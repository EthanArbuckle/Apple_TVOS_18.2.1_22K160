void sub_10059B3F4( _Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20, uint64_t a21, uint64_t a22, uint64_t a23, uint64_t a24, uint64_t a25, uint64_t a26, uint64_t a27, uint64_t a28, uint64_t a29, uint64_t a30, uint64_t a31, uint64_t a32, void *a33)
{
  void *v33;
  void *v34;

  _Unwind_Resume(a1);
}

uint64_t sub_10059B4A0(uint64_t a1, uint64_t a2)
{
  BYTE4(v4) = 0;
  LODWORD(v4) = *(_DWORD *)(a1 + 76);
  WORD2(v3) = 0;
  LODWORD(v3) = 0;
  return (*(uint64_t (**)(uint64_t, void, void, void, void, void, void, void, uint64_t, uint64_t))(*(void *)a2 + 72LL))( a2,  *(void *)(a1 + 32),  *(unsigned int *)(a1 + 56),  *(unsigned int *)(a1 + 64),  *(unsigned int *)(a1 + 60),  0LL,  0LL,  0LL,  v3,  v4);
}

uint64_t sub_10059B4F8(uint64_t a1, uint64_t a2)
{
  BYTE4(v4) = 0;
  LODWORD(v4) = *(_DWORD *)(a1 + 76);
  WORD2(v3) = 0;
  LODWORD(v3) = 0;
  return (*(uint64_t (**)(uint64_t, void, void, void, void, void, void, void, uint64_t, uint64_t))(*(void *)a2 + 72LL))( a2,  *(void *)(a1 + 32),  *(unsigned int *)(a1 + 56),  *(unsigned int *)(a1 + 64),  *(unsigned int *)(a1 + 60),  0LL,  0LL,  0LL,  v3,  v4);
}

uint64_t sub_10059B550(uint64_t a1, uint64_t a2)
{
  BYTE4(v4) = 0;
  LODWORD(v4) = *(_DWORD *)(a1 + 76);
  WORD2(v3) = 0;
  LODWORD(v3) = 0;
  return (*(uint64_t (**)(uint64_t, void, void, void, void, void, void, void, uint64_t, uint64_t))(*(void *)a2 + 72LL))( a2,  *(void *)(a1 + 32),  *(unsigned int *)(a1 + 56),  *(unsigned int *)(a1 + 64),  *(unsigned int *)(a1 + 60),  0LL,  0LL,  0LL,  v3,  v4);
}

uint64_t sub_10059B5A8(uint64_t a1, uint64_t a2)
{
  BYTE4(v4) = 0;
  LODWORD(v4) = *(_DWORD *)(a1 + 76);
  WORD2(v3) = 0;
  LODWORD(v3) = 0;
  return (*(uint64_t (**)(uint64_t, void, void, void, void, void, void, void, uint64_t, uint64_t))(*(void *)a2 + 72LL))( a2,  *(void *)(a1 + 32),  *(unsigned int *)(a1 + 56),  *(unsigned int *)(a1 + 64),  *(unsigned int *)(a1 + 60),  0LL,  0LL,  0LL,  v3,  v4);
}

uint64_t sub_10059B600(uint64_t a1, uint64_t a2)
{
  BYTE4(v4) = 0;
  LODWORD(v4) = *(_DWORD *)(a1 + 76);
  WORD2(v3) = 0;
  LODWORD(v3) = 0;
  return (*(uint64_t (**)(uint64_t, void, void, void, void, void, void, void, uint64_t, uint64_t))(*(void *)a2 + 72LL))( a2,  *(void *)(a1 + 32),  *(unsigned int *)(a1 + 56),  *(unsigned int *)(a1 + 64),  *(unsigned int *)(a1 + 60),  0LL,  0LL,  0LL,  v3,  v4);
}

void sub_10059B658(uint64_t a1)
{
  uint64_t v2 = sub_1002E6E00();
  sub_10002418C(buf, "LE");
  sub_10002418C(__p, "EnableRSSIDetectionDebuggingUseCase");
  (*(void (**)(uint64_t, _BYTE *, void **, int *))(*(void *)v2 + 88LL))(v2, buf, __p, &dword_1008F1D00);
  if (v7 < 0) {
    operator delete(__p[0]);
  }
  if (v9 < 0) {
    operator delete(*(void **)buf);
  }
  uint64_t v3 = sub_1002E6E00();
  sub_10002418C(buf, "LE");
  sub_10002418C(__p, "EnableRSSIDetectionDebugging");
  (*(void (**)(uint64_t, _BYTE *, void **, char *))(*(void *)v3 + 72LL))(v3, buf, __p, &byte_1008F1D04);
  if (v7 < 0) {
    operator delete(__p[0]);
  }
  if (v9 < 0) {
    operator delete(*(void **)buf);
  }
  uint64_t v4 = (os_log_s *)qword_1008F7620;
  if (os_log_type_enabled((os_log_t)qword_1008F7620, OS_LOG_TYPE_DEFAULT))
  {
    uint64_t v5 = *(void *)(a1 + 32);
    *(_DWORD *)buf = 138543362;
    *(void *)&buf[4] = v5;
    _os_log_impl( (void *)&_mh_execute_header,  v4,  OS_LOG_TYPE_DEFAULT,  "RSSI Detection Debugging enabled for %{public}@. ",  buf,  0xCu);
  }

void sub_10059B7CC( _Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void *__p, uint64_t a11, int a12, __int16 a13, char a14, char a15, void *a16, uint64_t a17, int a18, __int16 a19, char a20, char a21)
{
  if (a15 < 0) {
    operator delete(__p);
  }
  if (a21 < 0) {
    operator delete(a16);
  }
  _Unwind_Resume(exception_object);
}

uint64_t sub_10059B810(uint64_t a1, uint64_t a2)
{
  BYTE4(v4) = 0;
  LODWORD(v4) = *(_DWORD *)(a1 + 76);
  WORD2(v3) = 0;
  LODWORD(v3) = 0;
  return (*(uint64_t (**)(uint64_t, void, void, void, void, void, void, void, uint64_t, uint64_t))(*(void *)a2 + 72LL))( a2,  *(void *)(a1 + 32),  *(unsigned int *)(a1 + 56),  *(unsigned int *)(a1 + 64),  *(unsigned int *)(a1 + 60),  0LL,  0LL,  0LL,  v3,  v4);
}

uint64_t sub_10059B868(uint64_t a1, uint64_t a2, int a3, void *a4, int a5, uint64_t a6)
{
  id v11 = a4;
  *(void *)src = 0LL;
  uint64_t v33 = 0LL;
  sub_100241F90(src, v11);
  if (uuid_is_null(v12))
  {
    if (os_log_type_enabled((os_log_t)qword_1008F7620, OS_LOG_TYPE_ERROR)) {
      sub_1006986C0();
    }
    v28[0] = _NSConcreteStackBlock;
    v28[1] = 3321888768LL;
    v28[2] = sub_10059BBEC;
    v28[3] = &unk_1008A24C0;
    uuid_copy(v31, src);
    int v30 = a5;
    uint64_t v13 = 7LL;
    int v29 = 7;
    sub_10058C72C((os_unfair_lock_s *)a1, v28);
  }

  else
  {
    v22[0] = 0LL;
    v22[1] = 0LL;
    sub_100242F28((uint64_t)v22, a1 + 120);
    if (a1 + 392 == sub_1001FDB10(a1 + 384, src))
    {
      if (os_log_type_enabled((os_log_t)qword_1008F7620, OS_LOG_TYPE_ERROR))
      {
        v15 = sub_100241F94(src);
        objc_claimAutoreleasedReturnValue(v15);
        sub_10069861C();
      }

      sub_100242F54((uint64_t)v22);
      v23[0] = _NSConcreteStackBlock;
      v23[1] = 3321888768LL;
      v23[2] = sub_10059BC64;
      v23[3] = &unk_1008A24C0;
      uuid_copy(v26, src);
      int v25 = a5;
      uint64_t v13 = 312LL;
      int v24 = 312;
      sub_10058C72C((os_unfair_lock_s *)a1, v23);
    }

    else if (sub_100599F74(a1, a2, src) || a1 + 672 == sub_1001FDB10(a1 + 664, src))
    {
      if (a3)
      {
        v27 = src;
        sub_1005BD7D0( (uint64_t **)(a1 + 664),  src,  (uint64_t)&unk_1006C2518,  (const unsigned __int8 *__attribute__((__org_typedef(uuid_t))) *)&v27)[6] = a2;
        uint64_t v14 = sub_1002E6E9C();
        (*(void (**)(uint64_t, void, void, uint64_t))(*(void *)v14 + 1768LL))( v14,  (unsigned __int16)a5,  HIWORD(a5),  a6);
      }

      else
      {
        v16 = (uint64_t *)sub_1001FDB10(a1 + 664, src);
        if ((uint64_t *)(a1 + 672) != v16)
        {
          sub_1001FDBCC((uint64_t **)(a1 + 664), v16);
          operator delete(v16);
        }
      }

      uint64_t v13 = 0LL;
    }

    else
    {
      sub_100242F54((uint64_t)v22);
      if (os_log_type_enabled((os_log_t)qword_1008F7620, OS_LOG_TYPE_ERROR)) {
        sub_10069865C();
      }
      v18[0] = _NSConcreteStackBlock;
      v18[1] = 3221225472LL;
      v18[2] = sub_10059BCDC;
      v18[3] = &unk_1008A24F8;
      id v19 = v11;
      int v21 = a5;
      int v20 = 2100;
      sub_10058C72C((os_unfair_lock_s *)a1, v18);

      uint64_t v13 = 2100LL;
    }

    sub_100242FAC((uint64_t)v22);
  }

  return v13;
}

void sub_10059BBA0( _Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, ...)
{
  _Unwind_Resume(a1);
}

void sub_10059BBEC(uint64_t a1, uint64_t a2)
{
  uint64_t v3 = sub_100241F94((const unsigned __int8 *)(a1 + 40));
  id v4 = (id)objc_claimAutoreleasedReturnValue(v3);
  (*(void (**)(uint64_t))(*(void *)a2 + 80LL))(a2);
}

void sub_10059BC50( _Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, id a10)
{
}

void sub_10059BC64(uint64_t a1, uint64_t a2)
{
  uint64_t v3 = sub_100241F94((const unsigned __int8 *)(a1 + 40));
  id v4 = (id)objc_claimAutoreleasedReturnValue(v3);
  (*(void (**)(uint64_t))(*(void *)a2 + 80LL))(a2);
}

void sub_10059BCC8( _Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, id a10)
{
}

uint64_t sub_10059BCDC(uint64_t a1, uint64_t a2)
{
  return (*(uint64_t (**)(uint64_t, void, void, void, void, void, void))(*(void *)a2 + 80LL))( a2,  *(void *)(a1 + 32),  *(unsigned __int16 *)(a1 + 44),  *(unsigned __int16 *)(a1 + 46),  0LL,  0LL,  *(unsigned int *)(a1 + 40));
}

uint64_t sub_10059BD08( uint64_t a1, unint64_t a2, int a3, void *a4, uint64_t a5, __int128 *a6, uint64_t a7, void *a8)
{
  unint64_t v55 = a2;
  id v15 = a4;
  id v16 = a8;
  *(void *)src = 0LL;
  uint64_t v69 = 0LL;
  v17 = (const unsigned __int8 *)sub_100241F90(src, v15);
  if (!uuid_is_null(v17))
  {
    v54[0] = 0LL;
    v54[1] = 0LL;
    sub_100242F28((uint64_t)v54, a1 + 120);
    if (a1 + 392 == sub_1001FDB10(a1 + 384, src) && a3)
    {
      if (os_log_type_enabled((os_log_t)qword_1008F7620, OS_LOG_TYPE_ERROR))
      {
        int v20 = sub_100241F94(src);
        objc_claimAutoreleasedReturnValue(v20);
        sub_10069861C();
      }

      sub_100242F54((uint64_t)v54);
      v58[0] = _NSConcreteStackBlock;
      v58[1] = 3321888768LL;
      v58[2] = sub_10059C2B4;
      v58[3] = &unk_1008A2518;
      uuid_copy(v62, src);
      __int128 v21 = a6[1];
      __int128 v59 = *a6;
      __int128 v60 = v21;
      uint64_t v19 = 312LL;
      int v61 = 312;
      sub_10058C72C((os_unfair_lock_s *)a1, v58);
      goto LABEL_74;
    }

    sub_100242F54((uint64_t)v54);
    if (!sub_100599FF0(a1, a2, src))
    {
      v22 = (os_log_s *)qword_1008F7620;
      if (os_log_type_enabled((os_log_t)qword_1008F7620, OS_LOG_TYPE_ERROR))
      {
        v23 = sub_100241F94(src);
        int v24 = (void *)objc_claimAutoreleasedReturnValue(v23);
        sub_100698724((uint64_t)v16, v24, (uint64_t)v57, v22);
      }
    }

    int v25 = (uint64_t **)(a1 + 688);
    if (a3)
    {
      v56 = &v55;
      v26 = sub_1005BD8E8((uint64_t)v25, &v55, (uint64_t)&unk_1006C2518, &v56);
      uuid_copy((unsigned __int8 *)v26 + 40, src);
      v56 = &v55;
      *((_WORD *)sub_100411CA0((uint64_t **)(a1 + 712), &v55, (uint64_t)&unk_1006C2518, &v56) + 20) = a5;
      uint64_t v27 = sub_1002E6E9C();
      v28 = *(void **)(a1 + 712);
      if (v28 != (void *)(a1 + 720))
      {
        do
        {
          else {
            a5 = *((unsigned __int16 *)v28 + 20);
          }
          int v29 = (void *)v28[1];
          if (v29)
          {
            do
            {
              int v30 = v29;
              int v29 = (void *)*v29;
            }

            while (v29);
          }

          else
          {
            do
            {
              int v30 = (void *)v28[2];
              BOOL v31 = *v30 == (void)v28;
              v28 = v30;
            }

            while (!v31);
          }

          v28 = v30;
        }

        while (v30 != (void *)(a1 + 720));
      }

      (*(void (**)(uint64_t, uint64_t, uint64_t, uint64_t))(*(void *)v27 + 1776LL))(v27, 1LL, a5, a7);
      goto LABEL_73;
    }

    v32 = *(void **)(a1 + 696);
    if (!v32) {
      goto LABEL_36;
    }
    uint64_t v33 = (uint64_t *)(a1 + 696);
    do
    {
      unint64_t v34 = v32[4];
      BOOL v35 = v34 >= a2;
      if (v34 >= a2) {
        v36 = v32;
      }
      else {
        v36 = v32 + 1;
      }
      if (v35) {
        uint64_t v33 = v32;
      }
      v32 = (void *)*v36;
    }

    while (*v36);
    if (v33 != (uint64_t *)(a1 + 696) && v33[4] <= a2)
    {
      sub_1001FDBCC(v25, v33);
      operator delete(v33);
      int v37 = 1;
    }

    else
    {
LABEL_36:
      int v37 = 0;
    }

    v38 = (uint64_t **)(a1 + 712);
    v39 = (uint64_t *)(a1 + 720);
    v40 = *(void **)(a1 + 720);
    if (v40)
    {
      v41 = (uint64_t *)(a1 + 720);
      do
      {
        unint64_t v42 = v40[4];
        BOOL v43 = v42 >= a2;
        if (v42 >= a2) {
          v44 = v40;
        }
        else {
          v44 = v40 + 1;
        }
        if (v43) {
          v41 = v40;
        }
        v40 = (void *)*v44;
      }

      while (*v44);
      if (v41 != v39 && v41[4] <= a2)
      {
        sub_1001FDBCC(v38, v41);
        operator delete(v41);
      }
    }

    v45 = *v38;
    if (*v38 == v39)
    {
      if (!v37)
      {
LABEL_73:
        uint64_t v19 = 0LL;
LABEL_74:
        sub_100242FAC((uint64_t)v54);
        goto LABEL_75;
      }

      uint64_t v46 = sub_1002E6E9C();
      v50 = *v38;
      if (*v38 != v39)
      {
        do
        {
          else {
            a5 = *((unsigned __int16 *)v50 + 20);
          }
          v51 = (uint64_t *)v50[1];
          if (v51)
          {
            do
            {
              v52 = v51;
              v51 = (uint64_t *)*v51;
            }

            while (v51);
          }

          else
          {
            do
            {
              v52 = (uint64_t *)v50[2];
              BOOL v31 = *v52 == (void)v50;
              v50 = v52;
            }

            while (!v31);
          }

          v50 = v52;
        }

        while (v52 != v39);
      }
    }

    else
    {
      uint64_t v46 = sub_1002E6E9C();
      a5 = *((unsigned __int16 *)v45 + 20);
      v47 = *v38;
      if (*v38 != v39)
      {
        do
        {
          else {
            a5 = *((unsigned __int16 *)v47 + 20);
          }
          v48 = (uint64_t *)v47[1];
          if (v48)
          {
            do
            {
              v49 = v48;
              v48 = (uint64_t *)*v48;
            }

            while (v48);
          }

          else
          {
            do
            {
              v49 = (uint64_t *)v47[2];
              BOOL v31 = *v49 == (void)v47;
              v47 = v49;
            }

            while (!v31);
          }

          v47 = v49;
        }

        while (v49 != v39);
      }
    }

    (*(void (**)(uint64_t, BOOL, uint64_t, uint64_t))(*(void *)v46 + 1776LL))(v46, v45 != v39, a5, a7);
    goto LABEL_73;
  }

  if (os_log_type_enabled((os_log_t)qword_1008F7620, OS_LOG_TYPE_ERROR)) {
    sub_10069877C();
  }
  v63[0] = _NSConcreteStackBlock;
  v63[1] = 3321888768LL;
  v63[2] = sub_10059C22C;
  v63[3] = &unk_1008A2518;
  uuid_copy(v67, src);
  __int128 v18 = a6[1];
  __int128 v64 = *a6;
  __int128 v65 = v18;
  uint64_t v19 = 7LL;
  int v66 = 7;
  sub_10058C72C((os_unfair_lock_s *)a1, v63);
LABEL_75:

  return v19;
}

void sub_10059C1EC(_Unwind_Exception *a1, uint64_t a2, ...)
{
  _Unwind_Resume(a1);
}

void sub_10059C22C(uint64_t a1, uint64_t a2)
{
  id v4 = sub_100241F94((const unsigned __int8 *)(a1 + 68));
  uint64_t v5 = (void *)objc_claimAutoreleasedReturnValue(v4);
  __int128 v6 = *(_OWORD *)(a1 + 48);
  v7[0] = *(_OWORD *)(a1 + 32);
  v7[1] = v6;
  (*(void (**)(uint64_t, void *, _OWORD *, void))(*(void *)a2 + 88LL))( a2,  v5,  v7,  *(unsigned int *)(a1 + 64));
}

void sub_10059C294(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_10059C2A4(uint64_t a1, uint64_t a2)
{
}

void sub_10059C2B4(uint64_t a1, uint64_t a2)
{
  id v4 = sub_100241F94((const unsigned __int8 *)(a1 + 68));
  uint64_t v5 = (void *)objc_claimAutoreleasedReturnValue(v4);
  __int128 v6 = *(_OWORD *)(a1 + 48);
  v7[0] = *(_OWORD *)(a1 + 32);
  v7[1] = v6;
  (*(void (**)(uint64_t, void *, _OWORD *, void))(*(void *)a2 + 88LL))( a2,  v5,  v7,  *(unsigned int *)(a1 + 64));
}

void sub_10059C31C(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_10059C32C( int a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, unsigned __int8 a9, unsigned __int8 a10, unsigned __int8 a11, unsigned __int16 a12, unsigned __int16 a13, unsigned __int16 a14, unsigned __int16 a15, unsigned __int16 a16, unsigned __int8 a17)
{
  v22 = (os_log_s *)qword_1008F7620;
  if (os_log_type_enabled((os_log_t)qword_1008F7620, OS_LOG_TYPE_DEFAULT))
  {
    *(_DWORD *)buf = 67113216;
    int v27 = a1;
    __int16 v28 = 1024;
    int v29 = a2;
    __int16 v30 = 1024;
    int v31 = a3;
    __int16 v32 = 1024;
    int v33 = a4;
    __int16 v34 = 1024;
    int v35 = a5;
    __int16 v36 = 1024;
    int v37 = a6;
    __int16 v38 = 1024;
    int v39 = a7;
    __int16 v40 = 1024;
    int v41 = a8;
    __int16 v42 = 1024;
    int v43 = a9;
    __int16 v44 = 1024;
    int v45 = a10;
    __int16 v46 = 1024;
    int v47 = a11;
    __int16 v48 = 1024;
    int v49 = a12;
    __int16 v50 = 1024;
    int v51 = a13;
    __int16 v52 = 1024;
    int v53 = a14;
    __int16 v54 = 1024;
    int v55 = a15;
    __int16 v56 = 1024;
    int v57 = a16;
    __int16 v58 = 1024;
    int v59 = a17;
    _os_log_impl( (void *)&_mh_execute_header,  v22,  OS_LOG_TYPE_DEFAULT,  "Cscb: csLeLocalSupportedCapabilitiesCB status=%{bluetooth:OI_STATUS}u numConfig:%d maxProc:%d numAnt:%d rolesSup:% d modeSup:%d rttCap:%d rttCoarseN:%d rttSoundingN:%d rttRandomPayloadN:%d SyncPhy%d:%d:%d:%d FcsTime:%d %d:%d",  buf,  0x68u);
  }

  BYTE12(xmmword_1008F6D58) = a2;
  HIWORD(xmmword_1008F6D58) = a3;
  byte_1008F6D68 = a4;
  byte_1008F6D69 = a5;
  byte_1008F6D6A = a6;
  byte_1008F6D6B = a7;
  byte_1008F6D6C = a8;
  byte_1008F6D6D = a9;
  byte_1008F6D6E = a10;
  byte_1008F6D6F = a11;
  word_1008F6D70 = a12;
  word_1008F6D72 = a13;
  word_1008F6D74 = a14;
  word_1008F6D76 = a15;
  LOWORD(dword_1008F6D78) = a16;
  BYTE2(dword_1008F6D78) = a17;
  sub_1002431FC(&stru_1008F7938);
  byte_1008F79A8 = 0;
}

uint64_t sub_10059C560()
{
  char v19 = 0;
  sub_100242CA4(&v19);
  uint64_t v6 = sub_1001214B4(259, (uint64_t)sub_10059C32C, v0, v1, v2, v3, v4, v5, v18);
  sub_100242CD0(&v19);
  char v7 = (os_log_s *)qword_1008F7620;
  if (os_log_type_enabled((os_log_t)qword_1008F7620, OS_LOG_TYPE_DEFAULT))
  {
    *(_DWORD *)buf = 67109120;
    *(_DWORD *)&uint8_t buf[4] = v6;
    _os_log_impl( (void *)&_mh_execute_header,  v7,  OS_LOG_TYPE_DEFAULT,  "csReadLocalSupportedCapabilities status:%d",  buf,  8u);
  }

  byte_1008F79A8 = 1;
  if ((_DWORD)v6)
  {
    if (sub_1000A86F0())
    {
      sub_1001EE134((uint64_t)"CS read local capabilities failed with status %!", v8, v9, v10, v11, v12, v13, v14, v6);
      id v15 = (os_log_s *)sub_100086554(0x5Cu);
      if (os_log_type_enabled(v15, OS_LOG_TYPE_ERROR))
      {
        id v16 = sub_1001EDDCC();
        sub_1006987E4((uint64_t)v16, (uint64_t)buf);
      }
    }

    byte_1008F79A8 = 0;
  }

  else
  {
    *(void *)buf = 0LL;
    uint64_t v21 = 0LL;
    sub_100242F28((uint64_t)buf, (uint64_t)&unk_1008F7968);
    if (byte_1008F79A8) {
      sub_1002430FC(&stru_1008F7938, (pthread_mutex_t **)buf);
    }
    sub_100242F54((uint64_t)buf);
    sub_100242FAC((uint64_t)buf);
  }

  sub_100242CD8(&v19);
  return 0LL;
}

void sub_10059C6CC( _Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, int a10, __int16 a11, char a12, char a13)
{
}

uint64_t sub_10059C704(void *a1, uint64_t a2, uint64_t a3)
{
  v30[0] = 0LL;
  v30[1] = 0LL;
  sub_100241F90(v30, a3);
  if ((sub_100592970(a1, (unsigned __int8 *)v30) & 1) != 0 || sub_100595874((uint64_t)a1, (unsigned __int8 *)v30))
  {
    uint64_t v4 = 0LL;
  }

  else
  {
    uint64_t v5 = (os_log_s *)qword_1008F7620;
    if (os_log_type_enabled((os_log_t)qword_1008F7620, OS_LOG_TYPE_ERROR)) {
      sub_10069881C((const unsigned __int8 *)v30, v5);
    }
    uint64_t v4 = 312LL;
  }

  uint64_t v28 = 0LL;
  BOOL v6 = sub_100599890((uint64_t)a1, (unsigned __int8 *)v30, &v28);
  uint64_t v7 = v28;
  if (v28) {
    BOOL v8 = v6;
  }
  else {
    BOOL v8 = 0;
  }
  if (v8)
  {
    char v27 = 0;
    sub_100242CA4(&v27);
    if (sub_10012D5EC(v7))
    {
      uint64_t v16 = sub_100128D24(0x104u, v9, v10, v11, v12, v13, v14, v15, v7);
      if ((_DWORD)v16)
      {
        if (sub_1000A86F0())
        {
          sub_1001EE134( (uint64_t)"CS read remote capabilities failed with status %!",  v17,  v18,  v19,  v20,  v21,  v22,  v23,  v16);
          int v24 = (os_log_s *)sub_100086554(0x5Cu);
          if (os_log_type_enabled(v24, OS_LOG_TYPE_ERROR))
          {
            int v25 = sub_1001EDDCC();
            sub_1006987E4((uint64_t)v25, (uint64_t)v29);
          }
        }
      }
    }

    sub_100242CD8(&v27);
  }

  return v4;
}

void sub_10059C860( _Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, int a11, __int16 a12, char a13, char a14)
{
}

uint64_t sub_10059C884(void *a1, unint64_t a2, uint64_t a3, __int128 *a4)
{
  *(void *)src = 0LL;
  uint64_t v19 = 0LL;
  sub_100241F90(src, a3);
  uuid_copy(dst, src);
  uint64_t v7 = sub_10059C9E8((uint64_t)a1, a2, dst);
  if ((sub_100592970(a1, src) & 1) != 0 || sub_100595874((uint64_t)a1, src))
  {
    if (v7)
    {
      char v16 = 0;
      sub_100242CA4(&v16);
      uint64_t v15 = 0LL;
      BOOL v8 = sub_100599890((uint64_t)a1, src, &v15);
      if (v15) {
        BOOL v9 = v8;
      }
      else {
        BOOL v9 = 0;
      }
      if (v9)
      {
        __int128 v10 = a4[1];
        __int128 v13 = *a4;
        v14[0] = v10;
        *(_OWORD *)((char *)v14 + 10) = *(__int128 *)((char *)a4 + 26);
        sub_1001FF1BC((uint64_t)v7, v15, (unsigned __int16 *)&v13);
      }

      sub_100242CD0(&v16);
      sub_100242CD8(&v16);
    }

    return 0LL;
  }

  else
  {
    uint64_t v12 = (os_log_s *)qword_1008F7620;
    if (os_log_type_enabled((os_log_t)qword_1008F7620, OS_LOG_TYPE_ERROR)) {
      sub_1006988A4(src, v12);
    }
    return 312LL;
  }

void sub_10059C9CC( _Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, int a17, __int16 a18, char a19, char a20)
{
}

void *sub_10059C9E8(uint64_t a1, unint64_t a2, unsigned __int8 *uu)
{
  unint64_t v13 = a2;
  uint64_t v5 = *(void **)(a1 + 1392);
  if (!v5) {
    goto LABEL_12;
  }
  BOOL v6 = (void *)(a1 + 1392);
  do
  {
    unint64_t v7 = v5[4];
    BOOL v8 = v7 >= a2;
    if (v7 >= a2) {
      BOOL v9 = v5;
    }
    else {
      BOOL v9 = v5 + 1;
    }
    if (v8) {
      BOOL v6 = v5;
    }
    uint64_t v5 = (void *)*v9;
  }

  while (*v9);
  if (v6 != (void *)(a1 + 1392) && v6[4] <= a2)
  {
    __int128 v10 = (void *)v6[5];
    if (!uuid_is_null(uu) && a1 + 1416 == sub_1001FDB10(a1 + 1408, uu))
    {
      uint64_t v14 = (unint64_t *)uu;
      uint64_t v11 = (uint64_t **)(a1 + 1408);
      goto LABEL_14;
    }
  }

  else
  {
LABEL_12:
    __int128 v10 = operator new(0x170uLL);
    sub_1001FF028((uint64_t)v10);
    uint64_t v14 = &v13;
    sub_100029574((uint64_t **)(a1 + 1384), &v13, (uint64_t)&unk_1006C2518, (uint64_t **)&v14)[5] = (uint64_t)v10;
    if (!uuid_is_null(uu))
    {
      uint64_t v11 = (uint64_t **)(a1 + 1408);
      uint64_t v14 = (unint64_t *)uu;
LABEL_14:
      sub_1005BDA24( v11,  uu,  (uint64_t)&unk_1006C2518,  (const unsigned __int8 *__attribute__((__org_typedef(uuid_t))) *)&v14)[6] = (uint64_t)v10;
    }
  }

  return v10;
}

void sub_10059CB28(_Unwind_Exception *a1)
{
}

uint64_t sub_10059CB3C(void *a1, unint64_t a2, uint64_t a3)
{
  *(void *)src = 0LL;
  uint64_t v20 = 0LL;
  sub_100241F90(src, a3);
  uuid_copy(dst, src);
  uint64_t v5 = sub_10059C9E8((uint64_t)a1, a2, dst);
  if ((sub_100592970(a1, src) & 1) != 0 || sub_100595874((uint64_t)a1, src))
  {
    if (v5)
    {
      char v17 = 0;
      sub_100242CA4(&v17);
      uint64_t v16 = 0LL;
      BOOL v6 = sub_100599890((uint64_t)a1, src, &v16);
      if (v16) {
        BOOL v13 = v6;
      }
      else {
        BOOL v13 = 0;
      }
      if (v13) {
        sub_1001FF198((uint64_t)v5, v16, v7, v8, v9, v10, v11, v12);
      }
      sub_100242CD0(&v17);
      sub_100242CD8(&v17);
    }

    return 0LL;
  }

  else
  {
    uint64_t v15 = (os_log_s *)qword_1008F7620;
    if (os_log_type_enabled((os_log_t)qword_1008F7620, OS_LOG_TYPE_ERROR)) {
      sub_10069892C(src, v15);
    }
    return 312LL;
  }

void sub_10059CC64( _Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, int a11, __int16 a12, char a13, char a14)
{
}

uint64_t sub_10059CC80(void *a1, unint64_t a2, uint64_t a3)
{
  *(void *)src = 0LL;
  uint64_t v20 = 0LL;
  sub_100241F90(src, a3);
  uuid_copy(dst, src);
  uint64_t v5 = sub_10059C9E8((uint64_t)a1, a2, dst);
  if ((sub_100592970(a1, src) & 1) != 0 || sub_100595874((uint64_t)a1, src))
  {
    if (v5)
    {
      char v17 = 0;
      sub_100242CA4(&v17);
      uint64_t v16 = 0LL;
      BOOL v6 = sub_100599890((uint64_t)a1, src, &v16);
      if (v16) {
        BOOL v13 = v6;
      }
      else {
        BOOL v13 = 0;
      }
      if (v13) {
        sub_1001FF198((uint64_t)v5, v16, v7, v8, v9, v10, v11, v12);
      }
      sub_100242CD0(&v17);
      sub_100242CD8(&v17);
    }

    return 0LL;
  }

  else
  {
    uint64_t v15 = (os_log_s *)qword_1008F7620;
    if (os_log_type_enabled((os_log_t)qword_1008F7620, OS_LOG_TYPE_ERROR)) {
      sub_1006989B4(src, v15);
    }
    return 312LL;
  }

void sub_10059CDA8( _Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, int a11, __int16 a12, char a13, char a14)
{
}

uint64_t sub_10059CDC4(void *a1, unint64_t a2, uint64_t a3, unsigned __int16 *a4)
{
  *(void *)src = 0LL;
  uint64_t v35 = 0LL;
  sub_100241F90(src, a3);
  uuid_copy(dst, src);
  uint64_t v7 = sub_10059C9E8((uint64_t)a1, a2, dst);
  if ((sub_100592970(a1, src) & 1) != 0 || sub_100595874((uint64_t)a1, src))
  {
    uint64_t v8 = 0LL;
    if (!v7) {
      return v8;
    }
    goto LABEL_8;
  }

  uint64_t v9 = (os_log_s *)qword_1008F7620;
  if (os_log_type_enabled((os_log_t)qword_1008F7620, OS_LOG_TYPE_ERROR)) {
    sub_100698A3C(src, v9);
  }
  uint64_t v8 = 312LL;
  if (v7)
  {
LABEL_8:
    __int128 v10 = *((_OWORD *)a4 + 1);
    v27[0] = *(_OWORD *)a4;
    v27[1] = v10;
    v27[2] = *((_OWORD *)a4 + 2);
    int v28 = *((_DWORD *)a4 + 12);
    sub_1001FF954((uint64_t)v7, (unsigned __int16 *)v27);
    unsigned int v11 = *a4;
    if (v11 > 3)
    {
      uint64_t v20 = (os_log_s *)qword_1008F7620;
      if (os_log_type_enabled((os_log_t)qword_1008F7620, OS_LOG_TYPE_ERROR))
      {
        sub_100366664(src, __p);
        uint64_t v22 = v24 >= 0 ? __p : (void **)__p[0];
        *(_DWORD *)buf = 67109378;
        unsigned int v30 = v11;
        __int16 v31 = 2082;
        __int16 v32 = v22;
        _os_log_error_impl( (void *)&_mh_execute_header,  v20,  OS_LOG_TYPE_ERROR,  "Unsupported ConfigID:%d for   %{public}s ",  buf,  0x12u);
        if (v24 < 0) {
          operator delete(__p[0]);
        }
      }

      return 312LL;
    }

    else
    {
      buf[0] = 0;
      sub_100242CA4(buf);
      __p[0] = 0LL;
      BOOL v12 = sub_100599890((uint64_t)a1, src, __p);
      if (__p[0]) {
        BOOL v18 = v12;
      }
      else {
        BOOL v18 = 0;
      }
      if (v18)
      {
        __int128 v19 = *((_OWORD *)a4 + 1);
        v25[0] = *(_OWORD *)a4;
        v25[1] = v19;
        v25[2] = *((_OWORD *)a4 + 2);
        int v26 = *((_DWORD *)a4 + 12);
        sub_1001FF044((uint64_t)v7, (uint64_t)__p[0], (unsigned __int16 *)v25, v13, v14, v15, v16, v17);
      }

      sub_100242CD0(buf);
      sub_100242CD8(buf);
    }
  }

  return v8;
}

void sub_10059CFEC(_Unwind_Exception *a1)
{
}

uint64_t sub_10059D008(void *a1, unint64_t a2, void *a3, uint64_t a4)
{
  id v7 = a3;
  *(void *)uu = 0LL;
  uint64_t v34 = 0LL;
  sub_100241F90(uu, v7);
  uint64_t v8 = (void *)a1[174];
  if (!v8) {
    goto LABEL_12;
  }
  uint64_t v9 = a1 + 174;
  do
  {
    unint64_t v10 = v8[4];
    BOOL v11 = v10 >= a2;
    if (v10 >= a2) {
      BOOL v12 = v8;
    }
    else {
      BOOL v12 = v8 + 1;
    }
    if (v11) {
      uint64_t v9 = v8;
    }
    uint64_t v8 = (void *)*v12;
  }

  while (*v12);
  if (v9 != a1 + 174 && v9[4] <= a2)
  {
    uint64_t v18 = v9[5];
    if ((sub_100592970(a1, uu) & 1) != 0 || sub_100595874((uint64_t)a1, uu))
    {
      uint64_t v16 = 0LL;
    }

    else
    {
      if (os_log_type_enabled((os_log_t)qword_1008F7620, OS_LOG_TYPE_ERROR))
      {
        sub_100366664(uu, __p);
        sub_10069823C();
      }

      uint64_t v16 = 312LL;
    }

    char v27 = 0;
    sub_100242CA4(&v27);
    *(void *)buf = 0LL;
    BOOL v19 = sub_100599890((uint64_t)a1, uu, buf);
    if (*(void *)buf) {
      BOOL v25 = v19;
    }
    else {
      BOOL v25 = 0;
    }
    if (v25) {
      sub_1001FF140(v18, *(uint64_t *)buf, a4, v20, v21, v22, v23, v24);
    }
    sub_100242CD0(&v27);
    sub_100242CD8(&v27);
  }

  else
  {
LABEL_12:
    sub_100494958(a2, (uint64_t)__p);
    if (v36[7] >= 0) {
      uint64_t v13 = __p;
    }
    else {
      uint64_t v13 = (void **)__p[0];
    }
    uint64_t v14 = (void *)objc_claimAutoreleasedReturnValue(+[NSString stringWithUTF8String:](&OBJC_CLASS___NSString, "stringWithUTF8String:", v13));
    if ((v36[7] & 0x80000000) != 0) {
      operator delete(__p[0]);
    }
    uint64_t v15 = (os_log_s *)qword_1008F7620;
    if (os_log_type_enabled((os_log_t)qword_1008F7620, OS_LOG_TYPE_ERROR))
    {
      *(_OWORD *)__p = 0u;
      memset(v36, 0, sizeof(v36));
      uuid_unparse_upper(uu, (char *)__p);
      sub_10002418C(v28, (char *)__p);
      if (v29 >= 0) {
        int v26 = v28;
      }
      else {
        int v26 = (void **)v28[0];
      }
      *(_DWORD *)buf = 138543618;
      *(void *)&uint8_t buf[4] = v14;
      __int16 v31 = 2082;
      __int16 v32 = v26;
      _os_log_error_impl( (void *)&_mh_execute_header,  v15,  OS_LOG_TYPE_ERROR,  "Session %{public}@ for %{public}s is not found",  buf,  0x16u);
      if (v29 < 0) {
        operator delete(v28[0]);
      }
    }

    uint64_t v16 = 2300LL;
  }

  return v16;
}

void sub_10059D284( _Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, int a10, __int16 a11, char a12, char a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20, uint64_t a21, uint64_t a22, uint64_t a23, void *__p, uint64_t a25, int a26, __int16 a27, char a28, char a29)
{
  _Unwind_Resume(a1);
}

uint64_t sub_10059D2E0(void *a1, unint64_t a2, void *a3, uint64_t a4, uint64_t a5)
{
  id v9 = a3;
  *(void *)uu = 0LL;
  uint64_t v35 = 0LL;
  sub_100241F90(uu, v9);
  unint64_t v10 = (void *)a1[174];
  if (!v10) {
    goto LABEL_12;
  }
  BOOL v11 = a1 + 174;
  do
  {
    unint64_t v12 = v10[4];
    BOOL v13 = v12 >= a2;
    if (v12 >= a2) {
      uint64_t v14 = v10;
    }
    else {
      uint64_t v14 = v10 + 1;
    }
    if (v13) {
      BOOL v11 = v10;
    }
    unint64_t v10 = (void *)*v14;
  }

  while (*v14);
  if (v11 != a1 + 174 && v11[4] <= a2)
  {
    uint64_t v20 = v11[5];
    if ((sub_100592970(a1, uu) & 1) != 0 || sub_100595874((uint64_t)a1, uu))
    {
      LOBYTE(v28[0]) = 0;
      sub_100242CA4(v28);
      __p[0] = 0LL;
      BOOL v21 = sub_100599890((uint64_t)a1, uu, __p);
      if (__p[0]) {
        BOOL v26 = v21;
      }
      else {
        BOOL v26 = 0;
      }
      if (v26) {
        sub_1001FF168(v20, (uint64_t)__p[0], a4, a5, v22, v23, v24, v25);
      }
      sub_100242CD0(v28);
      sub_100242CD8(v28);
      uint64_t v18 = 0LL;
    }

    else
    {
      if (os_log_type_enabled((os_log_t)qword_1008F7620, OS_LOG_TYPE_ERROR))
      {
        sub_100366664(uu, __p);
        sub_10069823C();
      }

      uint64_t v18 = 312LL;
    }
  }

  else
  {
LABEL_12:
    sub_100494958(a2, (uint64_t)__p);
    if (v37[7] >= 0) {
      uint64_t v15 = __p;
    }
    else {
      uint64_t v15 = (void **)__p[0];
    }
    uint64_t v16 = (void *)objc_claimAutoreleasedReturnValue(+[NSString stringWithUTF8String:](&OBJC_CLASS___NSString, "stringWithUTF8String:", v15));
    if ((v37[7] & 0x80000000) != 0) {
      operator delete(__p[0]);
    }
    uint64_t v17 = (os_log_s *)qword_1008F7620;
    if (os_log_type_enabled((os_log_t)qword_1008F7620, OS_LOG_TYPE_ERROR))
    {
      *(_OWORD *)__p = 0u;
      memset(v37, 0, sizeof(v37));
      uuid_unparse_upper(uu, (char *)__p);
      sub_10002418C(v28, (char *)__p);
      if (v29 >= 0) {
        char v27 = v28;
      }
      else {
        char v27 = (void **)v28[0];
      }
      *(_DWORD *)buf = 138543618;
      __int16 v31 = v16;
      __int16 v32 = 2082;
      int v33 = v27;
      _os_log_error_impl( (void *)&_mh_execute_header,  v17,  OS_LOG_TYPE_ERROR,  "Session %{public}@ for %{public}s is not found",  buf,  0x16u);
      if (v29 < 0) {
        operator delete(v28[0]);
      }
    }

    uint64_t v18 = 2300LL;
  }

  return v18;
}

void sub_10059D564( _Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, void *__p, uint64_t a20, int a21, __int16 a22, char a23, char a24)
{
  _Unwind_Resume(a1);
}

uint64_t sub_10059D5C0(void *a1, unint64_t a2, void *a3, __int128 *a4)
{
  id v7 = a3;
  *(void *)uu = 0LL;
  uint64_t v36 = 0LL;
  sub_100241F90(uu, v7);
  uint64_t v8 = (void *)a1[174];
  if (!v8) {
    goto LABEL_12;
  }
  id v9 = a1 + 174;
  do
  {
    unint64_t v10 = v8[4];
    BOOL v11 = v10 >= a2;
    if (v10 >= a2) {
      unint64_t v12 = v8;
    }
    else {
      unint64_t v12 = v8 + 1;
    }
    if (v11) {
      id v9 = v8;
    }
    uint64_t v8 = (void *)*v12;
  }

  while (*v12);
  if (v9 != a1 + 174 && v9[4] <= a2)
  {
    uint64_t v18 = v9[5];
    if ((sub_100592970(a1, uu) & 1) != 0 || sub_100595874((uint64_t)a1, uu))
    {
      uint64_t v16 = 0LL;
    }

    else
    {
      if (os_log_type_enabled((os_log_t)qword_1008F7620, OS_LOG_TYPE_ERROR))
      {
        sub_100366664(uu, out);
        sub_10069823C();
      }

      uint64_t v16 = 312LL;
    }

    char v29 = 0;
    sub_100242CA4(&v29);
    *(void *)buf = 0LL;
    BOOL v19 = sub_100599890((uint64_t)a1, uu, buf);
    if (*(void *)buf) {
      BOOL v25 = v19;
    }
    else {
      BOOL v25 = 0;
    }
    if (v25)
    {
      __int128 v27 = *a4;
      uint64_t v28 = *((void *)a4 + 2);
      sub_1001FF268(v18, *(uint64_t *)buf, (uint64_t)&v27, v20, v21, v22, v23, v24);
    }

    sub_100242CD0(&v29);
    sub_100242CD8(&v29);
  }

  else
  {
LABEL_12:
    sub_100494958(a2, (uint64_t)out);
    if (out[23] >= 0) {
      BOOL v13 = out;
    }
    else {
      BOOL v13 = *(char **)out;
    }
    uint64_t v14 = (void *)objc_claimAutoreleasedReturnValue(+[NSString stringWithUTF8String:](&OBJC_CLASS___NSString, "stringWithUTF8String:", v13));
    if (out[23] < 0) {
      operator delete(*(void **)out);
    }
    uint64_t v15 = (os_log_s *)qword_1008F7620;
    if (os_log_type_enabled((os_log_t)qword_1008F7620, OS_LOG_TYPE_ERROR))
    {
      memset(out, 0, sizeof(out));
      uuid_unparse_upper(uu, out);
      sub_10002418C(__p, out);
      if (v31 >= 0) {
        BOOL v26 = __p;
      }
      else {
        BOOL v26 = (void **)__p[0];
      }
      *(_DWORD *)buf = 138543618;
      *(void *)&uint8_t buf[4] = v14;
      __int16 v33 = 2082;
      uint64_t v34 = v26;
      _os_log_error_impl( (void *)&_mh_execute_header,  v15,  OS_LOG_TYPE_ERROR,  "Session %{public}@ for %{public}s is not found",  buf,  0x16u);
      if (v31 < 0) {
        operator delete(__p[0]);
      }
    }

    uint64_t v16 = 2300LL;
  }

  return v16;
}

void sub_10059D84C(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

uint64_t sub_10059D8A8(uint64_t a1, unint64_t a2, uint64_t a3)
{
  BOOL v6 = sub_10059C9E8(a1, a2, uu);
  if (v6)
  {
    LOBYTE(__p[0]) = 0;
    sub_100242CA4(__p);
    uint64_t v7 = sub_10056AAF0(a3);
    sub_1001FF384((uint64_t)v6, v7, v8, v9, v10, v11, v12, v13);
    sub_100242CD0(__p);
    sub_100242CD8(__p);
    return 0LL;
  }

  else
  {
    sub_100494958(a2, (uint64_t)__p);
    if (v18 >= 0) {
      uint64_t v15 = __p;
    }
    else {
      uint64_t v15 = (void **)__p[0];
    }
    uint64_t v16 = (void *)objc_claimAutoreleasedReturnValue(+[NSString stringWithUTF8String:](&OBJC_CLASS___NSString, "stringWithUTF8String:", v15));
    if (v18 < 0) {
      operator delete(__p[0]);
    }
    if (os_log_type_enabled((os_log_t)qword_1008F7620, OS_LOG_TYPE_ERROR)) {
      sub_100698AC4();
    }

    return 2300LL;
  }

void sub_10059D9D8( _Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, void *__p, uint64_t a10, int a11, __int16 a12, char a13, char a14)
{
  if (a14 < 0) {
    operator delete(__p);
  }
  _Unwind_Resume(exception_object);
}

uint64_t sub_10059DA0C(void *a1, unint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6)
{
  v26[0] = 0LL;
  v26[1] = 0LL;
  sub_100241F90(v26, a3);
  uuid_clear(uu);
  uint64_t v11 = sub_10059C9E8((uint64_t)a1, a2, uu);
  if (v11)
  {
    if ((sub_100592970(a1, (unsigned __int8 *)v26) & 1) != 0 || sub_100595874((uint64_t)a1, (unsigned __int8 *)v26))
    {
      uint64_t v12 = 0LL;
    }

    else
    {
      uint64_t v15 = (os_log_s *)qword_1008F7620;
      if (os_log_type_enabled((os_log_t)qword_1008F7620, OS_LOG_TYPE_ERROR)) {
        sub_100698B28((const unsigned __int8 *)v26, v15);
      }
      uint64_t v12 = 312LL;
    }

    char v24 = 0;
    sub_100242CA4(&v24);
    __p[0] = 0LL;
    BOOL v16 = sub_100599890((uint64_t)a1, (unsigned __int8 *)v26, __p);
    if (__p[0]) {
      BOOL v20 = v16;
    }
    else {
      BOOL v20 = 0;
    }
    if (v20) {
      sub_1001FF450((uint64_t)v11, (uint64_t)__p[0], a4, a5, a6, v17, v18, v19);
    }
    sub_100242CD0(&v24);
    sub_100242CD8(&v24);
  }

  else
  {
    sub_100494958(a2, (uint64_t)__p);
    if (v23 >= 0) {
      uint64_t v13 = __p;
    }
    else {
      uint64_t v13 = (void **)__p[0];
    }
    uint64_t v14 = (void *)objc_claimAutoreleasedReturnValue(+[NSString stringWithUTF8String:](&OBJC_CLASS___NSString, "stringWithUTF8String:", v13));
    if (v23 < 0) {
      operator delete(__p[0]);
    }
    if (os_log_type_enabled((os_log_t)qword_1008F7620, OS_LOG_TYPE_ERROR)) {
      sub_100698AC4();
    }

    return 2300LL;
  }

  return v12;
}

void sub_10059DBD8( _Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void *__p, uint64_t a11, int a12, __int16 a13, char a14, char a15, int a16, __int16 a17, char a18, char a19)
{
  if (a15 < 0) {
    operator delete(__p);
  }
  _Unwind_Resume(exception_object);
}

uint64_t sub_10059DC14(uint64_t a1, unint64_t a2)
{
  uint64_t v4 = sub_10059C9E8(a1, a2, uu);
  if (v4)
  {
    LOBYTE(__p[0]) = 0;
    sub_100242CA4(__p);
    sub_1001FF52C((uint64_t)v4, v5, v6, v7, v8, v9, v10, v11);
    sub_100242CD0(__p);
    sub_100242CD8(__p);
    return 0LL;
  }

  else
  {
    sub_100494958(a2, (uint64_t)__p);
    if (v16 >= 0) {
      uint64_t v13 = __p;
    }
    else {
      uint64_t v13 = (void **)__p[0];
    }
    uint64_t v14 = (void *)objc_claimAutoreleasedReturnValue(+[NSString stringWithUTF8String:](&OBJC_CLASS___NSString, "stringWithUTF8String:", v13));
    if (v16 < 0) {
      operator delete(__p[0]);
    }
    if (os_log_type_enabled((os_log_t)qword_1008F7620, OS_LOG_TYPE_ERROR)) {
      sub_100698BB0();
    }

    return 2300LL;
  }

void sub_10059DD34( _Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, void *__p, uint64_t a10, int a11, __int16 a12, char a13, char a14)
{
  if (a14 < 0) {
    operator delete(__p);
  }
  _Unwind_Resume(exception_object);
}

uint64_t sub_10059DD68(void *a1, unint64_t a2, uint64_t a3)
{
  *(void *)src = 0LL;
  uint64_t v28 = 0LL;
  sub_100241F90(src, a3);
  uuid_copy(dst, src);
  uint64_t v5 = sub_10059C9E8((uint64_t)a1, a2, dst);
  if (v5)
  {
    if ((sub_100592970(a1, src) & 1) != 0 || sub_100595874((uint64_t)a1, src))
    {
      LOBYTE(__p[0]) = 0;
      sub_100242CA4(__p);
      *(void *)uuid_string_t out = 0LL;
      BOOL v6 = sub_100599890((uint64_t)a1, src, out);
      if (*(void *)out) {
        BOOL v13 = v6;
      }
      else {
        BOOL v13 = 0;
      }
      if (v13) {
        sub_1001FF650((uint64_t)v5, *(uint64_t *)out, v7, v8, v9, v10, v11, v12);
      }
      sub_100242CD0(__p);
      sub_100242CD8(__p);
      return 0LL;
    }

    else
    {
      uint64_t v18 = (os_log_s *)qword_1008F7620;
      if (os_log_type_enabled((os_log_t)qword_1008F7620, OS_LOG_TYPE_ERROR)) {
        sub_100698C14(src, v18);
      }
      return 312LL;
    }
  }

  else
  {
    sub_100494958(a2, (uint64_t)out);
    if (out[23] >= 0) {
      uint64_t v15 = out;
    }
    else {
      uint64_t v15 = *(char **)out;
    }
    char v16 = (void *)objc_claimAutoreleasedReturnValue(+[NSString stringWithUTF8String:](&OBJC_CLASS___NSString, "stringWithUTF8String:", v15));
    if (out[23] < 0) {
      operator delete(*(void **)out);
    }
    uint64_t v17 = (os_log_s *)qword_1008F7620;
    if (os_log_type_enabled((os_log_t)qword_1008F7620, OS_LOG_TYPE_ERROR))
    {
      memset(out, 0, sizeof(out));
      uuid_unparse_upper(src, out);
      sub_10002418C(__p, out);
      uint64_t v19 = v21 >= 0 ? __p : (void **)__p[0];
      *(_DWORD *)buf = 138543618;
      char v23 = v16;
      __int16 v24 = 2082;
      BOOL v25 = v19;
      _os_log_error_impl( (void *)&_mh_execute_header,  v17,  OS_LOG_TYPE_ERROR,  "Session %{public}@ for %{public}s is not found",  buf,  0x16u);
      if (v21 < 0) {
        operator delete(__p[0]);
      }
    }

    return 2300LL;
  }

void sub_10059DF94( _Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, char a10)
{
}

uint64_t sub_10059DFDC(uint64_t a1, uint64_t a2, void *a3, uint64_t a4, uint64_t a5)
{
  id v7 = a3;
  if (qword_1008D5F10 != -1) {
    dispatch_once(&qword_1008D5F10, &stru_1008A2B10);
  }
  uint64_t v8 = off_1008D5F08;
  sub_100241F90(&v18, v7);
  if (sub_100595874((uint64_t)v8, (unsigned __int8 *)&v18))
  {
    if (qword_1008D5F30 != -1) {
      dispatch_once(&qword_1008D5F30, &stru_1008A2B30);
    }
    uint64_t v9 = sub_1005CC198((uint64_t)off_1008D5F28, v7, 0);
    if (qword_1008D5F50 != -1) {
      dispatch_once(&qword_1008D5F50, &stru_1008A2BD0);
    }
    uint64_t v10 = sub_10040007C(off_1008D5F48, v9, 1);
    uint64_t v11 = sub_1002E6E9C();
    uint64_t v12 = (*(uint64_t (**)(uint64_t, uint64_t, void *, uint64_t))(*(void *)v11 + 152LL))(v11, a4, v10, a5);
    BOOL v13 = (os_log_s *)qword_1008F7620;
    if (os_log_type_enabled((os_log_t)qword_1008F7620, OS_LOG_TYPE_DEFAULT))
    {
      id v14 = sub_1005BFB9C(v9);
      uint64_t v15 = (void *)objc_claimAutoreleasedReturnValue(v14);
      int v18 = 138412290;
      id v19 = v15;
      _os_log_impl( (void *)&_mh_execute_header,  v13,  OS_LOG_TYPE_DEFAULT,  "MRC LE Address :    %@ ",  (uint8_t *)&v18,  0xCu);
    }
  }

  else
  {
    char v16 = (os_log_s *)qword_1008F7620;
    if (os_log_type_enabled((os_log_t)qword_1008F7620, OS_LOG_TYPE_DEFAULT))
    {
      int v18 = 138412290;
      id v19 = v7;
      _os_log_impl( (void *)&_mh_execute_header,  v16,  OS_LOG_TYPE_DEFAULT,  "MRC needs to have device connected   %@ ",  (uint8_t *)&v18,  0xCu);
    }

    uint64_t v12 = 312LL;
  }

  return v12;
}

void sub_10059E1F8(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

uint64_t sub_10059E21C(void *a1, unint64_t a2, void *a3, uint64_t a4)
{
  id v7 = a3;
  *(void *)uuid_t uu = 0LL;
  uint64_t v36 = 0LL;
  sub_100241F90(uu, v7);
  uint64_t v8 = (void *)a1[174];
  if (!v8) {
    goto LABEL_12;
  }
  uint64_t v9 = a1 + 174;
  do
  {
    unint64_t v10 = v8[4];
    BOOL v11 = v10 >= a2;
    if (v10 >= a2) {
      uint64_t v12 = v8;
    }
    else {
      uint64_t v12 = v8 + 1;
    }
    if (v11) {
      uint64_t v9 = v8;
    }
    uint64_t v8 = (void *)*v12;
  }

  while (*v12);
  if (v9 != a1 + 174 && v9[4] <= a2)
  {
    uint64_t v18 = v9[5];
    if ((sub_100592970(a1, uu) & 1) != 0 || sub_100595874((uint64_t)a1, uu))
    {
      uint64_t v16 = 0LL;
    }

    else
    {
      if (os_log_type_enabled((os_log_t)qword_1008F7620, OS_LOG_TYPE_ERROR))
      {
        sub_100366664(uu, __p);
        sub_10069823C();
      }

      uint64_t v16 = 312LL;
    }

    char v29 = 0;
    sub_100242CA4(&v29);
    *(void *)buf = 0LL;
    BOOL v19 = sub_100599890((uint64_t)a1, uu, buf);
    uint64_t v20 = *(void *)buf;
    if (*(void *)buf) {
      BOOL v21 = v19;
    }
    else {
      BOOL v21 = 0;
    }
    if (v21)
    {
      uint64_t v22 = sub_10056AAF0(a4);
      sub_1001FF674(v18, v20, v22, v23, v24, v25, v26, v27);
    }

    sub_100242CD0(&v29);
    sub_100242CD8(&v29);
  }

  else
  {
LABEL_12:
    sub_100494958(a2, (uint64_t)__p);
    if (v38[7] >= 0) {
      BOOL v13 = __p;
    }
    else {
      BOOL v13 = (void **)__p[0];
    }
    id v14 = (void *)objc_claimAutoreleasedReturnValue(+[NSString stringWithUTF8String:](&OBJC_CLASS___NSString, "stringWithUTF8String:", v13));
    if ((v38[7] & 0x80000000) != 0) {
      operator delete(__p[0]);
    }
    uint64_t v15 = (os_log_s *)qword_1008F7620;
    if (os_log_type_enabled((os_log_t)qword_1008F7620, OS_LOG_TYPE_ERROR))
    {
      *(_OWORD *)__p = 0u;
      memset(v38, 0, sizeof(v38));
      uuid_unparse_upper(uu, (char *)__p);
      sub_10002418C(v30, (char *)__p);
      if (v31 >= 0) {
        uint64_t v28 = v30;
      }
      else {
        uint64_t v28 = (void **)v30[0];
      }
      *(_DWORD *)buf = 138543618;
      *(void *)&uint8_t buf[4] = v14;
      __int16 v33 = 2082;
      uint64_t v34 = v28;
      _os_log_error_impl( (void *)&_mh_execute_header,  v15,  OS_LOG_TYPE_ERROR,  "Session %{public}@ for %{public}s is not found",  buf,  0x16u);
      if (v31 < 0) {
        operator delete(v30[0]);
      }
    }

    uint64_t v16 = 2300LL;
  }

  return v16;
}

void sub_10059E4A4( _Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, int a10, __int16 a11, char a12, char a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20, uint64_t a21, uint64_t a22, uint64_t a23, void *__p, uint64_t a25, int a26, __int16 a27, char a28, char a29)
{
  _Unwind_Resume(a1);
}

void sub_10059E500(uint64_t a1, uint64_t a2)
{
  uint64_t v2 = *(uint64_t **)(a1 + 1128);
  uint64_t v3 = (uint64_t *)(a1 + 1136);
  if (v2 != (uint64_t *)(a1 + 1136))
  {
    uint64_t v5 = (uint64_t **)(a1 + 1128);
    do
    {
      if ((unint64_t)(a2 - v2[5]) < 0x6FC23AC01LL)
      {
        unint64_t v10 = (uint64_t *)v2[1];
        if (v10)
        {
          do
          {
            uint64_t v9 = v10;
            unint64_t v10 = (uint64_t *)*v10;
          }

          while (v10);
        }

        else
        {
          do
          {
            uint64_t v9 = (uint64_t *)v2[2];
            BOOL v11 = *v9 == (void)v2;
            uint64_t v2 = v9;
          }

          while (!v11);
        }
      }

      else
      {
        BOOL v6 = (os_log_s *)qword_1008F7620;
        if (os_log_type_enabled((os_log_t)qword_1008F7620, OS_LOG_TYPE_DEFAULT))
        {
          id v7 = sub_1005BF848(v2[4]);
          uint64_t v8 = (void *)objc_claimAutoreleasedReturnValue(v7);
          *(_DWORD *)buf = 138543362;
          BOOL v13 = v8;
          _os_log_impl( (void *)&_mh_execute_header,  v6,  OS_LOG_TYPE_DEFAULT,  "Removing expired ExpectedIncomingAddress:%{public}@",  buf,  0xCu);
        }

        uint64_t v9 = sub_1001FDBCC(v5, v2);
        operator delete(v2);
      }

      uint64_t v2 = v9;
    }

    while (v9 != v3);
  }

void sub_10059E668(uint64_t a1, uint64_t a2)
{
  unint64_t v8 = a2;
  __uint64_t v3 = clock_gettime_nsec_np(_CLOCK_MONOTONIC);
  sub_10059E500(a1, v3);
  *(void *)buf = &v8;
  sub_100029574((uint64_t **)(a1 + 1128), &v8, (uint64_t)&unk_1006C2518, (uint64_t **)buf)[5] = v3;
  uint64_t v4 = (os_log_s *)qword_1008F7620;
  if (os_log_type_enabled((os_log_t)qword_1008F7620, OS_LOG_TYPE_DEFAULT))
  {
    id v5 = sub_1005BF848(v8);
    BOOL v6 = (void *)objc_claimAutoreleasedReturnValue(v5);
    uint64_t v7 = *(void *)(a1 + 1144);
    *(_DWORD *)buf = 138543618;
    *(void *)&uint8_t buf[4] = v6;
    __int16 v10 = 2048;
    uint64_t v11 = v7;
    _os_log_impl( (void *)&_mh_execute_header,  v4,  OS_LOG_TYPE_DEFAULT,  "Adding address %{public}@ to fAddressForIncomingConnectionPrioritizationMap[%lu]",  buf,  0x16u);
  }

void sub_10059E778()
{
  uint64_t v0 = (os_log_s *)qword_1008F7620;
  if (os_log_type_enabled((os_log_t)qword_1008F7620, OS_LOG_TYPE_INFO))
  {
    *(_WORD *)uint64_t v1 = 0;
    _os_log_impl( (void *)&_mh_execute_header,  v0,  OS_LOG_TYPE_INFO,  "Stream state changed, re-evaluating scan params",  v1,  2u);
  }

void sub_10059E7DC()
{
}

uint64_t sub_10059E7E4(uint64_t a1, __int128 *a2)
{
  v24[0] = 0LL;
  v24[1] = 0LL;
  sub_100242F28((uint64_t)v24, a1 + 120);
  uint64_t v4 = sub_1002E6BF0();
  int v5 = (*(uint64_t (**)(uint64_t))(*(void *)v4 + 936LL))(v4);
  __int128 v20 = *a2;
  *(_OWORD *)(a1 + 288) = *a2;
  if (v5) {
    uint64_t v6 = *((void *)a2 + 2);
  }
  else {
    uint64_t v6 = 0LL;
  }
  *(void *)(a1 + 312) = v6;
  uint64_t v7 = (os_log_s *)qword_1008F7620;
  if (os_log_type_enabled((os_log_t)qword_1008F7620, OS_LOG_TYPE_DEFAULT))
  {
    id v8 = sub_1005BFB9C(v20);
    uint64_t v9 = (void *)objc_claimAutoreleasedReturnValue(v8);
    *(_DWORD *)buf = 138543362;
    *(void *)uint64_t v26 = v9;
    _os_log_impl( (void *)&_mh_execute_header,  v7,  OS_LOG_TYPE_DEFAULT,  "Local LE Connectable address is now %{public}@",  buf,  0xCu);

    uint64_t v7 = (os_log_s *)qword_1008F7620;
  }

  if (os_log_type_enabled(v7, OS_LOG_TYPE_DEFAULT))
  {
    id v10 = sub_1005BFB9C(*((void *)a2 + 1));
    uint64_t v11 = (void *)objc_claimAutoreleasedReturnValue(v10);
    *(_DWORD *)buf = 138543362;
    *(void *)uint64_t v26 = v11;
    _os_log_impl( (void *)&_mh_execute_header,  v7,  OS_LOG_TYPE_DEFAULT,  "Local LE Non-Connectable address is now %{public}@",  buf,  0xCu);

    uint64_t v7 = (os_log_s *)qword_1008F7620;
  }

  if (v5 && os_log_type_enabled(v7, OS_LOG_TYPE_DEFAULT))
  {
    id v12 = sub_1005BFB9C(*((void *)a2 + 2));
    BOOL v13 = (void *)objc_claimAutoreleasedReturnValue(v12);
    *(_DWORD *)buf = 138543362;
    *(void *)uint64_t v26 = v13;
    _os_log_impl( (void *)&_mh_execute_header,  v7,  OS_LOG_TYPE_DEFAULT,  "Local LE Non-Connectable Secondary address is now %{public}@",  buf,  0xCu);

    uint64_t v7 = (os_log_s *)qword_1008F7620;
  }

  if (os_log_type_enabled(v7, OS_LOG_TYPE_DEFAULT))
  {
    int v14 = *(unsigned __int8 *)(a1 + 184);
    uint64_t v15 = *(void *)(a1 + 352);
    uint64_t v16 = *(int *)(a1 + 864);
    else {
      uint64_t v17 = (&off_1008A2DC0)[v16];
    }
    *(_DWORD *)buf = 67109634;
    *(_DWORD *)uint64_t v26 = v14;
    *(_WORD *)&v26[4] = 2048;
    *(void *)&v26[6] = v15;
    __int16 v27 = 2082;
    uint64_t v28 = v17;
    _os_log_impl( (void *)&_mh_execute_header,  v7,  OS_LOG_TYPE_DEFAULT,  "fStarted:%d, fConnectingDevices.size:%lu, fConnectionState:%{public}s",  buf,  0x1Cu);
  }

  v21[0] = _NSConcreteStackBlock;
  v21[1] = 3221225472LL;
  v21[2] = sub_10059EB1C;
  v21[3] = &unk_1008A2548;
  __int128 v22 = *a2;
  uint64_t v23 = *((void *)a2 + 2);
  sub_10058C72C((os_unfair_lock_s *)a1, v21);
  if (*(_BYTE *)(a1 + 1066))
  {
    uint64_t v18 = (os_log_s *)qword_1008F7620;
    if (os_log_type_enabled((os_log_t)qword_1008F7620, OS_LOG_TYPE_DEFAULT))
    {
      *(_WORD *)buf = 0;
      _os_log_impl( (void *)&_mh_execute_header,  v18,  OS_LOG_TYPE_DEFAULT,  "Address change complete, will process connecting devices now",  buf,  2u);
    }

    *(_BYTE *)(a1 + 1066) = 0;
    if (!*(_DWORD *)(a1 + 864) && *(void *)(a1 + 352)) {
      sub_10059EB5C(a1);
    }
  }

  *(CFAbsoluteTime *)(a1 + 328) = CFAbsoluteTimeGetCurrent();
  return sub_100242FAC((uint64_t)v24);
}

void sub_10059EAF4( _Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, ...)
{
}

uint64_t sub_10059EB1C(uint64_t a1, uint64_t a2)
{
  __int128 v3 = *(_OWORD *)(a1 + 32);
  uint64_t v4 = *(void *)(a1 + 48);
  return (*(uint64_t (**)(uint64_t, __int128 *))(*(void *)a2 + 104LL))(a2, &v3);
}

uint64_t sub_10059EB5C(uint64_t a1)
{
  v83[0] = 0LL;
  v83[1] = 0LL;
  sub_100242F28((uint64_t)v83, a1 + 120);
  sub_1005AB264(a1);
  if (!*(_BYTE *)(a1 + 1067))
  {
    if (*(_DWORD *)(a1 + 928))
    {
      uint64_t v6 = (os_log_s *)qword_1008F7620;
      if (os_log_type_enabled((os_log_t)qword_1008F7620, OS_LOG_TYPE_FAULT))
      {
        *(_WORD *)buf = 0;
        _os_log_fault_impl( (void *)&_mh_execute_header,  v6,  OS_LOG_TYPE_FAULT,  "We should not get here, this is for debug purposes",  buf,  2u);
        uint64_t v6 = (os_log_s *)qword_1008F7620;
      }

      if (os_log_type_enabled(v6, OS_LOG_TYPE_ERROR)) {
        sub_100698D28();
      }
      return sub_100242FAC((uint64_t)v83);
    }

    if (*(_BYTE *)(a1 + 1065))
    {
      uint64_t v2 = qword_1008F7620;
      if (!os_log_type_enabled((os_log_t)qword_1008F7620, OS_LOG_TYPE_DEFAULT)) {
        return sub_100242FAC((uint64_t)v83);
      }
      *(_WORD *)buf = 0;
      __int128 v3 = "Controller Connection List is full, waiting for something to disconnect first";
      goto LABEL_4;
    }

    unsigned int v7 = *(_DWORD *)(a1 + 864);
    if (v7)
    {
      uint64_t v8 = qword_1008F7620;
      if (!os_log_type_enabled((os_log_t)qword_1008F7620, OS_LOG_TYPE_DEFAULT)) {
        return sub_100242FAC((uint64_t)v83);
      }
      if (v7 > 4) {
        uint64_t v9 = "UNKNOWN";
      }
      else {
        uint64_t v9 = off_1008A2C70[v7 - 1];
      }
      *(_DWORD *)buf = 136446466;
      *(void *)v85 = v9;
      *(_WORD *)&v85[8] = 1024;
      *(_DWORD *)v86 = v7;
      __int128 v3 = "Busy doing something else %{public}s(%d).";
      uint64_t v4 = (os_log_s *)v8;
      uint32_t v5 = 18;
      goto LABEL_5;
    }

    if (!*(void *)(a1 + 352))
    {
      id v10 = (os_log_s *)qword_1008F7620;
      if (os_log_type_enabled((os_log_t)qword_1008F7620, OS_LOG_TYPE_DEFAULT))
      {
        *(_WORD *)buf = 0;
        _os_log_impl((void *)&_mh_execute_header, v10, OS_LOG_TYPE_DEFAULT, "Connection list empty, skipping", buf, 2u);
      }

      sub_1005911F0(a1, 0);
      return sub_100242FAC((uint64_t)v83);
    }

    if (*(_BYTE *)(a1 + 1066))
    {
      uint64_t v2 = qword_1008F7620;
      if (!os_log_type_enabled((os_log_t)qword_1008F7620, OS_LOG_TYPE_DEFAULT)) {
        return sub_100242FAC((uint64_t)v83);
      }
      *(_WORD *)buf = 0;
      __int128 v3 = "Address change in progress, waiting for it to complete";
      goto LABEL_4;
    }

    int v82 = 0;
    unsigned __int16 v81 = 0;
    unsigned __int8 v80 = 0;
    sub_1005AC4A0(a1, (_WORD *)&v82 + 1, (unsigned __int16 *)&v82, &v81, &v80);
    if (*(_BYTE *)(a1 + 1075))
    {
      uint64_t v11 = (os_log_s *)qword_1008F7620;
      if (os_log_type_enabled((os_log_t)qword_1008F7620, OS_LOG_TYPE_DEFAULT))
      {
        int v12 = *(unsigned __int16 *)(a1 + 1078);
        int v13 = *(unsigned __int16 *)(a1 + 1076);
        *(_DWORD *)buf = 67109888;
        *(_DWORD *)v85 = HIWORD(v82);
        *(_WORD *)&v85[4] = 1024;
        *(_DWORD *)&v85[6] = (unsigned __int16)v82;
        *(_WORD *)v86 = 1024;
        *(_DWORD *)&v86[2] = v12;
        *(_WORD *)v87 = 1024;
        *(_DWORD *)&v87[2] = v13;
        _os_log_impl( (void *)&_mh_execute_header,  v11,  OS_LOG_TYPE_DEFAULT,  "Override MainCore Connection Scan: interval %d window %d by interval %d window %d",  buf,  0x1Au);
      }

      int v82 = *(_DWORD *)(a1 + 1076);
    }

    int v14 = *(const unsigned __int8 **)(a1 + 336);
    uint64_t v15 = (const unsigned __int8 *)(a1 + 344);
    char v16 = 1;
    if (v14 != (const unsigned __int8 *)(a1 + 344))
    {
      do
      {
        if (qword_1008D5F30 != -1) {
          dispatch_once(&qword_1008D5F30, &stru_1008A2B30);
        }
        uint64_t v17 = off_1008D5F28;
        uint64_t v18 = sub_100241F94(v14 + 25);
        BOOL v19 = (void *)objc_claimAutoreleasedReturnValue(v18);
        char v20 = sub_1005CF600((uint64_t)v17, v19);

        BOOL v21 = (const unsigned __int8 *)*((void *)v14 + 1);
        if (v21)
        {
          do
          {
            __int128 v22 = v21;
            BOOL v21 = *(const unsigned __int8 **)v21;
          }

          while (v21);
        }

        else
        {
          do
          {
            __int128 v22 = (const unsigned __int8 *)*((void *)v14 + 2);
            BOOL v23 = *(void *)v22 == (void)v14;
            int v14 = v22;
          }

          while (!v23);
        }

        v16 |= v20;
        int v14 = v22;
      }

      while (v22 != v15);
    }

    uint64_t v24 = sub_1002E6BF0();
    int v25 = (*(uint64_t (**)(uint64_t))(*(void *)v24 + 680LL))(v24);
    if ((v25 & 1) == 0)
    {
      uint64_t v26 = (os_log_s *)qword_1008F7620;
      if (os_log_type_enabled((os_log_t)qword_1008F7620, OS_LOG_TYPE_DEFAULT))
      {
        *(_WORD *)buf = 0;
        _os_log_impl( (void *)&_mh_execute_header,  v26,  OS_LOG_TYPE_DEFAULT,  "LELR is not enabled, disable coded PHY",  buf,  2u);
      }

      v16 &= ~4u;
    }

    uint64_t v27 = sub_1002E6BF0();
    else {
      unsigned __int8 v28 = v16;
    }
    char v29 = (os_log_s *)qword_1008F7620;
    if (os_log_type_enabled((os_log_t)qword_1008F7620, OS_LOG_TYPE_DEFAULT))
    {
      *(_DWORD *)buf = 67109888;
      *(_DWORD *)v85 = (unsigned __int16)v82;
      *(_WORD *)&v85[4] = 1024;
      *(_DWORD *)&v85[6] = HIWORD(v82);
      *(_WORD *)v86 = 1024;
      *(_DWORD *)&v86[2] = v25;
      *(_WORD *)v87 = 1024;
      *(_DWORD *)&v87[2] = v28;
      _os_log_impl( (void *)&_mh_execute_header,  v29,  OS_LOG_TYPE_DEFAULT,  "Next connection parameters are: window - 0x%x, interval - 0x%x enableLELR - %d initPHYs - %x",  buf,  0x1Au);
      char v29 = (os_log_s *)qword_1008F7620;
    }

    if (os_log_type_enabled(v29, OS_LOG_TYPE_DEFAULT))
    {
      uint64_t v30 = *(void *)(a1 + 352);
      *(_DWORD *)buf = 134217984;
      *(void *)v85 = v30;
      _os_log_impl( (void *)&_mh_execute_header,  v29,  OS_LOG_TYPE_DEFAULT,  "Starting auto connection for %lu devices",  buf,  0xCu);
    }

    uint64_t v31 = sub_1002E6BF0();
    if ((*(unsigned int (**)(uint64_t))(*(void *)v31 + 648LL))(v31))
    {
      uint64_t v32 = v81;
      BOOL v33 = v81 != 0;
      int v34 = HIWORD(v82);
      if (v81) {
        uint64_t v35 = HIWORD(v82);
      }
      else {
        uint64_t v35 = 0LL;
      }
      if (*(_BYTE *)(a1 + 1116) != v33)
      {
        *(_BYTE *)(a1 + 1116) = v33;
        if ((_DWORD)v32) {
          uint64_t v36 = &stru_1008A28E0;
        }
        else {
          uint64_t v36 = &stru_1008A2900;
        }
        sub_10058C72C((os_unfair_lock_s *)a1, v36);
      }

      int v37 = (os_log_s *)qword_1008F7620;
      if (*(_BYTE *)(a1 + 1068))
      {
        if (os_log_type_enabled((os_log_t)qword_1008F7620, OS_LOG_TYPE_DEFAULT))
        {
          __int16 v38 = "No";
          int v39 = *(unsigned __int16 *)(a1 + 1072);
          if ((_DWORD)v32) {
            __int16 v40 = "Yes";
          }
          else {
            __int16 v40 = "No";
          }
          int v41 = *(unsigned __int16 *)(a1 + 1070);
          if (*(_BYTE *)(a1 + 1074)) {
            __int16 v38 = "Yes";
          }
          *(_DWORD *)buf = 136447490;
          *(void *)v85 = v40;
          *(_WORD *)&v85[8] = 1024;
          *(_DWORD *)v86 = v35;
          *(_WORD *)&v86[4] = 1024;
          *(_DWORD *)v87 = v32;
          *(_WORD *)&v87[4] = 2082;
          *(void *)v88 = v38;
          *(_WORD *)&v88[8] = 1024;
          int v89 = v39;
          __int16 v90 = 1024;
          int v91 = v41;
          _os_log_impl( (void *)&_mh_execute_header,  v37,  OS_LOG_TYPE_DEFAULT,  "Override ScanCore Connection Scan: enabled %{public}s interval %d window %d by enabled %{public}s interval %d window %d",  buf,  0x2Eu);
          int v37 = (os_log_s *)qword_1008F7620;
        }

        BOOL v33 = *(_BYTE *)(a1 + 1074) != 0;
        uint64_t v35 = *(unsigned __int16 *)(a1 + 1072);
        uint64_t v32 = *(unsigned __int16 *)(a1 + 1070);
        unsigned __int16 v81 = *(_WORD *)(a1 + 1070);
      }

      if (os_log_type_enabled(v37, OS_LOG_TYPE_DEFAULT))
      {
        __int16 v42 = "No";
        *(_DWORD *)buf = 136447234;
        if (v33) {
          __int16 v42 = "Yes";
        }
        *(void *)v85 = v42;
        *(_WORD *)&v85[8] = 1024;
        *(_DWORD *)v86 = v35;
        *(_WORD *)&v86[4] = 1024;
        *(_DWORD *)v87 = v32;
        *(_WORD *)&v87[4] = 1024;
        *(_DWORD *)v88 = v34;
        *(_WORD *)&v88[4] = 1024;
        *(_DWORD *)&v88[6] = (unsigned __int16)v82;
        _os_log_impl( (void *)&_mh_execute_header,  v37,  OS_LOG_TYPE_DEFAULT,  "ScanCore Connection Scan Params enabled %{public}s interval %d window %d with MainCore interval %d window %d",  buf,  0x24u);
      }

      uint64_t v43 = sub_1002E6E9C();
      int v44 = (*(uint64_t (**)(uint64_t, BOOL, uint64_t, uint64_t, void))(*(void *)v43 + 1808LL))( v43,  v33,  v35,  v32,  0LL);
      int v45 = (os_log_s *)qword_1008F7620;
      if (v44)
      {
        if (os_log_type_enabled((os_log_t)qword_1008F7620, OS_LOG_TYPE_DEFAULT))
        {
          *(_DWORD *)buf = 67109120;
          *(_DWORD *)v85 = v44;
          _os_log_impl( (void *)&_mh_execute_header,  v45,  OS_LOG_TYPE_DEFAULT,  "Failed to execute btscLeSetConnectionScan with error %d",  buf,  8u);
        }
      }

      else if (os_log_type_enabled((os_log_t)qword_1008F7620, OS_LOG_TYPE_DEBUG))
      {
        sub_100698CFC();
      }
    }

    char v79 = 0;
    sub_100242CA4(&v79);
    uint64_t v46 = HIWORD(v82);
    uint64_t v47 = (unsigned __int16)v82;
    int v48 = sub_1001BD390(HIWORD(v82), (unsigned __int16)v82, v28, 0LL, 0, 0, 0xFFu, 0xFFu);
    int v49 = sub_1001BD930();
    sub_100242CD0(&v79);
    if (v48 > 757)
    {
      if (v48 == 758)
      {
        if (qword_1008D5F10 != -1) {
          dispatch_once(&qword_1008D5F10, &stru_1008A2B10);
        }
        sub_1005911F0((uint64_t)off_1008D5F08, 4u);
        goto LABEL_106;
      }

      if (v48 == 1319 && v49)
      {
        __int16 v50 = (os_log_s *)qword_1008F7620;
        if (os_log_type_enabled((os_log_t)qword_1008F7620, OS_LOG_TYPE_DEFAULT))
        {
          *(_WORD *)buf = 0;
          int v51 = "We're busy disconnecting another device, lets wait before we issue another connection command";
          goto LABEL_88;
        }

void sub_10059F5FC( _Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, void *__p, uint64_t a10, int a11, __int16 a12, char a13, char a14, char a15, int a16, __int16 a17, char a18, char a19)
{
  if (a14 < 0) {
    operator delete(__p);
  }
  sub_100242CD8(&a15);
  sub_100242FAC((uint64_t)&a17);
  _Unwind_Resume(a1);
}

uint64_t sub_10059F678(uint64_t a1)
{
  v9[0] = 0LL;
  v9[1] = 0LL;
  sub_100242F28((uint64_t)v9, a1 + 120);
  uint64_t v2 = (os_log_s *)qword_1008F7620;
  if (os_log_type_enabled((os_log_t)qword_1008F7620, OS_LOG_TYPE_DEFAULT))
  {
    int v3 = *(unsigned __int8 *)(a1 + 184);
    uint64_t v4 = *(void *)(a1 + 352);
    uint64_t v5 = *(int *)(a1 + 864);
    else {
      uint64_t v6 = (&off_1008A2DC0)[v5];
    }
    *(_DWORD *)buf = 67109634;
    int v11 = v3;
    __int16 v12 = 2048;
    uint64_t v13 = v4;
    __int16 v14 = 2082;
    uint64_t v15 = v6;
    _os_log_impl( (void *)&_mh_execute_header,  v2,  OS_LOG_TYPE_DEFAULT,  "AddressWillChange event fStarted:%d, fConnectingDevices.size:%lu, fConnectionState:%{public}s",  buf,  0x1Cu);
  }

  if (*(_BYTE *)(a1 + 184) && *(void *)(a1 + 352) && *(_DWORD *)(a1 + 864) == 1)
  {
    *(_BYTE *)(a1 + 1066) = 1;
    unsigned int v7 = (os_log_s *)qword_1008F7620;
    if (os_log_type_enabled((os_log_t)qword_1008F7620, OS_LOG_TYPE_DEFAULT))
    {
      *(_WORD *)buf = 0;
      _os_log_impl( (void *)&_mh_execute_header,  v7,  OS_LOG_TYPE_DEFAULT,  "Cancelling connections due to advertising address changed",  buf,  2u);
    }

    sub_100590B30(a1, 0);
  }

  return sub_100242FAC((uint64_t)v9);
}

void sub_10059F7E4( _Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9)
{
}

void sub_10059F800(uint64_t a1, void *a2)
{
  id v3 = a2;
  v25[0] = 0LL;
  v25[1] = 0LL;
  sub_100242F28((uint64_t)v25, a1 + 120);
  [*(id *)(a1 + 768) removeObject:v3];
  [*(id *)(a1 + 792) removeObject:v3];
  sub_100241F90(&buf, v3);
  BOOL v19 = (uint64_t **)(a1 + 336);
  uint64_t v4 = sub_1005BD640(a1 + 336, (unsigned __int8 *)&buf);
  uint64_t v5 = (os_log_s *)qword_1008F7620;
  if (a1 + 344 == v4)
  {
    if (os_log_type_enabled((os_log_t)qword_1008F7620, OS_LOG_TYPE_ERROR)) {
      sub_100698DB0();
    }
  }

  else
  {
    uint64_t v18 = (uint64_t *)v4;
    if (os_log_type_enabled((os_log_t)qword_1008F7620, OS_LOG_TYPE_DEFAULT))
    {
      LODWORD(buf) = 138543362;
      *(void *)((char *)&buf + 4) = v3;
      _os_log_impl( (void *)&_mh_execute_header,  v5,  OS_LOG_TYPE_DEFAULT,  "Removing device %{public}@ from connection filter accept list, waiting for controller to complete.",  (uint8_t *)&buf,  0xCu);
    }

    uint64_t v6 = *(uint64_t **)(a1 + 360);
    if (v6 != (uint64_t *)(a1 + 368))
    {
      do
      {
        sub_100241F90(&buf, v3);
        uint64_t v7 = uuid_compare((const unsigned __int8 *)v6 + 40, (const unsigned __int8 *)&buf);
        if ((_DWORD)v7)
        {
          uint64_t v8 = (uint64_t *)v6[1];
          if (v8)
          {
            do
            {
              uint64_t v9 = v8;
              uint64_t v8 = (uint64_t *)*v8;
            }

            while (v8);
          }

          else
          {
            do
            {
              uint64_t v9 = (uint64_t *)v6[2];
              BOOL v10 = *v9 == (void)v6;
              uint64_t v6 = v9;
            }

            while (!v10);
          }
        }

        else
        {
          int v11 = sub_1005A10D0(v7, v6[4]);
          __int16 v12 = (os_log_s *)qword_1008F7620;
          if (os_log_type_enabled((os_log_t)qword_1008F7620, OS_LOG_TYPE_INFO))
          {
            LODWORD(buf) = 67109120;
            DWORD1(buf) = v11;
            _os_log_impl( (void *)&_mh_execute_header,  v12,  OS_LOG_TYPE_INFO,  "removeAddressFromBTController returned %d",  (uint8_t *)&buf,  8u);
          }

          uint64_t v9 = sub_1001FDBCC((uint64_t **)(a1 + 360), v6);
          operator delete(v6);
        }

        uint64_t v6 = v9;
      }

      while (v9 != (uint64_t *)(a1 + 368));
    }

    if (_os_feature_enabled_impl("BluetoothFeatures", "SentinelConnScanRx"))
    {
      if (qword_1008D5F30 != -1) {
        dispatch_once(&qword_1008D5F30, &stru_1008A2B30);
      }
      uint64_t v22 = 0LL;
      uint64_t v23 = 0LL;
      uint64_t v24 = 0LL;
      unsigned int v13 = sub_1005CE2FC((uint64_t)off_1008D5F28, v3) - 0x10000;
      if (v13 <= 0x19 && ((1 << v13) & 0x37800FF) != 0)
      {
        sub_100241F90(&buf, v3);
        if (a1 + 616 != sub_1005BD640(a1 + 608, (unsigned __int8 *)&buf))
        {
          id v14 = v3;
          uint64_t v27 = 0LL;
          __int128 buf = (unint64_t)v14;
          int v28 = 0;
          v21[0] = _NSConcreteStackBlock;
          v21[1] = 3221225472LL;
          v21[2] = sub_1005B50E0;
          v21[3] = &unk_1008A28C0;
          void v21[4] = a1;
          char v29 = objc_retainBlock(v21);
          sub_1005B4DE8(&v22, (uint64_t *)&buf);

          sub_100241F90(&buf, v14);
          sub_1005BEDD4((uint64_t **)(a1 + 608), (unsigned __int8 *)&buf);
        }
      }

      if (v22 != v23)
      {
        if (qword_1008D6198 != -1) {
          dispatch_once(&qword_1008D6198, &stru_1008A2B70);
        }
        uint64_t v15 = off_1008D6190;
        memset(v20, 0, sizeof(v20));
        sub_1005BED08(v20, v22, v23, 0xCCCCCCCCCCCCCCCDLL * ((v23 - v22) >> 3));
        sub_10044B2B8((uint64_t)v15, v20);
        *(void *)&__int128 buf = v20;
        sub_1005BEB74((void ***)&buf);
        sub_1005BEBB4((uint64_t)&v22, v22);
      }

      __int128 buf = 0uLL;
      uint64_t v27 = 0LL;
      id v16 = objc_claimAutoreleasedReturnValue(objc_msgSend(v3, "UUIDString", v18, v19));
      sub_10002418C(&buf, (char *)[v16 UTF8String]);

      sub_1002EE40C((uint64_t **)(a1 + 1352), (const void **)&buf);
      if (SHIBYTE(v27) < 0) {
        operator delete((void *)buf);
      }
      *(void *)&__int128 buf = &v22;
      sub_1005BEB74((void ***)&buf);
    }

    if (qword_1008D5F30 != -1) {
      dispatch_once(&qword_1008D5F30, &stru_1008A2B30);
    }
    sub_1005D1F20((uint64_t)off_1008D5F28, v3, 0);
    sub_1001FDBCC(v19, v18);
    operator delete(v18);
  }

  if (*(_BYTE *)(a1 + 1119))
  {
    uint64_t v17 = sub_1002E6E9C();
  }

  sub_100242FAC((uint64_t)v25);
}

void sub_10059FCBC( _Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20, uint64_t a21, char a22, uint64_t a23, uint64_t a24, char a25, uint64_t a26, char *__p, uint64_t a28, int a29, __int16 a30, char a31, char a32, uint64_t a33, void *a34)
{
  __p = &a22;
  sub_1005BEB74((void ***)&__p);
  sub_100242FAC((uint64_t)&a25);

  _Unwind_Resume(a1);
}

void sub_10059FD6C(uint64_t a1, void *a2, char a3)
{
  id v3 = a2;
  uint64_t v4 = sub_1002E6E9C();
  if (!sub_1002D1240(v4, 100))
  {
    if (os_log_type_enabled((os_log_t)qword_1008F7620, OS_LOG_TYPE_ERROR)) {
      sub_100698E14();
    }
    goto LABEL_52;
  }

  uint64_t v5 = sub_1002E6BF0();
  if (qword_1008D6198 != -1) {
    dispatch_once(&qword_1008D6198, &stru_1008A2B70);
  }
  if (!sub_10044925C(off_1008D6190, v6)) {
    goto LABEL_15;
  }
  if (qword_1008D5F30 != -1) {
    dispatch_once(&qword_1008D5F30, &stru_1008A2B30);
  }
  int v7 = sub_1005CE2FC((uint64_t)off_1008D5F28, v3);
  int v8 = v7;
  BOOL v38 = 1;
  if (v7 == 19 || v7 == 196608) {
    goto LABEL_16;
  }
  uint64_t v9 = sub_1002E6BF0();
  if ((*(unsigned int (**)(uint64_t))(*(void *)v9 + 904LL))(v9))
  {
    BOOL v38 = 0;
  }

  else
  {
LABEL_15:
    BOOL v38 = 0;
  }

void sub_1005A02DC( _Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20, uint64_t a21, uint64_t a22, uint64_t a23, uint64_t a24, void *a25)
{
}

void sub_1005A0338(id *a1)
{
  __int128 v95 = 0u;
  __int128 v96 = 0u;
  __int128 v97 = 0u;
  __int128 v98 = 0u;
  id v1 = a1[97];
  id v2 = [v1 countByEnumeratingWithState:&v95 objects:v103 count:16];
  if (v2)
  {
    uint64_t v3 = *(void *)v96;
    do
    {
      for (i = 0LL; i != v2; i = (char *)i + 1)
      {
        if (*(void *)v96 != v3) {
          objc_enumerationMutation(v1);
        }
        uint64_t v5 = *(void **)(*((void *)&v95 + 1) + 8LL * (void)i);
        uint64_t v6 = (os_log_s *)qword_1008F7620;
        if (os_log_type_enabled((os_log_t)qword_1008F7620, OS_LOG_TYPE_DEFAULT))
        {
          *(_DWORD *)__int128 buf = 138543362;
          *(void *)&uint8_t buf[4] = v5;
          _os_log_impl( (void *)&_mh_execute_header,  v6,  OS_LOG_TYPE_DEFAULT,  "trying to remove %{public}@ from connecting list",  buf,  0xCu);
        }

        sub_10059F800((uint64_t)a1, v5);
      }

      id v2 = [v1 countByEnumeratingWithState:&v95 objects:v103 count:16];
    }

    while (v2);
  }

  [a1[97] removeAllObjects];
  v92 = 0LL;
  unsigned __int8 *__attribute__((__org_typedef(uuid_t))) v93 = 0LL;
  unint64_t v94 = 0LL;
  __int128 v88 = 0u;
  __int128 v89 = 0u;
  __int128 v90 = 0u;
  __int128 v91 = 0u;
  id v7 = a1[96];
  id v8 = [v7 countByEnumeratingWithState:&v88 objects:v102 count:16];
  if (v8)
  {
    uint64_t v9 = *(void *)v89;
    do
    {
      for (j = 0LL; j != v8; j = (char *)j + 1)
      {
        if (*(void *)v89 != v9) {
          objc_enumerationMutation(v7);
        }
        uint64_t v11 = *(void **)(*((void *)&v88 + 1) + 8LL * (void)j);
        int v12 = (os_log_s *)qword_1008F7620;
        if (os_log_type_enabled((os_log_t)qword_1008F7620, OS_LOG_TYPE_DEFAULT))
        {
          *(_DWORD *)__int128 buf = 138543362;
          *(void *)&uint8_t buf[4] = v11;
          _os_log_impl( (void *)&_mh_execute_header,  v12,  OS_LOG_TYPE_DEFAULT,  "trying to add %{public}@ to the connecting list",  buf,  0xCu);
        }

        if (sub_1005963D8((uint64_t)a1, v11) == 8)
        {
          *(void *)__int128 buf = 0LL;
          *(void *)&uint8_t buf[8] = 0LL;
          sub_100241F90(buf, v11);
          unsigned __int8 *__attribute__((__org_typedef(uuid_t))) v13 = v93;
          if ((unint64_t)v93 >= v94)
          {
            BOOL v14 = (unsigned __int8 *)sub_1005BDBC4((uint64_t)&v92, buf);
          }

          else
          {
            uuid_copy(v93, buf);
            BOOL v14 = v13 + 16;
          }

          unsigned __int8 *__attribute__((__org_typedef(uuid_t))) v93 = v14;
        }
      }

      id v8 = [v7 countByEnumeratingWithState:&v88 objects:v102 count:16];
    }

    while (v8);
  }

  __int128 v86 = 0u;
  __int128 v87 = 0u;
  __int128 v84 = 0u;
  __int128 v85 = 0u;
  id obj = a1[98];
  id v15 = [obj countByEnumeratingWithState:&v84 objects:v101 count:16];
  if (v15)
  {
    uint64_t v17 = (uint64_t **)(a1 + 45);
    unint64_t v18 = (uint64_t *)(a1 + 46);
    v73 = (uint64_t **)(a1 + 42);
    uint64_t v74 = *(void *)v85;
    *(void *)&__int128 v16 = 136315650LL;
    __int128 v70 = v16;
    do
    {
      BOOL v19 = 0LL;
      id v71 = v15;
      do
      {
        if (*(void *)v85 != v74) {
          objc_enumerationMutation(obj);
        }
        id v20 = *(void **)(*((void *)&v84 + 1) + 8LL * (void)v19);
        if (qword_1008D5F30 != -1) {
          dispatch_once(&qword_1008D5F30, &stru_1008A2B30);
        }
        BOOL v21 = sub_1005D733C((uint64_t)off_1008D5F28, v20);
        int v22 = (os_log_s *)qword_1008F7620;
        if (!v21)
        {
          if (os_log_type_enabled((os_log_t)qword_1008F7620, OS_LOG_TYPE_ERROR))
          {
            *(_DWORD *)__int128 buf = 138543362;
            *(void *)&uint8_t buf[4] = v20;
            _os_log_error_impl( (void *)&_mh_execute_header,  v22,  OS_LOG_TYPE_ERROR,  "Device %{public}@ does not support multiple addresses",  buf,  0xCu);
            int v22 = (os_log_s *)qword_1008F7620;
          }

          if (os_log_type_enabled(v22, OS_LOG_TYPE_FAULT))
          {
            *(_DWORD *)__int128 buf = 138543362;
            *(void *)&uint8_t buf[4] = v20;
            _os_log_fault_impl( (void *)&_mh_execute_header,  v22,  OS_LOG_TYPE_FAULT,  "Device %{public}@ does not support multiple addresses but still in the fDevicesToUpdateInFilterAcceptList",  buf,  0xCu);
          }

          goto LABEL_77;
        }

        if (os_log_type_enabled((os_log_t)qword_1008F7620, OS_LOG_TYPE_DEFAULT))
        {
          *(_DWORD *)__int128 buf = 138543362;
          *(void *)&uint8_t buf[4] = v20;
          _os_log_impl( (void *)&_mh_execute_header,  v22,  OS_LOG_TYPE_DEFAULT,  "processing %{public}@ from fDevicesToUpdateInFilterAcceptList",  buf,  0xCu);
        }

        __p = 0LL;
        int v82 = 0LL;
        uint64_t v83 = 0LL;
        if (qword_1008D5F30 != -1) {
          dispatch_once(&qword_1008D5F30, &stru_1008A2B30);
        }
        sub_1005D73C8((uint64_t)off_1008D5F28, v20, 2u, (uint64_t)&__p);
        if (!v83)
        {
          __int16 v40 = (os_log_s *)qword_1008F7620;
          if (os_log_type_enabled((os_log_t)qword_1008F7620, OS_LOG_TYPE_ERROR))
          {
            *(_DWORD *)__int128 buf = 138543362;
            *(void *)&uint8_t buf[4] = v20;
            _os_log_error_impl( (void *)&_mh_execute_header,  v40,  OS_LOG_TYPE_ERROR,  "Device %{public}@ has no addresses, disconnecting ",  buf,  0xCu);
          }

          sub_10023BF24((uint64_t)&__p, v82);
          goto LABEL_77;
        }

        uint64_t v23 = *v17;
        if (*v17 != v18)
        {
          do
          {
            sub_100241F90(buf, v20);
            uint64_t v24 = uuid_compare((const unsigned __int8 *)v23 + 40, buf);
            if ((_DWORD)v24)
            {
              id v25 = (uint64_t *)v23[1];
              if (v25)
              {
                do
                {
                  uint64_t v26 = v25;
                  id v25 = (uint64_t *)*v25;
                }

                while (v25);
              }

              else
              {
                do
                {
                  uint64_t v26 = (uint64_t *)v23[2];
                  BOOL v34 = *v26 == (void)v23;
                  uint64_t v23 = v26;
                }

                while (!v34);
              }
            }

            else
            {
              unint64_t v27 = v23[4];
              int v28 = sub_1005A10D0(v24, v27);
              char v29 = (os_log_s *)qword_1008F7620;
              if (os_log_type_enabled((os_log_t)qword_1008F7620, OS_LOG_TYPE_INFO))
              {
                sub_1005BFC20(v27, (std::stringbuf::string_type *)buf);
                uint64_t v30 = buf;
                if (buf[23] < 0) {
                  uint64_t v30 = *(_BYTE **)buf;
                }
                LODWORD(v100.__r_.__value_.__l.__data_) = 136446466;
                *(std::string::size_type *)((char *)v100.__r_.__value_.__r.__words + 4) = (std::string::size_type)v30;
                WORD2(v100.__r_.__value_.__r.__words[1]) = 1024;
                *(_DWORD *)((char *)&v100.__r_.__value_.__r.__words[1] + 6) = v28;
                _os_log_impl( (void *)&_mh_execute_header,  v29,  OS_LOG_TYPE_INFO,  "removeAddressFromBTController %{public}s returned %d",  (uint8_t *)&v100,  0x12u);
                if ((buf[23] & 0x80000000) != 0) {
                  operator delete(*(void **)buf);
                }
              }

              uint64_t v26 = sub_1001FDBCC(v17, v23);
              operator delete(v23);
            }

            uint64_t v23 = v26;
          }

          while (v26 != v18);
        }

        uint64_t v31 = __p;
        if (__p == &v82)
        {
LABEL_69:
          sub_10023BF24((uint64_t)&__p, v82);
          id v15 = v71;
          goto LABEL_83;
        }

        while (1)
        {
          unint64_t v80 = v31[4];
          int v32 = sub_1005A128C((uint64_t)a1, v80);
          int v33 = v32;
          BOOL v34 = !v32 || v32 == 4152;
          if (!v34) {
            break;
          }
          int v35 = (os_log_s *)qword_1008F7620;
          if (os_log_type_enabled((os_log_t)qword_1008F7620, OS_LOG_TYPE_DEFAULT))
          {
            sub_1005BFC20(v80, (std::stringbuf::string_type *)buf);
            uint64_t v36 = buf;
            if (buf[23] < 0) {
              uint64_t v36 = *(_BYTE **)buf;
            }
            LODWORD(v100.__r_.__value_.__l.__data_) = 136446466;
            *(std::string::size_type *)((char *)v100.__r_.__value_.__r.__words + 4) = (std::string::size_type)v36;
            WORD2(v100.__r_.__value_.__r.__words[1]) = 2114;
            *(std::string::size_type *)((char *)&v100.__r_.__value_.__r.__words[1] + 6) = (std::string::size_type)v20;
            _os_log_impl( (void *)&_mh_execute_header,  v35,  OS_LOG_TYPE_DEFAULT,  "setting fConnectingAddresses[%{public}s]=%{public}@",  (uint8_t *)&v100,  0x16u);
            if ((buf[23] & 0x80000000) != 0) {
              operator delete(*(void **)buf);
            }
          }

          sub_100241F90(buf, v20);
          v100.__r_.__value_.__r.__words[0] = (std::string::size_type)&v80;
          int v37 = sub_1005BCE78((uint64_t)v17, &v80, (uint64_t)&unk_1006C2518, &v100);
          uuid_copy((unsigned __int8 *)v37 + 40, buf);
          BOOL v38 = (void *)v31[1];
          if (v38)
          {
            do
            {
              int v39 = (void **)v38;
              BOOL v38 = (void *)*v38;
            }

            while (v38);
          }

          else
          {
            do
            {
              int v39 = (void **)v31[2];
              BOOL v34 = *v39 == v31;
              uint64_t v31 = v39;
            }

            while (!v34);
          }

          uint64_t v31 = v39;
          if (v39 == &v82) {
            goto LABEL_69;
          }
        }

        id v43 = __p;
        if (__p == &v82)
        {
          sub_10023BF24((uint64_t)&__p, v82);
          id v15 = v71;
LABEL_77:
          sub_100241F90(buf, v20);
          if ((sub_1005957E8((uint64_t)a1, buf) & 1) == 0)
          {
            sub_100241F90(buf, v20);
            int v41 = (uint64_t *)sub_1005BD640((uint64_t)v73, buf);
            if (a1 + 43 != (id *)v41)
            {
              sub_1001FDBCC(v73, v41);
              operator delete(v41);
            }

            __int16 v42 = (os_log_s *)qword_1008F7620;
            if (os_log_type_enabled((os_log_t)qword_1008F7620, OS_LOG_TYPE_DEFAULT))
            {
              *(_DWORD *)__int128 buf = 138412290;
              *(void *)&uint8_t buf[4] = v20;
              _os_log_impl( (void *)&_mh_execute_header,  v42,  OS_LOG_TYPE_DEFAULT,  "Sending device connection error for device %@",  buf,  0xCu);
            }

            sub_100241F90(buf, v20);
            sub_1005A1444((uint64_t)a1, buf, 0, 8, 0);
          }

          goto LABEL_83;
        }

        do
        {
          __int16 v44 = (void *)*v18;
          if (*v18)
          {
            unint64_t v45 = v43[4];
            __int16 v46 = (uint64_t *)(a1 + 46);
            do
            {
              unint64_t v47 = v44[4];
              BOOL v48 = v47 >= v45;
              if (v47 >= v45) {
                int v49 = v44;
              }
              else {
                int v49 = v44 + 1;
              }
              if (v48) {
                __int16 v46 = v44;
              }
              __int16 v44 = (void *)*v49;
            }

            while (*v49);
            if (v46 != v18 && v45 >= v46[4])
            {
              __int16 v50 = (os_log_s *)qword_1008F7620;
              BOOL v51 = os_log_type_enabled((os_log_t)qword_1008F7620, OS_LOG_TYPE_DEFAULT);
              if (v51)
              {
                sub_1005BFC20(v45, &v100);
                uint64_t v52 = &v100;
                if ((v100.__r_.__value_.__s.__size_ & 0x80u) != 0) {
                  uint64_t v52 = (std::stringbuf::string_type *)v100.__r_.__value_.__r.__words[0];
                }
                *(_DWORD *)__int128 buf = v70;
                *(void *)&uint8_t buf[4] = v52;
                *(_WORD *)&_BYTE buf[12] = 2112;
                *(void *)&buf[14] = v20;
                *(_WORD *)&buf[22] = 1024;
                *(_DWORD *)&buf[24] = v33;
                _os_log_impl( (void *)&_mh_execute_header,  v50,  OS_LOG_TYPE_DEFAULT,  "removing address %s from controller for device %@ due to error %d",  buf,  0x1Cu);
              }

              sub_1005A10D0(v51, v45);
              sub_1001FDBCC(v17, v46);
              operator delete(v46);
            }
          }

          uint64_t v53 = (void *)v43[1];
          if (v53)
          {
            do
            {
              uint64_t v54 = (void **)v53;
              uint64_t v53 = (void *)*v53;
            }

            while (v53);
          }

          else
          {
            do
            {
              uint64_t v54 = (void **)v43[2];
              BOOL v34 = *v54 == v43;
              id v43 = v54;
            }

            while (!v34);
          }

          id v43 = v54;
        }

        while (v54 != &v82);
        sub_10023BF24((uint64_t)&__p, v82);
        id v15 = v71;
        if (v33) {
          goto LABEL_77;
        }
LABEL_83:
        BOOL v19 = (char *)v19 + 1;
      }

      while (v19 != v15);
      id v55 = [obj countByEnumeratingWithState:&v84 objects:v101 count:16];
      id v15 = v55;
    }

    while (v55);
  }

  [a1[98] removeAllObjects];
  [a1[96] removeAllObjects];
  uint64_t v57 = (const unsigned __int8 *)v92;
  unsigned __int8 *__attribute__((__org_typedef(uuid_t))) v56 = v93;
  if (v92 != v93)
  {
    do
    {
      uint64_t v58 = (os_log_s *)qword_1008F7620;
      if (os_log_type_enabled((os_log_t)qword_1008F7620, OS_LOG_TYPE_ERROR))
      {
        memset(buf, 0, sizeof(buf));
        uuid_unparse_upper(v57, buf);
        sub_10002418C(&__p, buf);
        uint64_t v59 = v83 >= 0 ? &__p : (void **)__p;
        LODWORD(v100.__r_.__value_.__l.__data_) = 136446210;
        *(std::string::size_type *)((char *)v100.__r_.__value_.__r.__words + 4) = (std::string::size_type)v59;
        _os_log_error_impl( (void *)&_mh_execute_header,  v58,  OS_LOG_TYPE_ERROR,  "Failed to connect to device %{public}s due to 0 address",  (uint8_t *)&v100,  0xCu);
        if (SHIBYTE(v83) < 0) {
          operator delete(__p);
        }
      }

      sub_1005A1444((uint64_t)a1, v57, 0, 8, 0);
      v57 += 16;
    }

    while (v57 != v56);
  }

  uint64_t v60 = sub_1002E6E9C();
  if (sub_1002D1240(v60, 100))
  {
    __int128 v78 = 0u;
    __int128 v79 = 0u;
    __int128 v76 = 0u;
    __int128 v77 = 0u;
    id v61 = a1[99];
    id v62 = [v61 countByEnumeratingWithState:&v76 objects:v99 count:16];
    if (!v62) {
      goto LABEL_138;
    }
    uint64_t v63 = *(void *)v77;
    while (1)
    {
      for (k = 0LL; k != v62; k = (char *)k + 1)
      {
        if (*(void *)v77 != v63) {
          objc_enumerationMutation(v61);
        }
        uint64_t v65 = *(void **)(*((void *)&v76 + 1) + 8LL * (void)k);
        if (sub_1005A15FC((uint64_t)a1, v65))
        {
          uint64_t v66 = qword_1008F7620;
          if (!os_log_type_enabled((os_log_t)qword_1008F7620, OS_LOG_TYPE_DEFAULT)) {
            continue;
          }
          *(_DWORD *)__int128 buf = 138543362;
          *(void *)&uint8_t buf[4] = v65;
          uint64_t v67 = (os_log_s *)v66;
          v68 = "Warning: LeConnectionDenyList: Device %{public}@ is currently blocked, ignoring request to add to filter accept list";
          goto LABEL_135;
        }

        sub_100241F90(buf, v65);
        if (a1 + 43 != (id *)sub_1005BD640((uint64_t)(a1 + 42), buf))
        {
          sub_10059FD6C((uint64_t)a1, v65, 1);
          continue;
        }

        uint64_t v69 = qword_1008F7620;
        if (os_log_type_enabled((os_log_t)qword_1008F7620, OS_LOG_TYPE_DEFAULT))
        {
          *(_DWORD *)__int128 buf = 138543362;
          *(void *)&uint8_t buf[4] = v65;
          uint64_t v67 = (os_log_s *)v69;
          v68 = "not connecting to Device Device %{public}@ any more, ignoring update filter accept list option";
LABEL_135:
          _os_log_impl((void *)&_mh_execute_header, v67, OS_LOG_TYPE_DEFAULT, v68, buf, 0xCu);
          continue;
        }
      }

      id v62 = [v61 countByEnumeratingWithState:&v76 objects:v99 count:16];
      if (!v62)
      {
LABEL_138:

        break;
      }
    }
  }

  objc_msgSend(a1[99], "removeAllObjects", v70);
  if (v92)
  {
    unsigned __int8 *__attribute__((__org_typedef(uuid_t))) v93 = (unsigned __int8 *)v92;
    operator delete(v92);
  }

void sub_1005A0FF4( _Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20, uint64_t a21, uint64_t a22, uint64_t a23, uint64_t a24, uint64_t a25, uint64_t a26, uint64_t a27, uint64_t a28, uint64_t a29, uint64_t a30, uint64_t a31, uint64_t a32, uint64_t a33, char a34, uint64_t a35, uint64_t a36, uint64_t a37, uint64_t a38, uint64_t a39, uint64_t a40, uint64_t a41, uint64_t a42, uint64_t a43, uint64_t a44, uint64_t a45, uint64_t a46, uint64_t a47, uint64_t a48, uint64_t a49, uint64_t a50,uint64_t a51,uint64_t a52,uint64_t a53,void *__p,uint64_t a55)
{
  if (__p) {
    operator delete(__p);
  }
  _Unwind_Resume(a1);
}

uint64_t sub_1005A10D0(uint64_t a1, unint64_t a2)
{
  uint64_t v3 = sub_1001BCDB0(a2);
  int v10 = v3;
  char v12 = BYTE6(v3);
  __int16 v11 = WORD2(v3);
  uint64_t v4 = (os_log_s *)qword_1008F7620;
  if (os_log_type_enabled((os_log_t)qword_1008F7620, OS_LOG_TYPE_DEFAULT))
  {
    id v5 = sub_1005BFB9C(a2);
    uint64_t v6 = (void *)objc_claimAutoreleasedReturnValue(v5);
    *(_DWORD *)__int128 buf = 141558275;
    *(void *)&uint8_t buf[4] = 1752392040LL;
    *(_WORD *)&_BYTE buf[12] = 2113;
    *(void *)&buf[14] = v6;
    _os_log_impl( (void *)&_mh_execute_header,  v4,  OS_LOG_TYPE_DEFAULT,  "Removing address %{private, mask.hash}@ from connection FilterAcceptList, waiting for controller to complete.",  buf,  0x16u);
  }

  char v9 = 0;
  sub_100242CA4(&v9);
  byte_1008F7931 = 1;
  uint64_t v7 = sub_1001D57D0((unsigned __int8 *)&v10);
  sub_100242CD0(&v9);
  if ((_DWORD)v7)
  {
    if (os_log_type_enabled((os_log_t)qword_1008F7620, OS_LOG_TYPE_ERROR)) {
      sub_100698E78();
    }
    byte_1008F7931 = 0;
  }

  else
  {
    *(void *)__int128 buf = 0LL;
    *(void *)&uint8_t buf[8] = 0LL;
    sub_100242F28((uint64_t)buf, (uint64_t)&unk_1008F78F0);
    if (byte_1008F7931) {
      sub_1002430FC(&stru_1008F7880, (pthread_mutex_t **)buf);
    }
    sub_100242F54((uint64_t)buf);
    sub_100242FAC((uint64_t)buf);
  }

  sub_100242CD8(&v9);
  return v7;
}

void sub_1005A125C( _Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, int a9, __int16 a10, char a11, char a12)
{
}

uint64_t sub_1005A128C(uint64_t a1, unint64_t a2)
{
  if (!*(_BYTE *)(a1 + 184)) {
    return 103LL;
  }
  uint64_t v3 = sub_1001BCDB0(a2);
  int v10 = v3;
  char v12 = BYTE6(v3);
  __int16 v11 = WORD2(v3);
  uint64_t v4 = (os_log_s *)qword_1008F7620;
  if (os_log_type_enabled((os_log_t)qword_1008F7620, OS_LOG_TYPE_DEFAULT))
  {
    id v5 = sub_1005BFB9C(a2);
    uint64_t v6 = (void *)objc_claimAutoreleasedReturnValue(v5);
    *(_DWORD *)__int128 buf = 138477827;
    *(void *)&uint8_t buf[4] = v6;
    _os_log_impl( (void *)&_mh_execute_header,  v4,  OS_LOG_TYPE_DEFAULT,  "Adding address %{private}@ to connection FilterAcceptList, waiting for controller to complete.",  buf,  0xCu);
  }

  char v9 = 0;
  sub_100242CA4(&v9);
  byte_1008F7930 = 1;
  uint64_t v7 = sub_1001D5474((unsigned __int8 *)&v10);
  sub_100242CD0(&v9);
  if ((_DWORD)v7)
  {
    if (os_log_type_enabled((os_log_t)qword_1008F7620, OS_LOG_TYPE_ERROR)) {
      sub_100698ED8();
    }
    byte_1008F7930 = 0;
  }

  else
  {
    *(_OWORD *)__int128 buf = 0uLL;
    sub_100242F28((uint64_t)buf, (uint64_t)&unk_1008F78B0);
    if (byte_1008F7930) {
      sub_1002430FC(&stru_1008F7850, (pthread_mutex_t **)buf);
    }
    sub_100242F54((uint64_t)buf);
    sub_100242FAC((uint64_t)buf);
  }

  sub_100242CD8(&v9);
  return v7;
}

void sub_1005A1414( _Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, int a9, __int16 a10, char a11, char a12)
{
}

void sub_1005A1444(uint64_t a1, const unsigned __int8 *a2, int a3, int a4, char a5)
{
  uint64_t v10 = *(void *)(a1 + 400);
  __int16 v11 = sub_100241F94(a2);
  char v12 = (void *)objc_claimAutoreleasedReturnValue(v11);
  uint64_t v13 = sub_100404EB8();
  v23[0] = _NSConcreteStackBlock;
  v23[1] = 3221225472LL;
  v23[2] = sub_1005AACAC;
  v23[3] = &unk_1008A25D8;
  int v25 = v10;
  id v14 = v12;
  id v24 = v14;
  char v26 = a3;
  sub_100405384(v13, v23);
  if (qword_1008D92A8 != -1) {
    dispatch_once(&qword_1008D92A8, &stru_1008A2BB0);
  }
  uint64_t v15 = qword_1008D92A0;
  __int128 v16 = sub_100241F94(a2);
  uint64_t v17 = (void *)objc_claimAutoreleasedReturnValue(v16);
  if (a3) {
    uint64_t v18 = 2LL;
  }
  else {
    uint64_t v18 = 0LL;
  }
  sub_10064CA40(v15, v17, v18);

  if (a4 != 305 && (a3 & 1) == 0)
  {
    v19[0] = _NSConcreteStackBlock;
    v19[1] = 3221225472LL;
    v19[2] = sub_1005AAEFC;
    v19[3] = &unk_1008A2600;
    char v22 = a5;
    id v20 = v14;
    int v21 = a4;
    sub_10058C72C((os_unfair_lock_s *)a1, v19);
  }
}

void sub_1005A15BC( _Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, void *a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, void *a19)
{
  _Unwind_Resume(a1);
}

uint64_t sub_1005A15FC(uint64_t a1, void *a2)
{
  id v3 = a2;
  uint64_t v4 = *(const unsigned __int8 **)(a1 + 1456);
  id v5 = (const unsigned __int8 *)(a1 + 1464);
  if (v4 == v5)
  {
LABEL_11:
    uint64_t v9 = 0LL;
  }

  else
  {
    while (1)
    {
      sub_100241F90(uu2, v3);
      if (!uuid_compare(v4 + 32, uu2) && (*((void *)v4 + 9) || *((void *)v4 + 10))) {
        break;
      }
      uint64_t v6 = (const unsigned __int8 *)*((void *)v4 + 1);
      if (v6)
      {
        do
        {
          uint64_t v7 = v6;
          uint64_t v6 = *(const unsigned __int8 **)v6;
        }

        while (v6);
      }

      else
      {
        do
        {
          uint64_t v7 = (const unsigned __int8 *)*((void *)v4 + 2);
          BOOL v8 = *(void *)v7 == (void)v4;
          uint64_t v4 = v7;
        }

        while (!v8);
      }

      uint64_t v4 = v7;
      if (v7 == v5) {
        goto LABEL_11;
      }
    }

    uint64_t v9 = 1LL;
  }

  return v9;
}

void sub_1005A16E4(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

uint64_t sub_1005A16FC(uint64_t a1, int a2)
{
  v16[0] = 0LL;
  v16[1] = 0LL;
  sub_100242F28((uint64_t)v16, a1 + 120);
  uint64_t v4 = *(const unsigned __int8 **)(a1 + 384);
  if (v4 == (const unsigned __int8 *)(a1 + 392))
  {
    unsigned __int16 v5 = 0;
  }

  else
  {
    unsigned __int16 v5 = 0;
    do
    {
      if (qword_1008D5F30 != -1) {
        dispatch_once(&qword_1008D5F30, &stru_1008A2B30);
      }
      uint64_t v6 = off_1008D5F28;
      uint64_t v7 = sub_100241F94(v4 + 32);
      BOOL v8 = (void *)objc_claimAutoreleasedReturnValue(v7);
      if (sub_1005CE2FC((uint64_t)v6, v8) == a2)
      {
        uint64_t v9 = sub_100241F94(v4 + 32);
        uint64_t v10 = (void *)objc_claimAutoreleasedReturnValue(v9);
        sub_100241F90(v17, v10);
        unsigned __int16 v11 = (unsigned __int16)sub_1005957E8(a1, v17);

        v5 += v11 ^ 1;
      }

      else
      {
      }

      char v12 = (unsigned __int8 *)*((void *)v4 + 1);
      if (v12)
      {
        do
        {
          uint64_t v13 = (const unsigned __int8 **)v12;
          char v12 = *(unsigned __int8 **)v12;
        }

        while (v12);
      }

      else
      {
        do
        {
          uint64_t v13 = (const unsigned __int8 **)*((void *)v4 + 2);
          BOOL v14 = *v13 == v4;
          uint64_t v4 = (const unsigned __int8 *)v13;
        }

        while (!v14);
      }

      uint64_t v4 = (const unsigned __int8 *)v13;
    }

    while (v13 != (const unsigned __int8 **)(a1 + 392));
  }

  sub_100242FAC((uint64_t)v16);
  return v5;
}

void sub_1005A187C(_Unwind_Exception *a1, uint64_t a2, ...)
{
  sub_100242FAC((uint64_t)va);
  _Unwind_Resume(a1);
}

uint64_t sub_1005A18B4(uint64_t a1, void *a2, uint64_t a3)
{
  v22[0] = 0LL;
  v22[1] = 0LL;
  id v21 = a2;
  sub_100242F28((uint64_t)v22, a1 + 120);
  unsigned __int16 v4 = 0;
  if (v21 && (_DWORD)a3)
  {
    if (![v21 length]
      || (unsigned __int16 v5 = *(const unsigned __int8 **)(a1 + 384), v5 == (const unsigned __int8 *)(a1 + 392)))
    {
      unsigned __int16 v4 = 0;
    }

    else
    {
      unsigned __int16 v4 = 0;
      do
      {
        if (qword_1008D5F30 != -1) {
          dispatch_once(&qword_1008D5F30, &stru_1008A2B30);
        }
        uint64_t v6 = off_1008D5F28;
        uint64_t v7 = sub_100241F94(v5 + 32);
        BOOL v8 = (void *)objc_claimAutoreleasedReturnValue(v7);
        unsigned int v9 = sub_1005D3540((uint64_t)v6, v8, v21);

        if (qword_1008D5F30 != -1) {
          dispatch_once(&qword_1008D5F30, &stru_1008A2B30);
        }
        uint64_t v10 = off_1008D5F28;
        unsigned __int16 v11 = sub_100241F94(v5 + 32);
        char v12 = (void *)objc_claimAutoreleasedReturnValue(v11);
        LODWORD(v10) = sub_1005D37CC((uint64_t)v10, v12, a3);

        if ((v9 & v10 & 1) != 0)
        {
          uint64_t v13 = sub_100241F94(v5 + 32);
          BOOL v14 = (void *)objc_claimAutoreleasedReturnValue(v13);
          sub_100241F90(v23, v14);
          unsigned __int16 v15 = (unsigned __int16)sub_1005957E8(a1, v23);

          v4 += v15 ^ 1;
        }

        __int128 v16 = (unsigned __int8 *)*((void *)v5 + 1);
        if (v16)
        {
          do
          {
            uint64_t v17 = (const unsigned __int8 **)v16;
            __int128 v16 = *(unsigned __int8 **)v16;
          }

          while (v16);
        }

        else
        {
          do
          {
            uint64_t v17 = (const unsigned __int8 **)*((void *)v5 + 2);
            BOOL v18 = *v17 == v5;
            unsigned __int16 v5 = (const unsigned __int8 *)v17;
          }

          while (!v18);
        }

        unsigned __int16 v5 = (const unsigned __int8 *)v17;
      }

      while (v17 != (const unsigned __int8 **)(a1 + 392));
    }
  }

  sub_100242FAC((uint64_t)v22);

  return v4;
}

void sub_1005A1AB4(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, void *a4, ...)
{
  _Unwind_Resume(a1);
}

uint64_t sub_1005A1B10( uint64_t a1, unsigned __int8 *a2, uint64_t a3, uint64_t a4, __int16 a5, unsigned int a6, uint64_t a7)
{
  uint64_t v14 = sub_1002E6E9C();
  if (!(*(unsigned int (**)(uint64_t))(*(void *)v14 + 2096LL))(v14))
  {
    if (os_log_type_enabled((os_log_t)qword_1008F7620, OS_LOG_TYPE_ERROR)) {
      sub_100698F90();
    }
    return 11LL;
  }

  uint64_t v60 = 0LL;
  if (sub_100599890(a1, a2, &v60))
  {
    uint64_t v62 = 0LL;
    uint64_t v63 = 0LL;
    int v64 = 0;
    if (!(_DWORD)a4)
    {
      uint64_t v30 = (uint64_t *)sub_1005BCC74(a1 + 800, a2);
      if ((uint64_t *)(a1 + 808) != v30)
      {
        uint64_t v31 = v30;
        sub_1001FDBCC((uint64_t **)(a1 + 800), v30);
        operator delete(v31);
      }

      uint64_t v21 = 0LL;
      uint64_t v23 = 0LL;
      __int16 v28 = 0;
      char v27 = 0;
      __int16 v26 = 0;
      __int16 v25 = 0;
      uint64_t v18 = 0LL;
      goto LABEL_24;
    }

    uint64_t v15 = sub_1002E6E9C();
    if ((*(unsigned int (**)(uint64_t))(*(void *)v15 + 2104LL))(v15))
    {
      id v61 = a2;
      *((_WORD *)sub_1005BDD78( (uint64_t **)(a1 + 800),  a2,  (uint64_t)&unk_1006C2518,  (const unsigned __int8 *__attribute__((__org_typedef(uuid_t))) *)&v61)
      + 21) = a5;
      __int128 v16 = sub_100241F94(a2);
      uint64_t v17 = (void *)objc_claimAutoreleasedReturnValue(v16);
      uint64_t v18 = sub_10058E47C((uint64_t)v17, v17);

      BOOL v19 = sub_100241F94(a2);
      id v20 = (void *)objc_claimAutoreleasedReturnValue(v19);
      uint64_t v21 = sub_10058DFD4(a1, v20);

      if (a6 && a7)
      {
        unint64_t v22 = 0LL;
        if (a6 >= 5) {
          uint64_t v23 = 5LL;
        }
        else {
          uint64_t v23 = a6;
        }
        do
        {
          if (v22 >= a6) {
            int v24 = 0;
          }
          else {
            int v24 = *(_DWORD *)(a7 + 4 * v22);
          }
          *((_DWORD *)&v62 + v22++) = v24;
        }

        while (v22 != 5);
        __int16 v25 = 480;
        __int16 v26 = 20;
        char v27 = 6;
        __int16 v28 = 48;
      }

      else
      {
        uint64_t v62 = 0x2FA000002C4LL;
        if (qword_1008D5F30 != -1) {
          dispatch_once(&qword_1008D5F30, &stru_1008A2B30);
        }
        int v33 = off_1008D5F28;
        BOOL v34 = sub_100241F94(a2);
        int v35 = (void *)objc_claimAutoreleasedReturnValue(v34);
        sub_10002418C(v58, "A1603");
        if ((sub_1005CE5A8((uint64_t)v33, v35, (uint64_t)v58) & 1) != 0)
        {
          int v36 = 1;
        }

        else
        {
          if (qword_1008D5F30 != -1) {
            dispatch_once(&qword_1008D5F30, &stru_1008A2B30);
          }
          int v37 = off_1008D5F28;
          BOOL v38 = sub_100241F94(a2);
          int v39 = (void *)objc_claimAutoreleasedReturnValue(v38);
          sub_10002418C(v56, "A2051");
          if ((sub_1005CE5A8((uint64_t)v37, v39, (uint64_t)v56) & 1) != 0)
          {
            int v36 = 1;
          }

          else
          {
            if (qword_1008D5F30 != -1) {
              dispatch_once(&qword_1008D5F30, &stru_1008A2B30);
            }
            __int16 v40 = off_1008D5F28;
            int v41 = sub_100241F94(a2);
            __int16 v42 = (void *)objc_claimAutoreleasedReturnValue(v41);
            sub_10002418C(v54, "A3085");
            if ((sub_1005CE5A8((uint64_t)v40, v42, (uint64_t)v54) & 1) != 0)
            {
              int v36 = 1;
            }

            else
            {
              if (qword_1008D5F30 != -1) {
                dispatch_once(&qword_1008D5F30, &stru_1008A2B30);
              }
              id v43 = off_1008D5F28;
              __int16 v44 = sub_100241F94(a2);
              int v49 = (void *)objc_claimAutoreleasedReturnValue(v44);
              sub_10002418C(v52, "A2538");
              if ((sub_1005CE5A8((uint64_t)v43, v49, (uint64_t)v52) & 1) != 0)
              {
                int v36 = 1;
              }

              else
              {
                if (qword_1008D5F30 != -1) {
                  dispatch_once(&qword_1008D5F30, &stru_1008A2B30);
                }
                unint64_t v45 = off_1008D5F28;
                __int16 v46 = sub_100241F94(a2);
                unint64_t v47 = (void *)objc_claimAutoreleasedReturnValue(v46);
                sub_10002418C(__p, "_HID_DEVICE_");
                int v36 = sub_1005CE5A8((uint64_t)v45, v47, (uint64_t)__p);
                if (v51 < 0) {
                  operator delete(__p[0]);
                }
              }

              if (v53 < 0) {
                operator delete(v52[0]);
              }
            }

            if (v55 < 0) {
              operator delete(v54[0]);
            }
          }

          if (v57 < 0) {
            operator delete(v56[0]);
          }
        }

        if (v59 < 0) {
          operator delete(v58[0]);
        }

        if (v36)
        {
          __int16 v25 = 480;
          LODWORD(v63) = 719;
          __int16 v26 = 20;
          char v27 = 6;
          __int16 v28 = 48;
          uint64_t v23 = 3LL;
        }

        else
        {
          __int16 v25 = 480;
          __int16 v26 = 20;
          char v27 = 6;
          __int16 v28 = 48;
          uint64_t v23 = 2LL;
        }
      }

void sub_1005A2070( _Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, void *a11, void *__p, uint64_t a13, int a14, __int16 a15, char a16, char a17, void *a18, uint64_t a19, int a20, __int16 a21, char a22, char a23, void *a24, uint64_t a25, int a26, __int16 a27, char a28, char a29, void *a30, uint64_t a31, int a32, __int16 a33, char a34, char a35, void *a36, uint64_t a37, int a38, __int16 a39, char a40, char a41)
{
  if (a17 < 0) {
    operator delete(__p);
  }

  if (a23 < 0) {
    operator delete(a18);
  }

  if (a29 < 0) {
    operator delete(a24);
  }

  if (a35 < 0) {
    operator delete(a30);
  }

  if (a41 < 0) {
    operator delete(a36);
  }

  _Unwind_Resume(a1);
}

uint64_t sub_1005A213C(uint64_t a1, unsigned __int16 *a2)
{
  unsigned __int8 v64 = 0;
  int v62 = -31;
  unsigned int v63 = 1;
  int v61 = -30;
  uint64_t v59 = 0LL;
  uint64_t v60 = 0LL;
  uint64_t v57 = 0LL;
  uint64_t v58 = 0LL;
  uint64_t v2 = sub_1002E6E00();
  sub_10002418C(buf, "LE");
  sub_10002418C(__p, "ForceRSSIDetectionEnable");
  int v3 = (*(uint64_t (**)(uint64_t, uint8_t *, void **, unsigned __int8 *))(*(void *)v2 + 72LL))( v2,  buf,  __p,  &v64);
  if (v56 < 0) {
    operator delete(__p[0]);
  }
  if (v66 < 0)
  {
    operator delete(*(void **)buf);
    if (!v3) {
      goto LABEL_9;
    }
  }

  else if (!v3)
  {
    goto LABEL_9;
  }

  unsigned __int16 v4 = (os_log_s *)qword_1008F7620;
  if (os_log_type_enabled((os_log_t)qword_1008F7620, OS_LOG_TYPE_DEFAULT))
  {
    *(_DWORD *)__int128 buf = 67109120;
    *(_DWORD *)&uint8_t buf[4] = v64;
    _os_log_impl( (void *)&_mh_execute_header,  v4,  OS_LOG_TYPE_DEFAULT,  "Using override value for  ForceRSSIDetectionEnable enable=(%d)",  buf,  8u);
  }

void sub_1005A2C00( _Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, void *__p, uint64_t a17, int a18, __int16 a19, char a20, char a21, uint64_t a22, uint64_t a23, uint64_t a24, uint64_t a25, uint64_t a26, uint64_t a27, void *a28, uint64_t a29, int a30, __int16 a31, char a32, char a33)
{
  if (a21 < 0) {
    operator delete(__p);
  }
  if (a33 < 0) {
    operator delete(a28);
  }
  _Unwind_Resume(exception_object);
}

void sub_1005A2C94(uint64_t a1, void *a2, unsigned int a3, int a4, int a5)
{
  id v6 = a2;
  uint64_t v48 = 0LL;
  __int128 v46 = 0u;
  memset(v47, 0, sizeof(v47));
  __int128 v44 = 0u;
  __int128 v45 = 0u;
  __int128 v42 = 0u;
  memset(v43, 0, sizeof(v43));
  sub_1001FCFC8((uint64_t)&v42);
  if (v6)
  {
    if (a4)
    {
      if (qword_1008D67C8 != -1) {
        dispatch_once(&qword_1008D67C8, &stru_1008A2C10);
      }
      id v7 = sub_10027D9C4((uint64_t)off_1008D67C0, v6);
      BOOL v8 = (void *)objc_claimAutoreleasedReturnValue(v7);
      uint64_t v9 = objc_claimAutoreleasedReturnValue(+[NSMutableSet setWithArray:](&OBJC_CLASS___NSMutableSet, "setWithArray:", v8));
    }

    else
    {
      if (qword_1008D92A8 != -1) {
        dispatch_once(&qword_1008D92A8, &stru_1008A2BB0);
      }
      id v10 = sub_10064D6E0(qword_1008D92A0, v6);
      BOOL v8 = (void *)objc_claimAutoreleasedReturnValue(v10);
      uint64_t v9 = objc_claimAutoreleasedReturnValue(+[NSMutableSet setWithSet:](&OBJC_CLASS___NSMutableSet, "setWithSet:", v8));
    }

    unsigned __int16 v11 = (void *)v9;

    if (qword_1008D9158 != -1) {
      dispatch_once(&qword_1008D9158, &stru_1008A2C30);
    }
    id v12 = sub_100247E74(qword_1008D9150, v6);
    int v13 = (void *)objc_claimAutoreleasedReturnValue(v12);
    [v11 addObjectsFromArray:v13];

    if ([v11 count])
    {
      __int128 v40 = 0u;
      __int128 v41 = 0u;
      __int128 v38 = 0u;
      __int128 v39 = 0u;
      id v14 = v11;
      id v15 = [v14 countByEnumeratingWithState:&v38 objects:v50 count:16];
      if (v15)
      {
        uint64_t v16 = *(void *)v39;
        do
        {
          for (i = 0LL; i != v15; i = (char *)i + 1)
          {
            if (*(void *)v39 != v16) {
              objc_enumerationMutation(v14);
            }
            id v18 = *(id *)(*((void *)&v38 + 1) + 8LL * (void)i);
            int v19 = (const char *)[v18 UTF8String];
            size_t v20 = strlen(v19);
            uint64_t v21 = sub_1001FD17C(v43, (uint64_t)v19, v20);
            sub_1001FD17C(v21, (uint64_t)",", 1LL);
          }

          id v15 = [v14 countByEnumeratingWithState:&v38 objects:v50 count:16];
        }

        while (v15);
      }

      v49[0] = 0LL;
      v49[1] = 0LL;
      std::ostream::sentry::sentry(v49, v43);
      int v22 = (char *)v43 + *(void *)(*(void *)&v43[0] - 24LL);
      if ((v22[32] & 5) == 0)
      {
        (*(void (**)(std::stringbuf::string_type *__return_ptr, void, uint64_t, uint64_t, uint64_t))(**((void **)v22 + 5) + 32LL))( &v51,  *((void *)v22 + 5),  -1LL,  1LL,  16LL);
        if (v52 == -1) {
          std::ios_base::clear( (std::ios_base *)((char *)v43 + *(void *)(*(void *)&v43[0] - 24LL)),  *(_DWORD *)((char *)&v43[2] + *(void *)(*(void *)&v43[0] - 24LL)) | 4);
        }
      }

      std::ostream::sentry::~sentry(v49);
      v51.__r_.__value_.__s.__data_[0] = 0;
      sub_1001FD17C(v43, (uint64_t)&v51, 1LL);
    }

    else
    {
      if (qword_1008D5F30 != -1) {
        dispatch_once(&qword_1008D5F30, &stru_1008A2B30);
      }
      int v23 = off_1008D5F28;
      sub_10002418C(__p, "HasTS");
      int v24 = sub_1005CE5A8((uint64_t)v23, v6, (uint64_t)__p);
      if (v37 < 0) {
        operator delete(__p[0]);
      }
      if (v24) {
        __int16 v25 = "com.apple.magnet";
      }
      else {
        __int16 v25 = "Unknown";
      }
      if (v24) {
        uint64_t v26 = 16LL;
      }
      else {
        uint64_t v26 = 7LL;
      }
      sub_1001FD17C(v43, (uint64_t)v25, v26);
    }
  }

  else
  {
    sub_1001FD17C(v43, (uint64_t)"Unknown", 7LL);
  }

  if (a5)
  {
    uint64_t v27 = sub_1002E9074();
    std::stringbuf::str(&v51, (const std::stringbuf *)((char *)v43 + 8));
    if ((v51.__r_.__value_.__s.__size_ & 0x80u) == 0) {
      __int16 v28 = &v51;
    }
    else {
      __int16 v28 = (std::stringbuf::string_type *)v51.__r_.__value_.__r.__words[0];
    }
    BOOL v34 = &off_10087FAA8;
    uint64_t v35 = 0LL;
    (*(void (**)(uint64_t, void, std::stringbuf::string_type *, id, uint64_t (***)()))(*(void *)v27 + 40LL))( v27,  a3,  v28,  v6,  &v34);
    BOOL v34 = &off_10087FAA8;
    if (v35) {
      sub_1002CD254(v35);
    }
  }

  if (a3 == 5 || a3 == 3)
  {
    uint64_t v29 = sub_1002E9074();
    std::stringbuf::str(&v51, (const std::stringbuf *)((char *)v43 + 8));
    int v30 = (v51.__r_.__value_.__s.__size_ & 0x80u) == 0
        ? &v51
        : (std::stringbuf::string_type *)v51.__r_.__value_.__r.__words[0];
    (*(void (**)(uint64_t, std::stringbuf::string_type *, BOOL, id))(*(void *)v29 + 8LL))( v29,  v30,  a3 == 3,  v6);
  }

  *(void *)((char *)&v43[-1]
  *(void *)&v43[0] = v31;
  if (SHIBYTE(v45) < 0) {
    operator delete(*((void **)&v44 + 1));
  }
  std::streambuf::~streambuf((char *)v43 + 8);
  std::ios::~ios(v47);
}

void sub_1005A31E0( _Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, void *__p, uint64_t a13, int a14, __int16 a15, char a16, char a17, uint64_t a18, uint64_t a19, uint64_t a20, uint64_t a21, uint64_t a22, uint64_t a23, uint64_t a24, uint64_t a25, char a26, uint64_t a27, uint64_t a28, uint64_t a29, uint64_t a30, uint64_t a31, uint64_t a32, uint64_t a33, uint64_t a34, uint64_t a35, uint64_t a36, uint64_t a37, uint64_t a38, uint64_t a39, uint64_t a40, uint64_t a41, uint64_t a42, uint64_t a43, uint64_t a44, uint64_t a45, uint64_t a46, uint64_t a47, uint64_t a48, uint64_t a49, uint64_t a50,uint64_t a51,uint64_t a52,uint64_t a53,uint64_t a54,uint64_t a55,uint64_t a56,uint64_t a57,uint64_t a58,uint64_t a59,uint64_t a60,uint64_t a61,char a62)
{
  sub_1001FD0F4((uint64_t)&a26);
  _Unwind_Resume(a1);
}

uint64_t sub_1005A32CC(uint64_t a1, unsigned int a2, unsigned int a3, unsigned int a4, unsigned int a5)
{
  BOOL v7 = a2 > 2 || (a4 | a3) > 1 || a5 > 0x64 || a2 == 0;
  int v8 = v7;
  if (v7)
  {
    int v13 = (os_log_s *)qword_1008F7620;
    if (os_log_type_enabled((os_log_t)qword_1008F7620, OS_LOG_TYPE_ERROR))
    {
      id v15 = "ok";
      v19[0] = 67110914;
      uint64_t v16 = "VSC call not required";
      v19[1] = a2;
      if (a2) {
        uint64_t v16 = "ok";
      }
      __int16 v20 = 2080;
      if (a2 > 2) {
        uint64_t v16 = "Can't be >2";
      }
      uint64_t v21 = v16;
      __int16 v22 = 1024;
      unsigned int v23 = a3;
      uint64_t v17 = "Can't be >1";
      __int16 v24 = 2080;
      if (a3 <= 1) {
        id v18 = "ok";
      }
      else {
        id v18 = "Can't be >1";
      }
      __int16 v25 = v18;
      if (a4 <= 1) {
        uint64_t v17 = "ok";
      }
      __int16 v26 = 1024;
      unsigned int v27 = a4;
      if (a5 > 0x64) {
        id v15 = "Can't be >100";
      }
      __int16 v28 = 2080;
      uint64_t v29 = v17;
      __int16 v30 = 1024;
      unsigned int v31 = a5;
      __int16 v32 = 2080;
      int v33 = v15;
      _os_log_error_impl( (void *)&_mh_execute_header,  v13,  OS_LOG_TYPE_ERROR,  "SetConnectionPrioritization argument out of range: {priority:%d (%s), protectWLAN:%d (%s), protectLEA:%d (%s), p ercentageWithCriticalPriority:%d (%s)}",  (uint8_t *)v19,  0x42u);
    }
  }

  return v8 ^ 1u;
}

uint64_t sub_1005A3440(uint64_t a1, unint64_t a2, int a3, unsigned __int16 *a4, int a5, int a6)
{
  v326[1] = 0LL;
  v326[0] = 0LL;
  sub_100242F28((uint64_t)v326, a1 + 120);
  unsigned __int16 v325 = 0;
  if (qword_1008F1D18 != -1) {
    dispatch_once(&qword_1008F1D18, &stru_1008A2568);
  }
  char v324 = 0;
  sub_100242CA4(&v324);
  unint64_t v8 = a2;
  uint64_t v9 = sub_1001BCDB0(a2);
  int v321 = v9;
  char v323 = BYTE6(v9);
  __int16 v322 = WORD2(v9);
  BOOL v292 = sub_10012D5EC((uint64_t)a4);
  if (v292)
  {
    int v10 = sub_1001B998C((uint64_t)a4, &v325);
    int v11 = sub_1001B9BE0((uint64_t)a4);
  }

  else
  {
    int v10 = 0;
    int v11 = 0;
  }

  sub_100242CD0(&v324);
  int v288 = v10;
  id v12 = (os_log_s *)qword_1008F7620;
  if (os_log_type_enabled((os_log_t)qword_1008F7620, OS_LOG_TYPE_DEFAULT))
  {
    id v13 = sub_1005BFB9C(a2);
    id v14 = (id)objc_claimAutoreleasedReturnValue(v13);
    *(_DWORD *)__int128 buf = 138544386;
    *(void *)&uint8_t buf[4] = v14;
    *(_WORD *)&_BYTE buf[12] = 2048;
    *(void *)&buf[14] = a4;
    *(_WORD *)&_BYTE buf[22] = 1024;
    *(_DWORD *)&uint8_t buf[24] = a5;
    *(_WORD *)&buf[28] = 1024;
    *(_DWORD *)&buf[30] = v292;
    *(_WORD *)&buf[34] = 1024;
    *(_DWORD *)&buf[36] = a6;
    _os_log_impl( (void *)&_mh_execute_header,  v12,  OS_LOG_TYPE_DEFAULT,  "handleConnectionCompleteCallback address=%{public}@ handle=%p status=%d connectionIsActive=%d, wakeupEvent=%d",  buf,  0x28u);

    unint64_t v8 = a2;
  }

  if (!a5 || *(_DWORD *)(a1 + 864) != 3)
  {
    if (*(_BYTE *)(a1 + 1067))
    {
      uint64_t v16 = qword_1008F7620;
      if (os_log_type_enabled((os_log_t)qword_1008F7620, OS_LOG_TYPE_DEFAULT))
      {
        *(_WORD *)__int128 buf = 0;
        uint64_t v17 = "Stack is shutting down, this is most likely an orphan event dispatched late, ignoring";
        goto LABEL_21;
      }

      goto LABEL_423;
    }

    memset(uu, 0, sizeof(uu));
    uuid_clear(uu);
    if (a5)
    {
      if (a5 > 710)
      {
        if (a5 != 713)
        {
          if (a5 == 711)
          {
            if (qword_1008D5F30 != -1) {
              dispatch_once(&qword_1008D5F30, &stru_1008A2B30);
            }
            sub_1005C8684((uint64_t)off_1008D5F28, v8, 1u, 0, 0LL, 0LL, buf);
            uuid_copy(uu, buf);
            int is_null = uuid_is_null(uu);
            BOOL v47 = os_log_type_enabled((os_log_t)qword_1008F7620, OS_LOG_TYPE_ERROR);
            if (is_null)
            {
              if (v47)
              {
                id v48 = sub_1005BFB9C(v8);
                objc_claimAutoreleasedReturnValue(v48);
                sub_100699254();
              }

              goto LABEL_423;
            }

            if (v47)
            {
              sub_100366664(uu, buf);
              sub_1006991F0();
            }

            if (sub_100592970((void *)a1, uu))
            {
              unsigned __int16 v81 = sub_100241F94(uu);
              int v82 = (void *)objc_claimAutoreleasedReturnValue(v81);
              sub_10059F800(a1, v82);

              if ([*(id *)(a1 + 752) count])
              {
                uint64_t v83 = (char *)objc_claimAutoreleasedReturnValue([*(id *)(a1 + 752) anyObject]);
                [*(id *)(a1 + 752) removeObject:v83];
                __int128 v84 = (os_log_s *)qword_1008F7620;
                if (os_log_type_enabled((os_log_t)qword_1008F7620, OS_LOG_TYPE_DEFAULT))
                {
                  *(_DWORD *)v327 = 138543362;
                  v328 = v83;
                  _os_log_impl( (void *)&_mh_execute_header,  v84,  OS_LOG_TYPE_DEFAULT,  "Moving device %{public}@ off of the overflow list now that there's room",  v327,  0xCu);
                }

                sub_1005963D8(a1, v83);
              }
            }

            if (*(_DWORD *)(a1 + 864) != 1)
            {
              int v49 = 0;
              goto LABEL_415;
            }

            __int128 v85 = (os_log_s *)qword_1008F7620;
            if (os_log_type_enabled((os_log_t)qword_1008F7620, OS_LOG_TYPE_DEFAULT))
            {
              *(_WORD *)v327 = 0;
              _os_log_impl((void *)&_mh_execute_header, v85, OS_LOG_TYPE_DEFAULT, "Connection already exists", v327, 2u);
            }

            goto LABEL_92;
          }

LABEL_420:
          sub_1005A0338((id *)a1);
          sub_10059EB5C(a1);
          goto LABEL_423;
        }
      }

      else
      {
        if (a5 == 157)
        {
          v73 = (os_log_s *)qword_1008F7620;
          if (os_log_type_enabled((os_log_t)qword_1008F7620, OS_LOG_TYPE_ERROR)) {
            sub_1006992F4(v73, v74, v75, v76, v77, v78, v79, v80);
          }
          if ((a3 & 1) != 0) {
            goto LABEL_93;
          }
          goto LABEL_92;
        }

        if (a5 != 709) {
          goto LABEL_84;
        }
      }

      if (os_log_type_enabled((os_log_t)qword_1008F7620, OS_LOG_TYPE_ERROR)) {
        sub_100699294();
      }
      *(_BYTE *)(a1 + 1065) = 1;
      sub_1005911F0(a1, 0);
      int v49 = 0;
      goto LABEL_415;
    }

    if (qword_1008D5F30 != -1) {
      dispatch_once(&qword_1008D5F30, &stru_1008A2B30);
    }
    sub_1005C8684((uint64_t)off_1008D5F28, v8, 1u, 0, 0LL, 0LL, buf);
    uuid_copy(uu, buf);
    if (uuid_is_null(uu))
    {
      if (os_log_type_enabled((os_log_t)qword_1008F7620, OS_LOG_TYPE_ERROR))
      {
        id v42 = sub_1005BFB9C(v8);
        objc_claimAutoreleasedReturnValue(v42);
        sub_100699140();
      }

      sub_100242C98(&v324);
      sub_1001BD774(&v321);
      sub_100242CD0(&v324);
      if ((a3 & 1) != 0) {
        goto LABEL_423;
      }
      if (!*(void *)(a1 + 352))
      {
        sub_1005911F0(a1, 0);
        goto LABEL_423;
      }

      sub_1005911F0(a1, 1u);
      goto LABEL_420;
    }

    if (qword_1008D5F30 != -1) {
      dispatch_once(&qword_1008D5F30, &stru_1008A2B30);
    }
    uint64_t v50 = off_1008D5F28;
    std::stringbuf::string_type v51 = sub_100241F94(uu);
    uint64_t v52 = (void *)objc_claimAutoreleasedReturnValue(v51);
    sub_1005D3868((uint64_t)v50, v52, 1, 2, 0);

    if (qword_1008D5F30 != -1) {
      dispatch_once(&qword_1008D5F30, &stru_1008A2B30);
    }
    __int16 v53 = off_1008D5F28;
    uint64_t v54 = sub_100241F94(uu);
    char v55 = (void *)objc_claimAutoreleasedReturnValue(v54);
    sub_1005D1FA8((uint64_t)v53, v55, 1, a2);

    id v56 = (id)sub_100592970((void *)a1, uu);
    unint64_t v57 = a2;
    if (!(_DWORD)v56)
    {
      if ((a3 & 1) == 0)
      {
        __int128 v91 = *(void **)(a1 + 368);
        if (!v91) {
          goto LABEL_141;
        }
        uint64_t v92 = a1 + 368;
        do
        {
          unint64_t v93 = v91[4];
          BOOL v94 = v93 >= a2;
          if (v93 >= a2) {
            __int128 v95 = v91;
          }
          else {
            __int128 v95 = v91 + 1;
          }
          if (v94) {
            uint64_t v92 = (uint64_t)v91;
          }
          __int128 v91 = (void *)*v95;
        }

        while (*v95);
        if (v92 == a1 + 368 || *(void *)(v92 + 32) > a2)
        {
LABEL_141:
          v104 = (os_log_s *)qword_1008F7620;
          if (os_log_type_enabled((os_log_t)qword_1008F7620, OS_LOG_TYPE_FAULT))
          {
            sub_100366664(uu, buf);
            int v105 = (char)buf[23];
            v106 = *(uint8_t **)buf;
            id v107 = sub_1005BFB9C(a2);
            uint64_t v108 = objc_claimAutoreleasedReturnValue(v107);
            v109 = (void *)v108;
            v110 = buf;
            if (v105 < 0) {
              v110 = v106;
            }
            *(_DWORD *)v331 = 136446466;
            *(void *)&v331[4] = v110;
            __int16 v332 = 2114;
            uint64_t v333 = v108;
            _os_log_fault_impl( (void *)&_mh_execute_header,  v104,  OS_LOG_TYPE_FAULT,  "We have a successful outgoing connection to device %{public}s(%{public}@) but we never asked to connect to it",  v331,  0x16u);
          }

          uint64_t v111 = sub_1002E6E00();
          sub_10002418C(v302, "");
          sub_1004FB370(v111, 132LL, (uint64_t)v302, 1);
        }

        BOOL v96 = os_log_type_enabled((os_log_t)qword_1008F7620, OS_LOG_TYPE_ERROR);
        if (v96)
        {
          id v97 = sub_1005BFB9C(a2);
          objc_claimAutoreleasedReturnValue(v97);
          sub_100699100();
          unint64_t v57 = a2;
        }

        sub_1005A10D0(v96, v57);
        __int128 v98 = (uint64_t *)sub_1005BD640(a1 + 336, (unsigned __int8 *)(v92 + 40));
        if ((uint64_t *)(a1 + 344) != v98)
        {
          sub_1001FDBCC((uint64_t **)(a1 + 336), v98);
          operator delete(v98);
        }

        sub_1001FDBCC((uint64_t **)(a1 + 360), (uint64_t *)v92);
        operator delete((void *)v92);
        sub_1005911F0(a1, 0);
        sub_100242C98(&v324);
        sub_1001BD774(&v321);
        sub_100242CD0(&v324);
        if (!*(_DWORD *)(a1 + 928))
        {
          sub_1005A0338((id *)a1);
          sub_10059EB5C(a1);
        }

        goto LABEL_423;
      }

      int v49 = 0;
LABEL_245:
      sub_1005A213C((uint64_t)v56, a4);
      *(void *)__int128 buf = uu;
      sub_1005BC438( (uint64_t **)(a1 + 384),  uu,  (uint64_t)&unk_1006C2518,  (const unsigned __int8 *__attribute__((__org_typedef(uuid_t))) *)buf)[6] = (uint64_t)a4;
      if (!v292)
      {
        v211 = (os_log_s *)qword_1008F7620;
        if (os_log_type_enabled((os_log_t)qword_1008F7620, OS_LOG_TYPE_DEFAULT))
        {
          if (a3) {
            v212 = "Incoming";
          }
          else {
            v212 = "Outgoing";
          }
          if (a3) {
            v213 = "from";
          }
          else {
            v213 = "to";
          }
          sub_100366664(uu, v331);
          int v214 = v334;
          v215 = *(_BYTE **)v331;
          id v216 = sub_1005BFB9C(a2);
          v217 = (void *)objc_claimAutoreleasedReturnValue(v216);
          if (v214 >= 0) {
            v218 = v331;
          }
          else {
            v218 = v215;
          }
          id v219 = v217;
          *(_DWORD *)__int128 buf = 136447234;
          *(void *)&uint8_t buf[4] = v212;
          *(_WORD *)&_BYTE buf[12] = 2082;
          *(void *)&buf[14] = v213;
          *(_WORD *)&_BYTE buf[22] = 2082;
          *(void *)&uint8_t buf[24] = v218;
          *(_WORD *)&buf[32] = 2114;
          *(void *)&buf[34] = v219;
          *(_WORD *)&buf[42] = 2048;
          *(void *)&buf[44] = a4;
          _os_log_impl( (void *)&_mh_execute_header,  v211,  OS_LOG_TYPE_DEFAULT,  "%{public}s connection %{public}s device %{public}s (%{public}@) with handle:%p was successful but already disconnected",  buf,  0x34u);

          if (v334 < 0) {
            operator delete(*(void **)v331);
          }
        }

        goto LABEL_410;
      }

      if (qword_1008D5F30 != -1) {
        dispatch_once(&qword_1008D5F30, &stru_1008A2B30);
      }
      v169 = off_1008D5F28;
      v170 = sub_100241F94(uu);
      v171 = (void *)objc_claimAutoreleasedReturnValue(v170);
      sub_1005D26D8((uint64_t)v169, v171, a3 ^ 1);

      if (qword_1008D5F30 != -1) {
        dispatch_once(&qword_1008D5F30, &stru_1008A2B30);
      }
      v172 = off_1008D5F28;
      v173 = sub_100241F94(uu);
      v174 = (void *)objc_claimAutoreleasedReturnValue(v173);
      sub_1005D27F0((uint64_t)v172, v174, 0);

      v175 = (os_log_s *)qword_1008F7620;
      if (os_log_type_enabled((os_log_t)qword_1008F7620, OS_LOG_TYPE_DEFAULT))
      {
        if (a3) {
          v176 = "Incoming";
        }
        else {
          v176 = "Outgoing";
        }
        if (a3) {
          v177 = "from";
        }
        else {
          v177 = "to";
        }
        sub_100366664(uu, v331);
        int v178 = v334;
        v179 = *(_BYTE **)v331;
        id v180 = sub_1005BFB9C(a2);
        v181 = (void *)objc_claimAutoreleasedReturnValue(v180);
        if (v178 >= 0) {
          v182 = v331;
        }
        else {
          v182 = v179;
        }
        id v183 = v181;
        *(_DWORD *)__int128 buf = 136447746;
        *(void *)&uint8_t buf[4] = v176;
        *(_WORD *)&_BYTE buf[12] = 2082;
        *(void *)&buf[14] = v177;
        *(_WORD *)&_BYTE buf[22] = 2082;
        *(void *)&uint8_t buf[24] = v182;
        *(_WORD *)&buf[32] = 2114;
        *(void *)&buf[34] = v183;
        *(_WORD *)&buf[42] = 2048;
        *(void *)&buf[44] = a4;
        *(_WORD *)&buf[52] = 1024;
        *(_DWORD *)&buf[54] = v325;
        *(_WORD *)&buf[58] = 1024;
        *(_DWORD *)&buf[60] = 1;
        _os_log_impl( (void *)&_mh_execute_header,  v175,  OS_LOG_TYPE_DEFAULT,  "%{public}s connection %{public}s device %{public}s (%{public}@) with handle:%p was successful with connect ion interval %d active=%d",  buf,  0x40u);

        if (v334 < 0) {
          operator delete(*(void **)v331);
        }
      }

      double v184 = 0.35;
      if (v325 < 0x308u) {
        double v184 = 0.75;
      }
      unsigned int v185 = (int)(v184 * (double)(10 * v11) / ((double)v325 * 1.25));
      v186 = (os_log_s *)qword_1008F7620;
      if (os_log_type_enabled((os_log_t)qword_1008F7620, OS_LOG_TYPE_DEFAULT))
      {
        sub_100366664(uu, v331);
        v187 = v334 >= 0 ? v331 : *(_BYTE **)v331;
        *(_DWORD *)__int128 buf = 136446978;
        *(void *)&uint8_t buf[4] = v187;
        *(_WORD *)&_BYTE buf[12] = 1024;
        *(_DWORD *)&buf[14] = v185;
        *(_WORD *)&buf[18] = 1024;
        *(_DWORD *)&buf[20] = v325;
        *(_WORD *)&uint8_t buf[24] = 1024;
        *(_DWORD *)&buf[26] = v11;
        _os_log_impl( (void *)&_mh_execute_header,  v186,  OS_LOG_TYPE_DEFAULT,  "Connection Complete: setting LE device %{public}s connection threshold to %d events with interval %d, LSTO %d",  buf,  0x1Eu);
        if (v334 < 0) {
          operator delete(*(void **)v331);
        }
      }

      uint64_t v188 = sub_1002E6BF0();
      if (qword_1008D5F30 != -1) {
        dispatch_once(&qword_1008D5F30, &stru_1008A2B30);
      }
      uint64_t v189 = (uint64_t)off_1008D5F28;
      v190 = sub_100241F94(uu);
      v191 = (void *)objc_claimAutoreleasedReturnValue(v190);
      LOBYTE(v189) = sub_1005D2760(v189, v191);

      if ((v189 & 1) != 0)
      {
LABEL_275:
        uint64_t v192 = sub_1002E6E9C();
        if (v185 >= 0xFF) {
          uint64_t v193 = 255LL;
        }
        else {
          uint64_t v193 = v185;
        }
        if ((*(unsigned int (**)(uint64_t, unsigned __int16 *, uint64_t))(*(void *)v192 + 1056LL))( v192,  a4,  v193)
          && os_log_type_enabled((os_log_t)qword_1008F7620, OS_LOG_TYPE_ERROR))
        {
          sub_1006990D4();
        }
      }

      if (qword_1008D5F30 != -1) {
        dispatch_once(&qword_1008D5F30, &stru_1008A2B30);
      }
      v194 = off_1008D5F28;
      v195 = sub_100241F94(uu);
      v196 = (void *)objc_claimAutoreleasedReturnValue(v195);
      int v197 = sub_1005CE2FC((uint64_t)v194, v196);

      if (qword_1008D6198 != -1) {
        dispatch_once(&qword_1008D6198, &stru_1008A2B70);
      }
      char v198 = *((_BYTE *)off_1008D6190 + 198);
      char v199 = *((_BYTE *)off_1008D6190 + 197);
      v327[0] = 0;
      v327[0] = *((_BYTE *)off_1008D6190 + 199);
      unsigned __int8 v301 = v199 | v198;
      if (*(_BYTE *)(a1 + 1379))
      {
        if (a3 && *(void *)(a1 + 1144))
        {
          __uint64_t v200 = clock_gettime_nsec_np(_CLOCK_MONOTONIC);
          uint64_t v201 = v200;
          v202 = *(void **)(a1 + 1136);
          if (v202)
          {
            v203 = (uint64_t *)(a1 + 1136);
            do
            {
              unint64_t v204 = v202[4];
              BOOL v205 = v204 >= a2;
              if (v204 >= a2) {
                v206 = v202;
              }
              else {
                v206 = v202 + 1;
              }
              if (v205) {
                v203 = v202;
              }
              v202 = (void *)*v206;
            }

            while (*v206);
            if (v203 != (uint64_t *)(a1 + 1136))
            {
              unint64_t v207 = v203[4];
              if (v207 <= a2)
              {
                if (v200 - v203[5] < 0x6FC23AC01LL)
                {
                  uint64_t v220 = sub_1002E6E9C();
                  (*(void (**)(uint64_t, void, uint64_t, void, void, void, void))(*(void *)v220 + 2592LL))( v220,  *a4,  1LL,  0LL,  v327[0],  v301,  0LL);
                  v221 = (os_log_s *)qword_1008F7620;
                  if (os_log_type_enabled((os_log_t)qword_1008F7620, OS_LOG_TYPE_DEFAULT))
                  {
                    id v222 = sub_1005BF848(a2);
                    id v223 = (id)objc_claimAutoreleasedReturnValue(v222);
                    uint64_t v224 = *(void *)(a1 + 1144);
                    *(_DWORD *)__int128 buf = 138543618;
                    *(void *)&uint8_t buf[4] = v223;
                    *(_WORD *)&_BYTE buf[12] = 2048;
                    *(void *)&buf[14] = v224;
                    _os_log_impl( (void *)&_mh_execute_header,  v221,  OS_LOG_TYPE_DEFAULT,  "setConnectionPrioritization for matching incoming address:%{public}@ fAddressForIncomingConnection PrioritizationMap:%lu",  buf,  0x16u);
                  }

                  sub_1001FDBCC((uint64_t **)(a1 + 1128), v203);
                  operator delete(v203);
                }

                else
                {
                  v208 = (os_log_s *)qword_1008F7620;
                  if (os_log_type_enabled((os_log_t)qword_1008F7620, OS_LOG_TYPE_DEFAULT))
                  {
                    id v209 = sub_1005BF848(v207);
                    id v210 = (id)objc_claimAutoreleasedReturnValue(v209);
                    *(_DWORD *)__int128 buf = 138543362;
                    *(void *)&uint8_t buf[4] = v210;
                    _os_log_impl( (void *)&_mh_execute_header,  v208,  OS_LOG_TYPE_DEFAULT,  "Ignoring expired incoming prioritized connection address:%{public}@",  buf,  0xCu);
                  }
                }
              }
            }
          }

          sub_10059E500(a1, v201);
        }

        if (v197 == 196608)
        {
          unsigned __int8 v300 = *(_BYTE *)(a1 + 1379);
          __int16 v299 = 0;
          uint64_t v232 = sub_1002E6E00();
          int v233 = (*(uint64_t (**)(uint64_t, unsigned __int8 *, char *, uint8_t *, unsigned __int8 *, __int16 *))(*(void *)v232 + 832LL))( v232,  &v300,  (char *)&v299 + 1,  v327,  &v301,  &v299);
          v234 = (os_log_s *)qword_1008F7620;
          BOOL v235 = os_log_type_enabled((os_log_t)qword_1008F7620, OS_LOG_TYPE_DEFAULT);
          if (v235)
          {
            sub_100366664(uu, v331);
            v236 = "";
            if (v233) {
              v236 = "(overridden)";
            }
            if (v334 >= 0) {
              v237 = v331;
            }
            else {
              v237 = *(_BYTE **)v331;
            }
            else {
              v238 = off_1008A2CD0[(char)v300];
            }
            *(_DWORD *)__int128 buf = 136316418;
            *(void *)&uint8_t buf[4] = v236;
            *(_WORD *)&_BYTE buf[12] = 2080;
            *(void *)&buf[14] = v237;
            *(_WORD *)&_BYTE buf[22] = 2080;
            *(void *)&uint8_t buf[24] = v238;
            *(_WORD *)&buf[32] = 1024;
            *(_DWORD *)&buf[34] = HIBYTE(v299);
            *(_WORD *)&buf[38] = 1024;
            *(_DWORD *)&buf[40] = v327[0];
            *(_WORD *)&buf[44] = 1024;
            *(_DWORD *)&buf[46] = v299;
            _os_log_impl( (void *)&_mh_execute_header,  v234,  OS_LOG_TYPE_DEFAULT,  "CBUseCaseDigitalIDTSA %sfor device %s setConnectionPrioritization{priority:%s, protectWLAN:%d, protect LEA:%d, percentageWithCriticalPriority:%d}",  buf,  0x32u);
            if (v334 < 0) {
              operator delete(*(void **)v331);
            }
          }

          if (!sub_1005A32CC(v235, v300, HIBYTE(v299), v327[0], v299))
          {
            if (os_log_type_enabled((os_log_t)qword_1008F7620, OS_LOG_TYPE_ERROR)) {
              sub_1006990A8();
            }
            goto LABEL_350;
          }

LABEL_341:
          uint64_t v239 = sub_1002E6E9C();
          (*(void (**)(uint64_t, void, void, void, void, void, void))(*(void *)v239 + 2592LL))( v239,  *a4,  v300,  HIBYTE(v299),  v327[0],  v301,  v299);
          goto LABEL_350;
        }

        if (v197 == 19)
        {
          unsigned __int8 v300 = *(_BYTE *)(a1 + 1379);
          __int16 v299 = 0;
          uint64_t v225 = sub_1002E6E00();
          int v226 = (*(uint64_t (**)(uint64_t, unsigned __int8 *, char *, uint8_t *, unsigned __int8 *, __int16 *))(*(void *)v225 + 824LL))( v225,  &v300,  (char *)&v299 + 1,  v327,  &v301,  &v299);
          v227 = (os_log_s *)qword_1008F7620;
          BOOL v228 = os_log_type_enabled((os_log_t)qword_1008F7620, OS_LOG_TYPE_DEFAULT);
          if (v228)
          {
            sub_100366664(uu, v331);
            v229 = "";
            if (v226) {
              v229 = "(overridden)";
            }
            if (v334 >= 0) {
              v230 = v331;
            }
            else {
              v230 = *(_BYTE **)v331;
            }
            else {
              v231 = off_1008A2CD0[(char)v300];
            }
            *(_DWORD *)__int128 buf = 136316418;
            *(void *)&uint8_t buf[4] = v229;
            *(_WORD *)&_BYTE buf[12] = 2080;
            *(void *)&buf[14] = v230;
            *(_WORD *)&_BYTE buf[22] = 2080;
            *(void *)&uint8_t buf[24] = v231;
            *(_WORD *)&buf[32] = 1024;
            *(_DWORD *)&buf[34] = HIBYTE(v299);
            *(_WORD *)&buf[38] = 1024;
            *(_DWORD *)&buf[40] = v327[0];
            *(_WORD *)&buf[44] = 1024;
            *(_DWORD *)&buf[46] = v299;
            _os_log_impl( (void *)&_mh_execute_header,  v227,  OS_LOG_TYPE_DEFAULT,  "CBUseCaseDigitalID for %sdevice %s setConnectionPrioritization{priority:%s, protectWLAN:%d, protectLEA :%d, percentageWithCriticalPriority:%d}",  buf,  0x32u);
            if (v334 < 0) {
              operator delete(*(void **)v331);
            }
          }

          if (!sub_1005A32CC(v228, v300, HIBYTE(v299), v327[0], v299))
          {
            if (os_log_type_enabled((os_log_t)qword_1008F7620, OS_LOG_TYPE_ERROR)) {
              sub_10069907C();
            }
            goto LABEL_350;
          }

          goto LABEL_341;
        }
      }

LABEL_350:
      if (*(_BYTE *)(a1 + 1377))
      {
        if (qword_1008D5F30 != -1) {
          dispatch_once(&qword_1008D5F30, &stru_1008A2B30);
        }
        v240 = off_1008D5F28;
        v241 = sub_100241F94(uu);
        v242 = (void *)objc_claimAutoreleasedReturnValue(v241);
        id v243 = sub_1005D2B40((uint64_t)v240, v242);
        v244 = (void *)objc_claimAutoreleasedReturnValue(v243);

        uint64_t v245 = sub_1005A622C(a1, v197, v244);
        if ((_DWORD)v245)
        {
          uint64_t v246 = sub_1002E6E9C();
          (*(void (**)(uint64_t, void, uint64_t))(*(void *)v246 + 1728LL))(v246, *a4, v245);
        }
      }

      if (*(_BYTE *)(a1 + 1378))
      {
        uint64_t v247 = sub_1002E6BF0();
        if ((*(unsigned int (**)(uint64_t))(*(void *)v247 + 912LL))(v247))
        {
          if ((v197 - 0x10000) <= 0x15 && ((1 << v197) & 0x200011) != 0)
          {
            uint64_t v248 = sub_1002E6E9C();
            int v249 = (*(uint64_t (**)(uint64_t, void, void, uint64_t, uint64_t, void, uint64_t))(*(void *)v248 + 136LL))( v248,  0LL,  *a4,  1LL,  4294967227LL,  0LL,  4294967216LL);
            if (v249)
            {
              v250 = (os_log_s *)qword_1008F7620;
              if (os_log_type_enabled((os_log_t)qword_1008F7620, OS_LOG_TYPE_DEFAULT))
              {
                *(_DWORD *)__int128 buf = 67109120;
                *(_DWORD *)&uint8_t buf[4] = v249;
                _os_log_impl( (void *)&_mh_execute_header,  v250,  OS_LOG_TYPE_DEFAULT,  "Error results for enableEPATxBFForLE result:%d",  buf,  8u);
              }
            }
          }
        }
      }

      if (!v288 && (a3 & 1) == 0)
      {
        unsigned int v251 = sub_100599CBC(a1, uu);
        if (v325 > 0xCu) {
          unsigned int v252 = v251;
        }
        else {
          unsigned int v252 = 0;
        }
        if (v252 == 1 && v325)
        {
          v253 = (os_log_s *)qword_1008F7620;
          if (os_log_type_enabled((os_log_t)qword_1008F7620, OS_LOG_TYPE_DEFAULT))
          {
            sub_100366664(uu, buf);
            v254 = (buf[23] & 0x80u) == 0 ? buf : *(uint8_t **)buf;
            *(_DWORD *)v331 = 136446210;
            *(void *)&v331[4] = v254;
            _os_log_impl( (void *)&_mh_execute_header,  v253,  OS_LOG_TYPE_DEFAULT,  "Boosting connection interval to iCloud paired device %{public}s",  v331,  0xCu);
          }

          v255 = sub_100241F94(uu);
          v256 = (void *)objc_claimAutoreleasedReturnValue(v255);
          sub_100593618(a1, v256, -4, 0);
        }

        if (!*(_BYTE *)(a1 + 1110) && (v197 & 0xFFFF0000) == 0x10000 && (byte_1008F1D11 || v325 && v325 != 24))
        {
          v257 = (os_log_s *)qword_1008F7620;
          if (os_log_type_enabled((os_log_t)qword_1008F7620, OS_LOG_TYPE_DEFAULT))
          {
            sub_100366664(uu, v331);
            v259 = v334 >= 0 ? v331 : *(_BYTE **)v331;
            LOWORD(v258) = v325;
            *(_DWORD *)__int128 buf = 136446722;
            *(void *)&uint8_t buf[4] = v259;
            *(_WORD *)&_BYTE buf[12] = 2048;
            *(double *)&buf[14] = (double)v258 * 1.25;
            *(_WORD *)&_BYTE buf[22] = 1024;
            *(_DWORD *)&uint8_t buf[24] = byte_1008F1D11;
            _os_log_impl( (void *)&_mh_execute_header,  v257,  OS_LOG_TYPE_DEFAULT,  "Adjusting connection interval to FindMy device %{public}s, current CI is :%fms sendFindMyConnectionUpdateAnyTime:%d",  buf,  0x1Cu);
            if (v334 < 0) {
              operator delete(*(void **)v331);
            }
          }

          v260 = sub_100241F94(uu);
          v261 = (void *)objc_claimAutoreleasedReturnValue(v260);
          sub_100593618(a1, v261, -8, 0);
        }
      }

      if (!*(_BYTE *)(a1 + 632))
      {
        if (qword_1008D5F30 != -1) {
          dispatch_once(&qword_1008D5F30, &stru_1008A2B30);
        }
        v262 = off_1008D5F28;
        v263 = sub_100241F94(uu);
        v264 = (void *)objc_claimAutoreleasedReturnValue(v263);
        LODWORD(v262) = sub_1005CE518((uint64_t)v262, v264);

        if ((_DWORD)v262)
        {
          uint64_t v265 = sub_1002E6BF0();
          if ((*(unsigned int (**)(uint64_t))(*(void *)v265 + 344LL))(v265))
          {
            sub_100593158(a1, (unint64_t)a4);
          }

          else if ((a3 & 1) == 0)
          {
            if (qword_1008D5F10 != -1) {
              dispatch_once(&qword_1008D5F10, &stru_1008A2B10);
            }
            v266 = off_1008D5F08;
            v267 = sub_100241F94(uu);
            v268 = (void *)objc_claimAutoreleasedReturnValue(v267);
            sub_100593618((uint64_t)v266, v268, -2, 0);
          }
        }
      }

      if (sub_1005957E8(a1, uu))
      {
        v269 = (os_log_s *)qword_1008F7620;
        if (os_log_type_enabled((os_log_t)qword_1008F7620, OS_LOG_TYPE_DEFAULT))
        {
          sub_100366664(uu, buf);
          v270 = (buf[23] & 0x80u) == 0 ? buf : *(uint8_t **)buf;
          *(_DWORD *)v331 = 136446210;
          *(void *)&v331[4] = v270;
          _os_log_impl( (void *)&_mh_execute_header,  v269,  OS_LOG_TYPE_DEFAULT,  "Device was already disconnecting, disconnect connected device %{public}s",  v331,  0xCu);
        }

        sub_100242C98(&v324);
        *(void *)__int128 buf = 0LL;
        if (sub_100599890(a1, uu, buf)) {
          sub_1001B7974(*(uint64_t *)buf);
        }
        sub_100242CD0(&v324);
      }

LABEL_410:
      uint64_t v330 = 0LL;
      memset(buf, 0, sizeof(buf));
      v271 = sub_100241F94(uu);
      v272 = (void *)objc_claimAutoreleasedReturnValue(v271);
      sub_10058C504(a1, v272, (uint64_t)buf);

      v273 = sub_100241F94(uu);
      uint64_t v274 = objc_claimAutoreleasedReturnValue(v273);
      v275 = *(void **)buf;
      *(void *)__int128 buf = v274;

      *(void *)&uint8_t buf[24] = CFAbsoluteTimeGetCurrent();
      buf[49] = 1;
      buf[51] = a6;
      if (qword_1008D5F20 != -1) {
        dispatch_once(&qword_1008D5F20, &stru_1008A2BF0);
      }
      buf[48] = sub_10061C0F8(qword_1008D5F18, *(void **)buf);
      buf[50] = a3 ^ 1;
      v276 = objc_opt_new(&OBJC_CLASS___NSMutableArray);
      v277 = *(void **)&buf[8];
      *(void *)&uint8_t buf[8] = v276;

      v278 = sub_100241F94(uu);
      v279 = (void *)objc_claimAutoreleasedReturnValue(v278);
      v294[0] = *(id *)buf;
      v294[1] = *(id *)&buf[8];
      __int128 v295 = *(_OWORD *)&buf[16];
      __int128 v296 = *(_OWORD *)&buf[32];
      __int128 v297 = *(_OWORD *)&buf[48];
      int v298 = v330;
      sub_10058C62C(a1, v279, (uint64_t)v294);

      goto LABEL_415;
    }

    if (a3)
    {
      uint64_t v58 = (os_log_s *)qword_1008F7620;
      if (os_log_type_enabled((os_log_t)qword_1008F7620, OS_LOG_TYPE_DEFAULT))
      {
        *(_WORD *)__int128 buf = 0;
        _os_log_impl( (void *)&_mh_execute_header,  v58,  OS_LOG_TYPE_DEFAULT,  "Cancelling outgoing connection to same device",  buf,  2u);
      }

      int v59 = sub_100590B30(a1, 1);
      if (v59 == 1302)
      {
        uint64_t v60 = (os_log_s *)qword_1008F7620;
        if (os_log_type_enabled((os_log_t)qword_1008F7620, OS_LOG_TYPE_DEFAULT))
        {
          *(_WORD *)__int128 buf = 0;
          int v61 = "Failed to cancel the connection because its already connected, waiting for event";
          goto LABEL_136;
        }

LABEL_423:
  sub_100242CD8(&v324);
  return sub_100242FAC((uint64_t)v326);
}

void sub_1005A5DE4(_Unwind_Exception *a1)
{
}

void sub_1005A60C8(id a1)
{
  uint64_t v1 = sub_1002E6E00();
  sub_10002418C(v5, "LE");
  sub_10002418C(__p, "IgnoreControllerConnectionCompleteOnCancel");
  (*(void (**)(uint64_t, void **, void **, char *))(*(void *)v1 + 72LL))(v1, v5, __p, &byte_1008F1D10);
  if (v4 < 0) {
    operator delete(__p[0]);
  }
  if (v6 < 0) {
    operator delete(v5[0]);
  }
  uint64_t v2 = sub_1002E6E00();
  sub_10002418C(v5, "LE");
  sub_10002418C(__p, "sendFindMyConnectionUpdateAnyTime");
  (*(void (**)(uint64_t, void **, void **, char *))(*(void *)v2 + 72LL))(v2, v5, __p, &byte_1008F1D11);
  if (v4 < 0) {
    operator delete(__p[0]);
  }
  if (v6 < 0) {
    operator delete(v5[0]);
  }
}

void sub_1005A61B8( _Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, void *__p, uint64_t a10, int a11, __int16 a12, char a13, char a14, void *a15, uint64_t a16, int a17, __int16 a18, char a19, char a20)
{
  if (a14 < 0) {
    operator delete(__p);
  }
  if (a20 < 0) {
    operator delete(a15);
  }
  _Unwind_Resume(exception_object);
}

uint64_t sub_1005A61F4(uint64_t a1, uint64_t (***a2)(void, void, uint64_t))
{
  return (**a2)(a2, *(void *)(a1 + 32), 336LL);
}

uint64_t sub_1005A6210(uint64_t a1, uint64_t (***a2)(void, void, uint64_t))
{
  return (**a2)(a2, *(void *)(a1 + 32), 336LL);
}

uint64_t sub_1005A622C(uint64_t a1, int a2, void *a3)
{
  id v5 = a3;
  char v6 = v5;
  if (a2 == 131075)
  {
    uint64_t v7 = *(unsigned __int16 *)(a1 + 1382);
    if (!v5) {
      goto LABEL_20;
    }
  }

  else
  {
    uint64_t v7 = 0LL;
    if (!v5) {
      goto LABEL_20;
    }
  }

  if ([v5 count])
  {
    __int128 v16 = 0u;
    __int128 v17 = 0u;
    __int128 v14 = 0u;
    __int128 v15 = 0u;
    id v8 = v6;
    id v9 = [v8 countByEnumeratingWithState:&v14 objects:v18 count:16];
    if (v9)
    {
      uint64_t v10 = *(void *)v15;
      do
      {
        for (i = 0LL; i != v9; i = (char *)i + 1)
        {
          if (*(void *)v15 != v10) {
            objc_enumerationMutation(v8);
          }
          if (objc_msgSend( *(id *)(*((void *)&v14 + 1) + 8 * (void)i),  "longLongValue",  (void)v14) == 131075) {
            unsigned int v12 = *(unsigned __int16 *)(a1 + 1382);
          }
          else {
            unsigned int v12 = 0;
          }
          else {
            uint64_t v7 = v12;
          }
        }

        id v9 = [v8 countByEnumeratingWithState:&v14 objects:v18 count:16];
      }

      while (v9);
    }
  }

void sub_1005A638C(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

uint64_t sub_1005A63B8(uint64_t a1, int a2)
{
  v25[0] = 0LL;
  v25[1] = 0LL;
  sub_100242F28((uint64_t)v25, a1 + 120);
  int v4 = *(_DWORD *)(a1 + 864);
  if (v4 == 2)
  {
LABEL_2:
    id v5 = (os_log_s *)qword_1008F7620;
    if (a2)
    {
      if (os_log_type_enabled((os_log_t)qword_1008F7620, OS_LOG_TYPE_ERROR)) {
        sub_100699360();
      }
      if (a2 == 758)
      {
        sub_1005911F0(a1, 4u);
      }

      else if (a2 == 621)
      {
        uint64_t v6 = sub_1002E6E00();
        sub_1004FC118(v6, 1);
      }

      int v21 = *(_DWORD *)(a1 + 928);
      if (v21 == 1)
      {
        sub_1005911F0(a1, 0);
      }

      else if (v21)
      {
        __int16 v22 = (os_log_s *)qword_1008F7620;
        if (os_log_type_enabled((os_log_t)qword_1008F7620, OS_LOG_TYPE_DEFAULT))
        {
          unsigned int v23 = "UNKNOWN";
          if (v21 == 2) {
            unsigned int v23 = "Paused";
          }
          if (v21 == 3) {
            unsigned int v23 = "Resuming";
          }
          *(_DWORD *)__int128 buf = 136446210;
          *(void *)&uint8_t buf[4] = v23;
          _os_log_impl( (void *)&_mh_execute_header,  v22,  OS_LOG_TYPE_DEFAULT,  "handleConnectionCancelledCallback skipping processConnectingDevices, current Le Connection Manager state is %{public}s",  buf,  0xCu);
        }
      }

      else
      {
        sub_1005911F0(a1, 0);
        sub_1005A0338((id *)a1);
        sub_10059EB5C(a1);
      }
    }

    else
    {
      if (os_log_type_enabled((os_log_t)qword_1008F7620, OS_LOG_TYPE_DEFAULT))
      {
        *(_WORD *)__int128 buf = 0;
        _os_log_impl( (void *)&_mh_execute_header,  v5,  OS_LOG_TYPE_DEFAULT,  "Pending connection(s) canceled successfully",  buf,  2u);
      }

      sub_1005911F0(a1, 3u);
      if (*(_BYTE *)(a1 + 1118))
      {
        id v8 = *(const unsigned __int8 **)(a1 + 336);
        if (v8 != (const unsigned __int8 *)(a1 + 344))
        {
          do
          {
            id v9 = sub_100241F94(v8 + 25);
            uint64_t v10 = (void *)objc_claimAutoreleasedReturnValue(v9);
            BOOL v11 = sub_10058DFD4(a1, v10) == 0;

            if (!v11)
            {
              if (qword_1008D5F30 != -1) {
                dispatch_once(&qword_1008D5F30, &stru_1008A2B30);
              }
              unsigned int v12 = off_1008D5F28;
              id v13 = sub_100241F94(v8 + 25);
              __int128 v14 = (void *)objc_claimAutoreleasedReturnValue(v13);
              unint64_t v15 = sub_1005CC198((uint64_t)v12, v14, 0);

              *(_DWORD *)&buf[3] = 0;
              *(_DWORD *)__int128 buf = 0;
              uint64_t v16 = sub_1001BCDB0(v15);
              *(_DWORD *)__int128 buf = v16;
              buf[6] = BYTE6(v16);
              *(_WORD *)&uint8_t buf[4] = WORD2(v16);
              uint64_t v17 = sub_1002E6E9C();
              (*(void (**)(uint64_t, _BYTE *))(*(void *)v17 + 1792LL))(v17, buf);
            }

            id v18 = (unsigned __int8 *)*((void *)v8 + 1);
            if (v18)
            {
              do
              {
                int v19 = (const unsigned __int8 **)v18;
                id v18 = *(unsigned __int8 **)v18;
              }

              while (v18);
            }

            else
            {
              do
              {
                int v19 = (const unsigned __int8 **)*((void *)v8 + 2);
                BOOL v20 = *v19 == v8;
                id v8 = (const unsigned __int8 *)v19;
              }

              while (!v20);
            }

            id v8 = (const unsigned __int8 *)v19;
          }

          while (v19 != (const unsigned __int8 **)(a1 + 344));
        }
      }
    }

    return sub_100242FAC((uint64_t)v25);
  }

  uint64_t v7 = (os_log_s *)qword_1008F7620;
  if (os_log_type_enabled((os_log_t)qword_1008F7620, OS_LOG_TYPE_FAULT))
  {
    *(_DWORD *)__int128 buf = 67109120;
    *(_DWORD *)&uint8_t buf[4] = v4;
    _os_log_fault_impl( (void *)&_mh_execute_header,  v7,  OS_LOG_TYPE_FAULT,  "Received cancel callback outside of cancel state (%d)",  buf,  8u);
    if (*(_DWORD *)(a1 + 864) == 2) {
      goto LABEL_2;
    }
    uint64_t v7 = (os_log_s *)qword_1008F7620;
  }

  if (os_log_type_enabled(v7, OS_LOG_TYPE_ERROR)) {
    sub_1006993C8();
  }
  return sub_100242FAC((uint64_t)v25);
}

void sub_1005A6734( _Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9)
{
}

void sub_1005A6774(uint64_t a1, void *a2, unsigned int a3, int a4, double a5)
{
  id v9 = a2;
  if (qword_1008D5F30 != -1) {
    dispatch_once(&qword_1008D5F30, &stru_1008A2B30);
  }
  double v10 = sub_1005CC610((uint64_t)off_1008D5F28, v9);
  if (v10 != 0.0)
  {
    if (qword_1008D5F30 != -1) {
      dispatch_once(&qword_1008D5F30, &stru_1008A2B30);
    }
    double v11 = sub_1005CC7B8((uint64_t)off_1008D5F28, v9);
    if (qword_1008D5F30 != -1) {
      dispatch_once(&qword_1008D5F30, &stru_1008A2B30);
    }
    double v12 = sub_1005CC8D0((uint64_t)off_1008D5F28, v9);
    if (qword_1008D5F30 != -1) {
      dispatch_once(&qword_1008D5F30, &stru_1008A2B30);
    }
    double v13 = sub_1005CC9E8((uint64_t)off_1008D5F28, v9);
    if (v10 < a5 && v10 > 0.0) {
      double v14 = a5 - v10;
    }
    else {
      double v14 = 0.0;
    }
    if (v10 > 0.0 && v11 > v10) {
      double v15 = v11 - v10;
    }
    else {
      double v15 = 0.0;
    }
    BOOL v16 = v13 > v12;
    BOOL v17 = v12 > 0.0;
    double v18 = v13 - v12;
    if (v17 && v16) {
      double v19 = v18;
    }
    else {
      double v19 = 0.0;
    }
    if (v12 < a5 && v17) {
      double v20 = a5 - v12;
    }
    else {
      double v20 = 0.0;
    }
    if (qword_1008D5F30 != -1) {
      dispatch_once(&qword_1008D5F30, &stru_1008A2B30);
    }
    unsigned int v21 = sub_1005CCB00((uint64_t)off_1008D5F28, v9);
    uint64_t v80 = objc_alloc_init(&OBJC_CLASS___NSDateFormatter);
    -[NSDateFormatter setDateFormat:](v80, "setDateFormat:", @"yyyy-MM-dd H:mm:ss");
    uint64_t v77 = (void *)objc_claimAutoreleasedReturnValue( +[NSDate dateWithTimeIntervalSinceReferenceDate:]( &OBJC_CLASS___NSDate,  "dateWithTimeIntervalSinceReferenceDate:",  v10));
    uint64_t v22 = objc_claimAutoreleasedReturnValue(-[NSDateFormatter stringFromDate:](v80, "stringFromDate:"));
    unsigned int v23 = &unk_1006BB000;
    LODWORD(v23) = llround((v10 - floor(v10)) * 1000.0);
    uint64_t v79 = (void *)v22;
    __int16 v24 = (void *)objc_claimAutoreleasedReturnValue( +[NSString stringWithFormat:]( &OBJC_CLASS___NSString,  "stringWithFormat:",  @"%@.%000d",  v22,  v23));
    double v25 = 0.0;
    double v26 = (double)v21;
    double v27 = 0.0;
    if (v19 > 0.0) {
      double v27 = v26 / v19;
    }
    if (v20 > 0.0) {
      double v25 = v26 / v20;
    }
    uint64_t v84 = a1;
    int v28 = *(unsigned __int8 *)(a1 + 1379);
    if (a4 != 196608 && a4 != 19 || v28 == 0) {
      int v31 = 0;
    }
    else {
      int v31 = 75;
    }
    unsigned int v81 = v31;
    uint64_t v32 = (os_log_s *)qword_1008F7620;
    if (os_log_type_enabled((os_log_t)qword_1008F7620, OS_LOG_TYPE_DEFAULT))
    {
      *(_WORD *)__int128 buf = 0;
      _os_log_impl( (void *)&_mh_execute_header,  v32,  OS_LOG_TYPE_DEFAULT,  "statedump: ------------------ DigitalID Transaction -------------------",  buf,  2u);
      uint64_t v32 = (os_log_s *)qword_1008F7620;
    }

    unsigned int v87 = a3;
    id v82 = v24;
    if (os_log_type_enabled(v32, OS_LOG_TYPE_DEFAULT))
    {
      id v33 = [v24 UTF8String];
      *(_DWORD *)__int128 buf = 136446210;
      double v89 = *(double *)&v33;
      _os_log_impl( (void *)&_mh_execute_header,  v32,  OS_LOG_TYPE_DEFAULT,  "statedump: DigitalID - Start: %{public}s",  buf,  0xCu);
      uint64_t v32 = (os_log_s *)qword_1008F7620;
    }

    if (os_log_type_enabled(v32, OS_LOG_TYPE_DEFAULT))
    {
      *(_DWORD *)__int128 buf = 134217984;
      double v89 = v14;
      _os_log_impl( (void *)&_mh_execute_header,  v32,  OS_LOG_TYPE_DEFAULT,  "statedump: DigitalID - Connection Duration: %.3f (secs)",  buf,  0xCu);
      uint64_t v32 = (os_log_s *)qword_1008F7620;
    }

    if (os_log_type_enabled(v32, OS_LOG_TYPE_DEFAULT))
    {
      *(_DWORD *)__int128 buf = 134217984;
      double v89 = v15;
      _os_log_impl( (void *)&_mh_execute_header,  v32,  OS_LOG_TYPE_DEFAULT,  "statedump: DigitalID - Connection Set-up Duration: %.3f (secs)",  buf,  0xCu);
      uint64_t v32 = (os_log_s *)qword_1008F7620;
    }

    if (os_log_type_enabled(v32, OS_LOG_TYPE_DEFAULT))
    {
      *(_DWORD *)__int128 buf = 134217984;
      double v89 = v19;
      _os_log_impl( (void *)&_mh_execute_header,  v32,  OS_LOG_TYPE_DEFAULT,  "statedump: DigitalID - Data Transfer Duration: %.3f (secs)",  buf,  0xCu);
      uint64_t v32 = (os_log_s *)qword_1008F7620;
    }

    if (os_log_type_enabled(v32, OS_LOG_TYPE_DEFAULT))
    {
      *(_DWORD *)__int128 buf = 134217984;
      double v89 = v20;
      _os_log_impl( (void *)&_mh_execute_header,  v32,  OS_LOG_TYPE_DEFAULT,  "statedump: DigitalID - Presentment Data Transfer Duration: %.3f (secs)",  buf,  0xCu);
      uint64_t v32 = (os_log_s *)qword_1008F7620;
    }

    if (os_log_type_enabled(v32, OS_LOG_TYPE_DEFAULT))
    {
      *(_DWORD *)__int128 buf = 67109120;
      LODWORD(v89) = v21;
      _os_log_impl( (void *)&_mh_execute_header,  v32,  OS_LOG_TYPE_DEFAULT,  "statedump: DigitalID - Data Bytes: %d",  buf,  8u);
      uint64_t v32 = (os_log_s *)qword_1008F7620;
    }

    if (os_log_type_enabled(v32, OS_LOG_TYPE_DEFAULT))
    {
      *(_DWORD *)__int128 buf = 134218240;
      double v89 = v27;
      __int16 v90 = 2048;
      *(double *)__int128 v91 = v27 * 8.0;
      _os_log_impl( (void *)&_mh_execute_header,  v32,  OS_LOG_TYPE_DEFAULT,  "statedump: DigitalID - Data Transfer Throughput: %.3f (bytes/sec) %.3f (bits/sec)",  buf,  0x16u);
      uint64_t v32 = (os_log_s *)qword_1008F7620;
    }

    if (os_log_type_enabled(v32, OS_LOG_TYPE_DEFAULT))
    {
      *(_DWORD *)__int128 buf = 134218240;
      double v89 = v25;
      __int16 v90 = 2048;
      *(double *)__int128 v91 = v25 * 8.0;
      _os_log_impl( (void *)&_mh_execute_header,  v32,  OS_LOG_TYPE_DEFAULT,  "statedump: DigitalID - Presentment Data Transfer Throughput: %.3f (bytes/sec) %.3f (bits/sec)",  buf,  0x16u);
      uint64_t v32 = (os_log_s *)qword_1008F7620;
    }

    if (os_log_type_enabled(v32, OS_LOG_TYPE_DEFAULT))
    {
      *(_DWORD *)__int128 buf = 67109120;
      LODWORD(v89) = a3;
      _os_log_impl( (void *)&_mh_execute_header,  v32,  OS_LOG_TYPE_DEFAULT,  "statedump: DigitalID - Disconnection Reason: %d",  buf,  8u);
      uint64_t v32 = (os_log_s *)qword_1008F7620;
    }

    if (os_log_type_enabled(v32, OS_LOG_TYPE_DEFAULT))
    {
      uint64_t v34 = "Yes";
      if (!v28) {
        uint64_t v34 = "No";
      }
      *(_DWORD *)__int128 buf = 136315138;
      double v89 = *(double *)&v34;
      _os_log_impl( (void *)&_mh_execute_header,  v32,  OS_LOG_TYPE_DEFAULT,  "statedump: DigitalID - Is Connection Prioritization Supported: %s",  buf,  0xCu);
      uint64_t v32 = (os_log_s *)qword_1008F7620;
    }

    if (os_log_type_enabled(v32, OS_LOG_TYPE_DEFAULT))
    {
      *(_DWORD *)__int128 buf = 67109120;
      LODWORD(v89) = v81;
      _os_log_impl( (void *)&_mh_execute_header,  v32,  OS_LOG_TYPE_DEFAULT,  "statedump: DigitalID - Prioritized Connection Intervals Percent: %d",  buf,  8u);
    }

    unsigned int v83 = v21;
    if (qword_1008D6198 != -1) {
      dispatch_once(&qword_1008D6198, &stru_1008A2B70);
    }
    int v35 = *((_DWORD *)off_1008D6190 + 39);
    int v36 = *((_DWORD *)off_1008D6190 + 40);
    int v37 = *((unsigned __int8 *)off_1008D6190 + 196);
    int v38 = *((unsigned __int8 *)off_1008D6190 + 197);
    int v86 = *((unsigned __int8 *)off_1008D6190 + 198);
    int v39 = *((unsigned __int8 *)off_1008D6190 + 199);
    int v85 = *((unsigned __int8 *)off_1008D6190 + 204);
    uint64_t v40 = sub_1002E8EE8();
    int v41 = (*(uint64_t (**)(uint64_t))(*(void *)v40 + 120LL))(v40);
    if (v39) {
      BOOL v78 = *(_BYTE *)(a1 + 1379) != 0;
    }
    else {
      BOOL v78 = 0;
    }
    id v42 = (os_log_s *)qword_1008F7620;
    if (os_log_type_enabled((os_log_t)qword_1008F7620, OS_LOG_TYPE_DEFAULT))
    {
      *(_WORD *)__int128 buf = 0;
      _os_log_impl( (void *)&_mh_execute_header,  v42,  OS_LOG_TYPE_DEFAULT,  "statedump: ---------- DigitalID Concurrent Usages Statistics ----------",  buf,  2u);
      id v42 = (os_log_s *)qword_1008F7620;
    }

    if (os_log_type_enabled(v42, OS_LOG_TYPE_DEFAULT))
    {
      *(_DWORD *)__int128 buf = 67109120;
      LODWORD(v89) = v35;
      _os_log_impl( (void *)&_mh_execute_header,  v42,  OS_LOG_TYPE_DEFAULT,  "statedump: DigitalID - Num Classic Connections: %d",  buf,  8u);
      id v42 = (os_log_s *)qword_1008F7620;
    }

    if (os_log_type_enabled(v42, OS_LOG_TYPE_DEFAULT))
    {
      *(_DWORD *)__int128 buf = 67109120;
      LODWORD(v89) = v36;
      _os_log_impl( (void *)&_mh_execute_header,  v42,  OS_LOG_TYPE_DEFAULT,  "statedump: DigitalID - Num LE Connections: %d",  buf,  8u);
      id v42 = (os_log_s *)qword_1008F7620;
    }

    if (os_log_type_enabled(v42, OS_LOG_TYPE_DEFAULT))
    {
      unsigned int v43 = "No";
      if (v37) {
        unsigned int v43 = "Yes";
      }
      *(_DWORD *)__int128 buf = 136446210;
      double v89 = *(double *)&v43;
      _os_log_impl( (void *)&_mh_execute_header,  v42,  OS_LOG_TYPE_DEFAULT,  "statedump: DigitalID - Watch Connected: %{public}s",  buf,  0xCu);
      id v42 = (os_log_s *)qword_1008F7620;
    }

    if (os_log_type_enabled(v42, OS_LOG_TYPE_DEFAULT))
    {
      uint64_t v44 = "No";
      if (v38) {
        uint64_t v44 = "Yes";
      }
      *(_DWORD *)__int128 buf = 136446210;
      double v89 = *(double *)&v44;
      _os_log_impl( (void *)&_mh_execute_header,  v42,  OS_LOG_TYPE_DEFAULT,  "statedump: DigitalID - A2DP Streaming: %{public}s",  buf,  0xCu);
      id v42 = (os_log_s *)qword_1008F7620;
    }

    if (os_log_type_enabled(v42, OS_LOG_TYPE_DEFAULT))
    {
      __int128 v45 = "No";
      if (v86) {
        __int128 v45 = "Yes";
      }
      *(_DWORD *)__int128 buf = 136446210;
      double v89 = *(double *)&v45;
      _os_log_impl( (void *)&_mh_execute_header,  v42,  OS_LOG_TYPE_DEFAULT,  "statedump: DigitalID - HFP Streaming: %{public}s",  buf,  0xCu);
      id v42 = (os_log_s *)qword_1008F7620;
    }

    if (os_log_type_enabled(v42, OS_LOG_TYPE_DEFAULT))
    {
      __int128 v46 = "No";
      if (v39) {
        __int128 v46 = "Yes";
      }
      *(_DWORD *)__int128 buf = 136446210;
      double v89 = *(double *)&v46;
      _os_log_impl( (void *)&_mh_execute_header,  v42,  OS_LOG_TYPE_DEFAULT,  "statedump: DigitalID - LEA Streaming: %{public}s",  buf,  0xCu);
      id v42 = (os_log_s *)qword_1008F7620;
    }

    if (os_log_type_enabled(v42, OS_LOG_TYPE_DEFAULT))
    {
      BOOL v47 = "No";
      if (v85) {
        BOOL v47 = "Yes";
      }
      *(_DWORD *)__int128 buf = 136446210;
      double v89 = *(double *)&v47;
      _os_log_impl( (void *)&_mh_execute_header,  v42,  OS_LOG_TYPE_DEFAULT,  "statedump: DigitalID - ISO Pipe Streaming: %{public}s",  buf,  0xCu);
      id v42 = (os_log_s *)qword_1008F7620;
    }

    if (os_log_type_enabled(v42, OS_LOG_TYPE_DEFAULT))
    {
      id v48 = "No";
      if (v41) {
        id v48 = "Yes";
      }
      *(_DWORD *)__int128 buf = 136446210;
      double v89 = *(double *)&v48;
      _os_log_impl( (void *)&_mh_execute_header,  v42,  OS_LOG_TYPE_DEFAULT,  "statedump: DigitalID - WiFi on 2.4GHz: %{public}s",  buf,  0xCu);
      id v42 = (os_log_s *)qword_1008F7620;
    }

    if (os_signpost_enabled(v42))
    {
      id v49 = [v82 UTF8String];
      *(_DWORD *)__int128 buf = 138545154;
      double v89 = *(double *)&v9;
      __int16 v90 = 2082;
      *(void *)__int128 v91 = v49;
      *(_WORD *)&v91[8] = 2048;
      *(double *)uint64_t v92 = v14;
      *(_WORD *)&v92[8] = 2048;
      *(double *)unint64_t v93 = v15;
      *(_WORD *)&v93[8] = 2048;
      *(double *)BOOL v94 = v19;
      *(_WORD *)&v94[8] = 1024;
      *(_DWORD *)__int128 v95 = v83;
      *(_WORD *)&v95[4] = 2048;
      *(double *)&v95[6] = v27;
      *(_WORD *)&v95[14] = 1024;
      *(_DWORD *)&v95[16] = v87;
      _os_signpost_emit_with_name_impl( (void *)&_mh_execute_header,  v42,  OS_SIGNPOST_EVENT,  0xEEEEB0B5B2B2EEEELL,  "BTSignPost",  "BLE DigitalID Stat for %{public}@ start %{public}s duration total %.3f set-up %.3f data_transfer %.3f bytes %d t hroughput %.3f (bytes/sec) disconnect_reason %d",  buf,  0x4Au);
      id v42 = (os_log_s *)qword_1008F7620;
    }

    if (os_signpost_enabled(v42))
    {
      uint64_t v50 = "No";
      *(_DWORD *)__int128 buf = 138545410;
      double v89 = *(double *)&v9;
      __int16 v90 = 1024;
      if (v37) {
        std::stringbuf::string_type v51 = "Yes";
      }
      else {
        std::stringbuf::string_type v51 = "No";
      }
      *(_DWORD *)__int128 v91 = v35;
      if (v38) {
        uint64_t v52 = "Yes";
      }
      else {
        uint64_t v52 = "No";
      }
      *(_WORD *)&v91[4] = 1024;
      if (v86) {
        __int16 v53 = "Yes";
      }
      else {
        __int16 v53 = "No";
      }
      *(_DWORD *)&v91[6] = v36;
      if (v39) {
        uint64_t v54 = "Yes";
      }
      else {
        uint64_t v54 = "No";
      }
      *(_WORD *)uint64_t v92 = 2082;
      if (v85) {
        char v55 = "Yes";
      }
      else {
        char v55 = "No";
      }
      *(void *)&v92[2] = v51;
      if (v41) {
        uint64_t v50 = "Yes";
      }
      *(_WORD *)unint64_t v93 = 2082;
      *(void *)&v93[2] = v52;
      *(_WORD *)BOOL v94 = 2082;
      *(void *)&v94[2] = v53;
      *(_WORD *)__int128 v95 = 2082;
      *(void *)&v95[2] = v54;
      *(_WORD *)&v95[10] = 2082;
      *(void *)&v95[12] = v55;
      __int16 v96 = 2082;
      id v97 = v50;
      _os_signpost_emit_with_name_impl( (void *)&_mh_execute_header,  v42,  OS_SIGNPOST_EVENT,  0xEEEEB0B5B2B2EEEELL,  "BTSignPost",  "BLE DigitalID Condition for %{public}@ Classic %d LE %d Watch %{public}s A2DP %{public}s HFP %{public}s LEA %{pu blic}s ISO %{public}s WiFi 2.4GHz %{public}s",  buf,  0x54u);
    }

    id v56 = (void *)objc_claimAutoreleasedReturnValue(+[NSMutableDictionary dictionary](&OBJC_CLASS___NSMutableDictionary, "dictionary"));
    unint64_t v57 = (void *)objc_claimAutoreleasedReturnValue(+[NSNumber numberWithDouble:](&OBJC_CLASS___NSNumber, "numberWithDouble:", v14));
    [v56 setObject:v57 forKeyedSubscript:@"ConnectionDurationInSec"];

    uint64_t v58 = (void *)objc_claimAutoreleasedReturnValue(+[NSNumber numberWithDouble:](&OBJC_CLASS___NSNumber, "numberWithDouble:", v15));
    [v56 setObject:v58 forKeyedSubscript:@"ConnectionSetupDurationInSec"];

    int v59 = (void *)objc_claimAutoreleasedReturnValue(+[NSNumber numberWithDouble:](&OBJC_CLASS___NSNumber, "numberWithDouble:", v19));
    [v56 setObject:v59 forKeyedSubscript:@"DataTransferDurationInSec"];

    uint64_t v60 = (void *)objc_claimAutoreleasedReturnValue(+[NSNumber numberWithUnsignedInt:](&OBJC_CLASS___NSNumber, "numberWithUnsignedInt:", v83));
    [v56 setObject:v60 forKeyedSubscript:@"DataBytes"];

    int v61 = (void *)objc_claimAutoreleasedReturnValue(+[NSNumber numberWithDouble:](&OBJC_CLASS___NSNumber, "numberWithDouble:", v27));
    [v56 setObject:v61 forKeyedSubscript:@"ThroughputBytesPerSec"];

    int v62 = (void *)objc_claimAutoreleasedReturnValue(+[NSNumber numberWithUnsignedInt:](&OBJC_CLASS___NSNumber, "numberWithUnsignedInt:", v87));
    [v56 setObject:v62 forKeyedSubscript:@"DisconnectionReason"];

    id v63 = (void *)objc_claimAutoreleasedReturnValue(+[NSNumber numberWithBool:](&OBJC_CLASS___NSNumber, "numberWithBool:", v37 != 0));
    [v56 setObject:v63 forKeyedSubscript:@"IsWatchConnected"];

    unsigned __int8 v64 = (void *)objc_claimAutoreleasedReturnValue(+[NSNumber numberWithBool:](&OBJC_CLASS___NSNumber, "numberWithBool:", v38 != 0));
    [v56 setObject:v64 forKeyedSubscript:@"IsA2DPSessionActive"];

    uint64_t v65 = (void *)objc_claimAutoreleasedReturnValue(+[NSNumber numberWithBool:](&OBJC_CLASS___NSNumber, "numberWithBool:", v86 != 0));
    [v56 setObject:v65 forKeyedSubscript:@"IsHFPSessionActive"];

    uint64_t v66 = (void *)objc_claimAutoreleasedReturnValue(+[NSNumber numberWithBool:](&OBJC_CLASS___NSNumber, "numberWithBool:", v39 != 0));
    [v56 setObject:v66 forKeyedSubscript:@"IsLEASessionActive"];

    uint64_t v67 = (void *)objc_claimAutoreleasedReturnValue(+[NSNumber numberWithBool:](&OBJC_CLASS___NSNumber, "numberWithBool:", v85 != 0));
    [v56 setObject:v67 forKeyedSubscript:@"IsISOPipeStreamingActive"];

    uint64_t v68 = +[NSString stringWithUTF8String:](&OBJC_CLASS___NSString, "stringWithUTF8String:", sub_100595B00(a4));
    uint64_t v69 = (void *)objc_claimAutoreleasedReturnValue(v68);
    [v56 setObject:v69 forKeyedSubscript:@"UseCase"];

    uint64_t v70 = (void *)objc_claimAutoreleasedReturnValue( +[NSNumber numberWithBool:]( &OBJC_CLASS___NSNumber,  "numberWithBool:",  *(unsigned __int8 *)(v84 + 1379)));
    [v56 setObject:v70 forKeyedSubscript:@"IsConnPrioritizationSupported"];

    uint64_t v71 = (void *)objc_claimAutoreleasedReturnValue(+[NSNumber numberWithUnsignedInt:](&OBJC_CLASS___NSNumber, "numberWithUnsignedInt:", v81));
    [v56 setObject:v71 forKeyedSubscript:@"PrioritizedConnIntervalsPercentage"];

    uint64_t v72 = (void *)objc_claimAutoreleasedReturnValue(+[NSNumber numberWithBool:](&OBJC_CLASS___NSNumber, "numberWithBool:", v78));
    [v56 setObject:v72 forKeyedSubscript:@"ProtectLEA"];

    v73 = (void *)objc_claimAutoreleasedReturnValue(+[NSNumber numberWithDouble:](&OBJC_CLASS___NSNumber, "numberWithDouble:", v20));
    [v56 setObject:v73 forKeyedSubscript:@"PresentmentDuration"];

    uint64_t v74 = (void *)objc_claimAutoreleasedReturnValue(+[NSNumber numberWithDouble:](&OBJC_CLASS___NSNumber, "numberWithDouble:", v25));
    [v56 setObject:v74 forKeyedSubscript:@"PresentmentThroughputBytesPerSec"];

    uint64_t v75 = (os_log_s *)qword_1008F7620;
    if (os_log_type_enabled((os_log_t)qword_1008F7620, OS_LOG_TYPE_DEFAULT))
    {
      *(_DWORD *)__int128 buf = 138543362;
      double v89 = *(double *)&v56;
      _os_log_impl( (void *)&_mh_execute_header,  v75,  OS_LOG_TYPE_DEFAULT,  "Sending DigitalIDMetric :%{public}@",  buf,  0xCu);
    }

    uint64_t v76 = sub_1002E8D94();
    (*(void (**)(uint64_t, void *))(*(void *)v76 + 288LL))(v76, v56);
  }
}

void sub_1005A7704( _Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, void *a12, uint64_t a13, void *a14, uint64_t a15, void *a16, uint64_t a17, void *a18)
{
  _Unwind_Resume(a1);
}

void sub_1005A7858(uint64_t a1, void *a2)
{
  id v2 = a2;
  if (qword_1008D5F30 != -1) {
    dispatch_once(&qword_1008D5F30, &stru_1008A2B30);
  }
  sub_1005CC960((uint64_t)off_1008D5F28, v2, 0.0);
  if (qword_1008D5F30 != -1) {
    dispatch_once(&qword_1008D5F30, &stru_1008A2B30);
  }
  sub_1005CCA78((uint64_t)off_1008D5F28, v2, 0.0);
  if (qword_1008D5F30 != -1) {
    dispatch_once(&qword_1008D5F30, &stru_1008A2B30);
  }
  sub_1005CCB88((uint64_t)off_1008D5F28, v2, 0);
}

void sub_1005A7928( _Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, id a10)
{
}

void sub_1005A793C(uint64_t a1, void *a2, int a3, uint64_t a4)
{
  id v7 = a2;
  if (qword_1008D5F20 != -1) {
    dispatch_once(&qword_1008D5F20, &stru_1008A2BF0);
  }
  BOOL v8 = sub_10061C0F8(qword_1008D5F18, v7);
  if (qword_1008D5F30 != -1) {
    dispatch_once(&qword_1008D5F30, &stru_1008A2B30);
  }
  double v9 = sub_1005CC610((uint64_t)off_1008D5F28, v7);
  double v10 = 0.0;
  if (CFAbsoluteTimeGetCurrent() > v9) {
    double v10 = CFAbsoluteTimeGetCurrent() - v9;
  }
  if (qword_1008D5F30 != -1) {
    dispatch_once(&qword_1008D5F30, &stru_1008A2B30);
  }
  uint64_t v11 = sub_1005D1E08((uint64_t)off_1008D5F28, v7);
  double v12 = (void *)objc_claimAutoreleasedReturnValue(+[NSMutableDictionary dictionary](&OBJC_CLASS___NSMutableDictionary, "dictionary"));
  double v13 = (void *)objc_claimAutoreleasedReturnValue(+[NSNumber numberWithBool:](&OBJC_CLASS___NSNumber, "numberWithBool:", v8));
  [v12 setObject:v13 forKeyedSubscript:@"Paired"];

  double v14 = (void *)objc_claimAutoreleasedReturnValue(+[NSNumber numberWithDouble:](&OBJC_CLASS___NSNumber, "numberWithDouble:", v10));
  [v12 setObject:v14 forKeyedSubscript:@"DurationInSeconds"];

  double v15 = (void *)objc_claimAutoreleasedReturnValue(+[NSNumber numberWithUnsignedInt:](&OBJC_CLASS___NSNumber, "numberWithUnsignedInt:", a4));
  [v12 setObject:v15 forKeyedSubscript:@"DisconnectReasonCode"];

  BOOL v16 = (void *)objc_claimAutoreleasedReturnValue(+[NSNumber numberWithBool:](&OBJC_CLASS___NSNumber, "numberWithBool:", a3 == 0));
  [v12 setObject:v16 forKeyedSubscript:@"Initiator"];

  BOOL v17 = (void *)objc_claimAutoreleasedReturnValue(+[NSNumber numberWithShort:](&OBJC_CLASS___NSNumber, "numberWithShort:", v11));
  [v12 setObject:v17 forKeyedSubscript:@"ConnectionEstablishedRSSI"];

  sub_100241F90(buf, v7);
  __int16 v24 = buf;
  double v18 = +[NSNumber numberWithUnsignedShort:]( &OBJC_CLASS___NSNumber,  "numberWithUnsignedShort:",  *((unsigned __int16 *)sub_1005BDFA8( (uint64_t **)(a1 + 480),  buf,  (uint64_t)&unk_1006C2518,  (const unsigned __int8 *__attribute__((__org_typedef(uuid_t))) *)&v24)
          + 21));
  double v19 = (void *)objc_claimAutoreleasedReturnValue(v18);
  [v12 setObject:v19 forKeyedSubscript:@"PreviousConnectRetries"];

  if (qword_1008D5F30 != -1) {
    dispatch_once(&qword_1008D5F30, &stru_1008A2B30);
  }
  id v20 = sub_1005D2BD0((uint64_t)off_1008D5F28, v7);
  unsigned int v21 = (void *)objc_claimAutoreleasedReturnValue(v20);
  [v12 setObject:v21 forKeyedSubscript:@"UseCase"];

  uint64_t v22 = (os_log_s *)qword_1008F7620;
  if (os_log_type_enabled((os_log_t)qword_1008F7620, OS_LOG_TYPE_DEFAULT))
  {
    *(_DWORD *)__int128 buf = 138543362;
    double v26 = v12;
    _os_log_impl( (void *)&_mh_execute_header,  v22,  OS_LOG_TYPE_DEFAULT,  "Sending LeConnectRetry metric :%{public}@",  buf,  0xCu);
  }

  uint64_t v23 = sub_1002E8D94();
  (*(void (**)(uint64_t, void *))(*(void *)v23 + 280LL))(v23, v12);
}

void sub_1005A7C9C(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

uint64_t sub_1005A7D18( uint64_t a1, uint64_t a2, unint64_t a3, uint64_t a4, int a5, uint64_t a6, int a7, int a8, unsigned int a9)
{
  uint64_t v15 = sub_1002E8D94();
  (*(void (**)(uint64_t, unint64_t, uint64_t))(*(void *)v15 + 560LL))(v15, a3, a4);
  uint64_t v16 = sub_1002E8D94();
  (*(void (**)(uint64_t, unint64_t, uint64_t))(*(void *)v16 + 536LL))(v16, a3, a4);
  if (qword_1008D6628 != -1) {
    dispatch_once(&qword_1008D6628, &stru_1008A2B90);
  }
  sub_100333B70(qword_1008D6620, a4);
  v213[0] = 0LL;
  v213[1] = 0LL;
  sub_100242F28((uint64_t)v213, a1 + 120);
  memset(uu, 0, sizeof(uu));
  uuid_clear(uu);
  BOOL v17 = (os_log_s *)qword_1008F7620;
  if (os_log_type_enabled((os_log_t)qword_1008F7620, OS_LOG_TYPE_DEFAULT))
  {
    id v18 = sub_1005BFB9C(a2);
    id v19 = (id)objc_claimAutoreleasedReturnValue(v18);
    id v20 = v19;
    *(_DWORD *)__int128 buf = 67110402;
    unsigned int v21 = "Peripheral";
    *(_DWORD *)&uint8_t buf[4] = a6;
    *(_WORD *)&uint8_t buf[8] = 2114;
    if (!a5) {
      unsigned int v21 = "Central";
    }
    *(void *)&buf[10] = v19;
    *(_WORD *)&buf[18] = 2082;
    *(void *)&buf[20] = v21;
    uint64_t v22 = "Yes";
    *(_WORD *)&buf[28] = 2082;
    if (!a7) {
      uint64_t v22 = "No";
    }
    *(void *)&buf[30] = v22;
    *(_WORD *)&buf[38] = 1024;
    *(_DWORD *)&buf[40] = a8;
    *(_WORD *)&buf[44] = 1024;
    *(_DWORD *)&buf[46] = a9;
    _os_log_impl( (void *)&_mh_execute_header,  v17,  OS_LOG_TYPE_DEFAULT,  "LE ConnManager disconnection complete reason %d address=%{public}@ localRole=%{public}s wakeUp=%{public}s encrypte d:%d timeOffsetInMs:%d",  buf,  0x32u);
  }

  uint64_t v23 = sub_100404FE8();
  __int16 v24 = operator new(0x28uLL);
  v24[4] = 1;
  *((void *)v24 + 2) = 0LL;
  *(void *)__int16 v24 = &off_1008A2AB0;
  *((void *)v24 + 3) = sub_1002E91F8(1LL, 2LL, 0LL);
  *((void *)v24 + 4) = 3000LL;
  *((void *)v24 + 2) = 3000LL;
  sub_100405744(v23, v24);
  id v25 = sub_10059A5A8(a1, a3);
  __uint64_t v200 = (void *)objc_claimAutoreleasedReturnValue(v25);
  sub_1005A2C94((uint64_t)v200, v200, 5u, a5 == 1, a7);
  double v26 = *(unsigned __int8 **)(a1 + 384);
  if (v26 != (unsigned __int8 *)(a1 + 392))
  {
    while (*((void *)v26 + 6) != a3)
    {
      double v27 = (unsigned __int8 *)*((void *)v26 + 1);
      if (v27)
      {
        do
        {
          int v28 = v27;
          double v27 = *(unsigned __int8 **)v27;
        }

        while (v27);
      }

      else
      {
        do
        {
          int v28 = (unsigned __int8 *)*((void *)v26 + 2);
          BOOL v29 = *(void *)v28 == (void)v26;
          double v26 = v28;
        }

        while (!v29);
      }

      double v26 = v28;
    }

    uuid_copy(uu, v26 + 32);
    if (qword_1008D5F30 != -1) {
      dispatch_once(&qword_1008D5F30, &stru_1008A2B30);
    }
    __int16 v30 = off_1008D5F28;
    int v31 = sub_100241F94(uu);
    uint64_t v32 = (void *)objc_claimAutoreleasedReturnValue(v31);
    sub_1005D3868((uint64_t)v30, v32, 0, 2, a9);

    id v33 = (uint64_t *)sub_1001FDB10(a1 + 640, uu);
    if ((uint64_t *)(a1 + 648) != v33)
    {
      sub_1001FDBCC((uint64_t **)(a1 + 640), v33);
      operator delete(v33);
    }

    sub_1001FDBCC((uint64_t **)(a1 + 384), (uint64_t *)v26);
    operator delete(v26);
    sub_100241F90(buf, v200);
    sub_1005BE0C0((uint64_t **)(a1 + 840), buf);
  }

LABEL_194:
      if (os_log_type_enabled((os_log_t)qword_1008F7620, OS_LOG_TYPE_ERROR))
      {
        sub_100366664(uu, v219);
        sub_100699458();
      }

LABEL_196:
      int v93 = 1;
      int v92 = 1;
      goto LABEL_200;
    }

    __int16 v96 = (os_log_s *)qword_1008F7620;
    if (os_log_type_enabled((os_log_t)qword_1008F7620, OS_LOG_TYPE_DEFAULT))
    {
      memset(buf, 0, 37);
      uuid_unparse_upper(uu, (char *)buf);
      sub_10002418C(v214, (char *)buf);
      id v97 = SBYTE1(v215) >= 0 ? v214 : *(_BYTE **)v214;
      *(_DWORD *)id v219 = 136446210;
      *(void *)uint64_t v220 = v97;
      _os_log_impl( (void *)&_mh_execute_header,  v96,  OS_LOG_TYPE_DEFAULT,  "Disconnected from device %{public}s successfully (locally-initiated)",  v219,  0xCu);
      if (SBYTE1(v215) < 0) {
        operator delete(*(void **)v214);
      }
    }

    int v93 = 0;
    int v92 = 0;
    goto LABEL_200;
  }

  if ((int)a6 <= 4832)
  {
    switch((_DWORD)a6)
    {
      case 0x2F9:
        if (os_log_type_enabled((os_log_t)qword_1008F7620, OS_LOG_TYPE_ERROR))
        {
          sub_100366664(uu, v219);
          sub_1006996B4();
        }

        int v93 = 0;
        int v92 = 182;
        goto LABEL_200;
      case 0x2FA:
        if (os_log_type_enabled((os_log_t)qword_1008F7620, OS_LOG_TYPE_ERROR))
        {
          sub_100366664(uu, v219);
          sub_1006994A0();
        }

        int v92 = 305;
        goto LABEL_190;
      case 0x11BD:
        BOOL v94 = (os_log_s *)qword_1008F7620;
        if (os_log_type_enabled((os_log_t)qword_1008F7620, OS_LOG_TYPE_DEFAULT))
        {
          sub_100366664(uu, buf);
          __int128 v95 = (buf[23] & 0x80u) == 0 ? buf : *(uint8_t **)buf;
          *(_DWORD *)int v214 = 136446210;
          *(void *)&v214[4] = v95;
          _os_log_impl( (void *)&_mh_execute_header,  v94,  OS_LOG_TYPE_DEFAULT,  "Disconnected from device %{public}s because we timed out waiting for indication response",  v214,  0xCu);
        }

        int v92 = 1019;
        goto LABEL_190;
    }

    goto LABEL_194;
  }

  if ((int)a6 > 4834)
  {
    if ((_DWORD)a6 == 4835)
    {
      if (os_log_type_enabled((os_log_t)qword_1008F7620, OS_LOG_TYPE_ERROR))
      {
        sub_100366664(uu, v219);
        sub_100699668();
      }

      int v93 = 0;
      int v92 = 180;
      goto LABEL_200;
    }

    if ((_DWORD)a6 == 5300)
    {
      __int128 v98 = (os_log_s *)qword_1008F7620;
      if (os_log_type_enabled((os_log_t)qword_1008F7620, OS_LOG_TYPE_DEFAULT))
      {
        sub_100366664(uu, buf);
        v99 = (buf[23] & 0x80u) == 0 ? buf : *(uint8_t **)buf;
        *(_DWORD *)int v214 = 136446210;
        *(void *)&v214[4] = v99;
        _os_log_impl( (void *)&_mh_execute_header,  v98,  OS_LOG_TYPE_DEFAULT,  "Disconnected from device %{public}s because we LEA stalled",  v214,  0xCu);
      }

      int v92 = 2000;
      goto LABEL_190;
    }

    goto LABEL_194;
  }

  if ((_DWORD)a6 == 4833)
  {
    unsigned int v100 = (os_log_s *)qword_1008F7620;
    if (os_log_type_enabled((os_log_t)qword_1008F7620, OS_LOG_TYPE_DEFAULT))
    {
      sub_100366664(uu, buf);
      v101 = (buf[23] & 0x80u) == 0 ? buf : *(uint8_t **)buf;
      *(_DWORD *)int v214 = 136446210;
      *(void *)&v214[4] = v101;
      _os_log_impl( (void *)&_mh_execute_header,  v100,  OS_LOG_TYPE_DEFAULT,  "Disconnected from device %{public}s because it is no longer paired to us",  v214,  0xCu);
    }

    int v93 = 0;
    int v92 = 179;
  }

  else
  {
    if (os_log_type_enabled((os_log_t)qword_1008F7620, OS_LOG_TYPE_ERROR))
    {
      sub_100366664(uu, v219);
      sub_10069961C();
    }

    if (qword_1008D5F30 != -1) {
      dispatch_once(&qword_1008D5F30, &stru_1008A2B30);
    }
    uint64_t v79 = (uint64_t)off_1008D5F28;
    uint64_t v80 = sub_100241F94(uu);
    unsigned int v81 = (void *)objc_claimAutoreleasedReturnValue(v80);
    id v82 = sub_1005D7650(v79, v81);
    unsigned int v83 = (void *)objc_claimAutoreleasedReturnValue(v82);
    LOBYTE(v79) = v83 == 0LL;

    if ((v79 & 1) == 0)
    {
      if (qword_1008D5F30 != -1) {
        dispatch_once(&qword_1008D5F30, &stru_1008A2B30);
      }
      uint64_t v84 = off_1008D5F28;
      int v85 = sub_100241F94(uu);
      int v86 = (void *)objc_claimAutoreleasedReturnValue(v85);
      sub_1005C6DEC((uint64_t)v84, v86);

      if (qword_1008D5F30 != -1) {
        dispatch_once(&qword_1008D5F30, &stru_1008A2B30);
      }
      unsigned int v87 = off_1008D5F28;
      unsigned int v88 = sub_100241F94(uu);
      double v89 = (void *)objc_claimAutoreleasedReturnValue(v88);
      sub_1005D73C8((uint64_t)v87, v89, 2u, (uint64_t)buf);
      BOOL v90 = *(void *)&buf[16] == 0LL;
      sub_10023BF24((uint64_t)buf, *(void **)&buf[8]);

      BOOL v91 = os_log_type_enabled((os_log_t)qword_1008F7620, OS_LOG_TYPE_ERROR);
      if (!v90)
      {
        if (v91)
        {
          sub_100366664(uu, v218);
          sub_1006995D0();
        }

        int v92 = 315;
LABEL_190:
        int v93 = 1;
        goto LABEL_200;
      }

      if (v91)
      {
        sub_100366664(uu, v218);
        sub_100699584();
      }
    }

    int v93 = 0;
    int v92 = 315;
  }

LABEL_200:
  int v104 = v93 & (v198 ^ 1);
  if (a5) {
    int v105 = 0;
  }
  else {
    int v105 = v104;
  }
  v106 = (os_log_s *)qword_1008F7620;
  if (os_log_type_enabled((os_log_t)qword_1008F7620, OS_LOG_TYPE_DEFAULT))
  {
    *(_DWORD *)__int128 buf = 67110144;
    *(_DWORD *)&uint8_t buf[4] = v69;
    *(_WORD *)&uint8_t buf[8] = 1024;
    *(_DWORD *)&buf[10] = v198;
    *(_WORD *)&buf[14] = 1024;
    *(_DWORD *)&buf[16] = a5;
    *(_WORD *)&buf[20] = 1024;
    *(_DWORD *)&_BYTE buf[22] = a6;
    *(_WORD *)&buf[26] = 1024;
    *(_DWORD *)&buf[28] = v92;
    _os_log_impl( (void *)&_mh_execute_header,  v106,  OS_LOG_TYPE_DEFAULT,  "linkReady:%d disconnectDevice:%d localRole:%d reason:%d result:%d",  buf,  0x20u);
  }

  if ((v69 | v105 ^ 1) == 1)
  {
    if (!a5)
    {
      if (qword_1008D5F20 != -1) {
        dispatch_once(&qword_1008D5F20, &stru_1008A2BF0);
      }
      sub_10062A7B4(qword_1008D5F18, uu);
      if (qword_1008D5F20 != -1) {
        dispatch_once(&qword_1008D5F20, &stru_1008A2BF0);
      }
      sub_10062A96C(qword_1008D5F18, uu);
    }

    sub_100599B60(a1, uu);
  }

  uint64_t v217 = 0LL;
  memset(buf, 0, sizeof(buf));
  id v107 = sub_100241F94(uu);
  uint64_t v108 = (void *)objc_claimAutoreleasedReturnValue(v107);
  sub_10058C504(a1, v108, (uint64_t)buf);

  if (*(void *)buf)
  {
    buf[52] = a7;
    v109 = sub_100241F94(uu);
    v110 = (void *)objc_claimAutoreleasedReturnValue(v109);
    v206[0] = *(id *)buf;
    v206[1] = *(id *)&buf[8];
    __int128 v207 = *(_OWORD *)&buf[16];
    __int128 v208 = *(_OWORD *)&buf[32];
    __int128 v209 = *(_OWORD *)&buf[48];
    int v210 = v217;
    sub_10058C62C(a1, v110, (uint64_t)v206);
  }

  uint64_t v111 = sub_100241F94(uu);
  v112 = (void *)objc_claimAutoreleasedReturnValue(v111);
  if (v69) {
    sub_1005AA414(a1, v112, v92);
  }
  else {
    sub_1005AAC20(a1, v112);
  }

  if (qword_1008D5F30 != -1) {
    dispatch_once(&qword_1008D5F30, &stru_1008A2B30);
  }
  v113 = off_1008D5F28;
  v114 = sub_100241F94(uu);
  unsigned int v115 = (void *)objc_claimAutoreleasedReturnValue(v114);
  sub_1005D21E8((uint64_t)v113, v115, 0);

  if ((v69 & 1) != 0) {
    goto LABEL_235;
  }
  v116 = (os_log_s *)qword_1008F7620;
  BOOL v117 = os_log_type_enabled((os_log_t)qword_1008F7620, OS_LOG_TYPE_DEFAULT);
  if (!v105)
  {
    if (v117)
    {
      id v121 = sub_1005BFB9C(a2);
      id v122 = (id)objc_claimAutoreleasedReturnValue(v121);
      *(_DWORD *)int v214 = 67109890;
      *(_DWORD *)&v214[4] = v198;
      *(_WORD *)&v214[8] = 1024;
      *(_DWORD *)&v214[10] = a5;
      *(_WORD *)&v214[14] = 1024;
      *(_DWORD *)&v214[16] = a6;
      *(_WORD *)&v214[20] = 2114;
      id v215 = v122;
      _os_log_impl( (void *)&_mh_execute_header,  v116,  OS_LOG_TYPE_DEFAULT,  "Will not retry. Notify to check any pending connection. disconnectDevice:%d localRole:%d reason:%d address:%{public}@",  v214,  0x1Eu);
    }

    if (qword_1008D5F30 != -1) {
      dispatch_once(&qword_1008D5F30, &stru_1008A2B30);
    }
    v123 = off_1008D5F28;
    v124 = sub_100241F94(uu);
    v125 = (void *)objc_claimAutoreleasedReturnValue(v124);
    sub_1005D3C5C((uint64_t)v123, v125);

LABEL_235:
    sub_1005A1444(a1, uu, 0, v92, v69);
    int v126 = 0;
    int v127 = 1;
    goto LABEL_254;
  }

  if (v117)
  {
    *(_WORD *)int v214 = 0;
    _os_log_impl( (void *)&_mh_execute_header,  v116,  OS_LOG_TYPE_DEFAULT,  "Device disconnected without being ready, skipping disconnection notification.",  v214,  2u);
    v116 = (os_log_s *)qword_1008F7620;
  }

  if (os_log_type_enabled(v116, OS_LOG_TYPE_DEFAULT))
  {
    *(_WORD *)int v214 = 0;
    _os_log_impl((void *)&_mh_execute_header, v116, OS_LOG_TYPE_DEFAULT, "Retrying the connection attempt.", v214, 2u);
  }

  int v118 = *(_DWORD *)(a1 + 864);
  switch(v118)
  {
    case 0:
      v128 = (os_log_s *)qword_1008F7620;
      if (os_log_type_enabled((os_log_t)qword_1008F7620, OS_LOG_TYPE_DEFAULT))
      {
        *(_WORD *)int v214 = 0;
        _os_log_impl( (void *)&_mh_execute_header,  v128,  OS_LOG_TYPE_DEFAULT,  "LeConnectionStateIdle, lets add to filter accept list and process connecting devices.",  v214,  2u);
      }

      v129 = sub_100241F94(uu);
      v130 = (void *)objc_claimAutoreleasedReturnValue(v129);
      sub_1005963D8(a1, v130);

      int v126 = 1;
      goto LABEL_251;
    case 1:
      v131 = (os_log_s *)qword_1008F7620;
      if (os_log_type_enabled((os_log_t)qword_1008F7620, OS_LOG_TYPE_DEFAULT))
      {
        *(_WORD *)int v214 = 0;
        _os_log_impl( (void *)&_mh_execute_header,  v131,  OS_LOG_TYPE_DEFAULT,  "LeConnectionStateConnecting, lets cancel pending connection, try to add the device to the filter accept list.",  v214,  2u);
      }

      if (sub_100590B30(a1, 1))
      {
        v132 = sub_100241F94(uu);
        v133 = (void *)objc_claimAutoreleasedReturnValue(v132);
        sub_1005963D8(a1, v133);
      }

      else
      {
        int v197 = sub_100241F94(uu);
        v133 = (void *)objc_claimAutoreleasedReturnValue(v197);
        sub_100241F90(v214, v133);
        sub_100594AE4(a1, v214);
      }

      goto LABEL_250;
    case 2:
    case 4:
      v119 = (os_log_s *)qword_1008F7620;
      if (os_log_type_enabled((os_log_t)qword_1008F7620, OS_LOG_TYPE_DEFAULT))
      {
        else {
          v120 = off_1008A2D10[v118 - 2];
        }
        *(_DWORD *)int v214 = 136446210;
        *(void *)&v214[4] = v120;
        _os_log_impl( (void *)&_mh_execute_header,  v119,  OS_LOG_TYPE_DEFAULT,  "LeConnectionState%{public}s, lets add to pending, wait for cancelation to complete.",  v214,  0xCu);
      }

      v137 = sub_100241F94(uu);
      uint64_t v138 = (void *)objc_claimAutoreleasedReturnValue(v137);
      sub_100241F90(v214, v138);
      sub_100594AE4(a1, v214);

      goto LABEL_250;
    case 3:
      v134 = (os_log_s *)qword_1008F7620;
      if (os_log_type_enabled((os_log_t)qword_1008F7620, OS_LOG_TYPE_DEFAULT))
      {
        *(_WORD *)int v214 = 0;
        _os_log_impl( (void *)&_mh_execute_header,  v134,  OS_LOG_TYPE_DEFAULT,  "LeConnectionStateCancelled, lets add to filter accept list, wait for cancelation to complete.",  v214,  2u);
      }

      id v135 = sub_100241F94(uu);
      uint64_t v136 = (void *)objc_claimAutoreleasedReturnValue(v135);
      sub_1005963D8(a1, v136);

      goto LABEL_250;
    default:
LABEL_250:
      int v126 = 0;
LABEL_251:
      id v139 = sub_100241F94(uu);
      id v140 = (void *)objc_claimAutoreleasedReturnValue(v139);
      sub_1005A793C(a1, v140, 0, a6);

      if (a1 + 488 == sub_1005BCC74(a1 + 480, uu))
      {
        *(void *)int v214 = uu;
        *((_WORD *)sub_1005BDD78( (uint64_t **)(a1 + 480),  uu,  (uint64_t)&unk_1006C2518,  (const unsigned __int8 *__attribute__((__org_typedef(uuid_t))) *)v214)
        + 21) = 0;
      }

      *(void *)int v214 = uu;
      uint64_t v141 = sub_1005BDD78( (uint64_t **)(a1 + 480),  uu,  (uint64_t)&unk_1006C2518,  (const unsigned __int8 *__attribute__((__org_typedef(uuid_t))) *)v214);
      int v127 = 0;
      ++*((_WORD *)v141 + 21);
      break;
  }

LABEL_254:
  uint64_t v142 = sub_1002E6E00();
  if ((*(unsigned int (**)(uint64_t))(*(void *)v142 + 8LL))(v142))
  {
    uint64_t v143 = sub_1002E6BF0();
    int v144 = (*(uint64_t (**)(uint64_t))(*(void *)v143 + 408LL))(v143) ^ 1;
    if ((_DWORD)a6 != 708) {
      LOBYTE(v144) = 1;
    }
    if ((v144 & 1) == 0)
    {
      if (qword_1008D5F30 != -1) {
        dispatch_once(&qword_1008D5F30, &stru_1008A2B30);
      }
      id v145 = off_1008D5F28;
      id v146 = sub_100241F94(uu);
      uint64_t v147 = (void *)objc_claimAutoreleasedReturnValue(v146);
      sub_10002418C(v204, "BluetoothTVRemote");
      int v148 = sub_1005CE5A8((uint64_t)v145, v147, (uint64_t)v204);
      if (v205 < 0) {
        operator delete(v204[0]);
      }

      if (v148) {
        sub_10040CA80("AppleTVInternal", "AppleTVRemoteConnectionTimeout", 60.0);
      }
    }
  }

  if (v127)
  {
    if (qword_1008D5F20 != -1) {
      dispatch_once(&qword_1008D5F20, &stru_1008A2BF0);
    }
    uint64_t v149 = qword_1008D5F18;
    v150 = sub_100241F94(uu);
    id v151 = (void *)objc_claimAutoreleasedReturnValue(v150);
    LOBYTE(v149) = sub_10061C0F8(v149, v151);

    if ((v149 & 1) == 0)
    {
      if (qword_1008D5F30 != -1) {
        dispatch_once(&qword_1008D5F30, &stru_1008A2B30);
      }
      uint64_t v152 = off_1008D5F28;
      v153 = sub_100241F94(uu);
      uint64_t v154 = (void *)objc_claimAutoreleasedReturnValue(v153);
      sub_1005D4D10((uint64_t)v152, v154, 0);
    }
  }

  if (qword_1008D5F30 != -1) {
    dispatch_once(&qword_1008D5F30, &stru_1008A2B30);
  }
  v155 = off_1008D5F28;
  v156 = sub_100241F94(uu);
  v157 = (void *)objc_claimAutoreleasedReturnValue(v156);
  sub_10002418C(v202, "_UNPAIR_AFTER_DISCONNECTION_");
  int v158 = sub_1005CE5A8((uint64_t)v155, v157, (uint64_t)v202);
  if (v203 < 0) {
    operator delete(v202[0]);
  }

  if (v158)
  {
    id v159 = (os_log_s *)qword_1008F7620;
    if (os_log_type_enabled((os_log_t)qword_1008F7620, OS_LOG_TYPE_DEFAULT))
    {
      v160 = sub_100241F94(uu);
      id v161 = (id)objc_claimAutoreleasedReturnValue(v160);
      *(_DWORD *)int v214 = 138543362;
      *(void *)&v214[4] = v161;
      _os_log_impl( (void *)&_mh_execute_header,  v159,  OS_LOG_TYPE_DEFAULT,  "Device %{public}@ marked to be unpaired and removed after disconnection",  v214,  0xCu);
    }

    if (qword_1008D5F20 != -1) {
      dispatch_once(&qword_1008D5F20, &stru_1008A2BF0);
    }
    uint64_t v162 = qword_1008D5F18;
    id v163 = sub_100241F94(uu);
    v164 = (void *)objc_claimAutoreleasedReturnValue(v163);
    sub_100625C0C(v162, v164);

    if (qword_1008D5F30 != -1) {
      dispatch_once(&qword_1008D5F30, &stru_1008A2B30);
    }
    v165 = off_1008D5F28;
    int v166 = sub_100241F94(uu);
    v167 = (void *)objc_claimAutoreleasedReturnValue(v166);
    sub_1005C91A4((uint64_t)v165, v167);
  }

  v168 = (os_log_s *)qword_1008F7620;
  if (*(_BYTE *)(a1 + 1065))
  {
    if (os_log_type_enabled((os_log_t)qword_1008F7620, OS_LOG_TYPE_DEFAULT))
    {
      *(_WORD *)int v214 = 0;
      _os_log_impl((void *)&_mh_execute_header, v168, OS_LOG_TYPE_DEFAULT, "Controller is no longer full", v214, 2u);
      v168 = (os_log_s *)qword_1008F7620;
    }

    *(_BYTE *)(a1 + 1065) = 0;
  }

  else if (!v126)
  {
    int v169 = 0;
    goto LABEL_294;
  }

  if (!*(_DWORD *)(a1 + 928))
  {
    if (os_log_type_enabled(v168, OS_LOG_TYPE_DEFAULT))
    {
      *(_WORD *)int v214 = 0;
      _os_log_impl((void *)&_mh_execute_header, v168, OS_LOG_TYPE_DEFAULT, "Processing connecting devices", v214, 2u);
    }

    sub_10059EB5C(a1);
    goto LABEL_299;
  }

  int v169 = 1;
LABEL_294:
  if (os_log_type_enabled(v168, OS_LOG_TYPE_DEFAULT))
  {
    uint64_t v170 = *(int *)(a1 + 928);
    else {
      v171 = (&off_1008A2DA0)[v170];
    }
    *(_DWORD *)int v214 = 67109378;
    *(_DWORD *)&v214[4] = v169;
    *(_WORD *)&v214[8] = 2082;
    *(void *)&v214[10] = v171;
    _os_log_impl( (void *)&_mh_execute_header,  v168,  OS_LOG_TYPE_DEFAULT,  "handleDisconnectionCompleteCallback skipping processConnectingList, processConnectingList=%d, LE Connection Manage r State is %{public}s",  v214,  0x12u);
  }

LABEL_299:
  if (qword_1008D5F30 != -1) {
    dispatch_once(&qword_1008D5F30, &stru_1008A2B30);
  }
  v172 = off_1008D5F28;
  v173 = sub_100241F94(uu);
  v174 = (void *)objc_claimAutoreleasedReturnValue(v173);
  int v175 = sub_1005CE2FC((uint64_t)v172, v174);

  v176 = (os_log_s *)qword_1008F7620;
  if (os_log_type_enabled((os_log_t)qword_1008F7620, OS_LOG_TYPE_DEFAULT))
  {
    v177 = sub_100241F94(uu);
    int v178 = (void *)objc_claimAutoreleasedReturnValue(v177);
    v179 = sub_100595B00(v175);
    id v180 = v178;
    *(_DWORD *)int v214 = 136446722;
    *(void *)&v214[4] = v179;
    *(_WORD *)&v214[12] = 2114;
    *(void *)&v214[14] = v180;
    LOWORD(v215) = 1024;
    *(_DWORD *)((char *)&v215 + 2) = a6;
    _os_log_impl( (void *)&_mh_execute_header,  v176,  OS_LOG_TYPE_DEFAULT,  "BLE Disconnected %{public}s %{public}@ reason %d",  v214,  0x1Cu);

    v176 = (os_log_s *)qword_1008F7620;
  }

  if (os_signpost_enabled(v176))
  {
    v181 = sub_100241F94(uu);
    v182 = (void *)objc_claimAutoreleasedReturnValue(v181);
    id v183 = sub_100595B00(v175);
    id v184 = v182;
    *(_DWORD *)int v214 = 136446722;
    *(void *)&v214[4] = v183;
    *(_WORD *)&v214[12] = 2114;
    *(void *)&v214[14] = v184;
    LOWORD(v215) = 1024;
    *(_DWORD *)((char *)&v215 + 2) = a6;
    _os_signpost_emit_with_name_impl( (void *)&_mh_execute_header,  v176,  OS_SIGNPOST_EVENT,  0xEEEEB0B5B2B2EEEELL,  "BTSignPost",  "BLE Disconnected %{public}s %{public}@ reason %d",  v214,  0x1Cu);
  }

  if (v175 == 196608 || v175 == 19)
  {
    if (v127)
    {
      unsigned int v185 = sub_100241F94(uu);
      v186 = (void *)objc_claimAutoreleasedReturnValue(v185);
      double v187 = CFAbsoluteTimeGetCurrent();
      sub_1005A6774(a1, v186, a6, v175, v187);
    }

    uint64_t v188 = sub_100241F94(uu);
    uint64_t v189 = (void *)objc_claimAutoreleasedReturnValue(v188);
    sub_1005A7858((uint64_t)v189, v189);
  }

  if (v127)
  {
    if (qword_1008D5F30 != -1) {
      dispatch_once(&qword_1008D5F30, &stru_1008A2B30);
    }
    v190 = off_1008D5F28;
    v191 = sub_100241F94(uu);
    uint64_t v192 = (void *)objc_claimAutoreleasedReturnValue(v191);
    sub_1005CC6A0((uint64_t)v190, v192, 0.0);

    if (a1 + 488 != sub_1005BCC74(a1 + 480, uu)) {
      sub_1005BE110((uint64_t **)(a1 + 480), uu);
    }
  }

  if (qword_1008D5F30 != -1) {
    dispatch_once(&qword_1008D5F30, &stru_1008A2B30);
  }
  uint64_t v193 = off_1008D5F28;
  v194 = sub_100241F94(uu);
  v195 = (void *)objc_claimAutoreleasedReturnValue(v194);
  sub_1005CC848((uint64_t)v193, v195, 0.0);

LABEL_318:
  return sub_100242FAC((uint64_t)v213);
}

void sub_1005A9BB0( _Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, void *a12, uint64_t a13, void *a14, uint64_t a15, int a16, __int16 a17, char a18, char a19, void *__p, uint64_t a21, int a22, __int16 a23, char a24, char a25, uint64_t a26, uint64_t a27, uint64_t a28, uint64_t a29, uint64_t a30, uint64_t a31, uint64_t a32, uint64_t a33, uint64_t a34, void *a35, uint64_t a36, int a37, __int16 a38, char a39, char a40, char a41, uint64_t a42, uint64_t a43, uint64_t a44, uint64_t a45, uint64_t a46, uint64_t a47, uint64_t a48, uint64_t a49)
{
}

void sub_1005A9E84(uint64_t a1, void *a2, int a3, char a4)
{
  id v7 = a2;
  uint64_t v8 = sub_1002E6E9C();
  if ((*(unsigned int (**)(uint64_t))(*(void *)v8 + 2752LL))(v8))
  {
    uint64_t v9 = sub_100404FE8();
    v10[0] = _NSConcreteStackBlock;
    v10[1] = 3221225472LL;
    v10[2] = sub_1005B8070;
    v10[3] = &unk_100881010;
    uint64_t v12 = a1;
    id v11 = v7;
    char v14 = a4;
    int v13 = a3;
    sub_100405384(v9, v10);
  }
}

void sub_1005A9F3C( _Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, void *a14)
{
  _Unwind_Resume(a1);
}

void sub_1005A9F5C(uint64_t a1, void *a2, int a3, char a4)
{
  id v7 = a2;
  if (a3 == 4833 && _os_feature_enabled_impl("BluetoothFeatures", "OutgoingLeConnectionDenyList"))
  {
    uint64_t v8 = sub_100404FE8();
    v9[0] = _NSConcreteStackBlock;
    v9[1] = 3221225472LL;
    void v9[2] = sub_1005B8FE8;
    v9[3] = &unk_100881010;
    uint64_t v11 = a1;
    id v10 = v7;
    char v13 = a4;
    int v12 = 4833;
    sub_100405384(v8, v9);
  }
}

void sub_1005AA020( _Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, void *a14)
{
  _Unwind_Resume(a1);
}

void sub_1005AA040(uint64_t a1)
{
  double Current = CFAbsoluteTimeGetCurrent();
  *(double *)(a1 + 1176) = Current;
  if (Current + -172800.0 <= 0.0)
  {
    int v4 = (os_log_s *)qword_1008F7620;
    if (os_log_type_enabled((os_log_t)qword_1008F7620, OS_LOG_TYPE_ERROR)) {
      sub_1006998E0(v4, Current, Current + -172800.0, v5, v6);
    }
  }

  else
  {
    unsigned int v3 = *(unsigned __int16 *)(a1 + 1168);
    sub_1005B4110(a1, Current + -172800.0);
    if (v3 > 0x20)
    {
      sub_1005B4528(a1);
      if (os_log_type_enabled((os_log_t)qword_1008F7620, OS_LOG_TYPE_DEBUG)) {
        sub_100699874();
      }
    }

    else if (os_log_type_enabled((os_log_t)qword_1008F7620, OS_LOG_TYPE_DEBUG))
    {
      sub_100699810();
    }
  }

void sub_1005AA138(uint64_t a1, char *a2, int a3, double a4)
{
  uint64_t v8 = (os_log_s *)qword_1008F7620;
  if (os_log_type_enabled((os_log_t)qword_1008F7620, OS_LOG_TYPE_DEFAULT))
  {
    uint64_t v9 = a2;
    if (a2[23] < 0) {
      uint64_t v9 = *(char **)a2;
    }
    *(_DWORD *)__int128 buf = 136446722;
    *(void *)&uint8_t buf[4] = v9;
    *(_WORD *)&_BYTE buf[12] = 1024;
    *(_DWORD *)&buf[14] = (int)a4;
    *(_WORD *)&buf[18] = 1024;
    *(_DWORD *)&buf[20] = a3;
    _os_log_impl( (void *)&_mh_execute_header,  v8,  OS_LOG_TYPE_DEFAULT,  "upsertDisconnectionHistoryElement %{public}s time %d reason %d",  buf,  0x18u);
  }

  uint64_t v10 = sub_100024098(a1 + 1152, (const void **)a2);
  if (a1 + 1160 == v10)
  {
    if (os_log_type_enabled((os_log_t)qword_1008F7620, OS_LOG_TYPE_DEBUG)) {
      sub_100699958();
    }
    if (*(void *)(a1 + 1168) >= 0x21uLL) {
      sub_1005AA040(a1);
    }
    *(void *)__int128 buf = buf;
    *(_OWORD *)&uint8_t buf[8] = (unint64_t)buf;
    char v13 = (double *)operator new(0x20uLL);
    v13[2] = a4;
    *((_DWORD *)v13 + 6) = a3;
    *((_DWORD *)v13 + 7) = 0;
    *(void *)char v13 = buf;
    *((void *)v13 + 1) = buf;
    *(void *)__int128 buf = v13;
    *(void *)&uint8_t buf[8] = v13;
    *(void *)&buf[16] = 1LL;
    BOOL v17 = a2;
    char v14 = (uint8_t *)(sub_1005BE3C4( (uint64_t **)(a1 + 1152),  (const void **)a2,  (uint64_t)&unk_1006C2518,  (__int128 **)&v17)
                    + 56);
    if (v14 != buf) {
      goto LABEL_23;
    }
  }

  else
  {
    memset(buf, 0, sizeof(buf));
    sub_1005BE32C(buf, v10 + 56);
    if (os_log_type_enabled((os_log_t)qword_1008F7620, OS_LOG_TYPE_DEBUG)) {
      sub_100699A20();
    }
    if (*(void *)&buf[16] >= 0x60uLL)
    {
      if (*(_WORD *)&buf[16] == 95)
      {
        int v12 = *(uint64_t **)&buf[8];
      }

      else
      {
        unint64_t v11 = (unsigned __int16)(*(_WORD *)&buf[16] - 95) + 1LL;
        int v12 = *(uint64_t **)&buf[8];
        do
        {
          int v12 = (uint64_t *)v12[1];
          --v11;
        }

        while (v11 > 1);
      }

      sub_10040F0C4((uint64_t)buf, *(uint64_t **)&buf[8], v12);
      if (os_log_type_enabled((os_log_t)qword_1008F7620, OS_LOG_TYPE_DEBUG)) {
        sub_1006999C0();
      }
    }

    uint64_t v15 = (double *)operator new(0x20uLL);
    v15[2] = a4;
    *((_DWORD *)v15 + 6) = a3;
    *((_DWORD *)v15 + 7) = 0;
    uint64_t v16 = *(void *)buf;
    double *v15 = *(double *)buf;
    *((void *)v15 + 1) = buf;
    *(void *)(v16 + 8) = v15;
    BOOL v17 = a2;
    *(void *)__int128 buf = v15;
    ++*(void *)&buf[16];
    char v14 = (uint8_t *)(sub_1005BE3C4( (uint64_t **)(a1 + 1152),  (const void **)a2,  (uint64_t)&unk_1006C2518,  (__int128 **)&v17)
                    + 56);
    if (v14 != buf) {
LABEL_23:
    }
      sub_1005BE584((uint64_t *)v14, *(uint64_t *)&buf[8], (uint64_t)buf);
  }

  sub_10023DF50(buf);
  sub_1005B31CC((void *)a1);
}

void sub_1005AA3F0(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, ...)
{
}

void sub_1005AA414(uint64_t a1, void *a2, int a3)
{
  id v47 = a2;
  sub_100241F90(buf, v47);
  if (a1 + 1520 != sub_1001FDB10(a1 + 1512, buf))
  {
    sub_100241F90(buf, v47);
    int v55 = buf;
    uint64_t v5 = sub_1005BEE54( (uint64_t **)(a1 + 1512),  buf,  (uint64_t)&unk_1006C2518,  (const unsigned __int8 *__attribute__((__org_typedef(uuid_t))) *)&v55);
    id v48 = (id)v5[6];
    uint64_t v6 = (_UNKNOWN **)(id)v5[7];
    double v7 = *((double *)v5 + 9);
    int v8 = *((unsigned __int8 *)v5 + 80);
    unint64_t v9 = v5[11];
    int v10 = *((unsigned __int8 *)v5 + 97);
    int v11 = *((unsigned __int8 *)v5 + 98);
    int v49 = *((unsigned __int8 *)v5 + 99);
    int v12 = *((unsigned __int8 *)v5 + 100);
    unsigned int v43 = *((_DWORD *)v5 + 26);
    unsigned int v13 = *((_DWORD *)v5 + 27);
    unsigned int v14 = *((_DWORD *)v5 + 28);
    unsigned int v44 = v13;
    int v45 = v12;
    if (qword_1008D5F30 != -1) {
      dispatch_once(&qword_1008D5F30, &stru_1008A2B30);
    }
    int v15 = sub_1005CE2FC((uint64_t)off_1008D5F28, v47);
    if (qword_1008D5F20 != -1) {
      dispatch_once(&qword_1008D5F20, &stru_1008A2BF0);
    }
    BOOL v16 = sub_10061C0F8(qword_1008D5F18, v48);
    if (v10)
    {
      BOOL v17 = v16;
      unsigned int v42 = v14;
      double Current = CFAbsoluteTimeGetCurrent();
      id v19 = (void *)objc_claimAutoreleasedReturnValue(+[NSMutableDictionary dictionary](&OBJC_CLASS___NSMutableDictionary, "dictionary"));
      id v20 = (void *)objc_claimAutoreleasedReturnValue(+[NSNumber numberWithBool:](&OBJC_CLASS___NSNumber, "numberWithBool:", v17));
      [v19 setObject:v20 forKeyedSubscript:@"Paired"];

      unsigned int v21 = (void *)objc_claimAutoreleasedReturnValue(+[NSNumber numberWithDouble:](&OBJC_CLASS___NSNumber, "numberWithDouble:", Current - v7));
      [v19 setObject:v21 forKeyedSubscript:@"Duration"];

      uint64_t v22 = (void *)objc_claimAutoreleasedReturnValue(+[NSNumber numberWithInteger:](&OBJC_CLASS___NSNumber, "numberWithInteger:", a3));
      [v19 setObject:v22 forKeyedSubscript:@"DisconnectReason"];

      uint64_t v23 = (void *)objc_claimAutoreleasedReturnValue(+[NSNumber numberWithBool:](&OBJC_CLASS___NSNumber, "numberWithBool:", v11 != 0));
      [v19 setObject:v23 forKeyedSubscript:@"Initiator"];

      __int16 v24 = (void *)objc_claimAutoreleasedReturnValue(+[NSNumber numberWithBool:](&OBJC_CLASS___NSNumber, "numberWithBool:", v8 != 0));
      [v19 setObject:v24 forKeyedSubscript:@"RemoteDisconnected"];

      if (v11)
      {
        if (qword_1008D5F30 != -1) {
          dispatch_once(&qword_1008D5F30, &stru_1008A2B30);
        }
        id v25 = +[NSNumber numberWithChar:]( &OBJC_CLASS___NSNumber,  "numberWithChar:",  sub_1005D1E08((uint64_t)off_1008D5F28, v48));
        double v26 = (void *)objc_claimAutoreleasedReturnValue(v25);
        [v19 setObject:v26 forKeyedSubscript:@"ConnectionEstablishedRSSI"];
      }

      if (v15 == 655360)
      {
        [v19 setObject:&__kCFBooleanTrue forKeyedSubscript:@"DigitalKey"];
        double v27 = (void *)objc_claimAutoreleasedReturnValue(+[NSNumber numberWithUnsignedInt:](&OBJC_CLASS___NSNumber, "numberWithUnsignedInt:", v44));
        [v19 setObject:v27 forKeyedSubscript:@"KeyRSSIEventCount"];

        int v28 = (void *)objc_claimAutoreleasedReturnValue(+[NSNumber numberWithUnsignedInt:](&OBJC_CLASS___NSNumber, "numberWithUnsignedInt:", v43));
        [v19 setObject:v28 forKeyedSubscript:@"KeyRSSIEventWakeCount"];
      }

      if (v49) {
        [v19 setObject:&__kCFBooleanTrue forKeyedSubscript:@"KeyWakeOnConnect"];
      }
      if (v45) {
        [v19 setObject:&__kCFBooleanTrue forKeyedSubscript:@"KeyWakeOnDisconnect"];
      }
      if (v9 > 5) {
        BOOL v29 = @"PeerTypeOther";
      }
      else {
        BOOL v29 = (const __CFString *)*((void *)&off_1008A2D28 + v9);
      }
      [v19 setObject:v29 forKeyedSubscript:@"PeerType"];
      __int16 v30 = (void *)objc_claimAutoreleasedReturnValue(+[NSNumber numberWithUnsignedInt:](&OBJC_CLASS___NSNumber, "numberWithUnsignedInt:", v42));
      [v19 setObject:v30 forKeyedSubscript:@"DASessionType"];

      if (qword_1008D5F30 != -1) {
        dispatch_once(&qword_1008D5F30, &stru_1008A2B30);
      }
      int v31 = +[NSNumber numberWithUnsignedInt:]( &OBJC_CLASS___NSNumber,  "numberWithUnsignedInt:",  sub_1005D2540((uint64_t)off_1008D5F28, v48));
      uint64_t v32 = (void *)objc_claimAutoreleasedReturnValue(v31);
      [v19 setObject:v32 forKeyedSubscript:@"LinkReadyDuration"];

      LOBYTE(v55) = 0;
      __int16 v54 = 0;
      if (qword_1008D5F30 != -1) {
        dispatch_once(&qword_1008D5F30, &stru_1008A2B30);
      }
      sub_1005D2278((uint64_t)off_1008D5F28, v48, &v54, &v55, (char *)&v54 + 1);
      id v33 = (void *)objc_claimAutoreleasedReturnValue(+[NSNumber numberWithBool:](&OBJC_CLASS___NSNumber, "numberWithBool:", v55));
      [v19 setObject:v33 forKeyedSubscript:@"FastLeConnectionConfigured"];

      uint64_t v34 = (void *)objc_claimAutoreleasedReturnValue(+[NSNumber numberWithBool:](&OBJC_CLASS___NSNumber, "numberWithBool:", v54));
      [v19 setObject:v34 forKeyedSubscript:@"FastLeConnectionUsed"];

      if (qword_1008D5F30 != -1) {
        dispatch_once(&qword_1008D5F30, &stru_1008A2B30);
      }
      int v35 = +[NSNumber numberWithUnsignedShort:]( &OBJC_CLASS___NSNumber,  "numberWithUnsignedShort:",  sub_1005D2650((uint64_t)off_1008D5F28, v48));
      unint64_t v36 = (void *)objc_claimAutoreleasedReturnValue(v35);
      [v19 setObject:v36 forKeyedSubscript:@"LinkReadyConnectionInterval"];

      if (HIBYTE(v54)) {
        [v19 setObject:0 forKeyedSubscript:@"DASessionType"];
      }
      if (![v6 count])
      {

        uint64_t v6 = &off_1008C3228;
      }

      uint64_t v46 = a1;
      __int128 v52 = 0u;
      __int128 v53 = 0u;
      __int128 v50 = 0u;
      __int128 v51 = 0u;
      uint64_t v6 = v6;
      id v37 = [v6 countByEnumeratingWithState:&v50 objects:v56 count:16];
      if (v37)
      {
        uint64_t v38 = *(void *)v51;
        do
        {
          for (i = 0LL; i != v37; i = (char *)i + 1)
          {
            if (*(void *)v51 != v38) {
              objc_enumerationMutation(v6);
            }
            [v19 setObject:*(void *)(*((void *)&v50 + 1) + 8 * (void)i) forKeyedSubscript:@"BundleIdentifier"];
            uint64_t v40 = (os_log_s *)qword_1008F7620;
            if (os_log_type_enabled((os_log_t)qword_1008F7620, OS_LOG_TYPE_DEFAULT))
            {
              *(_DWORD *)__int128 buf = 138412290;
              uint64_t v58 = v19;
              _os_log_impl( (void *)&_mh_execute_header,  v40,  OS_LOG_TYPE_DEFAULT,  "Sending LESessionEndedMetric %@",  buf,  0xCu);
            }

            uint64_t v41 = sub_1002E8D94();
            (*(void (**)(uint64_t, void *))(*(void *)v41 + 272LL))(v41, v19);
          }

          id v37 = [v6 countByEnumeratingWithState:&v50 objects:v56 count:16];
        }

        while (v37);
      }

      sub_1005AAC20(v46, v48);
    }
  }
}

void sub_1005AAB20( _Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, void *a13, void *a14)
{
  _Unwind_Resume(a1);
}

void sub_1005AAC20(uint64_t a1, void *a2)
{
  id v3 = a2;
  sub_100241F90(v4, v3);
  sub_1005BEFDC((uint64_t **)(a1 + 1512), v4);
}

void sub_1005AAC94(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_1005AACAC(uint64_t a1)
{
  if (qword_1008D6198 != -1) {
    dispatch_once(&qword_1008D6198, &stru_1008A2B70);
  }
  sub_10044814C((os_unfair_lock_s *)off_1008D6190, *(_DWORD *)(a1 + 40));
  if (qword_1008D5F30 != -1) {
    dispatch_once(&qword_1008D5F30, &stru_1008A2B30);
  }
  id v2 = sub_1005D373C((uint64_t)off_1008D5F28, *(void **)(a1 + 32));
  id v3 = (void *)objc_claimAutoreleasedReturnValue(v2);
  int v4 = (void *)objc_claimAutoreleasedReturnValue([v3 cuFilteredArrayUsingBlock:&stru_1008A25B0]);

  __int128 v12 = 0u;
  __int128 v13 = 0u;
  __int128 v10 = 0u;
  __int128 v11 = 0u;
  id v5 = v4;
  id v6 = [v5 countByEnumeratingWithState:&v10 objects:v14 count:16];
  if (v6)
  {
    uint64_t v7 = *(void *)v11;
    do
    {
      int v8 = 0LL;
      do
      {
        if (*(void *)v11 != v7) {
          objc_enumerationMutation(v5);
        }
        unint64_t v9 = *(void **)(*((void *)&v10 + 1) + 8LL * (void)v8);
        if (qword_1008D6198 != -1) {
          dispatch_once(&qword_1008D6198, &stru_1008A2B70);
        }
        sub_10044D87C( (uint64_t)off_1008D6190,  *(void **)(a1 + 32),  objc_msgSend(v9, "integerValue", (void)v10),  *(unsigned __int8 *)(a1 + 44));
        int v8 = (char *)v8 + 1;
      }

      while (v6 != v8);
      id v6 = [v5 countByEnumeratingWithState:&v10 objects:v14 count:16];
    }

    while (v6);
  }
}

void sub_1005AAE80(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

id sub_1005AAEB0(id a1, NSNumber *a2)
{
  id v2 = a2;
  else {
    id v3 = v2;
  }
  int v4 = v3;

  return v4;
}

void sub_1005AAEEC(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

uint64_t sub_1005AAEFC(uint64_t a1, void *a2)
{
  uint64_t v2 = 16LL;
  if (!*(_BYTE *)(a1 + 44)) {
    uint64_t v2 = 128LL;
  }
  return (*(uint64_t (**)(void *, void, void))(*a2 + v2))( a2,  *(void *)(a1 + 32),  *(unsigned int *)(a1 + 40));
}

void sub_1005AAF2C(uint64_t a1)
{
  if (!*(void *)(a1 + 896))
  {
    uint64_t v2 = sub_1002E91F8(1LL, 3LL, 0LL);
    *(void *)(a1 + 896) = v2;
    if (v2)
    {
      id v3 = v2;
      int v4 = (os_log_s *)qword_1008F7668;
      if (os_log_type_enabled((os_log_t)qword_1008F7668, OS_LOG_TYPE_DEFAULT))
      {
        uint64_t v5 = (*(uint64_t (**)(void *))(*(void *)v3 + 16LL))(v3);
        int v6 = 136446210;
        uint64_t v7 = v5;
        _os_log_impl((void *)&_mh_execute_header, v4, OS_LOG_TYPE_DEFAULT, "Creating %{public}s", (uint8_t *)&v6, 0xCu);
      }
    }
  }

void sub_1005AB004(uint64_t a1, double a2)
{
  if (*(void *)(a1 + 552))
  {
    uint64_t v4 = qword_1008F7620;
    if (!os_log_type_enabled((os_log_t)qword_1008F7620, OS_LOG_TYPE_FAULT) || !sub_100699A88(v4, (void *)(a1 + 552))) {
      sub_100591808(a1);
    }
  }

  uint64_t v5 = (os_log_s *)qword_1008F7620;
  if (os_log_type_enabled((os_log_t)qword_1008F7620, OS_LOG_TYPE_DEFAULT))
  {
    *(_DWORD *)__int128 buf = 134217984;
    double v11 = a2;
    _os_log_impl( (void *)&_mh_execute_header,  v5,  OS_LOG_TYPE_DEFAULT,  "Arming Fast connection scan Timer with interval %f seconds",  buf,  0xCu);
  }

  *(double *)(a1 + 560) = a2;
  v9[0] = _NSConcreteStackBlock;
  v9[1] = 3221225472LL;
  void v9[2] = sub_1005AB190;
  v9[3] = &unk_100888180;
  void v9[4] = a1;
  uint64_t v6 = objc_claimAutoreleasedReturnValue( +[NSTimer timerWithTimeInterval:repeats:block:]( &OBJC_CLASS___NSTimer,  "timerWithTimeInterval:repeats:block:",  0LL,  v9,  a2));
  uint64_t v7 = *(void **)(a1 + 552);
  *(void *)(a1 + 552) = v6;

  int v8 = (void *)objc_claimAutoreleasedReturnValue(+[NSRunLoop mainRunLoop](&OBJC_CLASS___NSRunLoop, "mainRunLoop"));
  [v8 addTimer:*(void *)(a1 + 552) forMode:NSDefaultRunLoopMode];
}

void sub_1005AB178(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_1005AB190(uint64_t a1, void *a2)
{
  id v3 = a2;
  uint64_t v4 = *(void *)(a1 + 32);
  uint64_t v5 = (os_log_s *)qword_1008F7620;
  if (os_log_type_enabled((os_log_t)qword_1008F7620, OS_LOG_TYPE_DEFAULT))
  {
    *(_WORD *)__int128 buf = 0;
    _os_log_impl((void *)&_mh_execute_header, v5, OS_LOG_TYPE_DEFAULT, "Fast connection scan Timer expired !", buf, 2u);
  }

  uint64_t v6 = sub_100404FE8();
  v7[0] = _NSConcreteStackBlock;
  v7[1] = 3221225472LL;
  _OWORD v7[2] = sub_1005AB25C;
  v7[3] = &unk_10087EB20;
  v7[4] = v4;
  sub_100405384(v6, v7);
}

void sub_1005AB24C(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

uint64_t sub_1005AB25C(uint64_t a1)
{
  return sub_1005AB264(*(void *)(a1 + 32));
}

uint64_t sub_1005AB264(uint64_t a1)
{
  *(void *)&__int128 v74 = 0LL;
  sub_1000B0400((uint64_t)&v74);
  uint64_t v66 = SWORD2(v74);
  uint64_t v67 = (int)v74;
  v81[0] = 0LL;
  v81[1] = 0LL;
  sub_100242F28((uint64_t)v81, a1 + 120);
  uint64_t v80 = 0LL;
  __int128 v78 = 0u;
  memset(v79, 0, sizeof(v79));
  *(_OWORD *)uint64_t v76 = 0u;
  __int128 v77 = 0u;
  memset(v75, 0, sizeof(v75));
  __int128 v74 = 0u;
  sub_1001FCFC8((uint64_t)&v74);
  sub_100591808(a1);
  __int16 v73 = 0;
  uint64_t v2 = sub_1002E8EE8();
  (*(void (**)(uint64_t, char *, __int16 *))(*(void *)v2 + 48LL))(v2, (char *)&v73 + 1, &v73);
  if (qword_1008D6198 != -1) {
    dispatch_once(&qword_1008D6198, &stru_1008A2B70);
  }
  int v3 = *((unsigned __int8 *)off_1008D6190 + 197);
  int v4 = *((unsigned __int8 *)off_1008D6190 + 198);
  uint64_t v5 = (os_log_s *)qword_1008F7620;
  if (os_log_type_enabled((os_log_t)qword_1008F7620, OS_LOG_TYPE_DEFAULT))
  {
    *(_DWORD *)__int128 buf = 67109888;
    *(_DWORD *)&uint8_t buf[4] = HIBYTE(v73);
    *(_WORD *)&uint8_t buf[8] = 1024;
    *(_DWORD *)&buf[10] = v73;
    *(_WORD *)&buf[14] = 1024;
    LODWORD(v83[0]) = v3;
    WORD2(v83[0]) = 1024;
    *(_DWORD *)((char *)v83 + 6) = v4;
    _os_log_impl( (void *)&_mh_execute_header,  v5,  OS_LOG_TYPE_DEFAULT,  "checkIfFastConnectionScanIsRequired reason:%d state%d isA2DPStreaming:%d isHFPStreaming:%d",  buf,  0x1Au);
  }

  uint64_t v88 = 0LL;
  __int128 v86 = 0u;
  memset(v87, 0, sizeof(v87));
  *(_OWORD *)uint64_t v84 = 0u;
  __int128 v85 = 0u;
  memset(v83, 0, sizeof(v83));
  *(_OWORD *)__int128 buf = 0u;
  sub_1001FCFC8((uint64_t)buf);
  uint64_t v6 = *(const unsigned __int8 **)(a1 + 336);
  if (v6 != (const unsigned __int8 *)(a1 + 344))
  {
    if (v4 | v3) {
      __int16 v7 = 8;
    }
    else {
      __int16 v7 = 7;
    }
    __int16 v64 = v7;
    char v65 = 0;
    double v8 = 0.0;
    while (1)
    {
      __int128 v72 = 0uLL;
      if (qword_1008D5F30 != -1) {
        dispatch_once(&qword_1008D5F30, &stru_1008A2B30);
      }
      unint64_t v9 = off_1008D5F28;
      __int128 v10 = sub_100241F94(v6 + 25);
      double v11 = (void *)objc_claimAutoreleasedReturnValue(v10);
      sub_1005D3DE4((uint64_t)v9, v11, (uint64_t)&v72);

      if (qword_1008D5F30 != -1) {
        dispatch_once(&qword_1008D5F30, &stru_1008A2B30);
      }
      __int128 v12 = off_1008D5F28;
      __int128 v13 = sub_100241F94(v6 + 25);
      unsigned int v14 = (void *)objc_claimAutoreleasedReturnValue(v13);
      int v15 = sub_1005D6BDC((uint64_t)v12, v14);

      if (v72 == 0 || v15 == 6) {
        goto LABEL_48;
      }
      __int16 v71 = 0;
      if (qword_1008D5F30 != -1) {
        dispatch_once(&qword_1008D5F30, &stru_1008A2B30);
      }
      BOOL v16 = off_1008D5F28;
      BOOL v17 = sub_100241F94(v6 + 25);
      id v18 = (void *)objc_claimAutoreleasedReturnValue(v17);
      LOWORD(v16) = sub_1005D6BDC((uint64_t)v16, v18);

      __int16 v71 = (__int16)v16;
      if (HIBYTE(v73) == 1)
      {
        if ((_BYTE)v73) {
          break;
        }
      }

      if (HIBYTE(v73) == 2 && (_BYTE)v73)
      {
        id v20 = (os_log_s *)qword_1008F7620;
        if (os_log_type_enabled((os_log_t)qword_1008F7620, OS_LOG_TYPE_DEFAULT))
        {
          *(_WORD *)double v89 = 0;
          _os_log_impl( (void *)&_mh_execute_header,  v20,  OS_LOG_TYPE_DEFAULT,  "Extending host scan request to DefaultExtended while in AirPlay critical buffering state",  v89,  2u);
        }

        __int16 v19 = 1;
        goto LABEL_26;
      }

void sub_1005ABCF4( _Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, void *a15, uint64_t a16, uint64_t a17, void *__p, uint64_t a19, uint64_t a20, uint64_t a21, uint64_t a22, uint64_t a23, uint64_t a24, char a25, uint64_t a26, uint64_t a27, uint64_t a28, uint64_t a29, uint64_t a30, uint64_t a31, uint64_t a32, uint64_t a33, uint64_t a34, uint64_t a35, uint64_t a36, uint64_t a37, uint64_t a38, uint64_t a39, uint64_t a40, uint64_t a41, uint64_t a42, uint64_t a43, uint64_t a44, uint64_t a45, uint64_t a46, uint64_t a47, uint64_t a48, uint64_t a49, uint64_t a50,uint64_t a51,uint64_t a52,uint64_t a53,uint64_t a54,uint64_t a55,uint64_t a56,uint64_t a57,uint64_t a58,uint64_t a59,uint64_t a60,char a61,uint64_t a62,char a63)
{
}

void sub_1005ABDE4(uint64_t a1, void *a2, _WORD *a3, unsigned __int8 *a4, void *a5)
{
  id v8 = a2;
  uint64_t v9 = sub_1002E8EE8();
  unsigned __int16 v10 = (*(uint64_t (**)(uint64_t))(*(void *)v9 + 56LL))(v9);
  uint64_t v67 = 0LL;
  __int128 v65 = 0u;
  memset(v66, 0, sizeof(v66));
  *(_OWORD *)std::stringbuf::string_type __p = 0u;
  __int128 v64 = 0u;
  memset(v62, 0, sizeof(v62));
  __int128 v61 = 0u;
  sub_1001FCFC8((uint64_t)&v61);
  double v11 = sub_1001FD17C(v62, (uint64_t)"connectionScanParametersForDevice device:", 41LL);
  sub_100241F90(v68, v8);
  memset(out, 0, 37);
  uuid_unparse_upper(v12, (char *)out);
  sub_10002418C(&buf, (char *)out);
  if ((v70 & 0x80u) == 0) {
    p___int128 buf = &buf;
  }
  else {
    p___int128 buf = (__int128 *)buf;
  }
  if ((v70 & 0x80u) == 0) {
    uint64_t v14 = v70;
  }
  else {
    uint64_t v14 = *((void *)&buf + 1);
  }
  int v15 = sub_1001FD17C(v11, (uint64_t)p_buf, v14);
  BOOL v16 = sub_1001FD17C(v15, (uint64_t)" coexRecommendedConnectionScanDutycycle:", 40LL);
  std::ostream::operator<<(v16, v10);
  uint64_t v17 = (unsigned __int16)*a3;
  if (!v10 || v17 > 2)
  {
    uint64_t v27 = *(unsigned int *)(a1 + 4 * v17 + 568);
    sub_1001FD17C(v62, (uint64_t)" No CoexRequested", 17LL);
    goto LABEL_41;
  }

  sub_1001FD17C(v62, (uint64_t)" CoexRequested", 14LL);
  uint64_t v18 = a1;
  if (qword_1008D5F30 != -1) {
    dispatch_once(&qword_1008D5F30, &stru_1008A2B30);
  }
  int v19 = sub_1005D6DFC((uint64_t)off_1008D5F28, v8);
  id v20 = sub_1001FD17C(v62, (uint64_t)" devicePriority:", 16LL);
  unsigned int v21 = "Low";
  if (v19 == 1) {
    unsigned int v21 = "Medium";
  }
  if (v19 == 2) {
    uint64_t v22 = "High";
  }
  else {
    uint64_t v22 = v21;
  }
  size_t v23 = strlen(v22);
  sub_1001FD17C(v20, (uint64_t)v22, v23);
  if (v19)
  {
    a1 = v18;
    if (v19 == 2)
    {
      uint64_t v27 = *(unsigned int *)(v18 + 4LL * (unsigned __int16)*a3 + 568);
      goto LABEL_41;
    }

    if (v19 != 1 || !*(_WORD *)(v18 + 112))
    {
      uint64_t v27 = 0LL;
      goto LABEL_41;
    }

    int v59 = a4;
    uint64_t v24 = v18;
    uint64_t v25 = 0LL;
    unint64_t v26 = 0LL;
    LODWORD(v27) = 0;
    while (1)
    {
      uint64_t v28 = v24;
      uint64_t v27 = (*(_DWORD *)(*(void *)(v24 + 104) + v25) + v27);
      unint64_t v29 = a5[1] + v27;
      unint64_t v30 = *a5 + v29 / 0x3E8;
      unint64_t v31 = v29 % 0x3E8;
      LODWORD(out[0].__r_.__value_.__l.__data_) = *(_DWORD *)a5 + v29 / 0x3E8;
      HIDWORD(out[0].__r_.__value_.__r.__words[0]) = v29 % 0x3E8;
      *a3 = 8;
      ++v26;
      uint64_t v24 = v28;
      v25 += 8LL;
      if (v26 >= *(unsigned __int16 *)(v28 + 112))
      {
        uint64_t v27 = *(unsigned int *)(v28 + 600);
        a4 = v59;
        a1 = v28;
        goto LABEL_41;
      }
    }

    unint64_t v33 = sub_1001FD17C(v62, (uint64_t)" within segment:", 16LL);
    unint64_t v34 = (void *)std::ostream::operator<<(v33, v26);
    double v35 = sub_1001FD17C(v34, (uint64_t)" segmentTime:", 13LL);
    __int128 v72 = 0u;
    memset(out, 0, sizeof(out));
    snprintf((char *)out, 0x3FuLL, "%0llu.%0llu", v30, v31);
    sub_10002418C(&buf, (char *)out);
    a4 = v59;
    if ((v70 & 0x80u) == 0) {
      double v36 = &buf;
    }
    else {
      double v36 = (__int128 *)buf;
    }
    if ((v70 & 0x80u) == 0) {
      uint64_t v37 = v70;
    }
    else {
      uint64_t v37 = *((void *)&buf + 1);
    }
    uint64_t v38 = sub_1001FD17C(v35, (uint64_t)v36, v37);
    id v39 = sub_1001FD17C(v38, (uint64_t)" totalElapsedTime:", 18LL);
    uint64_t v40 = (void *)std::ostream::operator<<(v39, v27);
    uint64_t v41 = sub_1001FD17C(v40, (uint64_t)" fConnectionScanScheduleSegments.durationMS:", 44LL);
    std::ostream::operator<<(v41, *(unsigned int *)(*(void *)(v28 + 104) + v25));
    uint64_t v42 = *(void *)(v28 + 104) + v25;
    a1 = v28;
    int v32 = *(_DWORD *)(v42 + 4);
    if (v32 == 9) {
      LOWORD(v32) = 8;
    }
  }

  else
  {
    a1 = v18;
    uint64_t v27 = *(unsigned int *)(v18 + 600);
    LOWORD(v32) = 8;
  }

  *a3 = v32;
LABEL_41:
  unint64_t v43 = a5[1] + v27;
  *a5 += v43 / 0x3E8;
  a5[1] = v43 % 0x3E8;
  unsigned int v44 = sub_1001FD17C(v62, (uint64_t)" expirationTime:", 16LL);
  sub_10038FCC8(a5, out);
  if ((out[0].__r_.__value_.__s.__size_ & 0x80u) == 0) {
    int v45 = out;
  }
  else {
    int v45 = (std::stringbuf::string_type *)out[0].__r_.__value_.__r.__words[0];
  }
  if ((out[0].__r_.__value_.__s.__size_ & 0x80u) == 0) {
    uint64_t size = out[0].__r_.__value_.__s.__size_;
  }
  else {
    uint64_t size = out[0].__r_.__value_.__l.__size_;
  }
  id v47 = sub_1001FD17C(v44, (uint64_t)v45, size);
  id v48 = sub_1001FD17C(v47, (uint64_t)"sec (delta:", 11LL);
  int v49 = (void *)std::ostream::operator<<(v48, v27);
  int v50 = sub_1001FD17C(v49, (uint64_t)"ms) ", 4LL);
  std::string::size_type v51 = sub_1001FD17C(v50, (uint64_t)"scanDutyCycle:", 14LL);
  __int128 v52 = (void *)std::ostream::operator<<(v51, (unsigned __int16)*a3);
  sub_1001FD17C(v52, (uint64_t)" interval:", 10LL);
  LOWORD(v53) = *(_WORD *)(a1 + 2LL * (unsigned __int16)*a3 + 256);
  __int16 v54 = (void *)std::ostream::operator<<((double)v53 * 0.625);
  int v55 = sub_1001FD17C(v54, (uint64_t)"ms coexOverrideReason:", 22LL);
  std::ostream::operator<<(v55, *a4);
  BOOL v56 = (os_log_s *)qword_1008F7620;
  if (os_log_type_enabled((os_log_t)qword_1008F7620, OS_LOG_TYPE_INFO))
  {
    std::stringbuf::str(out, (const std::stringbuf *)((char *)v62 + 8));
    BOOL v57 = (out[0].__r_.__value_.__s.__size_ & 0x80u) == 0
        ? out
        : (std::stringbuf::string_type *)out[0].__r_.__value_.__r.__words[0];
    LODWORD(buf) = 136446210;
    *(void *)((char *)&buf + 4) = v57;
    _os_log_impl((void *)&_mh_execute_header, v56, OS_LOG_TYPE_INFO, "%{public}s", (uint8_t *)&buf, 0xCu);
  }

  *(void *)((char *)&v62[-1]
  *(void *)&v62[0] = v58;
  if (SHIBYTE(v64) < 0) {
    operator delete(__p[1]);
  }
  std::streambuf::~streambuf((char *)v62 + 8);
  std::ios::~ios(v66);
}

void sub_1005AC414( _Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, void *a6, uint64_t a7, ...)
{
  _Unwind_Resume(a1);
}

uint64_t sub_1005AC4A0(uint64_t a1, _WORD *a2, unsigned __int16 *a3, _WORD *a4, unsigned __int8 *a5)
{
  *a5 = 0;
  *a4 = 0;
  if (*(void *)(a1 + 896))
  {
    __int16 v107 = 0;
    if (qword_1008D6198 != -1) {
      dispatch_once(&qword_1008D6198, &stru_1008A2B70);
    }
    sub_1004491EC((uint64_t)off_1008D6190, 2);
    uint64_t v6 = sub_1002E8EE8();
    (*(void (**)(uint64_t, __int16 *, char *))(*(void *)v6 + 48LL))(v6, &v107, (char *)&v107 + 1);
    BOOL v7 = 0;
    *a3 = 48;
    *a2 = 480;
    if (v107 == 1)
    {
      HIDWORD(v97) = 0;
      uint64_t v8 = a1;
      if (HIBYTE(v107))
      {
        if (qword_1008D6198 != -1) {
          dispatch_once(&qword_1008D6198, &stru_1008A2B70);
        }
        HIDWORD(v97) = *((_BYTE *)off_1008D6190 + 197) != 0;
        BOOL v7 = *((_BYTE *)off_1008D6190 + 198) != 0;
      }
    }

    else
    {
      HIDWORD(v97) = 0;
      uint64_t v8 = a1;
    }

    LODWORD(v97) = v7;
    uint64_t v37 = *(const unsigned __int8 **)(v8 + 336);
    unsigned int v100 = (const unsigned __int8 **)(v8 + 344);
    if (v37 == (const unsigned __int8 *)(v8 + 344))
    {
      char v38 = 0;
    }

    else
    {
      char v38 = 0;
      if (v97) {
        __int16 v39 = 8;
      }
      else {
        __int16 v39 = 7;
      }
      __int16 v99 = v39;
      do
      {
        unsigned __int16 v106 = 0;
        if (qword_1008D5F30 != -1) {
          dispatch_once(&qword_1008D5F30, &stru_1008A2B30);
        }
        uint64_t v40 = off_1008D5F28;
        uint64_t v41 = sub_100241F94(v37 + 25);
        uint64_t v42 = (void *)objc_claimAutoreleasedReturnValue(v41);
        int v43 = sub_1005D6BDC((uint64_t)v40, v42);

        BOOL v44 = v43 == 1;
        if (HIBYTE(v107)) {
          BOOL v45 = v107 == 1;
        }
        else {
          BOOL v45 = 0;
        }
        __int16 v46 = v99;
        if (!v45) {
          __int16 v46 = v43;
        }
        unsigned __int16 v106 = v46;
        uint64_t v104 = 0LL;
        uint64_t v105 = 0LL;
        if (qword_1008D5F30 != -1) {
          dispatch_once(&qword_1008D5F30, &stru_1008A2B30);
        }
        id v47 = off_1008D5F28;
        id v48 = sub_100241F94(v37 + 25);
        int v49 = (void *)objc_claimAutoreleasedReturnValue(v48);
        sub_1005D3DE4((uint64_t)v47, v49, (uint64_t)&v104);

        int v50 = sub_100241F94(v37 + 25);
        std::string::size_type v51 = (void *)objc_claimAutoreleasedReturnValue(v50);
        sub_1005ABDE4(a1, v51, &v106, a5, &v104);

        uint64_t v52 = v106;
        if (v106 < 9uLL)
        {
          *(_WORD *)&buf_4[2] = 0;
          int buf = v104;
          *(_WORD *)buf_4 = v105;
          BOOL v56 = sub_1001F4468((uint64_t)&buf);
          unsigned int v57 = (unsigned __int16)*a2;
          *a2 = v57;
          uint64_t v58 = sub_1002E6BF0();
          if ((*(unsigned int (**)(uint64_t))(*(void *)v58 + 648LL))(v58))
          {
            unsigned int v59 = (unsigned __int16)*a4;
            if (qword_1008D5F30 != -1) {
              dispatch_once(&qword_1008D5F30, &stru_1008A2B30);
            }
            uint64_t v60 = off_1008D5F28;
            __int128 v61 = sub_100241F94(v37 + 25);
            uint64_t v62 = (void *)objc_claimAutoreleasedReturnValue(v61);
            if (v59 <= sub_1005CFC90((uint64_t)v60, v62))
            {
              if (qword_1008D5F30 != -1) {
                dispatch_once(&qword_1008D5F30, &stru_1008A2B30);
              }
              id v63 = off_1008D5F28;
              __int128 v64 = sub_100241F94(v37 + 25);
              __int128 v65 = (void *)objc_claimAutoreleasedReturnValue(v64);
              *a4 = sub_1005CFC90((uint64_t)v63, v65);
            }
          }

          uint64_t v66 = (os_log_s *)qword_1008F7620;
          if (os_log_type_enabled((os_log_t)qword_1008F7620, OS_LOG_TYPE_INFO))
          {
            uint64_t v67 = sub_100241F94(v37 + 25);
            id v68 = (id)objc_claimAutoreleasedReturnValue(v67);
            int v69 = *a3;
            int v70 = v106;
            int v71 = *(unsigned __int16 *)(a1 + 2LL * v106 + 256);
            v108[0] = v104;
            v108[1] = (unsigned __int16)v105;
            BOOL v72 = sub_1001F4468((uint64_t)v108);
            int v73 = *a3;
            __int128 v74 = "NO";
            if (v72) {
              __int128 v74 = "YES";
            }
            int v75 = (unsigned __int16)*a2;
            int v76 = (unsigned __int16)*a4;
            int buf = 138545154;
            *(void *)buf_4 = v68;
            *(_WORD *)&buf_4[8] = 1024;
            *(_DWORD *)uint64_t v111 = v69;
            *(_WORD *)&v111[4] = 1024;
            *(_DWORD *)v112 = v71;
            *(_WORD *)&v112[4] = 1024;
            *(_DWORD *)v113 = v70;
            *(_WORD *)&v113[4] = 2082;
            v114 = v74;
            __int16 v115 = 1024;
            int v116 = v73;
            __int16 v117 = 1024;
            int v118 = v75;
            __int16 v119 = 1024;
            int v120 = v76;
            _os_log_impl( (void *)&_mh_execute_header,  v66,  OS_LOG_TYPE_INFO,  "device %{public}@ Connection scans [0x%x/0x%x(level:%d)] ignored:%{public}s [aggregated 0x%x/0x%x/0x%x]",  (uint8_t *)&buf,  0x3Au);
          }
        }

        else
        {
          unint64_t v53 = (os_log_s *)qword_1008F7620;
          if (os_log_type_enabled((os_log_t)qword_1008F7620, OS_LOG_TYPE_FAULT))
          {
            uint64_t v79 = sub_100241F94(v37 + 25);
            uint64_t v80 = (void *)objc_claimAutoreleasedReturnValue(v79);
            int buf = 138543618;
            *(void *)buf_4 = v80;
            *(_WORD *)&buf_4[8] = 1024;
            *(_DWORD *)uint64_t v111 = v106;
            _os_log_fault_impl( (void *)&_mh_execute_header,  v53,  OS_LOG_TYPE_FAULT,  "device %{public}@ connection scan duty cycle %d is invalid",  (uint8_t *)&buf,  0x12u);

            unint64_t v53 = (os_log_s *)qword_1008F7620;
          }

          if (os_log_type_enabled(v53, OS_LOG_TYPE_ERROR))
          {
            __int16 v54 = sub_100241F94(v37 + 25);
            int v55 = (void *)objc_claimAutoreleasedReturnValue(v54);
            int buf = 138543618;
            *(void *)buf_4 = v55;
            *(_WORD *)&buf_4[8] = 1024;
            *(_DWORD *)uint64_t v111 = v106;
            _os_log_error_impl( (void *)&_mh_execute_header,  v53,  OS_LOG_TYPE_ERROR,  "device %{public}@ connection scan duty cycle %d is invalid",  (uint8_t *)&buf,  0x12u);
          }
        }

        __int128 v77 = (unsigned __int8 *)*((void *)v37 + 1);
        if (v77)
        {
          do
          {
            __int128 v78 = (const unsigned __int8 **)v77;
            __int128 v77 = *(unsigned __int8 **)v77;
          }

          while (v77);
        }

        else
        {
          do
          {
            __int128 v78 = (const unsigned __int8 **)*((void *)v37 + 2);
            BOOL v10 = *v78 == v37;
            uint64_t v37 = (const unsigned __int8 *)v78;
          }

          while (!v10);
        }

        v38 |= v44;
        uint64_t v37 = (const unsigned __int8 *)v78;
      }

      while (v78 != v100);
    }

    if (v107 == 1 && HIBYTE(v107) != 0)
    {
      uint64_t v82 = sub_1002E6BF0();
      int v83 = (*(uint64_t (**)(uint64_t))(*(void *)v82 + 968LL))(v82);
      int v84 = v83;
      unsigned int v85 = (unsigned __int16)*a2;
      if ((v97 | HIDWORD(v97)) == 1)
      {
        *a2 = v85;
        if (v83)
        {
          if (_os_feature_enabled_impl("BluetoothFeatures", "ScanCorePolicyV2"))
          {
            int v86 = (unsigned __int16)*a2;
            if (v86 == *(unsigned __int16 *)(a1 + 272))
            {
              int v87 = v86 - *a3;
              *a4 = v87;
            }
          }
        }
      }

      else
      {
        if ((v38 & 1) != 0) {
          unsigned int v88 = *(unsigned __int16 *)(a1 + 272);
        }
        else {
          unsigned int v88 = *(unsigned __int16 *)(a1 + 270);
        }
        if (v85 <= v88) {
          LOWORD(v85) = v88;
        }
        *a2 = v85;
      }

      double v89 = (os_log_s *)qword_1008F7620;
      if (os_log_type_enabled((os_log_t)qword_1008F7620, OS_LOG_TYPE_INFO))
      {
        int v90 = *a3;
        int v91 = (unsigned __int16)*a2;
        int v92 = (unsigned __int16)*a4;
        int buf = 67110400;
        *(_DWORD *)buf_4 = HIDWORD(v97);
        *(_WORD *)&buf_4[4] = 1024;
        *(_DWORD *)&buf_4[6] = v97;
        *(_WORD *)uint64_t v111 = 1024;
        *(_DWORD *)&v111[2] = v84;
        *(_WORD *)v112 = 1024;
        *(_DWORD *)&v112[2] = v90;
        *(_WORD *)v113 = 1024;
        *(_DWORD *)&v113[2] = v91;
        LOWORD(v114) = 1024;
        *(_DWORD *)((char *)&v114 + 2) = v92;
        _os_log_impl( (void *)&_mh_execute_header,  v89,  OS_LOG_TYPE_INFO,  "CarPlay is on, isA2DPStreaming:%d isHFPStreaming:%d highDutySC:%d Connection scans updated [0x%x/0x%x/0x%x]",  (uint8_t *)&buf,  0x26u);
      }
    }
  }

  else
  {
    if (qword_1008D6198 != -1) {
      dispatch_once(&qword_1008D6198, &stru_1008A2B70);
    }
    sub_1004491EC((uint64_t)off_1008D6190, 1);
    LOBYTE(v104) = 0;
    LOBYTE(v108[0]) = 0;
    LOBYTE(v106) = 0;
    uint64_t v9 = sub_1002E8D54();
    else {
      BOOL v10 = v104 == 0;
    }
    if (v10
      && ((uint64_t v11 = sub_1002E8D54(),
           !(*(unsigned int (**)(uint64_t, _DWORD *, unsigned __int16 *))(*(void *)v11 + 96LL))( v11,  v108,  &v106))
        ? (BOOL v12 = LOBYTE(v108[0]) == 0)
        : (BOOL v12 = 1),
          v12))
    {
      *a2 = 480;
      *a3 = *(_WORD *)(a1 + 274);
      __int128 v13 = *(const unsigned __int8 **)(a1 + 336);
      if (v13 != (const unsigned __int8 *)(a1 + 344))
      {
        do
        {
          if (qword_1008D5F30 != -1) {
            dispatch_once(&qword_1008D5F30, &stru_1008A2B30);
          }
          uint64_t v14 = off_1008D5F28;
          int v15 = sub_100241F94(v13 + 25);
          BOOL v16 = (void *)objc_claimAutoreleasedReturnValue(v15);
          unsigned int v17 = sub_1005D6CEC((uint64_t)v14, v16);

          if (v17 >= 7)
          {
            id v20 = (os_log_s *)qword_1008F7620;
            uint64_t v18 = a3;
            if (os_log_type_enabled((os_log_t)qword_1008F7620, OS_LOG_TYPE_FAULT))
            {
              int buf = 67109120;
              *(_DWORD *)buf_4 = v17;
              _os_log_fault_impl( (void *)&_mh_execute_header,  v20,  OS_LOG_TYPE_FAULT,  "scanDutyCycle cannot be %d",  (uint8_t *)&buf,  8u);
            }
          }

          else
          {
            uint64_t v18 = a3;
            unsigned int v19 = *a3;
            *a3 = v19;
          }

          unsigned int v21 = *v18;
          unsigned int v22 = (unsigned __int16)*a2;
          if (v21 > v22)
          {
            size_t v23 = (os_log_s *)qword_1008F7620;
            if (os_log_type_enabled((os_log_t)qword_1008F7620, OS_LOG_TYPE_FAULT))
            {
              int buf = 67109376;
              *(_DWORD *)buf_4 = v21;
              *(_WORD *)&buf_4[4] = 1024;
              *(_DWORD *)&buf_4[6] = v22;
              _os_log_fault_impl( (void *)&_mh_execute_header,  v23,  OS_LOG_TYPE_FAULT,  "scanWindow (0x%x), scanInterval (0x%x)",  (uint8_t *)&buf,  0xEu);
            }
          }

          uint64_t v24 = (unsigned __int8 *)*((void *)v13 + 1);
          if (v24)
          {
            do
            {
              uint64_t v25 = (const unsigned __int8 **)v24;
              uint64_t v24 = *(unsigned __int8 **)v24;
            }

            while (v24);
          }

          else
          {
            do
            {
              uint64_t v25 = (const unsigned __int8 **)*((void *)v13 + 2);
              BOOL v10 = *v25 == v13;
              __int128 v13 = (const unsigned __int8 *)v25;
            }

            while (!v10);
          }

          __int128 v13 = (const unsigned __int8 *)v25;
        }

        while (v25 != (const unsigned __int8 **)(a1 + 344));
      }
    }

    else
    {
      *a2 = 480;
      *a3 = 48;
    }

    uint64_t v26 = sub_1002E6BF0();
    if ((*(unsigned int (**)(uint64_t))(*(void *)v26 + 648LL))(v26))
    {
      uint64_t v27 = *(const unsigned __int8 **)(a1 + 336);
      if (v27 != (const unsigned __int8 *)(a1 + 344))
      {
        do
        {
          unsigned int v28 = (unsigned __int16)*a4;
          if (qword_1008D5F30 != -1) {
            dispatch_once(&qword_1008D5F30, &stru_1008A2B30);
          }
          unint64_t v29 = off_1008D5F28;
          unint64_t v30 = sub_100241F94(v27 + 25);
          unint64_t v31 = (void *)objc_claimAutoreleasedReturnValue(v30);
          if (v28 <= sub_1005CFC90((uint64_t)v29, v31))
          {
            if (qword_1008D5F30 != -1) {
              dispatch_once(&qword_1008D5F30, &stru_1008A2B30);
            }
            int v32 = off_1008D5F28;
            unint64_t v33 = sub_100241F94(v27 + 25);
            unint64_t v34 = (void *)objc_claimAutoreleasedReturnValue(v33);
            *a4 = sub_1005CFC90((uint64_t)v32, v34);
          }

          double v35 = (unsigned __int8 *)*((void *)v27 + 1);
          if (v35)
          {
            do
            {
              double v36 = (const unsigned __int8 **)v35;
              double v35 = *(unsigned __int8 **)v35;
            }

            while (v35);
          }

          else
          {
            do
            {
              double v36 = (const unsigned __int8 **)*((void *)v27 + 2);
              BOOL v10 = *v36 == v27;
              uint64_t v27 = (const unsigned __int8 *)v36;
            }

            while (!v10);
          }

          uint64_t v27 = (const unsigned __int8 *)v36;
        }

        while (v36 != (const unsigned __int8 **)(a1 + 344));
      }
    }
  }

  if (*(_BYTE *)(a1 + 1075))
  {
    *a3 = *(_WORD *)(a1 + 1076);
    int v93 = *(unsigned __int16 *)(a1 + 1078);
    *a2 = v93;
    BOOL v94 = (os_log_s *)qword_1008F7620;
    if (os_log_type_enabled((os_log_t)qword_1008F7620, OS_LOG_TYPE_DEFAULT))
    {
      int v95 = *a3;
      int buf = 67109376;
      *(_DWORD *)buf_4 = v95;
      *(_WORD *)&buf_4[4] = 1024;
      *(_DWORD *)&buf_4[6] = v93;
      _os_log_impl( (void *)&_mh_execute_header,  v94,  OS_LOG_TYPE_DEFAULT,  "Overriding Connection Scan Parameters on MainCore. window=%d: interval=%d ",  (uint8_t *)&buf,  0xEu);
    }
  }

  uint64_t result = sub_1005B5198((unsigned __int16 *)a1, (unsigned __int16)*a2, *a3, (unsigned __int16)*a4);
  if ((result & 1) == 0) {
    *a4 = 0;
  }
  return result;
}

void sub_1005AD034(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

uint64_t sub_1005AD0B8(uint64_t a1, char a2)
{
  if ((a2 & 1) == 0 && *(_BYTE *)(a1 + 184))
  {
    if (*(void *)(a1 + 352)) {
      return sub_1005AB264(a1);
    }
  }

  return a1;
}

uint64_t sub_1005AD0D4(uint64_t a1)
{
  v3[0] = 0LL;
  v3[1] = 0LL;
  sub_100242F28((uint64_t)v3, a1 + 120);
  if (*(_BYTE *)(a1 + 184) && *(void *)(a1 + 352)) {
    sub_1005AB264(a1);
  }
  return sub_100242FAC((uint64_t)v3);
}

void sub_1005AD128( _Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9)
{
}

uint64_t sub_1005AD13C(uint64_t a1)
{
  return sub_1005AD0D4(a1 - 8);
}

void sub_1005AD148(os_unfair_lock_s *a1, void *a2)
{
  int v3 = a2;
  os_unfair_lock_lock(a1);
  uint64_t v5 = 0LL;
  uint64_t v6 = 0LL;
  uint64_t v7 = 0LL;
  sub_100240540(&v5, (uint64_t)&a1[2]);
  os_unfair_lock_unlock(a1);
  int v4 = v5;
  if (v5 != v6)
  {
    do
      v3[2](v3, *v4++);
    while (v4 != v6);
    int v4 = v5;
  }

  if (v4)
  {
    uint64_t v6 = v4;
    operator delete(v4);
  }
}

void sub_1005AD1DC( _Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void *__p, uint64_t a11)
{
  _Unwind_Resume(a1);
}

uint64_t sub_1005AD204(os_unfair_lock_s *a1, int a2, uint64_t a3, int a4)
{
  v29[0] = 0LL;
  v29[1] = 0LL;
  sub_100242F28((uint64_t)v29, (uint64_t)&a1[30]);
  id v8 = sub_10059A5A8((uint64_t)a1, a3);
  uint64_t v9 = (void *)objc_claimAutoreleasedReturnValue(v8);
  if (v9)
  {
    sub_100241F90(uu2, v9);
    uint64_t v10 = sub_1001FDB10((uint64_t)&a1[234], uu2);
    uint64_t v11 = v10;
    if (&a1[236] == (os_unfair_lock_s *)v10)
    {
      if (os_log_type_enabled((os_log_t)qword_1008F7620, OS_LOG_TYPE_ERROR)) {
        sub_100699C48();
      }
    }

    else
    {
      *(void *)uu2 = 0LL;
      v32[0] = 0LL;
      v32[1] = 0LL;
      uint64_t v12 = v10 + 48;
      sub_1005BE160((uint64_t *)uu2, v10 + 48);
      uint64_t v14 = *(void **)(v11 + 56);
      __int128 v13 = (void *)(v11 + 56);
      sub_10023BF24(v12, v14);
      *(v13 - 1) = v13;
      *__int128 v13 = 0LL;
      v13[1] = 0LL;
      uint64_t v15 = sub_100404FE8();
      BOOL v16 = operator new(0x28uLL);
      sub_100241F90(src, v9);
      *((_WORD *)v16 + 4) = 1;
      *((void *)v16 + 2) = 0LL;
      *(void *)BOOL v16 = &off_1008A2AE8;
      uuid_copy(v16 + 24, src);
      *((void *)v16 + 2) = 1000LL;
      sub_100405744(v15, v16);
      sub_100242F54((uint64_t)v29);
      BOOL v17 = a2 == 0;
      BOOL v18 = a4 == 127 || a2 != 0;
      if (v17 && a4 == 127) {
        LOBYTE(a4) = 0;
      }
      unsigned int v19 = *(void ***)uu2;
      if (*(void ***)uu2 != v32)
      {
        do
        {
          v24[0] = _NSConcreteStackBlock;
          v24[1] = 3221225472LL;
          void v24[2] = sub_1005AD500;
          v24[3] = &unk_1008A2628;
          uint64_t v26 = v19 + 4;
          id v25 = v9;
          BOOL v27 = v18;
          char v28 = a4;
          sub_10058C72C(a1, v24);

          id v20 = v19[1];
          if (v20)
          {
            do
            {
              unsigned int v21 = (void **)v20;
              id v20 = (void *)*v20;
            }

            while (v20);
          }

          else
          {
            do
            {
              unsigned int v21 = (void **)v19[2];
              BOOL v22 = *v21 == v19;
              unsigned int v19 = v21;
            }

            while (!v22);
          }

          unsigned int v19 = v21;
        }

        while (v21 != v32);
      }

      sub_10023BF24((uint64_t)uu2, v32[0]);
    }
  }

  else if (os_log_type_enabled((os_log_t)qword_1008F7620, OS_LOG_TYPE_ERROR))
  {
    sub_100699BE4();
  }

  return sub_100242FAC((uint64_t)v29);
}

void sub_1005AD49C( _Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, char a17, uint64_t a18, uint64_t a19, uint64_t a20, char a21, void *a22)
{
  sub_100242FAC((uint64_t)&a17);
  _Unwind_Resume(a1);
}

uint64_t sub_1005AD500(uint64_t a1, uint64_t a2)
{
  return (*(uint64_t (**)(uint64_t, void, void, void, void))(*(void *)a2 + 24LL))( a2,  **(void **)(a1 + 40),  *(void *)(a1 + 32),  *(unsigned int *)(a1 + 48),  *(char *)(a1 + 52));
}

uint64_t sub_1005AD524(uint64_t a1, unsigned __int8 *a2)
{
  v6[0] = 0LL;
  v6[1] = 0LL;
  sub_100242F28((uint64_t)v6, a1 + 120);
  uint64_t v4 = sub_1001FDB10(a1 + 936, a2);
  if (a1 + 944 != v4)
  {
    if (*(void *)(v4 + 64)) {
      sub_1005997F4(a1, a2);
    }
    else {
      sub_1004F57A0((uint64_t **)(a1 + 936), v4);
    }
  }

  return sub_100242FAC((uint64_t)v6);
}

void sub_1005AD5AC( _Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9)
{
}

uint64_t sub_1005AD5C0(os_unfair_lock_s *a1, uint64_t a2, int a3)
{
  v14[0] = 0LL;
  v14[1] = 0LL;
  sub_100242F28((uint64_t)v14, (uint64_t)&a1[30]);
  id v6 = sub_10059A5A8((uint64_t)a1, a2);
  uint64_t v7 = (void *)objc_claimAutoreleasedReturnValue(v6);
  if (v7)
  {
    id v8 = (os_log_s *)qword_1008F7620;
    if (os_log_type_enabled((os_log_t)qword_1008F7620, OS_LOG_TYPE_DEFAULT))
    {
      uint64_t v9 = "asleep";
      if (a3) {
        uint64_t v9 = "awake";
      }
      *(_DWORD *)int buf = 138543618;
      BOOL v16 = v7;
      __int16 v17 = 2082;
      BOOL v18 = v9;
      _os_log_impl( (void *)&_mh_execute_header,  v8,  OS_LOG_TYPE_DEFAULT,  "Device %{public}@ is now %{public}s",  buf,  0x16u);
    }

    v11[0] = _NSConcreteStackBlock;
    v11[1] = 3221225472LL;
    v11[2] = sub_1005AD748;
    v11[3] = &unk_1008A2650;
    id v12 = v7;
    char v13 = a3;
    sub_10058C72C(a1, v11);
  }

  return sub_100242FAC((uint64_t)v14);
}

void sub_1005AD718( _Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, void *a6, uint64_t a7, ...)
{
  sub_100242FAC((uint64_t)va);
  _Unwind_Resume(a1);
}

uint64_t sub_1005AD748(uint64_t a1, uint64_t a2)
{
  return (*(uint64_t (**)(uint64_t, void, void))(*(void *)a2 + 48LL))( a2,  *(void *)(a1 + 32),  *(unsigned __int8 *)(a1 + 40));
}

uint64_t sub_1005AD764(os_unfair_lock_s *a1, uint64_t a2, int a3, uint64_t a4, int a5, int a6, int a7, int a8)
{
  v31[0] = 0LL;
  v31[1] = 0LL;
  sub_100242F28((uint64_t)v31, (uint64_t)&a1[30]);
  id v16 = sub_10059A5A8((uint64_t)a1, a2);
  __int16 v17 = (void *)objc_claimAutoreleasedReturnValue(v16);
  BOOL v18 = (os_log_s *)qword_1008F7620;
  BOOL v19 = os_log_type_enabled((os_log_t)qword_1008F7620, OS_LOG_TYPE_DEFAULT);
  if (v17)
  {
    if (v19)
    {
      BOOL v20 = a3 == 1 || a3 == 10;
      *(_DWORD *)int buf = 138545154;
      unsigned int v21 = "LE_SET_PHY";
      uint64_t v33 = (uint64_t)v17;
      __int16 v34 = 2082;
      if (v20) {
        unsigned int v21 = "ConnectionComplete";
      }
      double v35 = v21;
      __int16 v36 = 1024;
      int v37 = a3;
      __int16 v38 = 2048;
      uint64_t v39 = a4;
      __int16 v40 = 1024;
      int v41 = a5;
      __int16 v42 = 1024;
      int v43 = a6;
      __int16 v44 = 1024;
      int v45 = a7;
      __int16 v46 = 1024;
      int v47 = a8;
      _os_log_impl( (void *)&_mh_execute_header,  v18,  OS_LOG_TYPE_DEFAULT,  "Device %{public}@ is receiving a timestamp %{public}s EventType=%d with value %llu %d eventCnt=%d, sec:%d ms:%d",  buf,  0x3Eu);
    }

    v23[0] = _NSConcreteStackBlock;
    v23[1] = 3221225472LL;
    v23[2] = sub_1005AD99C;
    v23[3] = &unk_1008A2678;
    char v30 = a3;
    id v24 = v17;
    uint64_t v25 = a4;
    __int16 v29 = a6;
    int v26 = a5;
    int v27 = a7;
    int v28 = a8;
    sub_10058C72C(a1, v23);
  }

  else if (v19)
  {
    *(_DWORD *)int buf = 134217984;
    uint64_t v33 = a2;
    _os_log_impl((void *)&_mh_execute_header, v18, OS_LOG_TYPE_DEFAULT, "Device is not connected for %p", buf, 0xCu);
  }

  return sub_100242FAC((uint64_t)v31);
}

void sub_1005AD96C( _Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, void *a6, uint64_t a7, uint64_t a8, uint64_t a9, ...)
{
  sub_100242FAC((uint64_t)va);
  _Unwind_Resume(a1);
}

uint64_t sub_1005AD99C(uint64_t a1, uint64_t a2)
{
  return (*(uint64_t (**)(uint64_t, void, void, void, void, void, void, void))(*(void *)a2 + 56LL))( a2,  *(void *)(a1 + 32),  *(unsigned __int8 *)(a1 + 62),  *(void *)(a1 + 40),  *(unsigned int *)(a1 + 48),  *(unsigned __int16 *)(a1 + 60),  *(unsigned int *)(a1 + 52),  *(unsigned int *)(a1 + 56));
}

uint64_t sub_1005AD9C4( os_unfair_lock_s *a1, uint64_t a2, int a3, int a4, int a5, int a6, uint64_t a7, char a8, char a9, char a10, char a11, char a12, unsigned __int16 a13, int a14, char a15, char a16)
{
  v56[0] = 0LL;
  v56[1] = 0LL;
  sub_100242F28((uint64_t)v56, (uint64_t)&a1[30]);
  id v24 = sub_10059A5A8((uint64_t)a1, a2);
  uint64_t v25 = (void *)objc_claimAutoreleasedReturnValue(v24);
  if (v25)
  {
    sub_100241F90(buf, v25);
    if (sub_100599D10((uint64_t)a1, buf))
    {
      int v26 = (os_log_s *)qword_1008F7620;
      if (os_log_type_enabled((os_log_t)qword_1008F7620, OS_LOG_TYPE_DEFAULT))
      {
        int v27 = "";
        *(_DWORD *)int buf = 138545666;
        *(void *)&uint8_t buf[4] = v25;
        if (a15) {
          int v27 = " wakeUp";
        }
        *(_WORD *)&_BYTE buf[12] = 1024;
        *(_DWORD *)&buf[14] = a9;
        *(_WORD *)&buf[18] = 1024;
        *(_DWORD *)&buf[20] = a10;
        *(_WORD *)&uint8_t buf[24] = 1024;
        *(_DWORD *)&buf[26] = a11;
        *(_WORD *)&buf[30] = 1024;
        LODWORD(v59) = a12;
        WORD2(v59) = 1024;
        *(_DWORD *)((char *)&v59 + 6) = a13;
        WORD5(v59) = 1024;
        HIDWORD(v59) = a3;
        *(_WORD *)uint64_t v60 = 1024;
        *(_DWORD *)&v60[2] = a4;
        *(_WORD *)&v60[6] = 1024;
        *(_DWORD *)&v60[8] = a5;
        *(_WORD *)&v60[12] = 2082;
        *(void *)&v60[14] = v27;
        _os_log_impl( (void *)&_mh_execute_header,  v26,  OS_LOG_TYPE_DEFAULT,  "Device %{public}@ is receiving a Rssi Detection Rssi [Avg|Max|median|min] var = %d:%d:%d:%d %d  CoreMotion=%x: %x:%x %{public}s",  buf,  0x46u);
      }

      __int128 v59 = 0u;
      memset(v60, 0, sizeof(v60));
      memset(buf, 0, sizeof(buf));
      sub_10058C504((uint64_t)a1, v25, (uint64_t)buf);
      if (*(void *)buf)
      {
        ++*(_DWORD *)&v60[12];
        if (a15) {
          ++*(_DWORD *)&v60[8];
        }
        v51[0] = *(id *)buf;
        v51[1] = *(id *)&buf[8];
        __int128 v52 = *(_OWORD *)&buf[16];
        __int128 v53 = v59;
        __int128 v54 = *(_OWORD *)v60;
        int v55 = *(_DWORD *)&v60[16];
        sub_10058C62C((uint64_t)a1, v25, (uint64_t)v51);
      }

      v36[0] = _NSConcreteStackBlock;
      v36[1] = 3221225472LL;
      v36[2] = sub_1005ADE5C;
      v36[3] = &unk_1008A26A0;
      id v28 = v25;
      int v39 = a3;
      int v40 = a4;
      int v41 = a5;
      int v42 = a6;
      id v37 = v28;
      uint64_t v38 = a7;
      char v45 = a8;
      char v46 = a9;
      char v47 = a10;
      char v48 = a11;
      char v49 = a12;
      unsigned __int16 v44 = a13;
      int v43 = a14;
      char v50 = a16;
      sub_10058C72C(a1, v36);
      if (a15)
      {
        sub_100241F90(&uu2, v28);
        uint64_t v29 = sub_1001FDB10((uint64_t)&a1[160], (unsigned __int8 *)&uu2);
        if (&a1[162] != (os_unfair_lock_s *)v29)
        {
          memset(&uu2, 0, sizeof(uu2));
          sub_1004949D8(*(void *)(v29 + 48), &uu2);
          uint64_t v30 = sub_1002E9074();
          if ((uu2.__r_.__value_.__s.__size_ & 0x80u) == 0) {
            p_std::string uu2 = &uu2;
          }
          else {
            p_std::string uu2 = (std::string *)uu2.__r_.__value_.__r.__words[0];
          }
          __int16 v34 = &off_10087FAA8;
          double v35 = 0LL;
          (*(void (**)(uint64_t, uint64_t, std::string *, id, uint64_t (***)()))(*(void *)v30 + 40LL))( v30,  6LL,  p_uu2,  v28,  &v34);
          __int16 v34 = &off_10087FAA8;
          if (v35) {
            sub_1002CD254(v35);
          }
        }
      }
    }
  }

  else
  {
    int v32 = (os_log_s *)qword_1008F7620;
    if (os_log_type_enabled((os_log_t)qword_1008F7620, OS_LOG_TYPE_DEFAULT))
    {
      *(_DWORD *)int buf = 134217984;
      *(void *)&uint8_t buf[4] = a2;
      _os_log_impl((void *)&_mh_execute_header, v32, OS_LOG_TYPE_DEFAULT, "Device is not connected for %p", buf, 0xCu);
    }
  }

  return sub_100242FAC((uint64_t)v56);
}

void sub_1005ADDC4( _Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, unsigned int *a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, void *a19, uint64_t a20, uint64_t a21, uint64_t a22, uint64_t a23, uint64_t a24, uint64_t a25, uint64_t a26, uint64_t a27, uint64_t a28, uint64_t a29, uint64_t a30, uint64_t a31, uint64_t a32, uint64_t a33, char a34)
{
  if (a14) {
    sub_1002CD254(a14);
  }

  sub_100242FAC((uint64_t)&a34);
  _Unwind_Resume(a1);
}

uint64_t sub_1005ADE5C(uint64_t a1, uint64_t a2)
{
  BYTE4(v4) = *(_BYTE *)(a1 + 75);
  LODWORD(v4) = *(_DWORD *)(a1 + 64);
  WORD2(v3) = *(_WORD *)(a1 + 68);
  LODWORD(v3) = *(_DWORD *)(a1 + 71);
  return (*(uint64_t (**)(uint64_t, void, void, void, void, void, void, void, uint64_t, uint64_t))(*(void *)a2 + 72LL))( a2,  *(void *)(a1 + 32),  *(unsigned int *)(a1 + 48),  *(unsigned int *)(a1 + 52),  *(unsigned int *)(a1 + 56),  *(unsigned int *)(a1 + 60),  *(void *)(a1 + 40),  *(char *)(a1 + 70),  v3,  v4);
}

uint64_t sub_1005ADEB8(os_unfair_lock_s *a1, uint64_t a2, int a3, int a4, int a5, uint64_t a6, int a7)
{
  v26[0] = 0LL;
  v26[1] = 0LL;
  sub_100242F28((uint64_t)v26, (uint64_t)&a1[30]);
  id v14 = sub_10059A5A8((uint64_t)a1, a2);
  uint64_t v15 = (void *)objc_claimAutoreleasedReturnValue(v14);
  if (v15)
  {
    sub_100241F90(buf, v15);
    if (sub_100599DFC((uint64_t)a1, buf))
    {
      id v16 = (os_log_s *)qword_1008F7620;
      if (os_log_type_enabled((os_log_t)qword_1008F7620, OS_LOG_TYPE_DEFAULT))
      {
        *(_DWORD *)int buf = 138544386;
        uint64_t v28 = (uint64_t)v15;
        __int16 v29 = 1024;
        int v30 = a3;
        __int16 v31 = 1024;
        int v32 = a4;
        __int16 v33 = 1024;
        int v34 = a5;
        __int16 v35 = 2048;
        uint64_t v36 = a6;
        _os_log_impl( (void *)&_mh_execute_header,  v16,  OS_LOG_TYPE_DEFAULT,  "Device %{public}@ is receiving a Bluetooth Usage Event max:%d min:%d  audioStream=%d timeStamp=%llu",  buf,  0x28u);
      }

      v19[0] = _NSConcreteStackBlock;
      v19[1] = 3221225472LL;
      _DWORD v19[2] = sub_1005AE0E4;
      v19[3] = &unk_1008A26C8;
      __int16 v23 = a3;
      __int16 v24 = a4;
      char v25 = a5;
      id v20 = v15;
      uint64_t v21 = a6;
      int v22 = a7;
      sub_10058C72C(a1, v19);
    }
  }

  else
  {
    __int16 v17 = (os_log_s *)qword_1008F7620;
    if (os_log_type_enabled((os_log_t)qword_1008F7620, OS_LOG_TYPE_DEFAULT))
    {
      *(_DWORD *)int buf = 134217984;
      uint64_t v28 = a2;
      _os_log_impl((void *)&_mh_execute_header, v17, OS_LOG_TYPE_DEFAULT, "Device is not connected for %p", buf, 0xCu);
    }
  }

  return sub_100242FAC((uint64_t)v26);
}

void sub_1005AE0AC( _Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, void *a6, uint64_t a7, uint64_t a8, uint64_t a9, ...)
{
  sub_100242FAC((uint64_t)va);
  _Unwind_Resume(a1);
}

uint64_t sub_1005AE0E4(uint64_t a1, uint64_t a2)
{
  return (*(uint64_t (**)(uint64_t, void, void, void, void, void, void))(*(void *)a2 + 80LL))( a2,  *(void *)(a1 + 32),  *(unsigned __int16 *)(a1 + 52),  *(unsigned __int16 *)(a1 + 54),  *(unsigned __int8 *)(a1 + 56),  *(void *)(a1 + 40),  *(unsigned int *)(a1 + 48));
}

uint64_t sub_1005AE10C(os_unfair_lock_s *a1, uint64_t a2, char *a3, int a4)
{
  v24[0] = 0LL;
  v24[1] = 0LL;
  sub_100242F28((uint64_t)v24, (uint64_t)&a1[30]);
  id v8 = sub_10059A5A8((uint64_t)a1, a2);
  uint64_t v9 = (void *)objc_claimAutoreleasedReturnValue(v8);
  if (v9)
  {
    sub_100241F90(buf, v9);
    if (sub_100599E6C((uint64_t)a1, buf))
    {
      uint64_t v10 = (os_log_s *)qword_1008F7620;
      if (os_log_type_enabled((os_log_t)qword_1008F7620, OS_LOG_TYPE_DEFAULT))
      {
        int v11 = *a3;
        int v12 = *((unsigned __int16 *)a3 + 1);
        int v13 = *((unsigned __int16 *)a3 + 2);
        int v14 = *((unsigned __int16 *)a3 + 5);
        int v15 = *((unsigned __int16 *)a3 + 6);
        *(_DWORD *)int buf = 138544642;
        uint64_t v26 = (uint64_t)v9;
        __int16 v27 = 1024;
        int v28 = v11;
        __int16 v29 = 1024;
        int v30 = v12;
        __int16 v31 = 1024;
        int v32 = v13;
        __int16 v33 = 1024;
        int v34 = v14;
        __int16 v35 = 1024;
        int v36 = v15;
        _os_log_impl( (void *)&_mh_execute_header,  v10,  OS_LOG_TYPE_DEFAULT,  "Device %{public}@ is receiving a Phy statistc Bluetooth Usage Event Rssi:%d TxPER:%d:%d RxPER:%d:%d ",  buf,  0x2Au);
      }

      v19[0] = _NSConcreteStackBlock;
      v19[1] = 3221225472LL;
      _DWORD v19[2] = sub_1005AE33C;
      v19[3] = &unk_1008A26A0;
      id v20 = v9;
      __int128 v16 = *((_OWORD *)a3 + 1);
      __int128 v21 = *(_OWORD *)a3;
      __int128 v22 = v16;
      int v23 = a4;
      sub_10058C72C(a1, v19);
    }
  }

  else
  {
    __int16 v17 = (os_log_s *)qword_1008F7620;
    if (os_log_type_enabled((os_log_t)qword_1008F7620, OS_LOG_TYPE_DEFAULT))
    {
      *(_DWORD *)int buf = 134217984;
      uint64_t v26 = a2;
      _os_log_impl((void *)&_mh_execute_header, v17, OS_LOG_TYPE_DEFAULT, "Device is not connected for %p", buf, 0xCu);
    }
  }

  return sub_100242FAC((uint64_t)v24);
}

void sub_1005AE304( _Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, void *a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, ...)
{
  sub_100242FAC((uint64_t)va);
  _Unwind_Resume(a1);
}

uint64_t sub_1005AE33C(uint64_t a1, uint64_t a2)
{
  uint64_t v3 = *(void *)(a1 + 32);
  __int128 v4 = *(_OWORD *)(a1 + 56);
  v6[0] = *(_OWORD *)(a1 + 40);
  v6[1] = v4;
  return (*(uint64_t (**)(uint64_t, uint64_t, _OWORD *, void))(*(void *)a2 + 88LL))( a2,  v3,  v6,  *(unsigned int *)(a1 + 72));
}

void sub_1005AE380(os_unfair_lock_s *a1, uint64_t a2, int a3, int a4)
{
  id v7 = sub_10059A5A8((uint64_t)a1, a2);
  id v8 = (void *)objc_claimAutoreleasedReturnValue(v7);
  uint64_t v9 = (os_log_s *)qword_1008F7620;
  if (v8)
  {
    if (os_log_type_enabled((os_log_t)qword_1008F7620, OS_LOG_TYPE_DEFAULT))
    {
      uint64_t v10 = "high";
      *(_DWORD *)int buf = 136446722;
      if (a3) {
        uint64_t v10 = "low";
      }
      __int128 v16 = v10;
      __int16 v17 = 2114;
      BOOL v18 = v8;
      __int16 v19 = 1024;
      int v20 = a4;
      _os_log_impl( (void *)&_mh_execute_header,  v9,  OS_LOG_TYPE_DEFAULT,  "Crossed the %{public}s LE RSSI threshold for device %{public}@: %d",  buf,  0x1Cu);
    }

    v11[0] = _NSConcreteStackBlock;
    v11[1] = 3221225472LL;
    v11[2] = sub_1005AE508;
    v11[3] = &unk_1008A26F0;
    id v12 = v8;
    char v13 = a3;
    char v14 = a4;
    sub_10058C72C(a1, v11);
  }

  else if (os_log_type_enabled((os_log_t)qword_1008F7620, OS_LOG_TYPE_ERROR))
  {
    sub_100699CAC();
  }
}

void sub_1005AE4E8( _Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, void *a13)
{
  _Unwind_Resume(a1);
}

uint64_t sub_1005AE508(uint64_t a1, uint64_t a2)
{
  return (*(uint64_t (**)(uint64_t, void, void, void))(*(void *)a2 + 96LL))( a2,  *(void *)(a1 + 32),  *(unsigned __int8 *)(a1 + 40),  *(char *)(a1 + 41));
}

uint64_t sub_1005AE528(uint64_t a1, unint64_t a2, unsigned int a3, __int16 a4, int a5)
{
  v83[1] = 0LL;
  unint64_t v84 = a2;
  v83[0] = 0LL;
  sub_100242F28((uint64_t)v83, a1 + 120);
  memset(uu, 0, sizeof(uu));
  uuid_clear(uu);
  uint64_t v9 = *(const unsigned __int8 **)(a1 + 384);
  if (v9 != (const unsigned __int8 *)(a1 + 392))
  {
    while (*((void *)v9 + 6) != a2)
    {
      uint64_t v10 = (unsigned __int8 *)*((void *)v9 + 1);
      if (v10)
      {
        do
        {
          int v11 = (const unsigned __int8 **)v10;
          uint64_t v10 = *(unsigned __int8 **)v10;
        }

        while (v10);
      }

      else
      {
        do
        {
          int v11 = (const unsigned __int8 **)*((void *)v9 + 2);
          BOOL v66 = *v11 == v9;
          uint64_t v9 = (const unsigned __int8 *)v11;
        }

        while (!v66);
      }

      uint64_t v9 = (const unsigned __int8 *)v11;
    }

    uuid_copy(uu, v9 + 32);
  }

void sub_1005AEFF0( _Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, int a16, __int16 a17, char a18, char a19, void *__p, uint64_t a21, int a22, __int16 a23, char a24, char a25, char a26)
{
  sub_100242FAC((uint64_t)&a26);
  _Unwind_Resume(a1);
}

void sub_1005AF08C(uint64_t a1, uint64_t a2)
{
  uint64_t v3 = sub_100241F94((const unsigned __int8 *)(a1 + 42));
  id v4 = (id)objc_claimAutoreleasedReturnValue(v3);
  (*(void (**)(uint64_t))(*(void *)a2 + 32LL))(a2);
}

void sub_1005AF0F0( _Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, id a10)
{
}

void sub_1005AF104(uint64_t a1, uint64_t a2)
{
}

uint64_t sub_1005AF114(uint64_t a1, unint64_t a2, int a3, __int16 a4, __int16 a5, __int16 a6)
{
  v55[1] = 0LL;
  unint64_t v56 = a2;
  v55[0] = 0LL;
  sub_100242F28((uint64_t)v55, a1 + 120);
  memset(uu, 0, sizeof(uu));
  uuid_clear(uu);
  char v13 = *(const unsigned __int8 **)(a1 + 384);
  if (v13 != (const unsigned __int8 *)(a1 + 392))
  {
    while (*((void *)v13 + 6) != a2)
    {
      uint64_t v14 = (unsigned __int8 *)*((void *)v13 + 1);
      if (v14)
      {
        do
        {
          unint64_t v15 = (const unsigned __int8 **)v14;
          uint64_t v14 = *(unsigned __int8 **)v14;
        }

        while (v14);
      }

      else
      {
        do
        {
          unint64_t v15 = (const unsigned __int8 **)*((void *)v13 + 2);
          BOOL v16 = *v15 == v13;
          char v13 = (const unsigned __int8 *)v15;
        }

        while (!v16);
      }

      char v13 = (const unsigned __int8 *)v15;
    }

    uuid_copy(uu, v13 + 32);
  }

void sub_1005AF7E4(_Unwind_Exception *a1, uint64_t a2, ...)
{
}

void sub_1005AF81C(uint64_t a1, uint64_t a2)
{
  uint64_t v3 = (uint64_t *)a1;
  id v4 = *(uint64_t ***)(a1 + 32);
  uint64_t v5 = sub_100241F94((const unsigned __int8 *)(a1 + 48));
  __int16 v6 = (void *)objc_claimAutoreleasedReturnValue(v5);
  v4 += 66;
  v3 += 5;
  uint64_t v12 = v3;
  uint64_t v7 = *((unsigned __int16 *)sub_1005BC978(v4, (unint64_t *)v3, (uint64_t)&unk_1006C2518, &v12) + 20);
  uint64_t v12 = v3;
  uint64_t v8 = *((unsigned __int16 *)sub_1005BC978(v4, (unint64_t *)v3, (uint64_t)&unk_1006C2518, &v12) + 21);
  uint64_t v12 = v3;
  uint64_t v9 = *((unsigned __int16 *)sub_1005BC978(v4, (unint64_t *)v3, (uint64_t)&unk_1006C2518, &v12) + 22);
  uint64_t v12 = v3;
  uint64_t v10 = *((unsigned __int16 *)sub_1005BC978(v4, (unint64_t *)v3, (uint64_t)&unk_1006C2518, &v12) + 23);
  uint64_t v12 = v3;
  int v11 = sub_1005BC978(v4, (unint64_t *)v3, (uint64_t)&unk_1006C2518, &v12);
  (*(void (**)(uint64_t, void *, uint64_t, uint64_t, uint64_t, uint64_t, void))(*(void *)a2 + 32LL))( a2,  v6,  v7,  v8,  v9,  v10,  *((unsigned __int16 *)v11 + 24));
}

void sub_1005AF954(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

uint64_t sub_1005AF964(uint64_t a1, unint64_t a2, int a3, int a4, char a5, int a6)
{
  v75[1] = 0LL;
  unint64_t v76 = a2;
  v75[0] = 0LL;
  sub_100242F28((uint64_t)v75, a1 + 120);
  memset(uu, 0, sizeof(uu));
  uuid_clear(uu);
  uint64_t v12 = *(const unsigned __int8 **)(a1 + 384);
  if (v12 != (const unsigned __int8 *)(a1 + 392))
  {
    while (*((void *)v12 + 6) != a2)
    {
      char v13 = (unsigned __int8 *)*((void *)v12 + 1);
      if (v13)
      {
        do
        {
          uint64_t v14 = (const unsigned __int8 **)v13;
          char v13 = *(unsigned __int8 **)v13;
        }

        while (v13);
      }

      else
      {
        do
        {
          uint64_t v14 = (const unsigned __int8 **)*((void *)v12 + 2);
          BOOL v15 = *v14 == v12;
          uint64_t v12 = (const unsigned __int8 *)v14;
        }

        while (!v15);
      }

      uint64_t v12 = (const unsigned __int8 *)v14;
    }

    uuid_copy(uu, v12 + 32);
  }

void sub_1005B019C( _Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, void *__p, uint64_t a14, int a15, __int16 a16, char a17, char a18, char a19, uint64_t a20, uint64_t a21, uint64_t a22, uint64_t a23, uint64_t a24, uint64_t a25, uint64_t a26, uint64_t a27, uint64_t a28, uint64_t a29, uint64_t a30, uint64_t a31, uint64_t a32, uint64_t a33, char a34)
{
}

uint64_t sub_1005B0278(uint64_t a1, unsigned __int8 *a2)
{
  uint64_t v5 = 0LL;
  uint64_t result = sub_100599890(a1, a2, &v5);
  if ((_DWORD)result)
  {
    char v4 = 0;
    uint64_t v3 = sub_1002E6E9C();
    return (*(uint64_t (**)(uint64_t, void, uint64_t, void, char *, uint64_t))(*(void *)v3 + 1752LL))( v3,  *v5,  1LL,  0LL,  &v4,  33LL);
  }

  return result;
}

void sub_1005B02CC(uint64_t a1, uint64_t a2)
{
  uint64_t v3 = (const unsigned __int8 *)(a1 + 46);
  char v4 = sub_100241F94((const unsigned __int8 *)(a1 + 46));
  id v6 = (id)objc_claimAutoreleasedReturnValue(v4);
  (**(void (***)(uint64_t))a2)(a2);

  uint64_t v5 = sub_100241F94(v3);
  id v7 = (id)objc_claimAutoreleasedReturnValue(v5);
  (*(void (**)(uint64_t))(*(void *)a2 + 32LL))(a2);
}

void sub_1005B036C( _Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, void *a10)
{
}

void sub_1005B0384(uint64_t a1, uint64_t a2)
{
}

uint64_t sub_1005B0394( uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, int a7, uint64_t a8)
{
  v21[0] = 0LL;
  v21[1] = 0LL;
  sub_100242F28((uint64_t)v21, a1 + 120);
  memset(uu, 0, sizeof(uu));
  uuid_clear(uu);
  BOOL v16 = *(const unsigned __int8 **)(a1 + 384);
  if (v16 != (const unsigned __int8 *)(a1 + 392))
  {
    while (*((void *)v16 + 6) != a2)
    {
      __int16 v17 = (unsigned __int8 *)*((void *)v16 + 1);
      if (v17)
      {
        do
        {
          unint64_t v18 = (const unsigned __int8 **)v17;
          __int16 v17 = *(unsigned __int8 **)v17;
        }

        while (v17);
      }

      else
      {
        do
        {
          unint64_t v18 = (const unsigned __int8 **)*((void *)v16 + 2);
          BOOL v19 = *v18 == v16;
          BOOL v16 = (const unsigned __int8 *)v18;
        }

        while (!v19);
      }

      BOOL v16 = (const unsigned __int8 *)v18;
    }

    uuid_copy(uu, v16 + 32);
  }

void sub_1005B0540(_Unwind_Exception *a1, uint64_t a2, ...)
{
}

void sub_1005B0564(uint64_t a1, uint64_t a2)
{
  uint64_t v3 = *(void *)(a1 + 32);
  char v4 = sub_100241F94((const unsigned __int8 *)(a1 + 76));
  id v5 = (id)objc_claimAutoreleasedReturnValue(v4);
  (*(void (**)(uint64_t, uint64_t))(*(void *)a2 + 40LL))(a2, v3);
}

void sub_1005B05D0( _Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, id a10)
{
}

void sub_1005B05E4(uint64_t a1, uint64_t a2)
{
}

uint64_t sub_1005B05F4(uint64_t a1)
{
  v5[0] = 0LL;
  v5[1] = 0LL;
  sub_100242F28((uint64_t)v5, a1 + 120);
  uint64_t v2 = (os_log_s *)qword_1008F7620;
  if (os_log_type_enabled((os_log_t)qword_1008F7620, OS_LOG_TYPE_DEFAULT))
  {
    *(_WORD *)char v4 = 0;
    _os_log_impl((void *)&_mh_execute_header, v2, OS_LOG_TYPE_DEFAULT, "All devices have been disconnected", v4, 2u);
  }

  *(_BYTE *)(a1 + 1008) = 0;
  sub_1002431AC((pthread_cond_t *)(a1 + 960));
  return sub_100242FAC((uint64_t)v5);
}

void sub_1005B0680(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, ...)
{
}

uint64_t sub_1005B0694(uint64_t a1)
{
  v34[0] = 0LL;
  v34[1] = 0LL;
  sub_100242F28((uint64_t)v34, a1 + 120);
  __int128 v32 = 0u;
  __int128 v33 = 0u;
  __int128 v30 = 0u;
  __int128 v31 = 0u;
  id v2 = sub_10059A34C(a1);
  uint64_t v3 = (void *)objc_claimAutoreleasedReturnValue(v2);
  id v4 = [v3 countByEnumeratingWithState:&v30 objects:v43 count:16];
  if (v4)
  {
    uint64_t v23 = *(void *)v31;
    uint64_t v5 = a1 + 384;
    uint64_t v6 = a1 + 392;
    int v22 = v3;
LABEL_3:
    uint64_t v7 = 0LL;
    while (1)
    {
      if (*(void *)v31 != v23) {
        objc_enumerationMutation(v3);
      }
      uint64_t v8 = *(void *)(*((void *)&v30 + 1) + 8 * v7);
      sub_100241F90(buf, v8);
      uint64_t v9 = sub_1001FDB10(v5, buf);
      if (v6 == v9) {
        break;
      }
      uint64_t v10 = *(void *)(v9 + 48);
      char v29 = 0;
      sub_100242CA4(&v29);
      BOOL v11 = sub_10012D5EC(v10);
      unsigned __int16 v28 = 0;
      sub_1001B998C(v10, &v28);
      int v12 = sub_1001B9BE0(v10);
      sub_100242CD0(&v29);
      if (v11)
      {
        int v13 = v28;
        if (v28 >= 0x308u) {
          double v14 = 0.35;
        }
        else {
          double v14 = 0.75;
        }
        unsigned int v15 = (int)(v14 * (double)(10 * v12) / ((double)v28 * 1.25));
        BOOL v16 = (os_log_s *)qword_1008F7620;
        if (os_log_type_enabled((os_log_t)qword_1008F7620, OS_LOG_TYPE_DEFAULT))
        {
          *(_DWORD *)int buf = 138544130;
          uint64_t v36 = v8;
          __int16 v37 = 1024;
          unsigned int v38 = v15;
          __int16 v39 = 1024;
          int v40 = v13;
          __int16 v41 = 1024;
          int v42 = v12;
          _os_log_impl( (void *)&_mh_execute_header,  v16,  OS_LOG_TYPE_DEFAULT,  "setVoicePrioritizationThreshold: setting LE device %{public}@ connection threshold to %d events with int erval %d, LSTO %d",  buf,  0x1Eu);
        }

        uint64_t v3 = v22;
        uint64_t v17 = sub_1002E6E9C();
        if (v15 >= 0xFF) {
          uint64_t v18 = 255LL;
        }
        else {
          uint64_t v18 = v15;
        }
        if ((*(unsigned int (**)(uint64_t, uint64_t, uint64_t))(*(void *)v17 + 1056LL))(v17, v10, v18))
        {
          BOOL v19 = (os_log_s *)qword_1008F7620;
          if (os_log_type_enabled((os_log_t)qword_1008F7620, OS_LOG_TYPE_ERROR)) {
            sub_100699E10(&v26, v27, v19);
          }
        }
      }

      else
      {
        unint64_t v20 = (os_log_s *)qword_1008F7620;
        if (os_log_type_enabled((os_log_t)qword_1008F7620, OS_LOG_TYPE_ERROR)) {
          sub_100699E44(&v24, v25, v20);
        }
      }

      sub_100242CD8(&v29);
      if (v4 == (id)++v7)
      {
        id v4 = [v3 countByEnumeratingWithState:&v30 objects:v43 count:16];
        if (v4) {
          goto LABEL_3;
        }
        break;
      }
    }
  }

  return sub_100242FAC((uint64_t)v34);
}

void sub_1005B0984( _Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20, uint64_t a21, uint64_t a22, uint64_t a23, uint64_t a24, uint64_t a25, uint64_t a26, uint64_t a27, uint64_t a28, char a29)
{
  sub_100242FAC((uint64_t)&a29);
  _Unwind_Resume(a1);
}

uint64_t sub_1005B09DC( uint64_t result, unsigned __int8 *a2, int a3, int a4, uint64_t a5, __int16 a6, unsigned int a7, float a8, float a9, float a10)
{
  if (a8 != 0.0)
  {
    unsigned int v10 = a7;
    if (a10 != 0.0 && a7 != 0)
    {
      uint64_t v20 = result;
      v77[0] = 0LL;
      v77[1] = 0LL;
      sub_100242F28((uint64_t)v77, result + 120);
      *(void *)int buf = a2;
      unsigned int v21 = *((unsigned __int16 *)sub_1005BE1B4( (uint64_t **)(v20 + 840),  a2,  (uint64_t)&unk_1006C2518,  (const unsigned __int8 *__attribute__((__org_typedef(uuid_t))) *)buf)
            + 29);
      uint64_t v22 = sub_1001FDB10(v20 + 384, a2);
      if (v20 + 392 != v22)
      {
        uint64_t v64 = *(void *)(v22 + 48);
        if (v20 + 848 == sub_1005BD2B0(v20 + 840, a2)) {
          unsigned int v21 = 0;
        }
        *(void *)int buf = a2;
        uint64_t v23 = sub_1005BE1B4( (uint64_t **)(v20 + 840),  a2,  (uint64_t)&unk_1006C2518,  (const unsigned __int8 *__attribute__((__org_typedef(uuid_t))) *)buf);
        *(uint64_t *)((char *)v23 + 44) = 0x5010100000002LL;
        *((_WORD *)v23 + 26) = (int)a9;
        *((_WORD *)v23 + 27) = a3;
        *((_WORD *)v23 + 28) = a4;
        *((_WORD *)v23 + 29) = a5;
        *((_WORD *)v23 + 30) = a6;
        *((_WORD *)v23 + 31) = v10;
        *((float *)v23 + 16) = a8;
        *((float *)v23 + 17) = a9;
        *((float *)v23 + 18) = a10;
        *((_DWORD *)v23 + 19) = 0;
        if (qword_1008D5F30 != -1) {
          dispatch_once(&qword_1008D5F30, &stru_1008A2B30);
        }
        uint8_t v24 = off_1008D5F28;
        int v25 = sub_100241F94(a2);
        uint8_t v26 = (void *)objc_claimAutoreleasedReturnValue(v25);
        sub_10002418C(v75, "A2051");
        if ((sub_1005CE5A8((uint64_t)v24, v26, (uint64_t)v75) & 1) != 0)
        {
          int v27 = 1;
        }

        else
        {
          if (qword_1008D5F30 != -1) {
            dispatch_once(&qword_1008D5F30, &stru_1008A2B30);
          }
          unsigned __int16 v28 = off_1008D5F28;
          char v29 = sub_100241F94(a2);
          __int128 v30 = (void *)objc_claimAutoreleasedReturnValue(v29);
          sub_10002418C(v73, "A1603");
          if ((sub_1005CE5A8((uint64_t)v28, v30, (uint64_t)v73) & 1) != 0)
          {
            int v27 = 1;
          }

          else
          {
            if (qword_1008D5F30 != -1) {
              dispatch_once(&qword_1008D5F30, &stru_1008A2B30);
            }
            __int128 v31 = off_1008D5F28;
            __int128 v32 = sub_100241F94(a2);
            __int16 v63 = (void *)objc_claimAutoreleasedReturnValue(v32);
            sub_10002418C(v71, "A3085");
            if ((sub_1005CE5A8((uint64_t)v31, v63, (uint64_t)v71) & 1) != 0)
            {
              int v27 = 1;
            }

            else
            {
              if (qword_1008D5F30 != -1) {
                dispatch_once(&qword_1008D5F30, &stru_1008A2B30);
              }
              __int128 v33 = off_1008D5F28;
              unint64_t v34 = sub_100241F94(a2);
              BOOL v35 = (void *)objc_claimAutoreleasedReturnValue(v34);
              sub_10002418C(__p, "A2538");
              int v27 = sub_1005CE5A8((uint64_t)v33, v35, (uint64_t)__p);
              if (v70 < 0) {
                operator delete(__p[0]);
              }
            }

            if (v72 < 0) {
              operator delete(v71[0]);
            }
          }

          if (v74 < 0) {
            operator delete(v73[0]);
          }
        }

        if (v76 < 0) {
          operator delete(v75[0]);
        }

        if (v27 && v21 != (_DWORD)a5)
        {
          uint64_t v36 = sub_1002E6E9C();
          __int16 v37 = sub_100241F94(a2);
          unsigned int v38 = (void *)objc_claimAutoreleasedReturnValue(v37);
          unsigned __int8 v39 = v21 + 2;
          if (v21 <= 5) {
            unsigned __int8 v39 = 6;
          }
          (*(void (**)(uint64_t, void *, void))(*(void *)v36 + 992LL))(v36, v38, v39);
        }

        if (qword_1008D5F30 != -1) {
          dispatch_once(&qword_1008D5F30, &stru_1008A2B30);
        }
        int v40 = off_1008D5F28;
        __int16 v41 = sub_100241F94(a2);
        int v42 = (void *)objc_claimAutoreleasedReturnValue(v41);
        sub_10002418C(v67, "BluetoothTVRemote");
        char v43 = sub_1005CE5A8((uint64_t)v40, v42, (uint64_t)v67);
        if (v68 < 0) {
          operator delete(v67[0]);
        }

        if ((v43 & 1) != 0)
        {
          a4 = 6;
          a3 = 6;
        }

        else
        {
          uint64_t v44 = sub_100241F94(a2);
          int v45 = (void *)objc_claimAutoreleasedReturnValue(v44);
          BOOL v46 = sub_1005B124C(v45);

          if (v46)
          {
            if (qword_1008D6198 != -1) {
              dispatch_once(&qword_1008D6198, &stru_1008A2B70);
            }
            if (*((_BYTE *)off_1008D6190 + 198)) {
              a4 = 4;
            }
            else {
              a4 = 6;
            }
            a3 = 2;
          }
        }

        if (qword_1008D5F30 != -1) {
          dispatch_once(&qword_1008D5F30, &stru_1008A2B30);
        }
        uint64_t v47 = off_1008D5F28;
        unint64_t v48 = sub_100241F94(a2);
        BOOL v49 = (void *)objc_claimAutoreleasedReturnValue(v48);
        sub_10002418C(v65, "requiresCTOFix");
        int v50 = sub_1005CE5A8((uint64_t)v47, v49, (uint64_t)v65);
        if (v66 < 0) {
          operator delete(v65[0]);
        }

        if (v50) {
          unsigned int v10 = 3000;
        }
        uint64_t v51 = (os_log_s *)qword_1008F7620;
        if (os_log_type_enabled((os_log_t)qword_1008F7620, OS_LOG_TYPE_DEFAULT))
        {
          *(_DWORD *)int buf = 67110400;
          *(_DWORD *)&uint8_t buf[4] = (int)a8;
          __int16 v79 = 1024;
          int v80 = (int)a10;
          __int16 v81 = 1024;
          int v82 = a3;
          __int16 v83 = 1024;
          int v84 = a4;
          __int16 v85 = 1024;
          int v86 = a5;
          __int16 v87 = 1024;
          unsigned int v88 = v10;
          _os_log_impl( (void *)&_mh_execute_header,  v51,  OS_LOG_TYPE_DEFAULT,  "Got a profile request to update parameters to %dms->%dms, %d min CE length, %d max CE length, %d latency, and %d timeout",  buf,  0x26u);
        }

        buf[0] = 0;
        sub_100242CA4(buf);
        uint64_t v52 = v64;
        float v53 = (double)v10 / 10.0;
        LODWORD(v54) = vcvtps_s32_f32(v53);
        int v55 = sub_1001BD58C(v64, (int)(a8 / 1.25), (int)(a9 / 1.25), a5, v54, a3, a4);
        sub_100242CD0(buf);
        if (v55 && os_log_type_enabled((os_log_t)qword_1008F7620, OS_LOG_TYPE_ERROR))
        {
          sub_100699E78();
          uint64_t v52 = v64;
        }

        uint64_t v56 = sub_1002E6E9C();
        (*(void (**)(uint64_t, uint64_t, uint64_t, void))(*(void *)v56 + 1048LL))(v56, v52, 1LL, 0LL);
        if (qword_1008D5F30 != -1) {
          dispatch_once(&qword_1008D5F30, &stru_1008A2B30);
        }
        uint64_t v57 = off_1008D5F28;
        unint64_t v58 = sub_100241F94(a2);
        BOOL v59 = (void *)objc_claimAutoreleasedReturnValue(v58);
        sub_1005D27F0((uint64_t)v57, v59, 1);

        if (qword_1008D5F30 != -1) {
          dispatch_once(&qword_1008D5F30, &stru_1008A2B30);
        }
        uint64_t v60 = off_1008D5F28;
        unint64_t v61 = sub_100241F94(a2);
        int v62 = (void *)objc_claimAutoreleasedReturnValue(v61);
        sub_1005D2908((uint64_t)v60, v62, (int)a9);

        sub_100242CD8(buf);
      }

      return sub_100242FAC((uint64_t)v77);
    }
  }

  return result;
}

void sub_1005B1104( _Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, void *a9, uint64_t a10, uint64_t a11, void *a12, uint64_t a13, int a14, __int16 a15, char a16, char a17, void *a18, uint64_t a19, int a20, __int16 a21, char a22, char a23, void *__p, uint64_t a25, int a26, __int16 a27, char a28, char a29, void *a30, uint64_t a31, int a32, __int16 a33, char a34, char a35, void *a36, uint64_t a37, int a38, __int16 a39, char a40, char a41, void *a42, uint64_t a43, int a44, __int16 a45, char a46, char a47, char a48)
{
  if (a29 < 0) {
    operator delete(__p);
  }

  if (a35 < 0) {
    operator delete(a30);
  }

  if (a41 < 0) {
    operator delete(a36);
  }

  if (a47 < 0) {
    operator delete(a42);
  }

  sub_100242FAC((uint64_t)&a48);
  _Unwind_Resume(a1);
}

BOOL sub_1005B124C(void *a1)
{
  id v1 = a1;
  uint64_t v2 = sub_1002E6E9C();
  if ((*(unsigned int (**)(uint64_t))(*(void *)v2 + 2688LL))(v2))
  {
    if (qword_1008D5F30 != -1) {
      dispatch_once(&qword_1008D5F30, &stru_1008A2B30);
    }
    BOOL v3 = sub_1005D4FEC((uint64_t)off_1008D5F28, v1);
  }

  else
  {
    BOOL v3 = 0LL;
  }

  return v3;
}

void sub_1005B12CC(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

uint64_t sub_1005B12DC( uint64_t a1, unsigned __int8 *a2, _WORD *a3, _WORD *a4, _WORD *a5, _WORD *a6, _WORD *a7)
{
  if (sub_1005996B4(a1, a2))
  {
    *(void *)uuid_string_t out = 0LL;
    if (sub_100599890(a1, a2, out))
    {
      LOBYTE(__p[0]) = 0;
      sub_100242CA4(__p);
      sub_1001AF7E4(*(_WORD **)out, a3, a4, a5, a6, a7, 0LL, 0LL);
      sub_100242CD0(__p);
      sub_100242CD8(__p);
      return 0LL;
    }

    else
    {
      return 7LL;
    }
  }

  else
  {
    unsigned int v15 = (os_log_s *)qword_1008F7620;
    if (os_log_type_enabled((os_log_t)qword_1008F7620, OS_LOG_TYPE_ERROR))
    {
      memset(out, 0, 37);
      uuid_unparse_upper(a2, (char *)out);
      sub_10002418C(__p, (char *)out);
      if (v18 >= 0) {
        BOOL v16 = __p;
      }
      else {
        BOOL v16 = (void **)__p[0];
      }
      *(_DWORD *)uuid_string_t out = 136446210;
      *(void *)&out[4] = v16;
      _os_log_error_impl( (void *)&_mh_execute_header,  v15,  OS_LOG_TYPE_ERROR,  "Device %{public}s is not ready, cannot get connection parameters",  out,  0xCu);
      if (v18 < 0) {
        operator delete(__p[0]);
      }
    }

    return 12LL;
  }

void sub_1005B146C(_Unwind_Exception *a1, uint64_t a2, ...)
{
}

uint64_t sub_1005B1488(uint64_t a1)
{
  if (qword_1008D5F10 != -1) {
    dispatch_once(&qword_1008D5F10, &stru_1008A2B10);
  }
  return sub_1005B1504( (uint64_t)off_1008D5F08,  *(__int128 **)(a1 + 32),  *(unsigned __int8 *)(a1 + 52),  *(_WORD *)(a1 + 44),  *(_WORD *)(a1 + 46),  *(unsigned __int16 *)(a1 + 48),  *(unsigned __int16 *)(a1 + 50),  *(_DWORD *)(a1 + 40),  *(_WORD *)(a1 + 53),  HIBYTE(*(_WORD *)(a1 + 53)));
}

uint64_t sub_1005B1504( uint64_t a1, __int128 *a2, unsigned int a3, unsigned __int16 a4, unsigned __int16 a5, unsigned int a6, int a7, unsigned int a8, unsigned __int8 a9, unsigned __int8 a10)
{
  unsigned __int16 v75 = a4;
  unsigned __int16 v74 = a5;
  char v73 = 0;
  unsigned __int16 v72 = 10;
  v71[0] = 0LL;
  v71[1] = 0LL;
  sub_100242F28((uint64_t)v71, a1 + 120);
  memset(uu, 0, sizeof(uu));
  uuid_clear(uu);
  if (byte_1008F1CF0)
  {
    int v14 = 1;
  }

  else
  {
    uint64_t v30 = sub_1002E6E00();
    sub_10002418C(buf, "LE");
    sub_10002418C(v69, "DisableConnectionParameterUpdates");
    (*(void (**)(uint64_t, _BYTE *, void **, char *))(*(void *)v30 + 72LL))(v30, buf, v69, &v73);
    if (v70 < 0) {
      operator delete(v69[0]);
    }
    if (SHIBYTE(v80) < 0) {
      operator delete(*(void **)buf);
    }
    if (v73)
    {
      __int128 v31 = (os_log_s *)qword_1008F7620;
      int v14 = 0;
      if (os_log_type_enabled((os_log_t)qword_1008F7620, OS_LOG_TYPE_DEFAULT))
      {
        *(_WORD *)int buf = 0;
        _os_log_impl( (void *)&_mh_execute_header,  v31,  OS_LOG_TYPE_DEFAULT,  "Warning: Rejecting parameter updates due to override",  buf,  2u);
        int v14 = 0;
      }
    }

    else
    {
      if (sub_100593548(a1, (uint64_t)a2, uu))
      {
        uint64_t v35 = sub_1005BD2B0(a1 + 840, uu);
        if (a1 + 848 == v35) {
          uint64_t v36 = 0LL;
        }
        else {
          uint64_t v36 = v35 + 44;
        }
      }

      else
      {
        uint64_t v36 = 0LL;
      }

      int v55 = sub_100241F94(uu);
      uint64_t v56 = (void *)objc_claimAutoreleasedReturnValue(v55);
      int v14 = sub_1005B1D10((uint64_t)v56, &v75, &v74, a6, a7, v36, &v72, a9, v56);
    }
  }

  if (sub_100599CBC(a1, uu))
  {
    int v15 = 0;
LABEL_5:
    int v16 = 6;
LABEL_6:
    unsigned __int16 v72 = v16;
    goto LABEL_7;
  }

  if (qword_1008D5F30 != -1) {
    dispatch_once(&qword_1008D5F30, &stru_1008A2B30);
  }
  uint64_t v22 = off_1008D5F28;
  uint64_t v23 = sub_100241F94(uu);
  uint8_t v24 = (void *)objc_claimAutoreleasedReturnValue(v23);
  sub_10002418C(__p, "FastConnection");
  int v25 = sub_1005CE5A8((uint64_t)v22, v24, (uint64_t)__p);
  if (v68 < 0) {
    operator delete(__p[0]);
  }

  if (v25)
  {
    if (qword_1008D5F30 != -1) {
      dispatch_once(&qword_1008D5F30, &stru_1008A2B30);
    }
    uint8_t v26 = off_1008D5F28;
    int v27 = sub_100241F94(uu);
    unsigned __int16 v28 = (void *)objc_claimAutoreleasedReturnValue(v27);
    sub_10002418C(v65, "A2051");
    if ((sub_1005CE5A8((uint64_t)v26, v28, (uint64_t)v65) & 1) != 0)
    {
      int v29 = 1;
    }

    else
    {
      if (qword_1008D5F30 != -1) {
        dispatch_once(&qword_1008D5F30, &stru_1008A2B30);
      }
      __int16 v37 = off_1008D5F28;
      unsigned int v38 = sub_100241F94(uu);
      unsigned __int8 v39 = (void *)objc_claimAutoreleasedReturnValue(v38);
      sub_10002418C(v63, "A2538");
      int v29 = sub_1005CE5A8((uint64_t)v37, v39, (uint64_t)v63);
      if (v64 < 0) {
        operator delete(v63[0]);
      }
    }

    if (v66 < 0) {
      operator delete(v65[0]);
    }

    if (v29)
    {
      if (qword_1008D5F30 != -1) {
        dispatch_once(&qword_1008D5F30, &stru_1008A2B30);
      }
      int v40 = off_1008D5F28;
      __int16 v41 = sub_100241F94(uu);
      int v42 = (void *)objc_claimAutoreleasedReturnValue(v41);
      int v15 = sub_1005D2990((uint64_t)v40, v42);

      if (v15)
      {
        unsigned __int16 v75 = v15;
        unsigned __int16 v74 = v15;
      }
    }

    else
    {
      int v15 = 0;
    }

    if (qword_1008D5F30 != -1) {
      dispatch_once(&qword_1008D5F30, &stru_1008A2B30);
    }
    uint64_t v51 = off_1008D5F28;
    uint64_t v52 = sub_100241F94(uu);
    float v53 = (void *)objc_claimAutoreleasedReturnValue(v52);
    sub_10002418C(v61, "BluetoothTVRemote");
    int v54 = sub_1005CE5A8((uint64_t)v51, v53, (uint64_t)v61);
    if (v62 < 0) {
      operator delete(v61[0]);
    }

    if (!v54)
    {
      int v16 = 4;
      goto LABEL_6;
    }

    goto LABEL_5;
  }

  if (qword_1008D5F30 != -1) {
    dispatch_once(&qword_1008D5F30, &stru_1008A2B30);
  }
  __int128 v32 = off_1008D5F28;
  __int128 v33 = sub_100241F94(uu);
  unint64_t v34 = (void *)objc_claimAutoreleasedReturnValue(v33);
  LODWORD(v32) = sub_1005CE518((uint64_t)v32, v34);

  if ((_DWORD)v32)
  {
    int v15 = 0;
    int v16 = 12;
    goto LABEL_6;
  }

  if (qword_1008D5F30 != -1) {
    dispatch_once(&qword_1008D5F30, &stru_1008A2B30);
  }
  char v43 = off_1008D5F28;
  uint64_t v44 = sub_100241F94(uu);
  int v45 = (void *)objc_claimAutoreleasedReturnValue(v44);
  sub_10002418C(v59, "_HID_DEVICE_");
  int v46 = sub_1005CE5A8((uint64_t)v43, v45, (uint64_t)v59);
  if (v60 < 0) {
    operator delete(v59[0]);
  }

  if (v46
    && (uint64_t v47 = sub_100241F94(uu),
        unint64_t v48 = (void *)objc_claimAutoreleasedReturnValue(v47),
        BOOL v49 = sub_1005B124C(v48),
        v48,
        v49))
  {
    if (qword_1008D6198 != -1) {
      dispatch_once(&qword_1008D6198, &stru_1008A2B70);
    }
    int v15 = 0;
    if (*((_BYTE *)off_1008D6190 + 198)) {
      unsigned __int16 v50 = 4;
    }
    else {
      unsigned __int16 v50 = 6;
    }
    unsigned __int16 v72 = v50;
  }

  else
  {
    int v15 = 0;
  }

  int v16 = 2;
LABEL_7:
  uint64_t v17 = (os_log_s *)qword_1008F7620;
  if (os_log_type_enabled((os_log_t)qword_1008F7620, OS_LOG_TYPE_DEFAULT))
  {
    char v18 = "Rejecting";
    if (v14) {
      char v18 = "Accepting";
    }
    *(_DWORD *)int buf = 136447746;
    *(void *)&uint8_t buf[4] = v18;
    __int16 v77 = 1024;
    int v78 = v75;
    __int16 v79 = 1024;
    int v80 = v74;
    __int16 v81 = 1024;
    unsigned int v82 = a6;
    __int16 v83 = 1024;
    int v84 = a7;
    __int16 v85 = 1024;
    int v86 = v72;
    __int16 v87 = 1024;
    int v88 = v15;
    _os_log_impl( (void *)&_mh_execute_header,  v17,  OS_LOG_TYPE_DEFAULT,  "%{public}s following parameters: min=%u, max=%u, lat=%u, mul=%u, cel=%u, preferredLowLatencyInterval=%d",  buf,  0x30u);
  }

  buf[0] = 0;
  sub_100242CA4(buf);
  sub_1001B9C50(a2, a3, v14, v75, v74, a6, a7, v16, v72, a8);
  BOOL v19 = sub_100241F94(uu);
  uint64_t v20 = (void *)objc_claimAutoreleasedReturnValue(v19);
  sub_1005A2C94((uint64_t)v20, v20, 4u, a9 == 1, a10);

  sub_100242CD8(buf);
  return sub_100242FAC((uint64_t)v71);
}

void sub_1005B1BC4( _Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, void *__p, uint64_t a13, int a14, __int16 a15, char a16, char a17, void *a18, uint64_t a19, int a20, __int16 a21, char a22, char a23, void *a24, uint64_t a25, int a26, __int16 a27, char a28, char a29, void *a30, uint64_t a31, int a32, __int16 a33, char a34, char a35, void *a36, uint64_t a37, int a38, __int16 a39, char a40, char a41, void *a42, uint64_t a43, int a44, __int16 a45, char a46, char a47, char a48)
{
  sub_100242FAC((uint64_t)&a48);
  _Unwind_Resume(a1);
}

uint64_t sub_1005B1D10( uint64_t a1, unsigned __int16 *a2, _WORD *a3, unsigned int a4, __int16 a5, uint64_t a6, _WORD *a7, int a8, void *a9)
{
  id v16 = a9;
  unsigned int v17 = *a2;
  if ((unsigned __int16)(v17 - 3201) > 0xF384u)
  {
    unsigned int v18 = (unsigned __int16)*a3;
    if ((unsigned __int16)(v18 - 3201) > 0xF384u)
    {
      if (v17 <= v18)
      {
        if (a4 < 0x1F5)
        {
          if ((unsigned __int16)(a5 - 3201) > 0xF388u)
          {
            float v19 = (double)v17 * 1.25;
            float v20 = (double)v18 * 1.25;
            if (!a6)
            {
              if (v19 < 30.0)
              {
                unsigned int v21 = (os_log_s *)qword_1008F7620;
                BOOL v22 = os_log_type_enabled((os_log_t)qword_1008F7620, OS_LOG_TYPE_DEFAULT);
                if (a8)
                {
                  if (v22)
                  {
                    int v46 = 134218240;
                    *(double *)uint64_t v47 = v19;
                    *(_WORD *)&v47[8] = 1024;
                    *(_DWORD *)unint64_t v48 = 30;
                    _os_log_impl( (void *)&_mh_execute_header,  v21,  OS_LOG_TYPE_DEFAULT,  "Remote side (central) wants a min interval (%.0f ms) smaller than %d ms.",  (uint8_t *)&v46,  0x12u);
                  }
                }

                else
                {
                  if (v22)
                  {
                    int v46 = 134218240;
                    *(double *)uint64_t v47 = v19;
                    *(_WORD *)&v47[8] = 1024;
                    *(_DWORD *)unint64_t v48 = 30;
                    _os_log_impl( (void *)&_mh_execute_header,  v21,  OS_LOG_TYPE_DEFAULT,  "Remote side (peripheral) wants a min interval (%.0f ms) smaller than %d ms. Scaling up",  (uint8_t *)&v46,  0x12u);
                  }

                  *a2 = 24;
                  float v19 = 30.0;
                }
              }

              float v23 = 7.5;
              if (!a8) {
                float v23 = 30.0;
              }
              if ((v23 != v20 || v19 != v23) && (float)(v20 - v19) < 15.0)
              {
                uint8_t v26 = (os_log_s *)qword_1008F7620;
                if (os_log_type_enabled((os_log_t)qword_1008F7620, OS_LOG_TYPE_DEFAULT))
                {
                  LOWORD(v46) = 0;
                  _os_log_impl( (void *)&_mh_execute_header,  v26,  OS_LOG_TYPE_DEFAULT,  "Intervals should be 15 ms apart - increasing the gap",  (uint8_t *)&v46,  2u);
                }

                float v20 = v19 + 15.0;
                *a3 = (int)((float)(v19 + 15.0) / 1.25);
              }
            }

            if (v20 <= 2000.0)
            {
              if ((float)(v20 * (float)(int)(a4 + 1)) <= 6000.0)
              {
                if (a4 < 0x1F || a6)
                {
                  unsigned int v35 = (unsigned __int16)(10 * a5);
                  if (v35 >= 0x4651)
                  {
                    uint64_t v36 = (os_log_s *)qword_1008F7620;
                    if (a8 != 1)
                    {
                      if (os_log_type_enabled((os_log_t)qword_1008F7620, OS_LOG_TYPE_ERROR)) {
                        sub_10069A1F8();
                      }
                      goto LABEL_60;
                    }

                    if (os_log_type_enabled((os_log_t)qword_1008F7620, OS_LOG_TYPE_DEFAULT))
                    {
                      int v46 = 67109376;
                      *(_DWORD *)uint64_t v47 = v35;
                      *(_WORD *)&v47[4] = 1024;
                      *(_DWORD *)&v47[6] = 18000;
                      _os_log_impl( (void *)&_mh_execute_header,  v36,  OS_LOG_TYPE_DEFAULT,  "Remote side (central) asks for a timeout (%u ms) of more than %d seconds.",  (uint8_t *)&v46,  0xEu);
                    }
                  }

                  if ((float)(v20 * (float)(int)(3 * (a4 + 1))) <= (float)v35)
                  {
                    if (a6)
                    {
                      float v38 = *(float *)(a6 + 20);
                      if (v19 < v38)
                      {
                        unsigned __int8 v39 = (os_log_s *)qword_1008F7620;
                        if (os_log_type_enabled((os_log_t)qword_1008F7620, OS_LOG_TYPE_ERROR)) {
                          sub_10069A17C(a2, v39, v40, v38);
                        }
                        goto LABEL_60;
                      }

                      float v43 = *(float *)(a6 + 24);
                      if (v19 <= v43)
                      {
                        int v44 = (int)(v43 / 1.25);
                        *a3 = v44;
                        int v45 = (os_log_s *)qword_1008F7620;
                        if (os_log_type_enabled((os_log_t)qword_1008F7620, OS_LOG_TYPE_INFO))
                        {
                          int v46 = 67109120;
                          *(_DWORD *)uint64_t v47 = v44;
                          _os_log_impl( (void *)&_mh_execute_header,  v45,  OS_LOG_TYPE_INFO,  "Using %u as the max interval",  (uint8_t *)&v46,  8u);
                        }
                      }

                      *a7 = *(_WORD *)(a6 + 12);
                    }

                    uint64_t v41 = 1LL;
                    goto LABEL_61;
                  }

                  __int16 v37 = (os_log_s *)qword_1008F7620;
                  if (os_log_type_enabled((os_log_t)qword_1008F7620, OS_LOG_TYPE_ERROR))
                  {
                    int v46 = 67109632;
                    *(_DWORD *)uint64_t v47 = v35;
                    *(_WORD *)&v47[4] = 1024;
                    *(_DWORD *)&v47[6] = a4;
                    *(_WORD *)unint64_t v48 = 2048;
                    *(double *)&v48[2] = v20;
                    _os_log_error_impl( (void *)&_mh_execute_header,  v37,  OS_LOG_TYPE_ERROR,  "Remote sides asks for a timeout (%u ms) / latency (%u) / maxInterval (%f ms) that would cause link timeouts under bad conditions - refusing",  (uint8_t *)&v46,  0x18u);
                  }
                }

                else
                {
                  int v27 = (os_log_s *)qword_1008F7620;
                  if (os_log_type_enabled((os_log_t)qword_1008F7620, OS_LOG_TYPE_ERROR)) {
                    sub_10069A110(v27, v28, v29, v30, v31, v32, v33, v34);
                  }
                }
              }

              else if (os_log_type_enabled((os_log_t)qword_1008F7620, OS_LOG_TYPE_ERROR))
              {
                sub_10069A0E4();
              }
            }

            else if (os_log_type_enabled((os_log_t)qword_1008F7620, OS_LOG_TYPE_ERROR))
            {
              sub_10069A0B8();
            }
          }

          else if (os_log_type_enabled((os_log_t)qword_1008F7620, OS_LOG_TYPE_ERROR))
          {
            sub_10069A058();
          }
        }

        else if (os_log_type_enabled((os_log_t)qword_1008F7620, OS_LOG_TYPE_ERROR))
        {
          sub_100699FF8();
        }
      }

      else if (os_log_type_enabled((os_log_t)qword_1008F7620, OS_LOG_TYPE_ERROR))
      {
        sub_100699F98();
      }
    }

    else if (os_log_type_enabled((os_log_t)qword_1008F7620, OS_LOG_TYPE_ERROR))
    {
      sub_100699F38();
    }
  }

  else if (os_log_type_enabled((os_log_t)qword_1008F7620, OS_LOG_TYPE_ERROR))
  {
    sub_100699ED8();
  }

void sub_1005B22EC(uint64_t a1, int a2, unsigned int a3, unsigned int a4, void *a5)
{
  if (a2 == 2)
  {
    uint64_t v9 = (os_log_s *)qword_1008F7620;
    if (os_log_type_enabled((os_log_t)qword_1008F7620, OS_LOG_TYPE_DEFAULT))
    {
      *(_DWORD *)int buf = 67109632;
      *(_DWORD *)&uint8_t buf[4] = 2;
      *(_WORD *)int v27 = 2048;
      *(double *)&v27[2] = (float)((float)a3 * 1.25);
      __int16 v28 = 2048;
      double v29 = (float)((float)a4 * 1.25);
      _os_log_impl( (void *)&_mh_execute_header,  v9,  OS_LOG_TYPE_DEFAULT,  "autoReconnect caused resuming, state=%d, scan=%g/%g (ms)",  buf,  0x1Cu);
    }

    int v12 = (void *)*a5;
    unsigned int v10 = a5 + 1;
    BOOL v11 = v12;
    if (v12 != v10)
    {
      do
      {
        unint64_t v13 = v11[4];
        *(void *)int buf = 0LL;
        *(void *)int v27 = 0LL;
        if (qword_1008D5F30 != -1) {
          dispatch_once(&qword_1008D5F30, &stru_1008A2B30);
        }
        sub_1005C8684((uint64_t)off_1008D5F28, v13, 0, 1u, 0LL, 0LL, buf);
        if (uuid_is_null(buf))
        {
          if (os_log_type_enabled((os_log_t)qword_1008F7620, OS_LOG_TYPE_ERROR)) {
            sub_10069A26C(&v24, v13, &v25);
          }
        }

        else if (a1 + 392 == sub_1001FDB10(a1 + 384, buf))
        {
          sub_100594980(a1, buf, v13);
        }

        else
        {
          unint64_t v17 = sub_1001BCDB0(v13);
          unint64_t v18 = (unint64_t)v17 << 48;
          if (BYTE6(v13) == 3LL) {
            unint64_t v18 = 0x1000000000000LL;
          }
          if (BYTE6(v13) == 2LL) {
            unint64_t v19 = 0LL;
          }
          else {
            unint64_t v19 = v18;
          }
          int v20 = sub_1005A10D0( v17,  v17 & 0xFF000000 | (unint64_t)BYTE6(v17) | ((unint64_t)BYTE2(v17) << 32) & 0xFFFF00FFFFFFFFFFLL | ((unint64_t)BYTE1(v17) << 40) | (v17 >> 16) & 0xFF0000 | HIDWORD(v17) & 0xFF00 | v19);
          unsigned int v21 = (os_log_s *)qword_1008F7620;
          if (os_log_type_enabled((os_log_t)qword_1008F7620, OS_LOG_TYPE_INFO))
          {
            *(_DWORD *)BOOL v22 = 67109120;
            int v23 = v20;
            _os_log_impl( (void *)&_mh_execute_header,  v21,  OS_LOG_TYPE_INFO,  "autoReconnect to a device already connected, removeAddressFromBTController returned %d",  v22,  8u);
          }
        }

        int v14 = (void *)v11[1];
        if (v14)
        {
          do
          {
            int v15 = v14;
            int v14 = (void *)*v14;
          }

          while (v14);
        }

        else
        {
          do
          {
            int v15 = (void *)v11[2];
            BOOL v16 = *v15 == (void)v11;
            BOOL v11 = v15;
          }

          while (!v16);
        }

        BOOL v11 = v15;
      }

      while (v15 != v10);
    }

    if (*(_DWORD *)(a1 + 864) == 4) {
      sub_1005B2610(a1);
    }
  }

  else if (a2 == 1)
  {
    sub_1005911F0(a1, 4u);
  }

uint64_t sub_1005B2610(uint64_t a1)
{
  uint64_t v2 = (os_log_s *)qword_1008F7620;
  if (os_log_type_enabled((os_log_t)qword_1008F7620, OS_LOG_TYPE_DEFAULT))
  {
    uint64_t v3 = *(int *)(a1 + 864);
    else {
      id v4 = (&off_1008A2DC0)[v3];
    }
    uint64_t v5 = *(int *)(a1 + 928);
    else {
      uint64_t v6 = (&off_1008A2DA0)[v5];
    }
    int v15 = 136446466;
    BOOL v16 = v4;
    __int16 v17 = 2082;
    unint64_t v18 = v6;
    _os_log_impl( (void *)&_mh_execute_header,  v2,  OS_LOG_TYPE_DEFAULT,  "resumeConnectionManager called, LeConnectionState=%{public}s LeConnectionManagerState=%{public}s",  (uint8_t *)&v15,  0x16u);
  }

  unsigned int v7 = *(_DWORD *)(a1 + 928);
  if (v7 < 2) {
    goto LABEL_12;
  }
  if (v7 != 2)
  {
    if (v7 == 3)
    {
LABEL_12:
      if (os_log_type_enabled((os_log_t)qword_1008F7620, OS_LOG_TYPE_ERROR)) {
        sub_10069A2C8();
      }
      return 12LL;
    }

    return 0LL;
  }

  uint64_t v9 = (os_log_s *)qword_1008F7620;
  if (os_log_type_enabled((os_log_t)qword_1008F7620, OS_LOG_TYPE_DEFAULT))
  {
    LOWORD(v15) = 0;
    _os_log_impl( (void *)&_mh_execute_header,  v9,  OS_LOG_TYPE_DEFAULT,  "Resuming LE Connection Manager",  (uint8_t *)&v15,  2u);
  }

  sub_1005915A8((os_unfair_lock_s *)a1, 3u);
  int v10 = *(_DWORD *)(a1 + 864);
  if ((v10 - 1) < 3)
  {
    BOOL v11 = (os_log_s *)qword_1008F7620;
    BOOL v12 = os_log_type_enabled((os_log_t)qword_1008F7620, OS_LOG_TYPE_DEFAULT);
    uint64_t result = 0LL;
    if (!v12) {
      return result;
    }
    LOWORD(v15) = 0;
    _os_log_impl( (void *)&_mh_execute_header,  v11,  OS_LOG_TYPE_DEFAULT,  "We're doing something else right now, will resume when idle",  (uint8_t *)&v15,  2u);
    return 0LL;
  }

  if (v10 != 4)
  {
    if (!v10)
    {
      unint64_t v13 = (os_log_s *)qword_1008F7620;
      if (os_log_type_enabled((os_log_t)qword_1008F7620, OS_LOG_TYPE_DEFAULT))
      {
        LOWORD(v15) = 0;
        _os_log_impl( (void *)&_mh_execute_header,  v13,  OS_LOG_TYPE_DEFAULT,  "We're idle, lets move on",  (uint8_t *)&v15,  2u);
      }

      sub_1005915A8((os_unfair_lock_s *)a1, 0);
      sub_1005A0338((id *)a1);
      sub_10059EB5C(a1);
    }

    return 0LL;
  }

  int v14 = (os_log_s *)qword_1008F7620;
  if (os_log_type_enabled((os_log_t)qword_1008F7620, OS_LOG_TYPE_DEFAULT))
  {
    LOWORD(v15) = 0;
    _os_log_impl( (void *)&_mh_execute_header,  v14,  OS_LOG_TYPE_DEFAULT,  "We're auto-reconnecting, lets move on",  (uint8_t *)&v15,  2u);
  }

  sub_1005915A8((os_unfair_lock_s *)a1, 0);
  sub_1005911F0(a1, *(void *)(a1 + 352) != 0LL);
  if ([*(id *)(a1 + 768) count] || (uint64_t result = (uint64_t)objc_msgSend(*(id *)(a1 + 776), "count")) != 0)
  {
    sub_100590B30(a1, 0);
    return 0LL;
  }

  return result;
}

void sub_1005B28D8(uint64_t a1)
{
  if (qword_1008D5F10 != -1) {
    dispatch_once(&qword_1008D5F10, &stru_1008A2B10);
  }
  uint64_t v2 = off_1008D5F08;
  int v3 = *(unsigned __int8 *)(a1 + 60);
  unsigned int v4 = *(unsigned __int16 *)(a1 + 56);
  unsigned int v5 = *(unsigned __int16 *)(a1 + 58);
  sub_1005BE2D8(v6, a1 + 32);
  sub_1005B22EC((uint64_t)v2, v3, v4, v5, v6);
  sub_10023BF24((uint64_t)v6, (void *)v6[1]);
}

void sub_1005B2978( _Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, char a10, void *a11)
{
}

uint64_t *sub_1005B2990(uint64_t a1, uint64_t a2)
{
  return sub_1005BE2D8((uint64_t *)(a1 + 32), a2 + 32);
}

void sub_1005B299C(uint64_t a1)
{
}

double sub_1005B29AC(uint64_t a1, int a2, unsigned __int16 *a3, uint64_t a4)
{
  uint64_t v8 = (os_log_s *)qword_1008F7620;
  if (os_log_type_enabled((os_log_t)qword_1008F7620, OS_LOG_TYPE_DEFAULT))
  {
    LODWORD(v11[0]) = 67109120;
    HIDWORD(v11[0]) = a2;
    _os_log_impl( (void *)&_mh_execute_header,  v8,  OS_LOG_TYPE_DEFAULT,  "handleCsReadRemoteFAETableCallback status=%{bluetooth:OI_STATUS}u",  (uint8_t *)v11,  8u);
  }

  v11[0] = 0LL;
  v11[1] = 0LL;
  uuid_clear((unsigned __int8 *)v11);
  if (sub_100593548(a1, (uint64_t)a3, (unsigned __int8 *)v11))
  {
    uint64_t v10 = sub_1001FDB10(a1 + 1408, (unsigned __int8 *)v11);
    if (a1 + 1416 != v10) {
      *(void *)&double result = sub_1001FF740(*(void *)(v10 + 48), *a3, a4).n128_u64[0];
    }
  }

  return result;
}

uint64_t sub_1005B2AB0(uint64_t a1, int a2, uint64_t a3)
{
  uint64_t v6 = (os_log_s *)qword_1008F7620;
  if (os_log_type_enabled((os_log_t)qword_1008F7620, OS_LOG_TYPE_DEFAULT))
  {
    LODWORD(v8[0]) = 67109120;
    HIDWORD(v8[0]) = a2;
    _os_log_impl( (void *)&_mh_execute_header,  v6,  OS_LOG_TYPE_DEFAULT,  "handleCsReadRemoteFAETableCallback status=%{bluetooth:OI_STATUS}u",  (uint8_t *)v8,  8u);
  }

  v8[0] = 0LL;
  v8[1] = 0LL;
  uuid_clear((unsigned __int8 *)v8);
  uint64_t result = sub_100593548(a1, a3, (unsigned __int8 *)v8);
  if ((_DWORD)result)
  {
    uint64_t result = sub_1001FDB10(a1 + 1408, (unsigned __int8 *)v8);
    if (a1 + 1416 != result) {
      return sub_1001FF768(*(void *)(result + 48));
    }
  }

  return result;
}

void sub_1005B2BA4(uint64_t a1, int a2, uint64_t a3)
{
  uint64_t v6 = (os_log_s *)qword_1008F7620;
  if (os_log_type_enabled((os_log_t)qword_1008F7620, OS_LOG_TYPE_DEFAULT))
  {
    *(_DWORD *)int buf = 67109120;
    *(_DWORD *)&uint8_t buf[4] = a2;
    _os_log_impl( (void *)&_mh_execute_header,  v6,  OS_LOG_TYPE_DEFAULT,  "handleCsProcedureEnableCallback status=%{bluetooth:OI_STATUS}u",  buf,  8u);
  }

  *(void *)int buf = 0LL;
  uint64_t v9 = 0LL;
  uuid_clear(buf);
  if (sub_100593548(a1, a3, buf))
  {
    uint64_t v7 = sub_1001FDB10(a1 + 1408, buf);
    if (a1 + 1416 != v7) {
      sub_1001FF774(*(void *)(v7 + 48), a2);
    }
  }

void sub_1005B2CFC(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, int a6)
{
  BOOL v12 = (os_log_s *)qword_1008F7620;
  if (os_log_type_enabled((os_log_t)qword_1008F7620, OS_LOG_TYPE_DEFAULT))
  {
    *(_DWORD *)int buf = 67109120;
    *(_DWORD *)&uint8_t buf[4] = a6;
    _os_log_impl( (void *)&_mh_execute_header,  v12,  OS_LOG_TYPE_DEFAULT,  "handleCsSubeventResultCallback status=%{bluetooth:OI_STATUS}u",  buf,  8u);
  }

  *(void *)int buf = 0LL;
  uint64_t v15 = 0LL;
  uuid_clear(buf);
  if (sub_100593548(a1, a2, buf))
  {
    uint64_t v13 = sub_1001FDB10(a1 + 1408, buf);
    if (a1 + 1416 != v13) {
      sub_1001FF814(*(void *)(v13 + 48), a2, a3, a4, a5, a6);
    }
  }

void sub_1005B2E54(uint64_t a1, uint64_t a2, uint64_t a3, int a4)
{
  uint64_t v8 = (os_log_s *)qword_1008F7620;
  if (os_log_type_enabled((os_log_t)qword_1008F7620, OS_LOG_TYPE_DEFAULT))
  {
    *(_DWORD *)int buf = 67109120;
    *(_DWORD *)&uint8_t buf[4] = a4;
    _os_log_impl( (void *)&_mh_execute_header,  v8,  OS_LOG_TYPE_DEFAULT,  "handleCsSubeventResultCallback status=%{bluetooth:OI_STATUS}u",  buf,  8u);
  }

  *(void *)int buf = 0LL;
  uint64_t v11 = 0LL;
  uuid_clear(buf);
  if (sub_100593548(a1, a2, buf))
  {
    uint64_t v9 = sub_1001FDB10(a1 + 1408, buf);
    if (a1 + 1416 != v9) {
      sub_1001FF8B4(*(void *)(v9 + 48), a2, a3, a4);
    }
  }

double sub_1005B2F9C(uint64_t a1)
{
  if (qword_1008D5F10 != -1) {
    dispatch_once(&qword_1008D5F10, &stru_1008A2B10);
  }
  return sub_1005B29AC( (uint64_t)off_1008D5F08,  *(_DWORD *)(a1 + 48),  *(unsigned __int16 **)(a1 + 32),  *(void *)(a1 + 40));
}

uint64_t sub_1005B2FF0(uint64_t a1)
{
  if (qword_1008D5F10 != -1) {
    dispatch_once(&qword_1008D5F10, &stru_1008A2B10);
  }
  return sub_1005B2AB0((uint64_t)off_1008D5F08, *(_DWORD *)(a1 + 40), *(void *)(a1 + 32));
}

void sub_1005B3044(uint64_t a1)
{
  if (qword_1008D5F10 != -1) {
    dispatch_once(&qword_1008D5F10, &stru_1008A2B10);
  }
  sub_1005B2BA4((uint64_t)off_1008D5F08, *(_DWORD *)(a1 + 40), *(void *)(a1 + 32));
}

void sub_1005B30C0(uint64_t a1)
{
  if (qword_1008D5F10 != -1) {
    dispatch_once(&qword_1008D5F10, &stru_1008A2B10);
  }
  sub_1005B2CFC( (uint64_t)off_1008D5F08,  *(void *)(a1 + 32),  *(unsigned __int8 *)(a1 + 72),  *(unsigned __int8 *)(a1 + 73),  *(unsigned __int8 *)(a1 + 74),  *(unsigned __int8 *)(a1 + 75));
}

void sub_1005B314C(uint64_t a1)
{
  if (qword_1008D5F10 != -1) {
    dispatch_once(&qword_1008D5F10, &stru_1008A2B10);
  }
  sub_1005B2E54( (uint64_t)off_1008D5F08,  *(void *)(a1 + 32),  *(unsigned __int8 *)(a1 + 72),  *(unsigned __int8 *)(a1 + 73));
}

void sub_1005B31CC(void *a1)
{
  uint64_t v2 = (os_log_s *)qword_1008F7620;
  if (os_log_type_enabled((os_log_t)qword_1008F7620, OS_LOG_TYPE_DEFAULT))
  {
    uint64_t v3 = a1[146];
    *(_DWORD *)int buf = 67109120;
    *(_DWORD *)uint8_t v26 = v3;
    _os_log_impl( (void *)&_mh_execute_header,  v2,  OS_LOG_TYPE_DEFAULT,  "statedump: Disconnection History: %d entries",  buf,  8u);
  }

  if (a1[146])
  {
    double Current = CFAbsoluteTimeGetCurrent();
    unsigned int v5 = objc_alloc_init(&OBJC_CLASS___NSDateFormatter);
    -[NSDateFormatter setDateFormat:](v5, "setDateFormat:", @"yyyy-MM-dd H:mm:ss");
    uint64_t v6 = (void *)a1[144];
    unsigned int v21 = a1 + 145;
    if (v6 != a1 + 145)
    {
      do
      {
        uint64_t v22 = 0LL;
        uint64_t v23 = 0LL;
        uint64_t v24 = 0LL;
        sub_1005BE32C(&v22, (uint64_t)(v6 + 7));
        uint64_t v7 = (os_log_s *)qword_1008F7620;
        if (os_log_type_enabled((os_log_t)qword_1008F7620, OS_LOG_TYPE_DEFAULT))
        {
          uint64_t v8 = v6 + 4;
          *(_DWORD *)int buf = 136446210;
          *(void *)uint8_t v26 = v8;
          _os_log_impl((void *)&_mh_execute_header, v7, OS_LOG_TYPE_DEFAULT, "statedump:    %{public}s:", buf, 0xCu);
        }

        for (uint64_t i = v23; (uint64_t *)i != &v22; uint64_t i = *(void *)(i + 8))
        {
          double v10 = *(double *)(i + 16);
          uint64_t v11 = (void *)objc_claimAutoreleasedReturnValue( +[NSDate dateWithTimeIntervalSinceReferenceDate:]( &OBJC_CLASS___NSDate,  "dateWithTimeIntervalSinceReferenceDate:",  v10));
          BOOL v12 = (void *)objc_claimAutoreleasedReturnValue(-[NSDateFormatter stringFromDate:](v5, "stringFromDate:", v11));
          LODWORD(v13) = llround((v10 - floor(v10)) * 1000.0);
          int v14 = (void *)objc_claimAutoreleasedReturnValue( +[NSString stringWithFormat:]( &OBJC_CLASS___NSString,  "stringWithFormat:",  @"%@.%000d",  v12,  v13));
          uint64_t v15 = (os_log_s *)qword_1008F7620;
          if (os_log_type_enabled((os_log_t)qword_1008F7620, OS_LOG_TYPE_DEFAULT))
          {
            int v16 = *(_DWORD *)(i + 24);
            id v17 = [v14 UTF8String];
            *(_DWORD *)int buf = 67109890;
            *(_DWORD *)uint8_t v26 = v16;
            *(_WORD *)&v26[4] = 2082;
            *(void *)&v26[6] = v17;
            __int16 v27 = 2048;
            double v28 = v10;
            __int16 v29 = 2048;
            double v30 = Current - v10;
            _os_log_impl( (void *)&_mh_execute_header,  v15,  OS_LOG_TYPE_DEFAULT,  "statedump:       reason %d time:%{public}s %.3f secs(%-12.2f secs ago)",  buf,  0x26u);
          }
        }

        sub_10023DF50(&v22);
        unint64_t v18 = (void *)v6[1];
        if (v18)
        {
          do
          {
            unint64_t v19 = v18;
            unint64_t v18 = (void *)*v18;
          }

          while (v18);
        }

        else
        {
          do
          {
            unint64_t v19 = (void *)v6[2];
            BOOL v20 = *v19 == (void)v6;
            uint64_t v6 = v19;
          }

          while (!v20);
        }

        uint64_t v6 = v19;
      }

      while (v19 != v21);
    }
  }

void sub_1005B34C0(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_1005B3510(uint64_t a1, const void **a2)
{
  if (os_log_type_enabled((os_log_t)qword_1008F7620, OS_LOG_TYPE_DEBUG)) {
    sub_10069A2F4();
  }
  unsigned int v4 = (uint64_t *)sub_100024098(a1 + 1152, a2);
  if ((uint64_t *)(a1 + 1160) != v4)
  {
    unsigned int v5 = v4;
    sub_1001FDBCC((uint64_t **)(a1 + 1152), v4);
    sub_100291D30((uint64_t)(v5 + 4));
    operator delete(v5);
  }

double sub_1005B35A0(uint64_t a1, const void **a2)
{
  uint64_t v3 = sub_100024098(a1 + 1152, a2);
  double v4 = 0.0;
  if (a1 + 1160 != v3)
  {
    v6[0] = 0LL;
    v6[1] = 0LL;
    uint64_t v7 = 0LL;
    sub_1005BE32C(v6, v3 + 56);
    if (v7) {
      double v4 = *(double *)(v6[0] + 16LL);
    }
    sub_10023DF50(v6);
  }

  return v4;
}

void sub_1005B3614(void *a1)
{
  uint64_t v2 = (os_log_s *)qword_1008F7620;
  if (os_log_type_enabled((os_log_t)qword_1008F7620, OS_LOG_TYPE_DEFAULT))
  {
    uint64_t v3 = a1[150];
    *(_DWORD *)int buf = 67109120;
    LODWORD(v13) = v3;
    _os_log_impl( (void *)&_mh_execute_header,  v2,  OS_LOG_TYPE_DEFAULT,  "statedump: LeConnectionRSSIThresholdState History: %d entries",  buf,  8u);
  }

  if (a1[150])
  {
    double v4 = (void *)a1[148];
    unsigned int v5 = a1 + 149;
    if (v4 != a1 + 149)
    {
      uint64_t v6 = (os_log_s *)qword_1008F7620;
      do
      {
        if (os_log_type_enabled(v6, OS_LOG_TYPE_DEFAULT))
        {
          uint64_t v7 = v4 + 4;
          int v8 = *((_DWORD *)v4 + 14);
          *(_DWORD *)int buf = 136446466;
          uint64_t v13 = v7;
          __int16 v14 = 1024;
          int v15 = v8;
          _os_log_impl((void *)&_mh_execute_header, v6, OS_LOG_TYPE_DEFAULT, "statedump:    %{public}s:%d", buf, 0x12u);
          uint64_t v6 = (os_log_s *)qword_1008F7620;
        }

        uint64_t v9 = (void *)v4[1];
        if (v9)
        {
          do
          {
            double v10 = v9;
            uint64_t v9 = (void *)*v9;
          }

          while (v9);
        }

        else
        {
          do
          {
            double v10 = (void *)v4[2];
            BOOL v11 = *v10 == (void)v4;
            double v4 = v10;
          }

          while (!v11);
        }

        double v4 = v10;
      }

      while (v10 != v5);
    }
  }

uint64_t *sub_1005B379C(uint64_t a1, __int128 *a2, int a3)
{
  if (*(void *)(a1 + 1200) >= 0x21uLL) {
    sub_1005AA040(a1);
  }
  uint64_t v7 = a2;
  uint64_t result = sub_1005BE6A4((uint64_t **)(a1 + 1184), (const void **)a2, (uint64_t)&unk_1006C2518, &v7);
  *((_DWORD *)result + 14) = a3;
  return result;
}

uint64_t sub_1005B3808(uint64_t a1, const void **a2, double a3)
{
  double Current = CFAbsoluteTimeGetCurrent();
  if (Current <= a3) {
    double v7 = 0.0;
  }
  else {
    double v7 = Current - a3;
  }
  uint64_t v8 = sub_100024098(a1 + 1152, a2);
  if (a1 + 1160 == v8)
  {
    unsigned __int16 v10 = 0;
  }

  else
  {
    memset(v14, 0, sizeof(v14));
    sub_1005BE32C(v14, v8 + 56);
    uint64_t v9 = v14[1];
    if ((void *)v14[1] == v14)
    {
      unsigned __int16 v10 = 0;
    }

    else
    {
      unsigned __int16 v10 = 0;
      do
      {
        BOOL v11 = (*(_DWORD *)(v9 + 24) - 708) > 0x36
           || ((1LL << (*(_BYTE *)(v9 + 24) + 60)) & 0x40000004000001LL) == 0;
        uint64_t v9 = *(void *)(v9 + 8);
      }

      while ((void *)v9 != v14);
    }

    sub_10023DF50(v14);
  }

  BOOL v12 = (os_log_s *)qword_1008F7620;
  if (os_log_type_enabled((os_log_t)qword_1008F7620, OS_LOG_TYPE_INFO))
  {
    LODWORD(v14[0]) = 136446722;
    *(void *)((char *)v14 + 4) = a2;
    WORD2(v14[1]) = 2048;
    *(double *)((char *)&v14[1] + 6) = a3;
    HIWORD(v14[2]) = 1024;
    int v15 = v10;
    _os_log_impl( (void *)&_mh_execute_header,  v12,  OS_LOG_TYPE_INFO,  "getNumDisconnectionsBySignalQuality for %{public}s over time window %f count %d",  (uint8_t *)v14,  0x1Cu);
  }

  return v10;
}

BOOL sub_1005B39A4(uint64_t a1, void *a2)
{
  id v3 = a2;
  v15[0] = 0LL;
  v15[1] = 0LL;
  uint64_t v16 = 0LL;
  id v4 = objc_claimAutoreleasedReturnValue([v3 UUIDString]);
  sub_10002418C(v15, (char *)[v4 UTF8String]);

  if (SHIBYTE(v16) < 0)
  {
    sub_100024238(__p, v15[0], (unint64_t)v15[1]);
  }

  else
  {
    *(_OWORD *)std::stringbuf::string_type __p = *(_OWORD *)v15;
    uint64_t v14 = v16;
  }

  uint64_t v5 = sub_100024098(a1 + 1184, (const void **)__p);
  if (a1 + 1192 == v5) {
    int v6 = 2;
  }
  else {
    int v6 = *(_DWORD *)(v5 + 56);
  }
  if (SHIBYTE(v14) < 0) {
    operator delete(__p[0]);
  }
  int v7 = sub_1005B3C2C(a1, v3);
  uint64_t v8 = (os_log_s *)qword_1008F7620;
  if (os_log_type_enabled((os_log_t)qword_1008F7620, OS_LOG_TYPE_DEFAULT))
  {
    uint64_t v9 = v15;
    if (v16 < 0) {
      uint64_t v9 = (void **)v15[0];
    }
    *(_DWORD *)int buf = 136446722;
    unint64_t v18 = v9;
    __int16 v19 = 1024;
    int v20 = v6;
    __int16 v21 = 1024;
    int v22 = v7;
    _os_log_impl( (void *)&_mh_execute_header,  v8,  OS_LOG_TYPE_DEFAULT,  "updateLeConnectionRSSIThresholdState for %{public}s from %d to %d ",  buf,  0x18u);
  }

  if (v6 != v7)
  {
    if (v7 == 2)
    {
      if (os_log_type_enabled((os_log_t)qword_1008F7620, OS_LOG_TYPE_ERROR)) {
        sub_10069A35C();
      }
    }

    else
    {
      if (SHIBYTE(v16) < 0)
      {
        sub_100024238(v11, v15[0], (unint64_t)v15[1]);
      }

      else
      {
        *(_OWORD *)BOOL v11 = *(_OWORD *)v15;
        uint64_t v12 = v16;
      }

      sub_1005B379C(a1, (__int128 *)v11, v7);
      if (SHIBYTE(v12) < 0) {
        operator delete(v11[0]);
      }
    }
  }

  if (SHIBYTE(v16) < 0) {
    operator delete(v15[0]);
  }

  return v6 != v7;
}

void sub_1005B3BC0( _Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, void *__p, uint64_t a10, int a11, __int16 a12, char a13, char a14, uint64_t a15, uint64_t a16, uint64_t a17, int a18, __int16 a19, char a20, char a21, void *a22, uint64_t a23, int a24, __int16 a25, char a26, char a27)
{
  if (a14 < 0) {
    operator delete(__p);
  }
  if (a27 < 0) {
    operator delete(a22);
  }

  _Unwind_Resume(a1);
}

uint64_t sub_1005B3C2C(uint64_t a1, void *a2)
{
  id v3 = a2;
  v43[0] = 0LL;
  v43[1] = 0LL;
  uint64_t v44 = 0LL;
  id v4 = objc_claimAutoreleasedReturnValue([v3 UUIDString]);
  sub_10002418C(v43, (char *)[v4 UTF8String]);

  unsigned int v42 = 0;
  if (qword_1008D5F30 != -1) {
    dispatch_once(&qword_1008D5F30, &stru_1008A2B30);
  }
  unsigned int v5 = sub_1005CE2FC((uint64_t)off_1008D5F28, v3);
  unsigned int v42 = v5;
  unsigned int v6 = *(unsigned __int16 *)(a1 + 1208);
  int v7 = *(_DWORD *)(a1 + 1212);
  unsigned int v8 = *(unsigned __int16 *)(a1 + 1216);
  int v9 = *(_DWORD *)(a1 + 1220);
  uint64_t v10 = *(void *)(a1 + 1232);
  if (v10)
  {
    uint64_t v11 = a1 + 1232;
    do
    {
      unsigned int v12 = *(_DWORD *)(v10 + 28);
      BOOL v13 = v12 >= v5;
      if (v12 >= v5) {
        uint64_t v14 = (uint64_t *)v10;
      }
      else {
        uint64_t v14 = (uint64_t *)(v10 + 8);
      }
      if (v13) {
        uint64_t v11 = v10;
      }
      uint64_t v10 = *v14;
    }

    while (*v14);
    if (v11 != a1 + 1232 && v5 >= *(_DWORD *)(v11 + 28))
    {
      int v45 = &v42;
      unsigned int v6 = *((unsigned __int16 *)sub_1005BC550((uint64_t **)(a1 + 1224), &v42, (uint64_t)&unk_1006C2518, &v45) + 16);
    }
  }

  uint64_t v15 = *(void *)(a1 + 1256);
  if (v15)
  {
    uint64_t v16 = a1 + 1256;
    do
    {
      unsigned int v17 = *(_DWORD *)(v15 + 28);
      BOOL v18 = v17 >= v42;
      if (v17 >= v42) {
        __int16 v19 = (uint64_t *)v15;
      }
      else {
        __int16 v19 = (uint64_t *)(v15 + 8);
      }
      if (v18) {
        uint64_t v16 = v15;
      }
      uint64_t v15 = *v19;
    }

    while (*v19);
    if (v16 != a1 + 1256 && v42 >= *(_DWORD *)(v16 + 28))
    {
      int v45 = &v42;
      int v7 = *((_DWORD *)sub_1002DBB90((uint64_t **)(a1 + 1248), &v42, (uint64_t)&unk_1006C2518, &v45) + 8);
    }
  }

  uint64_t v20 = *(void *)(a1 + 1280);
  if (v20)
  {
    uint64_t v21 = a1 + 1280;
    do
    {
      unsigned int v22 = *(_DWORD *)(v20 + 28);
      BOOL v23 = v22 >= v42;
      if (v22 >= v42) {
        uint64_t v24 = (uint64_t *)v20;
      }
      else {
        uint64_t v24 = (uint64_t *)(v20 + 8);
      }
      if (v23) {
        uint64_t v21 = v20;
      }
      uint64_t v20 = *v24;
    }

    while (*v24);
    if (v21 != a1 + 1280 && v42 >= *(_DWORD *)(v21 + 28))
    {
      int v45 = &v42;
      unsigned int v8 = *((unsigned __int16 *)sub_1005BC550((uint64_t **)(a1 + 1272), &v42, (uint64_t)&unk_1006C2518, &v45) + 16);
    }
  }

  uint64_t v25 = *(void *)(a1 + 1304);
  if (v25)
  {
    uint64_t v26 = a1 + 1304;
    do
    {
      unsigned int v27 = *(_DWORD *)(v25 + 28);
      BOOL v28 = v27 >= v42;
      if (v27 >= v42) {
        __int16 v29 = (uint64_t *)v25;
      }
      else {
        __int16 v29 = (uint64_t *)(v25 + 8);
      }
      if (v28) {
        uint64_t v26 = v25;
      }
      uint64_t v25 = *v29;
    }

    while (*v29);
    if (v26 != a1 + 1304 && v42 >= *(_DWORD *)(v26 + 28))
    {
      int v45 = &v42;
      int v9 = *((_DWORD *)sub_1002DBB90((uint64_t **)(a1 + 1296), &v42, (uint64_t)&unk_1006C2518, &v45) + 8);
    }
  }

  if (SHIBYTE(v44) < 0)
  {
    sub_100024238(__p, v43[0], (unint64_t)v43[1]);
  }

  else
  {
    *(_OWORD *)std::stringbuf::string_type __p = *(_OWORD *)v43;
    uint64_t v41 = v44;
  }

  uint64_t v30 = sub_100024098(a1 + 1184, (const void **)__p);
  if (a1 + 1192 == v30) {
    int v31 = 2;
  }
  else {
    int v31 = *(_DWORD *)(v30 + 56);
  }
  if (SHIBYTE(v41) < 0)
  {
    operator delete(__p[0]);
    if (v31)
    {
LABEL_59:
      if (v31 == 1)
      {
        if (SHIBYTE(v44) < 0)
        {
          sub_100024238(v36, v43[0], (unint64_t)v43[1]);
        }

        else
        {
          *(_OWORD *)uint64_t v36 = *(_OWORD *)v43;
          uint64_t v37 = v44;
        }

        unsigned int v33 = sub_1005B3808(a1, (const void **)v36, (double)(unsigned __int16)v9);
        if (SHIBYTE(v37) < 0) {
          operator delete(v36[0]);
        }
        uint64_t v32 = v33 > v8;
      }

      else
      {
        if (os_log_type_enabled((os_log_t)qword_1008F7620, OS_LOG_TYPE_ERROR)) {
          sub_10069A3C4();
        }
        uint64_t v32 = 2LL;
      }

      goto LABEL_76;
    }
  }

  else if (v31)
  {
    goto LABEL_59;
  }

  if (SHIBYTE(v44) < 0)
  {
    sub_100024238(__dst, v43[0], (unint64_t)v43[1]);
  }

  else
  {
    *(_OWORD *)__uuid_t dst = *(_OWORD *)v43;
    uint64_t v39 = v44;
  }

  unsigned int v34 = sub_1005B3808(a1, (const void **)__dst, (double)(unsigned __int16)v7);
  if (SHIBYTE(v39) < 0) {
    operator delete(__dst[0]);
  }
  uint64_t v32 = v34 >= v6;
LABEL_76:
  if (SHIBYTE(v44) < 0) {
    operator delete(v43[0]);
  }

  return v32;
}

void sub_1005B4010( _Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, int a11, __int16 a12, char a13, char a14, uint64_t a15, void *a16, uint64_t a17, int a18, __int16 a19, char a20, char a21, uint64_t a22, uint64_t a23, uint64_t a24, int a25, __int16 a26, char a27, char a28, uint64_t a29, uint64_t a30, void *__p, uint64_t a32, int a33, __int16 a34, char a35, char a36)
{
  if (a36 < 0) {
    operator delete(__p);
  }

  _Unwind_Resume(a1);
}

uint64_t *sub_1005B4094(uint64_t a1, const void **a2)
{
  if (os_log_type_enabled((os_log_t)qword_1008F7620, OS_LOG_TYPE_DEBUG)) {
    sub_10069A42C();
  }
  uint64_t result = (uint64_t *)sub_100024098(a1 + 1184, a2);
  return result;
}

void sub_1005B4110(uint64_t a1, double a2)
{
  if (a2 > 0.0)
  {
    unsigned int v27 = &v27;
    BOOL v28 = (void **)&v27;
    uint64_t v29 = 0LL;
    id v3 = *(void **)(a1 + 1152);
    id v4 = (void *)(a1 + 1160);
    if (v3 != (void *)(a1 + 1160))
    {
      do
      {
        unsigned int v6 = v3 + 4;
        int v7 = (os_log_s *)qword_1008F7620;
        if (os_log_type_enabled((os_log_t)qword_1008F7620, OS_LOG_TYPE_DEBUG))
        {
          if (*((char *)v3 + 55) < 0)
          {
            uint64_t v14 = (void *)v3[4];
            sub_100024238(__dst, v14, v3[5]);
          }

          else
          {
            *(_OWORD *)__uuid_t dst = *v6;
            uint64_t v26 = v3[6];
            uint64_t v14 = v3 + 4;
          }

          double v15 = sub_1005B35A0(a1, (const void **)__dst);
          *(_DWORD *)int buf = 136446722;
          *(void *)&uint8_t buf[4] = v14;
          *(_WORD *)&_BYTE buf[12] = 2048;
          *(double *)&buf[14] = v15;
          *(_WORD *)&_BYTE buf[22] = 2048;
          double v33 = a2;
          _os_log_debug_impl( (void *)&_mh_execute_header,  v7,  OS_LOG_TYPE_DEBUG,  "purgeStaleDisconnectionHistoryLeConnectionRSSIThresholdState: %{public}s last %f cutoff %f",  buf,  0x20u);
          if (SHIBYTE(v26) < 0) {
            operator delete(__dst[0]);
          }
        }

        if (*((char *)v3 + 55) < 0)
        {
          sub_100024238(__p, (void *)v3[4], v3[5]);
        }

        else
        {
          *(_OWORD *)std::stringbuf::string_type __p = *v6;
          uint64_t v24 = v3[6];
        }

        double v8 = sub_1005B35A0(a1, (const void **)__p);
        if (SHIBYTE(v24) < 0) {
          operator delete(__p[0]);
        }
        if (v8 < a2)
        {
          int v9 = sub_1005BE7F4((uint64_t)&v27, 0LL, 0LL, (uint64_t)(v3 + 4));
          uint64_t v10 = v27;
          *int v9 = v27;
          v9[1] = &v27;
          v10[1] = v9;
          unsigned int v27 = v9;
          ++v29;
        }

        uint64_t v11 = (void *)v3[1];
        if (v11)
        {
          do
          {
            unsigned int v12 = v11;
            uint64_t v11 = (void *)*v11;
          }

          while (v11);
        }

        else
        {
          do
          {
            unsigned int v12 = (void *)v3[2];
            BOOL v13 = *v12 == (void)v3;
            id v3 = v12;
          }

          while (!v13);
        }

        id v3 = v12;
      }

      while (v12 != v4);
      for (uint64_t i = v28; i != (void **)&v27; uint64_t i = (void **)i[1])
      {
        memset(buf, 0, sizeof(buf));
        if (*((char *)i + 39) < 0)
        {
          sub_100024238(buf, i[2], (unint64_t)i[3]);
        }

        else
        {
          *(_OWORD *)int buf = *((_OWORD *)i + 1);
          *(void *)&uint8_t buf[16] = i[4];
        }

        unsigned int v17 = (os_log_s *)qword_1008F7620;
        if (os_log_type_enabled((os_log_t)qword_1008F7620, OS_LOG_TYPE_DEFAULT))
        {
          if ((buf[23] & 0x80u) == 0) {
            BOOL v18 = buf;
          }
          else {
            BOOL v18 = *(uint8_t **)buf;
          }
          *(_DWORD *)uint64_t v30 = 136446210;
          int v31 = v18;
          _os_log_impl( (void *)&_mh_execute_header,  v17,  OS_LOG_TYPE_DEFAULT,  "purgeStaleDisconnectionHistoryLeConnectionRSSIThresholdState: %{public}s deleted",  v30,  0xCu);
        }

        if ((char)buf[23] < 0)
        {
          sub_100024238(v21, *(void **)buf, *(unint64_t *)&buf[8]);
        }

        else
        {
          *(_OWORD *)uint64_t v21 = *(_OWORD *)buf;
          uint64_t v22 = *(void *)&buf[16];
        }

        sub_1005B3510(a1, (const void **)v21);
        if (SHIBYTE(v22) < 0) {
          operator delete(v21[0]);
        }
        if ((char)buf[23] < 0)
        {
          sub_100024238(v19, *(void **)buf, *(unint64_t *)&buf[8]);
        }

        else
        {
          *(_OWORD *)__int16 v19 = *(_OWORD *)buf;
          uint64_t v20 = *(void *)&buf[16];
        }

        sub_1005B4094(a1, (const void **)v19);
        if (SHIBYTE(v20) < 0) {
          operator delete(v19[0]);
        }
      }
    }

    sub_1002ECA14((void **)&v27);
  }

void sub_1005B448C( _Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, void *__p, uint64_t a12, int a13, __int16 a14, char a15, char a16, uint64_t a17, uint64_t a18, uint64_t a19, int a20, __int16 a21, char a22, char a23, uint64_t a24, uint64_t a25, uint64_t a26, int a27, __int16 a28, char a29, char a30, uint64_t a31, uint64_t a32, uint64_t a33, int a34, __int16 a35, char a36, char a37, void *a38)
{
}

BOOL sub_1005B4514(uint64_t a1, uint64_t a2)
{
  return *(double *)(a1 + 24) < *(double *)(a2 + 24);
}

void sub_1005B4528(uint64_t a1)
{
  int v1 = *(_DWORD *)(a1 + 1168);
  if ((unsigned __int16)v1 <= 0x20u)
  {
    if (os_log_type_enabled((os_log_t)qword_1008F7620, OS_LOG_TYPE_DEBUG)) {
      sub_10069A494();
    }
    return;
  }

  id v3 = &v27;
  unsigned int v27 = &v27;
  BOOL v28 = (void **)&v27;
  unint64_t v29 = 0LL;
  id v4 = *(void **)(a1 + 1152);
  unsigned int v5 = (void *)(a1 + 1160);
  if (v4 != (void *)(a1 + 1160))
  {
    while (1)
    {
      unsigned int v6 = v4 + 4;
      if (*((char *)v4 + 55) < 0)
      {
        sub_100024238(__dst, (void *)v4[4], v4[5]);
        if (*((char *)v4 + 55) < 0)
        {
          sub_100024238(__p, (void *)v4[4], v4[5]);
          goto LABEL_9;
        }
      }

      else
      {
        *(_OWORD *)__uuid_t dst = *v6;
        uint64_t v25 = (void *)v4[6];
      }

      *(_OWORD *)std::stringbuf::string_type __p = *v6;
      uint64_t v23 = v4[6];
LABEL_9:
      double v7 = sub_1005B35A0(a1, (const void **)__p);
      double v26 = v7;
      double v8 = operator new(0x30uLL);
      v8[1] = *(_OWORD *)__dst;
      *((void *)v8 + 4) = v25;
      __dst[1] = 0LL;
      uint64_t v25 = 0LL;
      __dst[0] = 0LL;
      *((double *)v8 + 5) = v7;
      int v9 = v27;
      *(void *)double v8 = v27;
      *((void *)v8 + 1) = &v27;
      v9[1] = v8;
      unsigned int v27 = v8;
      ++v29;
      if (SHIBYTE(v23) < 0) {
        operator delete(__p[0]);
      }
      uint64_t v10 = (void *)v4[1];
      if (v10)
      {
        do
        {
          uint64_t v11 = v10;
          uint64_t v10 = (void *)*v10;
        }

        while (v10);
      }

      else
      {
        do
        {
          uint64_t v11 = (void *)v4[2];
          BOOL v12 = *v11 == (void)v4;
          id v4 = v11;
        }

        while (!v12);
      }

      id v4 = v11;
      if (v11 == v5)
      {
        id v3 = (uint64_t **)v28;
        unint64_t v13 = v29;
        goto LABEL_20;
      }
    }
  }

  unint64_t v13 = 0LL;
LABEL_20:
  __dst[0] = sub_1005B4514;
  sub_1005BE86C(v3, (uint64_t *)&v27, v13, (unsigned int (**)(uint64_t, uint64_t))__dst);
  uint64_t v14 = v28;
  if (v28 != (void **)&v27)
  {
    if ((((_WORD)v1 - 32) & 0xFFFE) != 0) {
      int v15 = (unsigned __int16)(v1 - 32);
    }
    else {
      int v15 = 1;
    }
    do
    {
      __dst[0] = 0LL;
      __dst[1] = 0LL;
      uint64_t v25 = 0LL;
      if (*((char *)v14 + 39) < 0)
      {
        sub_100024238(__dst, v14[2], (unint64_t)v14[3]);
      }

      else
      {
        *(_OWORD *)__uuid_t dst = *((_OWORD *)v14 + 1);
        uint64_t v25 = v14[4];
      }

      if (SHIBYTE(v25) < 0)
      {
        sub_100024238(v20, __dst[0], (unint64_t)__dst[1]);
      }

      else
      {
        *(_OWORD *)uint64_t v20 = *(_OWORD *)__dst;
        uint64_t v21 = v25;
      }

      sub_1005B3510(a1, (const void **)v20);
      if (SHIBYTE(v21) < 0) {
        operator delete(v20[0]);
      }
      if (SHIBYTE(v25) < 0)
      {
        sub_100024238(v18, __dst[0], (unint64_t)__dst[1]);
      }

      else
      {
        *(_OWORD *)BOOL v18 = *(_OWORD *)__dst;
        __int16 v19 = v25;
      }

      sub_1005B4094(a1, (const void **)v18);
      if (SHIBYTE(v19) < 0) {
        operator delete(v18[0]);
      }
      uint64_t v16 = (os_log_s *)qword_1008F7620;
      if (os_log_type_enabled((os_log_t)qword_1008F7620, OS_LOG_TYPE_DEFAULT))
      {
        if (SHIBYTE(v25) >= 0) {
          unsigned int v17 = __dst;
        }
        else {
          unsigned int v17 = (void **)__dst[0];
        }
        *(_DWORD *)int buf = 136446210;
        int v31 = v17;
        _os_log_impl( (void *)&_mh_execute_header,  v16,  OS_LOG_TYPE_DEFAULT,  "capDisconnectionHistoryLeConnectionRSSIThresholdState: delete %{public}s",  buf,  0xCu);
      }

      if (SHIBYTE(v25) < 0) {
        operator delete(__dst[0]);
      }
      if (!--v15) {
        break;
      }
      uint64_t v14 = (void **)v14[1];
    }

    while (v14 != (void **)&v27);
  }

  sub_1002ECA14((void **)&v27);
}

void sub_1005B4898( _Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, void *a11, uint64_t a12, int a13, __int16 a14, char a15, char a16, uint64_t a17, uint64_t a18, uint64_t a19, int a20, __int16 a21, char a22, char a23, uint64_t a24, uint64_t a25, uint64_t a26, int a27, __int16 a28, char a29, char a30, uint64_t a31, void *__p, uint64_t a33, int a34, __int16 a35, char a36, char a37, uint64_t a38, uint64_t a39, char a40)
{
}

uint64_t sub_1005B493C(os_unfair_lock_s *a1)
{
  uint64_t v2 = (os_log_s *)qword_1008F7620;
  if (os_log_type_enabled((os_log_t)qword_1008F7620, OS_LOG_TYPE_DEFAULT))
  {
    uint64_t os_unfair_lock_opaque = (int)a1[216]._os_unfair_lock_opaque;
    else {
      id v4 = (&off_1008A2DC0)[os_unfair_lock_opaque];
    }
    uint64_t v5 = (int)a1[232]._os_unfair_lock_opaque;
    else {
      unsigned int v6 = (&off_1008A2DA0)[v5];
    }
    int v14 = 136446466;
    int v15 = v4;
    __int16 v16 = 2082;
    unsigned int v17 = v6;
    _os_log_impl( (void *)&_mh_execute_header,  v2,  OS_LOG_TYPE_DEFAULT,  "pauseConnectionManager called, LeConnectionState=%{public}s LeConnectionManagerState=%{public}s",  (uint8_t *)&v14,  0x16u);
  }

  uint32_t v7 = a1[232]._os_unfair_lock_opaque;
  if (v7 - 1 >= 3)
  {
    if (!v7)
    {
      sub_1005915A8(a1, 1u);
      switch(a1[216]._os_unfair_lock_opaque)
      {
        case 0u:
          uint64_t v11 = (os_log_s *)qword_1008F7620;
          if (!os_log_type_enabled((os_log_t)qword_1008F7620, OS_LOG_TYPE_DEFAULT)) {
            goto LABEL_25;
          }
          LOWORD(v14) = 0;
          BOOL v12 = "We're idle, lets move on";
          goto LABEL_24;
        case 1u:
          unint64_t v13 = (os_log_s *)qword_1008F7620;
          if (os_log_type_enabled((os_log_t)qword_1008F7620, OS_LOG_TYPE_DEFAULT))
          {
            LOWORD(v14) = 0;
            _os_log_impl( (void *)&_mh_execute_header,  v13,  OS_LOG_TYPE_DEFAULT,  "We're trying to connect - cancelling all connections, will pause when idle",  (uint8_t *)&v14,  2u);
          }

          sub_100590B30(a1, 1LL);
          return 0LL;
        case 2u:
        case 3u:
          int v9 = (os_log_s *)qword_1008F7620;
          BOOL v10 = os_log_type_enabled((os_log_t)qword_1008F7620, OS_LOG_TYPE_DEFAULT);
          uint64_t result = 0LL;
          if (!v10) {
            return result;
          }
          LOWORD(v14) = 0;
          _os_log_impl( (void *)&_mh_execute_header,  v9,  OS_LOG_TYPE_DEFAULT,  "We're in the middle of connection cancellation - will pause when idle",  (uint8_t *)&v14,  2u);
          return 0LL;
        case 4u:
          uint64_t v11 = (os_log_s *)qword_1008F7620;
          if (!os_log_type_enabled((os_log_t)qword_1008F7620, OS_LOG_TYPE_DEFAULT)) {
            goto LABEL_25;
          }
          LOWORD(v14) = 0;
          BOOL v12 = "We're autoReconnect, lets pause";
LABEL_24:
          _os_log_impl((void *)&_mh_execute_header, v11, OS_LOG_TYPE_DEFAULT, v12, (uint8_t *)&v14, 2u);
LABEL_25:
          sub_1005915A8(a1, 2u);
          break;
        default:
          return 0LL;
      }
    }

    return 0LL;
  }

  else
  {
    if (os_log_type_enabled((os_log_t)qword_1008F7620, OS_LOG_TYPE_ERROR)) {
      sub_10069A2C8();
    }
    return 12LL;
  }

void sub_1005B4BB0(id a1, LeConnectionManagerListener *a2)
{
}

void sub_1005B4BC0(id a1, LeConnectionManagerListener *a2)
{
}

uint64_t sub_1005B4BD0@<X0>(uint64_t a1@<X0>, std::stringbuf::string_type *a2@<X8>)
{
  uint64_t v21 = 0LL;
  __int128 v19 = 0u;
  memset(v20, 0, sizeof(v20));
  *(_OWORD *)std::stringbuf::string_type __p = 0u;
  __int128 v18 = 0u;
  memset(v16, 0, sizeof(v16));
  sub_10020E564((uint64_t)v16);
  id v4 = sub_1001FD17C(v16, (uint64_t)" client: ", 9LL);
  sub_1001FD17C(v4, (uint64_t)"LeConnectionManager", 19LL);
  uint64_t v5 = sub_1001FD17C(v16, (uint64_t)" state: (", 9LL);
  uint64_t v6 = *(int *)(a1 + 864);
  else {
    uint32_t v7 = (&off_1008A2DC0)[v6];
  }
  size_t v8 = strlen(v7);
  int v9 = sub_1001FD17C(v5, (uint64_t)v7, v8);
  sub_1001FD17C(v9, (uint64_t)")", 1LL);
  BOOL v10 = sub_1001FD17C(v16, (uint64_t)" , ManagerState: (", 18LL);
  uint64_t v11 = *(int *)(a1 + 928);
  else {
    BOOL v12 = (&off_1008A2DA0)[v11];
  }
  size_t v13 = strlen(v12);
  int v14 = sub_1001FD17C(v10, (uint64_t)v12, v13);
  sub_1001FD17C(v14, (uint64_t)")", 1LL);
  std::stringbuf::str(a2, (const std::stringbuf *)((char *)v16 + 8));
  if (SHIBYTE(v18) < 0) {
    operator delete(__p[1]);
  }
  std::streambuf::~streambuf((char *)v16 + 8);
  return std::ios::~ios(v20);
}

void sub_1005B4D94( _Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9)
{
}

uint64_t sub_1005B4DA8@<X0>(uint64_t a1@<X0>, std::stringbuf::string_type *a2@<X8>)
{
  return sub_1005B4BD0(a1 - 32, a2);
}

uint64_t sub_1005B4DB0(uint64_t a1, uint64_t (***a2)(void, void, uint64_t))
{
  return (**a2)(a2, *(void *)(a1 + 32), 202LL);
}

uint64_t sub_1005B4DCC(uint64_t a1, uint64_t (***a2)(void, void, uint64_t))
{
  return (**a2)(a2, *(void *)(a1 + 32), 1LL);
}

uint64_t sub_1005B4DE8(uint64_t *a1, uint64_t *a2)
{
  unint64_t v6 = a1[2];
  uint64_t result = (uint64_t)(a1 + 2);
  unint64_t v5 = v6;
  unint64_t v7 = *(void *)(result - 8);
  if (v7 >= v6)
  {
    unint64_t v12 = 0xCCCCCCCCCCCCCCCDLL * ((uint64_t)(v7 - *a1) >> 3);
    unint64_t v13 = v12 + 1;
    if (v12 + 1 > 0x666666666666666LL) {
      abort();
    }
    unint64_t v14 = 0xCCCCCCCCCCCCCCCDLL * ((uint64_t)(v5 - *a1) >> 3);
    if (2 * v14 > v13) {
      unint64_t v13 = 2 * v14;
    }
    if (v14 >= 0x333333333333333LL) {
      unint64_t v15 = 0x666666666666666LL;
    }
    else {
      unint64_t v15 = v13;
    }
    void v21[4] = result;
    __int16 v16 = (char *)sub_1001FDA44(result, v15);
    unsigned int v17 = &v16[40 * v12];
    v21[0] = v16;
    v21[1] = v17;
    v21[3] = &v16[40 * v18];
    uint64_t v19 = *a2;
    *a2 = 0LL;
    *(void *)unsigned int v17 = v19;
    LODWORD(v19) = *((_DWORD *)a2 + 6);
    *(_OWORD *)(v17 + 8) = *(_OWORD *)(a2 + 1);
    *((_DWORD *)v17 + 6) = v19;
    uint64_t v20 = a2[4];
    a2[4] = 0LL;
    *((void *)v17 + 4) = v20;
    void v21[2] = v17 + 40;
    sub_1005BEC04(a1, v21);
    uint64_t v11 = a1[1];
    uint64_t result = sub_1005BEC7C((uint64_t)v21);
  }

  else
  {
    uint64_t v8 = *a2;
    *a2 = 0LL;
    *(void *)unint64_t v7 = v8;
    __int128 v9 = *(_OWORD *)(a2 + 1);
    *(_DWORD *)(v7 + 24) = *((_DWORD *)a2 + 6);
    *(_OWORD *)(v7 + 8) = v9;
    uint64_t v10 = a2[4];
    a2[4] = 0LL;
    *(void *)(v7 + 32) = v10;
    uint64_t v11 = v7 + 40;
    a1[1] = v7 + 40;
  }

  a1[1] = v11;
  return result;
}

void sub_1005B4F1C(_Unwind_Exception *a1, uint64_t a2, ...)
{
}

void sub_1005B4F30(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, int a6)
{
  uint64_t v10 = *(void *)(a1 + 32);
  if (*(char *)(a2 + 23) < 0)
  {
    sub_100024238(__p, *(void **)a2, *(void *)(a2 + 8));
  }

  else
  {
    *(_OWORD *)std::stringbuf::string_type __p = *(_OWORD *)a2;
    uint64_t v12 = *(void *)(a2 + 16);
  }

  sub_1005B4FE8(v10, (__int128 *)__p, a3, a4, a5, a6);
  if (SHIBYTE(v12) < 0) {
    operator delete(__p[0]);
  }
}

void sub_1005B4FCC( _Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, void *__p, uint64_t a10, int a11, __int16 a12, char a13, char a14)
{
  if (a14 < 0) {
    operator delete(__p);
  }
  _Unwind_Resume(exception_object);
}

void sub_1005B4FE8(uint64_t a1, __int128 *a2, uint64_t a3, uint64_t a4, uint64_t a5, int a6)
{
  uint64_t v12 = sub_100404FE8();
  v13[0] = _NSConcreteStackBlock;
  v13[1] = 3321888768LL;
  v13[2] = sub_1005B7044;
  v13[3] = &unk_1008A2988;
  v13[4] = a1;
  if (*((char *)a2 + 23) < 0)
  {
    sub_100024238(&__p, *(void **)a2, *((void *)a2 + 1));
  }

  else
  {
    __int128 __p = *a2;
    uint64_t v15 = *((void *)a2 + 2);
  }

  uint64_t v16 = a3;
  uint64_t v17 = a4;
  uint64_t v18 = a5;
  int v19 = a6;
  sub_100405384(v12, v13);
  if (SHIBYTE(v15) < 0) {
    operator delete((void *)__p);
  }
}

void sub_1005B50C4( _Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, void *__p, uint64_t a15, int a16, __int16 a17, char a18, char a19)
{
  if (a19 < 0) {
    operator delete(__p);
  }
  _Unwind_Resume(exception_object);
}

void sub_1005B50E0(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, int a6)
{
  uint64_t v10 = *(void *)(a1 + 32);
  if (*(char *)(a2 + 23) < 0)
  {
    sub_100024238(__p, *(void **)a2, *(void *)(a2 + 8));
  }

  else
  {
    *(_OWORD *)__int128 __p = *(_OWORD *)a2;
    uint64_t v12 = *(void *)(a2 + 16);
  }

  sub_1005B4FE8(v10, (__int128 *)__p, a3, a4, a5, a6);
  if (SHIBYTE(v12) < 0) {
    operator delete(__p[0]);
  }
}

void sub_1005B517C( _Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, void *__p, uint64_t a10, int a11, __int16 a12, char a13, char a14)
{
  if (a14 < 0) {
    operator delete(__p);
  }
  _Unwind_Resume(exception_object);
}

uint64_t sub_1005B5198(unsigned __int16 *a1, int a2, int a3, int a4)
{
  if (!a4) {
    return 1LL;
  }
  if (a1[132] == a2)
  {
    BOOL v7 = a4 == 24;
  }

  else if (a1[136] == a2)
  {
    BOOL v7 = a2 - 48 == a4;
  }

  else
  {
    int v8 = a1[134];
    BOOL v7 = v8 != a2 || v8 - 48 == a4;
  }

  BOOL v9 = v7;
  if (a2 - a3 >= a4 && v9) {
    return 1LL;
  }
  uint64_t v11 = (os_log_s *)qword_1008F7620;
  BOOL v12 = os_log_type_enabled((os_log_t)qword_1008F7620, OS_LOG_TYPE_DEFAULT);
  uint64_t result = 0LL;
  if (v12)
  {
    v13[0] = 67109632;
    v13[1] = a2;
    __int16 v14 = 1024;
    int v15 = a3;
    __int16 v16 = 1024;
    int v17 = a4;
    _os_log_impl( (void *)&_mh_execute_header,  v11,  OS_LOG_TYPE_DEFAULT,  "connectionScanParameters: Invalid combination of scan parameters interval %d window %d scancoreWindow %d  - do not use SC for connection scan.",  (uint8_t *)v13,  0x14u);
    return 0LL;
  }

  return result;
}

void sub_1005B52C4(id a1, LeConnectionManagerListener *a2)
{
}

void sub_1005B52D4(id a1, LeConnectionManagerListener *a2)
{
}

__n128 sub_1005B52E4(__n128 *a1, __n128 *a2)
{
  __n128 result = a2[3];
  a1[4].n128_u64[0] = a2[4].n128_u64[0];
  a1[3] = result;
  return result;
}

uint64_t sub_1005B52FC(uint64_t a1)
{
  uint64_t v2 = (os_log_s *)qword_1008F7620;
  if (os_log_type_enabled((os_log_t)qword_1008F7620, OS_LOG_TYPE_DEFAULT))
  {
    id v3 = sub_1005BFB9C(*(void *)(*(void *)(*(void *)(a1 + 32) + 8LL) + 48LL));
    id v4 = (id)objc_claimAutoreleasedReturnValue(v3);
    id v5 = sub_1005BFB9C(*(void *)(*(void *)(*(void *)(a1 + 32) + 8LL) + 56LL));
    id v6 = (id)objc_claimAutoreleasedReturnValue(v5);
    int v7 = *(unsigned __int8 *)(a1 + 40);
    if (*(_BYTE *)(a1 + 40)) {
      int v8 = "";
    }
    else {
      int v8 = " non-connectable-secondary:";
    }
    if (*(_BYTE *)(a1 + 40))
    {
      BOOL v9 = &stru_1008A57D8;
    }

    else
    {
      id v10 = sub_1005BFB9C(*(void *)(*(void *)(*(void *)(a1 + 32) + 8LL) + 64LL));
      BOOL v9 = (__CFString *)objc_claimAutoreleasedReturnValue(v10);
    }

    *(_DWORD *)int buf = 138544130;
    id v16 = v4;
    __int16 v17 = 2114;
    id v18 = v6;
    __int16 v19 = 2080;
    uint64_t v20 = v8;
    __int16 v21 = 2114;
    uint64_t v22 = v9;
    _os_log_impl( (void *)&_mh_execute_header,  v2,  OS_LOG_TYPE_DEFAULT,  "LeConnectionManager::leAddressChangedCallback dispatched addresses connectable:%{public}@ non-connectable:%{public}@%s%{public}@",  buf,  0x2Au);
    if (!v7) {
  }
    }

  if (qword_1008D5F10 != -1) {
    dispatch_once(&qword_1008D5F10, &stru_1008A2B10);
  }
  uint64_t v11 = *(void *)(*(void *)(a1 + 32) + 8LL);
  __int128 v13 = *(_OWORD *)(v11 + 48);
  uint64_t v14 = *(void *)(v11 + 64);
  return sub_10059E7E4((uint64_t)off_1008D5F08, &v13);
}

void sub_1005B54BC(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_1005B54E8(id a1)
{
  if (qword_1008D5F10 != -1) {
    dispatch_once(&qword_1008D5F10, &stru_1008A2B10);
  }
  sub_10059F678((uint64_t)off_1008D5F08);
}

uint64_t sub_1005B5528(uint64_t a1)
{
  uint64_t v2 = (os_log_s *)qword_1008F7620;
  if (os_log_type_enabled((os_log_t)qword_1008F7620, OS_LOG_TYPE_DEFAULT))
  {
    if (*(_BYTE *)(a1 + 52)) {
      id v3 = "Incoming";
    }
    else {
      id v3 = "Outgoing";
    }
    uint64_t v4 = *(void *)(a1 + 32);
    id v5 = sub_1005BFB9C(*(void *)(a1 + 40));
    id v6 = (void *)objc_claimAutoreleasedReturnValue(v5);
    int v7 = *(_DWORD *)(a1 + 48);
    int v9 = 136446978;
    id v10 = v3;
    __int16 v11 = 2048;
    uint64_t v12 = v4;
    __int16 v13 = 2114;
    uint64_t v14 = v6;
    __int16 v15 = 1024;
    int v16 = v7;
    _os_log_impl( (void *)&_mh_execute_header,  v2,  OS_LOG_TYPE_DEFAULT,  "%{public}s LE Connection complete for handle %p address %{public}@ with status %d",  (uint8_t *)&v9,  0x26u);
  }

  if (qword_1008D5F10 != -1) {
    dispatch_once(&qword_1008D5F10, &stru_1008A2B10);
  }
  return sub_1005A3440( (uint64_t)off_1008D5F08,  *(void *)(a1 + 40),  *(unsigned __int8 *)(a1 + 52),  *(unsigned __int16 **)(a1 + 32),  *(_DWORD *)(a1 + 48),  *(unsigned __int8 *)(a1 + 53));
}

uint64_t sub_1005B5674(uint64_t a1)
{
  if (qword_1008D5F10 != -1) {
    dispatch_once(&qword_1008D5F10, &stru_1008A2B10);
  }
  return sub_1005A63B8((uint64_t)off_1008D5F08, *(_DWORD *)(a1 + 32));
}

uint64_t sub_1005B56C4(uint64_t a1)
{
  uint64_t v2 = (os_log_s *)qword_1008F7620;
  if (os_log_type_enabled((os_log_t)qword_1008F7620, OS_LOG_TYPE_DEFAULT))
  {
    uint64_t v3 = *(void *)(a1 + 32);
    int v6 = 134217984;
    uint64_t v7 = v3;
    _os_log_impl( (void *)&_mh_execute_header,  v2,  OS_LOG_TYPE_DEFAULT,  "Clearing ConnectionEventTrigger for device %lld",  (uint8_t *)&v6,  0xCu);
  }

  uint64_t v4 = sub_1002E6E9C();
  return (*(uint64_t (**)(uint64_t, void, uint64_t, uint64_t, void, uint64_t))(*(void *)v4 + 2920LL))( v4,  *(void *)(a1 + 40),  0xFFFFLL,  1LL,  0LL,  1LL);
}

uint64_t sub_1005B578C(uint64_t a1)
{
  uint64_t v2 = (os_log_s *)qword_1008F7620;
  if (os_log_type_enabled((os_log_t)qword_1008F7620, OS_LOG_TYPE_DEFAULT))
  {
    uint64_t v3 = *(void *)(a1 + 32);
    id v4 = sub_1005BFB9C(*(void *)(a1 + 40));
    id v5 = (void *)objc_claimAutoreleasedReturnValue(v4);
    int v6 = *(_DWORD *)(a1 + 48);
    int v7 = *(unsigned __int8 *)(a1 + 58);
    *(_DWORD *)int buf = 134218754;
    uint64_t v10 = v3;
    __int16 v11 = 2114;
    uint64_t v12 = v5;
    __int16 v13 = 1024;
    int v14 = v6;
    __int16 v15 = 1024;
    int v16 = v7;
    _os_log_impl( (void *)&_mh_execute_header,  v2,  OS_LOG_TYPE_DEFAULT,  "LE Link disconnected for handle %p address %{public}@ with reason %d encryptionPending %d",  buf,  0x22u);
  }

  if (qword_1008D5F10 != -1) {
    dispatch_once(&qword_1008D5F10, &stru_1008A2B10);
  }
  return sub_1005A7D18( (uint64_t)off_1008D5F08,  *(void *)(a1 + 40),  *(void *)(a1 + 32),  *(unsigned __int16 *)(a1 + 56),  *(unsigned __int8 *)(a1 + 59),  *(unsigned int *)(a1 + 48),  *(unsigned __int8 *)(a1 + 60),  *(unsigned __int8 *)(a1 + 61),  *(_DWORD *)(a1 + 52));
}

uint64_t sub_1005B58C0(uint64_t a1)
{
  if (qword_1008D5F10 != -1) {
    dispatch_once(&qword_1008D5F10, &stru_1008A2B10);
  }
  return sub_1005AD204( (os_unfair_lock_s *)off_1008D5F08,  *(_DWORD *)(a1 + 40),  *(void *)(a1 + 32),  *(char *)(a1 + 44));
}

void sub_1005B5918(uint64_t a1, uint64_t a2, char a3)
{
  uint64_t v5 = sub_100404FE8();
  v6[0] = _NSConcreteStackBlock;
  v6[1] = 3221225472LL;
  void v6[2] = sub_1005B5980;
  uint64_t v6[3] = &unk_1008800D8;
  v6[4] = a2;
  char v7 = a3;
  sub_100405384(v5, v6);
}

uint64_t sub_1005B5980(uint64_t a1)
{
  if (qword_1008D5F10 != -1) {
    dispatch_once(&qword_1008D5F10, &stru_1008A2B10);
  }
  return sub_1005AD5C0((os_unfair_lock_s *)off_1008D5F08, *(void *)(a1 + 32), *(unsigned __int8 *)(a1 + 40));
}

void sub_1005B59D4(uint64_t a1, uint64_t a2, char a3, uint64_t a4, int a5, __int16 a6, int a7, int a8)
{
  *(_BYTE *)(a2 + 248) = a3;
  *(_DWORD *)(a2 + 252) = a4;
  *(_DWORD *)(a2 + 256) = a5;
  *(_WORD *)(a2 + 260) = a6;
  uint64_t v15 = sub_100404FE8();
  v16[0] = _NSConcreteStackBlock;
  v16[1] = 3221225472LL;
  void v16[2] = sub_1005B5A80;
  v16[3] = &unk_10089BBD8;
  char v21 = a3;
  _OWORD v16[4] = a2;
  v16[5] = a4;
  __int16 v20 = a6;
  int v17 = a5;
  int v18 = a7;
  int v19 = a8;
  sub_100405384(v15, v16);
}

uint64_t sub_1005B5A80(uint64_t a1)
{
  if (qword_1008D5F10 != -1) {
    dispatch_once(&qword_1008D5F10, &stru_1008A2B10);
  }
  return sub_1005AD764( (os_unfair_lock_s *)off_1008D5F08,  *(void *)(a1 + 32),  *(unsigned __int8 *)(a1 + 62),  *(void *)(a1 + 40),  *(_DWORD *)(a1 + 48),  *(unsigned __int16 *)(a1 + 60),  *(_DWORD *)(a1 + 52),  *(_DWORD *)(a1 + 56));
}

uint64_t sub_1005B5AE0(uint64_t a1)
{
  if (qword_1008D5F10 != -1) {
    dispatch_once(&qword_1008D5F10, &stru_1008A2B10);
  }
  return sub_1005AD9C4( (os_unfair_lock_s *)off_1008D5F08,  *(void *)(a1 + 32),  *(_DWORD *)(a1 + 48),  *(_DWORD *)(a1 + 52),  *(_DWORD *)(a1 + 56),  *(_DWORD *)(a1 + 60),  *(void *)(a1 + 40),  *(_BYTE *)(a1 + 70),  *(_DWORD *)(a1 + 71),  BYTE1(*(_DWORD *)(a1 + 71)),  BYTE2(*(_DWORD *)(a1 + 71)),  HIBYTE(*(_DWORD *)(a1 + 71)),  *(_WORD *)(a1 + 68),  *(_DWORD *)(a1 + 64),  *(_WORD *)(a1 + 75),  HIBYTE(*(_WORD *)(a1 + 75)));
}

void sub_1005B5B68(uint64_t a1, uint64_t a2, __int16 a3, __int16 a4, char a5, uint64_t a6, int a7)
{
  uint64_t v13 = sub_100404FE8();
  v14[0] = _NSConcreteStackBlock;
  v14[1] = 3221225472LL;
  void v14[2] = sub_1005B5BFC;
  void v14[3] = &unk_1008873C8;
  __int16 v16 = a3;
  __int16 v17 = a4;
  char v18 = a5;
  v14[4] = a2;
  v14[5] = a6;
  int v15 = a7;
  sub_100405384(v13, v14);
}

uint64_t sub_1005B5BFC(uint64_t a1)
{
  if (qword_1008D5F10 != -1) {
    dispatch_once(&qword_1008D5F10, &stru_1008A2B10);
  }
  return sub_1005ADEB8( (os_unfair_lock_s *)off_1008D5F08,  *(void *)(a1 + 32),  *(unsigned __int16 *)(a1 + 52),  *(unsigned __int16 *)(a1 + 54),  *(unsigned __int8 *)(a1 + 56),  *(void *)(a1 + 40),  *(_DWORD *)(a1 + 48));
}

void sub_1005B5C5C(uint64_t a1, uint64_t a2, __int128 *a3, int a4)
{
  uint64_t v7 = sub_100404FE8();
  v9[1] = 3221225472LL;
  __int128 v8 = a3[1];
  __int128 v10 = *a3;
  v9[0] = _NSConcreteStackBlock;
  void v9[2] = sub_1005B5CDC;
  v9[3] = &unk_1008A2968;
  void v9[4] = a2;
  __int128 v11 = v8;
  int v12 = a4;
  sub_100405384(v7, v9);
}

uint64_t sub_1005B5CDC(uint64_t a1)
{
  if (qword_1008D5F10 != -1) {
    dispatch_once(&qword_1008D5F10, &stru_1008A2B10);
  }
  uint64_t v2 = *(void *)(a1 + 32);
  __int128 v3 = *(_OWORD *)(a1 + 56);
  v5[0] = *(_OWORD *)(a1 + 40);
  v5[1] = v3;
  return sub_1005AE10C((os_unfair_lock_s *)off_1008D5F08, v2, (char *)v5, *(_DWORD *)(a1 + 72));
}

void sub_1005B5D4C(uint64_t a1, uint64_t a2, char a3, char a4)
{
  uint64_t v7 = sub_100404FE8();
  v8[0] = _NSConcreteStackBlock;
  v8[1] = 3221225472LL;
  v8[2] = sub_1005B5DC4;
  void v8[3] = &unk_1008878D8;
  v8[4] = a2;
  char v9 = a3;
  char v10 = a4;
  sub_100405384(v7, v8);
}

void sub_1005B5DC4(uint64_t a1)
{
  if (qword_1008D5F10 != -1) {
    dispatch_once(&qword_1008D5F10, &stru_1008A2B10);
  }
  sub_1005AE380( (os_unfair_lock_s *)off_1008D5F08,  *(void *)(a1 + 32),  *(unsigned __int8 *)(a1 + 40),  *(char *)(a1 + 41));
}

uint64_t sub_1005B5E1C(uint64_t a1)
{
  if (qword_1008D5F10 != -1) {
    dispatch_once(&qword_1008D5F10, &stru_1008A2B10);
  }
  return sub_1005AE528( (uint64_t)off_1008D5F08,  *(void *)(a1 + 32),  *(unsigned __int16 *)(a1 + 40),  *(_WORD *)(a1 + 42),  *(unsigned __int16 *)(a1 + 44));
}

uint64_t sub_1005B5E78(uint64_t a1)
{
  if (qword_1008D5F10 != -1) {
    dispatch_once(&qword_1008D5F10, &stru_1008A2B10);
  }
  return sub_1005AF114( (uint64_t)off_1008D5F08,  *(void *)(a1 + 32),  *(unsigned __int16 *)(a1 + 40),  *(_WORD *)(a1 + 42),  *(_WORD *)(a1 + 44),  *(_WORD *)(a1 + 46));
}

uint64_t sub_1005B5ED8(uint64_t a1)
{
  if (qword_1008D5F10 != -1) {
    dispatch_once(&qword_1008D5F10, &stru_1008A2B10);
  }
  return sub_1005AF964( (uint64_t)off_1008D5F08,  *(void *)(a1 + 32),  *(_DWORD *)(a1 + 40),  *(unsigned __int8 *)(a1 + 48),  *(_BYTE *)(a1 + 49),  *(_DWORD *)(a1 + 44));
}

uint64_t sub_1005B5F34(uint64_t a1)
{
  if (qword_1008D5F10 != -1) {
    dispatch_once(&qword_1008D5F10, &stru_1008A2B10);
  }
  return sub_1005B0394( (uint64_t)off_1008D5F08,  *(void *)(a1 + 32),  *(void *)(a1 + 40),  *(void *)(a1 + 48),  *(void *)(a1 + 56),  *(void *)(a1 + 64),  *(_DWORD *)(a1 + 80),  *(void *)(a1 + 72));
}

uint64_t sub_1005B5F90()
{
  if (qword_1008D5F10 != -1) {
    dispatch_once(&qword_1008D5F10, &stru_1008A2B10);
  }
  return sub_1005B05F4((uint64_t)off_1008D5F08);
}

uint64_t sub_1005B5FD0(uint64_t a1, unsigned __int8 *a2, uint64_t a3)
{
  int v6 = (os_log_s *)qword_1008F7620;
  if (os_log_type_enabled((os_log_t)qword_1008F7620, OS_LOG_TYPE_DEFAULT))
  {
    uint64_t v7 = sub_100241F94(a2);
    __int128 v8 = (void *)objc_claimAutoreleasedReturnValue(v7);
    *(_DWORD *)int buf = 138543874;
    int v19 = v8;
    __int16 v20 = 1040;
    int v21 = 5;
    __int16 v22 = 2096;
    uint64_t v23 = a3;
    _os_log_impl( (void *)&_mh_execute_header,  v6,  OS_LOG_TYPE_DEFAULT,  "setConnectionAFHMap for device %{public}@ with map %.5P",  buf,  0x1Cu);
  }

  if (a1 + 392 == sub_1001FDB10(a1 + 384, a2))
  {
    __int16 v16 = (os_log_s *)qword_1008F7620;
    if (os_log_type_enabled((os_log_t)qword_1008F7620, OS_LOG_TYPE_ERROR)) {
      sub_10069A4F8(a2, v16);
    }
    return 3LL;
  }

  else
  {
    buf[0] = 0;
    sub_100242CA4(buf);
    uint64_t v15 = sub_1001214B4(180, (uint64_t)sub_1005B616C, v9, v10, v11, v12, v13, v14, a3);
    if ((_DWORD)v15)
    {
      if (os_log_type_enabled((os_log_t)qword_1008F7620, OS_LOG_TYPE_ERROR)) {
        sub_10069A57C();
      }
      uint64_t v15 = 1LL;
    }

    sub_100242CD8(buf);
  }

  return v15;
}

void sub_1005B6150(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, ...)
{
}

void sub_1005B616C(int a1)
{
  uint64_t v2 = (os_log_s *)qword_1008F7620;
  if (os_log_type_enabled((os_log_t)qword_1008F7620, OS_LOG_TYPE_DEFAULT))
  {
    v3[0] = 67109120;
    v3[1] = a1;
    _os_log_impl( (void *)&_mh_execute_header,  v2,  OS_LOG_TYPE_DEFAULT,  "Set AFH status=%{bluetooth:OI_STATUS}u",  (uint8_t *)v3,  8u);
  }

uint64_t sub_1005B620C(uint64_t a1, int a2, uint64_t a3)
{
  uint64_t v6 = sub_1002E6BF0();
  int v7 = (*(uint64_t (**)(uint64_t))(*(void *)v6 + 888LL))(v6);
  uint64_t result = 0LL;
  switch(a2)
  {
    case 65536:
    case 65540:
    case 65555:
    case 65557:
      uint64_t v9 = 0LL;
      *(_WORD *)(a3 + 1) = 1;
      *(_BYTE *)(a3 + 3) = 0;
      int v45 = a2;
      if (a2 == 65555) {
        unsigned int v10 = 180000;
      }
      else {
        unsigned int v10 = 10000;
      }
      int32x2_t v11 = vdup_n_s32(v10);
      uint64_t v12 = (unsigned int *)(a3 + 16);
      do
      {
        if ((v9 & 4) != 0) {
          unsigned int v13 = 3;
        }
        else {
          unsigned int v13 = 1;
        }
        *(v12 - 1) = v13;
        *uint64_t v12 = v10;
        if (*(_BYTE *)(a1 + 1376))
        {
          *(int32x2_t *)(v12 - 3) = vdup_n_s32(48 * v10 / *(unsigned __int16 *)(a1 + 2LL * v13 + 256));
          int v14 = *(unsigned __int8 *)(a1 + 1380);
          if (*(_BYTE *)(a1 + 1380))
          {
            uint64_t v15 = (os_log_s *)qword_1008F7620;
            BOOL v16 = os_log_type_enabled((os_log_t)qword_1008F7620, OS_LOG_TYPE_DEBUG);
            unsigned int v17 = v10;
            if (v16)
            {
              char v18 = sub_100595B00(v45);
              *(_DWORD *)int buf = 136315906;
              unint64_t v48 = v18;
              __int16 v49 = 1024;
              int v50 = v9;
              __int16 v51 = 1024;
              unsigned int v52 = v10;
              __int16 v53 = 1024;
              int v54 = v14;
              _os_log_debug_impl( (void *)&_mh_execute_header,  v15,  OS_LOG_TYPE_DEBUG,  "Override %s Coex 0x%x connection  scan timeout %d extended by %d percent",  buf,  0x1Eu);
              int v14 = *(unsigned __int8 *)(a1 + 1380);
              unsigned int v17 = *v12;
            }

            *uint64_t v12 = v17 * ((656 * (v14 + 100)) >> 16);
          }
        }

        else
        {
          *(int32x2_t *)(v12 - 3) = v11;
        }

        ++v9;
        v12 += 5;
      }

      while (v9 != 16);
      goto LABEL_58;
    case 65537:
    case 65541:
    case 65560:
      uint64_t v29 = 0LL;
      *(_WORD *)(a3 + 1) = 257;
      *(_BYTE *)(a3 + 3) = 1;
      unsigned int v30 = v7 & 0xFFFFFFFE;
      int v31 = (int32x2_t *)(a3 + 20);
      do
      {
        if ((v29 & 5) != 0)
        {
          v31[-1].i32[1] = 600000;
          if ((v29 & 8) != 0 && _os_feature_enabled_impl("BluetoothFeatures", "ScanCorePolicyV2"))
          {
            int v32 = 0;
            v31->i32[0] = *(unsigned __int16 *)(a1 + 268) - 48;
          }

          else
          {
            int v32 = 0;
          }

          uint64_t v33 = 6LL;
        }

        else if ((v29 & 2) != 0)
        {
          *(int32x2_t *)((char *)&v31[-1] + 4) = (int32x2_t)0x1800004E20LL;
          int v32 = 1;
          uint64_t v33 = 4LL;
        }

        else
        {
          int v32 = 0;
          v31[-1].i32[1] = 10000;
          uint64_t v33 = 1LL;
        }

        v31[-1].i32[0] = v33;
        unsigned int v34 = v31[-1].u32[1];
        if (*(_BYTE *)(a1 + 1376))
        {
          unsigned int v35 = *(unsigned __int16 *)(a1 + 2 * v33 + 256);
          unsigned int v36 = 48 * v34 / v35;
          v31[-2].i32[1] = v36;
          if (v30 != 2) {
            int v32 = 0;
          }
          if (v32 == 1) {
            unsigned int v36 = (v31->i32[0] + 48) * v34 / v35;
          }
          v31[-2].i32[0] = v36;
          int v37 = *(unsigned __int8 *)(a1 + 1380);
          if (*(_BYTE *)(a1 + 1380))
          {
            float v38 = (os_log_s *)qword_1008F7620;
            if (os_log_type_enabled((os_log_t)qword_1008F7620, OS_LOG_TYPE_DEBUG))
            {
              uint64_t v39 = sub_100595B00(a2);
              *(_DWORD *)int buf = 136315906;
              unint64_t v48 = v39;
              __int16 v49 = 1024;
              int v50 = v29;
              __int16 v51 = 1024;
              unsigned int v52 = v34;
              __int16 v53 = 1024;
              int v54 = v37;
              _os_log_debug_impl( (void *)&_mh_execute_header,  v38,  OS_LOG_TYPE_DEBUG,  "Override %s Coex 0x%x connection  scan timeout %d extended by %d percent",  buf,  0x1Eu);
              int v37 = *(unsigned __int8 *)(a1 + 1380);
              unsigned int v34 = v31[-1].u32[1];
            }

            v31[-1].i32[1] = v34 * ((656 * (v37 + 100)) >> 16);
          }
        }

        else
        {
          v31[-2] = vdup_n_s32(v34);
        }

        ++v29;
        int v31 = (int32x2_t *)((char *)v31 + 20);
      }

      while (v29 != 16);
      goto LABEL_58;
    case 65538:
    case 65542:
    case 65556:
    case 65558:
      uint64_t v19 = 0LL;
      *(_WORD *)(a3 + 1) = 1;
      *(_BYTE *)(a3 + 3) = 0;
      int v46 = a2;
      if (a2 == 65556) {
        unsigned int v20 = 180000;
      }
      else {
        unsigned int v20 = 60000;
      }
      int32x2_t v21 = vdup_n_s32(v20);
      __int16 v22 = (unsigned int *)(a3 + 16);
      do
      {
        if ((v19 & 4) != 0) {
          int v23 = 3;
        }
        else {
          int v23 = 1;
        }
        *(v22 - 1) = v23;
        unsigned int *v22 = v20;
        *(int32x2_t *)(v22 - 3) = v21;
        if (*(_BYTE *)(a1 + 1376))
        {
          int v24 = *(unsigned __int8 *)(a1 + 1380);
          if (*(_BYTE *)(a1 + 1380))
          {
            uint64_t v25 = (os_log_s *)qword_1008F7620;
            BOOL v26 = os_log_type_enabled((os_log_t)qword_1008F7620, OS_LOG_TYPE_DEBUG);
            unsigned int v27 = v20;
            if (v26)
            {
              BOOL v28 = sub_100595B00(v46);
              *(_DWORD *)int buf = 136315906;
              unint64_t v48 = v28;
              __int16 v49 = 1024;
              int v50 = v19;
              __int16 v51 = 1024;
              unsigned int v52 = v20;
              __int16 v53 = 1024;
              int v54 = v24;
              _os_log_debug_impl( (void *)&_mh_execute_header,  v25,  OS_LOG_TYPE_DEBUG,  "Override %s Coex 0x%x connection  scan timeout %d extended by %d percent",  buf,  0x1Eu);
              int v24 = *(unsigned __int8 *)(a1 + 1380);
              unsigned int v27 = *v22;
            }

            unsigned int *v22 = v27 * ((656 * (v24 + 100)) >> 16);
          }
        }

        ++v19;
        v22 += 5;
      }

      while (v19 != 16);
      goto LABEL_58;
    case 65539:
    case 65543:
    case 65561:
      *(_WORD *)(a3 + 1) = 0;
      *(_BYTE *)(a3 + 3) = 0;
      *(_OWORD *)(a3 + 4) = xmmword_1006C41D0;
      if (*(_BYTE *)(a1 + 1376))
      {
        unsigned int v40 = *(unsigned __int8 *)(a1 + 1380);
        if (*(_BYTE *)(a1 + 1380))
        {
          int v41 = 600000;
          unsigned int v42 = (os_log_s *)qword_1008F7620;
          if (os_log_type_enabled((os_log_t)qword_1008F7620, OS_LOG_TYPE_DEBUG))
          {
            *(_DWORD *)int buf = 136315650;
            unint64_t v48 = sub_100595B00(a2);
            __int16 v49 = 1024;
            int v50 = 600000;
            __int16 v51 = 1024;
            unsigned int v52 = v40;
            _os_log_debug_impl( (void *)&_mh_execute_header,  v42,  OS_LOG_TYPE_DEBUG,  "Override %s Coex None connection  scan timeout %d extended by %d percent",  buf,  0x18u);
            unsigned int v40 = *(unsigned __int8 *)(a1 + 1380);
            int v41 = *(_DWORD *)(a3 + 16);
          }

          *(_DWORD *)(a3 + 16) = v41 * ((656 * (v40 + 100)) >> 16);
        }
      }

void sub_1005B67D8(uint64_t a1, void *a2, const void **a3, uint64_t a4, uint64_t a5, uint64_t a6)
{
  id v11 = a2;
  if (qword_1008D5F30 != -1) {
    dispatch_once(&qword_1008D5F30, &stru_1008A2B30);
  }
  int v12 = sub_1005CE2FC((uint64_t)off_1008D5F28, v11);
  int v57 = 0;
  memset(v56, 0, sizeof(v56));
  if ((sub_1005B620C(a1, v12, (uint64_t)v56) & 1) != 0)
  {
    if (a1 + 1360 == sub_100024098(a1 + 1352, a3))
    {
      if (os_log_type_enabled((os_log_t)qword_1008F7620, OS_LOG_TYPE_ERROR)) {
        sub_10069A5DC();
      }
    }

    else
    {
      *(void *)int buf = a3;
      unsigned int v13 = sub_1005BCFB4((uint64_t **)(a1 + 1352), a3, (uint64_t)&unk_1006C2518, (__int128 **)buf);
      uint64_t v14 = *((int *)v13 + 16);
      unsigned int v51 = *((_DWORD *)v13 + 15);
      unsigned int v52 = *((_DWORD *)v13 + 14);
      unsigned int v53 = *((_DWORD *)v13 + 17);
      uint64_t v15 = (void *)objc_claimAutoreleasedReturnValue(+[NSMutableDictionary dictionary](&OBJC_CLASS___NSMutableDictionary, "dictionary"));
      [v15 setObject:@"Connection" forKeyedSubscript:@"ScanType"];
      BOOL v16 = +[NSString stringWithUTF8String:](&OBJC_CLASS___NSString, "stringWithUTF8String:", sub_100595B00(v12));
      unsigned int v17 = (void *)objc_claimAutoreleasedReturnValue(v16);
      [v15 setObject:v17 forKeyedSubscript:@"CBUseCase"];

      if (qword_1008D92A8 != -1) {
        dispatch_once(&qword_1008D92A8, &stru_1008A2BB0);
      }
      id v18 = sub_10064D6E0(qword_1008D92A0, v11);
      int v50 = (void *)objc_claimAutoreleasedReturnValue(v18);
      uint64_t v19 = (void *)objc_claimAutoreleasedReturnValue([v50 allObjects]);
      int v54 = (void *)objc_claimAutoreleasedReturnValue(+[NSArray arrayWithArray:](&OBJC_CLASS___NSArray, "arrayWithArray:", v19));

      unsigned int v20 = (void *)objc_claimAutoreleasedReturnValue([v54 sortedArrayUsingSelector:"compare:"]);
      int v55 = v20;
      int32x2_t v21 = (void *)objc_claimAutoreleasedReturnValue([v20 componentsJoinedByString:@","]);
      [v15 setObject:v21 forKeyedSubscript:@"BundleID"];

      __int16 v22 = (void *)objc_claimAutoreleasedReturnValue( +[NSNumber numberWithBool:]( &OBJC_CLASS___NSNumber,  "numberWithBool:",  *(unsigned __int8 *)(a1 + 1376)));
      [v15 setObject:v22 forKeyedSubscript:@"IsFWBased"];

      else {
        int v23 = (&off_1008A2D58)[v14];
      }
      uint64_t v25 = (void *)objc_claimAutoreleasedReturnValue(+[NSString stringWithUTF8String:](&OBJC_CLASS___NSString, "stringWithUTF8String:", v23));
      [v15 setObject:v25 forKeyedSubscript:@"InitialConnScanParamsType"];

      LODWORD(v25) = BYTE3(v56[0]);
      BOOL v26 = (void *)objc_claimAutoreleasedReturnValue(+[NSNumber numberWithBool:](&OBJC_CLASS___NSNumber, "numberWithBool:", BYTE3(v56[0])));
      [v15 setObject:v26 forKeyedSubscript:@"IsWiFiCoexCriticalProtected"];

      unsigned int v27 = (void *)objc_claimAutoreleasedReturnValue(+[NSNumber numberWithBool:](&OBJC_CLASS___NSNumber, "numberWithBool:", BYTE2(v56[0])));
      [v15 setObject:v27 forKeyedSubscript:@"IsBTAudioProtected"];

      BOOL v28 = (void *)objc_claimAutoreleasedReturnValue(+[NSNumber numberWithBool:](&OBJC_CLASS___NSNumber, "numberWithBool:", (_DWORD)v25 != 0));
      [v15 setObject:v28 forKeyedSubscript:@"IsWiFi2_4GHzProtected"];

      uint64_t v29 = (void *)objc_claimAutoreleasedReturnValue( +[NSNumber numberWithUnsignedLongLong:]( &OBJC_CLASS___NSNumber,  "numberWithUnsignedLongLong:",  0LL));
      [v15 setObject:v29 forKeyedSubscript:@"WiFiCriticalDefinition"];

      unsigned int v30 = (void *)objc_claimAutoreleasedReturnValue(+[NSNumber numberWithUnsignedInt:](&OBJC_CLASS___NSNumber, "numberWithUnsignedInt:", v53));
      [v15 setObject:v30 forKeyedSubscript:@"ScanDurationReqMsec"];

      int v31 = (void *)objc_claimAutoreleasedReturnValue(+[NSNumber numberWithUnsignedInt:](&OBJC_CLASS___NSNumber, "numberWithUnsignedInt:", v52));
      [v15 setObject:v31 forKeyedSubscript:@"ActualScanTimeReqMsec"];

      int v32 = (void *)objc_claimAutoreleasedReturnValue(+[NSNumber numberWithUnsignedInt:](&OBJC_CLASS___NSNumber, "numberWithUnsignedInt:", v51));
      [v15 setObject:v32 forKeyedSubscript:@"ActualScanTimeMCReqMsec"];

      uint64_t v33 = (void *)objc_claimAutoreleasedReturnValue(+[NSNumber numberWithUnsignedLongLong:](&OBJC_CLASS___NSNumber, "numberWithUnsignedLongLong:", a6));
      [v15 setObject:v33 forKeyedSubscript:@"ScanDurationMsec"];

      unsigned int v34 = (void *)objc_claimAutoreleasedReturnValue(+[NSNumber numberWithUnsignedLongLong:](&OBJC_CLASS___NSNumber, "numberWithUnsignedLongLong:", a4));
      [v15 setObject:v34 forKeyedSubscript:@"ActualScanTimeMsec"];

      unsigned int v35 = (void *)objc_claimAutoreleasedReturnValue(+[NSNumber numberWithUnsignedLongLong:](&OBJC_CLASS___NSNumber, "numberWithUnsignedLongLong:", a5));
      [v15 setObject:v35 forKeyedSubscript:@"ActualScanTimeMCMsec"];

      if (v53) {
        unsigned int v36 = 100 * (int)a6 / v53;
      }
      else {
        unsigned int v36 = 0;
      }
      if (v36 <= 0x63) {
        uint64_t v37 = v36;
      }
      else {
        uint64_t v37 = 100LL;
      }
      if (v52) {
        unsigned int v38 = 100 * (int)a4 / v52;
      }
      else {
        unsigned int v38 = 0;
      }
      if (v38 <= 0x63) {
        uint64_t v39 = v38;
      }
      else {
        uint64_t v39 = 100LL;
      }
      if (v51) {
        unsigned int v40 = 100 * (int)a5 / v51;
      }
      else {
        unsigned int v40 = 0;
      }
      if (v40 <= 0x63) {
        uint64_t v41 = v40;
      }
      else {
        uint64_t v41 = 100LL;
      }
      unsigned int v42 = (void *)objc_claimAutoreleasedReturnValue(+[NSNumber numberWithUnsignedInt:](&OBJC_CLASS___NSNumber, "numberWithUnsignedInt:", v37));
      [v15 setObject:v42 forKeyedSubscript:@"ScanDurationMsecPercentage"];

      float v43 = (void *)objc_claimAutoreleasedReturnValue(+[NSNumber numberWithUnsignedInt:](&OBJC_CLASS___NSNumber, "numberWithUnsignedInt:", v39));
      [v15 setObject:v43 forKeyedSubscript:@"ActualScanTimeMsecPercentage"];

      BOOL v44 = (void *)objc_claimAutoreleasedReturnValue(+[NSNumber numberWithUnsignedInt:](&OBJC_CLASS___NSNumber, "numberWithUnsignedInt:", v41));
      [v15 setObject:v44 forKeyedSubscript:@"ActualScanTimeMCMsecPercentage"];

      int v45 = (void *)objc_claimAutoreleasedReturnValue(+[NSNumber numberWithBool:](&OBJC_CLASS___NSNumber, "numberWithBool:", v36 > 0x63));
      [v15 setObject:v45 forKeyedSubscript:@"HasScanDurationReqMet"];

      int v46 = (void *)objc_claimAutoreleasedReturnValue(+[NSNumber numberWithBool:](&OBJC_CLASS___NSNumber, "numberWithBool:", v38 > 0x63));
      [v15 setObject:v46 forKeyedSubscript:@"HasActualScanTimeReqMet"];

      uint64_t v47 = (void *)objc_claimAutoreleasedReturnValue(+[NSNumber numberWithBool:](&OBJC_CLASS___NSNumber, "numberWithBool:", v40 > 0x63));
      [v15 setObject:v47 forKeyedSubscript:@"HasActualScanTimeMCReqMet"];

      unint64_t v48 = (os_log_s *)qword_1008F7620;
      if (os_log_type_enabled((os_log_t)qword_1008F7620, OS_LOG_TYPE_DEFAULT))
      {
        *(_DWORD *)int buf = 138543362;
        *(void *)&uint8_t buf[4] = v15;
        _os_log_impl( (void *)&_mh_execute_header,  v48,  OS_LOG_TYPE_DEFAULT,  "Sending CloseLoopScanningStats :%{public}@",  buf,  0xCu);
      }

      uint64_t v49 = sub_1002E8D94();
      (*(void (**)(uint64_t, void *))(*(void *)v49 + 384LL))(v49, v15);
    }
  }

  else
  {
    int v24 = (os_log_s *)qword_1008F7620;
    if (os_log_type_enabled((os_log_t)qword_1008F7620, OS_LOG_TYPE_ERROR)) {
      sub_10069A648(v12, v24);
    }
  }
}

void sub_1005B6EEC( _Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, void *a9, uint64_t a10, uint64_t a11, void *a12)
{
  _Unwind_Resume(a1);
}

void sub_1005B7044(uint64_t a1)
{
  uint64_t v2 = *(void *)(a1 + 32);
  __int128 v3 = (os_log_s *)qword_1008F7620;
  if (os_log_type_enabled((os_log_t)qword_1008F7620, OS_LOG_TYPE_DEFAULT))
  {
    id v4 = (void *)(a1 + 40);
    uint64_t v5 = *(void *)(a1 + 64);
    uint64_t v6 = *(void *)(a1 + 72);
    uint64_t v7 = *(void *)(a1 + 80);
    int v8 = *(_DWORD *)(a1 + 88);
    *(_DWORD *)int buf = 136316162;
    *(void *)&uint8_t buf[4] = v4;
    *(_WORD *)&_BYTE buf[12] = 2048;
    *(void *)&buf[14] = v5;
    *(_WORD *)&_BYTE buf[22] = 2048;
    *(void *)&uint8_t buf[24] = v6;
    *(_WORD *)&uint8_t buf[32] = 2048;
    *(void *)&buf[34] = v7;
    __int16 v31 = 1024;
    int v32 = v8;
    _os_log_impl( (void *)&_mh_execute_header,  v3,  OS_LOG_TYPE_DEFAULT,  "handleConnScanRxStoppedCB: %s totalRx %llu btMCRx %llu totalTime %llu reason %d",  buf,  0x30u);
  }

  if (*(_DWORD *)(a1 + 88) == 1)
  {
    uint64_t v9 = *(const unsigned __int8 **)(v2 + 336);
    if (v9 != (const unsigned __int8 *)(v2 + 344))
    {
      unsigned int v10 = (const void **)(a1 + 40);
      do
      {
        memset(buf, 0, 37);
        uuid_unparse_upper(v9 + 25, buf);
        sub_10002418C(&__p, buf);
        if ((v29 & 0x80u) == 0) {
          size_t v11 = v29;
        }
        else {
          size_t v11 = __n;
        }
        uint64_t v12 = *(unsigned __int8 *)(a1 + 63);
        int v13 = (char)v12;
        if ((v12 & 0x80u) != 0LL) {
          uint64_t v12 = *(void *)(a1 + 48);
        }
        if (v11 == v12)
        {
          if (v13 >= 0) {
            uint64_t v14 = (unsigned __int8 *)(a1 + 40);
          }
          else {
            uint64_t v14 = (unsigned __int8 *)*v10;
          }
          if ((v29 & 0x80) != 0)
          {
            uint64_t v19 = __p;
            int v20 = memcmp(__p, v14, __n);
            operator delete(v19);
            if (!v20) {
              goto LABEL_37;
            }
          }

          else
          {
            if (!v29) {
              goto LABEL_37;
            }
            uint64_t v15 = 0LL;
            do
            {
              int v16 = *((unsigned __int8 *)&__p + v15);
              int v17 = v14[v15];
              BOOL v18 = v16 != v17 || v29 - 1LL == v15++;
            }

            while (!v18);
            if (v16 == v17)
            {
LABEL_37:
              int v23 = sub_100241F94(v9 + 25);
              int v24 = (void *)objc_claimAutoreleasedReturnValue(v23);
              if (*(char *)(a1 + 63) < 0)
              {
                sub_100024238(v25, *(void **)(a1 + 40), *(void *)(a1 + 48));
              }

              else
              {
                *(_OWORD *)uint64_t v25 = *(_OWORD *)v10;
                uint64_t v26 = *(void *)(a1 + 56);
              }

              sub_1005B67D8( v2,  v24,  (const void **)v25,  *(void *)(a1 + 64),  *(void *)(a1 + 72),  *(void *)(a1 + 80));
              if (SHIBYTE(v26) < 0) {
                operator delete(v25[0]);
              }
              sub_100241F90(buf, v24);
              sub_100597F98(v2, buf, 10LL);
              sub_100241F90(buf, v24);
              sub_1005A1444(v2, buf, 0, 344, 0);

              return;
            }
          }
        }

        else if ((v29 & 0x80) != 0)
        {
          operator delete(__p);
        }

        int32x2_t v21 = (unsigned __int8 *)*((void *)v9 + 1);
        if (v21)
        {
          do
          {
            __int16 v22 = (const unsigned __int8 **)v21;
            int32x2_t v21 = *(unsigned __int8 **)v21;
          }

          while (v21);
        }

        else
        {
          do
          {
            __int16 v22 = (const unsigned __int8 **)*((void *)v9 + 2);
            BOOL v18 = *v22 == v9;
            uint64_t v9 = (const unsigned __int8 *)v22;
          }

          while (!v18);
        }

        uint64_t v9 = (const unsigned __int8 *)v22;
      }

      while (v22 != (const unsigned __int8 **)(v2 + 344));
    }
  }

void sub_1005B7314( _Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, void *__p, uint64_t a10, int a11, __int16 a12, char a13, char a14)
{
  _Unwind_Resume(a1);
}

void sub_1005B735C(uint64_t a1, void *a2)
{
  id v3 = a2;
  uint64_t v4 = sub_100404FE8();
  v6[0] = _NSConcreteStackBlock;
  v6[1] = 3221225472LL;
  void v6[2] = sub_1005B740C;
  uint64_t v6[3] = &unk_1008800B8;
  uint64_t v8 = a1;
  id v5 = v3;
  id v7 = v5;
  sub_100405384(v4, v6);
}

void sub_1005B73EC( _Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, void *a13)
{
  _Unwind_Resume(a1);
}

void sub_1005B740C(uint64_t a1)
{
}

void sub_1005B741C(uint64_t a1, void *a2, int a3)
{
  id v5 = a2;
  uint64_t v6 = sub_1002E6E9C();
  sub_100241F90(uu2, v5);
  if (a1 + 1440 == sub_1001FDB10(a1 + 1432, uu2)) {
    goto LABEL_26;
  }
  uint64_t v57 = 0LL;
  __int128 __p = 0u;
  memset(uu2, 0, sizeof(uu2));
  sub_100241F90(__str, v5);
  *(void *)int buf = __str;
  id v7 = sub_1005BF060( (uint64_t **)(a1 + 1432),  __str,  (uint64_t)&unk_1006C2518,  (const unsigned __int8 *__attribute__((__org_typedef(uuid_t))) *)buf);
  *(void *)std::string uu2 = *((id *)v7 + 6);
  *(_OWORD *)&unsigned __int8 uu2[8] = *(_OWORD *)(v7 + 56);
  *(_OWORD *)&uu2[24] = *(_OWORD *)(v7 + 72);
  *(_DWORD *)&uu2[40] = *((_DWORD *)v7 + 22);
  sub_100272534(&__p, (uint64_t)(v7 + 96));
  *(void *)__str = 0LL;
  sub_1000B0400((uint64_t)__str);
  uint64_t v8 = *(int *)__str;
  uint64_t v9 = *(__int16 *)&__str[4];
  if ((a3 & 1) != 0)
  {
    BOOL v10 = 1;
    BOOL v11 = 1;
  }

  else if (*(_OWORD *)&uu2[24] == 0LL)
  {
    unint64_t v12 = *(__int16 *)&__str[4] - *(void *)&uu2[16] + 1000 * (*(int *)__str - *(void *)&uu2[8]);
    int v13 = *(_DWORD *)(a1 + 1480);
    *(_DWORD *)__str = v12 / 0x3E8;
    *(_DWORD *)&__str[4] = v12 % 0x3E8;
    *(_DWORD *)&uint8_t buf[4] = 0;
    *(_DWORD *)int buf = v13;
    BOOL v10 = 0;
    BOOL v11 = (int)sub_1001F42B8((uint64_t)__str, (uint64_t)buf) > 0;
  }

  else
  {
    unint64_t v14 = *(__int16 *)&__str[4] - *(void *)&uu2[32] + 1000 * (*(int *)__str - *(void *)&uu2[24]);
    int v15 = *(_DWORD *)(a1 + 1484);
    *(_DWORD *)__str = v14 / 0x3E8;
    *(_DWORD *)&__str[4] = v14 % 0x3E8;
    *(_DWORD *)&uint8_t buf[4] = 0;
    *(_DWORD *)int buf = v15;
    BOOL v10 = (int)sub_1001F42B8((uint64_t)__str, (uint64_t)buf) > 0;
    BOOL v11 = v10;
  }

  int v16 = (os_log_s *)qword_1008F7620;
  if (!os_log_type_enabled((os_log_t)qword_1008F7620, OS_LOG_TYPE_DEFAULT)) {
    goto LABEL_17;
  }
  __int128 v59 = 0u;
  __int128 v60 = 0u;
  memset(__str, 0, sizeof(__str));
  snprintf(__str, 0x3FuLL, "%0llu.%0llu", v8, v9);
  sub_10002418C(v42, __str);
  int v17 = v43;
  BOOL v18 = (void **)v42[0];
  sub_1005B8B90((uint64_t)uu2, (std::stringbuf::string_type *)__str);
  uint64_t v19 = v42;
  if (v17 < 0) {
    uint64_t v19 = v18;
  }
  if (__str[23] >= 0) {
    int v20 = __str;
  }
  else {
    int v20 = *(_BYTE **)__str;
  }
  *(_DWORD *)int buf = 138413570;
  *(void *)&uint8_t buf[4] = v5;
  __int16 v45 = 1024;
  int v46 = a3;
  __int16 v47 = 1024;
  BOOL v48 = v11;
  __int16 v49 = 1024;
  BOOL v50 = v10;
  __int16 v51 = 2080;
  unsigned int v52 = v19;
  __int16 v53 = 2080;
  int v54 = v20;
  _os_log_impl( (void *)&_mh_execute_header,  v16,  OS_LOG_TYPE_DEFAULT,  "LeConnectionDenyList: evaluateDenyListDevice incoming Device %@ forceUnblock=%d stopMonitoring=%d stopBlocking=%d Ti meNow:%ssec entry:%s",  buf,  0x32u);
  if ((__str[23] & 0x80000000) != 0) {
    operator delete(*(void **)__str);
  }
  if (v43 < 0)
  {
    operator delete(v42[0]);
    if (v10) {
      goto LABEL_18;
    }
  }

  else
  {
LABEL_17:
    if (v10)
    {
LABEL_18:
      uint64_t v21 = sub_1002E6E9C();
      if (qword_1008D5F30 != -1) {
        dispatch_once(&qword_1008D5F30, &stru_1008A2B30);
      }
      uint64_t v22 = sub_1005CC198((uint64_t)off_1008D5F28, v5, 0);
      (*(void (**)(uint64_t, uint64_t))(*(void *)v21 + 3616LL))(v21, v22);
    }
  }

  if (v11)
  {
    sub_100241F90(__str, v5);
    sub_1005BF1DC((uint64_t **)(a1 + 1432), __str);
  }

  if ((void)__p)
  {
    *((void *)&__p + 1) = __p;
    operator delete((void *)__p);
  }

LABEL_26:
  sub_100241F90(uu2, v5);
  if (a1 + 1464 == sub_1001FDB10(a1 + 1456, uu2)) {
    goto LABEL_65;
  }
  uint64_t v57 = 0LL;
  __int128 __p = 0u;
  memset(uu2, 0, sizeof(uu2));
  sub_100241F90(__str, v5);
  *(void *)int buf = __str;
  int v23 = sub_1005BF060( (uint64_t **)(a1 + 1456),  __str,  (uint64_t)&unk_1006C2518,  (const unsigned __int8 *__attribute__((__org_typedef(uuid_t))) *)buf);
  *(void *)std::string uu2 = *((id *)v23 + 6);
  *(_OWORD *)&unsigned __int8 uu2[8] = *(_OWORD *)(v23 + 56);
  *(_OWORD *)&uu2[24] = *(_OWORD *)(v23 + 72);
  *(_DWORD *)&uu2[40] = *((_DWORD *)v23 + 22);
  sub_100272534(&__p, (uint64_t)(v23 + 96));
  *(void *)__str = 0LL;
  sub_1000B0400((uint64_t)__str);
  uint64_t v24 = *(int *)__str;
  uint64_t v25 = *(__int16 *)&__str[4];
  if ((a3 & 1) != 0)
  {
    BOOL v26 = 1;
    BOOL v27 = 1;
  }

  else if (*(_OWORD *)&uu2[24] == 0LL)
  {
    unint64_t v28 = *(__int16 *)&__str[4] - *(void *)&uu2[16] + 1000 * (*(int *)__str - *(void *)&uu2[8]);
    int v29 = *(_DWORD *)(a1 + 1480);
    *(_DWORD *)__str = v28 / 0x3E8;
    *(_DWORD *)&__str[4] = v28 % 0x3E8;
    *(_DWORD *)&uint8_t buf[4] = 0;
    *(_DWORD *)int buf = v29;
    BOOL v26 = 0;
    BOOL v27 = (int)sub_1001F42B8((uint64_t)__str, (uint64_t)buf) > 0;
  }

  else
  {
    unint64_t v30 = *(__int16 *)&__str[4] - *(void *)&uu2[32] + 1000 * (*(int *)__str - *(void *)&uu2[24]);
    int v31 = *(_DWORD *)(a1 + 1484);
    *(_DWORD *)__str = v30 / 0x3E8;
    *(_DWORD *)&__str[4] = v30 % 0x3E8;
    *(_DWORD *)&uint8_t buf[4] = 0;
    *(_DWORD *)int buf = v31;
    BOOL v26 = (int)sub_1001F42B8((uint64_t)__str, (uint64_t)buf) > 0;
    BOOL v27 = v26;
  }

  int v32 = (os_log_s *)qword_1008F7620;
  if (!os_log_type_enabled((os_log_t)qword_1008F7620, OS_LOG_TYPE_DEFAULT)) {
    goto LABEL_42;
  }
  __int128 v59 = 0u;
  __int128 v60 = 0u;
  memset(__str, 0, sizeof(__str));
  snprintf(__str, 0x3FuLL, "%0llu.%0llu", v24, v25);
  sub_10002418C(v42, __str);
  int v33 = v43;
  unsigned int v34 = (void **)v42[0];
  sub_1005B8B90((uint64_t)uu2, (std::stringbuf::string_type *)__str);
  unsigned int v35 = v42;
  if (v33 < 0) {
    unsigned int v35 = v34;
  }
  if (__str[23] >= 0) {
    unsigned int v36 = __str;
  }
  else {
    unsigned int v36 = *(_BYTE **)__str;
  }
  *(_DWORD *)int buf = 138413570;
  *(void *)&uint8_t buf[4] = v5;
  __int16 v45 = 1024;
  int v46 = a3;
  __int16 v47 = 1024;
  BOOL v48 = v27;
  __int16 v49 = 1024;
  BOOL v50 = v26;
  __int16 v51 = 2080;
  unsigned int v52 = v35;
  __int16 v53 = 2080;
  int v54 = v36;
  _os_log_impl( (void *)&_mh_execute_header,  v32,  OS_LOG_TYPE_DEFAULT,  "LeConnectionDenyList: evaluateDenyListDevice outgoing Device %@ forceUnblock=%d stopMonitoring=%d stopBlocking=%d Ti meNow:%ssec entry:%s",  buf,  0x32u);
  if ((__str[23] & 0x80000000) != 0) {
    operator delete(*(void **)__str);
  }
  if ((v43 & 0x80000000) == 0)
  {
LABEL_42:
    if (!v27) {
      goto LABEL_44;
    }
    goto LABEL_43;
  }

  operator delete(v42[0]);
  if (v27)
  {
LABEL_43:
    sub_100241F90(__str, v5);
    sub_1005BF1DC((uint64_t **)(a1 + 1456), __str);
  }

void sub_1005B7CBC( _Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, void *__p, uint64_t a13, int a14, __int16 a15, char a16, char a17, uint64_t a18, uint64_t a19, uint64_t a20, uint64_t a21, uint64_t a22, uint64_t a23, uint64_t a24, uint64_t a25, uint64_t a26)
{
  _Unwind_Resume(a1);
}

void sub_1005B7D68(uint64_t a1, void *a2)
{
  id v3 = a2;
  uint64_t v4 = sub_100404FE8();
  v6[0] = _NSConcreteStackBlock;
  v6[1] = 3221225472LL;
  void v6[2] = sub_1005B7E18;
  uint64_t v6[3] = &unk_1008800B8;
  uint64_t v8 = a1;
  id v5 = v3;
  id v7 = v5;
  sub_100405384(v4, v6);
}

void sub_1005B7DF8( _Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, void *a13)
{
  _Unwind_Resume(a1);
}

void sub_1005B7E18(uint64_t a1)
{
}

void sub_1005B7E2C(uint64_t a1, void *a2)
{
  id v3 = a2;
  uint64_t v4 = sub_100404FE8();
  v6[0] = _NSConcreteStackBlock;
  v6[1] = 3221225472LL;
  void v6[2] = sub_1005B7EDC;
  uint64_t v6[3] = &unk_1008800B8;
  uint64_t v8 = a1;
  id v5 = v3;
  id v7 = v5;
  sub_100405384(v4, v6);
}

void sub_1005B7EBC( _Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, void *a13)
{
  _Unwind_Resume(a1);
}

void sub_1005B7EDC(uint64_t a1)
{
}

void sub_1005B7EEC(uint64_t a1, void *a2)
{
  id v3 = a2;
  uint64_t v4 = sub_100404FE8();
  v6[0] = _NSConcreteStackBlock;
  v6[1] = 3221225472LL;
  void v6[2] = sub_1005B7F9C;
  uint64_t v6[3] = &unk_1008800B8;
  uint64_t v8 = a1;
  id v5 = v3;
  id v7 = v5;
  sub_100405384(v4, v6);
}

void sub_1005B7F7C( _Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, void *a13)
{
  _Unwind_Resume(a1);
}

void sub_1005B7F9C(uint64_t a1)
{
}

void sub_1005B7FB0(uint64_t a1, void *a2)
{
  id v3 = a2;
  uint64_t v4 = sub_100404FE8();
  v6[0] = _NSConcreteStackBlock;
  v6[1] = 3221225472LL;
  void v6[2] = sub_1005B8060;
  uint64_t v6[3] = &unk_1008800B8;
  uint64_t v8 = a1;
  id v5 = v3;
  id v7 = v5;
  sub_100405384(v4, v6);
}

void sub_1005B8040( _Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, void *a13)
{
  _Unwind_Resume(a1);
}

void sub_1005B8060(uint64_t a1)
{
}

void sub_1005B8070(uint64_t a1)
{
  uint64_t v2 = *(void *)(a1 + 40);
  obj[0] = 0LL;
  sub_1000B0400((uint64_t)obj);
  id v3 = (void *)SLODWORD(obj[0]);
  uint64_t v4 = (void *)SWORD2(obj[0]);
  sub_100241F90(obj, *(void *)(a1 + 32));
  if (v2 + 1440 == sub_1001FDB10(v2 + 1432, (unsigned __int8 *)obj) || *(_BYTE *)(a1 + 52))
  {
    v66[0] = 0LL;
    *(_OWORD *)__int128 __p = 0u;
    memset(obj, 0, sizeof(obj));
    *(void *)int buf = 0LL;
    sub_1000B0400((uint64_t)buf);
    obj[1] = (id)*(int *)buf;
    obj[2] = (id)*(__int16 *)&buf[4];
    if (*(_BYTE *)(a1 + 52))
    {
      obj[3] = (id)*(int *)buf;
      obj[4] = (id)*(__int16 *)&buf[4];
      LODWORD(obj[5]) = *(_DWORD *)(v2 + 1488);
      if (LODWORD(obj[5]))
      {
        unsigned int v5 = 0;
        uint64_t v6 = (char *)__p[1];
        do
        {
          if ((unint64_t)v6 >= v66[0])
          {
            uint64_t v8 = (char *)__p[0];
            uint64_t v9 = (v6 - (char *)__p[0]) >> 2;
            unint64_t v10 = v9 + 1;
            int64_t v11 = v66[0] - (unint64_t)__p[0];
            else {
              unint64_t v12 = v10;
            }
            if (v12)
            {
              int v13 = (char *)sub_10024E33C((uint64_t)v66, v12);
              uint64_t v8 = (char *)__p[0];
              uint64_t v6 = (char *)__p[1];
            }

            else
            {
              int v13 = 0LL;
            }

            unint64_t v14 = &v13[4 * v9];
            *(_DWORD *)unint64_t v14 = *(_DWORD *)(a1 + 48);
            id v7 = v14 + 4;
            while (v6 != v8)
            {
              int v15 = *((_DWORD *)v6 - 1);
              v6 -= 4;
              *((_DWORD *)v14 - 1) = v15;
              v14 -= 4;
            }

            __p[0] = v14;
            __p[1] = v7;
            v66[0] = &v13[4 * v12];
            if (v8) {
              operator delete(v8);
            }
          }

          else
          {
            *(_DWORD *)uint64_t v6 = *(_DWORD *)(a1 + 48);
            id v7 = v6 + 4;
          }

          __p[1] = v7;
          ++v5;
          uint64_t v6 = (char *)v7;
        }

        while (v5 < LODWORD(obj[5]));
      }
    }

    else
    {
      memset(&obj[3], 0, 20);
    }

    sub_100241F90(buf, *(void *)(a1 + 32));
    *(void *)uint64_t v57 = buf;
    int v16 = sub_1005BF060( (uint64_t **)(v2 + 1432),  buf,  (uint64_t)&unk_1006C2518,  (const unsigned __int8 *__attribute__((__org_typedef(uuid_t))) *)v57);
    objc_storeStrong((id *)v16 + 6, obj[0]);
    if (v16 + 48 == (unsigned __int8 *)obj)
    {
      *((_DWORD *)v16 + 22) = obj[5];
    }

    else
    {
      *(_OWORD *)(v16 + 56) = *(_OWORD *)&obj[1];
      *(_OWORD *)(v16 + 72) = *(_OWORD *)&obj[3];
      *((_DWORD *)v16 + 22) = obj[5];
      sub_100272430((char *)v16 + 96, (char *)__p[0], (uint64_t)__p[1], ((char *)__p[1] - (char *)__p[0]) >> 2);
    }

    int v17 = *(unsigned __int8 *)(a1 + 52);
    BOOL v18 = (os_log_s *)qword_1008F7620;
    if (os_log_type_enabled((os_log_t)qword_1008F7620, OS_LOG_TYPE_DEFAULT))
    {
      uint64_t v19 = "and blocking (forced)";
      uint64_t v20 = *(void *)(a1 + 32);
      if (!v17) {
        uint64_t v19 = " ";
      }
      *(_DWORD *)int buf = 138412546;
      *(void *)&uint8_t buf[4] = v20;
      *(_WORD *)&_BYTE buf[12] = 2080;
      *(void *)&buf[14] = v19;
      _os_log_impl( (void *)&_mh_execute_header,  v18,  OS_LOG_TYPE_DEFAULT,  "LeConnectionDenyList: evaluateIncomingDisconnection Device %@ disconnected now, started monitoring %s",  buf,  0x16u);
    }

    if (__p[0])
    {
      __p[1] = __p[0];
      operator delete(__p[0]);
    }

    if (!v17) {
      goto LABEL_38;
    }
    goto LABEL_35;
  }

  v66[0] = 0LL;
  *(_OWORD *)__int128 __p = 0u;
  memset(obj, 0, sizeof(obj));
  sub_100241F90(buf, *(void *)(a1 + 32));
  *(void *)uint64_t v57 = buf;
  int v23 = sub_1005BF060( (uint64_t **)(v2 + 1432),  buf,  (uint64_t)&unk_1006C2518,  (const unsigned __int8 *__attribute__((__org_typedef(uuid_t))) *)v57);
  obj[0] = *((id *)v23 + 6);
  *(_OWORD *)&obj[1] = *(_OWORD *)(v23 + 56);
  *(_OWORD *)&obj[3] = *(_OWORD *)(v23 + 72);
  LODWORD(obj[5]) = *((_DWORD *)v23 + 22);
  sub_100272534(__p, (uint64_t)(v23 + 96));
  unint64_t v24 = (_BYTE *)v4 - (char *)obj[2] + 1000 * ((void)v3 - (unint64_t)obj[1]);
  unint64_t v25 = v24 / 0x3E8;
  int v26 = *(_DWORD *)(v2 + 1480);
  *(_WORD *)&buf[6] = 0;
  *(_DWORD *)int buf = v24 / 0x3E8;
  unint64_t v27 = v24 % 0x3E8;
  *(_WORD *)&uint8_t buf[4] = v24 % 0x3E8;
  *(_DWORD *)&v57[4] = 0;
  *(_DWORD *)uint64_t v57 = v26;
  int v28 = sub_1001F42B8((uint64_t)buf, (uint64_t)v57);
  if (v28 < 0)
  {
    ++LODWORD(obj[5]);
    obj[1] = v3;
    obj[2] = v4;
    int v33 = (char *)__p[1];
    if (__p[1] >= (void *)v66[0])
    {
      unsigned int v35 = (char *)__p[0];
      int64_t v36 = ((char *)__p[1] - (char *)__p[0]) >> 2;
      unint64_t v37 = v36 + 1;
      int64_t v38 = v66[0] - (unint64_t)__p[0];
      else {
        unint64_t v39 = v37;
      }
      if (v39)
      {
        unsigned int v40 = (char *)sub_10024E33C((uint64_t)v66, v39);
        unsigned int v35 = (char *)__p[0];
        int v33 = (char *)__p[1];
      }

      else
      {
        unsigned int v40 = 0LL;
      }

      uint64_t v41 = &v40[4 * v36];
      unsigned int v42 = &v40[4 * v39];
      *(_DWORD *)uint64_t v41 = *(_DWORD *)(a1 + 48);
      unsigned int v34 = v41 + 4;
      while (v33 != v35)
      {
        int v43 = *((_DWORD *)v33 - 1);
        v33 -= 4;
        *((_DWORD *)v41 - 1) = v43;
        v41 -= 4;
      }

      __p[0] = v41;
      __p[1] = v34;
      v66[0] = v42;
      if (v35) {
        operator delete(v35);
      }
    }

    else
    {
      *(_DWORD *)__p[1] = *(_DWORD *)(a1 + 48);
      unsigned int v34 = v33 + 4;
    }

    __p[1] = v34;
    BOOL v44 = (os_log_s *)qword_1008F7620;
    if (os_log_type_enabled((os_log_t)qword_1008F7620, OS_LOG_TYPE_DEFAULT))
    {
      uint64_t v45 = *(void *)(a1 + 32);
      __int128 v68 = 0u;
      __int128 v69 = 0u;
      memset(buf, 0, sizeof(buf));
      snprintf((char *)buf, 0x3FuLL, "%0llu.%0llu", v25, v27);
      sub_10002418C(v53, (char *)buf);
      int v46 = v56 >= 0 ? v53 : *(_BYTE **)v53;
      int v47 = *(_DWORD *)(a1 + 48);
      *(_DWORD *)uint64_t v57 = 138413058;
      *(void *)&v57[4] = v45;
      __int16 v58 = 2080;
      __int128 v59 = v46;
      __int16 v60 = 1024;
      int v61 = (int)obj[5];
      __int16 v62 = 1024;
      int v63 = v47;
      _os_log_impl( (void *)&_mh_execute_header,  v44,  OS_LOG_TYPE_DEFAULT,  "LeConnectionDenyList: evaluateIncomingDisconnection Device %@ disconnected %s seconds ago, increasing counter to %d, disconnectResult=%d",  v57,  0x22u);
      if (v56 < 0) {
        operator delete(*(void **)v53);
      }
    }

    int v48 = (int)obj[5];
    unsigned int v49 = *(_DWORD *)(v2 + 1488);
    BOOL v30 = LODWORD(obj[5]) >= v49;
    if (LODWORD(obj[5]) >= v49)
    {
      obj[3] = v3;
      obj[4] = v4;
      BOOL v50 = (os_log_s *)qword_1008F7620;
      if (os_log_type_enabled((os_log_t)qword_1008F7620, OS_LOG_TYPE_DEFAULT))
      {
        uint64_t v51 = *(void *)(a1 + 32);
        *(_DWORD *)int buf = 138412546;
        *(void *)&uint8_t buf[4] = v51;
        *(_WORD *)&_BYTE buf[12] = 1024;
        *(_DWORD *)&buf[14] = v48;
        _os_log_impl( (void *)&_mh_execute_header,  v50,  OS_LOG_TYPE_DEFAULT,  "LeConnectionDenyList: evaluateIncomingDisconnection Device %@ disconnected, counter:%d started blocking",  buf,  0x12u);
      }
    }

    sub_100241F90(buf, *(void *)(a1 + 32));
    *(void *)uint64_t v57 = buf;
    unsigned int v52 = sub_1005BF060( (uint64_t **)(v2 + 1432),  buf,  (uint64_t)&unk_1006C2518,  (const unsigned __int8 *__attribute__((__org_typedef(uuid_t))) *)v57);
    objc_storeStrong((id *)v52 + 6, obj[0]);
    if (v52 + 48 == (unsigned __int8 *)obj)
    {
      *((_DWORD *)v52 + 22) = obj[5];
    }

    else
    {
      *(_OWORD *)(v52 + 56) = *(_OWORD *)&obj[1];
      *(_OWORD *)(v52 + 72) = *(_OWORD *)&obj[3];
      *((_DWORD *)v52 + 22) = obj[5];
      sub_100272430((char *)v52 + 96, (char *)__p[0], (uint64_t)__p[1], ((char *)__p[1] - (char *)__p[0]) >> 2);
    }
  }

  else
  {
    sub_100241F90(buf, *(void *)(a1 + 32));
    sub_1005BF1DC((uint64_t **)(v2 + 1432), buf);
    int v29 = (os_log_s *)qword_1008F7620;
    BOOL v30 = 0;
    if (os_log_type_enabled((os_log_t)qword_1008F7620, OS_LOG_TYPE_DEFAULT))
    {
      uint64_t v31 = *(void *)(a1 + 32);
      __int128 v68 = 0u;
      __int128 v69 = 0u;
      memset(buf, 0, sizeof(buf));
      snprintf((char *)buf, 0x3FuLL, "%0llu.%0llu", v25, v27);
      sub_10002418C(v57, (char *)buf);
      if (v60 >= 0) {
        int v32 = v57;
      }
      else {
        int v32 = *(_BYTE **)v57;
      }
      *(_DWORD *)__int16 v53 = 138412546;
      *(void *)&v53[4] = v31;
      __int16 v54 = 2080;
      int v55 = v32;
      _os_log_impl( (void *)&_mh_execute_header,  v29,  OS_LOG_TYPE_DEFAULT,  "LeConnectionDenyList: evaluateIncomingDisconnection  Device %@ disconnected %s seconds ago, stop monitoring",  v53,  0x16u);
      if (SHIBYTE(v60) < 0) {
        operator delete(*(void **)v57);
      }
      BOOL v30 = 0;
    }
  }

  if (__p[0])
  {
    __p[1] = __p[0];
    operator delete(__p[0]);
  }

  if (v28 < 0)
  {
    if (!v30)
    {
LABEL_38:
      sub_1005B88E0(v2);
      return;
    }

void sub_1005B8854( _Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, ...)
{
}

uint64_t sub_1005B88A8(uint64_t a1)
{
  uint64_t v2 = *(void **)(a1 + 48);
  if (v2)
  {
    *(void *)(a1 + 56) = v2;
    operator delete(v2);
  }

  return a1;
}

void sub_1005B88E0(uint64_t a1)
{
  uint64_t v2 = sub_1002E6E9C();
  if ((*(unsigned int (**)(uint64_t))(*(void *)v2 + 2752LL))(v2))
  {
    id v3 = (os_log_s *)qword_1008F7620;
    if (os_log_type_enabled((os_log_t)qword_1008F7620, OS_LOG_TYPE_DEFAULT))
    {
      uint64_t v4 = *(void *)(a1 + 1448);
      LODWORD(v18) = 134217984;
      *(void *)((char *)&v18 + 4) = v4;
      _os_log_impl( (void *)&_mh_execute_header,  v3,  OS_LOG_TYPE_DEFAULT,  "LeConnectionDenyList: LeConnectionManager::evaluateDenyListDevices incoming devices:%lu",  (uint8_t *)&v18,  0xCu);
    }

    if (*(void *)(a1 + 1448))
    {
      __int128 v18 = 0uLL;
      uint64_t v19 = 0LL;
      sub_1005BF234((uint64_t *)&v18, a1 + 1432);
      unsigned int v5 = (const unsigned __int8 *)v18;
      if ((__int128 *)v18 != (__int128 *)((char *)&v18 + 8))
      {
        do
        {
          uint64_t v6 = sub_100241F94(v5 + 32);
          id v7 = (void *)objc_claimAutoreleasedReturnValue(v6);
          sub_1005B741C(a1, v7, 0);

          uint64_t v8 = (const unsigned __int8 *)*((void *)v5 + 1);
          if (v8)
          {
            do
            {
              uint64_t v9 = v8;
              uint64_t v8 = *(const unsigned __int8 **)v8;
            }

            while (v8);
          }

          else
          {
            do
            {
              uint64_t v9 = (const unsigned __int8 *)*((void *)v5 + 2);
              BOOL v10 = *(void *)v9 == (void)v5;
              unsigned int v5 = v9;
            }

            while (!v10);
          }

          unsigned int v5 = v9;
        }

        while (v9 != (const unsigned __int8 *)((char *)&v18 + 8));
      }

      sub_1005B8DE0(a1);
      sub_1005BC2E8((uint64_t)&v18, *((void **)&v18 + 1));
    }
  }

  if (_os_feature_enabled_impl("BluetoothFeatures", "OutgoingLeConnectionDenyList"))
  {
    int64_t v11 = (os_log_s *)qword_1008F7620;
    if (os_log_type_enabled((os_log_t)qword_1008F7620, OS_LOG_TYPE_DEFAULT))
    {
      uint64_t v12 = *(void *)(a1 + 1472);
      LODWORD(v18) = 134217984;
      *(void *)((char *)&v18 + 4) = v12;
      _os_log_impl( (void *)&_mh_execute_header,  v11,  OS_LOG_TYPE_DEFAULT,  "LeConnectionDenyList: LeConnectionManager::evaluateDenyListDevices outgoing devices:%lu",  (uint8_t *)&v18,  0xCu);
    }

    if (*(void *)(a1 + 1472))
    {
      __int128 v18 = 0uLL;
      uint64_t v19 = 0LL;
      sub_1005BF234((uint64_t *)&v18, a1 + 1456);
      int v13 = (const unsigned __int8 *)v18;
      if ((__int128 *)v18 != (__int128 *)((char *)&v18 + 8))
      {
        do
        {
          unint64_t v14 = sub_100241F94(v13 + 32);
          int v15 = (void *)objc_claimAutoreleasedReturnValue(v14);
          sub_1005B741C(a1, v15, 0);

          int v16 = (const unsigned __int8 *)*((void *)v13 + 1);
          if (v16)
          {
            do
            {
              int v17 = v16;
              int v16 = *(const unsigned __int8 **)v16;
            }

            while (v16);
          }

          else
          {
            do
            {
              int v17 = (const unsigned __int8 *)*((void *)v13 + 2);
              BOOL v10 = *(void *)v17 == (void)v13;
              int v13 = v17;
            }

            while (!v10);
          }

          int v13 = v17;
        }

        while (v17 != (const unsigned __int8 *)((char *)&v18 + 8));
      }

      sub_1005B8DE0(a1);
      sub_1005BC2E8((uint64_t)&v18, *((void **)&v18 + 1));
    }
  }

void sub_1005B8B4C( _Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, void *a10)
{
}

uint64_t sub_1005B8B90@<X0>(uint64_t a1@<X0>, std::stringbuf::string_type *a2@<X8>)
{
  uint64_t v30 = 0LL;
  __int128 v28 = 0u;
  memset(v29, 0, sizeof(v29));
  *(_OWORD *)int v26 = 0u;
  __int128 v27 = 0u;
  memset(v25, 0, sizeof(v25));
  __int128 v24 = 0u;
  sub_1001FCFC8((uint64_t)&v24);
  uint64_t v4 = (void *)std::ostream::operator<<(v25, *(void *)a1 != 0LL);
  unsigned int v5 = sub_1001FD17C(v4, (uint64_t)" fRecentDisconnectTime", 22LL);
  sub_10038FCC8((void *)(a1 + 8), v22);
  if ((v23 & 0x80u) == 0) {
    uint64_t v6 = v22;
  }
  else {
    uint64_t v6 = (void **)v22[0];
  }
  if ((v23 & 0x80u) == 0) {
    uint64_t v7 = v23;
  }
  else {
    uint64_t v7 = (uint64_t)v22[1];
  }
  uint64_t v8 = sub_1001FD17C(v5, (uint64_t)v6, v7);
  uint64_t v9 = sub_1001FD17C(v8, (uint64_t)" fStartBlockingTime:", 20LL);
  sub_10038FCC8((void *)(a1 + 24), __p);
  if ((v21 & 0x80u) == 0) {
    BOOL v10 = __p;
  }
  else {
    BOOL v10 = (void **)__p[0];
  }
  if ((v21 & 0x80u) == 0) {
    uint64_t v11 = v21;
  }
  else {
    uint64_t v11 = (uint64_t)__p[1];
  }
  uint64_t v12 = sub_1001FD17C(v9, (uint64_t)v10, v11);
  int v13 = sub_1001FD17C(v12, (uint64_t)" fDisconnectCount:", 18LL);
  unint64_t v14 = (void *)std::ostream::operator<<(v13, *(unsigned int *)(a1 + 40));
  sub_1001FD17C(v14, (uint64_t)" DisconnectResults:", 19LL);
  int v15 = *(unsigned int **)(a1 + 48);
  for (uint64_t i = *(unsigned int **)(a1 + 56); v15 != i; ++v15)
  {
    int v17 = (void *)std::ostream::operator<<(v25, *v15);
    sub_1001FD17C(v17, (uint64_t)" ", 1LL);
  }

  std::stringbuf::str(a2, (const std::stringbuf *)((char *)v25 + 8));
  *(void *)((char *)&v25[-1]
  *(void *)&v25[0] = v18;
  if (SHIBYTE(v27) < 0) {
    operator delete(v26[1]);
  }
  std::streambuf::~streambuf((char *)v25 + 8);
  return std::ios::~ios(v29);
}

void sub_1005B8D90( _Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, void *a9, uint64_t a10, int a11, __int16 a12, char a13, char a14, void *__p, uint64_t a16, int a17, __int16 a18, char a19, char a20, char a21)
{
  if (a20 < 0) {
    operator delete(__p);
  }
  sub_1001FD0F4((uint64_t)&a21);
  _Unwind_Resume(a1);
}

void sub_1005B8DE0(uint64_t a1)
{
  if (*(void *)(a1 + 1496) || sub_1005B8F80(a1) && (sub_1005B9748(a1) & 1) != 0)
  {
    sub_10059189C(a1);
  }

  else
  {
    unint64_t v2 = (1000 * *(_DWORD *)(a1 + 1484)) / 0xAuLL;
    id v3 = (os_log_s *)qword_1008F7620;
    if (os_log_type_enabled((os_log_t)qword_1008F7620, OS_LOG_TYPE_DEFAULT))
    {
      *(_DWORD *)int buf = 134217984;
      unint64_t v10 = v2;
      _os_log_impl( (void *)&_mh_execute_header,  v3,  OS_LOG_TYPE_DEFAULT,  "LeConnectionDenyList: armPeriodicLeConnectionDenyListTimer %llu ms Armed!",  buf,  0xCu);
    }

    uint64_t v4 = sub_100404FE8();
    unsigned int v5 = dispatch_source_create( (dispatch_source_type_t)&_dispatch_source_type_timer,  0LL,  0LL,  *(dispatch_queue_t *)(v4 + 8));
    *(void *)(a1 + 1496) = v5;
    handler[0] = _NSConcreteStackBlock;
    handler[1] = 3221225472LL;
    handler[2] = sub_1005B97B0;
    handler[3] = &unk_10087EB20;
    handler[4] = a1;
    dispatch_source_set_event_handler(v5, handler);
    uint64_t v6 = *(dispatch_source_s **)(a1 + 1496);
    dispatch_time_t v7 = dispatch_time(0x8000000000000000LL, 1000000LL * v2);
    dispatch_source_set_timer(v6, v7, 0xFFFFFFFFFFFFFFFFLL, 0LL);
    dispatch_activate(*(dispatch_object_t *)(a1 + 1496));
  }

uint64_t sub_1005B8F80(uint64_t a1)
{
  int v1 = *(void **)(a1 + 1432);
  if (v1 == (void *)(a1 + 1440)) {
    return 1LL;
  }
  while (!v1[9] && !v1[10])
  {
    unint64_t v2 = (void *)v1[1];
    if (v2)
    {
      do
      {
        id v3 = v2;
        unint64_t v2 = (void *)*v2;
      }

      while (v2);
    }

    else
    {
      do
      {
        id v3 = (void *)v1[2];
        BOOL v4 = *v3 == (void)v1;
        int v1 = v3;
      }

      while (!v4);
    }

    int v1 = v3;
    if (v3 == (void *)(a1 + 1440)) {
      return 1LL;
    }
  }

  return 0LL;
}

void sub_1005B8FE8(uint64_t a1)
{
  uint64_t v2 = *(void *)(a1 + 40);
  obj[0] = 0LL;
  sub_1000B0400((uint64_t)obj);
  id v3 = (void *)SLODWORD(obj[0]);
  BOOL v4 = (void *)SWORD2(obj[0]);
  sub_100241F90(obj, *(void *)(a1 + 32));
  if (v2 + 1464 == sub_1001FDB10(v2 + 1456, (unsigned __int8 *)obj) || *(_BYTE *)(a1 + 52))
  {
    v58[0] = 0LL;
    *(_OWORD *)__int128 __p = 0u;
    memset(obj, 0, sizeof(obj));
    *(void *)int buf = 0LL;
    sub_1000B0400((uint64_t)buf);
    obj[1] = (id)*(int *)buf;
    obj[2] = (id)*(__int16 *)&buf[4];
    if (*(_BYTE *)(a1 + 52))
    {
      obj[3] = (id)*(int *)buf;
      obj[4] = (id)*(__int16 *)&buf[4];
      LODWORD(obj[5]) = *(_DWORD *)(v2 + 1488);
      if (LODWORD(obj[5]))
      {
        unsigned int v5 = 0;
        uint64_t v6 = (char *)__p[1];
        do
        {
          if ((unint64_t)v6 >= v58[0])
          {
            uint64_t v8 = (char *)__p[0];
            uint64_t v9 = (v6 - (char *)__p[0]) >> 2;
            unint64_t v10 = v9 + 1;
            int64_t v11 = v58[0] - (unint64_t)__p[0];
            else {
              unint64_t v12 = v10;
            }
            if (v12)
            {
              int v13 = (char *)sub_10024E33C((uint64_t)v58, v12);
              uint64_t v8 = (char *)__p[0];
              uint64_t v6 = (char *)__p[1];
            }

            else
            {
              int v13 = 0LL;
            }

            unint64_t v14 = &v13[4 * v9];
            *(_DWORD *)unint64_t v14 = *(_DWORD *)(a1 + 48);
            dispatch_time_t v7 = v14 + 4;
            while (v6 != v8)
            {
              int v15 = *((_DWORD *)v6 - 1);
              v6 -= 4;
              *((_DWORD *)v14 - 1) = v15;
              v14 -= 4;
            }

            __p[0] = v14;
            __p[1] = v7;
            v58[0] = &v13[4 * v12];
            if (v8) {
              operator delete(v8);
            }
          }

          else
          {
            *(_DWORD *)uint64_t v6 = *(_DWORD *)(a1 + 48);
            dispatch_time_t v7 = v6 + 4;
          }

          __p[1] = v7;
          ++v5;
          uint64_t v6 = (char *)v7;
        }

        while (v5 < LODWORD(obj[5]));
      }
    }

    else
    {
      memset(&obj[3], 0, 20);
    }

    sub_100241F90(buf, *(void *)(a1 + 32));
    *(void *)unsigned int v49 = buf;
    int v16 = sub_1005BF060( (uint64_t **)(v2 + 1456),  buf,  (uint64_t)&unk_1006C2518,  (const unsigned __int8 *__attribute__((__org_typedef(uuid_t))) *)v49);
    objc_storeStrong((id *)v16 + 6, obj[0]);
    if (v16 + 48 == (unsigned __int8 *)obj)
    {
      *((_DWORD *)v16 + 22) = obj[5];
    }

    else
    {
      *(_OWORD *)(v16 + 56) = *(_OWORD *)&obj[1];
      *(_OWORD *)(v16 + 72) = *(_OWORD *)&obj[3];
      *((_DWORD *)v16 + 22) = obj[5];
      sub_100272430((char *)v16 + 96, (char *)__p[0], (uint64_t)__p[1], ((char *)__p[1] - (char *)__p[0]) >> 2);
    }

    int v17 = (os_log_s *)qword_1008F7620;
    if (os_log_type_enabled((os_log_t)qword_1008F7620, OS_LOG_TYPE_DEFAULT))
    {
      uint64_t v18 = *(void *)(a1 + 32);
      uint64_t v19 = "and blocking (forced)";
      if (!*(_BYTE *)(a1 + 52)) {
        uint64_t v19 = " ";
      }
      *(_DWORD *)int buf = 138412546;
      *(void *)&uint8_t buf[4] = v18;
      *(_WORD *)&_BYTE buf[12] = 2080;
      *(void *)&buf[14] = v19;
      _os_log_impl( (void *)&_mh_execute_header,  v17,  OS_LOG_TYPE_DEFAULT,  "LeConnectionDenyList: evaluateOutgoingDisconnection Device %@ disconnected now, started monitoring %s",  buf,  0x16u);
    }

    if (__p[0])
    {
      __p[1] = __p[0];
      operator delete(__p[0]);
    }

LABEL_35:
    sub_1005B88E0(v2);
    return;
  }

  v58[0] = 0LL;
  *(_OWORD *)__int128 __p = 0u;
  memset(obj, 0, sizeof(obj));
  sub_100241F90(buf, *(void *)(a1 + 32));
  *(void *)unsigned int v49 = buf;
  uint64_t v20 = sub_1005BF060( (uint64_t **)(v2 + 1456),  buf,  (uint64_t)&unk_1006C2518,  (const unsigned __int8 *__attribute__((__org_typedef(uuid_t))) *)v49);
  obj[0] = *((id *)v20 + 6);
  *(_OWORD *)&obj[1] = *(_OWORD *)(v20 + 56);
  *(_OWORD *)&obj[3] = *(_OWORD *)(v20 + 72);
  LODWORD(obj[5]) = *((_DWORD *)v20 + 22);
  sub_100272534(__p, (uint64_t)(v20 + 96));
  unint64_t v21 = (_BYTE *)v4 - (char *)obj[2] + 1000 * ((void)v3 - (unint64_t)obj[1]);
  unint64_t v22 = v21 / 0x3E8;
  int v23 = *(_DWORD *)(v2 + 1480);
  *(_WORD *)&buf[6] = 0;
  *(_DWORD *)int buf = v21 / 0x3E8;
  unint64_t v24 = v21 % 0x3E8;
  *(_WORD *)&uint8_t buf[4] = v21 % 0x3E8;
  *(_DWORD *)&v49[4] = 0;
  *(_DWORD *)unsigned int v49 = v23;
  int v25 = sub_1001F42B8((uint64_t)buf, (uint64_t)v49);
  if (v25 < 0)
  {
    ++LODWORD(obj[5]);
    obj[1] = v3;
    obj[2] = v4;
    int v29 = (char *)__p[1];
    if (__p[1] >= (void *)v58[0])
    {
      uint64_t v31 = (char *)__p[0];
      int64_t v32 = ((char *)__p[1] - (char *)__p[0]) >> 2;
      unint64_t v33 = v32 + 1;
      int64_t v34 = v58[0] - (unint64_t)__p[0];
      else {
        unint64_t v35 = v33;
      }
      if (v35)
      {
        int64_t v36 = (char *)sub_10024E33C((uint64_t)v58, v35);
        uint64_t v31 = (char *)__p[0];
        int v29 = (char *)__p[1];
      }

      else
      {
        int64_t v36 = 0LL;
      }

      unint64_t v37 = &v36[4 * v32];
      int64_t v38 = &v36[4 * v35];
      *(_DWORD *)unint64_t v37 = *(_DWORD *)(a1 + 48);
      uint64_t v30 = v37 + 4;
      while (v29 != v31)
      {
        int v39 = *((_DWORD *)v29 - 1);
        v29 -= 4;
        *((_DWORD *)v37 - 1) = v39;
        v37 -= 4;
      }

      __p[0] = v37;
      __p[1] = v30;
      v58[0] = v38;
      if (v31) {
        operator delete(v31);
      }
    }

    else
    {
      *(_DWORD *)__p[1] = *(_DWORD *)(a1 + 48);
      uint64_t v30 = v29 + 4;
    }

    __p[1] = v30;
    unsigned int v40 = (os_log_s *)qword_1008F7620;
    if (os_log_type_enabled((os_log_t)qword_1008F7620, OS_LOG_TYPE_DEFAULT))
    {
      uint64_t v41 = *(void *)(a1 + 32);
      __int128 v60 = 0u;
      __int128 v61 = 0u;
      memset(buf, 0, sizeof(buf));
      snprintf((char *)buf, 0x3FuLL, "%0llu.%0llu", v22, v24);
      sub_10002418C(v45, (char *)buf);
      unsigned int v42 = v48 >= 0 ? v45 : *(_BYTE **)v45;
      int v43 = *(_DWORD *)(a1 + 48);
      *(_DWORD *)unsigned int v49 = 138413058;
      *(void *)&v49[4] = v41;
      __int16 v50 = 2080;
      uint64_t v51 = v42;
      __int16 v52 = 1024;
      int v53 = (int)obj[5];
      __int16 v54 = 1024;
      int v55 = v43;
      _os_log_impl( (void *)&_mh_execute_header,  v40,  OS_LOG_TYPE_DEFAULT,  "LeConnectionDenyList: evaluateOutgoingDisconnection Device %@ disconnected %s seconds ago, increasing counter to %d, disconnectResult=%d",  v49,  0x22u);
      if (v48 < 0) {
        operator delete(*(void **)v45);
      }
    }

    if (LODWORD(obj[5]) >= *(_DWORD *)(v2 + 1488))
    {
      obj[3] = v3;
      obj[4] = v4;
    }

    sub_100241F90(buf, *(void *)(a1 + 32));
    *(void *)unsigned int v49 = buf;
    BOOL v44 = sub_1005BF060( (uint64_t **)(v2 + 1456),  buf,  (uint64_t)&unk_1006C2518,  (const unsigned __int8 *__attribute__((__org_typedef(uuid_t))) *)v49);
    objc_storeStrong((id *)v44 + 6, obj[0]);
    if (v44 + 48 == (unsigned __int8 *)obj)
    {
      *((_DWORD *)v44 + 22) = obj[5];
    }

    else
    {
      *(_OWORD *)(v44 + 56) = *(_OWORD *)&obj[1];
      *(_OWORD *)(v44 + 72) = *(_OWORD *)&obj[3];
      *((_DWORD *)v44 + 22) = obj[5];
      sub_100272430((char *)v44 + 96, (char *)__p[0], (uint64_t)__p[1], ((char *)__p[1] - (char *)__p[0]) >> 2);
    }
  }

  else
  {
    sub_100241F90(buf, *(void *)(a1 + 32));
    sub_1005BF1DC((uint64_t **)(v2 + 1456), buf);
    int v26 = (os_log_s *)qword_1008F7620;
    if (os_log_type_enabled((os_log_t)qword_1008F7620, OS_LOG_TYPE_DEFAULT))
    {
      uint64_t v27 = *(void *)(a1 + 32);
      __int128 v60 = 0u;
      __int128 v61 = 0u;
      memset(buf, 0, sizeof(buf));
      snprintf((char *)buf, 0x3FuLL, "%0llu.%0llu", v22, v24);
      sub_10002418C(v49, (char *)buf);
      __int128 v28 = v52 >= 0 ? v49 : *(_BYTE **)v49;
      *(_DWORD *)uint64_t v45 = 138412546;
      *(void *)&v45[4] = v27;
      __int16 v46 = 2080;
      int v47 = v28;
      _os_log_impl( (void *)&_mh_execute_header,  v26,  OS_LOG_TYPE_DEFAULT,  "LeConnectionDenyList: evaluateOutgoingDisconnection  Device %@ disconnected %s seconds ago, stop monitoring",  v45,  0x16u);
      if (SHIBYTE(v52) < 0) {
        operator delete(*(void **)v49);
      }
    }
  }

  if (__p[0])
  {
    __p[1] = __p[0];
    operator delete(__p[0]);
  }

  if (v25 < 0) {
    goto LABEL_35;
  }
}

void sub_1005B96F4( _Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, ...)
{
}

uint64_t sub_1005B9748(uint64_t a1)
{
  int v1 = *(void **)(a1 + 1456);
  if (v1 == (void *)(a1 + 1464)) {
    return 1LL;
  }
  while (!v1[9] && !v1[10])
  {
    uint64_t v2 = (void *)v1[1];
    if (v2)
    {
      do
      {
        id v3 = v2;
        uint64_t v2 = (void *)*v2;
      }

      while (v2);
    }

    else
    {
      do
      {
        id v3 = (void *)v1[2];
        BOOL v4 = *v3 == (void)v1;
        int v1 = v3;
      }

      while (!v4);
    }

    int v1 = v3;
    if (v3 == (void *)(a1 + 1464)) {
      return 1LL;
    }
  }

  return 0LL;
}

uint64_t sub_1005B97B0(uint64_t a1)
{
  uint64_t v1 = *(void *)(a1 + 32);
  uint64_t v2 = (os_log_s *)qword_1008F7620;
  if (os_log_type_enabled((os_log_t)qword_1008F7620, OS_LOG_TYPE_DEFAULT))
  {
    *(_WORD *)BOOL v4 = 0;
    _os_log_impl( (void *)&_mh_execute_header,  v2,  OS_LOG_TYPE_DEFAULT,  "LeConnectionDenyList: fLeConnectionDenyListMaintainTimer Timer expired!",  v4,  2u);
  }

  sub_10059189C(v1);
  return sub_1005B88E0(v1);
}

void sub_1005B9828(uint64_t a1, void *a2)
{
  id v3 = a2;
  if (qword_1008F1D28 != -1) {
    dispatch_once(&qword_1008F1D28, &stru_1008A29B8);
  }
  uint64_t v4 = sub_100404FE8();
  v6[0] = _NSConcreteStackBlock;
  v6[1] = 3221225472LL;
  void v6[2] = sub_1005B9A60;
  uint64_t v6[3] = &unk_1008A1BB8;
  uint64_t v8 = a1;
  id v5 = v3;
  id v7 = v5;
  sub_100405384(v4, v6);
}

void sub_1005B98E0( _Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, void *a13)
{
  _Unwind_Resume(a1);
}

void sub_1005B9900(id a1)
{
  uint64_t v1 = sub_1002E6E00();
  sub_10002418C(buf, "LE");
  sub_10002418C(__p, "FastLEConnectionForceFakeLocalControllerInfo");
  int v2 = (*(uint64_t (**)(uint64_t, uint8_t *, void **, char *))(*(void *)v1 + 72LL))( v1,  buf,  __p,  &byte_1008F1D20);
  if (byte_1008F1D20) {
    int v3 = v2;
  }
  else {
    int v3 = 0;
  }
  if (v6 < 0) {
    operator delete(__p[0]);
  }
  if (v8 < 0)
  {
    operator delete(*(void **)buf);
    if (!v3) {
      return;
    }
  }

  else if (!v3)
  {
    return;
  }

  uint64_t v4 = (os_log_s *)qword_1008F7620;
  if (os_log_type_enabled((os_log_t)qword_1008F7620, OS_LOG_TYPE_DEFAULT))
  {
    *(_DWORD *)int buf = 67109120;
    *(_DWORD *)&uint8_t buf[4] = byte_1008F1D20;
    _os_log_impl( (void *)&_mh_execute_header,  v4,  OS_LOG_TYPE_DEFAULT,  "Warning: FastLEConnection:FastLEConnectionForceFakeLocalControllerInfo fakeControllerInfo:%d",  buf,  8u);
  }

void sub_1005B9A24( _Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void *__p, uint64_t a11, int a12, __int16 a13, char a14, char a15, void *a16, uint64_t a17, int a18, __int16 a19, char a20, char a21)
{
  if (a15 < 0) {
    operator delete(__p);
  }
  if (a21 < 0) {
    operator delete(a16);
  }
  _Unwind_Resume(exception_object);
}

void sub_1005B9A60(uint64_t a1)
{
  uint64_t v2 = *(void *)(a1 + 40);
  if (*(_BYTE *)(v2 + 184)
    && (int v3 = *(void **)(v2 + 1536)) != 0LL
    && [v3 length]
    && *(_BYTE *)(v2 + 1544))
  {
    id v4 = *(id *)(v2 + 1536);
    if (byte_1008F1D20)
    {
      id v5 = (os_log_s *)qword_1008F7620;
      if (os_log_type_enabled((os_log_t)qword_1008F7620, OS_LOG_TYPE_DEFAULT))
      {
        v9[0] = 0;
        _os_log_impl( (void *)&_mh_execute_header,  v5,  OS_LOG_TYPE_DEFAULT,  "Warning: FastLEConnection:LeConnectionManager::readLocalControllerCachedInfo randomizing controller info",  (uint8_t *)v9,  2u);
      }

      size_t v6 = [*(id *)(v2 + 1536) length];
      id v7 = (char *)malloc(v6);
      memcpy(v7, [*(id *)(v2 + 1536) bytes], v6);
      arc4random_buf(&v7[v6 - 4], 4uLL);
      uint64_t v8 = objc_claimAutoreleasedReturnValue(+[NSData dataWithBytes:length:](&OBJC_CLASS___NSData, "dataWithBytes:length:", v7, v6));

      free(v7);
      id v4 = (id)v8;
    }
  }

  else
  {
    id v4 = 0LL;
  }

  (*(void (**)(void))(*(void *)(a1 + 32) + 16LL))();
}

void sub_1005B9BBC(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_1005B9BD4(uint64_t a1)
{
  *(void *)int buf = 0LL;
  sub_1000B0400((uint64_t)buf);
  uint64_t v1 = (os_log_s *)qword_1008F7620;
  if (os_log_type_enabled((os_log_t)qword_1008F7620, OS_LOG_TYPE_DEFAULT))
  {
    *(_WORD *)int buf = 0;
    _os_log_impl( (void *)&_mh_execute_header,  v1,  OS_LOG_TYPE_DEFAULT,  "statedump: ------------------ LE Connection Manager -------------------",  buf,  2u);
    uint64_t v1 = (os_log_s *)qword_1008F7620;
  }

  if (os_log_type_enabled(v1, OS_LOG_TYPE_DEFAULT))
  {
    id v2 = sub_1005BFB9C(*(void *)(a1 + 288));
    id v3 = (id)objc_claimAutoreleasedReturnValue(v2);
    *(_DWORD *)int buf = 138543362;
    *(void *)&uint8_t buf[4] = v3;
    _os_log_impl( (void *)&_mh_execute_header,  v1,  OS_LOG_TYPE_DEFAULT,  "statedump: Local address %{public}@",  buf,  0xCu);
  }

  *(void *)int buf = 0LL;
  sub_1000B0400((uint64_t)buf);
  uint64_t v4 = *(int *)buf;
  uint64_t v5 = *(__int16 *)&buf[4];
  uint64_t v6 = *(void *)(a1 + 872);
  uint64_t v7 = *(void *)(a1 + 880);
  uint64_t v8 = (os_log_s *)qword_1008F7620;
  if (os_log_type_enabled((os_log_t)qword_1008F7620, OS_LOG_TYPE_DEFAULT))
  {
    unint64_t v9 = 1000 * (v4 - v6) - v7 + v5;
    unsigned int v10 = *(_DWORD *)(a1 + 928);
    if (v10 > 3) {
      int64_t v11 = "UNKNOWN";
    }
    else {
      int64_t v11 = (&off_1008A2DA0)[v10];
    }
    unsigned int v12 = *(_DWORD *)(a1 + 864);
    if (v12 > 4) {
      int v13 = "UNKNOWN";
    }
    else {
      int v13 = (&off_1008A2DC0)[v12];
    }
    memset(buf, 0, sizeof(buf));
    snprintf(buf, 0x3FuLL, "%0llu.%0llu", v9 / 0x3E8, v9 % 0x3E8);
    sub_10002418C(out, buf);
    if (out[23] >= 0) {
      unint64_t v14 = out;
    }
    else {
      unint64_t v14 = *(char **)out;
    }
    int v15 = *(unsigned __int8 *)(a1 + 888);
    if (*(_BYTE *)(a1 + 1065)) {
      int v16 = "YES";
    }
    else {
      int v16 = "NO";
    }
    *(_DWORD *)int buf = 136447746;
    *(void *)&uint8_t buf[4] = v11;
    *(_WORD *)&_BYTE buf[12] = 1024;
    *(_DWORD *)&buf[14] = v10;
    *(_WORD *)&_BYTE buf[18] = 2082;
    *(void *)&buf[20] = v13;
    *(_WORD *)&buf[28] = 1024;
    *(_DWORD *)&buf[30] = v12;
    *(_WORD *)&buf[34] = 2082;
    *(void *)&buf[36] = v14;
    *(_WORD *)&buf[44] = 1024;
    *(_DWORD *)&buf[46] = v15;
    *(_WORD *)&buf[50] = 2082;
    *(void *)&buf[52] = v16;
    _os_log_impl( (void *)&_mh_execute_header,  v8,  OS_LOG_TYPE_DEFAULT,  "statedump: state: %{public}s(%d),%{public}s(%d) for %{public}s seconds, %d errors, fControllerConnectionListFull=%{public}s",  buf,  0x3Cu);
    if (out[23] < 0) {
      operator delete(*(void **)out);
    }
    uint64_t v8 = (os_log_s *)qword_1008F7620;
  }

  if (os_log_type_enabled(v8, OS_LOG_TYPE_DEFAULT))
  {
    BOOL v17 = *(void *)(a1 + 896) != 0LL;
    *(_DWORD *)int buf = 67109120;
    *(_DWORD *)&uint8_t buf[4] = v17;
    _os_log_impl( (void *)&_mh_execute_header,  v8,  OS_LOG_TYPE_DEFAULT,  "statedump: FastConnectionScanAssertionActive:%d",  buf,  8u);
    uint64_t v8 = (os_log_s *)qword_1008F7620;
  }

  if (*(void *)(a1 + 552) && os_log_type_enabled(v8, OS_LOG_TYPE_DEFAULT))
  {
    uint64_t v18 = *(void *)(a1 + 560);
    *(_DWORD *)int buf = 134217984;
    *(void *)&uint8_t buf[4] = v18;
    _os_log_impl( (void *)&_mh_execute_header,  v8,  OS_LOG_TYPE_DEFAULT,  "statedump: FastConnectionScanTimer interval:%f",  buf,  0xCu);
    uint64_t v8 = (os_log_s *)qword_1008F7620;
  }

  if (os_log_type_enabled(v8, OS_LOG_TYPE_DEFAULT))
  {
    int v19 = *(unsigned __int8 *)(a1 + 1067);
    *(_DWORD *)int buf = 67109120;
    *(_DWORD *)&uint8_t buf[4] = v19;
    _os_log_impl((void *)&_mh_execute_header, v8, OS_LOG_TYPE_DEFAULT, "statedump: stackIsShuttingDown:%d", buf, 8u);
    uint64_t v8 = (os_log_s *)qword_1008F7620;
  }

  if (os_log_type_enabled(v8, OS_LOG_TYPE_DEFAULT))
  {
    *(_WORD *)int buf = 0;
    _os_log_impl((void *)&_mh_execute_header, v8, OS_LOG_TYPE_DEFAULT, "statedump: Connected devices:", buf, 2u);
  }

  uint64_t v20 = *(void **)(a1 + 384);
  if (v20 != (void *)(a1 + 392))
  {
    BOOL v235 = (uint64_t **)(a1 + 528);
    unint64_t v21 = (void *)(a1 + 536);
    BOOL v228 = (uint64_t **)(a1 + 504);
    unint64_t v22 = (void *)(a1 + 512);
    do
    {
      uint64_t v280 = 0LL;
      memset(v279, 0, sizeof(v279));
      __int128 v278 = 0u;
      __int128 v277 = 0u;
      *(_OWORD *)v276 = 0u;
      __int128 v275 = 0u;
      memset(buf, 0, sizeof(buf));
      sub_1001FCFC8((uint64_t)buf);
      if (a1 + 416 == sub_1001FDB10(a1 + 408, (unsigned __int8 *)v20 + 32))
      {
        v264[1] = 0LL;
        v264[0] = 0LL;
        if (qword_1008D5F30 != -1) {
          dispatch_once(&qword_1008D5F30, &stru_1008A2B30);
        }
        __int128 v28 = off_1008D5F28;
        int v29 = sub_100241F94((const unsigned __int8 *)v20 + 32);
        uint64_t v30 = (void *)objc_claimAutoreleasedReturnValue(v29);
        sub_1005D3DE4((uint64_t)v28, v30, (uint64_t)v264);

        uint64_t v31 = sub_1001FD17C(&buf[16], (uint64_t)"   ", 3LL);
        memset(out, 0, sizeof(out));
        uuid_unparse_upper((const unsigned __int8 *)v20 + 32, out);
        sub_10002418C(__p, out);
        if ((v273 & 0x80u) == 0) {
          int64_t v32 = __p;
        }
        else {
          int64_t v32 = (void **)__p[0];
        }
        if ((v273 & 0x80u) == 0) {
          uint64_t v33 = v273;
        }
        else {
          uint64_t v33 = (uint64_t)__p[1];
        }
        int64_t v34 = sub_1001FD17C(v31, (uint64_t)v32, v33);
        unint64_t v35 = sub_1001FD17C(v34, (uint64_t)" (not ready, added ", 19LL);
        sub_1005BBFF8(v264, (std::stringbuf::string_type *)out);
        if (out[23] >= 0) {
          int64_t v36 = out;
        }
        else {
          int64_t v36 = *(char **)out;
        }
        if (out[23] >= 0) {
          uint64_t v37 = out[23];
        }
        else {
          uint64_t v37 = *(void *)&out[8];
        }
        int64_t v38 = sub_1001FD17C(v35, (uint64_t)v36, v37);
        sub_1001FD17C(v38, (uint64_t)" ago)", 5LL);
        if (out[23] < 0) {
          operator delete(*(void **)out);
        }
      }

      else
      {
        unint64_t v24 = sub_1001FD17C(&buf[16], (uint64_t)"   ", 3LL);
        memset(out, 0, sizeof(out));
        uuid_unparse_upper((const unsigned __int8 *)v20 + 32, out);
        sub_10002418C(__p, out);
        if ((v273 & 0x80u) == 0) {
          int v25 = __p;
        }
        else {
          int v25 = (void **)__p[0];
        }
        if ((v273 & 0x80u) == 0) {
          uint64_t v26 = v273;
        }
        else {
          uint64_t v26 = (uint64_t)__p[1];
        }
        uint64_t v27 = sub_1001FD17C(v24, (uint64_t)v25, v26);
        sub_1001FD17C(v27, (uint64_t)" (ready)", 8LL);
      }

      int v39 = v20 + 6;
      unsigned int v40 = (void *)*v21;
      if (*v21)
      {
        unint64_t v41 = *v39;
        unsigned int v42 = (void *)(a1 + 536);
        do
        {
          unint64_t v43 = v40[4];
          BOOL v44 = v43 >= v41;
          if (v43 >= v41) {
            uint64_t v45 = v40;
          }
          else {
            uint64_t v45 = v40 + 1;
          }
          if (v44) {
            unsigned int v42 = v40;
          }
          unsigned int v40 = (void *)*v45;
        }

        while (*v45);
        if (v42 != v21 && v41 >= v42[4])
        {
          __int16 v46 = sub_1001FD17C(&buf[16], (uint64_t)" | CI: ", 7LL);
          *(void *)uuid_string_t out = v20 + 6;
          int v47 = sub_1005BC978(v235, v20 + 6, (uint64_t)&unk_1006C2518, (uint64_t **)out);
          char v48 = (void *)std::ostream::operator<<(v46, *((unsigned __int16 *)v47 + 20));
          unsigned int v49 = sub_1001FD17C(v48, (uint64_t)" PL: ", 5LL);
          *(void *)uuid_string_t out = v20 + 6;
          __int16 v50 = sub_1005BC978(v235, v20 + 6, (uint64_t)&unk_1006C2518, (uint64_t **)out);
          uint64_t v51 = (void *)std::ostream::operator<<(v49, *((unsigned __int16 *)v50 + 21));
          __int16 v52 = sub_1001FD17C(v51, (uint64_t)" LSTO: ", 7LL);
          *(void *)uuid_string_t out = v20 + 6;
          int v53 = sub_1005BC978(v235, v20 + 6, (uint64_t)&unk_1006C2518, (uint64_t **)out);
          __int16 v54 = (void *)std::ostream::operator<<(v52, *((unsigned __int16 *)v53 + 22));
          int v55 = sub_1001FD17C(v54, (uint64_t)" SubrateFactor: ", 16LL);
          *(void *)uuid_string_t out = v20 + 6;
          char v56 = sub_1005BC978(v235, v20 + 6, (uint64_t)&unk_1006C2518, (uint64_t **)out);
          uint64_t v57 = (void *)std::ostream::operator<<(v55, *((unsigned __int16 *)v56 + 23));
          __int16 v58 = sub_1001FD17C(v57, (uint64_t)" CN: ", 5LL);
          *(void *)uuid_string_t out = v20 + 6;
          __int128 v59 = sub_1005BC978(v235, v20 + 6, (uint64_t)&unk_1006C2518, (uint64_t **)out);
          __int128 v60 = (void *)std::ostream::operator<<(v58, *((unsigned __int16 *)v59 + 24));
          __int128 v61 = sub_1001FD17C(v60, (uint64_t)" SubrateStatus: ", 16LL);
          *(void *)uuid_string_t out = v20 + 6;
          __int16 v62 = sub_1005BC978(v235, v20 + 6, (uint64_t)&unk_1006C2518, (uint64_t **)out);
          std::ostream::operator<<(v61, *((unsigned int *)v62 + 13));
        }
      }

      int v63 = (void *)*v22;
      if (*v22)
      {
        unint64_t v64 = *v39;
        __int16 v65 = (void *)(a1 + 512);
        do
        {
          unint64_t v66 = v63[4];
          BOOL v67 = v66 >= v64;
          if (v66 >= v64) {
            __int128 v68 = v63;
          }
          else {
            __int128 v68 = v63 + 1;
          }
          if (v67) {
            __int16 v65 = v63;
          }
          int v63 = (void *)*v68;
        }

        while (*v68);
        if (v65 != v22 && v64 >= v65[4])
        {
          __int128 v69 = sub_1001FD17C(&buf[16], (uint64_t)" | Max PL: ", 11LL);
          *(void *)uuid_string_t out = v20 + 6;
          char v70 = sub_1005BD44C(v228, v20 + 6, (uint64_t)&unk_1006C2518, (uint64_t **)out);
          __int16 v71 = (void *)std::ostream::operator<<(v69, *((unsigned __int16 *)v70 + 20));
          unsigned __int16 v72 = sub_1001FD17C(v71, (uint64_t)" Min. SubrateFactor: ", 21LL);
          *(void *)uuid_string_t out = v20 + 6;
          char v73 = sub_1005BD44C(v228, v20 + 6, (uint64_t)&unk_1006C2518, (uint64_t **)out);
          unsigned __int16 v74 = (void *)std::ostream::operator<<(v72, *((unsigned __int16 *)v73 + 21));
          unsigned __int16 v75 = sub_1001FD17C(v74, (uint64_t)"Max. SubrateFactor: ", 20LL);
          *(void *)uuid_string_t out = v20 + 6;
          char v76 = sub_1005BD44C(v228, v20 + 6, (uint64_t)&unk_1006C2518, (uint64_t **)out);
          __int16 v77 = (void *)std::ostream::operator<<(v75, *((unsigned __int16 *)v76 + 22));
          int v78 = sub_1001FD17C(v77, (uint64_t)" CN: ", 5LL);
          *(void *)uuid_string_t out = v20 + 6;
          __int16 v79 = sub_1005BD44C(v228, v20 + 6, (uint64_t)&unk_1006C2518, (uint64_t **)out);
          int v80 = (void *)std::ostream::operator<<(v78, *((unsigned __int16 *)v79 + 23));
          __int16 v81 = sub_1001FD17C(v80, (uint64_t)" LSTO: ", 7LL);
          *(void *)uuid_string_t out = v20 + 6;
          unsigned int v82 = sub_1005BD44C(v228, v20 + 6, (uint64_t)&unk_1006C2518, (uint64_t **)out);
          __int16 v83 = (void *)std::ostream::operator<<(v81, 10 * *((unsigned __int16 *)v82 + 24));
          sub_1001FD17C(v83, (uint64_t)" msec", 5LL);
        }
      }

      int v84 = (os_log_s *)qword_1008F7620;
      if (os_log_type_enabled((os_log_t)qword_1008F7620, OS_LOG_TYPE_DEFAULT))
      {
        std::stringbuf::str((std::stringbuf::string_type *)out, (const std::stringbuf *)&buf[24]);
        __int16 v85 = out;
        if (out[23] < 0) {
          __int16 v85 = *(char **)out;
        }
        LODWORD(__p[0]) = 136446210;
        *(void **)((char *)__p + 4) = v85;
        _os_log_impl( (void *)&_mh_execute_header,  v84,  OS_LOG_TYPE_DEFAULT,  "statedump: %{public}s",  (uint8_t *)__p,  0xCu);
        if (out[23] < 0) {
          operator delete(*(void **)out);
        }
      }

      *(void *)int buf = v23;
      *(void *)&buf[*(void *)(v23 - 24)] = v230;
      *(void *)&uint8_t buf[16] = v229;
      if (SHIBYTE(v277) < 0) {
        operator delete(v276[1]);
      }
      std::streambuf::~streambuf(&buf[24]);
      std::ios::~ios(v279);
      int v86 = (void *)v20[1];
      if (v86)
      {
        do
        {
          __int16 v87 = v86;
          int v86 = (void *)*v86;
        }

        while (v86);
      }

      else
      {
        do
        {
          __int16 v87 = (void *)v20[2];
          BOOL v88 = *v87 == (void)v20;
          uint64_t v20 = v87;
        }

        while (!v88);
      }

      uint64_t v20 = v87;
    }

    while (v87 != (void *)(a1 + 392));
  }

  __int16 v89 = (os_log_s *)qword_1008F7620;
  if (os_log_type_enabled((os_log_t)qword_1008F7620, OS_LOG_TYPE_DEFAULT))
  {
    *(_WORD *)int buf = 0;
    _os_log_impl( (void *)&_mh_execute_header,  v89,  OS_LOG_TYPE_DEFAULT,  "statedump: UUIDToSessionMap :  fRSSIDetectionUUIDToSessionMap",  buf,  2u);
    __int16 v89 = (os_log_s *)qword_1008F7620;
  }

  int v90 = *(const unsigned __int8 **)(a1 + 640);
  if (v90 != (const unsigned __int8 *)(a1 + 648))
  {
    do
    {
      if (os_log_type_enabled(v89, OS_LOG_TYPE_DEFAULT))
      {
        int v91 = sub_100241F94(v90 + 32);
        id v92 = (id)objc_claimAutoreleasedReturnValue(v91);
        *(_DWORD *)int buf = 138543362;
        *(void *)&uint8_t buf[4] = v92;
        _os_log_impl( (void *)&_mh_execute_header,  v89,  OS_LOG_TYPE_DEFAULT,  "statedump:  Device%{public}@ : Session:",  buf,  0xCu);

        __int16 v89 = (os_log_s *)qword_1008F7620;
      }

      __int16 v93 = (unsigned __int8 *)*((void *)v90 + 1);
      if (v93)
      {
        do
        {
          unsigned int v94 = (const unsigned __int8 **)v93;
          __int16 v93 = *(unsigned __int8 **)v93;
        }

        while (v93);
      }

      else
      {
        do
        {
          unsigned int v94 = (const unsigned __int8 **)*((void *)v90 + 2);
          BOOL v88 = *v94 == v90;
          int v90 = (const unsigned __int8 *)v94;
        }

        while (!v88);
      }

      int v90 = (const unsigned __int8 *)v94;
    }

    while (v94 != (const unsigned __int8 **)(a1 + 648));
  }

  if (os_log_type_enabled(v89, OS_LOG_TYPE_DEFAULT))
  {
    *(_WORD *)int buf = 0;
    _os_log_impl( (void *)&_mh_execute_header,  v89,  OS_LOG_TYPE_DEFAULT,  "statedump: UUIDToSessionMap : fUsageNotificationUUIDToSessionMap",  buf,  2u);
    __int16 v89 = (os_log_s *)qword_1008F7620;
  }

  char v95 = *(const unsigned __int8 **)(a1 + 664);
  if (v95 != (const unsigned __int8 *)(a1 + 672))
  {
    do
    {
      if (os_log_type_enabled(v89, OS_LOG_TYPE_DEFAULT))
      {
        __int16 v96 = sub_100241F94(v95 + 32);
        id v97 = (id)objc_claimAutoreleasedReturnValue(v96);
        *(_DWORD *)int buf = 138543362;
        *(void *)&uint8_t buf[4] = v97;
        _os_log_impl( (void *)&_mh_execute_header,  v89,  OS_LOG_TYPE_DEFAULT,  "statedump:  Device%{public}@ : Session",  buf,  0xCu);

        __int16 v89 = (os_log_s *)qword_1008F7620;
      }

      int v98 = (unsigned __int8 *)*((void *)v95 + 1);
      if (v98)
      {
        do
        {
          __int16 v99 = (const unsigned __int8 **)v98;
          int v98 = *(unsigned __int8 **)v98;
        }

        while (v98);
      }

      else
      {
        do
        {
          __int16 v99 = (const unsigned __int8 **)*((void *)v95 + 2);
          BOOL v88 = *v99 == v95;
          char v95 = (const unsigned __int8 *)v99;
        }

        while (!v88);
      }

      char v95 = (const unsigned __int8 *)v99;
    }

    while (v99 != (const unsigned __int8 **)(a1 + 672));
  }

  if (os_log_type_enabled(v89, OS_LOG_TYPE_DEFAULT))
  {
    *(_WORD *)int buf = 0;
    _os_log_impl( (void *)&_mh_execute_header,  v89,  OS_LOG_TYPE_DEFAULT,  "statedump: SessionToUUIDMap fUsagePhyStatisticsUUIDToSessionMap :  ",  buf,  2u);
    __int16 v89 = (os_log_s *)qword_1008F7620;
  }

  signed int v100 = *(const unsigned __int8 **)(a1 + 688);
  if (v100 != (const unsigned __int8 *)(a1 + 696))
  {
    do
    {
      if (os_log_type_enabled(v89, OS_LOG_TYPE_DEFAULT))
      {
        __int16 v101 = sub_100241F94(v100 + 40);
        id v102 = (id)objc_claimAutoreleasedReturnValue(v101);
        *(_DWORD *)int buf = 138543362;
        *(void *)&uint8_t buf[4] = v102;
        _os_log_impl( (void *)&_mh_execute_header,  v89,  OS_LOG_TYPE_DEFAULT,  "statedump:  Session:  : Device%{public}@",  buf,  0xCu);

        __int16 v89 = (os_log_s *)qword_1008F7620;
      }

      v103 = (unsigned __int8 *)*((void *)v100 + 1);
      if (v103)
      {
        do
        {
          int v104 = (const unsigned __int8 **)v103;
          v103 = *(unsigned __int8 **)v103;
        }

        while (v103);
      }

      else
      {
        do
        {
          int v104 = (const unsigned __int8 **)*((void *)v100 + 2);
          BOOL v88 = *v104 == v100;
          signed int v100 = (const unsigned __int8 *)v104;
        }

        while (!v88);
      }

      signed int v100 = (const unsigned __int8 *)v104;
    }

    while (v104 != (const unsigned __int8 **)(a1 + 696));
  }

  if (os_log_type_enabled(v89, OS_LOG_TYPE_DEFAULT))
  {
    *(_WORD *)int buf = 0;
    _os_log_impl( (void *)&_mh_execute_header,  v89,  OS_LOG_TYPE_DEFAULT,  "statedump: SessionToUUIDMap fUsagePhyStatisticsSubratingToSessionMap :  ",  buf,  2u);
    __int16 v89 = (os_log_s *)qword_1008F7620;
  }

  __int16 v105 = *(void **)(a1 + 712);
  if (v105 != (void *)(a1 + 720))
  {
    do
    {
      if (os_log_type_enabled(v89, OS_LOG_TYPE_DEFAULT))
      {
        int v106 = *((unsigned __int16 *)v105 + 20);
        *(_DWORD *)int buf = 67109120;
        *(_DWORD *)&uint8_t buf[4] = v106;
        _os_log_impl((void *)&_mh_execute_header, v89, OS_LOG_TYPE_DEFAULT, "statedump:  Session:  : %d", buf, 8u);
        __int16 v89 = (os_log_s *)qword_1008F7620;
      }

      __int16 v107 = (void *)v105[1];
      if (v107)
      {
        do
        {
          uint64_t v108 = v107;
          __int16 v107 = (void *)*v107;
        }

        while (v107);
      }

      else
      {
        do
        {
          uint64_t v108 = (void *)v105[2];
          BOOL v88 = *v108 == (void)v105;
          __int16 v105 = v108;
        }

        while (!v88);
      }

      __int16 v105 = v108;
    }

    while (v108 != (void *)(a1 + 720));
  }

  if (os_log_type_enabled(v89, OS_LOG_TYPE_DEFAULT))
  {
    int v109 = *(char *)(a1 + 736);
    *(_DWORD *)int buf = 67109120;
    *(_DWORD *)&uint8_t buf[4] = v109;
    _os_log_impl( (void *)&_mh_execute_header,  v89,  OS_LOG_TYPE_DEFAULT,  "statedump: fLastGLobalMinRSSIApplied : %d",  buf,  8u);
    __int16 v89 = (os_log_s *)qword_1008F7620;
  }

  if (os_log_type_enabled(v89, OS_LOG_TYPE_DEFAULT))
  {
    *(_WORD *)int buf = 0;
    _os_log_impl((void *)&_mh_execute_header, v89, OS_LOG_TYPE_DEFAULT, "statedump: Ready devices:", buf, 2u);
  }

  v110 = *(const unsigned __int8 **)(a1 + 408);
  if (v110 != (const unsigned __int8 *)(a1 + 416))
  {
    do
    {
      uint64_t v111 = (os_log_s *)qword_1008F7620;
      if (os_log_type_enabled((os_log_t)qword_1008F7620, OS_LOG_TYPE_DEFAULT))
      {
        memset(buf, 0, 37);
        uuid_unparse_upper(v110 + 32, buf);
        sub_10002418C(out, buf);
        v112 = out[23] >= 0 ? out : *(char **)out;
        *(_DWORD *)int buf = 136446210;
        *(void *)&uint8_t buf[4] = v112;
        _os_log_impl((void *)&_mh_execute_header, v111, OS_LOG_TYPE_DEFAULT, "statedump:    %{public}s", buf, 0xCu);
        if (out[23] < 0) {
          operator delete(*(void **)out);
        }
      }

      v113 = (unsigned __int8 *)*((void *)v110 + 1);
      if (v113)
      {
        do
        {
          v114 = (const unsigned __int8 **)v113;
          v113 = *(unsigned __int8 **)v113;
        }

        while (v113);
      }

      else
      {
        do
        {
          v114 = (const unsigned __int8 **)*((void *)v110 + 2);
          BOOL v88 = *v114 == v110;
          v110 = (const unsigned __int8 *)v114;
        }

        while (!v88);
      }

      v110 = (const unsigned __int8 *)v114;
    }

    while (v114 != (const unsigned __int8 **)(a1 + 416));
  }

  __int16 v115 = (os_log_s *)qword_1008F7620;
  if (os_log_type_enabled((os_log_t)qword_1008F7620, OS_LOG_TYPE_DEFAULT))
  {
    *(_WORD *)int buf = 0;
    _os_log_impl((void *)&_mh_execute_header, v115, OS_LOG_TYPE_DEFAULT, "statedump: Devices with CL Info:", buf, 2u);
  }

  int v116 = *(const unsigned __int8 **)(a1 + 432);
  if (v116 != (const unsigned __int8 *)(a1 + 440))
  {
    do
    {
      __int16 v117 = (os_log_s *)qword_1008F7620;
      if (os_log_type_enabled((os_log_t)qword_1008F7620, OS_LOG_TYPE_DEFAULT))
      {
        memset(buf, 0, 37);
        uuid_unparse_upper(v116 + 32, buf);
        sub_10002418C(out, buf);
        int v118 = out[23] >= 0 ? out : *(char **)out;
        *(_DWORD *)int buf = 136446210;
        *(void *)&uint8_t buf[4] = v118;
        _os_log_impl((void *)&_mh_execute_header, v117, OS_LOG_TYPE_DEFAULT, "statedump:    %{public}s", buf, 0xCu);
        if (out[23] < 0) {
          operator delete(*(void **)out);
        }
      }

      __int16 v119 = (unsigned __int8 *)*((void *)v116 + 1);
      if (v119)
      {
        do
        {
          int v120 = (const unsigned __int8 **)v119;
          __int16 v119 = *(unsigned __int8 **)v119;
        }

        while (v119);
      }

      else
      {
        do
        {
          int v120 = (const unsigned __int8 **)*((void *)v116 + 2);
          BOOL v88 = *v120 == v116;
          int v116 = (const unsigned __int8 *)v120;
        }

        while (!v88);
      }

      int v116 = (const unsigned __int8 *)v120;
    }

    while (v120 != (const unsigned __int8 **)(a1 + 440));
  }

  id v121 = (os_log_s *)qword_1008F7620;
  if (os_log_type_enabled((os_log_t)qword_1008F7620, OS_LOG_TYPE_DEFAULT))
  {
    *(_WORD *)int buf = 0;
    _os_log_impl((void *)&_mh_execute_header, v121, OS_LOG_TYPE_DEFAULT, "statedump: Connecting devices:", buf, 2u);
  }

  uint64_t v122 = a1;
  v123 = *(const unsigned __int8 **)(a1 + 336);
  if (v123 != (const unsigned __int8 *)(a1 + 344))
  {
    v124 = (const unsigned __int8 *)(a1 + 368);
    do
    {
      *(_OWORD *)__int128 __p = 0uLL;
      if (qword_1008D5F30 != -1) {
        dispatch_once(&qword_1008D5F30, &stru_1008A2B30);
      }
      v125 = off_1008D5F28;
      int v126 = sub_100241F94(v123 + 25);
      int v127 = (void *)objc_claimAutoreleasedReturnValue(v126);
      sub_1005D3DE4((uint64_t)v125, v127, (uint64_t)__p);

      v128 = (os_log_s *)qword_1008F7620;
      if (os_log_type_enabled((os_log_t)qword_1008F7620, OS_LOG_TYPE_DEFAULT))
      {
        v129 = sub_100241F94(v123 + 25);
        id v233 = (id)objc_claimAutoreleasedReturnValue(v129);
        sub_1005BBFF8((unint64_t *)__p, (std::stringbuf::string_type *)out);
        v130 = out;
        if (out[23] < 0) {
          v130 = *(char **)out;
        }
        v231 = v130;
        if (qword_1008D5F30 != -1) {
          dispatch_once(&qword_1008D5F30, &stru_1008A2B30);
        }
        v131 = off_1008D5F28;
        v132 = sub_100241F94(v123 + 25);
        uint64_t v232 = (void *)objc_claimAutoreleasedReturnValue(v132);
        int v133 = sub_1005CE2FC((uint64_t)v131, v232);
        if (qword_1008D5F30 != -1) {
          dispatch_once(&qword_1008D5F30, &stru_1008A2B30);
        }
        v134 = off_1008D5F28;
        id v135 = sub_100241F94(v123 + 25);
        uint64_t v136 = (void *)objc_claimAutoreleasedReturnValue(v135);
        int v137 = sub_1005D6BDC((uint64_t)v134, v136);
        if (qword_1008D5F30 != -1) {
          dispatch_once(&qword_1008D5F30, &stru_1008A2B30);
        }
        uint64_t v138 = off_1008D5F28;
        id v139 = sub_100241F94(v123 + 25);
        id v140 = (void *)objc_claimAutoreleasedReturnValue(v139);
        int v141 = sub_1005D6CEC((uint64_t)v138, v140);
        *(_DWORD *)int buf = 138544386;
        *(void *)&uint8_t buf[4] = v233;
        *(_WORD *)&_BYTE buf[12] = 2082;
        *(void *)&buf[14] = v231;
        *(_WORD *)&_BYTE buf[22] = 1024;
        *(_DWORD *)&uint8_t buf[24] = v133;
        *(_WORD *)&buf[28] = 1024;
        *(_DWORD *)&buf[30] = v137;
        *(_WORD *)&buf[34] = 1024;
        *(_DWORD *)&buf[36] = v141;
        _os_log_impl( (void *)&_mh_execute_header,  v128,  OS_LOG_TYPE_DEFAULT,  "statedump:    %{public}@ (added %{public}s ago) useCase:%d scanDutyCycle screenON:%d screenOFF:%d",  buf,  0x28u);

        if (out[23] < 0) {
          operator delete(*(void **)out);
        }
      }

      uint64_t v142 = *(const unsigned __int8 **)(a1 + 360);
      if (v142 != v124)
      {
        do
        {
          uint64_t v143 = sub_100241F94(v123 + 25);
          int v144 = (void *)objc_claimAutoreleasedReturnValue(v143);
          sub_100241F90(buf, v144);
          BOOL v145 = uuid_compare(v142 + 40, buf) == 0;

          if (v145)
          {
            id v146 = (os_log_s *)qword_1008F7620;
            if (os_log_type_enabled((os_log_t)qword_1008F7620, OS_LOG_TYPE_DEFAULT))
            {
              sub_1005BF8CC(*((void *)v142 + 4), (std::stringbuf::string_type *)buf);
              uint64_t v147 = buf[23] >= 0 ? buf : *(_BYTE **)buf;
              *(_DWORD *)uuid_string_t out = 136315138;
              *(void *)&out[4] = v147;
              _os_log_impl( (void *)&_mh_execute_header,  v146,  OS_LOG_TYPE_DEFAULT,  "statedump:       %s",  (uint8_t *)out,  0xCu);
              if ((buf[23] & 0x80000000) != 0) {
                operator delete(*(void **)buf);
              }
            }
          }

          int v148 = (const unsigned __int8 *)*((void *)v142 + 1);
          if (v148)
          {
            do
            {
              uint64_t v149 = v148;
              int v148 = *(const unsigned __int8 **)v148;
            }

            while (v148);
          }

          else
          {
            do
            {
              uint64_t v149 = (const unsigned __int8 *)*((void *)v142 + 2);
              BOOL v88 = *(void *)v149 == (void)v142;
              uint64_t v142 = v149;
            }

            while (!v88);
          }

          uint64_t v142 = v149;
        }

        while (v149 != v124);
      }

      v150 = (unsigned __int8 *)*((void *)v123 + 1);
      if (v150)
      {
        do
        {
          id v151 = (const unsigned __int8 **)v150;
          v150 = *(unsigned __int8 **)v150;
        }

        while (v150);
      }

      else
      {
        do
        {
          id v151 = (const unsigned __int8 **)*((void *)v123 + 2);
          BOOL v88 = *v151 == v123;
          v123 = (const unsigned __int8 *)v151;
        }

        while (!v88);
      }

      v123 = (const unsigned __int8 *)v151;
      uint64_t v122 = a1;
    }

    while (v151 != (const unsigned __int8 **)(a1 + 344));
  }

  uint64_t v152 = (os_log_s *)qword_1008F7620;
  if (os_log_type_enabled((os_log_t)qword_1008F7620, OS_LOG_TYPE_DEFAULT))
  {
    *(_WORD *)int buf = 0;
    _os_log_impl( (void *)&_mh_execute_header,  v152,  OS_LOG_TYPE_DEFAULT,  "statedump: Disconnection reason map:",  buf,  2u);
  }

  v153 = *(const unsigned __int8 **)(v122 + 456);
  if (v153 != (const unsigned __int8 *)(v122 + 464))
  {
    do
    {
      uint64_t v154 = (os_log_s *)qword_1008F7620;
      if (os_log_type_enabled((os_log_t)qword_1008F7620, OS_LOG_TYPE_DEFAULT))
      {
        memset(buf, 0, 37);
        uuid_unparse_upper(v153 + 28, buf);
        sub_10002418C(out, buf);
        if (out[23] >= 0) {
          v155 = out;
        }
        else {
          v155 = *(char **)out;
        }
        uint64_t v156 = *((int *)v153 + 11);
        v157 = "unknown";
        *(_DWORD *)int buf = 136446466;
        *(void *)&uint8_t buf[4] = v155;
        *(_WORD *)&_BYTE buf[12] = 2082;
        *(void *)&buf[14] = v157;
        _os_log_impl( (void *)&_mh_execute_header,  v154,  OS_LOG_TYPE_DEFAULT,  "statedump:    %{public}s:%{public}s",  buf,  0x16u);
        if (out[23] < 0) {
          operator delete(*(void **)out);
        }
      }

      int v158 = (unsigned __int8 *)*((void *)v153 + 1);
      if (v158)
      {
        do
        {
          id v159 = (const unsigned __int8 **)v158;
          int v158 = *(unsigned __int8 **)v158;
        }

        while (v158);
      }

      else
      {
        do
        {
          id v159 = (const unsigned __int8 **)*((void *)v153 + 2);
          BOOL v88 = *v159 == v153;
          v153 = (const unsigned __int8 *)v159;
        }

        while (!v88);
      }

      v153 = (const unsigned __int8 *)v159;
    }

    while (v159 != (const unsigned __int8 **)(v122 + 464));
  }

  v160 = (os_log_s *)qword_1008F7620;
  if (os_log_type_enabled((os_log_t)qword_1008F7620, OS_LOG_TYPE_DEFAULT))
  {
    *(_WORD *)int buf = 0;
    _os_log_impl( (void *)&_mh_execute_header,  v160,  OS_LOG_TYPE_DEFAULT,  "statedump: Devices pending to go into filter accept list:",  buf,  2u);
  }

  __int128 v262 = 0u;
  __int128 v263 = 0u;
  __int128 v260 = 0u;
  __int128 v261 = 0u;
  id v161 = *(id *)(a1 + 768);
  id v162 = [v161 countByEnumeratingWithState:&v260 objects:v271 count:16];
  if (v162)
  {
    uint64_t v163 = *(void *)v261;
    do
    {
      for (uint64_t i = 0LL; i != v162; uint64_t i = (char *)i + 1)
      {
        if (*(void *)v261 != v163) {
          objc_enumerationMutation(v161);
        }
        v165 = (os_log_s *)qword_1008F7620;
        if (os_log_type_enabled((os_log_t)qword_1008F7620, OS_LOG_TYPE_DEFAULT))
        {
          uint64_t v166 = *(void *)(*((void *)&v260 + 1) + 8LL * (void)i);
          *(_DWORD *)int buf = 138543362;
          *(void *)&uint8_t buf[4] = v166;
          _os_log_impl((void *)&_mh_execute_header, v165, OS_LOG_TYPE_DEFAULT, "statedump:    %{public}@", buf, 0xCu);
        }
      }

      id v162 = [v161 countByEnumeratingWithState:&v260 objects:v271 count:16];
    }

    while (v162);
  }

  v167 = (os_log_s *)qword_1008F7620;
  if (os_log_type_enabled((os_log_t)qword_1008F7620, OS_LOG_TYPE_DEFAULT))
  {
    *(_WORD *)int buf = 0;
    _os_log_impl( (void *)&_mh_execute_header,  v167,  OS_LOG_TYPE_DEFAULT,  "statedump: Devices pending to go out of filter accept list:",  buf,  2u);
  }

  __int128 v258 = 0u;
  __int128 v259 = 0u;
  __int128 v256 = 0u;
  __int128 v257 = 0u;
  id v168 = *(id *)(a1 + 776);
  id v169 = [v168 countByEnumeratingWithState:&v256 objects:v270 count:16];
  if (v169)
  {
    uint64_t v170 = *(void *)v257;
    do
    {
      for (j = 0LL; j != v169; j = (char *)j + 1)
      {
        if (*(void *)v257 != v170) {
          objc_enumerationMutation(v168);
        }
        v172 = (os_log_s *)qword_1008F7620;
        if (os_log_type_enabled((os_log_t)qword_1008F7620, OS_LOG_TYPE_DEFAULT))
        {
          uint64_t v173 = *(void *)(*((void *)&v256 + 1) + 8LL * (void)j);
          *(_DWORD *)int buf = 138543362;
          *(void *)&uint8_t buf[4] = v173;
          _os_log_impl((void *)&_mh_execute_header, v172, OS_LOG_TYPE_DEFAULT, "statedump:    %{public}@", buf, 0xCu);
        }
      }

      id v169 = [v168 countByEnumeratingWithState:&v256 objects:v270 count:16];
    }

    while (v169);
  }

  v174 = (os_log_s *)qword_1008F7620;
  if (os_log_type_enabled((os_log_t)qword_1008F7620, OS_LOG_TYPE_DEFAULT))
  {
    *(_WORD *)int buf = 0;
    _os_log_impl( (void *)&_mh_execute_header,  v174,  OS_LOG_TYPE_DEFAULT,  "statedump: Devices pending to get updated in FilterAcceptList:",  buf,  2u);
  }

  __int128 v254 = 0u;
  __int128 v255 = 0u;
  __int128 v252 = 0u;
  __int128 v253 = 0u;
  id v175 = *(id *)(a1 + 784);
  id v176 = [v175 countByEnumeratingWithState:&v252 objects:v269 count:16];
  if (v176)
  {
    uint64_t v177 = *(void *)v253;
    do
    {
      for (k = 0LL; k != v176; k = (char *)k + 1)
      {
        if (*(void *)v253 != v177) {
          objc_enumerationMutation(v175);
        }
        v179 = (os_log_s *)qword_1008F7620;
        if (os_log_type_enabled((os_log_t)qword_1008F7620, OS_LOG_TYPE_DEFAULT))
        {
          uint64_t v180 = *(void *)(*((void *)&v252 + 1) + 8LL * (void)k);
          *(_DWORD *)int buf = 138412290;
          *(void *)&uint8_t buf[4] = v180;
          _os_log_impl((void *)&_mh_execute_header, v179, OS_LOG_TYPE_DEFAULT, "statedump:    %@", buf, 0xCu);
        }
      }

      id v176 = [v175 countByEnumeratingWithState:&v252 objects:v269 count:16];
    }

    while (v176);
  }

  v181 = (os_log_s *)qword_1008F7620;
  if (os_log_type_enabled((os_log_t)qword_1008F7620, OS_LOG_TYPE_DEFAULT))
  {
    *(_WORD *)int buf = 0;
    _os_log_impl( (void *)&_mh_execute_header,  v181,  OS_LOG_TYPE_DEFAULT,  "statedump: Overflowed connecting devices:",  buf,  2u);
  }

  __int128 v250 = 0u;
  __int128 v251 = 0u;
  __int128 v248 = 0u;
  __int128 v249 = 0u;
  id v182 = *(id *)(a1 + 752);
  id v183 = [v182 countByEnumeratingWithState:&v248 objects:v268 count:16];
  if (v183)
  {
    uint64_t v184 = *(void *)v249;
    do
    {
      for (m = 0LL; m != v183; m = (char *)m + 1)
      {
        if (*(void *)v249 != v184) {
          objc_enumerationMutation(v182);
        }
        v186 = (os_log_s *)qword_1008F7620;
        if (os_log_type_enabled((os_log_t)qword_1008F7620, OS_LOG_TYPE_DEFAULT))
        {
          uint64_t v187 = *(void *)(*((void *)&v248 + 1) + 8LL * (void)m);
          *(_DWORD *)int buf = 138543362;
          *(void *)&uint8_t buf[4] = v187;
          _os_log_impl((void *)&_mh_execute_header, v186, OS_LOG_TYPE_DEFAULT, "statedump:    %{public}@", buf, 0xCu);
        }
      }

      id v183 = [v182 countByEnumeratingWithState:&v248 objects:v268 count:16];
    }

    while (v183);
  }

  uint64_t v188 = (os_log_s *)qword_1008F7620;
  if (os_log_type_enabled((os_log_t)qword_1008F7620, OS_LOG_TYPE_DEFAULT))
  {
    *(_WORD *)int buf = 0;
    _os_log_impl( (void *)&_mh_execute_header,  v188,  OS_LOG_TYPE_DEFAULT,  "statedump: Blocked connecting devices:",  buf,  2u);
  }

  __int128 v246 = 0u;
  __int128 v247 = 0u;
  __int128 v244 = 0u;
  __int128 v245 = 0u;
  id v189 = *(id *)(a1 + 760);
  id v190 = [v189 countByEnumeratingWithState:&v244 objects:v267 count:16];
  if (v190)
  {
    uint64_t v191 = *(void *)v245;
    do
    {
      for (n = 0LL; n != v190; n = (char *)n + 1)
      {
        if (*(void *)v245 != v191) {
          objc_enumerationMutation(v189);
        }
        uint64_t v193 = (os_log_s *)qword_1008F7620;
        if (os_log_type_enabled((os_log_t)qword_1008F7620, OS_LOG_TYPE_DEFAULT))
        {
          uint64_t v194 = *(void *)(*((void *)&v244 + 1) + 8LL * (void)n);
          *(_DWORD *)int buf = 138543362;
          *(void *)&uint8_t buf[4] = v194;
          _os_log_impl((void *)&_mh_execute_header, v193, OS_LOG_TYPE_DEFAULT, "statedump:    %{public}@", buf, 0xCu);
        }
      }

      id v190 = [v189 countByEnumeratingWithState:&v244 objects:v267 count:16];
    }

    while (v190);
  }

  v195 = (os_log_s *)qword_1008F7620;
  if (os_log_type_enabled((os_log_t)qword_1008F7620, OS_LOG_TYPE_DEFAULT))
  {
    *(_WORD *)int buf = 0;
    _os_log_impl((void *)&_mh_execute_header, v195, OS_LOG_TYPE_DEFAULT, "statedump: Disconnecting devices:", buf, 2u);
  }

  __int128 v242 = 0u;
  __int128 v243 = 0u;
  __int128 v240 = 0u;
  __int128 v241 = 0u;
  id v196 = *(id *)(a1 + 744);
  id v197 = [v196 countByEnumeratingWithState:&v240 objects:v266 count:16];
  if (v197)
  {
    uint64_t v198 = *(void *)v241;
    do
    {
      for (iuint64_t i = 0LL; ii != v197; iuint64_t i = (char *)ii + 1)
      {
        if (*(void *)v241 != v198) {
          objc_enumerationMutation(v196);
        }
        __uint64_t v200 = (os_log_s *)qword_1008F7620;
        if (os_log_type_enabled((os_log_t)qword_1008F7620, OS_LOG_TYPE_DEFAULT))
        {
          uint64_t v201 = *(void *)(*((void *)&v240 + 1) + 8LL * (void)ii);
          *(_DWORD *)int buf = 138543362;
          *(void *)&uint8_t buf[4] = v201;
          _os_log_impl((void *)&_mh_execute_header, v200, OS_LOG_TYPE_DEFAULT, "statedump:    %{public}@", buf, 0xCu);
        }
      }

      id v197 = [v196 countByEnumeratingWithState:&v240 objects:v266 count:16];
    }

    while (v197);
  }

  v202 = (os_log_s *)qword_1008F7620;
  if (os_log_type_enabled((os_log_t)qword_1008F7620, OS_LOG_TYPE_DEFAULT))
  {
    *(_WORD *)int buf = 0;
    _os_log_impl( (void *)&_mh_execute_header,  v202,  OS_LOG_TYPE_DEFAULT,  "statedump: Requiring low latency devices:",  buf,  2u);
  }

  __int128 v238 = 0u;
  __int128 v239 = 0u;
  __int128 v236 = 0u;
  __int128 v237 = 0u;
  id v203 = *(id *)(a1 + 824);
  id v204 = [v203 countByEnumeratingWithState:&v236 objects:v265 count:16];
  if (v204)
  {
    uint64_t v205 = *(void *)v237;
    do
    {
      for (jj = 0LL; jj != v204; jj = (char *)jj + 1)
      {
        if (*(void *)v237 != v205) {
          objc_enumerationMutation(v203);
        }
        __int128 v207 = (os_log_s *)qword_1008F7620;
        if (os_log_type_enabled((os_log_t)qword_1008F7620, OS_LOG_TYPE_DEFAULT))
        {
          uint64_t v208 = *(void *)(*((void *)&v236 + 1) + 8LL * (void)jj);
          *(_DWORD *)int buf = 138543362;
          *(void *)&uint8_t buf[4] = v208;
          _os_log_impl((void *)&_mh_execute_header, v207, OS_LOG_TYPE_DEFAULT, "statedump:    %{public}@", buf, 0xCu);
        }
      }

      id v204 = [v203 countByEnumeratingWithState:&v236 objects:v265 count:16];
    }

    while (v204);
  }

  __int128 v209 = (os_log_s *)qword_1008F7620;
  if (os_log_type_enabled((os_log_t)qword_1008F7620, OS_LOG_TYPE_DEFAULT))
  {
    *(_WORD *)int buf = 0;
    _os_log_impl( (void *)&_mh_execute_header,  v209,  OS_LOG_TYPE_DEFAULT,  "statedump: Incoming LE Connection Deny List:",  buf,  2u);
  }

  int v210 = *(void **)(a1 + 1432);
  if (v210 != (void *)(a1 + 1440))
  {
    do
    {
      v211 = (os_log_s *)qword_1008F7620;
      if (os_log_type_enabled((os_log_t)qword_1008F7620, OS_LOG_TYPE_DEFAULT))
      {
        sub_1005B8B90((uint64_t)(v210 + 6), (std::stringbuf::string_type *)buf);
        char v212 = buf[23] >= 0 ? buf : *(_BYTE **)buf;
        *(_DWORD *)uuid_string_t out = 136446210;
        *(void *)&out[4] = v212;
        _os_log_impl( (void *)&_mh_execute_header,  v211,  OS_LOG_TYPE_DEFAULT,  "statedump:    %{public}s",  (uint8_t *)out,  0xCu);
        if ((buf[23] & 0x80000000) != 0) {
          operator delete(*(void **)buf);
        }
      }

      v213 = (void *)v210[1];
      if (v213)
      {
        do
        {
          int v214 = v213;
          v213 = (void *)*v213;
        }

        while (v213);
      }

      else
      {
        do
        {
          int v214 = (void *)v210[2];
          BOOL v88 = *v214 == (void)v210;
          int v210 = v214;
        }

        while (!v88);
      }

      int v210 = v214;
    }

    while (v214 != (void *)(a1 + 1440));
  }

  id v215 = (os_log_s *)qword_1008F7620;
  if (os_log_type_enabled((os_log_t)qword_1008F7620, OS_LOG_TYPE_DEFAULT))
  {
    *(_WORD *)int buf = 0;
    _os_log_impl( (void *)&_mh_execute_header,  v215,  OS_LOG_TYPE_DEFAULT,  "statedump: Outgoing LE Connection Deny List:",  buf,  2u);
  }

  id v216 = *(void **)(a1 + 1456);
  if (v216 != (void *)(a1 + 1464))
  {
    do
    {
      uint64_t v217 = (os_log_s *)qword_1008F7620;
      if (os_log_type_enabled((os_log_t)qword_1008F7620, OS_LOG_TYPE_DEFAULT))
      {
        sub_1005B8B90((uint64_t)(v216 + 6), (std::stringbuf::string_type *)buf);
        v218 = buf[23] >= 0 ? buf : *(_BYTE **)buf;
        *(_DWORD *)uuid_string_t out = 136446210;
        *(void *)&out[4] = v218;
        _os_log_impl( (void *)&_mh_execute_header,  v217,  OS_LOG_TYPE_DEFAULT,  "statedump:    %{public}s",  (uint8_t *)out,  0xCu);
        if ((buf[23] & 0x80000000) != 0) {
          operator delete(*(void **)buf);
        }
      }

      id v219 = (void *)v216[1];
      if (v219)
      {
        do
        {
          uint64_t v220 = v219;
          id v219 = (void *)*v219;
        }

        while (v219);
      }

      else
      {
        do
        {
          uint64_t v220 = (void *)v216[2];
          BOOL v88 = *v220 == (void)v216;
          id v216 = v220;
        }

        while (!v88);
      }

      id v216 = v220;
    }

    while (v220 != (void *)(a1 + 1464));
  }

  v221 = (os_log_s *)qword_1008F7620;
  if (os_log_type_enabled((os_log_t)qword_1008F7620, OS_LOG_TYPE_DEFAULT))
  {
    *(_WORD *)int buf = 0;
    _os_log_impl( (void *)&_mh_execute_header,  v221,  OS_LOG_TYPE_DEFAULT,  "statedump: Controller AutoReconnect map:",  buf,  2u);
  }

  id v222 = *(const unsigned __int8 **)(a1 + 800);
  if (v222 != (const unsigned __int8 *)(a1 + 808))
  {
    do
    {
      id v223 = (os_log_s *)qword_1008F7620;
      if (os_log_type_enabled((os_log_t)qword_1008F7620, OS_LOG_TYPE_DEFAULT))
      {
        memset(buf, 0, 37);
        uuid_unparse_upper(v222 + 26, buf);
        sub_10002418C(out, buf);
        uint64_t v224 = out[23] >= 0 ? out : *(char **)out;
        int v225 = *((unsigned __int16 *)v222 + 21);
        *(_DWORD *)int buf = 136446466;
        *(void *)&uint8_t buf[4] = v224;
        *(_WORD *)&_BYTE buf[12] = 1024;
        *(_DWORD *)&buf[14] = v225;
        _os_log_impl( (void *)&_mh_execute_header,  v223,  OS_LOG_TYPE_DEFAULT,  "statedump:    %{public}s timeout:%d",  buf,  0x12u);
        if (out[23] < 0) {
          operator delete(*(void **)out);
        }
      }

      int v226 = (unsigned __int8 *)*((void *)v222 + 1);
      if (v226)
      {
        do
        {
          v227 = (const unsigned __int8 **)v226;
          int v226 = *(unsigned __int8 **)v226;
        }

        while (v226);
      }

      else
      {
        do
        {
          v227 = (const unsigned __int8 **)*((void *)v222 + 2);
          BOOL v88 = *v227 == v222;
          id v222 = (const unsigned __int8 *)v227;
        }

        while (!v88);
      }

      id v222 = (const unsigned __int8 *)v227;
    }

    while (v227 != (const unsigned __int8 **)(a1 + 808));
  }

  sub_1005B31CC((void *)a1);
  sub_1005B3614((void *)a1);
}

void sub_1005BBE68(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

uint64_t sub_1005BBFF8@<X0>(unint64_t *a1@<X0>, std::stringbuf::string_type *a2@<X8>)
{
  unint64_t v4 = *a1;
  uint64_t v22 = 0LL;
  memset(v21, 0, sizeof(v21));
  __int128 v19 = 0u;
  __int128 v20 = 0u;
  *(_OWORD *)__int128 __p = 0u;
  __int128 v16 = 0u;
  memset(v17, 0, sizeof(v17));
  sub_1001FCFC8((uint64_t)&v16);
  if (v4 >> 7 >= 0x2A3)
  {
    uint64_t v5 = (void *)std::ostream::operator<<(v17, v4 / 0x15180);
    sub_1001FD17C(v5, (uint64_t)"days, ", 6LL);
  }

  unint64_t v6 = v4 % 0x15180;
  if (v6 >= 0xE10)
  {
    uint64_t v7 = (void *)std::ostream::operator<<(v17, v6 / 0xE10uLL);
    sub_1001FD17C(v7, (uint64_t)"hours, ", 7LL);
  }

  if (v6 % 0xE10 >= 0x3C)
  {
    uint64_t v8 = (void *)std::ostream::operator<<(v17, v6 % 0xE10 / 0x3C);
    sub_1001FD17C(v8, (uint64_t)"minutes, ", 9LL);
  }

  unint64_t v9 = (void *)std::ostream::operator<<(v17, *a1);
  unsigned int v10 = sub_1001FD17C(v9, (uint64_t)".", 1LL);
  uint64_t v11 = *v10;
  *(uint64_t *)((char *)v10 + *(void *)(*v10 - 24) + 16) = 3LL;
  *(uint64_t *)((char *)v10 + *(void *)(v11 - 24) + 24) = 3LL;
  unsigned __int8 v15 = 48;
  unsigned int v12 = sub_100361614(v10, &v15);
  std::ostream::operator<<(v12, a1[1]);
  std::stringbuf::str(a2, (const std::stringbuf *)((char *)v17 + 8));
  *(void *)((char *)&v17[-1]
  *(void *)&v17[0] = v13;
  if (SHIBYTE(v19) < 0) {
    operator delete(__p[1]);
  }
  std::streambuf::~streambuf((char *)v17 + 8);
  return std::ios::~ios(v21);
}

void sub_1005BC1FC(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, ...)
{
}

void sub_1005BC214(uint64_t a1)
{
  if (qword_1008D5F10 != -1) {
    dispatch_once(&qword_1008D5F10, &stru_1008A2B10);
  }
  sub_10058C25C( (uint64_t)off_1008D5F08,  *(void *)(a1 + 32),  *(_BYTE *)(a1 + 48),  *(_DWORD *)(a1 + 40),  *(_BYTE *)(a1 + 49),  *(_DWORD *)(a1 + 44));
}

uint64_t sub_1005BC278(uint64_t a1)
{
  uint64_t result = *(void *)(a1 + 24);
  if (result) {
    return (*(uint64_t (**)(uint64_t))(*(void *)result + 8LL))(result);
  }
  return result;
}

uint64_t sub_1005BC298(uint64_t a1)
{
  if (qword_1008D5F10 != -1) {
    dispatch_once(&qword_1008D5F10, &stru_1008A2B10);
  }
  return sub_1005AD524((uint64_t)off_1008D5F08, (unsigned __int8 *)(a1 + 24));
}

void sub_1005BC2E8(uint64_t a1, void *a2)
{
  if (a2)
  {
    sub_1005BC2E8(a1, *a2);
    sub_1005BC2E8(a1, a2[1]);
    sub_1005BC330((uint64_t)(a2 + 4));
    operator delete(a2);
  }

void sub_1005BC330(uint64_t a1)
{
  id v2 = *(void **)(a1 + 64);
  if (v2)
  {
    *(void *)(a1 + 72) = v2;
    operator delete(v2);
  }
}

void sub_1005BC360(uint64_t a1, void *a2)
{
  if (a2)
  {
    sub_1005BC360(a1, *a2);
    sub_1005BC360(a1, a2[1]);

    operator delete(a2);
  }

void sub_1005BC3B0(id a1)
{
  uint64_t v1 = operator new(0x618uLL);
  sub_1005872D8((uint64_t)v1);
  off_1008D5F08 = v1;
}

void sub_1005BC3E0(_Unwind_Exception *a1)
{
}

void sub_1005BC3F4(id a1)
{
  uint64_t v1 = operator new(0x128uLL);
  sub_1005C69F8();
  off_1008D5F28 = v1;
}

void sub_1005BC424(_Unwind_Exception *a1)
{
}

uint64_t *sub_1005BC438( uint64_t **a1, unsigned __int8 *uu1, uint64_t a3, const unsigned __int8 *__attribute__((__org_typedef(uuid_t))) *a4)
{
  uint64_t v9 = 0LL;
  unint64_t v6 = (uint64_t **)sub_1001FD824((uint64_t)a1, &v9, uu1);
  uint64_t result = *v6;
  if (!*v6)
  {
    memset(v8, 0, sizeof(v8));
    sub_1005BC4D8((uint64_t)a1, a4, v8);
    sub_100029630(a1, v9, v6, (uint64_t *)v8[0]);
    return (uint64_t *)v8[0];
  }

  return result;
}

void sub_1005BC4D8( uint64_t a1@<X0>, const unsigned __int8 *__attribute__((__org_typedef(uuid_t))) *a2@<X2>, unsigned __int8 **a3@<X8>)
{
  uint64_t v5 = (unsigned __int8 *)(a1 + 8);
  *a3 = 0LL;
  a3[1] = 0LL;
  a3[2] = 0LL;
  unint64_t v6 = (unsigned __int8 *)operator new(0x38uLL);
  *a3 = v6;
  a3[1] = v5;
  *((_BYTE *)a3 + 16) = 0;
  uuid_copy(v6 + 32, *a2);
  *((void *)v6 + 6) = 0LL;
  *((_BYTE *)a3 + 16) = 1;
}

void sub_1005BC538(_Unwind_Exception *a1)
{
  void *v1 = 0LL;
  operator delete(v2);
  _Unwind_Resume(a1);
}

uint64_t **sub_1005BC550(uint64_t **a1, unsigned int *a2, uint64_t a3, _DWORD **a4)
{
  uint64_t v7 = a1 + 1;
  unint64_t v6 = a1[1];
  if (v6)
  {
    unsigned int v8 = *a2;
    while (1)
    {
      while (1)
      {
        uint64_t v9 = (uint64_t **)v6;
        unsigned int v10 = *((_DWORD *)v6 + 7);
        if (v8 >= v10) {
          break;
        }
        unint64_t v6 = *v9;
        uint64_t v7 = v9;
        if (!*v9) {
          goto LABEL_10;
        }
      }

      if (v10 >= v8) {
        break;
      }
      unint64_t v6 = v9[1];
      if (!v6)
      {
        uint64_t v7 = v9 + 1;
        goto LABEL_10;
      }
    }
  }

  else
  {
    uint64_t v9 = a1 + 1;
LABEL_10:
    uint64_t v11 = operator new(0x28uLL);
    v11[7] = **a4;
    *((_WORD *)v11 + 16) = 0;
    sub_100029630(a1, (uint64_t)v9, v7, (uint64_t *)v11);
    return (uint64_t **)v11;
  }

  return v9;
}

char *sub_1005BC610(uint64_t **a1, unsigned int *a2, uint64_t a3, uint64_t **a4)
{
  uint64_t v10 = 0LL;
  unint64_t v6 = sub_1005BC69C((uint64_t)a1, &v10, a2);
  uint64_t v7 = (uint64_t *)*v6;
  if (!*v6)
  {
    unsigned int v8 = (uint64_t **)v6;
    uint64_t v7 = (uint64_t *)operator new(0x28uLL);
    *(uint64_t *)((char *)v7 + 28) = **a4;
    *((_BYTE *)v7 + 36) = 0;
    sub_100029630(a1, v10, v8, v7);
  }

  return (char *)v7;
}

uint64_t *sub_1005BC69C(uint64_t a1, void *a2, unsigned int *a3)
{
  uint64_t v5 = *(uint64_t **)(a1 + 8);
  uint64_t result = (uint64_t *)(a1 + 8);
  unint64_t v4 = v5;
  if (v5)
  {
    unsigned int v6 = *a3;
    int v7 = a3[1];
    do
    {
      while (1)
      {
        unsigned int v8 = v4;
        unsigned int v9 = *((_DWORD *)v4 + 7);
        int v10 = *((_DWORD *)v8 + 8);
        BOOL v11 = v7 < v10;
        if (v6 != v9) {
          BOOL v11 = v6 < v9;
        }
        if (!v11) {
          break;
        }
        unint64_t v4 = (uint64_t *)*v8;
        uint64_t result = v8;
        if (!*v8) {
          goto LABEL_15;
        }
      }

      BOOL v12 = v10 < v7;
      if (v6 == v9) {
        BOOL v13 = v12;
      }
      else {
        BOOL v13 = v9 < v6;
      }
      if (!v13) {
        break;
      }
      uint64_t result = v8 + 1;
      unint64_t v4 = (uint64_t *)v8[1];
    }

    while (v4);
  }

  else
  {
    unsigned int v8 = result;
  }

uint64_t sub_1005BC71C(uint64_t a1, unsigned int *a2)
{
  uint64_t v4 = *(void *)(a1 + 8);
  uint64_t v2 = a1 + 8;
  uint64_t v3 = v4;
  if (!v4) {
    return v2;
  }
  unsigned int v5 = *a2;
  int v6 = a2[1];
  uint64_t v7 = v2;
  do
  {
    unsigned int v8 = *(_DWORD *)(v3 + 28);
    BOOL v10 = v8 == v5;
    BOOL v9 = v8 < v5;
    if (v10) {
      BOOL v9 = *(_DWORD *)(v3 + 32) < v6;
    }
    BOOL v10 = !v9;
    if (v9) {
      BOOL v11 = (uint64_t *)(v3 + 8);
    }
    else {
      BOOL v11 = (uint64_t *)v3;
    }
    if (v10) {
      uint64_t v7 = v3;
    }
    uint64_t v3 = *v11;
  }

  while (*v11);
  if (v7 == v2) {
    return v2;
  }
  unsigned int v12 = *(_DWORD *)(v7 + 28);
  BOOL v13 = v6 < *(_DWORD *)(v7 + 32);
  BOOL v10 = v5 == v12;
  BOOL v14 = v5 < v12;
  if (v10) {
    BOOL v14 = v13;
  }
  if (v14) {
    return v2;
  }
  return v7;
}

void sub_1005BC790(id a1)
{
  uint64_t v1 = operator new(0x230uLL);
  sub_10042BC28();
  off_1008D60A8 = v1;
}

void sub_1005BC7C0(_Unwind_Exception *a1)
{
}

void sub_1005BC7D4(id a1)
{
  uint64_t v1 = (char *)operator new(0x200uLL);
  *(void *)uint64_t v1 = off_100898F60;
  *((void *)v1 + 1) = &off_100898FF0;
  *((void *)v1 + 2) = off_100899008;
  *((void *)v1 + 3) = &off_100899060;
  *((void *)v1 + 4) = &off_100899078;
  sub_100242DC4(v1 + 40);
  *((void *)v1 + 14) = 0LL;
  *((_DWORD *)v1 + 30) = 0;
  *((void *)v1 + 17) = 0LL;
  *((void *)v1 + 18) = 0LL;
  *((void *)v1 + 16) = 0LL;
  *(_OWORD *)(v1 + 155) = 0u;
  *(_OWORD *)(v1 + 171) = 0u;
  *(_OWORD *)(v1 + 187) = 0u;
  *(_WORD *)(v1 + 203) = 1;
  *((void *)v1 + 26) = 0LL;
  *((_WORD *)v1 + 108) = 256;
  *((void *)v1 + 29) = 0LL;
  *((void *)v1 + 28) = v1 + 232;
  *((void *)v1 + 32) = 0LL;
  *((void *)v1 + 33) = 0LL;
  *((void *)v1 + 30) = 0LL;
  *((void *)v1 + 31) = v1 + 256;
  v1[272] = 0;
  *((_DWORD *)v1 + 69) = 0;
  v1[280] = 0;
  *((_WORD *)v1 + 189) = 0;
  *(void *)(v1 + 313) = 0LL;
  *(_OWORD *)(v1 + 300) = 0u;
  *(_OWORD *)(v1 + 284) = 0u;
  *(_OWORD *)(v1 + 328) = 0u;
  *(_OWORD *)(v1 + 344) = 0u;
  *(_OWORD *)(v1 + 360) = 0u;
  v1[376] = 0;
  *((void *)v1 + 51) = v1 + 416;
  *((void *)v1 + 52) = 0LL;
  *((void *)v1 + 55) = 0LL;
  *((void *)v1 + 56) = 0LL;
  *((void *)v1 + 53) = 0LL;
  *((void *)v1 + 54) = v1 + 440;
  *((void *)v1 + 57) = v1 + 464;
  *((void *)v1 + 58) = 0LL;
  *((void *)v1 + 59) = 0LL;
  *((void *)v1 + 60) = @"XZ";
  *((void *)v1 + 62) = 0LL;
  *((_DWORD *)v1 + 126) = 0;
  off_1008D6190 = v1;
}

void sub_1005BC8DC(_Unwind_Exception *a1)
{
}

void sub_1005BC8F0(id a1)
{
  uint64_t v1 = operator new(0xA8uLL);
  sub_10005109C((uint64_t)v1);
  qword_1008D6620 = (uint64_t)v1;
}

void sub_1005BC920(_Unwind_Exception *a1)
{
}

void sub_1005BC934(id a1)
{
  uint64_t v1 = operator new(0xA8uLL);
  sub_10064B7C8();
  qword_1008D92A0 = (uint64_t)v1;
}

void sub_1005BC964(_Unwind_Exception *a1)
{
}

uint64_t *sub_1005BC978(uint64_t **a1, unint64_t *a2, uint64_t a3, uint64_t **a4)
{
  uint64_t v7 = a1 + 1;
  int v6 = a1[1];
  if (v6)
  {
    unint64_t v8 = *a2;
    while (1)
    {
      while (1)
      {
        BOOL v9 = (uint64_t **)v6;
        unint64_t v10 = v6[4];
        if (v8 >= v10) {
          break;
        }
        int v6 = *v9;
        uint64_t v7 = v9;
        if (!*v9) {
          goto LABEL_10;
        }
      }

      if (v10 >= v8) {
        break;
      }
      int v6 = v9[1];
      if (!v6)
      {
        uint64_t v7 = v9 + 1;
        goto LABEL_10;
      }
    }
  }

  else
  {
    BOOL v9 = a1 + 1;
LABEL_10:
    BOOL v11 = (uint64_t *)operator new(0x38uLL);
    void v11[4] = **a4;
    v11[5] = 0LL;
    v11[6] = 0LL;
    sub_100029630(a1, (uint64_t)v9, v7, v11);
    return v11;
  }

  return (uint64_t *)v9;
}

char *sub_1005BCA38(uint64_t a1, char *__src, char *a3)
{
  uint64_t v3 = a3;
  uint64_t v4 = __src;
  int v6 = *(char **)(a1 + 8);
  uint64_t v8 = a1 + 16;
  unint64_t v7 = *(void *)(a1 + 16);
  if ((unint64_t)v6 >= v7)
  {
    BOOL v13 = *(char **)a1;
    unint64_t v14 = ((uint64_t)&v6[-*(void *)a1] >> 3) + 1;
    if (v14 >> 61) {
      abort();
    }
    uint64_t v15 = __src - v13;
    uint64_t v16 = (__src - v13) >> 3;
    uint64_t v17 = v7 - (void)v13;
    if (v17 >> 2 > v14) {
      unint64_t v14 = v17 >> 2;
    }
    else {
      unint64_t v18 = v14;
    }
    uint64_t v30 = a1 + 16;
    if (v18) {
      __int128 v19 = (char *)sub_100008BA0(a1 + 16, v18);
    }
    else {
      __int128 v19 = 0LL;
    }
    __int128 v20 = &v19[8 * v16];
    __int128 __p = v19;
    uint64_t v27 = v20;
    __int128 v28 = v20;
    int v29 = &v19[8 * v18];
    if (v16 == v18)
    {
      if (v15 < 1)
      {
        if (v13 == v4) {
          unint64_t v22 = 1LL;
        }
        else {
          unint64_t v22 = v15 >> 2;
        }
        uint64_t v23 = (char *)sub_100008BA0(v8, v22);
        __int128 v20 = &v23[8 * (v22 >> 2)];
        __int128 __p = v23;
        uint64_t v27 = v20;
        int v29 = &v23[8 * v24];
        if (v19) {
          operator delete(v19);
        }
      }

      else
      {
        unint64_t v21 = v16 + 2;
        if (v16 >= -1) {
          unint64_t v21 = v16 + 1;
        }
        v20 -= 8 * (v21 >> 1);
        uint64_t v27 = v20;
      }
    }

    *(void *)__int128 v20 = *(void *)v3;
    __int128 v28 = v20 + 8;
    uint64_t v4 = sub_100008ADC((void **)a1, (uint64_t)&__p, v4);
    if (v28 != v27) {
      v28 += (v27 - v28 + 7) & 0xFFFFFFFFFFFFFFF8LL;
    }
    if (__p) {
      operator delete(__p);
    }
  }

  else if (__src == v6)
  {
    *(void *)__src = *(void *)a3;
    *(void *)(a1 + 8) = __src + 8;
  }

  else
  {
    BOOL v9 = __src + 8;
    unint64_t v10 = v6 - 8;
    BOOL v11 = *(void **)(a1 + 8);
    while (v10 < v6)
    {
      uint64_t v12 = *(void *)v10;
      v10 += 8;
      *v11++ = v12;
    }

    *(void *)(a1 + 8) = v11;
    if (v6 != v9) {
      memmove(&v6[-8 * ((v6 - v9) >> 3)], __src, v6 - v9);
    }
    if (v4 <= v3) {
      v3 += 8 * (*(void *)(a1 + 8) > (unint64_t)v3);
    }
    *(void *)uint64_t v4 = *(void *)v3;
  }

  return v4;
}

void sub_1005BCC3C( _Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void *__p, uint64_t a11, uint64_t a12)
{
  if (__p) {
    operator delete(__p);
  }
  _Unwind_Resume(exception_object);
}

uint64_t sub_1005BCC74(uint64_t a1, unsigned __int8 *uu2)
{
  uint64_t v2 = a1 + 8;
  uint64_t v3 = *(void *)(a1 + 8);
  if (!v3) {
    return v2;
  }
  uint64_t v5 = a1 + 8;
  do
  {
    int v6 = uuid_compare((const unsigned __int8 *)(v3 + 26), uu2);
    unint64_t v7 = (uint64_t *)(v3 + 8);
    if (v6 >= 0)
    {
      unint64_t v7 = (uint64_t *)v3;
      uint64_t v5 = v3;
    }

    uint64_t v3 = *v7;
  }

  while (*v7);
  return v5;
}

uint64_t *sub_1005BCCEC(uint64_t **a1, unsigned __int8 *uu1, const unsigned __int8 *a3)
{
  uint64_t v8 = 0LL;
  uint64_t v5 = (uint64_t **)sub_1005BCD74((uint64_t)a1, &v8, uu1);
  uint64_t result = *v5;
  if (!*v5)
  {
    memset(v7, 0, sizeof(v7));
    sub_1005BCE04((uint64_t)a1, a3, v7);
    sub_100029630(a1, v8, v5, (uint64_t *)v7[0]);
    return (uint64_t *)v7[0];
  }

  return result;
}

void *sub_1005BCD74(uint64_t a1, void *a2, unsigned __int8 *uu1)
{
  uint64_t v5 = (void *)(a1 + 8);
  uint64_t v4 = *(void *)(a1 + 8);
  if (v4)
  {
    do
    {
      while (1)
      {
        unint64_t v7 = (void *)v4;
        uint64_t v8 = (const unsigned __int8 *)(v4 + 25);
        uint64_t v4 = *v7;
        uint64_t v5 = v7;
        if (!*v7) {
          goto LABEL_9;
        }
      }

      if ((uuid_compare(v8, uu1) & 0x80000000) == 0) {
        break;
      }
      uint64_t v5 = v7 + 1;
      uint64_t v4 = v7[1];
    }

    while (v4);
  }

  else
  {
    unint64_t v7 = (void *)(a1 + 8);
  }

void sub_1005BCE04(uint64_t a1@<X0>, const unsigned __int8 *a2@<X1>, unsigned __int8 **a3@<X8>)
{
  uint64_t v5 = (unsigned __int8 *)(a1 + 8);
  *a3 = 0LL;
  a3[1] = 0LL;
  a3[2] = 0LL;
  int v6 = (unsigned __int8 *)operator new(0x30uLL);
  *a3 = v6;
  a3[1] = v5;
  *((_BYTE *)a3 + 16) = 0;
  uuid_copy(v6 + 25, a2);
  *((_BYTE *)a3 + 16) = 1;
}

void sub_1005BCE60(_Unwind_Exception *a1)
{
  void *v1 = 0LL;
  operator delete(v2);
  _Unwind_Resume(a1);
}

uint64_t *sub_1005BCE78(uint64_t a1, unint64_t *a2, uint64_t a3, void **a4)
{
  int v6 = (uint64_t **)(a1 + 8);
  uint64_t v5 = *(uint64_t **)(a1 + 8);
  if (v5)
  {
    unint64_t v7 = *a2;
    while (1)
    {
      while (1)
      {
        uint64_t v8 = (uint64_t **)v5;
        unint64_t v9 = v5[4];
        if (v7 >= v9) {
          break;
        }
        uint64_t v5 = *v8;
        int v6 = v8;
        if (!*v8) {
          goto LABEL_10;
        }
      }

      if (v9 >= v7) {
        break;
      }
      uint64_t v5 = v8[1];
      if (!v5)
      {
        int v6 = v8 + 1;
        goto LABEL_10;
      }
    }
  }

  else
  {
    uint64_t v8 = (uint64_t **)(a1 + 8);
LABEL_10:
    memset(v11, 0, sizeof(v11));
    sub_1005BCF38(a1, a4, v11);
    sub_100029630((uint64_t **)a1, (uint64_t)v8, v6, v11[0]);
    return v11[0];
  }

  return (uint64_t *)v8;
}

void sub_1005BCF38(uint64_t a1@<X0>, void **a2@<X2>, void *a3@<X8>)
{
  uint64_t v5 = a1 + 8;
  *a3 = 0LL;
  a3[1] = 0LL;
  a3[2] = 0LL;
  int v6 = operator new(0x38uLL);
  *a3 = v6;
  a3[1] = v5;
  *((_BYTE *)a3 + 16) = 0;
  *((void *)v6 + 4) = **a2;
  uuid_clear((unsigned __int8 *)v6 + 40);
  *((_BYTE *)a3 + 16) = 1;
}

void sub_1005BCF9C(_Unwind_Exception *a1)
{
  void *v1 = 0LL;
  operator delete(v2);
  _Unwind_Resume(a1);
}

uint64_t *sub_1005BCFB4(uint64_t **a1, const void **a2, uint64_t a3, __int128 **a4)
{
  uint64_t v9 = 0LL;
  int v6 = (uint64_t **)sub_10023E6A4((uint64_t)a1, &v9, a2);
  uint64_t result = *v6;
  if (!*v6)
  {
    memset(v8, 0, sizeof(v8));
    sub_1005BD054((uint64_t)a1, a4, v8);
    sub_100029630(a1, v9, v6, v8[0]);
    return v8[0];
  }

  return result;
}

_BYTE *sub_1005BD054@<X0>(uint64_t a1@<X0>, __int128 **a2@<X2>, void *a3@<X8>)
{
  uint64_t v5 = a1 + 8;
  *a3 = 0LL;
  a3[2] = 0LL;
  a3[1] = 0LL;
  int v6 = a3 + 1;
  unint64_t v7 = (char *)operator new(0x50uLL);
  *a3 = v7;
  *int v6 = v5;
  *((_BYTE *)a3 + 16) = 0;
  uint64_t result = v7 + 32;
  uint64_t v9 = *a2;
  if (*((char *)*a2 + 23) < 0)
  {
    uint64_t result = sub_100024238(result, *(void **)v9, *((void *)v9 + 1));
  }

  else
  {
    __int128 v10 = *v9;
    *((void *)v7 + 6) = *((void *)v9 + 2);
    *(_OWORD *)uint64_t result = v10;
  }

  *((void *)v7 + 7) = 0LL;
  *((void *)v7 + 8) = 0LL;
  *((_DWORD *)v7 + 18) = 0;
  *((_BYTE *)a3 + 16) = 1;
  return result;
}

void sub_1005BD0EC(_Unwind_Exception *a1)
{
  void *v1 = 0LL;
  sub_10023E740(v3, v2);
  _Unwind_Resume(a1);
}

uint64_t *sub_1005BD108( uint64_t **a1, unsigned __int8 *uu1, uint64_t a3, const unsigned __int8 *__attribute__((__org_typedef(uuid_t))) *a4)
{
  uint64_t v9 = 0LL;
  int v6 = (uint64_t **)sub_1005BD1A8((uint64_t)a1, &v9, uu1);
  uint64_t result = *v6;
  if (!*v6)
  {
    memset(v8, 0, sizeof(v8));
    sub_1005BD238((uint64_t)a1, a4, v8);
    sub_100029630(a1, v9, v6, (uint64_t *)v8[0]);
    return (uint64_t *)v8[0];
  }

  return result;
}

void *sub_1005BD1A8(uint64_t a1, void *a2, unsigned __int8 *uu1)
{
  uint64_t v5 = (void *)(a1 + 8);
  uint64_t v4 = *(void *)(a1 + 8);
  if (v4)
  {
    do
    {
      while (1)
      {
        unint64_t v7 = (void *)v4;
        uint64_t v8 = (const unsigned __int8 *)(v4 + 28);
        uint64_t v4 = *v7;
        uint64_t v5 = v7;
        if (!*v7) {
          goto LABEL_9;
        }
      }

      if ((uuid_compare(v8, uu1) & 0x80000000) == 0) {
        break;
      }
      uint64_t v5 = v7 + 1;
      uint64_t v4 = v7[1];
    }

    while (v4);
  }

  else
  {
    unint64_t v7 = (void *)(a1 + 8);
  }

void sub_1005BD238( uint64_t a1@<X0>, const unsigned __int8 *__attribute__((__org_typedef(uuid_t))) *a2@<X2>, unsigned __int8 **a3@<X8>)
{
  uint64_t v5 = (unsigned __int8 *)(a1 + 8);
  *a3 = 0LL;
  a3[1] = 0LL;
  a3[2] = 0LL;
  int v6 = (unsigned __int8 *)operator new(0x30uLL);
  *a3 = v6;
  a3[1] = v5;
  *((_BYTE *)a3 + 16) = 0;
  uuid_copy(v6 + 28, *a2);
  *((_DWORD *)v6 + 11) = 0;
  *((_BYTE *)a3 + 16) = 1;
}

void sub_1005BD298(_Unwind_Exception *a1)
{
  void *v1 = 0LL;
  operator delete(v2);
  _Unwind_Resume(a1);
}

uint64_t sub_1005BD2B0(uint64_t a1, unsigned __int8 *uu2)
{
  uint64_t v2 = a1 + 8;
  uint64_t v3 = *(void *)(a1 + 8);
  if (!v3) {
    return v2;
  }
  uint64_t v5 = a1 + 8;
  do
  {
    int v6 = uuid_compare((const unsigned __int8 *)(v3 + 28), uu2);
    unint64_t v7 = (uint64_t *)(v3 + 8);
    if (v6 >= 0)
    {
      unint64_t v7 = (uint64_t *)v3;
      uint64_t v5 = v3;
    }

    uint64_t v3 = *v7;
  }

  while (*v7);
  return v5;
}

uint64_t *sub_1005BD328( uint64_t **a1, unsigned __int8 *uu1, uint64_t a3, const unsigned __int8 *__attribute__((__org_typedef(uuid_t))) *a4)
{
  uint64_t v9 = 0LL;
  int v6 = (uint64_t **)sub_1005BD1A8((uint64_t)a1, &v9, uu1);
  uint64_t result = *v6;
  if (!*v6)
  {
    memset(v8, 0, sizeof(v8));
    sub_1005BD3C8((uint64_t)a1, a4, v8);
    sub_100029630(a1, v9, v6, v8[0]);
    return v8[0];
  }

  return result;
}

double sub_1005BD3C8@<D0>( uint64_t a1@<X0>, const unsigned __int8 *__attribute__((__org_typedef(uuid_t))) *a2@<X2>, void *a3@<X8>)
{
  uint64_t v5 = a1 + 8;
  *a3 = 0LL;
  a3[1] = 0LL;
  a3[2] = 0LL;
  int v6 = (char *)operator new(0x50uLL);
  *a3 = v6;
  a3[1] = v5;
  *((_BYTE *)a3 + 16) = 0;
  uuid_copy((unsigned __int8 *)v6 + 28, *a2);
  *((_DWORD *)v6 + 19) = 0;
  double result = 0.0;
  *(_OWORD *)(v6 + 60) = 0u;
  *(_OWORD *)(v6 + 44) = 0u;
  *((_BYTE *)a3 + 16) = 1;
  return result;
}

void sub_1005BD434(_Unwind_Exception *a1)
{
  void *v1 = 0LL;
  operator delete(v2);
  _Unwind_Resume(a1);
}

uint64_t **sub_1005BD44C(uint64_t **a1, unint64_t *a2, uint64_t a3, uint64_t **a4)
{
  unint64_t v7 = a1 + 1;
  int v6 = a1[1];
  if (v6)
  {
    unint64_t v8 = *a2;
    while (1)
    {
      while (1)
      {
        uint64_t v9 = (uint64_t **)v6;
        unint64_t v10 = v6[4];
        if (v8 >= v10) {
          break;
        }
        int v6 = *v9;
        unint64_t v7 = v9;
        if (!*v9) {
          goto LABEL_10;
        }
      }

      if (v10 >= v8) {
        break;
      }
      int v6 = v9[1];
      if (!v6)
      {
        unint64_t v7 = v9 + 1;
        goto LABEL_10;
      }
    }
  }

  else
  {
    uint64_t v9 = a1 + 1;
LABEL_10:
    BOOL v11 = operator new(0x38uLL);
    uint64_t v12 = **a4;
    v11[24] = 0;
    *((void *)v11 + 4) = v12;
    *((void *)v11 + 5) = 0LL;
    sub_100029630(a1, (uint64_t)v9, v7, (uint64_t *)v11);
    return (uint64_t **)v11;
  }

  return v9;
}

uint64_t *sub_1005BD50C( uint64_t **a1, unsigned __int8 *uu1, uint64_t a3, const unsigned __int8 *__attribute__((__org_typedef(uuid_t))) *a4)
{
  uint64_t v9 = 0LL;
  int v6 = (uint64_t **)sub_1001FD824((uint64_t)a1, &v9, uu1);
  double result = *v6;
  if (!*v6)
  {
    memset(v8, 0, sizeof(v8));
    sub_1005BD5AC((uint64_t)a1, a4, v8);
    sub_100029630(a1, v9, v6, (uint64_t *)v8[0]);
    return (uint64_t *)v8[0];
  }

  return result;
}

void sub_1005BD5AC( uint64_t a1@<X0>, const unsigned __int8 *__attribute__((__org_typedef(uuid_t))) *a2@<X2>, unsigned __int8 **a3@<X8>)
{
  uint64_t v5 = a1 + 8;
  *a3 = 0LL;
  a3[2] = 0LL;
  a3[1] = 0LL;
  int v6 = a3 + 1;
  unint64_t v7 = (unsigned __int8 *)operator new(0x48uLL);
  *a3 = v7;
  *int v6 = v5;
  *((_BYTE *)a3 + 16) = 0;
  uuid_copy(v7 + 32, *a2);
  *((void *)v7 + 7) = 0LL;
  *((void *)v7 + 8) = 0LL;
  *((void *)v7 + 6) = v7 + 56;
  *((_BYTE *)a3 + 16) = 1;
}

void sub_1005BD624(_Unwind_Exception *a1)
{
  void *v1 = 0LL;
  sub_1004F5910(v2, v3);
  _Unwind_Resume(a1);
}

uint64_t sub_1005BD640(uint64_t a1, unsigned __int8 *uu2)
{
  uint64_t v2 = a1 + 8;
  uint64_t v3 = *(void *)(a1 + 8);
  if (!v3) {
    return v2;
  }
  uint64_t v5 = a1 + 8;
  do
  {
    int v6 = uuid_compare((const unsigned __int8 *)(v3 + 25), uu2);
    unint64_t v7 = (uint64_t *)(v3 + 8);
    if (v6 >= 0)
    {
      unint64_t v7 = (uint64_t *)v3;
      uint64_t v5 = v3;
    }

    uint64_t v3 = *v7;
  }

  while (*v7);
  return v5;
}

uint64_t *sub_1005BD6B8( uint64_t **a1, unsigned __int8 *uu1, uint64_t a3, const unsigned __int8 *__attribute__((__org_typedef(uuid_t))) *a4)
{
  uint64_t v9 = 0LL;
  int v6 = (uint64_t **)sub_1001FD824((uint64_t)a1, &v9, uu1);
  double result = *v6;
  if (!*v6)
  {
    memset(v8, 0, sizeof(v8));
    sub_1005BD758((uint64_t)a1, a4, v8);
    sub_100029630(a1, v9, v6, (uint64_t *)v8[0]);
    return (uint64_t *)v8[0];
  }

  return result;
}

void sub_1005BD758( uint64_t a1@<X0>, const unsigned __int8 *__attribute__((__org_typedef(uuid_t))) *a2@<X2>, unsigned __int8 **a3@<X8>)
{
  uint64_t v5 = (unsigned __int8 *)(a1 + 8);
  *a3 = 0LL;
  a3[1] = 0LL;
  a3[2] = 0LL;
  int v6 = (unsigned __int8 *)operator new(0x38uLL);
  *a3 = v6;
  a3[1] = v5;
  *((_BYTE *)a3 + 16) = 0;
  uuid_copy(v6 + 32, *a2);
  *((void *)v6 + 6) = 0LL;
  *((_BYTE *)a3 + 16) = 1;
}

void sub_1005BD7B8(_Unwind_Exception *a1)
{
  void *v1 = 0LL;
  operator delete(v2);
  _Unwind_Resume(a1);
}

uint64_t *sub_1005BD7D0( uint64_t **a1, unsigned __int8 *uu1, uint64_t a3, const unsigned __int8 *__attribute__((__org_typedef(uuid_t))) *a4)
{
  uint64_t v9 = 0LL;
  int v6 = (uint64_t **)sub_1001FD824((uint64_t)a1, &v9, uu1);
  double result = *v6;
  if (!*v6)
  {
    memset(v8, 0, sizeof(v8));
    sub_1005BD870((uint64_t)a1, a4, v8);
    sub_100029630(a1, v9, v6, (uint64_t *)v8[0]);
    return (uint64_t *)v8[0];
  }

  return result;
}

void sub_1005BD870( uint64_t a1@<X0>, const unsigned __int8 *__attribute__((__org_typedef(uuid_t))) *a2@<X2>, unsigned __int8 **a3@<X8>)
{
  uint64_t v5 = (unsigned __int8 *)(a1 + 8);
  *a3 = 0LL;
  a3[1] = 0LL;
  a3[2] = 0LL;
  int v6 = (unsigned __int8 *)operator new(0x38uLL);
  *a3 = v6;
  a3[1] = v5;
  *((_BYTE *)a3 + 16) = 0;
  uuid_copy(v6 + 32, *a2);
  *((void *)v6 + 6) = 0LL;
  *((_BYTE *)a3 + 16) = 1;
}

void sub_1005BD8D0(_Unwind_Exception *a1)
{
  void *v1 = 0LL;
  operator delete(v2);
  _Unwind_Resume(a1);
}

uint64_t *sub_1005BD8E8(uint64_t a1, unint64_t *a2, uint64_t a3, void **a4)
{
  int v6 = (uint64_t **)(a1 + 8);
  uint64_t v5 = *(uint64_t **)(a1 + 8);
  if (v5)
  {
    unint64_t v7 = *a2;
    while (1)
    {
      while (1)
      {
        unint64_t v8 = (uint64_t **)v5;
        unint64_t v9 = v5[4];
        if (v7 >= v9) {
          break;
        }
        uint64_t v5 = *v8;
        int v6 = v8;
        if (!*v8) {
          goto LABEL_10;
        }
      }

      if (v9 >= v7) {
        break;
      }
      uint64_t v5 = v8[1];
      if (!v5)
      {
        int v6 = v8 + 1;
        goto LABEL_10;
      }
    }
  }

  else
  {
    unint64_t v8 = (uint64_t **)(a1 + 8);
LABEL_10:
    memset(v11, 0, sizeof(v11));
    sub_1005BD9A8(a1, a4, v11);
    sub_100029630((uint64_t **)a1, (uint64_t)v8, v6, v11[0]);
    return v11[0];
  }

  return (uint64_t *)v8;
}

void sub_1005BD9A8(uint64_t a1@<X0>, void **a2@<X2>, void *a3@<X8>)
{
  uint64_t v5 = a1 + 8;
  *a3 = 0LL;
  a3[1] = 0LL;
  a3[2] = 0LL;
  int v6 = operator new(0x38uLL);
  *a3 = v6;
  a3[1] = v5;
  *((_BYTE *)a3 + 16) = 0;
  *((void *)v6 + 4) = **a2;
  uuid_clear((unsigned __int8 *)v6 + 40);
  *((_BYTE *)a3 + 16) = 1;
}

void sub_1005BDA0C(_Unwind_Exception *a1)
{
  void *v1 = 0LL;
  operator delete(v2);
  _Unwind_Resume(a1);
}

uint64_t *sub_1005BDA24( uint64_t **a1, unsigned __int8 *uu1, uint64_t a3, const unsigned __int8 *__attribute__((__org_typedef(uuid_t))) *a4)
{
  uint64_t v9 = 0LL;
  int v6 = (uint64_t **)sub_1001FD824((uint64_t)a1, &v9, uu1);
  double result = *v6;
  if (!*v6)
  {
    memset(v8, 0, sizeof(v8));
    sub_1005BDAC4((uint64_t)a1, a4, v8);
    sub_100029630(a1, v9, v6, (uint64_t *)v8[0]);
    return (uint64_t *)v8[0];
  }

  return result;
}

void sub_1005BDAC4( uint64_t a1@<X0>, const unsigned __int8 *__attribute__((__org_typedef(uuid_t))) *a2@<X2>, unsigned __int8 **a3@<X8>)
{
  uint64_t v5 = (unsigned __int8 *)(a1 + 8);
  *a3 = 0LL;
  a3[1] = 0LL;
  a3[2] = 0LL;
  int v6 = (unsigned __int8 *)operator new(0x38uLL);
  *a3 = v6;
  a3[1] = v5;
  *((_BYTE *)a3 + 16) = 0;
  uuid_copy(v6 + 32, *a2);
  *((void *)v6 + 6) = 0LL;
  *((_BYTE *)a3 + 16) = 1;
}

void sub_1005BDB24(_Unwind_Exception *a1)
{
  void *v1 = 0LL;
  operator delete(v2);
  _Unwind_Resume(a1);
}

void sub_1005BDB3C(id a1)
{
  uint64_t v1 = operator new(0x138uLL);
  sub_1003FE3E0((uint64_t)v1);
  off_1008D5F48 = v1;
}

void sub_1005BDB6C(_Unwind_Exception *a1)
{
}

void sub_1005BDB80(id a1)
{
  uint64_t v1 = operator new(0xEB0uLL);
  sub_10061991C();
  qword_1008D5F18 = (uint64_t)v1;
}

void sub_1005BDBB0(_Unwind_Exception *a1)
{
}

uint64_t sub_1005BDBC4(uint64_t a1, const unsigned __int8 *a2)
{
  uint64_t v2 = *(unsigned __int8 **)a1;
  uint64_t v3 = (uint64_t)(*(void *)(a1 + 8) - *(void *)a1) >> 4;
  unint64_t v4 = v3 + 1;
  uint64_t v8 = *(void *)(a1 + 16);
  uint64_t v7 = a1 + 16;
  uint64_t v9 = v8 - (void)v2;
  if (v9 >> 3 > v4) {
    unint64_t v4 = v9 >> 3;
  }
  else {
    unint64_t v10 = v4;
  }
  uint64_t v18 = v7;
  if (v10) {
    BOOL v11 = (char *)sub_1003ADAF8(v7, v10);
  }
  else {
    BOOL v11 = 0LL;
  }
  __int128 __p = v11;
  unsigned __int8 *__attribute__((__org_typedef(uuid_t))) v15 = (unsigned __int8 *)&v11[16 * v3];
  uint64_t v17 = &v11[16 * v10];
  uuid_copy(v15, a2);
  uint64_t v16 = v15 + 16;
  sub_1005BDCE8((unsigned __int8 **)a1, &__p);
  uint64_t v12 = *(void *)(a1 + 8);
  if (v16 != v15) {
    v16 += (v15 - v16 + 15) & 0xFFFFFFFFFFFFFFF0LL;
  }
  if (__p) {
    operator delete(__p);
  }
  return v12;
}

void sub_1005BDCB0( _Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void *__p, uint64_t a11, uint64_t a12)
{
  if (__p) {
    operator delete(__p);
  }
  _Unwind_Resume(exception_object);
}

void sub_1005BDCE8(unsigned __int8 **a1, void *a2)
{
  uint64_t v5 = *a1;
  unint64_t v4 = a1[1];
  int v6 = (unsigned __int8 *)a2[1];
  while (v4 != v5)
  {
    v6 -= 16;
    v4 -= 16;
    uuid_copy(v6, v4);
  }

  a2[1] = v6;
  uint64_t v7 = *a1;
  *a1 = v6;
  a2[1] = v7;
  uint64_t v8 = a1[1];
  a1[1] = (unsigned __int8 *)a2[2];
  a2[2] = v8;
  uint64_t v9 = a1[2];
  a1[2] = (unsigned __int8 *)a2[3];
  a2[3] = v9;
  *a2 = a2[1];
}

uint64_t *sub_1005BDD78( uint64_t **a1, unsigned __int8 *uu1, uint64_t a3, const unsigned __int8 *__attribute__((__org_typedef(uuid_t))) *a4)
{
  uint64_t v9 = 0LL;
  int v6 = (uint64_t **)sub_1005BDE18((uint64_t)a1, &v9, uu1);
  double result = *v6;
  if (!*v6)
  {
    memset(v8, 0, sizeof(v8));
    sub_1005BDEA8((uint64_t)a1, a4, v8);
    sub_100029630(a1, v9, v6, (uint64_t *)v8[0]);
    return (uint64_t *)v8[0];
  }

  return result;
}

void *sub_1005BDE18(uint64_t a1, void *a2, unsigned __int8 *uu1)
{
  uint64_t v5 = (void *)(a1 + 8);
  uint64_t v4 = *(void *)(a1 + 8);
  if (v4)
  {
    do
    {
      while (1)
      {
        uint64_t v7 = (void *)v4;
        uint64_t v8 = (const unsigned __int8 *)(v4 + 26);
        uint64_t v4 = *v7;
        uint64_t v5 = v7;
        if (!*v7) {
          goto LABEL_9;
        }
      }

      if ((uuid_compare(v8, uu1) & 0x80000000) == 0) {
        break;
      }
      uint64_t v5 = v7 + 1;
      uint64_t v4 = v7[1];
    }

    while (v4);
  }

  else
  {
    uint64_t v7 = (void *)(a1 + 8);
  }

void sub_1005BDEA8( uint64_t a1@<X0>, const unsigned __int8 *__attribute__((__org_typedef(uuid_t))) *a2@<X2>, unsigned __int8 **a3@<X8>)
{
  uint64_t v5 = (unsigned __int8 *)(a1 + 8);
  *a3 = 0LL;
  a3[1] = 0LL;
  a3[2] = 0LL;
  int v6 = (unsigned __int8 *)operator new(0x30uLL);
  *a3 = v6;
  a3[1] = v5;
  *((_BYTE *)a3 + 16) = 0;
  uuid_copy(v6 + 26, *a2);
  *((_WORD *)v6 + 21) = 0;
  *((_BYTE *)a3 + 16) = 1;
}

void sub_1005BDF08(_Unwind_Exception *a1)
{
  void *v1 = 0LL;
  operator delete(v2);
  _Unwind_Resume(a1);
}

void sub_1005BDF20(id a1)
{
  uint64_t v1 = operator new(0x1A0uLL);
  sub_1002769A4();
  off_1008D67C0 = v1;
}

void sub_1005BDF50(_Unwind_Exception *a1)
{
}

void sub_1005BDF64(id a1)
{
  uint64_t v1 = operator new(0xE8uLL);
  sub_100243588((uint64_t)v1);
  qword_1008D9150 = (uint64_t)v1;
}

void sub_1005BDF94(_Unwind_Exception *a1)
{
}

uint64_t *sub_1005BDFA8( uint64_t **a1, unsigned __int8 *uu1, uint64_t a3, const unsigned __int8 *__attribute__((__org_typedef(uuid_t))) *a4)
{
  uint64_t v9 = 0LL;
  int v6 = (uint64_t **)sub_1005BDE18((uint64_t)a1, &v9, uu1);
  double result = *v6;
  if (!*v6)
  {
    memset(v8, 0, sizeof(v8));
    sub_1005BE048((uint64_t)a1, a4, v8);
    sub_100029630(a1, v9, v6, (uint64_t *)v8[0]);
    return (uint64_t *)v8[0];
  }

  return result;
}

void sub_1005BE048( uint64_t a1@<X0>, const unsigned __int8 *__attribute__((__org_typedef(uuid_t))) *a2@<X2>, unsigned __int8 **a3@<X8>)
{
  uint64_t v5 = (unsigned __int8 *)(a1 + 8);
  *a3 = 0LL;
  a3[1] = 0LL;
  a3[2] = 0LL;
  int v6 = (unsigned __int8 *)operator new(0x30uLL);
  *a3 = v6;
  a3[1] = v5;
  *((_BYTE *)a3 + 16) = 0;
  uuid_copy(v6 + 26, *a2);
  *((_WORD *)v6 + 21) = 0;
  *((_BYTE *)a3 + 16) = 1;
}

void sub_1005BE0A8(_Unwind_Exception *a1)
{
  void *v1 = 0LL;
  operator delete(v2);
  _Unwind_Resume(a1);
}

uint64_t sub_1005BE0C0(uint64_t **a1, unsigned __int8 *a2)
{
  uint64_t v3 = (uint64_t *)sub_1005BD2B0((uint64_t)a1, a2);
  uint64_t v4 = v3;
  sub_1001FDBCC(a1, v3);
  operator delete(v4);
  return 1LL;
}

uint64_t sub_1005BE110(uint64_t **a1, unsigned __int8 *a2)
{
  uint64_t v3 = (uint64_t *)sub_1005BCC74((uint64_t)a1, a2);
  uint64_t v4 = v3;
  sub_1001FDBCC(a1, v3);
  operator delete(v4);
  return 1LL;
}

uint64_t *sub_1005BE160(uint64_t *a1, uint64_t a2)
{
  a1[2] = 0LL;
  a1[1] = 0LL;
  *a1 = (uint64_t)(a1 + 1);
  sub_1002BB9EC(a1, *(void **)a2, (void *)(a2 + 8));
  return a1;
}

void sub_1005BE19C(_Unwind_Exception *a1)
{
}

uint64_t *sub_1005BE1B4( uint64_t **a1, unsigned __int8 *uu1, uint64_t a3, const unsigned __int8 *__attribute__((__org_typedef(uuid_t))) *a4)
{
  uint64_t v9 = 0LL;
  int v6 = (uint64_t **)sub_1005BD1A8((uint64_t)a1, &v9, uu1);
  double result = *v6;
  if (!*v6)
  {
    memset(v8, 0, sizeof(v8));
    sub_1005BE254((uint64_t)a1, a4, v8);
    sub_100029630(a1, v9, v6, v8[0]);
    return v8[0];
  }

  return result;
}

double sub_1005BE254@<D0>( uint64_t a1@<X0>, const unsigned __int8 *__attribute__((__org_typedef(uuid_t))) *a2@<X2>, void *a3@<X8>)
{
  uint64_t v5 = a1 + 8;
  *a3 = 0LL;
  a3[1] = 0LL;
  a3[2] = 0LL;
  int v6 = (char *)operator new(0x50uLL);
  *a3 = v6;
  a3[1] = v5;
  *((_BYTE *)a3 + 16) = 0;
  uuid_copy((unsigned __int8 *)v6 + 28, *a2);
  *((_DWORD *)v6 + 19) = 0;
  double result = 0.0;
  *(_OWORD *)(v6 + 60) = 0u;
  *(_OWORD *)(v6 + 44) = 0u;
  *((_BYTE *)a3 + 16) = 1;
  return result;
}

void sub_1005BE2C0(_Unwind_Exception *a1)
{
  void *v1 = 0LL;
  operator delete(v2);
  _Unwind_Resume(a1);
}

uint64_t *sub_1005BE2D8(uint64_t *a1, uint64_t a2)
{
  a1[2] = 0LL;
  a1[1] = 0LL;
  *a1 = (uint64_t)(a1 + 1);
  sub_1002BB9EC(a1, *(void **)a2, (void *)(a2 + 8));
  return a1;
}

void sub_1005BE314(_Unwind_Exception *a1)
{
}

void *sub_1005BE32C(void *a1, uint64_t a2)
{
  *a1 = a1;
  a1[1] = a1;
  a1[2] = 0LL;
  uint64_t v3 = *(void *)(a2 + 8);
  if (v3 != a2)
  {
    uint64_t v5 = 1LL;
    int v6 = a1;
    do
    {
      uint64_t v7 = operator new(0x20uLL);
      v7[1] = *(_OWORD *)(v3 + 16);
      *(void *)uint64_t v7 = v6;
      *((void *)v7 + 1) = a1;
      *((void *)v6 + 1) = v7;
      *a1 = v7;
      a1[2] = v5;
      uint64_t v3 = *(void *)(v3 + 8);
      ++v5;
      int v6 = v7;
    }

    while (v3 != a2);
  }

  return a1;
}

void sub_1005BE3B0(_Unwind_Exception *a1)
{
}

char *sub_1005BE3C4(uint64_t **a1, const void **a2, uint64_t a3, __int128 **a4)
{
  uint64_t v11 = 0LL;
  int v6 = (char **)sub_10023E6A4((uint64_t)a1, &v11, a2);
  uint64_t v7 = *v6;
  if (!*v6)
  {
    uint64_t v8 = (uint64_t **)v6;
    memset(v10, 0, sizeof(v10));
    sub_1005BE478((uint64_t)a1, a4, v10);
    sub_100029630(a1, v11, v8, (uint64_t *)v10[0]);
    uint64_t v7 = v10[0];
    v10[0] = 0LL;
    sub_1005BE540((uint64_t)v10, 0LL);
  }

  return v7;
}

char *sub_1005BE478@<X0>(uint64_t a1@<X0>, __int128 **a2@<X2>, char **a3@<X8>)
{
  uint64_t v5 = (char *)(a1 + 8);
  *a3 = 0LL;
  a3[1] = 0LL;
  a3[2] = 0LL;
  int v6 = (char *)operator new(0x50uLL);
  *a3 = v6;
  a3[1] = v5;
  *((_BYTE *)a3 + 16) = 0;
  double result = sub_1005BE4E8(v6 + 32, *a2);
  *((_BYTE *)a3 + 16) = 1;
  return result;
}

void sub_1005BE4D0(_Unwind_Exception *a1)
{
}

char *sub_1005BE4E8(char *__dst, __int128 *a2)
{
  if (*((char *)a2 + 23) < 0)
  {
    sub_100024238(__dst, *(void **)a2, *((void *)a2 + 1));
  }

  else
  {
    __int128 v3 = *a2;
    *((void *)__dst + 2) = *((void *)a2 + 2);
    *(_OWORD *)__uuid_t dst = v3;
  }

  *((void *)__dst + 3) = __dst + 24;
  *((void *)__dst + 4) = __dst + 24;
  *((void *)__dst + 5) = 0LL;
  return __dst;
}

void sub_1005BE540(uint64_t a1, uint64_t a2)
{
  uint64_t v2 = *(void **)a1;
  *(void *)a1 = a2;
  if (v2)
  {
    if (*(_BYTE *)(a1 + 16)) {
      sub_100291D30((uint64_t)v2 + 32);
    }
    operator delete(v2);
  }

uint64_t *sub_1005BE584(uint64_t *a1, uint64_t a2, uint64_t a3)
{
  for (uint64_t i = (uint64_t *)a1[1]; a2 != a3 && i != a1; uint64_t i = (uint64_t *)i[1])
  {
    *((_OWORD *)i + 1) = *(_OWORD *)(a2 + 16);
    a2 = *(void *)(a2 + 8);
  }

  if (i == a1) {
    return sub_1005BE5D4((uint64_t)a1, a1, a2, a3);
  }
  else {
    return sub_10040F0C4((uint64_t)a1, i, a1);
  }
}

uint64_t *sub_1005BE5D4(uint64_t a1, uint64_t *a2, uint64_t a3, uint64_t a4)
{
  if (a3 != a4)
  {
    uint64_t v8 = operator new(0x20uLL);
    uint64_t v9 = v8;
    *uint64_t v8 = 0LL;
    v8[1] = 0LL;
    *((_OWORD *)v8 + 1) = *(_OWORD *)(a3 + 16);
    uint64_t v10 = *(void *)(a3 + 8);
    uint64_t v11 = 1LL;
    if (v10 != a4)
    {
      uint64_t v12 = v8;
      do
      {
        uint64_t v8 = operator new(0x20uLL);
        *uint64_t v8 = v12;
        v8[1] = 0LL;
        *((_OWORD *)v8 + 1) = *(_OWORD *)(v10 + 16);
        v12[1] = v8;
        ++v11;
        uint64_t v10 = *(void *)(v10 + 8);
        uint64_t v12 = v8;
      }

      while (v10 != a4);
    }

    uint64_t v13 = *a2;
    *(void *)(v13 + 8) = v9;
    *uint64_t v9 = v13;
    *a2 = (uint64_t)v8;
    v8[1] = a2;
    *(void *)(a1 + 16) += v11;
    return v9;
  }

  return a2;
}

uint64_t *sub_1005BE6A4(uint64_t **a1, const void **a2, uint64_t a3, __int128 **a4)
{
  uint64_t v9 = 0LL;
  int v6 = (uint64_t **)sub_10023E6A4((uint64_t)a1, &v9, a2);
  double result = *v6;
  if (!*v6)
  {
    memset(v8, 0, sizeof(v8));
    sub_1005BE744((uint64_t)a1, a4, v8);
    sub_100029630(a1, v9, v6, v8[0]);
    return v8[0];
  }

  return result;
}

_BYTE *sub_1005BE744@<X0>(uint64_t a1@<X0>, __int128 **a2@<X2>, void *a3@<X8>)
{
  uint64_t v5 = a1 + 8;
  *a3 = 0LL;
  a3[2] = 0LL;
  a3[1] = 0LL;
  int v6 = a3 + 1;
  uint64_t v7 = (char *)operator new(0x40uLL);
  *a3 = v7;
  *int v6 = v5;
  *((_BYTE *)a3 + 16) = 0;
  double result = v7 + 32;
  uint64_t v9 = *a2;
  if (*((char *)*a2 + 23) < 0)
  {
    double result = sub_100024238(result, *(void **)v9, *((void *)v9 + 1));
  }

  else
  {
    __int128 v10 = *v9;
    *((void *)v7 + 6) = *((void *)v9 + 2);
    *(_OWORD *)double result = v10;
  }

  *((_DWORD *)v7 + 14) = 0;
  *((_BYTE *)a3 + 16) = 1;
  return result;
}

void sub_1005BE7D8(_Unwind_Exception *a1)
{
  void *v1 = 0LL;
  sub_10023E740(v3, v2);
  _Unwind_Resume(a1);
}

void *sub_1005BE7F4(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  uint64_t v7 = operator new(0x28uLL);
  *uint64_t v7 = a2;
  v7[1] = a3;
  uint64_t v8 = v7 + 2;
  if (*(char *)(a4 + 23) < 0)
  {
    sub_100024238(v8, *(void **)a4, *(void *)(a4 + 8));
  }

  else
  {
    *(_OWORD *)uint64_t v8 = *(_OWORD *)a4;
    v7[4] = *(void *)(a4 + 16);
  }

  return v7;
}

void sub_1005BE858(_Unwind_Exception *a1)
{
}

uint64_t *sub_1005BE86C( uint64_t **a1, uint64_t *a2, unint64_t a3, unsigned int (**a4)(uint64_t, uint64_t))
{
  uint64_t v4 = a1;
  if (a3 >= 2)
  {
    if (a3 == 2)
    {
      uint64_t v7 = (uint64_t *)*a2;
      if ((*a4)(*a2 + 16, (uint64_t)(a1 + 2)))
      {
        uint64_t v8 = *v7;
        *(void *)(v8 + 8) = v7[1];
        *(void *)v7[1] = v8;
        uint64_t v9 = *v4;
        v9[1] = (uint64_t)v7;
        *uint64_t v7 = (uint64_t)v9;
        *uint64_t v4 = v7;
        v7[1] = (uint64_t)v4;
        return v7;
      }
    }

    else
    {
      unint64_t v11 = a3 >> 1;
      unint64_t v12 = (a3 >> 1) + 1;
      uint64_t v13 = a1;
      do
      {
        uint64_t v13 = (uint64_t **)v13[1];
        --v12;
      }

      while (v12 > 1);
      unint64_t v14 = (uint64_t **)sub_1005BE86C(a1, v13, a3 >> 1, a4);
      uint64_t v4 = (uint64_t **)sub_1005BE86C(v13, a2, a3 - v11, a4);
      if ((*a4)((uint64_t)(v4 + 2), (uint64_t)(v14 + 2)))
      {
        for (uint64_t i = v4[1]; i != a2; uint64_t i = (uint64_t *)i[1])
        {
        }

        uint64_t i = a2;
LABEL_14:
        uint64_t v17 = *i;
        uint64_t v18 = *v4;
        v18[1] = *(void *)(*i + 8);
        **(void **)(v17 + 8) = v18;
        __int128 v19 = *v14;
        uint64_t v16 = v14[1];
        v19[1] = (uint64_t)v4;
        *uint64_t v4 = v19;
        *unint64_t v14 = (uint64_t *)v17;
        *(void *)(v17 + 8) = v14;
      }

      else
      {
        uint64_t v16 = v14[1];
        uint64_t i = (uint64_t *)v4;
        uint64_t v4 = v14;
      }

      if (v16 != i && i != a2)
      {
        __int128 v20 = i;
        do
        {
          if ((*a4)((uint64_t)(i + 2), (uint64_t)(v16 + 2)))
          {
            for (j = (uint64_t *)i[1]; j != a2; j = (uint64_t *)j[1])
            {
            }

            j = a2;
LABEL_25:
            uint64_t v22 = *j;
            uint64_t v23 = *i;
            *(void *)(v23 + 8) = *(void *)(*j + 8);
            **(void **)(v22 + 8) = v23;
            if (v20 == i) {
              __int128 v20 = j;
            }
            uint64_t v25 = *v16;
            uint64_t v24 = (uint64_t *)v16[1];
            *(void *)(v25 + 8) = i;
            uint64_t *i = v25;
            uint64_t *v16 = v22;
            *(void *)(v22 + 8) = v16;
            uint64_t v16 = v24;
            uint64_t i = j;
          }

          else
          {
            uint64_t v16 = (uint64_t *)v16[1];
          }
        }

        while (v16 != v20 && i != a2);
      }
    }
  }

  return (uint64_t *)v4;
}

uint64_t *sub_1005BEA78(uint64_t **a1, unsigned __int8 *uu1, const unsigned __int8 *a3)
{
  uint64_t v8 = 0LL;
  uint64_t v5 = (uint64_t **)sub_1005BCD74((uint64_t)a1, &v8, uu1);
  double result = *v5;
  if (!*v5)
  {
    memset(v7, 0, sizeof(v7));
    sub_1005BEB00((uint64_t)a1, a3, v7);
    sub_100029630(a1, v8, v5, (uint64_t *)v7[0]);
    return (uint64_t *)v7[0];
  }

  return result;
}

void sub_1005BEB00(uint64_t a1@<X0>, const unsigned __int8 *a2@<X1>, unsigned __int8 **a3@<X8>)
{
  uint64_t v5 = (unsigned __int8 *)(a1 + 8);
  *a3 = 0LL;
  a3[1] = 0LL;
  a3[2] = 0LL;
  int v6 = (unsigned __int8 *)operator new(0x30uLL);
  *a3 = v6;
  a3[1] = v5;
  *((_BYTE *)a3 + 16) = 0;
  uuid_copy(v6 + 25, a2);
  *((_BYTE *)a3 + 16) = 1;
}

void sub_1005BEB5C(_Unwind_Exception *a1)
{
  void *v1 = 0LL;
  operator delete(v2);
  _Unwind_Resume(a1);
}

void sub_1005BEB74(void ***a1)
{
  uint64_t v2 = *a1;
  if (*v2)
  {
    sub_1005BEBB4((uint64_t)v2, (uint64_t)*v2);
    operator delete(**a1);
  }

void sub_1005BEBB4(uint64_t a1, uint64_t a2)
{
  for (uint64_t i = *(void *)(a1 + 8); i != a2; i -= 40LL)
  {

    uint64_t v5 = *(void **)(i - 40);
  }

  *(void *)(a1 + 8) = a2;
}

uint64_t *sub_1005BEC04(uint64_t *result, void *a2)
{
  uint64_t v3 = *result;
  uint64_t v2 = result[1];
  uint64_t v4 = a2[1];
  while (v2 != v3)
  {
    uint64_t v5 = *(void *)(v2 - 40);
    v2 -= 40LL;
    *(void *)uint64_t v2 = 0LL;
    *(void *)(v4 - 40) = v5;
    v4 -= 40LL;
    __int128 v6 = *(_OWORD *)(v2 + 8);
    *(_DWORD *)(v4 + 24) = *(_DWORD *)(v2 + 24);
    *(_OWORD *)(v4 + 8) = v6;
    uint64_t v7 = *(void *)(v2 + 32);
    *(void *)(v2 + 32) = 0LL;
    *(void *)(v4 + 32) = v7;
  }

  a2[1] = v4;
  uint64_t v8 = *result;
  *double result = v4;
  a2[1] = v8;
  uint64_t v9 = result[1];
  result[1] = a2[2];
  a2[2] = v9;
  uint64_t v10 = result[2];
  result[2] = a2[3];
  a2[3] = v10;
  *a2 = a2[1];
  return result;
}

uint64_t sub_1005BEC7C(uint64_t a1)
{
  if (*(void *)a1) {
    operator delete(*(void **)a1);
  }
  return a1;
}

void sub_1005BECB0(uint64_t a1, uint64_t a2)
{
  for (uint64_t i = *(void *)(a1 + 16); i != a2; uint64_t i = *(void *)(a1 + 16))
  {
    *(void *)(a1 + 16) = i - 40;
  }

void *sub_1005BED08(void *result, uint64_t a2, uint64_t a3, unint64_t a4)
{
  if (a4)
  {
    __int128 v6 = result;
    sub_1004511FC(result, a4);
    double result = (void *)sub_1005BED64((uint64_t)(v6 + 2), a2, a3, v6[1]);
    v6[1] = result;
  }

  return result;
}

void sub_1005BED5C(_Unwind_Exception *a1)
{
  *(void *)(v1 + 8) = v2;
  _Unwind_Resume(a1);
}

uint64_t sub_1005BED64(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  if (a2 != a3)
  {
    uint64_t v6 = a2;
    do
    {
      *(void *)a4 = *(id *)v6;
      __int128 v7 = *(_OWORD *)(v6 + 8);
      *(_DWORD *)(a4 + 24) = *(_DWORD *)(v6 + 24);
      *(_OWORD *)(a4 + 8) = v7;
      *(void *)(a4 + 32) = objc_retainBlock(*(id *)(v6 + 32));
      a4 += 40LL;
      v6 += 40LL;
    }

    while (v6 != a3);
  }

  return a4;
}

uint64_t sub_1005BEDD4(uint64_t **a1, unsigned __int8 *a2)
{
  uint64_t v3 = (uint64_t *)sub_1005BD640((uint64_t)a1, a2);
  uint64_t v4 = v3;
  sub_1001FDBCC(a1, v3);
  operator delete(v4);
  return 1LL;
}

void sub_1005BEE24(id a1)
{
  uint64_t v1 = operator new(0x18uLL);
  *(void *)uint64_t v1 = 0LL;
  v1[2] = 0;
  *((_BYTE *)v1 + 12) = 0;
  v1[4] = 0;
  qword_1008D9058 = (uint64_t)v1;
}

uint64_t *sub_1005BEE54( uint64_t **a1, unsigned __int8 *uu1, uint64_t a3, const unsigned __int8 *__attribute__((__org_typedef(uuid_t))) *a4)
{
  uint64_t v9 = 0LL;
  uint64_t v6 = (uint64_t **)sub_1001FD824((uint64_t)a1, &v9, uu1);
  double result = *v6;
  if (!*v6)
  {
    memset(v8, 0, sizeof(v8));
    sub_1005BEEF4((uint64_t)a1, a4, v8);
    sub_100029630(a1, v9, v6, (uint64_t *)v8[0]);
    return (uint64_t *)v8[0];
  }

  return result;
}

double sub_1005BEEF4@<D0>( uint64_t a1@<X0>, const unsigned __int8 *__attribute__((__org_typedef(uuid_t))) *a2@<X2>, unsigned __int8 **a3@<X8>)
{
  uint64_t v5 = a1 + 8;
  *a3 = 0LL;
  a3[2] = 0LL;
  a3[1] = 0LL;
  uint64_t v6 = a3 + 1;
  __int128 v7 = (unsigned __int8 *)operator new(0x78uLL);
  *a3 = v7;
  *uint64_t v6 = v5;
  *((_BYTE *)a3 + 16) = 0;
  uuid_copy(v7 + 32, *a2);
  *((void *)v7 + 14) = 0LL;
  double result = 0.0;
  *((_OWORD *)v7 + 5) = 0u;
  *((_OWORD *)v7 + 6) = 0u;
  *((_OWORD *)v7 + 3) = 0u;
  *((_OWORD *)v7 + 4) = 0u;
  *((_BYTE *)a3 + 16) = 1;
  return result;
}

void sub_1005BEF74(_Unwind_Exception *a1)
{
  void *v1 = 0LL;
  sub_1005BEF90(v3, v2);
  _Unwind_Resume(a1);
}

void sub_1005BEF90(uint64_t a1, id *a2)
{
  if (*(_BYTE *)(a1 + 8))
  {
  }

  else if (!a2)
  {
    return;
  }

  operator delete(a2);
}

uint64_t sub_1005BEFDC(uint64_t **a1, unsigned __int8 *a2)
{
  uint64_t v3 = sub_1001FDB10((uint64_t)a1, a2);
  sub_1005BF020(a1, v3);
  return 1LL;
}

uint64_t *sub_1005BF020(uint64_t **a1, uint64_t a2)
{
  uint64_t v3 = sub_1001FDBCC(a1, (uint64_t *)a2);

  operator delete((void *)a2);
  return v3;
}

unsigned __int8 *sub_1005BF060( uint64_t **a1, unsigned __int8 *uu1, uint64_t a3, const unsigned __int8 *__attribute__((__org_typedef(uuid_t))) *a4)
{
  uint64_t v11 = 0LL;
  uint64_t v6 = (unsigned __int8 **)sub_1001FD824((uint64_t)a1, &v11, uu1);
  __int128 v7 = *v6;
  if (!*v6)
  {
    uint64_t v8 = (uint64_t **)v6;
    memset(v10, 0, sizeof(v10));
    sub_1005BF114((uint64_t)a1, a4, v10);
    sub_100029630(a1, v11, v8, (uint64_t *)v10[0]);
    __int128 v7 = v10[0];
    v10[0] = 0LL;
    sub_1005BF198((uint64_t)v10, 0LL);
  }

  return v7;
}

double sub_1005BF114@<D0>( uint64_t a1@<X0>, const unsigned __int8 *__attribute__((__org_typedef(uuid_t))) *a2@<X2>, unsigned __int8 **a3@<X8>)
{
  uint64_t v5 = (unsigned __int8 *)(a1 + 8);
  *a3 = 0LL;
  a3[1] = 0LL;
  a3[2] = 0LL;
  uint64_t v6 = (unsigned __int8 *)operator new(0x78uLL);
  *a3 = v6;
  a3[1] = v5;
  *((_BYTE *)a3 + 16) = 0;
  uuid_copy(v6 + 32, *a2);
  *((void *)v6 + 14) = 0LL;
  double result = 0.0;
  *((_OWORD *)v6 + 5) = 0u;
  *((_OWORD *)v6 + 6) = 0u;
  *((_OWORD *)v6 + 3) = 0u;
  *((_OWORD *)v6 + 4) = 0u;
  *((_BYTE *)a3 + 16) = 1;
  return result;
}

void sub_1005BF180(_Unwind_Exception *a1)
{
}

void sub_1005BF198(uint64_t a1, uint64_t a2)
{
  uint64_t v2 = *(void **)a1;
  *(void *)a1 = a2;
  if (v2)
  {
    if (*(_BYTE *)(a1 + 16)) {
      sub_1005BC330((uint64_t)v2 + 32);
    }
    operator delete(v2);
  }

uint64_t sub_1005BF1DC(uint64_t **a1, unsigned __int8 *a2)
{
  uint64_t v3 = (uint64_t *)sub_1001FDB10((uint64_t)a1, a2);
  uint64_t v4 = v3;
  sub_1001FDBCC(a1, v3);
  sub_1005BC330((uint64_t)(v4 + 4));
  operator delete(v4);
  return 1LL;
}

uint64_t *sub_1005BF234(uint64_t *a1, uint64_t a2)
{
  a1[2] = 0LL;
  a1[1] = 0LL;
  *a1 = (uint64_t)(a1 + 1);
  sub_1005BF288(a1, *(unsigned __int8 **)a2, (unsigned __int8 *)(a2 + 8));
  return a1;
}

void sub_1005BF270(_Unwind_Exception *a1)
{
}

uint64_t *sub_1005BF288(uint64_t *result, unsigned __int8 *a2, unsigned __int8 *a3)
{
  if (a2 != a3)
  {
    uint64_t v4 = a2;
    uint64_t v5 = (uint64_t **)result;
    uint64_t v6 = result + 1;
    do
    {
      double result = sub_1005BF30C(v5, v6, v4 + 32, (uint64_t)(v4 + 32));
      __int128 v7 = (unsigned __int8 *)*((void *)v4 + 1);
      if (v7)
      {
        do
        {
          uint64_t v8 = v7;
          __int128 v7 = *(unsigned __int8 **)v7;
        }

        while (v7);
      }

      else
      {
        do
        {
          uint64_t v8 = (unsigned __int8 *)*((void *)v4 + 2);
          BOOL v9 = *(void *)v8 == (void)v4;
          uint64_t v4 = v8;
        }

        while (!v9);
      }

      uint64_t v4 = v8;
    }

    while (v8 != a3);
  }

  return result;
}

uint64_t *sub_1005BF30C(uint64_t **a1, uint64_t *a2, unsigned __int8 *uu2, uint64_t a4)
{
  uint64_t v11 = 0LL;
  unint64_t v12 = 0LL;
  uint64_t v6 = sub_1005BF3AC(a1, a2, &v12, &v11, uu2);
  __int128 v7 = *(uint64_t **)v6;
  if (!*(void *)v6)
  {
    uint64_t v8 = (uint64_t **)v6;
    memset(v10, 0, sizeof(v10));
    sub_1005BF530((uint64_t)a1, a4, v10);
    sub_100029630(a1, (uint64_t)v12, v8, v10[0]);
    __int128 v7 = v10[0];
    v10[0] = 0LL;
    sub_1005BF198((uint64_t)v10, 0LL);
  }

  return v7;
}

const unsigned __int8 *sub_1005BF3AC( void *a1, uint64_t *a2, const unsigned __int8 **a3, uint64_t *a4, unsigned __int8 *uu2)
{
  BOOL v9 = (const unsigned __int8 *)(a1 + 1);
  if (a1 + 1 == a2 || uuid_compare(uu2, (const unsigned __int8 *)a2 + 32) < 0)
  {
    if ((uint64_t *)*a1 == a2)
    {
      unint64_t v12 = (const unsigned __int8 *)a2;
    }

    else
    {
      uint64_t v11 = (const unsigned __int8 *)*a2;
      if (*a2)
      {
        do
        {
          unint64_t v12 = v11;
          uint64_t v11 = (const unsigned __int8 *)*((void *)v11 + 1);
        }

        while (v11);
      }

      else
      {
        uint64_t v16 = a2;
        do
        {
          unint64_t v12 = (const unsigned __int8 *)v16[2];
          BOOL v17 = *(void *)v12 == (void)v16;
          uint64_t v16 = (uint64_t *)v12;
        }

        while (v17);
      }

      if ((uuid_compare(v12 + 32, uu2) & 0x80000000) == 0) {
        return (const unsigned __int8 *)sub_1001FD824((uint64_t)a1, a3, uu2);
      }
    }

    if (*a2)
    {
      *a3 = v12;
      return v12 + 8;
    }

    else
    {
      *a3 = (const unsigned __int8 *)a2;
      return (const unsigned __int8 *)a2;
    }
  }

  if (uuid_compare((const unsigned __int8 *)a2 + 32, uu2) < 0)
  {
    a4 = a2 + 1;
    uint64_t v13 = a2[1];
    if (v13)
    {
      unint64_t v14 = (const unsigned __int8 *)a2[1];
      do
      {
        unsigned __int8 *__attribute__((__org_typedef(uuid_t))) v15 = v14;
        unint64_t v14 = *(const unsigned __int8 **)v14;
      }

      while (v14);
    }

    else
    {
      __int128 v19 = (const unsigned __int8 *)a2;
      do
      {
        unsigned __int8 *__attribute__((__org_typedef(uuid_t))) v15 = (const unsigned __int8 *)*((void *)v19 + 2);
        BOOL v17 = *(void *)v15 == (void)v19;
        __int128 v19 = v15;
      }

      while (!v17);
    }

    if (v15 == v9) {
      goto LABEL_27;
    }
    if (uuid_compare(uu2, v15 + 32) < 0)
    {
      uint64_t v13 = *a4;
LABEL_27:
      if (v13)
      {
        *a3 = v15;
        return v15;
      }

      else
      {
        *a3 = (const unsigned __int8 *)a2;
      }

      return (const unsigned __int8 *)a4;
    }

    return (const unsigned __int8 *)sub_1001FD824((uint64_t)a1, a3, uu2);
  }

  *a3 = (const unsigned __int8 *)a2;
  *a4 = (uint64_t)a2;
  return (const unsigned __int8 *)a4;
}

uint64_t sub_1005BF530@<X0>(uint64_t a1@<X0>, uint64_t a2@<X1>, void *a3@<X8>)
{
  uint64_t v5 = a1 + 8;
  *a3 = 0LL;
  a3[1] = 0LL;
  a3[2] = 0LL;
  uint64_t v6 = operator new(0x78uLL);
  *a3 = v6;
  a3[1] = v5;
  *((_BYTE *)a3 + 16) = 0;
  uint64_t result = sub_1005BF5A0((uint64_t)v6 + 32, a2);
  *((_BYTE *)a3 + 16) = 1;
  return result;
}

void sub_1005BF588(_Unwind_Exception *a1)
{
}

uint64_t sub_1005BF5A0(uint64_t a1, uint64_t a2)
{
  *(void *)(a1 + 16) = *(id *)(a2 + 16);
  *(_OWORD *)(a1 + 24) = *(_OWORD *)(a2 + 24);
  *(_OWORD *)(a1 + 40) = *(_OWORD *)(a2 + 40);
  *(_DWORD *)(a1 + 56) = *(_DWORD *)(a2 + 56);
  sub_100272534((void *)(a1 + 64), a2 + 64);
  return a1;
}

void sub_1005BF5F8(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

  ;
}

void *sub_1005BF62C(const unsigned __int8 *a1, uint64_t a2, ...)
{
  return sub_100366664(a1, (uint64_t *)va);
}

  ;
}

void sub_1005BF650(void *a1, uint64_t a2, os_log_t log, const char *a4, ...)
{
}

void *sub_1005BF664(void *result, unsigned __int16 a2, uint64_t a3, float a4)
{
  if (v4 >= 0) {
    uint64_t v5 = result;
  }
  else {
    uint64_t v5 = (void *)*result;
  }
  *(float *)a3 = a4;
  *(void *)(a3 + 4) = v5;
  *(_WORD *)(a3 + 12) = 1024;
  *(_DWORD *)(a3 + 14) = a2;
  return result;
}

void sub_1005BF68C(void *a1, os_log_s *a2, uint64_t a3, const char *a4, uint8_t *a5)
{
}

void sub_1005BF698(void *a1, uint64_t a2, uint64_t a3, const char *a4)
{
}

  ;
}

  ;
}

void sub_1005BF6D4(uint64_t a1@<X8>)
{
  *(void *)(v1 - 8) = a1;
}

  ;
}

  ;
}

id sub_1005BF710(id a1)
{
  return a1;
}

  ;
}

void sub_1005BF730()
{
  uint64_t v0 = objc_autoreleasePoolPush();
  sub_100243040(&stru_1008F7850);
  __cxa_atexit((void (*)(void *))sub_1002430A8, &stru_1008F7850, (void *)&_mh_execute_header);
  sub_100243040(&stru_1008F7880);
  __cxa_atexit((void (*)(void *))sub_1002430A8, &stru_1008F7880, (void *)&_mh_execute_header);
  sub_100242DC4(&unk_1008F78B0);
  __cxa_atexit((void (*)(void *))sub_100242E28, &unk_1008F78B0, (void *)&_mh_execute_header);
  sub_100242DC4(&unk_1008F78F0);
  __cxa_atexit((void (*)(void *))sub_100242E28, &unk_1008F78F0, (void *)&_mh_execute_header);
  sub_100243040(&stru_1008F7938);
  __cxa_atexit((void (*)(void *))sub_1002430A8, &stru_1008F7938, (void *)&_mh_execute_header);
  sub_100242DC4(&unk_1008F7968);
  __cxa_atexit((void (*)(void *))sub_100242E28, &unk_1008F7968, (void *)&_mh_execute_header);
  objc_autoreleasePoolPop(v0);
}

id sub_1005BF848(uint64_t a1)
{
  if ((__p.__r_.__value_.__s.__size_ & 0x80u) == 0) {
    p_p = &__p;
  }
  else {
    p_p = (std::stringbuf::string_type *)__p.__r_.__value_.__r.__words[0];
  }
  uint64_t v2 = (void *)objc_claimAutoreleasedReturnValue(+[NSString stringWithUTF8String:](&OBJC_CLASS___NSString, "stringWithUTF8String:", p_p));
  return v2;
}

void sub_1005BF8B0( _Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void *__p, uint64_t a11, int a12, __int16 a13, char a14, char a15)
{
  if (a15 < 0) {
    operator delete(__p);
  }
  _Unwind_Resume(exception_object);
}

uint64_t sub_1005BF8CC@<X0>(uint64_t a1@<X0>, std::stringbuf::string_type *a2@<X8>)
{
  uint64_t v28 = 0LL;
  __int128 v26 = 0u;
  memset(v27, 0, sizeof(v27));
  *(_OWORD *)std::stringbuf::string_type __p = 0u;
  __int128 v25 = 0u;
  memset(v23, 0, sizeof(v23));
  sub_10020E564((uint64_t)v23);
  *(_DWORD *)((char *)v23 + *(void *)(*(void *)&v23[0] - 24LL) + 8) |= 0x4000u;
  unsigned __int8 v22 = 48;
  int v4 = sub_100361614(v23, &v22);
  uint64_t v5 = *v4;
  *(uint64_t *)((char *)v4 + *(void *)(*v4 - 24) + 24) = 2LL;
  *(_DWORD *)((char *)v4 + *(void *)(v5 - 24) + 8) = *(_DWORD *)((_BYTE *)v4 + *(void *)(v5 - 24) + 8) & 0xFFFFFFB5 | 8;
  uint64_t v6 = (void *)std::ostream::operator<<(v4, BYTE5(a1));
  __int128 v7 = sub_1001FD17C(v6, (uint64_t)":", 1LL);
  uint64_t v8 = *v7;
  *(uint64_t *)((char *)v7 + *(void *)(*v7 - 24) + 24) = 2LL;
  *(_DWORD *)((char *)v7 + *(void *)(v8 - 24) + 8) = *(_DWORD *)((_BYTE *)v7 + *(void *)(v8 - 24) + 8) & 0xFFFFFFB5 | 8;
  BOOL v9 = (void *)std::ostream::operator<<(v7, BYTE4(a1));
  uint64_t v10 = sub_1001FD17C(v9, (uint64_t)":", 1LL);
  uint64_t v11 = *v10;
  *(uint64_t *)((char *)v10 + *(void *)(*v10 - 24) + 24) = 2LL;
  *(_DWORD *)((char *)v10 + *(void *)(v11 - 24) + 8) = *(_DWORD *)((_BYTE *)v10 + *(void *)(v11 - 24) + 8) & 0xFFFFFFB5 | 8;
  unint64_t v12 = (void *)std::ostream::operator<<(v10, BYTE3(a1));
  uint64_t v13 = sub_1001FD17C(v12, (uint64_t)":", 1LL);
  uint64_t v14 = *v13;
  *(uint64_t *)((char *)v13 + *(void *)(*v13 - 24) + 24) = 2LL;
  *(_DWORD *)((char *)v13 + *(void *)(v14 - 24) + 8) = *(_DWORD *)((_BYTE *)v13 + *(void *)(v14 - 24) + 8) & 0xFFFFFFB5 | 8;
  unsigned __int8 *__attribute__((__org_typedef(uuid_t))) v15 = (void *)std::ostream::operator<<(v13, BYTE2(a1));
  uint64_t v16 = sub_1001FD17C(v15, (uint64_t)":", 1LL);
  uint64_t v17 = *v16;
  *(uint64_t *)((char *)v16 + *(void *)(*v16 - 24) + 24) = 2LL;
  *(_DWORD *)((char *)v16 + *(void *)(v17 - 24) + 8) = *(_DWORD *)((_BYTE *)v16 + *(void *)(v17 - 24) + 8) & 0xFFFFFFB5 | 8;
  uint64_t v18 = (void *)std::ostream::operator<<(v16, BYTE1(a1));
  __int128 v19 = sub_1001FD17C(v18, (uint64_t)":", 1LL);
  uint64_t v20 = *v19;
  *(uint64_t *)((char *)v19 + *(void *)(*v19 - 24) + 24) = 2LL;
  *(_DWORD *)((char *)v19 + *(void *)(v20 - 24) + 8) = *(_DWORD *)((_BYTE *)v19 + *(void *)(v20 - 24) + 8) & 0xFFFFFFB5 | 8;
  std::ostream::operator<<(v19, a1);
  std::stringbuf::str(a2, (const std::stringbuf *)((char *)v23 + 8));
  if (SHIBYTE(v25) < 0) {
    operator delete(__p[1]);
  }
  std::streambuf::~streambuf((char *)v23 + 8);
  return std::ios::~ios(v27);
}

void sub_1005BFB6C(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, ...)
{
}

id sub_1005BFB9C(uint64_t a1)
{
  if ((__p.__r_.__value_.__s.__size_ & 0x80u) == 0) {
    p_p = &__p;
  }
  else {
    p_p = (std::stringbuf::string_type *)__p.__r_.__value_.__r.__words[0];
  }
  uint64_t v2 = (void *)objc_claimAutoreleasedReturnValue(+[NSString stringWithUTF8String:](&OBJC_CLASS___NSString, "stringWithUTF8String:", p_p));
  return v2;
}

void sub_1005BFC04( _Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void *__p, uint64_t a11, int a12, __int16 a13, char a14, char a15)
{
  if (a15 < 0) {
    operator delete(__p);
  }
  _Unwind_Resume(exception_object);
}

uint64_t sub_1005BFC20@<X0>(uint64_t a1@<X0>, std::stringbuf::string_type *a2@<X8>)
{
  uint64_t v30 = 0LL;
  __int128 v28 = 0u;
  memset(v29, 0, sizeof(v29));
  *(_OWORD *)std::stringbuf::string_type __p = 0u;
  __int128 v27 = 0u;
  memset(v25, 0, sizeof(v25));
  sub_10020E564((uint64_t)v25);
  if ((a1 & 0xFF000000000000LL) != 0) {
    int v4 = "Random ";
  }
  else {
    int v4 = "Public ";
  }
  uint64_t v5 = sub_1001FD17C(v25, (uint64_t)v4, 7LL);
  *(_DWORD *)((char *)v5 + *(void *)(*v5 - 24LL) + 8) |= 0x4000u;
  unsigned __int8 v24 = 48;
  uint64_t v6 = sub_100361614(v5, &v24);
  uint64_t v7 = *v6;
  *(uint64_t *)((char *)v6 + *(void *)(*v6 - 24) + 24) = 2LL;
  *(_DWORD *)((char *)v6 + *(void *)(v7 - 24) + 8) = *(_DWORD *)((_BYTE *)v6 + *(void *)(v7 - 24) + 8) & 0xFFFFFFB5 | 8;
  uint64_t v8 = (void *)std::ostream::operator<<();
  BOOL v9 = sub_1001FD17C(v8, (uint64_t)":", 1LL);
  uint64_t v10 = *v9;
  *(uint64_t *)((char *)v9 + *(void *)(*v9 - 24) + 24) = 2LL;
  *(_DWORD *)((char *)v9 + *(void *)(v10 - 24) + 8) = *(_DWORD *)((_BYTE *)v9 + *(void *)(v10 - 24) + 8) & 0xFFFFFFB5 | 8;
  uint64_t v11 = (void *)std::ostream::operator<<();
  unint64_t v12 = sub_1001FD17C(v11, (uint64_t)":", 1LL);
  uint64_t v13 = *v12;
  *(uint64_t *)((char *)v12 + *(void *)(*v12 - 24) + 24) = 2LL;
  *(_DWORD *)((char *)v12 + *(void *)(v13 - 24) + 8) = *(_DWORD *)((_BYTE *)v12 + *(void *)(v13 - 24) + 8) & 0xFFFFFFB5 | 8;
  uint64_t v14 = (void *)std::ostream::operator<<();
  unsigned __int8 *__attribute__((__org_typedef(uuid_t))) v15 = sub_1001FD17C(v14, (uint64_t)":", 1LL);
  uint64_t v16 = *v15;
  *(uint64_t *)((char *)v15 + *(void *)(*v15 - 24) + 24) = 2LL;
  *(_DWORD *)((char *)v15 + *(void *)(v16 - 24) + 8) = *(_DWORD *)((_BYTE *)v15 + *(void *)(v16 - 24) + 8) & 0xFFFFFFB5 | 8;
  uint64_t v17 = (void *)std::ostream::operator<<();
  uint64_t v18 = sub_1001FD17C(v17, (uint64_t)":", 1LL);
  uint64_t v19 = *v18;
  *(uint64_t *)((char *)v18 + *(void *)(*v18 - 24) + 24) = 2LL;
  *(_DWORD *)((char *)v18 + *(void *)(v19 - 24) + 8) = *(_DWORD *)((_BYTE *)v18 + *(void *)(v19 - 24) + 8) & 0xFFFFFFB5 | 8;
  uint64_t v20 = (void *)std::ostream::operator<<();
  unint64_t v21 = sub_1001FD17C(v20, (uint64_t)":", 1LL);
  uint64_t v22 = *v21;
  *(uint64_t *)((char *)v21 + *(void *)(*v21 - 24) + 24) = 2LL;
  *(_DWORD *)((char *)v21 + *(void *)(v22 - 24) + 8) = *(_DWORD *)((_BYTE *)v21 + *(void *)(v22 - 24) + 8) & 0xFFFFFFB5 | 8;
  std::ostream::operator<<();
  std::stringbuf::str(a2, (const std::stringbuf *)((char *)v25 + 8));
  if (SHIBYTE(v27) < 0) {
    operator delete(__p[1]);
  }
  std::streambuf::~streambuf((char *)v25 + 8);
  return std::ios::~ios(v29);
}

void sub_1005BFEE0(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, ...)
{
}

id sub_1005BFF10(uint64_t a1)
{
  if ((__p.__r_.__value_.__s.__size_ & 0x80u) == 0) {
    p_p = &__p;
  }
  else {
    p_p = (std::stringbuf::string_type *)__p.__r_.__value_.__r.__words[0];
  }
  uint64_t v2 = (void *)objc_claimAutoreleasedReturnValue(+[NSString stringWithUTF8String:](&OBJC_CLASS___NSString, "stringWithUTF8String:", p_p));
  return v2;
}

void sub_1005BFF78( _Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void *__p, uint64_t a11, int a12, __int16 a13, char a14, char a15)
{
  if (a15 < 0) {
    operator delete(__p);
  }
  _Unwind_Resume(exception_object);
}

uint64_t sub_1005BFF94@<X0>(uint64_t a1@<X0>, std::stringbuf::string_type *a2@<X8>)
{
  uint64_t v30 = 0LL;
  __int128 v28 = 0u;
  memset(v29, 0, sizeof(v29));
  *(_OWORD *)std::stringbuf::string_type __p = 0u;
  __int128 v27 = 0u;
  memset(v25, 0, sizeof(v25));
  sub_10020E564((uint64_t)v25);
  *(_DWORD *)((char *)v25 + *(void *)(*(void *)&v25[0] - 24LL) + 8) |= 0x4000u;
  unsigned __int8 v24 = 48;
  int v4 = sub_100361614(v25, &v24);
  uint64_t v5 = *v4;
  *(uint64_t *)((char *)v4 + *(void *)(*v4 - 24) + 24) = 2LL;
  *(_DWORD *)((char *)v4 + *(void *)(v5 - 24) + 8) = *(_DWORD *)((_BYTE *)v4 + *(void *)(v5 - 24) + 8) & 0xFFFFFFB5 | 8;
  uint64_t v6 = (void *)std::ostream::operator<<(v4, BYTE5(a1));
  uint64_t v7 = sub_1001FD17C(v6, (uint64_t)":", 1LL);
  uint64_t v8 = *v7;
  *(uint64_t *)((char *)v7 + *(void *)(*v7 - 24) + 24) = 2LL;
  *(_DWORD *)((char *)v7 + *(void *)(v8 - 24) + 8) = *(_DWORD *)((_BYTE *)v7 + *(void *)(v8 - 24) + 8) & 0xFFFFFFB5 | 8;
  BOOL v9 = (void *)std::ostream::operator<<(v7, BYTE4(a1));
  uint64_t v10 = sub_1001FD17C(v9, (uint64_t)":", 1LL);
  uint64_t v11 = *v10;
  *(uint64_t *)((char *)v10 + *(void *)(*v10 - 24) + 24) = 2LL;
  *(_DWORD *)((char *)v10 + *(void *)(v11 - 24) + 8) = *(_DWORD *)((_BYTE *)v10 + *(void *)(v11 - 24) + 8) & 0xFFFFFFB5 | 8;
  unint64_t v12 = (void *)std::ostream::operator<<(v10, BYTE3(a1));
  uint64_t v13 = sub_1001FD17C(v12, (uint64_t)":", 1LL);
  uint64_t v14 = *v13;
  *(uint64_t *)((char *)v13 + *(void *)(*v13 - 24) + 24) = 2LL;
  *(_DWORD *)((char *)v13 + *(void *)(v14 - 24) + 8) = *(_DWORD *)((_BYTE *)v13 + *(void *)(v14 - 24) + 8) & 0xFFFFFFB5 | 8;
  unsigned __int8 *__attribute__((__org_typedef(uuid_t))) v15 = (void *)std::ostream::operator<<(v13, BYTE2(a1));
  uint64_t v16 = sub_1001FD17C(v15, (uint64_t)":", 1LL);
  uint64_t v17 = *v16;
  *(uint64_t *)((char *)v16 + *(void *)(*v16 - 24) + 24) = 2LL;
  *(_DWORD *)((char *)v16 + *(void *)(v17 - 24) + 8) = *(_DWORD *)((_BYTE *)v16 + *(void *)(v17 - 24) + 8) & 0xFFFFFFB5 | 8;
  uint64_t v18 = (void *)std::ostream::operator<<(v16, BYTE1(a1));
  uint64_t v19 = sub_1001FD17C(v18, (uint64_t)":", 1LL);
  uint64_t v20 = *v19;
  *(uint64_t *)((char *)v19 + *(void *)(*v19 - 24) + 24) = 2LL;
  *(_DWORD *)((char *)v19 + *(void *)(v20 - 24) + 8) = *(_DWORD *)((_BYTE *)v19 + *(void *)(v20 - 24) + 8) & 0xFFFFFFB5 | 8;
  std::ostream::operator<<(v19, a1);
  unint64_t v21 = sub_1001FD17C(v25, (uint64_t)"-", 1LL);
  *(_DWORD *)((char *)v21 + *(void *)(*v21 - 24LL) + 8) &= ~0x4000u;
  if ((a1 & 0xFF000000000000LL) != 0) {
    uint64_t v22 = "Random";
  }
  else {
    uint64_t v22 = "Public";
  }
  sub_1001FD17C(v21, (uint64_t)v22, 6LL);
  std::stringbuf::str(a2, (const std::stringbuf *)((char *)v25 + 8));
  if (SHIBYTE(v27) < 0) {
    operator delete(__p[1]);
  }
  std::streambuf::~streambuf((char *)v25 + 8);
  return std::ios::~ios(v29);
}

void sub_1005C0280(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, ...)
{
}

unint64_t sub_1005C02B0(void *a1)
{
  id v1 = a1;
  uint64_t v2 = v1;
  if (v1)
  {
    __p[0] = 0LL;
    __p[1] = 0LL;
    uint64_t v6 = 0LL;
    sub_10002418C(__p, (char *)[v1 UTF8String]);
    unint64_t v3 = sub_1005C033C((char *)__p);
    if (SHIBYTE(v6) < 0) {
      operator delete(__p[0]);
    }
  }

  else
  {
    unint64_t v3 = 0LL;
  }

  return v3;
}

void sub_1005C032C(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

unint64_t sub_1005C033C(char *a1)
{
  id v1 = a1;
  if (a1[23] < 0)
  {
    id v1 = *(const char **)a1;
  }

  else if (a1[23] - 25 < 0xFFFFFFE8)
  {
    return 0LL;
  }

  uint64_t v7 = 0LL;
  __int16 v6 = 0;
  int v5 = 0;
  if (sscanf( v1,  "%hhX:%hhX:%hhX:%hhX:%hhX:%hhX",  &v5,  (char *)&v5 + 1,  (char *)&v5 + 2,  (char *)&v5 + 3,  &v6,  (char *)&v6 + 1) == 6) {
    return ((unint64_t)v5 << 40) | ((unint64_t)BYTE1(v5) << 32) | ((unint64_t)BYTE2(v5) << 24) | ((unint64_t)HIBYTE(v5) << 16) | ((unint64_t)v6 << 8) | HIBYTE(v6);
  }
  if (sscanf( v1,  "%7s %hhX:%hhX:%hhX:%hhX:%hhX:%hhX",  &v7,  &v5,  (char *)&v5 + 1,  (char *)&v5 + 2,  (char *)&v5 + 3,  &v6,  (char *)&v6 + 1) != 7) {
    return 0LL;
  }
  uint64_t v4 = (_DWORD)v7 != 1818391888 || *(_DWORD *)((char *)&v7 + 3) != 6515052;
  return (v4 << 48) | ((unint64_t)v5 << 40) | ((unint64_t)BYTE1(v5) << 32) | ((unint64_t)BYTE2(v5) << 24) | ((unint64_t)HIBYTE(v5) << 16) | ((unint64_t)v6 << 8) | HIBYTE(v6);
}

unint64_t sub_1005C04DC(void *a1)
{
  id v1 = a1;
  uint64_t v2 = v1;
  __int16 v8 = 0;
  int v7 = 0;
  if (!v1)
  {
    if (os_log_type_enabled((os_log_t)qword_1008F75A0, OS_LOG_TYPE_ERROR)) {
      sub_10069A6BC();
    }
    goto LABEL_9;
  }

  if ([v1 length] != (id)6 && objc_msgSend(v2, "length") != (id)7)
  {
    uint64_t v4 = (os_log_s *)qword_1008F75A0;
    if (os_log_type_enabled((os_log_t)qword_1008F75A0, OS_LOG_TYPE_ERROR)) {
      sub_10069A6E8((uint64_t)v2, v4, v5);
    }
LABEL_9:
    unint64_t v3 = 0LL;
    goto LABEL_10;
  }

  objc_msgSend(v2, "getBytes:range:", &v7, (char *)objc_msgSend(v2, "length") - 6, 6);
  unint64_t v3 = ((unint64_t)v7 << 40) | ((unint64_t)BYTE1(v7) << 32) | ((unint64_t)BYTE2(v7) << 24) | ((unint64_t)HIBYTE(v7) << 16) | ((unint64_t)v8 << 8) | HIBYTE(v8) | 0x1000000000000LL;
LABEL_10:

  return v3;
}

void sub_1005C05F4(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

id sub_1005C0604(unint64_t a1)
{
  uint64_t v1 = sub_1001BCDB0(a1);
  int v4 = v1;
  char v6 = BYTE6(v1);
  __int16 v5 = WORD2(v1);
  uint64_t v2 = (void *)objc_claimAutoreleasedReturnValue(+[NSMutableData data](&OBJC_CLASS___NSMutableData, "data"));
  [v2 appendBytes:&v4 length:1];
  [v2 appendBytes:(char *)&v4 + 1 length:6];
  return v2;
}

void sub_1005C0674(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

uint64_t sub_1005C0684(uint64_t a1, uint64_t a2)
{
  int v4 = (const void *)a2;
  id v5 = (id)objc_claimAutoreleasedReturnValue(+[NSString stringWithUTF8String:](&OBJC_CLASS___NSString, "stringWithUTF8String:", v4));
  if ([v5 isEqualToString:@"APPEARANCE_KEYBOARD"])
  {
    __int16 v6 = 961;
  }

  else if ([v5 isEqualToString:@"APPEARANCE_MOUSE"])
  {
    __int16 v6 = 962;
  }

  else if ([v5 isEqualToString:@"APPEARANCE_TOUCHPAD"])
  {
    __int16 v6 = 969;
  }

  else if ([v5 isEqualToString:@"APPEARANCE_JOYSTICK"])
  {
    __int16 v6 = 963;
  }

  else if ([v5 isEqualToString:@"APPEARANCE_GAMEPAD"])
  {
    __int16 v6 = 964;
  }

  else if ([v5 isEqualToString:@"APPEARANCE_GENERIC AUDIO SINK"])
  {
    __int16 v6 = 2112;
  }

  else if ([v5 isEqualToString:@"APPEARANCE_STANDALONE SPEAKER"])
  {
    __int16 v6 = 2113;
  }

  else if ([v5 isEqualToString:@"APPEARANCE_SOUNDBAR"])
  {
    __int16 v6 = 2114;
  }

  else if ([v5 isEqualToString:@"APPEARANCE_BOOKSHELF SPEAKER"])
  {
    __int16 v6 = 2115;
  }

  else if ([v5 isEqualToString:@"APPEARANCE_STANDMOUNTED SPEAKER"])
  {
    __int16 v6 = 2116;
  }

  else if ([v5 isEqualToString:@"APPEARANCE_SPEAKERPHONE"])
  {
    __int16 v6 = 2117;
  }

  else if ([v5 isEqualToString:@"APPEARANCE_EARBUD"])
  {
    __int16 v6 = 2369;
  }

  else if ([v5 isEqualToString:@"APPEARANCE_HEADSET"])
  {
    __int16 v6 = 2370;
  }

  else if ([v5 isEqualToString:@"APPEARANCE_HEADPHONES"])
  {
    __int16 v6 = 2371;
  }

  else
  {
    if (([v5 isEqualToString:@"IsHearingAid"] & 1) == 0)
    {

      goto LABEL_34;
    }

    __int16 v6 = 2625;
  }

  *(_WORD *)(a1 + 392) = v6;
LABEL_34:
  sub_1005C5308((uint64_t **)(a1 + 176), (const void **)a2, a2);
  return v7 & 1;
}

void sub_1005C089C(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

uint64_t sub_1005C08B0(uint64_t a1, std::string *a2, int a3, int a4)
{
  *(_OWORD *)&a2->__r_.__value_.__l.__data_ = v16;
  a2->__r_.__value_.__l.__cap_ = v17;
  int v8 = *(_DWORD *)(a1 + 128);
  if (v8 < a3) {
    goto LABEL_4;
  }
  if (v8 != a3)
  {
    if (!a4) {
      return 0LL;
    }
LABEL_4:
    *(_DWORD *)(a1 + 128) = a3;
    std::string::operator=((std::string *)(a1 + 104), a2);
    return 1LL;
  }

  uint64_t size = a2->__r_.__value_.__s.__size_;
  if ((size & 0x80u) == 0LL) {
    std::string::size_type v11 = a2->__r_.__value_.__s.__size_;
  }
  else {
    std::string::size_type v11 = a2->__r_.__value_.__l.__size_;
  }
  uint64_t v12 = *(unsigned __int8 *)(a1 + 127);
  int v13 = (char)v12;
  if ((v12 & 0x80u) != 0LL) {
    uint64_t v12 = *(void *)(a1 + 112);
  }
  if (v11 != v12) {
    goto LABEL_4;
  }
  uint64_t v14 = v13 >= 0 ? (unsigned __int8 *)(a1 + 104) : *(unsigned __int8 **)(a1 + 104);
  if ((size & 0x80) != 0)
  {
    LOBYTE(size) = memcmp(a2->__r_.__value_.__l.__data_, v14, a2->__r_.__value_.__l.__size_) != 0;
  }

  else if (a2->__r_.__value_.__s.__size_)
  {
    unsigned __int8 *__attribute__((__org_typedef(uuid_t))) v15 = a2;
    while (v15->__r_.__value_.__s.__data_[0] == *v14)
    {
      unsigned __int8 *__attribute__((__org_typedef(uuid_t))) v15 = (std::string *)((char *)v15 + 1);
      ++v14;
      if (!--size) {
        goto LABEL_24;
      }
    }

    goto LABEL_4;
  }

void sub_1005C09D0(void *a1@<X1>, unsigned int a2@<W2>, std::stringbuf::string_type *a3@<X8>)
{
  id v5 = a1;
  uint64_t v19 = 0LL;
  __int128 v17 = 0u;
  memset(v18, 0, sizeof(v18));
  *(_OWORD *)std::stringbuf::string_type __p = 0u;
  __int128 v16 = 0u;
  memset(v14, 0, sizeof(v14));
  sub_10020E564((uint64_t)v14);
  id v6 = v5;
  char v7 = (unsigned __int8 *)[v6 bytes];
  LOWORD(v8) = (unsigned __int16)[v6 length];
  uint64_t v9 = *(void *)&v14[0];
  *(_DWORD *)((char *)v14 + *(void *)(*(void *)&v14[0] - 24LL) + 8) = *(_DWORD *)((_BYTE *)v14
                                                                                    + *(void *)(*(void *)&v14[0]
                                                                                                - 24LL)
                                                                                    + 8) & 0xFFFFFFB5 | 8;
  uint64_t v10 = (const std::ios_base *)((char *)v14 + *(void *)(v9 - 24));
  if (v10[1].__fmtflags_ == -1)
  {
    std::ios_base::getloc(v10);
    std::string::size_type v11 = std::locale::use_facet(&v20, &std::ctype<char>::id);
    ((void (*)(const std::locale::facet *, uint64_t))v11->__vftable[2].~facet_0)(v11, 32LL);
    std::locale::~locale(&v20);
  }

  v10[1].__fmtflags_ = 48;
  else {
    uint64_t v8 = (unsigned __int16)v8;
  }
  if ((_DWORD)v8)
  {
    do
    {
      uint64_t v12 = *(void *)&v14[0];
      *(void *)((char *)&v14[1] + *(void *)(*(void *)&v14[0] - 24LL) + 8) = 2LL;
      *(_DWORD *)((char *)v14 + *(void *)(v12 - 24) + 8) = *(_DWORD *)((_BYTE *)v14 + *(void *)(v12 - 24) + 8) & 0xFFFFFF4F | 0x80;
      unsigned int v13 = *v7++;
      std::ostream::operator<<(v14, v13);
      --v8;
    }

    while (v8);
  }

  std::stringbuf::str(a3, (const std::stringbuf *)((char *)v14 + 8));
  if (SHIBYTE(v16) < 0) {
    operator delete(__p[1]);
  }
  std::streambuf::~streambuf((char *)v14 + 8);
  std::ios::~ios(v18);
}

void sub_1005C0BA0( _Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9)
{
  _Unwind_Resume(a1);
}

_DWORD *sub_1005C0BD8(_DWORD *result, int a2)
{
  result[117] += a2;
  result[118] = a2;
  return result;
}

_DWORD *sub_1005C0BF8(_DWORD *result, int a2)
{
  result[114] += a2;
  result[115] = a2;
  return result;
}

void sub_1005C0C18(uint64_t a1)
{
  int v1 = *(_DWORD *)(a1 + 464);
  if (v1 && *(_DWORD *)(a1 + 468) / v1)
  {
    *(_DWORD *)((char *)__dst + 3) = 0;
    __dst[0] = 0;
    id v3 = *(id *)(a1 + 336);
    int v4 = v3;
    if (v3)
    {
      id v5 = v3;
      memcpy(__dst, [v5 bytes], (size_t)objc_msgSend(v5, "length"));
      int v6 = *(unsigned __int16 *)((char *)__dst + 1);
      unsigned int v7 = *(unsigned __int16 *)((char *)__dst + 3);
    }

    else
    {
      int v6 = 0;
      unsigned int v7 = 0;
    }

    uint64_t v17 = 0LL;
    unint64_t v18 = 0LL;
    int v20 = 0;
    unint64_t v19 = 0LL;
    int v9 = *(_DWORD *)(a1 + 464);
    if (v9) {
      int v10 = *(_DWORD *)(a1 + 468) / v9;
    }
    else {
      int v10 = 0;
    }
    unsigned int v11 = *(_DWORD *)(a1 + 452);
    if (v11) {
      unsigned int v12 = (char)(*(_DWORD *)(a1 + 456) / v11);
    }
    else {
      unsigned int v12 = 0;
    }
    unsigned int v13 = *(_DWORD *)(a1 + 472);
    unsigned int v14 = *(char *)(a1 + 460);
    sub_10040CB94(&v17, 13);
    HIDWORD(v17) = v10;
    unint64_t v18 = __PAIR64__(v13, v12);
    unint64_t v19 = __PAIR64__(v7, v14);
    int v20 = v6;
    unsigned __int8 *__attribute__((__org_typedef(uuid_t))) v15 = (os_log_s *)qword_1008F75A0;
    if (os_log_type_enabled((os_log_t)qword_1008F75A0, OS_LOG_TYPE_DEFAULT))
    {
      *(_DWORD *)int buf = 67110400;
      int v23 = v10;
      __int16 v24 = 1024;
      unsigned int v25 = v12;
      __int16 v26 = 1024;
      unsigned int v27 = v13;
      __int16 v28 = 1024;
      unsigned int v29 = v14;
      __int16 v30 = 1024;
      unsigned int v31 = v7;
      __int16 v32 = 1024;
      int v33 = v6;
      _os_log_impl( (void *)&_mh_execute_header,  v15,  OS_LOG_TYPE_DEFAULT,  "Sending LeConnectionPhyStats AWDMetric: RSSI Average %d, PER Average %d%%, RSSI %d, PER %d%% pid %d Vid %d",  buf,  0x26u);
    }

    if (sub_1002E8D94())
    {
      uint64_t v16 = sub_1002E8D94();
      (*(void (**)(uint64_t, uint64_t *))(*(void *)v16 + 40LL))(v16, &v17);
    }

    *(void *)(a1 + 452) = 0LL;
    *(void *)(a1 + 460) = 0LL;
    *(void *)(a1 + 468) = 0LL;
  }

  else
  {
    uint64_t v8 = (os_log_s *)qword_1008F75A0;
    if (os_log_type_enabled((os_log_t)qword_1008F75A0, OS_LOG_TYPE_DEFAULT))
    {
      *(_WORD *)int buf = 0;
      _os_log_impl( (void *)&_mh_execute_header,  v8,  OS_LOG_TYPE_DEFAULT,  "Not sending LE connection phy stats as average RSSI is 0 dBm",  buf,  2u);
    }
  }

void sub_1005C0E44(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

uint64_t sub_1005C0E60@<X0>(id *a1@<X0>, std::stringbuf::string_type *a2@<X8>)
{
  uint64_t v43 = 0LL;
  memset(v42, 0, sizeof(v42));
  __int128 v40 = 0u;
  __int128 v41 = 0u;
  *(_OWORD *)std::stringbuf::string_type __p = 0u;
  memset(v38, 0, sizeof(v38));
  sub_10020E564((uint64_t)v38);
  sub_1001FD17C(v38, (uint64_t)"DIS:", 4LL);
  std::stringbuf::str(&v37, (const std::stringbuf *)((char *)v38 + 8));
  if ((char)v37.__r_.__value_.__s.__size_ < 0)
  {
    std::string::size_type size = v37.__r_.__value_.__l.__size_;
    operator delete(v37.__r_.__value_.__l.__data_);
  }

  else
  {
    std::string::size_type size = v37.__r_.__value_.__s.__size_;
  }

  if (a1[34])
  {
    id v5 = sub_1001FD17C(v38, (uint64_t)" MFGR:", 6LL);
    int v6 = (const char *)[a1[34] UTF8String];
    size_t v7 = strlen(v6);
    sub_1001FD17C(v5, (uint64_t)v6, v7);
  }

  if (a1[35])
  {
    uint64_t v8 = sub_1001FD17C(v38, (uint64_t)" model:", 7LL);
    int v9 = (const char *)[a1[35] UTF8String];
    size_t v10 = strlen(v9);
    sub_1001FD17C(v8, (uint64_t)v9, v10);
  }

  if (a1[36])
  {
    unsigned int v11 = sub_1001FD17C(v38, (uint64_t)" SN:", 4LL);
    unsigned int v12 = (const char *)[a1[36] UTF8String];
    size_t v13 = strlen(v12);
    sub_1001FD17C(v11, (uint64_t)v12, v13);
  }

  if (a1[37])
  {
    unsigned int v14 = sub_1001FD17C(v38, (uint64_t)" HW:", 4LL);
    unsigned __int8 *__attribute__((__org_typedef(uuid_t))) v15 = (const char *)[a1[37] UTF8String];
    size_t v16 = strlen(v15);
    sub_1001FD17C(v14, (uint64_t)v15, v16);
  }

  if (a1[38])
  {
    uint64_t v17 = sub_1001FD17C(v38, (uint64_t)" FW:", 4LL);
    unint64_t v18 = (const char *)[a1[38] UTF8String];
    size_t v19 = strlen(v18);
    sub_1001FD17C(v17, (uint64_t)v18, v19);
  }

  if (a1[39])
  {
    int v20 = sub_1001FD17C(v38, (uint64_t)" SW:", 4LL);
    unint64_t v21 = (const char *)[a1[39] UTF8String];
    size_t v22 = strlen(v21);
    sub_1001FD17C(v20, (uint64_t)v21, v22);
  }

  if (a1[40])
  {
    int v23 = sub_1001FD17C(v38, (uint64_t)" SYSID:", 7LL);
    sub_1005C09D0(a1[40], 0xAu, &v37);
    __int16 v24 = (v37.__r_.__value_.__s.__size_ & 0x80u) == 0
        ? &v37
        : (std::stringbuf::string_type *)v37.__r_.__value_.__r.__words[0];
    uint64_t v25 = (v37.__r_.__value_.__s.__size_ & 0x80u) == 0 ? v37.__r_.__value_.__s.__size_ : v37.__r_.__value_.__l.__size_;
    sub_1001FD17C(v23, (uint64_t)v24, v25);
  }

  if (a1[42])
  {
    __int16 v26 = sub_1001FD17C(v38, (uint64_t)" PNPID:", 7LL);
    sub_1005C09D0(a1[42], 0xAu, &v37);
    unsigned int v27 = (v37.__r_.__value_.__s.__size_ & 0x80u) == 0
        ? &v37
        : (std::stringbuf::string_type *)v37.__r_.__value_.__r.__words[0];
    uint64_t v28 = (v37.__r_.__value_.__s.__size_ & 0x80u) == 0 ? v37.__r_.__value_.__s.__size_ : v37.__r_.__value_.__l.__size_;
    sub_1001FD17C(v26, (uint64_t)v27, v28);
  }

  if (a1[43])
  {
    unsigned int v29 = sub_1001FD17C(v38, (uint64_t)" UDI:", 5LL);
    sub_1005C09D0(a1[43], 0xAu, &v37);
    __int16 v30 = (v37.__r_.__value_.__s.__size_ & 0x80u) == 0
        ? &v37
        : (std::stringbuf::string_type *)v37.__r_.__value_.__r.__words[0];
    uint64_t v31 = (v37.__r_.__value_.__s.__size_ & 0x80u) == 0 ? v37.__r_.__value_.__s.__size_ : v37.__r_.__value_.__l.__size_;
    sub_1001FD17C(v29, (uint64_t)v30, v31);
  }

  if (a1[41])
  {
    __int16 v32 = sub_1001FD17C(v38, (uint64_t)" Regulatory:", 12LL);
    sub_1005C09D0(a1[41], 0xAu, &v37);
    int v33 = (v37.__r_.__value_.__s.__size_ & 0x80u) == 0
        ? &v37
        : (std::stringbuf::string_type *)v37.__r_.__value_.__r.__words[0];
    uint64_t v34 = (v37.__r_.__value_.__s.__size_ & 0x80u) == 0 ? v37.__r_.__value_.__s.__size_ : v37.__r_.__value_.__l.__size_;
    sub_1001FD17C(v32, (uint64_t)v33, v34);
  }

  std::stringbuf::str(&v37, (const std::stringbuf *)((char *)v38 + 8));
  if ((char)v37.__r_.__value_.__s.__size_ < 0)
  {
    std::string::size_type v35 = v37.__r_.__value_.__l.__size_;
    operator delete(v37.__r_.__value_.__l.__data_);
    if (v35 != size) {
      goto LABEL_57;
    }
    goto LABEL_56;
  }

  if (size == v37.__r_.__value_.__s.__size_) {
LABEL_56:
  }
    sub_1001FD17C(v38, (uint64_t)"Unavailable", 11LL);
LABEL_57:
  std::stringbuf::str(a2, (const std::stringbuf *)((char *)v38 + 8));
  if (SHIBYTE(v40) < 0) {
    operator delete(__p[1]);
  }
  std::streambuf::~streambuf((char *)v38 + 8);
  return std::ios::~ios(v42);
}

void sub_1005C12D8( _Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void *__p, uint64_t a11, int a12, __int16 a13, char a14, char a15, char a16)
{
  if (a15 < 0) {
    operator delete(__p);
  }
  sub_10020E784((uint64_t)&a16);
  _Unwind_Resume(a1);
}

uint64_t sub_1005C132C(uint64_t a1, void *a2, void *a3)
{
  id v5 = a2;
  id v6 = a3;
  size_t v7 = (void *)objc_claimAutoreleasedReturnValue([*(id *)(a1 + 64) beaconIdentifier]);

  if (v7)
  {
    uint64_t v8 = (void *)objc_claimAutoreleasedReturnValue([*(id *)(a1 + 64) allowedSessions]);

    if (v8)
    {
      __int128 v20 = 0u;
      __int128 v21 = 0u;
      __int128 v18 = 0u;
      __int128 v19 = 0u;
      int v9 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(*(id *)(a1 + 64), "allowedSessions", 0));
      id v10 = [v9 countByEnumeratingWithState:&v18 objects:v22 count:16];
      if (v10)
      {
        uint64_t v11 = *(void *)v19;
        do
        {
          for (uint64_t i = 0LL; i != v10; uint64_t i = (char *)i + 1)
          {
            if (*(void *)v19 != v11) {
              objc_enumerationMutation(v9);
            }
            size_t v13 = *(void **)(*((void *)&v18 + 1) + 8LL * (void)i);
            unsigned int v14 = (void *)objc_claimAutoreleasedReturnValue([v13 bundleId]);
            if ([v5 isEqual:v14])
            {
              unsigned __int8 *__attribute__((__org_typedef(uuid_t))) v15 = (void *)objc_claimAutoreleasedReturnValue([v13 userIdentifier]);
              unsigned __int8 v16 = [v6 isEqual:v15];

              if ((v16 & 1) != 0) {
                goto LABEL_14;
              }
            }

            else
            {
            }
          }

          id v10 = [v9 countByEnumeratingWithState:&v18 objects:v22 count:16];
        }

        while (v10);
      }

void sub_1005C14CC(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

uint64_t sub_1005C1518(uint64_t a1, void *a2)
{
  id v4 = a2;
  id v5 = v4;
  if (v4)
  {
    id v6 = (void *)objc_claimAutoreleasedReturnValue([v4 beaconIdentifier]);

    if (v6)
    {
      size_t v7 = (void *)objc_claimAutoreleasedReturnValue([v5 allowedSessions]);
      if (v7
        && (uint64_t v8 = (void *)objc_claimAutoreleasedReturnValue([v5 allowedSessions]),
            id v9 = [v8 count],
            v8,
            v7,
            v9))
      {
        id v10 = (void *)objc_claimAutoreleasedReturnValue([v5 longTermKeyMap]);
        if (v10
          && (uint64_t v11 = (void *)objc_claimAutoreleasedReturnValue([v5 longTermKeyMap]),
              id v12 = [v11 count],
              v11,
              v10,
              v12))
        {
          size_t v13 = (void *)objc_claimAutoreleasedReturnValue([v5 serialNumber]);
          if (v13)
          {
            unsigned int v14 = (void *)objc_claimAutoreleasedReturnValue([v5 serialNumber]);
            id v15 = [v14 length];

            if (v15)
            {
              __int128 v53 = 0u;
              __int128 v54 = 0u;
              __int128 v51 = 0u;
              __int128 v52 = 0u;
              id obj = (id)objc_claimAutoreleasedReturnValue([v5 longTermKeyMap]);
              id v16 = [obj countByEnumeratingWithState:&v51 objects:v67 count:16];
              if (v16)
              {
                uint64_t v17 = *(void *)v52;
                while (2)
                {
                  __int128 v18 = 0LL;
                  do
                  {
                    if (*(void *)v52 != v17) {
                      objc_enumerationMutation(obj);
                    }
                    uint64_t v19 = *(void *)(*((void *)&v51 + 1) + 8LL * (void)v18);
                    if (!v19 || [*(id *)(*((void *)&v51 + 1) + 8 * (void)v18) length] != (id)7)
                    {
                      if (os_log_type_enabled((os_log_t)qword_1008F75A0, OS_LOG_TYPE_ERROR))
                      {
                        BOOL v44 = (void *)objc_claimAutoreleasedReturnValue([v5 beaconIdentifier]);
                        sub_10069A838(v19, v44, (uint64_t)buf);
                      }

                      uint64_t v37 = 8LL;
LABEL_44:

                      goto LABEL_40;
                    }

                    __int128 v20 = (void *)objc_claimAutoreleasedReturnValue([v5 longTermKeyMap]);
                    __int128 v21 = (void *)objc_claimAutoreleasedReturnValue([v20 objectForKeyedSubscript:v19]);

                    __int128 v49 = 0u;
                    __int128 v50 = 0u;
                    __int128 v47 = 0u;
                    __int128 v48 = 0u;
                    id v22 = v21;
                    id v23 = [v22 countByEnumeratingWithState:&v47 objects:v66 count:16];
                    if (v23)
                    {
                      uint64_t v24 = *(void *)v48;
                      id v45 = v16;
                      while (2)
                      {
                        uint64_t v25 = v17;
                        __int16 v26 = 0LL;
                        do
                        {
                          if (*(void *)v48 != v24) {
                            objc_enumerationMutation(v22);
                          }
                          uint64_t v27 = *(void *)(*((void *)&v47 + 1) + 8LL * (void)v26);
                          if (!v27
                            || (unint64_t)[*(id *)(*((void *)&v47 + 1) + 8 * (void)v26) length] <= 0xF)
                          {
                            if (os_log_type_enabled((os_log_t)qword_1008F75A0, OS_LOG_TYPE_ERROR))
                            {
                              uint64_t v43 = (void *)objc_claimAutoreleasedReturnValue([v5 beaconIdentifier]);
                              sub_10069A880(v27, v43, (uint64_t)buf);
                            }

                            uint64_t v37 = 149LL;
                            goto LABEL_44;
                          }

                          __int16 v26 = (char *)v26 + 1;
                        }

                        while (v23 != v26);
                        id v23 = [v22 countByEnumeratingWithState:&v47 objects:v66 count:16];
                        uint64_t v17 = v25;
                        id v16 = v45;
                        if (v23) {
                          continue;
                        }
                        break;
                      }
                    }

                    __int128 v18 = (char *)v18 + 1;
                  }

                  while (v18 != v16);
                  id v16 = [obj countByEnumeratingWithState:&v51 objects:v67 count:16];
                  if (v16) {
                    continue;
                  }
                  break;
                }
              }

              uint64_t v28 = (os_log_s *)qword_1008F75A0;
              if (os_log_type_enabled((os_log_t)qword_1008F75A0, OS_LOG_TYPE_DEFAULT))
              {
                uint64_t v29 = *(void *)a1;
                __int16 v30 = (void *)objc_claimAutoreleasedReturnValue([v5 beaconIdentifier]);
                uint64_t v31 = (void *)objc_claimAutoreleasedReturnValue([v5 groupIdentifier]);
                __int16 v32 = (void *)objc_claimAutoreleasedReturnValue([v5 serialNumber]);
                unsigned int v33 = [v5 partIdentifier];
                unsigned int v34 = [v5 managedByFindMy];
                *(_DWORD *)int buf = 138413570;
                *(void *)&uint8_t buf[4] = v29;
                __int16 v56 = 2112;
                uint64_t v57 = v30;
                __int16 v58 = 2112;
                __int128 v59 = v31;
                __int16 v60 = 2112;
                __int128 v61 = v32;
                __int16 v62 = 1024;
                unsigned int v63 = v33;
                __int16 v64 = 1024;
                unsigned int v65 = v34;
                _os_log_impl( (void *)&_mh_execute_header,  v28,  OS_LOG_TYPE_DEFAULT,  "fIdentifier:%@ fFindMyID:%@ fFindMyGroupID:%@ fFindMySerialNumber:%@ fFindMyPartID:%d fManagedByFindMy:%d",  buf,  0x36u);
              }

              std::string::size_type v35 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(v5, "longTermKeyMap", v45));
              [v35 count];
              *(void *)int buf = 0LL;
              sub_1000B0400((uint64_t)buf);
              uint64_t v36 = *(__int16 *)&buf[4];
              *(void *)(a1 + 40) = *(int *)buf;
              *(void *)(a1 + 48) = v36;

              goto LABEL_30;
            }
          }

          if (os_log_type_enabled((os_log_t)qword_1008F75A0, OS_LOG_TYPE_ERROR)) {
            sub_10069A80C();
          }
        }

        else
        {
          __int128 v40 = (os_log_s *)qword_1008F75A0;
          if (os_log_type_enabled((os_log_t)qword_1008F75A0, OS_LOG_TYPE_ERROR))
          {
            __int128 v41 = (void *)objc_claimAutoreleasedReturnValue([v5 beaconIdentifier]);
            sub_10069A7C4(v41, (uint64_t)buf, v40);
          }
        }
      }

      else
      {
        int64_t v38 = (os_log_s *)qword_1008F75A0;
        if (os_log_type_enabled((os_log_t)qword_1008F75A0, OS_LOG_TYPE_ERROR))
        {
          int v39 = (void *)objc_claimAutoreleasedReturnValue([v5 beaconIdentifier]);
          sub_10069A77C(v39, (uint64_t)buf, v38);
        }
      }
    }

    else if (os_log_type_enabled((os_log_t)qword_1008F75A0, OS_LOG_TYPE_ERROR))
    {
      sub_10069A750();
    }

    uint64_t v37 = 3LL;
    goto LABEL_40;
  }

void sub_1005C1A58( _Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, void *a10)
{
  _Unwind_Resume(a1);
}

void sub_1005C1B24(uint64_t a1)
{
  uint64_t v2 = (void *)objc_claimAutoreleasedReturnValue([*(id *)(a1 + 64) longTermKeyMap]);
  id v3 = [v2 mutableCopy];
  id v4 = *(void **)(a1 + 72);
  *(void *)(a1 + 72) = v3;

  id v5 = *(void **)(a1 + 88);
  *(void *)(a1 + 88) = 0LL;

  id v6 = *(void **)(a1 + 80);
  *(void *)(a1 + 80) = 0LL;
}

void sub_1005C1B78(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_1005C1B88(void *a1)
{
  id v2 = sub_1002E9298();
  id v3 = (void *)objc_claimAutoreleasedReturnValue(v2);
  id v4 = v3;
  if (v3 && a1[10] && a1[11] && a1[8]) {
    objc_msgSend(v3, "successfulConnectionForPeripheral:leMAC:ltk:completion:");
  }
}

void sub_1005C1C14(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_1005C1C24(uint64_t a1, void *a2)
{
  id v3 = a2;
  uint64_t v4 = *(void *)(a1 + 32);
  id v5 = (os_log_s *)qword_1008F75A0;
  if (os_log_type_enabled((os_log_t)qword_1008F75A0, OS_LOG_TYPE_DEFAULT))
  {
    int v6 = 138412290;
    id v7 = v3;
    _os_log_impl( (void *)&_mh_execute_header,  v5,  OS_LOG_TYPE_DEFAULT,  "successfulConnectionForPeripheral returned %@",  (uint8_t *)&v6,  0xCu);
  }

  sub_1005C1B24(v4);
}

void sub_1005C1CE4(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_1005C1CFC(uint64_t a1, int a2)
{
  id v2 = (uint64_t **)(a1 + 176);
  if (a2)
  {
    sub_10002418C(__p, "_HID_DEVICE_");
    sub_1004F5958(v2, (const void **)__p, (uint64_t)__p);
  }

  else
  {
    sub_10002418C(__p, "_HID_DEVICE_");
    sub_1002EE40C(v2, (const void **)__p);
  }

  if (v4 < 0) {
    operator delete(__p[0]);
  }
}

void sub_1005C1D74( _Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void *__p, uint64_t a11, int a12, __int16 a13, char a14, char a15)
{
  if (a15 < 0) {
    operator delete(__p);
  }
  _Unwind_Resume(exception_object);
}

void sub_1005C1D94(uint64_t a1, void *a2, void *a3)
{
  id v9 = a2;
  id v5 = a3;
  if (*(void *)(a1 + 496))
  {
    if (!v9) {
      goto LABEL_9;
    }
  }

  else
  {
    uint64_t v6 = objc_claimAutoreleasedReturnValue(+[NSMutableDictionary dictionary](&OBJC_CLASS___NSMutableDictionary, "dictionary"));
    id v7 = *(void **)(a1 + 496);
    *(void *)(a1 + 496) = v6;

    if (!v9) {
      goto LABEL_9;
    }
  }

  id v8 = [v9 length];
  if (v5 && v8 && [v5 length]) {
    [*(id *)(a1 + 496) setObject:v5 forKeyedSubscript:v9];
  }
LABEL_9:
}

void sub_1005C1E38( _Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, id a10)
{
  _Unwind_Resume(a1);
}

void sub_1005C1E50(uint64_t a1, void *a2)
{
  id v5 = a2;
  if (v5)
  {
    if ([v5 length])
    {
      id v3 = *(void **)(a1 + 496);
      if (v3)
      {
        char v4 = (void *)objc_claimAutoreleasedReturnValue([v3 objectForKeyedSubscript:v5]);

        if (v4) {
          [*(id *)(a1 + 496) removeObjectForKey:v5];
        }
      }
    }
  }
}

void sub_1005C1EBC( _Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, id a10)
{
}

id sub_1005C1ED0(uint64_t a1)
{
  id v2 = *(void **)(a1 + 496);
  if (!v2 || ![v2 count]) {
    return 0LL;
  }
  id v3 = (void *)objc_claimAutoreleasedReturnValue(+[NSMutableSet set](&OBJC_CLASS___NSMutableSet, "set"));
  __int128 v14 = 0u;
  __int128 v15 = 0u;
  __int128 v12 = 0u;
  __int128 v13 = 0u;
  id v4 = *(id *)(a1 + 496);
  id v5 = [v4 countByEnumeratingWithState:&v12 objects:v16 count:16];
  if (v5)
  {
    uint64_t v6 = *(void *)v13;
    do
    {
      id v7 = 0LL;
      do
      {
        if (*(void *)v13 != v6) {
          objc_enumerationMutation(v4);
        }
        id v8 = (void *)objc_claimAutoreleasedReturnValue( objc_msgSend( *(id *)(a1 + 496),  "objectForKeyedSubscript:",  *(void *)(*((void *)&v12 + 1) + 8 * (void)v7),  (void)v12));
        id v9 = v8;
        if (v8 && [v8 length]) {
          [v3 addObject:v9];
        }

        id v7 = (char *)v7 + 1;
      }

      while (v5 != v7);
      id v5 = [v4 countByEnumeratingWithState:&v12 objects:v16 count:16];
    }

    while (v5);
  }

  if ([v3 count]) {
    id v10 = (void *)objc_claimAutoreleasedReturnValue([v3 allObjects]);
  }
  else {
    id v10 = 0LL;
  }

  return v10;
}

void sub_1005C2048(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

id sub_1005C2084(uint64_t a1, void *a2)
{
  id v3 = a2;
  id v4 = v3;
  if (v3 && [v3 length])
  {
    id v5 = sub_1005C1ED0(a1);
    uint64_t v6 = (void *)objc_claimAutoreleasedReturnValue(v5);
    id v7 = v6;
    if (v6 && [v6 count]) {
      id v8 = [v7 containsObject:v4];
    }
    else {
      id v8 = 0LL;
    }
  }

  else
  {
    id v8 = 0LL;
  }

  return v8;
}

void sub_1005C210C(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_1005C212C(uint64_t a1, void *a2, void *a3)
{
  id v9 = a2;
  id v5 = a3;
  if (*(void *)(a1 + 504))
  {
    if (!v9) {
      goto LABEL_9;
    }
  }

  else
  {
    uint64_t v6 = objc_claimAutoreleasedReturnValue(+[NSMutableDictionary dictionary](&OBJC_CLASS___NSMutableDictionary, "dictionary"));
    id v7 = *(void **)(a1 + 504);
    *(void *)(a1 + 504) = v6;

    if (!v9) {
      goto LABEL_9;
    }
  }

  id v8 = [v9 length];
  if (v5 && v8 && [v5 count]) {
    [*(id *)(a1 + 504) setObject:v5 forKeyedSubscript:v9];
  }
LABEL_9:
}

void sub_1005C21D0( _Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, id a10)
{
  _Unwind_Resume(a1);
}

void sub_1005C21E8(uint64_t a1, void *a2)
{
  id v5 = a2;
  if (v5)
  {
    if ([v5 length])
    {
      id v3 = *(void **)(a1 + 504);
      if (v3)
      {
        id v4 = (void *)objc_claimAutoreleasedReturnValue([v3 objectForKeyedSubscript:v5]);

        if (v4) {
          [*(id *)(a1 + 504) removeObjectForKey:v5];
        }
      }
    }
  }
}

void sub_1005C2254( _Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, id a10)
{
}

id sub_1005C2268(uint64_t a1)
{
  id v2 = *(void **)(a1 + 504);
  if (!v2 || ![v2 count]) {
    return 0LL;
  }
  id v3 = (void *)objc_claimAutoreleasedReturnValue(+[NSMutableSet set](&OBJC_CLASS___NSMutableSet, "set"));
  __int128 v22 = 0u;
  __int128 v23 = 0u;
  __int128 v20 = 0u;
  __int128 v21 = 0u;
  id obj = *(id *)(a1 + 504);
  id v4 = [obj countByEnumeratingWithState:&v20 objects:v25 count:16];
  if (v4)
  {
    uint64_t v5 = *(void *)v21;
    do
    {
      uint64_t v6 = 0LL;
      do
      {
        if (*(void *)v21 != v5) {
          objc_enumerationMutation(obj);
        }
        id v7 = (void *)objc_claimAutoreleasedReturnValue( [*(id *)(a1 + 504) objectForKeyedSubscript:*(void *)(*((void *)&v20 + 1) + 8 * (void)v6)]);
        id v8 = v7;
        if (v7 && [v7 count])
        {
          __int128 v18 = 0u;
          __int128 v19 = 0u;
          __int128 v16 = 0u;
          __int128 v17 = 0u;
          id v9 = v8;
          id v10 = [v9 countByEnumeratingWithState:&v16 objects:v24 count:16];
          if (v10)
          {
            uint64_t v11 = *(void *)v17;
            do
            {
              __int128 v12 = 0LL;
              do
              {
                if (*(void *)v17 != v11) {
                  objc_enumerationMutation(v9);
                }
                [v3 addObject:*(void *)(*((void *)&v16 + 1) + 8 * (void)v12)];
                __int128 v12 = (char *)v12 + 1;
              }

              while (v10 != v12);
              id v10 = [v9 countByEnumeratingWithState:&v16 objects:v24 count:16];
            }

            while (v10);
          }
        }

        uint64_t v6 = (char *)v6 + 1;
      }

      while (v6 != v4);
      id v4 = [obj countByEnumeratingWithState:&v20 objects:v25 count:16];
    }

    while (v4);
  }

  if ([v3 count]) {
    __int128 v13 = (void *)objc_claimAutoreleasedReturnValue([v3 allObjects]);
  }
  else {
    __int128 v13 = 0LL;
  }

  return v13;
}

void sub_1005C246C( _Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, void *a10)
{
  _Unwind_Resume(a1);
}

id sub_1005C24C0(uint64_t a1, uint64_t a2)
{
  id v3 = sub_1005C2268(a1);
  id v4 = (void *)objc_claimAutoreleasedReturnValue(v3);
  uint64_t v5 = v4;
  if (v4 && [v4 count])
  {
    uint64_t v6 = (void *)objc_claimAutoreleasedReturnValue(+[NSNumber numberWithUnsignedInt:](&OBJC_CLASS___NSNumber, "numberWithUnsignedInt:", a2));
    id v7 = [v5 containsObject:v6];
  }

  else
  {
    id v7 = 0LL;
  }

  return v7;
}

void sub_1005C253C(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

uint64_t sub_1005C2558(uint64_t a1, int a2, void *a3, int a4)
{
  id v8 = a3;
  uint64_t v9 = sub_1002E6E9C();
  if (((*(uint64_t (**)(uint64_t))(*(void *)v9 + 2728LL))(v9) & 1) == 0)
  {
    uint64_t v11 = 0LL;
    goto LABEL_27;
  }

  BOOL v10 = *(unsigned __int8 *)(a1 + 528) != a2 || *(_DWORD *)(a1 + 532) != a4;
  __int128 v12 = *(void **)(a1 + 520);
  if ((v8 || !v12) && (!v8 || v12))
  {
    unsigned int v13 = 0;
    if (v8 && v12) {
      unsigned int v13 = [v12 isEqualToData:v8] ^ 1;
    }
  }

  else
  {
    unsigned int v13 = 1;
  }

  *(_BYTE *)(a1 + 528) = a2;
  objc_storeStrong((id *)(a1 + 520), a3);
  int v14 = v13 | v10;
  *(_DWORD *)(a1 + 532) = a4;
  if (a4 != 2) {
    *(_BYTE *)(a1 + 544) = 1;
  }
  if (v14 || !*(_BYTE *)(a1 + 544))
  {
    sub_1005C284C(a1, 0);
    sub_1005C2FF4((uint64_t *)a1, 0);
  }

  if (!a2 || ![v8 length] || *(_BYTE *)(a1 + 529))
  {
    if (v14)
    {
      if (qword_1008D67C8 != -1) {
        dispatch_once(&qword_1008D67C8, &stru_1008A2E60);
      }
      sub_10028F584((uint64_t)off_1008D67C0, *(void **)a1);
    }

    int v15 = 0;
    goto LABEL_24;
  }

  if (*(_BYTE *)(a1 + 544))
  {
    uint64_t v11 = sub_1005C284C(a1, 1);
    if (!(_DWORD)v11)
    {
      int v15 = 1;
      sub_1005C2FF4((uint64_t *)a1, 1);
LABEL_24:
      uint64_t v11 = 0LL;
      goto LABEL_25;
    }
  }

  else
  {
    uint64_t v25 = (os_log_s *)qword_1008F75A0;
    if (os_log_type_enabled((os_log_t)qword_1008F75A0, OS_LOG_TYPE_ERROR)) {
      sub_10069A8C8((uint64_t *)a1, v25);
    }
    uint64_t v11 = 0LL;
  }

  int v15 = 1;
LABEL_25:
  __int128 v16 = (os_log_s *)qword_1008F75A0;
  if (os_log_type_enabled((os_log_t)qword_1008F75A0, OS_LOG_TYPE_INFO))
  {
    uint64_t v17 = *(void *)a1;
    int v18 = *(unsigned __int8 *)(a1 + 530);
    int v19 = *(unsigned __int8 *)(a1 + 529);
    int v20 = *(unsigned __int8 *)(a1 + 544);
    int v21 = *(_DWORD *)(a1 + 532);
    uint64_t v22 = *(void *)(a1 + 520);
    int v23 = *(unsigned __int8 *)(a1 + 528);
    int v26 = 138415362;
    uint64_t v27 = v17;
    __int16 v28 = 1024;
    int v29 = a2;
    __int16 v30 = 2112;
    id v31 = v8;
    __int16 v32 = 1024;
    int v33 = v14;
    __int16 v34 = 1024;
    int v35 = v15;
    __int16 v36 = 1024;
    int v37 = v11;
    __int16 v38 = 1024;
    int v39 = v18;
    __int16 v40 = 1024;
    int v41 = v19;
    __int16 v42 = 1024;
    int v43 = v20;
    __int16 v44 = 1024;
    int v45 = v21;
    __int16 v46 = 2112;
    uint64_t v47 = v22;
    __int16 v48 = 1024;
    int v49 = v23;
    __int16 v50 = 1024;
    int v51 = a4;
    _os_log_impl( (void *)&_mh_execute_header,  v16,  OS_LOG_TYPE_INFO,  "FastLeConnection:setControllerInfo fIdentifier:%@ version:%d info:%@ dataChanged:%d enable:%d result:%d fControlle rLTKStored:%d fControllerInfoConfigured:%d fFastLeConnectionAllowed:%d fControllerInfoOrigin:%d fControllerInfo:%@ fControllerInfoVersion:%d newOrigin:%d",  (uint8_t *)&v26,  0x5Cu);
  }

void sub_1005C2828(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

uint64_t sub_1005C284C(uint64_t a1, int a2)
{
  if (qword_1008D60B0 != -1) {
    dispatch_once(&qword_1008D60B0, &stru_1008A2E80);
  }
  if (!*((_BYTE *)off_1008D60A8 + 76)) {
    return 12LL;
  }
  uint64_t v4 = sub_1002E6E9C();
  unint64_t v5 = *(void *)(a1 + 24);
  if (v5 || (unint64_t v5 = *(void *)(a1 + 16)) != 0)
  {
    if (a2 && *(_BYTE *)(a1 + 528))
    {
      if (!*(_BYTE *)(a1 + 544))
      {
        int v18 = (os_log_s *)qword_1008F75A0;
        if (os_log_type_enabled((os_log_t)qword_1008F75A0, OS_LOG_TYPE_ERROR)) {
          sub_10069A9B4((uint64_t *)a1, v18, v19);
        }
        int v15 = 0;
        int v14 = 0;
        LODWORD(v6) = 12;
        goto LABEL_48;
      }

      if (!*(_BYTE *)(a1 + 530))
      {
        int v20 = *(void **)(a1 + 552);
        if (v20 && [v20 length])
        {
          uint64_t v21 = sub_1002E6E9C();
          int v22 = (*(uint64_t (**)(uint64_t, unint64_t, BOOL, void, id))(*(void *)v21 + 1832))( v21,  v5,  *(void *)(a1 + 24) != 0,  [*(id *)(a1 + 552) length],  objc_msgSend(*(id *)(a1 + 552), "bytes"));
          if (v22)
          {
            LODWORD(v6) = v22;
            int v23 = (os_log_s *)qword_1008F75A0;
            if (os_log_type_enabled((os_log_t)qword_1008F75A0, OS_LOG_TYPE_ERROR))
            {
              std::string::size_type v24 = *(void *)a1;
              sub_1005BFC20(v5, &__p);
              uint64_t v25 = (__p.__r_.__value_.__s.__size_ & 0x80u) == 0
                  ? &__p
                  : (std::stringbuf::string_type *)__p.__r_.__value_.__r.__words[0];
              uint64_t v26 = *(void *)(a1 + 520);
              int v27 = *(unsigned __int8 *)(a1 + 528);
              LODWORD(buf.__r_.__value_.__l.__data_) = 138413314;
              *(std::string::size_type *)((char *)buf.__r_.__value_.__r.__words + 4) = v24;
              WORD2(buf.__r_.__value_.__r.__words[1]) = 2080;
              *(std::string::size_type *)((char *)&buf.__r_.__value_.__r.__words[1] + 6) = (std::string::size_type)v25;
              HIWORD(buf.__r_.__value_.__r.__words[2]) = 2112;
              *(void *)int v55 = v26;
              *(_WORD *)&v55[8] = 1024;
              *(_DWORD *)__int16 v56 = v27;
              *(_WORD *)&v56[4] = 1024;
              *(_DWORD *)uint64_t v57 = v6;
              _os_log_error_impl( (void *)&_mh_execute_header,  v23,  OS_LOG_TYPE_ERROR,  "FastLEConnection:Failed writeStoredLTKForDevice for device %@ (%s) cached data:%@ version:%d returned %d aborting",  (uint8_t *)&buf,  0x2Cu);
            }

void sub_1005C2FD4( _Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, int a10, __int16 a11, char a12, char a13)
{
}

void sub_1005C2FF4(uint64_t *a1, int a2)
{
  block[0] = _NSConcreteStackBlock;
  block[1] = 3221225472LL;
  block[2] = sub_1005C3220;
  block[3] = &unk_10087EB20;
  block[4] = a1;
  if (qword_1008F1D30 != -1) {
    dispatch_once(&qword_1008F1D30, block);
  }
  uint64_t v4 = (dispatch_source_s *)a1[67];
  if (a2)
  {
    if (!v4 && *((_DWORD *)a1 + 133) == 3)
    {
      unint64_t v5 = (os_log_s *)qword_1008F75A0;
      if (os_log_type_enabled((os_log_t)qword_1008F75A0, OS_LOG_TYPE_DEFAULT))
      {
        uint64_t v6 = *a1;
        *(_DWORD *)std::stringbuf::string_type buf = 138412546;
        uint64_t v16 = v6;
        __int16 v17 = 2048;
        uint64_t v18 = qword_1008D9C38;
        _os_log_impl( (void *)&_mh_execute_header,  v5,  OS_LOG_TYPE_DEFAULT,  "FastLeConnection:enableClientControllerInfoTimer %@ timer duration %llums armed!",  buf,  0x16u);
      }

      uint64_t v7 = sub_100404FE8();
      int v8 = dispatch_source_create( (dispatch_source_type_t)&_dispatch_source_type_timer,  0LL,  0LL,  *(dispatch_queue_t *)(v7 + 8));
      a1[67] = (uint64_t)v8;
      v13[0] = _NSConcreteStackBlock;
      v13[1] = 3221225472LL;
      _DWORD v13[2] = sub_1005C33A8;
      v13[3] = &unk_10087EB20;
      v13[4] = a1;
      dispatch_source_set_event_handler(v8, v13);
      int v9 = (dispatch_source_s *)a1[67];
      dispatch_time_t v10 = dispatch_time(0x8000000000000000LL, 1000000 * qword_1008D9C38);
      dispatch_source_set_timer(v9, v10, 0xFFFFFFFFFFFFFFFFLL, 0LL);
      dispatch_activate((dispatch_object_t)a1[67]);
    }
  }

  else if (v4)
  {
    uint64_t v11 = (os_log_s *)qword_1008F75A0;
    if (os_log_type_enabled((os_log_t)qword_1008F75A0, OS_LOG_TYPE_DEFAULT))
    {
      uint64_t v12 = *a1;
      *(_DWORD *)std::stringbuf::string_type buf = 138412290;
      uint64_t v16 = v12;
      _os_log_impl( (void *)&_mh_execute_header,  v11,  OS_LOG_TYPE_DEFAULT,  "FastLeConnection:enableClientControllerInfoTimer %@ timer destroyed!",  buf,  0xCu);
      uint64_t v4 = (dispatch_source_s *)a1[67];
    }

    dispatch_source_cancel(v4);
    dispatch_release((dispatch_object_t)a1[67]);
    a1[67] = 0LL;
  }

void sub_1005C3220(uint64_t a1)
{
  int v1 = *(uint64_t **)(a1 + 32);
  int v10 = 0;
  uint64_t v2 = sub_1002E6E00();
  sub_10002418C(buf, "LE");
  sub_10002418C(__p, "DeviceFastLeConnectionClientTimeoutSeconds");
  int v3 = (*(uint64_t (**)(uint64_t, _BYTE *, void **, int *))(*(void *)v2 + 88LL))(v2, buf, __p, &v10);
  if (v10) {
    int v4 = v3;
  }
  else {
    int v4 = 0;
  }
  if (v9 < 0) {
    operator delete(__p[0]);
  }
  if (v14 < 0)
  {
    operator delete(*(void **)buf);
    if (!v4) {
      return;
    }
  }

  else if (!v4)
  {
    return;
  }

  uint64_t v5 = 1000LL * v10;
  qword_1008D9C38 = v5;
  uint64_t v6 = (os_log_s *)qword_1008F75A0;
  if (os_log_type_enabled((os_log_t)qword_1008F75A0, OS_LOG_TYPE_DEFAULT))
  {
    uint64_t v7 = *v1;
    *(_DWORD *)std::stringbuf::string_type buf = 138412546;
    *(void *)&uint8_t buf[4] = v7;
    __int16 v12 = 2048;
    uint64_t v13 = v5;
    _os_log_impl( (void *)&_mh_execute_header,  v6,  OS_LOG_TYPE_DEFAULT,  "FastLeConnection:enableClientControllerInfoTimer %@ Overriding timer duration to %llums",  buf,  0x16u);
  }

void sub_1005C336C( _Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, void *__p, uint64_t a10, int a11, __int16 a12, char a13, char a14, uint64_t a15, void *a16, uint64_t a17, int a18, __int16 a19, char a20, char a21)
{
  if (a14 < 0) {
    operator delete(__p);
  }
  if (a21 < 0) {
    operator delete(a16);
  }
  _Unwind_Resume(exception_object);
}

uint64_t sub_1005C33A8(uint64_t a1)
{
  int v1 = *(uint64_t **)(a1 + 32);
  uint64_t v2 = (os_log_s *)qword_1008F75A0;
  if (os_log_type_enabled((os_log_t)qword_1008F75A0, OS_LOG_TYPE_DEFAULT))
  {
    uint64_t v3 = *v1;
    int v5 = 138412290;
    uint64_t v6 = v3;
    _os_log_impl( (void *)&_mh_execute_header,  v2,  OS_LOG_TYPE_DEFAULT,  "FastLeConnection:enableClientControllerInfoTimer %@ timer expired!",  (uint8_t *)&v5,  0xCu);
  }

  dispatch_source_cancel((dispatch_source_t)v1[67]);
  dispatch_release((dispatch_object_t)v1[67]);
  v1[67] = 0LL;
  return sub_1005C2558(v1, 0LL, 0LL, 0LL);
}

uint64_t sub_1005C3474(uint64_t a1, int a2)
{
  if (qword_1008F1D40 != -1) {
    dispatch_once(&qword_1008F1D40, &stru_1008A2E40);
  }
  uint64_t v4 = sub_1002E6E9C();
  uint64_t result = (*(uint64_t (**)(uint64_t))(*(void *)v4 + 2728LL))(v4);
  if ((_DWORD)result)
  {
    if (*(_BYTE *)(a1 + 528)
      && (uint64_t v6 = *(void **)(a1 + 520)) != 0LL
      && [v6 length]
      && (int v7 = *(_DWORD *)(a1 + 532)) != 0)
    {
      if (v7 == 2) {
        int v8 = a2;
      }
      else {
        int v8 = 1;
      }
      *(_BYTE *)(a1 + 544) = v8;
      char v9 = (os_log_s *)qword_1008F75A0;
      if (byte_1008F1D38 == 1)
      {
        if (os_log_type_enabled((os_log_t)qword_1008F75A0, OS_LOG_TYPE_DEFAULT))
        {
          uint64_t v10 = *(void *)a1;
          int v13 = 138412802;
          uint64_t v14 = v10;
          __int16 v15 = 1024;
          int v16 = byte_1008F1D39;
          __int16 v17 = 1024;
          int v18 = 1;
          _os_log_impl( (void *)&_mh_execute_header,  v9,  OS_LOG_TYPE_DEFAULT,  "Warning: FastLEConnection:fastLeConnectionAllowed %@ forceAllow:%d forceOverride:%d",  (uint8_t *)&v13,  0x18u);
          char v9 = (os_log_s *)qword_1008F75A0;
        }

        int v8 = byte_1008F1D39;
        *(_BYTE *)(a1 + 544) = byte_1008F1D39;
      }

      if (os_log_type_enabled(v9, OS_LOG_TYPE_DEFAULT))
      {
        uint64_t v11 = *(void *)a1;
        int v12 = *(_DWORD *)(a1 + 532);
        int v13 = 138413058;
        uint64_t v14 = v11;
        __int16 v15 = 1024;
        int v16 = a2;
        __int16 v17 = 1024;
        int v18 = v8;
        __int16 v19 = 1024;
        int v20 = v12;
        _os_log_impl( (void *)&_mh_execute_header,  v9,  OS_LOG_TYPE_DEFAULT,  "FastLEConnection:fastLeConnectionAllowed %@ allowed:%d fFastLeConnectionAllowed:%d fControllerInfoOrigin:%d",  (uint8_t *)&v13,  0x1Eu);
        int v8 = *(unsigned __int8 *)(a1 + 544);
      }

      return sub_1005C284C(a1, v8 != 0);
    }

    else
    {
      return 12LL;
    }
  }

  return result;
}

void sub_1005C3654(id a1)
{
  uint64_t v1 = sub_1002E6E00();
  sub_10002418C(buf, "LE");
  sub_10002418C(__p, "DeviceFastLeConnectionForceAllow");
  int v2 = (*(uint64_t (**)(uint64_t, _BYTE *, void **, char *))(*(void *)v1 + 72LL))( v1,  buf,  __p,  &byte_1008F1D39);
  if (v6 < 0) {
    operator delete(__p[0]);
  }
  if (v8 < 0)
  {
    operator delete(*(void **)buf);
    if (!v2) {
      return;
    }
  }

  else if (!v2)
  {
    return;
  }

  byte_1008F1D38 = 1;
  uint64_t v3 = (os_log_s *)qword_1008F75A0;
  if (os_log_type_enabled((os_log_t)qword_1008F75A0, OS_LOG_TYPE_DEFAULT))
  {
    if (byte_1008F1D39) {
      uint64_t v4 = "YES";
    }
    else {
      uint64_t v4 = "NO";
    }
    *(_DWORD *)std::stringbuf::string_type buf = 136315138;
    *(void *)&uint8_t buf[4] = v4;
    _os_log_impl( (void *)&_mh_execute_header,  v3,  OS_LOG_TYPE_DEFAULT,  "Warning: FastLeConnection:fastLeConnectionAllowed DeviceFastLeConnectionForceAllow %s",  buf,  0xCu);
  }

void sub_1005C3794( _Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void *__p, uint64_t a11, int a12, __int16 a13, char a14, char a15, void *a16, uint64_t a17, int a18, __int16 a19, char a20, char a21)
{
  if (a15 < 0) {
    operator delete(__p);
  }
  if (a21 < 0) {
    operator delete(a16);
  }
  _Unwind_Resume(exception_object);
}

const char *sub_1005C37D0(unsigned int a1)
{
  if (a1 > 0xD) {
    return "?";
  }
  else {
    return off_1008A2EA0[a1];
  }
}

uint64_t sub_1005C37F4(uint64_t a1)
{
  uint64_t v2 = sub_100024098(a1 + 176, v25);
  uint64_t v3 = a1 + 184;
  if (a1 + 184 == v2)
  {
    sub_10002418C(v23, "A2051");
    if (v2 == sub_100024098(a1 + 176, v23))
    {
      sub_10002418C(v21, "A3085");
      if (v2 == sub_100024098(a1 + 176, (const void **)v21))
      {
        sub_10002418C(__p, "A2538");
        BOOL v4 = v2 != sub_100024098(a1 + 176, (const void **)__p);
        if (v20 < 0) {
          operator delete(__p[0]);
        }
      }

      else
      {
        BOOL v4 = 1;
      }

      if (v22 < 0) {
        operator delete(v21[0]);
      }
    }

    else
    {
      BOOL v4 = 1;
    }

    if (v24 < 0) {
      operator delete((void *)v23[0]);
    }
  }

  else
  {
    BOOL v4 = 1;
  }

  if (v26 < 0)
  {
    operator delete((void *)v25[0]);
    if (v4) {
      return 4LL;
    }
  }

  else if (v4)
  {
    return 4LL;
  }

  sub_10002418C(v17, "HasTS");
  uint64_t v6 = sub_100024098(a1 + 176, (const void **)v17);
  if (v18 < 0) {
    operator delete(v17[0]);
  }
  if (v3 != v6)
  {
    uint64_t v7 = sub_1002E6BF0();
    uint64_t v9 = sub_1002E6BF0();
    return (*(uint64_t (**)(uint64_t))(*(void *)v9 + 344LL))(v9);
  }

  sub_10002418C(v15, "_GHS_DEVICE_");
  uint64_t v8 = sub_100024098(a1 + 176, (const void **)v15);
  if (v16 < 0) {
    operator delete(v15[0]);
  }
  if (v3 != v8) {
    return 12LL;
  }
  if (*(_BYTE *)(a1 + 608)) {
    return 5LL;
  }
  uint64_t v10 = *(void **)(a1 + 200);
  if (!v10)
  {
    int v11 = *(_DWORD *)(a1 + 372);
    if (v11 == 655360) {
      unsigned int v12 = 11;
    }
    else {
      unsigned int v12 = 0;
    }
    if (v11 == 21) {
      return 3LL;
    }
    else {
      return v12;
    }
  }

  if (([*(id *)(a1 + 200) containsString:@"iMac"] & 1) != 0
    || ([*(id *)(a1 + 200) containsString:@"MacBook"] & 1) != 0)
  {
    return 9LL;
  }

  uint64_t result = CBProductIDFromNSString(*(void *)(a1 + 200));
  if ((_DWORD)result)
  {
    int v13 = (void *)objc_claimAutoreleasedReturnValue( +[CBProductInfo productInfoWithProductID:]( &OBJC_CLASS___CBProductInfo,  "productInfoWithProductID:",  result));
    unsigned int v14 = [v13 flags];

    if ((v14 & 0x2000) == 0)
    {
      if ((v14 & 0x4000) != 0) {
        return 8LL;
      }
      if ((v14 & 0x8000) != 0) {
        return 7LL;
      }
      return ((int)(v14 << 15) >> 31) & 6;
    }

    return 5LL;
  }

  return result;
}

void sub_1005C3AD0( _Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, int a11, __int16 a12, char a13, char a14, uint64_t a15, uint64_t a16, int a17, __int16 a18, char a19, char a20, void *__p, uint64_t a22, int a23, __int16 a24, char a25, char a26, void *a27, uint64_t a28, int a29, __int16 a30, char a31, char a32)
{
  _Unwind_Resume(a1);
}

uint64_t sub_1005C3B68(uint64_t result)
{
  *(_WORD *)(result + 529) = 0;
  return result;
}

void sub_1005C3B74(uint64_t *a1, char a2)
{
  *((_BYTE *)a1 + 160) = a2;
  if ((a2 & 1) == 0 && !*((_BYTE *)a1 + 161)) {
    *((_BYTE *)a1 + 162) = 0;
  }
  uint64_t v3 = a1[3];
  if (v3 || (uint64_t v3 = a1[2]) != 0)
  {
    if ((a2 & 1) == 0)
    {
      BOOL v4 = (void *)a1[69];
      a1[69] = 0LL;

      if (*((_BYTE *)a1 + 530))
      {
        uint64_t v5 = sub_1002E6E9C();
        int v6 = (*(uint64_t (**)(uint64_t, uint64_t, BOOL))(*(void *)v5 + 1840LL))(v5, v3, a1[3] != 0);
        if (v6)
        {
          int v7 = v6;
          uint64_t v8 = (os_log_s *)qword_1008F75A0;
          if (os_log_type_enabled((os_log_t)qword_1008F75A0, OS_LOG_TYPE_ERROR))
          {
            uint64_t v9 = *a1;
            sub_1005BFC20(v3, &__p);
            if ((__p.__r_.__value_.__s.__size_ & 0x80u) == 0) {
              p_p = &__p;
            }
            else {
              p_p = (std::stringbuf::string_type *)__p.__r_.__value_.__r.__words[0];
            }
            *(_DWORD *)std::stringbuf::string_type buf = 138412802;
            uint64_t v13 = v9;
            __int16 v14 = 2080;
            __int16 v15 = p_p;
            __int16 v16 = 1024;
            int v17 = v7;
            _os_log_error_impl( (void *)&_mh_execute_header,  v8,  OS_LOG_TYPE_ERROR,  "FastLEConnection:setLEPaired removePeerControllerCachedInfo device %@ (%s) returned %d",  buf,  0x1Cu);
          }
        }

        else
        {
          *((_BYTE *)a1 + 530) = 0;
        }
      }
    }
  }

  else if (os_log_type_enabled((os_log_t)qword_1008F75A0, OS_LOG_TYPE_FAULT))
  {
    sub_10069AA20();
  }

void sub_1005C3D04(id *a1, void *a2)
{
  id v4 = a2;
  uint64_t v5 = a1 + 69;
  objc_storeStrong(a1 + 69, a2);
  uint64_t v6 = (uint64_t)a1[3];
  if (!v6) {
    uint64_t v6 = (uint64_t)a1[2];
  }
  if (*v5)
  {
    if (!*((_BYTE *)a1 + 530) && *((_BYTE *)a1 + 160) && *((_BYTE *)a1 + 529))
    {
      uint64_t v15 = sub_1002E6E9C();
      int v16 = (*(uint64_t (**)(uint64_t, uint64_t, BOOL, void, id))(*(void *)v15 + 1832))( v15,  v6,  a1[3] != 0,  [a1[69] length],  objc_msgSend(*v5, "bytes"));
      *((_BYTE *)a1 + 530) = 1;
      if (!v16) {
        goto LABEL_24;
      }
      uint64_t v17 = qword_1008F75A0;
      if (!os_log_type_enabled((os_log_t)qword_1008F75A0, OS_LOG_TYPE_ERROR)) {
        goto LABEL_24;
      }
      id v18 = *a1;
      sub_1005BFC20(v6, &__p);
      if ((__p.__r_.__value_.__s.__size_ & 0x80u) == 0) {
        p_p = &__p;
      }
      else {
        p_p = (std::stringbuf::string_type *)__p.__r_.__value_.__r.__words[0];
      }
      id v20 = a1[65];
      int v21 = *((unsigned __int8 *)a1 + 528);
      *(_DWORD *)std::stringbuf::string_type buf = 138413314;
      id v24 = v18;
      __int16 v25 = 2080;
      char v26 = p_p;
      __int16 v27 = 2112;
      id v28 = v20;
      __int16 v29 = 1024;
      int v30 = v21;
      __int16 v31 = 1024;
      int v32 = v16;
      unsigned int v12 = "FastLEConnection:setLocalLTK writeStoredLTKForDevice device %@ (%s) controller cached data:%@ version:%d fai"
            "led with error %d";
      uint64_t v13 = (os_log_s *)v17;
      uint32_t v14 = 44;
      goto LABEL_21;
    }

    if ([*v5 length]) {
      goto LABEL_24;
    }
  }

  if (*((_BYTE *)a1 + 530))
  {
    uint64_t v7 = sub_1002E6E9C();
    int v8 = (*(uint64_t (**)(uint64_t, uint64_t, BOOL))(*(void *)v7 + 1840LL))(v7, v6, a1[3] != 0LL);
    if (!v8)
    {
      *((_BYTE *)a1 + 530) = 0;
      goto LABEL_24;
    }

    uint64_t v9 = qword_1008F75A0;
    if (os_log_type_enabled((os_log_t)qword_1008F75A0, OS_LOG_TYPE_ERROR))
    {
      id v10 = *a1;
      sub_1005BFC20(v6, &__p);
      if ((__p.__r_.__value_.__s.__size_ & 0x80u) == 0) {
        int v11 = &__p;
      }
      else {
        int v11 = (std::stringbuf::string_type *)__p.__r_.__value_.__r.__words[0];
      }
      *(_DWORD *)std::stringbuf::string_type buf = 138412802;
      id v24 = v10;
      __int16 v25 = 2080;
      char v26 = v11;
      __int16 v27 = 1024;
      LODWORD(v28) = v8;
      unsigned int v12 = "FastLEConnection:setLocalLTK removePeerControllerCachedInfo device %@ (%s) returned %d";
      uint64_t v13 = (os_log_s *)v9;
      uint32_t v14 = 28;
LABEL_21:
      _os_log_error_impl((void *)&_mh_execute_header, v13, OS_LOG_TYPE_ERROR, v12, buf, v14);
    }
  }

void sub_1005C3F90(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_1005C3FB8(uint64_t a1, int a2, uint64_t a3)
{
  *(_BYTE *)(a1 + 164) = a2;
  if (!a2) {
    a3 = 0LL;
  }
  *(void *)(a1 + 56) = a3;
  if ((a2 & 1) != 0)
  {
    *(CFAbsoluteTime *)(a1 + 416) = CFAbsoluteTimeGetCurrent();
  }

  else
  {
    *(_BYTE *)(a1 + 165) = 0;
    *(_BYTE *)(a1 + 236) = 0;
  }

uint64_t sub_1005C3FFC(uint64_t result, int a2)
{
  *(_DWORD *)(result + 168) = a2;
  if (*(_BYTE *)(result + 164))
  {
    uint64_t v2 = (uint64_t *)result;
    if (*(_DWORD *)(result + 532) == 3)
    {
      uint64_t v3 = (os_log_s *)qword_1008F75A0;
      if (os_log_type_enabled((os_log_t)qword_1008F75A0, OS_LOG_TYPE_DEFAULT))
      {
        uint64_t v4 = *v2;
        int v5 = 138412290;
        uint64_t v6 = v4;
        _os_log_impl( (void *)&_mh_execute_header,  v3,  OS_LOG_TYPE_DEFAULT,  "FastLEConnection:setLinkReadyDurationMS device %@ connected with Fast LE Connection cached info set by a CB client, removing.",  (uint8_t *)&v5,  0xCu);
      }

      return sub_1005C2558((uint64_t)v2, 0, 0LL, 0);
    }
  }

  return result;
}

uint64_t sub_1005C40CC@<X0>(uint64_t a1@<X0>, std::stringbuf::string_type *a2@<X8>)
{
  uint64_t v63 = 0LL;
  memset(v62, 0, sizeof(v62));
  __int128 v60 = 0u;
  __int128 v61 = 0u;
  *(_OWORD *)int v59 = 0u;
  memset(v58, 0, sizeof(v58));
  sub_10020E564((uint64_t)v58);
  *(_DWORD *)((char *)v58 + *(void *)(*(void *)&v58[0] - 24LL) + 8) |= 4u;
  if (*(void *)(a1 + 64))
  {
    uint64_t v4 = sub_1001FD17C(v58, (uint64_t)", FindMyBeaconID: ", 18LL);
    int v5 = (void *)objc_claimAutoreleasedReturnValue([*(id *)(a1 + 64) beaconIdentifier]);
    id v6 = objc_claimAutoreleasedReturnValue([v5 UUIDString]);
    uint64_t v7 = (const char *)[v6 UTF8String];
    size_t v8 = strlen(v7);
    uint64_t v9 = sub_1001FD17C(v4, (uint64_t)v7, v8);
    id v10 = sub_1001FD17C(v9, (uint64_t)" updated:", 9LL);
    int v11 = (void *)(a1 + 40);
    sub_1005BBFF8((unint64_t *)(a1 + 40), &__p);
    if ((__p.__r_.__value_.__s.__size_ & 0x80u) == 0) {
      p_p = &__p;
    }
    else {
      p_p = (std::stringbuf::string_type *)__p.__r_.__value_.__r.__words[0];
    }
    if ((__p.__r_.__value_.__s.__size_ & 0x80u) == 0) {
      uint64_t size = __p.__r_.__value_.__s.__size_;
    }
    else {
      uint64_t size = __p.__r_.__value_.__l.__size_;
    }
    sub_1001FD17C(v10, (uint64_t)p_p, size);

    uint32_t v14 = sub_1001FD17C(v58, (uint64_t)", FindMyUserID: ", 16LL);
    uint64_t v15 = (void *)objc_claimAutoreleasedReturnValue([*(id *)(a1 + 64) userIdentifier]);
    id v16 = objc_claimAutoreleasedReturnValue([v15 UUIDString]);
    uint64_t v17 = (const char *)[v16 UTF8String];
    size_t v18 = strlen(v17);
    __int16 v19 = sub_1001FD17C(v14, (uint64_t)v17, v18);
    id v20 = sub_1001FD17C(v19, (uint64_t)" updated:", 9LL);
    sub_1005BBFF8((unint64_t *)(a1 + 40), &__p);
    if ((__p.__r_.__value_.__s.__size_ & 0x80u) == 0) {
      int v21 = &__p;
    }
    else {
      int v21 = (std::stringbuf::string_type *)__p.__r_.__value_.__r.__words[0];
    }
    if ((__p.__r_.__value_.__s.__size_ & 0x80u) == 0) {
      uint64_t v22 = __p.__r_.__value_.__s.__size_;
    }
    else {
      uint64_t v22 = __p.__r_.__value_.__l.__size_;
    }
    sub_1001FD17C(v20, (uint64_t)v21, v22);

    int v23 = sub_1001FD17C(v58, (uint64_t)" FindMyGroupID:", 15LL);
    id v24 = (void *)objc_claimAutoreleasedReturnValue([*(id *)(a1 + 64) groupIdentifier]);
    if (v24)
    {
      int v11 = (void *)objc_claimAutoreleasedReturnValue([*(id *)(a1 + 64) groupIdentifier]);
      id v20 = objc_claimAutoreleasedReturnValue([v11 UUIDString]);
      __int16 v25 = (const char *)[v20 UTF8String];
    }

    else
    {
      __int16 v25 = "NONE";
    }

    size_t v26 = strlen(v25);
    sub_1001FD17C(v23, (uint64_t)v25, v26);
    if (v24)
    {
    }

    __int16 v27 = sub_1001FD17C(v58, (uint64_t)" fFindMyPartID:", 15LL);
    std::ostream::operator<<(v27, [*(id *)(a1 + 64) partIdentifier]);
    id v28 = sub_1001FD17C(v58, (uint64_t)" fFindMySerialNumber:", 21LL);
    __int16 v29 = (void *)objc_claimAutoreleasedReturnValue([*(id *)(a1 + 64) serialNumber]);
    id v30 = objc_claimAutoreleasedReturnValue( +[NSString stringWithFormat:]( &OBJC_CLASS___NSString, "stringWithFormat:", @"%@", v29));
    __int16 v31 = (const char *)[v30 UTF8String];
    size_t v32 = strlen(v31);
    sub_1001FD17C(v28, (uint64_t)v31, v32);

    char v33 = sub_1001FD17C(v58, (uint64_t)" keys:", 6LL);
    int v34 = (void *)objc_claimAutoreleasedReturnValue([*(id *)(a1 + 64) longTermKeyMap]);
    id v35 = objc_claimAutoreleasedReturnValue( +[NSString stringWithFormat:]( &OBJC_CLASS___NSString, "stringWithFormat:", @"%@", v34));
    unsigned int v36 = (const char *)[v35 UTF8String];
    size_t v37 = strlen(v36);
    sub_1001FD17C(v33, (uint64_t)v36, v37);

    std::string::size_type v38 = sub_1001FD17C(v58, (uint64_t)" sessions:", 10LL);
    int v39 = (void *)objc_claimAutoreleasedReturnValue([*(id *)(a1 + 64) allowedSessions]);
    id v40 = objc_claimAutoreleasedReturnValue( +[NSString stringWithFormat:]( &OBJC_CLASS___NSString, "stringWithFormat:", @"%@", v39));
    int v41 = (const char *)[v40 UTF8String];
    size_t v42 = strlen(v41);
    sub_1001FD17C(v38, (uint64_t)v41, v42);

    int v43 = sub_1001FD17C(v58, (uint64_t)" Valid LTKs:", 12LL);
    id v44 = objc_claimAutoreleasedReturnValue( +[NSString stringWithFormat:]( &OBJC_CLASS___NSString, "stringWithFormat:", @"%@", *(void *)(a1 + 72)));
    int v45 = (const char *)[v44 UTF8String];
    size_t v46 = strlen(v45);
    sub_1001FD17C(v43, (uint64_t)v45, v46);

    std::string::size_type v47 = sub_1001FD17C(v58, (uint64_t)" Last used Address/LTK:", 23LL);
    id v48 = objc_claimAutoreleasedReturnValue( +[NSString stringWithFormat:]( &OBJC_CLASS___NSString, "stringWithFormat:", @"%@", *(void *)(a1 + 80)));
    uint64_t v49 = (const char *)[v48 UTF8String];
    size_t v50 = strlen(v49);
    std::string::size_type v51 = sub_1001FD17C(v47, (uint64_t)v49, v50);
    __int128 v52 = sub_1001FD17C(v51, (uint64_t)"/", 1LL);
    id v53 = objc_claimAutoreleasedReturnValue( +[NSString stringWithFormat:]( &OBJC_CLASS___NSString, "stringWithFormat:", @"%@", *(void *)(a1 + 88)));
    __int128 v54 = (const char *)[v53 UTF8String];
    size_t v55 = strlen(v54);
    sub_1001FD17C(v52, (uint64_t)v54, v55);
  }

  std::stringbuf::str(a2, (const std::stringbuf *)((char *)v58 + 8));
  if (SHIBYTE(v60) < 0) {
    operator delete(v59[1]);
  }
  std::streambuf::~streambuf((char *)v58 + 8);
  return std::ios::~ios(v62);
}

void sub_1005C4654( _Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void *__p, uint64_t a11, int a12, __int16 a13, char a14, char a15, char a16)
{
  sub_10020E784((uint64_t)&a16);
  _Unwind_Resume(a1);
}

BOOL sub_1005C4708(uint64_t a1)
{
  uint64_t v2 = a1 + 176;
  sub_10002418C(__p, "_HID_DEVICE_");
  uint64_t v3 = sub_100024098(v2, (const void **)__p);
  if (v6 < 0) {
    operator delete(__p[0]);
  }
  return a1 + 184 != v3;
}

void sub_1005C476C( _Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void *__p, uint64_t a11, int a12, __int16 a13, char a14, char a15)
{
  if (a15 < 0) {
    operator delete(__p);
  }
  _Unwind_Resume(exception_object);
}

BOOL sub_1005C4788(uint64_t a1)
{
  if (sub_1005C4708(a1)) {
    return *(_BYTE *)(a1 + 610) != 0;
  }
  uint64_t v3 = (os_log_s *)qword_1008F75A0;
  BOOL v4 = os_log_type_enabled((os_log_t)qword_1008F75A0, OS_LOG_TYPE_DEFAULT);
  BOOL result = 0LL;
  if (v4)
  {
    uint64_t v5 = *(void *)a1;
    int v6 = 138412290;
    uint64_t v7 = v5;
    _os_log_impl( (void *)&_mh_execute_header,  v3,  OS_LOG_TYPE_DEFAULT,  "Device %@ does not have _HID_SERVICE_",  (uint8_t *)&v6,  0xCu);
    return 0LL;
  }

  return result;
}

uint64_t sub_1005C4850@<X0>(uint64_t a1@<X0>, std::stringbuf::string_type *a2@<X8>)
{
  uint64_t v80 = 0LL;
  __int128 v78 = 0u;
  memset(v79, 0, sizeof(v79));
  *(_OWORD *)char v76 = 0u;
  __int128 v77 = 0u;
  memset(v75, 0, sizeof(v75));
  sub_10020E564((uint64_t)v75);
  *(_DWORD *)((char *)v75 + *(void *)(*(void *)&v75[0] - 24LL) + 8) |= 4u;
  id v4 = sub_1005BFB9C(*(void *)(a1 + 16));
  id v5 = objc_claimAutoreleasedReturnValue(v4);
  int v6 = (const char *)[v5 UTF8String];
  size_t v7 = strlen(v6);
  sub_1001FD17C(v75, (uint64_t)v6, v7);

  if (*(void *)(a1 + 24) && *(_BYTE *)(a1 + 22))
  {
    size_t v8 = sub_1001FD17C(v75, (uint64_t)" (", 2LL);
    id v9 = sub_1005BFB9C(*(void *)(a1 + 24));
    id v10 = objc_claimAutoreleasedReturnValue(v9);
    int v11 = (const char *)[v10 UTF8String];
    size_t v12 = strlen(v11);
    uint64_t v13 = sub_1001FD17C(v8, (uint64_t)v11, v12);
    sub_1001FD17C(v13, (uint64_t)")", 1LL);
  }

  if (*(char *)(a1 + 127) < 0)
  {
    if (!*(void *)(a1 + 112)) {
      goto LABEL_22;
    }
  }

  else if (!*(_BYTE *)(a1 + 127))
  {
    goto LABEL_22;
  }

  switch(*(_DWORD *)(a1 + 128))
  {
    case 1:
      uint32_t v14 = sub_1001FD17C(v75, (uint64_t)", ", 2LL);
      uint64_t v15 = "Adv.";
      goto LABEL_13;
    case 2:
      uint32_t v14 = sub_1001FD17C(v75, (uint64_t)", ", 2LL);
      uint64_t v15 = "GAP";
      uint64_t v16 = 3LL;
      break;
    case 3:
      uint32_t v14 = sub_1001FD17C(v75, (uint64_t)", ", 2LL);
      uint64_t v15 = "User";
LABEL_13:
      uint64_t v16 = 4LL;
      break;
    case 4:
      uint32_t v14 = sub_1001FD17C(v75, (uint64_t)", ", 2LL);
      uint64_t v15 = "FindMy";
      uint64_t v16 = 6LL;
      break;
    default:
      uint32_t v14 = sub_1001FD17C(v75, (uint64_t)", ", 2LL);
      uint64_t v15 = "Unknown";
      uint64_t v16 = 7LL;
      break;
  }

  sub_1001FD17C(v14, (uint64_t)v15, v16);
  uint64_t v17 = sub_1001FD17C(v75, (uint64_t)"Name: ", 6LL);
  size_t v18 = sub_1001FD17C(v17, (uint64_t)"", 1LL);
  int v19 = *(char *)(a1 + 127);
  if (v19 >= 0) {
    uint64_t v20 = a1 + 104;
  }
  else {
    uint64_t v20 = *(void *)(a1 + 104);
  }
  if (v19 >= 0) {
    uint64_t v21 = *(unsigned __int8 *)(a1 + 127);
  }
  else {
    uint64_t v21 = *(void *)(a1 + 112);
  }
  uint64_t v22 = sub_1001FD17C(v18, v20, v21);
  sub_1001FD17C(v22, (uint64_t)"", 1LL);
LABEL_22:
  double Current = CFAbsoluteTimeGetCurrent();
  if (*(double *)(a1 + 400) != 0.0)
  {
    id v24 = sub_1001FD17C(v75, (uint64_t)", LastSeen: ", 12LL);
    *(void *)((char *)v24 + *(void *)(*v24 - 24LL) + 16) = 2LL;
    __int16 v25 = (void *)std::ostream::operator<<(Current - *(double *)(a1 + 400));
    sub_1001FD17C(v25, (uint64_t)"s ago", 5LL);
  }

  int v74 = 0;
  sub_1000B0740(&v74, 0LL);
  if (*(_DWORD *)(a1 + 140))
  {
    size_t v26 = sub_1001FD17C(v75, (uint64_t)", LastConn: ", 12LL);
    *(void *)((char *)v26 + *(void *)(*v26 - 24LL) + 16) = 2LL;
    __int16 v27 = (void *)std::ostream::operator<<(v26, (v74 - *(_DWORD *)(a1 + 140)));
    sub_1001FD17C(v27, (uint64_t)"s ago", 5LL);
  }

  if (*(_BYTE *)(a1 + 98)) {
    sub_1001FD17C(v75, (uint64_t)", Dual-mode", 11LL);
  }
  if (*(_BYTE *)(a1 + 160)) {
    sub_1001FD17C(v75, (uint64_t)", Paired", 8LL);
  }
  if (*(_BYTE *)(a1 + 236)) {
    sub_1001FD17C(v75, (uint64_t)", AutoReconnectEnabled", 22LL);
  }
  if (*(char *)(a1 + 231) < 0)
  {
    if (!*(void *)(a1 + 216)) {
      goto LABEL_43;
    }
  }

  else if (!*(_BYTE *)(a1 + 231))
  {
    goto LABEL_43;
  }

  id v28 = sub_1001FD17C(v75, (uint64_t)", iCloud: ", 10LL);
  int v29 = *(char *)(a1 + 231);
  if (v29 >= 0) {
    uint64_t v30 = a1 + 208;
  }
  else {
    uint64_t v30 = *(void *)(a1 + 208);
  }
  if (v29 >= 0) {
    uint64_t v31 = *(unsigned __int8 *)(a1 + 231);
  }
  else {
    uint64_t v31 = *(void *)(a1 + 216);
  }
  sub_1001FD17C(v28, v30, v31);
LABEL_43:
  if (*(_BYTE *)(a1 + 354))
  {
    size_t v32 = sub_1001FD17C(v75, (uint64_t)", CoexPriority: ", 16LL);
    std::ostream::operator<<(v32, *(unsigned __int8 *)(a1 + 354));
  }

  if (*(_BYTE *)(a1 + 234)) {
    sub_1001FD17C(v75, (uint64_t)", LE GATT Disabled", 18LL);
  }
  if (*(void *)(a1 + 56))
  {
    char v33 = sub_1001FD17C(v75, (uint64_t)", connectedAddress:", 19LL);
    sub_1005BFC20(*(void *)(a1 + 56), &__p);
    int v34 = (__p.__r_.__value_.__s.__size_ & 0x80u) == 0
        ? &__p
        : (std::stringbuf::string_type *)__p.__r_.__value_.__r.__words[0];
    uint64_t v35 = (__p.__r_.__value_.__s.__size_ & 0x80u) == 0 ? __p.__r_.__value_.__s.__size_ : __p.__r_.__value_.__l.__size_;
    unsigned int v36 = sub_1001FD17C(v33, (uint64_t)v34, v35);
    sub_1001FD17C(v36, (uint64_t)" ", 1LL);
  }

  size_t v37 = sub_1001FD17C(v75, (uint64_t)", ", 2LL);
  sub_1005C0E60((id *)a1, &__p);
  if ((__p.__r_.__value_.__s.__size_ & 0x80u) == 0) {
    p_p = &__p;
  }
  else {
    p_p = (std::stringbuf::string_type *)__p.__r_.__value_.__r.__words[0];
  }
  if ((__p.__r_.__value_.__s.__size_ & 0x80u) == 0) {
    uint64_t size = __p.__r_.__value_.__s.__size_;
  }
  else {
    uint64_t size = __p.__r_.__value_.__l.__size_;
  }
  sub_1001FD17C(v37, (uint64_t)p_p, size);
  if (*(_BYTE *)(a1 + 528))
  {
    id v40 = sub_1001FD17C(v75, (uint64_t)", Cached controller version:", 28LL);
    __p.__r_.__value_.__s.__data_[0] = *(_BYTE *)(a1 + 528);
    int v41 = sub_1001FD17C(v40, (uint64_t)&__p, 1LL);
    size_t v42 = sub_1001FD17C(v41, (uint64_t)" data:", 6LL);
    id v43 = objc_claimAutoreleasedReturnValue( +[NSString stringWithFormat:]( &OBJC_CLASS___NSString, "stringWithFormat:", @"%@", *(void *)(a1 + 520)));
    id v44 = (const char *)[v43 UTF8String];
    size_t v45 = strlen(v44);
    size_t v46 = sub_1001FD17C(v42, (uint64_t)v44, v45);
    std::string::size_type v47 = sub_1001FD17C(v46, (uint64_t)" origin:", 8LL);
    std::ostream::operator<<(v47, *(unsigned int *)(a1 + 532));
  }

  id v48 = sub_1001FD17C(v75, (uint64_t)", EstablishedFastLeConnection:", 30LL);
  if (*(_BYTE *)(a1 + 165)) {
    uint64_t v49 = "Y";
  }
  else {
    uint64_t v49 = "N";
  }
  sub_1001FD17C(v48, (uint64_t)v49, 1LL);
  size_t v50 = sub_1001FD17C(v75, (uint64_t)", linkReadyDuration:", 20LL);
  std::string::size_type v51 = (void *)std::ostream::operator<<(v50, *(unsigned int *)(a1 + 168));
  sub_1001FD17C(v51, (uint64_t)"ms", 2LL);
  if (*(_BYTE *)(a1 + 608)) {
    sub_1001FD17C(v75, (uint64_t)", ProxPayloadDecrypted", 22LL);
  }
  __int128 v52 = *(char **)(a1 + 584);
  id v53 = *(char **)(a1 + 592);
  if (v52 != v53)
  {
    char v54 = -127;
    do
    {
      int v56 = *v52++;
      char v55 = v56;
      if (v54 <= v56) {
        char v54 = v55;
      }
    }

    while (v52 != v53);
    if (v54 >= -126)
    {
      uint64_t v57 = sub_1001FD17C(v75, (uint64_t)", lastRSSIValue:", 16LL);
      __int16 v58 = (void *)std::ostream::operator<<(v57, v54);
      sub_1001FD17C(v58, (uint64_t)"dBm", 3LL);
    }
  }

  id v59 = sub_1005C50F4(a1);
  __int128 v60 = (void *)objc_claimAutoreleasedReturnValue(v59);
  if ([v60 count])
  {
    sub_1001FD17C(v75, (uint64_t)", customProps:[", 15LL);
    __int128 v71 = 0u;
    __int128 v72 = 0u;
    __int128 v69 = 0u;
    __int128 v70 = 0u;
    id v61 = v60;
    id v62 = [v61 countByEnumeratingWithState:&v69 objects:v81 count:16];
    if (v62)
    {
      uint64_t v63 = *(void *)v70;
      do
      {
        for (uint64_t i = 0LL; i != v62; uint64_t i = (char *)i + 1)
        {
          if (*(void *)v70 != v63) {
            objc_enumerationMutation(v61);
          }
          unsigned int v65 = (const char *)[*(id *)(*((void *)&v69 + 1) + 8 * (void)i) UTF8String];
          size_t v66 = strlen(v65);
          BOOL v67 = sub_1001FD17C(v75, (uint64_t)v65, v66);
          sub_1001FD17C(v67, (uint64_t)" ", 1LL);
        }

        id v62 = [v61 countByEnumeratingWithState:&v69 objects:v81 count:16];
      }

      while (v62);
    }

    sub_1001FD17C(v75, (uint64_t)"]", 1LL);
  }

  std::stringbuf::str(a2, (const std::stringbuf *)((char *)v75 + 8));

  if (SHIBYTE(v77) < 0) {
    operator delete(v76[1]);
  }
  std::streambuf::~streambuf((char *)v75 + 8);
  return std::ios::~ios(v79);
}

void sub_1005C5058( _Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, void *__p, uint64_t a20, int a21, __int16 a22, char a23, char a24, uint64_t a25, char a26)
{
  sub_10020E784((uint64_t)&a26);
  _Unwind_Resume(a1);
}

id sub_1005C50F4(uint64_t a1)
{
  uint64_t v1 = *(void **)(a1 + 512);
  if (v1) {
    uint64_t v2 = (void *)objc_claimAutoreleasedReturnValue([v1 allKeys]);
  }
  else {
    uint64_t v2 = &__NSArray0__struct;
  }
  return v2;
}

id sub_1005C5120(uint64_t a1, void *a2)
{
  id v3 = a2;
  if (!v3)
  {
    if (os_log_type_enabled((os_log_t)qword_1008F75A0, OS_LOG_TYPE_ERROR)) {
      sub_10069AA58();
    }
    goto LABEL_6;
  }

  id v4 = *(void **)(a1 + 512);
  if (!v4)
  {
LABEL_6:
    id v5 = 0LL;
    goto LABEL_7;
  }

  id v5 = (void *)objc_claimAutoreleasedReturnValue([v4 objectForKey:v3]);
LABEL_7:

  return v5;
}

void sub_1005C5198(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

uint64_t sub_1005C51A8(uint64_t a1, void *a2, void *a3)
{
  id v5 = a2;
  id v6 = a3;
  if (!v5 || (unint64_t)[v5 length] >= 0x401)
  {
    if (os_log_type_enabled((os_log_t)qword_1008F75A0, OS_LOG_TYPE_ERROR)) {
      sub_10069AA58();
    }
LABEL_5:
    uint64_t v7 = 0LL;
    goto LABEL_6;
  }

  if ((unint64_t)[v6 length] >= 0x401)
  {
    id v9 = (os_log_s *)qword_1008F75A0;
    if (os_log_type_enabled((os_log_t)qword_1008F75A0, OS_LOG_TYPE_ERROR)) {
      sub_10069AA84((uint64_t)v5, (uint64_t)v6, v9);
    }
    goto LABEL_5;
  }

  id v10 = *(void **)(a1 + 512);
  if (!v10)
  {
    int v11 = objc_opt_new(&OBJC_CLASS___NSMutableDictionary);
    size_t v12 = *(void **)(a1 + 512);
    *(void *)(a1 + 512) = v11;

    id v10 = *(void **)(a1 + 512);
  }

  uint64_t v13 = (void *)objc_claimAutoreleasedReturnValue([v10 objectForKey:v5]);
  unsigned int v14 = [v13 isEqualToString:v6];
  if ((v14 & 1) == 0)
  {
    uint64_t v15 = *(void **)(a1 + 512);
    if (v6) {
      [v15 setObject:v6 forKey:v5];
    }
    else {
      [v15 removeObjectForKey:v5];
    }
  }

  uint64_t v7 = v14 ^ 1;

LABEL_6:
  return v7;
}

void sub_1005C52E4(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

uint64_t *sub_1005C5308(uint64_t **a1, const void **a2, uint64_t a3)
{
  uint64_t v8 = 0LL;
  id v5 = (uint64_t **)sub_10023E6A4((uint64_t)a1, &v8, a2);
  BOOL result = *v5;
  if (!*v5)
  {
    memset(v7, 0, sizeof(v7));
    sub_100291A88((uint64_t)a1, a3, v7);
    sub_100029630(a1, v8, v5, v7[0]);
    return v7[0];
  }

  return result;
}

void sub_1005C5390(id a1)
{
  uint64_t v1 = operator new(0x1A0uLL);
  sub_1002769A4();
  off_1008D67C0 = v1;
}

void sub_1005C53C0(_Unwind_Exception *a1)
{
}

void sub_1005C53D4(id a1)
{
  uint64_t v1 = operator new(0x230uLL);
  sub_10042BC28();
  off_1008D60A8 = v1;
}

void sub_1005C5404(_Unwind_Exception *a1)
{
}

uint64_t sub_1005C5418(uint64_t a1)
{
  uint64_t v2 = (void *)sub_10041BFD4(a1, "GATTService", 0x100000);
  *uint64_t v2 = &off_1008A2F20;
  v2[41] = 0LL;
  if (qword_1008D9720 != -1) {
    dispatch_once(&qword_1008D9720, &stru_1008A3010);
  }
  uint64_t v3 = qword_1008D9718;
  *(void *)(a1 + 328) = qword_1008D9718;
  sub_10041C264(a1, v3);
  return a1;
}

void sub_1005C5494(_Unwind_Exception *a1)
{
}

void sub_1005C54B0(uint64_t a1)
{
  uint64_t v1 = (void *)sub_10041C0C4(a1);
  operator delete(v1);
}

uint64_t sub_1005C54C4(uint64_t a1)
{
  uint64_t v2 = (os_log_s *)qword_1008F75B0;
  if (os_log_type_enabled((os_log_t)qword_1008F75B0, OS_LOG_TYPE_DEFAULT))
  {
    *(_WORD *)id v4 = 0;
    _os_log_impl((void *)&_mh_execute_header, v2, OS_LOG_TYPE_DEFAULT, "GATTService start", v4, 2u);
  }

  return sub_10041C414(a1);
}

uint64_t sub_1005C5534(uint64_t a1)
{
  uint64_t v2 = (os_log_s *)qword_1008F75B0;
  if (os_log_type_enabled((os_log_t)qword_1008F75B0, OS_LOG_TYPE_DEFAULT))
  {
    *(_WORD *)id v4 = 0;
    _os_log_impl((void *)&_mh_execute_header, v2, OS_LOG_TYPE_DEFAULT, "GATTService stop", v4, 2u);
  }

  return sub_10041C708(a1);
}

BOOL sub_1005C55A4(uint64_t a1, unsigned __int8 *a2)
{
  if (qword_1008D9278 != -1) {
    dispatch_once(&qword_1008D9278, &stru_1008A3030);
  }
  if (!sub_100413664(qword_1008D9270, a2)) {
    return sub_10041D740(a1, (uint64_t)a2);
  }
  id v4 = (os_log_s *)qword_1008F75B0;
  if (os_log_type_enabled((os_log_t)qword_1008F75B0, OS_LOG_TYPE_DEFAULT))
  {
    sub_1003CF00C((uint64_t)a2, __p);
    if (v8 >= 0) {
      id v5 = __p;
    }
    else {
      id v5 = (void **)__p[0];
    }
    *(_DWORD *)std::stringbuf::string_type buf = 136446210;
    id v10 = v5;
    _os_log_impl( (void *)&_mh_execute_header,  v4,  OS_LOG_TYPE_DEFAULT,  "Rejecting GATT connection because device %{public}s is already connected over GATT",  buf,  0xCu);
    if (v8 < 0) {
      operator delete(__p[0]);
    }
  }

  return 0LL;
}

uint64_t sub_1005C56FC(uint64_t a1, uint64_t a2)
{
  __int128 v12 = xmmword_1006C28A0;
  memset(v14, 0, sizeof(v14));
  char v11 = 0;
  int v10 = 0;
  if (sub_1003D518C(a2))
  {
    if (sub_1003D2E50(a2, &v12, 4u)) {
      int v4 = 4;
    }
    else {
      int v4 = 0;
    }
  }

  else
  {
    BOOL v5 = sub_1003E235C(a2, v14, &v11);
    if (v11) {
      BOOL v6 = v5;
    }
    else {
      BOOL v6 = 0;
    }
    if (v6) {
      int v4 = 4 * (sub_10011B978((unsigned __int8 *)v14, 6145, &v10) == 0);
    }
    else {
      int v4 = 0;
    }
  }

  unsigned int v7 = *(_DWORD *)(a1 + 32);
  uint64_t v13 = 0LL;
  sub_1000B0400((uint64_t)&v13);
  *(void *)&__int128 v9 = (int)v13;
  *((void *)&v9 + 1) = SWORD2(v13);
  return sub_1003D1FC4(a2, v7, v4, &v9, 0);
}

uint64_t sub_1005C5868(uint64_t a1, uint64_t a2, _BYTE *a3)
{
  __int128 v8 = xmmword_1006C28A0;
  memset(v9, 0, sizeof(v9));
  char v7 = 0;
  int v6 = 0;
  *a3 = 0;
  if (sub_1003D518C(a2))
  {
    uint64_t result = sub_1003D2E50(a2, &v8, 4u);
    if ((result & 1) == 0) {
      return result;
    }
LABEL_10:
    *a3 = 1;
    return result;
  }

  uint64_t result = sub_1003D518C(a2);
  if ((_DWORD)result)
  {
    uint64_t result = sub_1003D2B2C(a2, 23);
    if ((_DWORD)result) {
      goto LABEL_10;
    }
  }

  return result;
}

void sub_1005C5984(id a1)
{
  uint64_t v1 = operator new(0x110uLL);
  sub_1003C0CFC((uint64_t)v1);
  qword_1008D9718 = (uint64_t)v1;
}

void sub_1005C59B4(_Unwind_Exception *a1)
{
}

void sub_1005C59C8(id a1)
{
  uint64_t v1 = operator new(0x50uLL);
  sub_100411DB0((uint64_t)v1);
  qword_1008D9270 = (uint64_t)v1;
}

void sub_1005C59F8(_Unwind_Exception *a1)
{
}

uint64_t sub_1005C5A0C(uint64_t a1, int a2, int a3, int a4)
{
  *(void *)a1 = &off_1008A3060;
  *(void *)(a1 + 8) = 0LL;
  __int128 v8 = (id *)(a1 + 8);
  if (qword_1008D6788 != -1) {
    dispatch_once(&qword_1008D6788, &stru_1008A3078);
  }
  if ((a3 - 1) > 0xA)
  {
    __int128 v9 = @"com.apple.bluetooth.LeBroadcaster.AdvertisingConfigAssertion";
    if (!a4) {
      goto LABEL_8;
    }
    goto LABEL_7;
  }

  __int128 v9 = off_1008A30B8[a3 - 1];
  if (a4) {
LABEL_7:
  }
    __int128 v9 = (__CFString *)objc_claimAutoreleasedReturnValue( +[NSString stringWithFormat:]( &OBJC_CLASS___NSString,  "stringWithFormat:",  @"%@.ForceWake",  v9));
LABEL_8:
  objc_storeStrong(v8, v9);
  *(_DWORD *)(a1 + 16) = a3;
  *(_DWORD *)(a1 + 20) = a2;
  *(_BYTE *)(a1 + 24) = a4;
  if (!a4)
  {
    IOReturn v11 = IOPMAssertionCreateWithName(@"PreventUserIdleSystemSleep", 0xFFu, v9, (IOPMAssertionID *)(a1 + 28));
    if (!v11) {
      goto LABEL_21;
    }
    goto LABEL_17;
  }

  int v28 = 1;
  Mutable = CFDictionaryCreateMutable( kCFAllocatorDefault,  0LL,  &kCFTypeDictionaryKeyCallBacks,  &kCFTypeDictionaryValueCallBacks);
  CFDictionaryAddValue(Mutable, @"AssertName", v9);
  IOReturn v11 = IOPMAssertionDeclareSystemActivityWithProperties(Mutable, a1 + 28, &v28);
  __int128 v12 = (os_log_s *)qword_1008F7578;
  if (os_log_type_enabled((os_log_t)qword_1008F7578, OS_LOG_TYPE_INFO))
  {
    *(_DWORD *)std::stringbuf::string_type buf = 138412802;
    if (v28 == 1) {
      uint64_t v13 = "kIOPMSystemSleepNotReverted";
    }
    else {
      uint64_t v13 = "kIOPMSystemSleepReverted";
    }
    uint64_t v30 = v9;
    __int16 v31 = 1024;
    IOReturn v32 = v11;
    __int16 v33 = 2080;
    int v34 = v13;
    _os_log_impl( (void *)&_mh_execute_header,  v12,  OS_LOG_TYPE_INFO,  "IOPMAssertionDeclareSystemActivityWithProperties %@ returned %d systemState=%s ",  buf,  0x1Cu);
  }

  CFRelease(Mutable);
  if (v11)
  {
LABEL_17:
    unsigned int v14 = (os_log_s *)qword_1008F7578;
    if (os_log_type_enabled((os_log_t)qword_1008F7578, OS_LOG_TYPE_ERROR))
    {
      int v19 = (__CFString *)-[__CFString UTF8String](v9, "UTF8String");
      *(_DWORD *)std::stringbuf::string_type buf = 136315394;
      uint64_t v30 = v19;
      __int16 v31 = 1024;
      IOReturn v32 = v11;
      _os_log_error_impl( (void *)&_mh_execute_header,  v14,  OS_LOG_TYPE_ERROR,  "Failed to take assertionId for name: %s, return value was: %d",  buf,  0x12u);
      unsigned int v14 = (os_log_s *)qword_1008F7578;
    }

    if (os_log_type_enabled(v14, OS_LOG_TYPE_FAULT)) {
      sub_10069AAFC((uint64_t)-[__CFString UTF8String](v9, "UTF8String"), buf, v11, v14);
    }
  }

void sub_1005C5D6C(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

uint64_t sub_1005C5DAC(uint64_t a1)
{
  *(void *)a1 = &off_1008A3060;
  uint64_t v2 = (int *)(a1 + 28);
  IOReturn v3 = IOPMAssertionRelease(*(_DWORD *)(a1 + 28));
  if (v3)
  {
    int v4 = (os_log_s *)qword_1008F7578;
    if (os_log_type_enabled((os_log_t)qword_1008F7578, OS_LOG_TYPE_ERROR))
    {
      int v12 = *v2;
      *(_DWORD *)std::stringbuf::string_type buf = 67109376;
      *(_DWORD *)&uint8_t buf[4] = v12;
      __int16 v24 = 1024;
      IOReturn v25 = v3;
      _os_log_error_impl( (void *)&_mh_execute_header,  v4,  OS_LOG_TYPE_ERROR,  "Failed to release assertionId: %d, return value was %d",  buf,  0xEu);
      int v4 = (os_log_s *)qword_1008F7578;
    }

    if (os_log_type_enabled(v4, OS_LOG_TYPE_FAULT)) {
      sub_10069AB50(v2, v3, v4);
    }
    if (qword_1008D9060 != -1) {
      dispatch_once(&qword_1008D9060, &stru_1008A3098);
    }
    uint64_t v5 = qword_1008D9058;
    sub_10002418C(buf, "Assertion");
    sub_10002418C(__p, "FailedToReleaseAssertion");
    sub_10040C784(0.0, v5, (uint64_t *)buf, (uint64_t *)__p);
    if (v22 < 0) {
      operator delete(__p[0]);
    }
    if (v26 < 0) {
      operator delete(*(void **)buf);
    }
  }

  int v6 = *(_DWORD *)(a1 + 16);
  int v7 = *(_DWORD *)(a1 + 20);
  CFAbsoluteTime Current = CFAbsoluteTimeGetCurrent();
  char v9 = *(_BYTE *)(a1 + 24);
  int v10 = *(_DWORD *)(a1 + 28);
  if (qword_1008D6788 != -1) {
    dispatch_once(&qword_1008D6788, &stru_1008A3078);
  }
  v13[0] = v7;
  v13[1] = 1;
  _DWORD v13[2] = v6;
  v13[3] = 0;
  CFAbsoluteTime v14 = Current;
  IOReturn v15 = v3;
  char v16 = v9;
  __int16 v17 = 0;
  char v18 = 0;
  int v19 = v10;
  int v20 = 0;
  sub_10040EE8C((uint64_t)off_1008D6780, v13);

  return a1;
}

void sub_1005C5FC0( _Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, void *__p, uint64_t a15, int a16, __int16 a17, char a18, char a19, void *a20, uint64_t a21, int a22, __int16 a23, char a24, char a25)
{
  if (a19 < 0) {
    operator delete(__p);
  }
  if (a25 < 0) {
    operator delete(a20);
  }

  _Unwind_Resume(a1);
}

void sub_1005C6018(uint64_t a1)
{
  uint64_t v1 = (void *)sub_1005C5DAC(a1);
  operator delete(v1);
}

id sub_1005C602C(uint64_t a1)
{
  return [*(id *)(a1 + 8) UTF8String];
}

void sub_1005C6034(id a1)
{
  uint64_t v1 = operator new(0xA8uLL);
  sub_10040D0A0((uint64_t)v1);
  off_1008D6780 = v1;
}

void sub_1005C6064(_Unwind_Exception *a1)
{
}

void sub_1005C6078(id a1)
{
  uint64_t v1 = operator new(0x18uLL);
  *(void *)uint64_t v1 = 0LL;
  v1[2] = 0;
  *((_BYTE *)v1 + 12) = 0;
  v1[4] = 0;
  qword_1008D9058 = (uint64_t)v1;
}

uint64_t sub_1005C60A8(uint64_t a1)
{
  *(void *)a1 = off_1008A3120;
  *(void *)(a1 + 8) = off_1008A31C8;
  *(void *)(a1 + 16) = off_1008A31E8;
  *(void *)(a1 + 24) = off_1008A3210;
  *(void *)(a1 + 32) = &off_1008A3240;
  *(void *)(a1 + 40) = &off_1008A3258;
  *(void *)(a1 + 48) = &off_1008A3270;
  *(void *)(a1 + 56) = &off_1008A3288;
  *(void *)(a1 + 64) = &off_1008A32A0;
  sub_100242DC4(a1 + 80);
  *(void *)(a1 + 224) = 0LL;
  *(void *)(a1 + 216) = a1 + 224;
  *(_DWORD *)(a1 + 144) = 500;
  *(void *)(a1 + 160) = 0LL;
  *(void *)(a1 + 176) = 0LL;
  *(void *)(a1 + 168) = a1 + 176;
  *(void *)(a1 + 148) = 0LL;
  *(_BYTE *)(a1 + 156) = 0;
  *(void *)(a1 + 184) = 0LL;
  *(void *)(a1 + 192) = a1 + 192;
  *(void *)(a1 + 200) = a1 + 192;
  *(void *)(a1 + 208) = 0LL;
  *(void *)(a1 + 232) = 0LL;
  *(void *)(a1 + 248) = 0LL;
  *(_DWORD *)(a1 + 256) = 0;
  *(void *)(a1 + 264) = 0LL;
  *(void *)(a1 + 272) = 0LL;
  *(void *)(a1 + 280) = 0LL;
  *(_BYTE *)(a1 + 288) = 0;
  uint64_t v2 = operator new(0x10uLL);
  sub_100404F28(v2, (uint64_t)"LeDeviceManager");
  *(void *)(a1 + 72) = v2;
  sub_100404F30((uint64_t)v2, QOS_CLASS_USER_INITIATED);
  int v46 = 0;
  uint64_t v3 = sub_1002E6E00();
  sub_10002418C(buf, "LeDeviceCache");
  sub_10002418C(__p, "NumDevicesInMemory");
  int v4 = (*(uint64_t (**)(uint64_t, uint8_t *, void **, int *))(*(void *)v3 + 88LL))(v3, buf, __p, &v46);
  if (v45 < 0) {
    operator delete(__p[0]);
  }
  if (v53 < 0)
  {
    operator delete(*(void **)buf);
    if (!v4) {
      goto LABEL_13;
    }
  }

  else if (!v4)
  {
    goto LABEL_13;
  }

  int v5 = v46;
  int v6 = (os_log_s *)qword_1008F75A0;
  if (v46 < 1)
  {
    if (os_log_type_enabled((os_log_t)qword_1008F75A0, OS_LOG_TYPE_ERROR)) {
      sub_10069ABD8();
    }
  }

  else
  {
    if (os_log_type_enabled((os_log_t)qword_1008F75A0, OS_LOG_TYPE_DEFAULT))
    {
      *(_DWORD *)std::stringbuf::string_type buf = 67109120;
      *(_DWORD *)&uint8_t buf[4] = v5;
      _os_log_impl( (void *)&_mh_execute_header,  v6,  OS_LOG_TYPE_DEFAULT,  "Warning: Using override value (%d) for max number of devices to be cached in memory",  buf,  8u);
      int v5 = v46;
    }

    *(_DWORD *)(a1 + 144) = v5;
  }

void sub_1005C68C0( _Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, void *__p, uint64_t a10, int a11, __int16 a12, char a13, char a14)
{
  unsigned __int8 v21 = *v19;
  if (*v19)
  {
    *(void *)(v14 + 272) = v21;
    operator delete(v21);
  }

  sub_10023BF24(v17, *(void **)(v14 + 224));
  sub_10023DF50(v18);
  sub_10023BF24(v16, *(void **)(v14 + 176));

  sub_100242E28(v15);
  _Unwind_Resume(a1);
}

uint64_t sub_1005C69FC(uint64_t a1, void *a2, void *a3)
{
  id v5 = a2;
  id v6 = a3;
  v11[0] = 0LL;
  v11[1] = 0LL;
  sub_100242F28((uint64_t)v11, a1 + 80);
  int v7 = sub_1005C6AC0(a1, v5);
  uint64_t v8 = (uint64_t)v7;
  if (v7)
  {
    [*(id *)(a1 + 248) addObject:v5];
    LODWORD(v7) = sub_1005C1518(v8, v6);
  }

  if (v8) {
    uint64_t v9 = v7;
  }
  else {
    uint64_t v9 = 3LL;
  }
  sub_100242FAC((uint64_t)v11);

  return v9;
}

void sub_1005C6A9C(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void *sub_1005C6AC0(uint64_t a1, void *a2)
{
  id v3 = a2;
  v12[0] = 0LL;
  v12[1] = 0LL;
  sub_100242F28((uint64_t)v12, a1 + 80);
  if (!v3)
  {
    int v4 = (os_log_s *)qword_1008F75A0;
    if (os_log_type_enabled((os_log_t)qword_1008F75A0, OS_LOG_TYPE_FAULT)) {
      sub_10069AC38(v4, v5, v6);
    }
  }

  int v7 = [*(id *)(a1 + 160) objectForKey:v3];
  if (v7)
  {
    sub_100241F90(buf, v3);
    sub_1005D10D4(a1, buf);
  }

  else
  {
    sub_100242F54((uint64_t)v12);
    int v7 = (void *)sub_1002DCB1C(*(void *)(a1 + 240), v3);
    if (v7)
    {
      uint64_t v8 = (os_log_s *)qword_1008F75A0;
      if (os_log_type_enabled((os_log_t)qword_1008F75A0, OS_LOG_TYPE_INFO))
      {
        id v9 = sub_1005BFB9C(v7[2]);
        int v10 = (void *)objc_claimAutoreleasedReturnValue(v9);
        *(_DWORD *)std::stringbuf::string_type buf = 138543618;
        id v14 = v3;
        __int16 v15 = 2114;
        uint64_t v16 = v10;
        _os_log_impl( (void *)&_mh_execute_header,  v8,  OS_LOG_TYPE_INFO,  "Device %{public}@ was on disk with address %{public}@",  buf,  0x16u);
      }

      sub_100242ECC((uint64_t)v12);
      sub_1005D00CC(a1, (uint64_t)v7);
    }
  }

  sub_100242FAC((uint64_t)v12);

  return v7;
}

void sub_1005C6C40( _Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9)
{
  _Unwind_Resume(a1);
}

id sub_1005C6C74(uint64_t a1)
{
  v13[0] = 0LL;
  v13[1] = 0LL;
  sub_100242F28((uint64_t)v13, a1 + 80);
  uint64_t v2 = (void *)objc_claimAutoreleasedReturnValue(+[NSMutableArray array](&OBJC_CLASS___NSMutableArray, "array"));
  __int128 v11 = 0u;
  __int128 v12 = 0u;
  __int128 v9 = 0u;
  __int128 v10 = 0u;
  id v3 = *(id *)(a1 + 248);
  id v4 = [v3 countByEnumeratingWithState:&v9 objects:v14 count:16];
  if (v4)
  {
    uint64_t v5 = *(void *)v10;
    do
    {
      for (uint64_t i = 0LL; i != v4; uint64_t i = (char *)i + 1)
      {
        if (*(void *)v10 != v5) {
          objc_enumerationMutation(v3);
        }
        uint64_t v7 = *(void *)(*((void *)&v9 + 1) + 8LL * (void)i);
        if (*((void *)objc_msgSend(*(id *)(a1 + 160), "objectForKey:", v7, (void)v9) + 8)) {
          [v2 addObject:v7];
        }
      }

      id v4 = [v3 countByEnumeratingWithState:&v9 objects:v14 count:16];
    }

    while (v4);
  }

  sub_100242FAC((uint64_t)v13);
  return v2;
}

void sub_1005C6DB4( _Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, ...)
{
  sub_100242FAC((uint64_t)va);
  _Unwind_Resume(a1);
}

void sub_1005C6DEC(uint64_t a1, void *a2)
{
  id v3 = a2;
  v5[0] = 0LL;
  v5[1] = 0LL;
  sub_100242F28((uint64_t)v5, a1 + 80);
  id v4 = [*(id *)(a1 + 160) objectForKey:v3];
  if (v4) {
    sub_1005C6E68((uint64_t)v4);
  }
  sub_100242FAC((uint64_t)v5);
}

void sub_1005C6E48(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_1005C6E68(uint64_t a1)
{
  if (*(void *)(a1 + 88) && *(void *)(a1 + 80))
  {
    uint64_t v2 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(*(id *)(a1 + 72), "objectForKeyedSubscript:"));
    id v7 = [v2 mutableCopy];

    [v7 removeObject:*(void *)(a1 + 88)];
    id v3 = [v7 count];
    id v4 = *(void **)(a1 + 72);
    if (v3) {
      [v4 setObject:v7 forKeyedSubscript:*(void *)(a1 + 80)];
    }
    else {
      [v4 removeObjectForKey:*(void *)(a1 + 80)];
    }
    uint64_t v5 = *(void **)(a1 + 88);
    *(void *)(a1 + 88) = 0LL;

    uint64_t v6 = *(void **)(a1 + 80);
    *(void *)(a1 + 80) = 0LL;
  }

void sub_1005C6F1C(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

id sub_1005C6F3C(uint64_t a1, void *a2)
{
  id v3 = a2;
  if (qword_1008F1E80 != -1) {
    dispatch_once(&qword_1008F1E80, &stru_1008A32F0);
  }
  v21[0] = 0LL;
  v21[1] = 0LL;
  sub_100242F28((uint64_t)v21, a1 + 80);
  id v4 = sub_1005C6AC0(a1, v3);
  uint64_t v5 = (uint64_t)v4;
  if (v4)
  {
    id v6 = (id)v4[8];
    if (v6)
    {
      if (*(_BYTE *)(v5 + 164)) {
        unint64_t v7 = *(void *)(v5 + 56);
      }
      else {
        unint64_t v7 = 0LL;
      }
      id v9 = sub_1005C0604(v7);
      __int128 v10 = (void *)objc_claimAutoreleasedReturnValue(v9);
      id v11 = *(id *)(v5 + 72);
      __int128 v12 = (os_log_s *)qword_1008F75A0;
      if (os_log_type_enabled((os_log_t)qword_1008F75A0, OS_LOG_TYPE_INFO))
      {
        uint64_t v13 = CUPrintNSObjectOneLine(v11);
        id v14 = (void *)objc_claimAutoreleasedReturnValue(v13);
        *(_DWORD *)std::stringbuf::string_type buf = 141558275;
        uint64_t v23 = 1752392040LL;
        __int16 v24 = 2113;
        id v25 = v14;
        _os_log_impl( (void *)&_mh_execute_header,  v12,  OS_LOG_TYPE_INFO,  "getFindMyDeviceLTK findMyEncryptionDictionary:%{private, mask.hash}@",  buf,  0x16u);
      }

      __int16 v15 = (void *)objc_claimAutoreleasedReturnValue([v11 objectForKeyedSubscript:v10]);
      if ([v15 count])
      {
        uint64_t v16 = (void *)objc_claimAutoreleasedReturnValue([v15 objectAtIndexedSubscript:0]);
        uint64_t v17 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(v16, "subdataWithRange:", 0, 16));
        id v8 = [v17 mutableCopy];

        if (byte_1008F1E78)
        {
          __int16 v31 = 0;
          uint64_t v30 = 0LL;
          objc_msgSend(v8, "replaceBytesInRange:withBytes:", 1, 10, &v30);
          char v18 = (os_log_s *)qword_1008F75A0;
          if (os_log_type_enabled((os_log_t)qword_1008F75A0, OS_LOG_TYPE_INFO))
          {
            *(_DWORD *)std::stringbuf::string_type buf = 141558275;
            uint64_t v23 = 1752392040LL;
            __int16 v24 = 2113;
            id v25 = v8;
            _os_log_impl( (void *)&_mh_execute_header,  v18,  OS_LOG_TYPE_INFO,  "BAD LTK:%{private, mask.hash}@",  buf,  0x16u);
          }
        }

        unsigned __int8 v19 = (os_log_s *)qword_1008F75A0;
        if (os_log_type_enabled((os_log_t)qword_1008F75A0, OS_LOG_TYPE_INFO))
        {
          *(_DWORD *)std::stringbuf::string_type buf = 141558787;
          uint64_t v23 = 1752392040LL;
          __int16 v24 = 2113;
          id v25 = v10;
          __int16 v26 = 2160;
          uint64_t v27 = 1752392040LL;
          __int16 v28 = 2113;
          id v29 = v8;
          _os_log_impl( (void *)&_mh_execute_header,  v19,  OS_LOG_TYPE_INFO,  "getFindMyDeviceLTK sessionKey:%{private, mask.hash}@ --> %{private, mask.hash}@",  buf,  0x2Au);
        }

        sub_1005C737C(v5, v10, v8);
      }

      else
      {
        id v8 = 0LL;
      }
    }

    else
    {
      id v8 = 0LL;
    }
  }

  else
  {
    id v8 = 0LL;
  }

  sub_100242FAC((uint64_t)v21);

  return v8;
}

void sub_1005C7244( _Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9)
{
  sub_100242FAC((uint64_t)&a9);
  _Unwind_Resume(a1);
}

void sub_1005C72C0(id a1)
{
  uint64_t v1 = sub_1002E6E00();
  sub_10002418C(v4, "FindMy");
  sub_10002418C(__p, "ForceCorruptLTK");
  (*(void (**)(uint64_t, void **, void **, char *))(*(void *)v1 + 72LL))(v1, v4, __p, &byte_1008F1E78);
  if (v3 < 0) {
    operator delete(__p[0]);
  }
  if (v5 < 0) {
    operator delete(v4[0]);
  }
}

void sub_1005C7348( _Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, void *__p, uint64_t a10, int a11, __int16 a12, char a13, char a14, void *a15, uint64_t a16, int a17, __int16 a18, char a19, char a20)
{
  if (a14 < 0) {
    operator delete(__p);
  }
  if (a20 < 0) {
    operator delete(a15);
  }
  _Unwind_Resume(exception_object);
}

void sub_1005C737C(uint64_t a1, void *a2, void *a3)
{
  id v5 = a2;
  objc_storeStrong((id *)(a1 + 88), a3);
  id v7 = a3;
  id v6 = *(void **)(a1 + 80);
  *(void *)(a1 + 80) = v5;
}

void sub_1005C73D8(uint64_t a1, void *a2)
{
  id v3 = a2;
  uint64_t v4 = sub_100404FE8();
  v6[0] = _NSConcreteStackBlock;
  v6[1] = 3221225472LL;
  void v6[2] = sub_1005C7488;
  uint64_t v6[3] = &unk_1008800B8;
  uint64_t v8 = a1;
  id v5 = v3;
  id v7 = v5;
  sub_100405384(v4, v6);
}

void sub_1005C7468( _Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, void *a13)
{
  _Unwind_Resume(a1);
}

void sub_1005C7488(uint64_t a1)
{
  uint64_t v102 = *(void *)(a1 + 40);
  id v2 = sub_1005C6C74(v102);
  id v3 = (void *)objc_claimAutoreleasedReturnValue(v2);
  id v92 = [v3 mutableCopy];

  uint64_t v133 = 0LL;
  v132 = 0LL;
  v131 = (uint64_t *)&v132;
  __int128 v127 = 0u;
  __int128 v128 = 0u;
  __int128 v129 = 0u;
  __int128 v130 = 0u;
  id obj = *(id *)(a1 + 32);
  id v95 = [obj countByEnumeratingWithState:&v127 objects:v144 count:16];
  if (v95)
  {
    id v5 = (void *)(v102 + 176);
    uint64_t v94 = *(void *)v128;
    *(void *)&__int128 v4 = 141558531LL;
    __int128 v91 = v4;
    do
    {
      for (uint64_t i = 0LL; i != v95; uint64_t i = (char *)i + 1)
      {
        if (*(void *)v128 != v94) {
          objc_enumerationMutation(obj);
        }
        id v6 = *(void **)(*((void *)&v127 + 1) + 8LL * (void)i);
        id v7 = (os_log_s *)qword_1008F75A0;
        if (os_log_type_enabled((os_log_t)qword_1008F75A0, OS_LOG_TYPE_DEFAULT))
        {
          LODWORD(buf.__r_.__value_.__l.__data_) = 141558275;
          *(std::string::size_type *)((char *)buf.__r_.__value_.__r.__words + 4) = 1752392040LL;
          WORD2(buf.__r_.__value_.__r.__words[1]) = 2113;
          *(std::string::size_type *)((char *)&buf.__r_.__value_.__r.__words[1] + 6) = (std::string::size_type)v6;
          _os_log_impl( (void *)&_mh_execute_header,  v7,  OS_LOG_TYPE_DEFAULT,  "SPOwner peripheral updated %{private, mask.hash}@",  (uint8_t *)&buf,  0x16u);
        }

        int v98 = v6;
        uint64_t v8 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(v6, "longTermKeyMap", v91));
        BOOL v9 = [v8 count] == 0;

        if (v9)
        {
          uint64_t v27 = (os_log_s *)qword_1008F75A0;
          if (os_log_type_enabled((os_log_t)qword_1008F75A0, OS_LOG_TYPE_ERROR)) {
            sub_10069ACAC(&v125, v126, v27);
          }
        }

        else
        {
          __int16 v96 = objc_opt_new(&OBJC_CLASS___NSMutableSet);
          __int128 v10 = (void *)objc_claimAutoreleasedReturnValue([v98 lastConnectedLEMAC]);
          BOOL v11 = v10 == 0LL;

          if (!v11)
          {
            __int128 v12 = (void *)objc_claimAutoreleasedReturnValue([v98 lastConnectedLEMAC]);
            -[NSMutableSet addObject:](v96, "addObject:", v12);
          }

          uint64_t v13 = (void *)objc_claimAutoreleasedReturnValue([v98 longTermKeyMap]);
          BOOL v14 = [v13 count] == 0;

          if (!v14)
          {
            __int16 v15 = (void *)objc_claimAutoreleasedReturnValue([v98 longTermKeyMap]);
            uint64_t v16 = (void *)objc_claimAutoreleasedReturnValue([v15 allKeys]);
            -[NSMutableSet addObjectsFromArray:](v96, "addObjectsFromArray:", v16);
          }

          if (-[NSMutableSet count](v96, "count"))
          {
            *(void *)uuid_t uu = 0LL;
            uint64_t v143 = 0LL;
            uint64_t v17 = (void *)objc_claimAutoreleasedReturnValue([v98 beaconIdentifier]);
            id v18 = sub_1005C84B8(v102, v17);
            unsigned __int8 v19 = (void *)objc_claimAutoreleasedReturnValue(v18);
            sub_100241F90(uu, v19);

            if (!uuid_is_null(uu)) {
              goto LABEL_46;
            }
            int v20 = (void *)objc_claimAutoreleasedReturnValue([v98 lastConnectedLEMAC]);
            unint64_t v21 = sub_1005C04DC(v20);

            if (v21)
            {
              sub_1005C8684(v102, v21, 0, 1u, 0LL, 0LL, (unsigned __int8 *)&buf);
              uuid_copy(uu, (const unsigned __int8 *)&buf);
            }

            if (uuid_is_null(uu))
            {
              __int128 v121 = 0u;
              __int128 v122 = 0u;
              __int128 v119 = 0u;
              __int128 v120 = 0u;
              char v22 = (void *)objc_claimAutoreleasedReturnValue([v98 longTermKeyMap]);
              id v23 = [v22 countByEnumeratingWithState:&v119 objects:v141 count:16];
              if (v23)
              {
                uint64_t v24 = *(void *)v120;
                while (2)
                {
                  for (j = 0LL; j != v23; j = (char *)j + 1)
                  {
                    if (*(void *)v120 != v24) {
                      objc_enumerationMutation(v22);
                    }
                    unint64_t v26 = sub_1005C04DC(*(void **)(*((void *)&v119 + 1) + 8LL * (void)j));
                    *(_OWORD *)&buf.__r_.__value_.__l.__data_ = 0uLL;
                    sub_1005C8684(v102, v26, 0, 1u, 0LL, 0LL, (unsigned __int8 *)&buf);
                    if (!uuid_is_null((const unsigned __int8 *)&buf))
                    {
                      uuid_copy(uu, (const unsigned __int8 *)&buf);
                      goto LABEL_32;
                    }
                  }

                  id v23 = [v22 countByEnumeratingWithState:&v119 objects:v141 count:16];
                  if (v23) {
                    continue;
                  }
                  break;
                }
              }

void sub_1005C8270( _Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, void *a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20, uint64_t a21, uint64_t a22, uint64_t a23, uint64_t a24, uint64_t a25, uint64_t a26, uint64_t a27, uint64_t a28, uint64_t a29, uint64_t a30, uint64_t a31, uint64_t a32, uint64_t a33, uint64_t a34, uint64_t a35, uint64_t a36, uint64_t a37, uint64_t a38, uint64_t a39, uint64_t a40, char a41, uint64_t a42)
{
  _Unwind_Resume(a1);
}

id sub_1005C84B8(uint64_t a1, void *a2)
{
  id v3 = a2;
  v20[0] = 0LL;
  v20[1] = 0LL;
  sub_100242F28((uint64_t)v20, a1 + 80);
  __int128 v18 = 0u;
  __int128 v19 = 0u;
  __int128 v16 = 0u;
  __int128 v17 = 0u;
  id v4 = *(id *)(a1 + 248);
  id v5 = [v4 countByEnumeratingWithState:&v16 objects:v21 count:16];
  if (v5)
  {
    uint64_t v6 = *(void *)v17;
    while (2)
    {
      for (uint64_t i = 0LL; i != v5; uint64_t i = (char *)i + 1)
      {
        if (*(void *)v17 != v6) {
          objc_enumerationMutation(v4);
        }
        uint64_t v8 = *(void **)(*((void *)&v16 + 1) + 8LL * (void)i);
        BOOL v9 = (id *)objc_msgSend(*(id *)(a1 + 160), "objectForKey:", v8, (void)v16);
        if (v9)
        {
          id v10 = v9[8];
          BOOL v11 = v10;
          if (v10)
          {
            __int128 v12 = (void *)objc_claimAutoreleasedReturnValue([v10 beaconIdentifier]);
            unsigned __int8 v13 = [v12 isEqual:v3];

            if ((v13 & 1) != 0)
            {
              id v14 = v8;

              goto LABEL_14;
            }
          }
        }
      }

      id v5 = [v4 countByEnumeratingWithState:&v16 objects:v21 count:16];
      if (v5) {
        continue;
      }
      break;
    }
  }

  id v14 = 0LL;
LABEL_14:

  sub_100242FAC((uint64_t)v20);
  return v14;
}

void sub_1005C8634( _Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, ...)
{
  sub_100242FAC((uint64_t)va);
  _Unwind_Resume(a1);
}

void sub_1005C8684( uint64_t a1@<X0>, unint64_t a2@<X1>, unsigned int a3@<W2>, unsigned int a4@<W3>, void *a5@<X4>, __int128 *a6@<X5>, unsigned __int8 *a7@<X8>)
{
  unint64_t v71 = __PAIR64__(a3, a4);
  uuid_t uu = a7;
  id v74 = a5;
  v86[0] = 0LL;
  v86[1] = 0LL;
  sub_100242F28((uint64_t)v86, a1 + 80);
  unint64_t v73 = a2;
  if (!a2)
  {
    if (os_log_type_enabled((os_log_t)qword_1008F75A0, OS_LOG_TYPE_FAULT)) {
      sub_10069AD5C();
    }
    goto LABEL_12;
  }

  if (BYTE6(a2) && (BYTE6(a2) != 1 || (a2 & 0xC00000000000LL) == 0x800000000000LL))
  {
LABEL_12:
    BOOL v9 = (os_log_s *)qword_1008F75A0;
    if (os_log_type_enabled((os_log_t)qword_1008F75A0, OS_LOG_TYPE_ERROR))
    {
      id v10 = sub_1005BFB9C(v73);
      BOOL v11 = (void *)objc_claimAutoreleasedReturnValue(v10);
      sub_10069AD14(v11, (uint64_t)&__p, v9);
    }

    goto LABEL_14;
  }

  if (HIDWORD(v71))
  {
    if (v74 && (v71 & 1) == 0)
    {
LABEL_8:
      if (os_log_type_enabled((os_log_t)qword_1008F75A0, OS_LOG_TYPE_ERROR)) {
        sub_10069AEE4();
      }
LABEL_14:
      uuid_clear(uu);
      goto LABEL_15;
    }
  }

  else if (v74)
  {
    goto LABEL_8;
  }

  if (a6)
  {
    unsigned __int16 v75 = objc_opt_new(&OBJC_CLASS___NSMutableSet);
    __int128 v84 = 0u;
    __int128 v85 = 0u;
    __int128 v82 = 0u;
    __int128 v83 = 0u;
    id v12 = *(id *)(a1 + 160);
    id v13 = [v12 countByEnumeratingWithState:&v82 objects:v96 count:16];
    if (v13)
    {
      uint64_t v14 = *(void *)v83;
      do
      {
        for (uint64_t i = 0LL; i != v13; uint64_t i = (char *)i + 1)
        {
          if (*(void *)v83 != v14) {
            objc_enumerationMutation(v12);
          }
          __int128 v16 = (id *)objc_msgSend( *(id *)(a1 + 160),  "objectForKey:",  *(void *)(*((void *)&v82 + 1) + 8 * (void)i),  v71,  uu);
          __int128 v17 = v16;
          if (!v16[3])
          {
            *(_DWORD *)&dst[3] = 0;
            *(_DWORD *)uuid_t dst = 0;
            uint64_t v18 = sub_1001BCDB0((unint64_t)v16[2]);
            *(_DWORD *)uuid_t dst = v18;
            dst[6] = BYTE6(v18);
            *(_WORD *)&dst[4] = WORD2(v18);
            if (sub_1001C924C((uint64_t)dst, a6))
            {
              __int128 v19 = (os_log_s *)qword_1008F75A0;
              if (os_log_type_enabled((os_log_t)qword_1008F75A0, OS_LOG_TYPE_DEFAULT))
              {
                sub_1005BFC20((uint64_t)v17[2], &__p);
                if ((__p.__r_.__value_.__s.__size_ & 0x80u) == 0) {
                  p_p = &__p;
                }
                else {
                  p_p = (std::stringbuf::string_type *)__p.__r_.__value_.__r.__words[0];
                }
                id v21 = *v17;
                *(_DWORD *)std::stringbuf::string_type buf = 136315394;
                __int16 v93 = p_p;
                __int16 v94 = 2112;
                id v95 = v21;
                _os_log_impl( (void *)&_mh_execute_header,  v19,  OS_LOG_TYPE_DEFAULT,  "Removing previous instances of cloud device with address:%s UUID:%@ from device cache",  buf,  0x16u);
              }

              id v22 = *v17;
              -[NSMutableSet addObject:](v75, "addObject:", v22);
            }
          }
        }

        id v13 = [v12 countByEnumeratingWithState:&v82 objects:v96 count:16];
      }

      while (v13);
    }

    __int128 v80 = 0u;
    __int128 v81 = 0u;
    __int128 v78 = 0u;
    __int128 v79 = 0u;
    id v23 = v75;
    id v24 = -[NSMutableSet countByEnumeratingWithState:objects:count:]( v23,  "countByEnumeratingWithState:objects:count:",  &v78,  v90,  16LL);
    if (v24)
    {
      uint64_t v25 = *(void *)v79;
      do
      {
        for (j = 0LL; j != v24; j = (char *)j + 1)
        {
          if (*(void *)v79 != v25) {
            objc_enumerationMutation(v23);
          }
          sub_1005C91A4(a1, *(void **)(*((void *)&v78 + 1) + 8LL * (void)j));
        }

        id v24 = -[NSMutableSet countByEnumeratingWithState:objects:count:]( v23,  "countByEnumeratingWithState:objects:count:",  &v78,  v90,  16LL);
      }

      while (v24);
    }

    -[NSMutableSet removeAllObjects](v23, "removeAllObjects");
    uint64_t v27 = sub_1002DCC34(*(void *)(a1 + 240), v73);
    if (v27)
    {
      sub_1002DCF3C(*(void *)(a1 + 240), v27);
      __int16 v28 = (void *)sub_1005DC5C8(v27);
      operator delete(v28);
    }
  }

  *(void *)uuid_t dst = 0LL;
  uint64_t v89 = 0LL;
  sub_1005D0D84(a1, v73, dst);
  if (!uuid_is_null(dst)
    || (sub_1005D0F38(a1, v73, (unsigned __int8 *)&__p),
        uuid_copy(dst, (const unsigned __int8 *)&__p),
        !uuid_is_null(dst)))
  {
    uuid_copy(uu, dst);
    goto LABEL_15;
  }

  id v29 = *(void **)(a1 + 176);
  if (v29)
  {
    uint64_t v30 = a1 + 176;
    do
    {
      unint64_t v31 = v29[4];
      BOOL v32 = v31 >= v73;
      if (v31 >= v73) {
        uint64_t v33 = v29;
      }
      else {
        uint64_t v33 = v29 + 1;
      }
      if (v32) {
        uint64_t v30 = (uint64_t)v29;
      }
      id v29 = (void *)*v33;
    }

    while (*v33);
    if (v30 != a1 + 176 && *(void *)(v30 + 32) <= v73)
    {
      if (!v74)
      {
        sub_1005D10D4(a1, (unsigned __int8 *)(v30 + 40));
        uuid_copy(uu, (const unsigned __int8 *)(v30 + 40));
        goto LABEL_15;
      }

      if (os_log_type_enabled((os_log_t)qword_1008F75A0, OS_LOG_TYPE_ERROR))
      {
        id v58 = sub_1005BFB9C(v73);
        id v59 = (id)objc_claimAutoreleasedReturnValue(v58);
        sub_100366664((const unsigned __int8 *)(v30 + 40), &__p);
        sub_10069AE98();
      }

      goto LABEL_86;
    }
  }

  if (*(_BYTE *)(a1 + 156)) {
    BOOL v34 = 1;
  }
  else {
    BOOL v34 = (_DWORD)v71 == 0;
  }
  if (v34) {
    goto LABEL_63;
  }
  uint64_t v42 = sub_1002E6BF0();
  int v43 = (*(uint64_t (**)(uint64_t))(*(void *)v42 + 432LL))(v42);
  id v44 = (os_log_s *)qword_1008F75A0;
  BOOL v45 = os_log_type_enabled((os_log_t)qword_1008F75A0, OS_LOG_TYPE_DEFAULT);
  if (!v43)
  {
    if (v45)
    {
      id v56 = sub_1005BFB9C(v73);
      uint64_t v57 = (void *)objc_claimAutoreleasedReturnValue(v56);
      LODWORD(__p.__r_.__value_.__l.__data_) = 138543362;
      *(std::string::size_type *)((char *)__p.__r_.__value_.__r.__words + 4) = (std::string::size_type)v57;
      _os_log_impl( (void *)&_mh_execute_header,  v44,  OS_LOG_TYPE_DEFAULT,  "Ignoring non-paired device address %{public}@ as the protected cache has not been loaded",  (uint8_t *)&__p,  0xCu);
    }

void sub_1005C905C( _Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, void *a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20, uint64_t a21, uint64_t a22, uint64_t a23, uint64_t a24, uint64_t a25, uint64_t a26, uint64_t a27, uint64_t a28, uint64_t a29, uint64_t a30, uint64_t a31, uint64_t a32, uint64_t a33, uint64_t a34, uint64_t a35, uint64_t a36, char a37)
{
  sub_100242FAC((uint64_t)&a37);
  _Unwind_Resume(a1);
}

void sub_1005C91A4(uint64_t a1, void *a2)
{
  id v3 = a2;
  id v4 = (os_log_s *)qword_1008F75A0;
  if (os_log_type_enabled((os_log_t)qword_1008F75A0, OS_LOG_TYPE_DEFAULT))
  {
    *(_DWORD *)std::stringbuf::string_type buf = 138543362;
    *(void *)&uint8_t buf[4] = v3;
    _os_log_impl( (void *)&_mh_execute_header,  v4,  OS_LOG_TYPE_DEFAULT,  "Clearing all records of device %{public}@",  buf,  0xCu);
  }

  v22[0] = 0LL;
  v22[1] = 0LL;
  sub_100242F28((uint64_t)v22, a1 + 80);
  id v5 = [*(id *)(a1 + 160) objectForKey:v3];
  uint64_t v6 = (uint64_t)v5;
  if (v5)
  {
    if (v5[164])
    {
      id v7 = (os_log_s *)qword_1008F75A0;
      if (os_log_type_enabled((os_log_t)qword_1008F75A0, OS_LOG_TYPE_DEFAULT))
      {
        *(_DWORD *)std::stringbuf::string_type buf = 138412290;
        *(void *)&uint8_t buf[4] = v3;
        _os_log_impl( (void *)&_mh_execute_header,  v7,  OS_LOG_TYPE_DEFAULT,  "Device %@ is pending delete but still connected, wait for a complete disconnection",  buf,  0xCu);
      }

      *(_BYTE *)(v6 + 488) = 1;
    }

    else
    {
      [*(id *)(a1 + 160) removeObjectForKey:v3];
      *(void *)std::string uu2 = 0LL;
      uint64_t v26 = 0LL;
      sub_100241F90(uu2, v3);
      uint64_t v8 = (unsigned __int8 *)(a1 + 192);
      for (uint64_t i = *(unsigned __int8 **)(a1 + 200); i != v8; uint64_t i = (unsigned __int8 *)*((void *)i + 1))
      {
        if (!uuid_compare(i + 16, uu2))
        {
          if (i != v8)
          {
            uint64_t v10 = *(void *)i;
            *(void *)(v10 + 8) = *((void *)i + 1);
            **((void **)i + 1) = v10;
            --*(void *)(a1 + 208);
            operator delete(i);
          }

          break;
        }
      }

      [*(id *)(a1 + 248) removeObject:v3];
      *(void *)std::stringbuf::string_type buf = *(void *)(v6 + 24);
      sub_10020166C(a1 + 168, (unint64_t *)buf);
      *(void *)std::stringbuf::string_type buf = *(void *)(v6 + 16);
      sub_10020166C(a1 + 168, (unint64_t *)buf);
      sub_1002DCF3C(*(void *)(a1 + 240), v6);
      sub_1005C2558(v6, 0, 0LL, 0);
      BOOL v11 = (void *)sub_1005DC5C8(v6);
      operator delete(v11);
      id v12 = (os_log_s *)qword_1008F75A0;
      if (os_log_type_enabled((os_log_t)qword_1008F75A0, OS_LOG_TYPE_INFO))
      {
        *(_DWORD *)std::stringbuf::string_type buf = 138412290;
        *(void *)&uint8_t buf[4] = v3;
        _os_log_impl((void *)&_mh_execute_header, v12, OS_LOG_TYPE_INFO, "Device %@ deleted", buf, 0xCu);
      }

      *(_OWORD *)std::stringbuf::string_type buf = 0u;
      __int128 v24 = 0u;
      *(_DWORD *)std::stringbuf::string_type buf = *(_DWORD *)(a1 + 256);
      sub_100240540(&buf[8], a1 + 264);
      v18._uint64_t os_unfair_lock_opaque = *(_DWORD *)buf;
      __uuid_t dst = 0LL;
      uint64_t v21 = 0LL;
      std::stringbuf::string_type __p = 0LL;
      id v13 = *(const void **)&buf[8];
      int64_t v14 = v24 - *(void *)&buf[8];
      if ((void)v24 != *(void *)&buf[8])
      {
        sub_10023DBC8(&__p, v14 >> 3);
        __int16 v15 = (char *)__dst;
        memmove(__dst, v13, v14);
        __uuid_t dst = &v15[8 * (v14 >> 3)];
      }

      v16[0] = _NSConcreteStackBlock;
      v16[1] = 3221225472LL;
      void v16[2] = sub_1005D51A4;
      v16[3] = &unk_1008A33D0;
      id v17 = v3;
      sub_1005DC3A4(&v18, v16);
      if (__p)
      {
        __uuid_t dst = __p;
        operator delete(__p);
      }

      if (*(void *)&buf[8])
      {
        *(void *)&__int128 v24 = *(void *)&buf[8];
        operator delete(*(void **)&buf[8]);
      }
    }
  }

  sub_100242FAC((uint64_t)v22);
}

void sub_1005C94D8( _Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, void *a16, uint64_t a17, uint64_t a18, char a19, uint64_t a20, uint64_t a21, void *__p, uint64_t a23)
{
  if (__p)
  {
    a23 = (uint64_t)__p;
    operator delete(__p);
  }

  sub_100242FAC((uint64_t)&a19);

  _Unwind_Resume(a1);
}

uint64_t sub_1005C9550(uint64_t a1, unsigned __int8 *a2, uint64_t a3, int a4)
{
  v20[0] = 0LL;
  v20[1] = 0LL;
  sub_100242F28((uint64_t)v20, a1 + 80);
  uint64_t v8 = objc_autoreleasePoolPush();
  BOOL v9 = sub_100241F94(a2);
  uint64_t v10 = (void *)objc_claimAutoreleasedReturnValue(v9);
  BOOL v11 = sub_1005C6AC0(a1, v10);

  if (!v11)
  {
    uint64_t v12 = 0LL;
    goto LABEL_17;
  }

  else {
    std::string __p = *(std::string *)a3;
  }
  uint64_t v13 = sub_1005C08B0((uint64_t)v11, &__p, a4, 0);
  uint64_t v12 = v13;
  if (((char)__p.__r_.__value_.__s.__size_ & 0x80000000) == 0)
  {
    if (!(_DWORD)v13) {
      goto LABEL_11;
    }
    goto LABEL_10;
  }

  operator delete(__p.__r_.__value_.__l.__data_);
  if ((_DWORD)v12) {
LABEL_10:
  }
    sub_1005CB37C(a1, a2);
LABEL_11:
  int64_t v14 = sub_100241F94(a2);
  __int16 v15 = (void *)objc_claimAutoreleasedReturnValue(v14);
  if (*(char *)(a3 + 23) < 0)
  {
    sub_100024238(v17, *(void **)a3, *(void *)(a3 + 8));
  }

  else
  {
    *(_OWORD *)id v17 = *(_OWORD *)a3;
    uint64_t v18 = *(void *)(a3 + 16);
  }

  sub_1005D1A28(a1, v15, (unsigned __int8 *)v17);
  if (SHIBYTE(v18) < 0) {
    operator delete(v17[0]);
  }

LABEL_17:
  objc_autoreleasePoolPop(v8);
  sub_100242FAC((uint64_t)v20);
  return v12;
}

void sub_1005C96B8( _Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, void *__p, uint64_t a10, int a11, __int16 a12, char a13, char a14, uint64_t a15, void *a16, uint64_t a17, int a18, __int16 a19, char a20, char a21, uint64_t a22, char a23)
{
  sub_100242FAC((uint64_t)&a23);
  _Unwind_Resume(a1);
}

void sub_1005C971C(uint64_t a1)
{
  if (qword_1008D61A8 != -1) {
    dispatch_once(&qword_1008D61A8, &stru_1008A34B8);
  }
  sub_1003B423C(qword_1008D61A0 + 8, a1 + 8);
  if (qword_1008D5F20 != -1) {
    dispatch_once(&qword_1008D5F20, &stru_1008A34D8);
  }
  sub_1006225C0((void *)qword_1008D5F18, a1 + 16);
  if (qword_1008D60B0 != -1) {
    dispatch_once(&qword_1008D60B0, &stru_1008A34F8);
  }
  sub_1001FC5E4((uint64_t)off_1008D60A8 + 80, a1 + 24);
  if ((sub_1002DC560(*(void *)(a1 + 240), a1 + 32) & 1) == 0
    && os_log_type_enabled((os_log_t)qword_1008F75A0, OS_LOG_TYPE_ERROR))
  {
    sub_10069AF10();
  }

  sub_1002E8F6C();
  char v20 = 0;
  uint64_t v2 = sub_1002E6E00();
  sub_10002418C(v18, "Device");
  sub_10002418C(__p, "wipeIDCache");
  (*(void (**)(uint64_t, void **, void **, char *))(*(void *)v2 + 72LL))(v2, v18, __p, &v20);
  if (v17 < 0) {
    operator delete(__p[0]);
  }
  if (v19 < 0) {
    operator delete(v18[0]);
  }
  if (qword_1008D6198 != -1) {
    dispatch_once(&qword_1008D6198, &stru_1008A3518);
  }
  int v3 = sub_100447F04((uint64_t)off_1008D6190);
  if (v20) {
    int v4 = 1;
  }
  else {
    int v4 = v3;
  }
  if (v4 == 1)
  {
    __int128 v14 = 0u;
    __int128 v15 = 0u;
    __int128 v12 = 0u;
    __int128 v13 = 0u;
    id v5 = *(id *)(a1 + 160);
    id v6 = [v5 countByEnumeratingWithState:&v12 objects:v21 count:16];
    if (v6)
    {
      uint64_t v7 = *(void *)v13;
      do
      {
        for (uint64_t i = 0LL; i != v6; uint64_t i = (char *)i + 1)
        {
          if (*(void *)v13 != v7) {
            objc_enumerationMutation(v5);
          }
          sub_1005C9A38(a1, *(void **)(*((void *)&v12 + 1) + 8LL * (void)i), @"LeIdentificationHashExist");
        }

        id v6 = [v5 countByEnumeratingWithState:&v12 objects:v21 count:16];
      }

      while (v6);
    }
  }

  id v9 = sub_1002E9298();
  uint64_t v10 = (void *)objc_claimAutoreleasedReturnValue(v9);
  BOOL v11 = v10;
  if (v10) {
    [v10 setPeripheralsUpdatedCallback:&stru_1008A3330];
  }
}

void sub_1005C99DC( _Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, void *__p, uint64_t a18, int a19, __int16 a20, char a21, char a22, void *a23, uint64_t a24, int a25, __int16 a26, char a27, char a28)
{
  _Unwind_Resume(a1);
}

BOOL sub_1005C9A38(uint64_t a1, void *a2, void *a3)
{
  id v5 = a2;
  id v6 = a3;
  v34[0] = 0LL;
  v34[1] = 0LL;
  sub_100242F28((uint64_t)v34, a1 + 80);
  uint64_t v7 = sub_1005C6AC0(a1, v5);
  BOOL v8 = (BOOL)v7;
  if (!v7) {
    goto LABEL_26;
  }
  id v9 = (os_log_s *)qword_1008F75A0;
  if (os_log_type_enabled((os_log_t)qword_1008F75A0, OS_LOG_TYPE_DEFAULT))
  {
    sub_10002418C(__p, (char *)[v6 UTF8String]);
    uint64_t v10 = sub_100024098(v8 + 176, (const void **)__p);
    *(_DWORD *)std::stringbuf::string_type buf = 138543874;
    *(void *)&uint8_t buf[4] = v6;
    *(_WORD *)&_BYTE buf[12] = 2114;
    *(void *)&buf[14] = v5;
    *(_WORD *)&_BYTE buf[22] = 1024;
    *(_DWORD *)&uint8_t buf[24] = v8 + 184 != v10;
    _os_log_impl( (void *)&_mh_execute_header,  v9,  OS_LOG_TYPE_DEFAULT,  "Removing %{public}@ tag from device %{public}@ hasTag:%d",  buf,  0x1Cu);
    if (v33 < 0) {
      operator delete(__p[0]);
    }
  }

  id v11 = v6;
  sub_10002418C(v30, (char *)[v11 UTF8String]);
  __int128 v12 = (uint64_t **)(v8 + 176);
  uint64_t v13 = sub_1002EE40C((uint64_t **)(v8 + 176), (const void **)v30);
  uint64_t v14 = v13;
  BOOL v8 = v13 != 0;
  if (v31 < 0)
  {
    operator delete(v30[0]);
    if (!v14) {
      goto LABEL_10;
    }
    goto LABEL_9;
  }

  if (v13)
  {
LABEL_9:
    sub_100241F90(buf, v5);
    sub_1005CB37C(a1, buf);
  }

void sub_1005C9E74( _Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, void *a15, uint64_t a16, uint64_t a17, void *__p, uint64_t a19, int a20, __int16 a21, char a22, char a23, uint64_t a24, uint64_t a25, int a26, __int16 a27, char a28, char a29, uint64_t a30, uint64_t a31, int a32, __int16 a33, char a34, char a35, char a36)
{
  _Unwind_Resume(a1);
}

void sub_1005C9F48(id a1, NSArray *a2)
{
  uint64_t v2 = a2;
  int v3 = (os_log_s *)qword_1008F75A0;
  if (os_log_type_enabled((os_log_t)qword_1008F75A0, OS_LOG_TYPE_DEFAULT))
  {
    int v4 = 141558275;
    uint64_t v5 = 1752392040LL;
    __int16 v6 = 2113;
    uint64_t v7 = v2;
    _os_log_impl( (void *)&_mh_execute_header,  v3,  OS_LOG_TYPE_DEFAULT,  "FindMy update %{private, mask.hash}@",  (uint8_t *)&v4,  0x16u);
  }

  if (qword_1008D5F30 != -1) {
    dispatch_once(&qword_1008D5F30, &stru_1008A3498);
  }
  sub_1005C73D8((uint64_t)off_1008D5F28, v2);
}

void sub_1005CA03C(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_1005CA054(uint64_t a1)
{
  if (qword_1008D60B0 != -1) {
    dispatch_once(&qword_1008D60B0, &stru_1008A34F8);
  }
  sub_100009168((uint64_t)off_1008D60A8 + 80, a1 + 24);
  if (qword_1008D5F20 != -1) {
    dispatch_once(&qword_1008D5F20, &stru_1008A34D8);
  }
  sub_100622704(qword_1008D5F18, a1 + 16);
  if (qword_1008D61A8 != -1) {
    dispatch_once(&qword_1008D61A8, &stru_1008A34B8);
  }
  sub_100009168(qword_1008D61A0 + 8, a1 + 8);
}

void sub_1005CA11C(uint64_t a1)
{
  uint64_t v2 = sub_100404FE8();
  v3[0] = _NSConcreteStackBlock;
  v3[1] = 3221225472LL;
  _DWORD v3[2] = sub_1005CA17C;
  v3[3] = &unk_10087EB20;
  v3[4] = a1;
  sub_100405384(v2, v3);
}

void sub_1005CA17C(uint64_t a1)
{
  uint64_t v1 = *(void *)(a1 + 32);
  id v2 = sub_1002E9298();
  int v3 = (void *)objc_claimAutoreleasedReturnValue(v2);
  if (v3)
  {
    int v4 = -[NSUUID initWithUUIDString:]( objc_alloc(&OBJC_CLASS___NSUUID),  "initWithUUIDString:",  @"FFFFEEEE-DDDD-CCCC-BBBB-AAAA00000000");
    uint64_t v5 = objc_alloc_init(&OBJC_CLASS___NSArray);
    [v3 startSessionForUserIdentifier:v4 bundleId:@"com.apple.bluetoothd" vendorIdentifierList:v5 completion:&stru_1008A3350];

    __int16 v6 = (os_log_s *)qword_1008F75A0;
    if (os_log_type_enabled((os_log_t)qword_1008F75A0, OS_LOG_TYPE_DEFAULT))
    {
      *(_WORD *)uint64_t v7 = 0;
      _os_log_impl((void *)&_mh_execute_header, v6, OS_LOG_TYPE_DEFAULT, "FindMy registration completed", v7, 2u);
    }
  }

  *(_BYTE *)(v1 + 289) = 1;
}

void sub_1005CA25C(_Unwind_Exception *a1)
{
  int v4 = v3;

  _Unwind_Resume(a1);
}

void sub_1005CA288(id a1, NSError *a2)
{
  int v3 = (os_log_s *)qword_1008F75A0;
  if (os_log_type_enabled((os_log_t)qword_1008F75A0, OS_LOG_TYPE_DEFAULT))
  {
    int v4 = 138412290;
    uint64_t v5 = a2;
    _os_log_impl( (void *)&_mh_execute_header,  v3,  OS_LOG_TYPE_DEFAULT,  "startSessionForUserIdentifier returned %@",  (uint8_t *)&v4,  0xCu);
  }

void sub_1005CA328(uint64_t a1)
{
  uint64_t v1 = a1 - 24;
  uint64_t v2 = sub_100404FE8();
  v3[0] = _NSConcreteStackBlock;
  v3[1] = 3221225472LL;
  _DWORD v3[2] = sub_1005CA17C;
  v3[3] = &unk_10087EB20;
  v3[4] = v1;
  sub_100405384(v2, v3);
}

uint64_t sub_1005CA388(uint64_t a1)
{
  uint64_t v2 = (os_log_s *)qword_1008F75A0;
  if (os_log_type_enabled((os_log_t)qword_1008F75A0, OS_LOG_TYPE_DEFAULT))
  {
    *(_WORD *)std::stringbuf::string_type buf = 0;
    _os_log_impl((void *)&_mh_execute_header, v2, OS_LOG_TYPE_DEFAULT, "LeDeviceManager::stackWillStop enter", buf, 2u);
  }

  *(void *)std::stringbuf::string_type buf = 0LL;
  uint64_t v23 = 0LL;
  sub_100242F28((uint64_t)buf, a1 + 80);
  uint64_t v3 = sub_100404FE8();
  v21[0] = _NSConcreteStackBlock;
  v21[1] = 3221225472LL;
  void v21[2] = sub_1005CA6AC;
  v21[3] = &unk_10087EB20;
  void v21[4] = a1;
  sub_100405384(v3, v21);
  id v4 = sub_1002E9298();
  uint64_t v5 = (void *)objc_claimAutoreleasedReturnValue(v4);
  if (v5)
  {
    if (qword_1008D5F30 != -1) {
      dispatch_once(&qword_1008D5F30, &stru_1008A3498);
    }
    id v6 = sub_1005C6C74((uint64_t)off_1008D5F28);
    __int128 v19 = 0u;
    __int128 v20 = 0u;
    __int128 v17 = 0u;
    __int128 v18 = 0u;
    id v7 = (id)objc_claimAutoreleasedReturnValue(v6);
    id v8 = [v7 countByEnumeratingWithState:&v17 objects:v24 count:16];
    if (v8)
    {
      uint64_t v9 = *(void *)v18;
      do
      {
        uint64_t v10 = 0LL;
        do
        {
          if (*(void *)v18 != v9) {
            objc_enumerationMutation(v7);
          }
          id v11 = *(void **)(*((void *)&v17 + 1) + 8LL * (void)v10);
          if (qword_1008D5F30 != -1) {
            dispatch_once(&qword_1008D5F30, &stru_1008A3498);
          }
          sub_1005C91A4((uint64_t)off_1008D5F28, v11);
          uint64_t v10 = (char *)v10 + 1;
        }

        while (v8 != v10);
        id v8 = [v7 countByEnumeratingWithState:&v17 objects:v24 count:16];
      }

      while (v8);
    }

    [*(id *)(a1 + 248) removeAllObjects];
    __int128 v12 = -[NSUUID initWithUUIDString:]( objc_alloc(&OBJC_CLASS___NSUUID),  "initWithUUIDString:",  @"FFFFEEEE-DDDD-CCCC-BBBB-AAAA00000000");
    [v5 stopSessionForUserIdentifier:v12 bundleId:@"com.apple.bluetoothd" completion:&stru_1008A3370];

    uint64_t v13 = (os_log_s *)qword_1008F75A0;
    if (os_log_type_enabled((os_log_t)qword_1008F75A0, OS_LOG_TYPE_DEFAULT))
    {
      *(_WORD *)int64_t v16 = 0;
      _os_log_impl((void *)&_mh_execute_header, v13, OS_LOG_TYPE_DEFAULT, "FindMy unregistration completed", v16, 2u);
    }
  }

  uint64_t v14 = (os_log_s *)qword_1008F75A0;
  if (os_log_type_enabled((os_log_t)qword_1008F75A0, OS_LOG_TYPE_DEFAULT))
  {
    *(_WORD *)int64_t v16 = 0;
    _os_log_impl((void *)&_mh_execute_header, v14, OS_LOG_TYPE_DEFAULT, "LeDeviceManager::stackWillStop exit", v16, 2u);
  }

  return sub_100242FAC((uint64_t)buf);
}

void sub_1005CA654( _Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, ...)
{
  sub_100242FAC((uint64_t)va);
  _Unwind_Resume(a1);
}

uint64_t sub_1005CA6AC(uint64_t result)
{
  *(_BYTE *)(*(void *)(result + 32) + 289LL) = 0;
  return result;
}

void sub_1005CA6B8(id a1, NSError *a2)
{
  uint64_t v3 = (os_log_s *)qword_1008F75A0;
  if (os_log_type_enabled((os_log_t)qword_1008F75A0, OS_LOG_TYPE_DEFAULT))
  {
    int v4 = 138412290;
    uint64_t v5 = a2;
    _os_log_impl( (void *)&_mh_execute_header,  v3,  OS_LOG_TYPE_DEFAULT,  "stopSessionForUserIdentifier returned %@",  (uint8_t *)&v4,  0xCu);
  }

uint64_t sub_1005CA758(uint64_t a1)
{
  return sub_1005CA388(a1 - 24);
}

void sub_1005CA760(uint64_t a1)
{
  __int128 v6 = 0u;
  __int128 v7 = 0u;
  __int128 v8 = 0u;
  __int128 v9 = 0u;
  id v2 = *(id *)(a1 + 160);
  id v3 = [v2 countByEnumeratingWithState:&v6 objects:v10 count:16];
  if (v3)
  {
    uint64_t v4 = *(void *)v7;
    do
    {
      uint64_t v5 = 0LL;
      do
      {
        if (*(void *)v7 != v4) {
          objc_enumerationMutation(v2);
        }
        sub_1005C3B68((uint64_t)objc_msgSend( *(id *)(a1 + 160),  "objectForKey:",  *(void *)(*((void *)&v6 + 1) + 8 * (void)v5),  (void)v6));
        uint64_t v5 = (char *)v5 + 1;
      }

      while (v3 != v5);
      id v3 = [v2 countByEnumeratingWithState:&v6 objects:v10 count:16];
    }

    while (v3);
  }
}

void sub_1005CA854(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_1005CA878(uint64_t a1)
{
}

uint64_t sub_1005CA880(uint64_t a1, uint64_t a2)
{
  v14[0] = 0LL;
  v14[1] = 0LL;
  sub_100242F28((uint64_t)v14, a1 + 80);
  __int128 v6 = *(uint64_t **)(a1 + 216);
  uint64_t v4 = (uint64_t **)(a1 + 216);
  uint64_t v5 = v6;
  if (v6 != (uint64_t *)(v4 + 1))
  {
    do
    {
      unint64_t v7 = v5[4];
      if (qword_1008D61A8 != -1) {
        dispatch_once(&qword_1008D61A8, &stru_1008A34B8);
      }
      uint64_t v8 = sub_10049729C(qword_1008D61A0, v7);
      __int128 v9 = (uint64_t *)v5[1];
      if (v8 == a2)
      {
        __int128 v12 = v5;
        if (v9)
        {
          do
          {
            uint64_t v10 = (uint64_t **)v9;
            __int128 v9 = (uint64_t *)*v9;
          }

          while (v9);
        }

        else
        {
          do
          {
            uint64_t v10 = (uint64_t **)v12[2];
            BOOL v11 = *v10 == v12;
            __int128 v12 = (uint64_t *)v10;
          }

          while (!v11);
        }

        sub_1001FDBCC(v4, v5);
        operator delete(v5);
        if (qword_1008D61A8 != -1) {
          dispatch_once(&qword_1008D61A8, &stru_1008A34B8);
        }
        sub_100497354(qword_1008D61A0, v7);
      }

      else if (v9)
      {
        do
        {
          uint64_t v10 = (uint64_t **)v9;
          __int128 v9 = (uint64_t *)*v9;
        }

        while (v9);
      }

      else
      {
        do
        {
          uint64_t v10 = (uint64_t **)v5[2];
          BOOL v11 = *v10 == v5;
          uint64_t v5 = (uint64_t *)v10;
        }

        while (!v11);
      }

      uint64_t v5 = (uint64_t *)v10;
    }

    while (v10 != v4 + 1);
  }

  return sub_100242FAC((uint64_t)v14);
}

void sub_1005CA9E4( _Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9)
{
}

uint64_t sub_1005CA9FC(uint64_t a1, uint64_t a2)
{
  return sub_1005CA880(a1 - 8, a2);
}

void sub_1005CAA04(uint64_t a1, char a2)
{
  uint64_t v4 = sub_100404FE8();
  v5[0] = _NSConcreteStackBlock;
  v5[1] = 3221225472LL;
  void v5[2] = sub_1005CAA6C;
  v5[3] = &unk_1008800D8;
  v5[4] = a1;
  char v6 = a2;
  sub_100405384(v4, v5);
}

void sub_1005CAA6C(uint64_t a1)
{
  *(_BYTE *)(*(void *)(a1 + 32) + 29sub_1005BF198(v1, 0LL) = *(_BYTE *)(a1 + 40);
  id v2 = (os_log_s *)qword_1008F75A0;
  if (os_log_type_enabled((os_log_t)qword_1008F75A0, OS_LOG_TYPE_DEFAULT))
  {
    int v3 = *(unsigned __int8 *)(a1 + 40);
    v4[0] = 67109120;
    v4[1] = v3;
    _os_log_impl( (void *)&_mh_execute_header,  v2,  OS_LOG_TYPE_DEFAULT,  "LeDeviceManager::screenStateChanged screenState:%d",  (uint8_t *)v4,  8u);
  }

void sub_1005CAB1C(uint64_t a1, char a2)
{
}

void sub_1005CAB24(uint64_t a1, char a2)
{
  uint64_t v4 = sub_100404FE8();
  v5[0] = _NSConcreteStackBlock;
  v5[1] = 3221225472LL;
  void v5[2] = sub_1005CAB8C;
  v5[3] = &unk_1008800D8;
  v5[4] = a1;
  char v6 = a2;
  sub_100405384(v4, v5);
}

void sub_1005CAB8C(uint64_t a1)
{
  *(_BYTE *)(*(void *)(a1 + 32) + 292LL) = *(_BYTE *)(a1 + 40);
  id v2 = (os_log_s *)qword_1008F75A0;
  if (os_log_type_enabled((os_log_t)qword_1008F75A0, OS_LOG_TYPE_DEFAULT))
  {
    int v3 = *(unsigned __int8 *)(a1 + 40);
    v4[0] = 67109120;
    v4[1] = v3;
    _os_log_impl( (void *)&_mh_execute_header,  v2,  OS_LOG_TYPE_DEFAULT,  "LeDeviceManager::deviceLockStateChanged fDeviceLocked:%d",  (uint8_t *)v4,  8u);
  }

void sub_1005CAC3C(uint64_t a1, char a2)
{
}

void sub_1005CAC44(uint64_t a1)
{
  uint64_t v2 = sub_100404FE8();
  v3[0] = _NSConcreteStackBlock;
  v3[1] = 3221225472LL;
  _DWORD v3[2] = sub_1005CACA4;
  v3[3] = &unk_10087EB20;
  v3[4] = a1;
  sub_100405384(v2, v3);
}

void sub_1005CACA4(uint64_t a1)
{
  *(_BYTE *)(*(void *)(a1 + 32) + 291LL) = 1;
  uint64_t v1 = (os_log_s *)qword_1008F75A0;
  if (os_log_type_enabled((os_log_t)qword_1008F75A0, OS_LOG_TYPE_DEFAULT))
  {
    *(_WORD *)uint64_t v2 = 0;
    _os_log_impl((void *)&_mh_execute_header, v1, OS_LOG_TYPE_DEFAULT, "LeDeviceManager::deviceFirstUnlocked", v2, 2u);
  }

void sub_1005CAD14(uint64_t a1)
{
  uint64_t v1 = a1 - 56;
  uint64_t v2 = sub_100404FE8();
  v3[0] = _NSConcreteStackBlock;
  v3[1] = 3221225472LL;
  _DWORD v3[2] = sub_1005CACA4;
  v3[3] = &unk_10087EB20;
  v3[4] = v1;
  sub_100405384(v2, v3);
}

void sub_1005CAD74(uint64_t a1, void *a2, int a3)
{
  id v5 = a2;
  v39[0] = 0LL;
  v39[1] = 0LL;
  sub_100242F28((uint64_t)v39, a1 + 80);
  char v6 = sub_1005C6AC0(a1, v5);
  if (v6)
  {
    sub_10002418C(__p, "HasBuiltinServices");
    uint64_t v7 = sub_100024098((uint64_t)(v6 + 22), (const void **)__p);
    if (v38 < 0) {
      operator delete(__p[0]);
    }
    if (a3)
    {
      if (qword_1008D5F20 != -1) {
        dispatch_once(&qword_1008D5F20, &stru_1008A34D8);
      }
      if (!sub_10061C0F8(qword_1008D5F18, v5)) {
        sub_1005C3B74(v6, 0);
      }
    }

    else
    {
      sub_1005C3B74(v6, 1);
      uint64_t v8 = sub_1002E6BF0();
      if ((*(unsigned int (**)(uint64_t))(*(void *)v8 + 384LL))(v8))
      {
        unsigned int v9 = *((unsigned __int16 *)v6 + 196) - 961;
        if (v9 < 9 && ((0x10Fu >> (*((_WORD *)v6 + 196) + 63)) & 1) != 0)
        {
          uint64_t v10 = (void *)objc_claimAutoreleasedReturnValue(-[__CFString uppercaseString](off_1008A35B8[(__int16)v9], "uppercaseString"));
          uint64_t v50 = 0LL;
          __int128 v48 = 0u;
          memset(v49, 0, sizeof(v49));
          __int128 v46 = 0u;
          __int128 v47 = 0u;
          __int128 v44 = 0u;
          __int128 v45 = 0u;
          __int128 v42 = 0u;
          __int128 v43 = 0u;
          sub_10020E564((uint64_t)&v42);
          BOOL v11 = sub_1001FD17C(&v42, (uint64_t)"APPEARANCE_", 11LL);
          id v29 = v10;
          sub_10002418C(&buf, (char *)[v29 UTF8String]);
          if ((v41 & 0x80u) == 0) {
            p___int128 buf = &buf;
          }
          else {
            p___int128 buf = (__int128 *)buf;
          }
          if ((v41 & 0x80u) == 0) {
            uint64_t v13 = v41;
          }
          else {
            uint64_t v13 = *((void *)&buf + 1);
          }
          sub_1001FD17C(v11, (uint64_t)p_buf, v13);
          std::stringbuf::str(&v36, (const std::stringbuf *)((char *)&v42 + 8));
          sub_1005C0684((uint64_t)v6, (uint64_t)&v36);
          if (SHIBYTE(v47) < 0) {
            operator delete(*((void **)&v46 + 1));
          }
          std::streambuf::~streambuf((char *)&v42 + 8);
          std::ios::~ios(v49);
        }
      }
    }

    sub_100241F90(&v42, v5);
    sub_1005CB37C(a1, (unsigned __int8 *)&v42);
    sub_100242F54((uint64_t)v39);
    uint64_t v14 = v6 + 23;
    if (v6 + 23 != (uint64_t *)v7)
    {
      sub_1005CB544(a1, 1);
      sub_10002418C(v34, "_GHS_DEVICE_");
      uint64_t v15 = sub_100024098((uint64_t)(v6 + 22), (const void **)v34);
      if (v35 < 0) {
        operator delete(v34[0]);
      }
      if (v14 != (void *)v15) {
LABEL_30:
      }
        sub_1005CB748(a1, v5, 2);
    }

    __int128 v42 = 0uLL;
    *(void *)&__int128 v43 = 0LL;
    sub_10040CFFC((uint64_t)&v42, v5, a3, v14 != (void *)v7);
    if (sub_1002E8D94())
    {
      uint64_t v16 = sub_1002E8D94();
      (*(void (**)(uint64_t, __int128 *))(*(void *)v16 + 40LL))(v16, &v42);
    }

    if (*((_BYTE *)v6 + 160))
    {
      __int128 v17 = sub_1005C6AC0(a1, v5);
      sub_10002418C(v32, "needsMFiAuthenticationCertClass2.0c");
      uint64_t v18 = sub_100024098((uint64_t)(v17 + 22), (const void **)v32);
      __int128 v19 = v17 + 23;
      if (v33 < 0) {
        operator delete(v32[0]);
      }
      if (v19 != (void *)v18)
      {
        __int128 v20 = (os_log_s *)qword_1008F75A0;
        if (os_log_type_enabled((os_log_t)qword_1008F75A0, OS_LOG_TYPE_DEFAULT))
        {
          LODWORD(buf) = 138543362;
          *(void *)((char *)&buf + 4) = v5;
          _os_log_impl( (void *)&_mh_execute_header,  v20,  OS_LOG_TYPE_DEFAULT,  "Starting MFI Auth 2.0c with device %{public}@",  (uint8_t *)&buf,  0xCu);
        }

        uint64_t v21 = sub_1002E8F6C();
        (*(void (**)(uint64_t, id))(*(void *)v21 + 24LL))(v21, v5);
        uint64_t v22 = sub_1002E8F6C();
        (*(void (**)(uint64_t, id))(*(void *)v22 + 176LL))(v22, v5);
      }

      uint64_t v23 = sub_1005C6AC0(a1, v5);
      sub_10002418C(v30, "needsMFiAuthentication4.0");
      uint64_t v24 = sub_100024098((uint64_t)(v23 + 22), (const void **)v30);
      uint64_t v25 = v23 + 23;
      if (v31 < 0) {
        operator delete(v30[0]);
      }
      if (v25 != (void *)v24)
      {
        uint64_t v26 = (os_log_s *)qword_1008F75A0;
        if (os_log_type_enabled((os_log_t)qword_1008F75A0, OS_LOG_TYPE_DEFAULT))
        {
          LODWORD(buf) = 138543362;
          *(void *)((char *)&buf + 4) = v5;
          _os_log_impl( (void *)&_mh_execute_header,  v26,  OS_LOG_TYPE_DEFAULT,  "Starting MFI Auth 4.0 with device %{public}@",  (uint8_t *)&buf,  0xCu);
        }

        uint64_t v27 = sub_1002E8F6C();
        (*(void (**)(uint64_t, id))(*(void *)v27 + 24LL))(v27, v5);
        uint64_t v28 = sub_1002E8F6C();
        (*(void (**)(uint64_t, id))(*(void *)v28 + 176LL))(v28, v5);
      }
    }
  }

  sub_100242FAC((uint64_t)v39);
}

void sub_1005CB288( _Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void *a10, uint64_t a11, int a12, __int16 a13, char a14, char a15, uint64_t a16, uint64_t a17, int a18, __int16 a19, char a20, char a21, void *a22, uint64_t a23, int a24, __int16 a25, char a26, char a27, void *__p, uint64_t a29, int a30, __int16 a31, char a32, char a33, uint64_t a34, uint64_t a35, int a36, __int16 a37, char a38, char a39, char a40, uint64_t a41, uint64_t a42, uint64_t a43, int a44, __int16 a45, char a46, char a47, uint64_t a48, char a49, uint64_t a50)
{
  if (a33 < 0) {
    operator delete(__p);
  }
  sub_10020E784((uint64_t)&a49);

  sub_100242FAC((uint64_t)&a40);
  _Unwind_Resume(a1);
}

uint64_t sub_1005CB37C(uint64_t a1, unsigned __int8 *a2)
{
  v10[0] = 0LL;
  v10[1] = 0LL;
  sub_100242F28((uint64_t)v10, a1 + 80);
  uint64_t v4 = *(void **)(a1 + 160);
  id v5 = sub_100241F94(a2);
  char v6 = (void *)objc_claimAutoreleasedReturnValue(v5);
  uint64_t v7 = [v4 objectForKey:v6];

  if (v7)
  {
    if (!*((_BYTE *)v7 + 97) && !*((_BYTE *)v7 + 96))
    {
      sub_1005D10D4(a1, a2);
      if (!v7[8])
      {
        uint64_t v8 = v7[2];
        if ((v8 & 0xFF000000000000LL) == 0 || (v8 & 0xFFC00000000000LL) == 0x1C00000000000LL || v7[3])
        {
          if (!*(_BYTE *)(a1 + 156)
            && !*((_BYTE *)v7 + 160)
            && os_log_type_enabled((os_log_t)qword_1008F75A0, OS_LOG_TYPE_ERROR))
          {
            sub_100366664(a2, out);
            sub_10069B01C();
          }

          sub_1002DCE48(*(void *)(a1 + 240), v7);
        }
      }
    }
  }

  else if (os_log_type_enabled((os_log_t)qword_1008F75A0, OS_LOG_TYPE_ERROR))
  {
    memset(out, 0, 37);
    uuid_unparse_upper(a2, out);
    sub_10002418C(v11, out);
    sub_10069AFC4();
  }

  return sub_100242FAC((uint64_t)v10);
}

void sub_1005CB510( _Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9)
{
}

void sub_1005CB544(uint64_t a1, char a2)
{
  id v4 = sub_1005D419C(a1);
  uint64_t v15 = (void *)objc_claimAutoreleasedReturnValue(v4);
  id v5 = (void *)objc_claimAutoreleasedReturnValue(+[NSMutableArray array](&OBJC_CLASS___NSMutableArray, "array"));
  char v14 = a2;
  __int128 v20 = 0u;
  __int128 v21 = 0u;
  __int128 v18 = 0u;
  __int128 v19 = 0u;
  id v6 = v15;
  id v7 = [v6 countByEnumeratingWithState:&v18 objects:v22 count:16];
  if (v7)
  {
    uint64_t v8 = *(void *)v19;
    do
    {
      for (uint64_t i = 0LL; i != v7; uint64_t i = (char *)i + 1)
      {
        if (*(void *)v19 != v8) {
          objc_enumerationMutation(v6);
        }
        uint64_t v10 = *(void *)(*((void *)&v18 + 1) + 8LL * (void)i);
        BOOL v11 = (char *)[*(id *)(a1 + 160) objectForKey:v10];
        sub_10002418C(__p, "DoNotAutoConnect");
        uint64_t v12 = sub_100024098((uint64_t)(v11 + 176), (const void **)__p);
        if (v17 < 0) {
          operator delete(__p[0]);
        }
      }

      id v7 = [v6 countByEnumeratingWithState:&v18 objects:v22 count:16];
    }

    while (v7);
  }

  if ((v14 & 1) != 0 || [v5 count])
  {
    uint64_t v13 = sub_1002E8F6C();
    (*(void (**)(uint64_t, void *))(*(void *)v13 + 32LL))(v13, v5);
  }
}

void sub_1005CB6F0( _Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, void *a11, void *__p, uint64_t a13, int a14, __int16 a15, char a16, char a17)
{
  _Unwind_Resume(a1);
}

void sub_1005CB748(uint64_t a1, void *a2, int a3)
{
  id v5 = a2;
  if (!v5) {
    goto LABEL_47;
  }
  if (qword_1008D5F30 != -1) {
    dispatch_once(&qword_1008D5F30, &stru_1008A3498);
  }
  id v6 = sub_1005C6AC0((uint64_t)off_1008D5F28, v5);
  uint64_t v7 = (uint64_t)v6;
  if (!v6 || !*((_BYTE *)v6 + 160))
  {
    uint64_t v16 = qword_1008F75A0;
    if (os_log_type_enabled((os_log_t)qword_1008F75A0, OS_LOG_TYPE_DEFAULT))
    {
      *(_DWORD *)__int128 buf = 67109120;
      LODWORD(v35) = a3;
      char v17 = "Identification - device not yet le-paired, stimulus %d";
      __int128 v18 = (os_log_s *)v16;
      uint32_t v19 = 8;
LABEL_46:
      _os_log_impl((void *)&_mh_execute_header, v18, OS_LOG_TYPE_DEFAULT, v17, buf, v19);
      goto LABEL_47;
    }

    goto LABEL_47;
  }

  if (a3 == 1) {
    *((_BYTE *)v6 + 359) = 1;
  }
  if (qword_1008D5F30 != -1) {
    dispatch_once(&qword_1008D5F30, &stru_1008A3498);
  }
  uint64_t v8 = off_1008D5F28;
  sub_10002418C(__p, "LeIdentificationHashExist");
  int v9 = sub_1005CE5A8((uint64_t)v8, v5, (uint64_t)__p);
  int v10 = v9;
  if ((v33 & 0x80000000) == 0)
  {
    if (v9) {
      goto LABEL_12;
    }
LABEL_19:
    __int128 v20 = (os_log_s *)qword_1008F75A0;
    if (os_log_type_enabled((os_log_t)qword_1008F75A0, OS_LOG_TYPE_DEFAULT))
    {
      *(_WORD *)__int128 buf = 0;
      _os_log_impl( (void *)&_mh_execute_header,  v20,  OS_LOG_TYPE_DEFAULT,  "Identification - Identification hash does not exist - generating",  buf,  2u);
    }

    if (qword_1008D5F30 != -1) {
      dispatch_once(&qword_1008D5F30, &stru_1008A3498);
    }
    int v21 = sub_1005DA170((uint64_t)off_1008D5F28, v5);
    uint64_t v22 = (os_log_s *)qword_1008F75A0;
    if (os_log_type_enabled((os_log_t)qword_1008F75A0, OS_LOG_TYPE_DEFAULT))
    {
      *(_DWORD *)__int128 buf = 138543874;
      id v35 = v5;
      __int16 v36 = 1024;
      int v37 = a3;
      __int16 v38 = 1024;
      int v39 = v21;
      _os_log_impl( (void *)&_mh_execute_header,  v22,  OS_LOG_TYPE_DEFAULT,  "Identification - generating for device %{public}@, stimulus %d, sent %d",  buf,  0x18u);
    }

    if ((v21 & 5) == 0 && sub_1005C4708(v7)) {
      sub_1005CDB8C(a1, v5);
    }
    goto LABEL_47;
  }

  operator delete(__p[0]);
  if (!v10) {
    goto LABEL_19;
  }
LABEL_12:
  uint64_t v11 = sub_1002E6BF0();
  if ((*(unsigned int (**)(uint64_t))(*(void *)v11 + 360LL))(v11))
  {
    sub_10002418C(v30, "IsLEMouse");
    uint64_t v12 = v7 + 176;
    uint64_t v13 = sub_100024098(v7 + 176, (const void **)v30);
    uint64_t v14 = v7 + 184;
    if (v14 == v13)
    {
      if (v31 < 0) {
        operator delete(v30[0]);
      }
    }

    else
    {
      sub_10002418C(v28, "HIDDeviceUnknownBehavior");
      if (v14 == sub_100024098(v12, (const void **)v28))
      {
        sub_10002418C(v26, "HIDDeviceKnownPoorBehavior");
        if (v14 == sub_100024098(v12, (const void **)v26))
        {
          sub_10002418C(v24, "HIDDeviceKnownGoodBehavior");
          BOOL v15 = v14 == sub_100024098(v12, (const void **)v24);
          if (v25 < 0) {
            operator delete(v24[0]);
          }
        }

        else
        {
          BOOL v15 = 0;
        }

        if (v27 < 0) {
          operator delete(v26[0]);
        }
      }

      else
      {
        BOOL v15 = 0;
      }

      if (v29 < 0) {
        operator delete(v28[0]);
      }
      if (v31 < 0)
      {
        operator delete(v30[0]);
        if (v15)
        {
LABEL_40:
          uint64_t v23 = qword_1008F75A0;
          if (os_log_type_enabled((os_log_t)qword_1008F75A0, OS_LOG_TYPE_DEFAULT))
          {
            *(_DWORD *)__int128 buf = 138543362;
            id v35 = v5;
            char v17 = "Identification - no hids tags for device %{public}@, not regenerating metric";
LABEL_45:
            __int128 v18 = (os_log_s *)v23;
            uint32_t v19 = 12;
            goto LABEL_46;
          }

          goto LABEL_47;
        }
      }

      else if (v15)
      {
        goto LABEL_40;
      }
    }
  }

  uint64_t v23 = qword_1008F75A0;
  if (os_log_type_enabled((os_log_t)qword_1008F75A0, OS_LOG_TYPE_DEFAULT))
  {
    *(_DWORD *)__int128 buf = 138543362;
    id v35 = v5;
    char v17 = "Identification - le identification tag exist for device %{public}@ - not generating";
    goto LABEL_45;
  }

void sub_1005CBB74( _Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void *__p, uint64_t a11, int a12, __int16 a13, char a14, char a15, void *a16, uint64_t a17, int a18, __int16 a19, char a20, char a21, void *a22, uint64_t a23, int a24, __int16 a25, char a26, char a27, void *a28, uint64_t a29, int a30, __int16 a31, char a32, char a33, uint64_t a34, uint64_t a35, int a36, __int16 a37, char a38, char a39)
{
  if (a15 < 0) {
    operator delete(__p);
  }
  if (a21 < 0) {
    operator delete(a16);
  }
  if (a27 < 0) {
    operator delete(a22);
  }
  if (a33 < 0) {
    operator delete(a28);
  }

  _Unwind_Resume(a1);
}

void sub_1005CBC08(uint64_t a1, void *a2, int a3)
{
}

void sub_1005CBC10(uint64_t a1, void *a2)
{
  id v3 = a2;
  v21[0] = 0LL;
  v21[1] = 0LL;
  sub_100242F28((uint64_t)v21, a1 + 80);
  id v4 = sub_1005C6AC0(a1, v3);
  if (v4)
  {
    uint64_t v19 = 0LL;
    id v20 = 0LL;
    sub_10040D044((uint64_t)&v19, v3);
    if (sub_1002E8D94())
    {
      uint64_t v5 = sub_1002E8D94();
      (*(void (**)(uint64_t, uint64_t *))(*(void *)v5 + 40LL))(v5, &v19);
    }

    sub_10002418C(__p, "HasBuiltinServices");
    uint64_t v6 = sub_100024098((uint64_t)(v4 + 22), (const void **)__p);
    if (v18 < 0) {
      operator delete(__p[0]);
    }
    else {
      uint64_t v7 = *((unsigned __int8 *)v4 + 231);
    }
    *((_BYTE *)v4 + 357) = 0;
    *((_BYTE *)v4 + 359) = 0;
    *((_BYTE *)v4 + 368) = 1;
    sub_1005C3B74(v4, 0);
    sub_10002418C(&__str, "");
    std::string::operator=((std::string *)(v4 + 26), &__str);
    uint64_t v8 = v4 + 23;
    sub_10023E78C((uint64_t)(v4 + 22), (char *)v4[23]);
    v4[23] = 0LL;
    v4[24] = 0LL;
    v4[22] = v8;
    v4[60] = 0LL;
    if (v7) {
      sub_1005C2558((uint64_t)v4, 0, 0LL, 0);
    }
    unint64_t v9 = v4[3];
    if (v9)
    {
      int v10 = (os_log_s *)qword_1008F75A0;
      if (os_log_type_enabled((os_log_t)qword_1008F75A0, OS_LOG_TYPE_INFO))
      {
        LODWORD(__str.__r_.__value_.__l.__data_) = 138543362;
        *(std::string::size_type *)((char *)__str.__r_.__value_.__r.__words + 4) = (std::string::size_type)v3;
        _os_log_impl( (void *)&_mh_execute_header,  v10,  OS_LOG_TYPE_INFO,  "Clearing resolved address for device %{public}@",  (uint8_t *)&__str,  0xCu);
      }

      v4[3] = 0LL;
      uint64_t v11 = v4[2];
      if ((v11 & 0xFF000000000000LL) == 0 || (v11 & 0xFFC00000000000LL) == 0x1C00000000000LL)
      {
        sub_100241F90(&__str, v3);
        sub_1005CB37C(a1, (unsigned __int8 *)&__str);
      }

      else
      {
        sub_1002DCF3C(*(void *)(a1 + 240), (uint64_t)v4);
      }

      if (v9 != v4[2])
      {
        uint64_t v12 = *(void **)(a1 + 176);
        if (v12)
        {
          uint64_t v13 = (uint64_t *)(a1 + 176);
          do
          {
            unint64_t v14 = v12[4];
            BOOL v15 = v14 >= v9;
            if (v14 >= v9) {
              uint64_t v16 = v12;
            }
            else {
              uint64_t v16 = v12 + 1;
            }
            if (v15) {
              uint64_t v13 = v12;
            }
            uint64_t v12 = (void *)*v16;
          }

          while (*v16);
          if (v13 != (uint64_t *)(a1 + 176) && v9 >= v13[4])
          {
            sub_1001FDBCC((uint64_t **)(a1 + 168), v13);
            operator delete(v13);
          }
        }
      }
    }

    if (v8 != (void *)v6) {
      sub_1005CB544(a1, 1);
    }
  }

  sub_100242FAC((uint64_t)v21);
}

void sub_1005CBEBC( _Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, int a12, __int16 a13, char a14, char a15, uint64_t a16, void *a17, char a18, uint64_t a19, void *__p, uint64_t a21, int a22, __int16 a23, char a24, char a25)
{
  sub_100242FAC((uint64_t)&a18);
  _Unwind_Resume(a1);
}

void sub_1005CBF38(uint64_t a1, void *a2)
{
}

uint64_t sub_1005CBF40(uint64_t a1, int a2, int a3)
{
  v18[0] = 0LL;
  v18[1] = 0LL;
  sub_100242F28((uint64_t)v18, a1 + 80);
  *(_BYTE *)(a1 + 156) = 1;
  *(_DWORD *)(a1 + 148) = a3;
  *(_DWORD *)(a1 + 152) = a2;
  __int128 v14 = 0u;
  __int128 v15 = 0u;
  __int128 v16 = 0u;
  __int128 v17 = 0u;
  id v6 = *(id *)(a1 + 160);
  id v7 = [v6 countByEnumeratingWithState:&v14 objects:v19 count:16];
  if (v7)
  {
    uint64_t v8 = *(void *)v15;
    do
    {
      for (uint64_t i = 0LL; i != v7; uint64_t i = (char *)i + 1)
      {
        if (*(void *)v15 != v8) {
          objc_enumerationMutation(v6);
        }
        int v10 = objc_msgSend( *(id *)(a1 + 160),  "objectForKey:",  *(void *)(*((void *)&v14 + 1) + 8 * (void)i),  (void)v14);
        int v11 = v10[33];
        if (v11) {
          v10[33] = *(_DWORD *)(a1 + 152) + v11;
        }
        int v12 = v10[34];
        if (v12) {
          v10[34] = *(_DWORD *)(a1 + 148) + v12;
        }
      }

      id v7 = [v6 countByEnumeratingWithState:&v14 objects:v19 count:16];
    }

    while (v7);
  }

  return sub_100242FAC((uint64_t)v18);
}

void sub_1005CC084( _Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, ...)
{
  sub_100242FAC((uint64_t)va);
  _Unwind_Resume(a1);
}

uint64_t sub_1005CC0B0(uint64_t a1, int a2, int a3)
{
  return sub_1005CBF40(a1 - 32, a2, a3);
}

BOOL sub_1005CC0B8(uint64_t a1, void *a2)
{
  return sub_1005C6AC0(a1, a2) != 0LL;
}

void sub_1005CC0D4(uint64_t a1@<X0>, void *a2@<X1>, uint64_t a3@<X8>)
{
  id v5 = a2;
  v8[0] = 0LL;
  v8[1] = 0LL;
  sub_100242F28((uint64_t)v8, a1 + 80);
  id v6 = sub_1005C6AC0(a1, v5);
  if (v6)
  {
    if (*((char *)v6 + 127) < 0)
    {
      sub_100024238((_BYTE *)a3, (void *)v6[13], v6[14]);
    }

    else
    {
      __int128 v7 = *(_OWORD *)(v6 + 13);
      *(void *)(a3 + 16) = v6[15];
      *(_OWORD *)a3 = v7;
    }
  }

  else
  {
    sub_10002418C((void *)a3, "");
  }

  sub_100242FAC((uint64_t)v8);
}

void sub_1005CC178(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

uint64_t sub_1005CC198(uint64_t a1, void *a2, int a3)
{
  id v5 = a2;
  v13[0] = 0LL;
  v13[1] = 0LL;
  sub_100242F28((uint64_t)v13, a1 + 80);
  id v6 = sub_1005C6AC0(a1, v5);
  __int128 v7 = v6;
  if (v6)
  {
    if (!v6[2])
    {
      uint64_t v8 = (os_log_s *)qword_1008F75A0;
      if (os_log_type_enabled((os_log_t)qword_1008F75A0, OS_LOG_TYPE_FAULT))
      {
        id v9 = sub_1005BFB9C(0LL);
        int v10 = (void *)objc_claimAutoreleasedReturnValue(v9);
        sub_10069B0CC(v10, (uint64_t)v14, v8);
      }
    }

    if (a3 || (uint64_t v11 = v7[3]) == 0) {
      uint64_t v11 = v7[2];
    }
  }

  else
  {
    if (os_log_type_enabled((os_log_t)qword_1008F75A0, OS_LOG_TYPE_ERROR)) {
      sub_10069B068();
    }
    uint64_t v11 = 0LL;
  }

  sub_100242FAC((uint64_t)v13);

  return v11;
}

void sub_1005CC2AC( _Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9)
{
  _Unwind_Resume(a1);
}

BOOL sub_1005CC2D8(uint64_t a1, void *a2)
{
  id v3 = a2;
  v7[0] = 0LL;
  v7[1] = 0LL;
  sub_100242F28((uint64_t)v7, a1 + 80);
  id v4 = sub_1005C6AC0(a1, v3);
  if (v4) {
    BOOL v5 = v4[3] != 0LL;
  }
  else {
    BOOL v5 = 0LL;
  }
  sub_100242FAC((uint64_t)v7);

  return v5;
}

void sub_1005CC348( _Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9)
{
  _Unwind_Resume(a1);
}

uint64_t sub_1005CC368(uint64_t a1, void *a2)
{
  id v3 = a2;
  v7[0] = 0LL;
  v7[1] = 0LL;
  sub_100242F28((uint64_t)v7, a1 + 80);
  id v4 = sub_1005C6AC0(a1, v3);
  if (v4) {
    uint64_t v5 = *((unsigned int *)v4 + 35);
  }
  else {
    uint64_t v5 = 0LL;
  }
  sub_100242FAC((uint64_t)v7);

  return v5;
}

void sub_1005CC3D0( _Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9)
{
  _Unwind_Resume(a1);
}

uint64_t sub_1005CC3F0(uint64_t a1, void *a2)
{
  id v3 = a2;
  v7[0] = 0LL;
  v7[1] = 0LL;
  sub_100242F28((uint64_t)v7, a1 + 80);
  id v4 = sub_1005C6AC0(a1, v3);
  if (v4) {
    uint64_t v5 = *((unsigned int *)v4 + 36);
  }
  else {
    uint64_t v5 = 0LL;
  }
  sub_100242FAC((uint64_t)v7);

  return v5;
}

void sub_1005CC458( _Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9)
{
  _Unwind_Resume(a1);
}

uint64_t sub_1005CC478(uint64_t a1, void *a2)
{
  id v3 = a2;
  v7[0] = 0LL;
  v7[1] = 0LL;
  sub_100242F28((uint64_t)v7, a1 + 80);
  id v4 = sub_1005C6AC0(a1, v3);
  if (v4) {
    uint64_t v5 = v4[19];
  }
  else {
    uint64_t v5 = 0LL;
  }
  sub_100242FAC((uint64_t)v7);

  return v5;
}

void sub_1005CC4E0( _Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9)
{
  _Unwind_Resume(a1);
}

uint64_t sub_1005CC500(uint64_t a1, void *a2)
{
  id v3 = a2;
  v7[0] = 0LL;
  v7[1] = 0LL;
  sub_100242F28((uint64_t)v7, a1 + 80);
  id v4 = sub_1005C6AC0(a1, v3);
  if (v4) {
    uint64_t v5 = *((unsigned int *)v4 + 33);
  }
  else {
    uint64_t v5 = 0LL;
  }
  sub_100242FAC((uint64_t)v7);

  return v5;
}

void sub_1005CC568( _Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9)
{
  _Unwind_Resume(a1);
}

uint64_t sub_1005CC588(uint64_t a1, void *a2)
{
  id v3 = a2;
  v7[0] = 0LL;
  v7[1] = 0LL;
  sub_100242F28((uint64_t)v7, a1 + 80);
  id v4 = sub_1005C6AC0(a1, v3);
  if (v4) {
    uint64_t v5 = *((unsigned int *)v4 + 65);
  }
  else {
    uint64_t v5 = 1LL;
  }
  sub_100242FAC((uint64_t)v7);

  return v5;
}

void sub_1005CC5F0( _Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9)
{
  _Unwind_Resume(a1);
}

double sub_1005CC610(uint64_t a1, void *a2)
{
  id v3 = a2;
  v7[0] = 0LL;
  v7[1] = 0LL;
  sub_100242F28((uint64_t)v7, a1 + 80);
  id v4 = (double *)sub_1005C6AC0(a1, v3);
  if (v4) {
    double v5 = v4[51];
  }
  else {
    double v5 = 0.0;
  }
  sub_100242FAC((uint64_t)v7);

  return v5;
}

void sub_1005CC680( _Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9)
{
  _Unwind_Resume(a1);
}

void sub_1005CC6A0(uint64_t a1, void *a2, double a3)
{
  id v5 = a2;
  v7[0] = 0LL;
  v7[1] = 0LL;
  sub_100242F28((uint64_t)v7, a1 + 80);
  id v6 = (double *)sub_1005C6AC0(a1, v5);
  if (v6) {
    v6[51] = a3;
  }
  sub_100242FAC((uint64_t)v7);
}

void sub_1005CC708( _Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9)
{
  _Unwind_Resume(a1);
}

double sub_1005CC728(uint64_t a1, void *a2)
{
  id v3 = a2;
  v7[0] = 0LL;
  v7[1] = 0LL;
  sub_100242F28((uint64_t)v7, a1 + 80);
  id v4 = (double *)sub_1005C6AC0(a1, v3);
  if (v4) {
    double v5 = v4[52];
  }
  else {
    double v5 = 0.0;
  }
  sub_100242FAC((uint64_t)v7);

  return v5;
}

void sub_1005CC798( _Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9)
{
  _Unwind_Resume(a1);
}

double sub_1005CC7B8(uint64_t a1, void *a2)
{
  id v3 = a2;
  v7[0] = 0LL;
  v7[1] = 0LL;
  sub_100242F28((uint64_t)v7, a1 + 80);
  id v4 = (double *)sub_1005C6AC0(a1, v3);
  if (v4) {
    double v5 = v4[53];
  }
  else {
    double v5 = 0.0;
  }
  sub_100242FAC((uint64_t)v7);

  return v5;
}

void sub_1005CC828( _Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9)
{
  _Unwind_Resume(a1);
}

void sub_1005CC848(uint64_t a1, void *a2, double a3)
{
  id v5 = a2;
  v7[0] = 0LL;
  v7[1] = 0LL;
  sub_100242F28((uint64_t)v7, a1 + 80);
  id v6 = (double *)sub_1005C6AC0(a1, v5);
  if (v6) {
    v6[53] = a3;
  }
  sub_100242FAC((uint64_t)v7);
}

void sub_1005CC8B0( _Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9)
{
  _Unwind_Resume(a1);
}

double sub_1005CC8D0(uint64_t a1, void *a2)
{
  id v3 = a2;
  v7[0] = 0LL;
  v7[1] = 0LL;
  sub_100242F28((uint64_t)v7, a1 + 80);
  id v4 = (double *)sub_1005C6AC0(a1, v3);
  if (v4) {
    double v5 = v4[54];
  }
  else {
    double v5 = 0.0;
  }
  sub_100242FAC((uint64_t)v7);

  return v5;
}

void sub_1005CC940( _Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9)
{
  _Unwind_Resume(a1);
}

void sub_1005CC960(uint64_t a1, void *a2, double a3)
{
  id v5 = a2;
  v7[0] = 0LL;
  v7[1] = 0LL;
  sub_100242F28((uint64_t)v7, a1 + 80);
  id v6 = (double *)sub_1005C6AC0(a1, v5);
  if (v6) {
    v6[54] = a3;
  }
  sub_100242FAC((uint64_t)v7);
}

void sub_1005CC9C8( _Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9)
{
  _Unwind_Resume(a1);
}

double sub_1005CC9E8(uint64_t a1, void *a2)
{
  id v3 = a2;
  v7[0] = 0LL;
  v7[1] = 0LL;
  sub_100242F28((uint64_t)v7, a1 + 80);
  id v4 = (double *)sub_1005C6AC0(a1, v3);
  if (v4) {
    double v5 = v4[55];
  }
  else {
    double v5 = 0.0;
  }
  sub_100242FAC((uint64_t)v7);

  return v5;
}

void sub_1005CCA58( _Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9)
{
  _Unwind_Resume(a1);
}

void sub_1005CCA78(uint64_t a1, void *a2, double a3)
{
  id v5 = a2;
  v7[0] = 0LL;
  v7[1] = 0LL;
  sub_100242F28((uint64_t)v7, a1 + 80);
  id v6 = (double *)sub_1005C6AC0(a1, v5);
  if (v6) {
    v6[55] = a3;
  }
  sub_100242FAC((uint64_t)v7);
}

void sub_1005CCAE0( _Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9)
{
  _Unwind_Resume(a1);
}

uint64_t sub_1005CCB00(uint64_t a1, void *a2)
{
  id v3 = a2;
  v7[0] = 0LL;
  v7[1] = 0LL;
  sub_100242F28((uint64_t)v7, a1 + 80);
  id v4 = sub_1005C6AC0(a1, v3);
  if (v4) {
    uint64_t v5 = *((unsigned int *)v4 + 112);
  }
  else {
    uint64_t v5 = 0LL;
  }
  sub_100242FAC((uint64_t)v7);

  return v5;
}

void sub_1005CCB68( _Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9)
{
  _Unwind_Resume(a1);
}

void sub_1005CCB88(uint64_t a1, void *a2, int a3)
{
  id v5 = a2;
  v7[0] = 0LL;
  v7[1] = 0LL;
  sub_100242F28((uint64_t)v7, a1 + 80);
  id v6 = sub_1005C6AC0(a1, v5);
  if (v6) {
    *((_DWORD *)v6 + 112) = a3;
  }
  sub_100242FAC((uint64_t)v7);
}

void sub_1005CCBF0( _Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9)
{
  _Unwind_Resume(a1);
}

void sub_1005CCC10(uint64_t a1, void *a2, int a3)
{
  id v5 = a2;
  v7[0] = 0LL;
  v7[1] = 0LL;
  sub_100242F28((uint64_t)v7, a1 + 80);
  id v6 = sub_1005C6AC0(a1, v5);
  if (v6) {
    *((_DWORD *)v6 + 112) += a3;
  }
  sub_100242FAC((uint64_t)v7);
}

void sub_1005CCC80( _Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9)
{
  _Unwind_Resume(a1);
}

BOOL sub_1005CCCA0(uint64_t a1, void *a2)
{
  id v3 = a2;
  v7[0] = 0LL;
  v7[1] = 0LL;
  sub_100242F28((uint64_t)v7, a1 + 80);
  id v4 = sub_1005C6AC0(a1, v3);
  if (v4) {
    BOOL v5 = *((_BYTE *)v4 + 162) != 0;
  }
  else {
    BOOL v5 = 0LL;
  }
  sub_100242FAC((uint64_t)v7);

  return v5;
}

void sub_1005CCD10( _Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9)
{
  _Unwind_Resume(a1);
}

uint64_t sub_1005CCD30@<X0>(uint64_t a1@<X0>, unint64_t a2@<X1>, uint64_t a3@<X8>)
{
  v14[0] = 0LL;
  v14[1] = 0LL;
  sub_100242F28((uint64_t)v14, a1 + 80);
  *(void *)a3 = 0LL;
  *(void *)(a3 + 8) = 0LL;
  uuid_clear((unsigned __int8 *)a3);
  if (a2)
  {
    uint64_t v8 = *(void **)(a1 + 224);
    __int128 v7 = (const unsigned __int8 *)(a1 + 224);
    id v6 = v8;
    if (v8)
    {
      id v9 = v7;
      do
      {
        unint64_t v10 = v6[4];
        BOOL v11 = v10 >= a2;
        if (v10 >= a2) {
          int v12 = v6;
        }
        else {
          int v12 = v6 + 1;
        }
        if (v11) {
          id v9 = (const unsigned __int8 *)v6;
        }
        id v6 = (void *)*v12;
      }

      while (*v12);
      if (v9 != v7 && *((void *)v9 + 4) <= a2) {
        uuid_copy((unsigned __int8 *)a3, v9 + 40);
      }
    }
  }

  return sub_100242FAC((uint64_t)v14);
}

void sub_1005CCDD4( _Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9)
{
}

void sub_1005CCDEC(uint64_t a1, void *a2, __int16 a3)
{
  id v5 = a2;
  v7[0] = 0LL;
  v7[1] = 0LL;
  sub_100242F28((uint64_t)v7, a1 + 80);
  id v6 = sub_1005C6AC0(a1, v5);
  if (v6) {
    *((_WORD *)v6 + 196) = a3;
  }
  sub_100242FAC((uint64_t)v7);
}

void sub_1005CCE54( _Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9)
{
  _Unwind_Resume(a1);
}

BOOL sub_1005CCE74(uint64_t a1)
{
  uint64_t v2 = sub_1002E6BF0();
  v12[0] = 0LL;
  v12[1] = 0LL;
  sub_100242F28((uint64_t)v12, a1 + 80);
  id v3 = (os_log_s *)qword_1008F75A0;
  if (os_log_type_enabled((os_log_t)qword_1008F75A0, OS_LOG_TYPE_DEBUG)) {
    sub_10069B114(a1, v3, v4, v5, v6, v7, v8, v9);
  }
  BOOL v10 = *(_BYTE *)(a1 + 288) != 0;
  sub_100242FAC((uint64_t)v12);
  return v10;
}

uint64_t sub_1005CCF08(uint64_t a1, void *a2, unsigned __int8 *a3)
{
  id v5 = a2;
  v99[0] = 0LL;
  v99[1] = 0LL;
  sub_100242F28((uint64_t)v99, a1 + 80);
  uint64_t v6 = sub_1005C6AC0(a1, v5);
  uint64_t v7 = (uint64_t)v6;
  if (!v6)
  {
    uint64_t v12 = 0LL;
    goto LABEL_178;
  }

  int v8 = (char)a3[23];
  if (v8 < 0)
  {
    if (*((void *)a3 + 1) != 24LL)
    {
      BOOL v10 = (os_log_s *)qword_1008F75A0;
      if (!os_log_type_enabled((os_log_t)qword_1008F75A0, OS_LOG_TYPE_DEFAULT)) {
        goto LABEL_24;
      }
      goto LABEL_20;
    }

    uint64_t v9 = *(unsigned __int8 **)a3;
  }

  else
  {
    uint64_t v9 = a3;
    if (v8 != 24)
    {
      BOOL v10 = (os_log_s *)qword_1008F75A0;
      if (!os_log_type_enabled((os_log_t)qword_1008F75A0, OS_LOG_TYPE_DEFAULT))
      {
LABEL_23:
        *(_OWORD *)std::string __p = *(_OWORD *)a3;
        uint64_t v96 = *((void *)a3 + 2);
        goto LABEL_25;
      }

      BOOL v11 = a3;
      goto LABEL_21;
    }
  }

  uint64_t v13 = *(void *)v9;
  uint64_t v14 = *((void *)v9 + 1);
  uint64_t v15 = *((void *)v9 + 2);
  if (v13 == 0x4144494C41564E49LL && v14 == 0x454B5241435F4554LL && v15 == 0x4543495645445F59LL)
  {
    sub_10002418C(v97, "PAIRED_FOR_ALISHA");
    uint64_t v34 = sub_100024098(v7 + 176, v97);
    if (v98 < 0) {
      operator delete((void *)v97[0]);
    }
    if (v7 + 184 != v34)
    {
      sub_100242F54((uint64_t)v99);
      if (qword_1008D5F20 != -1) {
        dispatch_once(&qword_1008D5F20, &stru_1008A34D8);
      }
      if (sub_10061C0F8(qword_1008D5F18, v5))
      {
        if (os_log_type_enabled((os_log_t)qword_1008F75A0, OS_LOG_TYPE_ERROR)) {
          sub_10069B204();
        }
      }

      else
      {
        sub_1005C91A4(a1, v5);
        __int128 v79 = (os_log_s *)qword_1008F75A0;
        if (os_log_type_enabled((os_log_t)qword_1008F75A0, OS_LOG_TYPE_DEFAULT))
        {
          *(_WORD *)__int128 buf = 0;
          _os_log_impl( (void *)&_mh_execute_header,  v79,  OS_LOG_TYPE_DEFAULT,  "Sucessfully deleted INVALIDATE_CARKEY_DEVICE",  buf,  2u);
        }
      }
    }

    goto LABEL_184;
  }

  BOOL v10 = (os_log_s *)qword_1008F75A0;
  if (os_log_type_enabled((os_log_t)qword_1008F75A0, OS_LOG_TYPE_DEFAULT))
  {
    BOOL v11 = a3;
    if ((v8 & 0x80000000) == 0)
    {
LABEL_21:
      *(_DWORD *)__int128 buf = 136446466;
      *(void *)&uint8_t buf[4] = v11;
      *(_WORD *)&_BYTE buf[12] = 2114;
      *(void *)&buf[14] = v5;
      _os_log_impl( (void *)&_mh_execute_header,  v10,  OS_LOG_TYPE_DEFAULT,  "Adding %{public}s tag to device %{public}@",  buf,  0x16u);
      LOBYTE(v8) = a3[23];
      goto LABEL_22;
    }

LABEL_172:
  memset(buf, 0, sizeof(buf));
  *(_DWORD *)__int128 buf = *(_DWORD *)(a1 + 256);
  sub_100240540(&buf[8], a1 + 264);
  v82._uint64_t os_unfair_lock_opaque = *(_DWORD *)buf;
  __uuid_t dst = 0LL;
  uint64_t v85 = 0LL;
  __int128 v83 = 0LL;
  unint64_t v73 = *(const void **)&buf[8];
  int64_t v74 = *(void *)&buf[16] - *(void *)&buf[8];
  if (*(void *)&buf[16] != *(void *)&buf[8])
  {
    sub_10023DBC8(&v83, v74 >> 3);
    unsigned __int16 v75 = (char *)__dst;
    memmove(__dst, v73, v74);
    __uuid_t dst = &v75[8 * (v74 >> 3)];
  }

  v80[0] = _NSConcreteStackBlock;
  v80[1] = 3221225472LL;
  v80[2] = sub_1005CE384;
  v80[3] = &unk_1008A33D0;
  id v81 = v5;
  sub_1005DC3A4(&v82, v80);
  if (v83)
  {
    __uuid_t dst = v83;
    operator delete(v83);
  }

  uint64_t v6 = *(void **)&buf[8];
  if (*(void *)&buf[8])
  {
    *(void *)&uint8_t buf[16] = *(void *)&buf[8];
    operator delete(*(void **)&buf[8]);
  }

LABEL_184:
    uint64_t v12 = 1LL;
    goto LABEL_185;
  }

  if (os_log_type_enabled((os_log_t)qword_1008F75A0, OS_LOG_TYPE_ERROR))
  {
    sub_1003CF00C((uint64_t)v76, buf);
    sub_10069B1C0();
  }

LABEL_185:
  sub_100242FAC((uint64_t)v99);
  return v12;
}

      if (*((void *)&v277 + 1))
      {
        *(void *)&__int128 v278 = *((void *)&v277 + 1);
        operator delete(*((void **)&v277 + 1));
      }

      v233.__r_.__value_.__r.__words[0] = (std::string::size_type)v185;
      sub_10004FEA4((void ***)&v233);
      if ((void)v191)
      {
        *((void *)&v191 + 1) = v191;
        operator delete((void *)v191);
      }

      char v109 = (void *)v76[1];
      if (v109)
      {
        do
        {
          __int128 v110 = v109;
          char v109 = (void *)*v109;
        }

        while (v109);
      }

      else
      {
        do
        {
          __int128 v110 = (void *)v76[2];
          __int128 v111 = *v110 == (void)v76;
          char v76 = v110;
        }

        while (!v111);
      }

      char v76 = v110;
      if (v110 == v181) {
        goto LABEL_206;
      }
    }

    uint64_t v85 = (std::string::size_type)p_size;
    *p_uint64_t size = 0LL;
    *(void *)(v85 + 8) = 0LL;
    v233.__r_.__value_.__r.__words[0] = v85;
    if (__dst[0].__r_.__value_.__s.__data_[8])
    {
      char v87 = *((void *)&v276 + 1);
      for (uint64_t i = v276; i != v87; i += 96LL)
        sub_10060F8F4((uint64_t **)&v233, (unsigned __int8 *)(i + 22), (_BYTE *)(i + 22));
    }

    if (*((_DWORD *)v182 + 491))
    {
      v215[0] = _NSConcreteStackBlock;
      v215[1] = 3321888768LL;
      v215[2] = sub_1005F9AC8;
      v215[3] = &unk_1008A3B78;
      v218 = v78;
      id v216 = v179;
      id v219 = &off_10087FAE8;
      uint64_t v220 = v252;
      if (v252) {
        sub_1002CD1E0((uint64_t)v252);
      }
      BOOL v88 = v170;
      NSUUID *v170 = 0LL;
      v88[1] = 0LL;
      v88[2] = 0LL;
      sub_100050EE8( (char *)v88,  (__int128 *)v191,  *((__int128 **)&v191 + 1),  0xCCCCCCCCCCCCCCCDLL * ((uint64_t)(*((void *)&v191 + 1) - v191) >> 2));
      id v223 = v177;
      sub_10060F9AC(v176, (uint64_t)&v233);
      uint64_t v217 = v184;
      sub_1005EBB90(v169, v215);

      sub_10023BF24((uint64_t)v176, v222[1]);
      if (v221[0])
      {
        v221[1] = v221[0];
        operator delete(v221[0]);
      }

      id v219 = &off_10087FAE8;
      id v89 = v220;
      uint64_t v90 = v168;
      if (!v220) {
        goto LABEL_162;
      }
    }

    else
    {
      if (!*((_BYTE *)v182 + 1255))
      {
        __int128 v112 = 289LL;
        if (!*(_BYTE *)(*(void *)(v77 + 8) + 143LL)) {
          __int128 v112 = 290LL;
        }
        ++v182[v112];
      }

      v224[0] = _NSConcreteStackBlock;
      v224[1] = 3321888768LL;
      v224[2] = sub_1005F9998;
      v224[3] = &unk_1008A3B78;
      v227 = v78;
      int v225 = v179;
      BOOL v228 = &off_10087FAE8;
      uint64_t v229 = v252;
      if (v252) {
        sub_1002CD1E0((uint64_t)v252);
      }
      __int128 v113 = v167;
      os_log_s *v167 = 0LL;
      v113[1] = 0LL;
      v113[2] = 0LL;
      sub_100050EE8( (char *)v113,  (__int128 *)v191,  *((__int128 **)&v191 + 1),  0xCCCCCCCCCCCCCCCDLL * ((uint64_t)(*((void *)&v191 + 1) - v191) >> 2));
      uint64_t v232 = v177;
      sub_10060F9AC(v171, (uint64_t)&v233);
      int v226 = v184;
      sub_1005EBB90(v166, v224);

      sub_10023BF24((uint64_t)v171, v231[1]);
      if (v230[0])
      {
        v230[1] = v230[0];
        operator delete(v230[0]);
      }

      BOOL v228 = &off_10087FAE8;
      id v89 = v229;
      uint64_t v90 = v165;
      if (!v229) {
        goto LABEL_162;
      }
    }

    sub_1002CD254(v89);
LABEL_162:

    sub_100494958(v78, (uint64_t)&v212);
    if (v214 >= 0) {
      __int128 v91 = (void **)&v212;
    }
    else {
      __int128 v91 = v212;
    }
    if (v214 >= 0) {
      id v92 = HIBYTE(v214);
    }
    else {
      id v92 = v213;
    }
    __int128 v93 = sub_1001FD17C(v173, (uint64_t)v91, v92);
    uint64_t v94 = sub_1001FD17C(v93, (uint64_t)" hashedUUIDs=", 13LL);
    id v95 = (void *)std::ostream::operator<<( v94,  -858993459 * ((*((void *)&v191 + 1) - (void)v191) >> 2));
    uint64_t v96 = sub_1001FD17C(v95, (uint64_t)" Nbmatchrules=", 14LL);
    id v97 = (void *)std::ostream::operator<<( v96,  -1431655765 * ((*(void *)(*(void *)(v77 + 8) + 72LL) - *(void *)(*(void *)(v77 + 8) + 64LL)) >> 5));
    char v98 = sub_1001FD17C(v97, (uint64_t)" ServiceUUID=", 13LL);
    __int16 v99 = (void *)std::ostream::operator<<( v98,  -858993459 * ((*(void *)(*(void *)(v77 + 8) + 16LL) - *(void *)(*(void *)(v77 + 8) + 8LL)) >> 2));
    sub_1001FD17C(v99, (uint64_t)" | ", 3LL);
    if (SHIBYTE(v214) < 0) {
      operator delete(v212);
    }
    signed int v100 = *(void *)(v183 + 8);
    if (*(_BYTE *)(v100 + 14) && !*(_BYTE *)(v100 + 367))
    {
      int v210 = 0u;
      v211 = 0u;
      uint64_t v208 = 0u;
      __int128 v209 = 0u;
      uint64_t v101 = sub_1005F9AF4(*(void *)(v77 + 8));
      char v102 = (void *)objc_claimAutoreleasedReturnValue(v101);
      __int128 v103 = [v102 countByEnumeratingWithState:&v208 objects:v264 count:16];
      if (v103)
      {
        __int128 v104 = *(void *)v209;
        do
        {
          for (j = 0LL; j != v103; j = (char *)j + 1)
          {
            if (*(void *)v209 != v104) {
              objc_enumerationMutation(v102);
            }
            __int128 v106 = *(id *)(*((void *)&v208 + 1) + 8LL * (void)j);
            sub_100494E68(v78, &v212);
            *(void *)&v206 = &v212;
            __int16 v107 = (uint64_t **)sub_10060FCB4(&v234, (const void **)&v212, (uint64_t)&unk_1006C2518, (_OWORD **)&v206);
            uint64_t v108 = v106;
            sub_10002418C(&v206, (char *)[v108 UTF8String]);
            sub_1004F5958(v107 + 7, (const void **)&v206, (uint64_t)&v206);
            if (SHIBYTE(v207) < 0) {
              operator delete((void *)v206);
            }
            if (SHIBYTE(v214) < 0) {
              operator delete(v212);
            }
          }

          __int128 v103 = [v102 countByEnumeratingWithState:&v208 objects:v264 count:16];
        }

        while (v103);
      }
    }

    sub_10023BF24((uint64_t)&v233, (void *)v233.__r_.__value_.__l.__size_);
    __int128 v83 = v184;
    goto LABEL_185;
  }

void sub_1005CD9B4( _Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, void *a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, int a20, __int16 a21, char a22, char a23, uint64_t a24, uint64_t a25, uint64_t a26, uint64_t a27, uint64_t a28, uint64_t a29, uint64_t a30, uint64_t a31, uint64_t a32, uint64_t a33, uint64_t a34, void *__p, uint64_t a36, int a37, __int16 a38, char a39, char a40, uint64_t a41, uint64_t a42, int a43, __int16 a44, char a45, char a46)
{
  _Unwind_Resume(a1);
}

void sub_1005CDACC(uint64_t a1)
{
  if (qword_1008D67C8 != -1) {
    dispatch_once(&qword_1008D67C8, &stru_1008A3458);
  }
  uint64_t v2 = (void *)(a1 + 40);
  int v3 = *(char *)(a1 + 63);
  if (v3 < 0)
  {
    if (*(void *)(a1 + 48) != 14LL)
    {
LABEL_14:
      BOOL v7 = 0LL;
      goto LABEL_15;
    }

    uint64_t v2 = (void *)*v2;
  }

  else if (v3 != 14)
  {
    goto LABEL_14;
  }

  uint64_t v4 = (void *)*v2;
  uint64_t v5 = *(void *)((char *)v2 + 6);
  BOOL v7 = v4 == (void *)0x6874754153434E41LL && v5 == 0x64657A69726F6874LL;
LABEL_15:
  sub_10028DE60((uint64_t)off_1008D67C0, *(void **)(a1 + 32), v7);
}

void sub_1005CDB80(uint64_t a1)
{
}

void sub_1005CDB8C(uint64_t a1, void *a2)
{
  id v3 = a2;
  uint64_t v4 = sub_1002E6BF0();
  uint64_t v5 = sub_1005C6AC0(a1, v3);
  sub_10002418C(v46, "IsLEMouse");
  uint64_t v6 = sub_100024098((uint64_t)(v5 + 22), v46);
  BOOL v7 = v5 + 23;
  if (v47 < 0) {
    operator delete((void *)v46[0]);
  }
  int v8 = (os_log_s *)qword_1008F75A0;
  BOOL v9 = os_log_type_enabled((os_log_t)qword_1008F75A0, OS_LOG_TYPE_DEFAULT);
  if (v7 != (void *)v6)
  {
    if (v9)
    {
      LODWORD(buf) = 138543362;
      *(void *)((char *)&buf + 4) = v3;
      _os_log_impl( (void *)&_mh_execute_header,  v8,  OS_LOG_TYPE_DEFAULT,  "HIDIdentification - The device %{public}@ supports HID. SetLEHIDDeviceBehavior",  (uint8_t *)&buf,  0xCu);
    }

    uint64_t v10 = sub_1002E6BF0();
    if ((*(unsigned int (**)(uint64_t))(*(void *)v10 + 272LL))(v10))
    {
      BOOL v11 = (os_log_s *)qword_1008F75A0;
      if (os_log_type_enabled((os_log_t)qword_1008F75A0, OS_LOG_TYPE_DEFAULT))
      {
        LOWORD(buf) = 0;
        _os_log_impl( (void *)&_mh_execute_header,  v11,  OS_LOG_TYPE_DEFAULT,  "HIDIdentification - limitedSupportForHID - Known Poor",  (uint8_t *)&buf,  2u);
      }

      sub_10002418C(__p, "HIDDeviceKnownPoorBehavior");
      sub_1005C0684((uint64_t)v5, (uint64_t)__p);
      if (v45 < 0) {
        operator delete(__p[0]);
      }
      goto LABEL_57;
    }

    if (*((char *)v5 + 127) < 0)
    {
      sub_100024238(&buf, (void *)v5[13], v5[14]);
    }

    else
    {
      __int128 buf = *(_OWORD *)(v5 + 13);
      uint64_t v51 = v5[15];
    }

    int v12 = SHIBYTE(v51);
    uint64_t v13 = (__int128 *)buf;
    NSStringEncoding v14 = +[NSString defaultCStringEncoding](&OBJC_CLASS___NSString, "defaultCStringEncoding");
    if (v12 >= 0) {
      p___int128 buf = &buf;
    }
    else {
      p___int128 buf = v13;
    }
    __int128 v16 = (void *)objc_claimAutoreleasedReturnValue( +[NSString stringWithCString:encoding:]( &OBJC_CLASS___NSString,  "stringWithCString:encoding:",  p_buf,  v14));
    if (SHIBYTE(v51) < 0) {
      operator delete((void *)buf);
    }
    if ([(id)qword_1008F79C0 containsObject:v16])
    {
      __int128 v17 = (os_log_s *)qword_1008F75A0;
      if (os_log_type_enabled((os_log_t)qword_1008F75A0, OS_LOG_TYPE_DEFAULT))
      {
        LODWORD(buf) = 138412290;
        *(void *)((char *)&buf + 4) = v16;
        _os_log_impl( (void *)&_mh_execute_header,  v17,  OS_LOG_TYPE_DEFAULT,  "HIDIdentification - WAR for known good LE HID %@",  (uint8_t *)&buf,  0xCu);
      }

      sub_10002418C(v42, "HIDDeviceKnownGoodBehavior");
      sub_1005C0684((uint64_t)v5, (uint64_t)v42);
      if (v43 < 0) {
        operator delete(v42[0]);
      }
      goto LABEL_56;
    }

    id v18 = (id)v5[45];
    int v19 = (void *)objc_claimAutoreleasedReturnValue([(id)qword_1008F79B0 objectForKey:v16]);
    id v20 = (void *)objc_claimAutoreleasedReturnValue([(id)qword_1008F79B8 objectForKey:v16]);
    sub_10002418C(v40, "HIDDeviceKnownGoodBehavior");
    if (v7 == (void *)sub_100024098((uint64_t)(v5 + 22), (const void **)v40))
    {
      sub_10002418C(v38, "HIDDeviceKnownPoorBehavior");
      BOOL v21 = v7 != (void *)sub_100024098((uint64_t)(v5 + 22), (const void **)v38);
      if (v39 < 0) {
        operator delete(v38[0]);
      }
    }

    else
    {
      BOOL v21 = 1;
    }

    if (v41 < 0) {
      operator delete(v40[0]);
    }
    if (v21)
    {
      uint64_t v22 = (os_log_s *)qword_1008F75A0;
      if (!os_log_type_enabled((os_log_t)qword_1008F75A0, OS_LOG_TYPE_DEFAULT))
      {
LABEL_55:

LABEL_56:
LABEL_57:
        uint64_t v26 = (os_log_s *)qword_1008F75A0;
        if (os_log_type_enabled((os_log_t)qword_1008F75A0, OS_LOG_TYPE_DEFAULT))
        {
          if (*((char *)v5 + 127) < 0)
          {
            sub_100024238(&buf, (void *)v5[13], v5[14]);
          }

          else
          {
            __int128 buf = *(_OWORD *)(v5 + 13);
            uint64_t v51 = v5[15];
          }

          uint64_t v27 = &buf;
          if (v51 < 0) {
            uint64_t v27 = (__int128 *)buf;
          }
          *(_DWORD *)uint64_t v48 = 136315138;
          uint64_t v49 = v27;
          _os_log_impl( (void *)&_mh_execute_header,  v26,  OS_LOG_TYPE_DEFAULT,  "Post leHIDBehaviorKnown for %s",  v48,  0xCu);
          if (SHIBYTE(v51) < 0) {
            operator delete((void *)buf);
          }
        }

        uint64_t v28 = (void *)objc_claimAutoreleasedReturnValue( +[NSDistributedNotificationCenter defaultCenter]( &OBJC_CLASS___NSDistributedNotificationCenter,  "defaultCenter"));
        char v29 = (void *)objc_claimAutoreleasedReturnValue( +[NSNotification notificationWithName:object:]( &OBJC_CLASS___NSNotification,  "notificationWithName:object:",  @"com.apple.bluetooth.leHIDBehaviorKnown",  0LL));
        [v28 postNotification:v29];

        goto LABEL_66;
      }

      LOWORD(buf) = 0;
      uint64_t v23 = "HIDIdentification - Device already identified as Good/Poor";
    }

    else
    {
      if ([v18 length] || !*((_BYTE *)v5 + 368))
      {
        if ([v19 isEqualToData:v18])
        {
          sub_10002418C(v36, "HIDDeviceKnownPoorBehavior");
          sub_1005C0684((uint64_t)v5, (uint64_t)v36);
          if ((v37 & 0x80000000) == 0) {
            goto LABEL_55;
          }
          BOOL v24 = (void *)v36[0];
        }

        else if ([v20 isEqualToData:v18])
        {
          sub_10002418C(v34, "HIDDeviceKnownGoodBehavior");
          sub_1005C0684((uint64_t)v5, (uint64_t)v34);
          if ((v35 & 0x80000000) == 0) {
            goto LABEL_55;
          }
          BOOL v24 = (void *)v34[0];
        }

        else
        {
          char v25 = (os_log_s *)qword_1008F75A0;
          if (os_log_type_enabled((os_log_t)qword_1008F75A0, OS_LOG_TYPE_DEFAULT))
          {
            LOWORD(buf) = 0;
            _os_log_impl( (void *)&_mh_execute_header,  v25,  OS_LOG_TYPE_DEFAULT,  "HIDIdentification - Device not found in known good/poor device lists",  (uint8_t *)&buf,  2u);
          }

          if (_os_feature_enabled_impl("BluetoothFeatures", "RuleBasedHIDClassification"))
          {
            sub_10002418C(v32, "HIDDeviceUnknownBehavior");
            sub_1002EE40C((uint64_t **)v5 + 22, v32);
            if ((v33 & 0x80000000) == 0) {
              goto LABEL_55;
            }
            BOOL v24 = (void *)v32[0];
          }

          else
          {
            sub_10002418C(v30, "HIDDeviceUnknownBehavior");
            sub_1005C0684((uint64_t)v5, (uint64_t)v30);
            if ((v31 & 0x80000000) == 0) {
              goto LABEL_55;
            }
            BOOL v24 = v30[0];
          }
        }

        operator delete(v24);
        goto LABEL_55;
      }

      uint64_t v22 = (os_log_s *)qword_1008F75A0;
      if (!os_log_type_enabled((os_log_t)qword_1008F75A0, OS_LOG_TYPE_DEFAULT)) {
        goto LABEL_55;
      }
      LOWORD(buf) = 0;
      uint64_t v23 = "HIDIdentification - No currently available identification data.";
    }

    _os_log_impl((void *)&_mh_execute_header, v22, OS_LOG_TYPE_DEFAULT, v23, (uint8_t *)&buf, 2u);
    goto LABEL_55;
  }

  if (v9)
  {
    LOWORD(buf) = 0;
    _os_log_impl( (void *)&_mh_execute_header,  v8,  OS_LOG_TYPE_DEFAULT,  "Not a mouse - no need to setLEHIDDeviceBehavior",  (uint8_t *)&buf,  2u);
  }

void sub_1005CE1B8( _Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void *__p, uint64_t a11, int a12, __int16 a13, char a14, char a15, uint64_t a16, uint64_t a17, int a18, __int16 a19, char a20, char a21, uint64_t a22, uint64_t a23, int a24, __int16 a25, char a26, char a27, uint64_t a28, uint64_t a29, int a30, __int16 a31, char a32, char a33, void *a34, uint64_t a35, int a36, __int16 a37, char a38, char a39, uint64_t a40, uint64_t a41, int a42, __int16 a43, char a44, char a45, void *a46, uint64_t a47, int a48, __int16 a49, char a50,char a51,void *a52,uint64_t a53,int a54,__int16 a55,char a56,char a57)
{
  if (a15 < 0) {
    operator delete(__p);
  }

  _Unwind_Resume(a1);
}

uint64_t sub_1005CE2FC(uint64_t a1, void *a2)
{
  id v3 = a2;
  v7[0] = 0LL;
  v7[1] = 0LL;
  sub_100242F28((uint64_t)v7, a1 + 80);
  uint64_t v4 = sub_1005C6AC0(a1, v3);
  if (v4) {
    uint64_t v5 = *(unsigned int *)(v4 + 372);
  }
  else {
    uint64_t v5 = 0LL;
  }
  sub_100242FAC((uint64_t)v7);

  return v5;
}

void sub_1005CE364( _Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9)
{
  _Unwind_Resume(a1);
}

uint64_t sub_1005CE384(uint64_t a1, uint64_t (***a2)(void, void, uint64_t))
{
  return (**a2)(a2, *(void *)(a1 + 32), 2LL);
}

void *sub_1005CE3A0(uint64_t a1, void *a2)
{
  id v2 = a2;
  if (qword_1008D5F30 != -1) {
    dispatch_once(&qword_1008D5F30, &stru_1008A3498);
  }
  uint64_t v3 = sub_1005CC198((uint64_t)off_1008D5F28, v2, 0);
  if (v3)
  {
    if (qword_1008D5F50 != -1) {
      dispatch_once(&qword_1008D5F50, &stru_1008A3558);
    }
    uint64_t v4 = sub_10040007C(off_1008D5F48, v3, 0);
  }

  else
  {
    if (os_log_type_enabled((os_log_t)qword_1008F75A0, OS_LOG_TYPE_ERROR)) {
      sub_10069B25C();
    }
    uint64_t v4 = 0LL;
  }

  return v4;
}

void sub_1005CE480(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_1005CE490(uint64_t a1, void *a2)
{
  id v3 = a2;
  sub_10002418C(__p, "HasTS");
  sub_1005CCF08(a1, v3, (unsigned __int8 *)__p);
  if (v5 < 0) {
    operator delete(__p[0]);
  }
}

void sub_1005CE4F0( _Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void *__p, uint64_t a11, int a12, __int16 a13, char a14, char a15)
{
  if (a15 < 0) {
    operator delete(__p);
  }

  _Unwind_Resume(a1);
}

unint64_t sub_1005CE518(uint64_t a1, void *a2)
{
  id v3 = a2;
  sub_10002418C(__p, "HasTS");
  unint64_t v4 = sub_1005CE5A8(a1, v3, (uint64_t)__p);
  if (v7 < 0) {
    operator delete(__p[0]);
  }

  return v4;
}

void sub_1005CE580( _Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void *__p, uint64_t a11, int a12, __int16 a13, char a14, char a15)
{
  if (a15 < 0) {
    operator delete(__p);
  }

  _Unwind_Resume(a1);
}

unint64_t sub_1005CE5A8(uint64_t a1, void *a2, uint64_t a3)
{
  id v5 = a2;
  v14[0] = 0LL;
  v14[1] = 0LL;
  sub_100242F28((uint64_t)v14, a1 + 80);
  unint64_t v6 = (unint64_t)sub_1005C6AC0(a1, v5);
  if (v6)
  {
    if (*(char *)(a3 + 23) < 0)
    {
      sub_100024238(__p, *(void **)a3, *(void *)(a3 + 8));
    }

    else
    {
      *(_OWORD *)std::string __p = *(_OWORD *)a3;
      uint64_t v13 = *(void *)(a3 + 16);
    }

    unint64_t v6 = v6 + 184 != sub_100024098(v6 + 176, (const void **)__p);
    if (SHIBYTE(v13) < 0) {
      operator delete(__p[0]);
    }
  }

  sub_100242F54((uint64_t)v14);
  int v8 = sub_1005CE3A0(v7, v5);
  if (v8)
  {
    unsigned __int8 v11 = 0;
    uint64_t v9 = sub_1002E6D7C();
    if ((*(unsigned int (**)(uint64_t, void *, uint64_t, unsigned __int8 *))(*(void *)v9 + 784LL))( v9,  v8,  a3,  &v11))
    {
      unint64_t v6 = v6;
    }

    else
    {
      unint64_t v6 = (v11 | v6) != 0;
    }
  }

  sub_100242FAC((uint64_t)v14);

  return v6;
}

void sub_1005CE6B4( _Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, void *__p, uint64_t a12, int a13, __int16 a14, char a15, char a16, uint64_t a17, char a18)
{
  if (a16 < 0) {
    operator delete(__p);
  }
  sub_100242FAC((uint64_t)&a18);

  _Unwind_Resume(a1);
}

uint64_t sub_1005CE6F8(uint64_t a1, uint64_t (***a2)(void, void, uint64_t))
{
  return (**a2)(a2, *(void *)(a1 + 32), 3LL);
}

id sub_1005CE714(uint64_t a1, uint64_t a2)
{
  unint64_t v4 = (void *)objc_claimAutoreleasedReturnValue(+[NSMutableArray array](&OBJC_CLASS___NSMutableArray, "array"));
  v19[0] = 0LL;
  v19[1] = 0LL;
  sub_100242F28((uint64_t)v19, a1 + 80);
  __int128 v17 = 0u;
  __int128 v18 = 0u;
  __int128 v15 = 0u;
  __int128 v16 = 0u;
  id v5 = *(id *)(a1 + 160);
  id v6 = [v5 countByEnumeratingWithState:&v15 objects:v20 count:16];
  if (v6)
  {
    uint64_t v7 = *(void *)v16;
    do
    {
      for (uint64_t i = 0LL; i != v6; uint64_t i = (char *)i + 1)
      {
        if (*(void *)v16 != v7) {
          objc_enumerationMutation(v5);
        }
        uint64_t v9 = *(void *)(*((void *)&v15 + 1) + 8LL * (void)i);
        uint64_t v10 = (char *)objc_msgSend(*(id *)(a1 + 160), "objectForKey:", v9, __p[0], __p[1], v14);
        if (*(char *)(a2 + 23) < 0)
        {
          sub_100024238(__p, *(void **)a2, *(void *)(a2 + 8));
        }

        else
        {
          *(_OWORD *)std::string __p = *(_OWORD *)a2;
          uint64_t v14 = *(void *)(a2 + 16);
        }

        uint64_t v11 = sub_100024098((uint64_t)(v10 + 176), (const void **)__p);
        if (SHIBYTE(v14) < 0) {
          operator delete(__p[0]);
        }
      }

      id v6 = [v5 countByEnumeratingWithState:&v15 objects:v20 count:16];
    }

    while (v6);
  }

  sub_100242F54((uint64_t)v19);
  sub_100242FAC((uint64_t)v19);
  return v4;
}

void sub_1005CE8B8( _Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, void *__p, uint64_t a10, int a11, __int16 a12, char a13, char a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20, uint64_t a21, uint64_t a22, uint64_t a23, char a24)
{
  _Unwind_Resume(a1);
}

void sub_1005CE910(uint64_t a1@<X0>, void *a2@<X1>, uint64_t *a3@<X8>)
{
  id v5 = a2;
  a3[2] = 0LL;
  a3[1] = 0LL;
  *a3 = (uint64_t)(a3 + 1);
  id v6 = sub_1005CE3A0((uint64_t)v5, v5);
  v22[0] = 0LL;
  v22[1] = 0LL;
  sub_100242F28((uint64_t)v22, a1 + 80);
  uint64_t v7 = (const void ***)sub_1005C6AC0(a1, v5);
  if (v7) {
    sub_100291978(a3, v7[22], v7 + 23);
  }
  if (v6)
  {
    uint64_t v8 = sub_1002E6D7C();
    uint64_t v9 = (*(uint64_t (**)(uint64_t, void *))(*(void *)v8 + 824LL))(v8, v6);
    uint64_t v10 = (void *)objc_claimAutoreleasedReturnValue(v9);
    uint64_t v11 = v10;
    if (v10)
    {
      __int128 v20 = 0u;
      __int128 v21 = 0u;
      __int128 v18 = 0u;
      __int128 v19 = 0u;
      id v12 = v10;
      id v13 = [v12 countByEnumeratingWithState:&v18 objects:v23 count:16];
      if (v13)
      {
        uint64_t v14 = *(void *)v19;
        do
        {
          __int128 v15 = 0LL;
          do
          {
            if (*(void *)v19 != v14) {
              objc_enumerationMutation(v12);
            }
            sub_10002418C( __p, (char *)[*(id *)(*((void *)&v18 + 1) + 8 * (void)v15) UTF8String]);
            sub_1004F5958((uint64_t **)a3, (const void **)__p, (uint64_t)__p);
            if (v17 < 0) {
              operator delete(__p[0]);
            }
            __int128 v15 = (char *)v15 + 1;
          }

          while (v13 != v15);
          id v13 = [v12 countByEnumeratingWithState:&v18 objects:v23 count:16];
        }

        while (v13);
      }
    }
  }

  sub_100242FAC((uint64_t)v22);
}

void sub_1005CEABC( _Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void *__p, uint64_t a11, int a12, __int16 a13, char a14, char a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20, uint64_t a21, uint64_t a22, uint64_t a23, uint64_t a24, char a25)
{
  sub_100242FAC((uint64_t)&a25);
  sub_10023E78C(v26, *(char **)(v26 + 8));

  _Unwind_Resume(a1);
}

id sub_1005CEB2C(uint64_t a1, void *a2)
{
  id v3 = a2;
  unint64_t v4 = (void *)objc_claimAutoreleasedReturnValue(+[NSMutableArray array](&OBJC_CLASS___NSMutableArray, "array"));
  __int128 v15 = 0LL;
  __int128 v16 = 0LL;
  uint64_t v17 = 0LL;
  sub_1002DC6C0(*(void *)(a1 + 240), v3, (uint64_t)&v15);
  id v5 = v15;
  for (i = v16; v5 != i; id v5 = (__int128 *)((char *)v5 + 24))
  {
    __p[0] = 0LL;
    __p[1] = 0LL;
    uint64_t v14 = 0LL;
    if (*((char *)v5 + 23) < 0)
    {
      sub_100024238(__p, *(void **)v5, *((void *)v5 + 1));
    }

    else
    {
      __int128 v7 = *v5;
      uint64_t v14 = *((void *)v5 + 2);
      *(_OWORD *)std::string __p = v7;
    }

    uint64_t v8 = objc_alloc(&OBJC_CLASS___NSUUID);
    if (v14 >= 0) {
      uint64_t v9 = __p;
    }
    else {
      uint64_t v9 = (void **)__p[0];
    }
    uint64_t v10 = (void *)objc_claimAutoreleasedReturnValue( +[NSString stringWithUTF8String:]( &OBJC_CLASS___NSString,  "stringWithUTF8String:",  v9,  __p[0],  __p[1],  v14));
    uint64_t v11 = -[NSUUID initWithUUIDString:](v8, "initWithUUIDString:", v10);

    [v4 addObject:v11];
    if (SHIBYTE(v14) < 0) {
      operator delete(__p[0]);
    }
  }

  __p[0] = &v15;
  sub_100024304((void ***)__p);

  return v4;
}

void sub_1005CEC70( _Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, void *__p, uint64_t a10, int a11, __int16 a12, char a13, char a14, char a15)
{
  _Unwind_Resume(a1);
}

id sub_1005CECD8(uint64_t a1, void *a2)
{
  id v3 = a2;
  v8[0] = 0LL;
  v8[1] = 0LL;
  sub_100242F28((uint64_t)v8, a1 + 80);
  unint64_t v4 = sub_1005C6AC0(a1, v3);
  if (v4)
  {
    id v5 = sub_1005C50F4((uint64_t)v4);
    id v6 = (void *)objc_claimAutoreleasedReturnValue(v5);
  }

  else
  {
    id v6 = &__NSArray0__struct;
  }

  sub_100242FAC((uint64_t)v8);

  return v6;
}

void sub_1005CED4C( _Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9)
{
  _Unwind_Resume(a1);
}

id sub_1005CED70(uint64_t a1, void *a2, void *a3)
{
  id v5 = a2;
  id v6 = a3;
  v11[0] = 0LL;
  v11[1] = 0LL;
  sub_100242F28((uint64_t)v11, a1 + 80);
  if (!v5)
  {
    if (os_log_type_enabled((os_log_t)qword_1008F75A0, OS_LOG_TYPE_ERROR)) {
      sub_100689E18();
    }
    goto LABEL_9;
  }

  if (!v6)
  {
    if (os_log_type_enabled((os_log_t)qword_1008F75A0, OS_LOG_TYPE_ERROR)) {
      sub_10069B2C0();
    }
    goto LABEL_9;
  }

  __int128 v7 = sub_1005C6AC0(a1, v5);
  if (!v7)
  {
LABEL_9:
    uint64_t v9 = 0LL;
    goto LABEL_10;
  }

  id v8 = sub_1005C5120((uint64_t)v7, v6);
  uint64_t v9 = (void *)objc_claimAutoreleasedReturnValue(v8);
LABEL_10:
  sub_100242FAC((uint64_t)v11);

  return v9;
}

void sub_1005CEE54( _Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9)
{
  _Unwind_Resume(a1);
}

uint64_t sub_1005CEE7C(uint64_t a1, void *a2, void *a3, void *a4)
{
  id v7 = a2;
  id v8 = a3;
  id v9 = a4;
  if (v7)
  {
    if (v8 && (unint64_t)[v8 length] < 0x401)
    {
      if ((unint64_t)[v9 length] <= 0x400)
      {
        uint64_t v11 = sub_1005C6AC0(a1, v7);
        if (v11)
        {
          v13[0] = 0LL;
          v13[1] = 0LL;
          sub_100242F28((uint64_t)v13, a1 + 80);
          if (sub_1005C51A8((uint64_t)v11, v8, v9))
          {
            sub_100242F54((uint64_t)v13);
            sub_100241F90(v14, v7);
            sub_1005CB37C(a1, v14);
          }

          sub_100242FAC((uint64_t)v13);
          uint64_t v10 = 0LL;
        }

        else
        {
          if (os_log_type_enabled((os_log_t)qword_1008F75A0, OS_LOG_TYPE_ERROR)) {
            sub_10069B2EC();
          }
          uint64_t v10 = 2LL;
        }
      }

      else
      {
        uint64_t v10 = 11LL;
      }
    }

    else
    {
      if (os_log_type_enabled((os_log_t)qword_1008F75A0, OS_LOG_TYPE_ERROR)) {
        sub_10069B2C0();
      }
      uint64_t v10 = 10LL;
    }
  }

  else
  {
    if (os_log_type_enabled((os_log_t)qword_1008F75A0, OS_LOG_TYPE_ERROR)) {
      sub_100689E18();
    }
    uint64_t v10 = 1LL;
  }

  return v10;
}

void sub_1005CF024(_Unwind_Exception *a1, uint64_t a2, ...)
{
  _Unwind_Resume(a1);
}

void sub_1005CF060(uint64_t a1@<X0>, void *a2@<X1>, uint64_t a3@<X8>)
{
  id v5 = a2;
  v8[0] = 0LL;
  v8[1] = 0LL;
  sub_100242F28((uint64_t)v8, a1 + 80);
  id v6 = sub_1005C6AC0(a1, v5);
  if (v6)
  {
    if (*((char *)v6 + 231) < 0)
    {
      sub_100024238((_BYTE *)a3, (void *)v6[26], v6[27]);
    }

    else
    {
      __int128 v7 = *((_OWORD *)v6 + 13);
      *(void *)(a3 + 16) = v6[28];
      *(_OWORD *)a3 = v7;
    }
  }

  else
  {
    *(void *)a3 = 0LL;
    *(void *)(a3 + 8) = 0LL;
    *(void *)(a3 + 16) = 0LL;
  }

  sub_100242FAC((uint64_t)v8);
}

void sub_1005CF0FC(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_1005CF11C(uint64_t a1, void *a2, const std::string *a3)
{
  id v5 = a2;
  v7[0] = 0LL;
  v7[1] = 0LL;
  sub_100242F28((uint64_t)v7, a1 + 80);
  id v6 = sub_1005C6AC0(a1, v5);
  if (v6)
  {
    std::string::operator=((std::string *)(v6 + 26), a3);
    sub_100241F90(v8, v5);
    sub_1005CB37C(a1, v8);
  }

  sub_100242FAC((uint64_t)v7);
}

void sub_1005CF1D0(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

BOOL sub_1005CF1FC(uint64_t a1, void *a2)
{
  id v3 = a2;
  v8[0] = 0LL;
  v8[1] = 0LL;
  sub_100242F28((uint64_t)v8, a1 + 80);
  unint64_t v4 = sub_1005C6AC0(a1, v3);
  if (v4)
  {
    else {
      uint64_t v5 = *((unsigned __int8 *)v4 + 231);
    }
    BOOL v6 = v5 != 0;
  }

  else
  {
    BOOL v6 = 0LL;
  }

  sub_100242FAC((uint64_t)v8);

  return v6;
}

void sub_1005CF27C( _Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9)
{
  _Unwind_Resume(a1);
}

id sub_1005CF29C(uint64_t a1, unsigned __int8 *a2)
{
  v26[0] = 0LL;
  v26[1] = 0LL;
  sub_100242F28((uint64_t)v26, a1 + 80);
  __int128 v24 = 0u;
  __int128 v25 = 0u;
  __int128 v22 = 0u;
  __int128 v23 = 0u;
  id v5 = *(id *)(a1 + 160);
  id v6 = [v5 countByEnumeratingWithState:&v22 objects:v27 count:16];
  if (!v6) {
    goto LABEL_34;
  }
  uint64_t v7 = *(void *)v23;
  do
  {
    id v8 = 0LL;
    do
    {
      if (*(void *)v23 != v7) {
        objc_enumerationMutation(v5);
      }
      id v9 = *(void **)(*((void *)&v22 + 1) + 8LL * (void)v8);
      uint64_t v10 = (char *)objc_msgSend(*(id *)(a1 + 160), "objectForKey:", v9, __p[0]);
      __p[0] = 0LL;
      __p[1] = 0LL;
      uint64_t v21 = 0LL;
      if (v10[231] < 0)
      {
        sub_100024238(__p, *((void **)v10 + 26), *((void *)v10 + 27));
      }

      else
      {
        *(_OWORD *)std::string __p = *((_OWORD *)v10 + 13);
        uint64_t v21 = *((void *)v10 + 28);
      }

      char v11 = HIBYTE(v21);
      id v12 = __p[1];
      if (v21 >= 0) {
        id v12 = (void *)HIBYTE(v21);
      }
      if (!v12) {
        goto LABEL_26;
      }
      uint64_t v13 = a2[23];
      uint64_t v14 = (v13 & 0x80u) == 0LL ? (void *)a2[23] : (void *)*((void *)a2 + 1);
      if (v14 != v12) {
        goto LABEL_26;
      }
      if (v21 >= 0) {
        __int128 v15 = __p;
      }
      else {
        __int128 v15 = (void **)__p[0];
      }
      if ((v13 & 0x80) != 0)
      {
      }

      else if (a2[23])
      {
        __int128 v16 = a2;
        while (*v16 == *(unsigned __int8 *)v15)
        {
          ++v16;
          __int128 v15 = (void **)((char *)v15 + 1);
          if (!--v13) {
            goto LABEL_31;
          }
        }

void sub_1005CF4A8( _Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, ...)
{
  sub_100242FAC((uint64_t)va);
  _Unwind_Resume(a1);
}

uint64_t sub_1005CF4D8(uint64_t a1, void *a2)
{
  id v3 = a2;
  v7[0] = 0LL;
  v7[1] = 0LL;
  sub_100242F28((uint64_t)v7, a1 + 80);
  unint64_t v4 = sub_1005C6AC0(a1, v3);
  if (v4) {
    uint64_t v5 = *((unsigned __int16 *)v4 + 128);
  }
  else {
    uint64_t v5 = 0LL;
  }
  sub_100242FAC((uint64_t)v7);

  return v5;
}

void sub_1005CF540( _Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9)
{
  _Unwind_Resume(a1);
}

void sub_1005CF560(uint64_t a1, void *a2, __int16 a3)
{
  id v5 = a2;
  v7[0] = 0LL;
  v7[1] = 0LL;
  sub_100242F28((uint64_t)v7, a1 + 80);
  id v6 = sub_1005C6AC0(a1, v5);
  if (v6) {
    *((_WORD *)v6 + 128) = a3;
  }
  sub_100242FAC((uint64_t)v7);
}

void sub_1005CF5C8( _Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9)
{
  _Unwind_Resume(a1);
}

void sub_1005CF5E8(uint64_t a1)
{
}

void sub_1005CF5F0(uint64_t a1, char a2)
{
  if ((a2 & 1) == 0) {
    sub_1005CB544(a1, 1);
  }
}

uint64_t sub_1005CF600(uint64_t a1, void *a2)
{
  id v3 = a2;
  v7[0] = 0LL;
  v7[1] = 0LL;
  sub_100242F28((uint64_t)v7, a1 + 80);
  unint64_t v4 = sub_1005C6AC0(a1, v3);
  if (v4) {
    uint64_t v5 = *((unsigned __int8 *)v4 + 258);
  }
  else {
    uint64_t v5 = 0LL;
  }
  sub_100242FAC((uint64_t)v7);

  return v5;
}

void sub_1005CF668( _Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9)
{
  _Unwind_Resume(a1);
}

void sub_1005CF688(uint64_t a1, void *a2, int a3)
{
  id v5 = a2;
  v7[0] = 0LL;
  v7[1] = 0LL;
  sub_100242F28((uint64_t)v7, a1 + 80);
  id v6 = sub_1005C6AC0(a1, v5);
  if (v6) {
    *((_BYTE *)v6 + 258) = a3;
  }
  sub_100242FAC((uint64_t)v7);
}

void sub_1005CF728( _Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9)
{
  _Unwind_Resume(a1);
}

uint64_t sub_1005CF748(uint64_t a1, void *a2)
{
  id v3 = a2;
  v7[0] = 0LL;
  v7[1] = 0LL;
  sub_100242F28((uint64_t)v7, a1 + 80);
  unint64_t v4 = sub_1005C6AC0(a1, v3);
  if (v4) {
    uint64_t v5 = *((unsigned __int8 *)v4 + 259);
  }
  else {
    uint64_t v5 = 0LL;
  }
  sub_100242FAC((uint64_t)v7);

  return v5;
}

void sub_1005CF7B0( _Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9)
{
  _Unwind_Resume(a1);
}

void sub_1005CF7D0(uint64_t a1, void *a2, unsigned int a3)
{
  id v5 = a2;
  v7[0] = 0LL;
  v7[1] = 0LL;
  sub_100242F28((uint64_t)v7, a1 + 80);
  if (a3 >= 4 && os_log_type_enabled((os_log_t)qword_1008F75A0, OS_LOG_TYPE_FAULT)) {
    sub_10069B378();
  }
  id v6 = sub_1005C6AC0(a1, v5);
  if (v6) {
    *((_BYTE *)v6 + 259) = a3;
  }
  sub_100242FAC((uint64_t)v7);
}

void sub_1005CF86C( _Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9)
{
  _Unwind_Resume(a1);
}

uint64_t sub_1005CF88C(uint64_t a1, void *a2)
{
  id v3 = a2;
  v8[0] = 0LL;
  v8[1] = 0LL;
  sub_100242F28((uint64_t)v8, a1 + 80);
  unint64_t v4 = sub_1005C6AC0(a1, v3);
  if (v4) {
    BOOL v5 = *((_BYTE *)v4 + 264) != 0;
  }
  uint64_t v6 = (v4 != 0LL) & v5;
  sub_100242FAC((uint64_t)v8);

  return v6;
}

void sub_1005CF904( _Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9)
{
  _Unwind_Resume(a1);
}

void sub_1005CF924(uint64_t a1, void *a2, uint64_t a3)
{
  id v5 = a2;
  v14[0] = 0LL;
  v14[1] = 0LL;
  sub_100242F28((uint64_t)v14, a1 + 80);
  uint64_t v6 = (os_log_s *)qword_1008F75A0;
  if (os_log_type_enabled((os_log_t)qword_1008F75A0, OS_LOG_TYPE_DEBUG)) {
    sub_10069B3D8(a3, v6, v7, v8, v9, v10, v11, v12);
  }
  uint64_t v13 = sub_1005C6AC0(a1, v5);
  if (v13) {
    *((_BYTE *)v13 + 264) = a3;
  }
  sub_100242FAC((uint64_t)v14);
}

void sub_1005CF9B8( _Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9)
{
  _Unwind_Resume(a1);
}

uint64_t sub_1005CF9D8(uint64_t a1, void *a2)
{
  id v3 = a2;
  v8[0] = 0LL;
  v8[1] = 0LL;
  sub_100242F28((uint64_t)v8, a1 + 80);
  unint64_t v4 = sub_1005C6AC0(a1, v3);
  if (v4) {
    BOOL v5 = *((_BYTE *)v4 + 265) != 0;
  }
  uint64_t v6 = (v4 != 0LL) & v5;
  sub_100242FAC((uint64_t)v8);

  return v6;
}

void sub_1005CFA50( _Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9)
{
  _Unwind_Resume(a1);
}

void sub_1005CFA70(uint64_t a1, void *a2, char a3)
{
  id v5 = a2;
  v7[0] = 0LL;
  v7[1] = 0LL;
  sub_100242F28((uint64_t)v7, a1 + 80);
  uint64_t v6 = sub_1005C6AC0(a1, v5);
  if (v6) {
    *((_BYTE *)v6 + 265) = a3;
  }
  sub_100242FAC((uint64_t)v7);
}

void sub_1005CFAD8( _Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9)
{
  _Unwind_Resume(a1);
}

uint64_t sub_1005CFAF8(uint64_t a1, void *a2)
{
  id v3 = a2;
  v7[0] = 0LL;
  v7[1] = 0LL;
  sub_100242F28((uint64_t)v7, a1 + 80);
  unint64_t v4 = sub_1005C6AC0(a1, v3);
  if (v4) {
    char v5 = *((_BYTE *)v4 + 385);
  }
  else {
    char v5 = 0;
  }
  sub_100242FAC((uint64_t)v7);

  return v5;
}

void sub_1005CFB60( _Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9)
{
  _Unwind_Resume(a1);
}

void sub_1005CFB80(uint64_t a1, void *a2, char a3)
{
  id v5 = a2;
  v7[0] = 0LL;
  v7[1] = 0LL;
  sub_100242F28((uint64_t)v7, a1 + 80);
  uint64_t v6 = sub_1005C6AC0(a1, v5);
  if (v6) {
    *((_BYTE *)v6 + 385) = a3;
  }
  sub_100242FAC((uint64_t)v7);
}

void sub_1005CFBE8( _Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9)
{
  _Unwind_Resume(a1);
}

void sub_1005CFC08(uint64_t a1, void *a2, char a3)
{
  id v5 = a2;
  v7[0] = 0LL;
  v7[1] = 0LL;
  sub_100242F28((uint64_t)v7, a1 + 80);
  uint64_t v6 = sub_1005C6AC0(a1, v5);
  if (v6) {
    *((_BYTE *)v6 + 384) = a3;
  }
  sub_100242FAC((uint64_t)v7);
}

void sub_1005CFC70( _Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9)
{
  _Unwind_Resume(a1);
}

uint64_t sub_1005CFC90(uint64_t a1, void *a2)
{
  id v3 = a2;
  v7[0] = 0LL;
  v7[1] = 0LL;
  sub_100242F28((uint64_t)v7, a1 + 80);
  unint64_t v4 = sub_1005C6AC0(a1, v3);
  if (v4) {
    uint64_t v5 = *((unsigned __int16 *)v4 + 197);
  }
  else {
    uint64_t v5 = 0LL;
  }
  sub_100242FAC((uint64_t)v7);

  return v5;
}

void sub_1005CFCF8( _Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9)
{
  _Unwind_Resume(a1);
}

void sub_1005CFD18(uint64_t a1, void *a2, __int16 a3)
{
  id v5 = a2;
  v7[0] = 0LL;
  v7[1] = 0LL;
  sub_100242F28((uint64_t)v7, a1 + 80);
  uint64_t v6 = sub_1005C6AC0(a1, v5);
  if (v6) {
    *((_WORD *)v6 + 197) = a3;
  }
  sub_100242FAC((uint64_t)v7);
}

void sub_1005CFD80( _Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9)
{
  _Unwind_Resume(a1);
}

void sub_1005CFDA0(uint64_t a1, void *a2, char a3)
{
  v28[0] = 0LL;
  v28[1] = 0LL;
  id v21 = a2;
  sub_100242F28((uint64_t)v28, a1 + 80);
  __int128 v26 = 0u;
  __int128 v27 = 0u;
  __int128 v24 = 0u;
  __int128 v25 = 0u;
  id v4 = v21;
  id v5 = [v4 countByEnumeratingWithState:&v24 objects:v33 count:16];
  if (v5)
  {
    uint64_t v22 = *(void *)v25;
    do
    {
      for (uint64_t i = 0LL; i != v5; uint64_t i = (char *)i + 1)
      {
        if (*(void *)v25 != v22) {
          objc_enumerationMutation(v4);
        }
        id v7 = *(id *)(*((void *)&v24 + 1) + 8LL * (void)i);
        uint64_t v8 = objc_autoreleasePoolPush();
        uint64_t v9 = (void *)objc_claimAutoreleasedReturnValue([v4 objectForKeyedSubscript:v7]);
        id v10 = [v9 unsignedLongLongValue];

        uint64_t v11 = (os_log_s *)qword_1008F75A0;
        if (os_log_type_enabled((os_log_t)qword_1008F75A0, OS_LOG_TYPE_INFO))
        {
          id v12 = sub_1005BFB9C((uint64_t)v10);
          uint64_t v13 = (void *)objc_claimAutoreleasedReturnValue(v12);
          *(_DWORD *)__int128 buf = 138543618;
          id v30 = v7;
          __int16 v31 = 2114;
          BOOL v32 = v13;
          _os_log_impl( (void *)&_mh_execute_header,  v11,  OS_LOG_TYPE_INFO,  "Attempting to load paired device %{public}@ (%{public}@) from the device cache",  buf,  0x16u);
        }

        uint64_t v14 = sub_1002DC904(*(void *)(a1 + 240), v7, (uint64_t)v10, a3);
        if (v14)
        {
          sub_1005D00CC(a1, v14);
          __int128 v15 = (os_log_s *)qword_1008F75A0;
          if (os_log_type_enabled((os_log_t)qword_1008F75A0, OS_LOG_TYPE_DEFAULT))
          {
            id v16 = sub_1005BFB9C((uint64_t)v10);
            int v17 = (void *)objc_claimAutoreleasedReturnValue(v16);
            *(_DWORD *)__int128 buf = 138543618;
            id v30 = v7;
            __int16 v31 = 2114;
            BOOL v32 = v17;
            _os_log_impl( (void *)&_mh_execute_header,  v15,  OS_LOG_TYPE_DEFAULT,  "Successfully reconciled paired device %{public}@ (%{public}@)",  buf,  0x16u);
          }
        }

        else
        {
          id v18 = (os_log_s *)qword_1008F75A0;
          if (os_log_type_enabled((os_log_t)qword_1008F75A0, OS_LOG_TYPE_DEFAULT))
          {
            id v19 = sub_1005BFB9C((uint64_t)v10);
            __int128 v20 = (void *)objc_claimAutoreleasedReturnValue(v19);
            *(_DWORD *)__int128 buf = 138543362;
            id v30 = v20;
            _os_log_impl( (void *)&_mh_execute_header,  v18,  OS_LOG_TYPE_DEFAULT,  "could not find (%{public}@) in the paired devices database",  buf,  0xCu);
          }
        }

        objc_autoreleasePoolPop(v8);
      }

      id v5 = [v4 countByEnumeratingWithState:&v24 objects:v33 count:16];
    }

    while (v5);
  }

  sub_100242FAC((uint64_t)v28);
}

void sub_1005D0068( _Unwind_Exception *a1, uint64_t a2, void *a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, ...)
{
  sub_100242FAC((uint64_t)va);
  _Unwind_Resume(a1);
}

void sub_1005D00CC(uint64_t a1, uint64_t a2)
{
  uint64_t v3 = a1;
  if (!a2 && os_log_type_enabled((os_log_t)qword_1008F75A0, OS_LOG_TYPE_FAULT))
  {
    sub_10069B500();
    uint64_t v3 = a1;
  }

  id v4 = *(id *)a2;
  v72[0] = 0LL;
  v72[1] = 0LL;
  id v56 = v4;
  sub_100242F28((uint64_t)v72, v3 + 80);
  id v5 = [*(id *)(v3 + 160) objectForKey:v4];
  [*(id *)(v3 + 160) setObject:a2 forKey:v4];
  if (v5)
  {
    uint64_t v6 = (os_log_s *)qword_1008F75A0;
    if (os_log_type_enabled((os_log_t)qword_1008F75A0, OS_LOG_TYPE_DEFAULT))
    {
      uint64_t v7 = v5[60];
      uint64_t v8 = *(void *)(a2 + 480);
      *(_DWORD *)__int128 buf = 134218240;
      *(void *)&buf[2] = v7;
      buf[6] = 2048;
      *(void *)&buf[7] = v8;
      _os_log_impl( (void *)&_mh_execute_header,  v6,  OS_LOG_TYPE_DEFAULT,  "MUC - Old device exist - copy current IDS user address 0x%llx in new device 0x%llx",  (uint8_t *)buf,  0x16u);
    }

    sub_1005D3F50(a2, (uint64_t)v5);
    uint64_t v9 = (void *)sub_1005DC5C8((uint64_t)v5);
    operator delete(v9);
  }

  *(void *)src = 0LL;
  uint64_t v93 = 0LL;
  sub_100241F90(src, v4);
  *(void *)std::string __p = *(void *)(a2 + 16);
  *(void *)__int128 buf = __p;
  uint64_t v61 = v3 + 168;
  id v10 = sub_1005DCEAC(v3 + 168, (unint64_t *)__p, (uint64_t)&unk_1006C2518, (void **)buf);
  uuid_copy((unsigned __int8 *)v10 + 40, src);
  if (*(void *)(a2 + 24))
  {
    *(void *)std::string __p = *(void *)(a2 + 24);
    *(void *)__int128 buf = __p;
    uint64_t v11 = sub_1005DCEAC(v61, (unint64_t *)__p, (uint64_t)&unk_1006C2518, (void **)buf);
    uuid_copy((unsigned __int8 *)v11 + 40, src);
  }

  id v12 = (unsigned __int8 *)(v3 + 192);
  for (uint64_t i = *(unsigned __int8 **)(v3 + 200); i != v12; uint64_t i = (unsigned __int8 *)*((void *)i + 1))
  {
    if (!uuid_compare(i + 16, src))
    {
      if (i != v12)
      {
        uint64_t v14 = *(void *)i;
        *(void *)(v14 + 8) = *((void *)i + 1);
        **((void **)i + 1) = v14;
        --*(void *)(v3 + 208);
        operator delete(i);
      }

      break;
    }
  }

  __int128 v15 = sub_1005DCFE8(v3 + 192, 0LL, 0LL, src);
  uint64_t v59 = v3 + 192;
  void *v15 = v12;
  id v16 = *(void **)(v3 + 200);
  v15[1] = v16;
  void *v16 = v15;
  uint64_t v17 = *(void *)(v3 + 208);
  *(void *)(v3 + 200) = v15;
  *(void *)(v3 + 208) = v17 + 1;
  __int128 v90 = 0u;
  __int128 v91 = 0u;
  __int128 v88 = 0u;
  __int128 v89 = 0u;
  __int128 v86 = 0u;
  __int128 v87 = 0u;
  memset(buf, 0, sizeof(buf));
  unsigned int v18 = (unsigned __int16)(v17 + 1);
  if ((signed int)v18 > *(_DWORD *)(v3 + 144))
  {
    if (os_log_type_enabled((os_log_t)qword_1008F75A0, OS_LOG_TYPE_DEBUG))
    {
      sub_10069B484();
      uint64_t v3 = a1;
    }

    int v19 = 0;
    unsigned __int16 v55 = 0;
    int v64 = 0;
    uint64_t v63 = 0LL;
    unsigned __int16 v62 = 0;
    unsigned __int16 v20 = 0;
    unsigned __int16 v21 = 0;
    uint64_t v57 = v3 + 264;
    if (v18 <= 1) {
      int v22 = 1;
    }
    else {
      int v22 = v18;
    }
    int v58 = v22;
    do
    {
      while (1)
      {
        int v23 = v19 + 1;
        if (v58 == v19 + 1)
        {
          char v45 = (os_log_s *)qword_1008F75A0;
          if (os_log_type_enabled((os_log_t)qword_1008F75A0, OS_LOG_TYPE_ERROR))
          {
            *(_DWORD *)std::string __p = 67110656;
            *(_DWORD *)&__p[4] = v21;
            *(_WORD *)&__p[8] = 1024;
            *(_DWORD *)&__p[10] = v20;
            *(_WORD *)&__p[14] = 1024;
            *(_DWORD *)&__p[16] = v62;
            *(_WORD *)&__p[20] = 1024;
            *(_DWORD *)&__p[22] = (unsigned __int16)v63;
            *(_WORD *)&__p[26] = 1024;
            *(_DWORD *)&__p[28] = WORD2(v63);
            __int16 v78 = 1024;
            *(_DWORD *)__int128 v79 = (unsigned __int16)v64;
            *(_WORD *)&v79[4] = 1024;
            *(_DWORD *)&v79[6] = v55;
            _os_log_error_impl( (void *)&_mh_execute_header,  v45,  OS_LOG_TYPE_ERROR,  "Device List Full with numConnected %d numConnecting %d numLEPaired %d numClassicPaired %d numOfFindMyDevic es %d numOfFastLeConnection %d numConnectOrPaired %d",  __p,  0x2Cu);
            char v45 = (os_log_s *)qword_1008F75A0;
          }

          uint64_t v46 = 0LL;
          while (1)
          {
            if (os_log_type_enabled(v45, OS_LOG_TYPE_DEFAULT))
            {
              int v47 = (unsigned __int16)buf[v46];
              if ((v46 & 1) != 0) {
                uint64_t v48 = "Y";
              }
              else {
                uint64_t v48 = "N";
              }
              *(_DWORD *)std::string __p = 136316674;
              if ((v46 & 2) != 0) {
                uint64_t v49 = "Y";
              }
              else {
                uint64_t v49 = "N";
              }
              *(void *)&__p[4] = v48;
              if ((v46 & 4) != 0) {
                uint64_t v50 = "Y";
              }
              else {
                uint64_t v50 = "N";
              }
              *(_WORD *)&_BYTE __p[12] = 2080;
              if ((v46 & 8) != 0) {
                uint64_t v51 = "Y";
              }
              else {
                uint64_t v51 = "N";
              }
              *(void *)&__p[14] = v49;
              if ((v46 & 0x10) != 0) {
                uint64_t v52 = "Y";
              }
              else {
                uint64_t v52 = "N";
              }
              *(_WORD *)&__p[22] = 2080;
              if ((v46 & 0x20) != 0) {
                uint64_t v53 = "Y";
              }
              else {
                uint64_t v53 = "N";
              }
              *(void *)&__p[24] = v50;
              __int16 v78 = 2080;
              *(void *)__int128 v79 = v51;
              *(_WORD *)&v79[8] = 2080;
              __int128 v80 = v52;
              __int16 v81 = 2080;
              os_unfair_lock_s v82 = v53;
              __int16 v83 = 1024;
              int v84 = v47;
              _os_log_impl( (void *)&_mh_execute_header,  v45,  OS_LOG_TYPE_DEFAULT,  "Device List Full with connected %s connecting %s lePaired %s ClassicPaired %s UnexpiredFindMyDevice %s F astLeConnectionDevice %s - count %d",  __p,  0x44u);
              char v45 = (os_log_s *)qword_1008F75A0;
            }

            if (++v46 == 64)
            {
              uint64_t v54 = sub_1002E6E00();
              sub_10002418C(v71, "");
              sub_1004FB370(v54, 3717LL, (uint64_t)v71, 1);
            }
          }
        }

        __int128 v24 = sub_100241F94((const unsigned __int8 *)(*(void *)v59 + 16LL));
        __int128 v25 = (void *)objc_claimAutoreleasedReturnValue(v24);
        __int128 v26 = [*(id *)(v3 + 160) objectForKey:v25];
        if (!v26)
        {
          __int128 v27 = (os_log_s *)qword_1008F75A0;
          if (os_log_type_enabled((os_log_t)qword_1008F75A0, OS_LOG_TYPE_FAULT))
          {
            sub_10069B440(v75, &v76, v27);
            uint64_t v3 = a1;
          }
        }

        __int16 v28 = v26[164];
        v21 += v28;
        v20 += v26[163];
        if (v26[163]) {
          LOBYTE(v28) = v28 | 2;
        }
        v62 += v26[160];
        if (v26[160]) {
          LOBYTE(v28) = v28 | 4;
        }
        if (v26[161]) {
          LOBYTE(v28) = v28 | 8;
        }
        int v29 = HIDWORD(v63);
        if (*((void *)v26 + 8)) {
          int v29 = HIDWORD(v63) + 1;
        }
        LOWORD(v63) = v63 + v26[161];
        HIDWORD(v63) = v29;
        if (*((void *)v26 + 8)) {
          LOBYTE(v28) = v28 | 0x10;
        }
        int v30 = v64;
        if (v26[528]) {
          int v30 = v64 + 1;
        }
        int v64 = v30;
        if (v26[528]) {
          LOBYTE(v28) = v28 | 0x20;
        }
        if (!(_BYTE)v28) {
          break;
        }
        ++buf[v28];
        sub_100241F90(__p, v25);
        sub_1005D10D4(v3, __p);

        ++v55;
        ++v19;
        uint64_t v3 = a1;
      }

      __int16 v31 = *(uint64_t **)(v3 + 192);
      uint64_t v32 = *v31;
      *(void *)(v32 + 8) = v31[1];
      *(void *)v31[1] = v32;
      --*(void *)(v3 + 208);
      operator delete(v31);
      if (*((void *)v26 + 3))
      {
        *(void *)std::string __p = *((void *)v26 + 3);
        sub_10020166C(v61, (unint64_t *)__p);
      }

      char v33 = (os_log_s *)qword_1008F75A0;
      if (os_log_type_enabled((os_log_t)qword_1008F75A0, OS_LOG_TYPE_INFO))
      {
        sub_1005C4850((uint64_t)v26, (std::stringbuf::string_type *)__p);
        uint64_t v34 = __p;
        if (__p[23] < 0) {
          uint64_t v34 = *(_BYTE **)__p;
        }
        *(_DWORD *)unint64_t v73 = 136446210;
        int64_t v74 = v34;
        _os_log_impl((void *)&_mh_execute_header, v33, OS_LOG_TYPE_INFO, "Device erased [%{public}s]", v73, 0xCu);
        if ((__p[23] & 0x80000000) != 0) {
          operator delete(*(void **)__p);
        }
      }

      *(void *)std::string __p = *((void *)v26 + 2);
      sub_10020166C(v61, (unint64_t *)__p);
      [*(id *)(v3 + 160) removeObjectForKey:v25];
      char v35 = (void *)sub_1005DC5C8((uint64_t)v26);
      operator delete(v35);
      unint64_t v36 = *(void *)(v3 + 208);
      uint64_t v37 = v3;
      unint64_t v38 = *(int *)(v3 + 144);
      memset(__p, 0, sizeof(__p));
      *(_DWORD *)std::string __p = *(_DWORD *)(v37 + 256);
      sub_100240540(&__p[8], v57);
      char v39 = (os_log_s *)qword_1008F75A0;
      if (os_log_type_enabled((os_log_t)qword_1008F75A0, OS_LOG_TYPE_INFO))
      {
        *(_DWORD *)unint64_t v73 = 138543362;
        int64_t v74 = v25;
        _os_log_impl((void *)&_mh_execute_header, v39, OS_LOG_TYPE_INFO, "Device %{public}@ evicted", v73, 0xCu);
      }

      v67._uint64_t os_unfair_lock_opaque = *(_DWORD *)__p;
      __uuid_t dst = 0LL;
      uint64_t v70 = 0LL;
      BOOL v68 = 0LL;
      int v40 = *(const void **)&__p[8];
      int64_t v41 = *(void *)&__p[16] - *(void *)&__p[8];
      if (*(void *)&__p[16] != *(void *)&__p[8])
      {
        sub_10023DBC8(&v68, v41 >> 3);
        __int128 v42 = (char *)__dst;
        memmove(__dst, v40, v41);
        __uuid_t dst = &v42[8 * (v41 >> 3)];
      }

      v65[0] = _NSConcreteStackBlock;
      v65[1] = 3221225472LL;
      v65[2] = sub_1005D3FF0;
      v65[3] = &unk_1008A33D0;
      id v43 = v25;
      id v66 = v43;
      sub_1005DC3A4(&v67, v65);
      if (v68)
      {
        __uuid_t dst = v68;
        operator delete(v68);
      }

      if (*(void *)&__p[8])
      {
        *(void *)&__p[16] = *(void *)&__p[8];
        operator delete(*(void **)&__p[8]);
      }

      BOOL v44 = v36 > v38;

      int v19 = v23;
      uint64_t v3 = a1;
    }

    while (v44);
  }

  sub_100242FAC((uint64_t)v72);
}

void sub_1005D0944( _Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, void *a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20, uint64_t a21, uint64_t a22, uint64_t a23, uint64_t a24, uint64_t a25, uint64_t a26, uint64_t a27, uint64_t a28, uint64_t a29, uint64_t a30, uint64_t a31, uint64_t a32, uint64_t a33, uint64_t a34, void *a35, uint64_t a36, uint64_t a37, void *__p, uint64_t a39, int a40, __int16 a41, char a42, char a43, char a44, uint64_t a45, uint64_t a46, uint64_t a47, uint64_t a48, uint64_t a49, uint64_t a50,void *a51,uint64_t a52)
{
  _Unwind_Resume(a1);
}

BOOL sub_1005D0A00(uint64_t a1, const unsigned __int8 *a2, uint64_t a3)
{
  uint64_t v4 = *(void *)(a1 + 240);
  id v5 = sub_100241F94(a2);
  uint64_t v6 = (void *)objc_claimAutoreleasedReturnValue(v5);
  BOOL v7 = sub_1002DCD2C(v4, v6, a3) != 0;

  return v7;
}

void sub_1005D0A58(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_1005D0A68(uint64_t a1, void *a2, void *a3)
{
  id v5 = a2;
  id v6 = a3;
  v9[0] = 0LL;
  v9[1] = 0LL;
  sub_100242F28((uint64_t)v9, a1 + 80);
  BOOL v7 = sub_1005C6AC0(a1, v5);
  uint64_t v8 = (void *)v7[1];
  v7[1] = v6;

  sub_100242FAC((uint64_t)v9);
}

void sub_1005D0ADC( _Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9)
{
  _Unwind_Resume(a1);
}

id sub_1005D0B00(uint64_t a1, void *a2)
{
  id v3 = a2;
  v6[0] = 0LL;
  v6[1] = 0LL;
  sub_100242F28((uint64_t)v6, a1 + 80);
  id v4 = (id)sub_1005C6AC0(a1, v3)[1];
  sub_100242FAC((uint64_t)v6);

  return v4;
}

void sub_1005D0B64( _Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9)
{
  _Unwind_Resume(a1);
}

uint64_t sub_1005D0B84@<X0>(uint64_t a1@<X0>, unsigned __int8 *a2@<X1>, unsigned __int8 *a3@<X8>)
{
  v27[0] = 0LL;
  v27[1] = 0LL;
  sub_100242F28((uint64_t)v27, a1 + 80);
  uint64_t v6 = *a2;
  uint64_t v7 = a2[1];
  uint64_t v8 = a2[2];
  uint64_t v9 = a2[3];
  uint64_t v10 = a2[4];
  uint64_t v11 = a2[5];
  __int128 v23 = 0u;
  __int128 v24 = 0u;
  __int128 v25 = 0u;
  __int128 v26 = 0u;
  id v12 = *(id *)(a1 + 160);
  id v13 = [v12 countByEnumeratingWithState:&v23 objects:v28 count:16];
  if (v13)
  {
    uint64_t v14 = (v6 << 40) | (v7 << 32) | (v8 << 24) | (v9 << 16) | (v10 << 8) | v11;
    uint64_t v15 = *(void *)v24;
    while (2)
    {
      for (uint64_t i = 0LL; i != v13; uint64_t i = (char *)i + 1)
      {
        if (*(void *)v24 != v15) {
          objc_enumerationMutation(v12);
        }
        uint64_t v17 = *(void *)(*((void *)&v23 + 1) + 8LL * (void)i);
        unsigned int v18 = [*(id *)(a1 + 160) objectForKey:v17];
        uint64_t v19 = v18[3];
        if (!v19) {
          uint64_t v19 = v18[2];
        }
        if (v14 == v19)
        {
          sub_100241F90(a3, v17);

          return sub_100242FAC((uint64_t)v27);
        }
      }

      id v13 = [v12 countByEnumeratingWithState:&v23 objects:v28 count:16];
      if (v13) {
        continue;
      }
      break;
    }
  }

  unsigned __int16 v20 = (os_log_s *)qword_1008F75A0;
  if (os_log_type_enabled((os_log_t)qword_1008F75A0, OS_LOG_TYPE_DEFAULT))
  {
    *(_WORD *)int v22 = 0;
    _os_log_impl( (void *)&_mh_execute_header,  v20,  OS_LOG_TYPE_DEFAULT,  "BD Addr not in deviceMap, generating new UUID",  v22,  2u);
  }

  uuid_clear(a3);
  return sub_100242FAC((uint64_t)v27);
}

void sub_1005D0D4C( _Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, ...)
{
}

uint64_t sub_1005D0D84@<X0>(uint64_t a1@<X0>, unint64_t a2@<X1>, unsigned __int8 *a3@<X8>)
{
  v20[0] = 0LL;
  v20[1] = 0LL;
  sub_100242F28((uint64_t)v20, a1 + 80);
  __int128 v18 = 0u;
  __int128 v19 = 0u;
  __int128 v16 = 0u;
  __int128 v17 = 0u;
  id v6 = *(id *)(a1 + 248);
  id v7 = [v6 countByEnumeratingWithState:&v16 objects:v21 count:16];
  if (v7)
  {
    uint64_t v8 = *(void *)v17;
    do
    {
      for (uint64_t i = 0LL; i != v7; uint64_t i = (char *)i + 1)
      {
        if (*(void *)v17 != v8) {
          objc_enumerationMutation(v6);
        }
        uint64_t v10 = *(void **)(*((void *)&v16 + 1) + 8LL * (void)i);
        sub_1005D73C8(a1, v10, 0, (uint64_t)v14);
        if (v15)
        {
          uint64_t v11 = v15;
          do
          {
            unint64_t v12 = v11[4];
            if (v12 <= a2)
            {
              if (v12 >= a2)
              {
                sub_10023BF24((uint64_t)v14, v15);
                sub_100241F90(a3, v10);

                return sub_100242FAC((uint64_t)v20);
              }

              ++v11;
            }

            uint64_t v11 = (void *)*v11;
          }

          while (v11);
        }

        sub_10023BF24((uint64_t)v14, v15);
      }

      id v7 = [v6 countByEnumeratingWithState:&v16 objects:v21 count:16];
    }

    while (v7);
  }

  uuid_clear(a3);
  return sub_100242FAC((uint64_t)v20);
}

void sub_1005D0F04( _Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, ...)
{
  sub_100242FAC((uint64_t)va);
  _Unwind_Resume(a1);
}

uint64_t sub_1005D0F38@<X0>(uint64_t a1@<X0>, uint64_t a2@<X1>, unsigned __int8 *a3@<X8>)
{
  v19[0] = 0LL;
  v19[1] = 0LL;
  sub_100242F28((uint64_t)v19, a1 + 80);
  __int128 v17 = 0u;
  __int128 v18 = 0u;
  __int128 v15 = 0u;
  __int128 v16 = 0u;
  id v6 = *(id *)(a1 + 248);
  id v7 = [v6 countByEnumeratingWithState:&v15 objects:v20 count:16];
  if (v7)
  {
    uint64_t v8 = *(void *)v16;
    do
    {
      for (uint64_t i = 0LL; i != v7; uint64_t i = (char *)i + 1)
      {
        if (*(void *)v16 != v8) {
          objc_enumerationMutation(v6);
        }
        uint64_t v10 = *(void *)(*((void *)&v15 + 1) + 8LL * (void)i);
        uint64_t v11 = objc_msgSend(*(id *)(a1 + 160), "objectForKey:", v10, (void)v15);
        if (sub_1005D89C0((uint64_t)v11) && *((_BYTE *)v11 + 164))
        {
          uint64_t v12 = v11[7];
          if (v12 == a2 && v12 != 0)
          {
            sub_100241F90(a3, v10);

            return sub_100242FAC((uint64_t)v19);
          }
        }
      }

      id v7 = [v6 countByEnumeratingWithState:&v15 objects:v20 count:16];
    }

    while (v7);
  }

  uuid_clear(a3);
  return sub_100242FAC((uint64_t)v19);
}

void sub_1005D109C( _Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, ...)
{
}

void *sub_1005D10D4(uint64_t a1, unsigned __int8 *uu2)
{
  uint64_t v4 = a1 + 192;
  for (uint64_t i = *(unsigned __int8 **)(a1 + 200); i != (unsigned __int8 *)v4; uint64_t i = (unsigned __int8 *)*((void *)i + 1))
  {
    if (!uuid_compare(i + 16, uu2))
    {
      break;
    }
  }

  id v6 = (os_log_s *)qword_1008F75A0;
  uint64_t i = (unsigned __int8 *)v4;
  if (os_log_type_enabled((os_log_t)qword_1008F75A0, OS_LOG_TYPE_FAULT))
  {
    sub_10069B52C(v6, v7, v8);
    uint64_t i = (unsigned __int8 *)v4;
  }

void sub_1005D11B0(uint64_t a1@<X0>, void *a2@<X1>, unsigned __int8 *a3@<X8>)
{
  id v5 = a2;
  v26[0] = 0LL;
  v26[1] = 0LL;
  sub_100242F28((uint64_t)v26, a1 + 80);
  v31[0] = 0LL;
  v31[1] = 0LL;
  sub_100241F90(v31, v5);
  unint64_t v6 = sub_1005D1520(v31);
  uint64_t v7 = v6;
  if (!v6)
  {
    if (os_log_type_enabled((os_log_t)qword_1008F75A0, OS_LOG_TYPE_ERROR)) {
      sub_10069B5A0();
    }
    goto LABEL_30;
  }

  uint64_t v8 = *(void **)(a1 + 176);
  if (v8)
  {
    uint64_t v9 = a1 + 176;
    do
    {
      unint64_t v10 = v8[4];
      BOOL v11 = v10 >= v6;
      if (v10 >= v6) {
        uint64_t v12 = v8;
      }
      else {
        uint64_t v12 = v8 + 1;
      }
      if (v11) {
        uint64_t v9 = (uint64_t)v8;
      }
      uint64_t v8 = (void *)*v12;
    }

    while (*v12);
    if (v9 != a1 + 176 && v6 >= *(void *)(v9 + 32))
    {
      unsigned __int16 v20 = (unsigned __int8 *)(v9 + 40);
      unsigned __int16 v21 = sub_100241F94((const unsigned __int8 *)(v9 + 40));
      int v22 = (void *)objc_claimAutoreleasedReturnValue(v21);
      unsigned __int8 v23 = [v5 isEqual:v22];

      if ((v23 & 1) != 0)
      {
        sub_1005D10D4(a1, v20);
        uuid_copy(a3, v20);
        goto LABEL_31;
      }

      if (os_log_type_enabled((os_log_t)qword_1008F75A0, OS_LOG_TYPE_ERROR))
      {
        id v24 = sub_1005BFB9C(v7);
        id v25 = (id)objc_claimAutoreleasedReturnValue(v24);
        sub_100366664(v20, buf);
        sub_10069AE98();
      }

void sub_1005D14A4( _Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9)
{
  sub_100242FAC((uint64_t)&a9);
  _Unwind_Resume(a1);
}

unint64_t sub_1005D1520(const void *a1)
{
  *(_DWORD *)&v2[3] = 0;
  *(_DWORD *)id v2 = 0;
  else {
    return ((unint64_t)v2[1] << 40) | ((unint64_t)v2[2] << 32) | ((unint64_t)v2[3] << 24) | ((unint64_t)v2[4] << 16) | ((unint64_t)v2[5] << 8) | v2[6] | ((unint64_t)v2[0] << 48);
  }
}

void sub_1005D1594(uint64_t a1, const unsigned __int8 *a2, uint64_t a3)
{
  if ((a3 & 0xFF000000000000LL) != 0)
  {
    unint64_t v6 = (os_log_s *)qword_1008F75A0;
    if (os_log_type_enabled((os_log_t)qword_1008F75A0, OS_LOG_TYPE_FAULT))
    {
      memset(out, 0, 37);
      uuid_unparse_upper(a2, (char *)out);
      sub_10002418C(__p, (char *)out);
      if (v12 >= 0) {
        unint64_t v10 = __p;
      }
      else {
        unint64_t v10 = (void **)__p[0];
      }
      *(_DWORD *)uuid_t out = 136446210;
      *(void *)&out[4] = v10;
      _os_log_fault_impl( (void *)&_mh_execute_header,  v6,  OS_LOG_TYPE_FAULT,  "Trying to remove duplicates of an address that is not public for device %{public}s",  out,  0xCu);
      if (v12 < 0) {
        operator delete(__p[0]);
      }
    }
  }

  uint64_t v7 = *(void *)(a1 + 240);
  uint64_t v8 = sub_100241F94(a2);
  uint64_t v9 = (void *)objc_claimAutoreleasedReturnValue(v8);
  sub_1002DCA3C(v7, a3, v9);
}

void sub_1005D16C8(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

uint64_t sub_1005D16E0(uint64_t a1, const unsigned __int8 *a2)
{
  v9[0] = 0LL;
  v9[1] = 0LL;
  sub_100242F28((uint64_t)v9, a1 + 80);
  uint64_t v4 = sub_100241F94(a2);
  id v5 = (void *)objc_claimAutoreleasedReturnValue(v4);
  unint64_t v6 = sub_1005C6AC0(a1, v5);

  if (v6) {
    uint64_t v7 = v6[3];
  }
  else {
    uint64_t v7 = 0LL;
  }
  sub_100242FAC((uint64_t)v9);
  return v7;
}

void sub_1005D1758( _Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9)
{
  sub_100242FAC((uint64_t)&a9);
  _Unwind_Resume(a1);
}

uint64_t sub_1005D1778(uint64_t a1, unsigned __int8 *a2, unint64_t a3)
{
  v24[1] = 0LL;
  unint64_t v25 = a3;
  v24[0] = 0LL;
  sub_100242F28((uint64_t)v24, a1 + 80);
  unint64_t v6 = sub_100241F94(a2);
  uint64_t v7 = (void *)objc_claimAutoreleasedReturnValue(v6);
  uint64_t v8 = sub_1005C6AC0(a1, v7);

  if (v8)
  {
    if (BYTE6(a3)
      && (BYTE6(a3) != 1 || (~a3 & 0xC00000000000LL) != 0)
      && os_log_type_enabled((os_log_t)qword_1008F75A0, OS_LOG_TYPE_FAULT))
    {
      sub_100366664(a2, v23);
      sub_10069B640();
    }

    uint64_t v9 = v8[3];
    if (v9)
    {
      if (v9 != v8[2])
      {
        unint64_t v10 = *(void **)(a1 + 176);
        if (v10)
        {
          BOOL v11 = (uint64_t *)(a1 + 176);
          do
          {
            unint64_t v12 = v10[4];
            BOOL v13 = v12 >= a3;
            if (v12 >= a3) {
              uint64_t v14 = v10;
            }
            else {
              uint64_t v14 = v10 + 1;
            }
            if (v13) {
              BOOL v11 = v10;
            }
            unint64_t v10 = (void *)*v14;
          }

          while (*v14);
          if (v11 != (uint64_t *)(a1 + 176) && v11[4] <= a3)
          {
            sub_1001FDBCC((uint64_t **)(a1 + 168), v11);
            operator delete(v11);
          }
        }
      }
    }

    id v15 = (os_log_s *)qword_1008F75A0;
    if (os_log_type_enabled((os_log_t)qword_1008F75A0, OS_LOG_TYPE_INFO))
    {
      id v16 = sub_1005BFB9C(a3);
      id v17 = (id)objc_claimAutoreleasedReturnValue(v16);
      memset(out, 0, 37);
      uuid_unparse_upper(a2, out);
      sub_10002418C(__p, out);
      if (v22 >= 0) {
        id v18 = __p;
      }
      else {
        id v18 = (void **)__p[0];
      }
      *(_DWORD *)__int128 buf = 138543618;
      id v27 = v17;
      __int16 v28 = 2082;
      __int16 v29 = v18;
      _os_log_impl( (void *)&_mh_execute_header,  v15,  OS_LOG_TYPE_INFO,  "Now using resolved address %{public}@ for resolvable device %{public}s",  buf,  0x16u);
      if (v22 < 0) {
        operator delete(__p[0]);
      }
    }

    void v8[3] = a3;
    sub_1005CB37C(a1, a2);
    *(void *)uuid_t out = &v25;
    __int128 v19 = sub_1005BCE78(a1 + 168, &v25, (uint64_t)&unk_1006C2518, (void **)out);
    uuid_copy((unsigned __int8 *)v19 + 40, a2);
  }

  return sub_100242FAC((uint64_t)v24);
}

void sub_1005D19E8( _Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, ...)
{
}

void sub_1005D1A28(uint64_t a1, void *a2, unsigned __int8 *a3)
{
  id v5 = a2;
  for (uint64_t i = 0LL; i != 5; ++i)
  {
    uint64_t v7 = (char *)&unk_1008F1D48 + 32 * i;
    uint64_t v8 = a3[23];
    if ((v8 & 0x80u) == 0LL) {
      uint64_t v9 = a3[23];
    }
    else {
      uint64_t v9 = *((void *)a3 + 1);
    }
    uint64_t v10 = v7[23];
    int v11 = (char)v10;
    if ((v10 & 0x80u) != 0LL) {
      uint64_t v10 = *((void *)v7 + 1);
    }
    if (v9 != v10) {
      continue;
    }
    if (v11 >= 0) {
      unint64_t v12 = (unsigned __int8 *)&unk_1008F1D48 + 32 * i;
    }
    else {
      unint64_t v12 = *(unsigned __int8 **)v7;
    }
    if ((v8 & 0x80) != 0)
    {
    }

    else if (a3[23])
    {
      BOOL v13 = a3;
      while (*v13 == *v12)
      {
        ++v13;
        ++v12;
        if (!--v8) {
          goto LABEL_18;
        }
      }

      continue;
    }

void sub_1005D1C1C( _Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, void *__p, uint64_t a12, int a13, __int16 a14, char a15, char a16, uint64_t a17, uint64_t a18, int a19, __int16 a20, char a21, char a22)
{
  if (a16 < 0) {
    operator delete(__p);
  }

  _Unwind_Resume(a1);
}

BOOL sub_1005D1C60(uint64_t a1, void *a2, _DWORD *a3)
{
  id v5 = a2;
  v9[0] = 0LL;
  v9[1] = 0LL;
  sub_100242F28((uint64_t)v9, a1 + 80);
  unint64_t v6 = sub_1005C6AC0(a1, v5);
  if (v6) {
    *a3 = *((_DWORD *)v6 + 32);
  }
  BOOL v7 = v6 != 0LL;
  sub_100242FAC((uint64_t)v9);

  return v7;
}

void sub_1005D1CD8( _Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9)
{
  _Unwind_Resume(a1);
}

void sub_1005D1CF8(uint64_t a1, void *a2, char a3)
{
  id v5 = a2;
  v7[0] = 0LL;
  v7[1] = 0LL;
  sub_100242F28((uint64_t)v7, a1 + 80);
  unint64_t v6 = sub_1005C6AC0(a1, v5);
  if (v6) {
    *((_BYTE *)v6 + 98) = a3;
  }
  sub_100242FAC((uint64_t)v7);
}

void sub_1005D1D60( _Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9)
{
  _Unwind_Resume(a1);
}

void sub_1005D1D80(uint64_t a1, void *a2)
{
  id v3 = a2;
  v6[0] = 0LL;
  v6[1] = 0LL;
  sub_100242F28((uint64_t)v6, a1 + 80);
  uint64_t v4 = sub_1005C6AC0(a1, v3);
  if (v4)
  {
    int v5 = *(_DWORD *)(a1 + 152) + 1;
    *(_DWORD *)(a1 + 152) = v5;
    *((_DWORD *)v4 + 33) = v5;
  }

  sub_100242FAC((uint64_t)v6);
}

void sub_1005D1DE8( _Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9)
{
  _Unwind_Resume(a1);
}

uint64_t sub_1005D1E08(uint64_t a1, void *a2)
{
  id v3 = a2;
  v7[0] = 0LL;
  v7[1] = 0LL;
  sub_100242F28((uint64_t)v7, a1 + 80);
  uint64_t v4 = sub_1005C6AC0(a1, v3);
  if (v4) {
    char v5 = *((_BYTE *)v4 + 476);
  }
  else {
    char v5 = 0;
  }
  sub_100242FAC((uint64_t)v7);

  return v5;
}

void sub_1005D1E70( _Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9)
{
  _Unwind_Resume(a1);
}

void sub_1005D1E90(uint64_t a1, void *a2, char a3)
{
  id v5 = a2;
  v7[0] = 0LL;
  v7[1] = 0LL;
  sub_100242F28((uint64_t)v7, a1 + 80);
  unint64_t v6 = sub_1005C6AC0(a1, v5);
  if (v6)
  {
    *((_BYTE *)v6 + 476) = a3;
    sub_1005DA094((uint64_t)v6, a3);
  }

  sub_100242FAC((uint64_t)v7);
}

void sub_1005D1F00(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_1005D1F20(uint64_t a1, void *a2, char a3)
{
  id v5 = a2;
  v7[0] = 0LL;
  v7[1] = 0LL;
  sub_100242F28((uint64_t)v7, a1 + 80);
  unint64_t v6 = sub_1005C6AC0(a1, v5);
  if (v6) {
    *((_BYTE *)v6 + 163) = a3;
  }
  sub_100242FAC((uint64_t)v7);
}

void sub_1005D1F88( _Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9)
{
  _Unwind_Resume(a1);
}

void sub_1005D1FA8(uint64_t a1, void *a2, int a3, uint64_t a4)
{
  id v7 = a2;
  v18[0] = 0LL;
  v18[1] = 0LL;
  sub_100242F28((uint64_t)v18, a1 + 80);
  uint64_t v8 = sub_1005C6AC0(a1, v7);
  uint64_t v9 = v8;
  if (v8)
  {
    sub_1005C3FB8((uint64_t)v8, a3, a4);
    if (a3)
    {
      sub_10002418C(__p, "DoNotAutoConnect");
      uint64_t v10 = sub_100024098((uint64_t)(v9 + 22), (const void **)__p);
      int v11 = v9 + 23;
      if (v17 < 0) {
        operator delete(__p[0]);
      }
      if (v11 != (void *)v10) {
        sub_1005C9A38(a1, v7, @"DoNotAutoConnect");
      }
    }

    else if (*((_BYTE *)v9 + 488))
    {
      uint64_t v12 = sub_100404FE8();
      v13[0] = _NSConcreteStackBlock;
      v13[1] = 3221225472LL;
      void v13[2] = sub_1005D212C;
      v13[3] = &unk_1008800B8;
      uint64_t v15 = a1;
      id v14 = v7;
      sub_100405460(v12, 1000LL, v13);
    }
  }

  sub_100242FAC((uint64_t)v18);
}

void sub_1005D20E4( _Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, void *a14, uint64_t a15, void *__p, uint64_t a17, int a18, __int16 a19, char a20, char a21)
{
  sub_100242FAC(v22 - 64);
  _Unwind_Resume(a1);
}

void sub_1005D212C(uint64_t a1)
{
  uint64_t v2 = *(void *)(a1 + 40);
  id v3 = (os_log_s *)qword_1008F75A0;
  if (os_log_type_enabled((os_log_t)qword_1008F75A0, OS_LOG_TYPE_DEFAULT))
  {
    uint64_t v4 = *(void *)(a1 + 32);
    int v5 = 138543362;
    uint64_t v6 = v4;
    _os_log_impl( (void *)&_mh_execute_header,  v3,  OS_LOG_TYPE_DEFAULT,  "deleting pending device %{public}@",  (uint8_t *)&v5,  0xCu);
  }

  sub_1005C91A4(v2, *(void **)(a1 + 32));
}

void sub_1005D21E8(uint64_t a1, void *a2, int a3)
{
}

void sub_1005D21F0(uint64_t a1, void *a2, char a3)
{
  id v5 = a2;
  v7[0] = 0LL;
  v7[1] = 0LL;
  sub_100242F28((uint64_t)v7, a1 + 80);
  uint64_t v6 = sub_1005C6AC0(a1, v5);
  if (v6) {
    *((_BYTE *)v6 + 165) = a3;
  }
  sub_100242FAC((uint64_t)v7);
}

void sub_1005D2258( _Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9)
{
  _Unwind_Resume(a1);
}

void sub_1005D2278(uint64_t a1, void *a2, _BYTE *a3, _BYTE *a4, char *a5)
{
  id v9 = a2;
  v13[0] = 0LL;
  v13[1] = 0LL;
  sub_100242F28((uint64_t)v13, a1 + 80);
  uint64_t v10 = sub_1005C6AC0(a1, v9);
  if (v10)
  {
    *a3 = *((_BYTE *)v10 + 165);
    *a4 = *((_BYTE *)v10 + 529);
    if (*((_BYTE *)v10 + 528)) {
      BOOL v11 = v10[65] == 0LL;
    }
    else {
      BOOL v11 = 1;
    }
    char v12 = !v11;
    *a5 = v12;
  }

  sub_100242FAC((uint64_t)v13);
}

void sub_1005D2314( _Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9)
{
  _Unwind_Resume(a1);
}

uint64_t sub_1005D2334(uint64_t a1)
{
  v16[0] = 0LL;
  v16[1] = 0LL;
  sub_100242F28((uint64_t)v16, a1 + 80);
  __int128 v14 = 0u;
  __int128 v15 = 0u;
  __int128 v12 = 0u;
  __int128 v13 = 0u;
  id v2 = *(id *)(a1 + 160);
  id v3 = [v2 countByEnumeratingWithState:&v12 objects:v17 count:16];
  if (v3)
  {
    uint64_t v4 = *(void *)v13;
    do
    {
      id v5 = 0LL;
      do
      {
        if (*(void *)v13 != v4) {
          objc_enumerationMutation(v2);
        }
        uint64_t v6 = (id *)objc_msgSend( *(id *)(a1 + 160),  "objectForKey:",  *(void *)(*((void *)&v12 + 1) + 8 * (void)v5),  (void)v12);
        int v7 = *((unsigned __int8 *)v6 + 528);
        id v8 = v6[65];
        id v9 = v8;
        if (v7) {
          BOOL v10 = v8 == 0LL;
        }
        else {
          BOOL v10 = 1;
        }
        if (!v10) {
          sub_1005C284C((uint64_t)v6, 1);
        }

        id v5 = (char *)v5 + 1;
      }

      while (v3 != v5);
      id v3 = [v2 countByEnumeratingWithState:&v12 objects:v17 count:16];
    }

    while (v3);
  }

  return sub_100242FAC((uint64_t)v16);
}

void sub_1005D247C( _Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, ...)
{
  sub_100242FAC((uint64_t)va);
  _Unwind_Resume(a1);
}

void sub_1005D24B4(uint64_t a1, void *a2, int a3)
{
  id v5 = a2;
  v7[0] = 0LL;
  v7[1] = 0LL;
  sub_100242F28((uint64_t)v7, a1 + 80);
  uint64_t v6 = sub_1005C6AC0(a1, v5);
  if (v6) {
    sub_1005C3FFC((uint64_t)v6, a3);
  }
  sub_100242FAC((uint64_t)v7);
}

void sub_1005D2520(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

uint64_t sub_1005D2540(uint64_t a1, void *a2)
{
  id v3 = a2;
  v7[0] = 0LL;
  v7[1] = 0LL;
  sub_100242F28((uint64_t)v7, a1 + 80);
  uint64_t v4 = sub_1005C6AC0(a1, v3);
  if (v4) {
    uint64_t v5 = *((unsigned int *)v4 + 42);
  }
  else {
    uint64_t v5 = 0LL;
  }
  sub_100242FAC((uint64_t)v7);

  return v5;
}

void sub_1005D25A8( _Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9)
{
  _Unwind_Resume(a1);
}

void sub_1005D25C8(uint64_t a1, void *a2, __int16 a3)
{
  id v5 = a2;
  v7[0] = 0LL;
  v7[1] = 0LL;
  sub_100242F28((uint64_t)v7, a1 + 80);
  uint64_t v6 = sub_1005C6AC0(a1, v5);
  if (v6) {
    *((_WORD *)v6 + 86) = a3;
  }
  sub_100242FAC((uint64_t)v7);
}

void sub_1005D2630( _Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9)
{
  _Unwind_Resume(a1);
}

uint64_t sub_1005D2650(uint64_t a1, void *a2)
{
  id v3 = a2;
  v7[0] = 0LL;
  v7[1] = 0LL;
  sub_100242F28((uint64_t)v7, a1 + 80);
  uint64_t v4 = sub_1005C6AC0(a1, v3);
  if (v4) {
    uint64_t v5 = *((unsigned __int16 *)v4 + 86);
  }
  else {
    uint64_t v5 = 0LL;
  }
  sub_100242FAC((uint64_t)v7);

  return v5;
}

void sub_1005D26B8( _Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9)
{
  _Unwind_Resume(a1);
}

void sub_1005D26D8(uint64_t a1, void *a2, char a3)
{
  id v5 = a2;
  v7[0] = 0LL;
  v7[1] = 0LL;
  sub_100242F28((uint64_t)v7, a1 + 80);
  uint64_t v6 = sub_1005C6AC0(a1, v5);
  if (v6) {
    *((_BYTE *)v6 + 232) = a3;
  }
  sub_100242FAC((uint64_t)v7);
}

void sub_1005D2740( _Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9)
{
  _Unwind_Resume(a1);
}

BOOL sub_1005D2760(uint64_t a1, void *a2)
{
  id v3 = a2;
  v7[0] = 0LL;
  v7[1] = 0LL;
  sub_100242F28((uint64_t)v7, a1 + 80);
  uint64_t v4 = sub_1005C6AC0(a1, v3);
  if (v4) {
    BOOL v5 = *((_BYTE *)v4 + 232) != 0;
  }
  else {
    BOOL v5 = 0LL;
  }
  sub_100242FAC((uint64_t)v7);

  return v5;
}

void sub_1005D27D0( _Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9)
{
  _Unwind_Resume(a1);
}

void sub_1005D27F0(uint64_t a1, void *a2, char a3)
{
  id v5 = a2;
  v7[0] = 0LL;
  v7[1] = 0LL;
  sub_100242F28((uint64_t)v7, a1 + 80);
  uint64_t v6 = sub_1005C6AC0(a1, v5);
  if (v6) {
    *((_BYTE *)v6 + 233) = a3;
  }
  sub_100242FAC((uint64_t)v7);
}

void sub_1005D2858( _Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9)
{
  _Unwind_Resume(a1);
}

BOOL sub_1005D2878(uint64_t a1, void *a2)
{
  id v3 = a2;
  v7[0] = 0LL;
  v7[1] = 0LL;
  sub_100242F28((uint64_t)v7, a1 + 80);
  uint64_t v4 = sub_1005C6AC0(a1, v3);
  if (v4) {
    BOOL v5 = *((_BYTE *)v4 + 233) != 0;
  }
  else {
    BOOL v5 = 0LL;
  }
  sub_100242FAC((uint64_t)v7);

  return v5;
}

void sub_1005D28E8( _Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9)
{
  _Unwind_Resume(a1);
}

void sub_1005D2908(uint64_t a1, void *a2, __int16 a3)
{
  id v5 = a2;
  v7[0] = 0LL;
  v7[1] = 0LL;
  sub_100242F28((uint64_t)v7, a1 + 80);
  uint64_t v6 = sub_1005C6AC0(a1, v5);
  if (v6) {
    *((_WORD *)v6 + 176) = a3;
  }
  sub_100242FAC((uint64_t)v7);
}

void sub_1005D2970( _Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9)
{
  _Unwind_Resume(a1);
}

uint64_t sub_1005D2990(uint64_t a1, void *a2)
{
  id v3 = a2;
  v7[0] = 0LL;
  v7[1] = 0LL;
  sub_100242F28((uint64_t)v7, a1 + 80);
  uint64_t v4 = sub_1005C6AC0(a1, v3);
  if (v4) {
    uint64_t v5 = *((unsigned __int16 *)v4 + 176);
  }
  else {
    uint64_t v5 = 0LL;
  }
  sub_100242FAC((uint64_t)v7);

  return v5;
}

void sub_1005D29F8( _Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9)
{
  _Unwind_Resume(a1);
}

void sub_1005D2A18(uint64_t a1, void *a2, int a3)
{
  id v5 = a2;
  v7[0] = 0LL;
  v7[1] = 0LL;
  sub_100242F28((uint64_t)v7, a1 + 80);
  uint64_t v6 = sub_1005C6AC0(a1, v5);
  if (v6) {
    *((_DWORD *)v6 + 93) = a3;
  }
  sub_100242FAC((uint64_t)v7);
}

void sub_1005D2A80( _Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9)
{
  _Unwind_Resume(a1);
}

void sub_1005D2AA0(uint64_t a1, void *a2, void *a3)
{
  id v5 = a2;
  id v6 = a3;
  v8[0] = 0LL;
  v8[1] = 0LL;
  sub_100242F28((uint64_t)v8, a1 + 80);
  int v7 = (id *)sub_1005C6AC0(a1, v5);
  if (v7) {
    objc_storeStrong(v7 + 47, a3);
  }
  sub_100242FAC((uint64_t)v8);
}

void sub_1005D2B1C( _Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9)
{
  _Unwind_Resume(a1);
}

id sub_1005D2B40(uint64_t a1, void *a2)
{
  id v3 = a2;
  v7[0] = 0LL;
  v7[1] = 0LL;
  sub_100242F28((uint64_t)v7, a1 + 80);
  uint64_t v4 = sub_1005C6AC0(a1, v3);
  if (v4) {
    id v5 = (id)v4[47];
  }
  else {
    id v5 = 0LL;
  }
  sub_100242FAC((uint64_t)v7);

  return v5;
}

void sub_1005D2BB0( _Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9)
{
  _Unwind_Resume(a1);
}

id sub_1005D2BD0(uint64_t a1, void *a2)
{
  id v3 = a2;
  v11[0] = 0LL;
  v11[1] = 0LL;
  sub_100242F28((uint64_t)v11, a1 + 80);
  id v4 = (id)sub_1005C6AC0(a1, v3)[47];
  id v5 = v4;
  if (v4 && [v4 count])
  {
    uint64_t v6 = objc_claimAutoreleasedReturnValue([v5 componentsJoinedByString:@","]);
  }

  else
  {
    int v7 = sub_1005CE2FC(a1, v3);
    id v8 = +[NSString stringWithUTF8String:](&OBJC_CLASS___NSString, "stringWithUTF8String:", sub_1005D2CC4(v7));
    uint64_t v6 = objc_claimAutoreleasedReturnValue(v8);
  }

  id v9 = (void *)v6;

  sub_100242FAC((uint64_t)v11);
  return v9;
}

void sub_1005D2C94( _Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9)
{
  sub_100242FAC((uint64_t)&a9);
  _Unwind_Resume(a1);
}

const char *sub_1005D2CC4(int a1)
{
  if (a1 >= 0x20000)
  {
    if (a1 >= 327680)
    {
      if (a1 > 589824)
      {
        if (a1 <= 2147418111)
        {
          switch(a1)
          {
            case 589825:
              return "FindNearbyPencil";
            case 655360:
              return "AccessDigitalHomeKey";
            case 786432:
              return "ProxControlDeviceClose";
            default:
              return "?";
          }
        }

        else
        {
          switch(a1)
          {
            case 2147418112:
              uint64_t result = "InternalTestNoLockScan";
              break;
            case 2147418113:
              uint64_t result = "InternalTestNoScreenOffScan";
              break;
            case 2147418114:
              uint64_t result = "InternalTestScanWithNoDups";
              break;
            case 2147418115:
              uint64_t result = "InternalTestScanWithDups";
              break;
            case 2147418116:
              uint64_t result = "InternalTestScanFor20Seconds";
              break;
            case 2147418117:
              uint64_t result = "InternalTestActiveScan";
              break;
            case 2147418118:
              uint64_t result = "InternalTestUUIDScan";
              break;
            case 2147418119:
              uint64_t result = "InternalTestScanFor10ClockSeconds";
              break;
            case 2147418120:
              uint64_t result = "InternalTestScanBoost";
              break;
            default:
              return "?";
          }
        }
      }

      else if (a1 > 458752)
      {
        switch(a1)
        {
          case 524288:
            uint64_t result = "ADPD";
            break;
          case 524289:
            uint64_t result = "ADPDBuffer";
            break;
          case 524290:
            uint64_t result = "MicroLocation";
            break;
          case 524291:
            uint64_t result = "MicroLocationLeech";
            break;
          default:
            if (a1 == 458753)
            {
              uint64_t result = "PrecisionFindingFindee";
            }

            else
            {
              if (a1 != 589824) {
                return "?";
              }
              uint64_t result = "FindNearbyRemote";
            }

            break;
        }
      }

      else
      {
        switch(a1)
        {
          case 393216:
            uint64_t result = "CaptiveNetworkJoin";
            break;
          case 393217:
            uint64_t result = "UseCaseSIMTransfer";
            break;
          case 393218:
            uint64_t result = "MacSetup";
            break;
          case 393219:
            uint64_t result = "AppleIDSignIn";
            break;
          case 393220:
            uint64_t result = "AppleIDSignInSettings";
            break;
          default:
            if (a1 == 327680)
            {
              uint64_t result = "RapportThirdParty";
            }

            else
            {
              if (a1 != 458752) {
                return "?";
              }
              uint64_t result = "PrecisionFindingFinder";
            }

            break;
        }
      }
    }

    else
    {
      switch(a1)
      {
        case 131072:
          return "SharingDefault";
        case 131073:
          return "SharingPhoneAutoUnlock";
        case 131074:
          return "SharingSiriWatchAuth";
        case 131075:
          return "SharingMacAutoUnlock";
        case 131076:
          return "SharingEDTScreenOn";
        case 131077:
          return "SharingEDTWiFiDisabled";
        case 131078:
          return "SharingEDTWombatEligibleAsDefaultCamera";
        case 131079:
          return "SharingEDTWombatCameraPicker";
        case 131080:
          return "SharingWombatBackground";
        case 131081:
          return "SharingUniversalControl";
        case 131082:
          return "SharingPeopleProximity";
        case 131083:
          return "SharingEDTEnsembleOpenDisplayPrefs";
        case 131084:
          return "SharingEDTNearbydMotionStopped";
        case 131085:
          return "SharingDoubleBoostGenericScan";
        case 131086:
          return "SharingEDTIncomingAdvertisement ";
        case 131087:
          return "SharingEDTWombatStreamStart";
        case 131088:
          return "SharingOYAutoUnlock";
        case 131089:
          return "?";
        case 131090:
          return "SharingAirDrop";
        case 131091:
          return "SharingNearbyInvitationHost";
        case 131092:
          return "SharingNearbyInvitationParticipant";
        case 131093:
          return "SharingAirDropAskToAirDrop";
        case 131094:
          return "SharingAirDropTempIdentity";
        case 131095:
          return "SharingAirDropNeedsCLink";
        case 131096:
          return "SharingRemoteWidgetUpdate";
        case 131097:
          return "SharingCountryCodeUpdate";
        case 131098:
          return "SharingMacPhoneAutoUnlock";
        case 131099:
          return "SharingVisionProDiscovery";
        case 131100:
          return "SharingVisionProStateChange";
        case 131101:
          return "SharingContinuityScreen";
        case 131102:
          return "SharingEDTRemoteDisplay";
        default:
          if (a1 == 196608)
          {
            uint64_t result = "DigitalIDTSA";
          }

          else
          {
            if (a1 != 0x40000) {
              return "?";
            }
            uint64_t result = "DigitalCarKeyThirdParty";
          }

          break;
      }
    }
  }

  else
  {
    uint64_t result = "Unspecified";
    switch(a1)
    {
      case 0:
        return result;
      case 1:
        uint64_t result = "HealthKit";
        break;
      case 2:
        uint64_t result = "HomeKit";
        break;
      case 3:
        uint64_t result = "FindMyObjectConnection";
        break;
      case 4:
        uint64_t result = "FindMyObjectConnectionTransient";
        break;
      case 5:
        uint64_t result = "MIDI";
        break;
      case 6:
        uint64_t result = "Continuity";
        break;
      case 7:
        uint64_t result = "InstantHotSpot";
        break;
      case 8:
        uint64_t result = "NearBy";
        break;
      case 9:
        uint64_t result = "Sharing";
        break;
      case 10:
        uint64_t result = "HearingSupport";
        break;
      case 11:
        uint64_t result = "Magnet";
        break;
      case 12:
        uint64_t result = "HID";
        break;
      case 13:
        uint64_t result = "LEA";
        break;
      case 14:
        uint64_t result = "External";
        break;
      case 15:
        uint64_t result = "ExternalMedical";
        break;
      case 16:
        uint64_t result = "ExternalLock";
        break;
      case 17:
        uint64_t result = "ExternalWatch";
        break;
      case 18:
        uint64_t result = "SmartRouting";
        break;
      case 19:
        uint64_t result = "DigitalID";
        break;
      case 20:
        uint64_t result = "DigitalKey";
        break;
      case 21:
        uint64_t result = "DigitalCarKey";
        break;
      case 22:
        uint64_t result = "HeySiri";
        break;
      case 23:
        uint64_t result = "ThirdPartyApp";
        break;
      case 24:
        uint64_t result = "CNJ";
        break;
      default:
        switch(a1)
        {
          case 256:
            uint64_t result = "DevicePresenceDetection";
            break;
          case 257:
            uint64_t result = "AudioBox";
            break;
          case 258:
            uint64_t result = "SIMTransfer";
            break;
          case 259:
            uint64_t result = "ProximityScreenOnLeechScan";
            break;
          case 260:
            uint64_t result = "MacMigrate";
            break;
          case 263:
            uint64_t result = "HIDUARTService";
            break;
          case 264:
            uint64_t result = "AccessibilitySwitchControlPairing";
            break;
          case 265:
            uint64_t result = "BaseBandFastConnect";
            break;
          case 266:
            uint64_t result = "SafetyAlerts";
            break;
          case 267:
            uint64_t result = "LECarPlay";
            break;
          case 268:
            uint64_t result = "TCCBluetooth";
            break;
          case 269:
            uint64_t result = "AOPBufferLeech";
            break;
          default:
            return "?";
        }

        break;
    }
  }

  return result;
}

void sub_1005D33F0(uint64_t a1, void *a2, void *a3, void *a4)
{
  id v7 = a2;
  id v8 = a3;
  id v9 = a4;
  v11[0] = 0LL;
  v11[1] = 0LL;
  sub_100242F28((uint64_t)v11, a1 + 80);
  BOOL v10 = sub_1005C6AC0(a1, v7);
  if (v10) {
    sub_1005C1D94((uint64_t)v10, v8, v9);
  }
  sub_100242FAC((uint64_t)v11);
}

void sub_1005D347C(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_1005D34A4(uint64_t a1, void *a2, void *a3)
{
  id v5 = a2;
  id v6 = a3;
  v8[0] = 0LL;
  v8[1] = 0LL;
  sub_100242F28((uint64_t)v8, a1 + 80);
  id v7 = sub_1005C6AC0(a1, v5);
  if (v7) {
    sub_1005C1E50((uint64_t)v7, v6);
  }
  sub_100242FAC((uint64_t)v8);
}

void sub_1005D351C(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

id sub_1005D3540(uint64_t a1, void *a2, void *a3)
{
  id v5 = a2;
  id v6 = a3;
  v10[0] = 0LL;
  v10[1] = 0LL;
  sub_100242F28((uint64_t)v10, a1 + 80);
  id v7 = sub_1005C6AC0(a1, v5);
  if (v7) {
    id v8 = sub_1005C2084((uint64_t)v7, v6);
  }
  else {
    id v8 = 0LL;
  }
  sub_100242FAC((uint64_t)v10);

  return v8;
}

void sub_1005D35C8(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_1005D35EC(uint64_t a1, void *a2, void *a3, void *a4)
{
  id v7 = a2;
  id v8 = a3;
  id v9 = a4;
  v11[0] = 0LL;
  v11[1] = 0LL;
  sub_100242F28((uint64_t)v11, a1 + 80);
  BOOL v10 = sub_1005C6AC0(a1, v7);
  if (v10) {
    sub_1005C212C((uint64_t)v10, v8, v9);
  }
  sub_100242FAC((uint64_t)v11);
}

void sub_1005D3678(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_1005D36A0(uint64_t a1, void *a2, void *a3)
{
  id v5 = a2;
  id v6 = a3;
  v8[0] = 0LL;
  v8[1] = 0LL;
  sub_100242F28((uint64_t)v8, a1 + 80);
  id v7 = sub_1005C6AC0(a1, v5);
  if (v7) {
    sub_1005C21E8((uint64_t)v7, v6);
  }
  sub_100242FAC((uint64_t)v8);
}

void sub_1005D3718(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

id sub_1005D373C(uint64_t a1, void *a2)
{
  id v3 = a2;
  v8[0] = 0LL;
  v8[1] = 0LL;
  sub_100242F28((uint64_t)v8, a1 + 80);
  id v4 = sub_1005C6AC0(a1, v3);
  if (v4)
  {
    id v5 = sub_1005C2268((uint64_t)v4);
    id v6 = (void *)objc_claimAutoreleasedReturnValue(v5);
  }

  else
  {
    id v6 = 0LL;
  }

  sub_100242FAC((uint64_t)v8);

  return v6;
}

void sub_1005D37AC(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

id sub_1005D37CC(uint64_t a1, void *a2, uint64_t a3)
{
  id v5 = a2;
  v9[0] = 0LL;
  v9[1] = 0LL;
  sub_100242F28((uint64_t)v9, a1 + 80);
  id v6 = sub_1005C6AC0(a1, v5);
  if (v6) {
    id v7 = sub_1005C24C0((uint64_t)v6, a3);
  }
  else {
    id v7 = 0LL;
  }
  sub_100242FAC((uint64_t)v9);

  return v7;
}

void sub_1005D3848(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_1005D3868(uint64_t a1, void *a2, char a3, int a4, unsigned int a5)
{
  id v9 = a2;
  v16[0] = 0LL;
  v16[1] = 0LL;
  sub_100242F28((uint64_t)v16, a1 + 80);
  BOOL v10 = sub_1005C6AC0(a1, v9);
  if (v10)
  {
    uint64_t v15 = 0LL;
    sub_1000B0740((_DWORD *)&v15 + 1, (__darwin_suseconds_t *)&v15);
    BOOL v11 = (os_log_s *)qword_1008F75A0;
    if (os_log_type_enabled((os_log_t)qword_1008F75A0, OS_LOG_TYPE_DEFAULT))
    {
      *(_DWORD *)__int128 buf = 138543874;
      id v18 = v9;
      __int16 v19 = 1024;
      int v20 = HIDWORD(v15);
      __int16 v21 = 1024;
      unsigned int v22 = a5;
      _os_log_impl( (void *)&_mh_execute_header,  v11,  OS_LOG_TYPE_DEFAULT,  "Device %{public}@ set last connected time to %d s offset %d ms",  buf,  0x18u);
    }

    if (a4 == 1)
    {
      *((_DWORD *)v10 + 36) = HIDWORD(v15);
    }

    else if (a4 == 2)
    {
      int v12 = *(_DWORD *)(a1 + 148) + 1;
      *(_DWORD *)(a1 + 148) = v12;
      int v13 = HIDWORD(v15);
      unsigned int v14 = HIDWORD(v15) - a5 / 0x3E8;
      *((_DWORD *)v10 + 34) = v12;
      *((_DWORD *)v10 + 35) = v14;
      if ((a3 & 1) == 0) {
        v10[19] = 1000 * v13 - a5 + (int)v15 / 1000;
      }
    }

    sub_100241F90(buf, v9);
    sub_1005CB37C(a1, buf);
  }

  sub_100242FAC((uint64_t)v16);
}

void sub_1005D3A1C(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, ...)
{
  _Unwind_Resume(a1);
}

void sub_1005D3A4C(uint64_t a1, void *a2, int a3)
{
  id v5 = a2;
  v7[0] = 0LL;
  v7[1] = 0LL;
  sub_100242F28((uint64_t)v7, a1 + 80);
  id v6 = sub_1005C6AC0(a1, v5);
  if (v6) {
    *((_DWORD *)v6 + 65) = a3;
  }
  sub_100242FAC((uint64_t)v7);
}

void sub_1005D3AB4( _Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9)
{
  _Unwind_Resume(a1);
}

void sub_1005D3AD4(uint64_t a1, void *a2)
{
  id v3 = a2;
  v11[0] = 0LL;
  v11[1] = 0LL;
  sub_100242F28((uint64_t)v11, a1 + 80);
  id v4 = sub_1005C6AC0(a1, v3);
  if (v4)
  {
    *(void *)std::string __str = 0LL;
    sub_1000B0400((uint64_t)__str);
    uint64_t v5 = *(int *)__str;
    uint64_t v6 = *(__int16 *)&__str[4];
    v4[30] = *(int *)__str;
    v4[31] = v6;
    id v7 = (os_log_s *)qword_1008F75A0;
    if (os_log_type_enabled((os_log_t)qword_1008F75A0, OS_LOG_TYPE_DEBUG))
    {
      __int128 v18 = 0u;
      __int128 v19 = 0u;
      *(_OWORD *)std::string __str = 0u;
      __int128 v17 = 0u;
      snprintf(__str, 0x3FuLL, "%0llu.%0llu", v5, v6);
      sub_10002418C(__p, __str);
      if (v10 >= 0) {
        id v8 = __p;
      }
      else {
        id v8 = (void **)__p[0];
      }
      *(_DWORD *)__int128 buf = 138543618;
      id v13 = v3;
      __int16 v14 = 2080;
      uint64_t v15 = v8;
      _os_log_debug_impl( (void *)&_mh_execute_header,  v7,  OS_LOG_TYPE_DEBUG,  "device %{public}@ added to filter accept list at %s",  buf,  0x16u);
      if (v10 < 0) {
        operator delete(__p[0]);
      }
    }
  }

  sub_100242FAC((uint64_t)v11);
}

void sub_1005D3C30( _Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, ...)
{
  _Unwind_Resume(a1);
}

void sub_1005D3C5C(uint64_t a1, void *a2)
{
  id v3 = a2;
  v11[0] = 0LL;
  v11[1] = 0LL;
  sub_100242F28((uint64_t)v11, a1 + 80);
  id v4 = sub_1005C6AC0(a1, v3);
  if (v4)
  {
    v4[30] = 0LL;
    v4[31] = 0LL;
    uint64_t v5 = (os_log_s *)qword_1008F75A0;
    if (os_log_type_enabled((os_log_t)qword_1008F75A0, OS_LOG_TYPE_DEBUG))
    {
      *(void *)std::string __str = 0LL;
      sub_1000B0400((uint64_t)__str);
      uint64_t v6 = *(int *)__str;
      uint64_t v7 = *(__int16 *)&__str[4];
      __int128 v18 = 0u;
      __int128 v19 = 0u;
      *(_OWORD *)std::string __str = 0u;
      __int128 v17 = 0u;
      snprintf(__str, 0x3FuLL, "%0llu.%0llu", v6, v7);
      sub_10002418C(__p, __str);
      if (v10 >= 0) {
        id v8 = __p;
      }
      else {
        id v8 = (void **)__p[0];
      }
      *(_DWORD *)__int128 buf = 138543618;
      id v13 = v3;
      __int16 v14 = 2080;
      uint64_t v15 = v8;
      _os_log_debug_impl( (void *)&_mh_execute_header,  v5,  OS_LOG_TYPE_DEBUG,  "resetDeviceAddedToFilterAcceptListTime for device %{public}@ at %s",  buf,  0x16u);
      if (v10 < 0) {
        operator delete(__p[0]);
      }
    }
  }

  sub_100242FAC((uint64_t)v11);
}

void sub_1005D3DB4( _Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, ...)
{
  _Unwind_Resume(a1);
}

void sub_1005D3DE4(uint64_t a1@<X0>, void *a2@<X1>, uint64_t a3@<X8>)
{
  id v5 = a2;
  v7[0] = 0LL;
  v7[1] = 0LL;
  sub_100242F28((uint64_t)v7, a1 + 80);
  uint64_t v6 = sub_1005C6AC0(a1, v5);
  if (v6)
  {
    *(_OWORD *)a3 = *(_OWORD *)(v6 + 240);
  }

  else
  {
    *(void *)a3 = 0LL;
    *(void *)(a3 + 8) = 0LL;
  }

  sub_100242FAC((uint64_t)v7);
}

void sub_1005D3E58( _Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9)
{
  _Unwind_Resume(a1);
}

void sub_1005D3E78(uint64_t a1, void *a2, char a3)
{
  id v5 = a2;
  v7[0] = 0LL;
  v7[1] = 0LL;
  sub_100242F28((uint64_t)v7, a1 + 80);
  uint64_t v6 = sub_1005C6AC0(a1, v5);
  if (v6)
  {
    *((_BYTE *)v6 + 162) = a3;
    sub_100241F90(v8, v5);
    sub_1005CB37C(a1, v8);
  }

  sub_100242FAC((uint64_t)v7);
}

void sub_1005D3F24(_Unwind_Exception *a1, uint64_t a2, ...)
{
  _Unwind_Resume(a1);
}

void sub_1005D3F50(uint64_t a1, uint64_t a2)
{
  id v4 = *(id *)(a2 + 520);
  int v5 = *(unsigned __int8 *)(a2 + 528);
  char v6 = *(_BYTE *)(a2 + 544);
  id v9 = v4;
  if (v4) {
    BOOL v7 = v5 == 0;
  }
  else {
    BOOL v7 = 1;
  }
  if (!v7)
  {
    int v8 = *(_DWORD *)(a2 + 532);
    sub_1005C2558(a2, 0, 0LL, 0);
    sub_1005C2558(a1, v5, v9, v8);
  }

  *(_BYTE *)(a1 + 544) = v6;
}

void sub_1005D3FDC( _Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, id a10)
{
}

uint64_t sub_1005D3FF0(uint64_t a1, uint64_t a2)
{
  return (*(uint64_t (**)(uint64_t, void))(*(void *)a2 + 8LL))(a2, *(void *)(a1 + 32));
}

void sub_1005D4008(uint64_t a1, void *a2, char a3)
{
  id v4 = a2;
  id v7 = v4;
  if (qword_1008D5F30 == -1)
  {
    int v5 = v4;
  }

  else
  {
    dispatch_once(&qword_1008D5F30, &stru_1008A3498);
    int v5 = v7;
  }

  char v6 = sub_1005C6AC0((uint64_t)off_1008D5F28, v5);
  if (v6) {
    *((_BYTE *)v6 + 237) = a3;
  }
}

void sub_1005D407C( _Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, id a10)
{
}

BOOL sub_1005D4090(uint64_t a1, void *a2)
{
  id v2 = a2;
  if (qword_1008D5F30 != -1) {
    dispatch_once(&qword_1008D5F30, &stru_1008A3498);
  }
  id v3 = sub_1005C6AC0((uint64_t)off_1008D5F28, v2);
  if (v3) {
    BOOL v4 = *((_BYTE *)v3 + 237) != 0;
  }
  else {
    BOOL v4 = 0LL;
  }

  return v4;
}

void sub_1005D4108(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_1005D4118(uint64_t a1, void *a2)
{
  id v2 = a2;
  id v5 = v2;
  if (qword_1008D5F30 == -1)
  {
    id v3 = v2;
  }

  else
  {
    dispatch_once(&qword_1008D5F30, &stru_1008A3498);
    id v3 = v5;
  }

  BOOL v4 = sub_1005C6AC0((uint64_t)off_1008D5F28, v3);
  if (v4) {
    sub_1005C0C18((uint64_t)v4);
  }
}

void sub_1005D4188( _Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, id a10)
{
}

id sub_1005D419C(uint64_t a1)
{
  id v2 = (void *)objc_claimAutoreleasedReturnValue(+[NSMutableArray array](&OBJC_CLASS___NSMutableArray, "array"));
  v18[0] = 0LL;
  v18[1] = 0LL;
  sub_100242F28((uint64_t)v18, a1 + 80);
  __int128 v16 = 0u;
  __int128 v17 = 0u;
  __int128 v14 = 0u;
  __int128 v15 = 0u;
  id v3 = *(id *)(a1 + 160);
  id v4 = [v3 countByEnumeratingWithState:&v14 objects:v19 count:16];
  if (v4)
  {
    uint64_t v5 = *(void *)v15;
    do
    {
      for (uint64_t i = 0LL; i != v4; uint64_t i = (char *)i + 1)
      {
        if (*(void *)v15 != v5) {
          objc_enumerationMutation(v3);
        }
        uint64_t v7 = *(void *)(*((void *)&v14 + 1) + 8LL * (void)i);
        int v8 = (char *)[*(id *)(a1 + 160) objectForKey:v7];
        sub_10002418C(__p, "HasBuiltinServices");
        uint64_t v9 = sub_100024098((uint64_t)(v8 + 176), (const void **)__p);
        if (v13 < 0) {
          operator delete(__p[0]);
        }
      }

      id v4 = [v3 countByEnumeratingWithState:&v14 objects:v19 count:16];
    }

    while (v4);
  }

  sub_100242F54((uint64_t)v18);
  char v10 = (void *)objc_claimAutoreleasedReturnValue([v2 indexesOfObjectsPassingTest:&stru_1008A3410]);
  [v2 removeObjectsAtIndexes:v10];

  sub_100242FAC((uint64_t)v18);
  return v2;
}

void sub_1005D4350( _Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void *__p, uint64_t a11, int a12, __int16 a13, char a14, char a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20, uint64_t a21, uint64_t a22, uint64_t a23, char a24)
{
  sub_100242FAC((uint64_t)&a24);
  _Unwind_Resume(a1);
}

BOOL sub_1005D43B8(id a1, NSUUID *a2, unint64_t a3, BOOL *a4)
{
  id v4 = a2;
  if (qword_1008D5F20 != -1) {
    dispatch_once(&qword_1008D5F20, &stru_1008A34D8);
  }
  BOOL v5 = !sub_10061C0F8(qword_1008D5F18, v4);

  return v5;
}

void sub_1005D441C(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_1005D442C(uint64_t a1, void *a2, int a3)
{
  id v4 = a2;
  if (qword_1008D5F30 != -1) {
    dispatch_once(&qword_1008D5F30, &stru_1008A3498);
  }
  BOOL v5 = sub_1005C6AC0((uint64_t)off_1008D5F28, v4);
  if (v5)
  {
    sub_1005C0BD8(v5, a3);
  }

  else
  {
    char v6 = (os_log_s *)qword_1008F75A0;
    if (os_log_type_enabled((os_log_t)qword_1008F75A0, OS_LOG_TYPE_DEFAULT))
    {
      int v7 = 138543362;
      id v8 = v4;
      _os_log_impl( (void *)&_mh_execute_header,  v6,  OS_LOG_TYPE_DEFAULT,  "updateRSSIStatForDevice - device not available %{public}@",  (uint8_t *)&v7,  0xCu);
    }
  }
}

void sub_1005D4520(_Unwind_Exception *exception_object)
{
}

void sub_1005D4538(uint64_t a1, void *a2, int a3)
{
  id v4 = a2;
  if (qword_1008D5F30 != -1) {
    dispatch_once(&qword_1008D5F30, &stru_1008A3498);
  }
  BOOL v5 = sub_1005C6AC0((uint64_t)off_1008D5F28, v4);
  if (v5)
  {
    sub_1005C0BF8(v5, a3);
  }

  else
  {
    char v6 = (os_log_s *)qword_1008F75A0;
    if (os_log_type_enabled((os_log_t)qword_1008F75A0, OS_LOG_TYPE_DEFAULT))
    {
      int v7 = 138543362;
      id v8 = v4;
      _os_log_impl( (void *)&_mh_execute_header,  v6,  OS_LOG_TYPE_DEFAULT,  "updatePERStatForDevice - device not available %{public}@",  (uint8_t *)&v7,  0xCu);
    }
  }
}

void sub_1005D462C(_Unwind_Exception *exception_object)
{
}

void sub_1005D4644(uint64_t a1, void *a2, char a3)
{
  id v5 = a2;
  v7[0] = 0LL;
  v7[1] = 0LL;
  sub_100242F28((uint64_t)v7, a1 + 80);
  char v6 = sub_1005C6AC0(a1, v5);
  if (v6) {
    *((_BYTE *)v6 + 609) = a3;
  }
  sub_100242FAC((uint64_t)v7);
}

void sub_1005D46AC( _Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9)
{
  _Unwind_Resume(a1);
}

void sub_1005D46CC(uint64_t a1, void *a2, __int16 a3)
{
  id v4 = a2;
  if (qword_1008D5F30 != -1) {
    dispatch_once(&qword_1008D5F30, &stru_1008A3498);
  }
  *((_WORD *)sub_1005C6AC0((uint64_t)off_1008D5F28, v4) + 16) = a3;
  uint64_t v5 = sub_100404EB8();
  v7[0] = _NSConcreteStackBlock;
  v7[1] = 3221225472LL;
  void v7[2] = sub_1005D47B8;
  v7[3] = &unk_1008A3438;
  id v6 = v4;
  id v8 = v6;
  __int16 v9 = a3;
  sub_100405384(v5, v7);
}

void sub_1005D4798( _Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, void *a13)
{
  _Unwind_Resume(a1);
}

uint64_t sub_1005D47B8(uint64_t a1)
{
  uint64_t v2 = sub_1002E8EE8();
  return (*(uint64_t (**)(uint64_t, void, void, uint64_t))(*(void *)v2 + 88LL))( v2,  *(void *)(a1 + 32),  *(unsigned __int16 *)(a1 + 40),  1LL);
}

void sub_1005D47EC(uint64_t a1, void *a2)
{
  id v3 = a2;
  id v4 = sub_1005D419C(a1);
  uint64_t v5 = (void *)objc_claimAutoreleasedReturnValue(v4);
  if ([v5 indexOfObject:v3] != (id)0x7FFFFFFFFFFFFFFFLL)
  {
    id v6 = (char *)[*(id *)(a1 + 160) objectForKey:v3];
    sub_10002418C(__p, "HasBuiltinServices");
    uint64_t v7 = sub_100024098((uint64_t)(v6 + 176), (const void **)__p);
    id v8 = v6 + 184;
    if (v12 < 0) {
      operator delete(__p[0]);
    }
    if (v8 != (char *)v7)
    {
      sub_10002418C(v9, "DoNotAutoConnect");
      sub_1005CCF08(a1, v3, (unsigned __int8 *)v9);
      if (v10 < 0) {
        operator delete(v9[0]);
      }
    }
  }
}

void sub_1005D48D0( _Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, void *__p, uint64_t a10, int a11, __int16 a12, char a13, char a14, uint64_t a15, uint64_t a16, int a17, __int16 a18, char a19, char a20)
{
  if (a14 < 0) {
    operator delete(__p);
  }

  _Unwind_Resume(a1);
}

void sub_1005D491C(uint64_t a1, void *a2, char a3)
{
  id v5 = a2;
  v7[0] = 0LL;
  v7[1] = 0LL;
  sub_100242F28((uint64_t)v7, a1 + 80);
  id v6 = sub_1005C6AC0(a1, v5);
  if (v6) {
    *((_BYTE *)v6 + 234) = a3;
  }
  sub_100242FAC((uint64_t)v7);
}

void sub_1005D4984( _Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9)
{
  _Unwind_Resume(a1);
}

BOOL sub_1005D49A4(uint64_t a1, void *a2)
{
  id v3 = a2;
  v7[0] = 0LL;
  v7[1] = 0LL;
  sub_100242F28((uint64_t)v7, a1 + 80);
  id v4 = sub_1005C6AC0(a1, v3);
  if (v4) {
    BOOL v5 = *((_BYTE *)v4 + 234) != 0;
  }
  else {
    BOOL v5 = 0LL;
  }
  sub_100242FAC((uint64_t)v7);

  return v5;
}

void sub_1005D4A14( _Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9)
{
  _Unwind_Resume(a1);
}

void sub_1005D4A34(uint64_t a1, void *a2, char a3)
{
  id v5 = a2;
  v7[0] = 0LL;
  v7[1] = 0LL;
  sub_100242F28((uint64_t)v7, a1 + 80);
  id v6 = sub_1005C6AC0(a1, v5);
  if (v6) {
    *((_BYTE *)v6 + 235) = a3;
  }
  sub_100242FAC((uint64_t)v7);
}

void sub_1005D4A9C( _Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9)
{
  _Unwind_Resume(a1);
}

BOOL sub_1005D4ABC(uint64_t a1, void *a2)
{
  id v3 = a2;
  v7[0] = 0LL;
  v7[1] = 0LL;
  sub_100242F28((uint64_t)v7, a1 + 80);
  id v4 = sub_1005C6AC0(a1, v3);
  if (v4) {
    BOOL v5 = *((_BYTE *)v4 + 235) != 0;
  }
  else {
    BOOL v5 = 0LL;
  }
  sub_100242FAC((uint64_t)v7);

  return v5;
}

void sub_1005D4B2C( _Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9)
{
  _Unwind_Resume(a1);
}

void sub_1005D4B4C(uint64_t a1, void *a2, int a3)
{
  id v5 = a2;
  v9[0] = 0LL;
  v9[1] = 0LL;
  sub_100242F28((uint64_t)v9, a1 + 80);
  id v6 = sub_1005C6AC0(a1, v5);
  if (v6)
  {
    int v7 = *((unsigned __int8 *)v6 + 236);
    if ((*((_BYTE *)v6 + 236) != 0) != a3)
    {
      *((_BYTE *)v6 + 236) = a3;
      id v8 = (os_log_s *)qword_1008F75A0;
      if (os_log_type_enabled((os_log_t)qword_1008F75A0, OS_LOG_TYPE_DEFAULT))
      {
        *(_DWORD *)__int128 buf = 138543874;
        id v11 = v5;
        __int16 v12 = 1024;
        int v13 = v7;
        __int16 v14 = 1024;
        int v15 = a3;
        _os_log_impl( (void *)&_mh_execute_header,  v8,  OS_LOG_TYPE_DEFAULT,  "AutoReconnectEnabled changed - device %{public}@ enabled updated from %d to %d",  buf,  0x18u);
      }
    }
  }

  sub_100242FAC((uint64_t)v9);
}

void sub_1005D4C58( _Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9)
{
  _Unwind_Resume(a1);
}

BOOL sub_1005D4C80(uint64_t a1, void *a2)
{
  id v3 = a2;
  v7[0] = 0LL;
  v7[1] = 0LL;
  sub_100242F28((uint64_t)v7, a1 + 80);
  id v4 = sub_1005C6AC0(a1, v3);
  if (v4) {
    BOOL v5 = *((_BYTE *)v4 + 236) != 0;
  }
  else {
    BOOL v5 = 0LL;
  }
  sub_100242FAC((uint64_t)v7);

  return v5;
}

void sub_1005D4CF0( _Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9)
{
  _Unwind_Resume(a1);
}

void sub_1005D4D10(uint64_t a1, void *a2, char a3)
{
  id v5 = a2;
  v18[0] = 0LL;
  v18[1] = 0LL;
  sub_100242F28((uint64_t)v18, a1 + 80);
  id v6 = sub_1005C6AC0(a1, v5);
  if (v6)
  {
    if (!v6[8]) {
      *((_BYTE *)v6 + 238) = a3;
    }
    *(_OWORD *)__int128 v16 = 0u;
    __int128 v17 = 0u;
    LODWORD(v16[0]) = *(_DWORD *)(a1 + 256);
    sub_100240540(&v16[1], a1 + 264);
    sub_100242F54((uint64_t)v18);
    v12._uint64_t os_unfair_lock_opaque = (uint32_t)v16[0];
    __uuid_t dst = 0LL;
    uint64_t v15 = 0LL;
    std::string __p = 0LL;
    int v7 = v16[1];
    int64_t v8 = v17 - (unint64_t)v16[1];
    if ((void *)v17 != v16[1])
    {
      sub_10023DBC8(&__p, v8 >> 3);
      __int16 v9 = (char *)__dst;
      memmove(__dst, v7, v8);
      __uuid_t dst = &v9[8 * (v8 >> 3)];
    }

    v10[0] = _NSConcreteStackBlock;
    v10[1] = 3221225472LL;
    void v10[2] = sub_1005D4EC0;
    v10[3] = &unk_1008A33D0;
    id v11 = v5;
    sub_1005DC3A4(&v12, v10);
    if (__p)
    {
      __uuid_t dst = __p;
      operator delete(__p);
    }

    if (v16[1])
    {
      *(void **)&__int128 v17 = v16[1];
      operator delete(v16[1]);
    }
  }

  sub_100242FAC((uint64_t)v18);
}

void sub_1005D4E64( _Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, void *a14, uint64_t a15, void *__p, uint64_t a17, uint64_t a18, uint64_t a19, void *a20, uint64_t a21)
{
  if (__p) {
    operator delete(__p);
  }
  if (a20) {
    operator delete(a20);
  }
  sub_100242FAC(v22 - 64);

  _Unwind_Resume(a1);
}

uint64_t sub_1005D4EC0(uint64_t a1, uint64_t (***a2)(void, void, uint64_t))
{
  return (**a2)(a2, *(void *)(a1 + 32), 1LL);
}

BOOL sub_1005D4EDC(uint64_t a1, void *a2)
{
  id v3 = a2;
  v7[0] = 0LL;
  v7[1] = 0LL;
  sub_100242F28((uint64_t)v7, a1 + 80);
  id v4 = sub_1005C6AC0(a1, v3);
  if (v4) {
    BOOL v5 = *((_BYTE *)v4 + 238) != 0;
  }
  else {
    BOOL v5 = 0LL;
  }
  sub_100242FAC((uint64_t)v7);

  return v5;
}

void sub_1005D4F4C( _Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9)
{
  _Unwind_Resume(a1);
}

void sub_1005D4F6C(uint64_t a1, void *a2)
{
  id v3 = a2;
  v5[0] = 0LL;
  v5[1] = 0LL;
  sub_100242F28((uint64_t)v5, a1 + 80);
  id v4 = sub_1005C6AC0(a1, v3);
  if (v4) {
    sub_1005C1CFC((uint64_t)v4, 1);
  }
  sub_100242FAC((uint64_t)v5);
}

void sub_1005D4FCC(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

BOOL sub_1005D4FEC(uint64_t a1, void *a2)
{
  id v3 = a2;
  v7[0] = 0LL;
  v7[1] = 0LL;
  sub_100242F28((uint64_t)v7, a1 + 80);
  id v4 = sub_1005C6AC0(a1, v3);
  if (v4) {
    BOOL v5 = sub_1005C4708((uint64_t)v4);
  }
  else {
    BOOL v5 = 0LL;
  }
  sub_100242FAC((uint64_t)v7);

  return v5;
}

void sub_1005D5058(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

uint64_t sub_1005D5078(uint64_t a1)
{
  __int128 v8 = 0u;
  __int128 v9 = 0u;
  __int128 v10 = 0u;
  __int128 v11 = 0u;
  id v2 = *(id *)(a1 + 160);
  unsigned __int8 v3 = 0;
  id v4 = [v2 countByEnumeratingWithState:&v8 objects:v12 count:16];
  if (v4)
  {
    uint64_t v5 = *(void *)v9;
    do
    {
      for (uint64_t i = 0LL; i != v4; uint64_t i = (char *)i + 1)
      {
        if (*(void *)v9 != v5) {
          objc_enumerationMutation(v2);
        }
        v3 += *((_BYTE *)objc_msgSend( *(id *)(a1 + 160),  "objectForKey:",  *(void *)(*((void *)&v8 + 1) + 8 * (void)i),  (void)v8)
              + 237);
      }

      id v4 = [v2 countByEnumeratingWithState:&v8 objects:v12 count:16];
    }

    while (v4);
  }

  return v3;
}

void sub_1005D5180(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

uint64_t sub_1005D51A4(uint64_t a1, uint64_t a2)
{
  return (*(uint64_t (**)(uint64_t, void))(*(void *)a2 + 8LL))(a2, *(void *)(a1 + 32));
}

uint64_t sub_1005D51BC(uint64_t a1)
{
  id v2 = (os_log_s *)qword_1008F75A0;
  if (os_log_type_enabled((os_log_t)qword_1008F75A0, OS_LOG_TYPE_DEFAULT))
  {
    *(_WORD *)__int128 buf = 0;
    _os_log_impl((void *)&_mh_execute_header, v2, OS_LOG_TYPE_DEFAULT, "Clearing all records of all devices", buf, 2u);
  }

  *(void *)__int128 buf = 0LL;
  uint64_t v15 = 0LL;
  sub_100242F28((uint64_t)buf, a1 + 80);
  __int128 v12 = 0u;
  __int128 v13 = 0u;
  __int128 v10 = 0u;
  __int128 v11 = 0u;
  id v3 = *(id *)(a1 + 160);
  id v4 = [v3 countByEnumeratingWithState:&v10 objects:v16 count:16];
  if (v4)
  {
    uint64_t v5 = *(void *)v11;
    do
    {
      id v6 = 0LL;
      do
      {
        if (*(void *)v11 != v5) {
          objc_enumerationMutation(v3);
        }
        free( objc_msgSend( *(id *)(a1 + 160),  "objectForKey:",  *(void *)(*((void *)&v10 + 1) + 8 * (void)v6),  (void)v10));
        id v6 = (char *)v6 + 1;
      }

      while (v4 != v6);
      id v4 = [v3 countByEnumeratingWithState:&v10 objects:v16 count:16];
    }

    while (v4);
  }

  [*(id *)(a1 + 160) removeAllObjects];
  sub_10023DF50((void *)(a1 + 192));
  [*(id *)(a1 + 248) removeAllObjects];
  __int128 v8 = *(void **)(a1 + 176);
  int v7 = (void *)(a1 + 176);
  sub_10023BF24((uint64_t)(v7 - 1), v8);
  *(v7 - 1) = v7;
  *int v7 = 0LL;
  v7[1] = 0LL;
  sub_1002DCFEC(v7[8]);
  return sub_100242FAC((uint64_t)buf);
}

void sub_1005D5340( _Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, ...)
{
  sub_100242FAC((uint64_t)va);
  _Unwind_Resume(a1);
}

uint64_t sub_1005D5374(uint64_t a1, void *a2, void *a3)
{
  id v5 = a2;
  __int128 v19 = a3;
  v26[0] = 0LL;
  v26[1] = 0LL;
  sub_100242F28((uint64_t)v26, a1 + 80);
  __int128 v24 = 0u;
  __int128 v25 = 0u;
  __int128 v22 = 0u;
  __int128 v23 = 0u;
  id v6 = *(id *)(a1 + 160);
  id v7 = [v6 countByEnumeratingWithState:&v22 objects:v27 count:16];
  if (v7)
  {
    uint64_t v8 = *(void *)v23;
LABEL_3:
    uint64_t v9 = 0LL;
    while (1)
    {
      if (*(void *)v23 != v8) {
        objc_enumerationMutation(v6);
      }
      __int128 v10 = (char *)[*(id *)(a1 + 160) objectForKey:*(void *)(*((void *)&v22 + 1) + 8 * v9)];
      __int128 v11 = v10;
      __int128 v12 = v10 + 208;
      if (v10[231] < 0)
      {
        sub_100024238(__p, *((void **)v10 + 26), *((void *)v10 + 27));
      }

      else
      {
        *(_OWORD *)std::string __p = *(_OWORD *)v12;
        uint64_t v21 = *((void *)v10 + 28);
      }

      if (SHIBYTE(v21) < 0)
      {
        __int128 v13 = __p[1];
        operator delete(__p[0]);
        if (v13)
        {
LABEL_13:
          if (v11[231] < 0)
          {
            sub_100024238(__p, *((void **)v11 + 26), *((void *)v11 + 27));
          }

          else
          {
            *(_OWORD *)std::string __p = *(_OWORD *)v12;
            uint64_t v21 = *((void *)v12 + 2);
          }

          if (v21 >= 0) {
            __int16 v14 = __p;
          }
          else {
            __int16 v14 = (void **)__p[0];
          }
          uint64_t v15 = (void *)objc_claimAutoreleasedReturnValue(+[NSString stringWithUTF8String:](&OBJC_CLASS___NSString, "stringWithUTF8String:", v14));
          unsigned int v16 = [v5 isEqualToString:v15];

          if (SHIBYTE(v21) < 0) {
            operator delete(__p[0]);
          }
          if (v16)
          {
            ((void (**)(id, char *))v19)[2](v19, v11);
            uint64_t v17 = 1LL;
            goto LABEL_26;
          }
        }
      }

      else if (HIBYTE(v21))
      {
        goto LABEL_13;
      }

      if (v7 == (id)++v9)
      {
        id v7 = [v6 countByEnumeratingWithState:&v22 objects:v27 count:16];
        if (v7) {
          goto LABEL_3;
        }
        break;
      }
    }
  }

  uint64_t v17 = 0LL;
LABEL_26:

  sub_100242FAC((uint64_t)v26);
  return v17;
}

void sub_1005D5594( _Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void *a10, void *__p, uint64_t a12, int a13, __int16 a14, char a15, char a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20, uint64_t a21, uint64_t a22, uint64_t a23, uint64_t a24, uint64_t a25, char a26)
{
  sub_100242FAC((uint64_t)&a26);
  _Unwind_Resume(a1);
}

BOOL sub_1005D5604(uint64_t a1, void *a2, void *a3)
{
  id v5 = a2;
  id v6 = a3;
  v9[0] = 0LL;
  v9[1] = 0LL;
  sub_100242F28((uint64_t)v9, a1 + 80);
  id v7 = sub_1005C6AC0(a1, v5);
  if (v7) {
    v6[2](v6, v7);
  }
  sub_100242FAC((uint64_t)v9);

  return v7 != 0LL;
}

void sub_1005D5694(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_1005D56B8(uint64_t a1, void *a2, void *a3)
{
  id v5 = a2;
  id v6 = a3;
  id v7 = (os_log_s *)qword_1008F75A0;
  if (os_log_type_enabled((os_log_t)qword_1008F75A0, OS_LOG_TYPE_DEFAULT))
  {
    *(_DWORD *)uint64_t v9 = 138543618;
    *(void *)&void v9[4] = v5;
    *(_WORD *)&v9[12] = 2114;
    *(void *)&v9[14] = v6;
    _os_log_impl( (void *)&_mh_execute_header,  v7,  OS_LOG_TYPE_DEFAULT,  "DIS for device %{public}@ DIS Manufacturer: %{public}@",  v9,  0x16u);
  }

  *(void *)uint64_t v9 = 0LL;
  *(void *)&__int16 v9[8] = 0LL;
  sub_100242F28((uint64_t)v9, a1 + 80);
  uint64_t v8 = (id *)sub_1005C6AC0(a1, v5);
  if (v8) {
    objc_storeStrong(v8 + 34, a3);
  }
  sub_100242FAC((uint64_t)v9);
}

void sub_1005D57C4( _Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9)
{
  _Unwind_Resume(a1);
}

id sub_1005D57F0(uint64_t a1, void *a2)
{
  id v3 = a2;
  id v4 = (os_log_s *)qword_1008F75A0;
  if (os_log_type_enabled((os_log_t)qword_1008F75A0, OS_LOG_TYPE_DEFAULT))
  {
    LODWORD(v8) = 138543362;
    *(void *)((char *)&v8 + 4) = v3;
    _os_log_impl( (void *)&_mh_execute_header,  v4,  OS_LOG_TYPE_DEFAULT,  "DIS manufacturer name for device %{public}@",  (uint8_t *)&v8,  0xCu);
  }

  __int128 v8 = 0uLL;
  sub_100242F28((uint64_t)&v8, a1 + 80);
  id v5 = sub_1005C6AC0(a1, v3);
  if (v5) {
    id v6 = (id)v5[34];
  }
  else {
    id v6 = 0LL;
  }
  sub_100242FAC((uint64_t)&v8);

  return v6;
}

void sub_1005D58E4( _Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9)
{
  _Unwind_Resume(a1);
}

void sub_1005D590C(uint64_t a1, void *a2, void *a3)
{
  id v5 = a2;
  id v6 = a3;
  id v7 = (os_log_s *)qword_1008F75A0;
  if (os_log_type_enabled((os_log_t)qword_1008F75A0, OS_LOG_TYPE_DEFAULT))
  {
    *(_DWORD *)uint64_t v9 = 138543618;
    *(void *)&void v9[4] = v5;
    *(_WORD *)&v9[12] = 2114;
    *(void *)&v9[14] = v6;
    _os_log_impl( (void *)&_mh_execute_header,  v7,  OS_LOG_TYPE_DEFAULT,  "DIS for device %{public}@ DIS Model number: %{public}@",  v9,  0x16u);
  }

  *(void *)uint64_t v9 = 0LL;
  *(void *)&__int16 v9[8] = 0LL;
  sub_100242F28((uint64_t)v9, a1 + 80);
  __int128 v8 = (id *)sub_1005C6AC0(a1, v5);
  if (v8) {
    objc_storeStrong(v8 + 35, a3);
  }
  sub_100242FAC((uint64_t)v9);
}

void sub_1005D5A18( _Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9)
{
  _Unwind_Resume(a1);
}

void sub_1005D5A44(uint64_t a1, void *a2, void *a3)
{
  id v5 = a2;
  id v6 = a3;
  id v7 = (os_log_s *)qword_1008F75A0;
  if (os_log_type_enabled((os_log_t)qword_1008F75A0, OS_LOG_TYPE_DEFAULT))
  {
    *(_DWORD *)uint64_t v9 = 138543618;
    *(void *)&void v9[4] = v5;
    *(_WORD *)&v9[12] = 2112;
    *(void *)&v9[14] = v6;
    _os_log_impl( (void *)&_mh_execute_header,  v7,  OS_LOG_TYPE_DEFAULT,  "DIS for device %{public}@ DIS serial number: %@",  v9,  0x16u);
  }

  *(void *)uint64_t v9 = 0LL;
  *(void *)&__int16 v9[8] = 0LL;
  sub_100242F28((uint64_t)v9, a1 + 80);
  __int128 v8 = (id *)sub_1005C6AC0(a1, v5);
  if (v8) {
    objc_storeStrong(v8 + 36, a3);
  }
  sub_100242FAC((uint64_t)v9);
}

void sub_1005D5B50( _Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9)
{
  _Unwind_Resume(a1);
}

void sub_1005D5B7C(uint64_t a1, void *a2, void *a3)
{
  id v5 = a2;
  id v6 = a3;
  id v7 = (os_log_s *)qword_1008F75A0;
  if (os_log_type_enabled((os_log_t)qword_1008F75A0, OS_LOG_TYPE_DEFAULT))
  {
    *(_DWORD *)uint64_t v9 = 138543618;
    *(void *)&void v9[4] = v5;
    *(_WORD *)&v9[12] = 2114;
    *(void *)&v9[14] = v6;
    _os_log_impl( (void *)&_mh_execute_header,  v7,  OS_LOG_TYPE_DEFAULT,  "DIS for device %{public}@ DIS HW Revision: %{public}@",  v9,  0x16u);
  }

  *(void *)uint64_t v9 = 0LL;
  *(void *)&__int16 v9[8] = 0LL;
  sub_100242F28((uint64_t)v9, a1 + 80);
  __int128 v8 = (id *)sub_1005C6AC0(a1, v5);
  if (v8) {
    objc_storeStrong(v8 + 37, a3);
  }
  sub_100242FAC((uint64_t)v9);
}

void sub_1005D5C88( _Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9)
{
  _Unwind_Resume(a1);
}

void sub_1005D5CB4(uint64_t a1, void *a2, void *a3)
{
  id v5 = a2;
  id v6 = a3;
  id v7 = (os_log_s *)qword_1008F75A0;
  if (os_log_type_enabled((os_log_t)qword_1008F75A0, OS_LOG_TYPE_DEFAULT))
  {
    *(_DWORD *)uint64_t v9 = 138543618;
    *(void *)&void v9[4] = v5;
    *(_WORD *)&v9[12] = 2114;
    *(void *)&v9[14] = v6;
    _os_log_impl( (void *)&_mh_execute_header,  v7,  OS_LOG_TYPE_DEFAULT,  "DIS for device %{public}@ DIS FW Revision: %{public}@",  v9,  0x16u);
  }

  *(void *)uint64_t v9 = 0LL;
  *(void *)&__int16 v9[8] = 0LL;
  sub_100242F28((uint64_t)v9, a1 + 80);
  __int128 v8 = (id *)sub_1005C6AC0(a1, v5);
  if (v8) {
    objc_storeStrong(v8 + 38, a3);
  }
  sub_100242FAC((uint64_t)v9);
}

void sub_1005D5DC0( _Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9)
{
  _Unwind_Resume(a1);
}

void sub_1005D5DEC(uint64_t a1, void *a2, void *a3)
{
  id v5 = a2;
  id v6 = a3;
  id v7 = (os_log_s *)qword_1008F75A0;
  if (os_log_type_enabled((os_log_t)qword_1008F75A0, OS_LOG_TYPE_DEFAULT))
  {
    *(_DWORD *)uint64_t v9 = 138543618;
    *(void *)&void v9[4] = v5;
    *(_WORD *)&v9[12] = 2114;
    *(void *)&v9[14] = v6;
    _os_log_impl( (void *)&_mh_execute_header,  v7,  OS_LOG_TYPE_DEFAULT,  "DIS for device %{public}@ DIS SW Revision: %{public}@",  v9,  0x16u);
  }

  *(void *)uint64_t v9 = 0LL;
  *(void *)&__int16 v9[8] = 0LL;
  sub_100242F28((uint64_t)v9, a1 + 80);
  __int128 v8 = (id *)sub_1005C6AC0(a1, v5);
  if (v8) {
    objc_storeStrong(v8 + 39, a3);
  }
  sub_100242FAC((uint64_t)v9);
}

void sub_1005D5EF8( _Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9)
{
  _Unwind_Resume(a1);
}

void sub_1005D5F24(uint64_t a1, void *a2, void *a3)
{
  id v5 = a2;
  id v6 = a3;
  id v7 = (os_log_s *)qword_1008F75A0;
  if (os_log_type_enabled((os_log_t)qword_1008F75A0, OS_LOG_TYPE_DEFAULT))
  {
    *(_DWORD *)uint64_t v9 = 138543618;
    *(void *)&void v9[4] = v5;
    *(_WORD *)&v9[12] = 2114;
    *(void *)&v9[14] = v6;
    _os_log_impl( (void *)&_mh_execute_header,  v7,  OS_LOG_TYPE_DEFAULT,  "DIS for device %{public}@ DIS systemID: %{public}@",  v9,  0x16u);
  }

  *(void *)uint64_t v9 = 0LL;
  *(void *)&__int16 v9[8] = 0LL;
  sub_100242F28((uint64_t)v9, a1 + 80);
  __int128 v8 = (id *)sub_1005C6AC0(a1, v5);
  if (v8) {
    objc_storeStrong(v8 + 40, a3);
  }
  sub_100242FAC((uint64_t)v9);
}

void sub_1005D6030( _Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9)
{
  _Unwind_Resume(a1);
}

void sub_1005D605C(uint64_t a1, void *a2, void *a3)
{
  id v5 = a2;
  id v6 = a3;
  id v7 = (os_log_s *)qword_1008F75A0;
  if (os_log_type_enabled((os_log_t)qword_1008F75A0, OS_LOG_TYPE_DEFAULT))
  {
    *(_DWORD *)uint64_t v9 = 138543618;
    *(void *)&void v9[4] = v5;
    *(_WORD *)&v9[12] = 2112;
    *(void *)&v9[14] = v6;
    _os_log_impl( (void *)&_mh_execute_header,  v7,  OS_LOG_TYPE_DEFAULT,  "DIS for device %{public}@ DIS regulatory data: %@",  v9,  0x16u);
  }

  *(void *)uint64_t v9 = 0LL;
  *(void *)&__int16 v9[8] = 0LL;
  sub_100242F28((uint64_t)v9, a1 + 80);
  __int128 v8 = (id *)sub_1005C6AC0(a1, v5);
  if (v8) {
    objc_storeStrong(v8 + 41, a3);
  }
  sub_100242FAC((uint64_t)v9);
}

void sub_1005D6168( _Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9)
{
  _Unwind_Resume(a1);
}

void sub_1005D6194(uint64_t a1, void *a2, void *a3)
{
  id v5 = a2;
  id v6 = a3;
  id v7 = (os_log_s *)qword_1008F75A0;
  if (os_log_type_enabled((os_log_t)qword_1008F75A0, OS_LOG_TYPE_DEFAULT))
  {
    *(_DWORD *)__int128 v11 = 138543618;
    *(void *)&void v11[4] = v5;
    *(_WORD *)&v11[12] = 2114;
    *(void *)&v11[14] = v6;
    _os_log_impl( (void *)&_mh_execute_header,  v7,  OS_LOG_TYPE_DEFAULT,  "DIS for device %{public}@ DIS PNP ID: %{public}@",  v11,  0x16u);
  }

  *(void *)__int128 v11 = 0LL;
  *(void *)&v11[8] = 0LL;
  sub_100242F28((uint64_t)v11, a1 + 80);
  __int128 v8 = (id *)sub_1005C6AC0(a1, v5);
  uint64_t v9 = v8;
  if (v8)
  {
    if (sub_1005C4708((uint64_t)v8) && sub_1002E8D94())
    {
      uint64_t v10 = sub_1002E8D94();
      (*(void (**)(uint64_t, void, id))(*(void *)v10 + 576LL))(v10, *((unsigned __int16 *)v9 + 128), v6);
    }

    objc_storeStrong(v9 + 42, a3);
    sub_1005D6308(a1, v5);
  }

  sub_100242FAC((uint64_t)v11);
}

void sub_1005D62DC(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_1005D6308(uint64_t a1, void *a2)
{
  id v3 = a2;
  id v4 = sub_1005C6AC0(a1, v3);
  uint64_t v5 = (uint64_t)v4;
  if (v4)
  {
    id v6 = (id)v4[42];
    id v7 = v6;
    if (!v6)
    {
LABEL_27:

      goto LABEL_28;
    }

    __int128 v8 = (char *)[v6 bytes];
    int v9 = *(unsigned __int16 *)(v8 + 1);
    int v10 = *(unsigned __int16 *)(v8 + 3);
    if (v9 != 1118) {
      goto LABEL_26;
    }
    sub_10002418C(__p, "IsXboxBLEController");
    sub_1005C0684(v5, (uint64_t)__p);
    if (v24 < 0) {
      operator delete(__p[0]);
    }
    if (v10 != 2835)
    {
LABEL_26:
      sub_1005D68D8(a1, v3, v9, v10);
      goto LABEL_27;
    }

    id v12 = *(id *)(v5 + 304);
    if (!v12)
    {
      if (os_log_type_enabled((os_log_t)qword_1008F75A0, OS_LOG_TYPE_ERROR)) {
        sub_10069B68C();
      }
      goto LABEL_25;
    }

    id v13 = [@"5.5.2641" compare:v12 options:64];
    __int16 v14 = (os_log_s *)qword_1008F75A0;
    BOOL v15 = os_log_type_enabled((os_log_t)qword_1008F75A0, OS_LOG_TYPE_DEFAULT);
    if (v13 == (id)1)
    {
      if (v15)
      {
        *(_DWORD *)__int128 buf = 138543874;
        id v26 = v12;
        __int16 v27 = 2114;
        __int16 v28 = @"5.5.2641";
        __int16 v29 = 2114;
        id v30 = v3;
        _os_log_impl( (void *)&_mh_execute_header,  v14,  OS_LOG_TYPE_DEFAULT,  "Firmware version: %{public}@ < minumum firmware version: %{public}@ for device %{public}@",  buf,  0x20u);
      }

      sub_10002418C(v21, "XboxControllerRequiresFWUpdate");
      sub_1005C0684(v5, (uint64_t)v21);
      if ((v22 & 0x80000000) == 0) {
        goto LABEL_24;
      }
      unsigned int v16 = (void **)v21;
    }

    else
    {
      if (v15)
      {
        *(_DWORD *)__int128 buf = 138543874;
        id v26 = v12;
        __int16 v27 = 2114;
        __int16 v28 = @"5.5.2641";
        __int16 v29 = 2114;
        id v30 = v3;
        _os_log_impl( (void *)&_mh_execute_header,  v14,  OS_LOG_TYPE_DEFAULT,  "Firmware version: %{public}@ >= minumum firmware version: %{public}@ for device %{public}@",  buf,  0x20u);
      }

      sub_10002418C(v19, "XboxControllerRequiresFWUpdate");
      sub_1002EE40C((uint64_t **)(v5 + 176), v19);
      if ((v20 & 0x80000000) == 0) {
        goto LABEL_24;
      }
      unsigned int v16 = (void **)v19;
    }

    operator delete(*v16);
LABEL_24:
    uint64_t v17 = (void *)objc_claimAutoreleasedReturnValue( +[NSDistributedNotificationCenter defaultCenter]( &OBJC_CLASS___NSDistributedNotificationCenter,  "defaultCenter"));
    __int128 v18 = (void *)objc_claimAutoreleasedReturnValue( +[NSNotification notificationWithName:object:]( &OBJC_CLASS___NSNotification,  "notificationWithName:object:",  @"com.apple.bluetooth.leDeviceFirmwareUpdateWarning",  0LL));
    [v17 postNotification:v18];

LABEL_25:
    goto LABEL_26;
  }

void sub_1005D65F8( _Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void *__p, uint64_t a11, int a12, __int16 a13, char a14, char a15, uint64_t a16, uint64_t a17, int a18, __int16 a19, char a20, char a21, void *a22, uint64_t a23, int a24, __int16 a25, char a26, char a27)
{
  if (a15 < 0) {
    operator delete(__p);
  }

  _Unwind_Resume(a1);
}

id sub_1005D6684(uint64_t a1, void *a2)
{
  id v3 = a2;
  id v4 = (os_log_s *)qword_1008F75A0;
  if (os_log_type_enabled((os_log_t)qword_1008F75A0, OS_LOG_TYPE_DEFAULT))
  {
    LODWORD(v8) = 138543362;
    *(void *)((char *)&v8 + 4) = v3;
    _os_log_impl( (void *)&_mh_execute_header,  v4,  OS_LOG_TYPE_DEFAULT,  "DIS for device %{public}@",  (uint8_t *)&v8,  0xCu);
  }

  __int128 v8 = 0uLL;
  sub_100242F28((uint64_t)&v8, a1 + 80);
  uint64_t v5 = sub_1005C6AC0(a1, v3);
  if (v5) {
    id v6 = (id)v5[42];
  }
  else {
    id v6 = 0LL;
  }
  sub_100242FAC((uint64_t)&v8);

  return v6;
}

void sub_1005D6778( _Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9)
{
  _Unwind_Resume(a1);
}

void sub_1005D67A0(uint64_t a1, void *a2, void *a3)
{
  id v5 = a2;
  id v6 = a3;
  id v7 = (os_log_s *)qword_1008F75A0;
  if (os_log_type_enabled((os_log_t)qword_1008F75A0, OS_LOG_TYPE_DEFAULT))
  {
    *(_DWORD *)int v9 = 138412546;
    *(void *)&void v9[4] = v5;
    *(_WORD *)&v9[12] = 2112;
    *(void *)&v9[14] = v6;
    _os_log_impl((void *)&_mh_execute_header, v7, OS_LOG_TYPE_DEFAULT, "DIS for device %@ DIS UDI: %@", v9, 0x16u);
  }

  *(void *)int v9 = 0LL;
  *(void *)&__int16 v9[8] = 0LL;
  sub_100242F28((uint64_t)v9, a1 + 80);
  __int128 v8 = (id *)sub_1005C6AC0(a1, v5);
  if (v8) {
    objc_storeStrong(v8 + 43, a3);
  }
  sub_100242FAC((uint64_t)v9);
}

void sub_1005D68AC( _Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9)
{
  _Unwind_Resume(a1);
}

void sub_1005D68D8(uint64_t a1, void *a2, int a3, int a4)
{
  id v7 = a2;
  for (uint64_t i = 0LL; i != 160; i += 32LL)
  {
    if (*(unsigned __int16 *)((char *)&unk_1008F1D48 + i + 24) == a3
      && *(unsigned __int16 *)((char *)&unk_1008F1D48 + i + 26) == a4)
    {
      sub_10002418C(__p, "LEPhyDenylist");
      char v9 = sub_1005CE5A8(a1, v7, (uint64_t)__p);
      char v10 = v9;
      if (v15 < 0)
      {
        operator delete(__p[0]);
        if ((v10 & 1) != 0) {
          continue;
        }
      }

      else if ((v9 & 1) != 0)
      {
        continue;
      }

      sub_10002418C(v12, "LEPhyDenylist");
      sub_1005CCF08(a1, v7, (unsigned __int8 *)v12);
      if (v13 < 0) {
        operator delete(v12[0]);
      }
      __int128 v11 = (os_log_s *)qword_1008F75A0;
      if (os_log_type_enabled((os_log_t)qword_1008F75A0, OS_LOG_TYPE_DEFAULT))
      {
        *(_DWORD *)__int128 buf = 67109376;
        int v17 = a3;
        __int16 v18 = 1024;
        int v19 = a4;
        _os_log_impl( (void *)&_mh_execute_header,  v11,  OS_LOG_TYPE_DEFAULT,  "LEPhyDenylist: set tag for VID = 0x%04x, PID = 0x%04x",  buf,  0xEu);
      }
    }
  }
}

void sub_1005D6A68( _Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, void *__p, uint64_t a12, int a13, __int16 a14, char a15, char a16, uint64_t a17, uint64_t a18, int a19, __int16 a20, char a21, char a22)
{
  if (a16 < 0) {
    operator delete(__p);
  }

  _Unwind_Resume(a1);
}

unint64_t sub_1005D6AAC(uint64_t a1, void *a2)
{
  id v3 = a2;
  sub_10002418C(__p, "LEPhyDenylist");
  unint64_t v4 = sub_1005CE5A8(a1, v3, (uint64_t)__p);
  if (v7 < 0) {
    operator delete(__p[0]);
  }

  return v4;
}

void sub_1005D6B14( _Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void *__p, uint64_t a11, int a12, __int16 a13, char a14, char a15)
{
  if (a15 < 0) {
    operator delete(__p);
  }

  _Unwind_Resume(a1);
}

void sub_1005D6B3C(uint64_t a1@<X0>, void *a2@<X1>, std::stringbuf::string_type *a3@<X8>)
{
  id v5 = a2;
  v7[0] = 0LL;
  v7[1] = 0LL;
  sub_100242F28((uint64_t)v7, a1 + 80);
  id v6 = (id *)sub_1005C6AC0(a1, v5);
  if (v6) {
    sub_1005C0E60(v6, a3);
  }
  else {
    sub_10002418C(a3, "");
  }
  sub_100242FAC((uint64_t)v7);
}

void sub_1005D6BBC(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

uint64_t sub_1005D6BDC(uint64_t a1, void *a2)
{
  id v3 = a2;
  v7[0] = 0LL;
  v7[1] = 0LL;
  sub_100242F28((uint64_t)v7, a1 + 80);
  uint64_t v4 = sub_1005C6AC0(a1, v3);
  if (v4) {
    uint64_t v5 = *(unsigned __int8 *)(v4 + 355);
  }
  else {
    uint64_t v5 = 0LL;
  }
  sub_100242FAC((uint64_t)v7);

  return v5;
}

void sub_1005D6C44( _Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9)
{
  _Unwind_Resume(a1);
}

void sub_1005D6C64(uint64_t a1, void *a2, char a3)
{
  id v5 = a2;
  v7[0] = 0LL;
  v7[1] = 0LL;
  sub_100242F28((uint64_t)v7, a1 + 80);
  id v6 = sub_1005C6AC0(a1, v5);
  if (v6) {
    *((_BYTE *)v6 + 355) = a3;
  }
  sub_100242FAC((uint64_t)v7);
}

void sub_1005D6CCC( _Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9)
{
  _Unwind_Resume(a1);
}

uint64_t sub_1005D6CEC(uint64_t a1, void *a2)
{
  id v3 = a2;
  v7[0] = 0LL;
  v7[1] = 0LL;
  sub_100242F28((uint64_t)v7, a1 + 80);
  uint64_t v4 = sub_1005C6AC0(a1, v3);
  if (v4) {
    uint64_t v5 = *(unsigned __int8 *)(v4 + 356);
  }
  else {
    uint64_t v5 = 0LL;
  }
  sub_100242FAC((uint64_t)v7);

  return v5;
}

void sub_1005D6D54( _Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9)
{
  _Unwind_Resume(a1);
}

void sub_1005D6D74(uint64_t a1, void *a2, char a3)
{
  id v5 = a2;
  v7[0] = 0LL;
  v7[1] = 0LL;
  sub_100242F28((uint64_t)v7, a1 + 80);
  id v6 = sub_1005C6AC0(a1, v5);
  if (v6) {
    *((_BYTE *)v6 + 356) = a3;
  }
  sub_100242FAC((uint64_t)v7);
}

void sub_1005D6DDC( _Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9)
{
  _Unwind_Resume(a1);
}

uint64_t sub_1005D6DFC(uint64_t a1, void *a2)
{
  id v3 = a2;
  v7[0] = 0LL;
  v7[1] = 0LL;
  sub_100242F28((uint64_t)v7, a1 + 80);
  uint64_t v4 = sub_1005C6AC0(a1, v3);
  if (v4) {
    uint64_t v5 = *((unsigned __int8 *)v4 + 354);
  }
  else {
    uint64_t v5 = 0LL;
  }
  sub_100242FAC((uint64_t)v7);

  return v5;
}

void sub_1005D6E64( _Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9)
{
  _Unwind_Resume(a1);
}

void sub_1005D6E84(uint64_t a1, void *a2, char a3)
{
  id v5 = a2;
  v7[0] = 0LL;
  v7[1] = 0LL;
  sub_100242F28((uint64_t)v7, a1 + 80);
  id v6 = sub_1005C6AC0(a1, v5);
  if (v6) {
    *((_BYTE *)v6 + 354) = a3;
  }
  sub_100242FAC((uint64_t)v7);
}

void sub_1005D6EEC( _Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9)
{
  _Unwind_Resume(a1);
}

void sub_1005D6F0C(uint64_t a1, void *a2, char a3)
{
  id v5 = a2;
  v7[0] = 0LL;
  v7[1] = 0LL;
  sub_100242F28((uint64_t)v7, a1 + 80);
  id v6 = sub_1005C6AC0(a1, v5);
  if (v6) {
    *((_BYTE *)v6 + 358) = a3;
  }
  sub_100242FAC((uint64_t)v7);
}

void sub_1005D6F74( _Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9)
{
  _Unwind_Resume(a1);
}

BOOL sub_1005D6F94(uint64_t a1, void *a2)
{
  id v3 = a2;
  v7[0] = 0LL;
  v7[1] = 0LL;
  sub_100242F28((uint64_t)v7, a1 + 80);
  uint64_t v4 = sub_1005C6AC0(a1, v3);
  if (v4) {
    BOOL v5 = *((_BYTE *)v4 + 358) != 0;
  }
  else {
    BOOL v5 = 0LL;
  }
  sub_100242FAC((uint64_t)v7);

  return v5;
}

void sub_1005D7004( _Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9)
{
  _Unwind_Resume(a1);
}

void sub_1005D7024(uint64_t a1, void *a2, char a3, int a4)
{
  id v7 = a2;
  v9[0] = 0LL;
  v9[1] = 0LL;
  sub_100242F28((uint64_t)v9, a1 + 80);
  __int128 v8 = sub_1005C6AC0(a1, v7);
  if (v8)
  {
    *((_BYTE *)v8 + 386) = a3;
    *((_DWORD *)v8 + 97) = a4;
  }

  sub_100242FAC((uint64_t)v9);
}

void sub_1005D7094( _Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9)
{
  _Unwind_Resume(a1);
}

void sub_1005D70B4(uint64_t a1, void *a2, _BYTE *a3, _DWORD *a4)
{
  id v7 = a2;
  v9[0] = 0LL;
  v9[1] = 0LL;
  sub_100242F28((uint64_t)v9, a1 + 80);
  __int128 v8 = sub_1005C6AC0(a1, v7);
  if (v8)
  {
    *a3 = *((_BYTE *)v8 + 386);
    *a4 = *((_DWORD *)v8 + 97);
  }

  sub_100242FAC((uint64_t)v9);
}

void sub_1005D712C( _Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9)
{
  _Unwind_Resume(a1);
}

void sub_1005D714C(uint64_t a1, void *a2, double a3)
{
  id v5 = a2;
  v7[0] = 0LL;
  v7[1] = 0LL;
  sub_100242F28((uint64_t)v7, a1 + 80);
  id v6 = (double *)sub_1005C6AC0(a1, v5);
  if (v6) {
    v6[50] = a3;
  }
  sub_100242FAC((uint64_t)v7);
}

void sub_1005D71B4( _Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9)
{
  _Unwind_Resume(a1);
}

double sub_1005D71D4(uint64_t a1, void *a2)
{
  id v3 = a2;
  v7[0] = 0LL;
  v7[1] = 0LL;
  sub_100242F28((uint64_t)v7, a1 + 80);
  uint64_t v4 = (double *)sub_1005C6AC0(a1, v3);
  if (v4) {
    double v5 = v4[50];
  }
  else {
    double v5 = 0.0;
  }
  sub_100242FAC((uint64_t)v7);

  return v5;
}

void sub_1005D7244( _Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9)
{
  _Unwind_Resume(a1);
}

void sub_1005D7264(uint64_t a1@<X0>, void *a2@<X1>, uint64_t a3@<X8>)
{
  id v5 = a2;
  if (sub_1005D733C(a1, v5))
  {
    sub_1005D73C8(a1, v5, 2u, a3);
  }

  else
  {
    uint64_t v6 = sub_1005CC198(a1, v5, 0);
    sub_1005DD088(a3, (unint64_t *)&v6, 1LL);
  }
}

void sub_1005D731C(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

BOOL sub_1005D733C(uint64_t a1, void *a2)
{
  id v3 = a2;
  v7[0] = 0LL;
  v7[1] = 0LL;
  sub_100242F28((uint64_t)v7, a1 + 80);
  id v4 = [*(id *)(a1 + 160) objectForKey:v3];
  if (v4) {
    BOOL v5 = sub_1005D89C0((uint64_t)v4);
  }
  else {
    BOOL v5 = 0LL;
  }
  sub_100242FAC((uint64_t)v7);

  return v5;
}

void sub_1005D73A8(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_1005D73C8(uint64_t a1@<X0>, void *a2@<X1>, unsigned int a3@<W2>, uint64_t a4@<X8>)
{
  id v7 = a2;
  *(void *)(a4 + 16) = 0LL;
  *(void *)(a4 + 8) = 0LL;
  *(void *)a4 = a4 + 8;
  v23[0] = 0LL;
  v23[1] = 0LL;
  sub_100242F28((uint64_t)v23, a1 + 80);
  __int128 v8 = (id *)[*(id *)(a1 + 160) objectForKey:v7];
  char v9 = v8;
  if (v8)
  {
    id v10 = v8[8];
    if (v10)
    {
      id v11 = v9[9];
      if ([v11 count])
      {
        if (!a3)
        {
          id v12 = (void *)objc_claimAutoreleasedReturnValue([v10 lastConnectedLEMAC]);
          *(void *)__int128 buf = sub_1005C04DC(v12);
          sub_1002555B0((uint64_t **)a4, (unint64_t *)buf, (uint64_t *)buf);
        }

        __int128 v20 = 0u;
        __int128 v21 = 0u;
        __int128 v18 = 0u;
        __int128 v19 = 0u;
        id v13 = v11;
        id v14 = [v13 countByEnumeratingWithState:&v18 objects:v24 count:16];
        if (v14)
        {
          uint64_t v15 = *(void *)v19;
LABEL_8:
          uint64_t v16 = 0LL;
          while (1)
          {
            if (*(void *)v19 != v15) {
              objc_enumerationMutation(v13);
            }
            *(void *)__int128 buf = sub_1005C04DC(*(void **)(*((void *)&v18 + 1) + 8 * v16));
            sub_1002555B0((uint64_t **)a4, (unint64_t *)buf, (uint64_t *)buf);
            if (a3)
            {
            }

            if (v14 == (id)++v16)
            {
              id v14 = [v13 countByEnumeratingWithState:&v18 objects:v24 count:16];
              if (v14) {
                goto LABEL_8;
              }
              break;
            }
          }
        }
      }

      else
      {
        int v17 = (os_log_s *)qword_1008F75A0;
        if (os_log_type_enabled((os_log_t)qword_1008F75A0, OS_LOG_TYPE_INFO))
        {
          *(_WORD *)__int128 buf = 0;
          _os_log_impl( (void *)&_mh_execute_header,  v17,  OS_LOG_TYPE_INFO,  "getDeviceExtraAddresses returning empty",  buf,  2u);
        }
      }
    }
  }

  sub_100242FAC((uint64_t)v23);
}

void sub_1005D75E4( _Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, ...)
{
  sub_100242FAC((uint64_t)va);
  sub_10023BF24(v12, *(void **)(v12 + 8));

  _Unwind_Resume(a1);
}

id sub_1005D7650(uint64_t a1, void *a2)
{
  id v3 = a2;
  v9[0] = 0LL;
  v9[1] = 0LL;
  sub_100242F28((uint64_t)v9, a1 + 80);
  id v4 = (id *)[*(id *)(a1 + 160) objectForKey:v3];
  if (v4 && (id v5 = v4[8]) != 0LL)
  {
    uint64_t v6 = v5;
    id v7 = (void *)objc_claimAutoreleasedReturnValue([v5 beaconIdentifier]);
  }

  else
  {
    id v7 = 0LL;
  }

  sub_100242FAC((uint64_t)v9);

  return v7;
}

void sub_1005D76DC( _Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9)
{
  sub_100242FAC((uint64_t)&a9);
  _Unwind_Resume(a1);
}

id sub_1005D7708(uint64_t a1, void *a2)
{
  id v3 = a2;
  v9[0] = 0LL;
  v9[1] = 0LL;
  sub_100242F28((uint64_t)v9, a1 + 80);
  id v4 = (id *)[*(id *)(a1 + 160) objectForKey:v3];
  if (v4 && (id v5 = v4[8]) != 0LL)
  {
    uint64_t v6 = v5;
    id v7 = (void *)objc_claimAutoreleasedReturnValue([v5 userIdentifier]);
  }

  else
  {
    id v7 = 0LL;
  }

  sub_100242FAC((uint64_t)v9);

  return v7;
}

void sub_1005D7794( _Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9)
{
  sub_100242FAC((uint64_t)&a9);
  _Unwind_Resume(a1);
}

id sub_1005D77C0(uint64_t a1, void *a2)
{
  id v3 = a2;
  v22[0] = 0LL;
  v22[1] = 0LL;
  sub_100242F28((uint64_t)v22, a1 + 80);
  __int128 v20 = 0u;
  __int128 v21 = 0u;
  __int128 v18 = 0u;
  __int128 v19 = 0u;
  id v4 = *(id *)(a1 + 248);
  id v5 = [v4 countByEnumeratingWithState:&v18 objects:v23 count:16];
  if (v5)
  {
    uint64_t v6 = *(void *)v19;
    while (2)
    {
      for (uint64_t i = 0LL; i != v5; uint64_t i = (char *)i + 1)
      {
        if (*(void *)v19 != v6) {
          objc_enumerationMutation(v4);
        }
        __int128 v8 = *(void **)(*((void *)&v18 + 1) + 8LL * (void)i);
        char v9 = (id *)objc_msgSend(*(id *)(a1 + 160), "objectForKey:", v8, (void)v18);
        if (v9)
        {
          id v10 = v9[8];
          id v11 = v10;
          if (v10)
          {
            uint64_t v12 = (void *)objc_claimAutoreleasedReturnValue([v10 serialNumber]);
            BOOL v13 = [v12 length] == 0;

            if (!v13)
            {
              id v14 = (void *)objc_claimAutoreleasedReturnValue([v11 serialNumber]);
              unsigned __int8 v15 = [v3 isEqualToString:v14];

              if ((v15 & 1) != 0)
              {
                id v16 = v8;

                goto LABEL_15;
              }
            }
          }
        }
      }

      id v5 = [v4 countByEnumeratingWithState:&v18 objects:v23 count:16];
      if (v5) {
        continue;
      }
      break;
    }
  }

  id v16 = 0LL;
LABEL_15:

  sub_100242FAC((uint64_t)v22);
  return v16;
}

void sub_1005D7964( _Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, ...)
{
  sub_100242FAC((uint64_t)va);
  _Unwind_Resume(a1);
}

uint64_t sub_1005D79C0(uint64_t a1, void *a2, void *a3, void *a4)
{
  id v7 = a2;
  id v8 = a3;
  id v9 = a4;
  v13[0] = 0LL;
  v13[1] = 0LL;
  sub_100242F28((uint64_t)v13, a1 + 80);
  id v10 = sub_1005C6AC0(a1, v7);
  if (v10)
  {
    uint64_t v11 = sub_1005C132C((uint64_t)v10, v8, v9);
  }

  else
  {
    sub_100242F54((uint64_t)v13);
    uint64_t v11 = 1LL;
  }

  sub_100242FAC((uint64_t)v13);

  return v11;
}

void sub_1005D7A64(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

id sub_1005D7A8C(uint64_t a1, void *a2)
{
  id v3 = a2;
  v19[0] = 0LL;
  v19[1] = 0LL;
  sub_100242F28((uint64_t)v19, a1 + 80);
  id v14 = (id)objc_claimAutoreleasedReturnValue(+[NSMutableArray array](&OBJC_CLASS___NSMutableArray, "array"));
  __int128 v17 = 0u;
  __int128 v18 = 0u;
  __int128 v15 = 0u;
  __int128 v16 = 0u;
  id v4 = *(id *)(a1 + 248);
  id v5 = [v4 countByEnumeratingWithState:&v15 objects:v20 count:16];
  if (v5)
  {
    uint64_t v6 = *(void *)v16;
    do
    {
      for (uint64_t i = 0LL; i != v5; uint64_t i = (char *)i + 1)
      {
        if (*(void *)v16 != v6) {
          objc_enumerationMutation(v4);
        }
        uint64_t v8 = *(void *)(*((void *)&v15 + 1) + 8LL * (void)i);
        id v9 = *((id *)[*(id *)(a1 + 160) objectForKey:v8] + 8);
        id v10 = v9;
        if (v9)
        {
          uint64_t v11 = (void *)objc_claimAutoreleasedReturnValue([v9 groupIdentifier]);
          unsigned int v12 = [v11 isEqual:v3];

          if (v12) {
            [v14 addObject:v8];
          }
        }
      }

      id v5 = [v4 countByEnumeratingWithState:&v15 objects:v20 count:16];
    }

    while (v5);
  }

  sub_100242FAC((uint64_t)v19);
  return v14;
}

void sub_1005D7C10( _Unwind_Exception *a1, uint64_t a2, void *a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, ...)
{
  sub_100242FAC((uint64_t)va);
  _Unwind_Resume(a1);
}

id sub_1005D7C70(uint64_t a1, void *a2)
{
  id v3 = a2;
  v9[0] = 0LL;
  v9[1] = 0LL;
  sub_100242F28((uint64_t)v9, a1 + 80);
  id v4 = (id *)[*(id *)(a1 + 160) objectForKey:v3];
  if (v4 && (id v5 = v4[8]) != 0LL)
  {
    uint64_t v6 = v5;
    id v7 = (void *)objc_claimAutoreleasedReturnValue([v5 groupIdentifier]);
  }

  else
  {
    id v7 = 0LL;
  }

  sub_100242FAC((uint64_t)v9);

  return v7;
}

void sub_1005D7CFC( _Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9)
{
  sub_100242FAC((uint64_t)&a9);
  _Unwind_Resume(a1);
}

id sub_1005D7D28(uint64_t a1, void *a2)
{
  id v3 = sub_1005D7C70(a1, a2);
  id v4 = (void *)objc_claimAutoreleasedReturnValue(v3);
  if (v4)
  {
    id v5 = sub_1005D7A8C(a1, v4);
    uint64_t v6 = (void *)objc_claimAutoreleasedReturnValue(v5);
  }

  else
  {
    uint64_t v6 = 0LL;
  }

  return v6;
}

void sub_1005D7D78(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

id sub_1005D7D88(uint64_t a1, void *a2)
{
  id v3 = a2;
  v9[0] = 0LL;
  v9[1] = 0LL;
  sub_100242F28((uint64_t)v9, a1 + 80);
  id v4 = (id *)[*(id *)(a1 + 160) objectForKey:v3];
  if (v4 && (id v5 = v4[8]) != 0LL)
  {
    uint64_t v6 = v5;
    id v7 = (void *)objc_claimAutoreleasedReturnValue([v5 serialNumber]);
  }

  else
  {
    id v7 = 0LL;
  }

  sub_100242FAC((uint64_t)v9);

  return v7;
}

void sub_1005D7E14( _Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9)
{
  sub_100242FAC((uint64_t)&a9);
  _Unwind_Resume(a1);
}

id sub_1005D7E40(uint64_t a1, void *a2)
{
  id v3 = a2;
  v9[0] = 0LL;
  v9[1] = 0LL;
  sub_100242F28((uint64_t)v9, a1 + 80);
  id v4 = (id *)[*(id *)(a1 + 160) objectForKey:v3];
  if (v4 && (id v5 = v4[8]) != 0LL)
  {
    uint64_t v6 = v5;
    id v7 = [v5 partIdentifier];
  }

  else
  {
    id v7 = 0LL;
  }

  sub_100242FAC((uint64_t)v9);

  return v7;
}

void sub_1005D7EC8( _Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9)
{
  sub_100242FAC((uint64_t)&a9);
  _Unwind_Resume(a1);
}

id sub_1005D7EF4(uint64_t a1, void *a2)
{
  id v3 = a2;
  v9[0] = 0LL;
  v9[1] = 0LL;
  sub_100242F28((uint64_t)v9, a1 + 80);
  id v4 = (id *)[*(id *)(a1 + 160) objectForKey:v3];
  if (v4 && (id v5 = v4[8]) != 0LL)
  {
    uint64_t v6 = v5;
    id v7 = [v5 managedByFindMy];
  }

  else
  {
    id v7 = 0LL;
  }

  sub_100242FAC((uint64_t)v9);

  return v7;
}

void sub_1005D7F7C( _Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9)
{
  sub_100242FAC((uint64_t)&a9);
  _Unwind_Resume(a1);
}

void sub_1005D7FA8(uint64_t a1, void *a2)
{
  id v3 = a2;
  v5[0] = 0LL;
  v5[1] = 0LL;
  sub_100242F28((uint64_t)v5, a1 + 80);
  id v4 = [*(id *)(a1 + 160) objectForKey:v3];
  if (v4) {
    sub_1005C1B88(v4);
  }
  sub_100242FAC((uint64_t)v5);
}

void sub_1005D8004(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_1005D8024()
{
  if (qword_1008D5F50 != -1) {
    dispatch_once(&qword_1008D5F50, &stru_1008A3558);
  }
  __int16 v29 = 0LL;
  __uuid_t dst = 0LL;
  uint64_t v31 = 0LL;
  sub_10040247C((uint64_t)off_1008D5F48, 8212, &v29);
  id v26 = 0LL;
  __int16 v27 = 0LL;
  uint64_t v28 = 0LL;
  if (qword_1008D5F50 != -1) {
    dispatch_once(&qword_1008D5F50, &stru_1008A3558);
  }
  sub_10040247C((uint64_t)off_1008D5F48, 8228, &v26);
  sub_100411A54((uint64_t)&v29, (uint64_t)__dst, (char *)v26, v27, (v27 - (_BYTE *)v26) >> 3);
  __int128 v23 = 0LL;
  char v24 = 0LL;
  uint64_t v25 = 0LL;
  if (qword_1008D5F50 != -1) {
    dispatch_once(&qword_1008D5F50, &stru_1008A3558);
  }
  sub_10040247C((uint64_t)off_1008D5F48, 8219, &v23);
  sub_100411A54((uint64_t)&v29, (uint64_t)__dst, (char *)v23, v24, (v24 - (_BYTE *)v23) >> 3);
  __int128 v20 = 0LL;
  __int128 v21 = 0LL;
  uint64_t v22 = 0LL;
  if (qword_1008D5F50 != -1) {
    dispatch_once(&qword_1008D5F50, &stru_1008A3558);
  }
  sub_10040247C((uint64_t)off_1008D5F48, 8224, &v20);
  sub_100411A54((uint64_t)&v29, (uint64_t)__dst, (char *)v20, v21, (v21 - (_BYTE *)v20) >> 3);
  uint64_t v0 = (os_log_s *)qword_1008F75A0;
  if (os_log_type_enabled((os_log_t)qword_1008F75A0, OS_LOG_TYPE_DEFAULT))
  {
    LODWORD(buf) = 134217984;
    *(void *)((char *)&buf + 4) = ((_BYTE *)__dst - (_BYTE *)v29) >> 3;
    _os_log_impl( (void *)&_mh_execute_header,  v0,  OS_LOG_TYPE_DEFAULT,  "parseCurrentAACPInfo devices:%lu",  (uint8_t *)&buf,  0xCu);
  }

  *(void *)&__int128 buf = 0LL;
  *((void *)&buf + 1) = &buf;
  uint64_t v37 = 0x4812000000LL;
  unint64_t v38 = sub_1005D86BC;
  char v39 = sub_1005D86F8;
  v42[0] = 0LL;
  v42[1] = 0LL;
  int v40 = &unk_1007C41D6;
  int64_t v41 = v42;
  uint64_t v1 = (uint64_t *)v29;
  id v2 = (uint64_t *)__dst;
  if (v29 != __dst)
  {
    do
    {
      uint64_t v3 = *v1;
      if ((sub_1003D2B2C(*v1, 3) & 1) == 0) {
        break;
      }
      memset(&__p, 0, sizeof(__p));
      sub_1003D930C(v3, 3u, &v32);
      if ((char)v32.__r_.__value_.__s.__size_ < 0)
      {
        std::string::size_type size = v32.__r_.__value_.__l.__size_;
        operator delete(v32.__r_.__value_.__l.__data_);
        if (size >= 2)
        {
LABEL_17:
          sub_1003D930C(v3, 3u, &v32);
          std::string __p = v32;
          memset(&__str, 0, sizeof(__str));
          sub_1003D930C(v3, 8u, &v32);
          if ((char)v32.__r_.__value_.__s.__size_ < 0)
          {
            std::string::size_type v5 = v32.__r_.__value_.__l.__size_;
            operator delete(v32.__r_.__value_.__l.__data_);
            if (v5 < 2) {
              goto LABEL_48;
            }
          }

          else if (v32.__r_.__value_.__s.__size_ <= 1u)
          {
LABEL_48:
            uint64_t v14 = sub_100404EB8();
            v17[0] = _NSConcreteStackBlock;
            v17[1] = 3221225472LL;
            v17[2] = sub_1005D8708;
            v17[3] = &unk_10087EB20;
            _OWORD v17[4] = v3;
            sub_100405384(v14, v17);
            goto LABEL_50;
          }

          sub_1003D930C(v3, 8u, &v32);
          std::string __str = v32;
          std::string::size_type cap_high = HIBYTE(v32.__r_.__value_.__l.__cap_);
          if ((v32.__r_.__value_.__s.__size_ & 0x80u) != 0) {
            std::string::size_type cap_high = __str.__r_.__value_.__l.__size_;
          }
          if (!cap_high)
          {
            sub_1003D930C(v3, 9u, &v32);
            if ((v32.__r_.__value_.__s.__size_ & 0x80u) == 0) {
              std::string::size_type v7 = v32.__r_.__value_.__s.__size_;
            }
            else {
              std::string::size_type v7 = v32.__r_.__value_.__l.__size_;
            }
            if (v7 >= 2)
            {
              sub_1003D930C(v3, 9u, &v32);
              std::string __str = v32;
            }
          }

          std::string::size_type v8 = __str.__r_.__value_.__s.__size_;
          int v9 = (char)__str.__r_.__value_.__s.__size_;
          if ((__str.__r_.__value_.__s.__size_ & 0x80u) != 0) {
            std::string::size_type v8 = __str.__r_.__value_.__l.__size_;
          }
          if (v8)
          {
            id v10 = (os_log_s *)qword_1008F75A0;
            if (os_log_type_enabled((os_log_t)qword_1008F75A0, OS_LOG_TYPE_INFO))
            {
              p_str = (std::string *)__str.__r_.__value_.__r.__words[0];
              if (v9 >= 0) {
                p_str = &__str;
              }
              if ((__p.__r_.__value_.__s.__size_ & 0x80u) == 0) {
                p_p = &__p;
              }
              else {
                p_p = (std::string *)__p.__r_.__value_.__r.__words[0];
              }
              LODWORD(v32.__r_.__value_.__l.__data_) = 141558787;
              *(std::string::size_type *)((char *)v32.__r_.__value_.__r.__words + 4) = 1752392040LL;
              WORD2(v32.__r_.__value_.__r.__words[1]) = 2081;
              *(std::string::size_type *)((char *)&v32.__r_.__value_.__r.__words[1] + 6) = (std::string::size_type)p_str;
              HIWORD(v32.__r_.__value_.__r.__words[2]) = 2160;
              uint64_t v33 = 1752392040LL;
              __int16 v34 = 2081;
              char v35 = p_p;
              _os_log_impl( (void *)&_mh_execute_header,  v10,  OS_LOG_TYPE_INFO,  "otherSN:%{private, mask.hash}s caseSN:%{private, mask.hash}s",  (uint8_t *)&v32,  0x2Au);
            }

            v32.__r_.__value_.__r.__words[0] = (std::string::size_type)&__p;
            BOOL v13 = sub_1005DD190( (uint64_t **)(*((void *)&buf + 1) + 48LL),  (const void **)&__p.__r_.__value_.__l.__data_,  (uint64_t)&unk_1006C2518,  (__int128 **)&v32);
            std::string::operator=((std::string *)(v13 + 7), &__str);
          }

          goto LABEL_48;
        }
      }

      else if (v32.__r_.__value_.__s.__size_ > 1u)
      {
        goto LABEL_17;
      }

void sub_1005D85E0( _Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20, uint64_t a21, uint64_t a22, void *__p, uint64_t a24, int a25, __int16 a26, char a27, char a28, uint64_t a29, void *a30, uint64_t a31, int a32, __int16 a33, char a34, char a35, void *a36, uint64_t a37, uint64_t a38, void *a39, uint64_t a40, uint64_t a41, void *a42, uint64_t a43, uint64_t a44, void *a45, uint64_t a46)
{
  if (a28 < 0) {
    operator delete(__p);
  }
  if (a35 < 0) {
    operator delete(a30);
  }
  _Block_object_dispose((const void *)(v46 - 192), 8);
  sub_1005DD104(a12, *(void **)(v46 - 136));
  if (a36) {
    operator delete(a36);
  }
  if (a39) {
    operator delete(a39);
  }
  if (a42) {
    operator delete(a42);
  }
  if (a45) {
    operator delete(a45);
  }
  _Unwind_Resume(a1);
}

void *sub_1005D86BC(void *result, void *a2)
{
  result[6] = a2[6];
  id v2 = a2 + 7;
  uint64_t v3 = a2[7];
  result[7] = v3;
  id v4 = result + 7;
  uint64_t v5 = a2[8];
  result[8] = v5;
  if (v5)
  {
    *(void *)(v3 + 16) = v4;
    a2[6] = v2;
    *id v2 = 0LL;
    a2[8] = 0LL;
  }

  else
  {
    result[6] = v4;
  }

  return result;
}

void sub_1005D86F8(uint64_t a1)
{
}

uint64_t sub_1005D8708(uint64_t a1)
{
  if (qword_1008D5F50 != -1) {
    dispatch_once(&qword_1008D5F50, &stru_1008A3558);
  }
  return sub_1003FFDA4((os_unfair_lock_s *)off_1008D5F48, *(void *)(a1 + 32), 15);
}

void sub_1005D875C(uint64_t a1, __n128 a2)
{
  id v2 = *(void **)(*(void *)(a1 + 32) + 8LL);
  if (v2[8])
  {
    uint64_t v3 = (void *)v2[6];
    id v4 = v2 + 7;
    if (v3 != v2 + 7)
    {
      a2.n128_u64[0] = 141559043LL;
      __n128 v17 = a2;
      do
      {
        v28[0] = 0LL;
        v28[1] = 0LL;
        if (qword_1008D6608 != -1) {
          dispatch_once(&qword_1008D6608, &stru_1008A3578);
        }
        uint64_t v5 = v3 + 7;
        uint64_t v6 = off_1008D6600;
        std::string::size_type v7 = (void *)objc_claimAutoreleasedReturnValue( +[NSString stringWithUTF8String:]( &OBJC_CLASS___NSString,  "stringWithUTF8String:",  v5,  *(_OWORD *)&v17));
        BOOL v8 = sub_10060CE98((uint64_t)v6, v7, (uint64_t)v28);

        if (v8)
        {
          int v9 = v3 + 4;
          id v10 = (os_log_s *)qword_1008F75A0;
          if (os_log_type_enabled((os_log_t)qword_1008F75A0, OS_LOG_TYPE_INFO))
          {
            uint64_t v11 = v3 + 4;
            *(_DWORD *)__int128 buf = v17.n128_u32[0];
            uint64_t v19 = 1752392040LL;
            __int16 v20 = 2081;
            __int128 v21 = v11;
            __int16 v22 = 2160;
            uint64_t v23 = 1752392040LL;
            __int16 v24 = 1041;
            int v25 = 16;
            __int16 v26 = 2097;
            __int16 v27 = v28;
            _os_log_impl( (void *)&_mh_execute_header,  v10,  OS_LOG_TYPE_INFO,  "Setting %{private, mask.hash}s encryption key to %{private, mask.hash}.16P",  buf,  0x30u);
          }

          if (qword_1008D6608 != -1) {
            dispatch_once(&qword_1008D6608, &stru_1008A3578);
          }
          unsigned int v12 = off_1008D6600;
          BOOL v13 = (void *)objc_claimAutoreleasedReturnValue(+[NSString stringWithUTF8String:](&OBJC_CLASS___NSString, "stringWithUTF8String:", v9));
          sub_10060CB10((uint64_t)v12, v13, (uint64_t)v28);
        }

        uint64_t v14 = (void *)v3[1];
        if (v14)
        {
          do
          {
            uint64_t v15 = v14;
            uint64_t v14 = (void *)*v14;
          }

          while (v14);
        }

        else
        {
          do
          {
            uint64_t v15 = (void *)v3[2];
            BOOL v16 = *v15 == (void)v3;
            uint64_t v3 = v15;
          }

          while (!v16);
        }

        uint64_t v3 = v15;
      }

      while (v15 != v4);
    }
  }

void sub_1005D89A4(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

BOOL sub_1005D89C0(uint64_t a1)
{
  uint64_t v1 = (void *)objc_claimAutoreleasedReturnValue([*(id *)(a1 + 64) longTermKeyMap]);
  BOOL v2 = [v1 count] != 0;

  return v2;
}

void sub_1005D89FC(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

uint64_t sub_1005D8A0C(uint64_t a1)
{
  if (qword_1008D5F10 != -1) {
    dispatch_once(&qword_1008D5F10, &stru_1008A3478);
  }
  id v2 = sub_10059A34C((uint64_t)off_1008D5F08);
  uint64_t v3 = (void *)objc_claimAutoreleasedReturnValue(v2);
  v20[0] = 0LL;
  v20[1] = 0LL;
  sub_100242F28((uint64_t)v20, a1 + 80);
  __int128 v18 = 0u;
  __int128 v19 = 0u;
  __int128 v16 = 0u;
  __int128 v17 = 0u;
  id v4 = v3;
  uint64_t v5 = 0LL;
  id v6 = [v4 countByEnumeratingWithState:&v16 objects:v21 count:16];
  if (v6)
  {
    uint64_t v7 = *(void *)v17;
    do
    {
      for (uint64_t i = 0LL; i != v6; uint64_t i = (char *)i + 1)
      {
        if (*(void *)v17 != v7) {
          objc_enumerationMutation(v4);
        }
        int v9 = *(void **)(*((void *)&v16 + 1) + 8LL * (void)i);
        sub_10002418C(__p, "HasBuiltinServices");
        int v10 = sub_1005CE5A8(a1, v9, (uint64_t)__p);
        int v11 = v10;
        if (v15 < 0)
        {
          operator delete(__p[0]);
          if (!v11) {
            continue;
          }
LABEL_12:
          unsigned int v12 = sub_1005C6AC0(a1, v9);
          uint64_t v5 = (v5 + sub_1005C4708((uint64_t)v12));
          continue;
        }

        if (v10) {
          goto LABEL_12;
        }
      }

      id v6 = [v4 countByEnumeratingWithState:&v16 objects:v21 count:16];
    }

    while (v6);
  }

  sub_100242FAC((uint64_t)v20);
  return v5;
}

void sub_1005D8BB8( _Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void *__p, uint64_t a11, int a12, __int16 a13, char a14, char a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20, uint64_t a21, uint64_t a22, uint64_t a23, char a24)
{
  sub_100242FAC((uint64_t)&a24);
  _Unwind_Resume(a1);
}

id sub_1005D8C08(uint64_t a1)
{
  if (qword_1008D5F10 != -1) {
    dispatch_once(&qword_1008D5F10, &stru_1008A3478);
  }
  id v2 = sub_10059A34C((uint64_t)off_1008D5F08);
  uint64_t v3 = (void *)objc_claimAutoreleasedReturnValue(v2);
  id v4 = (void *)objc_claimAutoreleasedReturnValue(+[NSMutableArray array](&OBJC_CLASS___NSMutableArray, "array"));
  v20[0] = 0LL;
  v20[1] = 0LL;
  sub_100242F28((uint64_t)v20, a1 + 80);
  __int128 v18 = 0u;
  __int128 v19 = 0u;
  __int128 v16 = 0u;
  __int128 v17 = 0u;
  id v5 = v3;
  id v6 = [v5 countByEnumeratingWithState:&v16 objects:v21 count:16];
  if (v6)
  {
    uint64_t v7 = *(void *)v17;
    do
    {
      for (uint64_t i = 0LL; i != v6; uint64_t i = (char *)i + 1)
      {
        if (*(void *)v17 != v7) {
          objc_enumerationMutation(v5);
        }
        int v9 = *(void **)(*((void *)&v16 + 1) + 8LL * (void)i);
        sub_10002418C(__p, "HasBuiltinServices");
        int v10 = sub_1005CE5A8(a1, v9, (uint64_t)__p);
        int v11 = v10;
        if (v15 < 0)
        {
          operator delete(__p[0]);
          if (!v11) {
            continue;
          }
        }

        else if (!v10)
        {
          continue;
        }

        unsigned int v12 = sub_1005C6AC0(a1, v9);
      }

      id v6 = [v5 countByEnumeratingWithState:&v16 objects:v21 count:16];
    }

    while (v6);
  }

  sub_100242FAC((uint64_t)v20);
  return v4;
}

void sub_1005D8DD0( _Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void *__p, uint64_t a11, int a12, __int16 a13, char a14, char a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20, uint64_t a21, uint64_t a22, uint64_t a23, char a24)
{
  sub_100242FAC((uint64_t)&a24);
  _Unwind_Resume(a1);
}

uint64_t sub_1005D8E2C(uint64_t a1, void *a2)
{
  id v3 = a2;
  if (!v3) {
    goto LABEL_24;
  }
  id v4 = (os_log_s *)qword_1008F75A0;
  if (os_log_type_enabled((os_log_t)qword_1008F75A0, OS_LOG_TYPE_DEFAULT))
  {
    *(_DWORD *)__int128 buf = 138543362;
    *(void *)&uint8_t buf[4] = v3;
    _os_log_impl( (void *)&_mh_execute_header,  v4,  OS_LOG_TYPE_DEFAULT,  "Checking if device %{public}@ is Apple Device",  buf,  0xCu);
  }

  *(_OWORD *)__int128 buf = 0uLL;
  sub_100242F28((uint64_t)buf, a1 + 80);
  id v5 = sub_1005C6AC0(a1, v3);
  if (!v5)
  {
LABEL_23:
    sub_100242FAC((uint64_t)buf);
LABEL_24:
    uint64_t v14 = 0LL;
    goto LABEL_25;
  }

  id v6 = (id)v5[42];
  uint64_t v7 = v6;
  if (v6 && (unint64_t)[v6 length] >= 5)
  {
    BOOL v8 = (unsigned __int8 *)[v7 bytes];
    int v9 = *v8;
    int v10 = *(unsigned __int16 *)(v8 + 1);
    if (v9 == 2 && v10 == 1452) {
      goto LABEL_20;
    }
    if (v9 == 1 && v10 == 76) {
      goto LABEL_20;
    }
  }

  if (qword_1008D5F30 != -1) {
    dispatch_once(&qword_1008D5F30, &stru_1008A3498);
  }
  int v11 = off_1008D5F28;
  sub_10002418C(__p, "IsAppleWatch");
  if ((sub_1005CE5A8((uint64_t)v11, v3, (uint64_t)__p) & 1) != 0)
  {
    if (v17 < 0) {
      operator delete(__p[0]);
    }
    goto LABEL_20;
  }

  if (qword_1008D5F30 != -1) {
    dispatch_once(&qword_1008D5F30, &stru_1008A3498);
  }
  char v12 = sub_1005CE518((uint64_t)off_1008D5F28, v3);
  char v13 = v12;
  if (v17 < 0)
  {
    operator delete(__p[0]);
    if ((v13 & 1) != 0) {
      goto LABEL_20;
    }
    goto LABEL_22;
  }

  if ((v12 & 1) == 0)
  {
LABEL_22:

    goto LABEL_23;
  }

void sub_1005D903C( _Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void *__p, uint64_t a11, int a12, __int16 a13, char a14, char a15, char a16)
{
  sub_100242FAC((uint64_t)&a16);
  _Unwind_Resume(a1);
}

uint64_t sub_1005D908C(uint64_t a1)
{
  if (qword_1008D5F10 != -1) {
    dispatch_once(&qword_1008D5F10, &stru_1008A3478);
  }
  id v2 = sub_10059A34C((uint64_t)off_1008D5F08);
  id v3 = (void *)objc_claimAutoreleasedReturnValue(v2);
  v24[0] = 0LL;
  v24[1] = 0LL;
  sub_100242F28((uint64_t)v24, a1 + 80);
  __int128 v22 = 0u;
  __int128 v23 = 0u;
  __int128 v20 = 0u;
  __int128 v21 = 0u;
  id v4 = v3;
  id v5 = [v4 countByEnumeratingWithState:&v20 objects:v25 count:16];
  if (v5)
  {
    uint64_t v6 = *(void *)v21;
    while (2)
    {
      for (uint64_t i = 0LL; i != v5; uint64_t i = (char *)i + 1)
      {
        if (*(void *)v21 != v6) {
          objc_enumerationMutation(v4);
        }
        BOOL v8 = *(void **)(*((void *)&v20 + 1) + 8LL * (void)i);
        sub_10002418C(v18, "A1603");
        if ((sub_1005CE5A8(a1, v8, (uint64_t)v18) & 1) != 0)
        {
          char v9 = 1;
        }

        else
        {
          sub_10002418C(v16, "A2051");
          if ((sub_1005CE5A8(a1, v8, (uint64_t)v16) & 1) != 0)
          {
            char v9 = 1;
          }

          else
          {
            sub_10002418C(v14, "A3085");
            if ((sub_1005CE5A8(a1, v8, (uint64_t)v14) & 1) != 0)
            {
              char v9 = 1;
            }

            else
            {
              sub_10002418C(__p, "A2538");
              char v9 = sub_1005CE5A8(a1, v8, (uint64_t)__p);
              if (v13 < 0) {
                operator delete(__p[0]);
              }
            }

            if (v15 < 0) {
              operator delete(v14[0]);
            }
          }

          if (v17 < 0) {
            operator delete(v16[0]);
          }
        }

        if (v19 < 0) {
          operator delete(v18[0]);
        }
        if ((v9 & 1) != 0)
        {
          uint64_t v10 = 1LL;
          goto LABEL_27;
        }
      }

      id v5 = [v4 countByEnumeratingWithState:&v20 objects:v25 count:16];
      if (v5) {
        continue;
      }
      break;
    }
  }

  uint64_t v10 = 0LL;
LABEL_27:

  sub_100242FAC((uint64_t)v24);
  return v10;
}

void sub_1005D92E8( _Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void *a10, void *__p, uint64_t a12, int a13, __int16 a14, char a15, char a16, void *a17, uint64_t a18, int a19, __int16 a20, char a21, char a22, void *a23, uint64_t a24, int a25, __int16 a26, char a27, char a28, void *a29, uint64_t a30, int a31, __int16 a32, char a33, char a34, uint64_t a35, uint64_t a36, uint64_t a37, uint64_t a38, uint64_t a39, uint64_t a40, uint64_t a41, uint64_t a42, char a43)
{
  sub_100242FAC((uint64_t)&a43);
  _Unwind_Resume(a1);
}

uint64_t sub_1005D9384(uint64_t a1, void *a2, int a3, void *a4, int a5)
{
  id v9 = a2;
  id v10 = a4;
  v14[0] = 0LL;
  v14[1] = 0LL;
  sub_100242F28((uint64_t)v14, a1 + 80);
  int v11 = sub_1005C6AC0(a1, v9);
  if (v11) {
    uint64_t v12 = sub_1005C2558((uint64_t)v11, a3, v10, a5);
  }
  else {
    uint64_t v12 = 8LL;
  }
  sub_100242FAC((uint64_t)v14);

  return v12;
}

void sub_1005D9424(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

uint64_t sub_1005D9448(uint64_t a1, void *a2)
{
  return sub_1005D9384(a1, a2, 0, 0LL, 0);
}

NSMutableArray *sub_1005D9458(uint64_t a1, int a2)
{
  v15[0] = 0LL;
  v15[1] = 0LL;
  sub_100242F28((uint64_t)v15, a1 + 80);
  id v4 = objc_opt_new(&OBJC_CLASS___NSMutableArray);
  __int128 v13 = 0u;
  __int128 v14 = 0u;
  __int128 v11 = 0u;
  __int128 v12 = 0u;
  id v5 = *(id *)(a1 + 160);
  id v6 = [v5 countByEnumeratingWithState:&v11 objects:v16 count:16];
  if (v6)
  {
    uint64_t v7 = *(void *)v12;
    do
    {
      for (uint64_t i = 0LL; i != v6; uint64_t i = (char *)i + 1)
      {
        if (*(void *)v12 != v7) {
          objc_enumerationMutation(v5);
        }
        uint64_t v9 = *(void *)(*((void *)&v11 + 1) + 8LL * (void)i);
        if (*((_DWORD *)objc_msgSend(*(id *)(a1 + 160), "objectForKey:", v9, (void)v11) + 133) == a2) {
          -[NSMutableArray addObject:](v4, "addObject:", v9);
        }
      }

      id v6 = [v5 countByEnumeratingWithState:&v11 objects:v16 count:16];
    }

    while (v6);
  }

  sub_100242FAC((uint64_t)v15);
  return v4;
}

void sub_1005D95A4( _Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, ...)
{
  sub_100242FAC((uint64_t)va);
  _Unwind_Resume(a1);
}

uint64_t sub_1005D95DC(uint64_t a1, void *a2)
{
  id v3 = a2;
  v7[0] = 0LL;
  v7[1] = 0LL;
  sub_100242F28((uint64_t)v7, a1 + 80);
  id v4 = sub_1005C6AC0(a1, v3);
  if (v4) {
    uint64_t v5 = *((unsigned int *)v4 + 133);
  }
  else {
    uint64_t v5 = 0LL;
  }
  sub_100242FAC((uint64_t)v7);

  return v5;
}

void sub_1005D9644( _Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9)
{
  _Unwind_Resume(a1);
}

uint64_t sub_1005D9664(uint64_t a1, void *a2, int a3)
{
  id v5 = a2;
  v9[0] = 0LL;
  v9[1] = 0LL;
  sub_100242F28((uint64_t)v9, a1 + 80);
  id v6 = sub_1005C6AC0(a1, v5);
  if (v6) {
    uint64_t v7 = sub_1005C3474((uint64_t)v6, a3);
  }
  else {
    uint64_t v7 = 8LL;
  }
  sub_100242FAC((uint64_t)v9);

  return v7;
}

void sub_1005D96E0(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_1005D9700(uint64_t a1, void *a2, void *a3)
{
  id v5 = a2;
  id v6 = a3;
  v8[0] = 0LL;
  v8[1] = 0LL;
  sub_100242F28((uint64_t)v8, a1 + 80);
  uint64_t v7 = (id *)sub_1005C6AC0(a1, v5);
  if (v7) {
    objc_storeStrong(v7 + 25, a3);
  }
  sub_100242FAC((uint64_t)v8);
}

void sub_1005D977C( _Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9)
{
  _Unwind_Resume(a1);
}

uint64_t sub_1005D97A0(uint64_t a1, void *a2)
{
  id v3 = a2;
  v7[0] = 0LL;
  v7[1] = 0LL;
  sub_100242F28((uint64_t)v7, a1 + 80);
  id v4 = sub_1005C6AC0(a1, v3);
  if (v4) {
    uint64_t v5 = sub_1005C37F4((uint64_t)v4);
  }
  else {
    uint64_t v5 = 0LL;
  }
  sub_100242FAC((uint64_t)v7);

  return v5;
}

void sub_1005D980C(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

uint64_t sub_1005D982C(uint64_t a1, void *a2)
{
  id v3 = a2;
  v16[0] = 0LL;
  v16[1] = 0LL;
  sub_100242F28((uint64_t)v16, a1 + 80);
  if (qword_1008D5F30 != -1) {
    dispatch_once(&qword_1008D5F30, &stru_1008A3498);
  }
  unint64_t v4 = sub_1005CC198((uint64_t)off_1008D5F28, v3, 0);
  uint64_t v5 = sub_1001BCDB0(v4);
  int v13 = v5;
  char v15 = BYTE6(v5);
  __int16 v14 = WORD2(v5);
  id v6 = sub_1005C6AC0(a1, v3);
  uint64_t v7 = v6;
  unsigned __int8 v12 = *((_BYTE *)v6 + 560);
  uint64_t v8 = v12;
  if (!v12)
  {
    __int16 v11 = *((_WORD *)v6 + 281);
    __int16 v10 = *((_WORD *)v6 + 282);
    memset(v17, 0, sizeof(v17));
    sub_10010F218(&v13, &v10, &v12, &v11);
    *((_BYTE *)v7 + 560) = v12;
    *((_WORD *)v7 + 281) = v11;
    *((_WORD *)v7 + 282) = v10;
    sub_100328B0C((uint64_t)v17);
    uint64_t v8 = v12;
  }

  sub_100242FAC((uint64_t)v16);

  return v8;
}

void sub_1005D9998(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, ...)
{
  uint64_t v5 = va_arg(va1, void);
  uint64_t v7 = va_arg(va1, void);
  sub_100328B0C((uint64_t)va1);
  sub_100242FAC((uint64_t)va);

  _Unwind_Resume(a1);
}

void sub_1005D99D8(uint64_t a1, void *a2, uint64_t a3)
{
  id v5 = a2;
  v13[0] = 0LL;
  v13[1] = 0LL;
  sub_100242F28((uint64_t)v13, a1 + 80);
  id v6 = (id *)sub_1005C6AC0(a1, v5);
  uint64_t v7 = v6;
  if (v6)
  {
    sub_1005C3D04(v6, 0LL);
    if ((*(_WORD *)(a3 + 80) & 8) != 0)
    {
      __int16 v11 = 0LL;
      unsigned __int8 v12 = 0LL;
      sub_10056AB04(&v11, (const void *)(a3 + 28), 0x10uLL);
      if (sub_10056AAD8((uint64_t)&v11))
      {
        uint64_t v8 = sub_10056AAF0((uint64_t)&v11);
        uint64_t v9 = +[NSData dataWithBytes:length:]( &OBJC_CLASS___NSData,  "dataWithBytes:length:",  v8,  sub_10056AAD8((uint64_t)&v11));
        __int16 v10 = (void *)objc_claimAutoreleasedReturnValue(v9);
        sub_1005C3D04(v7, v10);
      }

      __int16 v11 = &off_10087FAA8;
      if (v12) {
        sub_1002CD254(v12);
      }
    }
  }

  sub_100242FAC((uint64_t)v13);
}

void sub_1005D9AD0(_Unwind_Exception *a1, uint64_t a2, unsigned int *a3, ...)
{
  if (a3) {
    sub_1002CD254(a3);
  }
  sub_100242FAC((uint64_t)va);

  _Unwind_Resume(a1);
}

void sub_1005D9B20(uint64_t a1, void *a2, char a3)
{
  id v5 = a2;
  v7[0] = 0LL;
  v7[1] = 0LL;
  sub_100242F28((uint64_t)v7, a1 + 80);
  id v6 = sub_1005C6AC0(a1, v5);
  if (v6) {
    *((_BYTE *)v6 + 97) = a3;
  }
  sub_100242FAC((uint64_t)v7);
}

void sub_1005D9B88( _Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9)
{
  _Unwind_Resume(a1);
}

void sub_1005D9BA8(uint64_t a1, void *a2, char a3)
{
  id v5 = a2;
  v7[0] = 0LL;
  v7[1] = 0LL;
  sub_100242F28((uint64_t)v7, a1 + 80);
  id v6 = sub_1005C6AC0(a1, v5);
  if (v6) {
    *((_BYTE *)v6 + 96) = a3;
  }
  sub_100242FAC((uint64_t)v7);
}

void sub_1005D9C10( _Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9)
{
  _Unwind_Resume(a1);
}

BOOL sub_1005D9C30( uint64_t a1, void *a2, char a3, char a4, __int16 a5, __int16 a6, __int16 a7, char a8, char a9, char a10)
{
  id v17 = a2;
  v21[0] = 0LL;
  v21[1] = 0LL;
  sub_100242F28((uint64_t)v21, a1 + 80);
  __int128 v18 = sub_1005C6AC0(a1, v17);
  if (v18)
  {
    *((_BYTE *)v18 + 566) = a3;
    *((_BYTE *)v18 + 567) = a4;
    *((_WORD *)v18 + 284) = a5;
    *((_WORD *)v18 + 285) = a6;
    *((_WORD *)v18 + 286) = a7;
    *((_BYTE *)v18 + 574) = a8;
    *((_BYTE *)v18 + 575) = a9;
    *((_BYTE *)v18 + 576) = a10;
  }

  BOOL v19 = v18 != 0LL;
  sub_100242FAC((uint64_t)v21);

  return v19;
}

void sub_1005D9CEC( _Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9)
{
  _Unwind_Resume(a1);
}

uint64_t sub_1005D9D0C( uint64_t a1, void *a2, _BYTE *a3, _BYTE *a4, _WORD *a5, _WORD *a6, _WORD *a7, _BYTE *a8, _BYTE *a9, _BYTE *a10)
{
  id v17 = a2;
  v21[0] = 0LL;
  v21[1] = 0LL;
  sub_100242F28((uint64_t)v21, a1 + 80);
  __int128 v18 = sub_1005C6AC0(a1, v17);
  if (v18) {
    uint64_t v19 = sub_1005D9DE8((uint64_t)v18, a3, a4, a5, a6, a7, a8, a9, a10);
  }
  else {
    uint64_t v19 = 0LL;
  }
  sub_100242FAC((uint64_t)v21);

  return v19;
}

void sub_1005D9DC8(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, ...)
{
  _Unwind_Resume(a1);
}

uint64_t sub_1005D9DE8( uint64_t a1, _BYTE *a2, _BYTE *a3, _WORD *a4, _WORD *a5, _WORD *a6, _BYTE *a7, _BYTE *a8, _BYTE *a9)
{
  BOOL v9 = *(_BYTE *)(a1 + 566) != 0;
  if (*(_BYTE *)(a1 + 566)) {
    *a2 = *(_BYTE *)(a1 + 566);
  }
  if (*(_BYTE *)(a1 + 567))
  {
    *a3 = *(_BYTE *)(a1 + 567);
    BOOL v9 = 1LL;
  }

  if (*(_WORD *)(a1 + 568))
  {
    *a4 = *(_WORD *)(a1 + 568);
    BOOL v9 = 1LL;
  }

  if (*(_WORD *)(a1 + 570))
  {
    *a5 = *(_WORD *)(a1 + 570);
    BOOL v9 = 1LL;
  }

  if (*(_WORD *)(a1 + 572))
  {
    *a6 = *(_WORD *)(a1 + 572);
    BOOL v9 = 1LL;
  }

  if (*(_BYTE *)(a1 + 574))
  {
    *a7 = *(_BYTE *)(a1 + 574);
    BOOL v9 = 1LL;
  }

  if (*(_BYTE *)(a1 + 575))
  {
    *a8 = *(_BYTE *)(a1 + 575);
    BOOL v9 = 1LL;
  }

  if (*(_BYTE *)(a1 + 576))
  {
    *a9 = *(_BYTE *)(a1 + 576);
    return 1LL;
  }

  return v9;
}

uint64_t sub_1005D9E78(uint64_t a1, int a2)
{
  double Current = CFAbsoluteTimeGetCurrent();
  v19[0] = 0LL;
  v19[1] = 0LL;
  sub_100242F28((uint64_t)v19, a1 + 80);
  __int128 v17 = 0u;
  __int128 v18 = 0u;
  __int128 v15 = 0u;
  __int128 v16 = 0u;
  id v5 = *(id *)(a1 + 160);
  unsigned __int16 v6 = 0;
  id v7 = [v5 countByEnumeratingWithState:&v15 objects:v20 count:16];
  if (v7)
  {
    double v8 = Current - (double)(60 * a2);
    uint64_t v9 = *(void *)v16;
    do
    {
      for (uint64_t i = 0LL; i != v7; uint64_t i = (char *)i + 1)
      {
        if (*(void *)v16 != v9) {
          objc_enumerationMutation(v5);
        }
        __int16 v11 = (double *)objc_msgSend( *(id *)(a1 + 160),  "objectForKey:",  *(void *)(*((void *)&v15 + 1) + 8 * (void)i),  (void)v15);
        double v12 = v11[50];
        BOOL v13 = v12 <= 0.0 || v12 < v8;
        if (!v13 || !a2 || *((_BYTE *)v11 + 160)) {
          ++v6;
        }
      }

      id v7 = [v5 countByEnumeratingWithState:&v15 objects:v20 count:16];
    }

    while (v7);
  }

  sub_100242FAC((uint64_t)v19);
  return v6;
}

void sub_1005D9FD4( _Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, ...)
{
  sub_100242FAC((uint64_t)va);
  _Unwind_Resume(a1);
}

void sub_1005DA008(uint64_t a1, void *a2, char a3)
{
  id v5 = a2;
  v7[0] = 0LL;
  v7[1] = 0LL;
  sub_100242F28((uint64_t)v7, a1 + 80);
  unsigned __int16 v6 = sub_1005C6AC0(a1, v5);
  if (v6) {
    sub_1005DA094((uint64_t)v6, a3);
  }
  sub_100242FAC((uint64_t)v7);
}

void sub_1005DA074(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

char *sub_1005DA094(uint64_t a1, char a2)
{
  char v5 = a2;
  uint64_t result = sub_1005DC6E4((void *)(a1 + 584), *(char **)(a1 + 584), &v5);
  uint64_t v4 = *(void *)(a1 + 592);
  return result;
}

void sub_1005DA0E8(uint64_t a1, void *a2, char a3)
{
  id v5 = a2;
  v7[0] = 0LL;
  v7[1] = 0LL;
  sub_100242F28((uint64_t)v7, a1 + 80);
  unsigned __int16 v6 = sub_1005C6AC0(a1, v5);
  if (v6) {
    *((_BYTE *)v6 + 608) = a3;
  }
  sub_100242FAC((uint64_t)v7);
}

void sub_1005DA150( _Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9)
{
  _Unwind_Resume(a1);
}

uint64_t sub_1005DA170(uint64_t a1, void *a2)
{
  id v3 = a2;
  v169[0] = 0LL;
  v169[1] = 0LL;
  sub_100242F28((uint64_t)v169, a1 + 80);
  uint64_t v4 = sub_1005C6AC0(a1, v3);
  __int128 v264 = 0u;
  __int128 v265 = 0u;
  memset(v263, 0, sizeof(v263));
  __int128 v261 = 0u;
  memset(v262, 0, sizeof(v262));
  __int128 v259 = 0u;
  __int128 v260 = 0u;
  __int128 v257 = 0u;
  memset(v258, 0, sizeof(v258));
  __int128 v255 = 0u;
  __int128 v256 = 0u;
  __int128 data = 0u;
  __int128 v254 = 0u;
  *(_DWORD *)&__dst[3] = 0;
  *(_DWORD *)__uuid_t dst = 0;
  std::string __p = 0LL;
  uint64_t v166 = 0LL;
  v167 = 0LL;
  __int128 v251 = xmmword_1006BDAF4;
  int v252 = 0;
  sub_100634334((__n128 *)buf, (__n128 *)&v251);
  id v5 = (char *)sub_100050420((uint64_t)&v167, 1uLL);
  id v7 = &v5[20 * v6];
  __int128 v8 = *(_OWORD *)buf;
  *((_DWORD *)v5 + 4) = *(_DWORD *)&buf[16];
  *(_OWORD *)id v5 = v8;
  uint64_t v9 = v5 + 20;
  __int16 v11 = (char *)__p;
  __int16 v10 = v166;
  if (v166 != __p)
  {
    do
    {
      __int128 v12 = *(_OWORD *)(v10 - 20);
      *((_DWORD *)v5 - 1) = *((_DWORD *)v10 - 1);
      *(_OWORD *)(v5 - 20) = v12;
      v5 -= 20;
      v10 -= 20;
    }

    while (v10 != v11);
    __int16 v10 = (char *)__p;
  }

  std::string __p = v5;
  uint64_t v166 = v9;
  v167 = v7;
  if (v10) {
    operator delete(v10);
  }
  uint64_t v166 = v9;
  id v162 = 0LL;
  uint64_t v163 = 0LL;
  v164 = 0LL;
  __int128 v249 = xmmword_1006BDB08;
  int v250 = 0;
  sub_100634334((__n128 *)buf, (__n128 *)&v249);
  BOOL v13 = (char *)sub_100050420((uint64_t)&v164, 1uLL);
  __int128 v15 = &v13[20 * v14];
  __int128 v16 = *(_OWORD *)buf;
  *((_DWORD *)v13 + 4) = *(_DWORD *)&buf[16];
  *(_OWORD *)BOOL v13 = v16;
  __int128 v17 = v13 + 20;
  uint64_t v19 = (char *)v162;
  __int128 v18 = v163;
  if (v163 != v162)
  {
    do
    {
      __int128 v20 = *(_OWORD *)(v18 - 20);
      *((_DWORD *)v13 - 1) = *((_DWORD *)v18 - 1);
      *(_OWORD *)(v13 - 20) = v20;
      v13 -= 20;
      v18 -= 20;
    }

    while (v18 != v19);
    __int128 v18 = (char *)v162;
  }

  id v162 = v13;
  uint64_t v163 = v17;
  v164 = v15;
  if (v18) {
    operator delete(v18);
  }
  uint64_t v163 = v17;
  if (*((_BYTE *)v4 + 357))
  {
    __int128 v21 = (os_log_s *)qword_1008F75A0;
    if (os_log_type_enabled((os_log_t)qword_1008F75A0, OS_LOG_TYPE_DEFAULT))
    {
      *(_WORD *)__int128 buf = 0;
      _os_log_impl( (void *)&_mh_execute_header,  v21,  OS_LOG_TYPE_DEFAULT,  "Identification - metric has already been updated",  buf,  2u);
    }

    uint64_t v22 = 3LL;
    goto LABEL_15;
  }

  if (qword_1008D5F60 != -1) {
    dispatch_once(&qword_1008D5F60, &stru_1008A3598);
  }
  if (sub_10055679C(qword_1008D5F58, v3, (__int128 **)&__p, 1u, 0LL, 0))
  {
    BYTE3(data) = 1;
  }

  else
  {
    if (qword_1008D5F60 != -1) {
      dispatch_once(&qword_1008D5F60, &stru_1008A3598);
    }
    if (!sub_10055679C(qword_1008D5F58, v3, (__int128 **)&v162, 1u, 0LL, 0))
    {
      __int16 v34 = (os_log_s *)qword_1008F75A0;
      if (os_log_type_enabled((os_log_t)qword_1008F75A0, OS_LOG_TYPE_DEFAULT))
      {
        *(_WORD *)__int128 buf = 0;
        _os_log_impl( (void *)&_mh_execute_header,  v34,  OS_LOG_TYPE_DEFAULT,  "Identification - le metric only send for HIDs and GHSS, returning",  buf,  2u);
      }

      uint64_t v22 = 1LL;
      goto LABEL_15;
    }

    BYTE8(v265) = 1;
  }

  if (*((_BYTE *)v4 + 359))
  {
    unint64_t v24 = v4[3];
    if (v24)
    {
      unint64_t v25 = sub_1001BEE0C(v24);
      *(_DWORD *)uint64_t v156 = v25;
      *(_WORD *)&v156[4] = WORD2(v25);
      LOWORD(data) = v25;
      BYTE2(data) = BYTE2(v25);
      __int16 v26 = (os_log_s *)qword_1008F75A0;
      if (os_log_type_enabled((os_log_t)qword_1008F75A0, OS_LOG_TYPE_DEFAULT))
      {
        *(_DWORD *)__int128 buf = 68289538;
        *(_DWORD *)&uint8_t buf[4] = 6;
        *(_WORD *)&uint8_t buf[8] = 2098;
        *(void *)&buf[10] = v156;
        *(_WORD *)&_BYTE buf[18] = 1042;
        *(_DWORD *)&buf[20] = 3;
        *(_WORD *)&uint8_t buf[24] = 2098;
        p___int128 data = &data;
        _os_log_impl( (void *)&_mh_execute_header,  v26,  OS_LOG_TYPE_DEFAULT,  "Identification - device has resolved address %{public}.6P and OUI %{public}.3P",  buf,  0x22u);
        __int16 v26 = (os_log_s *)qword_1008F75A0;
      }

      if (os_log_type_enabled(v26, OS_LOG_TYPE_DEFAULT))
      {
        BOOL v27 = BYTE6(v24) == 1LL;
        uint64_t v28 = (v24 >> 40) & 0xC0;
        if (v28) {
          BOOL v29 = 0;
        }
        else {
          BOOL v29 = BYTE6(v24) == 1LL;
        }
        BOOL v30 = v28 == 64 && BYTE6(v24) == 1LL;
        if (v28 != 192) {
          BOOL v27 = 0;
        }
        if (BYTE6(v24)) {
          BOOL v32 = BYTE6(v24) == 1LL && v28 != 128;
        }
        else {
          BOOL v32 = 1;
        }
        *(_DWORD *)__int128 buf = 67110144;
        *(_DWORD *)&uint8_t buf[4] = BYTE6(v24) == 0;
        *(_WORD *)&uint8_t buf[8] = 1024;
        *(_DWORD *)&buf[10] = v30;
        *(_WORD *)&buf[14] = 1024;
        *(_DWORD *)&_WORD buf[16] = v27;
        *(_WORD *)&buf[20] = 1024;
        *(_DWORD *)&_BYTE buf[22] = v29;
        LOWORD(p_data) = 1024;
        *(_DWORD *)((char *)&p_data + 2) = v32;
        _os_log_impl( (void *)&_mh_execute_header,  v26,  OS_LOG_TYPE_DEFAULT,  "Identification - le device has address type %d, %d, %d, %d, %d",  buf,  0x20u);
      }

      LOWORD(data) = -1;
      BYTE2(data) = -1;
    }

    else
    {
      unint64_t v24 = v4[2];
      if (BYTE6(v24))
      {
        char v35 = (os_log_s *)qword_1008F75A0;
        if (os_log_type_enabled((os_log_t)qword_1008F75A0, OS_LOG_TYPE_DEFAULT))
        {
          BOOL v36 = BYTE6(v24) == 1LL;
          uint64_t v37 = (v24 >> 40) & 0xC0;
          if (v37) {
            BOOL v38 = 0;
          }
          else {
            BOOL v38 = BYTE6(v24) == 1LL;
          }
          *(_DWORD *)__int128 buf = 67110144;
          *(_DWORD *)&uint8_t buf[4] = 0;
          BOOL v39 = v37 == 64 && BYTE6(v24) == 1LL;
          *(_WORD *)&uint8_t buf[8] = 1024;
          *(_DWORD *)&buf[10] = v39;
          BOOL v40 = v37 == 192 && BYTE6(v24) == 1LL;
          *(_WORD *)&buf[14] = 1024;
          *(_DWORD *)&_WORD buf[16] = v40;
          if (v37 == 128) {
            BOOL v36 = 0;
          }
          *(_WORD *)&buf[20] = 1024;
          *(_DWORD *)&_BYTE buf[22] = v38;
          LOWORD(p_data) = 1024;
          *(_DWORD *)((char *)&p_data + 2) = v36;
          _os_log_impl( (void *)&_mh_execute_header,  v35,  OS_LOG_TYPE_DEFAULT,  "Identification - le device has address type %d, %d, %d, %d, %d, can not generate metric",  buf,  0x20u);
        }

        memset(buf, 0, 24);
        if (qword_1008D5F30 != -1) {
          dispatch_once(&qword_1008D5F30, &stru_1008A3498);
        }
        sub_1005CC0D4((uint64_t)off_1008D5F28, v3, (uint64_t)buf);
        int v41 = std::string::compare((const std::string *)buf, "Arc Touch BT Mouse");
        if (v41)
        {
          *((_BYTE *)v4 + 368) = 0;
        }

        else
        {
          uint64_t v149 = (os_log_s *)qword_1008F75A0;
          if (os_log_type_enabled((os_log_t)qword_1008F75A0, OS_LOG_TYPE_DEFAULT))
          {
            *(_WORD *)uint64_t v156 = 0;
            _os_log_impl( (void *)&_mh_execute_header,  v149,  OS_LOG_TYPE_DEFAULT,  "HIDIdentification - WAR for Arc Touch BT Mouse Identification",  v156,  2u);
          }

          LOWORD(data) = -1;
          BYTE2(data) = -1;
        }

        if ((buf[23] & 0x80000000) != 0) {
          operator delete(*(void **)buf);
        }
        if (v41)
        {
          uint64_t v22 = 2LL;
          goto LABEL_15;
        }
      }

      else
      {
        unint64_t v42 = sub_1001BEE0C(v24);
        *(_DWORD *)uint64_t v156 = v42;
        *(_WORD *)&v156[4] = WORD2(v42);
        LOWORD(data) = v42;
        BYTE2(data) = BYTE2(v42);
        id v43 = (os_log_s *)qword_1008F75A0;
        if (os_log_type_enabled((os_log_t)qword_1008F75A0, OS_LOG_TYPE_DEFAULT))
        {
          *(_DWORD *)__int128 buf = 68289538;
          *(_DWORD *)&uint8_t buf[4] = 6;
          *(_WORD *)&uint8_t buf[8] = 2098;
          *(void *)&buf[10] = v156;
          *(_WORD *)&_BYTE buf[18] = 1042;
          *(_DWORD *)&buf[20] = 3;
          *(_WORD *)&uint8_t buf[24] = 2098;
          p___int128 data = &data;
          _os_log_impl( (void *)&_mh_execute_header,  v43,  OS_LOG_TYPE_DEFAULT,  "Identification - device has public address %{public}.6P and OUI %{public}.3P",  buf,  0x22u);
        }
      }
    }

    if (qword_1008D67C8 != -1) {
      dispatch_once(&qword_1008D67C8, &stru_1008A3458);
    }
    v153 = v3;
    id v44 = sub_10027D9C4((uint64_t)off_1008D67C0, v3);
    char v45 = (void *)objc_claimAutoreleasedReturnValue(v44);
    __int128 v160 = 0u;
    __int128 v161 = 0u;
    __int128 v158 = 0u;
    __int128 v159 = 0u;
    id v46 = v45;
    id v47 = [v46 countByEnumeratingWithState:&v158 objects:v248 count:16];
    if (v47)
    {
      uint64_t v48 = *(void *)v159;
LABEL_81:
      uint64_t v49 = 0LL;
      while (1)
      {
        if (*(void *)v159 != v48) {
          objc_enumerationMutation(v46);
        }
        uint64_t v50 = *(void **)(*((void *)&v158 + 1) + 8 * v49);
        if (([v50 isEqualToString:@"com.apple.BTLEServer"] & 1) == 0
          && ([v50 isEqualToString:@"com.apple.Preferences"] & 1) == 0)
        {
          break;
        }

        if (v47 == (id)++v49)
        {
          id v47 = [v46 countByEnumeratingWithState:&v158 objects:v248 count:16];
          if (v47) {
            goto LABEL_81;
          }
          goto LABEL_88;
        }
      }

      id v51 = v50;

      if (!v51) {
        goto LABEL_95;
      }
      uint64_t v52 = (os_log_s *)qword_1008F75A0;
      if (os_log_type_enabled((os_log_t)qword_1008F75A0, OS_LOG_TYPE_DEFAULT))
      {
        *(_DWORD *)__int128 buf = 138543618;
        *(void *)&uint8_t buf[4] = v51;
        *(_WORD *)&_BYTE buf[12] = 2114;
        *(void *)&buf[14] = v3;
        _os_log_impl( (void *)&_mh_execute_header,  v52,  OS_LOG_TYPE_DEFAULT,  "%{public}@ bundleid found for uuid %{public}@",  buf,  0x16u);
      }

      id v152 = v51;
      sub_10002418C(buf, (char *)[v152 UTF8String]);
      uint64_t v53 = v3;
      if (SHIBYTE(v258[2]) < 0) {
        operator delete(v258[0]);
      }
      *(_OWORD *)__int128 v258 = *(_OWORD *)buf;
      v258[2] = *(void **)&buf[16];
    }

    else
    {
LABEL_88:

LABEL_95:
      uint64_t v54 = (os_log_s *)qword_1008F75A0;
      uint64_t v53 = v3;
      if (os_log_type_enabled((os_log_t)qword_1008F75A0, OS_LOG_TYPE_DEFAULT))
      {
        *(_DWORD *)__int128 buf = 138543362;
        *(void *)&uint8_t buf[4] = v3;
        _os_log_impl( (void *)&_mh_execute_header,  v54,  OS_LOG_TYPE_DEFAULT,  "No bundleid found for uuid %{public}@",  buf,  0xCu);
      }

      id v152 = 0LL;
    }

    id v55 = (id)v4[42];
    id v151 = v55;
    if (v55)
    {
      id v56 = v55;
      memcpy(__dst, [v56 bytes], (size_t)objc_msgSend(v56, "length"));
      int v57 = __dst[0];
      int v58 = *(unsigned __int16 *)&__dst[1];
      DWORD2(v255) = __dst[0];
      HIDWORD(v255) = *(unsigned __int16 *)&__dst[1];
      LODWORD(v256) = *(unsigned __int16 *)&__dst[3];
      DWORD1(v256) = *(unsigned __int16 *)&__dst[5];
      uint64_t v53 = v153;
    }

    else
    {
      int v57 = DWORD2(v255);
      int v58 = HIDWORD(v255);
    }

    if (v57 == 2 && v58 == 1452 || (char v59 = 0, v57 == 1) && v58 == 76)
    {
      id v60 = (os_log_s *)qword_1008F75A0;
      if (os_log_type_enabled((os_log_t)qword_1008F75A0, OS_LOG_TYPE_DEFAULT))
      {
        *(_WORD *)__int128 buf = 0;
        _os_log_impl( (void *)&_mh_execute_header,  v60,  OS_LOG_TYPE_DEFAULT,  "Overriding LE OUI for apple devices",  buf,  2u);
        int v57 = DWORD2(v255);
        int v58 = HIDWORD(v255);
      }

      LOWORD(data) = 2560;
      BYTE2(data) = 39;
      char v59 = 1;
    }

    if (v57 == 2 && v58 == 1118)
    {
      uint64_t v61 = (os_log_s *)qword_1008F75A0;
      if (os_log_type_enabled((os_log_t)qword_1008F75A0, OS_LOG_TYPE_DEFAULT))
      {
        *(_WORD *)__int128 buf = 0;
        _os_log_impl( (void *)&_mh_execute_header,  v61,  OS_LOG_TYPE_DEFAULT,  "Overriding LE OUI for MSFT devices",  buf,  2u);
      }

      LOWORD(data) = 7664;
      BYTE2(data) = -68;
    }

    if (qword_1008D5F30 != -1) {
      dispatch_once(&qword_1008D5F30, &stru_1008A3498);
    }
    sub_1005CC0D4((uint64_t)off_1008D5F28, v53, (uint64_t)buf);
    if (SBYTE7(v265) < 0) {
      operator delete((void *)v264);
    }
    *(void *)&__int128 v265 = *(void *)&buf[16];
    __int128 v264 = *(_OWORD *)buf;
    uint64_t v62 = buf[23];
    if (buf[23] >= 0) {
      uint64_t v63 = &v264;
    }
    else {
      uint64_t v63 = (__int128 *)v264;
    }
    if (buf[23] < 0) {
      uint64_t v62 = *((void *)&v264 + 1);
    }
    buf[0] = 13;
    int v64 = sub_1003DCD38(v63, (unsigned __int8 *)v63 + v62, buf);
    unsigned int v65 = (char *)&v264 + BYTE7(v265);
    if ((SBYTE7(v265) & 0x80u) == 0)
    {
      id v66 = (unsigned __int8 *)&v264;
    }

    else
    {
      unsigned int v65 = (char *)(v264 + *((void *)&v264 + 1));
      id v66 = (unsigned __int8 *)v264;
    }

    std::string::erase((std::string *)&v264, v64 - v66, v65 - (char *)v64);
    uint64_t v67 = BYTE7(v265);
    if ((SBYTE7(v265) & 0x80u) == 0) {
      BOOL v68 = &v264;
    }
    else {
      BOOL v68 = (__int128 *)v264;
    }
    if (SBYTE7(v265) < 0) {
      uint64_t v67 = *((void *)&v264 + 1);
    }
    buf[0] = 10;
    int v69 = sub_1003DCD38(v68, (unsigned __int8 *)v68 + v67, buf);
    uint64_t v70 = (char *)&v264 + BYTE7(v265);
    if ((SBYTE7(v265) & 0x80u) == 0)
    {
      BOOL v71 = (unsigned __int8 *)&v264;
    }

    else
    {
      uint64_t v70 = (char *)(v264 + *((void *)&v264 + 1));
      BOOL v71 = (unsigned __int8 *)v264;
    }

    std::string::erase((std::string *)&v264, v69 - v71, v70 - (char *)v69);
    uint64_t v72 = BYTE7(v265);
    if ((SBYTE7(v265) & 0x80u) == 0) {
      unint64_t v73 = &v264;
    }
    else {
      unint64_t v73 = (__int128 *)v264;
    }
    if (SBYTE7(v265) < 0) {
      uint64_t v72 = *((void *)&v264 + 1);
    }
    buf[0] = 44;
    int64_t v74 = sub_1003DCD38(v73, (unsigned __int8 *)v73 + v72, buf);
    unsigned __int16 v75 = (char *)&v264 + BYTE7(v265);
    if ((SBYTE7(v265) & 0x80u) == 0)
    {
      uint64_t v76 = (unsigned __int8 *)&v264;
    }

    else
    {
      unsigned __int16 v75 = (char *)(v264 + *((void *)&v264 + 1));
      uint64_t v76 = (unsigned __int8 *)v264;
    }

    std::string::erase((std::string *)&v264, v74 - v76, v75 - (char *)v74);
    char v157 = 0;
    sub_100242CA4(&v157);
    char v150 = v59;
    *(_DWORD *)&v156[3] = 0;
    *(_DWORD *)uint64_t v156 = 0;
    uint64_t v77 = sub_1001BCDB0(v24);
    *(_DWORD *)uint64_t v156 = v77;
    v156[6] = BYTE6(v77);
    *(_WORD *)&v156[4] = WORD2(v77);
    if (sub_10010F218(v156, (_WORD *)&data + 2, (_BYTE *)&data + 8, (_WORD *)&data + 3)
      && os_log_type_enabled((os_log_t)qword_1008F75A0, OS_LOG_TYPE_ERROR))
    {
      sub_10069B750();
    }

    sub_100242CD0(&v157);
    id v78 = (id)v4[34];
    BOOL v79 = v78 == 0LL;

    if (!v79)
    {
      id v80 = (id) v4[34];
      sub_10002418C(buf, (char *)[v80 UTF8String]);
      if (SHIBYTE(v258[5]) < 0) {
        operator delete(v258[3]);
      }
      *(_OWORD *)&v258[3] = *(_OWORD *)buf;
      v258[5] = *(void **)&buf[16];
      buf[23] = 0;
      buf[0] = 0;
    }

    id v81 = (id)v4[35];
    BOOL v82 = v81 == 0LL;

    if (!v82)
    {
      id v83 = (id) v4[35];
      sub_10002418C(buf, (char *)[v83 UTF8String]);
      if (SBYTE7(v260) < 0) {
        operator delete((void *)v259);
      }
      __int128 v259 = *(_OWORD *)buf;
      *(void *)&__int128 v260 = *(void *)&buf[16];
      buf[23] = 0;
      buf[0] = 0;
    }

    id v84 = (id)v4[37];
    BOOL v85 = v84 == 0LL;

    if (!v85)
    {
      id v86 = (id) v4[37];
      sub_10002418C(buf, (char *)[v86 UTF8String]);
      if (SBYTE7(v262[1]) < 0) {
        operator delete(*(void **)&v262[0]);
      }
      v262[0] = *(_OWORD *)buf;
      *(void *)&v262[1] = *(void *)&buf[16];
      buf[23] = 0;
      buf[0] = 0;
    }

    id v87 = (id)v4[38];
    BOOL v88 = v87 == 0LL;

    if (!v88)
    {
      id v89 = (id) v4[38];
      sub_10002418C(buf, (char *)[v89 UTF8String]);
      if (SHIBYTE(v262[2]) < 0) {
        operator delete(*((void **)&v262[1] + 1));
      }
      *(_OWORD *)((char *)&v262[1] + 8) = *(_OWORD *)buf;
      *((void *)&v262[2] + 1) = *(void *)&buf[16];
      buf[23] = 0;
      buf[0] = 0;
    }

    id v90 = (id)v4[39];
    BOOL v91 = v90 == 0LL;

    if (!v91)
    {
      id v92 = (id) v4[39];
      sub_10002418C(buf, (char *)[v92 UTF8String]);
      if (SBYTE7(v263[1]) < 0) {
        operator delete(*(void **)&v263[0]);
      }
      v263[0] = *(_OWORD *)buf;
      *(void *)&v263[1] = *(void *)&buf[16];
      buf[23] = 0;
      buf[0] = 0;
    }

    uint64_t v93 = BYTE7(v265);
    if ((SBYTE7(v265) & 0x80u) == 0) {
      uint64_t v94 = &v264;
    }
    else {
      uint64_t v94 = (__int128 *)v264;
    }
    if (SBYTE7(v265) < 0) {
      uint64_t v93 = *((void *)&v264 + 1);
    }
    buf[0] = 13;
    id v95 = sub_1003DCD38(v94, (unsigned __int8 *)v94 + v93, buf);
    uint64_t v96 = (char *)&v264 + BYTE7(v265);
    if ((SBYTE7(v265) & 0x80u) == 0)
    {
      id v97 = (unsigned __int8 *)&v264;
    }

    else
    {
      uint64_t v96 = (char *)(v264 + *((void *)&v264 + 1));
      id v97 = (unsigned __int8 *)v264;
    }

    std::string::erase((std::string *)&v264, v95 - v97, v96 - (char *)v95);
    uint64_t v98 = BYTE7(v265);
    if ((SBYTE7(v265) & 0x80u) == 0) {
      __int16 v99 = &v264;
    }
    else {
      __int16 v99 = (__int128 *)v264;
    }
    if (SBYTE7(v265) < 0) {
      uint64_t v98 = *((void *)&v264 + 1);
    }
    buf[0] = 10;
    signed int v100 = sub_1003DCD38(v99, (unsigned __int8 *)v99 + v98, buf);
    uint64_t v101 = (char *)&v264 + BYTE7(v265);
    if ((SBYTE7(v265) & 0x80u) == 0)
    {
      char v102 = (unsigned __int8 *)&v264;
    }

    else
    {
      uint64_t v101 = (char *)(v264 + *((void *)&v264 + 1));
      char v102 = (unsigned __int8 *)v264;
    }

    std::string::erase((std::string *)&v264, v100 - v102, v101 - (char *)v100);
    uint64_t v103 = BYTE7(v265);
    if ((SBYTE7(v265) & 0x80u) == 0) {
      __int128 v104 = &v264;
    }
    else {
      __int128 v104 = (__int128 *)v264;
    }
    if (SBYTE7(v265) < 0) {
      uint64_t v103 = *((void *)&v264 + 1);
    }
    buf[0] = 44;
    __int128 v105 = sub_1003DCD38(v104, (unsigned __int8 *)v104 + v103, buf);
    __int128 v106 = (char *)&v264 + BYTE7(v265);
    if ((SBYTE7(v265) & 0x80u) == 0)
    {
      __int16 v107 = (unsigned __int8 *)&v264;
    }

    else
    {
      __int128 v106 = (char *)(v264 + *((void *)&v264 + 1));
      __int16 v107 = (unsigned __int8 *)v264;
    }

    std::string::erase((std::string *)&v264, v105 - v107, v106 - (char *)v105);
    unint64_t v108 = HIBYTE(v258[2]);
    if (SHIBYTE(v258[2]) < 0) {
      unint64_t v108 = (unint64_t)v258[1];
    }
    char v109 = (char *)HIBYTE(v258[5]);
    if (SHIBYTE(v258[5]) < 0) {
      char v109 = (char *)v258[4];
    }
    __int128 v110 = &v109[v108];
    uint64_t v111 = BYTE7(v260);
    if (SBYTE7(v260) < 0) {
      uint64_t v111 = *((void *)&v259 + 1);
    }
    __int128 v112 = (char *)calloc((size_t)&v110[v111 + 80], 1uLL);
    __int128 v113 = v112;
    *(_OWORD *)__int128 v112 = data;
    __int128 v114 = v254;
    __int128 v115 = v255;
    __int128 v116 = v257;
    *((_OWORD *)v112 + 3) = v256;
    *((_OWORD *)v112 + 4) = v116;
    *((_OWORD *)v112 + 1) = v114;
    *((_OWORD *)v112 + 2) = v115;
    if ((v150 & 1) != 0)
    {
      unsigned int v117 = 80;
    }

    else
    {
      int v118 = v112 + 80;
      if (SHIBYTE(v258[2]) >= 0) {
        __int128 v119 = v258;
      }
      else {
        __int128 v119 = (void **)v258[0];
      }
      if (SHIBYTE(v258[2]) >= 0) {
        size_t v120 = HIBYTE(v258[2]);
      }
      else {
        size_t v120 = (size_t)v258[1];
      }
      memcpy(v118, v119, v120);
      int v121 = HIBYTE(v258[2]);
      if (SHIBYTE(v258[2]) < 0) {
        int v121 = (int)v258[1];
      }
      unsigned int v117 = v121 + 80;
    }

    if (SHIBYTE(v258[5]) >= 0) {
      __int128 v122 = &v258[3];
    }
    else {
      __int128 v122 = (void **)v258[3];
    }
    if (SHIBYTE(v258[5]) >= 0) {
      size_t v123 = HIBYTE(v258[5]);
    }
    else {
      size_t v123 = (size_t)v258[4];
    }
    memcpy(&v113[v117], v122, v123);
    int v124 = HIBYTE(v258[5]);
    if (SHIBYTE(v258[5]) < 0) {
      int v124 = (int)v258[4];
    }
    int v125 = v124 + v117;
    if ((SBYTE7(v260) & 0x80u) == 0) {
      int v126 = &v259;
    }
    else {
      int v126 = (__int128 *)v259;
    }
    if ((SBYTE7(v260) & 0x80u) == 0) {
      size_t v127 = BYTE7(v260);
    }
    else {
      size_t v127 = *((void *)&v259 + 1);
    }
    memcpy(&v113[v125], v126, v127);
    int v128 = BYTE7(v260);
    if (SBYTE7(v260) < 0) {
      int v128 = DWORD2(v259);
    }
    CC_LONG v129 = v128 + v125;
    CC_SHA1(&data, v129, (unsigned __int8 *)&v263[1] + 8);
    __int128 v130 = (os_log_s *)qword_1008F75A0;
    if (os_log_type_enabled((os_log_t)qword_1008F75A0, OS_LOG_TYPE_DEFAULT))
    {
      *(_DWORD *)__int128 buf = 68157954;
      *(_DWORD *)&uint8_t buf[4] = v129;
      *(_WORD *)&uint8_t buf[8] = 2098;
      *(void *)&buf[10] = &data;
      _os_log_impl( (void *)&_mh_execute_header,  v130,  OS_LOG_TYPE_DEFAULT,  "Identification - LE raw serialized data dump {%{public}.*P}",  buf,  0x12u);
      __int128 v130 = (os_log_s *)qword_1008F75A0;
    }

    if (os_log_type_enabled(v130, OS_LOG_TYPE_DEFAULT))
    {
      v131 = (char *)&v260 + 8;
      if ((SBYTE7(v265) & 0x80u) == 0) {
        v132 = &v264;
      }
      else {
        v132 = (__int128 *)v264;
      }
      if (SHIBYTE(v258[2]) >= 0) {
        uint64_t v133 = v258;
      }
      else {
        uint64_t v133 = (void **)v258[0];
      }
      if (v261 < 0) {
        v131 = (char *)*((void *)&v260 + 1);
      }
      v134 = (void **)v258[3];
      if (SHIBYTE(v258[5]) >= 0) {
        v134 = &v258[3];
      }
      id v135 = &v259;
      if (SBYTE7(v260) < 0) {
        id v135 = (__int128 *)v259;
      }
      uint64_t v136 = v262;
      if (SBYTE7(v262[1]) < 0) {
        uint64_t v136 = *(_OWORD **)&v262[0];
      }
      int v137 = (char *)&v262[1] + 8;
      if (v262[2] < 0) {
        int v137 = (char *)*((void *)&v262[1] + 1);
      }
      uint64_t v138 = *(_OWORD **)&v263[0];
      if ((SBYTE7(v263[1]) & 0x80u) == 0) {
        uint64_t v138 = v263;
      }
      *(_DWORD *)&uint8_t buf[4] = 20;
      p___int128 data = &data;
      uint64_t v173 = v132;
      int v175 = WORD2(data);
      int v179 = WORD3(data);
      id v183 = &v257;
      uint64_t v187 = (char *)&v257 + 8;
      int v191 = WORD5(data);
      int v195 = HIWORD(data);
      int v199 = WORD1(v254);
      int v203 = WORD3(v254);
      int v207 = WORD5(v254);
      int v211 = HIWORD(v254);
      int v215 = WORD1(v255);
      int v219 = WORD3(v255);
      int v223 = HIDWORD(v255);
      int v227 = DWORD1(v256);
      int v231 = BYTE3(data);
      id v233 = v133;
      *(void *)&buf[10] = (char *)&v263[1] + 8;
      *(_DWORD *)&buf[20] = 3;
      int v177 = BYTE8(data);
      *(_WORD *)&_BYTE buf[18] = 1042;
      __int16 v180 = 1042;
      __int16 v184 = 1042;
      int v181 = 8;
      int v185 = 8;
      *(_WORD *)&uint8_t buf[8] = 2098;
      *(_WORD *)&uint8_t buf[24] = 2098;
      __int16 v182 = 2098;
      __int16 v186 = 2098;
      __int128 v239 = v135;
      __int128 v241 = v136;
      __int128 v243 = v137;
      int v247 = BYTE8(v265);
      int v189 = HIDWORD(v256);
      int v193 = WORD6(data);
      int v197 = (unsigned __int16)v254;
      int v201 = WORD2(v254);
      int v205 = WORD4(v254);
      int v209 = WORD6(v254);
      int v213 = (unsigned __int16)v255;
      int v217 = WORD2(v255);
      int v221 = DWORD2(v255);
      int v225 = v256;
      int v229 = DWORD2(v256);
      BOOL v235 = v131;
      __int128 v237 = v134;
      __int16 v172 = 2082;
      __int16 v232 = 2082;
      __int16 v234 = 2082;
      __int16 v236 = 2082;
      __int16 v238 = 2082;
      __int16 v240 = 2082;
      __int16 v242 = 2082;
      __int16 v244 = 2082;
      __int128 v245 = v138;
      __int16 v174 = 1024;
      __int16 v176 = 1024;
      __int16 v178 = 1024;
      __int16 v188 = 1024;
      __int16 v190 = 1024;
      __int16 v192 = 1024;
      __int16 v194 = 1024;
      __int16 v196 = 1024;
      __int16 v198 = 1024;
      __int16 v200 = 1024;
      __int16 v202 = 1024;
      __int16 v204 = 1024;
      __int16 v206 = 1024;
      __int16 v208 = 1024;
      __int16 v210 = 1024;
      __int16 v212 = 1024;
      __int16 v214 = 1024;
      __int16 v216 = 1024;
      __int16 v218 = 1024;
      __int16 v220 = 1024;
      __int16 v222 = 1024;
      __int16 v224 = 1024;
      __int16 v226 = 1024;
      __int16 v228 = 1024;
      __int16 v230 = 1024;
      __int16 v246 = 1024;
      *(_DWORD *)__int128 buf = 68299266;
      _os_log_impl( (void *)&_mh_execute_header,  v130,  OS_LOG_TYPE_DEFAULT,  "Identification - generating LE metric {%{public}.20P, %{public}.3P, %{public}s, 0x%x, 0x%x, 0x%x, %{public}.8P, %{public}.8P, 0x%x, 0x%x, 0x%x, 0x%x, 0x%x, 0x%x, 0x%x, 0x%x, 0x%x, 0x%x, 0x%x, 0x%x, 0x%x, 0x%x, 0x%x, 0x%x, 0x %x, 0x%x, 0x%x, 0x%x, 0x%x, %d, %{public}s, %{public}s, %{public}s, %{public}s, %{public}s, %{public}s, %{public}s, %d}",  buf,  0x12Eu);
    }

    free(v113);
    uint64_t v139 = sub_1002E6E00();
    if ((*(unsigned int (**)(uint64_t))(*(void *)v139 + 8LL))(v139) && (WORD1(v255) || BYTE3(data)))
    {
      id v146 = (os_log_s *)qword_1008F75A0;
      if (os_log_type_enabled((os_log_t)qword_1008F75A0, OS_LOG_TYPE_DEFAULT))
      {
        uint64_t v147 = sub_1002E6E00();
        int v148 = (*(uint64_t (**)(uint64_t))(*(void *)v147 + 8LL))(v147);
        *(_DWORD *)__int128 buf = 67109376;
        *(_DWORD *)&uint8_t buf[4] = v148;
        *(_WORD *)&uint8_t buf[8] = 1024;
        *(_DWORD *)&buf[10] = BYTE3(data);
        _os_log_impl( (void *)&_mh_execute_header,  v146,  OS_LOG_TYPE_DEFAULT,  "Identification - routing LE friendly name: internal %d, le hid service present %d",  buf,  0xEu);
      }
    }

    else
    {
      id v140 = (os_log_s *)qword_1008F75A0;
      if (os_log_type_enabled((os_log_t)qword_1008F75A0, OS_LOG_TYPE_DEFAULT))
      {
        uint64_t v141 = sub_1002E6E00();
        int v142 = (*(uint64_t (**)(uint64_t))(*(void *)v141 + 8LL))(v141);
        *(_DWORD *)__int128 buf = 67109632;
        *(_DWORD *)&uint8_t buf[4] = v142;
        *(_WORD *)&uint8_t buf[8] = 1024;
        *(_DWORD *)&buf[10] = BYTE3(data);
        *(_WORD *)&buf[14] = 1024;
        *(_DWORD *)&_WORD buf[16] = BYTE8(v265);
        _os_log_impl( (void *)&_mh_execute_header,  v140,  OS_LOG_TYPE_DEFAULT,  "Identification - clearing LE friendly name: internal %d, le hid service present %d, le ghs service present %d",  buf,  0x14u);
      }

      if (SBYTE7(v265) < 0) {
        operator delete((void *)v264);
      }
      __int128 v264 = 0uLL;
      *(void *)&__int128 v265 = 0LL;
    }

    if (qword_1008D5F30 != -1) {
      dispatch_once(&qword_1008D5F30, &stru_1008A3498);
    }
    uint64_t v143 = off_1008D5F28;
    sub_10002418C(v154, "LeIdentificationHashExist");
    sub_1005CCF08((uint64_t)v143, v153, (unsigned __int8 *)v154);
    if (v155 < 0) {
      operator delete(v154[0]);
    }
    *((_BYTE *)v4 + 357) = 1;
    int v144 = (void *)objc_claimAutoreleasedReturnValue( +[NSData dataWithBytes:length:]( &OBJC_CLASS___NSData,  "dataWithBytes:length:",  (char *)&v263[1] + 8,  20LL,  v262));
    objc_storeStrong((id *)v4 + 45, v144);

    sub_100242F54((uint64_t)v169);
    uint64_t v145 = sub_1002E8D94();
    (*(void (**)(uint64_t, __int128 *))(*(void *)v145 + 224LL))(v145, &data);
    sub_100242CD8(&v157);

    uint64_t v22 = 0LL;
    id v3 = v153;
  }

  else
  {
    uint64_t v33 = (os_log_s *)qword_1008F75A0;
    if (os_log_type_enabled((os_log_t)qword_1008F75A0, OS_LOG_TYPE_DEFAULT))
    {
      *(_WORD *)__int128 buf = 0;
      _os_log_impl( (void *)&_mh_execute_header,  v33,  OS_LOG_TYPE_DEFAULT,  "Identification - DI not yet completed, returning",  buf,  2u);
    }

    uint64_t v22 = 4LL;
  }

void sub_1005DB9B8( _Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, void *a18, uint64_t a19, uint64_t a20, uint64_t a21, uint64_t a22, uint64_t a23, uint64_t a24, uint64_t a25, uint64_t a26, uint64_t a27, uint64_t a28, uint64_t a29, uint64_t a30, uint64_t a31, void *__p, uint64_t a33, uint64_t a34, void *a35, uint64_t a36, uint64_t a37, uint64_t a38, char a39)
{
  if (__p) {
    operator delete(__p);
  }
  if (a35) {
    operator delete(a35);
  }
  sub_100328B0C((uint64_t)&STACK[0x2F0]);
  sub_100242FAC((uint64_t)&a39);

  _Unwind_Resume(a1);
}

uint64_t sub_1005DBB20(uint64_t a1)
{
  uint64_t v1 = a1;
  v45[0] = 0LL;
  v45[1] = 0LL;
  sub_100242F28((uint64_t)v45, a1 + 80);
  id v2 = (os_log_s *)qword_1008F75A0;
  if (os_log_type_enabled((os_log_t)qword_1008F75A0, OS_LOG_TYPE_DEFAULT))
  {
    *(_WORD *)__int128 buf = 0;
    _os_log_impl( (void *)&_mh_execute_header,  v2,  OS_LOG_TYPE_DEFAULT,  "statedump: ------------------ LE Device Manager -------------------",  buf,  2u);
  }

  *(void *)__int128 buf = 0LL;
  sub_1000B0400((uint64_t)buf);
  id v3 = (os_log_s *)qword_1008F75A0;
  if (os_log_type_enabled((os_log_t)qword_1008F75A0, OS_LOG_TYPE_DEFAULT))
  {
    *(_WORD *)__int128 buf = 0;
    _os_log_impl((void *)&_mh_execute_header, v3, OS_LOG_TYPE_DEFAULT, "statedump: Devices:", buf, 2u);
  }

  v44[0] = 0LL;
  v44[1] = 0LL;
  id v43 = (uint64_t *)v44;
  __int128 v39 = 0u;
  __int128 v40 = 0u;
  __int128 v41 = 0u;
  __int128 v42 = 0u;
  id obj = *(id *)(v1 + 160);
  id v4 = [obj countByEnumeratingWithState:&v39 objects:v65 count:16];
  if (v4)
  {
    uint64_t v5 = *(void *)v40;
    uint64_t v29 = *(void *)v40;
    uint64_t v30 = v1;
    do
    {
      uint64_t v6 = 0LL;
      id v31 = v4;
      do
      {
        if (*(void *)v40 != v5) {
          objc_enumerationMutation(obj);
        }
        id v7 = *(void **)(*((void *)&v39 + 1) + 8LL * (void)v6);
        __int128 v8 = (unsigned __int8 *)[*(id *)(v1 + 160) objectForKey:v7];
        __int128 v38 = *((_OWORD *)v8 + 15);
        LODWORD(v37.__r_.__value_.__l.__data_) = sub_1005CE2FC(v1, v7);
        *(void *)__int128 buf = &v37;
        __int16 v9 = *((_WORD *)sub_1005BC550(&v43, (unsigned int *)&v37, (uint64_t)&unk_1006C2518, (_DWORD **)buf) + 16);
        LODWORD(v37.__r_.__value_.__l.__data_) = *((_DWORD *)v8 + 93);
        *(void *)__int128 buf = &v37;
        *((_WORD *)sub_1005BC550(&v43, (unsigned int *)&v37, (uint64_t)&unk_1006C2518, (_DWORD **)buf) + 16) = v9 + 1;
        uint64_t v10 = qword_1008F75A0;
        if (os_log_type_enabled((os_log_t)qword_1008F75A0, OS_LOG_TYPE_DEFAULT))
        {
          sub_1005C4850((uint64_t)v8, &v37);
          if ((v37.__r_.__value_.__s.__size_ & 0x80u) == 0) {
            __int16 v11 = &v37;
          }
          else {
            __int16 v11 = (std::stringbuf::string_type *)v37.__r_.__value_.__r.__words[0];
          }
          sub_1005BBFF8((unint64_t *)&v38, &v36);
          log = (os_log_s *)v10;
          if ((v36.__r_.__value_.__s.__size_ & 0x80u) == 0) {
            __int128 v12 = &v36;
          }
          else {
            __int128 v12 = (std::stringbuf::string_type *)v36.__r_.__value_.__r.__words[0];
          }
          int v13 = v8[358];
          int v14 = *((_DWORD *)v8 + 93);
          int v15 = v8[355];
          int v16 = v8[356];
          int v33 = v8[488];
          unsigned int v17 = sub_1005C37F4((uint64_t)v8);
          __int128 v18 = sub_1005C37D0(v17);
          sub_1005C40CC((uint64_t)v8, &__p);
          p_p = &__p;
          if ((__p.__r_.__value_.__s.__size_ & 0x80u) != 0) {
            p_p = (std::stringbuf::string_type *)__p.__r_.__value_.__r.__words[0];
          }
          *(_DWORD *)__int128 buf = 138545667;
          *(void *)&uint8_t buf[4] = v7;
          __int16 v47 = 2082;
          uint64_t v48 = v11;
          __int16 v49 = 2082;
          uint64_t v50 = v12;
          __int16 v51 = 1024;
          int v52 = v13;
          __int16 v53 = 1024;
          int v54 = v14;
          __int16 v55 = 1024;
          int v56 = v15;
          __int16 v57 = 1024;
          int v58 = v16;
          __int16 v59 = 1024;
          int v60 = v33;
          __int16 v61 = 2080;
          uint64_t v62 = v18;
          __int16 v63 = 2081;
          int v64 = p_p;
          _os_log_impl( (void *)&_mh_execute_header,  log,  OS_LOG_TYPE_DEFAULT,  "statedump:    %{public}@  %{public}s (added to WL %{public}s ago) disableDisconnect:%d useCase:%d scanDutyC ycle screenON:%d screenOFF:%d pendingDelete:%d type:%s FindMy:%{private}s ",  buf,  0x52u);
          uint64_t v5 = v29;
          uint64_t v1 = v30;
          id v4 = v31;
        }

        uint64_t v6 = (char *)v6 + 1;
      }

      while (v4 != v6);
      id v4 = [obj countByEnumeratingWithState:&v39 objects:v65 count:16];
    }

    while (v4);
  }

  __int128 v20 = (os_log_s *)qword_1008F75A0;
  if (os_log_type_enabled((os_log_t)qword_1008F75A0, OS_LOG_TYPE_DEFAULT))
  {
    *(_WORD *)__int128 buf = 0;
    _os_log_impl((void *)&_mh_execute_header, v20, OS_LOG_TYPE_DEFAULT, "statedump:    useCase map:", buf, 2u);
  }

  __int128 v21 = v43;
  if (v43 != (uint64_t *)v44)
  {
    uint64_t v22 = (os_log_s *)qword_1008F75A0;
    do
    {
      if (os_log_type_enabled(v22, OS_LOG_TYPE_DEFAULT))
      {
        __int128 v23 = sub_1005D2CC4(*((_DWORD *)v21 + 7));
        int v24 = *((unsigned __int16 *)v21 + 16);
        *(_DWORD *)__int128 buf = 136446466;
        *(void *)&uint8_t buf[4] = v23;
        __int16 v47 = 1024;
        LODWORD(v48) = v24;
        _os_log_impl( (void *)&_mh_execute_header,  v22,  OS_LOG_TYPE_DEFAULT,  "statedump:    \tuseCase:%{public}s count:%d",  buf,  0x12u);
        uint64_t v22 = (os_log_s *)qword_1008F75A0;
      }

      unint64_t v25 = (uint64_t *)v21[1];
      if (v25)
      {
        do
        {
          __int16 v26 = v25;
          unint64_t v25 = (uint64_t *)*v25;
        }

        while (v25);
      }

      else
      {
        do
        {
          __int16 v26 = (uint64_t *)v21[2];
          BOOL v27 = *v26 == (void)v21;
          __int128 v21 = v26;
        }

        while (!v27);
      }

      __int128 v21 = v26;
    }

    while (v26 != (uint64_t *)v44);
  }

  sub_1002DD04C(*(void *)(v1 + 240));
  sub_10023BF24((uint64_t)&v43, v44[0]);
  return sub_100242FAC((uint64_t)v45);
}

void sub_1005DC01C( _Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20, uint64_t a21, uint64_t a22, uint64_t a23, uint64_t a24, void *__p, uint64_t a26, int a27, __int16 a28, char a29, char a30, void *a31, uint64_t a32, int a33, __int16 a34, char a35, char a36, uint64_t a37, uint64_t a38, uint64_t a39, uint64_t a40, uint64_t a41, uint64_t a42, uint64_t a43, uint64_t a44, uint64_t a45, uint64_t a46, uint64_t a47, char a48, void *a49, uint64_t a50,char a51)
{
}

uint64_t sub_1005DC0A8(uint64_t a1)
{
  v18[0] = 0LL;
  v18[1] = 0LL;
  sub_100242F28((uint64_t)v18, a1 + 80);
  __int128 v21 = 0uLL;
  __int128 v14 = 0u;
  __int128 v15 = 0u;
  __int128 v16 = 0u;
  __int128 v17 = 0u;
  id v2 = *(id *)(a1 + 160);
  id v3 = [v2 countByEnumeratingWithState:&v14 objects:v20 count:16];
  if (v3)
  {
    uint64_t v4 = *(void *)v15;
    do
    {
      for (uint64_t i = 0LL; i != v3; uint64_t i = (char *)i + 1)
      {
        if (*(void *)v15 != v4) {
          objc_enumerationMutation(v2);
        }
        uint64_t v6 = *(void **)(*((void *)&v14 + 1) + 8LL * (void)i);
        id v7 = (char *)objc_msgSend(*(id *)(a1 + 160), "objectForKey:", v6, __p[0], __p[1], v12, v13, (void)v14);
        __int128 v19 = 0uLL;
        [v6 getUUIDBytes:&v19];
        __int128 v21 = v19;
        if (v7[164])
        {
          *(_DWORD *)((char *)&v13 + 3) = 0;
          LODWORD(v13) = 0;
          uint64_t v8 = sub_1001BCDB0(*((void *)v7 + 3));
          LODWORD(v13) = v8;
          BYTE6(v13) = BYTE6(v8);
          WORD2(v13) = WORD2(v8);
          if (v7[127] < 0)
          {
            sub_100024238(__p, *((void **)v7 + 13), *((void *)v7 + 14));
          }

          else
          {
            *(_OWORD *)std::stringbuf::string_type __p = *(_OWORD *)(v7 + 104);
            uint64_t v12 = *((void *)v7 + 15);
          }

          if (v12 >= 0) {
            __int16 v9 = (char *)__p;
          }
          else {
            __int16 v9 = (char *)__p[0];
          }
          sub_1000BACA0(&v13, v9, &v21);
          if (SHIBYTE(v12) < 0) {
            operator delete(__p[0]);
          }
        }
      }

      id v3 = [v2 countByEnumeratingWithState:&v14 objects:v20 count:16];
    }

    while (v3);
  }

  return sub_100242FAC((uint64_t)v18);
}

void sub_1005DC26C( _Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, void *__p, uint64_t a10, int a11, __int16 a12, char a13, char a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20, uint64_t a21, uint64_t a22, uint64_t a23, char a24)
{
  sub_100242FAC((uint64_t)&a24);
  _Unwind_Resume(a1);
}

uint64_t sub_1005DC2BC(uint64_t a1, uint64_t a2)
{
  v5[0] = 0LL;
  v5[1] = 0LL;
  sub_100242F28((uint64_t)v5, a1 + 80);
  sub_1005DC31C(a1 + 256, a2);
  return sub_100242FAC((uint64_t)v5);
}

void sub_1005DC308( _Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9)
{
}

void sub_1005DC31C(uint64_t a1, uint64_t a2)
{
  uint64_t v5 = *(char **)(a1 + 8);
  uint64_t v4 = *(char **)(a1 + 16);
  if (v5 != v4)
  {
    while (*(void *)v5 != a2)
    {
      v5 += 8;
      if (v5 == v4)
      {
        uint64_t v5 = *(char **)(a1 + 16);
        break;
      }
    }
  }

  if (v5 == v4)
  {
    uint64_t v6 = a2;
    sub_1005DD3AC(a1 + 8, v4, (char *)&v6);
    sub_100008A30(a1 + 8);
  }

  os_unfair_lock_unlock((os_unfair_lock_t)a1);
}

void sub_1005DC3A4(os_unfair_lock_s *a1, void *a2)
{
  id v3 = a2;
  os_unfair_lock_lock(a1);
  uint64_t v5 = 0LL;
  uint64_t v6 = 0LL;
  uint64_t v7 = 0LL;
  sub_100240540(&v5, (uint64_t)&a1[2]);
  os_unfair_lock_unlock(a1);
  uint64_t v4 = v5;
  if (v5 != v6)
  {
    do
      v3[2](v3, *v4++);
    while (v4 != v6);
    uint64_t v4 = v5;
  }

  if (v4)
  {
    uint64_t v6 = v4;
    operator delete(v4);
  }
}

void sub_1005DC438( _Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void *__p, uint64_t a11)
{
  _Unwind_Resume(a1);
}

uint64_t sub_1005DC460(uint64_t a1)
{
  *(void *)a1 = off_1008A3120;
  *(void *)(a1 + 8) = off_1008A31C8;
  *(void *)(a1 + 16) = off_1008A31E8;
  *(void *)(a1 + 24) = off_1008A3210;
  *(void *)(a1 + 32) = &off_1008A3240;
  *(void *)(a1 + 40) = &off_1008A3258;
  *(void *)(a1 + 48) = &off_1008A3270;
  *(void *)(a1 + 56) = &off_1008A3288;
  *(void *)(a1 + 64) = &off_1008A32A0;
  id v2 = *(void **)(a1 + 264);
  if (v2)
  {
    *(void *)(a1 + 272) = v2;
    operator delete(v2);
  }

  sub_10023BF24(a1 + 216, *(void **)(a1 + 224));
  sub_10023DF50((void *)(a1 + 192));
  sub_10023BF24(a1 + 168, *(void **)(a1 + 176));

  sub_100242E28(a1 + 80);
  return a1;
}

void sub_1005DC504(char *a1)
{
  *(void *)a1 = off_1008A3120;
  *((void *)a1 + 1) = off_1008A31C8;
  *((void *)a1 + 2) = off_1008A31E8;
  *((void *)a1 + 3) = off_1008A3210;
  *((void *)a1 + 4) = &off_1008A3240;
  *((void *)a1 + 5) = &off_1008A3258;
  *((void *)a1 + 6) = &off_1008A3270;
  *((void *)a1 + 7) = &off_1008A3288;
  *((void *)a1 + 8) = &off_1008A32A0;
  id v2 = (void *)*((void *)a1 + 33);
  if (v2)
  {
    *((void *)a1 + 34) = v2;
    operator delete(v2);
  }

  sub_10023BF24((uint64_t)(a1 + 216), *((void **)a1 + 28));
  sub_10023DF50((void *)a1 + 24);
  sub_10023BF24((uint64_t)(a1 + 168), *((void **)a1 + 22));

  sub_100242E28(a1 + 80);
  operator delete(a1);
}

uint64_t sub_1005DC5C8(uint64_t a1)
{
  id v2 = *(void **)(a1 + 584);
  if (v2)
  {
    *(void *)(a1 + 592) = v2;
    operator delete(v2);
  }

  sub_10023E78C(a1 + 176, *(char **)(a1 + 184));
  return a1;
}

char *sub_1005DC6E4(void *a1, char *__src, char *a3)
{
  id v3 = a3;
  uint64_t v4 = __src;
  uint64_t v6 = (char *)a1[1];
  unint64_t v7 = a1[2];
  if ((unint64_t)v6 >= v7)
  {
    uint64_t v10 = (char *)*a1;
    uint64_t v11 = (uint64_t)&v6[-*a1 + 1];
    if (v11 < 0) {
      abort();
    }
    uint64_t v12 = __src - v10;
    unint64_t v13 = v7 - (void)v10;
    if (2 * v13 > v11) {
      uint64_t v11 = 2 * v13;
    }
    if (v13 >= 0x3FFFFFFFFFFFFFFFLL) {
      size_t v14 = 0x7FFFFFFFFFFFFFFFLL;
    }
    else {
      size_t v14 = v11;
    }
    if (v14) {
      __int128 v15 = (char *)operator new(v14);
    }
    else {
      __int128 v15 = 0LL;
    }
    __int128 v16 = &v15[v12];
    __int128 v17 = &v15[v14];
    if (v12 == v14)
    {
      if (v12 < 1)
      {
        else {
          size_t v19 = 2 * v12;
        }
        __int128 v20 = (char *)operator new(v19);
        __int128 v16 = &v20[v19 >> 2];
        __int128 v17 = &v20[v19];
        if (v15)
        {
          operator delete(v15);
          uint64_t v10 = (char *)*a1;
        }
      }

      else
      {
        if (v12 + 1 >= 0) {
          uint64_t v18 = v12 + 1;
        }
        else {
          uint64_t v18 = v12 + 2;
        }
        v16 -= v18 >> 1;
      }
    }

    char *v16 = *v3;
    __int128 v21 = v16;
    if (v10 != v4)
    {
      uint64_t v22 = v4;
      __int128 v21 = v16;
      do
      {
        char v23 = *--v22;
        *--__int128 v21 = v23;
      }

      while (v22 != v10);
    }

    int v24 = (_BYTE *)a1[1];
    uint64_t v25 = v24 - v4;
    if (v24 != v4) {
      memmove(v16 + 1, v4, v24 - v4);
    }
    __int16 v26 = (char *)*a1;
    *a1 = v21;
    a1[1] = &v16[v25 + 1];
    a1[2] = v17;
    if (v26) {
      operator delete(v26);
    }
    return v16;
  }

  else if (__src == v6)
  {
    *__src = *a3;
    a1[1] = __src + 1;
  }

  else
  {
    uint64_t v8 = __src + 1;
    if (v6)
    {
      *uint64_t v6 = *(v6 - 1);
      __int16 v9 = v6 + 1;
    }

    else
    {
      __int16 v9 = 0LL;
    }

    a1[1] = v9;
    if (v6 != v8) {
      memmove(__src + 1, __src, v6 - v8);
    }
    *uint64_t v4 = *v3;
  }

  return v4;
}

void sub_1005DC8C8(_Unwind_Exception *exception_object)
{
  if (v1) {
    operator delete(v1);
  }
  _Unwind_Resume(exception_object);
}

void sub_1005DC8E0(id a1)
{
  uint64_t v1 = operator new(0x1A0uLL);
  sub_1002769A4();
  off_1008D67C0 = v1;
}

void sub_1005DC910(_Unwind_Exception *a1)
{
}

void sub_1005DC924(id a1)
{
  uint64_t v1 = operator new(0x618uLL);
  sub_10058B0A4();
  off_1008D5F08 = v1;
}

void sub_1005DC954(_Unwind_Exception *a1)
{
}

uint64_t *sub_1005DC968(uint64_t *a1, uint64_t a2)
{
  a1[2] = 0LL;
  a1[1] = 0LL;
  *a1 = (uint64_t)(a1 + 1);
  sub_1005DC9BC(a1, *(unsigned __int8 **)a2, (unsigned __int8 *)(a2 + 8));
  return a1;
}

void sub_1005DC9A4(_Unwind_Exception *a1)
{
}

uint64_t *sub_1005DC9BC(uint64_t *result, unsigned __int8 *a2, unsigned __int8 *a3)
{
  if (a2 != a3)
  {
    uint64_t v4 = a2;
    uint64_t v5 = (uint64_t **)result;
    uint64_t v6 = result + 1;
    do
    {
      uint64_t result = sub_1005DCA40(v5, v6, v4 + 25, v4 + 25);
      unint64_t v7 = (unsigned __int8 *)*((void *)v4 + 1);
      if (v7)
      {
        do
        {
          uint64_t v8 = v7;
          unint64_t v7 = *(unsigned __int8 **)v7;
        }

        while (v7);
      }

      else
      {
        do
        {
          uint64_t v8 = (unsigned __int8 *)*((void *)v4 + 2);
          BOOL v9 = *(void *)v8 == (void)v4;
          uint64_t v4 = v8;
        }

        while (!v9);
      }

      uint64_t v4 = v8;
    }

    while (v8 != a3);
  }

  return result;
}

uint64_t *sub_1005DCA40(uint64_t **a1, uint64_t *a2, unsigned __int8 *uu2, const unsigned __int8 *a4)
{
  uint64_t v9 = 0LL;
  uint64_t v10 = 0LL;
  uint64_t v6 = (uint64_t **)sub_1005DCACC(a1, a2, &v10, &v9, uu2);
  uint64_t result = *v6;
  if (!*v6)
  {
    memset(v8, 0, sizeof(v8));
    sub_1005BCE04((uint64_t)a1, a4, v8);
    sub_100029630(a1, (uint64_t)v10, v6, (uint64_t *)v8[0]);
    return (uint64_t *)v8[0];
  }

  return result;
}

const unsigned __int8 *sub_1005DCACC( void *a1, uint64_t *a2, const unsigned __int8 **a3, uint64_t *a4, unsigned __int8 *uu2)
{
  uint64_t v9 = (const unsigned __int8 *)(a1 + 1);
  if (a1 + 1 == a2 || uuid_compare(uu2, (const unsigned __int8 *)a2 + 25) < 0)
  {
    if ((uint64_t *)*a1 == a2)
    {
      uint64_t v12 = (const unsigned __int8 *)a2;
    }

    else
    {
      uint64_t v11 = (const unsigned __int8 *)*a2;
      if (*a2)
      {
        do
        {
          uint64_t v12 = v11;
          uint64_t v11 = (const unsigned __int8 *)*((void *)v11 + 1);
        }

        while (v11);
      }

      else
      {
        __int128 v16 = a2;
        do
        {
          uint64_t v12 = (const unsigned __int8 *)v16[2];
          BOOL v17 = *(void *)v12 == (void)v16;
          __int128 v16 = (uint64_t *)v12;
        }

        while (v17);
      }

      if ((uuid_compare(v12 + 25, uu2) & 0x80000000) == 0) {
        return (const unsigned __int8 *)sub_1005BCD74((uint64_t)a1, a3, uu2);
      }
    }

    if (*a2)
    {
      *a3 = v12;
      return v12 + 8;
    }

    else
    {
      *a3 = (const unsigned __int8 *)a2;
      return (const unsigned __int8 *)a2;
    }
  }

  if (uuid_compare((const unsigned __int8 *)a2 + 25, uu2) < 0)
  {
    a4 = a2 + 1;
    uint64_t v13 = a2[1];
    if (v13)
    {
      size_t v14 = (const unsigned __int8 *)a2[1];
      do
      {
        __int128 v15 = v14;
        size_t v14 = *(const unsigned __int8 **)v14;
      }

      while (v14);
    }

    else
    {
      size_t v19 = (const unsigned __int8 *)a2;
      do
      {
        __int128 v15 = (const unsigned __int8 *)*((void *)v19 + 2);
        BOOL v17 = *(void *)v15 == (void)v19;
        size_t v19 = v15;
      }

      while (!v17);
    }

    if (v15 == v9) {
      goto LABEL_27;
    }
    if (uuid_compare(uu2, v15 + 25) < 0)
    {
      uint64_t v13 = *a4;
LABEL_27:
      if (v13)
      {
        *a3 = v15;
        return v15;
      }

      else
      {
        *a3 = (const unsigned __int8 *)a2;
      }

      return (const unsigned __int8 *)a4;
    }

    return (const unsigned __int8 *)sub_1005BCD74((uint64_t)a1, a3, uu2);
  }

  *a3 = (const unsigned __int8 *)a2;
  *a4 = (uint64_t)a2;
  return (const unsigned __int8 *)a4;
}

void sub_1005DCC50(id a1)
{
  uint64_t v1 = operator new(0x128uLL);
  sub_1005C60A8((uint64_t)v1);
  off_1008D5F28 = v1;
}

void sub_1005DCC80(_Unwind_Exception *a1)
{
}

void sub_1005DCC94(id a1)
{
  uint64_t v1 = operator new(0x120uLL);
  sub_100495250();
  qword_1008D61A0 = (uint64_t)v1;
}

void sub_1005DCCC4(_Unwind_Exception *a1)
{
}

void sub_1005DCCD8(id a1)
{
  uint64_t v1 = operator new(0xEB0uLL);
  sub_10061991C();
  qword_1008D5F18 = (uint64_t)v1;
}

void sub_1005DCD08(_Unwind_Exception *a1)
{
}

void sub_1005DCD1C(id a1)
{
  uint64_t v1 = operator new(0x230uLL);
  sub_10042BC28();
  off_1008D60A8 = v1;
}

void sub_1005DCD4C(_Unwind_Exception *a1)
{
}

void sub_1005DCD60(id a1)
{
  uint64_t v1 = (char *)operator new(0x200uLL);
  *(void *)uint64_t v1 = off_100898F60;
  *((void *)v1 + 1) = &off_100898FF0;
  *((void *)v1 + 2) = off_100899008;
  *((void *)v1 + 3) = &off_100899060;
  *((void *)v1 + 4) = &off_100899078;
  sub_100242DC4(v1 + 40);
  *((void *)v1 + 14) = 0LL;
  *((_DWORD *)v1 + 30) = 0;
  *((void *)v1 + 17) = 0LL;
  *((void *)v1 + 18) = 0LL;
  *((void *)v1 + 16) = 0LL;
  *(_OWORD *)(v1 + 155) = 0u;
  *(_OWORD *)(v1 + 171) = 0u;
  *(_OWORD *)(v1 + 187) = 0u;
  *(_WORD *)(v1 + 203) = 1;
  *((void *)v1 + 26) = 0LL;
  *((_WORD *)v1 + 108) = 256;
  *((void *)v1 + 29) = 0LL;
  *((void *)v1 + 28) = v1 + 232;
  *((void *)v1 + 32) = 0LL;
  *((void *)v1 + 33) = 0LL;
  *((void *)v1 + 30) = 0LL;
  *((void *)v1 + 31) = v1 + 256;
  v1[272] = 0;
  *((_DWORD *)v1 + 69) = 0;
  v1[280] = 0;
  *((_WORD *)v1 + 189) = 0;
  *(void *)(v1 + 313) = 0LL;
  *(_OWORD *)(v1 + 300) = 0u;
  *(_OWORD *)(v1 + 284) = 0u;
  *(_OWORD *)(v1 + 328) = 0u;
  *(_OWORD *)(v1 + 344) = 0u;
  *(_OWORD *)(v1 + 360) = 0u;
  v1[376] = 0;
  *((void *)v1 + 51) = v1 + 416;
  *((void *)v1 + 52) = 0LL;
  *((void *)v1 + 55) = 0LL;
  *((void *)v1 + 56) = 0LL;
  *((void *)v1 + 53) = 0LL;
  *((void *)v1 + 54) = v1 + 440;
  *((void *)v1 + 57) = v1 + 464;
  *((void *)v1 + 58) = 0LL;
  *((void *)v1 + 59) = 0LL;
  *((void *)v1 + 60) = @"XZ";
  *((void *)v1 + 62) = 0LL;
  *((_DWORD *)v1 + 126) = 0;
  off_1008D6190 = v1;
}

void sub_1005DCE68(_Unwind_Exception *a1)
{
}

void sub_1005DCE7C(id a1)
{
  uint64_t v1 = operator new(0x18uLL);
  *(void *)uint64_t v1 = 0LL;
  v1[2] = 0;
  *((_BYTE *)v1 + 12) = 0;
  v1[4] = 0;
  qword_1008D9058 = (uint64_t)v1;
}

uint64_t *sub_1005DCEAC(uint64_t a1, unint64_t *a2, uint64_t a3, void **a4)
{
  uint64_t v6 = (uint64_t **)(a1 + 8);
  uint64_t v5 = *(uint64_t **)(a1 + 8);
  if (v5)
  {
    unint64_t v7 = *a2;
    while (1)
    {
      while (1)
      {
        uint64_t v8 = (uint64_t **)v5;
        unint64_t v9 = v5[4];
        if (v7 >= v9) {
          break;
        }
        uint64_t v5 = *v8;
        uint64_t v6 = v8;
        if (!*v8) {
          goto LABEL_10;
        }
      }

      if (v9 >= v7) {
        break;
      }
      uint64_t v5 = v8[1];
      if (!v5)
      {
        uint64_t v6 = v8 + 1;
        goto LABEL_10;
      }
    }
  }

  else
  {
    uint64_t v8 = (uint64_t **)(a1 + 8);
LABEL_10:
    memset(v11, 0, sizeof(v11));
    sub_1005DCF6C(a1, a4, v11);
    sub_100029630((uint64_t **)a1, (uint64_t)v8, v6, v11[0]);
    return v11[0];
  }

  return (uint64_t *)v8;
}

void sub_1005DCF6C(uint64_t a1@<X0>, void **a2@<X2>, void *a3@<X8>)
{
  uint64_t v5 = a1 + 8;
  *a3 = 0LL;
  a3[1] = 0LL;
  a3[2] = 0LL;
  uint64_t v6 = operator new(0x38uLL);
  *a3 = v6;
  a3[1] = v5;
  *((_BYTE *)a3 + 16) = 0;
  *((void *)v6 + 4) = **a2;
  uuid_clear((unsigned __int8 *)v6 + 40);
  *((_BYTE *)a3 + 16) = 1;
}

void sub_1005DCFD0(_Unwind_Exception *a1)
{
  void *v1 = 0LL;
  operator delete(v2);
  _Unwind_Resume(a1);
}

void *sub_1005DCFE8(uint64_t a1, uint64_t a2, uint64_t a3, const unsigned __int8 *a4)
{
  unint64_t v7 = operator new(0x20uLL);
  *(void *)unint64_t v7 = a2;
  *((void *)v7 + 1) = a3;
  uuid_copy((unsigned __int8 *)v7 + 16, a4);
  return v7;
}

void sub_1005DD030(_Unwind_Exception *a1)
{
}

void sub_1005DD044(id a1)
{
  uint64_t v1 = operator new(0x138uLL);
  sub_1003FE3E0((uint64_t)v1);
  off_1008D5F48 = v1;
}

void sub_1005DD074(_Unwind_Exception *a1)
{
}

uint64_t sub_1005DD088(uint64_t a1, unint64_t *a2, uint64_t a3)
{
  *(void *)(a1 + 8) = 0LL;
  uint64_t v4 = (void *)(a1 + 8);
  *(void *)(a1 + 16) = 0LL;
  *(void *)a1 = a1 + 8;
  if (a3)
  {
    uint64_t v6 = 8 * a3;
    do
    {
      sub_1002BBA70((uint64_t **)a1, v4, a2, (uint64_t *)a2);
      ++a2;
      v6 -= 8LL;
    }

    while (v6);
  }

  return a1;
}

void sub_1005DD0EC(_Unwind_Exception *a1)
{
}

void sub_1005DD104(uint64_t a1, void *a2)
{
  if (a2)
  {
    sub_1005DD104(a1, *a2);
    sub_1005DD104(a1, a2[1]);
    sub_1005DD14C((uint64_t)(a2 + 4));
    operator delete(a2);
  }

void sub_1005DD14C(uint64_t a1)
{
}

uint64_t *sub_1005DD190(uint64_t **a1, const void **a2, uint64_t a3, __int128 **a4)
{
  uint64_t v11 = 0LL;
  uint64_t v6 = (uint64_t **)sub_10023E6A4((uint64_t)a1, &v11, a2);
  unint64_t v7 = *v6;
  if (!*v6)
  {
    uint64_t v8 = v6;
    memset(v10, 0, sizeof(v10));
    sub_1005DD244((uint64_t)a1, a4, v10);
    sub_100029630(a1, v11, v8, v10[0]);
    unint64_t v7 = v10[0];
    v10[0] = 0LL;
    sub_1005DD2E0((uint64_t)v10, 0LL);
  }

  return v7;
}

_BYTE *sub_1005DD244@<X0>(uint64_t a1@<X0>, __int128 **a2@<X2>, void *a3@<X8>)
{
  uint64_t v5 = a1 + 8;
  *a3 = 0LL;
  a3[1] = 0LL;
  a3[2] = 0LL;
  uint64_t v6 = operator new(0x50uLL);
  *a3 = v6;
  a3[1] = v5;
  *((_BYTE *)a3 + 16) = 0;
  uint64_t result = v6 + 4;
  uint64_t v8 = *a2;
  if (*((char *)*a2 + 23) < 0)
  {
    uint64_t result = sub_100024238(result, *(void **)v8, *((void *)v8 + 1));
  }

  else
  {
    __int128 v9 = *v8;
    v6[6] = *((void *)v8 + 2);
    *(_OWORD *)uint64_t result = v9;
  }

  v6[7] = 0LL;
  v6[8] = 0LL;
  v6[9] = 0LL;
  *((_BYTE *)a3 + 16) = 1;
  return result;
}

void sub_1005DD2C8(_Unwind_Exception *a1)
{
}

void sub_1005DD2E0(uint64_t a1, uint64_t a2)
{
  id v2 = *(void **)a1;
  *(void *)a1 = a2;
  if (v2)
  {
    if (*(_BYTE *)(a1 + 16)) {
      sub_1005DD14C((uint64_t)v2 + 32);
    }
    operator delete(v2);
  }

void sub_1005DD324(id a1)
{
  uint64_t v1 = operator new(0x1128uLL);
  sub_1005DDADC();
  off_1008D6600 = v1;
}

void sub_1005DD354(_Unwind_Exception *a1)
{
}

void sub_1005DD368(id a1)
{
  uint64_t v1 = operator new(0x110uLL);
  sub_100551DD0();
  qword_1008D5F58 = (uint64_t)v1;
}

void sub_1005DD398(_Unwind_Exception *a1)
{
}

char *sub_1005DD3AC(uint64_t a1, char *__src, char *a3)
{
  id v3 = a3;
  uint64_t v4 = __src;
  uint64_t v6 = *(char **)(a1 + 8);
  uint64_t v8 = a1 + 16;
  unint64_t v7 = *(void *)(a1 + 16);
  if ((unint64_t)v6 >= v7)
  {
    uint64_t v13 = *(char **)a1;
    unint64_t v14 = ((uint64_t)&v6[-*(void *)a1] >> 3) + 1;
    if (v14 >> 61) {
      abort();
    }
    uint64_t v15 = __src - v13;
    uint64_t v16 = (__src - v13) >> 3;
    uint64_t v17 = v7 - (void)v13;
    if (v17 >> 2 > v14) {
      unint64_t v14 = v17 >> 2;
    }
    else {
      unint64_t v18 = v14;
    }
    uint64_t v30 = a1 + 16;
    if (v18) {
      size_t v19 = (char *)sub_100008BA0(a1 + 16, v18);
    }
    else {
      size_t v19 = 0LL;
    }
    __int128 v20 = &v19[8 * v16];
    std::stringbuf::string_type __p = v19;
    BOOL v27 = v20;
    uint64_t v28 = v20;
    uint64_t v29 = &v19[8 * v18];
    if (v16 == v18)
    {
      if (v15 < 1)
      {
        if (v13 == v4) {
          unint64_t v22 = 1LL;
        }
        else {
          unint64_t v22 = v15 >> 2;
        }
        char v23 = (char *)sub_100008BA0(v8, v22);
        __int128 v20 = &v23[8 * (v22 >> 2)];
        std::stringbuf::string_type __p = v23;
        BOOL v27 = v20;
        uint64_t v29 = &v23[8 * v24];
        if (v19) {
          operator delete(v19);
        }
      }

      else
      {
        unint64_t v21 = v16 + 2;
        if (v16 >= -1) {
          unint64_t v21 = v16 + 1;
        }
        v20 -= 8 * (v21 >> 1);
        BOOL v27 = v20;
      }
    }

    *(void *)__int128 v20 = *(void *)v3;
    uint64_t v28 = v20 + 8;
    uint64_t v4 = sub_100008ADC((void **)a1, (uint64_t)&__p, v4);
    if (v28 != v27) {
      v28 += (v27 - v28 + 7) & 0xFFFFFFFFFFFFFFF8LL;
    }
    if (__p) {
      operator delete(__p);
    }
  }

  else if (__src == v6)
  {
    *(void *)__src = *(void *)a3;
    *(void *)(a1 + 8) = __src + 8;
  }

  else
  {
    __int128 v9 = __src + 8;
    uint64_t v10 = v6 - 8;
    uint64_t v11 = *(void **)(a1 + 8);
    while (v10 < v6)
    {
      uint64_t v12 = *(void *)v10;
      v10 += 8;
      *v11++ = v12;
    }

    *(void *)(a1 + 8) = v11;
    if (v6 != v9) {
      memmove(&v6[-8 * ((v6 - v9) >> 3)], __src, v6 - v9);
    }
    if (v4 <= v3) {
      v3 += 8 * (*(void *)(a1 + 8) > (unint64_t)v3);
    }
    *(void *)uint64_t v4 = *(void *)v3;
  }

  return v4;
}

void sub_1005DD5B0( _Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void *__p, uint64_t a11, uint64_t a12)
{
  if (__p) {
    operator delete(__p);
  }
  _Unwind_Resume(exception_object);
}

uint64_t sub_1005DD5E8(uint64_t result, uint64_t a2, uint64_t a3, float a4)
{
  *(float *)a3 = a4;
  *(void *)(a3 + 4) = result;
  *(_WORD *)(a3 + 12) = 2114;
  *(void *)(a3 + 14) = a2;
  return result;
}

  ;
}

void sub_1005DD610()
{
}

void sub_1005DD618()
{
  for (uint64_t i = 0LL; i != -160; i -= 32LL)
  {
  }

void sub_1005DD65C()
{
  uint64_t v0 = objc_autoreleasePoolPush();
  uint64_t v1 = sub_10002418C(qword_1008F1D48, "CORSAIR HARPOON");
  *((_DWORD *)v1 + 6) = 454826846;
  sub_10002418C(v1 + 4, "CORSAIR IRONCLAW");
  dword_1008F1D80 = 454826828;
  sub_10002418C(&algn_1008F1D84[4], "DARK CORE RGB PRO SE");
  dword_1008F1DA0 = 461249308;
  sub_10002418C(&algn_1008F1DA4[4], "DARK CORE RGB PRO");
  dword_1008F1DC0 = 454826880;
  sub_10002418C(&algn_1008F1DC4[4], "KATAR PRO Wireless");
  dword_1008F1DE0 = 454826926;
  __cxa_atexit((void (*)(void *))sub_1005DD618, 0LL, (void *)&_mh_execute_header);
  objc_autoreleasePoolPop(v0);
}

void sub_1005DD748(_Unwind_Exception *a1)
{
}

uint64_t sub_1005DD75C(uint64_t a1)
{
  *(void *)a1 = &off_1008A3E80;
  *(void *)(a1 + 8) = off_1008A3EB8;
  *(void *)(a1 + 16) = &off_1008A29E8;
  *(void *)(a1 + 24) = &off_1008A2A18;
  *(void *)(a1 + 32) = &off_1008A2A60;
  *(void *)(a1 + 40) = &off_1008A2A30;
  *(void *)(a1 + 48) = off_1008A3F20;
  id v2 = (void *)(a1 + 56);
  sub_10002418C(&__p, "LeObserver");
  sub_10043C948(v2, &__p);
  *(void *)a1 = off_1008A3610;
  *(void *)(a1 + 8) = &off_1008A3708;
  *(void *)(a1 + 16) = off_1008A3770;
  *(void *)(a1 + 24) = &off_1008A37A0;
  *(void *)(a1 + 32) = off_1008A37B8;
  *(void *)(a1 + 40) = off_1008A3808;
  *(void *)(a1 + 48) = off_1008A3838;
  *(void *)(a1 + 56) = &off_1008A38E8;
  *(void *)(a1 + 112) = &off_1008A3900;
  *(void *)(a1 + 120) = &off_1008A3918;
  *(void *)(a1 + 128) = off_1008A3930;
  *(void *)(a1 + 136) = &off_1008A3960;
  *(void *)(a1 + 152) = 0LL;
  *(_BYTE *)(a1 + 1792) = 1;
  *(_OWORD *)(a1 + 1824) = 0u;
  *(_OWORD *)(a1 + 1800) = 0u;
  *(void *)(a1 + 1816) = a1 + 1824;
  *(_WORD *)(a1 + 1840) = 1;
  *(_BYTE *)(a1 + 1842) = 0;
  *(_DWORD *)(a1 + 1848) = -16777216;
  *(_BYTE *)(a1 + 1864) = 0;
  *(_DWORD *)(a1 + 1872) = 0;
  *(_OWORD *)(a1 + 1880) = 0u;
  *(void *)(a1 + 1928) = 0LL;
  *(_OWORD *)(a1 + 1912) = 0u;
  *(_OWORD *)(a1 + 1944) = 0u;
  *(_DWORD *)(a1 + 1852) = 0;
  *(void *)(a1 + 1896) = 0LL;
  *(_DWORD *)(a1 + 1904) = 0;
  *(void *)(a1 + 1936) = a1 + 1944;
  *(void *)(a1 + 1960) = 0LL;
  *(_OWORD *)(a1 + 2008) = 0u;
  *(void *)(a1 + 2000) = a1 + 2008;
  *(_OWORD *)(a1 + 2048) = 0u;
  *(_OWORD *)(a1 + 2024) = 0u;
  *(void *)(a1 + 2040) = a1 + 2048;
  *(_OWORD *)(a1 + 2072) = 0u;
  *(void *)(a1 + 2064) = a1 + 2072;
  *(_OWORD *)(a1 + 2088) = 0u;
  *(_BYTE *)(a1 + 2104) = 0;
  *(_OWORD *)(a1 + 2112) = 0u;
  *(void *)(a1 + 2128) = 300000LL;
  *(_BYTE *)(a1 + 2168) = 0;
  *(_OWORD *)(a1 + 2176) = 0u;
  *(_OWORD *)(a1 + 2192) = 0u;
  *(_OWORD *)(a1 + 2206) = 0u;
  *(_BYTE *)(a1 + 2244) = 1;
  *(_BYTE *)(a1 + 2247) = 0;
  *(_DWORD *)(a1 + 2292) = 0;
  *(void *)(a1 + 2344) = 0LL;
  *(_BYTE *)(a1 + 2352) = 0;
  *(void *)(a1 + 2272) = 0LL;
  *(_OWORD *)(a1 + 2256) = 0u;
  *(void *)(a1 + 3216) = 0x700000003LL;
  *(_BYTE *)(a1 + 3224) = 0;
  *(_BYTE *)(a1 + 3256) = 0;
  *(void *)(a1 + 3264) = 0LL;
  *(_BYTE *)(a1 + 4296) = 0;
  *(_OWORD *)(a1 + 4312) = 0u;
  *(void *)(a1 + 4304) = a1 + 4312;
  *(_OWORD *)(a1 + 4336) = 0u;
  *(void *)(a1 + 4328) = a1 + 4336;
  *(_BYTE *)(a1 + 4381) = 0;
  *(void *)(a1 + 4368) = 0LL;
  *(_OWORD *)(a1 + 4352) = 0u;
  *(_WORD *)(a1 + 4382) = 1;
  *(_WORD *)(a1 + 4385) = 1;
  uint64_t v3 = objc_claimAutoreleasedReturnValue(+[NSMutableSet set](&OBJC_CLASS___NSMutableSet, "set"));
  uint64_t v4 = *(void **)(a1 + 3264);
  *(void *)(a1 + 3264) = v3;

  return a1;
}

void sub_1005DD9EC( _Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, void *__p, uint64_t a14, int a15, __int16 a16, char a17, char a18, uint64_t a19)
{
  sub_10023BF24(v20, *(void **)(v19 + 4336));
  sub_10023BF24(v25, *(void **)(v19 + 4312));

  sub_100024304((void ***)&a19);
  sub_10060EF64(v26, *(void **)(v19 + 2072));
  sub_10023BF24(v21, *(void **)(v19 + 2048));
  sub_10060EED0(v23, *(void **)(v19 + 2008));
  sub_10023BF24(v22, *(void **)(v19 + 1944));
  uint64_t v28 = *(void **)(v19 + 1912);
  if (v28)
  {
    *(void *)(v19 + 1920) = v28;
    operator delete(v28);
  }

  uint64_t v29 = *v24;
  if (*v24)
  {
    *(void *)(v19 + 1888) = v29;
    operator delete(v29);
  }

  sub_10023BF24(a11, *(void **)(v19 + 1824));

  sub_10043CB0C(a12);
  _Unwind_Resume(a1);
}

void sub_1005DDAE0(uint64_t a1)
{
  if (qword_1008D67C8 != -1) {
    dispatch_once(&qword_1008D67C8, &stru_1008A4018);
  }
  sub_10057D000((uint64_t)off_1008D67C0 + 192, a1);
  if (qword_1008D60B0 != -1) {
    dispatch_once(&qword_1008D60B0, &stru_1008A4038);
  }
  sub_1001FC5E4((uint64_t)off_1008D60A8 + 80, a1 + 16);
  if (qword_1008D6198 != -1) {
    dispatch_once(&qword_1008D6198, &stru_1008A4058);
  }
  sub_100447B0C((uint64_t)off_1008D6190, a1 + 32);
  if (qword_1008D5F10 != -1) {
    dispatch_once(&qword_1008D5F10, &stru_1008A4078);
  }
  sub_100594810((uint64_t)off_1008D5F08, a1 + 48, 0);
  if (qword_1008D6628 != -1) {
    dispatch_once(&qword_1008D6628, &stru_1008A4098);
  }
  sub_100331D58(qword_1008D6620, a1 + 128);
  if (qword_1008D5F30 != -1) {
    dispatch_once(&qword_1008D5F30, &stru_1008A40B8);
  }
  sub_1005DC2BC((uint64_t)off_1008D5F28, a1 + 136);
  uint64_t v2 = sub_1002E8D54();
  sub_10060E0AC(v2 + 1128, a1 + 120);
  uint64_t v3 = sub_1002E8D54();
  sub_10060E39C(v3 + 1088, a1 + 112);
  uint64_t v4 = sub_1002E6BF0();
  if (((*(uint64_t (**)(uint64_t))(*(void *)v4 + 408LL))(v4) & 1) == 0)
  {
    uint64_t v5 = sub_1002E8D54();
    sub_1003CBF90(v5 + 728, a1 + 24);
  }

  uint64_t v6 = sub_1002E8D54();
  (*(void (**)(uint64_t, uint64_t))(*(void *)v6 + 152LL))(v6, a1 + 144);
  uint64_t v7 = sub_1002E6E00();
  *(_BYTE *)(a1 + 2168) = (*(uint64_t (**)(uint64_t, uint64_t))(*(void *)v7 + 768LL))(v7, a1 + 2176);
  uint64_t v8 = sub_1002E6E00();
  sub_10002418C(buf, "LE");
  sub_10002418C(__p, "EnableScanAgentPrints");
  v134 = (unsigned __int8 *)(a1 + 4381);
  int v9 = (*(uint64_t (**)(uint64_t, _BYTE *, void **, uint64_t))(*(void *)v8 + 72LL))(v8, buf, __p, a1 + 4385);
  if (v140 < 0) {
    operator delete(__p[0]);
  }
  if ((v142[3] & 0x80000000) != 0)
  {
    operator delete(*(void **)buf);
    if (!v9) {
      goto LABEL_23;
    }
  }

  else if (!v9)
  {
    goto LABEL_23;
  }

  uint64_t v10 = (os_log_s *)qword_1008F75B8;
  if (os_log_type_enabled((os_log_t)qword_1008F75B8, OS_LOG_TYPE_DEFAULT))
  {
    int v11 = *(unsigned __int8 *)(a1 + 4385);
    *(_DWORD *)__int128 buf = 67109120;
    *(_DWORD *)&uint8_t buf[4] = v11;
    _os_log_impl((void *)&_mh_execute_header, v10, OS_LOG_TYPE_DEFAULT, "fEnableDebugScanAgent is now %d", buf, 8u);
  }

LABEL_255:
  uint64_t v104 = sub_1002E6E00();
  sub_10002418C(buf, "SCANDEBUG");
  sub_10002418C(__p, "DebugScanConfigSequence");
  int v105 = (*(uint64_t (**)(uint64_t, _BYTE *, void **, char *))(*(void *)v104 + 72LL))( v104,  buf,  __p,  &byte_1008F1E9C);
  if (byte_1008F1E9C) {
    int v106 = v105;
  }
  else {
    int v106 = 0;
  }
  if (v140 < 0) {
    operator delete(__p[0]);
  }
  if ((v142[3] & 0x80000000) != 0)
  {
    operator delete(*(void **)buf);
    if (!v106) {
      goto LABEL_266;
    }
  }

  else if (!v106)
  {
    goto LABEL_266;
  }

  __int16 v107 = (os_log_s *)qword_1008F75B8;
  if (os_log_type_enabled((os_log_t)qword_1008F75B8, OS_LOG_TYPE_DEFAULT))
  {
    *(_WORD *)__int128 buf = 0;
    _os_log_impl((void *)&_mh_execute_header, v107, OS_LOG_TYPE_DEFAULT, "gSniffScanDebug is true", buf, 2u);
  }

LABEL_288:
  *(_WORD *)(a1 + 2246) = 0;
  uint64_t v116 = sub_1002E6E00();
  sub_10002418C(buf, "BLESCAN");
  sub_10002418C(__p, "forcePassiveScan");
  unsigned int v117 = (unsigned __int8 *)(a1 + 2246);
  if ((*(unsigned int (**)(uint64_t, _BYTE *, void **, uint64_t))(*(void *)v116 + 72LL))( v116,  buf,  __p,  a1 + 2246))
  {
    int v118 = *v117;
    if (v140 < 0) {
      operator delete(__p[0]);
    }
    if ((v142[3] & 0x80000000) != 0)
    {
      operator delete(*(void **)buf);
      if (!v118) {
        goto LABEL_305;
      }
    }

    else if (!v118)
    {
      goto LABEL_305;
    }

    uint64_t v119 = sub_1002E6E00();
    sub_10002418C(buf, "BLESCAN");
    sub_10002418C(__p, "forcePassiveScanEnable");
    (*(void (**)(uint64_t, _BYTE *, void **, uint64_t))(*(void *)v119 + 72LL))(v119, buf, __p, a1 + 2247);
    if (v140 < 0) {
      operator delete(__p[0]);
    }
    if ((v142[3] & 0x80000000) != 0) {
      operator delete(*(void **)buf);
    }
    size_t v120 = (os_log_s *)qword_1008F75B8;
    if (os_log_type_enabled((os_log_t)qword_1008F75B8, OS_LOG_TYPE_DEFAULT))
    {
      int v121 = *v117;
      int v122 = *(unsigned __int8 *)(a1 + 2247);
      *(_DWORD *)__int128 buf = 67109376;
      *(_DWORD *)&uint8_t buf[4] = v121;
      *(_WORD *)&uint8_t buf[8] = 1024;
      *(_DWORD *)&buf[10] = v122;
      _os_log_impl( (void *)&_mh_execute_header,  v120,  OS_LOG_TYPE_DEFAULT,  "Overriding BLE Scan Parameters to force passive scan to %d force to : %d",  buf,  0xEu);
    }
  }

  else
  {
    if (v140 < 0) {
      operator delete(__p[0]);
    }
    if ((v142[3] & 0x80000000) != 0) {
      operator delete(*(void **)buf);
    }
  }

LABEL_305:
  *(_BYTE *)(a1 + 2248) = 0;
  uint64_t v123 = sub_1002E6E00();
  sub_10002418C(buf, "BLESCAN");
  sub_10002418C(__p, "enableMatchingRuleAndAddressBatched");
  if ((*(unsigned int (**)(uint64_t, _BYTE *, void **, uint64_t))(*(void *)v123 + 72LL))( v123,  buf,  __p,  a1 + 2248))
  {
    int v124 = *(unsigned __int8 *)(a1 + 2248);
    if (v140 < 0) {
      operator delete(__p[0]);
    }
    if ((v142[3] & 0x80000000) != 0) {
      operator delete(*(void **)buf);
    }
    if (v124)
    {
      int v125 = (os_log_s *)qword_1008F75B8;
      if (os_log_type_enabled((os_log_t)qword_1008F75B8, OS_LOG_TYPE_DEFAULT))
      {
        *(_WORD *)__int128 buf = 0;
        _os_log_impl( (void *)&_mh_execute_header,  v125,  OS_LOG_TYPE_DEFAULT,  "Overriding BLE Scan Parameters to enable matching rules batched",  buf,  2u);
      }
    }
  }

  else
  {
    if (v140 < 0) {
      operator delete(__p[0]);
    }
    if ((v142[3] & 0x80000000) != 0) {
      operator delete(*(void **)buf);
    }
  }

  *(_OWORD *)(a1 + 2312) = 0u;
  *(_OWORD *)(a1 + 2328) = 0u;
  *(_OWORD *)(a1 + 2296) = 0u;
  *(void *)(a1 + 2280) = 0LL;
  *(void *)(a1 + 2712) = 0LL;
  *(_DWORD *)(a1 + 2719) = 0;
  sub_1005DF8A0(a1);
  sub_1005DF990(a1);
  *(void *)(a1 + 3208) = 0LL;
  sub_1005DFA44(a1);
  sub_1005DFAC0(a1);
  sub_1005DFC6C(a1);
  uint64_t v126 = objc_claimAutoreleasedReturnValue(+[NSMutableArray array](&OBJC_CLASS___NSMutableArray, "array"));
  size_t v127 = *(void **)(a1 + 4352);
  *(void *)(a1 + 4352) = v126;

  uint64_t v128 = objc_claimAutoreleasedReturnValue(+[NSMutableArray array](&OBJC_CLASS___NSMutableArray, "array"));
  CC_LONG v129 = *(void **)(a1 + 4360);
  *(void *)(a1 + 4360) = v128;

  uint64_t v130 = objc_claimAutoreleasedReturnValue(+[NSMutableArray array](&OBJC_CLASS___NSMutableArray, "array"));
  v131 = *(void **)(a1 + 4368);
  *(void *)(a1 + 4368) = v130;

  uint64_t v132 = objc_claimAutoreleasedReturnValue(+[NSMutableDictionary dictionary](&OBJC_CLASS___NSMutableDictionary, "dictionary"));
  uint64_t v133 = *(void **)(a1 + 2088);
  *(void *)(a1 + 2088) = v132;
}

void sub_1005DF66C( _Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, void *__p, uint64_t a17, int a18, __int16 a19, char a20, char a21, void *a22, uint64_t a23, int a24, __int16 a25, char a26, char a27)
{
  if (a21 < 0) {
    operator delete(__p);
  }
  if (a27 < 0) {
    operator delete(a22);
  }
  _Unwind_Resume(exception_object);
}

void sub_1005DF770(id a1, void *a2)
{
  string = xpc_dictionary_get_string(a2, _xpc_event_key_name);
  xpc_set_event("com.apple.alarm", string, 0LL);
  uint64_t v3 = (os_log_s *)qword_1008F76D8;
  if (os_log_type_enabled((os_log_t)qword_1008F76D8, OS_LOG_TYPE_DEFAULT))
  {
    uint64_t v4 = (void *)objc_claimAutoreleasedReturnValue(+[NSDate date](&OBJC_CLASS___NSDate, "date"));
    int v5 = 138412546;
    uint64_t v6 = v4;
    __int16 v7 = 2082;
    uint64_t v8 = string;
    _os_log_impl( (void *)&_mh_execute_header,  v3,  OS_LOG_TYPE_DEFAULT,  "com.apple.alarm xpc event handler at %@ for %{public}s",  (uint8_t *)&v5,  0x16u);
  }

  if (qword_1008D9700 != -1) {
    dispatch_once(&qword_1008D9700, &stru_1008A40D8);
  }
  ++*((_WORD *)off_1008D96F8 + 117);
}

void sub_1005DF8A0(uint64_t a1)
{
  uint64_t v2 = (os_log_s *)qword_1008F75B8;
  if (os_log_type_enabled((os_log_t)qword_1008F75B8, OS_LOG_TYPE_DEFAULT))
  {
    *(_WORD *)uint64_t v3 = 0;
    _os_log_impl((void *)&_mh_execute_header, v2, OS_LOG_TYPE_DEFAULT, "Reset BLE Scan Configuration Stat", v3, 2u);
  }

  *(_OWORD *)(a1 + 2680) = 0u;
  *(_OWORD *)(a1 + 2696) = 0u;
  *(_OWORD *)(a1 + 2648) = 0u;
  *(_OWORD *)(a1 + 2664) = 0u;
  *(_OWORD *)(a1 + 2616) = 0u;
  *(_OWORD *)(a1 + 2632) = 0u;
  *(_OWORD *)(a1 + 2584) = 0u;
  *(_OWORD *)(a1 + 2600) = 0u;
  *(_OWORD *)(a1 + 2552) = 0u;
  *(_OWORD *)(a1 + 2568) = 0u;
  *(_OWORD *)(a1 + 2520) = 0u;
  *(_OWORD *)(a1 + 2536) = 0u;
  *(_OWORD *)(a1 + 2488) = 0u;
  *(_OWORD *)(a1 + 2504) = 0u;
  *(_OWORD *)(a1 + 2456) = 0u;
  *(_OWORD *)(a1 + 2472) = 0u;
  *(_OWORD *)(a1 + 2424) = 0u;
  *(_OWORD *)(a1 + 2440) = 0u;
  *(_OWORD *)(a1 + 2392) = 0u;
  *(_OWORD *)(a1 + 2408) = 0u;
  *(_OWORD *)(a1 + 2360) = 0u;
  *(_OWORD *)(a1 + 2376) = 0u;
  *(_DWORD *)(a1 + 2492) = 0xFFFF;
  *(CFAbsoluteTime *)(a1 + 2360) = CFAbsoluteTimeGetCurrent();
  *(_OWORD *)(a1 + 2536) = 0u;
  *(_OWORD *)(a1 + 2552) = 0u;
  *(_OWORD *)(a1 + 2568) = 0u;
  *(_OWORD *)(a1 + 2584) = 0u;
  *(_OWORD *)(a1 + 2600) = 0u;
  *(_OWORD *)(a1 + 2616) = 0u;
  *(_OWORD *)(a1 + 2632) = 0u;
  *(_OWORD *)(a1 + 2648) = 0u;
  *(_OWORD *)(a1 + 2664) = 0u;
  *(_OWORD *)(a1 + 2680) = 0u;
  *(_OWORD *)(a1 + 2696) = 0u;
  *(_OWORD *)(a1 + 2712) = 0u;
  *(_OWORD *)(a1 + 2728) = 0u;
  *(_OWORD *)(a1 + 2744) = 0u;
  *(_OWORD *)(a1 + 2760) = 0u;
  *(_OWORD *)(a1 + 2776) = 0u;
  *(_OWORD *)(a1 + 2792) = 0u;
  *(_OWORD *)(a1 + 2808) = 0u;
  *(_OWORD *)(a1 + 2824) = 0u;
  *(_OWORD *)(a1 + 2840) = 0u;
  *(_OWORD *)(a1 + 2856) = 0u;
  *(_OWORD *)(a1 + 2872) = 0u;
  *(_DWORD *)(a1 + 2668) = 0xFFFF;
  *(CFAbsoluteTime *)(a1 + 2536) = CFAbsoluteTimeGetCurrent();
}

void sub_1005DF990(uint64_t a1)
{
  uint64_t v2 = (os_log_s *)qword_1008F75B8;
  if (os_log_type_enabled((os_log_t)qword_1008F75B8, OS_LOG_TYPE_DEFAULT))
  {
    *(_WORD *)uint64_t v3 = 0;
    _os_log_impl((void *)&_mh_execute_header, v2, OS_LOG_TYPE_DEFAULT, "Reset BLE Scan Stat", v3, 2u);
  }

  *(_OWORD *)(a1 + 3176) = 0u;
  *(_OWORD *)(a1 + 3192) = 0u;
  *(_OWORD *)(a1 + 3144) = 0u;
  *(_OWORD *)(a1 + 3sub_100242FAC(v47 - 160) = 0u;
  *(_OWORD *)(a1 + 3112) = 0u;
  *(_OWORD *)(a1 + 3128) = 0u;
  *(_OWORD *)(a1 + 3080) = 0u;
  *(_OWORD *)(a1 + 3096) = 0u;
  *(_OWORD *)(a1 + 3048) = 0u;
  *(_OWORD *)(a1 + 3064) = 0u;
  *(_OWORD *)(a1 + 3016) = 0u;
  *(_OWORD *)(a1 + 3032) = 0u;
  *(_OWORD *)(a1 + 2984) = 0u;
  *(_OWORD *)(a1 + 3000) = 0u;
  *(_OWORD *)(a1 + 2952) = 0u;
  *(_OWORD *)(a1 + 2968) = 0u;
  *(_OWORD *)(a1 + 2920) = 0u;
  *(_OWORD *)(a1 + 2936) = 0u;
  *(_OWORD *)(a1 + 2888) = 0u;
  *(_OWORD *)(a1 + 2904) = 0u;
  *(_OWORD *)(a1 + 2856) = 0u;
  *(_OWORD *)(a1 + 2872) = 0u;
  *(_OWORD *)(a1 + 2824) = 0u;
  *(_OWORD *)(a1 + 2840) = 0u;
  *(_OWORD *)(a1 + 2792) = 0u;
  *(_OWORD *)(a1 + 2808) = 0u;
  *(_OWORD *)(a1 + 2760) = 0u;
  *(_OWORD *)(a1 + 2776) = 0u;
  *(_OWORD *)(a1 + 2728) = 0u;
  *(_OWORD *)(a1 + 2744) = 0u;
  *(CFAbsoluteTime *)(a1 + 2728) = CFAbsoluteTimeGetCurrent();
}

void sub_1005DFA44(uint64_t a1)
{
  uint64_t v2 = (os_log_s *)qword_1008F75B8;
  if (os_log_type_enabled((os_log_t)qword_1008F75B8, OS_LOG_TYPE_DEFAULT))
  {
    *(_WORD *)uint64_t v3 = 0;
    _os_log_impl( (void *)&_mh_execute_header,  v2,  OS_LOG_TYPE_DEFAULT,  "Reset ScanCore BLE Connection Scan Stat",  v3,  2u);
  }

  *(void *)(a1 + 3248) = 0LL;
  *(_OWORD *)(a1 + 3232) = 0u;
  *(CFAbsoluteTime *)(a1 + 3232) = CFAbsoluteTimeGetCurrent();
}

double sub_1005DFAC0(uint64_t a1)
{
  uint64_t v2 = a1 + 710;
  bzero((void *)(a1 + 200), 0x638uLL);
  *(_DWORD *)(a1 + sub_100242FAC(v47 - 160) = 5046046;
  BOOL v3 = *(_BYTE *)(a1 + 2104) == 0;
  if (*(_BYTE *)(a1 + 2104)) {
    char v4 = 16;
  }
  else {
    char v4 = 18;
  }
  *(_BYTE *)(a1 + 164) = v4;
  if (v3) {
    char v5 = 14;
  }
  else {
    char v5 = 0;
  }
  *(_BYTE *)(a1 + 165) = v5;
  *(_BYTE *)(a1 + 172) = -1;
  *(_WORD *)(a1 + 170) = 0;
  *(_DWORD *)(a1 + 166) = 100;
  *(void *)(a1 + 181) = 0LL;
  *(void *)(a1 + 173) = 0LL;
  *(void *)(a1 + 188) = 0xFCB2160600000000LL;
  *(_DWORD *)(a1 + 196) = 25690112;
  *(_BYTE *)(a1 + 200) = 2;
  *(_BYTE *)(a1 + 229) = 1;
  *(_BYTE *)(a1 + 202) = 0;
  if (_os_feature_enabled_impl("BluetoothFeatures", "StandardUTFEAA")
    && _os_feature_enabled_impl("CoreLocation", "StandardUT"))
  {
    *(_DWORD *)(a1 + 260) = 25690112;
    *(_DWORD *)(a1 + 256) = -22407674;
    *(_WORD *)(a1 + 264) = 258;
    *(_BYTE *)(a1 + 292) = 1;
  }

  *(_DWORD *)(a1 + 704) = 5046158;
  BOOL v6 = *(_BYTE *)(a1 + 2104) == 0;
  if (*(_BYTE *)(a1 + 2104)) {
    char v7 = 16;
  }
  else {
    char v7 = 18;
  }
  *(_BYTE *)(a1 + 708) = v7;
  if (v6) {
    char v8 = 14;
  }
  else {
    char v8 = 0;
  }
  *(_BYTE *)(a1 + 709) = v8;
  *(_BYTE *)(a1 + 716) = -1;
  *(_WORD *)(a1 + 714) = 0;
  *(_DWORD *)uint64_t v2 = 100;
  *(void *)(a1 + 725) = 0LL;
  *(void *)(a1 + 717) = 0LL;
  *(void *)(a1 + 732) = 0xFCB2160600000000LL;
  *(_DWORD *)(a1 + 740) = 25690112;
  *(_BYTE *)(a1 + 744) = 2;
  *(_WORD *)(a1 + 772) = 511;
  *(_WORD *)(a1 + 745) = 257;
  *(_DWORD *)(a1 + 1248) = -43051482;
  *(_BYTE *)(a1 + 1260) = -1;
  *(void *)&double result = 13107200LL;
  *(void *)(v2 + 542) = 13107200LL;
  *(void *)(a1 + 1269) = 0LL;
  *(void *)(a1 + 1261) = 0LL;
  *(_DWORD *)(a1 + 1276) = 0;
  return result;
}

uint64_t sub_1005DFC6C(uint64_t a1)
{
  uint64_t v2 = 0LL;
  uint64_t v3 = a1 + 3272;
  do
  {
    uint64_t v4 = 0LL;
    uint64_t v5 = v3;
    do
    {
      for (uint64_t i = 0LL; i != 32; i += 16LL)
      {
        char v7 = (_DWORD *)(v5 + i);
        *(_DWORD *)((char *)v7 + 3) = 0;
        *char v7 = 0;
        v7[128] = 0;
        *(_DWORD *)(v5 + i + 515) = 0;
        uint64_t v8 = v5 + i + 520;
        void v7[2] = 0;
        *(_DWORD *)((char *)v7 + 11) = 0;
        v7[130] = 0;
        *(_DWORD *)(v8 + 3) = 0;
      }

      ++v4;
      v5 += 32LL;
    }

    while (v4 != 2);
    ++v2;
    v3 += 64LL;
  }

  while (v2 != 8);
  for (uint64_t j = 0LL; j != 2; ++j)
  {
    for (uint64_t k = 0LL; k != 2; ++k)
    {
      uint64_t v11 = 0LL;
      char v12 = 1;
      do
      {
        char v13 = v12;
        uint64_t v14 = sub_1002E6BF0();
        uint64_t result = (*(uint64_t (**)(uint64_t))(*(void *)v14 + 632LL))(v14);
        if ((result & 1) == 0)
        {
          uint64_t v16 = a1 + 32 * j + 16 * k + 8 * v11;
          *(_DWORD *)(v16 + 3528) = 43;
          *(_WORD *)(v16 + 3532) = 0;
          *(_BYTE *)(v16 + 3534) = 0;
          *(_DWORD *)(v16 + 3592) = 16;
          *(_WORD *)(v16 + 3596) = 0;
          *(_BYTE *)(v16 + 3598) = 0;
        }

        char v12 = 0;
        uint64_t v17 = a1 + 32 * j + 16 * k + 8 * v11;
        *(_DWORD *)(v17 + 3656) = 48;
        *(_WORD *)(v17 + 3660) = 0;
        *(_BYTE *)(v17 + 3662) = 0;
        uint64_t v11 = 1LL;
      }

      while ((v13 & 1) != 0);
    }
  }

  uint64_t v18 = 0LL;
  *(_DWORD *)(a1 + 3832) = 3145728;
  *(_WORD *)(a1 + 3836) = 0;
  char v19 = 1;
  *(_BYTE *)(a1 + 3838) = 1;
  *(_DWORD *)(a1 + 3840) = 3145728;
  *(_WORD *)(a1 + 3844) = 0;
  *(_BYTE *)(a1 + 3846) = 1;
  do
  {
    uint64_t v20 = a1 + 16 * v18;
    *(_DWORD *)(v20 + 4080) = 2818048;
    *(_WORD *)(v20 + 4084) = 0;
    char v21 = v19;
    *(_BYTE *)(v20 + 4086) = 0;
    *(_DWORD *)(v20 + 4072) = 0;
    *(_WORD *)(v20 + 4076) = 80;
    *(_BYTE *)(v20 + 4078) = 0;
    uint64_t v22 = a1 + 4040 + 16 * v18;
    *(_DWORD *)(v22 + 8) = 524331;
    *(_WORD *)(v22 + 12) = 0;
    *(_BYTE *)(v22 + 14) = 0;
    *(_DWORD *)uint64_t v22 = 43;
    *(_WORD *)(v22 + 4) = 16;
    uint64_t v18 = 1LL;
    *(_BYTE *)(v22 + 6) = 0;
    char v19 = 0;
  }

  while ((v21 & 1) != 0);
  uint64_t v23 = 0LL;
  char v24 = 1;
  do
  {
    uint64_t v25 = a1 + 16 * v23;
    *(_DWORD *)(v25 + 4144) = 0x100000;
    *(_WORD *)(v25 + 4148) = 0;
    char v26 = v24;
    *(_BYTE *)(v25 + 4150) = 0;
    *(_DWORD *)(v25 + 4136) = 0;
    *(_WORD *)(v25 + 4140) = 32;
    *(_BYTE *)(v25 + 4142) = 0;
    uint64_t v27 = a1 + 4104 + 16 * v23;
    *(_DWORD *)(v27 + 8) = 524304;
    *(_WORD *)(v27 + 12) = 0;
    *(_BYTE *)(v27 + 14) = 0;
    *(_DWORD *)uint64_t v27 = 16;
    *(_WORD *)(v27 + 4) = 16;
    uint64_t v23 = 1LL;
    *(_BYTE *)(v27 + 6) = 0;
    char v24 = 0;
  }

  while ((v26 & 1) != 0);
  for (uint64_t m = 0LL; m != 2; ++m)
  {
    for (uint64_t n = 0LL; n != 2; ++n)
    {
      uint64_t v30 = 0LL;
      char v31 = 1;
      do
      {
        uint64_t v32 = a1 + 32 * m + 16 * n + 8 * v30;
        *(_DWORD *)(v32 + 4168) = 32;
        *(_WORD *)(v32 + 4172) = 32;
        *(_BYTE *)(v32 + 4174) = 0;
        *(_DWORD *)(v32 + 3848) = 0;
        char v33 = v31;
        *(_WORD *)(v32 + 3852) = 16;
        *(_BYTE *)(v32 + 3854) = 0;
        uint64_t v30 = 1LL;
        char v31 = 0;
      }

      while ((v33 & 1) != 0);
    }
  }

  return result;
}

uint64_t sub_1005DFF08(uint64_t a1, uint64_t a2)
{
  unsigned __int8 v4 = atomic_load((unsigned __int8 *)&qword_1008F1EA0);
  if ((v4 & 1) == 0 && __cxa_guard_acquire(&qword_1008F1EA0))
  {
    uint64_t v48 = sub_1002E6BF0();
    byte_1008F1E9F = (*(uint64_t (**)(uint64_t))(*(void *)v48 + 840LL))(v48);
    __cxa_guard_release(&qword_1008F1EA0);
  }

  uint64_t v5 = *(void **)(a1 + 2040);
  if (v5 == (void *)(a1 + 2048))
  {
    uint64_t v6 = 0LL;
  }

  else
  {
    uint64_t v6 = 0LL;
    while (v5[5] != a2)
    {
      char v7 = (void *)v5[1];
      if (v7)
      {
        do
        {
          uint64_t v8 = v7;
          char v7 = (void *)*v7;
        }

        while (v7);
      }

      else
      {
        do
        {
          uint64_t v8 = (void *)v5[2];
          BOOL v13 = *v8 == (void)v5;
          uint64_t v5 = v8;
        }

        while (!v13);
      }

      uint64_t v5 = v8;
      if (v8 == (void *)(a1 + 2048)) {
        goto LABEL_14;
      }
    }

    uint64_t v6 = v5[4];
  }

void sub_1005E0538( _Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, void *__p, uint64_t a18, uint64_t a19, uint64_t a20, uint64_t a21, uint64_t a22, void *a23, uint64_t a24, int a25, __int16 a26, char a27, char a28, uint64_t a29, uint64_t a30, int a31, __int16 a32, char a33, char a34, char a35, uint64_t a36, uint64_t a37, uint64_t a38, uint64_t a39, uint64_t a40, uint64_t a41, uint64_t a42, uint64_t a43, uint64_t a44, uint64_t a45, uint64_t a46, uint64_t a47, uint64_t a48, char a49)
{
}

void sub_1005E0630(uint64_t a1@<X0>, int a2@<W1>, uint64_t a3@<X8>)
{
  unsigned __int8 v6 = atomic_load((unsigned __int8 *)&qword_1008F1EB0);
  if ((v6 & 1) == 0 && __cxa_guard_acquire(&qword_1008F1EB0))
  {
    dword_1008F1EA8 = *(_DWORD *)(sub_1002E6E9C() + 708);
    __cxa_guard_release(&qword_1008F1EB0);
  }

  __int128 v7 = 0uLL;
  memset(v140, 0, sizeof(v140));
  uint64_t v142 = 1LL;
  memset(v141, 0, sizeof(v141));
  BYTE1(v140[0]) = 1;
  *(_DWORD *)((char *)v140 + 2) = 0x1000000;
  BYTE6(v140[0]) = 1;
  *(_DWORD *)((char *)v140 + 7) = 256;
  *(_WORD *)((char *)v140 + 11) = 0;
  memset(v137, 0, sizeof(v137));
  memset(v138, 0, sizeof(v138));
  BYTE1(v137[0]) = 1;
  BYTE6(v137[0]) = 1;
  *(_DWORD *)((char *)v137 + 7) = 0;
  *(_WORD *)((char *)v137 + 11) = 0;
  uint64_t v139 = 1LL;
  if (a2 > 268)
  {
    char v12 = (void *)&v138[1] + 1;
    switch(a2)
    {
      case 65544:
      case 65559:
        __int16 v209 = (unsigned __int128)0LL >> 112;
        __n128 v207 = 0uLL;
        *(_OWORD *)__int16 v208 = 0uLL;
        *(void *)&v208[1] = 0x100129C00010101LL;
        *(_WORD *)&v208[9] = 513;
        *(void *)&v208[12] = 0xFFFF0000FFFFLL;
        *(_DWORD *)&v208[20] = 0xFFFF;
        memset(&v208[24], 0, 54);
        uint64_t v13 = sub_1002E6BF0();
        if ((*(unsigned int (**)(uint64_t))(*(void *)v13 + 384LL))(v13))
        {
          LODWORD(v137[2]) = 19660830;
          HIWORD(v137[0]) = 0;
          LOBYTE(v137[0]) = 0;
          *(void *)&v137[1] = 0LL;
          v208[4] = *(_BYTE *)(a1 + 144);
          uint64_t v14 = *((void *)&v138[0] + 1);
          if (*((void *)&v138[0] + 1) >= *(void *)&v138[1])
          {
            uint64_t v18 = sub_10060F3A8((uint64_t *)v138, (uint64_t)&v207);
          }

          else
          {
            **((void **)&v138[0] + 1) = (id)v207.n128_u64[0];
            *(void *)(v14 + 8) = (id)v207.n128_u64[1];
            *(_OWORD *)(v14 + 16) = *(_OWORD *)v208;
            __int128 v16 = *(_OWORD *)&v208[32];
            __int128 v15 = *(_OWORD *)&v208[48];
            __int128 v17 = *(_OWORD *)&v208[16];
            *(_OWORD *)(v14 + 78) = *(_OWORD *)&v208[62];
            *(_OWORD *)(v14 + 48) = v16;
            *(_OWORD *)(v14 + 64) = v15;
            *(_OWORD *)(v14 + 32) = v17;
            uint64_t v18 = v14 + 96;
          }

          *((void *)&v138[0] + 1) = v18;
          if (_os_feature_enabled_impl("CoreLocation", "StandardUT"))
          {
            __int128 v205 = xmmword_1006BDCB0;
            int v206 = 0;
            sub_100634334((__n128 *)buf, (__n128 *)&v205);
            sub_1005E38E0((void **)&v138[1] + 1, (__int128 *)buf);
            if (_os_feature_enabled_impl("BluetoothFeatures", "StandardUTFEAA"))
            {
              __int128 v203 = xmmword_1006BDCC4;
              int v204 = 0;
              sub_100634334((__n128 *)buf, (__n128 *)&v203);
              sub_1005E38E0((void **)&v138[1] + 1, (__int128 *)buf);
            }

            LOBYTE(v139) = *(_BYTE *)(a1 + 144);
          }
        }

        else
        {
          uint64_t v57 = sub_1002E6BF0();
          if ((*(unsigned int (**)(uint64_t))(*(void *)v57 + 376LL))(v57))
          {
            LODWORD(v137[2]) = 0;
            HIWORD(v137[0]) = 0;
            LOBYTE(v137[0]) = 0;
            *(void *)&v137[1] = 0LL;
            BYTE4(v137[0]) = 1;
            v208[4] = 1;
            sub_1005E3A00((uint64_t *)v138, (uint64_t)&v207);
            if (_os_feature_enabled_impl("CoreLocation", "StandardUT"))
            {
              LOBYTE(v139) = 1;
              __int128 v201 = xmmword_1006BDCB0;
              int v202 = 0;
              sub_100634334((__n128 *)buf, (__n128 *)&v201);
              sub_1005E38E0((void **)&v138[1] + 1, (__int128 *)buf);
              if (_os_feature_enabled_impl("BluetoothFeatures", "StandardUTFEAA"))
              {
                __int128 v199 = xmmword_1006BDCC4;
                int v200 = 0;
                sub_100634334((__n128 *)buf, (__n128 *)&v199);
                sub_1005E38E0((void **)&v138[1] + 1, (__int128 *)buf);
              }
            }

            if (!*(_BYTE *)(a1 + 144))
            {
              int v58 = v140;
              __int16 v59 = v141;
              char v12 = (void *)&v141[1] + 1;
              goto LABEL_183;
            }
          }

          else
          {
            unsigned int v76 = &unk_1008F1000;
            LOBYTE(v137[0]) = 0;
            int v77 = *(unsigned __int8 *)(a1 + 144);
            BOOL v79 = (dword_1008F1EA8 - 19) < 0x7BD && v77 != 0;
            v208[7] = v79;
            *(void *)&v137[1] = 0LL;
            v208[4] = v77;
            if ((dword_1008F1EA8 - 22) > 0x7B9)
            {
              else {
                HIWORD(v137[0]) = 2;
              }
            }

            else
            {
              HIWORD(v137[0]) = 3;
              int v80 = _os_feature_enabled_impl("BluetoothFeatures", "BeepOnMoveWake");
              double v81 = (os_log_s *)qword_1008F75B8;
              if (os_log_type_enabled((os_log_t)qword_1008F75B8, OS_LOG_TYPE_DEFAULT))
              {
                int v136 = dword_1008F1EA8;
                BOOL v82 = sub_1005E2B18(a2);
                int v83 = *(unsigned __int8 *)(a1 + 144);
                *(_DWORD *)__int128 buf = 67109890;
                *(_DWORD *)&uint8_t buf[4] = v80;
                *(_WORD *)&uint8_t buf[8] = 1024;
                *(_DWORD *)&buf[10] = v136;
                *(_WORD *)&buf[14] = 2080;
                __int16 v196 = v82;
                __int16 v197 = 1024;
                int v198 = v83;
                _os_log_impl( (void *)&_mh_execute_header,  v81,  OS_LOG_TYPE_DEFAULT,  "bomEnabled:%d chipset:%d usecase:%s fScreenState:%d",  buf,  0x1Eu);
              }

              unsigned int v76 = (_DWORD *)&unk_1008F1000;
              if (v80)
              {
                uint64_t v84 = sub_1002E6E9C();
                int v85 = (*(uint64_t (**)(uint64_t))(*(void *)v84 + 3504LL))(v84);
                if (a2 == 65559 && v85 == 25 && !*(_BYTE *)(a1 + 144))
                {
                  v208[4] = 1;
                  *(void *)&v208[24] = 0LL;
                  *(void *)&v208[32] = 0LL;
                  *(void *)&v208[39] = 0LL;
                  memset(&v208[49], 0, 23);
                  *(_WORD *)&v208[47] = 4;
                  *(_WORD *)&v208[72] = 4;
                  *(_DWORD *)&v208[74] = 1638425;
                }
              }
            }

            if ((v76[938] - 20) > 0x7BB)
            {
              if (*(_BYTE *)(a1 + 144))
              {
                LODWORD(v137[2]) = 19660830;
              }

              else
              {
                LODWORD(v137[2]) = 0;
                BYTE4(v137[0]) = 1;
              }
            }

            else
            {
              BOOL v129 = *(_BYTE *)(a1 + 144) == 0;
              if (*(_BYTE *)(a1 + 144)) {
                __int16 v130 = 30;
              }
              else {
                __int16 v130 = 0;
              }
              LOWORD(v137[2]) = v130;
              if (v129) {
                __int16 v131 = 0;
              }
              else {
                __int16 v131 = 300;
              }
              WORD1(v137[2]) = v131;
            }

            sub_1005E3A00((uint64_t *)v138, (uint64_t)&v207);
            if (_os_feature_enabled_impl("CoreLocation", "StandardUT"))
            {
              __int128 v193 = xmmword_1006BDCB0;
              int v194 = 0;
              sub_100634334((__n128 *)buf, (__n128 *)&v193);
              sub_1005E38E0((void **)&v138[1] + 1, (__int128 *)buf);
              if (_os_feature_enabled_impl("BluetoothFeatures", "StandardUTFEAA"))
              {
                __int128 v191 = xmmword_1006BDCC4;
                int v192 = 0;
                sub_100634334((__n128 *)buf, (__n128 *)&v191);
                sub_1005E38E0((void **)&v138[1] + 1, (__int128 *)buf);
              }
            }
          }
        }

        DWORD2(v137[2]) = 1;
        BYTE8(v137[0]) = 1;
        int v58 = v137;
        __int16 v59 = v138;
        goto LABEL_183;
      case 65545:
      case 65546:
        __int16 v209 = (unsigned __int128)0LL >> 112;
        __n128 v207 = 0uLL;
        *(_OWORD *)__int16 v208 = 0uLL;
        *(void *)&v208[1] = 0x100129C00010101LL;
        *(_WORD *)&v208[9] = 513;
        *(void *)&v208[12] = 0xFFFF0000FFFFLL;
        *(_DWORD *)&v208[20] = 0xFFFF;
        memset(&v208[24], 0, 54);
        uint64_t v38 = sub_1002E6BF0();
        if ((*(unsigned int (**)(uint64_t))(*(void *)v38 + 384LL))(v38))
        {
          LODWORD(v137[2]) = 19660830;
          HIWORD(v137[0]) = 0;
          LOBYTE(v137[0]) = 0;
          *(void *)&v137[1] = 0LL;
          v208[4] = *(_BYTE *)(a1 + 144);
          uint64_t v39 = *((void *)&v138[0] + 1);
          if (*((void *)&v138[0] + 1) >= *(void *)&v138[1])
          {
            uint64_t v43 = sub_10060F3A8((uint64_t *)v138, (uint64_t)&v207);
          }

          else
          {
            **((void **)&v138[0] + 1) = (id)v207.n128_u64[0];
            *(void *)(v39 + 8) = (id)v207.n128_u64[1];
            *(_OWORD *)(v39 + 16) = *(_OWORD *)v208;
            __int128 v41 = *(_OWORD *)&v208[32];
            __int128 v40 = *(_OWORD *)&v208[48];
            __int128 v42 = *(_OWORD *)&v208[16];
            *(_OWORD *)(v39 + 78) = *(_OWORD *)&v208[62];
            *(_OWORD *)(v39 + 48) = v41;
            *(_OWORD *)(v39 + 64) = v40;
            *(_OWORD *)(v39 + 32) = v42;
            uint64_t v43 = v39 + 96;
          }

          *((void *)&v138[0] + 1) = v43;
          if (_os_feature_enabled_impl("CoreLocation", "StandardUT"))
          {
            LOBYTE(v139) = *(_BYTE *)(a1 + 144);
            __int128 v189 = xmmword_1006BDCB0;
            int v190 = 0;
            sub_100634334((__n128 *)buf, (__n128 *)&v189);
            sub_1005E38E0((void **)&v138[1] + 1, (__int128 *)buf);
            if (_os_feature_enabled_impl("BluetoothFeatures", "StandardUTFEAA"))
            {
              __int128 v187 = xmmword_1006BDCC4;
              int v188 = 0;
              sub_100634334((__n128 *)buf, (__n128 *)&v187);
              sub_1005E38E0((void **)&v138[1] + 1, (__int128 *)buf);
            }
          }

          goto LABEL_182;
        }

        uint64_t v60 = sub_1002E6BF0();
        if ((*(unsigned int (**)(uint64_t))(*(void *)v60 + 376LL))(v60))
        {
          LODWORD(v137[2]) = 0;
          HIWORD(v137[0]) = 0;
          LOBYTE(v137[0]) = 0;
          *(void *)&v137[1] = 0LL;
          BYTE4(v137[0]) = 1;
          v208[4] = 1;
          sub_1005E3A00((uint64_t *)v138, (uint64_t)&v207);
          if (_os_feature_enabled_impl("CoreLocation", "StandardUT"))
          {
            LOBYTE(v139) = 1;
            __int128 v185 = xmmword_1006BDCB0;
            int v186 = 0;
            sub_100634334((__n128 *)buf, (__n128 *)&v185);
            sub_1005E38E0((void **)&v138[1] + 1, (__int128 *)buf);
            if (_os_feature_enabled_impl("BluetoothFeatures", "StandardUTFEAA"))
            {
              __int128 v183 = xmmword_1006BDCC4;
              int v184 = 0;
              sub_100634334((__n128 *)buf, (__n128 *)&v183);
              sub_1005E38E0((void **)&v138[1] + 1, (__int128 *)buf);
            }
          }

          if (!*(_BYTE *)(a1 + 144))
          {
LABEL_181:
            int v58 = v140;
            __int16 v59 = v141;
            char v12 = (void *)&v141[1] + 1;
            goto LABEL_183;
          }

void sub_1005E28EC(_Unwind_Exception *a1)
{
}

const char *sub_1005E2B18(int a1)
{
  if (a1 >= 0x20000)
  {
    if (a1 >= 327680)
    {
      if (a1 > 589824)
      {
        if (a1 <= 2147418111)
        {
          switch(a1)
          {
            case 589825:
              return "FindNearbyPencil";
            case 655360:
              return "AccessDigitalHomeKey";
            case 786432:
              return "ProxControlDeviceClose";
            default:
              return "?";
          }
        }

        else
        {
          switch(a1)
          {
            case 2147418112:
              uint64_t result = "InternalTestNoLockScan";
              break;
            case 2147418113:
              uint64_t result = "InternalTestNoScreenOffScan";
              break;
            case 2147418114:
              uint64_t result = "InternalTestScanWithNoDups";
              break;
            case 2147418115:
              uint64_t result = "InternalTestScanWithDups";
              break;
            case 2147418116:
              uint64_t result = "InternalTestScanFor20Seconds";
              break;
            case 2147418117:
              uint64_t result = "InternalTestActiveScan";
              break;
            case 2147418118:
              uint64_t result = "InternalTestUUIDScan";
              break;
            case 2147418119:
              uint64_t result = "InternalTestScanFor10ClockSeconds";
              break;
            case 2147418120:
              uint64_t result = "InternalTestScanBoost";
              break;
            default:
              return "?";
          }
        }
      }

      else if (a1 > 458752)
      {
        switch(a1)
        {
          case 524288:
            uint64_t result = "ADPD";
            break;
          case 524289:
            uint64_t result = "ADPDBuffer";
            break;
          case 524290:
            uint64_t result = "MicroLocation";
            break;
          case 524291:
            uint64_t result = "MicroLocationLeech";
            break;
          default:
            if (a1 == 458753)
            {
              uint64_t result = "PrecisionFindingFindee";
            }

            else
            {
              if (a1 != 589824) {
                return "?";
              }
              uint64_t result = "FindNearbyRemote";
            }

            break;
        }
      }

      else
      {
        switch(a1)
        {
          case 393216:
            uint64_t result = "CaptiveNetworkJoin";
            break;
          case 393217:
            uint64_t result = "UseCaseSIMTransfer";
            break;
          case 393218:
            uint64_t result = "MacSetup";
            break;
          case 393219:
            uint64_t result = "AppleIDSignIn";
            break;
          case 393220:
            uint64_t result = "AppleIDSignInSettings";
            break;
          default:
            if (a1 == 327680)
            {
              uint64_t result = "RapportThirdParty";
            }

            else
            {
              if (a1 != 458752) {
                return "?";
              }
              uint64_t result = "PrecisionFindingFinder";
            }

            break;
        }
      }
    }

    else
    {
      switch(a1)
      {
        case 131072:
          return "SharingDefault";
        case 131073:
          return "SharingPhoneAutoUnlock";
        case 131074:
          return "SharingSiriWatchAuth";
        case 131075:
          return "SharingMacAutoUnlock";
        case 131076:
          return "SharingEDTScreenOn";
        case 131077:
          return "SharingEDTWiFiDisabled";
        case 131078:
          return "SharingEDTWombatEligibleAsDefaultCamera";
        case 131079:
          return "SharingEDTWombatCameraPicker";
        case 131080:
          return "SharingWombatBackground";
        case 131081:
          return "SharingUniversalControl";
        case 131082:
          return "SharingPeopleProximity";
        case 131083:
          return "SharingEDTEnsembleOpenDisplayPrefs";
        case 131084:
          return "SharingEDTNearbydMotionStopped";
        case 131085:
          return "SharingDoubleBoostGenericScan";
        case 131086:
          return "SharingEDTIncomingAdvertisement ";
        case 131087:
          return "SharingEDTWombatStreamStart";
        case 131088:
          return "SharingOYAutoUnlock";
        case 131089:
          return "?";
        case 131090:
          return "SharingAirDrop";
        case 131091:
          return "SharingNearbyInvitationHost";
        case 131092:
          return "SharingNearbyInvitationParticipant";
        case 131093:
          return "SharingAirDropAskToAirDrop";
        case 131094:
          return "SharingAirDropTempIdentity";
        case 131095:
          return "SharingAirDropNeedsCLink";
        case 131096:
          return "SharingRemoteWidgetUpdate";
        case 131097:
          return "SharingCountryCodeUpdate";
        case 131098:
          return "SharingMacPhoneAutoUnlock";
        case 131099:
          return "SharingVisionProDiscovery";
        case 131100:
          return "SharingVisionProStateChange";
        case 131101:
          return "SharingContinuityScreen";
        case 131102:
          return "SharingEDTRemoteDisplay";
        default:
          if (a1 == 196608)
          {
            uint64_t result = "DigitalIDTSA";
          }

          else
          {
            if (a1 != 0x40000) {
              return "?";
            }
            uint64_t result = "DigitalCarKeyThirdParty";
          }

          break;
      }
    }
  }

  else
  {
    uint64_t result = "Unspecified";
    switch(a1)
    {
      case 0:
        return result;
      case 1:
        uint64_t result = "HealthKit";
        break;
      case 2:
        uint64_t result = "HomeKit";
        break;
      case 3:
        uint64_t result = "FindMyObjectConnection";
        break;
      case 4:
        uint64_t result = "FindMyObjectConnectionTransient";
        break;
      case 5:
        uint64_t result = "MIDI";
        break;
      case 6:
        uint64_t result = "Continuity";
        break;
      case 7:
        uint64_t result = "InstantHotSpot";
        break;
      case 8:
        uint64_t result = "NearBy";
        break;
      case 9:
        uint64_t result = "Sharing";
        break;
      case 10:
        uint64_t result = "HearingSupport";
        break;
      case 11:
        uint64_t result = "Magnet";
        break;
      case 12:
        uint64_t result = "HID";
        break;
      case 13:
        uint64_t result = "LEA";
        break;
      case 14:
        uint64_t result = "External";
        break;
      case 15:
        uint64_t result = "ExternalMedical";
        break;
      case 16:
        uint64_t result = "ExternalLock";
        break;
      case 17:
        uint64_t result = "ExternalWatch";
        break;
      case 18:
        uint64_t result = "SmartRouting";
        break;
      case 19:
        uint64_t result = "DigitalID";
        break;
      case 20:
        uint64_t result = "DigitalKey";
        break;
      case 21:
        uint64_t result = "DigitalCarKey";
        break;
      case 22:
        uint64_t result = "HeySiri";
        break;
      case 23:
        uint64_t result = "ThirdPartyApp";
        break;
      case 24:
        uint64_t result = "CNJ";
        break;
      default:
        switch(a1)
        {
          case 256:
            uint64_t result = "DevicePresenceDetection";
            break;
          case 257:
            uint64_t result = "AudioBox";
            break;
          case 258:
            uint64_t result = "SIMTransfer";
            break;
          case 259:
            uint64_t result = "ProximityScreenOnLeechScan";
            break;
          case 260:
            uint64_t result = "MacMigrate";
            break;
          case 263:
            uint64_t result = "HIDUARTService";
            break;
          case 264:
            uint64_t result = "AccessibilitySwitchControlPairing";
            break;
          case 265:
            uint64_t result = "BaseBandFastConnect";
            break;
          case 266:
            uint64_t result = "SafetyAlerts";
            break;
          case 267:
            uint64_t result = "LECarPlay";
            break;
          case 268:
            uint64_t result = "TCCBluetooth";
            break;
          case 269:
            uint64_t result = "AOPBufferLeech";
            break;
          default:
            return "?";
        }

        break;
    }
  }

  return result;
}

uint64_t sub_1005E3244@<X0>(unsigned __int8 *a1@<X0>, std::stringbuf::string_type *a2@<X8>)
{
  uint64_t v60 = 0LL;
  memset(v59, 0, sizeof(v59));
  __int128 v57 = 0u;
  __int128 v58 = 0u;
  *(_OWORD *)std::string __p = 0u;
  memset(v55, 0, sizeof(v55));
  sub_10020E564((uint64_t)v55);
  if (a1[5])
  {
    unsigned __int8 v4 = "disabled";
    uint64_t v5 = 8LL;
  }

  else if (a1[8])
  {
    __int128 v7 = sub_1001FD17C(v55, (uint64_t)"leech:", 6LL);
    uint64_t v8 = (void *)std::ostream::operator<<(v7, a1[4]);
    sub_1001FD17C(v8, (uint64_t)" ", 1LL);
    char v9 = sub_1001FD17C(v55, (uint64_t)"disabled:", 9LL);
    __int128 v10 = (void *)std::ostream::operator<<(v9, a1[5]);
    sub_1001FD17C(v10, (uint64_t)" ", 1LL);
    __int128 v11 = sub_1001FD17C(v55, (uint64_t)"AllowDups:", 10LL);
    char v12 = (void *)std::ostream::operator<<(v11, *a1);
    sub_1001FD17C(v12, (uint64_t)" ", 1LL);
    uint64_t v13 = sub_1001FD17C(v55, (uint64_t)"WhenLocked:", 11LL);
    uint64_t v14 = (void *)std::ostream::operator<<(v13, a1[1]);
    sub_1001FD17C(v14, (uint64_t)" ", 1LL);
    __int128 v15 = sub_1001FD17C(v55, (uint64_t)"BeforeFirstUnlock:", 18LL);
    __int128 v16 = (void *)std::ostream::operator<<(v15, a1[2]);
    sub_1001FD17C(v16, (uint64_t)" ", 1LL);
    __int128 v17 = sub_1001FD17C(v55, (uint64_t)"activeScan:", 11LL);
    uint64_t v18 = (void *)std::ostream::operator<<(v17, a1[3]);
    sub_1001FD17C(v18, (uint64_t)" ", 1LL);
    __int128 v19 = sub_1001FD17C(v55, (uint64_t)"advBufferConfig:", 16LL);
    char v20 = (void *)std::ostream::operator<<(v19, *((unsigned __int16 *)a1 + 7));
    sub_1001FD17C(v20, (uint64_t)" ", 1LL);
    uint64_t v21 = sub_1001FD17C(v55, (uint64_t)"coexImpacted:", 13LL);
    uint64_t v22 = (void *)std::ostream::operator<<(v21, a1[7]);
    sub_1001FD17C(v22, (uint64_t)" ", 1LL);
    uint64_t v23 = sub_1001FD17C(v55, (uint64_t)"scanDurationMS:", 15LL);
    __int128 v24 = (void *)std::ostream::operator<<(v23, *((void *)a1 + 2));
    sub_1001FD17C(v24, (uint64_t)" ", 1LL);
    char v25 = sub_1001FD17C(v55, (uint64_t)"ms scanDurationTimeoutMs:", 25LL);
    __int128 v26 = (void *)std::ostream::operator<<(v25, *((void *)a1 + 3));
    sub_1001FD17C(v26, (uint64_t)" ", 1LL);
    __int128 v27 = sub_1001FD17C(v55, (uint64_t)"ms scanWindow:", 14LL);
    __int128 v28 = (void *)std::ostream::operator<<(v27, *((unsigned __int16 *)a1 + 16));
    sub_1001FD17C(v28, (uint64_t)" ", 1LL);
    uint64_t v29 = sub_1001FD17C(v55, (uint64_t)"ms scanInterval:", 16LL);
    uint64_t v30 = (void *)std::ostream::operator<<(v29, *((unsigned __int16 *)a1 + 17));
    sub_1001FD17C(v30, (uint64_t)" ", 1LL);
    uint64_t v31 = sub_1001FD17C(v55, (uint64_t)"ms isSCOffloading:", 18LL);
    uint64_t v32 = (void *)std::ostream::operator<<(v31, a1[36]);
    sub_1001FD17C(v32, (uint64_t)" ", 1LL);
    uint64_t v33 = sub_1001FD17C(v55, (uint64_t)"privileged:", 11LL);
    __int128 v34 = (void *)std::ostream::operator<<(v33, a1[6]);
    sub_1001FD17C(v34, (uint64_t)" ", 1LL);
    __int128 v35 = sub_1001FD17C(v55, (uint64_t)"operatorType:", 13LL);
    int v36 = *((_DWORD *)a1 + 10);
    if (v36) {
      uint64_t v37 = "OR ";
    }
    else {
      uint64_t v37 = "AND ";
    }
    if (v36) {
      uint64_t v38 = 3LL;
    }
    else {
      uint64_t v38 = 4LL;
    }
    sub_1001FD17C(v35, (uint64_t)v37, v38);
    uint64_t v39 = sub_1001FD17C(v55, (uint64_t)"configureControllerUUIDs:", 25LL);
    __int128 v40 = (void *)std::ostream::operator<<(v39, a1[96]);
    sub_1001FD17C(v40, (uint64_t)" ", 1LL);
    sub_1001FD17C(v55, (uint64_t)"AppleTypes[", 11LL);
    __int128 v42 = (_BYTE *)*((void *)a1 + 6);
    __int128 v41 = (_BYTE *)*((void *)a1 + 7);
    if (v41 == v42)
    {
      sub_1001FD17C(v55, (uint64_t)"none", 4LL);
    }

    else
    {
      do
      {
        uint64_t v43 = (void *)std::ostream::operator<<(v55, v42[22]);
        if (v42[20]) {
          __int128 v44 = "Y";
        }
        else {
          __int128 v44 = "N";
        }
        __int128 v45 = sub_1001FD17C(v43, (uint64_t)v44, 1LL);
        if (v42[23]) {
          uint64_t v46 = "D";
        }
        else {
          uint64_t v46 = "";
        }
        char v47 = sub_1001FD17C(v45, (uint64_t)v46, v42[23] != 0);
        sub_1001FD17C(v47, (uint64_t)" ", 1LL);
        v42 += 96;
      }

      while (v42 != v41);
    }

    sub_1001FD17C(v55, (uint64_t)"] uuids[", 8LL);
    uint64_t v48 = *((void *)a1 + 9);
    uint64_t v49 = *((void *)a1 + 10);
    if (v49 == v48)
    {
      sub_1001FD17C(v55, (uint64_t)"none", 4LL);
      unsigned __int8 v4 = "]";
      uint64_t v5 = 1LL;
    }

    else
    {
      uint64_t v5 = 1LL;
      unsigned __int8 v4 = "]";
      do
      {
        sub_1006344B4(v48, v53);
        if ((v54 & 0x80u) == 0) {
          int v50 = v53;
        }
        else {
          int v50 = (void **)v53[0];
        }
        if ((v54 & 0x80u) == 0) {
          uint64_t v51 = v54;
        }
        else {
          uint64_t v51 = (uint64_t)v53[1];
        }
        __int128 v52 = sub_1001FD17C(v55, (uint64_t)v50, v51);
        sub_1001FD17C(v52, (uint64_t)" ", 1LL);
        v48 += 20LL;
      }

      while (v48 != v49);
    }
  }

  else
  {
    unsigned __int8 v4 = "NA";
    uint64_t v5 = 2LL;
  }

  sub_1001FD17C(v55, (uint64_t)v4, v5);
  std::stringbuf::str(a2, (const std::stringbuf *)((char *)v55 + 8));
  if (SHIBYTE(v57) < 0) {
    operator delete(__p[1]);
  }
  std::streambuf::~streambuf((char *)v55 + 8);
  return std::ios::~ios(v59);
}

void sub_1005E37A0( _Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void *__p, uint64_t a11, int a12, __int16 a13, char a14, char a15, char a16)
{
}

_DWORD *sub_1005E37D4(_DWORD *result, __int128 *a2)
{
  uint64_t v3 = result;
  __int128 v4 = *a2;
  __int128 v5 = a2[1];
  *(_OWORD *)(result + 77) = *(__int128 *)((char *)a2 + 28);
  *(_OWORD *)(result + 70) = v4;
  *(_OWORD *)(result + 74) = v5;
  if (result + 70 != (_DWORD *)a2)
  {
    sub_10060E768( (uint64_t *)result + 41,  *((void *)a2 + 6),  *((void *)a2 + 7),  0xAAAAAAAAAAAAAAABLL * ((uint64_t)(*((void *)a2 + 7) - *((void *)a2 + 6)) >> 5));
    uint64_t result = sub_100050224( (void *)v3 + 44,  *((__int128 **)a2 + 9),  *((__int128 **)a2 + 10),  0xCCCCCCCCCCCCCCCDLL * ((uint64_t)(*((void *)a2 + 10) - *((void *)a2 + 9)) >> 2));
  }

  *((_BYTE *)v3 + 376) = *((_BYTE *)a2 + 96);
  return result;
}

void sub_1005E3858(uint64_t a1)
{
  uint64_t v3 = *(void *)(a1 + 64);
  for (uint64_t i = *(void *)(a1 + 72); i != v3; sub_1000507F8(a1 + 80, i))
    i -= 96LL;
  *(void *)(a1 + 72) = v3;
  uint64_t v4 = a1 + 240;
  int v5 = 0;
  sub_10060E984((uint64_t)&v4, 0x100uLL);
  uint64_t v4 = a1 + 208;
  int v5 = 0;
  sub_10060E984((uint64_t)&v4, 0x100uLL);
}

void sub_1005E38E0(void **a1, __int128 *a2)
{
  unsigned __int8 v6 = a1[2];
  uint64_t v4 = (uint64_t)(a1 + 2);
  int v5 = v6;
  unint64_t v7 = *(void *)(v4 - 8);
  if (v7 >= (unint64_t)v6)
  {
    unint64_t v10 = 0xCCCCCCCCCCCCCCCDLL * ((uint64_t)(v7 - (void)*a1) >> 2);
    unint64_t v11 = v10 + 1;
    if (v10 + 1 > 0xCCCCCCCCCCCCCCCLL) {
      abort();
    }
    unint64_t v12 = 0xCCCCCCCCCCCCCCCDLL * ((v5 - (_BYTE *)*a1) >> 2);
    if (2 * v12 > v11) {
      unint64_t v11 = 2 * v12;
    }
    if (v12 >= 0x666666666666666LL) {
      unint64_t v13 = 0xCCCCCCCCCCCCCCCLL;
    }
    else {
      unint64_t v13 = v11;
    }
    if (v13) {
      uint64_t v14 = (char *)sub_100050420(v4, v13);
    }
    else {
      uint64_t v14 = 0LL;
    }
    __int128 v15 = &v14[20 * v10];
    __int128 v16 = &v14[20 * v13];
    __int128 v17 = *a2;
    *((_DWORD *)v15 + 4) = *((_DWORD *)a2 + 4);
    *(_OWORD *)__int128 v15 = v17;
    char v9 = v15 + 20;
    __int128 v19 = (char *)*a1;
    uint64_t v18 = (char *)a1[1];
    if (v18 != *a1)
    {
      do
      {
        __int128 v20 = *(_OWORD *)(v18 - 20);
        *((_DWORD *)v15 - 1) = *((_DWORD *)v18 - 1);
        *(_OWORD *)(v15 - 20) = v20;
        v15 -= 20;
        v18 -= 20;
      }

      while (v18 != v19);
      uint64_t v18 = (char *)*a1;
    }

    *a1 = v15;
    a1[1] = v9;
    a1[2] = v16;
    if (v18) {
      operator delete(v18);
    }
  }

  else
  {
    __int128 v8 = *a2;
    *(_DWORD *)(v7 + 16) = *((_DWORD *)a2 + 4);
    *(_OWORD *)unint64_t v7 = v8;
    char v9 = (char *)(v7 + 20);
  }

  a1[1] = v9;
}

uint64_t sub_1005E3A00(uint64_t *a1, uint64_t a2)
{
  unint64_t v4 = a1[1];
  if (v4 >= a1[2])
  {
    uint64_t result = sub_10060F3A8(a1, a2);
  }

  else
  {
    *(void *)unint64_t v4 = *(id *)a2;
    *(void *)(v4 + 8) = *(id *)(a2 + 8);
    *(_OWORD *)(v4 + 16) = *(_OWORD *)(a2 + 16);
    __int128 v6 = *(_OWORD *)(a2 + 48);
    __int128 v5 = *(_OWORD *)(a2 + 64);
    __int128 v7 = *(_OWORD *)(a2 + 32);
    *(_OWORD *)(v4 + 78) = *(_OWORD *)(a2 + 78);
    *(_OWORD *)(v4 + 48) = v6;
    *(_OWORD *)(v4 + 64) = v5;
    *(_OWORD *)(v4 + 32) = v7;
    uint64_t result = v4 + 96;
  }

  a1[1] = result;
  return result;
}

void sub_1005E3A84(uint64_t a1)
{
  if (os_log_type_enabled((os_log_t)qword_1008F75B8, OS_LOG_TYPE_DEBUG)) {
    sub_10069B7F0();
  }
  uint64_t v2 = sub_100404FE8();
  v3[0] = _NSConcreteStackBlock;
  v3[1] = 3221225472LL;
  _DWORD v3[2] = sub_1005E3B0C;
  v3[3] = &unk_10087EB20;
  v3[4] = a1;
  sub_1004054B4(v2, v3);
}

uint64_t sub_1005E3B0C(uint64_t result)
{
  *(_BYTE *)(*(void *)(result + 32) + 4386LL) = 1;
  return result;
}

void sub_1005E3B20(uint64_t a1)
{
}

void sub_1005E3B28(uint64_t a1)
{
  uint64_t v2 = (os_log_s *)qword_1008F75B8;
  if (os_log_type_enabled((os_log_t)qword_1008F75B8, OS_LOG_TYPE_INFO))
  {
    if (*(_BYTE *)(a1 + 144)) {
      uint64_t v3 = "On";
    }
    else {
      uint64_t v3 = "Off";
    }
    *(_DWORD *)__int128 buf = 136446210;
    __int128 v7 = v3;
    _os_log_impl( (void *)&_mh_execute_header,  v2,  OS_LOG_TYPE_INFO,  "LeObserver Power : system woke up, screen is %{public}s",  buf,  0xCu);
  }

  uint64_t v4 = sub_100404FE8();
  v5[0] = _NSConcreteStackBlock;
  v5[1] = 3221225472LL;
  void v5[2] = sub_1005E3C20;
  v5[3] = &unk_10087EB20;
  v5[4] = a1;
  sub_1004054B4(v4, v5);
}

void sub_1005E3C20(uint64_t a1)
{
  uint64_t v1 = *(void *)(a1 + 32);
  *(_BYTE *)(v1 + 4386) = 0;
  uint64_t v2 = sub_100404FE8();
  v3[0] = _NSConcreteStackBlock;
  v3[1] = 3221225472LL;
  _DWORD v3[2] = sub_1005E3C88;
  v3[3] = &unk_10087EB20;
  v3[4] = v1;
  sub_100405384(v2, v3);
}

uint64_t sub_1005E3C88(uint64_t a1)
{
  return sub_1005E3C94(*(void *)(a1 + 32), 0);
}

uint64_t sub_1005E3C94(uint64_t a1, char a2)
{
  if ((*(_DWORD *)(a1 + 1960) & 0xFFFFFFFD) == 1) {
    return sub_1005F51EC(a1, a2);
  }
  uint64_t v3 = (os_log_s *)qword_1008F75B8;
  if (os_log_type_enabled((os_log_t)qword_1008F75B8, OS_LOG_TYPE_DEFAULT))
  {
    *(_WORD *)uint64_t v4 = 0;
    _os_log_impl( (void *)&_mh_execute_header,  v3,  OS_LOG_TYPE_DEFAULT,  "Waiting for scan state to settle before updating scan",  v4,  2u);
  }

  return 0LL;
}

void sub_1005E3D1C(uint64_t a1)
{
}

_BYTE *sub_1005E3D24(uint64_t a1)
{
  char v9 = 0;
  sub_100242CA4(&v9);
  if (sub_1001BEB38())
  {
    sub_1001BA4B8(0x200000LL);
    sub_100242CD0(&v9);
    uint64_t v2 = 0LL;
    uint64_t v3 = 167LL;
    do
    {
      if (*(_BYTE *)(a1 + v3))
      {
        uint64_t v4 = (os_log_s *)qword_1008F75B8;
        if (os_log_type_enabled((os_log_t)qword_1008F75B8, OS_LOG_TYPE_INFO))
        {
          __int128 v5 = @"UNKNOWN";
          *(_DWORD *)__int128 buf = 138412290;
          unint64_t v11 = v5;
          _os_log_impl((void *)&_mh_execute_header, v4, OS_LOG_TYPE_INFO, "Destroying stale ADVBUFF(%@):", buf, 0xCu);
        }

        sub_1005E3ED4(a1, v2);
      }

      ++v2;
      v3 += 544LL;
    }

    while (v2 != 3);
    *(_BYTE *)(a1 + 4384) = 0;
    uint64_t v6 = sub_100404FE8();
    v8[0] = _NSConcreteStackBlock;
    v8[1] = 3221225472LL;
    void v8[2] = sub_1005E4320;
    void v8[3] = &unk_10087EB20;
    v8[4] = a1;
    sub_1004054B4(v6, v8);
  }

  return sub_100242CD8(&v9);
}

void sub_1005E3EB4( _Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, int a16, __int16 a17, char a18, char a19)
{
}

uint64_t sub_1005E3ED4(uint64_t a1, uint64_t a2)
{
  if (qword_1008F1F08 != -1) {
    dispatch_once(&qword_1008F1F08, &stru_1008A3D48);
  }
  if (a2 < 3)
  {
    uint64_t v6 = a1 + 544LL * a2;
    int v8 = *(unsigned __int8 *)(v6 + 167);
    uint64_t v7 = v6 + 167;
    *(_BYTE *)(v7 + 4) = 0;
    *(_WORD *)(v7 + 2) = 0;
    if (v8)
    {
      if (a2 <= 1 && byte_1008F1F00)
      {
        uint64_t v9 = sub_1002E6E9C();
        int v10 = (*(uint64_t (**)(uint64_t))(*(void *)v9 + 2312LL))(v9);
        __int16 v31 = 0;
        int v30 = 0;
        if (v10)
        {
          char v11 = v10;
          unint64_t v12 = 0LL;
          uint64_t v13 = a1 + 544LL * a2 + 228;
          do
          {
            if (*(_WORD *)(v13 - 34))
            {
              uint64_t v14 = sub_1002E6E9C();
              BYTE2(v29) = *(_BYTE *)(v13 - 28);
              LOWORD(v29) = *(_WORD *)(v13 - 30);
              int v15 = (*(uint64_t (**)(uint64_t, uint64_t, void, int *, void, void, void, void, int, uint64_t, uint64_t))(*(void *)v14 + 2792LL))( v14,  a2,  *(unsigned __int8 *)(v13 - 36),  &v30,  *(unsigned __int8 *)(v13 - 35),  *(unsigned __int16 *)(v13 - 34),  *(unsigned __int8 *)(v13 - 32),  *(unsigned __int8 *)(v13 - 31),  v29,  v13 - 27,  v13);
              if (v15)
              {
                int v16 = v15;
                __int128 v17 = (os_log_s *)qword_1008F75B8;
                if (os_log_type_enabled((os_log_t)qword_1008F75B8, OS_LOG_TYPE_ERROR))
                {
                  uint64_t v18 = off_1008A4258[(char)a2];
                  *(_DWORD *)__int128 buf = 138543618;
                  uint64_t v33 = v18;
                  __int16 v34 = 1024;
                  int v35 = v16;
                  _os_log_error_impl( (void *)&_mh_execute_header,  v17,  OS_LOG_TYPE_ERROR,  "ADVBUFF(%{public}@): Failed to remove ext buffer adv rule: %d",  buf,  0x12u);
                }
              }

              else
              {
                --v11;
              }
            }

            if (v12 > 6) {
              break;
            }
            ++v12;
            v13 += 64LL;
          }

          while (v11);
        }

        uint64_t v19 = sub_1002E6E9C();
        (*(void (**)(uint64_t, uint64_t))(*(void *)v19 + 2800LL))(v19, a2);
      }

      __int128 v20 = (os_log_s *)qword_1008F75B8;
      if (os_log_type_enabled((os_log_t)qword_1008F75B8, OS_LOG_TYPE_INFO))
      {
        uint64_t v21 = off_1008A4258[(char)a2];
        *(_DWORD *)__int128 buf = 138543362;
        uint64_t v33 = v21;
        _os_log_impl( (void *)&_mh_execute_header,  v20,  OS_LOG_TYPE_INFO,  "ADVBUFF(%{public}@): Destroying ADV buffer",  buf,  0xCu);
      }

      uint64_t v24 = sub_1002E6E9C();
      uint64_t v5 = (*(uint64_t (**)(uint64_t, uint64_t, void, void))(*(void *)v24 + 2840LL))(v24, a2, 0LL, 0LL);
      char v25 = (os_log_s *)qword_1008F75B8;
      if (os_log_type_enabled((os_log_t)qword_1008F75B8, OS_LOG_TYPE_INFO))
      {
        __int128 v26 = off_1008A4258[(char)a2];
        *(_DWORD *)__int128 buf = 138543618;
        uint64_t v33 = v26;
        __int16 v34 = 1024;
        int v35 = v5;
        _os_log_impl( (void *)&_mh_execute_header,  v25,  OS_LOG_TYPE_INFO,  "ADVBUFF(%{public}@): advBufControl Disabled returned %d",  buf,  0x12u);
      }

      if ((_DWORD)v5)
      {
        if (os_log_type_enabled((os_log_t)qword_1008F75B8, OS_LOG_TYPE_ERROR)) {
          sub_10069B820();
        }
      }

      else
      {
        *(_BYTE *)uint64_t v7 = 0;
        uint64_t v27 = a1 + 544LL * a2;
        *(_BYTE *)(v27 + 168) = 0;
        *(_BYTE *)(v27 + 172) = -1;
      }
    }

    else
    {
      uint64_t v22 = (os_log_s *)qword_1008F75B8;
      if (os_log_type_enabled((os_log_t)qword_1008F75B8, OS_LOG_TYPE_INFO))
      {
        uint64_t v23 = off_1008A4258[(char)a2];
        *(_DWORD *)__int128 buf = 138543362;
        uint64_t v33 = v23;
        uint64_t v5 = 12LL;
        _os_log_impl( (void *)&_mh_execute_header,  v22,  OS_LOG_TYPE_INFO,  "ADVBUFF(%{public}@): destroyADVBuffer - not created",  buf,  0xCu);
      }

      else
      {
        return 12LL;
      }
    }
  }

  else
  {
    uint64_t v4 = (os_log_s *)qword_1008F75B8;
    if (os_log_type_enabled((os_log_t)qword_1008F75B8, OS_LOG_TYPE_DEFAULT))
    {
      *(_DWORD *)__int128 buf = 67109120;
      LODWORD(v33) = a2;
      _os_log_impl( (void *)&_mh_execute_header,  v4,  OS_LOG_TYPE_DEFAULT,  "HW ADV Buffer handle out of range (%d), ignoring agent request",  buf,  8u);
    }

    return 7LL;
  }

  return v5;
}

void sub_1005E4320(uint64_t a1)
{
  uint64_t v1 = *(void *)(a1 + 32);
  *(_DWORD *)(v1 + 1960) = 1;
  *(void *)(v1 + 1840) = 0LL;
  *(_DWORD *)(v1 + 1847) = 0;
  uint64_t v2 = sub_1002E6E9C();
  sub_1002D0870(v2, v1 + 8);
  uint64_t v3 = sub_1002E6E9C();
  (*(void (**)(uint64_t, uint64_t))(*(void *)v3 + 624LL))(v3, 1LL);
  uint64_t v4 = sub_1002E6E9C();
  (*(void (**)(uint64_t, uint64_t))(*(void *)v4 + 976LL))(v4, 1LL);
  int v15 = 0LL;
  int v16 = 0LL;
  uint64_t v17 = 0LL;
  uint64_t v5 = (void (***)(void, void **))sub_1002E6C74();
  (**v5)(v5, &v15);
  uint64_t v6 = (uint64_t *)v15;
  if (v15 != v16)
  {
    while (1)
    {
      uint64_t v7 = *v6;
      v22[0] = 0LL;
      v22[1] = 0LL;
      uint64_t v8 = sub_1002E6C74();
      int v9 = (*(uint64_t (**)(uint64_t, uint64_t, uint64_t, void *))(*(void *)v8 + 96LL))(v8, v7, 3LL, v22);
      int v10 = (os_log_s *)qword_1008F75B8;
      if (os_log_type_enabled((os_log_t)qword_1008F75B8, OS_LOG_TYPE_DEFAULT))
      {
        sub_1003CF00C(v7, __p);
        char v11 = __p;
        if (v14 < 0) {
          char v11 = (void **)__p[0];
        }
        *(_DWORD *)__int128 buf = 136446466;
        uint64_t v19 = v11;
        __int16 v20 = 1024;
        int v21 = v9;
        _os_log_impl( (void *)&_mh_execute_header,  v10,  OS_LOG_TYPE_DEFAULT,  "Read encryption key for device %{public}s : result %d",  buf,  0x12u);
        if (v14 < 0) {
          break;
        }
      }

      if (!v9) {
        goto LABEL_7;
      }
LABEL_9:
      if (++v6 == v16) {
        goto LABEL_10;
      }
    }

    operator delete(__p[0]);
    if (v9) {
      goto LABEL_9;
    }
LABEL_7:
    LOBYTE(__p[0]) = 0;
    *(_DWORD *)((char *)__p + 1) = *(_DWORD *)(v7 + 128);
    *(_WORD *)((char *)__p + 5) = *(_WORD *)(v7 + 132);
    sub_1005E459C(v1, (unsigned __int8 *)__p, (uint64_t)v22);
    goto LABEL_9;
  }

void sub_1005E4574( _Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, void *__p, uint64_t a15)
{
  if (__p) {
    operator delete(__p);
  }
  _Unwind_Resume(exception_object);
}

void sub_1005E459C(uint64_t a1, unsigned __int8 *a2, uint64_t a3)
{
  if (a2)
  {
    if (a3)
    {
      uint64_t v5 = a2 + 1;
      id v6 = sub_1005BFB9C(((unint64_t)a2[1] << 40) | ((unint64_t)a2[2] << 32) | ((unint64_t)a2[3] << 24) | ((unint64_t)a2[4] << 16) | ((unint64_t)a2[5] << 8) | a2[6] | ((unint64_t)*a2 << 48));
      uint64_t v7 = (void *)objc_claimAutoreleasedReturnValue(v6);
      if (![v7 length])
      {
        if (os_log_type_enabled((os_log_t)qword_1008F75B8, OS_LOG_TYPE_ERROR)) {
          sub_10069B908();
        }
        goto LABEL_42;
      }

      uint64_t v8 = (void *)objc_claimAutoreleasedReturnValue(+[NSData dataWithBytes:length:](&OBJC_CLASS___NSData, "dataWithBytes:length:", a3, 16LL));
      [*(id *)(a1 + 2088) setObject:v8 forKeyedSubscript:v7];

      if (qword_1008D5F50 != -1) {
        dispatch_once(&qword_1008D5F50, &stru_1008A4158);
      }
      LODWORD(v21) = *(_DWORD *)v5;
      WORD2(v21) = *((_WORD *)v5 + 2);
      int v9 = sub_1003FFEB0(off_1008D5F48, (uint64_t)&v21, 1);
      if (!v9)
      {
LABEL_42:

        return;
      }

      uint64_t v21 = 0LL;
      uint64_t v22 = 0LL;
      uint64_t v23 = 0LL;
      uint64_t v10 = v21;
      unint64_t v11 = 0xAAAAAAAAAAAAAAABLL * ((v22 - v21) >> 3);
      if (v11 < 4) {
        goto LABEL_41;
      }
      uint64_t v12 = (void *)(v21 + 72);
      if (*(char *)(v21 + 95) < 0)
      {
        if (*(void *)(v21 + 80) <= 1uLL) {
          goto LABEL_23;
        }
        uint64_t v12 = (void *)*v12;
      }

      else if (*(unsigned __int8 *)(v21 + 95) <= 1u)
      {
        goto LABEL_23;
      }

      uint64_t v13 = (void *)objc_claimAutoreleasedReturnValue(+[NSString stringWithUTF8String:](&OBJC_CLASS___NSString, "stringWithUTF8String:", v12));
      if ([v13 length])
      {
        char v14 = (void *)objc_claimAutoreleasedReturnValue(+[NSData dataWithBytes:length:](&OBJC_CLASS___NSData, "dataWithBytes:length:", a3, 16LL));
        [*(id *)(a1 + 2088) setObject:v14 forKeyedSubscript:v13];
      }

      uint64_t v10 = v21;
      unint64_t v11 = 0xAAAAAAAAAAAAAAABLL * ((v22 - v21) >> 3);
LABEL_23:
      if (v11 < 9) {
        goto LABEL_41;
      }
      int v15 = (void *)(v10 + 192);
      if (*(char *)(v10 + 215) < 0)
      {
        if (*(void *)(v10 + 200) <= 1uLL) {
          goto LABEL_32;
        }
        int v15 = (void *)*v15;
      }

      else if (*(unsigned __int8 *)(v10 + 215) <= 1u)
      {
        goto LABEL_32;
      }

      int v16 = (void *)objc_claimAutoreleasedReturnValue(+[NSString stringWithUTF8String:](&OBJC_CLASS___NSString, "stringWithUTF8String:", v15));
      if ([v16 length])
      {
        uint64_t v17 = (void *)objc_claimAutoreleasedReturnValue(+[NSData dataWithBytes:length:](&OBJC_CLASS___NSData, "dataWithBytes:length:", a3, 16LL));
        [*(id *)(a1 + 2088) setObject:v17 forKeyedSubscript:v16];
      }

      uint64_t v10 = v21;
      unint64_t v11 = 0xAAAAAAAAAAAAAAABLL * ((v22 - v21) >> 3);
LABEL_32:
      if (v11 >= 0xA)
      {
        uint64_t v18 = (void *)(v10 + 216);
        if ((*(char *)(v10 + 239) & 0x80000000) == 0)
        {
LABEL_38:
          uint64_t v19 = (void *)objc_claimAutoreleasedReturnValue(+[NSString stringWithUTF8String:](&OBJC_CLASS___NSString, "stringWithUTF8String:", v18));
          if ([v19 length])
          {
            __int16 v20 = (void *)objc_claimAutoreleasedReturnValue(+[NSData dataWithBytes:length:](&OBJC_CLASS___NSData, "dataWithBytes:length:", a3, 16LL));
            [*(id *)(a1 + 2088) setObject:v20 forKeyedSubscript:v19];
          }

          goto LABEL_41;
        }

        if (*(void *)(v10 + 224) > 1uLL)
        {
          uint64_t v18 = (void *)*v18;
          goto LABEL_38;
        }
      }

void sub_1005E4914( _Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, void **a12)
{
  a12 = (void **)&a9;
  sub_100024304(&a12);

  _Unwind_Resume(a1);
}

id sub_1005E4988(uint64_t a1)
{
  *(void *)(a1 + 4328) = a1 + 4336;
  *(void *)(a1 + 4344) = 0LL;
  *(void *)(a1 + 4336) = 0LL;
  sub_10023BF24(a1 + 4304, *(void **)(a1 + 4312));
  *(void *)(a1 + 4304) = a1 + 4312;
  *(void *)(a1 + 4320) = 0LL;
  *(void *)(a1 + 4312) = 0LL;
  [*(id *)(a1 + 4352) removeAllObjects];
  [*(id *)(a1 + 4360) removeAllObjects];
  id result = [*(id *)(a1 + 4368) removeAllObjects];
  *(_DWORD *)(a1 + 4376) = 0;
  return result;
}

_BYTE *sub_1005E4A08(uint64_t a1)
{
  return sub_1005E3D24(a1 - 16);
}

void sub_1005E4A10(uint64_t a1)
{
  if (qword_1008F1EC0 != -1) {
    dispatch_once(&qword_1008F1EC0, &stru_1008A39B0);
  }
  if (!*(void *)(a1 + 2200))
  {
    uint64_t v2 = sub_1002E91F8(2LL, 4LL, byte_1008F1EB8);
    *(void *)(a1 + 2200) = v2;
    if (v2)
    {
      uint64_t v3 = v2;
      uint64_t v4 = (os_log_s *)qword_1008F7668;
      if (os_log_type_enabled((os_log_t)qword_1008F7668, OS_LOG_TYPE_DEFAULT))
      {
        uint64_t v5 = (*(uint64_t (**)(void *))(*(void *)v3 + 16LL))(v3);
        int v6 = 136446210;
        uint64_t v7 = v5;
        _os_log_impl((void *)&_mh_execute_header, v4, OS_LOG_TYPE_DEFAULT, "Creating %{public}s", (uint8_t *)&v6, 0xCu);
      }
    }
  }

void sub_1005E4B14(id a1)
{
  uint64_t v1 = sub_1002E6E00();
  sub_10002418C(v4, "POWER");
  sub_10002418C(__p, "ForceWakeScanForClient");
  (*(void (**)(uint64_t, void **, void **, char *))(*(void *)v1 + 72LL))(v1, v4, __p, &byte_1008F1EB8);
  if (v3 < 0) {
    operator delete(__p[0]);
  }
  if (v5 < 0) {
    operator delete(v4[0]);
  }
}

void sub_1005E4B9C( _Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, void *__p, uint64_t a10, int a11, __int16 a12, char a13, char a14, void *a15, uint64_t a16, int a17, __int16 a18, char a19, char a20)
{
  if (a14 < 0) {
    operator delete(__p);
  }
  if (a20 < 0) {
    operator delete(a15);
  }
  _Unwind_Resume(exception_object);
}

void sub_1005E4BD0(uint64_t a1)
{
  uint64_t v1 = *(void *)(a1 + 2200);
  if (v1)
  {
    char v3 = (os_log_s *)qword_1008F7668;
    if (!os_log_type_enabled((os_log_t)qword_1008F7668, OS_LOG_TYPE_DEFAULT)
      || (uint64_t v4 = (*(uint64_t (**)(uint64_t))(*(void *)v1 + 16LL))(v1),
          int v5 = 136446210,
          uint64_t v6 = v4,
          _os_log_impl( (void *)&_mh_execute_header,  v3,  OS_LOG_TYPE_DEFAULT,  "Destroying %{public}s",  (uint8_t *)&v5,  0xCu),  (uint64_t v1 = *(void *)(a1 + 2200)) != 0))
    {
      (*(void (**)(uint64_t))(*(void *)v1 + 8LL))(v1);
    }

    *(void *)(a1 + 2200) = 0LL;
  }

void sub_1005E4CAC(uint64_t a1)
{
  if (qword_1008F1ED0 != -1) {
    dispatch_once(&qword_1008F1ED0, &stru_1008A39D0);
  }
  uint64_t v2 = sub_1002E6E9C();
  if ((*(unsigned int (**)(uint64_t))(*(void *)v2 + 3448LL))(v2))
  {
    if (!*(void *)(a1 + 2208))
    {
      char v3 = sub_1002E91F8(2LL, 5LL, byte_1008F1EC8);
      *(void *)(a1 + 2208) = v3;
      if (v3)
      {
        uint64_t v4 = v3;
        int v5 = (os_log_s *)qword_1008F7668;
        if (os_log_type_enabled((os_log_t)qword_1008F7668, OS_LOG_TYPE_DEFAULT))
        {
          uint64_t v6 = (*(uint64_t (**)(void *))(*(void *)v4 + 16LL))(v4);
          int v7 = 136446210;
          uint64_t v8 = v6;
          _os_log_impl( (void *)&_mh_execute_header,  v5,  OS_LOG_TYPE_DEFAULT,  "Creating %{public}s",  (uint8_t *)&v7,  0xCu);
        }
      }
    }
  }

  sub_1005E4E90(a1);
}

void sub_1005E4DD4(id a1)
{
  uint64_t v1 = sub_1002E6E00();
  sub_10002418C(v4, "POWER");
  sub_10002418C(__p, "ForceWakeScanConfig");
  (*(void (**)(uint64_t, void **, void **, char *))(*(void *)v1 + 72LL))(v1, v4, __p, &byte_1008F1EC8);
  if (v3 < 0) {
    operator delete(__p[0]);
  }
  if (v5 < 0) {
    operator delete(v4[0]);
  }
}

void sub_1005E4E5C( _Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, void *__p, uint64_t a10, int a11, __int16 a12, char a13, char a14, void *a15, uint64_t a16, int a17, __int16 a18, char a19, char a20)
{
  if (a14 < 0) {
    operator delete(__p);
  }
  if (a20 < 0) {
    operator delete(a15);
  }
  _Unwind_Resume(exception_object);
}

void sub_1005E4E90(uint64_t a1)
{
  if (*(double *)(a1 + 2712) == 0.0)
  {
    *(CFAbsoluteTime *)(a1 + 2712) = CFAbsoluteTimeGetCurrent();
    unsigned int v2 = *(unsigned __int8 *)(a1 + 144);
    *(_BYTE *)(a1 + 2720) = v2;
    ++*(_DWORD *)(a1 + 176LL * v2 + 2448);
    if (*(_BYTE *)(a1 + 1841))
    {
      uint64_t v3 = a1 + 176LL * v2;
      ++*(_DWORD *)(v3 + 2452);
      uint64_t v4 = (_DWORD *)(v3 + 2456);
    }

    else
    {
      uint64_t v4 = (_DWORD *)(a1 + 176LL * v2 + 2464);
    }

    ++*v4;
    if (*(_BYTE *)(a1 + 1843)) {
      ++*(_DWORD *)(a1 + 176LL * v2 + 2472);
    }
    if (*(_BYTE *)(a1 + 1844)) {
      ++*(_DWORD *)(a1 + 176LL * v2 + 2480);
    }
    if (*(_BYTE *)(a1 + 1845)) {
      ++*(_DWORD *)(a1 + 176LL * v2 + 2484);
    }
    if (*(_BYTE *)(a1 + 1846)) {
      ++*(_DWORD *)(a1 + 176LL * v2 + 2476);
    }
    if (*(_BYTE *)(a1 + 1847)) {
      ++*(_DWORD *)(a1 + 176LL * v2 + 2488);
    }
    if (*(_BYTE *)(a1 + 2721)) {
      ++*(_DWORD *)(a1 + 176LL * v2 + 2508);
    }
    if (*(_BYTE *)(a1 + 2722)) {
      ++*(_DWORD *)(a1 + 176LL * v2 + 2520);
    }
  }

  else if (os_log_type_enabled((os_log_t)qword_1008F75B8, OS_LOG_TYPE_DEBUG))
  {
    sub_10069B934();
  }

void sub_1005E5004(uint64_t a1)
{
  uint64_t v2 = sub_1002E6E9C();
  if ((*(unsigned int (**)(uint64_t))(*(void *)v2 + 3448LL))(v2))
  {
    uint64_t v3 = *(void *)(a1 + 2208);
    if (v3)
    {
      uint64_t v4 = (os_log_s *)qword_1008F7668;
      if (!os_log_type_enabled((os_log_t)qword_1008F7668, OS_LOG_TYPE_DEFAULT)
        || (uint64_t v5 = (*(uint64_t (**)(uint64_t))(*(void *)v3 + 16LL))(v3),
            int v6 = 136446210,
            uint64_t v7 = v5,
            _os_log_impl( (void *)&_mh_execute_header,  v4,  OS_LOG_TYPE_DEFAULT,  "Destroying %{public}s",  (uint8_t *)&v6,  0xCu),  (uint64_t v3 = *(void *)(a1 + 2208)) != 0))
      {
        (*(void (**)(uint64_t))(*(void *)v3 + 8LL))(v3);
      }

      *(void *)(a1 + 2208) = 0LL;
    }
  }

  sub_1005E50FC(a1);
}

void sub_1005E50FC(uint64_t a1)
{
  if (*(double *)(a1 + 2712) != 0.0)
  {
    double Current = CFAbsoluteTimeGetCurrent();
    double v3 = *(double *)(a1 + 2712);
    if (Current <= v3) {
      unsigned int v4 = 0;
    }
    else {
      unsigned int v4 = ((Current - v3) * 1000.0);
    }
    unsigned int v5 = *(unsigned __int8 *)(a1 + 2720);
    if (os_log_type_enabled((os_log_t)qword_1008F75B8, OS_LOG_TYPE_DEBUG)) {
      sub_10069B964();
    }
    uint64_t v6 = a1 + 176LL * v5;
    unsigned int v7 = v4 / 0xA;
    if (v4 > 0xC7) {
      unsigned int v7 = 19;
    }
    uint64_t v8 = v6 + 4LL * v7;
    __int16 v9 = v4;
    unsigned int v10 = *(unsigned __int16 *)(v6 + 2492);
    *(_WORD *)(v6 + 2492) = v10;
    *(_WORD *)(v6 + 2494) = v9;
    ++*(_DWORD *)(v8 + 2368);
    if (*(_BYTE *)(a1 + 2721)) {
      *(_DWORD *)(a1 + 176LL * v5 + 2512) += v4;
    }
    if (*(_BYTE *)(a1 + 2722)) {
      *(_DWORD *)(a1 + 176LL * v5 + 2524) += v4;
    }
    *(_DWORD *)(a1 + 2719) = 0;
    *(void *)(a1 + 2712) = 0LL;
  }

_BYTE *sub_1005E521C(uint64_t a1)
{
  uint64_t v2 = (os_log_s *)qword_1008F75B8;
  if (os_log_type_enabled((os_log_t)qword_1008F75B8, OS_LOG_TYPE_DEFAULT))
  {
    *(_WORD *)__int128 buf = 0;
    _os_log_impl((void *)&_mh_execute_header, v2, OS_LOG_TYPE_DEFAULT, "LeObserver::stackWillStop enter", buf, 2u);
  }

  char v7 = 0;
  sub_100242CA4(&v7);
  if (sub_1001BEB38())
  {
    sub_1001BA4B8(0LL);
    sub_100242CD0(&v7);
    uint64_t v3 = sub_100404FE8();
    v6[0] = _NSConcreteStackBlock;
    v6[1] = 3221225472LL;
    void v6[2] = sub_1005E5344;
    uint64_t v6[3] = &unk_10087EB20;
    void v6[4] = a1;
    sub_1004054B4(v3, v6);
    unsigned int v4 = (os_log_s *)qword_1008F75B8;
    if (os_log_type_enabled((os_log_t)qword_1008F75B8, OS_LOG_TYPE_DEFAULT))
    {
      *(_WORD *)__int128 buf = 0;
      _os_log_impl((void *)&_mh_execute_header, v4, OS_LOG_TYPE_DEFAULT, "LeObserver::stackWillStop exit", buf, 2u);
    }
  }

  return sub_100242CD8(&v7);
}

void sub_1005E5330( _Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, int a14, __int16 a15, char a16, char a17)
{
}

void sub_1005E5344(uint64_t a1)
{
  uint64_t v1 = *(void *)(a1 + 32);
  uint64_t v2 = sub_1002E8D54();
  sub_10024E060(v2 + 368, v1 + 40);
  uint64_t v3 = sub_1002E6E9C();
  (*(void (**)(uint64_t, void))(*(void *)v3 + 624LL))(v3, 0LL);
  uint64_t v4 = sub_1002E6E9C();
  sub_1002D08D4(v4, v1 + 8);
  sub_1005E5470(v1);
  unsigned int v5 = *(void **)(v1 + 2112);
  *(void *)(v1 + 2112) = 0LL;

  uint64_t v6 = *(void **)(v1 + 2120);
  *(void *)(v1 + 2120) = 0LL;

  *(void *)(v1 + 1960) = 0LL;
  char v7 = *(void **)(v1 + 2040);
  uint64_t v8 = (void *)(v1 + 2048);
  if (v7 != (void *)(v1 + 2048))
  {
    do
    {
      uint64_t v9 = v7[5];
      if (v9) {
        (*(void (**)(uint64_t))(*(void *)v9 + 8LL))(v9);
      }
      unsigned int v10 = (void *)v7[1];
      if (v10)
      {
        do
        {
          unint64_t v11 = v10;
          unsigned int v10 = (void *)*v10;
        }

        while (v10);
      }

      else
      {
        do
        {
          unint64_t v11 = (void *)v7[2];
          BOOL v12 = *v11 == (void)v7;
          char v7 = v11;
        }

        while (!v12);
      }

      char v7 = v11;
    }

    while (v11 != v8);
  }

  sub_10023BF24(v1 + 2040, *(void **)(v1 + 2048));
  *(void *)(v1 + 2040) = v8;
  *(_OWORD *)(v1 + 2048) = 0u;
  sub_10060EF64(v1 + 2064, *(void **)(v1 + 2072));
  *(void *)(v1 + 2064) = v1 + 2072;
  *(void *)(v1 + 2080) = 0LL;
  *(void *)(v1 + 2072) = 0LL;
  sub_1005E4BD0(v1);
  sub_1005E569C((dispatch_object_t *)v1);
  sub_1005E5004(v1);
  sub_10043CB4C(v1 + 56);
}

uint64_t sub_1005E5470(uint64_t a1)
{
  uint64_t v2 = (os_log_s *)qword_1008F75B8;
  if (os_log_type_enabled((os_log_t)qword_1008F75B8, OS_LOG_TYPE_INFO))
  {
    *(_WORD *)__int128 buf = 0;
    _os_log_impl( (void *)&_mh_execute_header,  v2,  OS_LOG_TYPE_INFO,  "Destroying match table for all registered types",  buf,  2u);
  }

  uint64_t v3 = *(void **)(a1 + 1816);
  uint64_t v17 = a1;
  uint64_t v4 = (void *)(a1 + 1824);
  if (v3 != (void *)(a1 + 1824))
  {
    unsigned int v5 = (uint64_t **)(a1 + 1816);
    do
    {
      int v6 = *((unsigned __int8 *)v3 + 28);
      char v7 = *((_BYTE *)v3 + 29);
      int v8 = *((unsigned __int16 *)v3 + 15);
      int v9 = *((unsigned __int16 *)v3 + 18);
      __int16 v10 = *((_WORD *)v3 + 19);
      unint64_t v11 = (os_log_s *)qword_1008F75B8;
      if (os_log_type_enabled((os_log_t)qword_1008F75B8, OS_LOG_TYPE_DEBUG))
      {
        *(_DWORD *)__int128 buf = 67109632;
        *(_DWORD *)&uint8_t buf[4] = v8;
        __int16 v20 = 1024;
        int v21 = v6;
        __int16 v22 = 1024;
        int v23 = v9;
        _os_log_debug_impl( (void *)&_mh_execute_header,  v11,  OS_LOG_TYPE_DEBUG,  "handle:%d type:%d length:%d setCreated(false) setEnabled(false)",  buf,  0x14u);
      }

      unsigned __int8 v18 = v8;
      *(void *)__int128 buf = &v18;
      BOOL v12 = sub_10060F298(v5, &v18, (uint64_t)&unk_1006C2518, (char **)buf);
      *((_BYTE *)v12 + 28) = v6;
      *((_BYTE *)v12 + 29) = v7;
      *((_WORD *)v12 + 15) = v8;
      *((_DWORD *)v12 + 8) = 0;
      *((_WORD *)v12 + 18) = v9;
      *((_WORD *)v12 + 19) = v10;
      uint64_t v13 = (void *)v3[1];
      if (v13)
      {
        do
        {
          char v14 = v13;
          uint64_t v13 = (void *)*v13;
        }

        while (v13);
      }

      else
      {
        do
        {
          char v14 = (void *)v3[2];
          BOOL v15 = *v14 == (void)v3;
          uint64_t v3 = v14;
        }

        while (!v15);
      }

      uint64_t v3 = v14;
    }

    while (v14 != v4);
  }

  if (qword_1008D6628 != -1) {
    dispatch_once(&qword_1008D6628, &stru_1008A4098);
  }
  sub_100333DE0(qword_1008D6620, &off_1008C3110);
  *(_BYTE *)(v17 + 1855) = 0;
  sub_1005FC17C((double *)v17, 22, 0);
  return 0LL;
}

uint64_t sub_1005E569C(dispatch_object_t *a1)
{
  uint64_t v2 = (os_log_s *)qword_1008F76D8;
  if (os_log_type_enabled((os_log_t)qword_1008F76D8, OS_LOG_TYPE_DEFAULT))
  {
    LOWORD(v8[0]) = 0;
    _os_log_impl( (void *)&_mh_execute_header,  v2,  OS_LOG_TYPE_DEFAULT,  "Disarming contactTracing timers",  (uint8_t *)v8,  2u);
  }

  if (qword_1008D9700 != -1) {
    dispatch_once(&qword_1008D9700, &stru_1008A40D8);
  }
  sub_1003AC150((uint64_t)off_1008D96F8);
  uint64_t v3 = sub_100404FE8();
  v8[0] = _NSConcreteStackBlock;
  v8[1] = 3221225472LL;
  void v8[2] = sub_1006004B4;
  void v8[3] = &unk_10087EB20;
  v8[4] = a1;
  sub_100405384(v3, v8);
  sub_1006003D8((uint64_t)a1);
  uint64_t v4 = (dispatch_source_s *)a1[284];
  if (v4)
  {
    dispatch_source_cancel(v4);
    dispatch_release(a1[284]);
    a1[284] = 0LL;
  }

  unsigned int v5 = (dispatch_source_s *)a1[282];
  if (v5)
  {
    dispatch_source_cancel(v5);
    dispatch_release(a1[282]);
    a1[282] = 0LL;
  }

  int v6 = (dispatch_source_s *)a1[283];
  if (v6)
  {
    dispatch_source_cancel(v6);
    dispatch_release(a1[283]);
    a1[283] = 0LL;
  }

  return xpc_set_event("com.apple.alarm", "com.apple.bluetooth.contactTracingScanSystemWake", 0LL);
}

_BYTE *sub_1005E57DC(uint64_t a1)
{
  return sub_1005E521C(a1 - 16);
}

uint64_t sub_1005E57E4(uint64_t a1, int a2)
{
  int v3 = *(_DWORD *)(a1 + 2292);
  if (v3)
  {
    int v4 = a2 + v3;
    BOOL v5 = __OFADD__(a2, v3);
    if (v3 > 0) {
      char v6 = 127;
    }
    else {
      char v6 = 0x80;
    }
    if (v5) {
      LOBYTE(v4) = v6;
    }
    else {
      char v7 = v4;
    }
    int v8 = (os_log_s *)qword_1008F75B8;
    if (os_log_type_enabled((os_log_t)qword_1008F75B8, OS_LOG_TYPE_DEFAULT))
    {
      v10[0] = 67109632;
      v10[1] = v3;
      __int16 v11 = 1024;
      int v12 = a2;
      __int16 v13 = 1024;
      int v14 = v7;
      _os_log_impl( (void *)&_mh_execute_header,  v8,  OS_LOG_TYPE_DEFAULT,  "Warning: Applying RSSI offset of %d to %d, new rssi level is %d",  (uint8_t *)v10,  0x14u);
    }
  }

  else
  {
    return (char)a2;
  }

  return v7;
}

void sub_1005E58EC(uint64_t a1, __int128 *a2)
{
  __int128 v2 = a2[1];
  __int128 v5 = *a2;
  __int128 v6 = v2;
  __int128 v7 = a2[2];
  uint64_t v8 = *((void *)a2 + 6);
  uint64_t v3 = sub_100404FE8();
  v4[0] = _NSConcreteStackBlock;
  v4[1] = 3221225472LL;
  _DWORD v4[2] = sub_1005E5980;
  v4[3] = &unk_10089D260;
  sub_100405384(v3, v4);
}

void sub_1005E5980(uint64_t a1)
{
  __int128 v2 = *(_OWORD *)(a1 + 48);
  v35[0] = *(_OWORD *)(a1 + 32);
  v35[1] = v2;
  __int128 v36 = *(_OWORD *)(a1 + 64);
  uint64_t v37 = *(void *)(a1 + 80);
  uint64_t v3 = (os_log_s *)qword_1008F75B8;
  if (os_log_type_enabled((os_log_t)qword_1008F75B8, OS_LOG_TYPE_DEBUG)) {
    sub_10069BAE4(a1 + 32, v3, v4);
  }
  unsigned int v5 = BYTE7(v36);
  __int128 v6 = (os_log_s *)qword_1008F75B8;
  BOOL v7 = os_log_type_enabled((os_log_t)qword_1008F75B8, OS_LOG_TYPE_DEBUG);
  if (BYTE7(v36))
  {
    if (v7)
    {
      uint64_t v12 = CUPrintAddress((char *)&v36 + 8, 6LL, 0LL);
      __int16 v13 = (void *)objc_claimAutoreleasedReturnValue(v12);
      *(_DWORD *)__int128 buf = 138413570;
      int v21 = v13;
      __int16 v22 = 1024;
      int v23 = BYTE7(v36);
      __int16 v24 = 1040;
      int v25 = 31;
      __int16 v26 = 2096;
      uint64_t v27 = (char *)v35 + 8;
      __int16 v28 = 1024;
      int v29 = SBYTE14(v36);
      __int16 v30 = 1024;
      int v31 = HIBYTE(v36);
      _os_log_debug_impl( (void *)&_mh_execute_header,  v6,  OS_LOG_TYPE_DEBUG,  "aopReceivedDeviceFoundEvent: Parsing entry, address:%@ len:%d payload:%.31P rssi:%d channel:%d",  buf,  0x2Eu);

      unsigned int v5 = BYTE7(v36);
    }

    if (v5 < 0x20)
    {
      bzero(buf, 0x1788uLL);
      __int128 v18 = 0u;
      __int128 v19 = 0u;
      __int128 v16 = 0u;
      __int128 v17 = 0u;
      __int128 v15 = 0u;
      sub_1001F0050((uint64_t)&v15 + 2, (uint64_t)&v36 + 8, 6uLL);
      unint64_t v8 = ((unint64_t)BYTE2(v15) << 40) | ((unint64_t)BYTE3(v15) << 32) | ((unint64_t)BYTE4(v15) << 24) | ((unint64_t)BYTE5(v15) << 16) | ((unint64_t)BYTE6(v15) << 8) | BYTE7(v15);
      if (v8 && (!HIWORD(v8) || HIWORD(v8) == 1 && (BYTE2(v15) & 0xC0) != 0x80LL))
      {
        LOWORD(v15) = 256;
        WORD4(v15) = BYTE7(v36);
        *(void *)&__int128 v16 = (char *)v35 + 8;
        BYTE11(v17) = 0;
        BYTE8(v16) = BYTE14(v36);
        char v14 = 0;
        sub_100242CA4(&v14);
        sub_1001BA69C((unsigned __int8 *)&v15, (uint64_t)buf, v10, v11);
        sub_100242CD0(&v14);
        BYTE2(v23) = 0;
        char v33 = 0;
        char v34 = 1;
        char v32 = 0;
        sub_1005E5C78(buf);
        sub_100242CD8(&v14);
      }

      else
      {
        int v9 = (os_log_s *)qword_1008F75B8;
        if (os_log_type_enabled((os_log_t)qword_1008F75B8, OS_LOG_TYPE_ERROR)) {
          sub_10069BA58(v8, v9);
        }
      }
    }

    else if (os_log_type_enabled((os_log_t)qword_1008F75B8, OS_LOG_TYPE_ERROR))
    {
      sub_10069B9F4();
    }
  }

  else if (v7)
  {
    sub_10069B9C4();
  }

void sub_1005E5C5C( _Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, int a10, __int16 a11, char a12, char a13)
{
}

void sub_1005E5C78(unsigned __int8 *a1)
{
  if (qword_1008F1EF0 != -1) {
    dispatch_once(&qword_1008F1EF0, &stru_1008A3C40);
  }
  __int128 v2 = operator new(0x1E0uLL);
  sub_10056B368((uint64_t)v2);
  __n128 v104 = &off_10087FAE8;
  int v105 = (unsigned int *)v2;
  double Current = CFAbsoluteTimeGetCurrent();
  unsigned int v5 = a1 + 5633;
  if (a1[5976])
  {
    LODWORD(v4) = *((_DWORD *)a1 + 1487);
    double v6 = (double)v4 * 312.5 / 1000000.0;
  }

  else
  {
    double v6 = 0.0;
  }

  *((_WORD *)v2 + 20) = *((_WORD *)a1 + 1280);
  *((_DWORD *)v2 + 111) = a1[5983] != 0;
  uint64_t v78 = (uint64_t)(a1 + 5633);
  BOOL v79 = a1;
  if (a1[5978])
  {
    v2[30] = *((void *)a1 + 744);
    uint64_t v7 = *((void *)a1 + 745);
  }

  else
  {
    *((double *)v2 + 30) = Current - v6;
    uint64_t v7 = mach_continuous_time() * dword_1008F1EE8 / *(unsigned int *)algn_1008F1EEC / 0x3E8;
    unsigned int v5 = a1 + 5633;
  }

  v2[31] = v7;
  if (qword_1008D6608 != -1) {
    dispatch_once(&qword_1008D6608, &stru_1008A3FF8);
  }
  a1[2555] = sub_1005E57E4((uint64_t)off_1008D6600, (char)a1[2555]);
  if (v5[344])
  {
    if (qword_1008D6608 != -1) {
      dispatch_once(&qword_1008D6608, &stru_1008A3FF8);
    }
    LODWORD(v8) = *((_DWORD *)a1 + 1502);
    double v9 = *((double *)off_1008D6600 + 158);
    unsigned int v10 = *((_DWORD *)a1 + 1503);
    *((double *)v2 + 47) = v9 + (double)(unsigned __int16)(60 * ((unsigned __int16)(int)((double)v8 * 0.02) / 0x3Cu));
    CFAbsoluteTime v11 = CFAbsoluteTimeGetCurrent();
    double v12 = v9 + (double)((unsigned __int16)(60 * ((unsigned __int16)(int)((double)v10 * 0.02) / 0x3Cu) + 60) & 0xFFFC);
    if (v11 < v12) {
      double v12 = CFAbsoluteTimeGetCurrent();
    }
    uint64_t v13 = 0LL;
    *((double *)v2 + 48) = v12;
    *((double *)v2 + 30) = v12;
    do
    {
      sub_10056C40C((uint64_t)v2, v13, a1[v13 + 6000]);
      ++v13;
    }

    while (v13 != 4);
    *((_WORD *)v2 + 198) = *(_WORD *)(v5 + 371);
  }

  *((_BYTE *)v2 + 12) = *a1 < 2u;
  *((_BYTE *)v2 + 13) = a1[2557];
  sub_10002418C(&__str, (char *)a1 + 2521);
  std::string::operator=((std::string *)(v2 + 2), &__str);
  if (*((char *)v2 + 39) < 0)
  {
    sub_100024238(buf, (void *)v2[2], v2[3]);
  }

  else
  {
    *(_OWORD *)__int128 buf = *((_OWORD *)v2 + 1);
    *(void *)&uint8_t buf[16] = v2[4];
  }

  if ((buf[23] & 0x80000000) != 0)
  {
    uint64_t v14 = *(void *)&buf[8];
    operator delete(*(void **)buf);
    if (!v14) {
      goto LABEL_31;
    }
  }

  else if (!buf[23])
  {
    goto LABEL_31;
  }

  unint64_t v15 = (char)*a1;
  if (v15 < 5 && ((0x1Du >> v15) & 1) != 0) {
    *((_DWORD *)v2 + 117) |= dword_1006C4740[v15];
  }
LABEL_31:
  if (a1[2554])
  {
    unsigned __int8 v16 = a1[2553];
    *((_BYTE *)v2 + 42) = 1;
    *((_BYTE *)v2 + 43) = v16;
  }

  sub_10056BBA4((uint64_t)v2, (char)a1[2555]);
  sub_10056AB04(buf, a1 + 5633, a1[5884]);
  sub_10002EAC8((uint64_t)(v2 + 6), (uint64_t)buf);
  __int128 v17 = a1 + 6016;
  __int128 v18 = v79 + 5068;
  *(void *)__int128 buf = &off_10087FAA8;
  if (*(void *)&buf[8]) {
    sub_1002CD254(*(unsigned int **)&buf[8]);
  }
  uint64_t v19 = 0LL;
  __int16 v20 = v79 + 5885;
  do
  {
    if (v20[v19]) {
      *(void *)((char *)v2 + (((unint64_t)v20[v19] >> 3) & 0x18) + 168) |= 1LL << v20[v19];
    }
    ++v19;
  }

  while (v19 != 20);
  int v21 = (os_log_s *)qword_1008F75B8;
  if (os_log_type_enabled((os_log_t)qword_1008F75B8, OS_LOG_TYPE_INFO))
  {
    p_p = &__p;
    sub_10056B0A4((uint64_t)(v2 + 6), &__p);
    if ((__p.__r_.__value_.__s.__size_ & 0x80u) != 0) {
      p_p = (std::stringbuf::string_type *)__p.__r_.__value_.__r.__words[0];
    }
    uint64_t v23 = sub_10056AAD8((uint64_t)(v2 + 6));
    int v24 = sub_1005FB07C((uint64_t)v2);
    *(_DWORD *)__int128 buf = 136315650;
    *(void *)&uint8_t buf[4] = p_p;
    *(_WORD *)&_BYTE buf[12] = 2048;
    *(void *)&buf[14] = v23;
    *(_WORD *)&_BYTE buf[22] = 1024;
    int v121 = v24;
    _os_log_impl((void *)&_mh_execute_header, v21, OS_LOG_TYPE_INFO, "Setting mfgr data:%s len:%zu id:%02X", buf, 0x1Cu);
  }

  int v25 = (unsigned __int8 *)v78;
  if (_os_feature_enabled_impl("BluetoothFeatures", "Type18ToPOSH"))
  {
    if (*(_BYTE *)(v78 + 347))
    {
      unint64_t v26 = *(unsigned __int8 *)(v78 + 251);
      if (v26 >= 3 && *(_WORD *)v78 == 76)
      {
        int v25 = (unsigned __int8 *)v78;
        if (sub_1001BA580(v78, v26, (uint64_t (*)(void))sub_1005FAF40))
        {
          if (os_log_type_enabled((os_log_t)qword_1008F75B8, OS_LOG_TYPE_ERROR))
          {
            sub_10069BB5C();
            int v25 = (unsigned __int8 *)v78;
          }
        }
      }
    }
  }

  if (v25[347] && (unint64_t v27 = v25[251], v27 >= 3))
  {
    if (v25[343])
    {
      buf[0] = 0;
      int v28 = sub_1001BA580((uint64_t)v25, v27, (uint64_t (*)(void))sub_1005FB040);
      int v29 = buf[0];
      uint64_t v30 = sub_1002E8D94();
      if (v28) {
        int v31 = 0;
      }
      else {
        int v31 = v29;
      }
      uint64_t v97 = 0LL;
      int v98 = v31;
      uint64_t v99 = 0LL;
      BOOL v100 = (v28 | v29) == 0;
      uint64_t v101 = 0LL;
      (*(void (**)(uint64_t, uint64_t *))(*(void *)v30 + 584LL))(v30, &v97);
    }

    int v32 = 1;
  }

  else
  {
    int v32 = 0;
  }

  *(_WORD *)((char *)v2 + 341) = *(_WORD *)(v78 + 338);
  sub_10056AB04(buf, v79 + 5914, *(unsigned __int8 *)(v78 + 312));
  sub_10002EAC8((uint64_t)(v2 + 28), (uint64_t)buf);
  *(void *)__int128 buf = &off_10087FAA8;
  if (*(void *)&buf[8]) {
    sub_1002CD254(*(unsigned int **)&buf[8]);
  }
  if (*v17 || (v79[6021] & 0x40) != 0)
  {
    sub_10056AB04(buf, v17, 6uLL);
    sub_10002EAC8((uint64_t)(v2 + 56), (uint64_t)buf);
    *(void *)__int128 buf = &off_10087FAA8;
    if (*(void *)&buf[8]) {
      sub_1002CD254(*(unsigned int **)&buf[8]);
    }
  }

  int v76 = v32;
  if (v79[2520])
  {
    unint64_t v33 = 0LL;
    char v34 = (__n128 *)(v79 + 20);
    do
    {
      memset(buf, 0, 20);
      __n128 v118 = *v34;
      unsigned __int32 v119 = v34[1].n128_u32[0];
      sub_100634334((__n128 *)buf, &v118);
      if (!*((_BYTE *)v2 + 338) && sub_1001BEC7C(v35, byte_1008F1E88)) {
        *((_BYTE *)v2 + 338) = 1;
      }
      sub_1004F022C(v2, (__int128 *)buf);
      ++v33;
      char v34 = (__n128 *)((char *)v34 + 20);
    }

    while (v33 < v79[2520]);
  }

  if (*v18)
  {
    unint64_t v36 = 0LL;
    uint64_t v37 = (__n128 *)(v79 + 2568);
    do
    {
      memset(buf, 0, 20);
      __n128 v116 = *v37;
      unsigned __int32 v117 = v37[1].n128_u32[0];
      sub_100634334((__n128 *)buf, &v116);
      sub_1004F034C(v2, (__int128 *)buf);
      ++v36;
      uint64_t v37 = (__n128 *)((char *)v37 + 20);
    }

    while (v36 < *v18);
  }

  if (v79[5632])
  {
    unint64_t v38 = 0LL;
    char v77 = 0;
    uint64_t v39 = (__n128 *)(v79 + 5072);
    while (1)
    {
      memset(buf, 0, 20);
      __n128 v114 = *v39;
      unsigned __int32 v115 = v39[1].n128_u32[0];
      sub_100634334((__n128 *)buf, &v114);
      *(_OWORD *)&__p.__r_.__value_.__l.__data_ = 0uLL;
      sub_10056AB04(&__p, &v39[1].n128_u8[4], v39[3].n128_u16[2]);
      uint64_t v95 = buf;
      __int128 v40 = sub_10002E92C((uint64_t **)v2 + 14, buf, (uint64_t)&unk_1006C2518, &v95);
      sub_10002EAC8((uint64_t)v40 + 56, (uint64_t)&__p);
      __int128 v112 = xmmword_1006BDCB0;
      int v113 = 0;
      if (!sub_1001BEC7C(buf, (unsigned __int8 *)&v112))
      {
        __int128 v110 = xmmword_1006BDCC4;
        int v111 = 0;
      }

      __int128 v108 = xmmword_1006BDCB0;
      int v109 = 0;
      if (sub_1001BEC7C(buf, (unsigned __int8 *)&v108))
      {
        char v77 = sub_10056AE48((uint64_t)&__p, 0LL);
        uint64_t v41 = sub_10056AE48((uint64_t)&__p, 1uLL) & 1;
        int v76 = 2;
      }

      else
      {
        __int128 v106 = xmmword_1006BDCC4;
        int v107 = 0;
        if (sub_1001BEC7C(buf, (unsigned __int8 *)&v106)
          && _os_feature_enabled_impl("BluetoothFeatures", "StandardUTFEAA"))
        {
          char v42 = sub_10056AE48((uint64_t)&__p, 0LL);
          if (!*(_BYTE *)(v78 + 343))
          {
            int v76 = 3;
            char v77 = -1;
            goto LABEL_95;
          }

          LODWORD(v41) = (v42 & 1) == 0;
          int v96 = 0;
          uint64_t v95 = 0LL;
          int v76 = 3;
          char v77 = -1;
LABEL_93:
          int v45 = 0;
          int v44 = 0;
          int v43 = v41 ^ 1;
LABEL_94:
          uint64_t v46 = sub_1002E8D94();
          unint64_t v88 = v95;
          int v89 = v96;
          int v90 = v45;
          int v91 = v41;
          int v92 = 0;
          int v93 = v44;
          int v94 = v43;
          (*(void (**)(uint64_t, _OWORD **))(*(void *)v46 + 584LL))(v46, &v88);
          goto LABEL_95;
        }

        LODWORD(v41) = 0;
      }

      if (*(_BYTE *)(v78 + 343))
      {
        int v96 = 0;
        uint64_t v95 = 0LL;
        if (v77 != 1) {
          goto LABEL_93;
        }
        int v43 = 0;
        int v44 = v41 ^ 1;
        char v77 = 1;
        int v45 = v41;
        LODWORD(v41) = 0;
        goto LABEL_94;
      }

void sub_1005E69FC( _Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20, uint64_t a21, uint64_t a22, uint64_t a23, uint64_t a24, uint64_t a25, uint64_t a26, uint64_t a27, uint64_t a28, uint64_t a29, void *__p, uint64_t a31, int a32, __int16 a33, char a34, char a35, uint64_t a36, uint64_t a37, int a38, __int16 a39, char a40, char a41, uint64_t a42, uint64_t a43)
{
}

void sub_1005E6B2C(uint64_t a1, __int128 *a2)
{
  __int128 v2 = a2[1];
  __int128 v5 = *a2;
  __int128 v6 = v2;
  __int128 v7 = a2[2];
  uint64_t v8 = *((void *)a2 + 6);
  uint64_t v3 = sub_100404FE8();
  v4[0] = _NSConcreteStackBlock;
  v4[1] = 3221225472LL;
  _DWORD v4[2] = sub_1005E5980;
  v4[3] = &unk_10089D260;
  sub_100405384(v3, v4);
}

void sub_1005E6BC8(uint64_t a1, void *a2)
{
  unint64_t v4 = (os_log_s *)qword_1008F75B8;
  if (os_log_type_enabled((os_log_t)qword_1008F75B8, OS_LOG_TYPE_DEFAULT))
  {
    uint64_t v5 = 0x6DB6DB6DB6DB6DB7LL * ((uint64_t)(a2[1] - *a2) >> 3);
    LODWORD(buf) = 134217984;
    *(void *)((char *)&buf + 4) = v5;
    _os_log_impl( (void *)&_mh_execute_header,  v4,  OS_LOG_TYPE_DEFAULT,  "AOPBTBUFF: Read Event with %lu advertisements",  (uint8_t *)&buf,  0xCu);
  }

  __int128 buf = 0uLL;
  uint64_t v15 = 0LL;
  sub_100334E5C(&buf, (uint64_t)a2);
  uint64_t v6 = sub_100404FE8();
  v10[0] = _NSConcreteStackBlock;
  v10[1] = 3321888768LL;
  _DWORD v10[2] = sub_1005E6DA8;
  v10[3] = &unk_1008A39F0;
  void v10[4] = a1;
  std::stringbuf::string_type __p = 0LL;
  __uuid_t dst = 0LL;
  uint64_t v13 = 0LL;
  __int128 v7 = (const void *)buf;
  int64_t v8 = *((void *)&buf + 1) - buf;
  if (*((void *)&buf + 1) != (void)buf)
  {
    sub_100334ED4(&__p, 0x6DB6DB6DB6DB6DB7LL * (v8 >> 3));
    double v9 = (char *)__dst;
    memmove(__dst, v7, v8);
    __uuid_t dst = &v9[8 * (v8 >> 3)];
  }

  sub_100405384(v6, v10);
  if (__p)
  {
    __uuid_t dst = __p;
    operator delete(__p);
  }

  if ((void)buf)
  {
    *((void *)&buf + 1) = buf;
    operator delete((void *)buf);
  }

void sub_1005E6D6C( _Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, void *__p, uint64_t a15, uint64_t a16, void *a17, uint64_t a18)
{
  if (__p) {
    operator delete(__p);
  }
  if (a17) {
    operator delete(a17);
  }
  _Unwind_Resume(exception_object);
}

void sub_1005E6DA8(void *a1)
{
  unint64_t v36 = (unsigned __int8 *)a1[4];
  __int128 v2 = (os_log_s *)qword_1008F75B8;
  if (os_log_type_enabled((os_log_t)qword_1008F75B8, OS_LOG_TYPE_DEFAULT))
  {
    *(_WORD *)__int128 buf = 0;
    _os_log_impl((void *)&_mh_execute_header, v2, OS_LOG_TYPE_DEFAULT, "AOPBTBUFF: Read Event unpack devices", buf, 2u);
  }

  uint64_t v3 = a1[5];
  if (a1[6] != v3)
  {
    uint64_t v4 = 0LL;
    unint64_t v5 = 0LL;
    uint64_t v6 = 39LL;
    do
    {
      unsigned int v7 = *(unsigned __int8 *)(v3 + v6);
      if (v7 < 0x20)
      {
        bzero(buf, 0x1788uLL);
        __int128 v41 = 0u;
        __int128 v42 = 0u;
        __int128 v39 = 0u;
        __int128 v40 = 0u;
        __int128 v38 = 0u;
        sub_1001F0050((uint64_t)&v38 + 2, v3 + v6 + 1, 6uLL);
        BYTE1(v38) = 1;
        uint64_t v9 = BYTE2(v38);
        uint64_t v10 = BYTE3(v38);
        uint64_t v11 = BYTE4(v38);
        uint64_t v12 = BYTE5(v38);
        uint64_t v13 = BYTE6(v38);
        uint64_t v14 = BYTE7(v38);
        if (qword_1008D5F20 != -1) {
          dispatch_once(&qword_1008D5F20, &stru_1008A40F8);
        }
        unint64_t v15 = (v10 << 32) | (v9 << 40) | (v11 << 24) | (v12 << 16) | (v13 << 8) | v14 | 0x1000000000000LL;
        if (!sub_10062DF10(qword_1008D5F18, v15, (uint64_t)&v38 + 1)
          && (unint64_t v15 = ((unint64_t)BYTE2(v38) << 40) | ((unint64_t)BYTE3(v38) << 32) | ((unint64_t)BYTE4(v38) << 24) | ((unint64_t)BYTE5(v38) << 16) | ((unint64_t)BYTE6(v38) << 8) | BYTE7(v38) | ((unint64_t)BYTE1(v38) << 48)) == 0
          || HIWORD(v15) && (HIWORD(v15) == 1 ? (BOOL v16 = (v15 & 0xC00000000000LL) == 0x800000000000LL) : (BOOL v16 = 1), v16))
        {
          __int128 v17 = (os_log_s *)qword_1008F75B8;
          if (os_log_type_enabled((os_log_t)qword_1008F75B8, OS_LOG_TYPE_ERROR))
          {
            sub_1005BFC20(v15, (std::stringbuf::string_type *)&__p);
            p_p = &__p;
            if (SBYTE3(v48) < 0) {
              p_p = __p;
            }
            LODWORD(v43.__r_.__value_.__l.__data_) = 136315138;
            *(std::string::size_type *)((char *)v43.__r_.__value_.__r.__words + 4) = (std::string::size_type)p_p;
            _os_log_error_impl( (void *)&_mh_execute_header,  v17,  OS_LOG_TYPE_ERROR,  "AOPBTBUFF: Remote Bluetooth address %s is invalid!",  (uint8_t *)&v43,  0xCu);
            if (SBYTE3(v48) < 0) {
              operator delete(__p);
            }
          }
        }

        else
        {
          uint64_t v19 = (os_log_s *)qword_1008F75B8;
          if (os_log_type_enabled((os_log_t)qword_1008F75B8, OS_LOG_TYPE_INFO))
          {
            uint64_t v20 = *(void *)(a1[5] + v6 - 39);
            sub_1005BFC20(v15, &v43);
            int size = (char)v43.__r_.__value_.__s.__size_;
            std::string::size_type v22 = v43.__r_.__value_.__r.__words[0];
            uint64_t v23 = (unsigned __int8 *)(a1[5] + v6);
            int v24 = *v23;
            uint64_t v25 = CUPrintHex(v23 - 31, 31LL, 31LL, 0LL);
            uint64_t v26 = objc_claimAutoreleasedReturnValue(v25);
            unint64_t v27 = (void *)v26;
            int v28 = &v43;
            if (size < 0) {
              int v28 = (std::stringbuf::string_type *)v22;
            }
            int v29 = *(char *)(a1[5] + v6 + 7);
            LODWORD(__p) = 67110402;
            HIDWORD(__p) = v5;
            __int16 v45 = 2048;
            uint64_t v46 = v20;
            __int16 v47 = 2080;
            uint64_t v48 = v28;
            __int16 v49 = 1024;
            int v50 = v24;
            __int16 v51 = 2112;
            uint64_t v52 = v26;
            __int16 v53 = 1024;
            int v54 = v29;
            _os_log_impl( (void *)&_mh_execute_header,  v19,  OS_LOG_TYPE_INFO,  "AOPBTBUFF: Parsing entry %d, TIMESTAMP %f, ADDR %s, LEN %d, PAYLOAD %@, RSSI %3d",  (uint8_t *)&__p,  0x32u);
          }
        }

        LOBYTE(v38) = 3;
        uint64_t v30 = (unsigned __int8 *)(a1[5] + v6);
        WORD4(v38) = *v30;
        BYTE8(v39) = v30[7];
        *(void *)&__int128 v39 = v30 - 31;
        BYTE11(v40) = 0;
        LOBYTE(__p) = 0;
        sub_100242CA4(&__p);
        sub_1001BA69C((unsigned __int8 *)&v38, (uint64_t)buf, v31, v32);
        sub_100242CD0(&__p);
        char v57 = 0;
        uint64_t v33 = a1[5];
        uint64_t v59 = *(void *)(v33 + v6 - 39);
        if (*(void *)(v33 + v6 + 9)) {
          uint64_t v60 = *(void *)(v33 + v6 + 9);
        }
        char v58 = *(_BYTE *)(v33 + v6 + 8);
        uint64_t v34 = (unsigned __int128)((a1[6] - v33) * (__int128)0x4924924924924925LL) >> 64;
        BOOL v61 = v4 + (v34 >> 4) + ((unint64_t)v34 >> 63) > 1;
        char v62 = 1;
        sub_1005E5C78(buf);
        sub_100242CD8(&__p);
      }

      else
      {
        int64_t v8 = (os_log_s *)qword_1008F75B8;
        if (os_log_type_enabled((os_log_t)qword_1008F75B8, OS_LOG_TYPE_ERROR))
        {
          *(_DWORD *)__int128 buf = 67109120;
          unsigned int v56 = v7;
          _os_log_error_impl( (void *)&_mh_execute_header,  v8,  OS_LOG_TYPE_ERROR,  "Ignoring invalid data length %d",  buf,  8u);
        }
      }

      ++v5;
      uint64_t v3 = a1[5];
      v6 += 56LL;
      --v4;
    }

    while (0x6DB6DB6DB6DB6DB7LL * ((a1[6] - v3) >> 3) > v5);
  }

  uint64_t v35 = sub_100404FE8();
  v37[0] = _NSConcreteStackBlock;
  v37[1] = 3221225472LL;
  v37[2] = sub_1005E7344;
  v37[3] = &unk_10087EB20;
  v37[4] = v36;
  sub_100405384(v35, v37);
  v36[1854] = 0;
  v36[1864] = 0;
  sub_1005E75F8(v36);
}

void sub_1005E7310( _Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20, uint64_t a21, uint64_t a22, uint64_t a23, uint64_t a24, uint64_t a25, uint64_t a26, uint64_t a27, uint64_t a28, uint64_t a29, uint64_t a30, uint64_t a31, uint64_t a32, uint64_t a33, uint64_t a34, void *__p, uint64_t a36, int a37, __int16 a38, char a39, char a40, uint64_t a41, char a42)
{
  if (a40 < 0) {
    operator delete(__p);
  }
  _Unwind_Resume(exception_object);
}

void sub_1005E7344(uint64_t a1)
{
}

void sub_1005E734C(uint64_t a1)
{
  __int128 v2 = (os_log_s *)qword_1008F75B8;
  if (os_log_type_enabled((os_log_t)qword_1008F75B8, OS_LOG_TYPE_DEFAULT))
  {
    *(_WORD *)__int128 buf = 0;
    _os_log_impl((void *)&_mh_execute_header, v2, OS_LOG_TYPE_DEFAULT, "AOPBTBUFF Sending empty event", buf, 2u);
  }

  uint64_t v3 = (unsigned int *)operator new(0x1E0uLL);
  sub_10056B368((uint64_t)v3);
  *((_BYTE *)v3 + 305) = 1;
  uint64_t v4 = *(void **)(a1 + 2040);
  if (v4 != (void *)(a1 + 2048))
  {
    do
    {
      uint64_t v5 = v4[4];
      if (sub_100611348(v4[5]))
      {
        if (*(_DWORD *)(a1 + 1964))
        {
          v10[0] = _NSConcreteStackBlock;
          v10[1] = 3321888768LL;
          _DWORD v10[2] = sub_1005EBEB4;
          v10[3] = &unk_1008A3A48;
          void v10[4] = v5;
          uint64_t v11 = &off_10087FAE8;
          uint64_t v12 = v3;
          sub_1002CD1E0((uint64_t)v3);
          std::stringbuf::string_type __p = 0LL;
          uint64_t v14 = 0LL;
          uint64_t v15 = 0LL;
          sub_100050EE8((char *)&__p, 0LL, 0LL, 0LL);
          sub_1005EBB90((os_unfair_lock_s *)(a1 + 1904), v10);
          if (__p)
          {
            uint64_t v14 = __p;
            operator delete(__p);
          }

          uint64_t v11 = &off_10087FAE8;
          uint64_t v6 = v12;
          if (!v12) {
            goto LABEL_10;
          }
        }

        else
        {
          v16[0] = _NSConcreteStackBlock;
          v16[1] = 3321888768LL;
          void v16[2] = sub_1005EBE2C;
          v16[3] = &unk_1008A3A48;
          void v16[4] = v5;
          __int128 v17 = &off_10087FAE8;
          __int128 v18 = v3;
          sub_1002CD1E0((uint64_t)v3);
          uint64_t v19 = 0LL;
          uint64_t v20 = 0LL;
          uint64_t v21 = 0LL;
          sub_100050EE8((char *)&v19, 0LL, 0LL, 0LL);
          sub_1005EBB90((os_unfair_lock_s *)(a1 + 1872), v16);
          if (v19)
          {
            uint64_t v20 = v19;
            operator delete(v19);
          }

          __int128 v17 = &off_10087FAE8;
          uint64_t v6 = v18;
          if (!v18) {
            goto LABEL_10;
          }
        }

        sub_1002CD254(v6);
      }

void sub_1005E7578( _Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, void *a18, uint64_t a19, uint64_t a20, uint64_t a21, uint64_t a22, uint64_t a23, uint64_t a24, uint64_t a25, uint64_t a26, uint64_t a27, void *__p, uint64_t a29)
{
}

void sub_1005E75F8(unsigned __int8 *a1)
{
  __int128 v2 = (os_log_s *)qword_1008F75B8;
  if (os_log_type_enabled((os_log_t)qword_1008F75B8, OS_LOG_TYPE_INFO))
  {
    BOOL v3 = sub_1005EE83C((uint64_t)a1);
    int v4 = a1[144];
    int v5 = a1[1854];
    int v6 = a1[1864];
    v7[0] = 67109888;
    v7[1] = v3;
    __int16 v8 = 1024;
    int v9 = v4;
    __int16 v10 = 1024;
    int v11 = v5;
    __int16 v12 = 1024;
    int v13 = v6;
    _os_log_impl( (void *)&_mh_execute_header,  v2,  OS_LOG_TYPE_INFO,  "enableAOPBTBuffersIfNeeded haveAnyHwAOPBTBufferRequests:%d fScreenState:%d fAOPBTBufferReadInProgress:%d fAOPBTPro xCtxBufferReadInProgress:%d",  (uint8_t *)v7,  0x1Au);
  }

  if (sub_1005EE83C((uint64_t)a1))
  {
    if (sub_1005ED470((uint64_t)a1) && !a1[1854])
    {
      if (sub_1005ECCCC((uint64_t)a1, 22, 1))
      {
        if (os_log_type_enabled((os_log_t)qword_1008F75B8, OS_LOG_TYPE_ERROR)) {
          sub_10069BC7C();
        }
      }

      else
      {
        sub_1005ED56C((uint64_t)a1);
      }
    }

    if (sub_1005ECBFC((uint64_t)a1)
      && !a1[1864]
      && sub_1005ECCCC((uint64_t)a1, 0, 1)
      && os_log_type_enabled((os_log_t)qword_1008F75B8, OS_LOG_TYPE_ERROR))
    {
      sub_10069BC1C();
    }

    if (sub_1005ECC64((uint64_t)a1)
      && !a1[1864]
      && !a1[144]
      && sub_1005ECCCC((uint64_t)a1, 7, 1)
      && os_log_type_enabled((os_log_t)qword_1008F75B8, OS_LOG_TYPE_ERROR))
    {
      sub_10069BBBC();
    }
  }

void *sub_1005E77D8(uint64_t a1, uint64_t a2)
{
  return sub_100334E5C((void *)(a1 + 40), a2 + 40);
}

void sub_1005E77E4(uint64_t a1)
{
  __int128 v2 = *(void **)(a1 + 40);
  if (v2)
  {
    *(void *)(a1 + 48) = v2;
    operator delete(v2);
  }

void sub_1005E77FC(uint64_t a1, void *a2)
{
}

void sub_1005E7804(uint64_t a1, uint64_t a2)
{
  if (sub_1005E78AC(a1, a2))
  {
    if (os_log_type_enabled((os_log_t)qword_1008F75B8, OS_LOG_TYPE_ERROR)) {
      sub_10069BD48();
    }
  }

  else if (sub_1005E7BF8(a1, a2) && os_log_type_enabled((os_log_t)qword_1008F75B8, OS_LOG_TYPE_ERROR))
  {
    sub_10069BCDC();
  }

uint64_t sub_1005E78AC(uint64_t a1, int a2)
{
  int v4 = (os_log_s *)qword_1008F75B8;
  if (os_log_type_enabled((os_log_t)qword_1008F75B8, OS_LOG_TYPE_INFO))
  {
    *(_DWORD *)__int128 buf = 67109120;
    *(_DWORD *)&uint8_t buf[4] = a2;
    _os_log_impl((void *)&_mh_execute_header, v4, OS_LOG_TYPE_INFO, "Destroying match table for type %d", buf, 8u);
    int v4 = (os_log_s *)qword_1008F75B8;
  }

  int v5 = *(void **)(a1 + 1816);
  if (v5 == (void *)(a1 + 1824)) {
    goto LABEL_24;
  }
  while (1)
  {
    int v6 = *((unsigned __int8 *)v5 + 28);
    int v7 = *((unsigned __int16 *)v5 + 15);
    int v8 = *((unsigned __int16 *)v5 + 16);
    if (os_log_type_enabled(v4, OS_LOG_TYPE_DEBUG))
    {
      int v12 = *((unsigned __int16 *)v5 + 18);
      BOOL v13 = *((unsigned __int16 *)v5 + 17) != 0;
      *(_DWORD *)__int128 buf = 67110144;
      *(_DWORD *)&uint8_t buf[4] = v7;
      __int16 v26 = 1024;
      int v27 = v6;
      __int16 v28 = 1024;
      int v29 = v12;
      __int16 v30 = 1024;
      BOOL v31 = v8 != 0;
      __int16 v32 = 1024;
      BOOL v33 = v13;
      _os_log_debug_impl( (void *)&_mh_execute_header,  v4,  OS_LOG_TYPE_DEBUG,  "handle:%d type:%d length:%d isCreated:%d isEnabled:%d",  buf,  0x20u);
      int v4 = (os_log_s *)qword_1008F75B8;
    }

    BOOL v9 = v6 != a2 || v8 == 0;
    if (!v9) {
      break;
    }
    __int16 v10 = (void *)v5[1];
    if (v10)
    {
      do
      {
        int v11 = v10;
        __int16 v10 = (void *)*v10;
      }

      while (v10);
    }

    else
    {
      do
      {
        int v11 = (void *)v5[2];
        BOOL v9 = *v11 == (void)v5;
        int v5 = v11;
      }

      while (!v9);
    }

    int v5 = v11;
    if (v11 == (void *)(a1 + 1824)) {
      goto LABEL_24;
    }
  }

  if (!v7)
  {
LABEL_24:
    if (os_log_type_enabled(v4, OS_LOG_TYPE_ERROR)) {
      sub_10069BDB4();
    }
    return 3LL;
  }

  else
  {
    unsigned __int8 v24 = v7;
    *(void *)__int128 buf = &v24;
    uint64_t v14 = sub_10060F298((uint64_t **)(a1 + 1816), &v24, (uint64_t)&unk_1006C2518, (char **)buf);
    __int16 v15 = *((_WORD *)v14 + 14);
    uint64_t v16 = *((unsigned __int16 *)v14 + 15);
    int v17 = *((_DWORD *)v14 + 9);
    unsigned __int8 v24 = v7;
    *(void *)__int128 buf = &v24;
    __int128 v18 = sub_10060F298((uint64_t **)(a1 + 1816), &v24, (uint64_t)&unk_1006C2518, (char **)buf);
    *((_WORD *)v18 + 14) = v15;
    *((_WORD *)v18 + 15) = v16;
    *((_DWORD *)v18 + 8) = 0;
    *((_DWORD *)v18 + 9) = v17;
    uint64_t v19 = (os_log_s *)qword_1008F75B8;
    if (os_log_type_enabled((os_log_t)qword_1008F75B8, OS_LOG_TYPE_INFO))
    {
      *(_DWORD *)__int128 buf = 67109376;
      *(_DWORD *)&uint8_t buf[4] = a2;
      __int16 v26 = 1024;
      int v27 = v16;
      _os_log_impl( (void *)&_mh_execute_header,  v19,  OS_LOG_TYPE_INFO,  "Destroying match table for type %d with handle %d",  buf,  0xEu);
    }

    uint64_t v20 = sub_1002E6E9C();
    uint64_t v21 = (*(uint64_t (**)(uint64_t, uint64_t, void, uint64_t))(*(void *)v20 + 2840LL))(v20, v16, 0LL, 1LL);
    if ((_DWORD)v21)
    {
      std::string::size_type v22 = (os_log_s *)qword_1008F75B8;
      if (os_log_type_enabled((os_log_t)qword_1008F75B8, OS_LOG_TYPE_ERROR))
      {
        *(_DWORD *)__int128 buf = 67109632;
        *(_DWORD *)&uint8_t buf[4] = a2;
        __int16 v26 = 1024;
        int v27 = v7;
        __int16 v28 = 1024;
        int v29 = v21;
        _os_log_error_impl( (void *)&_mh_execute_header,  v22,  OS_LOG_TYPE_ERROR,  "Failed to destroy match table for type %d on handle %d: %d",  buf,  0x14u);
      }
    }

    else
    {
      sub_1005FC17C((double *)a1, a2, 0);
    }
  }

  return v21;
}

uint64_t sub_1005E7BF8(uint64_t a1, uint64_t a2)
{
  unsigned __int16 v27 = 0;
  if ((_DWORD)a2)
  {
    uint64_t v4 = 7LL;
  }

  else
  {
    if (os_log_type_enabled((os_log_t)qword_1008F75B8, OS_LOG_TYPE_DEBUG)) {
      sub_10069BF48();
    }
    uint64_t v4 = 3LL;
  }

  uint64_t v5 = sub_1005FBD08(a1, a2, 1, &v27);
  if ((_DWORD)v5)
  {
    uint64_t v6 = v5;
    if (os_log_type_enabled((os_log_t)qword_1008F75B8, OS_LOG_TYPE_ERROR)) {
      sub_10069BEE8();
    }
  }

  else
  {
    uint64_t v7 = v27;
    unsigned __int8 v28 = v27;
    *(void *)__int128 buf = &v28;
    int v8 = sub_10060F298((uint64_t **)(a1 + 1816), &v28, (uint64_t)&unk_1006C2518, (char **)buf);
    __int16 v25 = *((_WORD *)v8 + 15);
    char v23 = *((_BYTE *)v8 + 29);
    __int16 v24 = *((_WORD *)v8 + 17);
    BOOL v9 = (os_log_s *)qword_1008F75B8;
    if (os_log_type_enabled((os_log_t)qword_1008F75B8, OS_LOG_TYPE_DEFAULT))
    {
      *(_DWORD *)__int128 buf = 67109376;
      *(_DWORD *)&uint8_t buf[4] = v7;
      *(_WORD *)&uint8_t buf[8] = 1024;
      *(_DWORD *)&buf[10] = a2;
      _os_log_impl( (void *)&_mh_execute_header,  v9,  OS_LOG_TYPE_DEFAULT,  "Creating an AOP match table with handle %d for type %d",  buf,  0xEu);
    }

    if ((_DWORD)a2 == 22 && qword_1008F1EF8 != -1) {
      dispatch_once(&qword_1008F1EF8, &stru_1008A3D28);
    }
    if (qword_1008D6628 != -1) {
      dispatch_once(&qword_1008D6628, &stru_1008A4098);
    }
    char v10 = sub_100333D5C(qword_1008D6620, a2);
    if ((_DWORD)a2 == 22 && *(double *)(a1 + 1856) == 0.0)
    {
      +[NSDate timeIntervalSinceReferenceDate](&OBJC_CLASS___NSDate, "timeIntervalSinceReferenceDate");
      *(void *)(a1 + 1856) = v11;
    }

    uint64_t v12 = sub_1002E6E9C();
    uint64_t v6 = (*(uint64_t (**)(uint64_t, uint64_t, uint64_t, uint64_t, uint64_t, uint64_t, void, uint64_t, char, void, _BYTE, void, void, _BYTE))(*(void *)v12 + 2816LL))( v12,  v7,  v4,  255LL,  76LL,  a2,  0LL,  1LL,  v10,  0LL,  0,  0LL,  0LL,  0);
    if ((_DWORD)v6)
    {
      if (os_log_type_enabled((os_log_t)qword_1008F75B8, OS_LOG_TYPE_ERROR)) {
        sub_10069BE80();
      }
    }

    else
    {
      __int128 v48 = 0u;
      memset(v49, 0, sizeof(v49));
      __int128 v46 = 0u;
      __int128 v47 = 0u;
      __int128 v44 = 0u;
      __int128 v45 = 0u;
      __int128 v42 = 0u;
      __int128 v43 = 0u;
      __int128 v40 = 0u;
      __int128 v41 = 0u;
      __int128 v38 = 0u;
      __int128 v39 = 0u;
      *(_OWORD *)__int128 buf = 0u;
      __int128 v37 = 0u;
      buf[6] = 2;
      uint64_t v13 = sub_1002E6E9C();
      uint64_t v6 = (*(uint64_t (**)(uint64_t, uint64_t, void, void, uint8_t *))(*(void *)v13 + 2864LL))( v13,  v7,  0LL,  0LL,  buf);
      if ((_DWORD)v6)
      {
        if (os_log_type_enabled((os_log_t)qword_1008F75B8, OS_LOG_TYPE_ERROR)) {
          sub_10069BE18();
        }
      }

      else
      {
        if ((_DWORD)a2 == 22)
        {
          __int16 v14 = 1;
        }

        else if ((_DWORD)a2 == 7)
        {
          __int16 v14 = 4;
        }

        else if ((_DWORD)a2)
        {
          __int16 v14 = 0;
        }

        else
        {
          __int16 v14 = 2;
        }

        unsigned __int8 v26 = v25;
        int v29 = (char *)&v26;
        __int16 v15 = sub_10060F298((uint64_t **)(a1 + 1816), &v26, (uint64_t)&unk_1006C2518, &v29);
        *((_BYTE *)v15 + 28) = a2;
        *((_BYTE *)v15 + 29) = v23;
        *((_WORD *)v15 + 15) = v25;
        *((_WORD *)v15 + 16) = 1;
        *((_WORD *)v15 + 17) = v24;
        *((_WORD *)v15 + 18) = 1;
        *((_WORD *)v15 + 19) = v14;
        BOOL v16 = (_DWORD)a2 != 22;
        if (*(_BYTE *)(a1 + 1855)) {
          BOOL v16 = 1;
        }
        if (!v16)
        {
          if (qword_1008D6628 != -1) {
            dispatch_once(&qword_1008D6628, &stru_1008A4098);
          }
          uint64_t v17 = qword_1008D6620;
          v34[0] = @"type";
          v34[1] = @"descriptor";
          v35[0] = &off_1008C2C00;
          __int16 v32 = @"conf";
          __int16 v30 = @"appleType";
          __int128 v18 = (void *)objc_claimAutoreleasedReturnValue(+[NSNumber numberWithUnsignedChar:](&OBJC_CLASS___NSNumber, "numberWithUnsignedChar:", 22LL));
          BOOL v31 = v18;
          uint64_t v19 = (void *)objc_claimAutoreleasedReturnValue( +[NSDictionary dictionaryWithObjects:forKeys:count:]( &OBJC_CLASS___NSDictionary,  "dictionaryWithObjects:forKeys:count:",  &v31,  &v30,  1LL));
          BOOL v33 = v19;
          uint64_t v20 = (void *)objc_claimAutoreleasedReturnValue( +[NSDictionary dictionaryWithObjects:forKeys:count:]( &OBJC_CLASS___NSDictionary,  "dictionaryWithObjects:forKeys:count:",  &v33,  &v32,  1LL));
          v35[1] = v20;
          uint64_t v21 = (void *)objc_claimAutoreleasedReturnValue( +[NSDictionary dictionaryWithObjects:forKeys:count:]( &OBJC_CLASS___NSDictionary,  "dictionaryWithObjects:forKeys:count:",  v35,  v34,  2LL));
          sub_100333DE0(v17, v21);

          *(_BYTE *)(a1 + 1855) = 1;
        }
      }
    }
  }

  return v6;
}

void sub_1005E80E0(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_1005E811C(uint64_t a1, uint64_t a2)
{
}

void sub_1005E8124(uint64_t a1, const void *a2, unsigned int a3)
{
  uint64_t v6 = (os_log_s *)qword_1008F75B8;
  if (os_log_type_enabled((os_log_t)qword_1008F75B8, OS_LOG_TYPE_DEFAULT))
  {
    *(_DWORD *)__int128 buf = 67109120;
    *(_DWORD *)&uint8_t buf[4] = a3;
    _os_log_impl((void *)&_mh_execute_header, v6, OS_LOG_TYPE_DEFAULT, "ADVBUFF advBufferEvent length=%d", buf, 8u);
  }

  *(void *)__int128 buf = 0LL;
  uint64_t v13 = buf;
  uint64_t v14 = 0x2020000000LL;
  char v15 = 5;
  if (a3 == 244)
  {
    char v7 = 2;
    goto LABEL_7;
  }

  if (a3 == 219)
  {
    char v7 = *(_BYTE *)(a1 + 1796);
LABEL_7:
    char v15 = v7;
    int v8 = malloc(a3);
    memcpy(v8, a2, a3);
    uint64_t v9 = sub_100404FE8();
    v10[0] = _NSConcreteStackBlock;
    v10[1] = 3221225472LL;
    _DWORD v10[2] = sub_1005E82CC;
    v10[3] = &unk_1008A3A28;
    void v10[4] = buf;
    void v10[5] = a1;
    __int16 v11 = a3;
    v10[6] = v8;
    sub_100405384(v9, v10);
    goto LABEL_10;
  }

  if (os_log_type_enabled((os_log_t)qword_1008F75B8, OS_LOG_TYPE_ERROR)) {
    sub_10069BF78();
  }
LABEL_10:
  _Block_object_dispose(buf, 8);
}

void sub_1005E82AC( _Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, char a17)
{
}

void sub_1005E82CC(uint64_t a1)
{
  uint64_t v2 = *(void *)(a1 + 40);
  BOOL v3 = (os_log_t *)&qword_1008F75B8;
  uint64_t v4 = (os_log_s *)qword_1008F75B8;
  if (os_log_type_enabled((os_log_t)qword_1008F75B8, OS_LOG_TYPE_INFO))
  {
    unint64_t v5 = *(char *)(*(void *)(*(void *)(a1 + 32) + 8LL) + 24LL);
    if (v5 > 2) {
      uint64_t v6 = @"UNKNOWN";
    }
    else {
      uint64_t v6 = off_1008A4258[v5];
    }
    int v7 = *(unsigned __int8 *)(v2 + 1260);
    int v8 = *(unsigned __int8 *)(v2 + 172);
    int v9 = *(unsigned __int8 *)(v2 + 716);
    int v10 = *(unsigned __int8 *)(v2 + 544LL * *(unsigned __int8 *)(*(void *)(*(void *)(a1 + 32) + 8LL) + 24LL) + 169);
    int v11 = *(unsigned __int8 *)(v2 + 167);
    int v12 = *(unsigned __int8 *)(v2 + 711);
    int v13 = *(unsigned __int8 *)(v2 + 171);
    int v14 = *(unsigned __int8 *)(v2 + 715);
    *(_DWORD *)__int128 buf = 138414338;
    *(void *)&uint8_t buf[4] = v6;
    *(_WORD *)&_BYTE buf[12] = 1024;
    *(_DWORD *)&buf[14] = v7;
    *(_WORD *)&_BYTE buf[18] = 1024;
    *(_DWORD *)&_BYTE buf[20] = v8;
    *(_WORD *)int v156 = 1024;
    *(_DWORD *)&v156[2] = v9;
    *(_WORD *)&v156[6] = 1024;
    *(_DWORD *)&v156[8] = v10;
    *(_WORD *)&v156[12] = 1024;
    *(_DWORD *)&_BYTE v156[14] = v11;
    LOWORD(v157) = 1024;
    *(_DWORD *)((char *)&v157 + 2) = v12;
    HIWORD(v157) = 1024;
    *(_DWORD *)int v158 = v13;
    *(_WORD *)&v158[4] = 1024;
    *(_DWORD *)__int128 v159 = v14;
    _os_log_impl( (void *)&_mh_execute_header,  v4,  OS_LOG_TYPE_INFO,  "ADVBUFF(%@): advBufferEvent expectedEntries EN:%d ObjDiscoveryWild:%d ObjectDiscoveryNO:%d pendingDraining:%d crea tedWild:%d createdNO:%d readInProgressWild:%d readInProgressNO:%d",  buf,  0x3Cu);
  }

  unsigned int v15 = *(unsigned __int8 *)(*(void *)(*(void *)(a1 + 32) + 8LL) + 24LL);
  if (*(_BYTE *)(v2 + 544LL * *(unsigned __int8 *)(*(void *)(*(void *)(a1 + 32) + 8LL) + 24LL) + 167))
  {
    if (*(unsigned __int8 *)(v2 + 544LL * *(unsigned __int8 *)(*(void *)(*(void *)(a1 + 32) + 8LL) + 24LL) + 172) == 255)
    {
      BOOL v16 = (os_log_s *)qword_1008F75B8;
      if (os_log_type_enabled((os_log_t)qword_1008F75B8, OS_LOG_TYPE_FAULT))
      {
        *(_WORD *)__int128 buf = 0;
        _os_log_fault_impl( (void *)&_mh_execute_header,  v16,  OS_LOG_TYPE_FAULT,  "We were not expecting to get anything right now",  buf,  2u);
        unsigned int v15 = *(unsigned __int8 *)(*(void *)(*(void *)(a1 + 32) + 8LL) + 24LL);
      }
    }

    if (v15 <= 1)
    {
      if (*(_BYTE *)(v2 + 544LL * v15 + 172)
        && *(unsigned __int8 *)(v2 + 544LL * v15 + 172) != 255
        && *(_WORD *)(a1 + 56) == 219)
      {
        *(_BYTE *)(v2 + 544LL * v15 + 169) = 0;
        uint64_t v17 = *(int **)(a1 + 48);
        int v186 = v17 + 1;
        __int128 v187 = (char *)v17 + 47;
        int v188 = (char *)v17 + 90;
        __int128 v189 = (char *)v17 + 133;
        uint64_t v128 = v17;
        int v190 = v17 + 44;
        if (*(_BYTE *)(*(void *)(*(void *)(a1 + 32) + 8LL) + 24LL))
        {
          if (*(_BYTE *)(*(void *)(*(void *)(a1 + 32) + 8LL) + 24LL) == 1)
          {
            else {
              int v18 = *(unsigned __int8 *)(v2 + 716);
            }
            uint64_t v19 = sub_1002E8D94();
            v136[0] = 0;
            v136[1] = v18;
            uint64_t v138 = 0LL;
            uint64_t v139 = 0LL;
            uint64_t v137 = 0LL;
            (*(void (**)(uint64_t, _DWORD *))(*(void *)v19 + 584LL))(v19, v136);
          }
        }

        else
        {
          else {
            int v68 = *(unsigned __int8 *)(v2 + 172);
          }
          uint64_t v69 = sub_1002E8D94();
          int v131 = v68;
          uint64_t v132 = 0LL;
          uint64_t v134 = 0LL;
          uint64_t v133 = 0LL;
          int v135 = 0;
          (*(void (**)(uint64_t, int *))(*(void *)v69 + 584LL))(v69, &v131);
        }

        unsigned __int8 v70 = *(_BYTE *)(*(void *)(*(void *)(a1 + 32) + 8LL) + 24LL);
        uint64_t v71 = v2 + 544LL * v70;
        unsigned int v74 = *(unsigned __int8 *)(v71 + 172);
        uint64_t v72 = (_BYTE *)(v71 + 172);
        unsigned int v73 = v74;
        if (v74 >= 5) {
          int v75 = 5;
        }
        else {
          int v75 = v73;
        }
        if (v75)
        {
          int v76 = 0;
          unint64_t v77 = 0LL;
          do
          {
            uint64_t v78 = *v3;
            BOOL v79 = v3;
            if (os_log_type_enabled(*v3, OS_LOG_TYPE_INFO))
            {
              int v80 = @"UNKNOWN";
              if (v70 <= 2u) {
                int v80 = off_1008A4258[(char)v70];
              }
              uint64_t v81 = (uint64_t)(&v186)[v77];
              int v82 = *(unsigned __int8 *)(v81 + 6);
              int v83 = *(_DWORD *)(v81 + 38);
              int v84 = *(char *)(v81 + 42);
              *(_DWORD *)__int128 buf = 138414850;
              *(void *)&uint8_t buf[4] = v80;
              *(_WORD *)&_BYTE buf[12] = 1024;
              *(_DWORD *)&buf[14] = v77;
              *(_WORD *)&_BYTE buf[18] = 1040;
              *(_DWORD *)&_BYTE buf[20] = 43;
              *(_WORD *)int v156 = 2096;
              *(void *)&v156[2] = v81;
              *(_WORD *)&v156[10] = 1040;
              *(_DWORD *)&v156[12] = 6;
              *(_WORD *)&v156[16] = 2096;
              uint64_t v157 = v81;
              *(_WORD *)int v158 = 1024;
              *(_DWORD *)&v158[2] = v82;
              *(_WORD *)__int128 v159 = 1040;
              *(_DWORD *)&v159[2] = 31;
              __int16 v160 = 2096;
              uint64_t v161 = v81 + 7;
              __int16 v162 = 1024;
              int v163 = v83;
              __int16 v164 = 1024;
              int v165 = v84;
              _os_log_impl( (void *)&_mh_execute_header,  v78,  OS_LOG_TYPE_INFO,  "ADVBUFF(%@): Parsing entry %d entry_buff:%.43P address:%.6P len:%d payload:%.31P timestamp:%d rssi:%d",  buf,  0x54u);
            }

            else
            {
              uint64_t v81 = (uint64_t)(&v186)[v77];
            }

            unsigned int v85 = *(unsigned __int8 *)(v81 + 6);
            if (v85 < 0x20)
            {
              bzero(buf, 0x1788uLL);
              *(_OWORD *)uint64_t v141 = 0u;
              memset(v140, 0, sizeof(v140));
              sub_1001F0050((uint64_t)&v140[2], v81, 6uLL);
              unint64_t v87 = ((unint64_t)v140[2] << 40) | ((unint64_t)v140[3] << 32) | ((unint64_t)v140[4] << 24) | ((unint64_t)v140[5] << 16) | ((unint64_t)v140[6] << 8) | v140[7] | ((unint64_t)v140[1] << 48);
              if (!v87 || HIWORD(v87) && (HIWORD(v87) != 1 || (v140[2] & 0xC0) == 0x80LL))
              {
                unint64_t v88 = *v79;
                if (os_log_type_enabled(*v79, OS_LOG_TYPE_ERROR))
                {
                  unint64_t v103 = *(char *)(*(void *)(*(void *)(a1 + 32) + 8LL) + 24LL);
                  uint64_t v126 = @"UNKNOWN";
                  if (v103 <= 2) {
                    uint64_t v126 = off_1008A4258[v103];
                  }
                  id v104 = sub_1005BFB9C(v87);
                  int v105 = (void *)objc_claimAutoreleasedReturnValue(v104);
                  *(_DWORD *)int v152 = 138412546;
                  *(void *)&v152[4] = v126;
                  *(_WORD *)&v152[12] = 2112;
                  *(void *)&v152[14] = v105;
                  _os_log_error_impl( (void *)&_mh_execute_header,  v88,  OS_LOG_TYPE_ERROR,  "ADVBUFF(%@): Remote Bluetooth address %@ is invalid!",  v152,  0x16u);
                }
              }

              uint8_t v89 = sub_1005E57E4(v2, *(char *)(v81 + 42));
              *(_BYTE *)(v81 + 42) = v89;
              *(_WORD *)char v140 = 259;
              *(_WORD *)&v140[8] = *(unsigned __int8 *)(v81 + 6);
              v140[24] = v89;
              *(void *)&v140[16] = v81 + 7;
              v140[43] = 0;
              char v130 = 0;
              sub_100242CA4(&v130);
              sub_1001BA69C(v140, (uint64_t)buf, v90, v91);
              sub_100242CD0(&v130);
              uint8_t buf[16] = 0;
              uint64_t v92 = *(void *)(a1 + 32);
              BOOL v176 = v76 + *(unsigned __int8 *)(v2 + 544LL * *(unsigned __int8 *)(*(void *)(v92 + 8) + 24LL) + 172) > 1;
              LOBYTE(v177) = 1;
              int v93 = *v128;
              unsigned int v94 = *(_DWORD *)(v81 + 38);
              if (*v128 < v94) {
                int v93 = *v128 + 0xFFFFFFF;
              }
              unsigned int v175 = v93 - v94;
              uint64_t v95 = *v79;
              if (os_log_type_enabled(*v79, OS_LOG_TYPE_INFO))
              {
                unint64_t v96 = *(char *)(*(void *)(v92 + 8) + 24LL);
                uint64_t v97 = @"UNKNOWN";
                if (v96 <= 2) {
                  uint64_t v97 = off_1008A4258[v96];
                }
                int v98 = *v128;
                int v99 = *(_DWORD *)(v81 + 38);
                *(_DWORD *)int v152 = 138413826;
                *(void *)&v152[4] = v97;
                *(_WORD *)&v152[12] = 1040;
                *(_DWORD *)&v152[14] = 6;
                *(_WORD *)&v152[18] = 2096;
                *(void *)&v152[20] = &v140[2];
                *(_WORD *)&v152[28] = 1024;
                *(_DWORD *)&v152[30] = v98;
                *(_WORD *)&v152[34] = 1024;
                *(_DWORD *)&v152[36] = v99;
                *(_WORD *)&v152[40] = 1024;
                *(_DWORD *)&v152[42] = v175;
                *(_WORD *)&v152[46] = 1024;
                LODWORD(v153) = *(unsigned __int16 *)&v140[8];
                _os_log_impl( (void *)&_mh_execute_header,  v95,  OS_LOG_TYPE_INFO,  "ADVBUFF(%@): found %.6P now:%u event:%u delta:%u dataLen:%d",  v152,  0x34u);
              }

              sub_1005E5C78(buf);
              sub_100242CD8(&v130);
              BOOL v3 = v79;
            }

            else
            {
              BOOL v3 = v79;
              char v86 = *v79;
              if (os_log_type_enabled(*v79, OS_LOG_TYPE_ERROR))
              {
                *(_DWORD *)__int128 buf = 67109120;
                *(_DWORD *)&uint8_t buf[4] = v85;
                _os_log_error_impl( (void *)&_mh_execute_header,  v86,  OS_LOG_TYPE_ERROR,  "Ignoring invalid data length %d",  buf,  8u);
              }
            }

            ++v77;
            unsigned __int8 v70 = *(_BYTE *)(*(void *)(*(void *)(a1 + 32) + 8LL) + 24LL);
            uint64_t v100 = v2 + 544LL * v70;
            unsigned int v101 = *(unsigned __int8 *)(v100 + 172);
            uint64_t v72 = (_BYTE *)(v100 + 172);
            unsigned int v73 = v101;
            if (v101 >= 5) {
              unint64_t v102 = 5LL;
            }
            else {
              unint64_t v102 = v73;
            }
            --v76;
          }

          while (v77 < v102);
        }

        else
        {
          LOBYTE(v77) = 0;
        }

        _BYTE *v72 = v73 - v77;
        __int128 v106 = *v3;
        if (os_log_type_enabled(*v3, OS_LOG_TYPE_INFO))
        {
          unint64_t v107 = *(char *)(*(void *)(*(void *)(a1 + 32) + 8LL) + 24LL);
          if (v107 > 2) {
            __int128 v108 = @"UNKNOWN";
          }
          else {
            __int128 v108 = off_1008A4258[v107];
          }
          int v110 = *(unsigned __int8 *)(v2
          *(_DWORD *)__int128 buf = 138412546;
          *(void *)&uint8_t buf[4] = v108;
          *(_WORD *)&_BYTE buf[12] = 1024;
          *(_DWORD *)&buf[14] = v110;
          _os_log_impl( (void *)&_mh_execute_header,  v106,  OS_LOG_TYPE_INFO,  "ADVBUFF(%@): after parsing, expectedEntries=%d ",  buf,  0x12u);
        }

        unsigned int v111 = *(unsigned __int8 *)(*(void *)(*(void *)(a1 + 32) + 8LL) + 24LL);
        if (!*(_BYTE *)(v2 + 544LL * *(unsigned __int8 *)(*(void *)(*(void *)(a1 + 32) + 8LL) + 24LL) + 172))
        {
          __int128 v112 = *v3;
          if (os_log_type_enabled(*v3, OS_LOG_TYPE_INFO))
          {
            if (v111 > 2) {
              int v113 = @"UNKNOWN";
            }
            else {
              int v113 = off_1008A4258[(char)v111];
            }
            int v121 = *(unsigned __int8 *)(v2 + 144);
            int v122 = *(unsigned __int8 *)(v2
            *(_DWORD *)__int128 buf = 138412802;
            *(void *)&uint8_t buf[4] = v113;
            *(_WORD *)&_BYTE buf[12] = 1024;
            *(_DWORD *)&buf[14] = v121;
            *(_WORD *)&_BYTE buf[18] = 1024;
            *(_DWORD *)&_BYTE buf[20] = v122;
            _os_log_impl( (void *)&_mh_execute_header,  v112,  OS_LOG_TYPE_INFO,  "ADVBUFF(%@): We're done screenstate=%d fADVBufferExpectedEntries=%d",  buf,  0x18u);
            unsigned int v111 = *(unsigned __int8 *)(*(void *)(*(void *)(a1 + 32) + 8LL) + 24LL);
          }

          *(_BYTE *)(v2 + 160 + 544LL * v111 + 12) = -1;
          *(_BYTE *)(v2 + 160 + 544LL * *(unsigned __int8 *)(*(void *)(*(void *)(a1 + 32) + 8LL) + 24LL) + 11) = 0;
          uint64_t v123 = sub_100404FE8();
          v129[0] = _NSConcreteStackBlock;
          v129[1] = 3221225472LL;
          v129[2] = sub_1005E95D0;
          v129[3] = &unk_10087EB20;
          v129[4] = v2;
          sub_100405384(v123, v129);
        }

        goto LABEL_31;
      }

      goto LABEL_26;
    }

    if (v15 != 2 || !*(_BYTE *)(v2 + 1260) || *(unsigned __int8 *)(v2 + 1260) == 255)
    {
LABEL_26:
      std::string::size_type v22 = (os_log_s *)qword_1008F76B8;
      if (os_log_type_enabled((os_log_t)qword_1008F76B8, OS_LOG_TYPE_ERROR))
      {
        if (v15 > 2) {
          char v23 = @"UNKNOWN";
        }
        else {
          char v23 = off_1008A4258[(char)v15];
        }
        int v109 = *(unsigned __int8 *)(v2
        *(_DWORD *)__int128 buf = 138412546;
        *(void *)&uint8_t buf[4] = v23;
        *(_WORD *)&_BYTE buf[12] = 1024;
        *(_DWORD *)&buf[14] = v109;
        _os_log_error_impl( (void *)&_mh_execute_header,  v22,  OS_LOG_TYPE_ERROR,  "ADVBUFF(%@): invalid state expectedEntries=%d",  buf,  0x12u);
      }

      goto LABEL_31;
    }

    unint64_t v24 = 0LL;
    uint64_t v25 = *(void *)(a1 + 48);
    int v186 = (_DWORD *)(v25 + 4);
    __int128 v187 = (char *)(v25 + 52);
    int v188 = (char *)(v25 + 100);
    __int128 v189 = (char *)(v25 + 148);
    int v190 = (_DWORD *)(v25 + 196);
    do
    {
      uint64_t v26 = sub_1002E6E00();
      if ((*(unsigned int (**)(uint64_t))(*(void *)v26 + 176LL))(v26))
      {
        unsigned __int16 v27 = (os_log_s *)qword_1008F76D8;
        if (os_log_type_enabled((os_log_t)qword_1008F76D8, OS_LOG_TYPE_DEBUG))
        {
          unint64_t v51 = *(char *)(*(void *)(*(void *)(a1 + 32) + 8LL) + 24LL);
          uint64_t v52 = @"UNKNOWN";
          if (v51 <= 2) {
            uint64_t v52 = off_1008A4258[v51];
          }
          uint64_t v53 = (uint64_t)(&v186)[v24];
          int v54 = *(unsigned __int8 *)(v53 + 6);
          int v55 = *(unsigned __int16 *)(v53 + 38);
          int v56 = *(unsigned __int16 *)(v53 + 40);
          int v57 = *(char *)(v53 + 46);
          int v58 = *(char *)(v53 + 47);
          *(_DWORD *)__int128 buf = 138415874;
          *(void *)&uint8_t buf[4] = v52;
          *(_WORD *)&_BYTE buf[12] = 1024;
          *(_DWORD *)&buf[14] = v24;
          *(_WORD *)&_BYTE buf[18] = 1040;
          *(_DWORD *)&_BYTE buf[20] = 48;
          *(_WORD *)int v156 = 2096;
          *(void *)&v156[2] = v53;
          *(_WORD *)&v156[10] = 1040;
          *(_DWORD *)&v156[12] = 6;
          *(_WORD *)&v156[16] = 2096;
          uint64_t v157 = v53;
          *(_WORD *)int v158 = 1024;
          *(_DWORD *)&v158[2] = v54;
          *(_WORD *)__int128 v159 = 1040;
          *(_DWORD *)&v159[2] = 31;
          __int16 v160 = 2096;
          uint64_t v161 = v53 + 7;
          __int16 v162 = 1024;
          int v163 = v55;
          __int16 v164 = 1024;
          int v165 = v56;
          __int16 v166 = 1040;
          int v167 = 4;
          __int16 v168 = 2096;
          uint64_t v169 = v53 + 42;
          __int16 v170 = 1024;
          int v171 = v57;
          __int16 v172 = 1024;
          int v173 = v58;
          _os_log_debug_impl( (void *)&_mh_execute_header,  v27,  OS_LOG_TYPE_DEBUG,  "ADVBUFF(%@): Parsing entry %d entry_buff:%.48P address:%.6P len:%d payload:%.31P first:%d last:%d rssi:%.4P maxRSSI:%d avgRSSI:%d",  buf,  0x70u);
        }
      }

      uint64_t v28 = (uint64_t)(&v186)[v24];
      unsigned int v29 = *(unsigned __int8 *)(v28 + 6);
      if (v29 < 0x20)
      {
        bzero(buf, 0x1788uLL);
        __int128 v153 = 0u;
        __int128 v154 = 0u;
        memset(v152, 0, sizeof(v152));
        sub_1001F0050((uint64_t)&v152[2], v28, 6uLL);
        unint64_t v31 = ((unint64_t)v152[2] << 40) | ((unint64_t)v152[3] << 32) | ((unint64_t)v152[4] << 24) | ((unint64_t)v152[5] << 16) | ((unint64_t)v152[6] << 8) | v152[7] | ((unint64_t)v152[1] << 48);
        if (!v31 || HIWORD(v31) && (HIWORD(v31) != 1 || (v152[2] & 0xC0) == 0x80LL))
        {
          __int16 v32 = (os_log_s *)qword_1008F76B8;
          if (os_log_type_enabled((os_log_t)qword_1008F76B8, OS_LOG_TYPE_ERROR))
          {
            unint64_t v59 = *(char *)(*(void *)(*(void *)(a1 + 32) + 8LL) + 24LL);
            __int128 v127 = @"UNKNOWN";
            if (v59 <= 2) {
              __int128 v127 = off_1008A4258[v59];
            }
            id v60 = sub_1005BFB9C(v31);
            BOOL v61 = (void *)objc_claimAutoreleasedReturnValue(v60);
            *(_DWORD *)char v140 = 138412546;
            *(void *)&v140[4] = v127;
            *(_WORD *)&v140[12] = 2112;
            *(void *)&v140[14] = v61;
            _os_log_error_impl( (void *)&_mh_execute_header,  v32,  OS_LOG_TYPE_ERROR,  "ADVBUFF(%@): Remote Bluetooth address %@ is invalid!",  v140,  0x16u);
          }
        }

        *(_BYTE *)(v28 + 46) = sub_1005E57E4(v2, *(char *)(v28 + 46));
        int v33 = sub_1005E57E4(v2, *(char *)(v28 + 47));
        int v34 = v33;
        *(_BYTE *)(v28 + 47) = v33;
        int v35 = *(char *)(v28 + 46);
        if (v35 > 0 || v33 >= 1)
        {
          __int128 v45 = (os_log_s *)qword_1008F76B8;
          if (os_log_type_enabled((os_log_t)qword_1008F76B8, OS_LOG_TYPE_ERROR))
          {
            id v62 = sub_1005BFB9C(v31);
            int v63 = (void *)objc_claimAutoreleasedReturnValue(v62);
            *(_DWORD *)char v140 = 67109634;
            *(_DWORD *)&v140[4] = v34;
            *(_WORD *)&v140[8] = 1024;
            *(_DWORD *)&v140[10] = v35;
            *(_WORD *)&v140[14] = 2112;
            *(void *)&v140[16] = v63;
            _os_log_error_impl( (void *)&_mh_execute_header,  v45,  OS_LOG_TYPE_ERROR,  "Ignoring invalid RSSI level (avg:%d/max:%d) received from device %@",  v140,  0x18u);
          }
        }

        else
        {
          *(_WORD *)int v152 = 259;
          *(_WORD *)&v152[8] = *(unsigned __int8 *)(v28 + 6);
          *(void *)&v152[16] = v28 + 7;
          v152[43] = 0;
          char v130 = 0;
          sub_100242CA4(&v130);
          sub_1001BA69C(v152, (uint64_t)buf, v36, v37);
          sub_100242CD0(&v130);
          uint64_t v38 = 0LL;
          uint8_t buf[16] = 0;
          BOOL v176 = *(unsigned __int8 *)(v2
                                    + 544LL * *(unsigned __int8 *)(*(void *)(*(void *)(a1 + 32) + 8LL) + 24LL)
                                    + 172)
               - (int)v24 > 1;
          __int16 v177 = 257;
          char v182 = *(_BYTE *)(v28 + 46);
          char v183 = *(_BYTE *)(v28 + 47);
          char v174 = v182;
          do
          {
            *(&v178 + v38) = *(_BYTE *)(v28 + 42 + v38);
            ++v38;
          }

          while (v38 != 4);
          int v184 = *(unsigned __int16 *)(v28 + 38);
          int v185 = *(unsigned __int16 *)(v28 + 40);
          uint64_t v39 = sub_1002E6E00();
          if ((*(unsigned int (**)(uint64_t))(*(void *)v39 + 176LL))(v39))
          {
            __int128 v40 = (os_log_s *)qword_1008F76D8;
            if (os_log_type_enabled((os_log_t)qword_1008F76D8, OS_LOG_TYPE_INFO))
            {
              unint64_t v43 = *(char *)(*(void *)(*(void *)(a1 + 32) + 8LL) + 24LL);
              __int128 v44 = @"UNKNOWN";
              if (v43 <= 2) {
                __int128 v44 = off_1008A4258[v43];
              }
              LODWORD(v41) = v184;
              LODWORD(v42) = v185;
              *(_DWORD *)char v140 = 138415874;
              *(void *)&v140[4] = v44;
              *(_WORD *)&v140[12] = 1040;
              *(_DWORD *)&v140[14] = 6;
              *(_WORD *)&v140[18] = 2096;
              *(void *)&v140[20] = &v152[2];
              *(_WORD *)&v140[28] = 1040;
              *(_DWORD *)&v140[30] = 31;
              *(_WORD *)&v140[34] = 2096;
              *(void *)&v140[36] = *(void *)&v152[16];
              *(_WORD *)&v140[44] = 2048;
              *(double *)&v140[46] = (double)v41 * 0.02;
              *(_WORD *)&v140[54] = 2048;
              *(double *)&v140[56] = (double)v42 * 0.02;
              *(_WORD *)uint64_t v141 = 1024;
              *(_DWORD *)&v141[2] = *(unsigned __int16 *)&v152[8];
              *(_WORD *)&v141[6] = 1024;
              *(_DWORD *)&v141[8] = v182;
              *(_WORD *)&v141[12] = 1024;
              *(_DWORD *)&v141[14] = v183;
              __int16 v142 = 1024;
              int v143 = v178;
              __int16 v144 = 1024;
              int v145 = v179;
              __int16 v146 = 1024;
              int v147 = v180;
              __int16 v148 = 1024;
              int v149 = v181;
              __int16 v150 = 1024;
              int v151 = v179 + v178 + 2 * v180;
              _os_log_impl( (void *)&_mh_execute_header,  v40,  OS_LOG_TYPE_INFO,  "ADVBUFF(%@): found %.6P payload:%.31P first:%fs last:%fs dataLen:%d maxRSSI:%d avgRSSI:%d bin0:%d bin1:% d bin2:%d bin3:%d total:%d",  v140,  0x70u);
            }
          }

          ++*(void *)(v2 + 2312);
          sub_1005E5C78(buf);
          sub_100242CD8(&v130);
        }
      }

      else
      {
        __int16 v30 = (os_log_s *)qword_1008F76B8;
        if (os_log_type_enabled((os_log_t)qword_1008F76B8, OS_LOG_TYPE_ERROR))
        {
          *(_DWORD *)__int128 buf = 67109120;
          *(_DWORD *)&uint8_t buf[4] = v29;
          _os_log_error_impl( (void *)&_mh_execute_header,  v30,  OS_LOG_TYPE_ERROR,  "Ignoring invalid data length %d",  buf,  8u);
        }
      }

      ++v24;
      uint64_t v46 = v2 + 544LL * *(unsigned __int8 *)(*(void *)(*(void *)(a1 + 32) + 8LL) + 24LL);
      unsigned int v49 = *(unsigned __int8 *)(v46 + 172);
      __int128 v47 = (_BYTE *)(v46 + 172);
      unsigned int v48 = v49;
      if (v49 >= 5) {
        unint64_t v50 = 5LL;
      }
      else {
        unint64_t v50 = v48;
      }
    }

    while (v24 < v50);
    _BYTE *v47 = v48 - v24;
    signed __int8 v64 = (os_log_s *)qword_1008F76D8;
    if (os_log_type_enabled((os_log_t)qword_1008F76D8, OS_LOG_TYPE_INFO))
    {
      unint64_t v66 = *(char *)(*(void *)(*(void *)(a1 + 32) + 8LL) + 24LL);
      if (v66 > 2) {
        int v67 = @"UNKNOWN";
      }
      else {
        int v67 = off_1008A4258[v66];
      }
      int v114 = *(unsigned __int8 *)(v2 + 544LL * *(unsigned __int8 *)(*(void *)(*(void *)(a1 + 32) + 8LL) + 24LL) + 172);
      *(_DWORD *)__int128 buf = 138412546;
      *(void *)&uint8_t buf[4] = v67;
      *(_WORD *)&_BYTE buf[12] = 1024;
      *(_DWORD *)&buf[14] = v114;
      _os_log_impl( (void *)&_mh_execute_header,  v64,  OS_LOG_TYPE_INFO,  "ADVBUFF(%@): after parsing,expectedEntries=%d ",  buf,  0x12u);
    }

    uint64_t v115 = v2 + 544LL * *(unsigned __int8 *)(*(void *)(*(void *)(a1 + 32) + 8LL) + 24LL);
    int v117 = *(unsigned __int8 *)(v115 + 172);
    __n128 v116 = (_BYTE *)(v115 + 172);
    if (!v117)
    {
      _BYTE *v116 = -1;
      __n128 v118 = (os_log_s *)qword_1008F75B8;
      if (os_log_type_enabled((os_log_t)qword_1008F75B8, OS_LOG_TYPE_INFO))
      {
        unint64_t v119 = *(char *)(*(void *)(*(void *)(a1 + 32) + 8LL) + 24LL);
        if (v119 > 2) {
          uint64_t v120 = @"UNKNOWN";
        }
        else {
          uint64_t v120 = off_1008A4258[v119];
        }
        int v124 = *(unsigned __int8 *)(v2
        *(_DWORD *)__int128 buf = 138412546;
        *(void *)&uint8_t buf[4] = v120;
        *(_WORD *)&_BYTE buf[12] = 1024;
        *(_DWORD *)&buf[14] = v124;
        _os_log_impl( (void *)&_mh_execute_header,  v118,  OS_LOG_TYPE_INFO,  "ADVBUFF(%@): We're done expectedEntries=%d",  buf,  0x12u);
      }

      uint64_t v125 = sub_100404FE8();
      *(void *)__int128 buf = _NSConcreteStackBlock;
      *(void *)&uint8_t buf[8] = 3221225472LL;
      *(void *)&uint8_t buf[16] = sub_1006004B4;
      *(void *)int v156 = &unk_10087EB20;
      *(void *)&v156[8] = v2;
      sub_100405384(v125, buf);
      sub_1005E9E20(v2, *(unsigned __int8 *)(*(void *)(*(void *)(a1 + 32) + 8LL) + 24LL), 1);
      sub_1005EA3D8(v2);
      *(_BYTE *)(v2 + 544LL * *(unsigned __int8 *)(*(void *)(*(void *)(a1 + 32) + 8LL) + 24LL) + 171) = 0;
    }
  }

  else
  {
    uint64_t v20 = (os_log_s *)qword_1008F75B8;
    if (os_log_type_enabled((os_log_t)qword_1008F75B8, OS_LOG_TYPE_DEFAULT))
    {
      if (v15 > 2) {
        uint64_t v21 = @"UNKNOWN";
      }
      else {
        uint64_t v21 = off_1008A4258[(char)v15];
      }
      *(_DWORD *)__int128 buf = 138412290;
      *(void *)&uint8_t buf[4] = v21;
      _os_log_impl( (void *)&_mh_execute_header,  v20,  OS_LOG_TYPE_DEFAULT,  "ADVBUFF(%@): Received AdvBufferEvent for a buffer that is not created, ignoring",  buf,  0xCu);
    }
  }

void sub_1005E95A8( _Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20, uint64_t a21, uint64_t a22, uint64_t a23, uint64_t a24, uint64_t a25, uint64_t a26, uint64_t a27, int a28, __int16 a29, char a30, char a31)
{
}

void sub_1005E95D0(uint64_t a1)
{
}

void sub_1005E95D8(uint64_t a1)
{
  if (qword_1008F1EE0 != -1) {
    dispatch_once(&qword_1008F1EE0, &stru_1008A3A78);
  }
  uint64_t v2 = (os_log_s *)qword_1008F75B8;
  if (os_log_type_enabled((os_log_t)qword_1008F75B8, OS_LOG_TYPE_INFO))
  {
    *(_WORD *)__int128 buf = 0;
    _os_log_impl((void *)&_mh_execute_header, v2, OS_LOG_TYPE_INFO, "ADVBUFF readNextADVBuffer", buf, 2u);
  }

  if (sub_1005EBF48(a1))
  {
    unint64_t v4 = 0LL;
    unint64_t v5 = (unsigned __int8 *)(a1 + 169);
    *(void *)&__int128 v3 = 138413058LL;
    __int128 v46 = v3;
    do
    {
      uint64_t v6 = (os_log_s *)qword_1008F75B8;
      if (os_log_type_enabled((os_log_t)qword_1008F75B8, OS_LOG_TYPE_INFO))
      {
        int v7 = @"UNKNOWN";
        int v8 = *v5;
        int v9 = *(unsigned __int8 *)(a1 + v4 + 1793);
        *(_DWORD *)__int128 buf = 138412802;
        unint64_t v51 = v7;
        __int16 v52 = 1024;
        *(_DWORD *)uint64_t v53 = v8;
        *(_WORD *)&v53[4] = 1024;
        *(_DWORD *)&v53[6] = v9;
        _os_log_impl( (void *)&_mh_execute_header,  v6,  OS_LOG_TYPE_INFO,  "ADVBUFF(%@): pendingDraining:%d fObjectDiscoveryBuffersToRead:%d",  buf,  0x18u);
      }

      if (*(_BYTE *)(a1 + v4 + 1793) && *v5)
      {
        *(_BYTE *)(a1 + v4 + 1793) = 0;
        int v10 = (os_log_s *)qword_1008F75B8;
        if (os_log_type_enabled((os_log_t)qword_1008F75B8, OS_LOG_TYPE_INFO))
        {
          int v11 = @"UNKNOWN";
          int v12 = v5[3];
          int v13 = v5[2];
          *(_DWORD *)__int128 buf = 138412802;
          unint64_t v51 = v11;
          __int16 v52 = 1024;
          *(_DWORD *)uint64_t v53 = v12;
          *(_WORD *)&v53[4] = 1024;
          *(_DWORD *)&v53[6] = v13;
          _os_log_impl( (void *)&_mh_execute_header,  v10,  OS_LOG_TYPE_INFO,  "ADVBUFF(%@): expectedEntries=%d readInProgress:%d",  buf,  0x18u);
        }

        if (v5[3] == 255)
        {
          int v14 = (os_log_s *)qword_1008F75B8;
        }

        else
        {
          int v14 = (os_log_s *)qword_1008F75B8;
          if (!v5[2])
          {
            if (os_log_type_enabled((os_log_t)qword_1008F75B8, OS_LOG_TYPE_INFO))
            {
              else {
                unint64_t v43 = off_1008A4258[v4];
              }
              *(_DWORD *)__int128 buf = 138412290;
              unint64_t v51 = v43;
              _os_log_impl( (void *)&_mh_execute_header,  v14,  OS_LOG_TYPE_INFO,  "ADVBUFF(%@): Already reading ADV Buffer",  buf,  0xCu);
            }

void sub_1005E9E00(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

uint64_t sub_1005E9E20(uint64_t a1, uint64_t a2, int a3)
{
  if (a2 >= 3)
  {
    unint64_t v4 = (os_log_s *)qword_1008F75B8;
    if (os_log_type_enabled((os_log_t)qword_1008F75B8, OS_LOG_TYPE_DEFAULT))
    {
      int v41 = 67109120;
      LODWORD(v42) = a2;
      _os_log_impl( (void *)&_mh_execute_header,  v4,  OS_LOG_TYPE_DEFAULT,  "HW ADV Buffer handle out of range (%d), ignoring agent request",  (uint8_t *)&v41,  8u);
    }

    return 7LL;
  }

  unsigned int v8 = a2;
  if (a3 && *(_BYTE *)(a1 + 544LL * a2 + 170) && *(_BYTE *)(a1 + 544LL * a2 + 167))
  {
    int v9 = (os_log_s *)qword_1008F75B8;
    if (os_log_type_enabled((os_log_t)qword_1008F75B8, OS_LOG_TYPE_INFO))
    {
      else {
        int v10 = off_1008A4258[(char)a2];
      }
      int v41 = 138543362;
      unint64_t v42 = v10;
      _os_log_impl( (void *)&_mh_execute_header,  v9,  OS_LOG_TYPE_INFO,  "ADVBUFF(%{public}@): created and pending destroy",  (uint8_t *)&v41,  0xCu);
    }

    sub_1005E3ED4(a1, a2);
  }

  int v11 = (os_log_s *)qword_1008F75B8;
  if (os_log_type_enabled((os_log_t)qword_1008F75B8, OS_LOG_TYPE_INFO))
  {
    else {
      int v12 = off_1008A4258[(char)a2];
    }
    uint64_t v13 = a1 + 544LL * a2;
    int v14 = *(unsigned __int8 *)(v13 + 167);
    LODWORD(v13) = *(unsigned __int8 *)(v13 + 168);
    int v41 = 138544130;
    unint64_t v42 = v12;
    __int16 v43 = 1024;
    *(_DWORD *)__int128 v44 = a3;
    *(_WORD *)&v44[4] = 1024;
    *(_DWORD *)&v44[6] = v14;
    __int16 v45 = 1024;
    int v46 = v13;
    _os_log_impl( (void *)&_mh_execute_header,  v11,  OS_LOG_TYPE_INFO,  "ADVBUFF(%{public}@): enableADVBuffering enable=%d created=%d enabled=%d",  (uint8_t *)&v41,  0x1Eu);
  }

  if (!*(_BYTE *)(a1 + 544LL * v8 + 167))
  {
    uint64_t v21 = (os_log_s *)qword_1008F75B8;
    if (os_log_type_enabled((os_log_t)qword_1008F75B8, OS_LOG_TYPE_INFO))
    {
      else {
        uint64_t v22 = off_1008A4258[(char)a2];
      }
      int v41 = 138543362;
      unint64_t v42 = v22;
      uint64_t v5 = 12LL;
      _os_log_impl( (void *)&_mh_execute_header,  v21,  OS_LOG_TYPE_INFO,  "ADVBUFF(%{public}@): not created",  (uint8_t *)&v41,  0xCu);
      return v5;
    }

    return 12LL;
  }

  uint64_t v15 = a1 + 544LL * v8;
  int v17 = *(unsigned __int8 *)(v15 + 168);
  BOOL v16 = (_BYTE *)(v15 + 168);
  int v18 = (os_log_s *)qword_1008F75B8;
  BOOL v19 = os_log_type_enabled((os_log_t)qword_1008F75B8, OS_LOG_TYPE_INFO);
  if (v17 == a3)
  {
    if (v19)
    {
      else {
        int v20 = off_1008A4258[(char)a2];
      }
      unint64_t v24 = "paused";
      if (a3) {
        unint64_t v24 = "active";
      }
      int v41 = 138543618;
      unint64_t v42 = v20;
      __int16 v43 = 2082;
      *(void *)__int128 v44 = v24;
      _os_log_impl( (void *)&_mh_execute_header,  v18,  OS_LOG_TYPE_INFO,  "ADVBUFF(%{public}@): already %{public}s",  (uint8_t *)&v41,  0x16u);
    }

    return 12LL;
  }

  if (v19)
  {
    else {
      char v23 = off_1008A4258[(char)a2];
    }
    uint64_t v25 = "pausing";
    if (a3) {
      uint64_t v25 = "activating";
    }
    int v41 = 138543618;
    unint64_t v42 = v23;
    __int16 v43 = 2082;
    *(void *)__int128 v44 = v25;
    _os_log_impl( (void *)&_mh_execute_header,  v18,  OS_LOG_TYPE_INFO,  "ADVBUFF(%{public}@): mode change -> %{public}s ",  (uint8_t *)&v41,  0x16u);
  }

  uint64_t v26 = sub_1002E6E9C();
  uint64_t v5 = (*(uint64_t (**)(uint64_t, uint64_t, uint64_t, void))(*(void *)v26 + 2840LL))(v26, a2, 1LL, a3 ^ 1u);
  uint64_t v27 = (os_log_s *)qword_1008F75B8;
  if (os_log_type_enabled((os_log_t)qword_1008F75B8, OS_LOG_TYPE_INFO))
  {
    else {
      uint64_t v28 = off_1008A4258[(char)a2];
    }
    int v41 = 138543618;
    unint64_t v42 = v28;
    __int16 v43 = 1024;
    *(_DWORD *)__int128 v44 = v5;
    _os_log_impl( (void *)&_mh_execute_header,  v27,  OS_LOG_TYPE_INFO,  "ADVBUFF(%{public}@): advBufMatchControl returned %d",  (uint8_t *)&v41,  0x12u);
  }

  if ((_DWORD)v5)
  {
    if (os_log_type_enabled((os_log_t)qword_1008F75B8, OS_LOG_TYPE_ERROR)) {
      sub_10069C008();
    }
  }

  else
  {
    _BYTE *v16 = a3;
    uint64_t v29 = a1 + 544LL * v8;
    char v31 = *(_BYTE *)(v29 + 169);
    uint64_t v30 = (_BYTE *)(v29 + 169);
    *uint64_t v30 = v31 | a3;
    __int16 v32 = (os_log_s *)qword_1008F75B8;
    if (os_log_type_enabled((os_log_t)qword_1008F75B8, OS_LOG_TYPE_INFO))
    {
      else {
        int v33 = off_1008A4258[(char)a2];
      }
      int v34 = *v30;
      int v41 = 138543618;
      unint64_t v42 = v33;
      __int16 v43 = 1024;
      *(_DWORD *)__int128 v44 = v34;
      _os_log_impl( (void *)&_mh_execute_header,  v32,  OS_LOG_TYPE_INFO,  "ADVBUFF(%{public}@): pendingDraining:%d",  (uint8_t *)&v41,  0x12u);
    }

    if (a3)
    {
      uint64_t v35 = a1 + 544LL * v8;
      *(CFAbsoluteTime *)(v35 + 176) = CFAbsoluteTimeGetCurrent();
      uint8x8_t v36 = (uint64_t *)(v35 + 176);
      int16x8_t v37 = (os_log_s *)qword_1008F75B8;
      if (os_log_type_enabled((os_log_t)qword_1008F75B8, OS_LOG_TYPE_INFO))
      {
        else {
          uint64_t v38 = off_1008A4258[(char)a2];
        }
        uint64_t v39 = *v36;
        int v41 = 138543618;
        unint64_t v42 = v38;
        __int16 v43 = 2048;
        *(void *)__int128 v44 = v39;
        _os_log_impl( (void *)&_mh_execute_header,  v37,  OS_LOG_TYPE_INFO,  "ADVBUFF(%{public}@): setting start time to %f",  (uint8_t *)&v41,  0x16u);
      }
    }

    return 0LL;
  }

  return v5;
}

void sub_1005EA3D8(uint64_t a1)
{
  if (!*(void *)(a1 + 2272))
  {
    uint64_t v2 = sub_100404FE8();
    __int128 v3 = dispatch_source_create( (dispatch_source_type_t)&_dispatch_source_type_timer,  0LL,  0LL,  *(dispatch_queue_t *)(v2 + 8));
    *(void *)(a1 + 2272) = v3;
    unint64_t v4 = (os_log_s *)qword_1008F76D8;
    if (os_log_type_enabled((os_log_t)qword_1008F76D8, OS_LOG_TYPE_DEFAULT))
    {
      *(_WORD *)__int128 buf = 0;
      _os_log_impl( (void *)&_mh_execute_header,  v4,  OS_LOG_TYPE_DEFAULT,  "fContactTracingScanDeltaTimer Timer Armed!",  buf,  2u);
      __int128 v3 = *(dispatch_source_s **)(a1 + 2272);
    }

    handler[0] = _NSConcreteStackBlock;
    handler[1] = 3221225472LL;
    handler[2] = sub_100600CC8;
    handler[3] = &unk_10087EB20;
    handler[4] = a1;
    dispatch_source_set_event_handler(v3, handler);
    uint64_t v5 = *(dispatch_source_s **)(a1 + 2272);
    if (qword_1008D9700 != -1) {
      dispatch_once(&qword_1008D9700, &stru_1008A40D8);
    }
    uint64_t v6 = sub_1003AC838((uint64_t)off_1008D96F8);
    dispatch_time_t v7 = dispatch_time(0x8000000000000000LL, 1000000 * v6);
    dispatch_source_set_timer(v5, v7, 0xFFFFFFFFFFFFFFFFLL, 0LL);
    dispatch_activate(*(dispatch_object_t *)(a1 + 2272));
    if (*(_BYTE *)(a1 + 1255))
    {
      if (qword_1008D9700 != -1) {
        dispatch_once(&qword_1008D9700, &stru_1008A40D8);
      }
      uint64_t v8 = sub_1003AC804((uint64_t)off_1008D96F8);
    }

    else
    {
      if (qword_1008D9700 != -1) {
        dispatch_once(&qword_1008D9700, &stru_1008A40D8);
      }
      uint64_t v8 = sub_1003ACCC0((uint64_t)off_1008D96F8);
    }

    int v9 = (void *)objc_claimAutoreleasedReturnValue(+[NSDate date](&OBJC_CLASS___NSDate, "date"));
    [v9 timeIntervalSince1970];
    double v11 = v10;

    xpc_object_t v12 = xpc_dictionary_create(0LL, 0LL, 0LL);
    xpc_dictionary_set_date(v12, "Date", (uint64_t)((v11 + (double)v8) * 1000000000.0));
    uint64_t v13 = (os_log_s *)qword_1008F76D8;
    if (os_log_type_enabled((os_log_t)qword_1008F76D8, OS_LOG_TYPE_DEFAULT))
    {
      *(_DWORD *)__int128 buf = 134217984;
      uint64_t v16 = v8;
      _os_log_impl( (void *)&_mh_execute_header,  v13,  OS_LOG_TYPE_DEFAULT,  "XPC event com.apple.alarm for %llu seconds armed!",  buf,  0xCu);
    }

    xpc_set_event("com.apple.alarm", "com.apple.bluetooth.contactTracingScanSystemWake", v12);
    xpc_release(v12);
  }

void sub_1005EA67C(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_1005EA694(uint64_t a1, _OWORD *a2)
{
  unint64_t v4 = malloc(0xEEuLL);
  __int128 v5 = a2[13];
  v4[12] = a2[12];
  v4[13] = v5;
  *(_OWORD *)((char *)v4 + 222) = *(_OWORD *)((char *)a2 + 222);
  __int128 v6 = a2[9];
  v4[8] = a2[8];
  v4[9] = v6;
  __int128 v7 = a2[11];
  v4[10] = a2[10];
  v4[11] = v7;
  __int128 v8 = a2[5];
  void v4[4] = a2[4];
  v4[5] = v8;
  __int128 v9 = a2[7];
  v4[6] = a2[6];
  v4[7] = v9;
  __int128 v10 = a2[1];
  *unint64_t v4 = *a2;
  v4[1] = v10;
  __int128 v11 = a2[3];
  _DWORD v4[2] = a2[2];
  v4[3] = v11;
  uint64_t v12 = sub_100404FE8();
  v13[0] = _NSConcreteStackBlock;
  v13[1] = 3221225472LL;
  void v13[2] = sub_1005EA74C;
  v13[3] = &unk_10087F8E0;
  void v13[4] = a1;
  void v13[5] = v4;
  sub_100405384(v12, v13);
}

void sub_1005EA74C(uint64_t a1)
{
  uint64_t v1 = *(void *)(a1 + 32);
  uint64_t v2 = (os_log_s *)qword_1008F75B8;
  if (os_log_type_enabled((os_log_t)qword_1008F75B8, OS_LOG_TYPE_INFO))
  {
    int v3 = *(unsigned __int8 *)(v1 + 1851);
    int v4 = *(unsigned __int8 *)(v1 + 1852);
    int buf = 67109376;
    int v59 = v3;
    __int16 v60 = 1024;
    int v61 = v4;
    _os_log_impl( (void *)&_mh_execute_header,  v2,  OS_LOG_TYPE_INFO,  "Match Buffer matchBufferEvent fMatchBufferExpectedEntries:%d fMatchBufferEntriesReceived:%d",  (uint8_t *)&buf,  0xEu);
  }

  unsigned int v5 = *(unsigned __int8 *)(v1 + 1852);
  if (v5 <= 0x13 && *(unsigned __int8 *)(v1 + 1851) != 255)
  {
    unint64_t v6 = 0LL;
    uint64_t v7 = *(void *)(a1 + 40);
    v69[0] = v7 + 4;
    v69[1] = v7 + 22;
    v69[2] = v7 + 40;
    v69[3] = v7 + 58;
    v69[4] = v7 + 76;
    uint64_t v8 = v7 + 130;
    uint64_t v9 = v7 + 148;
    uint64_t v10 = v7 + 166;
    v69[5] = v7 + 94;
    v69[6] = v7 + 112;
    uint64_t v11 = v7 + 184;
    uint64_t v12 = v7 + 202;
    uint64_t v13 = v7 + 220;
    v69[7] = v8;
    v69[8] = v9;
    if (v5 >= 7) {
      unint64_t v14 = 20 - v5;
    }
    else {
      unint64_t v14 = 13LL;
    }
    v69[9] = v10;
    v69[10] = v11;
    v69[11] = v12;
    v69[12] = v13;
    do
    {
      unsigned __int8 v15 = *(_BYTE *)(v1 + 1852) + v6;
      uint64_t v16 = (os_log_s *)qword_1008F75B8;
      if (os_log_type_enabled((os_log_t)qword_1008F75B8, OS_LOG_TYPE_INFO))
      {
        int buf = 67109376;
        int v59 = v6;
        __int16 v60 = 1024;
        int v61 = v15;
        _os_log_impl( (void *)&_mh_execute_header,  v16,  OS_LOG_TYPE_INFO,  "Match Buffer Parsing i:%d tableIndex:%d",  (uint8_t *)&buf,  0xEu);
      }

      int v17 = (unsigned __int8 *)v69[v6];
      int v18 = (char)v17[17];
      if (v17[17] && *(_DWORD *)(v17 + 13))
      {
        --*(_BYTE *)(v1 + 1851);
        bzero(&buf, 0x1788uLL);
        __int128 v44 = 0u;
        __int128 v45 = 0u;
        __int128 v42 = 0u;
        __int128 v43 = 0u;
        __int128 v41 = 0u;
        BOOL v19 = (void *)objc_claimAutoreleasedReturnValue([*(id *)(v1 + 2112) objectAtIndex:v15]);
        int v20 = (void *)objc_claimAutoreleasedReturnValue([v19 objectForKeyedSubscript:@"MatchActionRulePeerAddress"]);
        objc_msgSend(v20, "getBytes:range:", (char *)&v41 + 2, 0, 6);

        LOWORD(v41) = 259;
        WORD4(v41) = *v17 + 1;
        BYTE8(v42) = sub_1005E57E4(v1, (char)v17[17]);
        *(void *)&__int128 v42 = v17;
        BYTE11(v43) = 0;
        char v40 = 0;
        sub_100242CA4(&v40);
        sub_1001BA69C((unsigned __int8 *)&v41, (uint64_t)&buf, v21, v22);
        sub_100242CD0(&v40);
        BOOL v67 = *(_BYTE *)(v1 + 1851) != 0;
        char v68 = 1;
        unsigned int v23 = **(_DWORD **)(a1 + 40);
        unsigned int v24 = *(_DWORD *)(v17 + 13);
        unsigned int v25 = v23 + 0xFFFFFFF;
        if (v23 >= v24) {
          unsigned int v25 = **(_DWORD **)(a1 + 40);
        }
        unsigned int v26 = v25 - v24;
        unsigned int v66 = v25 - v24;
        uint64_t v27 = (os_log_s *)qword_1008F75B8;
        if (os_log_type_enabled((os_log_t)qword_1008F75B8, OS_LOG_TYPE_INFO))
        {
          *(_DWORD *)int v46 = 68158978;
          int v47 = 6;
          __int16 v48 = 2096;
          unsigned int v49 = (char *)&v41 + 2;
          __int16 v50 = 1024;
          unsigned int v51 = v23;
          __int16 v52 = 1024;
          unsigned int v53 = v24;
          __int16 v54 = 1024;
          unsigned int v55 = v26;
          __int16 v56 = 1024;
          int v57 = WORD4(v41);
          _os_log_impl( (void *)&_mh_execute_header,  v27,  OS_LOG_TYPE_INFO,  "ADV Buffer found %.6P now:%u event:%u delta:%u dataLen:%d",  v46,  0x2Au);
        }

        sub_1005E5C78((unsigned __int8 *)&buf);
        sub_100242CD8(&v40);
      }

      else
      {
        uint64_t v28 = (os_log_s *)qword_1008F75B8;
        if (os_log_type_enabled((os_log_t)qword_1008F75B8, OS_LOG_TYPE_DEBUG))
        {
          int v29 = *(_DWORD *)(v17 + 13);
          int buf = 67109888;
          int v59 = v6;
          __int16 v60 = 1024;
          int v61 = v15;
          __int16 v62 = 1024;
          int v63 = v18;
          __int16 v64 = 1024;
          LODWORD(v65) = v29;
          _os_log_debug_impl( (void *)&_mh_execute_header,  v28,  OS_LOG_TYPE_DEBUG,  "Skipping entry i:%d tableIndex:%d rssi:%d timeStamp:%d",  (uint8_t *)&buf,  0x1Au);
        }
      }

      ++v6;
    }

    while (v6 < v14);
    unsigned __int8 v30 = *(_BYTE *)(v1 + 1852) + 13;
    *(_BYTE *)(v1 + 1852) = v30;
    char v31 = (os_log_s *)qword_1008F75B8;
    if (os_log_type_enabled((os_log_t)qword_1008F75B8, OS_LOG_TYPE_DEBUG))
    {
      int v38 = *(unsigned __int8 *)(v1 + 1851);
      int buf = 67109376;
      int v59 = v38;
      __int16 v60 = 1024;
      int v61 = v30;
      _os_log_debug_impl( (void *)&_mh_execute_header,  v31,  OS_LOG_TYPE_DEBUG,  "Match Buffer after parsing,fMatchBufferExpectedEntries:%d fMatchBufferEntriesReceived:%d",  (uint8_t *)&buf,  0xEu);
      unsigned __int8 v30 = *(_BYTE *)(v1 + 1852);
    }

    if (v30 >= 0x14u)
    {
      *(_WORD *)(v1 + 1851) = 255;
      __int16 v32 = (os_log_s *)qword_1008F75B8;
      if (os_log_type_enabled((os_log_t)qword_1008F75B8, OS_LOG_TYPE_INFO))
      {
        int v33 = *(unsigned __int8 *)(v1 + 144);
        if (*(void *)(v1 + 2120)) {
          int v34 = "YES";
        }
        else {
          int v34 = "NO";
        }
        int buf = 67109890;
        int v59 = v33;
        __int16 v60 = 1024;
        int v61 = 255;
        __int16 v62 = 1024;
        int v63 = 0;
        __int16 v64 = 2082;
        int v65 = v34;
        _os_log_impl( (void *)&_mh_execute_header,  v32,  OS_LOG_TYPE_INFO,  "Match Buffer We're done screenstate=%d fMatchBufferExpectedEntries:%d fMatchBufferEntriesReceived:%d pendingRules:%{public}s",  (uint8_t *)&buf,  0x1Eu);
      }

      *(_BYTE *)(v1 + 1853) = 0;
      uint64_t v35 = *(void *)(v1 + 2120);
      uint8x8_t v36 = (os_log_s *)qword_1008F75B8;
      BOOL v37 = os_log_type_enabled((os_log_t)qword_1008F75B8, OS_LOG_TYPE_INFO);
      if (v35)
      {
        if (v37)
        {
          LOWORD(buf) = 0;
          _os_log_impl( (void *)&_mh_execute_header,  v36,  OS_LOG_TYPE_INFO,  "Match Buffer Reconfiguring the table",  (uint8_t *)&buf,  2u);
        }

        sub_1005EADD8(v1);
        if (os_log_type_enabled((os_log_t)qword_1008F75B8, OS_LOG_TYPE_DEBUG)) {
          sub_10069C0F8();
        }
      }

      else
      {
        if (v37)
        {
          LOWORD(buf) = 0;
          _os_log_impl( (void *)&_mh_execute_header,  v36,  OS_LOG_TYPE_INFO,  "Match Buffer enabling the buffer again after reading",  (uint8_t *)&buf,  2u);
        }

        sub_1005EB324(v1, 1);
        if (os_log_type_enabled((os_log_t)qword_1008F75B8, OS_LOG_TYPE_DEBUG)) {
          sub_10069C098();
        }
      }
    }
  }

  free(*(void **)(a1 + 40));
}

void sub_1005EADA0(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

uint64_t sub_1005EADD8(uint64_t a1)
{
  uint64_t v2 = (os_log_s *)qword_1008F75B8;
  if (os_log_type_enabled((os_log_t)qword_1008F75B8, OS_LOG_TYPE_INFO))
  {
    *(_WORD *)int buf = 0;
    _os_log_impl((void *)&_mh_execute_header, v2, OS_LOG_TYPE_INFO, "configureMatchActionRulesTableInternal", buf, 2u);
  }

  int v3 = (id *)(a1 + 2112);
  objc_storeStrong((id *)(a1 + 2112), *(id *)(a1 + 2120));
  int v4 = *(void **)(a1 + 2120);
  *(void *)(a1 + 2120) = 0LL;

  if (*(void *)(a1 + 2112) && [*(id *)(a1 + 2112) count])
  {
    unsigned __int16 v32 = 256;
    uint64_t v5 = sub_1005FBAAC(a1, &v32);
    unint64_t v6 = (os_log_s *)qword_1008F75B8;
    if (os_log_type_enabled((os_log_t)qword_1008F75B8, OS_LOG_TYPE_INFO))
    {
      *(_DWORD *)int buf = 67109120;
      *(_DWORD *)&uint8_t buf[4] = v5;
      _os_log_impl( (void *)&_mh_execute_header,  v6,  OS_LOG_TYPE_INFO,  "createMatchActionRulesTable returned %d",  buf,  8u);
    }

    if ((_DWORD)v5 != 15 && (_DWORD)v5)
    {
      if (os_log_type_enabled((os_log_t)qword_1008F75B8, OS_LOG_TYPE_ERROR)) {
        sub_10069C188();
      }
    }

    else
    {
      else {
        int v7 = [*v3 count];
      }
      unsigned int v28 = v7;
      if (os_log_type_enabled((os_log_t)qword_1008F75B8, OS_LOG_TYPE_DEBUG)) {
        sub_10069C2A8();
      }
      unsigned int v27 = v32;
      unsigned int v11 = v28;
      if (v28)
      {
        unsigned int v12 = 0;
        unsigned __int8 v13 = 0;
        unint64_t v14 = (os_log_s *)qword_1008F75B8;
        *(void *)&__int128 v10 = 67109120LL;
        __int128 v26 = v10;
        while (1)
        {
          unsigned __int8 v29 = v13;
          char v31 = v12;
          *(_OWORD *)((char *)v48 + 14) = 0u;
          else {
            unsigned __int8 v15 = v11 - v12;
          }
          __int128 v47 = 0uLL;
          v48[0] = 0uLL;
          __int128 v45 = 0uLL;
          __int128 v46 = 0uLL;
          __int128 v43 = 0uLL;
          __int128 v44 = 0uLL;
          __int128 v42 = 0uLL;
          __int128 v40 = 0uLL;
          __int128 v41 = 0uLL;
          __int128 v38 = 0uLL;
          __int128 v39 = 0uLL;
          __int128 v36 = 0uLL;
          __int128 v37 = 0uLL;
          *(_OWORD *)int buf = 0uLL;
          if (os_log_type_enabled(v14, OS_LOG_TYPE_DEBUG))
          {
            *(_DWORD *)int v33 = v26;
            LODWORD(v34) = v15;
            _os_log_debug_impl((void *)&_mh_execute_header, v14, OS_LOG_TYPE_DEBUG, "count=%d", v33, 8u);
          }

          unsigned __int8 v30 = v15;
          if (v15)
          {
            uint64_t v16 = 0LL;
            uint64_t v17 = v12;
            uint64_t v18 = 17LL * v15;
            do
            {
              BOOL v19 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(*v3, "objectAtIndex:", v17, v26));
              int v20 = (os_log_s *)qword_1008F75B8;
              if (os_log_type_enabled((os_log_t)qword_1008F75B8, OS_LOG_TYPE_DEBUG))
              {
                *(_DWORD *)int v33 = 138412290;
                int v34 = v19;
                _os_log_debug_impl((void *)&_mh_execute_header, v20, OS_LOG_TYPE_DEBUG, "rule=%@", v33, 0xCu);
              }

              uint8x8_t v21 = (void *)objc_claimAutoreleasedReturnValue([v19 objectForKeyedSubscript:@"MatchActionRuleLocalToken"]);
              objc_msgSend(v21, "getBytes:range:", &buf[v16 + 7], 0, 6);

              int16x8_t v22 = (void *)objc_claimAutoreleasedReturnValue([v19 objectForKeyedSubscript:@"MatchActionRulePeerAddress"]);
              objc_msgSend(v22, "getBytes:range:", &buf[v16], 0, 6);

              unsigned int v23 = &buf[v16];
              v23[6] = 1;
              v23[13] = 18;

              v16 += 17LL;
              ++v17;
            }

            while (v18 != v16);
          }

          uint64_t v24 = sub_1002E6E9C();
          unsigned __int8 v13 = v30 + v31;
          uint64_t v5 = (*(uint64_t (**)(uint64_t, void, void, void, uint8_t *))(*(void *)v24 + 2864LL))( v24,  v27,  v29,  (v30 + v31 - 1),  buf);
          unint64_t v14 = (os_log_s *)qword_1008F75B8;
          if ((_DWORD)v5) {
            break;
          }
          unsigned int v12 = (v30 + v31);
          if (os_log_type_enabled((os_log_t)qword_1008F75B8, OS_LOG_TYPE_DEBUG))
          {
            *(_DWORD *)int v33 = v26;
            LODWORD(v34) = (v30 + v31);
            _os_log_debug_impl((void *)&_mh_execute_header, v14, OS_LOG_TYPE_DEBUG, "entriesSent=%d", v33, 8u);
            unint64_t v14 = (os_log_s *)qword_1008F75B8;
          }

          unsigned int v11 = v28;
          if (v28 <= v12)
          {
            unsigned int v27 = v32;
            goto LABEL_39;
          }
        }

        if (os_log_type_enabled((os_log_t)qword_1008F75B8, OS_LOG_TYPE_ERROR)) {
          sub_10069C248();
        }
      }

      else
      {
LABEL_39:
        uint64_t v25 = sub_1002E6E9C();
        uint64_t v5 = (*(uint64_t (**)(uint64_t, void, uint64_t, void))(*(void *)v25 + 2840LL))(v25, v27, 1LL, 0LL);
        if ((_DWORD)v5 && os_log_type_enabled((os_log_t)qword_1008F75B8, OS_LOG_TYPE_ERROR)) {
          sub_10069C1E8();
        }
      }
    }
  }

  else
  {
    uint64_t v8 = (os_log_s *)qword_1008F75B8;
    if (os_log_type_enabled((os_log_t)qword_1008F75B8, OS_LOG_TYPE_INFO))
    {
      *(_WORD *)int buf = 0;
      _os_log_impl((void *)&_mh_execute_header, v8, OS_LOG_TYPE_INFO, "new Match table rules are nil", buf, 2u);
    }

    return 0LL;
  }

  return v5;
}

void sub_1005EB2F4(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

uint64_t sub_1005EB324(uint64_t a1, int a2)
{
  int v4 = (os_log_s *)qword_1008F75B8;
  if (os_log_type_enabled((os_log_t)qword_1008F75B8, OS_LOG_TYPE_INFO))
  {
    int v17 = 67109120;
    LODWORD(v18) = a2;
    _os_log_impl( (void *)&_mh_execute_header,  v4,  OS_LOG_TYPE_INFO,  "Match Buffer enableMatchBuffering enable=%d",  (uint8_t *)&v17,  8u);
  }

  if (*(unsigned __int8 *)(a1 + 1851) == 255)
  {
    uint64_t v8 = *(void **)(a1 + 1816);
    if (v8 == (void *)(a1 + 1824))
    {
LABEL_16:
      unsigned int v12 = (os_log_s *)qword_1008F75B8;
      uint64_t v6 = 0LL;
      if (os_log_type_enabled((os_log_t)qword_1008F75B8, OS_LOG_TYPE_DEFAULT))
      {
        LOWORD(v17) = 0;
        _os_log_impl( (void *)&_mh_execute_header,  v12,  OS_LOG_TYPE_DEFAULT,  "No table is configured",  (uint8_t *)&v17,  2u);
        return 0LL;
      }
    }

    else
    {
      while (*((_BYTE *)v8 + 28) != 18)
      {
        uint64_t v9 = (void *)v8[1];
        if (v9)
        {
          do
          {
            __int128 v10 = v9;
            uint64_t v9 = (void *)*v9;
          }

          while (v9);
        }

        else
        {
          do
          {
            __int128 v10 = (void *)v8[2];
            BOOL v11 = *v10 == (void)v8;
            uint64_t v8 = v10;
          }

          while (!v11);
        }

        uint64_t v8 = v10;
        if (v10 == (void *)(a1 + 1824)) {
          goto LABEL_16;
        }
      }

      uint64_t v13 = *((unsigned __int16 *)v8 + 15);
      unint64_t v14 = (os_log_s *)qword_1008F75B8;
      if (os_log_type_enabled((os_log_t)qword_1008F75B8, OS_LOG_TYPE_INFO))
      {
        unsigned __int8 v15 = "pausing";
        if (a2) {
          unsigned __int8 v15 = "activating";
        }
        int v17 = 136446210;
        uint64_t v18 = v15;
        _os_log_impl( (void *)&_mh_execute_header,  v14,  OS_LOG_TYPE_INFO,  "Match Buffer mode change -> %{public}s ",  (uint8_t *)&v17,  0xCu);
      }

      uint64_t v16 = sub_1002E6E9C();
      uint64_t v6 = (*(uint64_t (**)(uint64_t, uint64_t, uint64_t, void))(*(void *)v16 + 2840LL))( v16,  v13,  1LL,  a2 ^ 1u);
      if ((_DWORD)v6 && os_log_type_enabled((os_log_t)qword_1008F75B8, OS_LOG_TYPE_ERROR)) {
        sub_10069C308();
      }
    }
  }

  else
  {
    uint64_t v5 = (os_log_s *)qword_1008F75B8;
    if (os_log_type_enabled((os_log_t)qword_1008F75B8, OS_LOG_TYPE_DEFAULT))
    {
      LOWORD(v17) = 0;
      _os_log_impl( (void *)&_mh_execute_header,  v5,  OS_LOG_TYPE_DEFAULT,  "We're in the middle of reading it, we cant pause now",  (uint8_t *)&v17,  2u);
    }

    return 12LL;
  }

  return v6;
}

void sub_1005EB568(uint64_t a1, uint64_t a2)
{
  if (a2)
  {
    uint64_t v2 = -[NSData initWithBytes:length:]( objc_alloc(&OBJC_CLASS___NSData),  "initWithBytes:length:",  a2,  *(unsigned __int8 *)(a2 + 1) + 4LL);
    objc_msgSend(gCBDaemonServer, "aopMessageReceived:");
  }

void sub_1005EB5D8( _Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, id a10)
{
}

uint64_t sub_1005EB5F0(uint64_t a1, void *a2)
{
  id v3 = a2;
  int v4 = (os_log_s *)qword_1008F75B8;
  if (os_log_type_enabled((os_log_t)qword_1008F75B8, OS_LOG_TYPE_INFO))
  {
    int v17 = 138412290;
    id v18 = v3;
    _os_log_impl( (void *)&_mh_execute_header,  v4,  OS_LOG_TYPE_INFO,  "Setting up match rules with %@",  (uint8_t *)&v17,  0xCu);
  }

  uint64_t v5 = sub_1002E6BF0();
  if ((*(unsigned int (**)(uint64_t))(*(void *)v5 + 704LL))(v5))
  {
    if (v3) {
      id v6 = v3;
    }
    else {
      id v6 = (id)objc_claimAutoreleasedReturnValue(+[NSArray array](&OBJC_CLASS___NSArray, "array"));
    }
    uint64_t v9 = *(void **)(a1 + 2120);
    *(void *)(a1 + 2120) = v6;

    uint64_t v8 = sub_1005EB324(a1, 0);
    if (!(_DWORD)v8)
    {
      __int128 v10 = (os_log_s *)qword_1008F75B8;
      if (os_log_type_enabled((os_log_t)qword_1008F75B8, OS_LOG_TYPE_INFO))
      {
        LOWORD(v17) = 0;
        _os_log_impl((void *)&_mh_execute_header, v10, OS_LOG_TYPE_INFO, "succesfully paused", (uint8_t *)&v17, 2u);
      }

      int v11 = sub_1005EDB50(a1);
      unsigned int v12 = (os_log_s *)qword_1008F75B8;
      if (os_log_type_enabled((os_log_t)qword_1008F75B8, OS_LOG_TYPE_INFO))
      {
        int v17 = 67109120;
        LODWORD(v18) = v11;
        _os_log_impl( (void *)&_mh_execute_header,  v12,  OS_LOG_TYPE_INFO,  "readMatchBuffers returned %d",  (uint8_t *)&v17,  8u);
      }

      if (v11 == 12)
      {
        uint64_t v13 = (os_log_s *)qword_1008F75B8;
        if (os_log_type_enabled((os_log_t)qword_1008F75B8, OS_LOG_TYPE_INFO))
        {
          LOWORD(v17) = 0;
          unint64_t v14 = "Match buffer read already in progress";
          goto LABEL_21;
        }

void sub_1005EB898(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_1005EB8B0(uint64_t a1)
{
  uint64_t v2 = (os_log_s *)qword_1008F75B8;
  if (os_log_type_enabled((os_log_t)qword_1008F75B8, OS_LOG_TYPE_DEFAULT))
  {
    *(_WORD *)int buf = 0;
    _os_log_impl((void *)&_mh_execute_header, v2, OS_LOG_TYPE_DEFAULT, "ADVBUFF Sending empty event", buf, 2u);
  }

  id v3 = (unsigned int *)operator new(0x1E0uLL);
  sub_10056B368((uint64_t)v3);
  *((_BYTE *)v3 + 304) = 1;
  int v4 = *(void **)(a1 + 2040);
  if (v4 != (void *)(a1 + 2048))
  {
    do
    {
      uint64_t v5 = objc_autoreleasePoolPush();
      uint64_t v6 = v4[4];
      uint64_t v7 = v4[5];
      if (sub_100611304(v7) || *(unsigned __int16 *)(*(void *)(v7 + 8) + 170LL) << 16 == 0x10000)
      {
        if (*(_DWORD *)(a1 + 1964))
        {
          v12[0] = _NSConcreteStackBlock;
          v12[1] = 3321888768LL;
          void v12[2] = sub_1005EBDA4;
          v12[3] = &unk_1008A3A48;
          v12[4] = v6;
          uint64_t v13 = &off_10087FAE8;
          unint64_t v14 = v3;
          sub_1002CD1E0((uint64_t)v3);
          std::stringbuf::string_type __p = 0LL;
          uint64_t v16 = 0LL;
          uint64_t v17 = 0LL;
          sub_100050EE8((char *)&__p, 0LL, 0LL, 0LL);
          sub_1005EBB90((os_unfair_lock_s *)(a1 + 1904), v12);
          if (__p)
          {
            uint64_t v16 = __p;
            operator delete(__p);
          }

          uint64_t v13 = &off_10087FAE8;
          uint64_t v8 = v14;
          if (!v14) {
            goto LABEL_11;
          }
        }

        else
        {
          v18[0] = _NSConcreteStackBlock;
          v18[1] = 3321888768LL;
          void v18[2] = sub_1005EBC4C;
          v18[3] = &unk_1008A3A48;
          void v18[4] = v6;
          BOOL v19 = &off_10087FAE8;
          int v20 = v3;
          sub_1002CD1E0((uint64_t)v3);
          uint8x8_t v21 = 0LL;
          int16x8_t v22 = 0LL;
          uint64_t v23 = 0LL;
          sub_100050EE8((char *)&v21, 0LL, 0LL, 0LL);
          sub_1005EBB90((os_unfair_lock_s *)(a1 + 1872), v18);
          if (v21)
          {
            int16x8_t v22 = v21;
            operator delete(v21);
          }

          BOOL v19 = &off_10087FAE8;
          uint64_t v8 = v20;
          if (!v20) {
            goto LABEL_11;
          }
        }

        sub_1002CD254(v8);
      }

void sub_1005EBB0C( _Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, void *a18, uint64_t a19, uint64_t a20, uint64_t a21, uint64_t a22, uint64_t a23, uint64_t a24, uint64_t a25, uint64_t a26, uint64_t a27, void *__p, uint64_t a29)
{
}

void sub_1005EBB90(os_unfair_lock_s *a1, void *a2)
{
  id v3 = a2;
  os_unfair_lock_lock(a1);
  uint64_t v5 = 0LL;
  uint64_t v6 = 0LL;
  uint64_t v7 = 0LL;
  sub_100240540(&v5, (uint64_t)&a1[2]);
  os_unfair_lock_unlock(a1);
  int v4 = v5;
  if (v5 != v6)
  {
    do
      v3[2](v3, *v4++);
    while (v4 != v6);
    int v4 = v5;
  }

  if (v4)
  {
    uint64_t v6 = v4;
    operator delete(v4);
  }
}

void sub_1005EBC24( _Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void *__p, uint64_t a11)
{
  _Unwind_Resume(a1);
}

void sub_1005EBC4C( uint64_t a1, void (***a2)(void, uint64_t, void, uint64_t, uint64_t, void, void ***, const __CFString *))
{
  uint64_t v3 = *(void *)(a1 + 32);
  v5[0] = 0LL;
  v5[1] = 0LL;
  int v4 = v5;
  (**a2)(a2, v3, 0LL, a1 + 40, a1 + 56, 0LL, &v4, @"default");
  sub_10023BF24((uint64_t)&v4, v5[0]);
}

void sub_1005EBCBC( _Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, char a10, void *a11)
{
}

char *sub_1005EBCD4(uint64_t a1, uint64_t a2)
{
  uint64_t v4 = *(void *)(a2 + 48);
  *(void *)(a1 + 40) = &off_10087FAE8;
  *(void *)(a1 + 48) = v4;
  if (v4) {
    sub_1002CD1E0(v4);
  }
  *(void *)(a1 + 56) = 0LL;
  *(void *)(a1 + 64) = 0LL;
  *(void *)(a1 + 72) = 0LL;
  return sub_100050EE8( (char *)(a1 + 56),  *(__int128 **)(a2 + 56),  *(__int128 **)(a2 + 64),  0xCCCCCCCCCCCCCCCDLL * ((uint64_t)(*(void *)(a2 + 64) - *(void *)(a2 + 56)) >> 2));
}

void sub_1005EBD3C(_Unwind_Exception *exception_object)
{
  *(void *)(v1 + 40) = v2;
  uint64_t v4 = *(unsigned int **)(v1 + 48);
  if (v4) {
    sub_1002CD254(v4);
  }
  _Unwind_Resume(exception_object);
}

void sub_1005EBD58(void *a1)
{
  uint64_t v2 = (void *)a1[7];
  if (v2)
  {
    a1[8] = v2;
    operator delete(v2);
  }

  a1[5] = &off_10087FAE8;
  uint64_t v3 = (unsigned int *)a1[6];
  if (v3) {
    sub_1002CD254(v3);
  }
}

void sub_1005EBDA4( uint64_t a1, void (***a2)(void, uint64_t, void, uint64_t, uint64_t, void, void ***, const __CFString *))
{
  uint64_t v3 = *(void *)(a1 + 32);
  v5[0] = 0LL;
  v5[1] = 0LL;
  uint64_t v4 = v5;
  (**a2)(a2, v3, 0LL, a1 + 40, a1 + 56, 0LL, &v4, @"default");
  sub_10023BF24((uint64_t)&v4, v5[0]);
}

void sub_1005EBE14( _Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, char a10, void *a11)
{
}

void sub_1005EBE2C( uint64_t a1, void (***a2)(void, uint64_t, void, uint64_t, uint64_t, void, void ***, const __CFString *))
{
  uint64_t v3 = *(void *)(a1 + 32);
  v5[0] = 0LL;
  v5[1] = 0LL;
  uint64_t v4 = v5;
  (**a2)(a2, v3, 0LL, a1 + 40, a1 + 56, 0LL, &v4, @"default");
  sub_10023BF24((uint64_t)&v4, v5[0]);
}

void sub_1005EBE9C( _Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, char a10, void *a11)
{
}

void sub_1005EBEB4( uint64_t a1, void (***a2)(void, uint64_t, void, uint64_t, uint64_t, void, void ***, const __CFString *))
{
  uint64_t v3 = *(void *)(a1 + 32);
  v5[0] = 0LL;
  v5[1] = 0LL;
  uint64_t v4 = v5;
  (**a2)(a2, v3, 0LL, a1 + 40, a1 + 56, 0LL, &v4, @"default");
  sub_10023BF24((uint64_t)&v4, v5[0]);
}

void sub_1005EBF24( _Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, char a10, void *a11)
{
}

void sub_1005EBF3C(id a1)
{
}

BOOL sub_1005EBF48(uint64_t a1)
{
  uint64_t v1 = *(void **)(a1 + 2040);
  uint64_t v2 = (void *)(a1 + 2048);
  if (v1 == (void *)(a1 + 2048)) {
    return 0LL;
  }
  do
  {
    BOOL result = *(_BYTE *)(*(void *)(v1[5] + 8LL) + 122LL) != 0;
    if (*(_BYTE *)(*(void *)(v1[5] + 8LL) + 122LL)) {
      break;
    }
    uint64_t v4 = (void *)v1[1];
    if (v4)
    {
      do
      {
        uint64_t v5 = v4;
        uint64_t v4 = (void *)*v4;
      }

      while (v4);
    }

    else
    {
      do
      {
        uint64_t v5 = (void *)v1[2];
        BOOL v6 = *v5 == (void)v1;
        uint64_t v1 = v5;
      }

      while (!v6);
    }

    uint64_t v1 = v5;
  }

  while (v5 != v2);
  return result;
}

uint64_t sub_1005EBFB4(uint64_t a1)
{
  uint64_t v1 = *(dispatch_source_s **)(a1 + 1800);
  if (v1)
  {
    uint64_t v3 = (os_log_s *)qword_1008F75B8;
    if (os_log_type_enabled((os_log_t)qword_1008F75B8, OS_LOG_TYPE_DEFAULT))
    {
      *(_WORD *)uint64_t v5 = 0;
      _os_log_impl( (void *)&_mh_execute_header,  v3,  OS_LOG_TYPE_DEFAULT,  "fADVBufferPeriodicDrainTimer destroyed!",  v5,  2u);
      uint64_t v1 = *(dispatch_source_s **)(a1 + 1800);
    }

    dispatch_source_cancel(v1);
    dispatch_release(*(dispatch_object_t *)(a1 + 1800));
    *(void *)(a1 + 1800) = 0LL;
  }

  return 0LL;
}

uint64_t sub_1005EC048(uint64_t a1)
{
  if (!*(void *)(a1 + 1800))
  {
    uint64_t v2 = *(void *)(a1 + 2128);
    uint64_t v3 = (os_log_s *)qword_1008F75B8;
    if (os_log_type_enabled((os_log_t)qword_1008F75B8, OS_LOG_TYPE_DEFAULT))
    {
      *(_DWORD *)int buf = 134217984;
      uint64_t v11 = v2;
      _os_log_impl( (void *)&_mh_execute_header,  v3,  OS_LOG_TYPE_DEFAULT,  "fADVBufferPeriodicDrainTimer %llu ms Armed!",  buf,  0xCu);
    }

    uint64_t v4 = sub_100404FE8();
    uint64_t v5 = dispatch_source_create( (dispatch_source_type_t)&_dispatch_source_type_timer,  0LL,  0LL,  *(dispatch_queue_t *)(v4 + 8));
    *(void *)(a1 + 1800) = v5;
    handler[0] = _NSConcreteStackBlock;
    handler[1] = 3221225472LL;
    handler[2] = sub_1005FC458;
    handler[3] = &unk_10087EB20;
    handler[4] = a1;
    dispatch_source_set_event_handler(v5, handler);
    BOOL v6 = *(dispatch_source_s **)(a1 + 1800);
    dispatch_time_t v7 = dispatch_time(0x8000000000000000LL, 1000000 * v2);
    dispatch_source_set_timer(v6, v7, 0xFFFFFFFFFFFFFFFFLL, 0LL);
    dispatch_activate(*(dispatch_object_t *)(a1 + 1800));
  }

  return 0LL;
}

uint64_t sub_1005EC18C(uint64_t a1, uint64_t a2)
{
  if (a2 >= 3)
  {
    uint64_t v3 = (os_log_s *)qword_1008F75B8;
    if (os_log_type_enabled((os_log_t)qword_1008F75B8, OS_LOG_TYPE_DEFAULT))
    {
      *(_DWORD *)int buf = 67109120;
      LODWORD(v31) = a2;
      _os_log_impl( (void *)&_mh_execute_header,  v3,  OS_LOG_TYPE_DEFAULT,  "HW ADV Buffer handle out of range (%d), ignoring agent request",  buf,  8u);
    }

    return 7LL;
  }

  uint64_t v6 = a1 + 544LL * a2;
  int v8 = *(unsigned __int8 *)(v6 + 172);
  dispatch_time_t v7 = (_BYTE *)(v6 + 172);
  if (v8 != 255)
  {
    uint64_t v9 = qword_1008F75B8;
    if (os_log_type_enabled((os_log_t)qword_1008F75B8, OS_LOG_TYPE_INFO))
    {
      else {
        __int128 v10 = off_1008A4258[(char)a2];
      }
      *(_DWORD *)int buf = 138543362;
      char v31 = v10;
      uint64_t v16 = "ADVBUFF(%{public}@): Cannot read ADV buffer since we're already in the process of reading it";
      uint64_t v4 = 12LL;
      uint64_t v17 = (os_log_s *)v9;
LABEL_15:
      _os_log_impl((void *)&_mh_execute_header, v17, OS_LOG_TYPE_INFO, v16, buf, 0xCu);
      return v4;
    }

    return 12LL;
  }

  unsigned int v11 = a2;
  int v12 = *(unsigned __int8 *)(a1 + 544LL * a2 + 167);
  uint64_t v13 = (os_log_s *)qword_1008F75B8;
  BOOL v14 = os_log_type_enabled((os_log_t)qword_1008F75B8, OS_LOG_TYPE_INFO);
  if (!v12)
  {
    if (v14)
    {
      else {
        id v18 = off_1008A4258[(char)a2];
      }
      *(_DWORD *)int buf = 138543362;
      char v31 = v18;
      uint64_t v16 = "ADVBUFF(%{public}@): Cannot read ADV buffer since its not created yet";
      uint64_t v4 = 12LL;
      uint64_t v17 = v13;
      goto LABEL_15;
    }

    return 12LL;
  }

  if (v14)
  {
    else {
      unsigned __int8 v15 = off_1008A4258[(char)a2];
    }
    *(_DWORD *)int buf = 138543362;
    char v31 = v15;
    _os_log_impl( (void *)&_mh_execute_header,  v13,  OS_LOG_TYPE_INFO,  "ADVBUFF(%{public}@): Reading ADV Buffer",  buf,  0xCu);
  }

  __int16 v29 = 0;
  __int16 v28 = 0;
  uint64_t v19 = sub_1002E6E9C();
  uint64_t v4 = (*(uint64_t (**)(uint64_t, uint64_t, char *, __int16 *, __int16 *))(*(void *)v19 + 2808LL))( v19,  a2,  (char *)&v29 + 1,  &v29,  &v28);
  int v20 = (os_log_s *)qword_1008F75B8;
  if (os_log_type_enabled((os_log_t)qword_1008F75B8, OS_LOG_TYPE_DEFAULT))
  {
    else {
      uint8x8_t v21 = off_1008A4258[(char)a2];
    }
    *(_DWORD *)int buf = 138543874;
    char v31 = v21;
    __int16 v32 = 1024;
    int v33 = v4;
    __int16 v34 = 1024;
    int v35 = HIBYTE(v29);
    _os_log_impl( (void *)&_mh_execute_header,  v20,  OS_LOG_TYPE_DEFAULT,  "ADVBUFF(%{public}@): Read ADV buffer complete with status %d expectedEntries %d",  buf,  0x18u);
    int v20 = (os_log_s *)qword_1008F75B8;
  }

  *dispatch_time_t v7 = HIBYTE(v29);
  uint64_t v22 = a1 + 544LL * v11;
  *(_BYTE *)(v22 + 173) = v29;
  *(_WORD *)(v22 + 174) = v28;
  if (os_log_type_enabled(v20, OS_LOG_TYPE_INFO))
  {
    else {
      uint64_t v23 = off_1008A4258[(char)a2];
    }
    int v24 = *v7;
    *(_DWORD *)int buf = 138543874;
    char v31 = v23;
    __int16 v32 = 1024;
    int v33 = v4;
    __int16 v34 = 1024;
    int v35 = v24;
    _os_log_impl( (void *)&_mh_execute_header,  v20,  OS_LOG_TYPE_INFO,  "ADVBUFF(%{public}@): Read ADV buffer complete with status %d number of available entries %d",  buf,  0x18u);
  }

  if ((_DWORD)a2 == 2) {
    ++*(void *)(a1 + 2296);
  }
  if (!(_DWORD)v4 && !*v7)
  {
    uint64_t v25 = (os_log_s *)qword_1008F75B8;
    if (os_log_type_enabled((os_log_t)qword_1008F75B8, OS_LOG_TYPE_INFO))
    {
      else {
        __int128 v26 = off_1008A4258[(char)a2];
      }
      *(_DWORD *)int buf = 138543362;
      char v31 = v26;
      _os_log_impl( (void *)&_mh_execute_header,  v25,  OS_LOG_TYPE_INFO,  "ADVBUFF(%{public}@): Nothing in the ADV buffer, we're not expecing any events",  buf,  0xCu);
    }

    *dispatch_time_t v7 = -1;
    *(_BYTE *)(a1 + 544LL * v11 + 169) = 0;
  }

  return v4;
}

void sub_1005EC5D0(uint64_t a1)
{
}

void sub_1005EC5D8(unsigned __int8 *a1)
{
  uint64_t v2 = (os_log_s *)qword_1008F75B8;
  if (os_log_type_enabled((os_log_t)qword_1008F75B8, OS_LOG_TYPE_INFO))
  {
    int v3 = sub_1005EE698((uint64_t)a1);
    int v4 = a1[144];
    int v15 = 67109376;
    int v16 = v3;
    __int16 v17 = 1024;
    int v18 = v4;
    _os_log_impl( (void *)&_mh_execute_header,  v2,  OS_LOG_TYPE_INFO,  "enableObjectDiscoveryADVBuffersIfNeeded objectDiscoveryHwAdvBufferOnly:%d fScreenState:%d",  (uint8_t *)&v15,  0xEu);
  }

  if (sub_1005EE698((uint64_t)a1) && !a1[144])
  {
    uint64_t v5 = (os_log_s *)qword_1008F75B8;
    if (os_log_type_enabled((os_log_t)qword_1008F75B8, OS_LOG_TYPE_DEFAULT))
    {
      int v6 = a1[172];
      int v7 = a1[167];
      int v8 = a1[168];
      int v15 = 67109632;
      int v16 = v6;
      __int16 v17 = 1024;
      int v18 = v7;
      __int16 v19 = 1024;
      int v20 = v8;
      _os_log_impl( (void *)&_mh_execute_header,  v5,  OS_LOG_TYPE_DEFAULT,  "exptectedEntries:%d created:%d enabled:%d",  (uint8_t *)&v15,  0x14u);
    }

    if (a1[172] == 255 && a1[167] && !a1[168])
    {
      int v9 = sub_1005E9E20((uint64_t)a1, 0LL, 1);
      if (v9)
      {
        int v10 = v9;
        unsigned int v11 = (os_log_s *)qword_1008F75B8;
        if (os_log_type_enabled((os_log_t)qword_1008F75B8, OS_LOG_TYPE_INFO))
        {
          int v15 = 67109120;
          int v16 = v10;
          _os_log_impl( (void *)&_mh_execute_header,  v11,  OS_LOG_TYPE_INFO,  "enableADVBuffering(Wild) failed with result %d",  (uint8_t *)&v15,  8u);
        }
      }

      else
      {
        sub_1005EC048((uint64_t)a1);
      }
    }

    if (a1[716] == 255 && a1[711] && !a1[712])
    {
      int v12 = sub_1005E9E20((uint64_t)a1, 1LL, 1);
      if (v12)
      {
        int v13 = v12;
        BOOL v14 = (os_log_s *)qword_1008F75B8;
        if (os_log_type_enabled((os_log_t)qword_1008F75B8, OS_LOG_TYPE_INFO))
        {
          int v15 = 67109120;
          int v16 = v13;
          _os_log_impl( (void *)&_mh_execute_header,  v14,  OS_LOG_TYPE_INFO,  "enableADVBuffering(NO) failed with result %d",  (uint8_t *)&v15,  8u);
        }
      }

      else
      {
        sub_1005EC048((uint64_t)a1);
      }
    }
  }

uint64_t sub_1005EC82C(_BYTE *a1)
{
  if (!sub_1005EBF48((uint64_t)a1))
  {
    if (!os_log_type_enabled((os_log_t)qword_1008F75B8, OS_LOG_TYPE_ERROR))
    {
LABEL_13:
      uint64_t v2 = sub_100404FE8();
      v5[0] = _NSConcreteStackBlock;
      v5[1] = 3221225472LL;
      void v5[2] = sub_1005EC990;
      v5[3] = &unk_10087EB20;
      v5[4] = a1;
      sub_100405384(v2, v5);
      return 12LL;
    }

void sub_1005EC990(uint64_t a1)
{
}

void sub_1005EC998(uint64_t a1)
{
  if ((sub_1005ECBFC(a1) & 1) != 0) {
    int v2 = 1;
  }
  else {
    int v2 = sub_1005ECC64(a1);
  }
  int v3 = (os_log_s *)qword_1008F75B8;
  if (os_log_type_enabled((os_log_t)qword_1008F75B8, OS_LOG_TYPE_DEFAULT))
  {
    int v4 = *(unsigned __int8 *)(a1 + 1864);
    v8[0] = 67109376;
    v8[1] = v2;
    __int16 v9 = 1024;
    int v10 = v4;
    _os_log_impl( (void *)&_mh_execute_header,  v3,  OS_LOG_TYPE_DEFAULT,  "tryReadAOPBTProxCtxBuffers AOPBTProxContextBufferRequests:%d fAOPBTProxCtxBufferReadInProgress:%d",  (uint8_t *)v8,  0xEu);
  }

  if (*(_BYTE *)(a1 + 1864))
  {
    uint64_t v5 = (os_log_s *)qword_1008F75B8;
    if (os_log_type_enabled((os_log_t)qword_1008F75B8, OS_LOG_TYPE_DEFAULT))
    {
      LOWORD(v8[0]) = 0;
      _os_log_impl( (void *)&_mh_execute_header,  v5,  OS_LOG_TYPE_DEFAULT,  "AOPBTProxCtxBuffers already being read, skipping",  (uint8_t *)v8,  2u);
    }
  }

  else if (v2)
  {
    int v6 = (os_log_s *)qword_1008F75B8;
    if (os_log_type_enabled((os_log_t)qword_1008F75B8, OS_LOG_TYPE_INFO))
    {
      LOWORD(v8[0]) = 0;
      _os_log_impl( (void *)&_mh_execute_header,  v6,  OS_LOG_TYPE_INFO,  "AOPBTProxCtxBuffer read in progress, pause match All Types match table",  (uint8_t *)v8,  2u);
    }

    if (sub_1005ECCCC(a1, 0, 0))
    {
      if (os_log_type_enabled((os_log_t)qword_1008F75B8, OS_LOG_TYPE_ERROR)) {
        sub_10069C420();
      }
    }

    else
    {
LABEL_27:
      int v7 = (os_log_s *)qword_1008F75B8;
      if (os_log_type_enabled((os_log_t)qword_1008F75B8, OS_LOG_TYPE_INFO))
      {
        LOWORD(v8[0]) = 0;
        _os_log_impl( (void *)&_mh_execute_header,  v7,  OS_LOG_TYPE_INFO,  "AOPBTProxCtxBuffer read in progress, pause Proximity Pairing match table",  (uint8_t *)v8,  2u);
      }

      if (sub_1005ECCCC(a1, 7, 0))
      {
        if (os_log_type_enabled((os_log_t)qword_1008F75B8, OS_LOG_TYPE_ERROR)) {
          sub_10069C3C0();
        }
      }

      else
      {
LABEL_22:
        *(_BYTE *)(a1 + 1864) = 1;
        if (qword_1008D6628 != -1) {
          dispatch_once(&qword_1008D6628, &stru_1008A4098);
        }
        sub_1003327E4(qword_1008D6620);
      }
    }
  }

uint64_t sub_1005ECBFC(uint64_t a1)
{
  uint64_t v1 = *(void **)(a1 + 2040);
  int v2 = (void *)(a1 + 2048);
  if (v1 == (void *)(a1 + 2048)) {
    return 0LL;
  }
  do
  {
    unsigned int v3 = *(unsigned __int16 *)(*(void *)(v1[5] + 8LL) + 124LL);
    uint64_t result = (v3 >> 1) & 1;
    if ((v3 & 2) != 0) {
      break;
    }
    uint64_t v5 = (void *)v1[1];
    if (v5)
    {
      do
      {
        int v6 = v5;
        uint64_t v5 = (void *)*v5;
      }

      while (v5);
    }

    else
    {
      do
      {
        int v6 = (void *)v1[2];
        BOOL v7 = *v6 == (void)v1;
        uint64_t v1 = v6;
      }

      while (!v7);
    }

    uint64_t v1 = v6;
  }

  while (v6 != v2);
  return result;
}

uint64_t sub_1005ECC64(uint64_t a1)
{
  uint64_t v1 = *(void **)(a1 + 2040);
  int v2 = (void *)(a1 + 2048);
  if (v1 == (void *)(a1 + 2048)) {
    return 0LL;
  }
  do
  {
    unsigned int v3 = *(unsigned __int16 *)(*(void *)(v1[5] + 8LL) + 124LL);
    uint64_t result = (v3 >> 2) & 1;
    if ((v3 & 4) != 0) {
      break;
    }
    uint64_t v5 = (void *)v1[1];
    if (v5)
    {
      do
      {
        int v6 = v5;
        uint64_t v5 = (void *)*v5;
      }

      while (v5);
    }

    else
    {
      do
      {
        int v6 = (void *)v1[2];
        BOOL v7 = *v6 == (void)v1;
        uint64_t v1 = v6;
      }

      while (!v7);
    }

    uint64_t v1 = v6;
  }

  while (v6 != v2);
  return result;
}

uint64_t sub_1005ECCCC(uint64_t a1, int a2, int a3)
{
  int v6 = (uint64_t **)(a1 + 1816);
  BOOL v7 = *(void **)(a1 + 1816);
  if (v7 == (void *)(a1 + 1824))
  {
LABEL_13:
    uint64_t v11 = 0LL;
  }

  else
  {
    while (1)
    {
      BOOL v8 = *((unsigned __int8 *)v7 + 28) != a2 || *((_WORD *)v7 + 16) == 0;
      if (!v8) {
        break;
      }
      __int16 v9 = (void *)v7[1];
      if (v9)
      {
        do
        {
          int v10 = v9;
          __int16 v9 = (void *)*v9;
        }

        while (v9);
      }

      else
      {
        do
        {
          int v10 = (void *)v7[2];
          BOOL v8 = *v10 == (void)v7;
          BOOL v7 = v10;
        }

        while (!v8);
      }

      BOOL v7 = v10;
      if (v10 == (void *)(a1 + 1824)) {
        goto LABEL_13;
      }
    }

    uint64_t v11 = *((unsigned __int16 *)v7 + 15);
  }

  int v12 = (os_log_s *)qword_1008F75B8;
  if (os_log_type_enabled((os_log_t)qword_1008F75B8, OS_LOG_TYPE_INFO))
  {
    unsigned __int8 v35 = v11;
    *(void *)int buf = &v35;
    int v13 = *((unsigned __int8 *)sub_10060F298(v6, &v35, (uint64_t)&unk_1006C2518, (char **)buf) + 28);
    unsigned __int8 v34 = v11;
    *(void *)int buf = &v34;
    BOOL v14 = *((_WORD *)sub_10060F298(v6, &v34, (uint64_t)&unk_1006C2518, (char **)buf) + 16) != 0;
    unsigned __int8 v33 = v11;
    *(void *)int buf = &v33;
    BOOL v15 = *((_WORD *)sub_10060F298(v6, &v33, (uint64_t)&unk_1006C2518, (char **)buf) + 17) != 0;
    *(_DWORD *)int buf = 67110144;
    *(_DWORD *)&uint8_t buf[4] = v11;
    __int16 v37 = 1024;
    int v38 = v13;
    __int16 v39 = 1024;
    *(_DWORD *)__int128 v40 = a3;
    *(_WORD *)&v40[4] = 1024;
    *(_DWORD *)&v40[6] = v14;
    __int16 v41 = 1024;
    BOOL v42 = v15;
    _os_log_impl( (void *)&_mh_execute_header,  v12,  OS_LOG_TYPE_INFO,  "enableMatchTable handle:%d type:%d enable=%d created=%d enabled=%d",  buf,  0x20u);
  }

  if ((unsigned __int16)(v11 - 262) > 0xFFF9u)
  {
    unsigned __int8 v35 = v11;
    *(void *)int buf = &v35;
    if (*((_WORD *)sub_10060F298(v6, &v35, (uint64_t)&unk_1006C2518, (char **)buf) + 16))
    {
      unsigned __int8 v35 = v11;
      *(void *)int buf = &v35;
      char v18 = (*((_WORD *)sub_10060F298(v6, &v35, (uint64_t)&unk_1006C2518, (char **)buf) + 17) != 0) ^ a3;
      __int16 v19 = (os_log_s *)qword_1008F75B8;
      BOOL v20 = os_log_type_enabled((os_log_t)qword_1008F75B8, OS_LOG_TYPE_INFO);
      if ((v18 & 1) != 0)
      {
        if (v20)
        {
          unsigned __int8 v35 = v11;
          *(void *)int buf = &v35;
          int v21 = *((unsigned __int8 *)sub_10060F298(v6, &v35, (uint64_t)&unk_1006C2518, (char **)buf) + 28);
          uint64_t v22 = "pausing";
          *(_DWORD *)int buf = 67109634;
          *(_DWORD *)&uint8_t buf[4] = v11;
          if (a3) {
            uint64_t v22 = "activating";
          }
          __int16 v37 = 1024;
          int v38 = v21;
          __int16 v39 = 2082;
          *(void *)__int128 v40 = v22;
          _os_log_impl( (void *)&_mh_execute_header,  v19,  OS_LOG_TYPE_INFO,  "Match Table handle:%d type:%d mode change -> %{public}s ",  buf,  0x18u);
        }

        uint64_t v23 = sub_1002E6E9C();
        uint64_t v17 = (*(uint64_t (**)(uint64_t, uint64_t, uint64_t, void))(*(void *)v23 + 2840LL))( v23,  v11,  1LL,  a3 ^ 1u);
        int v24 = (os_log_s *)qword_1008F75B8;
        if (os_log_type_enabled((os_log_t)qword_1008F75B8, OS_LOG_TYPE_INFO))
        {
          unsigned __int8 v35 = v11;
          *(void *)int buf = &v35;
          int v25 = *((unsigned __int8 *)sub_10060F298(v6, &v35, (uint64_t)&unk_1006C2518, (char **)buf) + 28);
          *(_DWORD *)int buf = 67109632;
          *(_DWORD *)&uint8_t buf[4] = v11;
          __int16 v37 = 1024;
          int v38 = v25;
          __int16 v39 = 1024;
          *(_DWORD *)__int128 v40 = v17;
          _os_log_impl( (void *)&_mh_execute_header,  v24,  OS_LOG_TYPE_INFO,  "Match Table handle:%d type:%d advBufMatchControl returned %d",  buf,  0x14u);
        }

        if ((_DWORD)v17)
        {
          __int128 v26 = (os_log_s *)qword_1008F75B8;
          if (os_log_type_enabled((os_log_t)qword_1008F75B8, OS_LOG_TYPE_ERROR))
          {
            unsigned __int8 v35 = v11;
            *(void *)int buf = &v35;
            int v27 = *((unsigned __int8 *)sub_10060F298(v6, &v35, (uint64_t)&unk_1006C2518, (char **)buf) + 28);
            *(_DWORD *)int buf = 67109632;
            *(_DWORD *)&uint8_t buf[4] = v11;
            __int16 v37 = 1024;
            int v38 = v27;
            __int16 v39 = 1024;
            *(_DWORD *)__int128 v40 = v17;
            _os_log_error_impl( (void *)&_mh_execute_header,  v26,  OS_LOG_TYPE_ERROR,  "Match Table handle:%d type:%d Failed to enable match table : %d",  buf,  0x14u);
          }
        }

        else
        {
          unsigned __int8 v35 = v11;
          *(void *)int buf = &v35;
          *((_WORD *)sub_10060F298(v6, &v35, (uint64_t)&unk_1006C2518, (char **)buf) + 17) = a3;
        }

        sub_1005FC17C((double *)a1, a2, a3);
      }

      else
      {
        if (v20)
        {
          unsigned __int8 v35 = v11;
          *(void *)int buf = &v35;
          int v29 = *((unsigned __int8 *)sub_10060F298(v6, &v35, (uint64_t)&unk_1006C2518, (char **)buf) + 28);
          unsigned __int8 v30 = "paused";
          *(_DWORD *)int buf = 67109634;
          *(_DWORD *)&uint8_t buf[4] = v11;
          if (a3) {
            unsigned __int8 v30 = "active";
          }
          __int16 v37 = 1024;
          int v38 = v29;
          __int16 v39 = 2082;
          *(void *)__int128 v40 = v30;
          _os_log_impl( (void *)&_mh_execute_header,  v19,  OS_LOG_TYPE_INFO,  "Match Table handle:%d type:%d already %{public}s",  buf,  0x18u);
        }

        return 0LL;
      }
    }

    else
    {
      __int16 v28 = (os_log_s *)qword_1008F75B8;
      if (os_log_type_enabled((os_log_t)qword_1008F75B8, OS_LOG_TYPE_ERROR))
      {
        unsigned __int8 v35 = v11;
        *(void *)int buf = &v35;
        int v32 = *((unsigned __int8 *)sub_10060F298(v6, &v35, (uint64_t)&unk_1006C2518, (char **)buf) + 28);
        *(_DWORD *)int buf = 67109376;
        *(_DWORD *)&uint8_t buf[4] = v11;
        __int16 v37 = 1024;
        int v38 = v32;
        _os_log_error_impl( (void *)&_mh_execute_header,  v28,  OS_LOG_TYPE_ERROR,  "Match Table handle:%d type:%d not created",  buf,  0xEu);
      }

      return 12LL;
    }
  }

  else
  {
    int v16 = (os_log_s *)qword_1008F75B8;
    if (os_log_type_enabled((os_log_t)qword_1008F75B8, OS_LOG_TYPE_ERROR)) {
      sub_10069C480(a2, v11, v16);
    }
    return 7LL;
  }

  return v17;
}

void sub_1005ED2A0(uint64_t a1)
{
  int v2 = sub_1005ED470(a1);
  unsigned int v3 = (os_log_s *)qword_1008F75B8;
  if (os_log_type_enabled((os_log_t)qword_1008F75B8, OS_LOG_TYPE_DEFAULT))
  {
    int v4 = *(unsigned __int8 *)(a1 + 1854);
    v7[0] = 67109376;
    v7[1] = v2;
    __int16 v8 = 1024;
    int v9 = v4;
    _os_log_impl( (void *)&_mh_execute_header,  v3,  OS_LOG_TYPE_DEFAULT,  "tryReadAOPBTADPDBuffers haveAnyHwAOPBTADPDBufferRequests:%d fAOPBTBufferReadInProgress:%d",  (uint8_t *)v7,  0xEu);
  }

  if (*(_BYTE *)(a1 + 1854))
  {
    uint64_t v5 = (os_log_s *)qword_1008F75B8;
    if (os_log_type_enabled((os_log_t)qword_1008F75B8, OS_LOG_TYPE_DEFAULT))
    {
      LOWORD(v7[0]) = 0;
      _os_log_impl( (void *)&_mh_execute_header,  v5,  OS_LOG_TYPE_DEFAULT,  "AOPBTADPDBuff Already being read, skipping",  (uint8_t *)v7,  2u);
    }
  }

  else if (v2)
  {
    int v6 = (os_log_s *)qword_1008F75B8;
    if (os_log_type_enabled((os_log_t)qword_1008F75B8, OS_LOG_TYPE_INFO))
    {
      LOWORD(v7[0]) = 0;
      _os_log_impl( (void *)&_mh_execute_header,  v6,  OS_LOG_TYPE_INFO,  "AOPBTADPDBuff read in progress",  (uint8_t *)v7,  2u);
    }

    if (sub_1005ECCCC(a1, 22, 0))
    {
      if (os_log_type_enabled((os_log_t)qword_1008F75B8, OS_LOG_TYPE_ERROR)) {
        sub_10069C4F4();
      }
    }

    else
    {
      *(_BYTE *)(a1 + 1854) = 1;
      sub_1005ED4D8(a1);
      sub_1005ED56C(a1);
      if (qword_1008D6628 != -1) {
        dispatch_once(&qword_1008D6628, &stru_1008A4098);
      }
      sub_1003329B0(qword_1008D6620);
    }
  }

uint64_t sub_1005ED470(uint64_t a1)
{
  uint64_t v1 = *(void **)(a1 + 2040);
  int v2 = (void *)(a1 + 2048);
  if (v1 == (void *)(a1 + 2048)) {
    return 0LL;
  }
  do
  {
    __int16 v3 = *(_WORD *)(*(void *)(v1[5] + 8LL) + 124LL);
    uint64_t result = v3 & 1;
    if ((v3 & 1) != 0) {
      break;
    }
    uint64_t v5 = (void *)v1[1];
    if (v5)
    {
      do
      {
        int v6 = v5;
        uint64_t v5 = (void *)*v5;
      }

      while (v5);
    }

    else
    {
      do
      {
        int v6 = (void *)v1[2];
        BOOL v7 = *v6 == (void)v1;
        uint64_t v1 = v6;
      }

      while (!v7);
    }

    uint64_t v1 = v6;
  }

  while (v6 != v2);
  return result;
}

uint64_t sub_1005ED4D8(uint64_t a1)
{
  uint64_t v1 = *(dispatch_source_s **)(a1 + 1808);
  if (v1)
  {
    __int16 v3 = (os_log_s *)qword_1008F75B8;
    if (os_log_type_enabled((os_log_t)qword_1008F75B8, OS_LOG_TYPE_DEFAULT))
    {
      *(_WORD *)uint64_t v5 = 0;
      _os_log_impl( (void *)&_mh_execute_header,  v3,  OS_LOG_TYPE_DEFAULT,  "fAOPBTBufferPeriodicDrainTimer destroyed!",  v5,  2u);
      uint64_t v1 = *(dispatch_source_s **)(a1 + 1808);
    }

    dispatch_source_cancel(v1);
    dispatch_release(*(dispatch_object_t *)(a1 + 1808));
    *(void *)(a1 + 1808) = 0LL;
  }

  return 0LL;
}

uint64_t sub_1005ED56C(uint64_t a1)
{
  if (!*(void *)(a1 + 1808))
  {
    int v2 = (os_log_s *)qword_1008F75B8;
    if (os_log_type_enabled((os_log_t)qword_1008F75B8, OS_LOG_TYPE_DEFAULT))
    {
      *(_WORD *)int buf = 0;
      _os_log_impl( (void *)&_mh_execute_header,  v2,  OS_LOG_TYPE_DEFAULT,  "Arming fAOPBTBufferPeriodicDrainTimer",  buf,  2u);
    }

    uint64_t v3 = sub_100404FE8();
    int v4 = dispatch_source_create( (dispatch_source_type_t)&_dispatch_source_type_timer,  0LL,  0LL,  *(dispatch_queue_t *)(v3 + 8));
    *(void *)(a1 + 1808) = v4;
    handler[0] = _NSConcreteStackBlock;
    handler[1] = 3221225472LL;
    handler[2] = sub_1005FC35C;
    handler[3] = &unk_10087EB20;
    handler[4] = a1;
    dispatch_source_set_event_handler(v4, handler);
    uint64_t v5 = *(dispatch_source_s **)(a1 + 1808);
    dispatch_time_t v6 = dispatch_time(0x8000000000000000LL, 300000000000LL);
    dispatch_source_set_timer(v5, v6, 0xFFFFFFFFFFFFFFFFLL, 0LL);
    dispatch_activate(*(dispatch_object_t *)(a1 + 1808));
  }

  return 0LL;
}

void sub_1005ED66C(uint64_t a1)
{
  uint64_t v2 = *(void *)(a1 + 32);
  uint64_t v3 = (os_log_s *)qword_1008F75B8;
  if (os_log_type_enabled((os_log_t)qword_1008F75B8, OS_LOG_TYPE_DEFAULT))
  {
    int v4 = *(_DWORD *)(a1 + 40);
    uint64_t v5 = "On";
    if (!*(_BYTE *)(v2 + 144)) {
      uint64_t v5 = "Off";
    }
    v6[0] = 67109378;
    v6[1] = v4;
    __int16 v7 = 2082;
    __int16 v8 = v5;
    _os_log_impl( (void *)&_mh_execute_header,  v3,  OS_LOG_TYPE_DEFAULT,  "tryReadAOPBTBuffers reason:%d fScreenState:%{public}s",  (uint8_t *)v6,  0x12u);
  }

  if (*(_DWORD *)(a1 + 40) == 1) {
    sub_1005EC998(v2);
  }
  sub_1005ED2A0(v2);
}

void sub_1005ED760(uint64_t a1)
{
  uint64_t v2 = *(void *)(a1 + 32);
  uint64_t v3 = sub_1002E6BF0();
  int v4 = (*(uint64_t (**)(uint64_t))(*(void *)v3 + 704LL))(v3);
  uint64_t v5 = (os_log_s *)qword_1008F75B8;
  if (os_log_type_enabled((os_log_t)qword_1008F75B8, OS_LOG_TYPE_DEFAULT))
  {
    int v6 = *(_DWORD *)(a1 + 40);
    int v7 = *(unsigned __int8 *)(v2 + 1851);
    if (*(_BYTE *)(v2 + 144)) {
      __int16 v8 = "On";
    }
    else {
      __int16 v8 = "Off";
    }
    int v9 = (unsigned __int16)[*(id *)(v2 + 2112) count];
    BOOL v10 = sub_1005EBF48(v2);
    int v11 = *(unsigned __int8 *)(v2 + 172);
    int v12 = *(unsigned __int8 *)(v2 + 171);
    int v13 = *(unsigned __int8 *)(v2 + 715);
    int v14 = *(unsigned __int8 *)(v2 + 1853);
    int v27 = 67111426;
    int v28 = v6;
    __int16 v29 = 1024;
    int v30 = v7;
    __int16 v31 = 2082;
    int v32 = v8;
    __int16 v33 = 1024;
    int v34 = v9;
    __int16 v35 = 1024;
    int v36 = v4;
    __int16 v37 = 1024;
    BOOL v38 = v10;
    __int16 v39 = 1024;
    int v40 = v11;
    __int16 v41 = 1024;
    int v42 = v12;
    __int16 v43 = 1024;
    int v44 = v13;
    __int16 v45 = 1024;
    int v46 = v14;
    _os_log_impl( (void *)&_mh_execute_header,  v5,  OS_LOG_TYPE_DEFAULT,  "TryReadMatchAndADVBuffers reason:%d fMatchBufferExpectedEntries:0x%d fScreenState:%{public}s fMatchActionTableRule sCount:%d supportedADVBuffers:%d haveAnyHwObjectDiscoveryRequests:%d fADVBufferExpectedEntries:%d readInProgress[W ild]:%d readInProgress[NearOwner]:%d fMatchBufferReadInProgress:%d",  (uint8_t *)&v27,  0x42u);
  }

  if (*(_BYTE *)(v2 + 1853)
    || *(_BYTE *)(v2 + 171) && *(_BYTE *)(v2 + 167)
    || *(_BYTE *)(v2 + 715) && *(_BYTE *)(v2 + 711))
  {
    BOOL v15 = (os_log_s *)qword_1008F75B8;
    if (os_log_type_enabled((os_log_t)qword_1008F75B8, OS_LOG_TYPE_DEFAULT))
    {
      LOWORD(v27) = 0;
      _os_log_impl( (void *)&_mh_execute_header,  v15,  OS_LOG_TYPE_DEFAULT,  "Already reading buffers, skipping",  (uint8_t *)&v27,  2u);
    }
  }

  else
  {
    sub_1005EBFB4(v2);
    if (*(unsigned __int8 *)(v2 + 1851) == 255)
    {
      if ([*(id *)(v2 + 2112) count])
      {
        uint64_t v20 = sub_1002E6BF0();
        if ((*(unsigned int (**)(uint64_t))(*(void *)v20 + 704LL))(v20))
        {
          *(_BYTE *)(v2 + 1853) = 1;
          int v21 = (os_log_s *)qword_1008F75B8;
          if (os_log_type_enabled((os_log_t)qword_1008F75B8, OS_LOG_TYPE_INFO))
          {
            LOWORD(v27) = 0;
            _os_log_impl( (void *)&_mh_execute_header,  v21,  OS_LOG_TYPE_INFO,  "Match Buffer Reading ADV Buff",  (uint8_t *)&v27,  2u);
          }

          int v22 = sub_1005EB324(v2, 0);
          uint64_t v23 = (os_log_s *)qword_1008F75B8;
          if (v22)
          {
            int v24 = v22;
            if (os_log_type_enabled((os_log_t)qword_1008F75B8, OS_LOG_TYPE_INFO))
            {
              int v27 = 67109120;
              int v28 = v24;
              _os_log_impl( (void *)&_mh_execute_header,  v23,  OS_LOG_TYPE_INFO,  "Failed to pause match buffers with result %d",  (uint8_t *)&v27,  8u);
            }
          }

          else
          {
            if (os_log_type_enabled((os_log_t)qword_1008F75B8, OS_LOG_TYPE_DEBUG)) {
              sub_10069C5D0(v2, v2 + 1851, v23);
            }
            if (*(unsigned __int8 *)(v2 + 1851) == 255)
            {
              __int128 v26 = (os_log_s *)qword_1008F75B8;
              if (os_log_type_enabled((os_log_t)qword_1008F75B8, OS_LOG_TYPE_INFO))
              {
                LOWORD(v27) = 0;
                _os_log_impl( (void *)&_mh_execute_header,  v26,  OS_LOG_TYPE_INFO,  "Buffer is empty, we need to re-enable the match tables now",  (uint8_t *)&v27,  2u);
                __int128 v26 = (os_log_s *)qword_1008F75B8;
              }

              *(_BYTE *)(v2 + 1853) = 0;
              if (os_log_type_enabled(v26, OS_LOG_TYPE_DEBUG)) {
                sub_10069C554(v2, v26);
              }
            }
          }
        }
      }
    }

    *(_BYTE *)(v2 + 1795) = 0;
    *(_WORD *)(v2 + 1793) = 0;
    if (sub_1005EBF48(v2))
    {
      int v16 = objc_opt_new(&OBJC_CLASS___NSMutableDictionary);
      uint64_t v17 = *(void **)(v2 + 152);
      *(void *)(v2 + 152) = v16;

      uint64_t v18 = *(int *)(a1 + 40);
      if (v18 <= 4) {
        [*(id *)(v2 + 152) setObject:*((void *)&off_1008A4198 + v18) forKeyedSubscript:@"DrainReason"];
      }
      BOOL v19 = *(unsigned __int8 *)(v2 + 172) == 255 && *(_BYTE *)(v2 + 167) != 0;
      *(_BYTE *)(v2 + 1793) = v19;
      BOOL v25 = *(unsigned __int8 *)(v2 + 716) == 255 && *(_BYTE *)(v2 + 711) != 0;
      *(_BYTE *)(v2 + 1794) = v25;
    }

    sub_1005E95D8(v2);
  }

uint64_t sub_1005EDB50(uint64_t a1)
{
  if (*(unsigned __int8 *)(a1 + 1851) != 255)
  {
    uint64_t v1 = (os_log_s *)qword_1008F75B8;
    if (os_log_type_enabled((os_log_t)qword_1008F75B8, OS_LOG_TYPE_INFO))
    {
      LOWORD(v20) = 0;
      _os_log_impl( (void *)&_mh_execute_header,  v1,  OS_LOG_TYPE_INFO,  "Match Buffer Cannot read Match buffer since we're already in the process of reading it",  (uint8_t *)&v20,  2u);
    }

    return 12LL;
  }

  id v4 = [*(id *)(a1 + 2112) count];
  uint64_t v5 = (os_log_s *)qword_1008F75B8;
  BOOL v6 = os_log_type_enabled((os_log_t)qword_1008F75B8, OS_LOG_TYPE_INFO);
  if (!v4)
  {
    if (v6)
    {
      LOWORD(v20) = 0;
      _os_log_impl( (void *)&_mh_execute_header,  v5,  OS_LOG_TYPE_INFO,  "Match Buffer Cannot read Match buffer since we do not have any rules set up",  (uint8_t *)&v20,  2u);
    }

    return 18LL;
  }

  if (v6)
  {
    LOWORD(v20) = 0;
    _os_log_impl( (void *)&_mh_execute_header,  v5,  OS_LOG_TYPE_INFO,  "Match Buffer Reading Match Buffer",  (uint8_t *)&v20,  2u);
  }

  int v7 = *(void **)(a1 + 1816);
  if (v7 == (void *)(a1 + 1824))
  {
LABEL_17:
    int v12 = (os_log_s *)qword_1008F75B8;
    if (os_log_type_enabled((os_log_t)qword_1008F75B8, OS_LOG_TYPE_DEFAULT))
    {
      LOWORD(v20) = 0;
      _os_log_impl((void *)&_mh_execute_header, v12, OS_LOG_TYPE_DEFAULT, "No table is configured", (uint8_t *)&v20, 2u);
    }

    return 17LL;
  }

  else
  {
    __int16 v8 = (_BYTE *)(a1 + 1851);
    while (*((_BYTE *)v7 + 28) != 18)
    {
      int v9 = (void *)v7[1];
      if (v9)
      {
        do
        {
          BOOL v10 = v9;
          int v9 = (void *)*v9;
        }

        while (v9);
      }

      else
      {
        do
        {
          BOOL v10 = (void *)v7[2];
          BOOL v11 = *v10 == (void)v7;
          int v7 = v10;
        }

        while (!v11);
      }

      int v7 = v10;
      if (v10 == (void *)(a1 + 1824)) {
        goto LABEL_17;
      }
    }

    uint64_t v13 = *((unsigned __int16 *)v7 + 15);
    int v14 = (os_log_s *)qword_1008F75B8;
    if (os_log_type_enabled((os_log_t)qword_1008F75B8, OS_LOG_TYPE_INFO))
    {
      int v20 = 67109120;
      int v21 = v13;
      _os_log_impl( (void *)&_mh_execute_header,  v14,  OS_LOG_TYPE_INFO,  "Match Buffer reading handle %d",  (uint8_t *)&v20,  8u);
    }

    *(_BYTE *)(a1 + 1852) = 0;
    uint64_t v15 = sub_1002E6E9C();
    uint64_t v2 = (*(uint64_t (**)(uint64_t, uint64_t, uint64_t))(*(void *)v15 + 2880LL))(v15, v13, a1 + 1851);
    int v16 = (os_log_s *)qword_1008F75B8;
    if (os_log_type_enabled((os_log_t)qword_1008F75B8, OS_LOG_TYPE_INFO))
    {
      int v17 = *v8;
      int v20 = 67109376;
      int v21 = v2;
      __int16 v22 = 1024;
      int v23 = v17;
      _os_log_impl( (void *)&_mh_execute_header,  v16,  OS_LOG_TYPE_INFO,  "Match Buffer Read Match buffer complete with status %d number of available entries %d",  (uint8_t *)&v20,  0xEu);
    }

    if (!(_DWORD)v2)
    {
      if (*v8) {
        return 0LL;
      }
      BOOL v19 = (os_log_s *)qword_1008F75B8;
      if (os_log_type_enabled((os_log_t)qword_1008F75B8, OS_LOG_TYPE_INFO))
      {
        LOWORD(v20) = 0;
        _os_log_impl( (void *)&_mh_execute_header,  v19,  OS_LOG_TYPE_INFO,  "Match Buffer Nothing in the ADV buffer, we're not expecing any events",  (uint8_t *)&v20,  2u);
      }

      *__int16 v8 = -1;
      return 18LL;
    }
  }

  return v2;
}

void sub_1005EDE4C(uint64_t a1, const void *a2)
{
  uint64_t v3 = sub_100404FE8();
  v4[0] = _NSConcreteStackBlock;
  v4[1] = 3221225472LL;
  _DWORD v4[2] = sub_1005EDEBC;
  v4[3] = &unk_1008A3A98;
  void v4[4] = a1;
  sub_100405384(v3, v4);
}

void sub_1005EDEBC(uint64_t a1)
{
  uint64_t v2 = *(void *)(a1 + 32);
  uint64_t v3 = *(void *)(v2 + 2144) + *(unsigned int *)(a1 + 68);
  *(void *)(v2 + 2144) = v3;
  uint64_t v4 = *(void *)(v2 + 2136) + *(unsigned int *)(a1 + 72);
  *(void *)(v2 + 2136) = v4;
  uint64_t v5 = *(void *)(v2 + 2160) + *(unsigned int *)(a1 + 60);
  *(void *)(v2 + 2sub_100242FAC(v47 - 160) = v5;
  uint64_t v6 = *(void *)(v2 + 2152) + *(unsigned int *)(a1 + 64);
  *(void *)(v2 + 2152) = v6;
  int v7 = (os_log_s *)qword_1008F75B8;
  if (os_log_type_enabled((os_log_t)qword_1008F75B8, OS_LOG_TYPE_DEFAULT))
  {
    int v8 = *(_DWORD *)(a1 + 80);
    int v9 = *(_DWORD *)(a1 + 84);
    int v10 = *(_DWORD *)(a1 + 88);
    int v11 = *(_DWORD *)(a1 + 92);
    int v12 = *(_DWORD *)(a1 + 96);
    int v13 = *(_DWORD *)(a1 + 100);
    int v14 = *(_DWORD *)(a1 + 104);
    int v15 = *(_DWORD *)(a1 + 108);
    int v16 = *(_DWORD *)(a1 + 112);
    int v17 = *(_DWORD *)(a1 + 116);
    int v18 = *(_DWORD *)(a1 + 120);
    int v19 = *(_DWORD *)(a1 + 124);
    int v20 = *(_DWORD *)(a1 + 128);
    int v21 = *(_DWORD *)(a1 + 132);
    int v22 = *(_DWORD *)(a1 + 136);
    int v23 = *(_DWORD *)(a1 + 140);
    int v24 = *(_DWORD *)(a1 + 144);
    int v25 = *(_DWORD *)(a1 + 148);
    int v26 = *(_DWORD *)(a1 + 152);
    int v27 = *(_DWORD *)(a1 + 156);
    int v28 = *(_DWORD *)(a1 + 160);
    int v89 = *(_DWORD *)(a1 + 164);
    int v90 = *(_DWORD *)(a1 + 168);
    int v91 = *(_DWORD *)(a1 + 172);
    *(_DWORD *)int buf = 134224896;
    *(void *)int v93 = v3;
    *(_WORD *)&v93[8] = 2048;
    uint64_t v94 = v4;
    *(_WORD *)uint64_t v95 = 2048;
    *(void *)&v95[2] = v5;
    __int16 v96 = 2048;
    *(void *)uint64_t v97 = v6;
    *(_WORD *)&v97[8] = 1024;
    *(_DWORD *)int v98 = v8;
    *(_WORD *)&v98[4] = 1024;
    *(_DWORD *)int v99 = v9;
    *(_WORD *)&v99[4] = 1024;
    *(_DWORD *)uint64_t v100 = v10;
    *(_WORD *)&v100[4] = 1024;
    *(_DWORD *)unsigned int v101 = v11;
    *(_WORD *)&v101[4] = 1024;
    *(_DWORD *)unint64_t v102 = v12;
    *(_WORD *)&v102[4] = 1024;
    *(_DWORD *)unint64_t v103 = v13;
    *(_WORD *)&v103[4] = 1024;
    *(_DWORD *)id v104 = v14;
    *(_WORD *)&v104[4] = 1024;
    *(_DWORD *)int v105 = v15;
    *(_WORD *)&v105[4] = 1024;
    *(_DWORD *)__int128 v106 = v16;
    *(_WORD *)&v106[4] = 1024;
    *(_DWORD *)unint64_t v107 = v17;
    *(_WORD *)&v107[4] = 1024;
    *(_DWORD *)__int128 v108 = v18;
    *(_WORD *)&v108[4] = 1024;
    *(_DWORD *)int v109 = v19;
    *(_WORD *)&v109[4] = 1024;
    *(_DWORD *)int v110 = v20;
    *(_WORD *)&v110[4] = 1024;
    *(_DWORD *)unsigned int v111 = v21;
    *(_WORD *)&v111[4] = 1024;
    *(_DWORD *)__int128 v112 = v22;
    *(_WORD *)&v112[4] = 1024;
    *(_DWORD *)int v113 = v23;
    *(_WORD *)&v113[4] = 1024;
    int v114 = v24;
    __int16 v115 = 1024;
    int v116 = v25;
    __int16 v117 = 1024;
    int v118 = v26;
    __int16 v119 = 1024;
    int v120 = v27;
    __int16 v121 = 1024;
    int v122 = v28;
    __int16 v123 = 1024;
    int v124 = v89;
    __int16 v125 = 1024;
    int v126 = v90;
    __int16 v127 = 1024;
    int v128 = v91;
    _os_log_impl( (void *)&_mh_execute_header,  v7,  OS_LOG_TYPE_DEFAULT,  "LEStats: BMC:%lld LP:%lld, MC: %lld  %lld  ]  RxL:%05d:%05d:%05d  EAdv:%04d:%04d:%04d LeLR:%04d:%04d:%04d Aux:%04d :%04d:%04d Arsp:%04d:%04d:%04d cd:%04d:%04d:%04d aCrc:%05d:%05d:%05d def:%04d:%04d:%04d",  buf,  0xBAu);
    int v7 = (os_log_s *)qword_1008F75B8;
  }

  if (os_log_type_enabled(v7, OS_LOG_TYPE_DEFAULT))
  {
    int v29 = *(_DWORD *)(a1 + 176);
    int v30 = *(_DWORD *)(a1 + 180);
    int v31 = *(_DWORD *)(a1 + 184);
    int v32 = *(_DWORD *)(a1 + 188);
    int v33 = *(_DWORD *)(a1 + 192);
    int v34 = *(_DWORD *)(a1 + 196);
    int v35 = *(_DWORD *)(a1 + 200);
    int v36 = *(_DWORD *)(a1 + 204);
    int v37 = *(_DWORD *)(a1 + 208);
    int v38 = *(_DWORD *)(a1 + 212);
    int v39 = *(_DWORD *)(a1 + 216);
    int v40 = *(_DWORD *)(a1 + 220);
    int v41 = *(_DWORD *)(a1 + 224);
    int v42 = *(_DWORD *)(a1 + 228);
    int v43 = *(_DWORD *)(a1 + 232);
    int v44 = *(_DWORD *)(a1 + 236);
    int v45 = *(_DWORD *)(a1 + 240);
    int v46 = *(_DWORD *)(a1 + 244);
    int v47 = *(_DWORD *)(a1 + 248);
    int v48 = *(_DWORD *)(a1 + 252);
    int v49 = *(_DWORD *)(a1 + 256);
    int v50 = *(_DWORD *)(a1 + 260);
    int v51 = *(_DWORD *)(a1 + 264);
    *(_DWORD *)int buf = 67114752;
    *(_DWORD *)int v93 = v29;
    *(_WORD *)&v93[4] = 1024;
    *(_DWORD *)&v93[6] = v30;
    LOWORD(v94) = 1024;
    *(_DWORD *)((char *)&v94 + 2) = v31;
    HIWORD(v94) = 1024;
    *(_DWORD *)uint64_t v95 = v32;
    *(_WORD *)&v95[4] = 1024;
    *(_DWORD *)&v95[6] = v33;
    __int16 v96 = 1024;
    *(_DWORD *)uint64_t v97 = v34;
    *(_WORD *)&v97[4] = 1024;
    *(_DWORD *)&v97[6] = v35;
    *(_WORD *)int v98 = 1024;
    *(_DWORD *)&v98[2] = v36;
    *(_WORD *)int v99 = 1024;
    *(_DWORD *)&void v99[2] = v37;
    *(_WORD *)uint64_t v100 = 1024;
    *(_DWORD *)&v100[2] = v38;
    *(_WORD *)unsigned int v101 = 1024;
    *(_DWORD *)&v101[2] = v39;
    *(_WORD *)unint64_t v102 = 1024;
    *(_DWORD *)&v102[2] = v40;
    *(_WORD *)unint64_t v103 = 1024;
    *(_DWORD *)&v103[2] = v41;
    *(_WORD *)id v104 = 1024;
    *(_DWORD *)&v104[2] = v42;
    *(_WORD *)int v105 = 1024;
    *(_DWORD *)&v105[2] = v43;
    *(_WORD *)__int128 v106 = 1024;
    *(_DWORD *)&v106[2] = v44;
    *(_WORD *)unint64_t v107 = 1024;
    *(_DWORD *)&v107[2] = v45;
    *(_WORD *)__int128 v108 = 1024;
    *(_DWORD *)&_DWORD v108[2] = v46;
    *(_WORD *)int v109 = 1024;
    *(_DWORD *)&v109[2] = v47;
    *(_WORD *)int v110 = 1024;
    *(_DWORD *)&v110[2] = v48;
    *(_WORD *)unsigned int v111 = 1024;
    *(_DWORD *)&v111[2] = v49;
    *(_WORD *)__int128 v112 = 1024;
    *(_DWORD *)&v112[2] = v50;
    *(_WORD *)int v113 = 1024;
    *(_DWORD *)&v113[2] = v51;
    _os_log_impl( (void *)&_mh_execute_header,  v7,  OS_LOG_TYPE_DEFAULT,  "LEStats2: Rxa=%04d tSr=%04d tASr=%04d rSr=%04d tCi=%04d tCr=%04d rsRsp=%04d rsi=%04d rcr=%04d nba=%04d:%04d:%04d:% 04d tot:%04d:%04d cden=%04d:%04d:%04d:%04d totAdv=%04d:%04d:%04d:%04d",  buf,  0x8Cu);
    int v7 = (os_log_s *)qword_1008F75B8;
  }

  if (os_log_type_enabled(v7, OS_LOG_TYPE_DEBUG))
  {
    int v53 = *(_DWORD *)(v2 + 2748);
    int v54 = *(_DWORD *)(v2 + 2752);
    int v55 = *(_DWORD *)(v2 + 2756);
    int v56 = *(_DWORD *)(a1 + 60) + v53;
    int v57 = *(_DWORD *)(a1 + 68) + v54;
    int v58 = *(_DWORD *)(a1 + 44) + v55;
    *(_DWORD *)int buf = 67110400;
    *(_DWORD *)int v93 = v53;
    *(_WORD *)&v93[4] = 1024;
    *(_DWORD *)&v93[6] = v54;
    LOWORD(v94) = 1024;
    *(_DWORD *)((char *)&v94 + 2) = v55;
    HIWORD(v94) = 1024;
    *(_DWORD *)uint64_t v95 = v56;
    *(_WORD *)&v95[4] = 1024;
    *(_DWORD *)&v95[6] = v57;
    __int16 v96 = 1024;
    *(_DWORD *)uint64_t v97 = v58;
    _os_log_debug_impl( (void *)&_mh_execute_header,  v7,  OS_LOG_TYPE_DEBUG,  "BLEScanStat: MainCoreELNAOn [numAdvs, numAdvsBeforeFiltering, totalTime] [%d, %d, %d] -> [%d, %d, %d]",  buf,  0x26u);
    int v7 = (os_log_s *)qword_1008F75B8;
  }

  if (os_log_type_enabled(v7, OS_LOG_TYPE_DEBUG))
  {
    int v59 = *(_DWORD *)(v2 + 2760);
    int v60 = *(_DWORD *)(v2 + 2764);
    int v61 = *(_DWORD *)(v2 + 2768);
    int v62 = *(_DWORD *)(a1 + 64) + v59;
    int v63 = *(_DWORD *)(a1 + 72) + v60;
    int v64 = *(_DWORD *)(a1 + 48) + v61;
    *(_DWORD *)int buf = 67110400;
    *(_DWORD *)int v93 = v59;
    *(_WORD *)&v93[4] = 1024;
    *(_DWORD *)&v93[6] = v60;
    LOWORD(v94) = 1024;
    *(_DWORD *)((char *)&v94 + 2) = v61;
    HIWORD(v94) = 1024;
    *(_DWORD *)uint64_t v95 = v62;
    *(_WORD *)&v95[4] = 1024;
    *(_DWORD *)&v95[6] = v63;
    __int16 v96 = 1024;
    *(_DWORD *)uint64_t v97 = v64;
    _os_log_debug_impl( (void *)&_mh_execute_header,  v7,  OS_LOG_TYPE_DEBUG,  "BLEScanStat: MainCoreELNABypass [numAdvs, numAdvsBeforeFiltering, totalTime] [%d, %d, %d] -> [%d, %d, %d]",  buf,  0x26u);
    int v7 = (os_log_s *)qword_1008F75B8;
  }

  if (os_log_type_enabled(v7, OS_LOG_TYPE_DEBUG))
  {
    int v65 = *(_DWORD *)(v2 + 2772);
    int v66 = *(_DWORD *)(v2 + 2776);
    int v67 = *(_DWORD *)(v2 + 2780);
    int v68 = *(_DWORD *)(a1 + 252) + v65;
    int v69 = *(_DWORD *)(a1 + 260) + v66;
    int v70 = *(_DWORD *)(a1 + 228) + v67;
    *(_DWORD *)int buf = 67110400;
    *(_DWORD *)int v93 = v65;
    *(_WORD *)&v93[4] = 1024;
    *(_DWORD *)&v93[6] = v66;
    LOWORD(v94) = 1024;
    *(_DWORD *)((char *)&v94 + 2) = v67;
    HIWORD(v94) = 1024;
    *(_DWORD *)uint64_t v95 = v68;
    *(_WORD *)&v95[4] = 1024;
    *(_DWORD *)&v95[6] = v69;
    __int16 v96 = 1024;
    *(_DWORD *)uint64_t v97 = v70;
    _os_log_debug_impl( (void *)&_mh_execute_header,  v7,  OS_LOG_TYPE_DEBUG,  "BLEScanStat: ScanCoreELNAOn [numAdvs, numAdvsBeforeFiltering, totalTime] [%d, %d, %d] -> [%d, %d, %d]",  buf,  0x26u);
    int v7 = (os_log_s *)qword_1008F75B8;
  }

  if (os_log_type_enabled(v7, OS_LOG_TYPE_DEBUG))
  {
    int v71 = *(_DWORD *)(v2 + 2784);
    int v72 = *(_DWORD *)(v2 + 2788);
    int v73 = *(_DWORD *)(v2 + 2792);
    int v74 = *(_DWORD *)(a1 + 256) + v71;
    int v75 = *(_DWORD *)(a1 + 264) + v72;
    int v76 = *(_DWORD *)(a1 + 232) + v73;
    *(_DWORD *)int buf = 67110400;
    *(_DWORD *)int v93 = v71;
    *(_WORD *)&v93[4] = 1024;
    *(_DWORD *)&v93[6] = v72;
    LOWORD(v94) = 1024;
    *(_DWORD *)((char *)&v94 + 2) = v73;
    HIWORD(v94) = 1024;
    *(_DWORD *)uint64_t v95 = v74;
    *(_WORD *)&v95[4] = 1024;
    *(_DWORD *)&v95[6] = v75;
    __int16 v96 = 1024;
    *(_DWORD *)uint64_t v97 = v76;
    _os_log_debug_impl( (void *)&_mh_execute_header,  v7,  OS_LOG_TYPE_DEBUG,  "BLEScanStat: ScanCoreELNABypass [numAdvs, numAdvsBeforeFiltering, totalTime] [%d, %d, %d] -> [%d, %d, %d]",  buf,  0x26u);
    int v7 = (os_log_s *)qword_1008F75B8;
  }

  *(_DWORD *)(v2 + 2748) += *(_DWORD *)(a1 + 60);
  *(_DWORD *)(v2 + 2752) += *(_DWORD *)(a1 + 68);
  *(_DWORD *)(v2 + 2756) += *(_DWORD *)(a1 + 44);
  *(_DWORD *)(v2 + 2760) += *(_DWORD *)(a1 + 64);
  *(_DWORD *)(v2 + 2764) += *(_DWORD *)(a1 + 72);
  *(_DWORD *)(v2 + 2768) += *(_DWORD *)(a1 + 48);
  *(_DWORD *)(v2 + 2772) += *(_DWORD *)(a1 + 252);
  *(_DWORD *)(v2 + 2776) += *(_DWORD *)(a1 + 260);
  *(_DWORD *)(v2 + 2780) += *(_DWORD *)(a1 + 228);
  *(_DWORD *)(v2 + 2784) += *(_DWORD *)(a1 + 256);
  *(_DWORD *)(v2 + 2788) += *(_DWORD *)(a1 + 264);
  *(_DWORD *)(v2 + 2792) += *(_DWORD *)(a1 + 232);
  if (os_log_type_enabled(v7, OS_LOG_TYPE_DEBUG))
  {
    int v77 = *(_DWORD *)(v2 + 3184);
    int v78 = *(_DWORD *)(v2 + 3188);
    int v79 = *(_DWORD *)(v2 + 3192);
    int v80 = *(_DWORD *)(v2 + 3196);
    int v81 = *(_DWORD *)(v2 + 3200);
    int v82 = *(_DWORD *)(v2 + 3204);
    int v83 = *(_DWORD *)(a1 + 284) + v77;
    int v84 = *(_DWORD *)(a1 + 288) + v78;
    int v85 = *(_DWORD *)(a1 + 292) + v79;
    int v86 = *(_DWORD *)(a1 + 296) + v80;
    int v87 = *(_DWORD *)(a1 + 276) + v81;
    int v88 = *(_DWORD *)(a1 + 280) + v82;
    *(_DWORD *)int buf = 67111936;
    *(_DWORD *)int v93 = v77;
    *(_WORD *)&v93[4] = 1024;
    *(_DWORD *)&v93[6] = v78;
    LOWORD(v94) = 1024;
    *(_DWORD *)((char *)&v94 + 2) = v79;
    HIWORD(v94) = 1024;
    *(_DWORD *)uint64_t v95 = v80;
    *(_WORD *)&v95[4] = 1024;
    *(_DWORD *)&v95[6] = v81;
    __int16 v96 = 1024;
    *(_DWORD *)uint64_t v97 = v82;
    *(_WORD *)&v97[4] = 1024;
    *(_DWORD *)&v97[6] = v83;
    *(_WORD *)int v98 = 1024;
    *(_DWORD *)&v98[2] = v84;
    *(_WORD *)int v99 = 1024;
    *(_DWORD *)&void v99[2] = v85;
    *(_WORD *)uint64_t v100 = 1024;
    *(_DWORD *)&v100[2] = v86;
    *(_WORD *)unsigned int v101 = 1024;
    *(_DWORD *)&v101[2] = v87;
    *(_WORD *)unint64_t v102 = 1024;
    *(_DWORD *)&v102[2] = v88;
    _os_log_debug_impl( (void *)&_mh_execute_header,  v7,  OS_LOG_TYPE_DEBUG,  "BLEScanStat: ScanCoreCompensation [numAdvsELNAOn, numAdvsELNABypass, totalTimeELNAOn, totalTimeELNABypass, txBlank ingBTMC, txBlankingWLAN] [%d, %d, %d, %d, %d, %d] -> [%d, %d, %d, %d, %d, %d]",  buf,  0x4Au);
    int v7 = (os_log_s *)qword_1008F75B8;
  }

  *(int32x4_t *)(v2 + 3184) = vaddq_s32(*(int32x4_t *)(v2 + 3184), *(int32x4_t *)(a1 + 284));
  *(int32x2_t *)(v2 + 3200) = vadd_s32(*(int32x2_t *)(v2 + 3200), *(int32x2_t *)(a1 + 276));
  if (os_log_type_enabled(v7, OS_LOG_TYPE_DEBUG)) {
    sub_10069C65C(a1, v7, v52);
  }
}

uint64_t sub_1005EE698(uint64_t a1)
{
  uint64_t v1 = *(void **)(a1 + 2040);
  uint64_t v2 = (void *)(a1 + 2048);
  if (v1 != (void *)(a1 + 2048))
  {
    int v3 = 0;
    while (1)
    {
      uint64_t v4 = v1[5];
      uint64_t v5 = *(void *)(v4 + 8);
      if (*(_DWORD *)(v5 + 168))
      {
        uint64_t v17 = 0LL;
        *(_OWORD *)std::stringbuf::string_type __p = 0u;
        __int128 v16 = 0u;
        __int128 v14 = 0u;
        uint64_t v6 = *(void *)(v4 + 8);
        __int128 v13 = *(_OWORD *)(v6 + 280);
        __p[0] = 0LL;
        __int128 v14 = 0uLL;
        sub_10060E68C( &v14,  *(void *)(v6 + 328),  *(void *)(v6 + 336),  0xAAAAAAAAAAAAAAABLL * ((uint64_t)(*(void *)(v6 + 336) - *(void *)(v6 + 328)) >> 5));
        __p[1] = 0LL;
        __int128 v16 = 0uLL;
        sub_100050EE8( (char *)&__p[1],  *(__int128 **)(v6 + 352),  *(__int128 **)(v6 + 360),  0xCCCCCCCCCCCCCCCDLL * ((uint64_t)(*(void *)(v6 + 360) - *(void *)(v6 + 352)) >> 2));
        LOBYTE(v17) = *(_BYTE *)(v6 + 376);
        if (BYTE8(v13)) {
          BOOL v7 = HIWORD(v13) == 0;
        }
        else {
          BOOL v7 = 1;
        }
        int v8 = !v7;
        if (__p[1])
        {
          *(void **)&__int128 v16 = __p[1];
          operator delete(__p[1]);
        }

        v3 |= v8;
        int v18 = (void **)&v14;
        sub_10004FEA4(&v18);
        uint64_t v5 = *(void *)(v4 + 8);
      }

      BOOL v9 = *(_BYTE *)(v5 + 122) != 0;
      if ((*(_BYTE *)(v5 + 242) & 4) != 0 && !*(_BYTE *)(v5 + 122)) {
        break;
      }
      int v10 = (void *)v1[1];
      if (v10)
      {
        do
        {
          int v11 = v10;
          int v10 = (void *)*v10;
        }

        while (v10);
      }

      else
      {
        do
        {
          int v11 = (void *)v1[2];
          BOOL v7 = *v11 == (void)v1;
          uint64_t v1 = v11;
        }

        while (!v7);
      }

      v3 |= v9;
      uint64_t v1 = v11;
      if (v11 == v2) {
        return v3 & 1;
      }
    }
  }

  LOBYTE(v3) = 0;
  return v3 & 1;
}

void sub_1005EE824(_Unwind_Exception *a1)
{
  *(void *)(v2 - 88) = v1;
  sub_10004FEA4((void ***)(v2 - 88));
  _Unwind_Resume(a1);
}

BOOL sub_1005EE83C(uint64_t a1)
{
  uint64_t v1 = *(void **)(a1 + 2040);
  uint64_t v2 = (void *)(a1 + 2048);
  if (v1 == (void *)(a1 + 2048)) {
    return 0LL;
  }
  do
  {
    unsigned int v3 = *(unsigned __int16 *)(*(void *)(v1[5] + 8LL) + 124LL) - 1;
    BOOL result = v3 < 0xFF;
    if (v3 < 0xFF) {
      break;
    }
    uint64_t v5 = (void *)v1[1];
    if (v5)
    {
      do
      {
        uint64_t v6 = v5;
        uint64_t v5 = (void *)*v5;
      }

      while (v5);
    }

    else
    {
      do
      {
        uint64_t v6 = (void *)v1[2];
        BOOL v7 = *v6 == (void)v1;
        uint64_t v1 = v6;
      }

      while (!v7);
    }

    uint64_t v1 = v6;
  }

  while (v6 != v2);
  return result;
}

void sub_1005EE8AC(uint64_t a1, char a2)
{
  uint64_t v4 = sub_100404FE8();
  v8[0] = _NSConcreteStackBlock;
  v8[1] = 3221225472LL;
  _DWORD v8[2] = sub_1005EE988;
  void v8[3] = &unk_1008800D8;
  v8[4] = a1;
  char v9 = a2;
  sub_100405384(v4, v8);
  if (*(_BYTE *)(a1 + 2245))
  {
    sub_1005EF7DC(a1);
    sub_1005F0204(a1);
  }

  double Current = CFAbsoluteTimeGetCurrent();
  double v6 = *(double *)(a1 + 2728);
  if (Current > v6 && Current - v6 > 604800.0) {
    sub_1005DF990(a1);
  }
  double v7 = *(double *)(a1 + 3232);
  if (Current > v7 && Current - v7 > 604800.0) {
    sub_1005DFA44(a1);
  }
}

void sub_1005EE988(uint64_t a1)
{
  uint64_t v1 = *(void *)(a1 + 32);
  int v2 = *(unsigned __int8 *)(a1 + 40);
  *(_BYTE *)(v1 + 144) = v2;
  unsigned int v3 = (os_log_s *)qword_1008F75B8;
  if (os_log_type_enabled((os_log_t)qword_1008F75B8, OS_LOG_TYPE_DEFAULT))
  {
    int v4 = *(unsigned __int8 *)(v1 + 1851);
    if (v2) {
      uint64_t v5 = "On";
    }
    else {
      uint64_t v5 = "Off";
    }
    int v6 = (unsigned __int16)[*(id *)(v1 + 2112) count];
    uint64_t v7 = sub_1002E6BF0();
    int v8 = (*(uint64_t (**)(uint64_t))(*(void *)v7 + 704LL))(v7);
    *(_DWORD *)int buf = 67110402;
    *(_DWORD *)&uint8_t buf[4] = v4;
    *(_WORD *)&uint8_t buf[8] = 2082;
    *(void *)&buf[10] = v5;
    *(_WORD *)&_BYTE buf[18] = 1024;
    *(_DWORD *)&_BYTE buf[20] = v6;
    *(_WORD *)&_BYTE buf[24] = 1024;
    *(_DWORD *)&_BYTE buf[26] = v8;
    *(_WORD *)&buf[30] = 1024;
    *(_DWORD *)int v91 = sub_1005EBF48(v1);
    *(_WORD *)&void v91[4] = 1024;
    *(_DWORD *)&v91[6] = sub_1005EE83C(v1);
    _os_log_impl( (void *)&_mh_execute_header,  v3,  OS_LOG_TYPE_DEFAULT,  "screenStateChanged fMatchBufferExpectedEntries:0x%d fScreenState:%{public}s fMatchActionTableRulesCount:%d support edADVBuffers:%d haveAnyHwObjectDiscoveryRequests:%d haveAnyHwAOPBTBufferRequests:%d",  buf,  0x2Au);
    int v2 = *(unsigned __int8 *)(v1 + 144);
  }

  if (v2)
  {
    uint64_t v9 = sub_100404FE8();
    *(void *)int buf = _NSConcreteStackBlock;
    *(void *)&uint8_t buf[8] = 3221225472LL;
    *(void *)&uint8_t buf[16] = sub_1005ED760;
    *(void *)&_BYTE buf[24] = &unk_10087EB68;
    *(void *)int v91 = v1;
    *(_DWORD *)&v91[8] = 1;
    sub_100405384(v9, buf);
    uint64_t v10 = sub_100404FE8();
    *(void *)int buf = _NSConcreteStackBlock;
    *(void *)&uint8_t buf[8] = 3221225472LL;
    *(void *)&uint8_t buf[16] = sub_1005ED66C;
    *(void *)&_BYTE buf[24] = &unk_10087EB68;
    *(void *)int v91 = v1;
    *(_DWORD *)&v91[8] = 1;
    sub_100405384(v10, buf);
  }

  else
  {
    if ([*(id *)(v1 + 2112) count])
    {
      uint64_t v11 = sub_1002E6BF0();
      if ((*(unsigned int (**)(uint64_t))(*(void *)v11 + 704LL))(v11))
      {
        if (*(unsigned __int8 *)(v1 + 1851) == 255)
        {
          int v43 = sub_1005EB324(v1, 1);
          if (v43)
          {
            int v44 = (os_log_s *)qword_1008F75B8;
            if (os_log_type_enabled((os_log_t)qword_1008F75B8, OS_LOG_TYPE_INFO))
            {
              *(_DWORD *)int buf = 67109120;
              *(_DWORD *)&uint8_t buf[4] = v43;
              _os_log_impl( (void *)&_mh_execute_header,  v44,  OS_LOG_TYPE_INFO,  "enableMatchActionRulesBuffering failed with result %d",  buf,  8u);
            }
          }
        }
      }
    }

    sub_1005EC5D8((unsigned __int8 *)v1);
    sub_1005E75F8((unsigned __int8 *)v1);
  }

  if (sub_1005EF760(v1))
  {
    *(_BYTE *)(v1 + 1840) = 1;
    int v12 = (os_log_s *)qword_1008F75B8;
    if (os_log_type_enabled((os_log_t)qword_1008F75B8, OS_LOG_TYPE_DEFAULT))
    {
      int v13 = *(_DWORD *)(v1 + 1960);
      *(_DWORD *)int buf = 67109120;
      *(_DWORD *)&uint8_t buf[4] = v13;
      _os_log_impl( (void *)&_mh_execute_header,  v12,  OS_LOG_TYPE_DEFAULT,  "Restarting scans since the screen is transitioning while there is a request for active scans fState:%d",  buf,  8u);
    }
  }

  __int128 v14 = *(void **)(v1 + 2040);
  if (v14 == (void *)(v1 + 2048))
  {
LABEL_37:
    char v25 = 0;
  }

  else
  {
    char v15 = 0;
    while (1)
    {
      uint64_t v16 = *(void *)(v14[5] + 8LL);
      if (*(_DWORD *)(v16 + 168)) {
        break;
      }
      id v17 = *(id *)(v16 + 176);
      __int128 v86 = 0u;
      __int128 v87 = 0u;
      __int128 v88 = 0u;
      __int128 v89 = 0u;
      id v18 = v17;
      id v19 = [v18 countByEnumeratingWithState:&v86 objects:v123 count:16];
      if (v19)
      {
        uint64_t v20 = *(void *)v87;
        while (2)
        {
          for (uint64_t i = 0LL; i != v19; uint64_t i = (char *)i + 1)
          {
            if (*(void *)v87 != v20) {
              objc_enumerationMutation(v18);
            }
            if ([*(id *)(*((void *)&v86 + 1) + 8 * (void)i) intValue])
            {
              char v15 = 1;
              goto LABEL_28;
            }
          }

          id v19 = [v18 countByEnumeratingWithState:&v86 objects:v123 count:16];
          if (v19) {
            continue;
          }
          break;
        }
      }

void sub_1005EF73C(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

BOOL sub_1005EF760(uint64_t a1)
{
  uint64_t v1 = *(void **)(a1 + 2040);
  int v2 = (void *)(a1 + 2048);
  if (v1 == (void *)(a1 + 2048)) {
    return 0LL;
  }
  while (1)
  {
    BOOL result = sub_100610C44(v1[5]);
    if (result) {
      break;
    }
    int v4 = (void *)v1[1];
    if (v4)
    {
      do
      {
        uint64_t v5 = v4;
        int v4 = (void *)*v4;
      }

      while (v4);
    }

    else
    {
      do
      {
        uint64_t v5 = (void *)v1[2];
        BOOL v6 = *v5 == (void)v1;
        uint64_t v1 = v5;
      }

      while (!v6);
    }

    uint64_t v1 = v5;
    if (v5 == v2) {
      return result;
    }
  }

  return 1LL;
}

void sub_1005EF7DC(uint64_t a1)
{
  int v2 = (os_log_s *)qword_1008F75B8;
  if (os_log_type_enabled((os_log_t)qword_1008F75B8, OS_LOG_TYPE_DEFAULT))
  {
    *(_WORD *)int buf = 0;
    _os_log_impl((void *)&_mh_execute_header, v2, OS_LOG_TYPE_DEFAULT, "statedump: BLE Scan Stat:", buf, 2u);
    int v2 = (os_log_s *)qword_1008F75B8;
  }

  if (os_log_type_enabled(v2, OS_LOG_TYPE_DEFAULT))
  {
    double v3 = *(double *)(a1 + 2728);
    *(_DWORD *)int buf = 134217984;
    double v47 = v3;
    _os_log_impl( (void *)&_mh_execute_header,  v2,  OS_LOG_TYPE_DEFAULT,  "statedump: \tLast Stat Start Time: %f sec",  buf,  0xCu);
  }

  double Current = CFAbsoluteTimeGetCurrent();
  uint64_t v5 = (os_log_s *)qword_1008F75B8;
  if (os_log_type_enabled((os_log_t)qword_1008F75B8, OS_LOG_TYPE_DEFAULT))
  {
    double v6 = *(double *)(a1 + 2728);
    double v7 = Current - v6;
    BOOL v8 = Current < v6;
    double v9 = 0.0;
    if (!v8) {
      double v9 = v7;
    }
    *(_DWORD *)int buf = 134217984;
    double v47 = v9;
    _os_log_impl( (void *)&_mh_execute_header,  v5,  OS_LOG_TYPE_DEFAULT,  "statedump: \tStat Measurement Duration: %f sec",  buf,  0xCu);
    uint64_t v5 = (os_log_s *)qword_1008F75B8;
  }

  if (os_log_type_enabled(v5, OS_LOG_TYPE_DEFAULT))
  {
    int v10 = *(_DWORD *)(a1 + 2736);
    *(_DWORD *)int buf = 67109120;
    LODWORD(v47) = v10;
    _os_log_impl( (void *)&_mh_execute_header,  v5,  OS_LOG_TYPE_DEFAULT,  "statedump: \tNum Range Scan Requests: %u",  buf,  8u);
    uint64_t v5 = (os_log_s *)qword_1008F75B8;
  }

  if (os_log_type_enabled(v5, OS_LOG_TYPE_DEFAULT))
  {
    int v11 = *(_DWORD *)(a1 + 2740);
    *(_DWORD *)int buf = 67109120;
    LODWORD(v47) = v11;
    _os_log_impl( (void *)&_mh_execute_header,  v5,  OS_LOG_TYPE_DEFAULT,  "statedump: \tNum Priority Critical Scan Requests: %u",  buf,  8u);
    uint64_t v5 = (os_log_s *)qword_1008F75B8;
  }

  if (os_log_type_enabled(v5, OS_LOG_TYPE_DEFAULT))
  {
    int v12 = *(_DWORD *)(a1 + 2744);
    *(_DWORD *)int buf = 67109120;
    LODWORD(v47) = v12;
    _os_log_impl((void *)&_mh_execute_header, v5, OS_LOG_TYPE_DEFAULT, "statedump: \tNum Scan Requests: %u", buf, 8u);
  }

  uint64_t v13 = sub_1002E6BF0();
  if (((*(uint64_t (**)(uint64_t))(*(void *)v13 + 624LL))(v13) & 1) != 0
    || (uint64_t v14 = sub_1002E6BF0(), (*(unsigned int (**)(uint64_t))(*(void *)v14 + 648LL))(v14)))
  {
    char v15 = (os_log_s *)qword_1008F75B8;
    if (os_log_type_enabled((os_log_t)qword_1008F75B8, OS_LOG_TYPE_DEFAULT))
    {
      *(_WORD *)int buf = 0;
      _os_log_impl((void *)&_mh_execute_header, v15, OS_LOG_TYPE_DEFAULT, "statedump: \tMainCoreELNAOnStat:", buf, 2u);
      char v15 = (os_log_s *)qword_1008F75B8;
    }

    if (os_log_type_enabled(v15, OS_LOG_TYPE_DEFAULT))
    {
      int v16 = *(_DWORD *)(a1 + 2748);
      *(_DWORD *)int buf = 67109120;
      LODWORD(v47) = v16;
      _os_log_impl( (void *)&_mh_execute_header,  v15,  OS_LOG_TYPE_DEFAULT,  "statedump: \t\tnumAdvsAfterFiltering: %u",  buf,  8u);
      char v15 = (os_log_s *)qword_1008F75B8;
    }

    if (os_log_type_enabled(v15, OS_LOG_TYPE_DEFAULT))
    {
      int v17 = *(_DWORD *)(a1 + 2752);
      *(_DWORD *)int buf = 67109120;
      LODWORD(v47) = v17;
      _os_log_impl( (void *)&_mh_execute_header,  v15,  OS_LOG_TYPE_DEFAULT,  "statedump: \t\tnumAdvsBeforeFiltering: %u",  buf,  8u);
      char v15 = (os_log_s *)qword_1008F75B8;
    }

    if (os_log_type_enabled(v15, OS_LOG_TYPE_DEFAULT))
    {
      int v18 = *(_DWORD *)(a1 + 2756);
      *(_DWORD *)int buf = 67109120;
      LODWORD(v47) = v18;
      _os_log_impl((void *)&_mh_execute_header, v15, OS_LOG_TYPE_DEFAULT, "statedump: \t\ttotalTime: %u msec", buf, 8u);
      char v15 = (os_log_s *)qword_1008F75B8;
    }

    if (os_log_type_enabled(v15, OS_LOG_TYPE_DEFAULT))
    {
      *(_WORD *)int buf = 0;
      _os_log_impl( (void *)&_mh_execute_header,  v15,  OS_LOG_TYPE_DEFAULT,  "statedump: \tMainCoreELNABypassStat:",  buf,  2u);
      char v15 = (os_log_s *)qword_1008F75B8;
    }

    if (os_log_type_enabled(v15, OS_LOG_TYPE_DEFAULT))
    {
      int v19 = *(_DWORD *)(a1 + 2760);
      *(_DWORD *)int buf = 67109120;
      LODWORD(v47) = v19;
      _os_log_impl( (void *)&_mh_execute_header,  v15,  OS_LOG_TYPE_DEFAULT,  "statedump: \t\tnumAdvsAfterFiltering: %u",  buf,  8u);
      char v15 = (os_log_s *)qword_1008F75B8;
    }

    if (os_log_type_enabled(v15, OS_LOG_TYPE_DEFAULT))
    {
      int v20 = *(_DWORD *)(a1 + 2764);
      *(_DWORD *)int buf = 67109120;
      LODWORD(v47) = v20;
      _os_log_impl( (void *)&_mh_execute_header,  v15,  OS_LOG_TYPE_DEFAULT,  "statedump: \t\tnumAdvsBeforeFiltering: %u",  buf,  8u);
      char v15 = (os_log_s *)qword_1008F75B8;
    }

    if (os_log_type_enabled(v15, OS_LOG_TYPE_DEFAULT))
    {
      int v21 = *(_DWORD *)(a1 + 2768);
      *(_DWORD *)int buf = 67109120;
      LODWORD(v47) = v21;
      _os_log_impl((void *)&_mh_execute_header, v15, OS_LOG_TYPE_DEFAULT, "statedump: \t\ttotalTime: %u msec", buf, 8u);
    }
  }

  uint64_t v22 = sub_1002E6BF0();
  int v23 = (*(uint64_t (**)(uint64_t))(*(void *)v22 + 648LL))(v22);
  BOOL v24 = (os_log_s *)qword_1008F75B8;
  if (v23)
  {
    if (os_log_type_enabled((os_log_t)qword_1008F75B8, OS_LOG_TYPE_DEFAULT))
    {
      *(_WORD *)int buf = 0;
      _os_log_impl((void *)&_mh_execute_header, v24, OS_LOG_TYPE_DEFAULT, "statedump: \tScanCoreELNAOnStat:", buf, 2u);
      BOOL v24 = (os_log_s *)qword_1008F75B8;
    }

    if (os_log_type_enabled(v24, OS_LOG_TYPE_DEFAULT))
    {
      int v25 = *(_DWORD *)(a1 + 2772);
      *(_DWORD *)int buf = 67109120;
      LODWORD(v47) = v25;
      _os_log_impl( (void *)&_mh_execute_header,  v24,  OS_LOG_TYPE_DEFAULT,  "statedump: \t\tnumAdvsAfterFiltering: %u",  buf,  8u);
      BOOL v24 = (os_log_s *)qword_1008F75B8;
    }

    if (os_log_type_enabled(v24, OS_LOG_TYPE_DEFAULT))
    {
      int v26 = *(_DWORD *)(a1 + 2776);
      *(_DWORD *)int buf = 67109120;
      LODWORD(v47) = v26;
      _os_log_impl( (void *)&_mh_execute_header,  v24,  OS_LOG_TYPE_DEFAULT,  "statedump: \t\tnumAdvsBeforeFiltering: %u",  buf,  8u);
      BOOL v24 = (os_log_s *)qword_1008F75B8;
    }

    if (os_log_type_enabled(v24, OS_LOG_TYPE_DEFAULT))
    {
      int v27 = *(_DWORD *)(a1 + 2780);
      *(_DWORD *)int buf = 67109120;
      LODWORD(v47) = v27;
      _os_log_impl((void *)&_mh_execute_header, v24, OS_LOG_TYPE_DEFAULT, "statedump: \t\ttotalTime: %u msec", buf, 8u);
      BOOL v24 = (os_log_s *)qword_1008F75B8;
    }

    if (os_log_type_enabled(v24, OS_LOG_TYPE_DEFAULT))
    {
      *(_WORD *)int buf = 0;
      _os_log_impl( (void *)&_mh_execute_header,  v24,  OS_LOG_TYPE_DEFAULT,  "statedump: \tScanCoreELNABypassStat:",  buf,  2u);
      BOOL v24 = (os_log_s *)qword_1008F75B8;
    }

    if (os_log_type_enabled(v24, OS_LOG_TYPE_DEFAULT))
    {
      int v28 = *(_DWORD *)(a1 + 2784);
      *(_DWORD *)int buf = 67109120;
      LODWORD(v47) = v28;
      _os_log_impl( (void *)&_mh_execute_header,  v24,  OS_LOG_TYPE_DEFAULT,  "statedump: \t\tnumAdvsAfterFiltering: %u",  buf,  8u);
      BOOL v24 = (os_log_s *)qword_1008F75B8;
    }

    if (os_log_type_enabled(v24, OS_LOG_TYPE_DEFAULT))
    {
      int v29 = *(_DWORD *)(a1 + 2788);
      *(_DWORD *)int buf = 67109120;
      LODWORD(v47) = v29;
      _os_log_impl( (void *)&_mh_execute_header,  v24,  OS_LOG_TYPE_DEFAULT,  "statedump: \t\tnumAdvsBeforeFiltering: %u",  buf,  8u);
      BOOL v24 = (os_log_s *)qword_1008F75B8;
    }

    if (os_log_type_enabled(v24, OS_LOG_TYPE_DEFAULT))
    {
      int v30 = *(_DWORD *)(a1 + 2792);
      *(_DWORD *)int buf = 67109120;
      LODWORD(v47) = v30;
      _os_log_impl((void *)&_mh_execute_header, v24, OS_LOG_TYPE_DEFAULT, "statedump: \t\ttotalTime: %u msec", buf, 8u);
      BOOL v24 = (os_log_s *)qword_1008F75B8;
    }

    if (os_log_type_enabled(v24, OS_LOG_TYPE_DEFAULT))
    {
      *(_WORD *)int buf = 0;
      _os_log_impl( (void *)&_mh_execute_header,  v24,  OS_LOG_TYPE_DEFAULT,  "statedump: \tScanCoreCompsensationStat:",  buf,  2u);
      BOOL v24 = (os_log_s *)qword_1008F75B8;
    }

    if (os_log_type_enabled(v24, OS_LOG_TYPE_DEFAULT))
    {
      int v31 = *(_DWORD *)(a1 + 3184);
      *(_DWORD *)int buf = 67109120;
      LODWORD(v47) = v31;
      _os_log_impl((void *)&_mh_execute_header, v24, OS_LOG_TYPE_DEFAULT, "statedump: \t\tnumAdvsELNAOn: %u", buf, 8u);
      BOOL v24 = (os_log_s *)qword_1008F75B8;
    }

    if (os_log_type_enabled(v24, OS_LOG_TYPE_DEFAULT))
    {
      int v32 = *(_DWORD *)(a1 + 3188);
      *(_DWORD *)int buf = 67109120;
      LODWORD(v47) = v32;
      _os_log_impl( (void *)&_mh_execute_header,  v24,  OS_LOG_TYPE_DEFAULT,  "statedump: \t\numAdvsELNABypass: %u",  buf,  8u);
      BOOL v24 = (os_log_s *)qword_1008F75B8;
    }

    if (os_log_type_enabled(v24, OS_LOG_TYPE_DEFAULT))
    {
      int v33 = *(_DWORD *)(a1 + 3192);
      *(_DWORD *)int buf = 67109120;
      LODWORD(v47) = v33;
      _os_log_impl((void *)&_mh_execute_header, v24, OS_LOG_TYPE_DEFAULT, "statedump: \t\totalTimeELNAOn: %u", buf, 8u);
      BOOL v24 = (os_log_s *)qword_1008F75B8;
    }

    if (os_log_type_enabled(v24, OS_LOG_TYPE_DEFAULT))
    {
      int v34 = *(_DWORD *)(a1 + 3196);
      *(_DWORD *)int buf = 67109120;
      LODWORD(v47) = v34;
      _os_log_impl( (void *)&_mh_execute_header,  v24,  OS_LOG_TYPE_DEFAULT,  "statedump: \t\totalTimeELNABypass: %u",  buf,  8u);
      BOOL v24 = (os_log_s *)qword_1008F75B8;
    }

    if (os_log_type_enabled(v24, OS_LOG_TYPE_DEFAULT))
    {
      int v35 = *(_DWORD *)(a1 + 3200);
      *(_DWORD *)int buf = 67109120;
      LODWORD(v47) = v35;
      _os_log_impl( (void *)&_mh_execute_header,  v24,  OS_LOG_TYPE_DEFAULT,  "statedump: \t\txBlankingTimeByBTMC: %u",  buf,  8u);
      BOOL v24 = (os_log_s *)qword_1008F75B8;
    }

    if (os_log_type_enabled(v24, OS_LOG_TYPE_DEFAULT))
    {
      int v36 = *(_DWORD *)(a1 + 3204);
      *(_DWORD *)int buf = 67109120;
      LODWORD(v47) = v36;
      _os_log_impl( (void *)&_mh_execute_header,  v24,  OS_LOG_TYPE_DEFAULT,  "statedump: \t\txBlankingTimeByWLAN: %u",  buf,  8u);
      BOOL v24 = (os_log_s *)qword_1008F75B8;
    }
  }

  if (os_log_type_enabled(v24, OS_LOG_TYPE_DEFAULT))
  {
    *(_WORD *)int buf = 0;
    _os_log_impl( (void *)&_mh_execute_header,  v24,  OS_LOG_TYPE_DEFAULT,  "statedump: \tTotal Scan Time per Type:",  buf,  2u);
    BOOL v24 = (os_log_s *)qword_1008F75B8;
  }

  uint64_t v37 = 0LL;
  uint64_t v38 = a1 + 2800;
  do
  {
    uint64_t v39 = 0LL;
    uint64_t v45 = v38;
    do
    {
      uint64_t v40 = 0LL;
      if (v39) {
        uint64_t v41 = "Active ";
      }
      else {
        uint64_t v41 = "Passive";
      }
      do
      {
        if (os_log_type_enabled(v24, OS_LOG_TYPE_DEFAULT))
        {
          *(double *)&uint64_t v42 = COERCE_DOUBLE("Unknown Scan Agent Type");
          int v43 = "Unknown Duty Cycle Type";
          uint64_t v44 = *(void *)(v38 + 8 * v40);
          *(_DWORD *)int buf = 136446978;
          double v47 = *(double *)&v42;
          __int16 v48 = 2082;
          int v49 = v41;
          __int16 v50 = 2080;
          int v51 = v43;
          __int16 v52 = 2048;
          uint64_t v53 = v44;
          _os_log_impl( (void *)&_mh_execute_header,  v24,  OS_LOG_TYPE_DEFAULT,  "statedump: \t\t%{public}s %{public}s %-37s: %f sec",  buf,  0x2Au);
          BOOL v24 = (os_log_s *)qword_1008F75B8;
        }

        ++v40;
      }

      while (v40 != 3);
      ++v39;
      v38 += 24LL;
    }

    while (v39 != 2);
    ++v37;
    uint64_t v38 = v45 + 48;
  }

  while (v37 != 7);
}

void sub_1005F0204(uint64_t a1)
{
  uint64_t v2 = sub_1002E6BF0();
  if ((*(unsigned int (**)(uint64_t))(*(void *)v2 + 648LL))(v2))
  {
    double v3 = (os_log_s *)qword_1008F75B8;
    if (os_log_type_enabled((os_log_t)qword_1008F75B8, OS_LOG_TYPE_DEFAULT))
    {
      LOWORD(v12) = 0;
      _os_log_impl( (void *)&_mh_execute_header,  v3,  OS_LOG_TYPE_DEFAULT,  "statedump: BLE Connection Scan Stat (ScanCore):",  (uint8_t *)&v12,  2u);
    }

    double Current = CFAbsoluteTimeGetCurrent();
    uint64_t v5 = (os_log_s *)qword_1008F75B8;
    if (os_log_type_enabled((os_log_t)qword_1008F75B8, OS_LOG_TYPE_DEFAULT))
    {
      double v6 = *(double *)(a1 + 3232);
      double v7 = Current - v6;
      if (Current < v6) {
        double v7 = 0.0;
      }
      int v12 = 134217984;
      CFAbsoluteTime v13 = v7;
      _os_log_impl( (void *)&_mh_execute_header,  v5,  OS_LOG_TYPE_DEFAULT,  "statedump: \tLast Stat Start Time: %f sec",  (uint8_t *)&v12,  0xCu);
      uint64_t v5 = (os_log_s *)qword_1008F75B8;
    }

    if (os_log_type_enabled(v5, OS_LOG_TYPE_DEFAULT))
    {
      CFAbsoluteTime v8 = CFAbsoluteTimeGetCurrent() - *(double *)(a1 + 3232);
      int v12 = 134217984;
      CFAbsoluteTime v13 = v8;
      _os_log_impl( (void *)&_mh_execute_header,  v5,  OS_LOG_TYPE_DEFAULT,  "statedump: \tStat Measurement Duration: %f sec",  (uint8_t *)&v12,  0xCu);
      uint64_t v5 = (os_log_s *)qword_1008F75B8;
    }

    if (os_log_type_enabled(v5, OS_LOG_TYPE_DEFAULT))
    {
      int v9 = *(_DWORD *)(a1 + 3240);
      int v12 = 67109120;
      LODWORD(v13) = v9;
      _os_log_impl( (void *)&_mh_execute_header,  v5,  OS_LOG_TYPE_DEFAULT,  "statedump: \tNum Connections made with MainCore while ScanCore Enabled:%u",  (uint8_t *)&v12,  8u);
      uint64_t v5 = (os_log_s *)qword_1008F75B8;
    }

    if (os_log_type_enabled(v5, OS_LOG_TYPE_DEFAULT))
    {
      int v10 = *(_DWORD *)(a1 + 3244);
      int v12 = 67109120;
      LODWORD(v13) = v10;
      _os_log_impl( (void *)&_mh_execute_header,  v5,  OS_LOG_TYPE_DEFAULT,  "statedump: \tNum Connections made with ScanCore while ScanCore Enabled:%u",  (uint8_t *)&v12,  8u);
      uint64_t v5 = (os_log_s *)qword_1008F75B8;
    }

    if (os_log_type_enabled(v5, OS_LOG_TYPE_DEFAULT))
    {
      int v11 = *(_DWORD *)(a1 + 3248);
      int v12 = 67109120;
      LODWORD(v13) = v11;
      _os_log_impl( (void *)&_mh_execute_header,  v5,  OS_LOG_TYPE_DEFAULT,  "statedump: \tNum ScanCore Enabled for Connection Scan:%u",  (uint8_t *)&v12,  8u);
    }
  }

void sub_1005F044C(uint64_t a1, char a2)
{
}

__n128 sub_1005F0454(uint64_t a1, uint64_t a2)
{
  *(_OWORD *)(a2 + 16) = *(_OWORD *)(a1 + 2152);
  __n128 result = *(__n128 *)(a1 + 2136);
  *(__n128 *)a2 = result;
  return result;
}

void sub_1005F046C(uint64_t a1)
{
  if (qword_1008D60B0 != -1) {
    dispatch_once(&qword_1008D60B0, &stru_1008A4038);
  }
  sub_100009168((uint64_t)off_1008D60A8 + 80, a1 + 16);
  if (qword_1008D67C8 != -1) {
    dispatch_once(&qword_1008D67C8, &stru_1008A4018);
  }
  sub_100009168((uint64_t)off_1008D67C0 + 192, a1);
}

uint64_t sub_1005F04FC(uint64_t a1, uint64_t a2)
{
  uint64_t v2 = a2;
  int v3 = *(unsigned __int8 *)(a1 + 2168);
  if (v3 != 2)
  {
    if (v3 == 1)
    {
      int v4 = *(__int128 **)(a1 + 2176);
      uint64_t v42 = *(__int128 **)(a1 + 2184);
      if (v4 == v42)
      {
        char v22 = 1;
        return v22 & 1;
      }

      char v5 = 0;
      while (1)
      {
        __p[1] = 0LL;
        uint64_t v48 = 0LL;
        __p[0] = 0LL;
        if (*((char *)v4 + 23) < 0)
        {
          sub_100024238(__p, *(void **)v4, *((void *)v4 + 1));
        }

        else
        {
          __int128 v6 = *v4;
          uint64_t v48 = *((void *)v4 + 2);
          *(_OWORD *)std::stringbuf::string_type __p = v6;
        }

        sub_100494958(v2, (uint64_t)&v44);
        unsigned __int8 v7 = v46;
        CFAbsoluteTime v8 = v44;
        int v9 = (v46 & 0x80u) == 0 ? &v44 : (void **)v44;
        char v10 = HIBYTE(v48);
        int v11 = v48 >= 0 ? __p : (void **)__p[0];
        int v12 = v48 >= 0 ? (void *)HIBYTE(v48) : __p[1];
        if (v12) {
          break;
        }
        uint64_t v16 = 0LL;
        if ((v46 & 0x80) != 0) {
          goto LABEL_36;
        }
LABEL_37:
        BOOL v21 = v16 != -1;
        if (v10 < 0) {
          operator delete(__p[0]);
        }
        v5 |= v21;
        int v4 = (__int128 *)((char *)v4 + 24);
        if (v4 == v42)
        {
          char v22 = v5 ^ 1;
          return v22 & 1;
        }
      }

      if ((v46 & 0x80u) == 0) {
        uint64_t v13 = v46;
      }
      else {
        uint64_t v13 = v45;
      }
      uint64_t v14 = (char *)v9 + v13;
      if (v13 >= (uint64_t)v12)
      {
        uint64_t v40 = v44;
        int v17 = *(unsigned __int8 *)v11;
        int v18 = v9;
        do
        {
          uint64_t v19 = v13 - (void)v12;
          if (v19 == -1) {
            break;
          }
          int v20 = (char *)memchr(v18, v17, v19 + 1);
          if (!v20) {
            break;
          }
          char v15 = v20;
          if (!memcmp(v20, v11, (size_t)v12)) {
            goto LABEL_31;
          }
          int v18 = (void **)(v15 + 1);
          uint64_t v13 = v14 - (v15 + 1);
        }

        while (v13 >= (uint64_t)v12);
        char v15 = v14;
LABEL_31:
        CFAbsoluteTime v8 = v40;
        uint64_t v2 = a2;
      }

      else
      {
        char v15 = (char *)v9 + v13;
      }

      if (v15 == v14) {
        uint64_t v16 = -1LL;
      }
      else {
        uint64_t v16 = v15 - (char *)v9;
      }
      if ((v7 & 0x80) == 0) {
        goto LABEL_37;
      }
LABEL_36:
      operator delete(v8);
      char v10 = HIBYTE(v48);
      goto LABEL_37;
    }

void sub_1005F0810( _Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, void *__p, uint64_t a16, int a17, __int16 a18, char a19, char a20)
{
  if (a20 < 0) {
    operator delete(__p);
  }
  _Unwind_Resume(exception_object);
}

uint64_t sub_1005F0830(uint64_t a1, uint64_t *a2, int a3)
{
  if (*((char *)a2 + 23) < 0)
  {
    unint64_t v3 = a2[1];
    if (!v3) {
      return 3LL;
    }
    a2 = (uint64_t *)*a2;
  }

  else
  {
    unint64_t v3 = *((unsigned __int8 *)a2 + 23);
    if (!*((_BYTE *)a2 + 23)) {
      return 3LL;
    }
  }

  if (v3 >= 9) {
    unint64_t v3 = 9LL;
  }
  int v4 = (uint64_t *)((char *)a2 + v3);
  char v5 = a2;
  __int128 v6 = v4;
  do
  {
    if (*(_BYTE *)v5 == 99)
    {
      uint64_t v7 = &_mh_execute_header.magic + 1;
      while (v7 != 9)
      {
        int v8 = *((unsigned __int8 *)v5 + v7);
        int v9 = aComApple_0[v7++];
        if (v8 != v9) {
          goto LABEL_10;
        }
      }

      __int128 v6 = v5;
    }

uint64_t sub_1005F08E4(uint64_t a1)
{
  return (*(_BYTE *)(a1 + 711) + *(_BYTE *)(a1 + 167));
}

uint64_t sub_1005F08F8(uint64_t a1, unint64_t a2, unsigned __int8 *a3)
{
  unint64_t v187 = a2;
  if (!*(_DWORD *)(a1 + 1960)) {
    return 105LL;
  }
  if (sub_1005F04FC(a1, a2))
  {
    __int128 v6 = (os_log_s *)qword_1008F75B8;
    uint64_t v7 = 0LL;
    if (os_log_type_enabled((os_log_t)qword_1008F75B8, OS_LOG_TYPE_DEFAULT))
    {
      sub_100494958(a2, (uint64_t)__p);
      if (SHIBYTE(__p[2]) >= 0) {
        int v8 = __p;
      }
      else {
        int v8 = (void **)__p[0];
      }
      int v9 = *(unsigned __int8 *)(a1 + 2168);
      LODWORD(buf.__r_.__value_.__l.__data_) = 136446466;
      *(std::string::size_type *)((char *)buf.__r_.__value_.__r.__words + 4) = (std::string::size_type)v8;
      WORD2(buf.__r_.__value_.__r.__words[1]) = 1024;
      *(_DWORD *)((char *)&buf.__r_.__value_.__r.__words[1] + 6) = v9;
      _os_log_impl( (void *)&_mh_execute_header,  v6,  OS_LOG_TYPE_DEFAULT,  "Rejecting the custom Scan for %{public}s for list type %d",  (uint8_t *)&buf,  0x12u);
      if (SHIBYTE(__p[2]) < 0) {
        operator delete(__p[0]);
      }
      return 0LL;
    }

    return v7;
  }

  if (qword_1008D67C8 != -1) {
    dispatch_once(&qword_1008D67C8, &stru_1008A4018);
  }
  BOOL v10 = sub_10027D914((uint64_t)off_1008D67C0, a2);
  int v184 = 0LL;
  int v185 = 0LL;
  uint64_t v186 = 0LL;
  __int16 v166 = a3;
  sub_100050EE8( (char *)&v184,  *((__int128 **)a3 + 1),  *((__int128 **)a3 + 2),  0xCCCCCCCCCCCCCCCDLL * ((uint64_t)(*((void *)a3 + 2) - *((void *)a3 + 1)) >> 2));
  if (qword_1008D67C8 != -1) {
    dispatch_once(&qword_1008D67C8, &stru_1008A4018);
  }
  uint64_t v11 = sub_10027D798((uint64_t)off_1008D67C0, v187);
  if ((_DWORD)v11 == 1)
  {
    if (a3[1]) {
      uint64_t v11 = 32LL;
    }
    else {
      uint64_t v11 = 1LL;
    }
  }

  int v12 = (id *)(a3 + 152);
  id v13 = *((id *)a3 + 19);
  BOOL v14 = [v13 count] == 0;

  if (v14)
  {
    char v15 = (void *)objc_claimAutoreleasedReturnValue(+[NSSet setWithObject:](&OBJC_CLASS___NSSet, "setWithObject:", @"com.apple.bluetooth"));
    objc_storeStrong(v12, v15);
  }

  uint64_t v16 = (void *)(a1 + 2048);
  int v17 = *(void **)(a1 + 2048);
  if (!v17) {
    goto LABEL_32;
  }
  uint64_t v18 = a1 + 2048;
  do
  {
    unint64_t v19 = v17[4];
    BOOL v20 = v19 >= v187;
    if (v19 >= v187) {
      BOOL v21 = v17;
    }
    else {
      BOOL v21 = v17 + 1;
    }
    if (v20) {
      uint64_t v18 = (uint64_t)v17;
    }
    int v17 = (void *)*v21;
  }

  while (*v21);
  if ((void *)v18 == v16 || v187 < *(void *)(v18 + 32)) {
LABEL_32:
  }
    uint64_t v18 = a1 + 2048;
  __int16 v168 = (char *)operator new(0x100uLL);
  sub_100610BA4(v168, v166, v10, v11, *(unsigned __int8 *)(a1 + 144));
  if (qword_1008D67C8 != -1) {
    dispatch_once(&qword_1008D67C8, &stru_1008A4018);
  }
  v168[83] = sub_10027D96C((uint64_t)off_1008D67C0, v187);
  sub_100494958(v187, (uint64_t)&__str);
  std::string::operator=((std::string *)(v168 + 232), &__str);
  uint64_t v22 = sub_1005DFF08(a1, (uint64_t)v168);
  int v23 = (void *)(a1 + 2040);
  BOOL v24 = v166[122] != 0;
  if (v166[122] && (_os_feature_enabled_impl("BluetoothFeatures", "SentinelNewLocationFeatures") & 1) == 0)
  {
    unsigned __int8 v25 = (os_log_s *)qword_1008F75B8;
    if (os_log_type_enabled((os_log_t)qword_1008F75B8, OS_LOG_TYPE_DEFAULT))
    {
      LOWORD(__p[0]) = 0;
      _os_log_impl((void *)&_mh_execute_header, v25, OS_LOG_TYPE_DEFAULT, "ADVBUFF Legacy mode", (uint8_t *)__p, 2u);
    }

    int v26 = (void *)*v23;
    if ((void *)*v23 != v16)
    {
      while (1)
      {
        if (sub_100611304(v26[5]))
        {
          uint64_t v27 = v26[4];
          if (v187 != v27) {
            break;
          }
        }

        char v28 = (void *)v26[1];
        if (v28)
        {
          do
          {
            int v29 = v28;
            char v28 = (void *)*v28;
          }

          while (v28);
        }

        else
        {
          do
          {
            int v29 = (void *)v26[2];
            BOOL v132 = *v29 == (void)v26;
            int v26 = v29;
          }

          while (!v132);
        }

        int v26 = v29;
        if (v29 == v16) {
          goto LABEL_50;
        }
      }

      uint64_t v42 = (os_log_s *)qword_1008F75B8;
      if (os_log_type_enabled((os_log_t)qword_1008F75B8, OS_LOG_TYPE_ERROR))
      {
        sub_100494958(v27, (uint64_t)&buf);
        int size = (char)buf.__r_.__value_.__s.__size_;
        p_std::stringbuf::string_type buf = (std::stringbuf::string_type *)buf.__r_.__value_.__r.__words[0];
        int v163 = v203;
        sub_100494E68(v26[4], v203);
        if (size >= 0) {
          p_std::stringbuf::string_type buf = &buf;
        }
        if (SBYTE7(v204) < 0) {
          int v163 = *(uint8_t **)v203;
        }
        __int16 v164 = sub_1005E2B18(*(_DWORD *)(*(void *)(v26[5] + 8LL) + 168LL));
        LODWORD(__p[0]) = 136446722;
        *(void **)((char *)__p + 4) = p_buf;
        WORD2(__p[1]) = 2082;
        *(void **)((char *)&__p[1] + 6) = v163;
        HIWORD(__p[2]) = 2082;
        __p[3] = (void *)v164;
        _os_log_error_impl( (void *)&_mh_execute_header,  v42,  OS_LOG_TYPE_ERROR,  "Session %{public}s(%{public}s) %{public}s already uses the ADV buffers for type 18",  (uint8_t *)__p,  0x20u);
        if (SBYTE7(v204) < 0) {
          operator delete(*(void **)v203);
        }
      }

      uint64_t v7 = 3LL;
      goto LABEL_303;
    }
  }

void sub_1005F2310( _Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20, uint64_t a21, uint64_t a22, uint64_t a23, uint64_t a24, uint64_t a25, uint64_t a26, uint64_t a27, uint64_t a28, uint64_t a29, uint64_t a30, uint64_t a31, uint64_t a32, uint64_t a33, uint64_t a34, uint64_t a35, uint64_t a36, uint64_t a37, uint64_t a38, uint64_t a39, uint64_t a40, uint64_t a41, uint64_t a42, uint64_t a43, uint64_t a44, uint64_t a45, uint64_t a46, void *a47)
{
  if (SLOBYTE(STACK[0x327]) < 0) {
    operator delete((void *)STACK[0x310]);
  }
  if (a47) {
    operator delete(a47);
  }
  _Unwind_Resume(a1);
}

uint64_t sub_1005F24EC(uint64_t a1, unint64_t a2, int a3, int a4, char a5)
{
  if (!*(_DWORD *)(a1 + 1960)) {
    return 105LL;
  }
  __int128 v6 = *(void **)(a1 + 2048);
  if (!v6) {
    return 401LL;
  }
  int v8 = (uint64_t *)(a1 + 2048);
  do
  {
    unint64_t v9 = v6[4];
    BOOL v10 = v9 >= a2;
    if (v9 >= a2) {
      uint64_t v11 = v6;
    }
    else {
      uint64_t v11 = v6 + 1;
    }
    if (v10) {
      int v8 = v6;
    }
    __int128 v6 = (void *)*v11;
  }

  while (*v11);
  uint64_t v76 = (uint64_t **)(a1 + 2040);
  uint64_t v81 = v8[5];
  uint64_t v95 = 0LL;
  __int128 v93 = 0u;
  __int128 v94 = 0u;
  sub_100494958(a2, (uint64_t)__p);
  sub_10040CD64((uint64_t)&v93, (__int128 *)__p, *(_BYTE *)(v81 + 81), *(_DWORD *)(v81 + 120));
  if ((__p[23] & 0x80000000) != 0) {
    operator delete(*(void **)__p);
  }
  if (qword_1008D9298 != -1) {
    dispatch_once(&qword_1008D9298, &stru_1008A4118);
  }
  sub_10040D074(qword_1008D9290, (uint64_t)&v93);
  if (*(_BYTE *)(a1 + 4386))
  {
    id v13 = (os_log_s *)qword_1008F75B8;
    if (os_log_type_enabled((os_log_t)qword_1008F75B8, OS_LOG_TYPE_ERROR))
    {
      sub_100494958(a2, (uint64_t)&buf);
      int v71 = SHIBYTE(v101);
      p___int128 buf = (__int128 *)buf;
      uint64_t v73 = v91;
      sub_100494E68(a2, v91);
      if (v71 >= 0) {
        p___int128 buf = &buf;
      }
      if (v92 < 0) {
        uint64_t v73 = (void **)v91[0];
      }
      uint64_t v74 = sub_1005E2B18(*(_DWORD *)(*(void *)(v81 + 8) + 168LL));
      *(_DWORD *)std::stringbuf::string_type __p = 136446722;
      *(void *)&__p[4] = p_buf;
      *(_WORD *)&_BYTE __p[12] = 2082;
      *(void *)&__p[14] = v73;
      *(_WORD *)&__p[22] = 2082;
      uint64_t v97 = v74;
      _os_log_error_impl( (void *)&_mh_execute_header,  v13,  OS_LOG_TYPE_ERROR,  "WILLSLEEP violation! Session %{public}s(%{public}s) %{public}s asking to stop scan",  __p,  0x20u);
      if (v92 < 0) {
        operator delete(v91[0]);
      }
      if (SHIBYTE(v101) < 0) {
        operator delete((void *)buf);
      }
    }
  }

  id v14 = sub_100611384(v81);
  char v15 = (void *)objc_claimAutoreleasedReturnValue(v14);
  uint64_t v16 = (void *)objc_claimAutoreleasedReturnValue([v15 cuFilteredArrayUsingBlock:&stru_1008A3AF8]);
  uint64_t v78 = (void *)objc_claimAutoreleasedReturnValue(+[NSMutableSet setWithArray:](&OBJC_CLASS___NSMutableSet, "setWithArray:", v16));

  if (sub_100611378(v81))
  {
    int v17 = +[NSNumber numberWithUnsignedInt:](&OBJC_CLASS___NSNumber, "numberWithUnsignedInt:", sub_100611378(v81));
    uint64_t v18 = (void *)objc_claimAutoreleasedReturnValue(v17);
    [v78 addObject:v18];
  }

  uint64_t v80 = a1;
  __int128 v89 = 0u;
  __int128 v90 = 0u;
  __int128 v87 = 0u;
  __int128 v88 = 0u;
  id v19 = v78;
  id v20 = [v19 countByEnumeratingWithState:&v87 objects:v99 count:16];
  if (v20)
  {
    uint64_t v21 = *(void *)v88;
    do
    {
      uint64_t v22 = 0LL;
      do
      {
        if (*(void *)v88 != v21) {
          objc_enumerationMutation(v19);
        }
        int v23 = *(void **)(*((void *)&v87 + 1) + 8LL * (void)v22);
        if (qword_1008D6198 != -1) {
          dispatch_once(&qword_1008D6198, &stru_1008A4058);
        }
        sub_10044D74C((uint64_t)off_1008D6190, [v23 longLongValue]);
        uint64_t v22 = (char *)v22 + 1;
      }

      while (v20 != v22);
      id v20 = [v19 countByEnumeratingWithState:&v87 objects:v99 count:16];
    }

    while (v20);
  }

  if (sub_100610D74(v81)) {
    *(_BYTE *)(v80 + 1843) = 1;
  }
  if (sub_100610D98(v81)) {
    *(_BYTE *)(v80 + 1845) = 1;
  }
  if (sub_100611258(v81)) {
    *(_BYTE *)(v80 + 1844) = 1;
  }
  BOOL v24 = (void *)sub_100610E3C(v81);
  if (v24[1] != *v24 || sub_100610DB8(v81)) {
    *(_BYTE *)(v80 + 1846) = 1;
  }
  if (sub_100611304(v81)) {
    *(_BYTE *)(v80 + 1847) = 1;
  }
  uint64_t v25 = *(void *)(v81 + 8);
  uint64_t v27 = *(void *)(v25 + 64);
  uint64_t v26 = *(void *)(v25 + 72);
  if (v27 != v26)
  {
    do
    {
      if (*(_BYTE *)(v27 + 64))
      {
        int v28 = *(unsigned __int8 *)(v27 + 8);
        int v29 = sub_1005E78AC(v80, v28);
        if ((v29 & 0xFFFFFFFD) != 0)
        {
          int64_t v30 = (os_log_s *)qword_1008F75B8;
          if (os_log_type_enabled((os_log_t)qword_1008F75B8, OS_LOG_TYPE_ERROR))
          {
            *(_DWORD *)std::stringbuf::string_type __p = 67109376;
            *(_DWORD *)&__p[4] = v28;
            *(_WORD *)&__p[8] = 1024;
            *(_DWORD *)&__p[10] = v29;
            _os_log_error_impl( (void *)&_mh_execute_header,  v30,  OS_LOG_TYPE_ERROR,  "Failed to destroy a match table for type %d with error %d",  __p,  0xEu);
          }
        }
      }

      v27 += 96LL;
    }

    while (v27 != v26);
    uint64_t v25 = *(void *)(v81 + 8);
  }

  if (*(_BYTE *)(v25 + 143))
  {
    int v31 = (os_log_s *)qword_1008F76D8;
    if (os_log_type_enabled((os_log_t)qword_1008F76D8, OS_LOG_TYPE_DEFAULT))
    {
      sub_100494958(a2, (uint64_t)__p);
      int v32 = __p[23] >= 0 ? __p : *(_BYTE **)__p;
      LODWORD(buf) = 136446210;
      *(void *)((char *)&buf + 4) = v32;
      _os_log_impl( (void *)&_mh_execute_header,  v31,  OS_LOG_TYPE_DEFAULT,  "session %{public}s no longer needs to do Exposure Notification",  (uint8_t *)&buf,  0xCu);
      if ((__p[23] & 0x80000000) != 0) {
        operator delete(*(void **)__p);
      }
    }

    sub_1005E569C((dispatch_object_t *)v80);
    *(void *)(v80 + 2280) = 0LL;
    *(_OWORD *)(v80 + 2296) = 0u;
    *(_OWORD *)(v80 + 2312) = 0u;
    *(_OWORD *)(v80 + 2328) = 0u;
    if (*(_BYTE *)(v80 + 1255)) {
      sub_1005E3ED4(v80, 2LL);
    }
  }

  BOOL v33 = *(_DWORD *)(v80 + 1964) != 2 || *(_BYTE *)(*(void *)(v81 + 8) + 3LL) != 0;
  uint64_t v34 = sub_1002E6BF0();
  uint64_t v35 = (*(uint64_t (**)(uint64_t))(*(void *)v34 + 824LL))(v34);
  if (byte_1008F1E9D) {
    int v36 = 0;
  }
  else {
    int v36 = v35;
  }
  if (v36 != 1)
  {
    BOOL v38 = 0LL;
LABEL_77:
    uint64_t v41 = 0LL;
    goto LABEL_78;
  }

  if (qword_1008D6198 != -1) {
    dispatch_once(&qword_1008D6198, &stru_1008A4058);
  }
  int v37 = sub_1004494F0();
  BOOL v38 = (v37 & 0xFFFFFFFD) != 1;
  if ((sub_1005F4430(v80, v81) & 1) == 0 && !*(_BYTE *)(*(void *)(v81 + 8) + 200LL)
    || v37 == 2 && (uint64_t v39 = sub_1002E6E9C(), !(*(unsigned int (**)(uint64_t))(*(void *)v39 + 2648LL))(v39)))
  {
    BOOL v38 = 0LL;
  }

  if (!byte_1008F1E9E)
  {
    uint64_t v35 = sub_1005F4684(v80, v81);
    if (!(_DWORD)v35) {
      goto LABEL_77;
    }
  }

  uint64_t v40 = sub_1002E6E9C();
  uint64_t v35 = (*(uint64_t (**)(uint64_t))(*(void *)v40 + 2656LL))(v40);
  uint64_t v41 = v35 | v38;
LABEL_78:
  int v86 = 0;
  if (sub_1005F3D88(v35, v81, &v86))
  {
    v84[0] = _NSConcreteStackBlock;
    v84[1] = 3221225472LL;
    v84[2] = sub_1005F48D8;
    v84[3] = &unk_1008A3AB8;
    int v85 = v86;
    sub_1005EBB90((os_unfair_lock_s *)(v80 + 1872), v84);
  }

  sub_1005F3FAC(v80, a2, v38, v41);
  if ((a5 & 1) != 0) {
    goto LABEL_101;
  }
  uint64_t v42 = *(void *)(v81 + 8);
  if (!*(_DWORD *)(v42 + 188) && !*(_DWORD *)(v42 + 192)) {
    goto LABEL_101;
  }
  if (!*(_BYTE *)(v42 + 196)) {
    goto LABEL_101;
  }
  __int128 buf = 0uLL;
  unsigned int v101 = 0LL;
  v83[0] = _NSConcreteStackBlock;
  v83[1] = 3221225472LL;
  void v83[2] = sub_1005F48F4;
  v83[3] = &unk_1008A3B18;
  _OWORD v83[4] = v80;
  uint64_t v43 = objc_retainBlock(v83);
  uint64_t v44 = v43;
  uint64_t v45 = *((void *)&buf + 1);
  if (*((void *)&buf + 1) >= (unint64_t)v101)
  {
    unint64_t v47 = 0xCCCCCCCCCCCCCCCDLL * ((uint64_t)(*((void *)&buf + 1) - buf) >> 3);
    unint64_t v48 = v47 + 1;
    if (v47 + 1 > 0x666666666666666LL) {
      abort();
    }
    unint64_t v49 = 0xCCCCCCCCCCCCCCCDLL * ((uint64_t)&v101[-buf] >> 3) >= 0x333333333333333LL ? 0x666666666666666LL : v48;
    v98[0] = &v101;
    int v50 = (char *)sub_1001FDA44((uint64_t)&v101, v49);
    BOOL v52 = &v50[40 * v47];
    *((void *)v52 + 1) = 0LL;
    *((void *)v52 + 2) = 0LL;
    *(void *)BOOL v52 = a2;
    *((_DWORD *)v52 + 6) = 0;
    *((void *)v52 + 4) = v44;
    uint64_t v53 = *((void *)&buf + 1);
    uint64_t v54 = buf;
    if (*((void *)&buf + 1) == (void)buf)
    {
      uint64_t v54 = *((void *)&buf + 1);
      int v56 = &v50[40 * v47];
    }

    else
    {
      uint64_t v55 = *((void *)&buf + 1);
      int v56 = &v50[40 * v47];
      do
      {
        __int128 v57 = *(_OWORD *)(v55 - 40);
        *(_OWORD *)(v56 - 28) = *(_OWORD *)(v55 - 28);
        *(_OWORD *)(v56 - 40) = v57;
        uint64_t v58 = *(void *)(v55 - 8);
        *(void *)(v55 - 8) = 0LL;
        *((void *)v56 - 1) = v58;
        v56 -= 40;
        v55 -= 40LL;
      }

      while (v55 != v54);
    }

    int v46 = v52 + 40;
    *(void *)&__int128 buf = v56;
    *((void *)&buf + 1) = v52 + 40;
    uint64_t v59 = v101;
    unsigned int v101 = &v50[40 * v51];
    *(void *)&__p[16] = v53;
    uint64_t v97 = v59;
    *(void *)std::stringbuf::string_type __p = v54;
    *(void *)&__p[8] = v54;
    sub_10060F6AC((uint64_t)__p);
  }

  else
  {
    *(void *)(*((void *)&buf + 1) + 8LL) = 0LL;
    *(void *)(v45 + 16) = 0LL;
    *(void *)uint64_t v45 = a2;
    *(_DWORD *)(v45 + 24) = 0;
    int v46 = (char *)(v45 + 40);
    *(void *)(v45 + 32) = v43;
  }

  *((void *)&buf + 1) = v46;
  if (qword_1008D6198 != -1) {
    dispatch_once(&qword_1008D6198, &stru_1008A4058);
  }
  BOOL v60 = off_1008D6190;
  memset(v82, 0, sizeof(v82));
  sub_10060F6FC( v82,  (__int128 *)buf,  *((__int128 **)&buf + 1),  0xCCCCCCCCCCCCCCCDLL * ((uint64_t)(*((void *)&buf + 1) - buf) >> 3));
  sub_10044B9F8((uint64_t)v60, v82);
  *(void *)std::stringbuf::string_type __p = v82;
  sub_10060F638((void ***)__p);
  *(void *)std::stringbuf::string_type __p = &buf;
  sub_10060F638((void ***)__p);
  if (v81) {
LABEL_101:
  }
    (*(void (**)(uint64_t))(*(void *)v81 + 8LL))(v81);
  int v61 = v33 & a3;
  sub_1001FDBCC(v76, v8);
  operator delete(v8);
  uint64_t v62 = (os_log_s *)qword_1008F75B8;
  if (os_log_type_enabled((os_log_t)qword_1008F75B8, OS_LOG_TYPE_DEFAULT))
  {
    sub_100494958(a2, (uint64_t)&buf);
    int v63 = SHIBYTE(v101);
    uint64_t v64 = (__int128 *)buf;
    sub_100494E68(a2, v91);
    size_t v65 = &buf;
    if (v63 < 0) {
      size_t v65 = v64;
    }
    uint64_t v66 = (void **)v91[0];
    id v67 = "NO";
    if (v92 >= 0) {
      uint64_t v66 = v91;
    }
    *(_DWORD *)std::stringbuf::string_type __p = 136446978;
    *(void *)&__p[4] = v65;
    if (a3) {
      uint64_t v68 = "YES";
    }
    else {
      uint64_t v68 = "NO";
    }
    *(_WORD *)&_BYTE __p[12] = 2082;
    *(void *)&__p[14] = v66;
    if (v61) {
      id v67 = "YES";
    }
    *(_WORD *)&__p[22] = 2082;
    uint64_t v97 = v68;
    LOWORD(v98[0]) = 2082;
    *(void *)((char *)v98 + 2) = v67;
    _os_log_impl( (void *)&_mh_execute_header,  v62,  OS_LOG_TYPE_DEFAULT,  "Received 'stop scan' request from session %{public}s (%{public}s) updateScanParams:%{public}s shouldUpdateState:%{public}s",  __p,  0x2Au);
    if (v92 < 0) {
      operator delete(v91[0]);
    }
    if (SHIBYTE(v101) < 0) {
      operator delete((void *)buf);
    }
  }

  if (!sub_1005EBF48(v80)
    && a4
    && (_os_feature_enabled_impl("BluetoothFeatures", "SentinelNewLocationFeatures") & 1) == 0)
  {
    id v69 = (os_log_s *)qword_1008F75B8;
    if (os_log_type_enabled((os_log_t)qword_1008F75B8, OS_LOG_TYPE_DEFAULT))
    {
      *(_WORD *)std::stringbuf::string_type __p = 0;
      _os_log_impl((void *)&_mh_execute_header, v69, OS_LOG_TYPE_DEFAULT, "ADVBUFF Legacy mode", __p, 2u);
    }

    if (!sub_1005EBF48(v80))
    {
      sub_1005E3ED4(v80, 0LL);
      sub_1005E3ED4(v80, 1LL);
      sub_1005EBFB4(v80);
    }
  }

  if ((v61 & 1) != 0)
  {
    *(_BYTE *)(v80 + 1840) = 1;
    sub_1005E3C94(v80, 0);
  }

  else
  {
    id v70 = (os_log_s *)qword_1008F75B8;
    if (os_log_type_enabled((os_log_t)qword_1008F75B8, OS_LOG_TYPE_DEFAULT))
    {
      *(_WORD *)std::stringbuf::string_type __p = 0;
      _os_log_impl((void *)&_mh_execute_header, v70, OS_LOG_TYPE_DEFAULT, "Not updating state", __p, 2u);
    }
  }

  if (SHIBYTE(v94) < 0) {
    operator delete(*((void **)&v93 + 1));
  }
  return 0LL;
}

void sub_1005F3030( _Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, void *a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20, uint64_t a21, uint64_t a22, uint64_t a23, uint64_t a24, uint64_t a25, uint64_t a26, uint64_t a27, uint64_t a28, uint64_t a29, uint64_t a30, uint64_t a31, uint64_t a32, uint64_t a33, uint64_t a34, uint64_t a35, uint64_t a36, uint64_t a37, uint64_t a38, uint64_t a39, uint64_t a40, uint64_t a41, uint64_t a42, uint64_t a43, void *__p, uint64_t a45, int a46, __int16 a47, char a48, char a49, uint64_t a50,uint64_t a51,uint64_t a52,uint64_t a53,int a54,__int16 a55,char a56,char a57)
{
  a40 = v57 - 128;
  sub_10060F638((void ***)&a40);

  if (a49 < 0) {
    operator delete(__p);
  }
  _Unwind_Resume(a1);
}

uint64_t sub_1005F313C(uint64_t a1, uint64_t a2)
{
  if (a2 >= 3)
  {
    unint64_t v3 = (os_log_s *)qword_1008F75B8;
    if (os_log_type_enabled((os_log_t)qword_1008F75B8, OS_LOG_TYPE_DEFAULT))
    {
      *(_DWORD *)__int128 buf = 67109120;
      LODWORD(v39) = a2;
      _os_log_impl( (void *)&_mh_execute_header,  v3,  OS_LOG_TYPE_DEFAULT,  "HW ADV Buffer handle out of range (%d), ignoring agent request",  buf,  8u);
    }

    return 7LL;
  }

  uint64_t v6 = sub_1002E6BF0();
  if (!(*(unsigned int (**)(uint64_t))(*(void *)v6 + 704LL))(v6))
  {
    id v13 = (os_log_s *)qword_1008F75B8;
    if (os_log_type_enabled((os_log_t)qword_1008F75B8, OS_LOG_TYPE_DEFAULT))
    {
      else {
        id v14 = off_1008A4258[(char)a2];
      }
      *(_DWORD *)__int128 buf = 138543362;
      uint64_t v39 = v14;
      uint64_t v18 = "HW ADV for %{public}@ not supported on this hardware, ignoring agent request";
      goto LABEL_23;
    }

    return 11LL;
  }

  if ((_DWORD)a2 == 2)
  {
    uint64_t v7 = sub_1002E6E9C();
    if (((*(uint64_t (**)(uint64_t))(*(void *)v7 + 2320LL))(v7) & 1) == 0)
    {
      id v13 = (os_log_s *)qword_1008F75B8;
      if (os_log_type_enabled((os_log_t)qword_1008F75B8, OS_LOG_TYPE_DEFAULT))
      {
        *(_DWORD *)__int128 buf = 138543362;
        uint64_t v39 = @"EN";
        uint64_t v18 = "HW ADV Buffers for %{public}@ not supported on this hardware, ignoring agent request";
LABEL_23:
        _os_log_impl((void *)&_mh_execute_header, v13, OS_LOG_TYPE_DEFAULT, v18, buf, 0xCu);
        return 11LL;
      }

      return 11LL;
    }
  }

  uint64_t v8 = a1 + 544LL * a2;
  int v10 = *(unsigned __int8 *)(v8 + 167);
  unint64_t v9 = (_BYTE *)(v8 + 167);
  if (v10)
  {
    uint64_t v11 = (os_log_s *)qword_1008F75B8;
    if (!os_log_type_enabled((os_log_t)qword_1008F75B8, OS_LOG_TYPE_INFO)) {
      return 12LL;
    }
    else {
      int v12 = off_1008A4258[(char)a2];
    }
    *(_DWORD *)__int128 buf = 138543362;
    uint64_t v39 = v12;
    uint64_t v4 = 12LL;
    _os_log_impl((void *)&_mh_execute_header, v11, OS_LOG_TYPE_INFO, "ADVBUFF(%{public}@): already created", buf, 0xCu);
    return v4;
  }

  unsigned int v15 = a2;
  __int16 v37 = 0;
  int v36 = 0;
  uint64_t v16 = (os_log_s *)qword_1008F75B8;
  if (os_log_type_enabled((os_log_t)qword_1008F75B8, OS_LOG_TYPE_INFO))
  {
    else {
      int v17 = off_1008A4258[(char)a2];
    }
    *(_DWORD *)__int128 buf = 138543362;
    uint64_t v39 = v17;
    _os_log_impl( (void *)&_mh_execute_header,  v16,  OS_LOG_TYPE_INFO,  "ADVBUFF(%{public}@): sending advBufConfig",  buf,  0xCu);
  }

  uint64_t v19 = sub_1002E6E9C();
  uint64_t v20 = a1 + 544LL * a2;
  uint64_t v4 = (*(uint64_t (**)(uint64_t, uint64_t, void, int *, void, void, void, void, _BYTE))(*(void *)v19 + 2776LL))( v19,  a2,  *(v9 - 7),  &v36,  *(unsigned __int8 *)(v20 + 161),  *(unsigned __int16 *)(v20 + 162),  *(unsigned __int8 *)(v20 + 164),  *(unsigned __int8 *)(v20 + 165),  *(_BYTE *)(v20 + 166));
  uint64_t v21 = (os_log_s *)qword_1008F75B8;
  if (os_log_type_enabled((os_log_t)qword_1008F75B8, OS_LOG_TYPE_INFO))
  {
    else {
      uint64_t v22 = off_1008A4258[(char)a2];
    }
    *(_DWORD *)__int128 buf = 138543618;
    uint64_t v39 = v22;
    __int16 v40 = 1024;
    int v41 = v4;
    _os_log_impl( (void *)&_mh_execute_header,  v21,  OS_LOG_TYPE_INFO,  "ADVBUFF(%{public}@): ADVBufConfig returned %d",  buf,  0x12u);
  }

  if ((_DWORD)v4)
  {
    if (os_log_type_enabled((os_log_t)qword_1008F75B8, OS_LOG_TYPE_ERROR)) {
      sub_10069CA28();
    }
    return v4;
  }

  uint64_t v23 = *(void *)sub_1002E6E9C();
  if (a2 <= 1)
  {
    int v24 = (*(uint64_t (**)(void))(v23 + 2312))();
    if (v24)
    {
      char v25 = v24;
      unint64_t v26 = 0LL;
      uint64_t v4 = 0LL;
      uint64_t v27 = a1 + 544LL * a2 + 228;
      do
      {
        if (*(_WORD *)(v27 - 34))
        {
          uint64_t v28 = sub_1002E6E9C();
          BYTE2(v35) = *(_BYTE *)(v27 - 28);
          LOWORD(v35) = *(_WORD *)(v27 - 30);
          uint64_t v4 = (*(uint64_t (**)(uint64_t, uint64_t, void, int *, void, void, void, void, int, uint64_t, uint64_t))(*(void *)v28 + 2784LL))( v28,  a2,  *(unsigned __int8 *)(v27 - 36),  &v36,  *(unsigned __int8 *)(v27 - 35),  *(unsigned __int16 *)(v27 - 34),  *(unsigned __int8 *)(v27 - 32),  *(unsigned __int8 *)(v27 - 31),  v35,  v27 - 27,  v27);
          if ((_DWORD)v4)
          {
            int v29 = (os_log_s *)qword_1008F75B8;
            if (os_log_type_enabled((os_log_t)qword_1008F75B8, OS_LOG_TYPE_ERROR))
            {
              int64_t v30 = off_1008A4258[(char)a2];
              *(_DWORD *)__int128 buf = 138543618;
              uint64_t v39 = v30;
              __int16 v40 = 1024;
              int v41 = v4;
              _os_log_error_impl( (void *)&_mh_execute_header,  v29,  OS_LOG_TYPE_ERROR,  "ADVBUFF(%{public}@): Failed to configure ext buffer adv rule: %d",  buf,  0x12u);
            }
          }

          else
          {
            --v25;
          }
        }

        if (v26 > 6) {
          break;
        }
        ++v26;
        v27 += 64LL;
      }

      while (v25);
    }

    else
    {
      uint64_t v4 = 0LL;
    }

void sub_1005F377C(uint64_t a1)
{
  if (!*(void *)(a1 + 2256))
  {
    *(_BYTE *)(a1 + 2288) = 0;
    if (qword_1008D9700 != -1) {
      dispatch_once(&qword_1008D9700, &stru_1008A40D8);
    }
    uint64_t v2 = sub_1003AC908((uint64_t)off_1008D96F8);
    unint64_t v3 = (os_log_s *)qword_1008F76D8;
    if (os_log_type_enabled((os_log_t)qword_1008F76D8, OS_LOG_TYPE_DEFAULT))
    {
      *(_DWORD *)__int128 buf = 134217984;
      uint64_t v12 = v2;
      _os_log_impl( (void *)&_mh_execute_header,  v3,  OS_LOG_TYPE_DEFAULT,  "fContactTracingScanDurationTimer Timer %llu ms Armed!",  buf,  0xCu);
    }

    sub_100600300(a1);
    sub_1006005B0(a1);
    if (qword_1008D9700 != -1) {
      dispatch_once(&qword_1008D9700, &stru_1008A40D8);
    }
    sub_1003AC110();
    uint64_t v4 = sub_100404FE8();
    v10[0] = _NSConcreteStackBlock;
    v10[1] = 3221225472LL;
    _DWORD v10[2] = sub_100600B00;
    v10[3] = &unk_10087F8E0;
    void v10[4] = a1;
    void v10[5] = v2;
    sub_100405384(v4, v10);
    uint64_t v5 = sub_100404FE8();
    uint64_t v6 = dispatch_source_create( (dispatch_source_type_t)&_dispatch_source_type_timer,  0LL,  0LL,  *(dispatch_queue_t *)(v5 + 8));
    *(void *)(a1 + 2256) = v6;
    handler[0] = _NSConcreteStackBlock;
    handler[1] = 3221225472LL;
    handler[2] = sub_100600BA8;
    handler[3] = &unk_10087EB20;
    handler[4] = a1;
    dispatch_source_set_event_handler(v6, handler);
    uint64_t v7 = *(dispatch_source_s **)(a1 + 2256);
    dispatch_time_t v8 = dispatch_time(0x8000000000000000LL, 1000000 * v2);
    dispatch_source_set_timer(v7, v8, 0xFFFFFFFFFFFFFFFFLL, 0LL);
    dispatch_activate(*(dispatch_object_t *)(a1 + 2256));
  }

BOOL sub_1005F396C(uint64_t a1)
{
  uint64_t v1 = *(void **)(a1 + 2040);
  uint64_t v2 = (void *)(a1 + 2048);
  if (v1 == (void *)(a1 + 2048)) {
    return 0LL;
  }
  do
  {
    BOOL result = *(_BYTE *)(*(void *)(v1[5] + 8LL) + 143LL) != 0;
    if (*(_BYTE *)(*(void *)(v1[5] + 8LL) + 143LL)) {
      break;
    }
    uint64_t v4 = (void *)v1[1];
    if (v4)
    {
      do
      {
        uint64_t v5 = v4;
        uint64_t v4 = (void *)*v4;
      }

      while (v4);
    }

    else
    {
      do
      {
        uint64_t v5 = (void *)v1[2];
        BOOL v6 = *v5 == (void)v1;
        uint64_t v1 = v5;
      }

      while (!v6);
    }

    uint64_t v1 = v5;
  }

  while (v5 != v2);
  return result;
}

void sub_1005F39D8(uint64_t a1, uint64_t a2, uint64_t a3)
{
  uint64_t v5 = sub_1002E6BF0();
  if (((*(uint64_t (**)(uint64_t))(*(void *)v5 + 384LL))(v5) & 1) == 0)
  {
    uint64_t v6 = *(void *)(a3 + 8);
    if (!*(_BYTE *)(v6 + 137))
    {
      if (*(_BYTE *)(v6 + 143))
      {
        uint64_t v7 = (os_log_s *)qword_1008F76D8;
        if (os_log_type_enabled((os_log_t)qword_1008F76D8, OS_LOG_TYPE_INFO))
        {
          *(_WORD *)int v10 = 0;
          _os_log_impl( (void *)&_mh_execute_header,  v7,  OS_LOG_TYPE_INFO,  "ExposureNotification client does not have a decay timer",  v10,  2u);
        }
      }

      else
      {
        dispatch_time_t v8 = operator new(0x20uLL);
        v8[4] = 1;
        *(void *)dispatch_time_t v8 = &off_1008A3FD0;
        *((void *)v8 + 2) = *((unsigned int *)&unk_1006C4714 + *(int *)(a3 + 96) - 1);
        *((void *)v8 + 3) = a2;
        *(void *)(a3 + 88) = v8;
        uint64_t v9 = sub_100404FE8();
        sub_100405744(v9, v8);
      }
    }
  }

uint64_t sub_1005F3AD0(uint64_t a1, uint64_t a2, int a3)
{
  unsigned __int16 v21 = 0;
  uint64_t v6 = sub_1005FBD08(a1, a2, 1, &v21);
  if ((_DWORD)v6)
  {
    uint64_t v7 = v6;
    if (os_log_type_enabled((os_log_t)qword_1008F75B8, OS_LOG_TYPE_ERROR)) {
      sub_10069CB18();
    }
  }

  else
  {
    dispatch_time_t v8 = (uint64_t **)(a1 + 1816);
    uint64_t v9 = v21;
    unsigned __int8 v22 = v21;
    *(void *)__int128 buf = &v22;
    int v10 = sub_10060F298(v8, &v22, (uint64_t)&unk_1006C2518, (char **)buf);
    char v11 = *((_BYTE *)v10 + 29);
    __int16 v12 = *((_WORD *)v10 + 15);
    id v13 = (os_log_s *)qword_1008F75B8;
    if (os_log_type_enabled((os_log_t)qword_1008F75B8, OS_LOG_TYPE_DEFAULT))
    {
      *(_DWORD *)__int128 buf = 67109632;
      *(_DWORD *)&uint8_t buf[4] = v9;
      *(_WORD *)&uint8_t buf[8] = 1024;
      *(_DWORD *)&buf[10] = a2;
      *(_WORD *)&buf[14] = 1024;
      LODWORD(v25) = a3;
      _os_log_impl( (void *)&_mh_execute_header,  v13,  OS_LOG_TYPE_DEFAULT,  "Creating a match table with handle %x for type %d and mask: %d",  buf,  0x14u);
    }

    uint64_t v14 = sub_1002E6E9C();
    uint64_t v7 = (*(uint64_t (**)(uint64_t, uint64_t, uint64_t, uint64_t, uint64_t, uint64_t, void, uint64_t, _BYTE, void, char, void, void, _BYTE))(*(void *)v14 + 2816LL))( v14,  v9,  7LL,  255LL,  76LL,  a2,  0LL,  1LL,  0,  0LL,  16,  0LL,  0LL,  0);
    if (!(_DWORD)v7)
    {
      __int128 v36 = 0u;
      memset(v37, 0, sizeof(v37));
      __int128 v34 = 0u;
      __int128 v35 = 0u;
      __int128 v32 = 0u;
      __int128 v33 = 0u;
      __int128 v30 = 0u;
      __int128 v31 = 0u;
      __int128 v28 = 0u;
      __int128 v29 = 0u;
      __int128 v26 = 0u;
      __int128 v27 = 0u;
      *(_OWORD *)__int128 buf = 0u;
      __int128 v25 = 0u;
      buf[6] = 2;
      uint64_t v15 = sub_1002E6E9C();
      uint64_t v16 = (*(uint64_t (**)(uint64_t, uint64_t, void, void, uint8_t *))(*(void *)v15 + 2864LL))( v15,  v9,  0LL,  0LL,  buf);
      if ((_DWORD)v16)
      {
        uint64_t v7 = v16;
        if (os_log_type_enabled((os_log_t)qword_1008F75B8, OS_LOG_TYPE_ERROR)) {
          sub_10069C248();
        }
      }

      else
      {
        unsigned __int8 v20 = v12;
        uint64_t v23 = (char *)&v20;
        int v17 = sub_10060F298(v8, &v20, (uint64_t)&unk_1006C2518, &v23);
        *((_BYTE *)v17 + 28) = a2;
        *((_BYTE *)v17 + 29) = v11;
        *((_WORD *)v17 + 15) = v12;
        *((_DWORD *)v17 + 8) = 65537;
        *((_WORD *)v17 + 18) = 1;
        *((_WORD *)v17 + 19) = a3;
        uint64_t v18 = sub_1002E6E9C();
        uint64_t v7 = (*(uint64_t (**)(uint64_t, uint64_t, uint64_t, void))(*(void *)v18 + 2840LL))(v18, v9, 1LL, 0LL);
        if ((_DWORD)v7 && os_log_type_enabled((os_log_t)qword_1008F75B8, OS_LOG_TYPE_ERROR)) {
          sub_10069CAB8();
        }
      }
    }
  }

  return v7;
}

uint64_t sub_1005F3D88(uint64_t a1, uint64_t a2, _DWORD *a3)
{
  uint64_t v5 = sub_1002E6BF0();
  int v6 = (*(uint64_t (**)(uint64_t))(*(void *)v5 + 960LL))(v5);
  uint64_t v7 = 0LL;
  if (a2 && v6)
  {
    if (*(void *)(a2 + 8))
    {
      id v8 = sub_100611384(a2);
      uint64_t v9 = (void *)objc_claimAutoreleasedReturnValue(v8);
      if (sub_100611378(a2) == 589824)
      {
        *a3 = sub_100611378(a2);
LABEL_6:
        uint64_t v7 = 1LL;
      }

      else
      {
        if (v9 && [v9 count])
        {
          __int128 v18 = 0u;
          __int128 v19 = 0u;
          __int128 v16 = 0u;
          __int128 v17 = 0u;
          id v10 = v9;
          id v11 = [v10 countByEnumeratingWithState:&v16 objects:v20 count:16];
          if (v11)
          {
            uint64_t v12 = *(void *)v17;
            while (2)
            {
              for (uint64_t i = 0LL; i != v11; uint64_t i = (char *)i + 1)
              {
                if (*(void *)v17 != v12) {
                  objc_enumerationMutation(v10);
                }
                uint64_t v14 = *(void **)(*((void *)&v16 + 1) + 8LL * (void)i);
                if (objc_msgSend(v14, "longLongValue", (void)v16) == 589824)
                {
                  *a3 = [v14 longLongValue];

                  goto LABEL_6;
                }
              }

              id v11 = [v10 countByEnumeratingWithState:&v16 objects:v20 count:16];
              if (v11) {
                continue;
              }
              break;
            }
          }
        }

        uint64_t v7 = 0LL;
      }
    }

    else
    {
      return 0LL;
    }
  }

  return v7;
}

void sub_1005F3F18(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

uint64_t sub_1005F3F44(uint64_t a1, uint64_t a2)
{
  return (*(uint64_t (**)(uint64_t, void, uint64_t))(*(void *)a2 + 72LL))( a2,  *(unsigned int *)(a1 + 32),  1LL);
}

id sub_1005F3F60(id a1, NSNumber *a2)
{
  uint64_t v2 = a2;
  else {
    unint64_t v3 = v2;
  }
  uint64_t v4 = v3;

  return v4;
}

void sub_1005F3F9C(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_1005F3FAC(uint64_t a1, unint64_t a2, uint64_t a3, uint64_t a4)
{
  uint64_t v5 = *(void **)(a1 + 2048);
  if (!v5) {
    goto LABEL_12;
  }
  id v8 = (void *)(a1 + 2048);
  do
  {
    unint64_t v9 = v5[4];
    BOOL v10 = v9 >= a2;
    if (v9 >= a2) {
      id v11 = v5;
    }
    else {
      id v11 = v5 + 1;
    }
    if (v10) {
      id v8 = v5;
    }
    uint64_t v5 = (void *)*v11;
  }

  while (*v11);
  if (v8 != (void *)(a1 + 2048) && v8[4] <= a2)
  {
    id v17 = sub_100616AD0(v8[5]);
    __int128 v18 = (void *)objc_claimAutoreleasedReturnValue(v17);
    __int128 v19 = (void *)objc_claimAutoreleasedReturnValue( +[NSMutableDictionary dictionaryWithDictionary:]( &OBJC_CLASS___NSMutableDictionary,  "dictionaryWithDictionary:",  v18));

    unsigned __int8 v20 = (void *)objc_claimAutoreleasedReturnValue(+[NSNumber numberWithUnsignedInt:](&OBJC_CLASS___NSNumber, "numberWithUnsignedInt:", 0LL));
    [v19 setObject:v20 forKeyedSubscript:@"DASessionType"];

    if (qword_1008D67C8 != -1) {
      dispatch_once(&qword_1008D67C8, &stru_1008A4018);
    }
    if (sub_100279D80((uint64_t)off_1008D67C0, a2))
    {
      if (qword_1008D67C8 != -1) {
        dispatch_once(&qword_1008D67C8, &stru_1008A4018);
      }
      BOOL v21 = sub_10028EEDC((uint64_t)off_1008D67C0, a2);
    }

    else
    {
      BOOL v21 = 0LL;
    }

    unsigned __int8 v22 = (void *)objc_claimAutoreleasedReturnValue(+[NSNumber numberWithBool:](&OBJC_CLASS___NSNumber, "numberWithBool:", v21));
    [v19 setObject:v22 forKeyedSubscript:@"SupportsStateRestoration"];

    uint64_t v23 = (void *)objc_claimAutoreleasedReturnValue( +[NSNumber numberWithUnsignedInt:]( &OBJC_CLASS___NSNumber,  "numberWithUnsignedInt:",  *(unsigned int *)(a2 + 140)));
    [v19 setObject:v23 forKeyedSubscript:@"ClientType"];

    int v24 = (void *)objc_claimAutoreleasedReturnValue(+[NSNumber numberWithBool:](&OBJC_CLASS___NSNumber, "numberWithBool:", a3));
    [v19 setObject:v24 forKeyedSubscript:@"IsPrioritizedOverBT"];

    __int128 v25 = (void *)objc_claimAutoreleasedReturnValue(+[NSNumber numberWithBool:](&OBJC_CLASS___NSNumber, "numberWithBool:", a4));
    [v19 setObject:v25 forKeyedSubscript:@"IsPrioritizedOverWiFi"];

    __int128 v37 = 0u;
    __int128 v38 = 0u;
    __int128 v35 = 0u;
    __int128 v36 = 0u;
    id v26 = *(id *)(*(void *)(v8[5] + 8LL) + 152LL);
    id v27 = [v26 countByEnumeratingWithState:&v35 objects:v43 count:16];
    if (v27)
    {
      uint64_t v28 = *(void *)v36;
      do
      {
        for (uint64_t i = 0LL; i != v27; uint64_t i = (char *)i + 1)
        {
          if (*(void *)v36 != v28) {
            objc_enumerationMutation(v26);
          }
          [v19 setObject:*(void *)(*((void *)&v35 + 1) + 8 * (void)i) forKeyedSubscript:@"BundleID"];
          uint64_t v30 = sub_1002E8D94();
          (*(void (**)(uint64_t, void *))(*(void *)v30 + 304LL))(v30, v19);
        }

        id v27 = [v26 countByEnumeratingWithState:&v35 objects:v43 count:16];
      }

      while (v27);
    }
  }

  else
  {
LABEL_12:
    uint64_t v12 = (os_log_s *)qword_1008F75B8;
    if (os_log_type_enabled((os_log_t)qword_1008F75B8, OS_LOG_TYPE_DEFAULT))
    {
      sub_100494958(a2, (uint64_t)v33);
      int v13 = v34;
      uint64_t v14 = (void **)v33[0];
      sub_100494E68(a2, __p);
      uint64_t v15 = v33;
      if (v13 < 0) {
        uint64_t v15 = v14;
      }
      if (v32 >= 0) {
        __int128 v16 = __p;
      }
      else {
        __int128 v16 = (void **)__p[0];
      }
      *(_DWORD *)__int128 buf = 136446466;
      __int16 v40 = v15;
      __int16 v41 = 2082;
      uint64_t v42 = v16;
      _os_log_impl( (void *)&_mh_execute_header,  v12,  OS_LOG_TYPE_DEFAULT,  "sendSessionScanMetricStats could not find an agent for %{public}s(%{public}s)",  buf,  0x16u);
      if (v32 < 0) {
        operator delete(__p[0]);
      }
      if (v34 < 0) {
        operator delete(v33[0]);
      }
    }
  }

void sub_1005F4368( _Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, void *__p, uint64_t a13, int a14, __int16 a15, char a16, char a17)
{
  _Unwind_Resume(a1);
}

id sub_1005F43E4(id a1, NSNumber *a2)
{
  uint64_t v2 = a2;
  else {
    unint64_t v3 = v2;
  }
  uint64_t v4 = v3;

  return v4;
}

void sub_1005F4420(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

uint64_t sub_1005F4430(uint64_t a1, uint64_t a2)
{
  if (!a2 || !*(void *)(a2 + 8)) {
    return 0LL;
  }
  uint64_t v3 = sub_100611378(a2);
  if (sub_10060173C(v3, v3))
  {
    uint64_t v4 = (os_log_s *)qword_1008F75B8;
    if (os_log_type_enabled((os_log_t)qword_1008F75B8, OS_LOG_TYPE_DEFAULT))
    {
      int v5 = sub_100611378(a2);
      *(_DWORD *)__int128 buf = 136315138;
      int v24 = sub_1005E2B18(v5);
      _os_log_impl( (void *)&_mh_execute_header,  v4,  OS_LOG_TYPE_DEFAULT,  "Scanning Prioritization over BT for useCase %s",  buf,  0xCu);
    }

    return 1LL;
  }

  else
  {
    id v7 = sub_100611384(a2);
    id v8 = (void *)objc_claimAutoreleasedReturnValue(v7);
    unint64_t v9 = v8;
    if (v8 && [v8 count])
    {
      __int128 v20 = 0u;
      __int128 v21 = 0u;
      __int128 v18 = 0u;
      __int128 v19 = 0u;
      id v10 = v9;
      uint64_t v6 = (uint64_t)[v10 countByEnumeratingWithState:&v18 objects:v22 count:16];
      if (v6)
      {
        uint64_t v11 = *(void *)v19;
        while (2)
        {
          for (uint64_t i = 0LL; i != v6; ++i)
          {
            if (*(void *)v19 != v11) {
              objc_enumerationMutation(v10);
            }
            int v13 = *(void **)(*((void *)&v18 + 1) + 8 * i);
            id v14 = objc_msgSend(v13, "longLongValue", (void)v18);
            if (sub_10060173C((uint64_t)v14, (int)v14))
            {
              uint64_t v15 = (os_log_s *)qword_1008F75B8;
              if (os_log_type_enabled((os_log_t)qword_1008F75B8, OS_LOG_TYPE_DEFAULT))
              {
                __int128 v16 = sub_1005E2B18((int)[v13 longLongValue]);
                *(_DWORD *)__int128 buf = 136315138;
                int v24 = v16;
                _os_log_impl( (void *)&_mh_execute_header,  v15,  OS_LOG_TYPE_DEFAULT,  "Scanning Prioritization over BT for useCase %s",  buf,  0xCu);
              }

              uint64_t v6 = 1LL;
              goto LABEL_23;
            }
          }

          uint64_t v6 = (uint64_t)[v10 countByEnumeratingWithState:&v18 objects:v22 count:16];
          if (v6) {
            continue;
          }
          break;
        }
      }

void sub_1005F4654(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

uint64_t sub_1005F4684(uint64_t a1, uint64_t a2)
{
  if (!a2 || !*(void *)(a2 + 8)) {
    return 0LL;
  }
  uint64_t v3 = sub_100611378(a2);
  if (sub_1006017DC(v3, v3))
  {
    uint64_t v4 = (os_log_s *)qword_1008F75B8;
    if (os_log_type_enabled((os_log_t)qword_1008F75B8, OS_LOG_TYPE_DEFAULT))
    {
      int v5 = sub_100611378(a2);
      *(_DWORD *)__int128 buf = 136315138;
      int v24 = sub_1005E2B18(v5);
      _os_log_impl( (void *)&_mh_execute_header,  v4,  OS_LOG_TYPE_DEFAULT,  "Scanning Prioritization over WiFi for useCase %s",  buf,  0xCu);
    }

    return 1LL;
  }

  else
  {
    id v7 = sub_100611384(a2);
    id v8 = (void *)objc_claimAutoreleasedReturnValue(v7);
    unint64_t v9 = v8;
    if (v8 && [v8 count])
    {
      __int128 v20 = 0u;
      __int128 v21 = 0u;
      __int128 v18 = 0u;
      __int128 v19 = 0u;
      id v10 = v9;
      uint64_t v6 = (uint64_t)[v10 countByEnumeratingWithState:&v18 objects:v22 count:16];
      if (v6)
      {
        uint64_t v11 = *(void *)v19;
        while (2)
        {
          for (uint64_t i = 0LL; i != v6; ++i)
          {
            if (*(void *)v19 != v11) {
              objc_enumerationMutation(v10);
            }
            int v13 = *(void **)(*((void *)&v18 + 1) + 8 * i);
            id v14 = objc_msgSend(v13, "longLongValue", (void)v18);
            if (sub_1006017DC((uint64_t)v14, (int)v14))
            {
              uint64_t v15 = (os_log_s *)qword_1008F75B8;
              if (os_log_type_enabled((os_log_t)qword_1008F75B8, OS_LOG_TYPE_DEFAULT))
              {
                __int128 v16 = sub_1005E2B18((int)[v13 longLongValue]);
                *(_DWORD *)__int128 buf = 136315138;
                int v24 = v16;
                _os_log_impl( (void *)&_mh_execute_header,  v15,  OS_LOG_TYPE_DEFAULT,  "Scanning Prioritization over WiFi for useCase %s",  buf,  0xCu);
              }

              uint64_t v6 = 1LL;
              goto LABEL_23;
            }
          }

          uint64_t v6 = (uint64_t)[v10 countByEnumeratingWithState:&v18 objects:v22 count:16];
          if (v6) {
            continue;
          }
          break;
        }
      }

void sub_1005F48A8(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

uint64_t sub_1005F48D8(uint64_t a1, uint64_t a2)
{
  return (*(uint64_t (**)(uint64_t, void, void))(*(void *)a2 + 72LL))( a2,  *(unsigned int *)(a1 + 32),  0LL);
}

void sub_1005F48F4(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, int a6)
{
  uint64_t v11 = *(void *)(a1 + 32);
  uint64_t v12 = sub_100404FE8();
  v13[0] = _NSConcreteStackBlock;
  v13[1] = 3221225472LL;
  void v13[2] = sub_1006091B8;
  v13[3] = &unk_1008A2968;
  int v14 = a6;
  void v13[4] = v11;
  void v13[5] = a2;
  void v13[6] = a3;
  v13[7] = a4;
  v13[8] = a5;
  sub_100405384(v12, v13);
}

uint64_t sub_1005F4984(uint64_t a1, unint64_t a2, uint64_t a3)
{
  if (!*(_DWORD *)(a1 + 1960)) {
    return 105LL;
  }
  uint64_t v4 = *(void **)(a1 + 2048);
  if (!v4) {
    goto LABEL_29;
  }
  uint64_t v6 = a1 + 2048;
  do
  {
    unint64_t v7 = v4[4];
    BOOL v8 = v7 >= a2;
    if (v7 >= a2) {
      unint64_t v9 = v4;
    }
    else {
      unint64_t v9 = v4 + 1;
    }
    if (v8) {
      uint64_t v6 = (uint64_t)v4;
    }
    uint64_t v4 = (void *)*v9;
  }

  while (*v9);
  if (v6 == a1 + 2048 || *(void *)(v6 + 32) > a2)
  {
LABEL_29:
    if (os_log_type_enabled((os_log_t)qword_1008F75B8, OS_LOG_TYPE_ERROR)) {
      sub_10069CB78();
    }
    return 401LL;
  }

  uint64_t v11 = *(void *)(v6 + 40);
  if (((*(void *)(*(void *)(v11 + 8) + (((unint64_t)a3 >> 3) & 0x18) + 240) >> a3) & 1) == 0)
  {
    if (os_log_type_enabled((os_log_t)qword_1008F75B8, OS_LOG_TYPE_ERROR)) {
      sub_10069CBA4();
    }
    return 401LL;
  }

  sub_100615908(v11, a3);
  uint64_t v16 = 0LL;
  memset(v15, 0, sizeof(v15));
  uint64_t v12 = sub_1002E6BF0();
  if ((*(unsigned int (**)(uint64_t))(*(void *)v12 + 600LL))(v12))
  {
    uint64_t v13 = sub_1002E6E9C();
    int v14 = (*(uint64_t (**)(uint64_t, _OWORD *, void, uint64_t, uint64_t))(*(void *)v13 + 736LL))( v13,  v15,  0LL,  1LL,  a3);
  }

  else
  {
    int v14 = sub_1005E3C94(a1, 1);
  }

  if (v14 && os_log_type_enabled((os_log_t)qword_1008F75B8, OS_LOG_TYPE_ERROR)) {
    sub_10069CBD0();
  }
  return 0LL;
}

uint64_t sub_1005F4B38(uint64_t a1, char a2, uint64_t a3, uint64_t a4)
{
  uint64_t v7 = sub_1002E6E9C();
  if ((*(unsigned int (**)(uint64_t, void, uint64_t, uint64_t))(*(void *)v7 + 728LL))( v7,  a2,  a3,  a4)
    && os_log_type_enabled((os_log_t)qword_1008F75B8, OS_LOG_TYPE_ERROR))
  {
    sub_10069CC30();
  }

  return 0LL;
}

uint64_t sub_1005F4BB8(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5)
{
  uint64_t v9 = sub_1002E6E9C();
  if ((*(unsigned int (**)(uint64_t, uint64_t, uint64_t, uint64_t, uint64_t))(*(void *)v9 + 736LL))( v9,  a2,  a3,  a4,  a5)
    && os_log_type_enabled((os_log_t)qword_1008F75B8, OS_LOG_TYPE_ERROR))
  {
    sub_10069CC90();
  }

  return 0LL;
}

uint64_t sub_1005F4C40( uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, unsigned int a7, unsigned int a8, unsigned __int8 a9, uint64_t a10, __int16 a11, char a12, char a13, char a14)
{
  uint64_t v20 = sub_1002E6BF0();
  if (!(*(unsigned int (**)(uint64_t))(*(void *)v20 + 592LL))(v20)
    || (uint64_t v21 = sub_1002E6E9C(),
        BYTE4(v23) = a14,
        BYTE3(v23) = a13,
        BYTE2(v23) = a12,
        LOWORD(v23) = a11,
        (*(unsigned int (**)(uint64_t, uint64_t, uint64_t, uint64_t, uint64_t, void, void, void, uint64_t, uint64_t))(*(void *)v21 + 672LL))( v21,  a3,  a4,  a5,  a6,  a7,  a8,  a9,  a10,  v23)))
  {
    if (os_log_type_enabled((os_log_t)qword_1008F75B8, OS_LOG_TYPE_ERROR)) {
      sub_10069CCF0();
    }
  }

  return 0LL;
}

uint64_t sub_1005F4D54( uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, unsigned __int8 a9, uint64_t a10, __int16 a11, char a12)
{
  uint64_t v18 = sub_1002E6BF0();
  if (!(*(unsigned int (**)(uint64_t))(*(void *)v18 + 592LL))(v18)
    || (uint64_t v19 = sub_1002E6E9C(),
        BYTE2(v21) = a12,
        LOWORD(v21) = a11,
        (*(unsigned int (**)(uint64_t, uint64_t, uint64_t, uint64_t, uint64_t, uint64_t, uint64_t, void, uint64_t, int))(*(void *)v19 + 688LL))( v19,  a3,  a4,  a5,  a6,  a7,  a8,  a9,  a10,  v21)))
  {
    if (os_log_type_enabled((os_log_t)qword_1008F75B8, OS_LOG_TYPE_ERROR)) {
      sub_10069CD50();
    }
  }

  return 0LL;
}

uint64_t sub_1005F4E54(uint64_t a1, uint64_t a2, uint64_t a3)
{
  uint64_t v4 = sub_1002E6BF0();
  if ((*(unsigned int (**)(uint64_t))(*(void *)v4 + 592LL))(v4))
  {
    uint64_t v5 = sub_1002E6E9C();
    uint64_t v6 = (*(uint64_t (**)(uint64_t, uint64_t))(*(void *)v5 + 720LL))(v5, a3);
    if (!(_DWORD)v6) {
      return v6;
    }
  }

  else
  {
    uint64_t v6 = 11LL;
  }

  if (os_log_type_enabled((os_log_t)qword_1008F75B8, OS_LOG_TYPE_ERROR)) {
    sub_10069CDB0();
  }
  return v6;
}

uint64_t sub_1005F4ED8(uint64_t a1, uint64_t a2, uint64_t a3)
{
  uint64_t v5 = sub_1002E6BF0();
  if (!(*(unsigned int (**)(uint64_t))(*(void *)v5 + 592LL))(v5)
    || (uint64_t v6 = sub_1002E6E9C(),
        (*(unsigned int (**)(uint64_t, uint64_t, uint64_t))(*(void *)v6 + 696LL))(v6, a2, a3)))
  {
    if (os_log_type_enabled((os_log_t)qword_1008F75B8, OS_LOG_TYPE_ERROR)) {
      sub_10069CE10();
    }
  }

  return 0LL;
}

uint64_t sub_1005F4F64(uint64_t a1)
{
  uint64_t v6 = 0LL;
  uint64_t v7 = &v6;
  uint64_t v8 = 0x2020000000LL;
  char v9 = 0;
  uint64_t v2 = sub_100404FE8();
  v5[0] = _NSConcreteStackBlock;
  v5[1] = 3221225472LL;
  void v5[2] = sub_1005F500C;
  v5[3] = &unk_100880D70;
  v5[4] = &v6;
  void v5[5] = a1;
  sub_1004054B4(v2, v5);
  uint64_t v3 = *((unsigned __int8 *)v7 + 24);
  _Block_object_dispose(&v6, 8);
  return v3;
}

void sub_1005F4FF4( _Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, ...)
{
}

uint64_t sub_1005F500C(uint64_t result)
{
  *(_BYTE *)(*(void *)(*(void *)(result + 32) + 8LL) + 24LL) = *(_DWORD *)(*(void *)(result + 40) + 1960LL) == 3;
  return result;
}

void *sub_1005F5028(uint64_t a1, unint64_t a2)
{
  uint64_t v2 = *(void **)(a1 + 2048);
  if (!v2) {
    return 0LL;
  }
  uint64_t v3 = (void *)(a1 + 2048);
  do
  {
    unint64_t v4 = v2[4];
    BOOL v5 = v4 >= a2;
    if (v4 >= a2) {
      uint64_t v6 = v2;
    }
    else {
      uint64_t v6 = v2 + 1;
    }
    if (v5) {
      uint64_t v3 = v2;
    }
    uint64_t v2 = (void *)*v6;
  }

  while (*v6);
  if (v3 == (void *)(a1 + 2048)) {
    return 0LL;
  }
  if (v3[4] > a2) {
    return 0LL;
  }
  uint64_t v7 = *(void *)(v3[5] + 8LL);
  if (!v7) {
    return 0LL;
  }
  uint64_t v8 = operator new(0x188uLL);
  sub_10060EA30((uint64_t)v8, (__int128 **)(v7 + 8), (__int128 **)(v7 + 32), *(_BYTE *)v7, 0);
  return v8;
}

void sub_1005F50B8(_Unwind_Exception *a1)
{
}

void sub_1005F50CC(uint64_t a1, int a2)
{
  int v4 = *(_DWORD *)(a1 + 1960);
  if (v4)
  {
    if (v4 != 2)
    {
      BOOL v5 = (os_log_s *)qword_1008F75B8;
      if (os_log_type_enabled((os_log_t)qword_1008F75B8, OS_LOG_TYPE_FAULT)) {
        sub_10069CED0(v5, v6, v7, v8, v9, v10, v11, v12);
      }
    }

    uint64_t v13 = (os_log_s *)qword_1008F75B8;
    if (a2)
    {
      if (os_log_type_enabled((os_log_t)qword_1008F75B8, OS_LOG_TYPE_ERROR)) {
        sub_10069CE70();
      }
    }

    else
    {
      if (os_log_type_enabled((os_log_t)qword_1008F75B8, OS_LOG_TYPE_DEFAULT))
      {
        *(_WORD *)__int128 buf = 0;
        _os_log_impl((void *)&_mh_execute_header, v13, OS_LOG_TYPE_DEFAULT, "Scanning started successfully", buf, 2u);
      }

      *(void *)(a1 + 2096) = 0LL;
      *(_DWORD *)(a1 + 1960) = 3;
      sub_1005F51EC(a1, 0);
    }
  }

  else
  {
    int v14 = (os_log_s *)qword_1008F75B8;
    if (os_log_type_enabled((os_log_t)qword_1008F75B8, OS_LOG_TYPE_DEFAULT))
    {
      *(_WORD *)uint64_t v15 = 0;
      _os_log_impl((void *)&_mh_execute_header, v14, OS_LOG_TYPE_DEFAULT, "Ignoring late scan started event", v15, 2u);
    }
  }

uint64_t sub_1005F51EC(uint64_t a1, char a2)
{
  __int128 v152 = *(_OWORD *)&off_1008A3DD8;
  __int128 v153 = sub_1005FB138;
  memset(v151, 0, 26);
  int v4 = *(_DWORD *)(a1 + 1960);
  BOOL v5 = (os_log_t *)&qword_1008F75B8;
  if ((v4 & 0xFFFFFFFD) == 1) {
    goto LABEL_4;
  }
  uint64_t v6 = (os_log_s *)qword_1008F75B8;
  if (os_log_type_enabled((os_log_t)qword_1008F75B8, OS_LOG_TYPE_FAULT))
  {
    *(_DWORD *)__int128 buf = 136446210;
    *(void *)&uint8_t buf[4] = "isInSettledState()";
    _os_log_fault_impl((void *)&_mh_execute_header, v6, OS_LOG_TYPE_FAULT, "Assertion failed: %{public}s", buf, 0xCu);
    if (*(_DWORD *)(a1 + 1960)) {
      goto LABEL_4;
    }
    return 105LL;
  }

  if (!v4) {
    return 105LL;
  }
LABEL_4:
  if (*(_BYTE *)(a1 + 4296))
  {
    uint64_t v7 = (os_log_s *)qword_1008F75B8;
    BOOL v8 = os_log_type_enabled((os_log_t)qword_1008F75B8, OS_LOG_TYPE_DEFAULT);
    uint64_t result = 0LL;
    if (!v8) {
      return result;
    }
    *(_WORD *)__int128 buf = 0;
    uint64_t v10 = "Configuring controller, will try again later";
    goto LABEL_10;
  }

  if (*(_BYTE *)(a1 + 4383))
  {
    uint64_t v7 = (os_log_s *)qword_1008F75B8;
    BOOL v11 = os_log_type_enabled((os_log_t)qword_1008F75B8, OS_LOG_TYPE_DEFAULT);
    uint64_t result = 0LL;
    if (!v11) {
      return result;
    }
    *(_WORD *)__int128 buf = 0;
    uint64_t v10 = "Configuring controller scan RX Thresholds, will try again later";
LABEL_10:
    _os_log_impl((void *)&_mh_execute_header, v7, OS_LOG_TYPE_DEFAULT, v10, buf, 2u);
    return 0LL;
  }

  int v12 = sub_100600088(a1);
  if (v12) {
    BOOL v13 = *(_DWORD *)(a1 + 1964) == 0;
  }
  else {
    BOOL v13 = 0;
  }
  BOOL v14 = sub_10060001C(a1);
  uint64_t v15 = *(int *)(a1 + 1964);
  if ((_DWORD)v15)
  {
    BOOL v13 = sub_100600194(a1);
    BOOL v16 = v13;
  }

  else
  {
    BOOL v16 = 0;
  }

  id v17 = (os_log_s *)qword_1008F75B8;
  if (os_log_type_enabled((os_log_t)qword_1008F75B8, OS_LOG_TYPE_DEFAULT))
  {
    else {
      uint64_t v18 = off_1008A4238[v15];
    }
    int v19 = *(unsigned __int8 *)(a1 + 1840);
    *(_DWORD *)__int128 buf = 67110402;
    *(_DWORD *)&uint8_t buf[4] = v13;
    *(_WORD *)&uint8_t buf[8] = 1024;
    *(_DWORD *)&buf[10] = v12;
    *(_WORD *)&buf[14] = 1024;
    *(_DWORD *)&uint8_t buf[16] = v16;
    *(_WORD *)&_BYTE buf[20] = 2082;
    *(void *)&_BYTE buf[22] = v18;
    *(_WORD *)&buf[30] = 1024;
    *(_DWORD *)&_BYTE buf[32] = v14;
    *(_WORD *)&buf[36] = 1024;
    *(_DWORD *)&_BYTE buf[38] = v19;
    _os_log_impl( (void *)&_mh_execute_header,  v17,  OS_LOG_TYPE_DEFAULT,  "ShouldScan=%d AnyValidScanRequests=%d anyValidScanRequestInPaused=%d fObserverState=%{public}s ClientScanPowerAsse rtRequired=%d fScanFiltersNeedUpdagint=%d",  buf,  0x2Au);
  }

  if (v14 && v13) {
    sub_1005E4A10(a1);
  }
  else {
    sub_1005E4BD0(a1);
  }
  sub_1005FC618(a1);
  sub_1005EC5D8((unsigned __int8 *)a1);
  sub_1005FC8FC(a1);
  sub_1005E75F8((unsigned __int8 *)a1);
  if (!v13)
  {
    if (*(_DWORD *)(a1 + 1960) == 3)
    {
      __int128 v29 = (os_log_s *)qword_1008F75B8;
      if (os_log_type_enabled((os_log_t)qword_1008F75B8, OS_LOG_TYPE_DEFAULT))
      {
        *(_WORD *)__int128 buf = 0;
        _os_log_impl( (void *)&_mh_execute_header,  v29,  OS_LOG_TYPE_DEFAULT,  "Stopping scan as there are no remaining scan agents permitted to scan",  buf,  2u);
      }

      LOBYTE(__str) = 0;
      sub_100242CA4(&__str);
      if (sub_1001BA2D0())
      {
        if (os_log_type_enabled((os_log_t)qword_1008F75B8, OS_LOG_TYPE_ERROR)) {
          sub_10069CF40();
        }
      }

      else
      {
        *(_DWORD *)(a1 + 1960) = 4;
        dispatch_time_t v53 = dispatch_time(0LL, 3000000000LL);
        *(void *)(a1 + 2024) = v53;
        uint64_t v54 = (os_log_s *)qword_1008F75B8;
        if (os_log_type_enabled((os_log_t)qword_1008F75B8, OS_LOG_TYPE_INFO))
        {
          *(_DWORD *)__int128 buf = 134217984;
          *(void *)&uint8_t buf[4] = v53;
          _os_log_impl( (void *)&_mh_execute_header,  v54,  OS_LOG_TYPE_INFO,  "Setting the zone lost timeout to %lld",  buf,  0xCu);
        }

        double Current = CFAbsoluteTimeGetCurrent();
        double v56 = 0.0;
        if (Current > 0.0)
        {
          double v57 = *(double *)(a1 + 3208);
          BOOL v58 = Current <= v57 || v57 <= 0.0;
          double v59 = Current - v57;
          if (v58) {
            double v56 = 0.0;
          }
          else {
            double v56 = v59;
          }
        }

        unsigned int v60 = *(_DWORD *)(a1 + 3220);
        int v61 = *(unsigned __int8 *)(a1 + 3224);
        uint64_t v62 = *(unsigned int *)(a1 + 3216);
        uint64_t v63 = a1 + 48LL * v60 + 24LL * *(unsigned __int8 *)(a1 + 3224) + 8 * v62;
        double v64 = v56 + *(double *)(v63 + 2800);
        *(double *)(v63 + 2800) = v64;
        size_t v65 = (os_log_s *)qword_1008F75B8;
        if (os_log_type_enabled((os_log_t)qword_1008F75B8, OS_LOG_TYPE_DEBUG))
        {
          if (v60 > 6) {
            uint64_t v128 = "Unknown Duty Cycle Type";
          }
          else {
            uint64_t v128 = off_1008A41C0[v60];
          }
          uint64_t v129 = "active";
          if (!v61) {
            uint64_t v129 = "passive";
          }
          else {
            char v130 = off_1008A41F8[(int)v62];
          }
          uint64_t v131 = *(void *)(a1 + 3208);
          *(_DWORD *)__int128 buf = 136447490;
          *(void *)&uint8_t buf[4] = v128;
          *(_WORD *)&_BYTE buf[12] = 2082;
          *(void *)&buf[14] = v129;
          *(_WORD *)&_BYTE buf[22] = 2082;
          *(void *)&_BYTE buf[24] = v130;
          *(_WORD *)&_BYTE buf[32] = 2048;
          *(double *)&buf[34] = v56;
          *(_WORD *)&_BYTE buf[42] = 2048;
          *(double *)&buf[44] = v64;
          *(_WORD *)&buf[52] = 2048;
          *(void *)&buf[54] = v131;
          _os_log_debug_impl( (void *)&_mh_execute_header,  v65,  OS_LOG_TYPE_DEBUG,  "BLEScanStat: Scan stops with duty cycle %{public}s scan type %{public}s agent %{public}s duration %f sec tot alScanTime %f sec prev start at %f sec",  buf,  0x3Eu);
        }
      }

      sub_100242CD8(&__str);
    }

    else
    {
      sub_1005E5004(a1);
    }

    return 0LL;
  }

  v150[0] = 0LL;
  v150[1] = 0LL;
  int v149 = (uint64_t *)v150;
  uint64_t v20 = *(void **)(a1 + 2040);
  uint64_t v141 = (void *)(a1 + 2048);
  if (v20 != (void *)(a1 + 2048))
  {
    do
    {
      LODWORD(v146) = *(_DWORD *)(*(void *)(v20[5] + 8LL) + 168LL);
      uint64_t v158 = 0LL;
      __int128 v157 = 0u;
      memset(buf, 0, sizeof(buf));
      uint64_t v21 = sub_1005DFF08(a1, v20[5]);
      __int128 v22 = *(_OWORD *)v21;
      __int128 v23 = *(_OWORD *)(v21 + 16);
      *(_OWORD *)&buf[28] = *(_OWORD *)(v21 + 28);
      *(_OWORD *)__int128 buf = v22;
      *(_OWORD *)&uint8_t buf[16] = v23;
      memset(&buf[48], 0, 24);
      sub_10060E68C( &buf[48],  *(void *)(v21 + 48),  *(void *)(v21 + 56),  0xAAAAAAAAAAAAAAABLL * ((uint64_t)(*(void *)(v21 + 56) - *(void *)(v21 + 48)) >> 5));
      *(void *)&buf[72] = 0LL;
      __int128 v157 = 0uLL;
      sub_100050EE8( (char *)&buf[72],  *(__int128 **)(v21 + 72),  *(__int128 **)(v21 + 80),  0xCCCCCCCCCCCCCCCDLL * ((uint64_t)(*(void *)(v21 + 80) - *(void *)(v21 + 72)) >> 2));
      LOBYTE(v15_Block_object_dispose(va, 8) = *(_BYTE *)(v21 + 96);
      if (buf[8] && !buf[5] && !buf[4]) {
        sub_1006106E4(&v149, (unsigned int *)&v146, &v146);
      }
      BOOL v24 = (sub_1006093AC(*(void *)(v20[5] + 8LL), 0x16u) & 1) != 0 || *(_BYTE *)(a1 + 2721) != 0;
      *(_BYTE *)(a1 + 2721) = v24;
      BOOL v25 = (sub_100609514(*(void *)(v20[5] + 8LL), 2u) & 1) != 0 || *(_BYTE *)(a1 + 2722) != 0;
      *(_BYTE *)(a1 + 2722) = v25;
      if (*(void *)&buf[72])
      {
        *(void *)&__int128 v157 = *(void *)&buf[72];
        operator delete(*(void **)&buf[72]);
      }

      *(void *)&__int128 __str = &buf[48];
      sub_10004FEA4((void ***)&__str);
      id v26 = (void *)v20[1];
      if (v26)
      {
        do
        {
          id v27 = v26;
          id v26 = (void *)*v26;
        }

        while (v26);
      }

      else
      {
        do
        {
          id v27 = (void *)v20[2];
          BOOL v32 = *v27 == (void)v20;
          uint64_t v20 = v27;
        }

        while (!v32);
      }

      uint64_t v20 = v27;
    }

    while (v27 != v141);
  }

  uint64_t v28 = sub_1002E6BF0();
  else {
    sub_100602018(a1, (unsigned __int8 *)v151);
  }
  uint64_t v30 = *(void *)(a1 + 1968) ^ *(void *)&v151[0] | *(void *)(a1 + 1976) ^ *((void *)&v151[0] + 1) | *(void *)(a1 + 1984) ^ *(void *)&v151[1] | (unsigned __int16)(*(_WORD *)(a1 + 1992) ^ WORD4(v151[1]));
  *(_BYTE *)(a1 + 1841) = v30 != 0;
  if ((a2 & 1) != 0)
  {
    int v31 = 1;
  }

  else
  {
    if (*(_BYTE *)(a1 + 1840)) {
      BOOL v32 = 0;
    }
    else {
      BOOL v32 = v30 == 0;
    }
    int v31 = !v32;
  }

  BOOL v33 = v30 != 0;
  if (*(_DWORD *)(a1 + 1964) == 2) {
    int v34 = v33;
  }
  else {
    int v34 = v31;
  }
  __int128 v35 = (os_log_s *)qword_1008F75B8;
  if (os_log_type_enabled((os_log_t)qword_1008F75B8, OS_LOG_TYPE_DEFAULT))
  {
    *(_DWORD *)__int128 buf = 67109120;
    *(_DWORD *)&uint8_t buf[4] = v34;
    _os_log_impl((void *)&_mh_execute_header, v35, OS_LOG_TYPE_DEFAULT, "needToRestart=%d", buf, 8u);
  }

  if (*(_DWORD *)(a1 + 1960) == 3)
  {
    if (v34)
    {
      __int128 __str = 0u;
      __int128 v155 = 0u;
      LOWORD(v36) = *(_WORD *)(a1 + 1974);
      snprintf( (char *)&__str,  0x20uLL,  "%.2fms/%.2fms",  (double)*(unsigned __int16 *)(a1 + 1972) * 0.625,  (double)v36 * 0.625);
      sub_1005E4CAC(a1);
      __int128 v37 = (os_log_s *)qword_1008F75B8;
      if (os_log_type_enabled((os_log_t)qword_1008F75B8, OS_LOG_TYPE_INFO))
      {
        if (*(_BYTE *)(a1 + 1968)) {
          __int128 v38 = "passive";
        }
        else {
          __int128 v38 = "active";
        }
        int v39 = *(unsigned __int8 *)(a1 + 1971);
        *(_DWORD *)__int128 buf = 136446722;
        *(void *)&uint8_t buf[4] = v38;
        *(_WORD *)&_BYTE buf[12] = 2082;
        *(void *)&buf[14] = &__str;
        if (v39) {
          __int16 v40 = "no ";
        }
        else {
          __int16 v40 = "";
        }
        *(_WORD *)&_BYTE buf[22] = 2082;
        *(void *)&_BYTE buf[24] = v40;
        _os_log_impl( (void *)&_mh_execute_header,  v37,  OS_LOG_TYPE_INFO,  "Currently in %{public}s scan (%{public}s) with %{public}sduplicates - stopping scan...",  buf,  0x20u);
      }

      LOBYTE(v146) = 0;
      sub_100242CA4(&v146);
      if (sub_1001BA2D0())
      {
        if (os_log_type_enabled((os_log_t)qword_1008F75B8, OS_LOG_TYPE_ERROR)) {
          sub_10069CF40();
        }
      }

      else
      {
        *(_DWORD *)(a1 + 1960) = 4;
        dispatch_time_t v66 = dispatch_time(0LL, 3000000000LL);
        *(void *)(a1 + 2024) = v66;
        id v67 = (os_log_s *)qword_1008F75B8;
        if (os_log_type_enabled((os_log_t)qword_1008F75B8, OS_LOG_TYPE_INFO))
        {
          *(_DWORD *)__int128 buf = 134217984;
          *(void *)&uint8_t buf[4] = v66;
          _os_log_impl( (void *)&_mh_execute_header,  v67,  OS_LOG_TYPE_INFO,  "Setting the zone lost timeout to %lld",  buf,  0xCu);
        }

        double v68 = CFAbsoluteTimeGetCurrent();
        double v69 = 0.0;
        if (v68 > 0.0)
        {
          double v70 = *(double *)(a1 + 3208);
          BOOL v71 = v68 <= v70 || v70 <= 0.0;
          double v72 = v68 - v70;
          if (v71) {
            double v69 = 0.0;
          }
          else {
            double v69 = v72;
          }
        }

        unsigned int v73 = *(_DWORD *)(a1 + 3220);
        int v74 = *(unsigned __int8 *)(a1 + 3224);
        uint64_t v75 = *(unsigned int *)(a1 + 3216);
        uint64_t v76 = a1 + 48LL * v73 + 24LL * *(unsigned __int8 *)(a1 + 3224) + 8 * v75;
        double v77 = v69 + *(double *)(v76 + 2800);
        *(double *)(v76 + 2800) = v77;
        uint64_t v78 = (os_log_s *)qword_1008F75B8;
        if (os_log_type_enabled((os_log_t)qword_1008F75B8, OS_LOG_TYPE_DEBUG))
        {
          if (v73 > 6) {
            BOOL v132 = "Unknown Duty Cycle Type";
          }
          else {
            BOOL v132 = off_1008A41C0[v73];
          }
          id v134 = "active";
          if (!v74) {
            id v134 = "passive";
          }
          else {
            int v135 = off_1008A41F8[(int)v75];
          }
          uint64_t v136 = *(void *)(a1 + 3208);
          *(_DWORD *)__int128 buf = 136447490;
          *(void *)&uint8_t buf[4] = v132;
          *(_WORD *)&_BYTE buf[12] = 2082;
          *(void *)&buf[14] = v134;
          *(_WORD *)&_BYTE buf[22] = 2082;
          *(void *)&_BYTE buf[24] = v135;
          *(_WORD *)&_BYTE buf[32] = 2048;
          *(double *)&buf[34] = v69;
          *(_WORD *)&_BYTE buf[42] = 2048;
          *(double *)&buf[44] = v77;
          *(_WORD *)&buf[52] = 2048;
          *(void *)&buf[54] = v136;
          _os_log_debug_impl( (void *)&_mh_execute_header,  v78,  OS_LOG_TYPE_DEBUG,  "BLEScanStat: Scan stops with duty cycle %{public}s scan type %{public}s agent %{public}s duration %f sec tot alScanTime %f sec prev start at %f sec",  buf,  0x3Eu);
        }
      }

      sub_100242CD8(&v146);
    }

    else
    {
      sub_1005E5004(a1);
    }

    goto LABEL_208;
  }

  __int128 __str = 0u;
  __int128 v155 = 0u;
  LOWORD(v36) = WORD3(v151[0]);
  snprintf((char *)&__str, 0x20uLL, "%.2fms/%.2fms", (double)WORD2(v151[0]) * 0.625, (double)v36 * 0.625);
  else {
    BOOL v41 = 1;
  }
  int v42 = !v41;
  uint64_t v43 = (os_log_s *)qword_1008F75B8;
  if (os_log_type_enabled((os_log_t)qword_1008F75B8, OS_LOG_TYPE_DEFAULT))
  {
    uint64_t v44 = "Not ";
    int v45 = *(unsigned __int8 *)(a1 + 1840);
    if (v42) {
      uint64_t v44 = "";
    }
    int v46 = *(_DWORD *)(a1 + 1964);
    int v47 = *(unsigned __int8 *)(a1 + 2352);
    if (LOBYTE(v151[0])) {
      unint64_t v48 = "passive";
    }
    else {
      unint64_t v48 = "active";
    }
    *(_DWORD *)__int128 buf = 136448002;
    *(void *)&uint8_t buf[4] = v44;
    *(_WORD *)&_BYTE buf[12] = 2082;
    *(void *)&buf[14] = v48;
    if (BYTE3(v151[0])) {
      unint64_t v49 = "enabled";
    }
    else {
      unint64_t v49 = "disabled";
    }
    *(_WORD *)&_BYTE buf[22] = 2082;
    int v50 = "YES";
    *(void *)&_BYTE buf[24] = &__str;
    *(_WORD *)&_BYTE buf[32] = 2082;
    if (!v45) {
      int v50 = "NO";
    }
    *(void *)&buf[34] = v49;
    *(_WORD *)&_BYTE buf[42] = 1024;
    *(_DWORD *)&buf[44] = v45;
    *(_WORD *)&buf[48] = 1024;
    *(_DWORD *)&buf[50] = v46;
    *(_WORD *)&buf[54] = 1024;
    *(_DWORD *)&buf[56] = v47;
    *(_WORD *)&buf[60] = 2082;
    *(void *)&buf[62] = v50;
    _os_log_impl( (void *)&_mh_execute_header,  v43,  OS_LOG_TYPE_DEFAULT,  "%{public}sStarting %{public}s scan (%{public}s) with duplicate filter %{public}s scNeed=%d stateO=%d, retainDups=% d fScanFiltersNeedUpdating=%{public}s",  buf,  0x46u);
  }

  *(_OWORD *)(a1 + 196_Block_object_dispose(va, 8) = v151[0];
  *(_OWORD *)(a1 + 197_Block_object_dispose(va, 8) = *(__int128 *)((char *)v151 + 10);
  if (v42) {
    sub_1005E4CAC(a1);
  }
  if (*(_DWORD *)(a1 + 1964) == 2)
  {
    sub_1005FA2CC((_BYTE *)a1, 1);
  }

  else
  {
    if (*(_BYTE *)(a1 + 1840) || *(_BYTE *)(a1 + 1843))
    {
      *(_BYTE *)(a1 + 1840) = 0;
      if ((*(_BYTE *)(a1 + 4382) || *(_BYTE *)(a1 + 4381)) && *(_BYTE *)(a1 + 1842)) {
        sub_1005FA2CC((_BYTE *)a1, 0);
      }
      if (!LOBYTE(v151[0]) || (sub_100600200(a1) & 1) != 0 || (sub_100600280(a1) & 1) != 0)
      {
        uint64_t v51 = (os_log_s *)qword_1008F75B8;
        if (os_log_type_enabled((os_log_t)qword_1008F75B8, OS_LOG_TYPE_INFO))
        {
          *(_WORD *)__int128 buf = 0;
          _os_log_impl((void *)&_mh_execute_header, v51, OS_LOG_TYPE_INFO, "Skip addFilters", buf, 2u);
        }
      }

      else
      {
        sub_1005FE3B0(a1);
        if (*(_BYTE *)(a1 + 4382) || *(_BYTE *)(a1 + 4381)) {
          goto LABEL_208;
        }
      }
    }

    if (LOBYTE(v151[0])) {
      char v52 = sub_1005FE210(a1);
    }
    else {
      char v52 = 0;
    }
    BYTE3(v151[0]) |= v52;
  }

  __int16 v146 = 0LL;
  int v147 = 0LL;
  unint64_t v148 = 0LL;
  uint64_t v79 = *(void **)(a1 + 2040);
  if (v79 == v141)
  {
    *(_BYTE *)(a1 + 4383) = 0;
    goto LABEL_195;
  }

  int v140 = v42;
  do
  {
    uint64_t v81 = v79[4];
    uint64_t v80 = v79[5];
    uint64_t v82 = *v5;
    if (os_log_type_enabled(*v5, OS_LOG_TYPE_DEBUG))
    {
      sub_100494958(v81, (uint64_t)__p);
      int v109 = __p;
      if (v145 < 0) {
        int v109 = (void **)__p[0];
      }
      uint64_t v110 = *(void *)(v80 + 8);
      int v111 = *(unsigned __int8 *)(v110 + 196);
      int v113 = *(_DWORD *)(v110 + 188);
      int v112 = *(_DWORD *)(v110 + 192);
      if (v113) {
        int v114 = 120000;
      }
      else {
        int v114 = 0;
      }
      if (!v112) {
        int v112 = v114;
      }
      *(_DWORD *)__int128 buf = 136315906;
      *(void *)&uint8_t buf[4] = v109;
      *(_WORD *)&_BYTE buf[12] = 1024;
      *(_DWORD *)&buf[14] = v111;
      *(_WORD *)&_BYTE buf[18] = 1024;
      *(_DWORD *)&_BYTE buf[20] = v113;
      *(_WORD *)&_BYTE buf[24] = 1024;
      *(_DWORD *)&_BYTE buf[26] = v112;
      _os_log_debug_impl( (void *)&_mh_execute_header,  v82,  OS_LOG_TYPE_DEBUG,  "session %s scanRxThresholdConfigured:%d getScanRxThresholdRequirement:%d getScanTimeoutRequirement:%d",  buf,  0x1Eu);
      if (v145 < 0) {
        operator delete(__p[0]);
      }
    }

    uint64_t v83 = *(void *)(v80 + 8);
    if (!*(_BYTE *)(v83 + 196))
    {
      int v85 = *(_DWORD *)(v83 + 188);
      int v84 = *(_DWORD *)(v83 + 192);
      int v86 = 120000;
      if (!v85)
      {
        if (!v84) {
          goto LABEL_170;
        }
        int v86 = 0;
      }

      int v87 = *(_DWORD *)(v83 + 168);
      if (v84) {
        int v88 = *(_DWORD *)(v83 + 192);
      }
      else {
        int v88 = v86;
      }
      v143[0] = _NSConcreteStackBlock;
      v143[1] = 3221225472LL;
      v143[2] = sub_100609680;
      v143[3] = &unk_1008A3B18;
      v143[4] = a1;
      __int128 v89 = objc_retainBlock(v143);
      __int128 v90 = v89;
      int v91 = v147;
      if ((unint64_t)v147 >= v148)
      {
        __int128 v93 = v5;
        unint64_t v94 = 0xCCCCCCCCCCCCCCCDLL * ((v147 - v146) >> 3);
        unint64_t v95 = v94 + 1;
        if (v94 + 1 > 0x666666666666666LL) {
          abort();
        }
        else {
          unint64_t v96 = v95;
        }
        *(void *)&_BYTE buf[32] = &v148;
        uint64_t v97 = (char *)sub_1001FDA44((uint64_t)&v148, v96);
        int v99 = &v97[40 * v94];
        *(void *)int v99 = v81;
        *((_DWORD *)v99 + 2) = v85;
        *((_DWORD *)v99 + 3) = v85;
        *((_DWORD *)v99 + 4) = v88;
        *((_DWORD *)v99 + 5) = 7;
        *((_DWORD *)v99 + 6) = v87;
        *((void *)v99 + 4) = v90;
        unsigned int v101 = v146;
        uint64_t v100 = v147;
        if (v147 == v146)
        {
          unsigned int v101 = v147;
          unint64_t v103 = (__int128 *)&v97[40 * v94];
          BOOL v5 = v93;
        }

        else
        {
          uint64_t v102 = v147;
          unint64_t v103 = (__int128 *)&v97[40 * v94];
          BOOL v5 = v93;
          do
          {
            __int128 v104 = *(_OWORD *)(v102 - 40);
            *(__int128 *)((char *)v103 - 2_Block_object_dispose(va, 8) = *(_OWORD *)(v102 - 28);
            *(__int128 *)((char *)v103 - 40) = v104;
            uint64_t v105 = *((void *)v102 - 1);
            *((void *)v102 - 1) = 0LL;
            *((void *)v103 - 1) = v105;
            unint64_t v103 = (__int128 *)((char *)v103 - 40);
            v102 -= 40;
          }

          while (v102 != v101);
        }

        char v92 = (__int128 *)(v99 + 40);
        __int16 v146 = (char *)v103;
        int v147 = v99 + 40;
        unint64_t v106 = v148;
        unint64_t v148 = (unint64_t)&v97[40 * v98];
        *(void *)&uint8_t buf[16] = v100;
        *(void *)&_BYTE buf[24] = v106;
        *(void *)__int128 buf = v101;
        *(void *)&uint8_t buf[8] = v101;
        sub_10060F6AC((uint64_t)buf);
      }

      else
      {
        *(void *)int v147 = v81;
        *((_DWORD *)v91 + 2) = v85;
        *((_DWORD *)v91 + 3) = v85;
        *((_DWORD *)v91 + 4) = v88;
        *((_DWORD *)v91 + 5) = 7;
        *((_DWORD *)v91 + 6) = v87;
        char v92 = (__int128 *)(v91 + 40);
        *((void *)v91 + 4) = v89;
      }

      int v147 = (char *)v92;
      *(_BYTE *)(*(void *)(v80 + 8) + 196LL) = 1;
    }

LABEL_195:
  if (v42)
  {
    uint64_t v121 = sub_1002E6E9C();
    (*(void (**)(uint64_t, void))(*(void *)v121 + 1072LL))(v121, *(unsigned __int8 *)(a1 + 2352));
    *(_BYTE *)(a1 + 2352) = 0;
    LOBYTE(__p[0]) = 0;
    sub_100242CA4(__p);
    int v122 = sub_1001BB338((uint64_t)v151, (uint64_t)&v152, a1);
    sub_100242CD0(__p);
    if (v122)
    {
      if (os_log_type_enabled(*v5, OS_LOG_TYPE_ERROR)) {
        sub_10069CFA0();
      }
    }

    else
    {
      sub_1005E50FC(a1);
      *(_DWORD *)(a1 + 1960) = 2;
      CFAbsoluteTime v123 = CFAbsoluteTimeGetCurrent();
      *(CFAbsoluteTime *)(a1 + 320_Block_object_dispose(va, 8) = v123;
      int v124 = LOBYTE(v151[0]) ^ 1;
      *(_BYTE *)(a1 + 3224) = LOBYTE(v151[0]) ^ 1;
      int v126 = sub_100607AE8(v125, WORD2(v151[0]), WORD3(v151[0]));
      *(_DWORD *)(a1 + 3220) = v126;
      __int16 v127 = *v5;
      if (os_log_type_enabled(*v5, OS_LOG_TYPE_DEBUG))
      {
        if (v126 == 7) {
          uint64_t v133 = "Unknown Duty Cycle Type";
        }
        else {
          uint64_t v133 = off_1008A41C0[v126];
        }
        int v137 = "active";
        if (!v124) {
          int v137 = "passive";
        }
        uint64_t v138 = *(int *)(a1 + 3216);
        else {
          size_t v139 = off_1008A41F8[v138];
        }
        *(_DWORD *)__int128 buf = 136446978;
        *(void *)&uint8_t buf[4] = v133;
        *(_WORD *)&_BYTE buf[12] = 2082;
        *(void *)&buf[14] = v137;
        *(_WORD *)&_BYTE buf[22] = 2082;
        *(void *)&_BYTE buf[24] = v139;
        *(_WORD *)&_BYTE buf[32] = 2048;
        *(CFAbsoluteTime *)&buf[34] = v123;
        _os_log_debug_impl( (void *)&_mh_execute_header,  v127,  OS_LOG_TYPE_DEBUG,  "BLEScanStat: Scan started with duty cycle %{public}s scan type %{public}s agent %{public}s start at %f sec",  buf,  0x2Au);
      }

      if (qword_1008D6198 != -1) {
        dispatch_once(&qword_1008D6198, &stru_1008A4058);
      }
      sub_10044C72C((uint64_t)off_1008D6190, v151, 1, (uint64_t)&v149);
    }

    sub_100242CD8(__p);
  }

  else
  {
    sub_1005E5004(a1);
    if (qword_1008D6198 != -1) {
      dispatch_once(&qword_1008D6198, &stru_1008A4058);
    }
    sub_10044C72C((uint64_t)off_1008D6190, v151, 0, (uint64_t)&v149);
  }

LABEL_207:
  *(void *)__int128 buf = &v146;
  sub_10060F638((void ***)buf);
LABEL_208:
  sub_10023BF24((uint64_t)&v149, v150[0]);
  return 0LL;
}

void sub_1005F64E0( _Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20, uint64_t a21, uint64_t a22, uint64_t a23, uint64_t a24, uint64_t a25, uint64_t a26, uint64_t a27, uint64_t a28, char a29, uint64_t a30, uint64_t a31, char a32, void *a33)
{
}

uint64_t sub_1005F65B4( uint64_t a1, unint64_t a2, int a3, uint64_t a4, int a5, int a6, BOOL a7, int a8)
{
  int v172 = a8;
  BOOL v177 = a7;
  uint64_t v182 = (void *)a1;
  uint64_t v183 = a4;
  uint64_t v261 = 0LL;
  memset(v260, 0, sizeof(v260));
  __int128 v259 = 0u;
  __int128 v258 = 0u;
  __int128 v257 = 0u;
  __int128 v255 = 0u;
  memset(v256, 0, sizeof(v256));
  sub_1001FCFC8((uint64_t)&v255);
  if (!a2) {
    goto LABEL_324;
  }
  ++v182[262];
  if (a6)
  {
    uint64_t v12 = *(void *)(v183 + 8);
    __int16 v13 = *(_WORD *)(v12 + 472);
    uint64_t v14 = *(unsigned __int8 *)(v12 + 474);
    uint64_t v15 = *(unsigned __int8 *)(v12 + 342);
    uint64_t v16 = sub_1002E8D94();
    (*(void (**)(uint64_t, unint64_t))(*(void *)v16 + 680LL))( v16,  ((unint64_t)(v13 & 4) << 16) | (v15 << 24) | ((unint64_t)(v13 & 3) << 8) | v14);
  }

  if (qword_1008D5F30 != -1) {
    dispatch_once(&qword_1008D5F30, &stru_1008A40B8);
  }
  v274[1] = 0LL;
  v274[0] = 0LL;
  char v178 = off_1008D5F28;
  sub_1005C8684((uint64_t)off_1008D5F28, a2, 1u, 1u, 0LL, 0LL, (unsigned __int8 *)v274);
  if (uuid_is_null((const unsigned __int8 *)v274))
  {
    uint64_t v17 = *(void *)(v183 + 8);
    if (*(_BYTE *)(v17 + 14))
    {
      uint64_t v18 = (os_log_s *)qword_1008F75B8;
      if (os_log_type_enabled((os_log_t)qword_1008F75B8, OS_LOG_TYPE_ERROR))
      {
        id v163 = sub_1005BFB9C(a2);
        __int16 v164 = (void *)objc_claimAutoreleasedReturnValue(v163);
        v265.n128_u32[0] = 138543362;
        *(unint64_t *)((char *)v265.n128_u64 + 4) = (unint64_t)v164;
        _os_log_error_impl( (void *)&_mh_execute_header,  v18,  OS_LOG_TYPE_ERROR,  "Failed to get UUID for device %{public}@ that caused AP wakeup",  (uint8_t *)&v265,  0xCu);

        uint64_t v17 = *(void *)(v183 + 8);
      }

      __n128 v265 = 0uLL;
      *(void *)&v266[0] = 0LL;
      if (*(char *)(v17 + 39) < 0)
      {
        sub_100024238(&v236, *(void **)(v17 + 16), *(void *)(v17 + 24));
      }

      else
      {
        __int128 v236 = *(_OWORD *)(v17 + 16);
        v237[0] = *(void *)(v17 + 32);
      }

      uint64_t v24 = HIBYTE(v237[0]);
      if (v237[0] < 0) {
        uint64_t v24 = *((void *)&v236 + 1);
      }
      if (v24)
      {
        uint64_t v25 = *(void *)(v183 + 8);
        if (*(char *)(v25 + 39) < 0)
        {
          sub_100024238(&v265, *(void **)(v25 + 16), *(void *)(v25 + 24));
        }

        else
        {
          __n128 v265 = *(__n128 *)(v25 + 16);
          *(void *)&v266[0] = *(void *)(v25 + 32);
        }
      }

      else
      {
        sub_10002418C(&v265, "Unknown");
      }

      if (SHIBYTE(v237[0]) < 0) {
        operator delete((void *)v236);
      }
      if (*(_BYTE *)(*(void *)(v183 + 8) + 367LL)) {
        uint64_t v34 = 2LL;
      }
      else {
        uint64_t v34 = 1LL;
      }
      uint64_t v35 = sub_1002E9074();
      unint64_t v36 = *(unsigned int **)(*(void *)(v183 + 8) + 56LL);
      __int128 v253 = &off_10087FAA8;
      __int128 v254 = v36;
      if (v36) {
        sub_1002CD1E0((uint64_t)v36);
      }
      id v37 = sub_1005BFB9C(a2);
      id v38 = objc_claimAutoreleasedReturnValue(v37);
      id v39 = [v38 UTF8String];
      if ((SBYTE7(v266[0]) & 0x80u) == 0) {
        __int16 v40 = &v265;
      }
      else {
        __int16 v40 = (__n128 *)v265.n128_u64[0];
      }
      (*(void (**)(uint64_t, uint64_t (***)(), uint64_t, const char *, id, __n128 *))(*(void *)v35 + 32LL))( v35,  &v253,  v34,  "com.apple.bluetoothd",  v39,  v40);

      __int128 v253 = &off_10087FAA8;
      if (v254) {
        sub_1002CD254(v254);
      }
      if (SBYTE7(v266[0]) < 0) {
        operator delete((void *)v265.n128_u64[0]);
      }
    }

    goto LABEL_324;
  }

  int v19 = sub_100241F94((const unsigned __int8 *)v274);
  uint64_t v20 = (void *)objc_claimAutoreleasedReturnValue(v19);
  char v21 = *(_DWORD *)(*(void *)(v183 + 8) + 312LL) != 0;
  unsigned __int8 v179 = v20;
  sub_1005D9B20((uint64_t)v178, v20, v21);
  uint64_t v22 = *(void *)(v183 + 8);
  if (*(_BYTE *)(v22 + 304)) {
    char v23 = 1;
  }
  else {
    char v23 = *(_BYTE *)(v22 + 305) != 0;
  }
  sub_1005D9BA8((uint64_t)v178, v179, v23);
  uint64_t v26 = *(void *)(v183 + 8);
  if (*(_BYTE *)(v26 + 13))
  {
    sub_1005D1CF8((uint64_t)v178, v179, 1);
    uint64_t v26 = *(void *)(v183 + 8);
  }

  sub_1005D4644((uint64_t)v178, v179, *(_BYTE *)(v26 + 12));
  uint64_t v27 = *(void *)(v183 + 8);
  if (*(_WORD *)(v27 + 40))
  {
    sub_1005CCDEC((uint64_t)v178, v179, *(_WORD *)(v27 + 40));
    uint64_t v27 = *(void *)(v183 + 8);
  }

  if (*(void *)(v27 + 128))
  {
    __int128 v272 = xmmword_1006BDB08;
    int v273 = 0;
    sub_100634334(&v265, (__n128 *)&v272);
    uint64_t v28 = sub_100051D00(v27 + 112, (unsigned __int8 *)&v265);
    if (v27 + 120 != v28)
    {
      uint64_t v29 = v28 + 56;
      if ((unint64_t)sub_10056AAD8(v28 + 56) >= 3)
      {
        uint64_t v30 = sub_10056AAF0(v29);
        if (*(_WORD *)(v30 + 1))
        {
          int v31 = (void *)objc_claimAutoreleasedReturnValue( +[NSString stringWithFormat:]( &OBJC_CLASS___NSString,  "stringWithFormat:",  @"%d",  *(unsigned __int16 *)(v30 + 1)));
          sub_1005CEE7C((uint64_t)v178, v179, @"GHSDeviceType", v31);
          if (os_log_type_enabled((os_log_t)qword_1008F75B8, OS_LOG_TYPE_DEBUG)) {
            sub_10069D158();
          }
        }
      }
    }
  }

  if (*((_BYTE *)v182 + 3256))
  {
    uint64_t v32 = *(void *)(v183 + 8);
    if (*(_BYTE *)(v32 + 367))
    {
      int v33 = *(unsigned __int8 *)(v32 + 365);
      if (v33 == 1)
      {
        ++*((_DWORD *)v182 + 811);
        if (os_log_type_enabled((os_log_t)qword_1008F75B8, OS_LOG_TYPE_DEBUG)) {
          sub_10069D0F8();
        }
      }

      else if (!v33)
      {
        ++*((_DWORD *)v182 + 810);
        if (os_log_type_enabled((os_log_t)qword_1008F75B8, OS_LOG_TYPE_DEBUG)) {
          sub_10069D098();
        }
      }
    }
  }

  sub_1005D1D80((uint64_t)v178, v179);
  sub_1005D714C((uint64_t)v178, v179, *(double *)(*(void *)(v183 + 8) + 240LL));
  if (*(_BYTE *)(*(void *)(v183 + 8) + 367LL)) {
    sub_1005D1E90((uint64_t)v178, v179, a5);
  }
  sub_1005DA008((uint64_t)v178, v179, a5);
  v265.n128_u64[0] = (unint64_t)v274;
  BOOL v41 = sub_10060F76C( (uint64_t **)v182 + 258,  (unsigned __int8 *)v274,  (uint64_t)&unk_1006C2518,  (const unsigned __int8 *__attribute__((__org_typedef(uuid_t))) *)&v265);
  int v42 = v41 + 48;
  switch(a3)
  {
    case 0:
    case 2:
    case 3:
      if (a6) {
        uint64_t v43 = (uint64_t)(v41 + 96);
      }
      else {
        uint64_t v43 = (uint64_t)(v41 + 48);
      }
      goto LABEL_62;
    case 1:
      if (a6) {
        uint64_t v43 = (uint64_t)(v41 + 96);
      }
      else {
        uint64_t v43 = (uint64_t)(v41 + 64);
      }
      goto LABEL_62;
    case 4:
      if (a6) {
        uint64_t v43 = (uint64_t)(v41 + 112);
      }
      else {
        uint64_t v43 = (uint64_t)(v41 + 80);
      }
LABEL_62:
      sub_10002EAC8(v43, v183);
      break;
    default:
      break;
  }

  int v252 = 0LL;
  __int128 v251 = 0LL;
  sub_1005F8878(v42, &v251);
  v252[117] |= *(_DWORD *)(*(void *)(v183 + 8) + 468LL);
  uint64_t v44 = sub_1001FD17C(v256, (uint64_t)"Found device ", 14LL);
  __n128 v265 = 0u;
  memset(v266, 0, 21);
  uuid_unparse_upper((const unsigned __int8 *)v274, (char *)&v265);
  sub_10002418C(&v236, (char *)&v265);
  if (v237[0] >= 0) {
    int v45 = &v236;
  }
  else {
    int v45 = (__int128 *)v236;
  }
  if (v237[0] >= 0) {
    uint64_t v46 = HIBYTE(v237[0]);
  }
  else {
    uint64_t v46 = *((void *)&v236 + 1);
  }
  int v47 = sub_1001FD17C(v44, (uint64_t)v45, v46);
  unint64_t v48 = sub_1001FD17C(v47, (uint64_t)" ", 1LL);
  sub_1005BFC20(a2, (std::stringbuf::string_type *)&v265);
  if ((SBYTE7(v266[0]) & 0x80u) == 0) {
    unint64_t v49 = &v265;
  }
  else {
    unint64_t v49 = (__n128 *)v265.n128_u64[0];
  }
  if ((SBYTE7(v266[0]) & 0x80u) == 0) {
    uint64_t v50 = BYTE7(v266[0]);
  }
  else {
    uint64_t v50 = v265.n128_i64[1];
  }
  uint64_t v51 = sub_1001FD17C(v48, (uint64_t)v49, v50);
  char v52 = sub_1001FD17C(v51, (uint64_t)" RSSI:", 6LL);
  std::to_string(__dst, a5);
  if ((__dst[0].__r_.__value_.__s.__size_ & 0x80u) == 0) {
    dispatch_time_t v53 = __dst;
  }
  else {
    dispatch_time_t v53 = (std::string *)__dst[0].__r_.__value_.__r.__words[0];
  }
  if ((__dst[0].__r_.__value_.__s.__size_ & 0x80u) == 0) {
    uint64_t size = __dst[0].__r_.__value_.__s.__size_;
  }
  else {
    uint64_t size = __dst[0].__r_.__value_.__l.__size_;
  }
  uint64_t v55 = sub_1001FD17C(v52, (uint64_t)v53, size);
  double v56 = sub_1001FD17C(v55, (uint64_t)" with data:", 11LL);
  double v57 = (const char *)&v191;
  sub_10056C434((uint64_t)v252, (std::stringbuf::string_type *)&v191);
  if (SBYTE7(v192) < 0) {
    double v57 = (const char *)v191;
  }
  size_t v58 = strlen(v57);
  sub_1001FD17C(v56, (uint64_t)v57, v58);
  if (SBYTE7(v192) < 0) {
    operator delete((void *)v191);
  }
  if (SBYTE7(v266[0]) < 0) {
    operator delete((void *)v265.n128_u64[0]);
  }
  if (SHIBYTE(v237[0]) < 0) {
    operator delete((void *)v236);
  }
  if (*((char *)v252 + 39) < 0)
  {
    sub_100024238(&v265, *((void **)v252 + 2), *((void *)v252 + 3));
  }

  else
  {
    __n128 v265 = *((__n128 *)v252 + 1);
    *(void *)&v266[0] = *((void *)v252 + 4);
  }

  if (SBYTE7(v266[0]) < 0)
  {
    unint64_t v59 = v265.n128_u64[1];
    operator delete((void *)v265.n128_u64[0]);
    if (!v59) {
      goto LABEL_114;
    }
  }

  else if (!BYTE7(v266[0]))
  {
    goto LABEL_114;
  }

  if (*((char *)v252 + 39) < 0)
  {
    sub_100024238(&v249, *((void **)v252 + 2), *((void *)v252 + 3));
  }

  else
  {
    __int128 v249 = *((_OWORD *)v252 + 1);
    uint64_t v250 = *((void *)v252 + 4);
  }

  sub_1005C9550((uint64_t)v178, (unsigned __int8 *)v274, (uint64_t)&v249, 1);
  if (SHIBYTE(v250) < 0) {
    operator delete((void *)v249);
  }
  unsigned int v60 = sub_1001FD17C(v256, (uint64_t)" Setting name to ", 17LL);
  if (*((char *)v252 + 39) < 0)
  {
    sub_100024238(&v265, *((void **)v252 + 2), *((void *)v252 + 3));
  }

  else
  {
    __n128 v265 = *((__n128 *)v252 + 1);
    *(void *)&v266[0] = *((void *)v252 + 4);
  }

  if ((SBYTE7(v266[0]) & 0x80u) == 0) {
    int v61 = &v265;
  }
  else {
    int v61 = (__n128 *)v265.n128_u64[0];
  }
  if ((SBYTE7(v266[0]) & 0x80u) == 0) {
    uint64_t v62 = BYTE7(v266[0]);
  }
  else {
    uint64_t v62 = v265.n128_i64[1];
  }
  sub_1001FD17C(v60, (uint64_t)v61, v62);
  if (SBYTE7(v266[0]) < 0) {
    operator delete((void *)v265.n128_u64[0]);
  }
LABEL_114:
  uint64_t v63 = v252;
  *((void *)v252 + 25) = a2;
  sub_10056BBA4((uint64_t)v63, a5);
  double v64 = v252;
  uint64_t v65 = *(void *)(v183 + 8);
  *(_WORD *)((char *)v252 + 219) = *(_WORD *)(v65 + 219);
  *((void *)v64 + 30) = *(void *)(v65 + 240);
  *((void *)v64 + 31) = *(void *)(v65 + 248);
  *(_WORD *)((char *)v64 + 341) = *(_WORD *)(v65 + 341);
  *(unsigned int *)((char *)v64 + 365) = *(_DWORD *)(v65 + 365);
  *((_BYTE *)v64 + 369) = *(_BYTE *)(v65 + 369);
  *((_BYTE *)v64 + 14) = *(_BYTE *)(v65 + 14);
  *((_BYTE *)v64 + 306) = *(_BYTE *)(v65 + 306);
  v64[111] = *(_DWORD *)(v65 + 444);
  uint64_t v66 = *(void *)(v65 + 208);
  if (v66) {
    *((void *)v64 + 26) = v66;
  }
  if (sub_10056AAD8(v65 + 136) == 7)
  {
    id v67 = sub_1001FD17C(v256, (uint64_t)" LE BT ADDR len:", 16LL);
    uint64_t v68 = sub_10056AAD8(*(void *)(v183 + 8) + 136LL);
    std::ostream::operator<<(v67, v68);
    sub_10002EAC8((uint64_t)(v252 + 34), *(void *)(v183 + 8) + 136LL);
  }

  if (v182[252]) {
    sub_1005F894C((uint64_t)v182, (uint64_t)&v251, a5);
  }
  sub_1005F8B2C((uint64_t)v182, a2, (uint64_t)&v251);
  sub_1005F93C8((uint64_t)v182, a2, (uint64_t)&v251);
  if (*((_BYTE *)v252 + 361) || *((_BYTE *)v252 + 362))
  {
    sub_1005DA0E8((uint64_t)v178, v179, 1);
    if (*((_BYTE *)v252 + 361))
    {
      double v69 = sub_1001FD17C(v256, (uint64_t)" ProximityPairing Status address:", 33LL);
      sub_1005BF8CC(a2, (std::stringbuf::string_type *)&v265);
      if ((SBYTE7(v266[0]) & 0x80u) == 0) {
        double v70 = &v265;
      }
      else {
        double v70 = (__n128 *)v265.n128_u64[0];
      }
      if ((SBYTE7(v266[0]) & 0x80u) == 0) {
        uint64_t v71 = BYTE7(v266[0]);
      }
      else {
        uint64_t v71 = v265.n128_i64[1];
      }
      double v72 = sub_1001FD17C(v69, (uint64_t)v70, v71);
      unsigned int v73 = sub_1001FD17C(v72, (uint64_t)" isLastConnectedHost:", 21LL);
      if (*((_BYTE *)v252 + 363)) {
        int v74 = "YES";
      }
      else {
        int v74 = "NO";
      }
      if (*((_BYTE *)v252 + 363)) {
        uint64_t v75 = 3LL;
      }
      else {
        uint64_t v75 = 2LL;
      }
      sub_1001FD17C(v73, (uint64_t)v74, v75);
      if (SBYTE7(v266[0]) < 0) {
        operator delete((void *)v265.n128_u64[0]);
      }
      v244[0] = _NSConcreteStackBlock;
      v244[1] = 3321888768LL;
      v244[2] = sub_1005F997C;
      v244[3] = &unk_1008A3B40;
      unint64_t v246 = a2;
      id v245 = v179;
      int v247 = &off_10087FAE8;
      __int128 v248 = v252;
      if (v252) {
        sub_1002CD1E0((uint64_t)v252);
      }
      sub_1005EBB90((os_unfair_lock_s *)v182 + 468, v244);
      int v247 = &off_10087FAE8;
      if (v248) {
        sub_1002CD254(v248);
      }
    }
  }

  if (os_log_type_enabled((os_log_t)qword_1008F75B8, OS_LOG_TYPE_DEBUG))
  {
    std::stringbuf::str(&v243, (const std::stringbuf *)&v256[1]);
    sub_10069D04C();
  }

  uint64_t v271 = 0LL;
  __int128 v269 = 0u;
  memset(v270, 0, sizeof(v270));
  __int128 v267 = 0u;
  __int128 v268 = 0u;
  memset(v266, 0, sizeof(v266));
  __n128 v265 = 0u;
  sub_1001FCFC8((uint64_t)&v265);
  uint64_t v242 = 0LL;
  __int128 v240 = 0u;
  memset(v241, 0, sizeof(v241));
  __int128 v238 = 0u;
  __int128 v239 = 0u;
  memset(v237, 0, sizeof(v237));
  __int128 v236 = 0u;
  sub_1001FCFC8((uint64_t)&v236);
  v235[1] = 0LL;
  v235[0] = 0LL;
  std::stringbuf::string_type v175 = (uint64_t *)v235;
  __int16 v234 = (uint64_t *)v235;
  uint64_t v76 = (void *)v182[255];
  __int128 v181 = v182 + 256;
  if (v76 != v182 + 256)
  {
    int v185 = &v276;
    __int128 v180 = (char *)&v277 + 8;
    p_uint64_t size = &v233.__r_.__value_.__l.__size_;
    __int16 v168 = &v216;
    __int128 v169 = (os_unfair_lock_s *)(v182 + 238);
    BOOL v176 = (uint64_t *)v222;
    int v165 = &v225;
    __int16 v166 = (os_unfair_lock_s *)(v182 + 234);
    int v167 = v230;
    __int128 v170 = v221;
    __int128 v171 = (uint64_t *)v231;
    int v173 = v266;
    while (1)
    {
      uint64_t v78 = v76[4];
      uint64_t v77 = v76[5];
      __int128 v191 = 0uLL;
      *(void *)&__int128 v192 = 0LL;
      uint64_t v279 = 0LL;
      __int128 v277 = 0u;
      __int128 v278 = 0u;
      __int128 v276 = 0u;
      memset(__dst, 0, sizeof(__dst));
      uint64_t v79 = *(void *)(v77 + 8);
      __int128 v80 = *(_OWORD *)(v79 + 296);
      *(_OWORD *)&__dst[0].__r_.__value_.__l.__data_ = *(_OWORD *)(v79 + 280);
      *(_OWORD *)&__dst[0].__r_.__value_.__r.__words[2] = v80;
      *(_OWORD *)((char *)__dst[1].__r_.__value_.__r.__words + 4) = *(_OWORD *)(v79 + 308);
      uint64_t v81 = v185;
      *((void *)v185 + 1) = 0LL;
      *((void *)v81 + 2) = 0LL;
      *(void *)uint64_t v81 = 0LL;
      sub_10060E68C( v81,  *(void *)(v79 + 328),  *(void *)(v79 + 336),  0xAAAAAAAAAAAAAAABLL * ((uint64_t)(*(void *)(v79 + 336) - *(void *)(v79 + 328)) >> 5));
      uint64_t v82 = v180;
      *(void *)__int128 v180 = 0LL;
      *((void *)v82 + 1) = 0LL;
      *((void *)v82 + 2) = 0LL;
      sub_100050EE8( v82,  *(__int128 **)(v79 + 352),  *(__int128 **)(v79 + 360),  0xCCCCCCCCCCCCCCCDLL * ((uint64_t)(*(void *)(v79 + 360) - *(void *)(v79 + 352)) >> 2));
      LOBYTE(v279) = *(_BYTE *)(v79 + 376);
      id v83 = (id)objc_claimAutoreleasedReturnValue( +[NSMutableString stringWithString:]( &OBJC_CLASS___NSMutableString,  "stringWithString:",  @"default"));
      if (!__dst[0].__r_.__value_.__s.__data_[8] || !__dst[0].__r_.__value_.__s.__data_[5])
      {
        id v184 = v83;
        int v84 = sub_100611390(v77, (unsigned __int8 *)v274, (uint64_t)&v251, (void **)&v191, v83);
        id v83 = v184;
        if (v84) {
          break;
        }
      }

LABEL_206:
  if (os_log_type_enabled((os_log_t)qword_1008F75B8, OS_LOG_TYPE_DEBUG))
  {
    std::stringbuf::str(&v233, (const std::stringbuf *)((char *)v266 + 8));
    sub_10069D000();
  }

  v202[0] = _NSConcreteStackBlock;
  v202[1] = 3321888768LL;
  v202[2] = sub_1005F9B34;
  v202[3] = &unk_1008A3BB0;
  int v185 = v179;
  __int128 v203 = v185;
  __int128 v204 = &off_10087FAE8;
  __int128 v205 = v252;
  if (v252) {
    sub_1002CD1E0((uint64_t)v252);
  }
  sub_1005EBB90((os_unfair_lock_s *)v182 + 468, v202);
  uint64_t v115 = v183;
  uint64_t v116 = *(void *)(v183 + 8);
  if (*(_BYTE *)(v116 + 14))
  {
    __int16 v117 = sub_1005F9B50(v114, v116 + 48);
    id v184 = (id)objc_claimAutoreleasedReturnValue(v117);
    uint64_t v118 = sub_10056AAD8(*(void *)(v115 + 8) + 48LL);
    uint64_t v182 = &v165;
    size_t v119 = v118 + 5;
    uint64_t v121 = (char *)&v165 - ((__chkstk_darwin(v118, v120) + 20) & 0xFFFFFFFFFFFFFFF0LL);
    bzero(v121, v119);
    *(_WORD *)uint64_t v121 = 258;
    v121[2] = v172;
    v121[3] = sub_10056AAD8(*(void *)(v115 + 8) + 48LL) + 1;
    v121[4] = -1;
    uint64_t v122 = *(void *)(v115 + 8) + 48LL;
    size_t v123 = sub_10056AAD8(v122);
    sub_10056ACE0(v122, v121 + 5, 0LL, v123);
    int v200 = 0LL;
    __int16 v201 = 0LL;
    sub_10056AB04(&v200, v121, v119);
    uint64_t v213 = 0LL;
    __n128 v212 = 0LL;
    uint64_t v214 = 0LL;
    id v124 = objc_claimAutoreleasedReturnValue([v185 UUIDString]);
    sub_10002418C(&v212, (char *)[v124 UTF8String]);

    __int128 v206 = 0uLL;
    uint64_t v207 = 0LL;
    else {
      __dst[0] = *(std::string *)(v252 + 4);
    }
    uint64_t v125 = v183;
    std::string::size_type v126 = __dst[0].__r_.__value_.__s.__size_;
    if ((__dst[0].__r_.__value_.__s.__size_ & 0x80u) != 0) {
      std::string::size_type v126 = __dst[0].__r_.__value_.__l.__size_;
    }
    if (v126)
    {
      if (*((char *)v252 + 39) < 0)
      {
        sub_100024238(&v206, *((void **)v252 + 2), *((void *)v252 + 3));
      }

      else
      {
        __int128 v206 = *((_OWORD *)v252 + 1);
        uint64_t v207 = *((void *)v252 + 4);
      }
    }

    else
    {
      sub_1005CC0D4((uint64_t)v178, v185, (uint64_t)&v206);
    }

    if (*(_BYTE *)(*(void *)(v125 + 8) + 367LL))
    {
      if (qword_1008D92A8 != -1) {
        dispatch_once(&qword_1008D92A8, &stru_1008A4138);
      }
      id v127 = sub_10064D6E0(qword_1008D92A0, v185);
      uint64_t v128 = (void *)objc_claimAutoreleasedReturnValue(v127);
      if ([v128 count])
      {
        __int128 v198 = 0u;
        __int128 v199 = 0u;
        __int128 v196 = 0u;
        __int128 v197 = 0u;
        id v129 = v128;
        id v130 = [v129 countByEnumeratingWithState:&v196 objects:v263 count:16];
        if (v130)
        {
          uint64_t v131 = *(void *)v197;
          do
          {
            for (uint64_t k = 0LL; k != v130; uint64_t k = (char *)k + 1)
            {
              if (*(void *)v197 != v131) {
                objc_enumerationMutation(v129);
              }
              id v133 = *(id *)(*((void *)&v196 + 1) + 8LL * (void)k);
              id v134 = (const char *)[v133 UTF8String];
              size_t v135 = strlen(v134);
              uint64_t v136 = sub_1001FD17C(v237, (uint64_t)v134, v135);
              sub_1001FD17C(v136, (uint64_t)",", 1LL);
            }

            id v130 = [v129 countByEnumeratingWithState:&v196 objects:v263 count:16];
          }

          while (v130);
        }

        __int128 v191 = 0uLL;
        std::ostream::sentry::sentry(&v191, v237);
        int v137 = (char *)v237 + *(void *)(v237[0] - 24LL);
        if ((v137[32] & 5) == 0)
        {
          (*(void (**)(std::string *__return_ptr, void, uint64_t, uint64_t, uint64_t))(**((void **)v137 + 5)
                                                                                               + 32LL))( __dst,  *((void *)v137 + 5),  -1LL,  1LL,  16LL);
          if (v280 == -1) {
            std::ios_base::clear( (std::ios_base *)((char *)v237 + *(void *)(v237[0] - 24LL)),  *(_DWORD *)((char *)&v237[4] + *(void *)(v237[0] - 24LL)) | 4);
          }
        }

        std::ostream::sentry::~sentry(&v191);
        __dst[0].__r_.__value_.__s.__data_[0] = 0;
        sub_1001FD17C(v237, (uint64_t)__dst, 1LL);
      }

      uint64_t v138 = sub_1002E9074();
      size_t v139 = __dst;
      std::stringbuf::str(__dst, (const std::stringbuf *)&v237[1]);
      if ((__dst[0].__r_.__value_.__s.__size_ & 0x80u) != 0) {
        size_t v139 = (std::string *)__dst[0].__r_.__value_.__r.__words[0];
      }
      __int128 v194 = &off_10087FAA8;
      __int128 v195 = v201;
      if (v201) {
        sub_1002CD1E0((uint64_t)v201);
      }
      (*(void (**)(uint64_t, uint64_t, std::string *, __int128 *, uint64_t (***)()))(*(void *)v138 + 40LL))( v138,  2LL,  v139,  v185,  &v194);
      __int128 v194 = &off_10087FAA8;
      if (v195) {
        sub_1002CD254(v195);
      }

LABEL_306:
      __int128 v157 = (os_log_s *)qword_1008F75B8;
      if (os_log_type_enabled((os_log_t)qword_1008F75B8, OS_LOG_TYPE_DEFAULT))
      {
        LODWORD(__dst[0].__r_.__value_.__l.__data_) = 138412290;
        *(std::string::size_type *)((char *)__dst[0].__r_.__value_.__r.__words + 4) = (std::string::size_type)v184;
        _os_log_impl( (void *)&_mh_execute_header,  v157,  OS_LOG_TYPE_DEFAULT,  "wakeup AdvDeviceType = %@ ",  (uint8_t *)__dst,  0xCu);
      }

      if (SHIBYTE(v207) < 0) {
        operator delete((void *)v206);
      }
      if (SHIBYTE(v214) < 0) {
        operator delete(v212);
      }
      int v200 = &off_10087FAA8;
      if (v201) {
        sub_1002CD254(v201);
      }

      goto LABEL_315;
    }

    int v140 = v234;
    if (v234 != v175)
    {
      do
      {
        __int128 v192 = 0u;
        __int128 v193 = 0u;
        __int128 v191 = 0u;
        sub_100534300(&v191, (__int128 *)v140 + 2);
        int v188 = 0LL;
        __int128 v189 = 0LL;
        uint64_t v190 = 0LL;
        sub_100291924((uint64_t *)&v188, (const void ***)&v192 + 1);
        if (v190)
        {
          if ((SBYTE7(v192) & 0x80u) == 0) {
            uint64_t v141 = &v191;
          }
          else {
            uint64_t v141 = (__int128 *)v191;
          }
          if ((SBYTE7(v192) & 0x80u) == 0) {
            uint64_t v142 = BYTE7(v192);
          }
          else {
            uint64_t v142 = *((void *)&v191 + 1);
          }
          id v143 = sub_1001FD17C(v237, (uint64_t)v141, v142);
          sub_1001FD17C(v143, (uint64_t)"(", 1LL);
          id v144 = v188;
          if (v188 != &v189)
          {
            do
            {
              memset(__dst, 0, 24);
              else {
                __dst[0] = *(std::string *)(v144 + 4);
              }
              if ((__dst[0].__r_.__value_.__s.__size_ & 0x80u) == 0) {
                char v145 = __dst;
              }
              else {
                char v145 = (std::string *)__dst[0].__r_.__value_.__r.__words[0];
              }
              if ((__dst[0].__r_.__value_.__s.__size_ & 0x80u) == 0) {
                uint64_t v146 = __dst[0].__r_.__value_.__s.__size_;
              }
              else {
                uint64_t v146 = __dst[0].__r_.__value_.__l.__size_;
              }
              int v147 = sub_1001FD17C(v237, (uint64_t)v145, v146);
              sub_1001FD17C(v147, (uint64_t)",", 1LL);
              unint64_t v148 = v144[1];
              if (v148)
              {
                do
                {
                  int v149 = (char **)v148;
                  unint64_t v148 = *(char **)v148;
                }

                while (v148);
              }

              else
              {
                do
                {
                  int v149 = (char **)v144[2];
                  BOOL v111 = *v149 == (char *)v144;
                  id v144 = v149;
                }

                while (!v111);
              }

              id v144 = v149;
            }

            while (v149 != &v189);
          }

          v262[1] = 0LL;
          v262[0] = 0LL;
          std::ostream::sentry::sentry(v262, v237);
          uint64_t v150 = (char *)v237 + *(void *)(v237[0] - 24LL);
          if ((v150[32] & 5) == 0)
          {
            (*(void (**)(std::string *__return_ptr, void, uint64_t, uint64_t, uint64_t))(**((void **)v150 + 5)
                                                                                                 + 32LL))( __dst,  *((void *)v150 + 5),  -1LL,  1LL,  16LL);
            if (v280 == -1) {
              std::ios_base::clear( (std::ios_base *)((char *)v237 + *(void *)(v237[0] - 24LL)),  *(_DWORD *)((char *)&v237[4] + *(void *)(v237[0] - 24LL)) | 4);
            }
          }

          std::ostream::sentry::~sentry(v262);
          sub_1001FD17C(v237, (uint64_t)"),", 2LL);
        }

        sub_10023E78C((uint64_t)&v188, v189);
        sub_10023E78C((uint64_t)&v192 + 8, (char *)v193);
        if (SBYTE7(v192) < 0) {
          operator delete((void *)v191);
        }
        int v151 = (uint64_t *)v140[1];
        if (v151)
        {
          do
          {
            __int128 v152 = v151;
            int v151 = (uint64_t *)*v151;
          }

          while (v151);
        }

        else
        {
          do
          {
            __int128 v152 = (uint64_t *)v140[2];
            BOOL v111 = *v152 == (void)v140;
            int v140 = v152;
          }

          while (!v111);
        }

        int v140 = v152;
      }

      while (v152 != v175);
    }

    std::stringbuf::str(__dst, (const std::stringbuf *)&v237[1]);
    if ((char)__dst[0].__r_.__value_.__s.__size_ < 0)
    {
      std::string::size_type v154 = __dst[0].__r_.__value_.__l.__size_;
      operator delete(__dst[0].__r_.__value_.__l.__data_);
      if (v154)
      {
LABEL_291:
        __int128 v191 = 0uLL;
        std::ostream::sentry::sentry(&v191, v237);
        __int128 v153 = (char *)v237 + *(void *)(v237[0] - 24LL);
        if ((v153[32] & 5) == 0)
        {
          (*(void (**)(std::string *__return_ptr, void, uint64_t, uint64_t, uint64_t))(**((void **)v153 + 5)
                                                                                               + 32LL))( __dst,  *((void *)v153 + 5),  -1LL,  1LL,  16LL);
          if (v280 == -1) {
            std::ios_base::clear( (std::ios_base *)((char *)v237 + *(void *)(v237[0] - 24LL)),  *(_DWORD *)((char *)&v237[4] + *(void *)(v237[0] - 24LL)) | 4);
          }
        }

        std::ostream::sentry::~sentry(&v191);
        __dst[0].__r_.__value_.__s.__data_[0] = 0;
        sub_1001FD17C(v237, (uint64_t)__dst, 1LL);
        goto LABEL_297;
      }
    }

    else if (__dst[0].__r_.__value_.__s.__size_)
    {
      goto LABEL_291;
    }

    sub_1001FD17C(v237, (uint64_t)"com.apple.bluetoothd", 20LL);
LABEL_297:
    uint64_t v155 = sub_1002E9074();
    std::stringbuf::str(__dst, (const std::stringbuf *)&v237[1]);
    if ((__dst[0].__r_.__value_.__s.__size_ & 0x80u) == 0) {
      int v156 = __dst;
    }
    else {
      int v156 = (std::string *)__dst[0].__r_.__value_.__r.__words[0];
    }
    uint64_t v186 = &off_10087FAA8;
    unint64_t v187 = v201;
    if (v201) {
      sub_1002CD1E0((uint64_t)v201);
    }
    (*(void (**)(uint64_t, uint64_t, std::string *, __int128 *, uint64_t (***)()))(*(void *)v155 + 40LL))( v155,  1LL,  v156,  v185,  &v186);
    uint64_t v186 = &off_10087FAA8;
    if (v187) {
      sub_1002CD254(v187);
    }
    goto LABEL_306;
  }

LABEL_315:
  __int128 v204 = &off_10087FAE8;
  if (v205) {
    sub_1002CD254(v205);
  }

  sub_100533DF4((uint64_t)&v234, v235[0]);
  *(void *)((char *)&v237[-2]
  v237[0] = v159;
  if (SHIBYTE(v239) < 0) {
    operator delete(*((void **)&v238 + 1));
  }
  std::streambuf::~streambuf(&v237[1]);
  std::ios::~ios(v241);
  v265.n128_u64[0] = v158;
  *(unint64_t *)((char *)v265.n128_u64 + *(void *)(v158 - 24)) = v160;
  *(void *)&v266[0] = v159;
  if (SHIBYTE(v268) < 0) {
    operator delete(*((void **)&v267 + 1));
  }
  std::streambuf::~streambuf((char *)v266 + 8);
  std::ios::~ios(v270);
  __int128 v251 = &off_10087FAE8;
  if (v252) {
    sub_1002CD254(v252);
  }

LABEL_324:
  *(void *)((char *)&v256[-2]
  v256[0] = v161;
  if (SHIBYTE(v258) < 0) {
    operator delete(*((void **)&v257 + 1));
  }
  std::streambuf::~streambuf(&v256[1]);
  return std::ios::~ios(v260);
}

void sub_1005F82F0(_Unwind_Exception *a1)
{
  *(void *)(v1 + 344) = &off_10087FAA8;
  uint64_t v3 = *(unsigned int **)(v1 + 352);
  if (v3) {
    sub_1002CD254(v3);
  }

  *(void *)(v1 + 400) = &off_10087FAE8;
  int v4 = *(unsigned int **)(v1 + 408);
  if (v4) {
    sub_1002CD254(v4);
  }

  sub_100533DF4(v1 + 824, *(void **)(v1 + 832));
  sub_1001FD0F4(v1 + 848);
  sub_1001FD0F4(v1 + 1856);
  *(void *)(v1 + 124_Block_object_dispose(va, 8) = &off_10087FAE8;
  BOOL v5 = *(unsigned int **)(v1 + 1256);
  if (v5) {
    sub_1002CD254(v5);
  }

  sub_1001FD0F4(v1 + 1280);
  _Unwind_Resume(a1);
}

double sub_1005F8878@<D0>(void *a1@<X0>, void *a2@<X8>)
{
  *a2 = 0LL;
  a2[1] = 0LL;
  int v4 = operator new(0x1E0uLL);
  double result = sub_10056B368((uint64_t)v4);
  *a2 = &off_10087FAE8;
  a2[1] = v4;
  if (a1[1]) {
    double result = sub_10056B36C((uint64_t)v4, (uint64_t)a1);
  }
  if (a1[3]) {
    double result = sub_10056B36C((uint64_t)v4, (uint64_t)(a1 + 2));
  }
  if (a1[5]) {
    double result = sub_10056B36C((uint64_t)v4, (uint64_t)(a1 + 4));
  }
  if (a1[7]) {
    double result = sub_10056B36C((uint64_t)v4, (uint64_t)(a1 + 6));
  }
  if (a1[9]) {
    return sub_10056B36C((uint64_t)v4, (uint64_t)(a1 + 8));
  }
  return result;
}

void sub_1005F8924(_Unwind_Exception *a1)
{
}

void sub_1005F894C(uint64_t a1, uint64_t a2, int a3)
{
  if ((unint64_t)sub_10056AAD8(*(void *)(a2 + 8) + 48LL) >= 0x19)
  {
    uint64_t v6 = sub_10056AAF0(*(void *)(a2 + 8) + 48LL);
    BOOL v7 = *(_WORD *)v6 == 76 && *(_BYTE *)(v6 + 2) == 2;
    if (v7)
    {
      uint64_t v8 = v6;
      if (*(unsigned __int8 *)(v6 + 3) >= 0x15u)
      {
        uint64_t v9 = sub_1002E6E9C();
        if ((*(int (**)(uint64_t))(*(void *)v9 + 3488LL))(v9) <= a3)
        {
          uint64_t v26 = 0LL;
          uint64_t v27 = 0LL;
          uint64_t v28 = 0LL;
          uint64_t v10 = *(void **)(a1 + 2000);
          if (v10 != (void *)(a1 + 2008))
          {
            do
            {
              BOOL v11 = (unsigned __int8 *)sub_10056AAF0((uint64_t)(v10 + 4));
              unint64_t v12 = sub_10056AAD8((uint64_t)(v10 + 4));
              __int16 v13 = (unsigned __int8 *)sub_10056AAF0((uint64_t)(v10 + 6));
              unint64_t v14 = sub_10056AAD8((uint64_t)(v10 + 6));
              if (v12 >= v14) {
                unint64_t v15 = v14;
              }
              else {
                unint64_t v15 = v12;
              }
              if (v15)
              {
                uint64_t v16 = (unsigned __int8 *)(v8 + 4);
                while (1)
                {
                  int v18 = *v16++;
                  int v17 = v18;
                  int v19 = *v13++;
                  int v20 = v19 & v17;
                  int v21 = *v11++;
                  if (v20 != v21) {
                    break;
                  }
                  if (!--v15) {
                    goto LABEL_17;
                  }
                }
              }

              else
              {
LABEL_17:
                sub_1005FAD84(&v26, (uint64_t)(v10 + 4));
              }

              uint64_t v22 = (void *)v10[1];
              if (v22)
              {
                do
                {
                  char v23 = v22;
                  uint64_t v22 = (void *)*v22;
                }

                while (v22);
              }

              else
              {
                do
                {
                  char v23 = (void *)v10[2];
                  BOOL v7 = *v23 == (void)v10;
                  uint64_t v10 = v23;
                }

                while (!v7);
              }

              uint64_t v10 = v23;
            }

            while (v23 != (void *)(a1 + 2008));
            uint64_t v24 = v26;
            uint64_t v25 = v27;
            if (v27 != v26)
            {
              do
              {
                sub_10061036C((uint64_t **)(a1 + 2000), v24);
                v24 += 32LL;
              }

              while (v24 != v25);
              sub_1005FAA88(a1);
            }
          }

          uint64_t v29 = (void **)&v26;
          sub_100610134(&v29);
        }
      }
    }
  }

void sub_1005F8AF8( _Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, void **a12)
{
  a12 = (void **)&a9;
  sub_100610134(&a12);
  _Unwind_Resume(a1);
}

void sub_1005F8B2C(uint64_t a1, unint64_t a2, uint64_t a3)
{
  if ((unint64_t)sub_10056AAD8(*(void *)(a3 + 8) + 48LL) >= 0x1D)
  {
    uint64_t v6 = (os_log_s *)qword_1008F75B8;
    if (os_log_type_enabled((os_log_t)qword_1008F75B8, OS_LOG_TYPE_DEFAULT))
    {
      if (qword_1008D5F30 != -1) {
        dispatch_once(&qword_1008D5F30, &stru_1008A40B8);
      }
      sub_1005C8684((uint64_t)off_1008D5F28, a2, 0, 1u, 0LL, 0LL, (unsigned __int8 *)v55);
      BOOL v7 = sub_100241F94((const unsigned __int8 *)v55);
      id v8 = (id)objc_claimAutoreleasedReturnValue(v7);
      sub_1005BFC20(a2, (std::stringbuf::string_type *)__p);
      if (__p[23] >= 0) {
        uint64_t v9 = __p;
      }
      else {
        uint64_t v9 = *(_BYTE **)__p;
      }
      *(_DWORD *)__int128 buf = 138412546;
      *(void *)&uint8_t buf[4] = v8;
      __int16 v45 = 2080;
      uint64_t v46 = v9;
      _os_log_impl( (void *)&_mh_execute_header,  v6,  OS_LOG_TYPE_DEFAULT,  "decryptProximityPairingPayload device:%@ address:%s",  buf,  0x16u);
      if ((__p[23] & 0x80000000) != 0) {
        operator delete(*(void **)__p);
      }
    }

    uint64_t v10 = sub_10056AAF0(*(void *)(a3 + 8) + 48LL);
    BOOL v11 = (unsigned __int8 *)v10;
    BOOL v12 = *(_WORD *)v10 == 76 && *(_BYTE *)(v10 + 2) == 7;
    if (v12 && *(_BYTE *)(v10 + 4) == 1)
    {
      v55[0] = 0LL;
      v55[1] = 0LL;
      if ((sub_10060D144(a1, a2, (uint64_t)v55) & 1) != 0)
      {
        size_t v13 = sub_10056AAD8(*(void *)(a3 + 8) + 48LL);
        unint64_t v14 = (char *)operator new[](v13);
        size_t v15 = sub_10056AAD8(*(void *)(a3 + 8) + 48LL);
        memcpy(v14, v11, v15);
        uint64_t v16 = (os_log_s *)qword_1008F7600;
        if (os_log_type_enabled((os_log_t)qword_1008F7600, OS_LOG_TYPE_INFO))
        {
          id v17 = sub_1005BFB9C(a2);
          int v18 = (void *)objc_claimAutoreleasedReturnValue(v17);
          *(void *)std::stringbuf::string_type __p = 0x1004100603LL;
          *(_WORD *)&__p[8] = 2096;
          *(void *)&__p[10] = v11 + 13;
          *(_WORD *)&__p[18] = 2114;
          *(void *)&__p[20] = v18;
          __int16 v49 = 2160;
          uint64_t v50 = 1752392040LL;
          __int16 v51 = 1041;
          int v52 = 16;
          __int16 v53 = 2097;
          uint64_t v54 = v55;
          _os_log_impl( (void *)&_mh_execute_header,  v16,  OS_LOG_TYPE_INFO,  "Decrypting payload %.16P for the device %{public}@ using key %{private, mask.hash}.16P",  __p,  0x36u);
        }

        v42[0] = BYTE5(a2);
        v42[1] = BYTE4(a2);
        v42[2] = BYTE3(a2);
        v42[3] = BYTE2(a2);
        v42[4] = BYTE1(a2);
        v42[5] = a2;
        if (qword_1008D5F50 != -1) {
          dispatch_once(&qword_1008D5F50, &stru_1008A4158);
        }
        int v19 = sub_1003FFEB0(off_1008D5F48, (uint64_t)v42, 1);
        int v20 = sub_1001C43F0((uint64_t)v55, (uint64_t)(v11 + 13), (uint64_t)(v14 + 13), 0xFFFFFFFFFFFFFFFBLL);
        int v21 = (os_log_s *)qword_1008F7600;
        if (v20)
        {
          if (os_log_type_enabled((os_log_t)qword_1008F7600, OS_LOG_TYPE_ERROR)) {
            sub_10069D28C();
          }
LABEL_72:
          uint64_t v34 = *(void *)(a3 + 8) + 48LL;
          size_t v35 = sub_10056AAD8(v34);
          sub_10056AB04(__p, v14, v35);
          sub_10002EAC8(v34, (uint64_t)__p);
          *(void *)std::stringbuf::string_type __p = &off_10087FAA8;
          if (*(void *)&__p[8]) {
            sub_1002CD254(*(unsigned int **)&__p[8]);
          }
          operator delete[](v14);
          return;
        }

        if (os_log_type_enabled((os_log_t)qword_1008F7600, OS_LOG_TYPE_INFO))
        {
          *(_DWORD *)std::stringbuf::string_type __p = 141558531;
          *(void *)&__p[4] = 1752392040LL;
          *(_WORD *)&_BYTE __p[12] = 1041;
          *(_DWORD *)&__p[14] = 16;
          *(_WORD *)&__p[18] = 2097;
          *(void *)&__p[20] = v14 + 13;
          _os_log_impl( (void *)&_mh_execute_header,  v21,  OS_LOG_TYPE_INFO,  "Decrypted payload: %{private, mask.hash}.16P",  __p,  0x1Cu);
        }

        *(_BYTE *)(*(void *)(a3 + 8) + 361LL) = 1;
        if (v19)
        {
          unsigned int v25 = v11[11];
          if (v11[11])
          {
            if (sub_1003E16E4((uint64_t)v19) != v25)
            {
              LODWORD(v43[0]) = 0;
              uint64_t v41 = 0LL;
              int v40 = 0;
              if (sub_1003D55EC((uint64_t)v19, v43, (_DWORD *)&v41 + 1, &v41, &v40))
              {
                if ((_DWORD)v41 == 8203 && (v25 > 0xEF || (v25 & 0xF) == 0xF))
                {
                  unint64_t v36 = (os_log_s *)qword_1008F75B8;
                  if (os_log_type_enabled((os_log_t)qword_1008F75B8, OS_LOG_TYPE_INFO))
                  {
                    sub_1003D0100((uint64_t)v19, (uint64_t)buf);
                    id v37 = v47 >= 0 ? buf : *(_BYTE **)buf;
                    *(_DWORD *)std::stringbuf::string_type __p = 141558531;
                    *(void *)&__p[4] = 1752392040LL;
                    *(_WORD *)&_BYTE __p[12] = 2081;
                    *(void *)&__p[14] = v37;
                    *(_WORD *)&__p[22] = 1024;
                    *(_DWORD *)&_BYTE __p[24] = v25;
                    _os_log_impl( (void *)&_mh_execute_header,  v36,  OS_LOG_TYPE_INFO,  "Cannot set color for device %{private, mask.hash}s: %x",  __p,  0x1Cu);
                    if (v47 < 0) {
                      operator delete(*(void **)buf);
                    }
                  }
                }

                else
                {
                  uint64_t v26 = (os_log_s *)qword_1008F75B8;
                  if (os_log_type_enabled((os_log_t)qword_1008F75B8, OS_LOG_TYPE_INFO))
                  {
                    sub_1003D0100((uint64_t)v19, (uint64_t)buf);
                    uint64_t v27 = v47 >= 0 ? buf : *(_BYTE **)buf;
                    *(_DWORD *)std::stringbuf::string_type __p = 141558531;
                    *(void *)&__p[4] = 1752392040LL;
                    *(_WORD *)&_BYTE __p[12] = 2081;
                    *(void *)&__p[14] = v27;
                    *(_WORD *)&__p[22] = 1024;
                    *(_DWORD *)&_BYTE __p[24] = v25;
                    _os_log_impl( (void *)&_mh_execute_header,  v26,  OS_LOG_TYPE_INFO,  "Set color for device %{private, mask.hash}s, %d",  __p,  0x1Cu);
                    if (v47 < 0) {
                      operator delete(*(void **)buf);
                    }
                  }

                  sub_1003E1694((uint64_t)v19, v11[11]);
                  if (qword_1008D60C0 != -1) {
                    dispatch_once(&qword_1008D60C0, &stru_1008A4178);
                  }
                  sub_1003F637C((uint64_t)off_1008D60B8, (uint64_t)v19, 4100);
                }
              }
            }
          }

          uint64_t v28 = *(void *)(a3 + 8);
          if (*(char *)(v28 + 39) < 0)
          {
            sub_100024238(__p, *(void **)(v28 + 16), *(void *)(v28 + 24));
          }

          else
          {
            *(_OWORD *)std::stringbuf::string_type __p = *(_OWORD *)(v28 + 16);
            *(void *)&__p[16] = *(void *)(v28 + 32);
          }

          if ((__p[23] & 0x80000000) != 0)
          {
            uint64_t v29 = *(void *)&__p[8];
            operator delete(*(void **)__p);
            if (!v29)
            {
LABEL_52:
              v43[0] = 0LL;
              v43[1] = 0LL;
              if (qword_1008D5F30 != -1) {
                dispatch_once(&qword_1008D5F30, &stru_1008A40B8);
              }
              sub_1005C8684((uint64_t)off_1008D5F28, a2, 1u, 1u, 0LL, 0LL, (unsigned __int8 *)v43);
              if (qword_1008D5F30 != -1) {
                dispatch_once(&qword_1008D5F30, &stru_1008A40B8);
              }
              uint64_t v30 = off_1008D5F28;
              sub_1003D0100((uint64_t)v19, (uint64_t)v38);
              sub_1005C9550((uint64_t)v30, (unsigned __int8 *)v43, (uint64_t)v38, 1);
              if (v39 < 0) {
                operator delete(v38[0]);
              }
              int v31 = (os_log_s *)qword_1008F7600;
              if (os_log_type_enabled((os_log_t)qword_1008F7600, OS_LOG_TYPE_INFO))
              {
                sub_1003D0100((uint64_t)v19, (uint64_t)__p);
                uint64_t v32 = __p[23] >= 0 ? __p : *(_BYTE **)__p;
                *(_DWORD *)__int128 buf = 141558275;
                *(void *)&uint8_t buf[4] = 1752392040LL;
                __int16 v45 = 2081;
                uint64_t v46 = v32;
                _os_log_impl( (void *)&_mh_execute_header,  v31,  OS_LOG_TYPE_INFO,  "Set name for device %{private, mask.hash}s",  buf,  0x16u);
                if ((__p[23] & 0x80000000) != 0) {
                  operator delete(*(void **)__p);
                }
              }
            }
          }

          else if (!__p[23])
          {
            goto LABEL_52;
          }
        }

        if (os_log_type_enabled((os_log_t)qword_1008F75B8, OS_LOG_TYPE_DEBUG)) {
          sub_10069D1B8();
        }
        goto LABEL_72;
      }

      uint64_t v22 = (os_log_s *)qword_1008F7600;
      if (os_log_type_enabled((os_log_t)qword_1008F7600, OS_LOG_TYPE_INFO))
      {
        id v23 = sub_1005BFB9C(a2);
        uint64_t v24 = (void *)objc_claimAutoreleasedReturnValue(v23);
        *(_DWORD *)std::stringbuf::string_type __p = 138543362;
        *(void *)&__p[4] = v24;
        _os_log_impl( (void *)&_mh_execute_header,  v22,  OS_LOG_TYPE_INFO,  "No encryption key for the device %{public}@",  __p,  0xCu);
      }
    }
  }

void sub_1005F9374( _Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, void *__p, uint64_t a10, int a11, __int16 a12, char a13, char a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20, uint64_t a21, uint64_t a22, uint64_t a23, uint64_t a24, uint64_t a25)
{
  if (a14 < 0) {
    operator delete(__p);
  }
  _Unwind_Resume(exception_object);
}

void sub_1005F93C8(uint64_t a1, unint64_t a2, uint64_t a3)
{
  uint64_t v6 = *(unsigned int **)(*(void *)(a3 + 8) + 56LL);
  uint64_t v28 = &off_10087FAA8;
  uint64_t v29 = v6;
  if (v6) {
    sub_1002CD1E0((uint64_t)v6);
  }
  int64_t v7 = sub_10056AAD8((uint64_t)&v28);
  uint64_t v8 = sub_10056AAF0((uint64_t)&v28);
  if ((unint64_t)v7 >= 2)
  {
    uint64_t v10 = (const void *)v8;
    if (*(_BYTE *)v8 == 76 && !*(_BYTE *)(v8 + 1) && v7 >= 4)
    {
      uint64_t v11 = v8 + v7;
      BOOL v12 = (unsigned __int8 *)(v8 + 2);
      while (1)
      {
        size_t v13 = v12 + 2;
        uint64_t v14 = v12[1] & 0x1F;
        if (*v12 == 7) {
          break;
        }
        BOOL v12 = &v13[v14];
      }

      int v15 = *v13;
      if (v15 != 8 && v15 != 6) {
        goto LABEL_53;
      }
      __int128 v41 = 0uLL;
      int v17 = *v13;
      if (v17 == 6)
      {
        uint64_t v8 = sub_10060D144(a1, a2, (uint64_t)&v41);
        if ((v8 & 1) == 0)
        {
          if (os_log_type_enabled((os_log_t)qword_1008F7600, OS_LOG_TYPE_DEBUG))
          {
            sub_1005BF8CC(a2, &buf);
            sub_10069D37C();
          }

          goto LABEL_53;
        }
      }

      else if (v17 == 8)
      {
        *(_DWORD *)((char *)buf.__r_.__value_.__r.__words + 3) = 0;
        LODWORD(buf.__r_.__value_.__l.__data_) = 0;
        uint64_t v18 = sub_1001BCDB0(a2);
        LODWORD(buf.__r_.__value_.__l.__data_) = v18;
        buf.__r_.__value_.__s.__data_[6] = BYTE6(v18);
        WORD2(buf.__r_.__value_.__r.__words[0]) = WORD2(v18);
        if (qword_1008D5F20 != -1) {
          dispatch_once(&qword_1008D5F20, &stru_1008A40F8);
        }
        uint64_t v8 = sub_10062D738(qword_1008D5F18, &buf, &v41);
        if ((v8 & 1) == 0)
        {
          if (os_log_type_enabled((os_log_t)qword_1008F75B8, OS_LOG_TYPE_ERROR)) {
            sub_10069D3C8();
          }
          goto LABEL_53;
        }
      }

      __chkstk_darwin(v8, v9);
      int v19 = (char *)&v28 - ((v7 + 15) & 0xFFFFFFFFFFFFFFF0LL);
      bzero(v19, v7);
      int v20 = memcpy(v19, v10, v7);
      uint64_t v21 = v13 - (_BYTE *)v10 + 1;
      if (v17 == 6)
      {
        if (sub_1001C43F0((uint64_t)&v41, (uint64_t)&v19[v21], (uint64_t)&v19[v21], v7 - v21))
        {
          if (os_log_type_enabled((os_log_t)qword_1008F7600, OS_LOG_TYPE_ERROR))
          {
            sub_1005BF8CC(a2, &buf);
            sub_10069D2EC();
          }

          goto LABEL_53;
        }

        uint64_t v23 = *(void *)(a3 + 8);
        *(_BYTE *)(v23 + 362) = 1;
        uint64_t v24 = (os_log_s *)qword_1008F7600;
        if (os_log_type_enabled((os_log_t)qword_1008F7600, OS_LOG_TYPE_INFO))
        {
          sub_1005BF8CC(a2, &v30);
          if ((v30.__r_.__value_.__s.__size_ & 0x80u) == 0) {
            unsigned int v25 = &v30;
          }
          else {
            unsigned int v25 = (std::stringbuf::string_type *)v30.__r_.__value_.__r.__words[0];
          }
          LODWORD(buf.__r_.__value_.__l.__data_) = 136447747;
          *(std::string::size_type *)((char *)buf.__r_.__value_.__r.__words + 4) = (std::string::size_type)v25;
          WORD2(buf.__r_.__value_.__r.__words[1]) = 2160;
          *(std::string::size_type *)((char *)&buf.__r_.__value_.__r.__words[1] + 6) = 1752392040LL;
          HIWORD(buf.__r_.__value_.__r.__words[2]) = 1040;
          int v32 = v7;
          __int16 v33 = 2097;
          uint64_t v34 = v10;
          __int16 v35 = 2160;
          uint64_t v36 = 1752392040LL;
          __int16 v37 = 1040;
          int v38 = v7;
          __int16 v39 = 2097;
          int v40 = (char *)&v28 - ((v7 + 15) & 0xFFFFFFFFFFFFFFF0LL);
          _os_log_impl( (void *)&_mh_execute_header,  v24,  OS_LOG_TYPE_INFO,  "Decrypt AccessoryStatus ADV success: %{public}s, %{private, mask.hash}.*P -> %{private, mask.hash}.*P",  (uint8_t *)&buf,  0x40u);
          uint64_t v23 = *(void *)(a3 + 8);
        }

        goto LABEL_51;
      }

      if (v17 != 8) {
        goto LABEL_53;
      }
      uint64_t v22 = ccaes_ecb_decrypt_mode(v20);
      if (!ccecb_one_shot(v22, 16LL, &v41, 1LL, &v19[v21], &v19[v21]))
      {
        uint64_t v23 = *(void *)(a3 + 8);
        *(_BYTE *)(v23 + 362) = 1;
        uint64_t v26 = (os_log_s *)qword_1008F75B8;
        if (os_log_type_enabled((os_log_t)qword_1008F75B8, OS_LOG_TYPE_DEFAULT))
        {
          sub_1005BF8CC(a2, &v30);
          if ((v30.__r_.__value_.__s.__size_ & 0x80u) == 0) {
            uint64_t v27 = &v30;
          }
          else {
            uint64_t v27 = (std::stringbuf::string_type *)v30.__r_.__value_.__r.__words[0];
          }
          LODWORD(buf.__r_.__value_.__l.__data_) = 136447747;
          *(std::string::size_type *)((char *)buf.__r_.__value_.__r.__words + 4) = (std::string::size_type)v27;
          WORD2(buf.__r_.__value_.__r.__words[1]) = 2160;
          *(std::string::size_type *)((char *)&buf.__r_.__value_.__r.__words[1] + 6) = 1752392040LL;
          HIWORD(buf.__r_.__value_.__r.__words[2]) = 1040;
          int v32 = v7;
          __int16 v33 = 2097;
          uint64_t v34 = v10;
          __int16 v35 = 2160;
          uint64_t v36 = 1752392040LL;
          __int16 v37 = 1040;
          int v38 = v7;
          __int16 v39 = 2097;
          int v40 = (char *)&v28 - ((v7 + 15) & 0xFFFFFFFFFFFFFFF0LL);
          _os_log_impl( (void *)&_mh_execute_header,  v26,  OS_LOG_TYPE_DEFAULT,  "Decrypt FindMyAccessory ADV success: %{public}s, %{private, mask.hash}.*P -> %{private, mask.hash}.*P",  (uint8_t *)&buf,  0x40u);
          uint64_t v23 = *(void *)(a3 + 8);
        }

void sub_1005F9908(_Unwind_Exception *exception_object)
{
  *(void *)(v2 - 224) = v1;
  int v4 = *(unsigned int **)(v2 - 216);
  if (v4) {
    sub_1002CD254(v4);
  }
  _Unwind_Resume(exception_object);
}

uint64_t sub_1005F997C(uint64_t a1, uint64_t a2)
{
  return (*(uint64_t (**)(uint64_t, void, void, uint64_t))(*(void *)a2 + 32LL))( a2,  *(void *)(a1 + 40),  *(void *)(a1 + 32),  a1 + 48);
}

uint64_t sub_1005F9998( uint64_t a1, uint64_t (***a2)(void, void, void, uint64_t, uint64_t, void, uint64_t, void))
{
  return (**a2)( a2,  *(void *)(a1 + 48),  *(void *)(a1 + 32),  a1 + 56,  a1 + 72,  *(unsigned __int8 *)(a1 + 120),  a1 + 96,  *(void *)(a1 + 40));
}

uint64_t *sub_1005F99C4(uint64_t a1, uint64_t a2)
{
  uint64_t v4 = *(void *)(a2 + 64);
  *(void *)(a1 + 56) = &off_10087FAE8;
  *(void *)(a1 + 64) = v4;
  if (v4) {
    sub_1002CD1E0(v4);
  }
  *(void *)(a1 + 72) = 0LL;
  *(void *)(a1 + 80) = 0LL;
  *(void *)(a1 + 8_Block_object_dispose(va, 8) = 0LL;
  sub_100050EE8( (char *)(a1 + 72),  *(__int128 **)(a2 + 72),  *(__int128 **)(a2 + 80),  0xCCCCCCCCCCCCCCCDLL * ((uint64_t)(*(void *)(a2 + 80) - *(void *)(a2 + 72)) >> 2));
  return sub_10060F9AC((uint64_t *)(a1 + 96), a2 + 96);
}

void sub_1005F9A3C(_Unwind_Exception *exception_object)
{
  BOOL v5 = *v2;
  if (*v2)
  {
    v1[10] = v5;
    operator delete(v5);
  }

  v1[7] = v3;
  uint64_t v6 = (unsigned int *)v1[8];
  if (v6) {
    sub_1002CD254(v6);
  }
  _Unwind_Resume(exception_object);
}

void sub_1005F9A70(uint64_t a1)
{
  uint64_t v2 = *(void **)(a1 + 72);
  if (v2)
  {
    *(void *)(a1 + 80) = v2;
    operator delete(v2);
  }

  *(void *)(a1 + 56) = &off_10087FAE8;
  uint64_t v3 = *(unsigned int **)(a1 + 64);
  if (v3) {
    sub_1002CD254(v3);
  }
}

uint64_t sub_1005F9AC8( uint64_t a1, uint64_t (***a2)(void, void, void, uint64_t, uint64_t, void, uint64_t, void))
{
  return (**a2)( a2,  *(void *)(a1 + 48),  *(void *)(a1 + 32),  a1 + 56,  a1 + 72,  *(unsigned __int8 *)(a1 + 120),  a1 + 96,  *(void *)(a1 + 40));
}

id sub_1005F9AF4(uint64_t a1)
{
  if (*(void *)(a1 + 64) == *(void *)(a1 + 72) || !*(void *)(a1 + 160)) {
    id v1 = *(id *)(a1 + 152);
  }
  else {
    id v1 = (id)objc_claimAutoreleasedReturnValue(+[NSSet setWithObject:](&OBJC_CLASS___NSSet, "setWithObject:"));
  }
  return v1;
}

uint64_t sub_1005F9B34(uint64_t a1, uint64_t a2)
{
  return (*(uint64_t (**)(uint64_t, void, uint64_t))(*(void *)a2 + 48LL))(a2, *(void *)(a1 + 32), a1 + 40);
}

NSMutableString *sub_1005F9B50(uint64_t a1, uint64_t a2)
{
  uint64_t v3 = objc_alloc_init(&OBJC_CLASS___NSMutableString);
  unint64_t v4 = sub_10056AAD8(a2);
  BOOL v5 = (_WORD *)sub_10056AAF0(a2);
  uint64_t v6 = v5;
  if (v4 > 2)
  {
    if (v4 != 3)
    {
      LODWORD(v7) = 2;
      uint64_t v8 = 3LL;
      do
      {
        uint64_t v9 = *((unsigned __int8 *)v6 + v8);
        uint64_t v10 = "Invalid";
        switch(*((_BYTE *)v6 + (int)v7))
        {
          case 0:
            break;
          case 1:
            uint64_t v10 = "Hash";
            break;
          case 2:
            uint64_t v10 = "iBeacon";
            break;
          case 3:
            uint64_t v10 = "AirPrint";
            break;
          case 4:
            uint64_t v10 = "LegacyATVSetup";
            break;
          case 5:
            uint64_t v10 = "AirDrop";
            break;
          case 6:
            uint64_t v10 = "HomeKitV1";
            break;
          case 7:
            uint64_t v10 = "ProxPairing";
            break;
          case 8:
            uint64_t v10 = "HeySiri";
            break;
          case 9:
            uint64_t v10 = "AirPlayTarget";
            break;
          case 0xA:
            uint64_t v10 = "AirPlaySource";
            break;
          case 0xB:
            uint64_t v10 = "MagicSwitch";
            break;
          case 0xC:
            uint64_t v10 = "Continuity";
            break;
          case 0xD:
            uint64_t v10 = "TetheringTarget";
            break;
          case 0xE:
            uint64_t v10 = "TetheringSource";
            break;
          case 0xF:
            uint64_t v10 = "NearbyAction";
            break;
          case 0x10:
            uint64_t v10 = "NearbyInfo";
            break;
          case 0x11:
            uint64_t v10 = "HomeKitV2";
            break;
          case 0x12:
            uint64_t v10 = "ObjectDiscovery";
            break;
          case 0x13:
            uint64_t v10 = "SpatialInteraction";
            break;
          case 0x14:
            uint64_t v10 = "DCKit";
            break;
          case 0x15:
            uint64_t v10 = "NearbyActionV2";
            break;
          case 0x16:
            uint64_t v10 = "NearbyInfoV2";
            break;
          case 0x17:
          case 0x19:
            goto LABEL_10;
          case 0x18:
            uint64_t v10 = "DSInfo";
            break;
          case 0x1A:
            uint64_t v10 = "NearbyActionNoWake";
            break;
          default:
            else {
LABEL_10:
            }
              uint64_t v10 = "?";
            break;
        }

        uint64_t v11 = (void *)objc_claimAutoreleasedReturnValue(+[NSString stringWithUTF8String:](&OBJC_CLASS___NSString, "stringWithUTF8String:", v10));
        -[NSMutableString appendFormat:](v3, "appendFormat:", @"%@,", v11);

        uint64_t v7 = (int)v7 + 2LL + v9;
        uint64_t v8 = v7 + 1;
      }

      while (v4 > v7 + 1);
    }
  }

  else if (*v5 != 76)
  {
    -[NSMutableString appendFormat:](v3, "appendFormat:", @"Others,");
  }

  return v3;
}

void sub_1005F9DB0(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

uint64_t sub_1005F9DD8(uint64_t a1)
{
  return a1;
}

void sub_1005F9E14(uint64_t a1, uint64_t a2)
{
  if (*(_DWORD *)(a1 + 1960))
  {
    if ((_DWORD)a2)
    {
      if (os_log_type_enabled((os_log_t)qword_1008F75B8, OS_LOG_TYPE_ERROR)) {
        sub_10069D3F4();
      }
      uint64_t v30 = sub_1002E6E00();
      sub_10002418C(v31, "");
      sub_1004FB370(v30, a2, (uint64_t)v31, 1);
    }

    int v33 = 0;
    uint64_t v4 = sub_1002E6BF0();
    if ((*(unsigned int (**)(uint64_t))(*(void *)v4 + 568LL))(v4))
    {
      uint64_t v5 = sub_1002E6E9C();
      (*(void (**)(uint64_t, int *))(*(void *)v5 + 1016LL))(v5, &v33);
    }

    uint64_t v6 = (os_log_s *)qword_1008F75B8;
    if (os_log_type_enabled((os_log_t)qword_1008F75B8, OS_LOG_TYPE_DEFAULT))
    {
      uint64_t v7 = *(void *)(a1 + 2096);
      *(_DWORD *)std::stringbuf::string_type buf = 134218240;
      *(void *)&uint8_t buf[4] = v7;
      *(_WORD *)&_BYTE buf[12] = 1024;
      *(_DWORD *)&buf[14] = v33;
      _os_log_impl( (void *)&_mh_execute_header,  v6,  OS_LOG_TYPE_DEFAULT,  "Scanning stopped successfully.  %llu Advertising Events, %u dropped pkts",  buf,  0x12u);
    }

    int v8 = *(_DWORD *)(a1 + 1964);
    if (*(_BYTE *)(a1 + 1840) || v8 == 1)
    {
      if (*(_BYTE *)(a1 + 1840)) {
        BOOL v9 = v8 == 1;
      }
      else {
        BOOL v9 = 1;
      }
      int v10 = v9;
      sub_1005FA2CC((_BYTE *)a1, v10);
    }

    *(_DWORD *)(a1 + 1960) = 1;
    uint64_t v11 = (os_log_s *)qword_1008F75B8;
    if (os_log_type_enabled((os_log_t)qword_1008F75B8, OS_LOG_TYPE_DEFAULT))
    {
      uint64_t v12 = *(int *)(a1 + 1964);
      else {
        size_t v13 = off_1008A4238[v12];
      }
      *(_DWORD *)std::stringbuf::string_type buf = 136446466;
      *(void *)&uint8_t buf[4] = "Idle";
      *(_WORD *)&_BYTE buf[12] = 2082;
      *(void *)&buf[14] = v13;
      _os_log_impl( (void *)&_mh_execute_header,  v11,  OS_LOG_TYPE_DEFAULT,  "handleScanStoppedEvent state=%{public}s observerState=%{public}s",  buf,  0x16u);
    }

    int v15 = *(unsigned __int8 **)(a1 + 2064);
    *(void *)std::stringbuf::string_type buf = 0LL;
    *(void *)&uint8_t buf[8] = buf;
    *(void *)&uint8_t buf[16] = 0x4812000000LL;
    uint64_t v36 = sub_1005FA488;
    __int16 v37 = sub_1005FA4C4;
    v40[0] = 0LL;
    v40[1] = 0LL;
    int v38 = &unk_1007C41D6;
    __int16 v39 = v40;
    if (v15 != (unsigned __int8 *)(a1 + 2072))
    {
      uint64_t v16 = (void *)(a1 + 2048);
      do
      {
        memset(dst, 0, sizeof(dst));
        uuid_copy(dst, v15 + 32);
        int v17 = *(void **)(a1 + 2040);
        if (v17 == v16)
        {
LABEL_41:
          sub_1005BCCEC((uint64_t **)(*(void *)&buf[8] + 48LL), dst, dst);
          unsigned int v25 = (unsigned __int8 *)*((void *)v15 + 1);
          uint64_t v26 = v15;
          if (v25)
          {
            do
            {
              uint64_t v24 = (unsigned __int8 **)v25;
              unsigned int v25 = *(unsigned __int8 **)v25;
            }

            while (v25);
          }

          else
          {
            do
            {
              uint64_t v24 = (unsigned __int8 **)*((void *)v26 + 2);
              BOOL v9 = *v24 == v26;
              uint64_t v26 = (unsigned __int8 *)v24;
            }

            while (!v9);
          }

          sub_1001FDBCC((uint64_t **)(a1 + 2064), (uint64_t *)v15);
          sub_10060EFAC((void *)v15 + 4);
          operator delete(v15);
        }

        else
        {
          char v18 = 0;
          while (1)
          {
            uint64_t v19 = v17[5];
            uint64_t v20 = sub_1001FDB10(v19 + 104, dst);
            if (v19 + 112 != v20) {
              break;
            }
            uint64_t v21 = (void *)v17[1];
            if (v21)
            {
              do
              {
                uint64_t v22 = v21;
                uint64_t v21 = (void *)*v21;
              }

              while (v21);
            }

            else
            {
              do
              {
                uint64_t v22 = (void *)v17[2];
                BOOL v9 = *v22 == (void)v17;
                int v17 = v22;
              }

              while (!v9);
            }

            v18 |= v19 + 112 != v20;
            int v17 = v22;
            if (v22 == v16)
            {
              if ((v18 & 1) == 0) {
                goto LABEL_41;
              }
              break;
            }
          }

          uint64_t v23 = (unsigned __int8 *)*((void *)v15 + 1);
          if (v23)
          {
            do
            {
              uint64_t v24 = (unsigned __int8 **)v23;
              uint64_t v23 = *(unsigned __int8 **)v23;
            }

            while (v23);
          }

          else
          {
            do
            {
              uint64_t v24 = (unsigned __int8 **)*((void *)v15 + 2);
              BOOL v9 = *v24 == v15;
              int v15 = (unsigned __int8 *)v24;
            }

            while (!v9);
          }
        }

        int v15 = (unsigned __int8 *)v24;
      }

      while (v24 != (unsigned __int8 **)(a1 + 2072));
    }

    uint64_t v27 = sub_100404FE8();
    v32[0] = _NSConcreteStackBlock;
    v32[1] = 3221225472LL;
    v32[2] = sub_1005FA4D4;
    v32[3] = &unk_100880C30;
    v32[4] = buf;
    sub_100405384(v27, v32);
    int v28 = *(_DWORD *)(a1 + 1964);
    if (v28 == 3)
    {
      unsigned int v29 = 0;
    }

    else
    {
      if (v28 != 1)
      {
        sub_1005F51EC(a1, 0LL);
        goto LABEL_54;
      }

      unsigned int v29 = 2;
    }

    sub_1005FA5B8((os_unfair_lock_s *)a1, v29);
LABEL_54:
    _Block_object_dispose(buf, 8);
    sub_10023BF24((uint64_t)&v39, v40[0]);
    return;
  }

  uint64_t v14 = (os_log_s *)qword_1008F75B8;
  if (os_log_type_enabled((os_log_t)qword_1008F75B8, OS_LOG_TYPE_DEFAULT))
  {
    *(_WORD *)std::stringbuf::string_type buf = 0;
    _os_log_impl((void *)&_mh_execute_header, v14, OS_LOG_TYPE_DEFAULT, "Ignoring late scan stopped event", buf, 2u);
  }

void sub_1005FA27C( _Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void *__p, uint64_t a11, int a12, __int16 a13, char a14, char a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20, uint64_t a21, uint64_t a22, uint64_t a23, char a24, uint64_t a25, uint64_t a26, uint64_t a27, uint64_t a28, uint64_t a29, uint64_t a30, uint64_t a31)
{
  if (a15 < 0) {
    operator delete(__p);
  }
  _Unwind_Resume(exception_object);
}

void sub_1005FA2CC(_BYTE *a1, int a2)
{
  uint64_t v4 = (os_log_s *)qword_1008F75B8;
  if (os_log_type_enabled((os_log_t)qword_1008F75B8, OS_LOG_TYPE_DEFAULT))
  {
    uint64_t v5 = "NO";
    if (a2) {
      uint64_t v6 = "YES";
    }
    else {
      uint64_t v6 = "NO";
    }
    if (a1[1849]) {
      uint64_t v7 = "YES";
    }
    else {
      uint64_t v7 = "NO";
    }
    int v8 = a1[1848];
    int v9 = a1[1850];
    if (a1[1843]) {
      int v10 = "YES";
    }
    else {
      int v10 = "NO";
    }
    int v17 = 136447234;
    if (v8) {
      uint64_t v11 = "YES";
    }
    else {
      uint64_t v11 = "NO";
    }
    char v18 = v6;
    __int16 v19 = 2082;
    if (v9) {
      uint64_t v5 = "YES";
    }
    uint64_t v20 = v7;
    __int16 v21 = 2082;
    uint64_t v22 = v10;
    __int16 v23 = 2082;
    uint64_t v24 = v11;
    __int16 v25 = 2082;
    uint64_t v26 = v5;
    _os_log_impl( (void *)&_mh_execute_header,  v4,  OS_LOG_TYPE_DEFAULT,  "Trying to remove scan filters with forceRemove=%{public}s fHaveZoneFilters:%{public}s fZoneScansHaveChanged:%{publ ic}s fHaveUUIDFilters:%{public}s fHaveRuleFilters:%{public}s",  (uint8_t *)&v17,  0x34u);
  }

  if (a1[1849])
  {
    if (a1[1843] || (a2 & 1) != 0) {
      goto LABEL_22;
    }
  }

  else if (a2)
  {
LABEL_22:
    uint64_t v12 = sub_1002E6E9C();
    (*(void (**)(uint64_t))(*(void *)v12 + 616LL))(v12);
    uint64_t v13 = sub_1002E6E9C();
    (*(void (**)(uint64_t, void))(*(void *)v13 + 624LL))(v13, 0LL);
    a1[1849] = 0;
    a1[1842] = 0;
  }

  if (a1[1848] || a2)
  {
    uint64_t v14 = sub_1002E6E9C();
    (*(void (**)(uint64_t, uint64_t))(*(void *)v14 + 400LL))(v14, 1LL);
    a1[1848] = 0;
    a1[1842] = 0;
  }

  if (a1[1850] || a2)
  {
    uint64_t v15 = sub_1002E6E9C();
    (*(void (**)(uint64_t))(*(void *)v15 + 632LL))(v15);
    uint64_t v16 = sub_1002E6E9C();
    (*(void (**)(uint64_t))(*(void *)v16 + 776LL))(v16);
    a1[1850] = 0;
    a1[1842] = 0;
  }

void *sub_1005FA488(void *result, void *a2)
{
  result[6] = a2[6];
  uint64_t v2 = a2 + 7;
  uint64_t v3 = a2[7];
  result[7] = v3;
  uint64_t v4 = result + 7;
  uint64_t v5 = a2[8];
  result[8] = v5;
  if (v5)
  {
    *(void *)(v3 + 16) = v4;
    a2[6] = v2;
    *uint64_t v2 = 0LL;
    a2[8] = 0LL;
  }

  else
  {
    result[6] = v4;
  }

  return result;
}

void sub_1005FA4C4(uint64_t a1)
{
}

void sub_1005FA4D4(uint64_t a1)
{
  uint64_t v1 = *(void *)(*(void *)(a1 + 32) + 8LL);
  uint64_t v2 = *(unsigned __int8 **)(v1 + 48);
  if (v2 != (unsigned __int8 *)(v1 + 56))
  {
    do
    {
      if (qword_1008D5F30 != -1) {
        dispatch_once(&qword_1008D5F30, &stru_1008A40B8);
      }
      sub_1005CB37C((uint64_t)off_1008D5F28, v2 + 25);
      uint64_t v4 = (unsigned __int8 *)*((void *)v2 + 1);
      if (v4)
      {
        do
        {
          uint64_t v5 = v4;
          uint64_t v4 = *(unsigned __int8 **)v4;
        }

        while (v4);
      }

      else
      {
        do
        {
          uint64_t v5 = (unsigned __int8 *)*((void *)v2 + 2);
          BOOL v6 = *(void *)v5 == (void)v2;
          uint64_t v2 = v5;
        }

        while (!v6);
      }

      uint64_t v2 = v5;
    }

    while (v5 != (unsigned __int8 *)(v1 + 56));
    uint64_t v1 = *(void *)(*(void *)(a1 + 32) + 8LL);
  }

  int v8 = *(void **)(v1 + 56);
  uint64_t v7 = (void *)(v1 + 56);
  sub_10023BF24((uint64_t)(v7 - 1), v8);
  *(v7 - 1) = v7;
  *uint64_t v7 = 0LL;
  v7[1] = 0LL;
}

uint64_t sub_1005FA5B8(os_unfair_lock_s *a1, unsigned int a2)
{
  uint64_t v4 = (os_log_s *)qword_1008F75B8;
  if (os_log_type_enabled((os_log_t)qword_1008F75B8, OS_LOG_TYPE_DEFAULT))
  {
    uint64_t os_unfair_lock_opaque = (int)a1[490]._os_unfair_lock_opaque;
    else {
      BOOL v6 = off_1008A4210[os_unfair_lock_opaque];
    }
    unsigned int v7 = a1[491]._os_unfair_lock_opaque;
    if (v7 > 3) {
      int v8 = "UNKNOWN";
    }
    else {
      int v8 = off_1008A4238[v7];
    }
    if (a2 > 3) {
      int v9 = "UNKNOWN";
    }
    else {
      int v9 = off_1008A4238[a2];
    }
    int v13 = 136447234;
    uint64_t v14 = v6;
    __int16 v15 = 2082;
    uint64_t v16 = v8;
    __int16 v17 = 1024;
    unsigned int v18 = v7;
    __int16 v19 = 2082;
    uint64_t v20 = v9;
    __int16 v21 = 1024;
    unsigned int v22 = a2;
    _os_log_impl( (void *)&_mh_execute_header,  v4,  OS_LOG_TYPE_DEFAULT,  "scan state:%{public}s, changing ObserverState %{public}s(%d) --> %{public}s(%d)",  (uint8_t *)&v13,  0x2Cu);
  }

  a1[491]._uint64_t os_unfair_lock_opaque = a2;
  switch(a2)
  {
    case 0u:
      sub_10043CB4C((uint64_t)&a1[14]);
      int v10 = a1 + 468;
      uint64_t v11 = &stru_1008A3E30;
      goto LABEL_16;
    case 1u:
    case 3u:
      sub_10043CC24((uint64_t)&a1[14]);
      break;
    case 2u:
      int v10 = a1 + 468;
      uint64_t v11 = &stru_1008A3E10;
LABEL_16:
      sub_1005EBB90(v10, v11);
      break;
    default:
      return sub_1005E3C94(a1, 0LL);
  }

  return sub_1005E3C94(a1, 0LL);
}

void sub_1005FA758(uint64_t a1, uint64_t a2, uint64_t a3)
{
  if ((unint64_t)sub_10056AAD8(a2) <= 0x15 && (unint64_t v6 = sub_10056AAD8(a2), v6 <= sub_10056AAD8(a3)))
  {
    int v8 = (os_log_s *)qword_1008F75B8;
    if (os_log_type_enabled((os_log_t)qword_1008F75B8, OS_LOG_TYPE_INFO))
    {
      sub_10056B0A4(a2, (std::stringbuf::string_type *)buf);
      int v9 = buf[23] >= 0 ? buf : *(_BYTE **)buf;
      *(_DWORD *)__int16 v17 = 136446210;
      *(void *)&_OWORD v17[4] = v9;
      _os_log_impl( (void *)&_mh_execute_header,  v8,  OS_LOG_TYPE_INFO,  "Received zone lost event for zone %{public}s",  v17,  0xCu);
      if ((buf[23] & 0x80000000) != 0) {
        operator delete(*(void **)buf);
      }
    }

    dispatch_time_t v10 = dispatch_time(0LL, 0LL);
    dispatch_time_t v11 = *(void *)(a1 + 2024);
    if (v10 <= v11)
    {
      memset(buf, 0, sizeof(buf));
      sub_10060EC38(buf, a2, a3);
      if ((void *)(a1 + 2008) == sub_10060FDCC(a1 + 2000, (uint64_t)buf))
      {
        dispatch_time_t v14 = dispatch_time(0LL, 30000000000LL);
        *(void *)__int16 v17 = buf;
        sub_10060FEB8((uint64_t **)(a1 + 2000), (uint64_t)buf, (uint64_t)&unk_1006C2518, (uint64_t *)v17)[8] = v14;
        sub_1005FAA88(a1);
      }

      *(void *)&uint8_t buf[16] = &off_10087FAA8;
      if (*(void *)&buf[24]) {
        sub_1002CD254(*(unsigned int **)&buf[24]);
      }
      *(void *)std::stringbuf::string_type buf = &off_10087FAA8;
      if (*(void *)&buf[8]) {
        sub_1002CD254(*(unsigned int **)&buf[8]);
      }
    }

    else
    {
      dispatch_time_t v12 = v10;
      int v13 = (os_log_s *)qword_1008F75B8;
      if (os_log_type_enabled((os_log_t)qword_1008F75B8, OS_LOG_TYPE_DEFAULT))
      {
        *(_DWORD *)std::stringbuf::string_type buf = 134218240;
        *(void *)&uint8_t buf[4] = v11;
        *(_WORD *)&_BYTE buf[12] = 2048;
        *(void *)&buf[14] = v12;
        _os_log_impl( (void *)&_mh_execute_header,  v13,  OS_LOG_TYPE_DEFAULT,  "We are beyond the zone lost timeout (%lld).  Sending directly to clients.  Now %lld",  buf,  0x16u);
      }

      v15[0] = _NSConcreteStackBlock;
      v15[1] = 3221225472LL;
      void v15[2] = sub_1005FAA70;
      _OWORD v15[3] = &unk_1008A3BE0;
      v15[4] = a2;
      v15[5] = a3;
      sub_1005EBB90((os_unfair_lock_s *)(a1 + 1872), v15);
      if (*(_DWORD *)(sub_1002E6E9C() + 708) == 1) {
        sub_1005E3C94(a1, 1);
      }
    }
  }

  else
  {
    unsigned int v7 = (os_log_s *)qword_1008F75B8;
    if (os_log_type_enabled((os_log_t)qword_1008F75B8, OS_LOG_TYPE_INFO))
    {
      *(_DWORD *)std::stringbuf::string_type buf = 134218240;
      *(void *)&uint8_t buf[4] = sub_10056AAD8(a2);
      *(_WORD *)&_BYTE buf[12] = 2048;
      *(void *)&buf[14] = sub_10056AAD8(a3);
      _os_log_impl( (void *)&_mh_execute_header,  v7,  OS_LOG_TYPE_INFO,  "Zone Lost event has invalid sizes.  zoneLength:%zu maskLength:%zu",  buf,  0x16u);
    }
  }

void sub_1005FAA50( _Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, ...)
{
}

uint64_t sub_1005FAA70(uint64_t a1, uint64_t a2)
{
  return (*(uint64_t (**)(uint64_t, void, void))(*(void *)a2 + 8LL))( a2,  *(void *)(a1 + 32),  *(void *)(a1 + 40));
}

void sub_1005FAA88(uint64_t a1)
{
  uint64_t v2 = *(void *)(a1 + 2016);
  uint64_t v3 = *(dispatch_source_s **)(a1 + 2032);
  if (v2)
  {
    if (v3)
    {
      dispatch_suspend(v3);
    }

    else
    {
      uint64_t v4 = sub_100404FE8();
      uint64_t v5 = dispatch_source_create( (dispatch_source_type_t)&_dispatch_source_type_timer,  0LL,  0LL,  *(dispatch_queue_t *)(v4 + 8));
      *(void *)(a1 + 2032) = v5;
      dispatch_source_set_event_handler(v5, &stru_1008A3C00);
    }

    unint64_t v6 = *(void **)(a1 + 2000);
    dispatch_time_t v7 = -1LL;
    if (v6 != (void *)(a1 + 2008))
    {
      do
      {
        if (v7 >= v6[8]) {
          dispatch_time_t v7 = v6[8];
        }
        int v8 = (void *)v6[1];
        if (v8)
        {
          do
          {
            int v9 = v8;
            int v8 = (void *)*v8;
          }

          while (v8);
        }

        else
        {
          do
          {
            int v9 = (void *)v6[2];
            BOOL v10 = *v9 == (void)v6;
            unint64_t v6 = v9;
          }

          while (!v10);
        }

        unint64_t v6 = v9;
      }

      while (v9 != (void *)(a1 + 2008));
    }

    dispatch_source_set_timer(*(dispatch_source_t *)(a1 + 2032), v7, 0xFFFFFFFFFFFFFFFFLL, 0x3B9ACA00uLL);
    dispatch_resume(*(dispatch_object_t *)(a1 + 2032));
  }

  else if (v3)
  {
    dispatch_source_cancel(v3);
    dispatch_release(*(dispatch_object_t *)(a1 + 2032));
    *(void *)(a1 + 2032) = 0LL;
  }

void *sub_1005FAB78(void *a1)
{
  a1[2] = &off_10087FAA8;
  uint64_t v2 = (unsigned int *)a1[3];
  if (v2) {
    sub_1002CD254(v2);
  }
  *a1 = &off_10087FAA8;
  uint64_t v3 = (unsigned int *)a1[1];
  if (v3) {
    sub_1002CD254(v3);
  }
  return a1;
}

void sub_1005FABC0(id a1)
{
  if (qword_1008D6608 != -1) {
    dispatch_once(&qword_1008D6608, &stru_1008A3FF8);
  }
  sub_1005FAC00((uint64_t)off_1008D6600);
}

void sub_1005FAC00(uint64_t a1)
{
  dispatch_time_t v2 = dispatch_time(0LL, 0LL);
  uint64_t v11 = 0LL;
  uint64_t v12 = 0LL;
  uint64_t v13 = 0LL;
  uint64_t v3 = *(void **)(a1 + 2000);
  if (v3 != (void *)(a1 + 2008))
  {
    dispatch_time_t v4 = v2;
    do
    {
      if (v3[8] <= v4)
      {
        v10[0] = _NSConcreteStackBlock;
        v10[1] = 3221225472LL;
        _DWORD v10[2] = sub_1005FAD68;
        v10[3] = &unk_1008A3C20;
        void v10[4] = v3 + 4;
        sub_1005EBB90((os_unfair_lock_s *)(a1 + 1872), v10);
        sub_1005FAD84(&v11, (uint64_t)(v3 + 4));
      }

      uint64_t v5 = (void *)v3[1];
      if (v5)
      {
        do
        {
          unint64_t v6 = v5;
          uint64_t v5 = (void *)*v5;
        }

        while (v5);
      }

      else
      {
        do
        {
          unint64_t v6 = (void *)v3[2];
          BOOL v7 = *v6 == (void)v3;
          uint64_t v3 = v6;
        }

        while (!v7);
      }

      uint64_t v3 = v6;
    }

    while (v6 != (void *)(a1 + 2008));
    uint64_t v8 = v11;
    uint64_t v9 = v12;
    while (v8 != v9)
    {
      sub_10061036C((uint64_t **)(a1 + 2000), v8);
      v8 += 32LL;
    }
  }

  sub_1005FAA88(a1);
  dispatch_time_t v14 = (void **)&v11;
  sub_100610134(&v14);
}

void sub_1005FAD44( _Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, char a15, uint64_t a16, uint64_t a17, void **a18)
{
  a18 = (void **)&a15;
  sub_100610134(&a18);
  _Unwind_Resume(a1);
}

uint64_t sub_1005FAD68(uint64_t a1, uint64_t a2)
{
  return (*(uint64_t (**)(uint64_t, void, uint64_t))(*(void *)a2 + 8LL))( a2,  *(void *)(a1 + 32),  *(void *)(a1 + 32) + 16LL);
}

void *sub_1005FAD84(uint64_t *a1, uint64_t a2)
{
  unint64_t v6 = a1[2];
  uint64_t v4 = (uint64_t)(a1 + 2);
  unint64_t v5 = v6;
  unint64_t v7 = *(void *)(v4 - 8);
  if (v7 >= v6)
  {
    uint64_t v10 = (uint64_t)(v7 - *a1) >> 5;
    uint64_t v11 = v5 - *a1;
    uint64_t v12 = v11 >> 4;
    else {
      unint64_t v13 = v12;
    }
    uint64_t v19 = v4;
    if (v13) {
      dispatch_time_t v14 = (char *)sub_100240F38(v4, v13);
    }
    else {
      dispatch_time_t v14 = 0LL;
    }
    __int16 v15 = v14;
    uint64_t v16 = &v14[32 * v10];
    unsigned int v18 = &v14[32 * v13];
    sub_100610080(v16, a2);
    __int16 v17 = v16 + 32;
    sub_100610204(a1, &v15);
    uint64_t v9 = a1[1];
    double result = sub_1006102F8(&v15);
  }

  else
  {
    double result = sub_100610080(*(void **)(v4 - 8), a2);
    uint64_t v9 = v7 + 32;
    a1[1] = v7 + 32;
  }

  a1[1] = v9;
  return result;
}

void sub_1005FAE70( _Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, char a10)
{
  *(void *)(v10 + _Block_object_dispose(va, 8) = v11;
  _Unwind_Resume(exception_object);
}

void sub_1005FAE90(int a1)
{
  uint64_t v2 = sub_100404FE8();
  v3[0] = _NSConcreteStackBlock;
  v3[1] = 3221225472LL;
  _DWORD v3[2] = sub_1005FAEF0;
  v3[3] = &unk_10087F980;
  int v4 = a1;
  sub_100405384(v2, v3);
}

void sub_1005FAEF0(uint64_t a1)
{
  if (qword_1008D6608 != -1) {
    dispatch_once(&qword_1008D6608, &stru_1008A3FF8);
  }
  sub_1005F50CC((uint64_t)off_1008D6600, *(_DWORD *)(a1 + 32));
}

uint64_t sub_1005FAF40(int a1, const void *a2, size_t __n, uint64_t a4)
{
  uint64_t result = 161LL;
  if (a2)
  {
    if (__n)
    {
      uint64_t result = 161LL;
      if (a1 == 18)
      {
        if (a4)
        {
          if (__n < 0x1E)
          {
            uint64_t v9 = a4 + 5072 + 56LL * *(unsigned __int8 *)(a4 + 5632);
            *(_DWORD *)(v9 + 16) = 0;
            *(_OWORD *)uint64_t v9 = xmmword_1006BDCB0;
            uint64_t v10 = (_BYTE *)(a4 + 5072 + 56LL * *(unsigned __int8 *)(a4 + 5632));
            v10[20] = 1;
            v10[21] = __n < 4;
            memcpy(v10 + 22, a2, __n);
            uint64_t result = 0LL;
            unsigned __int8 v11 = *(_BYTE *)(a4 + 5632);
            *(_WORD *)(a4 + 5072 + 56LL * v11 + 52) = __n + 2;
            *(_BYTE *)(a4 + 5632) = v11 + 1;
          }

          else
          {
            uint64_t v8 = (os_log_s *)qword_1008F75B8;
            if (os_log_type_enabled((os_log_t)qword_1008F75B8, OS_LOG_TYPE_ERROR)) {
              sub_10069D454(__n, v8);
            }
            return 162LL;
          }
        }
      }
    }
  }

  return result;
}

uint64_t sub_1005FB040(int a1, uint64_t a2, unint64_t a3, BOOL *a4)
{
  uint64_t result = 161LL;
  if (a2 && a3 && a1 == 18)
  {
    if (a4)
    {
      uint64_t result = 0LL;
      *a4 = a3 < 3;
    }
  }

  return result;
}

void sub_1005FB070(id a1)
{
}

uint64_t sub_1005FB07C(uint64_t a1)
{
  uint64_t v1 = a1 + 48;
  if ((unint64_t)sub_10056AAD8(a1 + 48) < 2)
  {
    return 0;
  }

  else
  {
    __int16 v2 = *(unsigned __int8 *)sub_10056AAF0(v1);
    return (unsigned __int16)(v2 | (*(unsigned __int8 *)(sub_10056AAF0(v1) + 1) << 8));
  }

uint64_t sub_1005FB0D0(uint64_t a1)
{
  if (qword_1008D6608 != -1) {
    dispatch_once(&qword_1008D6608, &stru_1008A3FF8);
  }
  return sub_1005F65B4( (uint64_t)off_1008D6600,  *(void *)(a1 + 32),  *(unsigned __int8 *)(a1 + 56),  a1 + 40,  *(char *)(a1 + 57),  *(unsigned __int8 *)(a1 + 58),  *(unsigned __int8 *)(a1 + 59),  *(unsigned __int8 *)(a1 + 60));
}

void sub_1005FB138(int a1)
{
  uint64_t v2 = sub_100404FE8();
  v3[0] = _NSConcreteStackBlock;
  v3[1] = 3221225472LL;
  _DWORD v3[2] = sub_1005FB198;
  v3[3] = &unk_10087F980;
  int v4 = a1;
  sub_100405384(v2, v3);
}

void sub_1005FB198(uint64_t a1)
{
  if (qword_1008D6608 != -1) {
    dispatch_once(&qword_1008D6608, &stru_1008A3FF8);
  }
  sub_1005F9E14((uint64_t)off_1008D6600, *(unsigned int *)(a1 + 32));
}

void sub_1005FB1E8(uint64_t a1, uint64_t a2, uint64_t a3)
{
  int v4 = *(unsigned int **)(a2 + 8);
  if (v4) {
    sub_1002CD1E0(*(void *)(a2 + 8));
  }
  unint64_t v5 = *(unsigned int **)(a3 + 8);
  if (v5) {
    sub_1002CD1E0((uint64_t)v5);
  }
  uint64_t v6 = sub_100404FE8();
  v7[0] = _NSConcreteStackBlock;
  v7[1] = 3321888768LL;
  _DWORD v7[2] = sub_1005FB344;
  v7[3] = &unk_1008A3C90;
  uint64_t v8 = &off_10087FAA8;
  uint64_t v9 = v4;
  if (v4) {
    sub_1002CD1E0((uint64_t)v4);
  }
  uint64_t v10 = &off_10087FAA8;
  unsigned __int8 v11 = v5;
  if (v5) {
    sub_1002CD1E0((uint64_t)v5);
  }
  sub_100405384(v6, v7);
  uint64_t v10 = &off_10087FAA8;
  if (v11) {
    sub_1002CD254(v11);
  }
  uint64_t v8 = &off_10087FAA8;
  if (v9) {
    sub_1002CD254(v9);
  }
  if (v5) {
    sub_1002CD254(v5);
  }
  if (v4) {
    sub_1002CD254(v4);
  }
}

void sub_1005FB2D4( _Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, unsigned int *a14, uint64_t a15, uint64_t a16)
{
  if (a14)
  {
    sub_1002CD254(a14);
    if (!v17)
    {
LABEL_3:
      if (!v16) {
        goto LABEL_5;
      }
      goto LABEL_4;
    }
  }

  else if (!v17)
  {
    goto LABEL_3;
  }

  sub_1002CD254(v17);
  if (!v16) {
LABEL_5:
  }
    _Unwind_Resume(exception_object);
LABEL_4:
  sub_1002CD254(v16);
  goto LABEL_5;
}

void sub_1005FB344(uint64_t a1)
{
  if (qword_1008D6608 != -1) {
    dispatch_once(&qword_1008D6608, &stru_1008A3FF8);
  }
  sub_1005FA758((uint64_t)off_1008D6600, a1 + 32, a1 + 48);
}

void sub_1005FB398(void *a1, uint64_t a2)
{
  uint64_t v4 = *(void *)(a2 + 40);
  a1[4] = &off_10087FAA8;
  a1[5] = v4;
  if (v4) {
    sub_1002CD1E0(v4);
  }
  uint64_t v5 = *(void *)(a2 + 56);
  a1[6] = &off_10087FAA8;
  a1[7] = v5;
  if (v5) {
    sub_1002CD1E0(v5);
  }
}

void sub_1005FB3E8(_Unwind_Exception *exception_object)
{
  *(void *)(v1 + 32) = v2;
  uint64_t v4 = *(unsigned int **)(v1 + 40);
  if (v4) {
    sub_1002CD254(v4);
  }
  _Unwind_Resume(exception_object);
}

void sub_1005FB404(void *a1)
{
  a1[6] = &off_10087FAA8;
  uint64_t v2 = (unsigned int *)a1[7];
  if (v2) {
    sub_1002CD254(v2);
  }
  a1[4] = &off_10087FAA8;
  uint64_t v3 = (unsigned int *)a1[5];
  if (v3) {
    sub_1002CD254(v3);
  }
}

void sub_1005FB454()
{
  uint64_t v0 = (os_log_s *)qword_1008F75B8;
  if (os_log_type_enabled((os_log_t)qword_1008F75B8, OS_LOG_TYPE_INFO))
  {
    *(_WORD *)uint64_t v2 = 0;
    _os_log_impl( (void *)&_mh_execute_header,  v0,  OS_LOG_TYPE_INFO,  "Stream state changed, re-evaluating scan params",  v2,  2u);
  }

  uint64_t v1 = sub_100404FE8();
  sub_100405384(v1, &stru_1008A3CC0);
}

void sub_1005FB4C8(id a1)
{
  if (qword_1008D6608 != -1) {
    dispatch_once(&qword_1008D6608, &stru_1008A3FF8);
  }
  sub_1005E3C94((uint64_t)off_1008D6600, 0);
}

void sub_1005FB50C()
{
}

void sub_1005FB514(uint64_t a1)
{
  uint64_t v2 = (os_log_s *)qword_1008F75B8;
  if (os_log_type_enabled((os_log_t)qword_1008F75B8, OS_LOG_TYPE_DEFAULT))
  {
    *(_WORD *)std::stringbuf::string_type buf = 0;
    _os_log_impl((void *)&_mh_execute_header, v2, OS_LOG_TYPE_DEFAULT, "scanRxConfigured", buf, 2u);
  }

  uint64_t v3 = sub_100404FE8();
  v4[0] = _NSConcreteStackBlock;
  v4[1] = 3221225472LL;
  _DWORD v4[2] = sub_1005FB5B8;
  v4[3] = &unk_10087EB20;
  void v4[4] = a1;
  sub_100405384(v3, v4);
}

uint64_t sub_1005FB5B8(uint64_t a1)
{
  return sub_1005E3C94(*(void *)(a1 + 32), 0);
}

void sub_1005FB5C4(uint64_t a1)
{
}

void sub_1005FB5CC()
{
  uint64_t v0 = (os_log_s *)qword_1008F75B8;
  if (os_log_type_enabled((os_log_t)qword_1008F75B8, OS_LOG_TYPE_INFO))
  {
    *(_WORD *)uint64_t v2 = 0;
    _os_log_impl( (void *)&_mh_execute_header,  v0,  OS_LOG_TYPE_INFO,  "BT ACL protect mode changed, re-evaluating scan params",  v2,  2u);
  }

  uint64_t v1 = sub_100404FE8();
  sub_100405384(v1, &stru_1008A3CE0);
}

void sub_1005FB640(id a1)
{
  if (qword_1008D6608 != -1) {
    dispatch_once(&qword_1008D6608, &stru_1008A3FF8);
  }
  sub_1005E3C94((uint64_t)off_1008D6600, 0);
}

void sub_1005FB684()
{
}

void sub_1005FB68C(uint64_t a1)
{
  uint64_t v2 = (os_log_s *)qword_1008F75B8;
  if (os_log_type_enabled((os_log_t)qword_1008F75B8, OS_LOG_TYPE_DEFAULT))
  {
    *(_WORD *)std::stringbuf::string_type buf = 0;
    _os_log_impl((void *)&_mh_execute_header, v2, OS_LOG_TYPE_DEFAULT, "systemCoexStateCahnged", buf, 2u);
  }

  uint64_t v3 = sub_100404FE8();
  v4[0] = _NSConcreteStackBlock;
  v4[1] = 3221225472LL;
  _DWORD v4[2] = sub_1005FB730;
  v4[3] = &unk_10087EB20;
  void v4[4] = a1;
  sub_100405384(v3, v4);
}

uint64_t sub_1005FB730(uint64_t a1)
{
  return sub_1005E3C94(*(void *)(a1 + 32), 0);
}

void sub_1005FB73C(uint64_t a1)
{
}

void sub_1005FB744(uint64_t a1, int a2)
{
  uint64_t v4 = (os_log_s *)qword_1008F75B8;
  if (os_log_type_enabled((os_log_t)qword_1008F75B8, OS_LOG_TYPE_DEFAULT))
  {
    *(_DWORD *)std::stringbuf::string_type buf = 67109120;
    int v9 = a2;
    _os_log_impl((void *)&_mh_execute_header, v4, OS_LOG_TYPE_DEFAULT, "SDP Progress Changed inProgress=%d", buf, 8u);
  }

  uint64_t v5 = sub_100404FE8();
  v6[0] = _NSConcreteStackBlock;
  v6[1] = 3221225472LL;
  _DWORD v6[2] = sub_1005FB830;
  uint64_t v6[3] = &unk_1008800D8;
  void v6[4] = a1;
  char v7 = a2;
  sub_100405384(v5, v6);
}

uint64_t sub_1005FB830(uint64_t a1)
{
  uint64_t v1 = *(void *)(a1 + 32);
  *(_BYTE *)(v1 + 4384) = *(_BYTE *)(a1 + 40);
  return sub_1005E3C94(v1, 0);
}

void sub_1005FB84C(uint64_t a1, int a2)
{
}

void sub_1005FB854(uint64_t a1, unint64_t a2, uint64_t a3, char a4, char a5)
{
  *((void *)&v9 + 1) = a3;
  *(void *)&__int128 v9 = bswap64(a2);
  unint64_t v8 = v9 >> 16;
  if (qword_1008D5F30 != -1) {
    dispatch_once(&qword_1008D5F30, &stru_1008A40B8);
  }
  *(void *)uuid_t uu = 0LL;
  uint64_t v20 = 0LL;
  sub_1005C8684((uint64_t)off_1008D5F28, v8, 0, 1u, 0LL, 0LL, uu);
  if (uuid_is_null(uu))
  {
    if (os_log_type_enabled((os_log_t)qword_1008F75B8, OS_LOG_TYPE_ERROR)) {
      sub_10069D4E0();
    }
  }

  else
  {
    uint64_t v10 = sub_100241F94(uu);
    unsigned __int8 v11 = (void *)objc_claimAutoreleasedReturnValue(v10);
    uint64_t v12 = sub_100404FE8();
    v14[0] = _NSConcreteStackBlock;
    v14[1] = 3221225472LL;
    void v14[2] = sub_1005FB9F0;
    void v14[3] = &unk_100890D88;
    uint64_t v16 = a1;
    id v13 = v11;
    id v15 = v13;
    char v17 = a4;
    char v18 = a5;
    sub_100405384(v12, v14);
  }

void sub_1005FB9C8( _Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, void *a13)
{
  _Unwind_Resume(a1);
}

void sub_1005FB9F0(uint64_t a1)
{
  uint64_t v2 = *(void **)(a1 + 32);
  uint64_t v3 = (os_unfair_lock_s *)(*(void *)(a1 + 40) + 1872LL);
  v4[0] = _NSConcreteStackBlock;
  v4[1] = 3221225472LL;
  _DWORD v4[2] = sub_1005FBA80;
  v4[3] = &unk_1008A3D08;
  id v5 = v2;
  __int16 v6 = *(_WORD *)(a1 + 48);
  sub_1005EBB90(v3, v4);
}

void sub_1005FBA6C( _Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, void *a13)
{
}

uint64_t sub_1005FBA80(uint64_t a1, uint64_t a2)
{
  return (*(uint64_t (**)(uint64_t, void, void, void))(*(void *)a2 + 40LL))( a2,  *(void *)(a1 + 32),  *(unsigned __int8 *)(a1 + 40),  *(unsigned __int8 *)(a1 + 41));
}

void sub_1005FBAA0(uint64_t a1, uint64_t a2, uint64_t a3, char a4, char a5)
{
}

uint64_t sub_1005FBAAC(uint64_t a1, unsigned __int16 *a2)
{
  unsigned __int16 v23 = 0;
  uint64_t v4 = sub_1005FBD08(a1, 18, 20, &v23);
  uint64_t v5 = v23;
  *a2 = v23;
  if ((_DWORD)v4)
  {
    uint64_t v6 = v4;
    if (os_log_type_enabled((os_log_t)qword_1008F75B8, OS_LOG_TYPE_ERROR)) {
      sub_10069CB18();
    }
  }

  else
  {
    char v7 = (uint64_t **)(a1 + 1816);
    unsigned __int8 v22 = v5;
    *(void *)std::stringbuf::string_type buf = &v22;
    unint64_t v8 = sub_10060F298(v7, &v22, (uint64_t)&unk_1006C2518, (char **)buf);
    char v9 = *((_BYTE *)v8 + 29);
    __int16 v10 = *((_WORD *)v8 + 15);
    __int16 v11 = *((_WORD *)v8 + 17);
    __int16 v12 = *((_WORD *)v8 + 19);
    id v13 = (os_log_s *)qword_1008F75B8;
    if (os_log_type_enabled((os_log_t)qword_1008F75B8, OS_LOG_TYPE_DEFAULT))
    {
      *(_DWORD *)std::stringbuf::string_type buf = 67109376;
      *(_DWORD *)&uint8_t buf[4] = v5;
      __int16 v25 = 1024;
      int v26 = 18;
      _os_log_impl( (void *)&_mh_execute_header,  v13,  OS_LOG_TYPE_DEFAULT,  "Creating a match table with handle %d for type %d",  buf,  0xEu);
    }

    uint64_t v14 = sub_1002E6E9C();
    char v21 = 0;
    char v20 = 0;
    int v19 = 0;
    char v18 = 0;
    uint64_t v6 = (*(uint64_t (**)(uint64_t, uint64_t, uint64_t, uint64_t, uint64_t, uint64_t, void, uint64_t, char, void, char, void, void, char))(*(void *)v14 + 2816LL))( v14,  v5,  23LL,  255LL,  76LL,  18LL,  0LL,  20LL,  v18,  0LL,  v20,  0LL,  0LL,  v21);
    if (!(_DWORD)v6)
    {
      unsigned __int8 v22 = v10;
      *(void *)std::stringbuf::string_type buf = &v22;
      id v15 = sub_10060F298(v7, &v22, (uint64_t)&unk_1006C2518, (char **)buf);
      *((_BYTE *)v15 + 2_Block_object_dispose(va, 8) = 18;
      *((_BYTE *)v15 + 29) = v9;
      *((_WORD *)v15 + 15) = v10;
      *((_WORD *)v15 + 16) = 1;
      *((_WORD *)v15 + 17) = v11;
      *((_WORD *)v15 + 1_Block_object_dispose(va, 8) = 20;
      *((_WORD *)v15 + 19) = v12;
      *a2 = v5;
      uint64_t v16 = sub_1002E6E9C();
      uint64_t v6 = (*(uint64_t (**)(uint64_t, uint64_t, uint64_t, uint64_t, uint64_t, uint64_t))(*(void *)v16 + 2872LL))( v16,  v5,  1LL,  10LL,  1LL,  12LL);
      if ((_DWORD)v6)
      {
        if (os_log_type_enabled((os_log_t)qword_1008F75B8, OS_LOG_TYPE_ERROR)) {
          sub_10069D5C8();
        }
      }
    }
  }

  return v6;
}

uint64_t sub_1005FBD08(uint64_t a1, int a2, int a3, _WORD *a4)
{
  *a4 = 0;
  uint64_t v4 = *(void **)(a1 + 1816);
  uint64_t v5 = (void *)(a1 + 1824);
  if (v4 == (void *)(a1 + 1824))
  {
    char v7 = 0;
LABEL_40:
    int v21 = 0;
LABEL_41:
    unsigned __int8 v22 = (os_log_s *)qword_1008F75B8;
    if (os_log_type_enabled((os_log_t)qword_1008F75B8, OS_LOG_TYPE_DEBUG))
    {
      *(_DWORD *)std::stringbuf::string_type buf = 67109120;
      int v45 = v21;
      _os_log_debug_impl((void *)&_mh_execute_header, v22, OS_LOG_TYPE_DEBUG, "MATCH TABLE nextHandle:%d", buf, 8u);
      if (!*a4) {
        return 4LL;
      }
    }

    else if (!v21)
    {
      return 4LL;
    }

    if (v7 != 5) {
      return 0LL;
    }
    unsigned __int16 v23 = (os_log_s *)qword_1008F75B8;
    if (os_log_type_enabled((os_log_t)qword_1008F75B8, OS_LOG_TYPE_ERROR)) {
      sub_10069D628(v23, v24, v25, v26, v27, v28, v29, v30);
    }
    return 4LL;
  }

  char v7 = 0;
  unint64_t v8 = *(void **)(a1 + 1816);
  do
  {
    if (*((_WORD *)v8 + 16)) {
      ++v7;
    }
    char v9 = (void *)v8[1];
    if (v9)
    {
      do
      {
        __int16 v10 = v9;
        char v9 = (void *)*v9;
      }

      while (v9);
    }

    else
    {
      do
      {
        __int16 v10 = (void *)v8[2];
        BOOL v16 = *v10 == (void)v8;
        unint64_t v8 = v10;
      }

      while (!v16);
    }

    unint64_t v8 = v10;
  }

  while (v10 != v5);
  if (v4 == v5) {
    goto LABEL_40;
  }
  while (1)
  {
    int v11 = *((unsigned __int8 *)v4 + 28);
    int v12 = *((unsigned __int16 *)v4 + 15);
    int v13 = *((unsigned __int16 *)v4 + 16);
    int v14 = *((unsigned __int16 *)v4 + 18);
    id v15 = (os_log_s *)qword_1008F75B8;
    if (os_log_type_enabled((os_log_t)qword_1008F75B8, OS_LOG_TYPE_DEBUG)) {
      break;
    }
    if (!v13) {
      goto LABEL_24;
    }
LABEL_14:
    BOOL v16 = v11 == 255 || v14 == 0;
    if (v16 && os_log_type_enabled((os_log_t)qword_1008F75B8, OS_LOG_TYPE_FAULT)) {
      sub_10069D7CC(&v40, v41);
    }
    if (v11 == a2)
    {
      int v32 = (os_log_s *)qword_1008F75B8;
      if (os_log_type_enabled((os_log_t)qword_1008F75B8, OS_LOG_TYPE_DEBUG))
      {
        *(_DWORD *)std::stringbuf::string_type buf = 67109632;
        int v45 = a2;
        __int16 v46 = 1024;
        int v47 = v12;
        __int16 v48 = 1024;
        int v49 = v14;
        _os_log_debug_impl( (void *)&_mh_execute_header,  v32,  OS_LOG_TYPE_DEBUG,  "MATCH TABLE table for type:%d is already created with handle %d and size:%d",  buf,  0x14u);
      }

      *a4 = v12;
      return 15LL;
    }

double *sub_1005FC17C(double *result, int a2, int a3)
{
  if (a2 == 22)
  {
    v9[3] = v3;
    void v9[4] = v4;
    uint64_t v5 = result;
    double v6 = result[232];
    if (a3)
    {
      if (v6 == 0.0)
      {
        uint64_t result = (double *)+[NSDate timeIntervalSinceReferenceDate]( &OBJC_CLASS___NSDate,  "timeIntervalSinceReferenceDate");
        *((void *)v5 + 232) = v7;
      }
    }

    else if (v6 > 0.0)
    {
      v9[0] = 0LL;
      if (qword_1008D6628 != -1) {
        dispatch_once(&qword_1008D6628, &stru_1008A4098);
      }
      sub_100333CAC(qword_1008D6620, 0x16u, (_DWORD *)v9 + 1, v9);
      uint64_t v8 = sub_1002E8D94();
      uint64_t result = (double *)(*(uint64_t (**)(uint64_t, double, float, float))(*(void *)v8 + 448LL))( v8,  v5[232],  *((float *)v9 + 1),  *(float *)v9);
      v5[232] = 0.0;
    }
  }

  return result;
}

void sub_1005FC230(id a1)
{
  uint64_t v1 = sub_1002E6E00();
  sub_10002418C(v5, "MatchTable");
  sub_10002418C(__p, "ADPDBufferDupNumEntries");
  (*(void (**)(uint64_t, void **, void **, int *))(*(void *)v1 + 128LL))(v1, v5, __p, &dword_1008D9C40);
  if (v4 < 0) {
    operator delete(__p[0]);
  }
  if (v6 < 0) {
    operator delete(v5[0]);
  }
  uint64_t v2 = sub_1002E6E00();
  sub_10002418C(v5, "MatchTable");
  sub_10002418C(__p, "ADPDBufferDupClearTimeoutSeconds");
  (*(void (**)(uint64_t, void **, void **, int *))(*(void *)v2 + 128LL))(v2, v5, __p, &dword_1008D9C44);
  if (v4 < 0) {
    operator delete(__p[0]);
  }
  if (v6 < 0) {
    operator delete(v5[0]);
  }
}

void sub_1005FC320( _Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, void *__p, uint64_t a10, int a11, __int16 a12, char a13, char a14, void *a15, uint64_t a16, int a17, __int16 a18, char a19, char a20)
{
  if (a14 < 0) {
    operator delete(__p);
  }
  if (a20 < 0) {
    operator delete(a15);
  }
  _Unwind_Resume(exception_object);
}

void sub_1005FC35C(uint64_t a1)
{
  uint64_t v1 = *(void *)(a1 + 32);
  uint64_t v2 = (os_log_s *)qword_1008F75B8;
  if (os_log_type_enabled((os_log_t)qword_1008F75B8, OS_LOG_TYPE_DEFAULT))
  {
    int v3 = *(unsigned __int8 *)(v1 + 144);
    LODWORD(v5[0]) = 67109120;
    HIDWORD(v5[0]) = v3;
    _os_log_impl( (void *)&_mh_execute_header,  v2,  OS_LOG_TYPE_DEFAULT,  "fAOPBTBufferPeriodicDrainTimer Timer expired! screenState:%d",  (uint8_t *)v5,  8u);
  }

  dispatch_source_cancel(*(dispatch_source_t *)(v1 + 1808));
  dispatch_release(*(dispatch_object_t *)(v1 + 1808));
  *(void *)(v1 + 180_Block_object_dispose(va, 8) = 0LL;
  uint64_t v4 = sub_100404FE8();
  v5[0] = _NSConcreteStackBlock;
  v5[1] = 3221225472LL;
  void v5[2] = sub_1005ED66C;
  v5[3] = &unk_10087EB68;
  v5[4] = v1;
  int v6 = 2;
  sub_100405384(v4, v5);
}

void sub_1005FC458(uint64_t a1)
{
  uint64_t v1 = *(void *)(a1 + 32);
  uint64_t v2 = (os_log_s *)qword_1008F75B8;
  if (os_log_type_enabled((os_log_t)qword_1008F75B8, OS_LOG_TYPE_DEFAULT))
  {
    int v3 = *(unsigned __int8 *)(v1 + 144);
    LODWORD(v5[0]) = 67109120;
    HIDWORD(v5[0]) = v3;
    _os_log_impl( (void *)&_mh_execute_header,  v2,  OS_LOG_TYPE_DEFAULT,  "fADVBufferPeriodicDrainTimer Timer expired! screenState:%d",  (uint8_t *)v5,  8u);
  }

  dispatch_source_cancel(*(dispatch_source_t *)(v1 + 1800));
  dispatch_release(*(dispatch_object_t *)(v1 + 1800));
  *(void *)(v1 + 1800) = 0LL;
  if (!*(_BYTE *)(v1 + 144))
  {
    uint64_t v4 = sub_100404FE8();
    v5[0] = _NSConcreteStackBlock;
    v5[1] = 3221225472LL;
    void v5[2] = sub_1005ED760;
    v5[3] = &unk_10087EB68;
    v5[4] = v1;
    int v6 = 3;
    sub_100405384(v4, v5);
  }

void sub_1005FC55C(id a1)
{
  uint64_t v1 = sub_1002E6E00();
  sub_10002418C(v4, "ADVBUFF");
  sub_10002418C(__p, "TestRemoevAndClearOnBufferDestroy");
  (*(void (**)(uint64_t, void **, void **, char *))(*(void *)v1 + 72LL))(v1, v4, __p, &byte_1008F1F00);
  if (v3 < 0) {
    operator delete(__p[0]);
  }
  if (v5 < 0) {
    operator delete(v4[0]);
  }
}

void sub_1005FC5E4( _Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, void *__p, uint64_t a10, int a11, __int16 a12, char a13, char a14, void *a15, uint64_t a16, int a17, __int16 a18, char a19, char a20)
{
  if (a14 < 0) {
    operator delete(__p);
  }
  if (a20 < 0) {
    operator delete(a15);
  }
  _Unwind_Resume(exception_object);
}

uint64_t sub_1005FC618(uint64_t a1)
{
  if ((_os_feature_enabled_impl("BluetoothFeatures", "SentinelNewLocationFeatures") & 1) != 0)
  {
    int v2 = *(unsigned __int8 *)(a1 + 711) | (2 * *(unsigned __int8 *)(a1 + 167));
    char v3 = *(void **)(a1 + 2040);
    if (v3 == (void *)(a1 + 2048))
    {
      LOWORD(v4) = 0;
    }

    else
    {
      int v4 = 0;
      do
      {
        uint64_t v5 = v3[5];
        if (*(_DWORD *)(*(void *)(v5 + 8) + 168LL))
        {
          else {
            int v6 = 0;
          }
          v4 |= v6 | sub_1006112F4(v3[5]);
        }

        uint64_t v7 = (void *)v3[1];
        if (v7)
        {
          do
          {
            uint64_t v8 = v7;
            uint64_t v7 = (void *)*v7;
          }

          while (v7);
        }

        else
        {
          do
          {
            uint64_t v8 = (void *)v3[2];
            BOOL v9 = *v8 == (void)v3;
            char v3 = v8;
          }

          while (!v9);
        }

        char v3 = v8;
      }

      while (v8 != (void *)(a1 + 2048));
    }

    int v12 = (unsigned __int16)v4;
    unsigned __int16 v13 = v4 ^ v2;
    int v14 = (os_log_s *)qword_1008F75B8;
    if (os_log_type_enabled((os_log_t)qword_1008F75B8, OS_LOG_TYPE_DEFAULT))
    {
      v16[0] = 67109632;
      v16[1] = v2;
      __int16 v17 = 1024;
      int v18 = v12;
      __int16 v19 = 1024;
      int v20 = v13;
      _os_log_impl( (void *)&_mh_execute_header,  v14,  OS_LOG_TYPE_DEFAULT,  "updateADVBufferConfig current:%02x new:%02x configChanged:%02x",  (uint8_t *)v16,  0x14u);
    }

    if (!v13) {
      return 0LL;
    }
    if ((v13 & 2) != 0)
    {
      if ((v12 & 2) == 0)
      {
        sub_1005E3ED4(a1, 0LL);
        if ((v13 & 1) == 0) {
          goto LABEL_39;
        }
        goto LABEL_30;
      }

      *(_BYTE *)(a1 + 170) = 0;
      if (sub_1005F313C(a1, 0LL) && os_log_type_enabled((os_log_t)qword_1008F75B8, OS_LOG_TYPE_ERROR))
      {
        sub_10069C8E4();
        if ((v13 & 1) == 0)
        {
LABEL_39:
          if (!*(_BYTE *)(a1 + 167) && !*(_BYTE *)(a1 + 711)) {
            sub_1005EBFB4(a1);
          }
          return 0LL;
        }

uint64_t sub_1005FC8FC(uint64_t a1)
{
  int v2 = *(void **)(a1 + 1816);
  if (v2 == (void *)(a1 + 1824))
  {
    LOBYTE(v3) = 0;
  }

  else
  {
    int v3 = 0;
    do
    {
      int v4 = *((unsigned __int8 *)v2 + 28);
      int v5 = v3 | 2;
      if (!*((_WORD *)v2 + 16)) {
        int v5 = v3;
      }
      int v6 = v3 | 4;
      if (!*((_WORD *)v2 + 16)) {
        int v6 = v3;
      }
      int v7 = v3 | (*((_WORD *)v2 + 16) != 0);
      if (v4 != 22) {
        int v7 = v3;
      }
      if (v4 == 7) {
        int v7 = v6;
      }
      if (*((_BYTE *)v2 + 28)) {
        int v3 = v7;
      }
      else {
        int v3 = v5;
      }
      uint64_t v8 = (void *)v2[1];
      if (v8)
      {
        do
        {
          BOOL v9 = v8;
          uint64_t v8 = (void *)*v8;
        }

        while (v8);
      }

      else
      {
        do
        {
          BOOL v9 = (void *)v2[2];
          BOOL v10 = *v9 == (void)v2;
          int v2 = v9;
        }

        while (!v10);
      }

      int v2 = v9;
    }

    while (v9 != (void *)(a1 + 1824));
  }

  int v11 = *(void **)(a1 + 2040);
  int v12 = (void *)(a1 + 2048);
  if (v11 == (void *)(a1 + 2048))
  {
    unsigned __int8 v13 = 0;
  }

  else
  {
    unsigned __int8 v13 = 0;
    do
    {
      char v14 = sub_100611318(v11[5]);
      else {
        char v15 = 0;
      }
      else {
        char v16 = 0;
      }
      __int16 v17 = (void *)v11[1];
      if (v17)
      {
        do
        {
          int v18 = v17;
          __int16 v17 = (void *)*v17;
        }

        while (v17);
      }

      else
      {
        do
        {
          int v18 = (void *)v11[2];
          BOOL v10 = *v18 == (void)v11;
          int v11 = v18;
        }

        while (!v10);
      }

      v13 |= v14 | v15 | v16;
      int v11 = v18;
    }

    while (v18 != v12);
  }

  __int16 v19 = (os_log_s *)qword_1008F75B8;
  if (os_log_type_enabled((os_log_t)qword_1008F75B8, OS_LOG_TYPE_DEBUG))
  {
    v22[0] = 67109632;
    v22[1] = v3;
    __int16 v23 = 1024;
    int v24 = v13;
    __int16 v25 = 1024;
    int v26 = (v13 ^ v3);
    _os_log_debug_impl( (void *)&_mh_execute_header,  v19,  OS_LOG_TYPE_DEBUG,  "AOPBTBUFF config current:%d new:%d configChanged:%d",  (uint8_t *)v22,  0x14u);
  }

  if (((v13 ^ v3) & 1) == 0)
  {
    uint64_t v20 = 0LL;
LABEL_53:
    if ((v13 & 2) != 0)
    {
      uint64_t v20 = sub_1005E7BF8(a1, 0LL);
      if ((_DWORD)v20 && os_log_type_enabled((os_log_t)qword_1008F75B8, OS_LOG_TYPE_ERROR)) {
        sub_10069D918();
      }
    }

    else
    {
      uint64_t v20 = sub_1005E78AC(a1, 0);
      if ((_DWORD)v20 && os_log_type_enabled((os_log_t)qword_1008F75B8, OS_LOG_TYPE_ERROR)) {
        sub_10069D8B8();
      }
    }

    goto LABEL_60;
  }

  if ((v13 & 1) == 0)
  {
    uint64_t v20 = sub_1005E78AC(a1, 22);
    if ((_DWORD)v20 && os_log_type_enabled((os_log_t)qword_1008F75B8, OS_LOG_TYPE_ERROR))
    {
      sub_10069D978();
      goto LABEL_60;
    }

id sub_1005FCC88(uint64_t a1, void *a2, void *a3)
{
  id v4 = a2;
  id v5 = a3;
  id v6 = [v4 mutableCopy];
  int v7 = (void *)objc_claimAutoreleasedReturnValue([v4 objectForKeyedSubscript:@"bypassFilterDuplicate"]);
  unsigned __int8 v8 = [v7 unsignedIntValue];

  BOOL v9 = (void *)objc_claimAutoreleasedReturnValue([v5 objectForKeyedSubscript:@"bypassFilterDuplicate"]);
  LOBYTE(v7) = [v9 unsignedIntValue];

  BOOL v10 = (void *)objc_claimAutoreleasedReturnValue([v4 objectForKeyedSubscript:@"rssi"]);
  unsigned int v11 = [v10 intValue];

  int v12 = (void *)objc_claimAutoreleasedReturnValue([v5 objectForKeyedSubscript:@"rssi"]);
  unsigned int v13 = [v12 intValue];

  BOOL v14 = (v8 | v7) != 0;
  else {
    unsigned __int8 v15 = v11;
  }
  char v16 = (void *)objc_claimAutoreleasedReturnValue(+[NSNumber numberWithUnsignedChar:](&OBJC_CLASS___NSNumber, "numberWithUnsignedChar:", v14));
  [v6 setObject:v16 forKeyedSubscript:@"bypassFilterDuplicate"];

  __int16 v17 = (void *)objc_claimAutoreleasedReturnValue(+[NSNumber numberWithChar:](&OBJC_CLASS___NSNumber, "numberWithChar:", v15));
  [v6 setObject:v17 forKeyedSubscript:@"rssi"];

  int v18 = (void *)objc_claimAutoreleasedReturnValue([v4 objectForKeyedSubscript:@"mask"]);
  uint64_t v19 = objc_claimAutoreleasedReturnValue([v5 objectForKeyedSubscript:@"mask"]);
  uint64_t v20 = (void *)v19;
  memset(v27, 0, sizeof(v27));
  char v28 = 0;
  if (!v18) {
    goto LABEL_12;
  }
  if (!v19) {
    goto LABEL_12;
  }
  id v21 = [v18 length];
  if (v21 != [v20 length] || !objc_msgSend(v18, "length") || !objc_msgSend(v20, "length")) {
    goto LABEL_12;
  }
  unsigned __int8 v22 = (void *)objc_claimAutoreleasedReturnValue( +[NSData dataWithBytes:length:]( NSData,  "dataWithBytes:length:",  v27,  [v18 length]));
  if ([v18 isEqual:v22])
  {

LABEL_12:
    [v6 setObject:0 forKeyedSubscript:@"mask"];
    [v6 setObject:0 forKeyedSubscript:@"data"];
    goto LABEL_13;
  }

  __int16 v23 = (void *)objc_claimAutoreleasedReturnValue( +[NSData dataWithBytes:length:]( NSData,  "dataWithBytes:length:",  v27,  [v20 length]));
  unsigned int v24 = [v20 isEqual:v23];

  if (v24) {
    goto LABEL_12;
  }
LABEL_13:
  id v25 = [v6 copy];

  return v25;
}

void sub_1005FCF50(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

uint64_t sub_1005FCFEC(uint64_t a1, void *a2)
{
  id v2 = a2;
  int v3 = (void *)objc_claimAutoreleasedReturnValue([v2 objectForKeyedSubscript:@"data"]);
  unsigned __int16 v4 = (unsigned __int16)[v3 length];

  id v5 = (void *)objc_claimAutoreleasedReturnValue([v2 objectForKeyedSubscript:@"mask"]);
  unsigned __int16 v6 = (unsigned __int16)[v5 length];

  uint64_t v7 = sub_1002E6E9C();
  int v8 = v4;
  if (v4 <= (*(unsigned int (**)(uint64_t))(*(void *)v7 + 3504LL))(v7)
    && (uint64_t v9 = sub_1002E6E9C(), v6 <= (*(unsigned int (**)(uint64_t))(*(void *)v9 + 3504LL))(v9)))
  {
    uint64_t v11 = 1LL;
  }

  else
  {
    BOOL v10 = (os_log_s *)qword_1008F75B8;
    if (os_log_type_enabled((os_log_t)qword_1008F75B8, OS_LOG_TYPE_ERROR))
    {
      unsigned int v13 = (void *)objc_claimAutoreleasedReturnValue([v2 objectForKeyedSubscript:@"puckType"]);
      v14[0] = 67109890;
      v14[1] = v8;
      __int16 v15 = 1024;
      int v16 = v6;
      __int16 v17 = 2112;
      int v18 = v13;
      __int16 v19 = 2112;
      id v20 = v2;
      _os_log_error_impl( (void *)&_mh_execute_header,  v10,  OS_LOG_TYPE_ERROR,  "The blobLen(%d) and maskLen(%d) are not support for this rule type %@, %@ ",  (uint8_t *)v14,  0x22u);
    }

    uint64_t v11 = 0LL;
  }

  return v11;
}

void sub_1005FD174(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_1005FD1A4(uint64_t a1, void *a2)
{
  id v3 = a2;
  unsigned __int16 v4 = (os_log_s *)qword_1008F75B8;
  if (os_log_type_enabled((os_log_t)qword_1008F75B8, OS_LOG_TYPE_INFO))
  {
    int v5 = *(unsigned __int8 *)(a1 + 144);
    *(_DWORD *)std::stringbuf::string_type buf = 138412546;
    *(void *)&uint8_t buf[4] = v3;
    *(_WORD *)&_BYTE buf[12] = 1024;
    *(_DWORD *)&buf[14] = v5;
    _os_log_impl( (void *)&_mh_execute_header,  v4,  OS_LOG_TYPE_INFO,  "addUniqueUUIDRulesToDictionary %@ fScreenState:%d",  buf,  0x12u);
  }

  if (*(_BYTE *)(a1 + 144))
  {
    *(void *)std::stringbuf::string_type buf = 0LL;
    *(void *)&uint8_t buf[8] = buf;
    *(void *)&uint8_t buf[16] = 0x3032000000LL;
    uint64_t v30 = sub_1005FD514;
    int v31 = sub_1005FD524;
    id v32 = 0LL;
    unsigned __int16 v6 = *(void **)(a1 + 4360);
    __int16 v19 = _NSConcreteStackBlock;
    uint64_t v20 = 3221225472LL;
    id v21 = sub_1005FD52C;
    unsigned __int8 v22 = &unk_1008A3D70;
    id v7 = v3;
    id v23 = v7;
    unsigned int v24 = buf;
    [v6 enumerateObjectsUsingBlock:&v19];
    id v8 = objc_msgSend(v7, "mutableCopy", v19, v20, v21, v22);
    if (*(void *)(*(void *)&buf[8] + 40LL))
    {
      objc_msgSend(*(id *)(a1 + 4360), "removeObject:");
      uint64_t v9 = objc_opt_new(&OBJC_CLASS___NSData);
      [v8 setObject:v9 forKeyedSubscript:@"data"];

      BOOL v10 = objc_opt_new(&OBJC_CLASS___NSData);
      [v8 setObject:v10 forKeyedSubscript:@"mask"];

      uint64_t v11 = (void *)objc_claimAutoreleasedReturnValue([*(id *)(*(void *)&buf[8] + 40) objectForKeyedSubscript:@"rssi"]);
      signed __int8 v12 = [v11 intValue];
      unsigned int v13 = (void *)objc_claimAutoreleasedReturnValue([v7 objectForKeyedSubscript:@"rssi"]);
      signed __int8 v14 = [v13 intValue];
      if (v14 >= v12) {
        unsigned __int8 v15 = v12;
      }
      else {
        unsigned __int8 v15 = v14;
      }
      int v16 = (void *)objc_claimAutoreleasedReturnValue(+[NSNumber numberWithChar:](&OBJC_CLASS___NSNumber, "numberWithChar:", v15));
      [v8 setObject:v16 forKeyedSubscript:@"rssi"];

      __int16 v17 = (os_log_s *)qword_1008F75B8;
      if (os_log_type_enabled((os_log_t)qword_1008F75B8, OS_LOG_TYPE_INFO))
      {
        uint64_t v18 = *(void *)(*(void *)&buf[8] + 40LL);
        *(_DWORD *)id v25 = 138412546;
        uint64_t v26 = v18;
        __int16 v27 = 2112;
        id v28 = v8;
        _os_log_impl( (void *)&_mh_execute_header,  v17,  OS_LOG_TYPE_INFO,  "addUniqueUUIDRulesToDictionary removing [%@] and replacing with [%@]",  v25,  0x16u);
      }
    }

    [*(id *)(a1 + 4360) addObject:v8];

    _Block_object_dispose(buf, 8);
  }

  else
  {
    [*(id *)(a1 + 4360) addObject:v3];
  }
}

void sub_1005FD484(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

uint64_t sub_1005FD514(uint64_t result, uint64_t a2)
{
  *(void *)(result + 40) = *(void *)(a2 + 40);
  *(void *)(a2 + 40) = 0LL;
  return result;
}

void sub_1005FD524(uint64_t a1)
{
}

void sub_1005FD52C(uint64_t a1, void *a2, uint64_t a3, _BYTE *a4)
{
  id v7 = a2;
  id v8 = (void *)objc_claimAutoreleasedReturnValue([*(id *)(a1 + 32) objectForKeyedSubscript:@"uuid"]);
  uint64_t v9 = (void *)objc_claimAutoreleasedReturnValue([v7 objectForKeyedSubscript:@"uuid"]);
  unsigned int v10 = [v8 isEqual:v9];

  if (v10)
  {
    objc_storeStrong((id *)(*(void *)(*(void *)(a1 + 40) + 8LL) + 40LL), a2);
    *a4 = 1;
    uint64_t v11 = (os_log_s *)qword_1008F75B8;
    if (os_log_type_enabled((os_log_t)qword_1008F75B8, OS_LOG_TYPE_INFO))
    {
      uint64_t v12 = *(void *)(a1 + 32);
      uint64_t v13 = *(void *)(*(void *)(*(void *)(a1 + 40) + 8LL) + 40LL);
      int v14 = 138412546;
      uint64_t v15 = v13;
      __int16 v16 = 2112;
      uint64_t v17 = v12;
      _os_log_impl( (void *)&_mh_execute_header,  v11,  OS_LOG_TYPE_INFO,  "addUniqueUUIDRulesToDictionary found existing rule [%@] with same uuid as new rule [%@]",  (uint8_t *)&v14,  0x16u);
    }
  }
}

void sub_1005FD678(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_1005FD6A8(uint64_t a1, void *a2)
{
  id v2 = a2;
  double v69 = (void *)objc_claimAutoreleasedReturnValue(+[NSMutableArray array](&OBJC_CLASS___NSMutableArray, "array"));
  if (sub_1005FCFEC((uint64_t)v69, v2))
  {
    __int128 v79 = 0u;
    __int128 v80 = 0u;
    __int128 v77 = 0u;
    __int128 v78 = 0u;
    id obj = *(id *)(a1 + 4352);
    id v3 = [obj countByEnumeratingWithState:&v77 objects:v91 count:16];
    if (v3)
    {
      uint64_t v71 = *(void *)v78;
      *(void *)&__int128 v4 = 67109632LL;
      __int128 v63 = v4;
      do
      {
        id v72 = v3;
        for (uint64_t i = 0LL; i != v72; uint64_t i = (char *)i + 1)
        {
          if (*(void *)v78 != v71) {
            objc_enumerationMutation(obj);
          }
          unsigned __int16 v6 = *(void **)(*((void *)&v77 + 1) + 8LL * (void)i);
          id v7 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(v6, "objectForKeyedSubscript:", @"puckType", v63));
          id v8 = (void *)objc_claimAutoreleasedReturnValue([v2 objectForKeyedSubscript:@"puckType"]);
          unsigned int v9 = [v7 isEqual:v8];

          if (!v9) {
            continue;
          }
          unsigned int v10 = (os_log_s *)qword_1008F75B8;
          if (os_log_type_enabled((os_log_t)qword_1008F75B8, OS_LOG_TYPE_INFO))
          {
            uint64_t v11 = (void *)objc_claimAutoreleasedReturnValue([v6 objectForKeyedSubscript:@"puckType"]);
            uint64_t v12 = (void *)objc_claimAutoreleasedReturnValue([v2 objectForKeyedSubscript:@"shouldConsolidateRule"]);
            unsigned int v13 = [v12 BOOLValue];
            *(_DWORD *)std::stringbuf::string_type buf = 138413058;
            *(void *)&uint8_t buf[4] = v11;
            *(_WORD *)&_BYTE buf[12] = 1024;
            *(_DWORD *)&buf[14] = v13;
            *(_WORD *)&_BYTE buf[18] = 2112;
            *(void *)&_BYTE buf[20] = v6;
            *(_WORD *)&buf[28] = 2112;
            *(void *)&buf[30] = v2;
            _os_log_impl( (void *)&_mh_execute_header,  v10,  OS_LOG_TYPE_INFO,  "Already have this rule for type %@ consolidate %d %@ new rule %@.",  buf,  0x26u);
          }

          int v14 = (void *)objc_claimAutoreleasedReturnValue([v6 objectForKeyedSubscript:@"bypassFilterDuplicate"]);
          uint64_t v15 = (void *)objc_claimAutoreleasedReturnValue([v2 objectForKeyedSubscript:@"bypassFilterDuplicate"]);
          if (([v14 isEqualToNumber:v15] & 1) == 0)
          {

LABEL_14:
            __int16 v19 = (os_log_s *)qword_1008F75B8;
            if (os_log_type_enabled((os_log_t)qword_1008F75B8, OS_LOG_TYPE_INFO))
            {
              uint64_t v20 = (void *)objc_claimAutoreleasedReturnValue([v6 objectForKeyedSubscript:@"puckType"]);
              id v21 = (void *)objc_claimAutoreleasedReturnValue([v6 objectForKeyedSubscript:@"bypassFilterDuplicate"]);
              unsigned __int8 v22 = (void *)objc_claimAutoreleasedReturnValue([v6 objectForKeyedSubscript:@"rssi"]);
              id v23 = (void *)objc_claimAutoreleasedReturnValue([v2 objectForKeyedSubscript:@"bypassFilterDuplicate"]);
              unsigned int v24 = (void *)objc_claimAutoreleasedReturnValue([v2 objectForKeyedSubscript:@"rssi"]);
              *(_DWORD *)std::stringbuf::string_type buf = 138413314;
              *(void *)&uint8_t buf[4] = v20;
              *(_WORD *)&_BYTE buf[12] = 2112;
              *(void *)&buf[14] = v21;
              *(_WORD *)&_BYTE buf[22] = 2112;
              *(void *)&_BYTE buf[24] = v22;
              *(_WORD *)&_BYTE buf[32] = 2112;
              *(void *)&buf[34] = v23;
              __int16 v89 = 2112;
              __int128 v90 = v24;
              _os_log_impl( (void *)&_mh_execute_header,  v19,  OS_LOG_TYPE_INFO,  "Consolidate rules type %@ old bypassFilterDuplicate %@ rssi %@ new bypassFilterDuplicate %@ rssi %@",  buf,  0x34u);
            }

            goto LABEL_16;
          }

          __int16 v16 = (void *)objc_claimAutoreleasedReturnValue([v6 objectForKeyedSubscript:@"rssi"]);
          uint64_t v17 = (void *)objc_claimAutoreleasedReturnValue([v2 objectForKeyedSubscript:@"rssi"]);
          unsigned __int8 v18 = [v16 isEqualToNumber:v17];

          if ((v18 & 1) == 0) {
            goto LABEL_14;
          }
LABEL_16:
          id v25 = (void *)objc_claimAutoreleasedReturnValue([v2 objectForKeyedSubscript:@"shouldConsolidateRule"]);
          if (v25)
          {
            uint64_t v26 = (void *)objc_claimAutoreleasedReturnValue([v2 objectForKeyedSubscript:@"shouldConsolidateRule"]);
            unsigned int v27 = [v26 BOOLValue];

            int v28 = v27 ^ 1;
          }

          else
          {
            int v28 = 0;
          }

          uint64_t v29 = (void *)objc_claimAutoreleasedReturnValue([v6 objectForKeyedSubscript:@"shouldConsolidateRule"]);
          if (v29)
          {
            uint64_t v30 = (void *)objc_claimAutoreleasedReturnValue([v6 objectForKeyedSubscript:@"shouldConsolidateRule"]);
            unsigned int v31 = [v30 BOOLValue];

            int v32 = v31 ^ 1;
          }

          else
          {
            int v32 = 0;
          }

          if ((v28 | v32) != 1) {
            goto LABEL_35;
          }
          int v33 = (void *)objc_claimAutoreleasedReturnValue([v2 objectForKeyedSubscript:@"data"]);
          uint64_t v34 = objc_claimAutoreleasedReturnValue([v6 objectForKeyedSubscript:@"data"]);
          BOOL v35 = (void *)v34;
          if (!v33 || !v34) {
            goto LABEL_34;
          }
          memset(buf, 0, 25);
          uint64_t v68 = (void *)objc_claimAutoreleasedReturnValue( +[NSData dataWithBytes:length:]( NSData,  "dataWithBytes:length:",  buf,  [v33 length]));
          uint64_t v36 = (void *)objc_claimAutoreleasedReturnValue( +[NSData dataWithBytes:length:]( NSData,  "dataWithBytes:length:",  buf,  [v35 length]));
          if (([v35 isEqualToData:v36] & 1) != 0
            || ([v33 isEqualToData:v68] & 1) != 0
            || ([v35 isEqualToData:v33] & 1) != 0)
          {
            if (([v35 isEqualToData:v33] & 1) != 0
              || (__int16 v37 = (void *)objc_claimAutoreleasedReturnValue([v6 objectForKeyedSubscript:@"matchAllDevices"]),
                  char v38 = (void *)objc_claimAutoreleasedReturnValue([v2 objectForKeyedSubscript:@"matchAllDevices"]),
                  unsigned __int8 v39 = [v37 isEqualToNumber:v38],
                  v38,
                  v37,
                  (v39 & 1) != 0))
            {
              char v40 = (void *)objc_claimAutoreleasedReturnValue([v6 objectForKeyedSubscript:@"rssi"]);
              __int128 v41 = (void *)objc_claimAutoreleasedReturnValue([v2 objectForKeyedSubscript:@"rssi"]);
              unsigned __int8 v42 = [v40 isEqualToNumber:v41];

              uint64_t v43 = (os_log_s *)qword_1008F75B8;
              if ((v42 & 1) != 0)
              {
                if (os_log_type_enabled((os_log_t)qword_1008F75B8, OS_LOG_TYPE_DEBUG))
                {
                  uint64_t v66 = (void *)objc_claimAutoreleasedReturnValue([v2 objectForKeyedSubscript:@"puckType"]);
                  unsigned int v65 = [v66 intValue];
                  __int16 v52 = (void *)objc_claimAutoreleasedReturnValue([v2 objectForKeyedSubscript:@"rssi"]);
                  unsigned int v64 = [v52 intValue];
                  BOOL v53 = (void *)objc_claimAutoreleasedReturnValue([v2 objectForKeyedSubscript:@"shouldConsolidateRule"]);
                  unsigned int v54 = [v53 intValue];
                  *(_DWORD *)uint64_t v82 = v63;
                  unsigned int v83 = v65;
                  __int16 v84 = 1024;
                  unsigned int v85 = v64;
                  __int16 v86 = 1024;
                  unsigned int v87 = v54;
                  _os_log_debug_impl( (void *)&_mh_execute_header,  v43,  OS_LOG_TYPE_DEBUG,  "New rule for type %d rssi:%d shouldConsolidate:%d is the same - consolidating",  v82,  0x14u);
                }

LABEL_34:
LABEL_35:
                [v69 addObject:v6];
                continue;
              }

              if (os_log_type_enabled((os_log_t)qword_1008F75B8, OS_LOG_TYPE_DEFAULT))
              {
                uint64_t v44 = (void *)objc_claimAutoreleasedReturnValue([v2 objectForKeyedSubscript:@"puckType"]);
                unsigned int v45 = [v44 intValue];
                *(_DWORD *)uint64_t v82 = 67109120;
                unsigned int v83 = v45;
                _os_log_impl( (void *)&_mh_execute_header,  v43,  OS_LOG_TYPE_DEFAULT,  "rssi is different for type %d - ignore consolidating",  v82,  8u);
              }
            }

            else
            {
              __int16 v46 = (os_log_s *)qword_1008F75B8;
              if (os_log_type_enabled((os_log_t)qword_1008F75B8, OS_LOG_TYPE_DEFAULT))
              {
                int v47 = (void *)objc_claimAutoreleasedReturnValue([v2 objectForKeyedSubscript:@"puckType"]);
                unsigned int v48 = [v47 intValue];
                *(_DWORD *)uint64_t v82 = 67109120;
                unsigned int v83 = v48;
                _os_log_impl( (void *)&_mh_execute_header,  v46,  OS_LOG_TYPE_DEFAULT,  "device filer is different for type %d - ignore consolidating",  v82,  8u);
              }
            }
          }

          else
          {
            int v49 = (os_log_s *)qword_1008F75B8;
            if (os_log_type_enabled((os_log_t)qword_1008F75B8, OS_LOG_TYPE_DEFAULT))
            {
              __int16 v50 = (void *)objc_claimAutoreleasedReturnValue([v2 objectForKeyedSubscript:@"puckType"]);
              unsigned int v51 = [v50 intValue];
              *(_DWORD *)uint64_t v82 = 67109120;
              unsigned int v83 = v51;
              _os_log_impl( (void *)&_mh_execute_header,  v49,  OS_LOG_TYPE_DEFAULT,  "non-zero data is different for type %d - ignore consolidating",  v82,  8u);
            }
          }
        }

        id v3 = [obj countByEnumeratingWithState:&v77 objects:v91 count:16];
      }

      while (v3);
    }

    if ([v69 count])
    {
      id v55 = [v2 copy];
      __int128 v75 = 0u;
      __int128 v76 = 0u;
      __int128 v73 = 0u;
      __int128 v74 = 0u;
      id v56 = v69;
      id v57 = [v56 countByEnumeratingWithState:&v73 objects:v81 count:16];
      id v58 = v57;
      if (v57)
      {
        uint64_t v59 = *(void *)v74;
        do
        {
          unsigned int v60 = 0LL;
          int v61 = v55;
          do
          {
            if (*(void *)v74 != v59) {
              objc_enumerationMutation(v56);
            }
            id v62 = sub_1005FCC88((uint64_t)v57, *(void **)(*((void *)&v73 + 1) + 8LL * (void)v60), v61);
            id v55 = (id)objc_claimAutoreleasedReturnValue(v62);

            unsigned int v60 = (char *)v60 + 1;
            int v61 = v55;
          }

          while (v58 != v60);
          id v57 = [v56 countByEnumeratingWithState:&v73 objects:v81 count:16];
          id v58 = v57;
        }

        while (v57);
      }

      [*(id *)(a1 + 4352) removeObjectsInArray:v56];
      [*(id *)(a1 + 4352) addObject:v55];
    }

    else
    {
      [*(id *)(a1 + 4352) addObject:v2];
    }
  }
}

void sub_1005FE00C( _Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20, uint64_t a21, uint64_t a22, void *a23)
{
  _Unwind_Resume(a1);
}

uint64_t sub_1005FE210(uint64_t a1)
{
  uint64_t v2 = sub_1002E6BF0();
  if ((*(unsigned int (**)(uint64_t))(*(void *)v2 + 592LL))(v2))
  {
    id v3 = *(void **)(a1 + 2040);
    if (v3 != (void *)(a1 + 2048))
    {
      char v4 = 0;
      while (1)
      {
        if (sub_100617C84(v3[5]) && !sub_100611304(v3[5]))
        {
          uint64_t v5 = v3[5];
          if (!*(_BYTE *)(*(void *)(v5 + 8) + 143LL) || !*(_BYTE *)(a1 + 1255)) {
            break;
          }
        }

void sub_1005FE3B0(uint64_t a1)
{
  unint64_t v148 = (_BYTE *)(a1 + 4296);
  int v149 = *(unsigned __int8 *)(a1 + 4382);
  if (os_log_type_enabled((os_log_t)qword_1008F75B8, OS_LOG_TYPE_DEBUG)) {
    sub_10069DB60();
  }
  if (v148[85])
  {
    uint64_t v1 = sub_1002E6E9C();
    (*(void (**)(uint64_t))(*(void *)v1 + 616LL))(v1);
    uint64_t v2 = sub_1002E6E9C();
    (*(void (**)(uint64_t, uint64_t))(*(void *)v2 + 400LL))(v2, 1LL);
    uint64_t v3 = sub_1002E6E9C();
    (*(void (**)(uint64_t, uint64_t))(*(void *)v3 + 392LL))(v3, 1LL);
    uint64_t v4 = sub_1002E6E9C();
    (*(void (**)(uint64_t))(*(void *)v4 + 632LL))(v4);
    uint64_t v5 = sub_1002E6E9C();
    (*(void (**)(uint64_t))(*(void *)v5 + 776LL))(v5);
  }

  sub_1005E4988(a1);
  _BYTE *v148 = 1;
  uint64_t v201 = 0LL;
  int v200 = 0LL;
  __int128 v199 = (uint64_t *)&v200;
  unint64_t v198 = 0LL;
  __int128 v197 = 0LL;
  __int128 v196 = (uint64_t *)&v197;
  int v6 = *(void **)(a1 + 2040);
  __int16 v166 = (void *)(a1 + 2048);
  if (v6 == (void *)(a1 + 2048)) {
    goto LABEL_233;
  }
  do
  {
    uint64_t v7 = v6[5];
    memset(__dst, 0, 24);
    uint64_t v163 = v7;
    sub_1000516DC( __dst,  *(void *)(*(void *)(v7 + 8) + 64LL),  *(void *)(*(void *)(v7 + 8) + 72LL),  0xAAAAAAAAAAAAAAABLL * ((uint64_t)(*(void *)(*(void *)(v7 + 8) + 72LL) - *(void *)(*(void *)(v7 + 8) + 64LL)) >> 5));
    uint64_t v8 = *(void *)__dst;
    if (*(void *)__dst == *(void *)&__dst[8])
    {
      LOBYTE(v11) = 0;
    }

    else
    {
      do
      {
        id v9 = *(id *)(v8 + 56);
        __int128 v192 = 0u;
        __int128 v193 = 0u;
        __int128 v194 = 0u;
        __int128 v195 = 0u;
        id v10 = v9;
        id v11 = [v10 countByEnumeratingWithState:&v192 objects:v219 count:16];
        if (v11)
        {
          uint64_t v12 = *(void *)v193;
          while (2)
          {
            unsigned int v13 = 0LL;
            do
            {
              if (*(void *)v193 != v12) {
                objc_enumerationMutation(v10);
              }
              int v14 = *(void **)(*((void *)&v192 + 1) + 8LL * (void)v13);
              *(void *)std::stringbuf::string_type __p = 0LL;
              if (qword_1008D5F30 != -1) {
                dispatch_once(&qword_1008D5F30, &stru_1008A40B8);
              }
              *(void *)std::stringbuf::string_type __p = sub_1005CC198((uint64_t)off_1008D5F28, v14, 0);
              if (*(void *)__p)
              {
                sub_1002555B0(&v196, (unint64_t *)__p, (uint64_t *)__p);
                if (v198 >= 0x1F)
                {
                  if (os_log_type_enabled((os_log_t)qword_1008F75B8, OS_LOG_TYPE_ERROR)) {
                    sub_10069DB34(&v190, v191);
                  }
                  LOBYTE(v11) = 1;
                  goto LABEL_25;
                }
              }

              else
              {
                uint64_t v15 = (os_log_s *)qword_1008F75B8;
                if (os_log_type_enabled((os_log_t)qword_1008F75B8, OS_LOG_TYPE_INFO))
                {
                  *(_WORD *)std::stringbuf::string_type buf = 0;
                  _os_log_impl( (void *)&_mh_execute_header,  v15,  OS_LOG_TYPE_INFO,  "Tried to add device to matching list that was not present",  buf,  2u);
                }
              }

              unsigned int v13 = (char *)v13 + 1;
            }

            while (v11 != v13);
            id v11 = [v10 countByEnumeratingWithState:&v192 objects:v219 count:16];
            if (v11) {
              continue;
            }
            break;
          }
        }

LABEL_212:
    __int128 v172 = 0u;
    __int128 v173 = 0u;
    __int128 v170 = 0u;
    __int128 v171 = 0u;
    id v133 = *(id *)(a1 + 4360);
    id v134 = [v133 countByEnumeratingWithState:&v170 objects:v204 count:16];
    if (v134)
    {
      uint64_t v135 = *(void *)v171;
      while (2)
      {
        for (uint64_t k = 0LL; k != v134; uint64_t k = (char *)k + 1)
        {
          if (*(void *)v171 != v135) {
            objc_enumerationMutation(v133);
          }
          int v137 = *(void **)(*((void *)&v170 + 1) + 8LL * (void)k);
          memset(buf, 0, 20);
          id v138 = objc_claimAutoreleasedReturnValue([v137 objectForKeyedSubscript:@"uuid"]);
          size_t v139 = (int8x16_t *)[v138 bytes];
          int v140 = (void *)objc_claimAutoreleasedReturnValue([v137 objectForKeyedSubscript:@"uuid"]);
          sub_1006343C4((uint64_t)buf, v139, [v140 length]);

          uint64_t v141 = sub_1002E6E9C();
          __int128 v202 = *(_OWORD *)buf;
          int v203 = *(_DWORD *)&buf[16];
          uint64_t v142 = (void *)objc_claimAutoreleasedReturnValue([v137 objectForKeyedSubscript:@"data"]);
          LOBYTE(v140) = [v142 length];
          id v143 = objc_claimAutoreleasedReturnValue([v137 objectForKeyedSubscript:@"data"]);
          id v144 = [v143 bytes];
          id v145 = objc_claimAutoreleasedReturnValue([v137 objectForKeyedSubscript:@"mask"]);
          LOBYTE(v146) = 1;
          LODWORD(v140) = (*(uint64_t (**)(uint64_t, __int128 *, void, uint64_t, uint64_t, void, id, id, int))(*(void *)v141 + 416))( v141,  &v202,  0,  169,  1,  v140,  v144,  [v145 bytes],  v146);

          if ((_DWORD)v140)
          {
            if (os_log_type_enabled((os_log_t)qword_1008F75B8, OS_LOG_TYPE_ERROR))
            {
              sub_1006344B4((uint64_t)buf, __p);
              sub_10069DA38();
            }

            goto LABEL_223;
          }
        }

        id v134 = [v133 countByEnumeratingWithState:&v170 objects:v204 count:16];
        if (v134) {
          continue;
        }
        break;
      }
    }

LABEL_223:
  }

  *(_BYTE *)(a1 + 184_Block_object_dispose(va, 8) = 1;
  if (v149 || v148[85]) {
    sub_1005FFF7C(a1, *(_BYTE *)(a1 + 1843));
  }
  else {
    _BYTE *v148 = 0;
  }
  *(_BYTE *)(a1 + 1847) = 0;
  *(_DWORD *)(a1 + 1843) = 0;
  sub_10023BF24((uint64_t)&v196, v197);
  sub_10023BF24((uint64_t)&v199, v200);
}

void sub_1005FFC40(_Unwind_Exception *a1)
{
}

void sub_1005FFF7C(uint64_t a1, char a2)
{
  if (os_log_type_enabled((os_log_t)qword_1008F75B8, OS_LOG_TYPE_DEBUG)) {
    sub_10069DBFC();
  }
  uint64_t v4 = sub_100405138();
  v5[0] = _NSConcreteStackBlock;
  v5[1] = 3221225472LL;
  void v5[2] = sub_100607B60;
  v5[3] = &unk_1008800D8;
  v5[4] = a1;
  char v6 = a2;
  sub_100405384(v4, v5);
}

BOOL sub_10060001C(uint64_t a1)
{
  uint64_t v1 = *(void **)(a1 + 2040);
  uint64_t v2 = (void *)(a1 + 2048);
  if (v1 == (void *)(a1 + 2048)) {
    return 0LL;
  }
  do
  {
    BOOL result = *(_BYTE *)(*(void *)(v1[5] + 8LL) + 142LL) != 0;
    if (*(_BYTE *)(*(void *)(v1[5] + 8LL) + 142LL)) {
      break;
    }
    uint64_t v4 = (void *)v1[1];
    if (v4)
    {
      do
      {
        uint64_t v5 = v4;
        uint64_t v4 = (void *)*v4;
      }

      while (v4);
    }

    else
    {
      do
      {
        uint64_t v5 = (void *)v1[2];
        BOOL v6 = *v5 == (void)v1;
        uint64_t v1 = v5;
      }

      while (!v6);
    }

    uint64_t v1 = v5;
  }

  while (v5 != v2);
  return result;
}

uint64_t sub_100600088(uint64_t a1)
{
  uint64_t v1 = *(void **)(a1 + 2040);
  uint64_t v2 = (void *)(a1 + 2048);
  if (v1 != (void *)(a1 + 2048))
  {
    do
    {
      uint64_t v4 = v1[5];
      if (sub_100617C84(v4))
      {
        uint64_t v5 = *(void *)(v4 + 8);
        if (*(_BYTE *)(v5 + 143) || *(_BYTE *)(v5 + 122) || *(_WORD *)(v5 + 124)) {
          return 1LL;
        }
        if (!sub_100610DAC(v4) || *(_BYTE *)(a1 + 144))
        {
          unsigned int v6 = *(unsigned __int8 *)(v4 + 81);
          if (v6 <= 0x20)
          {
            if (((1LL << v6) & 0x114) != 0)
            {
              if (sub_100610CCC(v4)) {
                return 1LL;
              }
            }

            else if (((1LL << v6) & 0x100010000LL) != 0)
            {
              return 1LL;
            }
          }
        }
      }

      uint64_t v7 = (void *)v1[1];
      if (v7)
      {
        do
        {
          uint64_t v8 = v7;
          uint64_t v7 = (void *)*v7;
        }

        while (v7);
      }

      else
      {
        do
        {
          uint64_t v8 = (void *)v1[2];
          BOOL v9 = *v8 == (void)v1;
          uint64_t v1 = v8;
        }

        while (!v9);
      }

      uint64_t v1 = v8;
    }

    while (v8 != v2);
  }

  return 0LL;
}

BOOL sub_100600194(uint64_t a1)
{
  uint64_t v1 = *(void **)(a1 + 2040);
  uint64_t v2 = (void *)(a1 + 2048);
  if (v1 == (void *)(a1 + 2048)) {
    return 0LL;
  }
  do
  {
    BOOL result = *(_BYTE *)(*(void *)(v1[5] + 8LL) + 3LL) != 0;
    if (*(_BYTE *)(*(void *)(v1[5] + 8LL) + 3LL)) {
      break;
    }
    uint64_t v4 = (void *)v1[1];
    if (v4)
    {
      do
      {
        uint64_t v5 = v4;
        uint64_t v4 = (void *)*v4;
      }

      while (v4);
    }

    else
    {
      do
      {
        uint64_t v5 = (void *)v1[2];
        BOOL v6 = *v5 == (void)v1;
        uint64_t v1 = v5;
      }

      while (!v6);
    }

    uint64_t v1 = v5;
  }

  while (v5 != v2);
  return result;
}

uint64_t sub_100600200(uint64_t a1)
{
  uint64_t v1 = *(void **)(a1 + 2040);
  if (v1 != (void *)(a1 + 2048))
  {
    do
    {
      uint64_t v2 = *(void *)(v1[5] + 8LL);
      uint64_t v3 = *(void *)(v2 + 96);
      uint64_t v4 = *(void *)(v2 + 104);
      while (v3 != v4)
      {
        if (*(_DWORD *)(v3 + 104) == 2) {
          return 1LL;
        }
        v3 += 112LL;
      }

      uint64_t v5 = (void *)v1[1];
      if (v5)
      {
        do
        {
          BOOL v6 = v5;
          uint64_t v5 = (void *)*v5;
        }

        while (v5);
      }

      else
      {
        do
        {
          BOOL v6 = (void *)v1[2];
          BOOL v7 = *v6 == (void)v1;
          uint64_t v1 = v6;
        }

        while (!v7);
      }

      uint64_t v1 = v6;
    }

    while (v6 != (void *)(a1 + 2048));
  }

  return 0LL;
}

uint64_t sub_100600280(uint64_t a1)
{
  uint64_t v1 = *(void **)(a1 + 2040);
  if (v1 != (void *)(a1 + 2048))
  {
    do
    {
      uint64_t v2 = *(void *)(v1[5] + 8LL);
      uint64_t v3 = *(void *)(v2 + 96);
      uint64_t v4 = *(void *)(v2 + 104);
      while (v3 != v4)
      {
        if (*(_DWORD *)(v3 + 104) == 3) {
          return 1LL;
        }
        v3 += 112LL;
      }

      uint64_t v5 = (void *)v1[1];
      if (v5)
      {
        do
        {
          BOOL v6 = v5;
          uint64_t v5 = (void *)*v5;
        }

        while (v5);
      }

      else
      {
        do
        {
          BOOL v6 = (void *)v1[2];
          BOOL v7 = *v6 == (void)v1;
          uint64_t v1 = v6;
        }

        while (!v7);
      }

      uint64_t v1 = v6;
    }

    while (v6 != (void *)(a1 + 2048));
  }

  return 0LL;
}

void sub_100600300(uint64_t a1)
{
  if (!*(void *)(a1 + 2344))
  {
    uint64_t v2 = sub_1002E91F8(2LL, 6LL, 0LL);
    *(void *)(a1 + 2344) = v2;
    if (v2)
    {
      uint64_t v3 = v2;
      uint64_t v4 = (os_log_s *)qword_1008F7668;
      if (os_log_type_enabled((os_log_t)qword_1008F7668, OS_LOG_TYPE_DEFAULT))
      {
        uint64_t v5 = (*(uint64_t (**)(void *))(*(void *)v3 + 16LL))(v3);
        int v6 = 136446210;
        uint64_t v7 = v5;
        _os_log_impl((void *)&_mh_execute_header, v4, OS_LOG_TYPE_DEFAULT, "Creating %{public}s", (uint8_t *)&v6, 0xCu);
      }
    }
  }

void sub_1006003D8(uint64_t a1)
{
  uint64_t v1 = *(void *)(a1 + 2344);
  if (v1)
  {
    uint64_t v3 = (os_log_s *)qword_1008F7668;
    if (!os_log_type_enabled((os_log_t)qword_1008F7668, OS_LOG_TYPE_DEFAULT)
      || (uint64_t v4 = (*(uint64_t (**)(uint64_t))(*(void *)v1 + 16LL))(v1),
          int v5 = 136446210,
          uint64_t v6 = v4,
          _os_log_impl( (void *)&_mh_execute_header,  v3,  OS_LOG_TYPE_DEFAULT,  "Destroying %{public}s",  (uint8_t *)&v5,  0xCu),  (uint64_t v1 = *(void *)(a1 + 2344)) != 0))
    {
      (*(void (**)(uint64_t))(*(void *)v1 + 8LL))(v1);
    }

    *(void *)(a1 + 2344) = 0LL;
  }

void sub_1006004B4(uint64_t a1)
{
  uint64_t v1 = *(void *)(a1 + 32);
  uint64_t v2 = sub_1002E9074();
  (*(void (**)(uint64_t, void, void, void, void, double))(*(void *)v2 + 64LL))( v2,  *(void *)(v1 + 2296),  *(void *)(v1 + 2304),  *(void *)(v1 + 2312),  *(void *)(v1 + 2320),  *(double *)(v1 + 2328));
  uint64_t v3 = (os_log_s *)qword_1008F76D8;
  if (os_log_type_enabled((os_log_t)qword_1008F76D8, OS_LOG_TYPE_DEFAULT))
  {
    uint64_t v4 = *(void *)(v1 + 2296);
    uint64_t v5 = *(void *)(v1 + 2304);
    uint64_t v6 = *(void *)(v1 + 2312);
    uint64_t v7 = *(void *)(v1 + 2320);
    uint64_t v8 = *(void *)(v1 + 2328);
    int v9 = 134219008;
    uint64_t v10 = v4;
    __int16 v11 = 2048;
    uint64_t v12 = v5;
    __int16 v13 = 2048;
    uint64_t v14 = v6;
    __int16 v15 = 2048;
    uint64_t v16 = v7;
    __int16 v17 = 2048;
    uint64_t v18 = v8;
    _os_log_impl( (void *)&_mh_execute_header,  v3,  OS_LOG_TYPE_DEFAULT,  "reportExposureNotificationStats numOfScans:%llu duration:%llu numOfENReports:%llu numOfOtherReports:%llu lastENScanTS:%f",  (uint8_t *)&v9,  0x34u);
  }

void sub_1006005B0(uint64_t a1)
{
  if (*(void *)(a1 + 2344))
  {
    if (qword_1008D9700 != -1) {
      dispatch_once(&qword_1008D9700, &stru_1008A40D8);
    }
    uint64_t v2 = sub_1003ACB48((uint64_t)off_1008D96F8);
    uint64_t v3 = (os_log_s *)qword_1008F76D8;
    if (os_log_type_enabled((os_log_t)qword_1008F76D8, OS_LOG_TYPE_DEFAULT))
    {
      *(_DWORD *)std::stringbuf::string_type buf = 134217984;
      v12[0] = v2;
      _os_log_impl( (void *)&_mh_execute_header,  v3,  OS_LOG_TYPE_DEFAULT,  "armContactTracingScanWithDuplicatesDurationTimer Timer %llu ms Armed!",  buf,  0xCu);
    }

    uint64_t v4 = sub_100404FE8();
    uint64_t v5 = dispatch_source_create( (dispatch_source_type_t)&_dispatch_source_type_timer,  0LL,  0LL,  *(dispatch_queue_t *)(v4 + 8));
    *(void *)(a1 + 2264) = v5;
    handler[0] = _NSConcreteStackBlock;
    handler[1] = 3221225472LL;
    handler[2] = sub_100600794;
    handler[3] = &unk_10087EB20;
    handler[4] = a1;
    dispatch_source_set_event_handler(v5, handler);
    uint64_t v6 = *(dispatch_source_s **)(a1 + 2264);
    dispatch_time_t v7 = dispatch_time(0x8000000000000000LL, 1000000 * v2);
    dispatch_source_set_timer(v6, v7, 0xFFFFFFFFFFFFFFFFLL, 0LL);
    dispatch_activate(*(dispatch_object_t *)(a1 + 2264));
    ++*(_BYTE *)(a1 + 2288);
  }

  else
  {
    uint64_t v8 = (os_log_s *)qword_1008F76D8;
    if (os_log_type_enabled((os_log_t)qword_1008F76D8, OS_LOG_TYPE_INFO))
    {
      int v9 = *(unsigned __int8 *)(a1 + 2288);
      *(_DWORD *)std::stringbuf::string_type buf = 67109376;
      LODWORD(v12[0]) = v9;
      WORD2(v12[0]) = 1024;
      *(_DWORD *)((char *)v12 + 6) = 0;
      _os_log_impl( (void *)&_mh_execute_header,  v8,  OS_LOG_TYPE_INFO,  "fContactTracingScanDupClearDeltaTimer fContactTracingScanDupfilterClearCounter=%d isPowerAssertForContactTracingScanCreated=%d",  buf,  0xEu);
    }
  }

uint64_t sub_100600794(uint64_t a1)
{
  uint64_t v1 = *(void *)(a1 + 32);
  uint64_t v2 = (os_log_s *)qword_1008F76D8;
  if (os_log_type_enabled((os_log_t)qword_1008F76D8, OS_LOG_TYPE_DEFAULT))
  {
    *(_WORD *)uint64_t v4 = 0;
    _os_log_impl( (void *)&_mh_execute_header,  v2,  OS_LOG_TYPE_DEFAULT,  "fContactTracingScanWithDuplicatesDurationTimer Timer expired!",  v4,  2u);
  }

  dispatch_source_cancel(*(dispatch_source_t *)(v1 + 2264));
  dispatch_release(*(dispatch_object_t *)(v1 + 2264));
  *(void *)(v1 + 2264) = 0LL;
  *(_BYTE *)(v1 + 2352) = 0;
  sub_100600834(v1);
  sub_100600994(v1, 0);
  return sub_1005E3C94(v1, 1);
}

void sub_100600834(uint64_t a1)
{
  uint64_t v1 = *(void **)(a1 + 2040);
  uint64_t v2 = (void *)(a1 + 2048);
  if (v1 != (void *)(a1 + 2048))
  {
    do
    {
      uint64_t v3 = v1[5];
      if (*(_BYTE *)(*(void *)(v3 + 8) + 143LL))
      {
        uint64_t v4 = (os_log_s *)qword_1008F76D8;
        if (os_log_type_enabled((os_log_t)qword_1008F76D8, OS_LOG_TYPE_DEFAULT))
        {
          sub_100494958(v1[4], (uint64_t)__p);
          uint64_t v5 = v12 >= 0 ? __p : (void **)__p[0];
          *(_DWORD *)std::stringbuf::string_type buf = 136446210;
          uint64_t v14 = v5;
          _os_log_impl( (void *)&_mh_execute_header,  v4,  OS_LOG_TYPE_DEFAULT,  "Clearing scan agent sw dup filter map for session %{public}s",  buf,  0xCu);
          if (v12 < 0) {
            operator delete(__p[0]);
          }
        }

        dispatch_time_t v7 = *(void **)(v3 + 112);
        uint64_t v6 = (void *)(v3 + 112);
        sub_10061068C((uint64_t)(v6 - 1), v7);
        *(v6 - 1) = v6;
        *uint64_t v6 = 0LL;
        v6[1] = 0LL;
      }

      uint64_t v8 = (void *)v1[1];
      if (v8)
      {
        do
        {
          int v9 = v8;
          uint64_t v8 = (void *)*v8;
        }

        while (v8);
      }

      else
      {
        do
        {
          int v9 = (void *)v1[2];
          BOOL v10 = *v9 == (void)v1;
          uint64_t v1 = v9;
        }

        while (!v10);
      }

      uint64_t v1 = v9;
    }

    while (v9 != v2);
  }

void sub_100600994(uint64_t a1, int a2)
{
  uint64_t v2 = *(void **)(a1 + 2040);
  uint64_t v3 = (void *)(a1 + 2048);
  if (v2 != (void *)(a1 + 2048))
  {
    do
    {
      uint64_t v5 = v2[5];
      uint64_t v6 = *(_BYTE **)(v5 + 8);
      if (v6[143])
      {
        dispatch_time_t v7 = (os_log_s *)qword_1008F76D8;
        if (os_log_type_enabled((os_log_t)qword_1008F76D8, OS_LOG_TYPE_DEFAULT))
        {
          sub_100494958(v2[4], (uint64_t)__p);
          uint64_t v8 = __p;
          if (v13 < 0) {
            uint64_t v8 = (void **)__p[0];
          }
          *(_DWORD *)std::stringbuf::string_type buf = 136446466;
          __int16 v15 = v8;
          __int16 v16 = 1024;
          int v17 = a2;
          _os_log_impl( (void *)&_mh_execute_header,  v7,  OS_LOG_TYPE_DEFAULT,  "Setting scan agent for session:%{public}s allowdups:%d",  buf,  0x12u);
          if (v13 < 0) {
            operator delete(__p[0]);
          }
          uint64_t v6 = *(_BYTE **)(v5 + 8);
        }

        *uint64_t v6 = a2;
      }

      int v9 = (void *)v2[1];
      if (v9)
      {
        do
        {
          BOOL v10 = v9;
          int v9 = (void *)*v9;
        }

        while (v9);
      }

      else
      {
        do
        {
          BOOL v10 = (void *)v2[2];
          BOOL v11 = *v10 == (void)v2;
          uint64_t v2 = v10;
        }

        while (!v11);
      }

      uint64_t v2 = v10;
    }

    while (v10 != v3);
  }

double sub_100600B00(uint64_t a1)
{
  uint64_t v2 = *(void *)(a1 + 32);
  ++*(void *)(v2 + 2296);
  if (qword_1008D9700 != -1) {
    dispatch_once(&qword_1008D9700, &stru_1008A40D8);
  }
  double result = (double)*(unint64_t *)(v2 + 2304)
         + (double)(*(void *)(a1 + 40) / 0x3E8uLL)
         * (48.0
          / (double)sub_1003ACC60((uint64_t)off_1008D96F8));
  *(void *)(v2 + 2304) = (unint64_t)result;
  return result;
}

void sub_100600BA8(uint64_t a1)
{
  uint64_t v1 = *(void *)(a1 + 32);
  uint64_t v2 = (os_log_s *)qword_1008F76D8;
  if (os_log_type_enabled((os_log_t)qword_1008F76D8, OS_LOG_TYPE_DEFAULT))
  {
    LOWORD(v5[0]) = 0;
    _os_log_impl( (void *)&_mh_execute_header,  v2,  OS_LOG_TYPE_DEFAULT,  "fContactTracingScanDurationTimer Timer expired!",  (uint8_t *)v5,  2u);
  }

  dispatch_source_cancel(*(dispatch_source_t *)(v1 + 2256));
  dispatch_release(*(dispatch_object_t *)(v1 + 2256));
  *(void *)(v1 + 2256) = 0LL;
  *(_BYTE *)(v1 + 1840) = 1;
  *(_BYTE *)(v1 + 2352) = 1;
  sub_1005E3C94(v1, 1);
  if (qword_1008D9700 != -1) {
    dispatch_once(&qword_1008D9700, &stru_1008A40D8);
  }
  sub_1003AC150((uint64_t)off_1008D96F8);
  uint64_t v3 = sub_100404FE8();
  v5[0] = _NSConcreteStackBlock;
  v5[1] = 3221225472LL;
  void v5[2] = sub_1006004B4;
  v5[3] = &unk_10087EB20;
  v5[4] = v1;
  sub_100405384(v3, v5);
  sub_1005EA3D8(v1);
  CFAbsoluteTime Current = CFAbsoluteTimeGetCurrent();
  *(CFAbsoluteTime *)(v1 + 232_Block_object_dispose(va, 8) = Current;
  *(CFAbsoluteTime *)(v1 + 2280) = Current;
  sub_1006003D8(v1);
}

void sub_100600CC8(uint64_t a1)
{
  uint64_t v1 = *(void *)(a1 + 32);
  uint64_t v2 = (os_log_s *)qword_1008F76D8;
  if (os_log_type_enabled((os_log_t)qword_1008F76D8, OS_LOG_TYPE_DEFAULT))
  {
    *(_WORD *)uint64_t v23 = 0;
    _os_log_impl( (void *)&_mh_execute_header,  v2,  OS_LOG_TYPE_DEFAULT,  "fContactTracingScanDeltaTimer Timer expired!",  v23,  2u);
  }

  uint64_t v3 = *(dispatch_source_s **)(v1 + 2272);
  if (v3)
  {
    dispatch_source_cancel(v3);
    dispatch_release(*(dispatch_object_t *)(v1 + 2272));
    *(void *)(v1 + 2272) = 0LL;
  }

  *(_BYTE *)(v1 + 1840) = 1;
  if (!*(_BYTE *)(v1 + 1255))
  {
    sub_1005F377C(v1);
    sub_100600994(v1, 1);
    sub_100600834(v1);
    sub_1005E3C94(v1, 1);
    return;
  }

  if (*(double *)(v1 + 2336) != 0.0)
  {
    CFAbsoluteTime Current = CFAbsoluteTimeGetCurrent();
    *(void *)(v1 + 2304) = (unint64_t)(Current
    *(CFAbsoluteTime *)(v1 + 2336) = Current;
  }

  if (sub_1005F396C(v1) && *(_BYTE *)(v1 + 1255))
  {
    uint64_t v5 = (os_log_s *)qword_1008F76D8;
    if (os_log_type_enabled((os_log_t)qword_1008F76D8, OS_LOG_TYPE_DEFAULT))
    {
      *(_DWORD *)uint64_t v23 = 138543362;
      *(void *)&_OWORD v23[4] = @"EN";
      _os_log_impl( (void *)&_mh_execute_header,  v5,  OS_LOG_TYPE_DEFAULT,  "ADVBUFF(%{public}@): Pausing ADV Buffers",  v23,  0xCu);
    }

    if (*(unsigned __int8 *)(v1 + 1260) != 255)
    {
      uint64_t v6 = (os_log_s *)qword_1008F76D8;
      if (!os_log_type_enabled((os_log_t)qword_1008F76D8, OS_LOG_TYPE_DEFAULT)) {
        goto LABEL_20;
      }
      *(_DWORD *)uint64_t v23 = 138543362;
      *(void *)&_OWORD v23[4] = @"EN";
      dispatch_time_t v7 = "Already reading ADVBUFF(%{public}@):";
      goto LABEL_19;
    }

    int v8 = sub_1005E9E20(v1, 2LL, 0);
    uint64_t v6 = (os_log_s *)qword_1008F76D8;
    BOOL v9 = os_log_type_enabled((os_log_t)qword_1008F76D8, OS_LOG_TYPE_DEFAULT);
    if (!v8)
    {
      if (v9)
      {
        int v11 = *(unsigned __int8 *)(v1 + 1260);
        *(_DWORD *)uint64_t v23 = 138543618;
        *(void *)&_OWORD v23[4] = @"EN";
        *(_WORD *)&v23[12] = 1024;
        *(_DWORD *)&v23[14] = v11;
        _os_log_impl( (void *)&_mh_execute_header,  v6,  OS_LOG_TYPE_DEFAULT,  "ADVBUFF(%{public}@): Trying to read, current expectedEntries=%d",  v23,  0x12u);
      }

      int v12 = sub_1005EC18C(v1, 2LL);
      char v13 = (os_log_s *)qword_1008F76D8;
      if (os_log_type_enabled((os_log_t)qword_1008F76D8, OS_LOG_TYPE_DEFAULT))
      {
        int v14 = *(unsigned __int8 *)(v1 + 1260);
        *(_DWORD *)uint64_t v23 = 138543874;
        *(void *)&_OWORD v23[4] = @"EN";
        *(_WORD *)&v23[12] = 1024;
        *(_DWORD *)&v23[14] = v12;
        *(_WORD *)&v23[18] = 1024;
        *(_DWORD *)&v23[20] = v14;
        _os_log_impl( (void *)&_mh_execute_header,  v13,  OS_LOG_TYPE_DEFAULT,  "ADVBUFF(%{public}@): ReadADVBuffer returned %d, expectedEntries:%d",  v23,  0x18u);
      }

      if (v12)
      {
        __int16 v15 = (os_log_s *)qword_1008F75B8;
        if (os_log_type_enabled((os_log_t)qword_1008F75B8, OS_LOG_TYPE_FAULT)) {
          sub_10069DD0C(v15, v16, v17, v18, v19, v20, v21, v22);
        }
      }

      if (*(unsigned __int8 *)(v1 + 1260) == 255)
      {
        sub_1005E9E20(v1, 2LL, 1);
        if (os_log_type_enabled((os_log_t)qword_1008F76D8, OS_LOG_TYPE_DEBUG)) {
          sub_10069DCAC();
        }
        sub_1005EA3D8(v1);
      }

      goto LABEL_20;
    }

    if (v9)
    {
      *(_DWORD *)uint64_t v23 = 138543362;
      *(void *)&_OWORD v23[4] = @"EN";
      dispatch_time_t v7 = "ADVBUFF(%{public}@): could not disable ADV buffering";
LABEL_19:
      _os_log_impl((void *)&_mh_execute_header, v6, OS_LOG_TYPE_DEFAULT, v7, v23, 0xCu);
    }
  }

uint64_t sub_10060108C(uint64_t result, uint64_t a2, uint64_t a3, uint64_t a4)
{
  *(_WORD *)(a2 + _Block_object_dispose(va, 8) = a3;
  *(_WORD *)(a2 + 12) = WORD1(a3);
  *(_WORD *)(a2 + 10) = WORD2(a3);
  *(_BYTE *)(a2 + 14) = BYTE6(a3) & 1;
  if (*(_BYTE *)(result + 2244))
  {
    uint64_t v6 = sub_1002E6BF0();
    double result = (*(uint64_t (**)(uint64_t))(*(void *)v6 + 672LL))(v6);
    if ((_DWORD)result)
    {
      *(_BYTE *)(a2 + 1_Block_object_dispose(va, 8) = a4 & 1;
      *(_WORD *)(a2 + 20) = WORD1(a4);
      *(_WORD *)(a2 + 22) = WORD2(a4);
    }
  }

  return result;
}

uint64_t sub_1006010FC(uint64_t a1, uint64_t a2, int a3, uint64_t a4, unsigned __int8 *a5)
{
  uint64_t v9 = sub_1002E6BF0();
  uint64_t result = (*(uint64_t (**)(uint64_t))(*(void *)v9 + 888LL))(v9);
  switch(a3)
  {
    case 5:
      if ((_DWORD)result == 3)
      {
        unsigned int v15 = *((unsigned __int16 *)a5 + 1);
        if (a5[1])
        {
          if (*(unsigned __int16 *)(a2 + 2) < v15)
          {
            *(_WORD *)(a2 + 2) = v15;
            goto LABEL_20;
          }
        }

        else if (*(unsigned __int16 *)(a2 + 4) < v15)
        {
          *(_WORD *)(a2 + 4) = v15;
          *(_WORD *)(a2 + 2) = 0;
        }
      }

      break;
    case 3:
      if (!(*(unsigned __int16 *)(a2 + 4) | *(unsigned __int16 *)(a2 + 2)))
      {
        unint64_t v16 = 1374389535LL * (*(unsigned __int16 *)(a4 + 4) - *(unsigned __int16 *)(a4 + 6)) * *a5;
        *(_WORD *)(a2 + 4) = (v16 >> 37) + (v16 >> 63);
      }

      if ((_DWORD)result != 3) {
        goto LABEL_20;
      }
      break;
    case 2:
      unsigned int v11 = *(unsigned __int16 *)(a2 + 4);
      if (!*(_WORD *)(a2 + 4) && !*(_WORD *)(a2 + 2))
      {
        uint64_t v12 = 1374389535LL * (*(unsigned __int16 *)(a4 + 4) - *(unsigned __int16 *)(a4 + 6)) * *a5;
        unsigned __int16 v13 = (v12 >> 37) + ((unint64_t)v12 >> 63);
        unsigned int v11 = v13;
        *(_WORD *)(a2 + 4) = v13;
      }

      if ((_DWORD)result != 2 || v11 < 0x11)
      {
LABEL_20:
        *(_WORD *)(a2 + 4) = 0;
        return result;
      }

      *(_WORD *)(a2 + 4) = (unsigned __int16)((20976 * *a5) >> 16) >> 1;
      break;
  }

  return result;
}

void sub_100601254( uint64_t a1, unsigned __int8 *a2, char a3, int a4, unsigned int a5, unsigned int a6, uint64_t a7, int a8)
{
  unint64_t v16 = a2 + 6;
  unsigned int v17 = sub_100601690(a1, *((unsigned __int16 *)a2 + 2), *((unsigned __int16 *)a2 + 3));
  if (v17 == 7) {
    return;
  }
  unsigned int v18 = v17;
  if (a4 && (a3 & 1) == 0)
  {
    uint64_t v19 = (os_log_s *)qword_1008F75B8;
    if (os_log_type_enabled((os_log_t)qword_1008F75B8, OS_LOG_TYPE_ERROR)) {
      sub_10069DD7C(v19);
    }
    return;
  }

  uint64_t v20 = sub_1002E6BF0();
  uint64_t v21 = (*(uint64_t (**)(uint64_t))(*(void *)v20 + 888LL))(v20);
  unsigned int v22 = v21 - 2;
  int v41 = v21;
  if ((v21 - 2) < 2)
  {
    int v42 = v21 - 2;
    uint64_t v23 = *(void *)(a1 + ((unint64_t)v18 << 6) + 32LL * *a2 + 16LL * a5 + 8LL * a6 + 3784);
    uint64_t v44 = v23;
    if (*(_BYTE *)a7 || *(_WORD *)(a7 + 2))
    {
      v43[0] = *(_OWORD *)a2;
      *(_OWORD *)((char *)v43 + 10) = *(_OWORD *)(a2 + 10);
      sub_1006010FC(v21, (uint64_t)&v44, v18, (uint64_t)v43, (unsigned __int8 *)a7);
      uint64_t v23 = v44;
    }

    unsigned int v24 = *((unsigned __int16 *)a2 + 2);
    if (*((_WORD *)a2 + 2)) {
      unsigned int v25 = 100 * (WORD1(v23) + WORD2(v23)) / v24;
    }
    else {
      unsigned int v25 = 0;
    }
    if (v18 == 6)
    {
      BOOL v31 = (v23 & 0xFFFFFFFFFFFFLL) == 0x2000000020LL;
    }

    else
    {
      if (v18 != 5)
      {
        BOOL v39 = 0;
        goto LABEL_24;
      }

      BOOL v31 = v25 < 0x32;
    }

    BOOL v39 = v31;
LABEL_24:
    if ((_WORD)v23) {
      int v32 = 100;
    }
    else {
      int v32 = 50;
    }
    if ((v23 & 0xFFFFFFFF0000LL) == 0) {
      int v32 = 0;
    }
    unsigned int v40 = v32;
    uint64_t v33 = (os_log_s *)qword_1008F75B8;
    if (os_log_type_enabled((os_log_t)qword_1008F75B8, OS_LOG_TYPE_DEBUG))
    {
      int v34 = *((unsigned __int16 *)a2 + 3);
      int v35 = *a2;
      uint64_t v36 = "N";
      *(_DWORD *)std::stringbuf::string_type buf = 67112194;
      int v46 = v34;
      __int16 v47 = 1024;
      if (v39) {
        uint64_t v36 = "Y";
      }
      int v48 = v24;
      __int16 v49 = 1024;
      unsigned int v50 = v18;
      __int16 v51 = 1024;
      int v52 = v35;
      __int16 v53 = 1024;
      unsigned int v54 = a5;
      __int16 v55 = 1024;
      unsigned int v56 = a6;
      __int16 v57 = 1024;
      int v58 = (unsigned __int16)v23;
      __int16 v59 = 1024;
      int v60 = WORD1(v23);
      __int16 v61 = 1024;
      int v62 = WORD2(v23);
      __int16 v63 = 1024;
      int v64 = BYTE6(v23);
      __int16 v65 = 2082;
      uint64_t v66 = v36;
      __int16 v67 = 1024;
      unsigned int v68 = v40;
      __int16 v69 = 1024;
      int v70 = 1;
      _os_log_debug_impl( (void *)&_mh_execute_header,  v33,  OS_LOG_TYPE_DEBUG,  "scanParamsScanCoreTable: input [window %d interval %d type %d passive %d critical %d range %d] output [MCELNAByp ass %d SCELNAOn %d SCELNABypass %d concurrent %d] compensation [%{public}s, %d, query %d]",  buf,  0x54u);
    }

    unint64_t v29 = (unint64_t)v40 << 16;
    int v28 = &_mh_execute_header;
    BOOL v30 = v39;
LABEL_31:
    unsigned int v22 = v42;
    goto LABEL_32;
  }

  if ((_DWORD)v21 == 1)
  {
    int v42 = -1;
    uint64_t v26 = *a2;
    uint64_t v23 = *(void *)(a1 + ((unint64_t)v18 << 6) + 32 * v26 + 16LL * a5 + 8LL * a6 + 3272);
    unsigned int v27 = (os_log_s *)qword_1008F75B8;
    if (os_log_type_enabled((os_log_t)qword_1008F75B8, OS_LOG_TYPE_DEBUG))
    {
      int v37 = *((unsigned __int16 *)a2 + 3);
      int v38 = *((unsigned __int16 *)a2 + 2);
      *(_DWORD *)std::stringbuf::string_type buf = 67111424;
      int v46 = v37;
      __int16 v47 = 1024;
      int v48 = v38;
      __int16 v49 = 1024;
      unsigned int v50 = v18;
      __int16 v51 = 1024;
      int v52 = v26;
      __int16 v53 = 1024;
      unsigned int v54 = a5;
      __int16 v55 = 1024;
      unsigned int v56 = a6;
      __int16 v57 = 1024;
      int v58 = (unsigned __int16)v23;
      __int16 v59 = 1024;
      int v60 = WORD1(v23);
      __int16 v61 = 1024;
      int v62 = WORD2(v23);
      __int16 v63 = 1024;
      int v64 = BYTE6(v23);
      _os_log_debug_impl( (void *)&_mh_execute_header,  v27,  OS_LOG_TYPE_DEBUG,  "scanParamsMainCoreELNABypassTable: input [window %d interval %d type %d passive %d critical %d range %d] output [MCELNABypass %d SCELNAOn %d SCELNABypass %d concurrent %d]",  buf,  0x3Eu);
    }

    int v28 = 0LL;
    unint64_t v29 = 0LL;
    BOOL v30 = 0LL;
    goto LABEL_31;
  }

  uint64_t v23 = 0LL;
  int v28 = 0LL;
  unint64_t v29 = 0LL;
  BOOL v30 = 0LL;
LABEL_32:
  sub_10060108C(a1, (uint64_t)a2, v23, v29 | (unint64_t)v28 | v30);
  if (a8 && v18 == 5)
  {
    if (v22 < 2)
    {
      unint64_t v16 = a2 + 10;
    }

    else if (v41)
    {
      if (v41 != 1) {
        return;
      }
      unint64_t v16 = a2 + 8;
    }

    *v16 += a8;
  }

uint64_t sub_100601690(uint64_t a1, int a2, int a3)
{
  if (a2 == 48 && a3 == 48) {
    return 0LL;
  }
  if (a2 == 64 && a3 == 48) {
    return 1LL;
  }
  if (a2 == 96 && a3 == 48) {
    return 2LL;
  }
  if (a2 == 144 && a3 == 48) {
    return 3LL;
  }
  if (a2 == 480 && a3 == 48) {
    return 4LL;
  }
  if (a3 == 48 && (a2 & 0xFFFE) == 0x608) {
    return 5LL;
  }
  if (a3) {
    BOOL v4 = 0;
  }
  else {
    BOOL v4 = a2 == 4800;
  }
  if (v4) {
    return 6LL;
  }
  else {
    return 7LL;
  }
}

uint64_t sub_10060173C(uint64_t a1, int a2)
{
  uint64_t result = 1LL;
  if (((a2 - 131078) > 9 || ((1 << (a2 - 6)) & 0x203) == 0) && a2 != 22)
  {
    if (a2 == 265)
    {
      uint64_t v5 = sub_1002E6BF0();
      uint64_t v6 = sub_1002E6BF0();
      uint64_t v7 = sub_1002E6BF0();
      if (((*(uint64_t (**)(uint64_t))(*(void *)v7 + 424LL))(v7) & 1) != 0)
      {
        return 1LL;
      }

      else
      {
        uint64_t v8 = sub_1002E6BF0();
        return (*(uint64_t (**)(uint64_t))(*(void *)v8 + 944LL))(v8);
      }
    }

    else
    {
      return 0LL;
    }
  }

  return result;
}

uint64_t sub_1006017DC(uint64_t a1, int a2)
{
  if (a2 == 22)
  {
    uint64_t v6 = 50LL;
LABEL_8:
    uint64_t v7 = *(uint64_t (**)(void))(*(void *)sub_1002E6BF0() + 8 * v6);
    return v7();
  }

  if (a2 == 265)
  {
    uint64_t v2 = sub_1002E6BF0();
    uint64_t v3 = sub_1002E6BF0();
    uint64_t v4 = sub_1002E6BF0();
    uint64_t v6 = 118LL;
    goto LABEL_8;
  }

  return 0LL;
}

uint64_t sub_100601870(uint64_t a1, uint64_t a2)
{
  if (!a2 || !*(void *)(a2 + 8)) {
    return 0LL;
  }
  if (sub_100611378(a2) == 22)
  {
    uint64_t v3 = (os_log_s *)qword_1008F75B8;
    if (os_log_type_enabled((os_log_t)qword_1008F75B8, OS_LOG_TYPE_DEFAULT))
    {
      int v4 = sub_100611378(a2);
      *(_DWORD *)std::stringbuf::string_type buf = 136315138;
      unsigned int v22 = sub_1005E2B18(v4);
      _os_log_impl( (void *)&_mh_execute_header,  v3,  OS_LOG_TYPE_DEFAULT,  "ScanCore offloading is allowed while throttling due to SDP for %s",  buf,  0xCu);
    }

    return 1LL;
  }

  else
  {
    id v6 = sub_100611384(a2);
    uint64_t v7 = (void *)objc_claimAutoreleasedReturnValue(v6);
    uint64_t v8 = v7;
    if (v7 && [v7 count])
    {
      __int128 v18 = 0u;
      __int128 v19 = 0u;
      __int128 v16 = 0u;
      __int128 v17 = 0u;
      id v9 = v8;
      uint64_t v5 = (uint64_t)[v9 countByEnumeratingWithState:&v16 objects:v20 count:16];
      if (v5)
      {
        uint64_t v10 = *(void *)v17;
        while (2)
        {
          for (uint64_t i = 0LL; i != v5; ++i)
          {
            if (*(void *)v17 != v10) {
              objc_enumerationMutation(v9);
            }
            uint64_t v12 = *(void **)(*((void *)&v16 + 1) + 8 * i);
            if (objc_msgSend(v12, "longLongValue", (void)v16) == 22)
            {
              unsigned __int16 v13 = (os_log_s *)qword_1008F75B8;
              if (os_log_type_enabled((os_log_t)qword_1008F75B8, OS_LOG_TYPE_DEFAULT))
              {
                int v14 = sub_1005E2B18((int)[v12 longLongValue]);
                *(_DWORD *)std::stringbuf::string_type buf = 136315138;
                unsigned int v22 = v14;
                _os_log_impl( (void *)&_mh_execute_header,  v13,  OS_LOG_TYPE_DEFAULT,  "ScanCore offloading is allowed while throttling due to SDP for %s",  buf,  0xCu);
              }

              uint64_t v5 = 1LL;
              goto LABEL_23;
            }
          }

          uint64_t v5 = (uint64_t)[v9 countByEnumeratingWithState:&v16 objects:v20 count:16];
          if (v5) {
            continue;
          }
          break;
        }
      }

void sub_100601A8C(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

uint64_t sub_100601ABC(uint64_t a1, uint64_t a2)
{
  if (!a2 || !*(void *)(a2 + 8)) {
    return 0LL;
  }
  int v3 = sub_100611378(a2);
  if (v3 == 2147418120 || v3 == 131101)
  {
    int v4 = (os_log_s *)qword_1008F75B8;
    if (os_log_type_enabled((os_log_t)qword_1008F75B8, OS_LOG_TYPE_DEFAULT))
    {
      int v5 = sub_100611378(a2);
      *(_DWORD *)std::stringbuf::string_type buf = 136315138;
      uint64_t v26 = sub_1005E2B18(v5);
      _os_log_impl( (void *)&_mh_execute_header,  v4,  OS_LOG_TYPE_DEFAULT,  "Wall power scan boost for %s is allowed",  buf,  0xCu);
    }

    return 1LL;
  }

  else
  {
    id v8 = sub_100611384(a2);
    id v9 = (void *)objc_claimAutoreleasedReturnValue(v8);
    uint64_t v10 = v9;
    if (v9 && [v9 count])
    {
      __int128 v22 = 0u;
      __int128 v23 = 0u;
      __int128 v20 = 0u;
      __int128 v21 = 0u;
      id v11 = v10;
      id v12 = [v11 countByEnumeratingWithState:&v20 objects:v24 count:16];
      if (v12)
      {
        uint64_t v13 = *(void *)v21;
        while (2)
        {
          for (uint64_t i = 0LL; i != v12; uint64_t i = (char *)i + 1)
          {
            if (*(void *)v21 != v13) {
              objc_enumerationMutation(v11);
            }
            unsigned int v15 = *(void **)(*((void *)&v20 + 1) + 8LL * (void)i);
            unsigned int v16 = objc_msgSend(v15, "longLongValue", (void)v20);
            if (v16 == 2147418120 || v16 == 131101)
            {
              __int128 v18 = (os_log_s *)qword_1008F75B8;
              if (os_log_type_enabled((os_log_t)qword_1008F75B8, OS_LOG_TYPE_DEFAULT))
              {
                __int128 v19 = sub_1005E2B18((int)[v15 longLongValue]);
                *(_DWORD *)std::stringbuf::string_type buf = 136315138;
                uint64_t v26 = v19;
                _os_log_impl( (void *)&_mh_execute_header,  v18,  OS_LOG_TYPE_DEFAULT,  "Wall power scan boost for %s is allowed",  buf,  0xCu);
              }

              uint64_t v6 = 1LL;
              goto LABEL_29;
            }
          }

          id v12 = [v11 countByEnumeratingWithState:&v20 objects:v24 count:16];
          uint64_t v6 = 0LL;
          if (v12) {
            continue;
          }
          break;
        }
      }

      else
      {
        uint64_t v6 = 0LL;
      }

void sub_100601D18(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

uint64_t sub_100601D48(uint64_t a1, uint64_t a2)
{
  if (a2 && *(void *)(a2 + 8))
  {
    int v3 = sub_100611378(a2);
    if (v3 == 2147418120 || v3 == 131101) {
      unsigned int v5 = 32;
    }
    else {
      unsigned int v5 = 0;
    }
    if (v3 == 2147418120 || v3 == 131101)
    {
      uint64_t v6 = (os_log_s *)qword_1008F75B8;
      if (os_log_type_enabled((os_log_t)qword_1008F75B8, OS_LOG_TYPE_DEFAULT))
      {
        int v7 = sub_100611378(a2);
        *(_DWORD *)std::stringbuf::string_type buf = 134218242;
        double v29 = (double)v5 * 0.625;
        __int16 v30 = 2080;
        BOOL v31 = sub_1005E2B18(v7);
        _os_log_impl( (void *)&_mh_execute_header,  v6,  OS_LOG_TYPE_DEFAULT,  "Scan boost incremental window %.2f msec for %s",  buf,  0x16u);
      }
    }

    id v8 = sub_100611384(a2);
    id v9 = (void *)objc_claimAutoreleasedReturnValue(v8);
    uint64_t v10 = v9;
    if (v9 && [v9 count])
    {
      __int128 v25 = 0u;
      __int128 v26 = 0u;
      __int128 v23 = 0u;
      __int128 v24 = 0u;
      id v11 = v10;
      id v12 = [v11 countByEnumeratingWithState:&v23 objects:v27 count:16];
      __int128 v22 = v10;
      if (v12)
      {
        uint64_t v13 = *(void *)v24;
        do
        {
          for (uint64_t i = 0LL; i != v12; uint64_t i = (char *)i + 1)
          {
            if (*(void *)v24 != v13) {
              objc_enumerationMutation(v11);
            }
            unsigned int v15 = *(void **)(*((void *)&v23 + 1) + 8LL * (void)i);
            unsigned int v16 = [v15 longLongValue];
            if (v16 == 2147418120 || v16 == 131101) {
              unsigned int v18 = 32;
            }
            else {
              unsigned int v18 = 0;
            }
            if (v18 > (unsigned __int16)v5)
            {
              __int128 v19 = (os_log_s *)qword_1008F75B8;
              if (os_log_type_enabled((os_log_t)qword_1008F75B8, OS_LOG_TYPE_DEFAULT))
              {
                __int128 v20 = sub_1005E2B18((int)[v15 longLongValue]);
                *(_DWORD *)std::stringbuf::string_type buf = 134218242;
                double v29 = (double)v18 * 0.625;
                __int16 v30 = 2080;
                BOOL v31 = v20;
                _os_log_impl( (void *)&_mh_execute_header,  v19,  OS_LOG_TYPE_DEFAULT,  "Scan boost incremental window %.2f msec for %s",  buf,  0x16u);
              }

              LOWORD(v5) = 32;
            }
          }

          id v12 = [v11 countByEnumeratingWithState:&v23 objects:v27 count:16];
        }

        while (v12);
      }

      uint64_t v10 = v22;
    }
  }

  else
  {
    LOWORD(v5) = 0;
  }

  return (unsigned __int16)v5;
}

void sub_100601FDC(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

uint64_t sub_100602018(uint64_t a1, unsigned __int8 *a2)
{
  BOOL v288 = (sub_1005EE698(a1) & 1) != 0 || sub_1005F396C(a1);
  uint64_t v316 = a1;
  BOOL v292 = sub_1005F396C(a1);
  uint64_t v3 = sub_1002E6BF0();
  unsigned int v286 = (*(uint64_t (**)(uint64_t))(*(void *)v3 + 616LL))(v3);
  uint64_t v4 = sub_1002E6BF0();
  unsigned int v285 = (*(uint64_t (**)(uint64_t))(*(void *)v4 + 648LL))(v4);
  uint64_t v5 = sub_1002E6BF0();
  unsigned int v295 = (*(uint64_t (**)(uint64_t))(*(void *)v5 + 824LL))(v5);
  uint64_t v6 = sub_1002E6E9C();
  int v289 = (*(uint64_t (**)(uint64_t))(*(void *)v6 + 2656LL))(v6);
  __int128 v311 = (void *)objc_claimAutoreleasedReturnValue(+[NSMutableDictionary dictionary](&OBJC_CLASS___NSMutableDictionary, "dictionary"));
  *(_WORD *)a2 = 0;
  a2[2] = 0;
  *((_DWORD *)a2 + 2) = 0;
  *((_WORD *)a2 + 6) = 0;
  *(_DWORD *)(a2 + 14) = 256;
  a2[18] = 0;
  *((_DWORD *)a2 + 5) = 0;
  unsigned int v282 = (unsigned __int16 *)(a2 + 20);
  *((_WORD *)a2 + 12) = 0;
  if (qword_1008D6198 != -1) {
    dispatch_once(&qword_1008D6198, &stru_1008A4058);
  }
  uint64_t v7 = a1;
  uint64_t v8 = sub_10044C108((uint64_t)off_1008D6190, 0LL, 1u);
  if (v8)
  {
    id v9 = (os_log_s *)qword_1008F75B8;
    if (os_log_type_enabled((os_log_t)qword_1008F75B8, OS_LOG_TYPE_DEFAULT))
    {
      *(_DWORD *)std::stringbuf::string_type buf = 134217984;
      *(void *)&uint8_t buf[4] = v8;
      _os_log_impl((void *)&_mh_execute_header, v9, OS_LOG_TYPE_DEFAULT, "coexStateBitmap:0x%llX", buf, 0xCu);
    }
  }

  int v322 = 0;
  uint64_t v10 = sub_1002E8D54();
  else {
    BOOL v11 = v322 == 0;
  }
  int v12 = !v11;
  int v279 = v12;
  __int128 v312 = (void *)objc_claimAutoreleasedReturnValue(+[NSMutableArray array](&OBJC_CLASS___NSMutableArray, "array"));
  uint64_t v13 = *(void **)(v316 + 2040);
  int v14 = &AMFDRSealingMapCopyLocalDictForClass_ptr;
  if (v13 != (void *)(v316 + 2048))
  {
    BOOL v283 = 0;
    int v297 = 0;
    char v284 = 0;
    uint64_t v290 = 0LL;
    uint64_t v15 = 0LL;
    uint64_t v281 = 0LL;
    int v280 = 0;
    char v287 = 0;
    char v310 = 0;
    unsigned __int16 v306 = 0;
    char v296 = 0;
    int v313 = 0;
    char v307 = 0;
    int v293 = 0;
    unsigned int v294 = 3;
    uint64_t v291 = 4LL;
    double v16 = 0.0;
    double v17 = 0.0;
    uint64_t v304 = 3LL;
    char v303 = 1;
    while (1)
    {
      uint64_t v314 = v15;
      int v18 = *(_DWORD *)(*(void *)(v13[5] + 8LL) + 168LL);
      memset(&buf[16], 0, 88);
      *(_OWORD *)std::stringbuf::string_type buf = 0u;
      uint64_t v19 = *(void *)(v13[5] + 8LL);
      __int128 v20 = *(_OWORD *)(v19 + 296);
      *(_OWORD *)std::stringbuf::string_type buf = *(_OWORD *)(v19 + 280);
      *(_OWORD *)&uint8_t buf[16] = v20;
      *(_OWORD *)&buf[28] = *(_OWORD *)(v19 + 308);
      sub_10060E68C( &buf[48],  *(void *)(v19 + 328),  *(void *)(v19 + 336),  0xAAAAAAAAAAAAAAABLL * ((uint64_t)(*(void *)(v19 + 336) - *(void *)(v19 + 328)) >> 5));
      memset(&buf[72], 0, 24);
      sub_100050EE8( &buf[72],  *(__int128 **)(v19 + 352),  *(__int128 **)(v19 + 360),  0xCCCCCCCCCCCCCCCDLL * ((uint64_t)(*(void *)(v19 + 360) - *(void *)(v19 + 352)) >> 2));
      buf[96] = *(_BYTE *)(v19 + 376);
      __int128 v21 = (void *)objc_claimAutoreleasedReturnValue(+[NSMutableDictionary dictionary](&OBJC_CLASS___NSMutableDictionary, "dictionary"));
      __int128 v22 = (void *)objc_claimAutoreleasedReturnValue( +[NSNumber numberWithBool:]( &OBJC_CLASS___NSNumber,  "numberWithBool:",  *(unsigned __int8 *)(*(void *)(v13[5] + 8LL) + 3LL)));
      [v21 setObject:v22 forKeyedSubscript:@"isAllowedInScreenOff"];

      __int128 v23 = +[NSNumber numberWithBool:](&OBJC_CLASS___NSNumber, "numberWithBool:", sub_100610C38(v13[5]));
      __int128 v24 = (void *)objc_claimAutoreleasedReturnValue(v23);
      [v21 setObject:v24 forKeyedSubscript:@"allowDupes"];

      __int128 v25 = (void *)objc_claimAutoreleasedReturnValue(+[NSNumber numberWithUnsignedInt:](&OBJC_CLASS___NSNumber, "numberWithUnsignedInt:", 0LL));
      [v21 setObject:v25 forKeyedSubscript:@"window"];

      __int128 v26 = (void *)objc_claimAutoreleasedReturnValue(+[NSNumber numberWithUnsignedInt:](&OBJC_CLASS___NSNumber, "numberWithUnsignedInt:", 0LL));
      [v21 setObject:v26 forKeyedSubscript:@"interval"];

      unsigned int v27 = (void *)objc_claimAutoreleasedReturnValue(+[NSNumber numberWithBool:](&OBJC_CLASS___NSNumber, "numberWithBool:", 0LL));
      [v21 setObject:v27 forKeyedSubscript:@"active"];

      int v28 = +[NSNumber numberWithBool:](&OBJC_CLASS___NSNumber, "numberWithBool:", sub_100610DAC(v13[5]));
      double v29 = (void *)objc_claimAutoreleasedReturnValue(v28);
      [v21 setObject:v29 forKeyedSubscript:@"requiresActiveScan"];

      __int16 v30 = (void *)objc_claimAutoreleasedReturnValue( +[NSNumber numberWithBool:]( &OBJC_CLASS___NSNumber,  "numberWithBool:",  *(unsigned __int8 *)(v13[5] + 81LL) == 32));
      [v21 setObject:v30 forKeyedSubscript:@"daemon"];

      BOOL v31 = (void *)objc_claimAutoreleasedReturnValue( +[NSNumber numberWithBool:]( &OBJC_CLASS___NSNumber,  "numberWithBool:",  *(unsigned __int8 *)(v13[5] + 81LL) == 16));
      [v21 setObject:v31 forKeyedSubscript:@"ForegroundApp"];

      int v32 = +[NSNumber numberWithBool:](&OBJC_CLASS___NSNumber, "numberWithBool:", sub_100611304(v13[5]));
      uint64_t v33 = (void *)objc_claimAutoreleasedReturnValue(v32);
      [v21 setObject:v33 forKeyedSubscript:@"isAnyHWObjectDiscoveryEnabled"];

      int v34 = (void *)objc_claimAutoreleasedReturnValue(+[NSNumber numberWithDouble:](&OBJC_CLASS___NSNumber, "numberWithDouble:", v16));
      [v21 setObject:v34 forKeyedSubscript:@"HWADVBufferWindowMs"];

      int v35 = (void *)objc_claimAutoreleasedReturnValue(+[NSNumber numberWithDouble:](&OBJC_CLASS___NSNumber, "numberWithDouble:", v17));
      [v21 setObject:v35 forKeyedSubscript:@"HWADVBufferIntervalMs"];

      uint64_t v36 = +[NSNumber numberWithBool:](&OBJC_CLASS___NSNumber, "numberWithBool:", sub_100611360(v13[5]));
      int v37 = (void *)objc_claimAutoreleasedReturnValue(v36);
      [v21 setObject:v37 forKeyedSubscript:@"isRangeScan"];

      int v38 = +[NSNumber numberWithBool:](&OBJC_CLASS___NSNumber, "numberWithBool:", sub_10061136C(v13[5]));
      BOOL v39 = (void *)objc_claimAutoreleasedReturnValue(v38);
      [v21 setObject:v39 forKeyedSubscript:@"isPriorityCritical"];

      unsigned int v40 = (void *)objc_claimAutoreleasedReturnValue( +[NSNumber numberWithBool:]( &OBJC_CLASS___NSNumber,  "numberWithBool:",  *(unsigned __int8 *)(*(void *)(v13[5] + 8LL) + 142LL)));
      [v21 setObject:v40 forKeyedSubscript:@"holdPowerAssert"];

      int v41 = (void *)objc_claimAutoreleasedReturnValue( +[NSNumber numberWithBool:]( &OBJC_CLASS___NSNumber,  "numberWithBool:",  *(unsigned __int8 *)(*(void *)(v13[5] + 8LL) + 143LL)));
      [v21 setObject:v41 forKeyedSubscript:@"isContactTracing"];

      int v42 = (void *)objc_claimAutoreleasedReturnValue( +[NSNumber numberWithUnsignedInt:]( &OBJC_CLASS___NSNumber,  "numberWithUnsignedInt:",  *(unsigned int *)(v13[5] + 208LL)));
      [v21 setObject:v42 forKeyedSubscript:@"scanAgentType"];

      id v43 = (void *)objc_claimAutoreleasedReturnValue( +[NSNumber numberWithInt:]( &OBJC_CLASS___NSNumber,  "numberWithInt:",  *(unsigned int *)(v13[5] + 96LL)));
      [v21 setObject:v43 forKeyedSubscript:@"agentScanLevel"];

      id v44 = [v14[391] stringWithUTF8String:sub_1005E2B18(v18)];
      unsigned int v45 = (void *)objc_claimAutoreleasedReturnValue(v44);
      [v21 setObject:v45 forKeyedSubscript:@"usecase"];

      if (buf[8])
      {
        int v46 = v14[391];
        sub_1005E3244(buf, &v356);
        __int16 v47 = (v356.__r_.__value_.__s.__size_ & 0x80u) == 0
            ? &v356
            : (std::stringbuf::string_type *)v356.__r_.__value_.__r.__words[0];
        int v48 = (void *)objc_claimAutoreleasedReturnValue([v46 stringWithUTF8String:v47]);
        [v21 setObject:v48 forKeyedSubscript:@"usecaseParams"];
      }

      __int16 v49 = v14[391];
      sub_100494958(v13[4], (uint64_t)&v356);
      if ((v356.__r_.__value_.__s.__size_ & 0x80u) == 0) {
        unsigned int v50 = &v356;
      }
      else {
        unsigned int v50 = (std::stringbuf::string_type *)v356.__r_.__value_.__r.__words[0];
      }
      __int16 v51 = (void *)objc_claimAutoreleasedReturnValue([v49 stringWithUTF8String:v50]);
      [v311 setObject:v21 forKeyedSubscript:v51];

      if (!sub_100617C84(v13[5])) {
        goto LABEL_175;
      }
      ++v310;
      uint64_t v52 = v13[5];
      if (!*(_BYTE *)(*(void *)(v52 + 8) + 3LL) && *(_DWORD *)(v316 + 1964) == 2) {
        goto LABEL_175;
      }
      BOOL v53 = sub_100611304(v52);
      uint64_t v54 = v13[5];
      uint64_t v55 = *(void *)(v54 + 8);
      if (v53)
      {
        int v56 = *(unsigned __int8 *)(v55 + 120);
        if (*(_BYTE *)(v55 + 120))
        {
          unsigned int v58 = *(_DWORD *)(v55 + 128);
          unsigned int v57 = *(_DWORD *)(v55 + 132);
          uint64_t v59 = *(unsigned __int8 *)(v55 + 136);
        }

        else
        {
          uint64_t v59 = 0LL;
          unsigned int v57 = 0;
          unsigned int v58 = 0;
        }

        float v65 = v17;
        double v17 = v65;
        float v66 = v16;
        double v16 = v66;
        __int16 v67 = (os_log_s *)qword_1008F75B8;
        if (os_log_type_enabled((os_log_t)qword_1008F75B8, OS_LOG_TYPE_DEFAULT))
        {
          sub_100494958(v13[4], (uint64_t)v354);
          unsigned int v68 = v354;
          if (v355 < 0) {
            unsigned int v68 = *(_BYTE **)v354;
          }
          LODWORD(v356.__r_.__value_.__l.__data_) = 136447746;
          *(std::string::size_type *)((char *)v356.__r_.__value_.__r.__words + 4) = (std::string::size_type)v68;
          WORD2(v356.__r_.__value_.__r.__words[1]) = 2048;
          *(double *)((char *)&v356.__r_.__value_.__r.__words[1] + 6) = v17;
          HIWORD(v356.__r_.__value_.__r.__words[2]) = 2048;
          double v357 = v16;
          __int16 v358 = 1024;
          unsigned int v359 = v58;
          __int16 v360 = 1024;
          unsigned int v361 = v57;
          __int16 v362 = 1024;
          int v363 = v59;
          __int16 v364 = 1024;
          int v365 = v56;
          _os_log_impl( (void *)&_mh_execute_header,  v67,  OS_LOG_TYPE_DEFAULT,  "ObjectDiscovery Client (%{public}s) HWADVBufferIntervalMs:%f HWADVBufferWindowMs:%f _interval:%d _window:%d _active:%d specifiedParams:%d",  (uint8_t *)&v356,  0x38u);
          if (v355 < 0) {
            operator delete(*(void **)v354);
          }
          uint64_t v54 = v13[5];
          uint64_t v55 = *(void *)(v54 + 8);
        }

        uint64_t v69 = 0LL;
        uint64_t v70 = 0LL;
        BOOL v292 = 0;
        if (*(void *)(v55 + 16) != *(void *)(v55 + 8)) {
          v297 |= sub_100610C38(v54);
        }
        goto LABEL_121;
      }

      if (*(_BYTE *)(v55 + 143))
      {
        if (*(_BYTE *)(v316 + 1255))
        {
          float v60 = v17;
          if (v60 < 965.62) {
            float v60 = 965.62;
          }
          double v17 = v60;
          float v61 = v16;
          if (v61 < 30.0) {
            float v61 = 30.0;
          }
          double v16 = v61;
          int v62 = (os_log_s *)qword_1008F75B8;
          if (os_log_type_enabled((os_log_t)qword_1008F75B8, OS_LOG_TYPE_DEFAULT))
          {
            sub_100494958(v13[4], (uint64_t)v354);
            __int16 v63 = v354;
            if (v355 < 0) {
              __int16 v63 = *(_BYTE **)v354;
            }
            LODWORD(v356.__r_.__value_.__l.__data_) = 136446722;
            *(std::string::size_type *)((char *)v356.__r_.__value_.__r.__words + 4) = (std::string::size_type)v63;
            WORD2(v356.__r_.__value_.__r.__words[1]) = 2048;
            *(double *)((char *)&v356.__r_.__value_.__r.__words[1] + 6) = v17;
            HIWORD(v356.__r_.__value_.__r.__words[2]) = 2048;
            double v357 = v16;
            _os_log_impl( (void *)&_mh_execute_header,  v62,  OS_LOG_TYPE_DEFAULT,  "EN Client (%{public}s) HWADVBufferIntervalMs:%f HWADVBufferWindowMs:%f",  (uint8_t *)&v356,  0x20u);
            if (v355 < 0)
            {
              int v64 = *(void **)v354;
              goto LABEL_73;
            }
          }
        }

        else
        {
          int v74 = *(_DWORD *)(v54 + 96);
          else {
            uint64_t v75 = v291;
          }
          uint64_t v291 = v75;
          v297 |= sub_100610C38(v54);
          id v76 = (os_log_s *)qword_1008F76D8;
          if (os_log_type_enabled((os_log_t)qword_1008F76D8, OS_LOG_TYPE_DEFAULT))
          {
            sub_100494958(v13[4], (uint64_t)&v356);
            __int128 v77 = (v356.__r_.__value_.__s.__size_ & 0x80u) == 0
                ? &v356
                : (std::stringbuf::string_type *)v356.__r_.__value_.__r.__words[0];
            *(_DWORD *)v354 = 136446210;
            *(void *)&v354[4] = v77;
            _os_log_impl((void *)&_mh_execute_header, v76, OS_LOG_TYPE_DEFAULT, "EN Client (%{public}s) ", v354, 0xCu);
            if ((char)v356.__r_.__value_.__s.__size_ < 0)
            {
              int v64 = (void *)v356.__r_.__value_.__r.__words[0];
LABEL_73:
              operator delete(v64);
            }
          }
        }

        uint64_t v59 = 0LL;
        uint64_t v69 = 0LL;
        uint64_t v70 = 0LL;
        goto LABEL_121;
      }

      int v71 = *(_DWORD *)(v55 + 168);
      if (v71 == 265 || (int v72 = *(unsigned __int8 *)(v54 + 81), v72 == 32) || v72 == 16)
      {
        if ((sub_100610C38(v13[5]) & 1) != 0)
        {
          BOOL v73 = 1;
        }

        else
        {
          __int128 v78 = *(int8x8_t **)(v13[5] + 8LL);
          v354[0] = 1;
          v356.__r_.__value_.__s.__data_[0] = 0;
          BOOL v73 = sub_10060ECA8(v78 + 26, 0, (uint64_t)&v78[30], 0, v354) != 0;
        }

        uint64_t v79 = v13[5];
        __int128 v80 = *(void **)(v79 + 8);
        if (v80[2] != v80[1]
          || v80[8] == v80[9]
          || (uint64_t v93 = sub_1002E6BF0(),
              int v94 = (*(uint64_t (**)(uint64_t))(*(void *)v93 + 592LL))(v93),
              uint64_t v79 = v13[5],
              v71 == 265)
          || v94 != 1)
        {
          v297 |= sub_100610C38(v79);
        }

        else if (sub_100610C38(v79) && os_log_type_enabled((os_log_t)qword_1008F75B8, OS_LOG_TYPE_DEBUG))
        {
          sub_10069DE68(&v320, v321);
        }

        v284 |= v73;
        uint64_t v81 = v13[5];
        if (*(_BYTE *)(v81 + 81) == 32)
        {
          BOOL v82 = sub_100610CA8(v81);
          char v83 = v71 == 265 || v82;
          uint64_t v81 = v13[5];
          if ((v83 & 1) != 0)
          {
LABEL_88:
            uint64_t v55 = *(void *)(v81 + 8);
            uint64_t v86 = v316;
            if (*(_BYTE *)(v55 + 120))
            {
              uint64_t v70 = *(unsigned int *)(v55 + 128);
              uint64_t v69 = *(unsigned int *)(v55 + 132);
              uint64_t v59 = *(unsigned __int8 *)(v55 + 136);
              BOOL v283 = (v59 | v283) != 0;
              if (*(_BYTE *)(v55 + 136))
              {
                unsigned int v87 = (os_log_s *)qword_1008F75B8;
                uint64_t v81 = os_log_type_enabled((os_log_t)qword_1008F75B8, OS_LOG_TYPE_INFO);
                if ((_DWORD)v81)
                {
                  LODWORD(v356.__r_.__value_.__l.__data_) = 67109634;
                  HIDWORD(v356.__r_.__value_.__r.__words[0]) = v69;
                  LOWORD(v356.__r_.__value_.__r.__words[1]) = 1024;
                  *(_DWORD *)((char *)&v356.__r_.__value_.__r.__words[1] + 2) = v70;
                  HIWORD(v356.__r_.__value_.__r.__words[1]) = 2082;
                  v356.__r_.__value_.__l.__cap_ = (std::string::size_type)"active";
                  _os_log_impl( (void *)&_mh_execute_header,  v87,  OS_LOG_TYPE_INFO,  "Daemon is requesting scan parameters %d/%d (%{public}s)",  (uint8_t *)&v356,  0x18u);
                }
              }

              if (v279)
              {
                uint64_t v88 = sub_100601ABC(v81, v13[5]);
                uint64_t v86 = v316;
                if ((_DWORD)v88)
                {
                  int v89 = sub_100601690( v88,  (int)((double)v70 / 0.625),  (int)((double)v69 / 0.625));
                  if (v89 == 5) {
                    uint64_t v69 = 30LL;
                  }
                  else {
                    uint64_t v69 = v69;
                  }
                  if (v89 == 5) {
                    uint64_t v70 = 300LL;
                  }
                  else {
                    uint64_t v70 = v70;
                  }
                }
              }

              uint64_t v90 = v314;
              if (!(_DWORD)v314 || v70 / v69 < (int)v290 / (int)v314)
              {
                uint64_t v90 = v69;
                uint64_t v290 = v70;
              }

              uint64_t v314 = v90;
              uint64_t v55 = *(void *)(v13[5] + 8LL);
              if (*(_BYTE *)(v55 + 273))
              {
                BYTE4(v281) = 1;
                if ((_DWORD)v290)
                {
                  if ((_DWORD)v90)
                  {
                    if ((_DWORD)v281)
                    {
                      int v91 = v280;
                      int v92 = v281;
                      if ((int)v281 / v280 < (int)v290 / (int)v90)
                      {
                        int v91 = v90;
                        int v92 = v290;
                      }

                      int v280 = v91;
                      LODWORD(v281) = v92;
                      BYTE4(v281) = 1;
                    }

                    else
                    {
                      int v280 = v90;
                      LODWORD(v281) = v290;
                      BYTE4(v281) = 1;
                    }
                  }
                }
              }
            }

            else
            {
              uint64_t v59 = 0LL;
              uint64_t v69 = 0LL;
              uint64_t v70 = 0LL;
            }

            goto LABEL_119;
          }
        }

        else if (v71 == 265)
        {
          goto LABEL_88;
        }

        uint64_t v59 = 0LL;
        uint64_t v69 = 0LL;
        uint64_t v70 = 0LL;
        int v84 = *(_DWORD *)(v81 + 96);
        else {
          uint64_t v85 = v291;
        }
        uint64_t v291 = v85;
        uint64_t v55 = *(void *)(v81 + 8);
      }

      else
      {
        uint64_t v59 = 0LL;
        uint64_t v69 = 0LL;
        uint64_t v70 = 0LL;
      }

      uint64_t v86 = v316;
LABEL_119:
      BOOL v288 = 0;
      BOOL v292 = 0;
      if (*(_BYTE *)(v55 + 3)) {
        v287 |= *(_DWORD *)(v86 + 1964) == 2;
      }
LABEL_121:
      uint64_t v95 = sub_10061136C(v13[5]);
      char v96 = v95;
      unsigned int v97 = v295;
      if (byte_1008F1E9D) {
        unsigned int v97 = 0;
      }
      if (v97 != 1) {
        goto LABEL_146;
      }
      if ((sub_1005F4430(v316, v13[5]) & 1) != 0)
      {
        int v313 = 1;
        uint64_t v98 = v316;
      }

      else
      {
        uint64_t v98 = v316;
        if (*(_BYTE *)(*(void *)(v13[5] + 8LL) + 200LL))
        {
          int v99 = (os_log_s *)qword_1008F75B8;
          if (os_log_type_enabled((os_log_t)qword_1008F75B8, OS_LOG_TYPE_DEFAULT))
          {
            LOWORD(v356.__r_.__value_.__l.__data_) = 0;
            _os_log_impl( (void *)&_mh_execute_header,  v99,  OS_LOG_TYPE_DEFAULT,  "Scanning Prioritization for double boost with allowed use cases.",  (uint8_t *)&v356,  2u);
          }

          int v313 = 1;
        }
      }

      if (qword_1008D6198 != -1) {
        dispatch_once(&qword_1008D6198, &stru_1008A4058);
      }
      uint64_t v95 = sub_1004494F0();
      if ((v313 & 1) == 0) {
        goto LABEL_143;
      }
      int v100 = v95 & 0xFFFFFFFD;
      if ((_DWORD)v95 == 2)
      {
        uint64_t v101 = sub_1002E6E9C();
        uint64_t v95 = (*(uint64_t (**)(uint64_t))(*(void *)v101 + 2648LL))(v101);
        if (v100 == 1) {
          char v102 = 0;
        }
        else {
          char v102 = v95;
        }
        if ((v102 & 1) != 0)
        {
LABEL_145:
          int v313 = 1;
          goto LABEL_146;
        }
      }

      else if (v100 != 1)
      {
        goto LABEL_145;
      }

      v293 &= v289;
      id v103 = (os_log_s *)qword_1008F75B8;
      uint64_t v95 = os_log_type_enabled((os_log_t)qword_1008F75B8, OS_LOG_TYPE_DEFAULT);
      int v313 = 0;
      if ((v95 & 1) != 0)
      {
        LOWORD(v356.__r_.__value_.__l.__data_) = 0;
        _os_log_impl( (void *)&_mh_execute_header,  v103,  OS_LOG_TYPE_DEFAULT,  "Scanning Prioritization is not enabled with HIDs connected.",  (uint8_t *)&v356,  2u);
LABEL_143:
        int v313 = 0;
      }

LABEL_205:
  if ((_DWORD)v290) {
    BOOL v150 = v147 == 0;
  }
  else {
    BOOL v150 = 1;
  }
  char v151 = !v150;
  if (v150)
  {
    unsigned int v153 = *((unsigned __int16 *)a2 + 3);
    unsigned int v152 = *((unsigned __int16 *)a2 + 2);
  }

  else
  {
    if (v283) {
      *a2 = 0;
    }
    unsigned int v152 = *((unsigned __int16 *)a2 + 2);
    unsigned int v153 = *((unsigned __int16 *)a2 + 3);
    if ((int)v290 / v147 <= (int)(v152 / v153))
    {
      unsigned int v152 = (int)((double)(int)v290 / 0.625);
      *((_WORD *)a2 + 2) = v152;
      unsigned int v153 = (int)((double)v147 / 0.625);
      *((_WORD *)a2 + 3) = v153;
    }
  }

  if (qword_1008D6198 != -1) {
    dispatch_once(&qword_1008D6198, &stru_1008A4058);
  }
  BOOL v154 = sub_100449204(off_1008D6190);
  uint64_t v155 = sub_1002E6BF0();
  int v156 = (*(uint64_t (**)(uint64_t))(*(void *)v155 + 968LL))(v155);
  if (((v154 | v156 ^ 1) & 1) != 0) {
    char v157 = 0;
  }
  else {
    char v157 = _os_feature_enabled_impl("BluetoothFeatures", "ScanCorePolicyV2");
  }
  LODWORD(v356.__r_.__value_.__l.__data_) = 100;
  if ((int)v281 / v280 == *((unsigned __int16 *)a2 + 2) / *((unsigned __int16 *)a2 + 3)
    && _os_feature_enabled_impl("BluetoothFeatures", "ScanCorePolicyV2"))
  {
    v157 |= v148;
  }

  if (!v154)
  {
    uint64_t v158 = sub_1002E8EE8();
    unsigned int v159 = 100 * v153 / v152;
    if ((_DWORD)v291 == 1)
    {
      if (v159 < 0x32) {
        goto LABEL_229;
      }
    }

    else
    {
      if (v159 > 0x31) {
        char v163 = v151;
      }
      else {
        char v163 = 0;
      }
      if ((v163 & 1) == 0)
      {
LABEL_229:
        if (v159 < 0x22)
        {
          char v157 = 0;
        }

        else
        {
          signed __int8 v160 = (os_log_s *)qword_1008F75B8;
          if (os_log_type_enabled((os_log_t)qword_1008F75B8, OS_LOG_TYPE_INFO))
          {
            LOWORD(v161) = *((_WORD *)a2 + 3);
            LOWORD(v162) = *((_WORD *)a2 + 2);
            *(_DWORD *)std::stringbuf::string_type buf = 134219264;
            *(double *)&uint8_t buf[4] = (double)v161 * 0.625;
            *(_WORD *)&_BYTE buf[12] = 2048;
            *(double *)&buf[14] = (double)v162 * 0.625;
            *(_WORD *)&_BYTE buf[22] = 1024;
            *(_DWORD *)&uint8_t buf[24] = v159;
            *(_WORD *)&buf[28] = 2048;
            *(void *)&buf[30] = 0x403E000000000000LL;
            *(_WORD *)&_BYTE buf[38] = 2048;
            *(void *)&uint8_t buf[40] = 0x4056800000000000LL;
            *(_WORD *)&buf[48] = 1024;
            *(_DWORD *)&buf[50] = v291;
            _os_log_impl( (void *)&_mh_execute_header,  v160,  OS_LOG_TYPE_INFO,  "Limiting scan duty cycle based on other activities from %.2fms/%.2fms (scanPercentage %d)to %.2fms/%.2fms minScanLevel %d",  buf,  0x36u);
          }

          *((_DWORD *)a2 + 1) = 3145872;
          v356.__r_.__value_.__s.__data_[0] = ((3 * v159) >> 1) - 50;
        }

        goto LABEL_241;
      }
    }

    int v164 = (os_log_s *)qword_1008F75B8;
    if (os_log_type_enabled((os_log_t)qword_1008F75B8, OS_LOG_TYPE_INFO))
    {
      LOWORD(v165) = *((_WORD *)a2 + 3);
      LOWORD(v166) = *((_WORD *)a2 + 2);
      *(_DWORD *)std::stringbuf::string_type buf = 134219264;
      *(double *)&uint8_t buf[4] = (double)v165 * 0.625;
      *(_WORD *)&_BYTE buf[12] = 2048;
      *(double *)&buf[14] = (double)v166 * 0.625;
      *(_WORD *)&_BYTE buf[22] = 1024;
      *(_DWORD *)&uint8_t buf[24] = v159;
      *(_WORD *)&buf[28] = 2048;
      *(void *)&buf[30] = 0x403E000000000000LL;
      *(_WORD *)&_BYTE buf[38] = 2048;
      *(void *)&uint8_t buf[40] = 0x404E000000000000LL;
      *(_WORD *)&buf[48] = 1024;
      *(_DWORD *)&buf[50] = v291;
      _os_log_impl( (void *)&_mh_execute_header,  v164,  OS_LOG_TYPE_INFO,  "Limiting scan duty cycle based on other activities from %.2fms/%.2fms (scanPercentage %d)to %.2fms/%.2fms minScanLevel %d",  buf,  0x36u);
    }

    *((_DWORD *)a2 + 1) = 3145824;
  }

LABEL_241:
  if (*(void *)(v316 + 2344))
  {
    if (qword_1008D9700 != -1) {
      dispatch_once(&qword_1008D9700, &stru_1008A40D8);
    }
    int v167 = sub_1003ACC60((uint64_t)off_1008D96F8);
    *((_WORD *)a2 + 2) = v167;
    *((_WORD *)a2 + 3) = 48;
    uint64_t v168 = (os_log_s *)qword_1008F76D8;
    if (os_log_type_enabled((os_log_t)qword_1008F76D8, OS_LOG_TYPE_INFO))
    {
      *(_DWORD *)std::stringbuf::string_type buf = 67109376;
      *(_DWORD *)&uint8_t buf[4] = v167;
      *(_WORD *)&uint8_t buf[8] = 1024;
      *(_DWORD *)&buf[10] = 48;
      _os_log_impl( (void *)&_mh_execute_header,  v168,  OS_LOG_TYPE_INFO,  "ExposureNotification scan active, setting params interval:%d window:%d",  buf,  0xEu);
    }

    BOOL v288 = 0;
    char v157 = 0;
  }

  if (!*a2 && !((*(_BYTE *)(v316 + 144) != 0) | v287 & 1))
  {
    __int128 v169 = (os_log_s *)qword_1008F75B8;
    if (os_log_type_enabled((os_log_t)qword_1008F75B8, OS_LOG_TYPE_DEFAULT))
    {
      *(_WORD *)std::stringbuf::string_type buf = 0;
      _os_log_impl( (void *)&_mh_execute_header,  v169,  OS_LOG_TYPE_DEFAULT,  "Forcing passive scans based on screen state",  buf,  2u);
    }

    *a2 = 1;
    if (*(_BYTE *)(v316 + 2246))
    {
      __int128 v170 = (os_log_s *)qword_1008F75B8;
      if (os_log_type_enabled((os_log_t)qword_1008F75B8, OS_LOG_TYPE_DEFAULT))
      {
        int v171 = *(unsigned __int8 *)(v316 + 2247);
        *(_DWORD *)std::stringbuf::string_type buf = 67109120;
        *(_DWORD *)&uint8_t buf[4] = v171;
        _os_log_impl((void *)&_mh_execute_header, v170, OS_LOG_TYPE_DEFAULT, "ForcePassiveScan is now %d", buf, 8u);
      }

      *a2 = *(_BYTE *)(v316 + 2247);
    }
  }

  if (v288)
  {
    __int128 v172 = (os_log_s *)qword_1008F75B8;
    if (os_log_type_enabled((os_log_t)qword_1008F75B8, OS_LOG_TYPE_INFO))
    {
      *(_DWORD *)std::stringbuf::string_type buf = 134218240;
      *(double *)&uint8_t buf[4] = v17;
      *(_WORD *)&_BYTE buf[12] = 2048;
      *(double *)&buf[14] = v16;
      _os_log_impl( (void *)&_mh_execute_header,  v172,  OS_LOG_TYPE_INFO,  "ADV buffer only, overriding settings HWADVBufferIntervalMs:%f HWADVBufferWindowMs:%f",  buf,  0x16u);
    }

    char v157 = 0;
    *((_WORD *)a2 + 2) = (int)(v17 / 0.625);
    *((_WORD *)a2 + 3) = (int)(v16 / 0.625);
    *a2 = 1;
  }

  uint64_t v173 = sub_1002E6E9C();
  if ((*(unsigned int (**)(uint64_t))(*(void *)v173 + 2704LL))(v173))
  {
    if (qword_1008D6198 != -1) {
      dispatch_once(&qword_1008D6198, &stru_1008A4058);
    }
    if (*((_BYTE *)off_1008D6190 + 201))
    {
      unsigned int v174 = *((unsigned __int16 *)a2 + 3);
      unsigned int v175 = *((unsigned __int16 *)a2 + 2);
      if (100 * v174 / v175 >= 0xB)
      {
        __int128 v176 = (os_log_s *)qword_1008F75B8;
        if (os_log_type_enabled((os_log_t)qword_1008F75B8, OS_LOG_TYPE_INFO))
        {
          *(_DWORD *)std::stringbuf::string_type buf = 134219264;
          *(double *)&uint8_t buf[4] = (double)v174 * 0.625;
          *(_WORD *)&_BYTE buf[12] = 2048;
          *(double *)&buf[14] = (double)v175 * 0.625;
          *(_WORD *)&_BYTE buf[22] = 1024;
          *(_DWORD *)&uint8_t buf[24] = 100 * v174 / v175;
          *(_WORD *)&buf[28] = 2048;
          *(void *)&buf[30] = 0x403E000000000000LL;
          *(_WORD *)&_BYTE buf[38] = 2048;
          *(void *)&uint8_t buf[40] = 0x4072C00000000000LL;
          *(_WORD *)&buf[48] = 1024;
          *(_DWORD *)&buf[50] = v291;
          _os_log_impl( (void *)&_mh_execute_header,  v176,  OS_LOG_TYPE_INFO,  "Limiting scan duty cycle due to BT ACL protect mode from %.2fms/%.2fms (scanPercentage %d)to %.2fms/%.2fms minScanLevel %d",  buf,  0x36u);
        }

        *((_DWORD *)a2 + 1) = 3146208;
      }
    }
  }

  double v177 = *(double *)(v316 + 2336);
  if (v292)
  {
    if (v177 == 0.0)
    {
      CFAbsoluteTime Current = CFAbsoluteTimeGetCurrent();
      *(CFAbsoluteTime *)(v316 + 2336) = Current;
      *(CFAbsoluteTime *)(v316 + 232_Block_object_dispose(va, 8) = Current;
    }
  }

  else
  {
    if (v177 != 0.0)
    {
      CFAbsoluteTime v179 = CFAbsoluteTimeGetCurrent();
      *(void *)(v316 + 2304) = (unint64_t)(v179
      *(CFAbsoluteTime *)(v316 + 2336) = v179;
    }

    *(void *)(v316 + 2336) = 0LL;
  }

  if ((v286 | v285) == 1
    && (*((unsigned __int16 *)a2 + 3) == 0xFFFF || !*((_WORD *)a2 + 3))
    && sub_1005EE698(v316))
  {
    *((_WORD *)a2 + 2) = 4800;
  }

  char v180 = v148 | v157;
  unsigned int v181 = 100 * *((unsigned __int16 *)a2 + 3) / *((unsigned __int16 *)a2 + 2);
  if (v181 < 0x1E)
  {
    if (((v313 | v293) & 1) != 0)
    {
      __int128 v182 = (os_log_s *)qword_1008F75B8;
      if (os_log_type_enabled((os_log_t)qword_1008F75B8, OS_LOG_TYPE_DEFAULT))
      {
        __int128 v183 = "No";
        if ((v313 & 1) != 0) {
          __int128 v184 = "Yes";
        }
        else {
          __int128 v184 = "No";
        }
        *(_DWORD *)std::stringbuf::string_type buf = 136315650;
        *(void *)&uint8_t buf[4] = v184;
        if ((v293 & 1) != 0) {
          __int128 v183 = "Yes";
        }
        *(_WORD *)&_BYTE buf[12] = 2080;
        *(void *)&buf[14] = v183;
        *(_WORD *)&_BYTE buf[22] = 1024;
        *(_DWORD *)&uint8_t buf[24] = v181;
        _os_log_impl( (void *)&_mh_execute_header,  v182,  OS_LOG_TYPE_DEFAULT,  "Do not prioritize scanning over BT %s WiFi %s for scan duty cycle %u.",  buf,  0x1Cu);
      }
    }
  }

  else
  {
    a2[24] = v313 & 1;
    a2[25] = v293 & 1;
  }

  uint64_t v185 = v316;
  if (*(_BYTE *)(v316 + 4384))
  {
    unsigned int v186 = *((unsigned __int16 *)a2 + 3);
    unsigned int v187 = *((unsigned __int16 *)a2 + 2);
    double v188 = (double)v186 * 100.0 / (double)v187;
    __int128 v189 = (os_log_s *)qword_1008F75B8;
    if (os_log_type_enabled((os_log_t)qword_1008F75B8, OS_LOG_TYPE_DEFAULT))
    {
      *(_DWORD *)std::stringbuf::string_type buf = 67110144;
      *(_DWORD *)&uint8_t buf[4] = v186;
      *(_WORD *)&uint8_t buf[8] = 1024;
      *(_DWORD *)&buf[10] = v187;
      *(_WORD *)&buf[14] = 2048;
      *(double *)&uint8_t buf[16] = (double)v186 * 100.0 / (double)v187;
      *(_WORD *)&uint8_t buf[24] = 2048;
      *(void *)&_BYTE buf[26] = 0x4008DAB7EC1DD343LL;
      *(_WORD *)&buf[34] = 1024;
      *(_DWORD *)&buf[36] = v188 > 3.10679612;
      _os_log_impl( (void *)&_mh_execute_header,  v189,  OS_LOG_TYPE_DEFAULT,  "Checking if throttling down our scan during SDP is needed window:%d interval:%d dutyCycle:%f throttledDutyCycle: %f needToThrottle:%d",  buf,  0x28u);
    }

    if (v188 <= 3.10679612)
    {
      uint64_t v185 = v316;
    }

    else
    {
      char v190 = (os_log_s *)qword_1008F75B8;
      uint64_t v185 = v316;
      if (os_log_type_enabled((os_log_t)qword_1008F75B8, OS_LOG_TYPE_DEFAULT))
      {
        *(_WORD *)std::stringbuf::string_type buf = 0;
        _os_log_impl( (void *)&_mh_execute_header,  v190,  OS_LOG_TYPE_DEFAULT,  "Throttling down our scan during SDP",  buf,  2u);
      }

      *((_DWORD *)a2 + 1) = 3147273;
      if ((v296 & 1) != 0)
      {
        LODWORD(v356.__r_.__value_.__l.__data_) = 72745216;
        char v180 = 1;
      }
    }
  }

  if (!*a2)
  {
    a2[3] = (v284 & 1) == 0;
    if ((v284 & 1) == 0) {
      goto LABEL_300;
    }
    goto LABEL_299;
  }

  a2[3] = (v297 & 1) == 0;
  if ((v297 & 1) != 0) {
LABEL_299:
  }
    *(_BYTE *)(v185 + 2352) = 0;
LABEL_300:
  int v191 = *((unsigned __int16 *)a2 + 2);
  if (v191 != 48)
  {
    if (*((_WORD *)a2 + 2))
    {
      int v192 = *((unsigned __int16 *)a2 + 3);
      if (*((_WORD *)a2 + 3))
      {
        if (v192 == v191)
        {
          if (os_log_type_enabled((os_log_t)qword_1008F75B8, OS_LOG_TYPE_DEBUG)) {
            sub_10069DE00(v192);
          }
          uint64_t v185 = v316;
          *((_DWORD *)a2 + 1) = 3145776;
        }
      }
    }
  }

  if ((v180 & (*a2 != 0)) == 0)
  {
    v356.__r_.__value_.__s.__data_[0] = 0;
    *(_WORD *)&v356.__r_.__value_.__s.__data_[2] = 0;
  }

  if (v306)
  {
    __int128 v193 = (os_log_s *)qword_1008F75B8;
    if (os_log_type_enabled((os_log_t)qword_1008F75B8, OS_LOG_TYPE_DEFAULT))
    {
      __int128 v194 = "No";
      if (v279) {
        __int128 v194 = "Yes";
      }
      *(_DWORD *)std::stringbuf::string_type buf = 67109378;
      *(_DWORD *)&uint8_t buf[4] = v322;
      *(_WORD *)&uint8_t buf[8] = 2080;
      *(void *)&buf[10] = v194;
      _os_log_impl( (void *)&_mh_execute_header,  v193,  OS_LOG_TYPE_DEFAULT,  "powerSource %d is wall powered %s\n",  buf,  0x12u);
    }
  }

  sub_100601254(v185, a2, v286, v285, v307 & 1, v309, (uint64_t)&v356, v306);
  uint64_t v195 = sub_1002E6E9C();
  if ((*(unsigned int (**)(uint64_t, void, void))(*(void *)v195 + 2664LL))( v195,  *((unsigned __int16 *)a2 + 2),  *((unsigned __int16 *)a2 + 3)))
  {
    a2[25] = 1;
  }

  __int128 v196 = (os_log_s *)qword_1008F75B8;
  if (os_log_type_enabled((os_log_t)qword_1008F75B8, OS_LOG_TYPE_DEFAULT))
  {
    LOWORD(v197) = *((_WORD *)a2 + 3);
    *(double *)&unint64_t v198 = (double)v197;
    double v199 = *(double *)&v198 * 0.625;
    LOWORD(v19_Block_object_dispose(va, 8) = *((_WORD *)a2 + 2);
    *(double *)&unint64_t v200 = (double)v198;
    double v201 = *(double *)&v200 * 0.625;
    LOWORD(v200) = *((_WORD *)a2 + 4);
    double v202 = (double)v200;
    double v203 = v202 * 0.625;
    if (v286) {
      __int128 v204 = "supported";
    }
    else {
      __int128 v204 = "unsupported";
    }
    LOWORD(v202) = *((_WORD *)a2 + 6);
    *(double *)&unint64_t v205 = (double)*(unint64_t *)&v202;
    double v206 = *(double *)&v205 * 0.625;
    LOWORD(v205) = *((_WORD *)a2 + 5);
    double v207 = (double)v205 * 0.625;
    if (a2[14]) {
      __int128 v208 = "concurrent";
    }
    else {
      __int128 v208 = "non-concurrent";
    }
    if (v285) {
      __int128 v209 = "supported";
    }
    else {
      __int128 v209 = "unspported";
    }
    if (qword_1008D6198 != -1) {
      dispatch_once(&qword_1008D6198, &stru_1008A4058);
    }
    int v210 = *((unsigned __int8 *)off_1008D6190 + 204);
    int v211 = *(unsigned __int8 *)(v316 + 144);
    __n128 v212 = "passive";
    if (!*a2) {
      __n128 v212 = "active";
    }
    if (a2[3]) {
      __int128 v213 = "Enabled";
    }
    else {
      __int128 v213 = "Disabled";
    }
    int v214 = *((unsigned __int16 *)a2 + 10);
    int v215 = *((unsigned __int16 *)a2 + 11);
    __int16 v216 = "Yes";
    int v217 = a2[24];
    if (v154) {
      uint64_t v218 = "Yes";
    }
    else {
      uint64_t v218 = "No";
    }
    int v219 = a2[25];
    if (!a2[18]) {
      __int16 v216 = "No";
    }
    *(_DWORD *)std::stringbuf::string_type buf = 134224642;
    *(double *)&uint8_t buf[4] = v199;
    *(_WORD *)&_BYTE buf[12] = 2048;
    *(double *)&buf[14] = v201;
    *(_WORD *)&_BYTE buf[22] = 2048;
    *(double *)&uint8_t buf[24] = v203;
    *(_WORD *)&_BYTE buf[32] = 2048;
    *(double *)&buf[34] = v201;
    *(_WORD *)&_BYTE buf[42] = 2082;
    *(void *)&buf[44] = v204;
    *(_WORD *)&buf[52] = 2048;
    *(double *)&buf[54] = v206;
    *(_WORD *)&buf[62] = 2048;
    *(double *)&_BYTE buf[64] = v207;
    *(_WORD *)&buf[72] = 2082;
    *(void *)&buf[74] = v208;
    *(_WORD *)&buf[82] = 2082;
    *(void *)&buf[84] = v209;
    *(_WORD *)&buf[92] = 1024;
    *(_DWORD *)&buf[94] = v315;
    *(_WORD *)&buf[98] = 1024;
    *(_DWORD *)&buf[100] = v290;
    *(_WORD *)char v324 = 1024;
    *(_DWORD *)&v324[2] = v210;
    *(_WORD *)unsigned __int16 v325 = 1024;
    *(_DWORD *)&v325[2] = v154;
    __int16 v326 = 1024;
    int v327 = v156;
    __int16 v328 = 1024;
    int v329 = v180 & 1;
    __int16 v330 = 1024;
    int v331 = v287 & 1;
    __int16 v332 = 1024;
    int v333 = v211;
    __int16 v334 = 2082;
    v335 = v212;
    __int16 v336 = 2082;
    v337 = v213;
    __int16 v338 = 1024;
    int v339 = v291;
    __int16 v340 = 2082;
    v341 = v218;
    __int16 v342 = 2082;
    v343 = v216;
    __int16 v344 = 1024;
    int v345 = v214;
    __int16 v346 = 1024;
    int v347 = v215;
    __int16 v348 = 1024;
    int v349 = v217;
    __int16 v350 = 1024;
    int v351 = v219;
    __int16 v352 = 1024;
    int v353 = v322;
    _os_log_impl( (void *)&_mh_execute_header,  v196,  OS_LOG_TYPE_DEFAULT,  "Returning scan parameters: Main:%.2fms/%.2fms LP:%.2fms/%.2fms(%{public}s) SC:%.2fms/%.2fms/%{public}s(%{public}s) Dm:(m:%d/%d) Cond:%d:%d:%d:%d:%d Sc:%d (%{public}s) Dupfilter:%{public}s minScanLevel:%d HD:%{public}s Comp:%{pub lic}s(%d,%d) Pri:%d/%d PS:%d",  buf,  0xD8u);
  }

  if (*(_BYTE *)(v316 + 2222))
  {
    unsigned int v220 = *(unsigned __int16 *)(v316 + 2224);
    *((_WORD *)a2 + 2) = v220;
    unsigned int v221 = *(unsigned __int16 *)(v316 + 2226);
    *((_WORD *)a2 + 3) = v221;
    unsigned int v222 = *(unsigned __int16 *)(v316 + 2228);
    *((_WORD *)a2 + 4) = v222;
    unsigned __int16 v223 = *(_BYTE *)(v316 + 2230) ? *(_WORD *)(v316 + 2232) : 0;
    unsigned __int16 v224 = *(_BYTE *)(v316 + 2230) ? 0 : *(_WORD *)(v316 + 2232);
    *((_WORD *)a2 + 6) = v223;
    *((_WORD *)a2 + 5) = v224;
    int v225 = *(unsigned __int8 *)(v316 + 2234);
    a2[14] = v225;
    BOOL v226 = *(_BYTE *)(v316 + 2235) && *(_BYTE *)(v316 + 2238) != 0;
    a2[18] = v226;
    int v227 = *(_BYTE *)(v316 + 2236) ? *(unsigned __int16 *)(v316 + 2240) : 0;
    *unsigned int v282 = v227;
    int v228 = *(_BYTE *)(v316 + 2237) ? *(unsigned __int16 *)(v316 + 2242) : 0;
    *((_WORD *)a2 + 11) = v228;
    int v229 = (os_log_s *)qword_1008F75B8;
    if (os_log_type_enabled((os_log_t)qword_1008F75B8, OS_LOG_TYPE_DEFAULT))
    {
      *(_DWORD *)std::stringbuf::string_type buf = 67112450;
      __int16 v230 = "Yes";
      *(_DWORD *)&uint8_t buf[4] = v220;
      *(_WORD *)&uint8_t buf[8] = 2048;
      if (v225) {
        int v231 = "Yes";
      }
      else {
        int v231 = "No";
      }
      *(double *)&buf[10] = (double)v220 * 0.625;
      *(_WORD *)&_BYTE buf[18] = 1024;
      *(_DWORD *)&_BYTE buf[20] = v221;
      if (!v226) {
        __int16 v230 = "No";
      }
      *(_WORD *)&uint8_t buf[24] = 1024;
      *(_DWORD *)&_BYTE buf[26] = v222;
      *(_WORD *)&buf[30] = 1024;
      *(_DWORD *)&_BYTE buf[32] = v223;
      *(_WORD *)&buf[36] = 1024;
      *(_DWORD *)&_BYTE buf[38] = v224;
      *(_WORD *)&_BYTE buf[42] = 2048;
      *(double *)&buf[44] = (double)v221 * 0.625;
      *(_WORD *)&buf[52] = 2048;
      *(double *)&buf[54] = (double)v222 * 0.625;
      *(_WORD *)&buf[62] = 2048;
      *(double *)&_BYTE buf[64] = (double)v223 * 0.625;
      *(_WORD *)&buf[72] = 2048;
      *(double *)&buf[74] = (double)v224 * 0.625;
      *(_WORD *)&buf[82] = 2082;
      *(void *)&buf[84] = v231;
      *(_WORD *)&buf[92] = 2082;
      *(void *)&buf[94] = v230;
      *(_WORD *)&buf[102] = 1024;
      *(_DWORD *)char v324 = v227;
      *(_WORD *)&v324[4] = 1024;
      *(_DWORD *)unsigned __int16 v325 = v228;
      _os_log_impl( (void *)&_mh_execute_header,  v229,  OS_LOG_TYPE_DEFAULT,  "Returning scan parameters (overridden with ScanCore) Interval %d(%.2fms) Window %d/%d/%d/%d(%.2fms/%.2fms/%.2fms /%.2fms) Concurrent %{public}s Compensation %{public}s percent %d query %d",  buf,  0x72u);
    }
  }

  int v232 = *((unsigned __int16 *)a2 + 3);
  unsigned int v233 = *((unsigned __int16 *)a2 + 2);
  __int16 v234 = (void *)objc_claimAutoreleasedReturnValue(+[NSMutableDictionary dictionary](&OBJC_CLASS___NSMutableDictionary, "dictionary"));
  BOOL v235 = (void *)objc_claimAutoreleasedReturnValue(+[NSNumber numberWithBool:](&OBJC_CLASS___NSNumber, "numberWithBool:", *a2));
  [v234 setObject:v235 forKeyedSubscript:@"scanParams.passive"];

  __int128 v236 = (void *)objc_claimAutoreleasedReturnValue(+[NSNumber numberWithBool:](&OBJC_CLASS___NSNumber, "numberWithBool:", a2[1]));
  [v234 setObject:v236 forKeyedSubscript:@"scanParams.limited"];

  __int128 v237 = (void *)objc_claimAutoreleasedReturnValue(+[NSNumber numberWithBool:](&OBJC_CLASS___NSNumber, "numberWithBool:", a2[3]));
  [v234 setObject:v237 forKeyedSubscript:@"scanParams.filterDups"];

  LOWORD(v23_Block_object_dispose(va, 8) = *((_WORD *)a2 + 2);
  __int128 v239 = (void *)objc_claimAutoreleasedReturnValue(+[NSNumber numberWithDouble:](&OBJC_CLASS___NSNumber, "numberWithDouble:", (double)v238 * 0.625));
  [v234 setObject:v239 forKeyedSubscript:@"scanParams.interval"];

  LOWORD(v240) = *((_WORD *)a2 + 3);
  __int128 v241 = (void *)objc_claimAutoreleasedReturnValue(+[NSNumber numberWithDouble:](&OBJC_CLASS___NSNumber, "numberWithDouble:", (double)v240 * 0.625));
  [v234 setObject:v241 forKeyedSubscript:@"scanParams.window"];

  LOWORD(v242) = *((_WORD *)a2 + 4);
  std::stringbuf::string_type v243 = (void *)objc_claimAutoreleasedReturnValue(+[NSNumber numberWithDouble:](&OBJC_CLASS___NSNumber, "numberWithDouble:", (double)v242 * 0.625));
  [v234 setObject:v243 forKeyedSubscript:@"scanParams.windowLPCore"];

  LOWORD(v244) = *((_WORD *)a2 + 5);
  id v245 = (void *)objc_claimAutoreleasedReturnValue(+[NSNumber numberWithDouble:](&OBJC_CLASS___NSNumber, "numberWithDouble:", (double)v244 * 0.625));
  [v234 setObject:v245 forKeyedSubscript:@"scanParams.windowScanCoreELNABypass"];

  LOWORD(v246) = *((_WORD *)a2 + 6);
  int v247 = (void *)objc_claimAutoreleasedReturnValue(+[NSNumber numberWithDouble:](&OBJC_CLASS___NSNumber, "numberWithDouble:", (double)v246 * 0.625));
  [v234 setObject:v247 forKeyedSubscript:@"scanParams.windowScanCoreELNAOn"];

  __int128 v248 = (void *)objc_claimAutoreleasedReturnValue(+[NSNumber numberWithBool:](&OBJC_CLASS___NSNumber, "numberWithBool:", a2[14]));
  [v234 setObject:v248 forKeyedSubscript:@"scanParams.concurrencyMode"];

  __int128 v249 = (void *)objc_claimAutoreleasedReturnValue(+[NSNumber numberWithUnsignedChar:](&OBJC_CLASS___NSNumber, "numberWithUnsignedChar:", a2[15]));
  [v234 setObject:v249 forKeyedSubscript:@"scanParams.scanningPhys"];

  uint64_t v250 = (void *)objc_claimAutoreleasedReturnValue(+[NSNumber numberWithBool:](&OBJC_CLASS___NSNumber, "numberWithBool:", a2[16]));
  [v234 setObject:v250 forKeyedSubscript:@"scanParams.retainDuplicates"];

  __int128 v251 = (void *)objc_claimAutoreleasedReturnValue(+[NSNumber numberWithUnsignedChar:](&OBJC_CLASS___NSNumber, "numberWithUnsignedChar:", a2[17]));
  [v234 setObject:v251 forKeyedSubscript:@"scanParams.priorityConfig"];

  int v252 = (void *)objc_claimAutoreleasedReturnValue(+[NSNumber numberWithBool:](&OBJC_CLASS___NSNumber, "numberWithBool:", a2[18]));
  [v234 setObject:v252 forKeyedSubscript:@"scanParams.isScanCoreCompensated"];

  __int128 v253 = (void *)objc_claimAutoreleasedReturnValue(+[NSNumber numberWithUnsignedShort:](&OBJC_CLASS___NSNumber, "numberWithUnsignedShort:", *v282));
  [v234 setObject:v253 forKeyedSubscript:@"scanParams.scanCoreCompensationPercent"];

  __int128 v254 = (void *)objc_claimAutoreleasedReturnValue( +[NSNumber numberWithUnsignedShort:]( &OBJC_CLASS___NSNumber,  "numberWithUnsignedShort:",  *((unsigned __int16 *)a2 + 11)));
  [v234 setObject:v254 forKeyedSubscript:@"scanParams.scanCoreCoexQueryPeriod"];

  __int128 v255 = (void *)objc_claimAutoreleasedReturnValue(+[NSNumber numberWithBool:](&OBJC_CLASS___NSNumber, "numberWithBool:", a2[24]));
  [v234 setObject:v255 forKeyedSubscript:@"scanParams.isPrioritizedOverBT"];

  __int128 v256 = (void *)objc_claimAutoreleasedReturnValue(+[NSNumber numberWithBool:](&OBJC_CLASS___NSNumber, "numberWithBool:", a2[25]));
  [v234 setObject:v256 forKeyedSubscript:@"scanParams.isPrioritizedOverWiFi"];

  __int128 v257 = (void *)objc_claimAutoreleasedReturnValue( +[NSNumber numberWithBool:]( &OBJC_CLASS___NSNumber,  "numberWithBool:",  *(unsigned __int8 *)(v316 + 144)));
  [v234 setObject:v257 forKeyedSubscript:@"fScreenState"];

  __int128 v258 = (void *)objc_claimAutoreleasedReturnValue(+[NSNumber numberWithInt:](&OBJC_CLASS___NSNumber, "numberWithInt:", v290));
  [v234 setObject:v258 forKeyedSubscript:@"daemonInterval"];

  __int128 v259 = (void *)objc_claimAutoreleasedReturnValue(+[NSNumber numberWithInt:](&OBJC_CLASS___NSNumber, "numberWithInt:", v315));
  [v234 setObject:v259 forKeyedSubscript:@"daemonWindow"];

  __int128 v260 = (void *)objc_claimAutoreleasedReturnValue(+[NSNumber numberWithInt:](&OBJC_CLASS___NSNumber, "numberWithInt:", v291));
  [v234 setObject:v260 forKeyedSubscript:@"minScanLevel"];

  uint64_t v261 = (void *)objc_claimAutoreleasedReturnValue( +[NSNumber numberWithUnsignedInt:]( &OBJC_CLASS___NSNumber,  "numberWithUnsignedInt:",  100 * v232 / v233));
  [v234 setObject:v261 forKeyedSubscript:@"scanPercentage"];

  __int128 v262 = (void *)objc_claimAutoreleasedReturnValue(+[NSNumber numberWithBool:](&OBJC_CLASS___NSNumber, "numberWithBool:", v287 & 1));
  [v234 setObject:v262 forKeyedSubscript:@"allowInPause"];

  __int128 v263 = (void *)objc_claimAutoreleasedReturnValue(+[NSNumber numberWithBool:](&OBJC_CLASS___NSNumber, "numberWithBool:", v288));
  [v234 setObject:v263 forKeyedSubscript:@"onlyDoingHWADVBuffer"];

  __int128 v264 = (void *)objc_claimAutoreleasedReturnValue(+[NSNumber numberWithBool:](&OBJC_CLASS___NSNumber, "numberWithBool:", v292));
  [v234 setObject:v264 forKeyedSubscript:@"onlyDoingENHWADVBuffer"];

  __n128 v265 = (void *)objc_claimAutoreleasedReturnValue(+[NSNumber numberWithDouble:](&OBJC_CLASS___NSNumber, "numberWithDouble:", v17));
  [v234 setObject:v265 forKeyedSubscript:@"HWADVBufferIntervalMs"];

  v266 = (void *)objc_claimAutoreleasedReturnValue(+[NSNumber numberWithDouble:](&OBJC_CLASS___NSNumber, "numberWithDouble:", v16));
  [v234 setObject:v266 forKeyedSubscript:@"HWADVBufferWindowMs"];

  __int128 v267 = (void *)objc_claimAutoreleasedReturnValue(+[NSNumber numberWithBool:](&OBJC_CLASS___NSNumber, "numberWithBool:", v286));
  [v234 setObject:v267 forKeyedSubscript:@"scanLPCoreEnable"];

  __int128 v268 = (void *)objc_claimAutoreleasedReturnValue(+[NSNumber numberWithBool:](&OBJC_CLASS___NSNumber, "numberWithBool:", v285));
  [v234 setObject:v268 forKeyedSubscript:@"isScanCoreEnabled"];

  __int128 v269 = (void *)objc_claimAutoreleasedReturnValue(+[NSNumber numberWithBool:](&OBJC_CLASS___NSNumber, "numberWithBool:", v295));
  [v234 setObject:v269 forKeyedSubscript:@"supportsDiscoveryScanPrioritization"];

  v270 = (void *)objc_claimAutoreleasedReturnValue(+[NSNumber numberWithBool:](&OBJC_CLASS___NSNumber, "numberWithBool:", v309));
  [v234 setObject:v270 forKeyedSubscript:@"isRangeScan"];

  uint64_t v271 = (void *)objc_claimAutoreleasedReturnValue(+[NSNumber numberWithBool:](&OBJC_CLASS___NSNumber, "numberWithBool:", v307 & 1));
  [v234 setObject:v271 forKeyedSubscript:@"isPriorityCritical"];

  __int128 v272 = (void *)objc_claimAutoreleasedReturnValue(+[NSNumber numberWithUnsignedInt:](&OBJC_CLASS___NSNumber, "numberWithUnsignedInt:", v304));
  [v234 setObject:v272 forKeyedSubscript:@"combinedScanAgentType"];

  int v273 = (void *)objc_claimAutoreleasedReturnValue(+[NSNumber numberWithUnsignedInt:](&OBJC_CLASS___NSNumber, "numberWithUnsignedInt:", v294));
  [v234 setObject:v273 forKeyedSubscript:@"scanAgentType"];

  uint64_t v274 = (void *)objc_claimAutoreleasedReturnValue(+[NSNumber numberWithBool:](&OBJC_CLASS___NSNumber, "numberWithBool:", v313 & 1));
  [v234 setObject:v274 forKeyedSubscript:@"isPrioritizedOverBT"];

  __int128 v275 = (void *)objc_claimAutoreleasedReturnValue(+[NSNumber numberWithBool:](&OBJC_CLASS___NSNumber, "numberWithBool:", v293 & 1));
  [v234 setObject:v275 forKeyedSubscript:@"isPrioritizedOverWiFi"];

  __int128 v276 = (void *)objc_claimAutoreleasedReturnValue( +[NSNumber numberWithUnsignedInt:]( &OBJC_CLASS___NSNumber,  "numberWithUnsignedInt:",  *(unsigned int *)(v316 + 1964)));
  [v234 setObject:v276 forKeyedSubscript:@"fObserverState"];

  [v311 setObject:v234 forKeyedSubscript:@"Controller"];
  v318[0] = _NSConcreteStackBlock;
  v318[1] = 3221225472LL;
  v318[2] = sub_1006051D0;
  v318[3] = &unk_1008A3D98;
  id v277 = v311;
  id v319 = v277;
  sub_1005EBB90((os_unfair_lock_s *)(v316 + 1872), v318);

  return 1LL;
}

void sub_100604E00( _Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20, uint64_t a21, uint64_t a22, uint64_t a23, uint64_t a24, uint64_t a25, uint64_t a26, uint64_t a27, uint64_t a28, uint64_t a29, uint64_t a30, uint64_t a31, uint64_t a32, uint64_t a33, uint64_t a34, uint64_t a35, uint64_t a36, uint64_t a37, uint64_t a38, uint64_t a39, uint64_t a40, uint64_t a41, uint64_t a42, uint64_t a43, uint64_t a44, uint64_t a45, uint64_t a46, uint64_t a47, uint64_t a48, uint64_t a49, uint64_t a50,uint64_t a51,uint64_t a52,uint64_t a53,uint64_t a54,uint64_t a55,uint64_t a56,uint64_t a57,uint64_t a58,uint64_t a59,uint64_t a60,uint64_t a61,uint64_t a62,void *a63)
{
  _Unwind_Resume(a1);
}

uint64_t sub_1006051D0(uint64_t a1, uint64_t a2)
{
  return (*(uint64_t (**)(uint64_t, void))(*(void *)a2 + 64LL))(a2, *(void *)(a1 + 32));
}

uint64_t sub_1006051E8(uint64_t a1, uint64_t a2)
{
  uint64_t v3 = sub_1002E6BF0();
  unsigned int v235 = (*(uint64_t (**)(uint64_t))(*(void *)v3 + 616LL))(v3);
  uint64_t v4 = sub_1002E6BF0();
  unsigned int v234 = (*(uint64_t (**)(uint64_t))(*(void *)v4 + 648LL))(v4);
  uint64_t v5 = sub_1002E6BF0();
  int v236 = (*(uint64_t (**)(uint64_t))(*(void *)v5 + 824LL))(v5);
  uint64_t v6 = sub_1002E6E9C();
  int v232 = (*(uint64_t (**)(uint64_t))(*(void *)v6 + 2656LL))(v6);
  *(_WORD *)a2 = 1;
  *(_BYTE *)(a2 + 2) = 0;
  *(_WORD *)(a2 + _Block_object_dispose(va, 8) = 0;
  *(_BYTE *)(a2 + 15) = 1;
  __int128 v249 = (unsigned __int8 *)a2;
  *(_WORD *)(a2 + 24) = 0;
  __int128 v248 = (void *)objc_claimAutoreleasedReturnValue(+[NSMutableArray array](&OBJC_CLASS___NSMutableArray, "array"));
  unint64_t v246 = (void *)objc_claimAutoreleasedReturnValue(+[NSMutableDictionary dictionary](&OBJC_CLASS___NSMutableDictionary, "dictionary"));
  uint64_t v7 = *(void **)(a1 + 2040);
  uint64_t v8 = &AMFDRSealingMapCopyLocalDictForClass_ptr;
  if (v7 != (void *)(a1 + 2048))
  {
    BOOL v242 = 0;
    int v243 = 0;
    int v9 = 0;
    unsigned int v231 = 0;
    uint64_t v237 = 0LL;
    char v245 = 0;
    int v233 = 0;
    uint64_t v230 = 0LL;
    int v240 = 1;
    char v241 = 0;
    uint64_t v238 = 3LL;
    uint64_t v10 = 30LL;
    uint64_t v239 = 300LL;
    while (1)
    {
      uint64_t v11 = *(void *)(v7[5] + 8LL);
      memset(&v264[16], 0, 88);
      *(_OWORD *)__int128 v264 = 0u;
      uint64_t v12 = *(void *)(v7[5] + 8LL);
      __int128 v13 = *(_OWORD *)(v12 + 296);
      *(_OWORD *)__int128 v264 = *(_OWORD *)(v12 + 280);
      int v14 = *(_DWORD *)(v11 + 168);
      *(_OWORD *)&v264[16] = v13;
      *(_OWORD *)&v264[28] = *(_OWORD *)(v12 + 308);
      *(void *)&v264[56] = 0LL;
      *(void *)&v264[48] = 0LL;
      sub_10060E68C( &v264[48],  *(void *)(v12 + 328),  *(void *)(v12 + 336),  0xAAAAAAAAAAAAAAABLL * ((uint64_t)(*(void *)(v12 + 336) - *(void *)(v12 + 328)) >> 5));
      memset(&v264[72], 0, 24);
      sub_100050EE8( &v264[72],  *(__int128 **)(v12 + 352),  *(__int128 **)(v12 + 360),  0xCCCCCCCCCCCCCCCDLL * ((uint64_t)(*(void *)(v12 + 360) - *(void *)(v12 + 352)) >> 2));
      uint64_t v250 = v10;
      v264[96] = *(_BYTE *)(v12 + 376);
      int v252 = (void *)objc_claimAutoreleasedReturnValue(+[NSMutableDictionary dictionary](&OBJC_CLASS___NSMutableDictionary, "dictionary"));
      uint64_t v15 = (void *)objc_claimAutoreleasedReturnValue( +[NSNumber numberWithBool:]( &OBJC_CLASS___NSNumber,  "numberWithBool:",  *(unsigned __int8 *)(*(void *)(v7[5] + 8LL) + 3LL)));
      [v252 setObject:v15 forKeyedSubscript:@"isAllowedInPaused"];

      double v16 = +[NSNumber numberWithBool:](&OBJC_CLASS___NSNumber, "numberWithBool:", sub_100610C38(v7[5]));
      double v17 = (void *)objc_claimAutoreleasedReturnValue(v16);
      [v252 setObject:v17 forKeyedSubscript:@"allowDupes"];

      int v18 = (void *)objc_claimAutoreleasedReturnValue(+[NSNumber numberWithUnsignedInt:](&OBJC_CLASS___NSNumber, "numberWithUnsignedInt:", 0LL));
      [v252 setObject:v18 forKeyedSubscript:@"window"];

      uint64_t v19 = (void *)objc_claimAutoreleasedReturnValue(+[NSNumber numberWithUnsignedInt:](&OBJC_CLASS___NSNumber, "numberWithUnsignedInt:", 0LL));
      [v252 setObject:v19 forKeyedSubscript:@"interval"];

      __int128 v20 = (void *)objc_claimAutoreleasedReturnValue(+[NSNumber numberWithBool:](&OBJC_CLASS___NSNumber, "numberWithBool:", 0LL));
      [v252 setObject:v20 forKeyedSubscript:@"active"];

      __int128 v21 = +[NSNumber numberWithBool:](&OBJC_CLASS___NSNumber, "numberWithBool:", sub_100610DAC(v7[5]));
      __int128 v22 = (void *)objc_claimAutoreleasedReturnValue(v21);
      [v252 setObject:v22 forKeyedSubscript:@"requiresActiveScan"];

      __int128 v23 = (void *)objc_claimAutoreleasedReturnValue( +[NSNumber numberWithBool:]( &OBJC_CLASS___NSNumber,  "numberWithBool:",  *(unsigned __int8 *)(v7[5] + 81LL) == 32));
      [v252 setObject:v23 forKeyedSubscript:@"daemon"];

      __int128 v24 = (void *)objc_claimAutoreleasedReturnValue( +[NSNumber numberWithBool:]( &OBJC_CLASS___NSNumber,  "numberWithBool:",  *(unsigned __int8 *)(v7[5] + 81LL) == 16));
      [v252 setObject:v24 forKeyedSubscript:@"ForegroundApp"];

      __int128 v25 = +[NSNumber numberWithBool:](&OBJC_CLASS___NSNumber, "numberWithBool:", sub_100611304(v7[5]));
      __int128 v26 = (void *)objc_claimAutoreleasedReturnValue(v25);
      [v252 setObject:v26 forKeyedSubscript:@"isAnyHWObjectDiscoveryEnabled"];

      [v252 setObject:&off_1008C2C18 forKeyedSubscript:@"HWADVBufferWindowMs"];
      [v252 setObject:&off_1008C2C18 forKeyedSubscript:@"HWADVBufferIntervalMs"];
      unsigned int v27 = +[NSNumber numberWithBool:](&OBJC_CLASS___NSNumber, "numberWithBool:", sub_100611360(v7[5]));
      int v28 = (void *)objc_claimAutoreleasedReturnValue(v27);
      [v252 setObject:v28 forKeyedSubscript:@"isRangeScan"];

      double v29 = +[NSNumber numberWithBool:](&OBJC_CLASS___NSNumber, "numberWithBool:", sub_10061136C(v7[5]));
      __int16 v30 = (void *)objc_claimAutoreleasedReturnValue(v29);
      [v252 setObject:v30 forKeyedSubscript:@"isPriorityCritical"];

      BOOL v31 = (void *)objc_claimAutoreleasedReturnValue( +[NSNumber numberWithBool:]( &OBJC_CLASS___NSNumber,  "numberWithBool:",  *(unsigned __int8 *)(*(void *)(v7[5] + 8LL) + 142LL)));
      [v252 setObject:v31 forKeyedSubscript:@"holdPowerAssert"];

      int v32 = (void *)objc_claimAutoreleasedReturnValue( +[NSNumber numberWithBool:]( &OBJC_CLASS___NSNumber,  "numberWithBool:",  *(unsigned __int8 *)(*(void *)(v7[5] + 8LL) + 143LL)));
      [v252 setObject:v32 forKeyedSubscript:@"isContactTracing"];

      uint64_t v33 = (void *)objc_claimAutoreleasedReturnValue( +[NSNumber numberWithUnsignedInt:]( &OBJC_CLASS___NSNumber,  "numberWithUnsignedInt:",  *(unsigned int *)(v7[5] + 208LL)));
      [v252 setObject:v33 forKeyedSubscript:@"scanAgentType"];

      int v34 = (void *)objc_claimAutoreleasedReturnValue( +[NSNumber numberWithInt:]( &OBJC_CLASS___NSNumber,  "numberWithInt:",  *(unsigned int *)(v7[5] + 96LL)));
      [v252 setObject:v34 forKeyedSubscript:@"agentScanLevel"];

      int v35 = +[NSString stringWithUTF8String:](&OBJC_CLASS___NSString, "stringWithUTF8String:", sub_1005E2B18(v14));
      uint64_t v36 = (void *)objc_claimAutoreleasedReturnValue(v35);
      [v252 setObject:v36 forKeyedSubscript:@"usecase"];

      if (v264[8])
      {
        sub_1005E3244(v264, &__p);
        int v37 = (__p.__r_.__value_.__s.__size_ & 0x80u) == 0
            ? &__p
            : (std::stringbuf::string_type *)__p.__r_.__value_.__r.__words[0];
        int v38 = (void *)objc_claimAutoreleasedReturnValue(+[NSString stringWithUTF8String:](&OBJC_CLASS___NSString, "stringWithUTF8String:", v37));
        [v252 setObject:v38 forKeyedSubscript:@"usecaseParams"];
      }

      sub_100494958(v7[4], (uint64_t)&__p);
      if ((__p.__r_.__value_.__s.__size_ & 0x80u) == 0) {
        p_p = &__p;
      }
      else {
        p_p = (std::stringbuf::string_type *)__p.__r_.__value_.__r.__words[0];
      }
      unsigned int v40 = (void *)objc_claimAutoreleasedReturnValue(+[NSString stringWithUTF8String:](&OBJC_CLASS___NSString, "stringWithUTF8String:", p_p));
      [v246 setObject:v252 forKeyedSubscript:v40];

      if (!sub_100617C84(v7[5])) {
        goto LABEL_150;
      }
      ++v245;
      uint64_t v41 = v7[5];
      if (!*(_BYTE *)(*(void *)(v41 + 8) + 3LL) && *(_DWORD *)(a1 + 1964) == 2) {
        goto LABEL_150;
      }
      BOOL v42 = sub_100611304(v41);
      id v43 = (os_log_s *)qword_1008F75B8;
      if (v42)
      {
        if (os_log_type_enabled((os_log_t)qword_1008F75B8, OS_LOG_TYPE_ERROR)) {
          sub_10069DE94(&v258, v259);
        }
        uint64_t v44 = 0LL;
        uint64_t v45 = 0LL;
        uint64_t v247 = 0LL;
        int v46 = &AMFDRSealingMapCopyLocalDictForClass_ptr;
        goto LABEL_144;
      }

      if (os_log_type_enabled((os_log_t)qword_1008F75B8, OS_LOG_TYPE_DEFAULT))
      {
        int v47 = *(unsigned __int8 *)(v7[5] + 81LL);
        LODWORD(__p.__r_.__value_.__l.__data_) = 67109120;
        HIDWORD(__p.__r_.__value_.__r.__words[0]) = v47;
        _os_log_impl((void *)&_mh_execute_header, v43, OS_LOG_TYPE_DEFAULT, "state %d", (uint8_t *)&__p, 8u);
      }

      if (sub_100610D74(v7[5]) || sub_100610D98(v7[5]))
      {
        uint64_t v247 = 0LL;
      }

      else
      {
        int v48 = (os_log_s *)qword_1008F75B8;
        if (os_log_type_enabled((os_log_t)qword_1008F75B8, OS_LOG_TYPE_DEFAULT))
        {
          uint64_t v49 = v7[5];
          if (*(char *)(v49 + 255) < 0)
          {
            sub_100024238(buf, *(void **)(v49 + 232), *(void *)(v49 + 240));
            uint64_t v49 = v7[5];
          }

          else
          {
            *(_OWORD *)std::stringbuf::string_type buf = *(_OWORD *)(v49 + 232);
            *(void *)&uint8_t buf[16] = *(void *)(v49 + 248);
          }

          unsigned int v50 = buf[23] >= 0 ? buf : *(_BYTE **)buf;
          BOOL v51 = sub_100610D74(v49);
          BOOL v52 = sub_100610D98(v7[5]);
          LODWORD(__p.__r_.__value_.__l.__data_) = 136315650;
          *(std::string::size_type *)((char *)__p.__r_.__value_.__r.__words + 4) = (std::string::size_type)v50;
          WORD2(__p.__r_.__value_.__r.__words[1]) = 1024;
          *(_DWORD *)((char *)&__p.__r_.__value_.__r.__words[1] + 6) = v51;
          WORD1(__p.__r_.__value_.__r.__words[2]) = 1024;
          HIDWORD(__p.__r_.__value_.__r.__words[2]) = v52;
          _os_log_impl( (void *)&_mh_execute_header,  v48,  OS_LOG_TYPE_DEFAULT,  "Upgrading %s to active scan hasZoneScan:%d hasMatchingRulesScan:%d",  (uint8_t *)&__p,  0x18u);
          if ((buf[23] & 0x80000000) != 0) {
            operator delete(*(void **)buf);
          }
        }

        v9 |= sub_100610C38(v7[5]);
        uint64_t v247 = 1LL;
      }

      if (sub_100610D68(v7[5]))
      {
        id v53 = sub_100616628(v7[5], 0, (_DWORD *)(a1 + 4376));
        uint64_t v54 = (void *)objc_claimAutoreleasedReturnValue(v53);
        __int128 v262 = 0u;
        __int128 v263 = 0u;
        __int128 v260 = 0u;
        __int128 v261 = 0u;
        id obj = v54;
        id v55 = [obj countByEnumeratingWithState:&v260 objects:v286 count:16];
        if (v55)
        {
          uint64_t v56 = *(void *)v261;
          unsigned int v57 = v14 & 0xFFFF0000;
          do
          {
            for (uint64_t i = 0LL; i != v55; uint64_t i = (char *)i + 1)
            {
              if (*(void *)v261 != v56) {
                objc_enumerationMutation(obj);
              }
              uint64_t v59 = (void *)objc_claimAutoreleasedReturnValue( [*(id *)(*((void *)&v260 + 1) + 8 * (void)i) objectForKeyedSubscript:@"puckType"]);
              if (v59)
              {
                uint64_t v60 = objc_opt_class(&OBJC_CLASS___NSNumber);
                if ((objc_opt_isKindOfClass(v59, v60) & 1) != 0 && [v59 integerValue] == (id)8)
                {
                  float v61 = (os_log_s *)qword_1008F75B8;
                  if (os_log_type_enabled((os_log_t)qword_1008F75B8, OS_LOG_TYPE_DEFAULT))
                  {
                    int v62 = sub_100610C38(v7[5]);
                    LODWORD(__p.__r_.__value_.__l.__data_) = 67109120;
                    HIDWORD(__p.__r_.__value_.__r.__words[0]) = v62;
                    _os_log_impl( (void *)&_mh_execute_header,  v61,  OS_LOG_TYPE_DEFAULT,  "HS is asking for duplicates? %d",  (uint8_t *)&__p,  8u);
                  }

                  v9 |= sub_100610C38(v7[5]);
                }
              }

              if (v57 == 0x10000)
              {
                __int16 v63 = (os_log_s *)qword_1008F75B8;
                if (os_log_type_enabled((os_log_t)qword_1008F75B8, OS_LOG_TYPE_DEFAULT))
                {
                  uint64_t v64 = v7[5];
                  int v65 = *(_DWORD *)(*(void *)(v64 + 8) + 168LL);
                  int v66 = sub_100610C38(v64);
                  __int16 v67 = sub_1005E2B18(v65);
                  LODWORD(__p.__r_.__value_.__l.__data_) = 136315394;
                  unsigned int v68 = "No";
                  if (v66) {
                    unsigned int v68 = "Yes";
                  }
                  *(std::string::size_type *)((char *)__p.__r_.__value_.__r.__words + 4) = (std::string::size_type)v67;
                  WORD2(__p.__r_.__value_.__r.__words[1]) = 2080;
                  *(std::string::size_type *)((char *)&__p.__r_.__value_.__r.__words[1] + 6) = (std::string::size_type)v68;
                  _os_log_impl( (void *)&_mh_execute_header,  v63,  OS_LOG_TYPE_DEFAULT,  "Findmy usecase %s is asking for duplicates? %s",  (uint8_t *)&__p,  0x16u);
                }

                v9 |= sub_100610C38(v7[5]);
              }

              uint64_t v69 = *(void *)(v7[5] + 8LL);
              uint64_t v70 = *(void *)(v69 + 64);
              uint64_t v71 = *(void *)(v69 + 72);
              while (v70 != v71)
              {
                if (*(_BYTE *)(v70 + 8) == 16 && *(_BYTE *)(v70 + 50) == 1)
                {
                  int v72 = (os_log_s *)qword_1008F75B8;
                  int v9 = 1;
                  if (os_log_type_enabled((os_log_t)qword_1008F75B8, OS_LOG_TYPE_DEFAULT))
                  {
                    __p.__r_.__value_.__r.__words[0] = 0x104000100LL;
                    _os_log_impl( (void *)&_mh_execute_header,  v72,  OS_LOG_TYPE_DEFAULT,  "NearbyInfo asking for duplicates? %d",  (uint8_t *)&__p,  8u);
                  }
                }

                v70 += 96LL;
              }
            }

            id v55 = [obj countByEnumeratingWithState:&v260 objects:v286 count:16];
          }

          while (v55);
        }
      }

      BOOL v73 = (os_log_s *)qword_1008F75B8;
      int v46 = &AMFDRSealingMapCopyLocalDictForClass_ptr;
      if (os_log_type_enabled((os_log_t)qword_1008F75B8, OS_LOG_TYPE_DEFAULT))
      {
        uint64_t v74 = v7[5];
        if (*(char *)(v74 + 255) < 0)
        {
          sub_100024238(buf, *(void **)(v74 + 232), *(void *)(v74 + 240));
          uint64_t v74 = v7[5];
        }

        else
        {
          *(_OWORD *)std::stringbuf::string_type buf = *(_OWORD *)(v74 + 232);
          *(void *)&uint8_t buf[16] = *(void *)(v74 + 248);
        }

        int v75 = buf[23];
        id v76 = *(_BYTE **)buf;
        int v77 = sub_100610C38(v74);
        LODWORD(__p.__r_.__value_.__l.__data_) = 136315906;
        __int128 v78 = buf;
        if (v75 < 0) {
          __int128 v78 = v76;
        }
        *(std::string::size_type *)((char *)__p.__r_.__value_.__r.__words + 4) = (std::string::size_type)v78;
        WORD2(__p.__r_.__value_.__r.__words[1]) = 1024;
        *(_DWORD *)((char *)&__p.__r_.__value_.__r.__words[1] + 6) = v9 & 1;
        WORD1(__p.__r_.__value_.__r.__words[2]) = 1024;
        HIDWORD(__p.__r_.__value_.__r.__words[2]) = v77;
        __int16 v284 = 1024;
        int v285 = v247;
        _os_log_impl( (void *)&_mh_execute_header,  v73,  OS_LOG_TYPE_DEFAULT,  "%s allowDupes:%d, agentAllowDupes:%d, active:%d",  (uint8_t *)&__p,  0x1Eu);
        if ((buf[23] & 0x80000000) != 0) {
          operator delete(*(void **)buf);
        }
      }

      uint64_t v79 = v7[5];
      uint64_t v80 = *(void *)(v79 + 8);
      int v81 = *(unsigned __int8 *)(v80 + 120);
      if (*(_BYTE *)(v80 + 120))
      {
        uint64_t v44 = *(unsigned int *)(v80 + 128);
        uint64_t v45 = *(unsigned int *)(v80 + 132);
        uint64_t v247 = *(unsigned __int8 *)(v80 + 136);
      }

      else
      {
        uint64_t v44 = 0LL;
        uint64_t v45 = 0LL;
      }

      BOOL v82 = (os_log_s *)qword_1008F75B8;
      if (os_log_type_enabled((os_log_t)qword_1008F75B8, OS_LOG_TYPE_DEFAULT))
      {
        else {
          std::stringbuf::string_type __p = *(std::stringbuf::string_type *)(v79 + 232);
        }
        char v83 = &__p;
        if ((__p.__r_.__value_.__s.__size_ & 0x80u) != 0) {
          char v83 = (std::stringbuf::string_type *)__p.__r_.__value_.__r.__words[0];
        }
        *(_DWORD *)std::stringbuf::string_type buf = 136315394;
        *(void *)&uint8_t buf[4] = v83;
        *(_WORD *)&_BYTE buf[12] = 1024;
        *(_DWORD *)&buf[14] = v247;
        _os_log_impl((void *)&_mh_execute_header, v82, OS_LOG_TYPE_DEFAULT, "%s active %d", buf, 0x12u);
      }

      BOOL v242 = (v247 | v242) != 0;
      if (v81)
      {
        if ((_DWORD)v247)
        {
          int v84 = (os_log_s *)qword_1008F75B8;
          if (os_log_type_enabled((os_log_t)qword_1008F75B8, OS_LOG_TYPE_DEFAULT))
          {
            LODWORD(__p.__r_.__value_.__l.__data_) = 67109634;
            HIDWORD(__p.__r_.__value_.__r.__words[0]) = v45;
            LOWORD(__p.__r_.__value_.__r.__words[1]) = 1024;
            *(_DWORD *)((char *)&__p.__r_.__value_.__r.__words[1] + 2) = v44;
            HIWORD(__p.__r_.__value_.__r.__words[1]) = 2082;
            __p.__r_.__value_.__l.__cap_ = (std::string::size_type)"active";
            _os_log_impl( (void *)&_mh_execute_header,  v84,  OS_LOG_TYPE_DEFAULT,  "Daemon is requesting scan parameters %d/%d (%{public}s)",  (uint8_t *)&__p,  0x18u);
          }
        }

        if (sub_100610CA8(v7[5]))
        {
          BOOL v85 = v45 >= v250 || (_DWORD)v45 == 0;
          if (v85) {
            uint64_t v86 = v250;
          }
          else {
            uint64_t v86 = v45;
          }
          uint64_t v250 = v86;
          else {
            uint64_t v88 = v44;
          }
          uint64_t v239 = v88;
        }

        if (*(_BYTE *)(*(void *)(v7[5] + 8LL) + 273LL))
        {
          if (qword_1008D6198 != -1) {
            dispatch_once(&qword_1008D6198, &stru_1008A4058);
          }
          if (sub_100449494((uint64_t)off_1008D6190))
          {
            unsigned int v89 = v231;
            if (v231)
            {
              int v90 = v230;
              if ((int)(v231 / v230) < (int)(v239 / v250))
              {
                int v90 = v250;
                unsigned int v89 = v239;
              }

              unsigned int v231 = v89;
              LODWORD(v230) = v90;
              BYTE4(v230) = 1;
            }

            else
            {
              LODWORD(v230) = v250;
              BYTE4(v230) = 1;
              unsigned int v231 = v239;
            }
          }
        }
      }

      else
      {
        int v91 = *(_DWORD *)(v7[5] + 96LL);
        uint64_t v92 = (int)v238 >= v91 ? v91 : v238;
        uint64_t v238 = v92;
      }

      uint64_t v93 = v7[5];
      if (*(_BYTE *)(*(void *)(v93 + 8) + 3LL)) {
        BYTE4(v237) |= *(_DWORD *)(a1 + 1964) == 2;
      }
      char v94 = sub_10061136C(v93);
      int v95 = v236;
      if (byte_1008F1E9D) {
        int v95 = 0;
      }
      if (v95 == 1) {
        break;
      }
LABEL_141:
      v241 |= v94;
      if ((v240 & 1) != 0) {
        int v240 = sub_100611360(v7[5]);
      }
      else {
        int v240 = 0;
      }
LABEL_144:
      char v102 = v46[391];
      sub_100494958(v7[4], (uint64_t)&__p);
      int size = (char)__p.__r_.__value_.__s.__size_;
      std::string::size_type v104 = __p.__r_.__value_.__r.__words[0];
      id v105 = [v46[391] defaultCStringEncoding];
      if (size >= 0) {
        uint64_t v106 = &__p;
      }
      else {
        uint64_t v106 = (std::stringbuf::string_type *)v104;
      }
      uint64_t v107 = (void *)objc_claimAutoreleasedReturnValue([v102 stringWithCString:v106 encoding:v105]);
      char v108 = v46[391];
      uint64_t v109 = v7[5];
      uint64_t v110 = *(unsigned __int8 *)(*(void *)(v109 + 8) + 3LL);
      uint64_t v111 = sub_100610C38(v109);
      unsigned int v112 = sub_100610DAC(v7[5]);
      id v113 = [v108 stringWithFormat:@"[%@] AP:%d AD:%d(%d/%d) AS:%d RAS:%d DMN:%d FG:%d ADVBF:%d pBT:%d", v107, v110, v111, v45, v44, v247, v112, *(unsigned __int8 *)(v7[5] + 81) == 32, *(unsigned __int8 *)(v7[5] + 81) == 16, sub_100611304(v7[5]), v243 & 1];
      std::string::size_type v114 = (void *)objc_claimAutoreleasedReturnValue(v113);
      [v248 addObject:v114];

LABEL_150:
      if (*(void *)&v264[72])
      {
        *(void *)&v264[80] = *(void *)&v264[72];
        operator delete(*(void **)&v264[72]);
      }

      __p.__r_.__value_.__r.__words[0] = (std::string::size_type)&v264[48];
      sub_10004FEA4((void ***)&__p);
      id v115 = (void *)v7[1];
      uint64_t v10 = v250;
      uint64_t v8 = &AMFDRSealingMapCopyLocalDictForClass_ptr;
      if (v115)
      {
        do
        {
          id v116 = v115;
          id v115 = (void *)*v115;
        }

        while (v115);
      }

      else
      {
        do
        {
          id v116 = (void *)v7[2];
          BOOL v85 = *v116 == (void)v7;
          uint64_t v7 = v116;
        }

        while (!v85);
      }

      uint64_t v7 = v116;
      if (v116 == (void *)(a1 + 2048)) {
        goto LABEL_161;
      }
    }

    if ((sub_1005F4430(a1, v7[5]) & 1) == 0)
    {
      if (!*(_BYTE *)(*(void *)(v7[5] + 8LL) + 200LL))
      {
LABEL_123:
        if (qword_1008D6198 != -1) {
          dispatch_once(&qword_1008D6198, &stru_1008A4058);
        }
        uint64_t v97 = sub_1004494F0();
        if ((v243 & 1) == 0)
        {
LABEL_136:
          int v243 = 0;
          goto LABEL_139;
        }

        int v98 = v97 & 0xFFFFFFFD;
        if ((_DWORD)v97 == 2)
        {
          uint64_t v99 = sub_1002E6E9C();
          uint64_t v97 = (*(uint64_t (**)(uint64_t))(*(void *)v99 + 2648LL))(v99);
          if (v98 == 1) {
            char v100 = 0;
          }
          else {
            char v100 = v97;
          }
          if ((v100 & 1) == 0) {
            goto LABEL_134;
          }
        }

        else if (v98 == 1)
        {
LABEL_134:
          LODWORD(v237) = v232 & v237;
          uint64_t v101 = (os_log_s *)qword_1008F75B8;
          uint64_t v97 = os_log_type_enabled((os_log_t)qword_1008F75B8, OS_LOG_TYPE_DEFAULT);
          int v243 = 0;
          if ((v97 & 1) == 0) {
            goto LABEL_139;
          }
          LOWORD(__p.__r_.__value_.__l.__data_) = 0;
          _os_log_impl( (void *)&_mh_execute_header,  v101,  OS_LOG_TYPE_DEFAULT,  "Scanning Prioritization is not enabled with HIDs connected.",  (uint8_t *)&__p,  2u);
          goto LABEL_136;
        }

        int v243 = 1;
LABEL_139:
        if (*(_BYTE *)(a1 + 4384)) {
          v233 |= sub_100601870(v97, v7[5]);
        }
        goto LABEL_141;
      }

      char v96 = (os_log_s *)qword_1008F75B8;
      if (os_log_type_enabled((os_log_t)qword_1008F75B8, OS_LOG_TYPE_DEFAULT))
      {
        LOWORD(__p.__r_.__value_.__l.__data_) = 0;
        _os_log_impl( (void *)&_mh_execute_header,  v96,  OS_LOG_TYPE_DEFAULT,  "Scanning Prioritization for double boost with allowed use cases.",  (uint8_t *)&__p,  2u);
      }
    }

    int v243 = 1;
    goto LABEL_123;
  }

  BOOL v242 = 0;
  int v243 = 0;
  LOBYTE(v233) = 0;
  char v245 = 0;
  uint64_t v230 = 0LL;
  unsigned int v231 = 0;
  LOBYTE(v9) = 0;
  uint64_t v239 = 300LL;
  uint64_t v10 = 30LL;
  uint64_t v237 = 0LL;
  uint64_t v238 = 3LL;
  int v240 = 1;
  char v241 = 0;
LABEL_161:
  id obja = (id)objc_claimAutoreleasedReturnValue( objc_msgSend( v8[391],  "stringWithFormat:",  @"AD:%d AS:%d MSL:%d (%d/%d) PSV:%d",  v9 & 1,  v242,  v238,  v10,  v239,  *v249));
  unsigned __int8 v117 = (os_log_s *)qword_1008F75B8;
  if (os_log_type_enabled((os_log_t)qword_1008F75B8, OS_LOG_TYPE_DEFAULT))
  {
    uint64_t v118 = *(void *)(a1 + 2056);
    *(_DWORD *)__int128 v264 = 134218242;
    *(void *)&v264[4] = v118;
    *(_WORD *)&v264[12] = 2114;
    *(void *)&v264[14] = obja;
    _os_log_impl( (void *)&_mh_execute_header,  v117,  OS_LOG_TYPE_DEFAULT,  "ScanParams: numScanAgents %lu, combined params %{public}@",  v264,  0x16u);
  }

  BOOL v253 = v245 != 0;
  uint64_t v251 = v10;
  int v119 = [v248 count];
  if (v119 >= -1)
  {
    uint64_t v120 = 0LL;
    int v121 = v119 - 1;
    uint64_t v122 = ((v119 - 1) / 3 + 1);
    int v123 = 2;
    int v124 = 1;
    do
    {
      if (v123 >= v121) {
        int v125 = v121;
      }
      else {
        int v125 = v123;
      }
      BOOL v126 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(v248, "subarrayWithRange:", v120, v125 + v124));
      BOOL v127 = (os_log_s *)qword_1008F75B8;
      if (os_log_type_enabled((os_log_t)qword_1008F75B8, OS_LOG_TYPE_DEFAULT))
      {
        id v128 = (id)objc_claimAutoreleasedReturnValue([v126 componentsJoinedByString:@"|"]);
        *(_DWORD *)__int128 v264 = 138543362;
        *(void *)&v264[4] = v128;
        _os_log_impl((void *)&_mh_execute_header, v127, OS_LOG_TYPE_DEFAULT, "ScanParams: %{public}@", v264, 0xCu);
      }

      v123 += 3;
      v124 -= 3;
      v120 += 3LL;
      --v122;
    }

    while (v122);
  }

  switch((int)v238)
  {
    case 1:
      unsigned __int16 v129 = 64;
      goto LABEL_175;
    case 2:
      unsigned __int16 v129 = 96;
      goto LABEL_175;
    case 3:
      unsigned __int16 v129 = 480;
LABEL_175:
      *((_DWORD *)v249 + 1) = v129 | 0x300000;
      break;
    case 4:
      *((_DWORD *)v249 + 1) = 3147273;
      *__int128 v249 = 1;
      break;
    default:
      break;
  }

  if (v242) {
    *__int128 v249 = 0;
  }
  unsigned int v130 = *((unsigned __int16 *)v249 + 2);
  unsigned int v131 = *((unsigned __int16 *)v249 + 3);
  if ((int)(v239 / v251) <= (int)(v130 / v131))
  {
    unsigned int v130 = (int)((double)(int)v239 / 0.625);
    *((_WORD *)v249 + 2) = v130;
    unsigned int v131 = (int)((double)(int)v251 / 0.625);
    *((_WORD *)v249 + 3) = v131;
  }

  LODWORD(__p.__r_.__value_.__l.__data_) = 100;
  BOOL v132 = (v230 & 0x100000000LL) != 0 && v231 / v230 == v130 / v131;
  if (qword_1008D6198 != -1) {
    dispatch_once(&qword_1008D6198, &stru_1008A4058);
  }
  if (!sub_100449204(off_1008D6190))
  {
    unsigned int v133 = 100 * v131 / v130;
    if (v133 < 0x32)
    {
      if (v133 < 0x21) {
        goto LABEL_197;
      }
      int v139 = (os_log_s *)qword_1008F75B8;
      if (os_log_type_enabled((os_log_t)qword_1008F75B8, OS_LOG_TYPE_INFO))
      {
        int v137 = v249;
        LOWORD(v140) = *((_WORD *)v249 + 3);
        LOWORD(v141) = *((_WORD *)v249 + 2);
        *(_DWORD *)__int128 v264 = 134219264;
        *(double *)&v264[4] = (double)v140 * 0.625;
        *(_WORD *)&v264[12] = 2048;
        *(double *)&v264[14] = (double)v141 * 0.625;
        *(_WORD *)&v264[22] = 1024;
        *(_DWORD *)&v264[24] = v133;
        *(_WORD *)&v264[28] = 2048;
        *(void *)&v264[30] = 0x403E000000000000LL;
        *(_WORD *)&v264[38] = 2048;
        *(void *)&v264[40] = 0x4056800000000000LL;
        *(_WORD *)&v264[48] = 1024;
        *(_DWORD *)&v264[50] = v238;
        _os_log_impl( (void *)&_mh_execute_header,  v139,  OS_LOG_TYPE_INFO,  "Limiting scan duty cycle based on other activities from %.2fms/%.2fms (scanPercentage %d)to %.2fms/%.2fms minScanLevel %d",  v264,  0x36u);
        __int16 v138 = 144;
        goto LABEL_196;
      }

      __int16 v138 = 144;
    }

    else
    {
      id v134 = (os_log_s *)qword_1008F75B8;
      if (os_log_type_enabled((os_log_t)qword_1008F75B8, OS_LOG_TYPE_INFO))
      {
        int v137 = v249;
        LOWORD(v135) = *((_WORD *)v249 + 3);
        LOWORD(v136) = *((_WORD *)v249 + 2);
        *(_DWORD *)__int128 v264 = 134219264;
        *(double *)&v264[4] = (double)v135 * 0.625;
        *(_WORD *)&v264[12] = 2048;
        *(double *)&v264[14] = (double)v136 * 0.625;
        *(_WORD *)&v264[22] = 1024;
        *(_DWORD *)&v264[24] = v133;
        *(_WORD *)&v264[28] = 2048;
        *(void *)&v264[30] = 0x403E000000000000LL;
        *(_WORD *)&v264[38] = 2048;
        *(void *)&v264[40] = 0x404E000000000000LL;
        *(_WORD *)&v264[48] = 1024;
        *(_DWORD *)&v264[50] = v238;
        _os_log_impl( (void *)&_mh_execute_header,  v134,  OS_LOG_TYPE_INFO,  "Limiting scan duty cycle based on other activities from %.2fms/%.2fms (scanPercentage %d)to %.2fms/%.2fms minScanLevel %d",  v264,  0x36u);
        __int16 v138 = 96;
LABEL_196:
        *((_WORD *)v137 + 2) = v138;
        *((_WORD *)v137 + 3) = 48;
        goto LABEL_197;
      }

      __int16 v138 = 96;
    }

    int v137 = v249;
    goto LABEL_196;
  }

void sub_100607720( _Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20, uint64_t a21, uint64_t a22, uint64_t a23, uint64_t a24, uint64_t a25, uint64_t a26, uint64_t a27, uint64_t a28, uint64_t a29, uint64_t a30, uint64_t a31, uint64_t a32, uint64_t a33, uint64_t a34, uint64_t a35, uint64_t a36, uint64_t a37, uint64_t a38, uint64_t a39, uint64_t a40, uint64_t a41, uint64_t a42, uint64_t a43, uint64_t a44, void *a45, uint64_t a46, void *a47, uint64_t a48, uint64_t a49, uint64_t a50,uint64_t a51,uint64_t a52,void *a53)
{
  _Unwind_Resume(a1);
}

uint64_t sub_100607AD0(uint64_t a1, uint64_t a2)
{
  return (*(uint64_t (**)(uint64_t, void))(*(void *)a2 + 64LL))(a2, *(void *)(a1 + 32));
}

uint64_t sub_100607AE8(uint64_t a1, unsigned int a2, int a3)
{
  uint64_t result = 7LL;
  if (a2 && a3)
  {
    unsigned int v4 = 100 * a3 / a2;
    if (v4 <= 0x4B)
    {
      if (v4 <= 0x32)
      {
        if (v4 <= 0x22)
        {
          if (v4 <= 0xA)
          {
            if (v4 <= 4)
            {
              if (v4 > 1) {
                return 5LL;
              }
              else {
                return 6LL;
              }
            }

            else
            {
              return 4LL;
            }
          }

          else
          {
            return 3LL;
          }
        }

        else
        {
          return 2LL;
        }
      }

      else
      {
        return 1LL;
      }
    }

    else
    {
      return 0LL;
    }
  }

  return result;
}

void sub_100607B60(uint64_t a1)
{
  uint64_t v108 = *(void *)(a1 + 32);
  if (*(_BYTE *)(v108 + 2248))
  {
    uint64_t v2 = sub_1002E6E9C();
    int v103 = (*(uint64_t (**)(uint64_t))(*(void *)v2 + 2768LL))(v2);
  }

  else
  {
    int v103 = 0;
  }

  if ([*(id *)(v108 + 4368) count] && *(_BYTE *)(a1 + 40))
  {
    if (os_log_type_enabled((os_log_t)qword_1008F75B8, OS_LOG_TYPE_DEBUG)) {
      sub_10069E0D0();
    }
    __int128 v131 = 0u;
    __int128 v132 = 0u;
    __int128 v129 = 0u;
    __int128 v130 = 0u;
    id obj = *(id *)(v108 + 4368);
    id v3 = [obj countByEnumeratingWithState:&v129 objects:v142 count:16];
    if (v3)
    {
      uint64_t v4 = *(void *)v130;
LABEL_10:
      uint64_t v5 = 0LL;
      while (1)
      {
        if (*(void *)v130 != v4) {
          objc_enumerationMutation(obj);
        }
        uint64_t v6 = *(void **)(*((void *)&v129 + 1) + 8 * v5);
        uint64_t v7 = sub_1002E6E9C();
        id v8 = v6;
        if ((*(unsigned int (**)(uint64_t, id, void, uint64_t))(*(void *)v7 + 600))( v7,  [v8 bytes],  (unsigned __int16)objc_msgSend(v8, "length"),  240))
        {
          break;
        }

        if (v3 == (id)++v5)
        {
          id v3 = [obj countByEnumeratingWithState:&v129 objects:v142 count:16];
          if (v3) {
            goto LABEL_10;
          }
          break;
        }
      }
    }

    uint64_t v9 = sub_1002E6E9C();
    (*(void (**)(uint64_t, uint64_t))(*(void *)v9 + 624LL))(v9, 1LL);
    char v10 = 1;
  }

  else
  {
    char v10 = 0;
  }

  uint64_t v11 = *(void *)(v108 + 4320);
  if (v11)
  {
    uint64_t v12 = (os_log_s *)qword_1008F75B8;
    if (os_log_type_enabled((os_log_t)qword_1008F75B8, OS_LOG_TYPE_DEBUG)) {
      sub_10069E068(v11, v12, v13);
    }
    if (v103)
    {
      uint64_t v14 = v108;
      uint64_t v15 = malloc(8LL * *(void *)(v108 + 4320));
    }

    else
    {
      uint64_t v15 = 0LL;
      uint64_t v14 = v108;
    }

    double v16 = *(void **)(v14 + 4304);
    double v17 = (void *)(v14 + 4312);
    if (v16 != v17)
    {
      int v18 = 0;
      if (v15) {
        int v19 = v103;
      }
      else {
        int v19 = 0;
      }
      do
      {
        if (v19)
        {
          v15[v18++] = v16[4];
        }

        else
        {
          uint64_t v20 = sub_1002E6E9C();
          (*(void (**)(uint64_t, void))(*(void *)v20 + 760LL))(v20, v16[4]);
        }

        __int128 v21 = (void *)v16[1];
        if (v21)
        {
          do
          {
            __int128 v22 = v21;
            __int128 v21 = (void *)*v21;
          }

          while (v21);
        }

        else
        {
          do
          {
            __int128 v22 = (void *)v16[2];
            BOOL v23 = *v22 == (void)v16;
            double v16 = v22;
          }

          while (!v23);
        }

        double v16 = v22;
      }

      while (v22 != v17);
    }

    char v24 = v103 ^ 1;
    if (!v15) {
      char v24 = 1;
    }
    if ((v24 & 1) == 0)
    {
      unint64_t v25 = *(void *)(v108 + 4320);
      if (v25)
      {
        uint64_t v26 = 0LL;
        int v27 = 0;
        do
        {
          int v28 = v25 - v27;
          if (v28 >= 25) {
            int v29 = 25;
          }
          else {
            int v29 = v28;
          }
          uint64_t v30 = sub_1002E6E9C();
          (*(void (**)(uint64_t, void, void *))(*(void *)v30 + 784LL))( v30,  v29,  &v15[v26]);
          v27 += v29;
          uint64_t v26 = v27;
          unint64_t v25 = *(void *)(v108 + 4320);
        }

        while (v25 > v27);
      }

      free(v15);
    }

    char v10 = 1;
  }

  if (os_log_type_enabled((os_log_t)qword_1008F75B8, OS_LOG_TYPE_DEBUG)) {
    sub_10069E000();
  }
  if ([*(id *)(v108 + 4352) count])
  {
    if (v103) {
      uint64_t v107 = (char *)malloc(62 * (void)[*(id *)(v108 + 4352) count]);
    }
    else {
      uint64_t v107 = 0LL;
    }
    __int128 v127 = 0u;
    __int128 v128 = 0u;
    __int128 v125 = 0u;
    __int128 v126 = 0u;
    id obja = *(id *)(v108 + 4352);
    id v31 = [obja countByEnumeratingWithState:&v125 objects:v141 count:16];
    if (v31)
    {
      int v109 = 0;
      int v32 = v103;
      if (!v107) {
        int v32 = 0;
      }
      int v104 = v32;
      uint64_t v105 = *(void *)v126;
LABEL_58:
      uint64_t v33 = 0LL;
      id v106 = v31;
      while (1)
      {
        if (*(void *)v126 != v105) {
          objc_enumerationMutation(obja);
        }
        uint64_t v117 = v33;
        int v34 = *(void **)(*((void *)&v125 + 1) + 8 * v33);
        *(_OWORD *)std::stringbuf::string_type buf = 0uLL;
        id v35 = objc_claimAutoreleasedReturnValue([v34 objectForKeyedSubscript:@"data"]);
        id v36 = [v35 bytes];
        int v37 = (void *)objc_claimAutoreleasedReturnValue([v34 objectForKeyedSubscript:@"data"]);
        sub_10056AB04(buf, v36, (size_t)[v37 length]);

        __int128 v136 = 0uLL;
        id v38 = objc_claimAutoreleasedReturnValue([v34 objectForKeyedSubscript:@"mask"]);
        id v39 = [v38 bytes];
        unsigned int v40 = (void *)objc_claimAutoreleasedReturnValue([v34 objectForKeyedSubscript:@"mask"]);
        sub_10056AB04(&v136, v39, (size_t)[v40 length]);

        uint64_t v41 = (void *)objc_claimAutoreleasedReturnValue([v34 objectForKeyedSubscript:@"rssi"]);
        unsigned __int8 v42 = [v41 intValue];

        id v43 = (void *)objc_claimAutoreleasedReturnValue([v34 objectForKeyedSubscript:@"puckType"]);
        unsigned __int8 v115 = [v43 unsignedIntValue];

        uint64_t v44 = (void *)objc_claimAutoreleasedReturnValue([v34 objectForKeyedSubscript:@"bypassFilterDuplicate"]);
        unsigned __int8 v114 = [v44 unsignedIntValue];

        uint64_t v45 = (void *)objc_claimAutoreleasedReturnValue([v34 objectForKeyedSubscript:@"targetCore"]);
        unsigned __int8 v113 = [v45 unsignedIntValue];

        int v46 = (void *)objc_claimAutoreleasedReturnValue([v34 objectForKeyedSubscript:@"rssithresholdOrder"]);
        unsigned __int8 v47 = [v46 unsignedIntValue];

        int v48 = (void *)objc_claimAutoreleasedReturnValue([v34 objectForKeyedSubscript:@"matchAllDevices"]);
        unsigned __int8 v49 = [v48 unsignedIntValue];

        unsigned int v50 = (void *)objc_claimAutoreleasedReturnValue([v34 objectForKeyedSubscript:@"address"]);
        id v51 = [v50 unsignedLongLongValue];

        BOOL v52 = (void *)objc_claimAutoreleasedReturnValue([v34 objectForKeyedSubscript:@"report127dBm"]);
        unsigned int v53 = [v52 unsignedIntValue];
        BOOL v54 = v53 != 0;

        id v55 = (void *)objc_claimAutoreleasedReturnValue([v34 objectForKeyedSubscript:@"report27dBm"]);
        unsigned int v56 = [v55 unsignedIntValue];
        BOOL v57 = v56 != 0;

        if (v104)
        {
          unsigned int v58 = (unsigned __int8 *)&v107[62 * v109];
          *(_OWORD *)(v58 + 7) = 0u;
          *(_WORD *)(v58 + 55) = 0;
          *(_OWORD *)(v58 + 39) = 0u;
          *(_OWORD *)(v58 + 23) = 0u;
          uint64_t v59 = (const void *)sub_10056AAF0((uint64_t)&v136);
          else {
            size_t v60 = 25LL;
          }
          memcpy(v58 + 32, v59, v60);
          unsigned int v68 = (const void *)sub_10056AAF0((uint64_t)buf);
          if ((unint64_t)sub_10056AAD8((uint64_t)buf) <= 0x19)
          {
            size_t v70 = sub_10056AAD8((uint64_t)buf);
            unsigned __int8 v69 = v42;
          }

          else
          {
            unsigned __int8 v69 = v42;
            size_t v70 = 25LL;
          }

          memcpy(v58 + 7, v68, v70);
          *unsigned int v58 = v49;
          uint64_t v71 = &v107[62 * v109];
          *(_DWORD *)(v71 + 1) = 0;
          *(_WORD *)(v71 + 5) = 0;
          v71[57] = v115;
          v71[58] = v69;
          v71[59] = v114;
          v71[60] = v113;
          char v72 = v47 | 2;
          if (v53) {
            char v72 = v47;
          }
          if (!v56) {
            v72 |= 4u;
          }
          v71[61] = v72;
          ++v109;
          int v67 = 9;
        }

        else
        {
          signed __int8 v61 = v42;
          uint64_t v62 = sub_1002E6E9C();
          uint64_t v63 = sub_10056AAF0((uint64_t)buf);
          unsigned __int16 v64 = sub_10056AAD8((uint64_t)buf);
          uint64_t v65 = sub_10056AAF0((uint64_t)&v136);
          unsigned __int16 v66 = sub_10056AAD8((uint64_t)&v136);
          BYTE4(v102) = v57;
          BYTE3(v102) = v54;
          BYTE2(v102) = v47;
          BYTE1(v102) = v113;
          LOBYTE(v102) = v114;
          if ((*(unsigned int (**)(uint64_t, uint64_t, void, uint64_t, void, void, void, void, id, uint64_t))(*(void *)v62 + 672LL))( v62,  v63,  v64,  v65,  v66,  v61,  v115,  v49,  v51,  v102))
          {
            if (os_log_type_enabled((os_log_t)qword_1008F75B8, OS_LOG_TYPE_ERROR)) {
              sub_10069DFD4(&v123, v124);
            }
            int v67 = 8;
          }

          else
          {
            int v67 = 0;
          }
        }

        *(void *)&__int128 v136 = &off_10087FAA8;
        if (*((void *)&v136 + 1)) {
          sub_1002CD254(*((unsigned int **)&v136 + 1));
        }
        *(void *)std::stringbuf::string_type buf = &off_10087FAA8;
        if (*(void *)&buf[8]) {
          sub_1002CD254(*(unsigned int **)&buf[8]);
        }
        if (v67 != 9 && v67) {
          break;
        }
        uint64_t v33 = v117 + 1;
        if (v106 == (id)(v117 + 1))
        {
          id v31 = [obja countByEnumeratingWithState:&v125 objects:v141 count:16];
          if (v31) {
            goto LABEL_58;
          }
          break;
        }
      }
    }

    if (os_log_type_enabled((os_log_t)qword_1008F75B8, OS_LOG_TYPE_DEBUG)) {
      sub_10069DAD0();
    }
    uint64_t v73 = sub_1002E6E9C();
    (*(void (**)(uint64_t, void))(*(void *)v73 + 744LL))(v73, *(unsigned int *)(v108 + 4376));
    char v74 = v103 ^ 1;
    if (!v107) {
      char v74 = 1;
    }
    if ((v74 & 1) == 0)
    {
      if ([*(id *)(v108 + 4352) count])
      {
        uint64_t v75 = 0LL;
        int v76 = 0;
        do
        {
          else {
            int v77 = 4;
          }
          uint64_t v78 = sub_1002E6E9C();
          (*(void (**)(uint64_t, void, uint64_t, char *))(*(void *)v78 + 680LL))( v78,  v77,  25LL,  &v107[62 * v75]);
          v76 += v77;
          uint64_t v75 = v76;
        }

        while ((unint64_t)[*(id *)(v108 + 4352) count] > v76);
      }

      free(v107);
    }

    char v10 = 1;
  }

  if (os_log_type_enabled((os_log_t)qword_1008F75B8, OS_LOG_TYPE_DEBUG)) {
    sub_10069DF6C();
  }
  if (*(void *)(v108 + 4344) || [*(id *)(v108 + 4360) count])
  {
    uint64_t v79 = sub_1002E6E9C();
    (*(void (**)(uint64_t, uint64_t))(*(void *)v79 + 392LL))(v79, 1LL);
    uint64_t v80 = *(void **)(v108 + 4328);
    uint64_t v118 = (void *)(v108 + 4336);
    if (v80 != (void *)(v108 + 4336))
    {
      while (1)
      {
        uint64_t v81 = sub_1002E6E9C();
        uint64_t v82 = (uint64_t)v80 + 28;
        __int128 v139 = *(_OWORD *)((char *)v80 + 28);
        int v140 = *((_DWORD *)v80 + 11);
        if ((*(unsigned int (**)(uint64_t, __int128 *, void, uint64_t, uint64_t, uint64_t))(*(void *)v81 + 408LL))( v81,  &v139,  0LL,  169LL,  1LL,  1LL))
        {
          break;
        }

        char v83 = (void *)v80[1];
        if (v83)
        {
          do
          {
            int v84 = v83;
            char v83 = (void *)*v83;
          }

          while (v83);
        }

        else
        {
          do
          {
            int v84 = (void *)v80[2];
            BOOL v23 = *v84 == (void)v80;
            uint64_t v80 = v84;
          }

          while (!v23);
        }

        uint64_t v80 = v84;
        if (v84 == v118) {
          goto LABEL_114;
        }
      }

      BOOL v85 = (os_log_s *)qword_1008F75B8;
      if (os_log_type_enabled((os_log_t)qword_1008F75B8, OS_LOG_TYPE_ERROR)) {
        sub_10069DEC0(v82, v85);
      }
    }

LABEL_114:
    __int128 v121 = 0u;
    __int128 v122 = 0u;
    __int128 v119 = 0u;
    __int128 v120 = 0u;
    id objb = *(id *)(v108 + 4360);
    id v86 = [objb countByEnumeratingWithState:&v119 objects:v138 count:16];
    if (v86)
    {
      uint64_t v116 = *(void *)v120;
      while (2)
      {
        for (uint64_t i = 0LL; i != v86; uint64_t i = (char *)i + 1)
        {
          if (*(void *)v120 != v116) {
            objc_enumerationMutation(objb);
          }
          uint64_t v88 = *(void **)(*((void *)&v119 + 1) + 8LL * (void)i);
          __int128 v136 = 0uLL;
          int v137 = 0;
          id v89 = objc_claimAutoreleasedReturnValue([v88 objectForKeyedSubscript:@"uuid"]);
          int v90 = (int8x16_t *)[v89 bytes];
          int v91 = (void *)objc_claimAutoreleasedReturnValue([v88 objectForKeyedSubscript:@"uuid"]);
          sub_1006343C4((uint64_t)&v136, v90, [v91 length]);

          if (v118 == (void *)sub_10038DAA8(v108 + 4328, (unsigned __int8 *)&v136))
          {
            uint64_t v93 = sub_1002E6E9C();
            __int128 v134 = v136;
            int v135 = v137;
            char v94 = (void *)objc_claimAutoreleasedReturnValue([v88 objectForKeyedSubscript:@"rssi"]);
            unsigned __int8 v95 = [v94 intValue];
            char v96 = (void *)objc_claimAutoreleasedReturnValue([v88 objectForKeyedSubscript:@"data"]);
            unsigned __int8 v97 = [v96 length];
            id v98 = objc_claimAutoreleasedReturnValue([v88 objectForKeyedSubscript:@"data"]);
            id v99 = [v98 bytes];
            id v100 = objc_claimAutoreleasedReturnValue([v88 objectForKeyedSubscript:@"mask"]);
            LOBYTE(v101) = 1;
            LODWORD(v99) = (*(uint64_t (**)(uint64_t, __int128 *, void, void, uint64_t, void, id, id, int))(*(void *)v93 + 416))( v93,  &v134,  0,  v95,  1,  v97,  v99,  [v100 bytes],  v101);

            if ((_DWORD)v99)
            {
              if (os_log_type_enabled((os_log_t)qword_1008F75B8, OS_LOG_TYPE_ERROR))
              {
                sub_1006344B4((uint64_t)&v136, buf);
                sub_10069DA38();
              }

              goto LABEL_128;
            }
          }

          else
          {
            uint64_t v92 = (os_log_s *)qword_1008F75B8;
            if (os_log_type_enabled((os_log_t)qword_1008F75B8, OS_LOG_TYPE_INFO))
            {
              *(_DWORD *)std::stringbuf::string_type buf = 138412290;
              *(void *)&uint8_t buf[4] = v88;
              _os_log_impl( (void *)&_mh_execute_header,  v92,  OS_LOG_TYPE_INFO,  "Skip adding %@ as its uuid was already added without blob/mask",  buf,  0xCu);
            }
          }
        }

        id v86 = [objb countByEnumeratingWithState:&v119 objects:v138 count:16];
        if (v86) {
          continue;
        }
        break;
      }
    }

void sub_100608894( _Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, void *a18)
{
}

void sub_100608A2C(uint64_t a1, char a2)
{
  if (os_log_type_enabled((os_log_t)qword_1008F75B8, OS_LOG_TYPE_DEBUG)) {
    sub_10069E138();
  }
  uint64_t v4 = sub_100404FE8();
  v5[0] = _NSConcreteStackBlock;
  v5[1] = 3221225472LL;
  void v5[2] = sub_100608AC8;
  v5[3] = &unk_1008800D8;
  v5[4] = a1;
  char v6 = a2;
  sub_100405384(v4, v5);
}

uint64_t sub_100608AC8(uint64_t a1)
{
  uint64_t v2 = *(void *)(a1 + 32);
  if (os_log_type_enabled((os_log_t)qword_1008F75B8, OS_LOG_TYPE_DEBUG)) {
    sub_10069E1B4();
  }
  sub_1005E4988(v2);
  *(_BYTE *)(v2 + 4296) = 0;
  *(_BYTE *)(v2 + 1842) = *(_BYTE *)(a1 + 40);
  return sub_1005E3C94(v2, 1LL);
}

void sub_100608B40(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5)
{
  if (a2)
  {
    uint64_t v6 = *(void *)(a2 + 8);
    if (*(_BYTE *)(v6 + 288))
    {
      char v10 = (void *)objc_claimAutoreleasedReturnValue(+[NSMutableDictionary dictionary](&OBJC_CLASS___NSMutableDictionary, "dictionary"));
      [v10 setObject:@"Discovery" forKeyedSubscript:@"ScanType"];
      int v11 = *(_DWORD *)(*(void *)(a2 + 8) + 168LL);
      uint64_t v12 = +[NSString stringWithUTF8String:](&OBJC_CLASS___NSString, "stringWithUTF8String:", sub_1005E2B18(v11));
      uint64_t v13 = (void *)objc_claimAutoreleasedReturnValue(v12);
      [v10 setObject:v13 forKeyedSubscript:@"CBUseCase"];

      id v49 = *(id *)(*(void *)(a2 + 8) + 152LL);
      uint64_t v14 = (void *)objc_claimAutoreleasedReturnValue([v49 allObjects]);
      uint64_t v15 = (void *)objc_claimAutoreleasedReturnValue(+[NSArray arrayWithArray:](&OBJC_CLASS___NSArray, "arrayWithArray:", v14));

      double v16 = (void *)objc_claimAutoreleasedReturnValue([v15 sortedArrayUsingSelector:"compare:"]);
      double v17 = (void *)objc_claimAutoreleasedReturnValue([v16 componentsJoinedByString:@","]);
      [v10 setObject:v17 forKeyedSubscript:@"BundleID"];

      uint64_t v18 = sub_1002E6BF0();
      int v19 = +[NSNumber numberWithBool:]( &OBJC_CLASS___NSNumber,  "numberWithBool:",  (*(uint64_t (**)(uint64_t))(*(void *)v18 + 840LL))(v18));
      uint64_t v20 = (void *)objc_claimAutoreleasedReturnValue(v19);
      [v10 setObject:v20 forKeyedSubscript:@"IsFWBased"];

      [v10 setObject:@"NotApplicable" forKeyedSubscript:@"InitialConnScanParamsType"];
      __int128 v21 = (void *)objc_claimAutoreleasedReturnValue( +[NSNumber numberWithBool:]( &OBJC_CLASS___NSNumber,  "numberWithBool:",  *(unsigned __int8 *)(v6 + 290)));
      [v10 setObject:v21 forKeyedSubscript:@"IsWiFiCoexCriticalProtected"];

      __int128 v22 = (void *)objc_claimAutoreleasedReturnValue( +[NSNumber numberWithBool:]( &OBJC_CLASS___NSNumber,  "numberWithBool:",  *(unsigned __int8 *)(v6 + 291)));
      [v10 setObject:v22 forKeyedSubscript:@"IsBTAudioProtected"];

      BOOL v23 = (void *)objc_claimAutoreleasedReturnValue( +[NSNumber numberWithBool:]( &OBJC_CLASS___NSNumber,  "numberWithBool:",  *(unsigned __int8 *)(v6 + 292)));
      [v10 setObject:v23 forKeyedSubscript:@"IsWiFi2_4GHzProtected"];

      if ((v11 - 65548) < 2)
      {
        uint64_t v24 = 63LL;
      }

      else if (v11 == 268)
      {
        uint64_t v24 = -1LL;
      }

      else if (v11 == 265)
      {
        uint64_t v24 = 111LL;
      }

      else
      {
        uint64_t v24 = 0LL;
      }

      unint64_t v25 = (void *)objc_claimAutoreleasedReturnValue( +[NSNumber numberWithUnsignedLongLong:]( &OBJC_CLASS___NSNumber,  "numberWithUnsignedLongLong:",  v24));
      [v10 setObject:v25 forKeyedSubscript:@"WiFiCriticalDefinition"];

      uint64_t v26 = (void *)objc_claimAutoreleasedReturnValue( +[NSNumber numberWithUnsignedLongLong:]( &OBJC_CLASS___NSNumber,  "numberWithUnsignedLongLong:",  *(void *)(v6 + 304)));
      [v10 setObject:v26 forKeyedSubscript:@"ScanDurationReqMsec"];

      int v27 = (void *)objc_claimAutoreleasedReturnValue( +[NSNumber numberWithUnsignedLongLong:]( &OBJC_CLASS___NSNumber,  "numberWithUnsignedLongLong:",  *(void *)(v6 + 296)));
      [v10 setObject:v27 forKeyedSubscript:@"ActualScanTimeReqMsec"];

      int v28 = (void *)objc_claimAutoreleasedReturnValue( +[NSNumber numberWithUnsignedLongLong:]( &OBJC_CLASS___NSNumber,  "numberWithUnsignedLongLong:",  *(void *)(v6 + 296)));
      [v10 setObject:v28 forKeyedSubscript:@"ActualScanTimeMCReqMsec"];

      int v29 = (void *)objc_claimAutoreleasedReturnValue(+[NSNumber numberWithUnsignedLongLong:](&OBJC_CLASS___NSNumber, "numberWithUnsignedLongLong:", a5));
      [v10 setObject:v29 forKeyedSubscript:@"ScanDurationMsec"];

      uint64_t v30 = (void *)objc_claimAutoreleasedReturnValue(+[NSNumber numberWithUnsignedLongLong:](&OBJC_CLASS___NSNumber, "numberWithUnsignedLongLong:", a3));
      [v10 setObject:v30 forKeyedSubscript:@"ActualScanTimeMsec"];

      id v31 = (void *)objc_claimAutoreleasedReturnValue(+[NSNumber numberWithUnsignedLongLong:](&OBJC_CLASS___NSNumber, "numberWithUnsignedLongLong:", a4));
      [v10 setObject:v31 forKeyedSubscript:@"ActualScanTimeMCMsec"];

      unint64_t v32 = *(void *)(v6 + 304);
      if (v32) {
        unint64_t v33 = (100 * a5) / v32;
      }
      else {
        LODWORD(v33) = 0;
      }
      else {
        uint64_t v34 = 100LL;
      }
      unint64_t v35 = *(void *)(v6 + 296);
      if (v35)
      {
        unint64_t v36 = (100 * a3) / v35;
        BOOL v37 = v36 > 0x63;
        else {
          uint64_t v38 = 100LL;
        }
        unint64_t v39 = (100 * a4) / v35;
      }

      else
      {
        uint64_t v38 = 0LL;
        BOOL v37 = 0LL;
        LODWORD(v39) = 0;
      }

      else {
        uint64_t v40 = 100LL;
      }
      uint64_t v41 = (void *)objc_claimAutoreleasedReturnValue(+[NSNumber numberWithUnsignedInt:](&OBJC_CLASS___NSNumber, "numberWithUnsignedInt:", v34));
      [v10 setObject:v41 forKeyedSubscript:@"ScanDurationMsecPercentage"];

      unsigned __int8 v42 = (void *)objc_claimAutoreleasedReturnValue(+[NSNumber numberWithUnsignedInt:](&OBJC_CLASS___NSNumber, "numberWithUnsignedInt:", v38));
      [v10 setObject:v42 forKeyedSubscript:@"ActualScanTimeMsecPercentage"];

      id v43 = (void *)objc_claimAutoreleasedReturnValue(+[NSNumber numberWithUnsignedInt:](&OBJC_CLASS___NSNumber, "numberWithUnsignedInt:", v40));
      [v10 setObject:v43 forKeyedSubscript:@"ActualScanTimeMCMsecPercentage"];

      uint64_t v44 = (void *)objc_claimAutoreleasedReturnValue(+[NSNumber numberWithBool:](&OBJC_CLASS___NSNumber, "numberWithBool:", v33 > 0x63));
      [v10 setObject:v44 forKeyedSubscript:@"HasScanDurationReqMet"];

      uint64_t v45 = (void *)objc_claimAutoreleasedReturnValue(+[NSNumber numberWithBool:](&OBJC_CLASS___NSNumber, "numberWithBool:", v37));
      [v10 setObject:v45 forKeyedSubscript:@"HasActualScanTimeReqMet"];

      int v46 = (void *)objc_claimAutoreleasedReturnValue(+[NSNumber numberWithBool:](&OBJC_CLASS___NSNumber, "numberWithBool:", v39 > 0x63));
      [v10 setObject:v46 forKeyedSubscript:@"HasActualScanTimeMCReqMet"];

      unsigned __int8 v47 = (os_log_s *)qword_1008F75B8;
      if (os_log_type_enabled((os_log_t)qword_1008F75B8, OS_LOG_TYPE_DEFAULT))
      {
        *(_DWORD *)std::stringbuf::string_type buf = 138543362;
        id v51 = v10;
        _os_log_impl( (void *)&_mh_execute_header,  v47,  OS_LOG_TYPE_DEFAULT,  "Sending CloseLoopScanningStats :%{public}@",  buf,  0xCu);
      }

      uint64_t v48 = sub_1002E8D94();
      (*(void (**)(uint64_t, void *))(*(void *)v48 + 384LL))(v48, v10);
    }
  }

void sub_1006090FC( _Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, void *a10)
{
  _Unwind_Resume(a1);
}

void sub_1006091B8(uint64_t a1)
{
  int v2 = *(_DWORD *)(a1 + 72);
  if (v2 == 2) {
    int v3 = 20;
  }
  else {
    int v3 = 1;
  }
  if (v2 == 1) {
    int v4 = 342;
  }
  else {
    int v4 = v3;
  }
  v20[0] = _NSConcreteStackBlock;
  void v20[2] = sub_10060938C;
  uint64_t v20[3] = &unk_1008A3DB8;
  uint64_t v6 = *(void *)(a1 + 32);
  uint64_t v5 = *(void *)(a1 + 40);
  v20[1] = 3221225472LL;
  int v20[4] = v5;
  int v22 = v4;
  __int128 v21 = *(_OWORD *)(a1 + 48);
  sub_1005EBB90((os_unfair_lock_s *)(v6 + 1872), v20);
  id v8 = *(void **)(v6 + 2048);
  if (v8)
  {
    unint64_t v9 = *(void *)(a1 + 40);
    char v10 = (void *)(v6 + 2048);
    do
    {
      unint64_t v11 = v8[4];
      BOOL v12 = v11 >= v9;
      if (v11 >= v9) {
        uint64_t v13 = v8;
      }
      else {
        uint64_t v13 = v8 + 1;
      }
      if (v12) {
        char v10 = v8;
      }
      id v8 = (void *)*v13;
    }

    while (*v13);
    if (v10 != (void *)(v6 + 2048) && v9 >= v10[4])
    {
      uint64_t v14 = v10[5];
      if (*(_DWORD *)(a1 + 72) == 1)
      {
        sub_100608B40(v7, v14, *(void *)(a1 + 48), *(void *)(a1 + 56), *(void *)(a1 + 64));
        unint64_t v9 = *(void *)(a1 + 40);
      }

      uint64_t v15 = (os_log_s *)qword_1008F75B8;
      if (os_log_type_enabled((os_log_t)qword_1008F75B8, OS_LOG_TYPE_DEFAULT))
      {
        sub_100494958(v9, (uint64_t)__p);
        if (v19 >= 0) {
          double v16 = __p;
        }
        else {
          double v16 = (void **)__p[0];
        }
        *(_DWORD *)std::stringbuf::string_type buf = 136446210;
        uint64_t v24 = v16;
        _os_log_impl((void *)&_mh_execute_header, v15, OS_LOG_TYPE_DEFAULT, "stopping scan for %{public}s", buf, 0xCu);
        if (v19 < 0) {
          operator delete(__p[0]);
        }
        unint64_t v9 = *(void *)(a1 + 40);
      }

      uint64_t v17 = *(void *)(v14 + 8);
      *(_DWORD *)(v17 + 18_Block_object_dispose(va, 8) = 0;
      *(_DWORD *)(v17 + 192) = 0;
      sub_1005F24EC(v6, v9, 1LL, 1LL, 0LL);
    }
  }

uint64_t sub_10060938C(uint64_t a1, uint64_t a2)
{
  return (*(uint64_t (**)(uint64_t, void, void, void, void))(*(void *)a2 + 56LL))( a2,  *(void *)(a1 + 32),  *(unsigned int *)(a1 + 56),  *(void *)(a1 + 40),  *(void *)(a1 + 48));
}

uint64_t sub_1006093AC(uint64_t a1, unsigned int a2)
{
  if (*(_DWORD *)(a1 + 168) == a2) {
    return 1LL;
  }
  int v3 = *(void **)(a1 + 176);
  if (!v3) {
    return 0LL;
  }
  __int128 v14 = 0u;
  __int128 v15 = 0u;
  __int128 v12 = 0u;
  __int128 v13 = 0u;
  id v5 = v3;
  uint64_t v2 = (uint64_t)[v5 countByEnumeratingWithState:&v12 objects:v16 count:16];
  if (v2)
  {
    uint64_t v6 = *(void *)v13;
    unint64_t v7 = a2;
    while (2)
    {
      for (uint64_t i = 0LL; i != v2; ++i)
      {
        if (*(void *)v13 != v6) {
          objc_enumerationMutation(v5);
        }
        id v9 = *(id *)(*((void *)&v12 + 1) + 8 * i);
        BOOL v10 = objc_msgSend(v9, "longLongValue", (void)v12) == (id)v7;

        if (v10)
        {
          uint64_t v2 = 1LL;
          goto LABEL_14;
        }
      }

      uint64_t v2 = (uint64_t)[v5 countByEnumeratingWithState:&v12 objects:v16 count:16];
      if (v2) {
        continue;
      }
      break;
    }
  }

void sub_1006094E8(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

uint64_t sub_100609514(uint64_t a1, unsigned int a2)
{
  int v3 = *(void **)(a1 + 176);
  if (!v3) {
    return 0LL;
  }
  __int128 v14 = 0u;
  __int128 v15 = 0u;
  __int128 v12 = 0u;
  __int128 v13 = 0u;
  id v5 = v3;
  uint64_t v2 = (uint64_t)[v5 countByEnumeratingWithState:&v12 objects:v16 count:16];
  if (v2)
  {
    uint64_t v6 = *(void *)v13;
    uint64_t v7 = a2;
    while (2)
    {
      for (uint64_t i = 0LL; i != v2; ++i)
      {
        if (*(void *)v13 != v6) {
          objc_enumerationMutation(v5);
        }
        id v9 = *(id *)(*((void *)&v12 + 1) + 8 * i);
        BOOL v10 = v7 == objc_msgSend(v9, "longLongValue", (void)v12) >> 16;

        if (v10)
        {
          uint64_t v2 = 1LL;
          goto LABEL_14;
        }
      }

      uint64_t v2 = (uint64_t)[v5 countByEnumeratingWithState:&v12 objects:v16 count:16];
      if (v2) {
        continue;
      }
      break;
    }
  }

void sub_100609654(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_100609680(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, int a6)
{
  uint64_t v11 = *(void *)(a1 + 32);
  uint64_t v12 = sub_100404FE8();
  v13[0] = _NSConcreteStackBlock;
  v13[1] = 3221225472LL;
  void v13[2] = sub_1006091B8;
  v13[3] = &unk_1008A2968;
  int v14 = a6;
  void v13[4] = v11;
  void v13[5] = a2;
  void v13[6] = a3;
  v13[7] = a4;
  v13[8] = a5;
  sub_100405384(v12, v13);
}

uint64_t sub_100609710(uint64_t result, unint64_t a2, uint64_t a3)
{
  int v3 = *(void **)(result + 2048);
  if (v3)
  {
    uint64_t v5 = result;
    uint64_t v6 = result + 2048;
    do
    {
      unint64_t v7 = v3[4];
      BOOL v8 = v7 >= a2;
      if (v7 >= a2) {
        id v9 = v3;
      }
      else {
        id v9 = v3 + 1;
      }
      if (v8) {
        uint64_t v6 = (uint64_t)v3;
      }
      int v3 = (void *)*v9;
    }

    while (*v9);
    if (v6 != result + 2048 && *(void *)(v6 + 32) <= a2)
    {
      uint64_t v10 = *(void *)(v6 + 40);
      if (*(void *)(v10 + 88) == a3 && !*(_BYTE *)(*(void *)(v10 + 8) + 143LL))
      {
        int v11 = *(_DWORD *)(v10 + 96);
        uint64_t v12 = (os_log_s *)qword_1008F75B8;
        if (v11 >= 3 && os_log_type_enabled((os_log_t)qword_1008F75B8, OS_LOG_TYPE_FAULT))
        {
          *(_DWORD *)std::stringbuf::string_type __p = 136446210;
          *(void *)&__p[4] = "level < kNumScanLevels";
          _os_log_fault_impl( (void *)&_mh_execute_header,  v12,  OS_LOG_TYPE_FAULT,  "Assertion failed: %{public}s",  __p,  0xCu);
          uint64_t v12 = (os_log_s *)qword_1008F75B8;
        }

        BOOL v13 = os_log_type_enabled(v12, OS_LOG_TYPE_INFO);
        if (v13)
        {
          sub_100494958(a2, (uint64_t)__p);
          int v14 = v16 >= 0 ? __p : *(_BYTE **)__p;
          *(_DWORD *)std::stringbuf::string_type buf = 136446466;
          uint64_t v18 = v14;
          __int16 v19 = 1024;
          int v20 = v11 + 1;
          _os_log_impl( (void *)&_mh_execute_header,  v12,  OS_LOG_TYPE_INFO,  "Session %{public}s is now at scan level %d",  buf,  0x12u);
          if (v16 < 0) {
            operator delete(*(void **)__p);
          }
        }

        *(_DWORD *)(v10 + 96) = v11 + 1;
        if (v11 > 1) {
          *(void *)(v10 + 8_Block_object_dispose(va, 8) = 0LL;
        }
        else {
          sub_1005F39D8(v13, a2, v10);
        }
        return sub_1005E3C94(v5, 0);
      }
    }
  }

  return result;
}

void sub_1006098F4(uint64_t a1)
{
  if (!*(_BYTE *)(a1 + 3256))
  {
    int v2 = *(_DWORD *)(a1 + 3248) + 1;
    *(_DWORD *)(a1 + 324_Block_object_dispose(va, 8) = v2;
    int v3 = (os_log_s *)qword_1008F75B8;
    if (os_log_type_enabled((os_log_t)qword_1008F75B8, OS_LOG_TYPE_DEFAULT))
    {
      v4[0] = 67109120;
      v4[1] = v2;
      _os_log_impl( (void *)&_mh_execute_header,  v3,  OS_LOG_TYPE_DEFAULT,  "ScanCoreBLEConnectionScanStat: ScanCore is enabled for Connection Scan %d times",  (uint8_t *)v4,  8u);
    }
  }

  *(_BYTE *)(a1 + 3256) = 1;
}

void sub_1006099B8(uint64_t a1)
{
}

void sub_1006099C0(uint64_t a1)
{
  if (*(_BYTE *)(a1 + 3256))
  {
    int v2 = (os_log_s *)qword_1008F75B8;
    if (os_log_type_enabled((os_log_t)qword_1008F75B8, OS_LOG_TYPE_DEFAULT))
    {
      *(_WORD *)int v3 = 0;
      _os_log_impl( (void *)&_mh_execute_header,  v2,  OS_LOG_TYPE_DEFAULT,  "ScanCore is disabled for Connection Scan",  v3,  2u);
    }
  }

  *(_BYTE *)(a1 + 3256) = 0;
}

void sub_100609A34(uint64_t a1)
{
}

uint64_t sub_100609A3C(uint64_t result, unint64_t a2, int a3)
{
  int v3 = *(void **)(result + 2048);
  if (v3)
  {
    uint64_t v6 = result;
    uint64_t v7 = result + 2048;
    do
    {
      unint64_t v8 = v3[4];
      BOOL v9 = v8 >= a2;
      if (v8 >= a2) {
        uint64_t v10 = v3;
      }
      else {
        uint64_t v10 = v3 + 1;
      }
      if (v9) {
        uint64_t v7 = (uint64_t)v3;
      }
      int v3 = (void *)*v10;
    }

    while (*v10);
    if (v7 != result + 2048 && *(void *)(v7 + 32) <= a2)
    {
      uint64_t v11 = *(void *)(v7 + 40);
      sub_100616A44(v11);
      *(_BYTE *)(v11 + 81) = a3;
      if (a3 == 16)
      {
        int v12 = *(unsigned __int8 *)(*(void *)(v11 + 8) + 143LL);
        BOOL v13 = (os_log_s *)qword_1008F75B8;
        BOOL v14 = os_log_type_enabled((os_log_t)qword_1008F75B8, OS_LOG_TYPE_INFO);
        if (v12)
        {
          if (v14)
          {
            sub_100494958(*(void *)(v7 + 32), (uint64_t)__p);
            if (v18 >= 0) {
              __int128 v15 = __p;
            }
            else {
              __int128 v15 = (void **)__p[0];
            }
            *(_DWORD *)std::stringbuf::string_type buf = 136446210;
            int v20 = v15;
            _os_log_impl( (void *)&_mh_execute_header,  v13,  OS_LOG_TYPE_INFO,  "Session %{public}s does not need a scan level bump since its doing ContactTracing",  buf,  0xCu);
            if (v18 < 0) {
              operator delete(__p[0]);
            }
          }
        }

        else
        {
          if (v14)
          {
            sub_100494958(a2, (uint64_t)__p);
            char v16 = v18 >= 0 ? __p : (void **)__p[0];
            *(_DWORD *)std::stringbuf::string_type buf = 136446210;
            int v20 = v16;
            _os_log_impl( (void *)&_mh_execute_header,  v13,  OS_LOG_TYPE_INFO,  "Session %{public}s is now back at scan level 1",  buf,  0xCu);
            if (v18 < 0) {
              operator delete(__p[0]);
            }
          }

          *(_DWORD *)(v11 + 96) = 1;
        }

        sub_1005F39D8(v14, a2, v11);
      }

      return sub_1005E3C94(v6, 0);
    }
  }

  return result;
}

uint64_t sub_100609C14(uint64_t a1, void *a2)
{
  id v3 = a2;
  int v4 = (os_log_s *)qword_1008F75B8;
  if (os_log_type_enabled((os_log_t)qword_1008F75B8, OS_LOG_TYPE_DEFAULT))
  {
    uint64_t v5 = *(int *)(a1 + 1960);
    else {
      uint64_t v6 = off_1008A4210[v5];
    }
    uint64_t v7 = *(int *)(a1 + 1964);
    else {
      unint64_t v8 = off_1008A4238[v7];
    }
    int v21 = 136446466;
    int v22 = v6;
    __int16 v23 = 2082;
    uint64_t v24 = v8;
    _os_log_impl( (void *)&_mh_execute_header,  v4,  OS_LOG_TYPE_DEFAULT,  "pauseScans State: %{public}s, ObserverState: %{public}s",  (uint8_t *)&v21,  0x16u);
  }

  int v9 = *(_DWORD *)(a1 + 1964);
  if ((v9 - 1) < 2)
  {
    int v12 = (os_log_s *)qword_1008F75B8;
    if (os_log_type_enabled((os_log_t)qword_1008F75B8, OS_LOG_TYPE_DEFAULT))
    {
      uint64_t v13 = *(int *)(a1 + 1960);
      BOOL v14 = "UNKNOWN";
      __int128 v15 = "UNKNOWN";
      if (v9 == 1) {
        BOOL v14 = "Pausing";
      }
      if (v9 == 2) {
        BOOL v14 = "Paused";
      }
      int v21 = 136446466;
      int v22 = v15;
      __int16 v23 = 2082;
      uint64_t v24 = v14;
      _os_log_impl( (void *)&_mh_execute_header,  v12,  OS_LOG_TYPE_DEFAULT,  "Already Paused Scans State: %{public}s, ObserverState: %{public}s",  (uint8_t *)&v21,  0x16u);
    }

    uint64_t v11 = 401LL;
  }

  else
  {
    if (v9 == 3)
    {
      uint64_t v11 = 1LL;
      goto LABEL_29;
    }

    if (!v9)
    {
      sub_1005FA5B8((os_unfair_lock_s *)a1, 1u);
      int v10 = *(_DWORD *)(a1 + 1960);
      if (v10 == 1 || v10 == 3 && sub_100600194(a1)) {
        sub_1005FA5B8((os_unfair_lock_s *)a1, 2u);
      }
    }

    uint64_t v11 = 0LL;
  }

  [*(id *)(a1 + 3264) addObject:v3];
  char v16 = (os_log_s *)qword_1008F75B8;
  if (os_log_type_enabled((os_log_t)qword_1008F75B8, OS_LOG_TYPE_DEFAULT))
  {
    uint64_t v17 = (const char *)[v3 UTF8String];
    char v18 = (const char *)[*(id *)(a1 + 3264) count];
    uint64_t v19 = *(void *)(a1 + 3264);
    int v21 = 136315650;
    int v22 = v17;
    __int16 v23 = 2048;
    uint64_t v24 = v18;
    __int16 v25 = 2112;
    uint64_t v26 = v19;
    _os_log_impl( (void *)&_mh_execute_header,  v16,  OS_LOG_TYPE_DEFAULT,  "Added Paused Client: %s, Clients(Count: %lu): %@",  (uint8_t *)&v21,  0x20u);
  }

void sub_100609EB0(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

uint64_t sub_100609ECC(uint64_t a1, void *a2)
{
  id v3 = a2;
  [*(id *)(a1 + 3264) removeObject:v3];
  if ([*(id *)(a1 + 3264) count])
  {
    int v4 = (os_log_s *)qword_1008F75B8;
    uint64_t v5 = 0LL;
    if (os_log_type_enabled((os_log_t)qword_1008F75B8, OS_LOG_TYPE_DEFAULT))
    {
      uint64_t v6 = (const char *)[*(id *)(a1 + 3264) count];
      uint64_t v7 = *(int *)(a1 + 1960);
      else {
        unint64_t v8 = off_1008A4210[v7];
      }
      uint64_t v12 = *(int *)(a1 + 1964);
      else {
        uint64_t v13 = off_1008A4238[v12];
      }
      uint64_t v14 = *(void *)(a1 + 3264);
      int v19 = 134218754;
      int v20 = v6;
      __int16 v21 = 2082;
      int v22 = v8;
      __int16 v23 = 2082;
      uint64_t v24 = v13;
      __int16 v25 = 2112;
      uint64_t v26 = v14;
      _os_log_impl( (void *)&_mh_execute_header,  v4,  OS_LOG_TYPE_DEFAULT,  "Cannot Resume Scans we have %lu clients required to be paused, State: %{public}s, ObserverState: %{public}s, clients: %@",  (uint8_t *)&v19,  0x2Au);
LABEL_13:
      uint64_t v5 = 0LL;
    }
  }

  else
  {
    [*(id *)(a1 + 3264) removeAllObjects];
    int v9 = (os_log_s *)qword_1008F75B8;
    if (os_log_type_enabled((os_log_t)qword_1008F75B8, OS_LOG_TYPE_DEFAULT))
    {
      uint64_t v10 = *(int *)(a1 + 1960);
      else {
        uint64_t v11 = off_1008A4210[v10];
      }
      uint64_t v15 = *(int *)(a1 + 1964);
      else {
        char v16 = off_1008A4238[v15];
      }
      int v19 = 136446466;
      int v20 = v11;
      __int16 v21 = 2082;
      int v22 = v16;
      _os_log_impl( (void *)&_mh_execute_header,  v9,  OS_LOG_TYPE_DEFAULT,  "resumeScans State: %{public}s, ObserverState: %{public}s",  (uint8_t *)&v19,  0x16u);
    }

    unsigned int v17 = *(_DWORD *)(a1 + 1964);
    uint64_t v5 = 1LL;
    if (v17 >= 2 && v17 != 3)
    {
      if (v17 == 2)
      {
        sub_1005FA5B8((os_unfair_lock_s *)a1, 3u);
        *(_BYTE *)(a1 + 1840) = 1;
        if ((*(_DWORD *)(a1 + 1960) | 2) == 3) {
          sub_1005FA5B8((os_unfair_lock_s *)a1, 0);
        }
      }

      goto LABEL_13;
    }
  }

  return v5;
}

void sub_10060A11C(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_10060A138(id a1, LeObserverListener *a2)
{
}

void sub_10060A148(id a1, LeObserverListener *a2)
{
}

uint64_t sub_10060A158@<X0>(uint64_t a1@<X0>, std::stringbuf::string_type *a2@<X8>)
{
  uint64_t v21 = 0LL;
  __int128 v19 = 0u;
  memset(v20, 0, sizeof(v20));
  *(_OWORD *)std::stringbuf::string_type __p = 0u;
  __int128 v18 = 0u;
  memset(v16, 0, sizeof(v16));
  sub_10020E564((uint64_t)v16);
  int v4 = sub_1001FD17C(v16, (uint64_t)" client: ", 9LL);
  sub_1001FD17C(v4, (uint64_t)"LeObserver", 10LL);
  uint64_t v5 = sub_1001FD17C(v16, (uint64_t)" state: (", 9LL);
  uint64_t v6 = *(int *)(a1 + 1960);
  else {
    uint64_t v7 = off_1008A4210[v6];
  }
  size_t v8 = strlen(v7);
  int v9 = sub_1001FD17C(v5, (uint64_t)v7, v8);
  sub_1001FD17C(v9, (uint64_t)")", 1LL);
  uint64_t v10 = sub_1001FD17C(v16, (uint64_t)" , ObserverState: (", 19LL);
  uint64_t v11 = *(int *)(a1 + 1964);
  else {
    uint64_t v12 = off_1008A4238[v11];
  }
  size_t v13 = strlen(v12);
  uint64_t v14 = sub_1001FD17C(v10, (uint64_t)v12, v13);
  sub_1001FD17C(v14, (uint64_t)")", 1LL);
  std::stringbuf::str(a2, (const std::stringbuf *)((char *)v16 + 8));
  if (SHIBYTE(v18) < 0) {
    operator delete(__p[1]);
  }
  std::streambuf::~streambuf((char *)v16 + 8);
  return std::ios::~ios(v20);
}

void sub_10060A31C( _Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9)
{
}

uint64_t sub_10060A330@<X0>(uint64_t a1@<X0>, std::stringbuf::string_type *a2@<X8>)
{
  return sub_10060A158(a1 - 56, a2);
}

void sub_10060A338(uint64_t a1)
{
  uint64_t v1 = (_BYTE *)(a1 + 4296);
  int v2 = (os_log_s *)qword_1008F75B8;
  if (os_log_type_enabled((os_log_t)qword_1008F75B8, OS_LOG_TYPE_DEFAULT))
  {
    LOWORD(buf[0].__r_.__value_.__l.__data_) = 0;
    _os_log_impl( (void *)&_mh_execute_header,  v2,  OS_LOG_TYPE_DEFAULT,  "statedump: -------------------- LE Observer ---------------------",  (uint8_t *)buf,  2u);
    int v2 = (os_log_s *)qword_1008F75B8;
  }

  if (os_log_type_enabled(v2, OS_LOG_TYPE_DEFAULT))
  {
    uint64_t v3 = *(int *)(a1 + 1960);
    else {
      int v4 = off_1008A4210[v3];
    }
    uint64_t v5 = *(int *)(a1 + 1964);
    else {
      uint64_t v6 = off_1008A4238[v5];
    }
    int v7 = v1[90];
    LODWORD(buf[0].__r_.__value_.__l.__data_) = 136446722;
    *(std::string::size_type *)((char *)buf[0].__r_.__value_.__r.__words + 4) = (std::string::size_type)v4;
    WORD2(buf[0].__r_.__value_.__r.__words[1]) = 2082;
    *(std::string::size_type *)((char *)&buf[0].__r_.__value_.__r.__words[1] + 6) = (std::string::size_type)v6;
    HIWORD(buf[0].__r_.__value_.__r.__words[2]) = 1024;
    LODWORD(buf[1].__r_.__value_.__l.__data_) = v7;
    _os_log_impl( (void *)&_mh_execute_header,  v2,  OS_LOG_TYPE_DEFAULT,  "statedump: State: %{public}s, ObserverState: %{public}s fSystemWillSleep: %d",  (uint8_t *)buf,  0x1Cu);
    int v2 = (os_log_s *)qword_1008F75B8;
  }

  if (os_log_type_enabled(v2, OS_LOG_TYPE_DEFAULT))
  {
    int v8 = sub_100600088(a1);
    int v9 = "NO";
    if (v8) {
      int v9 = "YES";
    }
    LODWORD(buf[0].__r_.__value_.__l.__data_) = 136446210;
    *(std::string::size_type *)((char *)buf[0].__r_.__value_.__r.__words + 4) = (std::string::size_type)v9;
    _os_log_impl( (void *)&_mh_execute_header,  v2,  OS_LOG_TYPE_DEFAULT,  "statedump: haveAnyValidScanRequests:%{public}s",  (uint8_t *)buf,  0xCu);
    int v2 = (os_log_s *)qword_1008F75B8;
  }

  if (os_log_type_enabled(v2, OS_LOG_TYPE_DEFAULT))
  {
    BOOL v10 = sub_1005EF760(a1);
    uint64_t v11 = "NO";
    if (v10) {
      uint64_t v11 = "YES";
    }
    LODWORD(buf[0].__r_.__value_.__l.__data_) = 136446210;
    *(std::string::size_type *)((char *)buf[0].__r_.__value_.__r.__words + 4) = (std::string::size_type)v11;
    _os_log_impl( (void *)&_mh_execute_header,  v2,  OS_LOG_TYPE_DEFAULT,  "statedump: haveAnyActiveScanRequests:%{public}s",  (uint8_t *)buf,  0xCu);
    int v2 = (os_log_s *)qword_1008F75B8;
  }

  if (os_log_type_enabled(v2, OS_LOG_TYPE_DEFAULT))
  {
    BOOL v12 = sub_100600194(a1);
    size_t v13 = "NO";
    if (v12) {
      size_t v13 = "YES";
    }
    LODWORD(buf[0].__r_.__value_.__l.__data_) = 136446210;
    *(std::string::size_type *)((char *)buf[0].__r_.__value_.__r.__words + 4) = (std::string::size_type)v13;
    _os_log_impl( (void *)&_mh_execute_header,  v2,  OS_LOG_TYPE_DEFAULT,  "statedump: haveAnyValidScanRequestsInPaused:%{public}s",  (uint8_t *)buf,  0xCu);
    int v2 = (os_log_s *)qword_1008F75B8;
  }

  if (os_log_type_enabled(v2, OS_LOG_TYPE_DEFAULT))
  {
    BOOL v14 = sub_1005EBF48(a1);
    uint64_t v15 = "NO";
    if (v14) {
      uint64_t v15 = "YES";
    }
    LODWORD(buf[0].__r_.__value_.__l.__data_) = 136446210;
    *(std::string::size_type *)((char *)buf[0].__r_.__value_.__r.__words + 4) = (std::string::size_type)v15;
    _os_log_impl( (void *)&_mh_execute_header,  v2,  OS_LOG_TYPE_DEFAULT,  "statedump: haveAnyValidHWObjectDiscovery:%{public}s",  (uint8_t *)buf,  0xCu);
    int v2 = (os_log_s *)qword_1008F75B8;
  }

  if (os_log_type_enabled(v2, OS_LOG_TYPE_DEFAULT))
  {
    int v16 = sub_1005EE698(a1);
    unsigned int v17 = "NO";
    if (v16) {
      unsigned int v17 = "YES";
    }
    LODWORD(buf[0].__r_.__value_.__l.__data_) = 136446210;
    *(std::string::size_type *)((char *)buf[0].__r_.__value_.__r.__words + 4) = (std::string::size_type)v17;
    _os_log_impl( (void *)&_mh_execute_header,  v2,  OS_LOG_TYPE_DEFAULT,  "statedump: objectDiscoveryHwAdvBufferOnly:%{public}s",  (uint8_t *)buf,  0xCu);
    int v2 = (os_log_s *)qword_1008F75B8;
  }

  if (os_log_type_enabled(v2, OS_LOG_TYPE_DEFAULT))
  {
    BOOL v18 = sub_1005EE83C(a1);
    __int128 v19 = "NO";
    if (v18) {
      __int128 v19 = "YES";
    }
    LODWORD(buf[0].__r_.__value_.__l.__data_) = 136446210;
    *(std::string::size_type *)((char *)buf[0].__r_.__value_.__r.__words + 4) = (std::string::size_type)v19;
    _os_log_impl( (void *)&_mh_execute_header,  v2,  OS_LOG_TYPE_DEFAULT,  "statedump: haveAnyHwAOPBTBufferRequests:%{public}s",  (uint8_t *)buf,  0xCu);
    int v2 = (os_log_s *)qword_1008F75B8;
  }

  if (os_log_type_enabled(v2, OS_LOG_TYPE_DEFAULT))
  {
    BOOL v20 = sub_10060001C(a1);
    uint64_t v21 = "NO";
    std::string::size_type v22 = *(void *)(a1 + 2200);
    if (v20) {
      uint64_t v21 = "YES";
    }
    LODWORD(buf[0].__r_.__value_.__l.__data_) = 136446466;
    *(std::string::size_type *)((char *)buf[0].__r_.__value_.__r.__words + 4) = (std::string::size_type)v21;
    WORD2(buf[0].__r_.__value_.__r.__words[1]) = 2048;
    *(std::string::size_type *)((char *)&buf[0].__r_.__value_.__r.__words[1] + 6) = v22;
    _os_log_impl( (void *)&_mh_execute_header,  v2,  OS_LOG_TYPE_DEFAULT,  "statedump: haveClientPowerAssertion:%{public}s, fScanningPowerAssertion:%llx",  (uint8_t *)buf,  0x16u);
    int v2 = (os_log_s *)qword_1008F75B8;
  }

  if (os_log_type_enabled(v2, OS_LOG_TYPE_DEFAULT))
  {
    if (*(void *)(a1 + 2208)) {
      __int16 v23 = "YES";
    }
    else {
      __int16 v23 = "NO";
    }
    uint64_t v24 = sub_1002E6E9C();
    else {
      __int16 v25 = "NO";
    }
    LODWORD(buf[0].__r_.__value_.__l.__data_) = 136446466;
    *(std::string::size_type *)((char *)buf[0].__r_.__value_.__r.__words + 4) = (std::string::size_type)v23;
    WORD2(buf[0].__r_.__value_.__r.__words[1]) = 2082;
    *(std::string::size_type *)((char *)&buf[0].__r_.__value_.__r.__words[1] + 6) = (std::string::size_type)v25;
    _os_log_impl( (void *)&_mh_execute_header,  v2,  OS_LOG_TYPE_DEFAULT,  "statedump: configPowerAssert:%{public}s needsScanconfigPowerAssertions:%{public}s",  (uint8_t *)buf,  0x16u);
    int v2 = (os_log_s *)qword_1008F75B8;
  }

  if (os_log_type_enabled(v2, OS_LOG_TYPE_DEFAULT))
  {
    uint64_t v26 = "YES";
    if (*(_BYTE *)(a1 + 1840)) {
      int v27 = "YES";
    }
    else {
      int v27 = "NO";
    }
    if (!*(_BYTE *)(a1 + 1843)) {
      uint64_t v26 = "NO";
    }
    LODWORD(buf[0].__r_.__value_.__l.__data_) = 136446466;
    *(std::string::size_type *)((char *)buf[0].__r_.__value_.__r.__words + 4) = (std::string::size_type)v27;
    WORD2(buf[0].__r_.__value_.__r.__words[1]) = 2082;
    *(std::string::size_type *)((char *)&buf[0].__r_.__value_.__r.__words[1] + 6) = (std::string::size_type)v26;
    _os_log_impl( (void *)&_mh_execute_header,  v2,  OS_LOG_TYPE_DEFAULT,  "statedump: fScanFiltersNeedUpdating:%{public}s fZoneScansHaveChanged:%{public}s ",  (uint8_t *)buf,  0x16u);
    int v2 = (os_log_s *)qword_1008F75B8;
  }

  if (os_log_type_enabled(v2, OS_LOG_TYPE_DEFAULT))
  {
    int v28 = "YES";
    if (*(_BYTE *)(a1 + 1848)) {
      int v29 = "YES";
    }
    else {
      int v29 = "NO";
    }
    int v30 = *(unsigned __int8 *)(a1 + 1850);
    if (*(_BYTE *)(a1 + 1849)) {
      id v31 = "YES";
    }
    else {
      id v31 = "NO";
    }
    LODWORD(buf[0].__r_.__value_.__l.__data_) = 136446722;
    if (!v30) {
      int v28 = "NO";
    }
    *(std::string::size_type *)((char *)buf[0].__r_.__value_.__r.__words + 4) = (std::string::size_type)v29;
    WORD2(buf[0].__r_.__value_.__r.__words[1]) = 2082;
    *(std::string::size_type *)((char *)&buf[0].__r_.__value_.__r.__words[1] + 6) = (std::string::size_type)v31;
    HIWORD(buf[0].__r_.__value_.__r.__words[2]) = 2082;
    buf[1].__r_.__value_.__r.__words[0] = (std::string::size_type)v28;
    _os_log_impl( (void *)&_mh_execute_header,  v2,  OS_LOG_TYPE_DEFAULT,  "statedump: fHaveUUIDFilters:%{public}s fHaveZoneFilters:%{public}s fHaveRuleFilters:%{public}s",  (uint8_t *)buf,  0x20u);
    int v2 = (os_log_s *)qword_1008F75B8;
  }

  if (os_log_type_enabled(v2, OS_LOG_TYPE_DEFAULT))
  {
    std::string::size_type v32 = *(void *)(a1 + 2128);
    LODWORD(buf[0].__r_.__value_.__l.__data_) = 134217984;
    *(std::string::size_type *)((char *)buf[0].__r_.__value_.__r.__words + 4) = v32;
    _os_log_impl( (void *)&_mh_execute_header,  v2,  OS_LOG_TYPE_DEFAULT,  "statedump: fApWakeReadADVBuffersDebounceDelta:%llu",  (uint8_t *)buf,  0xCu);
    int v2 = (os_log_s *)qword_1008F75B8;
  }

  if (os_log_type_enabled(v2, OS_LOG_TYPE_DEFAULT))
  {
    int v33 = *(_DWORD *)(a1 + 2292);
    LODWORD(buf[0].__r_.__value_.__l.__data_) = 67109120;
    HIDWORD(buf[0].__r_.__value_.__r.__words[0]) = v33;
    _os_log_impl((void *)&_mh_execute_header, v2, OS_LOG_TYPE_DEFAULT, "statedump: fRSSIOffset:%d", (uint8_t *)buf, 8u);
    int v2 = (os_log_s *)qword_1008F75B8;
  }

  if (os_log_type_enabled(v2, OS_LOG_TYPE_DEFAULT))
  {
    int v34 = v1[88];
    LODWORD(buf[0].__r_.__value_.__l.__data_) = 67109120;
    HIDWORD(buf[0].__r_.__value_.__r.__words[0]) = v34;
    _os_log_impl( (void *)&_mh_execute_header,  v2,  OS_LOG_TYPE_DEFAULT,  "statedump: fScanThrottlingRequired:%d",  (uint8_t *)buf,  8u);
    int v2 = (os_log_s *)qword_1008F75B8;
  }

  if (os_log_type_enabled(v2, OS_LOG_TYPE_DEFAULT))
  {
    if (*(_BYTE *)(a1 + 2352)) {
      unint64_t v35 = "YES";
    }
    else {
      unint64_t v35 = "NO";
    }
    LODWORD(buf[0].__r_.__value_.__l.__data_) = 136446210;
    *(std::string::size_type *)((char *)buf[0].__r_.__value_.__r.__words + 4) = (std::string::size_type)v35;
    _os_log_impl( (void *)&_mh_execute_header,  v2,  OS_LOG_TYPE_DEFAULT,  "statedump: fShouldRetainDupsNextUpdate:%{public}s",  (uint8_t *)buf,  0xCu);
    int v2 = (os_log_s *)qword_1008F75B8;
  }

  if (os_log_type_enabled(v2, OS_LOG_TYPE_DEFAULT))
  {
    uint64_t v36 = sub_1002E6BF0();
    int v37 = (*(uint64_t (**)(uint64_t))(*(void *)v36 + 704LL))(v36);
    LODWORD(buf[0].__r_.__value_.__l.__data_) = 67109120;
    HIDWORD(buf[0].__r_.__value_.__r.__words[0]) = v37;
    _os_log_impl( (void *)&_mh_execute_header,  v2,  OS_LOG_TYPE_DEFAULT,  "statedump: Num of supported ObjectDiscovery HW ADV Buffers:%d",  (uint8_t *)buf,  8u);
    int v2 = (os_log_s *)qword_1008F75B8;
  }

  if (os_log_type_enabled(v2, OS_LOG_TYPE_DEFAULT))
  {
    if (byte_1008F1E9C) {
      uint64_t v38 = "YES";
    }
    else {
      uint64_t v38 = "NO";
    }
    LODWORD(buf[0].__r_.__value_.__l.__data_) = 136446210;
    *(std::string::size_type *)((char *)buf[0].__r_.__value_.__r.__words + 4) = (std::string::size_type)v38;
    _os_log_impl( (void *)&_mh_execute_header,  v2,  OS_LOG_TYPE_DEFAULT,  "statedump: gSniffScanDebug:%{public}s",  (uint8_t *)buf,  0xCu);
    int v2 = (os_log_s *)qword_1008F75B8;
  }

  if (os_log_type_enabled(v2, OS_LOG_TYPE_DEFAULT))
  {
    unint64_t v39 = "YES";
    if (*v1) {
      uint64_t v40 = "YES";
    }
    else {
      uint64_t v40 = "NO";
    }
    int v41 = *(_DWORD *)(a1 + 4376);
    if (v1[84]) {
      unsigned __int8 v42 = "YES";
    }
    else {
      unsigned __int8 v42 = "NO";
    }
    if (v1[86]) {
      id v43 = "YES";
    }
    else {
      id v43 = "NO";
    }
    if (!v1[85]) {
      unint64_t v39 = "NO";
    }
    LODWORD(buf[0].__r_.__value_.__l.__data_) = 136447490;
    *(std::string::size_type *)((char *)buf[0].__r_.__value_.__r.__words + 4) = (std::string::size_type)v40;
    WORD2(buf[0].__r_.__value_.__r.__words[1]) = 1024;
    *(_DWORD *)((char *)&buf[0].__r_.__value_.__r.__words[1] + 6) = v41;
    WORD1(buf[0].__r_.__value_.__r.__words[2]) = 2082;
    *(std::string::size_type *)((char *)&buf[0].__r_.__value_.__r.__words[2] + 4) = (std::string::size_type)v42;
    WORD2(buf[1].__r_.__value_.__r.__words[0]) = 2082;
    *(std::string::size_type *)((char *)buf[1].__r_.__value_.__r.__words + 6) = (std::string::size_type)v43;
    HIWORD(buf[1].__r_.__value_.__r.__words[1]) = 2082;
    buf[1].__r_.__value_.__l.__cap_ = (std::string::size_type)v39;
    LOWORD(vsub_100242FAC(v47 - 160) = 2082;
    *(void *)((char *)&v160 + 2) = v43;
    _os_log_impl( (void *)&_mh_execute_header,  v2,  OS_LOG_TYPE_DEFAULT,  "statedump: fControllerConfigInProgress:%{public}s fBypassFilterMask:%04x fGlobalDuplicateFilter:%{public}s shouldD ispatchConfig():%{public}s fDebugControllerConfigDispatchSequence:%{public}s fForceDispatchInsteadOfSerialConfig:%{public}s",  (uint8_t *)buf,  0x3Au);
  }

  uint64_t v44 = sub_1002E6E00();
  if ((*(unsigned int (**)(uint64_t))(*(void *)v44 + 8LL))(v44))
  {
    uint64_t v45 = (os_log_s *)qword_1008F75B8;
    if (os_log_type_enabled((os_log_t)qword_1008F75B8, OS_LOG_TYPE_DEFAULT))
    {
      LOWORD(buf[0].__r_.__value_.__l.__data_) = 0;
      _os_log_impl( (void *)&_mh_execute_header,  v45,  OS_LOG_TYPE_DEFAULT,  "statedump: fFilterPeripherals:",  (uint8_t *)buf,  2u);
    }

    int v46 = *(void **)(a1 + 4304);
    if (v46 != (void *)(a1 + 4312))
    {
      do
      {
        unsigned __int8 v47 = (os_log_s *)qword_1008F75B8;
        if (os_log_type_enabled((os_log_t)qword_1008F75B8, OS_LOG_TYPE_DEFAULT))
        {
          sub_1005BF8CC(v46[4], buf);
          uint64_t v48 = (buf[0].__r_.__value_.__s.__size_ & 0x80u) == 0
              ? buf
              : (std::stringbuf::string_type *)buf[0].__r_.__value_.__r.__words[0];
          *(_DWORD *)BOOL v152 = 136446210;
          *(void *)&v152[4] = v48;
          _os_log_impl((void *)&_mh_execute_header, v47, OS_LOG_TYPE_DEFAULT, "    %{public}s", v152, 0xCu);
        }

        id v49 = (void *)v46[1];
        if (v49)
        {
          do
          {
            unsigned int v50 = v49;
            id v49 = (void *)*v49;
          }

          while (v49);
        }

        else
        {
          do
          {
            unsigned int v50 = (void *)v46[2];
            BOOL v51 = *v50 == (void)v46;
            int v46 = v50;
          }

          while (!v51);
        }

        int v46 = v50;
      }

      while (v50 != (void *)(a1 + 4312));
    }

    BOOL v52 = (os_log_s *)qword_1008F75B8;
    if (os_log_type_enabled((os_log_t)qword_1008F75B8, OS_LOG_TYPE_DEFAULT))
    {
      LOWORD(buf[0].__r_.__value_.__l.__data_) = 0;
      _os_log_impl((void *)&_mh_execute_header, v52, OS_LOG_TYPE_DEFAULT, "statedump: fAllUuids:", (uint8_t *)buf, 2u);
    }

    unsigned int v53 = *(void **)(a1 + 4328);
    if (v53 != (void *)(a1 + 4336))
    {
      do
      {
        BOOL v54 = (os_log_s *)qword_1008F75B8;
        if (os_log_type_enabled((os_log_t)qword_1008F75B8, OS_LOG_TYPE_DEFAULT))
        {
          sub_1006344B4((uint64_t)v53 + 28, buf);
          id v55 = (buf[0].__r_.__value_.__s.__size_ & 0x80u) == 0
              ? buf
              : (std::stringbuf::string_type *)buf[0].__r_.__value_.__r.__words[0];
          *(_DWORD *)BOOL v152 = 136446210;
          *(void *)&v152[4] = v55;
          _os_log_impl((void *)&_mh_execute_header, v54, OS_LOG_TYPE_DEFAULT, "    %{public}s", v152, 0xCu);
        }

        unsigned int v56 = (void *)v53[1];
        if (v56)
        {
          do
          {
            BOOL v57 = v56;
            unsigned int v56 = (void *)*v56;
          }

          while (v56);
        }

        else
        {
          do
          {
            BOOL v57 = (void *)v53[2];
            BOOL v51 = *v57 == (void)v53;
            unsigned int v53 = v57;
          }

          while (!v51);
        }

        unsigned int v53 = v57;
      }

      while (v57 != (void *)(a1 + 4336));
    }
  }

  unsigned int v58 = (os_log_s *)qword_1008F75B8;
  if (*(_DWORD *)(a1 + 1960) == 3)
  {
    *(_OWORD *)&buf[0].__r_.__value_.__l.__data_ = 0uLL;
    if (os_log_type_enabled((os_log_t)qword_1008F75B8, OS_LOG_TYPE_DEFAULT))
    {
      *(_WORD *)BOOL v152 = 0;
      _os_log_impl((void *)&_mh_execute_header, v58, OS_LOG_TYPE_DEFAULT, "statedump: Scan configuration:", v152, 2u);
    }

    LOWORD(v59) = *(_WORD *)(a1 + 1972);
    snprintf((char *)buf, 0x10uLL, "%.02fms", (double)v59 * 0.625);
    size_t v60 = (os_log_s *)qword_1008F75B8;
    if (os_log_type_enabled((os_log_t)qword_1008F75B8, OS_LOG_TYPE_DEFAULT))
    {
      *(_DWORD *)BOOL v152 = 136446210;
      *(void *)&v152[4] = buf;
      _os_log_impl( (void *)&_mh_execute_header,  v60,  OS_LOG_TYPE_DEFAULT,  "statedump:    Interval: %{public}s",  v152,  0xCu);
    }

    LOWORD(v61) = *(_WORD *)(a1 + 1974);
    snprintf((char *)buf, 0x10uLL, "%.02fms", (double)v61 * 0.625);
    unsigned int v58 = (os_log_s *)qword_1008F75B8;
    if (os_log_type_enabled((os_log_t)qword_1008F75B8, OS_LOG_TYPE_DEFAULT))
    {
      *(_DWORD *)BOOL v152 = 136446210;
      *(void *)&v152[4] = buf;
      _os_log_impl( (void *)&_mh_execute_header,  v58,  OS_LOG_TYPE_DEFAULT,  "statedump:    Window: %{public}s",  v152,  0xCu);
      unsigned int v58 = (os_log_s *)qword_1008F75B8;
    }

    if (os_log_type_enabled(v58, OS_LOG_TYPE_DEFAULT))
    {
      if (*(_BYTE *)(a1 + 1968)) {
        uint64_t v62 = "Passive";
      }
      else {
        uint64_t v62 = "Active";
      }
      *(_DWORD *)BOOL v152 = 136446210;
      *(void *)&v152[4] = v62;
      _os_log_impl((void *)&_mh_execute_header, v58, OS_LOG_TYPE_DEFAULT, "statedump:    Type: %{public}s", v152, 0xCu);
      unsigned int v58 = (os_log_s *)qword_1008F75B8;
    }

    if (os_log_type_enabled(v58, OS_LOG_TYPE_DEFAULT))
    {
      if (*(_BYTE *)(a1 + 1971)) {
        uint64_t v63 = "No";
      }
      else {
        uint64_t v63 = "Yes";
      }
      *(_DWORD *)BOOL v152 = 136446210;
      *(void *)&v152[4] = v63;
      _os_log_impl( (void *)&_mh_execute_header,  v58,  OS_LOG_TYPE_DEFAULT,  "statedump:    Duplicates: %{public}s",  v152,  0xCu);
      unsigned int v58 = (os_log_s *)qword_1008F75B8;
    }

    if (os_log_type_enabled(v58, OS_LOG_TYPE_DEFAULT))
    {
      if (*(_BYTE *)(a1 + 1970)) {
        unsigned __int16 v64 = "Yes";
      }
      else {
        unsigned __int16 v64 = "No";
      }
      *(_DWORD *)BOOL v152 = 136446210;
      *(void *)&v152[4] = v64;
      _os_log_impl( (void *)&_mh_execute_header,  v58,  OS_LOG_TYPE_DEFAULT,  "statedump:    Filter Accept List: %{public}s",  v152,  0xCu);
      unsigned int v58 = (os_log_s *)qword_1008F75B8;
    }

    if (os_log_type_enabled(v58, OS_LOG_TYPE_DEFAULT))
    {
      if (*(_BYTE *)(a1 + 1848)) {
        uint64_t v65 = "Disabled";
      }
      else {
        uint64_t v65 = "Enabled";
      }
      *(_DWORD *)BOOL v152 = 136446210;
      *(void *)&v152[4] = v65;
      _os_log_impl( (void *)&_mh_execute_header,  v58,  OS_LOG_TYPE_DEFAULT,  "statedump:    HW Filtering: %{public}s",  v152,  0xCu);
      unsigned int v58 = (os_log_s *)qword_1008F75B8;
    }
  }

  if (os_log_type_enabled(v58, OS_LOG_TYPE_DEFAULT))
  {
    LOWORD(buf[0].__r_.__value_.__l.__data_) = 0;
    _os_log_impl((void *)&_mh_execute_header, v58, OS_LOG_TYPE_DEFAULT, "statedump: Scan agents:", (uint8_t *)buf, 2u);
  }

  if (v1[89])
  {
    unsigned __int16 v66 = *(void **)(a1 + 2040);
    if (v66 != (void *)(a1 + 2048))
    {
      do
      {
        uint64_t v137 = *(void *)(v66[5] + 8LL);
        int v67 = (os_log_s *)qword_1008F75B8;
        unsigned int v68 = v66;
        __int128 v136 = v66;
        if (os_log_type_enabled((os_log_t)qword_1008F75B8, OS_LOG_TYPE_DEFAULT))
        {
          sub_100494958(v68[4], (uint64_t)buf);
          unsigned __int8 v69 = buf;
          if ((buf[0].__r_.__value_.__s.__size_ & 0x80u) != 0) {
            unsigned __int8 v69 = (std::stringbuf::string_type *)buf[0].__r_.__value_.__r.__words[0];
          }
          *(_DWORD *)BOOL v152 = 136446210;
          *(void *)&v152[4] = v69;
          _os_log_impl( (void *)&_mh_execute_header,  v67,  OS_LOG_TYPE_DEFAULT,  "statedump:    %{public}s",  v152,  0xCu);
          int v67 = (os_log_s *)qword_1008F75B8;
        }

        if (os_log_type_enabled(v67, OS_LOG_TYPE_DEFAULT))
        {
          size_t v70 = "Yes";
          if (!*(_BYTE *)v137) {
            size_t v70 = "No";
          }
          LODWORD(buf[0].__r_.__value_.__l.__data_) = 136446210;
          *(std::string::size_type *)((char *)buf[0].__r_.__value_.__r.__words + 4) = (std::string::size_type)v70;
          _os_log_impl( (void *)&_mh_execute_header,  v67,  OS_LOG_TYPE_DEFAULT,  "statedump:       Duplicates: %{public}s",  (uint8_t *)buf,  0xCu);
        }

        unsigned int v146 = 0LL;
        uint64_t v147 = 0LL;
        unsigned int v145 = 0LL;
        sub_100050EE8( (char *)&v145,  *(__int128 **)(v137 + 8),  *(__int128 **)(v137 + 16),  0xCCCCCCCCCCCCCCCDLL * ((uint64_t)(*(void *)(v137 + 16) - *(void *)(v137 + 8)) >> 2));
        uint64_t v166 = 0LL;
        __int128 v164 = 0u;
        memset(v165, 0, sizeof(v165));
        *(_OWORD *)unsigned int v162 = 0u;
        __int128 v163 = 0u;
        __int128 v160 = 0u;
        __int128 v161 = 0u;
        memset(buf, 0, sizeof(buf));
        sub_1001FCFC8((uint64_t)buf);
        uint64_t v71 = (char *)v145;
        if (v146 != v145)
        {
          do
          {
            sub_1006344B4((uint64_t)v71, v152);
            if ((SBYTE7(v153[0]) & 0x80u) == 0) {
              char v72 = v152;
            }
            else {
              char v72 = *(uint8_t **)v152;
            }
            if ((SBYTE7(v153[0]) & 0x80u) == 0) {
              uint64_t v73 = BYTE7(v153[0]);
            }
            else {
              uint64_t v73 = *(void *)&v152[8];
            }
            char v74 = sub_1001FD17C(&buf[0].__r_.__value_.__l.__cap_, (uint64_t)v72, v73);
            sub_1001FD17C(v74, (uint64_t)" ", 1LL);
            if (SBYTE7(v153[0]) < 0) {
              operator delete(*(void **)v152);
            }
            v71 += 20;
          }

          while (v71 != v146);
          uint64_t v75 = (os_log_s *)qword_1008F75B8;
          if (os_log_type_enabled((os_log_t)qword_1008F75B8, OS_LOG_TYPE_DEFAULT))
          {
            std::stringbuf::str((std::stringbuf::string_type *)v152, (const std::stringbuf *)&buf[1]);
            int v76 = v152;
            if (SBYTE7(v153[0]) < 0) {
              int v76 = *(uint8_t **)v152;
            }
            LODWORD(v148.__r_.__value_.__l.__data_) = 136446210;
            *(std::string::size_type *)((char *)v148.__r_.__value_.__r.__words + 4) = (std::string::size_type)v76;
            _os_log_impl( (void *)&_mh_execute_header,  v75,  OS_LOG_TYPE_DEFAULT,  "statedump:       Services: %{public}s",  (uint8_t *)&v148,  0xCu);
            if (SBYTE7(v153[0]) < 0) {
              operator delete(*(void **)v152);
            }
          }
        }

        if (&v145 != (void **)(v137 + 32)) {
          sub_100050224( &v145,  *(__int128 **)(v137 + 32),  *(__int128 **)(v137 + 40),  0xCCCCCCCCCCCCCCCDLL * ((uint64_t)(*(void *)(v137 + 40) - *(void *)(v137 + 32)) >> 2));
        }
        memset(v152, 0, sizeof(v152));
        *(void *)&v153[0] = 0LL;
        std::string::operator=((std::string *)&v162[1], (const std::string *)v152);
        sub_1002D50A0((uint64_t)&buf[1]);
        if (SBYTE7(v153[0]) < 0) {
          operator delete(*(void **)v152);
        }
        uint64_t v78 = (char *)v145;
        int v77 = v146;
        while (v78 != v77)
        {
          sub_1006344B4((uint64_t)v78, v152);
          if ((SBYTE7(v153[0]) & 0x80u) == 0) {
            uint64_t v79 = v152;
          }
          else {
            uint64_t v79 = *(uint8_t **)v152;
          }
          if ((SBYTE7(v153[0]) & 0x80u) == 0) {
            uint64_t v80 = BYTE7(v153[0]);
          }
          else {
            uint64_t v80 = *(void *)&v152[8];
          }
          uint64_t v81 = sub_1001FD17C(&buf[0].__r_.__value_.__l.__cap_, (uint64_t)v79, v80);
          sub_1001FD17C(v81, (uint64_t)" ", 1LL);
          if (SBYTE7(v153[0]) < 0) {
            operator delete(*(void **)v152);
          }
          v78 += 20;
        }

        uint64_t v82 = (os_log_s *)qword_1008F75B8;
        if (os_log_type_enabled((os_log_t)qword_1008F75B8, OS_LOG_TYPE_DEFAULT))
        {
          std::stringbuf::str((std::stringbuf::string_type *)v152, (const std::stringbuf *)&buf[1]);
          char v83 = v152;
          if (SBYTE7(v153[0]) < 0) {
            char v83 = *(uint8_t **)v152;
          }
          LODWORD(v148.__r_.__value_.__l.__data_) = 136446210;
          *(std::string::size_type *)((char *)v148.__r_.__value_.__r.__words + 4) = (std::string::size_type)v83;
          _os_log_impl( (void *)&_mh_execute_header,  v82,  OS_LOG_TYPE_DEFAULT,  "statedump:       Solicited Services: %{public}s",  (uint8_t *)&v148,  0xCu);
          if (SBYTE7(v153[0]) < 0) {
            operator delete(*(void **)v152);
          }
          uint64_t v82 = (os_log_s *)qword_1008F75B8;
        }

        if (os_log_type_enabled(v82, OS_LOG_TYPE_DEFAULT))
        {
          int v84 = "YES";
          if (!*(_BYTE *)(v137 + 2)) {
            int v84 = "NO";
          }
          *(_DWORD *)BOOL v152 = 136446210;
          *(void *)&v152[4] = v84;
          _os_log_impl( (void *)&_mh_execute_header,  v82,  OS_LOG_TYPE_DEFAULT,  "statedump:       Requires active scan:%{public}s",  v152,  0xCu);
          uint64_t v82 = (os_log_s *)qword_1008F75B8;
        }

        if (os_log_type_enabled(v82, OS_LOG_TYPE_DEFAULT))
        {
          int v85 = *(_DWORD *)(v136[5] + 96LL);
          *(_DWORD *)BOOL v152 = 67109120;
          *(_DWORD *)&v152[4] = v85;
          _os_log_impl( (void *)&_mh_execute_header,  v82,  OS_LOG_TYPE_DEFAULT,  "statedump:       scan level:%d",  v152,  8u);
          uint64_t v82 = (os_log_s *)qword_1008F75B8;
        }

        if (os_log_type_enabled(v82, OS_LOG_TYPE_DEFAULT))
        {
          id v86 = "YES";
          if (!*(_BYTE *)(*(void *)(v136[5] + 8LL) + 3LL)) {
            id v86 = "NO";
          }
          *(_DWORD *)BOOL v152 = 136446210;
          *(void *)&v152[4] = v86;
          _os_log_impl( (void *)&_mh_execute_header,  v82,  OS_LOG_TYPE_DEFAULT,  "statedump:       Allowed in paused:%{public}s",  v152,  0xCu);
          uint64_t v82 = (os_log_s *)qword_1008F75B8;
        }

        if (os_log_type_enabled(v82, OS_LOG_TYPE_DEFAULT))
        {
          unsigned int v87 = "YES";
          if (!*(_BYTE *)(*(void *)(v136[5] + 8LL) + 142LL)) {
            unsigned int v87 = "NO";
          }
          *(_DWORD *)BOOL v152 = 136446210;
          *(void *)&v152[4] = v87;
          _os_log_impl( (void *)&_mh_execute_header,  v82,  OS_LOG_TYPE_DEFAULT,  "statedump:       Power assertion:%{public}s",  v152,  0xCu);
        }

        uint64_t v88 = (os_log_s *)qword_1008F76D8;
        if (os_log_type_enabled((os_log_t)qword_1008F76D8, OS_LOG_TYPE_DEFAULT))
        {
          id v89 = "YES";
          if (!*(_BYTE *)(*(void *)(v136[5] + 8LL) + 143LL)) {
            id v89 = "NO";
          }
          *(_DWORD *)BOOL v152 = 136446210;
          *(void *)&v152[4] = v89;
          _os_log_impl( (void *)&_mh_execute_header,  v88,  OS_LOG_TYPE_DEFAULT,  "statedump:       Exposure Notification:%{public}s",  v152,  0xCu);
        }

        if (*(_BYTE *)(v137 + 120))
        {
          int v90 = (os_log_s *)qword_1008F75B8;
          if (os_log_type_enabled((os_log_t)qword_1008F75B8, OS_LOG_TYPE_DEFAULT))
          {
            int v91 = *(unsigned __int8 *)(v137 + 136);
            int v93 = *(_DWORD *)(v137 + 128);
            int v92 = *(_DWORD *)(v137 + 132);
            *(_DWORD *)BOOL v152 = 67109632;
            *(_DWORD *)&v152[4] = v93;
            *(_WORD *)&v152[8] = 1024;
            *(_DWORD *)&v152[10] = v92;
            *(_WORD *)&v152[14] = 1024;
            LODWORD(v153[0]) = v91;
            _os_log_impl( (void *)&_mh_execute_header,  v90,  OS_LOG_TYPE_DEFAULT,  "statedump:       requested interval:%d window:%d active:%d",  v152,  0x14u);
          }
        }

        char v94 = *(_BYTE *)(v137 + 122);
        if ((v94 & 1) != 0)
        {
          unsigned __int8 v95 = (os_log_s *)qword_1008F75B8;
          if (os_log_type_enabled((os_log_t)qword_1008F75B8, OS_LOG_TYPE_DEFAULT))
          {
            *(_WORD *)BOOL v152 = 0;
            _os_log_impl( (void *)&_mh_execute_header,  v95,  OS_LOG_TYPE_DEFAULT,  "statedump:       HW ObjectDiscovery Wild",  v152,  2u);
            char v94 = *(_BYTE *)(v137 + 122);
          }
        }

        if ((v94 & 2) != 0)
        {
          char v96 = (os_log_s *)qword_1008F75B8;
          if (os_log_type_enabled((os_log_t)qword_1008F75B8, OS_LOG_TYPE_DEFAULT))
          {
            *(_WORD *)BOOL v152 = 0;
            _os_log_impl( (void *)&_mh_execute_header,  v96,  OS_LOG_TYPE_DEFAULT,  "statedump:       HW ObjectDiscovery Near Owner",  v152,  2u);
          }
        }

        __int16 v97 = *(_WORD *)(v137 + 124);
        if ((v97 & 1) != 0)
        {
          id v98 = (os_log_s *)qword_1008F75B8;
          if (os_log_type_enabled((os_log_t)qword_1008F75B8, OS_LOG_TYPE_DEFAULT))
          {
            *(_WORD *)BOOL v152 = 0;
            _os_log_impl( (void *)&_mh_execute_header,  v98,  OS_LOG_TYPE_DEFAULT,  "statedump:       HW AOP BT Buffer ADPD",  v152,  2u);
            __int16 v97 = *(_WORD *)(v137 + 124);
          }
        }

        if ((v97 & 2) != 0)
        {
          id v99 = (os_log_s *)qword_1008F75B8;
          if (os_log_type_enabled((os_log_t)qword_1008F75B8, OS_LOG_TYPE_DEFAULT))
          {
            *(_WORD *)BOOL v152 = 0;
            _os_log_impl( (void *)&_mh_execute_header,  v99,  OS_LOG_TYPE_DEFAULT,  "statedump:       HW AOP BT Buffer All",  v152,  2u);
          }
        }

        uint64_t v100 = *(void *)(v137 + 64);
        uint64_t v101 = *(void *)(v137 + 72);
        while (v100 != v101)
        {
          uint64_t v102 = (os_log_s *)qword_1008F75B8;
          if (*(_BYTE *)(v100 + 64) && os_log_type_enabled((os_log_t)qword_1008F75B8, OS_LOG_TYPE_DEFAULT))
          {
            int v103 = *(unsigned __int8 *)(v100 + 8);
            *(_DWORD *)BOOL v152 = 67109120;
            *(_DWORD *)&v152[4] = v103;
            _os_log_impl( (void *)&_mh_execute_header,  v102,  OS_LOG_TYPE_DEFAULT,  "statedump:       ObjectLocator type %x",  v152,  8u);
            uint64_t v102 = (os_log_s *)qword_1008F75B8;
          }

          if (os_log_type_enabled(v102, OS_LOG_TYPE_DEFAULT))
          {
            int v104 = *(unsigned __int8 *)(v100 + 8);
            int v105 = *(_DWORD *)(v100 + 80);
            int v106 = *(_DWORD *)(v100 + 84);
            int v107 = *(_DWORD *)(v100 + 88);
            *(_DWORD *)BOOL v152 = 67109888;
            *(_DWORD *)&v152[4] = v104;
            *(_WORD *)&v152[8] = 1024;
            *(_DWORD *)&v152[10] = v105;
            *(_WORD *)&v152[14] = 1024;
            LODWORD(v153[0]) = v106;
            WORD2(v153[0]) = 1024;
            *(_DWORD *)((char *)v153 + 6) = v107;
            _os_log_impl( (void *)&_mh_execute_header,  v102,  OS_LOG_TYPE_DEFAULT,  "statedump:       Puck: %d  %d/%d/%d",  v152,  0x1Au);
          }

          id v108 = *(id *)(v100 + 72);
          if (v108)
          {
            int v109 = v108;
            id v110 = *(id *)(v100 + 72);
            BOOL v111 = [v110 count] == 0;

            if (!v111)
            {
              uint64_t v158 = 0LL;
              __int128 v156 = 0u;
              memset(v157, 0, sizeof(v157));
              *(_OWORD *)std::stringbuf::string_type __p = 0u;
              __int128 v155 = 0u;
              memset(v153, 0, sizeof(v153));
              *(_OWORD *)BOOL v152 = 0u;
              sub_1001FCFC8((uint64_t)v152);
              __int128 v143 = 0u;
              __int128 v144 = 0u;
              __int128 v141 = 0u;
              __int128 v142 = 0u;
              id v112 = *(id *)(v100 + 72);
              id v113 = [v112 countByEnumeratingWithState:&v141 objects:v151 count:16];
              if (v113)
              {
                uint64_t v114 = *(void *)v142;
                do
                {
                  for (uint64_t i = 0LL; i != v113; uint64_t i = (char *)i + 1)
                  {
                    if (*(void *)v142 != v114) {
                      objc_enumerationMutation(v112);
                    }
                    uint64_t v116 = sub_1005E2B18((int)[*(id *)(*((void *)&v141 + 1) + 8 * (void)i) longLongValue]);
                    size_t v117 = strlen(v116);
                    uint64_t v118 = sub_1001FD17C(v153, (uint64_t)v116, v117);
                    sub_1001FD17C(v118, (uint64_t)" ", 1LL);
                  }

                  id v113 = [v112 countByEnumeratingWithState:&v141 objects:v151 count:16];
                }

                while (v113);
              }

              __int128 v119 = (os_log_s *)qword_1008F75B8;
              if (os_log_type_enabled((os_log_t)qword_1008F75B8, OS_LOG_TYPE_DEFAULT))
              {
                std::stringbuf::str(&v148, (const std::stringbuf *)((char *)v153 + 8));
                __int128 v120 = &v148;
                if ((v148.__r_.__value_.__s.__size_ & 0x80u) != 0) {
                  __int128 v120 = (std::stringbuf::string_type *)v148.__r_.__value_.__r.__words[0];
                }
                *(_DWORD *)unsigned __int16 v149 = 136315138;
                BOOL v150 = v120;
                _os_log_impl( (void *)&_mh_execute_header,  v119,  OS_LOG_TYPE_DEFAULT,  "statedump:             UseCaseList: %s",  v149,  0xCu);
              }

              *(void *)BOOL v152 = v139;
              *(void *)&v152[*(void *)(v139 - 24)] = v138;
              *(void *)&v153[0] = v140;
              if (SHIBYTE(v155) < 0) {
                operator delete(__p[1]);
              }
              std::streambuf::~streambuf((char *)v153 + 8);
              std::ios::~ios(v157);
            }
          }

          v100 += 96LL;
        }

        __int128 v121 = (os_log_s *)qword_1008F75B8;
        if (os_log_type_enabled((os_log_t)qword_1008F75B8, OS_LOG_TYPE_DEFAULT))
        {
          __int128 v122 = "YES";
          if (!*(_BYTE *)(v137 + 200)) {
            __int128 v122 = "NO";
          }
          *(_DWORD *)BOOL v152 = 136446210;
          *(void *)&v152[4] = v122;
          _os_log_impl( (void *)&_mh_execute_header,  v121,  OS_LOG_TYPE_DEFAULT,  "statedump:       Requires double boost scan: %{public}s",  v152,  0xCu);
        }

        sub_100615DAC(v136[5]);
        buf[0].__r_.__value_.__r.__words[0] = v139;
        *(std::string::size_type *)((char *)buf[0].__r_.__value_.__r.__words + *(void *)(v139 - 24)) = v138;
        buf[0].__r_.__value_.__l.__cap_ = v140;
        if (SHIBYTE(v163) < 0) {
          operator delete(v162[1]);
        }
        std::streambuf::~streambuf(&buf[1]);
        std::ios::~ios(v165);
        if (v145)
        {
          unsigned int v146 = (char *)v145;
          operator delete(v145);
        }

        char v123 = v136;
        int v124 = (void *)v136[1];
        if (v124)
        {
          do
          {
            __int128 v125 = v124;
            int v124 = (void *)*v124;
          }

          while (v124);
        }

        else
        {
          do
          {
            __int128 v125 = (void *)v123[2];
            BOOL v51 = *v125 == (void)v123;
            char v123 = v125;
          }

          while (!v51);
        }

        unsigned __int16 v66 = v125;
      }

      while (v125 != (void *)(a1 + 2048));
    }
  }

  __int128 v126 = (os_log_s *)qword_1008F75B8;
  if (os_log_type_enabled((os_log_t)qword_1008F75B8, OS_LOG_TYPE_DEFAULT))
  {
    LOWORD(buf[0].__r_.__value_.__l.__data_) = 0;
    _os_log_impl( (void *)&_mh_execute_header,  v126,  OS_LOG_TYPE_DEFAULT,  "statedump: Configured ObjectLocator MatchTables:",  (uint8_t *)buf,  2u);
    __int128 v126 = (os_log_s *)qword_1008F75B8;
  }

  __int128 v127 = *(void **)(a1 + 1816);
  if (v127 != (void *)(a1 + 1824))
  {
    do
    {
      if (os_log_type_enabled(v126, OS_LOG_TYPE_DEFAULT))
      {
        int v128 = *((unsigned __int16 *)v127 + 18);
        int v129 = *((unsigned __int16 *)v127 + 15);
        int v130 = *((unsigned __int8 *)v127 + 28);
        BOOL v131 = *((_WORD *)v127 + 16) != 0;
        BOOL v132 = *((unsigned __int16 *)v127 + 17) != 0;
        LODWORD(buf[0].__r_.__value_.__l.__data_) = 67110144;
        HIDWORD(buf[0].__r_.__value_.__r.__words[0]) = v130;
        LOWORD(buf[0].__r_.__value_.__r.__words[1]) = 1024;
        *(_DWORD *)((char *)&buf[0].__r_.__value_.__r.__words[1] + 2) = v129;
        HIWORD(buf[0].__r_.__value_.__r.__words[1]) = 1024;
        LODWORD(buf[0].__r_.__value_.__r.__words[2]) = v128;
        WORD2(buf[0].__r_.__value_.__r.__words[2]) = 1024;
        *(_DWORD *)((char *)&buf[0].__r_.__value_.__r.__words[2] + 6) = v131;
        *(_WORD *)&buf[1].__r_.__value_.__s.__data_[2] = 1024;
        HIDWORD(buf[1].__r_.__value_.__r.__words[0]) = v132;
        _os_log_impl( (void *)&_mh_execute_header,  v126,  OS_LOG_TYPE_DEFAULT,  "statedump: \tType:%x handle:%d Length:%d created:%d enabled:%d",  (uint8_t *)buf,  0x20u);
        __int128 v126 = (os_log_s *)qword_1008F75B8;
      }

      unsigned int v133 = (void *)v127[1];
      if (v133)
      {
        do
        {
          __int128 v134 = v133;
          unsigned int v133 = (void *)*v133;
        }

        while (v133);
      }

      else
      {
        do
        {
          __int128 v134 = (void *)v127[2];
          BOOL v51 = *v134 == (void)v127;
          __int128 v127 = v134;
        }

        while (!v51);
      }

      __int128 v127 = v134;
    }

    while (v134 != (void *)(a1 + 1824));
  }

  if (os_log_type_enabled(v126, OS_LOG_TYPE_DEFAULT))
  {
    LOWORD(buf[0].__r_.__value_.__l.__data_) = 0;
    _os_log_impl( (void *)&_mh_execute_header,  v126,  OS_LOG_TYPE_DEFAULT,  "statedump: Configured Payload encryption keys:",  (uint8_t *)buf,  2u);
  }

  [*(id *)(a1 + 2088) enumerateKeysAndObjectsWithOptions:1 usingBlock:&stru_1008A3E50];
  sub_10060C17C(a1);
  sub_1005EF7DC(a1);
  sub_1005F0204(a1);
  sub_10060C940(a1);
}

void sub_10060BF5C( _Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20, uint64_t a21, uint64_t a22, uint64_t a23, uint64_t a24, uint64_t a25, uint64_t a26, uint64_t a27, uint64_t a28, uint64_t a29, uint64_t a30, uint64_t a31, uint64_t a32, uint64_t a33, uint64_t a34, uint64_t a35, uint64_t a36, uint64_t a37, uint64_t a38, uint64_t a39, uint64_t a40, uint64_t a41, uint64_t a42, uint64_t a43, void *a44)
{
  STACK[0x300] = a31;
  *(unint64_t *)((char *)&STACK[0x300] + *(void *)(a31 - 24)) = a30;
  STACK[0x310] = a32;
  if (SLOBYTE(STACK[0x36F]) < 0) {
    operator delete((void *)STACK[0x358]);
  }
  std::streambuf::~streambuf(a18);
  std::ios::~ios(a14);
  if (a44) {
    operator delete(a44);
  }
  _Unwind_Resume(a1);
}

void sub_10060C0A8(id a1, id a2, id a3, BOOL *a4)
{
  uint64_t v6 = (os_log_s *)qword_1008F75B8;
  if (os_log_type_enabled((os_log_t)qword_1008F75B8, OS_LOG_TYPE_DEFAULT))
  {
    int v7 = 141558787;
    uint64_t v8 = 1752392040LL;
    __int16 v9 = 2113;
    id v10 = a2;
    __int16 v11 = 2160;
    uint64_t v12 = 1752392040LL;
    __int16 v13 = 2113;
    id v14 = a3;
    _os_log_impl( (void *)&_mh_execute_header,  v6,  OS_LOG_TYPE_DEFAULT,  "statedump:       %{private, mask.hash}@ --> %{private, mask.hash}@",  (uint8_t *)&v7,  0x2Au);
  }

void sub_10060C17C(uint64_t a1)
{
  int v2 = (os_log_s *)qword_1008F75B8;
  if (os_log_type_enabled((os_log_t)qword_1008F75B8, OS_LOG_TYPE_DEFAULT))
  {
    *(_WORD *)std::stringbuf::string_type buf = 0;
    _os_log_impl( (void *)&_mh_execute_header,  v2,  OS_LOG_TYPE_DEFAULT,  "statedump: BLE Scan Configuration Stat:",  buf,  2u);
  }

  sub_10060D4C8(a1);
  double Current = CFAbsoluteTimeGetCurrent();
  uint64_t v4 = 0LL;
  uint64_t v5 = (os_log_s *)qword_1008F75B8;
  char v6 = 1;
  do
  {
    char v7 = v6;
    double v8 = *(double *)(a1 + 176 * v4 + 2360);
    if (Current >= v8) {
      double v9 = Current - v8;
    }
    else {
      double v9 = 0.0;
    }
    if (os_log_type_enabled(v5, OS_LOG_TYPE_DEFAULT))
    {
      id v10 = "screen off";
      if ((v7 & 1) != 0) {
        id v10 = "screen on";
      }
      *(_DWORD *)std::stringbuf::string_type buf = 136315138;
      double v33 = *(double *)&v10;
      _os_log_impl( (void *)&_mh_execute_header,  v5,  OS_LOG_TYPE_DEFAULT,  "statedump: \t=================== LE Scan Configuration Stats when %s ===================",  buf,  0xCu);
      uint64_t v5 = (os_log_s *)qword_1008F75B8;
    }

    if (os_log_type_enabled(v5, OS_LOG_TYPE_DEFAULT))
    {
      *(_DWORD *)std::stringbuf::string_type buf = 134217984;
      double v33 = v9;
      _os_log_impl( (void *)&_mh_execute_header,  v5,  OS_LOG_TYPE_DEFAULT,  "statedump: \tBLE Scan Configuration Stats started %f sec ago",  buf,  0xCu);
      uint64_t v5 = (os_log_s *)qword_1008F75B8;
    }

    if (os_log_type_enabled(v5, OS_LOG_TYPE_DEFAULT))
    {
      int v11 = *(_DWORD *)(a1 + 176 * v4 + 2448);
      *(_DWORD *)std::stringbuf::string_type buf = 67109120;
      LODWORD(v33) = v11;
      _os_log_impl( (void *)&_mh_execute_header,  v5,  OS_LOG_TYPE_DEFAULT,  "statedump: \tBLE Scan Configuration Count: %u",  buf,  8u);
      uint64_t v5 = (os_log_s *)qword_1008F75B8;
    }

    if (os_log_type_enabled(v5, OS_LOG_TYPE_DEFAULT))
    {
      int v12 = *(_DWORD *)(a1 + 176 * v4 + 2452);
      *(_DWORD *)std::stringbuf::string_type buf = 67109120;
      LODWORD(v33) = v12;
      _os_log_impl( (void *)&_mh_execute_header,  v5,  OS_LOG_TYPE_DEFAULT,  "statedump: \tBLE Scan Configuration Count hasParamUpdate : %u",  buf,  8u);
      uint64_t v5 = (os_log_s *)qword_1008F75B8;
    }

    if (os_log_type_enabled(v5, OS_LOG_TYPE_DEFAULT))
    {
      int v13 = *(_DWORD *)(a1 + 176 * v4 + 2456);
      *(_DWORD *)std::stringbuf::string_type buf = 67109120;
      LODWORD(v33) = v13;
      _os_log_impl( (void *)&_mh_execute_header,  v5,  OS_LOG_TYPE_DEFAULT,  "statedump: \tBLE Scan Configuration Count needFWScanRestart : %u",  buf,  8u);
      uint64_t v5 = (os_log_s *)qword_1008F75B8;
    }

    if (os_log_type_enabled(v5, OS_LOG_TYPE_DEFAULT))
    {
      int v14 = *(_DWORD *)(a1 + 176 * v4 + 2464);
      *(_DWORD *)std::stringbuf::string_type buf = 67109120;
      LODWORD(v33) = v14;
      _os_log_impl( (void *)&_mh_execute_header,  v5,  OS_LOG_TYPE_DEFAULT,  "statedump: \tBLE Scan Configuration Count needNoFWScanRestart : %u",  buf,  8u);
      uint64_t v5 = (os_log_s *)qword_1008F75B8;
    }

    if (os_log_type_enabled(v5, OS_LOG_TYPE_DEFAULT))
    {
      int v15 = *(_DWORD *)(a1 + 176 * v4 + 2484);
      *(_DWORD *)std::stringbuf::string_type buf = 67109120;
      LODWORD(v33) = v15;
      _os_log_impl( (void *)&_mh_execute_header,  v5,  OS_LOG_TYPE_DEFAULT,  "statedump: \tBLE Scan Configuration Count hasMatchingRuleUpdate : %u",  buf,  8u);
      uint64_t v5 = (os_log_s *)qword_1008F75B8;
    }

    if (os_log_type_enabled(v5, OS_LOG_TYPE_DEFAULT))
    {
      int v16 = *(_DWORD *)(a1 + 176 * v4 + 2480);
      *(_DWORD *)std::stringbuf::string_type buf = 67109120;
      LODWORD(v33) = v16;
      _os_log_impl( (void *)&_mh_execute_header,  v5,  OS_LOG_TYPE_DEFAULT,  "statedump: \tBLE Scan Configuration Count hasMatchingAddressUpdate : %u",  buf,  8u);
      uint64_t v5 = (os_log_s *)qword_1008F75B8;
    }

    if (os_log_type_enabled(v5, OS_LOG_TYPE_DEFAULT))
    {
      int v17 = *(_DWORD *)(a1 + 176 * v4 + 2476);
      *(_DWORD *)std::stringbuf::string_type buf = 67109120;
      LODWORD(v33) = v17;
      _os_log_impl( (void *)&_mh_execute_header,  v5,  OS_LOG_TYPE_DEFAULT,  "statedump: \tBLE Scan Configuration Count hasPCFUpdate : %u",  buf,  8u);
      uint64_t v5 = (os_log_s *)qword_1008F75B8;
    }

    if (os_log_type_enabled(v5, OS_LOG_TYPE_DEFAULT))
    {
      int v18 = *(_DWORD *)(a1 + 176 * v4 + 2472);
      *(_DWORD *)std::stringbuf::string_type buf = 67109120;
      LODWORD(v33) = v18;
      _os_log_impl( (void *)&_mh_execute_header,  v5,  OS_LOG_TYPE_DEFAULT,  "statedump: \tBLE Scan Configuration Count hasZoneUpdate : %u",  buf,  8u);
      uint64_t v5 = (os_log_s *)qword_1008F75B8;
    }

    if (os_log_type_enabled(v5, OS_LOG_TYPE_DEFAULT))
    {
      int v19 = *(_DWORD *)(a1 + 176 * v4 + 2488);
      *(_DWORD *)std::stringbuf::string_type buf = 67109120;
      LODWORD(v33) = v19;
      _os_log_impl( (void *)&_mh_execute_header,  v5,  OS_LOG_TYPE_DEFAULT,  "statedump: \tBLE Scan Configuration Count hasAdvMatchBufUpdate : %u",  buf,  8u);
      uint64_t v5 = (os_log_s *)qword_1008F75B8;
    }

    if (os_log_type_enabled(v5, OS_LOG_TYPE_DEFAULT))
    {
      int v20 = *(unsigned __int16 *)(a1 + 176 * v4 + 2492);
      *(_DWORD *)std::stringbuf::string_type buf = 67109120;
      LODWORD(v33) = v20;
      _os_log_impl( (void *)&_mh_execute_header,  v5,  OS_LOG_TYPE_DEFAULT,  "statedump: \tBLE Scan Configuration Min: %u ms",  buf,  8u);
      uint64_t v5 = (os_log_s *)qword_1008F75B8;
    }

    if (os_log_type_enabled(v5, OS_LOG_TYPE_DEFAULT))
    {
      int v21 = *(unsigned __int16 *)(a1 + 176 * v4 + 2494);
      *(_DWORD *)std::stringbuf::string_type buf = 67109120;
      LODWORD(v33) = v21;
      _os_log_impl( (void *)&_mh_execute_header,  v5,  OS_LOG_TYPE_DEFAULT,  "statedump: \tBLE Scan Configuration Max: %u ms",  buf,  8u);
      uint64_t v5 = (os_log_s *)qword_1008F75B8;
    }

    if (os_log_type_enabled(v5, OS_LOG_TYPE_DEFAULT))
    {
      int v22 = *(unsigned __int16 *)(a1 + 176 * v4 + 2496);
      *(_DWORD *)std::stringbuf::string_type buf = 67109120;
      LODWORD(v33) = v22;
      _os_log_impl( (void *)&_mh_execute_header,  v5,  OS_LOG_TYPE_DEFAULT,  "statedump: \tBLE Scan Configuration Average: %u ms",  buf,  8u);
      uint64_t v5 = (os_log_s *)qword_1008F75B8;
    }

    if (os_log_type_enabled(v5, OS_LOG_TYPE_DEFAULT))
    {
      int v23 = *(unsigned __int16 *)(a1 + 176 * v4 + 2498);
      *(_DWORD *)std::stringbuf::string_type buf = 67109120;
      LODWORD(v33) = v23;
      _os_log_impl( (void *)&_mh_execute_header,  v5,  OS_LOG_TYPE_DEFAULT,  "statedump: \tBLE Scan Configuration 5 Percentile: %u ms",  buf,  8u);
      uint64_t v5 = (os_log_s *)qword_1008F75B8;
    }

    if (os_log_type_enabled(v5, OS_LOG_TYPE_DEFAULT))
    {
      int v24 = *(unsigned __int16 *)(a1 + 176 * v4 + 2500);
      *(_DWORD *)std::stringbuf::string_type buf = 67109120;
      LODWORD(v33) = v24;
      _os_log_impl( (void *)&_mh_execute_header,  v5,  OS_LOG_TYPE_DEFAULT,  "statedump: \tBLE Scan Configuration 25 Percentile: %u ms",  buf,  8u);
      uint64_t v5 = (os_log_s *)qword_1008F75B8;
    }

    if (os_log_type_enabled(v5, OS_LOG_TYPE_DEFAULT))
    {
      int v25 = *(unsigned __int16 *)(a1 + 176 * v4 + 2502);
      *(_DWORD *)std::stringbuf::string_type buf = 67109120;
      LODWORD(v33) = v25;
      _os_log_impl( (void *)&_mh_execute_header,  v5,  OS_LOG_TYPE_DEFAULT,  "statedump: \tBLE Scan Configuration 50 Percentile: %u ms",  buf,  8u);
      uint64_t v5 = (os_log_s *)qword_1008F75B8;
    }

    if (os_log_type_enabled(v5, OS_LOG_TYPE_DEFAULT))
    {
      int v26 = *(unsigned __int16 *)(a1 + 176 * v4 + 2504);
      *(_DWORD *)std::stringbuf::string_type buf = 67109120;
      LODWORD(v33) = v26;
      _os_log_impl( (void *)&_mh_execute_header,  v5,  OS_LOG_TYPE_DEFAULT,  "statedump: \tBLE Scan Configuration 75 Percentile: %u ms",  buf,  8u);
      uint64_t v5 = (os_log_s *)qword_1008F75B8;
    }

    if (os_log_type_enabled(v5, OS_LOG_TYPE_DEFAULT))
    {
      int v27 = *(unsigned __int16 *)(a1 + 176 * v4 + 2506);
      *(_DWORD *)std::stringbuf::string_type buf = 67109120;
      LODWORD(v33) = v27;
      _os_log_impl( (void *)&_mh_execute_header,  v5,  OS_LOG_TYPE_DEFAULT,  "statedump: \tBLE Scan Configuration 95 Percentile: %u ms",  buf,  8u);
      uint64_t v5 = (os_log_s *)qword_1008F75B8;
    }

    if (os_log_type_enabled(v5, OS_LOG_TYPE_DEFAULT))
    {
      int v28 = *(unsigned __int16 *)(a1 + 176 * v4 + 2516);
      *(_DWORD *)std::stringbuf::string_type buf = 67109120;
      LODWORD(v33) = v28;
      _os_log_impl( (void *)&_mh_execute_header,  v5,  OS_LOG_TYPE_DEFAULT,  "statedump: \tBLE Scan Configuration Average HeySiri UseCase: %u ms",  buf,  8u);
      uint64_t v5 = (os_log_s *)qword_1008F75B8;
    }

    if (os_log_type_enabled(v5, OS_LOG_TYPE_DEFAULT))
    {
      int v29 = *(_DWORD *)(a1 + 176 * v4 + 2508);
      *(_DWORD *)std::stringbuf::string_type buf = 67109120;
      LODWORD(v33) = v29;
      _os_log_impl( (void *)&_mh_execute_header,  v5,  OS_LOG_TYPE_DEFAULT,  "statedump: \tBLE Scan Configuration Count HeySiri UseCase: %u",  buf,  8u);
      uint64_t v5 = (os_log_s *)qword_1008F75B8;
    }

    if (os_log_type_enabled(v5, OS_LOG_TYPE_DEFAULT))
    {
      int v30 = *(unsigned __int16 *)(a1 + 176 * v4 + 2528);
      *(_DWORD *)std::stringbuf::string_type buf = 67109120;
      LODWORD(v33) = v30;
      _os_log_impl( (void *)&_mh_execute_header,  v5,  OS_LOG_TYPE_DEFAULT,  "statedump: \tBLE Scan Configuration Average Sharing UseCases: %u ms",  buf,  8u);
      uint64_t v5 = (os_log_s *)qword_1008F75B8;
    }

    if (os_log_type_enabled(v5, OS_LOG_TYPE_DEFAULT))
    {
      int v31 = *(_DWORD *)(a1 + 176 * v4 + 2520);
      *(_DWORD *)std::stringbuf::string_type buf = 67109120;
      LODWORD(v33) = v31;
      _os_log_impl( (void *)&_mh_execute_header,  v5,  OS_LOG_TYPE_DEFAULT,  "statedump: \tBLE Scan Configuration Count Sharing UseCase: %u",  buf,  8u);
      uint64_t v5 = (os_log_s *)qword_1008F75B8;
    }

    char v6 = 0;
    uint64_t v4 = 1LL;
  }

  while ((v7 & 1) != 0);
}

void sub_10060C940(uint64_t a1)
{
  uint64_t v2 = 0LL;
  uint64_t v3 = (os_log_s *)qword_1008F75B8;
  uint64_t v4 = -1632LL;
  do
  {
    if (os_log_type_enabled(v3, OS_LOG_TYPE_DEFAULT))
    {
      uint64_t v5 = @"UNKNOWN";
      uint64_t v6 = a1 + v4;
      int v7 = *(unsigned __int8 *)(a1 + v4 + 1792);
      int v8 = *(unsigned __int8 *)(a1 + v4 + 1793);
      int v9 = *(unsigned __int16 *)(a1 + v4 + 1794);
      int v10 = *(unsigned __int8 *)(a1 + v4 + 1796);
      int v11 = *(unsigned __int8 *)(a1 + v4 + 1797);
      int v12 = *(unsigned __int8 *)(a1 + v4 + 1798);
      if (*(_BYTE *)(a1 + v4 + 1799)) {
        int v13 = "YES";
      }
      else {
        int v13 = "NO";
      }
      if (*(_BYTE *)(v6 + 1800)) {
        int v14 = "YES";
      }
      else {
        int v14 = "NO";
      }
      int v15 = *(unsigned __int8 *)(v6 + 1804);
      int v16 = *(unsigned __int8 *)(v6 + 1805);
      int v17 = *(unsigned __int16 *)(v6 + 1806);
      uint64_t v18 = *(void *)(v6 + 1808);
      *(_DWORD *)std::stringbuf::string_type buf = 138546434;
      int v20 = v5;
      __int16 v21 = 1024;
      int v22 = v7;
      __int16 v23 = 1024;
      int v24 = v8;
      __int16 v25 = 1024;
      int v26 = v9;
      __int16 v27 = 1024;
      int v28 = v10;
      __int16 v29 = 1024;
      int v30 = v11;
      __int16 v31 = 1024;
      int v32 = v12;
      __int16 v33 = 2082;
      int v34 = v13;
      __int16 v35 = 2082;
      uint64_t v36 = v14;
      __int16 v37 = 1024;
      int v38 = v15;
      __int16 v39 = 1024;
      int v40 = v16;
      __int16 v41 = 1024;
      int v42 = v17;
      __int16 v43 = 2048;
      uint64_t v44 = v18;
      _os_log_impl( (void *)&_mh_execute_header,  v3,  OS_LOG_TYPE_DEFAULT,  "statedump: ADVBUFF(%{public}@): mask:0x%x advADType:0x%x advCompanyID:0x%x advType:0x%x minPayloadSize:%d buffEn tries:%d created:%{public}s enabled:%{public}s expectedEntries:%d statusMask:0x%x overflows:%d enabledTS:%f",  buf,  0x60u);
      uint64_t v3 = (os_log_s *)qword_1008F75B8;
    }

    ++v2;
    v4 += 544LL;
  }

  while (v4);
}

void sub_10060CB10(uint64_t a1, void *a2, uint64_t a3)
{
  id v5 = a2;
  if (v5)
  {
    if (a3)
    {
      uint64_t v6 = (void *)objc_claimAutoreleasedReturnValue(+[NSData dataWithBytes:length:](&OBJC_CLASS___NSData, "dataWithBytes:length:", a3, 16LL));
      [*(id *)(a1 + 2088) setObject:v6 forKeyedSubscript:v5];
    }

    else if (os_log_type_enabled((os_log_t)qword_1008F75B8, OS_LOG_TYPE_ERROR))
    {
      sub_10069E264();
    }
  }

  else if (os_log_type_enabled((os_log_t)qword_1008F75B8, OS_LOG_TYPE_ERROR))
  {
    sub_10069E238();
  }
}

void sub_10060CBD0(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_10060CBEC(uint64_t a1, unsigned __int8 *a2)
{
  uint64_t v3 = a2 + 1;
  uint64_t v4 = *(void **)(a1 + 2088);
  id v5 = sub_1005BFB9C(((unint64_t)a2[1] << 40) | ((unint64_t)a2[2] << 32) | ((unint64_t)a2[3] << 24) | ((unint64_t)a2[4] << 16) | ((unint64_t)a2[5] << 8) | a2[6] | ((unint64_t)*a2 << 48));
  uint64_t v6 = (void *)objc_claimAutoreleasedReturnValue(v5);
  [v4 removeObjectForKey:v6];

  if (qword_1008D5F50 != -1) {
    dispatch_once(&qword_1008D5F50, &stru_1008A4158);
  }
  LODWORD(v16) = *(_DWORD *)v3;
  WORD2(v16) = *((_WORD *)v3 + 2);
  int v7 = sub_1003FFEB0(off_1008D5F48, (uint64_t)&v16, 1);
  if (v7)
  {
    uint64_t v16 = 0LL;
    uint64_t v17 = 0LL;
    uint64_t v18 = 0LL;
    uint64_t v8 = v16;
    unint64_t v9 = 0xAAAAAAAAAAAAAAABLL * ((v17 - v16) >> 3);
    if (v9 < 4) {
      goto LABEL_32;
    }
    int v10 = (void *)(v16 + 72);
    if (*(char *)(v16 + 95) < 0)
    {
      if (*(void *)(v16 + 80) <= 1uLL) {
        goto LABEL_14;
      }
      int v10 = (void *)*v10;
    }

    else if (*(unsigned __int8 *)(v16 + 95) <= 1u)
    {
      goto LABEL_14;
    }

    int v11 = (void *)objc_claimAutoreleasedReturnValue(+[NSString stringWithUTF8String:](&OBJC_CLASS___NSString, "stringWithUTF8String:", v10));
    if ([v11 length]) {
      [*(id *)(a1 + 2088) removeObjectForKey:v11];
    }

    uint64_t v8 = v16;
    unint64_t v9 = 0xAAAAAAAAAAAAAAABLL * ((v17 - v16) >> 3);
LABEL_14:
    if (v9 < 9) {
      goto LABEL_32;
    }
    int v12 = (void *)(v8 + 192);
    if (*(char *)(v8 + 215) < 0)
    {
      if (*(void *)(v8 + 200) <= 1uLL) {
        goto LABEL_23;
      }
      int v12 = (void *)*v12;
    }

    else if (*(unsigned __int8 *)(v8 + 215) <= 1u)
    {
      goto LABEL_23;
    }

    int v13 = (void *)objc_claimAutoreleasedReturnValue(+[NSString stringWithUTF8String:](&OBJC_CLASS___NSString, "stringWithUTF8String:", v12));
    if ([v13 length]) {
      [*(id *)(a1 + 2088) removeObjectForKey:v13];
    }

    uint64_t v8 = v16;
    unint64_t v9 = 0xAAAAAAAAAAAAAAABLL * ((v17 - v16) >> 3);
LABEL_23:
    if (v9 >= 0xA)
    {
      int v14 = (void *)(v8 + 216);
      if ((*(char *)(v8 + 239) & 0x80000000) == 0)
      {
LABEL_29:
        int v15 = (void *)objc_claimAutoreleasedReturnValue(+[NSString stringWithUTF8String:](&OBJC_CLASS___NSString, "stringWithUTF8String:", v14));
        if ([v15 length]) {
          [*(id *)(a1 + 2088) removeObjectForKey:v15];
        }

        goto LABEL_32;
      }

      if (*(void *)(v8 + 224) > 1uLL)
      {
        int v14 = (void *)*v14;
        goto LABEL_29;
      }
    }

void sub_10060CE50( _Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, void **a12)
{
  a12 = (void **)&a9;
  sub_100024304(&a12);
  _Unwind_Resume(a1);
}

BOOL sub_10060CE98(uint64_t a1, void *a2, uint64_t a3)
{
  id v5 = a2;
  uint64_t v6 = (void *)objc_claimAutoreleasedReturnValue([*(id *)(a1 + 2088) objectForKey:v5]);
  int v7 = (os_log_s *)qword_1008F75B8;
  if (os_log_type_enabled((os_log_t)qword_1008F75B8, OS_LOG_TYPE_INFO))
  {
    int v10 = 141558787;
    uint64_t v11 = 1752392040LL;
    __int16 v12 = 2113;
    id v13 = v5;
    __int16 v14 = 2160;
    uint64_t v15 = 1752392040LL;
    __int16 v16 = 2113;
    uint64_t v17 = v6;
    _os_log_impl( (void *)&_mh_execute_header,  v7,  OS_LOG_TYPE_INFO,  "getDeviceEncryptionKey SN:%{private, mask.hash}@ key:%{private, mask.hash}@",  (uint8_t *)&v10,  0x2Au);
  }

  id v8 = [v6 length];
  if (v8) {
    [v6 getBytes:a3 length:16];
  }

  return v8 != 0LL;
}

void sub_10060CFBC(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

BOOL sub_10060CFE0(uint64_t a1, uint64_t a2, uint64_t a3)
{
  id v5 = *(void **)(a1 + 2088);
  id v6 = sub_1005BFB9C(a2);
  int v7 = (void *)objc_claimAutoreleasedReturnValue(v6);
  id v8 = (void *)objc_claimAutoreleasedReturnValue([v5 objectForKey:v7]);

  unint64_t v9 = (os_log_s *)qword_1008F75B8;
  if (os_log_type_enabled((os_log_t)qword_1008F75B8, OS_LOG_TYPE_INFO))
  {
    id v10 = sub_1005BFB9C(a2);
    uint64_t v11 = (void *)objc_claimAutoreleasedReturnValue(v10);
    int v14 = 138412803;
    uint64_t v15 = v11;
    __int16 v16 = 2160;
    uint64_t v17 = 1752392040LL;
    __int16 v18 = 2113;
    int v19 = v8;
    _os_log_impl( (void *)&_mh_execute_header,  v9,  OS_LOG_TYPE_INFO,  "getDeviceEncryptionKey address:%@ key:%{private, mask.hash}@",  (uint8_t *)&v14,  0x20u);
  }

  id v12 = [v8 length];
  if (v12) {
    [v8 getBytes:a3 length:16];
  }

  return v12 != 0LL;
}

void sub_10060D11C(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

uint64_t sub_10060D144(uint64_t a1, unint64_t a2, uint64_t a3)
{
  if (sub_10060CFE0(a1, a2, a3)) {
    return 1LL;
  }
  if (qword_1008D5F30 != -1) {
    dispatch_once(&qword_1008D5F30, &stru_1008A40B8);
  }
  sub_1005C8684((uint64_t)off_1008D5F28, a2, 0, 1u, 0LL, 0LL, v13);
  int v7 = sub_100241F94(v13);
  id v8 = (void *)objc_claimAutoreleasedReturnValue(v7);
  if (!v8) {
    goto LABEL_10;
  }
  if (qword_1008D5F30 != -1) {
    dispatch_once(&qword_1008D5F30, &stru_1008A40B8);
  }
  id v9 = sub_1005D7D88((uint64_t)off_1008D5F28, v8);
  id v10 = (void *)objc_claimAutoreleasedReturnValue(v9);
  BOOL v11 = sub_10060CE98(a1, v10, a3);

  if (v11) {
    uint64_t v6 = 1LL;
  }
  else {
LABEL_10:
  }
    uint64_t v6 = 0LL;

  return v6;
}

void sub_10060D284(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_10060D2A8(uint64_t a1, void *a2)
{
  id v3 = a2;
  uint64_t v4 = sub_100404FE8();
  v6[0] = _NSConcreteStackBlock;
  v6[1] = 3221225472LL;
  _DWORD v6[2] = sub_10060D358;
  uint64_t v6[3] = &unk_1008800B8;
  uint64_t v8 = a1;
  id v5 = v3;
  id v7 = v5;
  sub_100405384(v4, v6);
}

void sub_10060D338( _Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, void *a13)
{
  _Unwind_Resume(a1);
}

void sub_10060D358(uint64_t a1)
{
  uint64_t v1 = *(void *)(a1 + 40);
  uint64_t v2 = *(void **)(v1 + 2040);
  id v3 = (void *)(v1 + 2048);
  if (v2 != (void *)(v1 + 2048))
  {
    do
    {
      id v5 = (os_log_s *)qword_1008F75B8;
      if (os_log_type_enabled((os_log_t)qword_1008F75B8, OS_LOG_TYPE_INFO))
      {
        sub_100494958(v2[4], (uint64_t)__p);
        uint64_t v6 = v12 >= 0 ? __p : (void **)__p[0];
        uint64_t v7 = *(void *)(a1 + 32);
        *(_DWORD *)std::stringbuf::string_type buf = 136446466;
        int v14 = v6;
        __int16 v15 = 2114;
        uint64_t v16 = v7;
        _os_log_impl( (void *)&_mh_execute_header,  v5,  OS_LOG_TYPE_INFO,  "session %{public}s device %{public}@ invalidated",  buf,  0x16u);
        if (v12 < 0) {
          operator delete(__p[0]);
        }
      }

      sub_1006180AC(v2[5], *(void **)(a1 + 32));
      uint64_t v8 = (void *)v2[1];
      if (v8)
      {
        do
        {
          id v9 = v8;
          uint64_t v8 = (void *)*v8;
        }

        while (v8);
      }

      else
      {
        do
        {
          id v9 = (void *)v2[2];
          BOOL v10 = *v9 == (void)v2;
          uint64_t v2 = v9;
        }

        while (!v10);
      }

      uint64_t v2 = v9;
    }

    while (v9 != v3);
  }

void sub_10060D4C0(uint64_t a1, void *a2)
{
}

uint64_t sub_10060D4C8(uint64_t result)
{
  uint64_t v1 = 0LL;
  uint64_t v29 = result + 2368;
  char v2 = 1;
  uint64_t v30 = result;
  do
  {
    char v3 = v2;
    uint64_t v4 = result + 176 * v1;
    unsigned int v5 = *(_DWORD *)(v4 + 2448);
    if (v5)
    {
      char v32 = v3;
      uint64_t v6 = 0LL;
      int v7 = 0;
      int v8 = 0;
      int v9 = 0;
      int v10 = 0;
      int v11 = 0;
      unsigned int v12 = 0;
      unsigned int v13 = 0;
      __int16 v31 = (unsigned int *)(v4 + 2448);
      unsigned int v38 = v5 / 0x14;
      unsigned int v37 = v5 >> 2;
      unsigned int v36 = v5 >> 1;
      unsigned int v35 = (3 * v5) >> 2;
      unsigned int v34 = 19 * v5 / 0x14;
      int v14 = (os_log_s *)qword_1008F75B8;
      uint64_t v33 = v1;
      uint64_t v15 = v29 + 176 * v1;
      int v16 = 10;
      do
      {
        unsigned int v39 = v12;
        if (os_log_type_enabled(v14, OS_LOG_TYPE_DEFAULT))
        {
          int v17 = *(_DWORD *)(v15 + 4 * v6);
          *(_DWORD *)std::stringbuf::string_type buf = 67109376;
          int v41 = v6;
          __int16 v42 = 1024;
          int v43 = v17;
          _os_log_impl( (void *)&_mh_execute_header,  v14,  OS_LOG_TYPE_DEFAULT,  "statedump: \tBLE Scan Configuration Count Bucket %d Count: %u",  buf,  0xEu);
          int v14 = (os_log_s *)qword_1008F75B8;
        }

        int v18 = *(_DWORD *)(v15 + 4 * v6);
        unsigned int v12 = v39 + ((v16 * v18) >> 1);
        v13 += v18;
        if (v11) {
          BOOL v19 = 0;
        }
        else {
          BOOL v19 = v13 >= v38;
        }
        if (v19) {
          int v11 = v6;
        }
        if (v10) {
          BOOL v20 = 0;
        }
        else {
          BOOL v20 = v13 >= v37;
        }
        if (v20) {
          int v10 = v6;
        }
        if (v9) {
          BOOL v21 = 0;
        }
        else {
          BOOL v21 = v13 >= v36;
        }
        if (v21) {
          int v9 = v6;
        }
        if (v8) {
          BOOL v22 = 0;
        }
        else {
          BOOL v22 = v13 >= v35;
        }
        if (v22) {
          int v8 = v6;
        }
        if (v7) {
          BOOL v23 = 0;
        }
        else {
          BOOL v23 = v13 >= v34;
        }
        if (v23) {
          int v7 = v6;
        }
        ++v6;
        v16 += 20;
      }

      while (v6 != 20);
      uint64_t result = v30;
      uint64_t v24 = v30 + 176 * v33;
      *(_WORD *)(v24 + 249_Block_object_dispose(va, 8) = 10 * v11 + 5;
      *(_WORD *)(v24 + 2500) = 10 * v10 + 5;
      *(_WORD *)(v24 + 2502) = 10 * v9 + 5;
      *(_WORD *)(v24 + 2504) = 10 * v8 + 5;
      *(_WORD *)(v24 + 2506) = 10 * v7 + 5;
      unsigned int v25 = *v31;
      *(_WORD *)(v24 + 2496) = v12 / *v31;
      unsigned int v26 = *(_DWORD *)(v24 + 2508);
      if (v26) {
        *(_WORD *)(v30 + 176 * v33 + 2516) = *(_DWORD *)(v30 + 176 * v33 + 2512) / v26;
      }
      unsigned int v27 = *(_DWORD *)(v30 + 176 * v33 + 2520);
      if (v27) {
        *(_WORD *)(v30 + 176 * v33 + 252_Block_object_dispose(va, 8) = *(_DWORD *)(v30 + 176 * v33 + 2524) / v27;
      }
      uint64_t v28 = v30 + 176 * v33;
      *(_BYTE *)(v28 + 2460) = 100 * *(_DWORD *)(v28 + 2456) / v25;
      *(_BYTE *)(v28 + 246_Block_object_dispose(va, 8) = 100 * *(_DWORD *)(v28 + 2464) / v25;
      char v3 = v32;
    }

    char v2 = 0;
    uint64_t v1 = 1LL;
  }

  while ((v3 & 1) != 0);
  return result;
}

void sub_10060D784(uint64_t a1)
{
  char v2 = (os_log_s *)qword_1008F75B8;
  if (os_log_type_enabled((os_log_t)qword_1008F75B8, OS_LOG_TYPE_DEFAULT))
  {
    *(_WORD *)__int16 v31 = 0;
    _os_log_impl( (void *)&_mh_execute_header,  v2,  OS_LOG_TYPE_DEFAULT,  "Send BLE Scan Configuration Daily Stat for Metric",  v31,  2u);
  }

  sub_10060D4C8(a1);
  uint64_t v3 = 0LL;
  char v4 = 1;
  do
  {
    char v5 = v4;
    uint64_t v6 = objc_opt_new(&OBJC_CLASS___NSMutableDictionary);
    int v7 = v6;
    if ((v5 & 1) != 0) {
      int v8 = @"ScreenOff";
    }
    else {
      int v8 = @"ScreenOn";
    }
    -[NSMutableDictionary setObject:forKeyedSubscript:](v6, "setObject:forKeyedSubscript:", v8, @"ScreenState");
    int v9 = (void *)objc_claimAutoreleasedReturnValue( +[NSNumber numberWithUnsignedInt:]( &OBJC_CLASS___NSNumber,  "numberWithUnsignedInt:",  *(unsigned int *)(a1 + 176 * v3 + 2448)));
    -[NSMutableDictionary setObject:forKeyedSubscript:]( v7,  "setObject:forKeyedSubscript:",  v9,  @"ScanConfigCount");

    int v10 = (void *)objc_claimAutoreleasedReturnValue( +[NSNumber numberWithUnsignedInt:]( &OBJC_CLASS___NSNumber,  "numberWithUnsignedInt:",  *(unsigned int *)(a1 + 176 * v3 + 2452)));
    -[NSMutableDictionary setObject:forKeyedSubscript:]( v7,  "setObject:forKeyedSubscript:",  v10,  @"ScanConfigCountHasParamsUpdate");

    int v11 = (void *)objc_claimAutoreleasedReturnValue( +[NSNumber numberWithUnsignedChar:]( &OBJC_CLASS___NSNumber,  "numberWithUnsignedChar:",  *(unsigned __int8 *)(a1 + 176 * v3 + 2460)));
    -[NSMutableDictionary setObject:forKeyedSubscript:]( v7,  "setObject:forKeyedSubscript:",  v11,  @"ScanConfigPercentageNeedFWScanRestart");

    unsigned int v12 = (void *)objc_claimAutoreleasedReturnValue( +[NSNumber numberWithUnsignedChar:]( &OBJC_CLASS___NSNumber,  "numberWithUnsignedChar:",  *(unsigned __int8 *)(a1 + 176 * v3 + 2468)));
    -[NSMutableDictionary setObject:forKeyedSubscript:]( v7,  "setObject:forKeyedSubscript:",  v12,  @"ScanConfigPercentageNeedNoFWScanRestart");

    unsigned int v13 = (void *)objc_claimAutoreleasedReturnValue( +[NSNumber numberWithUnsignedInt:]( &OBJC_CLASS___NSNumber,  "numberWithUnsignedInt:",  *(unsigned int *)(a1 + 176 * v3 + 2484)));
    -[NSMutableDictionary setObject:forKeyedSubscript:]( v7,  "setObject:forKeyedSubscript:",  v13,  @"ScanConfigCountHasMatchingRuleRequested");

    int v14 = (void *)objc_claimAutoreleasedReturnValue( +[NSNumber numberWithUnsignedInt:]( &OBJC_CLASS___NSNumber,  "numberWithUnsignedInt:",  *(unsigned int *)(a1 + 176 * v3 + 2480)));
    -[NSMutableDictionary setObject:forKeyedSubscript:]( v7,  "setObject:forKeyedSubscript:",  v14,  @"ScanConfigCountHasMatchingAddressRequested");

    uint64_t v15 = (void *)objc_claimAutoreleasedReturnValue( +[NSNumber numberWithUnsignedInt:]( &OBJC_CLASS___NSNumber,  "numberWithUnsignedInt:",  *(unsigned int *)(a1 + 176 * v3 + 2476)));
    -[NSMutableDictionary setObject:forKeyedSubscript:]( v7,  "setObject:forKeyedSubscript:",  v15,  @"ScanConfigCountHasPCFRequested");

    int v16 = (void *)objc_claimAutoreleasedReturnValue( +[NSNumber numberWithUnsignedInt:]( &OBJC_CLASS___NSNumber,  "numberWithUnsignedInt:",  *(unsigned int *)(a1 + 176 * v3 + 2472)));
    -[NSMutableDictionary setObject:forKeyedSubscript:]( v7,  "setObject:forKeyedSubscript:",  v16,  @"ScanConfigCountHasZoneRequested");

    int v17 = (void *)objc_claimAutoreleasedReturnValue( +[NSNumber numberWithUnsignedInt:]( &OBJC_CLASS___NSNumber,  "numberWithUnsignedInt:",  *(unsigned int *)(a1 + 176 * v3 + 2488)));
    -[NSMutableDictionary setObject:forKeyedSubscript:]( v7,  "setObject:forKeyedSubscript:",  v17,  @"ScanConfigCountHasAdvMatchBufRequested");

    int v18 = (void *)objc_claimAutoreleasedReturnValue( +[NSNumber numberWithUnsignedShort:]( &OBJC_CLASS___NSNumber,  "numberWithUnsignedShort:",  *(unsigned __int16 *)(a1 + 176 * v3 + 2492)));
    -[NSMutableDictionary setObject:forKeyedSubscript:]( v7,  "setObject:forKeyedSubscript:",  v18,  @"ScanConfigTimeMin");

    BOOL v19 = (void *)objc_claimAutoreleasedReturnValue( +[NSNumber numberWithUnsignedShort:]( &OBJC_CLASS___NSNumber,  "numberWithUnsignedShort:",  *(unsigned __int16 *)(a1 + 176 * v3 + 2494)));
    -[NSMutableDictionary setObject:forKeyedSubscript:]( v7,  "setObject:forKeyedSubscript:",  v19,  @"ScanConfigTimeMax");

    BOOL v20 = (void *)objc_claimAutoreleasedReturnValue( +[NSNumber numberWithUnsignedShort:]( &OBJC_CLASS___NSNumber,  "numberWithUnsignedShort:",  *(unsigned __int16 *)(a1 + 176 * v3 + 2496)));
    -[NSMutableDictionary setObject:forKeyedSubscript:]( v7,  "setObject:forKeyedSubscript:",  v20,  @"ScanConfigTimeAvg");

    BOOL v21 = (void *)objc_claimAutoreleasedReturnValue( +[NSNumber numberWithUnsignedShort:]( &OBJC_CLASS___NSNumber,  "numberWithUnsignedShort:",  *(unsigned __int16 *)(a1 + 176 * v3 + 2498)));
    -[NSMutableDictionary setObject:forKeyedSubscript:]( v7,  "setObject:forKeyedSubscript:",  v21,  @"ScanConfigTimePercentile5");

    BOOL v22 = (void *)objc_claimAutoreleasedReturnValue( +[NSNumber numberWithUnsignedShort:]( &OBJC_CLASS___NSNumber,  "numberWithUnsignedShort:",  *(unsigned __int16 *)(a1 + 176 * v3 + 2500)));
    -[NSMutableDictionary setObject:forKeyedSubscript:]( v7,  "setObject:forKeyedSubscript:",  v22,  @"ScanConfigTimePercentile25");

    BOOL v23 = (void *)objc_claimAutoreleasedReturnValue( +[NSNumber numberWithUnsignedShort:]( &OBJC_CLASS___NSNumber,  "numberWithUnsignedShort:",  *(unsigned __int16 *)(a1 + 176 * v3 + 2502)));
    -[NSMutableDictionary setObject:forKeyedSubscript:]( v7,  "setObject:forKeyedSubscript:",  v23,  @"ScanConfigTimePercentile50");

    uint64_t v24 = (void *)objc_claimAutoreleasedReturnValue( +[NSNumber numberWithUnsignedShort:]( &OBJC_CLASS___NSNumber,  "numberWithUnsignedShort:",  *(unsigned __int16 *)(a1 + 176 * v3 + 2504)));
    -[NSMutableDictionary setObject:forKeyedSubscript:]( v7,  "setObject:forKeyedSubscript:",  v24,  @"ScanConfigTimePercentile75");

    unsigned int v25 = (void *)objc_claimAutoreleasedReturnValue( +[NSNumber numberWithUnsignedShort:]( &OBJC_CLASS___NSNumber,  "numberWithUnsignedShort:",  *(unsigned __int16 *)(a1 + 176 * v3 + 2506)));
    -[NSMutableDictionary setObject:forKeyedSubscript:]( v7,  "setObject:forKeyedSubscript:",  v25,  @"ScanConfigTimePercentile95");

    unsigned int v26 = (void *)objc_claimAutoreleasedReturnValue( +[NSNumber numberWithUnsignedShort:]( &OBJC_CLASS___NSNumber,  "numberWithUnsignedShort:",  *(unsigned __int16 *)(a1 + 176 * v3 + 2516)));
    -[NSMutableDictionary setObject:forKeyedSubscript:]( v7,  "setObject:forKeyedSubscript:",  v26,  @"ScanConfigTimeAvgHeySiriUseCase");

    unsigned int v27 = (void *)objc_claimAutoreleasedReturnValue( +[NSNumber numberWithUnsignedInt:]( &OBJC_CLASS___NSNumber,  "numberWithUnsignedInt:",  *(unsigned int *)(a1 + 176 * v3 + 2508)));
    -[NSMutableDictionary setObject:forKeyedSubscript:]( v7,  "setObject:forKeyedSubscript:",  v27,  @"ScanConfigCountHeySiriUseCase");

    uint64_t v28 = (void *)objc_claimAutoreleasedReturnValue( +[NSNumber numberWithUnsignedShort:]( &OBJC_CLASS___NSNumber,  "numberWithUnsignedShort:",  *(unsigned __int16 *)(a1 + 176 * v3 + 2528)));
    -[NSMutableDictionary setObject:forKeyedSubscript:]( v7,  "setObject:forKeyedSubscript:",  v28,  @"ScanConfigTimeAvgSharingUseCase");

    uint64_t v29 = (void *)objc_claimAutoreleasedReturnValue( +[NSNumber numberWithUnsignedInt:]( &OBJC_CLASS___NSNumber,  "numberWithUnsignedInt:",  *(unsigned int *)(a1 + 176 * v3 + 2520)));
    -[NSMutableDictionary setObject:forKeyedSubscript:]( v7,  "setObject:forKeyedSubscript:",  v29,  @"ScanConfigCountSharingUseCase");

    uint64_t v30 = sub_1002E8D94();
    (*(void (**)(uint64_t, NSMutableDictionary *))(*(void *)v30 + 312LL))(v30, v7);

    char v4 = 0;
    uint64_t v3 = 1LL;
  }

  while ((v5 & 1) != 0);
  sub_1005DF8A0(a1);
}

void sub_10060DC84(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

__n128 sub_10060DCF0(uint64_t a1, uint64_t a2)
{
  char v4 = (float64x2_t *)(a1 + 3024);
  uint64_t v5 = a1 + 2748;
  uint64_t v6 = (os_log_s *)qword_1008F75B8;
  if (os_log_type_enabled((os_log_t)qword_1008F75B8, OS_LOG_TYPE_DEFAULT))
  {
    *(_WORD *)BOOL v19 = 0;
    _os_log_impl((void *)&_mh_execute_header, v6, OS_LOG_TYPE_DEFAULT, "Get BLE Scan Stat for Metric", v19, 2u);
  }

  CFAbsoluteTime Current = CFAbsoluteTimeGetCurrent();
  double v8 = *(double *)(a1 + 2728);
  unsigned int v9 = ((Current - v8) * 1000.0);
  if (Current < v8) {
    unsigned int v9 = 0;
  }
  *(_DWORD *)a2 = v9;
  *(_OWORD *)(a2 + 4) = *(_OWORD *)v5;
  *(_OWORD *)(a2 + 20) = *(_OWORD *)(v5 + 16);
  *(_OWORD *)(a2 + 36) = *(_OWORD *)(v5 + 32);
  float64x2_t v10 = (float64x2_t)vdupq_n_s64(0x408F400000000000uLL);
  int32x4_t v11 = vuzp1q_s32( (int32x4_t)vcvtq_u64_f64(vmulq_f64(*(float64x2_t *)(v5 + 52), v10)),  (int32x4_t)vcvtq_u64_f64(vmulq_f64(*(float64x2_t *)(v5 + 68), v10)));
  float64x2_t v12 = vmulq_f64(*(float64x2_t *)(v5 + 84), v10);
  *(void *)(a2 + 52) = *(void *)(a1 + 2736);
  int32x4_t v13 = (int32x4_t)vcvtq_u64_f64(vmulq_f64(*(float64x2_t *)(v5 + 100), v10));
  *(_DWORD *)(a2 + 60) = *(_DWORD *)(a1 + 2744);
  *(int32x4_t *)(a2 + 64) = v11;
  *(int32x4_t *)(a2 + 80) = vuzp1q_s32((int32x4_t)vcvtq_u64_f64(v12), v13);
  int32x4_t v14 = vuzp1q_s32( (int32x4_t)vcvtq_u64_f64(vmulq_f64(*(float64x2_t *)(v5 + 148), v10)),  (int32x4_t)vcvtq_u64_f64(vmulq_f64(*(float64x2_t *)(v5 + 164), v10)));
  *(int32x4_t *)(a2 + 96) = vuzp1q_s32( (int32x4_t)vcvtq_u64_f64(vmulq_f64(*(float64x2_t *)(v5 + 116), v10)),  (int32x4_t)vcvtq_u64_f64(vmulq_f64(*(float64x2_t *)(v5 + 132), v10)));
  *(int32x4_t *)(a2 + 112) = v14;
  int32x4_t v15 = vuzp1q_s32( (int32x4_t)vcvtq_u64_f64(vmulq_f64(*(float64x2_t *)(v5 + 212), v10)),  (int32x4_t)vcvtq_u64_f64(vmulq_f64(*(float64x2_t *)(v5 + 228), v10)));
  *(int32x4_t *)(a2 + 12_Block_object_dispose(va, 8) = vuzp1q_s32( (int32x4_t)vcvtq_u64_f64(vmulq_f64(*(float64x2_t *)(v5 + 180), v10)),  (int32x4_t)vcvtq_u64_f64(vmulq_f64(*(float64x2_t *)(v5 + 196), v10)));
  *(int32x4_t *)(a2 + 144) = v15;
  int32x4_t v16 = vuzp1q_s32((int32x4_t)vcvtq_u64_f64(vmulq_f64(*v4, v10)), (int32x4_t)vcvtq_u64_f64(vmulq_f64(v4[1], v10)));
  *(int32x4_t *)(a2 + sub_100242FAC(v47 - 160) = vuzp1q_s32( (int32x4_t)vcvtq_u64_f64(vmulq_f64(*(float64x2_t *)(v5 + 244), v10)),  (int32x4_t)vcvtq_u64_f64(vmulq_f64(*(float64x2_t *)(v5 + 260), v10)));
  *(int32x4_t *)(a2 + 176) = v16;
  int32x4_t v17 = vuzp1q_s32((int32x4_t)vcvtq_u64_f64(vmulq_f64(v4[4], v10)), (int32x4_t)vcvtq_u64_f64(vmulq_f64(v4[5], v10)));
  *(int32x4_t *)(a2 + 192) = vuzp1q_s32( (int32x4_t)vcvtq_u64_f64(vmulq_f64(v4[2], v10)),  (int32x4_t)vcvtq_u64_f64(vmulq_f64(v4[3], v10)));
  *(int32x4_t *)(a2 + 20_Block_object_dispose(va, 8) = v17;
  *(int32x2_t *)(a2 + 224) = vmovn_s64((int64x2_t)vcvtq_u64_f64(vmulq_f64(*(float64x2_t *)(a1 + 3120), v10)));
  sub_1005DF990(a1);
  return result;
}

uint64_t sub_10060DF10()
{
  return 1LL;
}

void sub_10060DF1C(uint64_t a1)
{
  uint64_t v2 = sub_100404FE8();
  v3[0] = _NSConcreteStackBlock;
  v3[1] = 3221225472LL;
  _DWORD v3[2] = sub_10060EE74;
  v3[3] = &unk_10087EB20;
  void v3[4] = a1;
  sub_100405384(v2, v3);
}

void sub_10060DF7C(uint64_t a1)
{
  uint64_t v2 = sub_100404FE8();
  v3[0] = _NSConcreteStackBlock;
  v3[1] = 3221225472LL;
  _DWORD v3[2] = sub_10060EE80;
  v3[3] = &unk_10087EB20;
  void v3[4] = a1;
  sub_100405384(v2, v3);
}

uint64_t sub_10060DFE0()
{
  return 1LL;
}

void sub_10060DFEC(uint64_t a1)
{
  uint64_t v1 = a1 - 112;
  uint64_t v2 = sub_100404FE8();
  v3[0] = _NSConcreteStackBlock;
  v3[1] = 3221225472LL;
  _DWORD v3[2] = sub_10060EE74;
  v3[3] = &unk_10087EB20;
  void v3[4] = v1;
  sub_100405384(v2, v3);
}

void sub_10060E04C(uint64_t a1)
{
  uint64_t v1 = a1 - 120;
  uint64_t v2 = sub_100404FE8();
  v3[0] = _NSConcreteStackBlock;
  v3[1] = 3221225472LL;
  _DWORD v3[2] = sub_10060EE80;
  v3[3] = &unk_10087EB20;
  void v3[4] = v1;
  sub_100405384(v2, v3);
}

void sub_10060E0AC(uint64_t a1, uint64_t a2)
{
  char v4 = *(char **)(a1 + 8);
  uint64_t v5 = *(char **)(a1 + 16);
  if (v4 == v5)
  {
    uint64_t v6 = *(char **)(a1 + 8);
    goto LABEL_10;
  }

  uint64_t v6 = *(char **)(a1 + 8);
  while (*(void *)v6 != a2)
  {
    v6 += 8;
    if (v6 == v5)
    {
      uint64_t v6 = *(char **)(a1 + 16);
      break;
    }
  }

  if (v6 == v5)
  {
    if (v4 != v5)
    {
LABEL_11:
      uint64_t v7 = a2;
      sub_10060E160(a1 + 8, v6, (char *)&v7);
      sub_100008A30(a1 + 8);
      goto LABEL_12;
    }

char *sub_10060E160(uint64_t a1, char *__src, char *a3)
{
  uint64_t v3 = a3;
  char v4 = __src;
  uint64_t v6 = *(char **)(a1 + 8);
  uint64_t v8 = a1 + 16;
  unint64_t v7 = *(void *)(a1 + 16);
  if ((unint64_t)v6 >= v7)
  {
    int32x4_t v13 = *(char **)a1;
    unint64_t v14 = ((uint64_t)&v6[-*(void *)a1] >> 3) + 1;
    if (v14 >> 61) {
      abort();
    }
    uint64_t v15 = __src - v13;
    uint64_t v16 = (__src - v13) >> 3;
    uint64_t v17 = v7 - (void)v13;
    if (v17 >> 2 > v14) {
      unint64_t v14 = v17 >> 2;
    }
    else {
      unint64_t v18 = v14;
    }
    uint64_t v30 = a1 + 16;
    if (v18) {
      BOOL v19 = (char *)sub_100008BA0(a1 + 16, v18);
    }
    else {
      BOOL v19 = 0LL;
    }
    BOOL v20 = &v19[8 * v16];
    std::stringbuf::string_type __p = v19;
    unsigned int v27 = v20;
    uint64_t v28 = v20;
    uint64_t v29 = &v19[8 * v18];
    if (v16 == v18)
    {
      if (v15 < 1)
      {
        if (v13 == v4) {
          unint64_t v22 = 1LL;
        }
        else {
          unint64_t v22 = v15 >> 2;
        }
        BOOL v23 = (char *)sub_100008BA0(v8, v22);
        BOOL v20 = &v23[8 * (v22 >> 2)];
        std::stringbuf::string_type __p = v23;
        unsigned int v27 = v20;
        uint64_t v29 = &v23[8 * v24];
        if (v19) {
          operator delete(v19);
        }
      }

      else
      {
        unint64_t v21 = v16 + 2;
        if (v16 >= -1) {
          unint64_t v21 = v16 + 1;
        }
        v20 -= 8 * (v21 >> 1);
        unsigned int v27 = v20;
      }
    }

    *(void *)BOOL v20 = *(void *)v3;
    uint64_t v28 = v20 + 8;
    char v4 = sub_100008ADC((void **)a1, (uint64_t)&__p, v4);
    if (v28 != v27) {
      v28 += (v27 - v28 + 7) & 0xFFFFFFFFFFFFFFF8LL;
    }
    if (__p) {
      operator delete(__p);
    }
  }

  else if (__src == v6)
  {
    *(void *)__src = *(void *)a3;
    *(void *)(a1 + _Block_object_dispose(va, 8) = __src + 8;
  }

  else
  {
    unsigned int v9 = __src + 8;
    float64x2_t v10 = v6 - 8;
    int32x4_t v11 = *(void **)(a1 + 8);
    while (v10 < v6)
    {
      uint64_t v12 = *(void *)v10;
      v10 += 8;
      *v11++ = v12;
    }

    *(void *)(a1 + _Block_object_dispose(va, 8) = v11;
    if (v6 != v9) {
      memmove(&v6[-8 * ((v6 - v9) >> 3)], __src, v6 - v9);
    }
    if (v4 <= v3) {
      v3 += 8 * (*(void *)(a1 + 8) > (unint64_t)v3);
    }
    *(void *)char v4 = *(void *)v3;
  }

  return v4;
}

void sub_10060E364( _Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void *__p, uint64_t a11, uint64_t a12)
{
  if (__p) {
    operator delete(__p);
  }
  _Unwind_Resume(exception_object);
}

void sub_10060E39C(uint64_t a1, uint64_t a2)
{
  char v4 = *(char **)(a1 + 8);
  uint64_t v5 = *(char **)(a1 + 16);
  if (v4 == v5)
  {
    uint64_t v6 = *(char **)(a1 + 8);
    goto LABEL_10;
  }

  uint64_t v6 = *(char **)(a1 + 8);
  while (*(void *)v6 != a2)
  {
    v6 += 8;
    if (v6 == v5)
    {
      uint64_t v6 = *(char **)(a1 + 16);
      break;
    }
  }

  if (v6 == v5)
  {
    if (v4 != v5)
    {
LABEL_11:
      uint64_t v7 = a2;
      sub_10060E450(a1 + 8, v6, (char *)&v7);
      sub_100008A30(a1 + 8);
      goto LABEL_12;
    }

char *sub_10060E450(uint64_t a1, char *__src, char *a3)
{
  uint64_t v3 = a3;
  char v4 = __src;
  uint64_t v6 = *(char **)(a1 + 8);
  uint64_t v8 = a1 + 16;
  unint64_t v7 = *(void *)(a1 + 16);
  if ((unint64_t)v6 >= v7)
  {
    int32x4_t v13 = *(char **)a1;
    unint64_t v14 = ((uint64_t)&v6[-*(void *)a1] >> 3) + 1;
    if (v14 >> 61) {
      abort();
    }
    uint64_t v15 = __src - v13;
    uint64_t v16 = (__src - v13) >> 3;
    uint64_t v17 = v7 - (void)v13;
    if (v17 >> 2 > v14) {
      unint64_t v14 = v17 >> 2;
    }
    else {
      unint64_t v18 = v14;
    }
    uint64_t v30 = a1 + 16;
    if (v18) {
      BOOL v19 = (char *)sub_100008BA0(a1 + 16, v18);
    }
    else {
      BOOL v19 = 0LL;
    }
    BOOL v20 = &v19[8 * v16];
    std::stringbuf::string_type __p = v19;
    unsigned int v27 = v20;
    uint64_t v28 = v20;
    uint64_t v29 = &v19[8 * v18];
    if (v16 == v18)
    {
      if (v15 < 1)
      {
        if (v13 == v4) {
          unint64_t v22 = 1LL;
        }
        else {
          unint64_t v22 = v15 >> 2;
        }
        BOOL v23 = (char *)sub_100008BA0(v8, v22);
        BOOL v20 = &v23[8 * (v22 >> 2)];
        std::stringbuf::string_type __p = v23;
        unsigned int v27 = v20;
        uint64_t v29 = &v23[8 * v24];
        if (v19) {
          operator delete(v19);
        }
      }

      else
      {
        unint64_t v21 = v16 + 2;
        if (v16 >= -1) {
          unint64_t v21 = v16 + 1;
        }
        v20 -= 8 * (v21 >> 1);
        unsigned int v27 = v20;
      }
    }

    *(void *)BOOL v20 = *(void *)v3;
    uint64_t v28 = v20 + 8;
    char v4 = sub_100008ADC((void **)a1, (uint64_t)&__p, v4);
    if (v28 != v27) {
      v28 += (v27 - v28 + 7) & 0xFFFFFFFFFFFFFFF8LL;
    }
    if (__p) {
      operator delete(__p);
    }
  }

  else if (__src == v6)
  {
    *(void *)__src = *(void *)a3;
    *(void *)(a1 + _Block_object_dispose(va, 8) = __src + 8;
  }

  else
  {
    unsigned int v9 = __src + 8;
    float64x2_t v10 = v6 - 8;
    int32x4_t v11 = *(void **)(a1 + 8);
    while (v10 < v6)
    {
      uint64_t v12 = *(void *)v10;
      v10 += 8;
      *v11++ = v12;
    }

    *(void *)(a1 + _Block_object_dispose(va, 8) = v11;
    if (v6 != v9) {
      memmove(&v6[-8 * ((v6 - v9) >> 3)], __src, v6 - v9);
    }
    if (v4 <= v3) {
      v3 += 8 * (*(void *)(a1 + 8) > (unint64_t)v3);
    }
    *(void *)char v4 = *(void *)v3;
  }

  return v4;
}

void sub_10060E654( _Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void *__p, uint64_t a11, uint64_t a12)
{
  if (__p) {
    operator delete(__p);
  }
  _Unwind_Resume(exception_object);
}

void *sub_10060E68C(void *result, uint64_t a2, uint64_t a3, unint64_t a4)
{
  if (a4)
  {
    uint64_t v6 = result;
    sub_10005172C(result, a4);
    __n128 result = (void *)sub_10060E6E8((uint64_t)(v6 + 2), a2, a3, v6[1]);
    v6[1] = result;
  }

  return result;
}

void sub_10060E6E0(_Unwind_Exception *a1)
{
  *(void *)(v1 + _Block_object_dispose(va, 8) = v2;
  _Unwind_Resume(a1);
}

uint64_t sub_10060E6E8(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  if (a2 != a3)
  {
    uint64_t v6 = a2;
    do
    {
      *(void *)a4 = *(id *)v6;
      *(void *)(a4 + _Block_object_dispose(va, 8) = *(id *)(v6 + 8);
      *(_OWORD *)(a4 + 16) = *(_OWORD *)(v6 + 16);
      __int128 v8 = *(_OWORD *)(v6 + 48);
      __int128 v7 = *(_OWORD *)(v6 + 64);
      __int128 v9 = *(_OWORD *)(v6 + 32);
      *(_OWORD *)(a4 + 7_Block_object_dispose(va, 8) = *(_OWORD *)(v6 + 78);
      *(_OWORD *)(a4 + 4_Block_object_dispose(va, 8) = v8;
      *(_OWORD *)(a4 + 64) = v7;
      *(_OWORD *)(a4 + 32) = v9;
      a4 += 96LL;
      v6 += 96LL;
    }

    while (v6 != a3);
  }

  return a4;
}

void sub_10060E768(uint64_t *a1, uint64_t a2, uint64_t a3, unint64_t a4)
{
  uint64_t v8 = (uint64_t)(a1 + 2);
  __int128 v9 = (id *)*a1;
  if (0xAAAAAAAAAAAAAAABLL * ((a1[2] - *a1) >> 5) < a4)
  {
    sub_10060E8C0(a1);
    if (a4 > 0x2AAAAAAAAAAAAAALL) {
      abort();
    }
    unint64_t v10 = 0x5555555555555556LL * ((a1[2] - *a1) >> 5);
    if (v10 <= a4) {
      unint64_t v10 = a4;
    }
    if (0xAAAAAAAAAAAAAAABLL * ((a1[2] - *a1) >> 5) >= 0x155555555555555LL) {
      unint64_t v11 = 0x2AAAAAAAAAAAAAALL;
    }
    else {
      unint64_t v11 = v10;
    }
    sub_10005172C(a1, v11);
    uint64_t v12 = sub_10060E6E8(v8, a2, a3, a1[1]);
    goto LABEL_11;
  }

  if (0xAAAAAAAAAAAAAAABLL * ((a1[1] - (uint64_t)v9) >> 5) < a4)
  {
    uint64_t v13 = a2 + 32 * ((a1[1] - (uint64_t)v9) >> 5);
    sub_10060E8F8((int)&v15, a2, v13, v9);
    uint64_t v12 = sub_10060E6E8(v8, v13, a3, a1[1]);
LABEL_11:
    a1[1] = v12;
    return;
  }

  sub_10060E8F8((int)&v16, a2, a3, v9);
  sub_10004FEE4((uint64_t)a1, v14);
}

void sub_10060E8B0(_Unwind_Exception *a1)
{
  *(void *)(v1 + _Block_object_dispose(va, 8) = v2;
  _Unwind_Resume(a1);
}

void sub_10060E8B8(_Unwind_Exception *a1)
{
  *(void *)(v1 + _Block_object_dispose(va, 8) = v2;
  _Unwind_Resume(a1);
}

void sub_10060E8C0(uint64_t *a1)
{
  if (*a1)
  {
    sub_10004FEE4((uint64_t)a1, *a1);
    operator delete((void *)*a1);
    *a1 = 0LL;
    a1[1] = 0LL;
    a1[2] = 0LL;
  }

uint64_t sub_10060E8F8(int a1, uint64_t a2, uint64_t a3, id *location)
{
  uint64_t v5 = a2;
  if (a2 == a3) {
    return a2;
  }
  uint64_t v6 = a3;
  do
  {
    objc_storeStrong(location, *(id *)v5);
    objc_storeStrong(location + 1, *(id *)(v5 + 8));
    *((_OWORD *)location + 1) = *(_OWORD *)(v5 + 16);
    __int128 v7 = *(_OWORD *)(v5 + 32);
    __int128 v8 = *(_OWORD *)(v5 + 48);
    __int128 v9 = *(_OWORD *)(v5 + 64);
    *(_OWORD *)((char *)location + 7_Block_object_dispose(va, 8) = *(_OWORD *)(v5 + 78);
    *((_OWORD *)location + 3) = v8;
    *((_OWORD *)location + 4) = v9;
    *((_OWORD *)location + 2) = v7;
    location += 12;
    v5 += 96LL;
  }

  while (v5 != v6);
  return v6;
}

void sub_10060E984(uint64_t a1, unint64_t a2)
{
  unint64_t v2 = a2;
  int v4 = *(_DWORD *)(a1 + 8);
  uint64_t v5 = *(void **)a1;
  if (v4)
  {
    else {
      unint64_t v6 = (64 - v4);
    }
    *v5++ &= ~((0xFFFFFFFFFFFFFFFFLL >> (64 - v4 - v6)) & (-1LL << v4));
    unint64_t v2 = a2 - v6;
    *(void *)a1 = v5;
  }

  unint64_t v7 = v2 >> 6;
  if (v2 >= 0x40) {
    bzero(v5, 8 * v7);
  }
  if ((v2 & 0x3F) != 0)
  {
    __int128 v8 = &v5[v7];
    *(void *)a1 = v8;
    *v8 &= ~(0xFFFFFFFFFFFFFFFFLL >> -(v2 & 0x3F));
  }

uint64_t sub_10060EA30(uint64_t a1, __int128 **a2, __int128 **a3, char a4, char a5)
{
  *(_BYTE *)a1 = a4 & 1;
  *(_BYTE *)(a1 + 1) = (a4 & 2) != 0;
  *(_BYTE *)(a1 + 2) = 0;
  *(_BYTE *)(a1 + 3) = a5;
  *(void *)(a1 + _Block_object_dispose(va, 8) = 0LL;
  *(void *)(a1 + 16) = 0LL;
  *(void *)(a1 + 24) = 0LL;
  sub_100050EE8((char *)(a1 + 8), *a2, a2[1], 0xCCCCCCCCCCCCCCCDLL * (((char *)a2[1] - (char *)*a2) >> 2));
  *(void *)(a1 + 32) = 0LL;
  *(void *)(a1 + 40) = 0LL;
  *(void *)(a1 + 4_Block_object_dispose(va, 8) = 0LL;
  sub_100050EE8((char *)(a1 + 32), *a3, a3[1], 0xCCCCCCCCCCCCCCCDLL * (((char *)a3[1] - (char *)*a3) >> 2));
  *(_WORD *)(a1 + 121) = 0;
  *(_WORD *)(a1 + 124) = 0;
  *(void *)(a1 + 176) = 0LL;
  *(_BYTE *)(a1 + 184) = 0;
  *(_OWORD *)(a1 + 56) = 0u;
  *(_OWORD *)(a1 + 72) = 0u;
  *(_OWORD *)(a1 + 8_Block_object_dispose(va, 8) = 0u;
  *(_OWORD *)(a1 + 104) = 0u;
  *(void *)(a1 + 12_Block_object_dispose(va, 8) = 0LL;
  *(_WORD *)(a1 + 136) = 0;
  *(_DWORD *)(a1 + 142) = 0;
  *(void *)(a1 + 152) = 0LL;
  *(void *)(a1 + sub_100242FAC(v47 - 160) = 0LL;
  *(_DWORD *)(a1 + 16_Block_object_dispose(va, 8) = 0;
  *(void *)(a1 + 18_Block_object_dispose(va, 8) = 0LL;
  *(_BYTE *)(a1 + 196) = 0;
  *(_WORD *)(a1 + 197) = 257;
  *(_DWORD *)(a1 + 199) = 0;
  *(_BYTE *)(a1 + 203) = 8;
  *(_BYTE *)(a1 + 280) = 0;
  *(_OWORD *)(a1 + 240) = 0u;
  *(_OWORD *)(a1 + 256) = 0u;
  *(_OWORD *)(a1 + 20_Block_object_dispose(va, 8) = 0u;
  *(_OWORD *)(a1 + 224) = 0u;
  *(_BYTE *)(a1 + 281) = 1;
  *(_DWORD *)(a1 + 282) = 0;
  *(_BYTE *)(a1 + 286) = 1;
  *(_DWORD *)(a1 + 320) = 0;
  *(_DWORD *)(a1 + 287) = 0;
  *(_WORD *)(a1 + 291) = 0;
  *(void *)(a1 + 309) = 0LL;
  *(void *)(a1 + 294) = 0LL;
  *(void *)(a1 + 302) = 0LL;
  *(_OWORD *)(a1 + 32_Block_object_dispose(va, 8) = 0u;
  *(_OWORD *)(a1 + 344) = 0u;
  *(_OWORD *)(a1 + 360) = 0u;
  *(_BYTE *)(a1 + 376) = 1;
  *(_DWORD *)(a1 + 384) = 0;
  uint64_t v7 = objc_claimAutoreleasedReturnValue(+[NSMutableArray array](&OBJC_CLASS___NSMutableArray, "array"));
  __int128 v8 = *(void **)(a1 + 88);
  *(void *)(a1 + 8_Block_object_dispose(va, 8) = v7;

  *(_BYTE *)(a1 + 4) = 0;
  uint64_t v9 = objc_claimAutoreleasedReturnValue(+[NSSet set](&OBJC_CLASS___NSSet, "set"));
  unint64_t v10 = *(void **)(a1 + 152);
  *(void *)(a1 + 152) = v9;

  return a1;
}

void sub_10060EBB4( _Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10)
{
  uint64_t v13 = *v11;
  if (*v11)
  {
    *(void *)(v10 + 16) = v13;
    operator delete(v13);
  }

  _Unwind_Resume(exception_object);
}

void *sub_10060EC38(void *a1, uint64_t a2, uint64_t a3)
{
  uint64_t v5 = *(void *)(a2 + 8);
  *a1 = &off_10087FAA8;
  a1[1] = v5;
  if (v5) {
    sub_1002CD1E0(v5);
  }
  uint64_t v6 = *(void *)(a3 + 8);
  a1[2] = &off_10087FAA8;
  a1[3] = v6;
  if (v6) {
    sub_1002CD1E0(v6);
  }
  return a1;
}

void sub_10060EC8C(_Unwind_Exception *exception_object)
{
  void *v1 = v2;
  int v4 = (unsigned int *)v1[1];
  if (v4) {
    sub_1002CD254(v4);
  }
  _Unwind_Resume(exception_object);
}

uint64_t sub_10060ECA8(int8x8_t *a1, unsigned int a2, uint64_t a3, unsigned int a4, _BYTE *a5)
{
  unint64_t v5 = a4 - (unint64_t)a2 + 8 * (a3 - (void)a1);
  if (*a5) {
    return sub_10060ECC8(a1, a2, v5);
  }
  else {
    return sub_10060ED6C((uint64_t *)a1, a2, v5);
  }
}

uint64_t sub_10060ECC8(int8x8_t *a1, unsigned int a2, unint64_t a3)
{
  uint64_t v3 = a2;
  if (a2)
  {
    if (64 - a2 >= a3) {
      unint64_t v4 = a3;
    }
    else {
      unint64_t v4 = 64 - a2;
    }
    uint64_t v5 = (uint64_t)*a1++;
    uint8x8_t v6 = (uint8x8_t)vcnt_s8((int8x8_t)((0xFFFFFFFFFFFFFFFFLL >> (64 - a2 - v4)) & (-1LL << a2) & v5));
    v6.i16[0] = vaddlv_u8(v6);
    uint64_t v3 = v6.u32[0];
    a3 -= v4;
  }

  if (a3 >= 0x40)
  {
    do
    {
      int8x8_t v7 = *a1++;
      uint8x8_t v8 = (uint8x8_t)vcnt_s8(v7);
      v8.i16[0] = vaddlv_u8(v8);
      v3 += v8.u32[0];
      a3 -= 64LL;
    }

    while (a3 > 0x3F);
  }

  if (a3)
  {
    uint8x8_t v9 = (uint8x8_t)vcnt_s8((int8x8_t)(*(void *)a1 & (0xFFFFFFFFFFFFFFFFLL >> -(char)a3)));
    v9.i16[0] = vaddlv_u8(v9);
    v3 += v9.u32[0];
  }

  return v3;
}

uint64_t sub_10060ED6C(uint64_t *a1, unsigned int a2, unint64_t a3)
{
  uint64_t v3 = a2;
  if (a2)
  {
    if (64 - a2 >= a3) {
      unint64_t v4 = a3;
    }
    else {
      unint64_t v4 = 64 - a2;
    }
    uint64_t v5 = *a1++;
    uint8x8_t v6 = (uint8x8_t)vcnt_s8((int8x8_t)((0xFFFFFFFFFFFFFFFFLL >> (64 - a2 - v4)) & (-1LL << a2) & ~v5));
    v6.i16[0] = vaddlv_u8(v6);
    uint64_t v3 = v6.u32[0];
    a3 -= v4;
  }

  if (a3 >= 0x40)
  {
    do
    {
      uint64_t v7 = *a1++;
      uint8x8_t v8 = (uint8x8_t)vcnt_s8((int8x8_t)~v7);
      v8.i16[0] = vaddlv_u8(v8);
      v3 += v8.u32[0];
      a3 -= 64LL;
    }

    while (a3 > 0x3F);
  }

  if (a3)
  {
    uint8x8_t v9 = (uint8x8_t)vcnt_s8((int8x8_t)((0xFFFFFFFFFFFFFFFFLL >> -(char)a3) & ~*a1));
    v9.i16[0] = vaddlv_u8(v9);
    v3 += v9.u32[0];
  }

  return v3;
}

uint64_t sub_10060EE20(uint64_t a1)
{
  if (qword_1008D6608 != -1) {
    dispatch_once(&qword_1008D6608, &stru_1008A3FF8);
  }
  return sub_100609710((uint64_t)off_1008D6600, *(void *)(a1 + 24), a1);
}

uint64_t sub_10060EE74(uint64_t a1)
{
  return sub_1005E3C94(*(void *)(a1 + 32), 0);
}

uint64_t sub_10060EE80(uint64_t a1)
{
  return sub_1005E3C94(*(void *)(a1 + 32), 0);
}

void sub_10060EE8C(id a1)
{
  uint64_t v1 = operator new(0x1128uLL);
  sub_1005DD75C((uint64_t)v1);
  off_1008D6600 = v1;
}

void sub_10060EEBC(_Unwind_Exception *a1)
{
}

void sub_10060EED0(uint64_t a1, void *a2)
{
  if (a2)
  {
    sub_10060EED0(a1, *a2);
    sub_10060EED0(a1, a2[1]);
    sub_10060EF18(a2 + 4);
    operator delete(a2);
  }

void sub_10060EF18(void *a1)
{
  a1[2] = &off_10087FAA8;
  uint64_t v2 = (unsigned int *)a1[3];
  if (v2) {
    sub_1002CD254(v2);
  }
  *a1 = &off_10087FAA8;
  uint64_t v3 = (unsigned int *)a1[1];
  if (v3) {
    sub_1002CD254(v3);
  }
}

void sub_10060EF64(uint64_t a1, void *a2)
{
  if (a2)
  {
    sub_10060EF64(a1, *a2);
    sub_10060EF64(a1, a2[1]);
    sub_10060EFAC(a2 + 4);
    operator delete(a2);
  }

void sub_10060EFAC(void *a1)
{
  a1[10] = &off_10087FAE8;
  uint64_t v2 = (unsigned int *)a1[11];
  if (v2) {
    sub_1002CD254(v2);
  }
  a1[8] = &off_10087FAE8;
  uint64_t v3 = (unsigned int *)a1[9];
  if (v3) {
    sub_1002CD254(v3);
  }
  a1[6] = &off_10087FAE8;
  unint64_t v4 = (unsigned int *)a1[7];
  if (v4) {
    sub_1002CD254(v4);
  }
  a1[4] = &off_10087FAE8;
  uint64_t v5 = (unsigned int *)a1[5];
  if (v5) {
    sub_1002CD254(v5);
  }
  a1[2] = &off_10087FAE8;
  uint8x8_t v6 = (unsigned int *)a1[3];
  if (v6) {
    sub_1002CD254(v6);
  }
}

void sub_10060F028(id a1)
{
  uint64_t v1 = operator new(0x1A0uLL);
  sub_1002769A4();
  off_1008D67C0 = v1;
}

void sub_10060F058(_Unwind_Exception *a1)
{
}

void sub_10060F06C(id a1)
{
  uint64_t v1 = operator new(0x230uLL);
  sub_10042BC28();
  off_1008D60A8 = v1;
}

void sub_10060F09C(_Unwind_Exception *a1)
{
}

void sub_10060F0B0(id a1)
{
  uint64_t v1 = (char *)operator new(0x200uLL);
  *(void *)uint64_t v1 = off_100898F60;
  *((void *)v1 + 1) = &off_100898FF0;
  *((void *)v1 + 2) = off_100899008;
  *((void *)v1 + 3) = &off_100899060;
  *((void *)v1 + 4) = &off_100899078;
  sub_100242DC4(v1 + 40);
  *((void *)v1 + 14) = 0LL;
  *((_DWORD *)v1 + 30) = 0;
  *((void *)v1 + 17) = 0LL;
  *((void *)v1 + 1_Block_object_dispose(va, 8) = 0LL;
  *((void *)v1 + 16) = 0LL;
  *(_OWORD *)(v1 + 155) = 0u;
  *(_OWORD *)(v1 + 171) = 0u;
  *(_OWORD *)(v1 + 187) = 0u;
  *(_WORD *)(v1 + 203) = 1;
  *((void *)v1 + 26) = 0LL;
  *((_WORD *)v1 + 10_Block_object_dispose(va, 8) = 256;
  *((void *)v1 + 29) = 0LL;
  *((void *)v1 + 2_Block_object_dispose(va, 8) = v1 + 232;
  *((void *)v1 + 32) = 0LL;
  *((void *)v1 + 33) = 0LL;
  *((void *)v1 + 30) = 0LL;
  *((void *)v1 + 31) = v1 + 256;
  v1[272] = 0;
  *((_DWORD *)v1 + 69) = 0;
  v1[280] = 0;
  *((_WORD *)v1 + 189) = 0;
  *(void *)(v1 + 313) = 0LL;
  *(_OWORD *)(v1 + 300) = 0u;
  *(_OWORD *)(v1 + 284) = 0u;
  *(_OWORD *)(v1 + 32_Block_object_dispose(va, 8) = 0u;
  *(_OWORD *)(v1 + 344) = 0u;
  *(_OWORD *)(v1 + 360) = 0u;
  v1[376] = 0;
  *((void *)v1 + 51) = v1 + 416;
  *((void *)v1 + 52) = 0LL;
  *((void *)v1 + 55) = 0LL;
  *((void *)v1 + 56) = 0LL;
  *((void *)v1 + 53) = 0LL;
  *((void *)v1 + 54) = v1 + 440;
  *((void *)v1 + 57) = v1 + 464;
  *((void *)v1 + 5_Block_object_dispose(va, 8) = 0LL;
  *((void *)v1 + 59) = 0LL;
  *((void *)v1 + 60) = @"XZ";
  *((void *)v1 + 62) = 0LL;
  *((_DWORD *)v1 + 126) = 0;
  off_1008D6190 = v1;
}

void sub_10060F1B8(_Unwind_Exception *a1)
{
}

void sub_10060F1CC(id a1)
{
  uint64_t v1 = operator new(0x618uLL);
  sub_10058B0A4();
  off_1008D5F08 = v1;
}

void sub_10060F1FC(_Unwind_Exception *a1)
{
}

void sub_10060F210(id a1)
{
  uint64_t v1 = operator new(0xA8uLL);
  sub_10005109C((uint64_t)v1);
  qword_1008D6620 = (uint64_t)v1;
}

void sub_10060F240(_Unwind_Exception *a1)
{
}

void sub_10060F254(id a1)
{
  uint64_t v1 = operator new(0x128uLL);
  sub_1005C69F8();
  off_1008D5F28 = v1;
}

void sub_10060F284(_Unwind_Exception *a1)
{
}

uint64_t **sub_10060F298(uint64_t **a1, unsigned __int8 *a2, uint64_t a3, char **a4)
{
  uint64_t v7 = a1 + 1;
  uint8x8_t v6 = a1[1];
  if (v6)
  {
    unsigned int v8 = *a2;
    while (1)
    {
      while (1)
      {
        uint8x8_t v9 = (uint64_t **)v6;
        unsigned int v10 = *((unsigned __int8 *)v6 + 26);
        if (v8 >= v10) {
          break;
        }
        uint8x8_t v6 = *v9;
        uint64_t v7 = v9;
        if (!*v9) {
          goto LABEL_10;
        }
      }

      if (v10 >= v8) {
        break;
      }
      uint8x8_t v6 = v9[1];
      if (!v6)
      {
        uint64_t v7 = v9 + 1;
        goto LABEL_10;
      }
    }
  }

  else
  {
    uint8x8_t v9 = a1 + 1;
LABEL_10:
    unint64_t v11 = (char *)operator new(0x28uLL);
    v11[26] = **a4;
    v11[28] = -1;
    *((_WORD *)v11 + 19) = 0;
    *(void *)(v11 + 30) = 0LL;
    sub_100029630(a1, (uint64_t)v9, v7, (uint64_t *)v11);
    return (uint64_t **)v11;
  }

  return v9;
}

void sub_10060F364(id a1)
{
  uint64_t v1 = operator new(0x118uLL);
  sub_1003AA490((uint64_t)v1);
  off_1008D96F8 = v1;
}

void sub_10060F394(_Unwind_Exception *a1)
{
}

uint64_t sub_10060F3A8(uint64_t *a1, uint64_t a2)
{
  uint64_t v2 = *a1;
  unint64_t v3 = 0xAAAAAAAAAAAAAAABLL * ((a1[1] - *a1) >> 5);
  unint64_t v4 = v3 + 1;
  if (v3 + 1 > 0x2AAAAAAAAAAAAAALL) {
    abort();
  }
  uint64_t v8 = a1[2];
  uint64_t v7 = (uint64_t)(a1 + 2);
  unint64_t v9 = 0xAAAAAAAAAAAAAAABLL * ((v8 - v2) >> 5);
  if (2 * v9 > v4) {
    unint64_t v4 = 2 * v9;
  }
  if (v9 >= 0x155555555555555LL) {
    unint64_t v10 = 0x2AAAAAAAAAAAAAALL;
  }
  else {
    unint64_t v10 = v4;
  }
  void v18[4] = v7;
  if (v10) {
    unint64_t v11 = (char *)sub_100050740(v7, v10);
  }
  else {
    unint64_t v11 = 0LL;
  }
  uint64_t v12 = &v11[96 * v3];
  v18[0] = v11;
  v18[1] = v12;
  v18[3] = &v11[96 * v10];
  *(void *)uint64_t v12 = *(id *)a2;
  *((void *)v12 + 1) = *(id *)(a2 + 8);
  *((_OWORD *)v12 + 1) = *(_OWORD *)(a2 + 16);
  __int128 v14 = *(_OWORD *)(a2 + 48);
  __int128 v13 = *(_OWORD *)(a2 + 64);
  __int128 v15 = *(_OWORD *)(a2 + 32);
  *(_OWORD *)(v12 + 7_Block_object_dispose(va, 8) = *(_OWORD *)(a2 + 78);
  *((_OWORD *)v12 + 3) = v14;
  *((_OWORD *)v12 + 4) = v13;
  *((_OWORD *)v12 + 2) = v15;
  void v18[2] = v12 + 96;
  sub_10060F4CC(a1, v18);
  uint64_t v16 = a1[1];
  sub_10060F548((uint64_t)v18);
  return v16;
}

void sub_10060F4B8(_Unwind_Exception *a1, uint64_t a2, ...)
{
}

uint64_t *sub_10060F4CC(uint64_t *result, void *a2)
{
  uint64_t v3 = *result;
  uint64_t v2 = result[1];
  unint64_t v4 = (_OWORD *)a2[1];
  while (v2 != v3)
  {
    __int128 v5 = *(_OWORD *)(v2 - 96);
    v2 -= 96LL;
    *(void *)uint64_t v2 = 0LL;
    *(void *)(v2 + _Block_object_dispose(va, 8) = 0LL;
    *(v4 - 6) = v5;
    v4 -= 6;
    v4[1] = *(_OWORD *)(v2 + 16);
    __int128 v6 = *(_OWORD *)(v2 + 32);
    __int128 v7 = *(_OWORD *)(v2 + 48);
    __int128 v8 = *(_OWORD *)(v2 + 64);
    *(_OWORD *)((char *)v4 + 7_Block_object_dispose(va, 8) = *(_OWORD *)(v2 + 78);
    v4[3] = v7;
    void v4[4] = v8;
    _DWORD v4[2] = v6;
  }

  a2[1] = v4;
  uint64_t v9 = *result;
  *__n128 result = (uint64_t)v4;
  a2[1] = v9;
  uint64_t v10 = result[1];
  result[1] = a2[2];
  a2[2] = v10;
  uint64_t v11 = result[2];
  result[2] = a2[3];
  a2[3] = v11;
  *a2 = a2[1];
  return result;
}

uint64_t sub_10060F548(uint64_t a1)
{
  if (*(void *)a1) {
    operator delete(*(void **)a1);
  }
  return a1;
}

void sub_10060F57C(uint64_t a1, uint64_t a2)
{
  for (uint64_t i = *(void *)(a1 + 16); i != a2; uint64_t i = *(void *)(a1 + 16))
  {
    *(void *)(a1 + 16) = i - 96;
  }

void sub_10060F5D4(id a1)
{
  uint64_t v1 = operator new(0xEB0uLL);
  sub_10061991C();
  qword_1008D5F18 = (uint64_t)v1;
}

void sub_10060F604(_Unwind_Exception *a1)
{
}

void sub_10060F618(id a1)
{
  qword_1008D9290 = (uint64_t)operator new(1uLL);
}

void sub_10060F638(void ***a1)
{
  uint64_t v1 = *a1;
  uint64_t v2 = (id *)**a1;
  if (v2)
  {
    unint64_t v4 = (id *)v1[1];
    __int128 v5 = **a1;
    if (v4 != v2)
    {
      do
      {
        __int128 v6 = v4 - 5;

        unint64_t v4 = v6;
      }

      while (v6 != v2);
      __int128 v5 = **a1;
    }

    v1[1] = v2;
    operator delete(v5);
  }

uint64_t sub_10060F6AC(uint64_t a1)
{
  uint64_t v3 = *(void *)(a1 + 8);
  for (uint64_t i = *(void *)(a1 + 16); i != v3; uint64_t i = *(void *)(a1 + 16))
  {
    *(void *)(a1 + 16) = i - 40;
  }

  if (*(void *)a1) {
    operator delete(*(void **)a1);
  }
  return a1;
}

void *sub_10060F6FC(void *result, __int128 *a2, __int128 *a3, unint64_t a4)
{
  if (a4)
  {
    __int128 v6 = result;
    __n128 result = sub_1004511FC(result, a4);
    uint64_t v7 = v6[1];
    while (a2 != a3)
    {
      __int128 v8 = *a2;
      *(_OWORD *)(v7 + 12) = *(__int128 *)((char *)a2 + 12);
      *(_OWORD *)uint64_t v7 = v8;
      __n128 result = objc_retainBlock(*((id *)a2 + 4));
      *(void *)(v7 + 32) = result;
      v7 += 40LL;
      a2 = (__int128 *)((char *)a2 + 40);
    }

    v6[1] = v7;
  }

  return result;
}

unsigned __int8 *sub_10060F76C( uint64_t **a1, unsigned __int8 *uu1, uint64_t a3, const unsigned __int8 *__attribute__((__org_typedef(uuid_t))) *a4)
{
  uint64_t v11 = 0LL;
  __int128 v6 = (unsigned __int8 **)sub_1001FD824((uint64_t)a1, &v11, uu1);
  uint64_t v7 = *v6;
  if (!*v6)
  {
    __int128 v8 = (uint64_t **)v6;
    memset(v10, 0, sizeof(v10));
    sub_10060F820((uint64_t)a1, a4, v10);
    sub_100029630(a1, v11, v8, (uint64_t *)v10[0]);
    uint64_t v7 = v10[0];
    v10[0] = 0LL;
    sub_10060F8B0((uint64_t)v10, 0LL);
  }

  return v7;
}

void sub_10060F820( uint64_t a1@<X0>, const unsigned __int8 *__attribute__((__org_typedef(uuid_t))) *a2@<X2>, unsigned __int8 **a3@<X8>)
{
  __int128 v5 = (unsigned __int8 *)(a1 + 8);
  *a3 = 0LL;
  a3[1] = 0LL;
  a3[2] = 0LL;
  __int128 v6 = (unsigned __int8 *)operator new(0x80uLL);
  *a3 = v6;
  a3[1] = v5;
  *((_BYTE *)a3 + 16) = 0;
  uuid_copy(v6 + 32, *a2);
  *((void *)v6 + 6) = &off_10087FAE8;
  *((void *)v6 + 7) = 0LL;
  *((void *)v6 + _Block_object_dispose(va, 8) = &off_10087FAE8;
  *((void *)v6 + 9) = 0LL;
  *((void *)v6 + 10) = &off_10087FAE8;
  *((void *)v6 + 11) = 0LL;
  *((void *)v6 + 12) = &off_10087FAE8;
  *((void *)v6 + 13) = 0LL;
  *((void *)v6 + 14) = &off_10087FAE8;
  *((void *)v6 + 15) = 0LL;
  *((_BYTE *)a3 + 16) = 1;
}

void sub_10060F898(_Unwind_Exception *a1)
{
}

void sub_10060F8B0(uint64_t a1, uint64_t a2)
{
  uint64_t v2 = *(void **)a1;
  *(void *)a1 = a2;
  if (v2)
  {
    if (*(_BYTE *)(a1 + 16)) {
      sub_10060EFAC(v2 + 4);
    }
    operator delete(v2);
  }

uint64_t **sub_10060F8F4(uint64_t **a1, unsigned __int8 *a2, _BYTE *a3)
{
  __int128 v6 = a1 + 1;
  __int128 v5 = a1[1];
  if (v5)
  {
    unsigned int v7 = *a2;
    while (1)
    {
      while (1)
      {
        __int128 v8 = (uint64_t **)v5;
        unsigned int v9 = *((unsigned __int8 *)v5 + 25);
        if (v7 >= v9) {
          break;
        }
        __int128 v5 = *v8;
        __int128 v6 = v8;
        if (!*v8) {
          goto LABEL_10;
        }
      }

      if (v9 >= v7) {
        break;
      }
      __int128 v5 = v8[1];
      if (!v5)
      {
        __int128 v6 = v8 + 1;
        goto LABEL_10;
      }
    }
  }

  else
  {
    __int128 v8 = a1 + 1;
LABEL_10:
    uint64_t v10 = (uint64_t *)operator new(0x20uLL);
    *((_BYTE *)v10 + 25) = *a3;
    sub_100029630(a1, (uint64_t)v8, v6, v10);
    return (uint64_t **)v10;
  }

  return v8;
}

uint64_t *sub_10060F9AC(uint64_t *a1, uint64_t a2)
{
  a1[2] = 0LL;
  a1[1] = 0LL;
  *a1 = (uint64_t)(a1 + 1);
  sub_10060FA00(a1, *(unsigned __int8 **)a2, (unsigned __int8 *)(a2 + 8));
  return a1;
}

void sub_10060F9E8(_Unwind_Exception *a1)
{
}

uint64_t *sub_10060FA00(uint64_t *result, unsigned __int8 *a2, unsigned __int8 *a3)
{
  if (a2 != a3)
  {
    unint64_t v4 = a2;
    __int128 v5 = (uint64_t **)result;
    __int128 v6 = result + 1;
    do
    {
      __n128 result = sub_10060FA84(v5, v6, v4 + 25, v4 + 25);
      unsigned int v7 = (unsigned __int8 *)*((void *)v4 + 1);
      if (v7)
      {
        do
        {
          __int128 v8 = v7;
          unsigned int v7 = *(unsigned __int8 **)v7;
        }

        while (v7);
      }

      else
      {
        do
        {
          __int128 v8 = (unsigned __int8 *)*((void *)v4 + 2);
          BOOL v9 = *(void *)v8 == (void)v4;
          unint64_t v4 = v8;
        }

        while (!v9);
      }

      unint64_t v4 = v8;
    }

    while (v8 != a3);
  }

  return result;
}

uint64_t *sub_10060FA84(uint64_t **a1, uint64_t *a2, unsigned __int8 *a3, _BYTE *a4)
{
  uint64_t v10 = 0LL;
  uint64_t v11 = 0LL;
  __int128 v6 = sub_10060FB0C(a1, a2, &v11, &v10, a3);
  unsigned int v7 = (uint64_t *)*v6;
  if (!*v6)
  {
    __int128 v8 = (uint64_t **)v6;
    unsigned int v7 = (uint64_t *)operator new(0x20uLL);
    *((_BYTE *)v7 + 25) = *a4;
    sub_100029630(a1, (uint64_t)v11, v8, v7);
  }

  return v7;
}

uint64_t *sub_10060FB0C(void *a1, uint64_t *a2, uint64_t **a3, uint64_t *a4, unsigned __int8 *a5)
{
  __int128 v5 = a1 + 1;
  if (a1 + 1 == a2 || (v6 = *a5, unsigned int v7 = *((unsigned __int8 *)a2 + 25), v6 < v7))
  {
    __int128 v8 = (uint64_t *)*a2;
    if ((uint64_t *)*a1 == a2)
    {
      uint64_t v10 = a2;
LABEL_17:
      if (v8)
      {
        *a3 = v10;
        return v10 + 1;
      }

      else
      {
        *a3 = a2;
        return a2;
      }
    }

    if (v8)
    {
      BOOL v9 = (uint64_t *)*a2;
      do
      {
        uint64_t v10 = v9;
        BOOL v9 = (uint64_t *)v9[1];
      }

      while (v9);
    }

    else
    {
      __int128 v13 = a2;
      do
      {
        uint64_t v10 = (uint64_t *)v13[2];
        BOOL v14 = *v10 == (void)v13;
        __int128 v13 = v10;
      }

      while (v14);
    }

    unsigned int v15 = *a5;
    uint64_t v16 = *v5;
    if (*v5)
    {
      do
      {
        while (1)
        {
          uint64_t v17 = (uint64_t *)v16;
          unsigned int v18 = *(unsigned __int8 *)(v16 + 25);
          if (v15 >= v18) {
            break;
          }
          uint64_t v16 = *v17;
          __int128 v5 = v17;
          if (!*v17) {
            goto LABEL_29;
          }
        }

        if (v18 >= v15) {
          break;
        }
        __int128 v5 = v17 + 1;
        uint64_t v16 = v17[1];
      }

      while (v16);
    }

    else
    {
      uint64_t v17 = a1 + 1;
    }

_OWORD *sub_10060FCB4(uint64_t **a1, const void **a2, uint64_t a3, _OWORD **a4)
{
  uint64_t v14 = 0LL;
  unsigned int v6 = (void **)sub_10023E6A4((uint64_t)a1, &v14, a2);
  unsigned int v7 = *v6;
  if (!*v6)
  {
    __int128 v8 = (uint64_t **)v6;
    uint64_t v13 = 0LL;
    unsigned int v7 = operator new(0x50uLL);
    v12[1] = a1 + 1;
    BOOL v9 = *a4;
    uint64_t v10 = *((void *)*a4 + 2);
    _DWORD v7[2] = **a4;
    *((void *)v7 + 6) = v10;
    v9[1] = 0LL;
    void v9[2] = 0LL;
    *BOOL v9 = 0LL;
    *((void *)v7 + 9) = 0LL;
    *((void *)v7 + _Block_object_dispose(va, 8) = 0LL;
    *((void *)v7 + 7) = v7 + 4;
    LOBYTE(v13) = 1;
    sub_100029630(a1, v14, v8, (uint64_t *)v7);
    v12[0] = 0LL;
    sub_1005340D4((uint64_t)v12, 0LL);
  }

  return v7;
}

void sub_10060FD88(id a1)
{
  uint64_t v1 = operator new(0xA8uLL);
  sub_10064B7C8();
  qword_1008D92A0 = (uint64_t)v1;
}

void sub_10060FDB8(_Unwind_Exception *a1)
{
}

void *sub_10060FDCC(uint64_t a1, uint64_t a2)
{
  uint64_t v2 = (void *)(a1 + 8);
  uint64_t v3 = *(void **)(a1 + 8);
  if (!v3) {
    return v2;
  }
  uint64_t v5 = a1 + 16;
  unsigned int v6 = (void *)(a1 + 8);
  do
  {
    BOOL v7 = sub_10060FE58(v5, (uint64_t)(v3 + 4), a2);
    __int128 v8 = v3 + 1;
    if (!v7)
    {
      __int128 v8 = v3;
      unsigned int v6 = v3;
    }

    uint64_t v3 = (void *)*v8;
  }

  while (*v8);
  return v6;
}

BOOL sub_10060FE58(uint64_t a1, uint64_t a2, uint64_t a3)
{
  if (sub_10056B000(a2, a3)) {
    return 1LL;
  }
  if (sub_10056B000(a3, a2)) {
    return 0LL;
  }
  return sub_10056B000(a2 + 16, a3 + 16);
}

uint64_t *sub_10060FEB8(uint64_t **a1, uint64_t a2, uint64_t a3, uint64_t *a4)
{
  uint64_t v11 = 0LL;
  unsigned int v6 = (uint64_t **)sub_10060FF6C((uint64_t)a1, &v11, a2);
  BOOL v7 = *v6;
  if (!*v6)
  {
    __int128 v8 = v6;
    memset(v10, 0, sizeof(v10));
    sub_100610008((uint64_t)a1, a4, v10);
    sub_100029630(a1, v11, v8, v10[0]);
    BOOL v7 = v10[0];
    v10[0] = 0LL;
    sub_1006100F0((uint64_t)v10, 0LL);
  }

  return v7;
}

void *sub_10060FF6C(uint64_t a1, void *a2, uint64_t a3)
{
  uint64_t v5 = (void *)(a1 + 8);
  unint64_t v4 = *(void **)(a1 + 8);
  if (v4)
  {
    uint64_t v7 = a1 + 16;
    do
    {
      while (1)
      {
        __int128 v8 = v4;
        uint64_t v9 = (uint64_t)(v4 + 4);
        unint64_t v4 = (void *)*v8;
        uint64_t v5 = v8;
        if (!*v8) {
          goto LABEL_10;
        }
      }

      if (!sub_10060FE58(v7, v9, a3)) {
        break;
      }
      uint64_t v5 = v8 + 1;
      unint64_t v4 = (void *)v8[1];
    }

    while (v4);
  }

  else
  {
    __int128 v8 = (void *)(a1 + 8);
  }

void *sub_100610008@<X0>(uint64_t a1@<X0>, uint64_t *a2@<X2>, void *a3@<X8>)
{
  uint64_t v5 = a1 + 8;
  *a3 = 0LL;
  a3[1] = 0LL;
  a3[2] = 0LL;
  unsigned int v6 = operator new(0x48uLL);
  *a3 = v6;
  a3[1] = v5;
  *((_BYTE *)a3 + 16) = 0;
  __n128 result = sub_100610080(v6 + 4, *a2);
  v6[8] = 0LL;
  *((_BYTE *)a3 + 16) = 1;
  return result;
}

void sub_100610068(_Unwind_Exception *a1)
{
}

void *sub_100610080(void *a1, uint64_t a2)
{
  uint64_t v4 = *(void *)(a2 + 8);
  *a1 = &off_10087FAA8;
  a1[1] = v4;
  if (v4) {
    sub_1002CD1E0(v4);
  }
  uint64_t v5 = *(void *)(a2 + 24);
  a1[2] = &off_10087FAA8;
  a1[3] = v5;
  if (v5) {
    sub_1002CD1E0(v5);
  }
  return a1;
}

void sub_1006100D4(_Unwind_Exception *exception_object)
{
  void *v1 = v2;
  uint64_t v4 = (unsigned int *)v1[1];
  if (v4) {
    sub_1002CD254(v4);
  }
  _Unwind_Resume(exception_object);
}

void sub_1006100F0(uint64_t a1, uint64_t a2)
{
  uint64_t v2 = *(void **)a1;
  *(void *)a1 = a2;
  if (v2)
  {
    if (*(_BYTE *)(a1 + 16)) {
      sub_10060EF18(v2 + 4);
    }
    operator delete(v2);
  }

void sub_100610134(void ***a1)
{
  uint64_t v1 = *a1;
  uint64_t v2 = **a1;
  if (v2)
  {
    uint64_t v4 = v1[1];
    uint64_t v5 = **a1;
    if (v4 != v2)
    {
      do
      {
        v4 -= 4;
        sub_1006101B8((uint64_t)(v1 + 2), v4);
      }

      while (v4 != v2);
      uint64_t v5 = **a1;
    }

    v1[1] = v2;
    operator delete(v5);
  }

void sub_1006101B8(uint64_t a1, void *a2)
{
  a2[2] = &off_10087FAA8;
  uint64_t v3 = (unsigned int *)a2[3];
  if (v3) {
    sub_1002CD254(v3);
  }
  *a2 = &off_10087FAA8;
  uint64_t v4 = (unsigned int *)a2[1];
  if (v4) {
    sub_1002CD254(v4);
  }
}

void *sub_100610204(uint64_t *a1, void *a2)
{
  uint64_t v5 = *a1;
  uint64_t v4 = a1[1];
  __n128 result = (void *)a2[1];
  while (v4 != v5)
  {
    v4 -= 32LL;
    __n128 result = sub_100610288(result - 4, v4);
  }

  a2[1] = result;
  uint64_t v7 = *a1;
  *a1 = (uint64_t)result;
  a2[1] = v7;
  uint64_t v8 = a1[1];
  a1[1] = a2[2];
  a2[2] = v8;
  uint64_t v9 = a1[2];
  a1[2] = a2[3];
  a2[3] = v9;
  *a2 = a2[1];
  return result;
}

void *sub_100610288(void *a1, uint64_t a2)
{
  uint64_t v4 = *(void *)(a2 + 8);
  *a1 = &off_10087FAA8;
  a1[1] = v4;
  if (v4) {
    sub_1002CD1E0(v4);
  }
  uint64_t v5 = *(void *)(a2 + 24);
  a1[2] = &off_10087FAA8;
  a1[3] = v5;
  if (v5) {
    sub_1002CD1E0(v5);
  }
  return a1;
}

void sub_1006102DC(_Unwind_Exception *exception_object)
{
  void *v1 = v2;
  uint64_t v4 = (unsigned int *)v1[1];
  if (v4) {
    sub_1002CD254(v4);
  }
  _Unwind_Resume(exception_object);
}

void **sub_1006102F8(void **a1)
{
  if (*a1) {
    operator delete(*a1);
  }
  return a1;
}

void sub_100610328(void *a1)
{
  uint64_t v2 = a1[1];
  for (uint64_t i = a1[2]; i != v2; uint64_t i = a1[2])
  {
    uint64_t v4 = a1[4];
    a1[2] = i - 32;
    sub_1006101B8(v4, (void *)(i - 32));
  }

uint64_t sub_10061036C(uint64_t **a1, uint64_t a2)
{
  uint64_t v3 = sub_10060FDCC((uint64_t)a1, a2);
  uint64_t v4 = v3;
  sub_1001FDBCC(a1, v3);
  sub_10060EF18(v4 + 4);
  operator delete(v4);
  return 1LL;
}

uint64_t sub_1006103C4(void *a1)
{
  if (a1 + 4 == sub_100610430(a1 + 1, 0, 0xC0uLL) && v2 == 0LL) {
    return *a1;
  }
  uint64_t v4 = (const char *)sub_100610414("bitset to_ullong overflow error");
  return sub_100610414(v4);
}

uint64_t sub_100610414(const char *a1)
{
  return sub_100610430();
}

void *sub_100610430(void *result, unsigned int a2, unint64_t a3)
{
  if (!a2)
  {
LABEL_8:
    if (a3 >= 0x40)
    {
      do
      {
        if (*result) {
          break;
        }
        ++result;
        a3 -= 64LL;
      }

      while (a3 > 0x3F);
    }

    return result;
  }

  unint64_t v3 = 64 - a2;
  if (v3 >= a3) {
    unint64_t v4 = a3;
  }
  else {
    unint64_t v4 = 64 - a2;
  }
  if (v3 < a3)
  {
    a3 -= v4;
    ++result;
    goto LABEL_8;
  }

  unint64_t v5 = a2 + a3;
  uint64_t v6 = v5 - 63;
  uint64_t v7 = v6 >> 6;
  unint64_t v8 = v5 >> 6;
  if ((a3 & 0x8000000000000000LL) != 0LL) {
    unint64_t v8 = v7;
  }
  result += v8;
  return result;
}

uint64_t **sub_10061052C(uint64_t **result, void *a2, void *a3)
{
  unint64_t v5 = result;
  if (result[2])
  {
    uint64_t v6 = *result;
    uint64_t v7 = result[1];
    *__n128 result = (uint64_t *)(result + 1);
    _DWORD v7[2] = 0LL;
    result[1] = 0LL;
    result[2] = 0LL;
    if (v6[1]) {
      unint64_t v8 = (uint64_t *)v6[1];
    }
    else {
      unint64_t v8 = v6;
    }
    uint64_t v14 = result;
    unsigned int v15 = v8;
    uint64_t v16 = v8;
    if (v8)
    {
      unsigned int v15 = sub_10026145C((uint64_t)v8);
      if (a2 != a3)
      {
        uint64_t v9 = a2;
        do
        {
          v8[4] = v9[4];
          sub_10026EB6C(v5, v8);
          unint64_t v8 = v15;
          uint64_t v16 = v15;
          if (v15) {
            unsigned int v15 = sub_10026145C((uint64_t)v15);
          }
          uint64_t v10 = (void *)v9[1];
          if (v10)
          {
            do
            {
              a2 = v10;
              uint64_t v10 = (void *)*v10;
            }

            while (v10);
          }

          else
          {
            do
            {
              a2 = (void *)v9[2];
              BOOL v11 = *a2 == (void)v9;
              uint64_t v9 = a2;
            }

            while (!v11);
          }

          if (!v8) {
            break;
          }
          uint64_t v9 = a2;
        }

        while (a2 != a3);
      }
    }

    __n128 result = (uint64_t **)sub_1002614B0((uint64_t)&v14);
  }

  if (a2 != a3)
  {
    do
    {
      __n128 result = (uint64_t **)sub_10026EBD8(v5, a2 + 4);
      uint64_t v12 = (void *)a2[1];
      if (v12)
      {
        do
        {
          uint64_t v13 = v12;
          uint64_t v12 = (void *)*v12;
        }

        while (v12);
      }

      else
      {
        do
        {
          uint64_t v13 = (void *)a2[2];
          BOOL v11 = *v13 == (void)a2;
          a2 = v13;
        }

        while (!v11);
      }

      a2 = v13;
    }

    while (v13 != a3);
  }

  return result;
}

void sub_100610678(_Unwind_Exception *a1, uint64_t a2, ...)
{
}

void sub_10061068C(uint64_t a1, void *a2)
{
  if (a2)
  {
    sub_10061068C(a1, *a2);
    sub_10061068C(a1, a2[1]);
    a2[6] = &off_10087FAE8;
    unint64_t v4 = (unsigned int *)a2[7];
    if (v4) {
      sub_1002CD254(v4);
    }
    operator delete(a2);
  }

uint64_t **sub_1006106E4(uint64_t **a1, unsigned int *a2, _DWORD *a3)
{
  uint64_t v6 = a1 + 1;
  unint64_t v5 = a1[1];
  if (v5)
  {
    unsigned int v7 = *a2;
    while (1)
    {
      while (1)
      {
        unint64_t v8 = (uint64_t **)v5;
        unsigned int v9 = *((_DWORD *)v5 + 7);
        if (v7 >= v9) {
          break;
        }
        unint64_t v5 = *v8;
        uint64_t v6 = v8;
        if (!*v8) {
          goto LABEL_10;
        }
      }

      if (v9 >= v7) {
        break;
      }
      unint64_t v5 = v8[1];
      if (!v5)
      {
        uint64_t v6 = v8 + 1;
        goto LABEL_10;
      }
    }
  }

  else
  {
    unint64_t v8 = a1 + 1;
LABEL_10:
    uint64_t v10 = (uint64_t *)operator new(0x20uLL);
    *((_DWORD *)v10 + 7) = *a3;
    sub_100029630(a1, (uint64_t)v8, v6, v10);
    return (uint64_t **)v10;
  }

  return v8;
}

void sub_10061079C(id a1)
{
  uint64_t v1 = operator new(0x138uLL);
  sub_1003FE3E0((uint64_t)v1);
  off_1008D5F48 = v1;
}

void sub_1006107CC(_Unwind_Exception *a1)
{
}

void sub_1006107E0(id a1)
{
  uint64_t v1 = operator new(0xF8uLL);
  sub_1003EC784((uint64_t)v1);
  off_1008D60B8 = v1;
}

void sub_100610810(_Unwind_Exception *a1)
{
}

void sub_100610824(void *a1, os_log_s *a2, uint64_t a3, const char *a4, uint8_t *a5)
{
}

double sub_100610830(double a1)
{
  return a1 * 0.625;
}

  ;
}

  ;
}

void sub_10061088C( void *a1, os_log_s *a2, uint64_t a3, const char *a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint8_t a9)
{
}

  ;
}

void sub_1006108A4()
{
  uint64_t v0 = objc_autoreleasePoolPush();
  sub_1006343C4((uint64_t)byte_1008F1E88, &xmmword_1006C471C, 16LL);
  objc_autoreleasePoolPop(v0);
}

uint64_t sub_1006108E0(uint64_t a1, uint64_t a2, char a3, char a4, char a5)
{
  *(void *)a1 = &off_1008A4280;
  *(void *)(a1 + _Block_object_dispose(va, 8) = a2;
  *(_BYTE *)(a1 + 80) = a3;
  *(_BYTE *)(a1 + 81) = a4;
  *(_BYTE *)(a1 + 82) = a5;
  *(void *)(a1 + 8_Block_object_dispose(va, 8) = 0LL;
  *(_DWORD *)(a1 + 96) = 1;
  *(void *)(a1 + 112) = 0LL;
  *(void *)(a1 + 104) = a1 + 112;
  *(void *)(a1 + 120) = 0LL;
  *(void *)(a1 + 12_Block_object_dispose(va, 8) = a1 + 128;
  *(void *)(a1 + sub_100242FAC(v47 - 160) = 0LL;
  *(void *)(a1 + 136) = a1 + 128;
  *(void *)(a1 + 144) = 0LL;
  *(void *)(a1 + 152) = a1 + 160;
  *(void *)(a1 + 16_Block_object_dispose(va, 8) = 0LL;
  *(_WORD *)(a1 + 176) = 200;
  *(_BYTE *)(a1 + 17_Block_object_dispose(va, 8) = 0;
  *(void *)(a1 + 200) = 0LL;
  *(void *)(a1 + 192) = 0LL;
  *(void *)(a1 + 184) = a1 + 192;
  *(_DWORD *)(a1 + 20_Block_object_dispose(va, 8) = 3;
  *(_WORD *)(a1 + 224) = 257;
  *(void *)(a1 + 232) = 0LL;
  *(void *)(a1 + 240) = 0LL;
  *(void *)(a1 + 24_Block_object_dispose(va, 8) = 0LL;
  uint64_t v6 = sub_1002E6BF0();
  int v16 = 0;
  uint64_t v7 = sub_1002E6E00();
  sub_10002418C(buf, "LESCAN");
  sub_10002418C(__p, "MaxReportsInMap");
  int v8 = (*(uint64_t (**)(uint64_t, uint8_t *, void **, int *))(*(void *)v7 + 88LL))(v7, buf, __p, &v16);
  if (v16 > 0) {
    int v9 = v8;
  }
  else {
    int v9 = 0;
  }
  if (v15 < 0) {
    operator delete(__p[0]);
  }
  if (v18 < 0) {
    operator delete(*(void **)buf);
  }
  uint64_t v10 = (os_log_s *)qword_1008F75B8;
  if (v9)
  {
    BOOL v11 = os_log_type_enabled((os_log_t)qword_1008F75B8, OS_LOG_TYPE_DEFAULT);
    __int16 v12 = v16;
    if (v11)
    {
      *(_DWORD *)std::stringbuf::string_type buf = 67109120;
      *(_DWORD *)&uint8_t buf[4] = v16;
      _os_log_impl( (void *)&_mh_execute_header,  v10,  OS_LOG_TYPE_DEFAULT,  "Warning: Using override value (%d) for max number of ADV reports in map",  buf,  8u);
      __int16 v12 = v16;
      uint64_t v10 = (os_log_s *)qword_1008F75B8;
    }

    *(_WORD *)(a1 + 176) = v12;
  }

  if (os_log_type_enabled(v10, OS_LOG_TYPE_DEBUG)) {
    sub_10069E290(v10);
  }
  *(_OWORD *)(a1 + 4_Block_object_dispose(va, 8) = 0u;
  *(_OWORD *)(a1 + 64) = 0u;
  *(_OWORD *)(a1 + 16) = 0u;
  *(_OWORD *)(a1 + 32) = 0u;
  *(void *)(a1 + 216) = sub_1000B068C();
  *(_BYTE *)(a1 + 64) = *(_BYTE *)(a1 + 81) == 16;
  return a1;
}

void sub_100610B1C( _Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, void *__p, uint64_t a12, int a13, __int16 a14, char a15, char a16, uint64_t a17, void *a18, uint64_t a19, int a20, __int16 a21, char a22, char a23)
{
}

uint64_t sub_100610BA8(uint64_t a1)
{
  *(void *)a1 = &off_1008A4280;
  uint64_t v2 = *(void *)(a1 + 8);
  if (v2)
  {
    unint64_t v3 = (void *)sub_10004FD94(v2);
    operator delete(v3);
  }

  sub_1006185B8(a1 + 184, *(void **)(a1 + 192));
  sub_10023BF24(a1 + 152, *(void **)(a1 + 160));
  sub_10023DF50((void *)(a1 + 128));
  sub_10061068C(a1 + 104, *(void **)(a1 + 112));
  return a1;
}

void sub_100610C24(uint64_t a1)
{
  uint64_t v1 = (void *)sub_100610BA8(a1);
  operator delete(v1);
}

uint64_t sub_100610C38(uint64_t a1)
{
  return **(unsigned __int8 **)(a1 + 8);
}

BOOL sub_100610C44(uint64_t a1)
{
  uint64_t v1 = *(_BYTE **)(a1 + 8);
  if (v1[288])
  {
    int v2 = v1[283];
    return v2 != 0;
  }

  int v4 = *(unsigned __int8 *)(a1 + 81);
  if (v4 != 16)
  {
    if (v4 != 32) {
      return 0LL;
    }
    if (v1[1] && v1[120])
    {
      int v2 = v1[136];
      return v2 != 0;
    }
  }

  return *(int *)(a1 + 96) < 4;
}

BOOL sub_100610CA8(uint64_t a1)
{
  uint64_t v1 = *(void *)(a1 + 8);
  return *(_BYTE *)(v1 + 1) && *(_BYTE *)(v1 + 120) != 0;
}

BOOL sub_100610CCC(uint64_t a1)
{
  if (*(_BYTE *)(a1 + 81) == 32)
  {
    uint64_t v2 = *(void *)(a1 + 8);
    if (*(_BYTE *)(v2 + 1)) {
      return 1LL;
    }
    if ([*(id *)(v2 + 88) count]) {
      return 1LL;
    }
    unint64_t v3 = *(void **)(a1 + 8);
    if (v3[8] != v3[9] || v3[2] != v3[1]) {
      return 1LL;
    }
    uint64_t v7 = v3 + 12;
    uint64_t v6 = v3 + 13;
    return *v7 != *v6;
  }

  if (*(_BYTE *)(a1 + 80))
  {
    uint64_t v5 = *(void *)(a1 + 8);
    uint64_t v6 = (void *)(v5 + 8);
    uint64_t v7 = (void *)(v5 + 16);
    return *v7 != *v6;
  }

  return 0LL;
}

uint64_t sub_100610D68(uint64_t a1)
{
  return *(unsigned __int8 *)(*(void *)(a1 + 8) + 1LL);
}

BOOL sub_100610D74(uint64_t a1)
{
  return [*(id *)(*(void *)(a1 + 8) + 88) count] != 0;
}

BOOL sub_100610D98(uint64_t a1)
{
  return *(void *)(*(void *)(a1 + 8) + 64LL) != *(void *)(*(void *)(a1 + 8) + 72LL);
}

uint64_t sub_100610DAC(uint64_t a1)
{
  return *(unsigned __int8 *)(*(void *)(a1 + 8) + 2LL);
}

BOOL sub_100610DB8(uint64_t a1)
{
  uint64_t v1 = *(void *)(a1 + 8);
  if (*(_BYTE *)(a1 + 81) == 32)
  {
    if (*(_BYTE *)(v1 + 1))
    {
      if (*(void *)(v1 + 8) == *(void *)(v1 + 16))
      {
        if ([*(id *)(v1 + 88) count]) {
          return 0LL;
        }
        uint64_t v1 = *(void *)(a1 + 8);
        if (*(void *)(v1 + 64) != *(void *)(v1 + 72)) {
          return 0LL;
        }
      }
    }
  }

  if (*(void *)(v1 + 8) == *(void *)(v1 + 16)) {
    return 1LL;
  }
  return *(void *)(v1 + 32) != *(void *)(v1 + 40);
}

uint64_t sub_100610E3C(uint64_t a1)
{
  return *(void *)(a1 + 8) + 8LL;
}

id sub_100610E48(uint64_t a1, unsigned __int8 *a2)
{
  id v27 = (id)objc_claimAutoreleasedReturnValue(+[NSMutableArray array](&OBJC_CLASS___NSMutableArray, "array"));
  uint64_t v4 = *(void *)(a1 + 8);
  uint64_t v6 = *(void *)(v4 + 96);
  for (uint64_t i = *(void *)(v4 + 104); v6 != i; v6 += 112LL)
  {
    uint64_t v7 = (os_log_s *)qword_1008F75B8;
    if (os_log_type_enabled((os_log_t)qword_1008F75B8, OS_LOG_TYPE_INFO))
    {
      sub_1006344B4((uint64_t)a2, &v29);
      int size = (char)v29.__r_.__value_.__s.__size_;
      std::string::size_type v9 = v29.__r_.__value_.__r.__words[0];
      sub_1004F1C08(v6, &__p);
      uint64_t v10 = &v29;
      if (size < 0) {
        uint64_t v10 = (std::stringbuf::string_type *)v9;
      }
      p_p = &__p;
      if ((__p.__r_.__value_.__s.__size_ & 0x80u) != 0) {
        p_p = (std::stringbuf::string_type *)__p.__r_.__value_.__r.__words[0];
      }
      *(_DWORD *)std::stringbuf::string_type buf = 136315394;
      *(void *)&uint8_t buf[4] = v10;
      *(_WORD *)&_BYTE buf[12] = 2080;
      *(void *)&buf[14] = p_p;
      _os_log_impl( (void *)&_mh_execute_header,  v7,  OS_LOG_TYPE_INFO,  "enhancedUUIDRulesForUUID uuid:%s filter:%s",  buf,  0x16u);
    }

    if (*(_DWORD *)(v6 + 104) == 1)
    {
      __int128 v12 = *(_OWORD *)(v6 + 20);
      LODWORD(v29.__r_.__value_.__r.__words[2]) = *(_DWORD *)(v6 + 36);
      *(_OWORD *)&v29.__r_.__value_.__l.__data_ = v12;
      if (sub_1001BEC7C((unsigned __int8 *)&v29, a2))
      {
        uint64_t v13 = (void *)objc_claimAutoreleasedReturnValue(+[NSMutableDictionary dictionary](&OBJC_CLASS___NSMutableDictionary, "dictionary"));
        int v14 = *(char *)(v6 + 72);
        int v15 = *a2;
        if (v15 == 2 || v15 == 16)
        {
          *(void *)std::stringbuf::string_type buf = 0LL;
          *(void *)&uint8_t buf[8] = 0LL;
          sub_10063443C(a2, buf);
          if (sub_10056AAD8(v6 + 40))
          {
            if (sub_10056AAD8(v6 + 56) && *(_BYTE *)(v6 + 79))
            {
              if (v14 >= 0) {
                LOBYTE(v14) = -87;
              }
              int v16 = (void *)objc_claimAutoreleasedReturnValue(+[NSData dataWithBytes:length:](&OBJC_CLASS___NSData, "dataWithBytes:length:", buf, *a2));
              [v13 setObject:v16 forKeyedSubscript:@"uuid"];

              uint64_t v17 = sub_10056AAF0(v6 + 40);
              char v18 = +[NSData dataWithBytes:length:]( &OBJC_CLASS___NSData,  "dataWithBytes:length:",  v17,  sub_10056AAD8(v6 + 40));
              BOOL v19 = (void *)objc_claimAutoreleasedReturnValue(v18);
              [v13 setObject:v19 forKeyedSubscript:@"data"];

              uint64_t v20 = sub_10056AAF0(v6 + 56);
              unint64_t v21 = +[NSData dataWithBytes:length:]( &OBJC_CLASS___NSData,  "dataWithBytes:length:",  v20,  sub_10056AAD8(v6 + 56));
              unsigned int v22 = (void *)objc_claimAutoreleasedReturnValue(v21);
              [v13 setObject:v22 forKeyedSubscript:@"mask"];

              BOOL v23 = (void *)objc_claimAutoreleasedReturnValue( +[NSNumber numberWithChar:]( &OBJC_CLASS___NSNumber,  "numberWithChar:",  v14));
              [v13 setObject:v23 forKeyedSubscript:@"rssi"];

              [v27 addObject:v13];
              uint64_t v24 = (os_log_s *)qword_1008F75B8;
              if (os_log_type_enabled((os_log_t)qword_1008F75B8, OS_LOG_TYPE_INFO))
              {
                sub_1004F1C08(v6, &v29);
                unsigned int v25 = &v29;
                if ((v29.__r_.__value_.__s.__size_ & 0x80u) != 0) {
                  unsigned int v25 = (std::stringbuf::string_type *)v29.__r_.__value_.__r.__words[0];
                }
                LODWORD(__p.__r_.__value_.__l.__data_) = 136315394;
                *(std::string::size_type *)((char *)__p.__r_.__value_.__r.__words + 4) = (std::string::size_type)v25;
                WORD2(__p.__r_.__value_.__r.__words[1]) = 2112;
                *(std::string::size_type *)((char *)&__p.__r_.__value_.__r.__words[1] + 6) = (std::string::size_type)v13;
                _os_log_impl( (void *)&_mh_execute_header,  v24,  OS_LOG_TYPE_INFO,  "enhancedRule %s converted to %@",  (uint8_t *)&__p,  0x16u);
              }
            }
          }
        }
      }
    }
  }

  return v27;
}

void sub_1006111DC( _Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void *a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, void *__p, uint64_t a18, int a19, __int16 a20, char a21, char a22)
{
  _Unwind_Resume(a1);
}

BOOL sub_100611258(uint64_t a1)
{
  return sub_100611260(*(void *)(a1 + 8));
}

BOOL sub_100611260(uint64_t a1)
{
  uint64_t v1 = *(void *)(a1 + 64);
  uint64_t v2 = *(void *)(a1 + 72);
  if (v1 == v2) {
    return 0LL;
  }
  uint64_t v3 = v1 + 96;
  do
  {
    id v4 = *(id *)(v3 - 40);
    id v5 = [v4 count];
    BOOL v6 = v5 != 0LL;

    if (v5) {
      BOOL v7 = 1;
    }
    else {
      BOOL v7 = v3 == v2;
    }
    v3 += 96LL;
  }

  while (!v7);
  return v6;
}

void sub_1006112D4(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

uint64_t sub_1006112E4(uint64_t a1)
{
  return *(_BYTE *)(*(void *)(a1 + 8) + 122LL) & 1;
}

uint64_t sub_1006112F4(uint64_t a1)
{
  return (*(unsigned __int8 *)(*(void *)(a1 + 8) + 122LL) >> 1) & 1;
}

BOOL sub_100611304(uint64_t a1)
{
  return *(_BYTE *)(*(void *)(a1 + 8) + 122LL) != 0;
}

uint64_t sub_100611318(uint64_t a1)
{
  return *(_WORD *)(*(void *)(a1 + 8) + 124LL) & 1;
}

uint64_t sub_100611328(uint64_t a1)
{
  return (*(unsigned __int16 *)(*(void *)(a1 + 8) + 124LL) >> 1) & 1;
}

uint64_t sub_100611338(uint64_t a1)
{
  return (*(unsigned __int16 *)(*(void *)(a1 + 8) + 124LL) >> 2) & 1;
}

BOOL sub_100611348(uint64_t a1)
{
  return *(unsigned __int16 *)(*(void *)(a1 + 8) + 124LL) - 1 < 0xFF;
}

uint64_t sub_100611360(uint64_t a1)
{
  return *(unsigned __int8 *)(*(void *)(a1 + 8) + 140LL);
}

uint64_t sub_10061136C(uint64_t a1)
{
  return *(unsigned __int8 *)(*(void *)(a1 + 8) + 141LL);
}

uint64_t sub_100611378(uint64_t a1)
{
  return *(unsigned int *)(*(void *)(a1 + 8) + 168LL);
}

id sub_100611384(uint64_t a1)
{
  return *(id *)(*(void *)(a1 + 8) + 176LL);
}

uint64_t sub_100611390(uint64_t a1, unsigned __int8 *a2, uint64_t a3, void **a4, void *a5)
{
  id v10 = a5;
  BOOL v11 = v10;
  char v48 = 0;
  __int128 v12 = *(_BYTE **)(a3 + 8);
  if (v12[304] && !v12[370])
  {
    uint64_t v19 = *(void *)(a1 + 8);
    goto LABEL_61;
  }

  if (!v12[305])
  {
    [v10 setString:@"default"];
    if (!sub_100611A54(a1)) {
      goto LABEL_17;
    }
    if (!sub_100611AAC(a1))
    {
LABEL_44:
      unsigned int v25 = sub_100618600((uint64_t **)(a1 + 104), a2, a3);
      if ((v26 & 1) == 0)
      {
        id v27 = v25;
        if (!v48 && (sub_100614218(a1, v26, a3, (uint64_t)(v25 + 6)) & 1) == 0)
        {
          int v43 = (os_log_s *)qword_1008F75B8;
          if (os_log_type_enabled((os_log_t)qword_1008F75B8, OS_LOG_TYPE_INFO))
          {
            sub_100366664(a2, out);
            uint64_t v44 = out[23] >= 0 ? out : *(_BYTE **)out;
            *(_DWORD *)std::stringbuf::string_type __p = 136446210;
            *(void *)&__p[4] = v44;
            _os_log_impl( (void *)&_mh_execute_header,  v43,  OS_LOG_TYPE_INFO,  "Ignoring duplicate advertisement data for device %{public}s",  __p,  0xCu);
            if ((out[23] & 0x80000000) != 0) {
              operator delete(*(void **)out);
            }
          }

          goto LABEL_17;
        }

        sub_10002EAC8((uint64_t)(v27 + 6), a3);
      }

      uint64_t v28 = sub_1001FDB10(a1 + 152, a2);
      if (a1 + 160 != v28)
      {
        std::stringbuf::string_type v29 = *(uint64_t **)(v28 + 48);
        uint64_t v30 = *v29;
        *(void *)(v30 + _Block_object_dispose(va, 8) = v29[1];
        *(void *)v29[1] = v30;
        --*(void *)(a1 + 144);
        operator delete(v29);
      }

      __int16 v31 = sub_1005DCFE8(a1 + 128, 0LL, 0LL, a2);
      *__int16 v31 = a1 + 128;
      char v32 = *(void **)(a1 + 136);
      v31[1] = v32;
      void *v32 = v31;
      uint64_t v33 = *(void *)(a1 + 144) + 1LL;
      *(void *)(a1 + 136) = v31;
      *(void *)(a1 + 144) = v33;
      *(void *)uuid_t out = a2;
      sub_1006187DC( (uint64_t **)(a1 + 152),  a2,  (uint64_t)&unk_1006C2518,  (const unsigned __int8 *__attribute__((__org_typedef(uuid_t))) *)out)[6] = (uint64_t)v31;
      if (*(void *)(a1 + 144) <= (unint64_t)*(unsigned __int16 *)(a1 + 176))
      {
        int v38 = 1;
      }

      else
      {
        memset(dst, 0, sizeof(dst));
        uuid_copy(dst, (const unsigned __int8 *)(*(void *)(a1 + 128) + 16LL));
        unsigned int v34 = *(uint64_t **)(a1 + 128);
        uint64_t v35 = *v34;
        *(void *)(v35 + _Block_object_dispose(va, 8) = v34[1];
        *(void *)v34[1] = v35;
        --*(void *)(a1 + 144);
        operator delete(v34);
        unsigned int v36 = (os_log_s *)qword_1008F75B8;
        if (os_log_type_enabled((os_log_t)qword_1008F75B8, OS_LOG_TYPE_INFO))
        {
          memset(out, 0, 37);
          uuid_unparse_upper(dst, out);
          sub_10002418C(__p, out);
          unsigned int v37 = v51 >= 0 ? __p : *(_BYTE **)__p;
          *(_DWORD *)std::stringbuf::string_type buf = 136446210;
          unsigned int v53 = v37;
          _os_log_impl( (void *)&_mh_execute_header,  v36,  OS_LOG_TYPE_INFO,  "doesDeviceMatch: erasing last device %{public}s",  buf,  0xCu);
          if (v51 < 0) {
            operator delete(*(void **)__p);
          }
        }

        sub_1006188F4((uint64_t **)(a1 + 104), dst);
        sub_100618980((uint64_t **)(a1 + 152), dst);
        int v38 = 0;
      }

      unsigned int v39 = (os_log_s *)qword_1008F75B8;
      if (os_log_type_enabled((os_log_t)qword_1008F75B8, OS_LOG_TYPE_DEBUG))
      {
        uint64_t v45 = *(void *)(a1 + 120);
        int v46 = *(unsigned __int16 *)(a1 + 176);
        BOOL v47 = *(void *)(*(void *)(a1 + 8) + 64LL) != *(void *)(*(void *)(a1 + 8) + 72LL);
        *(_DWORD *)uuid_t out = 134219008;
        *(void *)&out[4] = v45;
        *(_WORD *)&out[12] = 1024;
        *(_DWORD *)&out[14] = v46;
        *(_WORD *)&out[18] = 2048;
        *(void *)&out[20] = v45;
        *(_WORD *)&out[28] = 1024;
        *(_DWORD *)&out[30] = v47;
        *(_WORD *)&out[34] = 1024;
        *(_DWORD *)&out[36] = v38;
        _os_log_debug_impl( (void *)&_mh_execute_header,  v39,  OS_LOG_TYPE_DEBUG,  "doesDeviceMatch: fAdvDataMap size:%lu fMaxNumOfReportsInMap:%d fAdvDataMap size:%lu Puck?:%d roomInMap:%d",  out,  0x28u);
      }

      goto LABEL_61;
    }

    unint64_t v13 = sub_10056AAD8(*(void *)(a3 + 8) + 48LL);
    int v14 = (_WORD *)sub_10056AAF0(*(void *)(a3 + 8) + 48LL);
    int v15 = *(_DWORD *)(*(void *)(a1 + 8) + 384LL);
    if (v15)
    {
      if (v15 == 1)
      {
        if (sub_100611B0C(a1) && (sub_100611B74(a1, a2, a3, a4, &v48) & 1) != 0) {
          goto LABEL_44;
        }
        id v17 = [*(id *)(*(void *)(a1 + 8) + 56) count];
        if (v17)
        {
          char v18 = sub_100241F94(a2);
          id v5 = (void *)objc_claimAutoreleasedReturnValue(v18);
          if ((sub_100612014(a1, v5) & 1) != 0)
          {
LABEL_14:

            goto LABEL_44;
          }
        }

        uint64_t v22 = *(void *)(a1 + 8);
        if (*(_BYTE *)(v22 + 137))
        {
          if ((sub_100612110(a1, a2, a3) & 1) != 0)
          {
LABEL_28:
            char v23 = 1;
            goto LABEL_41;
          }

          uint64_t v22 = *(void *)(a1 + 8);
        }

        if (*(void *)(v22 + 64) != *(void *)(v22 + 72))
        {
          if ((sub_100612580(a1, v14, v13, a4, &v48) & 1) != 0) {
            goto LABEL_28;
          }
          uint64_t v22 = *(void *)(a1 + 8);
        }

        if (*(void *)(v22 + 96) != *(void *)(v22 + 104)) {
          goto LABEL_40;
        }
        if (!v17) {
          goto LABEL_17;
        }
        goto LABEL_22;
      }

void sub_1006119F4(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

BOOL sub_100611A54(uint64_t a1)
{
  uint64_t v2 = sub_1002E6BF0();
  char v3 = (*(uint64_t (**)(uint64_t))(*(void *)v2 + 384LL))(v2);
  int v4 = *(unsigned __int8 *)(a1 + 81);
  if ((v4 & 0x30) != 0) {
    char v5 = v3;
  }
  else {
    char v5 = 0;
  }
  return (v5 & 1) != 0 || v4 == 16 || sub_100610CCC(a1);
}

BOOL sub_100611AAC(uint64_t a1)
{
  if (sub_100611B0C(a1)) {
    return 1LL;
  }
  if ([*(id *)(*(void *)(a1 + 8) + 56) count]) {
    return 1LL;
  }
  uint64_t v2 = *(void *)(a1 + 8);
  return *(_BYTE *)(v2 + 137)
      || *(void *)(v2 + 64) != *(void *)(v2 + 72)
      || *(void *)(v2 + 96) != *(void *)(v2 + 104);
}

BOOL sub_100611B0C(uint64_t a1)
{
  if (v5 == v4)
  {
    BOOL v2 = *(void *)(*(void *)(a1 + 8) + 40LL) != *(void *)(*(void *)(a1 + 8) + 32LL);
    if (!v4) {
      return v2;
    }
    goto LABEL_3;
  }

  BOOL v2 = 1LL;
  if (v4)
  {
LABEL_3:
    char v5 = v4;
    operator delete(v4);
  }

  return v2;
}

uint64_t sub_100611B74(uint64_t a1, const unsigned __int8 *a2, uint64_t a3, void **a4, _BYTE *a5)
{
  if (__p[1] == __p[0])
  {
    uint64_t v10 = *(void *)(a1 + 8);
    uint64_t v12 = *(void *)(v10 + 32);
    uint64_t v11 = *(void *)(v10 + 40);
    if (__p[1]) {
      operator delete(__p[1]);
    }
    if (v11 == v12) {
      return 0LL;
    }
  }

  else if (__p[0])
  {
    __p[1] = __p[0];
    operator delete(__p[0]);
  }

  unint64_t v13 = *(void **)(a3 + 8);
  uint64_t v44 = 0LL;
  uint64_t v45 = 0LL;
  uint64_t v46 = 0LL;
  sub_100614AA0(*(void *)(a1 + 8), &v44);
  if (*(void *)(*(void *)(a3 + 8) + 72LL) != *(void *)(*(void *)(a3 + 8) + 64LL))
  {
    uint64_t v14 = sub_100614334(v14, a2, (uint64_t)&v44, (unsigned __int8 **)(*(void *)(a3 + 8) + 64LL));
    if ((v14 & 1) != 0) {
      goto LABEL_39;
    }
  }

  if (v13[16])
  {
    unsigned int v40 = a5;
    __p[0] = 0LL;
    __p[1] = 0LL;
    v50[0] = 0LL;
    int v15 = (void *)v13[14];
    if (v15 != v13 + 15)
    {
      uint64_t v16 = 0LL;
      do
      {
        id v17 = (__int128 *)(v15 + 4);
        if ((unint64_t)v16 >= v50[0])
        {
          unint64_t v19 = 0xCCCCCCCCCCCCCCCDLL * ((v16 - (char *)__p[0]) >> 2);
          unint64_t v20 = v19 + 1;
          if (v19 + 1 > 0xCCCCCCCCCCCCCCCLL) {
            abort();
          }
          else {
            unint64_t v21 = v20;
          }
          if (v21) {
            uint64_t v14 = (uint64_t)sub_100050420((uint64_t)v50, v21);
          }
          else {
            uint64_t v14 = 0LL;
          }
          unint64_t v22 = v14 + 20 * v19;
          __int128 v23 = *v17;
          *(_DWORD *)(v22 + 16) = *((_DWORD *)v15 + 12);
          *(_OWORD *)unint64_t v22 = v23;
          unsigned int v25 = (char *)__p[0];
          uint64_t v24 = (char *)__p[1];
          uint64_t v26 = (char *)v22;
          if (__p[1] != __p[0])
          {
            do
            {
              __int128 v27 = *(_OWORD *)(v24 - 20);
              *((_DWORD *)v26 - 1) = *((_DWORD *)v24 - 1);
              *(_OWORD *)(v26 - 20) = v27;
              v26 -= 20;
              v24 -= 20;
            }

            while (v24 != v25);
            uint64_t v24 = (char *)__p[0];
          }

          uint64_t v16 = (char *)(v22 + 20);
          __p[0] = v26;
          __p[1] = (void *)(v22 + 20);
          v50[0] = v14 + 20 * v21;
          if (v24) {
            operator delete(v24);
          }
        }

        else
        {
          __int128 v18 = *v17;
          *((_DWORD *)v16 + 4) = *((_DWORD *)v15 + 12);
          *(_OWORD *)uint64_t v16 = v18;
          v16 += 20;
        }

        __p[1] = v16;
        uint64_t v28 = (void *)v15[1];
        if (v28)
        {
          do
          {
            std::stringbuf::string_type v29 = v28;
            uint64_t v28 = (void *)*v28;
          }

          while (v28);
        }

        else
        {
          do
          {
            std::stringbuf::string_type v29 = (void *)v15[2];
            BOOL v30 = *v29 == (void)v15;
            int v15 = v29;
          }

          while (!v30);
        }

        int v15 = v29;
      }

      while (v29 != v13 + 15);
    }

    char v31 = sub_100614334(v14, a2, (uint64_t)&v44, (unsigned __int8 **)__p);
    uint64_t v14 = (uint64_t)__p[0];
    a5 = v40;
    if (__p[0])
    {
      __p[1] = __p[0];
      operator delete(__p[0]);
    }

    if ((v31 & 1) != 0) {
      goto LABEL_39;
    }
  }

  uint64_t v32 = *(void *)(a3 + 8);
  if (*(void *)(v32 + 96) != *(void *)(v32 + 88))
  {
    uint64_t v32 = *(void *)(a3 + 8);
  }

  unint64_t v34 = sub_10056AAD8(v32 + 48);
  uint64_t v35 = (_WORD *)sub_10056AAF0(*(void *)(a3 + 8) + 48LL);
  if (v34 < 3 || *v35 != 76 || !sub_100614C7C(a1, (uint64_t)v35, v34, a4, &v43))
  {
    int v38 = (os_log_s *)qword_1008F75B8;
    if (os_log_type_enabled((os_log_t)qword_1008F75B8, OS_LOG_TYPE_DEBUG))
    {
      *(_OWORD *)std::stringbuf::string_type __p = 0u;
      memset(v50, 0, 21);
      uuid_unparse_upper(a2, (char *)__p);
      sub_10002418C(v41, (char *)__p);
      sub_10069E2D0((uint64_t)__p, (char *)v41, (uint64_t)buf, v38);
    }

    uint64_t v33 = 0LL;
    goto LABEL_56;
  }

  unsigned int v36 = (os_log_s *)qword_1008F75B8;
  if (os_log_type_enabled((os_log_t)qword_1008F75B8, OS_LOG_TYPE_INFO))
  {
    *(_OWORD *)std::stringbuf::string_type __p = 0u;
    memset(v50, 0, 21);
    uuid_unparse_upper(a2, (char *)__p);
    sub_10002418C(v41, (char *)__p);
    unsigned int v37 = v42 >= 0 ? v41 : (void **)v41[0];
    *(_DWORD *)std::stringbuf::string_type buf = 136446210;
    char v48 = v37;
    _os_log_impl( (void *)&_mh_execute_header,  v36,  OS_LOG_TYPE_INFO,  "Device %{public}s matched MFG data",  buf,  0xCu);
    if (v42 < 0) {
      operator delete(v41[0]);
    }
  }

  if (*(_BYTE *)(*(void *)(a1 + 8) + 1LL)) {
    *a5 = 1;
  }
LABEL_39:
  uint64_t v33 = 1LL;
LABEL_56:
  if (v44)
  {
    uint64_t v45 = v44;
    operator delete(v44);
  }

  return v33;
}

void sub_100611FB8( _Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, void *__p, uint64_t a19, uint64_t a20, uint64_t a21, uint64_t a22, void *a23, uint64_t a24)
{
  if (__p) {
    operator delete(__p);
  }
  _Unwind_Resume(exception_object);
}

uint64_t sub_100612014(uint64_t a1, void *a2)
{
  id v3 = a2;
  if ([*(id *)(*(void *)(a1 + 8) + 56) count]
    && [*(id *)(*(void *)(a1 + 8) + 56) containsObject:v3])
  {
    int v4 = (os_log_s *)qword_1008F75B8;
    if (os_log_type_enabled((os_log_t)qword_1008F75B8, OS_LOG_TYPE_DEFAULT))
    {
      int v7 = 138543362;
      id v8 = v3;
      _os_log_impl( (void *)&_mh_execute_header,  v4,  OS_LOG_TYPE_DEFAULT,  "Peer %{public}@ matched the peripheral filter",  (uint8_t *)&v7,  0xCu);
    }

    uint64_t v5 = 1LL;
  }

  else
  {
    uint64_t v5 = 0LL;
  }

  return v5;
}

void sub_1006120F4(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

uint64_t sub_100612110(uint64_t a1, const unsigned __int8 *a2, uint64_t a3)
{
  if (!*(_BYTE *)(*(void *)(a1 + 8) + 137LL)) {
    return 0LL;
  }
  uuid_copy(dst, a2);
  uuid_t uu = (unsigned __int8 *)a2;
  memset(&dst[16], 0, 48);
  *(_OWORD *)std::stringbuf::string_type __p = 0u;
  __int128 v32 = 0u;
  int v35 = 0;
  char v36 = 0;
  memset(v33, 0, sizeof(v33));
  uint64_t v5 = sub_1006189D0((uint64_t **)(a1 + 184), dst, (uint64_t)dst);
  sub_100618524(&dst[16]);
  sub_100618524(__p);
  *(void *)uuid_t dst = 0LL;
  sub_1000B0400((uint64_t)dst);
  uint64_t v6 = *(__int16 *)&dst[4];
  unint64_t v7 = *(__int16 *)&dst[4] + 1000LL * *(int *)dst;
  BOOL v8 = v7 >= 0x3E8;
  unint64_t v9 = v7 - 1000;
  if (v8) {
    unint64_t v10 = v9;
  }
  else {
    unint64_t v10 = 0LL;
  }
  int v11 = *(unsigned __int8 *)(*(void *)(a3 + 8) + 216LL);
  if (v11 != 127)
  {
    *(void *)uuid_t dst = *(int *)dst;
    *(void *)&unsigned __int8 dst[8] = v6;
    dst[16] = v11;
    sub_10061531C((uint64_t)(v5 + 6), (__n128 *)dst);
    *((_DWORD *)v5 + 24) += *(char *)(*(void *)(a3 + 8) + 216LL);
  }

  uint64_t v12 = v5[11];
  if (!v12) {
    goto LABEL_17;
  }
  while (1)
  {
    unint64_t v13 = v12 + v5[10] - 1;
    uint64_t v14 = *(void *)(v5[7] + 8 * (v13 / 0xAA));
    unint64_t v15 = v13 % 0xAA;
    uint64_t v16 = (void *)(v14 + 24 * (v13 % 0xAA));
    *(void *)uuid_t dst = 0LL;
    *(_DWORD *)uuid_t dst = *v16;
    *(_WORD *)&dst[4] = v16[1];
    LODWORD(__p[0]) = v10 / 0x3E8;
    HIDWORD(__p[0]) = v10 % 0x3E8;
    uint64_t v17 = v5[11];
    *((_DWORD *)v5 + 24) -= *(char *)(v14 + 24 * v15 + 16);
    v5[11] = v17 - 1;
    sub_100618EAC(v5 + 6, 1);
    uint64_t v12 = v5[11];
    if (!v12) {
      goto LABEL_17;
    }
  }

  uint64_t v18 = v5[11];
  if ((unint64_t)v18 < 0xA)
  {
LABEL_17:
    uint64_t result = 0LL;
    *((_BYTE *)v5 + 100) = 0;
    return result;
  }

  uint64_t v19 = *((unsigned __int8 *)v5 + 100);
  uint64_t v20 = *(void *)(a3 + 8);
  uint64_t v21 = *((int *)v5 + 24) / v18;
  if (*(_BYTE *)(v20 + 42)) {
    LOBYTE(v21) = v21 - *(_BYTE *)(v20 + 43);
  }
  if (*((_BYTE *)v5 + 100))
  {
    if (byte_1006C4825[(v19 - 1)] >= (char)v21)
    {
      char v22 = 1;
    }

    else
    {
      char v22 = -1;
    }

    unsigned __int8 v24 = v19 + v22;
    *((_BYTE *)v5 + 100) = v19 + v22;
  }

  else
  {
    if (v21 == 127)
    {
      unsigned __int8 v24 = 0;
    }

    else
    {
      unsigned __int8 v24 = 0;
      do
        *((_BYTE *)v5 + 100) = ++v24;
      while (byte_1006C4825[v24] > (char)v21);
    }

    if (!v24) {
      goto LABEL_33;
    }
  }

  unsigned int v25 = (os_log_s *)qword_1008F75B8;
  LOBYTE(v19) = v24;
  if (os_log_type_enabled((os_log_t)qword_1008F75B8, OS_LOG_TYPE_DEFAULT))
  {
    memset(dst, 0, 37);
    uuid_unparse_upper(uu, dst);
    sub_10002418C(__p, dst);
    if ((SBYTE7(v32) & 0x80u) == 0) {
      uint64_t v26 = __p;
    }
    else {
      uint64_t v26 = (void **)__p[0];
    }
    int v27 = *((unsigned __int8 *)v5 + 100);
    *(_DWORD *)uuid_t dst = 136446722;
    *(void *)&dst[4] = v26;
    *(_WORD *)&dst[12] = 1024;
    *(_DWORD *)&dst[14] = v27;
    *(_WORD *)&dst[18] = 1024;
    *(_DWORD *)&dst[20] = (char)v21;
    _os_log_impl( (void *)&_mh_execute_header,  v25,  OS_LOG_TYPE_DEFAULT,  "Device %{public}s is now at proximity level %u with an average RSSI of %d dB",  dst,  0x18u);
    if (SBYTE7(v32) < 0) {
      operator delete(__p[0]);
    }
    LOBYTE(v19) = *((_BYTE *)v5 + 100);
  }

void sub_100612554(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, ...)
{
}

uint64_t sub_100612580(uint64_t a1, _WORD *a2, unint64_t a3, void **a4, _BYTE *a5)
{
  if (a3 < 3 || *(void *)(*(void *)(a1 + 8) + 64LL) == *(void *)(*(void *)(a1 + 8) + 72LL) || *a2 != 76) {
    return 0LL;
  }
  else {
    return sub_100614C7C(a1, (uint64_t)a2, a3, a4, a5);
  }
}

uint64_t sub_1006125B0(uint64_t a1, const unsigned __int8 *a2, uint64_t a3, uint64_t a4, void *a5)
{
  id v147 = a5;
  uint64_t v151 = a1;
  uint64_t v7 = *(void *)(a1 + 8);
  if (*(void *)(v7 + 96) == *(void *)(v7 + 104))
  {
    uint64_t v84 = 1LL;
  }

  else
  {
    v181[0] = 0LL;
    v181[1] = 0LL;
    unsigned int v179 = 0LL;
    unsigned int v180 = v181;
    uint64_t v150 = a3;
    BOOL v8 = *(void **)(a3 + 8);
    double v177 = 0LL;
    unsigned int v178 = 0LL;
    if (v8[16])
    {
      unint64_t v9 = (void *)v8[14];
      if (v9 != v8 + 15)
      {
        unint64_t v10 = 0LL;
        do
        {
          int v11 = (__int128 *)(v9 + 4);
          if (v10 >= v179)
          {
            unint64_t v13 = 0xCCCCCCCCCCCCCCCDLL * ((v10 - (_BYTE *)v177) >> 2);
            unint64_t v14 = v13 + 1;
            if (v13 + 1 > 0xCCCCCCCCCCCCCCCLL) {
              abort();
            }
            if (0x999999999999999ALL * ((v179 - (_BYTE *)v177) >> 2) > v14) {
              unint64_t v14 = 0x999999999999999ALL * ((v179 - (_BYTE *)v177) >> 2);
            }
            if (0xCCCCCCCCCCCCCCCDLL * ((v179 - (_BYTE *)v177) >> 2) >= 0x666666666666666LL) {
              unint64_t v15 = 0xCCCCCCCCCCCCCCCLL;
            }
            else {
              unint64_t v15 = v14;
            }
            if (v15) {
              uint64_t v16 = (char *)sub_100050420((uint64_t)&v179, v15);
            }
            else {
              uint64_t v16 = 0LL;
            }
            uint64_t v17 = &v16[20 * v13];
            __int128 v18 = *v11;
            *((_DWORD *)v17 + 4) = *((_DWORD *)v9 + 12);
            *(_OWORD *)uint64_t v17 = v18;
            uint64_t v20 = (char *)v177;
            uint64_t v19 = v178;
            uint64_t v21 = v17;
            if (v178 != v177)
            {
              do
              {
                __int128 v22 = *(_OWORD *)(v19 - 20);
                *((_DWORD *)v21 - 1) = *((_DWORD *)v19 - 1);
                *(_OWORD *)(v21 - 20) = v22;
                v21 -= 20;
                v19 -= 20;
              }

              while (v19 != v20);
              uint64_t v19 = (char *)v177;
            }

            unint64_t v10 = v17 + 20;
            double v177 = v21;
            unsigned int v178 = v17 + 20;
            unsigned int v179 = &v16[20 * v15];
            if (v19) {
              operator delete(v19);
            }
          }

          else
          {
            __int128 v12 = *v11;
            *((_DWORD *)v10 + 4) = *((_DWORD *)v9 + 12);
            *(_OWORD *)unint64_t v10 = v12;
            v10 += 20;
          }

          unsigned int v178 = v10;
          __int128 v23 = (void *)v9[1];
          if (v23)
          {
            do
            {
              unsigned __int8 v24 = v23;
              __int128 v23 = (void *)*v23;
            }

            while (v23);
          }

          else
          {
            do
            {
              unsigned __int8 v24 = (void *)v9[2];
              BOOL v25 = *v24 == (void)v9;
              unint64_t v9 = v24;
            }

            while (!v25);
          }

          unint64_t v9 = v24;
        }

        while (v24 != v8 + 15);
        uint64_t v7 = *(void *)(a1 + 8);
      }
    }

    unsigned __int16 v149 = v8;
    uint64_t v174 = 0LL;
    uint64_t v175 = 0LL;
    uint64_t v176 = 0LL;
    sub_100614268(v7, &v174);
    uint64_t v27 = v174;
    for (uint64_t i = v175; v27 != i; v27 += 112LL)
    {
      uint64_t v28 = *(void *)(v150 + 8);
      uint64_t v29 = *(void *)(v28 + 64);
      uint64_t v30 = *(void *)(v28 + 72);
      char v31 = (unsigned __int8 **)(v28 + 64);
      if (v30 != v29)
      {
        *(_OWORD *)uuid_string_t out = *(_OWORD *)(v27 + 20);
        *(_DWORD *)&out[16] = *(_DWORD *)(v27 + 36);
        __int128 v32 = operator new(0x14uLL);
        *(void *)&__p[8] = v32 + 5;
        *(void *)&__p[16] = v32 + 5;
        *(_OWORD *)__int128 v32 = *(_OWORD *)out;
        v32[4] = *(_DWORD *)&out[16];
        *(void *)std::stringbuf::string_type __p = v32;
        char v33 = sub_100614334((uint64_t)v32, a2, (uint64_t)__p, v31);
        operator delete(v32);
        if ((v33 & 1) != 0) {
          goto LABEL_33;
        }
      }

      if (v178 == v177) {
        goto LABEL_34;
      }
      *(_OWORD *)uuid_string_t out = *(_OWORD *)(v27 + 20);
      *(_DWORD *)&out[16] = *(_DWORD *)(v27 + 36);
      unint64_t v34 = operator new(0x14uLL);
      *(void *)&__p[8] = v34 + 5;
      *(void *)&__p[16] = v34 + 5;
      *(_OWORD *)unint64_t v34 = *(_OWORD *)out;
      v34[4] = *(_DWORD *)&out[16];
      *(void *)std::stringbuf::string_type __p = v34;
      char v35 = sub_100614334((uint64_t)v34, a2, (uint64_t)__p, (unsigned __int8 **)&v177);
      operator delete(v34);
      if ((v35 & 1) == 0)
      {
LABEL_34:
        uint64_t v37 = *(void *)(v150 + 8);
        uint64_t v38 = *(void *)(v37 + 88);
        uint64_t v39 = *(void *)(v37 + 96);
        unsigned int v40 = (unsigned __int8 **)(v37 + 88);
        if (v39 == v38)
        {
          int v36 = 0;
        }

        else
        {
          *(_OWORD *)uuid_string_t out = *(_OWORD *)(v27 + 20);
          *(_DWORD *)&out[16] = *(_DWORD *)(v27 + 36);
          int v41 = operator new(0x14uLL);
          *(void *)&__p[8] = v41 + 5;
          *(void *)&__p[16] = v41 + 5;
          *(_OWORD *)int v41 = *(_OWORD *)out;
          v41[4] = *(_DWORD *)&out[16];
          *(void *)std::stringbuf::string_type __p = v41;
          int v36 = sub_100614334((uint64_t)v41, a2, (uint64_t)__p, v40);
          operator delete(v41);
        }
      }

      else
      {
LABEL_33:
        int v36 = 1;
      }

      id v42 = *(id *)v27;
      sub_10002418C(__p, (char *)[v42 UTF8String]);
      char v43 = (char **)sub_100024098((uint64_t)&v180, (const void **)__p);
      if ((__p[23] & 0x80000000) != 0) {
        operator delete(*(void **)__p);
      }

      if (v181 == v43)
      {
        id v44 = *(id *)v27;
        sub_10002418C(__p, (char *)[v44 UTF8String]);
        *(void *)uuid_string_t out = __p;
        *((_BYTE *)sub_1002925B8((uint64_t **)&v180, (const void **)__p, (uint64_t)&unk_1006C2518, (_OWORD **)out) + 56) = v36;
        if ((__p[23] & 0x80000000) != 0) {
          operator delete(*(void **)__p);
        }
      }

      else
      {
        id v44 = *(id *)v27;
        sub_10002418C(__p, (char *)[v44 UTF8String]);
        *(void *)uuid_string_t out = __p;
        uint64_t v45 = sub_1002925B8((uint64_t **)&v180, (const void **)__p, (uint64_t)&unk_1006C2518, (_OWORD **)out);
        if (*((_BYTE *)v45 + 56)) {
          char v46 = v36;
        }
        else {
          char v46 = 0;
        }
        *((_BYTE *)v45 + 56) = v46;
        if ((__p[23] & 0x80000000) != 0) {
          operator delete(*(void **)__p);
        }
      }

      BOOL v47 = (os_log_s *)qword_1008F75B8;
      if (os_log_type_enabled((os_log_t)qword_1008F75B8, OS_LOG_TYPE_INFO))
      {
        uint64_t v48 = v151 + 232;
        memset(out, 0, sizeof(out));
        uuid_unparse_upper(a2, out);
        sub_10002418C(&v171, out);
        if (v173 >= 0) {
          id v49 = &v171;
        }
        else {
          id v49 = v171;
        }
        __int128 v50 = *(_OWORD *)(v27 + 20);
        LODWORD(v188.__r_.__value_.__r.__words[2]) = *(_DWORD *)(v27 + 36);
        *(_OWORD *)&v188.__r_.__value_.__l.__data_ = v50;
        sub_1006344B4((uint64_t)&v188, out);
        if (out[23] >= 0) {
          char v51 = out;
        }
        else {
          char v51 = *(char **)out;
        }
        id v52 = *(id *)v27;
        id v53 = *(id *)v27;
        sub_10002418C(&v191, (char *)[v53 UTF8String]);
        v170.__r_.__value_.__r.__words[0] = (std::string::size_type)&v191;
        int v54 = *((unsigned __int8 *)sub_1002925B8( (uint64_t **)&v180,  (const void **)&v191,  (uint64_t)&unk_1006C2518,  &v170)
              + 56);
        *(_DWORD *)std::stringbuf::string_type __p = 136316418;
        *(void *)&__p[4] = v48;
        *(_WORD *)&_BYTE __p[12] = 2080;
        *(void *)&__p[14] = v49;
        *(_WORD *)&_BYTE __p[22] = 2080;
        *(void *)BOOL v184 = v51;
        *(_WORD *)&v184[8] = 1024;
        *(_DWORD *)int v185 = v36;
        *(_WORD *)&v185[4] = 2112;
        *(void *)&v185[6] = v52;
        *(_WORD *)&v185[14] = 1024;
        *(_DWORD *)&v185[16] = v54;
        _os_log_impl( (void *)&_mh_execute_header,  v47,  OS_LOG_TYPE_INFO,  "filterByEnhancedRules uuidWithoutBlobAndMask session:%s device:%s uuid:%s match:%d matchMap[%@]:%d",  __p,  0x36u);
        if (SHIBYTE(v192) < 0) {
          operator delete((void *)v191);
        }

        if (out[23] < 0) {
          operator delete(*(void **)out);
        }
        if (SHIBYTE(v173) < 0) {
          operator delete(v171);
        }
      }
    }

    int v171 = 0LL;
    uint64_t v172 = 0LL;
    uint64_t v173 = 0LL;
    sub_100614500(*(void *)(v151 + 8), (uint64_t *)&v171);
    std::stringbuf::string_type v148 = v172;
    __int128 v161 = (char *)v171;
    if (v172 != v171 && v149[16])
    {
      unsigned int v153 = v149 + 15;
      while (1)
      {
        id v55 = (void *)v149[14];
        if (v55 != v153) {
          break;
        }
LABEL_122:
        v161 += 112;
        if (v161 == v148) {
          goto LABEL_123;
        }
      }

      char v164 = 0;
      uint64_t v155 = (uint64_t)(v161 + 40);
      char v157 = (__int128 *)(v161 + 20);
      uint64_t v152 = (uint64_t)(v161 + 56);
      while (1)
      {
        __int128 v191 = *v157;
        LODWORD(v192) = *((_DWORD *)v161 + 9);
        unsigned int v56 = operator new(0x14uLL);
        *(void *)&__p[8] = v56 + 5;
        *(void *)&__p[16] = v56 + 5;
        *(_OWORD *)unsigned int v56 = v191;
        v56[4] = v192;
        *(void *)std::stringbuf::string_type __p = v56;
        *(_OWORD *)&v188.__r_.__value_.__l.__data_ = *((_OWORD *)v55 + 2);
        LODWORD(v188.__r_.__value_.__r.__words[2]) = *((_DWORD *)v55 + 12);
        BOOL v57 = operator new(0x14uLL);
        *(void *)&out[8] = v57 + 5;
        *(void *)&out[16] = v57 + 5;
        *(_OWORD *)BOOL v57 = *(_OWORD *)&v188.__r_.__value_.__l.__data_;
        v57[4] = v188.__r_.__value_.__r.__words[2];
        *(void *)uuid_string_t out = v57;
        if ((sub_100614334((uint64_t)v57, a2, (uint64_t)__p, (unsigned __int8 **)out) & 1) != 0)
        {
          unsigned int v58 = (unsigned __int8 *)sub_10056AAF0((uint64_t)(v55 + 7));
          size_t v59 = sub_10056AAD8((uint64_t)(v55 + 7));
          size_t v60 = sub_10056AAD8(v155);
          unint64_t v61 = (unsigned __int8 *)sub_10056AAF0(v152);
          uint64_t v62 = (unsigned __int8 *)sub_10056AAF0(v155);
          BOOL v63 = sub_1006145CC((uint64_t)v62, v58, v59, v60, v61, v62);
          BOOL v57 = *(_DWORD **)out;
          v164 |= v63;
          char v64 = v164 & 1;
          if (!*(void *)out) {
            goto LABEL_75;
          }
        }

        else
        {
          char v64 = v164 & 1;
        }

        operator delete(v57);
LABEL_75:
        if (*(void *)__p) {
          operator delete(*(void **)__p);
        }
        id v65 = *(id *)v161;
        sub_10002418C(__p, (char *)[v65 UTF8String]);
        unsigned __int16 v66 = (char **)sub_100024098((uint64_t)&v180, (const void **)__p);
        if ((__p[23] & 0x80000000) != 0) {
          operator delete(*(void **)__p);
        }

        if (v181 == v66)
        {
          id v67 = *(id *)v161;
          sub_10002418C(__p, (char *)[v67 UTF8String]);
          *(void *)uuid_string_t out = __p;
          *((_BYTE *)sub_1002925B8((uint64_t **)&v180, (const void **)__p, (uint64_t)&unk_1006C2518, (_OWORD **)out) + 56) = v64;
          if ((__p[23] & 0x80000000) != 0) {
            operator delete(*(void **)__p);
          }
        }

        else
        {
          id v67 = *(id *)v161;
          sub_10002418C(__p, (char *)[v67 UTF8String]);
          *(void *)uuid_string_t out = __p;
          unsigned int v68 = sub_1002925B8((uint64_t **)&v180, (const void **)__p, (uint64_t)&unk_1006C2518, (_OWORD **)out);
          *((_BYTE *)v68 + 56) = v164 & (*((_BYTE *)v68 + 56) != 0);
          if ((__p[23] & 0x80000000) != 0) {
            operator delete(*(void **)__p);
          }
        }

        unsigned __int8 v69 = (os_log_s *)qword_1008F75B8;
        if (os_log_type_enabled((os_log_t)qword_1008F75B8, OS_LOG_TYPE_INFO))
        {
          uint64_t v70 = v151 + 232;
          memset(out, 0, sizeof(out));
          uuid_unparse_upper(a2, out);
          sub_10002418C(&v191, out);
          if (v192 >= 0) {
            uint64_t v71 = &v191;
          }
          else {
            uint64_t v71 = (__int128 *)v191;
          }
          __int128 v189 = *v157;
          int v190 = *((_DWORD *)v161 + 9);
          sub_1006344B4((uint64_t)&v189, out);
          if (out[23] >= 0) {
            char v72 = out;
          }
          else {
            char v72 = *(char **)out;
          }
          sub_10056B0A4((uint64_t)(v55 + 7), &v188);
          if ((v188.__r_.__value_.__s.__size_ & 0x80u) == 0) {
            uint64_t v73 = &v188;
          }
          else {
            uint64_t v73 = (std::stringbuf::string_type *)v188.__r_.__value_.__r.__words[0];
          }
          sub_10056B0A4(v155, &v170);
          if ((v170.__r_.__value_.__s.__size_ & 0x80u) == 0) {
            char v74 = &v170;
          }
          else {
            char v74 = (std::stringbuf::string_type *)v170.__r_.__value_.__r.__words[0];
          }
          sub_10056B0A4(v152, &v169);
          if ((v169.__r_.__value_.__s.__size_ & 0x80u) == 0) {
            uint64_t v75 = &v169;
          }
          else {
            uint64_t v75 = (std::stringbuf::string_type *)v169.__r_.__value_.__r.__words[0];
          }
          id v76 = *(id *)v161;
          id v77 = *(id *)v161;
          sub_10002418C(v167, (char *)[v77 UTF8String]);
          unsigned __int16 v182 = v167;
          int v78 = *((unsigned __int8 *)sub_1002925B8( (uint64_t **)&v180,  (const void **)v167,  (uint64_t)&unk_1006C2518,  (_OWORD **)&v182)
                + 56);
          *(_DWORD *)std::stringbuf::string_type __p = 136317186;
          *(void *)&__p[4] = v70;
          *(_WORD *)&_BYTE __p[12] = 2080;
          *(void *)&__p[14] = v71;
          *(_WORD *)&_BYTE __p[22] = 2080;
          *(void *)BOOL v184 = v72;
          *(_WORD *)&v184[8] = 2080;
          *(void *)int v185 = v73;
          *(_WORD *)&v185[8] = 2080;
          *(void *)&v185[10] = v74;
          *(_WORD *)&v185[18] = 2080;
          *(void *)&v185[20] = v75;
          *(_WORD *)&v185[28] = 1024;
          *(_DWORD *)&v185[30] = v164 & 1;
          *(_WORD *)&v185[34] = 2112;
          *(void *)int v186 = v76;
          *(_WORD *)&v186[8] = 1024;
          v187[0] = v78;
          _os_log_impl( (void *)&_mh_execute_header,  v69,  OS_LOG_TYPE_INFO,  "filterByEnhancedRules uuidWithBlobAndMask session:%s device:%s uuid:%s data:%s blob:%s mask:%s match:%d matchMap[%@]:%d",  __p,  0x54u);
          if (v168 < 0) {
            operator delete(v167[0]);
          }

          if (out[23] < 0) {
            operator delete(*(void **)out);
          }
          if (SHIBYTE(v192) < 0) {
            operator delete((void *)v191);
          }
        }

        uint64_t v79 = (void *)v55[1];
        if (v79)
        {
          do
          {
            uint64_t v80 = v79;
            uint64_t v79 = (void *)*v79;
          }

          while (v79);
        }

        else
        {
          do
          {
            uint64_t v80 = (void *)v55[2];
            BOOL v25 = *v80 == (void)v55;
            id v55 = v80;
          }

          while (!v25);
        }

        id v55 = v80;
        if (v80 == v153) {
          goto LABEL_122;
        }
      }
    }

void sub_100613D08( _Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, void *a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20, uint64_t a21, uint64_t a22, uint64_t a23, uint64_t a24, uint64_t a25, uint64_t a26, uint64_t a27, uint64_t a28, uint64_t a29, void *a30, uint64_t a31, uint64_t a32, void *a33, uint64_t a34, uint64_t a35, void *a36, uint64_t a37, uint64_t a38, uint64_t a39, uint64_t a40, uint64_t a41, char a42, uint64_t a43, uint64_t a44, void *__p, uint64_t a46, uint64_t a47, char a48, uint64_t a49, uint64_t a50,uint64_t a51,uint64_t a52,void *a53)
{
  a53 = &a39;
  sub_10004FF34((void ***)&a53);
  a53 = &a42;
  sub_10004FF34((void ***)&a53);
  if (__p)
  {
    a46 = (uint64_t)__p;
    operator delete(__p);
  }

  sub_10023E78C((uint64_t)&a48, (char *)a49);

  _Unwind_Resume(a1);
}

uint64_t sub_100614218(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  uint64_t v4 = *(void *)(a1 + 8);
  if (*(_BYTE *)v4 || [*(id *)(v4 + 88) count]) {
    return 1LL;
  }
  else {
    return sub_10056BEC8(*(void *)(a3 + 8), *(void *)(a4 + 8)) ^ 1;
  }
}

uint64_t sub_100614268@<X0>(uint64_t result@<X0>, uint64_t *a2@<X8>)
{
  *a2 = 0LL;
  a2[1] = 0LL;
  a2[2] = 0LL;
  uint64_t v3 = *(void *)(result + 96);
  uint64_t v4 = *(void *)(result + 104);
  if (v3 != v4)
  {
    uint64_t v5 = v3 + 56;
    do
    {
      if (*(_DWORD *)(v5 + 48) == 1)
      {
        if (sub_10056AAC8(v5 - 16) || (uint64_t result = sub_10056AAC8(v5), (_DWORD)result))
        {
          uint64_t v6 = v5 - 56;
          unint64_t v7 = a2[1];
          if (v7 >= a2[2])
          {
            uint64_t result = sub_100618294(a2, v6);
          }

          else
          {
            sub_1006183A8(a2[1], v6);
            uint64_t result = v7 + 112;
            a2[1] = v7 + 112;
          }

          a2[1] = result;
        }
      }

      v5 += 112LL;
    }

    while (v5 - 56 != v4);
  }

  return result;
}

void sub_100614310( _Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, void **a10)
{
  *(void *)(v10 + _Block_object_dispose(va, 8) = v11;
  a10 = (void **)v10;
  sub_10004FF34(&a10);
  _Unwind_Resume(a1);
}

uint64_t sub_100614334(uint64_t a1, const unsigned __int8 *a2, uint64_t a3, unsigned __int8 **a4)
{
  uint64_t v4 = *(unsigned __int8 **)a3;
  if (*(void *)a3 == *(void *)(a3 + 8)) {
    return 0LL;
  }
  BOOL v8 = a4[1];
  while (1)
  {
    unint64_t v9 = *a4;
    if (*a4 == v8)
    {
      unint64_t v9 = v8;
    }

    else
    {
      while (!sub_1001BEC7C(v9, v4))
      {
        v9 += 20;
        if (v9 == v8)
        {
          unint64_t v9 = v8;
          break;
        }
      }

      BOOL v8 = a4[1];
    }

    if (v9 != v8) {
      break;
    }
    v4 += 20;
  }

  uint64_t v11 = (os_log_s *)qword_1008F75B8;
  if (os_log_type_enabled((os_log_t)qword_1008F75B8, OS_LOG_TYPE_DEFAULT))
  {
    sub_1006344B4((uint64_t)v4, v16);
    if (v17 >= 0) {
      __int128 v12 = v16;
    }
    else {
      __int128 v12 = (void **)v16[0];
    }
    memset(out, 0, 37);
    uuid_unparse_upper(a2, out);
    sub_10002418C(__p, out);
    if (v15 >= 0) {
      unint64_t v13 = __p;
    }
    else {
      unint64_t v13 = (void **)__p[0];
    }
    *(_DWORD *)std::stringbuf::string_type buf = 136446466;
    uint64_t v19 = v12;
    __int16 v20 = 2082;
    uint64_t v21 = v13;
    _os_log_impl( (void *)&_mh_execute_header,  v11,  OS_LOG_TYPE_DEFAULT,  "Matched UUID %{public}s for device %{public}s",  buf,  0x16u);
    if (v15 < 0) {
      operator delete(__p[0]);
    }
    if (v17 < 0) {
      operator delete(v16[0]);
    }
  }

  return 1LL;
}

void sub_1006144DC( _Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, void *__p, uint64_t a13, int a14, __int16 a15, char a16, char a17)
{
}

uint64_t sub_100614500@<X0>(uint64_t result@<X0>, uint64_t *a2@<X8>)
{
  *a2 = 0LL;
  a2[1] = 0LL;
  a2[2] = 0LL;
  uint64_t v3 = *(void *)(result + 96);
  uint64_t v4 = *(void *)(result + 104);
  if (v3 != v4)
  {
    uint64_t v5 = v3 + 56;
    do
    {
      if (*(_DWORD *)(v5 + 48) == 1)
      {
        uint64_t result = sub_10056AAC8(v5 - 16);
        if ((result & 1) == 0)
        {
          uint64_t result = sub_10056AAC8(v5);
          if ((result & 1) == 0)
          {
            uint64_t v6 = v5 - 56;
            unint64_t v7 = a2[1];
            if (v7 >= a2[2])
            {
              uint64_t result = sub_100618294(a2, v6);
            }

            else
            {
              sub_1006183A8(a2[1], v6);
              uint64_t result = v7 + 112;
              a2[1] = v7 + 112;
            }

            a2[1] = result;
          }
        }
      }

      v5 += 112LL;
    }

    while (v5 - 56 != v4);
  }

  return result;
}

void sub_1006145A8( _Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, void **a10)
{
  *(void *)(v10 + _Block_object_dispose(va, 8) = v11;
  a10 = (void **)v10;
  sub_10004FF34(&a10);
  _Unwind_Resume(a1);
}

BOOL sub_1006145CC( uint64_t a1, unsigned __int8 *a2, size_t a3, size_t a4, unsigned __int8 *a5, unsigned __int8 *a6)
{
  uint64_t v10 = (os_log_s *)qword_1008F75B8;
  if (os_log_type_enabled((os_log_t)qword_1008F75B8, OS_LOG_TYPE_INFO))
  {
    sub_10056AB04(&v28, a2, a3);
    sub_10056B0A4((uint64_t)&v28, &v30);
    if ((v30.__r_.__value_.__s.__size_ & 0x80u) == 0) {
      uint64_t v11 = &v30;
    }
    else {
      uint64_t v11 = (std::stringbuf::string_type *)v30.__r_.__value_.__r.__words[0];
    }
    sub_10056AB04(&v25, a6, a4);
    sub_10056B0A4((uint64_t)&v25, &v27);
    if ((v27.__r_.__value_.__s.__size_ & 0x80u) == 0) {
      __int128 v12 = &v27;
    }
    else {
      __int128 v12 = (std::stringbuf::string_type *)v27.__r_.__value_.__r.__words[0];
    }
    sub_10056AB04(&v22, a5, a4);
    sub_10056B0A4((uint64_t)&v22, &__p);
    if ((__p.__r_.__value_.__s.__size_ & 0x80u) == 0) {
      p_p = &__p;
    }
    else {
      p_p = (std::stringbuf::string_type *)__p.__r_.__value_.__r.__words[0];
    }
    *(_DWORD *)std::stringbuf::string_type buf = 136315650;
    __int128 v32 = v11;
    __int16 v33 = 2080;
    *(void *)unint64_t v34 = v12;
    *(_WORD *)&v34[8] = 2080;
    char v35 = p_p;
    _os_log_impl( (void *)&_mh_execute_header,  v10,  OS_LOG_TYPE_INFO,  "matchMaskAndBlob data:%s blob:%s mask:%s",  buf,  0x20u);
    __int128 v22 = &off_10087FAA8;
    if (v23) {
      sub_1002CD254(v23);
    }
    BOOL v25 = &off_10087FAA8;
    if (v26) {
      sub_1002CD254(v26);
    }
    uint64_t v28 = &off_10087FAA8;
    if (v29) {
      sub_1002CD254(v29);
    }
  }

  if (a3 >= a4)
  {
    if (a4)
    {
      BOOL v14 = 0;
      char v15 = 0LL;
      uint64_t v16 = (os_log_s *)qword_1008F75B8;
      do
      {
        int v17 = v15->__r_.__value_.__s.__data_[(void)a2];
        int v18 = v15->__r_.__value_.__s.__data_[(void)a5];
        if (os_log_type_enabled(v16, OS_LOG_TYPE_INFO))
        {
          int v19 = v15->__r_.__value_.__s.__data_[(void)a6];
          *(_DWORD *)std::stringbuf::string_type buf = 134219008;
          __int128 v32 = v15;
          __int16 v33 = 1024;
          *(_DWORD *)unint64_t v34 = v17;
          *(_WORD *)&v34[4] = 1024;
          *(_DWORD *)&v34[6] = v18;
          LOWORD(v35) = 1024;
          *(_DWORD *)((char *)&v35 + 2) = v19;
          HIWORD(v35) = 1024;
          int v36 = v18 & v17;
          _os_log_impl( (void *)&_mh_execute_header,  v16,  OS_LOG_TYPE_INFO,  "matchMaskAndBlob byteIndex:%zu data:0x%02X mask:0x%02X blob:0x%02X result:0x%02X",  buf,  0x24u);
          uint64_t v16 = (os_log_s *)qword_1008F75B8;
        }

        char v15 = (std::stringbuf::string_type *)((char *)v15 + 1);
        BOOL v14 = (unint64_t)v15 >= a4;
      }

      while ((std::stringbuf::string_type *)a4 != v15);
    }

    else
    {
      return 1;
    }
  }

  else
  {
    return 0;
  }

  return v14;
}

void sub_100614894( _Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, unsigned int *a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, unsigned int *a18, void *__p, uint64_t a20, int a21, __int16 a22, char a23, char a24, uint64_t a25, unsigned int *a26, void *a27, uint64_t a28, int a29, __int16 a30, char a31, char a32)
{
  if (a13) {
    sub_1002CD254(a13);
  }
  if (a24 < 0) {
    operator delete(__p);
  }
  if (a18) {
    sub_1002CD254(a18);
  }
  if (a32 < 0) {
    operator delete(a27);
  }
  if (a26) {
    sub_1002CD254(a26);
  }
  _Unwind_Resume(exception_object);
}

uint64_t sub_100614930@<X0>(uint64_t result@<X0>, uint64_t *a2@<X8>)
{
  *a2 = 0LL;
  a2[1] = 0LL;
  a2[2] = 0LL;
  uint64_t v2 = *(void *)(result + 96);
  uint64_t v3 = *(void *)(result + 104);
  if (v2 != v3)
  {
    unint64_t v5 = 0LL;
    do
    {
      if (*(_DWORD *)(v2 + 104) == 2)
      {
        if (v5 >= a2[2])
        {
          uint64_t result = sub_100618294(a2, v2);
          unint64_t v5 = result;
        }

        else
        {
          uint64_t result = sub_1006183A8(v5, v2);
          v5 += 112LL;
          a2[1] = v5;
        }

        a2[1] = v5;
      }

      v2 += 112LL;
    }

    while (v2 != v3);
  }

  return result;
}

void sub_1006149C4(_Unwind_Exception *a1, uint64_t a2, ...)
{
}

uint64_t sub_1006149E8@<X0>(uint64_t result@<X0>, uint64_t *a2@<X8>)
{
  *a2 = 0LL;
  a2[1] = 0LL;
  a2[2] = 0LL;
  uint64_t v2 = *(void *)(result + 96);
  uint64_t v3 = *(void *)(result + 104);
  if (v2 != v3)
  {
    unint64_t v5 = 0LL;
    do
    {
      if (*(_DWORD *)(v2 + 104) == 3)
      {
        if (v5 >= a2[2])
        {
          uint64_t result = sub_100618294(a2, v2);
          unint64_t v5 = result;
        }

        else
        {
          uint64_t result = sub_1006183A8(v5, v2);
          v5 += 112LL;
          a2[1] = v5;
        }

        a2[1] = v5;
      }

      v2 += 112LL;
    }

    while (v2 != v3);
  }

  return result;
}

void sub_100614A7C(_Unwind_Exception *a1, uint64_t a2, ...)
{
}

void sub_100614AA0(uint64_t a1@<X0>, void **a2@<X8>)
{
  *a2 = 0LL;
  a2[1] = 0LL;
  a2[2] = 0LL;
  uint64_t v3 = *(__int128 **)(a1 + 8);
  for (i = *(__int128 **)(a1 + 16); v3 != i; uint64_t v3 = (__int128 *)((char *)v3 + 20))
  {
    __int128 v6 = *v3;
    int v23 = *((_DWORD *)v3 + 4);
    __int128 v22 = v6;
    if ((sub_10061847C(a1, (unsigned __int8 *)&v22) & 1) == 0)
    {
      BOOL v8 = (char *)a2[1];
      unint64_t v7 = (char *)a2[2];
      if (v8 >= v7)
      {
        unint64_t v11 = 0xCCCCCCCCCCCCCCCDLL * ((v8 - (_BYTE *)*a2) >> 2);
        unint64_t v12 = v11 + 1;
        if (v11 + 1 > 0xCCCCCCCCCCCCCCCLL) {
          abort();
        }
        unint64_t v13 = 0xCCCCCCCCCCCCCCCDLL * ((v7 - (_BYTE *)*a2) >> 2);
        if (2 * v13 > v12) {
          unint64_t v12 = 2 * v13;
        }
        if (v13 >= 0x666666666666666LL) {
          unint64_t v14 = 0xCCCCCCCCCCCCCCCLL;
        }
        else {
          unint64_t v14 = v12;
        }
        if (v14) {
          char v15 = (char *)sub_100050420((uint64_t)(a2 + 2), v14);
        }
        else {
          char v15 = 0LL;
        }
        uint64_t v16 = &v15[20 * v11];
        __int128 v17 = *v3;
        *((_DWORD *)v16 + 4) = *((_DWORD *)v3 + 4);
        *(_OWORD *)uint64_t v16 = v17;
        int v19 = (char *)*a2;
        int v18 = (char *)a2[1];
        __int16 v20 = v16;
        if (v18 != *a2)
        {
          do
          {
            __int128 v21 = *(_OWORD *)(v18 - 20);
            *((_DWORD *)v20 - 1) = *((_DWORD *)v18 - 1);
            *(_OWORD *)(v20 - 20) = v21;
            v20 -= 20;
            v18 -= 20;
          }

          while (v18 != v19);
          int v18 = (char *)*a2;
        }

        uint64_t v10 = v16 + 20;
        *a2 = v20;
        a2[1] = v16 + 20;
        a2[2] = &v15[20 * v14];
        if (v18) {
          operator delete(v18);
        }
      }

      else
      {
        __int128 v9 = *v3;
        *((_DWORD *)v8 + 4) = *((_DWORD *)v3 + 4);
        *(_OWORD *)BOOL v8 = v9;
        uint64_t v10 = v8 + 20;
      }

      a2[1] = v10;
    }
  }

void sub_100614C5C(_Unwind_Exception *exception_object)
{
  uint64_t v3 = *(void **)v1;
  if (*(void *)v1)
  {
    *(void *)(v1 + _Block_object_dispose(va, 8) = v3;
    operator delete(v3);
  }

  _Unwind_Resume(exception_object);
}

uint64_t sub_100614C7C(uint64_t a1, uint64_t a2, unint64_t a3, void **a4, _BYTE *a5)
{
  uint64_t v8 = sub_1002E6E00();
  if ((*(unsigned int (**)(uint64_t))(*(void *)v8 + 8LL))(v8))
  {
    uint64_t v9 = sub_1002E6BF0();
    if ((*(unsigned int (**)(uint64_t))(*(void *)v9 + 408LL))(v9))
    {
      uint64_t v10 = sub_1002E6BF0();
      (*(void (**)(uint64_t, uint64_t))(*(void *)v10 + 976LL))(v10, 1LL);
    }
  }

  if (a3 >= 3)
  {
    uint64_t v11 = 2LL;
    unsigned int v12 = 2;
    while (1)
    {
      uint64_t v13 = a2 + v11;
      unint64_t v14 = *(unsigned __int8 *)(a2 + v11);
      if ((_DWORD)v14 == 1)
      {
        if (v12 + 16 >= a3)
        {
          uint64_t v46 = qword_1008F75B8;
          char v18 = 0;
          if (!os_log_type_enabled((os_log_t)qword_1008F75B8, OS_LOG_TYPE_DEFAULT)) {
            goto LABEL_75;
          }
          *(_WORD *)size_t v60 = 0;
          BOOL v47 = "Invalid length";
          goto LABEL_72;
        }

        uint64_t v15 = *(void *)(a1 + 8);
        if (*(void *)(v15 + 16) != *(void *)(v15 + 8))
        {
          unint64_t v61 = 0LL;
          v62[0] = 0LL;
          *(void *)size_t v60 = 0LL;
          sub_100050EE8( (char *)v60,  *(__int128 **)(v15 + 8),  *(__int128 **)(v15 + 16),  0xCCCCCCCCCCCCCCCDLL * ((uint64_t)(*(void *)(v15 + 16) - *(void *)(v15 + 8)) >> 2));
          __int128 v17 = *(_DWORD **)v60;
          uint64_t v16 = v61;
          if (*(_DWORD **)v60 == v61)
          {
            char v18 = 0;
          }

          else
          {
            char v18 = 0;
            uint64_t v19 = v13 + 1;
            do
            {
              __int16 v59 = 0;
              int v20 = v17[4];
              __int128 v69 = *(_OWORD *)v17;
              int v70 = v20;
              sub_100404798((unsigned __int8 *)&v69, (_BYTE *)&v59 + 1, &v59);
              if (HIBYTE(v59) <= 0xFuLL && ((*(unsigned __int8 *)(v19 + HIBYTE(v59)) >> v59) & 1) != 0)
              {
                __int128 v21 = (os_log_s *)qword_1008F75B8;
                if (os_log_type_enabled((os_log_t)qword_1008F75B8, OS_LOG_TYPE_DEFAULT))
                {
                  sub_1006344B4((uint64_t)v17, __p);
                  __int128 v22 = __p;
                  if (v58 < 0) {
                    __int128 v22 = (void **)__p[0];
                  }
                  *(_DWORD *)std::stringbuf::string_type buf = 136446722;
                  char v64 = v22;
                  __int16 v65 = 1024;
                  int v66 = HIBYTE(v59);
                  __int16 v67 = 1024;
                  int v68 = v59;
                  _os_log_impl( (void *)&_mh_execute_header,  v21,  OS_LOG_TYPE_DEFAULT,  "Tentatively matched UUID %{public}s (@ byte: %u, bit: %u)",  buf,  0x18u);
                  if (v58 < 0) {
                    operator delete(__p[0]);
                  }
                }

                unsigned __int8 v24 = (char *)a4[1];
                int v23 = (char *)a4[2];
                if (v24 >= v23)
                {
                  unint64_t v27 = 0xCCCCCCCCCCCCCCCDLL * ((v24 - (_BYTE *)*a4) >> 2);
                  unint64_t v28 = v27 + 1;
                  if (v27 + 1 > 0xCCCCCCCCCCCCCCCLL) {
                    abort();
                  }
                  unint64_t v29 = 0xCCCCCCCCCCCCCCCDLL * ((v23 - (_BYTE *)*a4) >> 2);
                  if (2 * v29 > v28) {
                    unint64_t v28 = 2 * v29;
                  }
                  if (v29 >= 0x666666666666666LL) {
                    unint64_t v30 = 0xCCCCCCCCCCCCCCCLL;
                  }
                  else {
                    unint64_t v30 = v28;
                  }
                  if (v30) {
                    char v31 = (char *)sub_100050420((uint64_t)(a4 + 2), v30);
                  }
                  else {
                    char v31 = 0LL;
                  }
                  __int128 v32 = &v31[20 * v27];
                  __int128 v33 = *(_OWORD *)v17;
                  *((_DWORD *)v32 + 4) = v17[4];
                  *(_OWORD *)__int128 v32 = v33;
                  char v35 = (char *)*a4;
                  unint64_t v34 = (char *)a4[1];
                  int v36 = v32;
                  if (v34 != *a4)
                  {
                    do
                    {
                      __int128 v37 = *(_OWORD *)(v34 - 20);
                      *((_DWORD *)v36 - 1) = *((_DWORD *)v34 - 1);
                      *(_OWORD *)(v36 - 20) = v37;
                      v36 -= 20;
                      v34 -= 20;
                    }

                    while (v34 != v35);
                    unint64_t v34 = (char *)*a4;
                  }

                  uint64_t v26 = v32 + 20;
                  *a4 = v36;
                  a4[1] = v32 + 20;
                  a4[2] = &v31[20 * v30];
                  if (v34) {
                    operator delete(v34);
                  }
                }

                else
                {
                  __int128 v25 = *(_OWORD *)v17;
                  *((_DWORD *)v24 + 4) = v17[4];
                  *(_OWORD *)unsigned __int8 v24 = v25;
                  uint64_t v26 = v24 + 20;
                }

                a4[1] = v26;
                char v18 = 1;
              }

              v17 += 5;
            }

            while (v17 != v16);
            __int128 v17 = *(_DWORD **)v60;
          }

          if (v17)
          {
            unint64_t v61 = v17;
            operator delete(v17);
          }

          v12 += 17;
          goto LABEL_61;
        }

        int v41 = 0;
        char v18 = 0;
        LODWORD(v3_Block_object_dispose(va, 8) = v12 + 1;
        int v39 = 16;
      }

      else
      {
        unint64_t v38 = v12 + 1;
        if (v38 >= a3)
        {
          uint64_t v46 = qword_1008F75B8;
          char v18 = 0;
          if (!os_log_type_enabled((os_log_t)qword_1008F75B8, OS_LOG_TYPE_DEFAULT)) {
            goto LABEL_75;
          }
          *(_WORD *)size_t v60 = 0;
          BOOL v47 = "Invalid length, not enough room for the len field.";
LABEL_72:
          id v49 = (os_log_s *)v46;
          uint32_t v50 = 2;
LABEL_73:
          _os_log_impl((void *)&_mh_execute_header, v49, OS_LOG_TYPE_DEFAULT, v47, v60, v50);
          break;
        }

        int v39 = *(_BYTE *)(a2 + v38) & 0x1F;
        if (v39 == 31)
        {
          unint64_t v40 = v12 + 2;
          if (v40 >= a3)
          {
            uint64_t v46 = qword_1008F75B8;
            char v18 = 0;
            if (!os_log_type_enabled((os_log_t)qword_1008F75B8, OS_LOG_TYPE_DEFAULT)) {
              goto LABEL_75;
            }
            *(_WORD *)size_t v60 = 0;
            BOOL v47 = "Not enough data for the extended data byte. Ignoring.";
            goto LABEL_72;
          }

          int v39 = *(unsigned __int8 *)(a2 + v40) + 31;
          int v41 = 2;
        }

        else
        {
          int v41 = 1;
        }

        if (v39 + v12 + v41 > a3)
        {
          uint64_t v48 = qword_1008F75B8;
          char v18 = 0;
          if (!os_log_type_enabled((os_log_t)qword_1008F75B8, OS_LOG_TYPE_DEFAULT)) {
            goto LABEL_75;
          }
          *(_DWORD *)size_t v60 = 67109888;
          *(_DWORD *)&v60[4] = v12;
          LOWORD(v61) = 1024;
          *(_DWORD *)((char *)&v61 + 2) = v39;
          HIWORD(v61) = 1024;
          LODWORD(v62[0]) = v41;
          WORD2(v62[0]) = 2048;
          *(void *)((char *)v62 + 6) = a3;
          BOOL v47 = "Ignoring packet since byte offset of %d + payload length of %d + length size of %d doesnt fit in dataLength %zu";
          id v49 = (os_log_s *)v48;
          uint32_t v50 = 30;
          goto LABEL_73;
        }

        id v42 = *(int8x8_t **)(a1 + 8);
        buf[0] = 1;
        v60[0] = 0;
        uint64_t v43 = sub_10060ECA8(v42 + 26, 0, (uint64_t)&v42[30], 0, buf);
        uint64_t v44 = *(void *)(a1 + 8);
        if (v43 && ((*(void *)(v44 + ((v14 >> 3) & 0x18) + 208) >> v14) & 1) != 0)
        {
          uint64_t v45 = (os_log_s *)qword_1008F75B8;
          if (os_log_type_enabled((os_log_t)qword_1008F75B8, OS_LOG_TYPE_DEBUG))
          {
            *(_DWORD *)size_t v60 = 67109120;
            *(_DWORD *)&v60[4] = v14;
            _os_log_debug_impl( (void *)&_mh_execute_header,  v45,  OS_LOG_TYPE_DEBUG,  "Show dup for given rule with puck type 0x%x",  v60,  8u);
            uint64_t v44 = *(void *)(a1 + 8);
          }

          *a5 = 1;
        }

        if ((_DWORD)v14 != 2) {
          goto LABEL_57;
        }
        if (![*(id *)(v44 + 88) count])
        {
          uint64_t v44 = *(void *)(a1 + 8);
LABEL_57:
          if (*(void *)(v44 + 64) != *(void *)(v44 + 72)
            && ((*(void *)(v44 + ((v14 >> 3) & 0x18) + 240) >> v14) & 1) != 0)
          {
            sub_1006153B4(v44, v14);
            char v18 = 1;
            goto LABEL_75;
          }

          char v18 = 0;
          goto LABEL_60;
        }

        char v18 = 1;
      }

void sub_1006152F0( _Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20, void *__p, uint64_t a22)
{
  if (__p) {
    operator delete(__p);
  }
  _Unwind_Resume(exception_object);
}

__n128 sub_10061531C(uint64_t a1, __n128 *a2)
{
  unint64_t v4 = *(void *)(a1 + 32);
  if (!v4)
  {
    sub_100618B94((void **)a1);
    unint64_t v4 = *(void *)(a1 + 32);
  }

  uint64_t v5 = *(void *)(a1 + 8);
  __int128 v6 = (void *)(v5 + 8 * (v4 / 0xAA));
  uint64_t v7 = *v6 + 24 * (v4 % 0xAA);
  if (*(void *)(a1 + 16) == v5) {
    uint64_t v7 = 0LL;
  }
  if (v7 == *v6) {
    uint64_t v7 = *(v6 - 1) + 4080LL;
  }
  __n128 result = *a2;
  *(__n128 *)(v7 - 24) = *a2;
  *(_BYTE *)(v7 - _Block_object_dispose(va, 8) = a2[1].n128_u8[0];
  uint64_t v9 = *(void *)(a1 + 40) + 1LL;
  *(void *)(a1 + 32) = v4 - 1;
  *(void *)(a1 + 40) = v9;
  return result;
}

void sub_1006153B4(uint64_t a1, int a2)
{
  uint64_t v2 = *(void *)(a1 + 64);
  uint64_t v3 = *(void *)(a1 + 72);
  if (v2 != v3)
  {
    uint64_t v5 = (id *)(a1 + 160);
    do
    {
      v2 += 96LL;
    }

    while (v2 != v3);
  }

void sub_10061540C(uint64_t a1)
{
  if ([*(id *)(*(void *)(a1 + 8) + 88) count])
  {
    __int128 v18 = 0u;
    __int128 v19 = 0u;
    __int128 v16 = 0u;
    __int128 v17 = 0u;
    id v2 = *(id *)(*(void *)(a1 + 8) + 88LL);
    id v3 = [v2 countByEnumeratingWithState:&v16 objects:v22 count:16];
    if (v3)
    {
      uint64_t v4 = *(void *)v17;
      do
      {
        for (uint64_t i = 0LL; i != v3; uint64_t i = (char *)i + 1)
        {
          if (*(void *)v17 != v4) {
            objc_enumerationMutation(v2);
          }
          id v6 = *(id *)(*((void *)&v16 + 1) + 8LL * (void)i);
          id v7 = [v6 bytes];
          id v8 = [v6 length];
          if (v8) {
            BOOL v9 = v7 == 0LL;
          }
          else {
            BOOL v9 = 1;
          }
          if (v9)
          {
            uint64_t v10 = (os_log_s *)qword_1008F75B8;
            if (os_log_type_enabled((os_log_t)qword_1008F75B8, OS_LOG_TYPE_ERROR)) {
              sub_10069E33C(&v14, v15, v10);
            }
          }

          else
          {
            else {
              unsigned __int16 v11 = (unsigned __int16)v8;
            }
            unsigned int v12 = (os_log_s *)qword_1008F75B8;
            if (os_log_type_enabled((os_log_t)qword_1008F75B8, OS_LOG_TYPE_DEFAULT))
            {
              *(_DWORD *)std::stringbuf::string_type buf = 138412290;
              id v21 = v6;
              _os_log_impl((void *)&_mh_execute_header, v12, OS_LOG_TYPE_DEFAULT, "Adding zone %@", buf, 0xCu);
            }

            uint64_t v13 = sub_1002E6E9C();
            if ((*(unsigned int (**)(uint64_t, id, void, uint64_t))(*(void *)v13 + 600LL))( v13,  v7,  v11,  240LL))
            {
              goto LABEL_22;
            }
          }
        }

        id v3 = [v2 countByEnumeratingWithState:&v16 objects:v22 count:16];
      }

      while (v3);
    }

void sub_1006155F0(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

uint64_t sub_100615618(const unsigned __int8 **a1, unsigned int a2)
{
  uint64_t v27 = 0LL;
  __int128 v25 = 0u;
  memset(v26, 0, sizeof(v26));
  *(_OWORD *)int v23 = 0u;
  __int128 v24 = 0u;
  memset(v22, 0, sizeof(v22));
  sub_1001FCFC8((uint64_t)v22);
  id v3 = (os_log_s *)qword_1008F75B8;
  if (os_log_type_enabled((os_log_t)qword_1008F75B8, OS_LOG_TYPE_DEFAULT))
  {
    uint64_t v4 = a1[2];
    *(_DWORD *)std::stringbuf::string_type buf = 134217984;
    *(void *)&uint8_t buf[4] = v4;
    _os_log_impl( (void *)&_mh_execute_header,  v3,  OS_LOG_TYPE_DEFAULT,  "statedump: _printAdvMap %lu items in map",  buf,  0xCu);
  }

  id v7 = *a1;
  uint64_t v5 = a1 + 1;
  id v6 = v7;
  if (v7 != (const unsigned __int8 *)v5)
  {
    do
    {
      id v8 = (os_log_s *)qword_1008F75B8;
      if (os_log_type_enabled((os_log_t)qword_1008F75B8, OS_LOG_TYPE_DEFAULT))
      {
        memset(buf, 0, sizeof(buf));
        uuid_unparse_upper(v6 + 32, buf);
        sub_10002418C(__p, buf);
        int v9 = v21;
        uint64_t v10 = (void **)__p[0];
        sub_10056C434(*((void *)v6 + 7), (std::stringbuf::string_type *)buf);
        unsigned __int16 v11 = __p;
        if (v9 < 0) {
          unsigned __int16 v11 = v10;
        }
        unsigned int v12 = buf;
        if (buf[23] < 0) {
          unsigned int v12 = *(_BYTE **)buf;
        }
        BOOL v13 = (*(void *)(*((void *)v6 + 7) + 8 * ((unint64_t)a2 >> 6) + 168) & (1LL << a2)) != 0;
        *(_DWORD *)unint64_t v28 = 136315906;
        unint64_t v29 = v11;
        __int16 v30 = 2080;
        char v31 = v12;
        __int16 v32 = 1024;
        unsigned int v33 = a2;
        __int16 v34 = 1024;
        BOOL v35 = v13;
        _os_log_impl( (void *)&_mh_execute_header,  v8,  OS_LOG_TYPE_DEFAULT,  "statedump:    %s:%s hasType(%d):%d",  v28,  0x22u);
        if ((buf[23] & 0x80000000) != 0) {
          operator delete(*(void **)buf);
        }
        if (v21 < 0) {
          operator delete(__p[0]);
        }
      }

      uint8_t v14 = (unsigned __int8 *)*((void *)v6 + 1);
      if (v14)
      {
        do
        {
          uint64_t v15 = (const unsigned __int8 **)v14;
          uint8_t v14 = *(unsigned __int8 **)v14;
        }

        while (v14);
      }

      else
      {
        do
        {
          uint64_t v15 = (const unsigned __int8 **)*((void *)v6 + 2);
          BOOL v16 = *v15 == v6;
          id v6 = (const unsigned __int8 *)v15;
        }

        while (!v16);
      }

      id v6 = (const unsigned __int8 *)v15;
    }

    while (v15 != v5);
  }

  *(void *)((char *)v22
  *(void *)&v22[1] = v17;
  if (SHIBYTE(v24) < 0) {
    operator delete(v23[1]);
  }
  std::streambuf::~streambuf((char *)&v22[1] + 8);
  return std::ios::~ios(v26);
}

void sub_1006158D4( _Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, void *__p, uint64_t a13, int a14, __int16 a15, char a16, char a17, char a18)
{
}

void sub_100615908(uint64_t a1, unsigned int a2)
{
  if (qword_1008F1F18 != -1) {
    dispatch_once(&qword_1008F1F18, &stru_1008A4290);
  }
  __int128 v22 = 0LL;
  v23[0] = 0LL;
  v23[1] = 0LL;
  sub_100618F20((uint64_t *)&v22, a1 + 104);
  id v3 = v22;
  if (v22 != (const unsigned __int8 *)v23)
  {
    do
    {
      uint64_t v4 = (unsigned __int8 *)*((void *)v3 + 1);
      if (v4)
      {
        do
        {
          uint64_t v5 = (const unsigned __int8 **)v4;
          uint64_t v4 = *(unsigned __int8 **)v4;
        }

        while (v4);
      }

      else
      {
        do
        {
          uint64_t v5 = (const unsigned __int8 **)*((void *)v3 + 2);
          BOOL v6 = *v5 == v3;
          id v3 = (const unsigned __int8 *)v5;
        }

        while (!v6);
      }

      id v3 = (const unsigned __int8 *)v5;
    }

    while (v5 != (const unsigned __int8 **)v23);
  }

  if (byte_1008F1F10)
  {
    id v7 = (os_log_s *)qword_1008F75B8;
    if (os_log_type_enabled((os_log_t)qword_1008F75B8, OS_LOG_TYPE_DEFAULT))
    {
      LOWORD(buf[0].__r_.__value_.__l.__data_) = 0;
      _os_log_impl( (void *)&_mh_execute_header,  v7,  OS_LOG_TYPE_DEFAULT,  "statedump: clearAdvDataCacheForAppleType before removal",  (uint8_t *)buf,  2u);
    }

    sub_100615618(&v22, a2);
    id v8 = (os_log_s *)qword_1008F75B8;
    if (os_log_type_enabled((os_log_t)qword_1008F75B8, OS_LOG_TYPE_DEFAULT))
    {
      LOWORD(buf[0].__r_.__value_.__l.__data_) = 0;
      _os_log_impl( (void *)&_mh_execute_header,  v8,  OS_LOG_TYPE_DEFAULT,  "statedump: clearAdvDataCacheForAppleType after removal",  (uint8_t *)buf,  2u);
    }

    sub_100615618((const unsigned __int8 **)(a1 + 104), a2);
    int v9 = (os_log_s *)qword_1008F75B8;
    if (os_log_type_enabled((os_log_t)qword_1008F75B8, OS_LOG_TYPE_DEFAULT))
    {
      LODWORD(buf[0].__r_.__value_.__l.__data_) = 67109120;
      HIDWORD(buf[0].__r_.__value_.__r.__words[0]) = a2;
      _os_log_impl( (void *)&_mh_execute_header,  v9,  OS_LOG_TYPE_DEFAULT,  "statedump: clearAdvDataCacheForAppleType removed items with type %d",  (uint8_t *)buf,  8u);
    }

    uint64_t v10 = v22;
    if (v22 != (const unsigned __int8 *)v23)
    {
      do
      {
        if (a1 + 112 == sub_1001FDB10(a1 + 104, (unsigned __int8 *)v10 + 32))
        {
          unsigned __int16 v11 = (os_log_s *)qword_1008F75B8;
          if (os_log_type_enabled((os_log_t)qword_1008F75B8, OS_LOG_TYPE_DEFAULT))
          {
            memset(buf, 0, 37);
            uuid_unparse_upper(v10 + 32, (char *)buf);
            sub_10002418C(__p, (char *)buf);
            int v12 = v21;
            BOOL v13 = (void **)__p[0];
            sub_10056C434(*((void *)v10 + 7), buf);
            uint8_t v14 = __p;
            if (v12 < 0) {
              uint8_t v14 = v13;
            }
            uint64_t v15 = buf;
            if ((buf[0].__r_.__value_.__s.__size_ & 0x80u) != 0) {
              uint64_t v15 = (std::stringbuf::string_type *)buf[0].__r_.__value_.__r.__words[0];
            }
            BOOL v16 = (*(void *)(*((void *)v10 + 7) + 8 * ((unint64_t)a2 >> 6) + 168) & (1LL << a2)) != 0;
            *(_DWORD *)__int128 v24 = 136315906;
            __int128 v25 = v14;
            __int16 v26 = 2080;
            uint64_t v27 = v15;
            __int16 v28 = 1024;
            unsigned int v29 = a2;
            __int16 v30 = 1024;
            BOOL v31 = v16;
            _os_log_impl( (void *)&_mh_execute_header,  v11,  OS_LOG_TYPE_DEFAULT,  "statedump:    %s:%s hasType(%d):%d",  v24,  0x22u);
            if (v21 < 0) {
              operator delete(__p[0]);
            }
          }
        }

        uint64_t v17 = (unsigned __int8 *)*((void *)v10 + 1);
        if (v17)
        {
          do
          {
            __int128 v18 = (const unsigned __int8 **)v17;
            uint64_t v17 = *(unsigned __int8 **)v17;
          }

          while (v17);
        }

        else
        {
          do
          {
            __int128 v18 = (const unsigned __int8 **)*((void *)v10 + 2);
            BOOL v6 = *v18 == v10;
            uint64_t v10 = (const unsigned __int8 *)v18;
          }

          while (!v6);
        }

        uint64_t v10 = (const unsigned __int8 *)v18;
      }

      while (v18 != (const unsigned __int8 **)v23);
    }
  }

  sub_10061068C((uint64_t)&v22, v23[0]);
}

void sub_100615CAC( _Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, void *__p, uint64_t a14, int a15, __int16 a16, char a17, char a18, char a19, uint64_t a20)
{
}

void sub_100615CF0(id a1)
{
  uint64_t v1 = sub_1002E6E00();
  sub_10002418C(v4, "LE");
  sub_10002418C(__p, "LeScanAgentDebugClearAdvDataCache");
  (*(void (**)(uint64_t, void **, void **, char *))(*(void *)v1 + 72LL))(v1, v4, __p, &byte_1008F1F10);
  if (v3 < 0) {
    operator delete(__p[0]);
  }
  if (v5 < 0) {
    operator delete(v4[0]);
  }
}

void sub_100615D78( _Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, void *__p, uint64_t a10, int a11, __int16 a12, char a13, char a14, void *a15, uint64_t a16, int a17, __int16 a18, char a19, char a20)
{
  if (a14 < 0) {
    operator delete(__p);
  }
  if (a20 < 0) {
    operator delete(a15);
  }
  _Unwind_Resume(exception_object);
}

void sub_100615DAC(uint64_t a1)
{
  id v2 = (os_log_s *)qword_1008F75B8;
  if (os_log_type_enabled((os_log_t)qword_1008F75B8, OS_LOG_TYPE_DEFAULT))
  {
    if (*(_BYTE *)(a1 + 80)) {
      char v3 = "YES";
    }
    else {
      char v3 = "NO";
    }
    int v4 = *(unsigned __int8 *)(a1 + 81);
    if (*(_BYTE *)(a1 + 83)) {
      char v5 = "YES";
    }
    else {
      char v5 = "NO";
    }
    *(_DWORD *)std::stringbuf::string_type buf = 136446722;
    *(void *)&uint8_t buf[4] = v3;
    *(_WORD *)&_BYTE buf[12] = 1024;
    *(_DWORD *)&buf[14] = v4;
    *(_WORD *)&_BYTE buf[18] = 2082;
    *(void *)&_BYTE buf[20] = v5;
    _os_log_impl( (void *)&_mh_execute_header,  v2,  OS_LOG_TYPE_DEFAULT,  "statedump: \t\tfSupportsBackgrounding:%{public}s fSessionState:%d, fhasEntitlementBTCentralBackground:%{public}s",  buf,  0x1Cu);
    id v2 = (os_log_s *)qword_1008F75B8;
  }

  if (os_log_type_enabled(v2, OS_LOG_TYPE_DEFAULT))
  {
    if (*(void *)(a1 + 88)) {
      BOOL v6 = "YES";
    }
    else {
      BOOL v6 = "NO";
    }
    int v7 = *(_DWORD *)(a1 + 96);
    *(_DWORD *)std::stringbuf::string_type buf = 136446466;
    *(void *)&uint8_t buf[4] = v6;
    *(_WORD *)&_BYTE buf[12] = 1024;
    *(_DWORD *)&buf[14] = v7;
    _os_log_impl( (void *)&_mh_execute_header,  v2,  OS_LOG_TYPE_DEFAULT,  "statedump: \t\thasDecayTimer:%{public}s fCurrentScanLevel:%d",  buf,  0x12u);
    id v2 = (os_log_s *)qword_1008F75B8;
  }

  if (os_log_type_enabled(v2, OS_LOG_TYPE_DEFAULT))
  {
    uint64_t v8 = *(void *)(a1 + 120);
    uint64_t v9 = *(void *)(a1 + 144);
    int v10 = *(unsigned __int16 *)(a1 + 176);
    *(_DWORD *)std::stringbuf::string_type buf = 134218496;
    *(void *)&uint8_t buf[4] = v8;
    *(_WORD *)&_BYTE buf[12] = 2048;
    *(void *)&buf[14] = v9;
    *(_WORD *)&_BYTE buf[22] = 1024;
    *(_DWORD *)&_BYTE buf[24] = v10;
    _os_log_impl( (void *)&_mh_execute_header,  v2,  OS_LOG_TYPE_DEFAULT,  "statedump: \t\tfAdvDataMap.size:%lu fAdvLRUList.size:%lu fMaxNumOfReportsInMap:%d",  buf,  0x1Cu);
    id v2 = (os_log_s *)qword_1008F75B8;
  }

  if (os_log_type_enabled(v2, OS_LOG_TYPE_DEFAULT))
  {
    int v11 = *(_DWORD *)(a1 + 208);
    *(_DWORD *)std::stringbuf::string_type buf = 67109120;
    *(_DWORD *)&uint8_t buf[4] = v11;
    _os_log_impl((void *)&_mh_execute_header, v2, OS_LOG_TYPE_DEFAULT, "statedump: \t\tfScanAgentType:%d", buf, 8u);
  }

  if (*(_BYTE *)(a1 + 178))
  {
    __int128 v37 = 0LL;
    unint64_t v38 = 0LL;
    uint64_t v39 = 0LL;
    sub_100618F20((uint64_t *)&v37, a1 + 104);
    uint64_t v34 = 0LL;
    uint64_t v35 = 0LL;
    uint64_t v36 = 0LL;
    sub_100619150(&v34, a1 + 128);
    BOOL v31 = 0LL;
    __int16 v32 = 0LL;
    uint64_t v33 = 0LL;
    sub_1006191E0((uint64_t *)&v31, a1 + 152);
    int v12 = (os_log_s *)qword_1008F75B8;
    if (os_log_type_enabled((os_log_t)qword_1008F75B8, OS_LOG_TYPE_DEFAULT))
    {
      *(_DWORD *)std::stringbuf::string_type buf = 134217984;
      *(void *)&uint8_t buf[4] = v36;
      _os_log_impl( (void *)&_mh_execute_header,  v12,  OS_LOG_TYPE_DEFAULT,  "statedump: \t\t--- fAdvLRUList (size:%lu) ---------",  buf,  0xCu);
    }

    for (uint64_t i = v35; (uint64_t *)i != &v34; uint64_t i = *(void *)(i + 8))
    {
      uint8_t v14 = (os_log_s *)qword_1008F75B8;
      if (os_log_type_enabled((os_log_t)qword_1008F75B8, OS_LOG_TYPE_DEFAULT))
      {
        memset(buf, 0, 37);
        uuid_unparse_upper((const unsigned __int8 *)(i + 16), (char *)buf);
        sub_10002418C(__p, (char *)buf);
        uint64_t v15 = v30 >= 0 ? __p : (void **)__p[0];
        *(_DWORD *)unint64_t v40 = 136446210;
        int v41 = v15;
        _os_log_impl((void *)&_mh_execute_header, v14, OS_LOG_TYPE_DEFAULT, "statedump: \t\t %{public}s", v40, 0xCu);
        if (v30 < 0) {
          operator delete(__p[0]);
        }
      }
    }

    BOOL v16 = (os_log_s *)qword_1008F75B8;
    if (os_log_type_enabled((os_log_t)qword_1008F75B8, OS_LOG_TYPE_DEFAULT))
    {
      *(_DWORD *)std::stringbuf::string_type buf = 134217984;
      *(void *)&uint8_t buf[4] = v33;
      _os_log_impl( (void *)&_mh_execute_header,  v16,  OS_LOG_TYPE_DEFAULT,  "statedump: \t\t--- fAdvLRUListMap (size:%lu) ---------",  buf,  0xCu);
    }

    uint64_t v17 = v31;
    if (v31 != (const unsigned __int8 *)&v32)
    {
      do
      {
        __int128 v18 = (os_log_s *)qword_1008F75B8;
        if (os_log_type_enabled((os_log_t)qword_1008F75B8, OS_LOG_TYPE_DEFAULT))
        {
          memset(buf, 0, 37);
          uuid_unparse_upper(v17 + 32, (char *)buf);
          sub_10002418C(__p, (char *)buf);
          __int128 v19 = v30 >= 0 ? __p : (void **)__p[0];
          *(_DWORD *)unint64_t v40 = 136446210;
          int v41 = v19;
          _os_log_impl((void *)&_mh_execute_header, v18, OS_LOG_TYPE_DEFAULT, "statedump: \t\t %{public}s", v40, 0xCu);
          if (v30 < 0) {
            operator delete(__p[0]);
          }
        }

        int v20 = (unsigned __int8 *)*((void *)v17 + 1);
        if (v20)
        {
          do
          {
            char v21 = (const unsigned __int8 **)v20;
            int v20 = *(unsigned __int8 **)v20;
          }

          while (v20);
        }

        else
        {
          do
          {
            char v21 = (const unsigned __int8 **)*((void *)v17 + 2);
            BOOL v22 = *v21 == v17;
            uint64_t v17 = (const unsigned __int8 *)v21;
          }

          while (!v22);
        }

        uint64_t v17 = (const unsigned __int8 *)v21;
      }

      while (v21 != (const unsigned __int8 **)&v32);
    }

    int v23 = (os_log_s *)qword_1008F75B8;
    if (os_log_type_enabled((os_log_t)qword_1008F75B8, OS_LOG_TYPE_DEFAULT))
    {
      *(_DWORD *)std::stringbuf::string_type buf = 134217984;
      *(void *)&uint8_t buf[4] = v39;
      _os_log_impl( (void *)&_mh_execute_header,  v23,  OS_LOG_TYPE_DEFAULT,  "statedump: \t\t--- fAdvDataMap (size:%lu) ---------",  buf,  0xCu);
    }

    __int128 v24 = v37;
    if (v37 != (const unsigned __int8 *)&v38)
    {
      do
      {
        __int128 v25 = (os_log_s *)qword_1008F75B8;
        if (os_log_type_enabled((os_log_t)qword_1008F75B8, OS_LOG_TYPE_DEFAULT))
        {
          memset(buf, 0, 37);
          uuid_unparse_upper(v24 + 32, (char *)buf);
          sub_10002418C(__p, (char *)buf);
          __int16 v26 = v30 >= 0 ? __p : (void **)__p[0];
          *(_DWORD *)unint64_t v40 = 136446210;
          int v41 = v26;
          _os_log_impl((void *)&_mh_execute_header, v25, OS_LOG_TYPE_DEFAULT, "statedump: \t\t %{public}s", v40, 0xCu);
          if (v30 < 0) {
            operator delete(__p[0]);
          }
        }

        uint64_t v27 = (unsigned __int8 *)*((void *)v24 + 1);
        if (v27)
        {
          do
          {
            __int16 v28 = (const unsigned __int8 **)v27;
            uint64_t v27 = *(unsigned __int8 **)v27;
          }

          while (v27);
        }

        else
        {
          do
          {
            __int16 v28 = (const unsigned __int8 **)*((void *)v24 + 2);
            BOOL v22 = *v28 == v24;
            __int128 v24 = (const unsigned __int8 *)v28;
          }

          while (!v22);
        }

        __int128 v24 = (const unsigned __int8 *)v28;
      }

      while (v28 != (const unsigned __int8 **)&v38);
    }

    sub_10023BF24((uint64_t)&v31, v32);
    sub_10023DF50(&v34);
    sub_10061068C((uint64_t)&v37, v38);
  }

void sub_1006163AC( _Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, char a20, void *a21)
{
}

id sub_1006163F8(uint64_t a1)
{
  id v2 = (void *)objc_claimAutoreleasedReturnValue(+[NSMutableArray array](&OBJC_CLASS___NSMutableArray, "array"));
  if ([*(id *)(*(void *)(a1 + 8) + 88) count])
  {
    __int128 v18 = 0u;
    __int128 v19 = 0u;
    __int128 v16 = 0u;
    __int128 v17 = 0u;
    id v3 = *(id *)(*(void *)(a1 + 8) + 88LL);
    id v4 = [v3 countByEnumeratingWithState:&v16 objects:v20 count:16];
    if (v4)
    {
      uint64_t v5 = *(void *)v17;
      do
      {
        for (uint64_t i = 0LL; i != v4; uint64_t i = (char *)i + 1)
        {
          if (*(void *)v17 != v5) {
            objc_enumerationMutation(v3);
          }
          id v7 = *(id *)(*((void *)&v16 + 1) + 8LL * (void)i);
          id v8 = [v7 bytes];
          if ([v7 length]) {
            BOOL v9 = v8 == 0LL;
          }
          else {
            BOOL v9 = 1;
          }
          if (v9)
          {
            int v10 = (os_log_s *)qword_1008F75B8;
            if (os_log_type_enabled((os_log_t)qword_1008F75B8, OS_LOG_TYPE_ERROR)) {
              sub_10069E33C(&v14, v15, v10);
            }
          }

          else if ((unint64_t)[v7 length] < 0x16)
          {
            [v2 addObject:v7];
          }

          else
          {
            int v11 = (void *)objc_claimAutoreleasedReturnValue( +[NSData dataWithBytes:length:]( NSData, "dataWithBytes:length:", [v7 bytes], 21));
            [v2 addObject:v11];
          }
        }

        id v4 = [v3 countByEnumeratingWithState:&v16 objects:v20 count:16];
      }

      while (v4);
    }

    id v12 = v2;
  }

  else
  {
    id v12 = 0LL;
  }

  return v12;
}

void sub_1006165E8(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

id sub_100616628(uint64_t a1, int a2, _DWORD *a3)
{
  uint64_t v4 = objc_claimAutoreleasedReturnValue(+[NSMutableArray array](&OBJC_CLASS___NSMutableArray, "array"));
  uint64_t v5 = *(void *)(a1 + 8);
  uint64_t v7 = *(void *)(v5 + 64);
  uint64_t v6 = *(void *)(v5 + 72);
  id v39 = (id)v4;
  uint64_t v40 = v6;
  while (v7 != v6)
  {
    uint64_t v8 = *(unsigned __int8 *)(v7 + 48);
    unsigned int v44 = *(unsigned __int8 *)(v7 + 8);
    int v9 = *(unsigned __int8 *)(v7 + 49);
    uint64_t v10 = *(unsigned __int8 *)(v7 + 50);
    uint64_t v11 = *(unsigned __int8 *)(v7 + 51);
    uint64_t v12 = *(unsigned __int8 *)(v7 + 52);
    id v13 = *(id *)(v7 + 56);
    if (*(_BYTE *)(v7 + 68))
    {
      int v41 = v9;
      int v14 = *(unsigned __int8 *)(v7 + 65);
      id v43 = v13;
      id v15 = [v13 count];
      int v42 = v14;
      int v16 = a2;
      if (!v15) {
        int v16 = 1;
      }
      if (v16) {
        unsigned __int8 v17 = 2;
      }
      else {
        unsigned __int8 v17 = 3;
      }
      __int128 v18 = (void *)objc_claimAutoreleasedReturnValue(+[NSMutableDictionary dictionary](&OBJC_CLASS___NSMutableDictionary, "dictionary"));
      uint64_t v19 = sub_10056AAF0(v7 + 16);
      int v20 = +[NSData dataWithBytes:length:](&OBJC_CLASS___NSData, "dataWithBytes:length:", v19, sub_10056AAD8(v7 + 16));
      char v21 = (void *)objc_claimAutoreleasedReturnValue(v20);
      [v18 setObject:v21 forKeyedSubscript:@"data"];

      uint64_t v22 = sub_10056AAF0(v7 + 32);
      int v23 = +[NSData dataWithBytes:length:](&OBJC_CLASS___NSData, "dataWithBytes:length:", v22, sub_10056AAD8(v7 + 32));
      __int128 v24 = (void *)objc_claimAutoreleasedReturnValue(v23);
      [v18 setObject:v24 forKeyedSubscript:@"mask"];

      __int128 v25 = (void *)objc_claimAutoreleasedReturnValue(+[NSNumber numberWithChar:](&OBJC_CLASS___NSNumber, "numberWithChar:", v8));
      [v18 setObject:v25 forKeyedSubscript:@"rssi"];

      __int16 v26 = (void *)objc_claimAutoreleasedReturnValue(+[NSNumber numberWithUnsignedChar:](&OBJC_CLASS___NSNumber, "numberWithUnsignedChar:", v44));
      [v18 setObject:v26 forKeyedSubscript:@"puckType"];

      uint64_t v27 = (void *)objc_claimAutoreleasedReturnValue(+[NSNumber numberWithUnsignedChar:](&OBJC_CLASS___NSNumber, "numberWithUnsignedChar:", v17));
      [v18 setObject:v27 forKeyedSubscript:@"matchAllDevices"];

      __int16 v28 = (void *)objc_claimAutoreleasedReturnValue( +[NSNumber numberWithUnsignedLongLong:]( &OBJC_CLASS___NSNumber,  "numberWithUnsignedLongLong:",  0LL));
      [v18 setObject:v28 forKeyedSubscript:@"address"];

      unsigned int v29 = (void *)objc_claimAutoreleasedReturnValue(+[NSNumber numberWithUnsignedChar:](&OBJC_CLASS___NSNumber, "numberWithUnsignedChar:", v10));
      [v18 setObject:v29 forKeyedSubscript:@"bypassFilterDuplicate"];

      char v30 = (void *)objc_claimAutoreleasedReturnValue(+[NSNumber numberWithUnsignedChar:](&OBJC_CLASS___NSNumber, "numberWithUnsignedChar:", v11));
      [v18 setObject:v30 forKeyedSubscript:@"targetCore"];

      BOOL v31 = (void *)objc_claimAutoreleasedReturnValue(+[NSNumber numberWithUnsignedChar:](&OBJC_CLASS___NSNumber, "numberWithUnsignedChar:", v12));
      [v18 setObject:v31 forKeyedSubscript:@"rssithresholdOrder"];

      __int16 v32 = (void *)objc_claimAutoreleasedReturnValue(+[NSNumber numberWithBool:](&OBJC_CLASS___NSNumber, "numberWithBool:", v42 != 0));
      [v18 setObject:v32 forKeyedSubscript:@"shouldConsolidateRule"];

      uint64_t v33 = (void *)objc_claimAutoreleasedReturnValue( +[NSNumber numberWithBool:]( &OBJC_CLASS___NSNumber,  "numberWithBool:",  *(unsigned __int8 *)(v7 + 66)));
      [v18 setObject:v33 forKeyedSubscript:@"report127dBm"];

      uint64_t v34 = (void *)objc_claimAutoreleasedReturnValue( +[NSNumber numberWithBool:]( &OBJC_CLASS___NSNumber,  "numberWithBool:",  *(unsigned __int8 *)(v7 + 67)));
      [v18 setObject:v34 forKeyedSubscript:@"report27dBm"];

      [v39 addObject:v18];
      int v35 = 1 << v44;
      if (!v41) {
        int v35 = 0;
      }
      *a3 |= v35;

      id v13 = v43;
    }

    v7 += 96LL;
    uint64_t v6 = v40;
  }

  return v39;
}

void sub_1006169E0( _Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, void *a12, uint64_t a13, uint64_t a14, void *a15)
{
  _Unwind_Resume(a1);
}

uint64_t sub_100616A44(uint64_t a1)
{
  uint64_t result = sub_1000B068C();
  uint64_t v3 = result - *(void *)(a1 + 216);
  *(void *)(a1 + 216) = result;
  *(void *)(a1 + 56) += v3;
  unsigned int v4 = *(unsigned __int8 *)(a1 + 81);
  if (v4 <= 0x20)
  {
    if (((1LL << v4) & 0x100010002LL) != 0)
    {
      uint64_t v5 = (void *)(a1 + 48);
    }

    else
    {
      if (((1LL << v4) & 0x110) == 0) {
        return result;
      }
      uint64_t v5 = (void *)(a1 + 40);
    }

    *v5 += v3;
  }

  return result;
}

id sub_100616AD0(uint64_t a1)
{
  *(_BYTE *)(a1 + 65) = *(_BYTE *)(a1 + 81) == 16;
  id v2 = *(const unsigned __int8 **)(a1 + 104);
  if (v2 != (const unsigned __int8 *)(a1 + 112))
  {
    do
    {
      if (qword_1008D5F20 != -1) {
        dispatch_once(&qword_1008D5F20, &stru_1008A42B0);
      }
      uint64_t v3 = qword_1008D5F18;
      unsigned int v4 = sub_100241F94(v2 + 32);
      uint64_t v5 = (void *)objc_claimAutoreleasedReturnValue(v4);
      LODWORD(v3) = sub_10061C0F8(v3, v5);

      if ((_DWORD)v3) {
        ++*(void *)(a1 + 72);
      }
      uint64_t v6 = (unsigned __int8 *)*((void *)v2 + 1);
      if (v6)
      {
        do
        {
          uint64_t v7 = (const unsigned __int8 **)v6;
          uint64_t v6 = *(unsigned __int8 **)v6;
        }

        while (v6);
      }

      else
      {
        do
        {
          uint64_t v7 = (const unsigned __int8 **)*((void *)v2 + 2);
          BOOL v8 = *v7 == v2;
          id v2 = (const unsigned __int8 *)v7;
        }

        while (!v8);
      }

      id v2 = (const unsigned __int8 *)v7;
    }

    while (v7 != (const unsigned __int8 **)(a1 + 112));
  }

  id v65 = (id)objc_claimAutoreleasedReturnValue(+[NSMutableDictionary dictionary](&OBJC_CLASS___NSMutableDictionary, "dictionary"));
  int v66 = (void *)objc_claimAutoreleasedReturnValue(+[NSMutableString string](&OBJC_CLASS___NSMutableString, "string"));
  uint64_t v9 = *(void *)(a1 + 8);
  char v74 = 0LL;
  uint64_t v75 = 0LL;
  uint64_t v73 = 0LL;
  sub_100050EE8( (char *)&v73,  *(__int128 **)(v9 + 8),  *(__int128 **)(v9 + 16),  0xCCCCCCCCCCCCCCCDLL * ((uint64_t)(*(void *)(v9 + 16) - *(void *)(v9 + 8)) >> 2));
  uint64_t v11 = (unsigned __int8 *)v73;
  uint64_t v10 = v74;
  if (v73 == v74)
  {
    unsigned __int16 v13 = 0;
    unsigned __int16 v12 = 0;
  }

  else
  {
    unsigned __int16 v12 = 0;
    unsigned __int16 v13 = 0;
    do
    {
      sub_1006344B4((uint64_t)v11, __p);
      if (v72 >= 0) {
        int v14 = __p;
      }
      else {
        int v14 = (void **)__p[0];
      }
      id v15 = (void *)objc_claimAutoreleasedReturnValue(+[NSString stringWithUTF8String:](&OBJC_CLASS___NSString, "stringWithUTF8String:", v14));
      int v16 = (void *)objc_claimAutoreleasedReturnValue(+[NSString stringWithFormat:](&OBJC_CLASS___NSString, "stringWithFormat:", @"%@ ", v15));
      [v66 appendString:v16];

      if (v72 < 0) {
        operator delete(__p[0]);
      }
      int v18 = *v11;
      v11 += 20;
      int v17 = v18;
      if (v18 == 16) {
        ++v13;
      }
      if (v17 == 2) {
        ++v12;
      }
    }

    while (v11 != v10);
  }

  uint64_t v19 = *(void *)(a1 + 8);
  uint64_t v20 = *(void *)(v19 + 64);
  uint64_t v21 = *(void *)(v19 + 72);
  if (v20 == v21)
  {
    unsigned __int16 v22 = 0;
  }

  else
  {
    unsigned __int16 v22 = 0;
    do
    {
      id v23 = *(id *)(v20 + 56);
      unsigned __int16 v24 = (unsigned __int16)[v23 count];

      v22 += v24;
      v20 += 96LL;
    }

    while (v20 != v21);
  }

  [v65 setObject:v66 forKeyedSubscript:@"ServiceUUID"];
  __int128 v25 = (void *)objc_claimAutoreleasedReturnValue(+[NSNumber numberWithUnsignedShort:](&OBJC_CLASS___NSNumber, "numberWithUnsignedShort:", v12));
  [v65 setObject:v25 forKeyedSubscript:@"NumberOf16bitUUID"];

  __int16 v26 = (void *)objc_claimAutoreleasedReturnValue(+[NSNumber numberWithUnsignedShort:](&OBJC_CLASS___NSNumber, "numberWithUnsignedShort:", v13));
  [v65 setObject:v26 forKeyedSubscript:@"NumberOf128bitUUID"];

  uint64_t v27 = (void *)objc_claimAutoreleasedReturnValue( +[NSNumber numberWithUnsignedLong:]( &OBJC_CLASS___NSNumber,  "numberWithUnsignedLong:",  0xAAAAAAAAAAAAAAABLL * ((uint64_t)(*(void *)(*(void *)(a1 + 8) + 72LL) - *(void *)(*(void *)(a1 + 8) + 64LL)) >> 5)));
  [v65 setObject:v27 forKeyedSubscript:@"NumberOfPuckType"];

  __int16 v28 = (void *)objc_claimAutoreleasedReturnValue(+[NSNumber numberWithUnsignedShort:](&OBJC_CLASS___NSNumber, "numberWithUnsignedShort:", v22));
  [v65 setObject:v28 forKeyedSubscript:@"NumberOfPeers"];

  unsigned int v29 = (void *)objc_claimAutoreleasedReturnValue( +[NSNumber numberWithUnsignedChar:]( &OBJC_CLASS___NSNumber,  "numberWithUnsignedChar:",  *(unsigned __int8 *)(*(void *)(a1 + 8) + 122LL)));
  [v65 setObject:v29 forKeyedSubscript:@"ObjectDiscoveryMask"];

  char v30 = (void *)objc_claimAutoreleasedReturnValue( +[NSNumber numberWithBool:]( NSNumber,  "numberWithBool:",  [*(id *)(*(void *)(a1 + 8) + 88) count] != 0));
  [v65 setObject:v30 forKeyedSubscript:@"HasZoneFilter"];

  BOOL v31 = (void *)objc_claimAutoreleasedReturnValue( +[NSNumber numberWithBool:]( &OBJC_CLASS___NSNumber,  "numberWithBool:",  *(unsigned __int8 *)(*(void *)(a1 + 8) + 143LL)));
  [v65 setObject:v31 forKeyedSubscript:@"isContactTracing"];

  __int16 v32 = (void *)objc_claimAutoreleasedReturnValue( +[NSNumber numberWithUnsignedLongLong:]( &OBJC_CLASS___NSNumber,  "numberWithUnsignedLongLong:",  *(void *)(a1 + 24)));
  [v65 setObject:v32 forKeyedSubscript:@"NumberOfEventsInBackground"];

  uint64_t v33 = (void *)objc_claimAutoreleasedReturnValue( +[NSNumber numberWithUnsignedLongLong:]( &OBJC_CLASS___NSNumber,  "numberWithUnsignedLongLong:",  *(void *)(a1 + 32)));
  [v65 setObject:v33 forKeyedSubscript:@"NumberOfEventsInForeground"];

  uint64_t v34 = (void *)objc_claimAutoreleasedReturnValue( +[NSNumber numberWithUnsignedInt:]( &OBJC_CLASS___NSNumber,  "numberWithUnsignedInt:",  *(unsigned int *)(a1 + 120)));
  [v65 setObject:v34 forKeyedSubscript:@"NumberOfUniqueDevicesFound"];

  int v35 = (void *)objc_claimAutoreleasedReturnValue( +[NSNumber numberWithUnsignedLongLong:]( &OBJC_CLASS___NSNumber,  "numberWithUnsignedLongLong:",  *(void *)(a1 + 72)));
  [v65 setObject:v35 forKeyedSubscript:@"NumberOfUniquePairedDevicesFound"];

  uint64_t v36 = (void *)objc_claimAutoreleasedReturnValue(+[NSNumber numberWithBool:](&OBJC_CLASS___NSNumber, "numberWithBool:", **(unsigned __int8 **)(a1 + 8)));
  [v65 setObject:v36 forKeyedSubscript:@"AllowsDuplicates"];

  __int128 v37 = (void *)objc_claimAutoreleasedReturnValue( +[NSNumber numberWithUnsignedLongLong:]( &OBJC_CLASS___NSNumber,  "numberWithUnsignedLongLong:",  *(void *)(a1 + 40)));
  [v65 setObject:v37 forKeyedSubscript:@"TimeSpentInBackground"];

  unint64_t v38 = (void *)objc_claimAutoreleasedReturnValue( +[NSNumber numberWithUnsignedLongLong:]( &OBJC_CLASS___NSNumber,  "numberWithUnsignedLongLong:",  *(void *)(a1 + 48)));
  [v65 setObject:v38 forKeyedSubscript:@"TimeSpentInForeground"];

  id v39 = (void *)objc_claimAutoreleasedReturnValue( +[NSNumber numberWithUnsignedLongLong:]( &OBJC_CLASS___NSNumber,  "numberWithUnsignedLongLong:",  *(void *)(a1 + 56)));
  [v65 setObject:v39 forKeyedSubscript:@"DurationInMS"];

  uint64_t v40 = (void *)objc_claimAutoreleasedReturnValue(+[NSNumber numberWithBool:](&OBJC_CLASS___NSNumber, "numberWithBool:", *(unsigned __int8 *)(a1 + 64)));
  [v65 setObject:v40 forKeyedSubscript:@"AppInForegroundAtStart"];

  int v41 = (void *)objc_claimAutoreleasedReturnValue(+[NSNumber numberWithBool:](&OBJC_CLASS___NSNumber, "numberWithBool:", *(unsigned __int8 *)(a1 + 65)));
  [v65 setObject:v41 forKeyedSubscript:@"AppInForegroundAtStop"];

  int v42 = +[NSNumber numberWithBool:](&OBJC_CLASS___NSNumber, "numberWithBool:", sub_100610CCC(a1));
  id v43 = (void *)objc_claimAutoreleasedReturnValue(v42);
  [v65 setObject:v43 forKeyedSubscript:@"AllowedInBackground"];

  unsigned int v44 = (void *)objc_claimAutoreleasedReturnValue(+[NSNumber numberWithBool:](&OBJC_CLASS___NSNumber, "numberWithBool:", *(unsigned __int8 *)(a1 + 82)));
  [v65 setObject:v44 forKeyedSubscript:@"ScreenState"];

  uint64_t v45 = objc_alloc_init(&OBJC_CLASS___NSMutableSet);
  uint64_t v46 = *(void *)(a1 + 8);
  if (*(_DWORD *)(v46 + 168))
  {
    BOOL v47 = (void *)objc_claimAutoreleasedReturnValue(+[NSNumber numberWithUnsignedInt:](&OBJC_CLASS___NSNumber, "numberWithUnsignedInt:"));
    -[NSMutableSet addObject:](v45, "addObject:", v47);

    uint64_t v46 = *(void *)(a1 + 8);
  }

  uint64_t v48 = *(void *)(v46 + 64);
  uint64_t v49 = *(void *)(v46 + 72);
  while (v48 != v49)
  {
    id v50 = *(id *)(v48 + 72);
    __int128 v67 = 0u;
    __int128 v68 = 0u;
    __int128 v69 = 0u;
    __int128 v70 = 0u;
    id v51 = v50;
    id v52 = [v51 countByEnumeratingWithState:&v67 objects:v76 count:16];
    if (v52)
    {
      uint64_t v53 = *(void *)v68;
      do
      {
        for (uint64_t i = 0LL; i != v52; uint64_t i = (char *)i + 1)
        {
          if (*(void *)v68 != v53) {
            objc_enumerationMutation(v51);
          }
          if ([*(id *)(*((void *)&v67 + 1) + 8 * (void)i) longLongValue])
          {
            id v55 = (void *)objc_claimAutoreleasedReturnValue(+[NSNumber numberWithUnsignedInt:](&OBJC_CLASS___NSNumber, "numberWithUnsignedInt:"));
            -[NSMutableSet addObject:](v45, "addObject:", v55);
          }
        }

        id v52 = [v51 countByEnumeratingWithState:&v67 objects:v76 count:16];
      }

      while (v52);
    }

    v48 += 96LL;
  }

  if (-[NSMutableSet count](v45, "count"))
  {
    unsigned int v56 = (void *)objc_claimAutoreleasedReturnValue(-[NSMutableSet allObjects](v45, "allObjects"));
    BOOL v57 = (void *)objc_claimAutoreleasedReturnValue(+[NSMutableArray array](&OBJC_CLASS___NSMutableArray, "array"));
    char v58 = (void *)objc_claimAutoreleasedReturnValue([v56 sortedArrayUsingSelector:"compare:"]);

    for (unint64_t j = 0; j < (unint64_t)[v58 count]; ++j)
    {
      size_t v60 = (void *)objc_claimAutoreleasedReturnValue([v58 objectAtIndex:j]);
      unint64_t v61 = +[NSString stringWithUTF8String:]( NSString,  "stringWithUTF8String:",  sub_100617558((int)[v60 longLongValue]));
      uint64_t v62 = (void *)objc_claimAutoreleasedReturnValue(v61);
      [v57 addObject:v62];
    }

    BOOL v63 = (void *)objc_claimAutoreleasedReturnValue([v57 componentsJoinedByString:@","]);
    [v65 setObject:v63 forKeyedSubscript:@"CBUseCase"];
  }

  else
  {
    char v58 = (void *)objc_claimAutoreleasedReturnValue(+[NSString stringWithUTF8String:](&OBJC_CLASS___NSString, "stringWithUTF8String:", "Unspecified"));
    [v65 setObject:v58 forKeyedSubscript:@"CBUseCase"];
  }

  if (v73)
  {
    char v74 = (unsigned __int8 *)v73;
    operator delete(v73);
  }

  return v65;
}

void sub_100617340( _Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, void *a11, void *a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20, void *a21, uint64_t a22, int a23, __int16 a24, char a25, char a26, void *__p, uint64_t a28)
{
  if (__p) {
    operator delete(__p);
  }

  _Unwind_Resume(a1);
}

const char *sub_100617558(int a1)
{
  if (a1 >= 0x20000)
  {
    if (a1 >= 327680)
    {
      if (a1 > 589824)
      {
        if (a1 <= 2147418111)
        {
          switch(a1)
          {
            case 589825:
              return "FindNearbyPencil";
            case 655360:
              return "AccessDigitalHomeKey";
            case 786432:
              return "ProxControlDeviceClose";
            default:
              return "?";
          }
        }

        else
        {
          switch(a1)
          {
            case 2147418112:
              uint64_t result = "InternalTestNoLockScan";
              break;
            case 2147418113:
              uint64_t result = "InternalTestNoScreenOffScan";
              break;
            case 2147418114:
              uint64_t result = "InternalTestScanWithNoDups";
              break;
            case 2147418115:
              uint64_t result = "InternalTestScanWithDups";
              break;
            case 2147418116:
              uint64_t result = "InternalTestScanFor20Seconds";
              break;
            case 2147418117:
              uint64_t result = "InternalTestActiveScan";
              break;
            case 2147418118:
              uint64_t result = "InternalTestUUIDScan";
              break;
            case 2147418119:
              uint64_t result = "InternalTestScanFor10ClockSeconds";
              break;
            case 2147418120:
              uint64_t result = "InternalTestScanBoost";
              break;
            default:
              return "?";
          }
        }
      }

      else if (a1 > 458752)
      {
        switch(a1)
        {
          case 524288:
            uint64_t result = "ADPD";
            break;
          case 524289:
            uint64_t result = "ADPDBuffer";
            break;
          case 524290:
            uint64_t result = "MicroLocation";
            break;
          case 524291:
            uint64_t result = "MicroLocationLeech";
            break;
          default:
            if (a1 == 458753)
            {
              uint64_t result = "PrecisionFindingFindee";
            }

            else
            {
              if (a1 != 589824) {
                return "?";
              }
              uint64_t result = "FindNearbyRemote";
            }

            break;
        }
      }

      else
      {
        switch(a1)
        {
          case 393216:
            uint64_t result = "CaptiveNetworkJoin";
            break;
          case 393217:
            uint64_t result = "UseCaseSIMTransfer";
            break;
          case 393218:
            uint64_t result = "MacSetup";
            break;
          case 393219:
            uint64_t result = "AppleIDSignIn";
            break;
          case 393220:
            uint64_t result = "AppleIDSignInSettings";
            break;
          default:
            if (a1 == 327680)
            {
              uint64_t result = "RapportThirdParty";
            }

            else
            {
              if (a1 != 458752) {
                return "?";
              }
              uint64_t result = "PrecisionFindingFinder";
            }

            break;
        }
      }
    }

    else
    {
      switch(a1)
      {
        case 131072:
          return "SharingDefault";
        case 131073:
          return "SharingPhoneAutoUnlock";
        case 131074:
          return "SharingSiriWatchAuth";
        case 131075:
          return "SharingMacAutoUnlock";
        case 131076:
          return "SharingEDTScreenOn";
        case 131077:
          return "SharingEDTWiFiDisabled";
        case 131078:
          return "SharingEDTWombatEligibleAsDefaultCamera";
        case 131079:
          return "SharingEDTWombatCameraPicker";
        case 131080:
          return "SharingWombatBackground";
        case 131081:
          return "SharingUniversalControl";
        case 131082:
          return "SharingPeopleProximity";
        case 131083:
          return "SharingEDTEnsembleOpenDisplayPrefs";
        case 131084:
          return "SharingEDTNearbydMotionStopped";
        case 131085:
          return "SharingDoubleBoostGenericScan";
        case 131086:
          return "SharingEDTIncomingAdvertisement ";
        case 131087:
          return "SharingEDTWombatStreamStart";
        case 131088:
          return "SharingOYAutoUnlock";
        case 131089:
          return "?";
        case 131090:
          return "SharingAirDrop";
        case 131091:
          return "SharingNearbyInvitationHost";
        case 131092:
          return "SharingNearbyInvitationParticipant";
        case 131093:
          return "SharingAirDropAskToAirDrop";
        case 131094:
          return "SharingAirDropTempIdentity";
        case 131095:
          return "SharingAirDropNeedsCLink";
        case 131096:
          return "SharingRemoteWidgetUpdate";
        case 131097:
          return "SharingCountryCodeUpdate";
        case 131098:
          return "SharingMacPhoneAutoUnlock";
        case 131099:
          return "SharingVisionProDiscovery";
        case 131100:
          return "SharingVisionProStateChange";
        case 131101:
          return "SharingContinuityScreen";
        case 131102:
          return "SharingEDTRemoteDisplay";
        default:
          if (a1 == 196608)
          {
            uint64_t result = "DigitalIDTSA";
          }

          else
          {
            if (a1 != 0x40000) {
              return "?";
            }
            uint64_t result = "DigitalCarKeyThirdParty";
          }

          break;
      }
    }
  }

  else
  {
    uint64_t result = "Unspecified";
    switch(a1)
    {
      case 0:
        return result;
      case 1:
        uint64_t result = "HealthKit";
        break;
      case 2:
        uint64_t result = "HomeKit";
        break;
      case 3:
        uint64_t result = "FindMyObjectConnection";
        break;
      case 4:
        uint64_t result = "FindMyObjectConnectionTransient";
        break;
      case 5:
        uint64_t result = "MIDI";
        break;
      case 6:
        uint64_t result = "Continuity";
        break;
      case 7:
        uint64_t result = "InstantHotSpot";
        break;
      case 8:
        uint64_t result = "NearBy";
        break;
      case 9:
        uint64_t result = "Sharing";
        break;
      case 10:
        uint64_t result = "HearingSupport";
        break;
      case 11:
        uint64_t result = "Magnet";
        break;
      case 12:
        uint64_t result = "HID";
        break;
      case 13:
        uint64_t result = "LEA";
        break;
      case 14:
        uint64_t result = "External";
        break;
      case 15:
        uint64_t result = "ExternalMedical";
        break;
      case 16:
        uint64_t result = "ExternalLock";
        break;
      case 17:
        uint64_t result = "ExternalWatch";
        break;
      case 18:
        uint64_t result = "SmartRouting";
        break;
      case 19:
        uint64_t result = "DigitalID";
        break;
      case 20:
        uint64_t result = "DigitalKey";
        break;
      case 21:
        uint64_t result = "DigitalCarKey";
        break;
      case 22:
        uint64_t result = "HeySiri";
        break;
      case 23:
        uint64_t result = "ThirdPartyApp";
        break;
      case 24:
        uint64_t result = "CNJ";
        break;
      default:
        switch(a1)
        {
          case 256:
            uint64_t result = "DevicePresenceDetection";
            break;
          case 257:
            uint64_t result = "AudioBox";
            break;
          case 258:
            uint64_t result = "SIMTransfer";
            break;
          case 259:
            uint64_t result = "ProximityScreenOnLeechScan";
            break;
          case 260:
            uint64_t result = "MacMigrate";
            break;
          case 263:
            uint64_t result = "HIDUARTService";
            break;
          case 264:
            uint64_t result = "AccessibilitySwitchControlPairing";
            break;
          case 265:
            uint64_t result = "BaseBandFastConnect";
            break;
          case 266:
            uint64_t result = "SafetyAlerts";
            break;
          case 267:
            uint64_t result = "LECarPlay";
            break;
          case 268:
            uint64_t result = "TCCBluetooth";
            break;
          case 269:
            uint64_t result = "AOPBufferLeech";
            break;
          default:
            return "?";
        }

        break;
    }
  }

  return result;
}

BOOL sub_100617C84(uint64_t a1)
{
  uint64_t v2 = *(void *)(a1 + 8);
  int v3 = *(_DWORD *)(v2 + 168);
  memset((char *)&v24[1] + 12, 0, 32);
  memset((char *)&v24[3] + 12, 0, 28);
  __int128 v4 = *(_OWORD *)(v2 + 296);
  __int128 v23 = *(_OWORD *)(v2 + 280);
  v24[0] = v4;
  *(_OWORD *)((char *)v24 + 12) = *(_OWORD *)(v2 + 308);
  memset(&v24[2], 0, 24);
  sub_10060E68C( &v24[2],  *(void *)(v2 + 328),  *(void *)(v2 + 336),  0xAAAAAAAAAAAAAAABLL * ((uint64_t)(*(void *)(v2 + 336) - *(void *)(v2 + 328)) >> 5));
  memset((char *)&v24[3] + 8, 0, 24);
  sub_100050EE8( (char *)&v24[3] + 8,  *(__int128 **)(v2 + 352),  *(__int128 **)(v2 + 360),  0xCCCCCCCCCCCCCCCDLL * ((uint64_t)(*(void *)(v2 + 360) - *(void *)(v2 + 352)) >> 2));
  LOBYTE(v24[5]) = *(_BYTE *)(v2 + 376);
  uint64_t v5 = sub_1002E8D54();
  int v6 = (*(uint64_t (**)(uint64_t))(*(void *)v5 + 184LL))(v5);
  uint64_t v7 = sub_1002E8D54();
  int v8 = (*(uint64_t (**)(uint64_t))(*(void *)v7 + 192LL))(v7);
  int v9 = *(unsigned __int8 *)(a1 + 225);
  int v10 = *(unsigned __int8 *)(a1 + 81);
  if (BYTE8(v23))
  {
    if (BYTE4(v23) | BYTE5(v23))
    {
      if (os_log_type_enabled((os_log_t)qword_1008F75B8, OS_LOG_TYPE_DEBUG)) {
        sub_10069E468();
      }
      int v11 = 0;
    }

    else
    {
      int v11 = 1;
    }

    if (BYTE1(v23)) {
      int v13 = 0;
    }
    else {
      int v13 = v6;
    }
    if (v13 == 1)
    {
      if (os_log_type_enabled((os_log_t)qword_1008F75B8, OS_LOG_TYPE_DEBUG)) {
        sub_10069E3E4();
      }
      int v11 = 0;
    }

    BOOL v12 = v11 != 0;
    if (BYTE2(v23)) {
      char v14 = 1;
    }
    else {
      char v14 = v8;
    }
    if ((v14 & 1) == 0)
    {
      if (os_log_type_enabled((os_log_t)qword_1008F75B8, OS_LOG_TYPE_DEBUG)) {
        sub_10069E36C();
      }
      BOOL v12 = 0LL;
    }
  }

  else
  {
    BOOL v12 = 1LL;
  }

  id v15 = (os_log_s *)qword_1008F75B8;
  if (!v9 && v3 == 23 && v10 != 16)
  {
    if (os_log_type_enabled((os_log_t)qword_1008F75B8, OS_LOG_TYPE_DEBUG))
    {
      uint64_t v20 = (void *)(a1 + 232);
      *(_DWORD *)std::stringbuf::string_type buf = 136315394;
      *(void *)&uint8_t buf[4] = v20;
      __int16 v26 = 1024;
      LODWORD(v27) = v10;
      _os_log_debug_impl( (void *)&_mh_execute_header,  v15,  OS_LOG_TYPE_DEBUG,  "agent %s cannot scan, CBUseCaseThirdPartyApp not allowed to scan in background getSessionState:%d",  buf,  0x12u);
      BOOL v12 = 0LL;
      id v15 = (os_log_s *)qword_1008F75B8;
    }

    else
    {
      BOOL v12 = 0LL;
    }
  }

  if (os_log_type_enabled(v15, OS_LOG_TYPE_DEBUG))
  {
    int v17 = (void *)(a1 + 232);
    int v18 = sub_100617558(v3);
    if (v10 <= 7)
    {
      if (v10 == 2)
      {
        uint64_t v19 = "terminated";
        goto LABEL_48;
      }

      if (v10 == 4)
      {
        uint64_t v19 = "suspended";
        goto LABEL_48;
      }
    }

    else
    {
      switch(v10)
      {
        case 8:
          uint64_t v19 = "background-running";
          goto LABEL_48;
        case 16:
          uint64_t v19 = "foreground-running";
          goto LABEL_48;
        case 32:
          uint64_t v19 = "daemon";
          goto LABEL_48;
      }
    }

    uint64_t v19 = "unknown";
LABEL_48:
    sub_1005E3244((unsigned __int8 *)&v23, &v22);
    if ((v22.__r_.__value_.__s.__size_ & 0x80u) == 0) {
      uint64_t v21 = &v22;
    }
    else {
      uint64_t v21 = (std::stringbuf::string_type *)v22.__r_.__value_.__r.__words[0];
    }
    *(_DWORD *)std::stringbuf::string_type buf = 136316930;
    *(void *)&uint8_t buf[4] = v17;
    __int16 v26 = 2080;
    uint64_t v27 = v18;
    __int16 v28 = 1024;
    BOOL v29 = v12;
    __int16 v30 = 1024;
    int v31 = v6;
    __int16 v32 = 1024;
    int v33 = v8;
    __int16 v34 = 1024;
    int v35 = v9;
    __int16 v36 = 2080;
    __int128 v37 = v19;
    __int16 v38 = 2080;
    id v39 = v21;
    _os_log_debug_impl( (void *)&_mh_execute_header,  v15,  OS_LOG_TYPE_DEBUG,  "canScanNow session:%s(%s) allowed:%d  deviceLocked:%d deviceFirstUnlocked:%d allowedInBKG:%d sessionState:%s %s",  buf,  0x42u);
  }

  if (*((void *)&v24[3] + 1))
  {
    *(void *)&uint8_t v24[4] = *((void *)&v24[3] + 1);
    operator delete(*((void **)&v24[3] + 1));
  }

  *(void *)std::stringbuf::string_type buf = &v24[2];
  sub_10004FEA4((void ***)buf);
  return v12;
}

void sub_100618074(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, ...)
{
}

void sub_1006180AC(uint64_t a1, void *a2)
{
  id v3 = a2;
  *(void *)std::string uu2 = 0LL;
  uint64_t v6 = 0LL;
  sub_100241F90(uu2, v3);
  if (a1 + 112 != sub_1001FDB10(a1 + 104, uu2))
  {
    sub_1006188F4((uint64_t **)(a1 + 104), uu2);
    __int128 v4 = (uint64_t *)sub_1001FDB10(a1 + 152, uu2);
    if ((uint64_t *)(a1 + 160) != v4)
    {
      sub_1001FDBCC((uint64_t **)(a1 + 152), v4);
      operator delete(v4);
    }

    sub_1006181A8(a1 + 128, uu2);
  }
}

void sub_100618188(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void *sub_1006181A8(uint64_t a1, unsigned __int8 *uu2)
{
  v10[0] = (uint64_t)v10;
  v10[1] = (uint64_t)v10;
  _DWORD v10[2] = 0LL;
  uint64_t v2 = *(void *)(a1 + 8);
  if (v2 != a1)
  {
    do
    {
      int v5 = uuid_compare((const unsigned __int8 *)(v2 + 16), uu2);
      uint64_t v6 = *(void *)(v2 + 8);
      if (!v5)
      {
        if (v6 == a1)
        {
          BOOL v8 = 1;
LABEL_8:
          uint64_t v6 = a1;
        }

        else
        {
          while (1)
          {
            int v7 = uuid_compare((const unsigned __int8 *)(v6 + 16), uu2);
            BOOL v8 = v7 == 0;
            if (v7) {
              break;
            }
            uint64_t v6 = *(void *)(v6 + 8);
            if (v6 == a1) {
              goto LABEL_8;
            }
          }
        }

        sub_10040BD38((uint64_t)v10, v10, a1, (void *)v2, (void *)v6);
        if (!v8) {
          uint64_t v6 = *(void *)(v6 + 8);
        }
      }

      uint64_t v2 = v6;
    }

    while (v6 != a1);
  }

  return sub_10023DF50(v10);
}

void sub_100618278(_Unwind_Exception *a1, uint64_t a2, ...)
{
}

uint64_t sub_100618294(uint64_t *a1, uint64_t a2)
{
  uint64_t v2 = *a1;
  uint64_t v3 = 0x6DB6DB6DB6DB6DB7LL * ((a1[1] - *a1) >> 4);
  unint64_t v4 = v3 + 1;
  uint64_t v8 = a1[2];
  uint64_t v7 = (uint64_t)(a1 + 2);
  unint64_t v9 = 0x6DB6DB6DB6DB6DB7LL * ((v8 - v2) >> 4);
  if (2 * v9 > v4) {
    unint64_t v4 = 2 * v9;
  }
  if (v9 >= 0x124924924924924LL) {
    unint64_t v10 = 0x249249249249249LL;
  }
  else {
    unint64_t v10 = v4;
  }
  uint64_t v18 = v7;
  if (v10) {
    int v11 = (char *)sub_100050C20(v7, v10);
  }
  else {
    int v11 = 0LL;
  }
  char v14 = v11;
  id v15 = &v11[112 * v3];
  int v17 = &v11[112 * v10];
  sub_1006183A8((uint64_t)v15, a2);
  int v16 = v15 + 112;
  sub_100050B84(a1, &v14);
  uint64_t v12 = a1[1];
  sub_100050C68(&v14);
  return v12;
}

void sub_100618394(_Unwind_Exception *a1, uint64_t a2, ...)
{
}

uint64_t sub_1006183A8(uint64_t a1, uint64_t a2)
{
  *(void *)a1 = *(id *)a2;
  *(void *)(a1 + _Block_object_dispose(va, 8) = *(id *)(a2 + 8);
  uint64_t v4 = *(void *)(a2 + 32);
  *(_OWORD *)(a1 + 16) = *(_OWORD *)(a2 + 16);
  *(void *)(a1 + 32) = v4;
  *(void *)(a1 + 40) = &off_10087FAA8;
  uint64_t v5 = *(void *)(a2 + 48);
  *(void *)(a1 + 4_Block_object_dispose(va, 8) = v5;
  if (v5) {
    sub_1002CD1E0(v5);
  }
  uint64_t v6 = *(void *)(a2 + 64);
  *(void *)(a1 + 56) = &off_10087FAA8;
  *(void *)(a1 + 64) = v6;
  if (v6) {
    sub_1002CD1E0(v6);
  }
  __int128 v7 = *(_OWORD *)(a2 + 72);
  *(void *)(a1 + 8_Block_object_dispose(va, 8) = *(void *)(a2 + 88);
  *(_OWORD *)(a1 + 72) = v7;
  *(void *)(a1 + 96) = *(id *)(a2 + 96);
  *(_DWORD *)(a1 + 104) = *(_DWORD *)(a2 + 104);
  return a1;
}

void sub_100618448(_Unwind_Exception *a1)
{
  *(void *)(v1 + 40) = v2;
  uint64_t v4 = *(unsigned int **)(v1 + 48);
  if (v4) {
    sub_1002CD254(v4);
  }

  _Unwind_Resume(a1);
}

uint64_t sub_10061847C(uint64_t a1, unsigned __int8 *a2)
{
  uint64_t v2 = *(void *)(a1 + 96);
  uint64_t v3 = *(void *)(a1 + 104);
  if (v2 == v3) {
    return 0LL;
  }
  while (1)
  {
    if (*(_DWORD *)(v2 + 104) == 1)
    {
      __int128 v5 = *(_OWORD *)(v2 + 20);
      int v8 = *(_DWORD *)(v2 + 36);
      __int128 v7 = v5;
    }

    v2 += 112LL;
    if (v2 == v3) {
      return 0LL;
    }
  }

  return 1LL;
}

uint64_t sub_100618524(void *a1)
{
  uint64_t v2 = (void **)a1[1];
  uint64_t v3 = (void **)a1[2];
  a1[5] = 0LL;
  unint64_t v4 = (char *)v3 - (char *)v2;
  if ((unint64_t)((char *)v3 - (char *)v2) >= 0x11)
  {
    do
    {
      operator delete(*v2);
      uint64_t v3 = (void **)a1[2];
      uint64_t v2 = (void **)(a1[1] + 8LL);
      a1[1] = v2;
      unint64_t v4 = (char *)v3 - (char *)v2;
    }

    while ((unint64_t)((char *)v3 - (char *)v2) > 0x10);
  }

  unint64_t v5 = v4 >> 3;
  if (v5 == 1)
  {
    uint64_t v6 = 85LL;
  }

  else
  {
    if (v5 != 2) {
      goto LABEL_9;
    }
    uint64_t v6 = 170LL;
  }

  a1[4] = v6;
LABEL_9:
  while (v2 != v3)
  {
    __int128 v7 = *v2++;
    operator delete(v7);
  }

  return sub_10023DF04((uint64_t)a1);
}

void sub_1006185B8(uint64_t a1, void *a2)
{
  if (a2)
  {
    sub_1006185B8(a1, *a2);
    sub_1006185B8(a1, a2[1]);
    sub_100618524(a2 + 6);
    operator delete(a2);
  }

uint64_t *sub_100618600(uint64_t **a1, const unsigned __int8 *a2, uint64_t a3)
{
  std::stringbuf::string_type __p = 0LL;
  v10[0] = 0LL;
  v10[1] = 0LL;
  sub_1006186B4((uint64_t)a1, a2, a3, &__p);
  uint64_t v8 = 0LL;
  unint64_t v4 = (uint64_t **)sub_1001FD824((uint64_t)a1, &v8, (unsigned __int8 *)__p + 32);
  unint64_t v5 = *v4;
  if (*v4)
  {
    uint64_t v6 = __p;
    std::stringbuf::string_type __p = 0LL;
    if (v6) {
      sub_100618788((uint64_t)v10, v6);
    }
  }

  else
  {
    sub_100029630(a1, v8, v4, (uint64_t *)__p);
    return (uint64_t *)__p;
  }

  return v5;
}

void sub_100618690( _Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void *__p, uint64_t a11)
{
  if (__p) {
    sub_100618788((uint64_t)&a11, __p);
  }
  _Unwind_Resume(exception_object);
}

uint64_t sub_1006186B4@<X0>( uint64_t a1@<X0>, const unsigned __int8 *a2@<X1>, uint64_t a3@<X2>, void *a4@<X8>)
{
  uint64_t v7 = a1 + 8;
  *a4 = 0LL;
  a4[2] = 0LL;
  a4[1] = 0LL;
  uint64_t v8 = a4 + 1;
  unint64_t v9 = operator new(0x40uLL);
  *a4 = v9;
  *uint64_t v8 = v7;
  *((_BYTE *)a4 + 16) = 0;
  uint64_t result = sub_100618748((uint64_t)v9 + 32, a2, a3);
  *((_BYTE *)a4 + 16) = 1;
  return result;
}

void sub_10061872C(_Unwind_Exception *a1)
{
  void *v1 = 0LL;
  sub_100618788(v2, v3);
  _Unwind_Resume(a1);
}

uint64_t sub_100618748(uint64_t a1, const unsigned __int8 *a2, uint64_t a3)
{
  uint64_t v5 = *(void *)(a3 + 8);
  *(void *)(a1 + 16) = &off_10087FAE8;
  *(void *)(a1 + 24) = v5;
  if (v5) {
    sub_1002CD1E0(v5);
  }
  return a1;
}

void sub_100618788(uint64_t a1, void *__p)
{
  if (*(_BYTE *)(a1 + 8))
  {
    __p[6] = &off_10087FAE8;
    uint64_t v3 = (unsigned int *)__p[7];
    if (v3) {
      sub_1002CD254(v3);
    }
  }

  else if (!__p)
  {
    return;
  }

  operator delete(__p);
}

uint64_t *sub_1006187DC( uint64_t **a1, unsigned __int8 *uu1, uint64_t a3, const unsigned __int8 *__attribute__((__org_typedef(uuid_t))) *a4)
{
  uint64_t v9 = 0LL;
  uint64_t v6 = (uint64_t **)sub_1001FD824((uint64_t)a1, &v9, uu1);
  uint64_t result = *v6;
  if (!*v6)
  {
    memset(v8, 0, sizeof(v8));
    sub_10061887C((uint64_t)a1, a4, v8);
    sub_100029630(a1, v9, v6, (uint64_t *)v8[0]);
    return (uint64_t *)v8[0];
  }

  return result;
}

void sub_10061887C( uint64_t a1@<X0>, const unsigned __int8 *__attribute__((__org_typedef(uuid_t))) *a2@<X2>, unsigned __int8 **a3@<X8>)
{
  uint64_t v5 = (unsigned __int8 *)(a1 + 8);
  *a3 = 0LL;
  a3[1] = 0LL;
  a3[2] = 0LL;
  uint64_t v6 = (unsigned __int8 *)operator new(0x38uLL);
  *a3 = v6;
  a3[1] = v5;
  *((_BYTE *)a3 + 16) = 0;
  uuid_copy(v6 + 32, *a2);
  *((void *)v6 + 6) = 0LL;
  *((_BYTE *)a3 + 16) = 1;
}

void sub_1006188DC(_Unwind_Exception *a1)
{
  void *v1 = 0LL;
  operator delete(v2);
  _Unwind_Resume(a1);
}

uint64_t sub_1006188F4(uint64_t **a1, unsigned __int8 *a2)
{
  uint64_t v3 = (uint64_t *)sub_1001FDB10((uint64_t)a1, a2);
  sub_100618938(a1, v3);
  return 1LL;
}

uint64_t *sub_100618938(uint64_t **a1, uint64_t *a2)
{
  uint64_t v3 = sub_1001FDBCC(a1, a2);
  a2[6] = (uint64_t)&off_10087FAE8;
  unint64_t v4 = (unsigned int *)a2[7];
  if (v4) {
    sub_1002CD254(v4);
  }
  operator delete(a2);
  return v3;
}

uint64_t sub_100618980(uint64_t **a1, unsigned __int8 *a2)
{
  uint64_t v3 = (uint64_t *)sub_1001FDB10((uint64_t)a1, a2);
  unint64_t v4 = v3;
  sub_1001FDBCC(a1, v3);
  operator delete(v4);
  return 1LL;
}

uint64_t *sub_1006189D0(uint64_t **a1, unsigned __int8 *uu1, uint64_t a3)
{
  uint64_t v10 = 0LL;
  uint64_t v5 = (uint64_t **)sub_1001FD824((uint64_t)a1, &v10, uu1);
  uint64_t v6 = *v5;
  if (!*v5)
  {
    uint64_t v7 = v5;
    memset(v9, 0, sizeof(v9));
    sub_100618A6C((uint64_t)a1, a3, v9);
    sub_100029630(a1, v10, v7, v9[0]);
    uint64_t v6 = v9[0];
    v9[0] = 0LL;
    sub_100618B50((uint64_t)v9, 0LL);
  }

  return v6;
}

uint64_t sub_100618A6C@<X0>(uint64_t a1@<X0>, uint64_t a2@<X1>, void *a3@<X8>)
{
  uint64_t v5 = a1 + 8;
  *a3 = 0LL;
  a3[1] = 0LL;
  a3[2] = 0LL;
  uint64_t v6 = operator new(0x68uLL);
  *a3 = v6;
  a3[1] = v5;
  *((_BYTE *)a3 + 16) = 0;
  uint64_t result = sub_100618ADC((uint64_t)v6 + 32, a2);
  *((_BYTE *)a3 + 16) = 1;
  return result;
}

void sub_100618AC4(_Unwind_Exception *a1)
{
}

uint64_t sub_100618ADC(uint64_t a1, uint64_t a2)
{
  *(void *)(a1 + 16) = *(void *)(a2 + 16);
  *(void *)(a1 + 24) = *(void *)(a2 + 24);
  *(void *)(a1 + 32) = *(void *)(a2 + 32);
  *(void *)(a1 + 40) = *(void *)(a2 + 40);
  *(_OWORD *)(a2 + 16) = 0u;
  *(_OWORD *)(a2 + 32) = 0u;
  *(void *)(a1 + 4_Block_object_dispose(va, 8) = *(void *)(a2 + 48);
  *(void *)(a1 + 56) = *(void *)(a2 + 56);
  *(void *)(a2 + 4_Block_object_dispose(va, 8) = 0LL;
  *(void *)(a2 + 56) = 0LL;
  int v4 = *(_DWORD *)(a2 + 64);
  *(_BYTE *)(a1 + 6_Block_object_dispose(va, 8) = *(_BYTE *)(a2 + 68);
  *(_DWORD *)(a1 + 64) = v4;
  return a1;
}

void sub_100618B50(uint64_t a1, uint64_t a2)
{
  uint64_t v2 = *(void **)a1;
  *(void *)a1 = a2;
  if (v2)
  {
    if (*(_BYTE *)(a1 + 16)) {
      sub_100618524(v2 + 6);
    }
    operator delete(v2);
  }

void sub_100618B94(void **a1)
{
  uint64_t v2 = a1[1];
  uint64_t v3 = a1[2];
  unint64_t v4 = (v3 - v2) >> 3;
  if (v3 == v2) {
    uint64_t v5 = 0LL;
  }
  else {
    uint64_t v5 = 170 * v4 - 1;
  }
  uint64_t v6 = (char *)a1[4];
  if (v5 - (unint64_t)&v6[(void)a1[5]] < 0xAA)
  {
    uint64_t v7 = (uint64_t)(a1 + 3);
    uint64_t v8 = a1[3];
    uint64_t v9 = *a1;
    uint64_t v10 = v8 - (_BYTE *)*a1;
    if (v4 >= v10 >> 3)
    {
      if (v8 == v9) {
        unint64_t v11 = 1LL;
      }
      else {
        unint64_t v11 = v10 >> 2;
      }
      uint64_t v46 = a1 + 3;
      std::stringbuf::string_type __p = sub_100008BA0(v7, v11);
      id v43 = (char *)__p;
      unsigned int v44 = (char *)__p;
      uint64_t v45 = (char *)__p + 8 * v12;
      int v41 = operator new(0xFF0uLL);
      sub_10023FEC0(&__p, &v41);
      int v13 = (char *)a1[1];
      char v14 = v44;
      if (v13 == a1[2])
      {
        int v33 = (char *)a1[1];
      }

      else
      {
        do
        {
          if (v14 == v45)
          {
            int64_t v15 = v43 - (_BYTE *)__p;
            if (v43 <= __p)
            {
              if (v14 == __p) {
                unint64_t v23 = 1LL;
              }
              else {
                unint64_t v23 = (v14 - (_BYTE *)__p) >> 2;
              }
              unsigned __int16 v24 = (char *)sub_100008BA0((uint64_t)v46, v23);
              __int16 v26 = v43;
              char v14 = &v24[8 * (v23 >> 2)];
              uint64_t v27 = v44 - v43;
              if (v44 != v43)
              {
                char v14 = &v24[8 * (v23 >> 2) + (v27 & 0xFFFFFFFFFFFFFFF8LL)];
                uint64_t v28 = 8 * (v27 >> 3);
                BOOL v29 = &v24[8 * (v23 >> 2)];
                do
                {
                  uint64_t v30 = *(void *)v26;
                  v26 += 8;
                  *(void *)BOOL v29 = v30;
                  v29 += 8;
                  v28 -= 8LL;
                }

                while (v28);
              }

              int v31 = __p;
              std::stringbuf::string_type __p = v24;
              id v43 = &v24[8 * (v23 >> 2)];
              unsigned int v44 = v14;
              uint64_t v45 = &v24[8 * v25];
              if (v31)
              {
                operator delete(v31);
                char v14 = v44;
              }
            }

            else
            {
              uint64_t v16 = v15 >> 3;
              BOOL v17 = v15 >> 3 < -1;
              uint64_t v18 = (v15 >> 3) + 2;
              if (v17) {
                uint64_t v19 = v18;
              }
              else {
                uint64_t v19 = v16 + 1;
              }
              uint64_t v20 = &v43[-8 * (v19 >> 1)];
              int64_t v21 = v14 - v43;
              if (v14 != v43)
              {
                memmove(&v43[-8 * (v19 >> 1)], v43, v14 - v43);
                char v14 = v43;
              }

              std::stringbuf::string_type v22 = &v14[-8 * (v19 >> 1)];
              char v14 = &v20[v21];
              id v43 = v22;
              unsigned int v44 = &v20[v21];
            }
          }

          uint64_t v32 = *(void *)v13;
          v13 += 8;
          *(void *)char v14 = v32;
          char v14 = v44 + 8;
          v44 += 8;
        }

        while (v13 != a1[2]);
        int v33 = (char *)a1[1];
      }

      __int16 v36 = *a1;
      __int128 v37 = v43;
      *a1 = __p;
      a1[1] = v37;
      std::stringbuf::string_type __p = v36;
      id v43 = v33;
      __int16 v38 = (char *)a1[3];
      id v39 = v45;
      a1[2] = v14;
      a1[3] = v39;
      unsigned int v44 = v13;
      uint64_t v45 = v38;
      if (v14 - v37 == 8) {
        uint64_t v40 = 85LL;
      }
      else {
        uint64_t v40 = (uint64_t)a1[4] + 170;
      }
      a1[4] = (void *)v40;
      if (v13 != v33) {
        unsigned int v44 = &v13[(v33 - v13 + 7) & 0xFFFFFFFFFFFFFFF8LL];
      }
      if (v36) {
        operator delete(v36);
      }
    }

    else
    {
      if (v2 == v9)
      {
        std::stringbuf::string_type __p = operator new(0xFF0uLL);
        sub_10023FC90(a1, &__p);
        __int16 v34 = a1[2];
        std::stringbuf::string_type __p = (void *)*(v34 - 1);
        a1[2] = v34 - 1;
      }

      else
      {
        std::stringbuf::string_type __p = operator new(0xFF0uLL);
      }

      sub_10023FDA4((uint64_t)a1, &__p);
      if ((_BYTE *)a1[2] - (_BYTE *)a1[1] == 8) {
        uint64_t v35 = 85LL;
      }
      else {
        uint64_t v35 = (uint64_t)a1[4] + 170;
      }
      a1[4] = (void *)v35;
    }
  }

  else
  {
    a1[4] = v6 + 170;
    std::stringbuf::string_type __p = (void *)*((void *)v3 - 1);
    a1[2] = v3 - 8;
    sub_10023FDA4((uint64_t)a1, &__p);
  }

void sub_100618E60( _Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void *__p, uint64_t a11, uint64_t a12)
{
  if (__p) {
    operator delete(__p);
  }
  _Unwind_Resume(a1);
}

uint64_t sub_100618EAC(void *a1, int a2)
{
  uint64_t v3 = a1[1];
  uint64_t v2 = a1[2];
  if (v2 == v3) {
    uint64_t v4 = 0LL;
  }
  else {
    uint64_t v4 = 170 * ((v2 - v3) >> 3) - 1;
  }
  unint64_t v5 = v4 - (a1[5] + a1[4]);
  if (v5 < 0xAA) {
    a2 = 1;
  }
  if (v5 < 0x154) {
    int v7 = a2;
  }
  else {
    int v7 = 0;
  }
  if ((v7 & 1) == 0)
  {
    operator delete(*(void **)(v2 - 8));
    a1[2] -= 8LL;
  }

  return v7 ^ 1u;
}

uint64_t *sub_100618F20(uint64_t *a1, uint64_t a2)
{
  a1[2] = 0LL;
  a1[1] = 0LL;
  *a1 = (uint64_t)(a1 + 1);
  sub_100618F74(a1, *(unsigned __int8 **)a2, (unsigned __int8 *)(a2 + 8));
  return a1;
}

void sub_100618F5C(_Unwind_Exception *a1)
{
}

uint64_t *sub_100618F74(uint64_t *result, unsigned __int8 *a2, unsigned __int8 *a3)
{
  if (a2 != a3)
  {
    uint64_t v4 = a2;
    unint64_t v5 = (uint64_t **)result;
    uint64_t v6 = result + 1;
    do
    {
      uint64_t result = sub_100618FF8(v5, v6, v4 + 32, (uint64_t)(v4 + 32));
      int v7 = (unsigned __int8 *)*((void *)v4 + 1);
      if (v7)
      {
        do
        {
          uint64_t v8 = v7;
          int v7 = *(unsigned __int8 **)v7;
        }

        while (v7);
      }

      else
      {
        do
        {
          uint64_t v8 = (unsigned __int8 *)*((void *)v4 + 2);
          BOOL v9 = *(void *)v8 == (void)v4;
          uint64_t v4 = v8;
        }

        while (!v9);
      }

      uint64_t v4 = v8;
    }

    while (v8 != a3);
  }

  return result;
}

uint64_t *sub_100618FF8(uint64_t **a1, uint64_t *a2, unsigned __int8 *uu2, uint64_t a4)
{
  uint64_t v9 = 0LL;
  uint64_t v10 = 0LL;
  uint64_t v6 = (uint64_t **)sub_1005BF3AC(a1, a2, &v10, &v9, uu2);
  uint64_t result = *v6;
  if (!*v6)
  {
    memset(v8, 0, sizeof(v8));
    sub_100619084((uint64_t)a1, a4, v8);
    sub_100029630(a1, (uint64_t)v10, v6, v8[0]);
    return v8[0];
  }

  return result;
}

uint64_t sub_100619084@<X0>(uint64_t a1@<X0>, uint64_t a2@<X1>, void *a3@<X8>)
{
  uint64_t v5 = a1 + 8;
  *a3 = 0LL;
  a3[2] = 0LL;
  a3[1] = 0LL;
  uint64_t v6 = a3 + 1;
  int v7 = operator new(0x40uLL);
  *a3 = v7;
  *uint64_t v6 = v5;
  *((_BYTE *)a3 + 16) = 0;
  uint64_t result = sub_100619110((uint64_t)v7 + 32, a2);
  *((_BYTE *)a3 + 16) = 1;
  return result;
}

void sub_1006190F4(_Unwind_Exception *a1)
{
  void *v1 = 0LL;
  sub_100618788(v2, v3);
  _Unwind_Resume(a1);
}

uint64_t sub_100619110(uint64_t a1, uint64_t a2)
{
  uint64_t v4 = *(void *)(a2 + 24);
  *(void *)(a1 + 16) = &off_10087FAE8;
  *(void *)(a1 + 24) = v4;
  if (v4) {
    sub_1002CD1E0(v4);
  }
  return a1;
}

uint64_t *sub_100619150(uint64_t *a1, uint64_t a2)
{
  *a1 = (uint64_t)a1;
  a1[1] = (uint64_t)a1;
  a1[2] = 0LL;
  for (uint64_t i = *(void *)(a2 + 8); i != a2; uint64_t i = *(void *)(i + 8))
  {
    uint64_t v5 = sub_1005DCFE8((uint64_t)a1, 0LL, 0LL, (const unsigned __int8 *)(i + 16));
    uint64_t v6 = *a1;
    *uint64_t v5 = *a1;
    v5[1] = a1;
    *(void *)(v6 + _Block_object_dispose(va, 8) = v5;
    *a1 = (uint64_t)v5;
    ++a1[2];
  }

  return a1;
}

void sub_1006191CC(_Unwind_Exception *a1)
{
}

uint64_t *sub_1006191E0(uint64_t *a1, uint64_t a2)
{
  a1[2] = 0LL;
  a1[1] = 0LL;
  *a1 = (uint64_t)(a1 + 1);
  sub_100619234(a1, *(unsigned __int8 **)a2, (unsigned __int8 *)(a2 + 8));
  return a1;
}

void sub_10061921C(_Unwind_Exception *a1)
{
}

uint64_t *sub_100619234(uint64_t *result, unsigned __int8 *a2, unsigned __int8 *a3)
{
  if (a2 != a3)
  {
    uint64_t v4 = a2;
    uint64_t v5 = (uint64_t **)result;
    uint64_t v6 = result + 1;
    do
    {
      uint64_t result = sub_1006192B8(v5, v6, v4 + 32, (uint64_t)(v4 + 32));
      int v7 = (unsigned __int8 *)*((void *)v4 + 1);
      if (v7)
      {
        do
        {
          uint64_t v8 = v7;
          int v7 = *(unsigned __int8 **)v7;
        }

        while (v7);
      }

      else
      {
        do
        {
          uint64_t v8 = (unsigned __int8 *)*((void *)v4 + 2);
          BOOL v9 = *(void *)v8 == (void)v4;
          uint64_t v4 = v8;
        }

        while (!v9);
      }

      uint64_t v4 = v8;
    }

    while (v8 != a3);
  }

  return result;
}

uint64_t *sub_1006192B8(uint64_t **a1, uint64_t *a2, unsigned __int8 *uu2, uint64_t a4)
{
  uint64_t v9 = 0LL;
  uint64_t v10 = 0LL;
  uint64_t v6 = (uint64_t **)sub_1005BF3AC(a1, a2, &v10, &v9, uu2);
  uint64_t result = *v6;
  if (!*v6)
  {
    memset(v8, 0, sizeof(v8));
    sub_100619344((uint64_t)a1, a4, v8);
    sub_100029630(a1, (uint64_t)v10, v6, (uint64_t *)v8[0]);
    return (uint64_t *)v8[0];
  }

  return result;
}

void sub_100619344(uint64_t a1@<X0>, uint64_t a2@<X1>, unsigned __int8 **a3@<X8>)
{
  uint64_t v5 = (unsigned __int8 *)(a1 + 8);
  *a3 = 0LL;
  a3[1] = 0LL;
  a3[2] = 0LL;
  uint64_t v6 = (unsigned __int8 *)operator new(0x38uLL);
  *a3 = v6;
  a3[1] = v5;
  *((_BYTE *)a3 + 16) = 0;
  uuid_copy(v6 + 32, (const unsigned __int8 *)a2);
  *((void *)v6 + 6) = *(void *)(a2 + 16);
  *((_BYTE *)a3 + 16) = 1;
}

void sub_1006193A8(_Unwind_Exception *a1)
{
  void *v1 = 0LL;
  operator delete(v2);
  _Unwind_Resume(a1);
}

void sub_1006193C0(id a1)
{
  uint64_t v1 = operator new(0xEB0uLL);
  sub_10061991C();
  qword_1008D5F18 = (uint64_t)v1;
}

void sub_1006193F0(_Unwind_Exception *a1)
{
}

void sub_100619404(uint64_t a1@<X8>)
{
  *(void *)(v1 - _Block_object_dispose(va, 8) = a1;
}

_OWORD *sub_100619414(_OWORD *a1, uint64_t a2, int a3)
{
  if (a3 == 34)
  {
    unint64_t v4 = 0LL;
    while (1)
    {
      int v5 = *(unsigned __int8 *)(a2 + v4);
      uint64_t v6 = a1;
      if (v5 == 114) {
        goto LABEL_6;
      }
      if (v5 == 99) {
        break;
      }
LABEL_7:
      if (v4 >= 0x22)
      {
        a1[10] = 0u;
        a1[11] = 0u;
        a1[8] = 0u;
        a1[9] = 0u;
        a1[6] = 0u;
        a1[7] = 0u;
        a1[4] = 0u;
        a1[5] = 0u;
        a1[2] = 0u;
        a1[3] = 0u;
        return a1;
      }
    }

    uint64_t v6 = a1 + 1;
LABEL_6:
    *uint64_t v6 = *(_OWORD *)(v4 + a2 + 1);
    v4 += 17LL;
    goto LABEL_7;
  }

  if (os_log_type_enabled((os_log_t)qword_1008F75A8, OS_LOG_TYPE_ERROR)) {
    sub_10069E4D8();
  }
  return a1;
}

__n128 sub_1006194D0(uint64_t a1, _WORD *a2)
{
  *a2 = 34;
  uint64_t v3 = (char *)operator new[](0x22uLL);
  *uint64_t v3 = 114;
  __n128 result = *(__n128 *)a1;
  __int128 v5 = *(_OWORD *)(a1 + 16);
  *(_OWORD *)(v3 + 1) = *(_OWORD *)a1;
  v3[17] = 99;
  *(_OWORD *)(v3 + 1_Block_object_dispose(va, 8) = v5;
  return result;
}

uint64_t sub_100619518(uint64_t a1)
{
  *(void *)a1 = off_1008A42E0;
  *(void *)(a1 + _Block_object_dispose(va, 8) = &off_1008A4340;
  *(void *)(a1 + 16) = &off_1008A4358;
  *(void *)(a1 + 24) = 0LL;
  *(_BYTE *)(a1 + 41) = 0;
  sub_100242DC4(a1 + 48);
  *(_OWORD *)(a1 + 120) = 0u;
  *(void *)(a1 + 112) = a1 + 120;
  *(void *)(a1 + 216) = 0LL;
  *(_BYTE *)(a1 + 424) = 1;
  *(_OWORD *)(a1 + 44_Block_object_dispose(va, 8) = 0u;
  *(_OWORD *)(a1 + 472) = 0u;
  *(void *)(a1 + 432) = 0LL;
  *(void *)(a1 + 440) = a1 + 448;
  *(void *)(a1 + 464) = a1 + 472;
  *(_OWORD *)(a1 + 496) = 0u;
  *(void *)(a1 + 48_Block_object_dispose(va, 8) = a1 + 496;
  *(_OWORD *)(a1 + 520) = 0u;
  *(void *)(a1 + 512) = a1 + 520;
  *(void *)(a1 + 536) = a1 + 544;
  *(_WORD *)(a1 + 594) = 0;
  *(_BYTE *)(a1 + 596) = 0;
  *(_BYTE *)(a1 + 371_Block_object_dispose(va, 8) = 0;
  *(_BYTE *)(a1 + 592) = 0;
  *(_OWORD *)(a1 + 560) = 0u;
  *(_OWORD *)(a1 + 576) = 0u;
  *(_OWORD *)(a1 + 544) = 0u;
  *(_OWORD *)(a1 + 3720) = 0u;
  *(_WORD *)(a1 + 3736) = 25;
  *(void *)(a1 + 3752) = 0LL;
  uint64_t v2 = sub_1002E6E00();
  sub_10002418C(buf, "LE");
  sub_10002418C(__p, "CloudPair");
  if ((*(unsigned int (**)(uint64_t, uint8_t *, void **, uint64_t))(*(void *)v2 + 72LL))( v2,  buf,  __p,  a1 + 424))
  {
    int v3 = *(unsigned __int8 *)(a1 + 424);
    if (v11 < 0) {
      operator delete(__p[0]);
    }
    if (v13 < 0)
    {
      operator delete(*(void **)buf);
      if (v3) {
        goto LABEL_14;
      }
    }

    else if (v3)
    {
      goto LABEL_14;
    }

    unint64_t v4 = (os_log_s *)qword_1008F75A8;
    if (os_log_type_enabled((os_log_t)qword_1008F75A8, OS_LOG_TYPE_DEFAULT))
    {
      *(_WORD *)std::stringbuf::string_type buf = 0;
      _os_log_impl( (void *)&_mh_execute_header,  v4,  OS_LOG_TYPE_DEFAULT,  "Warning: Cloud pairing disabled by defaults write",  buf,  2u);
    }
  }

  else
  {
    if (v11 < 0) {
      operator delete(__p[0]);
    }
    if (v13 < 0) {
      operator delete(*(void **)buf);
    }
  }

void sub_100619830( _Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, _Unwind_Exception *exception_object, void **a11, uint64_t a12, uint64_t a13, void *__p, uint64_t a15, int a16, __int16 a17, char a18, char a19, void *a20, uint64_t a21, int a22, __int16 a23, char a24, char a25)
{
  if (a19 < 0) {
    operator delete(__p);
  }
  if (a25 < 0) {
    operator delete(a20);
  }

  int v33 = *(void **)(v25 + 568);
  if (v33)
  {
    *(void *)(v25 + 576) = v33;
    operator delete(v33);
  }

  sub_10025506C(v27 + 424, *v28);
  sub_1006325A8(v26, *v29);
  sub_1006325A8(v27 + 376, *a11);
  sub_1006325A8(a12, *v31);
  sub_1006325A8(v27 + 328, *v32);
  sub_10063250C(v27, *v30);
  sub_100242E28(a13);

  _Unwind_Resume(a1);
}

uint64_t sub_100619920(uint64_t a1)
{
  *(void *)a1 = off_1008A42E0;
  *(void *)(a1 + _Block_object_dispose(va, 8) = &off_1008A4340;
  *(void *)(a1 + 16) = &off_1008A4358;
  if (qword_1008D60B0 != -1) {
    dispatch_once(&qword_1008D60B0, &stru_1008A45B8);
  }
  sub_100009168((uint64_t)off_1008D60A8 + 80, a1);

  uint64_t v2 = *(void **)(a1 + 568);
  if (v2)
  {
    *(void *)(a1 + 576) = v2;
    operator delete(v2);
  }

  sub_10025506C(a1 + 536, *(void **)(a1 + 544));
  sub_1006325A8(a1 + 512, *(void **)(a1 + 520));
  sub_1006325A8(a1 + 488, *(void **)(a1 + 496));
  sub_1006325A8(a1 + 464, *(void **)(a1 + 472));
  sub_1006325A8(a1 + 440, *(void **)(a1 + 448));
  sub_10063250C(a1 + 112, *(void **)(a1 + 120));
  sub_100242E28(a1 + 48);

  return a1;
}

void sub_100619A0C(_Unwind_Exception *a1)
{
  int v3 = *(void **)(v1 + 568);
  if (v3)
  {
    *(void *)(v1 + 576) = v3;
    operator delete(v3);
  }

  sub_10025506C(v1 + 536, *(void **)(v1 + 544));
  sub_1006325A8(v1 + 512, *(void **)(v1 + 520));
  sub_1006325A8(v1 + 488, *(void **)(v1 + 496));
  sub_1006325A8(v1 + 464, *(void **)(v1 + 472));
  sub_1006325A8(v1 + 440, *(void **)(v1 + 448));
  sub_10063250C(v1 + 112, *(void **)(v1 + 120));
  sub_100242E28(v1 + 48);

  _Unwind_Resume(a1);
}

void sub_100619A94(uint64_t a1)
{
  uint64_t v1 = (void *)sub_100619920(a1);
  operator delete(v1);
}

uint64_t sub_100619AA8(uint64_t a1)
{
  v4[0] = 0LL;
  v4[1] = 0LL;
  sub_100242F28((uint64_t)v4, a1 + 48);
  uint64_t v2 = *(unsigned __int8 *)(a1 + 3718);
  sub_100242FAC((uint64_t)v4);
  return v2;
}

uint64_t sub_100619AEC(uint64_t a1)
{
  unsigned int v9 = 0;
  __int16 v8 = 0;
  int v7 = 0;
  int v2 = sub_100298544(19, (UInt8 *)&v7, 6LL, &v9);
  if (v2 == -34019)
  {
    if (os_log_type_enabled((os_log_t)qword_1008F75A8, OS_LOG_TYPE_ERROR)) {
      sub_10069E538();
    }
    return 130LL;
  }

  int v3 = v2;
  uint64_t result = 103LL;
  if (!v3 && v9 == 6)
  {
    *(void *)(a1 + 240) = ((unint64_t)v7 << 40) | ((unint64_t)BYTE1(v7) << 32) | ((unint64_t)BYTE2(v7) << 24) | ((unint64_t)HIBYTE(v7) << 16) | ((unint64_t)v8 << 8) | HIBYTE(v8) | 0x1000000000000LL;
    int v5 = sub_100298544(17, (UInt8 *)(a1 + 152), 16LL, &v9);
    if (v5 == -34019)
    {
      if (os_log_type_enabled((os_log_t)qword_1008F75A8, OS_LOG_TYPE_ERROR)) {
        sub_10069E564();
      }
      return 130LL;
    }

    int v6 = v5;
    uint64_t result = 103LL;
    if (!v6 && v9 == 16)
    {
      uint64_t result = sub_1001115A4((__int128 *)(a1 + 152), 1, 0, (void *)(a1 + 224));
      if ((_DWORD)result)
      {
        if (os_log_type_enabled((os_log_t)qword_1008F75A8, OS_LOG_TYPE_ERROR)) {
          sub_10069E590();
        }
        return 130LL;
      }
    }
  }

  return result;
}

uint64_t sub_100619C74(__n128 *a1)
{
  __int16 v10 = 0;
  int v9 = 0;
  unsigned __int8 v8 = 1;
  arc4random_buf(&v9, 6uLL);
  LOBYTE(v9) = v9 | 0xC0;
  int v2 = (os_log_s *)qword_1008F75A8;
  if (os_log_type_enabled((os_log_t)qword_1008F75A8, OS_LOG_TYPE_DEFAULT))
  {
    *(_WORD *)int v7 = 0;
    _os_log_impl( (void *)&_mh_execute_header,  v2,  OS_LOG_TYPE_DEFAULT,  "Generating new non connectable identity address",  v7,  2u);
  }

  if (sub_10029871C(0x13u, (const UInt8 *)&v9, 6u))
  {
    int v3 = (os_log_s *)qword_1008F75A8;
    if (os_log_type_enabled((os_log_t)qword_1008F75A8, OS_LOG_TYPE_FAULT))
    {
      *(_WORD *)int v7 = 0;
      _os_log_fault_impl( (void *)&_mh_execute_header,  v3,  OS_LOG_TYPE_FAULT,  "Failed to set new non connectable static random address!",  v7,  2u);
      int v3 = (os_log_s *)qword_1008F75A8;
    }

    if (os_log_type_enabled(v3, OS_LOG_TYPE_ERROR)) {
      sub_10069E61C();
    }
    return 130LL;
  }

  a1[15].n128_u64[0] = ((unint64_t)v9 << 40) | ((unint64_t)BYTE1(v9) << 32) | ((unint64_t)BYTE2(v9) << 24) | ((unint64_t)HIBYTE(v9) << 16) | ((unint64_t)v10 << 8) | HIBYTE(v10) | ((unint64_t)v8 << 48);
  arc4random_buf(&a1[9].n128_i8[8], 0x10uLL);
  unint64_t v4 = (os_log_s *)qword_1008F75A8;
  if (os_log_type_enabled((os_log_t)qword_1008F75A8, OS_LOG_TYPE_DEFAULT))
  {
    *(_WORD *)int v7 = 0;
    _os_log_impl( (void *)&_mh_execute_header,  v4,  OS_LOG_TYPE_DEFAULT,  "Generating new non connectable identity root",  v7,  2u);
  }

  if (sub_10029871C(0x11u, &a1[9].n128_u8[8], 0x10u))
  {
    int v5 = (os_log_s *)qword_1008F75A8;
    if (os_log_type_enabled((os_log_t)qword_1008F75A8, OS_LOG_TYPE_FAULT))
    {
      *(_WORD *)int v7 = 0;
      _os_log_fault_impl( (void *)&_mh_execute_header,  v5,  OS_LOG_TYPE_FAULT,  "Failed to set new non connectable identity root!",  v7,  2u);
      int v5 = (os_log_s *)qword_1008F75A8;
    }

    if (os_log_type_enabled(v5, OS_LOG_TYPE_ERROR)) {
      sub_10069E5F0();
    }
    return 130LL;
  }

  if (sub_1001115A4((__int128 *)&a1[9].n128_i8[8], 1, 0, &a1[14]))
  {
    if (os_log_type_enabled((os_log_t)qword_1008F75A8, OS_LOG_TYPE_ERROR)) {
      sub_10069E590();
    }
    return 130LL;
  }

  sub_10029871C(0x12u, (const UInt8 *)&a1[14], 0x10u);
  if (a1[2].n128_u8[9])
  {
    v7[0] = 0;
    sub_100242CA4(v7);
    sub_100184B9C(a1 + 14);
    sub_100242CD8(v7);
  }

  return 0LL;
}

void sub_100619F08( _Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, char a9)
{
}

uint64_t sub_100619F1C(uint64_t a1)
{
  v28[0] = 0LL;
  v28[1] = 0LL;
  sub_100242F28((uint64_t)v28, a1 + 48);
  unsigned int v27 = 0;
  uint64_t v2 = sub_1002E6BF0();
  int v3 = (*(uint64_t (**)(uint64_t))(*(void *)v2 + 432LL))(v2);
  unint64_t v4 = (os_log_s *)qword_1008F75A8;
  if (os_log_type_enabled((os_log_t)qword_1008F75A8, OS_LOG_TYPE_DEFAULT))
  {
    *(_DWORD *)std::stringbuf::string_type buf = 67109120;
    int v30 = v3;
    _os_log_impl((void *)&_mh_execute_header, v4, OS_LOG_TYPE_DEFAULT, "readRootKeys diagnostics mode:%d", buf, 8u);
  }

  if (v3)
  {
    int v5 = (os_log_s *)qword_1008F75A8;
    uint64_t v6 = 0LL;
    if (os_log_type_enabled((os_log_t)qword_1008F75A8, OS_LOG_TYPE_DEFAULT))
    {
      *(_WORD *)std::stringbuf::string_type buf = 0;
      _os_log_impl((void *)&_mh_execute_header, v5, OS_LOG_TYPE_DEFAULT, "Diagnostics mode, skipping KeyChain", buf, 2u);
LABEL_6:
      uint64_t v6 = 0LL;
      goto LABEL_98;
    }

    goto LABEL_98;
  }

  int v7 = sub_100298544(2, (UInt8 *)(a1 + 136), 16LL, &v27);
  if (v7 == -34019)
  {
    if (os_log_type_enabled((os_log_t)qword_1008F75A8, OS_LOG_TYPE_ERROR)) {
      goto LABEL_39;
    }
    goto LABEL_97;
  }

  if (v7) {
    BOOL v8 = 0;
  }
  else {
    BOOL v8 = v27 == 16;
  }
  int v9 = !v8;
  if (!v8)
  {
    arc4random_buf((void *)(a1 + 136), 0x10uLL);
    if (os_log_type_enabled((os_log_t)qword_1008F75A8, OS_LOG_TYPE_ERROR)) {
      sub_10069E944();
    }
    if (sub_10029871C(2u, (const UInt8 *)(a1 + 136), 0x10u))
    {
      __int16 v10 = (os_log_s *)qword_1008F75A8;
      if (os_log_type_enabled((os_log_t)qword_1008F75A8, OS_LOG_TYPE_FAULT))
      {
        *(_WORD *)std::stringbuf::string_type buf = 0;
        _os_log_fault_impl( (void *)&_mh_execute_header,  v10,  OS_LOG_TYPE_FAULT,  "Failed to set new identity root!",  buf,  2u);
        __int16 v10 = (os_log_s *)qword_1008F75A8;
      }

      if (os_log_type_enabled(v10, OS_LOG_TYPE_ERROR)) {
        sub_10069E918();
      }
      goto LABEL_97;
    }
  }

  int v11 = sub_100298544(1, (UInt8 *)(a1 + 168), 16LL, &v27);
  if (v11 == -34019)
  {
    if (os_log_type_enabled((os_log_t)qword_1008F75A8, OS_LOG_TYPE_ERROR)) {
      goto LABEL_39;
    }
    goto LABEL_97;
  }

  if (v11 || v27 != 16)
  {
    arc4random_buf((void *)(a1 + 168), 0x10uLL);
    if (os_log_type_enabled((os_log_t)qword_1008F75A8, OS_LOG_TYPE_ERROR)) {
      sub_10069E8EC();
    }
    if (sub_10029871C(1u, (const UInt8 *)(a1 + 168), 0x10u))
    {
      uint64_t v12 = (os_log_s *)qword_1008F75A8;
      if (os_log_type_enabled((os_log_t)qword_1008F75A8, OS_LOG_TYPE_FAULT))
      {
        *(_WORD *)std::stringbuf::string_type buf = 0;
        _os_log_fault_impl( (void *)&_mh_execute_header,  v12,  OS_LOG_TYPE_FAULT,  "Failed to set new encryption root!",  buf,  2u);
        uint64_t v12 = (os_log_s *)qword_1008F75A8;
      }

      if (os_log_type_enabled(v12, OS_LOG_TYPE_ERROR)) {
        sub_10069E8C0();
      }
      goto LABEL_97;
    }

    int v9 = 1;
  }

  int v13 = sub_100298544(5, (UInt8 *)(a1 + 312), 96LL, &v27);
  if (v13 == -34019)
  {
    if (os_log_type_enabled((os_log_t)qword_1008F75A8, OS_LOG_TYPE_ERROR)) {
LABEL_39:
    }
      sub_10069E564();
LABEL_97:
    uint64_t v6 = 130LL;
    goto LABEL_98;
  }

  if (v13 || v27 != 96)
  {
    buf[0] = 96;
    if (sub_1001120DC((_OWORD *)(a1 + 248), (_OWORD *)(a1 + 312)))
    {
      if (!os_log_type_enabled((os_log_t)qword_1008F75A8, OS_LOG_TYPE_ERROR)) {
        goto LABEL_97;
      }
LABEL_47:
      sub_10069E868();
      goto LABEL_97;
    }

    if (sub_10029871C(5u, (const UInt8 *)(a1 + 312), 0x60u))
    {
      if (!os_log_type_enabled((os_log_t)qword_1008F75A8, OS_LOG_TYPE_FAULT)) {
        goto LABEL_97;
      }
    }

    else
    {
      if (!os_log_type_enabled((os_log_t)qword_1008F75A8, OS_LOG_TYPE_FAULT)) {
        goto LABEL_97;
      }
    }

void sub_10061A860( _Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, ...)
{
}

BOOL sub_10061A890(uint64_t a1)
{
  v10[0] = 0LL;
  v10[1] = 0LL;
  sub_100242F28((uint64_t)v10, a1 + 48);
  if (!*(void *)(a1 + 456) || (uint64_t v2 = *(const unsigned __int8 **)(a1 + 440), v2 == (const unsigned __int8 *)(a1 + 448)))
  {
    BOOL v5 = 0LL;
  }

  else
  {
    while (1)
    {
      int v3 = sub_100241F94(v2 + 32);
      unint64_t v4 = (void *)objc_claimAutoreleasedReturnValue(v3);
      BOOL v5 = sub_10061C0F8(a1, v4);

      if (v5) {
        break;
      }
      uint64_t v6 = (unsigned __int8 *)*((void *)v2 + 1);
      if (v6)
      {
        do
        {
          int v7 = (const unsigned __int8 **)v6;
          uint64_t v6 = *(unsigned __int8 **)v6;
        }

        while (v6);
      }

      else
      {
        do
        {
          int v7 = (const unsigned __int8 **)*((void *)v2 + 2);
          BOOL v8 = *v7 == v2;
          uint64_t v2 = (const unsigned __int8 *)v7;
        }

        while (!v8);
      }

      uint64_t v2 = (const unsigned __int8 *)v7;
    }

    BOOL v5 = 1LL;
  }

void sub_10061A968( _Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9)
{
}

void sub_10061A988()
{
  uint64_t v0 = sub_1002E6E00();
  sub_10002418C(__p, "LeSecurityManager hit a keychain problem.");
  sub_1004FC14C(v0, (uint64_t *)__p, 3172327085LL);
  if (v2 < 0) {
    operator delete(__p[0]);
  }
}

void sub_10061A9E4( _Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void *__p, uint64_t a11, int a12, __int16 a13, char a14, char a15)
{
  if (a15 < 0) {
    operator delete(__p);
  }
  _Unwind_Resume(exception_object);
}

uint64_t sub_10061AA00(uint64_t a1)
{
  *(_DWORD *)&__size[1] = 0;
  char v2 = (UInt8 *)(a1 + 32);
  if (sub_100298544(11, (UInt8 *)(a1 + 32), 4LL, (unsigned int *)&__size[1])
    || *(_DWORD *)&__size[1] != 4)
  {
    *(_DWORD *)char v2 = 144;
    int v3 = (os_log_s *)qword_1008F76C0;
    if (os_log_type_enabled((os_log_t)qword_1008F76C0, OS_LOG_TYPE_INFO))
    {
      *(_WORD *)std::stringbuf::string_type buf = 0;
      _os_log_impl( (void *)&_mh_execute_header,  v3,  OS_LOG_TYPE_INFO,  "readTEKsFromKeychain empty fEKRollingPeriod",  buf,  2u);
    }

    sub_10029871C(0xBu, v2, 4u);
  }

  uint64_t v4 = objc_claimAutoreleasedReturnValue(+[NSMutableArray array](&OBJC_CLASS___NSMutableArray, "array"));
  BOOL v5 = *(void **)(a1 + 24);
  *(void *)(a1 + 24) = v4;

  __size[0] = 301;
  if (sub_100298544(13, (UInt8 *)__size, 2LL, (unsigned int *)&__size[1]) || *(_DWORD *)&__size[1] != 2)
  {
    uint64_t v13 = sub_1002E6E00();
    if ((*(unsigned int (**)(uint64_t))(*(void *)v13 + 176LL))(v13))
    {
      int v14 = (os_log_s *)qword_1008F76C0;
      if (os_log_type_enabled((os_log_t)qword_1008F76C0, OS_LOG_TYPE_INFO))
      {
        *(_WORD *)std::stringbuf::string_type buf = 0;
        _os_log_impl((void *)&_mh_execute_header, v14, OS_LOG_TYPE_INFO, "reading old TEK Keychain storage", buf, 2u);
      }
    }

    __size[0] = 301;
    __int128 v49 = 0u;
    memset(v50, 0, sizeof(v50));
    __int128 v47 = 0u;
    __int128 v48 = 0u;
    __int128 v45 = 0u;
    __int128 v46 = 0u;
    __int128 v43 = 0u;
    __int128 v44 = 0u;
    __int128 v41 = 0u;
    __int128 v42 = 0u;
    __int128 v39 = 0u;
    __int128 v40 = 0u;
    __int128 v37 = 0u;
    __int128 v38 = 0u;
    __int128 v35 = 0u;
    __int128 v36 = 0u;
    memset(buf, 0, sizeof(buf));
    if (sub_100298544(10, buf, 301LL, (unsigned int *)&__size[1]) || *(_DWORD *)&__size[1] != 301)
    {
      if (os_log_type_enabled((os_log_t)qword_1008F76B8, OS_LOG_TYPE_ERROR)) {
        sub_10069E970();
      }
    }

    else if (buf[0])
    {
      uint64_t v15 = 0LL;
      uint64_t v16 = 20LL * buf[0];
      do
      {
        *(_OWORD *)&__size[3] = *(_OWORD *)&buf[v15 + 1];
        int v32 = *(_DWORD *)&buf[v15 + 17];
        char v33 = *(_DWORD *)(a1 + 32);
        int v17 = *(void **)(a1 + 24);
        uint64_t v18 = (void *)objc_claimAutoreleasedReturnValue(+[NSData dataWithBytes:length:](&OBJC_CLASS___NSData, "dataWithBytes:length:", &__size[3], 21LL));
        [v17 addObject:v18];

        v15 += 20LL;
      }

      while (v16 != v15);
    }

    sub_10062EF5C(a1);
  }

  else
  {
    uint64_t v6 = __size[0];
    if (__size[0])
    {
      int v7 = (UInt8 *)malloc(__size[0]);
      if (sub_100298544(14, v7, v6, (unsigned int *)&__size[1]) || *(_DWORD *)&__size[1] != __size[0])
      {
        if (os_log_type_enabled((os_log_t)qword_1008F76B8, OS_LOG_TYPE_ERROR)) {
          sub_10069E99C();
        }
      }

      else if (__size[0])
      {
        uint64_t v8 = 0LL;
        do
        {
          uint64_t v9 = v7[v8];
          uint64_t v10 = v8 + 1;
          int v11 = *(void **)(a1 + 24);
          uint64_t v12 = (void *)objc_claimAutoreleasedReturnValue( +[NSData dataWithBytes:length:]( &OBJC_CLASS___NSData,  "dataWithBytes:length:",  &v7[v8 + 1],  v9));
          [v11 addObject:v12];

          uint64_t v8 = v10 + v9;
        }

        while (v10 + v9 < (unint64_t)__size[0]);
      }

      free(v7);
    }
  }

  sub_10062F5D8(a1);
  if ([*(id *)(a1 + 24) count])
  {
    id v19 = objc_claimAutoreleasedReturnValue([*(id *)(a1 + 24) objectAtIndex:0]);
    int v20 = *((unsigned __int8 *)[v19 bytes] + 16);
    id v21 = objc_claimAutoreleasedReturnValue([*(id *)(a1 + 24) objectAtIndex:0]);
    int v22 = *((unsigned __int8 *)[v21 bytes] + 17);
    id v23 = objc_claimAutoreleasedReturnValue([*(id *)(a1 + 24) objectAtIndex:0]);
    int v24 = *((unsigned __int8 *)[v23 bytes] + 18);
    id v25 = objc_claimAutoreleasedReturnValue([*(id *)(a1 + 24) objectAtIndex:0]);
    *(_DWORD *)(a1 + 36) = v20 | (v22 << 8) | (v24 << 16) | (*((unsigned __int8 *)[v25 bytes] + 19) << 24);
  }

  uint64_t v26 = sub_1002E6E00();
  if ((*(unsigned int (**)(uint64_t))(*(void *)v26 + 184LL))(v26))
  {
    unsigned int v27 = (os_log_s *)qword_1008F76C0;
    if (os_log_type_enabled((os_log_t)qword_1008F76C0, OS_LOG_TYPE_INFO))
    {
      uint64_t v28 = *(void *)(a1 + 24);
      int v29 = *(_DWORD *)(a1 + 36);
      *(_DWORD *)std::stringbuf::string_type buf = 138412546;
      *(void *)&uint8_t buf[4] = v28;
      *(_WORD *)&_BYTE buf[12] = 1024;
      *(_DWORD *)&buf[14] = v29;
      _os_log_impl( (void *)&_mh_execute_header,  v27,  OS_LOG_TYPE_INFO,  "readTEKsFromKeychain fTEKArray %@ fENIntervalNumber=%d",  buf,  0x12u);
    }
  }

  return 0LL;
}

void sub_10061AE8C(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_10061AEE0(uint64_t a1)
{
  uint64_t v1 = sub_1002E6BF0();
  if ((*(unsigned int (**)(uint64_t))(*(void *)v1 + 432LL))(v1))
  {
    if (os_log_type_enabled((os_log_t)qword_1008F75A8, OS_LOG_TYPE_ERROR)) {
      sub_10069E9C8();
    }
    return;
  }

  char v33 = (void *)objc_claimAutoreleasedReturnValue(+[NSMutableDictionary dictionary](&OBJC_CLASS___NSMutableDictionary, "dictionary"));
  v41[0] = 0LL;
  v41[1] = 0LL;
  sub_100242F28((uint64_t)v41, a1 + 48);
  id v2 = sub_1002978A8(0LL);
  int v32 = (void *)objc_claimAutoreleasedReturnValue(v2);
  if (qword_1008D5F30 != -1) {
    dispatch_once(&qword_1008D5F30, &stru_1008A45D8);
  }
  sub_1005CFDA0((uint64_t)off_1008D5F28, v32, 0);
  __int128 v39 = 0u;
  __int128 v40 = 0u;
  __int128 v37 = 0u;
  __int128 v38 = 0u;
  id v3 = v32;
  id v4 = [v3 countByEnumeratingWithState:&v37 objects:v46 count:16];
  if (v4)
  {
    uint64_t v5 = *(void *)v38;
    do
    {
      uint64_t v6 = 0LL;
      do
      {
        if (*(void *)v38 != v5) {
          objc_enumerationMutation(v3);
        }
        int v7 = *(void **)(*((void *)&v37 + 1) + 8LL * (void)v6);
        uint64_t v8 = objc_autoreleasePoolPush();
        uint64_t v9 = (void *)objc_claimAutoreleasedReturnValue([v3 objectForKeyedSubscript:v7]);
        id v10 = [v9 unsignedLongLongValue];

        int v11 = (os_log_s *)qword_1008F75A8;
        if (os_log_type_enabled((os_log_t)qword_1008F75A8, OS_LOG_TYPE_DEFAULT))
        {
          id v12 = sub_1005BFB9C((uint64_t)v10);
          uint64_t v13 = (void *)objc_claimAutoreleasedReturnValue(v12);
          *(_DWORD *)std::stringbuf::string_type buf = 138543874;
          *(void *)&uint8_t buf[4] = v13;
          *(_WORD *)&_BYTE buf[12] = 2114;
          *(void *)&buf[14] = v7;
          *(_WORD *)&_BYTE buf[22] = 2048;
          uint64_t v45 = 0LL;
          _os_log_impl( (void *)&_mh_execute_header,  v11,  OS_LOG_TYPE_DEFAULT,  "MUC - BTAddr %{public}@, BTUUID %{public}@, HostAddr to use 0x%llx",  buf,  0x20u);
        }

        if (sub_10061B53C(a1, (unint64_t)v10, v7))
        {
          *(void *)uuid_t uu = 0LL;
          uint64_t v43 = 0LL;
          if (qword_1008D5F30 != -1) {
            dispatch_once(&qword_1008D5F30, &stru_1008A45D8);
          }
          sub_1005C8684((uint64_t)off_1008D5F28, (unint64_t)v10, 0, 1u, 0LL, 0LL, uu);
          if (uuid_is_null(uu))
          {
            if (uuid_is_null(uu) && os_log_type_enabled((os_log_t)qword_1008F75A8, OS_LOG_TYPE_FAULT))
            {
              id v14 = sub_1005BFB9C((uint64_t)v10);
              objc_claimAutoreleasedReturnValue(v14);
              sub_10069E9F4();
            }

            goto LABEL_23;
          }

          memset(buf, 0, sizeof(buf));
          if (qword_1008D5F30 != -1) {
            dispatch_once(&qword_1008D5F30, &stru_1008A45D8);
          }
          uint64_t v16 = off_1008D5F28;
          int v17 = sub_100241F94(uu);
          uint64_t v18 = (void *)objc_claimAutoreleasedReturnValue(v17);
          sub_1005CF060((uint64_t)v16, v18, (uint64_t)buf);

          if ((char)buf[23] < 0)
          {
            if (*(void *)&buf[8])
            {
              id v19 = *(uint8_t **)buf;
LABEL_32:
              int v20 = (void *)objc_claimAutoreleasedReturnValue( +[NSString stringWithUTF8String:]( &OBJC_CLASS___NSString,  "stringWithUTF8String:",  v19,  v32));
              id v21 = sub_100241F94(uu);
              int v22 = (void *)objc_claimAutoreleasedReturnValue(v21);
              [v33 setObject:v20 forKeyedSubscript:v22];
            }
          }

          else if (buf[23])
          {
            id v19 = buf;
            goto LABEL_32;
          }

          if (qword_1008D5F30 != -1) {
            dispatch_once(&qword_1008D5F30, &stru_1008A45D8);
          }
          id v23 = off_1008D5F28;
          sub_10002418C(__p, "_HIDEINSETTINGS_");
          int v24 = sub_1005CE5A8((uint64_t)v23, v7, (uint64_t)__p);
          int v25 = v24;
          if (v36 < 0)
          {
            operator delete(__p[0]);
            if (!v25) {
              goto LABEL_42;
            }
          }

          else if (!v24)
          {
LABEL_42:
            goto LABEL_23;
          }

          if (qword_1008D5F30 != -1) {
            dispatch_once(&qword_1008D5F30, &stru_1008A45D8);
          }
          sub_1005D4D10((uint64_t)off_1008D5F28, v7, 1);
          goto LABEL_42;
        }

        if (os_log_type_enabled((os_log_t)qword_1008F75A8, OS_LOG_TYPE_ERROR))
        {
          id v15 = sub_1005BFB9C((uint64_t)v10);
          objc_claimAutoreleasedReturnValue(v15);
          sub_10069EA3C();
        }

        sub_1002983AC((uint64_t)v10, 0LL, 1);
LABEL_23:
        objc_autoreleasePoolPop(v8);
        uint64_t v6 = (char *)v6 + 1;
      }

      while (v4 != v6);
      id v26 = [v3 countByEnumeratingWithState:&v37 objects:v46 count:16];
      id v4 = v26;
    }

    while (v26);
  }

  unsigned int v27 = (os_log_s *)qword_1008F75A8;
  if (os_log_type_enabled((os_log_t)qword_1008F75A8, OS_LOG_TYPE_DEFAULT))
  {
    id v28 = [v3 count];
    id v29 = [v3 count];
    int v30 = "s";
    uint64_t v31 = *(void *)(a1 + 456);
    *(_DWORD *)std::stringbuf::string_type buf = 134218498;
    if (v29 == (id)1) {
      int v30 = "";
    }
    *(void *)&uint8_t buf[4] = v28;
    *(_WORD *)&_BYTE buf[12] = 2082;
    *(void *)&buf[14] = v30;
    *(_WORD *)&_BYTE buf[22] = 2048;
    uint64_t v45 = v31;
    _os_log_impl( (void *)&_mh_execute_header,  v27,  OS_LOG_TYPE_DEFAULT,  "Found %lu paired LE device%{public}s in local keychain, loaded %lu",  buf,  0x20u);
  }

  sub_100242FAC((uint64_t)v41);
}

void sub_10061B470( _Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, void *a9, uint64_t a10, void *a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, void *a16, uint64_t a17, int a18, __int16 a19, char a20, char a21, uint64_t a22, uint64_t a23, uint64_t a24, uint64_t a25, uint64_t a26, uint64_t a27, uint64_t a28, uint64_t a29, char a30, uint64_t a31, uint64_t a32, uint64_t a33, uint64_t a34, uint64_t a35, uint64_t a36, uint64_t a37, void *__p, uint64_t a39, int a40, __int16 a41, char a42, char a43)
{
  _Unwind_Resume(a1);
}

BOOL sub_10061B53C(uint64_t a1, unint64_t a2, void *a3)
{
  id v5 = a3;
  v40[0] = 0LL;
  v40[1] = 0LL;
  sub_100242F28((uint64_t)v40, a1 + 48);
  *(void *)uuid_t uu = 0LL;
  uint64_t v51 = 0LL;
  if (qword_1008D5F30 != -1) {
    dispatch_once(&qword_1008D5F30, &stru_1008A45D8);
  }
  sub_1005C8684((uint64_t)off_1008D5F28, a2, 0, 1u, 0LL, 0LL, uu);
  if (uuid_is_null(uu))
  {
    if (uuid_is_null(uu) && os_log_type_enabled((os_log_t)qword_1008F75A8, OS_LOG_TYPE_FAULT))
    {
      id v6 = sub_1005BFB9C(a2);
      objc_claimAutoreleasedReturnValue(v6);
      sub_10069EAD4();
    }

    BOOL v7 = 1LL;
  }

  else
  {
    __int128 v38 = 0LL;
    __int128 v39 = 0LL;
    sub_10061CA00(a1, a2, &v38);
    uint64_t v8 = (os_log_s *)qword_1008F75A8;
    BOOL v9 = os_log_type_enabled((os_log_t)qword_1008F75A8, OS_LOG_TYPE_DEFAULT);
    if (v9)
    {
      memset(out, 0, 37);
      uuid_unparse_upper(uu, (char *)out);
      sub_10002418C(v48, (char *)out);
      id v10 = v49 >= 0 ? v48 : (void **)v48[0];
      *(_DWORD *)std::stringbuf::string_type buf = 136446210;
      uint64_t v45 = v10;
      _os_log_impl( (void *)&_mh_execute_header,  v8,  OS_LOG_TYPE_DEFAULT,  "Verifying keys for device %{public}s",  buf,  0xCu);
      if (v49 < 0) {
        operator delete(v48[0]);
      }
    }

    int v11 = v39;
    char v36 = &off_10089A548;
    __int128 v37 = v39;
    if (v39) {
      sub_1002CD1E0((uint64_t)v39);
    }
    BOOL v7 = sub_10061C488(v9, (uint64_t)&v36);
    char v36 = &off_10089A548;
    if (v11) {
      sub_1002CD254(v11);
    }
    if (v7)
    {
      if (v5)
      {
        id v12 = sub_100241F94(uu);
        uint64_t v13 = (void *)objc_claimAutoreleasedReturnValue(v12);
        unsigned __int8 v14 = objc_msgSend(v5, "isEqual:", v13, v36, v37);

        if ((v14 & 1) == 0)
        {
          id v15 = (os_log_s *)qword_1008F75A8;
          if (os_log_type_enabled((os_log_t)qword_1008F75A8, OS_LOG_TYPE_FAULT))
          {
            sub_100366664(uu, v48);
            int v16 = v49;
            int v17 = (void **)v48[0];
            id v18 = sub_1005BFB9C(a2);
            uint64_t v19 = objc_claimAutoreleasedReturnValue(v18);
            int v20 = (void *)v19;
            id v21 = v48;
            LODWORD(out[0]) = 136446722;
            if (v16 < 0) {
              id v21 = v17;
            }
            *(void *)((char *)out + 4) = v21;
            WORD6(out[0]) = 2114;
            *(void *)((char *)out + 14) = v5;
            WORD3(out[1]) = 2114;
            *((void *)&out[1] + 1) = v19;
            _os_log_fault_impl( (void *)&_mh_execute_header,  v15,  OS_LOG_TYPE_FAULT,  "Cached UUID (%{public}s) doesn't match keychain UUID (%{public}@) for paired address %{public}@",  (uint8_t *)out,  0x20u);
            if (v49 < 0) {
              operator delete(v48[0]);
            }
          }
        }
      }

      else
      {
        int v22 = (os_log_s *)qword_1008F75A8;
        if (os_log_type_enabled((os_log_t)qword_1008F75A8, OS_LOG_TYPE_DEFAULT))
        {
          memset(out, 0, 37);
          uuid_unparse_upper(uu, (char *)out);
          sub_10002418C(v48, (char *)out);
          int v23 = v49;
          int v24 = (void **)v48[0];
          id v25 = sub_1005BFB9C(a2);
          uint64_t v26 = objc_claimAutoreleasedReturnValue(v25);
          unsigned int v27 = v48;
          if (v23 < 0) {
            unsigned int v27 = v24;
          }
          *(_DWORD *)std::stringbuf::string_type buf = 136446466;
          uint64_t v45 = v27;
          __int16 v46 = 2114;
          uint64_t v47 = v26;
          id v28 = (void *)v26;
          _os_log_impl( (void *)&_mh_execute_header,  v22,  OS_LOG_TYPE_DEFAULT,  "Writing recovery UUID (%{public}s) to keychain for paired address %{public}@",  buf,  0x16u);
          if (v49 < 0) {
            operator delete(v48[0]);
          }
        }

        uint64_t v29 = sub_100404FE8();
        int v30 = operator new(0x38uLL);
        uuid_copy(dst, uu);
        sub_100631690((uint64_t)v30, a2, dst, (uint64_t)&v38);
        sub_100405744(v29, v30);
      }

      *(void *)&out[0] = uu;
      uint64_t v31 = sub_100632688( (uint64_t **)(a1 + 440),  uu,  (uint64_t)&unk_1006C2518,  (const unsigned __int8 *__attribute__((__org_typedef(uuid_t))) *)out);
      sub_10002EAC8((uint64_t)(v31 + 6), (uint64_t)&v38);
      int v42 = 0;
      memset(out, 0, sizeof(out));
      sub_10061D7EC(a1, (uint64_t)&v38, out);
      sub_100242F54((uint64_t)v40);
      if (qword_1008D5F30 != -1) {
        dispatch_once(&qword_1008D5F30, &stru_1008A45D8);
      }
      int v32 = off_1008D5F28;
      char v33 = sub_100241F94(uu);
      int v34 = (void *)objc_claimAutoreleasedReturnValue(v33);
      sub_1005D99D8((uint64_t)v32, v34, (uint64_t)out);
    }

    else if (os_log_type_enabled((os_log_t)qword_1008F75A8, OS_LOG_TYPE_ERROR))
    {
      sub_100366664(uu, out);
      sub_10069EA84();
    }

    __int128 v38 = &off_10089A548;
    if (v39) {
      sub_1002CD254(v39);
    }
  }

  sub_100242FAC((uint64_t)v40);

  return v7;
}

void sub_10061BA24(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, unsigned int *a5, ...)
{
  if (a5) {
    sub_1002CD254(a5);
  }
  sub_100242FAC((uint64_t)va);

  _Unwind_Resume(a1);
}

void sub_10061BADC(uint64_t a1)
{
  uint64_t v1 = sub_1002E6BF0();
  if ((*(unsigned int (**)(uint64_t))(*(void *)v1 + 432LL))(v1))
  {
    if (os_log_type_enabled((os_log_t)qword_1008F75A8, OS_LOG_TYPE_ERROR)) {
      sub_10069E9C8();
    }
  }

  else
  {
    uint64_t v2 = sub_1002E6BF0();
    if (((*(uint64_t (**)(uint64_t))(*(void *)v2 + 352LL))(v2) & 1) != 0)
    {
      v42[0] = 0LL;
      v42[1] = 0LL;
      sub_100242F28((uint64_t)v42, a1 + 48);
      id v3 = sub_1002978BC();
      int v34 = (void *)objc_claimAutoreleasedReturnValue(v3);
      id v4 = (os_log_s *)qword_1008F75A8;
      if (os_log_type_enabled((os_log_t)qword_1008F75A8, OS_LOG_TYPE_DEFAULT))
      {
        id v5 = [v34 count];
        id v6 = [v34 count];
        BOOL v7 = "s";
        if (v6 == (id)1) {
          BOOL v7 = "";
        }
        *(_DWORD *)std::stringbuf::string_type buf = 134218242;
        *(void *)&uint8_t buf[4] = v5;
        *(_WORD *)&_BYTE buf[12] = 2082;
        *(void *)&buf[14] = v7;
        _os_log_impl( (void *)&_mh_execute_header,  v4,  OS_LOG_TYPE_DEFAULT,  "Found %lu paired LE device%{public}s in synchronized keychain",  buf,  0x16u);
      }

      if (qword_1008D5F30 != -1) {
        dispatch_once(&qword_1008D5F30, &stru_1008A45D8);
      }
      sub_1005CFDA0((uint64_t)off_1008D5F28, v34, 1);
      __int128 v40 = 0u;
      __int128 v41 = 0u;
      __int128 v38 = 0u;
      __int128 v39 = 0u;
      id v8 = v34;
      id v9 = [v8 countByEnumeratingWithState:&v38 objects:v51 count:16];
      if (v9)
      {
        uint64_t v10 = *(void *)v39;
        do
        {
          int v11 = 0LL;
          do
          {
            if (*(void *)v39 != v10) {
              objc_enumerationMutation(v8);
            }
            id v12 = *(void **)(*((void *)&v38 + 1) + 8LL * (void)v11);
            uint64_t v13 = objc_autoreleasePoolPush();
            unsigned __int8 v14 = (void *)objc_claimAutoreleasedReturnValue([v8 objectForKeyedSubscript:v12]);
            id v15 = [v14 unsignedLongLongValue];

            *(void *)uuid_t uu = 0LL;
            uint64_t v50 = 0LL;
            if (qword_1008D5F30 != -1) {
              dispatch_once(&qword_1008D5F30, &stru_1008A45D8);
            }
            sub_1005C8684((uint64_t)off_1008D5F28, (unint64_t)v15, 0, 1u, 0LL, 0LL, uu);
            if (uuid_is_null(uu))
            {
              int v16 = (os_log_s *)qword_1008F75A8;
              if (os_log_type_enabled((os_log_t)qword_1008F75A8, OS_LOG_TYPE_DEFAULT))
              {
                id v17 = sub_1005BFB9C((uint64_t)v15);
                id v18 = (void *)objc_claimAutoreleasedReturnValue(v17);
                *(_DWORD *)std::stringbuf::string_type buf = 138543362;
                *(void *)&uint8_t buf[4] = v18;
                _os_log_impl( (void *)&_mh_execute_header,  v16,  OS_LOG_TYPE_DEFAULT,  "Failed to retrieve UUID for paired address %{public}@, this is a synced key from another device, we do n't really care about it on this device.",  buf,  0xCu);
              }
            }

            else
            {
              uint64_t v19 = sub_100241F94(uu);
              int v20 = (void *)objc_claimAutoreleasedReturnValue(v19);
              unsigned __int8 v21 = [v12 isEqual:v20];

              if ((v21 & 1) != 0)
              {
                sub_10061B53C(a1, (unint64_t)v15, v12);
                if (!sub_10061C0F8(a1, v12))
                {
                  if (qword_1008D5F30 != -1) {
                    dispatch_once(&qword_1008D5F30, &stru_1008A45D8);
                  }
                  int v22 = off_1008D5F28;
                  int v23 = sub_100241F94(uu);
                  int v24 = (void *)objc_claimAutoreleasedReturnValue(v23);
                  id v25 = sub_1005C6AC0((uint64_t)v22, v24);
                  sub_1005C3B74(v25, 0);

                  uint64_t v26 = (os_log_s *)qword_1008F75A8;
                  if (os_log_type_enabled((os_log_t)qword_1008F75A8, OS_LOG_TYPE_DEFAULT))
                  {
                    id v27 = sub_1005BFB9C((uint64_t)v15);
                    id v28 = (void *)objc_claimAutoreleasedReturnValue(v27);
                    *(_DWORD *)std::stringbuf::string_type buf = 138543618;
                    *(void *)&uint8_t buf[4] = v12;
                    *(_WORD *)&_BYTE buf[12] = 2114;
                    *(void *)&buf[14] = v28;
                    _os_log_impl( (void *)&_mh_execute_header,  v26,  OS_LOG_TYPE_DEFAULT,  "Device %{public}@ (%{public}@) is not really paired, its just a previously paired watch",  buf,  0x16u);
                  }
                }
              }

              else
              {
                uint64_t v29 = (os_log_s *)qword_1008F75A8;
                if (os_log_type_enabled((os_log_t)qword_1008F75A8, OS_LOG_TYPE_DEFAULT))
                {
                  id v30 = sub_1005BFB9C((uint64_t)v15);
                  id v31 = (id)objc_claimAutoreleasedReturnValue(v30);
                  memset(buf, 0, 37);
                  uuid_unparse_upper(uu, (char *)buf);
                  sub_10002418C(__p, (char *)buf);
                  int v32 = __p;
                  if (v37 < 0) {
                    int v32 = (void **)__p[0];
                  }
                  *(_DWORD *)uint64_t v43 = 138543874;
                  __int128 v44 = v12;
                  __int16 v45 = 2114;
                  id v46 = v31;
                  __int16 v47 = 2082;
                  __int128 v48 = v32;
                  _os_log_impl( (void *)&_mh_execute_header,  v29,  OS_LOG_TYPE_DEFAULT,  "Device %{public}@ (%{public}@) UUID from keychain is different than in local database(%{public }s). Ignoring keychain copy.",  v43,  0x20u);
                  if (v37 < 0) {
                    operator delete(__p[0]);
                  }
                }
              }
            }

            objc_autoreleasePoolPop(v13);
            int v11 = (char *)v11 + 1;
          }

          while (v9 != v11);
          id v9 = [v8 countByEnumeratingWithState:&v38 objects:v51 count:16];
        }

        while (v9);
      }

      sub_100242FAC((uint64_t)v42);
    }

    else
    {
      char v33 = (os_log_s *)qword_1008F75A8;
      if (os_log_type_enabled((os_log_t)qword_1008F75A8, OS_LOG_TYPE_DEFAULT))
      {
        *(_WORD *)std::stringbuf::string_type buf = 0;
        _os_log_impl( (void *)&_mh_execute_header,  v33,  OS_LOG_TYPE_DEFAULT,  "skipping synchronized keychain read since this is not a phone.",  buf,  2u);
      }
    }
  }

void sub_10061C06C( _Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, void *a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20, uint64_t a21, uint64_t a22, uint64_t a23, uint64_t a24, uint64_t a25, uint64_t a26, uint64_t a27, uint64_t a28, char a29)
{
  sub_100242FAC((uint64_t)&a29);
  _Unwind_Resume(a1);
}

BOOL sub_10061C0F8(uint64_t a1, void *a2)
{
  id v3 = a2;
  v18[0] = 0LL;
  v18[1] = 0LL;
  sub_100242F28((uint64_t)v18, a1 + 48);
  sub_100241F90(uu2, v3);
  uint64_t v4 = sub_1001FDB10(a1 + 440, uu2);
  uint64_t v5 = v4;
  if (a1 + 448 == v4)
  {
    BOOL v6 = 0LL;
  }

  else
  {
    sub_10032BA60(*(void *)(v4 + 56), 0, uu2);
    if (sub_10056AAC8((uint64_t)uu2))
    {
      sub_10032BA60(*(void *)(v5 + 56), 3, &v16);
      if (sub_10056AAC8((uint64_t)&v16))
      {
        sub_10032BA60(*(void *)(v5 + 56), 4, &v14);
        if (sub_10056AAC8((uint64_t)&v14))
        {
          sub_10032BA60(*(void *)(v5 + 56), 5, &v12);
          if (sub_10056AAC8((uint64_t)&v12))
          {
            sub_10032BA60(*(void *)(v5 + 56), 8, &v10);
            if (sub_10056AAC8((uint64_t)&v10))
            {
              sub_10032BA60(*(void *)(v5 + 56), 9, &v8);
              BOOL v6 = !sub_10056AAC8((uint64_t)&v8);
              id v8 = &off_10087FAA8;
              if (v9) {
                sub_1002CD254(v9);
              }
            }

            else
            {
              BOOL v6 = 1LL;
            }

            uint64_t v10 = &off_10087FAA8;
            if (v11) {
              sub_1002CD254(v11);
            }
          }

          else
          {
            BOOL v6 = 1LL;
          }

          id v12 = &off_10087FAA8;
          if (v13) {
            sub_1002CD254(v13);
          }
        }

        else
        {
          BOOL v6 = 1LL;
        }

        unsigned __int8 v14 = &off_10087FAA8;
        if (v15) {
          sub_1002CD254(v15);
        }
      }

      else
      {
        BOOL v6 = 1LL;
      }

      int v16 = &off_10087FAA8;
      if (v17) {
        sub_1002CD254(v17);
      }
    }

    else
    {
      BOOL v6 = 1LL;
    }

    *(void *)std::string uu2 = &off_10087FAA8;
    if (v20) {
      sub_1002CD254(v20);
    }
  }

  sub_100242FAC((uint64_t)v18);

  return v6;
}

void sub_10061C308( _Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, unsigned int *a11, uint64_t a12, unsigned int *a13, uint64_t a14, unsigned int *a15, uint64_t a16, unsigned int *a17, uint64_t a18, unsigned int *a19)
{
  if (a11) {
    sub_1002CD254(a11);
  }
  if (a13) {
    sub_1002CD254(a13);
  }
  if (a15) {
    sub_1002CD254(a15);
  }
  if (a17) {
    sub_1002CD254(a17);
  }
  if (a19) {
    sub_1002CD254(a19);
  }
  *(void *)(v20 - 56) = &off_10087FAA8;
  int v22 = *(unsigned int **)(v20 - 48);
  if (v22) {
    sub_1002CD254(v22);
  }
  sub_100242FAC(v20 - 72);

  _Unwind_Resume(a1);
}

BOOL sub_10061C408(uint64_t a1, uint64_t a2, int a3)
{
  uint64_t v5 = 0LL;
  BOOL v6 = 0LL;
  sub_10032BA60(*(void *)(a2 + 8), a3, &v5);
  BOOL v3 = sub_10056AAC8((uint64_t)&v5);
  uint64_t v5 = &off_10087FAA8;
  if (v6) {
    sub_1002CD254(v6);
  }
  return !v3;
}

void sub_10061C464( _Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, unsigned int *a10)
{
  if (a10) {
    sub_1002CD254(a10);
  }
  _Unwind_Resume(exception_object);
}

BOOL sub_10061C488(uint64_t a1, uint64_t a2)
{
  BOOL v3 = *(unsigned int **)(a2 + 8);
  v39[0] = &off_10089A548;
  v39[1] = v3;
  if (v3) {
    sub_1002CD1E0((uint64_t)v3);
  }
  BOOL v4 = sub_10061C408(a1, (uint64_t)v39, 0);
  BOOL v5 = v4;
  v39[0] = &off_10089A548;
  if (v3) {
    sub_1002CD254(v3);
  }
  BOOL v6 = *(unsigned int **)(a2 + 8);
  v38[0] = &off_10089A548;
  v38[1] = v6;
  if (v6) {
    sub_1002CD1E0((uint64_t)v6);
  }
  BOOL v7 = sub_10061C408(v4, (uint64_t)v38, 3);
  BOOL v8 = v7;
  v38[0] = &off_10089A548;
  if (v6) {
    sub_1002CD254(v6);
  }
  id v9 = *(unsigned int **)(a2 + 8);
  v37[0] = &off_10089A548;
  v37[1] = v9;
  if (v9) {
    sub_1002CD1E0((uint64_t)v9);
  }
  BOOL v10 = sub_10061C408(v7, (uint64_t)v37, 4);
  BOOL v11 = v10;
  v37[0] = &off_10089A548;
  if (v9) {
    sub_1002CD254(v9);
  }
  id v12 = *(unsigned int **)(a2 + 8);
  v36[0] = &off_10089A548;
  v36[1] = v12;
  if (v12) {
    sub_1002CD1E0((uint64_t)v12);
  }
  BOOL v13 = sub_10061C408(v10, (uint64_t)v36, 5);
  BOOL v14 = v13;
  v36[0] = &off_10089A548;
  if (v12) {
    sub_1002CD254(v12);
  }
  id v15 = *(unsigned int **)(a2 + 8);
  v35[0] = &off_10089A548;
  v35[1] = v15;
  if (v15) {
    sub_1002CD1E0((uint64_t)v15);
  }
  BOOL v16 = sub_10061C408(v13, (uint64_t)v35, 9);
  BOOL v17 = v16;
  v35[0] = &off_10089A548;
  if (v15) {
    sub_1002CD254(v15);
  }
  id v18 = *(unsigned int **)(a2 + 8);
  v34[0] = &off_10089A548;
  v34[1] = v18;
  if (v18) {
    sub_1002CD1E0((uint64_t)v18);
  }
  BOOL v19 = sub_10061C408(v16, (uint64_t)v34, 9);
  v34[0] = &off_10089A548;
  if (v18) {
    sub_1002CD254(v18);
  }
  int v32 = 0LL;
  char v33 = 0LL;
  sub_10032BA60(*(void *)(a2 + 8), 7, &v32);
  unsigned __int8 v21 = (os_log_s *)qword_1008F75A8;
  if (os_log_type_enabled((os_log_t)qword_1008F75A8, OS_LOG_TYPE_DEFAULT))
  {
    *(_DWORD *)std::stringbuf::string_type buf = 67110656;
    *(_DWORD *)&uint8_t buf[4] = v14;
    LOWORD(v44) = 1024;
    *(_DWORD *)((char *)&v44 + 2) = v17;
    HIWORD(v44) = 1024;
    BOOL v45 = v19;
    __int16 v46 = 1024;
    BOOL v47 = v5;
    __int16 v48 = 1024;
    BOOL v49 = v11;
    __int16 v50 = 1024;
    BOOL v51 = v8;
    __int16 v52 = 1024;
    BOOL v53 = v20;
    _os_log_impl( (void *)&_mh_execute_header,  v21,  OS_LOG_TYPE_DEFAULT,  "hasLocalLTK=%d hasLocalRAND=%d hasLocalEDIV=%d hasRemoteLTK=%d hasRemoteRand=%d hasRemoteEDIV=%d securedConnection=%d",  buf,  0x2Cu);
  }

  if (!v20)
  {
    if (!v5 && !v11 && !v8)
    {
      BOOL v14 = v17 ^ v19 ^ 1u;
      goto LABEL_62;
    }

    *(void *)std::stringbuf::string_type buf = 0LL;
    __int128 v44 = 0LL;
    sub_10032BA60(*(void *)(a2 + 8), 1, buf);
    if (sub_10056AAD8((uint64_t)buf) && *(_BYTE *)sub_10056AAF0((uint64_t)buf) == 16)
    {
      __int128 v42 = xmmword_1006BDDF0;
      id v30 = 0LL;
      id v31 = 0LL;
      sub_10056AB04(&v30, &v42, 0x10uLL);
      sub_10032BA60(*(void *)(a2 + 8), 0, &v40);
      BOOL v22 = sub_10056AF84((uint64_t)&v30, (uint64_t)&v40);
      __int128 v40 = &off_10087FAA8;
      if (v41) {
        sub_1002CD254(v41);
      }
      if (v22)
      {
        if (os_log_type_enabled((os_log_t)qword_1008F75A8, OS_LOG_TYPE_ERROR)) {
          sub_10069EB14();
        }
        BOOL v23 = 1;
      }

      else
      {
        __int128 v40 = 0LL;
        __int128 v41 = 0LL;
        sub_1001F0050((uint64_t)&v40, (uint64_t)&v42, 0x10uLL);
        id v28 = 0LL;
        uint64_t v29 = 0LL;
        sub_10056AB04(&v28, &v40, 0x10uLL);
        sub_10032BA60(*(void *)(a2 + 8), 0, &v26);
        BOOL v23 = sub_10056AF84((uint64_t)&v28, (uint64_t)&v26);
        uint64_t v26 = &off_10087FAA8;
        if (v27) {
          sub_1002CD254(v27);
        }
        if (v23)
        {
          if (os_log_type_enabled((os_log_t)qword_1008F75A8, OS_LOG_TYPE_ERROR)) {
            sub_10069EB14();
          }
          BOOL v23 = 1;
        }

        id v28 = &off_10087FAA8;
        if (v29) {
          sub_1002CD254(v29);
        }
      }

      id v30 = &off_10087FAA8;
      if (v31) {
        sub_1002CD254(v31);
      }
      if (v23 || !v5) {
        goto LABEL_59;
      }
    }

    else if (!v5)
    {
LABEL_59:
      BOOL v14 = 0LL;
LABEL_60:
      *(void *)std::stringbuf::string_type buf = &off_10087FAA8;
      if (v44) {
        sub_1002CD254(v44);
      }
      goto LABEL_62;
    }

    BOOL v14 = v8 & v11;
    goto LABEL_60;
  }

void sub_10061C8D8( _Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, unsigned int *a10, uint64_t a11, unsigned int *a12, uint64_t a13, unsigned int *a14, uint64_t a15, unsigned int *a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20, uint64_t a21, uint64_t a22, uint64_t a23, uint64_t a24, uint64_t a25, uint64_t a26, uint64_t a27, uint64_t a28, uint64_t a29, uint64_t a30)
{
  if (a10) {
    sub_1002CD254(a10);
  }
  if (a12) {
    sub_1002CD254(a12);
  }
  if (a14) {
    sub_1002CD254(a14);
  }
  *(void *)(v30 - sub_100242FAC(v47 - 160) = &off_10087FAA8;
  int v32 = *(unsigned int **)(v30 - 152);
  if (v32) {
    sub_1002CD254(v32);
  }
  if (a16) {
    sub_1002CD254(a16);
  }
  _Unwind_Resume(exception_object);
}

uint64_t sub_10061CA00@<X0>(uint64_t a1@<X0>, unint64_t a2@<X1>, void *a3@<X8>)
{
  v160[0] = 0LL;
  v160[1] = 0LL;
  sub_100242F28((uint64_t)v160, a1 + 48);
  *a3 = 0LL;
  a3[1] = 0LL;
  BOOL v6 = operator new(0x28uLL);
  _DWORD v6[2] = 1;
  *(void *)BOOL v6 = &off_10089A468;
  *((void *)v6 + 4) = 0LL;
  *((void *)v6 + 3) = 0LL;
  *((void *)v6 + 2) = v6 + 6;
  *a3 = &off_10089A548;
  a3[1] = v6;
  BOOL v7 = (os_log_s *)qword_1008F75A8;
  if (os_log_type_enabled((os_log_t)qword_1008F75A8, OS_LOG_TYPE_DEFAULT))
  {
    id v8 = sub_1005BFB9C(a2);
    id v9 = (id)objc_claimAutoreleasedReturnValue(v8);
    LODWORD(buf) = 138543362;
    *(void *)((char *)&buf + 4) = v9;
    _os_log_impl( (void *)&_mh_execute_header,  v7,  OS_LOG_TYPE_DEFAULT,  "Loading keys from keychain for device address %{public}@",  (uint8_t *)&buf,  0xCu);
  }

  v163[0] = 0LL;
  v163[1] = 0LL;
  if (qword_1008D5F30 != -1) {
    dispatch_once(&qword_1008D5F30, &stru_1008A45D8);
  }
  sub_1005C8684((uint64_t)off_1008D5F28, a2, 0, 1u, 0LL, 0LL, (unsigned __int8 *)v163);
  if (qword_1008D5F30 != -1) {
    dispatch_once(&qword_1008D5F30, &stru_1008A45D8);
  }
  BOOL v10 = off_1008D5F28;
  BOOL v11 = sub_100241F94((const unsigned __int8 *)v163);
  id v12 = (void *)objc_claimAutoreleasedReturnValue(v11);
  sub_10002418C(__p, "IsAppleWatch");
  int v13 = sub_1005CE5A8((uint64_t)v10, v12, (uint64_t)__p);
  if (v159 < 0) {
    operator delete(__p[0]);
  }

  v157[0] = &off_10089A548;
  v157[1] = v6;
  sub_1002CD1E0((uint64_t)v6);
  sub_100627CA0(a1, a2, (uint64_t)v157, 0xAu, v13);
  v157[0] = &off_10089A548;
  sub_1002CD254(v6);
  __int128 buf = 0uLL;
  BOOL v162 = 0LL;
  id v15 = sub_10024E33C((uint64_t)&v162, 1uLL);
  BOOL v17 = (char *)*((void *)&buf + 1);
  BOOL v16 = (char *)buf;
  id v18 = (char *)&v15[v14];
  _DWORD *v15 = 0;
  BOOL v19 = (char *)(v15 + 1);
  BOOL v20 = v15;
  while (v17 != v16)
  {
    int v21 = *((_DWORD *)v17 - 1);
    v17 -= 4;
    *--BOOL v20 = v21;
  }

  *(void *)&__int128 buf = v20;
  *((void *)&buf + 1) = v15 + 1;
  BOOL v162 = (char *)&v15[v14];
  if (v16)
  {
    operator delete(v16);
    id v18 = v162;
  }

  *((void *)&buf + 1) = v15 + 1;
  if (v19 >= v18)
  {
    BOOL v23 = (char *)buf;
    uint64_t v24 = (uint64_t)&v19[-buf] >> 2;
    unint64_t v25 = v24 + 1;
    uint64_t v26 = (uint64_t)&v18[-buf];
    if (v26 >> 1 > v25) {
      unint64_t v25 = v26 >> 1;
    }
    else {
      unint64_t v27 = v25;
    }
    if (v27)
    {
      id v28 = (char *)sub_10024E33C((uint64_t)&v162, v27);
      BOOL v19 = (char *)*((void *)&buf + 1);
      BOOL v23 = (char *)buf;
    }

    else
    {
      id v28 = 0LL;
    }

    uint64_t v29 = &v28[4 * v24];
    id v18 = &v28[4 * v27];
    *(_DWORD *)uint64_t v29 = 1;
    BOOL v22 = v29 + 4;
    while (v19 != v23)
    {
      int v30 = *((_DWORD *)v19 - 1);
      v19 -= 4;
      *((_DWORD *)v29 - 1) = v30;
      v29 -= 4;
    }

    *(void *)&__int128 buf = v29;
    *((void *)&buf + 1) = v22;
    BOOL v162 = v18;
    if (v23)
    {
      operator delete(v23);
      id v18 = v162;
    }
  }

  else
  {
    v15[1] = 1;
    BOOL v22 = (char *)(v15 + 2);
  }

  *((void *)&buf + 1) = v22;
  if (v22 >= v18)
  {
    int v32 = (char *)buf;
    uint64_t v33 = (uint64_t)&v22[-buf] >> 2;
    unint64_t v34 = v33 + 1;
    uint64_t v35 = (uint64_t)&v18[-buf];
    if (v35 >> 1 > v34) {
      unint64_t v34 = v35 >> 1;
    }
    else {
      unint64_t v36 = v34;
    }
    if (v36)
    {
      char v37 = (char *)sub_10024E33C((uint64_t)&v162, v36);
      BOOL v22 = (char *)*((void *)&buf + 1);
      int v32 = (char *)buf;
    }

    else
    {
      char v37 = 0LL;
    }

    __int128 v38 = &v37[4 * v33];
    id v18 = &v37[4 * v36];
    *(_DWORD *)__int128 v38 = 2;
    id v31 = v38 + 4;
    while (v22 != v32)
    {
      int v39 = *((_DWORD *)v22 - 1);
      v22 -= 4;
      *((_DWORD *)v38 - 1) = v39;
      v38 -= 4;
    }

    *(void *)&__int128 buf = v38;
    *((void *)&buf + 1) = v31;
    BOOL v162 = v18;
    if (v32)
    {
      operator delete(v32);
      id v18 = v162;
    }
  }

  else
  {
    *(_DWORD *)BOOL v22 = 2;
    id v31 = v22 + 4;
  }

  *((void *)&buf + 1) = v31;
  if (v31 >= v18)
  {
    __int128 v41 = (char *)buf;
    uint64_t v42 = (uint64_t)&v31[-buf] >> 2;
    unint64_t v43 = v42 + 1;
    uint64_t v44 = (uint64_t)&v18[-buf];
    if (v44 >> 1 > v43) {
      unint64_t v43 = v44 >> 1;
    }
    else {
      unint64_t v45 = v43;
    }
    if (v45)
    {
      __int16 v46 = (char *)sub_10024E33C((uint64_t)&v162, v45);
      id v31 = (char *)*((void *)&buf + 1);
      __int128 v41 = (char *)buf;
    }

    else
    {
      __int16 v46 = 0LL;
    }

    BOOL v47 = &v46[4 * v42];
    id v18 = &v46[4 * v45];
    *(_DWORD *)BOOL v47 = 3;
    __int128 v40 = v47 + 4;
    while (v31 != v41)
    {
      int v48 = *((_DWORD *)v31 - 1);
      v31 -= 4;
      *((_DWORD *)v47 - 1) = v48;
      v47 -= 4;
    }

    *(void *)&__int128 buf = v47;
    *((void *)&buf + 1) = v40;
    BOOL v162 = v18;
    if (v41)
    {
      operator delete(v41);
      id v18 = v162;
    }
  }

  else
  {
    *(_DWORD *)id v31 = 3;
    __int128 v40 = v31 + 4;
  }

  *((void *)&buf + 1) = v40;
  if (v40 >= v18)
  {
    __int16 v50 = (char *)buf;
    uint64_t v51 = (uint64_t)&v40[-buf] >> 2;
    unint64_t v52 = v51 + 1;
    uint64_t v53 = (uint64_t)&v18[-buf];
    if (v53 >> 1 > v52) {
      unint64_t v52 = v53 >> 1;
    }
    else {
      unint64_t v54 = v52;
    }
    if (v54)
    {
      id v55 = (char *)sub_10024E33C((uint64_t)&v162, v54);
      __int128 v40 = (char *)*((void *)&buf + 1);
      __int16 v50 = (char *)buf;
    }

    else
    {
      id v55 = 0LL;
    }

    unsigned int v56 = &v55[4 * v51];
    id v18 = &v55[4 * v54];
    *(_DWORD *)unsigned int v56 = 4;
    BOOL v49 = v56 + 4;
    while (v40 != v50)
    {
      int v57 = *((_DWORD *)v40 - 1);
      v40 -= 4;
      *((_DWORD *)v56 - 1) = v57;
      v56 -= 4;
    }

    *(void *)&__int128 buf = v56;
    *((void *)&buf + 1) = v49;
    BOOL v162 = v18;
    if (v50)
    {
      operator delete(v50);
      id v18 = v162;
    }
  }

  else
  {
    *(_DWORD *)__int128 v40 = 4;
    BOOL v49 = v40 + 4;
  }

  *((void *)&buf + 1) = v49;
  if (v49 >= v18)
  {
    __int16 v59 = (char *)buf;
    uint64_t v60 = (uint64_t)&v49[-buf] >> 2;
    unint64_t v61 = v60 + 1;
    uint64_t v62 = (uint64_t)&v18[-buf];
    if (v62 >> 1 > v61) {
      unint64_t v61 = v62 >> 1;
    }
    else {
      unint64_t v63 = v61;
    }
    if (v63)
    {
      char v64 = (char *)sub_10024E33C((uint64_t)&v162, v63);
      BOOL v49 = (char *)*((void *)&buf + 1);
      __int16 v59 = (char *)buf;
    }

    else
    {
      char v64 = 0LL;
    }

    id v65 = &v64[4 * v60];
    id v18 = &v64[4 * v63];
    *(_DWORD *)id v65 = 12;
    char v58 = v65 + 4;
    while (v49 != v59)
    {
      int v66 = *((_DWORD *)v49 - 1);
      v49 -= 4;
      *((_DWORD *)v65 - 1) = v66;
      v65 -= 4;
    }

    *(void *)&__int128 buf = v65;
    *((void *)&buf + 1) = v58;
    BOOL v162 = v18;
    if (v59)
    {
      operator delete(v59);
      id v18 = v162;
    }
  }

  else
  {
    *(_DWORD *)BOOL v49 = 12;
    char v58 = v49 + 4;
  }

  *((void *)&buf + 1) = v58;
  if (v58 >= v18)
  {
    __int128 v68 = (char *)buf;
    uint64_t v69 = (uint64_t)&v58[-buf] >> 2;
    unint64_t v70 = v69 + 1;
    uint64_t v71 = (uint64_t)&v18[-buf];
    if (v71 >> 1 > v70) {
      unint64_t v70 = v71 >> 1;
    }
    else {
      unint64_t v72 = v70;
    }
    if (v72)
    {
      uint64_t v73 = (char *)sub_10024E33C((uint64_t)&v162, v72);
      char v58 = (char *)*((void *)&buf + 1);
      __int128 v68 = (char *)buf;
    }

    else
    {
      uint64_t v73 = 0LL;
    }

    char v74 = &v73[4 * v69];
    id v18 = &v73[4 * v72];
    *(_DWORD *)char v74 = 15;
    __int128 v67 = v74 + 4;
    while (v58 != v68)
    {
      int v75 = *((_DWORD *)v58 - 1);
      v58 -= 4;
      *((_DWORD *)v74 - 1) = v75;
      v74 -= 4;
    }

    *(void *)&__int128 buf = v74;
    *((void *)&buf + 1) = v67;
    BOOL v162 = v18;
    if (v68)
    {
      operator delete(v68);
      id v18 = v162;
    }
  }

  else
  {
    *(_DWORD *)char v58 = 15;
    __int128 v67 = v58 + 4;
  }

  *((void *)&buf + 1) = v67;
  if (v67 >= v18)
  {
    id v77 = (char *)buf;
    uint64_t v78 = (uint64_t)&v67[-buf] >> 2;
    unint64_t v79 = v78 + 1;
    uint64_t v80 = (uint64_t)&v18[-buf];
    if (v80 >> 1 > v79) {
      unint64_t v79 = v80 >> 1;
    }
    else {
      unint64_t v81 = v79;
    }
    if (v81)
    {
      uint64_t v82 = (char *)sub_10024E33C((uint64_t)&v162, v81);
      __int128 v67 = (char *)*((void *)&buf + 1);
      id v77 = (char *)buf;
    }

    else
    {
      uint64_t v82 = 0LL;
    }

    uint64_t v83 = &v82[4 * v78];
    id v18 = &v82[4 * v81];
    *(_DWORD *)uint64_t v83 = 5;
    id v76 = v83 + 4;
    while (v67 != v77)
    {
      int v84 = *((_DWORD *)v67 - 1);
      v67 -= 4;
      *((_DWORD *)v83 - 1) = v84;
      v83 -= 4;
    }

    *(void *)&__int128 buf = v83;
    *((void *)&buf + 1) = v76;
    BOOL v162 = v18;
    if (v77)
    {
      operator delete(v77);
      id v18 = v162;
    }
  }

  else
  {
    *(_DWORD *)__int128 v67 = 5;
    id v76 = v67 + 4;
  }

  *((void *)&buf + 1) = v76;
  if (v76 >= v18)
  {
    BOOL v86 = (char *)buf;
    uint64_t v87 = (uint64_t)&v76[-buf] >> 2;
    unint64_t v88 = v87 + 1;
    uint64_t v89 = (uint64_t)&v18[-buf];
    if (v89 >> 1 > v88) {
      unint64_t v88 = v89 >> 1;
    }
    else {
      unint64_t v90 = v88;
    }
    if (v90)
    {
      id v91 = (char *)sub_10024E33C((uint64_t)&v162, v90);
      id v76 = (char *)*((void *)&buf + 1);
      BOOL v86 = (char *)buf;
    }

    else
    {
      id v91 = 0LL;
    }

    int v92 = &v91[4 * v87];
    id v18 = &v91[4 * v90];
    *(_DWORD *)int v92 = 6;
    uint64_t v85 = v92 + 4;
    while (v76 != v86)
    {
      int v93 = *((_DWORD *)v76 - 1);
      v76 -= 4;
      *((_DWORD *)v92 - 1) = v93;
      v92 -= 4;
    }

    *(void *)&__int128 buf = v92;
    *((void *)&buf + 1) = v85;
    BOOL v162 = v18;
    if (v86)
    {
      operator delete(v86);
      id v18 = v162;
    }
  }

  else
  {
    *(_DWORD *)id v76 = 6;
    uint64_t v85 = v76 + 4;
  }

  *((void *)&buf + 1) = v85;
  if (v85 >= v18)
  {
    BOOL v95 = (char *)buf;
    uint64_t v96 = (uint64_t)&v85[-buf] >> 2;
    unint64_t v97 = v96 + 1;
    uint64_t v98 = (uint64_t)&v18[-buf];
    if (v98 >> 1 > v97) {
      unint64_t v97 = v98 >> 1;
    }
    else {
      unint64_t v99 = v97;
    }
    if (v99)
    {
      uint64_t v100 = (char *)sub_10024E33C((uint64_t)&v162, v99);
      uint64_t v85 = (char *)*((void *)&buf + 1);
      BOOL v95 = (char *)buf;
    }

    else
    {
      uint64_t v100 = 0LL;
    }

    uint64_t v101 = &v100[4 * v96];
    id v18 = &v100[4 * v99];
    *(_DWORD *)uint64_t v101 = 7;
    char v94 = v101 + 4;
    while (v85 != v95)
    {
      int v102 = *((_DWORD *)v85 - 1);
      v85 -= 4;
      *((_DWORD *)v101 - 1) = v102;
      v101 -= 4;
    }

    *(void *)&__int128 buf = v101;
    *((void *)&buf + 1) = v94;
    BOOL v162 = v18;
    if (v95)
    {
      operator delete(v95);
      id v18 = v162;
    }
  }

  else
  {
    *(_DWORD *)uint64_t v85 = 7;
    char v94 = v85 + 4;
  }

  *((void *)&buf + 1) = v94;
  if (v94 >= v18)
  {
    id v104 = (char *)buf;
    uint64_t v105 = (uint64_t)&v94[-buf] >> 2;
    unint64_t v106 = v105 + 1;
    uint64_t v107 = (uint64_t)&v18[-buf];
    if (v107 >> 1 > v106) {
      unint64_t v106 = v107 >> 1;
    }
    else {
      unint64_t v108 = v106;
    }
    if (v108)
    {
      int v109 = (char *)sub_10024E33C((uint64_t)&v162, v108);
      char v94 = (char *)*((void *)&buf + 1);
      id v104 = (char *)buf;
    }

    else
    {
      int v109 = 0LL;
    }

    id v110 = &v109[4 * v105];
    id v18 = &v109[4 * v108];
    *(_DWORD *)id v110 = 8;
    int v103 = v110 + 4;
    while (v94 != v104)
    {
      int v111 = *((_DWORD *)v94 - 1);
      v94 -= 4;
      *((_DWORD *)v110 - 1) = v111;
      v110 -= 4;
    }

    *(void *)&__int128 buf = v110;
    *((void *)&buf + 1) = v103;
    BOOL v162 = v18;
    if (v104)
    {
      operator delete(v104);
      id v18 = v162;
    }
  }

  else
  {
    *(_DWORD *)char v94 = 8;
    int v103 = v94 + 4;
  }

  *((void *)&buf + 1) = v103;
  if (v103 >= v18)
  {
    id v113 = (char *)buf;
    uint64_t v114 = (uint64_t)&v103[-buf] >> 2;
    unint64_t v115 = v114 + 1;
    uint64_t v116 = (uint64_t)&v18[-buf];
    if (v116 >> 1 > v115) {
      unint64_t v115 = v116 >> 1;
    }
    else {
      unint64_t v117 = v115;
    }
    if (v117)
    {
      uint64_t v118 = (char *)sub_10024E33C((uint64_t)&v162, v117);
      int v103 = (char *)*((void *)&buf + 1);
      id v113 = (char *)buf;
    }

    else
    {
      uint64_t v118 = 0LL;
    }

    uint64_t v119 = &v118[4 * v114];
    id v18 = &v118[4 * v117];
    *(_DWORD *)uint64_t v119 = 9;
    id v112 = v119 + 4;
    while (v103 != v113)
    {
      int v120 = *((_DWORD *)v103 - 1);
      v103 -= 4;
      *((_DWORD *)v119 - 1) = v120;
      v119 -= 4;
    }

    *(void *)&__int128 buf = v119;
    *((void *)&buf + 1) = v112;
    BOOL v162 = v18;
    if (v113)
    {
      operator delete(v113);
      id v18 = v162;
    }
  }

  else
  {
    *(_DWORD *)int v103 = 9;
    id v112 = v103 + 4;
  }

  *((void *)&buf + 1) = v112;
  if (v112 >= v18)
  {
    __int128 v122 = (char *)buf;
    uint64_t v123 = (uint64_t)&v112[-buf] >> 2;
    unint64_t v124 = v123 + 1;
    uint64_t v125 = (uint64_t)&v18[-buf];
    if (v125 >> 1 > v124) {
      unint64_t v124 = v125 >> 1;
    }
    else {
      unint64_t v126 = v124;
    }
    if (v126)
    {
      __int128 v127 = (char *)sub_10024E33C((uint64_t)&v162, v126);
      id v112 = (char *)*((void *)&buf + 1);
      __int128 v122 = (char *)buf;
    }

    else
    {
      __int128 v127 = 0LL;
    }

    id v128 = &v127[4 * v123];
    id v18 = &v127[4 * v126];
    *(_DWORD *)id v128 = 13;
    __int128 v121 = v128 + 4;
    while (v112 != v122)
    {
      int v129 = *((_DWORD *)v112 - 1);
      v112 -= 4;
      *((_DWORD *)v128 - 1) = v129;
      v128 -= 4;
    }

    *(void *)&__int128 buf = v128;
    *((void *)&buf + 1) = v121;
    BOOL v162 = v18;
    if (v122)
    {
      operator delete(v122);
      id v18 = v162;
    }
  }

  else
  {
    *(_DWORD *)id v112 = 13;
    __int128 v121 = v112 + 4;
  }

  *((void *)&buf + 1) = v121;
  if (v121 >= v18)
  {
    BOOL v131 = (char *)buf;
    uint64_t v132 = (uint64_t)&v121[-buf] >> 2;
    unint64_t v133 = v132 + 1;
    uint64_t v134 = (uint64_t)&v18[-buf];
    if (v134 >> 1 > v133) {
      unint64_t v133 = v134 >> 1;
    }
    else {
      unint64_t v135 = v133;
    }
    if (v135)
    {
      int v136 = (char *)sub_10024E33C((uint64_t)&v162, v135);
      __int128 v121 = (char *)*((void *)&buf + 1);
      BOOL v131 = (char *)buf;
    }

    else
    {
      int v136 = 0LL;
    }

    id v137 = &v136[4 * v132];
    id v18 = &v136[4 * v135];
    *(_DWORD *)id v137 = 14;
    char v130 = v137 + 4;
    while (v121 != v131)
    {
      int v138 = *((_DWORD *)v121 - 1);
      v121 -= 4;
      *((_DWORD *)v137 - 1) = v138;
      v137 -= 4;
    }

    *(void *)&__int128 buf = v137;
    *((void *)&buf + 1) = v130;
    BOOL v162 = v18;
    if (v131)
    {
      operator delete(v131);
      id v18 = v162;
    }
  }

  else
  {
    *(_DWORD *)__int128 v121 = 14;
    char v130 = v121 + 4;
  }

  *((void *)&buf + 1) = v130;
  if (v130 >= v18)
  {
    std::string::size_type v140 = (char *)buf;
    uint64_t v141 = (uint64_t)&v130[-buf] >> 2;
    unint64_t v142 = v141 + 1;
    uint64_t v143 = (uint64_t)&v18[-buf];
    if (v143 >> 1 > v142) {
      unint64_t v142 = v143 >> 1;
    }
    else {
      unint64_t v144 = v142;
    }
    if (v144)
    {
      unsigned int v145 = (char *)sub_10024E33C((uint64_t)&v162, v144);
      char v130 = (char *)*((void *)&buf + 1);
      std::string::size_type v140 = (char *)buf;
    }

    else
    {
      unsigned int v145 = 0LL;
    }

    unsigned int v146 = &v145[4 * v141];
    id v147 = &v145[4 * v144];
    *(_DWORD *)unsigned int v146 = 16;
    int v139 = v146 + 4;
    while (v130 != v140)
    {
      int v148 = *((_DWORD *)v130 - 1);
      v130 -= 4;
      *((_DWORD *)v146 - 1) = v148;
      v146 -= 4;
    }

    *(void *)&__int128 buf = v146;
    *((void *)&buf + 1) = v139;
    BOOL v162 = v147;
    if (v140) {
      operator delete(v140);
    }
  }

  else
  {
    *(_DWORD *)char v130 = 16;
    int v139 = v130 + 4;
  }

  *((void *)&buf + 1) = v139;
  v156[0] = &off_10089A548;
  v156[1] = v6;
  sub_1002CD1E0((uint64_t)v6);
  sub_100627958(a1, a2, (uint64_t)v156, (unsigned int **)&buf, 0);
  sub_1002CD254(v6);
  uint64_t v149 = sub_1001BCDB0(a2);
  int v153 = v149;
  char v155 = BYTE6(v149);
  __int16 v154 = WORD2(v149);
  sub_10056AB04(&v151, &v153, 7uLL);
  sub_10032B1F8((uint64_t)v6, 11, (uint64_t)&v151);
  uint64_t v151 = &off_10087FAA8;
  if (v152) {
    sub_1002CD254(v152);
  }
  if ((void)buf)
  {
    *((void *)&buf + 1) = buf;
    operator delete((void *)buf);
  }

  return sub_100242FAC((uint64_t)v160);
}

void sub_10061D6E8( _Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, void *a16, uint64_t a17, int a18, __int16 a19, char a20, char a21, char a22, uint64_t a23, void *__p, uint64_t a25)
{
  *unint64_t v25 = v27;
  sub_1002CD254(v26);
  sub_100242FAC((uint64_t)&a22);
  _Unwind_Resume(a1);
}

void sub_10061D7E4()
{
}

uint64_t sub_10061D7EC(uint64_t a1, uint64_t a2, _WORD *a3)
{
  v12[0] = 0LL;
  v12[1] = 0LL;
  sub_100242F28((uint64_t)v12, a1 + 48);
  uint64_t v5 = *(void *)(a2 + 8);
  if (!a3 || !v5)
  {
    BOOL v6 = (os_log_s *)qword_1008F75A8;
    if (os_log_type_enabled((os_log_t)qword_1008F75A8, OS_LOG_TYPE_FAULT))
    {
      *(_WORD *)__int128 buf = 0;
      _os_log_fault_impl( (void *)&_mh_execute_header,  v6,  OS_LOG_TYPE_FAULT,  "Invalid params dict and keys should always be valid",  buf,  2u);
      uint64_t v5 = *(void *)(a2 + 8);
    }
  }

  *(void *)__int128 buf = 0LL;
  BOOL v11 = 0LL;
  sub_10032BA60(v5, 6, buf);
  if (!sub_10056AAC8((uint64_t)buf))
  {
    sub_10056AB74((uint64_t)buf, a3 + 22, 1uLL);
    sub_10032BA60(*(void *)(a2 + 8), 7, &v8);
    sub_10002EAC8((uint64_t)buf, (uint64_t)&v8);
    id v8 = &off_10087FAA8;
    if (v9) {
      sub_1002CD254(v9);
    }
    if (!sub_10056AAC8((uint64_t)buf))
    {
      sub_10056AB74((uint64_t)buf, (char *)a3 + 45, 1uLL);
      sub_10032BA60(*(void *)(a2 + 8), 5, &v8);
      sub_10002EAC8((uint64_t)buf, (uint64_t)&v8);
      id v8 = &off_10087FAA8;
      if (v9) {
        sub_1002CD254(v9);
      }
    }

    a3[40] |= 8u;
  }

  sub_10032BA60(*(void *)(a2 + 8), 8, &v8);
  sub_10002EAC8((uint64_t)buf, (uint64_t)&v8);
  id v8 = &off_10087FAA8;
  if (v9) {
    sub_1002CD254(v9);
  }
  if (!sub_10056AAC8((uint64_t)buf))
  {
    sub_10056AB74((uint64_t)buf, a3 + 23, 2uLL);
    a3[40] |= 0x10u;
  }

  sub_10032BA60(*(void *)(a2 + 8), 9, &v8);
  sub_10002EAC8((uint64_t)buf, (uint64_t)&v8);
  id v8 = &off_10087FAA8;
  if (v9) {
    sub_1002CD254(v9);
  }
  if (!sub_10056AAC8((uint64_t)buf))
  {
    sub_10056AB74((uint64_t)buf, a3 + 24, 8uLL);
    a3[40] |= 0x20u;
  }

  sub_10032BA60(*(void *)(a2 + 8), 0, &v8);
  sub_10002EAC8((uint64_t)buf, (uint64_t)&v8);
  id v8 = &off_10087FAA8;
  if (v9) {
    sub_1002CD254(v9);
  }
  if (!sub_10056AAC8((uint64_t)buf))
  {
    sub_10056AB74((uint64_t)buf, a3, 0x10uLL);
    sub_10032BA60(*(void *)(a2 + 8), 1, &v8);
    sub_10002EAC8((uint64_t)buf, (uint64_t)&v8);
    id v8 = &off_10087FAA8;
    if (v9) {
      sub_1002CD254(v9);
    }
    sub_10032BA60(*(void *)(a2 + 8), 2, &v8);
    sub_10002EAC8((uint64_t)buf, (uint64_t)&v8);
    id v8 = &off_10087FAA8;
    if (v9) {
      sub_1002CD254(v9);
    }
    a3[40] |= 1u;
  }

  sub_10032BA60(*(void *)(a2 + 8), 3, &v8);
  sub_10002EAC8((uint64_t)buf, (uint64_t)&v8);
  id v8 = &off_10087FAA8;
  if (v9) {
    sub_1002CD254(v9);
  }
  if (!sub_10056AAC8((uint64_t)buf))
  {
    sub_10056AB74((uint64_t)buf, a3 + 9, 2uLL);
    a3[40] |= 2u;
  }

  sub_10032BA60(*(void *)(a2 + 8), 4, &v8);
  sub_10002EAC8((uint64_t)buf, (uint64_t)&v8);
  id v8 = &off_10087FAA8;
  if (v9) {
    sub_1002CD254(v9);
  }
  if (!sub_10056AAC8((uint64_t)buf))
  {
    sub_10056AB74((uint64_t)buf, a3 + 10, 8uLL);
    a3[40] |= 4u;
  }

  sub_10032BA60(*(void *)(a2 + 8), 10, &v8);
  sub_10002EAC8((uint64_t)buf, (uint64_t)&v8);
  id v8 = &off_10087FAA8;
  if (v9) {
    sub_1002CD254(v9);
  }
  if (!sub_10056AAC8((uint64_t)buf))
  {
    sub_10056AB74((uint64_t)buf, a3 + 28, 0x10uLL);
    a3[40] |= 0x40u;
  }

  sub_10032BA60(*(void *)(a2 + 8), 11, &v8);
  sub_10002EAC8((uint64_t)buf, (uint64_t)&v8);
  id v8 = &off_10087FAA8;
  if (v9) {
    sub_1002CD254(v9);
  }
  if (!sub_10056AAC8((uint64_t)buf))
  {
    sub_10056AB74((uint64_t)buf, a3 + 36, 7uLL);
    a3[40] |= 0x80u;
  }

  sub_10032BA60(*(void *)(a2 + 8), 16, &v8);
  sub_10002EAC8((uint64_t)buf, (uint64_t)&v8);
  id v8 = &off_10087FAA8;
  if (v9) {
    sub_1002CD254(v9);
  }
  if (!sub_10056AAC8((uint64_t)buf))
  {
    sub_10056AB74((uint64_t)buf, (char *)a3 + 79, 1uLL);
    a3[40] |= 0x100u;
  }

  *(void *)__int128 buf = &off_10087FAA8;
  if (v11) {
    sub_1002CD254(v11);
  }
  return sub_100242FAC((uint64_t)v12);
}

void sub_10061DCA8(_Unwind_Exception *a1, uint64_t a2, unsigned int *a3, uint64_t a4, unsigned int *a5, ...)
{
  if (a3) {
    sub_1002CD254(a3);
  }
  if (a5) {
    sub_1002CD254(a5);
  }
  sub_100242FAC((uint64_t)va);
  _Unwind_Resume(a1);
}

void sub_10061DD60(uint64_t a1)
{
  uint64_t v2 = sub_1002E6BF0();
  if ((*(unsigned int (**)(uint64_t))(*(void *)v2 + 432LL))(v2))
  {
    if (os_log_type_enabled((os_log_t)qword_1008F75A8, OS_LOG_TYPE_ERROR)) {
      sub_10069E9C8();
    }
  }

  else
  {
    BOOL v3 = (void *)objc_claimAutoreleasedReturnValue(+[NSMutableSet set](&OBJC_CLASS___NSMutableSet, "set"));
    if (*(void *)(a1 + 456))
    {
      BOOL v4 = *(const unsigned __int8 **)(a1 + 440);
      if (v4 != (const unsigned __int8 *)(a1 + 448))
      {
        do
        {
          uint64_t v5 = sub_100241F94(v4 + 32);
          BOOL v6 = (void *)objc_claimAutoreleasedReturnValue(v5);
          [v3 addObject:v6];

          BOOL v7 = (unsigned __int8 *)*((void *)v4 + 1);
          if (v7)
          {
            do
            {
              id v8 = (const unsigned __int8 **)v7;
              BOOL v7 = *(unsigned __int8 **)v7;
            }

            while (v7);
          }

          else
          {
            do
            {
              id v8 = (const unsigned __int8 **)*((void *)v4 + 2);
              BOOL v9 = *v8 == v4;
              BOOL v4 = (const unsigned __int8 *)v8;
            }

            while (!v9);
          }

          BOOL v4 = (const unsigned __int8 *)v8;
        }

        while (v8 != (const unsigned __int8 **)(a1 + 448));
      }
    }

    sub_10061BADC(a1);
    if (*(_BYTE *)(a1 + 41))
    {
      BOOL v10 = *(const unsigned __int8 **)(a1 + 440);
      if (v10 != (const unsigned __int8 *)(a1 + 448))
      {
        do
        {
          BOOL v11 = sub_100241F94(v10 + 32);
          id v12 = (void *)objc_claimAutoreleasedReturnValue(v11);
          unsigned __int8 v13 = [v3 containsObject:v12];

          int v32 = 0LL;
          uint64_t v33 = 0LL;
          sub_10032BA60(*((void *)v10 + 7), 10, &v32);
          if (!sub_10056AAC8((uint64_t)&v32))
          {
            uint64_t v14 = sub_100241F94(v10 + 32);
            id v15 = (void *)objc_claimAutoreleasedReturnValue(v14);
            char v16 = sub_10061C0F8(a1, v15) | v13;

            if ((v16 & 1) == 0)
            {
              uint64_t v17 = sub_1002E6E9C();
              if (qword_1008D5F30 != -1) {
                dispatch_once(&qword_1008D5F30, &stru_1008A45D8);
              }
              id v18 = off_1008D5F28;
              BOOL v19 = sub_100241F94(v10 + 32);
              BOOL v20 = (void *)objc_claimAutoreleasedReturnValue(v19);
              uint64_t v21 = sub_1005CC198((uint64_t)v18, v20, 0);
              uint64_t v22 = sub_10056AAF0((uint64_t)&v32);
              int v23 = (*(uint64_t (**)(uint64_t, uint64_t, uint64_t, uint64_t))(*(void *)v17 + 360LL))( v17,  v21,  v22,  1LL);

              uint64_t v24 = sub_100241F94(v10 + 32);
              unint64_t v25 = (void *)objc_claimAutoreleasedReturnValue(v24);
              sub_10061E0B4((uint64_t)v25, v25, v23);

              sub_10032BA60(*((void *)v10 + 7), 11, &v30);
              uint64_t v26 = (int *)sub_10056AAF0((uint64_t)&v30);
              uint64_t v27 = (_OWORD *)sub_10056AAF0((uint64_t)&v32);
              sub_10061E118(a1, v26, v27);
              int v30 = &off_10087FAA8;
              if (v31) {
                sub_1002CD254(v31);
              }
            }
          }

          int v32 = &off_10087FAA8;
          if (v33) {
            sub_1002CD254(v33);
          }
          id v28 = (unsigned __int8 *)*((void *)v10 + 1);
          if (v28)
          {
            do
            {
              uint64_t v29 = (const unsigned __int8 **)v28;
              id v28 = *(unsigned __int8 **)v28;
            }

            while (v28);
          }

          else
          {
            do
            {
              uint64_t v29 = (const unsigned __int8 **)*((void *)v10 + 2);
              BOOL v9 = *v29 == v10;
              BOOL v10 = (const unsigned __int8 *)v29;
            }

            while (!v9);
          }

          BOOL v10 = (const unsigned __int8 *)v29;
        }

        while (v29 != (const unsigned __int8 **)(a1 + 448));
      }
    }
  }

void sub_10061E038(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_10061E0B4(uint64_t a1, void *a2, int a3)
{
  id v4 = a2;
  if (a3 && os_log_type_enabled((os_log_t)qword_1008F75A8, OS_LOG_TYPE_ERROR)) {
    sub_10069EB40();
  }
}

BOOL sub_10061E118(uint64_t a1, int *a2, _OWORD *a3)
{
  unint64_t v6 = ((unint64_t)*((unsigned __int8 *)a2 + 1) << 40) | ((unint64_t)*((unsigned __int8 *)a2 + 2) << 32) | ((unint64_t)*((unsigned __int8 *)a2 + 3) << 24) | ((unint64_t)*((unsigned __int8 *)a2 + 4) << 16) | ((unint64_t)*((unsigned __int8 *)a2 + 5) << 8) | *((unsigned __int8 *)a2 + 6) | ((unint64_t)*(unsigned __int8 *)a2 << 48);
  if (qword_1008D5F30 != -1) {
    dispatch_once(&qword_1008D5F30, &stru_1008A45D8);
  }
  *(void *)uuid_t uu = 0LL;
  uint64_t v27 = 0LL;
  sub_1005C8684((uint64_t)off_1008D5F28, v6, 0, 1u, 0LL, 0LL, uu);
  BOOL v7 = (os_log_s *)qword_1008F75A8;
  if (os_log_type_enabled((os_log_t)qword_1008F75A8, OS_LOG_TYPE_DEFAULT))
  {
    id v8 = &v20;
    sub_1005BFC20(v6, &v20);
    if ((v20.__r_.__value_.__s.__size_ & 0x80u) != 0) {
      id v8 = (std::stringbuf::string_type *)v20.__r_.__value_.__r.__words[0];
    }
    if (uuid_is_null(uu))
    {
      *(_DWORD *)__int128 buf = 136446466;
      int v23 = v8;
      __int16 v24 = 2082;
      unint64_t v25 = "NONE";
      _os_log_impl( (void *)&_mh_execute_header,  v7,  OS_LOG_TYPE_DEFAULT,  "Adding %{public}s (%{public}s) to the cache.",  buf,  0x16u);
    }

    else
    {
      memset(out, 0, 37);
      uuid_unparse_upper(uu, out);
      sub_10002418C(__p, out);
      if (v19 >= 0) {
        BOOL v9 = __p;
      }
      else {
        BOOL v9 = (void **)__p[0];
      }
      *(_DWORD *)__int128 buf = 136446466;
      int v23 = v8;
      __int16 v24 = 2082;
      unint64_t v25 = (const char *)v9;
      _os_log_impl( (void *)&_mh_execute_header,  v7,  OS_LOG_TYPE_DEFAULT,  "Adding %{public}s (%{public}s) to the cache.",  buf,  0x16u);
      if (v19 < 0) {
        operator delete(__p[0]);
      }
    }
  }

  if (uuid_is_null(uu))
  {
    int v10 = 0;
  }

  else
  {
    BOOL v11 = sub_100241F94(uu);
    id v12 = (void *)objc_claimAutoreleasedReturnValue(v11);
    BOOL v13 = sub_10061C0F8(a1, v12);

    int v10 = !v13;
  }

  LOBYTE(__p[0]) = 0;
  sub_100242CA4(__p);
  int v14 = sub_1001C9948(a2, a3, v10);
  sub_100242CD0(__p);
  id v15 = (os_log_s *)qword_1008F75A8;
  if (os_log_type_enabled((os_log_t)qword_1008F75A8, OS_LOG_TYPE_DEFAULT))
  {
    sub_1005BFC20(v6, &v20);
    if ((v20.__r_.__value_.__s.__size_ & 0x80u) == 0) {
      char v16 = &v20;
    }
    else {
      char v16 = (std::stringbuf::string_type *)v20.__r_.__value_.__r.__words[0];
    }
    *(_DWORD *)uuid_string_t out = 136447235;
    *(void *)&out[4] = v16;
    *(_WORD *)&out[12] = 1041;
    *(_DWORD *)&out[14] = 16;
    *(_WORD *)&out[18] = 2097;
    *(void *)&out[20] = a3;
    *(_WORD *)&out[28] = 1024;
    *(_DWORD *)&out[30] = v10;
    *(_WORD *)&out[34] = 1024;
    *(_DWORD *)&out[36] = v14;
    _os_log_impl( (void *)&_mh_execute_header,  v15,  OS_LOG_TYPE_DEFAULT,  "Added %{public}s to the cache (irk=%{private}.16P, okToRePair=%d) status=%d",  out,  0x28u);
  }

  sub_100242CD8(__p);
  return v14 == 0;
}

void sub_10061E45C( _Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, void *__p, uint64_t a13, int a14, __int16 a15, char a16, char a17)
{
  _Unwind_Resume(a1);
}

uint64_t sub_10061E4A4(uint64_t a1)
{
  if (qword_1008D5F30 != -1) {
    dispatch_once(&qword_1008D5F30, &stru_1008A45D8);
  }
  int v2 = *((_DWORD *)off_1008D5F28 + 36);
  unsigned int v3 = *(unsigned __int16 *)(a1 + 3736);
  if (v3 < (unsigned __int16)v2)
  {
    LOWORD(v3) = v2 - 25;
    *(_WORD *)(a1 + 3736) = v2 - 25;
  }

  id v4 = (os_log_s *)qword_1008F75A8;
  if (os_log_type_enabled((os_log_t)qword_1008F75A8, OS_LOG_TYPE_DEFAULT))
  {
    *(_DWORD *)__int128 buf = 67109120;
    *(_DWORD *)&uint8_t buf[4] = (unsigned __int16)v3;
    _os_log_impl((void *)&_mh_execute_header, v4, OS_LOG_TYPE_DEFAULT, "We can have up to %d paired devices", buf, 8u);
  }

  uint64_t v5 = sub_100619F1C(a1);
  if ((_DWORD)v5)
  {
    sub_10061A988();
    uint64_t v19 = sub_1002E6E00();
    sub_10002418C(v27, "");
    sub_1004FB370(v19, v5, (uint64_t)v27, 1);
  }

  v26[0] = 0LL;
  v26[1] = 0LL;
  sub_100242F28((uint64_t)v26, a1 + 48);
  sub_10061AEE0(a1);
  sub_10061BADC(a1);
  uint64_t v6 = sub_1002E6BF0();
  int v7 = (*(uint64_t (**)(uint64_t))(*(void *)v6 + 440LL))(v6);
  *(_BYTE *)(a1 + 3717) = v7;
  sub_1001853D0(v7 ^ 1u);
  if (*(_BYTE *)(a1 + 3717)) {
    sub_1001D46D8();
  }
  out_tokeuint64_t n = 0;
  id v8 = *(dispatch_queue_s **)(sub_100404FE8() + 8);
  handler[0] = _NSConcreteStackBlock;
  handler[1] = 3221225472LL;
  handler[2] = sub_10061E8BC;
  handler[3] = &unk_10088E280;
  handler[4] = a1;
  uint32_t v9 = notify_register_dispatch("com.apple.mobile.keybagd.first_unlock", &out_token, v8, handler);
  int v10 = (os_log_s *)qword_1008F75A8;
  if (v9)
  {
    if (os_log_type_enabled((os_log_t)qword_1008F75A8, OS_LOG_TYPE_ERROR)) {
      sub_10069EBA0();
    }
  }

  else if (os_log_type_enabled((os_log_t)qword_1008F75A8, OS_LOG_TYPE_DEFAULT))
  {
    *(_WORD *)__int128 buf = 0;
    _os_log_impl( (void *)&_mh_execute_header,  v10,  OS_LOG_TYPE_DEFAULT,  "Successfully registered for MKB first unlock notification",  buf,  2u);
  }

  BOOL v11 = *(dispatch_queue_s **)(sub_100404FE8() + 8);
  v23[0] = _NSConcreteStackBlock;
  v23[1] = 3221225472LL;
  void v23[2] = sub_10061E9F8;
  void v23[3] = &unk_10088E280;
  _OWORD v23[4] = a1;
  notify_register_dispatch("com.apple.purplebuddy.setupdone", &out_token, v11, v23);
  char v22 = 0;
  uint64_t v12 = sub_1002E6E00();
  sub_10002418C(buf, "CT");
  sub_10002418C(__p, "UseCTPrefixForCTCrypto");
  int v13 = (*(uint64_t (**)(uint64_t, uint8_t *, void **, char *))(*(void *)v12 + 72LL))(v12, buf, __p, &v22);
  if (v22) {
    int v14 = v13;
  }
  else {
    int v14 = 0;
  }
  if (v21 < 0) {
    operator delete(__p[0]);
  }
  if (v29 < 0)
  {
    operator delete(*(void **)buf);
    if (!v14) {
      goto LABEL_27;
    }
  }

  else if (!v14)
  {
    goto LABEL_27;
  }

  id v15 = (os_log_s *)qword_1008F75A8;
  if (os_log_type_enabled((os_log_t)qword_1008F75A8, OS_LOG_TYPE_DEFAULT))
  {
    *(_WORD *)__int128 buf = 0;
    _os_log_impl( (void *)&_mh_execute_header,  v15,  OS_LOG_TYPE_DEFAULT,  "Warning: using the CT- prefix instead of EN- prefix for ContactTracing",  buf,  2u);
  }

  *(_BYTE *)(a1 + 40) = 1;
LABEL_27:
  uint64_t v16 = objc_claimAutoreleasedReturnValue(+[NSMutableArray array](&OBJC_CLASS___NSMutableArray, "array"));
  uint64_t v17 = *(void **)(a1 + 3752);
  *(void *)(a1 + 3752) = v16;

  sub_10061EA68(a1);
  if (qword_1008D5F10 != -1) {
    dispatch_once(&qword_1008D5F10, &stru_1008A45F8);
  }
  sub_100594810((uint64_t)off_1008D5F08, a1 + 16, 0);
  return sub_100242FAC((uint64_t)v26);
}

void sub_10061E84C( _Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, void *a9, uint64_t a10, int a11, __int16 a12, char a13, char a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20, uint64_t a21, uint64_t a22, uint64_t a23, uint64_t a24, uint64_t a25, uint64_t a26, char a27, uint64_t a28, void *__p, uint64_t a30, int a31, __int16 a32, char a33, char a34)
{
  if (a34 < 0) {
    operator delete(__p);
  }
  _Unwind_Resume(exception_object);
}

void sub_10061E8BC(uint64_t a1)
{
  uint64_t v1 = *(void *)(a1 + 32);
  int v2 = (os_log_s *)qword_1008F75A8;
  BOOL v3 = os_log_type_enabled((os_log_t)qword_1008F75A8, OS_LOG_TYPE_DEFAULT);
  if (v3)
  {
    v6[0] = 67109120;
    v6[1] = MKBDeviceUnlockedSinceBoot(v3);
    _os_log_impl( (void *)&_mh_execute_header,  v2,  OS_LOG_TYPE_DEFAULT,  "Received MKB first unlock notification. MKBDeviceUnlockedSinceBoot returns : %d",  (uint8_t *)v6,  8u);
  }

  int v4 = MKBDeviceUnlockedSinceBoot(v3);
  uint64_t v5 = (os_log_s *)qword_1008F75A8;
  if (v4 != 1 && os_log_type_enabled((os_log_t)qword_1008F75A8, OS_LOG_TYPE_FAULT))
  {
    LOWORD(v6[0]) = 0;
    _os_log_fault_impl( (void *)&_mh_execute_header,  v5,  OS_LOG_TYPE_FAULT,  "Received MKB first unlock notification, but MKBDeviceUnlockedSinceBoot returns 0",  (uint8_t *)v6,  2u);
    uint64_t v5 = (os_log_s *)qword_1008F75A8;
  }

  if (os_log_type_enabled(v5, OS_LOG_TYPE_DEFAULT))
  {
    LOWORD(v6[0]) = 0;
    _os_log_impl( (void *)&_mh_execute_header,  v5,  OS_LOG_TYPE_DEFAULT,  "Received first unlock notification - loading keychain from synchronized again",  (uint8_t *)v6,  2u);
  }

  sub_10061DD60(v1);
}

void sub_10061E9F8(uint64_t a1)
{
  uint64_t v1 = *(void *)(a1 + 32);
  int v2 = (os_log_s *)qword_1008F75A8;
  if (os_log_type_enabled((os_log_t)qword_1008F75A8, OS_LOG_TYPE_DEFAULT))
  {
    *(_WORD *)BOOL v3 = 0;
    _os_log_impl( (void *)&_mh_execute_header,  v2,  OS_LOG_TYPE_DEFAULT,  "Received setup done - loading keychain from synchrnized again",  v3,  2u);
  }

  sub_10061DD60(v1);
}

void sub_10061EA68(uint64_t a1)
{
  BOOL v11 = 0LL;
  uint64_t v12 = 0LL;
  uint64_t v13 = 0LL;
  int v2 = (void (***)(void, uint64_t **))sub_1002E6C74();
  (**v2)(v2, &v11);
  BOOL v3 = v11;
  if (v11 == v12) {
    goto LABEL_11;
  }
  do
  {
    uint64_t v4 = *v3;
    v18[0] = 0LL;
    v18[1] = 0LL;
    uint64_t v5 = sub_1002E6C74();
    int v6 = (*(uint64_t (**)(uint64_t, uint64_t, uint64_t, void *))(*(void *)v5 + 96LL))(v5, v4, 2LL, v18);
    int v7 = (os_log_s *)qword_1008F75A8;
    if (!os_log_type_enabled((os_log_t)qword_1008F75A8, OS_LOG_TYPE_DEFAULT)) {
      goto LABEL_6;
    }
    sub_1003CF00C(v4, __p);
    id v8 = __p;
    if (v10 < 0) {
      id v8 = (void **)__p[0];
    }
    *(_DWORD *)__int128 buf = 136446466;
    id v15 = v8;
    __int16 v16 = 1024;
    int v17 = v6;
    _os_log_impl( (void *)&_mh_execute_header,  v7,  OS_LOG_TYPE_DEFAULT,  "Read IRK for device %{public}s : result %d",  buf,  0x12u);
    if ((v10 & 0x80000000) == 0)
    {
LABEL_6:
      if (v6) {
        goto LABEL_9;
      }
LABEL_7:
      LOBYTE(__p[0]) = 0;
      *(_DWORD *)((char *)__p + 1) = *(_DWORD *)(v4 + 128);
      *(_WORD *)((char *)__p + 5) = *(_WORD *)(v4 + 132);
      sub_100621334(a1, (unsigned __int8 *)__p, (uint64_t)v18);
      goto LABEL_9;
    }

    operator delete(__p[0]);
    if (!v6) {
      goto LABEL_7;
    }
LABEL_9:
    ++v3;
  }

  while (v3 != v12);
  BOOL v3 = v11;
LABEL_11:
  if (v3)
  {
    uint64_t v12 = v3;
    operator delete(v3);
  }

void sub_10061EC2C( _Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, void *__p, uint64_t a15)
{
  if (__p) {
    operator delete(__p);
  }
  _Unwind_Resume(exception_object);
}

uint64_t sub_10061EC54(uint64_t a1)
{
  uint64_t v2 = sub_1002E6BF0();
  unsigned __int8 v3 = (*(uint64_t (**)(uint64_t))(*(void *)v2 + 80LL))(v2);
  v61[0] = 0LL;
  v61[1] = 0LL;
  sub_100242F28((uint64_t)v61, a1 + 48);
  char v60 = 0;
  sub_100242CA4(&v60);
  if (!sub_1001BEB38()) {
    goto LABEL_125;
  }
  if (sub_1001D33C4( (__int128 *)(a1 + 136),  (__n128 *)(a1 + 184),  (__int128 *)(a1 + 168),  (__int128 *)(a1 + 200),  (__n128 *)(a1 + 224)))
  {
    if (os_log_type_enabled((os_log_t)qword_1008F75A8, OS_LOG_TYPE_ERROR)) {
      sub_10069ED80();
    }
    goto LABEL_125;
  }

  *(_OWORD *)(a1 + 184) = *sub_1001D46D0();
  char v59 = 0;
  uint64_t v4 = sub_1002E6E00();
  sub_10002418C(buf, "LE");
  sub_10002418C(__p, "ForceBoolIOCaps");
  int v5 = (*(uint64_t (**)(uint64_t, uint8_t *, void **, char *))(*(void *)v4 + 72LL))(v4, buf, __p, &v59);
  if (v59) {
    int v6 = v5;
  }
  else {
    int v6 = 0;
  }
  if (v58 < 0) {
    operator delete(__p[0]);
  }
  if (v63 < 0) {
    operator delete(*(void **)buf);
  }
  if (v6)
  {
    int v7 = (os_log_s *)qword_1008F75A8;
    if (os_log_type_enabled((os_log_t)qword_1008F75A8, OS_LOG_TYPE_DEFAULT))
    {
      *(_WORD *)__int128 buf = 0;
      unsigned __int8 v3 = 2;
      _os_log_impl( (void *)&_mh_execute_header,  v7,  OS_LOG_TYPE_DEFAULT,  "Warning: Overriding LE security IO capabilities to YES/NO only - DEPRECATED - please move to modern defaults writes",  buf,  2u);
    }

    else
    {
      unsigned __int8 v3 = 2;
    }
  }

  int v56 = 0;
  uint64_t v8 = sub_1002E6E00();
  sub_10002418C(buf, "LE");
  sub_10002418C(__p, "InputCaps");
  int v9 = (*(uint64_t (**)(uint64_t, uint8_t *, void **, int *))(*(void *)v8 + 88LL))(v8, buf, __p, &v56);
  if (v58 < 0) {
    operator delete(__p[0]);
  }
  if (v63 < 0) {
    operator delete(*(void **)buf);
  }
  if (v9)
  {
    char v10 = (os_log_s *)qword_1008F75A8;
    if (os_log_type_enabled((os_log_t)qword_1008F75A8, OS_LOG_TYPE_DEFAULT))
    {
      *(_DWORD *)__int128 buf = 67109120;
      *(_DWORD *)&uint8_t buf[4] = v56;
      _os_log_impl( (void *)&_mh_execute_header,  v10,  OS_LOG_TYPE_DEFAULT,  "Warning: Using override value (0x%02x) for LE input capabilities",  buf,  8u);
    }

    unsigned __int8 v3 = v56;
  }

  uint64_t v11 = sub_1002E6E00();
  sub_10002418C(buf, "LE");
  sub_10002418C(__p, "OutputCaps");
  int v12 = (*(uint64_t (**)(uint64_t, uint8_t *, void **, int *))(*(void *)v11 + 88LL))(v11, buf, __p, &v56);
  if (v58 < 0) {
    operator delete(__p[0]);
  }
  if (v63 < 0)
  {
    operator delete(*(void **)buf);
    if (v12) {
      goto LABEL_28;
    }
LABEL_32:
    unsigned __int8 v14 = 32;
    goto LABEL_33;
  }

  if (!v12) {
    goto LABEL_32;
  }
LABEL_28:
  uint64_t v13 = (os_log_s *)qword_1008F75A8;
  if (os_log_type_enabled((os_log_t)qword_1008F75A8, OS_LOG_TYPE_DEFAULT))
  {
    *(_DWORD *)__int128 buf = 67109120;
    *(_DWORD *)&uint8_t buf[4] = v56;
    _os_log_impl( (void *)&_mh_execute_header,  v13,  OS_LOG_TYPE_DEFAULT,  "Warning: Using override value (0x%02x) for LE output capabilities",  buf,  8u);
  }

  unsigned __int8 v14 = v56;
LABEL_33:
  char v55 = 0;
  uint64_t v15 = sub_1002E6E00();
  sub_10002418C(buf, "LE");
  sub_10002418C(__p, "DisableSSP");
  int v16 = (*(uint64_t (**)(uint64_t, uint8_t *, void **, char *))(*(void *)v15 + 72LL))(v15, buf, __p, &v55);
  if (v55) {
    int v17 = v16;
  }
  else {
    int v17 = 0;
  }
  if (v58 < 0) {
    operator delete(__p[0]);
  }
  if (v63 < 0) {
    operator delete(*(void **)buf);
  }
  if (v17)
  {
    id v18 = (os_log_s *)qword_1008F75A8;
    if (os_log_type_enabled((os_log_t)qword_1008F75A8, OS_LOG_TYPE_DEFAULT))
    {
      *(_WORD *)__int128 buf = 0;
      _os_log_impl( (void *)&_mh_execute_header,  v18,  OS_LOG_TYPE_DEFAULT,  "Warning: LE secured connections disabled by defaults write",  buf,  2u);
    }
  }

  char v54 = 0;
  uint64_t v19 = sub_1002E6E00();
  sub_10002418C(buf, "LE");
  sub_10002418C(__p, "DisableH7");
  int v20 = (*(uint64_t (**)(uint64_t, uint8_t *, void **, char *))(*(void *)v19 + 72LL))(v19, buf, __p, &v54);
  if (v54) {
    int v21 = v20;
  }
  else {
    int v21 = 0;
  }
  if (v58 < 0) {
    operator delete(__p[0]);
  }
  if (v63 < 0)
  {
    operator delete(*(void **)buf);
    if (!v21) {
      goto LABEL_55;
    }
  }

  else if (!v21)
  {
    goto LABEL_55;
  }

  char v22 = (os_log_s *)qword_1008F75A8;
  if (os_log_type_enabled((os_log_t)qword_1008F75A8, OS_LOG_TYPE_DEFAULT))
  {
    *(_WORD *)__int128 buf = 0;
    _os_log_impl( (void *)&_mh_execute_header,  v22,  OS_LOG_TYPE_DEFAULT,  "Warning: Disabling LE SMP local H7 support!",  buf,  2u);
  }

  sub_1001D46B0();
LABEL_55:
  char v53 = 0;
  uint64_t v23 = sub_1002E6E00();
  sub_10002418C(buf, "LE");
  sub_10002418C(__p, "ForceReplyH7");
  int v24 = (*(uint64_t (**)(uint64_t, uint8_t *, void **, char *))(*(void *)v23 + 72LL))(v23, buf, __p, &v53);
  if (v53) {
    int v25 = v24;
  }
  else {
    int v25 = 0;
  }
  if (v58 < 0) {
    operator delete(__p[0]);
  }
  if (v63 < 0)
  {
    operator delete(*(void **)buf);
    if (!v25) {
      goto LABEL_67;
    }
  }

  else if (!v25)
  {
    goto LABEL_67;
  }

  uint64_t v26 = (os_log_s *)qword_1008F75A8;
  if (os_log_type_enabled((os_log_t)qword_1008F75A8, OS_LOG_TYPE_DEFAULT))
  {
    *(_WORD *)__int128 buf = 0;
    _os_log_impl( (void *)&_mh_execute_header,  v26,  OS_LOG_TYPE_DEFAULT,  "Warning: Forcing LE SMP to reply with H7!",  buf,  2u);
  }

  sub_1001D46C0();
LABEL_67:
  uint64_t v27 = sub_1002E6E00();
  sub_10002418C(buf, "LE");
  sub_10002418C(__p, "OverrideMaxLEPairedDevices");
  int v28 = (*(uint64_t (**)(uint64_t, uint8_t *, void **, int *))(*(void *)v27 + 88LL))(v27, buf, __p, &v56);
  if (v56 > 0) {
    int v29 = v28;
  }
  else {
    int v29 = 0;
  }
  if (v58 < 0) {
    operator delete(__p[0]);
  }
  if (v63 < 0) {
    operator delete(*(void **)buf);
  }
  if (v29)
  {
    int v30 = (os_log_s *)qword_1008F75A8;
    BOOL v31 = os_log_type_enabled((os_log_t)qword_1008F75A8, OS_LOG_TYPE_DEFAULT);
    __int16 v32 = v56;
    if (v31)
    {
      *(_DWORD *)__int128 buf = 67109120;
      *(_DWORD *)&uint8_t buf[4] = v56;
      _os_log_impl( (void *)&_mh_execute_header,  v30,  OS_LOG_TYPE_DEFAULT,  "Warning: Overriding max number of allowed LE Paired devices to %d",  buf,  8u);
      __int16 v32 = v56;
    }

    *(_WORD *)(a1 + 3736) = v32;
  }

  uint64_t v33 = sub_1002E6E00();
  sub_10002418C(buf, "LE");
  sub_10002418C(__p, "OverrideInitiatorKeys");
  int v34 = (*(uint64_t (**)(uint64_t, uint8_t *, void **, int *))(*(void *)v33 + 88LL))(v33, buf, __p, &v56);
  if (v56 > 0) {
    int v35 = v34;
  }
  else {
    int v35 = 0;
  }
  if (v58 < 0) {
    operator delete(__p[0]);
  }
  if (v63 < 0)
  {
    operator delete(*(void **)buf);
    if (!v35) {
      goto LABEL_90;
    }
  }

  else if (!v35)
  {
    goto LABEL_90;
  }

  unint64_t v36 = (os_log_s *)qword_1008F75A8;
  BOOL v37 = os_log_type_enabled((os_log_t)qword_1008F75A8, OS_LOG_TYPE_DEFAULT);
  unsigned __int8 v38 = v56;
  if (v37)
  {
    *(_DWORD *)__int128 buf = 67109120;
    *(_DWORD *)&uint8_t buf[4] = v56;
    _os_log_impl( (void *)&_mh_execute_header,  v36,  OS_LOG_TYPE_DEFAULT,  "Warning: Overriding initiator keys to 0x%0x",  buf,  8u);
    unsigned __int8 v38 = v56;
  }

  sub_1001D4688(v38);
LABEL_90:
  uint64_t v39 = sub_1002E6E00();
  sub_10002418C(buf, "LE");
  sub_10002418C(__p, "OverrideResponderKeys");
  int v40 = (*(uint64_t (**)(uint64_t, uint8_t *, void **, int *))(*(void *)v39 + 88LL))(v39, buf, __p, &v56);
  if (v56 > 0) {
    int v41 = v40;
  }
  else {
    int v41 = 0;
  }
  if (v58 < 0) {
    operator delete(__p[0]);
  }
  if (v63 < 0)
  {
    operator delete(*(void **)buf);
    if (!v41) {
      goto LABEL_102;
    }
  }

  else if (!v41)
  {
    goto LABEL_102;
  }

  uint64_t v42 = (os_log_s *)qword_1008F75A8;
  BOOL v43 = os_log_type_enabled((os_log_t)qword_1008F75A8, OS_LOG_TYPE_DEFAULT);
  unsigned __int8 v44 = v56;
  if (v43)
  {
    *(_DWORD *)__int128 buf = 67109120;
    *(_DWORD *)&uint8_t buf[4] = v56;
    _os_log_impl( (void *)&_mh_execute_header,  v42,  OS_LOG_TYPE_DEFAULT,  "Warning: Overriding responder keys to 0x%0x",  buf,  8u);
    unsigned __int8 v44 = v56;
  }

  sub_1001D4694(v44);
LABEL_102:
  uint64_t v45 = sub_1002E6E00();
  sub_10002418C(buf, "LE");
  sub_10002418C(__p, "OverrideUsePublicAddress");
  int v46 = (*(uint64_t (**)(uint64_t, uint8_t *, void **, int *))(*(void *)v45 + 88LL))(v45, buf, __p, &v56);
  if (v58 < 0) {
    operator delete(__p[0]);
  }
  if (v63 < 0)
  {
    operator delete(*(void **)buf);
    if (!v46) {
      goto LABEL_111;
    }
LABEL_108:
    BOOL v47 = (os_log_s *)qword_1008F75A8;
    if (os_log_type_enabled((os_log_t)qword_1008F75A8, OS_LOG_TYPE_DEFAULT))
    {
      *(_DWORD *)__int128 buf = 67109120;
      *(_DWORD *)&uint8_t buf[4] = v56;
      _os_log_impl( (void *)&_mh_execute_header,  v47,  OS_LOG_TYPE_DEFAULT,  "Warning: Overriding use Public Address to %d",  buf,  8u);
    }

    nullsub_63((_BYTE)v56 != 0, v48);
    goto LABEL_111;
  }

  if (v46) {
    goto LABEL_108;
  }
LABEL_111:
  qword_1008D9C60 = a1;
  if (sub_1001C8324(off_1008D9C48, v3, v14, v55 == 0, 0))
  {
    if (os_log_type_enabled((os_log_t)qword_1008F75A8, OS_LOG_TYPE_ERROR)) {
      sub_10069ED20();
    }
  }

  else
  {
    qword_1008D9C80 = a1;
    sub_1001C864C((uint64_t)off_1008D9C68);
    if (v49)
    {
      if (os_log_type_enabled((os_log_t)qword_1008F75A8, OS_LOG_TYPE_ERROR)) {
        sub_10069ECC0();
      }
    }

    else
    {
      qword_1008D9C98 = a1;
      sub_1001C87BC((__n128 *)off_1008D9C88);
      if (v50)
      {
        if (os_log_type_enabled((os_log_t)qword_1008F75A8, OS_LOG_TYPE_ERROR)) {
          sub_10069EC60();
        }
      }

      else if (sub_1001BD934(1))
      {
        if (os_log_type_enabled((os_log_t)qword_1008F75A8, OS_LOG_TYPE_ERROR)) {
          sub_10069EC00();
        }
      }

      else
      {
        sub_100242CD0(&v60);
        *(_BYTE *)(a1 + 41) = 1;
        uint64_t v51 = (os_log_s *)qword_1008F75A8;
        if (os_log_type_enabled((os_log_t)qword_1008F75A8, OS_LOG_TYPE_DEFAULT))
        {
          *(_WORD *)__int128 buf = 0;
          _os_log_impl( (void *)&_mh_execute_header,  v51,  OS_LOG_TYPE_DEFAULT,  "LESecurityManager stackDidStart",  buf,  2u);
        }
      }
    }
  }

void sub_10061F6D0( _Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, void *__p, uint64_t a12, int a13, __int16 a14, char a15, char a16, int a17, __int16 a18, char a19, char a20, char a21, uint64_t a22, void *a23, uint64_t a24, int a25, __int16 a26, char a27, char a28)
{
  if (a16 < 0) {
    operator delete(__p);
  }
  if (a28 < 0) {
    operator delete(a23);
  }
  sub_100242CD8(&a20);
  sub_100242FAC((uint64_t)&a21);
  _Unwind_Resume(a1);
}

void sub_10061F7B0(uint64_t a1, void *a2, int a3)
{
  id v5 = a2;
  uint64_t v6 = sub_100404FE8();
  v8[0] = _NSConcreteStackBlock;
  v8[1] = 3221225472LL;
  _DWORD v8[2] = sub_10061F868;
  void v8[3] = &unk_100881060;
  uint64_t v10 = a1;
  id v7 = v5;
  id v9 = v7;
  int v11 = a3;
  sub_100405384(v6, v8);
}

void sub_10061F848( _Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, void *a14)
{
  _Unwind_Resume(a1);
}

void sub_10061F868(uint64_t a1)
{
  uint64_t v2 = *(void *)(a1 + 40);
  if ([*(id *)(v2 + 3752) containsObject:*(void *)(a1 + 32)])
  {
    unsigned __int8 v3 = (os_log_s *)qword_1008F75A8;
    if (os_log_type_enabled((os_log_t)qword_1008F75A8, OS_LOG_TYPE_DEFAULT))
    {
      uint64_t v4 = *(void *)(a1 + 32);
      *(_DWORD *)__int128 buf = 138543362;
      *(void *)&uint8_t buf[4] = v4;
      _os_log_impl( (void *)&_mh_execute_header,  v3,  OS_LOG_TYPE_DEFAULT,  "Device %{public}@ was pending BMS unpairing but got disconnected, lets complete unpairing",  buf,  0xCu);
    }

    [*(id *)(v2 + 3752) removeObject:*(void *)(a1 + 32)];
    sub_10061FAB4(v2, *(void **)(a1 + 32), 0);
  }

  else
  {
    int v5 = *(_DWORD *)(a1 + 48);
    if (v5 == 182 || v5 == 179)
    {
      memset(buf, 0, sizeof(buf));
      uint64_t v16 = 0LL;
      if (qword_1008D5F30 != -1) {
        dispatch_once(&qword_1008D5F30, &stru_1008A45D8);
      }
      sub_1005CF060((uint64_t)off_1008D5F28, *(void **)(a1 + 32), (uint64_t)buf);
      uint64_t v6 = HIBYTE(v16);
      int v7 = SHIBYTE(v16);
      if (v16 < 0) {
        uint64_t v6 = *(void *)&buf[8];
      }
      if (v6)
      {
        uint64_t v8 = (os_log_s *)qword_1008F7588;
        if (os_log_type_enabled((os_log_t)qword_1008F7588, OS_LOG_TYPE_DEFAULT))
        {
          id v9 = *(uint8_t **)buf;
          if (v7 >= 0) {
            id v9 = buf;
          }
          *(_DWORD *)uint64_t v13 = 136446210;
          unsigned __int8 v14 = v9;
          _os_log_impl( (void *)&_mh_execute_header,  v8,  OS_LOG_TYPE_DEFAULT,  "Bad or missing keys, re-cloud pairing for device %{public}s",  v13,  0xCu);
        }

        uint64_t v10 = sub_1002E8FF0();
        if (SHIBYTE(v16) < 0)
        {
          sub_100024238(__p, *(void **)buf, *(unint64_t *)&buf[8]);
        }

        else
        {
          *(_OWORD *)std::stringbuf::string_type __p = *(_OWORD *)buf;
          uint64_t v12 = v16;
        }

        (*(void (**)(uint64_t, void **))(*(void *)v10 + 56LL))(v10, __p);
        if (SHIBYTE(v12) < 0) {
          operator delete(__p[0]);
        }
      }

      if (SHIBYTE(v16) < 0) {
        operator delete(*(void **)buf);
      }
    }
  }

void sub_10061FA78( _Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, void *__p, uint64_t a10, int a11, __int16 a12, char a13, char a14, uint64_t a15, uint64_t a16, uint64_t a17, void *a18, uint64_t a19, int a20, __int16 a21, char a22, char a23)
{
  if (a14 < 0) {
    operator delete(__p);
  }
  if (a23 < 0) {
    operator delete(a18);
  }
  _Unwind_Resume(exception_object);
}

void sub_10061FAB4(uint64_t a1, void *a2, int a3)
{
  id v5 = a2;
  uint64_t v6 = *(uint64_t **)(a1 + 568);
  for (uint64_t i = *(uint64_t **)(a1 + 576); v6 != i; ++v6)
  {
    uint64_t v8 = *v6;
    uint64_t v9 = sub_100404FE8();
    v21[0] = _NSConcreteStackBlock;
    v21[1] = 3221225472LL;
    void v21[2] = sub_100627468;
    v21[3] = &unk_1008800B8;
    uint64_t v23 = v8;
    id v22 = v5;
    sub_100405384(v9, v21);
  }

  if (qword_1008D5F30 != -1) {
    dispatch_once(&qword_1008D5F30, &stru_1008A45D8);
  }
  uint64_t v10 = off_1008D5F28;
  sub_10002418C(__p, "PrivateModeDevice");
  int v11 = sub_1005CE5A8((uint64_t)v10, v5, (uint64_t)__p);
  int v12 = v11;
  if (v20 < 0)
  {
    operator delete(__p[0]);
    if (!v12) {
      goto LABEL_14;
    }
  }

  else if (!v11)
  {
    goto LABEL_14;
  }

  uint64_t v13 = (os_log_s *)qword_1008F75A8;
  BOOL v14 = os_log_type_enabled((os_log_t)qword_1008F75A8, OS_LOG_TYPE_DEFAULT);
  if (v14)
  {
    *(_WORD *)__int128 buf = 0;
    _os_log_impl( (void *)&_mh_execute_header,  v13,  OS_LOG_TYPE_DEFAULT,  "Device being unpaired is tagged with private mode. Restart rotation of random address",  buf,  2u);
  }

  *(_WORD *)(a1 + 594) = 0;
  sub_100627314(v14, 0LL);
  if (qword_1008D5F30 != -1) {
    dispatch_once(&qword_1008D5F30, &stru_1008A45D8);
  }
  sub_1005C9A38((uint64_t)off_1008D5F28, v5, @"PrivateModeDevice");
LABEL_14:
  if (a3)
  {
    if (qword_1008D5F10 != -1) {
      dispatch_once(&qword_1008D5F10, &stru_1008A45F8);
    }
    uint64_t v15 = off_1008D5F08;
    sub_100241F90(buf, v5);
    sub_100597F98((uint64_t)v15, buf, 5u);
    uint64_t v16 = sub_100404FE8();
    v17[0] = _NSConcreteStackBlock;
    v17[1] = 3221225472LL;
    v17[2] = sub_10062747C;
    v17[3] = &unk_10087EA48;
    id v18 = v5;
    sub_100405384(v16, v17);
  }
}

void sub_10061FD48( _Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, void *a13, void *__p, uint64_t a15, int a16, __int16 a17, char a18, char a19, uint64_t a20, uint64_t a21, uint64_t a22, uint64_t a23, uint64_t a24)
{
  _Unwind_Resume(a1);
}

void sub_10061FDA0(uint64_t a1, void *a2, int a3)
{
}

void sub_10061FDA8(uint64_t a1, void *a2, uint64_t a3)
{
  id v5 = a2;
  uint64_t v6 = (os_log_s *)qword_1008F75A8;
  if (os_log_type_enabled((os_log_t)qword_1008F75A8, OS_LOG_TYPE_DEFAULT))
  {
    int v7 = 138543618;
    id v8 = v5;
    __int16 v9 = 1024;
    int v10 = a3;
    _os_log_impl( (void *)&_mh_execute_header,  v6,  OS_LOG_TYPE_DEFAULT,  "Device %{public}@ disconnected without link ready with result: %d",  (uint8_t *)&v7,  0x12u);
  }

  (*(void (**)(uint64_t, id, uint64_t))(*(void *)a1 + 64LL))(a1, v5, a3);
}

void sub_10061FE84(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_10061FE9C(uint64_t a1, void *a2, uint64_t a3)
{
}

uint64_t sub_10061FEA4(uint64_t a1)
{
  uint64_t v2 = (os_log_s *)qword_1008F75A8;
  if (os_log_type_enabled((os_log_t)qword_1008F75A8, OS_LOG_TYPE_DEFAULT))
  {
    *(_WORD *)__int128 buf = 0;
    _os_log_impl( (void *)&_mh_execute_header,  v2,  OS_LOG_TYPE_DEFAULT,  "LeSecurityManager::stackWillStop enter",  buf,  2u);
  }

  *(void *)__int128 buf = 0LL;
  uint64_t v17 = 0LL;
  sub_100242F28((uint64_t)buf, a1 + 48);
  char v15 = 0;
  sub_100242CA4(&v15);
  if (sub_1001BEB38())
  {
    __int128 v13 = 0u;
    __int128 v14 = 0u;
    __int128 v11 = 0u;
    __int128 v12 = 0u;
    id v3 = *(id *)(a1 + 3752);
    id v4 = [v3 countByEnumeratingWithState:&v11 objects:v18 count:16];
    if (v4)
    {
      uint64_t v5 = *(void *)v12;
      do
      {
        uint64_t v6 = 0LL;
        do
        {
          if (*(void *)v12 != v5) {
            objc_enumerationMutation(v3);
          }
          id v7 = *(id *)(*((void *)&v11 + 1) + 8LL * (void)v6);
          sub_10061FAB4(a1, v7, 0);

          uint64_t v6 = (char *)v6 + 1;
        }

        while (v4 != v6);
        id v4 = [v3 countByEnumeratingWithState:&v11 objects:v18 count:16];
      }

      while (v4);
    }

    [*(id *)(a1 + 3752) removeAllObjects];
    sub_1001C8874(off_1008D9C88);
    sub_1001C86F4((uint64_t)off_1008D9C68);
    sub_1001C8544((uint64_t)off_1008D9C48);
    sub_1001BD934(0);
    sub_100242CD0(&v15);
    *(_BYTE *)(a1 + 41) = 0;
    [*(id *)(a1 + 3728) removeAllObjects];
    sub_1006325A8(a1 + 464, *(void **)(a1 + 472));
    *(void *)(a1 + 472) = 0LL;
    *(void *)(a1 + 480) = 0LL;
    *(void *)(a1 + 464) = a1 + 472;
    sub_1006325A8(a1 + 488, *(void **)(a1 + 496));
    *(void *)(a1 + 496) = 0LL;
    *(void *)(a1 + 504) = 0LL;
    *(void *)(a1 + 48_Block_object_dispose(va, 8) = a1 + 496;
    sub_1006325A8(a1 + 512, *(void **)(a1 + 520));
    *(void *)(a1 + 512) = a1 + 520;
    *(void *)(a1 + 52_Block_object_dispose(va, 8) = 0LL;
    *(void *)(a1 + 520) = 0LL;
    id v8 = (os_log_s *)qword_1008F75A8;
    if (os_log_type_enabled((os_log_t)qword_1008F75A8, OS_LOG_TYPE_DEFAULT))
    {
      *(_WORD *)int v10 = 0;
      _os_log_impl( (void *)&_mh_execute_header,  v8,  OS_LOG_TYPE_DEFAULT,  "LeSecurityManager::stackWillStop exit",  v10,  2u);
    }
  }

  sub_100242CD8(&v15);
  return sub_100242FAC((uint64_t)buf);
}

void sub_1006200F8( _Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, int a20, __int16 a21, char a22, char a23, char a24)
{
  sub_100242CD8(&a23);
  sub_100242FAC((uint64_t)&a24);
  _Unwind_Resume(a1);
}

void sub_100620144(uint64_t a1, unsigned __int8 *a2)
{
  id v4 = (void *)(((unint64_t)a2[1] << 40) | ((unint64_t)a2[2] << 32) | ((unint64_t)a2[3] << 24) | ((unint64_t)a2[4] << 16) | ((unint64_t)a2[5] << 8) | a2[6] | ((unint64_t)*a2 << 48));
  uint64_t v5 = (os_log_s *)qword_1008F75A8;
  if (os_log_type_enabled((os_log_t)qword_1008F75A8, OS_LOG_TYPE_DEFAULT))
  {
    sub_1005BFC20((uint64_t)v4, (std::stringbuf::string_type *)dst);
    uint64_t v6 = (SBYTE7(v97) & 0x80u) == 0 ? dst : *(unsigned __int8 **)dst;
    *(_DWORD *)__int128 buf = 136446210;
    uint64_t v87 = (std::stringbuf::string_type *)v6;
    _os_log_impl((void *)&_mh_execute_header, v5, OS_LOG_TYPE_DEFAULT, "Deriving key for device %{public}s", buf, 0xCu);
    if (SBYTE7(v97) < 0) {
      operator delete(*(void **)dst);
    }
  }

  int v84 = &off_10089A548;
  uint64_t v85 = 0LL;
  id v7 = *(const unsigned __int8 **)(a1 + 440);
  if (v7 != (const unsigned __int8 *)(a1 + 448))
  {
    char v8 = 0;
    while (1)
    {
      sub_10002EAC8((uint64_t)&v84, (uint64_t)(v7 + 48));
      memset(dst, 0, sizeof(dst));
      uuid_copy(dst, v7 + 32);
      if (qword_1008D5F30 != -1) {
        dispatch_once(&qword_1008D5F30, &stru_1008A45D8);
      }
      __int16 v9 = off_1008D5F28;
      int v10 = sub_100241F94(dst);
      __int128 v11 = (void *)objc_claimAutoreleasedReturnValue(v10);
      uint64_t v12 = sub_1005CC198((uint64_t)v9, v11, 0);

      __int128 v13 = (unsigned __int8 *)*((void *)v7 + 1);
      if (v13)
      {
        do
        {
          __int128 v14 = (const unsigned __int8 **)v13;
          __int128 v13 = *(unsigned __int8 **)v13;
        }

        while (v13);
      }

      else
      {
        do
        {
          __int128 v14 = (const unsigned __int8 **)*((void *)v7 + 2);
          BOOL v15 = *v14 == v7;
          id v7 = (const unsigned __int8 *)v14;
        }

        while (!v15);
      }

      v8 |= v4 == (void *)v12;
      id v7 = (const unsigned __int8 *)v14;
      if (v14 == (const unsigned __int8 **)(a1 + 448))
      {
        if ((v8 & 1) == 0) {
          goto LABEL_23;
        }
        break;
      }
    }

    char v83 = 0;
    sub_100242CA4(&v83);
    uint64_t v16 = sub_10012D98C(a2);
    sub_100242CD0(&v83);
    memset(uu, 0, sizeof(uu));
    uuid_clear(uu);
    if (v16)
    {
      if (qword_1008D5F10 != -1) {
        dispatch_once(&qword_1008D5F10, &stru_1008A45F8);
      }
      sub_100593548((uint64_t)off_1008D5F08, v16, uu);
    }

    else
    {
      if (qword_1008D5F30 != -1) {
        dispatch_once(&qword_1008D5F30, &stru_1008A45D8);
      }
      sub_1005C8684( (uint64_t)off_1008D5F28,  ((unint64_t)a2[1] << 40) | ((unint64_t)a2[2] << 32) | ((unint64_t)a2[3] << 24) | ((unint64_t)a2[4] << 16) | ((unint64_t)a2[5] << 8) | a2[6] | ((unint64_t)*a2 << 48),  0,  1u,  0LL,  0LL,  dst);
      uuid_copy(uu, dst);
    }

    if (uuid_is_null(uu))
    {
LABEL_33:
      unint64_t v81 = 0LL;
      uint64_t v82 = 0LL;
      sub_10032BA60((uint64_t)v85, 16, &v81);
      BOOL v19 = sub_10056AAC8((uint64_t)&v81);
      if (qword_1008D5F30 != -1) {
        dispatch_once(&qword_1008D5F30, &stru_1008A45D8);
      }
      char v20 = off_1008D5F28;
      int v21 = sub_100241F94(uu);
      id v22 = (void *)objc_claimAutoreleasedReturnValue(v21);
      uint64_t v23 = (void *)sub_1005CE518((uint64_t)v20, v22);

      int v24 = !v19;
      int v25 = (os_log_s *)qword_1008F75A8;
      if (os_log_type_enabled((os_log_t)qword_1008F75A8, OS_LOG_TYPE_DEFAULT))
      {
        *(_DWORD *)uuid_t dst = 67109376;
        *(_DWORD *)&dst[4] = (_DWORD)v23;
        *(_WORD *)&unsigned __int8 dst[8] = 1024;
        *(_DWORD *)&dst[10] = v24;
        _os_log_impl((void *)&_mh_execute_header, v25, OS_LOG_TYPE_DEFAULT, "hasTS:%d hasLKLTK:%d", dst, 0xEu);
      }

      if (((v24 | v23) & 1) == 0)
      {
        uint64_t v33 = (os_log_s *)qword_1008F75A8;
        if (os_log_type_enabled((os_log_t)qword_1008F75A8, OS_LOG_TYPE_DEFAULT))
        {
          sub_1005BFC20((uint64_t)v4, (std::stringbuf::string_type *)dst);
          int v34 = (SBYTE7(v97) & 0x80u) == 0 ? dst : *(unsigned __int8 **)dst;
          *(_DWORD *)__int128 buf = 136446210;
          uint64_t v87 = (std::stringbuf::string_type *)v34;
          _os_log_impl( (void *)&_mh_execute_header,  v33,  OS_LOG_TYPE_DEFAULT,  "Device %{public}s is not an Watch and does not have the LKLTK bit set, will not derive a link key for it.",  buf,  0xCu);
          if (SBYTE7(v97) < 0) {
            operator delete(*(void **)dst);
          }
        }

        goto LABEL_67;
      }

      int v101 = 0;
      __int128 v99 = 0u;
      __int128 v100 = 0u;
      __int128 v97 = 0u;
      __int128 v98 = 0u;
      *(_OWORD *)uuid_t dst = 0u;
      unsigned __int8 v80 = 0;
      __int128 v95 = 0uLL;
      __n128 v93 = 0uLL;
      int v94 = 0;
      sub_10052523C((uint64_t)&v93);
      sub_10061D7EC(a1, (uint64_t)&v84, dst);
      char v79 = 0;
      sub_100242CA4(&v79);
      int v26 = sub_1001C915C(&v95, &v80, (uint64_t)dst);
      sub_100242CD0(&v79);
      if (v26 || (v80 & 0xFE) != 2)
      {
        uint64_t v39 = (os_log_s *)qword_1008F75A8;
        if (os_log_type_enabled((os_log_t)qword_1008F75A8, OS_LOG_TYPE_ERROR))
        {
          sub_1005BFC20((uint64_t)v4, &v71);
          char v64 = (v71.__r_.__value_.__s.__size_ & 0x80u) == 0
              ? &v71
              : (std::stringbuf::string_type *)v71.__r_.__value_.__r.__words[0];
          *(_DWORD *)__int128 buf = 136446722;
          uint64_t v87 = v64;
          __int16 v88 = 1024;
          int v89 = v26;
          __int16 v90 = 1024;
          int v91 = v80;
          _os_log_error_impl( (void *)&_mh_execute_header,  v39,  OS_LOG_TYPE_ERROR,  "LE_Security_DeriveLinkKeyForAddress %{public}s with result %{bluetooth:OI_STATUS}u ltkType=%d ",  buf,  0x18u);
        }

        goto LABEL_66;
      }

      if (v80 != 3)
      {
        if (v80 != 2)
        {
          char v63 = (os_log_s *)qword_1008F75A8;
          if (os_log_type_enabled((os_log_t)qword_1008F75A8, OS_LOG_TYPE_FAULT))
          {
            *(_WORD *)__int128 buf = 0;
            _os_log_fault_impl( (void *)&_mh_execute_header,  v63,  OS_LOG_TYPE_FAULT,  "Unknown LTK Type - aborting\n",  buf,  2u);
            char v63 = (os_log_s *)qword_1008F75A8;
          }

          if (os_log_type_enabled(v63, OS_LOG_TYPE_ERROR))
          {
            *(_DWORD *)__int128 buf = 67109120;
            LODWORD(v87) = v80;
            _os_log_error_impl( (void *)&_mh_execute_header,  v63,  OS_LOG_TYPE_ERROR,  "Unknown LTK Type (%d) - aborting",  buf,  8u);
            char v63 = (os_log_s *)qword_1008F75A8;
          }

          if (os_log_type_enabled(v63, OS_LOG_TYPE_DEFAULT))
          {
            *(_WORD *)__int128 buf = 0;
            _os_log_impl((void *)&_mh_execute_header, v63, OS_LOG_TYPE_DEFAULT, "LinkKey is not valid", buf, 2u);
          }

          goto LABEL_66;
        }

        uint64_t v27 = sub_1002E6BF0();
        char v28 = (*(uint64_t (**)(uint64_t))(*(void *)v27 + 344LL))(v27);
        if ((v28 & 1) != 0) {
          goto LABEL_46;
        }
        if (qword_1008D5F30 != -1) {
          dispatch_once(&qword_1008D5F30, &stru_1008A45D8);
        }
        uint64_t v23 = off_1008D5F28;
        int v29 = sub_100241F94(uu);
        id v4 = (void *)objc_claimAutoreleasedReturnValue(v29);
        sub_10002418C(__p, "IsAppleWatch");
        if ((sub_1005CE5A8((uint64_t)v23, v4, (uint64_t)__p) & 1) != 0)
        {
LABEL_46:
          int v30 = 0;
        }

        else
        {
          if (qword_1008D5F30 != -1) {
            dispatch_once(&qword_1008D5F30, &stru_1008A45D8);
          }
          id v65 = off_1008D5F28;
          int v66 = sub_100241F94(uu);
          uint64_t v23 = (void *)objc_claimAutoreleasedReturnValue(v66);
          if (!sub_1005CE518((uint64_t)v65, v23))
          {
            unsigned int v31 = 4;
            int v30 = 1;
            goto LABEL_48;
          }

          int v30 = 1;
        }

        unsigned int v31 = 7;
LABEL_48:
        sub_10052525C((uint64_t)buf, &v95, v31);
        sub_100525248(&v93, (__n128 *)buf);
        nullsub_63(buf, v32);
        if (v30) {

        }
        if ((v28 & 1) == 0)
        {
          if (v78 < 0) {
            operator delete(__p[0]);
          }
        }

void sub_100620D54( _Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, void *a15, uint64_t a16, int a17, __int16 a18, char a19, char a20, void *a21, uint64_t a22, int a23, __int16 a24, char a25, char a26, void *__p, uint64_t a28, int a29, __int16 a30, char a31, char a32, void *a33, uint64_t a34, int a35, __int16 a36, char a37, char a38, int a39, __int16 a40, char a41, uint64_t (**a42)(), unsigned int *a43, int a44, __int16 a45, char a46, char a47, uint64_t (**a48)(), unsigned int *a49, char a50,uint64_t a51,uint64_t a52,uint64_t a53,int a54,char a55,uint64_t a56,uint64_t a57,char a58)
{
  if (a32 < 0) {
    operator delete(__p);
  }

  sub_100242CD8(&a41);
  nullsub_63(&a58, v61);
  a42 = &off_10087FAA8;
  if (a43) {
    sub_1002CD254(a43);
  }
  sub_100242CD8(&a47);
  a48 = &off_10089A548;
  if (a49) {
    sub_1002CD254(a49);
  }
  _Unwind_Resume(a1);
}

void sub_100620F44(uint64_t a1, void *a2, int a3)
{
  id v5 = a2;
  v20[0] = 0LL;
  v20[1] = 0LL;
  sub_100242F28((uint64_t)v20, a1 + 48);
  uint64_t v6 = (os_log_s *)qword_1008F75A8;
  if (os_log_type_enabled((os_log_t)qword_1008F75A8, OS_LOG_TYPE_DEFAULT))
  {
    *(_DWORD *)__int128 buf = 138543362;
    *(void *)&uint8_t buf[4] = v5;
    _os_log_impl((void *)&_mh_execute_header, v6, OS_LOG_TYPE_DEFAULT, "Deriving key for device %{public}@", buf, 0xCu);
  }

  if (qword_1008D5F30 != -1) {
    dispatch_once(&qword_1008D5F30, &stru_1008A45D8);
  }
  unint64_t v7 = sub_1005CC198((uint64_t)off_1008D5F28, v5, 0);
  sub_100241F90(buf, v5);
  id v18 = (uint64_t (**)())buf;
  char v8 = sub_10063289C( (uint64_t **)(a1 + 440),  buf,  (uint64_t)&unk_1006C2518,  (const unsigned __int8 *__attribute__((__org_typedef(uuid_t))) *)&v18);
  __int16 v9 = (unsigned int *)v8[7];
  if (v9) {
    sub_1002CD1E0(v8[7]);
  }
  uint64_t v10 = sub_1002E6BF0();
  if ((((*(unsigned int (**)(uint64_t))(*(void *)v10 + 344LL))(v10) | a3 ^ 1) & 1) == 0)
  {
    __int128 v11 = (os_log_s *)qword_1008F75A8;
    if (os_log_type_enabled((os_log_t)qword_1008F75A8, OS_LOG_TYPE_DEFAULT))
    {
      *(_DWORD *)__int128 buf = 138543362;
      *(void *)&uint8_t buf[4] = v5;
      _os_log_impl( (void *)&_mh_execute_header,  v11,  OS_LOG_TYPE_DEFAULT,  "Switching derivation method for device %{public}@",  buf,  0xCu);
    }

    id v18 = 0LL;
    BOOL v19 = 0LL;
    sub_10032BA60((uint64_t)v9, 16, &v18);
    __uuid_t dst = 1;
    if (sub_10056AAC8((uint64_t)&v18))
    {
      int v12 = 1;
    }

    else
    {
      sub_10056AB74((uint64_t)&v18, &__dst, 1uLL);
      int v12 = __dst;
    }

    __int128 v13 = (os_log_s *)qword_1008F75A8;
    if (os_log_type_enabled((os_log_t)qword_1008F75A8, OS_LOG_TYPE_DEFAULT))
    {
      if (v12 == 1) {
        __int128 v14 = "6";
      }
      else {
        __int128 v14 = "7";
      }
      *(_DWORD *)__int128 buf = 138543618;
      *(void *)&uint8_t buf[4] = v5;
      *(_WORD *)&_BYTE buf[12] = 2080;
      *(void *)&buf[14] = v14;
      _os_log_impl( (void *)&_mh_execute_header,  v13,  OS_LOG_TYPE_DEFAULT,  "Current key derivation method for device %{public}@ is H%s",  buf,  0x16u);
      int v12 = __dst;
      __int128 v13 = (os_log_s *)qword_1008F75A8;
    }

    if (v12 == 2) {
      char v15 = 1;
    }
    else {
      char v15 = 2;
    }
    __uuid_t dst = v15;
    if (os_log_type_enabled(v13, OS_LOG_TYPE_DEFAULT))
    {
      if (v12 == 2) {
        uint64_t v16 = "6";
      }
      else {
        uint64_t v16 = "7";
      }
      *(_DWORD *)__int128 buf = 138543618;
      *(void *)&uint8_t buf[4] = v5;
      *(_WORD *)&_BYTE buf[12] = 2080;
      *(void *)&buf[14] = v16;
      _os_log_impl( (void *)&_mh_execute_header,  v13,  OS_LOG_TYPE_DEFAULT,  "New key derivation method for device %{public}@ is H%s",  buf,  0x16u);
    }

    sub_10056AB04(buf, &__dst, 1uLL);
    sub_10032B1F8((uint64_t)v9, 16, (uint64_t)buf);
    *(void *)__int128 buf = &off_10087FAA8;
    if (*(void *)&buf[8]) {
      sub_1002CD254(*(unsigned int **)&buf[8]);
    }
    id v18 = &off_10087FAA8;
    if (v19) {
      sub_1002CD254(v19);
    }
  }

  uint64_t v17 = sub_1001BCDB0(v7);
  *(_DWORD *)__int128 buf = v17;
  buf[6] = BYTE6(v17);
  *(_WORD *)&uint8_t buf[4] = WORD2(v17);
  sub_100620144(a1, buf);
  if (v9) {
    sub_1002CD254(v9);
  }
  sub_100242FAC((uint64_t)v20);
}

void sub_1006212A8( _Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, unsigned int *a11, char a12, uint64_t a13, uint64_t a14, uint64_t (**a15)(), unsigned int *a16)
{
  a15 = &off_10087FAA8;
  if (a16) {
    sub_1002CD254(a16);
  }
  if (a11) {
    sub_1002CD254(a11);
  }
  if (v17) {
    sub_1002CD254(v17);
  }
  sub_100242FAC((uint64_t)&a12);

  _Unwind_Resume(a1);
}

void sub_100621334(uint64_t a1, unsigned __int8 *a2, uint64_t a3)
{
  uint64_t v6 = 0LL;
  for (uint64_t i = 0LL; i != 130; ++i)
  {
    BOOL v8 = *(_DWORD *)(a1 + v6 + 613) == *(_DWORD *)a2 && *(_DWORD *)(a1 + v6 + 616) == *(_DWORD *)(a2 + 3);
    if (v8 && *(_BYTE *)(a1 + v6 + 620))
    {
      uint64_t v19 = a1 + v6;
      if (*(void *)(v19 + 597) == *(void *)a3 && *(void *)(v19 + 605) == *(void *)(a3 + 8))
      {
        uint64_t v27 = (os_log_s *)qword_1008F75A8;
        if (os_log_type_enabled((os_log_t)qword_1008F75A8, OS_LOG_TYPE_ERROR))
        {
          sub_1005BFC20( ((unint64_t)a2[1] << 40) | ((unint64_t)a2[2] << 32) | ((unint64_t)a2[3] << 24) | ((unint64_t)a2[4] << 16) | ((unint64_t)a2[5] << 8) | a2[6] | ((unint64_t)*a2 << 48),  &__p);
          if ((__p.__r_.__value_.__s.__size_ & 0x80u) == 0) {
            p_p = &__p;
          }
          else {
            p_p = (std::stringbuf::string_type *)__p.__r_.__value_.__r.__words[0];
          }
          *(_DWORD *)__int128 buf = 136446723;
          uint64_t v32 = p_p;
          __int16 v33 = 1041;
          int v34 = 16;
          __int16 v35 = 2097;
          uint64_t v36 = a3;
          _os_log_error_impl( (void *)&_mh_execute_header,  v27,  OS_LOG_TYPE_ERROR,  "address %{public}s Incorrect IRK %{private}.16P",  buf,  0x1Cu);
        }
      }

      else
      {
        *(_OWORD *)(v19 + 597) = *(_OWORD *)a3;
        *(_BYTE *)(v19 + 620) = 1;
        if (*(_BYTE *)(a1 + 41))
        {
          sub_100627130(a1, a2);
          unint64_t v21 = ((unint64_t)a2[1] << 40) | ((unint64_t)a2[2] << 32) | ((unint64_t)a2[3] << 24) | ((unint64_t)a2[4] << 16) | ((unint64_t)a2[5] << 8) | a2[6] | ((unint64_t)*a2 << 48);
          uint64_t v22 = sub_1002E6E9C();
          (*(void (**)(uint64_t, unint64_t, uint64_t))(*(void *)v22 + 368LL))(v22, v21, 1LL);
LABEL_22:
          sub_10061E118(a1, (int *)(a1 + 24LL * i + 613), (_OWORD *)(a1 + 24LL * i + 597));
          unint64_t v23 = ((unint64_t)a2[1] << 40) | ((unint64_t)a2[2] << 32) | ((unint64_t)a2[3] << 24) | ((unint64_t)a2[4] << 16) | ((unint64_t)a2[5] << 8) | a2[6] | ((unint64_t)*a2 << 48);
          uint64_t v24 = sub_1002E6E9C();
          int v25 = (*(uint64_t (**)(uint64_t, unint64_t, uint64_t, uint64_t))(*(void *)v24 + 360LL))( v24,  v23,  a3,  1LL);
          id v26 = sub_10062CCB0(a1, v23);
          id v29 = (id)objc_claimAutoreleasedReturnValue(v26);
          sub_10061E0B4((uint64_t)v29, v29, v25);
        }
      }

      return;
    }

    v6 += 24LL;
  }

  uint64_t i = 0LL;
  for (uint64_t j = a1 + 597; *(_BYTE *)(j + 23); j += 24LL)
  {
    if (++i == 130)
    {
      uint64_t v10 = (os_log_s *)qword_1008F75A8;
      if (os_log_type_enabled((os_log_t)qword_1008F75A8, OS_LOG_TYPE_ERROR)) {
        sub_10069EDE0(v10, v11, v12, v13, v14, v15, v16, v17);
      }
      return;
    }
  }

  int v18 = *(_DWORD *)a2;
  *(_DWORD *)(j + 19) = *(_DWORD *)(a2 + 3);
  *(_DWORD *)(j + 16) = v18;
  *(_OWORD *)uint64_t j = *(_OWORD *)a3;
  *(_BYTE *)(j + 23) = 1;
  if (*(_BYTE *)(a1 + 41)) {
    goto LABEL_22;
  }
}

void sub_100621680(uint64_t a1)
{
  id v29 = (void *)objc_claimAutoreleasedReturnValue(+[NSMutableDictionary dictionary](&OBJC_CLASS___NSMutableDictionary, "dictionary"));
  v34[0] = 0LL;
  v34[1] = 0LL;
  sub_100242F28((uint64_t)v34, a1 + 48);
  id v2 = sub_1002978A8(0LL);
  char v28 = (void *)objc_claimAutoreleasedReturnValue(v2);
  id v3 = (os_log_s *)qword_1008F75A8;
  if (os_log_type_enabled((os_log_t)qword_1008F75A8, OS_LOG_TYPE_DEFAULT))
  {
    id v4 = [v28 count];
    id v5 = [v28 count];
    uint64_t v6 = "s";
    if (v5 == (id)1) {
      uint64_t v6 = "";
    }
    *(_DWORD *)__int128 buf = 134218242;
    *(void *)&uint8_t buf[4] = v4;
    *(_WORD *)&_BYTE buf[12] = 2082;
    *(void *)&buf[14] = v6;
    _os_log_impl( (void *)&_mh_execute_header,  v3,  OS_LOG_TYPE_DEFAULT,  "Found %lu paired LE device%{public}s in local keychain",  buf,  0x16u);
  }

  if (qword_1008D5F30 != -1) {
    dispatch_once(&qword_1008D5F30, &stru_1008A45D8);
  }
  sub_1005CFDA0((uint64_t)off_1008D5F28, v28, 0);
  __int128 v32 = 0u;
  __int128 v33 = 0u;
  __int128 v30 = 0u;
  __int128 v31 = 0u;
  id v7 = v28;
  id v8 = [v7 countByEnumeratingWithState:&v30 objects:v38 count:16];
  if (v8)
  {
    uint64_t v9 = *(void *)v31;
    do
    {
      uint64_t v10 = 0LL;
      do
      {
        if (*(void *)v31 != v9) {
          objc_enumerationMutation(v7);
        }
        uint64_t v11 = *(void **)(*((void *)&v30 + 1) + 8LL * (void)v10);
        uint64_t v12 = objc_autoreleasePoolPush();
        uint64_t v13 = (void *)objc_claimAutoreleasedReturnValue([v7 objectForKeyedSubscript:v11]);
        id v14 = [v13 unsignedLongLongValue];

        if (sub_10061B53C(a1, (unint64_t)v14, v11))
        {
          *(void *)uuid_t uu = 0LL;
          uint64_t v37 = 0LL;
          if (qword_1008D5F30 != -1) {
            dispatch_once(&qword_1008D5F30, &stru_1008A45D8);
          }
          sub_1005C8684((uint64_t)off_1008D5F28, (unint64_t)v14, 0, 1u, 0LL, 0LL, uu);
          if (!uuid_is_null(uu))
          {
            memset(buf, 0, 24);
            if (qword_1008D5F30 != -1) {
              dispatch_once(&qword_1008D5F30, &stru_1008A45D8);
            }
            uint64_t v16 = off_1008D5F28;
            uint64_t v17 = sub_100241F94(uu);
            int v18 = (void *)objc_claimAutoreleasedReturnValue(v17);
            sub_1005CF060((uint64_t)v16, v18, (uint64_t)buf);

            if (((char)buf[23] & 0x80000000) == 0)
            {
              if (!buf[23]) {
                goto LABEL_28;
              }
              uint64_t v19 = buf;
              goto LABEL_26;
            }

            if (*(void *)&buf[8])
            {
              uint64_t v19 = *(uint8_t **)buf;
LABEL_26:
              char v20 = (void *)objc_claimAutoreleasedReturnValue(+[NSString stringWithUTF8String:](&OBJC_CLASS___NSString, "stringWithUTF8String:", v19));
              unint64_t v21 = sub_100241F94(uu);
              uint64_t v22 = (void *)objc_claimAutoreleasedReturnValue(v21);
              [v29 setObject:v20 forKeyedSubscript:v22];
            }

            operator delete(*(void **)buf);
            goto LABEL_28;
          }

          if (uuid_is_null(uu) && os_log_type_enabled((os_log_t)qword_1008F75A8, OS_LOG_TYPE_FAULT))
          {
            id v15 = sub_1005BFB9C((uint64_t)v14);
            objc_claimAutoreleasedReturnValue(v15);
            sub_10069E9F4();
          }
        }

void sub_100621B24( _Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void *a10, uint64_t a11, void *a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20, char a21, uint64_t a22, void *__p, uint64_t a24, int a25, __int16 a26, char a27, char a28)
{
  sub_100242FAC((uint64_t)&a21);
  _Unwind_Resume(a1);
}

uint64_t sub_100621BD0(void *a1)
{
  v71[0] = 0LL;
  v71[1] = 0LL;
  sub_100242F28((uint64_t)v71, (uint64_t)(a1 + 6));
  sub_1006224E4();
  id v2 = (const unsigned __int8 *)a1[55];
  char v64 = (const unsigned __int8 *)(a1 + 56);
  if (v2 != (const unsigned __int8 *)(a1 + 56))
  {
    do
    {
      id v3 = objc_autoreleasePoolPush();
      *(void *)__int128 buf = 0LL;
      *(void *)&uint8_t buf[8] = 0LL;
      sub_10032BA60(*((void *)v2 + 7), 10, buf);
      if (!sub_10056AAC8((uint64_t)buf))
      {
        uint64_t v4 = sub_1002E6E9C();
        if (qword_1008D5F30 != -1) {
          dispatch_once(&qword_1008D5F30, &stru_1008A45D8);
        }
        id v5 = off_1008D5F28;
        uint64_t v6 = sub_100241F94(v2 + 32);
        id v7 = (void *)objc_claimAutoreleasedReturnValue(v6);
        uint64_t v8 = sub_1005CC198((uint64_t)v5, v7, 0);
        uint64_t v9 = sub_10056AAF0((uint64_t)buf);
        int v10 = (*(uint64_t (**)(uint64_t, uint64_t, uint64_t, uint64_t))(*(void *)v4 + 360LL))(v4, v8, v9, 1LL);

        sub_10032BA60(*((void *)v2 + 7), 11, dst);
        uint64_t v11 = (int *)sub_10056AAF0((uint64_t)dst);
        uint64_t v12 = (_OWORD *)sub_10056AAF0((uint64_t)buf);
        sub_10061E118((uint64_t)a1, v11, v12);
        *(void *)uuid_t dst = &off_10087FAA8;
        if (*(void *)&dst[8]) {
          sub_1002CD254(*(unsigned int **)&dst[8]);
        }
        uint64_t v13 = sub_100241F94(v2 + 32);
        id v14 = (void *)objc_claimAutoreleasedReturnValue(v13);
        sub_10061E0B4((uint64_t)v14, v14, v10);
      }

      *(void *)__int128 buf = &off_10087FAA8;
      if (*(void *)&buf[8]) {
        sub_1002CD254(*(unsigned int **)&buf[8]);
      }
      objc_autoreleasePoolPop(v3);
      id v15 = (const unsigned __int8 *)*((void *)v2 + 1);
      if (v15)
      {
        do
        {
          uint64_t v16 = v15;
          id v15 = *(const unsigned __int8 **)v15;
        }

        while (v15);
      }

      else
      {
        do
        {
          uint64_t v16 = (const unsigned __int8 *)*((void *)v2 + 2);
          BOOL v17 = *(void *)v16 == (void)v2;
          id v2 = v16;
        }

        while (!v17);
      }

      id v2 = v16;
    }

    while (v16 != v64);
    id v2 = (const unsigned __int8 *)a1[55];
  }

  if (v2 != v64)
  {
    *(void *)&__int128 v1 = 138543362LL;
    __int128 v62 = v1;
    do
    {
      int v18 = objc_autoreleasePoolPush();
      memset(dst, 0, sizeof(dst));
      uuid_copy(dst, v2 + 32);
      if (qword_1008D5F30 != -1) {
        dispatch_once(&qword_1008D5F30, &stru_1008A45D8);
      }
      uint64_t v19 = off_1008D5F28;
      char v20 = sub_100241F94(dst);
      unint64_t v21 = (void *)objc_claimAutoreleasedReturnValue(v20);
      sub_10002418C(__p, "_CTKD_");
      int v22 = sub_1005CE5A8((uint64_t)v19, v21, (uint64_t)__p);
      if (v70 < 0) {
        operator delete(__p[0]);
      }

      if (qword_1008D5F30 != -1) {
        dispatch_once(&qword_1008D5F30, &stru_1008A45D8);
      }
      int v23 = off_1008D5F28;
      uint64_t v24 = sub_100241F94(dst);
      BOOL v25 = (void *)objc_claimAutoreleasedReturnValue(v24);
      int v26 = sub_1005CE518((uint64_t)v23, v25);

      if (qword_1008D5F30 != -1) {
        dispatch_once(&qword_1008D5F30, &stru_1008A45D8);
      }
      uint64_t v27 = off_1008D5F28;
      char v28 = sub_100241F94(dst);
      id v29 = (void *)objc_claimAutoreleasedReturnValue(v28);
      sub_10002418C(v67, "IsAppleWatch");
      int v30 = sub_1005CE5A8((uint64_t)v27, v29, (uint64_t)v67);
      if (v68 < 0) {
        operator delete(v67[0]);
      }

      __int128 v31 = (os_log_s *)qword_1008F75A8;
      if (os_log_type_enabled((os_log_t)qword_1008F75A8, OS_LOG_TYPE_INFO))
      {
        __int128 v32 = sub_100241F94(dst);
        __int128 v33 = (void *)objc_claimAutoreleasedReturnValue(v32);
        *(_DWORD *)__int128 buf = 138544130;
        *(void *)&uint8_t buf[4] = v33;
        *(_WORD *)&_BYTE buf[12] = 1024;
        *(_DWORD *)&buf[14] = v22;
        *(_WORD *)&_BYTE buf[18] = 1024;
        *(_DWORD *)&_BYTE buf[20] = v26;
        *(_WORD *)&uint8_t buf[24] = 1024;
        *(_DWORD *)&_BYTE buf[26] = v30;
        _os_log_impl( (void *)&_mh_execute_header,  v31,  OS_LOG_TYPE_INFO,  "%{public}@ CTKDTag:%d hasTSTag:%d isAppleWatchTag:%d",  buf,  0x1Eu);
      }

      if ((((v26 | v30) ^ 1 | v22) & 1) == 0)
      {
        int v34 = (os_log_s *)qword_1008F75A8;
        if (os_log_type_enabled((os_log_t)qword_1008F75A8, OS_LOG_TYPE_DEFAULT))
        {
          __int16 v35 = sub_100241F94(dst);
          uint64_t v36 = (void *)objc_claimAutoreleasedReturnValue(v35);
          *(_DWORD *)__int128 buf = v62;
          *(void *)&uint8_t buf[4] = v36;
          _os_log_impl( (void *)&_mh_execute_header,  v34,  OS_LOG_TYPE_DEFAULT,  "Upgrading device %{public}@ to the new CTKD derived LK",  buf,  0xCu);
        }

        if (qword_1008D5F30 != -1) {
          dispatch_once(&qword_1008D5F30, &stru_1008A45D8);
        }
        uint64_t v37 = off_1008D5F28;
        char v38 = sub_100241F94(dst);
        uint64_t v39 = (void *)objc_claimAutoreleasedReturnValue(v38);
        unint64_t v40 = sub_1005CC198((uint64_t)v37, v39, 0);

        *(_DWORD *)&buf[3] = 0;
        *(_DWORD *)__int128 buf = 0;
        uint64_t v41 = sub_1001BCDB0(v40);
        *(_DWORD *)__int128 buf = v41;
        buf[6] = BYTE6(v41);
        *(_WORD *)&uint8_t buf[4] = WORD2(v41);
        sub_100620144((uint64_t)a1, buf);
      }

      objc_autoreleasePoolPop(v18);
      uint64_t v42 = (const unsigned __int8 *)*((void *)v2 + 1);
      if (v42)
      {
        do
        {
          char v43 = v42;
          uint64_t v42 = *(const unsigned __int8 **)v42;
        }

        while (v42);
      }

      else
      {
        do
        {
          char v43 = (const unsigned __int8 *)*((void *)v2 + 2);
          BOOL v17 = *(void *)v43 == (void)v2;
          id v2 = v43;
        }

        while (!v17);
      }

      id v2 = v43;
    }

    while (v43 != v64);
  }

  sub_1001C8074();
  unsigned __int8 v44 = (void *)a1[67];
  if (v44 != a1 + 68)
  {
    do
    {
      int v45 = (const unsigned __int8 *)v44[5];
      if (v45 != (const unsigned __int8 *)(v44 + 6))
      {
        do
        {
          unsigned int v46 = objc_autoreleasePoolPush();
          memset(uu, 0, sizeof(uu));
          uuid_copy(uu, v45 + 32);
          if (!uuid_is_null(uu))
          {
            if (qword_1008D5F30 != -1) {
              dispatch_once(&qword_1008D5F30, &stru_1008A45D8);
            }
            uint64_t v47 = off_1008D5F28;
            uint64_t v48 = sub_100241F94(uu);
            int v49 = (void *)objc_claimAutoreleasedReturnValue(v48);
            unint64_t v50 = sub_1005CC198((uint64_t)v47, v49, 0);

            memset(v66, 0, 7);
            uint64_t v51 = sub_1001BCDB0(v50);
            v66[0] = v51;
            BYTE2(v66[1]) = BYTE6(v51);
            LOWORD(v66[1]) = WORD2(v51);
            char v65 = 0;
            sub_100242CA4(&v65);
            if (uuid_is_null(uu)) {
              uint64_t v52 = 0LL;
            }
            else {
              uint64_t v52 = v66;
            }
            if (sub_1001C80AC(v52, 1))
            {
              uint64_t v53 = (os_log_s *)qword_1008F75A8;
              if (os_log_type_enabled((os_log_t)qword_1008F75A8, OS_LOG_TYPE_ERROR))
              {
                memset(buf, 0, 37);
                uuid_unparse_upper(uu, (char *)buf);
                sub_10002418C(dst, (char *)buf);
                int v56 = dst;
                if (v73 < 0) {
                  int v56 = *(unsigned __int8 **)dst;
                }
                *(_DWORD *)std::string v74 = 136446210;
                int v75 = v56;
                _os_log_error_impl( (void *)&_mh_execute_header,  v53,  OS_LOG_TYPE_ERROR,  "Failed to re-enable OOB pairing for device %{public}s",  v74,  0xCu);
                if (v73 < 0) {
                  operator delete(*(void **)dst);
                }
              }
            }

            sub_100242CD8(&v65);
          }

          objc_autoreleasePoolPop(v46);
          uint64_t v54 = (unsigned __int8 *)*((void *)v45 + 1);
          if (v54)
          {
            do
            {
              uint64_t v55 = (const unsigned __int8 **)v54;
              uint64_t v54 = *(unsigned __int8 **)v54;
            }

            while (v54);
          }

          else
          {
            do
            {
              uint64_t v55 = (const unsigned __int8 **)*((void *)v45 + 2);
              BOOL v17 = *v55 == v45;
              int v45 = (const unsigned __int8 *)v55;
            }

            while (!v17);
          }

          int v45 = (const unsigned __int8 *)v55;
        }

        while (v55 != v44 + 6);
      }

      int v57 = (void *)v44[1];
      if (v57)
      {
        do
        {
          char v58 = v57;
          int v57 = (void *)*v57;
        }

        while (v57);
      }

      else
      {
        do
        {
          char v58 = (void *)v44[2];
          BOOL v17 = *v58 == (void)v44;
          unsigned __int8 v44 = v58;
        }

        while (!v17);
      }

      unsigned __int8 v44 = v58;
    }

    while (v58 != a1 + 68);
  }

  uint64_t v59 = objc_claimAutoreleasedReturnValue(+[NSMutableArray array](&OBJC_CLASS___NSMutableArray, "array", v62));
  char v60 = (void *)a1[466];
  a1[466] = v59;

  sub_10061EA68((uint64_t)a1);
  sub_100621680((uint64_t)a1);
  if (sub_1001BEB38())
  {
    if (qword_1008D5F30 != -1) {
      dispatch_once(&qword_1008D5F30, &stru_1008A45D8);
    }
    sub_1005CB544((uint64_t)off_1008D5F28, 0);
  }

  return sub_100242FAC((uint64_t)v71);
}

void sub_1006223C0( _Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, int a16, __int16 a17, char a18, char a19, uint64_t a20, void *__p, uint64_t a22, int a23, __int16 a24, char a25, char a26, void *a27, uint64_t a28, int a29, __int16 a30, char a31, char a32, char a33, uint64_t a34, uint64_t a35, uint64_t a36)
{
}

_BYTE *sub_1006224E4()
{
  uint64_t v0 = (os_log_s *)qword_1008F75A8;
  if (os_log_type_enabled((os_log_t)qword_1008F75A8, OS_LOG_TYPE_DEFAULT))
  {
    *(_WORD *)__int128 buf = 0;
    _os_log_impl((void *)&_mh_execute_header, v0, OS_LOG_TYPE_DEFAULT, "Clearing address resolving cache", buf, 2u);
  }

  char v2 = 0;
  sub_100242CA4(&v2);
  sub_1001C9C00();
  sub_100242CD0(&v2);
  return sub_100242CD8(&v2);
}

void sub_100622568( _Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, int a10, __int16 a11, char a12, char a13)
{
}

uint64_t sub_10062257C(uint64_t a1, uint64_t a2)
{
  v5[0] = 0LL;
  v5[1] = 0LL;
  sub_100242F28((uint64_t)v5, a1 + 48);
  *(void *)(a1 + 560) = a2;
  return sub_100242FAC((uint64_t)v5);
}

uint64_t sub_1006225C0(void *a1, uint64_t a2)
{
  v20[0] = 0LL;
  v20[1] = 0LL;
  sub_100242F28((uint64_t)v20, (uint64_t)(a1 + 6));
  uint64_t v4 = (void *)a1[71];
  id v5 = (void *)a1[72];
  uint64_t v6 = v4;
  if (v4 != v5)
  {
    while (*v6 != a2)
    {
      if (++v6 == v5)
      {
        uint64_t v6 = (void *)a1[72];
        break;
      }
    }
  }

  if (v6 == v5)
  {
    unint64_t v7 = a1[73];
    if ((unint64_t)v5 >= v7)
    {
      uint64_t v9 = v5 - v4;
      uint64_t v10 = v7 - (void)v4;
      uint64_t v11 = v10 >> 2;
      else {
        unint64_t v12 = v11;
      }
      if (v12) {
        uint64_t v13 = (char *)sub_100008BA0((uint64_t)(a1 + 73), v12);
      }
      else {
        uint64_t v13 = 0LL;
      }
      id v14 = &v13[8 * v9];
      id v15 = &v13[8 * v12];
      *(void *)id v14 = a2;
      uint64_t v8 = v14 + 8;
      uint64_t v16 = (char *)a1[72];
      BOOL v17 = (char *)a1[71];
      if (v16 != v17)
      {
        do
        {
          uint64_t v18 = *((void *)v16 - 1);
          v16 -= 8;
          *((void *)v14 - 1) = v18;
          v14 -= 8;
        }

        while (v16 != v17);
        uint64_t v16 = (char *)a1[71];
      }

      a1[71] = v14;
      a1[72] = v8;
      a1[73] = v15;
      if (v16) {
        operator delete(v16);
      }
    }

    else
    {
      *id v5 = a2;
      uint64_t v8 = v5 + 1;
    }

    a1[72] = v8;
  }

  return sub_100242FAC((uint64_t)v20);
}

void sub_1006226F0( _Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9)
{
}

uint64_t sub_100622704(uint64_t a1, uint64_t a2)
{
  v8[0] = 0LL;
  v8[1] = 0LL;
  sub_100242F28((uint64_t)v8, a1 + 48);
  uint64_t v4 = *(char **)(a1 + 568);
  id v5 = *(char **)(a1 + 576);
  if (v4 != v5)
  {
    while (*(void *)v4 != a2)
    {
      v4 += 8;
      if (v4 == v5)
      {
        uint64_t v4 = *(char **)(a1 + 576);
        break;
      }
    }
  }

  if (v4 != v5)
  {
    int64_t v6 = v5 - (v4 + 8);
    if (v5 != v4 + 8) {
      memmove(v4, v4 + 8, v5 - (v4 + 8));
    }
    *(void *)(a1 + 576) = &v4[v6];
  }

  return sub_100242FAC((uint64_t)v8);
}

void sub_1006227A0(uint64_t a1, void *a2, int a3, int a4, int a5)
{
  id v9 = a2;
  if (*(_BYTE *)(a1 + 3718))
  {
LABEL_2:
    if (*(_BYTE *)(a1 + 41))
    {
      sub_100242AE0(19LL, 0LL, v9);
      uint64_t v10 = (os_log_s *)qword_1008F75A8;
      if (os_log_type_enabled((os_log_t)qword_1008F75A8, OS_LOG_TYPE_DEFAULT))
      {
        *(_DWORD *)__int128 buf = 138544130;
        unint64_t v23 = (unint64_t)v9;
        __int16 v24 = 1024;
        int v25 = a3;
        __int16 v26 = 1024;
        int v27 = a4;
        __int16 v28 = 1024;
        int v29 = a5;
        _os_log_impl( (void *)&_mh_execute_header,  v10,  OS_LOG_TYPE_DEFAULT,  "Initiating pairing to device %{public}@ useMITM=%d distributeIRK=%d disableCTKD=%d",  buf,  0x1Eu);
      }

      uint64_t v21 = 0LL;
      if (qword_1008D5F10 != -1) {
        dispatch_once(&qword_1008D5F10, &stru_1008A45F8);
      }
      uint64_t v11 = off_1008D5F08;
      sub_100241F90(buf, v9);
      if (sub_100599890((uint64_t)v11, buf, &v21))
      {
        unint64_t v12 = *(void *)(a1 + 456);
        if (v12 >= *(unsigned __int16 *)(a1 + 3736))
        {
          uint64_t v18 = (os_log_s *)qword_1008F75A8;
          if (os_log_type_enabled((os_log_t)qword_1008F75A8, OS_LOG_TYPE_DEFAULT))
          {
            *(_DWORD *)__int128 buf = 134217984;
            unint64_t v23 = v12;
            _os_log_impl( (void *)&_mh_execute_header,  v18,  OS_LOG_TYPE_DEFAULT,  "Ignoring pairing request as there are too many paired devices (%lu)",  buf,  0xCu);
          }

          char v20 = 0;
          sub_100242CA4(&v20);
          sub_10018551C(v21, 4835);
          sub_100242CD0(&v20);
          if (qword_1008D5F10 != -1) {
            dispatch_once(&qword_1008D5F10, &stru_1008A45F8);
          }
          uint64_t v19 = off_1008D5F08;
          sub_100241F90(buf, v9);
          sub_100597F98((uint64_t)v19, buf, 8u);
          uint64_t v16 = (uint8_t *)&v20;
        }

        else
        {
          if (a5)
          {
            uint64_t v13 = (os_log_s *)qword_1008F75A8;
            BOOL v14 = os_log_type_enabled((os_log_t)qword_1008F75A8, OS_LOG_TYPE_DEFAULT);
            if (v14)
            {
              *(_DWORD *)__int128 buf = 138543362;
              unint64_t v23 = (unint64_t)v9;
              _os_log_impl( (void *)&_mh_execute_header,  v13,  OS_LOG_TYPE_DEFAULT,  "Disabling CTKD for device %{public}@",  buf,  0xCu);
            }

            sub_100622B64(v14, v9, 1);
          }

          buf[0] = 0;
          sub_100242CA4(buf);
          if ((a4 & 1) == 0) {
            sub_1001D4688(1LL);
          }
          int v15 = sub_1001BD96C(v21, a3);
          sub_100242CD0(buf);
          if (v15 && os_log_type_enabled((os_log_t)qword_1008F75A8, OS_LOG_TYPE_ERROR)) {
            sub_10069EE78();
          }
          uint64_t v16 = buf;
        }

        sub_100242CD8(v16);
      }

      else if (os_log_type_enabled((os_log_t)qword_1008F75A8, OS_LOG_TYPE_ERROR))
      {
        sub_10069EED8();
      }
    }

    goto LABEL_30;
  }

  BOOL v17 = (os_log_s *)qword_1008F75A8;
  if (os_log_type_enabled((os_log_t)qword_1008F75A8, OS_LOG_TYPE_FAULT))
  {
    *(_WORD *)__int128 buf = 0;
    _os_log_fault_impl( (void *)&_mh_execute_header,  v17,  OS_LOG_TYPE_FAULT,  "We don't have root keys for LE, something's wrong, file a radar!",  buf,  2u);
    if (*(_BYTE *)(a1 + 3718)) {
      goto LABEL_2;
    }
    BOOL v17 = (os_log_s *)qword_1008F75A8;
  }

  if (os_log_type_enabled(v17, OS_LOG_TYPE_ERROR)) {
    sub_10069EE4C();
  }
LABEL_30:
}

void sub_100622B18(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, ...)
{
  _Unwind_Resume(a1);
}

void sub_100622B64(uint64_t a1, void *a2, int a3)
{
  id v4 = a2;
  id v5 = (os_log_s *)qword_1008F75A8;
  if (os_log_type_enabled((os_log_t)qword_1008F75A8, OS_LOG_TYPE_DEFAULT))
  {
    int64_t v6 = "enable";
    if (a3) {
      int64_t v6 = "disable";
    }
    *(_DWORD *)__int128 buf = 136446466;
    uint64_t v10 = v6;
    __int16 v11 = 2114;
    id v12 = v4;
    _os_log_impl( (void *)&_mh_execute_header,  v5,  OS_LOG_TYPE_DEFAULT,  "Warning: Trying to %{public}s CTKD for device %{public}@",  buf,  0x16u);
  }

  BOOL v8 = 0LL;
  if (qword_1008D5F10 != -1) {
    dispatch_once(&qword_1008D5F10, &stru_1008A45F8);
  }
  unint64_t v7 = off_1008D5F08;
  sub_100241F90(buf, v4);
  if (sub_100599890((uint64_t)v7, buf, &v8))
  {
    buf[0] = 0;
    sub_100242CA4(buf);
    sub_1001D46E8(v8, a3);
    sub_100242CD8(buf);
  }

  else if (os_log_type_enabled((os_log_t)qword_1008F75A8, OS_LOG_TYPE_ERROR))
  {
    sub_10069EF3C();
  }
}

void sub_100622CD4(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, ...)
{
  _Unwind_Resume(a1);
}

void sub_100622D00(uint64_t a1, void *a2, int a3, unsigned int a4)
{
  id v7 = a2;
  if (*(_BYTE *)(a1 + 3718))
  {
LABEL_2:
    if (*(_BYTE *)(a1 + 41))
    {
      if (qword_1008D5F30 != -1) {
        dispatch_once(&qword_1008D5F30, &stru_1008A45D8);
      }
      uint64_t v8 = sub_1005CC198((uint64_t)off_1008D5F28, v7, 0);
      uint64_t v9 = sub_1001BCDB0(v8);
      int v18 = v9;
      char v20 = BYTE6(v9);
      __int16 v19 = WORD2(v9);
      if (a3)
      {
        uint64_t v10 = (os_log_s *)qword_1008F75A8;
        BOOL v11 = os_log_type_enabled((os_log_t)qword_1008F75A8, OS_LOG_TYPE_DEFAULT);
        if (a4)
        {
          if (v11)
          {
            id v12 = sub_1005BFB9C(v8);
            uint64_t v13 = (void *)objc_claimAutoreleasedReturnValue(v12);
            *(_DWORD *)__int128 buf = 67109634;
            *(_DWORD *)int v22 = a4;
            *(_WORD *)&void v22[4] = 2114;
            *(void *)&v22[6] = v7;
            *(_WORD *)&v22[14] = 2114;
            *(void *)&uint8_t v22[16] = v13;
            _os_log_impl( (void *)&_mh_execute_header,  v10,  OS_LOG_TYPE_DEFAULT,  "Accepting pairing request with passkey %u from device %{public}@ (%{public}@)",  buf,  0x1Cu);
          }
        }

        else if (v11)
        {
          id v16 = sub_1005BFB9C(v8);
          BOOL v17 = (void *)objc_claimAutoreleasedReturnValue(v16);
          *(_DWORD *)__int128 buf = 138543618;
          *(void *)int v22 = v7;
          *(_WORD *)&v22[8] = 2114;
          *(void *)&v22[10] = v17;
          _os_log_impl( (void *)&_mh_execute_header,  v10,  OS_LOG_TYPE_DEFAULT,  "Accepting pairing request from device %{public}@(%{public}@)",  buf,  0x16u);
        }

        buf[0] = 0;
        sub_100242CA4(buf);
        if (sub_1001CBF50(&v18, a4))
        {
          if (os_log_type_enabled((os_log_t)qword_1008F75A8, OS_LOG_TYPE_ERROR)) {
            sub_10069EFA0();
          }
          sub_1001CBD38(&v18);
        }
      }

      else
      {
        int v15 = (os_log_s *)qword_1008F75A8;
        if (os_log_type_enabled((os_log_t)qword_1008F75A8, OS_LOG_TYPE_DEFAULT))
        {
          *(_DWORD *)__int128 buf = 138543362;
          *(void *)int v22 = v7;
          _os_log_impl( (void *)&_mh_execute_header,  v15,  OS_LOG_TYPE_DEFAULT,  "Rejecting pairing request from device %{public}@",  buf,  0xCu);
        }

        buf[0] = 0;
        sub_100242CA4(buf);
      }

      sub_100242CD8(buf);
    }

    goto LABEL_24;
  }

  BOOL v14 = (os_log_s *)qword_1008F75A8;
  if (os_log_type_enabled((os_log_t)qword_1008F75A8, OS_LOG_TYPE_FAULT))
  {
    *(_WORD *)__int128 buf = 0;
    _os_log_fault_impl( (void *)&_mh_execute_header,  v14,  OS_LOG_TYPE_FAULT,  "We don't have root keys for LE, something's wrong, file a radar!",  buf,  2u);
    if (*(_BYTE *)(a1 + 3718)) {
      goto LABEL_2;
    }
    BOOL v14 = (os_log_s *)qword_1008F75A8;
  }

  if (os_log_type_enabled(v14, OS_LOG_TYPE_ERROR)) {
    sub_10069EE4C();
  }
LABEL_24:
}

void sub_100623018(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_100623058(uint64_t a1, unint64_t a2, void *a3, int a4, uint64_t a5)
{
  unint64_t v55 = a2;
  id v8 = a3;
  if (*(_BYTE *)(a1 + 3718))
  {
LABEL_2:
    if (*(_BYTE *)(a1 + 41))
    {
      if (qword_1008D5F30 != -1) {
        dispatch_once(&qword_1008D5F30, &stru_1008A45D8);
      }
      uint64_t v9 = sub_1005CC198((uint64_t)off_1008D5F28, v8, 0);
      uint64_t v10 = sub_1001BCDB0(v9);
      int v52 = v10;
      char v54 = BYTE6(v10);
      __int16 v53 = WORD2(v10);
      if (a4)
      {
        v51[0] = 0LL;
        v51[1] = 0LL;
        sub_100242F28((uint64_t)v51, a1 + 48);
        char v50 = 0;
        sub_100242CA4(&v50);
        *(void *)uuid_t uu = &v55;
        BOOL v11 = sub_1002554E8((uint64_t **)(a1 + 536), &v55, (uint64_t)&unk_1006C2518, (uint64_t **)uu);
        sub_100241F90(uu, v8);
        uint64_t v12 = (uint64_t)(v11 + 5);
        uint64_t v13 = sub_1001FDB10((uint64_t)(v11 + 5), uu);
        BOOL v14 = v11 + 6;
        if ((v14 == (uint64_t *)v13 || (int v15 = *(_OWORD **)(v13 + 48)) == 0LL)
          && ((uuid_clear(uu), uint64_t v16 = sub_1001FDB10(v12, uu), v14 == (uint64_t *)v16)
           || (int v15 = *(_OWORD **)(v16 + 48)) == 0LL))
        {
          char v38 = (os_log_s *)qword_1008F75A8;
          if (os_log_type_enabled((os_log_t)qword_1008F75A8, OS_LOG_TYPE_DEFAULT))
          {
            id v39 = sub_1005BFB9C(v9);
            unint64_t v40 = (void *)objc_claimAutoreleasedReturnValue(v39);
            *(_DWORD *)uuid_t uu = 138543618;
            *(void *)&uu[4] = v8;
            *(_WORD *)&uu[12] = 2114;
            *(void *)&uu[14] = v40;
            _os_log_impl( (void *)&_mh_execute_header,  v38,  OS_LOG_TYPE_DEFAULT,  "Accepting out-of-band pairing request from device %{public}@ (%{public}@) with remote keys",  uu,  0x16u);
          }

          int v31 = sub_1001D3E40(&v52, (_OWORD *)a5, (_OWORD *)(a5 + 16), 0LL);
        }

        else
        {
          __int128 v17 = v15[1];
          *(_OWORD *)uuid_t uu = *v15;
          *(_OWORD *)&uu[16] = v17;
          uint64_t v18 = *(void *)(a5 + 8);
          BOOL v26 = *(void *)a5 == *(void *)uu;
          __int128 v19 = v15[2];
          __int128 v20 = v15[3];
          __int128 v21 = v15[5];
          __int128 v63 = v15[4];
          __int128 v64 = v21;
          __int128 v61 = v19;
          __int128 v62 = v20;
          __int128 v22 = v15[7];
          __int128 v65 = v15[6];
          __int128 v66 = v22;
          __int128 v23 = v15[11];
          __int128 v25 = v15[8];
          __int128 v24 = v15[9];
          __int128 v69 = v15[10];
          __int128 v70 = v23;
          BOOL v26 = v26 && v18 == *(void *)&uu[8];
          __int128 v67 = v25;
          __int128 v68 = v24;
          if (v26
            && (*(void *)(a5 + 16) == *(void *)&uu[16]
              ? (BOOL v27 = *(void *)(a5 + 24) == *(void *)&uu[24])
              : (BOOL v27 = 0),
                v27))
          {
            char v43 = (os_log_s *)qword_1008F75A8;
            if (os_log_type_enabled((os_log_t)qword_1008F75A8, OS_LOG_TYPE_DEFAULT))
            {
              id v44 = sub_1005BFB9C(v9);
              int v45 = (void *)objc_claimAutoreleasedReturnValue(v44);
              *(_DWORD *)__int128 buf = 138543618;
              id v57 = v8;
              __int16 v58 = 2114;
              uint64_t v59 = v45;
              _os_log_impl( (void *)&_mh_execute_header,  v43,  OS_LOG_TYPE_DEFAULT,  "Accepting out-of-band pairing request from device %{public}@ (%{public}@) with locally generated key bundle",  buf,  0x16u);
            }

            int v31 = sub_1001D3E40(&v52, 0LL, 0LL, uu);
          }

          else
          {
            __int16 v28 = (os_log_s *)qword_1008F75A8;
            if (os_log_type_enabled((os_log_t)qword_1008F75A8, OS_LOG_TYPE_DEFAULT))
            {
              id v29 = sub_1005BFB9C(v9);
              int v30 = (void *)objc_claimAutoreleasedReturnValue(v29);
              *(_DWORD *)__int128 buf = 138543618;
              id v57 = v8;
              __int16 v58 = 2114;
              uint64_t v59 = v30;
              _os_log_impl( (void *)&_mh_execute_header,  v28,  OS_LOG_TYPE_DEFAULT,  "Accepting out-of-band pairing request from device %{public}@ (%{public}@) with locally generated key bundle for 2-way OOB",  buf,  0x16u);
            }

            int v31 = sub_1001D3E40(&v52, (_OWORD *)a5, (_OWORD *)(a5 + 16), uu);
          }
        }

        int v41 = v31;
        if (v31)
        {
          uint64_t v42 = (os_log_s *)qword_1008F75A8;
          if (os_log_type_enabled((os_log_t)qword_1008F75A8, OS_LOG_TYPE_ERROR))
          {
            id v48 = sub_1005BFB9C(v9);
            int v49 = (void *)objc_claimAutoreleasedReturnValue(v48);
            *(_DWORD *)uuid_t uu = 138543874;
            *(void *)&uu[4] = v8;
            *(_WORD *)&uu[12] = 2114;
            *(void *)&uu[14] = v49;
            *(_WORD *)&uu[22] = 1024;
            *(_DWORD *)&uu[24] = v41;
            _os_log_error_impl( (void *)&_mh_execute_header,  v42,  OS_LOG_TYPE_ERROR,  "Failed to accept pairing for device %{public}@ (%{public}@) with result %{bluetooth:OI_STATUS}u - cancelling...",  uu,  0x1Cu);
          }

          sub_1001CBD38(&v52);
        }

        sub_100242CD8(&v50);
        sub_100242FAC((uint64_t)v51);
      }

      else
      {
        __int128 v33 = (os_log_s *)qword_1008F75A8;
        if (os_log_type_enabled((os_log_t)qword_1008F75A8, OS_LOG_TYPE_DEFAULT))
        {
          id v34 = sub_1005BFB9C(v9);
          __int16 v35 = (void *)objc_claimAutoreleasedReturnValue(v34);
          *(_DWORD *)uuid_t uu = 138543618;
          *(void *)&uu[4] = v8;
          *(_WORD *)&uu[12] = 2114;
          *(void *)&uu[14] = v35;
          _os_log_impl( (void *)&_mh_execute_header,  v33,  OS_LOG_TYPE_DEFAULT,  "Rejecting out-of-band pairing request from device %{public}@ (%{public}@)",  uu,  0x16u);
        }

        buf[0] = 0;
        sub_100242CA4(buf);
        int v36 = sub_1001CBD38(&v52);
        if (v36)
        {
          uint64_t v37 = (os_log_s *)qword_1008F75A8;
          if (os_log_type_enabled((os_log_t)qword_1008F75A8, OS_LOG_TYPE_ERROR))
          {
            id v46 = sub_1005BFB9C(v9);
            uint64_t v47 = (void *)objc_claimAutoreleasedReturnValue(v46);
            *(_DWORD *)uuid_t uu = 138543874;
            *(void *)&uu[4] = v8;
            *(_WORD *)&uu[12] = 2114;
            *(void *)&uu[14] = v47;
            *(_WORD *)&uu[22] = 1024;
            *(_DWORD *)&uu[24] = v36;
            _os_log_error_impl( (void *)&_mh_execute_header,  v37,  OS_LOG_TYPE_ERROR,  "Failed to cancel pairing to device %{public}@ (%{public}@) with result %{bluetooth:OI_STATUS}u",  uu,  0x1Cu);
          }
        }

        sub_100242CD8(buf);
      }
    }

    goto LABEL_39;
  }

  __int128 v32 = (os_log_s *)qword_1008F75A8;
  if (os_log_type_enabled((os_log_t)qword_1008F75A8, OS_LOG_TYPE_FAULT))
  {
    *(_WORD *)uuid_t uu = 0;
    _os_log_fault_impl( (void *)&_mh_execute_header,  v32,  OS_LOG_TYPE_FAULT,  "We don't have root keys for LE, something's wrong, file a radar!",  uu,  2u);
    if (*(_BYTE *)(a1 + 3718)) {
      goto LABEL_2;
    }
    __int128 v32 = (os_log_s *)qword_1008F75A8;
  }

  if (os_log_type_enabled(v32, OS_LOG_TYPE_ERROR)) {
    sub_10069EE4C();
  }
LABEL_39:
}

void sub_1006235F4( _Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, int a10, __int16 a11, char a12, char a13, char a14)
{
  _Unwind_Resume(a1);
}

_OWORD *sub_100623670(uint64_t a1, uint64_t a2, void *a3)
{
  unint64_t v25 = a2;
  id v4 = a3;
  __int128 v41 = 0u;
  __int128 v42 = 0u;
  __int128 v39 = 0u;
  __int128 v40 = 0u;
  __int128 v37 = 0u;
  __int128 v38 = 0u;
  __int128 v35 = 0u;
  __int128 v36 = 0u;
  __int128 v34 = 0u;
  __int128 v32 = 0u;
  __int128 v33 = 0u;
  __int128 v31 = 0u;
  v24[0] = 0LL;
  v24[1] = 0LL;
  sub_100242F28((uint64_t)v24, a1 + 48);
  char v23 = 0;
  sub_100242CA4(&v23);
  if (sub_1001D3CB8(&v31))
  {
    if (os_log_type_enabled((os_log_t)qword_1008F75A8, OS_LOG_TYPE_ERROR)) {
      sub_10069F060();
    }
    id v5 = 0LL;
  }

  else
  {
    id v5 = operator new(0xC0uLL);
    __int128 v6 = v32;
    *id v5 = v31;
    v5[1] = v6;
    __int128 v7 = v34;
    __int128 v8 = v35;
    void v5[2] = v33;
    v5[3] = v7;
    __int128 v9 = v36;
    __int128 v10 = v37;
    v5[4] = v8;
    void v5[5] = v9;
    __int128 v11 = v38;
    __int128 v12 = v39;
    void v5[6] = v10;
    v5[7] = v11;
    __int128 v13 = v42;
    __int128 v14 = v40;
    v5[10] = v41;
    v5[11] = v13;
    v5[8] = v12;
    v5[9] = v14;
    __p[0] = &v25;
    int v15 = sub_1002554E8((uint64_t **)(a1 + 536), &v25, (uint64_t)&unk_1006C2518, (uint64_t **)__p);
    sub_100241F90(__p, v4);
    *(void *)__int128 buf = __p;
    uint64_t v16 = sub_1006329D4( (uint64_t **)v15 + 5,  (unsigned __int8 *)__p,  (uint64_t)&unk_1006C2518,  (const unsigned __int8 *__attribute__((__org_typedef(uuid_t))) *)buf);
    __int128 v17 = (void *)v16[6];
    if (v17)
    {
      uint64_t v18 = (os_log_s *)qword_1008F75A8;
      if (!os_log_type_enabled((os_log_t)qword_1008F75A8, OS_LOG_TYPE_ERROR)) {
        goto LABEL_7;
      }
      sub_100494958(v25, (uint64_t)__p);
      if (v27 >= 0) {
        __int128 v22 = __p;
      }
      else {
        __int128 v22 = (void **)__p[0];
      }
      *(_DWORD *)__int128 buf = 138543618;
      *(void *)&uint8_t buf[4] = v4;
      __int16 v29 = 2082;
      int v30 = v22;
      _os_log_error_impl( (void *)&_mh_execute_header,  v18,  OS_LOG_TYPE_ERROR,  "Overwriting previously generated OOB data for device %{public}@ on session %{public}s",  buf,  0x16u);
      if (v27 < 0) {
        operator delete(__p[0]);
      }
      __int128 v17 = (void *)v16[6];
      if (v17) {
LABEL_7:
      }
        operator delete(v17);
    }

    __int128 v19 = (os_log_s *)qword_1008F75A8;
    if (os_log_type_enabled((os_log_t)qword_1008F75A8, OS_LOG_TYPE_DEFAULT))
    {
      sub_100494958(v25, (uint64_t)__p);
      __int128 v20 = v27 >= 0 ? __p : (void **)__p[0];
      *(_DWORD *)__int128 buf = 138543618;
      *(void *)&uint8_t buf[4] = v4;
      __int16 v29 = 2082;
      int v30 = v20;
      _os_log_impl( (void *)&_mh_execute_header,  v19,  OS_LOG_TYPE_DEFAULT,  "Generated OOB data for device %{public}@ on session %{public}s",  buf,  0x16u);
      if (v27 < 0) {
        operator delete(__p[0]);
      }
    }

    void v16[6] = (uint64_t)v5;
  }

  sub_100242CD8(&v23);
  sub_100242FAC((uint64_t)v24);

  return v5;
}

void sub_10062394C( _Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, int a9, __int16 a10, char a11, char a12, char a13)
{
  _Unwind_Resume(a1);
}

void sub_100623998(uint64_t a1, unint64_t a2, void *a3, char a4)
{
  unint64_t v17 = a2;
  id v6 = a3;
  v16[0] = 0LL;
  v16[1] = 0LL;
  sub_100242F28((uint64_t)v16, a1 + 48);
  *(void *)__int128 buf = &v17;
  __int128 v7 = sub_1002554E8((uint64_t **)(a1 + 536), &v17, (uint64_t)&unk_1006C2518, (uint64_t **)buf);
  sub_100241F90(buf, v6);
  __int128 v8 = (uint64_t **)(v7 + 5);
  const unsigned __int8 *__attribute__((__org_typedef(uuid_t))) v18 = buf;
  __int128 v9 = sub_1006329D4(v8, buf, (uint64_t)&unk_1006C2518, &v18);
  *((_BYTE *)v9 + 56) = a4;
  if ((a4 & 1) != 0)
  {
    __int128 v10 = (os_log_s *)qword_1008F75A8;
    BOOL v11 = os_log_type_enabled((os_log_t)qword_1008F75A8, OS_LOG_TYPE_DEFAULT);
    if (v6)
    {
      if (v11)
      {
        *(_DWORD *)__int128 buf = 138543362;
        *(void *)&uint8_t buf[4] = v6;
        _os_log_impl( (void *)&_mh_execute_header,  v10,  OS_LOG_TYPE_DEFAULT,  "Enabling out-of-band pairing for device %{public}@",  buf,  0xCu);
      }

      if (qword_1008D5F30 != -1) {
        dispatch_once(&qword_1008D5F30, &stru_1008A45D8);
      }
      unint64_t v12 = sub_1005CC198((uint64_t)off_1008D5F28, v6, 0);
    }

    else
    {
      if (v11)
      {
        *(_WORD *)__int128 buf = 0;
        _os_log_impl( (void *)&_mh_execute_header,  v10,  OS_LOG_TYPE_DEFAULT,  "Enabling out-of-band pairing for all devices",  buf,  2u);
      }

      unint64_t v12 = 0LL;
    }

    uint64_t v14 = sub_1001BCDB0(v12);
    *(_DWORD *)__int128 buf = v14;
    buf[6] = BYTE6(v14);
    *(_WORD *)&uint8_t buf[4] = WORD2(v14);
    LOBYTE(v1_Block_object_dispose(va, 8) = 0;
    sub_100242CA4(&v18);
    if (v6) {
      int v15 = (int *)buf;
    }
    else {
      int v15 = 0LL;
    }
    sub_100242CD8(&v18);
  }

  else
  {
    if (!v9[6])
    {
      sub_100241F90(buf, v6);
      __int128 v13 = (uint64_t *)sub_1001FDB10((uint64_t)v8, buf);
      sub_1001FDBCC(v8, v13);
      operator delete(v13);
    }

    sub_100623C48(a1, v6);
  }

  sub_100242FAC((uint64_t)v16);
}

void sub_100623BF8(_Unwind_Exception *a1, uint64_t a2, ...)
{
  _Unwind_Resume(a1);
}

void sub_100623C48(uint64_t a1, void *a2)
{
  id v3 = a2;
  id v4 = *(void **)(a1 + 536);
  if (v4 == (void *)(a1 + 544))
  {
LABEL_21:
    if (!*(_BYTE *)(a1 + 41)) {
      goto LABEL_39;
    }
    char v23 = 0;
    sub_100242CA4(&v23);
    int v15 = (os_log_s *)qword_1008F75A8;
    BOOL v16 = os_log_type_enabled((os_log_t)qword_1008F75A8, OS_LOG_TYPE_DEFAULT);
    if (v3)
    {
      if (v16)
      {
        *(_DWORD *)__int128 buf = 138543362;
        id v25 = v3;
        _os_log_impl( (void *)&_mh_execute_header,  v15,  OS_LOG_TYPE_DEFAULT,  "Disabling out-of-band pairing for device %{public}@",  buf,  0xCu);
      }

      if (qword_1008D5F30 != -1) {
        dispatch_once(&qword_1008D5F30, &stru_1008A45D8);
      }
      unint64_t v17 = sub_1005CC198((uint64_t)off_1008D5F28, v3, 0);
      uint64_t v18 = sub_1001BCDB0(v17);
      *(_DWORD *)__int128 buf = v18;
      BYTE2(v25) = BYTE6(v18);
      LOWORD(v25) = WORD2(v18);
      int v19 = sub_1001C80AC((int *)buf, 0);
      if (v19 != 120) {
        goto LABEL_35;
      }
      if (qword_1008D5F30 != -1) {
        dispatch_once(&qword_1008D5F30, &stru_1008A45D8);
      }
      unint64_t v20 = sub_1005CC198((uint64_t)off_1008D5F28, v3, 1);
      uint64_t v21 = sub_1001BCDB0(v20);
      *(_DWORD *)__int128 buf = v21;
      BYTE2(v25) = BYTE6(v21);
      LOWORD(v25) = WORD2(v21);
      int v22 = sub_1001C80AC((int *)buf, 0);
    }

    else
    {
      if (v16)
      {
        *(_WORD *)__int128 buf = 0;
        _os_log_impl( (void *)&_mh_execute_header,  v15,  OS_LOG_TYPE_DEFAULT,  "Disabling out-of-band pairing for all devices",  buf,  2u);
      }

      int v22 = sub_1001C80AC(0LL, 0);
    }

    int v19 = v22;
LABEL_35:
    if (v19 && os_log_type_enabled((os_log_t)qword_1008F75A8, OS_LOG_TYPE_ERROR)) {
      sub_10069F124();
    }
    sub_100242CD8(&v23);
    goto LABEL_39;
  }

  char v5 = 1;
  do
  {
    id v6 = (const unsigned __int8 *)v4[5];
    while (1)
    {
      __int128 v7 = sub_100241F94(v6 + 32);
      __int128 v8 = (void *)objc_claimAutoreleasedReturnValue(v7);
      if (![v3 isEqual:v8])
      {

        goto LABEL_8;
      }

      int v9 = v6[56];

      if (v9) {
        break;
      }
LABEL_8:
      __int128 v10 = (unsigned __int8 *)*((void *)v6 + 1);
      if (v10)
      {
        do
        {
          BOOL v11 = (const unsigned __int8 **)v10;
          __int128 v10 = *(unsigned __int8 **)v10;
        }

        while (v10);
      }

      else
      {
        do
        {
          BOOL v11 = (const unsigned __int8 **)*((void *)v6 + 2);
          BOOL v12 = *v11 == v6;
          id v6 = (const unsigned __int8 *)v11;
        }

        while (!v12);
      }

      id v6 = (const unsigned __int8 *)v11;
      if (v11 == v4 + 6) {
        goto LABEL_14;
      }
    }

    char v5 = 0;
LABEL_14:
    __int128 v13 = (void *)v4[1];
    if (v13)
    {
      do
      {
        uint64_t v14 = v13;
        __int128 v13 = (void *)*v13;
      }

      while (v13);
    }

    else
    {
      do
      {
        uint64_t v14 = (void *)v4[2];
        BOOL v12 = *v14 == (void)v4;
        id v4 = v14;
      }

      while (!v12);
    }

    id v4 = v14;
  }

  while (v14 != (void *)(a1 + 544));
  if ((v5 & 1) != 0) {
    goto LABEL_21;
  }
LABEL_39:
}

void sub_100623F34( _Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, int a10, __int16 a11, char a12, char a13)
{
  _Unwind_Resume(a1);
}

uint64_t sub_100623F78(uint64_t a1, unint64_t a2)
{
  v18[0] = 0LL;
  v18[1] = 0LL;
  sub_100242F28((uint64_t)v18, a1 + 48);
  id v4 = *(void **)(a1 + 544);
  if (v4)
  {
    uint64_t v5 = a1 + 544;
    do
    {
      unint64_t v6 = v4[4];
      BOOL v7 = v6 >= a2;
      if (v6 >= a2) {
        __int128 v8 = v4;
      }
      else {
        __int128 v8 = v4 + 1;
      }
      if (v7) {
        uint64_t v5 = (uint64_t)v4;
      }
      id v4 = (void *)*v8;
    }

    while (*v8);
    if (v5 != a1 + 544 && *(void *)(v5 + 32) <= a2)
    {
      int v9 = *(unsigned __int8 **)(v5 + 40);
      if (v9 != (unsigned __int8 *)(v5 + 48))
      {
        do
        {
          memset(dst, 0, sizeof(dst));
          uuid_copy(dst, v9 + 32);
          __int128 v10 = (void *)*((void *)v9 + 6);
          if (v10) {
            operator delete(v10);
          }
          BOOL v11 = (unsigned __int8 *)*((void *)v9 + 1);
          BOOL v12 = v9;
          if (v11)
          {
            do
            {
              __int128 v13 = v11;
              BOOL v11 = *(unsigned __int8 **)v11;
            }

            while (v11);
          }

          else
          {
            do
            {
              __int128 v13 = (unsigned __int8 *)*((void *)v12 + 2);
              BOOL v14 = *(void *)v13 == (void)v12;
              BOOL v12 = v13;
            }

            while (!v14);
          }

          sub_1001FDBCC((uint64_t **)(v5 + 40), (uint64_t *)v9);
          operator delete(v9);
          int v15 = sub_100241F94(dst);
          BOOL v16 = (void *)objc_claimAutoreleasedReturnValue(v15);
          sub_100623C48(a1, v16);

          int v9 = v13;
        }

        while (v13 != (unsigned __int8 *)(v5 + 48));
      }

      sub_10032982C((uint64_t **)(a1 + 536), v5);
    }
  }

  return sub_100242FAC((uint64_t)v18);
}

void sub_1006240EC(_Unwind_Exception *a1, uint64_t a2, ...)
{
}

id sub_10062411C(uint64_t a1, unint64_t a2, uint64_t a3, uint64_t a4, const std::string *a5)
{
  v28[0] = 0LL;
  v28[1] = 0LL;
  sub_100242F28((uint64_t)v28, a1 + 48);
  unint64_t v10 = *(void *)(a1 + 456);
  if (v10 >= *(unsigned __int16 *)(a1 + 3736))
  {
    BOOL v11 = (os_log_s *)qword_1008F75A8;
    if (os_log_type_enabled((os_log_t)qword_1008F75A8, OS_LOG_TYPE_DEFAULT))
    {
      *(_DWORD *)__int128 buf = 134217984;
      *(void *)&uint8_t buf[4] = v10;
      _os_log_impl( (void *)&_mh_execute_header,  v11,  OS_LOG_TYPE_DEFAULT,  "Too many paired devices (%lu), but cloud paired devices are allowed",  buf,  0xCu);
    }
  }

  *(_OWORD *)__int128 buf = 0uLL;
  sub_10032BA60(*(void *)(a4 + 8), 10, buf);
  *(void *)std::string uu2 = 0LL;
  uint64_t v31 = 0LL;
  if (qword_1008D5F30 != -1) {
    dispatch_once(&qword_1008D5F30, &stru_1008A45D8);
  }
  BOOL v12 = off_1008D5F28;
  else {
    __int128 v13 = (__int128 *)sub_10056AAF0((uint64_t)buf);
  }
  sub_1005C8684((uint64_t)v12, a2, 1u, 0, 0LL, v13, uu2);
  if (qword_1008D5F30 != -1) {
    dispatch_once(&qword_1008D5F30, &stru_1008A45D8);
  }
  BOOL v14 = off_1008D5F28;
  if (*(char *)(a3 + 23) < 0)
  {
    sub_100024238(__p, *(void **)a3, *(void *)(a3 + 8));
  }

  else
  {
    *(_OWORD *)std::stringbuf::string_type __p = *(_OWORD *)a3;
    uint64_t v27 = *(void *)(a3 + 16);
  }

  sub_1005C9550((uint64_t)v14, uu2, (uint64_t)__p, 2);
  if (SHIBYTE(v27) < 0) {
    operator delete(__p[0]);
  }
  if (a1 + 472 != sub_1001FDB10(a1 + 464, uu2))
  {
    int v15 = (os_log_s *)qword_1008F75A8;
    if (os_log_type_enabled((os_log_t)qword_1008F75A8, OS_LOG_TYPE_FAULT)) {
      sub_10069F184(v15, v16, v17);
    }
  }

  __int16 v29 = uu2;
  uint64_t v18 = sub_100632688( (uint64_t **)(a1 + 464),  uu2,  (uint64_t)&unk_1006C2518,  (const unsigned __int8 *__attribute__((__org_typedef(uuid_t))) *)&v29);
  sub_10002EAC8((uint64_t)(v18 + 6), a4);
  if (qword_1008D5F30 != -1) {
    dispatch_once(&qword_1008D5F30, &stru_1008A45D8);
  }
  int v19 = off_1008D5F28;
  unint64_t v20 = sub_100241F94(uu2);
  uint64_t v21 = (void *)objc_claimAutoreleasedReturnValue(v20);
  unint64_t v22 = sub_1005CC198((uint64_t)v19, v21, 0);
  sub_100624468(a1, v22, a2, 0, a5);

  char v23 = sub_100241F94(uu2);
  __int128 v24 = (void *)objc_claimAutoreleasedReturnValue(v23);
  *(void *)__int128 buf = &off_10087FAA8;
  if (*(void *)&buf[8]) {
    sub_1002CD254(*(unsigned int **)&buf[8]);
  }
  sub_100242FAC((uint64_t)v28);
  return v24;
}

void sub_100624404( _Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, void *__p, uint64_t a10, int a11, __int16 a12, char a13, char a14, uint64_t a15, char a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20, uint64_t a21, uint64_t (**a22)(), unsigned int *a23)
{
  a22 = &off_10087FAA8;
  if (a23) {
    sub_1002CD254(a23);
  }
  sub_100242FAC((uint64_t)&a16);
  _Unwind_Resume(a1);
}

void sub_100624468(uint64_t a1, unint64_t a2, unint64_t a3, int a4, const std::string *a5)
{
  if (*(_BYTE *)(a1 + 41))
  {
    uint64_t v10 = sub_1001BCDB0(a2);
    *(_DWORD *)src = v10;
    src[6] = BYTE6(v10);
    *(_WORD *)&src[4] = WORD2(v10);
    LOBYTE(v141) = 0;
    sub_100242CA4(&v141);
    uint64_t v11 = sub_10012D98C(src);
    sub_100242CD0(&v141);
    if (v11)
    {
      if (qword_1008D5F10 != -1) {
        dispatch_once(&qword_1008D5F10, &stru_1008A45F8);
      }
      sub_100593548((uint64_t)off_1008D5F08, v11, uu);
    }

    sub_100242CD8(&v141);
  }

  if (uuid_is_null(uu))
  {
    if (qword_1008D5F30 != -1) {
      dispatch_once(&qword_1008D5F30, &stru_1008A45D8);
    }
    sub_1005C8684((uint64_t)off_1008D5F28, a2, 0, 1u, 0LL, 0LL, src);
    uuid_copy(uu, src);
    if (uuid_is_null(uu))
    {
      if (qword_1008D5F30 != -1) {
        dispatch_once(&qword_1008D5F30, &stru_1008A45D8);
      }
      sub_1005C8684((uint64_t)off_1008D5F28, a3, 0, 1u, 0LL, 0LL, src);
      uuid_copy(uu, src);
    }
  }

  BOOL v12 = (os_log_s *)qword_1008F75A8;
  if (os_log_type_enabled((os_log_t)qword_1008F75A8, OS_LOG_TYPE_INFO))
  {
    id v13 = sub_1005BFB9C(a2);
    id v14 = (id)objc_claimAutoreleasedReturnValue(v13);
    *(_DWORD *)src = 138543618;
    *(void *)&src[4] = v14;
    *(_WORD *)&src[12] = 1024;
    *(_DWORD *)&src[14] = a4;
    _os_log_impl( (void *)&_mh_execute_header,  v12,  OS_LOG_TYPE_INFO,  "Device %{public}@ finished pairing with status  %{bluetooth:OI_STATUS}u",  src,  0x12u);
  }

  if (uuid_is_null(uu))
  {
    int v15 = (os_log_s *)qword_1008F75A8;
    if (os_log_type_enabled((os_log_t)qword_1008F75A8, OS_LOG_TYPE_INFO))
    {
      id v16 = sub_1005BFB9C(a2);
      uint64_t v17 = (void *)objc_claimAutoreleasedReturnValue(v16);
      *(_DWORD *)src = 138543362;
      *(void *)&src[4] = v17;
      _os_log_impl( (void *)&_mh_execute_header,  v15,  OS_LOG_TYPE_INFO,  "Device %{public}@ finished pairing but wasn't being tracked by device manager, ignoring this event",  src,  0xCu);
    }

    return;
  }

  v130[0] = 0LL;
  v130[1] = 0LL;
  sub_100242F28((uint64_t)v130, a1 + 48);
  uint64_t v18 = (uint64_t **)(a1 + 464);
  int v109 = (uint64_t *)sub_1001FDB10(a1 + 464, uu);
  int v19 = &OBJC_INSTANCE_METHODS_iapUUID;
  if (a4)
  {
    if (a4 != 4832)
    {
      if (os_log_type_enabled((os_log_t)qword_1008F75A8, OS_LOG_TYPE_ERROR))
      {
        sub_100366664(uu, src);
        sub_10069F224();
      }

      switch(a4)
      {
        case 4818:
          int v62 = 173;
          break;
        case 4819:
          int v62 = 174;
          break;
        case 4820:
        case 4821:
        case 4822:
        case 4823:
        case 4826:
LABEL_118:
          int v62 = 1;
          break;
        case 4824:
          int v62 = 175;
          break;
        case 4825:
          int v62 = 176;
          break;
        case 4827:
          int v62 = 172;
          break;
        default:
          int v62 = 170;
          switch(a4)
          {
            case 4805:
              goto LABEL_135;
            case 4806:
              goto LABEL_118;
            case 4807:
              int v62 = 171;
              break;
            case 4808:
              if (a3)
              {
                __int128 buf = 0uLL;
                if (qword_1008D5F30 != -1) {
                  dispatch_once(&qword_1008D5F30, &stru_1008A45D8);
                }
                sub_1005C8684((uint64_t)off_1008D5F28, a3, 0, 1u, 0LL, 0LL, (unsigned __int8 *)&buf);
                if (uuid_is_null((const unsigned __int8 *)&buf)
                  && os_log_type_enabled((os_log_t)qword_1008F75A8, OS_LOG_TYPE_FAULT))
                {
                  sub_10069F1F8();
                }

                if (!uuid_is_null((const unsigned __int8 *)&buf))
                {
                  if (qword_1008D5F30 != -1) {
                    dispatch_once(&qword_1008D5F30, &stru_1008A45D8);
                  }
                  __int128 v95 = off_1008D5F28;
                  uint64_t v96 = sub_100241F94(uu);
                  __int128 v97 = (void *)objc_claimAutoreleasedReturnValue(v96);
                  __int128 v98 = sub_100241F94((const unsigned __int8 *)&buf);
                  __int128 v99 = (void *)objc_claimAutoreleasedReturnValue(v98);
                  sub_1005D0A68((uint64_t)v95, v97, v99);
                }
              }

              int v62 = 168;
              break;
            case 4809:
              int v62 = 167;
              break;
            default:
              if (a4 != 4835) {
                goto LABEL_118;
              }
              int v62 = 180;
              break;
          }

          break;
      }

LABEL_135:
      goto LABEL_137;
    }

    if (qword_1008D5F30 != -1) {
      dispatch_once(&qword_1008D5F30, &stru_1008A45D8);
    }
    unint64_t v20 = off_1008D5F28;
    uint64_t v21 = sub_100241F94(uu);
    unint64_t v22 = (void *)objc_claimAutoreleasedReturnValue(v21);
    sub_10002418C(__p, "_UNPAIR_AFTER_DISCONNECTION_");
    sub_1005CCF08((uint64_t)v20, v22, (unsigned __int8 *)__p);
    if (v129 < 0) {
      operator delete(__p[0]);
    }

    char v23 = sub_100241F94(uu);
    __int128 v24 = (void *)objc_claimAutoreleasedReturnValue(v23);
    sub_10062C530(a1, v24);

    uint64_t v25 = sub_100404FE8();
    *(void *)src = _NSConcreteStackBlock;
    *(void *)&unsigned __int8 src[8] = 3221225472LL;
    *(void *)&unsigned __int8 src[16] = sub_10062BAC4;
    *(void *)&src[24] = &unk_10087EB20;
    *(void *)&src[32] = a1;
    sub_100405384(v25, src);
  }

  BOOL v26 = (os_log_s *)qword_1008F75A8;
  if (os_log_type_enabled((os_log_t)qword_1008F75A8, OS_LOG_TYPE_DEFAULT))
  {
    memset(src, 0, 37);
    uuid_unparse_upper(uu, src);
    sub_10002418C(&v141, src);
    uint64_t v27 = v143 >= 0
        ? (const unsigned __int8 *__attribute__((__org_typedef(uuid_t))) *)&v141
        : (const unsigned __int8 *__attribute__((__org_typedef(uuid_t))) *)v141;
    LODWORD(buf) = 136446210;
    *(void *)((char *)&buf + 4) = v27;
    _os_log_impl( (void *)&_mh_execute_header,  v26,  OS_LOG_TYPE_DEFAULT,  "Pairing succeeded to device %{public}s",  (uint8_t *)&buf,  0xCu);
    if (v143 < 0) {
      operator delete(v141);
    }
  }

  if (qword_1008D5F30 != -1) {
    dispatch_once(&qword_1008D5F30, &stru_1008A45D8);
  }
  __int16 v28 = off_1008D5F28;
  __int16 v29 = sub_100241F94(uu);
  int v30 = (void *)objc_claimAutoreleasedReturnValue(v29);
  sub_1005CF11C((uint64_t)v28, v30, a5);

  if (qword_1008D5F30 != -1) {
    dispatch_once(&qword_1008D5F30, &stru_1008A45D8);
  }
  uint64_t v31 = off_1008D5F28;
  __int128 v32 = sub_100241F94(uu);
  __int128 v33 = (void *)objc_claimAutoreleasedReturnValue(v32);
  sub_1005D3868((uint64_t)v31, v33, 1, 2, 0);

  sub_10062A96C(a1, uu);
  if ((uint64_t *)(a1 + 472) == v109)
  {
    __int128 v63 = operator new(0x28uLL);
    v63[2] = 1;
    *(void *)__int128 v63 = &off_10089A468;
    *((void *)v63 + 4) = 0LL;
    *((void *)v63 + 3) = 0LL;
    *((void *)v63 + 2) = v63 + 6;
    *(void *)src = &off_10089A548;
    *(void *)&unsigned __int8 src[8] = v63;
    LOBYTE(v126) = 1;
    sub_10056AB04(&v141, &v126, 1uLL);
    sub_10032B1F8((uint64_t)v63, 17, (uint64_t)&v141);
    uint64_t v141 = (unsigned __int8 *)&off_10087FAA8;
    if (v142) {
      sub_1002CD254(v142);
    }
    uint64_t v141 = uu;
    __int128 v64 = sub_100632688( (uint64_t **)(a1 + 440),  uu,  (uint64_t)&unk_1006C2518,  (const unsigned __int8 *__attribute__((__org_typedef(uuid_t))) *)&v141);
    sub_10002EAC8((uint64_t)(v64 + 6), (uint64_t)src);
    *(void *)src = &off_10089A548;
    __int128 v65 = *(unsigned int **)&src[8];
    if (!*(void *)&src[8]) {
      goto LABEL_114;
    }
  }

  else
  {
    uint64_t v34 = v109[7];
    *(void *)&__int128 buf = &off_10089A548;
    *((void *)&buf + 1) = v34;
    if (v34) {
      sub_1002CD1E0(v34);
    }
    if (a3)
    {
      sub_10032BA60(*((uint64_t *)&buf + 1), 11, src);
      uint64_t v35 = *(unsigned __int8 *)(sub_10056AAF0((uint64_t)src) + 1);
      sub_10032BA60(*((uint64_t *)&buf + 1), 11, &v141);
      uint64_t v36 = *(unsigned __int8 *)(sub_10056AAF0((uint64_t)&v141) + 2);
      sub_10032BA60(*((uint64_t *)&buf + 1), 11, &v126);
      unint64_t v108 = a3;
      uint64_t v37 = *(unsigned __int8 *)(sub_10056AAF0((uint64_t)&v126) + 3);
      sub_10032BA60(*((uint64_t *)&buf + 1), 11, &v124);
      uint64_t v38 = *(unsigned __int8 *)(sub_10056AAF0((uint64_t)&v124) + 4);
      sub_10032BA60(*((uint64_t *)&buf + 1), 11, &v138);
      uint64_t v39 = *(unsigned __int8 *)(sub_10056AAF0((uint64_t)&v138) + 5);
      sub_10032BA60(*((uint64_t *)&buf + 1), 11, &v122);
      uint64_t v40 = *(unsigned __int8 *)(sub_10056AAF0((uint64_t)&v122) + 6);
      sub_10032BA60(*((uint64_t *)&buf + 1), 11, &v120);
      uint64_t v41 = v35 << 40;
      uint64_t v42 = *(unsigned __int8 *)sub_10056AAF0((uint64_t)&v120);
      int v120 = &off_10087FAA8;
      if (v121) {
        sub_1002CD254(v121);
      }
      uint64_t v43 = v41 | (v36 << 32);
      __int128 v122 = &off_10087FAA8;
      if (v123) {
        sub_1002CD254(v123);
      }
      uint64_t v44 = v43 | (v37 << 24);
      int v138 = &off_10087FAA8;
      if (v139) {
        sub_1002CD254(v139);
      }
      uint64_t v45 = v44 | (v38 << 16);
      unint64_t v124 = &off_10087FAA8;
      if (v125) {
        sub_1002CD254(v125);
      }
      uint64_t v46 = v45 | (v39 << 8);
      unint64_t v126 = &off_10087FAA8;
      if (v127) {
        sub_1002CD254(v127);
      }
      uint64_t v47 = v46 | v40;
      uint64_t v141 = (unsigned __int8 *)&off_10087FAA8;
      int v19 = &OBJC_INSTANCE_METHODS_iapUUID;
      if (v142) {
        sub_1002CD254(v142);
      }
      uint64_t v48 = v47 | (v42 << 48);
      *(void *)src = &off_10087FAA8;
      if (*(void *)&src[8]) {
        sub_1002CD254(*(unsigned int **)&src[8]);
      }
      uint64_t v18 = (uint64_t **)(a1 + 464);
      if (v48 != v108)
      {
        int v49 = (os_log_s *)qword_1008F75A8;
        if (os_log_type_enabled((os_log_t)qword_1008F75A8, OS_LOG_TYPE_FAULT))
        {
          id v50 = sub_1005BFB9C(v108);
          id v51 = (id)objc_claimAutoreleasedReturnValue(v50);
          id v52 = sub_1005BFB9C(v48);
          __int16 v53 = (void *)objc_claimAutoreleasedReturnValue(v52);
          sub_10069F2F4(v51, v53, (uint64_t)&v141, v49);
        }
      }

      sub_10032BA60(*((uint64_t *)&buf + 1), 10, src);
      BOOL v54 = sub_10056AAC8((uint64_t)src);
      *(void *)src = &off_10087FAA8;
      if (*(void *)&src[8]) {
        sub_1002CD254(*(unsigned int **)&src[8]);
      }
      if (v54)
      {
        unint64_t v55 = (os_log_s *)qword_1008F75A8;
        if (os_log_type_enabled((os_log_t)qword_1008F75A8, OS_LOG_TYPE_FAULT))
        {
          id v56 = sub_1005BFB9C(a2);
          id v57 = (void *)objc_claimAutoreleasedReturnValue(v56);
          sub_10069F290(v57, (uint64_t)&v138, v55);
        }
      }

      if (qword_1008D5F30 != -1) {
        dispatch_once(&qword_1008D5F30, &stru_1008A45D8);
      }
      sub_1005D1778((uint64_t)off_1008D5F28, uu, v108);
      if (*(_BYTE *)(a1 + 41))
      {
        if (qword_1008D5F30 != -1) {
          dispatch_once(&qword_1008D5F30, &stru_1008A45D8);
        }
        __int16 v58 = off_1008D5F28;
        uint64_t v59 = sub_100241F94(uu);
        char v60 = (void *)objc_claimAutoreleasedReturnValue(v59);
        sub_10002418C(v118, "IsAppleWatch");
        if ((sub_1005CE5A8((uint64_t)v58, v60, (uint64_t)v118) & 1) != 0)
        {
          int v61 = 1;
        }

        else
        {
          if (qword_1008D5F30 != -1) {
            dispatch_once(&qword_1008D5F30, &stru_1008A45D8);
          }
          __int128 v66 = off_1008D5F28;
          __int128 v67 = sub_100241F94(uu);
          __int128 v68 = (void *)objc_claimAutoreleasedReturnValue(v67);
          int v61 = sub_1005CE518((uint64_t)v66, v68);
        }

        if (v119 < 0) {
          operator delete(v118[0]);
        }

        if (v61)
        {
          if (qword_1008D5F30 != -1) {
            dispatch_once(&qword_1008D5F30, &stru_1008A45D8);
          }
          sub_1005D1594((uint64_t)off_1008D5F28, uu, v108);
          uint64_t v69 = sub_100404FE8();
          __int128 v70 = operator new(0x28uLL);
          v70[4] = 1;
          *(void *)__int128 v70 = &off_1008A4538;
          *((void *)v70 + 2) = v108;
          *((void *)v70 + 3) = 0LL;
          *((_BYTE *)v70 + 32) = 1;
          sub_100405744(v69, v70);
        }

        uint64_t v71 = sub_100404FE8();
        unint64_t v72 = operator new(0x28uLL);
        sub_10032BA60(*((uint64_t *)&buf + 1), 10, src);
        char v73 = (_OWORD *)sub_10056AAF0((uint64_t)src);
        v72[4] = 1;
        *(void *)unint64_t v72 = &off_1008A4538;
        *((void *)v72 + 2) = v108;
        *((void *)v72 + 3) = 0LL;
        *((_BYTE *)v72 + 32) = 0;
        if (v73)
        {
          std::string v74 = operator new[](0x10uLL);
          *((void *)v72 + 3) = v74;
          *std::string v74 = *v73;
        }

        sub_100405744(v71, v72);
        *(void *)src = &off_10087FAA8;
        if (*(void *)&src[8]) {
          sub_1002CD254(*(unsigned int **)&src[8]);
        }
        uint64_t v75 = sub_1002E6E9C();
        int v19 = &OBJC_INSTANCE_METHODS_iapUUID;
        (*(void (**)(uint64_t, unint64_t, uint64_t))(*(void *)v75 + 1128LL))(v75, a2, 1LL);
      }
    }

    *(void *)src = uu;
    char v76 = sub_100632688( (uint64_t **)(a1 + 440),  uu,  (uint64_t)&unk_1006C2518,  (const unsigned __int8 *__attribute__((__org_typedef(uuid_t))) *)src);
    sub_10002EAC8((uint64_t)(v76 + 6), (uint64_t)&buf);
    sub_100632AF0(v18, v109);
    uint64_t v77 = sub_100404FE8();
    char v78 = operator new(0x38uLL);
    if (qword_1008D5F30 != -1) {
      dispatch_once(&qword_1008D5F30, &stru_1008A45D8);
    }
    char v79 = off_1008D5F28;
    unsigned __int8 v80 = sub_100241F94(uu);
    unint64_t v81 = (void *)objc_claimAutoreleasedReturnValue(v80);
    uint64_t v82 = sub_1005CC198((uint64_t)v79, v81, 0);
    uuid_copy(dst, uu);
    sub_100631690((uint64_t)v78, v82, dst, (uint64_t)&buf);
    sub_100405744(v77, v78);

    if (*(_BYTE *)(a1 + 41))
    {
      unint64_t v126 = 0LL;
      __int128 v127 = 0LL;
      sub_10032BA60(*((uint64_t *)&buf + 1), 10, &v126);
      memset(src, 0, 20);
      sub_10052523C((uint64_t)src);
      if (!sub_10056AAC8((uint64_t)&v126))
      {
        sub_10032BA60(*((uint64_t *)&buf + 1), 11, &v124);
        int v84 = (int *)sub_10056AAF0((uint64_t)&v124);
        uint64_t v85 = (_OWORD *)sub_10056AAF0((uint64_t)&v126);
        sub_10061E118(a1, v84, v85);
        unint64_t v124 = &off_10087FAA8;
        if (v125) {
          sub_1002CD254(v125);
        }
      }

      nullsub_63(src, v83);
      unint64_t v126 = &off_10087FAA8;
      if (v127) {
        sub_1002CD254(v127);
      }
    }

    if (qword_1008D5F30 != -1) {
      dispatch_once(&qword_1008D5F30, &stru_1008A45D8);
    }
    BOOL v86 = off_1008D5F28;
    uint64_t v87 = sub_100241F94(uu);
    __int16 v88 = (void *)objc_claimAutoreleasedReturnValue(v87);
    LODWORD(v86) = sub_1005D4EDC((uint64_t)v86, v88);

    if ((_DWORD)v86)
    {
      if (qword_1008D5F30 != -1) {
        dispatch_once(&qword_1008D5F30, &stru_1008A45D8);
      }
      int v89 = off_1008D5F28;
      __int16 v90 = sub_100241F94(uu);
      int v91 = (void *)objc_claimAutoreleasedReturnValue(v90);
      sub_10002418C(v116, "_HIDEINSETTINGS_");
      sub_1005CCF08((uint64_t)v89, v91, (unsigned __int8 *)v116);
      if (v117 < 0) {
        operator delete(v116[0]);
      }
    }

    *(void *)src = 0LL;
    *(void *)&unsigned __int8 src[8] = src;
    *(void *)&unsigned __int8 src[16] = 0x8812000000LL;
    *(void *)&src[24] = sub_10062C764;
    *(void *)&src[32] = nullsub_589;
    uint64_t v134 = &unk_1007C41D6;
    memset(v135, 0, sizeof(v135));
    int v136 = 0;
    sub_10061D7EC(a1, (uint64_t)&buf, v135);
    uint64_t v92 = sub_100404FE8();
    v131[0] = _NSConcreteStackBlock;
    v131[1] = 3321888768LL;
    v131[2] = sub_10062C78C;
    v131[3] = &unk_1008A4440;
    uuid_copy(v132, uu);
    v131[4] = src;
    sub_100405384(v92, v131);
    _Block_object_dispose(src, 8);
    *(void *)&__int128 buf = &off_10089A548;
    __int128 v65 = (unsigned int *)*((void *)&buf + 1);
    if (!*((void *)&buf + 1)) {
      goto LABEL_114;
    }
  }

  sub_1002CD254(v65);
LABEL_114:
  __n128 v93 = (os_log_s *)qword_1008F75A8;
  int v62 = 0;
  if (os_log_type_enabled((os_log_t)qword_1008F75A8, OS_LOG_TYPE_DEFAULT))
  {
    uint64_t v94 = *(void *)(a1 + 456);
    *(_DWORD *)src = 134217984;
    *(void *)&src[4] = v94;
    _os_log_impl((void *)&_mh_execute_header, v93, OS_LOG_TYPE_DEFAULT, "Number of LE Paired devices:%lu", src, 0xCu);
    int v62 = 0;
  }

                  if ((buf[23] & 0x80000000) == 0) {
                    return;
                  }
                  char v73 = *(void **)buf;
                  goto LABEL_137;
                }

                if (strcmp(a2, "LeaStoreBondingInfoRequest"))
                {
                  if (strcmp(a2, "LeaStoreBondingInfoResponse"))
                  {
                    if (!strcmp(a2, "UARPDataOverAACP"))
                    {
                      BOOL v7 = -[NSString initWithUTF8String:]( objc_alloc(&OBJC_CLASS___NSString),  "initWithUTF8String:",  xpc_dictionary_get_string(a3, "kUARPDeviceUUID"));
                      __int128 v8 = -[NSUUID initWithUUIDString:](objc_alloc(&OBJC_CLASS___NSUUID), "initWithUUIDString:", v7);
                      if (qword_1008D5F30 != -1) {
                        dispatch_once(&qword_1008D5F30, &stru_1008A4F88);
                      }
                      int v9 = sub_1005CC198((uint64_t)off_1008D5F28, v8, 0);
                      if (qword_1008D5F50 != -1) {
                        dispatch_once(&qword_1008D5F50, &stru_1008A4FA8);
                      }
                      uint64_t v10 = sub_10040007C(off_1008D5F48, v9, 1);
                      if (v10)
                      {
                        *(void *)__int128 buf = 0LL;
                        uint64_t v11 = xpc_dictionary_get_data(a3, "kUARPData", (size_t *)buf);
                        if (v11 && (BOOL v12 = *(void *)buf) != 0)
                        {
                          id v13 = malloc(*(size_t *)buf);
                          if (v13)
                          {
                            id v14 = v13;
                            memcpy(v13, v11, v12);
                            if (qword_1008D60E0 != -1) {
                              dispatch_once(&qword_1008D60E0, &stru_1008A5048);
                            }
                            if (sub_100222DD4( (uint64_t)off_1008D60D8,  (uint64_t)v10,  *(unsigned __int16 *)buf,  v14))
                            {
                              if (os_log_type_enabled((os_log_t)qword_1008F75A0, OS_LOG_TYPE_ERROR)) {
                                sub_1006A0F58();
                              }
                            }

                            free(v14);
                          }

                          else if (os_log_type_enabled((os_log_t)qword_1008F75A0, OS_LOG_TYPE_ERROR))
                          {
                            sub_1006A0F2C();
                          }
                        }

                        else if (os_log_type_enabled((os_log_t)qword_1008F75A0, OS_LOG_TYPE_ERROR))
                        {
                          sub_1006A0F00();
                        }
                      }

                      else if (os_log_type_enabled((os_log_t)qword_1008F75A0, OS_LOG_TYPE_ERROR))
                      {
                        sub_1006A0ED4();
                      }
                    }

                    return;
                  }

                  memset(buf, 0, 24);
                  char v241 = (char *)xpc_dictionary_get_string(a3, "kLeaDeviceAddress");
                  sub_10002418C(buf, v241);
                  BOOL v242 = xpc_dictionary_get_int64(a3, "kLeaStoreBondingInfoResult");
                  WORD2(dst.__r_.__value_.__r.__words[0]) = 0;
                  LODWORD(dst.__r_.__value_.__l.__data_) = 0;
                  if (buf[23] >= 0) {
                    int v243 = buf;
                  }
                  else {
                    int v243 = *(unsigned __int8 **)buf;
                  }
                  if (sub_1003FE1A4((uint64_t)&dst, v243))
                  {
                    if (qword_1008D9B20 != -1) {
                      dispatch_once(&qword_1008D9B20, &stru_1008A5068);
                    }
                    __int128 v278 = (int)dst.__r_.__value_.__l.__data_;
                    __int16 v279 = WORD2(dst.__r_.__value_.__r.__words[0]);
                    sub_1004C1354(qword_1008D9B18, (unsigned __int8 *)&v278, v242);
                    goto LABEL_135;
                  }

                  unsigned int v234 = (os_log_s *)qword_1008F75A0;
                  if (os_log_type_enabled((os_log_t)qword_1008F75A0, OS_LOG_TYPE_DEFAULT))
                  {
                    LOWORD(v342.__r_.__value_.__l.__data_) = 0;
                    unsigned int v235 = "Received invalid device address on LeaStoreBondingInfoResponse";
                    goto LABEL_600;
                  }

                  goto LABEL_135;
                }

                memset(buf, 0, 24);
                int v211 = (char *)xpc_dictionary_get_string(a3, "kLeaDeviceAddress");
                sub_10002418C(buf, v211);
                memset(&dst, 0, sizeof(dst));
                __n128 v212 = (char *)xpc_dictionary_get_string(a3, "kLeaDeviceName");
                sub_10002418C(&dst, v212);
                __int128 v213 = xpc_dictionary_get_int64(a3, "kLeaDeviceEdiv");
                __int128 v308 = 0;
                char v307 = 0;
                if (buf[23] >= 0) {
                  int v214 = buf;
                }
                else {
                  int v214 = *(unsigned __int8 **)buf;
                }
                if (sub_1003FE1A4((uint64_t)&v307, v214))
                {
                  v337 = 0LL;
                  *(void *)&v340[8] = 0LL;
                  *(void *)__int16 v340 = 0LL;
                  int v345 = 0uLL;
                  length = 0LL;
                  int v215 = (uint64_t *)xpc_dictionary_get_data(a3, "kLeaDeviceRand", &length);
                  if (v215 && length == 8)
                  {
                    v337 = *v215;
                    char v301 = 0LL;
                    __int16 v216 = xpc_dictionary_get_data(a3, "kLeaDeviceLtk", &v301);
                    if (v216 && v301 == 16)
                    {
                      *(_OWORD *)__int16 v340 = *v216;
                      unsigned int v298 = 0LL;
                      int v217 = (__int128 *)xpc_dictionary_get_data(a3, "kLeaDeviceIrk", &v298);
                      if (v217 && v298 == 16)
                      {
                        int v345 = *v217;
                        if (v213)
                        {
                          uint64_t v218 = ((unint64_t)v307 << 40) | ((unint64_t)BYTE1(v307) << 32) | ((unint64_t)BYTE2(v307) << 24) | ((unint64_t)HIBYTE(v307) << 16) | ((unint64_t)v308 << 8) | HIBYTE(v308);
                          v343 = 0LL;
                          __int16 v344 = 0LL;
                          if (qword_1008D5F30 != -1) {
                            dispatch_once(&qword_1008D5F30, &stru_1008A4F88);
                          }
                          sub_1005C8684((uint64_t)off_1008D5F28, v218, 0, 0, 0LL, 0LL, (unsigned __int8 *)&v343);
                          int v219 = operator new(0x28uLL);
                          v219[2] = 1;
                          *(void *)int v219 = &off_10089A468;
                          *((void *)v219 + 4) = 0LL;
                          *((void *)v219 + 3) = 0LL;
                          *((void *)v219 + 2) = v219 + 6;
                          unsigned int v294 = &off_10089A548;
                          unsigned int v295 = v219;
                          int v293 = v213;
                          BOOL v292 = 16;
                          unsigned int v220 = sub_1001BCDB0(v218);
                          int v289 = v220;
                          uint64_t v291 = BYTE6(v220);
                          uint64_t v290 = WORD2(v220);
                          unsigned int v221 = v295;
                          sub_10056AB04(&v342, &v289, 7uLL);
                          sub_10032B1F8((uint64_t)v221, 11, (uint64_t)&v342);
                          v342.__r_.__value_.__r.__words[0] = (std::string::size_type)&off_10087FAA8;
                          if (v342.__r_.__value_.__l.__size_) {
                            sub_1002CD254((unsigned int *)v342.__r_.__value_.__l.__size_);
                          }
                          unsigned int v222 = v295;
                          sub_10056AB04(&v342, &v293, 2uLL);
                          sub_10032B1F8((uint64_t)v222, 3, (uint64_t)&v342);
                          v342.__r_.__value_.__r.__words[0] = (std::string::size_type)&off_10087FAA8;
                          if (v342.__r_.__value_.__l.__size_) {
                            sub_1002CD254((unsigned int *)v342.__r_.__value_.__l.__size_);
                          }
                          unsigned __int16 v223 = v295;
                          sub_10056AB04(&v342, &v337, 8uLL);
                          sub_10032B1F8((uint64_t)v223, 4, (uint64_t)&v342);
                          v342.__r_.__value_.__r.__words[0] = (std::string::size_type)&off_10087FAA8;
                          if (v342.__r_.__value_.__l.__size_) {
                            sub_1002CD254((unsigned int *)v342.__r_.__value_.__l.__size_);
                          }
                          unsigned __int16 v224 = v295;
                          sub_10056AB04(&v342, v340, 0x10uLL);
                          sub_10032B1F8((uint64_t)v224, 0, (uint64_t)&v342);
                          v342.__r_.__value_.__r.__words[0] = (std::string::size_type)&off_10087FAA8;
                          if (v342.__r_.__value_.__l.__size_) {
                            sub_1002CD254((unsigned int *)v342.__r_.__value_.__l.__size_);
                          }
                          int v225 = v295;
                          sub_10056AB04(&v342, &v292, 1uLL);
                          sub_10032B1F8((uint64_t)v225, 1, (uint64_t)&v342);
                          v342.__r_.__value_.__r.__words[0] = (std::string::size_type)&off_10087FAA8;
                          if (v342.__r_.__value_.__l.__size_) {
                            sub_1002CD254((unsigned int *)v342.__r_.__value_.__l.__size_);
                          }
                          BOOL v226 = v295;
                          sub_10056AB04(&v342, &v345, 0x10uLL);
                          sub_10032B1F8((uint64_t)v226, 10, (uint64_t)&v342);
                          v342.__r_.__value_.__r.__words[0] = (std::string::size_type)&off_10087FAA8;
                          if (v342.__r_.__value_.__l.__size_) {
                            sub_1002CD254((unsigned int *)v342.__r_.__value_.__l.__size_);
                          }
                          if (qword_1008D9B20 != -1) {
                            dispatch_once(&qword_1008D9B20, &stru_1008A5068);
                          }
                          char v287 = v307;
                          BOOL v288 = v308;
                          sub_1004C1484(qword_1008D9B18, (unsigned __int8 *)&v287);
                          if (qword_1008D5F20 != -1) {
                            dispatch_once(&qword_1008D5F20, &stru_1008A5128);
                          }
                          int v227 = qword_1008D5F18;
                          id v228 = sub_100241F94((const unsigned __int8 *)&v343);
                          int v229 = (void *)objc_claimAutoreleasedReturnValue(v228);
                          sub_10002418C(v285, "");
                          uint64_t v230 = sub_10062C894(v227, v229, (uint64_t)&v294, (uint64_t)v285);
                          if (v286 < 0) {
                            operator delete(v285[0]);
                          }

                          if (qword_1008D5F30 != -1) {
                            dispatch_once(&qword_1008D5F30, &stru_1008A4F88);
                          }
                          unsigned int v231 = off_1008D5F28;
                          int v232 = sub_100241F94((const unsigned __int8 *)&v343);
                          int v233 = (void *)objc_claimAutoreleasedReturnValue(v232);
                          sub_100241F90(&v342, v233);
                          else {
                            __int16 v284 = dst;
                          }
                          sub_1005C9550((uint64_t)v231, (unsigned __int8 *)&v342, (uint64_t)&v284, 2);

                          int v268 = (os_log_s *)qword_1008F75A0;
                          if (os_log_type_enabled((os_log_t)qword_1008F75A0, OS_LOG_TYPE_DEFAULT))
                          {
                            __int16 v269 = "Successfully stored";
                            if (v230) {
                              __int16 v269 = "Failed to store";
                            }
                            int v270 = buf;
                            if (buf[23] < 0) {
                              int v270 = *(_BYTE **)buf;
                            }
                            LODWORD(v342.__r_.__value_.__l.__data_) = 136315394;
                            *(std::string::size_type *)((char *)v342.__r_.__value_.__r.__words + 4) = (std::string::size_type)v269;
                            WORD2(v342.__r_.__value_.__r.__words[1]) = 2080;
                            *(std::string::size_type *)((char *)&v342.__r_.__value_.__r.__words[1] + 6) = (std::string::size_type)v270;
                            _os_log_impl( (void *)&_mh_execute_header,  v268,  OS_LOG_TYPE_DEFAULT,  "%s bonding info for address %s",  (uint8_t *)&v342,  0x16u);
                          }

                          if ((buf[23] & 0x80000000) != 0)
                          {
                            sub_100024238(v282, *(void **)buf, *(unint64_t *)&buf[8]);
                          }

                          else
                          {
                            *(_OWORD *)int v282 = *(_OWORD *)buf;
                            BOOL v283 = *(void *)&buf[16];
                          }

                          sub_100644330(a1, (const char *)v282, v230 != 0);
                          if (SHIBYTE(v283) < 0) {
                            operator delete(v282[0]);
                          }
                          unsigned int v294 = &off_10089A548;
                          if (v295) {
                            sub_1002CD254(v295);
                          }
                          goto LABEL_102;
                        }

                        __int128 v261 = (os_log_s *)qword_1008F75A0;
                        if (os_log_type_enabled((os_log_t)qword_1008F75A0, OS_LOG_TYPE_DEFAULT))
                        {
                          LOWORD(v342.__r_.__value_.__l.__data_) = 0;
                          _os_log_impl( (void *)&_mh_execute_header,  v261,  OS_LOG_TYPE_DEFAULT,  "Received LeaStoreBondingInfoRequest to trigger unpairing",  (uint8_t *)&v342,  2u);
                        }

                        *(_OWORD *)&v342.__r_.__value_.__l.__data_ = 0uLL;
                        if (qword_1008D5F30 != -1) {
                          dispatch_once(&qword_1008D5F30, &stru_1008A4F88);
                        }
                        sub_1005C8684( (uint64_t)off_1008D5F28,  ((unint64_t)v307 << 40) | ((unint64_t)BYTE1(v307) << 32) | ((unint64_t)BYTE2(v307) << 24) | ((unint64_t)HIBYTE(v307) << 16) | ((unint64_t)v308 << 8) | HIBYTE(v308),  0,  0,  0LL,  0LL,  (unsigned __int8 *)&v342);
                        if (qword_1008D5F20 != -1) {
                          dispatch_once(&qword_1008D5F20, &stru_1008A5128);
                        }
                        __int128 v262 = qword_1008D5F18;
                        __int128 v263 = sub_100241F94((const unsigned __int8 *)&v342);
                        __int128 v264 = (void *)objc_claimAutoreleasedReturnValue(v263);
                        LODWORD(v262) = sub_10061C0F8(v262, v264);

                        if ((_DWORD)v262)
                        {
                          if (qword_1008D9B20 != -1) {
                            dispatch_once(&qword_1008D9B20, &stru_1008A5068);
                          }
                          int v280 = v307;
                          __int16 v281 = v308;
                          sub_1004C1594(qword_1008D9B18, (unsigned __int8 *)&v280);
                          if (qword_1008D5F20 != -1) {
                            dispatch_once(&qword_1008D5F20, &stru_1008A5128);
                          }
                          __n128 v265 = qword_1008D5F18;
                          v266 = sub_100241F94((const unsigned __int8 *)&v342);
                          __int16 v267 = (void *)objc_claimAutoreleasedReturnValue(v266);
                          sub_100625C0C(v265, v267);

                          goto LABEL_102;
                        }

                        __int16 v271 = qword_1008F75A0;
                        if (!os_log_type_enabled((os_log_t)qword_1008F75A0, OS_LOG_TYPE_DEFAULT))
                        {
LABEL_102:
                          uint64_t v59 = (void *)dst.__r_.__value_.__r.__words[0];
LABEL_134:
                          operator delete(v59);
                          goto LABEL_135;
                        }

                        LOWORD(v343) = 0;
                        unint64_t v55 = "Device is already unpaired";
                        id v56 = (std::string *)&v343;
                        id v57 = (os_log_s *)v271;
                        __int16 v58 = 2;
LABEL_101:
                        _os_log_impl((void *)&_mh_execute_header, v57, OS_LOG_TYPE_DEFAULT, v55, (uint8_t *)v56, v58);
                        goto LABEL_102;
                      }

                      if (os_log_type_enabled((os_log_t)qword_1008F75A0, OS_LOG_TYPE_ERROR)) {
                        sub_1006A0EA8();
                      }
                      if ((buf[23] & 0x80000000) != 0)
                      {
                        sub_100024238(&v296, *(void **)buf, *(unint64_t *)&buf[8]);
                      }

                      else
                      {
                        char v296 = *(_OWORD *)buf;
                        int v297 = *(void *)&buf[16];
                      }

                      sub_100644330(a1, (const char *)&v296, 1u);
                      if ((SHIBYTE(v297) & 0x80000000) == 0) {
                        goto LABEL_102;
                      }
                      uint64_t v118 = (void *)v296;
                    }

                    else
                    {
                      if (os_log_type_enabled((os_log_t)qword_1008F75A0, OS_LOG_TYPE_ERROR)) {
                        sub_1006A0E7C();
                      }
                      if ((buf[23] & 0x80000000) != 0)
                      {
                        sub_100024238(&v299, *(void **)buf, *(unint64_t *)&buf[8]);
                      }

                      else
                      {
                        uint64_t v299 = *(_OWORD *)buf;
                        uint64_t v300 = *(void *)&buf[16];
                      }

                      sub_100644330(a1, (const char *)&v299, 1u);
                      if ((SHIBYTE(v300) & 0x80000000) == 0) {
                        goto LABEL_102;
                      }
                      uint64_t v118 = (void *)v299;
                    }
                  }

                  else
                  {
                    if (os_log_type_enabled((os_log_t)qword_1008F75A0, OS_LOG_TYPE_ERROR)) {
                      sub_1006A0E50();
                    }
                    if ((buf[23] & 0x80000000) != 0)
                    {
                      sub_100024238(&v302, *(void **)buf, *(unint64_t *)&buf[8]);
                    }

                    else
                    {
                      v302 = *(_OWORD *)buf;
                      char v303 = *(void *)&buf[16];
                    }

                    sub_100644330(a1, (const char *)&v302, 1u);
                    if ((SHIBYTE(v303) & 0x80000000) == 0) {
                      goto LABEL_102;
                    }
                    uint64_t v118 = (void *)v302;
                  }
                }

                else
                {
                  unint64_t v244 = (os_log_s *)qword_1008F75A0;
                  if (os_log_type_enabled((os_log_t)qword_1008F75A0, OS_LOG_TYPE_DEFAULT))
                  {
                    LOWORD(v342.__r_.__value_.__l.__data_) = 0;
                    _os_log_impl( (void *)&_mh_execute_header,  v244,  OS_LOG_TYPE_DEFAULT,  "Received invalid device address on LeaStoreBondingInfoRequest",  (uint8_t *)&v342,  2u);
                  }

                  if ((buf[23] & 0x80000000) != 0)
                  {
                    sub_100024238(&v305, *(void **)buf, *(unint64_t *)&buf[8]);
                  }

                  else
                  {
                    uint64_t v305 = *(_OWORD *)buf;
                    unsigned __int16 v306 = *(void *)&buf[16];
                  }

                  sub_100644330(a1, (const char *)&v305, 1u);
                  if ((SHIBYTE(v306) & 0x80000000) == 0) {
                    goto LABEL_102;
                  }
                  uint64_t v118 = (void *)v305;
                }

void sub_100625590( _Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20, uint64_t a21, uint64_t a22, uint64_t a23, uint64_t a24, void *a25, uint64_t a26, int a27, __int16 a28, char a29, char a30, void *__p, uint64_t a32, int a33, __int16 a34, char a35, char a36, uint64_t a37, uint64_t a38, uint64_t a39, uint64_t a40, uint64_t a41, uint64_t a42, uint64_t a43, uint64_t a44, void *a45, uint64_t a46, int a47, __int16 a48, char a49, char a50,char a51,uint64_t a52,uint64_t a53,uint64_t a54,uint64_t a55,uint64_t a56,uint64_t a57,uint64_t a58,uint64_t a59,uint64_t a60,uint64_t a61)
{
  sub_100242FAC((uint64_t)&a51);
  _Unwind_Resume(a1);
}

uint64_t sub_100625934(uint64_t a1, unsigned __int8 *a2)
{
  v29[0] = 0LL;
  v29[1] = 0LL;
  sub_100242F28((uint64_t)v29, a1 + 48);
  if (((char)a2[23] & 0x80000000) == 0)
  {
    if (a2[23]) {
      goto LABEL_3;
    }
LABEL_38:
    if (os_log_type_enabled((os_log_t)qword_1008F75A8, OS_LOG_TYPE_FAULT)) {
      sub_10069F370();
    }
    goto LABEL_40;
  }

  if (!*((void *)a2 + 1)) {
    goto LABEL_38;
  }
LABEL_3:
  id v3 = *(const unsigned __int8 **)(a1 + 440);
  if (v3 == (const unsigned __int8 *)(a1 + 448))
  {
LABEL_35:
    unint64_t v20 = (os_log_s *)qword_1008F75A8;
    if (os_log_type_enabled((os_log_t)qword_1008F75A8, OS_LOG_TYPE_ERROR)) {
      sub_10069F39C((char *)a2 + 23, a2, v20);
    }
LABEL_40:
    uint64_t v21 = 0LL;
    goto LABEL_41;
  }

  while (1)
  {
    memset(dst, 0, sizeof(dst));
    uuid_copy(dst, v3 + 32);
    if (qword_1008D5F30 != -1) {
      dispatch_once(&qword_1008D5F30, &stru_1008A45D8);
    }
    id v4 = off_1008D5F28;
    uint64_t v5 = sub_100241F94(dst);
    unint64_t v6 = (void *)objc_claimAutoreleasedReturnValue(v5);
    sub_1005CF060((uint64_t)v4, v6, (uint64_t)&__s1);
    if ((v28 & 0x80u) == 0) {
      size_t v7 = v28;
    }
    else {
      size_t v7 = __n;
    }
    uint64_t v8 = a2[23];
    int v9 = (char)v8;
    if ((v8 & 0x80u) != 0LL) {
      uint64_t v8 = *((void *)a2 + 1);
    }
    if (v7 != v8)
    {
      if ((v28 & 0x80) != 0) {
        operator delete(__s1);
      }

      goto LABEL_29;
    }

    if (v9 >= 0) {
      uint64_t v10 = a2;
    }
    else {
      uint64_t v10 = *(unsigned __int8 **)a2;
    }
    if ((v28 & 0x80) != 0)
    {
      id v16 = __s1;
      BOOL v17 = memcmp(__s1, v10, __n) == 0;
      operator delete(v16);

      if (v17) {
        goto LABEL_43;
      }
      goto LABEL_29;
    }

    if (!v28) {
      break;
    }
    uint64_t v11 = 0LL;
    do
    {
      int v12 = *((unsigned __int8 *)&__s1 + v11);
      int v13 = v10[v11];
      BOOL v14 = v12 != v13 || v28 - 1LL == v11++;
    }

    while (!v14);
    BOOL v15 = v12 != v13;

    if (!v15) {
      goto LABEL_43;
    }
LABEL_29:
    uint64_t v18 = (unsigned __int8 *)*((void *)v3 + 1);
    if (v18)
    {
      do
      {
        int v19 = (const unsigned __int8 **)v18;
        uint64_t v18 = *(unsigned __int8 **)v18;
      }

      while (v18);
    }

    else
    {
      do
      {
        int v19 = (const unsigned __int8 **)*((void *)v3 + 2);
        BOOL v14 = *v19 == v3;
        id v3 = (const unsigned __int8 *)v19;
      }

      while (!v14);
    }

    id v3 = (const unsigned __int8 *)v19;
  }

LABEL_43:
  char v23 = sub_100241F94(dst);
  __int128 v24 = (void *)objc_claimAutoreleasedReturnValue(v23);
  sub_100625C0C(a1, v24);

  uint64_t v21 = 1LL;
LABEL_41:
  sub_100242FAC((uint64_t)v29);
  return v21;
}

void sub_100625BD0(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, ...)
{
  sub_100242FAC((uint64_t)va);
  _Unwind_Resume(a1);
}

void sub_100625C0C(uint64_t a1, void *a2)
{
  id v3 = a2;
  if (sub_10061C0F8(a1, v3))
  {
    id v4 = (os_log_s *)qword_1008F75A8;
    if (os_log_type_enabled((os_log_t)qword_1008F75A8, OS_LOG_TYPE_DEFAULT))
    {
      *(_DWORD *)__int128 buf = 138543362;
      *(void *)&uint8_t buf[4] = v3;
      _os_log_impl((void *)&_mh_execute_header, v4, OS_LOG_TYPE_DEFAULT, "Unpairing device %{public}@", buf, 0xCu);
    }

    *(_OWORD *)__int128 buf = 0uLL;
    sub_100242F28((uint64_t)buf, a1 + 48);
    if (qword_1008D5F30 != -1) {
      dispatch_once(&qword_1008D5F30, &stru_1008A45D8);
    }
    uint64_t v5 = sub_1005CC198((uint64_t)off_1008D5F28, v3, 0);
    uint64_t v6 = sub_1001BCDB0(v5);
    int v32 = v6;
    char v34 = BYTE6(v6);
    __int16 v33 = WORD2(v6);
    if (sub_100626340(a1, v3))
    {
      sub_100241F90(&uu2, v3);
      uint64_t v7 = sub_1001FDB10(a1 + 440, (unsigned __int8 *)&uu2);
      uint64_t v8 = (uint64_t *)v7;
      int v9 = *(unsigned int **)(v7 + 56);
      if (v9) {
        sub_1002CD1E0(*(void *)(v7 + 56));
      }
      if (*(_BYTE *)(a1 + 41))
      {
        __int128 uu2 = 0uLL;
        sub_10032BA60((uint64_t)v9, 10, &uu2);
        BOOL v10 = sub_10056AAC8((uint64_t)&uu2);
        if (!v10)
        {
          uint64_t v11 = sub_100404FE8();
          int v12 = operator new(0x28uLL);
          v12[4] = 1;
          *(void *)int v12 = &off_1008A4538;
          *((void *)v12 + 2) = v5;
          *((void *)v12 + 3) = 0LL;
          *((_BYTE *)v12 + 32) = 1;
          BOOL v10 = sub_100405744(v11, v12);
        }

        sub_100627130(v10, (unsigned __int8 *)&v32);
        *(void *)&__int128 uu2 = &off_10087FAA8;
        if (*((void *)&uu2 + 1)) {
          sub_1002CD254(*((unsigned int **)&uu2 + 1));
        }
      }

      sub_100632AF0((uint64_t **)(a1 + 440), v8);
      if (v9) {
        sub_1002CD254(v9);
      }
    }

    if (qword_1008D5F30 != -1) {
      dispatch_once(&qword_1008D5F30, &stru_1008A45D8);
    }
    int v13 = off_1008D5F28;
    sub_100241F90(&uu2, v3);
    if (sub_1005D0A00((uint64_t)v13, (const unsigned __int8 *)&uu2, v5))
    {
      if (os_log_type_enabled((os_log_t)qword_1008F75A8, OS_LOG_TYPE_ERROR))
      {
        id v14 = sub_1005BFB9C(v5);
        objc_claimAutoreleasedReturnValue(v14);
        sub_10069F414();
      }
    }

    else
    {
      uint64_t v21 = sub_1002E6BF0();
      int v22 = (*(uint64_t (**)(uint64_t))(*(void *)v21 + 352LL))(v21);
      sub_1002983AC(v5, 0LL, v22);
      char v23 = (os_log_s *)qword_1008F75A8;
      if (os_log_type_enabled((os_log_t)qword_1008F75A8, OS_LOG_TYPE_DEFAULT))
      {
        uint64_t v24 = *(void *)(a1 + 456);
        LODWORD(uu2) = 134217984;
        *(void *)((char *)&uu2 + 4) = v24;
        _os_log_impl( (void *)&_mh_execute_header,  v23,  OS_LOG_TYPE_DEFAULT,  "Number of LE Paired devices:%lu",  (uint8_t *)&uu2,  0xCu);
      }
    }

    if (qword_1008D5F30 != -1) {
      dispatch_once(&qword_1008D5F30, &stru_1008A45D8);
    }
    uint64_t v25 = off_1008D5F28;
    sub_10002418C(__p, "_CTKD_");
    int v26 = sub_1005CE5A8((uint64_t)v25, v3, (uint64_t)__p);
    int v27 = v26;
    if (v31 < 0)
    {
      operator delete(__p[0]);
      if (!v27)
      {
LABEL_46:
        if (qword_1008D5F60 != -1) {
          dispatch_once(&qword_1008D5F60, &stru_1008A4638);
        }
        uint64_t v29 = qword_1008D5F58;
        sub_100241F90(&uu2, v3);
        else {
          [*(id *)(a1 + 3752) addObject:v3];
        }
        sub_100242FAC((uint64_t)buf);
        goto LABEL_52;
      }
    }

    else if (!v26)
    {
      goto LABEL_46;
    }

    unsigned __int8 v28 = (os_log_s *)qword_1008F75A8;
    if (os_log_type_enabled((os_log_t)qword_1008F75A8, OS_LOG_TYPE_DEFAULT))
    {
      LOWORD(uu2) = 0;
      _os_log_impl((void *)&_mh_execute_header, v28, OS_LOG_TYPE_DEFAULT, "Removing _CTKD_ Tag", (uint8_t *)&uu2, 2u);
    }

    if (qword_1008D5F30 != -1) {
      dispatch_once(&qword_1008D5F30, &stru_1008A45D8);
    }
    sub_1005C9A38((uint64_t)off_1008D5F28, v3, @"_CTKD_");
    if (qword_1008D67A8 != -1) {
      dispatch_once(&qword_1008D67A8, &stru_1008A4618);
    }
    sub_10052F2AC((uint64_t)off_1008D67A0, v5);
    goto LABEL_46;
  }

  unsigned int v15 = [*(id *)(a1 + 3752) containsObject:v3];
  id v16 = (os_log_s *)qword_1008F75A8;
  BOOL v17 = os_log_type_enabled((os_log_t)qword_1008F75A8, OS_LOG_TYPE_DEFAULT);
  if (v15)
  {
    if (v17)
    {
      *(_DWORD *)__int128 buf = 138543362;
      *(void *)&uint8_t buf[4] = v3;
      _os_log_impl( (void *)&_mh_execute_header,  v16,  OS_LOG_TYPE_DEFAULT,  "Device %{public}@ is still in the process of unpairing, ignore this request, wait for BMS to complete or a disconnection",  buf,  0xCu);
    }
  }

  else
  {
    if (v17)
    {
      *(_DWORD *)__int128 buf = 138543362;
      *(void *)&uint8_t buf[4] = v3;
      _os_log_impl( (void *)&_mh_execute_header,  v16,  OS_LOG_TYPE_DEFAULT,  "Device %{public}@ isn't paired",  buf,  0xCu);
    }

    sub_10061FAB4(a1, v3, 0);
    sub_100241F90(buf, v3);
    uint64_t v18 = sub_1001FDB10(a1 + 440, buf);
    int v19 = (uint64_t *)v18;
    if (a1 + 448 != v18)
    {
      unint64_t v20 = *(unsigned int **)(v18 + 56);
      if (v20) {
        sub_1002CD1E0(*(void *)(v18 + 56));
      }
      sub_100632AF0((uint64_t **)(a1 + 440), v19);
      if (v20) {
        sub_1002CD254(v20);
      }
    }
  }

void sub_1006261A8( _Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, void *__p, uint64_t a10, int a11, __int16 a12, char a13, char a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, char a20)
{
  _Unwind_Resume(a1);
}

uint64_t sub_100626260(uint64_t a1, void *a2)
{
  id v3 = a2;
  if (*(_BYTE *)(a1 + 41))
  {
    if (qword_1008D5F30 != -1) {
      dispatch_once(&qword_1008D5F30, &stru_1008A45D8);
    }
    unint64_t v4 = sub_1005CC198((uint64_t)off_1008D5F28, v3, 0);
    uint64_t v5 = sub_1001BCDB0(v4);
    int v9 = v5;
    char v11 = BYTE6(v5);
    __int16 v10 = WORD2(v5);
    char v8 = 0;
    sub_100242CA4(&v8);
    uint64_t v6 = sub_1001CBF3C(&v9);
    sub_100242CD8(&v8);
  }

  else
  {
    uint64_t v6 = 0LL;
  }

  return v6;
}

void sub_100626318( _Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, int a9, __int16 a10, char a11, char a12)
{
  _Unwind_Resume(a1);
}

BOOL sub_100626340(uint64_t a1, void *a2)
{
  id v3 = a2;
  v7[0] = 0LL;
  v7[1] = 0LL;
  sub_100242F28((uint64_t)v7, a1 + 48);
  sub_100241F90(uu2, v3);
  uint64_t v4 = sub_1001FDB10(a1 + 440, uu2);
  if (a1 + 448 == v4)
  {
    BOOL v5 = 0LL;
  }

  else
  {
    *(void *)__int128 uu2 = 0LL;
    int v9 = 0LL;
    sub_10032BA60(*(void *)(v4 + 56), 17, uu2);
    BOOL v5 = sub_10056AAC8((uint64_t)uu2);
    *(void *)__int128 uu2 = &off_10087FAA8;
    if (v9) {
      sub_1002CD254(v9);
    }
  }

  sub_100242FAC((uint64_t)v7);

  return v5;
}

void sub_10062641C( _Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, char a10, uint64_t a11, uint64_t (**a12)(), unsigned int *a13)
{
  a12 = &off_10087FAA8;
  if (a13) {
    sub_1002CD254(a13);
  }
  sub_100242FAC((uint64_t)&a10);

  _Unwind_Resume(a1);
}

id sub_100626468(uint64_t a1)
{
  char v2 = (void *)objc_claimAutoreleasedReturnValue(+[NSMutableArray array](&OBJC_CLASS___NSMutableArray, "array"));
  v13[0] = 0LL;
  v13[1] = 0LL;
  sub_100242F28((uint64_t)v13, a1 + 48);
  id v3 = *(const unsigned __int8 **)(a1 + 440);
  if (v3 != (const unsigned __int8 *)(a1 + 448))
  {
    do
    {
      uint64_t v4 = sub_100241F94(v3 + 32);
      BOOL v5 = (void *)objc_claimAutoreleasedReturnValue(v4);
      BOOL v6 = sub_10061C0F8(a1, v5);

      if (v6)
      {
        uint64_t v7 = sub_100241F94(v3 + 32);
        char v8 = (void *)objc_claimAutoreleasedReturnValue(v7);
        [v2 addObject:v8];
      }

      int v9 = (unsigned __int8 *)*((void *)v3 + 1);
      if (v9)
      {
        do
        {
          __int16 v10 = (const unsigned __int8 **)v9;
          int v9 = *(unsigned __int8 **)v9;
        }

        while (v9);
      }

      else
      {
        do
        {
          __int16 v10 = (const unsigned __int8 **)*((void *)v3 + 2);
          BOOL v11 = *v10 == v3;
          id v3 = (const unsigned __int8 *)v10;
        }

        while (!v11);
      }

      id v3 = (const unsigned __int8 *)v10;
    }

    while (v10 != (const unsigned __int8 **)(a1 + 448));
  }

  sub_100242FAC((uint64_t)v13);
  return v2;
}

void sub_100626568(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

id sub_1006265A0(uint64_t a1)
{
  char v2 = (void *)objc_claimAutoreleasedReturnValue(+[NSMutableArray array](&OBJC_CLASS___NSMutableArray, "array"));
  v14[0] = 0LL;
  v14[1] = 0LL;
  sub_100242F28((uint64_t)v14, a1 + 48);
  id v3 = *(const unsigned __int8 **)(a1 + 440);
  if (v3 != (const unsigned __int8 *)(a1 + 448))
  {
    do
    {
      uint64_t v4 = sub_100241F94(v3 + 32);
      BOOL v5 = (void *)objc_claimAutoreleasedReturnValue(v4);
      if (sub_10061C0F8(a1, v5))
      {
        if (qword_1008D5F30 != -1) {
          dispatch_once(&qword_1008D5F30, &stru_1008A45D8);
        }
        BOOL v6 = off_1008D5F28;
        uint64_t v7 = sub_100241F94(v3 + 32);
        char v8 = (void *)objc_claimAutoreleasedReturnValue(v7);
        LODWORD(v6) = sub_1005CF1FC((uint64_t)v6, v8);

        if (!(_DWORD)v6) {
          goto LABEL_8;
        }
        int v9 = sub_100241F94(v3 + 32);
        BOOL v5 = (void *)objc_claimAutoreleasedReturnValue(v9);
        [v2 addObject:v5];
      }

LABEL_8:
      __int16 v10 = (unsigned __int8 *)*((void *)v3 + 1);
      if (v10)
      {
        do
        {
          BOOL v11 = (const unsigned __int8 **)v10;
          __int16 v10 = *(unsigned __int8 **)v10;
        }

        while (v10);
      }

      else
      {
        do
        {
          BOOL v11 = (const unsigned __int8 **)*((void *)v3 + 2);
          BOOL v12 = *v11 == v3;
          id v3 = (const unsigned __int8 *)v11;
        }

        while (!v12);
      }

      id v3 = (const unsigned __int8 *)v11;
    }

    while (v11 != (const unsigned __int8 **)(a1 + 448));
  }

  sub_100242FAC((uint64_t)v14);
  return v2;
}

void sub_100626700(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_10062673C(uint64_t a1, void *a2)
{
  id v3 = a2;
  v6[0] = 0LL;
  v6[1] = 0LL;
  sub_100242F28((uint64_t)v6, a1 + 48);
  uint64_t v4 = (os_log_s *)qword_1008F75A8;
  if (os_log_type_enabled((os_log_t)qword_1008F75A8, OS_LOG_TYPE_DEFAULT))
  {
    *(_DWORD *)__int128 buf = 138543362;
    id v8 = v3;
    _os_log_impl( (void *)&_mh_execute_header,  v4,  OS_LOG_TYPE_DEFAULT,  "Device %{public}@ is tagged as a watch",  buf,  0xCu);
  }

  if (qword_1008D5F30 != -1) {
    dispatch_once(&qword_1008D5F30, &stru_1008A45D8);
  }
  unint64_t v5 = sub_1005CC198((uint64_t)off_1008D5F28, v3, 0);
  sub_10062687C(a1, v5, 0xAu);
  sub_100242FAC((uint64_t)v6);
}

void sub_100626854(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

uint64_t sub_10062687C(uint64_t a1, unint64_t a2, unsigned int a3)
{
  v24[0] = 0LL;
  v24[1] = 0LL;
  sub_100242F28((uint64_t)v24, a1 + 48);
  unint64_t v5 = (os_log_s *)qword_1008F75A8;
  if (os_log_type_enabled((os_log_t)qword_1008F75A8, OS_LOG_TYPE_DEFAULT))
  {
    id v6 = sub_1005BFB9C(a2);
    uint64_t v7 = (void *)objc_claimAutoreleasedReturnValue(v6);
    *(_DWORD *)__int128 buf = 67109378;
    *(_DWORD *)&uint8_t buf[4] = a3;
    *(_WORD *)int v26 = 2114;
    *(void *)&void v26[2] = v7;
    _os_log_impl( (void *)&_mh_execute_header,  v5,  OS_LOG_TYPE_DEFAULT,  "Adding keys %d to synced keychain for device %{public}@ tagged as a watch",  buf,  0x12u);
  }

  int v22 = 0LL;
  std::stringbuf::string_type __p = 0LL;
  uint64_t v21 = 0LL;
  signed int v8 = a3 - 1;
  if (a3 - 1 < 0x10 && ((0x81EFu >> v8) & 1) != 0)
  {
    unsigned int v9 = dword_1006C4868[v8];
  }

  else if ((a3 & 0xFFFFFFFE) == 0xE)
  {
    unsigned int v9 = 4;
  }

  else
  {
    unsigned int v9 = 16;
  }

  uint64_t v20 = 0LL;
  __int16 v10 = (os_log_s *)qword_1008F75A8;
  if (os_log_type_enabled((os_log_t)qword_1008F75A8, OS_LOG_TYPE_DEFAULT))
  {
    *(_WORD *)__int128 buf = 0;
    _os_log_impl( (void *)&_mh_execute_header,  v10,  OS_LOG_TYPE_DEFAULT,  "addKeyToSyncedKeychainForDevice is calling BTKCCopyLEData",  buf,  2u);
  }

  v27[0] = 0LL;
  v27[1] = 0LL;
  if (qword_1008D5F30 != -1) {
    dispatch_once(&qword_1008D5F30, &stru_1008A45D8);
  }
  sub_1005C8684((uint64_t)off_1008D5F28, a2, 0, 1u, 0LL, 0LL, (unsigned __int8 *)v27);
  BOOL v11 = sub_100241F94((const unsigned __int8 *)v27);

  sub_1002981F8(a2, a3, (UInt8 **)&__p, (_DWORD *)&v21 + 1, (_DWORD *)&v20 + 1, (UInt8 **)&v22, &v21, &v20);
  int v12 = HIDWORD(v21);
  if (!HIDWORD(v20) && HIDWORD(v21))
  {
    int v13 = (os_log_s *)qword_1008F75A8;
    if (os_log_type_enabled((os_log_t)qword_1008F75A8, OS_LOG_TYPE_DEFAULT))
    {
      *(_DWORD *)__int128 buf = 67109632;
      *(_DWORD *)&uint8_t buf[4] = v20;
      *(_WORD *)int v26 = 1024;
      *(_DWORD *)&void v26[2] = v12;
      *(_WORD *)&v26[6] = 1024;
      *(_DWORD *)&v26[8] = v21;
      _os_log_impl( (void *)&_mh_execute_header,  v13,  OS_LOG_TYPE_DEFAULT,  "Found key in local Keychain syncedStatus=%d localLen=%d syncedLen=%d",  buf,  0x14u);
      int v12 = HIDWORD(v21);
    }

    if (v12 == v9)
    {
      if ((_DWORD)v20 || memcmp(__p, v22, v9))
      {
        *(void *)__int128 buf = 0LL;
        *(void *)int v26 = 0LL;
        if (qword_1008D5F30 != -1) {
          dispatch_once(&qword_1008D5F30, &stru_1008A45D8);
        }
        sub_1005C8684((uint64_t)off_1008D5F28, a2, 0, 1u, 0LL, 0LL, buf);
        id v14 = sub_100241F94(buf);
        unsigned int v15 = (void *)objc_claimAutoreleasedReturnValue(v14);
        sub_100297E4C(a2, v15, a3, (const UInt8 *)__p, HIDWORD(v21), 1);

        id v16 = (os_log_s *)qword_1008F75A8;
        if (os_log_type_enabled((os_log_t)qword_1008F75A8, OS_LOG_TYPE_DEFAULT))
        {
          *(_WORD *)int v19 = 0;
          _os_log_impl((void *)&_mh_execute_header, v16, OS_LOG_TYPE_DEFAULT, "Added Key to synced keychain", v19, 2u);
        }
      }
    }

    else
    {
      BOOL v17 = (os_log_s *)qword_1008F75A8;
      if (!os_log_type_enabled((os_log_t)qword_1008F75A8, OS_LOG_TYPE_FAULT)) {
        goto LABEL_26;
      }
      *(_DWORD *)__int128 buf = 67109632;
      *(_DWORD *)&uint8_t buf[4] = a3;
      *(_WORD *)int v26 = 1024;
      *(_DWORD *)&void v26[2] = v9;
      *(_WORD *)&v26[6] = 1024;
      *(_DWORD *)&v26[8] = v12;
      _os_log_fault_impl( (void *)&_mh_execute_header,  v17,  OS_LOG_TYPE_FAULT,  "Ignoring data of invalid length for key type %d - expected %d byte(s), read %d byte(s)",  buf,  0x14u);
    }

    int v12 = HIDWORD(v21);
  }

void sub_100626C58( _Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, ...)
{
  sub_100242FAC((uint64_t)va);
  _Unwind_Resume(a1);
}

void sub_100626C8C(uint64_t a1, void *a2)
{
  id v3 = a2;
  v6[0] = 0LL;
  v6[1] = 0LL;
  sub_100242F28((uint64_t)v6, a1 + 48);
  uint64_t v4 = (os_log_s *)qword_1008F75A8;
  if (os_log_type_enabled((os_log_t)qword_1008F75A8, OS_LOG_TYPE_DEFAULT))
  {
    *(_DWORD *)__int128 buf = 138543362;
    id v8 = v3;
    _os_log_impl( (void *)&_mh_execute_header,  v4,  OS_LOG_TYPE_DEFAULT,  "Device %{public}@ is untagged as a watch",  buf,  0xCu);
  }

  if (qword_1008D5F30 != -1) {
    dispatch_once(&qword_1008D5F30, &stru_1008A45D8);
  }
  unint64_t v5 = sub_1005CC198((uint64_t)off_1008D5F28, v3, 0);
  sub_100626DCC(a1, v5, 0xAu);
  sub_100242FAC((uint64_t)v6);
}

void sub_100626DA4(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

uint64_t sub_100626DCC(uint64_t a1, unint64_t a2, unsigned int a3)
{
  v26[0] = 0LL;
  v26[1] = 0LL;
  sub_100242F28((uint64_t)v26, a1 + 48);
  id v6 = (os_log_s *)qword_1008F75A8;
  if (os_log_type_enabled((os_log_t)qword_1008F75A8, OS_LOG_TYPE_INFO))
  {
    id v7 = sub_1005BFB9C(a2);
    id v8 = (void *)objc_claimAutoreleasedReturnValue(v7);
    *(_DWORD *)__int128 buf = 67109378;
    *(_DWORD *)&uint8_t buf[4] = a3;
    LOWORD(v28[0]) = 2114;
    *(void *)((char *)v28 + 2) = v8;
    _os_log_impl( (void *)&_mh_execute_header,  v6,  OS_LOG_TYPE_INFO,  "removing keys %d from synced keychain for device %{public}@ tagged as a watch",  buf,  0x12u);

    id v6 = (os_log_s *)qword_1008F75A8;
  }

  uint64_t v24 = 0LL;
  std::stringbuf::string_type __p = 0LL;
  if (os_log_type_enabled(v6, OS_LOG_TYPE_INFO))
  {
    *(_WORD *)__int128 buf = 0;
    _os_log_impl( (void *)&_mh_execute_header,  v6,  OS_LOG_TYPE_INFO,  "removeKeyFromSyncedKeychainForDevice is calling BTKCCopyLEData",  buf,  2u);
  }

  *(void *)__int128 buf = 0LL;
  v28[0] = 0LL;
  if (qword_1008D5F30 != -1) {
    dispatch_once(&qword_1008D5F30, &stru_1008A45D8);
  }
  sub_1005C8684((uint64_t)off_1008D5F28, a2, 0, 1u, 0LL, 0LL, buf);
  unsigned int v9 = sub_100241F94(buf);

  sub_1002981F8(a2, a3, 0LL, 0LL, 0LL, (UInt8 **)&__p, (_DWORD *)&v24 + 1, &v24);
  if (!(_DWORD)v24 && HIDWORD(v24))
  {
    __int16 v10 = (os_log_s *)qword_1008F75A8;
    if (os_log_type_enabled((os_log_t)qword_1008F75A8, OS_LOG_TYPE_DEFAULT))
    {
      *(_WORD *)uint64_t v21 = 0;
      _os_log_impl((void *)&_mh_execute_header, v10, OS_LOG_TYPE_DEFAULT, "Found key", v21, 2u);
    }

    BOOL v11 = sub_100241F94(buf);
    int v12 = (void *)objc_claimAutoreleasedReturnValue(v11);
    sub_100297E4C(a2, v12, a3, (const UInt8 *)__p, 0LL, 1);

    int v13 = (os_log_s *)qword_1008F75A8;
    if (os_log_type_enabled((os_log_t)qword_1008F75A8, OS_LOG_TYPE_DEFAULT))
    {
      *(_WORD *)uint64_t v21 = 0;
      _os_log_impl((void *)&_mh_execute_header, v13, OS_LOG_TYPE_DEFAULT, "Moved Key", v21, 2u);
    }

    id v14 = sub_100241F94(buf);
    unsigned int v15 = (void *)objc_claimAutoreleasedReturnValue(v14);
    BOOL v16 = sub_10061C0F8(a1, v15);

    if (!v16)
    {
      if (a3 == 10 && *(_BYTE *)(a1 + 41))
      {
        uint64_t v17 = sub_100404FE8();
        uint64_t v18 = operator new(0x28uLL);
        void v18[4] = 1;
        *(void *)uint64_t v18 = &off_1008A4538;
        *((void *)v18 + 2) = a2;
        *((void *)v18 + 3) = 0LL;
        *((_BYTE *)v18 + 32) = 1;
        sub_100405744(v17, v18);
        uint64_t v19 = sub_1001BCDB0(a2);
        *(_DWORD *)uint64_t v21 = v19;
        char v23 = BYTE6(v19);
        __int16 v22 = WORD2(v19);
        sub_100627130(v19, v21);
      }

      sub_1002983AC(a2, 0LL, 1);
    }

    if (__p) {
      operator delete[](__p);
    }
  }

  return sub_100242FAC((uint64_t)v26);
}

void sub_1006270F0( _Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, ...)
{
}

BOOL sub_100627130(uint64_t a1, unsigned __int8 *a2)
{
  unint64_t v3 = ((unint64_t)a2[1] << 40) | ((unint64_t)a2[2] << 32) | ((unint64_t)a2[3] << 24) | ((unint64_t)a2[4] << 16) | ((unint64_t)a2[5] << 8) | a2[6] | ((unint64_t)*a2 << 48);
  uint64_t v4 = (os_log_s *)qword_1008F75A8;
  if (os_log_type_enabled((os_log_t)qword_1008F75A8, OS_LOG_TYPE_DEFAULT))
  {
    sub_1005BFC20(v3, &__p);
    unint64_t v5 = (__p.__r_.__value_.__s.__size_ & 0x80u) == 0
       ? &__p
       : (std::stringbuf::string_type *)__p.__r_.__value_.__r.__words[0];
    *(_DWORD *)__int128 buf = 136446210;
    int v13 = v5;
    _os_log_impl( (void *)&_mh_execute_header,  v4,  OS_LOG_TYPE_DEFAULT,  "Removing %{public}s from the cache.",  buf,  0xCu);
  }

  char v10 = 0;
  sub_100242CA4(&v10);
  int v6 = sub_1001C9AB4(a2);
  sub_100242CD0(&v10);
  id v7 = (os_log_s *)qword_1008F75A8;
  if (os_log_type_enabled((os_log_t)qword_1008F75A8, OS_LOG_TYPE_DEFAULT))
  {
    sub_1005BFC20(v3, &__p);
    if ((__p.__r_.__value_.__s.__size_ & 0x80u) == 0) {
      p_p = &__p;
    }
    else {
      p_p = (std::stringbuf::string_type *)__p.__r_.__value_.__r.__words[0];
    }
    *(_DWORD *)__int128 buf = 136446210;
    int v13 = p_p;
    _os_log_impl( (void *)&_mh_execute_header,  v7,  OS_LOG_TYPE_DEFAULT,  "Removed %{public}s from the cache.",  buf,  0xCu);
  }

  sub_100242CD8(&v10);
  return v6 == 0;
}

void sub_1006272F4( _Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, int a9, __int16 a10, char a11, char a12)
{
}

_BYTE *sub_100627314(uint64_t a1, uint64_t a2)
{
  unint64_t v3 = (os_log_s *)qword_1008F75A8;
  if (os_log_type_enabled((os_log_t)qword_1008F75A8, OS_LOG_TYPE_DEFAULT))
  {
    int v8 = 67109120;
    int v9 = a2;
    _os_log_impl((void *)&_mh_execute_header, v3, OS_LOG_TYPE_DEFAULT, "setPrivateModeEnabled %d", (uint8_t *)&v8, 8u);
  }

  uint64_t v4 = sub_1002E6E9C();
  int v5 = (*(uint64_t (**)(uint64_t, uint64_t))(*(void *)v4 + 1816LL))(v4, a2);
  int v6 = (os_log_s *)qword_1008F75A8;
  if (os_log_type_enabled((os_log_t)qword_1008F75A8, OS_LOG_TYPE_DEFAULT))
  {
    int v8 = 67109376;
    int v9 = a2;
    __int16 v10 = 1024;
    int v11 = v5;
    _os_log_impl( (void *)&_mh_execute_header,  v6,  OS_LOG_TYPE_DEFAULT,  "enable2MBPHYForDenylistedDevices %d returned %d",  (uint8_t *)&v8,  0xEu);
  }

  LOBYTE(v_Block_object_dispose(va, 8) = 0;
  sub_100242CA4(&v8);
  sub_1001BDD20(a2);
  sub_100242CD0(&v8);
  return sub_100242CD8(&v8);
}

void sub_10062744C( _Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, char a9)
{
}

uint64_t sub_100627468(uint64_t a1)
{
  return (*(uint64_t (**)(void, void))(**(void **)(a1 + 40) + 8LL))( *(void *)(a1 + 40),  *(void *)(a1 + 32));
}

void sub_10062747C(uint64_t a1)
{
  if (qword_1008D5F60 != -1) {
    dispatch_once(&qword_1008D5F60, &stru_1008A4638);
  }
  sub_1005528F8(qword_1008D5F58, *(void **)(a1 + 32));
}

void sub_1006274CC(uint64_t a1, uint64_t a2)
{
  if (*(_WORD *)(a1 + 594) && !*(_BYTE *)(a1 + 596))
  {
    int v8 = (os_log_s *)qword_1008F75A8;
    if (os_log_type_enabled((os_log_t)qword_1008F75A8, OS_LOG_TYPE_ERROR)) {
      sub_10069F454(a2, v8, v9, v10, v11, v12, v13, v14);
    }
    *(_BYTE *)(a1 + 596) = 1;
    *(_WORD *)(a1 + 594) = a2;
  }

  else
  {
    *(_WORD *)(a1 + 594) = a2;
    sub_100627314(a1, 1LL);
    uint64_t v4 = sub_100404FE8();
    int v5 = operator new(0x18uLL);
    uint64_t v6 = 1000LL * *(unsigned __int16 *)(a1 + 594);
    v5[4] = 1;
    *(void *)int v5 = &off_1008A4570;
    *((void *)v5 + 2) = v6;
    sub_100405744(v4, v5);
    uint64_t v7 = sub_100404FE8();
    sub_100405384(v7, &stru_1008A43F8);
  }

void sub_1006275A4(id a1)
{
  if (qword_1008D5F10 != -1) {
    dispatch_once(&qword_1008D5F10, &stru_1008A45F8);
  }
  sub_1005AD0B8((uint64_t)off_1008D5F08, 1);
}

void sub_1006275E8(uint64_t a1)
{
  if (*(_WORD *)(a1 + 594))
  {
    int v2 = *(unsigned __int8 *)(a1 + 596);
    unint64_t v3 = (os_log_s *)qword_1008F75A8;
    BOOL v4 = os_log_type_enabled((os_log_t)qword_1008F75A8, OS_LOG_TYPE_DEFAULT);
    if (v2)
    {
      if (v4)
      {
        *(_WORD *)__int128 buf = 0;
        _os_log_impl((void *)&_mh_execute_header, v3, OS_LOG_TYPE_DEFAULT, "Renew private mode.", buf, 2u);
      }

      uint64_t v5 = sub_100404FE8();
      uint64_t v6 = operator new(0x18uLL);
      uint64_t v7 = 1000LL * *(unsigned __int16 *)(a1 + 594);
      void v6[4] = 1;
      *(void *)uint64_t v6 = &off_1008A4570;
      *((void *)v6 + 2) = v7;
      sub_100405744(v5, v6);
      *(_BYTE *)(a1 + 596) = 0;
    }

    else
    {
      if (v4)
      {
        *(_WORD *)__int128 buf = 0;
        _os_log_impl((void *)&_mh_execute_header, v3, OS_LOG_TYPE_DEFAULT, "Disable private mode.", buf, 2u);
      }

      *(_WORD *)(a1 + 594) = 0;
      __int128 v17 = 0u;
      __int128 v18 = 0u;
      __int128 v19 = 0u;
      __int128 v20 = 0u;
      if (qword_1008D5F20 != -1) {
        dispatch_once(&qword_1008D5F20, &stru_1008A4598);
      }
      id v9 = sub_100626468(qword_1008D5F18);
      uint64_t v10 = (void *)objc_claimAutoreleasedReturnValue(v9);
      id v11 = [v10 countByEnumeratingWithState:&v17 objects:v22 count:16];
      if (v11)
      {
        uint64_t v12 = *(void *)v18;
        do
        {
          uint64_t v13 = 0LL;
          do
          {
            if (*(void *)v18 != v12) {
              objc_enumerationMutation(v10);
            }
            uint64_t v14 = *(void **)(*((void *)&v17 + 1) + 8LL * (void)v13);
            if (qword_1008D5F30 != -1) {
              dispatch_once(&qword_1008D5F30, &stru_1008A45D8);
            }
            sub_1005C9A38((uint64_t)off_1008D5F28, v14, @"PrivateModeDevice");
            uint64_t v13 = (char *)v13 + 1;
          }

          while (v11 != v13);
          id v11 = [v10 countByEnumeratingWithState:&v17 objects:v22 count:16];
        }

        while (v11);
      }

      sub_100627314(v15, 0LL);
      uint64_t v16 = sub_100404FE8();
      sub_100405384(v16, &stru_1008A4418);
    }
  }

  else
  {
    int v8 = (os_log_s *)qword_1008F75A8;
    if (os_log_type_enabled((os_log_t)qword_1008F75A8, OS_LOG_TYPE_DEFAULT))
    {
      *(_WORD *)__int128 buf = 0;
      _os_log_impl( (void *)&_mh_execute_header,  v8,  OS_LOG_TYPE_DEFAULT,  "Private mode has already been disabled. Nothing more to do here",  buf,  2u);
    }
  }

void sub_10062788C(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_1006278AC(id a1)
{
  if (qword_1008D5F10 != -1) {
    dispatch_once(&qword_1008D5F10, &stru_1008A45F8);
  }
  sub_1005AD0B8((uint64_t)off_1008D5F08, 0);
}

void sub_1006278F0(uint64_t a1, void *a2)
{
  id v3 = a2;
  objc_msgSend(*(id *)(a1 + 3752), "removeObject:");
  sub_10061FAB4(a1, v3, 1);
}

void sub_10062793C( _Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, id a10)
{
}

void sub_100627950(uint64_t a1, void *a2)
{
}

uint64_t sub_100627958(uint64_t a1, uint64_t a2, uint64_t a3, unsigned int **a4, int a5)
{
  v24[0] = 0LL;
  v24[1] = 0LL;
  sub_100242F28((uint64_t)v24, a1 + 48);
  id v9 = (os_log_s *)qword_1008F75A8;
  if (os_log_type_enabled((os_log_t)qword_1008F75A8, OS_LOG_TYPE_INFO))
  {
    sub_1005BF8CC(a2, &__p);
    uint64_t v10 = (__p.__r_.__value_.__s.__size_ & 0x80u) == 0
        ? &__p
        : (std::stringbuf::string_type *)__p.__r_.__value_.__r.__words[0];
    id v11 = a5 ? "YES" : "NO";
    LODWORD(buf.__r_.__value_.__l.__data_) = 136446466;
    *(std::string::size_type *)((char *)buf.__r_.__value_.__r.__words + 4) = (std::string::size_type)v10;
    WORD2(buf.__r_.__value_.__r.__words[1]) = 2082;
    *(std::string::size_type *)((char *)&buf.__r_.__value_.__r.__words[1] + 6) = (std::string::size_type)v11;
    _os_log_impl( (void *)&_mh_execute_header,  v9,  OS_LOG_TYPE_INFO,  "readKeyForDevice address:%{public}s syncedKeychain:%{public}s",  (uint8_t *)&buf,  0x16u);
  }

  __int16 v22 = 0LL;
  CFTypeRef cf = 0LL;
  uint64_t v21 = 0LL;
  v32[0] = 0LL;
  v32[1] = 0LL;
  if (qword_1008D5F30 != -1) {
    dispatch_once(&qword_1008D5F30, &stru_1008A45D8);
  }
  sub_1005C8684((uint64_t)off_1008D5F28, a2, 0, 1u, 0LL, 0LL, (unsigned __int8 *)v32);
  uint64_t v12 = sub_100241F94((const unsigned __int8 *)v32);

  uint64_t v13 = *a4;
  uint64_t v14 = a4[1];
  if (*a4 != v14)
  {
    if (a5) {
      uint64_t v15 = "YES";
    }
    else {
      uint64_t v15 = "NO";
    }
    do
    {
      int v16 = *v13;
      sub_10029819C(a2, *v13, (UInt8 **)&v22, (_DWORD *)&v21 + 1, &v21, a5, (const __CFDictionary **)&cf);
      __int128 v17 = (os_log_s *)qword_1008F75A8;
      if (os_log_type_enabled((os_log_t)qword_1008F75A8, OS_LOG_TYPE_INFO))
      {
        sub_1005BF8CC(a2, &buf);
        p_std::stringbuf::string_type buf = &buf;
        if ((buf.__r_.__value_.__s.__size_ & 0x80u) != 0) {
          p_std::stringbuf::string_type buf = (std::stringbuf::string_type *)buf.__r_.__value_.__r.__words[0];
        }
        LODWORD(__p.__r_.__value_.__l.__data_) = 136447234;
        *(std::string::size_type *)((char *)__p.__r_.__value_.__r.__words + 4) = (std::string::size_type)p_buf;
        WORD2(__p.__r_.__value_.__r.__words[1]) = 2082;
        *(std::string::size_type *)((char *)&__p.__r_.__value_.__r.__words[1] + 6) = (std::string::size_type)v15;
        HIWORD(__p.__r_.__value_.__r.__words[2]) = 1024;
        int v27 = v16;
        __int16 v28 = 1024;
        int v29 = v21;
        __int16 v30 = 1024;
        int v31 = HIDWORD(v21);
        _os_log_impl( (void *)&_mh_execute_header,  v17,  OS_LOG_TYPE_INFO,  "readKeyForDevice BTKCCopyLEDataEx address:%{public}s synced:%{public}s type:%d status:%d dataLen:%d",  (uint8_t *)&__p,  0x28u);
      }

      if (!(_DWORD)v21 && HIDWORD(v21))
      {
        uint64_t v19 = *(void *)(a3 + 8);
        sub_10056AB04(&__p, v22, HIDWORD(v21));
        sub_10032B1F8(v19, v16, (uint64_t)&__p);
        __p.__r_.__value_.__r.__words[0] = (std::string::size_type)&off_10087FAA8;
        if (__p.__r_.__value_.__l.__size_) {
          sub_1002CD254((unsigned int *)__p.__r_.__value_.__l.__size_);
        }
        if (v22)
        {
          operator delete[](v22);
          __int16 v22 = 0LL;
        }
      }

      ++v13;
    }

    while (v13 != v14);
    if (cf) {
      CFRelease(cf);
    }
  }

  return sub_100242FAC((uint64_t)v24);
}

void sub_100627C50( _Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, ...)
{
}

uint64_t sub_100627CA0(uint64_t a1, unint64_t a2, uint64_t a3, unsigned int a4, int a5)
{
  v38[0] = 0LL;
  v38[1] = 0LL;
  sub_100242F28((uint64_t)v38, a1 + 48);
  uint64_t v36 = 0LL;
  uint64_t v37 = 0LL;
  uint64_t v35 = 0LL;
  unsigned int v10 = a4 - 1;
  if (a4 - 1 < 0x10 && ((0x81EFu >> v10) & 1) != 0)
  {
    unsigned int v11 = dword_1006C4868[v10];
  }

  else if ((a4 & 0xFFFFFFFE) == 0xE)
  {
    unsigned int v11 = 4;
  }

  else
  {
    unsigned int v11 = 16;
  }

  uint64_t v34 = 0LL;
  v50[0] = 0LL;
  v50[1] = 0LL;
  if (qword_1008D5F30 != -1) {
    dispatch_once(&qword_1008D5F30, &stru_1008A45D8);
  }
  sub_1005C8684((uint64_t)off_1008D5F28, a2, 0, 1u, 0LL, 0LL, (unsigned __int8 *)v50);
  uint64_t v12 = sub_100241F94((const unsigned __int8 *)v50);

  sub_1002981F8(a2, a4, (UInt8 **)&v37, (_DWORD *)&v35 + 1, (_DWORD *)&v34 + 1, (UInt8 **)&v36, &v35, &v34);
  uint64_t v13 = (os_log_s *)qword_1008F75A8;
  if (os_log_type_enabled((os_log_t)qword_1008F75A8, OS_LOG_TYPE_INFO))
  {
    sub_1005BF8CC(a2, &__p);
    p_p = (std::stringbuf::string_type *)__p.__r_.__value_.__r.__words[0];
    uint64_t v15 = "NO";
    if ((__p.__r_.__value_.__s.__size_ & 0x80u) == 0) {
      p_p = &__p;
    }
    if (a5) {
      uint64_t v15 = "YES";
    }
    *(_DWORD *)std::stringbuf::string_type buf = 136447746;
    *(void *)&uint8_t buf[4] = p_p;
    *(_WORD *)&_BYTE buf[12] = 2082;
    *(void *)&buf[14] = v15;
    __int16 v40 = 1024;
    unsigned int v41 = a4;
    __int16 v42 = 1024;
    int v43 = HIDWORD(v35);
    __int16 v44 = 1024;
    int v45 = HIDWORD(v34);
    __int16 v46 = 1024;
    int v47 = v35;
    __int16 v48 = 1024;
    int v49 = v34;
    _os_log_impl( (void *)&_mh_execute_header,  v13,  OS_LOG_TYPE_INFO,  "readKeyForDevice BTKCCopyLEData address:%{public}s syncedKeychain:%{public}s type:%d localLen:%d localStatus:%d sy ncedLen:%d, SynedStatus:%d",  buf,  0x34u);
  }

  if (!HIDWORD(v34))
  {
    unsigned int v16 = HIDWORD(v35);
    if (HIDWORD(v35))
    {
      if (HIDWORD(v35) != v11)
      {
        __int128 v17 = (os_log_s *)qword_1008F75A8;
        if (os_log_type_enabled((os_log_t)qword_1008F75A8, OS_LOG_TYPE_FAULT))
        {
          *(_DWORD *)std::stringbuf::string_type buf = 67109632;
          *(_DWORD *)&uint8_t buf[4] = a4;
          *(_WORD *)&uint8_t buf[8] = 1024;
          *(_DWORD *)&buf[10] = v11;
          *(_WORD *)&buf[14] = 1024;
          *(_DWORD *)&uint8_t buf[16] = v16;
          _os_log_fault_impl( (void *)&_mh_execute_header,  v17,  OS_LOG_TYPE_FAULT,  "Ignoring data of invalid length for key type %d - expected %d byte(s), read %d byte(s)",  buf,  0x14u);
          unsigned int v11 = HIDWORD(v35);
        }

        else
        {
          unsigned int v11 = v16;
        }
      }

      uint64_t v18 = *(void *)(a3 + 8);
      sub_10056AB04(buf, v37, v11);
      sub_10032B1F8(v18, a4, (uint64_t)buf);
      *(void *)std::stringbuf::string_type buf = &off_10087FAA8;
      if (*(void *)&buf[8]) {
        sub_1002CD254(*(unsigned int **)&buf[8]);
      }
      if ((_DWORD)v34 || !(_DWORD)v35)
      {
        if (!(_DWORD)v34 || !a5) {
          goto LABEL_49;
        }
      }

      else
      {
        else {
          size_t v19 = HIDWORD(v35);
        }
        if (!memcmp(v37, v36, v19) || (a5 & 1) == 0) {
          goto LABEL_49;
        }
      }

      __int16 v30 = (os_log_s *)qword_1008F75A8;
      if (os_log_type_enabled((os_log_t)qword_1008F75A8, OS_LOG_TYPE_DEFAULT))
      {
        *(_WORD *)std::stringbuf::string_type buf = 0;
        _os_log_impl( (void *)&_mh_execute_header,  v30,  OS_LOG_TYPE_DEFAULT,  "storing synced data with the local values",  buf,  2u);
      }

      int v31 = sub_100241F94((const unsigned __int8 *)v50);
      int v29 = (void *)objc_claimAutoreleasedReturnValue(v31);
      sub_100628230(a1, a2, v29, a3, a4, 1);
LABEL_48:

LABEL_49:
      int v20 = v34;
      goto LABEL_50;
    }
  }

  int v20 = v34;
  if (!(_DWORD)v34)
  {
    unsigned int v21 = v35;
    if ((_DWORD)v35)
    {
      if ((_DWORD)v35 != v11)
      {
        __int16 v22 = (os_log_s *)qword_1008F75A8;
        if (os_log_type_enabled((os_log_t)qword_1008F75A8, OS_LOG_TYPE_FAULT))
        {
          *(_DWORD *)std::stringbuf::string_type buf = 67109632;
          *(_DWORD *)&uint8_t buf[4] = a4;
          *(_WORD *)&uint8_t buf[8] = 1024;
          *(_DWORD *)&buf[10] = v11;
          *(_WORD *)&buf[14] = 1024;
          *(_DWORD *)&uint8_t buf[16] = v21;
          _os_log_fault_impl( (void *)&_mh_execute_header,  v22,  OS_LOG_TYPE_FAULT,  "Ignoring data of invalid length for key type %d - expected %d byte(s), read %d byte(s)",  buf,  0x14u);
          unsigned int v11 = v35;
        }

        else
        {
          unsigned int v11 = v21;
        }
      }

      uint64_t v23 = *(void *)(a3 + 8);
      sub_10056AB04(buf, v36, v11);
      sub_10032B1F8(v23, a4, (uint64_t)buf);
      *(void *)std::stringbuf::string_type buf = &off_10087FAA8;
      if (*(void *)&buf[8]) {
        sub_1002CD254(*(unsigned int **)&buf[8]);
      }
      if ((a5 & 1) != 0) {
        goto LABEL_49;
      }
      uint64_t v24 = sub_100241F94((const unsigned __int8 *)v50);
      uint64_t v25 = (void *)objc_claimAutoreleasedReturnValue(v24);
      BOOL v26 = sub_10061C0F8(a1, v25);

      if (!v26) {
        goto LABEL_49;
      }
      int v27 = (os_log_s *)qword_1008F75A8;
      if (os_log_type_enabled((os_log_t)qword_1008F75A8, OS_LOG_TYPE_DEFAULT))
      {
        *(_WORD *)std::stringbuf::string_type buf = 0;
        _os_log_impl( (void *)&_mh_execute_header,  v27,  OS_LOG_TYPE_DEFAULT,  "writing local data with the synced values",  buf,  2u);
      }

      __int16 v28 = sub_100241F94((const unsigned __int8 *)v50);
      int v29 = (void *)objc_claimAutoreleasedReturnValue(v28);
      sub_100628230(a1, a2, v29, a3, a4, 0);
      goto LABEL_48;
    }
  }