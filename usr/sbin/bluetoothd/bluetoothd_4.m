uint64_t sub_1001BC418()
{
  uint64_t result;
  result = sub_10019D6F8();
  dword_1008ECC5C = 0;
  return result;
}

uint64_t sub_1001BC434()
{
  sub_1001EE0E4( "gOverrideLocalAddress:%d gPrivateMode:%d gLePrivateAddressTimer:%d gHoldStableAddress=%d gLeHoldStablePrivateAddress Timer=%d callCount=%d\n",  byte_1008ECCA1,  byte_1008ECCA0,  dword_1008ECCAC,  byte_1008ECCB4,  dword_1008ECCB0,  (unsigned __int16)word_1008ECCB6);
  sub_1001EE0E4( "gNoAddressRotationWhileScanningOrConnecting=%d gRefreshLocalAddressOnConnectionComplete=%d gRefreshLocalAddressOnSca nComplete=%d gAddressRefreshFirstDeferral=%ld.%d\n",  byte_1008E8A40,  byte_1008ECCBB,  dword_1008ECCBC,  word_1008ECCC0,  v2);
  sub_1001EE0E4("gRefreshLocalAddressOnAdvertisingSettled=%d", byte_1008ECCB8);
  sub_1001EE0E4( "supportedStates:%@ ADFlags:%x LeRoles:%x LeCurrentAddressType:%x discoveryType:%x\n",  &qword_1008E8AF0,  8LL,  byte_1008E8AF9,  byte_1008E8AF8,  byte_1008ECC6D,  byte_1008E8B18);
  sub_1001EE0E4( "gPeripheralPrivacyFlagEnabled:%x gLeBondable:%x gAutoAddressRefresh:%x\n",  byte_1008ECCA2,  byte_1008ECCA8,  byte_1008D8EAC);
  sub_1001EE0E4( "gPrivateAddressRotateInterval=%d gPrivateAddressRotateIntervalOverride=%d\n\n",  6000,  (unsigned __int16)word_1008ECCC4);
  sub_1001EE0E4("gAddressRotationInProgress=%d", byte_1008ECCB9);
  sub_1001EE0E4( "gFastLeConnectionMaxSlots=%d gFastLeConnectionUsedSlots=%d MAX_FAST_LE_CONNECTION_LIST_SIZE=%d",  byte_1008ECCD8,  byte_1008ECCD9,  32);
  sub_1001EE0E4("Advertising TX Power:\n");
  if (sub_10019C5A4())
  {
    unint64_t v0 = 0LL;
    do
    {
      sub_1001EE0E4("\tInstance:%d power:%d\n", v0, *((char *)&dword_1008ECC68 + v0));
      ++v0;
    }

    while (v0 < sub_10019C5A4());
  }

  sub_1001AFD1C();
  sub_10019FCA8();
  return sub_1001C6A50();
}

void sub_1001BC61C(uint64_t a1, uint64_t a2, uint64_t a3)
{
  if (sub_1000A86F0())
  {
    sub_1001EE134((uint64_t)"_initMultipleAdvertisingLocalCB", v6, v7, v8, v9, v10, v11, v12, *(uint64_t *)v14);
    v13 = (os_log_s *)sub_100086554(0x42u);
    if (os_log_type_enabled(v13, OS_LOG_TYPE_DEFAULT))
    {
      *(_DWORD *)v14 = 136446210;
      *(void *)&v14[4] = sub_1001EDDCC();
      _os_log_impl((void *)&_mh_execute_header, v13, OS_LOG_TYPE_DEFAULT, " %{public}s", v14, 0xCu);
    }
  }

  if (!(_DWORD)a1) {
    sub_1001BC710();
  }
  if (off_1008ECC60) {
    off_1008ECC60(a1, a2, a3);
  }
  off_1008ECC60 = 0LL;
}

void sub_1001BC710()
{
  byte_1008ECCA2 = byte_1008ECC6D != 0;
  sub_1001BCDDC( (int *)((char *)&dword_1008ECC6E[2 * byte_1008ECC6D] - byte_1008ECC6D),  1);
  if (!byte_1008ECC6D)
  {
    sub_1001ABEC8(0, v0, v1, v2, v3, v4, v5, v6);
    sub_10019D9F8(0);
    sub_1001C6890(0);
  }

uint64_t sub_1001BC780(unsigned int a1, char a2, int a3, uint64_t (*a4)(void, void, void))
{
  byte_1008ECC48 = 0;
  off_1008ECC50 = 0LL;
  byte_1008ECC58 = 0;
  dword_1008ECC68 = 2139062143;
  byte_1008ECC6C = 127;
  if (a1 >= 5)
  {
    sub_1001EE2A0();
    return 4062LL;
  }

  byte_1008ECC6D = a1;
  byte_1008D8EAC = a2;
  bzero(&unk_1008E8B20, 0x4128uLL);
  uint64_t v7 = sub_1001BC95C();
  if ((_DWORD)v7)
  {
    uint64_t v4 = v7;
    if (sub_1000A86F0())
    {
      sub_1001EE134((uint64_t)"LE_GAP_GenerateAddress failed with status %!", v8, v9, v10, v11, v12, v13, v14, v4);
      v15 = (os_log_s *)sub_100086554(0x42u);
      if (os_log_type_enabled(v15, OS_LOG_TYPE_ERROR)) {
LABEL_7:
      }
        sub_100657858();
    }
  }

  else
  {
    off_1008ECC60 = a4;
    if (a3)
    {
      uint64_t v4 = sub_10019DF08((uint64_t (*)(void, void, void))sub_1001BC61C);
      if ((_DWORD)v4)
      {
        if (sub_1000A86F0())
        {
          sub_1001EE134( (uint64_t)"LE_InitMultipleAdvertising failed with status %!",  v17,  v18,  v19,  v20,  v21,  v22,  v23,  v4);
          v24 = (os_log_s *)sub_100086554(0x42u);
          if (os_log_type_enabled(v24, OS_LOG_TYPE_ERROR)) {
            goto LABEL_7;
          }
        }
      }
    }

    else
    {
      sub_1001BC710();
      off_1008ECC98 = a4;
      if (!a4) {
        return 0LL;
      }
      uint64_t v4 = sub_1001EE6E8((uint64_t)sub_1001BCA04, 0LL, 0, 0LL);
      if ((_DWORD)v4)
      {
        if (sub_1000A86F0())
        {
          sub_1001EE134( (uint64_t)"Could not register LE GAP Init Callback timer, status:%!",  v25,  v26,  v27,  v28,  v29,  v30,  v31,  v4);
          v32 = (os_log_s *)sub_100086554(0x42u);
          if (os_log_type_enabled(v32, OS_LOG_TYPE_ERROR)) {
            sub_100657858();
          }
        }

        return 4062LL;
      }
    }
  }

  return v4;
}

uint64_t sub_1001BC95C()
{
  if (!dword_1008F7010) {
    return 103LL;
  }
  if (byte_1008ECC6D != 3) {
    return 0LL;
  }
  uint64_t v0 = sub_1001BDAC8(3LL);
  if ((_DWORD)v0)
  {
    if (sub_1000A86F0())
    {
      sub_1001EE134( (uint64_t)"creaetAddress with address type %d failed with error %! in LE_GAP_GenerateAddress",  v1,  v2,  v3,  v4,  v5,  v6,  v7,  byte_1008ECC6D);
      uint64_t v8 = (os_log_s *)sub_100086554(0x42u);
      if (os_log_type_enabled(v8, OS_LOG_TYPE_ERROR)) {
        sub_100657858();
      }
    }
  }

  return v0;
}

uint64_t sub_1001BCA04()
{
  return off_1008ECC98(0LL, 0LL, 0LL);
}

uint64_t sub_1001BCA1C(unint64_t a1)
{
  if (byte_1008ECCA0)
  {
    if (sub_1000A86F0())
    {
      sub_1001EE134((uint64_t)"Cannot override local address while in private mode", v1, v2, v3, v4, v5, v6, v7, v39);
      uint64_t v8 = (os_log_s *)sub_100086554(0x42u);
      if (os_log_type_enabled(v8, OS_LOG_TYPE_ERROR)) {
        sub_100657858();
      }
    }

    return 408LL;
  }

  if (!a1)
  {
    byte_1008ECCA1 = 0;
    sub_1001B835C();
    int v28 = sub_1000A86F0();
    uint64_t result = 0LL;
    if (!v28) {
      return result;
    }
    sub_1001EE134((uint64_t)"Going back to self rotating address", v21, v22, v23, v24, v25, v26, v27, v39);
    uint64_t v29 = (os_log_s *)sub_100086554(0x42u);
    BOOL v30 = os_log_type_enabled(v29, OS_LOG_TYPE_DEFAULT);
    uint64_t result = 0LL;
    if (!v30) {
      return result;
    }
    *(_DWORD *)buf = 136446210;
    v41 = sub_1001EDDCC();
    _os_log_impl((void *)&_mh_execute_header, v29, OS_LOG_TYPE_DEFAULT, " %{public}s", buf, 0xCu);
    return 0LL;
  }

  if ((a1 & 0xFF000000000000LL) != 0)
  {
    sub_1001BCCC4();
    byte_1008ECCA1 = 1;
    uint64_t v11 = (char *)&dword_1008ECC6E[2 * byte_1008ECC6D] - byte_1008ECC6D;
    v11[6] = a1;
    *((_WORD *)v11 + 2) = ((a1 << 16) & 0xFF00000000LL | ((unint64_t)BYTE1(a1) << 40)) >> 32;
    *(_DWORD *)uint64_t v11 = a1 & 0xFF000000 | (a1 >> 16) & 0xFF0000 | WORD2(a1) & 0xFF00 | BYTE6(a1);
    if (sub_1000A86F0())
    {
      uint64_t v19 = *((_BYTE *)&dword_1008ECC6E[2 * byte_1008ECC6D] - byte_1008ECC6D)
          ? "Random"
          : "Public";
      sub_1001EE134((uint64_t)"Overriding address to %s:%:", v12, v13, v14, v15, v16, v17, v18, (uint64_t)v19);
      uint64_t v20 = (os_log_s *)sub_100086554(0x42u);
      if (os_log_type_enabled(v20, OS_LOG_TYPE_DEFAULT))
      {
        *(_DWORD *)buf = 136446210;
        v41 = sub_1001EDDCC();
        _os_log_impl((void *)&_mh_execute_header, v20, OS_LOG_TYPE_DEFAULT, " %{public}s", buf, 0xCu);
      }
    }

    sub_1001BCDDC( (int *)((char *)&dword_1008ECC6E[2 * byte_1008ECC6D] - byte_1008ECC6D),  0);
    return 0LL;
  }

  if (sub_1000A86F0())
  {
    sub_1001EE134((uint64_t)"Cannot set local public address !", v31, v32, v33, v34, v35, v36, v37, v39);
    v38 = (os_log_s *)sub_100086554(0x42u);
    if (os_log_type_enabled(v38, OS_LOG_TYPE_ERROR)) {
      sub_100657858();
    }
  }

  return 101LL;
}

uint64_t sub_1001BCCC4()
{
  if (sub_1000A86F0())
  {
    sub_1001EE134( (uint64_t)"Canceling PrivateAddressTimer gPrivateMode=%d gOverrideLocalAddress=%d gHoldStableAddress=%d",  v0,  v1,  v2,  v3,  v4,  v5,  v6,  byte_1008ECCA0);
    uint64_t v7 = (os_log_s *)sub_100086554(0x42u);
    if (os_log_type_enabled(v7, OS_LOG_TYPE_DEFAULT))
    {
      *(_DWORD *)buf = 136446210;
      uint64_t v10 = sub_1001EDDCC();
      _os_log_impl((void *)&_mh_execute_header, v7, OS_LOG_TYPE_DEFAULT, " %{public}s", buf, 0xCu);
    }
  }

  uint64_t result = dword_1008ECCAC;
  if (dword_1008ECCAC)
  {
    uint64_t result = sub_1001EEB14(dword_1008ECCAC);
    dword_1008ECCAC = 0;
  }

  return result;
}

uint64_t sub_1001BCDB0(unint64_t a1)
{
  return (a1 << 32) & 0xFF0000000000LL | (a1 << 48) | (a1 << 16) & 0xFF00000000LL | a1 & 0xFF000000 | (a1 >> 16) & 0xFF0000 | WORD2(a1) & 0xFF00 | BYTE6(a1);
}

void sub_1001BCDDC(int *a1, int a2)
{
  if (sub_1000A86F0())
  {
    sub_1001EE134( (uint64_t)"_refreshLeAddressHelper gNeedToStopAdvertisingWhenAddressChanges=%d gOverrideLocalAddress:%d gHoldStableA ddress=%d callCount=%d gLeHoldStablePrivateAddressTimer=%d gLeCurrentAddress=%d gLeNonConnectableAddressT ype=%d gLeNonConnectableSecondaryAddressType=%d",  v4,  v5,  v6,  v7,  v8,  v9,  v10,  byte_1008ECC58);
    uint64_t v11 = (os_log_s *)sub_100086554(0x42u);
    if (os_log_type_enabled(v11, OS_LOG_TYPE_DEFAULT))
    {
      *(_DWORD *)buf = 136446210;
      *(void *)&uint8_t buf[4] = sub_1001EDDCC();
      _os_log_impl((void *)&_mh_execute_header, v11, OS_LOG_TYPE_DEFAULT, " %{public}s", buf, 0xCu);
    }
  }

  byte_1008ECCB9 = 1;
  if (byte_1008ECC58 == 1)
  {
    byte_1008ECC58 = 0;
    sub_10019C5B0(1);
  }

  sub_1001BA04C();
  if (*(_BYTE *)a1 == 1)
  {
    sub_10019DEC8(a1, 0LL, v12, v13, v14, v15, v16, v17);
    sub_10019DD08(a1, 4u, 0LL, v18, v19, v20, v21, v22);
  }

  __int16 v83 = 0;
  int v82 = 0;
  char v81 = 1;
  arc4random_buf(&v82, 6uLL);
  LOBYTE(v82) = v82 & 0x3F;
  if (byte_1008D8EAE)
  {
    if (byte_1008D8EAD == 3)
    {
      v60 = sub_1001D46D4();
      __int16 v80 = 0;
      int v79 = 0;
      *(_WORD *)&buf[5] = 0;
      *(_DWORD *)&buf[1] = 0;
      buf[0] = 1;
      do
      {
        arc4random_buf(&buf[1], 3uLL);
        BOOL v61 = *(unsigned __int16 *)&buf[1] == (unsigned __int16)v79 && buf[3] == BYTE2(v79);
      }

      while (v61 || !(*(unsigned __int16 *)&buf[1] ^ 0xFF | buf[3]));
      buf[1] = buf[1] & 0x3F | 0x40;
      uint64_t v62 = sub_1001D2AC0((__int16 *)&buf[1], 1);
      if ((_DWORD)v62)
      {
        uint64_t v63 = v62;
        if (sub_1000A86F0())
        {
          sub_1001EE134( (uint64_t)"Failed to generate a non connectable random address with status %! for address %:, falling back to non resolvable",  v64,  v65,  v66,  v67,  v68,  v69,  v70,  v63);
          v71 = (os_log_s *)sub_100086554(0x42u);
          if (os_log_type_enabled(v71, OS_LOG_TYPE_ERROR)) {
            sub_100657F74();
          }
        }
      }

      else
      {
        char v78 = 0;
        __int16 v77 = 0;
        uint64_t v72 = sub_100110FB8(v60, (__int16 *)&buf[1], (uint64_t)&v77);
        if (!(_DWORD)v72)
        {
          int v28 = (int *)buf;
          goto LABEL_14;
        }

        uint64_t v73 = v72;
        if (sub_1000A86F0())
        {
          sub_1001EE134( (uint64_t)"Failed to resolve the non connectable random address with status %! for address %:, falling back to non resolvable",  v74,  v75,  v66,  v67,  v68,  v69,  v70,  v73);
          v76 = (os_log_s *)sub_100086554(0x42u);
          if (os_log_type_enabled(v76, OS_LOG_TYPE_ERROR)) {
            sub_100657F74();
          }
        }
      }

      sub_10019DD08((int *)&v81, 1u, 0LL, v66, v67, v68, v69, v70);
      return;
    }

    if (byte_1008D8EAD == 2)
    {
      int v28 = (int *)&v81;
LABEL_14:
      sub_10019DD08(v28, 1u, 0LL, v23, v24, v25, v26, v27);
    }
  }

  if (byte_1008ECCA9)
  {
    arc4random_buf(&v82, 6uLL);
    LOBYTE(v82) = v82 & 0x3F;
    sub_10019DD08((int *)&v81, 3u, 0LL, v29, v30, v31, v32, v33);
  }

  if (sub_1000A86F0())
  {
    v41 = byte_1008D8EAE ? "  Non Connectable:" : "";
    sub_1001EE134((uint64_t)"_refreshLeAddressHelper %@%@%@%@", v34, v35, v36, v37, v38, v39, v40, (uint64_t)v41);
    v42 = (os_log_s *)sub_100086554(0x42u);
    if (os_log_type_enabled(v42, OS_LOG_TYPE_DEFAULT))
    {
      v43 = sub_1001EDDCC();
      *(_DWORD *)buf = 136446210;
      *(void *)&uint8_t buf[4] = v43;
      _os_log_impl((void *)&_mh_execute_header, v42, OS_LOG_TYPE_DEFAULT, " %{public}s", buf, 0xCu);
    }
  }

uint64_t sub_1001BD2B0()
{
  if (sub_1000A86F0())
  {
    sub_1001EE134((uint64_t)"LE_GAP_TerminateAdvertising", v0, v1, v2, v3, v4, v5, v6, *(uint64_t *)v17);
    uint64_t v7 = (os_log_s *)sub_100086554(0x42u);
    if (os_log_type_enabled(v7, OS_LOG_TYPE_DEFAULT))
    {
      *(_DWORD *)uint64_t v17 = 136446210;
      *(void *)&v17[4] = sub_1001EDDCC();
      _os_log_impl((void *)&_mh_execute_header, v7, OS_LOG_TYPE_DEFAULT, " %{public}s", v17, 0xCu);
    }
  }

  sub_1001BA310(0);
  byte_1008ECC48 = 0;
  off_1008ECC50 = 0LL;
  byte_1008ECC6D = 0;
  sub_10019DCE4();
  return sub_10019E340(v8, v9, v10, v11, v12, v13, v14, v15);
}

uint64_t sub_1001BD390( unsigned int a1, unsigned int a2, uint64_t a3, uint64_t a4, unsigned int a5, unsigned int a6, unsigned __int8 a7, unsigned __int8 a8)
{
  if (!dword_1008F7010) {
    return 103LL;
  }
  if ((qword_1008E8AF0 & 0x40) != 0)
  {
    if ((byte_1008E8AF8 & 8) != 0)
    {
      if (sub_1001D5C2C())
      {
        if (a1) {
          uint64_t v33 = a1;
        }
        else {
          uint64_t v33 = 204LL;
        }
        if (a2) {
          uint64_t v34 = a2;
        }
        else {
          uint64_t v34 = 108LL;
        }
        if (a5) {
          uint64_t v35 = a5;
        }
        else {
          uint64_t v35 = 20LL;
        }
        uint64_t v16 = sub_1001AB0A4(v33, v34, v35, a6, 0LL, 10, a3, a4, a7, a8);
        if ((_DWORD)v16)
        {
          if (sub_1000A86F0())
          {
            sub_1001EE134((uint64_t)"Could not start auto-connect : %!", v36, v37, v38, v39, v40, v41, v42, v16);
            v43 = (os_log_s *)sub_100086554(0x42u);
            if (os_log_type_enabled(v43, OS_LOG_TYPE_ERROR)) {
              sub_100657858();
            }
          }
        }
      }

      else
      {
        if (sub_1000A86F0())
        {
          sub_1001EE134( (uint64_t)"There are no devices in the filter accept list. Can't trigger auto-connection.",  v44,  v45,  v46,  v47,  v48,  v49,  v50,  v53);
          uint64_t v51 = (os_log_s *)sub_100086554(0x42u);
          if (os_log_type_enabled(v51, OS_LOG_TYPE_ERROR)) {
            sub_100657858();
          }
        }

        return 4066LL;
      }
    }

    else
    {
      if (sub_1000A86F0())
      {
        sub_1001EE134( (uint64_t)"We can only be in auto connection mode in Central role.",  v17,  v18,  v19,  v20,  v21,  v22,  v23,  v53);
        uint64_t v24 = (os_log_s *)sub_100086554(0x42u);
        if (os_log_type_enabled(v24, OS_LOG_TYPE_ERROR)) {
          sub_100657858();
        }
      }

      return 4065LL;
    }
  }

  else
  {
    if (sub_1000A86F0())
    {
      sub_1001EE134((uint64_t)"Device does not support incoming connections.", v8, v9, v10, v11, v12, v13, v14, v53);
      uint64_t v15 = (os_log_s *)sub_100086554(0x42u);
      if (os_log_type_enabled(v15, OS_LOG_TYPE_ERROR)) {
        sub_100657858();
      }
    }

    return 1330LL;
  }

  return v16;
}

uint64_t sub_1001BD58C(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, int a6, int a7)
{
  if (!dword_1008F7010) {
    return 103LL;
  }
  if (a1 && sub_10012D5EC(a1))
  {
    if (*(_BYTE *)(a1 + 70) == 1) {
      return sub_1001CA0A0(a1, a2, a3, a4, a5);
    }
    else {
      return sub_1001AD740(a1, a2, a3, a4, a5, a6, a7);
    }
  }

  else
  {
    if (sub_1000A86F0())
    {
      sub_1001EE134((uint64_t)"This handle is not a LE connection.", v15, v16, v17, v18, v19, v20, v21, v23);
      uint64_t v22 = (os_log_s *)sub_100086554(0x42u);
      if (os_log_type_enabled(v22, OS_LOG_TYPE_ERROR)) {
        sub_100657858();
      }
    }

    return 1310LL;
  }

uint64_t sub_1001BD69C( uint64_t a1, unsigned int a2, unsigned int a3, unsigned int a4, unsigned int a5, int a6)
{
  if (!dword_1008F7010) {
    return 103LL;
  }
  if (a1 && sub_10012D5EC(a1)) {
    return sub_1001ADC7C(a1, a2, a3, a4, a5, a6);
  }
  if (sub_1000A86F0())
  {
    sub_1001EE134((uint64_t)"This handle is not a LE connection.", v13, v14, v15, v16, v17, v18, v19, v21);
    uint64_t v20 = (os_log_s *)sub_100086554(0x42u);
    if (os_log_type_enabled(v20, OS_LOG_TYPE_ERROR)) {
      sub_100657858();
    }
  }

  return 1310LL;
}

uint64_t sub_1001BD774(_DWORD *a1)
{
  if (!dword_1008F7010) {
    return 103LL;
  }
  uint64_t v1 = sub_10012D98C(a1);
  return sub_1001B7974(v1);
}

uint64_t sub_1001BD7A4(uint64_t (*a1)(void))
{
  uint64_t v12 = 0LL;
  if (!dword_1008F7010) {
    return 103LL;
  }
  while (sub_10012ECBC(&v12))
  {
    if (*(_BYTE *)(v12 + 124) != 7)
    {
      if (sub_1001B7974(v12))
      {
        if (sub_1000A86F0())
        {
          sub_1001EE134((uint64_t)"Failed to disconnect handle %x (address %:)", v2, v3, v4, v5, v6, v7, v8, v12);
          uint64_t v9 = (os_log_s *)sub_100086554(0x42u);
          if (os_log_type_enabled(v9, OS_LOG_TYPE_ERROR))
          {
            uint64_t v10 = sub_1001EDDCC();
            *(_DWORD *)buf = 136446466;
            uint64_t v14 = v10;
            __int16 v15 = 1024;
            int v16 = 0xFFFF;
            _os_log_error_impl( (void *)&_mh_execute_header,  v9,  OS_LOG_TYPE_ERROR,  "%{public}s (status=%{bluetooth:OI_STATUS}u)",  buf,  0x12u);
          }
        }
      }

      off_1008E8A48 = a1;
    }
  }

  if (off_1008E8A48) {
    return 0LL;
  }
  else {
    return 122LL;
  }
}

uint64_t sub_1001BD924()
{
  return sub_1001ADDD4();
}

uint64_t sub_1001BD934(char a1)
{
  if (!dword_1008F7010) {
    return 103LL;
  }
  uint64_t result = 0LL;
  byte_1008ECCA8 = a1;
  return result;
}

uint64_t sub_1001BD960()
{
  return byte_1008ECCA8;
}

uint64_t sub_1001BD96C(uint64_t a1, int a2)
{
  if (!dword_1008F7010) {
    return 103LL;
  }
  if ((byte_1008E8AF8 & 0xC) != 0)
  {
    if (sub_1000A86F0())
    {
      sub_1001EE134( (uint64_t)"LE_GAP is Asking to pair... because someone called StartBonding.",  v4,  v5,  v6,  v7,  v8,  v9,  v10,  *(uint64_t *)v21);
      uint64_t v11 = (os_log_s *)sub_100086554(0x42u);
      if (os_log_type_enabled(v11, OS_LOG_TYPE_DEFAULT))
      {
        *(_DWORD *)uint64_t v21 = 136446210;
        *(void *)&v21[4] = sub_1001EDDCC();
        _os_log_impl((void *)&_mh_execute_header, v11, OS_LOG_TYPE_DEFAULT, " %{public}s", v21, 0xCu);
      }
    }

    return sub_1001D377C(a1, a2);
  }

  else
  {
    if (sub_1000A86F0())
    {
      sub_1001EE134( (uint64_t)"We can only pair in Central or peripheral role.",  v13,  v14,  v15,  v16,  v17,  v18,  v19,  *(uint64_t *)v21);
      uint64_t v20 = (os_log_s *)sub_100086554(0x42u);
      if (os_log_type_enabled(v20, OS_LOG_TYPE_ERROR)) {
        sub_100657858();
      }
    }

    return 4068LL;
  }

uint64_t sub_1001BDAB4(uint64_t result)
{
  byte_1008ECCA9 = result;
  return result;
}

uint64_t sub_1001BDAC0()
{
  return 152LL;
}

uint64_t sub_1001BDAC8(uint64_t a1)
{
  switch((int)a1)
  {
    case 0:
      uint64_t v2 = 0LL;
      LOBYTE(dword_1008ECC6E[0]) = 0;
      *(int *)((char *)dword_1008ECC6E + 1) = dword_1008F6D18;
      *(__int16 *)((char *)&word_1008ECC72 + 1) = word_1008F6D1C;
      break;
    case 1:
      byte_1008ECC75 = 1;
      arc4random_buf(&byte_1008ECC76, 6uLL);
      uint64_t v2 = 0LL;
      byte_1008ECC76 |= 0xC0u;
      break;
    case 2:
      byte_1008ECC7C = 1;
      while (1)
      {
        do
          arc4random_buf(&dword_1008ECC7D, 6uLL);
        while (!(dword_1008ECC7D | (unsigned __int16)word_1008ECC81));
        if (dword_1008ECC7D ^ 0xFF | (unsigned __int16)word_1008ECC81)
        {
          if (dword_1008ECC7D != dword_1008F6D18 || word_1008ECC81 != word_1008F6D1C) {
            break;
          }
        }
      }

      uint64_t v2 = 0LL;
      LOBYTE(dword_1008ECC7D) = dword_1008ECC7D & 0x3F;
      break;
    case 3:
      uint64_t v12 = sub_1001D46D0();
      byte_1008ECC83 = 1;
      do
      {
        do
          arc4random_buf(&word_1008ECC84, 3uLL);
        while (!((unsigned __int16)word_1008ECC84 | byte_1008ECC86));
      }

      while (!((unsigned __int16)word_1008ECC84 ^ 0xFF | byte_1008ECC86));
      LOBYTE(word_1008ECC84) = word_1008ECC84 & 0x3F | 0x40;
      uint64_t v13 = sub_1001D2AC0(&word_1008ECC84, 0);
      if ((_DWORD)v13)
      {
        uint64_t v2 = v13;
        if (sub_1000A86F0())
        {
          sub_1001EE134( (uint64_t)"Failed to generate a random address with status %! for address %:",  v14,  v15,  v16,  v17,  v18,  v19,  v20,  v2);
          uint64_t v21 = (os_log_s *)sub_100086554(0x42u);
          if (os_log_type_enabled(v21, OS_LOG_TYPE_ERROR)) {
            sub_100657F74();
          }
        }
      }

      else
      {
        char v24 = 0;
        __int16 v23 = 0;
        uint64_t v2 = sub_100110FB8(v12, &word_1008ECC84, (uint64_t)&v23);
        if ((_DWORD)v2) {
          goto LABEL_4;
        }
      }

      break;
    default:
      sub_1001EE2A0();
      uint64_t v2 = 4069LL;
LABEL_4:
      if (sub_1000A86F0())
      {
        sub_1001EE134( (uint64_t)"Could not generate a new address of type %d with status %!.",  v3,  v4,  v5,  v6,  v7,  v8,  v9,  a1);
        uint64_t v10 = (os_log_s *)sub_100086554(0x42u);
        if (os_log_type_enabled(v10, OS_LOG_TYPE_ERROR)) {
          sub_100657858();
        }
      }

      break;
  }

  return v2;
}

void sub_1001BDD20(unsigned int a1)
{
  if (sub_1000A86F0())
  {
    sub_1001EE134((uint64_t)"EnablePrivateMode:%d", v2, v3, v4, v5, v6, v7, v8, a1);
    uint64_t v9 = (os_log_s *)sub_100086554(0x42u);
    if (os_log_type_enabled(v9, OS_LOG_TYPE_DEFAULT))
    {
      *(_DWORD *)buf = 136446210;
      uint64_t v11 = sub_1001EDDCC();
      _os_log_impl((void *)&_mh_execute_header, v9, OS_LOG_TYPE_DEFAULT, " %{public}s", buf, 0xCu);
    }
  }

  byte_1008ECCA0 = a1;
  if ((a1 & 1) == 0) {
    sub_1001B835C();
  }
}

uint64_t sub_1001BDDF4(unsigned int a1, char a2)
{
  if (!dword_1008F7010) {
    return 103LL;
  }
  if (a1 < 5 && a1)
  {
    byte_1008D8EAD = a1;
    byte_1008D8EAE = a2;
    sub_1001BCDDC( (int *)((char *)&dword_1008ECC6E[2 * byte_1008ECC6D] - byte_1008ECC6D),  1);
    return 0LL;
  }

  else
  {
    sub_1001EE2A0();
    return 4071LL;
  }

uint64_t sub_1001BDE68()
{
  if (!dword_1008F7010) {
    return 103LL;
  }
  unsigned int v0 = byte_1008ECC6D;
  byte_1008ECCA2 = byte_1008ECC6D != 0;
  if (byte_1008ECC6D == 3)
  {
    uint64_t v1 = sub_1001BDAC8(3LL);
    if ((_DWORD)v1)
    {
      uint64_t v2 = v1;
      if (sub_1000A86F0())
      {
        sub_1001EE134( (uint64_t)"createAddress with type %d failed with status %! in LE_GAP_RefreshAddress",  v3,  v4,  v5,  v6,  v7,  v8,  v9,  byte_1008ECC6D);
        uint64_t v10 = (os_log_s *)sub_100086554(0x42u);
        if (os_log_type_enabled(v10, OS_LOG_TYPE_ERROR)) {
          sub_100657858();
        }
      }

      return v2;
    }

    unsigned int v0 = byte_1008ECC6D;
  }

  sub_1001BCDDC((int *)((char *)&dword_1008ECC6E[2 * v0] - v0), 1);
  if (!byte_1008ECC6D)
  {
    sub_1001ABEC8(0, v11, v12, v13, v14, v15, v16, v17);
    sub_10019D9F8(0);
    sub_1001C6890(0);
  }

  return 0LL;
}

char *sub_1001BDF5C(unsigned int a1, uint64_t a2)
{
  if (a1) {
    uint64_t result = sub_10019DCF4(a1);
  }
  else {
    uint64_t result = (char *)&dword_1008ECC6E[2 * byte_1008ECC6D] - byte_1008ECC6D;
  }
  int v4 = *(_DWORD *)result;
  __int16 v5 = *((_WORD *)result + 2);
  *(_BYTE *)(a2 + 6) = result[6];
  *(_WORD *)(a2 + 4) = v5;
  *(_DWORD *)a2 = v4;
  return result;
}

uint64_t sub_1001BDFB4(uint64_t result)
{
  uint64_t v1 = (char *)&dword_1008ECC6E[2 * byte_1008ECC6D] - byte_1008ECC6D;
  char v2 = v1[6];
  __int16 v3 = *((_WORD *)v1 + 2);
  *(_DWORD *)uint64_t result = *(_DWORD *)v1;
  *(_WORD *)(result + 4) = v3;
  *(_BYTE *)(result + 6) = v2;
  return result;
}

uint64_t sub_1001BDFE8(uint64_t result)
{
  int v1 = dword_1008ECC6E[0];
  __int16 v2 = word_1008ECC72;
  *(_BYTE *)(result + 6) = byte_1008ECC74;
  *(_WORD *)(result + 4) = v2;
  *(_DWORD *)uint64_t result = v1;
  return result;
}

uint64_t sub_1001BE00C()
{
  if (!BYTE9(xmmword_1008F6D58)) {
    return 0LL;
  }
  if (dword_1008F7010) {
    return 140LL;
  }
  LOBYTE(dword_1008ECC6E[0]) = 0;
  *(int *)((char *)dword_1008ECC6E + 1) = dword_1008F6D18;
  *(__int16 *)((char *)&word_1008ECC72 + 1) = word_1008F6D1C;
  sub_1001BDAC8(2LL);
  byte_1008ECC75 = 1;
  arc4random_buf(&byte_1008ECC76, 6uLL);
  byte_1008ECC76 |= 0xC0u;
  byte_1008ECC6D = 0;
  dword_1008ECCAC = 0;
  dword_1008ECCB0 = 0;
  if (BYTE8(xmmword_1008F6D58)) {
    BOOL v1 = BYTE9(xmmword_1008F6D58) == 0;
  }
  else {
    BOOL v1 = 1;
  }
  if (v1) {
    char v2 = 4;
  }
  else {
    char v2 = 24;
  }
  byte_1008E8AF9 |= v2;
  sub_1001CB0A4((uint64_t (*)(void, void, void, void, void, void, void, void))sub_1001B9C24);
  sub_1001C87BC((__n128 *)off_100885FD8);
  sub_1001C6918();
  uint64_t result = 0LL;
  dword_1008F7010 = 1;
  off_1008E8A48 = 0LL;
  byte_1008ECCA0 = 0;
  byte_1008ECCA1 = 0;
  byte_1008ECCB4 = 0;
  word_1008ECCB6 = 0;
  byte_1008ECCB8 = 0;
  byte_1008ECCB9 = 0;
  if (!byte_1008ECCBA)
  {
    uint64_t result = 0LL;
    byte_1008E8A40 = 0;
    byte_1008ECCBB = 0;
    dword_1008ECCBC = 0;
    word_1008ECCC0 = 0;
  }

  return result;
}

uint64_t sub_1001BE170(unsigned int a1, unsigned __int16 a2)
{
  if (dword_1008ECCB0) {
    sub_1001BFF04();
  }
  unsigned __int16 v41 = 0;
  uint64_t v4 = sub_1001EEC44(dword_1008ECCAC, &v41);
  if ((_DWORD)v4)
  {
    uint64_t v5 = v4;
    sub_1001EE134( (uint64_t)"Failed to read timeout value for private address refresh timer, status:%! gHoldStableAddress:%d gHoldStab leAddressCount:%d ",  v6,  v7,  v8,  v9,  v10,  v11,  v12,  v5);
    uint64_t v13 = (os_log_s *)sub_100086554(0x42u);
    if (!os_log_type_enabled(v13, OS_LOG_TYPE_ERROR)) {
      goto LABEL_7;
    }
    goto LABEL_6;
  }

  if (v41 >= a1)
  {
    uint64_t v5 = sub_1001EE6E8((uint64_t)sub_1001BE3F8, 0LL, a2, &dword_1008ECCB0);
    if ((_DWORD)v5)
    {
      sub_1001EE134( (uint64_t)"Failed to register resetLeHoldStablePrivateAddress, status:%! gHoldStableAddress:%d gHoldStableAddressCount:%d ",  v24,  v25,  v26,  v27,  v28,  v29,  v30,  v5);
      uint64_t v31 = (os_log_s *)sub_100086554(0x42u);
      if (!os_log_type_enabled(v31, OS_LOG_TYPE_ERROR)) {
        goto LABEL_7;
      }
LABEL_6:
      sub_100657858();
LABEL_7:
      sub_1001BFF04();
      word_1008ECCB6 = 0;
      byte_1008ECCB4 = 0;
      return v5;
    }
  }

  else
  {
    uint64_t v15 = sub_1001EEB7C(dword_1008ECCAC, a2);
    if ((_DWORD)v15)
    {
      uint64_t v5 = v15;
      sub_1001EE134( (uint64_t)"Failed to update private address refresh timer, status:%! gHoldStableAddress:%d gHoldStableAddressCount:%d",  v16,  v17,  v18,  v19,  v20,  v21,  v22,  v5);
      __int16 v23 = (os_log_s *)sub_100086554(0x42u);
      if (!os_log_type_enabled(v23, OS_LOG_TYPE_ERROR)) {
        goto LABEL_7;
      }
      goto LABEL_6;
    }

    ++word_1008ECCB6;
    uint64_t v5 = 116LL;
  }

  byte_1008ECCB4 = 1;
  if (sub_1000A86F0())
  {
    sub_1001EE134( (uint64_t)"EnableHoldStableAddress: gHoldStableAddressCount=%d gLeHoldStablePrivateAddressTimer=%d gLePrivateAddressTimer=%d",  v32,  v33,  v34,  v35,  v36,  v37,  v38,  (unsigned __int16)word_1008ECCB6);
    uint64_t v39 = (os_log_s *)sub_100086554(0x42u);
    if (os_log_type_enabled(v39, OS_LOG_TYPE_DEFAULT))
    {
      uint64_t v40 = sub_1001EDDCC();
      *(_DWORD *)buf = 136446210;
      v43 = v40;
      _os_log_impl((void *)&_mh_execute_header, v39, OS_LOG_TYPE_DEFAULT, " %{public}s", buf, 0xCu);
    }
  }

  return v5;
}

uint64_t sub_1001BE3F8()
{
  if (sub_1000A86F0())
  {
    sub_1001EE134( (uint64_t)"LeHoldStablePrivateAddress expired:%d PrivateAddressTimer active:%s",  v0,  v1,  v2,  v3,  v4,  v5,  v6,  (unsigned __int16)word_1008ECCB6);
    uint64_t v7 = (os_log_s *)sub_100086554(0x42u);
    if (os_log_type_enabled(v7, OS_LOG_TYPE_DEFAULT))
    {
      *(_DWORD *)buf = 136446210;
      uint64_t v10 = sub_1001EDDCC();
      _os_log_impl((void *)&_mh_execute_header, v7, OS_LOG_TYPE_DEFAULT, " %{public}s", buf, 0xCu);
    }
  }

  uint64_t result = sub_1001BFF04();
  byte_1008ECCB4 = 0;
  word_1008ECCB6 = 0;
  return result;
}

uint64_t sub_1001BE4EC(_DWORD *a1)
{
  unsigned __int16 v3 = 0;
  uint64_t result = sub_1001EEC44(dword_1008ECCAC, &v3);
  if (!(_DWORD)result) {
    *a1 = 100 * v3;
  }
  return result;
}

_BYTE *sub_1001BE538(_BYTE *result, _BYTE *a2, _BYTE *a3, _WORD *a4, _DWORD *a5, _DWORD *a6)
{
  *uint64_t result = byte_1008ECCB4;
  *a2 = byte_1008ECCA1;
  *a3 = byte_1008ECCA0;
  *a4 = word_1008ECCB6;
  *a5 = dword_1008ECCAC;
  *a6 = dword_1008ECCB0;
  return result;
}

uint64_t sub_1001BE584(uint64_t result)
{
  word_1008ECCC4 = 10 * result;
  return result;
}

uint64_t sub_1001BE598(uint64_t result)
{
  byte_1008ECCBA = result;
  return result;
}

uint64_t sub_1001BE5A4()
{
  if (!BYTE9(xmmword_1008F6D58)) {
    return 0LL;
  }
  if (!dword_1008F7010) {
    return 103LL;
  }
  sub_1001BCCC4();
  sub_1001BFF04();
  qword_1008E8AF0 = 0LL;
  sub_1001C8874(off_100885FD8);
  sub_100174780();
  sub_10018A448();
  byte_1008E8AF9 = 0;
  byte_1008E8AF8 = 0;
  byte_1008ECC6D = 0;
  byte_1008E8B18 = 0;
  off_1008E8A48 = 0LL;
  *(_OWORD *)&xmmword_1008E8B08 = 0uLL;
  unk_1008E8B00 = 0LL;
  byte_1008E8A40 = 0;
  byte_1008ECCBB = 0;
  byte_1008ECCB8 = 0;
  byte_1008ECCA0 = 0;
  byte_1008ECCA1 = 0;
  byte_1008ECCB4 = 0;
  word_1008ECCB6 = 0;
  byte_1008ECCB9 = 0;
  sub_1001BE780();
  sub_1001BD2B0();
  sub_1001D5D10();
  sub_1000AF3B8();
  sub_1001D539C();
  sub_1001CB440();
  sub_1001C69B0();
  sub_1001AA668();
  sub_1000AF014();
  if (dword_1008ECCC8)
  {
    if (sub_1000A86F0())
    {
      sub_1001EE134((uint64_t)"Canceling power assertion", v0, v1, v2, v3, v4, v5, v6, *(uint64_t *)v9);
      uint64_t v7 = (os_log_s *)sub_100086554(0x42u);
      if (os_log_type_enabled(v7, OS_LOG_TYPE_DEFAULT))
      {
        *(_DWORD *)uint64_t v9 = 136446210;
        *(void *)&v9[4] = sub_1001EDDCC();
        _os_log_impl((void *)&_mh_execute_header, v7, OS_LOG_TYPE_DEFAULT, " %{public}s", v9, 0xCu);
      }
    }

    sub_1001EEB14(dword_1008ECCC8);
    dword_1008ECCC8 = 0;
    qword_1008ECCD0 = 0LL;
    sub_1000B1428();
  }

  uint64_t result = 0LL;
  dword_1008F7010 = 0;
  return result;
}

uint64_t sub_1001BE780()
{
  uint64_t result = sub_10019FB18();
  if ((_DWORD)result)
  {
    return sub_10019E9E0(0LL, 0LL);
  }

  return result;
}

uint64_t sub_1001BE7B4(uint64_t (*a1)(void, void), void *a2)
{
  uint64_t v4 = sub_10019E9E0(a1, a2);
  if ((_DWORD)v4)
  {
    if (sub_1000A86F0())
    {
      sub_1001EE134((uint64_t)"LE_InitPeriodicAdvertising failed with status %!", v5, v6, v7, v8, v9, v10, v11, v4);
      uint64_t v12 = (os_log_s *)sub_100086554(0x42u);
      if (os_log_type_enabled(v12, OS_LOG_TYPE_ERROR)) {
        sub_100657858();
      }
    }
  }

  return v4;
}

uint64_t sub_1001BE844(unsigned __int8 *a1)
{
  if (!dword_1008F7010) {
    return 103LL;
  }
  if ((sub_10019FB18() & 1) != 0)
  {
    unsigned int v2 = *a1;
    if (v2 >= sub_10019DED4())
    {
      if (sub_1000A86F0())
      {
        sub_1001EE134((uint64_t)"Invalid advHandle=%d", v20, v21, v22, v23, v24, v25, v26, *a1);
        uint64_t v27 = (os_log_s *)sub_100086554(0x42u);
        if (os_log_type_enabled(v27, OS_LOG_TYPE_ERROR)) {
          sub_100657858();
        }
      }

      return 101LL;
    }

    else
    {
      uint64_t v3 = sub_10019F138(a1);
      if ((_DWORD)v3)
      {
        if (sub_1000A86F0())
        {
          sub_1001EE134( (uint64_t)"LE_StartPeriodicAdvertising failed with status %! advHandle=%d ",  v4,  v5,  v6,  v7,  v8,  v9,  v10,  v3);
          uint64_t v11 = (os_log_s *)sub_100086554(0x42u);
          if (os_log_type_enabled(v11, OS_LOG_TYPE_ERROR)) {
            sub_100657F74();
          }
        }
      }
    }
  }

  else
  {
    if (sub_1000A86F0())
    {
      sub_1001EE134((uint64_t)"LE GAP Periodic Advertising is not enabled", v12, v13, v14, v15, v16, v17, v18, v29);
      uint64_t v19 = (os_log_s *)sub_100086554(0x42u);
      if (os_log_type_enabled(v19, OS_LOG_TYPE_ERROR)) {
        sub_100657858();
      }
    }

    return 117LL;
  }

  return v3;
}

uint64_t sub_1001BE988(unsigned int a1)
{
  if (!dword_1008F7010) {
    return 103LL;
  }
  if ((sub_10019FB18() & 1) == 0)
  {
    sub_1001EE134((uint64_t)"LE GAP Periodic Advertising is not enabled", v11, v12, v13, v14, v15, v16, v17, v28);
    uint64_t v18 = (os_log_s *)sub_100086554(0x42u);
    if (!os_log_type_enabled(v18, OS_LOG_TYPE_ERROR)) {
      return 117LL;
    }
LABEL_14:
    sub_100657858();
    return 117LL;
  }

  if (!sub_10019ECA0())
  {
    sub_1001EE134( (uint64_t)"LE_GAP_StopPeriodicAdvertising there is no active periodic advertising set.",  v19,  v20,  v21,  v22,  v23,  v24,  v25,  v28);
    uint64_t v26 = (os_log_s *)sub_100086554(0x42u);
    if (!os_log_type_enabled(v26, OS_LOG_TYPE_ERROR)) {
      return 117LL;
    }
    goto LABEL_14;
  }

  uint64_t v2 = sub_10019ED68(a1, 0);
  if ((_DWORD)v2)
  {
    if (sub_1000A86F0())
    {
      sub_1001EE134( (uint64_t)"LE_StopPeriodicAdvertising failed with status %! advHandle=%d ",  v3,  v4,  v5,  v6,  v7,  v8,  v9,  v2);
      uint64_t v10 = (os_log_s *)sub_100086554(0x42u);
      if (os_log_type_enabled(v10, OS_LOG_TYPE_ERROR)) {
        sub_100657F74();
      }
    }
  }

  return v2;
}

void sub_1001BEAB8(uint64_t a1)
{
  if (sub_1000A86F0())
  {
    sub_1001EE134( (uint64_t)"LE_GAP_SetForceConnectionDelay Overriding Encryption and remote version information delay to %d",  v2,  v3,  v4,  v5,  v6,  v7,  v8,  a1);
    uint64_t v9 = (os_log_s *)sub_100086554(0x42u);
    if (os_log_type_enabled(v9, OS_LOG_TYPE_ERROR)) {
      sub_100657858();
    }
  }

  dword_1008ECCA4 = a1;
}

uint64_t sub_1001BEB28(uint64_t result, unsigned int a2)
{
  *((_BYTE *)&dword_1008ECC68 + a2) = result;
  return result;
}

BOOL sub_1001BEB38()
{
  if (dword_1008F7010) {
    BOOL v0 = BYTE9(xmmword_1008F6D58) == 0;
  }
  else {
    BOOL v0 = 1;
  }
  return !v0;
}

uint64_t sub_1001BEB60()
{
  if (sub_1000A86F0())
  {
    if (byte_1008ECCB9) {
      uint64_t v7 = "YES";
    }
    else {
      uint64_t v7 = "NO";
    }
    sub_1001EE134((uint64_t)"Address rotation in progress:%s", v0, v1, v2, v3, v4, v5, v6, (uint64_t)v7);
    uint64_t v8 = (os_log_s *)sub_100086554(0x42u);
    if (os_log_type_enabled(v8, OS_LOG_TYPE_DEFAULT))
    {
      *(_DWORD *)buf = 136446210;
      uint64_t v11 = sub_1001EDDCC();
      _os_log_impl((void *)&_mh_execute_header, v8, OS_LOG_TYPE_DEFAULT, " %{public}s", buf, 0xCu);
    }
  }

  return byte_1008ECCB9;
}

void sub_1001BEC40(int a1)
{
  if (a1)
  {
    dword_1008F7010 = 0;
    uint64_t v1 = sub_1001BD2B0();
    sub_1001D5AEC(v1, v2, v3, v4, v5, v6, v7, v8);
    sub_1001C69B0();
    sub_1001AA580();
  }

  else
  {
    dword_1008F7010 = 1;
  }

BOOL sub_1001BEC7C(unsigned __int8 *a1, unsigned __int8 *a2)
{
  if (a1 == a2) {
    return 1LL;
  }
  size_t v2 = *a1;
  int v3 = *a2;
  if ((_DWORD)v2 == v3)
  {
    return memcmp(a1 + 4, a2 + 4, v2) == 0;
  }

  else
  {
    *(_DWORD *)uint64_t v8 = 0;
    *(_DWORD *)uint64_t v7 = 0;
    if ((_DWORD)v2 == 4)
    {
      v8[0] = 16;
      *(_OWORD *)&v8[4] = xmmword_1006BD88A;
      *(_DWORD *)&v8[4] = bswap32(*((_DWORD *)a1 + 1));
    }

    else if ((_DWORD)v2 == 2)
    {
      v8[0] = 16;
      *(_OWORD *)&v8[4] = xmmword_1006BD88A;
      *(_WORD *)&v8[6] = bswap32(*((unsigned __int16 *)a1 + 2)) >> 16;
    }

    else
    {
      *(_OWORD *)uint64_t v8 = *(_OWORD *)a1;
      *(_DWORD *)&v8[16] = *((_DWORD *)a1 + 4);
    }

    if (v3 == 4)
    {
      v7[0] = 16;
      *(_OWORD *)&v7[4] = xmmword_1006BD88A;
      *(_DWORD *)&v7[4] = bswap32(*((_DWORD *)a2 + 1));
    }

    else if (v3 == 2)
    {
      v7[0] = 16;
      *(_OWORD *)&v7[4] = xmmword_1006BD88A;
      *(_WORD *)&v7[6] = bswap32(*((unsigned __int16 *)a2 + 2)) >> 16;
    }

    else
    {
      *(_OWORD *)uint64_t v7 = *(_OWORD *)a2;
      *(_DWORD *)&v7[16] = *((_DWORD *)a2 + 4);
    }

    return *(void *)v8 == *(void *)v7
        && *(void *)&v8[8] == *(void *)&v7[8]
        && *(unsigned int *)&v8[16] == (unint64_t)*(unsigned int *)&v7[16];
  }

unint64_t sub_1001BEE0C(unint64_t a1)
{
  return bswap64(a1) >> 16;
}

void sub_1001BEE18(int8x16_t *a1@<X0>, uint64_t a2@<X1>, int a3@<W2>, uint64_t a4@<X8>)
{
  *(void *)a4 = 0LL;
  *(void *)(a4 + 8) = 0LL;
  *(_DWORD *)(a4 + 16) = 0;
  *(_BYTE *)a4 = a2;
  switch((_DWORD)a2)
  {
    case 0x10:
      if (a3 == 1)
      {
        int8x16_t v7 = vrev64q_s8(*a1);
        int8x16_t v8 = vextq_s8(v7, v7, 8uLL);
      }

      else
      {
        int8x16_t v8 = *a1;
      }

      *(int8x16_t *)(a4 + 4) = v8;
      break;
    case 4:
      if (a3 == 1) {
        unsigned int v9 = a1->i32[0];
      }
      else {
        unsigned int v9 = bswap32(a1->i32[0]);
      }
      *(_DWORD *)(a4 + 4) = v9;
      break;
    case 2:
      if (a3 == 1) {
        LOWORD(v6) = a1->i16[0];
      }
      else {
        unsigned int v6 = bswap32(a1->u16[0]) >> 16;
      }
      *(_WORD *)(a4 + 4) = v6;
      break;
    default:
      if (sub_1000A86F0())
      {
        sub_1001EE134( (uint64_t)"Invalid UUID length of %d when converting to LE_UUID",  v10,  v11,  v12,  v13,  v14,  v15,  v16,  a2);
        uint64_t v17 = (os_log_s *)sub_100086554(0x42u);
        if (os_log_type_enabled(v17, OS_LOG_TYPE_ERROR)) {
          sub_100657858();
        }
      }

      *(_BYTE *)a4 = 16;
      break;
  }

void sub_1001BEF1C(_BYTE *a1, unsigned __int8 *a2, int a3)
{
  int v4 = *a2;
  switch(v4)
  {
    case 16:
      if (a3 == 1)
      {
        *a1 = a2[19];
        a1[1] = a2[18];
        a1[2] = a2[17];
        a1[3] = a2[16];
        a1[4] = a2[15];
        a1[5] = a2[14];
        a1[6] = a2[13];
        a1[7] = a2[12];
        a1[8] = a2[11];
        a1[9] = a2[10];
        a1[10] = a2[9];
        a1[11] = a2[8];
        a1[12] = a2[7];
        a1[13] = a2[6];
        a1[14] = a2[5];
        a1[15] = a2[4];
      }

      else
      {
        *(_OWORD *)a1 = *(_OWORD *)(a2 + 4);
      }

      break;
    case 4:
      int v7 = *((_DWORD *)a2 + 1);
      if (a3 == 1)
      {
        *a1 = v7;
        a1[1] = BYTE1(*((_DWORD *)a2 + 1));
        a1[2] = *((_WORD *)a2 + 3);
        a1[3] = a2[7];
      }

      else
      {
        a1[3] = v7;
        a1[2] = BYTE1(*((_DWORD *)a2 + 1));
        a1[1] = *((_WORD *)a2 + 3);
        *a1 = a2[7];
      }

      break;
    case 2:
      __int16 v5 = *((_WORD *)a2 + 2);
      if (a3 == 1)
      {
        *a1 = v5;
        unsigned __int8 v6 = a2[5];
      }

      else
      {
        *a1 = HIBYTE(v5);
        unsigned __int8 v6 = a2[4];
      }

      a1[1] = v6;
      break;
    default:
      if (sub_1000A86F0())
      {
        sub_1001EE134((uint64_t)"Invalid UUID length of %d when copying to array", v8, v9, v10, v11, v12, v13, v14, *a2);
        uint64_t v15 = (os_log_s *)sub_100086554(0x42u);
        if (os_log_type_enabled(v15, OS_LOG_TYPE_ERROR)) {
          sub_100657858();
        }
      }

      break;
  }

uint64_t sub_1001BF0C0(uint64_t result)
{
  byte_1008ECCD8 = result;
  return result;
}

uint64_t sub_1001BF0CC(unint64_t a1, char a2, char a3, char a4)
{
  if ((a1 & 0xFFFFFFFFFFFFLL) != 0)
  {
    if (byte_1008ECCD8)
    {
      uint64_t v4 = 0LL;
      unsigned __int8 v5 = byte_1008ECCD8 + 1;
      unsigned __int8 v6 = qword_1008ECCE0;
      unsigned __int8 v7 = byte_1008ECCD8 + 1;
      do
      {
        uint64_t v9 = *v6;
        v6 += 2;
        uint64_t v8 = v9;
        if (v8 == a1) {
          unsigned __int8 v5 = v4;
        }
        ++v4;
      }

      while (byte_1008ECCD8 != v4);
      if ((a3 & 1) != 0) {
        goto LABEL_14;
      }
    }

    else
    {
      unsigned __int8 v7 = 1;
      unsigned __int8 v5 = 1;
      if ((a3 & 1) != 0)
      {
LABEL_14:
        if (byte_1008ECCD8 <= v7)
        {
          uint64_t v21 = 106LL;
          goto LABEL_29;
        }

        if (byte_1008ECCD8 <= v5)
        {
          uint64_t v11 = &qword_1008ECCE0[2 * v7];
          *uint64_t v11 = a1;
          *((_BYTE *)v11 + 8) = a2;
          *((_BYTE *)v11 + 9) = a4;
          char v12 = byte_1008ECCD9 + 1;
LABEL_25:
          uint64_t v21 = 0LL;
          byte_1008ECCD9 = v12;
          goto LABEL_29;
        }

        goto LABEL_28;
      }
    }

    if (byte_1008ECCD8 <= v5)
    {
      uint64_t v21 = 101LL;
      goto LABEL_29;
    }

    uint64_t v22 = &qword_1008ECCE0[2 * v5];
    *uint64_t v22 = 0LL;
    *((_WORD *)v22 + 4) = 0;
    if (byte_1008ECCD9)
    {
      char v12 = byte_1008ECCD9 - 1;
      goto LABEL_25;
    }

void sub_1001BF340(uint64_t a1, unsigned __int16 **a2)
{
  if (sub_1000A86F0())
  {
    sub_1001EE134( (uint64_t)"FastLEConnection:LE_GAP_FastLEConnectionReady status:%d role:%d address:%d localResolvableAddr:%d, peerRe solvableAddr:%d interval:%d latency:%d timeout:%d centralClockAccuracy:%d LMPVersion:%d mfgr:%d LMPSubver sion:%d featuresLength:%d txPHY:%d rxPHY:%d maxTxOctets:%d maxTxTime:%d maxRxOctets:%d maxRxTime:%d instantValue:%d",  *((unsigned __int8 *)a2 + 62),  *((unsigned __int16 *)a2 + 32),  *((unsigned __int16 *)a2 + 33),  *((unsigned __int16 *)a2 + 34),  *((unsigned __int16 *)a2 + 35),  *((unsigned __int16 *)a2 + 36),  v4,  a1);
    unsigned __int8 v5 = (os_log_s *)sub_100086554(0x42u);
    if (os_log_type_enabled(v5, OS_LOG_TYPE_DEFAULT))
    {
      *(_DWORD *)buf = 136446210;
      uint64_t v53 = sub_1001EDDCC();
      _os_log_impl((void *)&_mh_execute_header, v5, OS_LOG_TYPE_DEFAULT, " %{public}s", buf, 0xCu);
    }
  }

  if ((_DWORD)a1)
  {
    if (sub_1000A86F0())
    {
      sub_1001EE134( (uint64_t)"FastLEConnection:LE_GAP_FastLEConnectionReady Fast LE Connection not succesful status:%d fastLEConnectEnabled:%d",  v6,  v7,  v8,  v9,  v10,  v11,  v12,  a1);
      uint64_t v13 = (os_log_s *)sub_100086554(0x42u);
      if (os_log_type_enabled(v13, OS_LOG_TYPE_DEFAULT))
      {
        uint64_t v14 = sub_1001EDDCC();
        *(_DWORD *)buf = 136446210;
        uint64_t v53 = v14;
        _os_log_impl((void *)&_mh_execute_header, v13, OS_LOG_TYPE_DEFAULT, " %{public}s", buf, 0xCu);
      }
    }

    if (*((_BYTE *)*a2 + 316))
    {
      *((_BYTE *)*a2 + 316) = 0;
      uint64_t v15 = (uint64_t)*a2;
      if (*((_BYTE *)*a2 + 70))
      {
        uint64_t v16 = sub_1001B7A10(v15);
        if ((_DWORD)v16)
        {
          uint64_t v17 = v16;
          if (sub_1000A86F0())
          {
            sub_1001EE134( (uint64_t)"FastLEConnection:LE_GAP_ReadRemoteVersionInformation failed %!",  v18,  v19,  v20,  v21,  v22,  v23,  v24,  v17);
            uint64_t v25 = (os_log_s *)sub_100086554(0x42u);
            if (os_log_type_enabled(v25, OS_LOG_TYPE_ERROR)) {
              sub_100657F74();
            }
          }

          sub_1001B7AA0((uint64_t)*a2, v17);
        }

        else
        {
          *((_DWORD *)*a2 + 33) = 1;
        }
      }

      else if (sub_1001B8CE4(v15))
      {
        if (sub_1000A86F0())
        {
          sub_1001EE134( (uint64_t)"FastLEConnection:Encryption start fails with status %!",  v36,  v37,  v38,  v39,  v40,  v41,  v42,  a1);
          v43 = (os_log_s *)sub_100086554(0x42u);
          if (os_log_type_enabled(v43, OS_LOG_TYPE_ERROR)) {
            sub_100657F74();
          }
        }
      }

      else
      {
        *((_BYTE *)*a2 + 125) = 1;
      }
    }
  }

  else
  {
    if (*((_BYTE *)*a2 + 316) || (sub_1001EE2A0(), *((_BYTE *)*a2 + 316)))
    {
      if (sub_1000A86F0())
      {
        sub_1001EE134( (uint64_t)"FastLEConnection:LE_GAP_FastLEConnectionReady Setting up connection fastLEConnectEncryptionPending:%d fastLEConnectionFakeEncryptEvent:%d",  v26,  v27,  v28,  v29,  v30,  v31,  v32,  *((unsigned __int8 *)*a2 + 317));
        uint64_t v33 = (os_log_s *)sub_100086554(0x42u);
        if (os_log_type_enabled(v33, OS_LOG_TYPE_DEFAULT))
        {
          uint64_t v34 = sub_1001EDDCC();
          *(_DWORD *)buf = 136446210;
          uint64_t v53 = v34;
          _os_log_impl((void *)&_mh_execute_header, v33, OS_LOG_TYPE_DEFAULT, " %{public}s", buf, 0xCu);
        }
      }

      (*a2)[40] = *((_WORD *)a2 + 20);
      (*a2)[41] = *((_WORD *)a2 + 21);
      (*a2)[42] = *((_WORD *)a2 + 22);
      *((_BYTE *)*a2 + 118) = *((_BYTE *)a2 + 46);
      *((_BYTE *)*a2 + 125) = *((_BYTE *)*a2 + 317);
      uint64_t v35 = (uint64_t)*a2;
      if (*((_BYTE *)*a2 + 125))
      {
        *(_BYTE *)(v35 + 167) = 16;
        *((_BYTE *)*a2 + 169) = 1;
        uint64_t v35 = (uint64_t)*a2;
        if (*((_BYTE *)*a2 + 318))
        {
          sub_1001C73C4(0LL, v35, 1LL);
          uint64_t v35 = (uint64_t)*a2;
        }
      }

      *(_DWORD *)(v35 + 132) = 1;
      *((_BYTE *)*a2 + 126) = 1;
      sub_1001AF6C0(0LL, (uint64_t)*a2, *((unsigned __int8 *)a2 + 47), *((_WORD *)a2 + 24), *((_WORD *)a2 + 25));
      *((_DWORD *)*a2 + 33) = 2;
      sub_1001AEA1C(0LL, **a2, (unsigned __int16 **)((char *)a2 + 52));
      *((_DWORD *)*a2 + 33) = 3;
      *((_DWORD *)*a2 + 34) = 0;
      sub_1001AEE34( **a2,  *((unsigned __int16 *)a2 + 32),  *((unsigned __int16 *)a2 + 33),  *((unsigned __int16 *)a2 + 34),  *((unsigned __int16 *)a2 + 35));
      *((_DWORD *)*a2 + 33) = 4;
      sub_1001AF218(0LL, (uint64_t)*a2, *((unsigned __int8 *)a2 + 61), *((unsigned __int8 *)a2 + 62));
    }

    else
    {
      if (sub_1000A86F0())
      {
        sub_1001EE134( (uint64_t)"FastLEConnection:LE_GAP_FastLEConnectionReady for invalid address %llu",  v44,  v45,  v46,  v47,  v48,  v49,  v50,  (uint64_t)a2[2]);
        uint64_t v51 = (os_log_s *)sub_100086554(0x42u);
        if (os_log_type_enabled(v51, OS_LOG_TYPE_ERROR)) {
          sub_100657858();
        }
      }

      sub_1001EE2A0();
    }
  }

void sub_1001BF7E8(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5)
{
  if (sub_1000A86F0())
  {
    sub_1001EE134( (uint64_t)"AutoReconnect: state:%d scan:%d / %d ms numOfAddr:%d",  v10,  v11,  v12,  v13,  v14,  v15,  v16,  a1);
    uint64_t v17 = (os_log_s *)sub_100086554(0x42u);
    if (os_log_type_enabled(v17, OS_LOG_TYPE_DEFAULT))
    {
      *(_DWORD *)buf = 136446210;
      uint64_t v19 = sub_1001EDDCC();
      _os_log_impl((void *)&_mh_execute_header, v17, OS_LOG_TYPE_DEFAULT, " %{public}s", buf, 0xCu);
    }
  }

  if (off_1008E8AE8) {
    off_1008E8AE8(a1, a2, a3, a4, a5);
  }
}

uint64_t sub_1001BF900(uint64_t a1)
{
  return sub_1001C8D80(**(void **)(a1 + 8));
}

uint64_t sub_1001BF90C(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, unsigned __int8 *a5)
{
  if (a2 % a3)
  {
    if (sub_1000A86F0())
    {
      sub_1001EE134((uint64_t)"Invalid UUID list length: (%u %% %u) != 0", v7, v8, v9, v10, v11, v12, v13, a2);
      uint64_t v14 = (os_log_s *)sub_100086554(0x42u);
      if (os_log_type_enabled(v14, OS_LOG_TYPE_ERROR)) {
        sub_100657858();
      }
    }

    return 4056LL;
  }

  if ((_DWORD)a2)
  {
    unsigned int v19 = 0;
    unsigned __int8 v20 = *a5;
    while (v20 < 0x7Du)
    {
      uint64_t v21 = a4 + 20LL * v20;
      sub_1001BEE18((int8x16_t *)(a1 + v19), a3, 1, (uint64_t)&v30);
      *(_OWORD *)uint64_t v21 = v30;
      *(_DWORD *)(v21 + 16) = v31;
      unsigned __int8 v20 = *a5 + 1;
      *a5 = v20;
      unsigned int v19 = (v19 + a3);
    }

    if (sub_1000A86F0())
    {
      sub_1001EE134((uint64_t)"Invalid index %u for UUIDs in parseADUuids", v22, v23, v24, v25, v26, v27, v28, *a5);
      uint64_t v29 = (os_log_s *)sub_100086554(0x42u);
      if (os_log_type_enabled(v29, OS_LOG_TYPE_ERROR)) {
        sub_100657858();
      }
    }

    return 4056LL;
  }

  return 0LL;
}

uint64_t sub_1001BFA8C(int8x16_t *a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  int v4 = a3;
  unsigned __int8 v5 = a2 - a3;
  if (a2 < a3)
  {
    sub_1001EE134((uint64_t)"Invalid service data length: %d < %d (UUID size=%d)", v7, v8, v9, v10, v11, v12, v13, a2);
    uint64_t v14 = (os_log_s *)sub_100086554(0x42u);
    if (!os_log_type_enabled(v14, OS_LOG_TYPE_ERROR)) {
      return 4057LL;
    }
    goto LABEL_12;
  }

  if (!a4)
  {
    sub_1001EE134((uint64_t)"Invalid parsedData for parseADServiceData", v25, v26, v27, v28, v29, v30, v31, v45);
    uint64_t v32 = (os_log_s *)sub_100086554(0x42u);
    if (!os_log_type_enabled(v32, OS_LOG_TYPE_ERROR)) {
      return 4057LL;
    }
LABEL_12:
    sub_100657858();
    return 4057LL;
  }

  uint64_t v16 = (char *)(a4 + 5632);
  if (*(unsigned __int8 *)(a4 + 5632) >= 0xAuLL)
  {
    sub_1001EE134( (uint64_t)"Invalid parsedData nbServiceData %u for parseADServiceData",  v17,  v18,  v19,  v20,  v21,  v22,  v23,  *v16);
    uint64_t v24 = (os_log_s *)sub_100086554(0x42u);
    if (!os_log_type_enabled(v24, OS_LOG_TYPE_ERROR)) {
      return 4057LL;
    }
    goto LABEL_12;
  }

  uint64_t v34 = a4 + 56LL * *(unsigned __int8 *)(a4 + 5632);
  sub_1001BEE18(a1, a3, 1, (uint64_t)&v46);
  *(_OWORD *)(v34 + 5072) = v46;
  *(_DWORD *)(v34 + 5088) = v47;
  if (v5 >= 0x20u)
  {
    if (sub_1000A86F0())
    {
      sub_1001EE134( (uint64_t)"Invalid size %d for serviceData in parseADServiceData",  v35,  v36,  v37,  v38,  v39,  v40,  v41,  v5);
      uint64_t v42 = (os_log_s *)sub_100086554(0x42u);
      if (os_log_type_enabled(v42, OS_LOG_TYPE_ERROR)) {
        sub_100657858();
      }
    }

    return 4057LL;
  }

  memmove((void *)(a4 + 5072 + 56LL * *v16 + 20), &a1->i8[v4], v5);
  uint64_t result = 0LL;
  char v44 = *v16;
  *(_WORD *)(a4 + 5072 + 56LL * *v16 + 52) = v5;
  *uint64_t v16 = v44 + 1;
  return result;
}

void sub_1001BFCA8()
{
  dword_1008ECCC8 = 0;
  uint64_t v0 = sub_1000B05D8();
  if (v0 - qword_1008ECCD0 < 0x3E8) {
    sub_1001EE6E8( (uint64_t)sub_1001BFCA8,  0LL,  (unsigned __int16)(1099 - (v0 - qword_1008ECCD0)) / 0x64u,  &dword_1008ECCC8);
  }
  else {
    sub_1000B1428();
  }
}

void sub_1001BFD0C()
{
  byte_1008ECCB9 = 0;
  sub_1001B9F20();
}

void sub_1001BFD2C()
{
  byte_1008ECCB9 = 0;
  sub_1001B9F20();
}

void sub_1001BFD4C()
{
  LOWORD(v0) = word_1008ECCC4;
  if (!word_1008ECCC4)
  {
    uint32_t v1 = arc4random();
    unsigned int v0 = v1 - 6000 * ((unsigned __int16)v1 / 0x1770u) + 6000;
  }

  if (sub_1000A86F0())
  {
    sub_1001EE134( (uint64_t)"Registering PrivateAddressTimer gPrivateMode=%d gOverrideLocalAddress=%d gLePrivateAddressTimer=%d gLeCur rentAddress=%d gAutoAddressRefresh=%d gPrivateAddressRotateInterval=%d gPrivateAddressRotateIntervalOverr ide=%d nextRandomAddressChange=%d seconds gHoldStableAddress=%d",  v2,  v3,  v4,  v5,  v6,  v7,  v8,  byte_1008ECCA0);
    uint64_t v9 = (os_log_s *)sub_100086554(0x42u);
    if (os_log_type_enabled(v9, OS_LOG_TYPE_DEFAULT))
    {
      *(_DWORD *)buf = 136446210;
      uint64_t v21 = sub_1001EDDCC();
      _os_log_impl((void *)&_mh_execute_header, v9, OS_LOG_TYPE_DEFAULT, " %{public}s", buf, 0xCu);
    }
  }

  if (byte_1008D8EAC)
  {
    uint64_t v10 = sub_1001EE6E8((uint64_t)sub_1001B835C, 0LL, (unsigned __int16)v0, &dword_1008ECCAC);
    if ((_DWORD)v10)
    {
      uint64_t v11 = v10;
      if (sub_1000A86F0())
      {
        sub_1001EE134( (uint64_t)"Failed to register a private address refresh timer, status:%!",  v12,  v13,  v14,  v15,  v16,  v17,  v18,  v11);
        uint64_t v19 = (os_log_s *)sub_100086554(0x42u);
        if (os_log_type_enabled(v19, OS_LOG_TYPE_ERROR)) {
          sub_100657858();
        }
      }
    }
  }

uint64_t sub_1001BFF04()
{
  if (sub_1000A86F0())
  {
    sub_1001EE134( (uint64_t)"Canceling LeHoldStablePrivateAddressTimer [%d]",  v0,  v1,  v2,  v3,  v4,  v5,  v6,  (unsigned __int16)word_1008ECCB6);
    uint64_t v7 = (os_log_s *)sub_100086554(0x42u);
    if (os_log_type_enabled(v7, OS_LOG_TYPE_DEFAULT))
    {
      *(_DWORD *)buf = 136446210;
      uint64_t v10 = sub_1001EDDCC();
      _os_log_impl((void *)&_mh_execute_header, v7, OS_LOG_TYPE_DEFAULT, " %{public}s", buf, 0xCu);
    }
  }

  uint64_t result = dword_1008ECCB0;
  if (dword_1008ECCB0)
  {
    uint64_t result = sub_1001EEB14(dword_1008ECCB0);
    dword_1008ECCB0 = 0;
  }

  return result;
}

void *sub_1001BFFDC()
{
  uint64_t result = (void *)qword_1008ECEE0;
  if (qword_1008ECEE0)
  {
    do
    {
      uint64_t v1 = (void *)result[12];
      sub_1000B1838(result);
      uint64_t result = v1;
    }

    while (v1);
  }

  qword_1008ECEE0 = 0LL;
  return result;
}

uint64_t sub_1001C001C()
{
  uint64_t v0 = sub_1001A194C();
  if ((_DWORD)v0)
  {
    if (sub_1000A86F0())
    {
      sub_1001EE134((uint64_t)"ATT initialization failed with status %!", v1, v2, v3, v4, v5, v6, v7, v0);
      uint64_t v8 = (os_log_s *)sub_100086554(0x45u);
      if (os_log_type_enabled(v8, OS_LOG_TYPE_ERROR)) {
        sub_100657F74();
      }
    }
  }

  else
  {
    sub_1001A48D8((uint64_t)off_100885FF0);
  }

  return v0;
}

uint64_t sub_1001C009C(uint64_t a1)
{
  uint64_t v1 = sub_1001A23CC(a1);
  uint64_t v2 = qword_1008ECEE0;
  if (qword_1008ECEE0)
  {
    while (*(void **)v2 != v1)
    {
      uint64_t v2 = *(void *)(v2 + 96);
      if (!v2) {
        goto LABEL_4;
      }
    }

    return *(unsigned __int16 *)(v2 + 8);
  }

  else
  {
LABEL_4:
    uint64_t result = sub_1000A86F0();
    if ((_DWORD)result)
    {
      sub_1001EE134((uint64_t)"Could not find GATT session with HCI handle", v4, v5, v6, v7, v8, v9, v10, v12);
      uint64_t v11 = (os_log_s *)sub_100086554(0x45u);
      uint64_t result = os_log_type_enabled(v11, OS_LOG_TYPE_ERROR);
      if ((_DWORD)result)
      {
        sub_100657858();
        return 0LL;
      }
    }
  }

  return result;
}

uint64_t sub_1001C0120(uint64_t a1, uint64_t a2)
{
  uint64_t v3 = sub_1001C01F4(a1);
  if (v3)
  {
    LOWORD(v4) = *((_WORD *)v3 + 4);
  }

  else
  {
    uint64_t v5 = sub_1000B17F4(0x70uLL);
    if (v5)
    {
      *(void *)uint64_t v5 = a2;
      __int16 v6 = word_1008ECEE8;
      int v4 = (unsigned __int16)word_1008ECEE8++ + 1;
      v5[4] = v4;
      if ((v4 & 0x10000) != 0)
      {
        word_1008ECEE8 = v6 + 2;
        v5[4] = v6 + 2;
        LOWORD(v4) = 1;
      }

      *((void *)v5 + 10) = 0LL;
      v5[44] = 0;
      *((void *)v5 + 2) = 0LL;
      *((void *)v5 + 3) = 0LL;
      uint64_t v7 = qword_1008ECEE0;
      *((void *)v5 + 12) = qword_1008ECEE0;
      *((void *)v5 + 13) = 0LL;
      if (v7) {
        *(void *)(v7 + 104) = v5;
      }
      qword_1008ECEE0 = (uint64_t)v5;
    }

    else
    {
      if (sub_1000A86F0())
      {
        sub_1001EE134((uint64_t)"Failed to allocate a session.", v8, v9, v10, v11, v12, v13, v14, v17);
        uint64_t v15 = (os_log_s *)sub_100086554(0x45u);
        if (os_log_type_enabled(v15, OS_LOG_TYPE_ERROR)) {
          sub_100657858();
        }
      }

      LOWORD(v4) = 0;
    }
  }

  return (unsigned __int16)v4;
}

void *sub_1001C01F4(uint64_t a1)
{
  uint64_t v1 = sub_1001A23CC(a1);
  uint64_t v2 = 0LL;
  if (v1)
  {
    uint64_t v3 = (void *)qword_1008ECEE0;
    if (qword_1008ECEE0)
    {
      while ((void *)*v3 != v1)
      {
        uint64_t v3 = (void *)v3[12];
        if (!v3) {
          return 0LL;
        }
      }

      return v3;
    }
  }

  return (void *)v2;
}

uint64_t sub_1001C0240(unsigned int a1, _WORD *a2)
{
  uint64_t v3 = (uint64_t *)sub_1001C028C(a1);
  if (!v3) {
    return 101LL;
  }
  int v4 = sub_1001A2494(*v3);
  if (!v4) {
    return 4100LL;
  }
  __int16 v5 = v4;
  uint64_t result = 0LL;
  *a2 = v5;
  return result;
}

uint64_t sub_1001C028C(unsigned int a1)
{
  uint64_t result = qword_1008ECEE0;
  if (qword_1008ECEE0)
  {
    while (*(unsigned __int16 *)(result + 8) != a1)
    {
      uint64_t result = *(void *)(result + 96);
      if (!result) {
        goto LABEL_4;
      }
    }
  }

  else
  {
LABEL_4:
    if (sub_1000A86F0())
    {
      sub_1001EE134((uint64_t)"Could not find session with handle %x", v3, v4, v5, v6, v7, v8, v9, a1);
      uint64_t v10 = (os_log_s *)sub_100086554(0x45u);
      if (os_log_type_enabled(v10, OS_LOG_TYPE_ERROR)) {
        sub_100657858();
      }
    }

    return 0LL;
  }

  return result;
}

uint64_t sub_1001C031C(uint64_t a1, __int16 a2)
{
  uint64_t v3 = sub_1001C01F4(a1);
  if (!v3) {
    return 101LL;
  }
  sub_1001A24CC(*v3, a2);
  return 0LL;
}

uint64_t sub_1001C0358(unsigned int a1, uint64_t a2, unsigned int a3, uint64_t a4)
{
  uint64_t v7 = (uint64_t *)sub_1001C028C(a1);
  uint64_t result = 101LL;
  if (v7 && a2)
  {
    if (v7[2])
    {
      return 118LL;
    }

    else
    {
      uint64_t result = sub_1001A27F8(*v7, (uint64_t)sub_1001C03C8, a3, (uint64_t)v7);
      if (!(_DWORD)result)
      {
        v7[2] = a2;
        v7[3] = a4;
      }
    }
  }

  return result;
}

uint64_t sub_1001C03C8(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  if (!(_DWORD)a2) {
    sub_1001A24CC(a1, a3);
  }
  uint64_t v8 = *(uint64_t (**)(uint64_t, uint64_t, uint64_t))(a4 + 16);
  uint64_t v7 = *(void *)(a4 + 24);
  *(void *)(a4 + 16) = 0LL;
  return v8(a2, a3, v7);
}

uint64_t sub_1001C0410(unsigned int a1, uint64_t a2, uint64_t a3)
{
  uint64_t v5 = (uint64_t *)sub_1001C028C(a1);
  *(_OWORD *)uint64_t v7 = xmmword_1006BDCEC;
  *(_OWORD *)((char *)&v7[2] + 1) = *(__int128 *)((char *)&xmmword_1006BDCEC + 9);
  uint64_t result = 101LL;
  if (v5 && a2)
  {
    if (v5[2])
    {
      return 118LL;
    }

    else
    {
      uint64_t result = sub_1001A2D24(*v5, (uint64_t)sub_1001C04DC, v7, (uint64_t)v5);
      if (!(_DWORD)result)
      {
        v5[2] = a2;
        v5[3] = a3;
        v5[4] = 0LL;
        v5[5] = 0LL;
        v5[6] = 0xFFFF000100000000LL;
        v5[7] = 0LL;
        v5[8] = 0LL;
        v5[9] = 0LL;
      }
    }
  }

  return result;
}

void sub_1001C04DC(uint64_t a1, uint64_t a2, uint64_t a3, unsigned int a4, int a5, uint64_t a6)
{
  if ((_DWORD)a2 != 10)
  {
    uint64_t v7 = a2;
    if ((_DWORD)a2)
    {
      if (sub_1000A86F0())
      {
        sub_1001EE134( (uint64_t)"Received error response for services discovery: %d",  v24,  v25,  v26,  v27,  v28,  v29,  v30,  v7);
        uint64_t v31 = (os_log_s *)sub_100086554(0x45u);
        if (os_log_type_enabled(v31, OS_LOG_TYPE_ERROR)) {
          sub_100657858();
        }
      }

      goto LABEL_26;
    }

    unsigned int v37 = *(unsigned __int16 *)(a6 + 54);
    uint64_t v11 = (char *)sub_1000B17F4(24 * (*(unsigned __int16 *)(a6 + 88) + (unint64_t)a4));
    __dst = v11;
    int v12 = 0;
    if (a4)
    {
      uint64_t v13 = (int8x16_t **)(a3 + 8);
      uint64_t v14 = v11;
      uint64_t v15 = a4;
      while (1)
      {
        int v16 = *(unsigned __int16 *)(a6 + 88);
        uint64_t v17 = &v14[24 * *(unsigned __int16 *)(a6 + 88)];
        *(_DWORD *)uint64_t v17 = *((_DWORD *)v13 - 2);
        if (a5 == 20) {
          break;
        }
        if (a5 == 6)
        {
          uint64_t v18 = &v14[24 * v16];
          uint64_t v19 = *v13;
          uint64_t v20 = 2LL;
LABEL_9:
          sub_1001BEE18(v19, v20, 1, (uint64_t)v38);
          __int128 v21 = *(_OWORD *)v38;
          *((_DWORD *)v18 + 5) = *(_DWORD *)&v38[16];
          *(_OWORD *)(v18 + 4) = v21;
        }

        else {
          int v12 = *((unsigned __int16 *)v17 + 1);
        }
        v13 += 2;
        v14 += 24;
        if (!--v15) {
          goto LABEL_14;
        }
      }

      uint64_t v18 = &v14[24 * v16];
      uint64_t v19 = *v13;
      uint64_t v20 = 16LL;
      goto LABEL_9;
    }

double sub_1001C0730(unsigned int a1, uint64_t a2, unsigned __int8 *a3, uint64_t a4)
{
  uint64_t v7 = sub_1001C028C(a1);
  __int128 v12 = *(_OWORD *)a3;
  int v13 = *((_DWORD *)a3 + 4);
  __chkstk_darwin(v7, *a3);
  uint64_t v9 = (char *)&v12 - v8;
  bzero((char *)&v12 - v8, v10);
  if (v7 && a2 && !*(void *)(v7 + 16))
  {
    sub_1001BEF1C(v9, a3, 1);
    if (!sub_1001A2BF4(*(void *)v7, (uint64_t)sub_1001C0860, 10240, 1, 0xFFFFu, v9, *a3, v7))
    {
      *(void *)(v7 + 16) = a2;
      *(void *)(v7 + 24) = a4;
      double result = *(double *)&v12;
      *(_OWORD *)(v7 + 32) = v12;
      *(_DWORD *)(v7 + 48) = v13;
      *(_DWORD *)(v7 + 52) = -65535;
      *(void *)(v7 + 64) = 0LL;
      *(void *)(v7 + 72) = 0LL;
      *(void *)(v7 + 56) = 0LL;
    }
  }

  return result;
}

void sub_1001C0860(uint64_t a1, uint64_t a2, uint64_t a3, unsigned int a4, uint64_t a5)
{
  if ((_DWORD)a2 != 10)
  {
    uint64_t v6 = a2;
    if ((_DWORD)a2)
    {
      if (sub_1000A86F0())
      {
        sub_1001EE134( (uint64_t)"Received error response for services matching UUID discovery: %d",  v24,  v25,  v26,  v27,  v28,  v29,  v30,  v6);
        uint64_t v31 = (os_log_s *)sub_100086554(0x45u);
        if (os_log_type_enabled(v31, OS_LOG_TYPE_ERROR)) {
          sub_100657858();
        }
      }

      goto LABEL_21;
    }

    __int128 v9 = *(_OWORD *)(a5 + 48);
    __int128 v37 = *(_OWORD *)(a5 + 32);
    __int128 v38 = v9;
    __int128 v39 = *(_OWORD *)(a5 + 64);
    __int128 v35 = v37;
    int v36 = *(_DWORD *)(a5 + 48);
    size_t v10 = (char *)sub_1000B17F4(24 * (*(unsigned __int16 *)(a5 + 88) + (unint64_t)a4));
    uint64_t v11 = v10;
    unsigned int v12 = 0;
    if (a4)
    {
      int v13 = (unsigned __int16 *)(a3 + 2);
      uint64_t v14 = v10;
      uint64_t v15 = a4;
      do
      {
        int v16 = &v14[24 * *(unsigned __int16 *)(a5 + 88)];
        *(_WORD *)int v16 = *(v13 - 1);
        unsigned int v18 = *v13;
        v13 += 2;
        unsigned int v17 = v18;
        *((_WORD *)v16 + 1) = v18;
        *((_DWORD *)v16 + 5) = v36;
        *(_OWORD *)(v16 + 4) = v35;
        else {
          unsigned int v12 = v17;
        }
        v14 += 24;
        --v15;
      }

      while (v15);
    }

    uint64_t v19 = *(const void **)(a5 + 80);
    if (v19)
    {
      memmove(v10, v19, 24LL * *(unsigned __int16 *)(a5 + 88));
      sub_1000B1838(*(void **)(a5 + 80));
    }

    *(void *)(a5 + 80) = v11;
    *(_WORD *)(a5 + 88) += a4;
    if (v12) {
      unsigned __int16 v20 = v12;
    }
    else {
      unsigned __int16 v20 = -1;
    }
    if (WORD3(v38) > v20)
    {
      __chkstk_darwin(v10, v37);
      uint64_t v22 = (char *)&v35 - v21;
      bzero((char *)&v35 - v21, v23);
      sub_1001BEF1C(v22, (unsigned __int8 *)&v37, 1);
      uint64_t v6 = sub_1001A2BF4(*(void *)a5, (uint64_t)sub_1001C0860, 10240, v20 + 1, 0xFFFFu, v22, v37, a5);
      if (!(_DWORD)v6) {
        return;
      }
      goto LABEL_21;
    }
  }

  uint64_t v6 = 0LL;
LABEL_21:
  uint64_t v33 = *(void (**)(uint64_t, void, void, uint64_t))(a5 + 16);
  uint64_t v32 = *(void *)(a5 + 24);
  *(void *)(a5 + 16) = 0LL;
  v33(v6, *(void *)(a5 + 80), *(unsigned __int16 *)(a5 + 88), v32);
  uint64_t v34 = *(void **)(a5 + 80);
  if (v34) {
    sub_1000B1838(v34);
  }
  *(void *)(a5 + 80) = 0LL;
  *(_WORD *)(a5 + 88) = 0;
}

uint64_t sub_1001C0AAC(unsigned int a1, uint64_t a2, __int16 a3, __int16 a4, uint64_t a5)
{
  uint64_t v9 = sub_1001C028C(a1);
  char v11 = 8;
  __int16 v12 = a3;
  __int16 v13 = a4;
  int v15 = 0;
  __int128 v14 = xmmword_1006BD8C4;
  uint64_t result = 101LL;
  if (v9 && a2)
  {
    if (*(void *)(v9 + 16))
    {
      return 118LL;
    }

    else
    {
      uint64_t result = sub_1001A2D24(*(void *)v9, (uint64_t)sub_1001C0B98, (int *)&v11, v9);
      if (!(_DWORD)result)
      {
        *(void *)(v9 + 16) = a2;
        *(void *)(v9 + 24) = a5;
        *(void *)(v9 + 32) = 0LL;
        *(void *)(v9 + 40) = 0LL;
        *(_DWORD *)(v9 + 48) = 0;
        *(_WORD *)(v9 + 52) = a3;
        *(_WORD *)(v9 + 54) = a4;
        *(void *)(v9 + 64) = 0LL;
        *(void *)(v9 + 72) = 0LL;
        *(void *)(v9 + 56) = 0LL;
      }
    }
  }

  return result;
}

void sub_1001C0B98(uint64_t a1, uint64_t a2, uint64_t a3, unsigned int a4, int a5, uint64_t a6)
{
  if ((_DWORD)a2 == 10)
  {
    if (sub_1001C2930(a6)) {
      return;
    }
  }

  else
  {
    uint64_t v7 = a2;
    if ((_DWORD)a2)
    {
      if (sub_1000A86F0())
      {
        sub_1001EE134( (uint64_t)"Received error response for included services discovery: %d",  v27,  v28,  v29,  v30,  v31,  v32,  v33,  v7);
        uint64_t v34 = (os_log_s *)sub_100086554(0x45u);
        if (os_log_type_enabled(v34, OS_LOG_TYPE_ERROR)) {
          sub_100657858();
        }
      }

      goto LABEL_30;
    }

    unsigned int v40 = *(unsigned __int16 *)(a6 + 54);
    char v11 = (char *)sub_1000B17F4(28 * (*(unsigned __int16 *)(a6 + 88) + (unint64_t)a4));
    __dst = v11;
    int v12 = 0;
    if (a4)
    {
      __int16 v13 = (_WORD **)(a3 + 8);
      __int128 v14 = v11;
      for (uint64_t i = a4; i; --i)
      {
        uint64_t v16 = *(unsigned __int16 *)(a6 + 88);
        uint64_t v17 = 28 * v16;
        unsigned int v18 = &v14[28 * v16];
        *(_WORD *)unsigned int v18 = *((_WORD *)v13 - 4);
        uint64_t v19 = *v13;
        *((_WORD *)v18 + 1) = **v13;
        *((_WORD *)v18 + 2) = v19[1];
        if (a5 == 22)
        {
          uint64_t v21 = &v14[28 * v16];
          uint64_t v22 = (int8x16_t *)(v19 + 2);
          uint64_t v23 = 16LL;
        }

        else
        {
          if (a5 != 8)
          {
            if (a5 == 6)
            {
              unsigned __int16 v20 = &v14[28 * v16];
              v20[8] = 0;
              *((_WORD *)v20 + 6) = 0;
            }

            goto LABEL_12;
          }

          uint64_t v21 = &v14[28 * v16];
          uint64_t v22 = (int8x16_t *)(v19 + 2);
          uint64_t v23 = 2LL;
        }

        sub_1001BEE18(v22, v23, 1, (uint64_t)v41);
        __int128 v24 = *(_OWORD *)v41;
        *((_DWORD *)v21 + 6) = *(_DWORD *)&v41[16];
        *(_OWORD *)(v21 + 8) = v24;
LABEL_12:
        else {
          int v12 = *(unsigned __int16 *)&v14[v17];
        }
        v14 += 28;
        v13 += 2;
      }
    }

    uint64_t v25 = *(const void **)(a6 + 80);
    uint64_t v26 = *(unsigned __int16 *)(a6 + 88);
    if (v25)
    {
      memmove(__dst, v25, 28 * v26);
      sub_1000B1838(*(void **)(a6 + 80));
      LOWORD(v26) = *(_WORD *)(a6 + 88);
    }

    *(void *)(a6 + 80) = __dst;
    *(_WORD *)(a6 + 88) = v26 + a4;
    if (v12) {
      unsigned __int16 v35 = v12;
    }
    else {
      unsigned __int16 v35 = -1;
    }
    if (v40 > v35)
    {
      v41[0] = 8;
      *(_WORD *)&v41[1] = v35 + 1;
      *(_WORD *)&v41[3] = v40;
      int v42 = 0;
      *(_OWORD *)&v41[5] = xmmword_1006BD8C4;
      uint64_t v7 = sub_1001A2D24(*(void *)a6, (uint64_t)sub_1001C0B98, (int *)v41, a6);
      if (!(_DWORD)v7) {
        return;
      }
      goto LABEL_30;
    }
  }

  uint64_t v7 = 0LL;
LABEL_30:
  __int128 v37 = *(void (**)(uint64_t, void, void, uint64_t))(a6 + 16);
  uint64_t v36 = *(void *)(a6 + 24);
  *(void *)(a6 + 16) = 0LL;
  v37(v7, *(void *)(a6 + 80), *(unsigned __int16 *)(a6 + 88), v36);
  __int128 v38 = *(void **)(a6 + 80);
  if (v38) {
    sub_1000B1838(v38);
  }
  *(void *)(a6 + 80) = 0LL;
  *(_WORD *)(a6 + 88) = 0;
}

uint64_t sub_1001C0E30(unsigned int a1, uint64_t a2, __int16 a3, __int16 a4, uint64_t a5)
{
  uint64_t v9 = sub_1001C028C(a1);
  char v11 = 8;
  __int16 v12 = a3;
  __int16 v13 = a4;
  int v15 = 0;
  __int128 v14 = xmmword_1006BD8D8;
  uint64_t result = 101LL;
  if (v9 && a2)
  {
    if (*(void *)(v9 + 16))
    {
      return 118LL;
    }

    else
    {
      uint64_t result = sub_1001A2D24(*(void *)v9, (uint64_t)sub_1001C0F1C, (int *)&v11, v9);
      if (!(_DWORD)result)
      {
        *(void *)(v9 + 16) = a2;
        *(void *)(v9 + 24) = a5;
        *(void *)(v9 + 32) = 0LL;
        *(void *)(v9 + 40) = 0LL;
        *(_DWORD *)(v9 + 48) = 0;
        *(_WORD *)(v9 + 52) = a3;
        *(_WORD *)(v9 + 54) = a4;
        *(void *)(v9 + 64) = 0LL;
        *(void *)(v9 + 72) = 0LL;
        *(void *)(v9 + 56) = 0LL;
      }
    }
  }

  return result;
}

void sub_1001C0F1C(uint64_t a1, uint64_t a2, uint64_t a3, unsigned int a4, int a5, uint64_t a6)
{
  uint64_t v6 = a6;
  if ((_DWORD)a2 != 10)
  {
    uint64_t v7 = a2;
    if ((_DWORD)a2)
    {
      if (sub_1000A86F0())
      {
        sub_1001EE134( (uint64_t)"Received error response for characteristics discovery: %d",  v23,  v24,  v25,  v26,  v27,  v28,  v29,  v7);
        uint64_t v30 = (os_log_s *)sub_100086554(0x45u);
        if (os_log_type_enabled(v30, OS_LOG_TYPE_ERROR)) {
          sub_100657858();
        }
      }

      goto LABEL_31;
    }

    LODWORD(v8) = a4;
    int v38 = *(unsigned __int16 *)(a6 + 54);
    __int128 v43 = *(_OWORD *)(a6 + 32);
    int v44 = *(_DWORD *)(a6 + 48);
    size_t v10 = (char *)sub_1000B17F4(28 * (*(unsigned __int16 *)(a6 + 88) + (unint64_t)a4));
    if ((_DWORD)v8)
    {
      unsigned __int16 v11 = 0;
      LOWORD(v12) = 0;
      __int16 v13 = (char **)(a3 + 8);
      uint64_t v8 = v8;
      uint64_t v39 = v6;
      while (1)
      {
        __int128 v14 = v10;
        int v15 = &v10[28 * *(unsigned __int16 *)(v6 + 88)];
        uint64_t v16 = &v15[28 * v11];
        *(_WORD *)uint64_t v16 = *((_WORD *)v13 - 4);
        uint64_t v17 = *v13;
        v16[2] = **v13;
        *((_WORD *)v16 + 2) = *(_WORD *)(v17 + 1);
        unsigned int v18 = (unsigned __int16 *)(v16 + 4);
        if (a5 == 21)
        {
          uint64_t v19 = &v15[28 * v11];
          unsigned __int16 v20 = (int8x16_t *)(v17 + 3);
          uint64_t v21 = 16LL;
        }

        else
        {
          if (a5 != 7) {
            goto LABEL_10;
          }
          uint64_t v19 = &v15[28 * v11];
          unsigned __int16 v20 = (int8x16_t *)(v17 + 3);
          uint64_t v21 = 2LL;
        }

        sub_1001BEE18(v20, v21, 1, (uint64_t)v41);
        __int128 v22 = *(_OWORD *)v41;
        *((_DWORD *)v19 + 6) = *(_DWORD *)&v41[16];
        *(_OWORD *)(v19 + 8) = v22;
        uint64_t v6 = v39;
LABEL_10:
        else {
          int v12 = *v18;
        }
        v13 += 2;
        --v8;
        size_t v10 = v14;
        if (!v8) {
          goto LABEL_22;
        }
      }
    }

    int v12 = 0;
    unsigned __int16 v11 = 0;
LABEL_22:
    uint64_t v31 = *(const void **)(v6 + 80);
    uint64_t v32 = *(unsigned __int16 *)(v6 + 88);
    if (v31)
    {
      memmove(v10, v31, 28 * v32);
      sub_1000B1838(*(void **)(v6 + 80));
      LOWORD(v32) = *(_WORD *)(v6 + 88);
    }

    *(void *)(v6 + 80) = v10;
    *(_WORD *)(v6 + 88) = v32 + v11;
    if (v12) {
      unsigned __int16 v33 = v12;
    }
    else {
      unsigned __int16 v33 = -1;
    }
    if (v38 - 1 > v33)
    {
      v41[0] = 8;
      *(_WORD *)&v41[1] = v33 + 1;
      *(_WORD *)&v41[3] = v38;
      int v42 = 0;
      *(_OWORD *)&v41[5] = xmmword_1006BD8D8;
      uint64_t v7 = sub_1001A2D24(a1, (uint64_t)sub_1001C0F1C, (int *)v41, v6);
      if (!(_DWORD)v7) {
        return;
      }
      goto LABEL_31;
    }
  }

  uint64_t v7 = 0LL;
LABEL_31:
  unsigned __int16 v35 = *(void (**)(uint64_t, void, void, uint64_t))(v6 + 16);
  uint64_t v34 = *(void *)(v6 + 24);
  *(void *)(v6 + 16) = 0LL;
  v35(v7, *(void *)(v6 + 80), *(unsigned __int16 *)(v6 + 88), v34);
  uint64_t v36 = *(void **)(v6 + 80);
  if (v36) {
    sub_1000B1838(v36);
  }
  *(void *)(v6 + 80) = 0LL;
  *(_WORD *)(v6 + 88) = 0;
}

__n128 sub_1001C11D4(unsigned int a1, uint64_t a2, __n128 *a3, __int16 a4, __int16 a5, uint64_t a6)
{
  uint64_t v11 = sub_1001C028C(a1);
  char v15 = 8;
  __int16 v16 = a4;
  __int16 v17 = a5;
  int v19 = 0;
  __int128 v18 = xmmword_1006BD8D8;
  __n128 result = *a3;
  __n128 v13 = *a3;
  unsigned __int32 v14 = a3[1].n128_u32[0];
  if (v11
    && a2
    && !*(void *)(v11 + 16)
    && !sub_1001A2D24(*(void *)v11, (uint64_t)sub_1001C0F1C, (int *)&v15, v11))
  {
    *(void *)(v11 + 16) = a2;
    *(void *)(v11 + 24) = a6;
    __n128 result = v13;
    *(__n128 *)(v11 + 32) = v13;
    *(_DWORD *)(v11 + 48) = v14;
    *(_WORD *)(v11 + 52) = a4;
    *(_WORD *)(v11 + 54) = a5;
    *(void *)(v11 + 64) = 0LL;
    *(void *)(v11 + 72) = 0LL;
    *(void *)(v11 + 56) = 0LL;
  }

  return result;
}

uint64_t sub_1001C12DC(unsigned int a1, uint64_t a2, __int16 a3, __int16 a4, uint64_t a5)
{
  uint64_t v9 = sub_1001C028C(a1);
  char v11 = 4;
  __int16 v12 = a3;
  __int16 v13 = a4;
  uint64_t result = 101LL;
  if (v9 && a2)
  {
    if (*(void *)(v9 + 16))
    {
      return 118LL;
    }

    else
    {
      uint64_t result = sub_1001A2AF8(*(void *)v9, (uint64_t)sub_1001C1388, (uint64_t)&v11, v9);
      if (!(_DWORD)result)
      {
        *(void *)(v9 + 16) = a2;
        *(void *)(v9 + 24) = a5;
        *(void *)(v9 + 32) = 0LL;
        *(void *)(v9 + 40) = 0LL;
        *(_DWORD *)(v9 + 48) = 0;
        *(_WORD *)(v9 + 52) = a3;
        *(_WORD *)(v9 + 54) = a4;
        *(void *)(v9 + 64) = 0LL;
        *(void *)(v9 + 72) = 0LL;
        *(void *)(v9 + 56) = 0LL;
      }
    }
  }

  return result;
}

void sub_1001C1388(uint64_t a1, uint64_t a2, uint64_t a3, unsigned int a4, uint64_t a5)
{
  if ((_DWORD)a2 != 10)
  {
    uint64_t v6 = a2;
    if ((_DWORD)a2)
    {
      if (sub_1000A86F0())
      {
        sub_1001EE134( (uint64_t)"Received error response for descriptors discovery: %u",  v21,  v22,  v23,  v24,  v25,  v26,  v27,  v6);
        uint64_t v28 = (os_log_s *)sub_100086554(0x45u);
        if (os_log_type_enabled(v28, OS_LOG_TYPE_ERROR)) {
          sub_100657858();
        }
      }

      goto LABEL_21;
    }

    unsigned int v9 = *(unsigned __int16 *)(a5 + 54);
    size_t v10 = (char *)sub_1000B17F4(40 * (*(unsigned __int16 *)(a5 + 88) + (unint64_t)a4));
    char v11 = v10;
    unsigned int v12 = 0;
    if (a4)
    {
      __int16 v13 = (__int128 *)(a3 + 4);
      unsigned __int32 v14 = v10;
      uint64_t v15 = a4;
      do
      {
        __int16 v16 = &v14[40 * *(unsigned __int16 *)(a5 + 88)];
        unsigned int v17 = *((unsigned __int16 *)v13 - 2);
        *(_WORD *)__int16 v16 = v17;
        __int128 v18 = *v13;
        *((_DWORD *)v16 + 5) = *((_DWORD *)v13 + 4);
        *(_OWORD *)(v16 + 4) = v18;
        *((void *)v16 + 3) = 0LL;
        *((_WORD *)v16 + 16) = 0;
        else {
          unsigned int v12 = v17;
        }
        v14 += 40;
        __int16 v13 = (__int128 *)((char *)v13 + 24);
        --v15;
      }

      while (v15);
    }

    int v19 = *(const void **)(a5 + 80);
    if (v19)
    {
      memmove(v10, v19, 40LL * *(unsigned __int16 *)(a5 + 88));
      sub_1000B1838(*(void **)(a5 + 80));
    }

    *(void *)(a5 + 80) = v11;
    *(_WORD *)(a5 + 88) += a4;
    if (v12) {
      unsigned __int16 v20 = v12;
    }
    else {
      unsigned __int16 v20 = -1;
    }
    if (v9 > v20)
    {
      char v32 = 4;
      __int16 v33 = v20 + 1;
      __int16 v34 = v9;
      uint64_t v6 = sub_1001A2AF8(*(void *)a5, (uint64_t)sub_1001C1388, (uint64_t)&v32, a5);
      if (!(_DWORD)v6) {
        return;
      }
      goto LABEL_21;
    }
  }

  uint64_t v6 = 0LL;
LABEL_21:
  uint64_t v30 = *(void (**)(uint64_t, void, void, uint64_t))(a5 + 16);
  uint64_t v29 = *(void *)(a5 + 24);
  *(void *)(a5 + 16) = 0LL;
  v30(v6, *(void *)(a5 + 80), *(unsigned __int16 *)(a5 + 88), v29);
  uint64_t v31 = *(void **)(a5 + 80);
  if (v31) {
    sub_1000B1838(v31);
  }
  *(void *)(a5 + 80) = 0LL;
  *(_WORD *)(a5 + 88) = 0;
}

uint64_t sub_1001C1540(unsigned int a1, uint64_t a2, __int16 a3, uint64_t a4)
{
  uint64_t v7 = sub_1001C028C(a1);
  char v9 = 10;
  __int16 v10 = a3;
  uint64_t result = 101LL;
  if (v7 && a2)
  {
    if (*(void *)(v7 + 16))
    {
      return 118LL;
    }

    else
    {
      uint64_t result = sub_1001A2E80(*(void *)v7, (uint64_t)sub_1001C15E0, (uint64_t)&v9, v7);
      if (!(_DWORD)result)
      {
        *(void *)(v7 + 16) = a2;
        *(void *)(v7 + 24) = a4;
        *(void *)(v7 + 32) = 0LL;
        *(void *)(v7 + 40) = 0LL;
        *(_DWORD *)(v7 + 48) = 0;
        *(_WORD *)(v7 + 52) = a3;
        *(void *)(v7 + 54) = 0LL;
        *(void *)(v7 + 70) = 0LL;
        *(void *)(v7 + 62) = 0LL;
        *(_WORD *)(v7 + 78) = 0;
      }
    }
  }

  return result;
}

void sub_1001C15E0(uint64_t a1, uint64_t a2, const void *a3, unsigned int a4, uint64_t a5)
{
  if ((_DWORD)a2)
  {
    uint64_t v6 = a2;
    if (sub_1000A86F0())
    {
      sub_1001EE134( (uint64_t)"LE_GATT_Handle_ReadLongCharacteristicValueResponse Received error response for characteristic read: %u",  v7,  v8,  v9,  v10,  v11,  v12,  v13,  v6);
      unsigned __int32 v14 = (os_log_s *)sub_100086554(0x45u);
      if (os_log_type_enabled(v14, OS_LOG_TYPE_ERROR)) {
        sub_100657858();
      }
    }
  }

  else
  {
    __int16 v19 = *(_WORD *)(a5 + 52);
    int v20 = *(unsigned __int16 *)(a5 + 56);
    size_t v21 = a4;
    uint64_t v22 = (char *)sub_1000B17F4(*(unsigned __int16 *)(a5 + 88) + (unint64_t)a4);
    memmove(&v22[*(unsigned __int16 *)(a5 + 88)], a3, v21);
    uint64_t v23 = *(const void **)(a5 + 80);
    if (v23)
    {
      memmove(v22, v23, *(unsigned __int16 *)(a5 + 88));
      sub_1000B1838(*(void **)(a5 + 80));
    }

    *(void *)(a5 + 80) = v22;
    unsigned __int16 v24 = *(_WORD *)(a5 + 88) + a4;
    *(_WORD *)(a5 + 88) = v24;
    int v25 = sub_1001A2494(*(void *)a5);
    if (!v24 || v20 + v24 > 0x1FF || v25 - 1 > (int)a4)
    {
      uint64_t v27 = *(void (**)(void, void, void, uint64_t))(a5 + 16);
      uint64_t v26 = *(void *)(a5 + 24);
      *(void *)(a5 + 16) = 0LL;
      v27(0LL, *(void *)(a5 + 80), *(unsigned __int16 *)(a5 + 88), v26);
      goto LABEL_12;
    }

    char v29 = 12;
    __int16 v30 = v19;
    __int16 v31 = v20 + v24;
    uint64_t v6 = sub_1001A2F6C(*(void *)a5, (uint64_t)sub_1001C15E0, (uint64_t)&v29, a5);
    if (!(_DWORD)v6) {
      return;
    }
  }

  __int16 v16 = *(void (**)(uint64_t, void, void, uint64_t))(a5 + 16);
  uint64_t v15 = *(void *)(a5 + 24);
  *(void *)(a5 + 16) = 0LL;
  v16(v6, 0LL, 0LL, v15);
LABEL_12:
  uint64_t v28 = *(void **)(a5 + 80);
  if (v28) {
    sub_1000B1838(v28);
  }
  *(void *)(a5 + 80) = 0LL;
  *(_WORD *)(a5 + 88) = 0;
}

uint64_t sub_1001C176C( unsigned int a1, uint64_t a2, __int128 *a3, __int16 a4, unsigned int a5, __int16 a6, uint64_t a7)
{
  uint64_t v13 = (uint64_t *)sub_1001C028C(a1);
  char v27 = 8;
  __int16 v28 = a4;
  __int16 v29 = a5;
  __int128 v30 = *a3;
  int v31 = *((_DWORD *)a3 + 4);
  __int128 v25 = *a3;
  int v26 = *((_DWORD *)a3 + 4);
  uint64_t v14 = (uint64_t)v13;
  uint64_t v15 = 101LL;
  if (v13 && a2)
  {
    if (v13[2])
    {
      return 118LL;
    }

    else
    {
      uint64_t v15 = sub_1001A2D24(*v13, (uint64_t)sub_1001C18E4, (int *)&v27, (uint64_t)v13);
      if ((_DWORD)v15)
      {
        if (sub_1000A86F0())
        {
          sub_1001EE134( (uint64_t)"Failed to send discover all services request for bearer 0x%x %!",  v17,  v18,  v19,  v20,  v21,  v22,  v23,  v14);
          unsigned __int16 v24 = (os_log_s *)sub_100086554(0x45u);
          if (os_log_type_enabled(v24, OS_LOG_TYPE_ERROR)) {
            sub_100657858();
          }
        }
      }

      else
      {
        *(void *)(v14 + 16) = a2;
        *(void *)(v14 + 24) = a7;
        *(_OWORD *)(v14 + 32) = v25;
        *(_DWORD *)(v14 + 48) = v26;
        *(_WORD *)(v14 + 52) = a4;
        *(_WORD *)(v14 + 54) = a5;
        *(void *)(v14 + 56) = 0LL;
        *(void *)(v14 + 64) = 0LL;
        *(_WORD *)(v14 + 72) = 0;
        *(_WORD *)(v14 + 74) = a6;
        *(_DWORD *)(v14 + 76) = 0;
      }
    }
  }

  return v15;
}

void sub_1001C18E4(uint64_t a1, uint64_t a2, uint64_t a3, unsigned int a4, int a5, uint64_t a6)
{
  uint64_t v9 = &qword_1008ECEE0;
  do
  {
    uint64_t v10 = *v9;
    uint64_t v9 = (uint64_t *)(*v9 + 96);
  }

  while (v10 != a6 && v10 != 0);
  if (v10)
  {
    uint64_t v12 = *(void (**)(uint64_t, uint64_t, uint64_t, uint64_t))(a6 + 16);
    if ((_DWORD)a2 == 10)
    {
      if (!v12) {
        return;
      }
      *(void *)(a6 + 16) = 0LL;
      uint64_t v24 = *(void *)(a6 + 80);
      uint64_t v14 = *(unsigned __int16 *)(a6 + 88);
      uint64_t v25 = *(void *)(a6 + 24);
      uint64_t v26 = 10LL;
    }

    else if ((_DWORD)a2)
    {
      if (sub_1000A86F0()
        && (sub_1001EE134((uint64_t)"Received error response for read value %d", v27, v28, v29, v30, v31, v32, v33, a2),
            __int16 v34 = (os_log_s *)sub_100086554(0x45u),
            os_log_type_enabled(v34, OS_LOG_TYPE_ERROR)))
      {
        sub_100657858();
        if (!v12) {
          return;
        }
      }

      else if (!v12)
      {
        return;
      }

      *(void *)(a6 + 16) = 0LL;
      uint64_t v25 = *(void *)(a6 + 24);
      uint64_t v26 = a2;
      uint64_t v24 = 0LL;
      uint64_t v14 = 0LL;
    }

    else
    {
      unsigned int v13 = sub_1001C2DB4(a6, a3, a4, a5);
      uint64_t v14 = *(unsigned __int16 *)(a6 + 88);
      if (v14 >= *(unsigned __int16 *)(a6 + 74)
        || v13 == 0xFFFF
        || (unsigned int v15 = *(unsigned __int16 *)(a6 + 54), v13 >= v15))
      {
        if (!v12) {
          return;
        }
        *(void *)(a6 + 16) = 0LL;
        uint64_t v24 = *(void *)(a6 + 80);
      }

      else
      {
        char v36 = 8;
        __int16 v37 = v13 + 1;
        __int16 v38 = v15;
        __int128 v39 = *(_OWORD *)(a6 + 32);
        int v40 = *(_DWORD *)(a6 + 48);
        if (sub_1000A86F0()
          && (sub_1001EE134( (uint64_t)"Failed to send read characteristics value request for bearer 0x%x",  v16,  v17,  v18,  v19,  v20,  v21,  v22,  a1),  uint64_t v23 = (os_log_s *)sub_100086554(0x45u),  os_log_type_enabled(v23, OS_LOG_TYPE_ERROR)))
        {
          sub_100657858();
          if (!v12) {
            return;
          }
        }

        else if (!v12)
        {
          return;
        }

        *(void *)(a6 + 16) = 0LL;
        uint64_t v24 = *(void *)(a6 + 80);
        uint64_t v14 = *(unsigned __int16 *)(a6 + 88);
      }

      uint64_t v25 = *(void *)(a6 + 24);
      uint64_t v26 = 0LL;
    }

    v12(v26, v24, v14, v25);
    unsigned __int16 v35 = *(void **)(a6 + 80);
    if (v35) {
      sub_1000B1838(v35);
    }
    *(void *)(a6 + 80) = 0LL;
    *(_WORD *)(a6 + 88) = 0;
  }

uint64_t sub_1001C1AFC(unsigned int a1, uint64_t a2, __int16 a3, __int16 a4, uint64_t a5)
{
  uint64_t v9 = sub_1001C028C(a1);
  char v11 = 12;
  __int16 v12 = a3;
  __int16 v13 = a4;
  uint64_t result = 101LL;
  if (v9 && a2)
  {
    if (*(void *)(v9 + 16))
    {
      return 118LL;
    }

    else
    {
      uint64_t result = sub_1001A2F6C(*(void *)v9, (uint64_t)sub_1001C15E0, (uint64_t)&v11, v9);
      if (!(_DWORD)result)
      {
        *(void *)(v9 + 16) = a2;
        *(void *)(v9 + 24) = a5;
        *(void *)(v9 + 32) = 0LL;
        *(void *)(v9 + 40) = 0LL;
        *(_DWORD *)(v9 + 48) = 0;
        *(_WORD *)(v9 + 52) = a3;
        *(_WORD *)(v9 + 54) = 0;
        *(_WORD *)(v9 + 56) = a4;
        *(void *)(v9 + 66) = 0LL;
        *(void *)(v9 + 58) = 0LL;
        *(void *)(v9 + 72) = 0LL;
      }
    }
  }

  return result;
}

uint64_t sub_1001C1BB0(unsigned int a1, uint64_t a2, __int16 a3, uint64_t a4, __int16 a5, uint64_t a6)
{
  char v11 = (uint64_t *)sub_1001C028C(a1);
  if (a2) {
    char v12 = 18;
  }
  else {
    char v12 = 82;
  }
  char v26 = v12;
  __int16 v27 = a3;
  __int16 v28 = a5;
  uint64_t v29 = a4;
  if (!v11) {
    return 101LL;
  }
  uint64_t v13 = (uint64_t)v11;
  if (v11[2]) {
    return 118LL;
  }
  uint64_t v16 = *v11;
  if (a2) {
    uint64_t v17 = sub_1001C1CAC;
  }
  else {
    uint64_t v17 = 0LL;
  }
  uint64_t v14 = sub_1001A3058(v16, (uint64_t)v17, (__int16 *)&v26, v13);
  if ((_DWORD)v14)
  {
    if (sub_1000A86F0())
    {
      sub_1001EE134((uint64_t)"Failed to write request for bearer 0x%x %!", v18, v19, v20, v21, v22, v23, v24, v13);
      uint64_t v25 = (os_log_s *)sub_100086554(0x45u);
      if (os_log_type_enabled(v25, OS_LOG_TYPE_ERROR)) {
        sub_100657858();
      }
    }
  }

  else
  {
    *(void *)(v13 + 16) = a2;
    *(void *)(v13 + 24) = a6;
  }

  return v14;
}

void sub_1001C1CAC(uint64_t a1, uint64_t a2, uint64_t a3)
{
  uint64_t v5 = &qword_1008ECEE0;
  do
  {
    uint64_t v6 = *v5;
    uint64_t v5 = (uint64_t *)(*v5 + 96);
  }

  while (v6 != a3 && v6 != 0);
  if (v6)
  {
    uint64_t v8 = *(void (**)(uint64_t, void))(a3 + 16);
    *(void *)(a3 + 16) = 0LL;
    if ((_DWORD)a2
      && sub_1000A86F0()
      && (sub_1001EE134((uint64_t)"Received error response for write value %d", v9, v10, v11, v12, v13, v14, v15, a2),
          uint64_t v16 = (os_log_s *)sub_100086554(0x45u),
          os_log_type_enabled(v16, OS_LOG_TYPE_ERROR)))
    {
      sub_100657858();
      if (!v8) {
        return;
      }
    }

    else if (!v8)
    {
      return;
    }

    v8(a2, *(void *)(a3 + 24));
  }

uint64_t sub_1001C1D60( unsigned int a1, uint64_t a2, __int16 a3, __int16 a4, const void *a5, unsigned int a6, uint64_t a7)
{
  uint64_t v13 = (uint64_t *)sub_1001C028C(a1);
  char v27 = 22;
  __int16 v28 = a3;
  __int16 v29 = a4;
  __int16 v30 = a6;
  uint64_t v14 = 101LL;
  uint64_t v31 = a5;
  if (v13 && a2)
  {
    uint64_t v15 = (uint64_t)v13;
    if (v13[2])
    {
      return 118LL;
    }

    else
    {
      uint64_t v17 = sub_1001A31A8(*(void *)v15, (uint64_t)sub_1001C1EC4, (int *)&v27, v15);
      if ((_DWORD)v17)
      {
        uint64_t v14 = v17;
        if (sub_1000A86F0())
        {
          sub_1001EE134((uint64_t)"Failed to write request for bearer 0x%x %!", v18, v19, v20, v21, v22, v23, v24, v15);
          uint64_t v25 = (os_log_s *)sub_100086554(0x45u);
          if (os_log_type_enabled(v25, OS_LOG_TYPE_ERROR)) {
            sub_100657858();
          }
        }
      }

      else
      {
        *(void *)(v15 + 16) = a2;
        *(void *)(v15 + 24) = a7;
        *(void *)(v15 + 32) = 0LL;
        *(void *)(v15 + 40) = 0LL;
        *(_DWORD *)(v15 + 48) = 0;
        *(_WORD *)(v15 + 52) = a3;
        *(_WORD *)(v15 + 54) = 0;
        *(_WORD *)(v15 + 56) = a4;
        *(void *)(v15 + 66) = 0LL;
        *(void *)(v15 + 72) = 0LL;
        *(void *)(v15 + 58) = 0LL;
        *(_WORD *)(v15 + 72) = a6;
        char v26 = sub_1000B17F4(a6);
        *(void *)(v15 + 64) = v26;
        if (v26) {
          memmove(v26, a5, a6);
        }
        return 0LL;
      }
    }
  }

  return v14;
}

void sub_1001C1EC4(int a1, uint64_t a2, uint64_t a3, int a4, void *__s2, size_t __n, uint64_t *a7)
{
  uint64_t v10 = &qword_1008ECEE0;
  do
  {
    uint64_t v11 = (uint64_t *)*v10;
    uint64_t v10 = (uint64_t *)(*v10 + 96);
  }

  while (v11 != a7 && v11 != 0LL);
  if (!v11) {
    return;
  }
  uint64_t v13 = *a7;
  *(_BYTE *)(*a7 + 96) = a2;
  uint64_t v14 = (void (*)(uint64_t, uint64_t))a7[2];
  if ((_DWORD)a2)
  {
    if (sub_1000A86F0())
    {
      sub_1001EE134( (uint64_t)"Received error response %d for write long value - canceling execution",  v15,  v16,  v17,  v18,  v19,  v20,  v21,  a2);
      uint64_t v22 = (os_log_s *)sub_100086554(0x45u);
      if (os_log_type_enabled(v22, OS_LOG_TYPE_ERROR)) {
        sub_100657858();
      }
    }

    uint64_t v23 = sub_1001A32B0(*a7, (uint64_t)sub_1001C2F34, 0, (uint64_t)a7);
    if ((_DWORD)v23)
    {
      uint64_t v24 = v23;
      if (!sub_1000A86F0()
        || (sub_1001EE134((uint64_t)"Failed to execute write request %!", v25, v26, v27, v28, v29, v30, v31, v24),
            uint64_t v32 = (os_log_s *)sub_100086554(0x45u),
            !os_log_type_enabled(v32, OS_LOG_TYPE_ERROR)))
      {
        if (!v14) {
          goto LABEL_18;
        }
        goto LABEL_16;
      }

      sub_100657858();
      if (v14)
      {
LABEL_16:
        a7[2] = 0LL;
        uint64_t v33 = a7[3];
        uint64_t v34 = a2;
LABEL_17:
        v14(v34, v33);
      }

uint64_t sub_1001C2338(unsigned int a1, uint64_t a2, __int16 a3, uint64_t a4, __int16 a5, uint64_t a6)
{
  uint64_t v11 = (uint64_t *)sub_1001C028C(a1);
  char v23 = 18;
  __int16 v24 = a3;
  __int16 v25 = a5;
  uint64_t v26 = a4;
  uint64_t v12 = 101LL;
  if (v11 && a2)
  {
    uint64_t v13 = (uint64_t)v11;
    if (v11[2])
    {
      return 118LL;
    }

    else
    {
      uint64_t v12 = sub_1001A3058(*v11, (uint64_t)sub_1001C1CAC, (__int16 *)&v23, (uint64_t)v11);
      if ((_DWORD)v12)
      {
        if (sub_1000A86F0())
        {
          sub_1001EE134( (uint64_t)"Failed to write characteristic descriptor %: %!",  v15,  v16,  v17,  v18,  v19,  v20,  v21,  v13);
          uint64_t v22 = (os_log_s *)sub_100086554(0x45u);
          if (os_log_type_enabled(v22, OS_LOG_TYPE_ERROR)) {
            sub_100657858();
          }
        }
      }

      else
      {
        *(void *)(v13 + 16) = a2;
        *(void *)(v13 + 24) = a6;
      }
    }
  }

  return v12;
}

__n128 sub_1001C2420(__n128 *a1)
{
  if (!a1) {
    sub_1001EE2A0();
  }
  if (xmmword_1008ECEF0 != 0) {
    sub_1001EE2A0();
  }
  if (a1)
  {
    __n128 result = *a1;
    off_1008ECF00 = (uint64_t (*)(void, void, void, void))a1[1].n128_u64[0];
    xmmword_1008ECEF0 = (__int128)result;
  }

  return result;
}

void sub_1001C2470()
{
  xmmword_1008ECEF0 = 0uLL;
  off_1008ECF00 = 0LL;
}

uint64_t sub_1001C2484(uint64_t result)
{
  dword_1008D8EB0 = result;
  return result;
}

void sub_1001C2490(unsigned __int16 *a1, uint64_t a2, uint64_t a3)
{
  if (sub_1000A86F0())
  {
    uint64_t v13 = a1 ? *a1 : 0LL;
    sub_1001EE134( (uint64_t)"_GATT_LE_ConnectCompleteCB notification from lmHandle 0x%x with status %!",  v6,  v7,  v8,  v9,  v10,  v11,  v12,  v13);
    uint64_t v14 = (os_log_s *)sub_100086554(0x45u);
    if (os_log_type_enabled(v14, OS_LOG_TYPE_DEFAULT))
    {
      *(_DWORD *)buf = 136446210;
      uint64_t v30 = sub_1001EDDCC();
      _os_log_impl((void *)&_mh_execute_header, v14, OS_LOG_TYPE_DEFAULT, " %{public}s", buf, 0xCu);
    }
  }

  uint64_t v15 = sub_1001C0120((uint64_t)a1, a2);
  if ((_DWORD)v15)
  {
    uint64_t v16 = (void (*)(unsigned __int16 *, uint64_t, uint64_t, uint64_t, uint64_t))xmmword_1008ECEF0;
    if ((void)xmmword_1008ECEF0)
    {
      uint64_t v17 = v15;
      uint64_t v18 = sub_1001A24F8(a2);
      uint64_t v19 = 1LL;
      if (a1)
      {
        if (*((_BYTE *)a1 + 2) == 4) {
          uint64_t v19 = 2LL;
        }
        else {
          uint64_t v19 = 1LL;
        }
      }

      v16(a1, v17, v18, v19, a3);
    }
  }

  else if (sub_1000A86F0())
  {
    sub_1001EE134((uint64_t)"Failed to create LE GATT session ", v20, v21, v22, v23, v24, v25, v26, v28);
    uint64_t v27 = (os_log_s *)sub_100086554(0x45u);
    if (os_log_type_enabled(v27, OS_LOG_TYPE_ERROR)) {
      sub_100657F74();
    }
  }

void sub_1001C260C(uint64_t a1, uint64_t a2)
{
  if (sub_1000A86F0())
  {
    sub_1001EE134((uint64_t)"_GATT_LE_DisconnectedCB on handle %p with reason %!", v4, v5, v6, v7, v8, v9, v10, a1);
    uint64_t v11 = (os_log_s *)sub_100086554(0x45u);
    if (os_log_type_enabled(v11, OS_LOG_TYPE_DEFAULT))
    {
      *(_DWORD *)buf = 136446210;
      uint64_t v21 = sub_1001EDDCC();
      _os_log_impl((void *)&_mh_execute_header, v11, OS_LOG_TYPE_DEFAULT, " %{public}s", buf, 0xCu);
    }
  }

  if (a1)
  {
    if (*((void *)&xmmword_1008ECEF0 + 1)) {
      (*((void (**)(uint64_t, uint64_t))&xmmword_1008ECEF0 + 1))(a1, a2);
    }
  }

  else if (sub_1000A86F0())
  {
    sub_1001EE134( (uint64_t)"_GATT_LE_DisconnectedCB handle is not valid with reason %!",  v12,  v13,  v14,  v15,  v16,  v17,  v18,  a2);
    uint64_t v19 = (os_log_s *)sub_100086554(0x45u);
    if (os_log_type_enabled(v19, OS_LOG_TYPE_ERROR)) {
      sub_100657F74();
    }
  }

void sub_1001C273C(unsigned __int16 *a1, uint64_t a2, uint64_t a3, int a4)
{
  if (sub_1000A86F0())
  {
    uint64_t v15 = a1 ? *a1 : 0LL;
    sub_1001EE134( (uint64_t)"_GATT_LE_LinkReadyCB notification from lmHandle 0x%x with status %!",  v8,  v9,  v10,  v11,  v12,  v13,  v14,  v15);
    uint64_t v16 = (os_log_s *)sub_100086554(0x45u);
    if (os_log_type_enabled(v16, OS_LOG_TYPE_DEFAULT))
    {
      *(_DWORD *)buf = 136446210;
      uint64_t v27 = sub_1001EDDCC();
      _os_log_impl((void *)&_mh_execute_header, v16, OS_LOG_TYPE_DEFAULT, " %{public}s", buf, 0xCu);
    }
  }

  if (a4)
  {
    if (sub_1000A86F0())
    {
      if (a1) {
        uint64_t v24 = *a1;
      }
      else {
        uint64_t v24 = 0LL;
      }
      sub_1001EE134( (uint64_t)"GATT ready notification from lmHandle 0x%x (%x) with error %!",  v17,  v18,  v19,  v20,  v21,  v22,  v23,  v24);
      uint64_t v25 = (os_log_s *)sub_100086554(0x45u);
      if (os_log_type_enabled(v25, OS_LOG_TYPE_ERROR)) {
        sub_100657F74();
      }
    }
  }

  else if (off_1008ECF00)
  {
    off_1008ECF00(a1, a2, a3, 0LL);
  }

void sub_1001C28A8(uint64_t a1)
{
  uint64_t v1 = (void *)qword_1008ECEE0;
  if (qword_1008ECEE0)
  {
    while (1)
    {
      uint64_t v2 = v1[12];
      if (*v1 == a1) {
        break;
      }
      uint64_t v1 = (void *)v1[12];
      if (!v2) {
        return;
      }
    }

    if (v2) {
      *(void *)(v2 + 104) = v1[13];
    }
    uint64_t v3 = v1[13];
    if (v3) {
      uint64_t v4 = (uint64_t *)(v3 + 96);
    }
    else {
      uint64_t v4 = &qword_1008ECEE0;
    }
    *uint64_t v4 = v2;
    uint64_t v5 = (void *)v1[10];
    if (v5) {
      sub_1000B1838(v5);
    }
    v1[10] = 0LL;
    *((_WORD *)v1 + 44) = 0;
    sub_1000B1838(v1);
  }

BOOL sub_1001C2930(uint64_t a1)
{
  unint64_t v1 = *(unsigned __int16 *)(a1 + 88);
  if (!*(_WORD *)(a1 + 88)) {
    return 0LL;
  }
  uint64_t v3 = *(void (**)(void))(a1 + 16);
  uint64_t v4 = *(void *)(a1 + 80);
  if (*(_BYTE *)(v4 + 8))
  {
    unint64_t v5 = 0LL;
    uint64_t v6 = (unsigned __int8 *)(v4 + 36);
    while (v1 - 1 != v5)
    {
      int v7 = *v6;
      v6 += 28;
      ++v5;
      if (!v7)
      {
        BOOL v8 = v5 < v1;
        goto LABEL_9;
      }
    }

    return 0LL;
  }

  unint64_t v5 = 0LL;
  BOOL v8 = 1LL;
LABEL_9:
  __int16 v9 = *(_WORD *)(v4 + 28 * v5 + 2);
  char v11 = 10;
  __int16 v12 = v9;
  if (sub_1001A2E80(*(void *)a1, (uint64_t)sub_1001C2A24, (uint64_t)&v11, a1))
  {
    if (v3)
    {
      *(void *)(a1 + 16) = 0LL;
      v3();
    }
  }

  else
  {
    *(void *)(a1 + 32) = 0LL;
    *(void *)(a1 + 40) = 0LL;
    *(_DWORD *)(a1 + 48) = 0;
    *(_WORD *)(a1 + 52) = v9;
    *(_WORD *)(a1 + 54) = v5;
    *(void *)(a1 + 64) = 0LL;
    *(void *)(a1 + 72) = 0LL;
    *(void *)(a1 + 56) = 0LL;
  }

  return v8;
}

void sub_1001C2A24(uint64_t a1, uint64_t a2, int8x16_t *a3, uint64_t a4, uint64_t a5)
{
  BOOL v8 = &qword_1008ECEE0;
  do
  {
    uint64_t v9 = *v8;
    BOOL v8 = (uint64_t *)(*v8 + 96);
  }

  while (v9 != a5 && v9 != 0);
  if (!v9) {
    return;
  }
  char v11 = *(void (**)(uint64_t, uint64_t, uint64_t, uint64_t))(a5 + 16);
  if ((_DWORD)a2 == 10)
  {
    if ((sub_1001C2930(a5) & 1) == 0 && v11)
    {
      __int16 v12 = (_WORD *)(a5 + 88);
      uint64_t v27 = *(unsigned __int16 *)(a5 + 88);
      *(void *)(a5 + 16) = 0LL;
      v11(0LL, *(void *)(a5 + 80), v27, *(void *)(a5 + 24));
      uint64_t v28 = *(void **)(a5 + 80);
      if (!v28) {
        goto LABEL_38;
      }
      goto LABEL_37;
    }

    return;
  }

  if ((_DWORD)a2)
  {
    if (sub_1000A86F0()
      && (sub_1001EE134( (uint64_t)"Received error response for included service discovery 0x%x",  v29,  v30,  v31,  v32,  v33,  v34,  v35,  a2),  uint64_t v36 = (os_log_s *)sub_100086554(0x45u),  os_log_type_enabled(v36, OS_LOG_TYPE_ERROR)))
    {
      sub_100657858();
      if (!v11) {
        return;
      }
    }

    else if (!v11)
    {
      return;
    }

    *(void *)(a5 + 16) = 0LL;
    v11(a2, 0LL, 0LL, *(void *)(a5 + 24));
    unsigned __int16 v37 = *(void **)(a5 + 80);
    if (v37) {
      sub_1000B1838(v37);
    }
    *(void *)(a5 + 80) = 0LL;
    __int16 v12 = (_WORD *)(a5 + 88);
    goto LABEL_39;
  }

  __int16 v12 = (_WORD *)(a5 + 88);
  uint64_t v13 = *(unsigned __int16 *)(a5 + 54);
  if (*(unsigned __int16 *)(a5 + 88) <= v13)
  {
    sub_1001EE134((uint64_t)"Invalid position %d / %d", v38, v39, v40, v41, v42, v43, v44, v13);
    uint64_t v45 = (os_log_s *)sub_100086554(0x45u);
    if (!os_log_type_enabled(v45, OS_LOG_TYPE_ERROR)) {
      goto LABEL_32;
    }
    goto LABEL_31;
  }

  uint64_t v14 = *(unsigned __int16 *)(a5 + 52);
  uint64_t v15 = *(void *)(a5 + 80);
  if (*(unsigned __int16 *)(v15 + 28LL * *(unsigned __int16 *)(a5 + 54) + 2) != (_DWORD)v14)
  {
    sub_1001EE134((uint64_t)"Handles don't match 0x%x 0x%x", v46, v47, v48, v49, v50, v51, v52, v14);
    uint64_t v53 = (os_log_s *)sub_100086554(0x45u);
    if (!os_log_type_enabled(v53, OS_LOG_TYPE_ERROR)) {
      goto LABEL_32;
    }
    goto LABEL_31;
  }

  uint64_t v16 = v15 + 28LL * *(unsigned __int16 *)(a5 + 54);
  int v18 = *(unsigned __int8 *)(v16 + 8);
  uint64_t v17 = v16 + 8;
  if (!v18)
  {
    if ((_DWORD)a4 == 2 || (_DWORD)a4 == 16)
    {
      sub_1001BEE18(a3, a4, 1, (uint64_t)&v75);
      __int128 v65 = v75;
      *(_DWORD *)(v17 + 16) = v76;
      *(_OWORD *)uint64_t v17 = v65;
      goto LABEL_44;
    }

    if (!sub_1000A86F0()
      || (sub_1001EE134((uint64_t)"Invalid length %d", v66, v67, v68, v69, v70, v71, v72, a4),
          uint64_t v73 = (os_log_s *)sub_100086554(0x45u),
          !os_log_type_enabled(v73, OS_LOG_TYPE_ERROR)))
    {
LABEL_32:
      if (sub_1000A86F0()
        && (sub_1001EE134((uint64_t)"Error parsing the read response", v54, v55, v56, v57, v58, v59, v60, v74),
            uint64_t v61 = (os_log_s *)sub_100086554(0x45u),
            os_log_type_enabled(v61, OS_LOG_TYPE_ERROR)))
      {
        sub_100657858();
        if (!v11) {
          return;
        }
      }

      else if (!v11)
      {
        return;
      }

      *(void *)(a5 + 16) = 0LL;
      uint64_t v62 = *(void *)(a5 + 24);
      uint64_t v63 = 0LL;
      uint64_t v64 = 0LL;
LABEL_36:
      v11(0LL, v63, v64, v62);
      uint64_t v28 = *(void **)(a5 + 80);
      if (!v28)
      {
LABEL_38:
        *(void *)(a5 + 80) = 0LL;
LABEL_39:
        *__int16 v12 = 0;
        return;
      }

uint64_t sub_1001C2DB4(uint64_t a1, uint64_t a2, unsigned int a3, int a4)
{
  uint64_t v8 = a3;
  size_t v9 = 260LL * a3;
  __chkstk_darwin(a1, a2);
  char v11 = (char *)&v21 - v10;
  bzero((char *)&v21 - v10, v9);
  if (a3)
  {
    size_t v12 = a4 - 2;
    uint64_t v13 = (const void **)(a2 + 8);
    uint64_t v14 = v8;
    uint64_t v15 = v11;
    do
    {
      uint64_t v16 = *((unsigned __int16 *)v13 - 4);
      _WORD *v15 = v16;
      v15[129] = v12;
      uint64_t v17 = *v13;
      v13 += 2;
      memmove(v15 + 1, v17, v12);
      v15 += 130;
      --v14;
    }

    while (v14);
    if (!a1) {
      return v16;
    }
  }

  else
  {
    uint64_t v16 = 0xFFFFLL;
    if (!a1) {
      return v16;
    }
  }

  int v18 = *(void **)(a1 + 80);
  uint64_t v19 = (char *)sub_1000B17F4(260 * (*(unsigned __int16 *)(a1 + 88) + v8));
  *(void *)(a1 + 80) = v19;
  if (!v19) {
    return 0xFFFFLL;
  }
  if (v18)
  {
    memmove(v19, v18, 260LL * *(unsigned __int16 *)(a1 + 88));
    sub_1000B1838(v18);
    uint64_t v19 = *(char **)(a1 + 80);
  }

  memmove(&v19[260 * *(unsigned __int16 *)(a1 + 88)], v11, v9);
  *(_WORD *)(a1 + 88) += a3;
  return v16;
}

void sub_1001C2F34(uint64_t a1, uint64_t a2, void *a3)
{
  uint64_t v4 = &qword_1008ECEE0;
  do
  {
    unint64_t v5 = (void *)*v4;
    uint64_t v4 = (uint64_t *)(*v4 + 96);
  }

  while (v5 != a3 && v5 != 0LL);
  if (v5)
  {
    int v7 = (void (*)(void, void))a3[2];
    a3[2] = 0LL;
    if (v7) {
      v7(*(unsigned __int8 *)(*a3 + 96LL), a3[3]);
    }
    uint64_t v8 = (void *)a3[8];
    if (v8)
    {
      sub_1000B1838(v8);
      a3[8] = 0LL;
    }
  }

void sub_1001C2F9C(uint64_t a1, uint64_t a2, void *a3)
{
  uint64_t v4 = &qword_1008ECEE0;
  do
  {
    unint64_t v5 = (void *)*v4;
    uint64_t v4 = (uint64_t *)(*v4 + 96);
  }

  while (v5 != a3 && v5 != 0LL);
  if (v5)
  {
    int v7 = (void (*)(uint64_t, void))a3[2];
    a3[2] = 0LL;
    if (v7) {
      v7(a2, a3[3]);
    }
    uint64_t v8 = (void *)a3[8];
    if (v8) {
      sub_1000B1838(v8);
    }
  }

const char *sub_1001C3008(char a1)
{
  else {
    return off_100886010[(char)(a1 + 1)];
  }
}

void sub_1001C3038(uint64_t a1, uint64_t a2)
{
  __int16 v12 = 0;
  int v11 = 0;
  if (sub_10010EF78(a2, (uint64_t)&v11))
  {
    if (sub_1000A86F0())
    {
      sub_1001EE134((uint64_t)"Could not get address", v2, v3, v4, v5, v6, v7, v8, v10);
      size_t v9 = (os_log_s *)sub_100086554(0x55u);
      if (os_log_type_enabled(v9, OS_LOG_TYPE_ERROR)) {
        sub_100657858();
      }
    }
  }

  else
  {
    sub_1001C30B8((uint64_t)&v11);
  }

uint64_t sub_1001C30B8(uint64_t result)
{
  uint64_t v1 = result;
  for (uint64_t i = 0LL; i != 294; i += 42LL)
  {
    uint64_t v3 = &qword_1008ECF08[i];
    if (LOBYTE(qword_1008ECF08[i + 2]))
    {
      int v4 = *(_DWORD *)((char *)v3 + 17);
      int v5 = *(unsigned __int16 *)((char *)v3 + 21);
      if (*(_DWORD *)v1 == v4 && *(unsigned __int16 *)(v1 + 4) == v5)
      {
        __n128 result = LODWORD(qword_1008ECF08[i + 3]);
        if ((_DWORD)result) {
          __n128 result = sub_1001EEB14(result);
        }
        *(_OWORD *)&qword_1008ECF08[i + 40] = 0u;
        *(_OWORD *)&qword_1008ECF08[i + 42] = 0u;
        *(_OWORD *)&qword_1008ECF08[i + 36] = 0u;
        *(_OWORD *)&qword_1008ECF08[i + 38] = 0u;
        *(_OWORD *)&qword_1008ECF08[i + 32] = 0u;
        *(_OWORD *)&qword_1008ECF08[i + 34] = 0u;
        *(_OWORD *)&qword_1008ECF08[i + 28] = 0u;
        *(_OWORD *)&qword_1008ECF08[i + 30] = 0u;
        *(_OWORD *)&qword_1008ECF08[i + 24] = 0u;
        *(_OWORD *)&qword_1008ECF08[i + 26] = 0u;
        *(_OWORD *)&qword_1008ECF08[i + 20] = 0u;
        *(_OWORD *)&qword_1008ECF08[i + 22] = 0u;
        *(_OWORD *)&qword_1008ECF08[i + 16] = 0u;
        *(_OWORD *)&qword_1008ECF08[i + 18] = 0u;
        *(_OWORD *)&qword_1008ECF08[i + 12] = 0u;
        *(_OWORD *)&qword_1008ECF08[i + 14] = 0u;
        *(_OWORD *)&qword_1008ECF08[i + 8] = 0u;
        *(_OWORD *)&qword_1008ECF08[i + 10] = 0u;
        *(_OWORD *)&qword_1008ECF08[i + 4] = 0u;
        *(_OWORD *)&qword_1008ECF08[i + 6] = 0u;
        *(_OWORD *)&qword_1008ECF08[i + 2] = 0u;
      }
    }
  }

  return result;
}

uint64_t sub_1001C3160(uint64_t a1)
{
  qword_1008ECF08 = a1;
  return 0LL;
}

uint64_t sub_1001C3170(uint64_t a1, uint64_t a2)
{
  uint64_t v3 = sub_1001C31E0(a1);
  uint64_t v4 = 0LL;
  if (v3 && byte_1008ED848)
  {
    if (*((unsigned __int8 *)v3 + 7) == 240)
    {
      int v5 = *(_DWORD *)((char *)v3 + 1);
      *(_WORD *)(a2 + 4) = *(_WORD *)((char *)v3 + 5);
      *(_DWORD *)a2 = v5;
      *(_DWORD *)(a2 + 24) = 5;
      *(_OWORD *)(a2 + 6) = *(_OWORD *)((char *)v3 + 12);
      return 1LL;
    }

    else
    {
      return 0LL;
    }
  }

  return v4;
}

uint64_t *sub_1001C31E0(uint64_t a1)
{
  uint64_t v1 = 0LL;
  while (1)
  {
    uint64_t v2 = &qword_1008ECF08[v1];
    if (LOBYTE(qword_1008ECF08[v1 + 2]))
    {
      int v3 = *(_DWORD *)((char *)v2 + 17);
      int v4 = *(unsigned __int16 *)((char *)v2 + 21);
    }

    v1 += 42LL;
    if (v1 == 294) {
      return 0LL;
    }
  }

  return &qword_1008ECF08[v1 + 2];
}

BOOL sub_1001C3234(uint64_t a1)
{
  if (!byte_1008ED848) {
    goto LABEL_19;
  }
  if (*(_DWORD *)a1 != *(_DWORD *)qword_1008ED850
    || *(unsigned __int16 *)(a1 + 4) != *(unsigned __int16 *)(qword_1008ED850 + 4))
  {
    uint64_t v2 = 0LL;
    uint64_t v3 = qword_1008ED850 + 44;
    while (byte_1008ED848 - 1LL != v2)
    {
      BOOL v4 = *(_DWORD *)a1 == *(_DWORD *)v3 && *(unsigned __int16 *)(a1 + 4) == *(unsigned __int16 *)(v3 + 4);
      v3 += 44LL;
      ++v2;
      if (v4) {
        goto LABEL_15;
      }
    }

    goto LABEL_19;
  }

uint64_t *sub_1001C33FC(uint64_t a1)
{
  __n128 result = sub_1001C31E0(a1);
  if (!result)
  {
    for (uint64_t i = 0LL; i != 294; i += 42LL)
    {
      BOOL v4 = &qword_1008ECF08[i];
      if (!LOBYTE(qword_1008ECF08[i + 2]))
      {
        int v13 = *(_DWORD *)a1;
        __int16 v14 = *(_WORD *)(a1 + 4);
        *((_BYTE *)v4 + 16) = 1;
        __n128 result = v4 + 2;
        *(_WORD *)((char *)result + 5) = v14;
        *(_DWORD *)((char *)result + 1) = v13;
        return result;
      }
    }

    if (sub_1000A86F0())
    {
      sub_1001EE134( (uint64_t)"No magic pairing slot available to allocate for address %:",  v5,  v6,  v7,  v8,  v9,  v10,  v11,  a1);
      uint64_t v12 = (os_log_s *)sub_100086554(0x55u);
      if (os_log_type_enabled(v12, OS_LOG_TYPE_ERROR)) {
        sub_100657858();
      }
    }

    return 0LL;
  }

  return result;
}

const char *sub_1001C34B0(int a1)
{
  __n128 result = "STATE_IDLE";
  switch(a1)
  {
    case 0:
      return result;
    case 1:
      __n128 result = "STATE_CHANNEL_FOUND";
      break;
    case 2:
      __n128 result = "STATE_SENT_HINT";
      break;
    case 3:
      __n128 result = "STATE_SENT_AES_SIV";
      break;
    default:
      BOOL v4 = "STATE_ERROR";
      if (a1 != 255) {
        BOOL v4 = "UNKNOWN";
      }
      if (a1 == 240) {
        __n128 result = "STATE_SUCCESS";
      }
      else {
        __n128 result = v4;
      }
      break;
  }

  return result;
}

void sub_1001C3530(uint64_t a1)
{
  uint64_t v2 = sub_10012D890(a1);
  sub_10018A690(v2);
  uint64_t v3 = sub_1001C33FC(a1);
  if (v3)
  {
    uint64_t v4 = (uint64_t)v3;
    if (!*((_BYTE *)v3 + 7))
    {
      sub_1001C3588(a1, 1);
      sub_1001C3604(v4);
    }
  }

void sub_1001C3588(uint64_t a1, char a2)
{
  uint64_t v4 = sub_1001C31E0(a1);
  if (v4)
  {
    *((_BYTE *)v4 + 7) = a2;
  }

  else if (sub_1000A86F0())
  {
    sub_1001EE134((uint64_t)" %: does not have a magic pairing device entry", v5, v6, v7, v8, v9, v10, v11, a1);
    uint64_t v12 = (os_log_s *)sub_100086554(0x55u);
    if (os_log_type_enabled(v12, OS_LOG_TYPE_ERROR)) {
      sub_100657858();
    }
  }

void sub_1001C3604(uint64_t a1)
{
  if (*(unsigned __int8 *)(a1 + 7) - 2 > 0xEE)
  {
    uint64_t v10 = byte_1008ED848;
    if (byte_1008ED848)
    {
      uint64_t v11 = 0LL;
      *(_BYTE *)(a1 + 269) = 0;
      uint64_t v12 = (_DWORD *)(a1 + 1);
      uint64_t v13 = qword_1008ED850;
      while (*v12 != *(_DWORD *)v13 || *(unsigned __int16 *)(a1 + 5) != *(unsigned __int16 *)(v13 + 4))
      {
        ++v11;
        v13 += 44LL;
        if (v10 == v11)
        {
          if (sub_1000A86F0())
          {
            sub_1001EE134((uint64_t)"No hint for device %:. Aborting", v15, v16, v17, v18, v19, v20, v21, a1 + 1);
            uint64_t v22 = (os_log_s *)sub_100086554(0x55u);
            if (os_log_type_enabled(v22, OS_LOG_TYPE_ERROR)) {
              sub_100657858();
            }
          }

          goto LABEL_19;
        }
      }

      *(_BYTE *)(a1 + 269) = v11;
      uint64_t v31 = (__int128 *)(a1 + 28);
      arc4random_buf((void *)(a1 + 28), 0x10uLL);
      arc4random_buf((void *)(a1 + 270), 0x10uLL);
      *(void *)uint64_t v52 = 6LL;
      *(void *)&v52[8] = a1 + 1;
      uint64_t v32 = sub_1001EE6E8((uint64_t)sub_1001C4984, (const void **)v52, 25, (int *)(a1 + 8));
      if ((_DWORD)v32)
      {
        uint64_t v33 = v32;
        if (sub_1000A86F0())
        {
          sub_1001EE134( (uint64_t)"Could not register timeout for magic pairing operation ret=%!",  v34,  v35,  v36,  v37,  v38,  v39,  v40,  v33);
          uint64_t v41 = (os_log_s *)sub_100086554(0x55u);
          if (os_log_type_enabled(v41, OS_LOG_TYPE_ERROR)) {
            sub_100657858();
          }
        }
      }

      if (*(unsigned __int8 *)(a1 + 7) >= 2u)
      {
        if (sub_1000A86F0())
        {
          sub_1001EE134( (uint64_t)"Invalid state %d trying to send address: %:",  v42,  v43,  v44,  v45,  v46,  v47,  v48,  *(unsigned __int8 *)(a1 + 7));
          uint64_t v49 = (os_log_s *)sub_100086554(0x55u);
          if (os_log_type_enabled(v49, OS_LOG_TYPE_ERROR)) {
            sub_100657858();
          }
        }
      }

      __int16 v57 = 0;
      *(_DWORD *)uint64_t v52 = 268439555;
      v52[4] = 0;
      uint64_t v50 = qword_1008ED850 + 44LL * *(unsigned __int8 *)(a1 + 269);
      *(_OWORD *)&v52[5] = *(_OWORD *)(v50 + 6);
      int v53 = 1048608;
      __int128 v54 = *v31;
      int v55 = 262400;
      int v56 = *(_DWORD *)(v50 + 40);
    }

    else
    {
      if (sub_1000A86F0())
      {
        sub_1001EE134((uint64_t)"No MagicPairing table found", v23, v24, v25, v26, v27, v28, v29, v51);
        uint64_t v30 = (os_log_s *)sub_100086554(0x55u);
        if (os_log_type_enabled(v30, OS_LOG_TYPE_ERROR)) {
          sub_100657F08();
        }
      }

      uint64_t v12 = (_DWORD *)(a1 + 1);
LABEL_19:
      sub_1001C3588((uint64_t)v12, 255);
      if (*(_BYTE *)(a1 + 334)) {
        sub_1001C4510((uint64_t)v12, 8LL);
      }
      *(_BYTE *)(a1 + 334) = 0;
    }
  }

  else if (sub_1000A86F0())
  {
    sub_1001EE134( (uint64_t)"MagicPairing is currently in progress (%x) with device %:",  v2,  v3,  v4,  v5,  v6,  v7,  v8,  *(unsigned __int8 *)(a1 + 7));
    uint64_t v9 = (os_log_s *)sub_100086554(0x55u);
    if (os_log_type_enabled(v9, OS_LOG_TYPE_ERROR)) {
      sub_100657F08();
    }
  }

uint64_t sub_1001C3914(uint64_t a1, char a2)
{
  qword_1008ED850 = a1;
  byte_1008ED848 = a2;
  return 0LL;
}

uint64_t sub_1001C392C(uint64_t a1, uint64_t a2)
{
  v6[0] = 0LL;
  v6[1] = 0LL;
  uint64_t v4 = ccaes_ecb_encrypt_mode();
  else {
    return 0LL;
  }
}

uint64_t sub_1001C39B0()
{
  uint64_t v0 = sub_1001732EC(0x30u, 1, 8, 7u, &qword_1008ECF10, (uint64_t)sub_1001C3B90);
  if ((_DWORD)v0)
  {
    uint64_t v1 = v0;
    if (sub_1000A86F0())
    {
      sub_1001EE134((uint64_t)"OI_ChanMan_AllocateFixedChannel returned %!", v2, v3, v4, v5, v6, v7, v8, v1);
      uint64_t v9 = (os_log_s *)sub_100086554(0x55u);
      if (os_log_type_enabled(v9, OS_LOG_TYPE_ERROR)) {
LABEL_16:
      }
        sub_100657858();
    }
  }

  else
  {
    **(_WORD **)(qword_1008ECF10 + 120) = 100;
    uint64_t v10 = sub_1001E6B70(nullsub_78);
    if ((_DWORD)v10)
    {
      uint64_t v1 = v10;
      if (sub_1000A86F0())
      {
        sub_1001EE134((uint64_t)"OI_SECMGR_RegisterAuditCb returned %!", v11, v12, v13, v14, v15, v16, v17, v1);
        uint64_t v18 = (os_log_s *)sub_100086554(0x55u);
        if (os_log_type_enabled(v18, OS_LOG_TYPE_ERROR)) {
          goto LABEL_16;
        }
      }
    }

    else
    {
      uint64_t v19 = sub_100179804((uint64_t)sub_1001C3530, 48);
      if ((_DWORD)v19)
      {
        uint64_t v1 = v19;
        if (sub_1000A86F0())
        {
          sub_1001EE134( (uint64_t)"OI_ConnectMan_Register_FixedChannelInfo_callback returned %!",  v20,  v21,  v22,  v23,  v24,  v25,  v26,  v1);
          uint64_t v27 = (os_log_s *)sub_100086554(0x55u);
          if (os_log_type_enabled(v27, OS_LOG_TYPE_ERROR)) {
            goto LABEL_16;
          }
        }
      }

      else
      {
        uint64_t v1 = sub_10010EBE0((uint64_t)&unk_1008D8EB8);
        if (!(_DWORD)v1)
        {
          bzero(qword_1008ECF08, 0x940uLL);
          byte_1008ED848 = 0;
          qword_1008ED850 = 0LL;
          return v1;
        }

        if (sub_1000A86F0())
        {
          sub_1001EE134( (uint64_t)"OI_DEVMGR_EXTRA_Register_Connect_CB returned %!",  v28,  v29,  v30,  v31,  v32,  v33,  v34,  v1);
          uint64_t v35 = (os_log_s *)sub_100086554(0x55u);
          if (os_log_type_enabled(v35, OS_LOG_TYPE_ERROR)) {
            goto LABEL_16;
          }
        }
      }
    }
  }

  return v1;
}

void sub_1001C3B90(uint64_t a1, unsigned __int8 *a2, unsigned int a3)
{
  unsigned __int16 v3 = a3 - 2;
  if (a3 < 2) {
    return;
  }
  __int16 v140 = 0;
  int v139 = 0;
  int v6 = *a2;
  switch(*a2)
  {
    case 1u:
      uint64_t v7 = sub_10012D890((uint64_t)&v139);
      sub_10018A690(v7);
      uint64_t v8 = sub_1001C31E0((uint64_t)&v139);
      if (!v8) {
        sub_1001EE2A0();
      }
      *(_WORD *)buf = 384;
      buf[2] = 104;
      memset(&buf[3], 0, 105);
      sub_1001C4610((uint64_t)v8 + 1, 2u, (char *)buf, 0x6CuLL);
      return;
    case 2u:
      uint64_t v11 = (char *)sub_1001C31E0((uint64_t)&v139);
      if (!v11)
      {
        if (sub_1000A86F0())
        {
          sub_1001EE134( (uint64_t)" %: does not have a magic pairing device entry",  v55,  v56,  v57,  v58,  v59,  v60,  v61,  (uint64_t)&v139);
          uint64_t v62 = (os_log_s *)sub_100086554(0x55u);
          if (os_log_type_enabled(v62, OS_LOG_TYPE_ERROR)) {
            sub_100657858();
          }
        }

        uint64_t v63 = 8LL;
        goto LABEL_71;
      }

      if (!v3) {
        sub_1000E6B88( "/Library/Caches/com.apple.xbs/Sources/MobileBluetooth_base/Stack/corestack/magicPairing/BT_MagicPairing.c",  823,  "(length) > 0");
      }
      uint64_t v12 = a2 + 2;
      uint64_t v13 = a2[2];
      if ((_DWORD)v13 != 2)
      {
        if (sub_1000A86F0())
        {
          sub_1001EE134((uint64_t)"Invalid number of paramerter = %d", v64, v65, v66, v67, v68, v69, v70, v13);
          uint64_t v71 = (os_log_s *)sub_100086554(0x55u);
          if (os_log_type_enabled(v71, OS_LOG_TYPE_ERROR)) {
            sub_100657858();
          }
        }

        uint64_t v63 = 3LL;
        goto LABEL_71;
      }

      uint64_t v14 = (uint64_t)v11;
      unsigned __int16 v15 = a3 - 3;
      int v16 = v3 - 53;
      int v17 = v3 - 3;
      uint64_t v18 = v11 + 168;
      int v19 = 2;
      int v20 = 1;
      do
      {
        if (v15 <= (unsigned __int16)v20) {
          sub_1000E6B88( "/Library/Caches/com.apple.xbs/Sources/MobileBluetooth_base/Stack/corestack/magicPairing/BT_MagicPairing.c",  837,  "ByteStream_NumReadBytesAvail(bs) >= 2");
        }
        if (v15 <= (unsigned __int16)(v20 + 2)) {
          sub_1000E6B88( "/Library/Caches/com.apple.xbs/Sources/MobileBluetooth_base/Stack/corestack/magicPairing/BT_MagicPairing.c",  838,  "ByteStream_NumReadBytesAvail(bs) >= 2");
        }
        int v21 = *(unsigned __int16 *)&v12[(unsigned __int16)v20];
        uint64_t v22 = &v12[(unsigned __int16)(v20 + 2)];
        int v23 = *v22;
        int v24 = v23 | (v22[1] << 8);
        int v25 = v20 + 4;
        if (v21 == 128)
        {
          if (v24 != 54)
          {
            if (sub_1000A86F0())
            {
              sub_1001EE134( (uint64_t)"ERROR AES_SIV key length mismatch, please file a sysdiagnose from all cloud paired devices",  v85,  v86,  v87,  v88,  v89,  v90,  v91,  v137);
              uint64_t v92 = (os_log_s *)sub_100086554(0x55u);
              if (os_log_type_enabled(v92, OS_LOG_TYPE_FAULT)) {
                sub_10065C8E4(v92);
              }
            }

            goto LABEL_70;
          }

          if (v16 <= (unsigned __int16)v25) {
            sub_1000E6B88( "/Library/Caches/com.apple.xbs/Sources/MobileBluetooth_base/Stack/corestack/magicPairing/BT_MagicPairing.c",  852,  "ByteStream_NumReadBytesAvail(bs) >= (keySize)");
          }
          uint64_t v11 = (char *)memmove(v18, &v12[(unsigned __int16)v25], 0x36uLL);
          v20 += 58;
          *(_BYTE *)(v14 + 268) = v23;
        }

        else if (v21 == 256)
        {
          if (v24 != 4) {
            sub_1001EE2A0();
          }
          if (v17 <= (unsigned __int16)v25) {
            sub_1000E6B88( "/Library/Caches/com.apple.xbs/Sources/MobileBluetooth_base/Stack/corestack/magicPairing/BT_MagicPairing.c",  843,  "ByteStream_NumReadBytesAvail(bs) >= 4");
          }
          *(_DWORD *)(v14 + 164) = *(_DWORD *)&v12[(unsigned __int16)(v20 + 4)];
          v20 += 8;
        }

        else
        {
          if (sub_1000A86F0())
          {
            sub_1001EE134((uint64_t)"Invalid opcode %x", v26, v27, v28, v29, v30, v31, v32, v137);
            uint64_t v33 = (os_log_s *)sub_100086554(0x55u);
            if (os_log_type_enabled(v33, OS_LOG_TYPE_ERROR))
            {
              uint64_t v34 = sub_1001EDDCC();
              *(_DWORD *)buf = 136446466;
              *(void *)&uint8_t buf[4] = v34;
              *(_WORD *)&buf[12] = 1024;
              *(_DWORD *)&buf[14] = 0xFFFF;
              _os_log_error_impl( (void *)&_mh_execute_header,  v33,  OS_LOG_TYPE_ERROR,  "%{public}s (status=%{bluetooth:OI_STATUS}u)",  buf,  0x12u);
            }
          }

          uint64_t v11 = (char *)sub_1001C4510((uint64_t)&v139, 3LL);
          int v20 = v25;
        }

        --v19;
      }

      while ((_BYTE)v19);
      uint64_t v72 = (__int128 *)(qword_1008ED850 + 44LL * *(unsigned __int8 *)(v14 + 269));
      __int128 v74 = *v72;
      __int128 v73 = v72[1];
      *(_OWORD *)&v144[12] = *(__int128 *)((char *)v72 + 28);
      __int128 v143 = v74;
      *(_OWORD *)v144 = v73;
      if (*(_DWORD *)&v144[24] < *(_DWORD *)(v14 + 164))
      {
        while (1)
        {
          __int128 v142 = 0uLL;
          *(void *)buf = 0LL;
          *(void *)&buf[8] = 0LL;
          uint64_t v75 = ccaes_ecb_encrypt_mode(v11);
          uint64_t v11 = (char *)ccecb_one_shot(v75, 16LL, &v144[6], 1LL, buf, &v142);
          if ((_DWORD)v11) {
            break;
          }
          *(_OWORD *)&v144[6] = v142;
          if (++*(_DWORD *)&v144[24] >= *(_DWORD *)(v14 + 164)) {
            goto LABEL_56;
          }
        }

        if (sub_1000A86F0())
        {
          sub_1001EE134((uint64_t)"Error generating RatchetAccKey: %!", v106, v107, v108, v109, v110, v111, v112, 154LL);
          v113 = (os_log_s *)sub_100086554(0x55u);
          if (os_log_type_enabled(v113, OS_LOG_TYPE_ERROR)) {
LABEL_69:
          }
            sub_100657858();
        }

        goto LABEL_70;
      }

uint64_t sub_1001C43F0(uint64_t a1, uint64_t a2, uint64_t a3, unint64_t a4)
{
  if (a4 < 0x10) {
    return 101LL;
  }
  uint64_t v8 = ccaes_ecb_decrypt_mode();
  else {
    return 0LL;
  }
}

uint64_t sub_1001C4454(uint64_t a1, uint64_t a2, uint64_t a3, unint64_t a4)
{
  if (a4 < 0x10) {
    return 101LL;
  }
  uint64_t v8 = ccaes_ecb_encrypt_mode();
  else {
    return 0LL;
  }
}

uint64_t sub_1001C44B8()
{
  qword_1008ECF08[0] = 0LL;
  sub_100179864((uint64_t)sub_1001C3530);
  if (qword_1008ECF10) {
    sub_1001734D8(qword_1008ECF10);
  }
  uint64_t v0 = &dword_100000010 + 1;
  do
  {
    sub_1001C30B8((uint64_t)qword_1008ECF08 + v0);
    v0 += 336LL;
  }

  while (v0 != 2369);
  return 0LL;
}

uint64_t *sub_1001C4510(uint64_t a1, uint64_t a2)
{
  char v14 = a2;
  if (sub_1000A86F0())
  {
    uint64_t v4 = sub_1001C3008(a2);
    sub_1001EE134((uint64_t)"Sending status %s(%d) to device %:", v5, v6, v7, v8, v9, v10, v11, (uint64_t)v4);
    uint64_t v12 = (os_log_s *)sub_100086554(0x55u);
    if (os_log_type_enabled(v12, OS_LOG_TYPE_DEFAULT))
    {
      *(_DWORD *)buf = 136446210;
      int v16 = sub_1001EDDCC();
      _os_log_impl((void *)&_mh_execute_header, v12, OS_LOG_TYPE_DEFAULT, " %{public}s", buf, 0xCu);
    }
  }

  sub_1001C4610(a1, 0xFFu, &v14, 1uLL);
  return sub_1001C476C(a1, a2);
}

uint64_t sub_1001C4610(uint64_t a1, unsigned int a2, char *a3, size_t a4)
{
  int v23 = 0LL;
  v22[0] = a2;
  v22[1] = 1;
  int v7 = sub_10010EEE0(a1, (uint64_t *)&v23);
  uint64_t result = 101LL;
  if (v7 || !v23) {
    return result;
  }
  memset(&v21[1], 0, 96);
  if (a3) {
    unsigned int v9 = 2;
  }
  else {
    unsigned int v9 = 1;
  }
  v21[0] = 0uLL;
  uint64_t v10 = sub_1001EF520((uint64_t)v21, v9);
  if ((_DWORD)v10)
  {
    uint64_t v11 = v10;
LABEL_10:
    if (sub_1000A86F0())
    {
      sub_1001EE134((uint64_t)"Failed to send PDU %u: %!", v13, v14, v15, v16, v17, v18, v19, a2);
      int v20 = (os_log_s *)sub_100086554(0x55u);
      if (os_log_type_enabled(v20, OS_LOG_TYPE_ERROR)) {
        sub_100657858();
      }
    }

    return v11;
  }

  uint64_t v12 = sub_1001EFB10((unsigned __int8 *)v21, v22, 2uLL, 0);
  if ((_DWORD)v12)
  {
    uint64_t v11 = v12;
    sub_1001EF5E4((uint64_t)v21);
    goto LABEL_10;
  }

  sub_1001EF5E4((uint64_t)v21);
  uint64_t result = 0LL;
  if ((_DWORD)v11 && (_DWORD)v11 != 412) {
    goto LABEL_10;
  }
  return result;
}

uint64_t *sub_1001C476C(uint64_t a1, uint64_t a2)
{
  uint64_t result = sub_1001C31E0(a1);
  if (result)
  {
    uint64_t v5 = result;
    if (sub_1000A86F0())
    {
      uint64_t v6 = sub_1001C3008(a2);
      sub_1001C34B0(*((unsigned __int8 *)v5 + 7));
      sub_1001EE134( (uint64_t)"MP Complete Pairing with status:%s(%d) state:(%s)%d",  v7,  v8,  v9,  v10,  v11,  v12,  v13,  (uint64_t)v6);
      uint64_t v14 = (os_log_s *)sub_100086554(0x55u);
      if (os_log_type_enabled(v14, OS_LOG_TYPE_DEFAULT))
      {
        *(_DWORD *)buf = 136446210;
        *(void *)&uint8_t buf[4] = sub_1001EDDCC();
        _os_log_impl((void *)&_mh_execute_header, v14, OS_LOG_TYPE_DEFAULT, " %{public}s", buf, 0xCu);
      }
    }

    uint64_t v15 = *((unsigned int *)v5 + 2);
    if ((_DWORD)v15)
    {
      sub_1001EEB14(v15);
      *((_DWORD *)v5 + 2) = 0;
    }

    if ((_DWORD)a2) {
      char v16 = -1;
    }
    else {
      char v16 = -16;
    }
    *((_BYTE *)v5 + 7) = v16;
    if ((_DWORD)a2)
    {
      if (!qword_1008ECF08[0]) {
        return (uint64_t *)sub_1001C30B8(a1);
      }
      uint64_t v17 = *(void (**)(uint64_t, uint64_t, uint64_t, uint64_t, uint64_t, char *, void))qword_1008ECF08[0];
      if (!*(void *)qword_1008ECF08[0]) {
        return (uint64_t *)sub_1001C30B8(a1);
      }
      uint64_t v18 = a1;
      uint64_t v19 = a2;
      uint64_t v20 = 0LL;
      uint64_t v21 = 0LL;
      uint64_t v22 = 0LL;
      int v23 = 0LL;
    }

    else
    {
      *(_OWORD *)buf = 0uLL;
      v27[0] = 0LL;
      v27[1] = 0LL;
      v26[0] = 0LL;
      v26[1] = 0LL;
      sub_1000B0974((char *)v5 + 270, 0x10uLL, (char *)v5 + 286, 0x10u, buf, 0x10u);
      sub_1000B0974((char *)v5 + 286, 0x10uLL, v26, 0x10u, v27, 0x10u);
      for (uint64_t i = 0LL; i != 16; ++i)
        *((_BYTE *)v5 + i + 12) = *((_BYTE *)v27 + i) ^ buf[i];
      if (!qword_1008ECF08[0]) {
        return (uint64_t *)sub_1001C30B8(a1);
      }
      uint64_t v17 = *(void (**)(uint64_t, uint64_t, uint64_t, uint64_t, uint64_t, char *, void))qword_1008ECF08[0];
      if (!*(void *)qword_1008ECF08[0]) {
        return (uint64_t *)sub_1001C30B8(a1);
      }
      uint64_t v25 = qword_1008ED850 + 44LL * *((unsigned __int8 *)v5 + 269);
      uint64_t v20 = v25 + 6;
      uint64_t v21 = v25 + 22;
      uint64_t v22 = *(unsigned int *)(v25 + 40);
      int v23 = (char *)v5 + 12;
      uint64_t v18 = a1;
      uint64_t v19 = 0LL;
    }

    v17(v18, v19, v20, v21, v22, v23, 0LL);
    return (uint64_t *)sub_1001C30B8(a1);
  }

  return result;
}

uint64_t *sub_1001C4984(uint64_t a1)
{
  if (sub_1000A86F0())
  {
    sub_1001EE134((uint64_t)"BT MagicPairing timeout.", v2, v3, v4, v5, v6, v7, v8, v13);
    uint64_t v9 = (os_log_s *)sub_100086554(0x55u);
    if (os_log_type_enabled(v9, OS_LOG_TYPE_ERROR)) {
      sub_100657858();
    }
  }

  uint64_t v10 = *(int **)(a1 + 8);
  __int16 v11 = *((_WORD *)v10 + 2);
  int v14 = *v10;
  __int16 v15 = v11;
  return sub_1001C4510((uint64_t)&v14, 6LL);
}

BOOL sub_1001C4A08(uint64_t a1)
{
  uint64_t v2 = ccaes_siv_encrypt_mode();
  uint64_t v3 = qword_1008ED850 + 44LL * *(unsigned __int8 *)(a1 + 269);
  __int128 v4 = *(_OWORD *)(a1 + 270);
  v20[0] = *(_OWORD *)(a1 + 28);
  v20[1] = v4;
  memset(&v20[4], 0, 32);
  int v21 = 0;
  v20[2] = *(_OWORD *)(a1 + 286);
  v20[3] = *(_OWORD *)(v3 + 6);
  size_t v5 = ccsiv_ciphertext_size(v2, 64LL);
  __chkstk_darwin(v5, v6);
  uint64_t v8 = (char *)v20 - v7;
  bzero((char *)v20 - v7, v5);
  uint64_t v9 = ccsiv_one_shot(v2, 32LL, a1 + 302, 0LL, 0LL, 0LL, 0LL, 64LL, v20, v8);
  if ((_DWORD)v9)
  {
    if (sub_1000A86F0())
    {
      sub_1001EE134((uint64_t)"ccsiv_one_shot returned %d", v10, v11, v12, v13, v14, v15, v16, v9);
      uint64_t v17 = (os_log_s *)sub_100086554(0x55u);
      if (os_log_type_enabled(v17, OS_LOG_TYPE_ERROR)) {
        sub_100657858();
      }
    }
  }

  else
  {
    *(_BYTE *)(a1 + 144) = v5;
    if (v5 >= 0x64) {
      size_t v18 = 100LL;
    }
    else {
      size_t v18 = v5;
    }
    memmove((void *)(a1 + 44), v8, v18);
  }

  return (_DWORD)v9 == 0;
}

uint64_t *sub_1001C4B9C(uint64_t a1, uint64_t a2)
{
  size_t v3 = *(unsigned __int8 *)(a1 + 144);
  __chkstk_darwin(a1, a2);
  size_t v5 = (char *)&v8 - v4;
  bzero((char *)&v8 - v4, v3 + 5);
  *(_WORD *)size_t v5 = -32767;
  v5[2] = 0;
  *(_WORD *)(v5 + 3) = v3;
  memmove(v5 + 5, (const void *)(a1 + 44), v3);
  uint64_t v6 = a1 + 1;
  uint64_t result = (uint64_t *)sub_1001C4610(v6, 3u, v5, (v3 + 5));
  if ((_DWORD)result) {
    return sub_1001C476C(v6, 1LL);
  }
  return result;
}

uint64_t sub_1001C4C9C()
{
  uint64_t v0 = sub_1001A56C0();
  if ((_DWORD)v0)
  {
    if (sub_1000A86F0())
    {
      sub_1001EE134((uint64_t)"Failed to create init ATT database with result %!", v1, v2, v3, v4, v5, v6, v7, v0);
      uint64_t v8 = (os_log_s *)sub_100086554(0x45u);
      if (os_log_type_enabled(v8, OS_LOG_TYPE_ERROR)) {
        sub_100657858();
      }
    }
  }

  return v0;
}

uint64_t sub_1001C4D14(uint64_t a1, int a2, unsigned __int8 *a3, uint64_t a4)
{
  if (!a1) {
    sub_1001EE2A0();
  }
  int v8 = *a3;
  if (v8 != 16 && v8 != 2) {
    return 146LL;
  }
  if (a2) {
    uint64_t v10 = &xmmword_1006BD89C;
  }
  else {
    uint64_t v10 = &xmmword_1006BD8B0;
  }
  *(_OWORD *)(a1 + 4) = *v10;
  *(_DWORD *)(a1 + 20) = *((_DWORD *)v10 + 4);
  *(void *)(a1 + 32) = sub_1001C4DCC;
  *(void *)(a1 + 40) = 0LL;
  *(_BYTE *)(a1 + 26) = 1;
  __int128 v12 = *(_OWORD *)a3;
  *(_DWORD *)(a1 + 64) = *((_DWORD *)a3 + 4);
  *(_OWORD *)(a1 + 48) = v12;
  return sub_1001A58C4(0LL, a1, a4);
}

uint64_t sub_1001C4DCC(uint64_t a1, unsigned int a2, void *a3, int a4, _WORD *a5)
{
  unsigned int v6 = *(unsigned __int8 *)(a1 + 48);
  BOOL v7 = v6 >= a2;
  int v8 = v6 - a2;
  if (!v7) {
    return 7LL;
  }
  v12[0] = 0LL;
  v12[1] = 0LL;
  if (v8 >= a4) {
    LOWORD(v8) = a4;
  }
  *a5 = v8;
  sub_1001BEF1C(v12, (unsigned __int8 *)(a1 + 48), 1);
  memmove(a3, (char *)v12 + a2, (unsigned __int16)*a5);
  return 0LL;
}

void sub_1001C4E78(unsigned __int16 *a1)
{
  if (a1) {
    sub_1001A5BC8(*a1, 0);
  }
  else {
    sub_1001EE2A0();
  }
}

uint64_t sub_1001C4E8C(uint64_t a1, uint64_t a2, uint64_t a3)
{
  int v3 = *(unsigned __int8 *)(a3 + 48);
  if (v3 != 16 && v3 != 2) {
    return 146LL;
  }
  *(_DWORD *)(a1 + 20) = 0;
  *(_OWORD *)(a1 + 4) = xmmword_1006BD8C4;
  *(void *)(a1 + 32) = sub_1001C4F08;
  *(void *)(a1 + 40) = 0LL;
  *(_BYTE *)(a1 + 26) = 1;
  *(_WORD *)(a1 + 48) = *(_WORD *)a3;
  *(_WORD *)(a1 + 50) = *(_WORD *)(a3 + 24);
  int v5 = *(_DWORD *)(a3 + 64);
  *(_OWORD *)(a1 + 52) = *(_OWORD *)(a3 + 48);
  *(_DWORD *)(a1 + 68) = v5;
  return sub_1001A58C4(a2, a1, 0LL);
}

uint64_t sub_1001C4F08(uint64_t a1, unsigned int a2, void *__dst, int a4, unsigned __int16 *a5)
{
  int v6 = *(unsigned __int8 *)(a1 + 52);
  if (v6 == 2) {
    unsigned int v7 = 6;
  }
  else {
    unsigned int v7 = 4;
  }
  int v8 = v7 - a2;
  if (v7 < a2) {
    return 7LL;
  }
  __int16 v15 = 0;
  int v14 = *(_DWORD *)(a1 + 48);
  if (v6 == 2) {
    sub_1001BEF1C(&v15, (unsigned __int8 *)(a1 + 52), 1);
  }
  if (v8 >= a4) {
    unsigned __int16 v13 = a4;
  }
  else {
    unsigned __int16 v13 = v8;
  }
  *a5 = v13;
  memmove(__dst, (char *)&v14 + a2, v13);
  return 0LL;
}

uint64_t sub_1001C4FB4( uint64_t a1, unsigned __int16 *a2, char a3, uint64_t a4, uint64_t a5, unsigned __int8 *a6, uint64_t a7, uint64_t a8)
{
  int v8 = *a6;
  if (v8 != 16 && v8 != 2) {
    return 146LL;
  }
  if ((a3 & 2) == 0 || a7)
  {
    if ((a3 & 0x4C) == 0 || a8)
    {
      *(_OWORD *)(a2 + 2) = xmmword_1006BD8D8;
      *((_DWORD *)a2 + 5) = 0;
      *((void *)a2 + 4) = sub_1001C514C;
      *((void *)a2 + 5) = 0LL;
      *((_BYTE *)a2 + 26) = 1;
      *((_BYTE *)a2 + 48) = a3;
      __int128 v32 = *(_OWORD *)a6;
      *((_DWORD *)a2 + 17) = *((_DWORD *)a6 + 4);
      *(_OWORD *)(a2 + 26) = v32;
      if (sub_1001A58C4(a1, (uint64_t)a2, a4))
      {
        return 4105LL;
      }

      else
      {
        __int128 v33 = *(_OWORD *)a6;
        *(_DWORD *)(a5 + 20) = *((_DWORD *)a6 + 4);
        *(_OWORD *)(a5 + 4) = v33;
        *(void *)(a5 + 32) = a7;
        *(void *)(a5 + 40) = a8;
        uint64_t result = sub_1001A58C4(*a2, a5, 0LL);
        if ((_DWORD)result)
        {
          sub_1001A5BC8(*a2, 0);
          return 4106LL;
        }

        else
        {
          a2[25] = *(_WORD *)a5;
        }
      }
    }

    else
    {
      if (sub_1000A86F0())
      {
        sub_1001EE134( (uint64_t)"Set callback required since characteristic is writable.",  v24,  v25,  v26,  v27,  v28,  v29,  v30,  v34);
        uint64_t v31 = (os_log_s *)sub_100086554(0x45u);
        if (os_log_type_enabled(v31, OS_LOG_TYPE_ERROR)) {
          sub_100657858();
        }
      }

      return 4104LL;
    }
  }

  else
  {
    if (sub_1000A86F0())
    {
      sub_1001EE134( (uint64_t)"Get callback required since characteristic is readable",  v15,  v16,  v17,  v18,  v19,  v20,  v21,  v34);
      uint64_t v22 = (os_log_s *)sub_100086554(0x45u);
      if (os_log_type_enabled(v22, OS_LOG_TYPE_ERROR)) {
        sub_100657858();
      }
    }

    return 4103LL;
  }

  return result;
}

uint64_t sub_1001C514C(uint64_t a1, unsigned int a2, void *a3, int a4, _WORD *a5)
{
  unsigned int v6 = *(unsigned __int8 *)(a1 + 52) + 3;
  int v7 = v6 - a2;
  if (v6 < a2) {
    return 7LL;
  }
  v13[0] = 0LL;
  v13[1] = 0LL;
  char v11 = *(_BYTE *)(a1 + 48);
  __int16 v12 = *(_WORD *)(a1 + 50);
  if (v7 >= a4) {
    LOWORD(v7) = a4;
  }
  *a5 = v7;
  sub_1001BEF1C(v13, (unsigned __int8 *)(a1 + 52), 1);
  memmove(a3, &v11 + a2, (unsigned __int16)*a5);
  return 0LL;
}

uint64_t sub_1001C5210( uint64_t a1, uint64_t a2, char a3, unsigned __int8 *a4, uint64_t (*a5)(uint64_t a1, unsigned int a2, void *a3, signed int a4, _WORD *a5), uint64_t a6)
{
  int v6 = *a4;
  if (v6 != 16 && v6 != 2) {
    return 146LL;
  }
  __int128 v14 = *(_OWORD *)a4;
  *(_DWORD *)(a1 + 20) = *((_DWORD *)a4 + 4);
  *(_OWORD *)(a1 + 4) = v14;
  if (sub_1001BEC7C(a4, (unsigned __int8 *)&xmmword_1006BD8EC)
    || sub_1001BEC7C(a4, (unsigned __int8 *)&xmmword_1006BD93C))
  {
    a6 = 0LL;
  }

  else
  {
    if (sub_1001BEC7C(a4, (unsigned __int8 *)&xmmword_1006BD900))
    {
      a5 = sub_1001C5324;
      goto LABEL_10;
    }

    if (sub_1001BEC7C(a4, (unsigned __int8 *)&xmmword_1006BD914)
      || sub_1001BEC7C(a4, (unsigned __int8 *)&xmmword_1006BD928))
    {
      a3 |= 3u;
      goto LABEL_10;
    }
  }

  a5 = sub_1001C5324;
  a3 = 1;
LABEL_10:
  *(_BYTE *)(a1 + 26) = a3;
  *(void *)(a1 + 32) = a5;
  *(void *)(a1 + 40) = a6;
  return sub_1001A58C4(a2, a1, 0LL);
}

uint64_t sub_1001C5324(uint64_t a1, unsigned int a2, void *a3, signed int a4, _WORD *a5)
{
  uint64_t v10 = (unsigned __int8 *)(a1 + 4);
  if (!sub_1001BEC7C((unsigned __int8 *)(a1 + 4), (unsigned __int8 *)&xmmword_1006BD8EC))
  {
    if (sub_1001BEC7C(v10, (unsigned __int8 *)&xmmword_1006BD93C))
    {
      v18[0] = *(_WORD *)(a1 + 48);
      char v19 = *(_BYTE *)(a1 + 52);
      if (a2 <= 7)
      {
        v18[1] = *(_WORD *)(a1 + 50);
        __int16 v20 = *(_WORD *)(a1 + 54);
        else {
          size_t v11 = 7 - a2;
        }
        *a5 = v11;
        __int16 v12 = v18;
        goto LABEL_13;
      }
    }

    else
    {
      sub_1001BEC7C(v10, (unsigned __int8 *)&xmmword_1006BD900);
      unsigned int v14 = *(unsigned __int16 *)(a1 + 56);
      BOOL v15 = v14 >= a2;
      signed int v16 = v14 - a2;
      if (v15)
      {
        if (v16 >= a4) {
          LOWORD(v16) = a4;
        }
        *a5 = v16;
        unsigned __int16 v13 = (char *)(*(void *)(a1 + 48) + a2);
        size_t v11 = (unsigned __int16)v16;
        goto LABEL_19;
      }
    }

    return 7LL;
  }

  if (a2 > 2) {
    return 7LL;
  }
  __int16 v21 = *(_WORD *)(a1 + 48);
  else {
    size_t v11 = 2 - a2;
  }
  *a5 = v11;
  __int16 v12 = &v21;
LABEL_13:
  unsigned __int16 v13 = (char *)v12 + a2;
LABEL_19:
  memmove(a3, v13, v11);
  return 0LL;
}

uint64_t sub_1001C5450(uint64_t a1, unsigned __int8 *a2, int a3, const void *a4, int a5)
{
  if (sub_1001BEC7C(a2 + 4, (unsigned __int8 *)&xmmword_1006BD8D8))
  {
    if (a3)
    {
      if ((a2[48] & 0x10) == 0)
      {
        if (sub_1000A86F0())
        {
          sub_1001EE134( (uint64_t)"Can't send notification to characteristic without notify property!",  v10,  v11,  v12,  v13,  v14,  v15,  v16,  v35);
          uint64_t v17 = (os_log_s *)sub_100086554(0x45u);
          if (os_log_type_enabled(v17, OS_LOG_TYPE_ERROR)) {
            sub_100657858();
          }
        }

        return 4108LL;
      }

      return sub_1001A5EBC(a1, *((_WORD *)a2 + 25), a3, a4, a5);
    }

    if ((a2[48] & 0x20) != 0) {
      return sub_1001A5EBC(a1, *((_WORD *)a2 + 25), a3, a4, a5);
    }
    if (sub_1000A86F0())
    {
      sub_1001EE134( (uint64_t)"Can't send indication to characteristic without indicate property!",  v27,  v28,  v29,  v30,  v31,  v32,  v33,  v35);
      uint64_t v34 = (os_log_s *)sub_100086554(0x45u);
      if (os_log_type_enabled(v34, OS_LOG_TYPE_ERROR)) {
        sub_100657858();
      }
    }

    return 4109LL;
  }

  else
  {
    if (sub_1000A86F0())
    {
      sub_1001EE134( (uint64_t)"Attribute handle 0x%x is not a characteristic!",  v19,  v20,  v21,  v22,  v23,  v24,  v25,  *(unsigned __int16 *)a2);
      uint64_t v26 = (os_log_s *)sub_100086554(0x45u);
      if (os_log_type_enabled(v26, OS_LOG_TYPE_ERROR)) {
        sub_100657858();
      }
    }

    return 4107LL;
  }

double sub_1001C55C0@<D0>(unsigned int a1@<W0>, int a2@<W1>, _OWORD *a3@<X8>)
{
  if (a1 <= 3)
  {
    int v3 = (int *)&xmmword_1008ED858 + a2;
    if (a1 == 1)
    {
      int v4 = *v3;
    }

    else
    {
      int v5 = v3[12];
      v3 += 12;
      int v4 = v5;
    }

    if (v4 != -1) {
      *int v3 = v4 + 1;
    }
  }

  __int128 v6 = unk_1008ED888;
  a3[2] = xmmword_1008ED878;
  a3[3] = v6;
  __int128 v7 = unk_1008ED8A8;
  a3[4] = xmmword_1008ED898;
  a3[5] = v7;
  double result = *(double *)&xmmword_1008ED858;
  __int128 v9 = unk_1008ED868;
  *a3 = xmmword_1008ED858;
  a3[1] = v9;
  return result;
}

void sub_1001C5618(unsigned __int16 *a1)
{
  uint64_t v1 = qword_1008ED8D0;
  uint64_t v2 = (void (*)(unsigned __int16 *, uint64_t))off_1008ED8C0;
  int v4 = (_DWORD *)((char *)a1 + 1);
  int v3 = *(_DWORD *)((char *)a1 + 1);
  memset(ptr, 0, 15);
  if (v3) {
    BOOL v5 = 0;
  }
  else {
    BOOL v5 = *((_DWORD *)a1 + 1) == 0;
  }
  if (v5) {
    return;
  }
  if (!*((_BYTE *)a1 + 58)) {
    goto LABEL_9;
  }
  int v7 = *(unsigned __int8 *)v4;
  if (v7 == 255)
  {
    *int v4 = *(_DWORD *)((char *)a1 + 51);
    *((_DWORD *)a1 + 1) = *(_DWORD *)(a1 + 27);
LABEL_9:
    char v8 = *(_BYTE *)v4;
    goto LABEL_10;
  }

  char v8 = v7 - 2;
  *(_BYTE *)int v4 = v8;
LABEL_10:
  if (v8 == 1 && (a1[1] & 0xC0) == 0x40)
  {
    char v52 = 0;
    memset(v51, 0, sizeof(v51));
    if (!sub_1001C9328((_BYTE *)a1 + 1, (uint64_t)v51, &v52))
    {
      if (v52)
      {
        *int v4 = *(_DWORD *)v51;
        *(_DWORD *)((char *)v4 + 3) = *(_DWORD *)&v51[3];
      }
    }
  }

  int v9 = *((char *)a1 + 24);
  if (v9 <= 27)
  {
    if (v9 <= -40)
    {
      else {
        int v10 = 10;
      }
    }

    else
    {
      int v10 = 0;
    }
  }

  else
  {
    int v10 = 11;
  }

  unsigned int v11 = *((unsigned __int8 *)a1 + 44);
  if (v11 <= 3)
  {
    uint64_t v12 = (int *)&xmmword_1008ED858 + v10;
    if (v11 == 1)
    {
      int v13 = *v12;
    }

    else
    {
      int v14 = v12[12];
      v12 += 12;
      int v13 = v14;
    }

    if (v13 != -1) {
      *uint64_t v12 = v13 + 1;
    }
  }

  unsigned int v15 = *((unsigned __int8 *)a1 + 28);
  BOOL v16 = v15 < 3;
  if (v15 >= 3)
  {
    if (sub_1000A86F0())
    {
      sub_1001EE134( (uint64_t)"Invalid packet status:%d",  v17,  v18,  v19,  v20,  v21,  v22,  v23,  *((unsigned __int8 *)a1 + 28));
      uint64_t v24 = (os_log_s *)sub_100086554(0x42u);
      if (os_log_type_enabled(v24, OS_LOG_TYPE_ERROR)) {
        sub_100657858();
      }
    }

    sub_1001EE2A0();
  }

  if (sub_1001EC434(qword_1008ED8F8)
    && (uint64_t v25 = (void *)sub_1001EC43C(qword_1008ED8F8), (ptr[0] = v25) != 0LL))
  {
    while (1)
    {
      uint64_t v26 = sub_1001EC460((uint64_t)v25);
      sub_1001EC444((uint64_t)ptr);
      uint64_t v25 = ptr[0];
      if (!ptr[0]) {
        goto LABEL_40;
      }
    }

    uint64_t v28 = (unsigned __int16 *)v26;
    sub_1001EC4B4(qword_1008ED8F8, (void *)ptr[0], 0);
    if (*((_BYTE *)v28 + 28) != 1) {
      sub_1001EE2A0();
    }
  }

  else
  {
LABEL_40:
    if (*((_BYTE *)a1 + 28) != 1)
    {
      uint64_t v28 = 0LL;
      goto LABEL_47;
    }

    uint64_t v28 = (unsigned __int16 *)sub_1000B17F4(0x50uLL);
    *(_OWORD *)uint64_t v28 = 0u;
    *((_OWORD *)v28 + 1) = 0u;
    *((_OWORD *)v28 + 2) = 0u;
    *((_OWORD *)v28 + 3) = 0u;
    *((_OWORD *)v28 + 4) = 0u;
    BOOL v16 = 0;
    *((void *)v28 + 2) = sub_1000B17F4(0x672uLL);
  }

  size_t v29 = a1[4];
  if (v29 > 0x671 || (uint64_t v30 = v28[4], v31 = v30 + v29, (unsigned __int16)(v30 + v29) > 0x672u))
  {
    if (sub_1000A86F0())
    {
      sub_1001EE134( (uint64_t)"Total advertising data length %d is larger than max advertising length %d",  v34,  v35,  v36,  v37,  v38,  v39,  v40,  v28[4] + a1[4]);
      uint64_t v41 = (os_log_s *)sub_100086554(0x42u);
      if (os_log_type_enabled(v41, OS_LOG_TYPE_ERROR)) {
        sub_100657858();
      }
    }

    sub_1001EE2A0();
    goto LABEL_63;
  }

  memmove((void *)(*((void *)v28 + 2) + v30), *((const void **)a1 + 2), v29);
  uint64_t v32 = *((void *)v28 + 2);
  memmove(v28, a1, 0x50uLL);
  *((void *)v28 + 2) = v32;
  v28[4] = v31;
  if (*((_BYTE *)a1 + 28) == 1)
  {
    sub_1001EC1DC(qword_1008ED8F8, (uint64_t)v28, 80LL);
    return;
  }

uint64_t sub_1001C5A00( uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, unsigned __int8 a9, char a10, char a11, char a12, __int16 a13, __int16 a14, char a15, char a16, uint64_t (*a17)(void, void), void *a18, uint64_t a19, uint64_t a20)
{
  *(_DWORD *)&v163[3] = 0;
  *(_DWORD *)v163 = 0;
  if (memcmp(&unk_1008ED8B8, &unk_1006BDD58, 0x40uLL))
  {
    if (sub_1000A86F0())
    {
      sub_1001EE134((uint64_t)"LE scan already in progress.", v28, v29, v30, v31, v32, v33, v34, v157);
      uint64_t v35 = (os_log_s *)sub_100086554(0x42u);
      if (os_log_type_enabled(v35, OS_LOG_TYPE_ERROR)) {
        sub_100657858();
      }
    }

    return 118LL;
  }

  if (byte_1008ED900 == 1) {
    sub_1001EE2A0();
  }
  if (!a18 || !a17 || !a19)
  {
    sub_1001EE134((uint64_t)"Invalid callback functions", v45, v46, v47, v48, v49, v50, v51, v157);
    char v52 = (os_log_s *)sub_100086554(0x42u);
    if (!os_log_type_enabled(v52, OS_LOG_TYPE_ERROR)) {
      return 101LL;
    }
LABEL_64:
    sub_100657858();
    return 101LL;
  }

  if (!(a4 | a3 | a5 | a6))
  {
    sub_1001EE134( (uint64_t)"Cannot start scan when both main and LP cores window is set to 0",  v53,  v54,  v55,  v56,  v57,  v58,  v59,  v157);
    uint64_t v60 = (os_log_s *)sub_100086554(0x42u);
    if (!os_log_type_enabled(v60, OS_LOG_TYPE_ERROR)) {
      return 101LL;
    }
    goto LABEL_64;
  }

  if (a1 >= 2)
  {
    sub_1001EE134((uint64_t)"Invalid scan type parameters : %d", v37, v38, v39, v40, v41, v42, v43, a1);
    uint64_t v44 = (os_log_s *)sub_100086554(0x42u);
    if (!os_log_type_enabled(v44, OS_LOG_TYPE_ERROR)) {
      return 101LL;
    }
    goto LABEL_64;
  }

  if ((_DWORD)a2 && (a2 - 16385) <= 0xFFFFC002)
  {
    sub_1001EE134((uint64_t)"Invalid scan interval parameters : %d", v61, v62, v63, v64, v65, v66, v67, a2);
    uint64_t v68 = (os_log_s *)sub_100086554(0x42u);
    if (!os_log_type_enabled(v68, OS_LOG_TYPE_ERROR)) {
      return 101LL;
    }
    goto LABEL_64;
  }

  if ((_DWORD)a3 && (a3 - 16385) <= 0xFFFFC002)
  {
    sub_1001EE134((uint64_t)"Invalid scan interval parameters : %d", v69, v70, v71, v72, v73, v74, v75, a3);
    uint64_t v76 = (os_log_s *)sub_100086554(0x42u);
    if (!os_log_type_enabled(v76, OS_LOG_TYPE_ERROR)) {
      return 101LL;
    }
    goto LABEL_64;
  }

  if ((_DWORD)a4 && (a4 - 4) >= 0x3FFD)
  {
    sub_1001EE134( (uint64_t)"Invalid scan window parameters for leScanWindowLPCore : %d",  v77,  v78,  v79,  v80,  v81,  v82,  v83,  a4);
    uint64_t v84 = (os_log_s *)sub_100086554(0x42u);
    if (!os_log_type_enabled(v84, OS_LOG_TYPE_ERROR)) {
      return 101LL;
    }
    goto LABEL_64;
  }

  if ((_DWORD)a5 && (a5 - 16385) <= 0xFFFFC002)
  {
    sub_1001EE134( (uint64_t)"Invalid scan window parameters for leScanWindowScanCoreELNAOn : %d",  v85,  v86,  v87,  v88,  v89,  v90,  v91,  a5);
    uint64_t v92 = (os_log_s *)sub_100086554(0x42u);
    if (!os_log_type_enabled(v92, OS_LOG_TYPE_ERROR)) {
      return 101LL;
    }
    goto LABEL_64;
  }

  if ((_DWORD)a6 && (a6 - 16385) <= 0xFFFFC002)
  {
    sub_1001EE134( (uint64_t)"Invalid scan window parameters for leScanWindowScanCoreELNABypass : %d",  v93,  v94,  v95,  v96,  v97,  v98,  v99,  a6);
    uint64_t v100 = (os_log_s *)sub_100086554(0x42u);
    if (!os_log_type_enabled(v100, OS_LOG_TYPE_ERROR)) {
      return 101LL;
    }
    goto LABEL_64;
  }

  if ((_DWORD)a5 && (_DWORD)a6)
  {
    sub_1001EE134( (uint64_t)"Invalid scan window parameters for leScanWindowScanCoreELNAOn : %d and leScanWindowScanCoreELNABypass : % d. Both cannot be used at the same time.",  v101,  v102,  v103,  v104,  v105,  v106,  v107,  a5);
    uint64_t v108 = (os_log_s *)sub_100086554(0x42u);
    if (!os_log_type_enabled(v108, OS_LOG_TYPE_ERROR)) {
      return 101LL;
    }
    goto LABEL_64;
  }

  if (a7 >= 2)
  {
    sub_1001EE134((uint64_t)"Invalid scan filter : %d", v109, v110, v111, v112, v113, v114, v115, a7);
    uint64_t v116 = (os_log_s *)sub_100086554(0x42u);
    if (!os_log_type_enabled(v116, OS_LOG_TYPE_ERROR)) {
      return 101LL;
    }
    goto LABEL_64;
  }

  if (a8 >= 2)
  {
    sub_1001EE134((uint64_t)"Invalid scan filter duplicate setting : %d", v117, v118, v119, v120, v121, v122, v123, a8);
    BOOL v124 = (os_log_s *)sub_100086554(0x42u);
    if (!os_log_type_enabled(v124, OS_LOG_TYPE_ERROR)) {
      return 101LL;
    }
    goto LABEL_64;
  }

  if (a9 >= 2u && !byte_1008ED901)
  {
    sub_1001EE134((uint64_t)"Invalid scan phy setting : %d", v125, v126, v127, v128, v129, v130, v131, a9);
    uint64_t v132 = (os_log_s *)sub_100086554(0x42u);
    if (!os_log_type_enabled(v132, OS_LOG_TYPE_ERROR)) {
      return 101LL;
    }
    goto LABEL_64;
  }

  sub_1001BDFB4((uint64_t)v163);
  uint64_t v141 = 0LL;
  byte_1008ED902 = 1;
  unk_1008ED8B8 = a17;
  off_1008ED8C0 = a18;
  qword_1008ED8C8 = a19;
  qword_1008ED8D0 = a20;
  LOBYTE(xmmword_1008ED8D8) = a1;
  WORD1(xmmword_1008ED8D8) = a2;
  WORD2(xmmword_1008ED8D8) = a3;
  WORD3(xmmword_1008ED8D8) = a4;
  WORD4(xmmword_1008ED8D8) = a5;
  WORD5(xmmword_1008ED8D8) = a6;
  BYTE12(xmmword_1008ED8D8) = a9;
  BYTE13(xmmword_1008ED8D8) = a7;
  BYTE14(xmmword_1008ED8D8) = a8;
  *(_WORD *)((char *)&xmmword_1008ED8D8 + 15) = 258;
  byte_1008ED8E9 = 1;
  byte_1008ED8EE = a10;
  int v142 = byte_1008ED903;
  if (!byte_1008ED903) {
    a11 = 0;
  }
  byte_1008ED8EF = a11;
  byte_1008ED8F2 = a12;
  word_1008ED8F4 = a13;
  word_1008ED8F6 = a14;
  byte_1008ED8F0 = a15;
  byte_1008ED8F1 = a16;
  v162[0] = a1;
  v162[1] = a1;
  v162[2] = a1;
  v161[0] = a2;
  v161[1] = a2;
  v161[2] = a2;
  v160[0] = a3;
  v160[1] = a3;
  v160[2] = a3;
  __int16 v159 = 0;
  if (a12) {
    __int16 v144 = a13;
  }
  else {
    __int16 v144 = 30;
  }
  int v158 = 0;
  do
  {
    *(_WORD *)((char *)&v158 + v141) = v144;
    v141 += 2LL;
  }

  while (v141 != 6);
  if (byte_1008ED904) {
    BOOL v145 = byte_1008ED905 == 0;
  }
  else {
    BOOL v145 = 1;
  }
  char v146 = v145;
  if (v142 || (v146 & 1) == 0)
  {
    if (byte_1008ED906) {
      unsigned __int8 v148 = 2;
    }
    else {
      unsigned __int8 v148 = 1;
    }
    byte_1008ED8E8 = v148;
    if (!(_DWORD)a2 || !(_DWORD)a3)
    {
      sub_1001C617C(0LL, v134, v135, v136, v137, v138, v139, v140);
      return 0LL;
    }

    uint64_t v147 = sub_10018E65C(v163[0], a7, a9, (uint64_t)v162, (uint64_t)v161, (uint64_t)v160, v148, 1u);
  }

  else if (byte_1008ED906)
  {
    uint64_t v147 = sub_1001214B4(215, (uint64_t)sub_1001C617C, v135, v136, v137, v138, v139, v140, v163[0]);
  }

  else
  {
    uint64_t v147 = sub_1001214B4(171, (uint64_t)sub_1001C617C, v135, v136, v137, v138, v139, v140, a1);
  }

  uint64_t v36 = v147;
  if ((_DWORD)v147)
  {
    if (sub_1000A86F0())
    {
      sub_1001EE134((uint64_t)"Could not start a LE scan %!", v149, v150, v151, v152, v153, v154, v155, v36);
      v156 = (os_log_s *)sub_100086554(0x42u);
      if (os_log_type_enabled(v156, OS_LOG_TYPE_ERROR)) {
        sub_100657858();
      }
    }

    xmmword_1008ED8D8 = 0u;
    *(_OWORD *)&byte_1008ED8E8 = 0u;
    *(_OWORD *)&unk_1008ED8B8 = 0u;
    *(_OWORD *)&qword_1008ED8C8 = 0u;
    byte_1008ED902 = 0;
  }

  return v36;
}

void sub_1001C617C( uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  uint64_t v8 = a1;
  int v10 = (void (*)(uint64_t, uint64_t))qword_1008ED8C8;
  uint64_t v9 = qword_1008ED8D0;
  *(_DWORD *)&v34[3] = 0;
  *(_DWORD *)uint64_t v34 = 0;
  char v33 = xmmword_1008ED8D8;
  int v11 = WORD1(xmmword_1008ED8D8);
  __int16 v32 = WORD1(xmmword_1008ED8D8);
  int v12 = WORD3(xmmword_1008ED8D8);
  __int16 v31 = WORD3(xmmword_1008ED8D8);
  if (!(_DWORD)a1)
  {
    if (!byte_1008ED904 || !byte_1008ED905)
    {
      sub_1001C6C1C(0LL, a2, a3, a4, a5, a6, a7, a8);
      return;
    }

    sub_1001BDFB4((uint64_t)v34);
    if (byte_1008ED906) {
      unsigned __int8 v28 = 2;
    }
    else {
      unsigned __int8 v28 = 1;
    }
    byte_1008ED8E8 = v28;
    if (byte_1008ED908)
    {
      if (WORD3(xmmword_1008ED8D8))
      {
        uint64_t v29 = v34[0];
        uint64_t v30 = BYTE13(xmmword_1008ED8D8);
        goto LABEL_20;
      }

      if (WORD4(xmmword_1008ED8D8) | WORD5(xmmword_1008ED8D8))
      {
        sub_1001C6EFC(0LL, v21, v22, v23, v24, v25, v26, v27);
        return;
      }
    }

    else if (v11 && v12)
    {
      uint64_t v29 = v34[0];
      uint64_t v30 = BYTE13(xmmword_1008ED8D8);
LABEL_20:
      uint64_t v8 = sub_10018E65C(v29, v30, 1LL, (uint64_t)&v33, (uint64_t)&v32, (uint64_t)&v31, v28, 2u);
      if (!(_DWORD)v8) {
        return;
      }
      goto LABEL_2;
    }

    sub_1001C6C1C(0LL, v21, v22, v23, v24, v25, v26, v27);
    return;
  }

BOOL sub_1001C63A0()
{
  return memcmp(&unk_1008ED8B8, &unk_1006BDD58, 0x40uLL) != 0;
}

uint64_t sub_1001C63D0()
{
  if (byte_1008ED900 == 1)
  {
    uint64_t v0 = 0LL;
    byte_1008ED907 = 0;
  }

  else if (byte_1008ED902 == 1)
  {
    if (sub_1000A86F0())
    {
      sub_1001EE134((uint64_t)"Scan is starting, can't stop it.", v1, v2, v3, v4, v5, v6, v7, v27);
      uint64_t v8 = (os_log_s *)sub_100086554(0x42u);
      if (os_log_type_enabled(v8, OS_LOG_TYPE_ERROR)) {
        sub_100657858();
      }
    }

    return 118LL;
  }

  else if (!memcmp(&unk_1008ED8B8, &unk_1006BDD58, 0x40uLL))
  {
    return 0LL;
  }

  else
  {
    if (byte_1008ED905)
    {
      if (byte_1008ED906) {
        unsigned __int8 v15 = 2;
      }
      else {
        unsigned __int8 v15 = 1;
      }
      byte_1008ED8E8 = v15;
      if (!byte_1008ED904 || byte_1008ED908)
      {
        unsigned int v16 = byte_1008ED8E9;
      }

      else
      {
        unsigned int v16 = 3;
        byte_1008ED8E9 = 3;
      }

      uint64_t v17 = sub_10018E4B0(0LL, v15, BYTE14(xmmword_1008ED8D8), HIBYTE(xmmword_1008ED8D8), v16);
    }

    else if (byte_1008ED906)
    {
      uint64_t v17 = sub_1001214B4(216, (uint64_t)sub_1001C65AC, v9, v10, v11, v12, v13, v14, 0LL);
    }

    else
    {
      uint64_t v17 = sub_1001214B4(172, (uint64_t)sub_1001C65AC, v9, v10, v11, v12, v13, v14, 0LL);
    }

    uint64_t v0 = v17;
    if ((_DWORD)v17)
    {
      if (sub_1000A86F0())
      {
        sub_1001EE134((uint64_t)"Could not stop the LE scan : %!", v18, v19, v20, v21, v22, v23, v24, v0);
        uint64_t v25 = (os_log_s *)sub_100086554(0x42u);
        if (os_log_type_enabled(v25, OS_LOG_TYPE_ERROR)) {
          sub_100657858();
        }
      }
    }

    else
    {
      byte_1008ED907 = 0;
      byte_1008ED900 = 1;
    }
  }

  return v0;
}

void sub_1001C65AC(uint64_t a1)
{
  uint64_t v2 = qword_1008ED8D0;
  uint64_t v25 = (void (*)(uint64_t, uint64_t))qword_1008ED8C8;
  uint64_t v3 = qword_1008ED8F8;
  if (qword_1008ED8F8)
  {
    while (sub_1001EC434(v3))
    {
      uint64_t v4 = (void **)sub_1001EC30C(qword_1008ED8F8);
      sub_1001EC324(qword_1008ED8F8, 0);
      sub_1000B1838(v4[2]);
      sub_1000B1838(v4);
      uint64_t v3 = qword_1008ED8F8;
    }
  }

  if (byte_1008ED907 == 1)
  {
    *(_DWORD *)&v29[3] = 0;
    *(_DWORD *)uint64_t v29 = 0;
    sub_1001BDFB4((uint64_t)v29);
    char v28 = xmmword_1008ED8D8;
    __int16 v26 = WORD2(xmmword_1008ED8D8);
    __int16 v27 = WORD1(xmmword_1008ED8D8);
    if (byte_1008ED904) {
      BOOL v12 = byte_1008ED905 == 0;
    }
    else {
      BOOL v12 = 1;
    }
    char v13 = v12;
    if (!byte_1008ED903 && (v13 & 1) != 0)
    {
      if (byte_1008ED906) {
        uint64_t v14 = sub_1001214B4(215, (uint64_t)sub_1001C6C1C, v6, v7, v8, v9, v10, v11, v29[0]);
      }
      else {
        uint64_t v14 = sub_1001214B4(171, (uint64_t)sub_1001C6C1C, v6, v7, v8, v9, v10, v11, xmmword_1008ED8D8);
      }
LABEL_29:
      uint64_t v16 = v14;
      if ((_DWORD)v14)
      {
LABEL_30:
        if (sub_1000A86F0())
        {
          sub_1001EE134((uint64_t)"Could not restart a LE scan %!", v17, v18, v19, v20, v21, v22, v23, v16);
          uint64_t v24 = (os_log_s *)sub_100086554(0x42u);
          if (os_log_type_enabled(v24, OS_LOG_TYPE_ERROR)) {
            sub_100657858();
          }
        }

        xmmword_1008ED8D8 = 0u;
        *(_OWORD *)&byte_1008ED8E8 = 0u;
        *(_OWORD *)&unk_1008ED8B8 = 0u;
        *(_OWORD *)&qword_1008ED8C8 = 0u;
        goto LABEL_35;
      }

      goto LABEL_35;
    }

    if (byte_1008ED906) {
      unsigned __int8 v15 = 2;
    }
    else {
      unsigned __int8 v15 = 1;
    }
    byte_1008ED8E8 = v15;
    if (byte_1008ED908)
    {
      if (!WORD2(xmmword_1008ED8D8))
      {
        if (!WORD3(xmmword_1008ED8D8))
        {
          if (!(WORD4(xmmword_1008ED8D8) | WORD5(xmmword_1008ED8D8)))
          {
            uint64_t v16 = 101LL;
            goto LABEL_30;
          }

          sub_1001C6EFC(0LL, v5, v6, v7, v8, v9, v10, v11);
LABEL_35:
          byte_1008ED907 = 0;
          byte_1008ED900 = 0;
          return;
        }

uint64_t sub_1001C6890(int a1)
{
  uint64_t result = memcmp(&unk_1008ED8B8, &unk_1006BDD58, 0x40uLL);
  if ((_DWORD)result)
  {
    if ((byte_1008ED907 & 1) != 0 || a1 && BYTE13(xmmword_1008ED8D8) != 1 || (byte_1008ED900 & 1) != 0)
    {
      return 0LL;
    }

    else
    {
      uint64_t result = sub_1001C63D0();
      if (!(_DWORD)result) {
        byte_1008ED907 = 1;
      }
    }
  }

  return result;
}

uint64_t sub_1001C690C(uint64_t result)
{
  byte_1008ED906 = result;
  return result;
}

void sub_1001C6918()
{
  xmmword_1008ED8D8 = 0u;
  *(_OWORD *)&byte_1008ED8E8 = 0u;
  *(_OWORD *)&unk_1008ED8B8 = 0u;
  *(_OWORD *)&qword_1008ED8C8 = 0u;
  if (!qword_1008ED8F8) {
    qword_1008ED8F8 = (uint64_t)sub_1001EC038(0LL, 0LL);
  }
}

uint64_t sub_1001C6960(uint64_t result)
{
  byte_1008ED905 = result;
  return result;
}

uint64_t sub_1001C696C(uint64_t result)
{
  byte_1008ED909 = result;
  return result;
}

uint64_t sub_1001C6978(uint64_t result)
{
  byte_1008ED904 = result;
  byte_1008ED90A = 0;
  return result;
}

uint64_t sub_1001C698C(uint64_t result)
{
  byte_1008ED903 = result;
  return result;
}

uint64_t sub_1001C6998(uint64_t result)
{
  byte_1008ED908 = result;
  return result;
}

uint64_t sub_1001C69A4(uint64_t result)
{
  byte_1008ED90B = result;
  return result;
}

void sub_1001C69B0()
{
  xmmword_1008ED8D8 = 0u;
  *(_OWORD *)&byte_1008ED8E8 = 0u;
  *(_OWORD *)&unk_1008ED8B8 = 0u;
  *(_OWORD *)&qword_1008ED8C8 = 0u;
  byte_1008ED907 = 0;
  byte_1008ED900 = 0;
  byte_1008ED902 = 0;
  uint64_t v0 = qword_1008ED8F8;
  if (qword_1008ED8F8)
  {
    while (sub_1001EC434(v0))
    {
      uint64_t v1 = (void **)sub_1001EC30C(qword_1008ED8F8);
      sub_1001EC324(qword_1008ED8F8, 0);
      sub_1000B1838(v1[2]);
      sub_1000B1838(v1);
      uint64_t v0 = qword_1008ED8F8;
    }
  }

  sub_1001EC070((void *)qword_1008ED8F8);
  qword_1008ED8F8 = 0LL;
}

uint64_t sub_1001C6A44(uint64_t result)
{
  byte_1008ED901 = result;
  return result;
}

uint64_t sub_1001C6A50()
{
  sub_1001EE0E4( "lRestartScanInProgress=%d lStopInProgress=%d lStartInProgress=%d",  byte_1008ED907,  byte_1008ED900,  byte_1008ED902);
  if (!memcmp(&unk_1008ED8B8, &unk_1006BDD58, 0x40uLL))
  {
    uint64_t result = sub_1001EE0E4("No scan in progress\n");
  }

  else
  {
    sub_1001EE0E4( "Current Scan Parameters: leScanType:%d leScanInterval:0x%x leScanWindow:0x%x scanningFilterPolicy:%d filterDuplicates:%d\n",  xmmword_1008ED8D8,  WORD1(xmmword_1008ED8D8),  WORD2(xmmword_1008ED8D8),  BYTE13(xmmword_1008ED8D8),  BYTE14(xmmword_1008ED8D8));
    uint64_t result = sub_1001EE0E4("scanStartedCb:%sset deviceFoundCb:%sset scanFinishedCb:%sset\n");
  }

  if (byte_1008ED906)
  {
    sub_1001EE0E4("Incomplete advertising packets:\n");
    uint64_t result = qword_1008ED8F8;
    if (qword_1008ED8F8)
    {
      uint64_t result = sub_1001EC434(qword_1008ED8F8);
      if ((_DWORD)result)
      {
        uint64_t result = sub_1001EC43C(qword_1008ED8F8);
        for (i = result; i; uint64_t result = i)
        {
          uint64_t v2 = (unsigned __int8 *)sub_1001EC460(result);
          if (v2[1]) {
            uint64_t v3 = "Public";
          }
          else {
            uint64_t v3 = "Random";
          }
          unint64_t v0 = v0 & 0xFFFF000000000000LL | *(unsigned int *)(v2 + 2) | ((unint64_t)*((unsigned __int16 *)v2 + 3) << 32);
          sub_1001EE0E4( " %s %: responseType:%d dataLen:%d rssi:%d eventType:%d dataStatus:%d primaryPHY:%d secPHY:%d SID:%d txPower: %d periodicInterval:%d\n",  v3,  v0,  *v2,  *((unsigned __int16 *)v2 + 4),  (char)v2[24],  *((unsigned __int16 *)v2 + 13),  v2[28],  v2[29],  v2[30],  v2[31],  v2[32],  *((unsigned __int16 *)v2 + 17));
          sub_1001EC444((uint64_t)&i);
        }
      }
    }
  }

  return result;
}

void sub_1001C6C1C( uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  uint64_t v8 = a1;
  uint64_t v10 = (void (*)(uint64_t, uint64_t))qword_1008ED8C8;
  uint64_t v9 = qword_1008ED8D0;
  if ((_DWORD)a1) {
    goto LABEL_48;
  }
  if (!byte_1008ED905)
  {
    if (byte_1008ED906) {
      uint64_t v13 = sub_1001214B4(216, (uint64_t)sub_1001C713C, a3, a4, a5, a6, a7, a8, 1LL);
    }
    else {
      uint64_t v13 = sub_1001214B4(172, (uint64_t)sub_1001C713C, a3, a4, a5, a6, a7, a8, 1LL);
    }
LABEL_45:
    uint64_t v8 = v13;
    if (!(_DWORD)v13) {
      return;
    }
    goto LABEL_48;
  }

  if (byte_1008ED906) {
    char v11 = 2;
  }
  else {
    char v11 = 1;
  }
  byte_1008ED8E8 = v11;
  if (byte_1008ED904)
  {
    byte_1008ED8E9 = WORD2(xmmword_1008ED8D8) != 0;
    if (WORD3(xmmword_1008ED8D8)) {
      byte_1008ED8E9 = (WORD2(xmmword_1008ED8D8) != 0) | 2;
    }
  }

  if (byte_1008ED908)
  {
    if (WORD5(xmmword_1008ED8D8))
    {
      char v12 = 8;
      goto LABEL_16;
    }

    if (WORD4(xmmword_1008ED8D8))
    {
      char v12 = 4;
LABEL_16:
      byte_1008ED8E9 |= v12;
      if (byte_1008ED8EE) {
        BOOL v14 = WORD2(xmmword_1008ED8D8) == 0;
      }
      else {
        BOOL v14 = 1;
      }
      if (v14) {
        char v15 = 1;
      }
      else {
        char v15 = 5;
      }
      if (byte_1008ED8F2)
      {
        unsigned __int8 v16 = v15 | 8;
        switch(word_1008ED8F6)
        {
          case 0:
            goto LABEL_33;
          case 1:
            unsigned __int8 v16 = v15 | 0x18;
            break;
          case 2:
            unsigned __int8 v16 = v15 | 0x28;
            break;
          case 4:
            unsigned __int8 v16 = v15 | 0x38;
            break;
          default:
            if (sub_1000A86F0())
            {
              sub_1001EE134( (uint64_t)"Unexpected scancore coex query interval %d",  v17,  v18,  v19,  v20,  v21,  v22,  v23,  (unsigned __int16)word_1008ED8F6);
              uint64_t v24 = (os_log_s *)sub_100086554(0x42u);
              if (os_log_type_enabled(v24, OS_LOG_TYPE_ERROR)) {
                sub_100657858();
              }
            }

            break;
        }
      }

      else
      {
        unsigned __int8 v16 = v15;
      }

      goto LABEL_33;
    }
  }

  unsigned __int8 v16 = 1;
LABEL_33:
  if (byte_1008ED90B)
  {
    if (byte_1008ED8F0 && byte_1008ED8F1)
    {
      v16 |= 0x80u;
    }

    else
    {
      if (byte_1008ED8F1) {
        unsigned __int8 v25 = v16 | 0xC0;
      }
      else {
        unsigned __int8 v25 = v16;
      }
      if (byte_1008ED8F0) {
        v16 |= 0x40u;
      }
      else {
        unsigned __int8 v16 = v25;
      }
    }
  }

  if (byte_1008ED8E9)
  {
    uint64_t v13 = sub_10018E4B0( v16,  byte_1008ED8E8,  BYTE14(xmmword_1008ED8D8),  HIBYTE(xmmword_1008ED8D8),  byte_1008ED8E9);
    goto LABEL_45;
  }

  uint64_t v8 = 408LL;
LABEL_48:
  if (sub_1000A86F0())
  {
    sub_1001EE134((uint64_t)"Could not start LE scan (leScanParamsCb): %!", v26, v27, v28, v29, v30, v31, v32, v8);
    char v33 = (os_log_s *)sub_100086554(0x42u);
    if (os_log_type_enabled(v33, OS_LOG_TYPE_ERROR)) {
      sub_100657858();
    }
  }

  xmmword_1008ED8D8 = 0u;
  *(_OWORD *)&byte_1008ED8E8 = 0u;
  *(_OWORD *)&unk_1008ED8B8 = 0u;
  *(_OWORD *)&qword_1008ED8C8 = 0u;
  byte_1008ED902 = 0;
  if (v10) {
    v10(v8, v9);
  }
  else {
    sub_1001EE2A0();
  }
}

void sub_1001C6EFC( uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  uint64_t v8 = a1;
  uint64_t v10 = (void (*)(uint64_t, uint64_t))qword_1008ED8C8;
  uint64_t v9 = qword_1008ED8D0;
  char v34 = xmmword_1008ED8D8;
  __int16 v33 = WORD1(xmmword_1008ED8D8);
  __int16 v11 = WORD5(xmmword_1008ED8D8);
  if (WORD5(xmmword_1008ED8D8) | WORD4(xmmword_1008ED8D8)) {
    BOOL v12 = WORD1(xmmword_1008ED8D8) == 0;
  }
  else {
    BOOL v12 = 1;
  }
  if (v12 || byte_1008ED908 == 0) {
    goto LABEL_9;
  }
  *(_DWORD *)&v35[3] = 0;
  *(_DWORD *)uint64_t v35 = 0;
  if (WORD5(xmmword_1008ED8D8) && WORD4(xmmword_1008ED8D8))
  {
    if (sub_1000A86F0())
    {
      sub_1001EE134( (uint64_t)"ELNAOn and ELNAByass cannot be used with ScanCore together leScanWindowScanCoreELNAOn=%d leScanWindowSc anCoreELNABypass=%d",  v14,  v15,  v16,  v17,  v18,  v19,  v20,  WORD3(xmmword_1008ED8D8));
      uint64_t v21 = (os_log_s *)sub_100086554(0x42u);
      if (os_log_type_enabled(v21, OS_LOG_TYPE_ERROR)) {
        sub_100657858();
      }
    }

    sub_1001C6C1C(v8, v14, v15, v16, v17, v18, v19, v20);
    return;
  }

  if (WORD4(xmmword_1008ED8D8))
  {
    __int16 v11 = WORD4(xmmword_1008ED8D8);
    unsigned int v22 = 4;
  }

  else
  {
    unsigned int v22 = 8;
  }

  __int16 v32 = v11;
  if (!(_DWORD)a1)
  {
    if (byte_1008ED905)
    {
      sub_1001BDFB4((uint64_t)v35);
      if (byte_1008ED906) {
        uint64_t v31 = 2LL;
      }
      else {
        uint64_t v31 = 1LL;
      }
      byte_1008ED8E8 = v31;
      sub_10018E65C(v35[0], BYTE13(xmmword_1008ED8D8), 1LL, (uint64_t)&v34, (uint64_t)&v33, (uint64_t)&v32, v31, v22);
      return;
    }

    a1 = 0LL;
LABEL_9:
    sub_1001C6C1C(a1, a2, a3, a4, a5, a6, a7, a8);
    return;
  }

  if (sub_1000A86F0())
  {
    sub_1001EE134( (uint64_t)"Could not start LE scan (leScanParamsScanCoreCb): %!",  v23,  v24,  v25,  v26,  v27,  v28,  v29,  v8);
    uint64_t v30 = (os_log_s *)sub_100086554(0x42u);
    if (os_log_type_enabled(v30, OS_LOG_TYPE_ERROR)) {
      sub_100657858();
    }
  }

  xmmword_1008ED8D8 = 0u;
  *(_OWORD *)&byte_1008ED8E8 = 0u;
  *(_OWORD *)&unk_1008ED8B8 = 0u;
  *(_OWORD *)&qword_1008ED8C8 = 0u;
  byte_1008ED902 = 0;
  if (v10) {
    v10(v8, v9);
  }
  else {
    sub_1001EE2A0();
  }
}

void sub_1001C713C(uint64_t a1)
{
  if ((_DWORD)a1) {
    goto LABEL_4;
  }
  if (byte_1008ED909)
  {
    a1 = sub_10018E970();
LABEL_4:
    sub_1001C718C(a1);
    return;
  }

  sub_1001C7248(0LL);
}

void sub_1001C718C(uint64_t a1)
{
  if ((_DWORD)a1)
  {
    uint64_t v3 = (void (*)(uint64_t, uint64_t))qword_1008ED8C8;
    uint64_t v2 = qword_1008ED8D0;
    if (sub_1000A86F0())
    {
      sub_1001EE134((uint64_t)"Reset scan in LE_Scan: %! for location %d", v4, v5, v6, v7, v8, v9, v10, a1);
      __int16 v11 = (os_log_s *)sub_100086554(0x42u);
      if (os_log_type_enabled(v11, OS_LOG_TYPE_ERROR)) {
        sub_100657858();
      }
    }

    xmmword_1008ED8D8 = 0u;
    *(_OWORD *)&byte_1008ED8E8 = 0u;
    unk_1008ED8B8 = 0u;
    *(_OWORD *)&qword_1008ED8C8 = 0u;
    byte_1008ED902 = 0;
    if (v3) {
      v3(a1, v2);
    }
    else {
      sub_1001EE2A0();
    }
  }

void sub_1001C7248(uint64_t a1)
{
  if ((_DWORD)a1) {
    goto LABEL_2;
  }
  if (byte_1008ED904 && (byte_1008ED90A & 1) == 0)
  {
    a1 = sub_10018EB2C();
    byte_1008ED90A = 1;
LABEL_2:
    sub_1001C718C(a1);
    return;
  }

  byte_1008ED902 = 0;
  if (unk_1008ED8B8) {
    unk_1008ED8B8(0LL, qword_1008ED8D0);
  }
}

void sub_1001C72DC(uint64_t a1)
{
  uint64_t v2 = (void (*)(uint64_t, uint64_t))qword_1008ED8C8;
  uint64_t v1 = qword_1008ED8D0;
  byte_1008ED902 = 0;
  if ((_DWORD)a1)
  {
    if (sub_1000A86F0())
    {
      sub_1001EE134((uint64_t)"Could not start LE scan callback: %!", v4, v5, v6, v7, v8, v9, v10, a1);
      __int16 v11 = (os_log_s *)sub_100086554(0x42u);
      if (os_log_type_enabled(v11, OS_LOG_TYPE_ERROR)) {
        sub_100657858();
      }
    }

    xmmword_1008ED8D8 = 0u;
    *(_OWORD *)&byte_1008ED8E8 = 0u;
    *(_OWORD *)&unk_1008ED8B8 = 0u;
    *(_OWORD *)&qword_1008ED8C8 = 0u;
    if (v2) {
      v2(a1, v1);
    }
    else {
      sub_1001EE2A0();
    }
  }

  else if (unk_1008ED8B8)
  {
    unk_1008ED8B8(0LL, qword_1008ED8D0);
  }

uint64_t sub_1001C73B8(uint64_t result)
{
  qword_1008ED910 = result;
  return result;
}

void sub_1001C73C4(uint64_t a1, uint64_t a2, uint64_t a3)
{
  if (sub_10012D5EC(a2))
  {
    if ((_DWORD)a1)
    {
      if (sub_1000A86F0())
      {
        sub_1001EE134((uint64_t)"Failed to encrypt connection %!.", v6, v7, v8, v9, v10, v11, v12, a1);
        uint64_t v13 = (os_log_s *)sub_100086554(0x43u);
        if (os_log_type_enabled(v13, OS_LOG_TYPE_ERROR)) {
          sub_100657858();
        }
      }

      *(_BYTE *)(a2 + 167) = 0;
      if ((_DWORD)a1 == 708)
      {
        *(_DWORD *)(a2 + 132) = 6;
        *(_DWORD *)(a2 + 140) = 4834;
      }

      *(_BYTE *)(a2 + 166) = (_DWORD)a3 != 0;
    }

    else
    {
      *(_BYTE *)(a2 + 166) = (_DWORD)a3 != 0;
      *(_BYTE *)(a2 + 168) = *(_BYTE *)(a2 + 169);
      *(_BYTE *)(a2 + 208) = 1;
    }

    sub_1001D1C54(a2, a1, (_DWORD)a3 != 0);
    __int16 v22 = xmmword_1008ED960;
    if ((__int16)xmmword_1008ED960 >= 1)
    {
      uint64_t v23 = 0LL;
      uint64_t v24 = (void (**)(uint64_t, uint64_t, uint64_t, uint64_t))&xmmword_1008ED960 + 1;
      do
      {
        if (*v24)
        {
          (*v24)(a2, a1, a3, qword_1008ED938);
          __int16 v22 = xmmword_1008ED960;
        }

        ++v23;
        v24 += 3;
      }

      while (v23 < v22);
    }

    sub_1001D1CAC(a2, a1, a3 != 0);
  }

  else if (sub_1000A86F0())
  {
    sub_1001EE134((uint64_t)"This handle is not a LE connection.", v14, v15, v16, v17, v18, v19, v20, v25);
    uint64_t v21 = (os_log_s *)sub_100086554(0x43u);
    if (os_log_type_enabled(v21, OS_LOG_TYPE_ERROR)) {
      sub_100657858();
    }
  }

void sub_1001C7558(uint64_t a1, _BYTE *a2)
{
  if (sub_10012D5EC((uint64_t)a2))
  {
    if ((_DWORD)a1)
    {
      if (sub_1000A86F0())
      {
        sub_1001EE134((uint64_t)"Failed to refresh connection %!.", v4, v5, v6, v7, v8, v9, v10, a1);
        uint64_t v11 = (os_log_s *)sub_100086554(0x43u);
        if (os_log_type_enabled(v11, OS_LOG_TYPE_ERROR)) {
          sub_100657858();
        }
      }

      a2[166] = 0;
    }

    else
    {
      a2[166] = 1;
      a2[168] = a2[169];
      sub_1001D1C54((uint64_t)a2, 0, 1);
      __int16 v20 = xmmword_1008ED960;
      if ((__int16)xmmword_1008ED960 >= 1)
      {
        uint64_t v21 = 0LL;
        __int16 v22 = (char *)&xmmword_1008ED960 + 8;
        do
        {
          if (*(void *)v22)
          {
            (*(void (**)(_BYTE *, void, uint64_t, uint64_t))v22)(a2, 0LL, 1LL, qword_1008ED938);
            __int16 v20 = xmmword_1008ED960;
          }

          ++v21;
          v22 += 24;
        }

        while (v21 < v20);
      }

      sub_1001D1CAC((uint64_t)a2, 0, 1);
    }
  }

  else if (sub_1000A86F0())
  {
    sub_1001EE134((uint64_t)"This handle is not a LE connection.", v12, v13, v14, v15, v16, v17, v18, v23);
    uint64_t v19 = (os_log_s *)sub_100086554(0x43u);
    if (os_log_type_enabled(v19, OS_LOG_TYPE_ERROR)) {
      sub_100657858();
    }
  }

void sub_1001C76B8(int a1, void *a2, uint64_t a3)
{
  uint64_t v51 = 0LL;
  __int128 v50 = 0uLL;
  char v48 = 0;
  uint64_t v5 = sub_10012D6D8(a1);
  uint64_t v49 = v5;
  if (v5)
  {
    uint64_t v6 = (uint64_t)v5;
    if (sub_10012D5EC((uint64_t)v5))
    {
      if (!(_DWORD)a3 && *a2 == v51 && sub_1001CBF3C((_DWORD *)(v6 + 48)))
      {
        if (sub_1001D288C(v6, &v50, &v48))
        {
          if (!sub_1001214B4(186, (uint64_t)sub_1001C7910, v7, v8, v9, v10, v11, v12, v6))
          {
            *(_BYTE *)(v6 + 169) = v48;
            *(_BYTE *)(v6 + 166) = 2;
          }
        }

        else
        {
          if (sub_1000A86F0())
          {
            sub_1001EE134((uint64_t)"Rejecting key request", v38, v39, v40, v41, v42, v43, v44, v46);
            uint64_t v45 = (os_log_s *)sub_100086554(0x43u);
            if (os_log_type_enabled(v45, OS_LOG_TYPE_ERROR)) {
              sub_100657858();
            }
          }

          sub_1001214B4(187, 0LL, v39, v40, v41, v42, v43, v44, v6);
        }
      }

      else if (unk_1008ED920)
      {
        if (*(_BYTE *)(v6 + 55)) {
          uint64_t v21 = v6 + 56;
        }
        else {
          uint64_t v21 = v6 + 48;
        }
        unk_1008ED920(v21, a2, a3, qword_1008ED938);
        v47[1] = &v49;
        v47[0] = (const void *)8;
        if (sub_1001EE6E8((uint64_t)sub_1001C7948, v47, 5000, (int *)(v6 + 184)))
        {
          if (sub_1000A86F0())
          {
            sub_1001EE134((uint64_t)"Failed to set key request timeout CB", v22, v23, v24, v25, v26, v27, v28, v46);
            uint64_t v29 = (os_log_s *)sub_100086554(0x43u);
            if (os_log_type_enabled(v29, OS_LOG_TYPE_ERROR)) {
              sub_100657858();
            }
          }
        }
      }

      else if (sub_1000A86F0())
      {
        sub_1001EE134((uint64_t)"No callbacks, ignoring request", v30, v31, v32, v33, v34, v35, v36, v46);
        uint64_t v37 = (os_log_s *)sub_100086554(0x43u);
        if (os_log_type_enabled(v37, OS_LOG_TYPE_ERROR)) {
          sub_100657858();
        }
      }
    }

    else if (sub_1000A86F0())
    {
      sub_1001EE134((uint64_t)"This handle is not a LE connection, ignoring", v13, v14, v15, v16, v17, v18, v19, v46);
      __int16 v20 = (os_log_s *)sub_100086554(0x43u);
      if (os_log_type_enabled(v20, OS_LOG_TYPE_ERROR)) {
        sub_100657858();
      }
    }
  }

BOOL sub_1001C7910(BOOL result, uint64_t a2)
{
  if (result && a2)
  {
    uint64_t result = sub_10012D5EC(a2);
    if (result)
    {
      *(_BYTE *)(a2 + 166) = 0;
      *(_BYTE *)(a2 + 169) = 0;
    }
  }

  return result;
}

void sub_1001C7948(uint64_t a1)
{
  uint64_t v1 = *(uint64_t **)(a1 + 8);
  uint64_t v2 = *v1;
  if (*v1 && sub_10012D5EC(*v1))
  {
    *(_DWORD *)(v2 + 184) = 0;
    if (sub_1000A86F0())
    {
      sub_1001EE134( (uint64_t)"Timeout waiting for the response - we rejected the request for Key length",  v3,  v4,  v5,  v6,  v7,  v8,  v9,  v19);
      uint64_t v10 = (os_log_s *)sub_100086554(0x43u);
      if (os_log_type_enabled(v10, OS_LOG_TYPE_ERROR)) {
        sub_100657858();
      }
    }

    sub_1001214B4(187, 0LL, v4, v5, v6, v7, v8, v9, v2);
  }

  else if (sub_1000A86F0())
  {
    sub_1001EE134((uint64_t)"This handle is not a LE connection.", v11, v12, v13, v14, v15, v16, v17, v19);
    uint64_t v18 = (os_log_s *)sub_100086554(0x43u);
    if (os_log_type_enabled(v18, OS_LOG_TYPE_ERROR)) {
      sub_100657858();
    }
  }

uint64_t sub_1001C7A18(_DWORD *a1, uint64_t *a2, __int16 a3, uint64_t a4, char a5)
{
  v60[0] = 0LL;
  v60[1] = 0LL;
  if (!a1)
  {
    sub_1001EE134((uint64_t)"Invalid address", v21, v22, v23, v24, v25, v26, v27, v57);
    uint64_t v28 = (os_log_s *)sub_100086554(0x43u);
    if (!os_log_type_enabled(v28, OS_LOG_TYPE_ERROR)) {
      return 101LL;
    }
LABEL_20:
    sub_100657858();
    return 101LL;
  }

  if (!a2)
  {
    sub_1001EE134((uint64_t)"randomNumber cannot be NULL", v29, v30, v31, v32, v33, v34, v35, v57);
    uint64_t v36 = (os_log_s *)sub_100086554(0x43u);
    if (!os_log_type_enabled(v36, OS_LOG_TYPE_ERROR)) {
      return 101LL;
    }
    goto LABEL_20;
  }

  uint64_t v9 = sub_10012D98C(a1);
  uint64_t v59 = v9;
  if (!v9) {
    return 122LL;
  }
  uint64_t v10 = v9;
  if (!sub_10012D5EC(v9))
  {
    if (sub_1000A86F0())
    {
      sub_1001EE134((uint64_t)"This handle is not a LE connection, ignoring", v37, v38, v39, v40, v41, v42, v43, v57);
      uint64_t v44 = (os_log_s *)sub_100086554(0x43u);
      if (os_log_type_enabled(v44, OS_LOG_TYPE_ERROR)) {
        sub_100657858();
      }
    }

    return 122LL;
  }

  uint64_t v11 = *(unsigned int *)(v10 + 184);
  if ((_DWORD)v11)
  {
    sub_1001EEB14(v11);
    *(_DWORD *)(v10 + 184) = 0;
  }

  if (!(_DWORD)a4)
  {
    if (sub_1000A86F0())
    {
      sub_1001EE134((uint64_t)"Keysize=0 - no key present", v45, v14, v15, v16, v17, v18, v19, v57);
      uint64_t v46 = (os_log_s *)sub_100086554(0x43u);
      if (os_log_type_enabled(v46, OS_LOG_TYPE_ERROR)) {
        sub_100657858();
      }
    }

    uint64_t v12 = 0LL;
    goto LABEL_30;
  }

  if ((a5 & 0xFE) != 2)
  {
    uint64_t v12 = sub_1001D29BC(a2, a3, v60);
    if ((_DWORD)v12) {
      return v12;
    }
    uint64_t v47 = (_DWORD *)(*(_BYTE *)(v10 + 55) ? v10 + 56 : v10 + 48);
LABEL_30:
    sub_1001214B4(187, 0LL, v14, v15, v16, v17, v18, v19, v10);
    return v12;
  }

  if (off_1008ED928)
  {
    v58[1] = &v59;
    v58[0] = (const void *)8;
    uint64_t v12 = sub_1001EE6E8((uint64_t)sub_1001C7D14, v58, 0, 0LL);
    if (!(_DWORD)v12)
    {
      *(_BYTE *)(v59 + 166) = 3;
      return v12;
    }

    if (sub_1000A86F0())
    {
      sub_1001EE134( (uint64_t)"OI_Dispatch_RegisterTimedFunc failed to set key len request timeout %!",  v13,  v14,  v15,  v16,  v17,  v18,  v19,  v12);
      __int16 v20 = (os_log_s *)sub_100086554(0x43u);
      if (os_log_type_enabled(v20, OS_LOG_TYPE_ERROR)) {
        sub_100657858();
      }
    }

    uint64_t v10 = v59;
    goto LABEL_30;
  }

  if (sub_1000A86F0())
  {
    sub_1001EE134((uint64_t)"No callbacks, ignoring request", v48, v49, v50, v51, v52, v53, v54, v57);
    uint64_t v55 = (os_log_s *)sub_100086554(0x43u);
    if (os_log_type_enabled(v55, OS_LOG_TYPE_ERROR)) {
      sub_100657858();
    }
  }

  return 0LL;
}

void sub_1001C7D14(uint64_t a1)
{
  uint64_t v1 = **(void **)(a1 + 8);
  uint64_t v21 = v1;
  if (off_1008ED928)
  {
    v20[0] = 0LL;
    if (v1 && sub_10012D5EC(v1))
    {
      v20[1] = &v21;
      LOWORD(v20[0]) = 8;
      if (sub_1001EE6E8((uint64_t)sub_1001C9C34, v20, 5000, (int *)(v1 + 180)))
      {
        if (sub_1000A86F0())
        {
          sub_1001EE134((uint64_t)"Failed to set key request timeout CB", v2, v3, v4, v5, v6, v7, v8, v19);
          uint64_t v9 = (os_log_s *)sub_100086554(0x43u);
          if (os_log_type_enabled(v9, OS_LOG_TYPE_ERROR)) {
            sub_100657858();
          }
        }
      }

      else
      {
        if (*(_BYTE *)(v21 + 55)) {
          uint64_t v18 = v21 + 56;
        }
        else {
          uint64_t v18 = v21 + 48;
        }
        off_1008ED928(v18, qword_1008ED938);
      }
    }

    else if (sub_1000A86F0())
    {
      sub_1001EE134((uint64_t)"This handle is not a LE connection.", v10, v11, v12, v13, v14, v15, v16, v19);
      uint64_t v17 = (os_log_s *)sub_100086554(0x43u);
      if (os_log_type_enabled(v17, OS_LOG_TYPE_ERROR)) {
        sub_100657858();
      }
    }
  }

uint64_t sub_1001C7E38(_DWORD *a1, uint64_t a2, uint64_t a3, char a4)
{
  v58[0] = 0LL;
  v58[1] = 0LL;
  if (!a1)
  {
    sub_1001EE134((uint64_t)"Invalid address", v17, v18, v19, v20, v21, v22, v23, v57);
    uint64_t v24 = (os_log_s *)sub_100086554(0x43u);
    if (!os_log_type_enabled(v24, OS_LOG_TYPE_ERROR)) {
      return 101LL;
    }
LABEL_18:
    sub_100657858();
    return 101LL;
  }

  if (!a2)
  {
    sub_1001EE134((uint64_t)"Invalid *key specified", v34, v35, v36, v37, v38, v39, v40, v57);
    uint64_t v41 = (os_log_s *)sub_100086554(0x43u);
    if (!os_log_type_enabled(v41, OS_LOG_TYPE_ERROR)) {
      return 101LL;
    }
    goto LABEL_18;
  }

  uint64_t v7 = sub_10012D98C(a1);
  if (v7 && (uint64_t v8 = (_BYTE *)v7, sub_10012D5EC(v7)))
  {
    if ((a3 - 17) <= 0xFFFFFFEF)
    {
      sub_1001EE134((uint64_t)"LTK length is too big : %d.", v9, v10, v11, v12, v13, v14, v15, a3);
      uint64_t v16 = (os_log_s *)sub_100086554(0x43u);
      if (!os_log_type_enabled(v16, OS_LOG_TYPE_ERROR)) {
        return 101LL;
      }
      goto LABEL_18;
    }

    __memmove_chk(v58, a2, a3, 16LL);
    uint64_t v33 = sub_1001214B4(186, (uint64_t)sub_1001C7910, v43, v44, v45, v46, v47, v48, (uint64_t)v8);
    if ((_DWORD)v33)
    {
      if (sub_1000A86F0())
      {
        sub_1001EE134((uint64_t)"Could not send long term key response %!.", v49, v50, v51, v52, v53, v54, v55, v33);
        uint64_t v56 = (os_log_s *)sub_100086554(0x43u);
        if (os_log_type_enabled(v56, OS_LOG_TYPE_ERROR)) {
          sub_100657858();
        }
      }

      v8[167] = 0;
    }

    else
    {
      v8[167] = a3;
      v8[169] = a4;
      v8[166] = 2;
    }
  }

  else
  {
    if (sub_1000A86F0())
    {
      sub_1001EE134((uint64_t)"This handle is not a LE connection.", v25, v26, v27, v28, v29, v30, v31, v57);
      uint64_t v32 = (os_log_s *)sub_100086554(0x43u);
      if (os_log_type_enabled(v32, OS_LOG_TYPE_ERROR)) {
        sub_100657858();
      }
    }

    return 1310LL;
  }

  return v33;
}

uint64_t sub_1001C8074()
{
  byte_1008EDA28 = 0;
  xmmword_1008EDA29 = 0u;
  unk_1008EDA39 = 0u;
  xmmword_1008EDA49 = 0u;
  unk_1008EDA59 = 0u;
  xmmword_1008EDA69 = 0u;
  unk_1008EDA79 = 0u;
  xmmword_1008EDA89 = 0u;
  unk_1008EDA99 = 0u;
  xmmword_1008EDAA9 = 0u;
  unk_1008EDAB9 = 0u;
  xmmword_1008EDAC9 = 0u;
  dword_1008EDAD9 = 0;
  return 0LL;
}

uint64_t sub_1001C80AC(int *a1, char a2)
{
  if (a1)
  {
    if ((a2 & 1) != 0)
    {
      uint64_t v2 = 0LL;
      unsigned __int8 v3 = 20;
      uint64_t v4 = &xmmword_1008EDA29;
      do
      {
        int v5 = *((unsigned __int8 *)v4 + 7);
        if (*((_BYTE *)v4 + 7))
        {
          if (*(_DWORD *)v4 == *a1 && *(_DWORD *)((char *)v4 + 3) == *(int *)((char *)a1 + 3))
          {
            if (*((_BYTE *)v4 + 8)) {
              return 0LL;
            }
            *((_BYTE *)v4 + 8) = 1;
          }
        }

        if (v3 == 20 && v5 == 0) {
          unsigned __int8 v3 = v2;
        }
        ++v2;
        uint64_t v4 = (__int128 *)((char *)v4 + 9);
      }

      while (v2 != 20);
      if (v3 > 0x13u)
      {
        if (sub_1000A86F0())
        {
          sub_1001EE134( (uint64_t)"Could not find a free slot for this device (DB FULL). Aborting.",  v16,  v17,  v18,  v19,  v20,  v21,  v22,  v25);
          uint64_t v23 = (os_log_s *)sub_100086554(0x43u);
          if (os_log_type_enabled(v23, OS_LOG_TYPE_ERROR)) {
            sub_100657858();
          }
        }

        return 104LL;
      }

      else
      {
        uint64_t v8 = 0LL;
        uint64_t v9 = (char *)&xmmword_1008EDA29 + 9 * v3;
        v9[7] = 1;
        int v10 = *a1;
        *(_DWORD *)(v9 + 3) = *(int *)((char *)a1 + 3);
        *(_DWORD *)uint64_t v9 = v10;
        v9[8] = 1;
      }
    }

    else
    {
      uint64_t v11 = 0LL;
      while (1)
      {
        uint64_t v12 = (int *)((char *)&xmmword_1008EDA29 + v11);
        if (*((_BYTE *)&xmmword_1008EDA29 + v11 + 7))
        {
          int v13 = *v12;
          int v14 = *(int *)((char *)v12 + 3);
        }

        v11 += 9LL;
        if (v11 == 180) {
          return 120LL;
        }
      }

      uint64_t v8 = 0LL;
      *((_BYTE *)&xmmword_1008EDA29 + v11 + 7) = 0;
    }
  }

  else
  {
    uint64_t v8 = 0LL;
    byte_1008EDA28 = a2;
  }

  return v8;
}

BOOL sub_1001C822C(_DWORD *a1, _DWORD *a2)
{
  if (a1)
  {
    if (byte_1008EDA28) {
      return 1LL;
    }
    uint64_t v12 = 0LL;
    while (1)
    {
      int v13 = (int *)((char *)&xmmword_1008EDA29 + v12);
      if (*((_BYTE *)&xmmword_1008EDA29 + v12 + 7))
      {
        if (a2)
        {
          int v15 = *v13;
          int v16 = *(int *)((char *)v13 + 3);
        }
      }

      v12 += 9LL;
      if (v12 == 180) {
        return 0LL;
      }
    }

    uint64_t v11 = (char *)&xmmword_1008EDA29 + v12 + 8;
  }

  else
  {
    if (sub_1000A86F0())
    {
      sub_1001EE134((uint64_t)"Invalid address, checking global OOB flag", v3, v4, v5, v6, v7, v8, v9, v18);
      int v10 = (os_log_s *)sub_100086554(0x43u);
      if (os_log_type_enabled(v10, OS_LOG_TYPE_ERROR)) {
        sub_100657858();
      }
    }

    uint64_t v11 = &byte_1008EDA28;
  }

  return *v11 != 0;
}

uint64_t sub_1001C8324(_OWORD *a1, int a2, int a3, char a4, char a5)
{
  v25[0] = *(_OWORD *)off_100886070;
  v25[1] = *(_OWORD *)&off_100886080;
  LODWORD(xmmword_1008F7014) = 1;
  if (BYTE9(xmmword_1008F6D58))
  {
    if (unk_1008ED920) {
      BOOL v5 = 0;
    }
    else {
      BOOL v5 = off_1008ED928 == 0LL;
    }
    if (v5 && off_1008ED930 == 0LL)
    {
      __int128 v24 = a1[1];
      *(_OWORD *)&unk_1008ED920 = *a1;
      *(_OWORD *)&off_1008ED930 = v24;
      return sub_1001D3434( (uint64_t (*)(void, void, void, void, void))sub_1001C84A8,  (uint64_t)v25,  (uint64_t (*)(void, void, void, void))sub_1001C84C4,  a2,  a3,  a4,  a5);
    }

    else
    {
      if (sub_1000A86F0())
      {
        sub_1001EE134( (uint64_t)"Someone is already listening for LE security events.",  v7,  v8,  v9,  v10,  v11,  v12,  v13,  *(uint64_t *)&v25[0]);
        int v14 = (os_log_s *)sub_100086554(0x43u);
        if (os_log_type_enabled(v14, OS_LOG_TYPE_ERROR)) {
          sub_100657858();
        }
      }

      return 119LL;
    }
  }

  else
  {
    if (sub_1000A86F0())
    {
      sub_1001EE134( (uint64_t)"LE not supported, can't register SMP.",  v16,  v17,  v18,  v19,  v20,  v21,  v22,  *(uint64_t *)&v25[0]);
      uint64_t v23 = (os_log_s *)sub_100086554(0x43u);
      if (os_log_type_enabled(v23, OS_LOG_TYPE_ERROR)) {
        sub_100657858();
      }
    }

    return 147LL;
  }

uint64_t sub_1001C8454(uint64_t result, uint64_t a2)
{
  if (unk_1008ED940) {
    return unk_1008ED940(result, a2, qword_1008ED958);
  }
  return result;
}

uint64_t sub_1001C8470(uint64_t result)
{
  if (off_1008ED948) {
    return off_1008ED948(result, qword_1008ED958);
  }
  return result;
}

uint64_t sub_1001C848C(_DWORD *a1, uint64_t a2, uint64_t a3)
{
  if (off_1008ED950) {
    return off_1008ED950(a1, a2, a3, qword_1008ED958);
  }
  else {
    return sub_1001CBD38(a1);
  }
}

uint64_t sub_1001C84A8(uint64_t result, uint64_t a2, uint64_t a3, uint64_t a4)
{
  if (off_1008ED930) {
    return off_1008ED930(result, a2, a3, a4, qword_1008ED938);
  }
  return result;
}

uint64_t sub_1001C84C4(uint64_t result, uint64_t a2, uint64_t a3)
{
  __int16 v3 = xmmword_1008ED960;
  if ((__int16)xmmword_1008ED960 >= 1)
  {
    uint64_t v6 = result;
    uint64_t v7 = 0LL;
    uint64_t v8 = &qword_1008ED978;
    do
    {
      uint64_t v9 = (uint64_t (*)(uint64_t, uint64_t, uint64_t, uint64_t))*(v8 - 1);
      if (v9)
      {
        uint64_t result = v9(v6, a2, a3, *v8);
        __int16 v3 = xmmword_1008ED960;
      }

      ++v7;
      v8 += 3;
    }

    while (v7 < v3);
  }

  return result;
}

uint64_t sub_1001C8544(uint64_t a1)
{
  if (!BYTE9(xmmword_1008F6D58)) {
    return 0LL;
  }
  if (unk_1008ED920 == *(uint64_t (**)(void, void, void, void))a1
    && off_1008ED928 == *(uint64_t (**)(void, void))(a1 + 8)
    && off_1008ED930 == *(uint64_t (**)(void, void, void, void, void))(a1 + 16))
  {
    uint64_t result = sub_1001D3604();
    if (!(_DWORD)result)
    {
      qword_1008EDA20 = 0LL;
      xmmword_1008EDA00 = 0u;
      unk_1008EDA10 = 0u;
      xmmword_1008ED9E0 = 0u;
      unk_1008ED9F0 = 0u;
      xmmword_1008ED9C0 = 0u;
      unk_1008ED9D0 = 0u;
      xmmword_1008ED9A0 = 0u;
      unk_1008ED9B0 = 0u;
      xmmword_1008ED980 = 0u;
      unk_1008ED990 = 0u;
      xmmword_1008ED960 = 0u;
      *(_OWORD *)&qword_1008ED970 = 0u;
      *(_OWORD *)&unk_1008ED940 = 0u;
      *(_OWORD *)&off_1008ED950 = 0u;
      *(_OWORD *)&unk_1008ED920 = 0u;
      *(_OWORD *)&off_1008ED930 = 0u;
    }

    qword_1008EDAE0 = 0LL;
    word_1008EDAE8 = 0;
    LODWORD(xmmword_1008F7014) = 0;
  }

  else
  {
    if (sub_1000A86F0())
    {
      sub_1001EE134((uint64_t)"You need to unregister the correct callbacks", v1, v2, v3, v4, v5, v6, v7, v10);
      uint64_t v8 = (os_log_s *)sub_100086554(0x43u);
      if (os_log_type_enabled(v8, OS_LOG_TYPE_ERROR)) {
        sub_100657858();
      }
    }

    return 101LL;
  }

  return result;
}

__n128 sub_1001C864C(uint64_t a1)
{
  if (BYTE9(xmmword_1008F6D58))
  {
    if (unk_1008ED940) {
      BOOL v1 = 0;
    }
    else {
      BOOL v1 = off_1008ED948 == 0LL;
    }
    if (v1 && off_1008ED950 == 0LL)
    {
      __n128 result = *(__n128 *)a1;
      __int128 v12 = *(_OWORD *)(a1 + 16);
      *(_OWORD *)&unk_1008ED940 = *(_OWORD *)a1;
      *(_OWORD *)&off_1008ED950 = v12;
    }

    else if (sub_1000A86F0())
    {
      sub_1001EE134((uint64_t)"Someone is already listening for LE pairing events.", v3, v4, v5, v6, v7, v8, v9, v13);
      uint64_t v11 = (os_log_s *)sub_100086554(0x43u);
      if (os_log_type_enabled(v11, OS_LOG_TYPE_ERROR)) {
        sub_100657858();
      }
    }
  }

  return result;
}

double sub_1001C86F4(uint64_t a1)
{
  if (BYTE9(xmmword_1008F6D58))
  {
    if (unk_1008ED940 == *(uint64_t (**)(void, void, void))a1
      && off_1008ED948 == *(uint64_t (**)(void, void))(a1 + 8)
      && off_1008ED950 == *(uint64_t (**)(void, void, void, void))(a1 + 16))
    {
      double result = 0.0;
      *(_OWORD *)&unk_1008ED940 = 0u;
      *(_OWORD *)&off_1008ED950 = 0u;
    }

    else if (sub_1000A86F0())
    {
      sub_1001EE134((uint64_t)"You need to unregister the correct callbacks", v1, v2, v3, v4, v5, v6, v7, v10);
      uint64_t v9 = (os_log_s *)sub_100086554(0x43u);
      if (os_log_type_enabled(v9, OS_LOG_TYPE_ERROR)) {
        sub_100657858();
      }
    }
  }

  return result;
}

__n128 sub_1001C87BC(__n128 *a1)
{
  if (BYTE9(xmmword_1008F6D58))
  {
    __int16 v1 = xmmword_1008ED960;
    if ((__int16)xmmword_1008ED960 < 8LL)
    {
      uint64_t v11 = (char *)&unk_1008ED920 + 24 * (__int16)xmmword_1008ED960;
      __n128 result = *a1;
      *(__n128 *)(v11 + 72) = *a1;
      *((void *)v11 + 11) = a1[1].n128_u64[0];
      LOWORD(xmmword_1008ED960) = v1 + 1;
    }

    else if (sub_1000A86F0())
    {
      sub_1001EE134((uint64_t)"Too many callbacks registered.", v2, v3, v4, v5, v6, v7, v8, v12);
      uint64_t v10 = (os_log_s *)sub_100086554(0x43u);
      if (os_log_type_enabled(v10, OS_LOG_TYPE_ERROR)) {
        sub_100657858();
      }
    }
  }

  return result;
}

uint64_t sub_1001C8874(void *a1)
{
  if (!BYTE9(xmmword_1008F6D58)) {
    return 0LL;
  }
  __int16 v1 = xmmword_1008ED960;
  if (!(_WORD)xmmword_1008ED960)
  {
    uint64_t result = sub_1000A86F0();
    if (!(_DWORD)result) {
      return result;
    }
    sub_1001EE134((uint64_t)"No callbacks registered.", v13, v14, v15, v16, v17, v18, v19, v24);
    uint64_t v20 = (os_log_s *)sub_100086554(0x43u);
    uint64_t result = os_log_type_enabled(v20, OS_LOG_TYPE_ERROR);
    if (!(_DWORD)result) {
      return result;
    }
    sub_100657858();
    return 0LL;
  }

  if ((__int16)xmmword_1008ED960 < 1)
  {
LABEL_8:
    if (sub_1000A86F0())
    {
      sub_1001EE134((uint64_t)"You need to unregister the correct callbacks", v4, v5, v6, v7, v8, v9, v10, v24);
      uint64_t v11 = (os_log_s *)sub_100086554(0x43u);
      if (os_log_type_enabled(v11, OS_LOG_TYPE_ERROR)) {
        sub_100657858();
      }
    }

    return 101LL;
  }

  else
  {
    uint64_t v2 = 0LL;
    uint64_t v3 = &qword_1008ED970;
    while (*(v3 - 1) == *a1 && *v3 == a1[1])
    {
      ++v2;
      v3 += 3;
    }

    if ((__int16)xmmword_1008ED960 - 1 > (int)v2)
    {
      int v21 = (int)v2;
      do
      {
        uint64_t v22 = (char *)&xmmword_1008ED960 + 24 * (__int16)v21 + 8;
        uint64_t v2 = (char *)&xmmword_1008ED960 + 24 * (int)v2 + 8;
        __int128 v23 = *(_OWORD *)(v2 + 24);
        *((void *)v22 + 2) = *((void *)v2 + 5);
        *(_OWORD *)uint64_t v22 = v23;
        LODWORD(v2) = (__int16)++v21;
      }

      while ((__int16)xmmword_1008ED960 - 1 > (__int16)v21);
      __int16 v1 = xmmword_1008ED960;
    }

    uint64_t result = 0LL;
    LOWORD(xmmword_1008ED960) = v1 - 1;
  }

  return result;
}

uint64_t sub_1001C89E4(_BYTE *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, char a6)
{
  v60[0] = 0LL;
  v60[1] = 0LL;
  if (!a2)
  {
    sub_1001EE134((uint64_t)"*randomNumber cannot be NULL", v11, v12, v13, v14, v15, v16, v17, v59);
    uint64_t v18 = (os_log_s *)sub_100086554(0x43u);
    if (!os_log_type_enabled(v18, OS_LOG_TYPE_ERROR)) {
      return 101LL;
    }
LABEL_16:
    sub_100657858();
    return 101LL;
  }

  if (!a4)
  {
    sub_1001EE134((uint64_t)"*key cannot be NULL", v27, v28, v29, v30, v31, v32, v33, v59);
    uint64_t v34 = (os_log_s *)sub_100086554(0x43u);
    if (!os_log_type_enabled(v34, OS_LOG_TYPE_ERROR)) {
      return 101LL;
    }
    goto LABEL_16;
  }

  if (a1 && sub_10012D5EC((uint64_t)a1))
  {
    if (a1[166] == 2) {
      return 118LL;
    }
    if (a5 >= 0x11)
    {
      sub_1001EE134((uint64_t)"LTK length is too big : %d.", v36, v37, v38, v39, v40, v41, v42, a5);
      uint64_t v43 = (os_log_s *)sub_100086554(0x43u);
      if (!os_log_type_enabled(v43, OS_LOG_TYPE_ERROR)) {
        return 101LL;
      }
      goto LABEL_16;
    }

    __memmove_chk(v60, a4, a5, 16LL);
    a1[167] = a5;
    uint64_t v10 = sub_100128D24(0xB9u, v44, v45, v46, v47, v48, v49, v50, (uint64_t)a1);
    if ((_DWORD)v10)
    {
      if (sub_1000A86F0())
      {
        sub_1001EE134( (uint64_t)"Could not start the encryption on the LE link %!.",  v51,  v52,  v53,  v54,  v55,  v56,  v57,  v10);
        uint64_t v58 = (os_log_s *)sub_100086554(0x43u);
        if (os_log_type_enabled(v58, OS_LOG_TYPE_ERROR)) {
          sub_100657858();
        }
      }
    }

    else
    {
      a1[166] = 2;
      a1[169] = a6;
    }
  }

  else
  {
    if (sub_1000A86F0())
    {
      sub_1001EE134((uint64_t)"This handle is not a LE connection.", v19, v20, v21, v22, v23, v24, v25, v59);
      uint64_t v26 = (os_log_s *)sub_100086554(0x43u);
      if (os_log_type_enabled(v26, OS_LOG_TYPE_ERROR)) {
        sub_100657858();
      }
    }

    return 1310LL;
  }

  return v10;
}

uint64_t sub_1001C8C38(_BYTE *a1, uint64_t a2)
{
  if (!a2)
  {
    sub_1001EE134((uint64_t)"*keys cannot be NULL", v13, v14, v15, v16, v17, v18, v19, v29);
    uint64_t v20 = (os_log_s *)sub_100086554(0x43u);
    if (!os_log_type_enabled(v20, OS_LOG_TYPE_ERROR)) {
      return 101LL;
    }
    goto LABEL_12;
  }

  if (a1 && sub_10012D5EC((uint64_t)a1))
  {
    if (a1[166] == 2) {
      return 118LL;
    }
    if ((~*(unsigned __int16 *)(a2 + 80) & 7) == 0) {
      return sub_1001C89E4( a1,  a2 + 20,  *(unsigned __int16 *)(a2 + 18),  a2,  *(unsigned __int8 *)(a2 + 16),  *(_BYTE *)(a2 + 17));
    }
    sub_1001EE134((uint64_t)"Missing keys", v21, v22, v23, v24, v25, v26, v27, v29);
    uint64_t v28 = (os_log_s *)sub_100086554(0x43u);
    if (!os_log_type_enabled(v28, OS_LOG_TYPE_ERROR)) {
      return 101LL;
    }
LABEL_12:
    sub_100657858();
    return 101LL;
  }

  if (sub_1000A86F0())
  {
    sub_1001EE134((uint64_t)"This handle is not a LE connection.", v5, v6, v7, v8, v9, v10, v11, v29);
    uint64_t v12 = (os_log_s *)sub_100086554(0x43u);
    if (os_log_type_enabled(v12, OS_LOG_TYPE_ERROR)) {
      sub_100657858();
    }
  }

  return 1310LL;
}

uint64_t sub_1001C8D80(uint64_t a1)
{
  uint64_t v29 = a1;
  if (a1 && sub_10012D5EC(a1))
  {
    if (*(_BYTE *)(a1 + 166) == 2) {
      return 118LL;
    }
    if (!off_1008ED928)
    {
      if (sub_1000A86F0())
      {
        sub_1001EE134((uint64_t)"No callbacks defined", v19, v20, v21, v22, v23, v24, v25, v27);
        uint64_t v26 = (os_log_s *)sub_100086554(0x43u);
        if (os_log_type_enabled(v26, OS_LOG_TYPE_ERROR)) {
          sub_100657858();
        }
      }

      return 101LL;
    }

    v28[1] = &v29;
    v28[0] = (const void *)8;
    uint64_t result = sub_1001EE6E8((uint64_t)sub_1001C7D14, v28, 0, 0LL);
    if ((_DWORD)result)
    {
      if (sub_1000A86F0())
      {
        sub_1001EE134((uint64_t)"Failed to send key request callback", v11, v12, v13, v14, v15, v16, v17, v27);
        uint64_t v18 = (os_log_s *)sub_100086554(0x43u);
        if (os_log_type_enabled(v18, OS_LOG_TYPE_ERROR)) {
          sub_100657858();
        }
      }

      return 101LL;
    }
  }

  else
  {
    if (sub_1000A86F0())
    {
      sub_1001EE134((uint64_t)"This handle is not a LE connection.", v3, v4, v5, v6, v7, v8, v9, v27);
      uint64_t v10 = (os_log_s *)sub_100086554(0x43u);
      if (os_log_type_enabled(v10, OS_LOG_TYPE_ERROR)) {
        sub_100657858();
      }
    }

    return 1310LL;
  }

  return result;
}

uint64_t sub_1001C8ECC(uint64_t a1)
{
  if (sub_10012D5EC(a1)) {
    return *(unsigned __int8 *)(a1 + 166) == 1;
  }
  uint64_t result = sub_1000A86F0();
  if ((_DWORD)result)
  {
    sub_1001EE134((uint64_t)"Invalid LE connection handle 0x%x", v3, v4, v5, v6, v7, v8, v9, a1);
    uint64_t v10 = (os_log_s *)sub_100086554(0x43u);
    uint64_t result = os_log_type_enabled(v10, OS_LOG_TYPE_ERROR);
    if ((_DWORD)result)
    {
      sub_100657858();
      return 0LL;
    }
  }

  return result;
}

uint64_t sub_1001C8F50(uint64_t a1)
{
  if (sub_10012D5EC(a1))
  {
    if (*(_BYTE *)(a1 + 166) != 1) {
      return 0LL;
    }
    if (off_1008ED928) {
      return (*(_BYTE *)(a1 + 168) & 0xFD) == 1;
    }
    uint64_t result = sub_1000A86F0();
    if ((_DWORD)result)
    {
      sub_1001EE134((uint64_t)"No callbacks defined", v11, v12, v13, v14, v15, v16, v17, v19);
      uint64_t v18 = (os_log_s *)sub_100086554(0x43u);
      uint64_t result = os_log_type_enabled(v18, OS_LOG_TYPE_ERROR);
      if ((_DWORD)result)
      {
LABEL_7:
        sub_100657858();
        return 0LL;
      }
    }
  }

  else
  {
    uint64_t result = sub_1000A86F0();
    if ((_DWORD)result)
    {
      sub_1001EE134((uint64_t)"Invalid LE connection handle 0x%x", v3, v4, v5, v6, v7, v8, v9, a1);
      uint64_t v10 = (os_log_s *)sub_100086554(0x43u);
      uint64_t result = os_log_type_enabled(v10, OS_LOG_TYPE_ERROR);
      if ((_DWORD)result) {
        goto LABEL_7;
      }
    }
  }

  return result;
}

uint64_t sub_1001C902C(uint64_t a1)
{
  if (sub_10012D5EC(a1)) {
    return *(_BYTE *)(a1 + 208) != 0;
  }
  uint64_t result = sub_1000A86F0();
  if ((_DWORD)result)
  {
    sub_1001EE134((uint64_t)"Invalid LE connection handle 0x%x", v3, v4, v5, v6, v7, v8, v9, a1);
    uint64_t v10 = (os_log_s *)sub_100086554(0x43u);
    uint64_t result = os_log_type_enabled(v10, OS_LOG_TYPE_ERROR);
    if ((_DWORD)result)
    {
      sub_100657858();
      return 0LL;
    }
  }

  return result;
}

uint64_t sub_1001C90B0(uint64_t a1, _BYTE *a2)
{
  if (sub_10012D5EC(a1))
  {
    if (*(_BYTE *)(a1 + 166) == 1)
    {
      if (a2)
      {
        uint64_t result = 0LL;
        *a2 = *(_BYTE *)(a1 + 167);
      }

      else
      {
        sub_1001EE2A0();
        return 101LL;
      }
    }

    else
    {
      return 4802LL;
    }
  }

  else
  {
    if (sub_1000A86F0())
    {
      sub_1001EE134((uint64_t)"Invalid LE connection handle 0x%x", v5, v6, v7, v8, v9, v10, v11, a1);
      uint64_t v12 = (os_log_s *)sub_100086554(0x43u);
      if (os_log_type_enabled(v12, OS_LOG_TYPE_ERROR)) {
        sub_100657858();
      }
    }

    return 1310LL;
  }

  return result;
}

uint64_t sub_1001C915C(void *a1, _BYTE *a2, uint64_t a3)
{
  if (!a2)
  {
    sub_1001EE134((uint64_t)"*ltkType cannot be NULL", v5, v6, v7, v8, v9, v10, v11, v21);
    uint64_t v12 = (os_log_s *)sub_100086554(0x43u);
    if (!os_log_type_enabled(v12, OS_LOG_TYPE_ERROR)) {
      return 101LL;
    }
LABEL_12:
    sub_100657858();
    return 101LL;
  }

  if (!a3)
  {
    sub_1001EE134((uint64_t)"*keys cannot be NULL", v13, v14, v15, v16, v17, v18, v19, v21);
    uint64_t v20 = (os_log_s *)sub_100086554(0x43u);
    if (!os_log_type_enabled(v20, OS_LOG_TYPE_ERROR)) {
      return 101LL;
    }
    goto LABEL_12;
  }

  if ((*(_WORD *)(a3 + 80) & 8) == 0) {
    return 102LL;
  }
  char v3 = *(_BYTE *)(a3 + 45);
  if ((v3 & 0xFE) != 2) {
    return 102LL;
  }
  *a2 = v3;
  return sub_100184764((const void *)(a3 + 28), *(unsigned __int8 *)(a3 + 44), a1, *(unsigned __int8 *)(a3 + 79) == 2);
}

BOOL sub_1001C924C(uint64_t a1, __int128 *a2)
{
  BOOL result = 0LL;
  char v6 = 0;
  __int16 v5 = 0;
  if (a1 && a2) {
    return *(_BYTE *)a1 == 1
  }
        && (*(_BYTE *)(a1 + 1) & 0x40) != 0
        && !sub_100110FB8(a2, (__int16 *)(a1 + 1), (uint64_t)&v5)
        && v5 == *(_WORD *)(a1 + 4)
        && v6 == *(_BYTE *)(a1 + 6);
  return result;
}

uint64_t sub_1001C92D4(_DWORD *a1)
{
  uint64_t v1 = (unsigned __int16)word_1008EDAE8;
  if (!word_1008EDAE8) {
    return 0LL;
  }
  for (uint64_t i = qword_1008EDAE0; ; i += 24LL)
  {
    BOOL v3 = *a1 == *(_DWORD *)i && *(_DWORD *)((char *)a1 + 3) == *(_DWORD *)(i + 3);
    if (v3 && !*(_BYTE *)(i + 23)) {
      break;
    }
    if (!--v1) {
      return 0LL;
    }
  }

  return i + 7;
}

uint64_t sub_1001C9328(_BYTE *a1, uint64_t a2, _BYTE *a3)
{
  if (!a1 || !a2 || !a3)
  {
    sub_1001EE134((uint64_t)"Invalid parameter pointer specified", v10, v11, v12, v13, v14, v15, v16, *(uint64_t *)v35);
    uint64_t v17 = (os_log_s *)sub_100086554(0x43u);
    if (!os_log_type_enabled(v17, OS_LOG_TYPE_ERROR)) {
      return 101LL;
    }
LABEL_19:
    sub_100657858();
    return 101LL;
  }

  if (*a1 != 1 || (a1[1] & 0xC0) != 0x40)
  {
    sub_1001EE134( (uint64_t)"Cannot resolve a non-resolvable address.",  v18,  v19,  v20,  v21,  v22,  v23,  v24,  *(uint64_t *)v35);
    uint64_t v25 = (os_log_s *)sub_100086554(0x43u);
    if (!os_log_type_enabled(v25, OS_LOG_TYPE_ERROR)) {
      return 101LL;
    }
    goto LABEL_19;
  }

  if (qword_1008EDAE0 && word_1008EDAE8)
  {
    uint64_t v6 = 0LL;
    unint64_t v7 = 0LL;
    *a3 = 0;
    do
    {
      if (sub_1001C924C((uint64_t)a1, (__int128 *)(qword_1008EDAE0 + v6 + 7)) && !*a3)
      {
        int v8 = *(_DWORD *)(qword_1008EDAE0 + v6);
        __int16 v9 = *(_WORD *)(qword_1008EDAE0 + v6 + 4);
        *(_BYTE *)(a2 + 6) = *(_BYTE *)(qword_1008EDAE0 + v6 + 6);
        *(_WORD *)(a2 + 4) = v9;
        *(_DWORD *)a2 = v8;
        *a3 = 1;
      }

      ++v7;
      v6 += 24LL;
    }

    while (v7 < (unsigned __int16)word_1008EDAE8);
    return 0LL;
  }

  uint64_t result = sub_1000A86F0();
  if ((_DWORD)result)
  {
    sub_1001EE134((uint64_t)"No resolving cache defined.", v27, v28, v29, v30, v31, v32, v33, *(uint64_t *)v35);
    uint64_t v34 = (os_log_s *)sub_100086554(0x43u);
    uint64_t result = os_log_type_enabled(v34, OS_LOG_TYPE_INFO);
    if ((_DWORD)result)
    {
      *(_DWORD *)uint64_t v35 = 136446210;
      *(void *)&v35[4] = sub_1001EDDCC();
      _os_log_impl((void *)&_mh_execute_header, v34, OS_LOG_TYPE_INFO, " %{public}s", v35, 0xCu);
      return 0LL;
    }
  }

  return result;
}

uint64_t sub_1001C953C(_DWORD *a1, uint64_t a2)
{
  if (!a1)
  {
    sub_1001EE134((uint64_t)"Invalid address", v17, v18, v19, v20, v21, v22, v23, v42);
    uint64_t v24 = (os_log_s *)sub_100086554(0x43u);
    if (!os_log_type_enabled(v24, OS_LOG_TYPE_ERROR)) {
      return 101LL;
    }
LABEL_16:
    sub_100657858();
    return 101LL;
  }

  if (!a2)
  {
    sub_1001EE134((uint64_t)"*keys cannot be NULL", v25, v26, v27, v28, v29, v30, v31, v42);
    uint64_t v32 = (os_log_s *)sub_100086554(0x43u);
    if (!os_log_type_enabled(v32, OS_LOG_TYPE_ERROR)) {
      return 101LL;
    }
    goto LABEL_16;
  }

  uint64_t v4 = sub_10012D98C(a1);
  if (v4)
  {
    uint64_t v5 = v4;
    uint64_t v6 = *(unsigned int *)(v4 + 180);
    if ((_DWORD)v6)
    {
      sub_1001EEB14(v6);
      *(_DWORD *)(v5 + 180) = 0;
    }

    uint64_t v7 = sub_1001CDC8C((_BYTE *)v5, a2);
    if ((_DWORD)v7)
    {
      v44[0] = 0LL;
      int v8 = sub_1000B17F4(0x10uLL);
      uint64_t v43 = v8;
      *(void *)int v8 = v5;
      v8[2] = 4803;
      v44[1] = &v43;
      LOWORD(v44[0]) = 8;
      if (sub_1001EE6E8((uint64_t)sub_1001C9704, v44, 0, 0LL))
      {
        if (sub_1000A86F0())
        {
          sub_1001EE134((uint64_t)"Failed to send the encryption failed callback", v9, v10, v11, v12, v13, v14, v15, v42);
          uint64_t v16 = (os_log_s *)sub_100086554(0x43u);
          if (os_log_type_enabled(v16, OS_LOG_TYPE_ERROR)) {
            sub_100657858();
          }
        }

        return 101LL;
      }
    }
  }

  else
  {
    if (sub_1000A86F0())
    {
      sub_1001EE134( (uint64_t)"Connection to %: is no longer valid. Ignoring.",  v34,  v35,  v36,  v37,  v38,  v39,  v40,  (uint64_t)a1 + 1);
      uint64_t v41 = (os_log_s *)sub_100086554(0x43u);
      if (os_log_type_enabled(v41, OS_LOG_TYPE_ERROR)) {
        sub_100657858();
      }
    }

    return 122LL;
  }

  return v7;
}

void sub_1001C9704(uint64_t a1)
{
  uint64_t v1 = *(uint64_t ***)(a1 + 8);
  uint64_t v2 = *v1;
  uint64_t v3 = **v1;
  if (v3 && sub_10012D5EC(v3))
  {
    uint64_t v4 = *(unsigned int *)(*v2 + 180);
    if ((_DWORD)v4)
    {
      sub_1001EEB14(v4);
      *(_DWORD *)(*v2 + 180) = 0;
    }

    __int16 v5 = xmmword_1008ED960;
    if ((_WORD)xmmword_1008ED960)
    {
      unint64_t v6 = 0LL;
      uint64_t v7 = (void (**)(void))&xmmword_1008ED960 + 1;
      do
      {
        if (*v7)
        {
          (*v7)();
          __int16 v5 = xmmword_1008ED960;
        }

        ++v6;
        v7 += 3;
      }

      while (v6 < v5);
    }

    sub_1000B1838(v2);
  }

  else if (sub_1000A86F0())
  {
    sub_1001EE134((uint64_t)"This handle is not a LE connection.", v8, v9, v10, v11, v12, v13, v14, v16);
    uint64_t v15 = (os_log_s *)sub_100086554(0x43u);
    if (os_log_type_enabled(v15, OS_LOG_TYPE_ERROR)) {
      sub_100657858();
    }
  }

uint64_t sub_1001C9804(_DWORD *a1, int a2, uint64_t a3)
{
  if (!a1)
  {
    sub_1001EE134((uint64_t)"Invalid address", v7, v8, v9, v10, v11, v12, v13, v23);
    uint64_t v14 = (os_log_s *)sub_100086554(0x43u);
    if (!os_log_type_enabled(v14, OS_LOG_TYPE_ERROR)) {
      return 101LL;
    }
    goto LABEL_9;
  }

  if (a3)
  {
    uint64_t v5 = sub_10012D98C(a1);
    return sub_1001CDEA4(v5, a2, a3);
  }

  if (sub_1000A86F0())
  {
    sub_1001EE134((uint64_t)"*keys cannot be NULL", v15, v16, v17, v18, v19, v20, v21, v23);
    uint64_t v22 = (os_log_s *)sub_100086554(0x43u);
    if (os_log_type_enabled(v22, OS_LOG_TYPE_ERROR)) {
LABEL_9:
    }
      sub_100657858();
  }

  return 101LL;
}

uint64_t sub_1001C98C8(_DWORD *a1, int a2, unsigned __int8 a3)
{
  if (a1)
  {
    uint64_t v5 = sub_10012D98C(a1);
    return sub_1001CD18C(v5, a2, a3);
  }

  else
  {
    if (sub_1000A86F0())
    {
      sub_1001EE134((uint64_t)"Invalid address", v7, v8, v9, v10, v11, v12, v13, v15);
      uint64_t v14 = (os_log_s *)sub_100086554(0x43u);
      if (os_log_type_enabled(v14, OS_LOG_TYPE_ERROR)) {
        sub_100657858();
      }
    }

    return 101LL;
  }

uint64_t sub_1001C9948(int *a1, _OWORD *a2, char a3)
{
  unsigned int v6 = (unsigned __int16)word_1008EDAE8;
  if (word_1008EDAE8)
  {
    uint64_t v7 = 0LL;
    uint64_t v8 = (_DWORD *)qword_1008EDAE0;
    while (*v8 != *a1 || *(_DWORD *)((char *)v8 + 3) != *(int *)((char *)a1 + 3))
    {
      ++v7;
      v8 += 6;
    }

    if (sub_1000A86F0())
    {
      sub_1001EE134( (uint64_t)"Found a dup instance of  %: at index %d, trying to remove it.",  v10,  v11,  v12,  v13,  v14,  v15,  v16,  (uint64_t)a1 + 1);
      uint64_t v17 = (os_log_s *)sub_100086554(0x43u);
      if (os_log_type_enabled(v17, OS_LOG_TYPE_ERROR)) {
        sub_100657858();
      }
    }

    sub_1001C9AB4(a1);
    unsigned int v6 = (unsigned __int16)word_1008EDAE8;
  }

uint64_t sub_1001C9AB4(_DWORD *a1)
{
  if (!word_1008EDAE8) {
    return 120LL;
  }
  uint64_t v2 = 0LL;
  for (uint64_t i = (_DWORD *)qword_1008EDAE0; *i != *a1 || *(_DWORD *)((char *)i + 3) != *(_DWORD *)((char *)a1 + 3); i += 6)
  {
  }

  if ((unsigned __int16)word_1008EDAE8 <= 1u)
  {
    unsigned __int16 v9 = 0;
    unsigned int v6 = 0LL;
    uint64_t v8 = (void *)qword_1008EDAE0;
  }

  else
  {
    unsigned int v6 = (char *)sub_1000B17F4(24LL * ((unsigned __int16)word_1008EDAE8 - 1));
    unint64_t v7 = (unsigned __int16)word_1008EDAE8;
    uint64_t v8 = (void *)qword_1008EDAE0;
    if ((unsigned __int16)word_1008EDAE8 < 2u)
    {
      unsigned __int16 v9 = 0;
      if (!qword_1008EDAE0) {
        goto LABEL_25;
      }
      goto LABEL_24;
    }

    unsigned __int16 v9 = 0;
    unint64_t v10 = 1LL;
    uint64_t v11 = qword_1008EDAE0;
    do
    {
      if (*(_DWORD *)v11 != *a1 || *(_DWORD *)(v11 + 3) != *(_DWORD *)((char *)a1 + 3))
      {
        __int128 v13 = *(_OWORD *)v11;
        uint64_t v14 = &v6[24 * v9];
        *((void *)v14 + 2) = *(void *)(v11 + 16);
        *(_OWORD *)uint64_t v14 = v13;
        ++v9;
      }

      if (v10 >= v7) {
        break;
      }
      v11 += 24LL;
      ++v10;
    }

    while ((int)v7 - 1 > v9);
  }

  if (v8) {
LABEL_24:
  }
    sub_1000B1838(v8);
LABEL_25:
  uint64_t result = 0LL;
  qword_1008EDAE0 = (uint64_t)v6;
  word_1008EDAE8 = v9;
  return result;
}

void sub_1001C9C00()
{
  if (qword_1008EDAE0) {
    sub_1000B1838((void *)qword_1008EDAE0);
  }
  qword_1008EDAE0 = 0LL;
  word_1008EDAE8 = 0;
}

void sub_1001C9C34(uint64_t a1)
{
  uint64_t v1 = *(uint64_t **)(a1 + 8);
  uint64_t v2 = *v1;
  if (*v1 && sub_10012D5EC(*v1))
  {
    v22[0] = 0LL;
    uint64_t v3 = sub_1000B17F4(0x10uLL);
    uint64_t v21 = v3;
    *(void *)uint64_t v3 = v2;
    v3[2] = 4807;
    v22[1] = &v21;
    LOWORD(v22[0]) = 8;
    if (sub_1001EE6E8((uint64_t)sub_1001C9704, v22, 0, 0LL) && sub_1000A86F0())
    {
      sub_1001EE134((uint64_t)"Failed to send the encryption failed callback", v4, v5, v6, v7, v8, v9, v10, v20);
      uint64_t v11 = (os_log_s *)sub_100086554(0x43u);
      if (os_log_type_enabled(v11, OS_LOG_TYPE_ERROR)) {
        sub_100657858();
      }
    }
  }

  else if (sub_1000A86F0())
  {
    sub_1001EE134((uint64_t)"This handle is not a LE connection.", v12, v13, v14, v15, v16, v17, v18, v20);
    uint64_t v19 = (os_log_s *)sub_100086554(0x43u);
    if (os_log_type_enabled(v19, OS_LOG_TYPE_ERROR)) {
      sub_100657858();
    }
  }

uint64_t sub_1001C9D34(__int128 *a1, char a2, char a3)
{
  v33[0] = 1;
  v33[1] = a2;
  __int16 v34 = 2;
  char v35 = a3;
  char v36 = 0;
  if (sub_10012D5EC((uint64_t)a1))
  {
    uint64_t v4 = sub_1001EF80C(v33, 6uLL, 0);
    if (v4)
    {
      uint64_t v5 = v4;
      uint64_t v6 = sub_100172A98(0LL, 5LL, a1, (uint64_t)v4, 0);
      if ((_DWORD)v6)
      {
        if (sub_1000A86F0())
        {
          sub_1001EE134( (uint64_t)"Could not write the to SMP channel for handle 0x%x",  v7,  v8,  v9,  v10,  v11,  v12,  v13,  (uint64_t)a1);
          uint64_t v14 = (os_log_s *)sub_100086554(0x42u);
          if (os_log_type_enabled(v14, OS_LOG_TYPE_ERROR)) {
            sub_100657858();
          }
        }
      }

      sub_1001EF69C(v5);
    }

    else
    {
      if (sub_1000A86F0())
      {
        sub_1001EE134( (uint64_t)"Unable to allocate buffer for LE Signal transmit.",  v23,  v24,  v25,  v26,  v27,  v28,  v29,  v32);
        uint64_t v30 = (os_log_s *)sub_100086554(0x42u);
        if (os_log_type_enabled(v30, OS_LOG_TYPE_ERROR)) {
          sub_100657858();
        }
      }

      return 104LL;
    }
  }

  else
  {
    if (sub_1000A86F0())
    {
      sub_1001EE134((uint64_t)"This command is only available to LE devices.", v15, v16, v17, v18, v19, v20, v21, v32);
      uint64_t v22 = (os_log_s *)sub_100086554(0x42u);
      if (os_log_type_enabled(v22, OS_LOG_TYPE_ERROR)) {
        sub_100657858();
      }
    }

    return 4120LL;
  }

  return v6;
}

uint64_t sub_1001C9E9C( __int128 *a1, char a2, int a3, unsigned int a4, unsigned int a5, int a6, int a7, int a8, unsigned __int16 a9)
{
  v53[0] = 19;
  v53[1] = a2;
  __int16 v54 = 2;
  __int16 v55 = a3;
  if (sub_10012D5EC((uint64_t)a1))
  {
    if (!a3 && sub_1001AD740((uint64_t)a1, a4, a5, a6, a7, a8, a9))
    {
      if (sub_1000A86F0())
      {
        sub_1001EE134((uint64_t)"Failed to update connection parameters.", v16, v17, v18, v19, v20, v21, v22, v52);
        uint64_t v23 = (os_log_s *)sub_100086554(0x42u);
        if (os_log_type_enabled(v23, OS_LOG_TYPE_ERROR)) {
          sub_100657858();
        }
      }

      __int16 v55 = 1;
    }

    uint64_t v24 = sub_1001EF80C(v53, 6uLL, 0);
    if (v24)
    {
      uint64_t v25 = v24;
      uint64_t v26 = sub_100172A98(0LL, 5LL, a1, (uint64_t)v24, 0);
      if ((_DWORD)v26)
      {
        if (sub_1000A86F0())
        {
          sub_1001EE134( (uint64_t)"Could not write the to LE signal channel for handle 0x%x",  v27,  v28,  v29,  v30,  v31,  v32,  v33,  (uint64_t)a1);
          __int16 v34 = (os_log_s *)sub_100086554(0x42u);
          if (os_log_type_enabled(v34, OS_LOG_TYPE_ERROR)) {
            sub_100657858();
          }
        }
      }

      sub_1001EF69C(v25);
    }

    else
    {
      if (sub_1000A86F0())
      {
        sub_1001EE134( (uint64_t)"Unable to allocate buffer for LE Signal transmit.",  v43,  v44,  v45,  v46,  v47,  v48,  v49,  v52);
        uint64_t v50 = (os_log_s *)sub_100086554(0x42u);
        if (os_log_type_enabled(v50, OS_LOG_TYPE_ERROR)) {
          sub_100657858();
        }
      }

      return 104LL;
    }
  }

  else
  {
    if (sub_1000A86F0())
    {
      sub_1001EE134((uint64_t)"This command is only available to LE devices.", v35, v36, v37, v38, v39, v40, v41, v52);
      uint64_t v42 = (os_log_s *)sub_100086554(0x42u);
      if (os_log_type_enabled(v42, OS_LOG_TYPE_ERROR)) {
        sub_100657858();
      }
    }

    return 4121LL;
  }

  return v26;
}

uint64_t sub_1001CA0A0(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5)
{
  v132[0] = 18;
  char v5 = byte_1008D8ED0++;
  v132[1] = v5;
  __int16 v133 = 8;
  __int16 v134 = a2;
  __int16 v135 = a3;
  __int16 v136 = a4;
  __int16 v137 = a5;
  if (*(_BYTE *)(a1 + 70) != 1)
  {
    if (sub_1000A86F0())
    {
      sub_1001EE134((uint64_t)"Connection is not peripheral.", v15, v16, v17, v18, v19, v20, v21, v131);
      uint64_t v22 = (os_log_s *)sub_100086554(0x42u);
      if (os_log_type_enabled(v22, OS_LOG_TYPE_ERROR)) {
        sub_100657858();
      }
    }

    return 132LL;
  }

  if ((unsigned __int16)(a2 - 3201) <= 0xF384u)
  {
    sub_1001EE134((uint64_t)"Invalid min interval 0x%x.", v7, v8, v9, v10, v11, v12, v13, a2);
    uint64_t v14 = (os_log_s *)sub_100086554(0x42u);
    if (!os_log_type_enabled(v14, OS_LOG_TYPE_ERROR)) {
      return 101LL;
    }
    goto LABEL_50;
  }

  if ((unsigned __int16)(a3 - 3201) <= 0xF384u)
  {
    sub_1001EE134((uint64_t)"Invalid max interval : 0x%x.", v25, v26, v27, v28, v29, v30, v31, a3);
    uint64_t v32 = (os_log_s *)sub_100086554(0x42u);
    if (!os_log_type_enabled(v32, OS_LOG_TYPE_ERROR)) {
      return 101LL;
    }
    goto LABEL_50;
  }

  if (a4 >= 0x1F5)
  {
    sub_1001EE134((uint64_t)"Invalid peripheral latency %d.", v34, v35, v36, v37, v38, v39, v40, a4);
    uint64_t v41 = (os_log_s *)sub_100086554(0x42u);
    if (!os_log_type_enabled(v41, OS_LOG_TYPE_ERROR)) {
      return 101LL;
    }
    goto LABEL_50;
  }

  if ((a5 - 3201) <= 0xFFFFF388)
  {
    sub_1001EE134((uint64_t)"Invalid supervision timeout : 0x%x.", v43, v44, v45, v46, v47, v48, v49, a5);
    uint64_t v50 = (os_log_s *)sub_100086554(0x42u);
    if (!os_log_type_enabled(v50, OS_LOG_TYPE_ERROR)) {
      return 101LL;
    }
    goto LABEL_50;
  }

  if (a3 <= a2)
  {
    sub_1001EE134((uint64_t)"Invalid interval range : 0x%x - 0x%x.", v61, v62, v63, v64, v65, v66, v67, a2);
    uint64_t v68 = (os_log_s *)sub_100086554(0x42u);
    if (!os_log_type_enabled(v68, OS_LOG_TYPE_ERROR)) {
      return 101LL;
    }
LABEL_50:
    sub_100657858();
    return 101LL;
  }

  double v51 = (double)a3 * 1.25;
  int v52 = a4 + 1;
  if (v51 * (double)((int)a4 + 1) > 6000.0)
  {
    sub_1001EE134( (uint64_t)"Requesting an interval / latency combination that would provide a poor user experience (more than 6seconds syncups.)",  v53,  v54,  v55,  v56,  v57,  v58,  v59,  v131);
    uint64_t v60 = (os_log_s *)sub_100086554(0x42u);
    if (!os_log_type_enabled(v60, OS_LOG_TYPE_ERROR)) {
      return 101LL;
    }
    goto LABEL_50;
  }

  double v69 = (double)a2 * 1.25;
  if (v69 < 10.0)
  {
    sub_1001EE134( (uint64_t)"Requesting a min interval smaller than 10 ms. Let's refuse and not drain the battery...",  v70,  v71,  v72,  v73,  v74,  v75,  v76,  v131);
    uint64_t v77 = (os_log_s *)sub_100086554(0x42u);
    if (!os_log_type_enabled(v77, OS_LOG_TYPE_ERROR)) {
      return 101LL;
    }
    goto LABEL_50;
  }

  if (-(v69 - (double)a3 * 1.25) < 10.0)
  {
    sub_1001EE134((uint64_t)"Intervals should be %d ms apart - refusing.", v78, v79, v80, v81, v82, v83, v84, 10LL);
    uint64_t v85 = (os_log_s *)sub_100086554(0x42u);
    if (!os_log_type_enabled(v85, OS_LOG_TYPE_ERROR)) {
      return 101LL;
    }
    goto LABEL_50;
  }

  if (a4 >= 5 && (sub_100091610(a1) & 1) == 0)
  {
    sub_1001EE134( (uint64_t)"Requesting a peripheral latency more than 4 so we drain our battery and they don't - refusing.",  v104,  v105,  v106,  v107,  v108,  v109,  v110,  v131);
    uint64_t v111 = (os_log_s *)sub_100086554(0x42u);
    if (!os_log_type_enabled(v111, OS_LOG_TYPE_ERROR)) {
      return 101LL;
    }
    goto LABEL_50;
  }

  if (a5 >= 0x709)
  {
    sub_1001EE134( (uint64_t)"Requesting for a timeout of more than 18 seconds, this is not very user friendly - refusing.",  v87,  v88,  v89,  v90,  v91,  v92,  v93,  v131);
    uint64_t v94 = (os_log_s *)sub_100086554(0x42u);
    if (!os_log_type_enabled(v94, OS_LOG_TYPE_ERROR)) {
      return 101LL;
    }
    goto LABEL_50;
  }

  uint64_t v95 = (10 * a5);
  if (v51 * (double)(3 * v52) > (double)(int)v95)
  {
    sub_1001EE134( (uint64_t)"Requesting for a timeout(%dms) / latency(%d) / maxInterval(%dms) that would cause link timeouts under bad conditions. - refusing.",  v96,  v97,  v98,  v99,  v100,  v101,  v102,  v95);
    uint64_t v103 = (os_log_s *)sub_100086554(0x42u);
    if (!os_log_type_enabled(v103, OS_LOG_TYPE_ERROR)) {
      return 101LL;
    }
    goto LABEL_50;
  }

  uint64_t v113 = sub_1001EF80C(v132, 0xCuLL, 0);
  if (v113)
  {
    uint64_t v114 = v113;
    uint64_t v23 = sub_100172A98(0LL, 5LL, (__int128 *)a1, (uint64_t)v113, 0);
    if ((_DWORD)v23)
    {
      if (sub_1000A86F0())
      {
        sub_1001EE134( (uint64_t)"Could not write the to LE signal channel for handle 0x%x",  v115,  v116,  v117,  v118,  v119,  v120,  v121,  a1);
        uint64_t v122 = (os_log_s *)sub_100086554(0x42u);
        if (os_log_type_enabled(v122, OS_LOG_TYPE_ERROR)) {
          sub_100657858();
        }
      }
    }

    sub_1001EF69C(v114);
  }

  else
  {
    if (sub_1000A86F0())
    {
      sub_1001EE134( (uint64_t)"Unable to allocate buffer for LE Signal transmit.",  v123,  v124,  v125,  v126,  v127,  v128,  v129,  v131);
      uint64_t v130 = (os_log_s *)sub_100086554(0x42u);
      if (os_log_type_enabled(v130, OS_LOG_TYPE_ERROR)) {
        sub_100657858();
      }
    }

    return 104LL;
  }

  return v23;
}

uint64_t sub_1001CA640(__int128 *a1, char a2, __int16 a3, __int16 a4, __int16 a5, __int16 a6, __int16 a7)
{
  v37[0] = 21;
  v37[1] = a2;
  __int16 v38 = 10;
  __int16 v39 = a3;
  __int16 v40 = a4;
  __int16 v41 = a5;
  __int16 v42 = a6;
  __int16 v43 = a7;
  if (sub_10012D5EC((uint64_t)a1))
  {
    uint64_t v8 = sub_1001EF80C(v37, 0xEuLL, 0);
    if (v8)
    {
      uint64_t v9 = v8;
      uint64_t v10 = sub_100172A98(0LL, 5LL, a1, (uint64_t)v8, 0);
      if ((_DWORD)v10)
      {
        if (sub_1000A86F0())
        {
          sub_1001EE134( (uint64_t)"Could not write the to LE signal channel for handle 0x%x",  v11,  v12,  v13,  v14,  v15,  v16,  v17,  (uint64_t)a1);
          uint64_t v18 = (os_log_s *)sub_100086554(0x42u);
          if (os_log_type_enabled(v18, OS_LOG_TYPE_ERROR)) {
            sub_100657858();
          }
        }
      }

      sub_1001EF69C(v9);
    }

    else
    {
      if (sub_1000A86F0())
      {
        sub_1001EE134( (uint64_t)"Unable to allocate buffer for LE Signal transmit.",  v27,  v28,  v29,  v30,  v31,  v32,  v33,  v36);
        uint64_t v34 = (os_log_s *)sub_100086554(0x42u);
        if (os_log_type_enabled(v34, OS_LOG_TYPE_ERROR)) {
          sub_100657858();
        }
      }

      return 104LL;
    }
  }

  else
  {
    if (sub_1000A86F0())
    {
      sub_1001EE134((uint64_t)"This command is only available to LE devices.", v19, v20, v21, v22, v23, v24, v25, v36);
      uint64_t v26 = (os_log_s *)sub_100086554(0x42u);
      if (os_log_type_enabled(v26, OS_LOG_TYPE_ERROR)) {
        sub_100657858();
      }
    }

    return 4122LL;
  }

  return v10;
}

uint64_t sub_1001CA808(__int128 *a1, char a2, __int16 a3, __int16 a4, __int16 a5, __int16 a6, __int16 a7)
{
  v37[0] = 20;
  v37[1] = a2;
  __int16 v38 = 10;
  __int16 v39 = a3;
  __int16 v40 = a4;
  __int16 v41 = a5;
  __int16 v42 = a6;
  __int16 v43 = a7;
  if (sub_10012D5EC((uint64_t)a1))
  {
    uint64_t v8 = sub_1001EF80C(v37, 0xEuLL, 0);
    if (v8)
    {
      uint64_t v9 = v8;
      uint64_t v10 = sub_100172A98(0LL, 5LL, a1, (uint64_t)v8, 0);
      if ((_DWORD)v10)
      {
        if (sub_1000A86F0())
        {
          sub_1001EE134( (uint64_t)"Could not write the to LE signal channel for handle 0x%x",  v11,  v12,  v13,  v14,  v15,  v16,  v17,  (uint64_t)a1);
          uint64_t v18 = (os_log_s *)sub_100086554(0x42u);
          if (os_log_type_enabled(v18, OS_LOG_TYPE_ERROR)) {
            sub_100657858();
          }
        }
      }

      sub_1001EF69C(v9);
    }

    else
    {
      if (sub_1000A86F0())
      {
        sub_1001EE134( (uint64_t)"Unable to allocate buffer for LE Signal transmit.",  v27,  v28,  v29,  v30,  v31,  v32,  v33,  v36);
        uint64_t v34 = (os_log_s *)sub_100086554(0x42u);
        if (os_log_type_enabled(v34, OS_LOG_TYPE_ERROR)) {
          sub_100657858();
        }
      }

      return 104LL;
    }
  }

  else
  {
    if (sub_1000A86F0())
    {
      sub_1001EE134((uint64_t)"This command is only available to LE devices.", v19, v20, v21, v22, v23, v24, v25, v36);
      uint64_t v26 = (os_log_s *)sub_100086554(0x42u);
      if (os_log_type_enabled(v26, OS_LOG_TYPE_ERROR)) {
        sub_100657858();
      }
    }

    return 4123LL;
  }

  return v10;
}

uint64_t sub_1001CA9D0(__int128 *a1, char a2, __int16 a3, __int16 a4)
{
  int v34 = 262166;
  BYTE1(v34) = a2;
  __int16 v35 = a3;
  __int16 v36 = a4;
  if (sub_10012D5EC((uint64_t)a1))
  {
    char v5 = sub_1001EF80C((char *)&v34, 8uLL, 0);
    if (v5)
    {
      uint64_t v6 = v5;
      uint64_t v7 = sub_100172A98(0LL, 5LL, a1, (uint64_t)v5, 0);
      if ((_DWORD)v7)
      {
        if (sub_1000A86F0())
        {
          sub_1001EE134( (uint64_t)"Could not write the to LE signal channel for handle 0x%x",  v8,  v9,  v10,  v11,  v12,  v13,  v14,  (uint64_t)a1);
          uint64_t v15 = (os_log_s *)sub_100086554(0x42u);
          if (os_log_type_enabled(v15, OS_LOG_TYPE_ERROR)) {
            sub_100657858();
          }
        }
      }

      sub_1001EF69C(v6);
    }

    else
    {
      if (sub_1000A86F0())
      {
        sub_1001EE134( (uint64_t)"Unable to allocate buffer for LE Signal transmit.",  v24,  v25,  v26,  v27,  v28,  v29,  v30,  v33);
        uint64_t v31 = (os_log_s *)sub_100086554(0x42u);
        if (os_log_type_enabled(v31, OS_LOG_TYPE_ERROR)) {
          sub_100657858();
        }
      }

      return 104LL;
    }
  }

  else
  {
    if (sub_1000A86F0())
    {
      sub_1001EE134((uint64_t)"This command is only available to LE devices.", v16, v17, v18, v19, v20, v21, v22, v33);
      uint64_t v23 = (os_log_s *)sub_100086554(0x42u);
      if (os_log_type_enabled(v23, OS_LOG_TYPE_ERROR)) {
        sub_100657858();
      }
    }

    return 4124LL;
  }

  return v7;
}

uint64_t sub_1001CAB70(__int128 *a1, int a2, unsigned int a3, __int16 a4, unsigned int a5, char a6)
{
  v40[0] = 1;
  v40[1] = a6;
  v40[3] = 0;
  __int16 v41 = a2;
  int v42 = 0;
  if (a2 == 1)
  {
    uint64_t v9 = &v42;
    uint64_t v8 = (char *)&v42 + 1;
    unsigned int v10 = a3 >> 8;
    int v7 = 2;
  }

  else
  {
    int v7 = 0;
    if (a2 != 2) {
      goto LABEL_6;
    }
    uint64_t v8 = (char *)&v42 + 3;
    uint64_t v9 = (int *)((char *)&v42 + 2);
    LOWORD(v42) = a4;
    unsigned int v10 = a5 >> 8;
    int v7 = 4;
    LOBYTE(a3) = a5;
  }

  *(_BYTE *)uint64_t v9 = a3;
  *uint64_t v8 = v10;
LABEL_6:
  v40[2] = v7 + 2;
  if (sub_10012D5EC((uint64_t)a1))
  {
    uint64_t v11 = sub_1001EF80C(v40, (v7 + 6), 0);
    if (v11)
    {
      uint64_t v12 = v11;
      uint64_t v13 = sub_100172A98(0LL, 5LL, a1, (uint64_t)v11, 0);
      if ((_DWORD)v13)
      {
        if (sub_1000A86F0())
        {
          sub_1001EE134( (uint64_t)"Could not write the to LE signal channel for handle 0x%x",  v14,  v15,  v16,  v17,  v18,  v19,  v20,  (uint64_t)a1);
          uint64_t v21 = (os_log_s *)sub_100086554(0x42u);
          if (os_log_type_enabled(v21, OS_LOG_TYPE_ERROR)) {
            sub_100657858();
          }
        }
      }

      sub_1001EF69C(v12);
    }

    else
    {
      if (sub_1000A86F0())
      {
        sub_1001EE134( (uint64_t)"Unable to allocate buffer for LE Signal transmit.",  v30,  v31,  v32,  v33,  v34,  v35,  v36,  v39);
        uint64_t v37 = (os_log_s *)sub_100086554(0x42u);
        if (os_log_type_enabled(v37, OS_LOG_TYPE_ERROR)) {
          sub_100657858();
        }
      }

      return 104LL;
    }
  }

  else
  {
    if (sub_1000A86F0())
    {
      sub_1001EE134((uint64_t)"This command is only available to LE devices.", v22, v23, v24, v25, v26, v27, v28, v39);
      uint64_t v29 = (os_log_s *)sub_100086554(0x42u);
      if (os_log_type_enabled(v29, OS_LOG_TYPE_ERROR)) {
        sub_100657858();
      }
    }

    return 4125LL;
  }

  return v13;
}

uint64_t sub_1001CAD64(__int128 *a1, char a2, __int16 a3, __int16 a4)
{
  int v34 = 262150;
  BYTE1(v34) = a2;
  __int16 v35 = a4;
  __int16 v36 = a3;
  if (sub_10012D5EC((uint64_t)a1))
  {
    char v5 = sub_1001EF80C((char *)&v34, 8uLL, 0);
    if (v5)
    {
      uint64_t v6 = v5;
      uint64_t v7 = sub_100172A98(0LL, 5LL, a1, (uint64_t)v5, 0);
      if ((_DWORD)v7)
      {
        if (sub_1000A86F0())
        {
          sub_1001EE134( (uint64_t)"Could not write the to LE signal channel for handle 0x%x",  v8,  v9,  v10,  v11,  v12,  v13,  v14,  (uint64_t)a1);
          uint64_t v15 = (os_log_s *)sub_100086554(0x42u);
          if (os_log_type_enabled(v15, OS_LOG_TYPE_ERROR)) {
            sub_100657858();
          }
        }
      }

      sub_1001EF69C(v6);
    }

    else
    {
      if (sub_1000A86F0())
      {
        sub_1001EE134( (uint64_t)"Unable to allocate buffer for LE Signal transmit.",  v24,  v25,  v26,  v27,  v28,  v29,  v30,  v33);
        uint64_t v31 = (os_log_s *)sub_100086554(0x42u);
        if (os_log_type_enabled(v31, OS_LOG_TYPE_ERROR)) {
          sub_100657858();
        }
      }

      return 104LL;
    }
  }

  else
  {
    if (sub_1000A86F0())
    {
      sub_1001EE134((uint64_t)"This command is only available to LE devices.", v16, v17, v18, v19, v20, v21, v22, v33);
      uint64_t v23 = (os_log_s *)sub_100086554(0x42u);
      if (os_log_type_enabled(v23, OS_LOG_TYPE_ERROR)) {
        sub_100657858();
      }
    }

    return 4126LL;
  }

  return v7;
}

uint64_t sub_1001CAF04(__int128 *a1, char a2, __int16 a3, __int16 a4)
{
  int v34 = 262151;
  BYTE1(v34) = a2;
  __int16 v35 = a3;
  __int16 v36 = a4;
  if (sub_10012D5EC((uint64_t)a1))
  {
    char v5 = sub_1001EF80C((char *)&v34, 8uLL, 0);
    if (v5)
    {
      uint64_t v6 = v5;
      uint64_t v7 = sub_100172A98(0LL, 5LL, a1, (uint64_t)v5, 0);
      if ((_DWORD)v7)
      {
        if (sub_1000A86F0())
        {
          sub_1001EE134( (uint64_t)"Could not write the to LE signal channel for handle 0x%x",  v8,  v9,  v10,  v11,  v12,  v13,  v14,  (uint64_t)a1);
          uint64_t v15 = (os_log_s *)sub_100086554(0x42u);
          if (os_log_type_enabled(v15, OS_LOG_TYPE_ERROR)) {
            sub_100657858();
          }
        }
      }

      sub_1001EF69C(v6);
    }

    else
    {
      if (sub_1000A86F0())
      {
        sub_1001EE134( (uint64_t)"Unable to allocate buffer for LE Signal transmit.",  v24,  v25,  v26,  v27,  v28,  v29,  v30,  v33);
        uint64_t v31 = (os_log_s *)sub_100086554(0x42u);
        if (os_log_type_enabled(v31, OS_LOG_TYPE_ERROR)) {
          sub_100657858();
        }
      }

      return 104LL;
    }
  }

  else
  {
    if (sub_1000A86F0())
    {
      sub_1001EE134((uint64_t)"This command is only available to LE devices.", v16, v17, v18, v19, v20, v21, v22, v33);
      uint64_t v23 = (os_log_s *)sub_100086554(0x42u);
      if (os_log_type_enabled(v23, OS_LOG_TYPE_ERROR)) {
        sub_100657858();
      }
    }

    return 4127LL;
  }

  return v7;
}

uint64_t sub_1001CB0A4( uint64_t (*a1)(void, void, void, void, void, void, void, void))
{
  qword_1008EDAF0 = 0LL;
  off_1008EDAF8 = a1;
  uint64_t v1 = sub_1001732EC(5u, 2, 6, 3u, &qword_1008EDAF0, (uint64_t)sub_1001CB174);
  if ((_DWORD)v1 || !qword_1008EDAF0)
  {
    if (sub_1000A86F0())
    {
      sub_1001EE134((uint64_t)"Could not register the LE signal channel : %!", v2, v3, v4, v5, v6, v7, v8, v1);
      uint64_t v9 = (os_log_s *)sub_100086554(0x42u);
      if (os_log_type_enabled(v9, OS_LOG_TYPE_ERROR)) {
        sub_100657858();
      }
    }
  }

  else
  {
    *(_WORD *)sub_10017AF44((unsigned int *)qword_1008EDAF0) = 23;
    *(_WORD *)(sub_10017AF44((unsigned int *)qword_1008EDAF0) + 2) = -1;
  }

  return v1;
}

void sub_1001CB174(__int128 *a1, unsigned __int16 *a2, unsigned int a3, uint64_t a4)
{
  if (sub_10012D5EC((uint64_t)a1))
  {
    if (a2)
    {
      if (a3 > 3)
      {
        uint64_t v32 = a2[1];
        if (a3 - 4 == (_DWORD)v32)
        {
          char v33 = *((_BYTE *)a2 + 1);
          uint64_t v34 = *(unsigned __int8 *)a2;
          switch(*(_BYTE *)a2)
          {
            case 6:
              sub_1001CBC1C(a1, *((_BYTE *)a2 + 1), a2 + 2, v32);
              break;
            case 7:
              sub_1001CBCA8((uint64_t)a1, *((unsigned __int8 *)a2 + 1), a2 + 2, v32);
              break;
            case 8:
            case 9:
            case 0xA:
            case 0xB:
            case 0xC:
            case 0xD:
            case 0xE:
            case 0xF:
            case 0x10:
            case 0x11:
              goto LABEL_20;
            case 0x12:
              sub_1001CB4C8((uint64_t)a1, *((unsigned __int8 *)a2 + 1), a2 + 2, v32, a4);
              break;
            case 0x13:
              return;
            case 0x14:
              sub_1001CB9FC((uint64_t)a1, *((unsigned __int8 *)a2 + 1), a2 + 2, v32, a4);
              break;
            case 0x15:
              sub_1001CBA9C((uint64_t)a1, *((unsigned __int8 *)a2 + 1), (uint64_t)(a2 + 2), v32);
              break;
            case 0x16:
              sub_1001CBB38((uint64_t)a1, a2 + 2, a2[1]);
              break;
            default:
              if ((_DWORD)v34 != 1)
              {
LABEL_20:
                if (sub_1000A86F0())
                {
                  sub_1001EE134( (uint64_t)"LE Signaling channel error : invalid opcode %d",  v43,  v44,  v45,  v46,  v47,  v48,  v49,  v34);
                  uint64_t v50 = (os_log_s *)sub_100086554(0x42u);
                  if (os_log_type_enabled(v50, OS_LOG_TYPE_ERROR)) {
                    sub_100657858();
                  }
                }

                sub_1001C9D34(a1, v33, 0);
              }

              break;
          }
        }

        else if (sub_1000A86F0())
        {
          sub_1001EE134( (uint64_t)"LE Signaling channel error : corrupted packet size",  v35,  v36,  v37,  v38,  v39,  v40,  v41,  v51);
          int v42 = (os_log_s *)sub_100086554(0x42u);
          if (os_log_type_enabled(v42, OS_LOG_TYPE_ERROR)) {
            goto LABEL_18;
          }
        }
      }

      else if (sub_1000A86F0())
      {
        sub_1001EE134((uint64_t)"LE Signaling channel error : invalid packet size", v8, v9, v10, v11, v12, v13, v14, v51);
        uint64_t v15 = (os_log_s *)sub_100086554(0x42u);
        if (os_log_type_enabled(v15, OS_LOG_TYPE_ERROR)) {
LABEL_18:
        }
          sub_100657858();
      }
    }

    else if (sub_1000A86F0())
    {
      sub_1001EE134((uint64_t)"LE Signaling channel error : invalid data on", v24, v25, v26, v27, v28, v29, v30, v51);
      uint64_t v31 = (os_log_s *)sub_100086554(0x42u);
      if (os_log_type_enabled(v31, OS_LOG_TYPE_ERROR)) {
        goto LABEL_18;
      }
    }
  }

  else if (sub_1000A86F0())
  {
    sub_1001EE134((uint64_t)"LE Signaling channel error : not a LE handle.", v16, v17, v18, v19, v20, v21, v22, v51);
    uint64_t v23 = (os_log_s *)sub_100086554(0x42u);
    if (os_log_type_enabled(v23, OS_LOG_TYPE_ERROR)) {
      goto LABEL_18;
    }
  }

uint64_t sub_1001CB440()
{
  uint64_t v0 = sub_1001734D8(qword_1008EDAF0);
  if ((_DWORD)v0)
  {
    if (sub_1000A86F0())
    {
      sub_1001EE134((uint64_t)"Could not de-register the LE signal channel : %!", v1, v2, v3, v4, v5, v6, v7, v0);
      uint64_t v8 = (os_log_s *)sub_100086554(0x42u);
      if (os_log_type_enabled(v8, OS_LOG_TYPE_ERROR)) {
        sub_100657858();
      }
    }
  }

  qword_1008EDAF0 = 0LL;
  return v0;
}

void sub_1001CB4C8(uint64_t a1, uint64_t a2, unsigned __int16 *a3, uint64_t a4, uint64_t a5)
{
  char v5 = a2;
  if (*(_BYTE *)(a1 + 70) == 1)
  {
    if (sub_1000A86F0())
    {
      sub_1001EE134( (uint64_t)"This command should only be received if we are central.",  v7,  v8,  v9,  v10,  v11,  v12,  v13,  v118);
      uint64_t v14 = (os_log_s *)sub_100086554(0x42u);
      if (os_log_type_enabled(v14, OS_LOG_TYPE_ERROR)) {
        sub_100657858();
      }
    }

    sub_1001C9D34((__int128 *)a1, v5, 0);
    return;
  }

  if ((_DWORD)a4 == 8)
  {
    uint64_t v16 = *a3;
    uint64_t v17 = a3[1];
    uint64_t v18 = a3[2];
    uint64_t v19 = a3[3];
    if (off_1008EDAF8)
    {
      int v20 = off_1008EDAF8(a1, a2, *a3, v17, v18, v19, 0LL, a5);
      if (!v20) {
        return;
      }
      if (v20 != 121) {
        goto LABEL_57;
      }
    }

    if ((unsigned __int16)(v16 - 3201) > 0xF384u)
    {
      if ((unsigned __int16)(v17 - 3201) > 0xF384u)
      {
        if (v16 <= v17)
        {
          if (v18 < 0x1F5)
          {
            if ((unsigned __int16)(v19 - 3201) > 0xF388u)
            {
              double v69 = (double)v17 * 1.25;
              if (v69 * (double)((int)v18 + 1) <= 2000.0)
              {
                if ((double)v16 * 1.25 >= 10.0)
                {
                  if ((double)((int)v17 - (int)v16) * 1.25 >= 10.0)
                  {
                    if (v18 < 5)
                    {
                      if (v19 < 0x259)
                      {
                        if (v69 * (double)(3 * ((int)v18 + 1)) <= (double)(10 * (int)v19))
                        {
                          sub_1001C9E9C((__int128 *)a1, v5, 0, v16, v17, v18, v19, 0, 0);
                          return;
                        }

                        sub_1001EE134( (uint64_t)"Remote sides asks for a timeout(%dms) / latency(%d) / maxInterval(%dms) that would ca use link timeouts under bad conditions. - refusing.",  v110,  v111,  v112,  v113,  v114,  v115,  v116,  (10 * v19));
                        uint64_t v117 = (os_log_s *)sub_100086554(0x42u);
                        if (!os_log_type_enabled(v117, OS_LOG_TYPE_ERROR)) {
                          goto LABEL_57;
                        }
                      }

                      else
                      {
                        sub_1001EE134( (uint64_t)"Remote sides asks for a timeout of more than 6 seconds, this is not very user friendly - refusing.",  v102,  v103,  v104,  v105,  v106,  v107,  v108,  v118);
                        uint64_t v109 = (os_log_s *)sub_100086554(0x42u);
                        if (!os_log_type_enabled(v109, OS_LOG_TYPE_ERROR)) {
                          goto LABEL_57;
                        }
                      }
                    }

                    else
                    {
                      sub_1001EE134( (uint64_t)"Remote side wants a peripheral latency more than 4 so we drain our battery and they don't - refusing.",  v94,  v95,  v96,  v97,  v98,  v99,  v100,  v118);
                      uint64_t v101 = (os_log_s *)sub_100086554(0x42u);
                      if (!os_log_type_enabled(v101, OS_LOG_TYPE_ERROR)) {
                        goto LABEL_57;
                      }
                    }
                  }

                  else
                  {
                    sub_1001EE134( (uint64_t)"Intervals should be %d ms apart - refusing.",  v86,  v87,  v88,  v89,  v90,  v91,  v92,  10LL);
                    uint64_t v93 = (os_log_s *)sub_100086554(0x42u);
                    if (!os_log_type_enabled(v93, OS_LOG_TYPE_ERROR)) {
                      goto LABEL_57;
                    }
                  }
                }

                else
                {
                  sub_1001EE134( (uint64_t)"Remote side wants a min interval smaller than 20 ms. Let's refuse and not drain the battery...",  v78,  v79,  v80,  v81,  v82,  v83,  v84,  v118);
                  uint64_t v85 = (os_log_s *)sub_100086554(0x42u);
                  if (!os_log_type_enabled(v85, OS_LOG_TYPE_ERROR)) {
                    goto LABEL_57;
                  }
                }
              }

              else
              {
                sub_1001EE134( (uint64_t)"Remote side wants an interval / latency combination that would provide a poor user experience (more than 2seconds syncups.)",  v70,  v71,  v72,  v73,  v74,  v75,  v76,  v118);
                uint64_t v77 = (os_log_s *)sub_100086554(0x42u);
                if (!os_log_type_enabled(v77, OS_LOG_TYPE_ERROR)) {
                  goto LABEL_57;
                }
              }
            }

            else
            {
              sub_1001EE134((uint64_t)"Invalid timeout multiplier %d.", v61, v62, v63, v64, v65, v66, v67, v19);
              uint64_t v68 = (os_log_s *)sub_100086554(0x42u);
              if (!os_log_type_enabled(v68, OS_LOG_TYPE_ERROR)) {
                goto LABEL_57;
              }
            }
          }

          else
          {
            sub_1001EE134((uint64_t)"Invalid peripheral latency %d.", v53, v54, v55, v56, v57, v58, v59, v18);
            uint64_t v60 = (os_log_s *)sub_100086554(0x42u);
            if (!os_log_type_enabled(v60, OS_LOG_TYPE_ERROR)) {
              goto LABEL_57;
            }
          }
        }

        else
        {
          sub_1001EE134( (uint64_t)"Maximum interval is smaller than minimum interval : %d > %d.",  v45,  v46,  v47,  v48,  v49,  v50,  v51,  v16);
          int v52 = (os_log_s *)sub_100086554(0x42u);
          if (!os_log_type_enabled(v52, OS_LOG_TYPE_ERROR)) {
            goto LABEL_57;
          }
        }
      }

      else
      {
        sub_1001EE134((uint64_t)"Invalid maximum interval %d.", v37, v38, v39, v40, v41, v42, v43, v17);
        uint64_t v44 = (os_log_s *)sub_100086554(0x42u);
        if (!os_log_type_enabled(v44, OS_LOG_TYPE_ERROR)) {
          goto LABEL_57;
        }
      }
    }

    else
    {
      sub_1001EE134((uint64_t)"Invalid minimum interval %d.", v21, v22, v23, v24, v25, v26, v27, v16);
      uint64_t v28 = (os_log_s *)sub_100086554(0x42u);
      if (!os_log_type_enabled(v28, OS_LOG_TYPE_ERROR)) {
        goto LABEL_57;
      }
    }

    sub_100657858();
LABEL_57:
    sub_1001C9E9C((__int128 *)a1, v5, 1, 0, 0, 0, 0, 0, 0);
    return;
  }

  if (sub_1000A86F0())
  {
    sub_1001EE134((uint64_t)"Invalid size in parameter update request : %d", v29, v30, v31, v32, v33, v34, v35, a4);
    uint64_t v36 = (os_log_s *)sub_100086554(0x42u);
    if (os_log_type_enabled(v36, OS_LOG_TYPE_ERROR)) {
      sub_100657858();
    }
  }

void sub_1001CB9FC(uint64_t a1, uint64_t a2, unsigned __int16 *a3, uint64_t a4, uint64_t a5)
{
  if ((_DWORD)a4 == 10)
  {
    sub_100178ECC(a1, *a3, a3[1], a3[2], a3[3], a3[4], a2, a5);
  }

  else if (sub_1000A86F0())
  {
    sub_1001EE134( (uint64_t)"Invalid size in LE Connection Oriented L2CAP Channel connection request : %d",  v6,  v7,  v8,  v9,  v10,  v11,  v12,  a4);
    uint64_t v13 = (os_log_s *)sub_100086554(0x42u);
    if (os_log_type_enabled(v13, OS_LOG_TYPE_ERROR)) {
      sub_100657858();
    }
  }

void sub_1001CBA9C(uint64_t a1, unsigned int a2, uint64_t a3, uint64_t a4)
{
  if ((_DWORD)a4 == 10)
  {
    sub_100179314( a1,  *(_WORD *)a3,  *(unsigned __int16 *)(a3 + 2),  *(unsigned __int16 *)(a3 + 4),  *(unsigned __int16 *)(a3 + 6),  *(unsigned __int16 *)(a3 + 8),  a2);
  }

  else if (sub_1000A86F0())
  {
    sub_1001EE134( (uint64_t)"Invalid size in LE Connection Oriented L2CAP Channel connection response : %d",  v5,  v6,  v7,  v8,  v9,  v10,  v11,  a4);
    uint64_t v12 = (os_log_s *)sub_100086554(0x42u);
    if (os_log_type_enabled(v12, OS_LOG_TYPE_ERROR)) {
      sub_100657858();
    }
  }

void sub_1001CBB38(uint64_t a1, unsigned __int16 *a2, uint64_t a3)
{
  uint64_t v23 = 0LL;
  if ((_DWORD)a3 == 4)
  {
    int v3 = *((unsigned __int8 *)a2 + 2);
    int v4 = *((unsigned __int8 *)a2 + 3);
    sub_100172290(*a2, a1, &v23);
    if (v23)
    {
      sub_10016EDE8(v23, v3 | (v4 << 8));
    }

    else if (sub_1000A86F0())
    {
      sub_1001EE134((uint64_t)"Credits for an invalid channel CID", v14, v15, v16, v17, v18, v19, v20, v22);
      uint64_t v21 = (os_log_s *)sub_100086554(0x42u);
      if (os_log_type_enabled(v21, OS_LOG_TYPE_ERROR)) {
        sub_100657858();
      }
    }
  }

  else if (sub_1000A86F0())
  {
    sub_1001EE134( (uint64_t)"Invalid size in LEConnection Oriented L2CAP Channel connection Flow Credit : %d",  v6,  v7,  v8,  v9,  v10,  v11,  v12,  a3);
    uint64_t v13 = (os_log_s *)sub_100086554(0x42u);
    if (os_log_type_enabled(v13, OS_LOG_TYPE_ERROR)) {
      sub_100657858();
    }
  }

void sub_1001CBC1C(__int128 *a1, char a2, unsigned __int16 *a3, uint64_t a4)
{
  if ((_DWORD)a4 == 4)
  {
    sub_100178A54(a1, *a3, a3[1], a2);
  }

  else if (sub_1000A86F0())
  {
    sub_1001EE134((uint64_t)"Invalid size in Disconnect request : %d", v5, v6, v7, v8, v9, v10, v11, a4);
    uint64_t v12 = (os_log_s *)sub_100086554(0x42u);
    if (os_log_type_enabled(v12, OS_LOG_TYPE_ERROR)) {
      sub_100657858();
    }
  }

void sub_1001CBCA8(uint64_t a1, uint64_t a2, unsigned __int16 *a3, uint64_t a4)
{
  if ((_DWORD)a4 == 4)
  {
    sub_100178DA0(a1, a3[1], *a3);
  }

  else if (sub_1000A86F0())
  {
    sub_1001EE134((uint64_t)"Invalid size in Disconnect response : %d", v5, v6, v7, v8, v9, v10, v11, a4);
    uint64_t v12 = (os_log_s *)sub_100086554(0x42u);
    if (os_log_type_enabled(v12, OS_LOG_TYPE_ERROR)) {
      sub_100657858();
    }
  }

uint64_t sub_1001CBD38(_DWORD *a1)
{
  uint64_t v1 = sub_10012D98C(a1);
  if (!v1) {
    return 122LL;
  }
  uint64_t v2 = (__int128 *)v1;
  if (!sub_10012D5EC(v1))
  {
    if (sub_1000A86F0())
    {
      sub_1001EE134((uint64_t)"This command is only available to LE devices.", v7, v8, v9, v10, v11, v12, v13, v23);
      uint64_t v14 = (os_log_s *)sub_100086554(0x43u);
      if (os_log_type_enabled(v14, OS_LOG_TYPE_ERROR)) {
        sub_100657858();
      }
    }

    return 122LL;
  }

  uint64_t v3 = sub_100184F2C((uint64_t)v2);
  if (v3)
  {
    unint64_t v4 = *(unsigned int *)(v3 + 52);
    if (v4 >= 6) {
      char v5 = 8;
    }
    else {
      char v5 = 0x20C01010108uLL >> (8 * v4);
    }
    return sub_1001CBE38(v2, v5 & 0xF, (char *)v3);
  }

  else
  {
    if (sub_1000A86F0())
    {
      sub_1001EE134((uint64_t)"This device is not in a pairing state.", v15, v16, v17, v18, v19, v20, v21, v23);
      uint64_t v22 = (os_log_s *)sub_100086554(0x43u);
      if (os_log_type_enabled(v22, OS_LOG_TYPE_ERROR)) {
        sub_100657858();
      }
    }

    return 4806LL;
  }

uint64_t sub_1001CBE38(__int128 *a1, int a2, char *a3)
{
  char v4 = a2;
  __int16 v9 = 5;
  if (a2 == 240) {
    char v5 = 8;
  }
  else {
    char v5 = a2;
  }
  HIBYTE(v9) = v5;
  uint64_t v6 = sub_100184F74(a1, (char *)&v9, 2uLL, 0);
  if (a3)
  {
    uint64_t v7 = sub_1001853E8(v4);
    sub_100184BB0(a3, v7, 1);
  }

  return v6;
}

uint64_t sub_1001CBEB4(uint64_t result)
{
  if (result)
  {
    uint64_t v1 = result;
    if (sub_10012D5EC(result))
    {
      uint64_t result = sub_100184F2C(v1);
      if (result) {
        return *(_BYTE *)(result + 8) != 0;
      }
    }

    else
    {
      uint64_t result = sub_1000A86F0();
      if ((_DWORD)result)
      {
        sub_1001EE134((uint64_t)"This command is only available to LE devices.", v2, v3, v4, v5, v6, v7, v8, v10);
        __int16 v9 = (os_log_s *)sub_100086554(0x43u);
        uint64_t result = os_log_type_enabled(v9, OS_LOG_TYPE_ERROR);
        if ((_DWORD)result)
        {
          sub_100657858();
          return 0LL;
        }
      }
    }
  }

  return result;
}

uint64_t sub_1001CBF3C(_DWORD *a1)
{
  uint64_t v1 = sub_10012D98C(a1);
  return sub_1001CBEB4(v1);
}

uint64_t sub_1001CBF50(_DWORD *a1, unsigned int a2)
{
  HIDWORD(v3) = 0;
  *(void *)((char *)&v3 + 4) = 0LL;
  if (a2 > 0xF423F) {
    return 101LL;
  }
  LOWORD(v3) = a2;
  WORD1(v3) = BYTE2(a2);
  return sub_1001CBFD4(a1, &v3);
}

uint64_t sub_1001CBFD4(_DWORD *a1, _OWORD *a2)
{
  uint64_t v3 = sub_10012D98C(a1);
  if (!v3) {
    return 122LL;
  }
  uint64_t v4 = v3;
  uint64_t v5 = sub_100184F2C(v3);
  if (!v5) {
    return 4806LL;
  }
  uint64_t v7 = v5;
  *(_BYTE *)(v5 + 490) = 1;
  if ((*(_BYTE *)(v5 + 72) & *(_BYTE *)(v5 + 80) & 8) != 0)
  {
    switch(*(_BYTE *)(v5 + 16))
    {
      case 1:
        if (*(_BYTE *)(*(void *)v5 + 70LL))
        {
          memset(__s1, 0, 64);
          uint64_t v42 = sub_1001CC750(v7);
          if (!(_DWORD)v42) {
            return 0LL;
          }
          uint64_t v8 = v42;
          if (sub_1000A86F0())
          {
            sub_1001EE134( (uint64_t)"recvdSMPDeferredJustWorksNumComparPublicKey failed %!",  v43,  v44,  v45,  v46,  v47,  v48,  v49,  v8);
            uint64_t v50 = (os_log_s *)sub_100086554(0x43u);
            if (os_log_type_enabled(v50, OS_LOG_TYPE_ERROR)) {
              sub_100657F74();
            }
          }

          goto LABEL_37;
        }

        uint64_t v68 = (_OWORD *)(v5 + 152);
        double v69 = (_OWORD *)(v5 + 216);
        uint64_t v70 = sub_1001120DC((_OWORD *)(v5 + 152), (_OWORD *)(v5 + 216));
        if ((_DWORD)v70)
        {
          uint64_t v8 = v70;
          *(_OWORD *)(v7 + 184) = 0u;
          *(_OWORD *)(v7 + 200) = 0u;
          *uint64_t v68 = 0u;
          *(_OWORD *)(v7 + 168) = 0u;
          *double v69 = 0u;
          *(_OWORD *)(v7 + 232) = 0u;
          *(_OWORD *)(v7 + 248) = 0u;
          *(_OWORD *)(v7 + 264) = 0u;
          *(_OWORD *)(v7 + 280) = 0u;
          *(_OWORD *)(v7 + 296) = 0u;
        }

        else
        {
          sub_100185420(v7, 33);
          __s1[0] = 12;
          __int128 v79 = *(_OWORD *)(v7 + 168);
          *(_OWORD *)&__s1[1] = *v68;
          *(_OWORD *)&__s1[17] = v79;
          __int128 v80 = *(_OWORD *)(v7 + 200);
          *(_OWORD *)&__s1[33] = *(_OWORD *)(v7 + 184);
          *(_OWORD *)&__s1[49] = v80;
          return sub_100184F74(*(__int128 **)v7, __s1, 0x41uLL, 1);
        }

        return v8;
      case 2:
      case 3:
      case 4:
        *(_OWORD *)(v5 + 425) = *a2;
        *(_OWORD *)(v5 + 441) = *a2;
        uint64_t v8 = sub_1001CC98C(v5);
        if ((_DWORD)v8)
        {
          sub_1001EE134( (uint64_t)"smpDoOneLeSecuredConnectionPasskeyAuthItteration failed %!",  v9,  v10,  v11,  v12,  v13,  v14,  v15,  v8);
          uint64_t v16 = (os_log_s *)sub_100086554(0x43u);
          if (!os_log_type_enabled(v16, OS_LOG_TYPE_ERROR)) {
            goto LABEL_37;
          }
          break;
        }

        return v8;
      case 5:
        sub_1001EE134((uint64_t)"Wrong API for OOB", v51, v52, v53, v54, v55, v56, v57, v81);
        uint64_t v58 = (os_log_s *)sub_100086554(0x43u);
        if (!os_log_type_enabled(v58, OS_LOG_TYPE_ERROR)) {
          goto LABEL_36;
        }
        goto LABEL_35;
      case 6:
        if (*(_BYTE *)(*(void *)v5 + 70LL))
        {
          if (!*(_BYTE *)(v5 + 491)) {
            return 0LL;
          }
          uint64_t v8 = sub_1001CC55C((__int128 *)v4);
          if (!(_DWORD)v8) {
            return v8;
          }
          sub_1001EE134((uint64_t)"recvdSMPDeferredDHKeyCheck Failed %!", v60, v61, v62, v63, v64, v65, v66, v8);
          uint64_t v67 = (os_log_s *)sub_100086554(0x43u);
          if (!os_log_type_enabled(v67, OS_LOG_TYPE_ERROR)) {
            goto LABEL_37;
          }
        }

        else
        {
          uint64_t v8 = sub_1001CC484((__int128 **)v5);
          if (!(_DWORD)v8) {
            return v8;
          }
          sub_1001EE134((uint64_t)"Failed to send DHKey value with status %!", v71, v72, v73, v74, v75, v76, v77, v8);
          uint64_t v78 = (os_log_s *)sub_100086554(0x43u);
          if (!os_log_type_enabled(v78, OS_LOG_TYPE_ERROR)) {
            goto LABEL_37;
          }
        }

        break;
      default:
        if (sub_1000A86F0())
        {
          sub_1001EE134( (uint64_t)"wrong API for STKGENMethod=%d",  v34,  v35,  v36,  v37,  v38,  v39,  v40,  *(unsigned __int8 *)(v7 + 16));
          uint64_t v41 = (os_log_s *)sub_100086554(0x43u);
          if (os_log_type_enabled(v41, OS_LOG_TYPE_ERROR)) {
LABEL_35:
          }
            sub_100657858();
        }

uint64_t sub_1001CC484(__int128 **a1)
{
  __int128 v13 = 0uLL;
  uint64_t v2 = sub_1001D4938(a1, &v13, 1);
  if ((_DWORD)v2)
  {
    uint64_t v3 = v2;
    if (sub_1000A86F0())
    {
      sub_1001EE134((uint64_t)"smpAuthenticationStage2 failed %!", v4, v5, v6, v7, v8, v9, v10, v3);
      uint64_t v11 = (os_log_s *)sub_100086554(0x43u);
      if (os_log_type_enabled(v11, OS_LOG_TYPE_ERROR)) {
        sub_100657F74();
      }
    }
  }

  else
  {
    char v14 = 13;
    __int128 v15 = v13;
    return sub_100184F74(*a1, &v14, 0x11uLL, 1);
  }

  return v3;
}

uint64_t sub_1001CC55C(__int128 *a1)
{
  uint64_t v37 = 0LL;
  uint64_t v38 = 0LL;
  uint64_t v2 = (_BYTE *)sub_100184F2C((uint64_t)a1);
  uint64_t v3 = (uint64_t)v2;
  if (!v2)
  {
    if (sub_1000A86F0())
    {
      sub_1001EE134((uint64_t)"Could not find associated pairing data.", v24, v25, v26, v27, v28, v29, v30, v35);
      uint64_t v31 = (os_log_s *)sub_100086554(0x43u);
      if (os_log_type_enabled(v31, OS_LOG_TYPE_ERROR)) {
        sub_100657858();
      }
    }

    uint64_t v23 = 0LL;
    goto LABEL_27;
  }

  uint64_t v4 = sub_1001D4938(v2, &v37, 0);
  if ((_DWORD)v4)
  {
    uint64_t v5 = v4;
    if (sub_1000A86F0())
    {
      sub_1001EE134((uint64_t)"smpAuthenticationStage2 failed %!", v6, v7, v8, v9, v10, v11, v12, v5);
      __int128 v13 = (os_log_s *)sub_100086554(0x43u);
      if (os_log_type_enabled(v13, OS_LOG_TYPE_ERROR)) {
        sub_100657F74();
      }
    }
  }

  if (v37 != *(void *)(v3 + 492) || v38 != *(void *)(v3 + 500))
  {
    if (sub_1000A86F0())
    {
      sub_1001EE134((uint64_t)"DHKey failed to match.", v15, v16, v17, v18, v19, v20, v21, v35);
      uint64_t v22 = (os_log_s *)sub_100086554(0x43u);
      if (os_log_type_enabled(v22, OS_LOG_TYPE_ERROR)) {
        sub_100657858();
      }
    }

    sub_1001CBE38(a1, 11, (char *)v3);
    return 0LL;
  }

  if (*(_BYTE *)(v3 + 424)) {
    sub_100185420(v3, 41);
  }
  if (*(_BYTE *)(*(void *)v3 + 70LL) == 1)
  {
    uint64_t v32 = sub_1001CC484((__int128 **)v3);
  }

  else
  {
    uint64_t v36 = 0LL;
    if (*(_BYTE *)(v3 + 16) == 1) {
      char v33 = 2;
    }
    else {
      char v33 = 3;
    }
    uint64_t v32 = sub_1001C89E4(a1, (uint64_t)&v36, 0LL, v3 + 524, 16LL, v33);
  }

  uint64_t v23 = v32;
  if ((_DWORD)v32) {
LABEL_27:
  }
    sub_1001CBE38(a1, 8, (char *)v3);
  return v23;
}

uint64_t sub_1001CC750(uint64_t a1)
{
  uint64_t v2 = *(__int128 **)a1;
  if (*(_BYTE *)(*(void *)a1 + 70LL) == 1)
  {
    v36[0] = 12;
    *(_OWORD *)&v36[1] = *(_OWORD *)(a1 + 152);
    *(_OWORD *)&v36[17] = *(_OWORD *)(a1 + 168);
    __int128 v37 = *(_OWORD *)(a1 + 184);
    __int128 v38 = *(_OWORD *)(a1 + 200);
    uint64_t v3 = sub_100184F74(v2, v36, 0x41uLL, 1);
    if ((_DWORD)v3)
    {
      uint64_t v4 = v3;
      if (sub_1000A86F0())
      {
        sub_1001EE134((uint64_t)"smpSendPairingPublicKey failed %!", v5, v6, v7, v8, v9, v10, v11, v4);
        uint64_t v12 = (os_log_s *)sub_100086554(0x43u);
        if (os_log_type_enabled(v12, OS_LOG_TYPE_ERROR)) {
          sub_100657F74();
        }
      }

      return v4;
    }

    sub_100185420(a1, 34);
    __int128 v13 = (void *)(a1 + 473);
  }

  else
  {
    __int128 v13 = (void *)(a1 + 457);
  }

  arc4random_buf(v13, 0x10uLL);
  *(void *)(a1 + 433) = 0LL;
  *(void *)(a1 + 425) = 0LL;
  *(void *)(a1 + 449) = 0LL;
  *(void *)(a1 + 441) = 0LL;
  if (*(_BYTE *)(*(void *)a1 + 70LL))
  {
    __int128 v14 = *(_OWORD *)(a1 + 328);
    *(_OWORD *)uint64_t v36 = *(_OWORD *)(a1 + 312);
    *(_OWORD *)&v36[16] = v14;
    __int128 v15 = *(_OWORD *)(a1 + 168);
    v35[0] = *(_OWORD *)(a1 + 152);
    v35[1] = v15;
    uint64_t v16 = sub_1001116D0(v35, v36, (__int128 *)(a1 + 473), 0, (void *)(a1 + 88));
    if ((_DWORD)v16)
    {
      uint64_t v17 = v16;
      if (sub_1000A86F0())
      {
        sub_1001EE134((uint64_t)"Failed to generate confirmation value %!", v18, v19, v20, v21, v22, v23, v24, v17);
        uint64_t v25 = (os_log_s *)sub_100086554(0x43u);
        if (os_log_type_enabled(v25, OS_LOG_TYPE_ERROR)) {
          sub_100657F74();
        }
      }

      return 4825LL;
    }

    else
    {
      sub_100185340((uint64_t *)a1);
      uint64_t v4 = sub_1001CCDD0(*(void *)a1, (void *)(a1 + 88));
      if ((_DWORD)v4)
      {
        if (sub_1000A86F0())
        {
          sub_1001EE134((uint64_t)"Failed to send confirmation value %!", v27, v28, v29, v30, v31, v32, v33, v4);
          uint64_t v34 = (os_log_s *)sub_100086554(0x43u);
          if (os_log_type_enabled(v34, OS_LOG_TYPE_ERROR)) {
            sub_100657F74();
          }
        }
      }
    }
  }

  else
  {
    sub_100185420(a1, 35);
    return 0LL;
  }

  return v4;
}

uint64_t sub_1001CC98C(uint64_t a1)
{
  uint64_t v2 = (void *)(a1 + 88);
  uint64_t v3 = (__int128 *)(a1 + 312);
  uint64_t v4 = (__int128 *)(a1 + 152);
  if (*(_BYTE *)(*(void *)a1 + 70LL))
  {
    unsigned int v5 = *(_DWORD *)(a1 + 441);
    arc4random_buf((void *)(a1 + 473), 0x10uLL);
    char v6 = *(_BYTE *)(a1 + 489);
    __int128 v7 = v3[1];
    __int128 v55 = *v3;
    __int128 v56 = v7;
    __int128 v8 = v4[1];
    __int128 v53 = *v4;
    __int128 v54 = v8;
    if (((v5 >> v6) & 1) != 0) {
      char v9 = -127;
    }
    else {
      char v9 = 0x80;
    }
    uint64_t v10 = sub_1001116D0(&v53, &v55, (__int128 *)(a1 + 473), v9, v2);
    if ((_DWORD)v10)
    {
      uint64_t v11 = v10;
      if (sub_1000A86F0())
      {
        sub_1001EE134((uint64_t)"Failed to generate confirmation value C %!", v12, v13, v14, v15, v16, v17, v18, v11);
        uint64_t v19 = (os_log_s *)sub_100086554(0x43u);
        if (os_log_type_enabled(v19, OS_LOG_TYPE_ERROR)) {
LABEL_29:
        }
          sub_100657F74();
      }
    }

    else
    {
      sub_100185420(a1, 34);
      if (*(_BYTE *)(a1 + 490)
        && (!*(void *)(a1 + 104) ? (BOOL v34 = *(void *)(a1 + 112) == 0LL) : (BOOL v34 = 0),
            !v34 && (uint64_t v35 = sub_1001D4718((uint64_t *)a1), (_DWORD)v35)))
      {
        uint64_t v11 = v35;
        if (sub_1000A86F0())
        {
          sub_1001EE134( (uint64_t)"recvdSMPDoSecuredConnectionPasskeySendCai failed %!",  v36,  v37,  v38,  v39,  v40,  v41,  v42,  v11);
          uint64_t v43 = (os_log_s *)sub_100086554(0x43u);
          if (os_log_type_enabled(v43, OS_LOG_TYPE_ERROR)) {
            goto LABEL_29;
          }
        }
      }

      else
      {
        return 0LL;
      }
    }
  }

  else
  {
    unsigned int v20 = *(_DWORD *)(a1 + 425);
    arc4random_buf((void *)(a1 + 457), 0x10uLL);
    char v21 = *(_BYTE *)(a1 + 489);
    __int128 v22 = v3[1];
    __int128 v53 = *v3;
    __int128 v54 = v22;
    __int128 v23 = v4[1];
    __int128 v55 = *v4;
    __int128 v56 = v23;
    if (((v20 >> v21) & 1) != 0) {
      char v24 = -127;
    }
    else {
      char v24 = 0x80;
    }
    uint64_t v25 = sub_1001116D0(&v55, &v53, (__int128 *)(a1 + 457), v24, v2);
    if ((_DWORD)v25)
    {
      uint64_t v11 = v25;
      if (sub_1000A86F0())
      {
        sub_1001EE134((uint64_t)"Failed to generate confirmation value C %!", v26, v27, v28, v29, v30, v31, v32, v11);
        uint64_t v33 = (os_log_s *)sub_100086554(0x43u);
        if (os_log_type_enabled(v33, OS_LOG_TYPE_ERROR)) {
          goto LABEL_29;
        }
      }
    }

    else
    {
      sub_100185420(a1, 35);
      uint64_t v11 = sub_1001CCDD0(*(void *)a1, v2);
      if ((_DWORD)v11)
      {
        if (sub_1000A86F0())
        {
          sub_1001EE134((uint64_t)"smpSendPairingConfirmation failed %!", v44, v45, v46, v47, v48, v49, v50, v11);
          uint64_t v51 = (os_log_s *)sub_100086554(0x43u);
          if (os_log_type_enabled(v51, OS_LOG_TYPE_ERROR)) {
            goto LABEL_29;
          }
        }
      }
    }
  }

  return v11;
}

uint64_t sub_1001CCC34(uint64_t a1, int a2, void *a3, uint8x8_t a4)
{
  int8x16_t v18 = 0uLL;
  int8x16_t v17 = 0uLL;
  uint64_t v4 = *(__int8 **)a1;
  unsigned int v5 = (__int32 *)(a1 + 579);
  char v6 = (__int32 *)(a1 + 586);
  if (*(_BYTE *)(*(void *)a1 + 70LL))
  {
    v18.i8[0] = v4[48];
    v18.i8[1] = v4[63];
    *(__int32 *)((char *)v18.i32 + 2) = *v5;
    *(__int32 *)((char *)&v18.i32[1] + 1) = *(_DWORD *)(a1 + 582);
    *(__int32 *)((char *)&v18.i32[2] + 1) = *v6;
    v18.i32[3] = *(_DWORD *)(a1 + 589);
    a4.i32[0] = *(_DWORD *)(v4 + 66);
    int16x8_t v7 = (int16x8_t)vmovl_u8(a4);
    *(int16x4_t *)v7.i8 = vrev64_s16(*(int16x4_t *)v7.i8);
    v17.i32[0] = vmovn_s16(v7).u32[0];
    v17.i8[4] = v4[65];
    v17.i8[5] = v4[64];
    __int128 v8 = v4 + 49;
    v17.i8[6] = v4[54];
    v17.i8[7] = v4[53];
    char v9 = v4 + 52;
    uint64_t v10 = v4 + 51;
    uint64_t v11 = v4 + 50;
  }

  else
  {
    v18.i8[0] = v4[63];
    v18.i8[1] = v4[48];
    *(__int32 *)((char *)v18.i32 + 2) = *v5;
    *(__int32 *)((char *)&v18.i32[1] + 1) = *(_DWORD *)(a1 + 582);
    *(__int32 *)((char *)&v18.i32[2] + 1) = *v6;
    v18.i32[3] = *(_DWORD *)(a1 + 589);
    a4.i32[0] = *(_DWORD *)(v4 + 51);
    int16x8_t v12 = (int16x8_t)vmovl_u8(a4);
    *(int16x4_t *)v12.i8 = vrev64_s16(*(int16x4_t *)v12.i8);
    v17.i32[0] = vmovn_s16(v12).u32[0];
    v17.i8[4] = v4[50];
    v17.i8[5] = v4[49];
    __int128 v8 = v4 + 64;
    v17.i8[6] = v4[69];
    v17.i8[7] = v4[68];
    char v9 = v4 + 67;
    uint64_t v10 = v4 + 66;
    uint64_t v11 = v4 + 65;
  }

  __int8 v13 = *v8;
  __int8 v14 = *v11;
  __int8 v15 = *v10;
  v17.i8[8] = *v9;
  v17.i8[9] = v15;
  v17.i8[10] = v14;
  v17.i8[11] = v13;
  return sub_100111148((__int128 *)(a1 + 17), &v18, &v17, (int8x16_t *)(a1 + 136), (int8x16_t *)(a1 + 120), a2, a3);
}

uint64_t sub_1001CCDD0(uint64_t a1, void *a2)
{
  if (byte_1008EDB51)
  {
    *a2 = 0LL;
    a2[1] = 0LL;
  }

  char v73 = 3;
  __int128 v74 = *(_OWORD *)a2;
  if (sub_10012D5EC(a1))
  {
    uint64_t v3 = sub_100184F2C(a1);
    if (v3)
    {
      uint64_t v4 = v3;
      int v5 = *(unsigned __int8 *)(a1 + 70);
      if ((*(_BYTE *)(v3 + 72) & *(_BYTE *)(v3 + 80) & 8) != 0)
      {
        if (v5 != 1)
        {
LABEL_9:
          if (!v5 && !sub_10018550C(v4, 35))
          {
            char v6 = sub_100185414();
            sub_1001EE134( (uint64_t)"Central connection should be in SMP_STATE_PAIRING_SCONFIRM to send this command, current state is %s.",  v7,  v8,  v9,  v10,  v11,  v12,  v13,  (uint64_t)v6);
            __int8 v14 = (os_log_s *)sub_100086554(0x43u);
            if (!os_log_type_enabled(v14, OS_LOG_TYPE_ERROR)) {
              return 4823LL;
            }
            goto LABEL_44;
          }

uint64_t sub_1001CD18C(uint64_t a1, int a2, unsigned __int8 a3)
{
  char v3 = byte_1008D8ED1;
  else {
    char v4 = byte_1008D8ED2;
  }
  char v5 = v3 & 0xF7;
  char v6 = v4 & 0xF7;
  if (byte_1008EDB00) {
    char v7 = v3 & 0xF7;
  }
  else {
    char v7 = v3;
  }
  if (byte_1008EDB00) {
    char v8 = v4 & 0xF7;
  }
  else {
    char v8 = v4;
  }
  if (!a1 || !sub_10012D5EC(a1))
  {
    sub_1001EE134((uint64_t)"This handle is not a LE connection.", v25, v26, v27, v28, v29, v30, v31, v97);
    uint64_t v32 = (os_log_s *)sub_100086554(0x43u);
    if (!os_log_type_enabled(v32, OS_LOG_TYPE_ERROR)) {
      return 4820LL;
    }
LABEL_34:
    sub_100657858();
    return 4820LL;
  }

  uint64_t v12 = sub_100184F2C(a1);
  if (!v12)
  {
    sub_1001EE134( (uint64_t)"There is no security request for this connection. Ignoring reply.",  v34,  v35,  v36,  v37,  v38,  v39,  v40,  v97);
    uint64_t v41 = (os_log_s *)sub_100086554(0x43u);
    if (!os_log_type_enabled(v41, OS_LOG_TYPE_ERROR)) {
      return 4820LL;
    }
    goto LABEL_34;
  }

  uint64_t v13 = (char *)v12;
  *(_BYTE *)(v12 + 72) = a3;
  if (!a2)
  {
LABEL_73:
    sub_1001CBE38((__int128 *)a1, 8, v13);
    return 0LL;
  }

  if (*(_BYTE *)(a1 + 55)) {
    __int8 v14 = (_DWORD *)(a1 + 56);
  }
  else {
    __int8 v14 = 0LL;
  }
  BOOL v15 = sub_1001C822C((_DWORD *)(a1 + 48), v14);
  char v16 = v13[80];
  if ((v16 & 4) != 0 && byte_1008D8ED3 != 3) {
    v13[72] |= 4u;
  }
  if ((v16 & 8) != 0 && byte_1008EDB01)
  {
    v13[72] |= 8u;
    if ((byte_1008EDB02 & 1) == 0 && (v16 & 0x20) != 0 && !*(_BYTE *)(a1 + 232) && (v7 & 8) != 0)
    {
      if (sub_1000A86F0())
      {
        sub_1001EE134((uint64_t)"Sending CT2=1", v17, v18, v19, v20, v21, v22, v23, v97);
        uint64_t v24 = (os_log_s *)sub_100086554(0x43u);
        if (os_log_type_enabled(v24, OS_LOG_TYPE_DEFAULT))
        {
          *(_DWORD *)buf = 136446210;
          uint64_t v99 = sub_1001EDDCC();
          _os_log_impl((void *)&_mh_execute_header, v24, OS_LOG_TYPE_DEFAULT, " %{public}s", buf, 0xCu);
        }
      }

      a3 |= 0x20u;
    }
  }

  else
  {
    a3 &= ~0x20u;
    char v7 = v5;
    char v8 = v6;
  }

  if (*(_BYTE *)(a1 + 232)) {
    unsigned __int8 v42 = a3 & 0xDF;
  }
  else {
    unsigned __int8 v42 = a3;
  }
  if (*(_BYTE *)(a1 + 232))
  {
    char v7 = v5;
    char v43 = v6;
  }

  else
  {
    char v43 = v8;
  }

  if (byte_1008EDB03 == 1 && (v42 & 0x20) == 0)
  {
    if (sub_1000A86F0())
    {
      sub_1001EE134((uint64_t)"Force sending CT2=1", v44, v45, v46, v47, v48, v49, v50, v97);
      uint64_t v51 = (os_log_s *)sub_100086554(0x43u);
      if (os_log_type_enabled(v51, OS_LOG_TYPE_DEFAULT))
      {
        uint64_t v52 = sub_1001EDDCC();
        *(_DWORD *)buf = 136446210;
        uint64_t v99 = v52;
        _os_log_impl((void *)&_mh_execute_header, v51, OS_LOG_TYPE_DEFAULT, " %{public}s", buf, 0xCu);
      }
    }

    v42 |= 0x20u;
  }

  v13[73] = v15;
  v13[76] &= v7;
  v13[74] &= v43;
  v13[72] |= byte_1008EDB04 | v42;
  if (sub_1000A86F0())
  {
    sub_1001EE134((uint64_t)"authReq=%x expectedKeys=%x requestedKeys=%x", v53, v54, v55, v56, v57, v58, v59, v42);
    uint64_t v60 = (os_log_s *)sub_100086554(0x43u);
    if (os_log_type_enabled(v60, OS_LOG_TYPE_DEFAULT))
    {
      uint64_t v61 = sub_1001EDDCC();
      *(_DWORD *)buf = 136446210;
      uint64_t v99 = v61;
      _os_log_impl((void *)&_mh_execute_header, v60, OS_LOG_TYPE_DEFAULT, " %{public}s", buf, 0xCu);
    }
  }

  uint8_t v62 = v13[73];
  uint8_t v63 = v13[72];
  char v64 = v13[74];
  char v65 = v13[76];
  buf[0] = 2;
  buf[1] = byte_1008D8ED3;
  buf[2] = v62;
  buf[3] = v63;
  LOBYTE(v99) = 16;
  BYTE1(v99) = v64;
  BYTE2(v99) = v65;
  if (!sub_10012D5EC(a1))
  {
    sub_1001EE134((uint64_t)"This command is only available to LE devices.", v69, v70, v71, v72, v73, v74, v75, v97);
    uint64_t v76 = (os_log_s *)sub_100086554(0x43u);
    if (!os_log_type_enabled(v76, OS_LOG_TYPE_ERROR)) {
      goto LABEL_73;
    }
    goto LABEL_72;
  }

  if (*(_BYTE *)(a1 + 70) != 1)
  {
    sub_1001EE134((uint64_t)"You cannot send this command when central.", v77, v78, v79, v80, v81, v82, v83, v97);
    uint64_t v84 = (os_log_s *)sub_100086554(0x43u);
    if (!os_log_type_enabled(v84, OS_LOG_TYPE_ERROR)) {
      goto LABEL_73;
    }
    goto LABEL_72;
  }

  uint64_t v66 = sub_100184F2C(a1);
  if (!v66)
  {
    if ((sub_1000A86F0() & 1) == 0) {
      goto LABEL_73;
    }
    goto LABEL_71;
  }

  uint64_t v67 = v66;
  if (!sub_10018550C(v66, 17))
  {
    sub_100185414();
LABEL_71:
    sub_1001EE134((uint64_t)"Invalid pairing state for handle 0x%x : %s", v85, v86, v87, v88, v89, v90, v91, a1);
    uint64_t v92 = (os_log_s *)sub_100086554(0x43u);
    if (!os_log_type_enabled(v92, OS_LOG_TYPE_ERROR)) {
      goto LABEL_73;
    }
LABEL_72:
    sub_100657858();
    goto LABEL_73;
  }

  uint64_t v68 = sub_100184F74(*(__int128 **)v67, (char *)buf, 7uLL, 1);
  if ((_DWORD)v68)
  {
    sub_100184BB0((char *)v67, v68, 1);
    goto LABEL_73;
  }

  sub_100185420(v67, 18);
  *(_DWORD *)(v67 + 586) = *(_DWORD *)buf;
  *(_WORD *)(v67 + 590) = (_WORD)v99;
  *(_BYTE *)(v67 + 592) = BYTE2(v99);
  int v93 = v13[72];
  int v94 = v13[80];
  int v95 = v13[73];
  if ((v93 & v94 & 8) != 0)
  {
    if (v95 == 1) {
      goto LABEL_79;
    }
  }

  else if (v95 != 1)
  {
    goto LABEL_80;
  }

  if (v13[79] == 1)
  {
LABEL_79:
    char v96 = 5;
    goto LABEL_83;
  }

uint64_t sub_1001CD768(int a1, unsigned int a2, int a3)
{
  switch(a1)
  {
    case 0:
      if (a2 >= 5) {
        goto LABEL_14;
      }
      unint64_t v3 = 0x201020101uLL >> (8 * a2);
      break;
    case 1:
      LOBYTE(v3) = 1;
      switch(a2)
      {
        case 0u:
        case 3u:
          return v3;
        case 1u:
          if (a3) {
            LOBYTE(v3) = 6;
          }
          else {
            LOBYTE(v3) = 1;
          }
          break;
        case 2u:
          goto LABEL_16;
        case 4u:
          goto LABEL_17;
        default:
          goto LABEL_14;
      }

      break;
    case 2:
      if (a2 >= 5) {
        goto LABEL_14;
      }
      unint64_t v3 = 0x301040303uLL >> (8 * a2);
      break;
    case 3:
      if (a2 >= 5) {
        goto LABEL_14;
      }
LABEL_13:
      LOBYTE(v3) = 1;
      break;
    case 4:
      LOBYTE(v3) = 3;
      switch(a2)
      {
        case 0u:
          return v3;
        case 1u:
          BOOL v4 = a3 == 0;
          LOBYTE(v3) = 3;
          goto LABEL_18;
        case 2u:
LABEL_16:
          LOBYTE(v3) = 2;
          return v3;
        case 3u:
          goto LABEL_13;
        case 4u:
LABEL_17:
          BOOL v4 = a3 == 0;
          LOBYTE(v3) = 2;
LABEL_18:
          if (!v4) {
            LOBYTE(v3) = 6;
          }
          break;
        default:
          goto LABEL_14;
      }

      break;
    default:
LABEL_14:
      sub_1001EE2A0();
      LOBYTE(v3) = 1;
      break;
  }

  return v3;
}

uint64_t sub_1001CD880(uint64_t a1, int a2)
{
  char v3 = *(_BYTE *)(a1 + 80) & *(_BYTE *)(a1 + 72);
  if ((v3 & 8) == 0)
  {
    *(_BYTE *)(a1 + 74) &= ~8u;
    *(_BYTE *)(a1 + 76) &= ~8u;
    arc4random_buf((void *)(a1 + 120), 0x10uLL);
    if (off_1008F6EB0)
    {
      int v5 = *(unsigned __int8 *)(a1 + 16);
      if (v5 != 1)
      {
        if (a2) {
          int v6 = 2;
        }
        else {
          int v6 = 3;
        }
        if (v5 == v6)
        {
          *(_DWORD *)__buf = 0;
          *(_DWORD *)(a1 + 52) = 1;
          arc4random_buf(__buf, 4uLL);
          unsigned int v7 = *(_DWORD *)__buf % 0xF423Fu + 1;
          *(_WORD *)(a1 + 33) = v7;
          *(_WORD *)(a1 + 35) = BYTE2(v7);
LABEL_35:
          sub_1001D47A4(*(void *)a1);
          return 0LL;
        }

        if (v5 == 5) {
          int v18 = 3;
        }
        else {
          int v18 = 2;
        }
LABEL_34:
        *(_DWORD *)(a1 + 52) = v18;
        goto LABEL_35;
      }

uint64_t sub_1001CDB98(const void *a1, unsigned int a2)
{
  if (a2 < 0x10) {
    return 1LL;
  }
  __int128 __s2 = xmmword_1006BDDF0;
  v13[0] = 0LL;
  v13[1] = 0LL;
  sub_1001F0050((uint64_t)v13, (uint64_t)&__s2, 0x10uLL);
  if (memcmp(a1, &__s2, a2))
  {
    if (memcmp(a1, v13, a2)) {
      return 1LL;
    }
  }

  uint64_t result = sub_1000A86F0();
  if ((_DWORD)result)
  {
    sub_1001EE134((uint64_t)"Peer device is using a debug LTK, aborting pairing", v5, v6, v7, v8, v9, v10, v11, v13[0]);
    uint64_t v12 = (os_log_s *)sub_100086554(0x43u);
    uint64_t result = os_log_type_enabled(v12, OS_LOG_TYPE_ERROR);
    if ((_DWORD)result)
    {
      sub_100657858();
      return 0LL;
    }
  }

  return result;
}

uint64_t sub_1001CDC8C(_BYTE *a1, uint64_t a2)
{
  if (!a2)
  {
    if (sub_1000A86F0())
    {
      sub_1001EE134((uint64_t)"Invalid keys structure.", v22, v23, v24, v25, v26, v27, v28, v32);
      __int128 v29 = (os_log_s *)sub_100086554(0x43u);
      if (os_log_type_enabled(v29, OS_LOG_TYPE_ERROR)) {
        sub_100657858();
      }
    }

    return 101LL;
  }

  if (!a1 || !sub_10012D5EC((uint64_t)a1))
  {
    if (sub_1000A86F0())
    {
      sub_1001EE134((uint64_t)"This handle is not a LE connection.", v14, v15, v16, v17, v18, v19, v20, v32);
      uint64_t v21 = (os_log_s *)sub_100086554(0x43u);
      if (os_log_type_enabled(v21, OS_LOG_TYPE_ERROR)) {
        sub_100657858();
      }
    }

    return 4820LL;
  }

  a1[264] = *(_BYTE *)(a2 + 82);
  if (a1[166] == 3)
  {
    if (a1[55]) {
      BOOL v4 = a1 + 56;
    }
    else {
      BOOL v4 = a1 + 48;
    }
    uint64_t v5 = sub_1001C7E38(v4, a2 + 28, *(unsigned __int8 *)(a2 + 44), *(_BYTE *)(a2 + 45));
    if ((_DWORD)v5 && sub_1000A86F0())
    {
      sub_1001EE134((uint64_t)"LE_LongTermKeyReply failed %!", v6, v7, v8, v9, v10, v11, v12, v5);
      uint64_t v13 = (os_log_s *)sub_100086554(0x43u);
      if (os_log_type_enabled(v13, OS_LOG_TYPE_ERROR)) {
        sub_100657F74();
      }
    }

    return v5;
  }

  int v31 = *(unsigned __int16 *)(a2 + 80);
  if ((v31 & 8) != 0 && (*(_BYTE *)(a2 + 45) & 0xFE) == 2)
  {
    uint64_t v33 = 0LL;
    a1[208] = 1;
    return sub_1001C89E4(a1, (uint64_t)&v33, 0LL, a2 + 28, *(unsigned __int8 *)(a2 + 44), *(_BYTE *)(a2 + 45));
  }

  if ((~v31 & 7) != 0) {
    return 101LL;
  }
  a1[208] = 1;
  return sub_1001C89E4( a1,  a2 + 20,  *(unsigned __int16 *)(a2 + 18),  a2,  *(unsigned __int8 *)(a2 + 16),  *(_BYTE *)(a2 + 17));
}

uint64_t sub_1001CDEA4(uint64_t a1, int a2, uint64_t a3)
{
  char v3 = byte_1008D8ED1;
  else {
    char v4 = byte_1008D8ED2;
  }
  char v5 = v3 & 0xF7;
  char v6 = v4 & 0xF7;
  if (byte_1008EDB00) {
    char v7 = v3 & 0xF7;
  }
  else {
    char v7 = v3;
  }
  if (byte_1008EDB00) {
    char v8 = v4 & 0xF7;
  }
  else {
    char v8 = v4;
  }
  if (!a1 || !sub_10012D5EC(a1))
  {
    sub_1001EE134((uint64_t)"This handle is not a LE connection.", v29, v30, v31, v32, v33, v34, v35, v59);
    uint64_t v36 = (os_log_s *)sub_100086554(0x43u);
    if (!os_log_type_enabled(v36, OS_LOG_TYPE_ERROR)) {
      return 4820LL;
    }
LABEL_33:
    sub_100657858();
    return 4820LL;
  }

  uint64_t v12 = sub_100184F2C(a1);
  if (!v12)
  {
    sub_1001EE134( (uint64_t)"There is no security request for this connection. Ignoring reply.",  v37,  v38,  v39,  v40,  v41,  v42,  v43,  v59);
    uint64_t v44 = (os_log_s *)sub_100086554(0x43u);
    if (!os_log_type_enabled(v44, OS_LOG_TYPE_ERROR)) {
      return 4820LL;
    }
    goto LABEL_33;
  }

  uint64_t v13 = (char *)v12;
  if (!a2) {
    goto LABEL_53;
  }
  if (!a3 || (uint64_t result = sub_1001C8C38((_BYTE *)a1, a3), (_DWORD)result))
  {
    if (*(_BYTE *)(a1 + 55)) {
      uint64_t v15 = (_DWORD *)(a1 + 56);
    }
    else {
      uint64_t v15 = 0LL;
    }
    char v16 = sub_1001C822C((_DWORD *)(a1 + 48), v15);
    int v17 = v13[80] & 4;
    int v18 = byte_1008EDB04;
    int v19 = v17 | v18 | sub_1001BD960();
    if ((v13[80] & 8) != 0 && byte_1008EDB01)
    {
      unsigned __int8 v20 = v19 | 8;
      if ((byte_1008EDB02 & 1) == 0 && (v13[80] & 0x20) != 0 && !*(_BYTE *)(a1 + 232) && (v7 & 8) != 0)
      {
        if (sub_1000A86F0())
        {
          sub_1001EE134((uint64_t)"Sending CT2=1", v21, v22, v23, v24, v25, v26, v27, v59);
          uint64_t v28 = (os_log_s *)sub_100086554(0x43u);
          if (os_log_type_enabled(v28, OS_LOG_TYPE_DEFAULT))
          {
            *(_DWORD *)buf = 136446210;
            uint64_t v61 = sub_1001EDDCC();
            _os_log_impl((void *)&_mh_execute_header, v28, OS_LOG_TYPE_DEFAULT, " %{public}s", buf, 0xCu);
          }
        }

        unsigned __int8 v20 = v19 | 0x28;
      }
    }

    else
    {
      unsigned __int8 v20 = v19 & 0xDF;
      char v7 = v5;
      char v8 = v6;
    }

    if (*(_BYTE *)(a1 + 232)) {
      unsigned __int8 v45 = v20 & 0xDF;
    }
    else {
      unsigned __int8 v45 = v20;
    }
    if (*(_BYTE *)(a1 + 232))
    {
      char v7 = v5;
      char v46 = v6;
    }

    else
    {
      char v46 = v8;
    }

    if (sub_1000A86F0())
    {
      sub_1001EE134((uint64_t)"authReq=%x expectedKeys=%x requestedKeys=%x", v47, v48, v49, v50, v51, v52, v53, v45);
      uint64_t v54 = (os_log_s *)sub_100086554(0x43u);
      if (os_log_type_enabled(v54, OS_LOG_TYPE_DEFAULT))
      {
        uint64_t v55 = sub_1001EDDCC();
        *(_DWORD *)buf = 136446210;
        uint64_t v61 = v55;
        _os_log_impl((void *)&_mh_execute_header, v54, OS_LOG_TYPE_DEFAULT, " %{public}s", buf, 0xCu);
      }
    }

    if (byte_1008EDB05)
    {
      uint64_t v56 = (__int128 *)a1;
      int v57 = 3;
LABEL_54:
      sub_1001CBE38(v56, v57, v13);
      return 0LL;
    }

    int v58 = sub_1001CE204(a1, byte_1008D8ED3, v16, v45, v7, v46);
    uint64_t result = 0LL;
    if (v58)
    {
      if (v58 != 4804)
      {
LABEL_53:
        uint64_t v56 = (__int128 *)a1;
        int v57 = 8;
        goto LABEL_54;
      }
    }
  }

  return result;
}

uint64_t sub_1001CE204(uint64_t a1, char a2, char a3, char a4, char a5, char a6)
{
  LOBYTE(v47) = 1;
  BYTE1(v47) = a2;
  BYTE2(v47) = a3;
  HIBYTE(v47) = a4;
  LOBYTE(v48) = 16;
  HIBYTE(v48) = a5;
  char v49 = a6;
  if (sub_10012D5EC(a1))
  {
    if (*(_BYTE *)(a1 + 70))
    {
      if (sub_1000A86F0())
      {
        sub_1001EE134((uint64_t)"You cannot send this command when peripheral.", v9, v10, v11, v12, v13, v14, v15, v46);
        char v16 = (os_log_s *)sub_100086554(0x43u);
        if (os_log_type_enabled(v16, OS_LOG_TYPE_ERROR)) {
          sub_100657858();
        }
      }

      return 4821LL;
    }

    uint64_t v27 = sub_100184F2C(a1);
    if (v27)
    {
      uint64_t v28 = (_BYTE *)v27;
      if (*(unsigned __int8 *)(v27 + 8) >= 0x11u)
      {
        if (sub_1000A86F0())
        {
          uint64_t v29 = sub_100185414();
          sub_1001EE134( (uint64_t)"Cannot ask for pairing, device is already in state %s.",  v30,  v31,  v32,  v33,  v34,  v35,  v36,  (uint64_t)v29);
          uint64_t v37 = (os_log_s *)sub_100086554(0x43u);
          if (os_log_type_enabled(v37, OS_LOG_TYPE_ERROR)) {
            sub_100657F74();
          }
        }

        return 4804LL;
      }

void sub_1001CE42C(uint64_t a1, int *a2, uint64_t a3)
{
  uint64_t v110 = a1;
  char v6 = byte_1008D8ED1;
  else {
    char v7 = byte_1008D8ED2;
  }
  if (byte_1008EDB00) {
    char v8 = v6 & 0xF7;
  }
  else {
    char v8 = v6;
  }
  if (byte_1008EDB00) {
    char v9 = v7 & 0xF7;
  }
  else {
    char v9 = v7;
  }
  uint64_t v10 = (uint64_t *)sub_100184F2C(a1);
  uint64_t v11 = (char *)v10;
  int v12 = byte_1008EDB50;
  if (byte_1008EDB50) {
    goto LABEL_51;
  }
  if ((_DWORD)a3 != 6)
  {
    sub_1001EE134((uint64_t)"Invalid Pairing Request size %d.", v22, v23, v24, v25, v26, v27, v28, a3);
    uint64_t v29 = (os_log_s *)sub_100086554(0x43u);
    if (!os_log_type_enabled(v29, OS_LOG_TYPE_ERROR)) {
      goto LABEL_50;
    }
LABEL_69:
    sub_100657858();
LABEL_50:
    int v12 = 8;
    goto LABEL_51;
  }

  if (!*(_BYTE *)(a1 + 70))
  {
    sub_1001EE134( (uint64_t)"This command should only be received if we are peripheral.",  v30,  v31,  v32,  v33,  v34,  v35,  v36,  v109);
    uint64_t v37 = (os_log_s *)sub_100086554(0x43u);
    if (!os_log_type_enabled(v37, OS_LOG_TYPE_ERROR)) {
      goto LABEL_50;
    }
    goto LABEL_69;
  }

  if (v10)
  {
    sub_100185340(v10);
    if (!sub_10018550C((uint64_t)v11, 16) && !v11[9])
    {
      uint64_t v13 = sub_100185414();
      sub_1001EE134( (uint64_t)"Received pairing request from central, but we had already a previous non-encrypted entry in state %s.",  v14,  v15,  v16,  v17,  v18,  v19,  v20,  (uint64_t)v13);
      uint64_t v21 = (os_log_s *)sub_100086554(0x43u);
      if (!os_log_type_enabled(v21, OS_LOG_TYPE_ERROR)) {
        goto LABEL_50;
      }
      goto LABEL_69;
    }
  }

  else
  {
    uint64_t v11 = sub_100185244(a1);
    if (!v11)
    {
      if (sub_1000A86F0())
      {
        sub_1001EE134((uint64_t)"Could not allocate new device...", v70, v71, v72, v73, v74, v75, v76, v109);
        uint64_t v77 = (os_log_s *)sub_100086554(0x43u);
        if (os_log_type_enabled(v77, OS_LOG_TYPE_ERROR)) {
          sub_100657858();
        }
      }

      uint64_t v11 = 0LL;
      goto LABEL_50;
    }
  }

  sub_1001852E0( (uint64_t)v11,  *(_BYTE *)a2,  *((_BYTE *)a2 + 1),  *((_BYTE *)a2 + 2),  *((unsigned __int8 *)a2 + 3),  *((_BYTE *)a2 + 4),  *((_BYTE *)a2 + 5));
  if (v11[78] >= 5u)
  {
    if (sub_1000A86F0())
    {
      sub_1001EE134((uint64_t)"Invalid remote IOCaps %d.", v38, v39, v40, v41, v42, v43, v44, v11[78]);
      unsigned __int8 v45 = (os_log_s *)sub_100086554(0x43u);
      if (os_log_type_enabled(v45, OS_LOG_TYPE_ERROR)) {
        sub_100657858();
      }
    }

    goto LABEL_32;
  }

  if (v11[79] >= 2u)
  {
    sub_1001EE134((uint64_t)"Invalid OOB flags %d.", v46, v47, v48, v49, v50, v51, v52, v11[79]);
    uint64_t v53 = (os_log_s *)sub_100086554(0x43u);
    if (!os_log_type_enabled(v53, OS_LOG_TYPE_ERROR)) {
      goto LABEL_50;
    }
    goto LABEL_69;
  }

  if ((v11[80] & 0xC2) != 0)
  {
    if (sub_1000A86F0())
    {
      sub_1001EE134( (uint64_t)"Invalid authentication requirements 0x%x.",  v54,  v55,  v56,  v57,  v58,  v59,  v60,  v11[80]);
      uint64_t v61 = (os_log_s *)sub_100086554(0x43u);
      if (os_log_type_enabled(v61, OS_LOG_TYPE_ERROR)) {
        sub_100657858();
      }
    }
  }

  if (v11[81] - 17 <= 0xFFFFFFF5)
  {
    if (sub_1000A86F0())
    {
      sub_1001EE134( (uint64_t)"Invalid maximum encryption size %d",  v62,  v63,  v64,  v65,  v66,  v67,  v68,  v11[81]);
      uint64_t v69 = (os_log_s *)sub_100086554(0x43u);
      if (os_log_type_enabled(v69, OS_LOG_TYPE_ERROR)) {
        sub_100657858();
      }
    }

    int v12 = 6;
    goto LABEL_51;
  }

  unsigned int v78 = v11[82];
  if (v78 > 0xF || (unsigned int v79 = v11[83], v79 >= 0x10))
  {
    sub_1001EE134( (uint64_t)"Invalid key distribution parameters initiator:0x%x, responder:0xx",  v93,  v94,  v95,  v96,  v97,  v98,  v99,  v11[82]);
    uint64_t v100 = (os_log_s *)sub_100086554(0x43u);
    if (!os_log_type_enabled(v100, OS_LOG_TYPE_ERROR)) {
      goto LABEL_50;
    }
    goto LABEL_69;
  }

  if (byte_1008EDB05 && (v11[80] & 8) == 0)
  {
LABEL_32:
    int v12 = 3;
LABEL_51:
    sub_1001CBE38((__int128 *)a1, v12, v11);
    return;
  }

  char v80 = v78 & v9;
  if (byte_1008D8ED1 != -1) {
    char v80 = byte_1008D8ED1;
  }
  v11[74] = v80;
  v11[75] = 0;
  char v81 = v79 & v8;
  v11[76] = v81;
  v11[77] = 0;
  sub_100185420((uint64_t)v11, 17);
  v11[579] = 1;
  int v82 = *a2;
  *((_WORD *)v11 + 292) = *((_WORD *)a2 + 2);
  *((_DWORD *)v11 + 145) = v82;
  if (off_1008F6EA8)
  {
    if (*(_DWORD *)(v110 + 132) == 7)
    {
      *((void *)&buf + 1) = &v110;
      *(void *)&__int128 buf = 8LL;
      uint64_t v83 = sub_1001EE6E8((uint64_t)sub_1001D3118, (const void **)&buf, 0, 0LL);
      if ((_DWORD)v83)
      {
        uint64_t v84 = v83;
        if (sub_1000A86F0())
        {
          sub_1001EE134( (uint64_t)"Could not dispatch pairing request with status %!.",  v85,  v86,  v87,  v88,  v89,  v90,  v91,  v84);
          uint64_t v92 = (os_log_s *)sub_100086554(0x43u);
          if (os_log_type_enabled(v92, OS_LOG_TYPE_ERROR)) {
            sub_100657F74();
          }
        }
      }
    }

    else if (sub_1000A86F0())
    {
      sub_1001EE134( (uint64_t)"Got Pairing Request before link is ready for handle %p, lets handle this when the link is actually read y. Link state is %d",  v101,  v102,  v103,  v104,  v105,  v106,  v107,  v110);
      uint64_t v108 = (os_log_s *)sub_100086554(0x43u);
      if (os_log_type_enabled(v108, OS_LOG_TYPE_DEFAULT))
      {
        LODWORD(buf) = 136446210;
        *(void *)((char *)&buf + 4) = sub_1001EDDCC();
        _os_log_impl((void *)&_mh_execute_header, v108, OS_LOG_TYPE_DEFAULT, " %{public}s", (uint8_t *)&buf, 0xCu);
      }
    }
  }

uint64_t sub_1001CE9C0(uint64_t a1, int *a2, uint64_t a3)
{
  char v6 = (uint64_t *)sub_100184F2C(a1);
  uint64_t v7 = (uint64_t)v6;
  if (!v6)
  {
    sub_1001EE134( (uint64_t)"Pairing response with no pairing request for handle %d.",  v17,  v18,  v19,  v20,  v21,  v22,  v23,  a1);
    uint64_t v24 = (os_log_s *)sub_100086554(0x43u);
    if (!os_log_type_enabled(v24, OS_LOG_TYPE_ERROR)) {
      goto LABEL_46;
    }
LABEL_45:
    sub_100657858();
LABEL_46:
    int v8 = 8;
    return sub_1001CBE38((__int128 *)a1, v8, (char *)v7);
  }

  int v8 = byte_1008EDB50;
  if (byte_1008EDB50) {
    return sub_1001CBE38((__int128 *)a1, v8, (char *)v7);
  }
  if ((_DWORD)a3 != 6)
  {
    sub_1001EE134((uint64_t)"Invalid Pairing Response size %d.", v25, v26, v27, v28, v29, v30, v31, a3);
    uint64_t v32 = (os_log_s *)sub_100086554(0x43u);
    if (!os_log_type_enabled(v32, OS_LOG_TYPE_ERROR)) {
      goto LABEL_46;
    }
    goto LABEL_45;
  }

  sub_100185340(v6);
  if (*(_BYTE *)(a1 + 70) == 1)
  {
    sub_1001EE134( (uint64_t)"This command should only be received if we are central.",  v9,  v10,  v11,  v12,  v13,  v14,  v15,  v89);
    uint64_t v16 = (os_log_s *)sub_100086554(0x43u);
    if (!os_log_type_enabled(v16, OS_LOG_TYPE_ERROR)) {
      goto LABEL_46;
    }
    goto LABEL_45;
  }

  if (!sub_10018550C(v7, 17))
  {
    sub_1001EE134( (uint64_t)"Pairing response was received without a pairing request for handle %d.",  v41,  v42,  v43,  v44,  v45,  v46,  v47,  a1);
    uint64_t v48 = (os_log_s *)sub_100086554(0x43u);
    if (!os_log_type_enabled(v48, OS_LOG_TYPE_ERROR)) {
      goto LABEL_46;
    }
    goto LABEL_45;
  }

  sub_1001852E0( v7,  *(_BYTE *)a2,  *((_BYTE *)a2 + 1),  *((_BYTE *)a2 + 2),  *((unsigned __int8 *)a2 + 3),  *((_BYTE *)a2 + 4),  *((_BYTE *)a2 + 5));
  if (*(unsigned __int8 *)(v7 + 78) >= 5u)
  {
    if (sub_1000A86F0())
    {
      sub_1001EE134( (uint64_t)"Invalid remote IOCaps %d.",  v33,  v34,  v35,  v36,  v37,  v38,  v39,  *(unsigned __int8 *)(v7 + 78));
      uint64_t v40 = (os_log_s *)sub_100086554(0x43u);
      if (os_log_type_enabled(v40, OS_LOG_TYPE_ERROR)) {
        sub_100657858();
      }
    }

    goto LABEL_19;
  }

  if (*(unsigned __int8 *)(v7 + 79) >= 2u)
  {
    sub_1001EE134((uint64_t)"Invalid OOB flags %d.", v49, v50, v51, v52, v53, v54, v55, *(unsigned __int8 *)(v7 + 79));
    uint64_t v56 = (os_log_s *)sub_100086554(0x43u);
    if (!os_log_type_enabled(v56, OS_LOG_TYPE_ERROR)) {
      goto LABEL_46;
    }
    goto LABEL_45;
  }

  if ((*(_BYTE *)(v7 + 80) & 0xC2) != 0)
  {
    if (sub_1000A86F0())
    {
      sub_1001EE134( (uint64_t)"Invalid authentication requirements 0x%x.",  v57,  v58,  v59,  v60,  v61,  v62,  v63,  *(unsigned __int8 *)(v7 + 80));
      uint64_t v64 = (os_log_s *)sub_100086554(0x43u);
      if (os_log_type_enabled(v64, OS_LOG_TYPE_ERROR)) {
        sub_100657858();
      }
    }
  }

  if (*(unsigned __int8 *)(v7 + 81) - 17 <= 0xFFFFFFF5)
  {
    if (sub_1000A86F0())
    {
      sub_1001EE134( (uint64_t)"Invalid maximum encryption size %d",  v65,  v66,  v67,  v68,  v69,  v70,  v71,  *(unsigned __int8 *)(v7 + 81));
      uint64_t v72 = (os_log_s *)sub_100086554(0x43u);
      if (os_log_type_enabled(v72, OS_LOG_TYPE_ERROR)) {
        sub_100657858();
      }
    }

    int v8 = 6;
    return sub_1001CBE38((__int128 *)a1, v8, (char *)v7);
  }

  unsigned int v73 = *(unsigned __int8 *)(v7 + 82);
  if (v73 > 0xF || (unsigned int v74 = *(unsigned __int8 *)(v7 + 83), v74 >= 0x10))
  {
    sub_1001EE134( (uint64_t)"Invalid key distribution parameters initiator:0x%x, responder:0xx",  v78,  v79,  v80,  v81,  v82,  v83,  v84,  *(unsigned __int8 *)(v7 + 82));
    uint64_t v85 = (os_log_s *)sub_100086554(0x43u);
    if (!os_log_type_enabled(v85, OS_LOG_TYPE_ERROR)) {
      goto LABEL_46;
    }
    goto LABEL_45;
  }

  *(_BYTE *)(v7 + 76) = v73 & 0xB;
  *(_BYTE *)(v7 + 75) = 0;
  *(_BYTE *)(v7 + 74) = v74 & 0xB;
  *(_BYTE *)(v7 + 77) = 0;
  sub_100185420(v7, 18);
  int v75 = *(unsigned __int8 *)(v7 + 72);
  int v76 = *(unsigned __int8 *)(v7 + 80);
  if (byte_1008EDB05 && (v75 & v76 & 8) == 0)
  {
LABEL_19:
    int v8 = 3;
    return sub_1001CBE38((__int128 *)a1, v8, (char *)v7);
  }

  int v77 = *(unsigned __int8 *)(v7 + 73);
  if ((v75 & v76 & 8) != 0)
  {
    if (v77 == 1) {
      goto LABEL_50;
    }
  }

  else if (v77 != 1)
  {
    goto LABEL_51;
  }

  if (*(_BYTE *)(v7 + 79) == 1)
  {
LABEL_50:
    char v87 = 5;
    goto LABEL_54;
  }

void sub_1001CEE10(uint64_t a1, _OWORD *a2, uint64_t a3)
{
  uint64_t v6 = sub_100184F2C(a1);
  uint64_t v7 = v6;
  if (!v6)
  {
    sub_1001EE134((uint64_t)"Could not find associated pairing data.", v20, v21, v22, v23, v24, v25, v26, v128);
    uint64_t v27 = (os_log_s *)sub_100086554(0x43u);
    if (!os_log_type_enabled(v27, OS_LOG_TYPE_ERROR)) {
      goto LABEL_23;
    }
    goto LABEL_22;
  }

  if ((_DWORD)a3 != 16)
  {
    sub_1001EE134((uint64_t)"Invalid Pairing Confirmation size %d", v28, v29, v30, v31, v32, v33, v34, a3);
    uint64_t v35 = (os_log_s *)sub_100086554(0x43u);
    if (!os_log_type_enabled(v35, OS_LOG_TYPE_ERROR)) {
      goto LABEL_23;
    }
    goto LABEL_22;
  }

  char v8 = *(_BYTE *)(v6 + 72) & *(_BYTE *)(v6 + 80);
  uint64_t v9 = (uint64_t *)sub_100184F2C(a1);
  uint64_t v7 = (uint64_t)v9;
  if ((v8 & 8) == 0)
  {
    if (v9)
    {
      sub_100185340(v9);
      int v36 = *(unsigned __int8 *)(a1 + 70);
      if (v36 == 1)
      {
        if (!sub_10018550C(v7, 18))
        {
          uint64_t v81 = sub_100185414();
          sub_1001EE134( (uint64_t)"Device was not in the proper state. State is %s.",  v82,  v83,  v84,  v85,  v86,  v87,  v88,  (uint64_t)v81);
          uint64_t v89 = (os_log_s *)sub_100086554(0x43u);
          if (!os_log_type_enabled(v89, OS_LOG_TYPE_ERROR)) {
            goto LABEL_23;
          }
          goto LABEL_22;
        }

        int v36 = *(unsigned __int8 *)(a1 + 70);
      }

      if (v36 || sub_10018550C(v7, 34))
      {
        *(_OWORD *)(v7 + 104) = *a2;
        if (*(_BYTE *)(a1 + 70) == 1)
        {
          sub_100185420(v7, 34);
          if (*(_DWORD *)(v7 + 84) != 2)
          {
            *(_DWORD *)(v7 + 84) = 1;
            return;
          }
        }

        else
        {
          sub_100185420(v7, 35);
        }

        return;
      }

      uint64_t v109 = sub_100185414();
      sub_1001EE134( (uint64_t)"Device was not in the proper state. State is %s.",  v110,  v111,  v112,  v113,  v114,  v115,  v116,  (uint64_t)v109);
      uint64_t v117 = (os_log_s *)sub_100086554(0x43u);
      if (!os_log_type_enabled(v117, OS_LOG_TYPE_ERROR)) {
        goto LABEL_23;
      }
    }

    else
    {
      sub_1001EE134((uint64_t)"Could not find associated pairing data.", v45, v46, v47, v48, v49, v50, v51, v128);
      uint64_t v52 = (os_log_s *)sub_100086554(0x43u);
      if (!os_log_type_enabled(v52, OS_LOG_TYPE_ERROR)) {
        goto LABEL_23;
      }
    }

void sub_1001CF3E4(__int128 *a1, _OWORD *a2, uint64_t a3)
{
  uint64_t v6 = sub_100184F2C((uint64_t)a1);
  uint64_t v7 = v6;
  if (!v6)
  {
    sub_1001EE134((uint64_t)"Could not find associated pairing data.", v13, v14, v15, v16, v17, v18, v19, v297);
    uint64_t v20 = (os_log_s *)sub_100086554(0x43u);
    if (!os_log_type_enabled(v20, OS_LOG_TYPE_ERROR)) {
      goto LABEL_22;
    }
    goto LABEL_21;
  }

  if ((_DWORD)a3 != 16)
  {
    sub_1001EE134((uint64_t)"Invalid Pairing Random size %d", v21, v22, v23, v24, v25, v26, v27, a3);
    uint64_t v28 = (os_log_s *)sub_100086554(0x43u);
    if (!os_log_type_enabled(v28, OS_LOG_TYPE_ERROR)) {
      goto LABEL_22;
    }
    goto LABEL_21;
  }

  if ((*(_BYTE *)(v6 + 72) & *(_BYTE *)(v6 + 80) & 8) == 0)
  {
    __int128 v303 = 0uLL;
    *(void *)&__int128 v301 = 0LL;
    uint64_t v31 = (uint64_t *)sub_100184F2C((uint64_t)a1);
    uint64_t v7 = (uint64_t)v31;
    if (v31)
    {
      sub_100185340(v31);
      int v32 = *((unsigned __int8 *)a1 + 70);
      if (v32 == 1)
      {
        if (!sub_10018550C(v7, 35))
        {
          uint64_t v99 = sub_100185414();
          sub_1001EE134( (uint64_t)"Initiator device was not in the proper state. State is %s.",  v100,  v101,  v102,  v103,  v104,  v105,  v106,  (uint64_t)v99);
          uint64_t v107 = (os_log_s *)sub_100086554(0x43u);
          if (!os_log_type_enabled(v107, OS_LOG_TYPE_ERROR)) {
            goto LABEL_22;
          }
          goto LABEL_21;
        }

        int v32 = *((unsigned __int8 *)a1 + 70);
      }

      if (v32 || sub_10018550C(v7, 36))
      {
        *(_OWORD *)(v7 + 136) = *a2;
        if (*((_BYTE *)a1 + 70) == 1) {
          char v33 = 36;
        }
        else {
          char v33 = 37;
        }
        sub_100185420(v7, v33);
        if ((void)v303 == *(void *)(v7 + 104) && *((void *)&v303 + 1) == *(void *)(v7 + 112))
        {
          sub_100185420(v7, 40);
          v163 = (void *)(v7 + 120);
          if (*((_BYTE *)a1 + 70))
          {
            v164 = (uint64_t *)(v7 + 120);
            v163 = (void *)(v7 + 136);
          }

          else
          {
            v164 = (uint64_t *)(v7 + 136);
          }

          uint64_t v220 = *(unsigned __int8 *)(v7 + 81);
          if (v220 != 16) {
            bzero((void *)(v7 + 56 + v220), 16 - v220);
          }
          sub_100185420(v7, 41);
          if (!*((_BYTE *)a1 + 70))
          {
          }

          return;
        }

        if (sub_1000A86F0())
        {
          sub_1001EE134((uint64_t)"The confirmation value does not match.", v36, v37, v38, v39, v40, v41, v42, v297);
          uint64_t v43 = (os_log_s *)sub_100086554(0x43u);
          if (os_log_type_enabled(v43, OS_LOG_TYPE_ERROR)) {
            sub_100657858();
          }
        }

LABEL_178:
        sub_100657F74();
        goto LABEL_22;
      }

      __int128 v303 = 0uLL;
      unsigned int v136 = *(_DWORD *)(v7 + 441);
      char v137 = *(_BYTE *)(v7 + 489);
      __int128 v138 = *(_OWORD *)(v7 + 328);
      __int128 v301 = *(_OWORD *)(v7 + 312);
      __int128 v302 = v138;
      __int128 v139 = *(_OWORD *)(v7 + 168);
      __int128 v299 = *(_OWORD *)(v7 + 152);
      __int128 v300 = v139;
      if (((v136 >> v137) & 1) != 0) {
        char v140 = -127;
      }
      else {
        char v140 = 0x80;
      }
      uint64_t v141 = sub_1001116D0(&v301, &v299, (__int128 *)(v7 + 457), v140, &v303);
      if ((_DWORD)v141)
      {
        uint64_t v142 = v141;
        sub_1001EE134( (uint64_t)"Failed to generate confirmation value %!",  v143,  v144,  v145,  v146,  v147,  v148,  v149,  v142);
        uint64_t v150 = (os_log_s *)sub_100086554(0x43u);
        if (!os_log_type_enabled(v150, OS_LOG_TYPE_ERROR)) {
          goto LABEL_22;
        }
        goto LABEL_178;
      }

      if ((void)v303 != *(void *)(v7 + 104) || *((void *)&v303 + 1) != *(void *)(v7 + 112))
      {
        sub_1001EE134((uint64_t)"pairing confirmation does not match %!", v212, v213, v214, v215, v216, v217, v218, 0LL);
        v219 = (os_log_s *)sub_100086554(0x43u);
        if (!os_log_type_enabled(v219, OS_LOG_TYPE_ERROR)) {
          goto LABEL_42;
        }
        goto LABEL_143;
      }

      *(void *)(v7 + 104) = 0LL;
      *(void *)(v7 + 112) = 0LL;
      uint64_t v242 = sub_1001D4A70(*(void *)v7, (__int128 *)(v7 + 473));
      if ((_DWORD)v242)
      {
        uint64_t v243 = v242;
        sub_1001EE134((uint64_t)"smpSendPairingRandom failed %!", v244, v245, v246, v247, v248, v249, v250, v243);
        v251 = (os_log_s *)sub_100086554(0x43u);
        if (!os_log_type_enabled(v251, OS_LOG_TYPE_ERROR)) {
          goto LABEL_22;
        }
        goto LABEL_178;
      }

      unsigned int v274 = ++*(_BYTE *)(v7 + 489);
      if (v274 <= 0x13)
      {
        uint64_t v275 = sub_1001CC98C(v7);
        if ((_DWORD)v275)
        {
          uint64_t v276 = v275;
          sub_1001EE134( (uint64_t)"smpDoOneLeSecuredConnectionPasskeyAuthItteration returned %!",  v277,  v278,  v279,  v280,  v281,  v282,  v283,  v276);
          v284 = (os_log_s *)sub_100086554(0x43u);
          if (!os_log_type_enabled(v284, OS_LOG_TYPE_ERROR)) {
            goto LABEL_22;
          }
          goto LABEL_178;
        }

        uint64_t v285 = v7;
        char v286 = 34;
LABEL_170:
        sub_100185420(v285, v286);
        return;
      }
    }

    uint64_t v285 = v7;
    char v286 = 38;
    goto LABEL_170;
  }

        *(_BYTE *)(v261 + 31) = HIBYTE(v263);
        if ((v214 & 0x100) == 0)
        {
LABEL_152:
          if ((v214 & 0x200) == 0) {
            goto LABEL_153;
          }
          goto LABEL_180;
        }

  uint64_t v76 = sub_1005CE3A0((uint64_t)v6, v5);
  if (!v76) {
    goto LABEL_185;
  }
  uint64_t v77 = sub_1002E6D7C();
  if (!(*(unsigned int (**)(uint64_t, void *, unsigned __int8 *))(*(void *)v77 + 792LL))(v77, v76, a3))
  {
    if (os_log_type_enabled((os_log_t)qword_1008F75A0, OS_LOG_TYPE_DEBUG))
    {
      sub_1003CF00C((uint64_t)v76, buf);
      sub_10069B17C();
    }

LABEL_65:
  if (*((_BYTE *)a1 + 70) == 1)
  {
    uint64_t v89 = sub_1001D4A70((uint64_t)a1, (__int128 *)(v7 + 473));
    if ((_DWORD)v89)
    {
      uint64_t v90 = v89;
      sub_1001EE134((uint64_t)"Failed to send Nb to central with status %!", v91, v92, v93, v94, v95, v96, v97, v90);
      uint64_t v98 = (os_log_s *)sub_100086554(0x43u);
      if (!os_log_type_enabled(v98, OS_LOG_TYPE_ERROR)) {
        goto LABEL_22;
      }
      goto LABEL_103;
    }

    sub_100185420(v7, 38);
    if (*(_BYTE *)(v7 + 16) == 6)
    {
      LODWORD(v303) = 0;
      __int128 v175 = *(_OWORD *)(v7 + 328);
      __int128 v301 = *(_OWORD *)(v7 + 312);
      __int128 v302 = v175;
      __int128 v176 = *(_OWORD *)(v7 + 168);
      __int128 v299 = *(_OWORD *)(v7 + 152);
      __int128 v300 = v176;
      sub_100111CB8(&v301, &v299, (__int128 *)(v7 + 457), (__int128 *)(v7 + 473), &v303);
      if ((_DWORD)v177)
      {
        uint64_t v178 = v177;
        sub_1001EE134((uint64_t)"Failed to generate vb with status %!", v179, v180, v181, v182, v183, v184, v185, v178);
        v186 = (os_log_s *)sub_100086554(0x43u);
        if (!os_log_type_enabled(v186, OS_LOG_TYPE_ERROR)) {
          goto LABEL_22;
        }
        goto LABEL_178;
      }

      if (!off_1008F6EB0)
      {
        uint64_t v29 = a1;
        int v30 = 12;
        goto LABEL_23;
      }

      unsigned int v252 = v303 % 0xF4240;
      LODWORD(v303) = v303 % 0xF4240;
LABEL_173:
      *(_WORD *)(v7 + 33) = v252;
      *(_BYTE *)(v7 + 35) = BYTE2(v252);
      *(_BYTE *)(v7 + 36) = 0;
      *(_DWORD *)(v7 + 52) = 4;
      sub_1001D47A4(*(void *)v7);
      return;
    }

    return;
  }

  __int128 v303 = 0uLL;
  __int128 v151 = *(_OWORD *)(v7 + 168);
  __int128 v301 = *(_OWORD *)(v7 + 152);
  __int128 v302 = v151;
  __int128 v152 = *(_OWORD *)(v7 + 328);
  __int128 v299 = *(_OWORD *)(v7 + 312);
  __int128 v300 = v152;
  uint64_t v153 = sub_1001116D0(&v299, &v301, (__int128 *)(v7 + 473), 0, &v303);
  if ((_DWORD)v153)
  {
    uint64_t v154 = v153;
    sub_1001EE134( (uint64_t)"Failed to generate confirmation value Cb with status %!",  v155,  v156,  v157,  v158,  v159,  v160,  v161,  v154);
    v162 = (os_log_s *)sub_100086554(0x43u);
    if (!os_log_type_enabled(v162, OS_LOG_TYPE_ERROR)) {
      goto LABEL_22;
    }
    goto LABEL_178;
  }

  if ((void)v303 != *(void *)(v7 + 104) || *((void *)&v303 + 1) != *(void *)(v7 + 112))
  {
    sub_1001EE134((uint64_t)"Mismatch in Confirm calculations", v203, v204, v205, v206, v207, v208, v209, v297);
    v210 = (os_log_s *)sub_100086554(0x43u);
    if (!os_log_type_enabled(v210, OS_LOG_TYPE_ERROR)) {
      goto LABEL_42;
    }
    goto LABEL_143;
  }

  sub_100185420(v7, 39);
  if (*(_BYTE *)(v7 + 16) == 6)
  {
    unsigned int v298 = 0;
    __int128 v230 = *(_OWORD *)(v7 + 168);
    __int128 v301 = *(_OWORD *)(v7 + 152);
    __int128 v302 = v230;
    __int128 v231 = *(_OWORD *)(v7 + 328);
    __int128 v299 = *(_OWORD *)(v7 + 312);
    __int128 v300 = v231;
    sub_100111CB8(&v301, &v299, (__int128 *)(v7 + 457), (__int128 *)(v7 + 473), &v298);
    if ((_DWORD)v232)
    {
      uint64_t v233 = v232;
      if (sub_1000A86F0())
      {
        sub_1001EE134((uint64_t)"Failed to generate vb with status %!", v234, v235, v236, v237, v238, v239, v240, v233);
        v241 = (os_log_s *)sub_100086554(0x43u);
        if (os_log_type_enabled(v241, OS_LOG_TYPE_ERROR)) {
          sub_100657F74();
        }
      }

      goto LABEL_22;
    }

    if (!off_1008F6EB0)
    {
      uint64_t v29 = a1;
      int v30 = 5;
      goto LABEL_23;
    }

    unsigned int v252 = v298 % 0xF4240;
    v298 %= 0xF4240u;
    goto LABEL_173;
  }

  uint64_t v253 = sub_1001CC484((__int128 **)v7);
  if ((_DWORD)v253)
  {
    uint64_t v254 = v253;
    sub_1001EE134((uint64_t)"Failed to send DHKey value with status %!", v255, v256, v257, v258, v259, v260, v261, v254);
    v262 = (os_log_s *)sub_100086554(0x43u);
    if (!os_log_type_enabled(v262, OS_LOG_TYPE_ERROR)) {
      goto LABEL_22;
    }
    goto LABEL_178;
  }

  uint64_t v26 = v92;
  LODWORD(__p[0]) = 21;
  *(void *)__int128 buf = __p;
  *((_WORD *)sub_1005BC550((uint64_t **)(a1 + 1224), (unsigned int *)__p, (uint64_t)&unk_1006C2518, (_DWORD **)buf) + 16) = v26;
  uint64_t v27 = v91;
  LODWORD(__p[0]) = 21;
  *(void *)__int128 buf = __p;
  uint64_t v28 = v90;
  LODWORD(__p[0]) = 21;
  *(void *)__int128 buf = __p;
  *((_WORD *)sub_1005BC550((uint64_t **)(a1 + 1272), (unsigned int *)__p, (uint64_t)&unk_1006C2518, (_DWORD **)buf) + 16) = v28;
  uint64_t v29 = v89;
  LODWORD(__p[0]) = 21;
  *(void *)__int128 buf = __p;
  int v30 = v88;
  LODWORD(__p[0]) = 655360;
  *(void *)__int128 buf = __p;
  *((_WORD *)sub_1005BC550((uint64_t **)(a1 + 1224), (unsigned int *)__p, (uint64_t)&unk_1006C2518, (_DWORD **)buf) + 16) = v30;
  uint64_t v31 = v87;
  LODWORD(__p[0]) = 655360;
  *(void *)__int128 buf = __p;
  LOWORD(v31) = v86;
  LODWORD(__p[0]) = 655360;
  *(void *)__int128 buf = __p;
  *((_WORD *)sub_1005BC550((uint64_t **)(a1 + 1272), (unsigned int *)__p, (uint64_t)&unk_1006C2518, (_DWORD **)buf) + 16) = v31;
  int v32 = v85;
  LODWORD(__p[0]) = 655360;
  *(void *)__int128 buf = __p;
  char v33 = (uint64_t **)(a1 + 1320);
  __p[0] = (void *)3;
  *(void *)__int128 buf = __p;
  sub_1005BC610((uint64_t **)(a1 + 1320), (unsigned int *)__p, (uint64_t)&unk_1006C2518, (uint64_t **)buf)[36] = 0;
  LOBYTE(v29) = *(_BYTE *)(a1 + 1344);
  __p[0] = (void *)(&_mh_execute_header + 3);
  *(void *)__int128 buf = __p;
  sub_1005BC610((uint64_t **)(a1 + 1320), (unsigned int *)__p, (uint64_t)&unk_1006C2518, (uint64_t **)buf)[36] = v29;
  __p[0] = (void *)0x200000003LL;
  *(void *)__int128 buf = __p;
  sub_1005BC610((uint64_t **)(a1 + 1320), (unsigned int *)__p, (uint64_t)&unk_1006C2518, (uint64_t **)buf)[36] = 0;
  uint8x8_t v34 = *(char *)(a1 + 1345);
  uint64_t v81 = 24;
  uint64_t v82 = v34;
  uint64_t v79 = 5;
  uint64_t v80 = 1800;
  uint64_t v78 = 3600;
  uint64_t v35 = sub_1002E6E00();
  sub_10002418C(buf, "CONNECTION");
  sub_10002418C(__p, "LeConnectionMagnetRSSIThresholdStageOne");
  uint64_t v36 = (*(uint64_t (**)(uint64_t, uint8_t *, void **, int *))(*(void *)v35 + 88LL))(v35, buf, __p, &v82);
  if (v84 < 0) {
    operator delete(__p[0]);
  }
  if (v94 < 0)
  {
    operator delete(*(void **)buf);
    if (!v36) {
      goto LABEL_73;
    }
  }

  else if (!v36)
  {
    goto LABEL_73;
  }

  uint64_t v37 = (os_log_s *)qword_1008F7620;
  if (os_log_type_enabled((os_log_t)qword_1008F7620, OS_LOG_TYPE_DEFAULT))
  {
    *(_DWORD *)__int128 buf = 67109120;
    *(_DWORD *)&uint8_t buf[4] = v82;
    _os_log_impl( (void *)&_mh_execute_header,  v37,  OS_LOG_TYPE_DEFAULT,  "LeConnectionMagnetRSSIThresholdStageOne =%d (override)",  buf,  8u);
  }

void sub_1001D01E4(uint64_t a1, unsigned __int8 *a2, uint64_t a3)
{
  char v5 = (uint64_t *)sub_100184F2C(a1);
  if (v5)
  {
    uint64_t v6 = (char *)v5;
    sub_100185340(v5);
    if ((_DWORD)a3 == 1)
    {
      unsigned int v7 = *a2;
    }

    else
    {
      if (sub_1000A86F0())
      {
        sub_1001EE134((uint64_t)"Invalid Pairing Failed size %d", v16, v17, v18, v19, v20, v21, v22, a3);
        uint64_t v23 = (os_log_s *)sub_100086554(0x43u);
        if (os_log_type_enabled(v23, OS_LOG_TYPE_ERROR)) {
          sub_100657858();
        }
      }

      unsigned int v7 = 8;
    }

    if (sub_1000A86F0())
    {
      sub_1001EE134((uint64_t)"Peer sent Pairing Failed with reason=%d", v24, v25, v26, v27, v28, v29, v30, v7);
      uint64_t v31 = (os_log_s *)sub_100086554(0x43u);
      if (os_log_type_enabled(v31, OS_LOG_TYPE_ERROR)) {
        sub_100657858();
      }
    }

    uint64_t v32 = sub_1001853E8(v7);
    sub_100184BB0(v6, v32, 1);
  }

  else if (sub_1000A86F0())
  {
    sub_1001EE134((uint64_t)"Could not find associated pairing data.", v8, v9, v10, v11, v12, v13, v14, v33);
    uint64_t v15 = (os_log_s *)sub_100086554(0x43u);
    if (os_log_type_enabled(v15, OS_LOG_TYPE_ERROR)) {
      sub_100657858();
    }
  }

__n128 sub_1001D031C(uint64_t a1, __n128 *a2, uint64_t a3)
{
  if ((_DWORD)a3 != 16)
  {
    sub_1001EE134((uint64_t)"Invalid Encrypt Information size %d", v10, v11, v12, v13, v14, v15, v16, a3);
    uint64_t v17 = (os_log_s *)sub_100086554(0x43u);
    if (!os_log_type_enabled(v17, OS_LOG_TYPE_ERROR)) {
      goto LABEL_14;
    }
LABEL_13:
    sub_100657858();
LABEL_14:
    uint64_t v6 = 0LL;
LABEL_15:
    sub_1001CBE38((__int128 *)a1, 8, (char *)v6);
    return result;
  }

  char v5 = (uint64_t *)sub_100184F2C(a1);
  if (!v5)
  {
    sub_1001EE134((uint64_t)"Could not find associated pairing data.", v18, v19, v20, v21, v22, v23, v24, v60);
    uint64_t v25 = (os_log_s *)sub_100086554(0x43u);
    if (!os_log_type_enabled(v25, OS_LOG_TYPE_ERROR)) {
      goto LABEL_14;
    }
    goto LABEL_13;
  }

  uint64_t v6 = (uint64_t)v5;
  sub_100185340(v5);
  if (!*(_BYTE *)(v6 + 9))
  {
    sub_1001EE134((uint64_t)"The link is not encrypted, dumping LTK", v27, v28, v29, v30, v31, v32, v33, v60);
    uint8x8_t v34 = (os_log_s *)sub_100086554(0x43u);
    if (!os_log_type_enabled(v34, OS_LOG_TYPE_ERROR)) {
      goto LABEL_15;
    }
LABEL_19:
    sub_100657858();
    goto LABEL_15;
  }

  if ((*(unsigned __int8 *)(v6 + 75) | 8) != 8)
  {
    if (sub_1000A86F0())
    {
      sub_1001EE134((uint64_t)"We got LTK after some other keys.", v35, v36, v37, v38, v39, v40, v41, v60);
      uint64_t v42 = (os_log_s *)sub_100086554(0x43u);
      if (os_log_type_enabled(v42, OS_LOG_TYPE_ERROR)) {
        sub_100657858();
      }
    }

    goto LABEL_25;
  }

  if (!*(_BYTE *)(a1 + 70))
  {
    uint64_t v7 = v6;
    char v8 = 66;
    goto LABEL_24;
  }

  if (!sub_10018550C(v6, 67))
  {
    uint64_t v51 = sub_100185414();
    sub_1001EE134( (uint64_t)"Central is sending keys before we are (state is %s).",  v52,  v53,  v54,  v55,  v56,  v57,  v58,  (uint64_t)v51);
    uint64_t v59 = (os_log_s *)sub_100086554(0x43u);
    if (!os_log_type_enabled(v59, OS_LOG_TYPE_ERROR)) {
      goto LABEL_15;
    }
    goto LABEL_19;
  }

  uint64_t v7 = v6;
  char v8 = 64;
LABEL_24:
  sub_100185420(v7, v8);
LABEL_25:
  if ((*(_BYTE *)(v6 + 74) & 1) != 0)
  {
    __n128 result = *a2;
    *(__n128 *)(v6 + 508) = *a2;
  }

  else if (sub_1000A86F0())
  {
    sub_1001EE134((uint64_t)"We were not expecting LTK...", v43, v44, v45, v46, v47, v48, v49, v60);
    uint64_t v50 = (os_log_s *)sub_100086554(0x43u);
    if (os_log_type_enabled(v50, OS_LOG_TYPE_ERROR)) {
      sub_100657858();
    }
  }

  return result;
}

void sub_1001D0588(uint64_t a1, uint64_t a2, uint64_t a3)
{
  if ((_DWORD)a3 != 10)
  {
    sub_1001EE134((uint64_t)"Invalid Central Identification size %d", v17, v18, v19, v20, v21, v22, v23, a3);
    uint64_t v24 = (os_log_s *)sub_100086554(0x43u);
    if (!os_log_type_enabled(v24, OS_LOG_TYPE_ERROR)) {
      goto LABEL_19;
    }
LABEL_18:
    sub_100657858();
LABEL_19:
    uint64_t v6 = 0LL;
    goto LABEL_20;
  }

  char v5 = (uint64_t *)sub_100184F2C(a1);
  if (!v5)
  {
    sub_1001EE134((uint64_t)"Could not find associated pairing data.", v25, v26, v27, v28, v29, v30, v31, v66);
    uint64_t v32 = (os_log_s *)sub_100086554(0x43u);
    if (!os_log_type_enabled(v32, OS_LOG_TYPE_ERROR)) {
      goto LABEL_19;
    }
    goto LABEL_18;
  }

  uint64_t v6 = (uint64_t)v5;
  sub_100185340(v5);
  if (!*(_BYTE *)(v6 + 9))
  {
    sub_1001EE134((uint64_t)"The link is not encrypted, dumping EDIV/Rand", v33, v34, v35, v36, v37, v38, v39, v66);
    uint64_t v40 = (os_log_s *)sub_100086554(0x43u);
    if (!os_log_type_enabled(v40, OS_LOG_TYPE_ERROR)) {
      goto LABEL_20;
    }
LABEL_12:
    sub_100657858();
LABEL_20:
    sub_1001CBE38((__int128 *)a1, 8, (char *)v6);
    return;
  }

  if ((*(unsigned __int8 *)(v6 + 75) | 8) == 8)
  {
    int v7 = *(unsigned __int8 *)(a1 + 70);
    if (v7 == 1)
    {
      if (!sub_10018550C(v6, 64)) {
        goto LABEL_10;
      }
      int v7 = *(unsigned __int8 *)(a1 + 70);
    }

    if (!v7 && !sub_10018550C(v6, 66))
    {
LABEL_10:
      sub_1001EE134((uint64_t)"We got a EDIV/RAND without a LTK.", v8, v9, v10, v11, v12, v13, v14, v66);
      uint64_t v15 = (os_log_s *)sub_100086554(0x43u);
      if (!os_log_type_enabled(v15, OS_LOG_TYPE_ERROR)) {
        goto LABEL_20;
      }
      goto LABEL_12;
    }
  }

  else if (sub_1000A86F0())
  {
    sub_1001EE134((uint64_t)"We got EDIV/RAND after some other keys.", v41, v42, v43, v44, v45, v46, v47, v66);
    uint64_t v48 = (os_log_s *)sub_100086554(0x43u);
    if (os_log_type_enabled(v48, OS_LOG_TYPE_ERROR)) {
      sub_100657858();
    }
  }

  if ((*(_BYTE *)(v6 + 74) & 1) == 0)
  {
    sub_1001EE134((uint64_t)"We were not expecting LTK...", v49, v50, v51, v52, v53, v54, v55, v66);
    uint64_t v56 = (os_log_s *)sub_100086554(0x43u);
    if (!os_log_type_enabled(v56, OS_LOG_TYPE_ERROR)) {
      goto LABEL_38;
    }
    goto LABEL_30;
  }

  *(_BYTE *)(v6 + 75) |= 1u;
  *(_WORD *)(v6 + 542) = *(_WORD *)a2;
  *(void *)(v6 + 546) = *(void *)(a2 + 2);
  BOOL v67 = *(_BYTE *)(v6 + 16) != 1;
  if (!*(_BYTE *)(v6 + 612))
  {
    if (unk_1008F6E98 && (*(_BYTE *)(v6 + 80) & 1) != 0)
    {
      uint64_t v65 = a1 + 48;
      unk_1008F6E98(v65, 0LL, v6 + 508, 16LL, 0LL);
      unk_1008F6E98(v65, 1LL, v6 + 81, 1LL, 0LL);
      unk_1008F6E98(v65, 2LL, &v67, 1LL, 0LL);
      unk_1008F6E98(v65, 3LL, v6 + 542, 2LL, 0LL);
      unk_1008F6E98(v65, 4LL, v6 + 546, 8LL, 0LL);
    }

    goto LABEL_38;
  }

  if (sub_1000A86F0())
  {
    sub_1001EE134((uint64_t)"Compromised device, dropping keys", v57, v58, v59, v60, v61, v62, v63, v66);
    uint64_t v64 = (os_log_s *)sub_100086554(0x43u);
    if (os_log_type_enabled(v64, OS_LOG_TYPE_ERROR)) {
LABEL_30:
    }
      sub_100657858();
  }

__n128 sub_1001D08F8(uint64_t a1, __n128 *a2, uint64_t a3)
{
  if ((_DWORD)a3 != 16)
  {
    sub_1001EE134((uint64_t)"Invalid Identity Information size %d", v9, v10, v11, v12, v13, v14, v15, a3);
    uint64_t v16 = (os_log_s *)sub_100086554(0x43u);
    if (!os_log_type_enabled(v16, OS_LOG_TYPE_ERROR)) {
      goto LABEL_14;
    }
LABEL_13:
    sub_100657858();
LABEL_14:
    uint64_t v6 = 0LL;
LABEL_15:
    sub_1001CBE38((__int128 *)a1, 8, (char *)v6);
    return result;
  }

  char v5 = (uint64_t *)sub_100184F2C(a1);
  if (!v5)
  {
    sub_1001EE134((uint64_t)"Could not find associated pairing data.", v17, v18, v19, v20, v21, v22, v23, v50);
    uint64_t v24 = (os_log_s *)sub_100086554(0x43u);
    if (!os_log_type_enabled(v24, OS_LOG_TYPE_ERROR)) {
      goto LABEL_14;
    }
    goto LABEL_13;
  }

  uint64_t v6 = (uint64_t)v5;
  sub_100185340(v5);
  if (!*(_BYTE *)(v6 + 9))
  {
    sub_1001EE134((uint64_t)"The link is not encrypted, dumping IRK", v26, v27, v28, v29, v30, v31, v32, v50);
    uint64_t v33 = (os_log_s *)sub_100086554(0x43u);
    if (!os_log_type_enabled(v33, OS_LOG_TYPE_ERROR)) {
      goto LABEL_15;
    }
LABEL_19:
    sub_100657858();
    goto LABEL_15;
  }

  if (*(_BYTE *)(v6 + 75)) {
    goto LABEL_22;
  }
  if (!*(_BYTE *)(a1 + 70))
  {
    char v7 = 66;
    goto LABEL_21;
  }

  if (!sub_10018550C(v6, 67))
  {
    sub_1001EE134((uint64_t)"Central is sending keys before we are ...", v42, v43, v44, v45, v46, v47, v48, v50);
    uint64_t v49 = (os_log_s *)sub_100086554(0x43u);
    if (!os_log_type_enabled(v49, OS_LOG_TYPE_ERROR)) {
      goto LABEL_15;
    }
    goto LABEL_19;
  }

  char v7 = 64;
LABEL_21:
  sub_100185420(v6, v7);
LABEL_22:
  if ((*(_BYTE *)(v6 + 74) & 2) != 0)
  {
    __n128 result = *a2;
    *(__n128 *)(v6 + 562) = *a2;
  }

  else if (sub_1000A86F0())
  {
    sub_1001EE134((uint64_t)"We were not expecting IRK...", v34, v35, v36, v37, v38, v39, v40, v50);
    uint64_t v41 = (os_log_s *)sub_100086554(0x43u);
    if (os_log_type_enabled(v41, OS_LOG_TYPE_ERROR)) {
      sub_100657858();
    }
  }

  return result;
}

void sub_1001D0AF4(uint64_t a1, uint64_t a2, uint64_t a3)
{
  if ((_DWORD)a3 != 7)
  {
    sub_1001EE134((uint64_t)"Invalid Identity Address Information size %d", v17, v18, v19, v20, v21, v22, v23, a3);
    uint64_t v24 = (os_log_s *)sub_100086554(0x43u);
    if (!os_log_type_enabled(v24, OS_LOG_TYPE_ERROR)) {
      goto LABEL_20;
    }
LABEL_19:
    sub_100657858();
LABEL_20:
    uint64_t v6 = 0LL;
    goto LABEL_21;
  }

  char v5 = (uint64_t *)sub_100184F2C(a1);
  if (!v5)
  {
    sub_1001EE134((uint64_t)"Could not find associated pairing data.", v25, v26, v27, v28, v29, v30, v31, v86);
    uint64_t v32 = (os_log_s *)sub_100086554(0x43u);
    if (!os_log_type_enabled(v32, OS_LOG_TYPE_ERROR)) {
      goto LABEL_20;
    }
    goto LABEL_19;
  }

  uint64_t v6 = (uint64_t)v5;
  sub_100185340(v5);
  if (!*(_BYTE *)(v6 + 9))
  {
    sub_1001EE134((uint64_t)"The link is not encrypted, dumping Remote address", v34, v35, v36, v37, v38, v39, v40, v86);
    uint64_t v41 = (os_log_s *)sub_100086554(0x43u);
    if (!os_log_type_enabled(v41, OS_LOG_TYPE_ERROR)) {
      goto LABEL_21;
    }
LABEL_25:
    sub_100657858();
    goto LABEL_21;
  }

  if (*(_BYTE *)(v6 + 75)) {
    goto LABEL_10;
  }
  int v7 = *(unsigned __int8 *)(a1 + 70);
  if (v7 == 1)
  {
    if (!sub_10018550C(v6, 64)) {
      goto LABEL_33;
    }
    int v7 = *(unsigned __int8 *)(a1 + 70);
  }

  if (!v7 && !sub_10018550C(v6, 66))
  {
LABEL_33:
    sub_1001EE134((uint64_t)"We got an address without IRK.", v50, v51, v52, v53, v54, v55, v56, v86);
    uint64_t v57 = (os_log_s *)sub_100086554(0x43u);
    if (!os_log_type_enabled(v57, OS_LOG_TYPE_ERROR)) {
      goto LABEL_21;
    }
    goto LABEL_25;
  }

void sub_1001D0F34(uint64_t a1, uint64_t a2, uint64_t a3)
{
  if ((_DWORD)a3 != 16)
  {
    sub_1001EE134((uint64_t)"Invalid Signing Information size %d", v8, v9, v10, v11, v12, v13, v14, a3);
    uint64_t v15 = (os_log_s *)sub_100086554(0x43u);
    if (!os_log_type_enabled(v15, OS_LOG_TYPE_ERROR)) {
      goto LABEL_14;
    }
LABEL_13:
    sub_100657858();
LABEL_14:
    char v5 = 0LL;
    goto LABEL_15;
  }

  char v4 = (uint64_t *)sub_100184F2C(a1);
  if (!v4)
  {
    sub_1001EE134((uint64_t)"Could not find associated pairing data.", v16, v17, v18, v19, v20, v21, v22, v48);
    uint64_t v23 = (os_log_s *)sub_100086554(0x43u);
    if (!os_log_type_enabled(v23, OS_LOG_TYPE_ERROR)) {
      goto LABEL_14;
    }
    goto LABEL_13;
  }

  char v5 = (char *)v4;
  sub_100185340(v4);
  if (!v5[9])
  {
    sub_1001EE134((uint64_t)"The link is not encrypted.", v24, v25, v26, v27, v28, v29, v30, v48);
    uint64_t v31 = (os_log_s *)sub_100086554(0x43u);
    if (!os_log_type_enabled(v31, OS_LOG_TYPE_ERROR)) {
      goto LABEL_15;
    }
    goto LABEL_18;
  }

  if (!v5[75])
  {
    if (!*(_BYTE *)(a1 + 70))
    {
      char v6 = 66;
      goto LABEL_20;
    }

    if (sub_10018550C((uint64_t)v5, 67))
    {
      char v6 = 64;
LABEL_20:
      sub_100185420((uint64_t)v5, v6);
      goto LABEL_21;
    }

    if (sub_1000A86F0())
    {
      sub_1001EE134((uint64_t)"Central is sending keys before we are ...", v40, v41, v42, v43, v44, v45, v46, v48);
      uint64_t v47 = (os_log_s *)sub_100086554(0x43u);
      if (os_log_type_enabled(v47, OS_LOG_TYPE_ERROR)) {
LABEL_18:
      }
        sub_100657858();
    }

void sub_1001D1134(uint64_t a1, char *a2, uint64_t a3)
{
  if (xmmword_1008EDB16 == 0 || xmmword_1008EDB36 == 0)
  {
    sub_1001EE134((uint64_t)"Root keys are not set, can't pair.", v14, v15, v16, v17, v18, v19, v20, v59);
    uint64_t v21 = (os_log_s *)sub_100086554(0x43u);
    if (!os_log_type_enabled(v21, OS_LOG_TYPE_ERROR)) {
      goto LABEL_10;
    }
    goto LABEL_9;
  }

  if (!sub_100184F2C(a1))
  {
    if ((_DWORD)a3 == 1)
    {
      if (*(_BYTE *)(a1 + 166) == 2)
      {
        if (sub_1000A86F0())
        {
          sub_1001EE134( (uint64_t)"There is already an encryption in progress on this link, ignoring this request",  v22,  v23,  v24,  v25,  v26,  v27,  v28,  v59);
          uint64_t v29 = (os_log_s *)sub_100086554(0x43u);
          if (os_log_type_enabled(v29, OS_LOG_TYPE_ERROR)) {
            goto LABEL_6;
          }
        }
      }

      else
      {
        char v38 = *a2;
        uint64_t v39 = sub_100185244(a1);
        uint64_t v40 = v39;
        if (v39)
        {
          v39[80] = v38;
          sub_100185420((uint64_t)v39, 16);
        }

        if (*(_DWORD *)(a1 + 132) == 7)
        {
          *((void *)&buf + 1) = v40;
          *(void *)&__int128 buf = 8LL;
          uint64_t v41 = sub_1001EE6E8((uint64_t)sub_1001D3024, (const void **)&buf, 0, 0LL);
          if ((_DWORD)v41)
          {
            uint64_t v42 = v41;
            if (sub_1000A86F0())
            {
              sub_1001EE134( (uint64_t)"Could not dispatch SecurityRequest CB with status %!.",  v43,  v44,  v45,  v46,  v47,  v48,  v49,  v42);
              uint64_t v50 = (os_log_s *)sub_100086554(0x43u);
              if (os_log_type_enabled(v50, OS_LOG_TYPE_ERROR)) {
                sub_100657F74();
              }
            }
          }
        }

        else if (sub_1000A86F0())
        {
          sub_1001EE134( (uint64_t)"Got Security request before link is ready for handle %p, lets handle this when the link is actually ready. Link state is %d",  v51,  v52,  v53,  v54,  v55,  v56,  v57,  a1);
          BOOL v58 = (os_log_s *)sub_100086554(0x43u);
          if (os_log_type_enabled(v58, OS_LOG_TYPE_DEFAULT))
          {
            LODWORD(buf) = 136446210;
            *(void *)((char *)&buf + 4) = sub_1001EDDCC();
            _os_log_impl((void *)&_mh_execute_header, v58, OS_LOG_TYPE_DEFAULT, " %{public}s", (uint8_t *)&buf, 0xCu);
          }
        }
      }

      return;
    }

    if (!sub_1000A86F0()
      || (sub_1001EE134((uint64_t)"Invalid Security Request size %d", v30, v31, v32, v33, v34, v35, v36, a3),
          uint64_t v37 = (os_log_s *)sub_100086554(0x43u),
          !os_log_type_enabled(v37, OS_LOG_TYPE_ERROR)))
    {
LABEL_10:
      LOWORD(buf) = 2053;
      sub_100184F74((__int128 *)a1, (char *)&buf, 2uLL, 0);
      return;
    }

void sub_1001D1414(uint64_t a1, __int128 *a2, uint64_t a3)
{
  uint64_t v6 = sub_100184F2C(a1);
  uint64_t v7 = v6;
  if (!v6)
  {
    sub_1001EE134((uint64_t)"Could not find associated pairing data.", v22, v23, v24, v25, v26, v27, v28, v127);
    uint64_t v29 = (os_log_s *)sub_100086554(0x43u);
    if (!os_log_type_enabled(v29, OS_LOG_TYPE_ERROR)) {
      goto LABEL_63;
    }
    goto LABEL_39;
  }

  if ((_DWORD)a3 != 64)
  {
    sub_1001EE134((uint64_t)"Invalid pairing public key size %d", v30, v31, v32, v33, v34, v35, v36, a3);
    uint64_t v37 = (os_log_s *)sub_100086554(0x43u);
    if (!os_log_type_enabled(v37, OS_LOG_TYPE_ERROR)) {
      goto LABEL_63;
    }
    goto LABEL_39;
  }

  if ((*(_BYTE *)(v6 + 72) & *(_BYTE *)(v6 + 80) & 8) == 0)
  {
    sub_1001EE134( (uint64_t)"Both devices should be using secured connection to get this PDU.",  v38,  v39,  v40,  v41,  v42,  v43,  v44,  v127);
    uint64_t v45 = (os_log_s *)sub_100086554(0x43u);
    if (!os_log_type_enabled(v45, OS_LOG_TYPE_ERROR)) {
      goto LABEL_63;
    }
    goto LABEL_39;
  }

  int v8 = *(unsigned __int8 *)(a1 + 70);
  if (!*(_BYTE *)(a1 + 70))
  {
    if (sub_10018550C(v6, 33))
    {
      int v8 = *(unsigned __int8 *)(a1 + 70);
      goto LABEL_7;
    }

    uint64_t v65 = sub_100185414();
    sub_1001EE134( (uint64_t)"Central connection should be in SMP_STATE_PAIRING_SPUBLICK to send this command, current state is %s.",  v66,  v67,  v68,  v69,  v70,  v71,  v72,  (uint64_t)v65);
    uint64_t v73 = (os_log_s *)sub_100086554(0x43u);
    if (!os_log_type_enabled(v73, OS_LOG_TYPE_ERROR)) {
      goto LABEL_63;
    }
LABEL_39:
    sub_100657858();
LABEL_63:
    sub_1001CBE38((__int128 *)a1, 8, (char *)v7);
    return;
  }

uint64_t sub_1001D1A20(uint64_t a1, _OWORD *a2, uint64_t a3)
{
  uint64_t result = sub_100184F2C(a1);
  uint64_t v7 = result;
  if (!result)
  {
    sub_1001EE134((uint64_t)"Could not find associated pairing data.", v18, v19, v20, v21, v22, v23, v24, v52);
    uint64_t v25 = (os_log_s *)sub_100086554(0x43u);
    if (!os_log_type_enabled(v25, OS_LOG_TYPE_ERROR)) {
      return sub_1001CBE38((__int128 *)a1, 8, (char *)v7);
    }
    goto LABEL_20;
  }

  if ((_DWORD)a3 != 16)
  {
    sub_1001EE134((uint64_t)"Invalid pairing DHKey check size %d", v26, v27, v28, v29, v30, v31, v32, a3);
    uint64_t v33 = (os_log_s *)sub_100086554(0x43u);
    if (!os_log_type_enabled(v33, OS_LOG_TYPE_ERROR)) {
      return sub_1001CBE38((__int128 *)a1, 8, (char *)v7);
    }
    goto LABEL_20;
  }

  int v8 = *(unsigned __int8 *)(a1 + 70);
  if (!*(_BYTE *)(a1 + 70))
  {
    uint64_t result = sub_10018550C(result, 39);
    if ((result & 1) != 0)
    {
      int v8 = *(unsigned __int8 *)(a1 + 70);
      goto LABEL_6;
    }

    uint64_t v43 = sub_100185414();
    sub_1001EE134( (uint64_t)"Central connection should be in SMP_STATE_PAIRING_SDHKEY to send this command, current state is %s.",  v44,  v45,  v46,  v47,  v48,  v49,  v50,  (uint64_t)v43);
    uint64_t v51 = (os_log_s *)sub_100086554(0x43u);
    if (!os_log_type_enabled(v51, OS_LOG_TYPE_ERROR)) {
      return sub_1001CBE38((__int128 *)a1, 8, (char *)v7);
    }
LABEL_20:
    sub_100657858();
    return sub_1001CBE38((__int128 *)a1, 8, (char *)v7);
  }

uint64_t sub_1001D1C54(uint64_t a1, int a2, char a3)
{
  if (!sub_10012D5EC(a1)) {
    sub_1001EE2A0();
  }
  uint64_t v6 = sub_100184F2C(a1);
  uint64_t result = sub_100184F2C(a1);
  if (!a2)
  {
    if (result) {
      *(_BYTE *)(v6 + 9) = a3;
    }
  }

  return result;
}

void sub_1001D1CAC(uint64_t a1, int a2, int a3)
{
  char v6 = byte_1008D8ED1;
  else {
    char v7 = byte_1008D8ED2;
  }
  char v8 = v6 & 0xF7;
  char v9 = v7 & 0xF7;
  if (byte_1008EDB00) {
    char v10 = v6 & 0xF7;
  }
  else {
    char v10 = v6;
  }
  if (byte_1008EDB00) {
    char v11 = v7 & 0xF7;
  }
  else {
    char v11 = v7;
  }
  if (!sub_10012D5EC(a1)) {
    sub_1001EE2A0();
  }
  uint64_t v12 = (char *)sub_100184F2C(a1);
  if (v12)
  {
    uint64_t v13 = v12;
    if (a2)
    {
      if (sub_10018550C((uint64_t)v12, 16) && !*(_BYTE *)(a1 + 70))
      {
        int v23 = v13[80] & 4;
        int v24 = byte_1008EDB04;
        int v25 = v23 | v24 | sub_1001BD960();
        if ((v13[80] & 8) != 0)
        {
          if ((v10 & 8) != 0 && (v13[80] & 0x20) != 0 && (byte_1008EDB02 & 1) == 0)
          {
            if (sub_1000A86F0())
            {
              sub_1001EE134((uint64_t)"Sending CT2=1", v27, v28, v29, v30, v31, v32, v33, v47);
              uint64_t v34 = (os_log_s *)sub_100086554(0x43u);
              if (os_log_type_enabled(v34, OS_LOG_TYPE_DEFAULT))
              {
                *(_DWORD *)__int128 buf = 136446210;
                uint64_t v49 = sub_1001EDDCC();
                _os_log_impl((void *)&_mh_execute_header, v34, OS_LOG_TYPE_DEFAULT, " %{public}s", buf, 0xCu);
              }
            }
          }

          unsigned __int8 v26 = v25 | 0x28;
        }

        else
        {
          unsigned __int8 v26 = v25 & 0xDF;
          char v10 = v8;
          char v11 = v9;
        }

        if (*(_BYTE *)(a1 + 55)) {
          uint64_t v35 = (_DWORD *)(a1 + 56);
        }
        else {
          uint64_t v35 = 0LL;
        }
        char v36 = sub_1001C822C((_DWORD *)(a1 + 48), v35);
        if (sub_1000A86F0())
        {
          sub_1001EE134((uint64_t)"authReq=%x expectedKeys=%x requestedKeys=%x", v37, v38, v39, v40, v41, v42, v43, v26);
          uint64_t v44 = (os_log_s *)sub_100086554(0x43u);
          if (os_log_type_enabled(v44, OS_LOG_TYPE_DEFAULT))
          {
            uint64_t v45 = sub_1001EDDCC();
            *(_DWORD *)__int128 buf = 136446210;
            uint64_t v49 = v45;
            _os_log_impl((void *)&_mh_execute_header, v44, OS_LOG_TYPE_DEFAULT, " %{public}s", buf, 0xCu);
          }
        }

        sub_1001CE204(a1, byte_1008D8ED3, v36, v26, v10, v11);
      }

      else
      {
        if (sub_1000A86F0())
        {
          sub_1001EE134((uint64_t)"Could not encrypt the link.", v14, v15, v16, v17, v18, v19, v20, v47);
          uint64_t v21 = (os_log_s *)sub_100086554(0x43u);
          if (os_log_type_enabled(v21, OS_LOG_TYPE_ERROR)) {
            sub_100657858();
          }
        }

        sub_100184BB0(v13, 4802LL, 1);
      }
    }

    else
    {
      *(_BYTE *)(*(void *)v12 + 167LL) = v12[81];
      if (sub_10018550C((uint64_t)v12, 16) && !*(_BYTE *)(a1 + 70))
      {
        sub_100184BB0(v13, 0LL, 0);
        return;
      }

      if (a3)
      {
        sub_100185420((uint64_t)v13, 42);
        if (*(_BYTE *)(a1 + 70))
        {
          if (*(_BYTE *)(a1 + 70) != 1) {
            return;
          }
          sub_1001D20C8((uint64_t)v13);
          sub_1001D223C((uint64_t)v13);
          char v22 = (v13[72] & v13[80] & 8) != 0 ? -10 : -9;
          if ((v22 & v13[74] & 0xF7) != (v22 & v13[75] & 0xF7)
            && (v22 & v13[74]) != 0)
          {
            return;
          }
        }

        else
        {
          else {
            char v46 = -9;
          }
          if ((v46 & v13[74] & 0xF7) != (v46 & v13[75] & 0xF7)
            && (v46 & v13[74]) != 0)
          {
            return;
          }

          sub_1001D20C8((uint64_t)v13);
          sub_1001D223C((uint64_t)v13);
        }

        sub_100184BB0(v13, 0LL, 1);
      }
    }
  }

void sub_1001D20C8(uint64_t a1)
{
  if ((*(_BYTE *)(a1 + 72) & *(_BYTE *)(a1 + 80) & 8) != 0)
  {
    sub_100185420(a1, 128);
    return;
  }

  __int16 v24 = 0;
  arc4random_buf((void *)(a1 + 540), 2uLL);
  arc4random_buf((void *)(a1 + 554), 8uLL);
  uint64_t v2 = sub_100110EC0(&xmmword_1008EDB06, (uint64_t *)(a1 + 554), &v24);
  if ((_DWORD)v2)
  {
    uint64_t v3 = v2;
    if (sub_1000A86F0())
    {
      sub_1001EE134((uint64_t)"Could not generate DIV %!", v4, v5, v6, v7, v8, v9, v10, v3);
      char v11 = (os_log_s *)sub_100086554(0x43u);
      if (os_log_type_enabled(v11, OS_LOG_TYPE_ERROR)) {
LABEL_6:
      }
        sub_100657F74();
    }
  }

  else
  {
    __int16 v12 = *(_WORD *)(a1 + 540);
    *(_WORD *)(a1 + 544) = v12 ^ v24;
    uint64_t v13 = sub_1001115A4(&xmmword_1008EDB16, v12, 0, (void *)(a1 + 524));
    if ((_DWORD)v13)
    {
      uint64_t v14 = v13;
      if (sub_1000A86F0())
      {
        sub_1001EE134((uint64_t)"Could not generate LTK %!", v15, v16, v17, v18, v19, v20, v21, v14);
        char v22 = (os_log_s *)sub_100086554(0x43u);
        if (os_log_type_enabled(v22, OS_LOG_TYPE_ERROR)) {
          goto LABEL_6;
        }
      }
    }

    else
    {
      uint64_t v23 = *(unsigned __int8 *)(a1 + 81);
      if (v23 != 16) {
        bzero((void *)(a1 + 524 + v23), 16 - v23);
      }
      sub_100185420(a1, 128);
    }
  }

void sub_1001D223C(uint64_t a1)
{
  if (!sub_10018550C(a1, 128))
  {
    if (sub_1000A86F0())
    {
      sub_1001EE134((uint64_t)"SMP State is not GENERATED.", v2, v3, v4, v5, v6, v7, v8, v66);
      uint64_t v9 = (os_log_s *)sub_100086554(0x43u);
      if (os_log_type_enabled(v9, OS_LOG_TYPE_ERROR)) {
        sub_100657858();
      }
    }
  }

  if (*(_BYTE *)(*(void *)a1 + 70LL)) {
    char v10 = 66;
  }
  else {
    char v10 = 64;
  }
  sub_100185420(a1, v10);
  if ((*(_BYTE *)(a1 + 72) & *(_BYTE *)(a1 + 80) & 8) != 0)
  {
    if ((*(_BYTE *)(a1 + 80) & 1) != 0 && unk_1008F6E98)
    {
      if (*(_BYTE *)(a1 + 16) == 1) {
        char v11 = 2;
      }
      else {
        char v11 = 3;
      }
      LOBYTE(v68[0]) = v11;
      unk_1008F6E98(*(void *)a1 + 48LL, 5LL, a1 + 524, 16LL, 0LL);
      unk_1008F6E98(*(void *)a1 + 48LL, 7LL, v68, 1LL, 0LL);
      unk_1008F6E98(*(void *)a1 + 48LL, 6LL, a1 + 81, 1LL, 0LL);
      if (*(_BYTE *)(a1 + 594))
      {
        if (*(_BYTE *)(a1 + 593)) {
          unsigned __int8 v12 = 2;
        }
        else {
          unsigned __int8 v12 = 1;
        }
      }

      else
      {
        unsigned __int8 v12 = 0;
      }

      unsigned __int8 v67 = v12;
      if (sub_1000A86F0())
      {
        sub_1001EE134((uint64_t)"deriveLKLTK=%d useH7=%d", v14, v15, v16, v17, v18, v19, v20, v12);
        uint64_t v21 = (os_log_s *)sub_100086554(0x43u);
        if (os_log_type_enabled(v21, OS_LOG_TYPE_DEFAULT))
        {
          char v22 = sub_1001EDDCC();
          *(_DWORD *)__int128 buf = 136446210;
          *(void *)&uint8_t buf[4] = v22;
          _os_log_impl((void *)&_mh_execute_header, v21, OS_LOG_TYPE_DEFAULT, " %{public}s", buf, 0xCu);
        }
      }

      if (v12) {
        unk_1008F6E98(*(void *)a1 + 48LL, 16LL, &v67, 1LL, 0LL);
      }
      goto LABEL_30;
    }
  }

  else if ((*(_BYTE *)(a1 + 76) & 1) != 0 && (*(_BYTE *)(a1 + 77) & 1) == 0)
  {
    buf[0] = 6;
    *(_OWORD *)&buf[1] = *(_OWORD *)(a1 + 524);
    if (*(_BYTE *)(a1 + 9))
    {
      int v13 = sub_100184F74(*(__int128 **)a1, buf, 0x11uLL, 1);
      if (!v13)
      {
        buf[0] = 7;
        *(_WORD *)&buf[1] = *(_WORD *)(a1 + 544);
        *(void *)&buf[3] = *(void *)(a1 + 554);
        if (*(_BYTE *)(a1 + 9))
        {
          int v13 = sub_100184F74(*(__int128 **)a1, buf, 0xBuLL, 1);
        }

        else
        {
          if (sub_1000A86F0())
          {
            sub_1001EE134( (uint64_t)"This link is not encrypted, cannot send EDIV/RAND.",  v50,  v51,  v52,  v53,  v54,  v55,  v56,  v66);
            uint64_t v57 = (os_log_s *)sub_100086554(0x43u);
            if (os_log_type_enabled(v57, OS_LOG_TYPE_ERROR)) {
              sub_100657858();
            }
          }

          int v13 = 4802;
        }
      }

      if (!*(_BYTE *)(a1 + 612))
      {
        if (!v13 && (*(_BYTE *)(a1 + 80) & 1) != 0 && unk_1008F6E98)
        {
          buf[0] = *(_BYTE *)(a1 + 16) != 1;
          unk_1008F6E98(*(void *)a1 + 48LL, 6LL, a1 + 81, 1LL, 0LL);
          unk_1008F6E98(*(void *)a1 + 48LL, 7LL, buf, 1LL, 0LL);
          unk_1008F6E98(*(void *)a1 + 48LL, 8LL, a1 + 544, 2LL, 0LL);
          unk_1008F6E98(*(void *)a1 + 48LL, 9LL, a1 + 554, 8LL, 0LL);
        }

        goto LABEL_30;
      }
    }

    else
    {
      if (sub_1000A86F0())
      {
        sub_1001EE134((uint64_t)"This link is not encrypted, cannot send LTK.", v42, v43, v44, v45, v46, v47, v48, v66);
        uint64_t v49 = (os_log_s *)sub_100086554(0x43u);
        if (os_log_type_enabled(v49, OS_LOG_TYPE_ERROR)) {
          sub_100657858();
        }
      }

      if (!*(_BYTE *)(a1 + 612)) {
        goto LABEL_30;
      }
    }

    if (sub_1000A86F0())
    {
      sub_1001EE134((uint64_t)"Compromised device, dropping keys", v58, v59, v60, v61, v62, v63, v64, v66);
      uint64_t v65 = (os_log_s *)sub_100086554(0x43u);
      if (os_log_type_enabled(v65, OS_LOG_TYPE_ERROR)) {
        sub_100657858();
      }
    }

uint64_t sub_1001D288C(uint64_t a1, _OWORD *a2, _BYTE *a3)
{
  if (!sub_10012D5EC(a1)) {
    sub_1001EE2A0();
  }
  uint64_t v6 = sub_100184F2C(a1);
  if (v6)
  {
    uint64_t v7 = v6;
    if (sub_10018550C(v6, 41))
    {
      int v8 = *(unsigned __int8 *)(v7 + 16);
      if ((*(_BYTE *)(v7 + 72) & *(_BYTE *)(v7 + 80) & 8) != 0)
      {
        if (v8 == 1) {
          char v9 = 2;
        }
        else {
          char v9 = 3;
        }
        *a3 = v9;
        if (!a2) {
          return 1LL;
        }
        __int128 v10 = *(_OWORD *)(v7 + 524);
      }

      else
      {
        *a3 = v8 != 1;
        if (!a2) {
          return 1LL;
        }
        __int128 v10 = *(_OWORD *)(v7 + 56);
      }

      *a2 = v10;
      return 1LL;
    }

    uint64_t result = sub_1000A86F0();
    if ((_DWORD)result)
    {
      sub_1001EE134((uint64_t)"STK not generated for handle 0x%x", v20, v21, v22, v23, v24, v25, v26, a1);
      uint64_t v27 = (os_log_s *)sub_100086554(0x43u);
      uint64_t result = os_log_type_enabled(v27, OS_LOG_TYPE_ERROR);
      if ((_DWORD)result)
      {
LABEL_16:
        sub_100657858();
        return 0LL;
      }
    }
  }

  else
  {
    uint64_t result = sub_1000A86F0();
    if ((_DWORD)result)
    {
      sub_1001EE134((uint64_t)"There is no pairing data for this connection.", v12, v13, v14, v15, v16, v17, v18, v28);
      uint64_t v19 = (os_log_s *)sub_100086554(0x43u);
      uint64_t result = os_log_type_enabled(v19, OS_LOG_TYPE_ERROR);
      if ((_DWORD)result) {
        goto LABEL_16;
      }
    }
  }

  return result;
}

uint64_t sub_1001D29BC(uint64_t *a1, __int16 a2, void *a3)
{
  __int16 v24 = 0;
  uint64_t v5 = sub_100110EC0(&xmmword_1008EDB06, a1, &v24);
  if ((_DWORD)v5)
  {
    uint64_t v6 = v5;
    if (sub_1000A86F0())
    {
      sub_1001EE134((uint64_t)"Could not generate DIV %!", v7, v8, v9, v10, v11, v12, v13, v6);
      uint64_t v14 = (os_log_s *)sub_100086554(0x43u);
      if (os_log_type_enabled(v14, OS_LOG_TYPE_ERROR)) {
LABEL_8:
      }
        sub_100657F74();
    }
  }

  else
  {
    uint64_t v6 = sub_1001115A4(&xmmword_1008EDB16, v24 ^ a2, 0, a3);
    if ((_DWORD)v6)
    {
      if (sub_1000A86F0())
      {
        sub_1001EE134((uint64_t)"Could not generate LTK %!", v15, v16, v17, v18, v19, v20, v21, v6);
        uint64_t v22 = (os_log_s *)sub_100086554(0x43u);
        if (os_log_type_enabled(v22, OS_LOG_TYPE_ERROR)) {
          goto LABEL_8;
        }
      }
    }
  }

  return v6;
}

uint64_t sub_1001D2AC0(__int16 *a1, int a2)
{
  if ((unsigned __int16)*a1 | *((unsigned __int8 *)a1 + 2))
  {
    if (a2) {
      uint64_t v4 = sub_100184B7C();
    }
    else {
      uint64_t v4 = sub_100184B70();
    }
    if (*v4 == 0)
    {
      if (sub_1000A86F0())
      {
        sub_1001EE134( (uint64_t)"Cannot generate local random address when the IRK is set to 0's",  v23,  v24,  v25,  v26,  v27,  v28,  v29,  v32);
        uint64_t v30 = (os_log_s *)sub_100086554(0x43u);
        if (os_log_type_enabled(v30, OS_LOG_TYPE_ERROR)) {
          sub_100657858();
        }
      }

      return 103LL;
    }

    else
    {
      uint64_t v13 = sub_100110FB8(v4, a1, (uint64_t)a1 + 3);
      if (sub_1000B0174() && sub_1000A86F0())
      {
        uint64_t v21 = "Primary";
        if (a2) {
          uint64_t v21 = "Secondary";
        }
        sub_1001EE134( (uint64_t)"******* GENERATING RANDOM ADDRESS WITH %s IRK:%@ address:%@ AH result:%d",  v14,  v15,  v16,  v17,  v18,  v19,  v20,  (uint64_t)v21);
        uint64_t v22 = (os_log_s *)sub_100086554(0x43u);
        if (os_log_type_enabled(v22, OS_LOG_TYPE_DEFAULT))
        {
          *(_DWORD *)__int128 buf = 136446210;
          uint64_t v34 = sub_1001EDDCC();
          _os_log_impl((void *)&_mh_execute_header, v22, OS_LOG_TYPE_DEFAULT, " %{public}s", buf, 0xCu);
        }
      }
    }
  }

  else
  {
    if (sub_1000A86F0())
    {
      sub_1001EE134( (uint64_t)"Cannot generate local random address when the address bytes are set to 0's",  v5,  v6,  v7,  v8,  v9,  v10,  v11,  v32);
      uint64_t v12 = (os_log_s *)sub_100086554(0x43u);
      if (os_log_type_enabled(v12, OS_LOG_TYPE_ERROR)) {
        sub_100657858();
      }
    }

    return 101LL;
  }

  return v13;
}

void sub_1001D2C94(uint64_t a1, uint64_t a2)
{
  uint64_t v66 = a1;
  if ((_DWORD)a2)
  {
    if (sub_1000A86F0())
    {
      sub_1001EE134((uint64_t)"Link ready CB with status %!(%d).", v3, v4, v5, v6, v7, v8, v9, a2);
      uint64_t v10 = (os_log_s *)sub_100086554(0x43u);
      if (os_log_type_enabled(v10, OS_LOG_TYPE_ERROR)) {
LABEL_31:
      }
        sub_100657858();
    }
  }

  else
  {
    uint64_t v12 = sub_100184F2C(a1);
    if (v12)
    {
      uint64_t v13 = (char *)v12;
      if (*(_BYTE *)(a1 + 166) == 1)
      {
        if (sub_1000A86F0())
        {
          sub_1001EE134( (uint64_t)"Connection %p is already encrypted, lets drop this pairing data",  v14,  v15,  v16,  v17,  v18,  v19,  v20,  a1);
          uint64_t v21 = (os_log_s *)sub_100086554(0x43u);
          if (os_log_type_enabled(v21, OS_LOG_TYPE_DEFAULT))
          {
            LODWORD(buf) = 136446210;
            *(void *)((char *)&buf + 4) = sub_1001EDDCC();
            _os_log_impl((void *)&_mh_execute_header, v21, OS_LOG_TYPE_DEFAULT, " %{public}s", (uint8_t *)&buf, 0xCu);
          }
        }

        sub_100184BB0(v13, 0LL, 0);
      }

      else if (sub_10018550C(v12, 16))
      {
        if (sub_1000A86F0())
        {
          sub_100185414();
          sub_1001EE134( (uint64_t)"continue deferred handling of incoming Security Request from device %: (%s)",  v22,  v23,  v24,  v25,  v26,  v27,  v28,  a1 + 49);
          uint64_t v29 = (os_log_s *)sub_100086554(0x43u);
          if (os_log_type_enabled(v29, OS_LOG_TYPE_DEFAULT))
          {
            LODWORD(buf) = 136446210;
            *(void *)((char *)&buf + 4) = sub_1001EDDCC();
            _os_log_impl((void *)&_mh_execute_header, v29, OS_LOG_TYPE_DEFAULT, " %{public}s", (uint8_t *)&buf, 0xCu);
          }
        }

        *((void *)&buf + 1) = v13;
        *(void *)&__int128 buf = 8LL;
        uint64_t v30 = sub_1001EE6E8((uint64_t)sub_1001D3024, (const void **)&buf, 5, 0LL);
        if ((_DWORD)v30)
        {
          uint64_t v31 = v30;
          if (sub_1000A86F0())
          {
            sub_1001EE134( (uint64_t)"Could not dispatch SecurityRequest CB with status %!.",  v32,  v33,  v34,  v35,  v36,  v37,  v38,  v31);
            uint64_t v39 = (os_log_s *)sub_100086554(0x43u);
            if (os_log_type_enabled(v39, OS_LOG_TYPE_ERROR)) {
              sub_100657F74();
            }
          }
        }
      }

      else if (sub_10018550C((uint64_t)v13, 17))
      {
        if (sub_1000A86F0())
        {
          sub_100185414();
          sub_1001EE134( (uint64_t)"continue deferred handling of incoming Pairing Request from device %: (%s)",  v40,  v41,  v42,  v43,  v44,  v45,  v46,  a1 + 49);
          uint64_t v47 = (os_log_s *)sub_100086554(0x43u);
          if (os_log_type_enabled(v47, OS_LOG_TYPE_DEFAULT))
          {
            LODWORD(buf) = 136446210;
            *(void *)((char *)&buf + 4) = sub_1001EDDCC();
            _os_log_impl((void *)&_mh_execute_header, v47, OS_LOG_TYPE_DEFAULT, " %{public}s", (uint8_t *)&buf, 0xCu);
          }
        }

        *((void *)&buf + 1) = &v66;
        *(void *)&__int128 buf = 8LL;
        uint64_t v48 = sub_1001EE6E8((uint64_t)sub_1001D3118, (const void **)&buf, 5, 0LL);
        if ((_DWORD)v48)
        {
          uint64_t v49 = v48;
          if (sub_1000A86F0())
          {
            sub_1001EE134( (uint64_t)"Could not dispatch pairing request with status %!.",  v50,  v51,  v52,  v53,  v54,  v55,  v56,  v49);
            uint64_t v57 = (os_log_s *)sub_100086554(0x43u);
            if (os_log_type_enabled(v57, OS_LOG_TYPE_ERROR)) {
              sub_100657F74();
            }
          }
        }
      }

      else if (sub_1001CBEB4(a1))
      {
        if (sub_1000A86F0())
        {
          sub_100185414();
          sub_1001EE134( (uint64_t)"Device %: is in state %s, but its not supposed to be in this state",  v58,  v59,  v60,  v61,  v62,  v63,  v64,  a1 + 49);
          uint64_t v65 = (os_log_s *)sub_100086554(0x43u);
          if (os_log_type_enabled(v65, OS_LOG_TYPE_ERROR)) {
            goto LABEL_31;
          }
        }
      }
    }
  }

void sub_1001D3024(uint64_t a1)
{
  uint64_t v1 = **(void **)(a1 + 8);
  if (!sub_10012D5EC(v1))
  {
    sub_1001EE134((uint64_t)"Handle is not valid anymore.", v5, v6, v7, v8, v9, v10, v11, v21);
    uint64_t v12 = (os_log_s *)sub_100086554(0x43u);
    if (!os_log_type_enabled(v12, OS_LOG_TYPE_ERROR)) {
      return;
    }
LABEL_13:
    sub_100657858();
    return;
  }

  uint64_t v2 = sub_100184F2C(v1);
  if (!v2)
  {
    sub_1001EE134((uint64_t)"There is no pairing data for connection", v13, v14, v15, v16, v17, v18, v19, v21);
    uint64_t v20 = (os_log_s *)sub_100086554(0x43u);
    if (!os_log_type_enabled(v20, OS_LOG_TYPE_ERROR)) {
      return;
    }
    goto LABEL_13;
  }

  if (off_1008F6EA0)
  {
    unsigned int v3 = *(unsigned __int8 *)(v2 + 80);
    if (*(_BYTE *)(v1 + 55)) {
      uint64_t v4 = v1 + 56;
    }
    else {
      uint64_t v4 = v1 + 48;
    }
    off_1008F6EA0(v4, (v3 >> 2) & 1, 0LL);
  }

void sub_1001D3118(uint64_t a1)
{
  uint64_t v1 = *(uint64_t **)(a1 + 8);
  uint64_t v2 = *v1;
  if (*v1 && sub_10012D5EC(*v1))
  {
    if (sub_100184F2C(v2))
    {
      if (off_1008F6EA8) {
        off_1008F6EA8(v2 + 48, 0LL);
      }
      return;
    }

    if (sub_1000A86F0())
    {
      sub_1001EE134( (uint64_t)"There is no security request for this connection. Ignoring reply.",  v11,  v12,  v13,  v14,  v15,  v16,  v17,  v19);
      uint64_t v18 = (os_log_s *)sub_100086554(0x43u);
      if (os_log_type_enabled(v18, OS_LOG_TYPE_ERROR)) {
LABEL_8:
      }
        sub_100657858();
    }
  }

  else if (sub_1000A86F0())
  {
    sub_1001EE134((uint64_t)"This handle is not a LE connection.", v3, v4, v5, v6, v7, v8, v9, v19);
    uint64_t v10 = (os_log_s *)sub_100086554(0x43u);
    if (os_log_type_enabled(v10, OS_LOG_TYPE_ERROR)) {
      goto LABEL_8;
    }
  }

void sub_1001D31F8(uint64_t a1, uint64_t a2)
{
  uint64_t v3 = (char *)sub_100184F2C(a1);
  if (v3) {
    sub_100184BB0(v3, a2, 1);
  }
}

uint64_t sub_1001D3230(uint64_t a1)
{
  if (!sub_10012D5EC(a1)) {
    return 122LL;
  }
  uint64_t v2 = *(char **)(a1 + 240);
  if (v2) {
    sub_100184BB0(v2, 122LL, 1);
  }
  uint64_t result = *(unsigned int *)(a1 + 180);
  if ((_DWORD)result)
  {
    sub_1001EEB14(result);
    uint64_t result = 0LL;
    *(_DWORD *)(a1 + 180) = 0;
  }

  return result;
}

void sub_1001D3284(__int128 *a1)
{
  int v2 = sub_1000A86F0();
  if (a1)
  {
    if (v2)
    {
      sub_1001EE134((uint64_t)"MUC - save IRK and update RSA adv instance", v3, v4, v5, v6, v7, v8, v9, *(uint64_t *)v12);
      uint64_t v10 = (os_log_s *)sub_100086554(0x43u);
      if (os_log_type_enabled(v10, OS_LOG_TYPE_DEFAULT))
      {
        *(_DWORD *)uint64_t v12 = 136446210;
        *(void *)&v12[4] = sub_1001EDDCC();
        _os_log_impl((void *)&_mh_execute_header, v10, OS_LOG_TYPE_DEFAULT, " %{public}s", v12, 0xCu);
      }
    }

    xmmword_1008EDB26 = *a1;
  }

  else
  {
    if (v2)
    {
      sub_1001EE134((uint64_t)"MUC - reset IRK", v3, v4, v5, v6, v7, v8, v9, *(uint64_t *)v12);
      uint64_t v11 = (os_log_s *)sub_100086554(0x43u);
      if (os_log_type_enabled(v11, OS_LOG_TYPE_DEFAULT))
      {
        *(_DWORD *)uint64_t v12 = 136446210;
        *(void *)&v12[4] = sub_1001EDDCC();
        _os_log_impl((void *)&_mh_execute_header, v11, OS_LOG_TYPE_DEFAULT, " %{public}s", v12, 0xCu);
      }
    }

    xmmword_1008EDB26 = 0uLL;
  }

uint64_t sub_1001D33C4(__int128 *a1, __n128 *a2, __int128 *a3, __int128 *a4, __n128 *a5)
{
  xmmword_1008EDB36 = *a1;
  sub_100184B88(a2);
  sub_100184B9C(a5);
  xmmword_1008EDB16 = *a3;
  xmmword_1008EDB06 = *a4;
  return 0LL;
}

uint64_t sub_1001D3434( uint64_t (*a1)(void, void, void, void, void), uint64_t a2, uint64_t (*a3)(void, void, void, void), int a4, int a5, char a6, char a7)
{
  if (qword_1008EDB48) {
    sub_1001EE2A0();
  }
  byte_1008D8ED3 = sub_1001D3584(a4, a5);
  unk_1008F6E98 = a1;
  *(_OWORD *)&off_1008F6EA0 = *(_OWORD *)a2;
  off_1008F6EB0 = *(uint64_t (**)(void, void, void, void))(a2 + 16);
  unk_1008F6EB8 = a3;
  uint64_t v14 = sub_1001732EC(6u, 2, 8, 8u, &qword_1008EDB48, (uint64_t)sub_100184DA0);
  if ((_DWORD)v14) {
    BOOL v15 = 1;
  }
  else {
    BOOL v15 = qword_1008EDB48 == 0;
  }
  if (v15)
  {
    if (sub_1000A86F0())
    {
      sub_1001EE134((uint64_t)"Could not register the LE SecurityManager : %!", v16, v17, v18, v19, v20, v21, v22, v14);
      uint64_t v23 = (os_log_s *)sub_100086554(0x43u);
      if (os_log_type_enabled(v23, OS_LOG_TYPE_ERROR)) {
        sub_100657F74();
      }
    }
  }

  else
  {
    *(_WORD *)sub_10017AF44((unsigned int *)qword_1008EDB48) = 65;
    byte_1008EDB01 = a6;
    byte_1008EDB05 = a7;
    *(_WORD *)(sub_10017AF44((unsigned int *)qword_1008EDB48) + 2) = -1;
    sub_1001B7C4C((uint64_t)&unk_100886108);
  }

  return v14;
}

uint64_t sub_1001D3584(int a1, int a2)
{
  switch(a1)
  {
    case 3:
      if (a2 == 16) {
        return 2LL;
      }
      if (a2 == 32) {
        return 4LL;
      }
      goto LABEL_13;
    case 2:
      if (a2 != 16)
      {
        if (a2 == 32) {
          return 1LL;
        }
        goto LABEL_13;
      }

      break;
    case 1:
      if (a2 != 16)
      {
        if (a2 == 32) {
          return 0LL;
        }
        goto LABEL_13;
      }

      break;
    default:
LABEL_13:
      sub_1001EE2A0();
      return 3LL;
  }

  return 3LL;
}

uint64_t sub_1001D3604()
{
  uint64_t v0 = sub_1001734D8(qword_1008EDB48);
  if ((_DWORD)v0)
  {
    if (sub_1000A86F0())
    {
      sub_1001EE134((uint64_t)"Could not de-register the LE SecurityManager : %!", v1, v2, v3, v4, v5, v6, v7, v0);
      uint64_t v8 = (os_log_s *)sub_100086554(0x43u);
      if (os_log_type_enabled(v8, OS_LOG_TYPE_ERROR)) {
        sub_100657F74();
      }
    }
  }

  else
  {
    qword_1008EDB48 = 0LL;
    *(_OWORD *)&unk_1008F6E98 = 0u;
    *(_OWORD *)&off_1008F6EA8 = 0u;
    *(_OWORD *)&unk_1008F6EB8 = 0u;
    byte_1008D8ED3 = 3;
    sub_100184B88(&xmmword_1006BDDD8);
    sub_100184B9C(&xmmword_1006BDDD8);
    xmmword_1008EDB06 = 0uLL;
    xmmword_1008EDB16 = 0uLL;
    xmmword_1008EDB36 = 0uLL;
  }

  return v0;
}

uint64_t sub_1001D36EC()
{
  if (xmmword_1008EDB16 != 0 && xmmword_1008EDB36 != 0) {
    return 0LL;
  }
  if (sub_1000A86F0())
  {
    sub_1001EE134((uint64_t)"Root keys are not set, can't pair.", v1, v2, v3, v4, v5, v6, v7, v9);
    uint64_t v8 = (os_log_s *)sub_100086554(0x43u);
    if (os_log_type_enabled(v8, OS_LOG_TYPE_ERROR)) {
      sub_100657858();
    }
  }

  sub_1001EE2A0();
  return 4826LL;
}

uint64_t sub_1001D377C(uint64_t a1, int a2)
{
  char v4 = byte_1008D8ED1;
  else {
    char v5 = byte_1008D8ED2;
  }
  char v6 = v4 & 0xF7;
  char v7 = v5 & 0xF7;
  if (byte_1008EDB00) {
    char v8 = v4 & 0xF7;
  }
  else {
    char v8 = v4;
  }
  if (byte_1008EDB00) {
    char v9 = v5 & 0xF7;
  }
  else {
    char v9 = v5;
  }
  if (sub_1000A86F0())
  {
    sub_1001EE134((uint64_t)"StartPairing was called", v10, v11, v12, v13, v14, v15, v16, v91);
    uint64_t v17 = (os_log_s *)sub_100086554(0x43u);
    if (os_log_type_enabled(v17, OS_LOG_TYPE_DEFAULT))
    {
      *(_DWORD *)__int128 buf = 136446210;
      uint64_t v93 = sub_1001EDDCC();
      _os_log_impl((void *)&_mh_execute_header, v17, OS_LOG_TYPE_DEFAULT, " %{public}s", buf, 0xCu);
    }
  }

  uint64_t v18 = sub_1001D36EC();
  if ((_DWORD)v18) {
    return v18;
  }
  if (!sub_10012D5EC(a1))
  {
    sub_1001EE134((uint64_t)"Connection handle is not a LE handle...", v19, v20, v21, v22, v23, v24, v25, v91);
    uint64_t v26 = (os_log_s *)sub_100086554(0x43u);
    if (!os_log_type_enabled(v26, OS_LOG_TYPE_ERROR)) {
      return 4820LL;
    }
LABEL_21:
    sub_100657858();
    return 4820LL;
  }

  if (*(_BYTE *)(a1 + 233)) {
    return 4837LL;
  }
  char v28 = v6;
  char v29 = v7;
  if (a2) {
    int v30 = 4;
  }
  else {
    int v30 = 0;
  }
  int v31 = v30 | sub_1001BD960();
  if (byte_1008EDB01)
  {
    if (*(unsigned __int8 *)(a1 + 24) > 7u
      || (int v32 = *(unsigned __int16 *)(a1 + 20), v32 != 2) && v32 != 90 && v32 != 13
      || *(_BYTE *)(a1 + 70) == 1)
    {
      if ((byte_1008EDB02 & 1) != 0 || *(_BYTE *)(a1 + 232) || (v8 & 8) == 0)
      {
        v31 |= 8u;
      }

      else
      {
        if (sub_1000A86F0())
        {
          sub_1001EE134((uint64_t)"Sending CT2=1", v33, v34, v35, v36, v37, v38, v39, v91);
          uint64_t v40 = (os_log_s *)sub_100086554(0x43u);
          if (os_log_type_enabled(v40, OS_LOG_TYPE_DEFAULT))
          {
            uint64_t v41 = sub_1001EDDCC();
            *(_DWORD *)__int128 buf = 136446210;
            uint64_t v93 = v41;
            _os_log_impl((void *)&_mh_execute_header, v40, OS_LOG_TYPE_DEFAULT, " %{public}s", buf, 0xCu);
          }
        }

        v31 |= 0x28u;
      }

      char v28 = v8;
      char v29 = v9;
    }
  }

  if (*(_BYTE *)(a1 + 232)) {
    int v42 = v31 & 0x1F;
  }
  else {
    int v42 = v31;
  }
  if (*(_BYTE *)(a1 + 232)) {
    char v43 = v6;
  }
  else {
    char v43 = v28;
  }
  if (!*(_BYTE *)(a1 + 232)) {
    char v7 = v29;
  }
  uint64_t v44 = v42 | byte_1008EDB04;
  if (*(_BYTE *)(a1 + 55)) {
    uint64_t v45 = (_DWORD *)(a1 + 56);
  }
  else {
    uint64_t v45 = 0LL;
  }
  char v46 = sub_1001C822C((_DWORD *)(a1 + 48), v45);
  if (sub_1000A86F0())
  {
    sub_1001EE134((uint64_t)"authReq=%x localKeyDist=%x localKeyReq=%x", v47, v48, v49, v50, v51, v52, v53, v44);
    uint64_t v54 = (os_log_s *)sub_100086554(0x43u);
    if (os_log_type_enabled(v54, OS_LOG_TYPE_DEFAULT))
    {
      uint64_t v55 = sub_1001EDDCC();
      *(_DWORD *)__int128 buf = 136446210;
      uint64_t v93 = v55;
      _os_log_impl((void *)&_mh_execute_header, v54, OS_LOG_TYPE_DEFAULT, " %{public}s", buf, 0xCu);
    }
  }

  if (*(_BYTE *)(a1 + 70) != 1) {
    return sub_1001CE204(a1, byte_1008D8ED3, v46, v44, v43, v7);
  }
  buf[0] = 11;
  buf[1] = v44;
  if (!sub_10012D5EC(a1))
  {
    sub_1001EE134((uint64_t)"This command is only available to LE devices.", v67, v68, v69, v70, v71, v72, v73, v91);
    uint64_t v74 = (os_log_s *)sub_100086554(0x43u);
    if (!os_log_type_enabled(v74, OS_LOG_TYPE_ERROR)) {
      return 4820LL;
    }
    goto LABEL_21;
  }

  if (*(_BYTE *)(a1 + 70))
  {
    uint64_t v56 = sub_100184F2C(a1);
    if (v56)
    {
      uint64_t v57 = (char *)v56;
      if (!sub_10018550C(v56, 0))
      {
        if (sub_1000A86F0())
        {
          uint64_t v58 = sub_100185414();
          sub_1001EE134( (uint64_t)"Cannot send a security request, device is in state %s.",  v59,  v60,  v61,  v62,  v63,  v64,  v65,  (uint64_t)v58);
          uint64_t v66 = (os_log_s *)sub_100086554(0x43u);
          if (os_log_type_enabled(v66, OS_LOG_TYPE_ERROR)) {
            sub_100657F74();
          }
        }

        return 4804LL;
      }

uint64_t sub_1001D3CB8(_OWORD *a1)
{
  if (a1)
  {
    uint64_t v2 = a1 + 2;
    uint64_t v3 = sub_1001120DC(a1 + 2, a1 + 6);
    if ((_DWORD)v3)
    {
      uint64_t v4 = v3;
      if (sub_1000A86F0())
      {
        sub_1001EE134((uint64_t)"Failed to generate public/private key %!", v5, v6, v7, v8, v9, v10, v11, v4);
        uint64_t v12 = (os_log_s *)sub_100086554(0x43u);
        if (os_log_type_enabled(v12, OS_LOG_TYPE_ERROR)) {
          sub_100657F74();
        }
      }
    }

    else
    {
      arc4random_buf(a1, 0x10uLL);
      __int128 v22 = v2[1];
      v32[0] = *v2;
      v32[1] = v22;
      uint64_t v4 = sub_1001116D0(v32, v32, a1, 0, a1 + 1);
      if ((_DWORD)v4)
      {
        if (sub_1000A86F0())
        {
          sub_1001EE134( (uint64_t)"Failed to generate confirmation value C with status %!",  v23,  v24,  v25,  v26,  v27,  v28,  v29,  v4);
          int v30 = (os_log_s *)sub_100086554(0x43u);
          if (os_log_type_enabled(v30, OS_LOG_TYPE_ERROR)) {
            sub_100657F74();
          }
        }
      }
    }
  }

  else
  {
    if (sub_1000A86F0())
    {
      sub_1001EE134( (uint64_t)"Must provide storage for OOB Bundle and private key",  v13,  v14,  v15,  v16,  v17,  v18,  v19,  v31);
      uint64_t v20 = (os_log_s *)sub_100086554(0x43u);
      if (os_log_type_enabled(v20, OS_LOG_TYPE_ERROR)) {
        sub_100657858();
      }
    }

    return 101LL;
  }

  return v4;
}

uint64_t sub_1001D3E40(_DWORD *a1, _OWORD *a2, _OWORD *a3, _OWORD *a4)
{
  uint64_t v7 = sub_10012D98C(a1);
  if (!v7) {
    return 122LL;
  }
  uint64_t v8 = (__int128 *)v7;
  uint64_t v9 = sub_100184F2C(v7);
  if (!v9) {
    return 4806LL;
  }
  uint64_t v10 = (char *)v9;
  if ((*(_BYTE *)(v9 + 72) & *(_BYTE *)(v9 + 80) & 8) == 0 || *(_BYTE *)(v9 + 16) != 5)
  {
    if (sub_1000A86F0())
    {
      sub_1001EE134( (uint64_t)"This API can only be called on LE Secured Connection OOB Pairing.",  v26,  v27,  v28,  v29,  v30,  v31,  v32,  v67);
      uint64_t v33 = (os_log_s *)sub_100086554(0x43u);
      if (os_log_type_enabled(v33, OS_LOG_TYPE_ERROR)) {
        sub_100657858();
      }
    }

    uint64_t v17 = 408LL;
    goto LABEL_27;
  }

  if (a4)
  {
    __int128 v11 = a4[2];
    __int128 v12 = a4[3];
    __int128 v13 = a4[4];
    *(_OWORD *)(v9 + 200) = a4[5];
    *(_OWORD *)(v9 + 184) = v13;
    *(_OWORD *)(v9 + 168) = v12;
    *(_OWORD *)(v9 + 152) = v11;
    memmove((void *)(v9 + 216), a4 + 6, 0x60uLL);
    if (*(_BYTE *)(*(void *)v10 + 70LL) == 1) {
      uint64_t v14 = v10 + 441;
    }
    else {
      uint64_t v14 = v10 + 425;
    }
    *uint64_t v14 = *a4;
    *(_OWORD *)(v10 + 88) = a4[1];
  }

  else
  {
    uint64_t v35 = (_OWORD *)(v9 + 152);
    uint64_t v36 = sub_1001120DC((_OWORD *)(v9 + 152), (_OWORD *)(v9 + 216));
    if ((_DWORD)v36)
    {
      uint64_t v17 = v36;
      if (sub_1000A86F0())
      {
        sub_1001EE134((uint64_t)"Failed to generate public/private key %!", v37, v38, v39, v40, v41, v42, v43, v17);
        uint64_t v44 = (os_log_s *)sub_100086554(0x43u);
        if (os_log_type_enabled(v44, OS_LOG_TYPE_ERROR)) {
          sub_100657F74();
        }
      }

      goto LABEL_27;
    }

    if (*(_BYTE *)(*(void *)v10 + 70LL) == 1) {
      uint64_t v53 = v10 + 441;
    }
    else {
      uint64_t v53 = v10 + 425;
    }
    arc4random_buf(v53, 0x10uLL);
    uint64_t v54 = *(void *)v10;
    if (*(_BYTE *)(*(void *)v10 + 70LL) == 1) {
      uint64_t v55 = v10 + 425;
    }
    else {
      uint64_t v55 = v10 + 441;
    }
    *uint64_t v55 = 0LL;
    v55[1] = 0LL;
    __int128 v56 = *(_OWORD *)(v10 + 168);
    *(_OWORD *)uint64_t v68 = *v35;
    *(_OWORD *)&v68[16] = v56;
    if (*(_BYTE *)(v54 + 70) == 1) {
      uint64_t v57 = (__int128 *)(v10 + 441);
    }
    else {
      uint64_t v57 = (__int128 *)(v10 + 425);
    }
    uint64_t v58 = sub_1001116D0(v68, v68, v57, 0, v10 + 88);
    if ((_DWORD)v58)
    {
      uint64_t v17 = v58;
      sub_1001EE134( (uint64_t)"Failed to generate confirmation value C with status %!",  v59,  v60,  v61,  v62,  v63,  v64,  v65,  v17);
      uint64_t v66 = (os_log_s *)sub_100086554(0x43u);
      if (!os_log_type_enabled(v66, OS_LOG_TYPE_ERROR)) {
        goto LABEL_27;
      }
      goto LABEL_50;
    }
  }

  if (a2)
  {
    if (*(_BYTE *)(*(void *)v10 + 70LL) == 1) {
      uint64_t v15 = v10 + 425;
    }
    else {
      uint64_t v15 = v10 + 441;
    }
    _OWORD *v15 = *a2;
  }

  if (a3) {
    *(_OWORD *)(v10 + 104) = *a3;
  }
  v10[490] = 1;
  uint64_t v16 = *(__int128 **)v10;
  if (!*(_BYTE *)(*(void *)v10 + 70LL))
  {
    v68[0] = 12;
    *(_OWORD *)&v68[1] = *(_OWORD *)(v10 + 152);
    *(_OWORD *)&v68[17] = *(_OWORD *)(v10 + 168);
    __int128 v69 = *(_OWORD *)(v10 + 184);
    __int128 v70 = *(_OWORD *)(v10 + 200);
    uint64_t v17 = sub_100184F74(v16, v68, 0x41uLL, 1);
    if (!(_DWORD)v17)
    {
      sub_100185420((uint64_t)v10, 33);
      return v17;
    }

    sub_1001EE134((uint64_t)"Failed to send public keys %!", v45, v46, v47, v48, v49, v50, v51, v17);
    uint64_t v52 = (os_log_s *)sub_100086554(0x43u);
    if (!os_log_type_enabled(v52, OS_LOG_TYPE_ERROR)) {
      goto LABEL_27;
    }
LABEL_50:
    sub_100657F74();
LABEL_27:
    sub_1001CBE38(v8, 8, v10);
    return v17;
  }

  sub_100185420((uint64_t)v10, 32);
  uint64_t v17 = sub_1001D41F8((uint64_t)v10);
  if ((_DWORD)v17)
  {
    sub_1001EE134((uint64_t)"recvdSMPDeferredOOBPublicKey failed %!", v18, v19, v20, v21, v22, v23, v24, v17);
    uint64_t v25 = (os_log_s *)sub_100086554(0x43u);
    if (!os_log_type_enabled(v25, OS_LOG_TYPE_ERROR)) {
      goto LABEL_27;
    }
    goto LABEL_50;
  }

  return v17;
}

uint64_t sub_1001D41F8(uint64_t a1)
{
  if (!*(_BYTE *)(a1 + 490) || !memcmp((const void *)(a1 + 312), __s2, 0x40uLL))
  {
    if (*(_BYTE *)(*(void *)a1 + 70LL) == 1) {
      char v15 = 32;
    }
    else {
      char v15 = 33;
    }
    sub_100185420(a1, v15);
    return 0LL;
  }

  uint64_t v2 = *(__int128 **)a1;
  if (*(_BYTE *)(*(void *)a1 + 70LL) != 1) {
    goto LABEL_15;
  }
  if (!memcmp((const void *)(a1 + 152), __s2, 0x40uLL))
  {
    uint64_t v43 = sub_1001120DC((_OWORD *)(a1 + 152), (_OWORD *)(a1 + 216));
    if ((_DWORD)v43)
    {
      uint64_t v6 = v43;
      if (sub_1000A86F0())
      {
        sub_1001EE134((uint64_t)"LE_ReadLocalPublicKey failed %!", v44, v45, v46, v47, v48, v49, v50, v6);
        uint64_t v51 = (os_log_s *)sub_100086554(0x43u);
        if (os_log_type_enabled(v51, OS_LOG_TYPE_ERROR)) {
          goto LABEL_40;
        }
      }

      return v6;
    }

    uint64_t v2 = *(__int128 **)a1;
  }

  v76[0] = 12;
  __int128 v3 = *(_OWORD *)(a1 + 168);
  *(_OWORD *)&v76[1] = *(_OWORD *)(a1 + 152);
  *(_OWORD *)&v76[17] = v3;
  __int128 v4 = *(_OWORD *)(a1 + 200);
  __int128 v77 = *(_OWORD *)(a1 + 184);
  __int128 v78 = v4;
  uint64_t v5 = sub_100184F74(v2, v76, 0x41uLL, 1);
  if (!(_DWORD)v5)
  {
LABEL_15:
    uint64_t v17 = sub_100112260((const void *)(a1 + 312), 64LL, (const void *)(a1 + 216), 0x60u, (void *)(a1 + 376));
    if ((_DWORD)v17)
    {
      uint64_t v6 = v17;
      if (sub_1000A86F0())
      {
        sub_1001EE134((uint64_t)"DHKey generation failed %!", v18, v19, v20, v21, v22, v23, v24, v6);
        uint64_t v25 = (os_log_s *)sub_100086554(0x43u);
        if (os_log_type_enabled(v25, OS_LOG_TYPE_ERROR)) {
          goto LABEL_40;
        }
      }

      return v6;
    }

    sub_100185340((uint64_t *)a1);
    BOOL v26 = *(void *)(a1 + 104) == *(void *)&__s2[0] && *(void *)(a1 + 112) == *((void *)&__s2[0] + 1);
    uint64_t v27 = *(void *)a1;
    int v28 = *(unsigned __int8 *)(*(void *)a1 + 70LL);
    if (v26
      || (*(_BYTE *)(*(void *)a1 + 70LL) ? (uint64_t v29 = (uint64_t *)(a1 + 425)) : (uint64_t v29 = (uint64_t *)(a1 + 441)),
          (v31 = *v29, uint64_t v30 = v29[1], v31 == *(void *)&__s2[0]) ? (v32 = v30 == *((void *)&__s2[0] + 1)) : (v32 = 0),
          v32))
    {
      if (*(_BYTE *)(*(void *)a1 + 70LL)) {
        uint64_t v52 = (void *)(a1 + 425);
      }
      else {
        uint64_t v52 = (void *)(a1 + 441);
      }
    }

    else
    {
      uint64_t v73 = 0LL;
      uint64_t v74 = 0LL;
      __int128 v33 = *(_OWORD *)(a1 + 328);
      *(_OWORD *)uint64_t v76 = *(_OWORD *)(a1 + 312);
      *(_OWORD *)&v76[16] = v33;
      if (v28 == 1) {
        uint64_t v34 = (__int128 *)(a1 + 425);
      }
      else {
        uint64_t v34 = (__int128 *)(a1 + 441);
      }
      uint64_t v6 = sub_1001116D0(v76, v76, v34, 0, &v73);
      if ((_DWORD)v6)
      {
        sub_1001EE134( (uint64_t)"Failed to calculate remote C value with status %!",  v35,  v36,  v37,  v38,  v39,  v40,  v41,  v6);
        uint64_t v42 = (os_log_s *)sub_100086554(0x43u);
        if (!os_log_type_enabled(v42, OS_LOG_TYPE_ERROR)) {
          return v6;
        }
        goto LABEL_36;
      }

      if (*(void *)(a1 + 104) != v73 || *(void *)(a1 + 112) != v74)
      {
        if (sub_1000A86F0())
        {
          sub_1001EE134( (uint64_t)"Received and calculated remote C values do not match",  v64,  v65,  v66,  v67,  v68,  v69,  v70,  v72);
          uint64_t v71 = (os_log_s *)sub_100086554(0x43u);
          if (os_log_type_enabled(v71, OS_LOG_TYPE_ERROR)) {
            sub_100657858();
          }
        }

        sub_1001CBE38(*(__int128 **)a1, 4, (char *)a1);
        return v6;
      }

      uint64_t v27 = *(void *)a1;
      if (*(_BYTE *)(a1 + 79)) {
        goto LABEL_45;
      }
      if (*(_BYTE *)(v27 + 70) == 1) {
        uint64_t v52 = (void *)(a1 + 441);
      }
      else {
        uint64_t v52 = (void *)(a1 + 425);
      }
    }

    *uint64_t v52 = 0LL;
    v52[1] = 0LL;
LABEL_45:
    if (*(_BYTE *)(v27 + 70) == 1) {
      uint64_t v53 = (void *)(a1 + 473);
    }
    else {
      uint64_t v53 = (void *)(a1 + 457);
    }
    arc4random_buf(v53, 0x10uLL);
    if (*(_BYTE *)(*(void *)a1 + 70LL)) {
      char v54 = 36;
    }
    else {
      char v54 = 35;
    }
    sub_100185420(a1, v54);
    if (!*(_BYTE *)(*(void *)a1 + 70LL))
    {
      uint64_t v6 = sub_1001D4A70(*(void *)a1, (__int128 *)(a1 + 457));
      if (!(_DWORD)v6)
      {
        sub_100185420(a1, 37);
        return v6;
      }

      sub_1001EE134((uint64_t)"Failed to send pairing random to peripheral %!", v55, v56, v57, v58, v59, v60, v61, v6);
      uint64_t v62 = (os_log_s *)sub_100086554(0x43u);
      if (!os_log_type_enabled(v62, OS_LOG_TYPE_ERROR)) {
        return v6;
      }
LABEL_36:
      sub_100657F74();
      return v6;
    }

    return 0LL;
  }

  uint64_t v6 = v5;
  if (sub_1000A86F0())
  {
    sub_1001EE134((uint64_t)"smpSendPairingPublicKey failed %!", v7, v8, v9, v10, v11, v12, v13, v6);
    uint64_t v14 = (os_log_s *)sub_100086554(0x43u);
    if (os_log_type_enabled(v14, OS_LOG_TYPE_ERROR)) {
LABEL_40:
    }
      sub_100657F74();
  }

  return v6;
}

uint64_t sub_1001D463C(_DWORD *a1, _BYTE *a2)
{
  uint64_t v3 = sub_10012D98C(a1);
  if (!v3) {
    return 122LL;
  }
  uint64_t v4 = sub_100184F2C(v3);
  if (!v4) {
    return 4806LL;
  }
  uint64_t v5 = v4;
  uint64_t result = 0LL;
  *a2 = *(_BYTE *)(v5 + 80);
  return result;
}

uint64_t sub_1001D4688(uint64_t result)
{
  byte_1008D8ED1 = result;
  return result;
}

uint64_t sub_1001D4694(uint64_t result)
{
  byte_1008D8ED2 = result;
  return result;
}

uint64_t sub_1001D46A0(uint64_t result)
{
  byte_1008F2990 = result;
  return result;
}

void sub_1001D46B0()
{
  byte_1008EDB02 = 1;
}

void sub_1001D46C0()
{
  byte_1008EDB03 = 1;
}

void sub_1001D46D8()
{
  byte_1008EDB00 = 1;
}

BOOL sub_1001D46E8(BOOL result, char a2)
{
  if (result)
  {
    uint64_t v3 = result;
    uint64_t result = sub_10012D5EC(result);
    if (result) {
      *(_BYTE *)(v3 + 232) = a2;
    }
  }

  return result;
}

uint64_t sub_1001D4718(uint64_t *a1)
{
  uint64_t v2 = sub_1001CCDD0(*a1, a1 + 11);
  if ((_DWORD)v2)
  {
    if (sub_1000A86F0())
    {
      sub_1001EE134((uint64_t)"smpSendPairingConfirmation failed %!", v3, v4, v5, v6, v7, v8, v9, v2);
      uint64_t v10 = (os_log_s *)sub_100086554(0x43u);
      if (os_log_type_enabled(v10, OS_LOG_TYPE_ERROR)) {
        sub_100657F74();
      }
    }
  }

  else
  {
    sub_100185420((uint64_t)a1, 36);
  }

  return v2;
}

void sub_1001D47A4(uint64_t a1)
{
  v11[1] = &v12;
  uint64_t v12 = a1;
  v11[0] = (const void *)8;
  uint64_t v1 = sub_1001EE6E8((uint64_t)sub_1001D483C, v11, 0, 0LL);
  if ((_DWORD)v1)
  {
    uint64_t v2 = v1;
    if (sub_1000A86F0())
    {
      sub_1001EE134( (uint64_t)"Could not dispatch dispatchPairingDisplay CB with status %!.",  v3,  v4,  v5,  v6,  v7,  v8,  v9,  v2);
      uint64_t v10 = (os_log_s *)sub_100086554(0x43u);
      if (os_log_type_enabled(v10, OS_LOG_TYPE_ERROR)) {
        sub_100657F74();
      }
    }
  }

void sub_1001D483C(uint64_t a1)
{
  uint64_t v1 = *(uint64_t **)(a1 + 8);
  uint64_t v2 = *v1;
  if (!*v1 || !sub_10012D5EC(*v1))
  {
    sub_1001EE134((uint64_t)"This handle is not a LE connection.", v5, v6, v7, v8, v9, v10, v11, v21);
    uint64_t v12 = (os_log_s *)sub_100086554(0x43u);
    if (!os_log_type_enabled(v12, OS_LOG_TYPE_ERROR)) {
      return;
    }
LABEL_10:
    sub_100657858();
    return;
  }

  uint64_t v3 = sub_100184F2C(v2);
  if (!v3)
  {
    sub_1001EE134( (uint64_t)"There is no security request for this connection. Ignoring reply.",  v13,  v14,  v15,  v16,  v17,  v18,  v19,  v21);
    uint64_t v20 = (os_log_s *)sub_100086554(0x43u);
    if (!os_log_type_enabled(v20, OS_LOG_TYPE_ERROR)) {
      return;
    }
    goto LABEL_10;
  }

  if (off_1008F6EB0)
  {
    uint64_t v4 = v2 + 48;
    if (*(_BYTE *)(v2 + 55)) {
      uint64_t v4 = v2 + 56;
    }
    off_1008F6EB0(v4, *(unsigned int *)(v3 + 52), v3 + 33, 0LL);
  }

uint64_t sub_1001D4938(_BYTE *a1, void *a2, int a3)
{
  uint64_t v3 = a1 + 78;
  uint64_t v4 = 80LL;
  if (a3) {
    uint64_t v4 = 72LL;
  }
  uint64_t v5 = 79LL;
  if (a3)
  {
    uint64_t v5 = 73LL;
    uint64_t v3 = &byte_1008D8ED3;
  }

  char v6 = *v3;
  char v7 = a1[v5];
  LOBYTE(v26) = a1[v4];
  HIBYTE(v26) = v7;
  char v27 = v6;
  if (a1[424])
  {
    uint64_t v9 = (char *)(*(void *)a1 + 48LL);
    uint64_t v10 = *(void *)a1 + 63LL;
    if (*(_BYTE *)(*(void *)a1 + 70LL))
    {
      if (a3)
      {
        uint64_t v11 = (__int128 *)(a1 + 473);
        uint64_t v12 = (__int128 *)(a1 + 457);
        uint64_t v13 = (__int128 *)(a1 + 425);
LABEL_15:
        uint64_t v23 = (__int128 *)(a1 + 408);
        uint64_t v24 = (char *)v10;
LABEL_19:
        sub_100111AE0(v23, v11, v12, v13, &v26, v24, v9, a2);
        return 0LL;
      }

      uint64_t v11 = (__int128 *)(a1 + 457);
      uint64_t v12 = (__int128 *)(a1 + 473);
      uint64_t v13 = (__int128 *)(a1 + 441);
    }

    else
    {
      if (a3)
      {
        uint64_t v11 = (__int128 *)(a1 + 457);
        uint64_t v12 = (__int128 *)(a1 + 473);
        uint64_t v13 = (__int128 *)(a1 + 441);
        goto LABEL_15;
      }

      uint64_t v11 = (__int128 *)(a1 + 473);
      uint64_t v12 = (__int128 *)(a1 + 457);
      uint64_t v13 = (__int128 *)(a1 + 425);
    }

    uint64_t v23 = (__int128 *)(a1 + 408);
    uint64_t v24 = v9;
    uint64_t v9 = (char *)v10;
    goto LABEL_19;
  }

  if (sub_1000A86F0())
  {
    sub_1001EE134( (uint64_t)"LTK And MacKey are not generated, we have a problem.",  v14,  v15,  v16,  v17,  v18,  v19,  v20,  v25);
    uint64_t v21 = (os_log_s *)sub_100086554(0x43u);
    if (os_log_type_enabled(v21, OS_LOG_TYPE_ERROR)) {
      sub_100657858();
    }
  }

  return 4824LL;
}

uint64_t sub_1001D4A70(uint64_t a1, __int128 *a2)
{
  char v62 = 4;
  __int128 v63 = *a2;
  if (sub_10012D5EC(a1))
  {
    uint64_t v3 = sub_100184F2C(a1);
    if (v3)
    {
      uint64_t v4 = (__int128 **)v3;
      int v5 = *(unsigned __int8 *)(a1 + 70);
      if ((*(_BYTE *)(v3 + 72) & *(_BYTE *)(v3 + 80) & 8) != 0)
      {
        if (v5 != 1)
        {
LABEL_7:
          if (!v5 && !sub_10018550C((uint64_t)v4, 35))
          {
            char v6 = sub_100185414();
            sub_1001EE134( (uint64_t)"Central connection should be in SMP_STATE_PAIRING_SCONFIRM to send this command, current state is %s.",  v7,  v8,  v9,  v10,  v11,  v12,  v13,  (uint64_t)v6);
            uint64_t v14 = (os_log_s *)sub_100086554(0x43u);
            if (!os_log_type_enabled(v14, OS_LOG_TYPE_ERROR)) {
              return 4823LL;
            }
            goto LABEL_38;
          }

          goto LABEL_24;
        }

        if (sub_10018550C(v3, 36))
        {
          int v5 = *(unsigned __int8 *)(a1 + 70);
          goto LABEL_7;
        }

        __int128 v33 = sub_100185414();
        sub_1001EE134( (uint64_t)"Peripheral connection should be in SMP_STATE_PAIRING_MRAND to send this command, current state is %s.",  v34,  v35,  v36,  v37,  v38,  v39,  v40,  (uint64_t)v33);
        uint64_t v41 = (os_log_s *)sub_100086554(0x43u);
        if (!os_log_type_enabled(v41, OS_LOG_TYPE_ERROR)) {
          return 4823LL;
        }
      }

      else
      {
        if (!*(_BYTE *)(a1 + 70))
        {
          if (!sub_10018550C(v3, 35))
          {
            uint64_t v51 = sub_100185414();
            sub_1001EE134( (uint64_t)"Central connection should be in SMP_STATE_PAIRING_SCONFIRM to send this command, current state is %s.",  v52,  v53,  v54,  v55,  v56,  v57,  v58,  (uint64_t)v51);
            uint64_t v59 = (os_log_s *)sub_100086554(0x43u);
            if (!os_log_type_enabled(v59, OS_LOG_TYPE_ERROR)) {
              return 4823LL;
            }
            goto LABEL_38;
          }

          int v5 = *(unsigned __int8 *)(a1 + 70);
        }

        if (v5 != 1 || sub_10018550C((uint64_t)v4, 36))
        {
LABEL_24:
          uint64_t v23 = sub_100184F74(*v4, &v62, 0x11uLL, 1);
          if ((_DWORD)v23)
          {
            sub_100184BB0((char *)v4, v23, 1);
          }

          else
          {
            if (*(_BYTE *)(a1 + 70)) {
              char v32 = 37;
            }
            else {
              char v32 = 36;
            }
            sub_100185420((uint64_t)v4, v32);
          }

          return v23;
        }

        uint64_t v42 = sub_100185414();
        sub_1001EE134( (uint64_t)"Peripheral connection should be in SMP_STATE_PAIRING_MRAND to send this command, current state is %s.",  v43,  v44,  v45,  v46,  v47,  v48,  v49,  (uint64_t)v42);
        uint64_t v50 = (os_log_s *)sub_100086554(0x43u);
        if (!os_log_type_enabled(v50, OS_LOG_TYPE_ERROR)) {
          return 4823LL;
        }
      }
    }

    else
    {
      sub_1001EE134((uint64_t)"This device is not in a pairing state.", v24, v25, v26, v27, v28, v29, v30, v61);
      uint64_t v31 = (os_log_s *)sub_100086554(0x43u);
      if (!os_log_type_enabled(v31, OS_LOG_TYPE_ERROR)) {
        return 4823LL;
      }
    }

void sub_1001D4D70(char *a1)
{
  else {
    char v1 = -9;
  }
  if ((v1 & a1[74] & 0xF7) == (v1 & a1[75] & 0xF7)
    || (v1 & a1[74]) == 0)
  {
    if (*(_BYTE *)(*(void *)a1 + 70LL))
    {
      sub_100185420((uint64_t)a1, 65);
    }

    else
    {
      sub_100185420((uint64_t)a1, 67);
      sub_1001D20C8((uint64_t)a1);
      sub_1001D223C((uint64_t)a1);
    }

    sub_100184BB0(a1, 0LL, 1);
  }

uint64_t sub_1001D4E20( uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  if ((_BYTE)qword_1008EDB58 || (qword_1008EDB58 & 0x100) != 0) {
    return 118LL;
  }
  if (a1 < 0x28)
  {
    uint64_t v17 = sub_1001214B4(189, (uint64_t)sub_1001D4F34, a3, a4, a5, a6, a7, a8, a1);
    if ((_DWORD)v17)
    {
      if (sub_1000A86F0())
      {
        sub_1001EE134((uint64_t)"Failed to start RX LE test %!", v19, v20, v21, v22, v23, v24, v25, v17);
        uint64_t v26 = (os_log_s *)sub_100086554(0x42u);
        if (os_log_type_enabled(v26, OS_LOG_TYPE_ERROR)) {
          sub_100657858();
        }
      }
    }

    else
    {
      BYTE2(qword_1008EDB58) = a1;
      LOBYTE(qword_1008EDB58) = 1;
    }
  }

  else
  {
    if (sub_1000A86F0())
    {
      sub_1001EE134((uint64_t)"Invalid test frequency %d", v9, v10, v11, v12, v13, v14, v15, a1);
      uint64_t v16 = (os_log_s *)sub_100086554(0x42u);
      if (os_log_type_enabled(v16, OS_LOG_TYPE_ERROR)) {
        sub_100657858();
      }
    }

    return 101LL;
  }

  return v17;
}

void sub_1001D4F34(uint64_t a1)
{
  if ((_DWORD)a1)
  {
    if (sub_1000A86F0())
    {
      sub_1001EE134((uint64_t)"Could not start RX test %!", v2, v3, v4, v5, v6, v7, v8, a1);
      uint64_t v9 = (os_log_s *)sub_100086554(0x42u);
      if (os_log_type_enabled(v9, OS_LOG_TYPE_ERROR)) {
        sub_100657858();
      }
    }
  }

  else
  {
    BYTE1(qword_1008EDB58) |= 1u;
  }

  LOBYTE(qword_1008EDB58) = 0;
}

uint64_t sub_1001D4FB8( uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  if ((_BYTE)qword_1008EDB58 || (qword_1008EDB58 & 0x200) != 0) {
    return 118LL;
  }
  if (a1 >= 0x28)
  {
    sub_1001EE134((uint64_t)"Invalid test frequency %d", v9, v10, v11, v12, v13, v14, v15, a1);
    uint64_t v16 = (os_log_s *)sub_100086554(0x42u);
    if (!os_log_type_enabled(v16, OS_LOG_TYPE_ERROR)) {
      return 101LL;
    }
    goto LABEL_16;
  }

  if (a2 >= 0x26)
  {
    sub_1001EE134((uint64_t)"Invalid payload length %d", v20, v21, v22, v23, v24, v25, v26, a2);
    uint64_t v27 = (os_log_s *)sub_100086554(0x42u);
    if (!os_log_type_enabled(v27, OS_LOG_TYPE_ERROR)) {
      return 101LL;
    }
    goto LABEL_16;
  }

  if (a3 >= 8)
  {
    sub_1001EE134((uint64_t)"Invalid payload type %d", v29, v30, v31, v32, v33, v34, v35, a3);
    uint64_t v36 = (os_log_s *)sub_100086554(0x42u);
    if (!os_log_type_enabled(v36, OS_LOG_TYPE_ERROR)) {
      return 101LL;
    }
LABEL_16:
    sub_100657858();
    return 101LL;
  }

  uint64_t v17 = sub_1001214B4(190, (uint64_t)sub_1001D5188, a3, a4, a5, a6, a7, a8, a1);
  if ((_DWORD)v17)
  {
    if (sub_1000A86F0())
    {
      sub_1001EE134((uint64_t)"Failed to start TX LE test %!", v37, v38, v39, v40, v41, v42, v43, v17);
      uint64_t v44 = (os_log_s *)sub_100086554(0x42u);
      if (os_log_type_enabled(v44, OS_LOG_TYPE_ERROR)) {
        sub_100657858();
      }
    }
  }

  else
  {
    BYTE3(qword_1008EDB58) = a1;
    BYTE4(qword_1008EDB58) = a2;
    BYTE5(qword_1008EDB58) = a3;
    LOBYTE(qword_1008EDB58) = 1;
  }

  return v17;
}

void sub_1001D5188(uint64_t a1)
{
  if ((_DWORD)a1)
  {
    if (sub_1000A86F0())
    {
      sub_1001EE134((uint64_t)"Could not start TX test %!", v2, v3, v4, v5, v6, v7, v8, a1);
      uint64_t v9 = (os_log_s *)sub_100086554(0x42u);
      if (os_log_type_enabled(v9, OS_LOG_TYPE_ERROR)) {
        sub_100657858();
      }
    }
  }

  else
  {
    BYTE1(qword_1008EDB58) |= 2u;
  }

  LOBYTE(qword_1008EDB58) = 0;
}

uint64_t sub_1001D520C( void *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  if (BYTE1(qword_1008EDB58))
  {
    uint64_t v9 = sub_1001214B4(191, (uint64_t)sub_1001D52F8, a3, a4, a5, a6, a7, a8, v27);
    if ((_DWORD)v9)
    {
      if (sub_1000A86F0())
      {
        sub_1001EE134((uint64_t)"Failed to stop LE test %!", v10, v11, v12, v13, v14, v15, v16, v9);
        uint64_t v17 = (os_log_s *)sub_100086554(0x42u);
        if (os_log_type_enabled(v17, OS_LOG_TYPE_ERROR)) {
          sub_100657858();
        }
      }
    }

    else
    {
      LOBYTE(qword_1008EDB58) = 1;
      off_1008EDB60 = a1;
    }
  }

  else
  {
    if (sub_1000A86F0())
    {
      sub_1001EE134((uint64_t)"No test started", v18, v19, v20, v21, v22, v23, v24, v27);
      uint64_t v25 = (os_log_s *)sub_100086554(0x42u);
      if (os_log_type_enabled(v25, OS_LOG_TYPE_ERROR)) {
        sub_100657858();
      }
    }

    return 114LL;
  }

  return v9;
}

void sub_1001D52F8(uint64_t a1, uint64_t a2)
{
  uint64_t v4 = (void (*)(uint64_t, uint64_t))off_1008EDB60;
  if ((_DWORD)a1)
  {
    if (sub_1000A86F0())
    {
      sub_1001EE134((uint64_t)"Could not stop the test %!", v5, v6, v7, v8, v9, v10, v11, a1);
      uint64_t v12 = (os_log_s *)sub_100086554(0x42u);
      if (os_log_type_enabled(v12, OS_LOG_TYPE_ERROR)) {
        sub_100657858();
      }
    }
  }

  else
  {
    qword_1008EDB58 = 0LL;
    off_1008EDB60 = 0LL;
  }

  LOBYTE(qword_1008EDB58) = 0;
  if (v4) {
    v4(a1, a2);
  }
}

void sub_1001D539C()
{
  qword_1008EDB58 = 0LL;
  off_1008EDB60 = 0LL;
}

uint64_t sub_1001D53AC(uint64_t a1)
{
  __int16 v1 = word_1008EDB68;
  uint64_t v2 = (unsigned __int16)word_1008EDB68;
  if (word_1008EDB68)
  {
    if (word_1008EDB68 == 8)
    {
      if (sub_1000A86F0())
      {
        sub_1001EE134((uint64_t)"Can't add anymore callbacks.", v3, v4, v5, v6, v7, v8, v9, v14);
        uint64_t v10 = (os_log_s *)sub_100086554(0x42u);
        if (os_log_type_enabled(v10, OS_LOG_TYPE_ERROR)) {
          sub_100657858();
        }
      }

      return 4150LL;
    }

    else
    {
      unsigned __int8 v12 = 0;
      while (qword_1008EDB70[v12] != a1)
      {
        if ((unsigned __int16)word_1008EDB68 <= ++v12)
        {
          uint64_t v2 = v12;
          goto LABEL_11;
        }
      }

      return 0LL;
    }
  }

  else
  {
LABEL_11:
    uint64_t v11 = 0LL;
    qword_1008EDB70[v2] = a1;
    word_1008EDB68 = v1 + 1;
  }

  return v11;
}

uint64_t sub_1001D5474(unsigned __int8 *a1)
{
  if (!*((void *)&xmmword_1008EDBB0 + 1)) {
    return 118LL;
  }
  if ((unsigned __int16)xmmword_1008EDBB0 <= BYTE2(xmmword_1008EDBB0))
  {
    if (sub_1000A86F0())
    {
      sub_1001EE134( (uint64_t)"No room in filter accept list %d (+%d pending)/%d.",  v3,  v4,  v5,  v6,  v7,  v8,  v9,  BYTE2(xmmword_1008EDBB0));
      uint64_t v10 = (os_log_s *)sub_100086554(0x42u);
      if (os_log_type_enabled(v10, OS_LOG_TYPE_ERROR)) {
        sub_100657858();
      }
    }

    return 104LL;
  }

  else if (sub_1001D5614(a1))
  {
    return 4152LL;
  }

  else
  {
    unsigned __int8 v12 = sub_1000B17F4(0x10uLL);
    if (v12)
    {
      uint64_t v19 = v12;
      uint64_t v20 = sub_1001214B4(177, (uint64_t)sub_1001D5698, v13, v14, v15, v16, v17, v18, *a1);
      if ((_DWORD)v20)
      {
        uint64_t v2 = v20;
        if (sub_1000A86F0())
        {
          sub_1001EE134((uint64_t)"Could not add device to filter accept list %!", v21, v22, v23, v24, v25, v26, v27, v2);
          uint64_t v28 = (os_log_s *)sub_100086554(0x42u);
          if (os_log_type_enabled(v28, OS_LOG_TYPE_ERROR)) {
            sub_100657858();
          }
        }

        sub_1000B1838(v19);
      }

      else
      {
        int v29 = *(_DWORD *)a1;
        __int16 v30 = *((_WORD *)a1 + 2);
        *((_BYTE *)v19 + 6) = a1[6];
        *((_WORD *)v19 + 2) = v30;
        *uint64_t v19 = v29;
        *((void *)v19 + 1) = 0LL;
        if (qword_1008EDBC8)
        {
          *(void *)(qword_1008EDBC8 + 8) = v19;
          qword_1008EDBC8 = (uint64_t)v19;
        }

        uint64_t v2 = 0LL;
        if (!qword_1008EDBC0)
        {
          qword_1008EDBC0 = (uint64_t)v19;
          qword_1008EDBC8 = (uint64_t)v19;
        }
      }
    }

    else
    {
      return 106LL;
    }
  }

  return v2;
}

BOOL sub_1001D5614(_DWORD *a1)
{
  if (!BYTE2(xmmword_1008EDBB0)) {
    return 0LL;
  }
  if (**((_DWORD **)&xmmword_1008EDBB0 + 1) == *a1
    && *(_DWORD *)(*((void *)&xmmword_1008EDBB0 + 1) + 3LL) == *(_DWORD *)((char *)a1 + 3))
  {
    return 1LL;
  }

  uint64_t v2 = (_DWORD *)(*((void *)&xmmword_1008EDBB0 + 1) + 7LL);
  uint64_t v3 = 1LL;
  do
  {
    unint64_t v4 = v3;
    if (BYTE2(xmmword_1008EDBB0) == v3) {
      break;
    }
    BOOL v5 = *v2 == *a1 && *(_DWORD *)((char *)v2 + 3) == *(_DWORD *)((char *)a1 + 3);
    ++v3;
    uint64_t v2 = (_DWORD *)((char *)v2 + 7);
  }

  while (!v5);
  return v4 < BYTE2(xmmword_1008EDBB0);
}

uint64_t sub_1001D5698(uint64_t a1)
{
  if ((_DWORD)a1)
  {
    if (sub_1000A86F0())
    {
      sub_1001EE134((uint64_t)"Error adding device to filter accept list %!", v19, v20, v21, v22, v23, v24, v25, a1);
      uint64_t v26 = (os_log_s *)sub_100086554(0x42u);
      if (os_log_type_enabled(v26, OS_LOG_TYPE_ERROR)) {
        sub_100657F08();
      }
    }

    sub_1000B034C(a1, "Filter Accept List add error");
  }

  uint64_t v1 = qword_1008EDBC0;
  if (qword_1008EDBC0 || (sub_1001EE2A0(), (uint64_t v1 = qword_1008EDBC0) != 0))
  {
    char v2 = BYTE2(xmmword_1008EDBB0);
    uint64_t v3 = *((void *)&xmmword_1008EDBB0 + 1) - BYTE2(xmmword_1008EDBB0) + 8LL * BYTE2(xmmword_1008EDBB0);
    int v4 = *(_DWORD *)v1;
    __int16 v5 = *(_WORD *)(v1 + 4);
    *(_BYTE *)(v3 + 6) = *(_BYTE *)(v1 + 6);
    *(_WORD *)(v3 + 4) = v5;
    *(_DWORD *)uint64_t v3 = v4;
    BYTE2(xmmword_1008EDBB0) = v2 + 1;
  }

  unsigned int v6 = (unsigned __int16)word_1008EDB68;
  if (word_1008EDB68)
  {
    unint64_t v7 = 0LL;
    uint64_t v8 = qword_1008EDBC0;
    do
    {
      uint64_t v9 = *(void (**)(uint64_t, void))qword_1008EDB70[v7];
      if (v9) {
        BOOL v10 = v8 == 0;
      }
      else {
        BOOL v10 = 1;
      }
      if (!v10)
      {
        v9(v8, 0LL);
        uint64_t v8 = qword_1008EDBC0;
        unsigned int v6 = (unsigned __int16)word_1008EDB68;
      }

      ++v7;
    }

    while (v7 < v6);
  }

  sub_1001D5D40();
  sub_1001ABEC8(1, v11, v12, v13, v14, v15, v16, v17);
  sub_10019D9F8(1);
  return sub_1001C6890(1);
}

uint64_t sub_1001D57D0(unsigned __int8 *a1)
{
  if (!*((void *)&xmmword_1008EDBB0 + 1)) {
    return 118LL;
  }
  if (!sub_1001D5614(a1)) {
    return 4151LL;
  }
  char v2 = sub_1000B17F4(0x10uLL);
  if (!v2) {
    return 106LL;
  }
  uint64_t v9 = v2;
  uint64_t v10 = sub_1001214B4(178, (uint64_t)sub_1001D5904, v3, v4, v5, v6, v7, v8, *a1);
  if ((_DWORD)v10)
  {
    uint64_t v11 = v10;
    if (sub_1000A86F0())
    {
      sub_1001EE134( (uint64_t)"Could not remove device from filter accept list %!",  v12,  v13,  v14,  v15,  v16,  v17,  v18,  v11);
      uint64_t v19 = (os_log_s *)sub_100086554(0x42u);
      if (os_log_type_enabled(v19, OS_LOG_TYPE_ERROR)) {
        sub_100657858();
      }
    }

    sub_1000B1838(v9);
  }

  else
  {
    int v20 = *(_DWORD *)a1;
    __int16 v21 = *((_WORD *)a1 + 2);
    *((_BYTE *)v9 + 6) = a1[6];
    *((_WORD *)v9 + 2) = v21;
    *uint64_t v9 = v20;
    *((void *)v9 + 1) = 0LL;
    if (qword_1008EDBC8)
    {
      *(void *)(qword_1008EDBC8 + 8) = v9;
      qword_1008EDBC8 = (uint64_t)v9;
    }

    uint64_t v11 = 0LL;
    if (!qword_1008EDBC0)
    {
      qword_1008EDBC0 = (uint64_t)v9;
      qword_1008EDBC8 = (uint64_t)v9;
    }
  }

  return v11;
}

uint64_t sub_1001D5904(uint64_t a1)
{
  if ((_DWORD)a1)
  {
    if (sub_1000A86F0())
    {
      sub_1001EE134((uint64_t)"Error removing device from filter accept list %!", v31, v32, v33, v34, v35, v36, v37, a1);
      uint64_t v38 = (os_log_s *)sub_100086554(0x42u);
      if (os_log_type_enabled(v38, OS_LOG_TYPE_ERROR)) {
        sub_100657F08();
      }
    }

    sub_1000B034C(a1, "Filter Accept List remove error");
  }

  if (!qword_1008EDBC0) {
    sub_1001EE2A0();
  }
  if (BYTE2(xmmword_1008EDBB0))
  {
    uint64_t v1 = 0LL;
    uint64_t v2 = *((void *)&xmmword_1008EDBB0 + 1);
    while (1)
    {
      uint64_t v3 = *((void *)&xmmword_1008EDBB0 + 1) + v1;
      if (*(_DWORD *)(*((void *)&xmmword_1008EDBB0 + 1) + v1) == *(_DWORD *)qword_1008EDBC0
        && *(_DWORD *)(*((void *)&xmmword_1008EDBB0 + 1) + v1 + 3) == *(_DWORD *)(qword_1008EDBC0 + 3))
      {
        break;
      }

      v1 += 7LL;
      if (7LL * BYTE2(xmmword_1008EDBB0) == v1) {
        goto LABEL_11;
      }
    }

    unsigned __int8 v13 = --BYTE2(xmmword_1008EDBB0);
    if (7 * BYTE2(xmmword_1008EDBB0) != (_DWORD)v1)
    {
      uint64_t v14 = *((void *)&xmmword_1008EDBB0 + 1) - BYTE2(xmmword_1008EDBB0) + 8LL * BYTE2(xmmword_1008EDBB0);
      int v15 = *(_DWORD *)v14;
      __int16 v16 = *(_WORD *)(v14 + 4);
      *(_BYTE *)(v3 + 6) = *(_BYTE *)(v14 + 6);
      *(_WORD *)(v3 + 4) = v16;
      *(_DWORD *)uint64_t v3 = v15;
      uint64_t v2 = *((void *)&xmmword_1008EDBB0 + 1);
      unsigned __int8 v13 = BYTE2(xmmword_1008EDBB0);
    }

    uint64_t v17 = (_DWORD *)(v2 - v13 + 8LL * v13);
    *(_DWORD *)((char *)v17 + 3) = 0;
    *uint64_t v17 = 0;
  }

  else
  {
LABEL_11:
    if (sub_1000A86F0())
    {
      sub_1001EE134((uint64_t)"Device is not in the list anymore", v5, v6, v7, v8, v9, v10, v11, v39);
      uint64_t v12 = (os_log_s *)sub_100086554(0x42u);
      if (os_log_type_enabled(v12, OS_LOG_TYPE_ERROR)) {
        sub_100657858();
      }
    }
  }

  unsigned int v18 = (unsigned __int16)word_1008EDB68;
  if (word_1008EDB68)
  {
    unint64_t v19 = 0LL;
    uint64_t v20 = qword_1008EDBC0;
    do
    {
      __int16 v21 = *(void (**)(uint64_t, void))(qword_1008EDB70[v19] + 8LL);
      if (v21) {
        BOOL v22 = v20 == 0;
      }
      else {
        BOOL v22 = 1;
      }
      if (!v22)
      {
        v21(v20, 0LL);
        uint64_t v20 = qword_1008EDBC0;
        unsigned int v18 = (unsigned __int16)word_1008EDB68;
      }

      ++v19;
    }

    while (v19 < v18);
  }

  sub_1001D5D40();
  sub_1001ABEC8(1, v23, v24, v25, v26, v27, v28, v29);
  sub_10019D9F8(1);
  return sub_1001C6890(1);
}

uint64_t sub_1001D5AEC( uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  if (!*((void *)&xmmword_1008EDBB0 + 1)) {
    return 118LL;
  }
  uint64_t v8 = sub_1001214B4(176, (uint64_t)sub_1001D5B7C, a3, a4, a5, a6, a7, a8, v18);
  if ((_DWORD)v8)
  {
    if (sub_1000A86F0())
    {
      sub_1001EE134((uint64_t)"Could not remove device from filter accept list %!", v9, v10, v11, v12, v13, v14, v15, v8);
      __int16 v16 = (os_log_s *)sub_100086554(0x42u);
      if (os_log_type_enabled(v16, OS_LOG_TYPE_ERROR)) {
        sub_100657858();
      }
    }
  }

  return v8;
}

uint64_t sub_1001D5B7C(uint64_t a1)
{
  if ((_DWORD)a1)
  {
    if (sub_1000A86F0())
    {
      sub_1001EE134((uint64_t)"Error clearing filter accept list %!", v9, v10, v11, v12, v13, v14, v15, a1);
      __int16 v16 = (os_log_s *)sub_100086554(0x42u);
      if (os_log_type_enabled(v16, OS_LOG_TYPE_ERROR)) {
        sub_100657F08();
      }
    }

    sub_1000B034C(a1, "Filter Accept List clear error");
  }

  bzero(*((void **)&xmmword_1008EDBB0 + 1), 7LL * (unsigned __int16)xmmword_1008EDBB0);
  BYTE2(xmmword_1008EDBB0) = 0;
  sub_1001ABEC8(1, v1, v2, v3, v4, v5, v6, v7);
  sub_10019D9F8(1);
  return sub_1001C6890(1);
}

uint64_t sub_1001D5C2C()
{
  return (unsigned __int16)xmmword_1008EDBB0;
}

uint64_t sub_1001D5C38(_DWORD *a1)
{
  *a1 = BYTE2(xmmword_1008EDBB0);
  return *((void *)&xmmword_1008EDBB0 + 1);
}

uint64_t sub_1001D5C50(int *a1)
{
  if (sub_1001D5614(a1)) {
    return 4152LL;
  }
  uint64_t result = 0LL;
  char v3 = BYTE2(xmmword_1008EDBB0);
  uint64_t v4 = *((void *)&xmmword_1008EDBB0 + 1) - BYTE2(xmmword_1008EDBB0) + 8LL * BYTE2(xmmword_1008EDBB0);
  int v5 = *a1;
  __int16 v6 = *((_WORD *)a1 + 2);
  *(_BYTE *)(v4 + 6) = *((_BYTE *)a1 + 6);
  *(_WORD *)(v4 + 4) = v6;
  *(_DWORD *)uint64_t v4 = v5;
  BYTE2(xmmword_1008EDBB0) = v3 + 1;
  return result;
}

void *sub_1001D5CB8(unsigned int a1)
{
  LOWORD(xmmword_1008EDBB0) = a1;
  if (*((void *)&xmmword_1008EDBB0 + 1)) {
    sub_1000B1838(*((void **)&xmmword_1008EDBB0 + 1));
  }
  uint64_t result = sub_1000B17F4(7LL * a1);
  *((void *)&xmmword_1008EDBB0 + 1) = result;
  BYTE2(xmmword_1008EDBB0) = 0;
  qword_1008EDBC8 = 0LL;
  qword_1008EDBC0 = 0LL;
  return result;
}

double sub_1001D5D10()
{
  if (*((void *)&xmmword_1008EDBB0 + 1)) {
    sub_1000B1838(*((void **)&xmmword_1008EDBB0 + 1));
  }
  double result = 0.0;
  xmmword_1008EDBB0 = 0u;
  *(_OWORD *)&qword_1008EDBC0 = 0u;
  return result;
}

void sub_1001D5D40()
{
  if (qword_1008EDBC0)
  {
    uint64_t v0 = *(void *)(qword_1008EDBC0 + 8);
    sub_1000B1838((void *)qword_1008EDBC0);
    qword_1008EDBC0 = v0;
    if (!v0) {
      qword_1008EDBC8 = 0LL;
    }
  }

  else
  {
    sub_1001EE2A0();
  }

uint64_t sub_1001D5D88(uint64_t a1)
{
  if (qword_1008EDBD0) {
    return 119LL;
  }
  uint64_t v4 = sub_1000B17F4(0x18uLL);
  qword_1008EDBD0 = (uint64_t)v4;
  if (!v4) {
    return 106LL;
  }
  uint64_t v1 = sub_1001732EC(0x2Au, 2, 10, 0xAu, v4, (uint64_t)sub_1001D5E64);
  if ((_DWORD)v1)
  {
    sub_1000B1838((void *)qword_1008EDBD0);
    qword_1008EDBD0 = 0LL;
    return v1;
  }

  if (!sub_1001732EC(0x2Bu, 2, 10, 0xAu, (void *)(qword_1008EDBD0 + 8), (uint64_t)sub_1001D6130))
  {
    uint64_t v1 = 0LL;
    *(void *)(qword_1008EDBD0 + 16) = a1;
    return v1;
  }

  uint64_t v5 = sub_1001734D8(*(void *)qword_1008EDBD0);
  sub_1000B1838((void *)qword_1008EDBD0);
  qword_1008EDBD0 = 0LL;
  return v5;
}

void sub_1001D5E64(__int128 *a1, _BYTE *a2, int a3)
{
  if (!a2)
  {
    uint64_t v24 = "buf";
    goto LABEL_40;
  }

  if (!a3)
  {
    uint64_t v24 = "(length) > 0";
LABEL_40:
    sub_1000E6B88("/Library/Caches/com.apple.xbs/Sources/MobileBluetooth_base/Stack/corestack/le/LEA.c", 425, v24);
  }

  uint64_t v25 = a2;
  __int16 v26 = a3;
  __int16 v27 = a3;
  int v28 = 65537;
  uint64_t v4 = *a2;
  switch(*a2)
  {
    case 1:
      uint64_t v5 = sub_1001D6D54((uint64_t)a1, (uint64_t)&v25);
      goto LABEL_32;
    case 2:
      uint64_t v5 = sub_1001D704C((uint64_t)a1, (uint64_t *)&v25);
      goto LABEL_32;
    case 3:
      uint64_t v5 = sub_1001D7268((uint64_t)a1, (uint64_t *)&v25);
      goto LABEL_32;
    case 4:
      uint64_t v5 = sub_1001D74B0((uint64_t)a1, (uint64_t)&v25);
      goto LABEL_32;
    case 5:
      uint64_t v5 = sub_1001D75B4((uint64_t)a1, (uint64_t *)&v25);
      goto LABEL_32;
    case 6:
      __int16 v6 = *(void (**)(__int128 *))(*(void *)(qword_1008EDBD0 + 16) + 40LL);
      if (v6) {
        goto LABEL_24;
      }
      uint64_t v7 = 3LL;
      goto LABEL_33;
    case 7:
      uint64_t v5 = sub_1001D7720((uint64_t)a1, (uint64_t)&v25);
      goto LABEL_32;
    case 8:
      sub_1001D77B0((uint64_t)a1, (uint64_t *)&v25);
      return;
    case 9:
      __int16 v6 = *(void (**)(__int128 *))(*(void *)(qword_1008EDBD0 + 16) + 64LL);
LABEL_24:
      v6(a1);
      return;
    case 0xA:
      uint64_t v5 = sub_1001D7900((uint64_t)a1, (uint64_t *)&v25);
      goto LABEL_32;
    case 0xC:
      uint64_t v5 = sub_1001D79F4((uint64_t)a1, (uint64_t *)&v25);
      goto LABEL_32;
    case 0xD:
      (*(void (**)(__int128 *))(*(void *)(qword_1008EDBD0 + 16) + 88LL))(a1);
      return;
    case 0xE:
      uint64_t v5 = sub_1001D7B4C((uint64_t)a1, (uint64_t *)&v25);
      goto LABEL_32;
    case 0xF:
      uint64_t v5 = sub_1001D7C44((uint64_t)a1, (uint64_t *)&v25);
      goto LABEL_32;
    case 0x10:
      uint64_t v5 = sub_1001D7DA4((uint64_t)a1, (uint64_t *)&v25);
      goto LABEL_32;
    case 0x11:
      uint64_t v5 = sub_1001D7F40((uint64_t)a1, (uint64_t *)&v25);
      goto LABEL_32;
    case 0x12:
      uint64_t v5 = sub_1001D8038((uint64_t)a1, (uint64_t *)&v25);
      goto LABEL_32;
    case 0x13:
      uint64_t v5 = sub_1001D8294((uint64_t)a1, (uint64_t)&v25);
      goto LABEL_32;
    case 0x14:
      uint64_t v5 = sub_1001D848C((uint64_t)a1, (uint64_t)&v25);
      goto LABEL_32;
    case 0x15:
      uint64_t v5 = sub_1001D8684((uint64_t)a1, (uint64_t)&v25);
      goto LABEL_32;
    case 0x16:
      uint64_t v5 = sub_1001D8830((uint64_t)a1, (uint64_t *)&v25);
LABEL_32:
      uint64_t v7 = v5;
      if ((_DWORD)v5) {
        goto LABEL_33;
      }
      return;
    default:
      if (sub_1000A86F0())
      {
        sub_1001EE134((uint64_t)"Unhandled opcode: %u", v8, v9, v10, v11, v12, v13, v14, v4);
        uint64_t v15 = (os_log_s *)sub_100086554(0x42u);
        if (os_log_type_enabled(v15, OS_LOG_TYPE_ERROR)) {
          sub_100657858();
        }
      }

      uint64_t v7 = 1LL;
LABEL_33:
      if (sub_1000A86F0())
      {
        sub_1001EE134((uint64_t)"Sending error %u", v16, v17, v18, v19, v20, v21, v22, v7);
        uint64_t v23 = (os_log_s *)sub_100086554(0x42u);
        if (os_log_type_enabled(v23, OS_LOG_TYPE_ERROR)) {
          sub_100657858();
        }
      }

      v29[0] = v4;
      v29[1] = v7;
      v29[2] = 0;
      sub_1001D6234(a1, 8u, v29, 3uLL);
      return;
  }

uint64_t sub_1001D6130()
{
  uint64_t v0 = *(uint64_t (**)(void))(*(void *)(qword_1008EDBD0 + 16) + 96LL);
  if (v0) {
    return v0();
  }
  return result;
}

uint64_t sub_1001D614C()
{
  if (!qword_1008EDBD0) {
    return 121LL;
  }
  uint64_t result = sub_1001734D8(*(void *)(qword_1008EDBD0 + 8));
  if (!(_DWORD)result)
  {
    uint64_t result = sub_1001734D8(*(void *)qword_1008EDBD0);
    if (!(_DWORD)result)
    {
      sub_1000B1838((void *)qword_1008EDBD0);
      uint64_t result = 0LL;
      qword_1008EDBD0 = 0LL;
    }
  }

  return result;
}

uint64_t sub_1001D61A4(__int128 *a1, __int16 a2, __int16 a3, __int16 a4, __int16 a5)
{
  int v6 = 1346454860;
  __int16 v7 = a2;
  __int16 v8 = a3;
  __int16 v9 = a4;
  __int16 v10 = a5;
  return sub_1001D6234(a1, 1u, (char *)&v6, 0xCuLL);
}

uint64_t sub_1001D6234(__int128 *a1, unsigned __int8 a2, char *a3, size_t a4)
{
  unsigned __int8 v21 = a2;
  if (!a1)
  {
    uint64_t v9 = 1310LL;
    goto LABEL_10;
  }

  memset(&v20[1], 0, 96);
  if (a3) {
    unsigned int v7 = 2;
  }
  else {
    unsigned int v7 = 1;
  }
  v20[0] = 0uLL;
  uint64_t v8 = sub_1001EF520((uint64_t)v20, v7);
  if ((_DWORD)v8)
  {
    uint64_t v9 = v8;
LABEL_10:
    if (sub_1000A86F0())
    {
      sub_1001EE134((uint64_t)"Failed to send PDU %u: %!", v11, v12, v13, v14, v15, v16, v17, v21);
      uint64_t v18 = (os_log_s *)sub_100086554(0x42u);
      if (os_log_type_enabled(v18, OS_LOG_TYPE_ERROR)) {
        sub_100657858();
      }
    }

    return v9;
  }

  uint64_t v10 = sub_1001EFB10((unsigned __int8 *)v20, (char *)&v21, 1uLL, 0);
  if ((_DWORD)v10)
  {
    uint64_t v9 = v10;
    sub_1001EF5E4((uint64_t)v20);
    goto LABEL_10;
  }

  sub_1001EF5E4((uint64_t)v20);
  uint64_t result = 0LL;
  if ((_DWORD)v9 && (_DWORD)v9 != 412) {
    goto LABEL_10;
  }
  return result;
}

uint64_t sub_1001D6374(__int128 *a1, char a2, char a3, char a4, char a5)
{
  v6[0] = a2;
  v6[1] = a3;
  void v6[2] = a4;
  v6[3] = a5;
  return sub_1001D6234(a1, 3u, v6, 4uLL);
}

uint64_t sub_1001D63AC(uint64_t a1, int a2, int a3, __int16 a4, char a5)
{
  int v9 = a4;
  BYTE1(v9) = HIBYTE(a4);
  BYTE2(v9) = a3 == 2;
  *(_WORD *)(a1 + 127) = 257;
  *(_BYTE *)(a1 + 129) = a5;
  if (a2) {
    size_t v6 = 4LL;
  }
  else {
    size_t v6 = 2LL;
  }
  uint64_t v7 = sub_1001D6234((__int128 *)a1, 5u, (char *)&v9, v6);
  if (!(_DWORD)v7) {
    sub_1001ACBDC((unsigned __int16 *)a1, 5LL);
  }
  return v7;
}

uint64_t sub_1001D642C(uint64_t a1)
{
  uint64_t v2 = sub_1001D6234((__int128 *)a1, 6u, 0LL, 0LL);
  if (!(_DWORD)v2)
  {
    *(_BYTE *)(a1 + 128) = 0;
    sub_1001ACBDC((unsigned __int16 *)a1, 6LL);
  }

  return v2;
}

uint64_t sub_1001D6474(__int128 *a1, char *a2, unsigned __int8 a3)
{
  return sub_1001D6234(a1, 7u, a2, a3);
}

uint64_t sub_1001D6488(__int128 *a1, char a2, __int16 a3)
{
  char v4 = a2;
  __int16 v5 = a3;
  return sub_1001D6234(a1, 8u, &v4, 3uLL);
}

uint64_t sub_1001D64C0(__int128 *a1, char a2)
{
  char v3 = a2;
  return sub_1001D6234(a1, 0xAu, &v3, 1uLL);
}

uint64_t sub_1001D64EC(__int128 *a1, uint64_t a2, char a3)
{
  *(_DWORD *)&v6[3] = 0;
  *(_DWORD *)size_t v6 = 0;
  sub_1001F0050((uint64_t)v6, a2, 6uLL);
  v6[6] = a3;
  return sub_1001D6234(a1, 0x10u, v6, 7uLL);
}

uint64_t sub_1001D6540(__int128 *a1, uint64_t a2, __int16 a3, uint64_t *a4)
{
  uint64_t v8 = 0LL;
  uint64_t v9 = 0LL;
  sub_1001F0050((uint64_t)&v8, a2, 6uLL);
  HIWORD(v8) = a3;
  uint64_t v9 = *a4;
  return sub_1001D6234(a1, 0x12u, (char *)&v8, 0x10uLL);
}

uint64_t sub_1001D65D0(__int128 *a1, uint64_t a2, _OWORD *a3)
{
  *(_OWORD *)&v6[6] = *a3;
  return sub_1001D6234(a1, 0x13u, v6, 0x16uLL);
}

uint64_t sub_1001D6654(__int128 *a1, uint64_t a2, _OWORD *a3)
{
  *(_OWORD *)&v6[6] = *a3;
  return sub_1001D6234(a1, 0x14u, v6, 0x16uLL);
}

BOOL sub_1001D66D8(uint64_t a1)
{
  unsigned int v2 = 10 - sub_100188560(43);
  if (v2 < a1)
  {
    if (sub_1000A86F0())
    {
      sub_100188560(43);
      sub_1001EE134((uint64_t)"LEA Queue full: request buffers %d, queue-size %d", v3, v4, v5, v6, v7, v8, v9, a1);
      uint64_t v10 = (os_log_s *)sub_100086554(0x42u);
      if (os_log_type_enabled(v10, OS_LOG_TYPE_ERROR)) {
        sub_100657F08();
      }
    }
  }

  sub_100187700();
  return v2 >= a1;
}

uint64_t sub_1001D6778(__int128 *a1, char *a2, size_t a3, char a4, int a5)
{
  char v32 = a4;
  if (a1 && sub_10012D5EC((uint64_t)a1))
  {
    if (a5) {
      int v9 = 412;
    }
    else {
      int v9 = 625;
    }
    else {
      BOOL v10 = 0;
    }
    memset(v31, 0, sizeof(v31));
    uint64_t v19 = sub_1001EF520((uint64_t)v31, 2u);
    if (!(_DWORD)v19)
    {
      uint64_t v19 = sub_1001EFB10((unsigned __int8 *)v31, a2, a3, 2u);
      if (!(_DWORD)v19)
      {
        if (!v10 || (uint64_t v19 = sub_1001EFB10((unsigned __int8 *)v31, &v32, 1uLL, 0), !(_DWORD)v19))
        {
          if (a5) {
            uint64_t v21 = sub_100172A98(0LL, 43LL, a1, (uint64_t)v31, 1);
          }
          else {
            uint64_t v21 = sub_1001358D0(a1, (uint64_t)v31, WORD2(v31[0]));
          }
          uint64_t v19 = v21;
        }
      }

      sub_1001EF5E4((uint64_t)v31);
    }

    if ((_DWORD)v19 != v9)
    {
      if ((_DWORD)v19)
      {
        if (sub_1000A86F0())
        {
          sub_1001EE134((uint64_t)"Failed to send audio: %!", v22, v23, v24, v25, v26, v27, v28, v19);
          uint64_t v29 = (os_log_s *)sub_100086554(0x42u);
          if (os_log_type_enabled(v29, OS_LOG_TYPE_ERROR)) {
            sub_100657858();
          }
        }
      }
    }
  }

  else
  {
    if (sub_1000A86F0())
    {
      sub_1001EE134((uint64_t)"Failed to send audio as handle is invalid", v11, v12, v13, v14, v15, v16, v17, v30);
      uint64_t v18 = (os_log_s *)sub_100086554(0x42u);
      if (os_log_type_enabled(v18, OS_LOG_TYPE_ERROR)) {
        sub_100657858();
      }
    }

    return 1310LL;
  }

  return v19;
}

void sub_1001D6934()
{
}

uint64_t sub_1001D693C(uint64_t a1, unsigned int a2, int a3)
{
  if (!a1) {
    return 1310LL;
  }
  if (a3 == 2) {
    int v3 = 4;
  }
  else {
    int v3 = 2;
  }
  return sub_1001AD740(a1, a2, a2, 0, 300, v3, v3);
}

BOOL sub_1001D696C(unsigned __int16 *a1, int a2, int a3)
{
  if (a3 == 2) {
    int v3 = 4;
  }
  else {
    int v3 = 2;
  }
  return sub_1001AF780(a1, a2, v3, v3);
}

uint64_t sub_1001D6984(uint64_t a1)
{
  if (!a1 || !sub_10012D5EC(a1)) {
    return 1310LL;
  }
  if (*(_DWORD *)(a1 + 132) <= 4u)
  {
    if (sub_1000A86F0())
    {
      sub_1001EE134( (uint64_t)"Disconnecting LEA device before it is ready, tell the upper layer we failed",  v2,  v3,  v4,  v5,  v6,  v7,  v8,  *(uint64_t *)v11);
      int v9 = (os_log_s *)sub_100086554(0x42u);
      if (os_log_type_enabled(v9, OS_LOG_TYPE_DEFAULT))
      {
        *(_DWORD *)uint64_t v11 = 136446210;
        *(void *)&v11[4] = sub_1001EDDCC();
        _os_log_impl((void *)&_mh_execute_header, v9, OS_LOG_TYPE_DEFAULT, " %{public}s", v11, 0xCu);
      }
    }

    *(_DWORD *)(a1 + 132) = 6;
    *(_DWORD *)(a1 + 140) = 5300;
  }

  return sub_1001ABA40(a1);
}

uint64_t sub_1001D6A7C(uint64_t a1)
{
  uint64_t result = sub_1001C8ECC(a1);
  if ((_DWORD)result) {
    return sub_1001C8D80(a1);
  }
  return result;
}

uint64_t sub_1001D6AB0(uint64_t a1)
{
  if (!a1 || !sub_10012D5EC(a1)) {
    return 1310LL;
  }
  int v2 = *(_DWORD *)(a1 + 148);
  if (v2 == 2)
  {
    uint64_t v3 = 60LL;
  }

  else if (v2 == 1)
  {
    uint64_t v3 = 40LL;
  }

  else
  {
    uint64_t v3 = 0LL;
  }

  unsigned int v5 = *(unsigned __int16 *)(a1 + 104);
  if (v5 == (_DWORD)v3 && *(unsigned __int16 *)(a1 + 108) == (_DWORD)v3
    || v5 <= 0x1B && *(unsigned __int16 *)(a1 + 108) < 0x1Cu)
  {
    return 0LL;
  }

  if (sub_1000A86F0())
  {
    sub_1001EE134((uint64_t)"LEA set data length %dB %dus", v6, v7, v8, v9, v10, v11, v12, v3);
    uint64_t v13 = (os_log_s *)sub_100086554(0x42u);
    if (os_log_type_enabled(v13, OS_LOG_TYPE_DEFAULT))
    {
      *(_DWORD *)__int128 buf = 136446210;
      uint64_t v15 = sub_1001EDDCC();
      _os_log_impl((void *)&_mh_execute_header, v13, OS_LOG_TYPE_DEFAULT, " %{public}s", buf, 0xCu);
    }
  }

  return sub_10018D018(a1);
}

void sub_1001D6C4C(uint64_t a1)
{
  if (sub_1000A86F0())
  {
    sub_1001EE134((uint64_t)"LEA setTxDataLengthExtendedCB %!", v2, v3, v4, v5, v6, v7, v8, a1);
    uint64_t v9 = (os_log_s *)sub_100086554(0x42u);
    if (os_log_type_enabled(v9, OS_LOG_TYPE_DEFAULT))
    {
      *(_DWORD *)__int128 buf = 136446210;
      uint64_t v19 = sub_1001EDDCC();
      _os_log_impl((void *)&_mh_execute_header, v9, OS_LOG_TYPE_DEFAULT, " %{public}s", buf, 0xCu);
    }
  }

  if ((_DWORD)a1 && sub_1000A86F0())
  {
    sub_1001EE134((uint64_t)"Set data length extended error status %!", v10, v11, v12, v13, v14, v15, v16, a1);
    uint64_t v17 = (os_log_s *)sub_100086554(0x42u);
    if (os_log_type_enabled(v17, OS_LOG_TYPE_ERROR)) {
      sub_100657F08();
    }
  }

uint64_t sub_1001D6D54(uint64_t a1, uint64_t a2)
{
  if (*(_BYTE *)(a2 + 14) != 1) {
    sub_1000E6B88( "/Library/Caches/com.apple.xbs/Sources/MobileBluetooth_base/Stack/corestack/le/LEA.c",  48,  "(*bs).__RWFlag == BYTESTREAM_READ");
  }
  if (*(_BYTE *)(a2 + 15))
  {
    sub_1001ED1C4((uint64_t)"/Library/Caches/com.apple.xbs/Sources/MobileBluetooth_base/Stack/corestack/le/LEA.c");
    int v3 = *(unsigned __int8 *)(a2 + 14);
    *(_BYTE *)(a2 + 15) = 1;
    if (v3 != 1) {
      sub_1000E6B88( "/Library/Caches/com.apple.xbs/Sources/MobileBluetooth_base/Stack/corestack/le/LEA.c",  49,  "(*bs).__RWFlag == BYTESTREAM_READ");
    }
    goto LABEL_14;
  }

  uint64_t v4 = *(unsigned __int16 *)(a2 + 12);
  if (*(unsigned __int16 *)(a2 + 10) - (int)v4 <= 3)
  {
    *(_BYTE *)(a2 + 15) = 1;
LABEL_14:
    sub_1001ED1C4((uint64_t)"/Library/Caches/com.apple.xbs/Sources/MobileBluetooth_base/Stack/corestack/le/LEA.c");
    int v14 = *(unsigned __int8 *)(a2 + 14);
    *(_BYTE *)(a2 + 15) = 1;
    if (v14 != 1) {
      sub_1000E6B88( "/Library/Caches/com.apple.xbs/Sources/MobileBluetooth_base/Stack/corestack/le/LEA.c",  50,  "(*bs).__RWFlag == BYTESTREAM_READ");
    }
    goto LABEL_15;
  }

  unsigned int v5 = *(_DWORD *)(*(void *)a2 + v4);
  *(_WORD *)(a2 + 12) = v4 + 4;
  if (*(unsigned __int16 *)(a2 + 10) - (unsigned __int16)(v4 + 4) <= 1)
  {
    *(_BYTE *)(a2 + 15) = 1;
LABEL_15:
    sub_1001ED1C4((uint64_t)"/Library/Caches/com.apple.xbs/Sources/MobileBluetooth_base/Stack/corestack/le/LEA.c");
    int v15 = *(unsigned __int8 *)(a2 + 14);
    *(_BYTE *)(a2 + 15) = 1;
    if (v15 != 1) {
      sub_1000E6B88( "/Library/Caches/com.apple.xbs/Sources/MobileBluetooth_base/Stack/corestack/le/LEA.c",  51,  "(*bs).__RWFlag == BYTESTREAM_READ");
    }
    goto LABEL_16;
  }

  unsigned __int16 v6 = *(_WORD *)(*(void *)a2 + (unsigned __int16)(v4 + 4));
  *(_WORD *)(a2 + 12) = v4 + 6;
  if (*(unsigned __int16 *)(a2 + 10) - (unsigned __int16)(v4 + 6) <= 1)
  {
    *(_BYTE *)(a2 + 15) = 1;
LABEL_16:
    sub_1001ED1C4((uint64_t)"/Library/Caches/com.apple.xbs/Sources/MobileBluetooth_base/Stack/corestack/le/LEA.c");
    int v16 = *(unsigned __int8 *)(a2 + 14);
    *(_BYTE *)(a2 + 15) = 1;
    if (v16 != 1) {
      sub_1000E6B88( "/Library/Caches/com.apple.xbs/Sources/MobileBluetooth_base/Stack/corestack/le/LEA.c",  52,  "(*bs).__RWFlag == BYTESTREAM_READ");
    }
    goto LABEL_17;
  }

  unsigned __int16 v7 = *(_WORD *)(*(void *)a2 + (unsigned __int16)(v4 + 6));
  *(_WORD *)(a2 + 12) = v4 + 8;
  if (*(unsigned __int16 *)(a2 + 10) - (unsigned __int16)(v4 + 8) <= 1)
  {
    *(_BYTE *)(a2 + 15) = 1;
LABEL_17:
    sub_1001ED1C4((uint64_t)"/Library/Caches/com.apple.xbs/Sources/MobileBluetooth_base/Stack/corestack/le/LEA.c");
    goto LABEL_18;
  }

  unsigned __int16 v8 = *(_WORD *)(*(void *)a2 + (unsigned __int16)(v4 + 8));
  *(_WORD *)(a2 + 12) = v4 + 10;
  if (*(unsigned __int16 *)(a2 + 10) - (unsigned __int16)(v4 + 10) <= 1)
  {
LABEL_18:
    *(_BYTE *)(a2 + 15) = 1;
    goto LABEL_19;
  }

  unsigned int v9 = bswap32(v5);
  uint64_t v10 = (unsigned __int8 *)(*(void *)a2 + (unsigned __int16)(v4 + 10));
  int v11 = *v10;
  int v12 = v10[1];
  *(_WORD *)(a2 + 12) = v4 + 12;
  if (v9 == 1279607120 && (unsigned __int16)(v6 - 1) <= 1u)
  {
    (**(void (***)(uint64_t, void, void, void, void))(qword_1008EDBD0 + 16))( a1,  v6,  v7,  v8,  v11 | (v12 << 8));
    return 0LL;
  }

uint64_t sub_1001D704C(uint64_t a1, uint64_t *a2)
{
  if (!*(void *)(*(void *)(qword_1008EDBD0 + 16) + 8LL)) {
    return 3LL;
  }
  if (*((_BYTE *)a2 + 15))
  {
    sub_1001ED1C4((uint64_t)"/Library/Caches/com.apple.xbs/Sources/MobileBluetooth_base/Stack/corestack/le/LEA.c");
    unsigned __int8 v4 = 0;
  }

  else
  {
    unsigned __int8 v4 = *((_BYTE *)a2 + 10) - *((_BYTE *)a2 + 12);
  }

  __chkstk_darwin(a1, v4);
  unsigned __int16 v7 = (char *)&v25 - v6;
  bzero((char *)&v25 - v6, v8);
  if (*((_BYTE *)a2 + 14) != 1) {
    sub_1000E6B88( "/Library/Caches/com.apple.xbs/Sources/MobileBluetooth_base/Stack/corestack/le/LEA.c",  72,  "(*bs).__RWFlag == BYTESTREAM_READ");
  }
  uint64_t v9 = *a2;
  uint64_t v10 = *((unsigned __int16 *)a2 + 6);
  if (*((_BYTE *)a2 + 15))
  {
    sub_1001ED1C4((uint64_t)"/Library/Caches/com.apple.xbs/Sources/MobileBluetooth_base/Stack/corestack/le/LEA.c");
    int v11 = 0;
  }

  else
  {
    int v11 = *((unsigned __int16 *)a2 + 5) - (_DWORD)v10;
  }

  if (v11 >= v4)
  {
    if (v4)
    {
      int v12 = (char *)(v9 + v10);
      uint64_t v13 = v7;
      do
      {
        char v14 = *v12++;
        *v13++ = v14;
      }

      while (v13 < &v7[v4]);
    }

    *((_WORD *)a2 + 6) += v4;
    if (*((_BYTE *)a2 + 15)) {
      BOOL v15 = 1;
    }
    else {
      BOOL v15 = v4 == 0;
    }
    if (!v15)
    {
      (*(void (**)(uint64_t, char *, void))(*(void *)(qword_1008EDBD0 + 16) + 8LL))(a1, v7, v4);
      return 0LL;
    }
  }

  else
  {
    *((_BYTE *)a2 + 15) = 1;
  }

  uint64_t v5 = 2LL;
  if (sub_1000A86F0())
  {
    sub_1001EE134((uint64_t)"Failed to read supported codec list", v16, v17, v18, v19, v20, v21, v22, v25);
    uint64_t v23 = (os_log_s *)sub_100086554(0x42u);
    if (os_log_type_enabled(v23, OS_LOG_TYPE_ERROR)) {
      sub_100657858();
    }
    return 2LL;
  }

  return v5;
}

uint64_t sub_1001D7268(uint64_t a1, uint64_t *a2)
{
  if (!*(void *)(*(void *)(qword_1008EDBD0 + 16) + 16LL)) {
    return 3LL;
  }
  if (*((_BYTE *)a2 + 14) != 1) {
    sub_1000E6B88( "/Library/Caches/com.apple.xbs/Sources/MobileBluetooth_base/Stack/corestack/le/LEA.c",  97,  "(*bs).__RWFlag == BYTESTREAM_READ");
  }
  if (*((_BYTE *)a2 + 15))
  {
    sub_1001ED1C4((uint64_t)"/Library/Caches/com.apple.xbs/Sources/MobileBluetooth_base/Stack/corestack/le/LEA.c");
    int v3 = *((unsigned __int8 *)a2 + 14);
    *((_BYTE *)a2 + 15) = 1;
    if (v3 != 1) {
      sub_1000E6B88( "/Library/Caches/com.apple.xbs/Sources/MobileBluetooth_base/Stack/corestack/le/LEA.c",  98,  "(*bs).__RWFlag == BYTESTREAM_READ");
    }
    goto LABEL_13;
  }

  uint64_t v5 = *((unsigned __int16 *)a2 + 6);
  if (*((unsigned __int16 *)a2 + 5) <= v5)
  {
    *((_BYTE *)a2 + 15) = 1;
LABEL_13:
    sub_1001ED1C4((uint64_t)"/Library/Caches/com.apple.xbs/Sources/MobileBluetooth_base/Stack/corestack/le/LEA.c");
    int v13 = *((unsigned __int8 *)a2 + 14);
    *((_BYTE *)a2 + 15) = 1;
    if (v13 != 1) {
      sub_1000E6B88( "/Library/Caches/com.apple.xbs/Sources/MobileBluetooth_base/Stack/corestack/le/LEA.c",  99,  "(*bs).__RWFlag == BYTESTREAM_READ");
    }
    goto LABEL_14;
  }

  uint64_t v6 = *a2;
  *((_WORD *)a2 + 6) = v5 + 1;
  if (*((unsigned __int16 *)a2 + 5) <= (v5 + 1))
  {
    *((_BYTE *)a2 + 15) = 1;
LABEL_14:
    sub_1001ED1C4((uint64_t)"/Library/Caches/com.apple.xbs/Sources/MobileBluetooth_base/Stack/corestack/le/LEA.c");
    int v14 = *((unsigned __int8 *)a2 + 14);
    *((_BYTE *)a2 + 15) = 1;
    if (v14 != 1) {
      sub_1000E6B88( "/Library/Caches/com.apple.xbs/Sources/MobileBluetooth_base/Stack/corestack/le/LEA.c",  100,  "(*bs).__RWFlag == BYTESTREAM_READ");
    }
    goto LABEL_15;
  }

  uint64_t v7 = *(unsigned __int8 *)(v6 + v5);
  uint64_t v8 = *a2;
  *((_WORD *)a2 + 6) = v5 + 2;
  if (*((unsigned __int16 *)a2 + 5) > (v5 + 2))
  {
    uint64_t v9 = *(unsigned __int8 *)(v8 + v5 + 1);
    uint64_t v10 = *a2;
    *((_WORD *)a2 + 6) = v5 + 3;
    if (*((unsigned __int16 *)a2 + 5) > (v5 + 3))
    {
      uint64_t v11 = *(unsigned __int8 *)(v10 + v5 + 2);
      uint64_t v12 = *a2;
      *((_WORD *)a2 + 6) = v5 + 4;
      (*(void (**)(uint64_t, uint64_t, uint64_t, uint64_t, void))(*(void *)(qword_1008EDBD0 + 16) + 16LL))( a1,  v7,  v9,  v11,  *(unsigned __int8 *)(v12 + v5 + 3));
      return 0LL;
    }

    goto LABEL_16;
  }

  *((_BYTE *)a2 + 15) = 1;
LABEL_15:
  sub_1001ED1C4((uint64_t)"/Library/Caches/com.apple.xbs/Sources/MobileBluetooth_base/Stack/corestack/le/LEA.c");
LABEL_16:
  *((_BYTE *)a2 + 15) = 1;
  uint64_t v4 = 2LL;
  if (sub_1000A86F0())
  {
    sub_1001EE134((uint64_t)"Failed to read select codec", v15, v16, v17, v18, v19, v20, v21, v24);
    uint64_t v22 = (os_log_s *)sub_100086554(0x42u);
    if (os_log_type_enabled(v22, OS_LOG_TYPE_ERROR)) {
      sub_100657858();
    }
    return 2LL;
  }

  return v4;
}

uint64_t sub_1001D74B0(uint64_t a1, uint64_t a2)
{
  uint64_t v2 = *(void (**)(uint64_t, uint64_t))(*(void *)(qword_1008EDBD0 + 16) + 24LL);
  if (!v2) {
    return 3LL;
  }
  if (*(_BYTE *)(a2 + 14) != 1) {
    sub_1000E6B88( "/Library/Caches/com.apple.xbs/Sources/MobileBluetooth_base/Stack/corestack/le/LEA.c",  122,  "(*bs).__RWFlag == BYTESTREAM_READ");
  }
  if (*(_BYTE *)(a2 + 15))
  {
    sub_1001ED1C4((uint64_t)"/Library/Caches/com.apple.xbs/Sources/MobileBluetooth_base/Stack/corestack/le/LEA.c");
  }

  else
  {
    uint64_t v5 = *(unsigned __int16 *)(a2 + 12);
    if (*(unsigned __int16 *)(a2 + 10) - (int)v5 >= 2)
    {
      uint64_t v6 = *(unsigned __int16 *)(*(void *)a2 + v5);
      *(_WORD *)(a2 + 12) = v5 + 2;
      v2(a1, v6);
      return 0LL;
    }
  }

  *(_BYTE *)(a2 + 15) = 1;
  uint64_t v4 = 2LL;
  if (sub_1000A86F0())
  {
    sub_1001EE134((uint64_t)"Failed to read codec ready", v7, v8, v9, v10, v11, v12, v13, v16);
    int v14 = (os_log_s *)sub_100086554(0x42u);
    if (os_log_type_enabled(v14, OS_LOG_TYPE_ERROR)) {
      sub_100657858();
    }
    return 2LL;
  }

  return v4;
}

uint64_t sub_1001D75B4(uint64_t a1, uint64_t *a2)
{
  if (!*(void *)(*(void *)(qword_1008EDBD0 + 16) + 32LL)) {
    return 3LL;
  }
  if (*((_BYTE *)a2 + 14) != 1) {
    sub_1000E6B88( "/Library/Caches/com.apple.xbs/Sources/MobileBluetooth_base/Stack/corestack/le/LEA.c",  145,  "(*bs).__RWFlag == BYTESTREAM_READ");
  }
  if (*((_BYTE *)a2 + 15))
  {
    sub_1001ED1C4((uint64_t)"/Library/Caches/com.apple.xbs/Sources/MobileBluetooth_base/Stack/corestack/le/LEA.c");
  }

  else
  {
    int v5 = *((unsigned __int16 *)a2 + 5);
    uint64_t v6 = *((unsigned __int16 *)a2 + 6);
    if (v5 - (int)v6 >= 2)
    {
      uint64_t v7 = *a2;
      unsigned __int16 v8 = *(_WORD *)(*a2 + v6);
      *((_WORD *)a2 + 6) = v6 + 2;
      if (v5 - (unsigned __int16)(v6 + 2) >= 2)
      {
        unsigned __int16 v9 = *(_WORD *)(v7 + (unsigned __int16)(v6 + 2));
        *((_WORD *)a2 + 6) = v6 + 4;
LABEL_15:
        (*(void (**)(uint64_t, void, void))(*(void *)(qword_1008EDBD0 + 16) + 32LL))(a1, v8, v9);
        return 0LL;
      }

uint64_t sub_1001D7720(uint64_t a1, uint64_t a2)
{
  uint64_t v2 = *(void (**)(uint64_t, uint64_t, void))(*(void *)(qword_1008EDBD0 + 16) + 48LL);
  if (!v2) {
    return 3LL;
  }
  uint64_t v4 = *(unsigned __int16 *)(a2 + 12);
  uint64_t v5 = *(void *)a2 + v4;
  if (*(_BYTE *)(a2 + 15))
  {
    sub_1001ED1C4((uint64_t)"/Library/Caches/com.apple.xbs/Sources/MobileBluetooth_base/Stack/corestack/le/LEA.c");
    unsigned __int16 v6 = 0;
  }

  else
  {
    unsigned __int16 v6 = *(_WORD *)(a2 + 10) - v4;
  }

  v2(a1, v5, v6);
  return 0LL;
}

void sub_1001D77B0(uint64_t a1, uint64_t *a2)
{
  if (*((_BYTE *)a2 + 14) != 1) {
    sub_1000E6B88( "/Library/Caches/com.apple.xbs/Sources/MobileBluetooth_base/Stack/corestack/le/LEA.c",  194,  "(*bs).__RWFlag == BYTESTREAM_READ");
  }
  if (*((_BYTE *)a2 + 15))
  {
    sub_1001ED1C4((uint64_t)"/Library/Caches/com.apple.xbs/Sources/MobileBluetooth_base/Stack/corestack/le/LEA.c");
    int v3 = *((unsigned __int8 *)a2 + 14);
    *((_BYTE *)a2 + 15) = 1;
    if (v3 != 1) {
      sub_1000E6B88( "/Library/Caches/com.apple.xbs/Sources/MobileBluetooth_base/Stack/corestack/le/LEA.c",  195,  "(*bs).__RWFlag == BYTESTREAM_READ");
    }
    goto LABEL_9;
  }

  uint64_t v4 = *((unsigned __int16 *)a2 + 6);
  if (*((unsigned __int16 *)a2 + 5) <= v4)
  {
    *((_BYTE *)a2 + 15) = 1;
LABEL_9:
    sub_1001ED1C4((uint64_t)"/Library/Caches/com.apple.xbs/Sources/MobileBluetooth_base/Stack/corestack/le/LEA.c");
    goto LABEL_10;
  }

  uint64_t v5 = *a2;
  *((_WORD *)a2 + 6) = v4 + 1;
  if (*((unsigned __int16 *)a2 + 5) - ((int)v4 + 1) >= 2)
  {
    uint64_t v6 = *(unsigned __int8 *)(v5 + v4);
    uint64_t v7 = *(unsigned __int16 *)(*a2 + v4 + 1);
    *((_WORD *)a2 + 6) = v4 + 3;
    (*(void (**)(uint64_t, uint64_t, uint64_t))(*(void *)(qword_1008EDBD0 + 16) + 56LL))(a1, v6, v7);
    return;
  }

uint64_t sub_1001D7900(uint64_t a1, uint64_t *a2)
{
  if (*((_BYTE *)a2 + 14) != 1) {
    sub_1000E6B88( "/Library/Caches/com.apple.xbs/Sources/MobileBluetooth_base/Stack/corestack/le/LEA.c",  216,  "(*bs).__RWFlag == BYTESTREAM_READ");
  }
  if (*((_BYTE *)a2 + 15))
  {
    sub_1001ED1C4((uint64_t)"/Library/Caches/com.apple.xbs/Sources/MobileBluetooth_base/Stack/corestack/le/LEA.c");
  }

  else
  {
    uint64_t v3 = *((unsigned __int16 *)a2 + 6);
    if (*((unsigned __int16 *)a2 + 5) > v3)
    {
      uint64_t v4 = *a2;
      *((_WORD *)a2 + 6) = v3 + 1;
      (*(void (**)(uint64_t, void))(*(void *)(qword_1008EDBD0 + 16) + 72LL))( a1,  *(unsigned __int8 *)(v4 + v3));
      return 0LL;
    }
  }

  *((_BYTE *)a2 + 15) = 1;
  uint64_t v5 = 2LL;
  if (sub_1000A86F0())
  {
    sub_1001EE134((uint64_t)"Failed to read set volume", v6, v7, v8, v9, v10, v11, v12, v15);
    uint64_t v13 = (os_log_s *)sub_100086554(0x42u);
    if (os_log_type_enabled(v13, OS_LOG_TYPE_ERROR)) {
      sub_100657858();
    }
    return 2LL;
  }

  return v5;
}

uint64_t sub_1001D79F4(uint64_t a1, uint64_t *a2)
{
  if (*((_BYTE *)a2 + 14) != 1) {
    sub_1000E6B88( "/Library/Caches/com.apple.xbs/Sources/MobileBluetooth_base/Stack/corestack/le/LEA.c",  234,  "(*bs).__RWFlag == BYTESTREAM_READ");
  }
  if (*((_BYTE *)a2 + 15))
  {
    sub_1001ED1C4((uint64_t)"/Library/Caches/com.apple.xbs/Sources/MobileBluetooth_base/Stack/corestack/le/LEA.c");
    int v3 = *((unsigned __int8 *)a2 + 14);
    *((_BYTE *)a2 + 15) = 1;
    if (v3 != 1) {
      sub_1000E6B88( "/Library/Caches/com.apple.xbs/Sources/MobileBluetooth_base/Stack/corestack/le/LEA.c",  235,  "(*bs).__RWFlag == BYTESTREAM_READ");
    }
    goto LABEL_9;
  }

  uint64_t v4 = *((unsigned __int16 *)a2 + 6);
  if (*((unsigned __int16 *)a2 + 5) <= v4)
  {
    *((_BYTE *)a2 + 15) = 1;
LABEL_9:
    sub_1001ED1C4((uint64_t)"/Library/Caches/com.apple.xbs/Sources/MobileBluetooth_base/Stack/corestack/le/LEA.c");
    goto LABEL_10;
  }

  uint64_t v5 = *a2;
  *((_WORD *)a2 + 6) = v4 + 1;
  if (*((unsigned __int16 *)a2 + 5) > (v4 + 1))
  {
    uint64_t v6 = *(unsigned __int8 *)(v5 + v4);
    uint64_t v7 = *a2;
    *((_WORD *)a2 + 6) = v4 + 2;
    (*(void (**)(uint64_t, uint64_t, void))(*(void *)(qword_1008EDBD0 + 16) + 80LL))( a1,  v6,  *(unsigned __int8 *)(v7 + v4 + 1));
    return 0LL;
  }

uint64_t sub_1001D7B4C(uint64_t a1, uint64_t *a2)
{
  if (*((_BYTE *)a2 + 14) != 1) {
    sub_1000E6B88( "/Library/Caches/com.apple.xbs/Sources/MobileBluetooth_base/Stack/corestack/le/LEA.c",  262,  "(*bs).__RWFlag == BYTESTREAM_READ");
  }
  if (*((_BYTE *)a2 + 15))
  {
    sub_1001ED1C4((uint64_t)"/Library/Caches/com.apple.xbs/Sources/MobileBluetooth_base/Stack/corestack/le/LEA.c");
LABEL_7:
    *((_BYTE *)a2 + 15) = 1;
    goto LABEL_8;
  }

  uint64_t v3 = *((unsigned __int16 *)a2 + 6);
  uint64_t v4 = *a2;
  *((_WORD *)a2 + 6) = v3 + 1;
  uint64_t v5 = *(void (**)(uint64_t, void))(*(void *)(qword_1008EDBD0 + 16) + 104LL);
  if (v5)
  {
    v5(a1, *(unsigned __int8 *)(v4 + v3));
    return 0LL;
  }

uint64_t sub_1001D7C44(uint64_t a1, uint64_t *a2)
{
  if (*((_BYTE *)a2 + 14) != 1) {
    sub_1000E6B88( "/Library/Caches/com.apple.xbs/Sources/MobileBluetooth_base/Stack/corestack/le/LEA.c",  279,  "(*bs).__RWFlag == BYTESTREAM_READ");
  }
  if (*((_BYTE *)a2 + 15))
  {
    sub_1001ED1C4((uint64_t)"/Library/Caches/com.apple.xbs/Sources/MobileBluetooth_base/Stack/corestack/le/LEA.c");
    int v3 = *((unsigned __int8 *)a2 + 14);
    *((_BYTE *)a2 + 15) = 1;
    if (v3 != 1) {
      sub_1000E6B88( "/Library/Caches/com.apple.xbs/Sources/MobileBluetooth_base/Stack/corestack/le/LEA.c",  280,  "(*bs).__RWFlag == BYTESTREAM_READ");
    }
    goto LABEL_10;
  }

  uint64_t v4 = *((unsigned __int16 *)a2 + 6);
  if (*((unsigned __int16 *)a2 + 5) <= v4)
  {
    *((_BYTE *)a2 + 15) = 1;
LABEL_10:
    sub_1001ED1C4((uint64_t)"/Library/Caches/com.apple.xbs/Sources/MobileBluetooth_base/Stack/corestack/le/LEA.c");
    goto LABEL_11;
  }

  uint64_t v5 = *a2;
  uint64_t v6 = v4 + 1;
  *((_WORD *)a2 + 6) = v4 + 1;
  if (*((unsigned __int16 *)a2 + 5) <= (v4 + 1))
  {
LABEL_11:
    *((_BYTE *)a2 + 15) = 1;
    goto LABEL_12;
  }

  char v7 = *(_BYTE *)(v5 + v4);
  uint64_t v8 = *a2;
  *((_WORD *)a2 + 6) = v4 + 2;
  uint64_t v9 = *(void (**)(uint64_t, void, void))(*(void *)(qword_1008EDBD0 + 16) + 112LL);
  if (v9)
  {
    v9(a1, v7, *(unsigned __int8 *)(v8 + v6));
    return 0LL;
  }

uint64_t sub_1001D7DA4(uint64_t a1, uint64_t *a2)
{
  if (*((_BYTE *)a2 + 14) != 1) {
    sub_1000E6B88( "/Library/Caches/com.apple.xbs/Sources/MobileBluetooth_base/Stack/corestack/le/LEA.c",  297,  "(*bs).__RWFlag == BYTESTREAM_READ");
  }
  __int16 v20 = 0;
  int v19 = 0;
  if (*((_BYTE *)a2 + 15))
  {
    sub_1001ED1C4((uint64_t)"/Library/Caches/com.apple.xbs/Sources/MobileBluetooth_base/Stack/corestack/le/LEA.c");
  }

  else
  {
    uint64_t v4 = *((unsigned __int16 *)a2 + 6);
    if (*((unsigned __int16 *)a2 + 5) - (int)v4 >= 6)
    {
      sub_1001F0050((uint64_t)&v19, *a2 + v4, 6uLL);
      *((_WORD *)a2 + 6) += 6;
      goto LABEL_7;
    }
  }

  *((_BYTE *)a2 + 15) = 1;
LABEL_7:
  if (*((_BYTE *)a2 + 14) != 1) {
    sub_1000E6B88( "/Library/Caches/com.apple.xbs/Sources/MobileBluetooth_base/Stack/corestack/le/LEA.c",  298,  "(*bs).__RWFlag == BYTESTREAM_READ");
  }
  if (*((_BYTE *)a2 + 15))
  {
    sub_1001ED1C4((uint64_t)"/Library/Caches/com.apple.xbs/Sources/MobileBluetooth_base/Stack/corestack/le/LEA.c");
LABEL_13:
    *((_BYTE *)a2 + 15) = 1;
    goto LABEL_14;
  }

  uint64_t v5 = *((unsigned __int16 *)a2 + 6);
  uint64_t v6 = *a2;
  *((_WORD *)a2 + 6) = v5 + 1;
  char v7 = *(void (**)(uint64_t, int *, void))(*(void *)(qword_1008EDBD0 + 16) + 136LL);
  if (v7)
  {
    v7(a1, &v19, *(unsigned __int8 *)(v6 + v5));
    return 0LL;
  }

uint64_t sub_1001D7F40(uint64_t a1, uint64_t *a2)
{
  if (*((_BYTE *)a2 + 14) != 1) {
    sub_1000E6B88( "/Library/Caches/com.apple.xbs/Sources/MobileBluetooth_base/Stack/corestack/le/LEA.c",  314,  "(*bs).__RWFlag == BYTESTREAM_READ");
  }
  if (*((_BYTE *)a2 + 15))
  {
    sub_1001ED1C4((uint64_t)"/Library/Caches/com.apple.xbs/Sources/MobileBluetooth_base/Stack/corestack/le/LEA.c");
LABEL_7:
    *((_BYTE *)a2 + 15) = 1;
    goto LABEL_8;
  }

  uint64_t v3 = *((unsigned __int16 *)a2 + 6);
  uint64_t v4 = *a2;
  *((_WORD *)a2 + 6) = v3 + 1;
  uint64_t v5 = *(void (**)(uint64_t, void))(*(void *)(qword_1008EDBD0 + 16) + 120LL);
  if (v5)
  {
    v5(a1, *(unsigned __int8 *)(v4 + v3));
    return 0LL;
  }

uint64_t sub_1001D8038(uint64_t a1, uint64_t *a2)
{
  if (*((_BYTE *)a2 + 14) != 1) {
    sub_1000E6B88( "/Library/Caches/com.apple.xbs/Sources/MobileBluetooth_base/Stack/corestack/le/LEA.c",  332,  "(*bs).__RWFlag == BYTESTREAM_READ");
  }
  __int16 v24 = 0;
  int v23 = 0;
  uint64_t v25 = 0LL;
  if (*((_BYTE *)a2 + 15))
  {
    sub_1001ED1C4((uint64_t)"/Library/Caches/com.apple.xbs/Sources/MobileBluetooth_base/Stack/corestack/le/LEA.c");
  }

  else
  {
    uint64_t v4 = *((unsigned __int16 *)a2 + 6);
    if (*((unsigned __int16 *)a2 + 5) - (int)v4 >= 6)
    {
      sub_1001F0050((uint64_t)&v23, *a2 + v4, 6uLL);
      *((_WORD *)a2 + 6) += 6;
      goto LABEL_7;
    }
  }

  *((_BYTE *)a2 + 15) = 1;
LABEL_7:
  if (*((_BYTE *)a2 + 14) != 1) {
    sub_1000E6B88( "/Library/Caches/com.apple.xbs/Sources/MobileBluetooth_base/Stack/corestack/le/LEA.c",  333,  "(*bs).__RWFlag == BYTESTREAM_READ");
  }
  if (*((_BYTE *)a2 + 15))
  {
    sub_1001ED1C4((uint64_t)"/Library/Caches/com.apple.xbs/Sources/MobileBluetooth_base/Stack/corestack/le/LEA.c");
    int v5 = *((unsigned __int8 *)a2 + 14);
    *((_BYTE *)a2 + 15) = 1;
    if (v5 != 1) {
      sub_1000E6B88( "/Library/Caches/com.apple.xbs/Sources/MobileBluetooth_base/Stack/corestack/le/LEA.c",  334,  "(*bs).__RWFlag == BYTESTREAM_READ");
    }
    goto LABEL_18;
  }

  uint64_t v6 = *((unsigned __int16 *)a2 + 6);
  if (*((unsigned __int16 *)a2 + 5) - (int)v6 <= 1)
  {
    *((_BYTE *)a2 + 15) = 1;
LABEL_18:
    sub_1001ED1C4((uint64_t)"/Library/Caches/com.apple.xbs/Sources/MobileBluetooth_base/Stack/corestack/le/LEA.c");
    goto LABEL_19;
  }

  uint64_t v7 = *a2;
  unsigned __int16 v8 = *(_WORD *)(*a2 + v6);
  *((_WORD *)a2 + 6) = v6 + 2;
  if (*((unsigned __int16 *)a2 + 5) - (unsigned __int16)(v6 + 2) < 8)
  {
LABEL_19:
    *((_BYTE *)a2 + 15) = 1;
    goto LABEL_20;
  }

  uint64_t v9 = 0LL;
  uint64_t v10 = v7 + (unsigned __int16)(v6 + 2);
  do
  {
    *((_BYTE *)&v25 + v9) = *(_BYTE *)(v10 + v9);
    ++v9;
  }

  while (v9 != 8);
  *((_WORD *)a2 + 6) = v6 + 10;
  uint64_t v11 = *(void (**)(uint64_t, int *, void, uint64_t *))(*(void *)(qword_1008EDBD0 + 16) + 144LL);
  if (v11)
  {
    v11(a1, &v23, v8, &v25);
    return 0LL;
  }

uint64_t sub_1001D8294(uint64_t a1, uint64_t a2)
{
  if (*(_BYTE *)(a2 + 14) != 1) {
    sub_1000E6B88( "/Library/Caches/com.apple.xbs/Sources/MobileBluetooth_base/Stack/corestack/le/LEA.c",  351,  "(*bs).__RWFlag == BYTESTREAM_READ");
  }
  WORD2(v19) = 0;
  LODWORD(v19) = 0;
  v20[0] = 0LL;
  v20[1] = 0LL;
  if (*(_BYTE *)(a2 + 15))
  {
    sub_1001ED1C4((uint64_t)"/Library/Caches/com.apple.xbs/Sources/MobileBluetooth_base/Stack/corestack/le/LEA.c");
    LOWORD(v4) = *(_WORD *)(a2 + 12);
  }

  else
  {
    uint64_t v4 = *(unsigned __int16 *)(a2 + 12);
    if (*(unsigned __int16 *)(a2 + 10) - (int)v4 >= 6)
    {
      sub_1001F0050((uint64_t)&v19, *(void *)a2 + v4, 6uLL);
      LOWORD(v4) = *(_WORD *)(a2 + 12) + 6;
      *(_WORD *)(a2 + 12) = v4;
      goto LABEL_7;
    }
  }

  *(_BYTE *)(a2 + 15) = 1;
LABEL_7:
  if (*(_BYTE *)(a2 + 14) != 1) {
    sub_1000E6B88( "/Library/Caches/com.apple.xbs/Sources/MobileBluetooth_base/Stack/corestack/le/LEA.c",  352,  "(*bs).__RWFlag == BYTESTREAM_READ");
  }
  if (*(_BYTE *)(a2 + 15))
  {
    sub_1001ED1C4((uint64_t)"/Library/Caches/com.apple.xbs/Sources/MobileBluetooth_base/Stack/corestack/le/LEA.c");
LABEL_15:
    *(_BYTE *)(a2 + 15) = 1;
    goto LABEL_16;
  }

  __int16 v5 = v4;
  uint64_t v6 = 0LL;
  uint64_t v7 = *(void *)a2 + (unsigned __int16)v4;
  do
  {
    *((_BYTE *)v20 + v6) = *(_BYTE *)(v7 + v6);
    ++v6;
  }

  while (v6 != 16);
  *(_WORD *)(a2 + 12) = v5 + 16;
  unsigned __int16 v8 = *(void (**)(uint64_t, uint64_t *, void *))(*(void *)(qword_1008EDBD0 + 16) + 152LL);
  if (v8)
  {
    v8(a1, &v19, v20);
    return 0LL;
  }

uint64_t sub_1001D848C(uint64_t a1, uint64_t a2)
{
  if (*(_BYTE *)(a2 + 14) != 1) {
    sub_1000E6B88( "/Library/Caches/com.apple.xbs/Sources/MobileBluetooth_base/Stack/corestack/le/LEA.c",  369,  "(*bs).__RWFlag == BYTESTREAM_READ");
  }
  WORD2(v19) = 0;
  LODWORD(v19) = 0;
  v20[0] = 0LL;
  v20[1] = 0LL;
  if (*(_BYTE *)(a2 + 15))
  {
    sub_1001ED1C4((uint64_t)"/Library/Caches/com.apple.xbs/Sources/MobileBluetooth_base/Stack/corestack/le/LEA.c");
    LOWORD(v4) = *(_WORD *)(a2 + 12);
  }

  else
  {
    uint64_t v4 = *(unsigned __int16 *)(a2 + 12);
    if (*(unsigned __int16 *)(a2 + 10) - (int)v4 >= 6)
    {
      sub_1001F0050((uint64_t)&v19, *(void *)a2 + v4, 6uLL);
      LOWORD(v4) = *(_WORD *)(a2 + 12) + 6;
      *(_WORD *)(a2 + 12) = v4;
      goto LABEL_7;
    }
  }

  *(_BYTE *)(a2 + 15) = 1;
LABEL_7:
  if (*(_BYTE *)(a2 + 14) != 1) {
    sub_1000E6B88( "/Library/Caches/com.apple.xbs/Sources/MobileBluetooth_base/Stack/corestack/le/LEA.c",  370,  "(*bs).__RWFlag == BYTESTREAM_READ");
  }
  if (*(_BYTE *)(a2 + 15))
  {
    sub_1001ED1C4((uint64_t)"/Library/Caches/com.apple.xbs/Sources/MobileBluetooth_base/Stack/corestack/le/LEA.c");
LABEL_15:
    *(_BYTE *)(a2 + 15) = 1;
    goto LABEL_16;
  }

  __int16 v5 = v4;
  uint64_t v6 = 0LL;
  uint64_t v7 = *(void *)a2 + (unsigned __int16)v4;
  do
  {
    *((_BYTE *)v20 + v6) = *(_BYTE *)(v7 + v6);
    ++v6;
  }

  while (v6 != 16);
  *(_WORD *)(a2 + 12) = v5 + 16;
  unsigned __int16 v8 = *(void (**)(uint64_t, uint64_t *, void *))(*(void *)(qword_1008EDBD0 + 16) + 160LL);
  if (v8)
  {
    v8(a1, &v19, v20);
    return 0LL;
  }

uint64_t sub_1001D8684(uint64_t a1, uint64_t a2)
{
  if (*(_BYTE *)(a2 + 14) != 1) {
    sub_1000E6B88( "/Library/Caches/com.apple.xbs/Sources/MobileBluetooth_base/Stack/corestack/le/LEA.c",  387,  "(*bs).__RWFlag == BYTESTREAM_READ");
  }
  __int16 v22 = 0;
  int v21 = 0;
  if (*(_BYTE *)(a2 + 15))
  {
    sub_1001ED1C4((uint64_t)"/Library/Caches/com.apple.xbs/Sources/MobileBluetooth_base/Stack/corestack/le/LEA.c");
  }

  else
  {
    uint64_t v4 = *(unsigned __int16 *)(a2 + 12);
    if (*(unsigned __int16 *)(a2 + 10) - (int)v4 >= 6)
    {
      sub_1001F0050((uint64_t)&v21, *(void *)a2 + v4, 6uLL);
      *(_WORD *)(a2 + 12) += 6;
      goto LABEL_7;
    }
  }

  *(_BYTE *)(a2 + 15) = 1;
LABEL_7:
  if (*(_BYTE *)(a2 + 14) != 1) {
    sub_1000E6B88( "/Library/Caches/com.apple.xbs/Sources/MobileBluetooth_base/Stack/corestack/le/LEA.c",  388,  "(*bs).__RWFlag == BYTESTREAM_READ");
  }
  if (*(_BYTE *)(a2 + 15))
  {
    sub_1001ED1C4((uint64_t)"/Library/Caches/com.apple.xbs/Sources/MobileBluetooth_base/Stack/corestack/le/LEA.c");
LABEL_13:
    *(_BYTE *)(a2 + 15) = 1;
    goto LABEL_14;
  }

  uint64_t v5 = *(unsigned __int16 *)(a2 + 12);
  uint64_t v6 = (unsigned __int8 *)(*(void *)a2 + v5);
  int v7 = *v6;
  int v8 = v6[1];
  *(_WORD *)(a2 + 12) = v5 + 2;
  uint64_t v9 = *(void (**)(uint64_t, int *, void))(*(void *)(qword_1008EDBD0 + 16) + 168LL);
  if (v9)
  {
    v9(a1, &v21, v7 | (v8 << 8));
    return 0LL;
  }

uint64_t sub_1001D8830(uint64_t a1, uint64_t *a2)
{
  if (*((_BYTE *)a2 + 14) != 1) {
    sub_1000E6B88( "/Library/Caches/com.apple.xbs/Sources/MobileBluetooth_base/Stack/corestack/le/LEA.c",  404,  "(*bs).__RWFlag == BYTESTREAM_READ");
  }
  if (*((_BYTE *)a2 + 15))
  {
    sub_1001ED1C4((uint64_t)"/Library/Caches/com.apple.xbs/Sources/MobileBluetooth_base/Stack/corestack/le/LEA.c");
LABEL_7:
    *((_BYTE *)a2 + 15) = 1;
    goto LABEL_8;
  }

  uint64_t v3 = *((unsigned __int16 *)a2 + 6);
  uint64_t v4 = *a2;
  *((_WORD *)a2 + 6) = v3 + 1;
  uint64_t v5 = *(void (**)(uint64_t, void))(*(void *)(qword_1008EDBD0 + 16) + 128LL);
  if (v5)
  {
    v5(a1, *(unsigned __int8 *)(v4 + v3));
    return 0LL;
  }

uint64_t sub_1001D8928(uint64_t a1, unsigned int a2)
{
  if (!a1) {
    sub_1001EE2A0();
  }
  if (a2 == 1 || a2 >= 0x3E) {
    sub_1001EE2A0();
  }
  if (*(_BYTE *)qword_1008F6ED0)
  {
    uint64_t v4 = 0LL;
    uint64_t v5 = qword_1008EDBD8 - 88;
    while (1)
    {
      v5 += 88LL;
      if (v5 == a1) {
        break;
      }
    }

    return (unsigned __int16)(a2 | ((_WORD)v4 << 8));
  }

  else
  {
LABEL_10:
    sub_1001EE2A0();
    return 0;
  }

uint64_t sub_1001D89B0(uint64_t a1, int a2, void *a3)
{
  if (a1)
  {
    if (a3) {
      goto LABEL_3;
    }
  }

  else
  {
    sub_1001EE2A0();
    if (a3) {
      goto LABEL_3;
    }
  }

  sub_1001EE2A0();
LABEL_3:
  if (!dword_1008F6FD0) {
    return 408LL;
  }
  uint64_t v6 = (void *)(a1 + 16);
  while (1)
  {
    uint64_t v6 = (void *)*v6;
    if (!v6 || v6 == (void *)(a1 + 16)) {
      break;
    }
    if (*((unsigned __int8 *)v6 - 134) == a2)
    {
      uint64_t result = 0LL;
      *a3 = v6 - 18;
      return result;
    }
  }

  return 912LL;
}

uint64_t sub_1001D8A44(uint64_t a1, unsigned int a2, void *a3)
{
  if (a2 < 2) {
    return 121LL;
  }
  uint64_t v4 = *(unsigned __int8 *)(qword_1008F6ED0 + 1);
  if (!*(_BYTE *)(qword_1008F6ED0 + 1)) {
    return 121LL;
  }
  for (uint64_t i = (unsigned __int16 *)(qword_1008EDBE8 + 24); *((unsigned __int8 *)i + 2) != a2 >> 1; i += 28)
  {
    if (!--v4) {
      return 121LL;
    }
  }

  uint64_t result = sub_1001D8B08(a1, a2, a3);
  if (!(_DWORD)result)
  {
    uint64_t v8 = *a3;
    *(_BYTE *)(v8 + 20) = 1;
    *(void *)(v8 + 40) = *((void *)i - 1);
    uint64_t v9 = *a3;
    *(_WORD *)(*a3 + 160LL) = i[8];
    unsigned int v10 = *i;
    *(_WORD *)(v9 + 16) = v10;
    *(void *)(v9 + 48) = *((void *)i + 3);
  }

  return result;
}

uint64_t sub_1001D8B08(uint64_t a1, unsigned int a2, void *a3)
{
  if (!a1) {
    sub_1001EE2A0();
  }
  if (!dword_1008F6FD0) {
    return 408LL;
  }
  uint64_t v6 = (void *)(a1 + 16);
  while (1)
  {
    uint64_t v6 = (void *)*v6;
    if (!v6 || v6 == (void *)(a1 + 16)) {
      break;
    }
  }

  uint64_t v9 = sub_1000B1814(0xA8uLL);
  if (!v9) {
    return 106LL;
  }
  unsigned int v10 = v9;
  v9[20] = 0;
  *((_WORD *)v9 + 4) = sub_1001D8928(a1, a2);
  *((void *)v10 + 16) = a1;
  v10[10] = a2;
  *((void *)v10 + 11) = 0LL;
  *((_WORD *)v10 + 8) = 127;
  *((_WORD *)v10 + 6) = 140;
  *((void *)v10 + 13) = 0LL;
  *((_WORD *)v10 + 81) = 0;
  *(void *)(v10 + memset(v6, 0, 22) = 50544511LL;
  *(_DWORD *)(v10 + 30) = 16847633;
  *((_DWORD *)v10 + 14) = 0;
  sub_1001EF1D0((void *)v10 + 18, a1 + 16);
  uint64_t result = 0LL;
  *a3 = v10;
  return result;
}

void sub_1001D8C08(uint64_t a1)
{
  if (!a1) {
    sub_1001EE2A0();
  }
  uint64_t v2 = *(void *)(a1 + 128);
  if (!v2)
  {
    sub_1001EE2A0();
    uint64_t v2 = *(void *)(a1 + 128);
  }

  if (*(_BYTE *)(a1 + 96))
  {
    *(_BYTE *)(a1 + 96) = 0;
    uint64_t v3 = *(void *)(a1 + 88);
    if (v3)
    {
      *(void *)(a1 + 88) = 0LL;
      (*(void (**)(void, uint64_t, uint64_t))(a1 + 80))(*(unsigned __int16 *)(a1 + 8), v3, 143LL);
    }
  }

  uint64_t v4 = *(void *)(a1 + 128);
  uint64_t v7 = *(void **)(v4 + 56);
  uint64_t v6 = (void *)(v4 + 56);
  uint64_t v5 = v7;
  if (v7 != v6)
  {
    do
    {
      uint64_t v8 = (void *)*v5;
      if (*((unsigned __int8 *)v5 - 7) == *(unsigned __int8 *)(a1 + 10))
      {
        sub_1001EF1E4(v5);
        sub_1001EF69C((void *)*(v5 - 2));
        if (*((_BYTE *)v5 - 8)) {
          sub_1001DAF18(a1, 143LL);
        }
        sub_1000B1838(v5 - 2);
      }

      uint64_t v5 = v8;
    }

    while (v8 != v6);
  }

void sub_1001D8CE8(uint64_t a1, int a2)
{
  if (!a1) {
    sub_1001EE2A0();
  }
  uint64_t v4 = *(void *)(a1 + 128);
  if (!v4)
  {
    sub_1001EE2A0();
    uint64_t v4 = *(void *)(a1 + 128);
  }

  sub_1001F08BC(*(unsigned int *)(a1 + 56));
  sub_1001EF1E4((void *)(a1 + 144));
  uint64_t v5 = *(unsigned int *)(a1 + 136);
  if ((_DWORD)v5)
  {
    sub_1001EEB14(v5);
    *(_DWORD *)(a1 + 136) = 0;
  }

  sub_1001D8C08(a1);
  sub_1001DBD64(a1);
  if (a2 && *(void *)(v4 + 16) == v4 + 16) {
    sub_1001D8D80((unsigned __int8 *)v4, 0, *(unsigned int *)(a1 + 164));
  }
  sub_1000B1838((void *)a1);
}

uint64_t sub_1001D8D80(unsigned __int8 *a1, int a2, uint64_t a3)
{
  if (!a1) {
    sub_1001EE2A0();
  }
  if (sub_1000A86F0())
  {
    sub_1001EE134((uint64_t)"Shutting down session to %:", v6, v7, v8, v9, v10, v11, v12, (uint64_t)(a1 + 6));
    uint64_t v13 = (os_log_s *)sub_100086554(0x32u);
    if (os_log_type_enabled(v13, OS_LOG_TYPE_DEFAULT))
    {
      *(_DWORD *)__int128 buf = 136446210;
      uint64_t v18 = sub_1001EDDCC();
      _os_log_impl((void *)&_mh_execute_header, v13, OS_LOG_TYPE_DEFAULT, " %{public}s", buf, 0xCu);
    }
  }

  int v14 = *a1;
  if (!a2)
  {
    if (v14 != 9)
    {
      *a1 = 9;
      uint64_t v15 = sub_1001DC2AC(67LL, a1, 0LL);
      goto LABEL_12;
    }

    return 116LL;
  }

  if (v14 == 10) {
    return 116LL;
  }
  *a1 = 10;
  uint64_t v15 = sub_1001759FC(*((unsigned __int16 *)a1 + 1), a3);
LABEL_12:
  if ((_DWORD)v15) {
    sub_1001D902C((uint64_t)a1, v15, 1);
  }
  return 0LL;
}

uint64_t sub_1001D8EC4(int a1)
{
  if (!dword_1008F6FD0)
  {
    if (sub_1000A86F0())
    {
      sub_1001EE134((uint64_t)"OI_Rfcomm_GetSessionByCID", v4, v5, v6, v7, v8, v9, v10, v12);
      uint64_t v11 = (os_log_s *)sub_100086554(0x32u);
      if (os_log_type_enabled(v11, OS_LOG_TYPE_ERROR)) {
        sub_10065BE10();
      }
    }

    return 0LL;
  }

  uint64_t v1 = *(unsigned __int8 *)qword_1008F6ED0;
  if (!*(_BYTE *)qword_1008F6ED0) {
    return 0LL;
  }
  for (uint64_t result = qword_1008EDBD8; !*(_BYTE *)result || *(unsigned __int16 *)(result + 2) != a1; result += 88LL)
  {
    if (!--v1) {
      return 0LL;
    }
  }

  return result;
}

uint64_t sub_1001D8F70(uint64_t a1)
{
  if (!dword_1008F6FD0)
  {
    if (sub_1000A86F0())
    {
      sub_1001EE134((uint64_t)"OI_Rfcomm_GetSessionByAddr", v5, v6, v7, v8, v9, v10, v11, v13);
      uint64_t v12 = (os_log_s *)sub_100086554(0x32u);
      if (os_log_type_enabled(v12, OS_LOG_TYPE_ERROR)) {
        sub_10065BE10();
      }
    }

    return 0LL;
  }

  uint64_t v1 = *(unsigned __int8 *)qword_1008F6ED0;
  if (!*(_BYTE *)qword_1008F6ED0) {
    return 0LL;
  }
  for (uint64_t result = qword_1008EDBD8; ; result += 88LL)
  {
    if (*(_BYTE *)result)
    {
      if (*(_DWORD *)a1 == *(_DWORD *)(result + 6)
        && *(unsigned __int16 *)(a1 + 4) == *(unsigned __int16 *)(result + 10))
      {
        break;
      }
    }

    if (!--v1) {
      return 0LL;
    }
  }

  return result;
}

void sub_1001D902C(uint64_t a1, uint64_t a2, char a3)
{
  if (!a1) {
    sub_1001EE2A0();
  }
  if (!*(_BYTE *)a1) {
    sub_1001EE2A0();
  }
  sub_1001DDAC0(a1);
  sub_1001DDAE8(a1);
  sub_1001DC100(a1);
  uint64_t v5 = (void *)(a1 + 16);
  uint64_t v6 = *(void **)(a1 + 16);
  if (v6 == (void *)(a1 + 16))
  {
LABEL_30:
    *(_BYTE *)a1 = 0;
    sub_1001DDAC0(a1);
    sub_1001DDAE8(a1);
    sub_1001DC100(a1);
    sub_1001D94A0();
    uint64_t v28 = (unsigned __int16 *)qword_1008EDBE0;
    if (qword_1008EDBE0)
    {
      do
      {
        uint64_t v29 = (void (*)(void, uint64_t))*((void *)v28 + 3);
        if (v29)
        {
          v29(*v28, a2);
        }

        else
        {
          uint64_t v30 = (void (*)(void, void, uint64_t))*((void *)v28 + 2);
          if (v30) {
            v30(*v28, 0LL, a2);
          }
        }

        uint64_t v28 = *(unsigned __int16 **)(qword_1008EDBE0 + 32);
        sub_1000B1838((void *)qword_1008EDBE0);
        qword_1008EDBE0 = (uint64_t)v28;
      }

      while (v28);
    }

    qword_1008EDBE0 = 0LL;
    return;
  }

  char v32 = 0;
  int v33 = *(char *)(a1 + 82);
  uint64_t v31 = 136446466LL;
  uint64_t v7 = (void *)(a1 + 16);
  do
  {
    while (1)
    {
      uint64_t v8 = v6 - 18;
      *((_DWORD *)v6 + 5) = a2;
      unsigned int v9 = *((unsigned __int8 *)v6 - 131);
      if (v9 > 1 || (a3 & 1) != 0 || *((_BYTE *)v6 - 124) || (v33 & 0x80000000) == 0) {
        break;
      }
      *(_WORD *)((char *)v6 - 131) = 0;
      *(v6 - 7) = 0LL;
      char v32 = 1;
      *((_BYTE *)v6 - 111) = 1;
      *((_WORD *)v6 - 63) = 0;
      *((_DWORD *)v6 - memset(v6, 0, 22) = 0;
      sub_1001DBD64((uint64_t)(v6 - 18));
      uint64_t v7 = (void *)*v7;
      uint64_t v6 = (void *)*v7;
      if ((void *)*v7 == v5) {
        goto LABEL_29;
      }
    }

    if (v9 - 5 >= 4)
    {
      if (v9 == 9)
      {
        sub_1001D8CE8(v6 - 18, 0LL);
        goto LABEL_24;
      }

      uint64_t v11 = 0LL;
      *((_BYTE *)v6 - 131) = 9;
      uint64_t v10 = *(v6 - 9);
    }

    else
    {
      *((_BYTE *)v6 - 131) = 9;
      sub_1001D8C08((uint64_t)(v6 - 18));
      uint64_t v10 = 0LL;
      uint64_t v11 = *(void *)*(v6 - 13);
    }

    uint64_t v12 = *(v6 - 18);
    uint64_t v13 = *(unsigned __int16 *)(a1 + 10);
    uint64_t v14 = *(unsigned int *)(a1 + 6);
    __int16 v15 = *((_WORD *)v6 - 68);
    sub_1001D8CE8(v8, 0LL);
    uint64_t v16 = (char *)sub_1000B17F4(0x28uLL);
    if (v16)
    {
      *(_WORD *)uint64_t v16 = v15;
      *(_DWORD *)(v16 + 2) = v14;
      *((_WORD *)v16 + 3) = (v14 | (unint64_t)(v13 << 32)) >> 32;
      *((void *)v16 + 1) = v12;
      *((void *)v16 + 2) = v10;
      *((void *)v16 + 3) = v11;
      *((void *)v16 + 4) = 0LL;
      uint64_t v17 = qword_1008EDBE0;
      if (qword_1008EDBE0)
      {
        do
        {
          uint64_t v18 = v17;
          uint64_t v17 = *(void *)(v17 + 32);
        }

        while (v17);
        *(void *)(v18 + 32) = v16;
      }

      else
      {
        qword_1008EDBE0 = (uint64_t)v16;
      }
    }

    else
    {
      sub_1001EE2A0();
      if ((sub_1000A86F0() & 1) != 0)
      {
        sub_1001EE134((uint64_t)"Alloc RFCOMM link cache failed!", v19, v20, v21, v22, v23, v24, v25, v31);
        uint64_t v26 = (os_log_s *)sub_100086554(0x32u);
        if (os_log_type_enabled(v26, OS_LOG_TYPE_ERROR))
        {
          uint64_t v27 = sub_1001EDDCC();
          *(_DWORD *)__int128 buf = v31;
          uint64_t v36 = v27;
          __int16 v37 = 1024;
          int v38 = 104;
          _os_log_error_impl( (void *)&_mh_execute_header,  v26,  OS_LOG_TYPE_ERROR,  "%{public}s (status=%{bluetooth:OI_STATUS}u)",  buf,  0x12u);
        }
      }
    }

uint64_t sub_1001D9350(uint64_t a1, unsigned int a2)
{
  uint64_t v20 = 0LL;
  uint64_t v21 = 0LL;
  uint64_t v22 = 0LL;
  sub_1001EDBA0(0x28u);
  int v18 = 327745535;
  __int16 v19 = 776;
  if (a2 <= 0x7F) {
    __int16 v4 = 5;
  }
  else {
    __int16 v4 = 6;
  }
  unsigned __int16 v5 = v4 + a2;
  __int16 v17 = v5;
  if (v5 > 0x80u)
  {
    __int16 v6 = *(_WORD *)(sub_1001EDBA0(0x28u) + 8);
  }

  else
  {
    __int16 v6 = 128;
  }

  __int16 v17 = v6;
LABEL_9:
  *(_BYTE *)(a1 + 12) = 1;
  *(void *)(a1 + 32) = 0LL;
  uint64_t v7 = sub_100174028( (uint64_t)sub_1001DADFC,  (uint64_t)sub_1001DB478,  (uint64_t)sub_1001DAD74,  3,  a1 + 6,  (uint64_t)&v17,  (_WORD *)(a1 + 2),  (uint64_t)&unk_1006BDE20);
  if ((_DWORD)v7)
  {
    if (sub_1000A86F0())
    {
      sub_1001EE134((uint64_t)"L2CAP_CreateConnection failed with result %!", v8, v9, v10, v11, v12, v13, v14, v7);
      __int16 v15 = (os_log_s *)sub_100086554(0x32u);
      if (os_log_type_enabled(v15, OS_LOG_TYPE_ERROR)) {
        sub_100657F74();
      }
    }

    sub_1001D902C(a1, v7, 1LL);
  }

  else
  {
    *(_BYTE *)a1 = 2;
  }

  return v7;
}

void sub_1001D94A0()
{
  uint64_t v0 = (_DWORD *)qword_1008EDBF0;
  if (qword_1008EDBF0 || (sub_1001EE2A0(), (uint64_t v0 = (_DWORD *)qword_1008EDBF0) != 0LL))
  {
    if ((*v0)-- == 1) {
      sub_1001DA1EC();
    }
  }

uint64_t sub_1001D94EC(uint64_t a1, __int16 a2, uint64_t *a3)
{
  uint64_t v9 = 0LL;
  uint64_t result = sub_1001D9554(a1, &v9);
  if (!(_DWORD)result)
  {
    uint64_t v7 = v9;
    __int16 v8 = *(_WORD *)(a1 + 4);
    *(_DWORD *)(v9 + 6) = *(_DWORD *)a1;
    *(_WORD *)(v7 + 10) = v8;
    *(_BYTE *)(v7 + 12) = 0;
    *(void *)(v7 + 32) = 0LL;
    *(_WORD *)(v7 + 2) = a2;
    *a3 = v7;
  }

  return result;
}

uint64_t sub_1001D9554(uint64_t a1, uint64_t *a2)
{
  if (!dword_1008F6FD0) {
    return 408LL;
  }
  if (!*(_BYTE *)qword_1008F6ED0) {
    return 104LL;
  }
  unint64_t v3 = 0LL;
  uint64_t v4 = qword_1008EDBD8;
  unsigned __int16 v5 = (unsigned __int8 *)qword_1008EDBD8;
  do
  {
    *a2 = v4;
    int v6 = *v5;
    v5 += 88;
    if (v6)
    {
      int v7 = *(_DWORD *)(v4 + 6);
      int v8 = *(unsigned __int16 *)(v4 + 10);
    }

    ++v3;
    unint64_t v10 = *(unsigned __int8 *)qword_1008F6ED0;
    uint64_t v4 = (uint64_t)v5;
  }

  while (v3 < v10);
  if (!*(_BYTE *)qword_1008F6ED0) {
    return 104LL;
  }
  for (uint64_t i = qword_1008EDBD8; *(_BYTE *)i; i += 88LL)
  {
    if (!--v10) {
      return 104LL;
    }
  }

  *(_OWORD *)uint64_t i = 0u;
  *(void *)(i + 80) = 0LL;
  *(_OWORD *)(i + 48) = 0u;
  *(_OWORD *)(i + 64) = 0u;
  *(_OWORD *)(i + 16) = 0u;
  *(_OWORD *)(i + 32) = 0u;
  *(_BYTE *)uint64_t i = 1;
  *(_WORD *)(i + 44) = 257;
  sub_1001EF1B4((void *)(i + 56));
  sub_1001EF1B4((void *)(i + 16));
  uint64_t result = 0LL;
  *(_BYTE *)(i + 82) = 0;
  *a2 = i;
  ++*(_DWORD *)qword_1008EDBF0;
  return result;
}

uint64_t sub_1001D9678(uint64_t a1)
{
  if (!a1) {
    sub_1001EE2A0();
  }
  if (*(_BYTE *)(a1 + 13)) {
    sub_1001EE2A0();
  }
  uint64_t v2 = sub_1001DBC70(a1);
  if ((_DWORD)v2)
  {
    uint64_t v3 = v2;
    if (sub_1000A86F0())
    {
      sub_1001EE134((uint64_t)"DLCI: %d", v4, v5, v6, v7, v8, v9, v10, *(unsigned __int8 *)(a1 + 10));
      uint64_t v11 = (os_log_s *)sub_100086554(0x32u);
      if (os_log_type_enabled(v11, OS_LOG_TYPE_ERROR)) {
        sub_10065A878();
      }
    }

    return v3;
  }

  else
  {
    unsigned int v13 = *(unsigned __int16 *)(a1 + 16);
    uint64_t v14 = *(void *)(a1 + 128);
    *(_WORD *)(a1 + 16) = v13;
    return sub_1001F0324((uint64_t)sub_1001D9750, v14 + 6, *(__int128 **)(a1 + 48), (int *)(a1 + 56), 0);
  }

void sub_1001D9750(uint64_t a1, uint64_t a2)
{
  uint64_t v4 = sub_1001DAC1C(a1);
  if (v4)
  {
    uint64_t v5 = v4;
    if ((_DWORD)a2
      || (a2 = sub_1001DDB38(v4[16], 1, *((unsigned __int8 *)v4 + 10), 0, *((_WORD *)v4 + 8), *((_BYTE *)v4 + 14)),
          (_DWORD)a2))
    {
      if (sub_1000A86F0())
      {
        sub_1001EE134((uint64_t)"connection failed", v6, v7, v8, v9, v10, v11, v12, v14);
        unsigned int v13 = (os_log_s *)sub_100086554(0x32u);
        if (os_log_type_enabled(v13, OS_LOG_TYPE_ERROR)) {
          sub_10065A878();
        }
      }

      *((_DWORD *)v5 + 41) = a2;
      ((void (*)(void, void, uint64_t))v5[9])(*((unsigned __int16 *)v5 + 4), 0LL, a2);
      sub_1001D8CE8(v5, 1LL);
    }
  }

  else
  {
    sub_1001F08BC(a1);
  }

uint64_t sub_1001D9828()
{
  uint64_t v0 = *(unsigned __int8 *)(qword_1008F6ED0 + 1);
  if (!*(_BYTE *)(qword_1008F6ED0 + 1)) {
    return 0LL;
  }
  LOWORD(result) = 0;
  uint64_t v2 = (unsigned __int16 *)(qword_1008EDBE8 + 24);
  do
  {
    unsigned int v4 = *v2;
    v2 += 28;
    unsigned int v3 = v4;
    else {
      uint64_t result = v3;
    }
    --v0;
  }

  while (v0);
  return result;
}

uint64_t sub_1001D986C(uint64_t a1, int a2)
{
  if (!a2) {
    return 121LL;
  }
  uint64_t v2 = *(unsigned __int8 *)(qword_1008F6ED0 + 1);
  if (!*(_BYTE *)(qword_1008F6ED0 + 1)) {
    return 121LL;
  }
  for (uint64_t i = (unsigned __int8 *)(qword_1008EDBE8 + 26); *i != a2; i += 56)
  {
    if (!--v2) {
      return 121LL;
    }
  }

  (*(void (**)(void))(i - 18))();
  return 0LL;
}

uint64_t sub_1001D98D0(unsigned int a1, void *a2)
{
  if (!dword_1008F6FD0) {
    return 408LL;
  }
  uint64_t v2 = (_BYTE *)(qword_1008EDBD8 + 88LL * (a1 >> 8));
  if (!*v2) {
    return 916LL;
  }
  uint64_t result = sub_1001D89B0((uint64_t)v2, a1, a2);
  if (!(_DWORD)result)
  {
    if (*(_BYTE *)(*a2 + 13LL) == 9) {
      return 927LL;
    }
    else {
      return 0LL;
    }
  }

  return result;
}

uint64_t sub_1001D9964(uint64_t a1, uint64_t a2, unsigned int a3, unsigned int a4, _BYTE *a5, uint64_t a6)
{
  if (dword_1008F6FD0 || (uint64_t v14 = sub_1001D9B00(), !(_DWORD)v14))
  {
    ++*(_DWORD *)qword_1008EDBF0;
    BOOL v13 = a4 < a3 && a4 != 0;
    uint64_t v14 = 101LL;
    if (a3 && !v13 && a1 && a2)
    {
      uint64_t v15 = *(unsigned __int8 *)(qword_1008F6ED0 + 1);
      if (*(_BYTE *)(qword_1008F6ED0 + 1))
      {
        unsigned int v16 = 0;
        uint64_t v17 = 0LL;
        uint64_t v18 = qword_1008EDBE8;
        do
        {
          if (*(_BYTE *)(v18 + 26))
          {
            v16 |= 1 << *(_BYTE *)(v18 + 26);
          }

          else if (!v17)
          {
            *(_WORD *)(v18 + 24) = a3;
            uint64_t v17 = v18;
          }

          v18 += 56LL;
          --v15;
        }

        while (v15);
        if (v17)
        {
          int v19 = *a5;
          else {
            unsigned int v20 = *a5;
          }
          do
          {
            if (((v16 >> v20) & 1) == 0)
            {
              uint64_t v14 = 0LL;
              *(void *)(v17 + 8) = a1;
              *(void *)(v17 + 16) = a2;
              *(_WORD *)(v17 + 24) = a3;
              *(_WORD *)(v17 + 40) = a4 / a3;
              *(void *)(v17 + 48) = a6;
              *(_BYTE *)(v17 + 26) = v20;
              *a5 = v20;
              return v14;
            }

            unsigned int v20 = v20 % 0x1E + 1;
          }

          while (v20 != v19);
          if (sub_1000A86F0())
          {
            sub_1001EE134((uint64_t)"No free channel numbers", v21, v22, v23, v24, v25, v26, v27, v30);
            uint64_t v28 = (os_log_s *)sub_100086554(0x32u);
            if (os_log_type_enabled(v28, OS_LOG_TYPE_ERROR)) {
              sub_10065C960();
            }
          }
        }
      }

      uint64_t v14 = 104LL;
    }

    sub_1001D94A0();
  }

  return v14;
}

uint64_t sub_1001D9B00()
{
  if (dword_1008F6FD0) {
    sub_1001EE2A0();
  }
  uint64_t v0 = (unsigned __int8 *)sub_1001EDBA0(0x32u);
  qword_1008F6ED0 = (uint64_t)v0;
  if (!v0)
  {
    sub_1001EE2A0();
    uint64_t v0 = (unsigned __int8 *)qword_1008F6ED0;
    if (!qword_1008F6ED0) {
      return 127LL;
    }
  }

  qword_1008EDBE0 = 0LL;
  qword_1008EDBD8 = 0LL;
  qword_1008EDBE8 = 0LL;
  qword_1008EDBF0 = 0LL;
  qword_1008EDBD8 = (uint64_t)sub_1000B1814(88LL * *v0);
  if (!qword_1008EDBD8
    || (qword_1008EDBE8 = (uint64_t)sub_1000B1814(56LL * *(unsigned __int8 *)(qword_1008F6ED0 + 1))) == 0)
  {
    uint64_t v2 = 106LL;
LABEL_11:
    if (qword_1008EDBF0)
    {
      sub_1000B1838((void *)qword_1008EDBF0);
      qword_1008EDBF0 = 0LL;
    }

    goto LABEL_15;
  }

  uint64_t v1 = sub_1000B1814(4uLL);
  qword_1008EDBF0 = (uint64_t)v1;
  if (v1)
  {
    *uint64_t v1 = 0;
    uint64_t v2 = sub_10017A6F0(3, (uint64_t)sub_1001DB2D8);
    if (!(_DWORD)v2)
    {
      dword_1008F6FD0 = 1;
      return v2;
    }

    goto LABEL_11;
  }

  uint64_t v2 = 106LL;
LABEL_15:
  if (qword_1008EDBE8)
  {
    sub_1000B1838((void *)qword_1008EDBE8);
    qword_1008EDBE8 = 0LL;
  }

  if (qword_1008EDBD8)
  {
    sub_1000B1838((void *)qword_1008EDBD8);
    qword_1008EDBD8 = 0LL;
  }

  return v2;
}

uint64_t sub_1001D9C30(int a1)
{
  if (!dword_1008F6FD0) {
    return 408LL;
  }
  uint64_t v2 = *(unsigned __int8 *)(qword_1008F6ED0 + 1);
  if (!*(_BYTE *)(qword_1008F6ED0 + 1)) {
    return 120LL;
  }
  for (uint64_t i = (_BYTE *)(qword_1008EDBE8 + 26); *i != a1; i += 56)
  {
    if (!--v2) {
      return 120LL;
    }
  }

  if (*(_BYTE *)qword_1008F6ED0)
  {
    uint64_t v4 = 0LL;
    do
    {
      if (*(_BYTE *)(qword_1008EDBD8 + 88 * v4))
      {
        uint64_t v5 = qword_1008EDBD8 + 88 * v4;
        uint64_t v8 = *(void **)(v5 + 16);
        uint64_t v6 = (void *)(v5 + 16);
        for (j = v8; j && j != v6; j = (void *)*j)
        {
        }
      }

      ++v4;
    }

    while (v4 != *(unsigned __int8 *)qword_1008F6ED0);
  }

  *uint64_t i = 0;
  *((_WORD *)i - 1) = 0;
  sub_1001D94A0();
  return 0LL;
}

uint64_t sub_1001D9D2C(uint64_t a1, unsigned int a2, uint64_t a3)
{
  return sub_1001D9D34(a1, a2, a3, 1);
}

uint64_t sub_1001D9D34(uint64_t a1, unsigned int a2, uint64_t a3, int a4)
{
  if (!dword_1008F6FD0) {
    return 408LL;
  }
  if (!a1 || !a3)
  {
    sub_1001EE2A0();
    return 101LL;
  }

  if (*(_BYTE *)(a3 + 1) || *(_WORD *)(a3 + 6)) {
    sub_1001EE2A0();
  }
  unsigned int v8 = *(unsigned __int16 *)(a3 + 4);
  if (!*(_WORD *)(a3 + 4)) {
    return 101LL;
  }
  uint64_t v23 = 0LL;
  uint64_t v9 = sub_1001D98D0(a2, &v23);
  if (!(_DWORD)v9)
  {
    uint64_t v10 = v23;
    if (*(void *)(v23 + 88))
    {
      return 901LL;
    }

    else
    {
      uint64_t v12 = *(unsigned __int16 *)(v23 + 16);
      if (v8 <= v12 || a4)
      {
        *(void *)(v23 + 80) = a1;
        *(void *)(v10 + 88) = a3;
        sub_1001EFEB8(a3, v12);
        BOOL v13 = sub_1001DBC18(v23);
        uint64_t v14 = v23;
        if (v13)
        {
          *(_BYTE *)(v23 + 96) = 0;
          uint64_t v9 = sub_1001DC578(*(void *)(v14 + 128), *(unsigned __int8 *)(v14 + 10), a3, 0, 1LL);
          if ((_DWORD)v9)
          {
            if (sub_1000A86F0())
            {
              sub_1001EE134((uint64_t)"DLCI: %d", v15, v16, v17, v18, v19, v20, v21, *(unsigned __int8 *)(v23 + 10));
              uint64_t v22 = (os_log_s *)sub_100086554(0x32u);
              if (os_log_type_enabled(v22, OS_LOG_TYPE_ERROR)) {
                sub_10065A878();
              }
            }

            *(void *)(v23 + 88) = 0LL;
          }
        }

        else
        {
          uint64_t v9 = 0LL;
          *(_BYTE *)(v23 + 96) = 1;
        }
      }

      else
      {
        return 918LL;
      }
    }
  }

  return v9;
}

uint64_t sub_1001D9EAC(uint64_t a1, unsigned int a2, char *a3, size_t a4, int a5, int a6)
{
  if (!dword_1008F6FD0) {
    return 408LL;
  }
  if (a1)
  {
    uint64_t v7 = 101LL;
    if (a3 && (_DWORD)a4)
    {
      uint64_t v10 = sub_1001EF80C(a3, a4, a6);
      if (v10)
      {
        uint64_t v11 = v10;
        *((void *)v10 + 1) = a1;
        uint64_t v7 = sub_1001D9D34((uint64_t)sub_1001DACFC, a2, (uint64_t)v10, a5);
        if ((_DWORD)v7) {
          sub_1001EF69C(v11);
        }
      }

      else
      {
        return 106LL;
      }
    }
  }

  else
  {
    sub_1001EE2A0();
    return 101LL;
  }

  return v7;
}

uint64_t sub_1001D9F64(uint64_t a1, unsigned int a2, char *a3, size_t a4)
{
  return sub_1001D9EAC(a1, a2, a3, a4, 0, 0);
}

uint64_t sub_1001D9F70(uint64_t a1, unsigned int a2, char *a3, size_t a4)
{
  return sub_1001D9EAC(a1, a2, a3, a4, 1, 2);
}

uint64_t sub_1001D9F7C( uint64_t a1, void *a2, uint64_t a3, char a4, unsigned int a5, unsigned int a6, _WORD *a7, uint64_t a8)
{
  uint64_t v39 = 0LL;
  if (!dword_1008F6FD0)
  {
    uint64_t v18 = sub_1001D9B00();
    if ((_DWORD)v18) {
      return v18;
    }
  }

  if (!a2) {
    goto LABEL_19;
  }
  if (!a2[1])
  {
    sub_1001EE2A0();
    if (!a2[1]) {
      return 101LL;
    }
  }

  if (!*a2)
  {
    sub_1001EE2A0();
    if (!*a2) {
      return 101LL;
    }
  }

  if (!a1 || !a3)
  {
LABEL_19:
    sub_1001EE2A0();
    return 101LL;
  }

  unsigned int v38 = *(_DWORD *)qword_1008EDBF0;
  BOOL v17 = a6 < a5 && a6 != 0;
  uint64_t v18 = 101LL;
  if (!a5 || v17) {
    goto LABEL_33;
  }
  if ((a4 - 31) < 0xE2u)
  {
    uint64_t v18 = 910LL;
    goto LABEL_33;
  }

  uint64_t v40 = sub_1001D8F70(a3);
  uint64_t v20 = v40;
  uint64_t v37 = v40;
  if (!v40)
  {
    uint64_t v18 = sub_1001D9554(a3, &v40);
    if ((_DWORD)v18) {
      goto LABEL_33;
    }
    __int16 v26 = *(_WORD *)(a3 + 4);
    int v27 = *(_DWORD *)a3;
    uint64_t v28 = v40;
    *(_DWORD *)(v40 + 6) = v27;
    *(_WORD *)(v28 + 10) = v26;
    uint64_t v18 = sub_1001D9350(v28, a5);
    if ((_DWORD)v18) {
      goto LABEL_33;
    }
    uint64_t v20 = v28;
  }

  unsigned int v21 = (*(unsigned __int8 *)(v20 + 12) | (2 * (a4 & 0x7F))) ^ 1;
  uint64_t v22 = (_BYTE *)v20;
  uint64_t v18 = sub_1001D8B08(v20, v21, &v39);
  if ((_DWORD)v18)
  {
LABEL_33:
    if (sub_1000A86F0())
    {
      sub_1001EE134((uint64_t)"OI_RFCOMM_Connect failed", v29, v30, v31, v32, v33, v34, v35, v37);
      uint64_t v36 = (os_log_s *)sub_100086554(0x32u);
      if (os_log_type_enabled(v36, OS_LOG_TYPE_ERROR)) {
        sub_10065A878();
      }
    }

    if (dword_1008F6FD0)
    {
      if (*(_DWORD *)qword_1008EDBF0 <= v38)
      {
        if (!*(_DWORD *)qword_1008EDBF0) {
          sub_1001DA1EC();
        }
      }

      else
      {
        sub_1001D94A0();
      }
    }

    return v18;
  }

  uint64_t v23 = v22;
  uint64_t v24 = v39;
  *(void *)(v39 + 72) = a1;
  *(void *)(v24 + 40) = a2;
  *(_WORD *)(v24 + 16) = a5;
  if (a7) {
    *a7 = *(_WORD *)(v24 + 8);
  }
  *(_WORD *)(v24 + 160) = a6 / a5;
  *(void *)(v24 + 48) = a8;
  if (!v37 || *v23 != 7) {
    return 0LL;
  }
  uint64_t v25 = sub_1001D9678(v24);
  uint64_t v18 = v25;
  if ((_DWORD)v25)
  {
    *(_DWORD *)(v24 + 164) = v25;
    sub_1001D8CE8(v24, 1);
  }

  return v18;
}

void sub_1001DA1EC()
{
  if (dword_1008F6FD0 != 1) {
    sub_1001EE2A0();
  }
  uint64_t v0 = sub_10017A8B8(3);
  if ((_DWORD)v0)
  {
    sub_1000AFE20(v0);
    sub_1001DA26C();
  }

  else
  {
    if (qword_1008EDBF0)
    {
      sub_1000B1838((void *)qword_1008EDBF0);
      qword_1008EDBF0 = 0LL;
    }

    if (qword_1008EDBE8)
    {
      sub_1000B1838((void *)qword_1008EDBE8);
      qword_1008EDBE8 = 0LL;
    }

    if (qword_1008EDBD8)
    {
      sub_1000B1838((void *)qword_1008EDBD8);
      qword_1008EDBD8 = 0LL;
    }

    dword_1008F6FD0 = 0;
  }

uint64_t sub_1001DA26C(uint64_t a1, unsigned int a2, int a3)
{
  uint64_t v19 = 0LL;
  if (!dword_1008F6FD0) {
    return 408LL;
  }
  if (!a1 && a3)
  {
    sub_1001EE2A0();
    return 101LL;
  }

  uint64_t v6 = sub_1001D98D0(a2, &v19);
  if ((_DWORD)v6)
  {
    uint64_t v5 = v6;
    if (sub_1000A86F0())
    {
      sub_1001EE134((uint64_t)"OI_RFCOMM_Accept - linkhandle %d not found", v7, v8, v9, v10, v11, v12, v13, v19);
      uint64_t v14 = (os_log_s *)sub_100086554(0x32u);
      if (os_log_type_enabled(v14, OS_LOG_TYPE_ERROR)) {
        sub_10065A878();
      }
    }

    return v5;
  }

  uint64_t v15 = v19;
  if (*(_BYTE *)(v19 + 13) != 3) {
    return 408LL;
  }
  *(void *)(v19 + 72) = a1;
  uint64_t v16 = *(void *)(v15 + 128);
  if (a3) {
    return sub_1001F0324((uint64_t)sub_1001DA3B4, v16 + 6, *(__int128 **)(v15 + 48), (int *)(v15 + 56), 1);
  }
  uint64_t v5 = sub_1001DC2AC(15, v16, *(unsigned __int8 *)(v15 + 10));
  uint64_t v18 = v19;
  if ((_DWORD)v5)
  {
    *(_DWORD *)(v19 + 164) = v5;
    sub_1001D8CE8(v18, 1);
  }

  else
  {
    if (!v19)
    {
      sub_1001EE2A0();
      uint64_t v18 = v19;
    }

    uint64_t v5 = 0LL;
    *(_BYTE *)(v18 + 13) = 9;
  }

  return v5;
}

void sub_1001DA3B4(uint64_t a1, uint64_t a2, int a3)
{
  uint64_t v6 = sub_1001DAC1C(a1);
  if (!v6)
  {
    sub_1001F08BC(a1);
    return;
  }

  uint64_t v7 = (uint64_t)v6;
  if (!(_DWORD)a2)
  {
    uint64_t v27 = sub_1001DC2AC(99, v6[16], *((unsigned __int8 *)v6 + 10));
    if (!(_DWORD)v27)
    {
      *(_BYTE *)(v7 + 13) = 4;
      sub_1001DDEC8(*(void *)(v7 + 128), 1, *(_BYTE *)(v7 + 10), *(_BYTE *)(v7 + 12), 0);
      return;
    }

    uint64_t v28 = v27;
    if (sub_1000A86F0())
    {
      sub_1001EE134((uint64_t)"connection failed", v29, v30, v31, v32, v33, v34, v35, v37);
      uint64_t v36 = (os_log_s *)sub_100086554(0x32u);
      if (os_log_type_enabled(v36, OS_LOG_TYPE_ERROR)) {
        sub_10065A878();
      }
    }

    *(_BYTE *)(v7 + 13) = 9;
    *(_DWORD *)(v7 + 164) = v28;
    (*(void (**)(void, void, uint64_t))(v7 + 72))(*(unsigned __int16 *)(v7 + 8), 0LL, v28);
    goto LABEL_19;
  }

  if (sub_1000A86F0())
  {
    uint64_t v15 = "";
    if (a3) {
      uint64_t v15 = "Security failure, ";
    }
    sub_1001EE134( (uint64_t)"Policy enforcement failed, %s disconnecting ",  v8,  v9,  v10,  v11,  v12,  v13,  v14,  (uint64_t)v15);
    uint64_t v16 = (os_log_s *)sub_100086554(0x32u);
    if (os_log_type_enabled(v16, OS_LOG_TYPE_ERROR)) {
      sub_10065A878();
    }
  }

  *(_BYTE *)(v7 + 13) = 9;
  *(_DWORD *)(v7 + 164) = a2;
  (*(void (**)(void, void, uint64_t))(v7 + 72))(*(unsigned __int16 *)(v7 + 8), 0LL, a2);
  int v17 = sub_1001DC2AC(15, *(void *)(v7 + 128), *(unsigned __int8 *)(v7 + 10));
  if (v17)
  {
    int v18 = v17;
    if (sub_1000A86F0())
    {
      sub_1001EE134((uint64_t)"send DM failed", v19, v20, v21, v22, v23, v24, v25, v37);
      __int16 v26 = (os_log_s *)sub_100086554(0x32u);
      if (os_log_type_enabled(v26, OS_LOG_TYPE_ERROR)) {
        sub_10065A878();
      }
    }

    *(_DWORD *)(v7 + 164) = v18;
LABEL_19:
    sub_1001D8CE8(v7, 1);
  }

uint64_t sub_1001DA5AC(unsigned int a1, int a2)
{
  if (!dword_1008F6FD0) {
    return 408LL;
  }
  unsigned __int8 v2 = a1;
  uint64_t v7 = 0LL;
  unsigned int v3 = (_BYTE *)(qword_1008EDBD8 + 88LL * (a1 >> 8));
  if (!*v3) {
    return 916LL;
  }
  uint64_t result = sub_1001D89B0((uint64_t)v3, a1, &v7);
  if (!(_DWORD)result)
  {
    if (*(unsigned __int8 *)(v7 + 13) - 6 >= 4)
    {
      *(_DWORD *)(v7 + 164) = a2;
      uint64_t result = sub_1001DC2AC(67, (uint64_t)v3, v2);
      if (!(_DWORD)result)
      {
        uint64_t v6 = v7;
        if (!v7)
        {
          sub_1001EE2A0();
          uint64_t v6 = v7;
        }

        uint64_t result = 0LL;
        *(_BYTE *)(v6 + 13) = 6;
      }
    }

    else
    {
      return 0LL;
    }
  }

  return result;
}

uint64_t sub_1001DA694(unsigned int a1, uint64_t a2)
{
  uint64_t v10 = 0LL;
  uint64_t result = sub_1001D98D0(a1, &v10);
  if (!(_DWORD)result)
  {
    uint64_t v6 = v10;
    if (!v10)
    {
      sub_1001EE2A0();
      uint64_t v6 = v10;
    }

    uint64_t v7 = *(void *)(v6 + 128);
    if (v7) {
      goto LABEL_12;
    }
    sub_1001EE2A0();
LABEL_11:
    uint64_t v7 = *(void *)(v10 + 128);
LABEL_12:
    uint64_t v8 = (unsigned __int16 *)(v7 + 6);
    goto LABEL_13;
  }

  if ((_DWORD)result == 927) {
    goto LABEL_11;
  }
  uint64_t v5 = (unsigned __int16 *)qword_1008EDBE0;
  if (!qword_1008EDBE0) {
    return result;
  }
  while (*v5 != a1)
  {
    uint64_t v5 = (unsigned __int16 *)*((void *)v5 + 4);
    if (!v5) {
      return result;
    }
  }

  uint64_t v8 = v5 + 1;
LABEL_13:
  uint64_t result = 0LL;
  int v9 = *(_DWORD *)v8;
  *(_WORD *)(a2 + 4) = v8[2];
  *(_DWORD *)a2 = v9;
  return result;
}

uint64_t sub_1001DA73C( uint64_t a1, uint64_t a2, uint64_t a3, char a4, unsigned int a5, unsigned int a6, _WORD *a7, _WORD *a8, uint64_t a9, int a10)
{
  uint64_t v56 = 0LL;
  uint64_t v57 = 0LL;
  if (!dword_1008F6FD0)
  {
    uint64_t v19 = sub_1001D9B00();
    if ((_DWORD)v19) {
      return v19;
    }
  }

  uint64_t v18 = sub_1001D9554(a3, &v57);
  if ((_DWORD)v18)
  {
    uint64_t v19 = v18;
    if (sub_1000A86F0())
    {
      sub_1001EE134( (uint64_t)"OI_RFCOMM_createChannelForFastConnect Allocate Session failed",  v20,  v21,  v22,  v23,  v24,  v25,  v26,  v55[0]);
      uint64_t v27 = (os_log_s *)sub_100086554(0x32u);
      if (os_log_type_enabled(v27, OS_LOG_TYPE_ERROR)) {
        sub_10065A878();
      }
    }

    return v19;
  }

  uint64_t v28 = v57;
  __int16 v29 = *(_WORD *)(a3 + 4);
  uint64_t v30 = v57;
  *(_DWORD *)(v57 + 6) = *(_DWORD *)a3;
  uint64_t v31 = v30 + 6;
  *(_WORD *)(v28 + 10) = v29;
  *(void *)(v28 + 32) = 0LL;
  sub_1001EDBA0(0x28u);
  if (a5 <= 0x7F) {
    __int16 v32 = 5;
  }
  else {
    __int16 v32 = 6;
  }
  unsigned __int16 v33 = v32 + a5;
  if ((unsigned __int16)(v32 + a5) >= 0x81u)
  {
  }

  else
  {
    unsigned __int16 v33 = 128;
  }

  LOWORD(v55[0]) = v33;
  *(_DWORD *)((char *)v55 + 2) = 327745535;
  HIWORD(v55[0]) = 776;
  memset(&v55[1], 0, 24);
  uint64_t v34 = sub_100173838( 3,  (uint64_t)v55,  v31,  (uint64_t)sub_1001DADFC,  (uint64_t)sub_1001DB478,  (uint64_t)sub_1001DAD74,  (_WORD *)(v28 + 2),  (uint64_t)&unk_1006BDE20);
  if ((_DWORD)v34)
  {
    uint64_t v19 = v34;
    *(_BYTE *)uint64_t v28 = 0;
    sub_1001EE134( (uint64_t)"OI_RFCOMM_createChannelForFastConnect create L2CAP channel failed",  v35,  v36,  v37,  v38,  v39,  v40,  v41,  v55[0]);
    uint64_t v42 = (os_log_s *)sub_100086554(0x32u);
    if (!os_log_type_enabled(v42, OS_LOG_TYPE_ERROR)) {
      return v19;
    }
    goto LABEL_18;
  }

  *a8 = *(_WORD *)(v28 + 2);
  *(_BYTE *)(v28 + 12) = a10 != 0;
  unsigned int v43 = (2 * a4);
  if (a10) {
    uint64_t v44 = sub_1001D8B08(v28, v43, &v56);
  }
  else {
    uint64_t v44 = sub_1001D8A44(v28, v43, &v56);
  }
  uint64_t v19 = v44;
  *(_BYTE *)(v28 + 12) = a10 != 0;
  if ((_DWORD)v44)
  {
    *(_BYTE *)uint64_t v28 = 0;
    sub_1001EE134( (uint64_t)"OI_RFCOMM_createChannelForFastConnect allocate link failed",  v45,  v46,  v47,  v48,  v49,  v50,  v51,  v55[0]);
    uint64_t v52 = (os_log_s *)sub_100086554(0x32u);
    if (!os_log_type_enabled(v52, OS_LOG_TYPE_ERROR)) {
      return v19;
    }
LABEL_18:
    sub_10065A878();
    return v19;
  }

  uint64_t v53 = v56;
  *(void *)(v56 + 72) = a1;
  *(void *)(v53 + 40) = a2;
  *(_WORD *)(v53 + 16) = a5;
  if (a7) {
    *a7 = *(_WORD *)(v53 + 8);
  }
  *(_WORD *)(v53 + 160) = a6 / a5;
  *(void *)(v53 + 48) = a9;
  uint64_t v19 = sub_1001DBC70(v53);
  *(_BYTE *)uint64_t v28 = 7;
  return v19;
}

void sub_1001DA9EC(uint64_t a1, unsigned int a2)
{
  uint64_t v25 = 0LL;
  if (sub_100171EC4(a2, (uint64_t *)&v25))
  {
    if (sub_1000A86F0())
    {
      sub_1001EE134( (uint64_t)"OI_RFCOMM_FastConnectSetSessionMaxFrameSize L2CAP signal channel not found",  v3,  v4,  v5,  v6,  v7,  v8,  v9,  v24);
      uint64_t v10 = (os_log_s *)sub_100086554(0x32u);
      if (os_log_type_enabled(v10, OS_LOG_TYPE_ERROR)) {
LABEL_14:
      }
        sub_100657F74();
    }
  }

  else
  {
    uint64_t v11 = sub_1001D8F70(a1);
    if (v11)
    {
      uint64_t v12 = v11;
      unsigned int v13 = *(unsigned __int16 *)(sub_10017AB4C(v25) + 32);
      unsigned int v14 = *(unsigned __int16 *)(sub_10017AB4C(v25) + 36);
      if (v13 < v14) {
        unsigned int v14 = v13;
      }
      if (v14 >= 0x85) {
        __int16 v15 = -6;
      }
      else {
        __int16 v15 = -5;
      }
      *(_WORD *)(v12 + 4) = v15 + v14;
    }

    else if (sub_1000A86F0())
    {
      sub_1001EE134( (uint64_t)"OI_RFCOMM_FastConnectSetSessionMaxFrameSize Session not found",  v16,  v17,  v18,  v19,  v20,  v21,  v22,  v24);
      uint64_t v23 = (os_log_s *)sub_100086554(0x32u);
      if (os_log_type_enabled(v23, OS_LOG_TYPE_ERROR)) {
        goto LABEL_14;
      }
    }
  }

void sub_1001DAAF0(uint64_t a1, unsigned int a2)
{
  uint64_t v4 = sub_1001D8F70(a1);
  uint64_t v21 = 0LL;
  if (v4)
  {
    uint64_t v5 = (_BYTE *)v4;
    uint64_t v6 = v4 + 16;
    uint64_t v7 = (void *)(v4 + 16);
    do
    {
      uint64_t v8 = (void *)*v7;
      if (*v7 == v6) {
        break;
      }
      *((_BYTE *)v8 - 131) = 0;
      sub_1001D8CE8((uint64_t)(v8 - 18), 0);
      uint64_t v7 = (void *)*v7;
    }

    while (v7);
    *uint64_t v5 = 0;
    sub_1001DDAC0((uint64_t)v5);
    sub_1001DDAE8((uint64_t)v5);
    sub_1001DC100((uint64_t)v5);
    sub_1001D94A0();
    uint64_t v9 = (void *)qword_1008EDBE0;
    if (qword_1008EDBE0)
    {
      do
      {
        uint64_t v10 = v9[4];
        sub_1000B1838(v9);
        qword_1008EDBE0 = v10;
        uint64_t v9 = (void *)v10;
      }

      while (v10);
    }

    qword_1008EDBE0 = 0LL;
  }

  if (a2 && !sub_100171EC4(a2, &v21) && v21)
  {
    sub_1001734D8(v21);
    uint64_t v11 = sub_10012D890(a1);
    if (v11)
    {
      sub_10011286C(v11);
    }

    else if (sub_1000A86F0())
    {
      sub_1001EE134( (uint64_t)"OI_RFCOMM_destroyChannelForFastConnect NULL Handle",  v12,  v13,  v14,  v15,  v16,  v17,  v18,  v20);
      uint64_t v19 = (os_log_s *)sub_100086554(0x32u);
      if (os_log_type_enabled(v19, OS_LOG_TYPE_ERROR)) {
        sub_100657F74();
      }
    }
  }

void *sub_1001DAC1C(int a1)
{
  if (dword_1008F6FD0)
  {
    if (*(_BYTE *)qword_1008F6ED0)
    {
      uint64_t v1 = 0LL;
      do
      {
        if (qword_1008EDBD8 && *(_BYTE *)(qword_1008EDBD8 + 88 * v1))
        {
          unsigned __int8 v2 = (void *)(qword_1008EDBD8 + 88 * v1 + 16);
          while (1)
          {
            unsigned __int8 v2 = (void *)*v2;
            if (!v2 || v2 == (void *)(qword_1008EDBD8 + 88 * v1 + 16)) {
              break;
            }
            if (*((_DWORD *)v2 - 22) == a1) {
              return v2 - 18;
            }
          }
        }

        ++v1;
      }

      while (v1 != *(unsigned __int8 *)qword_1008F6ED0);
    }
  }

  else if (sub_1000A86F0())
  {
    sub_1001EE134((uint64_t)"OI_GetLinkByPolicyHandle", v4, v5, v6, v7, v8, v9, v10, v13);
    uint64_t v11 = (os_log_s *)sub_100086554(0x32u);
    if (os_log_type_enabled(v11, OS_LOG_TYPE_ERROR)) {
      sub_10065BE10();
    }
  }

  return 0LL;
}

uint64_t sub_1001DACFC(uint64_t a1, uint64_t a2, uint64_t a3)
{
  if (!a2) {
    sub_1001EE2A0();
  }
  uint64_t v6 = *(uint64_t (**)(uint64_t, uint64_t, void, uint64_t))(a2 + 8);
  if (!v6)
  {
    sub_1001EE2A0();
    uint64_t v6 = *(uint64_t (**)(uint64_t, uint64_t, void, uint64_t))(a2 + 8);
  }

  uint64_t v9 = 0LL;
  unsigned __int16 v8 = 0;
  sub_1001EF734((void **)a2, &v9, &v8);
  return v6(a1, v9, v8, a3);
}

void sub_1001DAD74(int a1, uint64_t a2, uint64_t a3)
{
  if (dword_1008F6FD0)
  {
    sub_1001DC898(a1, a2, a3);
  }

  else if (sub_1000A86F0())
  {
    sub_1001EE134((uint64_t)"%!", v3, v4, v5, v6, v7, v8, v9, 103LL);
    uint64_t v10 = (os_log_s *)sub_100086554(0x32u);
    if (os_log_type_enabled(v10, OS_LOG_TYPE_ERROR)) {
      sub_100657858();
    }
  }

void sub_1001DADFC(int a1, unsigned int a2, unsigned int a3, uint64_t a4)
{
  if (dword_1008F6FD0)
  {
    uint64_t v7 = (char *)sub_1001D8EC4(a1);
    if (!v7) {
      return;
    }
    uint64_t v8 = v7;
    if ((*v7 & 0xFE) != 2) {
      sub_1001EE2A0();
    }
    if ((_DWORD)a4)
    {
      sub_1001D902C(v8, a4, 0LL);
      return;
    }

    if (a3 >= a2) {
      unsigned int v17 = a2;
    }
    else {
      unsigned int v17 = a3;
    }
    if (v17 >= 0x85) {
      __int16 v18 = -6;
    }
    else {
      __int16 v18 = -5;
    }
    *((_WORD *)v8 + 2) = v18 + v17;
    if (*v8 == 2)
    {
      char v19 = 5;
    }

    else
    {
      char v19 = 4;
    }

    *uint64_t v8 = v19;
  }

  else if (sub_1000A86F0())
  {
    sub_1001EE134((uint64_t)"%!", v9, v10, v11, v12, v13, v14, v15, 103LL);
    uint64_t v16 = (os_log_s *)sub_100086554(0x32u);
    if (os_log_type_enabled(v16, OS_LOG_TYPE_ERROR)) {
      sub_100657858();
    }
  }

uint64_t sub_1001DAF18(uint64_t a1, uint64_t a2)
{
  uint64_t v4 = *(void *)(a1 + 88);
  *(void *)(a1 + 88) = 0LL;
  sub_1001EF6C0(v4);
  return (*(uint64_t (**)(void, uint64_t, uint64_t))(a1 + 80))(*(unsigned __int16 *)(a1 + 8), v4, a2);
}

void sub_1001DAF60(int a1, void *a2, uint64_t a3, uint64_t a4)
{
  uint64_t v4 = a4;
  uint64_t v57 = 0LL;
  if (!(_DWORD)a4
    || !sub_1000A86F0()
    || (sub_1001EE134((uint64_t)"RFCOMM Write failed %!", v7, v8, v9, v10, v11, v12, v13, v4),
        uint64_t v14 = (os_log_s *)sub_100086554(0x32u),
        !os_log_type_enabled(v14, OS_LOG_TYPE_ERROR)))
  {
    if (a2) {
      goto LABEL_6;
    }
    goto LABEL_5;
  }

  sub_100657858();
  if (!a2) {
LABEL_5:
  }
    sub_1001EE2A0();
LABEL_6:
  uint64_t v15 = sub_1001D8EC4(a1);
  if (v15)
  {
    uint64_t v16 = v15;
    *(void *)(v16 + 72) = 0LL;
    sub_1001EF69C(a2);
    int v17 = *(unsigned __int8 *)(v16 + 80);
    uint64_t v18 = *(unsigned __int8 *)(v16 + 81);
    if (!*(_BYTE *)(v16 + 80)) {
      goto LABEL_19;
    }
    uint64_t v19 = sub_1001D89B0(v16, *(unsigned __int8 *)(v16 + 81), &v57);
    if ((_DWORD)v19)
    {
      uint64_t v20 = v19;
      if (sub_1000A86F0())
      {
        sub_1001EE134((uint64_t)"%! (%d)", v21, v22, v23, v24, v25, v26, v27, v20);
        uint64_t v28 = (os_log_s *)sub_100086554(0x32u);
        if (os_log_type_enabled(v28, OS_LOG_TYPE_ERROR)) {
          sub_100657858();
        }
      }

      return;
    }

    if ((_DWORD)v4) {
      goto LABEL_19;
    }
    if (!sub_1001EFF04(*(void *)(v57 + 88), *(unsigned __int16 *)(v57 + 16)))
    {
      uint64_t v4 = 0LL;
LABEL_19:
      if (*(void *)(v16 + 56) != v16 + 56)
      {
        uint64_t v37 = sub_1001EF264((void **)(v16 + 56));
        uint64_t v38 = (void **)(v37 - 16);
        if (sub_100172A98( (uint64_t)sub_1001DAF60,  *(unsigned __int16 *)(v16 + 2),  0LL,  *(void *)(v37 - 16),  0))
        {
          sub_1001EF69C(*v38);
          if (sub_1000A86F0())
          {
            sub_1001EE134((uint64_t)"Write failed", v39, v40, v41, v42, v43, v44, v45, v56);
            uint64_t v46 = (os_log_s *)sub_100086554(0x32u);
            if (os_log_type_enabled(v46, OS_LOG_TYPE_ERROR)) {
              sub_100657858();
            }
          }
        }

        else
        {
          *(_WORD *)(v16 + 80) = *(_WORD *)(v37 - 8);
          *(void *)(v16 + 72) = *(void *)(v37 - 16);
        }

        sub_1000B1838(v38);
      }

      if (v17)
      {
        uint64_t v47 = v57;
        if (!v57)
        {
          sub_1001EE2A0();
          uint64_t v47 = v57;
        }

        uint64_t v48 = *(void *)(v47 + 88);
        *(void *)(v47 + 88) = 0LL;
        sub_1001EF6C0(v48);
        (*(void (**)(void, uint64_t, uint64_t))(v47 + 80))(*(unsigned __int16 *)(v47 + 8), v48, v4);
      }

      else if ((_DWORD)v18 && !sub_1001D89B0(v16, v18, &v57))
      {
        uint64_t v49 = v57;
        int v50 = *(unsigned __int8 *)(v57 + 11);
        *(_BYTE *)(v57 + 11) = 0;
        if (v50 == 15)
        {
          int v53 = *(unsigned __int8 *)(v49 + 13);
          if (v53 != 6 && v53 != 9)
          {
            sub_1001EE2A0();
            int v53 = *(unsigned __int8 *)(v49 + 13);
          }

          if (v53 == 9) {
            sub_1001D8CE8(v49, 1);
          }
        }

        else if (v50 == 99)
        {
          int v51 = *(unsigned __int8 *)(v49 + 13);
          if (v51 == 8)
          {
            uint64_t v54 = *(void (**)(uint64_t, void, uint64_t))(v49 + 72);
            uint64_t v55 = *(unsigned __int16 *)(v49 + 8);
            sub_1001D8CE8(v49, 0);
            v54(v55, 0LL, 927LL);
          }

          else if (v51 == 7)
          {
            *(_DWORD *)(v49 + 164) = 927;
            sub_1001DC258(v49, 0LL);
          }
        }
      }

      return;
    }

    if (!sub_1001DBC18(v57))
    {
      *(_BYTE *)(v57 + 96) = 1;
      return;
    }

    uint64_t v52 = sub_1001DC578(v16, v18, *(void *)(v57 + 88), 0, 1LL);
    if ((_DWORD)v52)
    {
      uint64_t v4 = v52;
      if ((_DWORD)v52 == 410)
      {
        sub_1001EE2A0();
        uint64_t v4 = 410LL;
      }

      goto LABEL_19;
    }
  }

  else
  {
    if (sub_1000A86F0())
    {
      sub_1001EE134( (uint64_t)"RFCOMM session has gone away - freeing orphaned MBUF %lx",  v29,  v30,  v31,  v32,  v33,  v34,  v35,  (uint64_t)a2);
      uint64_t v36 = (os_log_s *)sub_100086554(0x32u);
      if (os_log_type_enabled(v36, OS_LOG_TYPE_ERROR)) {
        sub_100657858();
      }
    }

    sub_1001EF69C(a2);
  }

void sub_1001DB2D8(uint64_t a1, uint64_t a2, unsigned int a3)
{
  if (dword_1008F6FD0)
  {
    uint64_t v23 = (_BYTE *)sub_1001D8F70(a2);
    if (v23 || sub_1001D94EC(a2, a3, (uint64_t *)&v23))
    {
      unsigned int v5 = a3;
      uint64_t v6 = 0LL;
      int v7 = 0;
LABEL_5:
      sub_100174B2C( (uint64_t)sub_1001DADFC,  (uint64_t)sub_1001DB478,  (uint64_t)sub_1001DAD74,  v5,  (uint64_t)v6,  v7,  (uint64_t)&unk_1006BDE20);
      return;
    }

    uint64_t v16 = v23;
    if (!v23)
    {
      sub_1001EE2A0();
      uint64_t v16 = v23;
    }

    *uint64_t v16 = 3;
    __int128 v21 = 0u;
    __int128 v22 = 0u;
    sub_1001EDBA0(0x28u);
    *(_DWORD *)((char *)&v21 + 2) = 327745535;
    WORD3(v21) = 776;
    WORD6(v21) = 0;
    BYTE8(vmemset(v6, 0, 22) = 0;
    unsigned int v17 = sub_1001D9828();
    __int16 v18 = sub_1001D9828();
    if (v17 <= 0x7F) {
      __int16 v19 = 5;
    }
    else {
      __int16 v19 = 6;
    }
    LOWORD(v21) = v18 + v19;
    if ((unsigned __int16)(v18 + v19) > 0x80u)
    {
      if (*(unsigned __int16 *)(sub_1001EDBA0(0x28u) + 8) >= (unsigned __int16)(v18 + v19))
      {
LABEL_20:
        uint64_t v6 = &v21;
        unsigned int v5 = a3;
        int v7 = 1;
        goto LABEL_5;
      }

      __int16 v20 = *(_WORD *)(sub_1001EDBA0(0x28u) + 8);
    }

    else
    {
      __int16 v20 = 128;
    }

    LOWORD(v21) = v20;
    goto LABEL_20;
  }

  if (sub_1000A86F0())
  {
    sub_1001EE134((uint64_t)"%!", v8, v9, v10, v11, v12, v13, v14, 103LL);
    uint64_t v15 = (os_log_s *)sub_100086554(0x32u);
    if (os_log_type_enabled(v15, OS_LOG_TYPE_ERROR)) {
      sub_100657858();
    }
  }

void sub_1001DB478(int a1, uint64_t a2)
{
  if (sub_1000A86F0())
  {
    sub_1001EE134((uint64_t)"RFCOMM's L2CAP link disconnected uint64_t result = %!", v4, v5, v6, v7, v8, v9, v10, a2);
    uint64_t v11 = (os_log_s *)sub_100086554(0x32u);
    if (os_log_type_enabled(v11, OS_LOG_TYPE_DEFAULT))
    {
      *(_DWORD *)__int128 buf = 136446210;
      __int128 v22 = sub_1001EDDCC();
      _os_log_impl((void *)&_mh_execute_header, v11, OS_LOG_TYPE_DEFAULT, " %{public}s", buf, 0xCu);
    }
  }

  if (dword_1008F6FD0)
  {
    uint64_t v12 = (unsigned __int8 *)sub_1001D8EC4(a1);
    if (v12) {
      sub_1001D902C(v12, a2, *v12 == 10);
    }
  }

  else if (sub_1000A86F0())
  {
    sub_1001EE134((uint64_t)"%!", v13, v14, v15, v16, v17, v18, v19, 103LL);
    __int16 v20 = (os_log_s *)sub_100086554(0x32u);
    if (os_log_type_enabled(v20, OS_LOG_TYPE_ERROR)) {
      sub_100657858();
    }
  }

uint64_t sub_1001DB5C0(uint64_t a1)
{
  if (a1
    && *(void *)a1
    && (unsigned __int8 v2 = *(void **)(a1 + 8)) != 0LL
    && (uint64_t v3 = *(void **)(a1 + 16)) != 0LL
    && (uint64_t v4 = *(void **)(a1 + 24)) != 0LL
    && (uint64_t v5 = *(void **)(a1 + 32)) != 0LL)
  {
    uint64_t result = 0LL;
    off_1008EDBF8 = *(_UNKNOWN **)a1;
    off_1008EDC00 = v2;
    off_1008EDC08 = v3;
    off_1008EDC10 = v4;
    off_1008EDC18 = v5;
  }

  else
  {
    sub_1001EE0E4("BTVirtualTransportRegisterCBs invalid cbs\n");
    return 114LL;
  }

  return result;
}

uint64_t sub_1001DB654()
{
  if (qword_1008EDC20 != -1) {
    dispatch_once(&qword_1008EDC20, &stru_100886158);
  }
  if (qword_1008EDC28) {
    return 0LL;
  }
  else {
    return 114LL;
  }
}

void sub_1001DB6A0(int a1, int a2, unsigned int a3)
{
  if (!off_1008EDC10) {
    sub_1001EE2A0();
  }
  sub_1001EE0E4("BTVirtual transport send packet type: 0x%x\n", a1);
  if (a1 == 1)
  {
    unsigned int v6 = 3;
    uint64_t v7 = &qword_1008EDC38;
  }

  else
  {
    if (a1 != 2)
    {
      sub_1001EE0E4("Virtual transport default packet type: 0x%x\n", a1);
      return;
    }

    unsigned int v6 = 4;
    uint64_t v7 = &qword_1008EDC48;
  }

  uint64_t v8 = *v7;
  uint64_t v9 = v6;
  uint64_t v10 = malloc(v6 + (unint64_t)a3);
  if (!v10) {
    sub_10065C9DC();
  }
  uint64_t v11 = v10;
  *(_WORD *)uint64_t v10 = a2;
  v10[2] = a3;
  if (a1 == 2) {
    v10[3] = BYTE1(a3);
  }
  if (a3) {
    sub_10011EF64(&v10[v9]);
  }
  else {
    sub_1000BA1F0();
  }
  sub_1001EE0E4("BTVirtual transport send packet type: 0x%x 0x%x\n", a1, a2);
  int v12 = 0;
  if ((off_1008EDC10(v8, v11, v9 + a3, &v12, 0xFFFFFFFFLL, sub_1001DBBDC) & 1) == 0
    && (byte_1008EDC30 & 1) == 0)
  {
    sub_1001EE0E4("Virtual transport write failed: type %u\n", a1);
    __break(1u);
  }

uint64_t sub_1001DB814()
{
  return 0LL;
}

void sub_1001DB81C(id a1)
{
  uint64_t v1 = dispatch_queue_attr_make_with_qos_class(0LL, QOS_CLASS_DEFAULT, 0);
  qword_1008EDC28 = (uint64_t)dispatch_queue_create("com.apple.bluetoothd.virtual-event", v1);
}

uint64_t sub_1001DB854()
{
  return 0LL;
}

uint64_t sub_1001DB85C()
{
  if (off_1008EDBF8) {
    BOOL v0 = off_1008EDC00 == 0LL;
  }
  else {
    BOOL v0 = 1;
  }
  if (v0 || off_1008EDC08 == 0LL || off_1008EDC10 == 0LL || off_1008EDC18 == 0LL)
  {
    sub_1001EE0E4("BTVirtual transport init failed, callbacks error");
    return 633LL;
  }

  else
  {
    uint64_t v11 = 0LL;
    __int128 v9 = 0u;
    __int128 v10 = 0u;
    __int128 v7 = 0u;
    __int128 v8 = 0u;
    __int128 v6 = 0u;
    byte_1008EDC30 = 0;
    off_1008EDBF8(&v6);
    LODWORD(v6) = 2;
    DWORD2(v7) = 5000;
    LODWORD(v8) = v8 | 0xC;
    *(void *)((char *)&v8 + 4) = 0x10200000020LL;
    LODWORD(v11) = 25;
    *(void *)&__int128 v7 = &stru_100886198;
    *(void *)&__int128 v9 = &stru_1008861D8;
    *((void *)&v9 + 1) = &stru_100886218;
    char v5 = off_1008EDC00(&v6, &qword_1008EDC38);
    uint64_t result = 0LL;
    if ((v5 & 1) == 0) {
      sub_10065C9F4();
    }
  }

  return result;
}

void sub_1001DB974(id a1, int a2, void *a3, void *a4)
{
}

void sub_1001DB9A0(id a1, int a2, void *a3, unsigned int a4)
{
  if (!a2)
  {
    if ((byte_1008EDC30 & 1) == 0)
    {
      if ((byte_1008EDC40 & 1) == 0)
      {
        v8[1] = 0LL;
        v8[0] = mach_continuous_time();
        uint64_t v7 = sub_10012F6A8(4, (unsigned __int8 *)a3, (unsigned __int16)a4);
        sub_1001EE0E4("BTVirtual handle_read OI_HCIIfc_DataReceived\n");
        sub_10012F73C(4LL, (unsigned __int8 *)a3, v7, (uint64_t)v8);
        if (!a3) {
          return;
        }
LABEL_8:
        free(a3);
        return;
      }

      sub_1001EE0E4("BTVirtual handle_read OI_SNIFF_LogReceive\n");
      sub_1000BA78C();
    }

    if (!a3) {
      return;
    }
    goto LABEL_8;
  }

  if ((byte_1008EDC30 & 1) == 0) {
    sub_1001EE0E4("Virtual read failed: type %u, status 0x%x\n", 4, a2);
  }
}

void sub_1001DBAA4(id a1, int a2, void *a3, unsigned int a4)
{
  if (a2)
  {
    if ((byte_1008EDC30 & 1) == 0)
    {
      sub_1001EE0E4("Virtual transport HCI write failed: 0x%x\n", a2);
      __break(1u);
    }
  }

void sub_1001DBAE0()
{
  if (off_1008EDC18) {
    BOOL v0 = off_1008EDC08 == 0LL;
  }
  else {
    BOOL v0 = 1;
  }
  if (!v0)
  {
    if (off_1008EDC18(qword_1008EDC50))
    {
      if ((off_1008EDC08(&qword_1008EDC50) & 1) == 0) {
        sub_10065CA10();
      }
    }
  }

uint64_t sub_1001DBBA0()
{
  return 0LL;
}

uint64_t sub_1001DBBA8()
{
  return 0LL;
}

uint64_t sub_1001DBBD4()
{
  return 2594LL;
}

void sub_1001DBBDC(void *a1)
{
  if (a1) {
    free(a1);
  }
}

uint64_t sub_1001DBBE8()
{
  return 0LL;
}

uint64_t sub_1001DBBF0()
{
  return 0LL;
}

void sub_1001DBBF8()
{
  byte_1008EDC30 = 1;
}

void sub_1001DBC08()
{
  byte_1008EDC40 = 1;
}

BOOL sub_1001DBC18(uint64_t a1)
{
  if (!a1) {
    sub_1001EE2A0();
  }
  uint64_t v2 = *(void *)(a1 + 128);
  if (!*(_BYTE *)(v2 + 44)) {
    return *(_BYTE *)(a1 + 32) && *(_BYTE *)(v2 + 45);
  }
  return *(_WORD *)(a1 + 18) != 0;
}

uint64_t sub_1001DBC70(uint64_t a1)
{
  if (!a1) {
    sub_1001EE2A0();
  }
  unsigned int v2 = *(unsigned __int16 *)(a1 + 160);
  if (!*(_WORD *)(a1 + 160))
  {
    uint64_t result = 0LL;
    *(_BYTE *)(a1 + 162) = 0;
    goto LABEL_13;
  }

  if (v2 >= 0xFF) {
    unsigned int v2 = 255;
  }
  *(_BYTE *)(a1 + 162) = v2;
  uint64_t v3 = (_BYTE *)(a1 + 162);
  *(_BYTE *)(a1 + 163) = 0;
  uint64_t v4 = sub_1000B17F4(24 * v2);
  *(void *)(a1 + 104) = v4;
  if (v4)
  {
    if (*v3)
    {
      uint64_t v5 = 0LL;
      unint64_t v6 = 0LL;
      while (1)
      {
        uint64_t v7 = sub_1000B17F4(*(unsigned __int16 *)(a1 + 16));
        __int128 v8 = *(char **)(a1 + 104);
        __int128 v9 = &v8[v5];
        *(void *)__int128 v9 = v7;
        *((_WORD *)v9 + 4) = 0;
        if (!v7) {
          break;
        }
        ++v6;
        v5 += 24LL;
      }

      if (v6)
      {
        uint64_t v11 = 0LL;
        do
        {
          sub_1000B1838(*(void **)(*(void *)(a1 + 104) + v11));
          v11 += 24LL;
          --v6;
        }

        while (v6);
        __int128 v8 = *(char **)(a1 + 104);
      }

      sub_1000B1838(v8);
      uint64_t result = 106LL;
      goto LABEL_14;
    }

uint64_t sub_1001DBD64(uint64_t a1)
{
  if (!a1) {
    sub_1001EE2A0();
  }
  if (*(_BYTE *)(a1 + 162))
  {
    uint64_t v2 = sub_1001DBE60(a1);
    if (v2)
    {
      int v3 = 0;
      int v4 = 0;
      do
      {
        v4 += *(unsigned __int16 *)(v2 + 8);
        uint64_t v2 = sub_1001DBE60(a1);
        --v3;
      }

      while (v2);
      if (v3)
      {
        if (sub_1000A86F0())
        {
          sub_1001EE134( (uint64_t)"%d rcv packets discarded (%d bytes total)",  v5,  v6,  v7,  v8,  v9,  v10,  v11,  -v3);
          int v12 = (os_log_s *)sub_100086554(0x32u);
          if (os_log_type_enabled(v12, OS_LOG_TYPE_ERROR)) {
            sub_100657858();
          }
        }
      }
    }

    if (*(_BYTE *)(a1 + 162))
    {
      uint64_t v13 = 0LL;
      unint64_t v14 = 0LL;
      do
      {
        sub_1000B1838(*(void **)(*(void *)(a1 + 104) + v13));
        ++v14;
        v13 += 24LL;
      }

      while (v14 < *(unsigned __int8 *)(a1 + 162));
      if (*(_BYTE *)(a1 + 162))
      {
        sub_1000B1838(*(void **)(a1 + 104));
        *(void *)(a1 + 104) = 0LL;
        *(_WORD *)(a1 + 162) = 0;
      }
    }
  }

  return 0LL;
}

uint64_t sub_1001DBE60(uint64_t a1)
{
  if (!a1) {
    sub_1001EE2A0();
  }
  uint64_t result = *(void *)(a1 + 112);
  if (result)
  {
    *(void *)(a1 + 112) = *(void *)(result + 16);
    if (result == *(void *)(a1 + 120)) {
      *(void *)(a1 + 120) = 0LL;
    }
    --*(_BYTE *)(a1 + 163);
  }

  return result;
}

uint64_t sub_1001DBEB0(uint64_t a1, const void *a2, uint64_t a3)
{
  if (!a1) {
    sub_1001EE2A0();
  }
  unsigned int v6 = *(unsigned __int16 *)(a1 + 16);
  if (v6 >= a3)
  {
    if (!(_DWORD)a3) {
      return 0LL;
    }
  }

  else
  {
    sub_1001EE2A0();
    unsigned int v6 = *(unsigned __int16 *)(a1 + 16);
  }

  if (v6 < a3)
  {
    if (sub_1000A86F0())
    {
      sub_1001EE134( (uint64_t)"Received RFCOMM packet with larger payload size %d than set on link (%d)",  v7,  v8,  v9,  v10,  v11,  v12,  v13,  a3);
      unint64_t v14 = (os_log_s *)sub_100086554(0x32u);
      if (os_log_type_enabled(v14, OS_LOG_TYPE_ERROR)) {
        sub_100657858();
      }
    }

    return 104LL;
  }

  if (!*(_BYTE *)(a1 + 162)) {
    return 104LL;
  }
  uint64_t v15 = 0LL;
  uint64_t v16 = *(void *)(a1 + 104);
  while (1)
  {
    uint64_t v17 = v16 + v15;
    if (!*(_WORD *)(v16 + v15 + 8)) {
      break;
    }
    v15 += 24LL;
  }

  *(_WORD *)(v17 + 8) = a3;
  memmove(*(void **)v17, a2, a3);
  uint64_t v19 = *(void *)(a1 + 104);
  if (!v19) {
    sub_1001EE2A0();
  }
  uint64_t v20 = v19 + v15;
  __int128 v21 = (void *)(a1 + 112);
  if (*(void *)(a1 + 112)) {
    __int128 v21 = (void *)(*(void *)(a1 + 120) + 16LL);
  }
  uint64_t result = 0LL;
  *__int128 v21 = v20;
  *(void *)(v19 + v15 + 16) = 0LL;
  *(void *)(a1 + 120) = v20;
  ++*(_BYTE *)(a1 + 163);
  return result;
}

uint64_t sub_1001DBFF0(uint64_t a1, unsigned int a2)
{
  if (!a1) {
    sub_1001EE2A0();
  }
  if (!*(_BYTE *)(*(void *)(a1 + 128) + 44LL)) {
    sub_1001EE2A0();
  }
  uint64_t result = sub_1001DC780(*(void *)(a1 + 128), *(unsigned __int8 *)(a1 + 10), 0LL, 0LL, a2);
  if (!(_DWORD)result) {
    *(_BYTE *)(a1 + 14) += a2;
  }
  return result;
}

uint64_t sub_1001DC064(uint64_t a1)
{
  if (!a1) {
    sub_1001EE2A0();
  }
  uint64_t result = sub_1001DBC18(a1);
  if ((_DWORD)result && *(_BYTE *)(a1 + 96))
  {
    uint64_t result = sub_1001DC578(*(void *)(a1 + 128), *(unsigned __int8 *)(a1 + 10), *(void *)(a1 + 88), 0, 1LL);
    if (!(_DWORD)result) {
      *(_BYTE *)(a1 + 96) = 0;
    }
  }

  return result;
}

void sub_1001DC0BC(uint64_t a1)
{
  if (!a1) {
    sub_1001EE2A0();
  }
  int v4 = *(void **)(a1 + 16);
  uint64_t v2 = (void *)(a1 + 16);
  for (uint64_t i = v4; i && i != v2; uint64_t i = (void *)*i)
    sub_1001DC064((uint64_t)(i - 18));
}

uint64_t sub_1001DC100(uint64_t a1)
{
  if (!a1) {
    sub_1001EE2A0();
  }
  return sub_1001EEB14(*(unsigned int *)(a1 + 40));
}

uint64_t sub_1001DC128(uint64_t a1, int a2)
{
  uint64_t v15 = a1;
  v14[0] = 0LL;
  int v3 = (int *)(a1 + 40);
  sub_1001EEB14(*(unsigned int *)(a1 + 40));
  v14[1] = &v15;
  LOWORD(v14[0]) = 8;
  uint64_t v4 = sub_1001EE6E8((uint64_t)sub_1001DC1D8, v14, a2, v3);
  if ((_DWORD)v4)
  {
    if (sub_1000A86F0())
    {
      sub_1001EE134((uint64_t)"Error registering session shutdown dispatch - %!", v5, v6, v7, v8, v9, v10, v11, v4);
      uint64_t v12 = (os_log_s *)sub_100086554(0x32u);
      if (os_log_type_enabled(v12, OS_LOG_TYPE_ERROR)) {
        sub_100657858();
      }
    }
  }

  return v4;
}

void sub_1001DC1D8(uint64_t a1)
{
  uint64_t v1 = sub_1001D8D80(**(void **)(a1 + 8), 1LL, 930LL);
  if ((_DWORD)v1)
  {
    uint64_t v2 = v1;
    if (sub_1000A86F0())
    {
      sub_1001EE134((uint64_t)"RFCOMM session shutdown failed - %!", v3, v4, v5, v6, v7, v8, v9, v2);
      uint64_t v10 = (os_log_s *)sub_100086554(0x32u);
      if (os_log_type_enabled(v10, OS_LOG_TYPE_ERROR)) {
        sub_100657858();
      }
    }
  }

uint64_t sub_1001DC258(uint64_t a1, uint64_t a2)
{
  if (!a1) {
    sub_1001EE2A0();
  }
  *(_BYTE *)(a1 + 13) = 9;
  sub_1001D8C08(a1);
  (**(void (***)(void, void))(a1 + 40))(*(unsigned __int16 *)(a1 + 8), *(unsigned int *)(a1 + 164));
  return sub_1001D8CE8(a1, a2);
}

uint64_t sub_1001DC2AC(int a1, uint64_t a2, int a3)
{
  if (*(_BYTE *)(a2 + 12)) {
    int v6 = 67;
  }
  else {
    int v6 = 99;
  }
  if (*(_BYTE *)(a2 + 12)) {
    int v7 = 47;
  }
  else {
    int v7 = 15;
  }
  if (v7 == a1 || v6 == a1) {
    char v9 = 3;
  }
  else {
    char v9 = 1;
  }
  __int16 v28 = 1;
  v27[0] = v9 | (4 * a3);
  v27[1] = a1 | 0x10;
  HIBYTE(v28) = sub_1001DD8C0(v27, 3);
  uint64_t v10 = sub_1001EF80C(v27, 4uLL, 0);
  if (!v10) {
    return 106LL;
  }
  uint64_t v11 = v10;
  uint64_t v12 = sub_1001DC470(a2, a3, (uint64_t)v10, 0);
  if (!(_DWORD)v12)
  {
    uint64_t v26 = 0LL;
    if (a3)
    {
      uint64_t v22 = sub_1001D89B0(a2, a3, &v26);
      if ((_DWORD)v22) {
        return v22;
      }
      uint64_t v23 = v26;
      *(_BYTE *)(v26 + 11) = a1;
      if (a1 == 47)
      {
        char v24 = 2;
      }

      else
      {
        if (a1 != 67) {
          return 0LL;
        }
        char v24 = 6;
      }

      *(_BYTE *)(v23 + 13) = v24;
    }

    else if (a1 != 47 && a1 != 67)
    {
      return 0LL;
    }

    sub_1001DD978(a2);
    return 0LL;
  }

  uint64_t v13 = v12;
  if (sub_1000A86F0())
  {
    sub_1001EE134((uint64_t)"%! (%d)", v14, v15, v16, v17, v18, v19, v20, v13);
    __int128 v21 = (os_log_s *)sub_100086554(0x32u);
    if (os_log_type_enabled(v21, OS_LOG_TYPE_ERROR)) {
      sub_100657858();
    }
  }

  sub_1001EF69C(v11);
  return v13;
}

uint64_t sub_1001DC470(uint64_t a1, char a2, uint64_t a3, char a4)
{
  if (!a1) {
    sub_1001EE2A0();
  }
  int v8 = sub_100172A98((uint64_t)sub_1001DAF60, *(unsigned __int16 *)(a1 + 2), 0LL, a3, 0);
  if (!v8)
  {
    uint64_t v10 = 0LL;
    *(_BYTE *)(a1 + 80) = a4;
    *(_BYTE *)(a1 + 81) = a2;
    *(void *)(a1 + 72) = a3;
    return v10;
  }

  if (v8 == 410)
  {
    char v9 = sub_1000B17F4(0x20uLL);
    if (v9)
    {
      *(void *)char v9 = a3;
      v9[8] = a4;
      v9[9] = a2;
      sub_1001EF1D0((void *)v9 + 2, a1 + 56);
      return 0LL;
    }

    return 106LL;
  }

  uint64_t v11 = sub_1000B17F4(0x20uLL);
  if (!v11) {
    return 106LL;
  }
  uint64_t v12 = v11;
  *uint64_t v11 = a3;
  *((_BYTE *)v11 + 8) = a4;
  uint64_t v13 = v11 + 2;
  *((_BYTE *)v11 + 9) = a2;
  sub_1001EF1D0(v11 + 2, a1 + 56);
  uint64_t v10 = sub_1001DC128(a1, 0);
  if ((_DWORD)v10)
  {
    sub_1001EF1E4(v13);
    sub_1000B1838(v12);
  }

  return v10;
}

uint64_t sub_1001DC578(uint64_t a1, uint64_t a2, uint64_t a3, unsigned int a4, uint64_t a5)
{
  if (a1)
  {
    if (a3) {
      goto LABEL_3;
    }
  }

  else
  {
    sub_1001EE2A0();
    if (a3) {
      goto LABEL_3;
    }
  }

  sub_1001EE2A0();
LABEL_3:
  char v22 = 0;
  int v21 = 0;
  uint64_t v19 = 0LL;
  unsigned int v10 = *(unsigned __int16 *)(a3 + 4);
  size_t v11 = sub_1001DC6F4(a1, a2, v10, a4, &v21);
  char v20 = sub_1001DD8C0((char *)&v21, 2);
  uint64_t v12 = (unsigned __int8 *)sub_1001EF29C(3u);
  if (!v12) {
    return 106LL;
  }
  uint64_t v13 = v12;
  sub_1001EFB10(v12, (char *)&v21, v11, 0);
  sub_1001EFC20(v13, a3);
  sub_1001EFB10(v13, &v20, 1uLL, 0);
  if (*(_BYTE *)(a1 + 44) && (_DWORD)a2 && v10)
  {
    uint64_t v14 = sub_1001D89B0(a1, a2, &v19);
    if ((_DWORD)v14)
    {
LABEL_14:
      sub_1001EF69C(v13);
      return v14;
    }

    uint64_t v15 = v19;
    int v16 = *(unsigned __int8 *)(v19 + 14);
    if (v16 + a4 >= 0x100)
    {
      sub_1001EE2A0();
      uint64_t v15 = v19;
      LOBYTE(v16) = *(_BYTE *)(v19 + 14);
    }

    *(_BYTE *)(v15 + 14) = v16 + a4;
    __int16 v17 = *(_WORD *)(v15 + 18);
    if (!v17)
    {
      sub_1001EE2A0();
      uint64_t v15 = v19;
      __int16 v17 = *(_WORD *)(v19 + 18);
    }

    *(_WORD *)(v15 + 18) = v17 - 1;
  }

  uint64_t v14 = sub_1001DC470(a1, a2, v13, a5);
  if ((_DWORD)v14) {
    goto LABEL_14;
  }
  return v14;
}

uint64_t sub_1001DC6F4(uint64_t a1, char a2, unsigned int a3, unsigned int a4, _BYTE *a5)
{
  if (*(_BYTE *)(a1 + 12)) {
    char v5 = 3;
  }
  else {
    char v5 = 1;
  }
  *a5 = v5 | (4 * a2);
  char v6 = 2 * a3;
  if (a4)
  {
    a5[1] = -1;
    if (a3 < 0x80)
    {
      a5[2] = v6 | 1;
LABEL_11:
      uint64_t result = 4LL;
      uint64_t v8 = 3LL;
      goto LABEL_12;
    }

    a5[2] = v6;
    a5[3] = a3 >> 7;
    uint64_t result = 5LL;
    uint64_t v8 = 4LL;
  }

  else
  {
    a5[1] = -17;
    if (a3 >= 0x80)
    {
      a5[2] = v6;
      a4 = a3 >> 7;
      goto LABEL_11;
    }

    LOBYTE(a4) = v6 | 1;
    uint64_t result = 3LL;
    uint64_t v8 = 2LL;
  }

uint64_t sub_1001DC780(uint64_t a1, uint64_t a2, char *a3, size_t a4, unsigned int a5)
{
  if ((_DWORD)a2 && (_DWORD)a4) {
    sub_1001EE2A0();
  }
  unsigned int v10 = sub_1001EF29C(3u);
  if (!v10) {
    return 106LL;
  }
  size_t v11 = (unsigned __int8 *)v10;
  char v17 = 0;
  int v15 = 0;
  char v16 = 0;
  size_t v12 = sub_1001DC6F4(a1, a2, a4, a5, &v15);
  uint64_t v13 = sub_1001EFB10(v11, (char *)&v15, v12, 0);
  if ((_DWORD)v13
    || (uint64_t v13 = sub_1001EFB10(v11, a3, a4, 0), (_DWORD)v13)
    || (v17 = sub_1001DD8C0((char *)&v15, 2), uint64_t v13 = sub_1001EFB10(v11, &v17, 1uLL, 0), (_DWORD)v13)
    || (uint64_t v13 = sub_1001DC470(a1, a2, v11, 0LL), (_DWORD)v13))
  {
    sub_1001EF69C(v11);
  }

  return v13;
}

void sub_1001DC898(int a1, uint64_t a2, uint64_t a3)
{
  uint64_t v5 = sub_1001D8EC4(a1);
  if (!v5) {
    return;
  }
  if (a3 > 3)
  {
    uint64_t v14 = (unsigned __int8 *)v5;
    int v15 = *(unsigned __int8 *)(a2 + 1);
    unsigned int v16 = v15 & 0xFFFFFFEF;
    if ((v15 & 0xFFFFFFEF) - 47 > 0x34 || ((1LL << ((v15 & 0xEFu) - 47)) & 0x10000000100001LL) == 0)
    {
      if (v16 == 239)
      {
        if (sub_1001DD944(*(_BYTE *)a2, v15, *(unsigned __int8 *)(a2 + (a3 - 1))))
        {
          if (sub_1000A86F0())
          {
            sub_1001EE134((uint64_t)"UIH FCS Error: %@", v27, v28, v29, v30, v31, v32, v33, a2);
            uint64_t v34 = (os_log_s *)sub_100086554(0x32u);
            if (os_log_type_enabled(v34, OS_LOG_TYPE_ERROR)) {
              goto LABEL_24;
            }
          }
        }

        else
        {
          sub_1001DD3D4(v14, (unsigned __int8 *)a2, a3, v26);
        }

        return;
      }

      if (v16 != 15) {
        return;
      }
    }

    if (sub_1001DD904( *(_BYTE *)a2,  v15,  *(_BYTE *)(a2 + 2),  *(unsigned __int8 *)(a2 + (a3 - 1))))
    {
      if (sub_1000A86F0())
      {
        sub_1001EE134((uint64_t)"FCS Error: %@", v18, v19, v20, v21, v22, v23, v24, a2);
        uint64_t v25 = (os_log_s *)sub_100086554(0x32u);
        if (os_log_type_enabled(v25, OS_LOG_TYPE_ERROR)) {
          goto LABEL_24;
        }
      }
    }

    else if (v16 > 0x42u)
    {
      if (v16 == 67)
      {
        sub_1001DCF40(v14, (unsigned __int8 *)a2);
      }

      else if (v16 == 99)
      {
        sub_1001DCC94(v14, (unsigned __int8 *)a2);
      }
    }

    else if (v16 == 15)
    {
      sub_1001DD1A4(v14, (unsigned __int8 *)a2);
    }

    else if (v16 == 47)
    {
      sub_1001DCACC(v14, (unsigned __int8 *)a2);
    }
  }

  else if (sub_1000A86F0())
  {
    sub_1001EE134((uint64_t)"OI_Rfcomm_ReceiveFrame invalid frame length=%d", v6, v7, v8, v9, v10, v11, v12, a3);
    uint64_t v13 = (os_log_s *)sub_100086554(0x32u);
    if (os_log_type_enabled(v13, OS_LOG_TYPE_ERROR)) {
LABEL_24:
    }
      sub_100657858();
  }

unsigned __int8 *sub_1001DCACC(unsigned __int8 *result, unsigned __int8 *a2)
{
  unsigned int v2 = *a2;
  if ((v2 & 1) != 0 && (a2[1] & 0x10) != 0)
  {
    uint64_t v3 = result;
    if (result[12])
    {
      if ((v2 & 2) != 0) {
        return result;
      }
    }

    else if ((v2 & 2) == 0)
    {
      return result;
    }

    uint64_t v25 = 0LL;
    unsigned int v4 = v2 >> 2;
    int v5 = *result;
    if (v5 != 7)
    {
      if (v5 == 4 && v2 <= 3)
      {
        uint64_t result = (unsigned __int8 *)sub_1001DC2AC(99LL, result, v2 >> 2);
        if (!(_DWORD)result) {
          *uint64_t v3 = 7;
        }
        return result;
      }

      return (unsigned __int8 *)sub_1001DC2AC(15LL, v3, v2 >> 2);
    }

    if (v2 > 0xF7 || v4 == 1)
    {
      if (sub_1000A86F0())
      {
        sub_1001EE134((uint64_t)"%! (%d)", v16, v17, v18, v19, v20, v21, v22, 912LL);
        uint64_t v23 = (os_log_s *)sub_100086554(0x32u);
        if (os_log_type_enabled(v23, OS_LOG_TYPE_ERROR)) {
          sub_100657858();
        }
      }

      return (unsigned __int8 *)sub_1001DC2AC(15LL, v3, v2 >> 2);
    }

    if (sub_1001D89B0((uint64_t)result, v2 >> 2, &v25))
    {
      uint64_t v6 = sub_1001D8A44((uint64_t)v3, v2 >> 2, &v25);
      if ((_DWORD)v6)
      {
        uint64_t v7 = v6;
        if (sub_1000A86F0())
        {
          sub_1001EE134((uint64_t)"%! (%d)", v8, v9, v10, v11, v12, v13, v14, v7);
          int v15 = (os_log_s *)sub_100086554(0x32u);
          if (os_log_type_enabled(v15, OS_LOG_TYPE_ERROR)) {
            sub_100657858();
          }
        }

        return (unsigned __int8 *)sub_1001DC2AC(15LL, v3, v2 >> 2);
      }

      uint64_t v24 = v25;
      if (!v25)
      {
        sub_1001EE2A0();
        uint64_t v24 = v25;
      }
    }

    else
    {
      uint64_t v24 = v25;
      if (*(_BYTE *)(v25 + 13) == 6) {
        return (unsigned __int8 *)sub_1001DC2AC(15LL, v3, v2 >> 2);
      }
    }

    *(_BYTE *)(v24 + 13) = 3;
    *(_BYTE *)(v24 + 10) = v4;
    uint64_t result = (unsigned __int8 *)sub_1001D986C((uint64_t)(v3 + 6), v2 >> 3);
    if (!(_DWORD)result) {
      return result;
    }
    *(_DWORD *)(v25 + 164) = 921;
    sub_1001D8CE8();
    return (unsigned __int8 *)sub_1001DC2AC(15LL, v3, v2 >> 2);
  }

  return result;
}

void sub_1001DCC94(unsigned __int8 *a1, unsigned __int8 *a2)
{
  unsigned int v4 = *a2;
  if ((v4 & 1) == 0 || (a2[1] & 0x10) == 0) {
    return;
  }
  if (a1[12])
  {
    if ((v4 & 2) == 0) {
      return;
    }
  }

  else if ((v4 & 2) != 0)
  {
    return;
  }

  uint64_t v41 = 0LL;
  int v5 = v4 >> 2;
  int v6 = *a1;
  if (v6 == 9)
  {
    if (v4 <= 3)
    {
      uint64_t v14 = sub_1001759FC(*((unsigned __int16 *)a1 + 1), 560LL);
      if ((_DWORD)v14) {
        sub_1001D902C(a1, v14, 1LL);
      }
      else {
        *a1 = 10;
      }
      return;
    }

    if (sub_1001D89B0((uint64_t)a1, v4 >> 2, &v41))
    {
      sub_1001EE134((uint64_t)"%! (%d)", v17, v18, v19, v20, v21, v22, v23, 912LL);
      uint64_t v24 = (os_log_s *)sub_100086554(0x32u);
      if (!os_log_type_enabled(v24, OS_LOG_TYPE_ERROR)) {
        return;
      }
LABEL_43:
      sub_100657858();
      return;
    }

    uint64_t v15 = v41;
    goto LABEL_39;
  }

  if (v6 != 7)
  {
    if (v6 == 5 && v4 <= 3)
    {
      *a1 = 7;
      uint64_t v9 = (unsigned __int8 *)*((void *)a1 + 2);
      uint64_t v7 = a1 + 16;
      uint64_t v8 = v9;
      if (v9)
      {
        if (v8 != v7)
        {
          do
          {
            uint64_t v41 = (uint64_t)(v8 - 144);
            uint64_t v10 = sub_1001D9678((uint64_t)(v8 - 144));
            if ((_DWORD)v10)
            {
              int v11 = v10;
              uint64_t v12 = (unsigned __int8 *)*((void *)v8 + 1);
              (*((void (**)(void, void, uint64_t))v8 - 9))(*((unsigned __int16 *)v8 - 68), 0LL, v10);
              *((_DWORD *)v8 + 5) = v11;
              sub_1001D8CE8(v8 - 144, 1LL);
              uint64_t v8 = v12;
            }

            uint64_t v8 = *(unsigned __int8 **)v8;
            if (v8) {
              BOOL v13 = v8 == v7;
            }
            else {
              BOOL v13 = 1;
            }
          }

          while (!v13);
        }
      }
    }

    return;
  }

  if (v5 == 1 || (v4 + 8) <= 0xBu)
  {
    if (sub_1000A86F0())
    {
      sub_1001EE134((uint64_t)"%! (%d)", v25, v26, v27, v28, v29, v30, v31, 101LL);
      uint64_t v32 = (os_log_s *)sub_100086554(0x32u);
      if (os_log_type_enabled(v32, OS_LOG_TYPE_ERROR)) {
        sub_100657858();
      }
    }

    return;
  }

  uint64_t v15 = v41;
  int v16 = *(unsigned __int8 *)(v41 + 13);
  if (v16 == 6)
  {
LABEL_39:
    sub_1001DC258(v15, 1LL);
    return;
  }

  if (v16 == 2)
  {
    *(_BYTE *)(v41 + 13) = 4;
    sub_1001DDEC8((uint64_t)a1, 1, v5, *(_BYTE *)(v15 + 12), 0);
    return;
  }

  if (sub_1000A86F0())
  {
    sub_1001EE134((uint64_t)"%! (%d)", v33, v34, v35, v36, v37, v38, v39, 408LL);
    uint64_t v40 = (os_log_s *)sub_100086554(0x32u);
    if (os_log_type_enabled(v40, OS_LOG_TYPE_ERROR)) {
      goto LABEL_43;
    }
  }

void sub_1001DCF40(_BYTE *a1, unsigned __int8 *a2)
{
  unsigned int v2 = *a2;
  if ((v2 & 1) == 0 || (a2[1] & 0x10) == 0) {
    return;
  }
  uint64_t v45 = 0LL;
  if (!a1[12])
  {
    if ((v2 & 2) != 0) {
      goto LABEL_6;
    }
LABEL_16:
    sub_1001EE134((uint64_t)"%! (%d)", v7, v8, v9, v10, v11, v12, v13, 917LL);
    uint64_t v14 = (os_log_s *)sub_100086554(0x32u);
    if (!os_log_type_enabled(v14, OS_LOG_TYPE_ERROR)) {
      return;
    }
LABEL_18:
    sub_100657858();
    return;
  }

  if ((v2 & 2) != 0) {
    goto LABEL_16;
  }
LABEL_6:
  uint64_t v4 = v2 >> 2;
  if (v2 > 0xF7 || (_DWORD)v4 == 1)
  {
    sub_1001EE134((uint64_t)"%! (%d)", v15, v16, v17, v18, v19, v20, v21, 920LL);
    uint64_t v22 = (os_log_s *)sub_100086554(0x32u);
    if (!os_log_type_enabled(v22, OS_LOG_TYPE_ERROR)) {
      return;
    }
    goto LABEL_18;
  }

  if (*a1 != 7)
  {
LABEL_14:
    sub_1001DC2AC(99LL, a1, v4);
    return;
  }

  if (v2 <= 3)
  {
    uint64_t v5 = sub_1001EDBA0(0x32u);
    if (*(_WORD *)(v5 + 10)) {
      int v6 = *(unsigned __int16 *)(v5 + 10);
    }
    else {
      int v6 = 30;
    }
    *a1 = 8;
    sub_1001DC128((uint64_t)a1, v6);
    goto LABEL_14;
  }

  if (sub_1001D89B0((uint64_t)a1, v2 >> 2, &v45))
  {
    if (sub_1000A86F0())
    {
      sub_1001EE134((uint64_t)"DLCI %d not found", v23, v24, v25, v26, v27, v28, v29, v4);
      uint64_t v30 = (os_log_s *)sub_100086554(0x32u);
      if (os_log_type_enabled(v30, OS_LOG_TYPE_ERROR)) {
        sub_100657858();
      }
    }
  }

  else
  {
    uint64_t v31 = sub_1001DC2AC(99LL, a1, v4);
    uint64_t v32 = v45;
    int v33 = *(unsigned __int8 *)(v45 + 13);
    if (v33 != 6)
    {
      if (v33 == 5)
      {
        *(_BYTE *)(v45 + 13) = 7;
        if ((_DWORD)v31)
        {
          if (sub_1000A86F0())
          {
            sub_1001EE134( (uint64_t)"RFCOMM send command failed with result : %!",  v34,  v35,  v36,  v37,  v38,  v39,  v40,  v31);
            uint64_t v41 = (os_log_s *)sub_100086554(0x32u);
            if (os_log_type_enabled(v41, OS_LOG_TYPE_ERROR)) {
              sub_100657858();
            }
          }

          uint64_t v42 = v45;
          *(_DWORD *)(v45 + 164) = 933;
          sub_1001DC258(v42, 0LL);
        }
      }

      else
      {
        uint64_t v43 = *(void (**)(uint64_t, void, uint64_t))(v45 + 72);
        if (v43)
        {
          *(_BYTE *)(v45 + 13) = 8;
          if ((_DWORD)v31)
          {
            uint64_t v44 = *(unsigned __int16 *)(v32 + 8);
            sub_1001D8CE8(v32, 0LL);
            v43(v44, 0LL, 927LL);
          }
        }
      }
    }
  }

void sub_1001DD1A4(unsigned __int8 *a1, unsigned __int8 *a2)
{
  unsigned int v2 = *a2;
  if ((v2 & 1) != 0)
  {
    if (a1[12])
    {
      if ((v2 & 2) == 0) {
        return;
      }
    }

    else if ((v2 & 2) != 0)
    {
      return;
    }

    uint64_t v36 = 0LL;
    uint64_t v5 = sub_1001D89B0((uint64_t)a1, v2 >> 2, &v36);
    if ((_DWORD)v5)
    {
      uint64_t v6 = v5;
      if (sub_1000A86F0())
      {
        sub_1001EE134((uint64_t)"%! (%d)", v7, v8, v9, v10, v11, v12, v13, v6);
        uint64_t v14 = (os_log_s *)sub_100086554(0x32u);
        if (os_log_type_enabled(v14, OS_LOG_TYPE_ERROR)) {
LABEL_33:
        }
          sub_100657858();
      }
    }

    else if ((a2[1] & 0x10) != 0 || (*(unsigned __int8 *)(v36 + 13) | 4) != 6)
    {
      int v15 = *a1;
      if (v15 == 7)
      {
        if (v2 >> 2 != 1 && (v2 + 8) >= 0xCu)
        {
          else {
            sub_1001DDAE8((uint64_t)a1);
          }
          uint64_t v24 = v36;
          switch(*(_BYTE *)(v36 + 13))
          {
            case 0:
            case 1:
            case 2:
              uint64_t v25 = *(void (**)(void, void, uint64_t))(v36 + 72);
              if (v25)
              {
                *(_DWORD *)(v36 + 164) = 934;
                v25(*(unsigned __int16 *)(v24 + 8), 0LL, 913LL);
                sub_1001D8CE8(v36, 1LL);
              }

              else if (sub_1000A86F0())
              {
                sub_1001EE134( (uint64_t)"Received unsolicited remote reject, ignore",  v27,  v28,  v29,  v30,  v31,  v32,  v33,  v35);
                uint64_t v34 = (os_log_s *)sub_100086554(0x32u);
                if (os_log_type_enabled(v34, OS_LOG_TYPE_ERROR)) {
                  goto LABEL_33;
                }
              }

              return;
            case 3:
            case 4:
            case 5:
              int v26 = 934;
              goto LABEL_28;
            case 6:
            case 9:
              goto LABEL_29;
            case 7:
            case 8:
              int v26 = 927;
LABEL_28:
              *(_DWORD *)(v36 + 164) = v26;
LABEL_29:
              sub_1001DC258(v24, 1LL);
              break;
            default:
              return;
          }
        }
      }

      else
      {
        if (v15 == 5)
        {
          sub_1001DDAC0((uint64_t)a1);
          sub_1001D8D80(a1, 0LL, 929LL);
          return;
        }

        if (sub_1000A86F0())
        {
          sub_1001EE134((uint64_t)"Unexpected DM received", v16, v17, v18, v19, v20, v21, v22, v35);
          uint64_t v23 = (os_log_s *)sub_100086554(0x32u);
          if (os_log_type_enabled(v23, OS_LOG_TYPE_ERROR)) {
            goto LABEL_33;
          }
        }
      }
    }
  }

void sub_1001DD3D4(_BYTE *a1, unsigned __int8 *a2, int a3, int16x8_t a4)
{
  uint64_t v102 = 0LL;
  unsigned int v4 = *a2;
  if ((v4 & 1) != 0)
  {
    if (a1[12])
    {
      if ((v4 & 2) != 0)
      {
        if (sub_1000A86F0())
        {
          sub_1001EE134((uint64_t)"%! (%d)", v14, v15, v16, v17, v18, v19, v20, 917LL);
          uint64_t v21 = (os_log_s *)sub_100086554(0x32u);
          if (os_log_type_enabled(v21, OS_LOG_TYPE_ERROR)) {
            goto LABEL_35;
          }
        }

        return;
      }
    }

    else if ((v4 & 2) == 0)
    {
      if (sub_1000A86F0())
      {
        sub_1001EE134((uint64_t)"%! (%d)", v22, v23, v24, v25, v26, v27, v28, 917LL);
        uint64_t v29 = (os_log_s *)sub_100086554(0x32u);
        if (os_log_type_enabled(v29, OS_LOG_TYPE_ERROR)) {
          goto LABEL_35;
        }
      }

      return;
    }

    unsigned int v30 = a2[2];
    if ((v30 & 1) != 0)
    {
      uint64_t v31 = v30 >> 1;
      unsigned int v32 = 3;
    }

    else
    {
      uint64_t v31 = (unsigned __int16)(v30 | (a2[3] << 8)) >> 1;
      unsigned int v32 = 4;
    }

    unsigned __int8 v33 = a2[1];
    if ((v33 & 0x10) != 0)
    {
      if (!a1[44])
      {
        if (sub_1000A86F0())
        {
          sub_1001EE134((uint64_t)"%! (%d)", v44, v45, v46, v47, v48, v49, v50, 917LL);
          int v51 = (os_log_s *)sub_100086554(0x32u);
          if (os_log_type_enabled(v51, OS_LOG_TYPE_ERROR)) {
            goto LABEL_35;
          }
        }

        return;
      }

      unsigned int v34 = a2[v32++];
    }

    else
    {
      unsigned int v34 = 0;
    }

    if ((_DWORD)v31 + v32 + 1 != a3)
    {
      if (sub_1000A86F0())
      {
        sub_1001EE134((uint64_t)"%! (%d)", v36, v37, v38, v39, v40, v41, v42, 917LL);
        uint64_t v43 = (os_log_s *)sub_100086554(0x32u);
        if (os_log_type_enabled(v43, OS_LOG_TYPE_ERROR)) {
          goto LABEL_35;
        }
      }

      return;
    }

    if (*a1 != 7) {
      return;
    }
    if (v4 > 0xF7 || v4 >> 2 == 1)
    {
      if (sub_1000A86F0())
      {
        sub_1001EE134((uint64_t)"%! (%d)", v52, v53, v54, v55, v56, v57, v58, 917LL);
        uint64_t v59 = (os_log_s *)sub_100086554(0x32u);
        if (os_log_type_enabled(v59, OS_LOG_TYPE_ERROR)) {
          goto LABEL_35;
        }
      }

      return;
    }

    uint64_t v35 = &a2[v32];
    if (v4 <= 3)
    {
      sub_1001DE0D0((uint64_t)a1, (char *)&a2[v32], v31, a4);
      return;
    }

    uint64_t v60 = sub_1001D89B0((uint64_t)a1, v4 >> 2, &v102);
    if ((_DWORD)v60)
    {
      uint64_t v61 = v60;
      sub_1001EE134((uint64_t)"%! (%d)", v62, v63, v64, v65, v66, v67, v68, v61);
      uint64_t v69 = (os_log_s *)sub_100086554(0x32u);
      if (!os_log_type_enabled(v69, OS_LOG_TYPE_ERROR)) {
        return;
      }
      goto LABEL_39;
    }

    if (a1[44])
    {
      if ((v33 & 0x10) != 0 && v34)
      {
        uint64_t v70 = v102;
        int v71 = *(unsigned __int16 *)(v102 + 18);
        if ((v71 ^ 0xFFFFu) <= v34)
        {
          if (sub_1000A86F0())
          {
            sub_1001EE134((uint64_t)"%! (%d)", v73, v74, v75, v76, v77, v78, v79, 922LL);
            uint64_t v80 = (os_log_s *)sub_100086554(0x32u);
            if (os_log_type_enabled(v80, OS_LOG_TYPE_ERROR)) {
              sub_100657858();
            }
          }

          sub_1001DA5AC(*(unsigned __int16 *)(v102 + 8), 922LL);
          return;
        }

        *(_WORD *)(v102 + 18) = v71 + v34;
        if (!v71) {
          sub_1001DC064(v70);
        }
      }

      uint64_t v72 = v102;
      if (!(_DWORD)v31)
      {
        if (*(_BYTE *)(v102 + 33) || !a1[44]) {
          return;
        }
        goto LABEL_66;
      }

      if (*(_BYTE *)(v102 + 14))
      {
        --*(_BYTE *)(v102 + 14);
      }

      else if (sub_1000A86F0())
      {
        sub_1001EE134((uint64_t)"Received data when remote credits = 0!", v81, v82, v83, v84, v85, v86, v87, v101);
        uint64_t v88 = (os_log_s *)sub_100086554(0x32u);
        if (os_log_type_enabled(v88, OS_LOG_TYPE_ERROR)) {
          sub_100657858();
        }
      }
    }

    uint64_t v72 = v102;
    if (*(_BYTE *)(v102 + 33))
    {
      if (!(_DWORD)v31) {
        return;
      }
      if (a1[44])
      {
        unsigned int v89 = *(unsigned __int8 *)(v102 + 14);
        if (v89 <= *(unsigned __int8 *)(qword_1008F6ED0 + 2))
        {
          if (*(_BYTE *)(v102 + 162)) {
            unsigned __int8 v90 = *(_BYTE *)(v102 + 162) - (v89 + *(_BYTE *)(v102 + 163));
          }
          else {
            unsigned __int8 v90 = ~(_BYTE)v89;
          }
          uint64_t v72 = v102;
        }
      }

uint64_t sub_1001DD8C0(char *a1, int a2)
{
  if ((_BYTE)a2)
  {
    char v2 = -1;
    do
    {
      char v3 = *a1++;
      --a2;
      char v2 = byte_1006BDE5A[(v3 ^ v2)];
    }

    while ((_BYTE)a2);
    return ~v2;
  }

  else
  {
    return 0;
  }

uint64_t sub_1001DD904(char a1, char a2, char a3, int a4)
{
  else {
    return 255LL;
  }
}

uint64_t sub_1001DD944(char a1, char a2, int a3)
{
  else {
    return 255LL;
  }
}

uint64_t sub_1001DD978(uint64_t a1)
{
  uint64_t v4 = a1;
  v3[0] = 0LL;
  uint64_t v1 = (int *)(a1 + 32);
  sub_1001EEB14(*(unsigned int *)(a1 + 32));
  v3[1] = &v4;
  LOWORD(v3[0]) = 8;
  return sub_1001EE6E8((uint64_t)sub_1001DD9E0, v3, *(unsigned __int16 *)(qword_1008F6ED0 + 4), v1);
}

uint64_t sub_1001DD9E0(uint64_t a1)
{
  if (sub_1000A86F0())
  {
    sub_1001EE134((uint64_t)"Timeout occurred", v2, v3, v4, v5, v6, v7, v8, v11);
    uint64_t v9 = (os_log_s *)sub_100086554(0x32u);
    if (os_log_type_enabled(v9, OS_LOG_TYPE_ERROR)) {
      sub_100657FDC(v9);
    }
  }

  return sub_1001D8D80(**(void **)(a1 + 8), 1LL, 931LL);
}

uint64_t sub_1001DDA50(uint64_t a1)
{
  uint64_t v4 = a1;
  if (!a1) {
    sub_1001EE2A0();
  }
  v3[0] = 0LL;
  sub_1001EEB14(*(unsigned int *)(a1 + 36));
  v3[1] = &v4;
  LOWORD(v3[0]) = 8;
  return sub_1001EE6E8((uint64_t)sub_1001DD9E0, v3, *(unsigned __int16 *)(qword_1008F6ED0 + 8), (int *)(a1 + 36));
}

uint64_t sub_1001DDAC0(uint64_t a1)
{
  if (!a1) {
    sub_1001EE2A0();
  }
  return sub_1001EEB14(*(unsigned int *)(a1 + 32));
}

uint64_t sub_1001DDAE8(uint64_t a1)
{
  if (!a1) {
    sub_1001EE2A0();
  }
  return sub_1001EEB14(*(unsigned int *)(a1 + 36));
}

uint64_t sub_1001DDB10(uint64_t a1)
{
  if (!a1) {
    sub_1001EE2A0();
  }
  return sub_1001EECE0(*(_DWORD *)(a1 + 36));
}

uint64_t sub_1001DDB38(uint64_t a1, int a2, unsigned int a3, unsigned __int8 a4, __int16 a5, char a6)
{
  if (!a1) {
    sub_1001EE2A0();
  }
  if (a2) {
    char v12 = -125;
  }
  else {
    char v12 = -127;
  }
  LOBYTE(v19[0]) = v12;
  HIBYTE(v19[0]) = 17;
  if (a3 >= 0x40) {
    sub_1001EE2A0();
  }
  memset((char *)&v19[1] + 1, 0, 7);
  LOBYTE(v19[1]) = a3;
  if (a2) {
    char v13 = -16;
  }
  else {
    char v13 = -32;
  }
  if (*(_BYTE *)(a1 + 44)) {
    char v14 = v13;
  }
  else {
    char v14 = 0;
  }
  if (*(_BYTE *)(a1 + 44)) {
    char v15 = a6;
  }
  else {
    char v15 = 0;
  }
  HIBYTE(v19[1]) = v14;
  v19[2] = a4;
  v19[3] = a5;
  LOBYTE(v19[4]) = 0;
  HIBYTE(v19[4]) = v15;
  if (a2) {
    sub_1001DDA50(a1);
  }
  uint64_t v18 = 0LL;
  uint64_t v16 = sub_1001DC780(a1, 0LL, (char *)v19, 0xAuLL, 0);
  if (!(_DWORD)v16)
  {
    uint64_t v16 = sub_1001D89B0(a1, a3, &v18);
    if ((_DWORD)v16) {
      sub_1001EE2A0();
    }
    if (!*(_BYTE *)(v18 + 13)) {
      *(_BYTE *)(v18 + 13) = 1;
    }
  }

  return v16;
}

uint64_t sub_1001DDC9C(uint64_t a1, int a2, uint64_t a3, uint64_t a4)
{
  if (!a1) {
    sub_1001EE2A0();
  }
  memset(v19, 0, sizeof(v19));
  if ((a4 & 0x80) != 0)
  {
    if (sub_1000A86F0())
    {
      sub_1001EE134((uint64_t)"OI_RfcommMux_TEST invalid size=%d", v10, v11, v12, v13, v14, v15, v16, a4);
      uint64_t v17 = (os_log_s *)sub_100086554(0x32u);
      if (os_log_type_enabled(v17, OS_LOG_TYPE_ERROR)) {
        sub_100657858();
      }
    }

    return 114LL;
  }

  else
  {
    if (a2) {
      char v8 = 35;
    }
    else {
      char v8 = 33;
    }
    v18[0] = v8;
    v18[1] = (2 * a4) | 1;
    __memmove_chk(v19, a3, a4, 254LL);
    if (a2) {
      sub_1001DDA50(a1);
    }
    return sub_1001DC780(a1, 0LL, v18, (a4 + 2), 0);
  }

uint64_t sub_1001DDDE8(uint64_t a1, int a2)
{
  if (!a1) {
    sub_1001EE2A0();
  }
  if (a2) {
    char v4 = -93;
  }
  else {
    char v4 = -95;
  }
  v6[0] = v4;
  v6[1] = 1;
  if (a2) {
    sub_1001DDA50(a1);
  }
  return sub_1001DC780(a1, 0LL, v6, 2uLL, 0);
}

uint64_t sub_1001DDE58(uint64_t a1, int a2)
{
  if (!a1) {
    sub_1001EE2A0();
  }
  if (a2) {
    char v4 = 99;
  }
  else {
    char v4 = 97;
  }
  v6[0] = v4;
  v6[1] = 1;
  if (a2) {
    sub_1001DDA50(a1);
  }
  return sub_1001DC780(a1, 0LL, v6, 2uLL, 0);
}

uint64_t sub_1001DDEC8(uint64_t a1, int a2, char a3, char a4, int a5)
{
  char v11 = 0;
  if (a2) {
    char v6 = -29;
  }
  else {
    char v6 = -31;
  }
  v10[0] = v6;
  if (a5)
  {
    char v11 = (16 * a5) | 3;
    size_t v7 = 5LL;
    char v8 = 7;
  }

  else
  {
    a4 |= 1u;
    size_t v7 = 4LL;
    char v8 = 5;
  }

  v10[1] = v8;
  v10[3] = a4;
  v10[2] = (4 * a3) | 3;
  if (a2) {
    sub_1001DDA50(a1);
  }
  return sub_1001DC780(a1, 0LL, v10, v7, 0);
}

uint64_t sub_1001DDF64(uint64_t a1, int a2, char a3, uint64_t a4)
{
  if (a2) {
    char v5 = -109;
  }
  else {
    char v5 = -111;
  }
  LOBYTE(v11[0]) = v5;
  LOBYTE(v11[1]) = (4 * a3) | 3;
  if (a4)
  {
    HIBYTE(v11[1]) = *(_BYTE *)(a4 + 2);
    unsigned int v8 = *(unsigned __int8 *)(a4 + 3);
    if (v8 > 3) {
      return 904LL;
    }
    int v9 = *(unsigned __int8 *)(a4 + 4);
    if ((v9 | 4) != 4) {
      return 905LL;
    }
    int v10 = *(unsigned __int8 *)(a4 + 5);
    if ((v10 | 8) != 8) {
      return 906LL;
    }
    LOBYTE(v11[2]) = *(_BYTE *)(a4 + 6) | v10 | v9 | v8;
    HIBYTE(v11[2]) = *(_BYTE *)(a4 + 7);
    v11[3] = *(_WORD *)(a4 + 8);
    v11[4] = *(_WORD *)a4;
    int v7 = 8;
  }

  else
  {
    int v7 = 1;
  }

  HIBYTE(v11[0]) = (2 * v7) | 1;
  if (a2) {
    sub_1001DDA50(a1);
  }
  return sub_1001DC780(a1, 0LL, (char *)v11, v7 | 2u, 0);
}

void sub_1001DE0D0(uint64_t a1, char *a2, int a3, int16x8_t a4)
{
  char v5 = *a2;
  int v6 = *a2 & 0xFC;
  uint64_t v7 = a2[1] >> 1;
  if ((_DWORD)v7 + 2 != a3)
  {
    if (sub_1000A86F0())
    {
      sub_1001EE134( (uint64_t)"Invalid RFCOMM packet received, command (%d), force disconnect the link",  v10,  v11,  v12,  v13,  v14,  v15,  v16,  v5 & 0xFC);
      uint64_t v17 = (os_log_s *)sub_100086554(0x32u);
      if (os_log_type_enabled(v17, OS_LOG_TYPE_ERROR)) {
        sub_100657858();
      }
    }

    sub_10010D064(a1 + 6);
    return;
  }

  HIDWORD(v8) = *a2 & 0xFC;
  LODWORD(v8) = v6 - 16;
  switch((v8 >> 4))
  {
    case 0u:
      if ((_DWORD)v7 == 1)
      {
        sub_1001DDB10(a1);
      }

      else if (sub_1000A86F0())
      {
        sub_1001EE134((uint64_t)"%! (%d)", v59, v60, v61, v62, v63, v64, v65, 917LL);
        uint64_t v66 = (os_log_s *)sub_100086554(0x32u);
        if (os_log_type_enabled(v66, OS_LOG_TYPE_ERROR)) {
          goto LABEL_107;
        }
      }

      return;
    case 1u:
      if (v6 != 32)
      {
        sub_1001EE2A0();
        char v5 = *a2;
      }

      if ((v5 & 2) != 0)
      {
        sub_1001DDC9C(a1, 0, (uint64_t)(a2 + 2), v7);
      }

      else
      {
        sub_1001DDAE8(a1);
        uint64_t v18 = *(void (**)(uint64_t, char *, uint64_t))(a1 + 48);
        if (v18)
        {
          v18(a1 + 6, a2 + 2, v7);
          *(void *)(a1 + 48) = 0LL;
        }

        else if (sub_1000A86F0())
        {
          sub_1001EE134( (uint64_t)"Mux_ReceiveTEST, receive response but no outstanding command, ignoring",  v129,  v130,  v131,  v132,  v133,  v134,  v135,  v258);
          unsigned int v136 = (os_log_s *)sub_100086554(0x32u);
          if (os_log_type_enabled(v136, OS_LOG_TYPE_ERROR)) {
            goto LABEL_107;
          }
        }
      }

      return;
    case 4u:
      uint64_t v262 = 0LL;
      if ((_DWORD)v7 == 2)
      {
        unsigned int v19 = a2[2];
        uint64_t v20 = v19 >> 2;
        if (v19 > 0xF7 || (_DWORD)v20 == 1)
        {
          if (sub_1000A86F0())
          {
            sub_1001EE134((uint64_t)"%! (%d)", v109, v110, v111, v112, v113, v114, v115, 917LL);
            uint64_t v116 = (os_log_s *)sub_100086554(0x32u);
            if (os_log_type_enabled(v116, OS_LOG_TYPE_ERROR)) {
              goto LABEL_107;
            }
          }
        }

        else if ((v5 & 2) != 0)
        {
          char v155 = a2[3];
          uint64_t v156 = sub_1001D89B0(a1, v19 >> 2, &v262);
          if ((_DWORD)v156)
          {
            uint64_t v157 = v156;
            sub_1001EE134((uint64_t)"%! (%d)", v158, v159, v160, v161, v162, v163, v164, v157);
            uint64_t v165 = (os_log_s *)sub_100086554(0x32u);
            if (!os_log_type_enabled(v165, OS_LOG_TYPE_ERROR)) {
              goto LABEL_79;
            }
            goto LABEL_111;
          }

          LOWORD(v259) = 1361;
          BYTE2(v259) = v19 | 3;
          BYTE3(v259) = v155;
          sub_1001DC780(a1, 0LL, (char *)&v259, 4uLL, 0);
          uint64_t v225 = *(void (**)(void, void))(*(void *)(v262 + 40) + 16LL);
          if (v225) {
            v225(*(unsigned __int16 *)(v262 + 8), v155 & 0xF);
          }
        }

        else
        {
          sub_1001DDAE8(a1);
        }
      }

      else if (sub_1000A86F0())
      {
        sub_1001EE134((uint64_t)"%! (%d)", v67, v68, v69, v70, v71, v72, v73, 917LL);
        uint64_t v74 = (os_log_s *)sub_100086554(0x32u);
        if (os_log_type_enabled(v74, OS_LOG_TYPE_ERROR)) {
          goto LABEL_107;
        }
      }

      return;
    case 5u:
      if (!a1)
      {
        sub_1001EE2A0();
        char v5 = *a2;
      }

      if ((v5 & 2) == 0) {
        goto LABEL_52;
      }
      sub_1001DDE58(a1, 0);
      if (!*(_BYTE *)(a1 + 44)) {
        *(_BYTE *)(a1 + 45) = 0;
      }
      return;
    case 7u:
      if (!a1) {
        sub_1001EE2A0();
      }
      uint64_t v262 = 0LL;
      if ((_DWORD)v7 == 8)
      {
        uint64_t v20 = a2[2] & 0x3F;
        if ((_DWORD)v20 == 1 || v20 >= 0x3E)
        {
          if (sub_1000A86F0())
          {
            sub_1001EE134((uint64_t)"%! (%d)", v117, v118, v119, v120, v121, v122, v123, 917LL);
            uint64_t v124 = (os_log_s *)sub_100086554(0x32u);
            if (os_log_type_enabled(v124, OS_LOG_TYPE_ERROR)) {
              goto LABEL_107;
            }
          }
        }

        else
        {
          char v21 = *a2;
          unsigned int v22 = a2[3];
          char v23 = a2[4];
          unsigned __int16 v24 = *((_WORD *)a2 + 3);
          __int16 v25 = a2[9] & 7;
          uint64_t v26 = sub_1001D89B0(a1, v20, &v262);
          if ((_DWORD)v26)
          {
            if ((v21 & 2) == 0)
            {
              uint64_t v27 = v26;
              if (sub_1000A86F0())
              {
                sub_1001EE134((uint64_t)"%! (%d)", v28, v29, v30, v31, v32, v33, v34, v27);
                uint64_t v35 = (os_log_s *)sub_100086554(0x32u);
                if (os_log_type_enabled(v35, OS_LOG_TYPE_ERROR)) {
                  sub_100657858();
                }
              }

              return;
            }

            uint64_t v178 = sub_1001D8A44(a1, v20, &v262);
            if ((_DWORD)v178)
            {
              uint64_t v179 = v178;
              if (sub_1000A86F0())
              {
                sub_1001EE134((uint64_t)"%! (%d)", v180, v181, v182, v183, v184, v185, v186, v179);
                unsigned int v187 = (os_log_s *)sub_100086554(0x32u);
                if (os_log_type_enabled(v187, OS_LOG_TYPE_ERROR)) {
LABEL_111:
                }
                  sub_100657858();
              }

              goto LABEL_79;
            }
          }

          else if ((v21 & 2) == 0)
          {
            if (*(_BYTE *)(v262 + 13) != 1) {
              return;
            }
            sub_1001DDAE8(a1);
            int v167 = (v22 & 0xF0) == 224;
            *(_BYTE *)(a1 + 44) = v167;
            if (*(unsigned __int16 *)(v262 + 16) >= v24)
            {
              *(_WORD *)(v262 + 16) = v24;
            }

            else
            {
              if (sub_1000A86F0())
              {
                sub_1001EE134((uint64_t)"%! (%d)", v168, v169, v170, v171, v172, v173, v174, 917LL);
                __int128 v175 = (os_log_s *)sub_100086554(0x32u);
                if (os_log_type_enabled(v175, OS_LOG_TYPE_ERROR)) {
                  sub_100657858();
                }
              }

              uint64_t v176 = v262;
              *(_DWORD *)(v262 + 164) = 918;
              uint64_t v177 = *(void (**)(void, void, uint64_t))(v176 + 72);
              if (v177)
              {
                v177(0LL, 0LL, 918LL);
                uint64_t v176 = v262;
              }

              sub_1001D8CE8(v176, 1LL);
              int v167 = *(unsigned __int8 *)(a1 + 44);
            }

            if (v167) {
              *(_WORD *)(v262 + 18) = v25;
            }
            if (!sub_1001DC2AC(47LL, a1, v20))
            {
              uint64_t v249 = v262;
              if (!v262)
              {
                sub_1001EE2A0();
                uint64_t v249 = v262;
              }

              *(_BYTE *)(v249 + 13) = 2;
            }

            return;
          }

          uint64_t v188 = v262;
          if (*(_BYTE *)(v262 + 13))
          {
            __int16 v189 = v24;
            uint64_t v190 = a1;
            unsigned int v191 = v20;
            unsigned __int8 v192 = v23 & 0x3F;
            char v193 = 0;
          }

          else
          {
            if (v22 >= 0xF0)
            {
              *(_BYTE *)(a1 + 44) = 1;
              *(_WORD *)(v188 + 18) = v25;
              uint64_t v238 = sub_1001DBC70(v188);
              if ((_DWORD)v238)
              {
                uint64_t v239 = v238;
                if (sub_1000A86F0())
                {
                  sub_1001EE134((uint64_t)"%! (%d)", v240, v241, v242, v243, v244, v245, v246, v239);
                  uint64_t v247 = (os_log_s *)sub_100086554(0x32u);
                  if (os_log_type_enabled(v247, OS_LOG_TYPE_ERROR)) {
                    sub_100657858();
                  }
                }

                uint64_t v248 = v262;
                if (!v262)
                {
                  sub_1001EE2A0();
                  uint64_t v248 = v262;
                }

                *(_BYTE *)(v248 + 13) = 9;
                goto LABEL_79;
              }

              uint64_t v188 = v262;
              char v193 = *(_BYTE *)(v262 + 14);
            }

            else
            {
              char v193 = 0;
              *(_BYTE *)(a1 + 44) = 0;
              *(_BYTE *)(v188 + 14) = 0;
            }

            __int16 v189 = *(_WORD *)(v188 + 16);
            uint64_t v190 = a1;
            unsigned int v191 = v20;
            unsigned __int8 v192 = v23 & 0x3F;
          }

          sub_1001DDB38(v190, 0, v191, v192, v189, v193);
        }
      }

      else if (sub_1000A86F0())
      {
        sub_1001EE134((uint64_t)"Mux_ReceivePN invalid cmdLen=%d, shall be=%d", v75, v76, v77, v78, v79, v80, v81, v7);
        uint64_t v82 = (os_log_s *)sub_100086554(0x32u);
        if (os_log_type_enabled(v82, OS_LOG_TYPE_ERROR)) {
          goto LABEL_107;
        }
      }

      return;
    case 8u:
      __int16 v263 = 0;
      uint64_t v261 = 0LL;
      uint64_t v262 = 0LL;
      unsigned int v36 = a2[2];
      uint64_t v20 = v36 >> 2;
      if (v36 > 0xF7 || (_DWORD)v20 == 1)
      {
        if (sub_1000A86F0())
        {
          sub_1001EE134((uint64_t)"%! (%d)", v83, v84, v85, v86, v87, v88, v89, 917LL);
          unsigned __int8 v90 = (os_log_s *)sub_100086554(0x32u);
          if (os_log_type_enabled(v90, OS_LOG_TYPE_ERROR)) {
            goto LABEL_107;
          }
        }

        return;
      }

      if ((_DWORD)v7 == 8)
      {
        BYTE2(v262) = a2[3];
        *(int8x8_t *)a4.i8 = vand_s8((int8x8_t)vdup_n_s16(a2[4]), (int8x8_t)0x30000800040003LL);
        *(_DWORD *)((char *)&v262 + 3) = vmovn_s16(a4).u32[0];
        HIBYTE(v262) = a2[5] & 0x3F;
        __int16 v263 = *((_WORD *)a2 + 3);
        LOWORD(v262) = *((_WORD *)a2 + 4);
        uint64_t v137 = sub_1001D89B0(a1, v20, &v261);
        if ((_DWORD)v137)
        {
          if ((v5 & 2) == 0)
          {
            uint64_t v138 = v137;
            sub_1001EE134((uint64_t)"%! (%d)", v139, v140, v141, v142, v143, v144, v145, v138);
            uint64_t v146 = (os_log_s *)sub_100086554(0x32u);
            if (!os_log_type_enabled(v146, OS_LOG_TYPE_ERROR)) {
              return;
            }
            goto LABEL_209;
          }

          uint64_t v203 = sub_1001D8A44(a1, v20, &v261);
          if ((_DWORD)v203)
          {
            uint64_t v204 = v203;
            if (sub_1000A86F0())
            {
              sub_1001EE134((uint64_t)"%! (%d)", v205, v206, v207, v208, v209, v210, v211, v204);
              uint64_t v212 = (os_log_s *)sub_100086554(0x32u);
              if (os_log_type_enabled(v212, OS_LOG_TYPE_ERROR)) {
                sub_100657858();
              }
            }

            goto LABEL_79;
          }
        }

        else if ((v5 & 2) == 0)
        {
          if (*(void *)(v261 + 64))
          {
            sub_1001DDAE8(a1);
            uint64_t v202 = v261;
            *(void *)(v261 + memset(v6, 0, 22) = v262;
            *(_WORD *)(v202 + 30) = v263;
            (*(void (**)(void, uint64_t *))(v202 + 64))(*(unsigned __int16 *)(v202 + 8), &v262);
            return;
          }

          if (sub_1000A86F0())
          {
            sub_1001EE134( (uint64_t)"Mux_ReceiveRPN, unsolicited response, ignoring",  v250,  v251,  v252,  v253,  v254,  v255,  v256,  v258);
            uint64_t v257 = (os_log_s *)sub_100086554(0x32u);
            if (os_log_type_enabled(v257, OS_LOG_TYPE_ERROR)) {
              goto LABEL_209;
            }
          }

          return;
        }

        uint64_t v213 = *(void (**)(void, uint64_t *))(*(void *)(v261 + 40) + 32LL);
        if (v213) {
          v213(*(unsigned __int16 *)(v261 + 8), &v262);
        }
        __int16 v214 = v262;
        if ((v262 & 1) != 0)
        {
          *(_BYTE *)(v261 + 24) = BYTE2(v262);
          if ((v214 & 2) == 0)
          {
LABEL_146:
            if ((v214 & 4) == 0) {
              goto LABEL_147;
            }
            goto LABEL_174;
          }
        }

        else if ((v262 & 2) == 0)
        {
          goto LABEL_146;
        }

        *(_BYTE *)(v261 + 25) = BYTE3(v262);
        if ((v214 & 4) == 0)
        {
LABEL_147:
          if ((v214 & 8) == 0) {
            goto LABEL_148;
          }
          goto LABEL_175;
        }

LABEL_177:
        *(_BYTE *)(v261 + 30) = v263;
        if ((v214 & 0x40) == 0)
        {
LABEL_151:
          if ((v214 & 0x100) == 0) {
            goto LABEL_152;
          }
          goto LABEL_179;
        }

  uint64_t v69 = *(unsigned __int8 *)(a1 + 1108);
  uint64_t v70 = *(unsigned __int8 *)(a1 + 1109);
  if (v69 > v70)
  {
    uint64_t v71 = (os_log_s *)qword_1008F7620;
    if (os_log_type_enabled((os_log_t)qword_1008F7620, OS_LOG_TYPE_ERROR))
    {
      *(_DWORD *)__int128 buf = 67109632;
      *(_DWORD *)&uint8_t buf[4] = v69;
      *(_WORD *)&buf[8] = 1024;
      *(_DWORD *)&buf[10] = v70;
      uint64_t v98 = 1024;
      uint64_t v99 = v70;
      _os_log_error_impl( (void *)&_mh_execute_header,  v71,  OS_LOG_TYPE_ERROR,  "fMinCELenDigitalID %d is greater than fMaxCELenDigitalID %d. Replace fMinCELenDigitalID by %d.",  buf,  0x14u);
      LOBYTE(v70) = *(_BYTE *)(a1 + 1109);
    }

    *(_BYTE *)(a1 + 1108) = v70;
  }

  uint64_t v87 = 0;
  uint64_t v72 = sub_1002E6E00();
  sub_10002418C(buf, "LE");
  sub_10002418C(__p, "OverrideConnectionIntervalFindMy");
  uint64_t v73 = (*(uint64_t (**)(uint64_t, _BYTE *, void **, unsigned __int8 *))(*(void *)v72 + 72LL))( v72,  buf,  __p,  &v87);
  if (v93 < 0) {
    operator delete(__p[0]);
  }
  if (v100 < 0)
  {
    operator delete(*(void **)buf);
    if (!v73) {
      goto LABEL_191;
    }
  }

  else if (!v73)
  {
    goto LABEL_191;
  }

  uint64_t v74 = v87;
  *(_BYTE *)(a1 + 1110) = v87;
  uint64_t v75 = (os_log_s *)qword_1008F7620;
  if (os_log_type_enabled((os_log_t)qword_1008F7620, OS_LOG_TYPE_DEFAULT))
  {
    uint64_t v76 = "enabled";
    if (!v74) {
      uint64_t v76 = "disabled";
    }
    *(_DWORD *)__int128 buf = 136315138;
    *(void *)&uint8_t buf[4] = v76;
    _os_log_impl( (void *)&_mh_execute_header,  v75,  OS_LOG_TYPE_DEFAULT,  "OverrideConnectionIntervalFindMy %s",  buf,  0xCu);
  }

LABEL_179:
        *(_BYTE *)(v261 + 29) = *(_BYTE *)(v261 + 29) & 0xFE | HIBYTE(v262) & 1;
        if ((v214 & 0x200) == 0)
        {
LABEL_153:
          if ((v214 & 0x400) == 0) {
            goto LABEL_154;
          }
          goto LABEL_181;
        }

LABEL_181:
        *(_BYTE *)(v261 + 29) = *(_BYTE *)(v261 + 29) & 0xFB | HIBYTE(v262) & 4;
        if ((v214 & 0x800) == 0)
        {
LABEL_155:
          if ((v214 & 0x1000) == 0) {
            goto LABEL_156;
          }
          goto LABEL_183;
        }

  uint64_t v43 = (os_log_s *)qword_1008F7578;
  uint64_t v44 = os_log_type_enabled((os_log_t)qword_1008F7578, OS_LOG_TYPE_DEFAULT);
  if (v44)
  {
    uint64_t v45 = sub_1002CF02C(v44, v3);
    *(_DWORD *)__int128 buf = 136446210;
    uint64_t v56 = v45;
    _os_log_impl( (void *)&_mh_execute_header,  v43,  OS_LOG_TYPE_DEFAULT,  "%{public}s supports the following VSCs",  buf,  0xCu);
  }

  for (uint64_t i = 0LL; i != 270; ++i)
  {
    if (*(_BYTE *)(a1 + 168 + i))
    {
      uint64_t v47 = (os_log_s *)qword_1008F7578;
      uint64_t v48 = os_log_type_enabled((os_log_t)qword_1008F7578, OS_LOG_TYPE_INFO);
      if (v48)
      {
        uint64_t v49 = sub_1002CE354(v48, i);
        *(_DWORD *)__int128 buf = 136446210;
        uint64_t v56 = v49;
        _os_log_impl((void *)&_mh_execute_header, v47, OS_LOG_TYPE_INFO, "%{public}s", buf, 0xCu);
      }
    }
  }

  return 0LL;
}

LABEL_182:
        *(_BYTE *)(v261 + 29) = *(_BYTE *)(v261 + 29) & 0xF7 | HIBYTE(v262) & 8;
        if ((v214 & 0x1000) == 0)
        {
LABEL_156:
          if ((v214 & 0x2000) == 0)
          {
LABEL_158:
            uint64_t v215 = sub_1001DDF64(a1, 0, v20, (uint64_t)&v262);
            if (!(_DWORD)v215) {
              return;
            }
            uint64_t v216 = v215;
            sub_1001EE134((uint64_t)"%! (%d)", v217, v218, v219, v220, v221, v222, v223, v216);
            uint64_t v224 = (os_log_s *)sub_100086554(0x32u);
            if (!os_log_type_enabled(v224, OS_LOG_TYPE_ERROR)) {
              return;
            }
            goto LABEL_209;
          }

  uint64_t v79 = sub_1002E6E00();
  sub_10002418C(buf, "LeBroadcaster");
  sub_10002418C(__p, "AdvStatsInstance2");
  uint64_t v80 = (*(uint64_t (**)(uint64_t, _BYTE *, void **, int *))(*(void *)v79 + 88LL))(v79, buf, __p, &v106);
  if (v110 < 0) {
    operator delete(__p[0]);
  }
  if (SBYTE3(v114) < 0) {
    operator delete(*(void **)buf);
  }
  uint64_t v81 = v106;
  if (!v80) {
    uint64_t v81 = 1;
  }
  *(_BYTE *)(v5 + 186) = v81;
  uint64_t v82 = sub_1002E6E00();
  sub_10002418C(buf, "LeBroadcaster");
  sub_10002418C(__p, "AdvStatsEnable2");
  uint64_t v83 = (*(uint64_t (**)(uint64_t, _BYTE *, void **, int *))(*(void *)v82 + 88LL))(v82, buf, __p, &v106);
  if (v110 < 0) {
    operator delete(__p[0]);
  }
  if (SBYTE3(v114) < 0) {
    operator delete(*(void **)buf);
  }
  uint64_t v84 = v106;
  if (!v83) {
    uint64_t v84 = 1;
  }
  *(_BYTE *)(v5 + 18memset((char *)&v11[1] + 1, 0, 7) = v84;
  uint64_t v85 = sub_1002E6E00();
  sub_10002418C(buf, "LeBroadcaster");
  sub_10002418C(__p, "AdvStatsReset2");
  uint64_t v86 = (*(uint64_t (**)(uint64_t, _BYTE *, void **, int *))(*(void *)v85 + 88LL))(v85, buf, __p, &v106);
  if (v110 < 0) {
    operator delete(__p[0]);
  }
  if (SBYTE3(v114) < 0) {
    operator delete(*(void **)buf);
  }
  uint64_t v87 = v106;
  if (!v86) {
    uint64_t v87 = 1;
  }
  *(_BYTE *)(v5 + 188) = v87;
  uint64_t v88 = sub_1002E6E00();
  sub_10002418C(buf, "LeBroadcaster");
  sub_10002418C(__p, "AdvStatsPeriod2");
  uint64_t v89 = (*(uint64_t (**)(uint64_t, _BYTE *, void **, int *))(*(void *)v88 + 88LL))(v88, buf, __p, &v106);
  if (v110 < 0) {
    operator delete(__p[0]);
  }
  if (SBYTE3(v114) < 0) {
    operator delete(*(void **)buf);
  }
  unsigned __int8 v90 = v106;
  if (!v89) {
    unsigned __int8 v90 = 60;
  }
  *(_DWORD *)(v5 + 190) = v90;
  uint64_t v91 = sub_1002E6E00();
  sub_10002418C(buf, "LeBroadcaster");
  sub_10002418C(__p, "AdvStatsCanWakeUpAP2");
  uint64_t v92 = (*(uint64_t (**)(uint64_t, _BYTE *, void **, int *))(*(void *)v91 + 88LL))(v91, buf, __p, &v106);
  if (v110 < 0) {
    operator delete(__p[0]);
  }
  if (SBYTE3(v114) < 0)
  {
    operator delete(*(void **)buf);
    if (v92) {
      goto LABEL_210;
    }
LABEL_212:
    *(_BYTE *)(v5 + 194) = 0;
    if (!(v89 | v86 | v83 | v80)) {
      goto LABEL_221;
    }
    goto LABEL_213;
  }

  if (!v92) {
    goto LABEL_212;
  }
LABEL_210:
  uint64_t v92 = v106;
  *(_BYTE *)(v5 + 194) = v106;
LABEL_213:
  uint64_t v93 = (os_log_s *)qword_1008F7648;
  if (os_log_type_enabled((os_log_t)qword_1008F7648, OS_LOG_TYPE_DEFAULT))
  {
    uint64_t v94 = *(unsigned __int8 *)(v5 + 186);
    if (*(_BYTE *)(v5 + 187)) {
      uint64_t v95 = "Y";
    }
    else {
      uint64_t v95 = "N";
    }
    if (*(_BYTE *)(v5 + 188)) {
      uint64_t v96 = "Y";
    }
    else {
      uint64_t v96 = "N";
    }
    uint64_t v97 = *(_DWORD *)(v5 + 190);
    *(_DWORD *)__int128 buf = 67110146;
    *(_DWORD *)&uint8_t buf[4] = v94;
    *(_WORD *)&buf[8] = 2080;
    *(void *)&buf[10] = v95;
    uint64_t v113 = 2080;
    uint64_t v114 = v96;
    uint64_t v115 = 1024;
    uint64_t v116 = v97;
    uint64_t v117 = 1024;
    uint64_t v118 = v92;
    _os_log_impl( (void *)&_mh_execute_header,  v93,  OS_LOG_TYPE_DEFAULT,  "Enabling Adv Stats for instance %d enable %s reset %s period %d (secs) canWakeUpAP %d",  buf,  0x28u);
  }

  uint64_t v166 = 0;
  uint64_t v85 = sub_1002E6E00();
  sub_10002418C(buf, "LE");
  sub_10002418C(__p, "GlobalMinRSSIConnection");
  uint64_t v86 = (*(uint64_t (**)(uint64_t, _BYTE *, void **, int *))(*(void *)v85 + 88LL))(v85, buf, __p, &v166);
  if (v171 < 0) {
    operator delete(__p[0]);
  }
  if (v175 < 0)
  {
    operator delete(*(void **)buf);
    if (!v86) {
      goto LABEL_190;
    }
  }

  else if (!v86)
  {
    goto LABEL_190;
  }

  uint64_t v87 = v166;
  *(_BYTE *)(a1 + 1120) = v166;
  uint64_t v88 = (os_log_s *)qword_1008F7620;
  if (os_log_type_enabled((os_log_t)qword_1008F7620, OS_LOG_TYPE_DEFAULT))
  {
    *(_DWORD *)__int128 buf = 67109120;
    *(_DWORD *)&uint8_t buf[4] = v87;
    _os_log_impl( (void *)&_mh_execute_header,  v88,  OS_LOG_TYPE_DEFAULT,  "GlobalMinRSSIConnection %d overridden",  buf,  8u);
  }

          DWORD2(v137[2]) = 1;
          BYTE8(v137[0]) = 1;
          uint64_t v58 = v137;
          uint64_t v59 = v138;
LABEL_183:
          uint64_t v98 = v58[1];
          *(_OWORD *)a3 = *v58;
          *(_OWORD *)(a3 + 16) = v98;
          *(_OWORD *)(a3 + 28) = *(_OWORD *)((char *)v58 + 28);
          *(void *)(a3 + 48) = *((void *)v58 + 6);
          *(_OWORD *)(a3 + 56) = *(_OWORD *)((char *)v58 + 56);
          v59[1] = 0LL;
          v59[2] = 0LL;
          os_log_s *v59 = 0LL;
          *(_OWORD *)(a3 + 72) = *(_OWORD *)((char *)v58 + 72);
          *(void *)(a3 + 88) = *((void *)v58 + 11);
          v12[1] = 0LL;
          void v12[2] = 0LL;
          *uint64_t v12 = 0LL;
          *(_BYTE *)(a3 + 96) = *((_BYTE *)v58 + 96);

          goto LABEL_108;
        }

        LOBYTE(v137[0]) = 0;
        if ((dword_1008F1EA8 - 19) > 0x7BC)
        {
          uint64_t v86 = 0;
          v208[7] = 0;
          *(void *)&v137[1] = 0LL;
        }

        else
        {
          v208[7] = *(_BYTE *)(a1 + 144);
          *(void *)&v137[1] = 0LL;
          if ((dword_1008F1EA8 - 22) < 0x7BA)
          {
            uint64_t v86 = 3;
LABEL_173:
            HIWORD(v137[0]) = v86;
            v208[4] = *(_BYTE *)(a1 + 144);
            sub_1005E3A00((uint64_t *)v138, (uint64_t)&v207);
            if (_os_feature_enabled_impl("CoreLocation", "StandardUT"))
            {
              LOBYTE(v139) = *(_BYTE *)(a1 + 144);
              uint64_t v181 = xmmword_1006BDCB0;
              uint64_t v182 = 0;
              sub_100634334((__n128 *)buf, (__n128 *)&v181);
              sub_1005E38E0((void **)&v138[1] + 1, (__int128 *)buf);
              if (_os_feature_enabled_impl("BluetoothFeatures", "StandardUTFEAA"))
              {
                uint64_t v179 = xmmword_1006BDCC4;
                uint64_t v180 = 0;
                sub_100634334((__n128 *)buf, (__n128 *)&v179);
                sub_1005E38E0((void **)&v138[1] + 1, (__int128 *)buf);
              }
            }

            LOWORD(v137[2]) = 30;
            uint64_t v96 = *(unsigned __int8 *)(a1 + 144);
            if (*(_BYTE *)(a1 + 144)) {
              uint64_t v97 = 300;
            }
            else {
              uint64_t v97 = 966;
            }
            WORD1(v137[2]) = v97;
            goto LABEL_182;
          }
        }

        uint64_t v86 = 2;
        goto LABEL_173;
      case 65547:
      case 65548:
        uint64_t v209 = (unsigned __int128)0LL >> 112;
        uint64_t v207 = 0uLL;
        *(_OWORD *)uint64_t v208 = 0uLL;
        *(void *)&v208[1] = 0x100129C01010101LL;
        *(_WORD *)&v208[9] = 513;
        *(void *)&v208[12] = 0xFFFF0000FFFFLL;
        *(_DWORD *)&v208[20] = 0xFFFF;
        memset(&v208[24], 0, 54);
        BYTE2(v137[0]) = 1;
        uint64_t v29 = sub_1002E6BF0();
        if (((*(uint64_t (**)(uint64_t))(*(void *)v29 + 384LL))(v29) & 1) != 0
          || (uint64_t v30 = sub_1002E6BF0(), (*(unsigned int (**)(uint64_t))(*(void *)v30 + 376LL))(v30)))
        {
          uint64_t v31 = sub_1002E6BF0();
          v208[7] = (*(uint64_t (**)(uint64_t))(*(void *)v31 + 376LL))(v31);
          uint64_t v32 = sub_1002E6BF0();
          LOBYTE(v137[0]) = (*(uint64_t (**)(uint64_t))(*(void *)v32 + 376LL))(v32);
          LODWORD(v137[2]) = 1966110;
          HIWORD(v137[0]) = 0;
          uint64_t v33 = *((void *)&v138[0] + 1);
          if (*((void *)&v138[0] + 1) >= *(void *)&v138[1])
          {
            uint64_t v37 = sub_10060F3A8((uint64_t *)v138, (uint64_t)&v207);
          }

          else
          {
            **((void **)&v138[0] + 1) = (id)v207.n128_u64[0];
            *(void *)(v33 + 8) = (id)v207.n128_u64[1];
            *(_OWORD *)(v33 + 16) = *(_OWORD *)v208;
            uint64_t v35 = *(_OWORD *)&v208[32];
            uint64_t v34 = *(_OWORD *)&v208[48];
            unsigned int v36 = *(_OWORD *)&v208[16];
            *(_OWORD *)(v33 + 78) = *(_OWORD *)&v208[62];
            *(_OWORD *)(v33 + 48) = v35;
            *(_OWORD *)(v33 + 64) = v34;
            *(_OWORD *)(v33 + 32) = v36;
            uint64_t v37 = v33 + 96;
          }

          *((void *)&v138[0] + 1) = v37;
          if (_os_feature_enabled_impl("CoreLocation", "StandardUT"))
          {
            uint64_t v177 = xmmword_1006BDCB0;
            uint64_t v178 = 0;
            sub_100634334((__n128 *)buf, (__n128 *)&v177);
            uint64_t v70 = *(_OWORD **)&v138[2];
            if (*(void *)&v138[2] >= *((void *)&v138[2] + 1))
            {
              uint64_t v92 = 0xCCCCCCCCCCCCCCCDLL * ((uint64_t)(*(void *)&v138[2] - *((void *)&v138[1] + 1)) >> 2);
              uint64_t v93 = v92 + 1;
              if (v92 + 1 > 0xCCCCCCCCCCCCCCCLL) {
                abort();
              }
              else {
                uint64_t v94 = v93;
              }
              if (v94) {
                uint64_t v95 = (char *)sub_100050420((uint64_t)&v138[2] + 8, v94);
              }
              else {
                uint64_t v95 = 0LL;
              }
              uint64_t v122 = &v95[20 * v92];
              uint64_t v123 = &v95[20 * v94];
              uint64_t v124 = *(_OWORD *)buf;
              *((_DWORD *)v122 + 4) = (_DWORD)v196;
              *(_OWORD *)uint64_t v122 = v124;
              uint64_t v72 = v122 + 20;
              unsigned int v126 = (char *)*((void *)&v138[1] + 1);
              uint64_t v125 = *(char **)&v138[2];
              if (*(void *)&v138[2] != *((void *)&v138[1] + 1))
              {
                do
                {
                  unsigned int v127 = *(_OWORD *)(v125 - 20);
                  *((_DWORD *)v122 - 1) = *((_DWORD *)v125 - 1);
                  *(_OWORD *)(v122 - 20) = v127;
                  v122 -= 20;
                  v125 -= 20;
                }

                while (v125 != v126);
                uint64_t v125 = (char *)*((void *)&v138[1] + 1);
              }

              *((void *)&v138[1] + 1) = v122;
              *(void *)&v138[2] = v72;
              *((void *)&v138[2] + 1) = v123;
              if (v125) {
                operator delete(v125);
              }
            }

            else
            {
              uint64_t v71 = *(_OWORD *)buf;
              *(_DWORD *)(*(void *)&v138[2] + 16LL) = (_DWORD)v196;
              *uint64_t v70 = v71;
              uint64_t v72 = (char *)v70 + 20;
            }

            *(void *)&v138[2] = v72;
            if (_os_feature_enabled_impl("BluetoothFeatures", "StandardUTFEAA"))
            {
              __int128 v175 = xmmword_1006BDCC4;
              uint64_t v176 = 0;
              sub_100634334((__n128 *)buf, (__n128 *)&v175);
              sub_1005E38E0((void **)&v138[1] + 1, (__int128 *)buf);
            }
          }
        }

        else
        {
          v208[7] = (dword_1008F1EA8 - 19) < 0x7BD;
          LOBYTE(v137[0]) = v208[7];
          LODWORD(v137[2]) = 1966110;
          HIWORD(v137[0]) = 0;
          sub_1005E3A00((uint64_t *)v138, (uint64_t)&v207);
          if (_os_feature_enabled_impl("CoreLocation", "StandardUT"))
          {
            uint64_t v173 = xmmword_1006BDCB0;
            uint64_t v174 = 0;
            sub_100634334((__n128 *)buf, (__n128 *)&v173);
            sub_1005E38E0((void **)&v138[1] + 1, (__int128 *)buf);
            if (_os_feature_enabled_impl("BluetoothFeatures", "StandardUTFEAA"))
            {
              uint64_t v171 = xmmword_1006BDCC4;
              uint64_t v172 = 0;
              sub_100634334((__n128 *)buf, (__n128 *)&v171);
              sub_1005E38E0((void **)&v138[1] + 1, (__int128 *)buf);
            }
          }
        }

        if (a2 == 65547)
        {
          *((void *)&v137[1] + 1) = 6000LL;
        }

        else
        {
          unsigned __int8 v128 = sub_1002E6BF0();
          if (((*(uint64_t (**)(uint64_t))(*(void *)v128 + 384LL))(v128) & 1) == 0)
          {
            *(void *)&v137[1] = 39000LL;
            else {
              uint64_t v132 = 0LL;
            }
            if (qword_1008D6198 != -1) {
              dispatch_once(&qword_1008D6198, &stru_1008A4058);
            }
            uint64_t v133 = sub_10044C108((uint64_t)off_1008D6190, v132, 1u);
            if ((~v133 & 6) == 0 || (v133 & 1) != 0)
            {
              strcpy((char *)&v137[2] + 2, "Z");
              BYTE7(v137[0]) = 1;
              BYTE4(v137[2]) = 1;
            }

            *((void *)&v137[1] + 1) = 120000LL;
            *(_WORD *)((char *)v137 + 9) = 257;
            BYTE11(v137[0]) = 1;
          }
        }

        goto LABEL_243;
      case 65549:
        uint64_t v209 = (unsigned __int128)0LL >> 112;
        uint64_t v207 = 0uLL;
        *(_OWORD *)uint64_t v208 = 0uLL;
        *(void *)&v208[1] = 0x100129C01010101LL;
        *(_WORD *)&v208[9] = 513;
        *(void *)&v208[12] = 0xFFFF0000FFFFLL;
        *(_DWORD *)&v208[20] = 0xFFFF;
        memset(&v208[24], 0, 54);
        uint64_t v46 = sub_1002E6BF0();
        if (qword_1008D6198 != -1) {
          dispatch_once(&qword_1008D6198, &stru_1008A4058);
        }
        uint64_t v47 = sub_10044C108((uint64_t)off_1008D6190, 63LL, 1u);
        v208[7] = 1;
        LOBYTE(v137[0]) = 1;
        BYTE2(v137[0]) = 1;
        if (!*(_BYTE *)(a1 + 144))
        {
LABEL_121:
          uint64_t v73 = 0LL;
          uint64_t v74 = *((void *)&v141[2] + 1);
          *(void *)(a3 + 64) = *(void *)&v141[1];
          uint64_t v75 = v140[1];
          *(_OWORD *)a3 = v140[0];
          *(_OWORD *)(a3 + 16) = v75;
          *(_OWORD *)(a3 + 28) = *(_OWORD *)((char *)&v140[1] + 12);
          *(_OWORD *)(a3 + 48) = v141[0];
          memset(v141, 0, 24);
          *(_OWORD *)(a3 + 72) = *(_OWORD *)((char *)&v141[1] + 8);
          *(void *)(a3 + 88) = v74;
          memset((char *)&v141[1] + 8, 0, 24);
          *(_BYTE *)(a3 + 96) = v142;
        }

        else
        {
          uint64_t v48 = v47;
          uint64_t v49 = sub_1002E6BF0();
          uint64_t v50 = (*(uint64_t (**)(uint64_t))(*(void *)v49 + 376LL))(v49);
          LOWORD(v137[2]) = 30;
          if (v50)
          {
            strcpy((char *)&v137[2] + 2, "(");
          }

          else
          {
            if ((v48 & 3) != 0)
            {
              if ((v48 & 5) != 0) {
                uint64_t v121 = 90;
              }
              else {
                uint64_t v121 = 60;
              }
              WORD1(v137[2]) = v121;
              BYTE7(v137[0]) = 1;
              BYTE4(v137[2]) = 1;
            }

            else
            {
              WORD1(v137[2]) = 30;
            }

            *(_DWORD *)((char *)v137 + 9) = 16843009;
          }

          HIWORD(v137[0]) = 0;
          *(void *)&v137[1] = 0LL;
          sub_1005E3A00((uint64_t *)v138, (uint64_t)&v207);
          if (_os_feature_enabled_impl("CoreLocation", "StandardUT"))
          {
            uint64_t v169 = xmmword_1006BDCB0;
            uint64_t v170 = 0;
            sub_100634334((__n128 *)buf, (__n128 *)&v169);
            sub_1005E38E0((void **)&v138[1] + 1, (__int128 *)buf);
            if (_os_feature_enabled_impl("BluetoothFeatures", "StandardUTFEAA"))
            {
              int v167 = xmmword_1006BDCC4;
              uint64_t v168 = 0;
              sub_100634334((__n128 *)buf, (__n128 *)&v167);
              sub_1005E38E0((void **)&v138[1] + 1, (__int128 *)buf);
            }
          }

          DWORD2(v137[2]) = 1;
          BYTE8(v137[0]) = 1;
          uint64_t v135 = v137[1];
          *(_OWORD *)a3 = v137[0];
          *(_OWORD *)(a3 + 16) = v135;
          *(_OWORD *)(a3 + 28) = *(_OWORD *)((char *)&v137[1] + 12);
          *(_OWORD *)(a3 + 48) = v138[0];
          *(void *)(a3 + 64) = *(void *)&v138[1];
          memset(v138, 0, 24);
          *(_OWORD *)(a3 + 72) = *(_OWORD *)((char *)&v138[1] + 8);
          *(void *)(a3 + 88) = *((void *)&v138[2] + 1);
          memset((char *)&v138[1] + 8, 0, 24);
          *(_BYTE *)(a3 + 96) = v139;
          uint64_t v73 = (void *)v207.n128_u64[1];
        }

        goto LABEL_108;
      case 65550:
        uint64_t v209 = (unsigned __int128)0LL >> 112;
        uint64_t v207 = 0uLL;
        *(_OWORD *)uint64_t v208 = 0uLL;
        *(void *)&v208[1] = 0x101129C01010101LL;
        *(_WORD *)&v208[9] = 513;
        *(void *)&v208[12] = 0xFFFF0000FFFFLL;
        *(_DWORD *)&v208[20] = 0xFFFF;
        memset(&v208[24], 0, 54);
        LOBYTE(v137[0]) = 1;
        BYTE2(v137[0]) = 1;
        LODWORD(v137[2]) = 19660830;
        HIWORD(v137[0]) = 0;
        *((void *)&v138[0] + 1) = sub_10060F3A8((uint64_t *)v138, (uint64_t)&v207);
        if (_os_feature_enabled_impl("CoreLocation", "StandardUT"))
        {
          uint64_t v165 = xmmword_1006BDCB0;
          uint64_t v166 = 0;
          sub_100634334((__n128 *)buf, (__n128 *)&v165);
          sub_1005E38E0((void **)&v138[1] + 1, (__int128 *)buf);
          if (_os_feature_enabled_impl("BluetoothFeatures", "StandardUTFEAA"))
          {
            uint64_t v163 = xmmword_1006BDCC4;
            uint64_t v164 = 0;
            sub_100634334((__n128 *)buf, (__n128 *)&v163);
            sub_1005E38E0((void **)&v138[1] + 1, (__int128 *)buf);
          }
        }

        *((void *)&v137[1] + 1) = 60000LL;
        DWORD2(v137[2]) = 1;
        BYTE8(v137[0]) = 1;
        uint64_t v45 = v137[1];
        *(_OWORD *)a3 = v137[0];
        *(_OWORD *)(a3 + 16) = v45;
        *(_OWORD *)(a3 + 28) = *(_OWORD *)((char *)&v137[1] + 12);
        *(_OWORD *)(a3 + 48) = v138[0];
        *(void *)(a3 + 64) = *(void *)&v138[1];
        memset(v138, 0, 24);
        *(_OWORD *)(a3 + 72) = *(_OWORD *)((char *)&v138[1] + 8);
        *(void *)(a3 + 88) = *((void *)&v138[2] + 1);
        memset((char *)&v138[1] + 8, 0, 24);
        *(_BYTE *)(a3 + 96) = v139;

        goto LABEL_108;
      case 65551:
        uint64_t v209 = (unsigned __int128)0LL >> 112;
        uint64_t v207 = 0uLL;
        *(_OWORD *)uint64_t v208 = 0uLL;
        *(void *)&v208[1] = 0x101129C01010101LL;
        *(_WORD *)&v208[9] = 513;
        *(void *)&v208[12] = 0xFFFF0000FFFFLL;
        *(_DWORD *)&v208[20] = 0xFFFF;
        memset(&v208[24], 0, 54);
        LOBYTE(v137[0]) = 1;
        LODWORD(v137[2]) = 2621470;
        HIWORD(v137[0]) = 0;
        *((void *)&v137[1] + 1) = 6000LL;
        *((void *)&v138[0] + 1) = sub_10060F3A8((uint64_t *)v138, (uint64_t)&v207);
        if (_os_feature_enabled_impl("CoreLocation", "StandardUT"))
        {
          uint64_t v161 = xmmword_1006BDCB0;
          uint64_t v162 = 0;
          sub_100634334((__n128 *)buf, (__n128 *)&v161);
          sub_1005E38E0((void **)&v138[1] + 1, (__int128 *)buf);
          if (_os_feature_enabled_impl("BluetoothFeatures", "StandardUTFEAA"))
          {
            uint64_t v159 = xmmword_1006BDCC4;
            uint64_t v160 = 0;
            sub_100634334((__n128 *)buf, (__n128 *)&v159);
            sub_1005E38E0((void **)&v138[1] + 1, (__int128 *)buf);
          }
        }

        goto LABEL_243;
      case 65552:
        uint64_t v209 = (unsigned __int128)0LL >> 112;
        uint64_t v207 = 0uLL;
        *(_OWORD *)uint64_t v208 = 0uLL;
        *(void *)&v208[1] = 0x101129C01010101LL;
        *(_WORD *)&v208[9] = 513;
        *(void *)&v208[12] = 0xFFFF0000FFFFLL;
        *(_DWORD *)&v208[20] = 0xFFFF;
        memset(&v208[24], 0, 54);
        LOBYTE(v137[0]) = 1;
        HIWORD(v137[0]) = 0;
        *((void *)&v137[1] + 1) = 60000LL;
        uint64_t v51 = *(unsigned __int8 *)(a1 + 144);
        BYTE5(v137[0]) = v51 ^ 1;
        if (v51)
        {
          *((void *)&v138[0] + 1) = sub_10060F3A8((uint64_t *)v138, (uint64_t)&v207);
          if (_os_feature_enabled_impl("CoreLocation", "StandardUT"))
          {
            uint64_t v157 = xmmword_1006BDCB0;
            uint64_t v158 = 0;
            sub_100634334((__n128 *)buf, (__n128 *)&v157);
            sub_1005E38E0((void **)&v138[1] + 1, (__int128 *)buf);
            if (_os_feature_enabled_impl("BluetoothFeatures", "StandardUTFEAA"))
            {
              char v155 = xmmword_1006BDCC4;
              uint64_t v156 = 0;
              sub_100634334((__n128 *)buf, (__n128 *)&v155);
              sub_1005E38E0((void **)&v138[1] + 1, (__int128 *)buf);
            }
          }

          LODWORD(v137[2]) = 5898270;
          uint64_t v7 = v138[0];
          uint64_t v52 = v138[1];
          uint64_t v53 = v138[2];
          uint64_t v54 = v139;
          uint64_t v55 = (void *)v207.n128_u64[1];
        }

        else
        {
          uint64_t v55 = 0LL;
          LODWORD(v137[2]) = 0;
          uint64_t v54 = 1;
          uint64_t v52 = 0uLL;
          uint64_t v53 = 0uLL;
        }

        DWORD2(v137[2]) = 1;
        BYTE8(v137[0]) = 1;
        uint64_t v91 = v137[1];
        *(_OWORD *)a3 = v137[0];
        *(_OWORD *)(a3 + 16) = v91;
        *(_OWORD *)(a3 + 28) = *(_OWORD *)((char *)&v137[1] + 12);
        memset(v138, 0, 24);
        *(_OWORD *)(a3 + 48) = v7;
        *(_OWORD *)(a3 + 64) = v52;
        *(_OWORD *)(a3 + 80) = v53;
        memset((char *)&v138[1] + 8, 0, 24);
        *(_BYTE *)(a3 + 96) = v54;

        goto LABEL_108;
      case 65553:
        if (!*(_BYTE *)(a1 + 144)) {
          goto LABEL_83;
        }
        uint64_t v209 = (unsigned __int128)0LL >> 112;
        uint64_t v207 = 0uLL;
        *(_OWORD *)uint64_t v208 = 0uLL;
        *(void *)&v208[1] = 0x101129C00010101LL;
        *(_WORD *)&v208[9] = 513;
        *(void *)&v208[12] = 0xFFFF0000FFFFLL;
        *(_DWORD *)&v208[20] = 0xFFFF;
        memset(&v208[24], 0, 54);
        *((void *)&v138[0] + 1) = sub_10060F3A8((uint64_t *)v138, (uint64_t)&v207);
        if (_os_feature_enabled_impl("CoreLocation", "StandardUT"))
        {
          LOBYTE(v139) = 0;
          uint64_t v153 = xmmword_1006BDCB0;
          uint64_t v154 = 0;
          sub_100634334((__n128 *)buf, (__n128 *)&v153);
          sub_1005E38E0((void **)&v138[1] + 1, (__int128 *)buf);
          if (_os_feature_enabled_impl("BluetoothFeatures", "StandardUTFEAA"))
          {
            uint64_t v151 = xmmword_1006BDCC4;
            uint64_t v152 = 0;
            sub_100634334((__n128 *)buf, (__n128 *)&v151);
            sub_1005E38E0((void **)&v138[1] + 1, (__int128 *)buf);
          }
        }

        goto LABEL_24;
      case 65554:
        uint64_t v209 = (unsigned __int128)0LL >> 112;
        uint64_t v207 = 0uLL;
        *(_OWORD *)uint64_t v208 = 0uLL;
        *(void *)&v208[1] = 0x101129C01010101LL;
        *(_WORD *)&v208[9] = 513;
        *(void *)&v208[12] = 0xFFFF0000FFFFLL;
        *(_DWORD *)&v208[20] = 0xFFFF;
        memset(&v208[24], 0, 54);
        LOBYTE(v137[0]) = 1;
        LODWORD(v137[2]) = 1966110;
        HIWORD(v137[0]) = 0;
        *((void *)&v138[0] + 1) = sub_10060F3A8((uint64_t *)v138, (uint64_t)&v207);
        if (_os_feature_enabled_impl("CoreLocation", "StandardUT"))
        {
          uint64_t v149 = xmmword_1006BDCB0;
          uint64_t v150 = 0;
          sub_100634334((__n128 *)buf, (__n128 *)&v149);
          sub_1005E38E0((void **)&v138[1] + 1, (__int128 *)buf);
          if (_os_feature_enabled_impl("BluetoothFeatures", "StandardUTFEAA"))
          {
            uint64_t v147 = xmmword_1006BDCC4;
            uint64_t v148 = 0;
            sub_100634334((__n128 *)buf, (__n128 *)&v147);
            sub_1005E38E0((void **)&v138[1] + 1, (__int128 *)buf);
          }
        }

LABEL_157:
          *(_BYTE *)(v261 + 29) = *(_BYTE *)(v261 + 29) & 0xDF | HIBYTE(v262) & 0x20;
          goto LABEL_158;
        }

LABEL_183:
        *(_BYTE *)(v261 + 29) = *(_BYTE *)(v261 + 29) & 0xEF | HIBYTE(v262) & 0x10;
        if ((v214 & 0x2000) == 0) {
          goto LABEL_158;
        }
        goto LABEL_157;
      }

      if ((_DWORD)v7 == 1)
      {
        uint64_t v37 = sub_1001D89B0(a1, v36 >> 2, &v261);
        if ((_DWORD)v37)
        {
          uint64_t v38 = v37;
          if (sub_1000A86F0())
          {
            sub_1001EE134((uint64_t)"Receive RPN with result %! on DLCI %d", v39, v40, v41, v42, v43, v44, v45, v38);
            uint64_t v46 = (os_log_s *)sub_100086554(0x32u);
            if (os_log_type_enabled(v46, OS_LOG_TYPE_ERROR)) {
              sub_100657858();
            }
          }

          uint64_t v259 = 50806655LL;
          __int16 v260 = 4881;
          if ((v5 & 2) != 0)
          {
            uint64_t v47 = sub_1001DDF64(a1, 0, v20, (uint64_t)&v259);
            if ((_DWORD)v47)
            {
              uint64_t v48 = v47;
              if (sub_1000A86F0())
              {
                sub_1001EE134((uint64_t)"%! (%d)", v49, v50, v51, v52, v53, v54, v55, v48);
                uint64_t v56 = (os_log_s *)sub_100086554(0x32u);
                if (os_log_type_enabled(v56, OS_LOG_TYPE_ERROR)) {
                  sub_100657858();
                }
              }
            }
          }

          return;
        }

        if ((v5 & 2) != 0)
        {
          uint64_t v226 = sub_1001DDF64(a1, 0, v20, v261 + 22);
          if (!(_DWORD)v226) {
            return;
          }
          uint64_t v227 = v226;
          sub_1001EE134((uint64_t)"%! (%d)", v228, v229, v230, v231, v232, v233, v234, v227);
          uint64_t v235 = (os_log_s *)sub_100086554(0x32u);
          if (!os_log_type_enabled(v235, OS_LOG_TYPE_ERROR)) {
            return;
          }
        }

        else
        {
          sub_1001EE134( (uint64_t)"Mux_ReceiveRPN, command is parameter report but C/R bit is not set, ignoring",  v194,  v195,  v196,  v197,  v198,  v199,  v200,  v258);
          v201 = (os_log_s *)sub_100086554(0x32u);
          if (!os_log_type_enabled(v201, OS_LOG_TYPE_ERROR)) {
            return;
          }
        }

LABEL_209:
        sub_100657858();
        return;
      }

      if (sub_1000A86F0())
      {
        sub_1001EE134((uint64_t)"%! (%d)", v147, v148, v149, v150, v151, v152, v153, 917LL);
        uint64_t v154 = (os_log_s *)sub_100086554(0x32u);
        if (os_log_type_enabled(v154, OS_LOG_TYPE_ERROR)) {
          goto LABEL_107;
        }
      }

      return;
    case 9u:
      if (!a1)
      {
        sub_1001EE2A0();
        char v5 = *a2;
      }

      if ((v5 & 2) != 0)
      {
        sub_1001DDDE8(a1, 0);
        if (!*(_BYTE *)(a1 + 44))
        {
          *(_BYTE *)(a1 + 45) = 1;
          sub_1001DC0BC(a1);
        }
      }

      else
      {
LABEL_52:
        sub_1001DDAE8(a1);
      }

      return;
    case 0xDu:
      if (!a1) {
        sub_1001EE2A0();
      }
      uint64_t v262 = 0LL;
      uint64_t v20 = a2[2] >> 2;
      char v57 = a2[3];
      if ((_DWORD)v7 == 2)
      {
        uint64_t v58 = 0LL;
      }

      else
      {
        if ((_DWORD)v7 != 3)
        {
          if (sub_1000A86F0())
          {
            sub_1001EE134((uint64_t)"%! (%d)", v101, v102, v103, v104, v105, v106, v107, 917LL);
            uint64_t v108 = (os_log_s *)sub_100086554(0x32u);
            if (os_log_type_enabled(v108, OS_LOG_TYPE_ERROR)) {
LABEL_107:
            }
              sub_100657858();
          }

          return;
        }

        uint64_t v58 = ((char)(a2[4] << 6) >> 7) & (a2[4] >> 4);
      }

      uint64_t v91 = sub_1001D89B0(a1, v20, &v262);
      if ((_DWORD)v91)
      {
        uint64_t v92 = v91;
        if (sub_1000A86F0())
        {
          sub_1001EE134((uint64_t)"%! (%d)", v93, v94, v95, v96, v97, v98, v99, v92);
          uint64_t v100 = (os_log_s *)sub_100086554(0x32u);
          if (os_log_type_enabled(v100, OS_LOG_TYPE_ERROR)) {
            sub_100657858();
          }
        }

        if ((*a2 & 2) != 0) {
LABEL_79:
        }
          sub_1001DC2AC(15LL, a1, v20);
        return;
      }

      if ((*a2 & 2) != 0)
      {
        sub_1001DDEC8(a1, 0, v20, v57, v58);
        uint64_t v166 = v262;
        if (!*(_BYTE *)(a1 + 44))
        {
          if ((v57 & 2) != 0)
          {
            *(_BYTE *)(v262 + 32) = 0;
          }

          else
          {
            *(_BYTE *)(v262 + 32) = 1;
            sub_1001DC064(v166);
            uint64_t v166 = v262;
          }
        }

        uint64_t v236 = *(void (**)(void, void, uint64_t))(*(void *)(v166 + 40) + 24LL);
        if (v236) {
          v236(*(unsigned __int16 *)(v166 + 8), v57 & 0xCE, v58);
        }
        return;
      }

      sub_1001DDAE8(a1);
      uint64_t v125 = v262;
      if (*(_BYTE *)(v262 + 13) != 4) {
        return;
      }
      *(_BYTE *)(v262 + 13) = 5;
      if (!*(_BYTE *)(a1 + 44)) {
        goto LABEL_191;
      }
      unsigned int v126 = *(unsigned __int8 *)(v125 + 162);
      if (*(_BYTE *)(v125 + 162))
      {
        unsigned int v127 = *(unsigned __int8 *)(v125 + 14);
        if (v126 < v127)
        {
          sub_1001EE2A0();
          uint64_t v125 = v262;
          LOBYTE(v126) = *(_BYTE *)(v262 + 162);
          LOBYTE(v12memset((char *)&v11[1] + 1, 0, 7) = *(_BYTE *)(v262 + 14);
        }

        unsigned __int8 v128 = v126 - v127 - *(_BYTE *)(v125 + 163);
        if (!v128)
        {
LABEL_191:
          uint64_t v237 = *(void (**)(void, void, void))(v125 + 72);
          if (v237)
          {
            v237(*(unsigned __int16 *)(v125 + 8), *(unsigned __int16 *)(v125 + 16), 0LL);
            *(void *)(v262 + 72) = 0LL;
          }

          return;
        }
      }

      else
      {
        unsigned __int8 v128 = -1;
      }

      uint64_t v125 = v262;
      goto LABEL_191;
    default:
      LOWORD(v262) = 785;
      BYTE2(v262) = v5 & 0xFE;
      sub_1001DC780(a1, 0LL, (char *)&v262, 3uLL, 0);
      return;
  }

uint64_t sub_1001DF01C(int a1, char a2, unsigned int a3, __int16 a4, int a5)
{
  uint64_t v9 = sub_1001D8EC4(a1);
  if (!v9) {
    return 114LL;
  }
  uint64_t v40 = 0LL;
  uint64_t v10 = 2 * (a2 & 0x7Fu);
  if (v10 >= 0x3E)
  {
    if (sub_1000A86F0())
    {
      sub_1001EE134((uint64_t)"%! (%d)", v11, v12, v13, v14, v15, v16, v17, 917LL);
      uint64_t v18 = (os_log_s *)sub_100086554(0x32u);
      if (os_log_type_enabled(v18, OS_LOG_TYPE_ERROR)) {
        sub_100657858();
      }
    }

    return 114LL;
  }

  uint64_t v19 = v9;
  if (sub_1001D89B0(v9, v10, &v40))
  {
    sub_1001EE134((uint64_t)"Could not find link for DLCI (%d)", v20, v21, v22, v23, v24, v25, v26, v10);
    uint64_t v27 = (os_log_s *)sub_100086554(0x32u);
    if (!os_log_type_enabled(v27, OS_LOG_TYPE_ERROR)) {
      return 114LL;
    }
    goto LABEL_9;
  }

  uint64_t v28 = v40;
  if (*(_BYTE *)(v40 + 13)) {
    return 114LL;
  }
  if (a5)
  {
    *(_BYTE *)(v19 + 44) = 1;
    *(_WORD *)(v28 + 18) = a4;
    uint64_t v30 = sub_1001DBC70(v28);
    if ((_DWORD)v30)
    {
      uint64_t v31 = v30;
      sub_1001EE134((uint64_t)"%! (%d)", v32, v33, v34, v35, v36, v37, v38, v31);
      uint64_t v39 = (os_log_s *)sub_100086554(0x32u);
      if (!os_log_type_enabled(v39, OS_LOG_TYPE_ERROR)) {
        return 114LL;
      }
LABEL_9:
      sub_100657858();
      return 114LL;
    }

    uint64_t v28 = v40;
  }

  else
  {
    LOBYTE(a4) = 0;
    *(_BYTE *)(v19 + 44) = 0;
  }

  uint64_t result = 0LL;
  *(_BYTE *)(v28 + 14) = a4;
  *(_BYTE *)(v28 + 13) = 5;
  return result;
}

uint64_t sub_1001DF1BC(unsigned int a1, _WORD *a2)
{
  unsigned int v3 = 0;
  v4[0] = 262147LL;
  v4[1] = a1;
  else {
    return v3;
  }
}

void sub_1001DF214()
{
  byte_1008EDC58 = 1;
}

uint64_t sub_1001DF224(uint64_t a1, uint64_t a2, uint64_t a3)
{
  if ((_DWORD)xmmword_1008F6FD8) {
    return 821LL;
  }
  if (!*(_WORD *)(sub_1001EDBA0(0x34u) + 2)) {
    sub_1001EE2A0();
  }
  if (!*(_WORD *)sub_1001EDBA0(0x34u)) {
    sub_1001EE2A0();
  }
  if ((_DWORD)xmmword_1008F6FD8)
  {
    uint64_t v3 = 140LL;
LABEL_10:
    if (sub_1000A86F0())
    {
      sub_1001EE134((uint64_t)"SDP client init failed %!", v8, v9, v10, v11, v12, v13, v14, v3);
      uint64_t v15 = (os_log_s *)sub_100086554(0x34u);
      if (os_log_type_enabled(v15, OS_LOG_TYPE_ERROR)) {
        sub_10065B898();
      }
    }

    return v3;
  }

  uint64_t v16 = sub_1000B1814(0x60uLL);
  qword_1008EDC60 = (uint64_t)v16;
  if (!v16)
  {
    uint64_t v3 = 106LL;
    goto LABEL_10;
  }

  if (byte_1008EDC58 == 1)
  {
    unsigned int v17 = 1024;
    v16[44] = 1024;
    LODWORD(xmmword_1008F6FD8) = 1;
    __int128 v21 = 0u;
    __int128 v22 = 0u;
    WORD2(v21) = 5000;
    LODWORD(v21) = -64512;
  }

  else
  {
    unsigned int v17 = (unsigned __int16)v16[44];
    LODWORD(xmmword_1008F6FD8) = 1;
    __int128 v22 = 0uLL;
    *((void *)&v21 + 1) = 0LL;
    *(_DWORD *)((char *)&v21 + 2) = 327745535;
    if (!v17) {
      unsigned int v17 = *(unsigned __int16 *)sub_1001EDBA0(0x34u);
    }
    LOWORD(v21) = v17;
    if (v17 <= 0x80)
    {
      __int16 v18 = 128;
      goto LABEL_23;
    }
  }

  __int16 v18 = *(_WORD *)(sub_1001EDBA0(0x28u) + 8);
LABEL_23:
  LOWORD(v21) = v18;
LABEL_24:
  WORD3(v21) = 772;
  WORD6(v21) = 0;
  BYTE8(vmemset(v6, 0, 22) = 0;
  uint64_t v19 = sub_100174028( (uint64_t)sub_1001DF42C,  (uint64_t)sub_1001DF5D4,  (uint64_t)sub_1001DF5D8,  1,  a3,  (uint64_t)&v21,  (_WORD *)(qword_1008EDC60 + 4),  (uint64_t)&unk_1006BDF90);
  if ((_DWORD)v19)
  {
    uint64_t v3 = v19;
    sub_1001DF7E8();
  }

  else
  {
    uint64_t v20 = qword_1008EDC60;
    *(_DWORD *)qword_1008EDC60 = 0;
    *(void *)(v20 + 72) = a2;
    *(void *)(v20 + 80) = a1;
    if (off_1008EDC68) {
      off_1008EDC68(1LL);
    }
    return 0LL;
  }

  return v3;
}

void sub_1001DF42C(unsigned int a1, unsigned int a2, unsigned int a3, uint64_t a4)
{
  if ((_DWORD)xmmword_1008F6FD8 && !*(_DWORD *)qword_1008EDC60)
  {
    uint64_t v13 = a4;
    if ((_DWORD)a4)
    {
      if (sub_1000A86F0())
      {
        sub_1001EE134((uint64_t)"SDP client connect failed %!", v14, v15, v16, v17, v18, v19, v20, v13);
        __int128 v21 = (os_log_s *)sub_100086554(0x34u);
        if (os_log_type_enabled(v21, OS_LOG_TYPE_ERROR)) {
          sub_10065B898();
        }
      }

      if (off_1008EDC68) {
        off_1008EDC68(0LL);
      }
    }

    else
    {
      __int16 v22 = a3;
      uint64_t v24 = qword_1008EDC60;
      *(_WORD *)(qword_1008EDC60 + 12) = v22;
      int v25 = *(unsigned __int16 *)(v24 + 88);
      if (!v25)
      {
        uint64_t v26 = (unsigned __int16 *)sub_1001EDBA0(0x34u);
        LOWORD(v25) = a2;
        if (*v26 < a2) {
          LOWORD(v25) = *(_WORD *)sub_1001EDBA0(0x34u);
        }
      }

      uint64_t v27 = qword_1008EDC60;
      *(_WORD *)(qword_1008EDC60 + 14) = v25;
      *(_DWORD *)uint64_t v27 = 1;
      uint64_t v28 = sub_1000B17F4(*(unsigned __int16 *)(v27 + 12));
      uint64_t v29 = qword_1008EDC60;
      *(void *)(qword_1008EDC60 + 24) = v28;
      if (v28)
      {
        (*(void (**)(void))(v29 + 80))(0LL);
        return;
      }

      uint64_t v13 = 106LL;
    }

    uint64_t v30 = *(void (**)(uint64_t))(qword_1008EDC60 + 80);
    sub_1001DF7E8();
    v30(v13);
  }

  else if (sub_1000A86F0())
  {
    sub_1001EE134((uint64_t)"Spurious connect complete callback CID = %d", v5, v6, v7, v8, v9, v10, v11, a1);
    uint64_t v12 = (os_log_s *)sub_100086554(0x34u);
    if (os_log_type_enabled(v12, OS_LOG_TYPE_ERROR)) {
      sub_10065C5D8();
    }
  }

void sub_1001DF5D8(uint64_t a1, char *a2, unsigned int a3)
{
  uint64_t v32 = 0LL;
  uint64_t v33 = 0LL;
  if (*(unsigned __int16 *)(qword_1008EDC60 + 4) == (_DWORD)a1)
  {
    sub_1001EEB14(*(unsigned int *)(qword_1008EDC60 + 8));
    if (*(_DWORD *)qword_1008EDC60 == 2)
    {
      if (a3 < 5)
      {
        uint64_t v5 = 804LL;
LABEL_35:
        sub_1001E0D38(v5);
        return;
      }

      if (!a2) {
        sub_1000E6B88( "/Library/Caches/com.apple.xbs/Sources/MobileBluetooth_base/Stack/corestack/sdp/sdp.c",  1141,  "buf");
      }
      uint64_t v32 = a2;
      LOWORD(v33) = a3;
      WORD1(v33) = a3;
      int v23 = *a2;
      unsigned int v24 = bswap32(*(unsigned __int16 *)(a2 + 1));
      HIDWORD(v33) = 65539;
      if (*(unsigned __int16 *)(qword_1008EDC60 + 68) != HIWORD(v24))
      {
        uint64_t v5 = 830LL;
        goto LABEL_35;
      }

      int v25 = a2[4];
      int v26 = a2[3];
      WORD2(v33) = 5;
      if (v23 != *(unsigned __int8 *)(qword_1008EDC60 + 32))
      {
        if (v23 == 1)
        {
          if (a3 - 7 > 0xFFFFFFFD)
          {
            HIBYTE(v33) = 1;
            unsigned int v28 = 800;
          }

          else
          {
            unsigned int v27 = __rev16(*(unsigned __int16 *)(a2 + 5));
            WORD2(v33) = 7;
            unsigned int v28 = v27 + 800;
          }

          if (v28 >= 0x327) {
            uint64_t v5 = 807LL;
          }
          else {
            uint64_t v5 = v28;
          }
        }

        else
        {
          uint64_t v5 = 831LL;
        }

        goto LABEL_35;
      }

      if ((v25 | (v26 << 8)) < a3 - 5)
      {
        uint64_t v5 = 829LL;
        goto LABEL_35;
      }

      int v29 = *(unsigned __int8 *)(qword_1008EDC60 + 32);
      if (v29 == 7 || v29 == 5)
      {
        uint64_t v5 = sub_1001E05B4((uint64_t)&v32);
      }

      else if (v29 == 3)
      {
        uint64_t v5 = sub_1001E03BC((uint64_t *)&v32);
      }

      else
      {
        sub_1001EE2A0();
        uint64_t v5 = 0LL;
      }

      if ((_DWORD)v5) {
        goto LABEL_35;
      }
    }

    else if (sub_1000A86F0())
    {
      sub_1001EE134((uint64_t)"SDP client not expecting data at this time", v15, v16, v17, v18, v19, v20, v21, v31);
      __int16 v22 = (os_log_s *)sub_100086554(0x34u);
      if (os_log_type_enabled(v22, OS_LOG_TYPE_ERROR)) {
        sub_10065C6B8();
      }
    }
  }

  else if (sub_1000A86F0())
  {
    sub_1001EE134((uint64_t)"ReceivedResponseCB no server corresponds to CID = %x", v7, v8, v9, v10, v11, v12, v13, a1);
    uint64_t v14 = (os_log_s *)sub_100086554(0x34u);
    if (os_log_type_enabled(v14, OS_LOG_TYPE_ERROR)) {
      sub_10065C5D8();
    }
  }

void sub_1001DF7E8()
{
  BOOL v0 = (void **)qword_1008EDC60;
  if (*(_DWORD *)(qword_1008EDC60 + 8))
  {
    sub_1001EEB14(*(unsigned int *)(qword_1008EDC60 + 8));
    uint64_t v1 = qword_1008EDC60;
    *(_DWORD *)(qword_1008EDC60 + 8) = 0;
    sub_1001759FC(*(unsigned __int16 *)(v1 + 4), 436LL);
    BOOL v0 = (void **)qword_1008EDC60;
  }

  if (v0[3])
  {
    sub_1000B1838(v0[3]);
    BOOL v0 = (void **)qword_1008EDC60;
    *(void *)(qword_1008EDC60 + 24) = 0LL;
  }

  if (v0[5])
  {
    sub_1000B1838(v0[5]);
    BOOL v0 = (void **)qword_1008EDC60;
    *(void *)(qword_1008EDC60 + 40) = 0LL;
  }

  if (v0[7])
  {
    sub_1000B1838(v0[7]);
    BOOL v0 = (void **)qword_1008EDC60;
    *(void *)(qword_1008EDC60 + 56) = 0LL;
  }

  sub_1000B1838(v0);
  qword_1008EDC60 = 0LL;
  byte_1008EDC58 = 0;
  LODWORD(xmmword_1008F6FD8) = 0;
}

uint64_t sub_1001DF894()
{
  if (!(_DWORD)xmmword_1008F6FD8) {
    return 810LL;
  }
  uint64_t v0 = qword_1008EDC60;
  if (*(_DWORD *)qword_1008EDC60 == 3) {
    return 810LL;
  }
  if (off_1008EDC68)
  {
    off_1008EDC68(0LL);
    uint64_t v0 = qword_1008EDC60;
  }

  uint64_t v1 = sub_1001759FC(*(unsigned __int16 *)(v0 + 4), 436LL);
  if ((_DWORD)v1)
  {
    sub_1001DF930(*(unsigned __int16 *)(qword_1008EDC60 + 4));
  }

  else
  {
    sub_1001EEB14(*(unsigned int *)(qword_1008EDC60 + 8));
    uint64_t v2 = (_DWORD *)qword_1008EDC60;
    *(_DWORD *)(qword_1008EDC60 + 8) = 0;
    *uint64_t v2 = 3;
  }

  return v1;
}

uint64_t sub_1001DF930(uint64_t result)
{
  if ((_DWORD)xmmword_1008F6FD8)
  {
    uint64_t v1 = result;
    if (off_1008EDC68) {
      off_1008EDC68(0LL);
    }
    if (*(unsigned __int16 *)(qword_1008EDC60 + 4) != (_DWORD)v1 && sub_1000A86F0())
    {
      sub_1001EE134((uint64_t)"No SDP connection for CID %d", v2, v3, v4, v5, v6, v7, v8, v1);
      uint64_t v9 = (os_log_s *)sub_100086554(0x34u);
      if (os_log_type_enabled(v9, OS_LOG_TYPE_ERROR)) {
        sub_10065C5D8();
      }
    }

    uint64_t v10 = *(uint64_t (**)(void))(qword_1008EDC60 + 72);
    sub_1001DF7E8();
    return v10();
  }

  return result;
}

uint64_t sub_1001DF9E0(uint64_t a1, unsigned int a2, unsigned __int8 *a3)
{
  if (!(_DWORD)xmmword_1008F6FD8) {
    return 810LL;
  }
  uint64_t v3 = qword_1008EDC60;
  int v4 = *(_DWORD *)qword_1008EDC60;
  if (!*(_DWORD *)qword_1008EDC60 || v4 == 3) {
    return 810LL;
  }
  if (v4 == 2) {
    return 817LL;
  }
  if (!a2) {
    return 825LL;
  }
  *(_WORD *)(qword_1008EDC60 + 48) = a2;
  *(_WORD *)(v3 + 50) = 0;
  int v10 = sub_10010AE3C(a3);
  if (v10 == 65534) {
    return 106LL;
  }
  unsigned __int16 v11 = v10 + 24;
  uint64_t v12 = sub_1000B17F4(4LL * a2);
  uint64_t v13 = qword_1008EDC60;
  *(void *)(qword_1008EDC60 + 40) = v12;
  if (!v12) {
    return 106LL;
  }
  uint64_t v14 = *(_BYTE **)(v13 + 24);
  if (!v14)
  {
    uint64_t v19 = "SDP_State->ReqBuffer";
    goto LABEL_32;
  }

  if (!v11)
  {
    uint64_t v19 = "(bufLen) > 0";
LABEL_32:
    sub_1000E6B88("/Library/Caches/com.apple.xbs/Sources/MobileBluetooth_base/Stack/corestack/sdp/sdp.c", 1315, v19);
  }

  __int16 v22 = v14;
  unsigned __int16 v23 = v11;
  __int16 v26 = 2;
  unsigned __int16 v24 = v11;
  *uint64_t v14 = 2;
  if ((unint64_t)v11 - 5 >= 0xFFFFFFFFFFFFFFFCLL) {
    sub_1000E6B88( "/Library/Caches/com.apple.xbs/Sources/MobileBluetooth_base/Stack/corestack/sdp/sdp.c",  1324,  "ByteStream_NumReadBytesAvail(request) >= (2 * sizeof(uint16_t))");
  }
  unsigned __int16 v25 = 5;
  sub_10010B0BC((uint64_t)&v22, a3);
  if (HIBYTE(v26))
  {
    sub_1001ED1C4((uint64_t)"/Library/Caches/com.apple.xbs/Sources/MobileBluetooth_base/Stack/corestack/sdp/sdp.c");
    goto LABEL_35;
  }

  if (v24 - v25 <= 1)
  {
LABEL_35:
    uint64_t v20 = "ByteStream_NumReadBytesAvail(request) >= 2";
    goto LABEL_37;
  }

  if (v26 != 2)
  {
    uint64_t v20 = "(request).__RWFlag == BYTESTREAM_WRITE";
LABEL_37:
    sub_1000E6B88("/Library/Caches/com.apple.xbs/Sources/MobileBluetooth_base/Stack/corestack/sdp/sdp.c", 1332, v20);
  }

  v22[v25 + 1] = *(_BYTE *)(qword_1008EDC60 + 48);
  v22[v25] = *(_BYTE *)(qword_1008EDC60 + 49);
  unsigned __int16 v15 = v25;
  unsigned __int16 v16 = v25 + 2;
  unsigned __int16 v25 = v16;
  *(_WORD *)(qword_1008EDC60 + 16) = v16;
  if (HIBYTE(v26))
  {
    sub_1001ED1C4((uint64_t)"/Library/Caches/com.apple.xbs/Sources/MobileBluetooth_base/Stack/corestack/sdp/sdp.c");
    goto LABEL_39;
  }

  if (v24 <= v16)
  {
LABEL_39:
    uint64_t v21 = "ByteStream_NumReadBytesAvail(request) >= 1";
    goto LABEL_41;
  }

  if (v26 != 2)
  {
    uint64_t v21 = "(request).__RWFlag == BYTESTREAM_WRITE";
LABEL_41:
    sub_1000E6B88("/Library/Caches/com.apple.xbs/Sources/MobileBluetooth_base/Stack/corestack/sdp/sdp.c", 1341, v21);
  }

  unsigned __int16 v25 = v15 + 3;
  v22[v16] = 0;
  if (v26 == 2)
  {
    unsigned __int16 v17 = v25;
    unsigned __int16 v24 = v25;
  }

  else
  {
    unsigned __int16 v17 = v24;
  }

  LOBYTE(v26) = 15;
  uint64_t v18 = qword_1008EDC60;
  *(_WORD *)(qword_1008EDC60 + 18) = v17;
  *(void *)(v18 + 80) = a1;
  *(_BYTE *)(v18 + 32) = 3;
  return sub_1001DFCA8();
}

uint64_t sub_1001DFCA8()
{
  uint64_t v0 = qword_1008EDC60;
  __int16 v1 = *(_WORD *)(qword_1008EDC60 + 68) + 1;
  *(_WORD *)(qword_1008EDC60 + 68) = v1;
  *(_BYTE *)(*(void *)(v0 + 24) + 2LL) = v1;
  *(_BYTE *)(*(void *)(v0 + 24) + 1LL) = *(_BYTE *)(v0 + 69);
  __int16 v2 = *(_WORD *)(v0 + 18) - 5;
  *(_BYTE *)(*(void *)(v0 + 24) + 4LL) = v2;
  *(_BYTE *)(*(void *)(v0 + 24) + 3LL) = HIBYTE(v2);
  uint64_t result = sub_100172DA0( (uint64_t)sub_1001E1190,  *(unsigned __int16 *)(v0 + 4),  0LL,  *(char **)(v0 + 24),  *(unsigned __int16 *)(v0 + 18));
  if (!(_DWORD)result)
  {
    uint64_t result = sub_1001EE6E8((uint64_t)sub_1001E11AC, 0LL, 70, (int *)(qword_1008EDC60 + 8));
    *(_DWORD *)qword_1008EDC60 = 2;
  }

  return result;
}

uint64_t sub_1001DFD4C(uint64_t a1, unsigned int a2, unsigned __int8 *a3)
{
  if (!(_DWORD)xmmword_1008F6FD8) {
    return 810LL;
  }
  uint64_t v19 = 0LL;
  int v3 = *(_DWORD *)qword_1008EDC60;
  if (!*(_DWORD *)qword_1008EDC60 || v3 == 3) {
    return 810LL;
  }
  if (v3 == 2) {
    return 817LL;
  }
  uint64_t result = sub_1001DFFAC((uint64_t)a3);
  if (!(_DWORD)result)
  {
    int v9 = sub_10010AE3C(a3);
    if (!v9) {
      return 106LL;
    }
    uint64_t v10 = qword_1008EDC60;
    uint64_t v11 = *(void *)(qword_1008EDC60 + 24);
    if (v11)
    {
      if ((_WORD)v9 != 0xFFE4)
      {
        uint64_t v18 = *(void *)(qword_1008EDC60 + 24);
        LOWORD(v19) = v9 + 28;
        HIWORD(v19) = 2;
        WORD1(v19) = v9 + 28;
        *(_BYTE *)uint64_t v11 = 4;
        if ((unint64_t)(unsigned __int16)(v9 + 28) - 5 >= 0xFFFFFFFFFFFFFFFCLL) {
          sub_1000E6B88( "/Library/Caches/com.apple.xbs/Sources/MobileBluetooth_base/Stack/corestack/sdp/sdp.c",  1470,  "ByteStream_NumReadBytesAvail(request) >= (2 * sizeof(uint16_t))");
        }
        unsigned int v12 = (unsigned __int16)(v9 + 28);
        if (v12 <= 8) {
          sub_1000E6B88( "/Library/Caches/com.apple.xbs/Sources/MobileBluetooth_base/Stack/corestack/sdp/sdp.c",  1474,  "ByteStream_NumReadBytesAvail(request) >= 4");
        }
        *(_DWORD *)(v11 + 5) = bswap32(a2);
        if (v12 <= 0xA) {
          sub_1000E6B88( "/Library/Caches/com.apple.xbs/Sources/MobileBluetooth_base/Stack/corestack/sdp/sdp.c",  1475,  "ByteStream_NumReadBytesAvail(request) >= 2");
        }
        *(_BYTE *)(v11 + 10) = *(_BYTE *)(v10 + 14);
        *(_BYTE *)(v11 + 9) = *(_BYTE *)(v10 + 15);
        WORD2(v19) = 11;
        sub_10010B0BC((uint64_t)&v18, a3);
        uint64_t v13 = WORD2(v19);
        *(_WORD *)(qword_1008EDC60 + 16) = WORD2(v19);
        if (HIBYTE(v19))
        {
          sub_1001ED1C4((uint64_t)"/Library/Caches/com.apple.xbs/Sources/MobileBluetooth_base/Stack/corestack/sdp/sdp.c");
        }

        else if (WORD1(v19) > v13)
        {
          if (BYTE6(v19) == 2)
          {
            WORD2(v19) = v13 + 1;
            *(_BYTE *)(v18 + v13) = 0;
            if (BYTE6(v19) == 2)
            {
              __int16 v14 = WORD2(v19);
              WORD1(v19) = WORD2(v19);
            }

            else
            {
              __int16 v14 = WORD1(v19);
            }

            BYTE6(v19) = 15;
            uint64_t v15 = qword_1008EDC60;
            *(_WORD *)(qword_1008EDC60 + 18) = v14;
            *(void *)(v15 + 80) = a1;
            *(_BYTE *)(v15 + 32) = 5;
            return sub_1001DFCA8();
          }

          unsigned __int16 v17 = "(request).__RWFlag == BYTESTREAM_WRITE";
LABEL_37:
          sub_1000E6B88( "/Library/Caches/com.apple.xbs/Sources/MobileBluetooth_base/Stack/corestack/sdp/sdp.c",  1485,  v17);
        }

        unsigned __int16 v17 = "ByteStream_NumReadBytesAvail(request) >= 1";
        goto LABEL_37;
      }

      unsigned __int16 v16 = "(bufLen) > 0";
    }

    else
    {
      unsigned __int16 v16 = "SDP_State->ReqBuffer";
    }

    sub_1000E6B88("/Library/Caches/com.apple.xbs/Sources/MobileBluetooth_base/Stack/corestack/sdp/sdp.c", 1461, v16);
  }

  return result;
}

uint64_t sub_1001DFFAC(uint64_t a1)
{
  if (!*(_WORD *)(a1 + 2)) {
    return 0LL;
  }
  unint64_t v2 = 0LL;
  uint64_t v3 = *(void *)(a1 + 8);
  int v4 = -1;
  while (1)
  {
    if (*(_BYTE *)v3 != 1)
    {
      sub_1001EE2A0();
      if (*(_BYTE *)v3 != 1) {
        break;
      }
    }

    unsigned int v5 = (unsigned __int16)*(_DWORD *)(v3 + 8);
    if (*(_WORD *)(v3 + 2) == 2) {
      int v6 = (unsigned __int16)*(_DWORD *)(v3 + 8);
    }
    else {
      int v6 = HIWORD(*(_DWORD *)(v3 + 8));
    }
    if (v6 < v4 || v5 < v6) {
      return 812LL;
    }
    ++v2;
    v3 += 16LL;
    int v4 = v5;
  }

  return 101LL;
}

uint64_t sub_1001E0050(uint64_t a1, unsigned __int8 *a2, unsigned __int8 *a3)
{
  if (!(_DWORD)xmmword_1008F6FD8) {
    return 810LL;
  }
  int v3 = *(_DWORD *)qword_1008EDC60;
  if (!*(_DWORD *)qword_1008EDC60 || v3 == 3) {
    return 810LL;
  }
  if (v3 == 2) {
    return 817LL;
  }
  int v9 = sub_10010AE3C(a2);
  if (!v9) {
    return 106LL;
  }
  __int16 v10 = v9;
  uint64_t result = sub_1001DFFAC((uint64_t)a3);
  if ((_DWORD)result) {
    return result;
  }
  int v11 = sub_10010AE3C(a3);
  if (!v11) {
    return 106LL;
  }
  unsigned int v12 = *(_BYTE **)(qword_1008EDC60 + 24);
  if (!v12)
  {
    unsigned __int16 v16 = "SDP_State->ReqBuffer";
    goto LABEL_32;
  }

  if (!(v10 + 24 + (_WORD)v11))
  {
    unsigned __int16 v16 = "(bufLen) > 0";
LABEL_32:
    sub_1000E6B88("/Library/Caches/com.apple.xbs/Sources/MobileBluetooth_base/Stack/corestack/sdp/sdp.c", 1570, v16);
  }

  uint64_t v19 = *(void *)(qword_1008EDC60 + 24);
  unsigned __int16 v20 = v10 + 24 + v11;
  __int16 v23 = 2;
  unsigned __int16 v21 = v20;
  *unsigned int v12 = 6;
  if ((unint64_t)(unsigned __int16)(v10 + 24 + v11) - 5 >= 0xFFFFFFFFFFFFFFFCLL) {
    sub_1000E6B88( "/Library/Caches/com.apple.xbs/Sources/MobileBluetooth_base/Stack/corestack/sdp/sdp.c",  1579,  "ByteStream_NumReadBytesAvail(request) >= (2 * sizeof(uint16_t))");
  }
  unsigned __int16 v22 = 5;
  sub_10010B0BC((uint64_t)&v19, a2);
  if (HIBYTE(v23))
  {
    sub_1001ED1C4((uint64_t)"/Library/Caches/com.apple.xbs/Sources/MobileBluetooth_base/Stack/corestack/sdp/sdp.c");
    goto LABEL_35;
  }

  if (v21 - v22 <= 1)
  {
LABEL_35:
    unsigned __int16 v17 = "ByteStream_NumReadBytesAvail(request) >= 2";
    goto LABEL_37;
  }

  if (v23 != 2)
  {
    unsigned __int16 v17 = "(request).__RWFlag == BYTESTREAM_WRITE";
LABEL_37:
    sub_1000E6B88("/Library/Caches/com.apple.xbs/Sources/MobileBluetooth_base/Stack/corestack/sdp/sdp.c", 1584, v17);
  }

  *(_BYTE *)(v19 + v22 + 1) = *(_BYTE *)(qword_1008EDC60 + 14);
  *(_BYTE *)(v19 + vmemset(v6, 0, 22) = *(_BYTE *)(qword_1008EDC60 + 15);
  v22 += 2;
  sub_10010B0BC((uint64_t)&v19, a3);
  uint64_t v13 = v22;
  *(_WORD *)(qword_1008EDC60 + 16) = v22;
  if (HIBYTE(v23))
  {
    sub_1001ED1C4((uint64_t)"/Library/Caches/com.apple.xbs/Sources/MobileBluetooth_base/Stack/corestack/sdp/sdp.c");
    goto LABEL_39;
  }

  if (v21 <= v13)
  {
LABEL_39:
    uint64_t v18 = "ByteStream_NumReadBytesAvail(request) >= 1";
    goto LABEL_41;
  }

  if (v23 != 2)
  {
    uint64_t v18 = "(request).__RWFlag == BYTESTREAM_WRITE";
LABEL_41:
    sub_1000E6B88("/Library/Caches/com.apple.xbs/Sources/MobileBluetooth_base/Stack/corestack/sdp/sdp.c", 1594, v18);
  }

  unsigned __int16 v22 = v13 + 1;
  *(_BYTE *)(v19 + v13) = 0;
  if (v23 == 2)
  {
    unsigned __int16 v14 = v22;
    unsigned __int16 v21 = v22;
  }

  else
  {
    unsigned __int16 v14 = v21;
  }

  LOBYTE(v23) = 15;
  uint64_t v15 = qword_1008EDC60;
  *(_WORD *)(qword_1008EDC60 + 18) = v14;
  *(void *)(v15 + 80) = a1;
  *(_BYTE *)(v15 + 32) = 7;
  return sub_1001DFCA8();
}

uint64_t sub_1001E0318()
{
  if (!(_DWORD)xmmword_1008F6FD8) {
    return 810LL;
  }
  int v0 = *(_DWORD *)qword_1008EDC60;
  uint64_t result = 810LL;
  if (*(_DWORD *)qword_1008EDC60)
  {
    if (v0 == 2)
    {
    }

    else if (v0 == 3)
    {
      return result;
    }

    return 815LL;
  }

  return result;
}

uint64_t sub_1001E0374(void *a1)
{
  if (off_1008EDC68)
  {
    if (off_1008EDC68 == a1) {
      return 0LL;
    }
    else {
      return 119LL;
    }
  }

  else
  {
    uint64_t result = 0LL;
    off_1008EDC68 = a1;
  }

  return result;
}

void *sub_1001E03A0(void *result)
{
  if (off_1008EDC68 == result) {
    off_1008EDC68 = 0LL;
  }
  return result;
}

uint64_t sub_1001E03BC(uint64_t *a1)
{
  if (*((_BYTE *)a1 + 14) != 1) {
    sub_1000E6B88( "/Library/Caches/com.apple.xbs/Sources/MobileBluetooth_base/Stack/corestack/sdp/sdp.c",  1023,  "(*Response).__RWFlag == BYTESTREAM_READ");
  }
  if (*((_BYTE *)a1 + 15))
  {
    sub_1001ED1C4((uint64_t)"/Library/Caches/com.apple.xbs/Sources/MobileBluetooth_base/Stack/corestack/sdp/sdp.c");
    int v2 = *((unsigned __int8 *)a1 + 14);
    *((_BYTE *)a1 + 15) = 1;
    if (v2 != 1) {
      sub_1000E6B88( "/Library/Caches/com.apple.xbs/Sources/MobileBluetooth_base/Stack/corestack/sdp/sdp.c",  1024,  "(*Response).__RWFlag == BYTESTREAM_READ");
    }
    goto LABEL_10;
  }

  uint64_t v3 = *((unsigned __int16 *)a1 + 6);
  if (*((unsigned __int16 *)a1 + 5) - (int)v3 <= 1)
  {
    *((_BYTE *)a1 + 15) = 1;
LABEL_10:
    sub_1001ED1C4((uint64_t)"/Library/Caches/com.apple.xbs/Sources/MobileBluetooth_base/Stack/corestack/sdp/sdp.c");
    goto LABEL_11;
  }

  unsigned int v4 = *(unsigned __int16 *)(*a1 + v3);
  *((_WORD *)a1 + 6) = v3 + 2;
  int v5 = *((unsigned __int16 *)a1 + 5);
  if (v5 - (unsigned __int16)(v3 + 2) <= 1)
  {
LABEL_11:
    *((_BYTE *)a1 + 15) = 1;
    return 829LL;
  }

  unsigned int v6 = __rev16(v4);
  uint64_t v7 = *a1;
  unsigned int v8 = __rev16(*(unsigned __int16 *)(*a1 + (unsigned __int16)(v3 + 2)));
  unsigned __int16 v9 = v3 + 4;
  *((_WORD *)a1 + 6) = v3 + 4;
  if (v8 > v6) {
    return 833LL;
  }
  uint64_t v11 = qword_1008EDC60;
  if (!v8)
  {
    unsigned __int16 v18 = *(_WORD *)(qword_1008EDC60 + 50);
    int v12 = *(unsigned __int16 *)(qword_1008EDC60 + 48);
LABEL_20:
    if (v12 == v18 || v6 == v18)
    {
      *(_DWORD *)uint64_t v11 = 1;
    }

    else
    {
      uint64_t result = sub_1001E0E08(a1);
      if ((_DWORD)result) {
        return result;
      }
      uint64_t v11 = qword_1008EDC60;
      if (*(_DWORD *)qword_1008EDC60 == 2) {
        return sub_1001DFCA8();
      }
    }

    (*(void (**)(void, void, void))(v11 + 80))( *(void *)(v11 + 40),  *(unsigned __int16 *)(v11 + 50),  0LL);
    sub_1000B1838(*(void **)(qword_1008EDC60 + 40));
    uint64_t result = 0LL;
    *(void *)(qword_1008EDC60 + 40) = 0LL;
    return result;
  }

  int v12 = *(unsigned __int16 *)(qword_1008EDC60 + 48);
  unsigned __int16 v13 = *(_WORD *)(qword_1008EDC60 + 50);
  int v14 = v5 - 3;
  while (v12 != v13)
  {
    if (v14 <= v9) {
      goto LABEL_11;
    }
    uint64_t v15 = v9;
    v9 += 4;
    LODWORD(v15) = *(_DWORD *)(v7 + v15);
    *((_WORD *)a1 + 6) = v9;
    unsigned int v16 = bswap32(v15);
    uint64_t v17 = *(void *)(v11 + 40);
    unsigned __int16 v18 = v13 + 1;
    *(_WORD *)(v11 + 50) = v13 + 1;
    *(_DWORD *)(v17 + 4LL * v13++) = v16;
    if (!--v8) {
      goto LABEL_20;
    }
  }

  return 837LL;
}

uint64_t sub_1001E05B4(uint64_t a1)
{
  uint64_t v56 = 0LL;
  unsigned __int16 v54 = 0;
  uint64_t v55 = 6LL;
  if (*(_BYTE *)(a1 + 14) != 1) {
    sub_1000E6B88( "/Library/Caches/com.apple.xbs/Sources/MobileBluetooth_base/Stack/corestack/sdp/sdp.c",  753,  "(*Response).__RWFlag == BYTESTREAM_READ");
  }
  __int16 v53 = 0;
  if (*(_BYTE *)(a1 + 15))
  {
    sub_1001ED1C4((uint64_t)"/Library/Caches/com.apple.xbs/Sources/MobileBluetooth_base/Stack/corestack/sdp/sdp.c");
LABEL_7:
    unsigned int v6 = 0LL;
    *(_BYTE *)(a1 + 15) = 1;
    goto LABEL_8;
  }

  unsigned int v2 = *(unsigned __int16 *)(a1 + 10);
  uint64_t v3 = *(unsigned __int16 *)(a1 + 12);
  unsigned int v4 = *(unsigned __int16 *)(*(void *)a1 + v3);
  unsigned __int16 v5 = v3 + 2;
  *(_WORD *)(a1 + 12) = v3 + 2;
  if ((int)(v2 - (unsigned __int16)(v3 + 2)) >= (int)(bswap32(v4) >> 16))
  {
    size_t v11 = __rev16(v4);
    if (v11 > *(unsigned __int16 *)(qword_1008EDC60 + 14))
    {
      unsigned int v6 = 0LL;
      uint64_t v7 = 836LL;
      goto LABEL_9;
    }

    unsigned int v12 = (unsigned __int16)(v3 + 2) + (_DWORD)v11;
    if (v12 > v2) {
      sub_1000E6B88( "/Library/Caches/com.apple.xbs/Sources/MobileBluetooth_base/Stack/corestack/sdp/sdp.c",  772,  "(size_t)(startPos + attrBytes) <= (size_t)((*Response).__size)");
    }
    *(_WORD *)(a1 + 12) = v12;
    uint64_t v13 = sub_1001E0E08((uint64_t *)a1);
    if ((_DWORD)v13)
    {
      uint64_t v7 = v13;
LABEL_19:
      unsigned int v6 = 0LL;
      goto LABEL_9;
    }

    if (*(unsigned __int16 *)(a1 + 10) < v5) {
      sub_1000E6B88( "/Library/Caches/com.apple.xbs/Sources/MobileBluetooth_base/Stack/corestack/sdp/sdp.c",  777,  "(size_t)(startPos) <= (size_t)((*Response).__size)");
    }
    *(_WORD *)(a1 + 12) = v5;
    if (v12 > *(unsigned __int16 *)(a1 + 8)) {
      sub_1000E6B88( "/Library/Caches/com.apple.xbs/Sources/MobileBluetooth_base/Stack/corestack/sdp/sdp.c",  781,  "((startPos + attrBytes) <= (*Response).__trueSize) && ((startPos + attrBytes) >= (*Response).__pos)");
    }
    *(_WORD *)(a1 + 10) = v12;
    uint64_t v14 = qword_1008EDC60;
    if (*(void *)(qword_1008EDC60 + 56))
    {
      size_t v15 = *(unsigned __int16 *)(qword_1008EDC60 + 64) + v11;
      if (v15 >= 0x2801)
      {
        if (sub_1000A86F0())
        {
          sub_1001EE134( (uint64_t)"Accumulated attribute reponse data length exceed the limits",  v16,  v17,  v18,  v19,  v20,  v21,  v22,  v50);
          __int16 v23 = (os_log_s *)sub_100086554(0x34u);
          if (os_log_type_enabled(v23, OS_LOG_TYPE_ERROR)) {
            sub_10065BB00();
          }
        }

        unsigned int v6 = 0LL;
        goto LABEL_79;
      }

      unsigned __int16 v24 = (char *)sub_1000B17F4(v15);
      unsigned int v6 = v24;
      if (!v24) {
        goto LABEL_79;
      }
      memmove(v24, *(const void **)(qword_1008EDC60 + 56), *(unsigned __int16 *)(qword_1008EDC60 + 64));
      if (*(_BYTE *)(a1 + 14) == 1)
      {
        uint64_t v25 = *(unsigned __int16 *)(qword_1008EDC60 + 64);
        uint64_t v26 = *(void *)a1;
        uint64_t v27 = *(unsigned __int16 *)(a1 + 12);
        if (*(_BYTE *)(a1 + 15))
        {
          sub_1001ED1C4((uint64_t)"/Library/Caches/com.apple.xbs/Sources/MobileBluetooth_base/Stack/corestack/sdp/sdp.c");
          int v28 = 0;
        }

        else
        {
          int v28 = *(unsigned __int16 *)(a1 + 10) - (_DWORD)v27;
        }

        if (v28 >= (int)v11)
        {
          memmove(&v6[v25], (const void *)(v26 + v27), v11);
          *(_WORD *)(a1 + 12) += v11;
          sub_1000B1838(*(void **)(qword_1008EDC60 + 56));
          uint64_t v14 = qword_1008EDC60;
          *(void *)(qword_1008EDC60 + 56) = 0LL;
          if (!(_DWORD)v15) {
            sub_1000E6B88( "/Library/Caches/com.apple.xbs/Sources/MobileBluetooth_base/Stack/corestack/sdp/sdp.c",  807,  "(catenatedLen) > 0");
          }
          unsigned __int16 v5 = 0;
          *(void *)a1 = v6;
          *(_WORD *)(a1 + 8) = v15;
          *(_DWORD *)(a1 + 12) = 0x10000;
          *(_WORD *)(a1 + 10) = v15;
          goto LABEL_37;
        }

        uint64_t v48 = "ByteStream_NumReadBytesAvail(*Response) >= (attrBytes)";
      }

      else
      {
        uint64_t v48 = "(*Response).__RWFlag == BYTESTREAM_READ";
      }

      sub_1000E6B88("/Library/Caches/com.apple.xbs/Sources/MobileBluetooth_base/Stack/corestack/sdp/sdp.c", 801, v48);
    }

    unsigned int v6 = 0LL;
LABEL_37:
    unsigned int v29 = *(unsigned __int16 *)(v14 + 66);
    if (!*(_WORD *)(v14 + 66))
    {
      uint64_t v30 = sub_10010B44C(a1, &v53, (_WORD *)(v14 + 66));
      if ((_DWORD)v30)
      {
        uint64_t v7 = v30;
        if ((_DWORD)v30 != 843) {
          goto LABEL_9;
        }
        if (*(unsigned __int16 *)(a1 + 10) < v5) {
          sub_1000E6B88( "/Library/Caches/com.apple.xbs/Sources/MobileBluetooth_base/Stack/corestack/sdp/sdp.c",  822,  "(size_t)(startPos) <= (size_t)((*Response).__size)");
        }
        *(_WORD *)(a1 + 12) = v5;
        uint64_t v7 = 843LL;
        unsigned __int16 v31 = v11;
LABEL_82:
        if (*(_DWORD *)qword_1008EDC60 == 2)
        {
          if (v31)
          {
            uint64_t v42 = sub_1000B17F4(v31);
            *(void *)(qword_1008EDC60 + 56) = v42;
            if (!v42)
            {
              uint64_t v7 = 106LL;
              goto LABEL_9;
            }

            if (*(_BYTE *)(a1 + 14) == 1)
            {
              uint64_t v43 = v42;
              uint64_t v44 = *(void *)a1;
              uint64_t v45 = *(unsigned __int16 *)(a1 + 12);
              if (*(_BYTE *)(a1 + 15))
              {
                sub_1001ED1C4((uint64_t)"/Library/Caches/com.apple.xbs/Sources/MobileBluetooth_base/Stack/corestack/sdp/sdp.c");
                int v46 = 0;
              }

              else
              {
                int v46 = *(unsigned __int16 *)(a1 + 10) - (_DWORD)v45;
              }

              if (v46 >= v31)
              {
                memmove(v43, (const void *)(v44 + v45), v31);
                *(_WORD *)(a1 + 12) += v31;
                *(_WORD *)(qword_1008EDC60 + 64) = v31;
                goto LABEL_94;
              }

              uint64_t v49 = "ByteStream_NumReadBytesAvail(*Response) >= (attrBytes)";
            }

            else
            {
              uint64_t v49 = "(*Response).__RWFlag == BYTESTREAM_READ";
            }

            sub_1000E6B88( "/Library/Caches/com.apple.xbs/Sources/MobileBluetooth_base/Stack/corestack/sdp/sdp.c",  951,  v49);
          }
        }

        else if (v31)
        {
          goto LABEL_39;
        }

void sub_1001E0D38(uint64_t a1)
{
  if (sub_1000A86F0())
  {
    sub_1001EE134((uint64_t)"SDP CleanupAndReportError %!", v2, v3, v4, v5, v6, v7, v8, a1);
    unsigned __int16 v9 = (os_log_s *)sub_100086554(0x34u);
    if (os_log_type_enabled(v9, OS_LOG_TYPE_ERROR)) {
      sub_10065B898();
    }
  }

  int v10 = *(unsigned __int8 *)(qword_1008EDC60 + 32);
  if (v10 == 7 || v10 == 5 || v10 == 3) {
    (*(void (**)(void, void, uint64_t))(qword_1008EDC60 + 80))(0LL, 0LL, a1);
  }
  else {
    sub_1001EE2A0();
  }
  uint64_t v11 = qword_1008EDC60;
  *(_DWORD *)qword_1008EDC60 = 1;
  *(_WORD *)(v11 + 66) = 0;
  unsigned int v12 = *(void **)(v11 + 56);
  if (v12)
  {
    sub_1000B1838(v12);
    *(void *)(qword_1008EDC60 + 56) = 0LL;
  }

uint64_t sub_1001E0E08(uint64_t *a1)
{
  if (*((_BYTE *)a1 + 14) != 1) {
    sub_1000E6B88( "/Library/Caches/com.apple.xbs/Sources/MobileBluetooth_base/Stack/corestack/sdp/sdp.c",  643,  "(*Response).__RWFlag == BYTESTREAM_READ");
  }
  if (*((_BYTE *)a1 + 15))
  {
    sub_1001ED1C4((uint64_t)"/Library/Caches/com.apple.xbs/Sources/MobileBluetooth_base/Stack/corestack/sdp/sdp.c");
LABEL_8:
    int v6 = 1;
    *((_BYTE *)a1 + 15) = 1;
LABEL_9:
    *(_DWORD *)qword_1008EDC60 = 1;
    goto LABEL_10;
  }

  uint64_t v2 = *((unsigned __int16 *)a1 + 6);
  uint64_t v3 = *a1;
  *((_WORD *)a1 + 6) = v2 + 1;
  uint64_t v4 = *(unsigned __int8 *)(v3 + v2);
  if (!*(_BYTE *)(v3 + v2))
  {
    int v6 = 0;
    goto LABEL_9;
  }

  uint64_t v7 = qword_1008EDC60;
  *(_BYTE *)(*(void *)(qword_1008EDC60 + 24) + *(unsigned __int16 *)(qword_1008EDC60 + 16)) = v4;
  if (*((_BYTE *)a1 + 14) != 1) {
    sub_1000E6B88( "/Library/Caches/com.apple.xbs/Sources/MobileBluetooth_base/Stack/corestack/sdp/sdp.c",  657,  "(*Response).__RWFlag == BYTESTREAM_READ");
  }
  uint64_t v8 = *(void *)(v7 + 24);
  uint64_t v9 = *(unsigned __int16 *)(v7 + 16);
  uint64_t v10 = *a1;
  uint64_t v11 = *((unsigned __int16 *)a1 + 6);
  if (*((_BYTE *)a1 + 15))
  {
    sub_1001ED1C4((uint64_t)"/Library/Caches/com.apple.xbs/Sources/MobileBluetooth_base/Stack/corestack/sdp/sdp.c");
    int v12 = 0;
  }

  else
  {
    int v12 = *((unsigned __int16 *)a1 + 5) - (_DWORD)v11;
  }

  if (v12 >= (int)v4)
  {
    uint64_t v13 = (_BYTE *)(v9 + v8 + 1);
    uint64_t v14 = (char *)(v10 + v11);
    size_t v15 = &v13[v4];
    do
    {
      char v16 = *v14++;
      *v13++ = v16;
    }

    while (v13 < v15);
    *((_WORD *)a1 + 6) += v4;
    int v6 = *((unsigned __int8 *)a1 + 15);
  }

  else
  {
    int v6 = 1;
    *((_BYTE *)a1 + 15) = 1;
  }

  *(_WORD *)(qword_1008EDC60 + 18) = v4 + *(_WORD *)(qword_1008EDC60 + 16) + 1;
LABEL_10:
  if (v6) {
    return 829LL;
  }
  else {
    return 0LL;
  }
}

uint64_t sub_1001E0FB8(uint64_t a1, int a2, _WORD *a3)
{
  if (!a2) {
    return 0LL;
  }
  int v4 = a2;
  while (1)
  {
    char v24 = 0;
    unsigned __int16 v23 = 0;
    uint64_t result = sub_10010B118(a1, &v24, (__int16 *)&v23);
    if ((_DWORD)result) {
      break;
    }
    if (v23 != 3 || v24 != 1)
    {
      if (sub_1000A86F0())
      {
        sub_1001EE134((uint64_t)"Bad attribute response - expected attribute id", v14, v15, v16, v17, v18, v19, v20, v22);
        uint64_t v21 = (os_log_s *)sub_100086554(0x34u);
        if (os_log_type_enabled(v21, OS_LOG_TYPE_ERROR)) {
          sub_10065CA58();
        }
      }

      return 833LL;
    }

    if (*(_BYTE *)(a1 + 15))
    {
      sub_1001ED1C4((uint64_t)"/Library/Caches/com.apple.xbs/Sources/MobileBluetooth_base/Stack/corestack/sdp/sdp.c");
      int v8 = 0;
      int v9 = v23;
    }

    else
    {
      int v8 = *(unsigned __int16 *)(a1 + 10) - *(unsigned __int16 *)(a1 + 12);
      int v9 = 3;
    }

    if (v8 < v9) {
      sub_1000E6B88( "/Library/Caches/com.apple.xbs/Sources/MobileBluetooth_base/Stack/corestack/sdp/sdp.c",  702,  "ByteStream_NumReadBytesAvail(*Response) >= (elemSize)");
    }
    *(_WORD *)(a1 + 12) += v9;
    uint64_t result = sub_10010B118(a1, &v24, (__int16 *)&v23);
    if ((_DWORD)result) {
      return result;
    }
    int v10 = v4 - 3;
    int v11 = v23;
    if (*(_BYTE *)(a1 + 15))
    {
      sub_1001ED1C4((uint64_t)"/Library/Caches/com.apple.xbs/Sources/MobileBluetooth_base/Stack/corestack/sdp/sdp.c");
      int v12 = 0;
      int v11 = v23;
    }

    else
    {
      int v12 = *(unsigned __int16 *)(a1 + 10) - *(unsigned __int16 *)(a1 + 12);
    }

    if (v12 < v11) {
      sub_1000E6B88( "/Library/Caches/com.apple.xbs/Sources/MobileBluetooth_base/Stack/corestack/sdp/sdp.c",  712,  "ByteStream_NumReadBytesAvail(*Response) >= (elemSize)");
    }
    *(_WORD *)(a1 + 12) += v11;
    if (a3) {
      *a3 += 2;
    }
    int v4 = v10 - v11;
    if (!(_WORD)v4) {
      return 0LL;
    }
  }

  return result;
}

void sub_1001E1190(uint64_t a1, uint64_t a2)
{
  if (*(void *)(qword_1008EDC60 + 24) != a2) {
    sub_1001EE2A0();
  }
}

void sub_1001E11AC()
{
  if ((_DWORD)xmmword_1008F6FD8)
  {
    uint64_t v0 = qword_1008EDC60;
    if (*(_DWORD *)qword_1008EDC60 == 2)
    {
      sub_1001E0D38(832LL);
      uint64_t v0 = qword_1008EDC60;
    }

    *(_DWORD *)(v0 + 8) = 0;
  }

uint64_t sub_1001E11F8()
{
  if (DWORD1(xmmword_1008F6FD8)) {
    return 140LL;
  }
  qword_1008EDC70 = (uint64_t)sub_1000B1814(0x80uLL);
  if (!qword_1008EDC70) {
    return 106LL;
  }
  __int16 v1 = (unsigned __int8 *)sub_1001EDBA0(0x28u);
  qword_1008EDC90 = (uint64_t)sub_1000B1814(32LL * *v1);
  word_1008EDC88 = 0;
  byte_1008EDC98 = 0;
  uint64_t v2 = sub_1000B1814(0x50uLL);
  if (!v2) {
    return 106LL;
  }
  uint64_t v3 = v2;
  byte_1008EDC78 = 1;
  word_1008EDC7A = 4;
  dword_1008EDC80 = 0;
  byte_1008EDCA0 = 4;
  int v4 = sub_1001F5FA0();
  word_1008EDCA2 = strlen(v4);
  qword_1008EDCA8 = (uint64_t)sub_1001F5FA0();
  byte_1008EDCB0 = 4;
  uint64_t v5 = sub_1001F5FAC();
  word_1008EDCB2 = strlen(v5);
  qword_1008EDCB8 = (uint64_t)sub_1001F5FAC();
  v3[12] = 6;
  *((void *)v3 + 2) = &unk_100886248;
  *((_BYTE *)v3 + 66) = -1;
  *((void *)v3 + memset((char *)&v11[1] + 1, 0, 7) = 0LL;
  v3[32] = 0;
  *((_DWORD *)v3 + 13) = 0;
  *((void *)v3 + 9) = &unk_1006BDFD0;
  int v6 = (_WORD *)qword_1008EDC70;
  *(void *)(qword_1008EDC70 + 120) = v3;
  *int v6 = 0;
  v6[12] = 2;
  char v6[24] = 8;
  v6[36] = 6;
  v6[48] = 5;
  uint64_t v7 = (char *)sub_1000B1814(0x50uLL);
  if (!v7) {
    return 106LL;
  }
  int v8 = v7;
  uint64_t result = 0LL;
  *((_DWORD *)v8 + 12) = 1330184192;
  *((void *)v8 + 2) = &unk_1008862F8;
  *((_WORD *)v8 + 12) = 1;
  *((void *)v8 + 4) = 0LL;
  *((_WORD *)v8 + 20) = 0;
  *(void *)(v8 + 52) = 0LL;
  *(void *)(v8 + 59) = 0LL;
  *((void *)v8 + 9) = &unk_1006BDFD0;
  uint64_t v9 = qword_1008EDC70;
  *(void *)int v8 = *(void *)(qword_1008EDC70 + 120);
  *(void *)(v9 + 120) = v8;
  byte_1008EDC9C = 1;
  DWORD2(xmmword_1008F6FD8) = 1;
  return result;
}

uint64_t sub_1001E139C(uint64_t a1, int *a2)
{
  int v4 = sub_1000B1814(0x50uLL);
  if (!v4) {
    return 104LL;
  }
  uint64_t v5 = v4;
  void v4[2] = *(void *)a1;
  *((_WORD *)v4 + 12) = *(_WORD *)(a1 + 8);
  v4[4] = *(void *)(a1 + 16);
  *((_WORD *)v4 + 20) = *(_WORD *)(a1 + 24);
  v4[7] = 0LL;
  *((_WORD *)v4 + 32) = 0;
  *((_BYTE *)v4 + 66) = -1;
  *((_DWORD *)v4 + 13) = 0;
  v4[9] = &unk_100886238;
  uint64_t v6 = *(unsigned __int16 *)(a1 + 8);
  if (!*(_WORD *)(a1 + 8)) {
    goto LABEL_14;
  }
  uint64_t v7 = *(void *)a1 + 16LL;
  while (*(_WORD *)(v7 - 16) != 1)
  {
    v7 += 24LL;
    if (!--v6) {
      goto LABEL_14;
    }
  }

  if (*(_BYTE *)(v7 - 8) == 6)
  {
    int v9 = *(unsigned __int16 *)(*(void *)v7 + 8LL) | 0x4F490000;
    int v10 = (void *)(qword_1008EDC70 + 120);
LABEL_10:
    *((_DWORD *)v4 + 12) = v9;
    int v11 = v10;
    while (1)
    {
      int v11 = (void *)*v11;
      if (!v11) {
        break;
      }
      if (*((_DWORD *)v11 + 12) == v9)
      {
        v9 += 0x10000;
        goto LABEL_10;
      }
    }

    if (a2) {
      *a2 = v9;
    }
    uint64_t result = 0LL;
    *uint64_t v5 = *v10;
    *int v10 = v5;
    byte_1008EDC78 = 1;
    word_1008EDC7A = 4;
    ++dword_1008EDC80;
  }

  else
  {
LABEL_14:
    if (sub_1000A86F0())
    {
      sub_1001EE134( (uint64_t)"ServiceClassIDList is mandatory in an SDP service record",  v12,  v13,  v14,  v15,  v16,  v17,  v18,  v20);
      uint64_t v19 = (os_log_s *)sub_100086554(0x36u);
      if (os_log_type_enabled(v19, OS_LOG_TYPE_ERROR)) {
        sub_100657858();
      }
    }

    sub_1000B1838(v5);
    return 826LL;
  }

  return result;
}

uint64_t sub_1001E1520(int a1)
{
  if (!a1) {
    return 101LL;
  }
  __int16 v1 = 0LL;
  uint64_t v2 = (void **)(qword_1008EDC70 + 120);
  do
  {
    uint64_t v3 = v1;
    __int16 v1 = *v2;
    if (!*v2) {
      return 802LL;
    }
    uint64_t v2 = (void **)*v2;
  }

  while (v1[12] != a1);
  if (*((_WORD *)v1 + 32))
  {
    if (sub_1000A86F0())
    {
      sub_1001EE134( (uint64_t)"Potential memory leak - Attribute list has not been removed",  v4,  v5,  v6,  v7,  v8,  v9,  v10,  v16);
      int v11 = (os_log_s *)sub_100086554(0x36u);
      if (os_log_type_enabled(v11, OS_LOG_TYPE_ERROR)) {
        sub_100657858();
      }
    }
  }

  uint64_t v12 = (void *)*((void *)v1 + 1);
  if (v12)
  {
    do
    {
      uint64_t v13 = (void *)*v12;
      sub_1000B1838(v12);
      uint64_t v12 = v13;
    }

    while (v13);
  }

  uint64_t v14 = (void *)(qword_1008EDC70 + 120);
  if (v3) {
    uint64_t v14 = v3;
  }
  *uint64_t v14 = *(void *)v1;
  sub_1000B1838(v1);
  uint64_t result = 0LL;
  byte_1008EDC78 = 1;
  word_1008EDC7A = 4;
  ++dword_1008EDC80;
  return result;
}

uint64_t sub_1001E1628()
{
  return dword_1008EDC80;
}

uint64_t sub_1001E1634(uint64_t a1, uint64_t a2)
{
  if (sub_1000A86F0())
  {
    sub_1001EE134((uint64_t)"Adding SDP Legacy record for service record handle %d", v4, v5, v6, v7, v8, v9, v10, a1);
    int v11 = (os_log_s *)sub_100086554(0x36u);
    if (os_log_type_enabled(v11, OS_LOG_TYPE_DEFAULT))
    {
      *(_DWORD *)__int128 buf = 136446210;
      uint64_t v16 = sub_1001EDDCC();
      _os_log_impl((void *)&_mh_execute_header, v11, OS_LOG_TYPE_DEFAULT, " %{public}s", buf, 0xCu);
    }
  }

  uint64_t v12 = qword_1008EDC70 + 120;
  while (1)
  {
    uint64_t v12 = *(void *)v12;
    if (!v12) {
      break;
    }
    if (*(_DWORD *)(v12 + 48) == (_DWORD)a1) {
      goto LABEL_9;
    }
  }

  sub_1001EE2A0();
LABEL_9:
  uint64_t v13 = sub_1000B1814(0x50uLL);
  uint64_t v13[2] = *(void *)a2;
  *((_WORD *)v13 + 12) = *(_WORD *)(a2 + 8);
  v13[4] = *(void *)(a2 + 16);
  *((_WORD *)v13 + 20) = *(_WORD *)(a2 + 24);
  v13[7] = 0LL;
  *((_WORD *)v13 + 32) = 0;
  *((_BYTE *)v13 + 66) = -1;
  v13[9] = &unk_100886238;
  *((_DWORD *)v13 + 12) = a1;
  *((_DWORD *)v13 + 13) = 0;
  void *v13 = *(void *)(v12 + 8);
  *(void *)(v12 + 8) = v13;
  return 0LL;
}

uint64_t sub_1001E1780(uint64_t a1, unsigned int a2, _WORD *a3, _DWORD *a4, uint64_t a5)
{
  uint64_t v5 = *(uint64_t **)(qword_1008EDC70 + 120);
  if (v5)
  {
    int v8 = 0;
    uint64_t v9 = a2;
    do
    {
      int v45 = v8 + 1;
      if ((unsigned __int16)*a3 <= (unsigned __int16)v8)
      {
        uint64_t v10 = qword_1008EDC70;
        *(_BYTE *)(qword_1008EDC70 + 8) = 1;
        *(_WORD *)(v10 + 10) = 4;
        *(_DWORD *)(v10 + 16) = *((_DWORD *)v5 + 12);
        *(_BYTE *)(v10 + 32) = 1;
        *(_WORD *)(v10 + 34) = 4;
        *(_DWORD *)(v10 + 40) = *((_DWORD *)v5 + 13);
        *(_BYTE *)(v10 + 56) = 1;
        *(_WORD *)(v10 + 58) = 1;
        *(_DWORD *)(v10 + 64) = *((unsigned __int8 *)v5 + 66);
        *(_OWORD *)(v10 + 80) = unk_1008D73F0;
        *(_OWORD *)(v10 + 104) = *(_OWORD *)v5[9];
        if (a2)
        {
          uint64_t v11 = 0LL;
          if (*(_WORD *)(v10 + 106)) {
            unint64_t v12 = 5LL;
          }
          else {
            unint64_t v12 = 4LL;
          }
          while (1)
          {
            if (*((_WORD *)v5 + 12))
            {
              unint64_t v13 = 1LL;
              uint64_t v14 = 8LL;
              do
              {
                int v15 = sub_1001E1ABC((unsigned __int8 *)(v5[2] + v14), a1 + 16 * v11);
                v14 += 24LL;
                ++v13;
              }

              while ((v15 & 1) == 0);
            }

            else
            {
              int v15 = 0;
            }

            if (*((_WORD *)v5 + 32)) {
              BOOL v16 = v15 == 0;
            }
            else {
              BOOL v16 = 0;
            }
            if (v16)
            {
              unint64_t v17 = 1LL;
              uint64_t v18 = 8LL;
              do
              {
                int v15 = sub_1001E1ABC((unsigned __int8 *)(v5[7] + v18), a1 + 16 * v11);
                v18 += 24LL;
                ++v17;
              }

              while ((v15 & 1) == 0);
            }

            if (!v15)
            {
              unint64_t v19 = 1LL;
              uint64_t v20 = 8LL;
              do
              {
                int v21 = sub_1001E1ABC((unsigned __int8 *)(qword_1008EDC70 + v20), a1 + 16 * v11);
                if (v19 >= v12) {
                  break;
                }
                v20 += 24LL;
                ++v19;
              }

              while (!v21);
              if ((v21 & 1) == 0) {
                break;
              }
            }

            if (++v11 == v9)
            {
              uint64_t v23 = (unsigned __int16)word_1008EDC88;
              if (!word_1008EDC88) {
                goto LABEL_49;
              }
              uint64_t v24 = qword_1008EDC90;
              while (*(void *)v24 != a5)
              {
                v24 += 32LL;
                if (!--v23) {
                  goto LABEL_49;
                }
              }

              if (!*(_BYTE *)(v24 + 28)) {
                goto LABEL_49;
              }
              uint64_t v25 = *((unsigned __int16 *)v5 + 12);
              if (!*((_WORD *)v5 + 12)) {
                goto LABEL_49;
              }
              uint64_t v26 = 0LL;
              LODWORD(v2memset((char *)&v11[1] + 1, 0, 7) = 0;
              int v28 = (void *)(v5[2] + 16);
              do
              {
                if (*((_WORD *)v28 - 8) == 1)
                {
                  LODWORD(v2memset((char *)&v11[1] + 1, 0, 7) = *((unsigned __int16 *)v28 - 3);
                  uint64_t v26 = *v28;
                }

                v28 += 3;
                --v25;
              }

              while (v25);
              if (!(_DWORD)v27)
              {
LABEL_49:
                uint64_t result = 0LL;
                *a4 = *((_DWORD *)v5 + 12);
                *a3 = v45;
                return result;
              }

              unsigned int v29 = (unsigned int *)(v26 + 8);
              uint64_t v27 = v27;
              while (1)
              {
                unsigned int v31 = *v29;
                v29 += 4;
                unint64_t v30 = v31;
                if (v31 == 4611 || (_DWORD)v30 == 4383) {
                  break;
                }
                if (!--v27) {
                  goto LABEL_49;
                }
              }

              if (sub_1000A86F0())
              {
                int v33 = sub_1001EBA4C(v30);
                sub_1001EE134( (uint64_t)"Wireless Splitter incoming connection ignore %s profile",  v34,  v35,  v36,  v37,  v38,  v39,  v40,  (uint64_t)v33);
                unsigned __int16 v41 = (os_log_s *)sub_100086554(0x36u);
                if (os_log_type_enabled(v41, OS_LOG_TYPE_DEFAULT))
                {
                  *(_DWORD *)__int128 buf = 136446210;
                  uint64_t v47 = sub_1001EDDCC();
                  _os_log_impl((void *)&_mh_execute_header, v41, OS_LOG_TYPE_DEFAULT, " %{public}s", buf, 0xCu);
                }
              }

              return 823LL;
            }
          }
        }
      }

      uint64_t v5 = (uint64_t *)*v5;
      int v8 = v45;
    }

    while (v5);
  }

  return 823LL;
}

uint64_t sub_1001E1ABC(unsigned __int8 *a1, uint64_t a2)
{
  int v4 = *a1;
  if ((v4 - 6) >= 2)
  {
    if (v4 == 3) {
      return sub_100109250((uint64_t)a1, a2);
    }
    return 0LL;
  }

  if (!*((_WORD *)a1 + 1)) {
    return 0LL;
  }
  unint64_t v5 = 0LL;
  uint64_t v6 = *((void *)a1 + 1);
  do
  {
    uint64_t result = sub_1001E1ABC(v6, a2);
    if ((_DWORD)result) {
      break;
    }
    ++v5;
    v6 += 16LL;
  }

  while (v5 < *((unsigned __int16 *)a1 + 1));
  return result;
}

void *sub_1001E1B50(uint64_t a1)
{
  uint64_t v1 = (unsigned __int16)word_1008EDC88;
  if (!word_1008EDC88) {
    return 0LL;
  }
  for (uint64_t result = (void *)qword_1008EDC90; *result != a1; result += 4)
  {
    if (!--v1) {
      return 0LL;
    }
  }

  return result;
}

void sub_1001E1B88(uint64_t a1)
{
  if (sub_1000A86F0())
  {
    sub_1001EE134((uint64_t)"%: disconnected with reason %!", v2, v3, v4, v5, v6, v7, v8, a1 + 48);
    uint64_t v9 = (os_log_s *)sub_100086554(0x36u);
    if (os_log_type_enabled(v9, OS_LOG_TYPE_DEFAULT))
    {
      *(_DWORD *)__int128 buf = 136446210;
      int v45 = sub_1001EDDCC();
      _os_log_impl((void *)&_mh_execute_header, v9, OS_LOG_TYPE_DEFAULT, " %{public}s", buf, 0xCu);
    }
  }

  if (!word_1008EDC88)
  {
LABEL_10:
    if (sub_1000A86F0())
    {
      sub_1001EE134((uint64_t)"Could not find remote SDP record for handle: %p", v14, v15, v16, v17, v18, v19, v20, a1);
      int v21 = (os_log_s *)sub_100086554(0x36u);
      if (os_log_type_enabled(v21, OS_LOG_TYPE_ERROR)) {
        sub_100657858();
      }
    }

    return;
  }

  if (*(void *)qword_1008EDC90 != a1)
  {
    unint64_t v10 = 0LL;
    uint64_t v11 = (uint64_t *)(qword_1008EDC90 + 32);
    while ((unsigned __int16)word_1008EDC88 - 1LL != v10)
    {
      uint64_t v12 = *v11;
      v11 += 4;
      ++v10;
      if (v12 == a1)
      {
        BOOL v13 = v10 < (unsigned __int16)word_1008EDC88;
        goto LABEL_14;
      }
    }

    goto LABEL_10;
  }

  unint64_t v10 = 0LL;
  BOOL v13 = 1;
LABEL_14:
  if (sub_1000A86F0())
  {
    sub_1001EE134( (uint64_t)"Deleting remote SDP record at entry %d",  v22,  v23,  v24,  v25,  v26,  v27,  v28,  (unsigned __int16)v10);
    unsigned int v29 = (os_log_s *)sub_100086554(0x36u);
    if (os_log_type_enabled(v29, OS_LOG_TYPE_DEFAULT))
    {
      unint64_t v30 = sub_1001EDDCC();
      *(_DWORD *)__int128 buf = 136446210;
      int v45 = v30;
      _os_log_impl((void *)&_mh_execute_header, v29, OS_LOG_TYPE_DEFAULT, " %{public}s", buf, 0xCu);
    }
  }

  uint64_t v31 = qword_1008EDC90 + 32 * v10;
  *(_WORD *)(v31 + 26) = 0;
  *(void *)(v31 + 8) = 0LL;
  *(void *)(v31 + 16) = 0LL;
  *(void *)uint64_t v31 = 0LL;
  unsigned __int16 v32 = --word_1008EDC88;
  if ((unsigned __int16)word_1008EDC88 > (unsigned __int16)v10)
  {
    int v33 = (_OWORD *)(v31 + 32);
    do
    {
      __int128 v34 = v33[1];
      *(v33 - 2) = *v33;
      *(v33 - 1) = v34;
      LODWORD(v10) = v10 + 1;
      v33 += 2;
    }

    while ((unsigned __int16)v10 < v32);
  }

  if (v13 && sub_1000A86F0())
  {
    sub_1001EE134((uint64_t)"Deleted Remote SDP Record for %:", v35, v36, v37, v38, v39, v40, v41, a1 + 48);
    uint64_t v42 = (os_log_s *)sub_100086554(0x36u);
    if (os_log_type_enabled(v42, OS_LOG_TYPE_DEFAULT))
    {
      uint64_t v43 = sub_1001EDDCC();
      *(_DWORD *)__int128 buf = 136446210;
      int v45 = v43;
      _os_log_impl((void *)&_mh_execute_header, v42, OS_LOG_TYPE_DEFAULT, " %{public}s", buf, 0xCu);
    }
  }

void sub_1001E1E34(uint64_t a1, char a2)
{
  uint64_t v3 = (unsigned __int16)word_1008EDC88;
  if (word_1008EDC88)
  {
    uint64_t v5 = qword_1008EDC90;
    while (*(void *)v5 != a1)
    {
      v5 += 32LL;
      if (!--v3) {
        goto LABEL_5;
      }
    }

    if (sub_1000A86F0())
    {
      sub_1001EE134( (uint64_t)"Wireless Splitter SDP record for remote device with hci handle: %p already exists, updating it",  v14,  v15,  v16,  v17,  v18,  v19,  v20,  *(void *)v5);
      int v21 = (os_log_s *)sub_100086554(0x36u);
      if (os_log_type_enabled(v21, OS_LOG_TYPE_DEFAULT))
      {
        *(_DWORD *)__int128 buf = 136446210;
        uint64_t v23 = sub_1001EDDCC();
        _os_log_impl((void *)&_mh_execute_header, v21, OS_LOG_TYPE_DEFAULT, " %{public}s", buf, 0xCu);
      }
    }

    *(_BYTE *)(v5 + 28) = a2;
  }

  else
  {
LABEL_5:
    if (sub_1000A86F0())
    {
      sub_1001EE134( (uint64_t)"Wireless Splitter SDP record for remote device with hci handle: %p does not exist",  v6,  v7,  v8,  v9,  v10,  v11,  v12,  a1);
      BOOL v13 = (os_log_s *)sub_100086554(0x36u);
      if (os_log_type_enabled(v13, OS_LOG_TYPE_DEFAULT))
      {
        *(_DWORD *)__int128 buf = 136446210;
        uint64_t v23 = sub_1001EDDCC();
        _os_log_impl((void *)&_mh_execute_header, v13, OS_LOG_TYPE_DEFAULT, " %{public}s", buf, 0xCu);
      }
    }
  }

void sub_1001E1FA8(uint64_t a1, char a2)
{
  uint64_t v3 = (unsigned __int16)word_1008EDC88;
  if (word_1008EDC88)
  {
    uint64_t v5 = qword_1008EDC90;
    while (*(void *)v5 != a1)
    {
      v5 += 32LL;
      if (!--v3) {
        goto LABEL_5;
      }
    }

    if (sub_1000A86F0())
    {
      sub_1001EE134( (uint64_t)"SDP record for remote device with hci handle: %p already exists, updating requiresLegacyPnPInformation flag in record.",  v14,  v15,  v16,  v17,  v18,  v19,  v20,  *(void *)v5);
      int v21 = (os_log_s *)sub_100086554(0x36u);
      if (os_log_type_enabled(v21, OS_LOG_TYPE_DEFAULT))
      {
        *(_DWORD *)__int128 buf = 136446210;
        uint64_t v23 = sub_1001EDDCC();
        _os_log_impl((void *)&_mh_execute_header, v21, OS_LOG_TYPE_DEFAULT, " %{public}s", buf, 0xCu);
      }
    }

    *(_BYTE *)(v5 + 24) = a2;
  }

  else
  {
LABEL_5:
    if (sub_1000A86F0())
    {
      sub_1001EE134( (uint64_t)"SDP record for remote device with hci handle: %p does not exist",  v6,  v7,  v8,  v9,  v10,  v11,  v12,  a1);
      BOOL v13 = (os_log_s *)sub_100086554(0x36u);
      if (os_log_type_enabled(v13, OS_LOG_TYPE_DEFAULT))
      {
        *(_DWORD *)__int128 buf = 136446210;
        uint64_t v23 = sub_1001EDDCC();
        _os_log_impl((void *)&_mh_execute_header, v13, OS_LOG_TYPE_DEFAULT, " %{public}s", buf, 0xCu);
      }
    }
  }

uint64_t sub_1001E211C(uint64_t a1, int a2, __int16 a3, __int16 a4)
{
  uint64_t v8 = (unsigned __int16)word_1008EDC88;
  if (word_1008EDC88)
  {
    uint64_t v9 = (_WORD *)(qword_1008EDC90 + 14);
    while (*(void *)(v9 - 7) != a1)
    {
      v9 += 16;
      if (!--v8) {
        goto LABEL_5;
      }
    }

    if (sub_1000A86F0())
    {
      sub_1001EE134( (uint64_t)"SDP record for remote device with hci handle: %p already exists, let's update the record",  v32,  v33,  v34,  v35,  v36,  v37,  v38,  *(void *)(v9 - 7));
      uint64_t v39 = (os_log_s *)sub_100086554(0x36u);
      if (os_log_type_enabled(v39, OS_LOG_TYPE_DEFAULT))
      {
        *(_DWORD *)__int128 buf = 136446210;
        uint64_t v44 = sub_1001EDDCC();
        _os_log_impl((void *)&_mh_execute_header, v39, OS_LOG_TYPE_DEFAULT, " %{public}s", buf, 0xCu);
      }
    }

    uint64_t result = 0LL;
    if (a2 > 4381)
    {
      switch(a2)
      {
        case 4382:
          uint64_t result = 0LL;
          v9[3] = a3;
          v9[4] = a4;
          break;
        case 4398:
          uint64_t result = 0LL;
          v9[1] = a3;
          v9[2] = a4;
          break;
        case 4404:
          uint64_t result = 0LL;
          v9[6] = a3;
          break;
      }
    }

    else if ((a2 - 4366) >= 2)
    {
      if (a2 == 4364)
      {
        uint64_t result = 0LL;
        *(v9 - 3) = a3;
        *(v9 - 2) = a4;
      }
    }

    else
    {
      uint64_t result = 0LL;
      *(v9 - 1) = a3;
      *uint64_t v9 = a4;
    }
  }

  else
  {
LABEL_5:
    if (sub_1000A86F0())
    {
      sub_1001EE134( (uint64_t)"SDP record for remote device with hci handle: %p does not exist, creating one",  v10,  v11,  v12,  v13,  v14,  v15,  v16,  a1);
      uint64_t v17 = (os_log_s *)sub_100086554(0x36u);
      if (os_log_type_enabled(v17, OS_LOG_TYPE_DEFAULT))
      {
        *(_DWORD *)__int128 buf = 136446210;
        uint64_t v44 = sub_1001EDDCC();
        _os_log_impl((void *)&_mh_execute_header, v17, OS_LOG_TYPE_DEFAULT, " %{public}s", buf, 0xCu);
      }
    }

    unsigned int v18 = (unsigned __int16)word_1008EDC88;
    int v19 = (unsigned __int16)word_1008EDC88;
    if (v19 == *(unsigned __int8 *)sub_1001EDBA0(0x28u))
    {
      if (sub_1000A86F0())
      {
        sub_1001EE134( (uint64_t)"No room to add another SDP remote record for connection %p. Total number of SDP remote records : %d",  v20,  v21,  v22,  v23,  v24,  v25,  v26,  (unsigned __int16)word_1008EDC88);
        uint64_t v27 = (os_log_s *)sub_100086554(0x36u);
        if (os_log_type_enabled(v27, OS_LOG_TYPE_ERROR)) {
          sub_10065AFF0(v27);
        }
      }

      return 104LL;
    }

    else
    {
      uint64_t v29 = qword_1008EDC90;
      uint64_t v30 = (unsigned __int16)word_1008EDC88;
      *(void *)(qword_1008EDC90 + 32LL * (unsigned __int16)word_1008EDC88) = a1;
      if (a2 > 4381)
      {
        switch(a2)
        {
          case 4382:
            uint64_t v41 = v29 + 32 * v30;
            *(_WORD *)(v41 + 20) = a3;
            *(_WORD *)(v41 + memset(v6, 0, 22) = a4;
            break;
          case 4398:
            uint64_t v42 = v29 + 32 * v30;
            *(_WORD *)(v42 + 16) = a3;
            *(_WORD *)(v42 + 18) = a4;
            break;
          case 4404:
            *(_WORD *)(v29 + 32 * v30 + 26) = a3;
            break;
        }
      }

      else if ((a2 - 4366) >= 2)
      {
        if (a2 == 4364)
        {
          uint64_t v40 = v29 + 32 * v30;
          *(_WORD *)(v40 + 8) = a3;
          *(_WORD *)(v40 + 10) = a4;
        }
      }

      else
      {
        uint64_t v31 = v29 + 32 * v30;
        *(_WORD *)(v31 + 12) = a3;
        *(_WORD *)(v31 + 14) = a4;
      }

      uint64_t result = 0LL;
      word_1008EDC88 = v30 + 1;
    }
  }

  return result;
}

uint64_t sub_1001E2470(uint64_t result)
{
  byte_1008EDC98 = result;
  return result;
}

uint64_t sub_1001E247C( uint64_t a1, uint64_t a2, unsigned int a3, unsigned __int16 *a4, __int16 **a5, uint64_t a6)
{
  uint64_t v6 = a4;
  unsigned int v7 = a3;
  unsigned int v10 = *a4;
  uint64_t v11 = &unk_1008ED000;
  uint64_t v12 = qword_1008EDC70 + 120;
  if (byte_1008EDC98)
  {
    while (1)
    {
      uint64_t v12 = *(void *)v12;
      if (!v12) {
        return 802LL;
      }
      if (*(_DWORD *)(v12 + 48) == (_DWORD)a1) {
        goto LABEL_28;
      }
    }
  }

  do
  {
    uint64_t v12 = *(void *)v12;
    if (!v12)
    {
      if (sub_1000A86F0())
      {
        sub_1001EE134((uint64_t)"Could not find record for service handle %u", v13, v14, v15, v16, v17, v18, v19, a1);
        uint64_t v20 = (os_log_s *)sub_100086554(0x36u);
        if (os_log_type_enabled(v20, OS_LOG_TYPE_ERROR)) {
          sub_100657858();
        }
      }

      return 802LL;
    }
  }

  while (*(_DWORD *)(v12 + 48) != (_DWORD)a1);
  uint64_t v21 = *(unsigned __int16 *)(v12 + 24);
  if (*(_WORD *)(v12 + 24))
  {
    uint64_t v22 = 0LL;
    unsigned int v23 = 0;
    uint64_t v24 = 0LL;
    uint64_t v25 = *(void *)(v12 + 16) + 16LL;
    do
    {
      int v26 = *(unsigned __int16 *)(v25 - 16);
      if (v26 == 9)
      {
        uint64_t v24 = *(unsigned __int16 *)(*(void *)(*(void *)v25 + 8LL) + 24LL);
      }

      else if (v26 == 1)
      {
        unsigned int v23 = *(unsigned __int16 *)(v25 - 6);
        uint64_t v22 = *(void *)v25;
      }

      v25 += 24LL;
      --v21;
    }

    while (v21);
  }

  else
  {
    uint64_t v24 = 0LL;
    unsigned int v23 = 0;
    uint64_t v22 = 0LL;
  }

  uint64_t v27 = (unsigned __int16)word_1008EDC88;
  if (!word_1008EDC88)
  {
LABEL_23:
    uint64_t v29 = a5;
    if (sub_1000A86F0())
    {
      sub_1001EE134( (uint64_t)"No remote SDP record found for device. Returning SDP record with profile version %x",  v30,  v31,  v32,  v33,  v34,  v35,  v36,  v24);
      uint64_t v37 = (os_log_s *)sub_100086554(0x36u);
      if (os_log_type_enabled(v37, OS_LOG_TYPE_ERROR)) {
        sub_100657858();
      }
    }

    a5 = v29;
LABEL_27:
    if (v12) {
      goto LABEL_28;
    }
    return 802LL;
  }

  uint64_t v28 = (unsigned __int16 *)(qword_1008EDC90 + 16);
  while (*((void *)v28 - 2) != a6)
  {
    v28 += 16;
    if (!--v27) {
      goto LABEL_23;
    }
  }

  if (!v23) {
    goto LABEL_27;
  }
  char v64 = 0;
  unsigned int v65 = 0;
  uint64_t v66 = v23;
  uint64_t v67 = (int *)(v22 + 8);
  uint64_t v100 = a5;
  do
  {
    int v69 = *v67;
    v67 += 4;
    int v68 = v69;
    if (v69 <= 4398)
    {
      switch(v68)
      {
        case 4364:
          unsigned int v65 = *(v28 - 2);
          if (!*(v28 - 2)) {
            unsigned int v65 = *(v28 - 4);
          }
          break;
        case 4367:
          unsigned int v65 = *(v28 - 4);
          if (!*(v28 - 4)) {
            unsigned int v65 = *(v28 - 2);
          }
          break;
        case 4383:
          unsigned int v65 = v28[2];
          break;
        default:
          goto LABEL_96;
      }

      goto LABEL_95;
    }

    switch(v68)
    {
      case 4399:
        unsigned int v65 = *v28;
LABEL_95:
        char v64 = 1;
        break;
      case 4402:
        unsigned int v65 = v28[5];
        goto LABEL_95;
      case 4608:
        if (sub_1000A86F0())
        {
          sub_1001EE134( (uint64_t)"Service class ID is OI_UUID_PnPInformation, so check if we need to send legacy PnPInformation record",  v70,  v71,  v72,  v73,  v74,  v75,  v76,  v98);
          uint64_t v77 = (os_log_s *)sub_100086554(0x36u);
          if (os_log_type_enabled(v77, OS_LOG_TYPE_DEFAULT))
          {
            uint64_t v78 = sub_1001EDDCC();
            *(_DWORD *)__int128 buf = 136446210;
            uint64_t v103 = v78;
            _os_log_impl((void *)&_mh_execute_header, v77, OS_LOG_TYPE_DEFAULT, " %{public}s", buf, 0xCu);
          }
        }

        char v64 = *((_BYTE *)v28 + 8);
        if (v64)
        {
          if (sub_1000A86F0())
          {
            sub_1001EE134( (uint64_t)"Need to send legacy PnPInformation record to remote",  v79,  v80,  v81,  v82,  v83,  v84,  v85,  v98);
            uint64_t v86 = (os_log_s *)sub_100086554(0x36u);
            if (os_log_type_enabled(v86, OS_LOG_TYPE_DEFAULT))
            {
              uint64_t v87 = sub_1001EDDCC();
              *(_DWORD *)__int128 buf = 136446210;
              uint64_t v103 = v87;
              _os_log_impl((void *)&_mh_execute_header, v86, OS_LOG_TYPE_DEFAULT, " %{public}s", buf, 0xCu);
            }
          }

          char v64 = 0;
          uint64_t v12 = *(void *)(v12 + 8);
        }

        a5 = v100;
        uint64_t v6 = a4;
        break;
    }

LABEL_96:
    --v66;
  }

  while (v66);
  uint64_t v11 = (void *)&unk_1008ED000;
  if (!v65 || v24 <= v65)
  {
    unsigned int v7 = a3;
    goto LABEL_27;
  }

  if ((v64 & 1) != 0)
  {
    uint64_t v88 = *(void **)(v12 + 8);
    if (v88)
    {
      uint64_t v89 = 0LL;
      unsigned __int16 v90 = -1;
      do
      {
        if (*(_WORD *)(v12 + 24))
        {
          uint64_t v91 = v88[2] + 16LL;
          uint64_t v92 = *(unsigned __int16 *)(v12 + 24);
          do
          {
            if (*(_WORD *)(v91 - 16) == 9)
            {
              unsigned int v93 = *(unsigned __int16 *)(*(void *)(*(void *)v91 + 8LL) + 24LL);
              if (v93 <= v65)
              {
                if ((int)(v65 - v93) <= v90)
                {
                  uint64_t v89 = v88;
                  unsigned __int16 v90 = v65 - v93;
                }
              }

              else if ((int)(v93 - v65) < v90)
              {
                uint64_t v89 = v88;
                unsigned __int16 v90 = v93 - v65;
              }
            }

            v91 += 24LL;
            --v92;
          }

          while (v92);
        }

        uint64_t v88 = (void *)*v88;
      }

      while (v88);
    }

    else
    {
      uint64_t v89 = 0LL;
    }

    if (v89) {
      uint64_t v12 = (uint64_t)v89;
    }
  }

  unsigned int v7 = a3;
  if (!v12)
  {
    sub_1001EE2A0();
    return 802LL;
  }

    uint64_t v99 = a1;
    unsigned __int16 v52 = (char *)v28;
    uint64_t v100 = a3;
    int v53 = **(unsigned __int16 **)(a2 + 8);
    unsigned __int16 v54 = *(unsigned __int16 **)(v104 + 8);
    uint64_t v55 = *(_BYTE *)(v104 + 72);
    uint64_t v56 = *(void *)(*(void *)(v104 + 96) + 8LL);
    __int128 buf = *v30;
    uint64_t v168 = *(_DWORD *)(v104 + 92);
    sub_100634334(&v164, &buf);
    uint64_t v120 = v164;
    uint64_t v121 = v165;
    if (sub_1001C4FB4( v53,  v54,  v55,  (unsigned __int16)((((_DWORD)v52 - (_DWORD)v17) >> 3) + 1),  v56,  (unsigned __int8 *)&v120,  (uint64_t)sub_100384D48,  (uint64_t)sub_100384DDC))
    {
      if (os_log_type_enabled((os_log_t)qword_1008F75B0, OS_LOG_TYPE_ERROR)) {
        sub_100674CF4();
      }
LABEL_143:
      sub_1001C4E78(*(unsigned __int16 **)(a2 + 8));
      goto LABEL_28;
    }

    while (v17 != v52)
    {
      int v57 = *(void *)v17;
      uint64_t v58 = *(void *)(*(void *)v17 + 8LL);
      unsigned __int16 v59 = *(_DWORD *)(v58 + 20);
      __int128 buf = *(__n128 *)(v58 + 4);
      uint64_t v168 = v59;
      sub_100634334(&v164, &buf);
      uint64_t v118 = xmmword_1006BD914;
      uint64_t v119 = 0;
      if (sub_1001BEC7C(v60, (unsigned __int8 *)&v118)
        || (unsigned int v61 = *(void *)(v57 + 8),
            unsigned int v62 = *(_DWORD *)(v61 + 20),
            __int128 buf = *(__n128 *)(v61 + 4),
            uint64_t v168 = v62,
            sub_100634334(&v170, &buf),
            uint64_t v116 = xmmword_1006BD928,
            uint64_t v117 = 0,
            sub_1001BEC7C(v63, (unsigned __int8 *)&v116)))
      {
        char v64 = sub_100384F0C;
        unsigned int v65 = sub_100384FA0;
      }

      else
      {
        char v64 = sub_100384D48;
        unsigned int v65 = sub_100384DDC;
      }

      uint64_t v66 = *(void *)(v57 + 8);
      uint64_t v67 = **(unsigned __int16 **)(v104 + 8);
      int v68 = *(_BYTE *)(v66 + 26);
      int v69 = *(__n128 *)(v66 + 4);
      uint64_t v168 = *(_DWORD *)(v66 + 20);
      __int128 buf = v69;
      sub_100634334(&v164, &buf);
      uint64_t v114 = v164;
      uint64_t v115 = v165;
      if (sub_1001C5210( v66,  v67,  v68,  (unsigned __int8 *)&v114,  (uint64_t (*)(uint64_t, unsigned int, void *, signed int, _WORD *))v64,  (uint64_t)v65))
      {
        uint64_t v17 = v102;
        if (os_log_type_enabled((os_log_t)qword_1008F75B0, OS_LOG_TYPE_ERROR)) {
          sub_100674C94();
        }
        goto LABEL_143;
      }

      v17 += 8;
    }

    int v26 = v102;
    uint64_t v25 = v101 + 8;
    a3 = v100;
    a1 = v99;
    if (v101 + 8 != v109) {
      continue;
    }
    break;
  }

  if (os_log_type_enabled((os_log_t)qword_1008F7620, OS_LOG_TYPE_ERROR)) {
    sub_1006980E8();
  }
  v115[0] = _NSConcreteStackBlock;
  v115[1] = 3221225472LL;
  v115[2] = sub_1005B4DCC;
  v115[3] = &unk_1008A2590;
  uint64_t v116 = v5;
  sub_10058C72C((os_unfair_lock_s *)a1, v115);

  uint64_t v32 = 1LL;
LABEL_112:
  sub_100242FAC((uint64_t)v139);

  return v32;
}

  unint64_t v38 = sub_1002E6E00();
  sub_10002418C(buf, "LE");
  sub_10002418C(__p, "ForceRSSIDetectionCM_AND_Mask2");
  uint64_t v39 = (*(uint64_t (**)(uint64_t, uint8_t *, void **, uint64_t *))(*(void *)v38 + 88LL))(v38, buf, __p, &v57);
  if (v56 < 0) {
    operator delete(__p[0]);
  }
  if (v66 < 0)
  {
    operator delete(*(void **)buf);
    if (!v39) {
      goto LABEL_104;
    }
LABEL_102:
    int v40 = (os_log_s *)qword_1008F7620;
    if (os_log_type_enabled((os_log_t)qword_1008F7620, OS_LOG_TYPE_DEFAULT))
    {
      *(_DWORD *)__int128 buf = 67109120;
      *(_DWORD *)&uint8_t buf[4] = v57;
      _os_log_impl( (void *)&_mh_execute_header,  v40,  OS_LOG_TYPE_DEFAULT,  "Using override value for  ForceRSSIDetectionCM_AND_Mask2 (%d)",  buf,  8u);
    }

    goto LABEL_104;
  }

  if (v39) {
    goto LABEL_102;
  }
LABEL_104:
  if (!v64) {
    return 1501LL;
  }
  uint64_t v42 = v62;
  uint64_t v41 = v63;
  uint64_t v43 = v61;
  int v53 = WORD2(v60);
  uint64_t v44 = BYTE4(v59);
  int v45 = v60;
  uint64_t v47 = BYTE4(v58);
  int v46 = v59;
  int v48 = HIDWORD(v57);
  uint64_t v49 = v57;
  int v50 = sub_1002E6E9C();
  LOBYTE(v52) = v44;
  HIWORD(v51) = v46;
  WORD2(v51) = v45;
  WORD1(v51) = v53;
  BYTE1(v51) = v43;
  LOBYTE(v51) = v43;
  return (*(uint64_t (**)(uint64_t, uint64_t, void, void, void, void, void, void, uint64_t, char, unint64_t, void))(*(void *)v50 + 1760LL))( v50,  1LL,  *a2,  v41,  v42,  v42,  v42,  v43,  v51,  v47,  __PAIR64__(v49, v48),  v52);
}

uint64_t sub_1001E2BBC(uint64_t *a1, char *a2)
{
  uint64_t v2 = a2;
  if (*a2 == 32) {
    uint64_t v2 = (char *)*((void *)a2 + 1);
  }
  if (*((_BYTE *)a1 + 15))
  {
    sub_1001ED1C4((uint64_t)"/Library/Caches/com.apple.xbs/Sources/MobileBluetooth_base/Stack/corestack/sdp/sdpdb.c");
    goto LABEL_77;
  }

  uint64_t v4 = *((unsigned __int16 *)a1 + 6);
  if (*((unsigned __int16 *)a1 + 5) <= v4)
  {
LABEL_77:
    uint64_t v32 = "ByteStream_NumReadBytesAvail(*pByteStream) >= 1";
    goto LABEL_79;
  }

  if (*((_BYTE *)a1 + 14) != 2)
  {
    uint64_t v32 = "(*pByteStream).__RWFlag == BYTESTREAM_WRITE";
LABEL_79:
    sub_1000E6B88("/Library/Caches/com.apple.xbs/Sources/MobileBluetooth_base/Stack/corestack/sdp/sdpdb.c", 1532, v32);
  }

  char v5 = *v2;
  uint64_t v6 = *a1;
  *((_WORD *)a1 + 6) = v4 + 1;
  *(_BYTE *)(v6 + v4) = v5;
  if (*((_BYTE *)a1 + 15))
  {
    sub_1001ED1C4((uint64_t)"/Library/Caches/com.apple.xbs/Sources/MobileBluetooth_base/Stack/corestack/sdp/sdpdb.c");
    goto LABEL_81;
  }

  uint64_t v7 = *((unsigned __int16 *)a1 + 6);
  if (*((unsigned __int16 *)a1 + 5) - (int)v7 <= 1)
  {
LABEL_81:
    uint64_t v33 = "ByteStream_NumReadBytesAvail(*pByteStream) >= 2";
    goto LABEL_83;
  }

  if (*((_BYTE *)a1 + 14) != 2)
  {
    uint64_t v33 = "(*pByteStream).__RWFlag == BYTESTREAM_WRITE";
LABEL_83:
    sub_1000E6B88("/Library/Caches/com.apple.xbs/Sources/MobileBluetooth_base/Stack/corestack/sdp/sdpdb.c", 1533, v33);
  }

  *(_BYTE *)(*a1 + vmemset((char *)&v11[1] + 1, 0, 7) = v2[2];
  *(_BYTE *)(*a1 + *((unsigned __int16 *)a1 + 6) + 1) = v2[3];
  __int16 v8 = *((_WORD *)a1 + 6);
  unsigned __int16 v9 = v8 + 2;
  *((_WORD *)a1 + 6) = v8 + 2;
  switch(*v2)
  {
    case 0:
      return 1LL;
    case 1:
      int v10 = *((unsigned __int16 *)v2 + 1);
      if (v10 != 16)
      {
        if (v10 == 8)
        {
          if (*((_BYTE *)a1 + 15))
          {
            sub_1001ED1C4((uint64_t)"/Library/Caches/com.apple.xbs/Sources/MobileBluetooth_base/Stack/corestack/sdp/sdpdb.c");
          }

          else
          {
            uint64_t v11 = v9;
            if (*((unsigned __int16 *)a1 + 5) - (unint64_t)v9 > 7)
            {
              if (*((_BYTE *)a1 + 14) != 2)
              {
                uint64_t v12 = "(*pByteStream).__RWFlag == BYTESTREAM_WRITE";
                goto LABEL_101;
              }

              goto LABEL_21;
            }
          }

          uint64_t v12 = "ByteStream_NumReadBytesAvail(*pByteStream) >= (sizeof(OI_UINT64))";
LABEL_101:
          sub_1000E6B88( "/Library/Caches/com.apple.xbs/Sources/MobileBluetooth_base/Stack/corestack/sdp/sdpdb.c",  1542,  v12);
        }

        if (*((_BYTE *)a1 + 15))
        {
          sub_1001ED1C4((uint64_t)"/Library/Caches/com.apple.xbs/Sources/MobileBluetooth_base/Stack/corestack/sdp/sdpdb.c");
        }

        else if (*((unsigned __int16 *)a1 + 5) - v9 > 3)
        {
          if (*((_BYTE *)a1 + 14) != 2)
          {
            uint64_t v31 = "(*pByteStream).__RWFlag == BYTESTREAM_WRITE";
            goto LABEL_111;
          }

uint64_t sub_1001E336C(uint64_t a1)
{
  if (!a1) {
    return 101LL;
  }
  if (*(_BYTE *)(a1 + 15))
  {
    sub_1001ED1C4((uint64_t)"/Library/Caches/com.apple.xbs/Sources/MobileBluetooth_base/Stack/corestack/sdp/sdpdb.c");
    goto LABEL_60;
  }

  uint64_t v2 = *(unsigned __int16 *)(a1 + 12);
  if (*(unsigned __int16 *)(a1 + 10) - (int)v2 <= 1)
  {
LABEL_60:
    int v26 = "ByteStream_NumReadBytesAvail(*sdpDataRecord) >= 2";
    goto LABEL_62;
  }

  if (*(_BYTE *)(a1 + 14) != 2)
  {
    int v26 = "(*sdpDataRecord).__RWFlag == BYTESTREAM_WRITE";
LABEL_62:
    sub_1000E6B88("/Library/Caches/com.apple.xbs/Sources/MobileBluetooth_base/Stack/corestack/sdp/sdpdb.c", 1612, v26);
  }

  *(_BYTE *)(*(void *)a1 + v2) = 0;
  *(_BYTE *)(*(void *)a1 + *(unsigned __int16 *)(a1 + 12) + 1LL) = 0;
  *(_WORD *)(a1 + 12) += 2;
  uint64_t v3 = *(uint64_t **)(qword_1008EDC70 + 120);
  if (!v3)
  {
    LOBYTE(v4) = 0;
    char v22 = 0;
LABEL_45:
    uint64_t result = 0LL;
    **(_BYTE **)a1 = v4;
    *(_BYTE *)(*(void *)a1 + 1LL) = v22;
    return result;
  }

  __int16 v4 = 0;
LABEL_7:
  uint64_t v5 = *((unsigned __int16 *)v3 + 12);
  if (!*((_WORD *)v3 + 12)) {
    goto LABEL_13;
  }
  uint64_t v6 = (char *)(v3[2] + 8);
  while (*((_WORD *)v6 - 4) != 1)
  {
    v6 += 24;
    if (!--v5) {
      goto LABEL_13;
    }
  }

  uint64_t result = sub_1001E2BBC((uint64_t *)a1, v6);
  if ((_DWORD)result)
  {
LABEL_13:
    if (*(_BYTE *)(a1 + 15))
    {
      sub_1001ED1C4((uint64_t)"/Library/Caches/com.apple.xbs/Sources/MobileBluetooth_base/Stack/corestack/sdp/sdpdb.c");
    }

    else
    {
      uint64_t v8 = *(unsigned __int16 *)(a1 + 12);
      if (*(unsigned __int16 *)(a1 + 10) - (int)v8 > 1)
      {
        if (*(_BYTE *)(a1 + 14) == 2)
        {
          uint64_t v9 = 0LL;
          *(_BYTE *)(*(void *)a1 + *(unsigned __int16 *)(a1 + 12)) = 0;
          ++v4;
          *(_BYTE *)(*(void *)a1 + *(unsigned __int16 *)(a1 + 12) + 1LL) = 0;
          *(_WORD *)(a1 + 12) += 2;
          uint64_t v10 = qword_1008EDC70;
          *(_BYTE *)(qword_1008EDC70 + 8) = 1;
          *(_WORD *)(v10 + 10) = 4;
          *(_DWORD *)(v10 + 16) = *((_DWORD *)v3 + 12);
          *(_BYTE *)(v10 + 32) = 1;
          *(_WORD *)(v10 + 34) = 4;
          *(_DWORD *)(v10 + 40) = *((_DWORD *)v3 + 13);
          *(_BYTE *)(v10 + 56) = 1;
          *(_WORD *)(v10 + 58) = 1;
          *(_DWORD *)(v10 + 64) = *((unsigned __int8 *)v3 + 66);
          *(_OWORD *)(v10 + 80) = unk_1008D73F0;
          *(_OWORD *)(v10 + 104) = *(_OWORD *)v3[9];
          if (*(_WORD *)(v10 + 106)) {
            unsigned int v11 = 5;
          }
          else {
            unsigned int v11 = 4;
          }
          while (1)
          {
            if (*(_BYTE *)(a1 + 15))
            {
              sub_1001ED1C4((uint64_t)"/Library/Caches/com.apple.xbs/Sources/MobileBluetooth_base/Stack/corestack/sdp/sdpdb.c");
LABEL_48:
              uint64_t v23 = "ByteStream_NumReadBytesAvail(*sdpDataRecord) >= 2";
LABEL_50:
              sub_1000E6B88( "/Library/Caches/com.apple.xbs/Sources/MobileBluetooth_base/Stack/corestack/sdp/sdpdb.c",  1634,  v23);
            }

            uint64_t v12 = *(unsigned __int16 *)(a1 + 12);
            if (*(_BYTE *)(a1 + 14) != 2)
            {
              uint64_t v23 = "(*sdpDataRecord).__RWFlag == BYTESTREAM_WRITE";
              goto LABEL_50;
            }

            uint64_t v13 = qword_1008EDC70 + v9;
            *(_BYTE *)(*(void *)a1 + v12) = *(_BYTE *)(qword_1008EDC70 + v9);
            *(_BYTE *)(*(void *)a1 + *(unsigned __int16 *)(a1 + 12) + 1LL) = *(_BYTE *)(v13 + 1);
            *(_WORD *)(a1 + 12) += 2;
            v9 += 24LL;
            if (24LL * v11 == v9)
            {
              unsigned __int16 v14 = *((_WORD *)v3 + 12);
              if (v14)
              {
                uint64_t v15 = 0LL;
                for (unint64_t i = 0LL; i < v14; ++i)
                {
                  int v17 = *(unsigned __int16 *)(v3[2] + v15);
                  if (v17 != 1)
                  {
                    if (*(_BYTE *)(a1 + 15))
                    {
                      sub_1001ED1C4((uint64_t)"/Library/Caches/com.apple.xbs/Sources/MobileBluetooth_base/Stack/corestack/sdp/sdpdb.c");
LABEL_56:
                      uint64_t v25 = "ByteStream_NumReadBytesAvail(*sdpDataRecord) >= 2";
LABEL_58:
                      sub_1000E6B88( "/Library/Caches/com.apple.xbs/Sources/MobileBluetooth_base/Stack/corestack/sdp/sdpdb.c",  1646,  v25);
                    }

                    uint64_t v18 = *(unsigned __int16 *)(a1 + 12);
                    if (*(_BYTE *)(a1 + 14) != 2)
                    {
                      uint64_t v25 = "(*sdpDataRecord).__RWFlag == BYTESTREAM_WRITE";
                      goto LABEL_58;
                    }

                    *(_BYTE *)(*(void *)a1 + v18) = v17;
                    *(_BYTE *)(*(void *)a1 + *(unsigned __int16 *)(a1 + 12) + 1LL) = *(_BYTE *)(v3[2] + v15 + 1);
                    *(_WORD *)(a1 + 12) += 2;
                    uint64_t result = sub_1001E2BBC((uint64_t *)a1, (char *)(v3[2] + v15 + 8));
                    if (!(_DWORD)result) {
                      return result;
                    }
                    LOWORD(v11) = v11 + 1;
                    unsigned __int16 v14 = *((_WORD *)v3 + 12);
                  }

                  v15 += 24LL;
                }
              }

              if (*((_WORD *)v3 + 32))
              {
                uint64_t v19 = 0LL;
                unint64_t v20 = 0LL;
                while (!*(_BYTE *)(a1 + 15))
                {
                  uint64_t v21 = *(unsigned __int16 *)(a1 + 12);
                  if (*(_BYTE *)(a1 + 14) != 2)
                  {
                    unint64_t v24 = "(*sdpDataRecord).__RWFlag == BYTESTREAM_WRITE";
                    goto LABEL_54;
                  }

                  *(_BYTE *)(*(void *)a1 + v21) = *(_BYTE *)(v3[7] + v19);
                  *(_BYTE *)(*(void *)a1 + *(unsigned __int16 *)(a1 + 12) + 1LL) = *(_BYTE *)(v3[7] + v19 + 1);
                  *(_WORD *)(a1 + 12) += 2;
                  ++v20;
                  v19 += 24LL;
                  LOWORD(v11) = v11 + 1;
                }

                sub_1001ED1C4((uint64_t)"/Library/Caches/com.apple.xbs/Sources/MobileBluetooth_base/Stack/corestack/sdp/sdpdb.c");
LABEL_52:
                unint64_t v24 = "ByteStream_NumReadBytesAvail(*sdpDataRecord) >= 2";
LABEL_54:
                sub_1000E6B88( "/Library/Caches/com.apple.xbs/Sources/MobileBluetooth_base/Stack/corestack/sdp/sdpdb.c",  1654,  v24);
              }

uint64_t sub_1001E3874(uint64_t a1)
{
  if (a1)
  {
    if (sub_1000A86F0())
    {
      sub_1001EE134( (uint64_t)"OI_SDPServer_Init: configuration parameter is deprecated",  v2,  v3,  v4,  v5,  v6,  v7,  v8,  v14);
      uint64_t v9 = (os_log_s *)sub_100086554(0x35u);
      if (os_log_type_enabled(v9, OS_LOG_TYPE_ERROR)) {
        sub_100657858();
      }
    }

    sub_1001EDBE4(a1, 53LL);
  }

  if (DWORD1(xmmword_1008F6FD8)) {
    return 140LL;
  }
  unsigned int v11 = (unsigned __int8 *)sub_1001EDBA0(0x35u);
  if (!v11)
  {
    sub_1001EE2A0();
    return 127LL;
  }

  uint64_t v12 = v11;
  unsigned int v13 = *v11;
  if (!*v11) {
    goto LABEL_17;
  }
  if (*((unsigned __int16 *)v11 + 1) <= 0xFu)
  {
    sub_1001EE2A0();
    unsigned int v13 = *v12;
  }

  xmmword_1008EDCF8 = 0u;
  *(_OWORD *)&qword_1008EDD08 = 0u;
  *((void *)&xmmword_1008EDCF8 + 1) = sub_1000B1814(32LL * v13);
  if (!*((void *)&xmmword_1008EDCF8 + 1)) {
    return 106LL;
  }
  *(void *)&xmmword_1008EDCF8 = sub_1001EDBA0(0x35u);
  uint64_t result = sub_1001E11F8();
  if (!(_DWORD)result)
  {
    uint64_t result = sub_10017A6F0(1, (uint64_t)sub_1001E3FF4);
    if (!(_DWORD)result)
    {
LABEL_17:
      uint64_t result = 0LL;
      DWORD1(xmmword_1008F6FD8) = 1;
    }
  }

  return result;
}

uint64_t sub_1001E39A4(uint64_t a1)
{
  if (!DWORD1(xmmword_1008F6FD8)) {
    return 103LL;
  }
  uint64_t result = 0LL;
  qword_1008EDD08 = a1;
  return result;
}

void sub_1001E39D0(int a1, unsigned int a2)
{
  __int128 v36 = 0u;
  __int128 v37 = 0u;
  if (sub_1000A86F0())
  {
    sub_1001EE134( (uint64_t)"SDPSERVER OI_SDPSRV_RespondToStalledIncomingRequest: stalled cid is %u, accept: %d",  v4,  v5,  v6,  v7,  v8,  v9,  v10,  a2);
    unsigned int v11 = (os_log_s *)sub_100086554(0x35u);
    if (os_log_type_enabled(v11, OS_LOG_TYPE_DEFAULT))
    {
      *(_DWORD *)__int128 buf = 136446210;
      uint64_t v39 = sub_1001EDDCC();
      _os_log_impl((void *)&_mh_execute_header, v11, OS_LOG_TYPE_DEFAULT, " %{public}s", buf, 0xCu);
    }
  }

  uint64_t v12 = xmmword_1008EDCF8;
  uint64_t v13 = *(unsigned __int8 *)xmmword_1008EDCF8;
  if (!*(_BYTE *)xmmword_1008EDCF8)
  {
LABEL_9:
    if (sub_1000A86F0())
    {
      sub_1001EE134((uint64_t)"stalled sdpclient is NULL", v15, v16, v17, v18, v19, v20, v21, v35);
      char v22 = (os_log_s *)sub_100086554(0x35u);
      if (os_log_type_enabled(v22, OS_LOG_TYPE_ERROR)) {
        sub_100657858();
      }
    }

    return;
  }

  uint64_t v14 = (__int16 *)(*((void *)&xmmword_1008EDCF8 + 1) + 4LL);
  while (!*((_BYTE *)v14 - 2) || (unsigned __int16)*(v14 - 2) != a2)
  {
    v14 += 16;
    if (!--v13) {
      goto LABEL_9;
    }
  }

  if (a1)
  {
    *((_BYTE *)v14 - 2) = 1;
    unsigned int v23 = *(unsigned __int16 *)(v12 + 4);
    *uint64_t v14 = v23;
    if (v23 > 0x80)
    {
      if (v23 <= *(unsigned __int16 *)(sub_1001EDBA0(0x28u) + 8))
      {
        __int16 v24 = *v14;
        goto LABEL_19;
      }

      __int16 v24 = *(_WORD *)(sub_1001EDBA0(0x28u) + 8);
    }

    else
    {
      __int16 v24 = 128;
    }

    *uint64_t v14 = v24;
LABEL_19:
    *((void *)&v36 + 1) = 0LL;
    __int128 v37 = 0uLL;
    LOWORD(v36) = v24;
    *(_DWORD *)((char *)&v36 + 2) = 327745535;
    WORD3(v36) = 772;
  }

  uint64_t v25 = sub_100174B2C( (uint64_t)sub_1001E3C18,  (uint64_t)sub_1001E3CA8,  (uint64_t)sub_1001E3D78,  a2,  (uint64_t)&v36,  a1,  (uint64_t)&unk_1006BE050);
  if ((_DWORD)v25)
  {
    uint64_t v26 = v25;
    if (sub_1000A86F0())
    {
      sub_1001EE134( (uint64_t)"SDPServer: L2CAP failed to complete the connection %!",  v27,  v28,  v29,  v30,  v31,  v32,  v33,  v26);
      uint64_t v34 = (os_log_s *)sub_100086554(0x35u);
      if (os_log_type_enabled(v34, OS_LOG_TYPE_ERROR)) {
        sub_100657858();
      }
    }

    *((_BYTE *)v14 - 2) = 0;
  }

void sub_1001E3C18(uint64_t a1, unsigned int a2, unsigned int a3, int a4)
{
  if (a4)
  {
    sub_1001E3CA8(a1);
  }

  else
  {
    uint64_t v4 = xmmword_1008EDCF8;
    uint64_t v5 = *(unsigned __int8 *)xmmword_1008EDCF8;
    if (*(_BYTE *)xmmword_1008EDCF8)
    {
      uint64_t v6 = (_WORD *)(*((void *)&xmmword_1008EDCF8 + 1) + 6LL);
      while (!*((_BYTE *)v6 - 4) || (unsigned __int16)*(v6 - 3) != (_DWORD)a1)
      {
        v6 += 16;
        if (!--v5) {
          goto LABEL_8;
        }
      }
    }

    else
    {
LABEL_8:
      sub_1001EE2A0();
      __break(1u);
    }

    if ((unsigned __int16)*(v6 - 1) >= a2)
    {
      unsigned int v7 = *(unsigned __int16 *)(v4 + 2);
      if (v7 <= a3) {
        *uint64_t v6 = v7;
      }
      else {
        *uint64_t v6 = a3;
      }
    }

    else
    {
      sub_1001E42E8(a1);
    }
  }

void sub_1001E3CA8(int a1)
{
  LODWORD(v2) = *(unsigned __int8 *)xmmword_1008EDCF8;
  if (*(_BYTE *)xmmword_1008EDCF8)
  {
    uint64_t v3 = (unsigned __int16 *)*((void *)&xmmword_1008EDCF8 + 1);
    uint64_t v4 = *(unsigned __int8 *)xmmword_1008EDCF8;
    while (!*((_BYTE *)v3 + 2) || *v3 != a1)
    {
      v3 += 16;
      if (!--v4) {
        goto LABEL_6;
      }
    }
  }

  else
  {
LABEL_6:
    uint64_t v3 = 0LL;
  }

  if (qword_1008EDD08)
  {
    uint64_t v5 = *(void (**)(unsigned __int16 *))(qword_1008EDD08 + 8);
    if (v5)
    {
      v5(v3 + 12);
      LODWORD(v2) = *(unsigned __int8 *)xmmword_1008EDCF8;
    }
  }

  if ((_DWORD)v2)
  {
    uint64_t v2 = v2;
    for (unint64_t i = (void **)(*((void *)&xmmword_1008EDCF8 + 1) + 16LL);
          !*((_BYTE *)i - 14) || *((unsigned __int16 *)i - 8) != a1;
          i += 4)
    {
      if (!--v2) {
        return;
      }
    }

    *((_BYTE *)i - 14) = 0;
    if (*i)
    {
      sub_1000B1838(*i);
      *unint64_t i = 0LL;
    }
  }

void sub_1001E3D78(uint64_t a1, unsigned __int8 *a2, unsigned int a3)
{
  uint64_t v3 = *(unsigned __int8 *)xmmword_1008EDCF8;
  if (!*(_BYTE *)xmmword_1008EDCF8)
  {
LABEL_6:
    if (sub_1000A86F0())
    {
      sub_1001EE134((uint64_t)"Client not allocated", v6, v7, v8, v9, v10, v11, v12, (uint64_t)ptr);
      uint64_t v13 = (os_log_s *)sub_100086554(0x35u);
      if (os_log_type_enabled(v13, OS_LOG_TYPE_ERROR))
      {
LABEL_8:
        sub_100657858();
        return;
      }
    }

    return;
  }

  uint64_t v5 = *((void *)&xmmword_1008EDCF8 + 1) + 8LL;
  while (!*(_BYTE *)(v5 - 6) || *(unsigned __int16 *)(v5 - 8) != (_DWORD)a1)
  {
    v5 += 32LL;
    if (!--v3) {
      goto LABEL_6;
    }
  }

  if (*(void *)(v5 + 8))
  {
    if (sub_1000A86F0())
    {
      sub_1001EE134((uint64_t)"Client sent overlapping request", v14, v15, v16, v17, v18, v19, v20, (uint64_t)ptr);
      uint64_t v21 = (os_log_s *)sub_100086554(0x35u);
      if (os_log_type_enabled(v21, OS_LOG_TYPE_ERROR)) {
        goto LABEL_8;
      }
    }

    return;
  }

  if (a3 < 5) {
    return;
  }
  if (!a2) {
    sub_1000E6B88( "/Library/Caches/com.apple.xbs/Sources/MobileBluetooth_base/Stack/corestack/sdp/sdpserver.c",  1591,  "requestBuffer");
  }
  uint64_t v36 = 0LL;
  __int128 v37 = a2;
  __int16 v38 = a3;
  __int16 v39 = a3;
  int v22 = *a2;
  unsigned int v23 = bswap32(*(unsigned __int16 *)(a2 + 1)) >> 16;
  int v40 = 65541;
  ptr = 0LL;
  if (a3 - 5 != bswap32(*(unsigned __int16 *)(a2 + 3)) >> 16)
  {
    int v25 = 804;
LABEL_25:
    int v24 = sub_1001E4330(v25, v23, (uint64_t)&ptr);
    goto LABEL_26;
  }

  if (v22 == 6)
  {
    int v24 = sub_1001E4F14(v23, (uint64_t)&v37, (uint64_t)&ptr, *(_WORD *)(v5 - 2), a1);
    goto LABEL_26;
  }

  if (v22 == 4)
  {
    int v24 = sub_1001E4C68(v23, (uint64_t)&v37, (uint64_t)&ptr, *(_WORD *)(v5 - 2), a1);
    goto LABEL_26;
  }

  if (v22 != 2)
  {
    int v25 = 803;
    goto LABEL_25;
  }

  int v24 = sub_1001E45C0(v23, (uint64_t)&v37, (uint64_t)&ptr, *(unsigned __int16 *)(v5 - 2), a1);
LABEL_26:
  if (v24) {
    goto LABEL_39;
  }
  int v34 = sub_100172DA0((uint64_t)sub_1001E5250, a1, 0LL, (char *)ptr, WORD1(v36));
  if (!v34) {
    return;
  }
  if (v34 != 410)
  {
LABEL_39:
    if (sub_1000A86F0())
    {
      sub_1001EE134((uint64_t)"IncomingRequest_CB failed", v26, v27, v28, v29, v30, v31, v32, (uint64_t)ptr);
      uint64_t v33 = (os_log_s *)sub_100086554(0x35u);
      if (os_log_type_enabled(v33, OS_LOG_TYPE_ERROR)) {
        sub_1006578C0();
      }
    }

    sub_1000B1838(ptr);
  }

  else
  {
    if (*(void *)(v5 + 8)) {
      sub_1001EE2A0();
    }
    *(void *)(v5 + 8) = ptr;
    *(_WORD *)uint64_t v5 = WORD1(v36);
  }

void sub_1001E3FF4(uint64_t a1, int *a2, uint64_t a3)
{
  unsigned int v3 = a3;
  __int128 v39 = 0u;
  __int128 v40 = 0u;
  uint64_t v4 = *(unsigned __int8 *)xmmword_1008EDCF8;
  if (!*(_BYTE *)xmmword_1008EDCF8) {
    goto LABEL_5;
  }
  uint64_t v6 = *((void *)&xmmword_1008EDCF8 + 1);
  while (*(_BYTE *)(v6 + 2))
  {
    v6 += 32LL;
    if (!--v4) {
      goto LABEL_5;
    }
  }

  if (qword_1008EDD08 && *(void *)qword_1008EDD08)
  {
    int v7 = (*(uint64_t (**)(int *, uint64_t))qword_1008EDD08)(a2, a3);
    __int16 v8 = *((_WORD *)a2 + 2);
    *(_DWORD *)(v6 + 24) = *a2;
    *(_WORD *)(v6 + 28) = v8;
    if (v7 != 845)
    {
      if (v7 == 847)
      {
        *(_WORD *)uint64_t v6 = v3;
        *(_BYTE *)(v6 + 2) = 1;
        if (sub_1000A86F0())
        {
          sub_1001EE134((uint64_t)"Stalled incoming SDP request for cid=%d", v9, v10, v11, v12, v13, v14, v15, v3);
          uint64_t v16 = (os_log_s *)sub_100086554(0x35u);
          if (os_log_type_enabled(v16, OS_LOG_TYPE_DEFAULT))
          {
            *(_DWORD *)__int128 buf = 136446210;
            uint64_t v42 = sub_1001EDDCC();
            _os_log_impl((void *)&_mh_execute_header, v16, OS_LOG_TYPE_DEFAULT, " %{public}s", buf, 0xCu);
          }
        }

        return;
      }

uint64_t sub_1001E42E8(uint64_t result)
{
  uint64_t v1 = *(unsigned __int8 *)xmmword_1008EDCF8;
  if (*(_BYTE *)xmmword_1008EDCF8)
  {
    for (unint64_t i = (_BYTE *)(*((void *)&xmmword_1008EDCF8 + 1) + 2LL);
          !*i || *((unsigned __int16 *)i - 1) != (_DWORD)result;
          i += 32)
    {
      if (!--v1) {
        return result;
      }
    }

    return sub_1001759FC(result, 436LL);
  }

  return result;
}

uint64_t sub_1001E4330(int a1, __int16 a2, uint64_t a3)
{
  if ((a1 - 807) > 0xFFFFFFF9)
  {
    __int16 v13 = a1 - 800;
  }

  else
  {
    if (sub_1000A86F0())
    {
      sub_1001EE134((uint64_t)"ComposeErrorResponse, generic error", v5, v6, v7, v8, v9, v10, v11, v23);
      uint64_t v12 = (os_log_s *)sub_100086554(0x35u);
      if (os_log_type_enabled(v12, OS_LOG_TYPE_ERROR)) {
        sub_100657858();
      }
    }

    __int16 v13 = 6;
  }

  uint64_t v14 = sub_1000B17F4(7uLL);
  if (!v14) {
    return 106LL;
  }
  *(void *)a3 = v14;
  *(_WORD *)(a3 + 8) = 7;
  *(_WORD *)(a3 + 14) = 2;
  *(_DWORD *)(a3 + 10) = 65543;
  *uint64_t v14 = 1;
  if (*(_BYTE *)(a3 + 15))
  {
    sub_1001ED1C4((uint64_t)"/Library/Caches/com.apple.xbs/Sources/MobileBluetooth_base/Stack/corestack/sdp/sdpserver.c");
    goto LABEL_22;
  }

  uint64_t v15 = *(unsigned __int16 *)(a3 + 12);
  if (*(unsigned __int16 *)(a3 + 10) - (int)v15 <= 1)
  {
LABEL_22:
    uint64_t v20 = "ByteStream_NumReadBytesAvail(*responseBS) >= 2";
    goto LABEL_24;
  }

  if (*(_BYTE *)(a3 + 14) != 2)
  {
    uint64_t v20 = "(*responseBS).__RWFlag == BYTESTREAM_WRITE";
LABEL_24:
    sub_1000E6B88( "/Library/Caches/com.apple.xbs/Sources/MobileBluetooth_base/Stack/corestack/sdp/sdpserver.c",  655,  v20);
  }

  *(_BYTE *)(*(void *)a3 + v15 + 1) = a2;
  *(_BYTE *)(*(void *)a3 + *(unsigned __int16 *)(a3 + 12)) = HIBYTE(a2);
  unsigned __int16 v16 = *(_WORD *)(a3 + 12) + 2;
  *(_WORD *)(a3 + 12) = v16;
  if (*(_BYTE *)(a3 + 15))
  {
    sub_1001ED1C4((uint64_t)"/Library/Caches/com.apple.xbs/Sources/MobileBluetooth_base/Stack/corestack/sdp/sdpserver.c");
    goto LABEL_26;
  }

  if (*(unsigned __int16 *)(a3 + 10) - v16 <= 1)
  {
LABEL_26:
    uint64_t v21 = "ByteStream_NumReadBytesAvail(*responseBS) >= 2";
    goto LABEL_28;
  }

  if (*(_BYTE *)(a3 + 14) != 2)
  {
    uint64_t v21 = "(*responseBS).__RWFlag == BYTESTREAM_WRITE";
LABEL_28:
    sub_1000E6B88( "/Library/Caches/com.apple.xbs/Sources/MobileBluetooth_base/Stack/corestack/sdp/sdpserver.c",  656,  v21);
  }

  *(_BYTE *)(*(void *)a3 + v16 + 1LL) = 2;
  *(_BYTE *)(*(void *)a3 + *(unsigned __int16 *)(a3 + 12)) = 0;
  unsigned __int16 v17 = *(_WORD *)(a3 + 12) + 2;
  *(_WORD *)(a3 + 12) = v17;
  if (*(_BYTE *)(a3 + 15))
  {
    sub_1001ED1C4((uint64_t)"/Library/Caches/com.apple.xbs/Sources/MobileBluetooth_base/Stack/corestack/sdp/sdpserver.c");
    goto LABEL_30;
  }

  if (*(unsigned __int16 *)(a3 + 10) - v17 <= 1)
  {
LABEL_30:
    uint64_t v22 = "ByteStream_NumReadBytesAvail(*responseBS) >= 2";
    goto LABEL_32;
  }

  if (*(_BYTE *)(a3 + 14) != 2)
  {
    uint64_t v22 = "(*responseBS).__RWFlag == BYTESTREAM_WRITE";
LABEL_32:
    sub_1000E6B88( "/Library/Caches/com.apple.xbs/Sources/MobileBluetooth_base/Stack/corestack/sdp/sdpserver.c",  657,  v22);
  }

  *(_BYTE *)(*(void *)a3 + v17 + 1LL) = v13;
  *(_BYTE *)(*(void *)a3 + *(unsigned __int16 *)(a3 + 12)) = HIBYTE(v13);
  __int16 v18 = *(_WORD *)(a3 + 12) + 2;
  *(_WORD *)(a3 + 12) = v18;
  if (*(_BYTE *)(a3 + 14) == 2) {
    *(_WORD *)(a3 + 10) = v18;
  }
  uint64_t result = 0LL;
  *(_BYTE *)(a3 + 14) = 15;
  return result;
}

uint64_t sub_1001E45C0(__int16 a1, uint64_t a2, uint64_t a3, int a4, unsigned int a5)
{
  uint64_t v60 = 0LL;
  uint64_t v61 = 0LL;
  int v58 = 0;
  int v59 = 0;
  uint64_t v57 = 0LL;
  sub_1001723A0(a5, &v57);
  uint64_t v9 = sub_1001E5308((uint64_t *)a2, (uint64_t)&v60);
  if ((_DWORD)v9)
  {
    uint64_t v10 = v9;
    if (sub_1000A86F0())
    {
      sub_1001EE134((uint64_t)"SDPServer: ServiceSearchRequest bad UUID list", v11, v12, v13, v14, v15, v16, v17, v55);
      __int16 v18 = (os_log_s *)sub_100086554(0x35u);
      if (os_log_type_enabled(v18, OS_LOG_TYPE_ERROR)) {
        sub_100657858();
      }
    }

    goto LABEL_29;
  }

  if (*(_BYTE *)(a2 + 14) != 1) {
    sub_1000E6B88( "/Library/Caches/com.apple.xbs/Sources/MobileBluetooth_base/Stack/corestack/sdp/sdpserver.c",  807,  "(*requestBS).__RWFlag == BYTESTREAM_READ");
  }
  if (*(_BYTE *)(a2 + 15))
  {
    sub_1001ED1C4((uint64_t)"/Library/Caches/com.apple.xbs/Sources/MobileBluetooth_base/Stack/corestack/sdp/sdpserver.c");
LABEL_27:
    *(_BYTE *)(a2 + 15) = 1;
    goto LABEL_28;
  }

  uint64_t v19 = *(unsigned __int16 *)(a2 + 12);
  uint64_t v20 = (unsigned __int8 *)(*(void *)a2 + v19);
  int v21 = v20[1];
  unsigned int v22 = v21 | (*v20 << 8);
  *(_WORD *)(a2 + 12) = v19 + 2;
  if (!v22)
  {
LABEL_28:
    uint64_t v10 = 803LL;
LABEL_29:
    if (sub_1000A86F0())
    {
      sub_1001EE134((uint64_t)"Error response to service search request: %!", v32, v33, v34, v35, v36, v37, v38, v10);
      __int128 v39 = (os_log_s *)sub_100086554(0x35u);
      if (os_log_type_enabled(v39, OS_LOG_TYPE_ERROR)) {
        sub_100657858();
      }
    }

    if (*(void *)a3) {
      sub_1000B1838(*(void **)a3);
    }
    sub_10010C410((unsigned __int8 *)&v60);
    return sub_1001E4330(v10, a1, a3);
  }

  uint64_t v10 = sub_1001E5374((uint64_t *)a2, &v58);
  if ((_DWORD)v10) {
    goto LABEL_29;
  }
  unsigned __int16 v23 = v22 >= (unsigned __int16)((a4 + 262132) >> 2) ? (a4 + 262132) >> 2 : v22;
  uint64_t v10 = sub_1001E5470(a3, (4 * v23 + 4) & 0xFFFC);
  if ((_DWORD)v10) {
    goto LABEL_29;
  }
  if (*(_BYTE *)(a3 + 15))
  {
    sub_1001ED1C4((uint64_t)"/Library/Caches/com.apple.xbs/Sources/MobileBluetooth_base/Stack/corestack/sdp/sdpserver.c");
LABEL_64:
    sub_1000E6B88( "/Library/Caches/com.apple.xbs/Sources/MobileBluetooth_base/Stack/corestack/sdp/sdpserver.c",  842,  "ByteStream_NumReadBytesAvail(*responseBS) >= (2 * sizeof(uint16_t))");
  }

  uint64_t v24 = *(unsigned __int16 *)(a3 + 12);
  unsigned int v25 = 0;
  unsigned __int16 v26 = 0;
  __int16 v27 = 0;
  uint64_t v56 = *(unsigned __int16 *)(a3 + 12);
  *(_WORD *)(a3 + 12) = v24 + 4;
  unsigned int v28 = (unsigned __int16)v58;
  while (1)
  {
    uint64_t v29 = sub_1001E1780(v61, WORD1(v60), (_WORD *)&v58 + 1, &v59, v57);
    if ((_DWORD)v29) {
      break;
    }
    char v30 = HIBYTE(v26);
    if (HIWORD(v58) > v28 && v26 < v23)
    {
      if (*(_BYTE *)(a3 + 15))
      {
        sub_1001ED1C4((uint64_t)"/Library/Caches/com.apple.xbs/Sources/MobileBluetooth_base/Stack/corestack/sdp/sdpserver.c");
LABEL_60:
        uint64_t v49 = "ByteStream_NumReadBytesAvail(*responseBS) >= 4";
LABEL_62:
        sub_1000E6B88( "/Library/Caches/com.apple.xbs/Sources/MobileBluetooth_base/Stack/corestack/sdp/sdpserver.c",  862,  v49);
      }

      uint64_t v31 = *(unsigned __int16 *)(a3 + 12);
      if (*(_BYTE *)(a3 + 14) != 2)
      {
        uint64_t v49 = "(*responseBS).__RWFlag == BYTESTREAM_WRITE";
        goto LABEL_62;
      }

      *(_BYTE *)(*(void *)a3 + v31 + 3) = v59;
      *(_BYTE *)(*(void *)a3 + *(unsigned __int16 *)(a3 + 12) + 2LL) = BYTE1(v59);
      *(_BYTE *)(*(void *)a3 + *(unsigned __int16 *)(a3 + 12) + 1LL) = BYTE2(v59);
      *(_BYTE *)(*(void *)a3 + *(unsigned __int16 *)(a3 + 12)) = HIBYTE(v59);
      *(_WORD *)(a3 + 12) += 4;
      ++v26;
      unsigned int v25 = HIWORD(v58);
      char v30 = HIBYTE(v26);
    }
  }

  uint64_t v10 = v29;
  if ((_DWORD)v29 != 823) {
    goto LABEL_29;
  }
  char v30 = HIBYTE(v26);
  LOBYTE(v21) = v27;
LABEL_37:
  if (HIWORD(v58) > v25)
  {
    if (*(_BYTE *)(a3 + 15))
    {
      sub_1001ED1C4((uint64_t)"/Library/Caches/com.apple.xbs/Sources/MobileBluetooth_base/Stack/corestack/sdp/sdpserver.c");
    }

    else
    {
      uint64_t v41 = *(unsigned __int16 *)(a3 + 12);
      if (*(unsigned __int16 *)(a3 + 10) > v41)
      {
        if (*(_BYTE *)(a3 + 14) == 2)
        {
          uint64_t v42 = *(_BYTE **)a3;
          *(_WORD *)(a3 + 12) = v41 + 1;
          v42[v41] = 2;
          if (*(_BYTE *)(a3 + 15))
          {
            sub_1001ED1C4((uint64_t)"/Library/Caches/com.apple.xbs/Sources/MobileBluetooth_base/Stack/corestack/sdp/sdpserver.c");
          }

          else
          {
            uint64_t v43 = *(unsigned __int16 *)(a3 + 12);
            if (*(unsigned __int16 *)(a3 + 10) - (int)v43 > 1)
            {
              if (*(_BYTE *)(a3 + 14) == 2)
              {
                *(_BYTE *)(*(void *)a3 + v43 + 1) = v25;
                *(_BYTE *)(*(void *)a3 + *(unsigned __int16 *)(a3 + 12)) = BYTE1(v25);
                unsigned __int16 v44 = *(_WORD *)(a3 + 12) + 2;
                *(_WORD *)(a3 + 12) = v44;
                goto LABEL_49;
              }

              int v53 = "(*responseBS).__RWFlag == BYTESTREAM_WRITE";
LABEL_82:
              sub_1000E6B88( "/Library/Caches/com.apple.xbs/Sources/MobileBluetooth_base/Stack/corestack/sdp/sdpserver.c",  877,  v53);
            }
          }

          int v53 = "ByteStream_NumReadBytesAvail(*responseBS) >= 2";
          goto LABEL_82;
        }

        unsigned __int16 v52 = "(*responseBS).__RWFlag == BYTESTREAM_WRITE";
LABEL_78:
        sub_1000E6B88( "/Library/Caches/com.apple.xbs/Sources/MobileBluetooth_base/Stack/corestack/sdp/sdpserver.c",  876,  v52);
      }
    }

    unsigned __int16 v52 = "ByteStream_NumReadBytesAvail(*responseBS) >= 1";
    goto LABEL_78;
  }

  if (*(_BYTE *)(a3 + 15))
  {
    sub_1001ED1C4((uint64_t)"/Library/Caches/com.apple.xbs/Sources/MobileBluetooth_base/Stack/corestack/sdp/sdpserver.c");
    goto LABEL_84;
  }

  uint64_t v45 = *(unsigned __int16 *)(a3 + 12);
  if (*(unsigned __int16 *)(a3 + 10) <= v45)
  {
LABEL_84:
    unsigned __int16 v54 = "ByteStream_NumReadBytesAvail(*responseBS) >= 1";
    goto LABEL_86;
  }

  if (*(_BYTE *)(a3 + 14) != 2)
  {
    unsigned __int16 v54 = "(*responseBS).__RWFlag == BYTESTREAM_WRITE";
LABEL_86:
    sub_1000E6B88( "/Library/Caches/com.apple.xbs/Sources/MobileBluetooth_base/Stack/corestack/sdp/sdpserver.c",  879,  v54);
  }

  int v46 = *(_BYTE **)a3;
  *(_WORD *)(a3 + 12) = v45 + 1;
  v46[v45] = 0;
  unsigned __int16 v44 = *(_WORD *)(a3 + 12);
LABEL_49:
  unsigned int v47 = *(unsigned __int16 *)(a3 + 10);
  if (v56 > v47) {
    sub_1000E6B88( "/Library/Caches/com.apple.xbs/Sources/MobileBluetooth_base/Stack/corestack/sdp/sdpserver.c",  885,  "(size_t)(paramPos) <= (size_t)((*responseBS).__size)");
  }
  *(_WORD *)(a3 + 12) = v56;
  if (*(_BYTE *)(a3 + 15))
  {
    sub_1001ED1C4((uint64_t)"/Library/Caches/com.apple.xbs/Sources/MobileBluetooth_base/Stack/corestack/sdp/sdpserver.c");
    goto LABEL_67;
  }

  if ((int)(v47 - v56) <= 1)
  {
LABEL_67:
    int v50 = "ByteStream_NumReadBytesAvail(*responseBS) >= 2";
    goto LABEL_69;
  }

  if (*(_BYTE *)(a3 + 14) != 2)
  {
    int v50 = "(*responseBS).__RWFlag == BYTESTREAM_WRITE";
LABEL_69:
    sub_1000E6B88( "/Library/Caches/com.apple.xbs/Sources/MobileBluetooth_base/Stack/corestack/sdp/sdpserver.c",  886,  v50);
  }

  *(_BYTE *)(*(void *)a3 + v56 + 1) = v21;
  *(_BYTE *)(*(void *)a3 + *(unsigned __int16 *)(a3 + 12)) = HIBYTE(v27);
  unsigned __int16 v48 = *(_WORD *)(a3 + 12) + 2;
  *(_WORD *)(a3 + 12) = v48;
  if (*(_BYTE *)(a3 + 15))
  {
    sub_1001ED1C4((uint64_t)"/Library/Caches/com.apple.xbs/Sources/MobileBluetooth_base/Stack/corestack/sdp/sdpserver.c");
    goto LABEL_71;
  }

  if (*(unsigned __int16 *)(a3 + 10) - v48 <= 1)
  {
LABEL_71:
    unsigned int v51 = "ByteStream_NumReadBytesAvail(*responseBS) >= 2";
    goto LABEL_73;
  }

  if (*(_BYTE *)(a3 + 14) != 2)
  {
    unsigned int v51 = "(*responseBS).__RWFlag == BYTESTREAM_WRITE";
LABEL_73:
    sub_1000E6B88( "/Library/Caches/com.apple.xbs/Sources/MobileBluetooth_base/Stack/corestack/sdp/sdpserver.c",  887,  v51);
  }

  *(_BYTE *)(*(void *)a3 + v48 + 1LL) = v26;
  *(_BYTE *)(*(void *)a3 + *(unsigned __int16 *)(a3 + 12)) = v30;
  *(_WORD *)(a3 + 12) += 2;
  if (*(unsigned __int16 *)(a3 + 10) < v44) {
    sub_1000E6B88( "/Library/Caches/com.apple.xbs/Sources/MobileBluetooth_base/Stack/corestack/sdp/sdpserver.c",  888,  "(size_t)(contPos) <= (size_t)((*responseBS).__size)");
  }
  *(_WORD *)(a3 + 12) = v44;
  sub_1001E5558(a3, 3, a1);
  sub_10010C410((unsigned __int8 *)&v60);
  return 0LL;
}

uint64_t sub_1001E4C68(__int16 a1, uint64_t a2, uint64_t a3, __int16 a4, unsigned int a5)
{
  v33[0] = 0LL;
  v33[1] = 0LL;
  __int16 v31 = 0;
  if (*(_BYTE *)(a2 + 15))
  {
    sub_1001ED1C4((uint64_t)"/Library/Caches/com.apple.xbs/Sources/MobileBluetooth_base/Stack/corestack/sdp/sdpserver.c");
LABEL_4:
    uint64_t v10 = 804LL;
    goto LABEL_5;
  }

  uint64_t v8 = *(unsigned __int16 *)(a2 + 10);
  uint64_t v9 = *(unsigned __int16 *)(a2 + 12);
  if (*(_BYTE *)(a2 + 14) != 1) {
    sub_1000E6B88( "/Library/Caches/com.apple.xbs/Sources/MobileBluetooth_base/Stack/corestack/sdp/sdpserver.c",  1228,  "(*requestBS).__RWFlag == BYTESTREAM_READ");
  }
  if ((int)v8 - (int)v9 <= 3)
  {
    *(_BYTE *)(a2 + 15) = 1;
    sub_1001ED1C4((uint64_t)"/Library/Caches/com.apple.xbs/Sources/MobileBluetooth_base/Stack/corestack/sdp/sdpserver.c");
    goto LABEL_26;
  }

  unsigned int v20 = *(_DWORD *)(*(void *)a2 + v9);
  *(_WORD *)(a2 + 12) = v9 + 4;
  if ((int)(v8 - (unsigned __int16)(v9 + 4)) <= 1)
  {
LABEL_26:
    *(_BYTE *)(a2 + 15) = 1;
    goto LABEL_27;
  }

  unsigned int v21 = bswap32(*(unsigned __int16 *)(*(void *)a2 + (unsigned __int16)(v9 + 4))) >> 16;
  *(_WORD *)(a2 + 12) = v9 + 6;
  if (v21 < 7)
  {
LABEL_27:
    uint64_t v10 = 803LL;
    goto LABEL_5;
  }

  uint64_t v10 = sub_1001E5748((uint64_t *)a2, (uint64_t)v33);
  if ((_DWORD)v10) {
    goto LABEL_5;
  }
  __int16 v32 = 0;
  uint64_t v10 = sub_1001E5374((uint64_t *)a2, &v32);
  if ((_DWORD)v10) {
    goto LABEL_5;
  }
  unsigned __int16 v30 = 0;
  uint64_t v10 = sub_1001E57C4(a3, v21, a4, &v30);
  if ((_DWORD)v10) {
    goto LABEL_5;
  }
  uint64_t v24 = bswap32(v20);
  __int16 v25 = v32;
  if (!v32)
  {
    unsigned __int16 v29 = 0;
    uint64_t v28 = sub_1001E58A4(v24, (uint64_t)v33, &v29, a5);
    if ((_DWORD)v28)
    {
      uint64_t v10 = v28;
      goto LABEL_5;
    }

    sub_1001E5998((uint64_t *)a3, v29, &v32);
    __int16 v25 = v32;
  }

  __int16 v31 = v25;
  __int16 v26 = *(_WORD *)(a3 + 12);
  unsigned __int16 v27 = *(_WORD *)(a3 + 12) - v26 + v25;
  if (!v27)
  {
    sub_1001EE2A0();
LABEL_22:
    unsigned __int16 v27 = 0;
  }

  if (!v31)
  {
    sub_1001E5D14((uint64_t *)a3, v30, v27);
    sub_1001E5558(a3, 5, a1);
    sub_10010C410((unsigned __int8 *)v33);
    return 0LL;
  }

  uint64_t v10 = 805LL;
LABEL_5:
  if (sub_1000A86F0())
  {
    sub_1001EE134((uint64_t)"Error response to service attribute request: %!", v11, v12, v13, v14, v15, v16, v17, v10);
    __int16 v18 = (os_log_s *)sub_100086554(0x35u);
    if (os_log_type_enabled(v18, OS_LOG_TYPE_ERROR)) {
      sub_100657858();
    }
  }

  if (*(void *)a3) {
    sub_1000B1838(*(void **)a3);
  }
  sub_10010C410((unsigned __int8 *)v33);
  return sub_1001E4330(v10, a1, a3);
}

uint64_t sub_1001E4F14(__int16 a1, uint64_t a2, uint64_t a3, __int16 a4, unsigned int a5)
{
  v37[0] = 0LL;
  v37[1] = 0LL;
  uint64_t v35 = 0LL;
  uint64_t v36 = 0LL;
  int v34 = 0;
  uint64_t v31 = 0LL;
  sub_1001723A0(a5, &v31);
  uint64_t v10 = sub_1001E5308((uint64_t *)a2, (uint64_t)&v35);
  if ((_DWORD)v10) {
    goto LABEL_20;
  }
  if (*(_BYTE *)(a2 + 14) != 1) {
    sub_1000E6B88( "/Library/Caches/com.apple.xbs/Sources/MobileBluetooth_base/Stack/corestack/sdp/sdpserver.c",  1371,  "(*requestBS).__RWFlag == BYTESTREAM_READ");
  }
  if (*(_BYTE *)(a2 + 15))
  {
    sub_1001ED1C4((uint64_t)"/Library/Caches/com.apple.xbs/Sources/MobileBluetooth_base/Stack/corestack/sdp/sdpserver.c");
LABEL_18:
    *(_BYTE *)(a2 + 15) = 1;
    goto LABEL_19;
  }

  uint64_t v11 = *(unsigned __int16 *)(a2 + 12);
  unsigned int v12 = bswap32(*(unsigned __int16 *)(*(void *)a2 + v11)) >> 16;
  *(_WORD *)(a2 + 12) = v11 + 2;
  if (v12 < 7)
  {
LABEL_19:
    uint64_t v10 = 803LL;
    goto LABEL_20;
  }

  uint64_t v10 = sub_1001E5748((uint64_t *)a2, (uint64_t)v37);
  if (!(_DWORD)v10)
  {
    unsigned __int16 v33 = 0;
    uint64_t v10 = sub_1001E5374((uint64_t *)a2, &v33);
    if (!(_DWORD)v10)
    {
      unsigned __int16 v32 = 0;
      uint64_t v10 = sub_1001E57C4(a3, v12, a4, &v32);
      if (!(_DWORD)v10)
      {
        unsigned __int16 v13 = v33;
        if (!v33)
        {
          unsigned int v30 = 0;
          unsigned __int16 v29 = 0;
          HIWORD(v34) = 0;
          while (1)
          {
            uint64_t v27 = sub_1001E1780(v36, WORD1(v35), (_WORD *)&v34 + 1, &v30, v31);
            if ((_DWORD)v27) {
              break;
            }
            uint64_t v16 = sub_1001E58A4(v30, (uint64_t)v37, &v29, a5);
            if ((_DWORD)v16)
            {
LABEL_37:
              uint64_t v10 = v16;
              goto LABEL_20;
            }

            if (v29 <= 0xFFu) {
              __int16 v28 = 2;
            }
            else {
              __int16 v28 = 3;
            }
            v13 += v29 + v28;
          }

          uint64_t v10 = v27;
          if ((_DWORD)v27 != 823) {
            goto LABEL_20;
          }
          sub_1001E5998((uint64_t *)a3, v13, (__int16 *)&v33);
          unsigned __int16 v13 = v33;
        }

        int v34 = v13;
        __int16 v14 = *(_WORD *)(a3 + 12);
        do
        {
          unsigned int v30 = 0;
          unsigned __int16 v29 = 0;
          uint64_t v15 = sub_1001E1780(v36, WORD1(v35), (_WORD *)&v34 + 1, &v30, v31);
          if ((_DWORD)v15)
          {
            uint64_t v10 = v15;
            if ((_DWORD)v15 != 823) {
              goto LABEL_20;
            }
            goto LABEL_34;
          }

          uint64_t v16 = sub_1001E58A4(v30, (uint64_t)v37, &v29, a5);
          if ((_DWORD)v16) {
            goto LABEL_37;
          }
        }

        unsigned __int16 v17 = *(_WORD *)(a3 + 12) - v14 + v13;
        if (v17) {
          goto LABEL_35;
        }
        sub_1001EE2A0();
LABEL_34:
        unsigned __int16 v17 = 0;
LABEL_35:
        if (!(_WORD)v34)
        {
          sub_1001E5D14((uint64_t *)a3, v32, v17);
          sub_1001E5558(a3, 7, a1);
          sub_10010C410((unsigned __int8 *)&v35);
          sub_10010C410((unsigned __int8 *)v37);
          return 0LL;
        }

        uint64_t v10 = 805LL;
      }
    }
  }

void sub_1001E5250(uint64_t a1, void *ptr, uint64_t a3, int a4)
{
  uint64_t v6 = *(unsigned __int8 *)xmmword_1008EDCF8;
  if (*(_BYTE *)xmmword_1008EDCF8)
  {
    uint64_t v7 = (unsigned __int16 *)*((void *)&xmmword_1008EDCF8 + 1);
    while (!*((_BYTE *)v7 + 2) || *v7 != (_DWORD)a1)
    {
      v7 += 16;
      if (!--v6) {
        goto LABEL_6;
      }
    }
  }

  else
  {
LABEL_6:
    uint64_t v7 = 0LL;
  }

  sub_1000B1838(ptr);
  if (a4 || !v7)
  {
    if (!a4) {
      return;
    }
  }

  else
  {
    uint64_t v8 = (char *)*((void *)v7 + 2);
    if (!v8) {
      return;
    }
    if (!sub_100172DA0((uint64_t)sub_1001E5250, a1, 0LL, v8, v7[4]))
    {
      *((void *)v7 + 2) = 0LL;
      return;
    }
  }

  sub_1001E42E8(a1);
}

uint64_t sub_1001E5308(uint64_t *a1, uint64_t a2)
{
  uint64_t result = sub_10010C368(a1, (unsigned __int8 *)a2);
  if (!(_DWORD)result)
  {
    if (*(_BYTE *)a2 == 6)
    {
      uint64_t v4 = *(unsigned __int16 *)(a2 + 2);
      if ((v4 - 13) >= 0xFFFFFFF4)
      {
        uint64_t v5 = *(unsigned __int8 **)(a2 + 8);
        while (1)
        {
          int v6 = *v5;
          v5 += 16;
          if (v6 != 3) {
            break;
          }
          if (!--v4) {
            return 0LL;
          }
        }
      }
    }

    sub_10010C410((unsigned __int8 *)a2);
    return 803LL;
  }

  return result;
}

uint64_t sub_1001E5374(uint64_t *a1, _WORD *a2)
{
  *a2 = 0;
  if (*((_BYTE *)a1 + 14) != 1) {
    sub_1000E6B88( "/Library/Caches/com.apple.xbs/Sources/MobileBluetooth_base/Stack/corestack/sdp/sdpserver.c",  726,  "(*requestBS).__RWFlag == BYTESTREAM_READ");
  }
  if (*((_BYTE *)a1 + 15))
  {
    sub_1001ED1C4((uint64_t)"/Library/Caches/com.apple.xbs/Sources/MobileBluetooth_base/Stack/corestack/sdp/sdpserver.c");
LABEL_8:
    *((_BYTE *)a1 + 15) = 1;
    return 804LL;
  }

  unsigned int v3 = *((unsigned __int16 *)a1 + 5);
  uint64_t v4 = *((unsigned __int16 *)a1 + 6);
  uint64_t v5 = *a1;
  uint64_t v6 = v4 + 1;
  *((_WORD *)a1 + 6) = v4 + 1;
  if (!*(_BYTE *)(v5 + v4)
    || ((int v7 = v3 - (unsigned __int16)v6, v7 >= 2)
      ? (*a2 = bswap32(*(unsigned __int16 *)(v5 + v6)) >> 16,
         LOWORD(v6) = *((_WORD *)a1 + 6) + 2,
         *((_WORD *)a1 + 6) = v6)
      : (*((_BYTE *)a1 + 15) = 1),
        *a2 ? (uint64_t result = 804LL) : (uint64_t result = 805LL),
        *a2 && v7 >= 2))
  {
    else {
      return 804LL;
    }
  }

  return result;
}

uint64_t sub_1001E5470(uint64_t a1, __int16 a2)
{
  unsigned __int16 v3 = a2 + 8;
  uint64_t v4 = sub_1000B17F4((unsigned __int16)(a2 + 8));
  if (v4)
  {
    if (!v3) {
      sub_1000E6B88( "/Library/Caches/com.apple.xbs/Sources/MobileBluetooth_base/Stack/corestack/sdp/sdpserver.c",  607,  "(allocSize) > 0");
    }
    *(void *)a1 = v4;
    *(_WORD *)(a1 + 8) = v3;
    *(_DWORD *)(a1 + 12) = 0x20000;
    *(_WORD *)(a1 + 10) = v3;
    if (v3 <= 4u) {
      sub_1000E6B88( "/Library/Caches/com.apple.xbs/Sources/MobileBluetooth_base/Stack/corestack/sdp/sdpserver.c",  612,  "ByteStream_NumReadBytesAvail(*responseBS) >= (5)");
    }
    uint64_t result = 0LL;
    *(_WORD *)(a1 + 12) = 5;
  }

  else
  {
    if (sub_1000A86F0())
    {
      sub_1001EE134((uint64_t)"CreateResponsePDU, OI_Malloc (%d) failed", v6, v7, v8, v9, v10, v11, v12, v3);
      unsigned __int16 v13 = (os_log_s *)sub_100086554(0x35u);
      if (os_log_type_enabled(v13, OS_LOG_TYPE_ERROR)) {
        sub_100657858();
      }
    }

    return 806LL;
  }

  return result;
}

uint64_t sub_1001E5558(uint64_t result, char a2, __int16 a3)
{
  unsigned int v3 = *(unsigned __int16 *)(result + 12);
  *(_WORD *)(result + 12) = 0;
  if (*(_BYTE *)(result + 15))
  {
    sub_1001ED1C4((uint64_t)"/Library/Caches/com.apple.xbs/Sources/MobileBluetooth_base/Stack/corestack/sdp/sdpserver.c");
    goto LABEL_15;
  }

  if (!*(_WORD *)(result + 10))
  {
LABEL_15:
    uint64_t v7 = "ByteStream_NumReadBytesAvail(*responseBS) >= 1";
    goto LABEL_17;
  }

  if (*(_BYTE *)(result + 14) != 2)
  {
    uint64_t v7 = "(*responseBS).__RWFlag == BYTESTREAM_WRITE";
LABEL_17:
    sub_1000E6B88("/Library/Caches/com.apple.xbs/Sources/MobileBluetooth_base/Stack/corestack/sdp/sdpserver.c", 568, v7);
  }

  uint64_t v4 = *(_BYTE **)result;
  *(_WORD *)(result + 12) = 1;
  *uint64_t v4 = a2;
  if (*(_BYTE *)(result + 15))
  {
    sub_1001ED1C4((uint64_t)"/Library/Caches/com.apple.xbs/Sources/MobileBluetooth_base/Stack/corestack/sdp/sdpserver.c");
    goto LABEL_19;
  }

  uint64_t v5 = *(unsigned __int16 *)(result + 12);
  if (*(unsigned __int16 *)(result + 10) - (int)v5 <= 1)
  {
LABEL_19:
    uint64_t v8 = "ByteStream_NumReadBytesAvail(*responseBS) >= 2";
    goto LABEL_21;
  }

  if (*(_BYTE *)(result + 14) != 2)
  {
    uint64_t v8 = "(*responseBS).__RWFlag == BYTESTREAM_WRITE";
LABEL_21:
    sub_1000E6B88("/Library/Caches/com.apple.xbs/Sources/MobileBluetooth_base/Stack/corestack/sdp/sdpserver.c", 569, v8);
  }

  *(_BYTE *)(*(void *)result + v5 + 1) = a3;
  *(_BYTE *)(*(void *)result + *(unsigned __int16 *)(result + 12)) = HIBYTE(a3);
  unsigned __int16 v6 = *(_WORD *)(result + 12) + 2;
  *(_WORD *)(result + 12) = v6;
  if (*(_BYTE *)(result + 15))
  {
    sub_1001ED1C4((uint64_t)"/Library/Caches/com.apple.xbs/Sources/MobileBluetooth_base/Stack/corestack/sdp/sdpserver.c");
    goto LABEL_23;
  }

  if (*(unsigned __int16 *)(result + 10) - v6 <= 1)
  {
LABEL_23:
    uint64_t v9 = "ByteStream_NumReadBytesAvail(*responseBS) >= 2";
    goto LABEL_25;
  }

  if (*(_BYTE *)(result + 14) != 2)
  {
    uint64_t v9 = "(*responseBS).__RWFlag == BYTESTREAM_WRITE";
LABEL_25:
    sub_1000E6B88("/Library/Caches/com.apple.xbs/Sources/MobileBluetooth_base/Stack/corestack/sdp/sdpserver.c", 570, v9);
  }

  *(_BYTE *)(*(void *)result + v6 + 1LL) = v3 - 5;
  *(_BYTE *)(*(void *)result + *(unsigned __int16 *)(result + 12)) = (unsigned __int16)(v3 - 5) >> 8;
  *(_WORD *)(result + 12) += 2;
  if (v3 > *(unsigned __int16 *)(result + 10)) {
    sub_1000E6B88( "/Library/Caches/com.apple.xbs/Sources/MobileBluetooth_base/Stack/corestack/sdp/sdpserver.c",  575,  "(size_t)(pos) <= (size_t)((*responseBS).__size)");
  }
  *(_WORD *)(result + 12) = v3;
  if (*(_BYTE *)(result + 14) == 2) {
    *(_WORD *)(result + 10) = v3;
  }
  *(_BYTE *)(result + 14) = 15;
  return result;
}

uint64_t sub_1001E5748(uint64_t *a1, uint64_t a2)
{
  uint64_t result = sub_10010C368(a1, (unsigned __int8 *)a2);
  if (!(_DWORD)result)
  {
    if (*(_BYTE *)a2 == 6)
    {
      uint64_t v4 = *(unsigned __int16 *)(a2 + 2);
      if (*(_WORD *)(a2 + 2))
      {
        for (unint64_t i = (unsigned __int16 *)(*(void *)(a2 + 8) + 2LL); *((_BYTE *)i - 2) == 1; i += 8)
        {
          int v6 = *i;
          if (v6 != 4 && v6 != 2) {
            break;
          }
          if (!--v4) {
            return 0LL;
          }
        }
      }
    }

    sub_10010C410((unsigned __int8 *)a2);
    return 803LL;
  }

  return result;
}

uint64_t sub_1001E57C4(uint64_t a1, unsigned int a2, __int16 a3, _WORD *a4)
{
  unsigned int v6 = (unsigned __int16)(a3 - 8);
  if (v6 >= a2) {
    unsigned int v6 = a2;
  }
  else {
    __int16 v7 = v6;
  }
  uint64_t result = sub_1001E5470(a1, v7);
  if (!(_DWORD)result)
  {
    if (*(_BYTE *)(a1 + 15))
    {
      sub_1001ED1C4((uint64_t)"/Library/Caches/com.apple.xbs/Sources/MobileBluetooth_base/Stack/corestack/sdp/sdpserver.c");
    }

    else
    {
      uint64_t v9 = *(unsigned __int16 *)(a1 + 12);
      if ((unint64_t)*(unsigned __int16 *)(a1 + 10) - v9 > 1)
      {
        __int16 v10 = v9 + 2;
        *(_WORD *)(a1 + 12) = v10;
        *a4 = v10;
        unint64_t v11 = *(unsigned __int16 *)(a1 + 10) - 3LL;
        if (v11 > *(unsigned __int16 *)(a1 + 8) || v11 < *(unsigned __int16 *)(a1 + 12)) {
          sub_1000E6B88( "/Library/Caches/com.apple.xbs/Sources/MobileBluetooth_base/Stack/corestack/sdp/sdpserver.c",  1085,  "((size - (sizeof(uint8_t) + sizeof(uint16_t))) <= (*responseBS).__trueSize) && ((size - (sizeof(uint8_t) + s izeof(uint16_t))) >= (*responseBS).__pos)");
        }
        *(_WORD *)(a1 + 10) = v11;
        return result;
      }
    }

    sub_1000E6B88( "/Library/Caches/com.apple.xbs/Sources/MobileBluetooth_base/Stack/corestack/sdp/sdpserver.c",  1075,  "ByteStream_NumReadBytesAvail(*responseBS) >= (sizeof(uint16_t))");
  }

  return result;
}

uint64_t sub_1001E58A4(uint64_t a1, uint64_t a2, _WORD *a3, unsigned int a4)
{
  uint64_t v21 = 0LL;
  unsigned __int16 v20 = 0;
  *a3 = 0;
  uint64_t v19 = 0LL;
  sub_1001723A0(a4, &v19);
  while (1)
  {
    uint64_t v7 = sub_1001E247C(a1, *(void *)(a2 + 8), *(unsigned __int16 *)(a2 + 2), &v20, (__int16 **)&v21, v19);
    if ((_DWORD)v7) {
      break;
    }
    int v8 = sub_10010AE3C(v21 + 8);
    if (!v8) {
      return 106LL;
    }
    *a3 += v8 + 3;
  }

  uint64_t v9 = v7;
  if ((_DWORD)v7 == 826) {
    return 0LL;
  }
  if (sub_1000A86F0())
  {
    sub_1001EE134((uint64_t)"Internal SDP error AttributeSearch returned %!", v10, v11, v12, v13, v14, v15, v16, v9);
    unsigned __int16 v17 = (os_log_s *)sub_100086554(0x35u);
    if (os_log_type_enabled(v17, OS_LOG_TYPE_ERROR)) {
      sub_100657858();
    }
  }

  return v9;
}

uint64_t sub_1001E5998(uint64_t *a1, unsigned int a2, __int16 *a3)
{
  uint64_t v3 = *((unsigned __int16 *)a1 + 6);
  int v4 = *((unsigned __int16 *)a1 + 5) - (_DWORD)v3;
  __int16 v5 = *a3;
  if (a2 < 0x100)
  {
    if (*a3)
    {
      __int16 v6 = v5 - 2;
      goto LABEL_6;
    }

    if ((v4 & 0xFFFE) == 0) {
      return 0LL;
    }
    if (*((_BYTE *)a1 + 15))
    {
      sub_1001ED1C4((uint64_t)"/Library/Caches/com.apple.xbs/Sources/MobileBluetooth_base/Stack/corestack/sdp/sdpserver.c");
    }

    else if (v4 > 0)
    {
      if (*((_BYTE *)a1 + 14) == 2)
      {
        uint64_t v10 = *a1;
        *((_WORD *)a1 + 6) = v3 + 1;
        *(_BYTE *)(v10 + v3) = 53;
        if (*((_BYTE *)a1 + 15))
        {
          sub_1001ED1C4((uint64_t)"/Library/Caches/com.apple.xbs/Sources/MobileBluetooth_base/Stack/corestack/sdp/sdpserver.c");
        }

        else
        {
          uint64_t v11 = *((unsigned __int16 *)a1 + 6);
          if (*((unsigned __int16 *)a1 + 5) > v11)
          {
            if (*((_BYTE *)a1 + 14) == 2)
            {
              uint64_t v12 = *a1;
              *((_WORD *)a1 + 6) = v11 + 1;
              *(_BYTE *)(v12 + v11) = a2;
              return 1LL;
            }

            uint64_t v14 = "(*responseBS).__RWFlag == BYTESTREAM_WRITE";
LABEL_33:
            sub_1000E6B88( "/Library/Caches/com.apple.xbs/Sources/MobileBluetooth_base/Stack/corestack/sdp/sdpserver.c",  1125,  v14);
          }
        }

        uint64_t v14 = "ByteStream_NumReadBytesAvail(*responseBS) >= 1";
        goto LABEL_33;
      }

      uint64_t v13 = "(*responseBS).__RWFlag == BYTESTREAM_WRITE";
LABEL_29:
      sub_1000E6B88( "/Library/Caches/com.apple.xbs/Sources/MobileBluetooth_base/Stack/corestack/sdp/sdpserver.c",  1124,  v13);
    }

    uint64_t v13 = "ByteStream_NumReadBytesAvail(*responseBS) >= 1";
    goto LABEL_29;
  }

  if (!*a3)
  {
    if ((unsigned __int16)(*((_WORD *)a1 + 5) - v3) >= 3u)
    {
      if (*((_BYTE *)a1 + 15))
      {
        sub_1001ED1C4((uint64_t)"/Library/Caches/com.apple.xbs/Sources/MobileBluetooth_base/Stack/corestack/sdp/sdpserver.c");
      }

      else if (v4 > 0)
      {
        if (*((_BYTE *)a1 + 14) == 2)
        {
          uint64_t v8 = *a1;
          *((_WORD *)a1 + 6) = v3 + 1;
          *(_BYTE *)(v8 + v3) = 54;
          if (*((_BYTE *)a1 + 15))
          {
            sub_1001ED1C4((uint64_t)"/Library/Caches/com.apple.xbs/Sources/MobileBluetooth_base/Stack/corestack/sdp/sdpserver.c");
          }

          else
          {
            uint64_t v9 = *((unsigned __int16 *)a1 + 6);
            if (*((unsigned __int16 *)a1 + 5) - (int)v9 > 1)
            {
              if (*((_BYTE *)a1 + 14) == 2)
              {
                *(_BYTE *)(*a1 + v9 + 1) = a2;
                *(_BYTE *)(*a1 + *((unsigned __int16 *)a1 + 6)) = BYTE1(a2);
                *((_WORD *)a1 + 6) += 2;
                return 1LL;
              }

              uint64_t v16 = "(*responseBS).__RWFlag == BYTESTREAM_WRITE";
LABEL_41:
              sub_1000E6B88( "/Library/Caches/com.apple.xbs/Sources/MobileBluetooth_base/Stack/corestack/sdp/sdpserver.c",  1115,  v16);
            }
          }

          uint64_t v16 = "ByteStream_NumReadBytesAvail(*responseBS) >= 2";
          goto LABEL_41;
        }

        uint64_t v15 = "(*responseBS).__RWFlag == BYTESTREAM_WRITE";
LABEL_37:
        sub_1000E6B88( "/Library/Caches/com.apple.xbs/Sources/MobileBluetooth_base/Stack/corestack/sdp/sdpserver.c",  1114,  v15);
      }

      uint64_t v15 = "ByteStream_NumReadBytesAvail(*responseBS) >= 1";
      goto LABEL_37;
    }

    return 0LL;
  }

  __int16 v6 = v5 - 3;
LABEL_6:
  *a3 = v6;
  return 1LL;
}

uint64_t sub_1001E5BF4(uint64_t a1, uint64_t a2, _WORD *a3, uint64_t a4, unsigned int a5)
{
  uint64_t v23 = 0LL;
  __int128 v22 = xmmword_1006BE080;
  unsigned __int16 v21 = 0;
  uint64_t v20 = 0LL;
  sub_1001723A0(a5, &v20);
  while (1)
  {
    uint64_t v9 = sub_1001E247C(a1, *(void *)(a2 + 8), *(unsigned __int16 *)(a2 + 2), &v21, (__int16 **)&v23, v20);
    if ((_DWORD)v9) {
      break;
    }
    DWORD2(vmemset(v6, 0, 22) = *(unsigned __int16 *)v23;
    uint64_t result = sub_10010B0E0(a4, a3, (unsigned __int8 *)&v22);
    if (!(_DWORD)result) {
      return result;
    }
    if (!sub_10010B0E0(a4, a3, v23 + 8)) {
      return 0LL;
    }
  }

  uint64_t v11 = v9;
  if ((_DWORD)v9 == 826) {
    return 1LL;
  }
  uint64_t result = sub_1000A86F0();
  if ((_DWORD)result)
  {
    sub_1001EE134((uint64_t)"Internal SDP error AttributeSearch returned %!", v12, v13, v14, v15, v16, v17, v18, v11);
    uint64_t v19 = (os_log_s *)sub_100086554(0x35u);
    uint64_t result = os_log_type_enabled(v19, OS_LOG_TYPE_ERROR);
    if ((_DWORD)result)
    {
      sub_100657858();
      return 0LL;
    }
  }

  return result;
}

uint64_t *sub_1001E5D14(uint64_t *result, unsigned int a2, int a3)
{
  unint64_t v3 = a2 - 2LL;
  unint64_t v4 = *((unsigned __int16 *)result + 5);
  if (v3 > v4) {
    sub_1000E6B88( "/Library/Caches/com.apple.xbs/Sources/MobileBluetooth_base/Stack/corestack/sdp/sdpserver.c",  1162,  "(size_t)(attrBytesPos - sizeof(uint16_t)) <= (size_t)((*responseBS).__size)");
  }
  uint64_t v5 = *((unsigned __int16 *)result + 6);
  *((_WORD *)result + 6) = v3;
  if (*((_BYTE *)result + 15))
  {
    sub_1001ED1C4((uint64_t)"/Library/Caches/com.apple.xbs/Sources/MobileBluetooth_base/Stack/corestack/sdp/sdpserver.c");
    goto LABEL_22;
  }

  if ((int)(v4 - (unsigned __int16)v3) <= 1)
  {
LABEL_22:
    uint64_t v11 = "ByteStream_NumReadBytesAvail(*responseBS) >= 2";
    goto LABEL_24;
  }

  if (*((_BYTE *)result + 14) != 2)
  {
    uint64_t v11 = "(*responseBS).__RWFlag == BYTESTREAM_WRITE";
LABEL_24:
    sub_1000E6B88( "/Library/Caches/com.apple.xbs/Sources/MobileBluetooth_base/Stack/corestack/sdp/sdpserver.c",  1163,  v11);
  }

  *(_BYTE *)(*result + (unsigned __int16)v3 + 1) = v5 - a2;
  *(_BYTE *)(*result + *((unsigned __int16 *)result + 6)) = (unsigned __int16)(v5 - a2) >> 8;
  *((_WORD *)result + 6) += 2;
  uint64_t v6 = *((unsigned __int16 *)result + 5);
  if (v5 > v6) {
    sub_1000E6B88( "/Library/Caches/com.apple.xbs/Sources/MobileBluetooth_base/Stack/corestack/sdp/sdpserver.c",  1167,  "(size_t)(attrEndPos) <= (size_t)((*responseBS).__size)");
  }
  *((_WORD *)result + 6) = v5;
  unint64_t v7 = v6 + 3;
  if (v7 > *((unsigned __int16 *)result + 4)) {
    sub_1000E6B88( "/Library/Caches/com.apple.xbs/Sources/MobileBluetooth_base/Stack/corestack/sdp/sdpserver.c",  1172,  "((size + (sizeof(uint8_t) + sizeof(uint16_t))) <= (*responseBS).__trueSize) && ((size + (sizeof(uint8_t) + sizeof( uint16_t))) >= (*responseBS).__pos)");
  }
  *((_WORD *)result + 5) = v7;
  if (a3)
  {
    if (*((_BYTE *)result + 15))
    {
      sub_1001ED1C4((uint64_t)"/Library/Caches/com.apple.xbs/Sources/MobileBluetooth_base/Stack/corestack/sdp/sdpserver.c");
    }

    else if (v5 < (unsigned __int16)v7)
    {
      if (*((_BYTE *)result + 14) == 2)
      {
        uint64_t v8 = *result;
        *((_WORD *)result + 6) = v5 + 1;
        *(_BYTE *)(v8 + v5) = 2;
        if (*((_BYTE *)result + 15))
        {
          sub_1001ED1C4((uint64_t)"/Library/Caches/com.apple.xbs/Sources/MobileBluetooth_base/Stack/corestack/sdp/sdpserver.c");
        }

        else
        {
          uint64_t v9 = *((unsigned __int16 *)result + 6);
          if (*((unsigned __int16 *)result + 5) - (int)v9 > 1)
          {
            if (*((_BYTE *)result + 14) == 2)
            {
              *(_BYTE *)(*result + v9 + 1) = a3;
              *(_BYTE *)(*result + *((unsigned __int16 *)result + 6)) = BYTE1(a3);
              *((_WORD *)result + 6) += 2;
              return result;
            }

            uint64_t v13 = "(*responseBS).__RWFlag == BYTESTREAM_WRITE";
LABEL_34:
            sub_1000E6B88( "/Library/Caches/com.apple.xbs/Sources/MobileBluetooth_base/Stack/corestack/sdp/sdpserver.c",  1178,  v13);
          }
        }

        uint64_t v13 = "ByteStream_NumReadBytesAvail(*responseBS) >= 2";
        goto LABEL_34;
      }

      uint64_t v12 = "(*responseBS).__RWFlag == BYTESTREAM_WRITE";
LABEL_30:
      sub_1000E6B88( "/Library/Caches/com.apple.xbs/Sources/MobileBluetooth_base/Stack/corestack/sdp/sdpserver.c",  1177,  v12);
    }

    uint64_t v12 = "ByteStream_NumReadBytesAvail(*responseBS) >= 1";
    goto LABEL_30;
  }

  if (*((_BYTE *)result + 15))
  {
    sub_1001ED1C4((uint64_t)"/Library/Caches/com.apple.xbs/Sources/MobileBluetooth_base/Stack/corestack/sdp/sdpserver.c");
    goto LABEL_36;
  }

  if (v5 >= (unsigned __int16)v7)
  {
LABEL_36:
    uint64_t v14 = "ByteStream_NumReadBytesAvail(*responseBS) >= 1";
    goto LABEL_38;
  }

  if (*((_BYTE *)result + 14) != 2)
  {
    uint64_t v14 = "(*responseBS).__RWFlag == BYTESTREAM_WRITE";
LABEL_38:
    sub_1000E6B88( "/Library/Caches/com.apple.xbs/Sources/MobileBluetooth_base/Stack/corestack/sdp/sdpserver.c",  1180,  v14);
  }

  uint64_t v10 = *result;
  *((_WORD *)result + 6) = v5 + 1;
  *(_BYTE *)(v10 + v5) = 0;
  return result;
}

void sub_1001E5FB8(uint64_t a1)
{
  if ((_DWORD)a1 && sub_1000A86F0())
  {
    sub_1001EE134((uint64_t)"Write Secure Connection failed %!", v2, v3, v4, v5, v6, v7, v8, a1);
    uint64_t v9 = (os_log_s *)sub_100086554(0x37u);
    if (os_log_type_enabled(v9, OS_LOG_TYPE_ERROR)) {
      sub_100657F74();
    }
  }

uint64_t sub_1001E6024()
{
  if (HIDWORD(xmmword_1008F6FD8)) {
    return 140LL;
  }
  uint64_t v1 = (unsigned __int8 *)sub_1001EDBA0(0x28u);
  uint64_t v2 = sub_1000B1814(16LL * *v1);
  qword_1008EDD18 = (uint64_t)v2;
  if (v2) {
    uint64_t v0 = 0LL;
  }
  else {
    uint64_t v0 = 106LL;
  }
  if (v2)
  {
    word_1008EDDA0 = 0;
    qword_1008EDD28 = 0LL;
    qword_1008EDD80 = 0LL;
    off_1008EDD98 = 0LL;
    dword_1008EDD70 = 3;
    DWORD2(xmmword_1008EDD48) = 6;
    dword_1008EDD24 = 0;
    byte_1008EDD21 = 0;
    HIDWORD(xmmword_1008F6FD8) = 1;
  }

  byte_1008F6ED8 = 0;
  return v0;
}

uint64_t sub_1001E6110(uint64_t a1, BOOL *a2)
{
  uint64_t v22 = 0LL;
  if (a1 && a2)
  {
    uint64_t v3 = sub_10010EEE0(a1, &v22);
    if ((_DWORD)v3)
    {
      if (sub_1000A86F0())
      {
        sub_1001EE134((uint64_t)"OI_SECMGR_RemoteSupportSSP: invalid address", v4, v5, v6, v7, v8, v9, v10, v21);
        uint64_t v11 = (os_log_s *)sub_100086554(0x37u);
        if (os_log_type_enabled(v11, OS_LOG_TYPE_ERROR)) {
          sub_100657F74();
        }
      }
    }

    else
    {
      *a2 = *(_BYTE *)(v22 + 277) != 0;
    }
  }

  else
  {
    if (sub_1000A86F0())
    {
      sub_1001EE134((uint64_t)"OI_SECMGR_RemoteSupportSSP: invalid parameters", v12, v13, v14, v15, v16, v17, v18, v21);
      uint64_t v19 = (os_log_s *)sub_100086554(0x37u);
      if (os_log_type_enabled(v19, OS_LOG_TYPE_ERROR)) {
        sub_100657F74();
      }
    }

    return 101LL;
  }

  return v3;
}

uint64_t sub_1001E61F0(uint64_t a1, __int16 a2)
{
  uint64_t v3 = sub_10012D890(a1);
  if (v3)
  {
    *(_WORD *)(v3 + 274) = 10 * a2;
    sub_10010C890(v3);
    return 0LL;
  }

  else
  {
    if (sub_1000A86F0())
    {
      sub_1001EE134((uint64_t)"Invalid connection", v5, v6, v7, v8, v9, v10, v11, v13);
      uint64_t v12 = (os_log_s *)sub_100086554(0x37u);
      if (os_log_type_enabled(v12, OS_LOG_TYPE_ERROR)) {
        sub_100657858();
      }
    }

    return 122LL;
  }

uint64_t sub_1001E6270(uint64_t a1, char a2)
{
  if (!a1) {
    return 101LL;
  }
  uint64_t v3 = sub_10012D890(a1);
  if (v3 && (uint64_t v4 = (unsigned __int16)word_1008EDDA0, word_1008EDDA0))
  {
    uint64_t v5 = qword_1008EDD18;
    while (*(void *)v5 != v3)
    {
      v5 += 16LL;
      if (!--v4) {
        goto LABEL_7;
      }
    }

    uint64_t result = 0LL;
    *(_BYTE *)(v5 + 13) = a2;
  }

  else
  {
LABEL_7:
    if (sub_1000A86F0())
    {
      sub_1001EE134((uint64_t)"Device is no longer connected", v6, v7, v8, v9, v10, v11, v12, v15);
      uint64_t v13 = (os_log_s *)sub_100086554(0x37u);
      if (os_log_type_enabled(v13, OS_LOG_TYPE_ERROR)) {
        sub_100657858();
      }
    }

    return 122LL;
  }

  return result;
}

uint64_t sub_1001E631C(uint64_t a1)
{
  if (a1 && (uint64_t v1 = (unsigned __int16)word_1008EDDA0, word_1008EDDA0))
  {
    uint64_t v2 = qword_1008EDD18;
    while (*(void *)v2 != a1)
    {
      v2 += 16LL;
      if (!--v1) {
        goto LABEL_6;
      }
    }

    return *(_BYTE *)(v2 + 13) != 0;
  }

  else
  {
LABEL_6:
    uint64_t result = sub_1000A86F0();
    if ((_DWORD)result)
    {
      sub_1001EE134((uint64_t)"Device is no longer connected", v4, v5, v6, v7, v8, v9, v10, v12);
      uint64_t v11 = (os_log_s *)sub_100086554(0x37u);
      uint64_t result = os_log_type_enabled(v11, OS_LOG_TYPE_ERROR);
      if ((_DWORD)result)
      {
        sub_100657858();
        return 0LL;
      }
    }
  }

  return result;
}

uint64_t sub_1001E63B4(uint64_t result)
{
  byte_1008EDD21 = result;
  return result;
}

uint64_t sub_1001E63C0( uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  if (a1)
  {
    uint64_t v8 = sub_1001214B4(119, a1, a3, a4, a5, a6, a7, a8, v18);
    if ((_DWORD)v8)
    {
      if (sub_1000A86F0())
      {
        sub_1001EE134((uint64_t)"OI_HCICMD_ReadLocalOOBData %!", v9, v10, v11, v12, v13, v14, v15, v8);
        uint64_t v16 = (os_log_s *)sub_100086554(0x37u);
        if (os_log_type_enabled(v16, OS_LOG_TYPE_ERROR)) {
          sub_100657F74();
        }
      }
    }
  }

  else
  {
    sub_1001EE2A0();
    return 101LL;
  }

  return v8;
}

uint64_t sub_1001E6448( uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  if (a1)
  {
    uint64_t v8 = sub_1001214B4(132, a1, a3, a4, a5, a6, a7, a8, v18);
    if ((_DWORD)v8)
    {
      if (sub_1000A86F0())
      {
        sub_1001EE134((uint64_t)"OI_HCICMD_ReadLocalOOBExtendedData %!", v9, v10, v11, v12, v13, v14, v15, v8);
        uint64_t v16 = (os_log_s *)sub_100086554(0x37u);
        if (os_log_type_enabled(v16, OS_LOG_TYPE_ERROR)) {
          sub_100657F74();
        }
      }
    }
  }

  else
  {
    sub_1001EE2A0();
    return 101LL;
  }

  return v8;
}

uint64_t sub_1001E64D0(uint64_t a1)
{
  uint64_t v1 = (unsigned __int16)word_1008EDDA0;
  if (word_1008EDDA0)
  {
    uint64_t v2 = (_DWORD *)(qword_1008EDD18 + 8);
    while (*((void *)v2 - 1) != a1)
    {
      v2 += 4;
      if (!--v1) {
        goto LABEL_5;
      }
    }

    return *v2 == 2;
  }

  else
  {
LABEL_5:
    uint64_t result = sub_1000A86F0();
    if ((_DWORD)result)
    {
      sub_1001EE134((uint64_t)"OI_SECMGR_ConnectionIsEncrypted %!", v4, v5, v6, v7, v8, v9, v10, 122LL);
      uint64_t v11 = (os_log_s *)sub_100086554(0x37u);
      uint64_t result = os_log_type_enabled(v11, OS_LOG_TYPE_ERROR);
      if ((_DWORD)result)
      {
        sub_100657F74();
        return 0LL;
      }
    }
  }

  return result;
}

uint64_t sub_1001E6578(uint64_t a1, _BYTE *a2)
{
  int v7 = 0;
  *a2 = 0;
  uint64_t v3 = a1 + 48;
  if ((sub_1001C3170(a1 + 48, (uint64_t)v6) & 1) != 0
    || (uint64_t result = (*(uint64_t (**)(uint64_t, void *))(qword_1008EDD28 + 32))(v3, v6), (_DWORD)result))
  {
    uint64_t result = 1LL;
    if (v7 == 8 || v7 == 5) {
      *a2 = 1;
    }
  }

  return result;
}

BOOL sub_1001E6620(uint64_t a1)
{
  return *(_DWORD *)(a1 + 48) == dword_1008EDD30 && *(unsigned __int16 *)(a1 + 52) == (unsigned __int16)word_1008EDD34;
}

void sub_1001E6660(uint64_t (*a1)(void, void, void))
{
  if (!a1) {
    sub_1001EE2A0();
  }
  off_1008EDD78 = a1;
}

uint64_t sub_1001E668C(uint64_t a1, uint64_t a2, uint64_t a3, uint8x8_t a4)
{
  int v28 = 0;
  if (HIDWORD(xmmword_1008F6FD8)) {
    BOOL v4 = dword_1008EDD24 == 0;
  }
  else {
    BOOL v4 = 1;
  }
  if (v4)
  {
    uint64_t result = sub_1000A86F0();
    if ((_DWORD)result)
    {
      sub_1001EE134((uint64_t)"!SECMGR_IS_INITIALIZED", v6, v7, v8, v9, v10, v11, v12, v26);
      uint64_t v13 = (os_log_s *)sub_100086554(0x37u);
      uint64_t result = os_log_type_enabled(v13, OS_LOG_TYPE_ERROR);
      if ((_DWORD)result)
      {
        sub_100657F74();
        return 0LL;
      }
    }
  }

  else
  {
    if (!qword_1008EDD80
      || (*(void *)(qword_1008EDD80 + 8) ? (BOOL v17 = qword_1008EDD28 == 0) : (BOOL v17 = 1),
          v17 || !*(void *)(qword_1008EDD28 + 32)))
    {
      sub_1001EE2A0();
    }

    a4.i32[0] = dword_1008EDD30;
    else {
      BOOL v18 = word_1008EDD34 == 0;
    }
    if (v18 && HIBYTE(word_1008EDD34) == 0) {
      return 0LL;
    }
    int v20 = (*(uint64_t (**)(uint64_t, uint64_t, int *))(qword_1008EDD80 + 8))(a2, a3, &dword_1008EDD30);
    uint64_t v21 = (unsigned __int16)word_1008EDDA0;
    if (word_1008EDDA0)
    {
      uint64_t v22 = qword_1008EDD18;
      while (1)
      {
        BOOL v23 = *(void *)v22 != a1;
        if (*(void *)v22 == a1) {
          break;
        }
        v22 += 16LL;
        if (!--v21)
        {
          uint64_t v22 = 0LL;
          break;
        }
      }
    }

    else
    {
      uint64_t v22 = 0LL;
      BOOL v23 = 1;
    }

    else {
      char v24 = (*(uint64_t (**)(int *, void *))(qword_1008EDD28 + 32))(&dword_1008EDD30, v27);
    }
    uint64_t result = v20 != 0;
    if (v20) {
      char v25 = v23;
    }
    else {
      char v25 = 1;
    }
    if ((v25 & 1) == 0)
    {
      if (*(_DWORD *)(v22 + 8) == 2)
      {
        if (v28 != 5) {
          char v24 = 0;
        }
        if ((v24 & 1) != 0) {
          return 0LL;
        }
      }

      return 1LL;
    }
  }

  return result;
}

uint64_t sub_1001E6890(uint64_t result)
{
  byte_1008EDD20 = result;
  return result;
}

uint64_t sub_1001E689C(void *a1)
{
  if (!a1)
  {
    sub_1001EE2A0();
    return 101LL;
  }

  if (!*a1)
  {
    sub_1001EE2A0();
    if (!*a1) {
      return 101LL;
    }
  }

  if (!a1[1])
  {
    sub_1001EE2A0();
    if (!a1[1]) {
      return 101LL;
    }
  }

  if (!a1[2])
  {
    sub_1001EE2A0();
    if (!a1[2]) {
      return 101LL;
    }
  }

  if (!a1[3])
  {
    sub_1001EE2A0();
    if (!a1[3]) {
      return 101LL;
    }
  }

  if (!a1[4])
  {
    sub_1001EE2A0();
    if (!a1[4]) {
      return 101LL;
    }
  }

  if (!a1[5])
  {
    sub_1001EE2A0();
    if (!a1[5]) {
      return 101LL;
    }
  }

  if (!a1[6])
  {
    sub_1001EE2A0();
    if (!a1[6]) {
      return 101LL;
    }
  }

  if (!a1[7])
  {
    sub_1001EE2A0();
    if (!a1[7]) {
      return 101LL;
    }
  }

  if (!a1[8])
  {
    sub_1001EE2A0();
    if (!a1[8]) {
      return 101LL;
    }
  }

  if (!a1[9])
  {
    sub_1001EE2A0();
    if (!a1[9]) {
      return 101LL;
    }
  }

  if (!a1[10])
  {
    sub_1001EE2A0();
    if (!a1[10]) {
      return 101LL;
    }
  }

  if (!a1[11])
  {
    sub_1001EE2A0();
    if (!a1[11]) {
      return 101LL;
    }
  }

  if (!a1[13])
  {
    sub_1001EE2A0();
    if (!a1[13]) {
      return 101LL;
    }
  }

  if (!a1[14])
  {
    sub_1001EE2A0();
    if (!a1[14]) {
      return 101LL;
    }
  }

  uint64_t result = 0LL;
  qword_1008EDD28 = (uint64_t)a1;
  if (!dword_1008EDD24)
  {
    if (qword_1008EDD80)
    {
      sub_1001E6A10(1);
      return 0LL;
    }
  }

  return result;
}

double sub_1001E6A10(int a1)
{
  dword_1008EDD24 = a1;
  if (a1 == 1 && (dword_1008F6EE8 || word_1008F6EEC != 0))
  {
    v13[0] = (const void *)40;
    v13[1] = &qword_1008F6EE0;
    uint64_t v2 = sub_1001EE6DC((uint64_t)sub_1001EB248, v13, 0LL);
    if ((_DWORD)v2)
    {
      uint64_t v3 = v2;
      if (sub_1000A86F0())
      {
        sub_1001EE134((uint64_t)"Dispatch registration failed %!", v4, v5, v6, v7, v8, v9, v10, v3);
        uint64_t v11 = (os_log_s *)sub_100086554(0x37u);
        if (os_log_type_enabled(v11, OS_LOG_TYPE_ERROR)) {
          sub_100657F74();
        }
      }

      sub_1001EE2A0();
    }

    qword_1008F6F00 = 0LL;
    double result = 0.0;
    *(_OWORD *)&qword_1008F6EE0 = 0u;
    xmmword_1008F6EF0 = 0u;
  }

  return result;
}

uint64_t sub_1001E6AEC(void *a1)
{
  if (!a1)
  {
    sub_1001EE2A0();
    return 101LL;
  }

  if (!*a1)
  {
    sub_1001EE2A0();
    if (!*a1) {
      return 101LL;
    }
  }

  if (!a1[1])
  {
    sub_1001EE2A0();
    if (!a1[1]) {
      return 101LL;
    }
  }

  qword_1008EDD80 = (uint64_t)a1;
  if (dword_1008EDD24) {
    BOOL v2 = 1;
  }
  else {
    BOOL v2 = qword_1008EDD28 == 0;
  }
  if (!v2) {
    sub_1001E6A10(1);
  }
  return 0LL;
}

uint64_t sub_1001E6B70(void *a1)
{
  off_1008EDD98 = a1;
  return 0LL;
}

void sub_1001E6B80(uint64_t a1, unsigned int a2)
{
  uint64_t v41 = 0LL;
  if (HIDWORD(xmmword_1008F6FD8)) {
    BOOL v2 = dword_1008EDD24 == 0;
  }
  else {
    BOOL v2 = 1;
  }
  if (v2)
  {
    if (sub_1000A86F0())
    {
      sub_1001EE134((uint64_t)"!SECMGR_IS_INITIALIZED", v3, v4, v5, v6, v7, v8, v9, v40);
      uint64_t v10 = (os_log_s *)sub_100086554(0x37u);
      if (os_log_type_enabled(v10, OS_LOG_TYPE_ERROR)) {
LABEL_8:
      }
        sub_100657F74();
    }
  }

  else
  {
    uint64_t v12 = (unsigned __int16)word_1008EDDA0;
    if (word_1008EDDA0)
    {
      uint64_t v13 = (void *)qword_1008EDD18;
      while (*v13 != a1)
      {
        v13 += 2;
        if (!--v12) {
          goto LABEL_13;
        }
      }

      if (sub_1000A86F0())
      {
        sub_1001EE134( (uint64_t)"OI_SECMGR_ConnectComplete, connection already exists",  v24,  v25,  v26,  v27,  v28,  v29,  v30,  v40);
        uint64_t v31 = (os_log_s *)sub_100086554(0x37u);
        if (os_log_type_enabled(v31, OS_LOG_TYPE_ERROR)) {
          goto LABEL_8;
        }
      }
    }

    else
    {
LABEL_13:
      uint64_t v14 = sub_1001E6D28(a1, &v41);
      if ((_DWORD)v14)
      {
        uint64_t v15 = v14;
        if (sub_1000A86F0())
        {
          sub_1001EE134((uint64_t)"_createSecurityRecord %!", v16, v17, v18, v19, v20, v21, v22, v15);
          BOOL v23 = (os_log_s *)sub_100086554(0x37u);
          if (os_log_type_enabled(v23, OS_LOG_TYPE_ERROR)) {
            sub_100657F74();
          }
        }
      }

      else
      {
        if (a2 >= 3)
        {
          if (sub_1000A86F0())
          {
            sub_1001EE134((uint64_t)"%! (%d)", v32, v33, v34, v35, v36, v37, v38, 1411LL);
            __int128 v39 = (os_log_s *)sub_100086554(0x37u);
            if (os_log_type_enabled(v39, OS_LOG_TYPE_ERROR)) {
              sub_100657F74();
            }
          }

          a2 = 0;
        }

        sub_1001E6E58(v41, a2);
      }
    }
  }

uint64_t sub_1001E6D28(uint64_t a1, void *a2)
{
  unsigned int v4 = (unsigned __int16)word_1008EDDA0;
  if (word_1008EDDA0)
  {
    uint64_t v5 = (void *)qword_1008EDD18;
    uint64_t v6 = (unsigned __int16)word_1008EDDA0;
    while (*v5 != a1)
    {
      v5 += 2;
      if (!--v6) {
        goto LABEL_8;
      }
    }

    sub_1001EE2A0();
    unsigned int v4 = (unsigned __int16)word_1008EDDA0;
LABEL_8:
  }

  else
  {
    sub_1001EDBA0(0x28u);
  }

  unsigned int v7 = (unsigned __int16)word_1008EDDA0;
  if (v7 >= *(unsigned __int8 *)sub_1001EDBA0(0x28u))
  {
    if (sub_1000A86F0())
    {
      sub_1001EE134( (uint64_t)"No room to add another connection %d",  v12,  v13,  v14,  v15,  v16,  v17,  v18,  (unsigned __int16)word_1008EDDA0);
      uint64_t v19 = (os_log_s *)sub_100086554(0x37u);
      if (os_log_type_enabled(v19, OS_LOG_TYPE_ERROR)) {
        sub_100657F74();
      }
    }

    return 104LL;
  }

  else
  {
    uint64_t v8 = qword_1008EDD18;
    uint64_t v9 = (unsigned __int16)word_1008EDDA0;
    if (a2) {
      *a2 = qword_1008EDD18 + 16LL * (unsigned __int16)word_1008EDDA0;
    }
    uint64_t result = 0LL;
    uint64_t v11 = v8 + 16 * v9;
    *(void *)uint64_t v11 = a1;
    *(_DWORD *)(v11 + 8) = 0;
    *(_WORD *)(v11 + 12) = 0;
    word_1008EDDA0 = v9 + 1;
  }

  return result;
}

void sub_1001E6E58(uint64_t a1, int a2)
{
  if (a1)
  {
    if (a2)
    {
LABEL_3:
      *(_DWORD *)(a1 + 8) = 2;
      sub_100118D88(*(void *)a1, 3);
      return;
    }
  }

  else
  {
    sub_1001EE2A0();
    if (a2) {
      goto LABEL_3;
    }
  }

  if (*(_DWORD *)(a1 + 8) == 2) {
    *(_DWORD *)(a1 + 8) = 1;
  }
}

void sub_1001E6EB8(uint64_t a1, uint64_t a2)
{
  if (!sub_10012D514(a1))
  {
    sub_1001EE134((uint64_t)"Connection is invalid", v22, v23, v24, v25, v26, v27, v28, v44);
    uint64_t v29 = (os_log_s *)sub_100086554(0x37u);
    if (!os_log_type_enabled(v29, OS_LOG_TYPE_ERROR)) {
      return;
    }
LABEL_9:
    sub_100657F74();
    return;
  }

  unsigned int v12 = dword_1008EDD24;
  if (HIDWORD(xmmword_1008F6FD8)) {
    BOOL v13 = dword_1008EDD24 == 0;
  }
  else {
    BOOL v13 = 1;
  }
  if (v13)
  {
    sub_1001EE134((uint64_t)"!SECMGR_IS_INITIALIZED", v14, v15, v16, v17, v18, v19, v20, v44);
    uint64_t v21 = (os_log_s *)sub_100086554(0x37u);
    if (!os_log_type_enabled(v21, OS_LOG_TYPE_ERROR)) {
      return;
    }
    goto LABEL_9;
  }

  if (!qword_1008EDD28 || !*(void *)(qword_1008EDD28 + 8))
  {
    sub_1001EE2A0();
    unsigned int v12 = dword_1008EDD24;
  }

  if (v12 >= 2)
  {
    else {
      BOOL v30 = BYTE1(dword_1008EDD40) == 0;
    }
    if (!v30)
    {
      *(_WORD *)((char *)&dword_1008EDD40 + 1) = 0;
      (*(void (**)(void))(qword_1008EDD28 + 8))();
      unsigned int v12 = dword_1008EDD24;
    }

    if (v12 == 5 && qword_1008EDD38 == a1)
    {
      sub_1001E7178(a2);
    }

    else if (v12 == 2)
    {
      if (qword_1008EDD38 == a1 && DWORD2(xmmword_1008EDD48) != 4) {
        sub_1001E737C(a2, v4, v5, v6, v7, v8, v9, v10);
      }
    }

    else if (v12 == 3 && qword_1008EDD38 == a1 || v12 == 4 && qword_1008EDD38 == a1)
    {
      v11.n128_f64[0] = sub_1001E6A10(1);
    }
  }

  unsigned int v31 = (unsigned __int16)word_1008EDDA0;
  if (word_1008EDDA0)
  {
    uint64_t v32 = qword_1008EDD18;
    uint64_t v33 = qword_1008EDD18 + 16;
    int v34 = (unsigned __int16)(word_1008EDDA0 - 1);
    do
    {
      unsigned int v35 = 0;
      do
      {
        unsigned int v36 = v35;
        uint64_t v37 = *(void *)(v32 + 16LL * v35);
      }

      while (v37 != a1 && ++v35 < v31);
      if (v37 != a1) {
        break;
      }
      word_1008EDDA0 = --v31;
      if (v35 < (unsigned __int16)v31)
      {
        __int128 v39 = (__n128 *)(v33 + 16LL * v35);
        if (v37 == a1) {
          char v40 = 2;
        }
        else {
          char v40 = 1;
        }
        int v41 = v34 - v36 - (v40 & 1);
        do
        {
          __n128 v11 = *v39;
          v39[-1] = *v39;
          ++v39;
          --v41;
        }

        while (v41);
      }

      --v34;
    }

    while ((_WORD)v31);
  }

  if (*(_DWORD *)(a1 + 48) == dword_1008F6EE8 && *(unsigned __int16 *)(a1 + 52) == (unsigned __int16)word_1008F6EEC)
  {
    qword_1008F6F00 = 0LL;
    __n128 v11 = 0uLL;
    *(_OWORD *)&qword_1008F6EE0 = 0u;
    xmmword_1008F6EF0 = 0u;
  }

  if (qword_1008EDD38 == a1) {
    qword_1008EDD38 = 0LL;
  }
  uint64_t v43 = *(void (**)(__n128))(qword_1008EDD28 + 96);
  if (v43) {
    v43(v11);
  }
}

void sub_1001E7178(uint64_t a1)
{
  if (sub_1000A86F0())
  {
    sub_1001EE134((uint64_t)"Enforcement complete with %!", v2, v3, v4, v5, v6, v7, v8, a1);
    uint64_t v9 = (os_log_s *)sub_100086554(0x37u);
    if (os_log_type_enabled(v9, OS_LOG_TYPE_DEFAULT))
    {
      *(_DWORD *)__int128 buf = 136446210;
      uint64_t v32 = sub_1001EDDCC();
      _os_log_impl((void *)&_mh_execute_header, v9, OS_LOG_TYPE_DEFAULT, " %{public}s", buf, 0xCu);
    }
  }

  if (dword_1008EDD24 != 5)
  {
    sub_1001EE2A0();
    if (dword_1008EDD24 != 5)
    {
      if (sub_1000A86F0())
      {
        uint64_t v17 = dword_1008EDD24 > 5 ? "unknown" : off_100886320[dword_1008EDD24];
        sub_1001EE134((uint64_t)"enforcementFinish - %s state, %!", v10, v11, v12, v13, v14, v15, v16, (uint64_t)v17);
        uint64_t v18 = (os_log_s *)sub_100086554(0x37u);
        if (os_log_type_enabled(v18, OS_LOG_TYPE_ERROR)) {
          sub_100657F74();
        }
      }
    }
  }

  sub_1001E6A10(1LL);
  dword_1008EDD70 = 3;
  uint64_t v19 = qword_1008EDD38;
  if (qword_1008EDD38)
  {
    if (*(_BYTE *)(qword_1008EDD38 + 194))
    {
      *(_BYTE *)(qword_1008EDD38 + 194) = 0;
      sub_1001179D0(v19);
      uint64_t v19 = qword_1008EDD38;
    }

    if (!*(_DWORD *)(v19 + 148))
    {
      uint64_t v21 = sub_10010C890(v19);
      if ((_DWORD)v21)
      {
        uint64_t v22 = v21;
        if (sub_1000A86F0())
        {
          sub_1001EE134((uint64_t)"OI_DevMgr_aclActivity failed with %!", v23, v24, v25, v26, v27, v28, v29, v22);
          BOOL v30 = (os_log_s *)sub_100086554(0x37u);
          if (os_log_type_enabled(v30, OS_LOG_TYPE_ERROR)) {
            sub_100657858();
          }
        }
      }
    }
  }

  uint64_t v20 = (void (*)(uint64_t, void))off_1008EDD68;
}

void sub_1001E737C( int a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  if (dword_1008EDD24 != 2) {
    sub_1001EE2A0();
  }
  if (!HIDWORD(xmmword_1008EDD48)) {
    HIDWORD(xmmword_1008EDD48) = a1;
  }
  uint64_t v9 = sub_1001214B4(77, (uint64_t)sub_1001EB614, a3, a4, a5, a6, a7, a8, 0LL);
  if ((_DWORD)v9)
  {
    uint64_t v10 = v9;
    if (sub_1000A86F0())
    {
      sub_1001EE134((uint64_t)"OI_HCICMD_WriteAuthenticationEnable %!", v11, v12, v13, v14, v15, v16, v17, v10);
      uint64_t v18 = (os_log_s *)sub_100086554(0x37u);
      if (os_log_type_enabled(v18, OS_LOG_TYPE_ERROR)) {
        sub_100657F74();
      }
    }

    sub_1001EB614(v10);
  }

void sub_1001E742C(uint64_t a1)
{
  if (sub_10012D514(a1))
  {
    if (sub_1000A86F0())
    {
      sub_1001EE134( (uint64_t)"AuthenticatedPayloadTimeoutEvent device %: , disconnecting",  v2,  v3,  v4,  v5,  v6,  v7,  v8,  a1 + 48);
      uint64_t v9 = (os_log_s *)sub_100086554(0x37u);
      if (os_log_type_enabled(v9, OS_LOG_TYPE_ERROR)) {
        sub_100657F74();
      }
    }

    uint64_t v10 = sub_10010CDEC(a1 + 48);
    if ((_DWORD)v10)
    {
      uint64_t v11 = v10;
      if (sub_1000A86F0())
      {
        sub_1001EE134( (uint64_t)"Failed to force-disconnect due to MIC with status %!",  v12,  v13,  v14,  v15,  v16,  v17,  v18,  v11);
        uint64_t v19 = (os_log_s *)sub_100086554(0x37u);
        if (os_log_type_enabled(v19, OS_LOG_TYPE_ERROR)) {
          sub_100657F74();
        }
      }
    }
  }

uint64_t sub_1001E74F8(uint64_t a1, uint64_t a2)
{
  if (!qword_1008EDD28 || (uint64_t v4 = *(uint64_t (**)(uint64_t, uint64_t))(qword_1008EDD28 + 104)) == 0LL)
  {
    sub_1001EE2A0();
    uint64_t v4 = *(uint64_t (**)(uint64_t, uint64_t))(qword_1008EDD28 + 104);
  }

  if (a2) {
    uint64_t v5 = a2 + 48;
  }
  else {
    uint64_t v5 = 0LL;
  }
  return v4(a1, v5);
}

void sub_1001E7550(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  uint64_t v85 = 0LL;
  if (HIDWORD(xmmword_1008F6FD8)) {
    BOOL v4 = dword_1008EDD24 == 0;
  }
  else {
    BOOL v4 = 1;
  }
  if (v4)
  {
    sub_1001EE134((uint64_t)"!SECMGR_IS_INITIALIZED", v5, v6, v7, v8, v9, v10, v11, v84);
    uint64_t v12 = (os_log_s *)sub_100086554(0x37u);
    if (!os_log_type_enabled(v12, OS_LOG_TYPE_ERROR)) {
      return;
    }
LABEL_8:
    sub_100657F74();
    return;
  }

  if ((_DWORD)a1 == 702) {
    return;
  }
  if (!sub_10012D514(a2))
  {
    sub_1001EE134((uint64_t)"Invalid Handle: 0x%x", v65, v66, v67, v68, v69, v70, v71, a2);
    uint64_t v72 = (os_log_s *)sub_100086554(0x37u);
    if (!os_log_type_enabled(v72, OS_LOG_TYPE_ERROR)) {
      return;
    }
    goto LABEL_8;
  }

  if (sub_1000A86F0())
  {
    uint64_t v17 = sub_1001EE1B0(a3);
    sub_1001EE134((uint64_t)"HCIEvent EncryptionChange: %s", v18, v19, v20, v21, v22, v23, v24, (uint64_t)v17);
    uint64_t v25 = (os_log_s *)sub_100086554(0x37u);
    if (os_log_type_enabled(v25, OS_LOG_TYPE_DEFAULT))
    {
      *(_DWORD *)__int128 buf = 136446210;
      uint64_t v87 = sub_1001EDDCC();
      _os_log_impl((void *)&_mh_execute_header, v25, OS_LOG_TYPE_DEFAULT, " %{public}s", buf, 0xCu);
    }
  }

  if (sub_1000A86F0())
  {
    sub_1001EE134((uint64_t)"        addr     = %:", v26, v27, v28, v29, v30, v31, v32, a2 + 48);
    uint64_t v33 = (os_log_s *)sub_100086554(0x37u);
    if (os_log_type_enabled(v33, OS_LOG_TYPE_DEFAULT))
    {
      int v34 = sub_1001EDDCC();
      *(_DWORD *)__int128 buf = 136446210;
      uint64_t v87 = v34;
      _os_log_impl((void *)&_mh_execute_header, v33, OS_LOG_TYPE_DEFAULT, " %{public}s", buf, 0xCu);
    }
  }

  if (sub_1000A86F0())
  {
    sub_1001EE134((uint64_t)"        status   = %!", v35, v36, v37, v38, v39, v40, v41, a1);
    uint64_t v42 = (os_log_s *)sub_100086554(0x37u);
    if (os_log_type_enabled(v42, OS_LOG_TYPE_DEFAULT))
    {
      uint64_t v43 = sub_1001EDDCC();
      *(_DWORD *)__int128 buf = 136446210;
      uint64_t v87 = v43;
      _os_log_impl((void *)&_mh_execute_header, v42, OS_LOG_TYPE_DEFAULT, " %{public}s", buf, 0xCu);
    }
  }

  if (sub_1000A86F0())
  {
    sub_1001EE134((uint64_t)"        key size = %d", v44, v45, v46, v47, v48, v49, v50, a4);
    unsigned int v51 = (os_log_s *)sub_100086554(0x37u);
    if (os_log_type_enabled(v51, OS_LOG_TYPE_DEFAULT))
    {
      unsigned __int16 v52 = sub_1001EDDCC();
      *(_DWORD *)__int128 buf = 136446210;
      uint64_t v87 = v52;
      _os_log_impl((void *)&_mh_execute_header, v51, OS_LOG_TYPE_DEFAULT, " %{public}s", buf, 0xCu);
    }
  }

  if (!(_DWORD)a1)
  {
    if (a3 < 3)
    {
      if ((_DWORD)a3)
      {
        uint64_t v53 = 1LL;
        goto LABEL_25;
      }
    }

    else if (sub_1000A86F0())
    {
      sub_1001EE134((uint64_t)"%! (%d)", v73, v74, v75, v76, v77, v78, v79, 1411LL);
      uint64_t v80 = (os_log_s *)sub_100086554(0x37u);
      if (os_log_type_enabled(v80, OS_LOG_TYPE_ERROR)) {
        sub_100657F74();
      }
    }
  }

  a3 = 0LL;
  uint64_t v53 = 2LL;
LABEL_25:
  if (off_1008EDD98) {
    off_1008EDD98(v53, a1, a2 + 48);
  }
  uint64_t v54 = (unsigned __int16)word_1008EDDA0;
  if (word_1008EDDA0)
  {
    uint64_t v55 = (void *)qword_1008EDD18;
    while (*v55 != a2)
    {
      v55 += 2;
      if (!--v54) {
        goto LABEL_31;
      }
    }

    uint64_t v85 = v55;
    sub_1001E6E58((uint64_t)v55, a3);
    uint64_t v56 = 0LL;
  }

  else
  {
LABEL_31:
    uint64_t v56 = sub_1001E6D28(a2, &v85);
    if ((_DWORD)v56)
    {
      if (sub_1000A86F0())
      {
        sub_1001EE134((uint64_t)"could not create security record %!", v57, v58, v59, v60, v61, v62, v63, v56);
        char v64 = (os_log_s *)sub_100086554(0x37u);
        if (os_log_type_enabled(v64, OS_LOG_TYPE_ERROR)) {
          sub_100657F74();
        }
      }

      a3 = 0LL;
    }

    else
    {
      sub_1001E6E58((uint64_t)v85, a3);
    }
  }

  if (!qword_1008EDD28 || !*(void *)(qword_1008EDD28 + 112)) {
    sub_1001EE2A0();
  }
  if (a2)
  {
    uint64_t v81 = *(void (**)(uint64_t, uint64_t, uint64_t, uint64_t))(qword_1008EDD28 + 112);
    if (v81) {
      v81(v56, a2 + 48, a3, a4);
    }
  }

  sub_10011882C(v56, a2, a3);
  if (dword_1008EDD24 == 5 && qword_1008EDD38 == a2 && dword_1008EDD70 == 2)
  {
    if ((_DWORD)a3) {
      unsigned int v82 = 0;
    }
    else {
      unsigned int v82 = 1414;
    }
    if ((_DWORD)v56) {
      uint64_t v83 = v56;
    }
    else {
      uint64_t v83 = v82;
    }
    sub_1001E7178(v83);
  }

  if (off_1008EDD78) {
    off_1008EDD78(v56, a2, a3);
  }
}

void sub_1001E7A20(uint64_t a1, uint64_t a2)
{
  if (HIDWORD(xmmword_1008F6FD8)) {
    BOOL v2 = dword_1008EDD24 == 0;
  }
  else {
    BOOL v2 = 1;
  }
  if (v2)
  {
    if (sub_1000A86F0())
    {
      sub_1001EE134((uint64_t)"!SECMGR_IS_INITIALIZED", v3, v4, v5, v6, v7, v8, v9, v12);
      uint64_t v10 = (os_log_s *)sub_100086554(0x37u);
      if (os_log_type_enabled(v10, OS_LOG_TYPE_ERROR)) {
        sub_100657F74();
      }
    }
  }

  else if (byte_1008EDD88)
  {
    if (*(_DWORD *)(a2 + 48) == dword_1008EDD89 && *(unsigned __int16 *)(a2 + 52) == (unsigned __int16)word_1008EDD8D)
    {
      byte_1008EDD88 = 0;
      off_1008EDD90(a1, &dword_1008EDD89);
    }
  }

void sub_1001E7AE8()
{
  if (HIDWORD(xmmword_1008F6FD8)) {
    BOOL v0 = dword_1008EDD24 == 0;
  }
  else {
    BOOL v0 = 1;
  }
  if (v0 && sub_1000A86F0())
  {
    sub_1001EE134((uint64_t)"!SECMGR_IS_INITIALIZED", v1, v2, v3, v4, v5, v6, v7, v9);
    uint64_t v8 = (os_log_s *)sub_100086554(0x37u);
    if (os_log_type_enabled(v8, OS_LOG_TYPE_ERROR)) {
      sub_100657F74();
    }
  }

void sub_1001E7B60( int a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  int v10 = HIDWORD(xmmword_1008F6FD8);
  int v11 = dword_1008EDD24;
  if (HIDWORD(xmmword_1008F6FD8)) {
    BOOL v12 = dword_1008EDD24 == 0;
  }
  else {
    BOOL v12 = 1;
  }
  if (v12)
  {
    sub_1001EE2A0();
    int v10 = HIDWORD(xmmword_1008F6FD8);
    int v11 = dword_1008EDD24;
  }

  if (v10) {
    BOOL v13 = v11 == 0;
  }
  else {
    BOOL v13 = 1;
  }
  if (v13)
  {
    if (sub_1000A86F0())
    {
      sub_1001EE134((uint64_t)"!SECMGR_IS_INITIALIZED", v14, v15, v16, v17, v18, v19, v20, v30);
      uint64_t v21 = (os_log_s *)sub_100086554(0x37u);
      if (os_log_type_enabled(v21, OS_LOG_TYPE_ERROR)) {
        goto LABEL_14;
      }
    }
  }

  else
  {
    if (a2)
    {
      if (a1) {
        sub_1001214B4(31, (uint64_t)sub_1001E7C7C, a3, a4, a5, a6, a7, a8, a2);
      }
      else {
        sub_1001214B4(32, (uint64_t)sub_1001E7C7C, a3, a4, a5, a6, a7, a8, a2);
      }
      return;
    }

    sub_1001EE2A0();
    if (sub_1000A86F0())
    {
      sub_1001EE134((uint64_t)"OI_STATUS_INVALID_PARAMETERS", v22, v23, v24, v25, v26, v27, v28, v30);
      uint64_t v29 = (os_log_s *)sub_100086554(0x37u);
      if (os_log_type_enabled(v29, OS_LOG_TYPE_ERROR)) {
LABEL_14:
      }
        sub_100657F74();
    }
  }

void sub_1001E7C7C(uint64_t a1)
{
  if ((_DWORD)a1 && sub_1000A86F0())
  {
    sub_1001EE134((uint64_t)"status %!", v2, v3, v4, v5, v6, v7, v8, a1);
    uint64_t v9 = (os_log_s *)sub_100086554(0x37u);
    if (os_log_type_enabled(v9, OS_LOG_TYPE_ERROR)) {
      sub_100657F74();
    }
  }

void sub_1001E7CE8(uint64_t a1, uint64_t a2)
{
  uint64_t v35 = 0LL;
  unsigned int v2 = dword_1008EDD24;
  if (HIDWORD(xmmword_1008F6FD8)) {
    BOOL v3 = dword_1008EDD24 == 0;
  }
  else {
    BOOL v3 = 1;
  }
  if (v3)
  {
    if (sub_1000A86F0())
    {
      sub_1001EE134((uint64_t)"!SECMGR_IS_INITIALIZED", v4, v5, v6, v7, v8, v9, v10, v34);
      int v11 = (os_log_s *)sub_100086554(0x37u);
      if (os_log_type_enabled(v11, OS_LOG_TYPE_ERROR)) {
        sub_100657F74();
      }
    }
  }

  else
  {
    if (!qword_1008EDD28 || !*(void *)(qword_1008EDD28 + 56))
    {
      sub_1001EE2A0();
      unsigned int v2 = dword_1008EDD24;
    }

    if (v2 < 2
      || (*(_DWORD *)a1 == dword_1008EDD30
        ? (BOOL v14 = *(unsigned __int16 *)(a1 + 4) == (unsigned __int16)word_1008EDD34)
        : (BOOL v14 = 0),
          !v14))
    {
      if (sub_1000A86F0())
      {
        sub_1001EE134((uint64_t)"Not actively pairing or enforcing %:", v15, v16, v17, v18, v19, v20, v21, a1);
        uint64_t v22 = (os_log_s *)sub_100086554(0x37u);
        if (os_log_type_enabled(v22, OS_LOG_TYPE_ERROR)) {
          sub_100657F74();
        }
      }

void sub_1001E7EB0( int a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  int v10 = HIDWORD(xmmword_1008F6FD8);
  int v11 = dword_1008EDD24;
  if (HIDWORD(xmmword_1008F6FD8)) {
    BOOL v12 = dword_1008EDD24 == 0;
  }
  else {
    BOOL v12 = 1;
  }
  if (v12)
  {
    sub_1001EE2A0();
    int v10 = HIDWORD(xmmword_1008F6FD8);
    int v11 = dword_1008EDD24;
  }

  if (v10) {
    BOOL v13 = v11 == 0;
  }
  else {
    BOOL v13 = 1;
  }
  if (v13)
  {
    if (sub_1000A86F0())
    {
      sub_1001EE134((uint64_t)"!SECMGR_IS_INITIALIZED", v14, v15, v16, v17, v18, v19, v20, v50);
      uint64_t v21 = (os_log_s *)sub_100086554(0x37u);
      if (os_log_type_enabled(v21, OS_LOG_TYPE_ERROR)) {
        goto LABEL_27;
      }
    }
  }

  else if (a2)
  {
    if (a1)
    {
      uint64_t v22 = sub_1001214B4(33, (uint64_t)sub_1001E8070, a3, a4, a5, a6, a7, a8, a2);
      if ((_DWORD)v22)
      {
        uint64_t v23 = v22;
        if (sub_1000A86F0())
        {
          sub_1001EE134((uint64_t)"OI_HCICMD_UserPasskeyRequestReply %!", v24, v25, v26, v27, v28, v29, v30, v23);
          uint64_t v31 = (os_log_s *)sub_100086554(0x37u);
          if (os_log_type_enabled(v31, OS_LOG_TYPE_ERROR)) {
LABEL_27:
          }
            sub_100657F74();
        }
      }
    }

    else
    {
      uint64_t v40 = sub_1001214B4(34, (uint64_t)sub_1001E8070, a3, a4, a5, a6, a7, a8, a2);
      if ((_DWORD)v40)
      {
        uint64_t v41 = v40;
        if (sub_1000A86F0())
        {
          sub_1001EE134((uint64_t)"OI_HCICMD_UserPasskeyRequestNegativeReply %!", v42, v43, v44, v45, v46, v47, v48, v41);
          uint64_t v49 = (os_log_s *)sub_100086554(0x37u);
          if (os_log_type_enabled(v49, OS_LOG_TYPE_ERROR)) {
            goto LABEL_27;
          }
        }
      }
    }
  }

  else
  {
    sub_1001EE2A0();
    if (sub_1000A86F0())
    {
      sub_1001EE134((uint64_t)"OI_STATUS_INVALID_PARAMETERS", v32, v33, v34, v35, v36, v37, v38, v50);
      uint64_t v39 = (os_log_s *)sub_100086554(0x37u);
      if (os_log_type_enabled(v39, OS_LOG_TYPE_ERROR)) {
        goto LABEL_27;
      }
    }
  }

void sub_1001E8070(uint64_t a1)
{
  if ((_DWORD)a1 && sub_1000A86F0())
  {
    sub_1001EE134((uint64_t)"status %!", v2, v3, v4, v5, v6, v7, v8, a1);
    uint64_t v9 = (os_log_s *)sub_100086554(0x37u);
    if (os_log_type_enabled(v9, OS_LOG_TYPE_ERROR)) {
      sub_100657F74();
    }
  }

void sub_1001E80DC(uint64_t a1)
{
  if (HIDWORD(xmmword_1008F6FD8)) {
    BOOL v1 = dword_1008EDD24 == 0;
  }
  else {
    BOOL v1 = 1;
  }
  if (v1)
  {
    if (sub_1000A86F0())
    {
      sub_1001EE134((uint64_t)"!SECMGR_IS_INITIALIZED", v2, v3, v4, v5, v6, v7, v8, v25);
      uint64_t v9 = (os_log_s *)sub_100086554(0x37u);
      if (os_log_type_enabled(v9, OS_LOG_TYPE_ERROR)) {
        sub_100657F74();
      }
    }
  }

  else
  {
    if (!qword_1008EDD28 || !*(void *)(qword_1008EDD28 + 64)) {
      sub_1001EE2A0();
    }
    uint64_t v11 = sub_10012D890(a1);
    if (v11)
    {
      else {
        (*(void (**)(uint64_t))(qword_1008EDD28 + 64))(a1);
      }
    }

    else if (sub_1000A86F0())
    {
      sub_1001EE134((uint64_t)"Invalid connection", v17, v18, v19, v20, v21, v22, v23, v25);
      uint64_t v24 = (os_log_s *)sub_100086554(0x37u);
      if (os_log_type_enabled(v24, OS_LOG_TYPE_ERROR)) {
        sub_100657858();
      }
    }
  }

void sub_1001E81F4(uint64_t a1, uint64_t a2)
{
  if (HIDWORD(xmmword_1008F6FD8)) {
    BOOL v2 = dword_1008EDD24 == 0;
  }
  else {
    BOOL v2 = 1;
  }
  if (v2)
  {
    if (sub_1000A86F0())
    {
      sub_1001EE134((uint64_t)"!SECMGR_IS_INITIALIZED", v3, v4, v5, v6, v7, v8, v9, v14);
      int v10 = (os_log_s *)sub_100086554(0x37u);
      if (os_log_type_enabled(v10, OS_LOG_TYPE_ERROR)) {
        sub_100657F74();
      }
    }
  }

  else
  {
    if (!qword_1008EDD28 || (uint64_t v13 = *(void (**)(uint64_t, uint64_t))(qword_1008EDD28 + 72)) == 0LL)
    {
      sub_1001EE2A0();
      uint64_t v13 = *(void (**)(uint64_t, uint64_t))(qword_1008EDD28 + 72);
    }

    v13(a1, a2);
  }

void sub_1001E82B4(uint64_t a1, uint64_t a2)
{
  if (HIDWORD(xmmword_1008F6FD8)) {
    BOOL v2 = dword_1008EDD24 == 0;
  }
  else {
    BOOL v2 = 1;
  }
  if (v2)
  {
    if (sub_1000A86F0())
    {
      sub_1001EE134((uint64_t)"!SECMGR_IS_INITIALIZED", v3, v4, v5, v6, v7, v8, v9, v27);
      int v10 = (os_log_s *)sub_100086554(0x37u);
      if (os_log_type_enabled(v10, OS_LOG_TYPE_ERROR)) {
        sub_100657F74();
      }
    }
  }

  else
  {
    if (!qword_1008EDD28 || !*(void *)(qword_1008EDD28 + 80)) {
      sub_1001EE2A0();
    }
    uint64_t v13 = sub_10012D890(a1);
    if (v13)
    {
      else {
        (*(void (**)(uint64_t, uint64_t))(qword_1008EDD28 + 80))(a1, a2);
      }
    }

    else if (sub_1000A86F0())
    {
      sub_1001EE134((uint64_t)"Invalid connection", v19, v20, v21, v22, v23, v24, v25, v27);
      uint64_t v26 = (os_log_s *)sub_100086554(0x37u);
      if (os_log_type_enabled(v26, OS_LOG_TYPE_ERROR)) {
        sub_100657858();
      }
    }
  }

void sub_1001E83E4(uint64_t a1)
{
  if (HIDWORD(xmmword_1008F6FD8)) {
    BOOL v1 = dword_1008EDD24 == 0;
  }
  else {
    BOOL v1 = 1;
  }
  if (v1)
  {
    if (sub_1000A86F0())
    {
      sub_1001EE134((uint64_t)"!SECMGR_IS_INITIALIZED", v2, v3, v4, v5, v6, v7, v8, v22);
      uint64_t v9 = (os_log_s *)sub_100086554(0x37u);
      if (os_log_type_enabled(v9, OS_LOG_TYPE_ERROR)) {
        sub_100657F74();
      }
    }
  }

  else
  {
    if (!qword_1008EDD28 || !*(void *)(qword_1008EDD28 + 88)) {
      sub_1001EE2A0();
    }
    uint64_t v11 = sub_10012D890(a1);
    if (v11)
    {
      else {
        (*(void (**)(uint64_t))(qword_1008EDD28 + 88))(a1);
      }
    }

    else if (sub_1000A86F0())
    {
      sub_1001EE134((uint64_t)"Invalid connection", v14, v15, v16, v17, v18, v19, v20, v22);
      uint64_t v21 = (os_log_s *)sub_100086554(0x37u);
      if (os_log_type_enabled(v21, OS_LOG_TYPE_ERROR)) {
        sub_100657858();
      }
    }
  }

void sub_1001E8508( int a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  int v14 = HIDWORD(xmmword_1008F6FD8);
  int v15 = dword_1008EDD24;
  if (HIDWORD(xmmword_1008F6FD8)) {
    BOOL v16 = dword_1008EDD24 == 0;
  }
  else {
    BOOL v16 = 1;
  }
  if (v16)
  {
    sub_1001EE2A0();
    int v14 = HIDWORD(xmmword_1008F6FD8);
    int v15 = dword_1008EDD24;
  }

  if (v14) {
    BOOL v17 = v15 == 0;
  }
  else {
    BOOL v17 = 1;
  }
  if (v17)
  {
    if (sub_1000A86F0())
    {
      sub_1001EE134((uint64_t)"!SECMGR_IS_INITIALIZED", v18, v19, v20, v21, v22, v23, v24, v62);
      uint64_t v25 = (os_log_s *)sub_100086554(0x37u);
      if (os_log_type_enabled(v25, OS_LOG_TYPE_ERROR)) {
        goto LABEL_41;
      }
    }

    return;
  }

  if (!a2)
  {
    sub_1001EE2A0();
    if (sub_1000A86F0())
    {
      sub_1001EE134((uint64_t)"OI_STATUS_INVALID_PARAMETERS pAddr %:", v36, v37, v38, v39, v40, v41, v42, 0LL);
      uint64_t v43 = (os_log_s *)sub_100086554(0x37u);
      if (os_log_type_enabled(v43, OS_LOG_TYPE_ERROR)) {
        goto LABEL_41;
      }
    }

    return;
  }

  if (!a1)
  {
    uint64_t v44 = sub_1001214B4(36, (uint64_t)sub_1001E8768, a3, a4, a5, a6, a7, a8, a2);
    if ((_DWORD)v44)
    {
      uint64_t v45 = v44;
      if (sub_1000A86F0())
      {
        sub_1001EE134((uint64_t)"OI_HCICMD_RemoteOOBDataRequestNegativeReply %!", v46, v47, v48, v49, v50, v51, v52, v45);
        uint64_t v53 = (os_log_s *)sub_100086554(0x37u);
        if (os_log_type_enabled(v53, OS_LOG_TYPE_ERROR)) {
          goto LABEL_41;
        }
      }
    }

    return;
  }

  if (a3)
  {
    if (a4) {
      goto LABEL_19;
    }
  }

  else
  {
    sub_1001EE2A0();
    if (a4)
    {
LABEL_19:
      if (a5) {
        goto LABEL_20;
      }
LABEL_37:
      sub_1001EE2A0();
      if (a6) {
        goto LABEL_21;
      }
LABEL_38:
      sub_1001EE2A0();
      goto LABEL_39;
    }
  }

  sub_1001EE2A0();
  if (!a5) {
    goto LABEL_37;
  }
LABEL_20:
  if (!a6) {
    goto LABEL_38;
  }
LABEL_21:
  if (!a5 || !a3 || !a4)
  {
LABEL_39:
    if (sub_1000A86F0())
    {
      sub_1001EE134((uint64_t)"oob data %!", v54, v55, v56, v57, v58, v59, v60, 101LL);
      uint64_t v61 = (os_log_s *)sub_100086554(0x37u);
      if (os_log_type_enabled(v61, OS_LOG_TYPE_ERROR)) {
        goto LABEL_41;
      }
    }

    return;
  }

  uint64_t v26 = sub_1001214B4(39, (uint64_t)sub_1001E8768, a3, a4, a5, a6, a7, a8, a2);
  if ((_DWORD)v26)
  {
    uint64_t v27 = v26;
    if (sub_1000A86F0())
    {
      sub_1001EE134((uint64_t)"OI_HCICMD_RemoteOOBDataRequestReply %!", v28, v29, v30, v31, v32, v33, v34, v27);
      uint64_t v35 = (os_log_s *)sub_100086554(0x37u);
      if (os_log_type_enabled(v35, OS_LOG_TYPE_ERROR)) {
LABEL_41:
      }
        sub_100657F74();
    }
  }

void sub_1001E8768(uint64_t a1)
{
  if ((_DWORD)a1 && sub_1000A86F0())
  {
    sub_1001EE134((uint64_t)"status %!", v2, v3, v4, v5, v6, v7, v8, a1);
    uint64_t v9 = (os_log_s *)sub_100086554(0x37u);
    if (os_log_type_enabled(v9, OS_LOG_TYPE_ERROR)) {
      sub_100657F74();
    }
  }

void sub_1001E87D4(uint64_t a1)
{
  int v1 = dword_1008EDD24;
  if (HIDWORD(xmmword_1008F6FD8)) {
    BOOL v2 = dword_1008EDD24 == 0;
  }
  else {
    BOOL v2 = 1;
  }
  if (v2)
  {
    if (sub_1000A86F0())
    {
      sub_1001EE134((uint64_t)"!SECMGR_IS_INITIALIZED", v3, v4, v5, v6, v7, v8, v9, v48);
      int v10 = (os_log_s *)sub_100086554(0x37u);
      if (os_log_type_enabled(v10, OS_LOG_TYPE_ERROR)) {
        sub_100657F74();
      }
    }
  }

  else
  {
    if (!qword_1008EDD28 || !*(void *)(qword_1008EDD28 + 24) || !*(void *)qword_1008EDD28)
    {
      sub_1001EE2A0();
      int v1 = dword_1008EDD24;
    }

    int v12 = 20;
    switch(v1)
    {
      case 1:
        return;
      case 2:
      case 5:
        BYTE1(dword_1008EDD40) = 1;
        (*(void (**)(uint64_t))qword_1008EDD28)(a1);
        if (dword_1008EDD24 != 2) {
          goto LABEL_38;
        }
        if (DWORD2(xmmword_1008EDD48) == 1) {
          goto LABEL_43;
        }
        if (DWORD2(xmmword_1008EDD48) == 2)
        {
          DWORD2(xmmword_1008EDD48) = 5;
          goto LABEL_38;
        }

        sub_1001EE2A0();
        goto LABEL_43;
      case 3:
        if (byte_1008EDD21 || xmmword_1008EDD48 < 2u || xmmword_1008EDD48 > 5u)
        {
LABEL_38:
          (*(void (**)(uint64_t))(qword_1008EDD28 + 24))(a1);
        }

        else
        {
          if (sub_1000A86F0())
          {
            sub_1001EE134( (uint64_t)"Non-bondable mode, rejecting IO caps request from %:",  v23,  v24,  v25,  v26,  v27,  v28,  v29,  a1);
            uint64_t v30 = (os_log_s *)sub_100086554(0x37u);
            if (os_log_type_enabled(v30, OS_LOG_TYPE_ERROR)) {
              sub_100657F74();
            }
          }

          int v12 = 24;
LABEL_43:
          if (sub_1000A86F0())
          {
            sub_1001EE134( (uint64_t)"rejecting %: ioCaps request, secmgrState: %s, %!",  v32,  v33,  v34,  v35,  v36,  v37,  v38,  a1);
            uint64_t v39 = (os_log_s *)sub_100086554(0x37u);
            if (os_log_type_enabled(v39, OS_LOG_TYPE_ERROR)) {
              sub_100657F74();
            }
          }

          if (sub_1000A86F0())
          {
            sub_1001EE134((uint64_t)"%:", v40, v41, v42, v43, v44, v45, v46, a1);
            uint64_t v47 = (os_log_s *)sub_100086554(0x37u);
            if (os_log_type_enabled(v47, OS_LOG_TYPE_ERROR)) {
              sub_100657F74();
            }
          }

          sub_1001E8B10(v12, a1, 0);
        }

        break;
      case 4:
        goto LABEL_43;
      default:
        if (sub_1000A86F0())
        {
          uint64_t v21 = dword_1008EDD24 > 5 ? "unknown" : off_100886320[dword_1008EDD24];
          sub_1001EE134((uint64_t)"secmgrState %s (%d)", v14, v15, v16, v17, v18, v19, v20, (uint64_t)v21);
          uint64_t v31 = (os_log_s *)sub_100086554(0x37u);
          if (os_log_type_enabled(v31, OS_LOG_TYPE_ERROR)) {
            sub_100657F74();
          }
        }

        sub_1001EE2A0();
        int v12 = 20;
        goto LABEL_43;
    }
  }

void sub_1001E8B10(int a1, uint64_t a2, int a3)
{
  int v6 = HIDWORD(xmmword_1008F6FD8);
  int v7 = dword_1008EDD24;
  if (HIDWORD(xmmword_1008F6FD8)) {
    BOOL v8 = dword_1008EDD24 == 0;
  }
  else {
    BOOL v8 = 1;
  }
  if (v8)
  {
    sub_1001EE2A0();
    int v7 = dword_1008EDD24;
    int v6 = HIDWORD(xmmword_1008F6FD8);
  }

  if (v6) {
    BOOL v9 = v7 == 0;
  }
  else {
    BOOL v9 = 1;
  }
  if (v9)
  {
    if (sub_1000A86F0())
    {
      sub_1001EE134((uint64_t)"!SECMGR_IS_INITIALIZED", v10, v11, v12, v13, v14, v15, v16, v62);
      uint64_t v17 = (os_log_s *)sub_100086554(0x37u);
      if (os_log_type_enabled(v17, OS_LOG_TYPE_ERROR)) {
        goto LABEL_50;
      }
    }
  }

  else
  {
    if (a2)
    {
      switch(v7)
      {
        case 1:
        case 2:
        case 4:
        case 5:
          goto LABEL_37;
        case 3:
          LOBYTE(dword_1008EDD40) = a3 != 3
                                 && BYTE1(xmmword_1008EDD48) != 3
                                 && (a3 == 2 || BYTE1(xmmword_1008EDD48) == 2 || a3 == 1
                                                                              || BYTE1(xmmword_1008EDD48) == 1);
LABEL_37:
          if (!qword_1008EDD80 || (uint64_t v35 = *(unsigned int (**)(void))qword_1008EDD80) == 0LL)
          {
            sub_1001EE2A0();
            uint64_t v35 = *(unsigned int (**)(void))qword_1008EDD80;
          }

          if (v35() >= 3) {
            LOBYTE(dword_1008EDD40) = 1;
          }
          if (a1)
          {
            uint64_t v42 = sub_1001214B4(37, (uint64_t)sub_1001E91D0, v36, v37, v38, v39, v40, v41, a2);
            if (!(_DWORD)v42) {
              return;
            }
            uint64_t v43 = v42;
            sub_1001EE134( (uint64_t)"OI_HCICMD_IOCapabilityRequestNegativeReply %!",  v44,  v45,  v46,  v47,  v48,  v49,  v50,  v43);
            uint64_t v51 = (os_log_s *)sub_100086554(0x37u);
            if (!os_log_type_enabled(v51, OS_LOG_TYPE_ERROR)) {
              return;
            }
          }

          else
          {
            uint64_t v52 = sub_1001214B4(30, (uint64_t)sub_1001E91D0, v36, v37, v38, v39, v40, v41, a2);
            if (!(_DWORD)v52) {
              return;
            }
            uint64_t v53 = v52;
            sub_1001EE134((uint64_t)"%!", v54, v55, v56, v57, v58, v59, v60, v53);
            uint64_t v61 = (os_log_s *)sub_100086554(0x37u);
            if (!os_log_type_enabled(v61, OS_LOG_TYPE_ERROR)) {
              return;
            }
          }

          break;
        default:
          if (sub_1000A86F0())
          {
            uint64_t v33 = dword_1008EDD24 > 5 ? "unknown" : off_100886320[dword_1008EDD24];
            sub_1001EE134((uint64_t)"secmgrState %s (%d), %!", v26, v27, v28, v29, v30, v31, v32, (uint64_t)v33);
            uint64_t v34 = (os_log_s *)sub_100086554(0x37u);
            if (os_log_type_enabled(v34, OS_LOG_TYPE_ERROR)) {
              sub_100657F74();
            }
          }

          sub_1001EE2A0();
          return;
      }

      goto LABEL_50;
    }

    sub_1001EE2A0();
    if (sub_1000A86F0())
    {
      sub_1001EE134((uint64_t)"OI_STATUS_INVALID_PARAMETERS", v18, v19, v20, v21, v22, v23, v24, v62);
      uint64_t v25 = (os_log_s *)sub_100086554(0x37u);
      if (os_log_type_enabled(v25, OS_LOG_TYPE_ERROR)) {
LABEL_50:
      }
        sub_100657F74();
    }
  }

void sub_1001E8E78(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  int v4 = dword_1008EDD24;
  if (HIDWORD(xmmword_1008F6FD8)) {
    BOOL v5 = dword_1008EDD24 == 0;
  }
  else {
    BOOL v5 = 1;
  }
  if (v5)
  {
    if (sub_1000A86F0())
    {
      sub_1001EE134((uint64_t)"!SECMGR_IS_INITIALIZED", v6, v7, v8, v9, v10, v11, v12, v55);
      uint64_t v13 = (os_log_s *)sub_100086554(0x37u);
      if (os_log_type_enabled(v13, OS_LOG_TYPE_ERROR)) {
        sub_100657F74();
      }
    }
  }

  else
  {
    if (!qword_1008EDD28 || !*(void *)(qword_1008EDD28 + 16) || !*(void *)qword_1008EDD28)
    {
      sub_1001EE2A0();
      int v4 = dword_1008EDD24;
    }

    switch(v4)
    {
      case 1:
        uint64_t v56 = 0LL;
        if (sub_10010EEE0(a1, &v56))
        {
          if (sub_1000A86F0())
          {
            sub_1001EE134( (uint64_t)"IoCapsResponse, internal inconsistency for %:, %!",  v27,  v28,  v29,  v30,  v31,  v32,  v33,  a1);
            uint64_t v34 = (os_log_s *)sub_100086554(0x37u);
            if (os_log_type_enabled(v34, OS_LOG_TYPE_ERROR)) {
              sub_100657F74();
            }
          }

          goto LABEL_38;
        }

        dword_1008EDD24 = 3;
        uint64_t v35 = v56;
        char v36 = *(_BYTE *)(v56 + 277);
        if (!v36)
        {
          char v36 = 1;
          *(_BYTE *)(v56 + 27memset((char *)&v11[1] + 1, 0, 7) = 1;
        }

        int v37 = *(_DWORD *)a1;
        word_1008EDD34 = *(_WORD *)(a1 + 4);
        dword_1008EDD30 = v37;
        qword_1008EDD38 = v35;
        *(_WORD *)((char *)&dword_1008EDD40 + 1) = 257;
        LOBYTE(dword_1008EDD40) = a4 & 1;
        HIBYTE(dword_1008EDD40) = v36 & (byte_1008F6D20 > 3u);
        LOBYTE(xmmword_1008EDD48) = a4;
        BYTE1(xmmword_1008EDD48) = a2;
        (*(void (**)(uint64_t))qword_1008EDD28)(a1);
        goto LABEL_33;
      case 2:
      case 5:
        if ((a4 & 1) != 0) {
          LOBYTE(dword_1008EDD40) = 1;
        }
        if (!BYTE1(dword_1008EDD40)) {
          *(_WORD *)((char *)&dword_1008EDD40 + 1) = 256;
        }
LABEL_33:
        (*(void (**)(uint64_t, uint64_t, uint64_t, uint64_t))(qword_1008EDD28 + 16))(a1, a2, a3, a4);
        break;
      case 3:
      case 4:
        goto LABEL_38;
      default:
        if (sub_1000A86F0())
        {
          uint64_t v26 = dword_1008EDD24 > 5 ? "unknown" : off_100886320[dword_1008EDD24];
          sub_1001EE134((uint64_t)"secmgrState %s (%d)", v19, v20, v21, v22, v23, v24, v25, (uint64_t)v26);
          uint64_t v38 = (os_log_s *)sub_100086554(0x37u);
          if (os_log_type_enabled(v38, OS_LOG_TYPE_ERROR)) {
            sub_100657F74();
          }
        }

        sub_1001EE2A0();
LABEL_38:
        if (sub_1000A86F0())
        {
          sub_1001EE134((uint64_t)"Ignoring IoCapsResponse event from %:, %!", v39, v40, v41, v42, v43, v44, v45, a1);
          uint64_t v46 = (os_log_s *)sub_100086554(0x37u);
          if (os_log_type_enabled(v46, OS_LOG_TYPE_ERROR)) {
            sub_100657F74();
          }
        }

        if (sub_10018BE60() == 6 || sub_10018BE60() == 12)
        {
          if (sub_1000A86F0())
          {
            sub_1001EE134( (uint64_t)"Unexpected IoCapsResponse event. Forcing disconnect from %:, %!",  v47,  v48,  v49,  v50,  v51,  v52,  v53,  a1);
            uint64_t v54 = (os_log_s *)sub_100086554(0x37u);
            if (os_log_type_enabled(v54, OS_LOG_TYPE_ERROR)) {
              sub_100657F74();
            }
          }

          sub_10010CDEC(a1);
        }

        break;
    }
  }

void sub_1001E91D0(uint64_t a1)
{
  if ((_DWORD)a1 && sub_1000A86F0())
  {
    sub_1001EE134((uint64_t)"ioCapsReplyCmdCb %!", v2, v3, v4, v5, v6, v7, v8, a1);
    uint64_t v9 = (os_log_s *)sub_100086554(0x37u);
    if (os_log_type_enabled(v9, OS_LOG_TYPE_ERROR)) {
      sub_100657F74();
    }
  }

void sub_1001E923C( int a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  int v11 = HIDWORD(xmmword_1008F6FD8);
  int v12 = dword_1008EDD24;
  if (HIDWORD(xmmword_1008F6FD8)) {
    BOOL v13 = dword_1008EDD24 == 0;
  }
  else {
    BOOL v13 = 1;
  }
  if (v13)
  {
    sub_1001EE2A0();
    int v11 = HIDWORD(xmmword_1008F6FD8);
    int v12 = dword_1008EDD24;
  }

  if (v11) {
    BOOL v14 = v12 == 0;
  }
  else {
    BOOL v14 = 1;
  }
  if (v14)
  {
    sub_1001EE134((uint64_t)"!SECMGR_IS_INITIALIZED", v15, v16, v17, v18, v19, v20, v21, v41);
    uint64_t v22 = (os_log_s *)sub_100086554(0x37u);
    if (!os_log_type_enabled(v22, OS_LOG_TYPE_ERROR)) {
      return;
    }
LABEL_32:
    sub_100657F74();
    return;
  }

  if (!a2)
  {
    sub_1001EE2A0();
    if (a3 || (a1 & 1) == 0)
    {
LABEL_25:
      sub_1001EE134((uint64_t)"OI_STATUS_INVALID_PARAMETERS", v24, v25, v26, v27, v28, v29, v30, v41);
      uint64_t v31 = (os_log_s *)sub_100086554(0x37u);
      if (!os_log_type_enabled(v31, OS_LOG_TYPE_ERROR)) {
        return;
      }
      goto LABEL_32;
    }

void sub_1001E93E4(int a1, uint64_t a2)
{
  if (a1 && sub_1000A86F0())
  {
    sub_1001EE134((uint64_t)"pinCodeRequestReplyCb %:, %!", v3, v4, v5, v6, v7, v8, v9, a2);
    uint64_t v10 = (os_log_s *)sub_100086554(0x37u);
    if (os_log_type_enabled(v10, OS_LOG_TYPE_ERROR)) {
      sub_100657F74();
    }
  }

void sub_1001E9454(uint64_t a1)
{
  uint64_t v46 = 0LL;
  if (HIDWORD(xmmword_1008F6FD8)) {
    BOOL v1 = dword_1008EDD24 == 0;
  }
  else {
    BOOL v1 = 1;
  }
  if (v1)
  {
    if (sub_1000A86F0())
    {
      sub_1001EE134((uint64_t)"!SECMGR_IS_INITIALIZED", v2, v3, v4, v5, v6, v7, v8, v45);
      uint64_t v9 = (os_log_s *)sub_100086554(0x37u);
      if (os_log_type_enabled(v9, OS_LOG_TYPE_ERROR)) {
        sub_100657F74();
      }
    }
  }

  else
  {
    if (!qword_1008EDD28 || !*(void *)(qword_1008EDD28 + 48)) {
      sub_1001EE2A0();
    }
    if (byte_1008EDD21)
    {
      uint64_t v11 = sub_10010EEE0(a1, &v46);
      if ((_DWORD)v11)
      {
        uint64_t v16 = v11;
        if (sub_1000A86F0())
        {
          sub_1001EE134((uint64_t)"OI_DEVMGR_GetAclHandleFromAddr %!", v17, v18, v19, v12, v13, v14, v15, v16);
          uint64_t v20 = (os_log_s *)sub_100086554(0x37u);
          if (os_log_type_enabled(v20, OS_LOG_TYPE_ERROR)) {
            sub_100657F74();
          }
        }
      }

      else
      {
        switch(dword_1008EDD24)
        {
          case 0:
          case 3:
          case 4:
            goto LABEL_43;
          case 1:
            dword_1008EDD24 = 4;
            int v25 = *(_DWORD *)a1;
            word_1008EDD34 = *(_WORD *)(a1 + 4);
            dword_1008EDD30 = v25;
            qword_1008EDD38 = v46;
            dword_1008EDD40 = 0;
            break;
          case 2:
            if (*(_DWORD *)a1 == dword_1008EDD30 && *(unsigned __int16 *)(a1 + 4) == (unsigned __int16)word_1008EDD34)
            {
              switch(DWORD2(xmmword_1008EDD48))
              {
                case 0:
                case 4:
                  goto LABEL_43;
                case 1:
                case 2:
                  DWORD2(xmmword_1008EDD48) = 3;
                  goto LABEL_37;
                case 3:
                  goto LABEL_37;
                default:
                  if (sub_1000A86F0())
                  {
                    sub_1001EE134( (uint64_t)"curContext.u.bondingContext.substate %d, %!",  v37,  v38,  v39,  v40,  v41,  v42,  v43,  DWORD2(xmmword_1008EDD48));
                    uint64_t v44 = (os_log_s *)sub_100086554(0x37u);
                    if (os_log_type_enabled(v44, OS_LOG_TYPE_ERROR)) {
                      sub_100657F74();
                    }
                  }

                  sub_1001E737C(105, v37, v38, v39, v40, v41, v42, v43);
                  goto LABEL_42;
              }
            }

            goto LABEL_43;
          case 5:
            break;
          default:
            if (sub_1000A86F0())
            {
              uint64_t v33 = dword_1008EDD24 > 5 ? "unknown" : off_100886320[dword_1008EDD24];
              sub_1001EE134((uint64_t)"secmgrState %s (%d), %!", v26, v27, v28, v29, v30, v31, v32, (uint64_t)v33);
              uint64_t v36 = (os_log_s *)sub_100086554(0x37u);
              if (os_log_type_enabled(v36, OS_LOG_TYPE_ERROR)) {
                sub_100657F74();
              }
            }

void sub_1001E9778( uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  unsigned int v50 = 0;
  int v8 = dword_1008EDD24;
  if (HIDWORD(xmmword_1008F6FD8)) {
    BOOL v9 = dword_1008EDD24 == 0;
  }
  else {
    BOOL v9 = 1;
  }
  if (v9)
  {
    if (sub_1000A86F0())
    {
      sub_1001EE134((uint64_t)"!SECMGR_IS_INITIALIZED", v10, v11, v12, v13, v14, v15, v16, v48);
      uint64_t v17 = (os_log_s *)sub_100086554(0x37u);
      if (os_log_type_enabled(v17, OS_LOG_TYPE_ERROR)) {
        sub_100657F74();
      }
    }

    return;
  }

  if (!qword_1008EDD28 || !*(void *)(qword_1008EDD28 + 32))
  {
    sub_1001EE2A0();
    int v8 = dword_1008EDD24;
  }

  if (v8 == 2)
  {
    switch(DWORD2(xmmword_1008EDD48))
    {
      case 0:
      case 3:
      case 4:
      case 5:
      case 6:
        sub_1001EE134( (uint64_t)"curContext.u.bondingContext.substate %d, %!",  v19,  v20,  v21,  v22,  v23,  v24,  v25,  DWORD2(xmmword_1008EDD48));
        uint64_t v26 = (os_log_s *)sub_100086554(0x37u);
        if (!os_log_type_enabled(v26, OS_LOG_TYPE_ERROR)) {
          goto LABEL_17;
        }
        goto LABEL_16;
      case 1:
        DWORD2(xmmword_1008EDD48) = 3;
        break;
      case 2:
        break;
      default:
        if (sub_1000A86F0())
        {
          sub_1001EE134((uint64_t)"Unknown bonding substate %!", v19, v20, v21, v22, v23, v24, v25, 105LL);
          uint64_t v37 = (os_log_s *)sub_100086554(0x37u);
          if (os_log_type_enabled(v37, OS_LOG_TYPE_ERROR)) {
LABEL_16:
          }
            sub_100657F74();
        }

uint64_t sub_1001E9A5C(int a1, uint64_t a2, uint64_t a3)
{
  if (dword_1008EDD24 != 5) {
    sub_1001EE2A0();
  }
  uint64_t result = 1LL;
  switch((int)a2)
  {
    case 0:
      return result;
    case 1:
      if (a1)
      {
        if (a3 > 8)
        {
          uint64_t result = sub_1000A86F0();
          if ((_DWORD)result)
          {
            sub_1001EE134((uint64_t)"Unhandled keytype", v31, v32, v33, v34, v35, v36, v37, a3);
            uint64_t v38 = (os_log_s *)sub_100086554(0x37u);
            uint64_t result = os_log_type_enabled(v38, OS_LOG_TYPE_ERROR);
            if ((_DWORD)result) {
              goto LABEL_34;
            }
          }
        }

        else if (((1 << a3) & 0x1B8) == 0)
        {
          if (((1 << a3) & 7) != 0) {
            goto LABEL_8;
          }
          uint64_t result = sub_1000A86F0();
          if ((_DWORD)result)
          {
            sub_1001EE134((uint64_t)"keyTypeIsSufficient %!", v39, v40, v41, v42, v43, v44, v45, 1420LL);
            uint64_t v46 = (os_log_s *)sub_100086554(0x37u);
            uint64_t result = os_log_type_enabled(v46, OS_LOG_TYPE_ERROR);
            if ((_DWORD)result) {
              goto LABEL_34;
            }
          }
        }
      }

      break;
    case 2:
      uint64_t result = 0LL;
      if (a3 <= 8)
      {
        if (((1 << a3) & 0x1B8) != 0) {
          goto LABEL_21;
        }
        if (!(_DWORD)a3) {
          goto LABEL_28;
        }
        if ((_DWORD)a3 == 6)
        {
          uint64_t result = sub_1000A86F0();
          if ((_DWORD)result)
          {
            sub_1001EE134((uint64_t)"keyTypeIsSufficient %!", v15, v16, v17, v18, v19, v20, v21, 1420LL);
            uint64_t v22 = (os_log_s *)sub_100086554(0x37u);
            uint64_t result = os_log_type_enabled(v22, OS_LOG_TYPE_ERROR);
            if ((_DWORD)result) {
              goto LABEL_34;
            }
          }
        }
      }

      break;
    case 3:
      uint64_t result = 0LL;
      if (a3 <= 8)
      {
        if (((1 << a3) & 0x1A8) != 0)
        {
LABEL_21:
          uint64_t result = 1LL;
        }

        else if ((_DWORD)a3)
        {
          if ((_DWORD)a3 == 6)
          {
            uint64_t result = sub_1000A86F0();
            if ((_DWORD)result)
            {
              sub_1001EE134((uint64_t)"keyTypeIsSufficient %!", v23, v24, v25, v26, v27, v28, v29, 1420LL);
              uint64_t v30 = (os_log_s *)sub_100086554(0x37u);
              uint64_t result = os_log_type_enabled(v30, OS_LOG_TYPE_ERROR);
              if ((_DWORD)result) {
                goto LABEL_34;
              }
            }
          }
        }

        else
        {
LABEL_28:
          uint64_t result = a1 ^ 1u;
        }
      }

      break;
    default:
      uint64_t result = sub_1000A86F0();
      if ((_DWORD)result)
      {
        sub_1001EE134((uint64_t)"Invalid security level %d, %!", v7, v8, v9, v10, v11, v12, v13, a2);
        uint64_t v14 = (os_log_s *)sub_100086554(0x37u);
        uint64_t result = os_log_type_enabled(v14, OS_LOG_TYPE_ERROR);
        if ((_DWORD)result)
        {
LABEL_34:
          sub_100657F74();
LABEL_8:
          uint64_t result = 0LL;
        }
      }

      break;
  }

  return result;
}

void sub_1001E9CC4(uint64_t a1)
{
  if ((_DWORD)a1 && sub_1000A86F0())
  {
    sub_1001EE134((uint64_t)"linkKeyRequestReplyCb %!", v2, v3, v4, v5, v6, v7, v8, a1);
    uint64_t v9 = (os_log_s *)sub_100086554(0x37u);
    if (os_log_type_enabled(v9, OS_LOG_TYPE_ERROR)) {
      sub_100657F74();
    }
  }

void sub_1001E9D30(uint64_t a1, uint64_t a2, uint64_t a3)
{
  uint64_t v18 = 0LL;
  if (HIDWORD(xmmword_1008F6FD8)) {
    BOOL v3 = dword_1008EDD24 == 0;
  }
  else {
    BOOL v3 = 1;
  }
  if (v3)
  {
    if (sub_1000A86F0())
    {
      sub_1001EE134((uint64_t)"!SECMGR_IS_INITIALIZED", v4, v5, v6, v7, v8, v9, v10, v17);
      uint64_t v11 = (os_log_s *)sub_100086554(0x37u);
      if (os_log_type_enabled(v11, OS_LOG_TYPE_ERROR)) {
        sub_100657F74();
      }
    }
  }

  else
  {
    if (!*(void *)(qword_1008EDD28 + 40)) {
      sub_1001EE2A0();
    }
    if (sub_10010EEE0(a1, &v18) || (uint64_t v16 = (unsigned __int16)word_1008EDDA0, !word_1008EDDA0))
    {
LABEL_12:
      uint64_t v15 = 0LL;
    }

    else
    {
      uint64_t v15 = qword_1008EDD18;
      while (*(void *)v15 != v18)
      {
        v15 += 16LL;
        if (!--v16) {
          goto LABEL_12;
        }
      }
    }

    (*(void (**)(uint64_t, uint64_t, uint64_t, void))(qword_1008EDD28 + 40))( a1,  a2,  a3,  byte_1008EDD21);
    if (v15)
    {
      if (*(_DWORD *)(v15 + 8) != 2) {
        *(_DWORD *)(v15 + 8) = 1;
      }
    }
  }

void sub_1001E9E64(uint64_t a1, uint64_t a2)
{
  if (HIDWORD(xmmword_1008F6FD8)) {
    BOOL v2 = dword_1008EDD24 == 0;
  }
  else {
    BOOL v2 = 1;
  }
  if (!v2)
  {
    if (dword_1008EDD24 == 2 && qword_1008EDD38 == a2)
    {
      if (DWORD2(xmmword_1008EDD48) > 6) {
        goto LABEL_48;
      }
      if (((1 << SBYTE8(xmmword_1008EDD48)) & 0x57) == 0)
      {
        HIDWORD(xmmword_1008EDD48) = a1;
        sub_1001EA150();
        goto LABEL_48;
      }

      if (sub_1000A86F0())
      {
        sub_1001EE134( (uint64_t)"curContext.u.bondingContext.substate %d, %!",  v16,  v17,  v18,  v19,  v20,  v21,  v22,  DWORD2(xmmword_1008EDD48));
        uint64_t v23 = (os_log_s *)sub_100086554(0x37u);
        if (os_log_type_enabled(v23, OS_LOG_TYPE_ERROR)) {
          sub_100657F74();
        }
      }

      sub_1001E737C(105, v16, v17, v18, v19, v20, v21, v22);
    }

    else
    {
      if (dword_1008EDD24 != 5 || qword_1008EDD38 != a2) {
        goto LABEL_48;
      }
      if (dword_1008EDD70 == 1)
      {
        if (!qword_1008EDD28 || !*(void *)(qword_1008EDD28 + 32))
        {
          sub_1001EE2A0();
          if (dword_1008EDD24 != 5) {
            sub_1001EE2A0();
          }
        }

        if (dword_1008EDD70 != 1) {
          sub_1001EE2A0();
        }
        if ((_DWORD)a1)
        {
          uint64_t v15 = a1;
        }

        else
        {
          memset(v41, 0, sizeof(v41));
          unsigned int v42 = 0;
          if (((sub_1001C3170((uint64_t)&dword_1008EDD30, (uint64_t)v41) & 1) != 0
             || (*(unsigned int (**)(int *, void *))(qword_1008EDD28 + 32))(&dword_1008EDD30, v41))
            && sub_1001E9A5C(HIBYTE(dword_1008EDD40), dword_1008EDD60, v42))
          {
            sub_1001EB33C();
            goto LABEL_48;
          }

          if (sub_1000A86F0())
          {
            sub_1001EE134((uint64_t)"enforceAuthenticationDone %!", v32, v33, v34, v35, v36, v37, v38, 1419LL);
            uint64_t v39 = (os_log_s *)sub_100086554(0x37u);
            if (os_log_type_enabled(v39, OS_LOG_TYPE_ERROR)) {
              sub_100657F74();
            }
          }

          uint64_t v15 = 1419LL;
        }

        sub_1001E7178(v15);
LABEL_48:
        if (off_1008EDD98) {
          off_1008EDD98(0LL, a1, a2 + 48);
        }
        return;
      }

      if (sub_1000A86F0())
      {
        sub_1001EE134( (uint64_t)"curContext.u.enforceContext.substate %d, %!",  v24,  v25,  v26,  v27,  v28,  v29,  v30,  dword_1008EDD70);
        uint64_t v31 = (os_log_s *)sub_100086554(0x37u);
        if (os_log_type_enabled(v31, OS_LOG_TYPE_ERROR)) {
          sub_100657F74();
        }
      }

      sub_1001E7178(105LL);
    }

    sub_1001EE2A0();
    goto LABEL_48;
  }

  if (sub_1000A86F0())
  {
    sub_1001EE134((uint64_t)"!SECMGR_IS_INITIALIZED", v3, v4, v5, v6, v7, v8, v9, v40);
    uint64_t v10 = (os_log_s *)sub_100086554(0x37u);
    if (os_log_type_enabled(v10, OS_LOG_TYPE_ERROR)) {
      sub_100657F74();
    }
  }

void sub_1001EA150()
{
  if (dword_1008EDD24 != 2) {
    sub_1001EE2A0();
  }
  DWORD2(xmmword_1008EDD48) = 4;
  uint64_t v0 = sub_10010D2C4(sub_1001EB5A0, (unsigned __int16 *)qword_1008EDD38);
  if ((_DWORD)v0)
  {
    uint64_t v1 = v0;
    if (sub_1000A86F0())
    {
      sub_1001EE134((uint64_t)"OI_DevMgr_BondingDisconnect %!", v2, v3, v4, v5, v6, v7, v8, v1);
      uint64_t v9 = (os_log_s *)sub_100086554(0x37u);
      if (os_log_type_enabled(v9, OS_LOG_TYPE_ERROR)) {
        sub_100657F74();
      }
    }

    sub_1001E737C(v1, v2, v3, v4, v5, v6, v7, v8);
  }

void sub_1001EA1F8(uint64_t a1, uint64_t a2, __n128 a3)
{
  unsigned int v3 = dword_1008EDD24;
  if (HIDWORD(xmmword_1008F6FD8)) {
    BOOL v4 = dword_1008EDD24 == 0;
  }
  else {
    BOOL v4 = 1;
  }
  if (v4)
  {
    if (sub_1000A86F0())
    {
      sub_1001EE134((uint64_t)"!SECMGR_IS_INITIALIZED", v5, v6, v7, v8, v9, v10, v11, v24);
      uint64_t v12 = (os_log_s *)sub_100086554(0x37u);
      if (os_log_type_enabled(v12, OS_LOG_TYPE_ERROR)) {
        sub_100657F74();
      }
    }
  }

  else
  {
    if (!qword_1008EDD28 || !*(void *)(qword_1008EDD28 + 8))
    {
      sub_1001EE2A0();
      unsigned int v3 = dword_1008EDD24;
    }

    if (v3 < 2
      || (!(*(_DWORD *)a2 ^ dword_1008EDD30 | *(unsigned __int16 *)(a2 + 4) ^ (unsigned __int16)word_1008EDD34)
        ? (BOOL v15 = BYTE1(dword_1008EDD40) == 0)
        : (BOOL v15 = 1),
          v15))
    {
      if (sub_1000A86F0())
      {
        sub_1001EE134((uint64_t)"SimplePairingComplete %:, %!", v16, v17, v18, v19, v20, v21, v22, a2);
        uint64_t v23 = (os_log_s *)sub_100086554(0x37u);
        if (os_log_type_enabled(v23, OS_LOG_TYPE_ERROR)) {
          sub_100657F74();
        }
      }
    }

    else
    {
      *(_WORD *)((char *)&dword_1008EDD40 + 1) = 0;
      if (v3 == 3) {
        a3.n128_f64[0] = sub_1001E6A10(1);
      }
    }

    (*(void (**)(uint64_t, uint64_t, __n128))(qword_1008EDD28 + 8))(a2, a1, a3);
  }

uint64_t sub_1001EA358(void *a1, uint64_t a2, uint64_t a3, uint64_t a4, int a5, char a6)
{
  *(void *)&__int128 v64 = a3;
  *((void *)&v64 + 1) = a4;
  uint64_t v63 = 0LL;
  if (sub_1000A86F0())
  {
    sub_1001093A0((uint64_t)&v64);
    sub_1001EE134((uint64_t)"Enforce policy for %:, %s", v10, v11, v12, v13, v14, v15, v16, a2);
    uint64_t v17 = (os_log_s *)sub_100086554(0x37u);
    if (os_log_type_enabled(v17, OS_LOG_TYPE_DEFAULT))
    {
      uint64_t v18 = sub_1001EDDCC();
      *(_DWORD *)__int128 buf = 136446210;
      uint64_t v66 = v18;
      _os_log_impl((void *)&_mh_execute_header, v17, OS_LOG_TYPE_DEFAULT, " %{public}s", buf, 0xCu);
    }
  }

  if (HIDWORD(xmmword_1008F6FD8)) {
    BOOL v19 = dword_1008EDD24 == 0;
  }
  else {
    BOOL v19 = 1;
  }
  if (v19) {
    return 103LL;
  }
  if (qword_1008EDD80 && *(void *)(qword_1008EDD80 + 8))
  {
    if (!a1) {
      goto LABEL_20;
    }
  }

  else
  {
    sub_1001EE2A0();
    if (!a1)
    {
LABEL_20:
      sub_1001EE2A0();
      return 101LL;
    }
  }

  if (!a2) {
    goto LABEL_20;
  }
  if ((dword_1008EDD24 - 2) < 4)
  {
    if (sub_1000A86F0())
    {
      uint64_t v28 = dword_1008EDD24 > 5 ? "unknown" : off_100886320[dword_1008EDD24];
      sub_1001EE134( (uint64_t)"State:  %s, Input Addr %:, Cur Addr %:, Pending Addr %:",  v21,  v22,  v23,  v24,  v25,  v26,  v27,  (uint64_t)v28);
      uint64_t v34 = (os_log_s *)sub_100086554(0x37u);
      if (os_log_type_enabled(v34, OS_LOG_TYPE_DEFAULT))
      {
        uint64_t v35 = sub_1001EDDCC();
        *(_DWORD *)__int128 buf = 136446210;
        uint64_t v66 = v35;
        _os_log_impl((void *)&_mh_execute_header, v34, OS_LOG_TYPE_DEFAULT, " %{public}s", buf, 0xCu);
      }
    }

    if (dword_1008F6EE8) {
      BOOL v36 = 0;
    }
    else {
      BOOL v36 = word_1008F6EEC == 0;
    }
    if (v36)
    {
      uint64_t v20 = 0LL;
      qword_1008F6EE0 = (uint64_t)a1;
      int v45 = *(_DWORD *)a2;
      word_1008F6EEC = *(_WORD *)(a2 + 4);
      dword_1008F6EE8 = v45;
      xmmword_1008F6EF0 = v64;
      LODWORD(qword_1008F6F00) = a5;
      BYTE4(qword_1008F6F00) = a6;
      return v20;
    }

    if (sub_1000A86F0())
    {
      sub_1001EE134( (uint64_t)"Security Mgr Busy with: Cur Addr %:, Pending Addr %:, Input Addr %:",  v37,  v38,  v39,  v40,  v41,  v42,  v43,  (uint64_t)&dword_1008EDD30);
      uint64_t v44 = (os_log_s *)sub_100086554(0x37u);
      if (os_log_type_enabled(v44, OS_LOG_TYPE_ERROR)) {
        sub_100657F74();
      }
    }

    uint64_t v20 = 1404LL;
    goto LABEL_53;
  }

  if (dword_1008EDD24 == 1)
  {
    uint64_t v20 = sub_10010EEE0(a2, &v63);
    if (!(_DWORD)v20)
    {
      uint64_t v30 = (unsigned __int16)word_1008EDDA0;
      if (word_1008EDDA0)
      {
        uint64_t v31 = (void *)qword_1008EDD18;
        while (*v31 != v63)
        {
          v31 += 2;
          if (!--v30) {
            goto LABEL_28;
          }
        }

void sub_1001EA7DC()
{
  if (sub_1000A86F0())
  {
    sub_1001EE134((uint64_t)"Deferred enforcement request", v0, v1, v2, v3, v4, v5, v6, v103);
    uint64_t v7 = (os_log_s *)sub_100086554(0x37u);
    if (os_log_type_enabled(v7, OS_LOG_TYPE_DEFAULT))
    {
      LODWORD(buf) = 136446210;
      *(void *)((char *)&buf + 4) = sub_1001EDDCC();
      _os_log_impl((void *)&_mh_execute_header, v7, OS_LOG_TYPE_DEFAULT, " %{public}s", (uint8_t *)&buf, 0xCu);
    }
  }

  if (!qword_1008EDD28 || !*(void *)(qword_1008EDD28 + 32)) {
    sub_1001EE2A0();
  }
  if (dword_1008EDD24 != 5
    && (!qword_1008EDD38
     || !sub_10012D514(qword_1008EDD38)
     && !sub_10012D5BC(qword_1008EDD38)
     && !sub_10012D5EC(qword_1008EDD38)
     && !sub_10012D61C(qword_1008EDD38)))
  {
    sub_1001EE134( (uint64_t)"Disconnection happened during enforcement, ignoring (enforcementFinish was already called).",  v32,  v33,  v34,  v35,  v36,  v37,  v38,  v103);
    uint64_t v39 = (os_log_s *)sub_100086554(0x37u);
    if (!os_log_type_enabled(v39, OS_LOG_TYPE_ERROR)) {
      return;
    }
    goto LABEL_54;
  }

  if (!qword_1008EDD38
    || !sub_10012D514(qword_1008EDD38)
    && !sub_10012D5BC(qword_1008EDD38)
    && !sub_10012D5EC(qword_1008EDD38)
    && !sub_10012D61C(qword_1008EDD38))
  {
    sub_1001EE134((uint64_t)"HCI handle not valid can not enforce request", v16, v17, v18, v19, v20, v21, v22, v103);
    uint64_t v23 = (os_log_s *)sub_100086554(0x37u);
    if (!os_log_type_enabled(v23, OS_LOG_TYPE_ERROR)) {
      return;
    }
    goto LABEL_54;
  }

  if (!*(_DWORD *)(qword_1008EDD38 + 148))
  {
    uint64_t v40 = sub_10010C890(qword_1008EDD38);
    if ((_DWORD)v40)
    {
      uint64_t v41 = v40;
      if (sub_1000A86F0())
      {
        sub_1001EE134((uint64_t)"OI_DevMgr_aclActivity failed with %!", v42, v43, v44, v45, v46, v47, v48, v41);
        uint64_t v49 = (os_log_s *)sub_100086554(0x37u);
        if (os_log_type_enabled(v49, OS_LOG_TYPE_ERROR)) {
          sub_100657858();
        }
      }
    }
  }

  if (dword_1008EDD24 != 5) {
    sub_1001EE2A0();
  }
  if (dword_1008EDD70) {
    sub_1001EE2A0();
  }
  if (!qword_1008EDD80 || !*(void *)(qword_1008EDD80 + 8)) {
    sub_1001EE2A0();
  }
  if (dword_1008EDD24 != 5)
  {
    uint64_t v31 = dword_1008EDD24 > 5 ? "unknown" : off_100886320[dword_1008EDD24];
    sub_1001EE134((uint64_t)"enforcementDeferredRequest - %s, %!", v24, v25, v26, v27, v28, v29, v30, (uint64_t)v31);
    uint64_t v61 = (os_log_s *)sub_100086554(0x37u);
    if (!os_log_type_enabled(v61, OS_LOG_TYPE_ERROR)) {
      return;
    }
LABEL_54:
    sub_100657F74();
    return;
  }

  if (dword_1008EDD70)
  {
    if (sub_1000A86F0())
    {
      else {
        uint64_t v15 = off_100886388[dword_1008EDD70];
      }
      sub_1001EE134( (uint64_t)"enforcementDeferredRequest - enforceSubstate %s, %!",  v8,  v9,  v10,  v11,  v12,  v13,  v14,  (uint64_t)v15);
      uint64_t v62 = (os_log_s *)sub_100086554(0x37u);
      if (os_log_type_enabled(v62, OS_LOG_TYPE_ERROR)) {
        sub_100657F74();
      }
    }

    uint64_t v60 = 105LL;
    goto LABEL_59;
  }

  uint64_t v50 = (unsigned __int16)word_1008EDDA0;
  if (!word_1008EDDA0)
  {
LABEL_48:
    if (sub_1000A86F0())
    {
      sub_1001EE134((uint64_t)"enforcementDeferredRequest - no connection %!", v52, v53, v54, v55, v56, v57, v58, 1408LL);
      uint64_t v59 = (os_log_s *)sub_100086554(0x37u);
      if (os_log_type_enabled(v59, OS_LOG_TYPE_ERROR)) {
        sub_100657F74();
      }
    }

    uint64_t v60 = 1408LL;
    goto LABEL_59;
  }

  uint64_t v51 = qword_1008EDD18 + 8;
  while (*(void *)(v51 - 8) != qword_1008EDD38)
  {
    v51 += 16LL;
    if (!--v50) {
      goto LABEL_48;
    }
  }

  if (!byte_1008EDD5C || *(_BYTE *)(qword_1008EDD38 + 212))
  {
    __int128 buf = 0uLL;
    unsigned int v108 = 0;
    uint64_t v107 = 0LL;
    else {
      unsigned int v63 = (*(uint64_t (**)(int *, __int128 *))(qword_1008EDD28 + 32))(&dword_1008EDD30, &buf);
    }
    char v64 = *(_BYTE *)(qword_1008EDD38 + 277) & (byte_1008F6D20 > 3u);
    if (sub_1000A86F0())
    {
      sub_1001EE134( (uint64_t)"Deferred security enforcement with linkKeyExists %d, remoteSupportsSSP %d, bothTwoDotOne %d, seclevel %d",  v65,  v66,  v67,  v68,  v69,  v70,  v71,  v63);
      uint64_t v72 = (os_log_s *)sub_100086554(0x37u);
      if (os_log_type_enabled(v72, OS_LOG_TYPE_DEFAULT))
      {
        *(_DWORD *)uint64_t v104 = 136446210;
        uint64_t v105 = sub_1001EDDCC();
        _os_log_impl((void *)&_mh_execute_header, v72, OS_LOG_TYPE_DEFAULT, " %{public}s", v104, 0xCu);
      }
    }

    if (dword_1008EDD60 != 1)
    {
      if (dword_1008EDD60)
      {
        if (sub_1000A86F0())
        {
          uint64_t v74 = dword_1008EDD60;
          sub_1001093A0((uint64_t)&off_1008EDD48);
          sub_1001EE134((uint64_t)"%d specified for %s, %!", v75, v76, v77, v78, v79, v80, v81, v74);
          unsigned int v82 = (os_log_s *)sub_100086554(0x37u);
          if (os_log_type_enabled(v82, OS_LOG_TYPE_ERROR)) {
            sub_100657F74();
          }
        }

        uint64_t v60 = 1418LL;
        goto LABEL_59;
      }

      goto LABEL_93;
    }

    if ((v64 & 1) != 0)
    {
LABEL_98:
      if (sub_1000A86F0())
      {
        uint64_t v73 = dword_1008EDD60;
        sub_1001E9A5C(HIBYTE(dword_1008EDD40), dword_1008EDD60, v108);
        sub_1001EE134((uint64_t)"Security level %d: state %s, key %s sufficient", v93, v94, v95, v96, v97, v98, v99, v73);
        uint64_t v100 = (os_log_s *)sub_100086554(0x37u);
        if (os_log_type_enabled(v100, OS_LOG_TYPE_DEFAULT))
        {
          uint64_t v101 = sub_1001EDDCC();
          *(_DWORD *)uint64_t v104 = 136446210;
          uint64_t v105 = v101;
          _os_log_impl((void *)&_mh_execute_header, v100, OS_LOG_TYPE_DEFAULT, " %{public}s", v104, 0xCu);
        }
      }

      *(_BYTE *)(v51 + 4) = 1;
      if (*(_DWORD *)v51) {
        unsigned int v102 = v63;
      }
      else {
        unsigned int v102 = 0;
      }
      if (v102 != 1 || !sub_1001E9A5C(HIBYTE(dword_1008EDD40), dword_1008EDD60, v108))
      {
        sub_1001EB470();
        return;
      }

      if (*(_DWORD *)v51 != 2)
      {
        sub_1001EB33C();
        return;
      }
    }

LABEL_93:
    uint64_t v60 = 0LL;
LABEL_59:
    sub_1001E7178(v60);
    return;
  }

  uint64_t v83 = sub_1001EE6E8((uint64_t)sub_1001EA7DC, 0LL, 3, 0LL);
  if ((_DWORD)v83)
  {
    uint64_t v84 = v83;
    if (sub_1000A86F0())
    {
      sub_1001EE134( (uint64_t)"enforcementDeferredRequest - Could not register function %!",  v85,  v86,  v87,  v88,  v89,  v90,  v91,  v84);
      uint64_t v92 = (os_log_s *)sub_100086554(0x37u);
      if (os_log_type_enabled(v92, OS_LOG_TYPE_ERROR)) {
        sub_100657F74();
      }
    }

    sub_10010CDEC((uint64_t)&dword_1008EDD30);
    uint64_t v60 = 1421LL;
    goto LABEL_59;
  }

            LODWORD(__p[0]) = 0;
            unsigned int v63 = 0LL;
            uint64_t v62 = 0;
            sub_1003D55EC(*a1, __p, (_DWORD *)&v63 + 1, &v63, &v62);
            uint64_t v57 = (void *)objc_claimAutoreleasedReturnValue( +[CBProductInfo productInfoWithProductID:]( &OBJC_CLASS___CBProductInfo,  "productInfoWithProductID:",  v63));
            if (([v57 flags] & 0x100000) != 0 && HIDWORD(v63) == 76)
            {
              uint64_t v58 = *a2 == 8;

              if (v58) {
                uint64_t v41 = 0;
              }
              if (v58) {
                goto LABEL_103;
              }
            }

            else
            {
            }

            if (a3)
            {
              sub_100235AF0((uint64_t)a1, *a2, buf);
              (*(void (**)(uint64_t, _BYTE *))(*(void *)v39 + 24LL))(v39, buf);
              if ((buf[23] & 0x80000000) != 0) {
                operator delete(*(void **)buf);
              }
            }

            goto LABEL_103;
        }
      }

      *(void *)__int128 buf = a2;
      uint64_t v43 = sub_100240788(v7, a2, (uint64_t)&unk_1006C2518, (_BYTE **)buf)[5];
      sub_100235A1C(a1, *a2, buf);
      (*(void (**)(uint64_t *, _BYTE *))(*v43 + 72))(v43, buf);
      if ((buf[23] & 0x80000000) != 0) {
        operator delete(*(void **)buf);
      }
      goto LABEL_74;
    }
  }

  uint64_t v13 = (os_log_s *)qword_1008F7560;
  if (os_log_type_enabled((os_log_t)qword_1008F7560, OS_LOG_TYPE_DEFAULT))
  {
    sub_1002359E8(*a2, __p);
    uint64_t v14 = v65 >= 0 ? __p : (void **)__p[0];
    uint64_t v15 = a2[2];
    uint64_t v16 = a2[3] == 1 ? "Yes" : "No";
    uint64_t v17 = a2[3] ? "No" : "Yes";
    *(_DWORD *)__int128 buf = 136446978;
    *(void *)&uint8_t buf[4] = v14;
    *(_WORD *)&buf[12] = 1024;
    *(_DWORD *)&buf[14] = v15;
    *(_WORD *)&buf[18] = 2082;
    *(void *)&buf[20] = v16;
    uint64_t v67 = 2082;
    uint64_t v68 = v17;
    _os_log_impl( (void *)&_mh_execute_header,  v13,  OS_LOG_TYPE_DEFAULT,  "Create Battery for %{public}s battery, battery level %d, charging = %{public}s fully charged = %{public}s",  buf,  0x26u);
    if (v65 < 0) {
      operator delete(__p[0]);
    }
  }

  uint64_t v18 = sub_1002E91B0(*a1);
  *(void *)__int128 buf = a2;
  sub_100240788(v7, a2, (uint64_t)&unk_1006C2518, (_BYTE **)buf)[5] = v18;
  *(void *)__int128 buf = a2;
  uint64_t v19 = sub_100240788(v7, a2, (uint64_t)&unk_1006C2518, (_BYTE **)buf);
  (*(void (**)(uint64_t *, void))(*v19[5] + 48))(v19[5], a2[2]);
  *(void *)__int128 buf = a2;
  uint64_t v20 = sub_100240788(v7, a2, (uint64_t)&unk_1006C2518, (_BYTE **)buf)[5];
  if (a2[3]) {
    uint64_t v21 = a2[3] == 1;
  }
  else {
    uint64_t v21 = 2LL;
  }
  (*(void (**)(uint64_t *, uint64_t))(*v20 + 64))(v20, v21);
  *(void *)__int128 buf = a2;
  uint64_t v22 = sub_100240788(v7, a2, (uint64_t)&unk_1006C2518, (_BYTE **)buf)[5];
  sub_1003FE1B4((unsigned __int8 *)(*a1 + 128), buf);
  (*(void (**)(uint64_t *, _BYTE *))(*v22 + 32))(v22, buf);
  if ((buf[23] & 0x80000000) != 0) {
    operator delete(*(void **)buf);
  }
  sub_100235A1C(a1, *a2, buf);
  if ((buf[23] & 0x80000000) == 0)
  {
    if (!buf[23]) {
      goto LABEL_35;
    }
LABEL_33:
    *(void *)__int128 buf = a2;
    uint64_t v24 = sub_100240788(v7, a2, (uint64_t)&unk_1006C2518, (_BYTE **)buf)[5];
    sub_100235A1C(a1, *a2, buf);
    (*(void (**)(uint64_t *, _BYTE *))(*v24 + 72))(v24, buf);
    if ((buf[23] & 0x80000000) != 0) {
      operator delete(*(void **)buf);
    }
    goto LABEL_35;
  }

  uint64_t v23 = *(void *)&buf[8];
  operator delete(*(void **)buf);
  if (v23) {
    goto LABEL_33;
  }
LABEL_35:
  *(void *)__int128 buf = a2;
  uint64_t v25 = sub_100240788(v7, a2, (uint64_t)&unk_1006C2518, (_BYTE **)buf)[5];
  else {
    uint64_t v26 = dword_1006BF5FC[(char)(*a2 - 1)];
  }
  (*(void (**)(uint64_t *, uint64_t))(*v25 + 40))(v25, v26);
  sub_1003D7C3C(*a1);
  uint64_t v27 = *a2;
  if (v27 <= 0x10 && ((1 << v27) & 0x10116) != 0)
  {
    uint64_t v28 = a2[3];
    if (v28 >= 3) {
      uint64_t v29 = 0;
    }
    else {
      uint64_t v29 = 0x20103u >> (8 * v28);
    }
    sub_1003D8258(*a1, a2[2], *a2);
    sub_1003D8380(*a1, v29, v27);
  }

  LODWORD(__p[0]) = 0;
  unsigned int v63 = 0LL;
  uint64_t v62 = 0;
  sub_1003D55EC(*a1, __p, (_DWORD *)&v63 + 1, &v63, &v62);
  uint64_t v30 = (void *)objc_claimAutoreleasedReturnValue( +[CBProductInfo productInfoWithProductID:]( &OBJC_CLASS___CBProductInfo,  "productInfoWithProductID:",  v63));
  if (([v30 flags] & 0x100000) != 0 && HIDWORD(v63) == 76)
  {
    uint64_t v31 = *a2 == 8;

    uint64_t v32 = !v31;
    if (v31) {
      goto LABEL_104;
    }
  }

  else
  {

    uint64_t v32 = 1LL;
  }

  if (a3)
  {
    *(void *)__int128 buf = a2;
    uint64_t v33 = sub_100240788(v7, a2, (uint64_t)&unk_1006C2518, (_BYTE **)buf)[5];
    sub_100235AF0((uint64_t)a1, *a2, buf);
    (*(void (**)(uint64_t *, _BYTE *))(*v33 + 24))(v33, buf);
    if ((buf[23] & 0x80000000) != 0) {
      operator delete(*(void **)buf);
    }
  }
}

uint64_t sub_1001EAEEC()
{
  else {
    uint64_t v0 = off_100886320[dword_1008EDD24];
  }
  sub_1001EE0E4("\nsecmgrState: %s\n", v0);
  int v1 = dword_1008EDD24;
  if ((dword_1008EDD24 - 2) <= 3)
  {
    sub_1001EE0E4("current context:\n");
    sub_1001EE0E4("   addr:          %:\n", &dword_1008EDD30);
    sub_1001EE0E4("   hciHandle:     0x%x\n", &qword_1008EDD38);
    sub_1001EE0E4("   mitm reqd:     %B\n", &dword_1008EDD40);
    sub_1001EE0E4("   sspInProgress: %B\n", (char *)&dword_1008EDD40 + 1);
    sub_1001EE0E4("   isRemoteSSP:   %B\n", (char *)&dword_1008EDD40 + 2);
    int v1 = dword_1008EDD24;
  }

  switch(v1)
  {
    case 5:
      else {
        uint64_t v3 = off_100886388[dword_1008EDD70];
      }
      sub_1001EE0E4("   substate:      %s\n", v3);
      sub_1001EE0E4("   cookie:        0x%x\n", dword_1008EDD58);
      sub_1001EE0E4("   incomingCnct:  %B\n", byte_1008EDD5C);
      else {
        uint64_t v4 = off_1008863A8[dword_1008EDD60];
      }
      sub_1001EE0E4("   secLevel:      %s\n", v4);
      break;
    case 3:
      sub_1001EE0E4("   authReqs:      %d\n");
      goto LABEL_22;
    case 2:
      else {
        uint64_t v2 = off_100886350[dword_1008EDD50];
      }
      sub_1001EE0E4("   substate:      %s\n", v2);
      sub_1001EE0E4("   finalStatus:   %!\n", dword_1008EDD54);
      break;
    default:
      goto LABEL_22;
  }

  sub_1001EE0E4("   callback:      0x%x\n");
LABEL_22:
  sub_1001EE0E4("bondable: %B\n", byte_1008EDD21);
  sub_1001EE0E4("Connections known to secmgr: %d\n", (unsigned __int16)word_1008EDDA0);
  if (word_1008EDDA0)
  {
    uint64_t v5 = 0LL;
    unint64_t v6 = 0LL;
    do
    {
      sub_1001EE0E4("   %: ", *(void *)(qword_1008EDD18 + v5) + 48LL);
      uint64_t v7 = *(int *)(qword_1008EDD18 + v5 + 8);
      uint64_t v8 = "unknown";
      sub_1001EE0E4(", state %s", v8);
      if (*(_BYTE *)(qword_1008EDD18 + v5 + 13)) {
        sub_1001EE0E4(", auto-rejecting");
      }
      sub_1001EE0E4("\n");
      ++v6;
      v5 += 16LL;
    }

    while (v6 < (unsigned __int16)word_1008EDDA0);
  }

  sub_1001EE0E4( "Pending Enforcement Req: %:, cb %x, cookie %x, incoming %d\n",  &dword_1008F6EE8,  qword_1008F6EE0,  qword_1008F6F00,  BYTE4(qword_1008F6F00));
  return sub_1001EE0E4("\n");
}

void sub_1001EB248(uint64_t a1)
{
  uint64_t v1 = *(void *)(a1 + 8);
  uint64_t v2 = v1 + 8;
  int v3 = sub_1001EA358( *(void **)v1,  v1 + 8,  *(void *)(v1 + 16),  *(void *)(v1 + 24),  *(_DWORD *)(v1 + 32),  *(_BYTE *)(v1 + 36));
  if (v3 && v3 != 1301)
  {
    if (sub_1000A86F0())
    {
      sub_1001EE134((uint64_t)"PolicyEnforceReq failed addr %:, status %!", v4, v5, v6, v7, v8, v9, v10, v2);
      uint64_t v11 = (os_log_s *)sub_100086554(0x37u);
      if (os_log_type_enabled(v11, OS_LOG_TYPE_ERROR)) {
        sub_100657F74();
      }
    }

    sub_1001EAEEC();
    uint64_t v12 = sub_10010CDEC(v2);
    if ((_DWORD)v12)
    {
      uint64_t v13 = v12;
      if (sub_1000A86F0())
      {
        sub_1001EE134((uint64_t)"PolicyEnforceReq Disconnect failed %!", v14, v15, v16, v17, v18, v19, v20, v13);
        uint64_t v21 = (os_log_s *)sub_100086554(0x37u);
        if (os_log_type_enabled(v21, OS_LOG_TYPE_ERROR)) {
          sub_100657F74();
        }
      }
    }

    sub_1001EE2A0();
  }

void sub_1001EB33C()
{
  if (sub_1000A86F0())
  {
    sub_1001EE134((uint64_t)"Send set encryption on", v0, v1, v2, v3, v4, v5, v6, v18);
    uint64_t v7 = (os_log_s *)sub_100086554(0x37u);
    if (os_log_type_enabled(v7, OS_LOG_TYPE_DEFAULT))
    {
      *(_DWORD *)__int128 buf = 136446210;
      uint64_t v20 = sub_1001EDDCC();
      _os_log_impl((void *)&_mh_execute_header, v7, OS_LOG_TYPE_DEFAULT, " %{public}s", buf, 0xCu);
    }
  }

  uint64_t v8 = sub_100128D24(16LL);
  if ((_DWORD)v8)
  {
    uint64_t v9 = v8;
    if (sub_1000A86F0())
    {
      sub_1001EE134((uint64_t)"OI_HCICMD_SetConnectionEncryption %!", v10, v11, v12, v13, v14, v15, v16, v9);
      uint64_t v17 = (os_log_s *)sub_100086554(0x37u);
      if (os_log_type_enabled(v17, OS_LOG_TYPE_ERROR)) {
        sub_100657F74();
      }
    }

    sub_1001E7178(v9);
  }

  else
  {
    dword_1008EDD70 = 2;
  }

void sub_1001EB470()
{
  if (sub_1000A86F0())
  {
    sub_1001EE134((uint64_t)"Send authentication request", v0, v1, v2, v3, v4, v5, v6, v18);
    uint64_t v7 = (os_log_s *)sub_100086554(0x37u);
    if (os_log_type_enabled(v7, OS_LOG_TYPE_DEFAULT))
    {
      *(_DWORD *)__int128 buf = 136446210;
      uint64_t v20 = sub_1001EDDCC();
      _os_log_impl((void *)&_mh_execute_header, v7, OS_LOG_TYPE_DEFAULT, " %{public}s", buf, 0xCu);
    }
  }

  uint64_t v8 = sub_100128D24(15LL);
  if ((_DWORD)v8)
  {
    uint64_t v9 = v8;
    if (sub_1000A86F0())
    {
      sub_1001EE134((uint64_t)"OI_HCICMD_AuthenticationRequested %!", v10, v11, v12, v13, v14, v15, v16, v9);
      uint64_t v17 = (os_log_s *)sub_100086554(0x37u);
      if (os_log_type_enabled(v17, OS_LOG_TYPE_ERROR)) {
        sub_100657F74();
      }
    }

    sub_1001E7178(v9);
  }

  else
  {
    dword_1008EDD70 = 1;
  }

void sub_1001EB5A0( uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  if ((_DWORD)a1)
  {
    if (sub_1000A86F0())
    {
      sub_1001EE134((uint64_t)"bondingDisconnectCb %!", a2, a3, a4, a5, a6, a7, a8, a1);
      uint64_t v9 = (os_log_s *)sub_100086554(0x37u);
      if (os_log_type_enabled(v9, OS_LOG_TYPE_ERROR)) {
        sub_100657F74();
      }
    }
  }

  sub_1001E737C(a1, a2, a3, a4, a5, a6, a7, a8);
}

void sub_1001EB614(uint64_t a1)
{
  if (dword_1008EDD24 != 2) {
    sub_1001EE2A0();
  }
  if (!(void)xmmword_1008EDD48) {
    sub_1001EE2A0();
  }
  if (!HIDWORD(xmmword_1008EDD48)) {
    HIDWORD(xmmword_1008EDD48) = a1;
  }
  sub_10010D06C();
  DWORD2(xmmword_1008EDD48) = 6;
  double v2 = sub_1001E6A10(1);
  if ((void)xmmword_1008EDD48)
  {
    ((void (*)(void, double))xmmword_1008EDD48)(HIDWORD(xmmword_1008EDD48), v2);
  }

  else if (sub_1000A86F0())
  {
    sub_1001EE134((uint64_t)"bondingFinishWriteAuthCB %!, %!", v3, v4, v5, v6, v7, v8, v9, a1);
    uint64_t v10 = (os_log_s *)sub_100086554(0x37u);
    if (os_log_type_enabled(v10, OS_LOG_TYPE_ERROR)) {
      sub_100657F74();
    }
  }

__int16 *sub_1001EB6F4(unint64_t a1)
{
  word_1008EDDA2 = 30768;
  char v1 = a0123456789abcd[(a1 >> 8) & 0xF];
  byte_1008EDDA4 = a0123456789abcd[(unint64_t)a1 >> 12];
  byte_1008EDDA5 = v1;
  byte_1008EDDA6 = a0123456789abcd[a1 >> 4];
  byte_1008EDDA7 = a0123456789abcd[a1 & 0xF];
  byte_1008EDDA8 = 0;
  return &word_1008EDDA2;
}

const char *sub_1001EB74C(unsigned int *a1)
{
  if (!a1) {
    return "invalid";
  }
  if (*(void *)a1 == 0x10000000000001LL && *((void *)a1 + 1) == 0x20000EE02000080LL) {
    return "SyncMLServer";
  }
  if (*(void *)a1 == 0x10000000000002LL && *((void *)a1 + 1) == 0x20000EE02000080LL) {
    return "SyncMLClient";
  }
  if (*(void *)a1 == 0xFECACADE00000000LL && *((void *)a1 + 1) == 0xFECACADEFECACADELL) {
    return "D2D";
  }
  if (*(void *)a1 == 0xDEFACADE00000000LL && *((void *)a1 + 1) == 0xFECACADEAFDECADELL) {
    return "WiapGateWay";
  }
  if (*(void *)a1 == 0xDEFACADE00000000LL && *((void *)a1 + 1) == 0xFFCACADEAFDECADELL) {
    return "WiapSink";
  }
  if (*(void *)a1 == 0x5F41191DC327ED08LL && *((void *)a1 + 1) == 0x770A6A10A222F286LL) {
    return "WiapGateWay_v2";
  }
  if (*(void *)a1 == 0x5F41191DC327ED08LL && *((void *)a1 + 1) == 0x780A6A10A222F286LL) {
    return "WiapSink_v2";
  }
  if (*(void *)a1 == 0x14DAD0B74EC2172LL && *((void *)a1 + 1) == 0x2A72E02B7B99778FLL) {
    return "AapServer";
  }
  if (*(void *)a1 == 0xDE49F4074B7C6F4BLL && *((void *)a1 + 1) == 0x298F720443ABB9B0LL) {
    return "AapService";
  }
  if (*(void *)a1 == 0x364B2E573619F31FLL && *((void *)a1 + 1) == 0xF4A61A9B40B2BFA2LL) {
    return "AapClient";
  }
  if (*(void *)a1 == 0x2A43B1001E0DE104LL && *((void *)a1 + 1) == 0x41F93A98BADD64B7LL) {
    return "Magnet";
  }
  if (*(void *)a1 == 0xA24041CD484388ECLL && *((void *)a1 + 1) == 0xD31FBF505D572797LL) {
    return "Carplay";
  }
  if (*(void *)a1 == 0x1C454DE166248D2DLL && *((void *)a1 + 1) == 0x1A29EAAB0173BC88LL) {
    return "CarplayGateway";
  }
  if (*(void *)(a1 + 1) == 0x8000008000100000LL && a1[3] == -80438433) {
    return sub_1001EBA4C(*a1);
  }
  else {
    return "unknown";
  }
}

const char *sub_1001EBA4C(unint64_t a1)
{
  if ((int)a1 <= 4352)
  {
    if ((int)a1 > 255)
    {
      if ((int)a1 > 4096)
      {
        if ((_DWORD)a1 == 4097) {
          return "BrowseGroupDescriptorServiceClassID";
        }
        if ((_DWORD)a1 == 4098) {
          return "PublicBrowseGroup";
        }
      }

      else
      {
        if ((_DWORD)a1 == 256) {
          return "L2CAP";
        }
        if ((_DWORD)a1 == 4096) {
          return "ServiceDiscoveryServerServiceClassID";
        }
      }

      goto LABEL_111;
    }

    uint64_t result = "NULL";
    switch((int)a1)
    {
      case 0:
        return result;
      case 1:
        uint64_t result = "SDP";
        break;
      case 2:
        uint64_t result = "UDP";
        break;
      case 3:
        uint64_t result = "RFCOMM";
        break;
      case 4:
        uint64_t result = "TCP";
        break;
      case 5:
        uint64_t result = "TCS_BIN";
        break;
      case 6:
        uint64_t result = "TCS_AT";
        break;
      case 8:
        uint64_t result = "OBEX";
        break;
      case 9:
        uint64_t result = "IP";
        break;
      case 10:
        uint64_t result = "FTP";
        break;
      case 12:
        uint64_t result = "HTTP";
        break;
      case 14:
        uint64_t result = "WSP";
        break;
      case 15:
        uint64_t result = "BNEP";
        break;
      case 16:
        uint64_t result = "UPNP";
        break;
      case 17:
        uint64_t result = "HIDP";
        break;
      case 18:
        uint64_t result = "HardcopyControlChannel";
        break;
      case 20:
        uint64_t result = "HardcopyDataChannel";
        break;
      case 22:
        uint64_t result = "HardcopyNotification";
        break;
      case 23:
        uint64_t result = "AVCTP";
        break;
      case 25:
        uint64_t result = "AVDTP";
        break;
      default:
        goto LABEL_111;
    }
  }

  else
  {
    if ((int)a1 <= 4607)
    {
      switch((int)a1)
      {
        case 4353:
          uint64_t result = "SerialPort";
          break;
        case 4354:
          uint64_t result = "LANAccessUsingPPP";
          break;
        case 4355:
          uint64_t result = "DialupNetworking";
          break;
        case 4356:
          uint64_t result = "IrMCSync";
          break;
        case 4357:
          uint64_t result = "OBEXObjectPush";
          break;
        case 4358:
          uint64_t result = "OBEXFileTransfer";
          break;
        case 4359:
          uint64_t result = "IrMCSyncCommand";
          break;
        case 4360:
          uint64_t result = "Headset";
          break;
        case 4361:
          uint64_t result = "CordlessTelephony";
          break;
        case 4362:
          uint64_t result = "AudioSource";
          break;
        case 4363:
          uint64_t result = "AudioSink";
          break;
        case 4364:
          uint64_t result = "AV_RemoteControlTarget";
          break;
        case 4365:
          uint64_t result = "AdvancedAudioDistribution";
          break;
        case 4366:
          uint64_t result = "AV_RemoteControl";
          break;
        case 4367:
          uint64_t result = "AV_RemoteControlController";
          break;
        case 4368:
          uint64_t result = "Intercom";
          break;
        case 4369:
          uint64_t result = "Fax";
          break;
        case 4370:
          uint64_t result = "HeadsetAudioGateway";
          break;
        case 4371:
          uint64_t result = "WAP";
          break;
        case 4372:
          uint64_t result = "WAP_CLIENT";
          break;
        case 4373:
          uint64_t result = "PANU";
          break;
        case 4374:
          uint64_t result = "NAP";
          break;
        case 4375:
          uint64_t result = "GN";
          break;
        case 4376:
          uint64_t result = "DirectPrinting";
          break;
        case 4377:
          uint64_t result = "ReferencePrinting";
          break;
        case 4378:
          uint64_t result = "Imaging";
          break;
        case 4379:
          uint64_t result = "ImagingResponder";
          break;
        case 4380:
          uint64_t result = "ImagingAutomaticArchive";
          break;
        case 4381:
          uint64_t result = "ImagingReferencedObjects";
          break;
        case 4382:
          uint64_t result = "Handsfree";
          break;
        case 4383:
          uint64_t result = "HandsfreeAudioGateway";
          break;
        case 4384:
          uint64_t result = "DirectPrintingReferenceObjectsService";
          break;
        case 4385:
          uint64_t result = "ReflectedUI";
          break;
        case 4386:
          uint64_t result = "BasicPrinting";
          break;
        case 4387:
          uint64_t result = "PrintingStatus";
          break;
        case 4388:
          uint64_t result = "HumanInterfaceDeviceService";
          break;
        case 4389:
          uint64_t result = "HardcopyCableReplacement";
          break;
        case 4390:
          uint64_t result = "HCR_Print";
          break;
        case 4391:
          uint64_t result = "HCR_Scan";
          break;
        case 4392:
          uint64_t result = "Common_ISDN_Access";
          break;
        case 4393:
          uint64_t result = "VideoConferencingGW";
          break;
        case 4394:
          uint64_t result = "UID_MT";
          break;
        case 4395:
          uint64_t result = "UID_TA";
          break;
        case 4396:
          uint64_t result = "Audio_Video";
          break;
        case 4397:
          uint64_t result = "SIM_Access";
          break;
        case 4398:
          uint64_t result = "PhonebookAccessClient";
          break;
        case 4399:
          uint64_t result = "PhonebookAccessServer";
          break;
        case 4400:
          uint64_t result = "PhonebookAccess";
          break;
        case 4401:
          uint64_t result = "Headset_HS";
          break;
        case 4402:
          uint64_t result = "Message_Access_Server";
          break;
        case 4403:
          uint64_t result = "OI_UUID_Message_Notification_Server";
          break;
        case 4404:
          uint64_t result = "OI_UUID_Message_Access_Profile";
          break;
        default:
          goto LABEL_111;
      }

      return result;
    }

    if ((int)a1 > 4863)
    {
      if ((int)a1 <= 5119)
      {
        switch((int)a1)
        {
          case 4864:
            uint64_t result = "ESDP_UPNP_IP_PAN";
            break;
          case 4865:
            uint64_t result = "ESDP_UPNP_IP_LAP";
            break;
          case 4866:
            uint64_t result = "ESDP_UPNP_IP_L2CAP";
            break;
          case 4867:
            uint64_t result = "VideoSource";
            break;
          case 4868:
            uint64_t result = "VideoSink";
            break;
          case 4869:
            uint64_t result = "VideoDistribution";
            break;
          default:
            goto LABEL_111;
        }

        return result;
      }

      if ((int)a1 <= 5121)
      {
        if ((_DWORD)a1 == 5120) {
          return "Health_Device_Profile";
        }
        else {
          return "Health_Device_Profile_Source";
        }
      }

      if ((_DWORD)a1 == 5122) {
        return "Health_Device_Profile_Sink";
      }
      if ((_DWORD)a1 == 6145) {
        return "GATT";
      }
LABEL_111:
      uint64_t result = (const char *)&word_1008EDDA2;
      word_1008EDDA2 = 30768;
      byte_1008EDDA4 = a0123456789abcd[(unsigned __int16)a1 >> 12];
      byte_1008EDDA5 = a0123456789abcd[(a1 >> 8) & 0xF];
      byte_1008EDDA6 = a0123456789abcd[a1 >> 4];
      byte_1008EDDA7 = a0123456789abcd[a1 & 0xF];
      byte_1008EDDA8 = 0;
      return result;
    }

    switch((int)a1)
    {
      case 4608:
        uint64_t result = "PnPInformation";
        break;
      case 4609:
        uint64_t result = "GenericNetworking";
        break;
      case 4610:
        uint64_t result = "GenericFileTransfer";
        break;
      case 4611:
        uint64_t result = "GenericAudio";
        break;
      case 4612:
        uint64_t result = "GenericTelephony";
        break;
      case 4613:
        uint64_t result = "UPNP_Service";
        break;
      case 4614:
        uint64_t result = "UPNP_IP_Service";
        break;
      default:
        goto LABEL_111;
    }
  }

  return result;
}

void *sub_1001EC038(uint64_t a1, uint64_t a2)
{
  uint64_t result = sub_1000B17F4(0x28uLL);
  if (result)
  {
    *uint64_t result = a1;
    result[1] = a2;
    result[2] = 0LL;
    result[3] = 0LL;
    *((_DWORD *)result + 8) = 0;
  }

  return result;
}

void sub_1001EC070(void *ptr)
{
  if (ptr)
  {
    while (1)
    {
      double v2 = (void *)ptr[2];
      if (!v2) {
        break;
      }
      ptr[2] = v2[1];
      uint64_t v3 = (void (*)(void))ptr[1];
      if (v3) {
        v3(*v2);
      }
      sub_1000B1838(v2);
    }

    sub_1000B1838(ptr);
  }

void sub_1001EC0C4(uint64_t a1)
{
  uint64_t v2 = a1 + 16;
  char v1 = *(void **)(a1 + 16);
  if (v1)
  {
    do
    {
      *(void *)(a1 + 16) = v1[1];
      uint64_t v4 = *(void (**)(void))(a1 + 8);
      if (v4) {
        v4(*v1);
      }
      sub_1000B1838(v1);
      char v1 = *(void **)v2;
    }

    while (*(void *)v2);
  }

  *(void *)uint64_t v2 = 0LL;
  *(void *)(v2 + 8) = 0LL;
  *(_DWORD *)(v2 + 16) = 0;
}

void *sub_1001EC124(uint64_t a1, uint64_t a2, uint64_t a3)
{
  uint64_t result = sub_1001EC168((void (**)(void *, uint64_t, uint64_t))a1, a2, a3);
  if (result)
  {
    uint64_t v5 = *(void *)(a1 + 24);
    result[1] = *(void *)(a1 + 16);
    *(void *)(a1 + 16) = result;
    if (!v5) {
      *(void *)(a1 + 24) = result;
    }
    ++*(_DWORD *)(a1 + 32);
  }

  return result;
}

void *sub_1001EC168(void (**a1)(void *, uint64_t, uint64_t), uint64_t a2, uint64_t a3)
{
  uint64_t v6 = sub_1000B17F4(0x10uLL);
  uint64_t v7 = v6;
  if (v6)
  {
    v6[1] = 0LL;
    if (*a1)
    {
      uint64_t v8 = sub_1000B17F4(a3);
      *uint64_t v7 = v8;
      if (v8) {
        (*a1)(v8, a2, a3);
      }
    }

    else
    {
      *uint64_t v6 = a2;
    }
  }

  return v7;
}

void *sub_1001EC1DC(uint64_t a1, uint64_t a2, uint64_t a3)
{
  uint64_t result = sub_1001EC168((void (**)(void *, uint64_t, uint64_t))a1, a2, a3);
  if (result)
  {
    result[1] = 0LL;
    uint64_t v5 = *(void *)(a1 + 24);
    if (v5) {
      *(void *)(v5 + 8) = result;
    }
    *(void *)(a1 + 24) = result;
    if (!*(void *)(a1 + 16)) {
      *(void *)(a1 + 16) = result;
    }
    ++*(_DWORD *)(a1 + 32);
  }

  return result;
}

void *sub_1001EC22C(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t (*a4)(void, uint64_t))
{
  uint64_t v8 = (void *)(a1 + 16);
  uint64_t v7 = *(void **)(a1 + 16);
  if (v7)
  {
    uint64_t v10 = 0LL;
    while (1)
    {
      uint64_t v11 = v7;
      uint64_t result = (void *)a4(*v7, a2);
      if (!(_DWORD)result) {
        break;
      }
      if ((int)result >= 1)
      {
        uint64_t result = sub_1001EC168((void (**)(void *, uint64_t, uint64_t))a1, a2, a3);
        if (!result) {
          return result;
        }
        result[1] = v11;
        uint64_t v14 = v10 + 1;
        if (!v10) {
          uint64_t v14 = v8;
        }
        *uint64_t v14 = result;
        goto LABEL_15;
      }

      uint64_t v7 = (void *)v11[1];
      uint64_t v10 = v11;
      if (!v7) {
        goto LABEL_6;
      }
    }
  }

  else
  {
LABEL_6:
    uint64_t result = sub_1001EC168((void (**)(void *, uint64_t, uint64_t))a1, a2, a3);
    if (result)
    {
      uint64_t v13 = *(void *)(a1 + 24);
      if (v13) {
        *(void *)(v13 + 8) = result;
      }
      *(void *)(a1 + 24) = result;
      if (!*(void *)(a1 + 16)) {
        *uint64_t v8 = result;
      }
LABEL_15:
      ++*(_DWORD *)(a1 + 32);
    }
  }

  return result;
}

uint64_t sub_1001EC30C(uint64_t a1)
{
  uint64_t v1 = *(void *)(a1 + 16);
  if (v1) {
    return *(void *)v1;
  }
  else {
    return 0LL;
  }
}

uint64_t sub_1001EC324(uint64_t a1, int a2)
{
  if (!a1) {
    return 0LL;
  }
  uint64_t v3 = *(void **)(a1 + 16);
  if (!v3) {
    return 0LL;
  }
  uint64_t v4 = *v3;
  uint64_t v5 = v3[1];
  if (a2)
  {
    uint64_t v6 = *(void (**)(void))(a1 + 8);
    if (v6)
    {
      v6(*v3);
      uint64_t v3 = *(void **)(a1 + 16);
    }
  }

  sub_1000B1838(v3);
  *(void *)(a1 + 16) = v5;
  if (!v5) {
    *(void *)(a1 + 24) = 0LL;
  }
  --*(_DWORD *)(a1 + 32);
  return v4;
}

uint64_t sub_1001EC398(uint64_t a1, int a2)
{
  uint64_t v2 = (void *)(a1 + 16);
  if (!*(void *)(a1 + 16)) {
    return 0LL;
  }
  uint64_t v4 = *(void **)(a1 + 24);
  uint64_t v5 = *v4;
  if (a2)
  {
    uint64_t v6 = *(void (**)(void))(a1 + 8);
    if (v6)
    {
      v6(*v4);
      uint64_t v4 = *(void **)(a1 + 24);
    }
  }

  sub_1000B1838(v4);
  uint64_t v8 = *(void *)(a1 + 16);
  uint64_t v7 = *(void *)(a1 + 24);
  if (v8 == v7)
  {
    uint64_t v9 = 0LL;
  }

  else
  {
    do
    {
      uint64_t v9 = v8;
      uint64_t v8 = *(void *)(v8 + 8);
    }

    while (v8 != v7);
    uint64_t v2 = (void *)(v9 + 8);
  }

  *uint64_t v2 = 0LL;
  *(void *)(a1 + 24) = v9;
  --*(_DWORD *)(a1 + 32);
  return v5;
}

uint64_t sub_1001EC434(uint64_t a1)
{
  return *(unsigned int *)(a1 + 32);
}

uint64_t sub_1001EC43C(uint64_t a1)
{
  return *(void *)(a1 + 16);
}

uint64_t sub_1001EC444(uint64_t result)
{
  if (result)
  {
    uint64_t v1 = *(void *)(*(void *)result + 8LL);
    *(void *)uint64_t result = v1;
    return v1 != 0;
  }

  return result;
}

uint64_t sub_1001EC460(uint64_t a1)
{
  return *(void *)a1;
}

uint64_t sub_1001EC468(uint64_t result, uint64_t a2)
{
  uint64_t v2 = *(void *)(result + 16);
  if (v2 != a2)
  {
    uint64_t v3 = *(void *)(result + 16);
    while (v3)
    {
      uint64_t v4 = v3;
      uint64_t v3 = *(void *)(v3 + 8);
      if (v3 == a2)
      {
        *(void *)(v4 + 8) = *(void *)(a2 + 8);
        *(void *)(a2 + 8) = v2;
        *(void *)(result + 16) = a2;
        if (*(void *)(result + 24) == a2) {
          *(void *)(result + 24) = v4;
        }
        return result;
      }
    }
  }

  return result;
}

void sub_1001EC4B4(uint64_t a1, void *ptr, int a3)
{
  uint64_t v3 = *(void **)(a1 + 16);
  if (!v3) {
    return;
  }
  if (v3 == ptr)
  {
    uint64_t v5 = 0LL;
LABEL_8:
    uint64_t v6 = ptr[1];
    if (v5)
    {
      v5[1] = v6;
      if (ptr[1])
      {
LABEL_11:
        --*(_DWORD *)(a1 + 32);
        if (a3)
        {
          uint64_t v7 = *(void (**)(void))(a1 + 8);
          if (v7) {
            v7(*ptr);
          }
        }

        sub_1000B1838(ptr);
        return;
      }
    }

    else
    {
      *(void *)(a1 + 16) = v6;
      if (v6) {
        goto LABEL_11;
      }
    }

    *(void *)(a1 + 24) = v5;
    goto LABEL_11;
  }

  while (1)
  {
    uint64_t v5 = v3;
    uint64_t v3 = (void *)v3[1];
    if (!v3) {
      break;
    }
    if (v3 == ptr) {
      goto LABEL_8;
    }
  }

void sub_1001EC550(void *a1, void *ptr, int a3)
{
  uint64_t v4 = (void *)a1[2];
  if (v4 == ptr)
  {
    sub_1001EC0C4((uint64_t)a1);
  }

  else
  {
    uint64_t v6 = ptr;
    do
    {
      uint64_t v7 = v4;
      uint64_t v4 = (void *)v4[1];
      if (v4) {
        BOOL v8 = v4 == ptr;
      }
      else {
        BOOL v8 = 1;
      }
    }

    while (!v8);
    if (v4)
    {
      v7[1] = 0LL;
      a1[3] = v7;
      if (ptr)
      {
        do
        {
          uint64_t v9 = v6;
          uint64_t v6 = (void *)v6[1];
          if (a3)
          {
            uint64_t v10 = (void (*)(void))a1[1];
            if (v10) {
              v10(*v9);
            }
          }

          sub_1000B1838(v9);
        }

        while (v6);
      }
    }
  }

double sub_1001EC5E8(uint64_t a1)
{
  double result = -3.59869635e230;
  *(_OWORD *)a1 = xmmword_1006BE170;
  *(void *)(a1 + 16) = 0LL;
  return result;
}

void *sub_1001EC5FC(uint64_t a1, __int128 *__src, size_t a3)
{
  __int16 v3 = a3;
  uint64_t v4 = __src;
  int v6 = *(_DWORD *)(a1 + 16);
  *(_DWORD *)(a1 + 16) = v6 + a3;
  if (__CFADD__(v6, (_DWORD)a3)) {
    ++*(_DWORD *)(a1 + 20);
  }
  uint64_t v7 = v6 & 0x3F;
  uint64_t v8 = 64 - v7;
  if (64 - (int)v7 <= a3)
  {
    uint64_t v10 = (_OWORD *)(a1 + 24);
    memmove((void *)(a1 - v8 + 88), __src, v8);
    uint64_t v11 = 0LL;
    do
      v11 += 4LL;
    while ((_DWORD)v11 != 64);
    sub_1001EC708((_DWORD *)a1, (int *)(a1 + 24));
    uint64_t v4 = (__int128 *)((char *)v4 + v8);
    unsigned __int16 v12 = v3 - v8;
    if (v12 >= 0x40u)
    {
      do
      {
        uint64_t v13 = 0LL;
        __int128 v14 = *v4;
        __int128 v15 = v4[1];
        __int128 v16 = v4[3];
        *(_OWORD *)(a1 + 56) = v4[2];
        *(_OWORD *)(a1 + 72) = v16;
        *uint64_t v10 = v14;
        *(_OWORD *)(a1 + 40) = v15;
        do
          v13 += 4LL;
        while ((_DWORD)v13 != 64);
        sub_1001EC708((_DWORD *)a1, (int *)(a1 + 24));
        v4 += 4;
        v12 -= 64;
      }

      while (v12 > 0x3Fu);
    }

    a3 = v12;
    uint64_t v9 = (void *)(a1 + 24);
  }

  else
  {
    uint64_t v9 = (void *)(a1 - v8 + 88);
    a3 = a3;
  }

  return memmove(v9, v4, a3);
}

_DWORD *sub_1001EC708(_DWORD *result, int *a2)
{
  int v2 = result[1];
  int v4 = result[2];
  int v3 = result[3];
  int v5 = *a2;
  int v6 = a2[1];
  HIDWORD(vmemset((char *)&v11[1] + 1, 0, 7) = *result + *a2 - 680876936 + (v4 & v2 | v3 & ~v2);
  LODWORD(vmemset((char *)&v11[1] + 1, 0, 7) = HIDWORD(v7);
  int v8 = (v7 >> 25) + v2;
  HIDWORD(vmemset((char *)&v11[1] + 1, 0, 7) = v3 + v6 - 389564586 + (v2 & v8 | v4 & ~v8);
  LODWORD(vmemset((char *)&v11[1] + 1, 0, 7) = HIDWORD(v7);
  int v9 = (v7 >> 20) + v8;
  int v10 = a2[2];
  int v11 = a2[3];
  HIDWORD(vmemset((char *)&v11[1] + 1, 0, 7) = v4 + v10 + 606105819 + (v8 & v9 | v2 & ~v9);
  LODWORD(vmemset((char *)&v11[1] + 1, 0, 7) = HIDWORD(v7);
  int v12 = (v7 >> 15) + v9;
  HIDWORD(vmemset((char *)&v11[1] + 1, 0, 7) = v2 + v11 - 1044525330 + (v9 & v12 | v8 & ~v12);
  LODWORD(vmemset((char *)&v11[1] + 1, 0, 7) = HIDWORD(v7);
  int v13 = (v7 >> 10) + v12;
  int v15 = a2[4];
  int v14 = a2[5];
  HIDWORD(vmemset((char *)&v11[1] + 1, 0, 7) = v15 + v8 - 176418897 + (v12 & v13 | v9 & ~v13);
  LODWORD(vmemset((char *)&v11[1] + 1, 0, 7) = HIDWORD(v7);
  int v16 = (v7 >> 25) + v13;
  HIDWORD(vmemset((char *)&v11[1] + 1, 0, 7) = v14 + v9 + 1200080426 + (v13 & v16 | v12 & ~v16);
  LODWORD(vmemset((char *)&v11[1] + 1, 0, 7) = HIDWORD(v7);
  int v17 = (v7 >> 20) + v16;
  int v18 = a2[6];
  int v19 = a2[7];
  HIDWORD(vmemset((char *)&v11[1] + 1, 0, 7) = v18 + v12 - 1473231341 + (v16 & v17 | v13 & ~v17);
  LODWORD(vmemset((char *)&v11[1] + 1, 0, 7) = HIDWORD(v7);
  int v20 = (v7 >> 15) + v17;
  HIDWORD(vmemset((char *)&v11[1] + 1, 0, 7) = v19 + v13 - 45705983 + (v17 & v20 | v16 & ~v20);
  LODWORD(vmemset((char *)&v11[1] + 1, 0, 7) = HIDWORD(v7);
  int v21 = (v7 >> 10) + v20;
  int v22 = a2[8];
  int v23 = a2[9];
  HIDWORD(vmemset((char *)&v11[1] + 1, 0, 7) = v22 + v16 + 1770035416 + (v20 & v21 | v17 & ~v21);
  LODWORD(vmemset((char *)&v11[1] + 1, 0, 7) = HIDWORD(v7);
  int v24 = (v7 >> 25) + v21;
  HIDWORD(vmemset((char *)&v11[1] + 1, 0, 7) = v23 + v17 - 1958414417 + (v21 & v24 | v20 & ~v24);
  LODWORD(vmemset((char *)&v11[1] + 1, 0, 7) = HIDWORD(v7);
  int v25 = (v7 >> 20) + v24;
  int v27 = a2[10];
  int v26 = a2[11];
  HIDWORD(vmemset((char *)&v11[1] + 1, 0, 7) = v27 + v20 - 42063 + (v24 & v25 | v21 & ~v25);
  LODWORD(vmemset((char *)&v11[1] + 1, 0, 7) = HIDWORD(v7);
  int v28 = (v7 >> 15) + v25;
  HIDWORD(vmemset((char *)&v11[1] + 1, 0, 7) = v26 + v21 - 1990404162 + (v25 & v28 | v24 & ~v28);
  LODWORD(vmemset((char *)&v11[1] + 1, 0, 7) = HIDWORD(v7);
  int v29 = (v7 >> 10) + v28;
  int v31 = a2[12];
  int v30 = a2[13];
  HIDWORD(vmemset((char *)&v11[1] + 1, 0, 7) = v31 + v24 + 1804603682 + (v28 & v29 | v25 & ~v29);
  LODWORD(vmemset((char *)&v11[1] + 1, 0, 7) = HIDWORD(v7);
  int v32 = (v7 >> 25) + v29;
  HIDWORD(vmemset((char *)&v11[1] + 1, 0, 7) = v30 + v25 - 40341101 + (v29 & v32 | v28 & ~v32);
  LODWORD(vmemset((char *)&v11[1] + 1, 0, 7) = HIDWORD(v7);
  int v33 = (v7 >> 20) + v32;
  int v35 = a2[14];
  int v34 = a2[15];
  HIDWORD(vmemset((char *)&v11[1] + 1, 0, 7) = v35 + v28 - 1502002290 + (v32 & v33 | v29 & ~v33);
  LODWORD(vmemset((char *)&v11[1] + 1, 0, 7) = HIDWORD(v7);
  int v36 = (v7 >> 15) + v33;
  HIDWORD(vmemset((char *)&v11[1] + 1, 0, 7) = v34 + v29 + 1236535329 + (v33 & v36 | v32 & ~v36);
  LODWORD(vmemset((char *)&v11[1] + 1, 0, 7) = HIDWORD(v7);
  int v37 = (v7 >> 10) + v36;
  HIDWORD(vmemset((char *)&v11[1] + 1, 0, 7) = v6 + v32 - 165796510 + (v37 & v33 | v36 & ~v33);
  LODWORD(vmemset((char *)&v11[1] + 1, 0, 7) = HIDWORD(v7);
  int v38 = (v7 >> 27) + v37;
  HIDWORD(vmemset((char *)&v11[1] + 1, 0, 7) = v18 + v33 - 1069501632 + (v38 & v36 | v37 & ~v36);
  LODWORD(vmemset((char *)&v11[1] + 1, 0, 7) = HIDWORD(v7);
  int v39 = (v7 >> 23) + v38;
  HIDWORD(vmemset((char *)&v11[1] + 1, 0, 7) = v26 + v36 + 643717713 + (v39 & v37 | v38 & ~v37);
  LODWORD(vmemset((char *)&v11[1] + 1, 0, 7) = HIDWORD(v7);
  int v40 = (v7 >> 18) + v39;
  HIDWORD(vmemset((char *)&v11[1] + 1, 0, 7) = v5 + v37 - 373897302 + (v40 & v38 | v39 & ~v38);
  LODWORD(vmemset((char *)&v11[1] + 1, 0, 7) = HIDWORD(v7);
  int v41 = (v7 >> 12) + v40;
  HIDWORD(vmemset((char *)&v11[1] + 1, 0, 7) = v14 + v38 - 701558691 + (v41 & v39 | v40 & ~v39);
  LODWORD(vmemset((char *)&v11[1] + 1, 0, 7) = HIDWORD(v7);
  int v42 = (v7 >> 27) + v41;
  HIDWORD(vmemset((char *)&v11[1] + 1, 0, 7) = v27 + v39 + 38016083 + (v42 & v40 | v41 & ~v40);
  LODWORD(vmemset((char *)&v11[1] + 1, 0, 7) = HIDWORD(v7);
  int v43 = (v7 >> 23) + v42;
  HIDWORD(vmemset((char *)&v11[1] + 1, 0, 7) = v34 + v40 - 660478335 + (v43 & v41 | v42 & ~v41);
  LODWORD(vmemset((char *)&v11[1] + 1, 0, 7) = HIDWORD(v7);
  int v44 = (v7 >> 18) + v43;
  HIDWORD(vmemset((char *)&v11[1] + 1, 0, 7) = v15 + v41 - 405537848 + (v44 & v42 | v43 & ~v42);
  LODWORD(vmemset((char *)&v11[1] + 1, 0, 7) = HIDWORD(v7);
  int v45 = (v7 >> 12) + v44;
  HIDWORD(vmemset((char *)&v11[1] + 1, 0, 7) = v23 + v42 + 568446438 + (v45 & v43 | v44 & ~v43);
  LODWORD(vmemset((char *)&v11[1] + 1, 0, 7) = HIDWORD(v7);
  int v46 = (v7 >> 27) + v45;
  HIDWORD(vmemset((char *)&v11[1] + 1, 0, 7) = v35 + v43 - 1019803690 + (v46 & v44 | v45 & ~v44);
  LODWORD(vmemset((char *)&v11[1] + 1, 0, 7) = HIDWORD(v7);
  int v47 = (v7 >> 23) + v46;
  HIDWORD(vmemset((char *)&v11[1] + 1, 0, 7) = v11 + v44 - 187363961 + (v47 & v45 | v46 & ~v45);
  LODWORD(vmemset((char *)&v11[1] + 1, 0, 7) = HIDWORD(v7);
  int v48 = (v7 >> 18) + v47;
  HIDWORD(vmemset((char *)&v11[1] + 1, 0, 7) = v22 + v45 + 1163531501 + (v48 & v46 | v47 & ~v46);
  LODWORD(vmemset((char *)&v11[1] + 1, 0, 7) = HIDWORD(v7);
  int v49 = (v7 >> 12) + v48;
  HIDWORD(vmemset((char *)&v11[1] + 1, 0, 7) = v30 + v46 - 1444681467 + (v49 & v47 | v48 & ~v47);
  LODWORD(vmemset((char *)&v11[1] + 1, 0, 7) = HIDWORD(v7);
  int v50 = (v7 >> 27) + v49;
  HIDWORD(vmemset((char *)&v11[1] + 1, 0, 7) = v10 + v47 - 51403784 + (v50 & v48 | v49 & ~v48);
  LODWORD(vmemset((char *)&v11[1] + 1, 0, 7) = HIDWORD(v7);
  int v51 = (v7 >> 23) + v50;
  HIDWORD(vmemset((char *)&v11[1] + 1, 0, 7) = v19 + v48 + 1735328473 + (v51 & v49 | v50 & ~v49);
  LODWORD(vmemset((char *)&v11[1] + 1, 0, 7) = HIDWORD(v7);
  int v52 = (v7 >> 18) + v51;
  HIDWORD(vmemset((char *)&v11[1] + 1, 0, 7) = v31 + v49 - 1926607734 + ((v52 ^ v51) & v50 ^ v51);
  LODWORD(vmemset((char *)&v11[1] + 1, 0, 7) = HIDWORD(v7);
  int v53 = (v7 >> 12) + v52;
  HIDWORD(vmemset((char *)&v11[1] + 1, 0, 7) = v14 + v50 - 378558 + (v52 ^ v51 ^ v53);
  LODWORD(vmemset((char *)&v11[1] + 1, 0, 7) = HIDWORD(v7);
  int v54 = (v7 >> 28) + v53;
  HIDWORD(vmemset((char *)&v11[1] + 1, 0, 7) = v22 + v51 - 2022574463 + (v53 ^ v52 ^ v54);
  LODWORD(vmemset((char *)&v11[1] + 1, 0, 7) = HIDWORD(v7);
  int v55 = (v7 >> 21) + v54;
  HIDWORD(vmemset((char *)&v11[1] + 1, 0, 7) = v26 + v52 + 1839030562 + (v54 ^ v53 ^ v55);
  LODWORD(vmemset((char *)&v11[1] + 1, 0, 7) = HIDWORD(v7);
  int v56 = (v7 >> 16) + v55;
  HIDWORD(vmemset((char *)&v11[1] + 1, 0, 7) = v35 + v53 - 35309556 + (v55 ^ v54 ^ v56);
  LODWORD(vmemset((char *)&v11[1] + 1, 0, 7) = HIDWORD(v7);
  int v57 = (v7 >> 9) + v56;
  HIDWORD(vmemset((char *)&v11[1] + 1, 0, 7) = v6 + v54 - 1530992060 + (v56 ^ v55 ^ v57);
  LODWORD(vmemset((char *)&v11[1] + 1, 0, 7) = HIDWORD(v7);
  int v58 = (v7 >> 28) + v57;
  HIDWORD(vmemset((char *)&v11[1] + 1, 0, 7) = v15 + v55 + 1272893353 + (v57 ^ v56 ^ v58);
  LODWORD(vmemset((char *)&v11[1] + 1, 0, 7) = HIDWORD(v7);
  int v59 = (v7 >> 21) + v58;
  HIDWORD(vmemset((char *)&v11[1] + 1, 0, 7) = v19 + v56 - 155497632 + (v58 ^ v57 ^ v59);
  LODWORD(vmemset((char *)&v11[1] + 1, 0, 7) = HIDWORD(v7);
  int v60 = (v7 >> 16) + v59;
  HIDWORD(vmemset((char *)&v11[1] + 1, 0, 7) = v27 + v57 - 1094730640 + (v59 ^ v58 ^ v60);
  LODWORD(vmemset((char *)&v11[1] + 1, 0, 7) = HIDWORD(v7);
  int v61 = (v7 >> 9) + v60;
  HIDWORD(vmemset((char *)&v11[1] + 1, 0, 7) = v30 + v58 + 681279174 + (v60 ^ v59 ^ v61);
  LODWORD(vmemset((char *)&v11[1] + 1, 0, 7) = HIDWORD(v7);
  int v62 = (v7 >> 28) + v61;
  HIDWORD(vmemset((char *)&v11[1] + 1, 0, 7) = v5 + v59 - 358537222 + (v61 ^ v60 ^ v62);
  LODWORD(vmemset((char *)&v11[1] + 1, 0, 7) = HIDWORD(v7);
  int v63 = (v7 >> 21) + v62;
  HIDWORD(vmemset((char *)&v11[1] + 1, 0, 7) = v11 + v60 - 722521979 + (v62 ^ v61 ^ v63);
  LODWORD(vmemset((char *)&v11[1] + 1, 0, 7) = HIDWORD(v7);
  int v64 = (v7 >> 16) + v63;
  HIDWORD(vmemset((char *)&v11[1] + 1, 0, 7) = v18 + v61 + 76029189 + (v63 ^ v62 ^ v64);
  LODWORD(vmemset((char *)&v11[1] + 1, 0, 7) = HIDWORD(v7);
  int v65 = (v7 >> 9) + v64;
  HIDWORD(vmemset((char *)&v11[1] + 1, 0, 7) = v23 + v62 - 640364487 + (v64 ^ v63 ^ v65);
  LODWORD(vmemset((char *)&v11[1] + 1, 0, 7) = HIDWORD(v7);
  int v66 = (v7 >> 28) + v65;
  HIDWORD(vmemset((char *)&v11[1] + 1, 0, 7) = v31 + v63 - 421815835 + (v65 ^ v64 ^ v66);
  LODWORD(vmemset((char *)&v11[1] + 1, 0, 7) = HIDWORD(v7);
  int v67 = (v7 >> 21) + v66;
  HIDWORD(vmemset((char *)&v11[1] + 1, 0, 7) = v34 + v64 + 530742520 + (v66 ^ v65 ^ v67);
  LODWORD(vmemset((char *)&v11[1] + 1, 0, 7) = HIDWORD(v7);
  int v68 = (v7 >> 16) + v67;
  HIDWORD(vmemset((char *)&v11[1] + 1, 0, 7) = v10 + v65 - 995338651 + (v67 ^ v66 ^ v68);
  LODWORD(vmemset((char *)&v11[1] + 1, 0, 7) = HIDWORD(v7);
  int v69 = (v7 >> 9) + v68;
  HIDWORD(vmemset((char *)&v11[1] + 1, 0, 7) = v5 + v66 - 198630844 + ((v69 | ~v67) ^ v68);
  LODWORD(vmemset((char *)&v11[1] + 1, 0, 7) = HIDWORD(v7);
  int v70 = (v7 >> 26) + v69;
  HIDWORD(vmemset((char *)&v11[1] + 1, 0, 7) = v19 + v67 + 1126891415 + ((v70 | ~v68) ^ v69);
  LODWORD(vmemset((char *)&v11[1] + 1, 0, 7) = HIDWORD(v7);
  int v71 = (v7 >> 22) + v70;
  HIDWORD(vmemset((char *)&v11[1] + 1, 0, 7) = v35 + v68 - 1416354905 + ((v71 | ~v69) ^ v70);
  LODWORD(vmemset((char *)&v11[1] + 1, 0, 7) = HIDWORD(v7);
  int v72 = (v7 >> 17) + v71;
  HIDWORD(vmemset((char *)&v11[1] + 1, 0, 7) = v14 + v69 - 57434055 + ((v72 | ~v70) ^ v71);
  LODWORD(vmemset((char *)&v11[1] + 1, 0, 7) = HIDWORD(v7);
  int v73 = (v7 >> 11) + v72;
  HIDWORD(vmemset((char *)&v11[1] + 1, 0, 7) = v31 + v70 + 1700485571 + ((v73 | ~v71) ^ v72);
  LODWORD(vmemset((char *)&v11[1] + 1, 0, 7) = HIDWORD(v7);
  int v74 = (v7 >> 26) + v73;
  HIDWORD(vmemset((char *)&v11[1] + 1, 0, 7) = v11 + v71 - 1894986606 + ((v74 | ~v72) ^ v73);
  LODWORD(vmemset((char *)&v11[1] + 1, 0, 7) = HIDWORD(v7);
  int v75 = (v7 >> 22) + v74;
  HIDWORD(vmemset((char *)&v11[1] + 1, 0, 7) = v27 + v72 - 1051523 + ((v75 | ~v73) ^ v74);
  LODWORD(vmemset((char *)&v11[1] + 1, 0, 7) = HIDWORD(v7);
  int v76 = (v7 >> 17) + v75;
  HIDWORD(vmemset((char *)&v11[1] + 1, 0, 7) = v6 + v73 - 2054922799 + ((v76 | ~v74) ^ v75);
  LODWORD(vmemset((char *)&v11[1] + 1, 0, 7) = HIDWORD(v7);
  int v77 = (v7 >> 11) + v76;
  HIDWORD(vmemset((char *)&v11[1] + 1, 0, 7) = v22 + v74 + 1873313359 + ((v77 | ~v75) ^ v76);
  LODWORD(vmemset((char *)&v11[1] + 1, 0, 7) = HIDWORD(v7);
  int v78 = (v7 >> 26) + v77;
  HIDWORD(vmemset((char *)&v11[1] + 1, 0, 7) = v34 + v75 - 30611744 + ((v78 | ~v76) ^ v77);
  LODWORD(vmemset((char *)&v11[1] + 1, 0, 7) = HIDWORD(v7);
  int v79 = (v7 >> 22) + v78;
  HIDWORD(vmemset((char *)&v11[1] + 1, 0, 7) = v18 + v76 - 1560198380 + ((v79 | ~v77) ^ v78);
  LODWORD(vmemset((char *)&v11[1] + 1, 0, 7) = HIDWORD(v7);
  int v80 = (v7 >> 17) + v79;
  HIDWORD(vmemset((char *)&v11[1] + 1, 0, 7) = v30 + v77 + 1309151649 + ((v80 | ~v78) ^ v79);
  LODWORD(vmemset((char *)&v11[1] + 1, 0, 7) = HIDWORD(v7);
  int v81 = (v7 >> 11) + v80;
  HIDWORD(vmemset((char *)&v11[1] + 1, 0, 7) = v15 + v78 - 145523070 + ((v81 | ~v79) ^ v80);
  LODWORD(vmemset((char *)&v11[1] + 1, 0, 7) = HIDWORD(v7);
  int v82 = (v7 >> 26) + v81;
  HIDWORD(vmemset((char *)&v11[1] + 1, 0, 7) = v26 + v79 - 1120210379 + ((v82 | ~v80) ^ v81);
  LODWORD(vmemset((char *)&v11[1] + 1, 0, 7) = HIDWORD(v7);
  int v83 = (v7 >> 22) + v82;
  HIDWORD(vmemset((char *)&v11[1] + 1, 0, 7) = v10 + v80 + 718787259 + ((v83 | ~v81) ^ v82);
  LODWORD(vmemset((char *)&v11[1] + 1, 0, 7) = HIDWORD(v7);
  int v84 = (v7 >> 17) + v83;
  HIDWORD(vmemset((char *)&v11[1] + 1, 0, 7) = v23 + v81 - 343485551 + ((v84 | ~v82) ^ v83);
  LODWORD(vmemset((char *)&v11[1] + 1, 0, 7) = HIDWORD(v7);
  *result += v82;
  result[1] = v84 + v2 + (v7 >> 11);
  result[2] = v84 + v4;
  result[3] = v83 + v3;
  return result;
}

double sub_1001ED0E4(_OWORD *a1, uint64_t a2)
{
  uint64_t v4 = *(_DWORD *)(a2 + 16) & 0x3F;
  int v5 = (int *)(a2 + 24);
  int v6 = (_BYTE *)(a2 + 24 + v4);
  *int v6 = 0x80;
  unint64_t v7 = (int *)(v6 + 1);
  if (v4 < 0x38)
  {
    int v9 = 55 - v4;
  }

  else
  {
    bzero(v7, v4 ^ 0x3F);
    uint64_t v8 = 0LL;
    do
      v8 += 4LL;
    while ((_DWORD)v8 != 64);
    sub_1001EC708((_DWORD *)a2, v5);
    int v9 = 56;
    unint64_t v7 = v5;
  }

  bzero(v7, (v9 + 8));
  uint64_t v10 = 0LL;
  do
    v10 += 4LL;
  while ((_DWORD)v10 != 56);
  *(void *)(a2 + 80) = 8LL * *(void *)(a2 + 16);
  sub_1001EC708((_DWORD *)a2, v5);
  uint64_t v11 = 0LL;
  do
    v11 += 4LL;
  while ((_DWORD)v11 != 16);
  *a1 = *(_OWORD *)a2;
  *(void *)(a2 + 80) = 0LL;
  double result = 0.0;
  *(_OWORD *)(a2 + 48) = 0u;
  *(_OWORD *)(a2 + 64) = 0u;
  *(_OWORD *)(a2 + 16) = 0u;
  *(_OWORD *)(a2 + 32) = 0u;
  *(_OWORD *)a2 = 0u;
  return result;
}

void sub_1001ED1C4(uint64_t a1)
{
  if (sub_1000A86F0())
  {
    sub_1001EE134( (uint64_t)"WARNING!!! ByteStream_NumReadBytesAvail fault at File:%s, Line:%d, Func:%s",  v2,  v3,  v4,  v5,  v6,  v7,  v8,  a1);
    int v9 = (os_log_s *)sub_100086554(0x39u);
    if (os_log_type_enabled(v9, OS_LOG_TYPE_DEFAULT))
    {
      *(_DWORD *)__int128 buf = 136446210;
      uint64_t v11 = sub_1001EDDCC();
      _os_log_impl((void *)&_mh_execute_header, v9, OS_LOG_TYPE_DEFAULT, " %{public}s", buf, 0xCu);
    }
  }

uint64_t sub_1001ED298( uint64_t *a1, unsigned int a2, uint64_t a3, unsigned int a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9)
{
  if (!a1) {
    sub_1000E6B88( "/Library/Caches/com.apple.xbs/Sources/MobileBluetooth_base/Stack/corestack/support/oi_bytestream.c",  142,  "bs");
  }
  if (!*a1) {
    sub_1000E6B88( "/Library/Caches/com.apple.xbs/Sources/MobileBluetooth_base/Stack/corestack/support/oi_bytestream.c",  143,  "ByteStream_GetDataPointer(*bs)");
  }
  int v72 = &a9;
  if (a4)
  {
    uint64_t v10 = a3;
    uint64_t v12 = 0LL;
    uint64_t v13 = a4;
    uint64_t v71 = a4;
    while (1)
    {
      switch(*(_BYTE *)(v10 + v12))
      {
        case 0:
        case 1:
          int v16 = v72++;
          if (*((_BYTE *)a1 + 14) != 1) {
            sub_1000E6B88( "/Library/Caches/com.apple.xbs/Sources/MobileBluetooth_base/Stack/corestack/support/oi_bytestream.c",  151,  "(*bs).__RWFlag == BYTESTREAM_READ");
          }
          if (*((_BYTE *)a1 + 15)) {
            goto LABEL_74;
          }
          uint64_t v37 = *((unsigned __int16 *)a1 + 6);
          int v38 = (_BYTE *)*v16;
          uint64_t v39 = *a1;
          *((_WORD *)a1 + 6) = v37 + 1;
          _BYTE *v38 = *(_BYTE *)(v39 + v37);
          goto LABEL_76;
        case 2:
        case 3:
        case 0xC:
          int v14 = v72++;
          if (*((_BYTE *)a1 + 14) != 1)
          {
            int v65 = "(*bs).__RWFlag == BYTESTREAM_READ";
            goto LABEL_88;
          }

          if (a2 >= 2)
          {
            int v65 = "((byteorder) == OI_BIG_ENDIAN_BYTE_ORDER) || ((byteorder) == OI_LITTLE_ENDIAN_BYTE_ORDER)";
LABEL_88:
            sub_1000E6B88( "/Library/Caches/com.apple.xbs/Sources/MobileBluetooth_base/Stack/corestack/support/oi_bytestream.c",  157,  v65);
          }

          if (*((_BYTE *)a1 + 15))
          {
LABEL_74:
            sub_1001ED1C4((uint64_t)"/Library/Caches/com.apple.xbs/Sources/MobileBluetooth_base/Stack/corestack/support/oi_bytestream.c");
LABEL_75:
            *((_BYTE *)a1 + 15) = 1;
            goto LABEL_76;
          }

          uint64_t v18 = *((unsigned __int16 *)a1 + 6);
          int v19 = (_WORD *)*v14;
          int v20 = (unsigned __int8 *)(*a1 + v18);
          if (a2) {
            int v21 = v20 + 1;
          }
          else {
            int v21 = v20;
          }
          if (!a2) {
            ++v20;
          }
          *int v19 = *v20 | (*v21 << 8);
          __int16 v22 = *((_WORD *)a1 + 6) + 2;
LABEL_82:
          *((_WORD *)a1 + 6) = v22;
LABEL_76:
          if (++v12 == v13) {
            goto LABEL_83;
          }
          break;
        case 4:
        case 5:
          int v17 = (unsigned int **)v72++;
          if (*((_BYTE *)a1 + 14) != 1)
          {
            int v67 = "(*bs).__RWFlag == BYTESTREAM_READ";
            goto LABEL_95;
          }

          if (a2 >= 2)
          {
            int v67 = "((byteorder) == OI_BIG_ENDIAN_BYTE_ORDER) || ((byteorder) == OI_LITTLE_ENDIAN_BYTE_ORDER)";
LABEL_95:
            sub_1000E6B88( "/Library/Caches/com.apple.xbs/Sources/MobileBluetooth_base/Stack/corestack/support/oi_bytestream.c",  162,  v67);
          }

          if (*((_BYTE *)a1 + 15)) {
            goto LABEL_74;
          }
          uint64_t v40 = *((unsigned __int16 *)a1 + 6);
          int v41 = (unsigned __int16 *)(*a1 + v40);
          if (a2)
          {
            unsigned int v43 = *v41++;
            unsigned int v42 = v43;
          }

          else
          {
            unsigned int v42 = __rev16(*(unsigned __int16 *)((char *)v41 + 1));
          }

          **int v17 = v42 | (*(unsigned __int8 *)v41 << 16);
          __int16 v22 = v40 + 3;
          goto LABEL_82;
        case 6:
        case 7:
        case 0xD:
          int v15 = (unsigned int **)v72++;
          if (*((_BYTE *)a1 + 14) != 1)
          {
            int v66 = "(*bs).__RWFlag == BYTESTREAM_READ";
            goto LABEL_91;
          }

          if (a2 >= 2)
          {
            int v66 = "((byteorder) == OI_BIG_ENDIAN_BYTE_ORDER) || ((byteorder) == OI_LITTLE_ENDIAN_BYTE_ORDER)";
LABEL_91:
            sub_1000E6B88( "/Library/Caches/com.apple.xbs/Sources/MobileBluetooth_base/Stack/corestack/support/oi_bytestream.c",  168,  v66);
          }

          if (*((_BYTE *)a1 + 15)) {
            goto LABEL_74;
          }
          uint64_t v23 = *((unsigned __int16 *)a1 + 6);
          int v24 = (unsigned int *)(*a1 + v23);
          if (a2) {
            unsigned int v25 = *v24;
          }
          else {
            unsigned int v25 = bswap32(*v24);
          }
          *const char *v15 = v25;
          __int16 v22 = v23 + 4;
          goto LABEL_82;
        case 0xA:
          int v26 = v72;
          int v27 = (_BYTE *)*v72;
          v72 += 2;
          if (*((_BYTE *)a1 + 14) != 1) {
            sub_1000E6B88( "/Library/Caches/com.apple.xbs/Sources/MobileBluetooth_base/Stack/corestack/support/oi_bytestream.c",  174,  "(*bs).__RWFlag == BYTESTREAM_READ");
          }
          int v28 = (_WORD *)v26[1];
          uint64_t v69 = *a1;
          uint64_t v29 = *((unsigned __int16 *)a1 + 6);
          uint64_t v30 = (unsigned __int16)*v28;
          if (*((_BYTE *)a1 + 15))
          {
            sub_1001ED1C4((uint64_t)"/Library/Caches/com.apple.xbs/Sources/MobileBluetooth_base/Stack/corestack/support/oi_bytestream.c");
            int v31 = 0;
          }

          else
          {
            int v31 = *((unsigned __int16 *)a1 + 5) - (_DWORD)v29;
          }

          int v32 = (unsigned __int16)*v28;
          if (v31 >= v32)
          {
            if ((_DWORD)v30)
            {
              int v44 = (char *)(v69 + v29);
              int v45 = &v27[v30];
              do
              {
                char v46 = *v44++;
                *v27++ = v46;
              }

              while (v27 < v45);
              LOWORD(v32) = *v28;
            }

            *((_WORD *)a1 + 6) += v32;
          }

          else
          {
            *((_BYTE *)a1 + 15) = 1;
          }

          uint64_t v10 = a3;
          uint64_t v13 = v71;
          goto LABEL_76;
        case 0xB:
          int v33 = v72++;
          if (*((_BYTE *)a1 + 14) != 1)
          {
            int v68 = "(*bs).__RWFlag == BYTESTREAM_READ";
            goto LABEL_100;
          }

          if (a2 >= 2)
          {
            int v68 = "((byteorder) == OI_BIG_ENDIAN_BYTE_ORDER) || ((byteorder) == OI_LITTLE_ENDIAN_BYTE_ORDER)";
LABEL_100:
            sub_1000E6B88( "/Library/Caches/com.apple.xbs/Sources/MobileBluetooth_base/Stack/corestack/support/oi_bytestream.c",  178,  v68);
          }

          if (*((_BYTE *)a1 + 15)) {
            goto LABEL_74;
          }
          uint64_t v60 = *((unsigned __int16 *)a1 + 6);
          uint64_t v61 = *v33;
          uint64_t v62 = *a1 + v60;
          if (a2)
          {
            sub_1001F0050(v61, v62, 6uLL);
          }

          else
          {
            int v63 = *(_DWORD *)v62;
            *(_WORD *)(v61 + 4) = *(_WORD *)(v62 + 4);
            *(_DWORD *)uint64_t v61 = v63;
          }

          __int16 v22 = *((_WORD *)a1 + 6) + 6;
          goto LABEL_82;
        case 0xE:
          int v34 = v72++;
          if (*((_BYTE *)a1 + 14) != 1) {
            sub_1000E6B88( "/Library/Caches/com.apple.xbs/Sources/MobileBluetooth_base/Stack/corestack/support/oi_bytestream.c",  182,  "(*bs).__RWFlag == BYTESTREAM_READ");
          }
          if (*((_BYTE *)a1 + 15))
          {
            sub_1001ED1C4((uint64_t)"/Library/Caches/com.apple.xbs/Sources/MobileBluetooth_base/Stack/corestack/support/oi_bytestream.c");
            int v35 = *((unsigned __int8 *)a1 + 14);
            *((_BYTE *)a1 + 15) = 1;
            if (v35 != 1) {
              sub_1000E6B88( "/Library/Caches/com.apple.xbs/Sources/MobileBluetooth_base/Stack/corestack/support/oi_bytestream.c",  183,  "(*bs).__RWFlag == BYTESTREAM_READ");
            }
            goto LABEL_74;
          }

          uint64_t v47 = *((unsigned __int16 *)a1 + 6);
          if (*((unsigned __int16 *)a1 + 5) - (int)v47 <= 3)
          {
            *((_BYTE *)a1 + 15) = 1;
            goto LABEL_74;
          }

          int v48 = (_DWORD *)*v34;
          uint64_t v49 = *a1;
          int v50 = (_DWORD *)*v34;
          *int v50 = bswap32(*(_DWORD *)(*a1 + v47));
          int v51 = v50 + 4;
          unsigned __int16 v52 = v47 + 4;
          *((_WORD *)a1 + 6) = v52;
          int v53 = (char *)(v49 + v52);
          int v54 = v48 + 1;
          do
          {
            char v55 = *v53++;
            *v54++ = v55;
          }

          while (v54 < (_BYTE *)v51);
          __int16 v22 = *((_WORD *)a1 + 6) + 12;
          goto LABEL_82;
        case 0x10:
          int v36 = v72++;
          if (*((_BYTE *)a1 + 14) != 1) {
            sub_1000E6B88( "/Library/Caches/com.apple.xbs/Sources/MobileBluetooth_base/Stack/corestack/support/oi_bytestream.c",  188,  "(*bs).__RWFlag == BYTESTREAM_READ");
          }
          if (*((_BYTE *)a1 + 15)) {
            goto LABEL_74;
          }
          uint64_t v56 = *((unsigned __int16 *)a1 + 6);
          uint64_t v57 = 0LL;
          uint64_t v58 = *v36;
          uint64_t v59 = *a1 + v56;
          do
          {
            *(_BYTE *)(v58 + v5memset((char *)&v11[1] + 1, 0, 7) = *(_BYTE *)(v59 + v57);
            ++v57;
          }

          while (v57 != 16);
          __int16 v22 = *((_WORD *)a1 + 6) + 16;
          goto LABEL_82;
        default:
          sub_1000E6B88( "/Library/Caches/com.apple.xbs/Sources/MobileBluetooth_base/Stack/corestack/support/oi_bytestream.c",  192,  "FALSE");
      }
    }
  }

LABEL_83:
  if (*((_BYTE *)a1 + 15)) {
    return 1031LL;
  }
  else {
    return 0LL;
  }
}

  sub_100242F54((uint64_t)v54);
  unsigned int v43 = sub_10056AB04(buf, v55[1], v56 - (unint64_t)v55[1]);
  int v44 = sub_10056AAD8((uint64_t)v43);
  sub_10040F938(a3, v44);
  *(void *)__int128 buf = &off_10087FAA8;
  if (*(void *)&buf[8]) {
    sub_1002CD254(*(unsigned int **)&buf[8]);
  }
  int v45 = sub_10056AB04(buf, v55[1], v56 - (unint64_t)v55[1]);
  char v46 = (char *)sub_10056AAF0((uint64_t)v45);
  sub_10056AB04(v57, v55[1], v56 - (unint64_t)v55[1]);
  uint64_t v47 = sub_10056AAD8((uint64_t)v57);
  sub_10040F91C(a3, v46, v47);
  *(void *)uint64_t v57 = &off_10087FAA8;
  if (*(void *)&v57[8]) {
    sub_1002CD254(*(unsigned int **)&v57[8]);
  }
  *(void *)__int128 buf = &off_10087FAA8;
  if (*(void *)&buf[8]) {
    sub_1002CD254(*(unsigned int **)&buf[8]);
  }
  sub_100242FAC((uint64_t)v54);
  if (v55[1])
  {
    *(void **)&uint64_t v56 = v55[1];
    operator delete(v55[1]);
  }

  return 0LL;
}

  *(void *)int v66 = 0LL;
  *(void *)int v67 = 0LL;
  if (sub_1003D55EC(a2, &v67[1], v67, &v66[1], v66))
  {
    int v31 = (os_log_s *)qword_1008F75E0;
    if (os_log_type_enabled((os_log_t)qword_1008F75E0, OS_LOG_TYPE_DEFAULT))
    {
      int v33 = v67[0];
      int v32 = v67[1];
      int v34 = v66[0];
      int v35 = v66[1];
      sub_1003CF00C(a2, &__str);
      int v36 = (__str.__r_.__value_.__s.__size_ & 0x80u) == 0 ? &__str : (std::string *)__str.__r_.__value_.__r.__words[0];
      *(_DWORD *)int v73 = 67110146;
      *(_DWORD *)&v73[4] = v32;
      *(_WORD *)&v73[8] = 1024;
      *(_DWORD *)&v73[10] = v33;
      *(_WORD *)&v73[14] = 1024;
      *(_DWORD *)&v73[16] = v35;
      *(_WORD *)&v73[20] = 1024;
      *(_DWORD *)&v73[22] = v34;
      *(_WORD *)&v73[26] = 2080;
      int v74 = (uint64_t)v36;
      _os_log_impl( (void *)&_mh_execute_header,  v31,  OS_LOG_TYPE_DEFAULT,  "Looking up by vidSrc 0x%x vid 0x%x pid 0x%x version 0x%x for %s",  v73,  0x24u);
    }

    uint64_t v37 = sub_1002D29C0( a1,  " FROM devices, matching_rules_did, makes WHERE ((matching_rules_did.vid_src IS NULL) OR (matching_rules_did. vid_src = ?1)) AND ((matching_rules_did.vid IS NULL) OR (matching_rules_did.vid = ?2)) AND ((matching_rules_ did.pid IS NULL) OR (matching_rules_did.pid = ?3)) AND ((matching_rules_did.version IS NULL) OR (matching_ru les_did.version = ?4)) AND (matching_rules_did.device_id = devices.id) AND CASE WHEN devices.make_id is NULL THEN (makes.id = 0) ELSE (devices.make_id = makes.id) END");
    int v38 = v37;
    if (v37)
    {
      if (sqlite3_bind_int(v37, 1, v67[1])
        || sqlite3_bind_int(v38, 2, v67[0])
        || sqlite3_bind_int(v38, 3, v66[1])
        || sqlite3_bind_int(v38, 4, v66[0]))
      {
        if (os_log_type_enabled((os_log_t)qword_1008F75E0, OS_LOG_TYPE_ERROR))
        {
          uint64_t v39 = sqlite3_errmsg(*a1);
          sub_100669964((uint64_t)v39, (uint64_t)v76);
        }
      }

      else
      {
        int v63 = sub_1002D2DC8(a1, v38, (uint64_t)&v82);
        if (v63)
        {
          int v64 = (os_log_s *)qword_1008F75E0;
          if (os_log_type_enabled((os_log_t)qword_1008F75E0, OS_LOG_TYPE_DEFAULT))
          {
            sub_1003CF00C(a2, v73);
            int v65 = v73[23] >= 0 ? v73 : *(_BYTE **)v73;
            LODWORD(__str.__r_.__value_.__l.__data_) = 136446466;
            *(std::string::size_type *)((char *)__str.__r_.__value_.__r.__words + 4) = (std::string::size_type)v65;
            WORD2(__str.__r_.__value_.__r.__words[1]) = 1024;
            *(_DWORD *)((char *)&__str.__r_.__value_.__r.__words[1] + 6) = v63;
            _os_log_impl( (void *)&_mh_execute_header,  v64,  OS_LOG_TYPE_DEFAULT,  "Found a DID profile for device %{public}s at row %d",  (uint8_t *)&__str,  0x12u);
            if ((v73[23] & 0x80000000) != 0) {
              operator delete(*(void **)v73);
            }
          }

          int v19 = 1;
        }
      }

      sqlite3_finalize(v38);
    }
  }

  memset(v73, 0, 24);
  if (!LOBYTE(__p[0]) || (std::string::operator=((std::string *)v73, (const std::string *)&__p[1]), !LOBYTE(__p[0])))
  {
    uint64_t v40 = (os_log_s *)qword_1008F75E0;
    if (os_log_type_enabled((os_log_t)qword_1008F75E0, OS_LOG_TYPE_DEFAULT))
    {
      sub_1003CF00C(a2, &__str);
      int v41 = (__str.__r_.__value_.__s.__size_ & 0x80u) == 0 ? &__str : (std::string *)__str.__r_.__value_.__r.__words[0];
      *(_DWORD *)__int128 buf = 136446210;
      *(void *)&uint8_t buf[4] = v41;
      _os_log_impl( (void *)&_mh_execute_header,  v40,  OS_LOG_TYPE_DEFAULT,  "Performing substring search for make name of device %{public}s",  buf,  0xCu);
    }

    unsigned int v42 = sub_1002D2B60(a1);
    if (v42)
    {
      if (sub_1002D2FF8(a1, v42, (uint64_t)&v82, a2))
      {
        if (LOBYTE(__p[0])) {
          std::string::operator=((std::string *)v73, (const std::string *)&__p[1]);
        }
        unsigned int v43 = (os_log_s *)qword_1008F75E0;
        if (os_log_type_enabled((os_log_t)qword_1008F75E0, OS_LOG_TYPE_DEFAULT))
        {
          sub_1003CF00C(a2, &__str);
          if ((__str.__r_.__value_.__s.__size_ & 0x80u) == 0) {
            int v44 = &__str;
          }
          else {
            int v44 = (std::string *)__str.__r_.__value_.__r.__words[0];
          }
          int v45 = v73;
          if (v73[23] < 0) {
            int v45 = *(_BYTE **)v73;
          }
          *(_DWORD *)__int128 buf = 136446466;
          *(void *)&uint8_t buf[4] = v44;
          *(_WORD *)&buf[12] = 2082;
          *(void *)&buf[14] = v45;
          _os_log_impl( (void *)&_mh_execute_header,  v43,  OS_LOG_TYPE_DEFAULT,  "Found make of device: %{public}s, Make: %{public}s",  buf,  0x16u);
        }

        int v19 = 1;
      }

      else
      {
        char v46 = (os_log_s *)qword_1008F75E0;
        if (os_log_type_enabled((os_log_t)qword_1008F75E0, OS_LOG_TYPE_DEFAULT))
        {
          sub_1003CF00C(a2, &__str);
          uint64_t v47 = (__str.__r_.__value_.__s.__size_ & 0x80u) == 0
              ? &__str
              : (std::string *)__str.__r_.__value_.__r.__words[0];
          *(_DWORD *)__int128 buf = 136446210;
          *(void *)&uint8_t buf[4] = v47;
          _os_log_impl( (void *)&_mh_execute_header,  v46,  OS_LOG_TYPE_DEFAULT,  "No make name found for device %{public}s",  buf,  0xCu);
        }
      }

      sqlite3_finalize(v42);
      if (!LOBYTE(__p[0])
        || (std::string::operator=((std::string *)v73, (const std::string *)&__p[1]), !LOBYTE(__p[0])))
      {
        int v48 = sub_1002D2C94(a1);
        if (v48)
        {
          uint64_t v49 = (os_log_s *)qword_1008F75E0;
          if (os_log_type_enabled((os_log_t)qword_1008F75E0, OS_LOG_TYPE_DEFAULT))
          {
            sub_1003CF00C(a2, &__str);
            int v50 = (__str.__r_.__value_.__s.__size_ & 0x80u) == 0
                ? &__str
                : (std::string *)__str.__r_.__value_.__r.__words[0];
            *(_DWORD *)__int128 buf = 136446210;
            *(void *)&uint8_t buf[4] = v50;
            _os_log_impl( (void *)&_mh_execute_header,  v49,  OS_LOG_TYPE_DEFAULT,  "Performing friendly name search for make group of device %{public}s",  buf,  0xCu);
          }

          if (sub_1002D386C(a1, v48, (uint64_t)&v82, a2))
          {
            if (LOBYTE(__p[0])) {
              std::string::operator=((std::string *)v73, (const std::string *)&__p[1]);
            }
            int v51 = (os_log_s *)qword_1008F75E0;
            if (os_log_type_enabled((os_log_t)qword_1008F75E0, OS_LOG_TYPE_DEFAULT))
            {
              sub_1003CF00C(a2, &__str);
              if ((__str.__r_.__value_.__s.__size_ & 0x80u) == 0) {
                unsigned __int16 v52 = &__str;
              }
              else {
                unsigned __int16 v52 = (std::string *)__str.__r_.__value_.__r.__words[0];
              }
              int v53 = v73;
              if (v73[23] < 0) {
                int v53 = *(_BYTE **)v73;
              }
              *(_DWORD *)__int128 buf = 136446466;
              *(void *)&uint8_t buf[4] = v52;
              *(_WORD *)&buf[12] = 2082;
              *(void *)&buf[14] = v53;
              _os_log_impl( (void *)&_mh_execute_header,  v51,  OS_LOG_TYPE_DEFAULT,  "Found make group of device: %{public}s, Make Group: %{public}s",  buf,  0x16u);
            }

            int v19 = 1;
          }

          else
          {
            int v54 = (os_log_s *)qword_1008F75E0;
            if (os_log_type_enabled((os_log_t)qword_1008F75E0, OS_LOG_TYPE_DEFAULT))
            {
              sub_1003CF00C(a2, &__str);
              char v55 = (__str.__r_.__value_.__s.__size_ & 0x80u) == 0
                  ? &__str
                  : (std::string *)__str.__r_.__value_.__r.__words[0];
              *(_DWORD *)__int128 buf = 136446210;
              *(void *)&uint8_t buf[4] = v55;
              _os_log_impl( (void *)&_mh_execute_header,  v54,  OS_LOG_TYPE_DEFAULT,  "No make group found for device %{public}s",  buf,  0xCu);
            }
          }

          sqlite3_finalize(v48);
        }
      }
    }
  }

  sub_1002D210C((uint64_t)a1);
  if (v19)
  {
    sub_1003D22F4(a2);
    sub_1003D2368((uint64_t *)a2, (uint64_t)&v82);
  }

  if ((v73[23] & 0x80000000) != 0) {
    operator delete(*(void **)v73);
  }
  uint64_t v23 = 0LL;
LABEL_158:
  if (SHIBYTE(v88[0]) < 0) {
    operator delete(__p[1]);
  }
  if (SHIBYTE(v86) < 0) {
    operator delete(v85[1]);
  }
  if (SHIBYTE(v84) < 0) {
    operator delete(v83[1]);
  }
  nullsub_63((char *)&v82 + 1, v8);
  sub_100242FAC((uint64_t)v68);
  return v23;
}

    int v45 = v17 == (char *)v28;
    int v17 = v102;
    if (v45)
    {
      if (os_log_type_enabled((os_log_t)qword_1008F75B0, OS_LOG_TYPE_ERROR)) {
        sub_100674E00();
      }
      sub_1001C4E78(*(unsigned __int16 **)(a2 + 8));
      int v14 = 907LL;
      goto LABEL_29;
    }

uint64_t sub_1001ED90C(void *a1)
{
  if (!dword_1008F6FAC)
  {
    for (uint64_t i = 0LL; i != 10; i += 2LL)
      qword_1008EDDB0[i] = 0LL;
    dword_1008F6FAC = 1;
  }

  if (!*a1) {
    sub_1001EE2A0();
  }
  if (!a1[1]) {
    sub_1001EE2A0();
  }
  uint64_t v3 = 0LL;
  for (uint64_t j = &stru_100000020.vmsize; j != -16; j -= 16LL)
  {
    uint64_t v5 = *(void **)((char *)qword_1008EDDB0 + j);
    if (v5)
    {
      if (v5 == a1)
      {
        sub_1001EE2A0();
        return 105LL;
      }
    }

    else
    {
      uint64_t v3 = (char *)qword_1008EDDB0 + j;
    }
  }

  if (v3)
  {
    *(void *)uint64_t v3 = a1;
    *((void *)v3 + 1) = 0x100000001LL;
    sub_1001EDA44((uint64_t)v3);
    if (*((_DWORD *)v3 + 3) == 2)
    {
      if (sub_1000A86F0())
      {
        sub_1001EE134((uint64_t)"Command chain initiation failed in first command", v6, v7, v8, v9, v10, v11, v12, v15);
        uint64_t v13 = (os_log_s *)sub_100086554(0x29u);
        if (os_log_type_enabled(v13, OS_LOG_TYPE_ERROR)) {
          sub_10065CAC8(v13);
        }
      }

      *(void *)uint64_t v3 = 0LL;
      *((_DWORD *)v3 + 3) = 0;
      return 1023LL;
    }

    else
    {
      uint64_t result = 0LL;
      *((_DWORD *)v3 + 3) = 3;
    }
  }

  else
  {
    sub_1001EE2A0();
    return 104LL;
  }

  return result;
}

uint64_t sub_1001EDA44(uint64_t result)
{
  uint64_t v1 = *(int *)(result + 8);
  uint64_t v2 = *(uint64_t (**)(void))(*(void *)result + 8 * v1);
  if (v2)
  {
    *(_DWORD *)(result + 8) = v1 + 1;
    return v2();
  }

  else if (*(_DWORD *)(result + 12) == 1)
  {
    *(_DWORD *)(result + 12) = 2;
  }

  else
  {
    uint64_t v3 = **(uint64_t (***)(void))result;
    *(void *)uint64_t result = 0LL;
    *(_DWORD *)(result + 12) = 0;
    return v3(0LL);
  }

  return result;
}

void sub_1001EDA8C(uint64_t a1)
{
  if (!dword_1008F6FAC) {
    sub_1001EE2A0();
  }
  uint64_t v2 = 0LL;
  while (qword_1008EDDB0[v2] != a1)
  {
    v2 += 2LL;
    if (v2 == 10)
    {
      sub_1001EE2A0();
      return;
    }
  }

  sub_1001EDA44((uint64_t)&qword_1008EDDB0[v2]);
}

void sub_1001EDAF0(void (**a1)(uint64_t), uint64_t a2)
{
  if (!dword_1008F6FAC) {
    sub_1001EE2A0();
  }
  uint64_t v4 = 0LL;
  while ((void (**)(uint64_t))qword_1008EDDB0[v4] != a1)
  {
    v4 += 2LL;
    if (v4 == 10)
    {
      sub_1001EE2A0();
      return;
    }
  }

  uint64_t v5 = &qword_1008EDDB0[v4];
  if (*((_DWORD *)v5 + 3) == 1)
  {
    *((_DWORD *)v5 + 3) = 2;
  }

  else
  {
    uint64_t v6 = *a1;
    *uint64_t v5 = 0LL;
    *((_DWORD *)v5 + 3) = 0;
    v6(a2);
  }

void *sub_1001EDB88()
{
  return memcpy(&unk_1008EDE00, &unk_1008863E8, 0x238uLL);
}

uint64_t sub_1001EDBA0(unsigned int a1)
{
  if (a1 >= 0x47) {
    sub_1001EE2A0();
  }
  uint64_t result = qword_1008EDE00[a1];
  if (!result)
  {
    sub_1001EE2A0();
    return qword_1008EDE00[a1];
  }

  return result;
}

void sub_1001EDBE4(uint64_t a1, uint64_t a2)
{
  if (sub_1001EF138(a2))
  {
    if (sub_1000A86F0())
    {
      sub_1001EE134( (uint64_t)"OI_ConfigTable_SetConfig fail: module %d is already initialized",  v4,  v5,  v6,  v7,  v8,  v9,  v10,  a2);
      uint64_t v11 = (os_log_s *)sub_100086554(0x39u);
      if (os_log_type_enabled(v11, OS_LOG_TYPE_ERROR)) {
LABEL_8:
      }
        sub_10065B06C();
    }
  }

  else if ((_DWORD)a2 == 40 && !sub_1001EF16C())
  {
    if (sub_1000A86F0())
    {
      sub_1001EE134( (uint64_t)"OI_ConfigTable_SetConfig fail: cannot set Common Configuration",  v12,  v13,  v14,  v15,  v16,  v17,  v18,  v20);
      int v19 = (os_log_s *)sub_100086554(0x39u);
      if (os_log_type_enabled(v19, OS_LOG_TYPE_ERROR)) {
        goto LABEL_8;
      }
    }
  }

  else
  {
    qword_1008EDE00[a2] = a1;
  }

char *sub_1001EDCD4(char *result, int a2, _WORD *a3)
{
  LOWORD(v3) = *a3;
  if (a2)
  {
    do
    {
      --a2;
      char v4 = *result++;
      int v3 = word_1006BE1A2[(v4 ^ v3)] ^ ((unsigned __int16)(v3 & 0xFF00) >> 8);
    }

    while ((_WORD)a2);
  }

  *a3 = v3;
  return result;
}

unint64_t sub_1001EDD10(unint64_t result, _BYTE *a2)
{
  *a2 = byte_1006BE3A2[result >> 4] | (16 * byte_1006BE3A2[result & 0xF]);
  a2[1] = byte_1006BE3A2[(unint64_t)result >> 12] | (16 * byte_1006BE3A2[(result >> 8) & 0xF]);
  return result;
}

uint64_t sub_1001EDD50()
{
  if (qword_1008EE048) {
    free((void *)qword_1008EE048);
  }
  qword_1008EE048 = 0LL;
  dword_1008EE040 = 0;
  uint64_t result = qword_1008EE050;
  if (qword_1008EE050)
  {
    uint64_t result = munmap((void *)qword_1008EE050, dword_1008EE03C);
    qword_1008EE050 = 0LL;
  }

  if (dword_1008D8FF8 != -1)
  {
    shm_unlink("com.apple.bluetooth.magnet.shm");
    uint64_t result = close(dword_1008D8FF8);
    dword_1008D8FF8 = -1;
  }

  return result;
}

void *sub_1001EDDCC()
{
  return &unk_1008EE058;
}

char *sub_1001EDDD8(unsigned int a1)
{
  if (a1 <= 0x5C) {
    return off_100886620[a1];
  }
  else {
    return 0LL;
  }
}

uint64_t sub_1001EDDF8()
{
  return 0LL;
}

uint64_t sub_1001EDE10( uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  __int128 v9 = unk_100886908;
  sub_1001F5F28((uint64_t)&v9, (uint64_t)"%:", a3, a4, a5, a6, a7, a8, a1);
  return sub_1001F5F50((uint64_t)&v9);
}

uint64_t sub_1001EDE54( uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  __int128 v9 = unk_100886908;
  sub_1001F5F28((uint64_t)&v9, (uint64_t)"%@", a3, a4, a5, a6, a7, a8, a1);
  return sub_1001F5F50((uint64_t)&v9);
}

void sub_1001EDE9C(unsigned __int8 *a1, char **a2)
{
  __int128 v11 = unk_100886918;
  uint64_t v2 = sub_1001F4EE4((uint64_t)&v11, a1, a2);
  if ((_DWORD)v2)
  {
    WORD2(v11) = 0;
    sub_1001F5F28((uint64_t)&v11, (uint64_t)"Invalid parameter in debug output %! %s", v3, v4, v5, v6, v7, v8, v2);
  }

  __int128 v9 = (os_log_s *)sub_100086554(0x5Cu);
  if (os_log_type_enabled(v9, OS_LOG_TYPE_DEFAULT))
  {
    uint64_t v10 = sub_1001F5F50((uint64_t)&v11);
    *(_DWORD *)__int128 buf = 136446210;
    uint64_t v13 = v10;
    _os_log_impl((void *)&_mh_execute_header, v9, OS_LOG_TYPE_DEFAULT, "%{public}s", buf, 0xCu);
  }

void sub_1001EDF7C(uint64_t a1, uint64_t a2)
{
  __int128 v11 = unk_100886918;
  uint64_t v2 = sub_1001F4EE4(&v11, a1, a2);
  if ((_DWORD)v2)
  {
    WORD2(v11) = 0;
    sub_1001F5F28((uint64_t)&v11, (uint64_t)"Invalid parameter in debug output %! %s", v3, v4, v5, v6, v7, v8, v2);
  }

  __int128 v9 = (os_log_s *)sub_100086554(0x58u);
  if (os_log_type_enabled(v9, OS_LOG_TYPE_DEFAULT))
  {
    uint64_t v10 = sub_1001F5F50((uint64_t)&v11);
    *(_DWORD *)__int128 buf = 136446210;
    uint64_t v13 = v10;
    _os_log_impl((void *)&_mh_execute_header, v9, OS_LOG_TYPE_DEFAULT, "%{public}s", buf, 0xCu);
  }

uint64_t sub_1001EE05C(uint64_t a1, int a2, uint64_t a3, uint64_t a4)
{
  uint64_t result = 0xFFFFFFFFLL;
  if (a1 && a2)
  {
    v6[0] = 0LL;
    v6[1] = a1;
    *(_DWORD *)((char *)v6 + 2) = (unsigned __int16)(a2 - 1);
    if (sub_1001F4EE4(v6, a3, a4))
    {
      return 0xFFFFFFFFLL;
    }

    else
    {
      uint64_t result = WORD2(v6[0]);
      *(_BYTE *)(a1 + WORD2(v6[0])) = 0;
    }
  }

  return result;
}

uint64_t sub_1001EE0BC( uint64_t a1, int a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9)
{
  return sub_1001EE05C(a1, a2, a3, (uint64_t)&a9);
}

void sub_1001EE0E4(char *a1, ...)
{
}

void sub_1001EE10C( uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9)
{
}

uint64_t sub_1001EE134( uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9)
{
  __int128 v17 = unk_100886918;
  bzero(&unk_1008EE058, 0x1000uLL);
  uint64_t result = sub_1001F4EE4(&v17, a1, &a9);
  if ((_DWORD)result)
  {
    WORD2(v1memset((char *)&v11[1] + 1, 0, 7) = 0;
    return sub_1001F5F28( (uint64_t)&v17,  (uint64_t)"Bad format string in debug output (error %d): %s",  v11,  v12,  v13,  v14,  v15,  v16,  result);
  }

  return result;
}

const char *sub_1001EE1B0(unsigned int a1)
{
  if (a1 > 2) {
    return "unknown";
  }
  else {
    return off_100886928[(char)a1];
  }
}

const char *sub_1001EE1D8(int a1)
{
  if (a1 <= 1)
  {
    if (!a1) {
      return "sco";
    }
    if (a1 == 1) {
      return "acl";
    }
  }

  else
  {
    switch(a1)
    {
      case 2:
        return "esco";
      case 240:
        return "acl-hdr";
      case 241:
        return "acl-hdr-hrb";
    }
  }

  return "unknown";
}

const char *sub_1001EE24C(unsigned int a1)
{
  if (a1 > 2) {
    return "unknown";
  }
  else {
    return off_100886940[(char)a1];
  }
}

const char *sub_1001EE274(int a1)
{
  uint64_t v1 = "unknown";
  if (a1 == 1) {
    uint64_t v1 = "peripheral";
  }
  if (a1) {
    return v1;
  }
  else {
    return "central";
  }
}

void sub_1001EE2A0()
{
  uint64_t v0 = qword_1008EF860;
  if (qword_1008EF860 || (v3 = 0LL, sub_10017B000(&qword_1008EF860, &v3), (uint64_t v0 = qword_1008EF860) != 0))
  {
    uint64_t v1 = *(uint64_t (**)(void))(v0 + 96);
    if (v1)
    {
      uint64_t v2 = v1(0LL);
      if ((_DWORD)v2)
      {
        if ((_DWORD)v2 != 102) {
          sub_1001EE0E4("Calling HciDriver_t::triggerCapture failed with status %!", v2);
        }
      }
    }
  }

  else
  {
    sub_1001EE0E4("BT driver not ready yet!, skipping");
  }

void *sub_1001EE328(void *result)
{
  off_1008EF858 = result;
  return result;
}

uint64_t sub_1001EE334()
{
  if (off_1008EF858) {
    return off_1008EF858();
  }
  return result;
}

void sub_1001EE348(uint64_t a1)
{
  if (sub_1000B0174())
  {
    sub_1001F142C(a1);
    sub_1001EE0E4("------------------------- Stack Dump reason: %s (%d) ------------------------------\n", v2, a1);
    if ((sub_1000A86F8() & 1) != 0)
    {
      uint64_t v3 = sub_1000A86F0();
      char v10 = v3;
      if ((v3 & 1) == 0) {
        sub_1000A85A0();
      }
      if ((int)a1 > 3699)
      {
        if ((_DWORD)a1 == 3700 || (_DWORD)a1 == 3702) {
          goto LABEL_14;
        }
      }

      else if ((_DWORD)a1 == 621 || (_DWORD)a1 == 3602)
      {
        goto LABEL_14;
      }

      __int128 v28 = 0u;
      __int128 v29 = 0u;
      __int128 v26 = 0u;
      __int128 v27 = 0u;
      __int128 v24 = 0u;
      __int128 v25 = 0u;
      __int128 v22 = 0u;
      __int128 v23 = 0u;
      __int128 v20 = 0u;
      __int128 v21 = 0u;
      __int128 v18 = 0u;
      __int128 v19 = 0u;
      __int128 v16 = 0u;
      __int128 v17 = 0u;
      *(_OWORD *)__int128 buf = 0u;
      __int128 v15 = 0u;
      sub_1001EE0BC((uint64_t)buf, 256, (uint64_t)"Fatal error detected, reason %! (0x%x)", v5, v6, v7, v8, v9, a1);
      sub_1000BAAF0((const char *)buf);
LABEL_14:
      nullsub_63(v3, v4);
      sub_1001BC434();
      sub_1000917F0();
      sub_1001000F8();
      sub_1001EAEEC();
      sub_10018739C();
      sub_100171FAC();
      sub_10010C490();
      sub_10012D31C();
      uint64_t v12 = sub_100137158();
      nullsub_63(v12, v13);
      sub_1001EEFB0();
      sub_10007C750();
      if ((v10 & 1) == 0) {
        sub_1000A8688();
      }
      return;
    }

    uint64_t v11 = (os_log_s *)sub_100086554(0x5Cu);
    if (os_log_type_enabled(v11, OS_LOG_TYPE_DEFAULT))
    {
      *(_DWORD *)__int128 buf = 136446210;
      *(void *)&uint8_t buf[4] = "Stack is not running";
      _os_log_impl((void *)&_mh_execute_header, v11, OS_LOG_TYPE_DEFAULT, "%{public}s", buf, 0xCu);
    }
  }

void *sub_1001EE4DC(uint64_t a1, uint64_t (*a2)(void))
{
  if (dword_1008F6FB0)
  {
    if (sub_1000A86F0())
    {
      sub_1001EE134((uint64_t)"OI_Dispatch_Init: %!", v4, v5, v6, v7, v8, v9, v10, 140LL);
      uint64_t v11 = (os_log_s *)sub_100086554(0x2Au);
      if (os_log_type_enabled(v11, OS_LOG_TYPE_ERROR)) {
        sub_100657858();
      }
    }

    sub_1001EE2A0();
  }

  if (a1)
  {
    if (sub_1000A86F0())
    {
      sub_1001EE134( (uint64_t)"OI_Dispatch_Init: configuration parameter is deprecated",  v12,  v13,  v14,  v15,  v16,  v17,  v18,  v21);
      __int128 v19 = (os_log_s *)sub_100086554(0x2Au);
      if (os_log_type_enabled(v19, OS_LOG_TYPE_ERROR)) {
        sub_100657858();
      }
    }

    sub_1001EDBE4(a1, 42LL);
  }

  if (!sub_1001EDBA0(0x2Au)) {
    sub_1001EE2A0();
  }
  byte_1008EF868 = 0;
  byte_1008EF870 = 0;
  word_1008EF87C = *(_WORD *)sub_1001EDBA0(0x2Au);
  uint64_t result = sub_1000B1814(24LL * (unsigned __int16)word_1008EF87C);
  qword_1008EF888 = (uint64_t)result;
  word_1008EF878 = -1;
  off_1008EF890 = a2;
  dword_1008EF898 = -1;
  dword_1008F6FB0 = 1;
  return result;
}

void sub_1001EE628(int a1)
{
  __int16 v1 = a1;
  uint64_t v2 = qword_1008EF888 + 24LL * a1;
  if (*(void *)(v2 + 8))
  {
    if (*(unsigned __int16 *)(qword_1008EF888 + 24LL * a1 + 6) >= 9u)
    {
      uint64_t v3 = *(void **)(qword_1008EF888 + 24LL * a1 + 16);
      if (v3) {
        sub_1000B1838(v3);
      }
    }
  }

  *(void *)(v2 + 8) = 0LL;
  *(_BYTE *)uint64_t v2 = 0;
  if (word_1008EF878 == v1 && (word_1008EF878 & 0x80000000) == 0)
  {
    do
    {
      if (*(void *)(qword_1008EF888 + 24LL * v1 + 8)) {
        break;
      }
      word_1008EF878 = --v1;
    }

    while ((v1 & 0x8000) == 0);
  }

uint64_t sub_1001EE6DC(uint64_t a1, const void **a2, int *a3)
{
  return sub_1001EE6E8(a1, a2, 0, a3);
}

uint64_t sub_1001EE6E8(uint64_t a1, const void **a2, int a3, int *a4)
{
  if (qword_1008EF888)
  {
    if (a1) {
      goto LABEL_3;
    }
LABEL_15:
    sub_1001EE2A0();
    if ((a3 & 0x8000) == 0) {
      goto LABEL_4;
    }
LABEL_16:
    sub_1001EE2A0();
    return 101LL;
  }

  sub_1001EE2A0();
  if (!a1) {
    goto LABEL_15;
  }
LABEL_3:
  if ((a3 & 0x8000) != 0) {
    goto LABEL_16;
  }
LABEL_4:
  uint64_t result = 101LL;
  if (a1)
  {
    uint64_t v9 = qword_1008EF888;
    if (qword_1008EF888)
    {
      if (!a3) {
        byte_1008EF870 = 1;
      }
      int v10 = (unsigned __int16)word_1008EF87C;
      if (word_1008EF87C)
      {
        uint64_t v11 = (void *)(qword_1008EF888 + 8);
        if (*(void *)(qword_1008EF888 + 8))
        {
          uint64_t v12 = 0LL;
          __int16 v13 = 0;
          while (1)
          {
            int v14 = ++v13;
            uint64_t v12 = v13;
            uint64_t v15 = qword_1008EF888 + 24LL * v13;
            uint64_t v16 = *(void *)(v15 + 8);
            uint64_t v11 = (void *)(v15 + 8);
            if (!v16) {
              goto LABEL_19;
            }
          }

          int v18 = 0;
          uint64_t v17 = qword_1008EF888 + 24 * v12;
        }

        else
        {
          int v14 = 0;
          __int16 v13 = 0;
          LODWORD(v12) = 0;
LABEL_19:
          uint64_t v17 = qword_1008EF888 + 24LL * (int)v12;
          if (word_1008EF878 < v13)
          {
            word_1008EF878 = v13;
            if (dword_1008EF898 < v14) {
              dword_1008EF898 = v14;
            }
          }

          sub_1001EEA54(qword_1008EF888 + 24LL * (int)v12, a3);
          *(_BYTE *)uint64_t v17 = 2;
          *uint64_t v11 = a1;
          uint64_t v19 = v9 + 24LL * (int)v12;
          int v20 = *(unsigned __int16 *)(v19 + 4);
          if (((v20 + 1) & 0x10000) != 0) {
            unsigned __int16 v21 = v20 + 2;
          }
          else {
            unsigned __int16 v21 = v20 + 1;
          }
          *(_WORD *)(v19 + 4) = v21;
          int v18 = v21 | ((unsigned __int16)v14 << 16);
          int v10 = (unsigned __int16)word_1008EF87C;
        }
      }

      else
      {
        __int16 v13 = 0;
        int v14 = 0;
        uint64_t v17 = 0LL;
        int v18 = 0;
      }

      if (v14 >= v10)
      {
        sub_1001EE2A0();
        int v10 = (unsigned __int16)word_1008EF87C;
      }

      if (v17) {
        BOOL v22 = v14 == v10;
      }
      else {
        BOOL v22 = 1;
      }
      if (v22)
      {
        if (sub_1000A86F0())
        {
          sub_1001EE134( (uint64_t)"Dispatch table of size %d overflow: timeout %d, cbFunc0x %x",  v23,  v24,  v25,  v26,  v27,  v28,  v29,  (unsigned __int16)word_1008EF87C);
          uint64_t v30 = (os_log_s *)sub_100086554(0x2Au);
          if (os_log_type_enabled(v30, OS_LOG_TYPE_ERROR)) {
            sub_100657858();
          }
        }

        sub_1001EE2A0();
        return 1002LL;
      }

      else
      {
        if (a2)
        {
          int v31 = *(__int16 *)a2;
          if (v31 > 8)
          {
            int v33 = sub_1000B17F4(*(unsigned __int16 *)a2);
            *(void *)(v17 + 16) = v33;
            if (!v33)
            {
              sub_1001EE628(v13);
              return 106LL;
            }

            memmove(v33, a2[1], *(__int16 *)a2);
            LOWORD(v31) = *(_WORD *)a2;
          }

          else if (v31 >= 1)
          {
            uint64_t v32 = 0LL;
            do
            {
              *(_BYTE *)(v17 + 16 + v32) = *((_BYTE *)a2[1] + v32);
              ++v32;
            }

            while (v32 < *(__int16 *)a2);
            LOWORD(v31) = *(_WORD *)a2;
          }
        }

        else
        {
          LOWORD(v31) = 0;
        }

        *(_WORD *)(v17 + 6) = v31;
        uint64_t result = 0LL;
        if (a4) {
          *a4 = v18;
        }
      }
    }
  }

  return result;
}

uint64_t sub_1001EE978(unsigned int a1, int a2)
{
  if (!sub_1001EE9D8(a1)) {
    return 1001LL;
  }
  if ((a2 & 0x8000) != 0)
  {
    sub_1001EE2A0();
    return 101LL;
  }

  else
  {
    sub_1001EEA54(qword_1008EF888 + 24LL * HIWORD(a1), a2);
    return 0LL;
  }

BOOL sub_1001EE9D8(unsigned int a1)
{
  unsigned __int16 v1 = a1;
  unsigned int v2 = HIWORD(a1);
  if (!qword_1008EF888) {
    sub_1001EE2A0();
  }
  return v2 < (unsigned __int16)word_1008EF87C
      && *(unsigned __int8 *)(qword_1008EF888 + 24LL * v2) >= 2u
      && *(unsigned __int16 *)(qword_1008EF888 + 24LL * v2 + 4) == v1;
}

void sub_1001EEA54(uint64_t a1, int a2)
{
  uint64_t v5 = 0LL;
  sub_1000B0400((uint64_t)&v5);
  int v4 = (SWORD2(v5) + 99) / 100 + 10 * v5;
  if (!a1) {
    sub_1001EE2A0();
  }
  *(_WORD *)(a1 + 2) = v4 + a2;
  if (!word_1008EF878 || a2 <= (__int16)(word_1008EF880 - v4))
  {
    word_1008EF880 = v4 + a2;
    if (off_1008EF890) {
      off_1008EF890((100 * a2));
    }
  }

uint64_t sub_1001EEB08(uint64_t a1)
{
  return (*(uint64_t (**)(void))(*(void *)(a1 + 8) + 8LL))(**(void **)(a1 + 8));
}

uint64_t sub_1001EEB14(uint64_t a1)
{
  if (!sub_1001EE9D8(a1)) {
    return 1001LL;
  }
  if (*(uint64_t (**)(uint64_t))(qword_1008EF888 + 24LL * WORD1(a1) + 8) == sub_1001EEB08)
  {
    sub_1000AFE20(a1);
    return sub_1001EEB7C();
  }

  else
  {
    sub_1001EE628((int)a1 >> 16);
    return 0LL;
  }

uint64_t sub_1001EEB7C(unsigned int a1, int a2)
{
  if (!sub_1001EE9D8(a1)) {
    return 1001LL;
  }
  uint64_t v4 = qword_1008EF888;
  uint64_t v7 = 0LL;
  sub_1000B0400((uint64_t)&v7);
  int v5 = (SWORD2(v7) + 99) / 100 + 10 * v7;
  *(_WORD *)(v4 + 24LL * HIWORD(a1) + 2) = v5 + a2;
  if (a2 <= (__int16)(word_1008EF880 - v5))
  {
    word_1008EF880 = v5 + a2;
    if (off_1008EF890) {
      off_1008EF890((100 * a2));
    }
  }

  return 0LL;
}

uint64_t sub_1001EEC44(unsigned int a1, _WORD *a2)
{
  if (!sub_1001EE9D8(a1)) {
    return 1001LL;
  }
  uint64_t v4 = qword_1008EF888;
  uint64_t v6 = 0LL;
  sub_1000B0400((uint64_t)&v6);
  uint64_t result = 0LL;
  *a2 = *(_WORD *)(v4 + 24LL * HIWORD(a1) + 2) + (SWORD2(v6) + 99) / -100 - 10 * v6;
  return result;
}

uint64_t sub_1001EECE0(unsigned int a1)
{
  if (!sub_1001EE9D8(a1)) {
    return 1001LL;
  }
  uint64_t v8 = 0LL;
  uint64_t v9 = 0LL;
  uint64_t v2 = qword_1008EF888;
  unsigned int v3 = HIWORD(a1);
  uint64_t v4 = qword_1008EF888 + 24LL * v3;
  *(_BYTE *)uint64_t v4 = 1;
  int v5 = *(__int16 *)(v4 + 6);
  if (v5)
  {
    LOWORD(v8) = v5;
    uint64_t v6 = (void *)(v2 + 24LL * v3 + 16);
    if (v5 >= 9) {
      uint64_t v6 = (void *)*v6;
    }
    uint64_t v9 = v6;
    (*(void (**)(uint64_t *))(v2 + 24LL * v3 + 8))(&v8);
  }

  else
  {
    (*(void (**)(void))(v2 + 24LL * v3 + 8))(0LL);
  }

  sub_1001EE628((__int16)v3);
  return 0LL;
}

uint64_t sub_1001EED90()
{
  if (!qword_1008EF888) {
    sub_1001EE2A0();
  }
  if (byte_1008EF868 == 1) {
    sub_1001EE2A0();
  }
  uint64_t v17 = 0LL;
  int v18 = 0LL;
  byte_1008EF868 = 1;
  uint64_t v19 = 0LL;
  sub_1000B0400((uint64_t)&v19);
  __int16 v0 = word_1008EF878;
  if (word_1008EF878 < 0)
  {
    byte_1008EF868 = 0;
LABEL_28:
    __int16 v1 = 0;
    byte_1008EF870 = 0;
    return v1;
  }

  __int16 v1 = 0;
  LOWORD(v2) = 0;
  int v3 = (SWORD2(v19) + 99) / 100 + 10 * v19;
  uint64_t v4 = qword_1008EF888;
  do
  {
    int v5 = (__int16)v2;
    uint64_t v6 = v4 + 24LL * (__int16)v2;
    uint64_t v7 = *(void (**)(uint64_t *))(v6 + 8);
    if (v7 && (__int16)(*(_WORD *)(v4 + 24LL * v5 + 2) - v3) <= 0)
    {
      *(_BYTE *)uint64_t v6 = 1;
      uint64_t v8 = v4 + 24LL * v5;
      int v9 = *(__int16 *)(v8 + 6);
      if (*(_WORD *)(v8 + 6))
      {
        LOWORD(v1memset((char *)&v11[1] + 1, 0, 7) = *(_WORD *)(v8 + 6);
        int v10 = (void *)(v4 + 24LL * v5 + 16);
        if (v9 >= 9) {
          int v10 = (void *)*v10;
        }
        int v18 = v10;
        uint64_t v11 = &v17;
      }

      else
      {
        uint64_t v11 = 0LL;
      }

      v7(v11);
      ++v1;
      sub_1001EE628(v5);
      uint64_t v4 = qword_1008EF888;
      __int16 v0 = word_1008EF878;
    }

    int v2 = (__int16)(v5 + 1);
  }

  while (v2 <= v0);
  if ((v0 & 0x8000) == 0)
  {
    uint64_t v12 = (unsigned __int16)(v0 + 1);
    __int16 v13 = (void *)(qword_1008EF888 + 8);
    unsigned __int16 v14 = -1;
    do
    {
      if (*v13)
      {
        __int16 v15 = *((_WORD *)v13 - 3);
        if ((unsigned __int16)(v15 - v3) < v14)
        {
          word_1008EF880 = *((_WORD *)v13 - 3);
          unsigned __int16 v14 = v15 - v3;
        }
      }

      v13 += 3;
      --v12;
    }

    while (v12);
    if (v14 != 0xFFFF && off_1008EF890) {
      off_1008EF890(100 * v14);
    }
  }

  byte_1008EF868 = 0;
  if (!v1) {
    goto LABEL_28;
  }
  return v1;
}

uint64_t sub_1001EEF6C()
{
  if (byte_1008EF868 != 1 && byte_1008EF870 != 0)
  {
    do
    {
      byte_1008EF870 = 0;
      uint64_t result = sub_1001EED90();
    }

    while ((byte_1008EF870 & 1) != 0);
  }

  return result;
}

uint64_t sub_1001EEFB0()
{
  uint64_t v11 = 0LL;
  sub_1000B0400((uint64_t)&v11);
  __int16 v0 = v11;
  int v1 = SWORD2(v11);
  sub_1001EE0E4("Dispatcher dump:\n");
  sub_1001EE0E4("   Running\t\t%d\n", byte_1008EF868);
  sub_1001EE0E4("   TableSize\t  %d\n", (unsigned __int16)word_1008EF87C);
  uint64_t result = sub_1001EE0E4("   max_used_count %d\n", dword_1008EF898);
  unsigned int v3 = (unsigned __int16)word_1008EF87C;
  if (word_1008EF87C)
  {
    uint64_t v4 = 0LL;
    unint64_t v5 = 0LL;
    int v6 = (unsigned __int16)(((unint64_t)(1374389535LL * (v1 + 99)) >> 37)
    uint64_t v7 = qword_1008EF888;
    do
    {
      uint64_t v8 = *(void *)(v7 + v4 + 8);
      if (v8)
      {
        unint64_t v9 = *(char *)(v7 + v4);
        int v10 = "unknown state";
        if (v9 <= 2) {
          int v10 = off_100886958[v9];
        }
        uint64_t result = sub_1001EE0E4( "entry %2d: %18s timeout %d, CBFunc 0x%x\n",  v5,  v10,  *(unsigned __int16 *)(v7 + v4 + 2) - v6,  v8);
        uint64_t v7 = qword_1008EF888;
        unsigned int v3 = (unsigned __int16)word_1008EF87C;
      }

      ++v5;
      v4 += 24LL;
    }

    while (v5 < v3);
  }

  return result;
}

double sub_1001EF0FC()
{
  double result = 0.0;
  xmmword_1008F6FF8 = 0u;
  unk_1008F7008 = 0u;
  xmmword_1008F6FD8 = 0u;
  unk_1008F6FE8 = 0u;
  xmmword_1008F6FB8 = 0u;
  unk_1008F6FC8 = 0u;
  xmmword_1008F6F98 = 0u;
  unk_1008F6FA8 = 0u;
  xmmword_1008F6F78 = 0u;
  unk_1008F6F88 = 0u;
  unk_1008F6F58 = 0u;
  *(_OWORD *)&dword_1008F6F68 = 0u;
  unk_1008F6F38 = 0u;
  *(_OWORD *)&dword_1008F6F48 = 0u;
  xmmword_1008F6F18 = 0u;
  unk_1008F6F28 = 0u;
  *(_OWORD *)&dword_1008F6F08 = 0u;
  xmmword_1008F7014 = 0u;
  return result;
}

uint64_t sub_1001EF138(unsigned int a1)
{
  if (a1 >= 0x47) {
    sub_1001EE2A0();
  }
  return dword_1008F6F08[a1];
}

BOOL sub_1001EF16C()
{
  if (dword_1008F6F08[0]) {
    return 0LL;
  }
  unint64_t v1 = 0LL;
  do
  {
    unint64_t v2 = v1;
    if (v1 == 70) {
      break;
    }
  }

  while (!dword_1008F6F08[++v1]);
  return v2 > 0x45;
}

void *sub_1001EF1B4(void *result)
{
  *double result = result;
  result[1] = result;
  return result;
}

void *sub_1001EF1BC(void *result, uint64_t *a2)
{
  uint64_t v2 = *a2;
  *a2 = (uint64_t)result;
  *double result = v2;
  result[1] = a2;
  *(void *)(v2 + 8) = result;
  return result;
}

void *sub_1001EF1D0(void *result, uint64_t a2)
{
  uint64_t v2 = *(void **)(a2 + 8);
  *uint64_t v2 = result;
  *double result = a2;
  result[1] = v2;
  *(void *)(a2 + 8) = result;
  return result;
}

void sub_1001EF1E4(void *a1)
{
  unint64_t v1 = (void *)a1[1];
  if ((void *)*v1 == a1 && (uint64_t v2 = *a1, *(void **)(*a1 + 8LL) == a1))
  {
    *unint64_t v1 = v2;
    *(void *)(v2 + 8) = v1;
  }

  else if (sub_1000A86F0())
  {
    sub_1001EE134((uint64_t)"Attempt to delete element not in list\n", v3, v4, v5, v6, v7, v8, v9, v11);
    int v10 = (os_log_s *)sub_100086554(0x39u);
    if (os_log_type_enabled(v10, OS_LOG_TYPE_ERROR)) {
      sub_100657FDC(v10);
    }
  }

uint64_t sub_1001EF264(void **a1)
{
  uint64_t v1 = (uint64_t)*a1;
  if (*a1 == a1) {
    return 0LL;
  }
  sub_1001EF1E4(*a1);
  return v1;
}

char *sub_1001EF29C(unsigned int a1)
{
  char v1 = a1;
  double result = (char *)sub_1000B17F4(24LL * a1 + 16);
  if (result)
  {
    *double result = v1;
    *(_WORD *)(result + 1) = 0;
    *((_DWORD *)result + 1) = 0;
  }

  return result;
}

uint64_t sub_1001EF2D8(void *a1, uint64_t a2, char a3)
{
  unsigned __int8 v6 = *(_BYTE *)a2 + a3;
  uint64_t v7 = (char *)sub_1000B17F4(24LL * v6 + 16);
  if (!v7) {
    return 106LL;
  }
  uint64_t v8 = v7;
  *uint64_t v7 = v6;
  *(_WORD *)(v7 + 1) = 0;
  *((_DWORD *)v7 + 1) = 0;
  *uint64_t v7 = *(_BYTE *)a2 + a3;
  v7[1] = *(_BYTE *)(a2 + 1);
  *((_WORD *)v7 + 3) = *(_WORD *)(a2 + 6);
  v7[2] = *(_BYTE *)(a2 + 2);
  *((_WORD *)v7 + 2) = *(_WORD *)(a2 + 4);
  *((void *)v7 + 1) = *(void *)(a2 + 8);
  if (*(_BYTE *)(a2 + 2))
  {
    uint64_t v9 = 0LL;
    unint64_t v10 = 0LL;
    while (1)
    {
      uint64_t v11 = a2 + v9;
      uint64_t v12 = &v8[v9];
      *(_WORD *)&v8[v9 + 18] = *(_WORD *)(a2 + v9 + 18);
      unsigned int v13 = *(unsigned __int8 *)(a2 + v9 + 16);
      if (v13 < 3) {
        break;
      }
      if (v13 == 4)
      {
        v12[16] = 4;
        uint64_t v16 = &v8[v9];
        *((_WORD *)v16 + 1memset((char *)&v11[1] + 1, 0, 7) = *(_WORD *)(a2 + v9 + 34);
        v16[32] = *(_BYTE *)(a2 + v9 + 32);
        sub_1001EF2D8(&v8[v9 + 24], *(void *)(a2 + v9 + 24), 0LL);
        goto LABEL_13;
      }

      if (v13 == 3)
      {
        v12[16] = 3;
        unsigned __int16 v14 = &v8[v9 + 24];
        __int16 v15 = (const void *)(a2 + v9 + 24);
LABEL_10:
        memmove(v14, v15, *(unsigned __int16 *)(v11 + 18));
      }

void sub_1001EF45C(uint64_t a1)
{
  if (*(_BYTE *)(a1 + 2))
  {
    unint64_t v2 = 0LL;
    uint64_t v3 = a1 + 18;
    do
    {
      unsigned int v4 = *(unsigned __int8 *)(v3 - 2);
      if (v4 >= 2)
      {
        if (v4 == 4)
        {
          *(_BYTE *)(*(void *)(v3 + 6) + 1LL) = *(_BYTE *)(v3 + 14);
          *(_WORD *)(*(void *)(v3 + 6) + 6LL) = *(_WORD *)(v3 + 16);
          *(_WORD *)(*(void *)(v3 + 6) + 4LL) = *(_WORD *)v3;
          sub_1001EF45C(*(void *)(v3 + 6));
        }
      }

      else
      {
        uint64_t v5 = *(void **)(v3 + 6);
        if (!v5) {
          sub_1000E6B88( "/Library/Caches/com.apple.xbs/Sources/MobileBluetooth_base/Stack/corestack/support/oi_mbuf.c",  133,  "cell->buf.ptr");
        }
        sub_1000B1838(v5);
        *(void *)(v3 + 6) = 0LL;
      }

      v3 += 24LL;
      ++v2;
    }

    while (v2 < *(unsigned __int8 *)(a1 + 2));
  }

  *(_DWORD *)(a1 + 4) = 0;
  *(_WORD *)(a1 + 1) = 0;
  *(void *)(a1 + 8) = 0LL;
  sub_1000B1838((void *)a1);
}

uint64_t sub_1001EF520(uint64_t a1, unsigned int a2)
{
  if (!a1) {
    sub_1000E6B88( "/Library/Caches/com.apple.xbs/Sources/MobileBluetooth_base/Stack/corestack/support/oi_mbuf.c",  171,  "mbuf != NULL");
  }
  if (!a2) {
    sub_1000E6B88( "/Library/Caches/com.apple.xbs/Sources/MobileBluetooth_base/Stack/corestack/support/oi_mbuf.c",  172,  "numCells > 0");
  }
  if (a2 < 5)
  {
    uint64_t v9 = 0LL;
    *(_BYTE *)a1 = a2;
    *(_WORD *)(a1 + 1) = 0;
    *(_DWORD *)(a1 + 4) = 0;
    *(void *)(a1 + 8) = 0LL;
    return v9;
  }

  uint64_t v9 = 124LL;
  sub_1001EE134((uint64_t)"OI_MBUF_Init %!", v2, v3, v4, v5, v6, v7, v8, 124LL);
  unint64_t v10 = (os_log_s *)sub_100086554(0x30u);
  if (os_log_type_enabled(v10, OS_LOG_TYPE_ERROR))
  {
    sub_100657858();
    return 124LL;
  }

  return v9;
}

void sub_1001EF5E4(uint64_t a1)
{
  unsigned int v2 = *(unsigned __int8 *)(a1 + 2);
  if (*(_BYTE *)(a1 + 2))
  {
    unint64_t v3 = 0LL;
    uint64_t v4 = a1 + 18;
    do
    {
      unsigned int v5 = *(unsigned __int8 *)(v4 - 2);
      if (v5 >= 2)
      {
        if (v5 == 4)
        {
          *(_BYTE *)(*(void *)(v4 + 6) + 1LL) = *(_BYTE *)(v4 + 14);
          *(_WORD *)(*(void *)(v4 + 6) + 6LL) = *(_WORD *)(v4 + 16);
          *(_WORD *)(*(void *)(v4 + 6) + 4LL) = *(_WORD *)v4;
        }
      }

      else
      {
        uint64_t v6 = *(void **)(v4 + 6);
        if (!v6) {
          sub_1000E6B88( "/Library/Caches/com.apple.xbs/Sources/MobileBluetooth_base/Stack/corestack/support/oi_mbuf.c",  207,  "cell->buf.ptr");
        }
        sub_1000B1838(v6);
        *(void *)(v4 + 6) = 0LL;
        unsigned int v2 = *(unsigned __int8 *)(a1 + 2);
      }

      v4 += 24LL;
      ++v3;
    }

    while (v3 < v2);
  }

  *(_DWORD *)(a1 + 4) = 0;
  *(_WORD *)(a1 + 1) = 0;
  *(void *)(a1 + 8) = 0LL;
}

void sub_1001EF69C(void *a1)
{
}

uint64_t sub_1001EF6C0(uint64_t result)
{
  *(_BYTE *)(result + 1) = 0;
  *(_DWORD *)(result + 4) = 0;
  unsigned int v1 = *(unsigned __int8 *)(result + 2);
  if (*(_BYTE *)(result + 2))
  {
    uint64_t v2 = result;
    unint64_t v3 = 0LL;
    uint64_t v4 = result + 16;
    do
    {
      *(_WORD *)(v2 + 4) += *(_WORD *)(v4 + 2);
      if (*(_BYTE *)v4 == 4)
      {
        uint64_t result = sub_1001EF6C0(*(void *)(v4 + 8));
        unsigned int v1 = *(unsigned __int8 *)(v2 + 2);
      }

      v4 += 24LL;
      ++v3;
    }

    while (v3 < v1);
  }

  return result;
}

void sub_1001EF734(void **ptr, void *a2, _WORD *a3)
{
  if (!ptr || !a2 || !a3) {
    sub_1000E6B88( "/Library/Caches/com.apple.xbs/Sources/MobileBluetooth_base/Stack/corestack/support/oi_mbuf.c",  331,  "mbuf && data && len");
  }
  unsigned int v6 = *(unsigned __int8 *)ptr;
  if (v6 >= 2) {
    sub_1000E6B88( "/Library/Caches/com.apple.xbs/Sources/MobileBluetooth_base/Stack/corestack/support/oi_mbuf.c",  332,  "mbuf->allocCells <= 1");
  }
  if (*((unsigned __int8 *)ptr + 2) != v6) {
    sub_1000E6B88( "/Library/Caches/com.apple.xbs/Sources/MobileBluetooth_base/Stack/corestack/support/oi_mbuf.c",  333,  "mbuf->usedCells == mbuf->allocCells");
  }
  if (v6 != 1) {
    goto LABEL_11;
  }
  if (!*((_BYTE *)ptr + 16))
  {
    sub_1000B1838(ptr[3]);
    goto LABEL_11;
  }

  if (*((_BYTE *)ptr + 16) != 2)
  {
LABEL_11:
    __int16 v7 = 0;
    *a2 = 0LL;
    goto LABEL_12;
  }

  *a2 = ptr[3];
  __int16 v7 = *((_WORD *)ptr + 9);
LABEL_12:
  *a3 = v7;
  sub_1000B1838(ptr);
}

void *sub_1001EF80C(char *a1, size_t a2, int a3)
{
  if (a1 && (_DWORD)a2)
  {
    unsigned int v6 = sub_1000B17F4(0x28uLL);
    __int16 v7 = v6;
    if (v6)
    {
      *unsigned int v6 = 1;
      void v6[3] = 0;
      *((_BYTE *)v6 + 2) = 1;
      void v6[2] = a2;
      uint64_t v8 = sub_1001EF904((uint64_t)(v6 + 8), a1, a2, a3);
      if ((_DWORD)v8)
      {
        uint64_t v9 = v8;
        if (sub_1000A86F0())
        {
          sub_1001EE134((uint64_t)"OI_MBUF_Wrap - InitCell failed %!", v10, v11, v12, v13, v14, v15, v16, v9);
          uint64_t v17 = (os_log_s *)sub_100086554(0x30u);
          if (os_log_type_enabled(v17, OS_LOG_TYPE_ERROR)) {
            sub_100657858();
          }
        }

        sub_1001EF5E4((uint64_t)v7);
        sub_1000B1838(v7);
        return 0LL;
      }
    }
  }

  else
  {
    int v18 = sub_1000B17F4(0x10uLL);
    __int16 v7 = v18;
    if (v18)
    {
      *int v18 = 0;
      *((_BYTE *)v18 + 2) = 0;
      *((_DWORD *)v18 + 1) = 0;
    }
  }

  return v7;
}

uint64_t sub_1001EF904(uint64_t a1, char *a2, size_t size, int a4)
{
  unsigned int v4 = size;
  if (a4) {
    goto LABEL_2;
  }
  if (size <= 8)
  {
    if ((_DWORD)size)
    {
      __int16 v7 = (_BYTE *)(a1 + 8);
      uint64_t v8 = size;
      do
      {
        char v9 = *a2++;
        *v7++ = v9;
        --v8;
      }

      while (v8);
    }

    LOBYTE(a4) = 3;
    goto LABEL_8;
  }

  uint64_t v11 = (char *)sub_1000B17F4(size);
  if (v11)
  {
    uint64_t v12 = v11;
    memmove(v11, a2, v4);
    LOBYTE(a4) = 0;
    a2 = v12;
LABEL_2:
    *(void *)(a1 + 8) = a2;
LABEL_8:
    uint64_t result = 0LL;
    *(_BYTE *)a1 = a4;
    *(_WORD *)(a1 + 2) = v4;
    return result;
  }

  *(void *)(a1 + 8) = 0LL;
  *(_WORD *)(a1 + 2) = 0;
  *(_BYTE *)a1 = 2;
  return 106LL;
}

uint64_t sub_1001EF9BC(unsigned __int8 *a1, char *a2, size_t size, unsigned int a4)
{
  if (!a1) {
    sub_1000E6B88( "/Library/Caches/com.apple.xbs/Sources/MobileBluetooth_base/Stack/corestack/support/oi_mbuf.c",  403,  "mbuf");
  }
  if (!a2) {
    sub_1000E6B88( "/Library/Caches/com.apple.xbs/Sources/MobileBluetooth_base/Stack/corestack/support/oi_mbuf.c",  404,  "buf");
  }
  if (*((_WORD *)a1 + 3)) {
    sub_1000E6B88( "/Library/Caches/com.apple.xbs/Sources/MobileBluetooth_base/Stack/corestack/support/oi_mbuf.c",  405,  "mbuf->currPos == 0");
  }
  if (a4 > 2) {
    return 101LL;
  }
  __int16 v6 = size;
  if (!(_DWORD)size) {
    return 0LL;
  }
  uint64_t v7 = a1[2];
  if (v7 >= *a1)
  {
    if (sub_1000A86F0())
    {
      sub_1001EE134((uint64_t)"MBUF Prepend overflow: alloc %d", v13, v14, v15, v16, v17, v18, v19, *a1);
      int v20 = (os_log_s *)sub_100086554(0x30u);
      if (os_log_type_enabled(v20, OS_LOG_TYPE_ERROR)) {
        sub_100657858();
      }
    }

    return 124LL;
  }

  else
  {
    if (a1[2])
    {
      uint64_t v8 = (uint64_t)&a1[24 * a1[2] + 16];
      uint64_t v9 = v7 - 1;
      do
      {
        uint64_t v10 = v9;
        uint64_t v11 = &a1[24 * v9];
        __int128 v12 = *((_OWORD *)v11 + 1);
        *(void *)(v8 + 16) = *((void *)v11 + 4);
        *(_OWORD *)uint64_t v8 = v12;
        v8 -= 24LL;
        --v9;
      }

      while (v10);
    }

    a1[2] = v7 + 1;
    uint64_t result = sub_1001EF904((uint64_t)(a1 + 16), a2, size, a4);
    if (!(_DWORD)result) {
      *((_WORD *)a1 + 2) += v6;
    }
  }

  return result;
}

uint64_t sub_1001EFB10(unsigned __int8 *a1, char *a2, size_t size, unsigned int a4)
{
  if (!a1) {
    sub_1000E6B88( "/Library/Caches/com.apple.xbs/Sources/MobileBluetooth_base/Stack/corestack/support/oi_mbuf.c",  452,  "mbuf");
  }
  if (*((_WORD *)a1 + 3)) {
    sub_1000E6B88( "/Library/Caches/com.apple.xbs/Sources/MobileBluetooth_base/Stack/corestack/support/oi_mbuf.c",  453,  "mbuf->currPos == 0");
  }
  if (a4 > 2) {
    return 101LL;
  }
  __int16 v6 = size;
  if (!(_DWORD)size) {
    return 0LL;
  }
  if (a1[2] >= *a1)
  {
    if (sub_1000A86F0())
    {
      sub_1001EE134((uint64_t)"MBUF Append overflow: alloc %d", v7, v8, v9, v10, v11, v12, v13, *a1);
      uint64_t v14 = (os_log_s *)sub_100086554(0x30u);
      if (os_log_type_enabled(v14, OS_LOG_TYPE_ERROR)) {
        sub_100657858();
      }
    }

    return 124LL;
  }

  else
  {
    uint64_t result = sub_1001EF904((uint64_t)&a1[24 * a1[2] + 16], a2, size, a4);
    if (!(_DWORD)result)
    {
      ++a1[2];
      *((_WORD *)a1 + 2) += v6;
    }
  }

  return result;
}

uint64_t sub_1001EFC20(unsigned __int8 *a1, uint64_t a2)
{
  unsigned int v3 = a1[2];
  if (v3 >= *a1)
  {
    if (sub_1000A86F0())
    {
      sub_1001EE134((uint64_t)"MBUF Append Mbuf overflow: alloc %d", v6, v7, v8, v9, v10, v11, v12, *a1);
      uint64_t v13 = (os_log_s *)sub_100086554(0x30u);
      if (os_log_type_enabled(v13, OS_LOG_TYPE_ERROR)) {
        sub_100657858();
      }
    }

    return 124LL;
  }

  else
  {
    uint64_t result = 0LL;
    unsigned int v5 = &a1[24 * v3];
    a1[2] = v3 + 1;
    *((_WORD *)a1 + 2) += *(_WORD *)(a2 + 4);
    v5[16] = 4;
    *((void *)v5 + 3) = a2;
    *((_WORD *)v5 + 9) = *(_WORD *)(a2 + 4);
    v5[32] = *(_BYTE *)(a2 + 1);
    *((_WORD *)v5 + 1memset((char *)&v11[1] + 1, 0, 7) = *(_WORD *)(a2 + 6);
  }

  return result;
}

uint64_t sub_1001EFCEC(char *a1, uint64_t a2, unsigned int a3)
{
  if (!a1) {
    sub_1000E6B88( "/Library/Caches/com.apple.xbs/Sources/MobileBluetooth_base/Stack/corestack/support/oi_mbuf.c",  525,  "dest");
  }
  if (!a2) {
    sub_1000E6B88( "/Library/Caches/com.apple.xbs/Sources/MobileBluetooth_base/Stack/corestack/support/oi_mbuf.c",  526,  "src");
  }
  if (!a3) {
    return 0LL;
  }
  unsigned int v4 = a1;
  unsigned __int16 v5 = *(_WORD *)(a2 + 6);
  else {
    uint64_t v6 = *(unsigned __int16 *)(a2 + 4);
  }
  uint64_t v7 = (void *)(a2 + 24LL * *(unsigned __int8 *)(a2 + 1) + 24);
  unsigned __int16 v8 = v6;
  while (1)
  {
    int v9 = *((unsigned __int8 *)v7 - 8);
    uint64_t v10 = v7;
    if (v9 == 3) {
      break;
    }
    if (v9 != 4)
    {
      uint64_t v10 = (void *)*v7;
      break;
    }

    if (v5) {
      sub_1000E6B88( "/Library/Caches/com.apple.xbs/Sources/MobileBluetooth_base/Stack/corestack/support/oi_mbuf.c",  540,  "currPos == 0");
    }
    unsigned int v11 = sub_1001EFCEC(v4, *v7, v8);
    if (v11 > v8) {
      sub_1000E6B88( "/Library/Caches/com.apple.xbs/Sources/MobileBluetooth_base/Stack/corestack/support/oi_mbuf.c",  542,  "len <= numBytes");
    }
    unsigned __int16 v12 = v11;
    if (v11 == v8)
    {
      __int16 v16 = 0;
      goto LABEL_22;
    }

uint64_t sub_1001EFEB8(uint64_t a1, uint64_t a2)
{
  if (!a1) {
    sub_1000E6B88( "/Library/Caches/com.apple.xbs/Sources/MobileBluetooth_base/Stack/corestack/support/oi_mbuf.c",  582,  "mbuf");
  }
  uint64_t v2 = *(unsigned __int16 *)(a1 + 4);
  if (v2 > a2)
  {
    *(_WORD *)(a1 + 4) = a2;
    uint64_t v2 = a2;
  }

  *(_WORD *)(a1 + 6) = 0;
  *(_BYTE *)(a1 + 1) = 0;
  return v2;
}

uint64_t sub_1001EFF04(uint64_t a1, unsigned int a2)
{
  if (!a1) {
    sub_1000E6B88( "/Library/Caches/com.apple.xbs/Sources/MobileBluetooth_base/Stack/corestack/support/oi_mbuf.c",  605,  "mbuf");
  }
  uint64_t v2 = *(unsigned __int8 *)(a1 + 1);
  uint64_t v3 = *(unsigned __int8 *)(a1 + 2);
  if (v2 >= v3) {
    sub_1000E6B88( "/Library/Caches/com.apple.xbs/Sources/MobileBluetooth_base/Stack/corestack/support/oi_mbuf.c",  606,  "mbuf->currCell < mbuf->usedCells");
  }
  unsigned __int16 v4 = *(_WORD *)(a1 + 6) + *(_WORD *)(a1 + 4);
  *(_WORD *)(a1 + 6) = v4;
  unsigned int v5 = *(unsigned __int16 *)(a1 + 24LL * v2 + 18);
  if (v5 <= v4)
  {
    uint64_t v6 = (unsigned __int16 *)(a1 + 24LL * v2 + 42);
    uint64_t v7 = v2 + 1;
    do
    {
      LOBYTE(v2) = v7;
      v4 -= v5;
      if (v3 == v7) {
        break;
      }
      unsigned int v8 = *v6;
      v6 += 12;
      LOWORD(v5) = v8;
      ++v7;
    }

    while (v8 <= v4);
    *(_WORD *)(a1 + 6) = v4;
    *(_BYTE *)(a1 + 1) = v2;
  }

  if (v2 == (_DWORD)v3)
  {
    LOWORD(v9) = 0;
    unsigned __int8 v10 = v3 - 1;
    *(_BYTE *)(a1 + 1) = v10;
    *(_WORD *)(a1 + 6) = *(_WORD *)(a1 + 24LL * v10 + 18);
  }

  else
  {
    unsigned int v11 = *(unsigned __int16 *)(a1 + 24LL * v2 + 18);
    BOOL v12 = v11 >= v4;
    unsigned int v9 = v11 - v4;
    if (!v12) {
      sub_1000E6B88( "/Library/Caches/com.apple.xbs/Sources/MobileBluetooth_base/Stack/corestack/support/oi_mbuf.c",  638,  "mbuf->cells[mbuf->currCell].len >= mbuf->currPos");
    }
    if (v2 + 1 < v3)
    {
      unsigned int v13 = (unsigned __int16 *)(a1 + 24LL * v2 + 42);
      uint64_t v14 = ~(unint64_t)v2 + v3;
      do
      {
        int v15 = *v13;
        v13 += 12;
        v9 += v15;
        --v14;
      }

      while (v14);
    }

    if (v9 >= a2) {
      LOWORD(v9) = a2;
    }
  }

  *(_WORD *)(a1 + 4) = v9;
  return (unsigned __int16)v9;
}

uint64_t sub_1001F0050(uint64_t result, uint64_t a2, unint64_t a3)
{
  if (a3)
  {
    uint64_t v3 = 0LL;
    unsigned __int16 v4 = (char *)(a3 + a2 - 1);
    do
    {
      char v5 = *v4--;
      *(_BYTE *)(result + v3++) = v5;
    }

    while (a3 > v3);
  }

  return result;
}

void sub_1001F0078(uint64_t a1, char *a2, _WORD *a3)
{
  unsigned int v6 = *(unsigned __int16 *)(sub_1001EDBA0(0x2Cu) + 10);
  if (a1)
  {
    if (a2) {
      goto LABEL_3;
    }
LABEL_26:
    sub_1001EE2A0();
    if (a3) {
      goto LABEL_4;
    }
    goto LABEL_27;
  }

  sub_1001EE2A0();
  if (!a2) {
    goto LABEL_26;
  }
LABEL_3:
  if (a3) {
    goto LABEL_4;
  }
LABEL_27:
  sub_1001EE2A0();
LABEL_4:
  if (dword_1008F6FCC)
  {
    if (*(_WORD *)(qword_1008EF8A0 + 20))
    {
      char v7 = 0;
      uint64_t v8 = *(void *)(qword_1008EF8A0 + 24);
      uint64_t v9 = *(unsigned __int16 *)(qword_1008EF8A0 + 20);
      do
      {
        if (*(_DWORD *)(v8 + 56) >> 18 >= 0x69u
          && (unsigned __int16)*(_DWORD *)(v8 + 56) < *(unsigned __int16 *)(qword_1008EF8A0 + 20)
          && *(_DWORD *)a1 == *(_DWORD *)v8
          && *(unsigned __int16 *)(a1 + 4) == *(unsigned __int16 *)(v8 + 4))
        {
          if (*(_BYTE *)(v8 + 24)) {
            char v7 = 1;
          }
          unsigned int v12 = v6 & 0xFFFFFFFD;
          if ((*(_BYTE *)(v8 + 40) & 1) == 0) {
            unsigned int v12 = v6;
          }
          if ((*(_BYTE *)(v8 + 40) & 2) != 0) {
            unsigned int v6 = v12 & 0xFFFFFFFB;
          }
          else {
            unsigned int v6 = v12;
          }
        }

        v8 += 64LL;
        --v9;
      }

      while (v9);
    }

    else
    {
      char v7 = 0;
    }
  }

  else
  {
    if (sub_1000A86F0())
    {
      sub_1001EE134((uint64_t)"OI_POLICYMGR_GetDevmgrPolicy", v13, v14, v15, v16, v17, v18, v19, v21);
      int v20 = (os_log_s *)sub_100086554(0x31u);
      if (os_log_type_enabled(v20, OS_LOG_TYPE_ERROR)) {
        sub_10065BE10();
      }
    }

    char v7 = 0;
  }

  *a2 = v7;
  *a3 = v6;
}

uint64_t sub_1001F01C4(uint64_t a1)
{
  if (a1)
  {
    if (sub_1000A86F0())
    {
      sub_1001EE134( (uint64_t)"OI_POLICYMGR_Init: configuration parameter is deprecated",  v2,  v3,  v4,  v5,  v6,  v7,  v8,  v19);
      uint64_t v9 = (os_log_s *)sub_100086554(0x31u);
      if (os_log_type_enabled(v9, OS_LOG_TYPE_ERROR)) {
        sub_100657858();
      }
    }

    sub_1001EDBE4(a1, 49LL);
  }

  if (dword_1008F6FCC) {
    return 140LL;
  }
  uint64_t v11 = sub_1001EDBA0(0x31u);
  if (v11)
  {
    unsigned int v12 = (unsigned __int16 *)v11;
    uint64_t v13 = sub_1000B1814(0x30uLL);
    qword_1008EF8A0 = (uint64_t)v13;
    if (v13)
    {
      v13[4] = 0;
      uint64_t v14 = *v12;
      *((_WORD *)v13 + 10) = v14;
      uint64_t v15 = sub_1000B1814(v14 << 6);
      uint64_t v16 = qword_1008EF8A0;
      *(void *)(qword_1008EF8A0 + 24) = v15;
      if (!v15)
      {
        sub_1001EE2A0();
        uint64_t v16 = qword_1008EF8A0;
      }

      uint64_t v17 = *(unsigned __int16 *)(v16 + 20);
      if (*(_WORD *)(v16 + 20))
      {
        uint64_t v18 = (_DWORD *)(*(void *)(v16 + 24) + 56LL);
        do
        {
          *uint64_t v18 = 0;
          v18 += 16;
          --v17;
        }

        while (v17);
      }

      uint64_t result = 0LL;
      *(_WORD *)(v16 + 32) = 420;
      *(_DWORD *)(v16 + 16) = 1;
      *(void *)(v16 + 40) = 0LL;
      dword_1008F6FCC = 1;
    }

    else
    {
      return 106LL;
    }
  }

  else
  {
    sub_1001EE2A0();
    return 127LL;
  }

  return result;
}

void sub_1001F02E8(uint64_t a1)
{
  if (!dword_1008F6FCC) {
    sub_1001EE2A0();
  }
  *(void *)(qword_1008EF8A0 + 40) = a1;
}

uint64_t sub_1001F0324(uint64_t a1, uint64_t a2, __int128 *a3, int *a4, char a5)
{
  if (a3 && a2 && a4)
  {
    if (dword_1008F6FCC)
    {
      v33[0] = 0LL;
      uint64_t v31 = 0LL;
      v32[0] = 0LL;
      uint64_t result = sub_10010EEE0(a2, &v31);
      if (!(_DWORD)result)
      {
        uint64_t v11 = qword_1008EF8A0;
        unsigned int v12 = (unsigned __int16)(*(_WORD *)(qword_1008EF8A0 + 32) + 1);
        if (v12 <= 0x1A4) {
          __int16 v13 = 420;
        }
        else {
          __int16 v13 = *(_WORD *)(qword_1008EF8A0 + 32) + 1;
        }
        *(_WORD *)(qword_1008EF8A0 + 32) = v13;
        uint64_t v14 = *(unsigned __int16 *)(v11 + 20);
        if (*(_WORD *)(v11 + 20))
        {
          uint64_t v15 = *(void *)(v11 + 24);
          if (v12 <= 0x1A4) {
            int v16 = 420;
          }
          else {
            int v16 = v12;
          }
          int v17 = v16 << 16;
          uint64_t v18 = v15 + 56;
          while (*(_DWORD *)v18)
          {
            ++v17;
            v18 += 64LL;
            if (!--v14) {
              goto LABEL_16;
            }
          }

          *(_DWORD *)uint64_t v18 = v17;
          int v27 = *(_DWORD *)a2;
          *(_WORD *)(v18 - 52) = *(_WORD *)(a2 + 4);
          *(_DWORD *)(v18 - 56) = v27;
          *(_BYTE *)(v18 + 4) = a5;
          __int128 v28 = a3[2];
          __int128 v29 = *a3;
          *(_OWORD *)(v18 - 32) = a3[1];
          *(_OWORD *)(v18 - 16) = v28;
          *(_OWORD *)(v18 - 48) = v29;
          v32[1] = a1;
          LODWORD(v32[0]) = v17;
          *a4 = v17;
          v33[1] = v32;
          LOWORD(v33[0]) = 16;
          return sub_1001EE6DC((uint64_t)sub_1001F04A8, v33, 0LL);
        }

        else
        {
LABEL_16:
          if (sub_1000A86F0())
          {
            sub_1001EE134( (uint64_t)"OI_POLICYMGR_NewConnection: connection list full!",  v19,  v20,  v21,  v22,  v23,  v24,  v25,  v30);
            uint64_t v26 = (os_log_s *)sub_100086554(0x31u);
            if (os_log_type_enabled(v26, OS_LOG_TYPE_ERROR)) {
              sub_100657858();
            }
          }

          return 104LL;
        }
      }
    }

    else
    {
      return 103LL;
    }
  }

  else
  {
    sub_1001EE2A0();
    return 101LL;
  }

  return result;
}

void sub_1001F04A8(uint64_t a1)
{
  int v66 = 0LL;
  int v67 = 0LL;
  unsigned int v1 = *(unsigned int **)(a1 + 8);
  if (sub_1000A86F0())
  {
    sub_1001EE134((uint64_t)"Trace deferredEnforcerCB, handle 0x%x", v2, v3, v4, v5, v6, v7, v8, *v1);
    uint64_t v9 = (os_log_s *)sub_100086554(0x31u);
    if (os_log_type_enabled(v9, OS_LOG_TYPE_DEFAULT))
    {
      *(_DWORD *)__int128 buf = 136446210;
      uint64_t v69 = sub_1001EDDCC();
      _os_log_impl((void *)&_mh_execute_header, v9, OS_LOG_TYPE_DEFAULT, " %{public}s", buf, 0xCu);
    }
  }

  BOOL v10 = sub_1001C3234(*(void *)(qword_1008EF8A0 + 24) + ((unint64_t)*(unsigned __int16 *)v1 << 6));
  if (*(_DWORD *)(qword_1008EF8A0 + 16) != 1 || v10)
  {
    uint64_t v65 = 0LL;
    sub_1000B0400((uint64_t)&v65);
    unsigned int v12 = sub_1001F4324(&dword_1008EF8A8, (int *)&v65);
    if (dword_1008EF8A8 && v12 >= 0x258) {
      sub_1000B034C(1501LL, "Policy enforcement timeout");
    }
    if (sub_1000A86F0())
    {
      uint64_t v20 = *(int *)(qword_1008EF8A0 + 16);
      uint64_t v21 = v20 > 5 ? "unknown" : off_100886BC0[v20];
      sub_1001EE134( (uint64_t)"deferredEnforcerCB busy, reposting request, pmanState %s",  v13,  v14,  v15,  v16,  v17,  v18,  v19,  (uint64_t)v21);
      int v44 = (os_log_s *)sub_100086554(0x31u);
      if (os_log_type_enabled(v44, OS_LOG_TYPE_DEFAULT))
      {
        int v45 = sub_1001EDDCC();
        *(_DWORD *)__int128 buf = 136446210;
        uint64_t v69 = v45;
        _os_log_impl((void *)&_mh_execute_header, v44, OS_LOG_TYPE_DEFAULT, " %{public}s", buf, 0xCu);
      }
    }

    int v67 = v1;
    LOWORD(v66) = 16;
    uint64_t v46 = sub_1001EE6E8((uint64_t)sub_1001F04A8, &v66, 1, 0LL);
    if ((_DWORD)v46)
    {
      uint64_t v47 = v46;
      if (sub_1000A86F0())
      {
        sub_1001EE134((uint64_t)"OI_Dispatch_RegisterTimedFunc failed %!", v48, v49, v50, v51, v52, v53, v54, v47);
        char v55 = (os_log_s *)sub_100086554(0x31u);
        if (os_log_type_enabled(v55, OS_LOG_TYPE_ERROR)) {
          sub_100657858();
        }
      }

      (*((void (**)(void, uint64_t, void))v1 + 1))(*v1, v47, 0LL);
    }

    return;
  }

  sub_1000B0400((uint64_t)&dword_1008EF8A8);
  uint64_t v22 = qword_1008EF8A0;
  *(_OWORD *)qword_1008EF8A0 = *(_OWORD *)v1;
  uint64_t v23 = *(void *)(v22 + 24) + ((unint64_t)(unsigned __int16)*(_DWORD *)v22 << 6);
  if (*(_DWORD *)(v23 + 56) != *(_DWORD *)v22)
  {
    if (sub_1000A86F0())
    {
      sub_1001EE134( (uint64_t)"startSecurityPolicyEnforcement, handle %d no longer valid",  v36,  v37,  v38,  v39,  v40,  v41,  v42,  *(unsigned int *)qword_1008EF8A0);
      unsigned int v43 = (os_log_s *)sub_100086554(0x31u);
      if (os_log_type_enabled(v43, OS_LOG_TYPE_ERROR)) {
        sub_100657858();
      }
    }

    uint64_t v34 = 122LL;
    uint64_t v35 = 0LL;
    goto LABEL_23;
  }

  uint64_t v24 = sub_1001EA358( sub_1001F0FEC,  v23,  *(void *)(v23 + 8),  *(void *)(v23 + 16),  *(_DWORD *)v22,  *(_BYTE *)(v23 + 60));
  if ((_DWORD)v24)
  {
    uint64_t v25 = v24;
    if (sub_1000A86F0())
    {
      sub_1001EE134( (uint64_t)"OI_SECMGR_EnforcePolicy failed addr %:, status %!",  v26,  v27,  v28,  v29,  v30,  v31,  v32,  v23);
      int v33 = (os_log_s *)sub_100086554(0x31u);
      if (os_log_type_enabled(v33, OS_LOG_TYPE_ERROR)) {
        sub_10065AFF0(v33);
      }
    }

    uint64_t v34 = v25;
    uint64_t v35 = 1LL;
LABEL_23:
    sub_1001F0E40(v34, v35);
    return;
  }

  if (sub_1000A86F0())
  {
    sub_1001EE134( (uint64_t)"Trace startSecurityPolicyEnforcement handle %#x : %s --------------------> %s\n\n\n\n",  v56,  v57,  v58,  v59,  v60,  v61,  v62,  *(unsigned int *)(v23 + 56));
    int v63 = (os_log_s *)sub_100086554(0x31u);
    if (os_log_type_enabled(v63, OS_LOG_TYPE_DEFAULT))
    {
      int v64 = sub_1001EDDCC();
      *(_DWORD *)__int128 buf = 136446210;
      uint64_t v69 = v64;
      _os_log_impl((void *)&_mh_execute_header, v63, OS_LOG_TYPE_DEFAULT, " %{public}s", buf, 0xCu);
    }
  }

  *(_DWORD *)(qword_1008EF8A0 + 16) = 2;
}

void sub_1001F08BC(uint64_t a1)
{
  __int16 v33 = 0;
  int v32 = 0;
  v30[0] = 0LL;
  v29[0] = 0LL;
  if (dword_1008F6FCC)
  {
    if ((_DWORD)a1)
    {
      if (a1 >> 18 < 0x69
        || (unsigned __int16)a1 >= *(unsigned __int16 *)(qword_1008EF8A0 + 20))
      {
        if (sub_1000A86F0())
        {
          sub_1001EE134((uint64_t)"OI_POLICYMGR_Disconnect invalid handle 0x%x", v20, v21, v22, v23, v24, v25, v26, a1);
          uint64_t v27 = (os_log_s *)sub_100086554(0x31u);
          if (os_log_type_enabled(v27, OS_LOG_TYPE_ERROR)) {
            sub_100657858();
          }
        }
      }

      else if (sub_1001F0A64(a1, (uint64_t)&v32))
      {
        int v31 = 0;
        if (sub_1001F0B58((uint64_t)&v32, &v31))
        {
          v29[1] = nullsub_79;
          LODWORD(v29[0]) = *(_DWORD *)(*(void *)(qword_1008EF8A0 + 24) + ((uint64_t)v31 << 6) + 56);
          v30[1] = v29;
          LOWORD(v30[0]) = 16;
          uint64_t v2 = sub_1001EE6DC((uint64_t)sub_1001F0BD4, v30, 0LL);
          if ((_DWORD)v2)
          {
            uint64_t v3 = v2;
            if (sub_1000A86F0())
            {
              sub_1001EE134((uint64_t)"OI_Dispatch_RegisterFunc failed %!", v4, v5, v6, v7, v8, v9, v10, v3);
              uint64_t v11 = (os_log_s *)sub_100086554(0x31u);
              if (os_log_type_enabled(v11, OS_LOG_TYPE_ERROR)) {
                sub_100657858();
              }
            }
          }
        }
      }
    }
  }

  else if (sub_1000A86F0())
  {
    sub_1001EE134((uint64_t)"OI_POLICYMGR_Disconnect", v12, v13, v14, v15, v16, v17, v18, v28);
    uint64_t v19 = (os_log_s *)sub_100086554(0x31u);
    if (os_log_type_enabled(v19, OS_LOG_TYPE_ERROR)) {
      sub_10065BE10();
    }
  }

uint64_t sub_1001F0A64(uint64_t a1, uint64_t a2)
{
  if (a1 >> 18 < 0x69
    || (uint64_t v3 = qword_1008EF8A0, (unsigned __int16)a1 >= *(unsigned __int16 *)(qword_1008EF8A0 + 20)))
  {
    uint64_t result = sub_1000A86F0();
    if (!(_DWORD)result) {
      return result;
    }
    sub_1001EE134((uint64_t)"Invalid handle 0x%x", v11, v12, v13, v14, v15, v16, v17, a1);
    uint64_t v18 = (os_log_s *)sub_100086554(0x31u);
    uint64_t result = os_log_type_enabled(v18, OS_LOG_TYPE_ERROR);
    if (!(_DWORD)result) {
      return result;
    }
    sub_100657858();
    return 0LL;
  }

  uint64_t v4 = *(void *)(qword_1008EF8A0 + 24);
  uint64_t v5 = v4 + ((unint64_t)(unsigned __int16)a1 << 6);
  int v7 = *(_DWORD *)(v5 + 56);
  uint64_t v6 = (_DWORD *)(v5 + 56);
  if (v7 != (_DWORD)a1) {
    return 0LL;
  }
  *uint64_t v6 = 0;
  if (a2)
  {
    uint64_t v8 = (int *)(v4 + ((unint64_t)(unsigned __int16)a1 << 6));
    int v9 = *v8;
    *(_WORD *)(a2 + 4) = *((_WORD *)v8 + 2);
    *(_DWORD *)a2 = v9;
  }

  if (*(void *)(v3 + 40))
  {
    uint64_t v19 = 0LL;
  }

  return 1LL;
}

BOOL sub_1001F0B58(uint64_t a1, _DWORD *a2)
{
  unint64_t v2 = *(unsigned __int16 *)(qword_1008EF8A0 + 20);
  if (*(_WORD *)(qword_1008EF8A0 + 20))
  {
    uint64_t v3 = 0LL;
    uint64_t v4 = *(void *)(qword_1008EF8A0 + 24);
    BOOL v5 = 1;
    while (*(_DWORD *)(v4 + 56) >> 18 < 0x69u
         || (unsigned __int16)*(_DWORD *)(v4 + 56) >= v2
         || *(_DWORD *)a1 != *(_DWORD *)v4
         || *(unsigned __int16 *)(a1 + 4) != *(unsigned __int16 *)(v4 + 4))
    {
      BOOL v5 = ++v3 < v2;
      v4 += 64LL;
      if (v2 == v3) {
        return 0;
      }
    }

    *a2 = v3;
  }

  else
  {
    return 0;
  }

  return v5;
}

void sub_1001F0BD4(uint64_t a1)
{
  __int16 v30 = 0;
  char v29 = 0;
  v28[0] = 0LL;
  unsigned int v1 = *(unsigned __int16 **)(a1 + 8);
  BOOL v2 = sub_1001C3234(*(void *)(qword_1008EF8A0 + 24) + ((unint64_t)*v1 << 6));
  uint64_t v3 = qword_1008EF8A0;
  if (*(_DWORD *)(qword_1008EF8A0 + 16) == 1 && !v2)
  {
    *(_OWORD *)qword_1008EF8A0 = *(_OWORD *)v1;
    uint64_t v15 = *(void *)(v3 + 24);
    int v16 = *(_DWORD *)v3;
    uint64_t v17 = v15 + ((unint64_t)(unsigned __int16)v16 << 6);
    if (*(_DWORD *)(v17 + 56) == v16)
    {
      sub_1001F0078(v17, &v29, &v30);
      uint64_t v18 = sub_1001180D8((uint64_t)sub_1001F11BC, v17, v29, v30, *(_DWORD *)(v17 + 56));
      if ((_DWORD)v18)
      {
        uint64_t v19 = v18;
        if (sub_1000A86F0())
        {
          sub_1001EE134((uint64_t)"OI_DEVMGR_EnforceLinkPolicy failed %!", v20, v21, v22, v23, v24, v25, v26, v19);
          uint64_t v27 = (os_log_s *)sub_100086554(0x31u);
          if (os_log_type_enabled(v27, OS_LOG_TYPE_ERROR)) {
            sub_100657858();
          }
        }
      }

      else
      {
        *(_DWORD *)(qword_1008EF8A0 + 16) = 3;
      }
    }
  }

  else
  {
    v28[1] = v1;
    LOWORD(v28[0]) = 16;
    uint64_t v5 = sub_1001EE6E8((uint64_t)sub_1001F0BD4, v28, 1, 0LL);
    if ((_DWORD)v5)
    {
      uint64_t v6 = v5;
      if (sub_1000A86F0())
      {
        sub_1001EE134((uint64_t)"OI_Dispatch_RegisterTimedFunc failed %!", v7, v8, v9, v10, v11, v12, v13, v6);
        uint64_t v14 = (os_log_s *)sub_100086554(0x31u);
        if (os_log_type_enabled(v14, OS_LOG_TYPE_ERROR)) {
          sub_100657858();
        }
      }
    }
  }

void sub_1001F0D54(uint64_t a1)
{
  if (dword_1008F6FCC)
  {
    int v13 = 0;
    if (sub_1001F0B58(a1, &v13))
    {
      uint64_t v2 = qword_1008EF8A0;
      do
      {
        uint64_t v3 = v13;
        if (*(_DWORD *)(v2 + 16) != 1 && *(_DWORD *)v2 == *(_DWORD *)(*(void *)(v2 + 24) + ((uint64_t)v13 << 6) + 56))
        {
          sub_1001F0E40(1500LL, 1LL);
          uint64_t v2 = qword_1008EF8A0;
        }

        *(_DWORD *)(*(void *)(v2 + 24) + (v3 << 6) + 56) = 0;
      }

      while (sub_1001F0B58(a1, &v13));
    }
  }

  else if (sub_1000A86F0())
  {
    sub_1001EE134((uint64_t)"OI_POLICYMGR_DevmgrDisconnect", v4, v5, v6, v7, v8, v9, v10, v12);
    uint64_t v11 = (os_log_s *)sub_100086554(0x31u);
    if (os_log_type_enabled(v11, OS_LOG_TYPE_ERROR)) {
      sub_10065BE10();
    }
  }

uint64_t sub_1001F0E40(uint64_t a1, uint64_t a2)
{
  if (!*(void *)(qword_1008EF8A0 + 8)) {
    sub_1001EE2A0();
  }
  if (sub_1000A86F0())
  {
    sub_1001EE134( (uint64_t)"Trace finishEnforcementEffort handle %#x : %s --------------------> %s\n\n\n\n",  v4,  v5,  v6,  v7,  v8,  v9,  v10,  *(unsigned int *)qword_1008EF8A0);
    uint64_t v11 = (os_log_s *)sub_100086554(0x31u);
    if (os_log_type_enabled(v11, OS_LOG_TYPE_DEFAULT))
    {
      *(_DWORD *)__int128 buf = 136446210;
      uint64_t v23 = sub_1001EDDCC();
      _os_log_impl((void *)&_mh_execute_header, v11, OS_LOG_TYPE_DEFAULT, " %{public}s", buf, 0xCu);
    }
  }

  uint64_t v12 = (unsigned int *)qword_1008EF8A0;
  *(_DWORD *)(qword_1008EF8A0 + 16) = 1;
  dword_1008EF8A8 = 0;
  word_1008EF8AC = 0;
  if ((_DWORD)a1)
  {
    if ((sub_1001F0A64(*v12, 0LL) & 1) == 0)
    {
      if (sub_1000A86F0())
      {
        sub_1001EE134( (uint64_t)"Orphaned policy, handle 0x%x",  v13,  v14,  v15,  v16,  v17,  v18,  v19,  *(unsigned int *)qword_1008EF8A0);
        uint64_t v20 = (os_log_s *)sub_100086554(0x31u);
        if (os_log_type_enabled(v20, OS_LOG_TYPE_ERROR)) {
          sub_100657858();
        }
      }
    }
  }

  return (*(uint64_t (**)(void, uint64_t, uint64_t))(qword_1008EF8A0 + 8))( *(unsigned int *)qword_1008EF8A0,  a1,  a2);
}

void sub_1001F0FEC(uint64_t a1, uint64_t a2)
{
  uint64_t v4 = qword_1008EF8A0;
  if (*(_DWORD *)(qword_1008EF8A0 + 16) != 2)
  {
    sub_1001EE2A0();
    uint64_t v4 = qword_1008EF8A0;
  }

  if (*(_DWORD *)v4 == (_DWORD)a2)
  {
    if ((_DWORD)a1)
    {
      sub_1001F0E40(a1, 1LL);
      return;
    }

    __int16 v34 = 0;
    char v33 = 0;
    uint64_t v13 = *(void *)(v4 + 24) + ((unint64_t)(unsigned __int16)a2 << 6);
    if (*(_DWORD *)(v13 + 56) == (_DWORD)a2)
    {
      sub_1001F0078(v13, &v33, &v34);
      uint64_t v14 = sub_1001180D8((uint64_t)sub_1001F11BC, v13, v33, v34, *(_DWORD *)(v13 + 56));
      if (!(_DWORD)v14)
      {
        *(_DWORD *)(qword_1008EF8A0 + 16) = 3;
        return;
      }

      uint64_t v15 = v14;
      if (sub_1000A86F0())
      {
        sub_1001EE134((uint64_t)"OI_DEVMGR_EnforceLinkPolicy failed %!", v16, v17, v18, v19, v20, v21, v22, v15);
        uint64_t v23 = (os_log_s *)sub_100086554(0x31u);
        if (os_log_type_enabled(v23, OS_LOG_TYPE_ERROR)) {
          sub_100657858();
        }
      }

      uint64_t v24 = v15;
    }

    else
    {
      if (sub_1000A86F0())
      {
        sub_1001EE134( (uint64_t)"startDevmgrPolicyEnforcement, handle %d no longer valid",  v25,  v26,  v27,  v28,  v29,  v30,  v31,  *(unsigned int *)qword_1008EF8A0);
        int v32 = (os_log_s *)sub_100086554(0x31u);
        if (os_log_type_enabled(v32, OS_LOG_TYPE_ERROR)) {
          sub_100657858();
        }
      }

      uint64_t v24 = 122LL;
    }

    sub_1001F0E40(v24, 0LL);
  }

  else if (sub_1000A86F0())
  {
    sub_1001EE134((uint64_t)"cookie does not match current enforcement (%d vs 0x%x)", v5, v6, v7, v8, v9, v10, v11, a2);
    uint64_t v12 = (os_log_s *)sub_100086554(0x31u);
    if (os_log_type_enabled(v12, OS_LOG_TYPE_ERROR)) {
      sub_100657858();
    }
  }

void sub_1001F11BC(uint64_t a1, uint64_t a2, uint64_t a3)
{
  if (*(_DWORD *)(qword_1008EF8A0 + 16) != 3)
  {
    sub_1001EE134( (uint64_t)"Policy Enforce State == %d",  v4,  v5,  v6,  v7,  v8,  v9,  v10,  *(unsigned int *)(qword_1008EF8A0 + 16));
    uint64_t v11 = (os_log_s *)sub_100086554(0x31u);
    if (!os_log_type_enabled(v11, OS_LOG_TYPE_ERROR)) {
      return;
    }
LABEL_7:
    sub_100657858();
    return;
  }

  if (*(_DWORD *)qword_1008EF8A0 != (_DWORD)a3)
  {
    sub_1001EE134( (uint64_t)"cookie does not match current enforcement (0x%x vs 0x%x)",  v12,  v13,  v14,  v15,  v16,  v17,  v18,  a3);
    uint64_t v19 = (os_log_s *)sub_100086554(0x31u);
    if (!os_log_type_enabled(v19, OS_LOG_TYPE_ERROR)) {
      return;
    }
    goto LABEL_7;
  }

  if ((_DWORD)a1)
  {
LABEL_4:
    sub_1001F0E40(a1, 0LL);
    return;
  }

  if (*(_DWORD *)(*(void *)(qword_1008EF8A0 + 24) + ((unint64_t)(unsigned __int16)a3 << 6) + 56) == (_DWORD)a3)
  {
    a1 = sub_1001EE6DC((uint64_t)sub_1001F1348, 0LL, 0LL);
    if ((_DWORD)a1) {
      goto LABEL_4;
    }
    *(_DWORD *)(qword_1008EF8A0 + 16) = 4;
  }

  else
  {
    if (sub_1000A86F0())
    {
      sub_1001EE134( (uint64_t)"startPowerPolicyEnforcement, handle %d no longer valid",  v20,  v21,  v22,  v23,  v24,  v25,  v26,  *(unsigned int *)qword_1008EF8A0);
      uint64_t v27 = (os_log_s *)sub_100086554(0x31u);
      if (os_log_type_enabled(v27, OS_LOG_TYPE_ERROR)) {
        sub_100657858();
      }
    }

    sub_1001F0E40(122LL, 0LL);
  }

uint64_t sub_1001F1348()
{
  __int16 v0 = (unsigned __int16 *)qword_1008EF8A0;
  if (*(_DWORD *)(qword_1008EF8A0 + 16) != 4)
  {
    sub_1001EE2A0();
    __int16 v0 = (unsigned __int16 *)qword_1008EF8A0;
  }

  uint64_t v1 = *((void *)v0 + 3);
  uint64_t v2 = v1 + ((unint64_t)*v0 << 6);
  uint64_t v3 = v0[10];
  if ((_DWORD)v3)
  {
    uint64_t v4 = 0LL;
    uint64_t v5 = v3;
    do
    {
      if (*(_DWORD *)(v1 + 56) >> 18 >= 0x69u
        && (unsigned __int16)*(_DWORD *)(v1 + 56) < v3
        && *(_DWORD *)v2 == *(_DWORD *)v1
        && *(unsigned __int16 *)(v2 + 4) == *(unsigned __int16 *)(v1 + 4))
      {
        uint64_t v8 = *(void *)(v1 + 48);
        if (v8)
        {
          if (!v4
            || *(_DWORD *)v8 > *(_DWORD *)v4
            || *(unsigned __int16 *)(v8 + 4) < *(unsigned __int16 *)(v4 + 4)
            || *(unsigned __int16 *)(v8 + 10) > *(unsigned __int16 *)(v4 + 10))
          {
            uint64_t v4 = *(void *)(v1 + 48);
          }
        }
      }

      v1 += 64LL;
      --v5;
    }

    while (v5);
  }

  else
  {
    uint64_t v4 = 0LL;
  }

  sub_100113D78(v2, (uint64_t *)v4);
  return sub_1001F0E40(0LL, 0LL);
}

double sub_1001F142C(uint64_t a1)
{
  if (sub_1000B0174())
  {
    for (unint64_t i = 0LL; ; ++i)
    {
      uint64_t v3 = off_1008D9000[i];
      if (!v3 || i > 4) {
        break;
      }
    }
  }

  return sub_1001F1498(a1);
}

double sub_1001F1498(unsigned int a1)
{
  if (a1)
  {
    unsigned int v1 = a1;
    if (a1 != 0xFFFF)
    {
      uint64_t v2 = &unk_1008EF8BD;
      byte_1008EF8C5 = 0;
      do
      {
        v2[7] = a0123456789_0[v1 % 0xA];
        --v2;
        BOOL v3 = v1 > 9;
        v1 /= 0xAu;
      }

      while (v3);
      double result = 5.76777859e-153;
      *(void *)uint64_t v2 = 0x2053555441545320LL;
    }
  }

  return result;
}

const char *sub_1001F1518(int a1)
{
  if (a1 <= 1499)
  {
    if (a1 > 1200)
    {
      switch(a1)
      {
        case 1201:
          double result = "OI_HCITRANS_CANNOT_CONNECT_TO_DEVICE";
          break;
        case 1203:
          double result = "OI_HCITRANS_BUFFER_TOO_SMALL";
          break;
        case 1204:
          double result = "OI_HCITRANS_NULL_DEVICE_HANDLE";
          break;
        case 1205:
          double result = "OI_HCITRANS_IO_ERROR";
          break;
        case 1206:
          double result = "OI_HCITRANS_DEVICE_NOT_READY";
          break;
        case 1207:
          double result = "OI_HCITRANS_FUNCTION_NOT_SUPPORTED";
          break;
        case 1209:
          double result = "OI_HCITRANS_ACCESS_DENIED";
          break;
        case 1210:
          double result = "OI_HCITRANS_ACL_DATA_ERROR";
          break;
        case 1211:
          double result = "OI_HCITRANS_SCO_DATA_ERROR";
          break;
        case 1212:
          double result = "OI_HCITRANS_EVENT_DATA_ERROR";
          break;
        case 1214:
          double result = "OI_HCITRANS_INTERNAL_ERROR";
          break;
        case 1215:
          double result = "OI_HCITRANS_LINK_NOT_ACTIVE";
          break;
        case 1216:
          double result = "OI_HCITRANS_INITIALIZING";
          break;
        case 1217:
          double result = "OI_HCITRANS_H4BC_TIMEOUT";
          break;
        case 1218:
          double result = "OI_HCITRANS_NO_RESOURCES";
          break;
        case 1219:
          double result = "OI_HCITRANS_DRIVER_ERROR";
          break;
        case 1220:
          double result = "OI_HCITRANS_DEVICE_FATAL_ERROR";
          break;
        case 1301:
          double result = "OI_DEVMGR_NO_CONNECTION";
          break;
        case 1302:
          double result = "OI_DEVMGR_CONNECTION_PENDING_READY";
          break;
        case 1305:
          double result = "OI_DEVMGR_HARDWARE_ERROR";
          break;
        case 1307:
          double result = "OI_DEVMGR_PENDING_CONNECT_LIST_FULL";
          break;
        case 1309:
          double result = "OI_DEVMGR_CONNECTION_LIST_FULL";
          break;
        case 1310:
          double result = "OI_DEVMGR_NO_SUCH_CONNECTION";
          break;
        case 1311:
          double result = "OI_DEVMGR_INQUIRY_IN_PROGRESS";
          break;
        case 1312:
          double result = "OI_DEVMGR_PERIODIC_INQUIRY_ACTIVE";
          break;
        case 1313:
          double result = "OI_DEVMGR_NO_INQUIRIES_ACTIVE";
          break;
        case 1314:
          double result = "OI_DEVMGR_DUPLICATE_CONNECTION";
          break;
        case 1316:
          double result = "OI_DEVMGR_DUPLICATE_EVENT_CALLBACK";
          break;
        case 1317:
          double result = "OI_DEVMGR_EVENT_CALLBACK_LIST_FULL";
          break;
        case 1318:
          double result = "OI_DEVMGR_EVENT_CALLBACK_NOT_FOUND";
          break;
        case 1319:
          double result = "OI_DEVMGR_BUSY";
          break;
        case 1320:
          double result = "OI_DEVMGR_ENUM_UNEXPECTED_INQ_COMPLETE";
          break;
        case 1321:
          double result = "OI_DEVMGR_ENUM_UNEXPECTED_INQ_RESULT";
          break;
        case 1322:
          double result = "OI_DEVMGR_ENUM_DATABASE_FULL";
          break;
        case 1323:
          double result = "OI_DEVMGR_ENUM_INQUIRIES_OVERLAP";
          break;
        case 1324:
          double result = "OI_DEVMGR_UNKNOWN_LINK_TYPE";
          break;
        case 1325:
          double result = "OI_DEVMGR_PARAM_IO_ACTIVE";
          break;
        case 1326:
          double result = "OI_DEVMGR_UNKNOWN_IAC_LAP";
          break;
        case 1327:
          double result = "OI_DEVMGR_SCO_ALREADY_REGISTERED";
          break;
        case 1328:
          double result = "OI_DEVMGR_SCO_NOT_REGISTERED";
          break;
        case 1329:
          double result = "OI_DEVMGR_SCO_WITHOUT_ACL";
          break;
        case 1330:
          double result = "OI_DEVMGR_NO_SUPPORT";
          break;
        case 1331:
          double result = "OI_DEVMGR_WRITE_POLICY_FAILED";
          break;
        case 1332:
          double result = "OI_DEVMGR_NOT_IN_CENTRAL_MODE";
          break;
        case 1333:
          double result = "OI_DEVMGR_POLICY_VIOLATION";
          break;
        case 1334:
          double result = "OI_DEVMGR_BUSY_TIMEOUT";
          break;
        case 1335:
          double result = "OI_DEVMGR_REENCRYPT_FAILED";
          break;
        case 1336:
          double result = "OI_DEVMGR_ROLE_POLICY_CONFLICT";
          break;
        case 1337:
          double result = "OI_DEVMGR_BAD_INTERVAL";
          break;
        case 1338:
          double result = "OI_DEVMGR_INVALID_SCO_HANDLE";
          break;
        case 1339:
          double result = "OI_DEVMGR_CONNECTION_OVERLAP";
          break;
        case 1340:
          double result = "OI_DEVMGR_ORPHAN_SUBRATE_COMPLETE";
          break;
        case 1341:
          double result = "OI_DEVMGR_EIR_RESPONSE_2_LARGE";
          break;
        case 1342:
          double result = "OI_DEVMGR_GENTLY_CENTRAL_SKIP_CONN";
          break;
        case 1343:
          double result = "OI_DEVMGR_REQUEST_INVALID_TYPE";
          break;
        case 1344:
          double result = "OI_DEVMGR_REQUEST_CONN_DISCONNECTED";
          break;
        case 1345:
          double result = "OI_DEVMGR_REQUEST_FINISH_BONDING";
          break;
        case 1346:
          double result = "OI_DEVMGR_REQUEST_FINISH_NAME_REQ";
          break;
        case 1348:
          double result = "OI_DEVMGR_DISCONNECT_UNCONDITIONAL";
          break;
        case 1349:
          double result = "OI_DEVMGR_INVALID_HANDLE_LINK_INFO";
          break;
        case 1350:
          double result = "OI_DEVMGR_INVALID_HANDLE_COUNTER";
          break;
        case 1351:
          double result = "OI_DEVMGR_INVALID_HANDLE_LINK_QUAL";
          break;
        case 1352:
          double result = "OI_DEVMGR_INVALID_HANDLE_RSSI";
          break;
        case 1353:
          double result = "OI_DEVMGR_INVALID_HANDLE_AUTO_FLUSH";
          break;
        case 1354:
          double result = "OI_DEVMGR_INVALID_HANDLE_TX_POWER";
          break;
        case 1355:
          double result = "OI_DEVMGR_INVALID_HANDLE_MAX_POWER";
          break;
        case 1356:
          double result = "OI_DEVMGR_INVALID_HANDLE_LSTO";
          break;
        case 1358:
          double result = "OI_DEVMGR_STATUS_DEFAULT";
          break;
        case 1359:
          double result = "OI_DEVMGR_NAME_REQUEST_IS_INVALID";
          break;
        case 1360:
          double result = "OI_DEVMGR_SCO_NO_ESCO_SUPPORT";
          break;
        case 1361:
          double result = "OI_DEVMGR_INVALID_ACL_STATE";
          break;
        case 1362:
          double result = "OI_DEVMGR_REMOTENAMECANCEL_CB";
          break;
        case 1363:
          double result = "OI_DEVMGR_INVALID_HANDLE_LINK_POL";
          break;
        case 1401:
          double result = "OI_SECMGR_NO_POLICY";
          break;
        case 1402:
          double result = "OI_SECMGR_INTERNAL_ERROR";
          break;
        case 1403:
          double result = "OI_SECMGR_ORPHANED_CALLBACK";
          break;
        case 1404:
          double result = "OI_SECMGR_BUSY";
          break;
        case 1405:
          double result = "OI_SECMGR_DEVICE_NOT_TRUSTED";
          break;
        case 1407:
          double result = "OI_SECMGR_DEVICE_ENCRYPT_FAIL";
          break;
        case 1408:
          double result = "OI_SECMGR_DISCONNECTED_FAIL";
          break;
        case 1409:
          double result = "OI_SECMGR_ACCESS_PENDING";
          break;
        case 1410:
          double result = "OI_SECMGR_PIN_CODE_TOO_SHORT";
          break;
        case 1411:
          double result = "OI_SECMGR_UNKNOWN_ENCRYPT_VALUE";
          break;
        case 1412:
          double result = "OI_SECMGR_INVALID_POLICY";
          break;
        case 1413:
          double result = "OI_SECMGR_AUTHORIZATION_FAILED";
          break;
        case 1414:
          double result = "OI_SECMGR_ENCRYPTION_FAILED";
          break;
        case 1415:
          double result = "OI_SECMGR_UNIT_KEY_UNSUPPORTED";
          break;
        case 1416:
          double result = "OI_SECMGR_NOT_REGISTERED";
          break;
        case 1417:
          double result = "OI_SECMGR_ILLEGAL_WRITE_SSP_MODE";
          break;
        case 1418:
          double result = "OI_SECMGR_INVALID_SEC_LEVEL";
          break;
        case 1419:
          double result = "OI_SECMGR_INSUFFICIENT_LINK_KEY";
          break;
        case 1420:
          double result = "OI_SECMGR_INVALID_KEY_TYPE";
          break;
        case 1421:
          double result = "OI_SECMGR_SSP_NOT_ENCRYPTED";
          break;
        case 1422:
          double result = "OI_SECMGR_ORPHAN_EVENT";
          break;
        case 1423:
          double result = "OI_SECMGR_NOT_BONDABLE";
          break;
        case 1424:
          double result = "OI_SECMGR_INVALID_REMOTE_AUTH";
          break;
        default:
          return 0LL;
      }
    }

    else
    {
      switch(a1)
      {
        case 402:
          double result = "OI_STATUS_PSM_ALREADY_REGISTERED";
          break;
        case 403:
          double result = "OI_STATUS_INVALID_CID";
          break;
        case 404:
          double result = "OI_STATUS_CID_NOT_FOUND";
          break;
        case 405:
        case 409:
        case 413:
        case 415:
        case 416:
        case 417:
        case 419:
        case 420:
        case 421:
        case 422:
        case 424:
        case 432:
        case 438:
        case 442:
        case 443:
        case 446:
        case 447:
        case 448:
        case 449:
        case 455:
        case 456:
        case 457:
        case 458:
        case 459:
        case 465:
        case 466:
        case 467:
        case 468:
        case 469:
        case 473:
        case 474:
        case 475:
        case 476:
        case 477:
        case 478:
        case 479:
        case 480:
        case 481:
        case 487:
        case 488:
        case 489:
        case 491:
        case 492:
        case 493:
        case 494:
        case 495:
        case 496:
        case 497:
        case 498:
        case 499:
        case 504:
        case 505:
        case 506:
        case 507:
        case 512:
        case 513:
        case 514:
        case 515:
        case 516:
        case 517:
        case 518:
        case 519:
        case 520:
        case 521:
        case 522:
        case 523:
        case 524:
        case 525:
        case 526:
        case 527:
        case 528:
        case 529:
        case 557:
        case 561:
        case 562:
        case 563:
        case 564:
        case 565:
        case 566:
        case 567:
        case 568:
        case 569:
        case 570:
        case 571:
        case 572:
        case 573:
        case 574:
        case 575:
        case 576:
        case 577:
        case 578:
        case 579:
        case 581:
        case 583:
        case 592:
        case 593:
        case 594:
        case 595:
        case 596:
        case 597:
        case 598:
        case 599:
        case 600:
        case 602:
        case 604:
        case 606:
        case 609:
        case 610:
        case 617:
        case 618:
        case 636:
        case 655:
        case 656:
        case 657:
        case 658:
        case 659:
        case 660:
        case 661:
        case 662:
        case 663:
        case 664:
        case 665:
        case 666:
        case 667:
        case 668:
        case 669:
        case 670:
        case 671:
        case 672:
        case 673:
        case 674:
        case 675:
        case 676:
        case 677:
        case 678:
        case 679:
        case 680:
        case 681:
        case 682:
        case 683:
        case 684:
        case 685:
        case 686:
        case 687:
        case 688:
        case 689:
        case 690:
        case 691:
        case 692:
        case 693:
        case 694:
        case 695:
        case 696:
        case 697:
        case 698:
        case 699:
        case 700:
        case 764:
        case 765:
        case 767:
        case 768:
        case 770:
        case 771:
        case 772:
        case 773:
        case 774:
        case 775:
        case 776:
        case 777:
        case 778:
        case 779:
        case 780:
        case 781:
        case 782:
        case 783:
        case 784:
        case 785:
        case 786:
        case 787:
        case 788:
        case 789:
        case 790:
        case 791:
        case 792:
        case 793:
        case 794:
        case 795:
        case 796:
        case 797:
        case 798:
        case 799:
        case 801:
        case 809:
        case 814:
        case 818:
        case 820:
        case 822:
        case 828:
        case 848:
        case 849:
        case 850:
        case 851:
        case 852:
        case 853:
        case 854:
        case 855:
        case 856:
        case 857:
        case 858:
        case 859:
        case 860:
        case 861:
        case 862:
        case 863:
        case 864:
        case 865:
        case 866:
        case 867:
        case 868:
        case 869:
        case 870:
        case 871:
        case 872:
        case 873:
        case 874:
        case 875:
        case 876:
        case 877:
        case 878:
        case 879:
        case 880:
        case 881:
        case 882:
        case 883:
        case 884:
        case 885:
        case 886:
        case 887:
        case 888:
        case 889:
        case 890:
        case 891:
        case 892:
        case 893:
        case 894:
        case 895:
        case 896:
        case 897:
        case 898:
        case 899:
        case 900:
        case 902:
        case 914:
        case 919:
        case 936:
        case 937:
        case 938:
        case 939:
        case 940:
        case 941:
        case 942:
        case 943:
        case 944:
        case 945:
        case 946:
        case 947:
        case 948:
        case 949:
        case 950:
        case 951:
        case 952:
        case 953:
        case 954:
        case 955:
        case 956:
        case 957:
        case 958:
        case 959:
        case 960:
        case 961:
        case 962:
        case 963:
        case 964:
        case 965:
        case 966:
        case 967:
        case 968:
        case 969:
        case 970:
        case 971:
        case 972:
        case 973:
        case 974:
        case 975:
        case 976:
        case 977:
        case 978:
        case 979:
        case 980:
        case 981:
        case 982:
        case 983:
        case 984:
        case 985:
        case 986:
        case 987:
        case 988:
        case 989:
        case 990:
        case 991:
        case 992:
        case 993:
        case 994:
        case 995:
        case 996:
        case 997:
        case 998:
        case 999:
        case 1000:
        case 1003:
        case 1004:
        case 1005:
        case 1006:
        case 1007:
        case 1008:
        case 1009:
        case 1011:
        case 1012:
        case 1013:
        case 1014:
        case 1015:
        case 1016:
        case 1017:
        case 1018:
        case 1019:
        case 1020:
        case 1024:
        case 1025:
        case 1026:
        case 1027:
        case 1028:
        case 1029:
        case 1032:
        case 1033:
        case 1034:
        case 1035:
        case 1036:
        case 1037:
        case 1038:
        case 1039:
        case 1052:
        case 1053:
        case 1054:
        case 1055:
        case 1056:
        case 1057:
        case 1058:
        case 1059:
        case 1060:
        case 1061:
        case 1062:
        case 1063:
        case 1064:
        case 1068:
        case 1069:
        case 1070:
        case 1071:
        case 1072:
        case 1073:
        case 1074:
        case 1075:
        case 1076:
        case 1077:
        case 1078:
        case 1079:
        case 1080:
        case 1081:
        case 1082:
        case 1083:
        case 1084:
        case 1085:
        case 1086:
        case 1087:
        case 1088:
        case 1089:
        case 1090:
        case 1091:
        case 1092:
        case 1093:
        case 1094:
        case 1095:
        case 1096:
        case 1097:
        case 1098:
        case 1099:
        case 1100:
          return 0LL;
        case 406:
          double result = "OI_STATUS_CHANNEL_NOT_FOUND";
          break;
        case 407:
          double result = "OI_STATUS_PSM_NOT_FOUND";
          break;
        case 408:
          double result = "OI_STATUS_INVALID_STATE";
          break;
        case 410:
          double result = "OI_STATUS_WRITE_IN_PROGRESS";
          break;
        case 411:
          double result = "OI_STATUS_INVALID_PACKET";
          break;
        case 412:
          double result = "OI_STATUS_SEND_COMPLETE";
          break;
        case 414:
          double result = "OI_STATUS_INVALID_HANDLE";
          break;
        case 418:
          double result = "OI_STATUS_GROUP_FULL";
          break;
        case 423:
          double result = "OI_STATUS_DEVICE_ALREADY_IN_GROUP";
          break;
        case 425:
          double result = "OI_STATUS_DUPLICATE_GROUP";
          break;
        case 426:
          double result = "OI_STATUS_EMPTY_GROUP";
          break;
        case 427:
          double result = "OI_STATUS_PACKET_NOT_FOUND";
          break;
        case 428:
          double result = "OI_STATUS_BUFFER_TOO_SMALL";
          break;
        case 429:
          double result = "OI_STATUS_IDENTIFIER_NOT_FOUND";
          break;
        case 430:
          double result = "OI_L2CAP_DISCONNECT_LOWER_LAYER";
          break;
        case 431:
          double result = "OI_L2CAP_DISCONNECT_REMOTE_REQUEST";
          break;
        case 433:
          double result = "OI_L2CAP_GROUP_ADD_CONNECT_FAIL";
          break;
        case 434:
          double result = "OI_L2CAP_GROUP_REMOVE_FAILURE";
          break;
        case 435:
          double result = "OI_L2CAP_DATA_WRITE_ERROR_LINK_TERM";
          break;
        case 436:
          double result = "OI_L2CAP_DISCONNECT_LOCAL_REQUEST";
          break;
        case 437:
          double result = "OI_L2CAP_CONNECT_TIMEOUT";
          break;
        case 439:
          double result = "OI_L2CAP_DISCONNECT_TIMEOUT";
          break;
        case 440:
          double result = "OI_L2CAP_PING_TIMEOUT";
          break;
        case 441:
          double result = "OI_L2CAP_GET_INFO_TIMEOUT";
          break;
        case 444:
          double result = "OI_L2CAP_INVALID_ADDRESS";
          break;
        case 445:
          double result = "OI_L2CAP_CMD_REJECT_RCVD";
          break;
        case 450:
          double result = "OI_L2CAP_CONNECT_BASE";
          break;
        case 451:
          double result = "OI_L2CAP_CONNECT_PENDING";
          break;
        case 452:
          double result = "OI_L2CAP_CONNECT_REFUSED_INVALID_PSM";
          break;
        case 453:
          double result = "OI_L2CAP_CONNECT_REFUSED_SECURITY";
          break;
        case 454:
          double result = "OI_L2CAP_CONNECT_REFUSED_NO_RESOURCES";
          break;
        case 460:
          double result = "OI_L2CAP_CONFIG_BASE";
          break;
        case 461:
          double result = "OI_L2CAP_CONFIG_FAIL_INVALID_PARAMETERS";
          break;
        case 462:
          double result = "OI_L2CAP_CONFIG_FAIL_NO_REASON";
          break;
        case 463:
          double result = "OI_L2CAP_CONFIG_FAIL_UNKNOWN_OPTIONS";
          break;
        case 464:
          double result = "OI_L2CAP_CONFIG_FAIL_TIMEOUT";
          break;
        case 470:
          double result = "OI_L2CAP_GET_INFO_BASE";
          break;
        case 471:
          double result = "OI_L2CAP_GET_INFO_NOT_SUPPORTED";
          break;
        case 472:
          double result = "OI_L2CAP_MTU_EXCEEDED";
          break;
        case 482:
          double result = "OI_L2CAP_INVALID_PSM";
          break;
        case 483:
          double result = "OI_L2CAP_INVALID_MTU";
          break;
        case 484:
          double result = "OI_L2CAP_INVALID_FLUSHTO";
          break;
        case 485:
          double result = "OI_L2CAP_DEQUEUE_ERT_ERROR";
          break;
        case 486:
          double result = "OI_L2CAP_ZERO_LENGTH_RECV_PAYLOAD";
          break;
        case 490:
          double result = "OI_L2CAP_INVALID_FLOW_CONTROL";
          break;
        case 500:
          double result = "OI_L2CAP_QUEUE_LOCAL_NOT_READY";
          break;
        case 501:
          double result = "OI_L2CAP_QUEUE_REMOTE_NOT_READY";
          break;
        case 502:
          double result = "OI_L2CAP_QUEUE_FRAGMENTATION";
          break;
        case 503:
          double result = "OI_L2CAP_QUEUE_SFRAME_HEADER_ERROR";
          break;
        case 508:
          double result = "OI_L2CAP_QUEUE_ERTM_CID_ERROR";
          break;
        case 509:
          double result = "OI_L2CAP_QUEUE_SUPERVISION_ERROR";
          break;
        case 510:
          double result = "OI_L2CAP_QUEUE_RETRANS_ERROR";
          break;
        case 511:
          double result = "OI_L2CAP_QUEUE_THREAD_CREATION_FAILED";
          break;
        case 530:
          double result = "OI_L2CAP_ACCEPT_RESPOND_REJECT";
          break;
        case 531:
          double result = "OI_L2CAP_CONMAN_DEFAULT";
          break;
        case 532:
          double result = "OI_L2CAP_FIXCHAN_WRONG_TYPE";
          break;
        case 533:
          double result = "OI_L2CAP_FLOW_SENT_INVALID_CHANNEL";
          break;
        case 534:
          double result = "OI_L2CAP_FLOW_UNEXPECTED_STATE";
          break;
        case 535:
          double result = "OI_L2CAP_FLOW_INIT_INVALID_CHAN";
          break;
        case 536:
          double result = "OI_L2CAP_FLOW_RECV_INVALID_CHAN";
          break;
        case 537:
          double result = "OI_L2CAP_QOS_POKE_INVALID_CHAN";
          break;
        case 538:
          double result = "OI_L2CAP_ERTM_SENDSREJLIST_ERROR";
          break;
        case 539:
          double result = "OI_L2CAP_ERTM_SENDSREJTAIL_ERROR";
          break;
        case 540:
          double result = "OI_L2CAP_ERTM_RETRANS_IFRAME_ERROR";
          break;
        case 541:
          double result = "OI_L2CAP_ERTM_RETRANS_IFRAME_COUNT_EXCEEDED";
          break;
        case 542:
          double result = "OI_L2CAP_ERTM_RETRANS_REQ_IFRAME_ERROR";
          break;
        case 543:
          double result = "OI_L2CAP_ERTM_RX_IFRAME_IN_RX_UNEXPECTED_STATE";
          break;
        case 544:
          double result = "OI_L2CAP_ERTM_RX_IFRAME_IN_REJ_UNEXPECTED_STATE";
          break;
        case 545:
          double result = "OI_L2CAP_ERTM_RX_IFRAME_IN_SREJ_UNEXPECTED_STATE";
          break;
        case 546:
          double result = "OI_L2CAP_ERTM_RETRANS_BAD_LENGTH_RECVD_DATA";
          break;
        case 547:
          double result = "OI_L2CAP_ERTM_RETRANS_BAD_SFRAME_RECVD_DATA";
          break;
        case 548:
          double result = "OI_L2CAP_ERTM_RETRANS_BAD_IFRAME_RECVD_DATA";
          break;
        case 549:
          double result = "OI_L2CAP_ERTM_RETRANS_ALLOC_FAIL_RECVD_DATA";
          break;
        case 550:
          double result = "OI_L2CAP_ERTM_RECVDATA_UNEXPECTED_STATE";
          break;
        case 551:
          double result = "OI_L2CAP_ERTM_LOCAL_BUSY_UNEXPECTED_STATE";
          break;
        case 552:
          double result = "OI_L2CAP_ERTM_LOCAL_BUSY_CLEAR_UNEXPECTED_STATE";
          break;
        case 553:
          double result = "OI_L2CAP_ERTM_SEQ_N_FBIT_UNEXPECTED_STATE";
          break;
        case 554:
          double result = "OI_L2CAP_ERTM_FBIT_UNEXPECTED_STATE";
          break;
        case 555:
          double result = "OI_L2CAP_ERTM_UNEXPECTED_RETRX_TIMER";
          break;
        case 556:
          double result = "OI_L2CAP_ERTM_UNEXPECTED_MONITOR_TIMER";
          break;
        case 558:
          double result = "OI_L2CAP_ERTM_TIMEOUT";
          break;
        case 559:
          double result = "OI_L2CAP_SIGNALMAN_TIMEOUT";
          break;
        case 560:
          double result = "OI_L2CAP_DISC_DLCI0";
          break;
        case 580:
          double result = "OI_L2CAP_LE_BASE";
          break;
        case 582:
          double result = "OI_L2CAP_LE_LE_PSM_NOT_SUPPORTED";
          break;
        case 584:
          double result = "OI_L2CAP_LE_NO_RESOURCES";
          break;
        case 585:
          double result = "OI_L2CAP_LE_INSUFFICIENT_AUTHENTICATION";
          break;
        case 586:
          double result = "OI_L2CAP_LE_INSUFFICIENT_AUTHORIZATION";
          break;
        case 587:
          double result = "OI_L2CAP_LE_INSUFFICIENT_ENC_KEY_SIZE";
          break;
        case 588:
          double result = "OI_L2CAP_LE_INSUFFICIENT_ENCRYPTION";
          break;
        case 589:
          double result = "OI_L2CAP_LE_INVALID_SOURCE_CID";
          break;
        case 590:
          double result = "OI_L2CAP_LE_SOURCE_CID_ALREADY_REGISTERED";
          break;
        case 591:
          double result = "OI_L2CAP_LE_UNACCEPTABLE_PARAMS";
          break;
        case 601:
          double result = "OI_HCI_NO_SUCH_CONNECTION";
          break;
        case 603:
          double result = "OI_HCI_CB_LIST_FULL";
          break;
        case 605:
          double result = "OI_HCI_EVENT_UNDERRUN";
          break;
        case 607:
          double result = "OI_HCI_UNKNOWN_EVENT_CODE";
          break;
        case 608:
          double result = "OI_HCI_BAD_EVENT_PARM_LEN";
          break;
        case 611:
          double result = "OI_HCI_CMD_QUEUE_FULL";
          break;
        case 612:
          double result = "OI_HCI_SHORT_EVENT";
          break;
        case 613:
          double result = "OI_HCI_TRANSMIT_NOT_READY";
          break;
        case 614:
          double result = "OI_HCI_ORPHAN_SENT_EVENT";
          break;
        case 615:
          double result = "OI_HCI_CMD_TABLE_ERROR";
          break;
        case 616:
          double result = "OI_HCI_UNKNOWN_CMD_ID";
          break;
        case 619:
          double result = "OI_HCI_UNEXPECTED_EVENT";
          break;
        case 620:
          double result = "OI_HCI_EVENT_TABLE_ERROR";
          break;
        case 621:
          double result = "OI_HCI_EXPECTED_EVENT_TIMEOUT";
          break;
        case 622:
          double result = "OI_HCI_NO_CMD_DESC_FOR_OPCODE";
          break;
        case 623:
          double result = "OI_HCI_INVALID_OPCODE_ERROR";
          break;
        case 624:
          double result = "OI_HCI_FLOW_CONTROL_DISABLED";
          break;
        case 625:
          double result = "OI_HCI_TX_COMPLETE";
          break;
        case 626:
          double result = "OI_HCI_TX_ERROR";
          break;
        case 627:
          double result = "OI_HCI_DEVICE_NOT_INITIALIZED";
          break;
        case 628:
          double result = "OI_HCI_UNSUPPORTED_COMMAND";
          break;
        case 629:
          double result = "OI_HCI_PASSTHROUGH_ERROR";
          break;
        case 630:
          double result = "OI_HCI_PASSTHROUGH_ALREADY_SET";
          break;
        case 631:
          double result = "OI_HCI_RESET_FAILURE";
          break;
        case 632:
          double result = "OI_HCI_TRANSPORT_RESET";
          break;
        case 633:
          double result = "OI_HCIERR_HCIIFC_INIT_FAILURE";
          break;
        case 634:
          double result = "OI_HCI_EXPECTED_EVENT_CONN_RELEASED";
          break;
        case 635:
          double result = "OI_HCI_EXPECTED_EVENT_ORPHANED";
          break;
        case 637:
          double result = "OI_HCI_STATUS_DEFAULT";
          break;
        case 638:
          double result = "OI_HCI_FAIL_MISSING_PARAMS";
          break;
        case 639:
          double result = "OI_HCI_MISSING_LINKTYPE";
          break;
        case 640:
          double result = "OI_HCI_EXPECTED_EVENT_NOT_FOUND";
          break;
        case 641:
          double result = "OI_HCI_WRITE_COD_HW_WORKAROUND";
          break;
        case 642:
          double result = "OI_HCI_HW_ERROR_CHIP_RX_INVALID";
          break;
        case 643:
          double result = "OI_HCI_HW_ERROR_HOST_RX_INVALID";
          break;
        case 644:
          double result = "OI_HCI_HW_ERROR_TIMEDOUT_INVALID";
          break;
        case 645:
          double result = "OI_HCI_HW_ERROR_RX_INVALID_STATE";
          break;
        case 646:
          double result = "OI_HCI_HW_ERROR_TIMEDOUT_INVALID_STATE";
          break;
        case 647:
          double result = "OI_HCI_HW_ERROR_RX_INVALID_LENGTH";
          break;
        case 648:
          double result = "OI_HCI_HW_ERROR_CODE_UNKNOWN";
          break;
        case 649:
          double result = "OI_HCI_DUPLICATE_LM_HANDLE";
          break;
        case 650:
          double result = "OI_HCI_HW_ERROR_NOT_INITIALIZED";
          break;
        case 651:
          double result = "OI_HCI_EVENT_DATA_UNDERRUN";
          break;
        case 652:
          double result = "OI_HCI_HW_ERROR_SPMI_TIMEOUT";
          break;
        case 653:
          double result = "OI_HCI_HW_ERROR_DID_NOT_SLEEP";
          break;
        case 654:
          double result = "OI_HCI_HW_ERROR_CMD_DISALLOWED";
          break;
        case 701:
          double result = "OI_HCIERR_UNKNOWN_HCI_COMMAND";
          break;
        case 702:
          double result = "OI_HCIERR_UNKNOWN_CONNECTION_IDENTIFIER";
          break;
        case 703:
          double result = "OI_HCIERR_HARDWARE_FAILURE";
          break;
        case 704:
          double result = "OI_HCIERR_PAGE_TIMEOUT";
          break;
        case 705:
          double result = "OI_HCIERR_AUTHENTICATION_FAILURE";
          break;
        case 706:
          double result = "OI_HCIERR_KEY_MISSING";
          break;
        case 707:
          double result = "OI_HCIERR_MEMORY_CAPACITY_EXCEEDED";
          break;
        case 708:
          double result = "OI_HCIERR_CONNECTION_TIMEOUT";
          break;
        case 709:
          double result = "OI_HCIERR_MAX_NUM_OF_CONNECTIONS";
          break;
        case 710:
          double result = "OI_HCIERR_MAX_NUM_OF_SCO_CONNECTIONS";
          break;
        case 711:
          double result = "OI_HCIERR_ACL_CONNECTION_ALREADY_EXISTS";
          break;
        case 712:
          double result = "OI_HCIERR_COMMAND_DISALLOWED";
          break;
        case 713:
          double result = "OI_HCIERR_HOST_REJECTED_RESOURCES";
          break;
        case 714:
          double result = "OI_HCIERR_HOST_REJECTED_SECURITY";
          break;
        case 715:
          double result = "OI_HCIERR_HOST_REJECTED_PERSONAL_DEVICE";
          break;
        case 716:
          double result = "OI_HCIERR_HOST_TIMEOUT";
          break;
        case 717:
          double result = "OI_HCIERR_UNSUPPORTED";
          break;
        case 718:
          double result = "OI_HCIERR_INVALID_PARAMETERS";
          break;
        case 719:
          double result = "OI_HCIERR_OTHER_END_USER_DISCONNECT";
          break;
        case 720:
          double result = "OI_HCIERR_OTHER_END_LOW_RESOURCES";
          break;
        case 721:
          double result = "OI_HCIERR_OTHER_END_POWERING_OFF";
          break;
        case 722:
          double result = "OI_HCIERR_CONNECTION_TERMINATED_LOCALLY";
          break;
        case 723:
          double result = "OI_HCIERR_REPEATED_ATTEMPTS";
          break;
        case 724:
          double result = "OI_HCIERR_PAIRING_NOT_ALLOWED";
          break;
        case 725:
          double result = "OI_HCIERR_UNKNOWN_LMP_PDU";
          break;
        case 726:
          double result = "OI_HCIERR_UNSUPPORTED_REMOTE_FEATURE";
          break;
        case 727:
          double result = "OI_HCIERR_SCO_OFFSET_REJECTED";
          break;
        case 728:
          double result = "OI_HCIERR_SCO_INTERVAL_REJECTED";
          break;
        case 729:
          double result = "OI_HCIERR_SCO_AIR_MODE_REJECTED";
          break;
        case 730:
          double result = "OI_HCIERR_INVALID_LMP_PARMS";
          break;
        case 731:
          double result = "OI_HCIERR_UNSPECIFIED_ERROR";
          break;
        case 732:
          double result = "OI_HCIERR_UNSUPPORTED_LMP_PARAMETERS";
          break;
        case 733:
          double result = "OI_HCIERR_ROLE_CHANGE_NOT_ALLOWED";
          break;
        case 734:
          double result = "OI_HCIERR_LMP_RESPONSE_TIMEOUT";
          break;
        case 735:
          double result = "OI_HCIERR_LMP_ERROR_TRANS_COLLISION";
          break;
        case 736:
          double result = "OI_HCIERR_LMP_PDU_NOT_ALLOWED";
          break;
        case 737:
          double result = "OI_HCIERR_ENCRYPTION_MODE_NOT_ACCEPTABLE";
          break;
        case 738:
          double result = "OI_HCIERR_UNIT_KEY_USED";
          break;
        case 739:
          double result = "OI_HCIERR_QOS_NOT_SUPPORTED";
          break;
        case 740:
          double result = "OI_HCIERR_INSTANT_PASSED";
          break;
        case 741:
          double result = "OI_HCIERR_UNIT_KEY_PAIRING_UNSUPPORTED";
          break;
        case 742:
          double result = "OI_HCIERR_DIFFERENT_TRANS_COLLISION";
          break;
        case 743:
          double result = "OI_HCIERR_RESERVED_2B";
          break;
        case 744:
          double result = "OI_HCIERR_QOS_UNACCEPTABLE_PARAMETER";
          break;
        case 745:
          double result = "OI_HCIERR_QOS_REJECTED";
          break;
        case 746:
          double result = "OI_HCIERR_CHANNEL_CLASSIFICATION_NOT_SUPPORTED";
          break;
        case 747:
          double result = "OI_HCIERR_INSUFFICIENT_SECURITY";
          break;
        case 748:
          double result = "OI_HCIERR_PARAMETER_OUT_OF_MANDATORY_RANGE";
          break;
        case 749:
          double result = "OI_HCIERR_RESERVED_31";
          break;
        case 750:
          double result = "OI_HCIERR_ROLE_SWITCH_PENDING";
          break;
        case 751:
          double result = "OI_HCIERR_RESERVED_33";
          break;
        case 752:
          double result = "OI_HCIERR_RESERVED_SLOT_VIOLATION";
          break;
        case 753:
          double result = "OI_HCIERR_ROLE_SWITCH_FAILED";
          break;
        case 754:
          double result = "OI_HCIERR_EIR_TOO_LARGE";
          break;
        case 755:
          double result = "OI_HCIERR_SSP_NOT_SUPPORTED_BY_HOST";
          break;
        case 756:
          double result = "OI_HCIERR_HOST_BUSY_PAIRING";
          break;
        case 757:
          double result = "OI_HCIERR_CONNECTION_REJ_NO_SUITABLE_CHANNEL";
          break;
        case 758:
          double result = "OI_HCIERR_CONTROLLER_BUSY";
          break;
        case 759:
          double result = "OI_HCIERR_UNACCEPTABLE_CONNECTION_PARAMETERS";
          break;
        case 760:
          double result = "OI_HCIERR_ADVERTISING_TIMEOUT";
          break;
        case 761:
          double result = "OI_HCIERR_CONNECTION_TERMINATED_DUE_TO_MIC_FAILURE";
          break;
        case 762:
          double result = "OI_HCIERR_CONNECTION_FAILED_TO_BE_ESTABLISHED";
          break;
        case 763:
          double result = "OI_HCIERR_MAC_CONNECTION_FAILED";
          break;
        case 766:
          double result = "OI_HCIERR_UNKNOWN_ADVERTISING_IDENTIFIER";
          break;
        case 769:
          double result = "OI_HCIERR_UNKNOWN_ERROR";
          break;
        case 800:
          double result = "OI_SDP_SPEC_ERROR";
          break;
        case 802:
          double result = "OI_SDP_INVALID_SERVICE_RECORD_HANDLE";
          break;
        case 803:
          double result = "OI_SDP_INVALID_REQUEST_SYNTAX";
          break;
        case 804:
          double result = "OI_SDP_INVALID_PDU_SIZE";
          break;
        case 805:
          double result = "OI_SDP_INVALID_CONTINUATION_STATE";
          break;
        case 806:
          double result = "OI_SDP_INSUFFICIENT_RESOURCES";
          break;
        case 807:
          double result = "OI_SDP_ERROR";
          break;
        case 808:
          double result = "OI_SDP_CORRUPT_DATA_ELEMENT";
          break;
        case 810:
          double result = "OI_SDP_SERVER_NOT_CONNECTED";
          break;
        case 811:
          double result = "OI_SDP_ACCESS_DENIED";
          break;
        case 812:
          double result = "OI_SDP_ATTRIBUTES_OUT_OF_ORDER";
          break;
        case 813:
          double result = "OI_SDP_DEVICE_DOES_NOT_SUPPORT_SDP";
          break;
        case 815:
          double result = "OI_SDP_NO_MORE_DATA";
          break;
        case 816:
          double result = "OI_SDP_REQUEST_PARAMS_TOO_LONG";
          break;
        case 817:
          double result = "OI_SDP_REQUEST_PENDING";
          break;
        case 819:
          double result = "OI_SDP_SERVER_CONNECT_FAILED";
          break;
        case 821:
          double result = "OI_SDP_SERVER_TOO_MANY_CONNECTIONS";
          break;
        case 823:
          double result = "OI_SDP_NO_MATCHING_SERVICE_RECORD";
          break;
        case 824:
          double result = "OI_SDP_PARTIAL_RESPONSE";
          break;
        case 825:
          double result = "OI_SDP_ILLEGAL_ARGUMENT";
          break;
        case 826:
          double result = "OI_SDP_ATTRIBUTE_NOT_FOUND";
          break;
        case 827:
          double result = "OI_SDP_DATABASE_OUT_OF_RESOURCES";
          break;
        case 829:
          double result = "OI_SDP_SHORT_PDU";
          break;
        case 830:
          double result = "OI_SDP_TRANSACTION_ID_MISMATCH";
          break;
        case 831:
          double result = "OI_SDP_UNEXPECTED_RESPONSE_PDU_ID";
          break;
        case 832:
          double result = "OI_SDP_REQUEST_TIMEOUT";
          break;
        case 833:
          double result = "OI_SDP_INVALID_RESPONSE_SYNTAX";
          break;
        case 834:
          double result = "OI_SDP_CONNECTION_TIMEOUT";
          break;
        case 835:
          double result = "OI_SDP_RESPONSE_DATA_ERROR";
          break;
        case 836:
          double result = "OI_SDP_TOO_MANY_ATTRIBUTE_BYTES";
          break;
        case 837:
          double result = "OI_SDP_TOO_MANY_SERVICE_RECORDS";
          break;
        case 838:
          double result = "OI_SDP_INVALID_CONNECTION_ID";
          break;
        case 839:
          double result = "OI_SDP_CANNOT_SET_ATTRIBUTE";
          break;
        case 840:
          double result = "OI_SDP_BADLY_FORMED_ATTRIBUTE_VALUE";
          break;
        case 841:
          double result = "OI_SDP_NO_ATTRIBUTE_LIST_TO_REMOVE";
          break;
        case 842:
          double result = "OI_SDP_ATTRIBUTE_LIST_ALREADY_ADDED";
          break;
        case 843:
          double result = "OI_SDP_DATA_ELEMENT_TRUNCATED";
          break;
        case 844:
          double result = "OI_SDP_STATUS_DEFAULT";
          break;
        case 845:
          double result = "OI_SDP_ACCEPT_INCOMING_REQUEST";
          break;
        case 846:
          double result = "OI_SDP_REJECT_INCOMING_REQUEST";
          break;
        case 847:
          double result = "OI_SDP_STALL_INCOMING_REQUEST";
          break;
        case 901:
          double result = "OI_RFCOMM_WRITE_IN_PROGRESS";
          break;
        case 903:
          double result = "OI_RFCOMM_INVALID_BAUDRATE";
          break;
        case 904:
          double result = "OI_RFCOMM_INVALID_DATABIT";
          break;
        case 905:
          double result = "OI_RFCOMM_INVALID_STOPBIT";
          break;
        case 906:
          double result = "OI_RFCOMM_INVALID_PARITY";
          break;
        case 907:
          double result = "OI_RFCOMM_INVALID_PARITYTYPE";
          break;
        case 908:
          double result = "OI_RFCOMM_INVALID_FLOWCONTROL";
          break;
        case 909:
          double result = "OI_RFCOMM_SESSION_EXISTS";
          break;
        case 910:
          double result = "OI_RFCOMM_INVALID_CHANNEL";
          break;
        case 911:
          double result = "OI_RFCOMM_DLCI_EXISTS";
          break;
        case 912:
          double result = "OI_RFCOMM_LINK_NOT_FOUND";
          break;
        case 913:
          double result = "OI_RFCOMM_REMOTE_REJECT";
          break;
        case 915:
          double result = "OI_RFCOMM_TEST_IN_PROGRESS";
          break;
        case 916:
          double result = "OI_RFCOMM_SESSION_NOT_FOUND";
          break;
        case 917:
          double result = "OI_RFCOMM_INVALID_PACKET";
          break;
        case 918:
          double result = "OI_RFCOMM_FRAMESIZE_EXCEEDED";
          break;
        case 920:
          double result = "OI_RFCOMM_INVALID_DLCI";
          break;
        case 921:
          double result = "OI_RFCOMM_SERVER_NOT_REGISTERED";
          break;
        case 922:
          double result = "OI_RFCOMM_CREDIT_ERROR";
          break;
        case 923:
          double result = "OI_RFCOMM_NO_CHANNEL_NUMBER";
          break;
        case 924:
          double result = "OI_RFCOMM_QUERY_IN_PROGRESS";
          break;
        case 925:
          double result = "OI_RFCOMM_SESSION_SHUTDOWN";
          break;
        case 926:
          double result = "OI_RFCOMM_LOCAL_DEVICE_DISCONNECTED";
          break;
        case 927:
          double result = "OI_RFCOMM_REMOTE_DEVICE_DISCONNECTED";
          break;
        case 928:
          double result = "OI_RFCOMM_OUT_OF_SERVER_CHANNELS";
          break;
        case 929:
          double result = "OI_RFCOMM_SESSION_REQ_REJECTED";
          break;
        case 930:
          double result = "OI_RFCOMM_SESSION_SHUTDOWN_TIMER_EXPIRED";
          break;
        case 931:
          double result = "OI_RFCOMM_SESSION_SHUTDOWN_FRAME_TIMER_EXPIRED";
          break;
        case 932:
          double result = "OI_RFCOMM_SESSION_SHUTDOWN_SEND_CREDIT_FAILED";
          break;
        case 933:
          double result = "OI_RFCOMM_LINK_DISC_UA_SEND_FAILED";
          break;
        case 934:
          double result = "OI_RFCOMM_LINK_DISC_REMOTE_ERROR";
          break;
        case 935:
          double result = "OI_RFCOMM_LINK_DISC_FAILED";
          break;
        case 1001:
          double result = "OI_DISPATCH_INVALID_CB_HANDLE";
          break;
        case 1002:
          double result = "OI_DISPATCH_TABLE_OVERFLOW";
          break;
        case 1010:
          double result = "OI_DATAELEM_INVALID_TYPE_ERROR";
          break;
        case 1021:
          double result = "OI_SUPPORT_STRCAT_ERROR";
          break;
        case 1022:
          double result = "OI_SUPPORT_MUTEX_FAILED";
          break;
        case 1023:
          double result = "OI_SUPPORT_CMDCHAIN_INITIATE_ERROR";
          break;
        case 1030:
          double result = "OI_BYTESTREAM_INVALID_DATA_POINTER";
          break;
        case 1031:
          double result = "OI_BYTESTREAM_PARSE_ERROR";
          break;
        case 1040:
          double result = "OI_OS_INTF_ABS_TIME_FAIL";
          break;
        case 1041:
          double result = "OI_OS_INTF_AES128_CREATE_ERROR";
          break;
        case 1042:
          double result = "OI_OS_INTF_AES128_UPDATE_ERROR";
          break;
        case 1043:
          double result = "OI_OS_INTF_AES128_SIZE_ERROR";
          break;
        case 1044:
          double result = "OI_OS_INTF_SUBKEY_ERROR";
          break;
        case 1045:
          double result = "OI_OS_INTF_MAC_SUBKEY_ERROR";
          break;
        case 1046:
          double result = "OI_OS_INTF_MAC_BLOCKS_ERROR";
          break;
        case 1047:
          double result = "OI_OS_INTF_MAC_XOR_ERROR";
          break;
        case 1048:
          double result = "OI_OS_INTF_DHKEY_PUB_ERROR";
          break;
        case 1049:
          double result = "OI_OS_INTF_DHKEY_PRIV_ERROR";
          break;
        case 1050:
          double result = "OI_OS_INTF_DHKEY_COMPUTE_KEY_ERROR";
          break;
        case 1051:
          double result = "OI_OS_INTF_READ_LOCAL_PUBLIC_ERROR";
          break;
        case 1065:
          double result = "OI_PLTF_INIT_ERROR";
          break;
        case 1066:
          double result = "OI_PLTF_DEV_NAME_ERROR";
          break;
        case 1067:
          double result = "OI_PLTF_DEV_ADDR_ERROR";
          break;
        case 1101:
          double result = "OI_TEST_UNKNOWN_TEST";
          break;
        case 1102:
          double result = "OI_TEST_FAIL";
          break;
        default:
          switch(a1)
          {
            case 101:
              double result = "OI_STATUS_INVALID_PARAMETERS";
              break;
            case 102:
              double result = "OI_STATUS_NOT_IMPLEMENTED";
              break;
            case 103:
              double result = "OI_STATUS_NOT_INITIALIZED";
              break;
            case 104:
              double result = "OI_STATUS_NO_RESOURCES";
              break;
            case 105:
              double result = "OI_STATUS_INTERNAL_ERROR";
              break;
            case 106:
              double result = "OI_STATUS_OUT_OF_MEMORY";
              break;
            case 107:
              double result = "OI_ILLEGAL_REENTRANT_CALL";
              break;
            case 108:
              double result = "OI_STATUS_INITIALIZATION_FAILED";
              break;
            case 109:
              double result = "OI_STATUS_INITIALIZATION_PENDING";
              break;
            case 110:
              double result = "OI_STATUS_NO_SCO_SUPPORT";
              break;
            case 111:
              double result = "OI_STATUS_OUT_OF_STATIC_MEMORY";
              break;
            case 112:
              double result = "OI_TIMEOUT";
              break;
            case 113:
              double result = "OI_OS_ERROR";
              break;
            case 114:
              double result = "OI_FAIL";
              break;
            case 115:
              double result = "OI_STRING_FORMAT_ERROR";
              break;
            case 116:
              double result = "OI_STATUS_PENDING";
              break;
            case 117:
              double result = "OI_STATUS_INVALID_COMMAND";
              break;
            case 118:
              double result = "OI_BUSY_FAIL";
              break;
            case 119:
              double result = "OI_STATUS_ALREADY_REGISTERED";
              break;
            case 120:
              double result = "OI_STATUS_NOT_FOUND";
              break;
            case 121:
              double result = "OI_STATUS_NOT_REGISTERED";
              break;
            case 122:
              double result = "OI_STATUS_NOT_CONNECTED";
              break;
            case 123:
              double result = "OI_CALLBACK_FUNCTION_REQUIRED";
              break;
            case 124:
              double result = "OI_STATUS_MBUF_OVERFLOW";
              break;
            case 125:
              double result = "OI_STATUS_MBUF_UNDERFLOW";
              break;
            case 126:
              double result = "OI_STATUS_CONNECTION_EXISTS";
              break;
            case 127:
              double result = "OI_STATUS_NOT_CONFIGURED";
              break;
            case 128:
              double result = "OI_LOWER_STACK_ERROR";
              break;
            case 129:
              double result = "OI_STATUS_RESET_IN_PROGRESS";
              break;
            case 130:
              double result = "OI_STATUS_ACCESS_DENIED";
              break;
            case 131:
              double result = "OI_STATUS_DATA_ERROR";
              break;
            case 132:
              double result = "OI_STATUS_INVALID_ROLE";
              break;
            case 133:
              double result = "OI_STATUS_ALREADY_CONNECTED";
              break;
            case 134:
              double result = "OI_STATUS_PARSE_ERROR";
              break;
            case 135:
              double result = "OI_STATUS_END_OF_FILE";
              break;
            case 136:
              double result = "OI_STATUS_READ_ERROR";
              break;
            case 137:
              double result = "OI_STATUS_WRITE_ERROR";
              break;
            case 138:
              double result = "OI_STATUS_NEGOTIATION_FAILURE";
              break;
            case 139:
              double result = "OI_STATUS_READ_IN_PROGRESS";
              break;
            case 140:
              double result = "OI_STATUS_ALREADY_INITIALIZED";
              break;
            case 141:
              double result = "OI_STATUS_STILL_CONNECTED";
              break;
            case 142:
              double result = "OI_STATUS_MTU_EXCEEDED";
              break;
            case 143:
              double result = "OI_STATUS_LINK_TERMINATED";
              break;
            case 144:
              double result = "OI_STATUS_PIN_CODE_TOO_LONG";
              break;
            case 145:
              double result = "OI_STATUS_STILL_REGISTERED";
              break;
            case 146:
              double result = "OI_STATUS_SPEC_VIOLATION";
              break;
            case 147:
              double result = "OI_STATUS_LE_NOT_SUPPORTED";
              break;
            case 148:
              double result = "OI_STATUS_MUTEX_DESTROY_FAILED";
              break;
            case 149:
              double result = "OI_STATUS_INVALID_LE_CONNECTION";
              break;
            case 150:
              double result = "OI_STACKWRAPPER_TIMEOUT";
              break;
            case 151:
              double result = "OI_CONDITIONAL_TIMEOUT";
              break;
            case 152:
              double result = "OI_STATUS_UNSUPPORTED";
              break;
            case 153:
              double result = "OI_STATUS_WATCH_TS_REMOTE_UNSUPPORTED";
              break;
            case 154:
              double result = "OI_STATUS_CCECB_FAIL";
              break;
            case 155:
              double result = "OI_STATUS_INVALID_LE_PERIODIC_SYNC";
              break;
            case 156:
              return 0LL;
            case 157:
              double result = "OI_STATUS_LE_DUPLICATE_CONNECTIONS";
              break;
            case 158:
              double result = "OI_STATUS_DUPLICATE_BD_ADDR";
              break;
            case 159:
              double result = "OI_STATUS_FAST_LE_CONNECTION_FAILED";
              break;
            case 160:
              double result = "OI_STATUS_OUTGOING_CONNECTION_DENIED";
              break;
            case 161:
              double result = "OI_STATUS_INCOMPLETE_DATA";
              break;
            case 162:
              double result = "OI_STATUS_INVALID_LENGTH";
              break;
            default:
              if (a1) {
                return 0LL;
              }
              double result = "OI_OK";
              break;
          }

          break;
      }
    }

    return result;
  }

  if (a1 <= 3569)
  {
    if (a1 > 2100)
    {
      if (a1 > 3100)
      {
        if (a1 > 3389)
        {
          switch(a1)
          {
            case 3450:
              double result = "BT_MAP_CONNECT_MNS_MAX_CONN";
              break;
            case 3451:
              double result = "BT_MAP_SERVER_CONN_IND_MAX_CLIENT";
              break;
            case 3452:
              double result = "BT_MAP_SERVER_GET_IND_MAX_CLIENT";
              break;
            case 3453:
              double result = "BT_MAP_SERVER_PUT_IND_MAX_CLIENT";
              break;
            case 3454:
              double result = "BT_MAP_SERVER_DISC_MAX_CLIENT";
              break;
            case 3455:
              double result = "BT_MAP_SERVER_ACCEPT_MAX_CLIENT";
              break;
            case 3456:
              double result = "BT_MAP_SEND_MAX_CLIENT";
              break;
            case 3457:
              double result = "BT_MAP_GETRESPONSE_MAX_CLIENT";
              break;
            case 3458:
              double result = "BT_MAP_SEND_MSG_RESPONSE_ERROR";
              break;
            case 3459:
              double result = "BT_MAP_SEND_MSG_MAX_CLIENT";
              break;
            case 3460:
              double result = "BT_MAP_GET_FOLDER_MAX_CLIENT";
              break;
            case 3461:
            case 3462:
            case 3463:
            case 3464:
            case 3465:
            case 3466:
            case 3467:
            case 3468:
            case 3469:
              return 0LL;
            case 3470:
              double result = "BT_NETWORK_STATUS_DEFAULT";
              break;
            case 3471:
              double result = "BT_NETWORK_IF_CREATE_ERROR";
              break;
            case 3472:
              double result = "BT_NETWORK_ADD_HOST_ERROR";
              break;
            case 3473:
              double result = "BT_NETWORK_MAX_CONN_ERROR";
              break;
            case 3474:
              double result = "BT_NETWORK_IF_WRITE_ERROR";
              break;
            default:
              switch(a1)
              {
                case 3390:
                  double result = "OI_BIPSRV_REJECT";
                  break;
                case 3391:
                case 3392:
                case 3393:
                case 3394:
                case 3395:
                case 3396:
                case 3397:
                case 3398:
                case 3399:
                  return 0LL;
                case 3400:
                  double result = "OI_PAN_CONSUMER_IF_WRITE_ERROR";
                  break;
                case 3401:
                  double result = "OI_PAN_STATUS_DEFAULT";
                  break;
                case 3402:
                  double result = "OI_PAN_INVALID_NET_IFC";
                  break;
                case 3403:
                  double result = "OI_PAN_USER_IFCREATE_ERROR";
                  break;
                case 3404:
                  double result = "OI_PAN_USER_IFWRITE_ERROR";
                  break;
                default:
                  switch(a1)
                  {
                    case 3550:
                      double result = "BT_MAGIC_PAIRING_IN_PROGRESS";
                      break;
                    case 3551:
                      double result = "BT_MAGIC_PAIRING_NO_TABLE_FOUND";
                      break;
                    case 3552:
                      double result = "BT_MAGIC_PAIRING_NO_HINT";
                      break;
                    case 3553:
                      double result = "BT_MAGIC_PAIRING_NOT_INPROGRESS";
                      break;
                    default:
                      return 0LL;
                  }

                  break;
              }

              break;
          }
        }

        else
        {
          if (a1 <= 3200)
          {
            switch(a1)
            {
              case 3101:
                return "OI_AADP_BAD_ENDPOINT";
              case 3102:
                return "OI_AADP_BAD_STATE";
              case 3200:
                return "OI_UNICODE_INVALID_SOURCE";
            }

            return 0LL;
          }

          switch(a1)
          {
            case 3300:
              double result = "OI_AVRCP_TOO_MANY_CONNECTIONS";
              break;
            case 3301:
              double result = "OI_AVRCP_NOT_IMPLEMENTED";
              break;
            case 3302:
              double result = "OI_AVRCP_REJECTED";
              break;
            case 3303:
              double result = "OI_AVRCP_INVALID_RESPONSE";
              break;
            case 3304:
              double result = "OI_AVRCP_RESPONSE_PACKET_OVERFLOW";
              break;
            case 3305:
              double result = "OI_AVRCP_RESPONSE_INVALID_PDU";
              break;
            case 3306:
              double result = "OI_AVRCP_RESPONSE_INVALID_PARAMETER";
              break;
            case 3307:
              double result = "OI_AVRCP_RESPONSE_PARAMETER_NOT_FOUND";
              break;
            case 3308:
              double result = "OI_AVRCP_RESPONSE_INTERNAL_ERROR";
              break;
            case 3309:
              double result = "OI_AVRCP_NO_REGISTERED_HANDLER_ERROR";
              break;
            case 3310:
              double result = "OI_AVRCP_RECVIND_INVALID_PID_ERROR";
              break;
            case 3311:
              double result = "OI_AVRCP_B_RECVIND_INVALID_PID_ERROR";
              break;
            case 3312:
              double result = "OI_AVRCP_TIMEOUT";
              break;
            default:
              if (a1 == 3201)
              {
                double result = "OI_UNICODE_SOURCE_EXHAUSTED";
              }

              else
              {
                if (a1 != 3202) {
                  return 0LL;
                }
                double result = "OI_UNICODE_DESTINATION_EXHAUSTED";
              }

              break;
          }
        }
      }

      else if (a1 > 2600)
      {
        if (a1 > 2800)
        {
          if (a1 > 2902)
          {
            switch(a1)
            {
              case 3001:
                double result = "OI_PBAP_REPOSITORY_NOT_SET";
                break;
              case 3002:
                double result = "OI_PBAP_PHONEBOOK_NOT_SET";
                break;
              case 3003:
                double result = "OI_PBAP_SET_PATH_DONE_ERROR";
                break;
              case 3004:
                double result = "OI_PBAP_SERVER_SIZE_ERROR";
                break;
              case 3005:
                double result = "OI_PBAP_CLIENT_ADDR_ERROR";
                break;
              default:
                if (a1 != 2903) {
                  return 0LL;
                }
                double result = "OI_AVDTP_INVALID_STREAM_HANDLE";
                break;
            }
          }

          else
          {
            switch(a1)
            {
              case 2801:
                double result = "OI_BLST_CHARACTER_TIMEOUT";
                break;
              case 2802:
                double result = "OI_BLST_ACKNOWLDGE_TIMEOUT";
                break;
              case 2803:
                double result = "OI_BLST_TX_NOT_READY";
                break;
              case 2804:
                double result = "OI_BLST_TX_BUSY";
                break;
              default:
                if (a1 == 2901)
                {
                  double result = "OI_AVDTP_CONNECTION_SEQ_ERROR";
                }

                else
                {
                  if (a1 != 2902) {
                    return 0LL;
                  }
                  double result = "OI_AVDTP_OUT_OF_RESOURCES";
                }

                break;
            }
          }
        }

        else
        {
          switch(a1)
          {
            case 2701:
              double result = "OI_AT_ERROR";
              break;
            case 2702:
              double result = "OI_AT_NO_CARRIER";
              break;
            case 2703:
              double result = "OI_AT_BUSY";
              break;
            case 2704:
              double result = "OI_AT_NO_ANSWER";
              break;
            case 2705:
              double result = "OI_AT_DELAYED";
              break;
            case 2706:
              double result = "OI_AT_BLACKLISTED";
              break;
            case 2707:
              double result = "OI_AT_CME_ERROR";
              break;
            case 2708:
              double result = "OI_AT_CMS_ERROR";
              break;
            default:
              switch(a1)
              {
                case 2601:
                  double result = "OI_HID_HOST_SERVICE_NOT_STARTED";
                  break;
                case 2602:
                  double result = "OI_HID_DEVICE_SERVICE_NOT_STARTED";
                  break;
                case 2603:
                  double result = "OI_HID_CONTROL_DISC_IND";
                  break;
                case 2604:
                  double result = "OI_HID_TIMEOUT";
                  break;
                default:
                  return 0LL;
              }

              break;
          }
        }
      }

      else if (a1 > 2300)
      {
        switch(a1)
        {
          case 2301:
            double result = "OI_CODEC_SBC_NO_SYNCWORD";
            break;
          case 2302:
            double result = "OI_CODEC_SBC_NOT_ENOUGH_HEADER_DATA";
            break;
          case 2303:
            double result = "OI_CODEC_SBC_NOT_ENOUGH_BODY_DATA";
            break;
          case 2304:
            double result = "OI_CODEC_SBC_NOT_ENOUGH_AUDIO_DATA";
            break;
          case 2305:
            double result = "OI_CODEC_SBC_CHECKSUM_MISMATCH";
            break;
          case 2306:
            double result = "OI_CODEC_SBC_PARTIAL_DECODE";
            break;
          default:
            switch(a1)
            {
              case 2401:
                double result = "OI_FIFOQ_QUEUE_NOT_ALIGNED";
                break;
              case 2402:
                double result = "OI_FIFOQ_INVALID_Q";
                break;
              case 2403:
                double result = "OI_FIFOQ_BUF_TOO_LARGE";
                break;
              case 2404:
                double result = "OI_FIFOQ_FULL";
                break;
              case 2405:
                double result = "OI_FIFOQ_NOT_ALLOCATED";
                break;
              case 2406:
                double result = "OI_FIFOQ_INVALID_DATA_PTR";
                break;
              default:
                return 0LL;
            }

            break;
        }
      }

      else
      {
        switch(a1)
        {
          case 2201:
            double result = "OI_PAN_ROLE_ALREADY_REGISTERED";
            break;
          case 2202:
            double result = "OI_PAN_ROLE_NOT_ALLOWED";
            break;
          case 2203:
            double result = "OI_PAN_INCOMPATIBLE_ROLES";
            break;
          case 2204:
            double result = "OI_PAN_INVALID_ROLE";
            break;
          case 2205:
            double result = "OI_PAN_CONNECTION_IN_PROGRESS";
            break;
          case 2206:
            double result = "OI_PAN_USER_ALREADY_CONNECTED";
            break;
          case 2207:
            double result = "OI_PAN_DEVICE_CONNECTED";
            break;
          default:
            switch(a1)
            {
              case 2101:
                double result = "OI_NETIFC_UP_FAILED";
                break;
              case 2102:
                double result = "OI_NETIFC_COULD_NOT_CREATE_THREAD";
                break;
              case 2103:
                double result = "OI_NETIFC_INITIALIZATION_FAILED";
                break;
              case 2104:
                double result = "OI_NETIFC_INTERFACE_ALREADY_UP";
                break;
              case 2105:
                double result = "OI_NETIFC_INTERFACE_NOT_UP";
                break;
              case 2106:
                double result = "OI_NETIFC_PACKET_TOO_BIG";
                break;
              default:
                return 0LL;
            }

            break;
        }
      }
    }

    else if (a1 > 1900)
    {
      if (a1 <= 2000)
      {
        switch(a1)
        {
          case 1901:
            return "OI_HEADSET_SERVICE_NOT_STARTED";
          case 1902:
            return "OI_HEADSET_AG_SERVICE_NOT_STARTED";
          case 1903:
            return "OI_HEADSET_COMMAND_IN_PROGRESS";
        }

        return 0LL;
      }

      switch(a1)
      {
        case 2001:
          double result = "OI_BNEP_INVALID_MTU";
          break;
        case 2002:
          double result = "OI_BNEP_SETUP_TIMEOUT";
          break;
        case 2003:
          double result = "OI_BNEP_SERVICE_NOT_REGISTERED";
          break;
        case 2004:
          double result = "OI_BNEP_INVALID_HANDLE";
          break;
        case 2005:
          double result = "OI_BNEP_RESPONSE_TIMEOUT";
          break;
        case 2006:
          double result = "OI_BNEP_INVALID_CONNECTION";
          break;
        case 2007:
          double result = "OI_BNEP_INVALID_FILTER";
          break;
        case 2008:
          double result = "OI_BNEP_CONNECTION_EXISTS";
          break;
        case 2009:
          double result = "OI_BNEP_NOT_INITIALIZED";
          break;
        case 2010:
          double result = "OI_BNEP_CONNECT_BASE";
          break;
        case 2011:
          double result = "OI_BNEP_CONNECT_FAILED_INVALID_DEST_UUID";
          break;
        case 2012:
          double result = "OI_BNEP_CONNECT_FAILED_INVALID_SOURCE_UUID";
          break;
        case 2013:
          double result = "OI_BNEP_CONNECT_FAILED_INVALID_UUID_SIZE";
          break;
        case 2014:
          double result = "OI_BNEP_CONNECT_FAILED_NOT_ALLOWED";
          break;
        case 2020:
          double result = "OI_BNEP_FILTER_NET_BASE";
          break;
        case 2021:
          double result = "OI_BNEP_FILTER_NET_UNSUPPORTED_REQUEST";
          break;
        case 2022:
          double result = "OI_BNEP_FILTER_NET_FAILED_INVALID_PROTOCOL_TYPE";
          break;
        case 2023:
          double result = "OI_BNEP_FILTER_NET_FAILED_MAX_LIMIT_REACHED";
          break;
        case 2024:
          double result = "OI_BNEP_FILTER_NET_FAILED_SECURITY";
          break;
        case 2030:
          double result = "OI_BNEP_FILTER_MULTI_BASE";
          break;
        case 2031:
          double result = "OI_BNEP_FILTER_MULTI_UNSUPPORTED_REQUEST";
          break;
        case 2032:
          double result = "OI_BNEP_FILTER_MULTI_FAILED_INVALID_ADDRESS";
          break;
        case 2033:
          double result = "OI_BNEP_FILTER_MULTI_FAILED_MAX_LIMIT_REACHED";
          break;
        case 2034:
          double result = "OI_BNEP_FILTER_MULTI_FAILED_SECURITY";
          break;
        case 2040:
          double result = "OI_BNEP_LOCAL_DEVICE_MUST_BE_CENTRAL";
          break;
        case 2041:
          double result = "OI_BNEP_PACKET_FILTERED_OUT";
          break;
        case 2042:
          double result = "OI_BNEP_NO_PACKET_FOUND";
          break;
        case 2043:
          double result = "OI_BNEP_TIMEOUT";
          break;
        default:
          return 0LL;
      }
    }

    else if (a1 <= 1700)
    {
      switch(a1)
      {
        case 1602:
          double result = "OI_TCS_INVALID_ELEMENT_TYPE";
          break;
        case 1603:
          double result = "OI_TCS_INVALID_PACKET";
          break;
        case 1604:
          double result = "OI_TCS_CALL_IN_PROGRESS";
          break;
        case 1605:
          double result = "OI_TCS_NO_CALL_IN_PROGRESS";
          break;
        default:
          if (a1 == 1500)
          {
            double result = "OI_DEVMGR_POLICY_ACL_DISCONNECTED";
          }

          else
          {
            if (a1 != 1501) {
              return 0LL;
            }
            double result = "OI_DEVMGR_POLICY_ENFORCEMENT_TIMEOUT";
          }

          break;
      }
    }

    else
    {
      switch(a1)
      {
        case 1701:
          double result = "OI_OBEX_CONTINUE";
          break;
        case 1702:
          double result = "OI_OBEX_COMMAND_ERROR";
          break;
        case 1703:
          double result = "OI_OBEX_CONNECTION_TIMEOUT";
          break;
        case 1704:
          double result = "OI_OBEX_CONNECT_FAILED";
          break;
        case 1705:
          double result = "OI_OBEX_DISCONNECT_FAILED";
          break;
        case 1706:
          double result = "OI_OBEX_ERROR";
          break;
        case 1707:
          double result = "OI_OBEX_INCOMPLETE_PACKET";
          break;
        case 1708:
          double result = "OI_OBEX_LENGTH_REQUIRED";
          break;
        case 1709:
          double result = "OI_OBEX_NOT_CONNECTED";
          break;
        case 1710:
          double result = "OI_OBEX_NO_MORE_CONNECTIONS";
          break;
        case 1711:
          double result = "OI_OBEX_OPERATION_IN_PROGRESS";
          break;
        case 1712:
          double result = "OI_OBEX_PUT_RESPONSE_ERROR";
          break;
        case 1713:
          double result = "OI_OBEX_GET_RESPONSE_ERROR";
          break;
        case 1714:
          double result = "OI_OBEX_REQUIRED_HEADER_NOT_FOUND";
          break;
        case 1715:
          double result = "OI_OBEX_SERVICE_UNAVAILABLE";
          break;
        case 1716:
          double result = "OI_OBEX_TOO_MANY_HEADER_BYTES";
          break;
        case 1717:
          double result = "OI_OBEX_UNKNOWN_COMMAND";
          break;
        case 1718:
          double result = "OI_OBEX_UNSUPPORTED_VERSION";
          break;
        case 1719:
          double result = "OI_OBEX_CLIENT_ABORTED_COMMAND";
          break;
        case 1720:
          double result = "OI_OBEX_BAD_PACKET";
          break;
        case 1721:
          double result = "OI_OBEX_BAD_REQUEST";
          break;
        case 1723:
          double result = "OI_OBEX_OBJECT_OVERFLOW";
          break;
        case 1724:
          double result = "OI_OBEX_NOT_FOUND";
          break;
        case 1735:
          double result = "OI_OBEX_ACCESS_DENIED";
          break;
        case 1736:
          double result = "OI_OBEX_VALUE_NOT_ACCEPTABLE";
          break;
        case 1737:
          double result = "OI_OBEX_PACKET_OVERFLOW";
          break;
        case 1738:
          double result = "OI_OBEX_NO_SUCH_FOLDER";
          break;
        case 1739:
          double result = "OI_OBEX_NAME_REQUIRED";
          break;
        case 1740:
          double result = "OI_OBEX_PASSWORD_TOO_LONG";
          break;
        case 1741:
          double result = "OI_OBEX_PRECONDITION_FAILED";
          break;
        case 1742:
          double result = "OI_OBEX_UNAUTHORIZED";
          break;
        case 1743:
          double result = "OI_OBEX_NOT_IMPLEMENTED";
          break;
        case 1744:
          double result = "OI_OBEX_INVALID_AUTH_DIGEST";
          break;
        case 1745:
          double result = "OI_OBEX_INVALID_OPERATION";
          break;
        case 1746:
          double result = "OI_OBEX_DATABASE_FULL";
          break;
        case 1747:
          double result = "OI_OBEX_DATABASE_LOCKED";
          break;
        case 1748:
          double result = "OI_OBEX_INTERNAL_SERVER_ERROR";
          break;
        case 1749:
          double result = "OI_OBEX_UNSUPPORTED_MEDIA_TYPE";
          break;
        case 1750:
          double result = "OI_OBEX_PARTIAL_CONTENT";
          break;
        case 1751:
          double result = "OI_OBEX_METHOD_NOT_ALLOWED";
          break;
        case 1752:
          double result = "OI_OBEXSRV_INCOMPLETE_GET";
          break;
        case 1753:
          double result = "OI_OBEX_FOLDER_BROWSING_NOT_ALLOWED";
          break;
        case 1754:
          double result = "OI_OBEX_SERVER_FORCED_DISCONNECT";
          break;
        case 1755:
          double result = "OI_OBEX_OFS_ERROR";
          break;
        case 1756:
          double result = "OI_OBEX_FILEOP_ERROR";
          break;
        case 1757:
          double result = "OI_OBEX_USERID_TOO_LONG";
          break;
        case 1758:
          double result = "OI_OBEX_APPEND_PARSER_ERROR";
          break;
        case 1759:
          double result = "OI_OBEXSRV_REJECT";
          break;
        case 1801:
          double result = "OI_HANDSFREE_EVENT_REPORTING_DISABLED";
          break;
        case 1802:
          double result = "OI_HANDSFREE_NOT_CONNECTED";
          break;
        case 1803:
          double result = "OI_HANDSFREE_SERVICE_NOT_STARTED";
          break;
        case 1804:
          double result = "OI_HANDSFREE_AG_SERVICE_NOT_STARTED";
          break;
        case 1805:
          double result = "OI_HANDSFREE_COMMAND_IN_PROGRESS";
          break;
        case 1806:
          double result = "OI_HANDSFREE_AUDIO_ALREADY_CONNECTED";
          break;
        case 1807:
          double result = "OI_HANDSFREE_AUDIO_NOT_CONNECTED";
          break;
        case 1808:
          double result = "OI_HANDSFREE_FEATURE_NOT_SUPPORTED";
          break;
        case 1809:
          double result = "OI_HANDSFREE_CODEC_SELECTION_TIMEOUT";
          break;
        case 1810:
          double result = "OI_HANDSFREE_CODEC_SELECTION_FAILED";
          break;
        case 1811:
          double result = "OI_HANDSFREE_PARAMS_EXCEEDED";
          break;
        case 1812:
          double result = "OI_HANDSFREE_CODEC_NOT_SUPPORTED";
          break;
        case 1813:
          double result = "OI_HANDSFREE_INVALID_CODEC";
          break;
        case 1814:
          double result = "OI_HANDSFREE_AG_TIMEOUT";
          break;
        case 1815:
          double result = "OI_HANDSFREE_DISC_MAX_HFP_DEVICES";
          break;
        case 1816:
          double result = "OI_HANDSFREE_LOCAL_DISC_CTRL_MISMATCH";
          break;
        case 1817:
          double result = "OI_HANDSFREE_LOCAL_DISC_SCO_REG_FAIL";
          break;
        case 1818:
          double result = "OI_LOCAL_DEVICE_DISC";
          break;
        default:
          return 0LL;
      }
    }
  }

  else
  {
    if (a1 > 4299)
    {
      if (a1 <= 4999)
      {
        switch(a1)
        {
          case 4800:
            double result = "OI_SMP_ERROR_FAIL";
            break;
          case 4801:
            double result = "OI_SMP_ERROR_ALREADY_ENCRYPTED";
            break;
          case 4802:
            double result = "OI_SMP_ERROR_NOT_ENCRYPTED";
            break;
          case 4803:
            double result = "OI_SMP_ERROR_NO_KEY";
            break;
          case 4804:
            double result = "OI_SMP_ERROR_IN_PROGRESS";
            break;
          case 4805:
            double result = "OI_SMP_ERROR_CONFIRM_VALUE_FAILED";
            break;
          case 4806:
            double result = "OI_SMP_ERROR_NOT_IN_PAIRING_MODE";
            break;
          case 4807:
            double result = "OI_SMP_ERROR_TIMEOUT";
            break;
          case 4808:
            double result = "OI_SMP_ERROR_ALREADY_PAIRED";
            break;
          case 4809:
            double result = "OI_SMP_ERROR_PASSKEY_ENTRY_FAILED";
            break;
          case 4810:
            double result = "OI_SMP_ERROR_OOB_NOT_AVAILABLE";
            break;
          case 4811:
            double result = "OI_SMP_ERROR_AUTH_REQUIREMENT";
            break;
          case 4812:
            double result = "OI_SMP_ERROR_PAIRING_NOT_SUPPORTED";
            break;
          case 4813:
            double result = "OI_SMP_ERROR_ENCYPRTION_KEY_SIZE";
            break;
          case 4814:
            double result = "OI_SMP_ERROR_COMMAND_NOT_SUPPORTED";
            break;
          case 4815:
            double result = "OI_SMP_ERROR_UNSPECIFIED_REASON";
            break;
          case 4816:
            double result = "OI_SMP_ERROR_REPEATED_ATTEMPS";
            break;
          case 4817:
            double result = "OI_SMP_ERROR_INVALID_PARAMETERS";
            break;
          case 4818:
            double result = "OI_SMP_ERROR_DHKEY_CHECK_FAILED";
            break;
          case 4819:
            double result = "OI_SMP_ERROR_NUM_COMPARISON_FAILED";
            break;
          case 4820:
            double result = "OI_SMP_ERROR_INVALID_HANDLE";
            break;
          case 4821:
            double result = "OI_SMP_ERROR_NOT_CENTRAL";
            break;
          case 4822:
            double result = "OI_SMP_ERROR_NOT_PERIPHERAL";
            break;
          case 4823:
            double result = "OI_SMP_ERROR_INVALID_PAIR_STATE";
            break;
          case 4824:
            double result = "OI_SMP_ERROR_NO_CALLBACK";
            break;
          case 4825:
            double result = "OI_SMP_ERROR_CRYPTO_FAILED";
            break;
          case 4826:
            double result = "OI_SMP_ERROR_NO_ROOT_KEYS";
            break;
          case 4827:
            double result = "OI_SMP_ERROR_TIMEOUT_USER_RSP";
            break;
          case 4828:
            double result = "OI_SMP_ERROR_CRYPTO_IRK";
            break;
          case 4829:
            double result = "OI_SMP_ERROR_CRYPTO";
            break;
          case 4830:
            double result = "OI_SMP_ERROR_BREDR_PAIRING_IN_PROGRESS";
            break;
          case 4831:
            double result = "OI_SMP_ERROR_CTKD_NA";
            break;
          case 4832:
            double result = "LE_SECURITY_ERROR_COMPROMISED_DEVICE";
            break;
          case 4833:
            double result = "LE_SECURITY_ERROR_OTHER_SIDE_UNPAIRED";
            break;
          case 4834:
            double result = "LE_SECURITY_ERROR_ENCRYPTION_TIMEOUT";
            break;
          case 4835:
            double result = "LE_SECURITY_ERROR_TOO_MANY_PAIRED_DEVICES";
            break;
          case 4836:
            double result = "LE_SECURITY_ERROR_NEW_LOCAL_DEVICE_IDENTIFIER";
            break;
          case 4837:
            double result = "LE_SECURITY_ERROR_PAIRING_NOT_ALLOWED";
            break;
          default:
            switch(a1)
            {
              case 4300:
                double result = "BT_ATT_STATUS_SUCCESS";
                break;
              case 4301:
                double result = "BT_ATT_ERROR_INVALID_HANDLE";
                break;
              case 4302:
                double result = "BT_ATT_ERROR_READ_NOT_PERMITTED";
                break;
              case 4303:
                double result = "BT_ATT_ERROR_WRITE_NOT_PERMITTED";
                break;
              case 4304:
                double result = "BT_ATT_ERROR_INVALID_PDU";
                break;
              case 4305:
                double result = "BT_ATT_ERROR_INSUFFICIENT_AUTHENTICATION";
                break;
              case 4306:
                double result = "BT_ATT_ERROR_REQUEST_NOT_SUPPORTED";
                break;
              case 4307:
                double result = "BT_ATT_ERROR_INVALID_OFFSET";
                break;
              case 4308:
                double result = "BT_ATT_ERROR_INSUFFICIENT_AUTHORIZATION";
                break;
              case 4309:
                double result = "BT_ATT_ERROR_PREPARE_QUEUE_FULL";
                break;
              case 4310:
                double result = "BT_ATT_ERROR_ATTRIBUTE_NOT_FOUND";
                break;
              case 4311:
                double result = "BT_ATT_ERROR_ATTRIBUTE_NOT_LONG";
                break;
              case 4312:
                double result = "BT_ATT_ERROR_INSUFFICIENT_ENCRYPTION_KEY_SIZE";
                break;
              case 4313:
                double result = "BT_ATT_ERROR_INVALID_ATTRIBUTE_VALUE_LENGTH";
                break;
              case 4314:
                double result = "BT_ATT_ERROR_UNLIKELY_ERROR";
                break;
              case 4315:
                double result = "BT_ATT_ERROR_INSUFFICIENT_ENCRYPTION";
                break;
              case 4316:
                double result = "BT_ATT_ERROR_UNSUPPORTED_GROUP_TYPEN";
                break;
              case 4317:
                double result = "BT_ATT_ERROR_INSUFFICIENT_RESOURCES";
                break;
              default:
                switch(a1)
                {
                  case 4540:
                    double result = "BT_ATT_ERROR_RESPONSE_PENDING";
                    break;
                  case 4541:
                    double result = "BT_ATT_ERROR_RESPONSE_TIMEOUT_REACHED";
                    break;
                  case 4542:
                    double result = "BT_ATT_ERROR_APPLICATION_UNAVAILABLE";
                    break;
                  case 4543:
                    double result = "BT_ATT_ERROR_RESPONSE_FULL";
                    break;
                  case 4544:
                    double result = "BT_ATT_ERROR_PREPARE_WRITE_INVALID";
                    break;
                  case 4545:
                    double result = "BT_ATT_ERROR_WRITE_REJECTED";
                    break;
                  default:
                    return 0LL;
                }

                break;
            }

            break;
        }

        return result;
      }

      if (a1 <= 5099)
      {
        switch(a1)
        {
          case 5000:
            double result = "BT_TS_TIMEOUT_UPGRADE_ERR";
            break;
          case 5001:
            double result = "BT_TS_TIMEOUT_UPGRADING_ERR";
            break;
          case 5002:
            double result = "BT_TS_TIMEOUT_UPGRADE_ENCRYPT_ERR";
            break;
          case 5003:
            double result = "BT_TS_TIMEOUT_UPGRADE_FINAL_ERR";
            break;
          case 5004:
            double result = "BT_TS_TIMEOUT_DOWNGRADE_STALL_ERR";
            break;
          case 5005:
            double result = "BT_TS_TIMEOUT_DOWNGRADE_ERR";
            break;
          case 5006:
            double result = "BT_TS_L2CAP_ERR";
            break;
          case 5007:
            double result = "BT_TS_NO_ALTERNATE_TRANSPORT";
            break;
          case 5008:
            double result = "BT_TS_FLUSH_NOT_SUPPORTED_ON_LE";
            break;
          case 5009:
            double result = "BT_TS_LE_DISCONNECTED";
            break;
          case 5010:
            double result = "BT_TS_UPGRADE_NOT_TRACKED_CENTRAL";
            break;
          case 5011:
            double result = "BT_TS_UPGRADE_NOT_TRACKED_PERIPHERAL";
            break;
          case 5012:
            double result = "BT_TS_UPGRADE_POLICY_ENF_FAILED";
            break;
          case 5013:
            double result = "BT_TS_STATUS_DEFAULT";
            break;
          case 5014:
            double result = "BT_TS_TIMEOUT";
            break;
          case 5015:
            double result = "BT_TS_SWITCH_HW_ERROR";
            break;
          case 5016:
            double result = "BT_TS_ERROR_INVALID_LMHANDLE";
            break;
          case 5017:
            double result = "BT_TS_ERROR_LL_COLLISION_DETECTED_AFH";
            break;
          case 5018:
            double result = "BT_TS_ERROR_LL_COLLISION_DETECTED_CON_UPDATE";
            break;
          case 5019:
            double result = "BT_TS_ERROR_LL_COLLISION_REJECTED_AFH";
            break;
          case 5020:
            double result = "BT_TS_ERROR_LL_COLLISION_REJECTED_CON_UPDATE";
            break;
          case 5021:
          case 5022:
          case 5023:
          case 5024:
          case 5025:
          case 5026:
          case 5027:
          case 5028:
          case 5029:
          case 5030:
          case 5031:
          case 5032:
          case 5033:
          case 5034:
          case 5035:
          case 5036:
          case 5037:
          case 5038:
          case 5039:
          case 5040:
          case 5041:
          case 5042:
          case 5043:
          case 5044:
          case 5045:
          case 5046:
          case 5047:
          case 5048:
          case 5049:
            return 0LL;
          case 5050:
            double result = "BT_TS_STATUS_SUCCESS";
            break;
          case 5051:
            double result = "BT_TS_STATUS_ERROR_INTERNAL";
            break;
          case 5052:
            double result = "BT_TS_STATUS_ERROR_ROLE";
            break;
          case 5053:
            double result = "BT_TS_STATUS_ERROR_PDU";
            break;
          case 5054:
            double result = "BT_TS_STATUS_ERROR_TRANSPORT";
            break;
          case 5055:
            double result = "BT_TS_STATUS_ERROR_STATE";
            break;
          case 5056:
            double result = "BT_TS_STATUS_ERROR_ENCRYPTION";
            break;
          case 5057:
            double result = "BT_TS_STATUS_ERROR_CONTROLLER";
            break;
          default:
            if (a1 != 5090) {
              return 0LL;
            }
            double result = "BT_TR_PARSER_PRELUDE_INCOMPLETE";
            break;
        }

        return result;
      }

      if (a1 > 5402)
      {
        switch(a1)
        {
          case 9500:
            double result = "BD_HCI_STALL_ERROR";
            break;
          case 9501:
            double result = "BD_GATT_UPDATE_GAP_NAME_ERROR";
            break;
          case 9502:
            double result = "BD_TEST_ERROR";
            break;
          case 9503:
            double result = "BD_PROFILE_FAILED_TO_STOP_ERROR";
            break;
          case 9504:
            double result = "BD_PROFILE_FAILED_TO_DEREGISTER_ERROR";
            break;
          case 9505:
            double result = "BD_PROFILE_FAILED_TO_CLEANUP_ERROR";
            break;
          default:
            if (a1 == 5403)
            {
              double result = "OI_MAX_BM3_STATUS_VAL";
            }

            else
            {
              if (a1 != 0xFFFF) {
                return 0LL;
              }
              double result = "OI_STATUS_NONE";
            }

            break;
        }

        return result;
      }

      if (a1 <= 5101)
      {
        if (a1 == 5100) {
          return "BT_CL_SEND_PDU_INVALID_HANDLE";
        }
        else {
          return "BT_CL_PEER_REMOVED_SERVICE";
        }
      }

      if (a1 == 5102) {
        return "BT_CL_SERVICE_UNREGISTERED_LOCALLY";
      }
      if (a1 == 5300) {
        return "BT_LEA_ERROR_STALLED_CONNECTION";
      }
      return 0LL;
    }

    if (a1 <= 3999)
    {
      if (a1 <= 3601)
      {
        switch(a1)
        {
          case 3570:
            return "BT_AAP_DISCONNECT";
          case 3600:
            return "BT_VSC_SEND_INPROGRESS_ERROR";
          case 3601:
            return "BT_VSC_NOT_IMPLEMENTED_ERROR";
        }

        return 0LL;
      }

      switch(a1)
      {
        case 3700:
          double result = "BD_DEBUG_DUMP";
          break;
        case 3701:
          double result = "BT_ASSERT_FAILURE";
          break;
        case 3702:
          return 0LL;
        case 3703:
          double result = "BT_CONTROLLER_CORE_DUMP";
          break;
        case 3704:
          double result = "BT_CONTROLLER_CORE_DUMP_INPROGRESS";
          break;
        case 3705:
          double result = "BD_ABORT_FAILURE";
          break;
        case 3706:
          double result = "BD_COREDUMP_IDLE_TIMEOUT";
          break;
        case 3707:
          double result = "BD_COREDUMP_TOO_LONG";
          break;
        case 3708:
          double result = "BT_MAC_IN_DARK_SLEEP_MODE";
          break;
        case 3709:
          double result = "BT_HCI_CMD_PENDING_BEFORE_DARK_SLEEP";
          break;
        case 3710:
          double result = "BT_TRANS_NOT_READY_BEFORE_DARK_WAKE";
          break;
        case 3711:
          double result = "BT_MAC_DARK_WAKE_TAKE_TOO_LONG";
          break;
        case 3712:
          double result = "BT_FAILED_TO_START_MAC_USER";
          break;
        case 3713:
          double result = "BT_FAILED_TO_CREATE_PCIE_ERROR_LISTENER";
          break;
        case 3714:
          double result = "BT_FAILED_TO_CREATE_PCIE_TIMESYNC_LISTENER";
          break;
        case 3715:
          double result = "BT_STACK_STOP_ERROR";
          break;
        case 3716:
          double result = "BT_MISSED_HEART_BEAT_NOTIFICATION";
          break;
        default:
          if (a1 != 3602) {
            return 0LL;
          }
          double result = "BT_VSC_STALL_ERROR";
          break;
      }
    }

    else
    {
      if (a1 > 4199)
      {
        switch(a1)
        {
          case 4200:
            return "BT_ATT_CLASSIC_MTU_REQ_ERROR";
          case 4201:
            return "BT_ATT_UNHANDLED_CLIENT_REQ_ERROR";
          case 4202:
            return "BT_ATT_SESSION_NOT_FOUND_ERROR";
        }

        return 0LL;
      }

      switch(a1)
      {
        case 4000:
          double result = "LE_LENGTH_ALREADY_BEST_FIT";
          break;
        case 4001:
          double result = "LE_ATT_WRITE_DATA_DROP_ERROR";
          break;
        case 4002:
          double result = "LE_ATT_SENDPDU_INVALID_BEARER";
          break;
        case 4003:
          double result = "LE_ATT_SENDPDU_INVALID_CONN";
          break;
        case 4004:
          double result = "LE_ATT_STATUS_DEFAULT";
          break;
        case 4005:
          double result = "LE_ATT_MTU_EXCH_ERROR";
          break;
        case 4006:
          double result = "LE_ATT_RSP_FIND_INFO_ERROR";
          break;
        case 4007:
          double result = "LE_ATT_RSP_FIND_INFO_UUID_ERROR";
          break;
        case 4008:
          double result = "LE_ATT_RSP_READ_BY_TYPE_LEN_ERROR";
          break;
        case 4009:
          double result = "LE_ATT_RSP_READ_BY_TYPE_ATRB_LEN_ERROR";
          break;
        case 4010:
          double result = "LE_ATT_RSP_READ_BY_GROUP_LEN_ERROR";
          break;
        case 4011:
          double result = "LE_ATT_RSP_READ_BY_GROUP_ATTRB_ERROR";
          break;
        case 4012:
          double result = "LE_ATT_RSP_PREPARE_WRITE_ERROR";
          break;
        case 4013:
          double result = "LE_ATT_INIT_FAIL";
          break;
        case 4014:
          double result = "LE_ATT_DB_SET_CB_ERROR";
          break;
        case 4015:
          double result = "LE_ATT_DB_UNSET_CB_ERROR";
          break;
        case 4016:
          double result = "LE_ATT_REG_ATRB_MAX_HANDLE_ERROR";
          break;
        case 4017:
          double result = "LE_ATT_REG_ATRB_INVALID_HANDLE_ERROR";
          break;
        case 4018:
          double result = "LE_ATT_SEND_CHAR_VAL_UPDATE_ERROR";
          break;
        case 4019:
          double result = "LE_ATT_SEND_CHAR_VAL_UPDATE_ALLOC_ERROR";
          break;
        case 4020:
          double result = "LE_ATT_SEND_CHAR_VAL_UPDATE_SESS_ERROR";
          break;
        case 4021:
          double result = "LE_ATT_WRITE_UNPACK_ERROR";
          break;
        case 4022:
          double result = "LE_ATT_RSP_FIND_BY_TYPE_ERROR";
          break;
        case 4050:
          double result = "LE_GAP_CALLBACK_MAX_ERROR";
          break;
        case 4051:
          double result = "LE_GAP_GETCONNINT_INVALIDHANDLE";
          break;
        case 4052:
          double result = "LE_GAP_GETADDR_INVALIDHANDLE";
          break;
        case 4053:
          double result = "LE_GAP_ADDADDR_MAXCB_ERROR";
          break;
        case 4054:
          double result = "LE_GAP_ROLE_ALREADY_SET_ERROR";
          break;
        case 4055:
          double result = "LE_GAP_SET_DISCOVERABLE_STATE_ERROR";
          break;
        case 4056:
          double result = "LE_GAP_PARSE_UUID_ERROR";
          break;
        case 4057:
          double result = "LE_GAP_PARSE_ADSERVICE_ERROR";
          break;
        case 4058:
          double result = "LE_GAP_PARSE_AD_RSP_ERROR";
          break;
        case 4059:
          double result = "LE_GAP_PARSE_AD_RSP_SIZE_ERROR";
          break;
        case 4060:
          double result = "LE_GAP_DISCOVERY_ALREADY_SCANNING";
          break;
        case 4061:
          double result = "LE_GAP_START_ADVERTISING_ERROR";
          break;
        case 4062:
          double result = "LE_GAP_INIT_ADVERTISING_WRONG_ADDR_ERROR";
          break;
        case 4063:
          double result = "LE_GAP_DIRECT_CONNECTABLE_ERROR";
          break;
        case 4064:
          double result = "LE_GAP_UNDIRECT_CONNECTABLE_ERROR";
          break;
        case 4065:
          double result = "LE_GAP_AUTO_CONNECT_ROLE_ERROR";
          break;
        case 4066:
          double result = "LE_GAP_AUTO_CONNECT_FILTER_ACCEPT_LIST_ERROR";
          break;
        case 4067:
          double result = "LE_GAP_DIRECT_CONNECT_ERROR";
          break;
        case 4068:
          double result = "LE_GAP_START_BONDING_ERROR";
          break;
        case 4069:
          double result = "LE_GAP_UNKNOWN_RANDOM_ADDR_ERROR";
          break;
        case 4070:
          double result = "LE_GAP_GEN_ADDR_ERROR";
          break;
        case 4071:
          double result = "LE_GAP_SET_ADDR_ERROR";
          break;
        case 4072:
          double result = "LE_GAP_REFRESH_ADDR_ERROR";
          break;
        case 4073:
          double result = "LE_GAP_ADDRESS_REFRESH_IN_PROGRESS";
          break;
        case 4074:
          double result = "LE_GAP_ADDRESS_REFRESH_TIMEOUT";
          break;
        case 4075:
          double result = "LE_GAP_ADVERTISING_STATE_UNSETTLED";
          break;
        case 4100:
          double result = "LE_GATT_SESSION_MTU_ERROR";
          break;
        case 4101:
          double result = "LE_GATT_EXE_LONGCHARVALUE_RSP_ERROR";
          break;
        case 4102:
          double result = "LE_GATT_WRITE_LONGCHARVALUE_RSP_ERROR";
          break;
        case 4103:
          double result = "LE_GATT_ADD_CHAR_CB_ERROR";
          break;
        case 4104:
          double result = "LE_GATT_ADD_CHAR_PROPERTIES_ERROR";
          break;
        case 4105:
          double result = "LE_GATT_DB_REGISTERATION_ERROR";
          break;
        case 4106:
          double result = "LE_GATT_DB_REGISTER_ATTRB_ERROR";
          break;
        case 4107:
          double result = "LE_GATT_SENDCHAR_UPDATE_UUID_ERROR";
          break;
        case 4108:
          double result = "LE_GATT_SENDCHAR_NOTIFY_ERROR";
          break;
        case 4109:
          double result = "LE_GATT_SENDCHAR_INDICATE_ERROR";
          break;
        case 4120:
          double result = "LE_SIGNALMAN_SEND_REJECTED";
          break;
        case 4121:
          double result = "LE_SIGNALMAN_SEND_CONN_UPDATE";
          break;
        case 4122:
          double result = "LE_SIGNALMAN_SEND_CHANN_RSP";
          break;
        case 4123:
          double result = "LE_SIGNALMAN_SEND_CHANN_REQ";
          break;
        case 4124:
          double result = "LE_SIGNALMAN_FLOW_ERROR";
          break;
        case 4125:
          double result = "LE_SIGNALMAN_CMD_REJECT_ERROR";
          break;
        case 4126:
          double result = "LE_SIGNALMAN_DISC_REQ_ERROR";
          break;
        case 4127:
          double result = "LE_SIGNALMAN_DISC_RSP_ERROR";
          break;
        case 4151:
          double result = "LE_FILTER_ACCEPT_LIST_ADDRESS_NOT_FOUND_ERROR";
          break;
        case 4152:
          double result = "LE_FILTER_ACCEPT_LIST_DUPLICATE_ADDRESS_FOUND_ERROR";
          break;
        case 4170:
          double result = "LE_CONNECTION_UPDATE_DUPLICATE";
          break;
        default:
          return 0LL;
      }
    }
  }

  return result;
}

uint64_t sub_1001F42A4(uint64_t a1)
{
  return (*(__int16 *)(a1 + 4) + 1000 * *(_DWORD *)a1);
}

uint64_t sub_1001F42B8(uint64_t a1, uint64_t a2)
{
  if (!a1 || !a2) {
    sub_1001EE2A0();
  }
  if (*(_DWORD *)a1 >= *(_DWORD *)a2)
  {
    if (*(_DWORD *)a1 <= *(_DWORD *)a2)
    {
      int v5 = *(__int16 *)(a1 + 4);
      int v6 = *(__int16 *)(a2 + 4);
      BOOL v7 = v5 < v6;
      __int16 v4 = v5 > v6;
      if (v7) {
        return -1;
      }
    }

    else
    {
      return 1;
    }
  }

  else
  {
    return -1;
  }

  return v4;
}

uint64_t sub_1001F4324(int *a1, int *a2)
{
  int v4 = *a2;
  int v5 = *a1;
  __int16 v6 = *((_WORD *)a2 + 2);
  __int16 v7 = *((_WORD *)a1 + 2);
  int v8 = *a2 - *a1;
  if (*a2 < *a1)
  {
    sub_1001EE2A0();
    int v4 = *a2;
    int v5 = *a1;
  }

  __int16 v9 = v6 - v7;
  int v10 = (__int16)(v6 - v7);
  if (v10 < 0) {
    __int16 v9 = v6 - v7 + 1000;
  }
  int v11 = 10 * v9;
  int v13 = v11 + 512;
  BOOL v12 = v11 < -512;
  unsigned int v14 = v11 + 1535;
  if (!v12) {
    unsigned int v14 = v13;
  }
  return (unsigned __int16)(10 * (v8 + (v10 >> 15)) + (v14 >> 10));
}

uint64_t sub_1001F43D4(int *a1, int *a2)
{
  int v4 = *a2;
  int v5 = *a1;
  __int16 v6 = *((_WORD *)a2 + 2);
  __int16 v7 = *((_WORD *)a1 + 2);
  int v8 = *a2 - *a1;
  if (*a2 < *a1)
  {
    sub_1001EE2A0();
    int v4 = *a2;
    int v5 = *a1;
  }

  __int16 v9 = v6 - v7;
  int v10 = (__int16)(v6 - v7);
  if (v10 < 0) {
    __int16 v9 = v6 - v7 + 1000;
  }
  return (1000 * (v8 + (v10 >> 15)) + v9);
}

BOOL sub_1001F4468(uint64_t a1)
{
  uint64_t v3 = 0LL;
  sub_1000B0400((uint64_t)&v3);
  return (sub_1001F42B8((uint64_t)&v3, a1) & 0x8000) == 0;
}

uint64_t sub_1001F44AC(unint64_t a1, int a2, _BYTE *a3, int a4)
{
  __int16 v7 = a3;
  unint64_t v8 = a1;
  if (a1 && a2 > 0 && a3 && a4 > 0)
  {
    unint64_t v4 = (unint64_t)&a3[a4];
    int v5 = sub_10009C354(&v8, a1 + 2LL * a2, (uint64_t *)&v7, v4, 0);
    if (v5)
    {
      return dword_1006BF004[v5];
    }

    else if ((unint64_t)v7 >= v4)
    {
      if (v7 == (_BYTE *)v4)
      {
        if (*(_BYTE *)(v4 - 1)) {
          return 3202LL;
        }
        else {
          return 0LL;
        }
      }

      else
      {
        return 0LL;
      }
    }

    else
    {
      uint64_t result = 0LL;
      *__int16 v7 = 0;
    }
  }

  else
  {
    sub_1001EE2A0();
    return 101LL;
  }

  return result;
}

uint64_t sub_1001F4558(unsigned __int16 *a1)
{
  unsigned int v1 = a1;
  if (!a1) {
    sub_1001EE2A0();
  }
  LODWORD(result) = -1;
  do
  {
    int v3 = *v1++;
    uint64_t result = (result + 1);
  }

  while (v3);
  return result;
}

_BYTE *sub_1001F458C(_BYTE *result, int *a2)
{
  if (result && a2)
  {
    for (uint64_t i = 0LL; ; ++i)
    {
      int v3 = result[i];
      if (v3 != 32 && v3 != 9) {
        break;
      }
    }

    uint64_t v5 = v3 == 45;
    uint64_t v6 = (uint64_t)(v3 == 45 ? result + 1 : result);
    __int16 v7 = (_BYTE *)(v6 + i);
    int v8 = *(unsigned __int8 *)(v6 + i);
    if ((v8 - 48) <= 9)
    {
      if (v8 == 48 && (__int16 v9 = &result[v5 + i], v9[1] == 120))
      {
        int v12 = v9[2];
        int v11 = v9 + 2;
        int v10 = v12;
        if (v12)
        {
          int v13 = 0;
          do
          {
            if ((v10 - 48) >= 0xA)
            {
              if ((v10 - 97) >= 6)
              {
                int v14 = -55;
              }

              else
              {
                int v14 = -87;
              }
            }

            else
            {
              int v14 = -48;
            }

            int v13 = v14 + 16 * v13 + v10;
            int v10 = result[v5++ + 3 + i];
          }

          while (v10);
          result += i + v5 + 2;
        }

        else
        {
          int v13 = 0;
          uint64_t result = v11;
        }
      }

      else
      {
        int v15 = 0;
        do
        {
          int v13 = v15;
          uint64_t result = v7;
          int v16 = *v7;
          if (!*v7) {
            break;
          }
          unsigned int v17 = v16 - 48;
          int v15 = v16 - 48 + 10 * v13;
          ++v7;
        }

        while (v17 < 0xA);
      }

      if (v3 == 45) {
        int v18 = -v13;
      }
      else {
        int v18 = v13;
      }
      *a2 = v18;
    }
  }

  return result;
}

uint64_t sub_1001F46A4(_BYTE *a1)
{
  unsigned int v2 = 0;
  else {
    return v2;
  }
}

uint64_t sub_1001F46E0(unsigned __int8 *a1, unsigned __int8 *a2)
{
  if (a1)
  {
    if (a2) {
      goto LABEL_4;
    }
    goto LABEL_3;
  }

  sub_1001EE2A0();
  if (!a2) {
LABEL_3:
  }
    sub_1001EE2A0();
LABEL_4:
  int v4 = *a1;
  int v5 = *a2;
  else {
    unsigned __int8 v6 = v5 - 32;
  }
  __int16 v7 = a2 + 1;
  int v8 = a1 + 1;
  while (1)
  {
    if (!(_BYTE)v4) {
      break;
    }
    int v9 = *v8++;
    LOBYTE(v4) = v9;
    char v10 = v9 - 32;
    int v11 = *v7++;
    unsigned __int8 v6 = v11;
    unsigned __int8 v12 = v11 - 32;
  }

  return 0LL;
}

unsigned __int8 *sub_1001F47B0(unsigned __int8 *a1, uint64_t a2)
{
  if (!a1 || !a2) {
    return a1;
  }
  for (uint64_t i = a1; ; ++i)
  {
    int v3 = *i;
    if (v3 != 9 && v3 != 32) {
      break;
    }
  }

  for (uint64_t j = 0LL; j != 6; ++j)
  {
    int v5 = *i;
    if ((v5 - 48) >= 0xA)
    {
      if ((v5 - 97) >= 6)
      {
        char v6 = -55;
      }

      else
      {
        char v6 = -87;
      }
    }

    else
    {
      char v6 = -48;
    }

    int v7 = i[1];
    if ((v7 - 48) >= 0xA)
    {
      if ((v7 - 97) >= 6)
      {
        char v8 = -55;
      }

      else
      {
        char v8 = -87;
      }
    }

    else
    {
      char v8 = -48;
    }

    *(_BYTE *)(a2 + j) = v7 + 16 * (v6 + v5) + v8;
    int v9 = i + 2;
    int v10 = i[2];
    if (v10 == 58 || v10 == 45) {
      int v9 = i + 3;
    }
    uint64_t i = v9;
  }

  return v9;
}

BOOL sub_1001F48A0(unsigned __int8 *a1, uint64_t a2)
{
  return sub_1001F47B0(a1, a2) != a1;
}

uint64_t sub_1001F48C8(uint64_t a1, size_t size)
{
  __int16 v2 = size;
  *(_BYTE *)a1 = 1;
  *(_WORD *)(a1 + 4) = 0;
  int v4 = sub_1000B17F4(size);
  *(void *)(a1 + 8) = v4;
  if (v4) {
    __int16 v5 = v2;
  }
  else {
    __int16 v5 = 0;
  }
  if (v4) {
    uint64_t result = 0LL;
  }
  else {
    uint64_t result = 106LL;
  }
  *(_WORD *)(a1 + 2) = v5;
  return result;
}

void sub_1001F4914(uint64_t a1)
{
  if (!*(_BYTE *)a1) {
    sub_1001EE2A0();
  }
  sub_1000B1838(*(void **)(a1 + 8));
  *(void *)(a1 + 8) = 0LL;
  *(_WORD *)(a1 + 2) = 0;
}

uint64_t sub_1001F494C(uint64_t a1, char *a2, int a3)
{
  uint64_t result = 0LL;
  if (a2)
  {
    int v5 = a3;
    if (a3)
    {
      char v6 = a2;
      while (1)
      {
        char v7 = *v6;
        if (!*v6) {
          return 0LL;
        }
        if (!*(_WORD *)(a1 + 2)
          || (unsigned int v8 = *(unsigned __int16 *)(a1 + 4), *(unsigned __int16 *)(a1 + 2) - 1 <= v8))
        {
          if (!*(_BYTE *)a1) {
            return 0LL;
          }
          if (!sub_1001F49EC(a1)) {
            return 106LL;
          }
          char v7 = *v6;
          unsigned int v8 = *(unsigned __int16 *)(a1 + 4);
        }

        --v5;
        ++v6;
        uint64_t v9 = *(void *)(a1 + 8);
        *(_WORD *)(a1 + 4) = v8 + 1;
        *(_BYTE *)(v9 + v8) = v7;
        if (!(_WORD)v5) {
          return 0LL;
        }
      }
    }
  }

  return result;
}

BOOL sub_1001F49EC(uint64_t a1)
{
  if (!*(void *)(a1 + 8)) {
    sub_1001EE2A0();
  }
  if (!*(_BYTE *)a1) {
    sub_1001EE2A0();
  }
  __int16 v2 = sub_1000B17F4(*(unsigned __int16 *)(a1 + 2) + 32LL);
  int v3 = v2;
  if (v2)
  {
    if (*(_WORD *)(a1 + 4))
    {
      unint64_t v4 = 0LL;
      do
      {
        v2[v4] = *(_BYTE *)(*(void *)(a1 + 8) + v4);
        ++v4;
      }

      while (v4 < *(unsigned __int16 *)(a1 + 4));
    }

    sub_1000B1838(*(void **)(a1 + 8));
    *(void *)(a1 + 8) = v3;
    *(_WORD *)(a1 + 2) += 32;
  }

  return v3 != 0LL;
}

uint64_t sub_1001F4A7C(uint64_t a1, _BYTE *a2)
{
  if (!a2) {
    return 0LL;
  }
  char v2 = *a2;
  if (!*a2) {
    return 0LL;
  }
  unint64_t v4 = a2 + 1;
  while (1)
  {
    if (*(_WORD *)(a1 + 2))
    {
      unsigned int v5 = *(unsigned __int16 *)(a1 + 4);
    }

    if (!*(_BYTE *)a1) {
      return 0LL;
    }
    if (!sub_1001F49EC(a1)) {
      return 106LL;
    }
    char v2 = *(v4 - 1);
    unsigned int v5 = *(unsigned __int16 *)(a1 + 4);
LABEL_9:
    uint64_t v6 = *(void *)(a1 + 8);
    *(_WORD *)(a1 + 4) = v5 + 1;
    *(_BYTE *)(v6 + v5) = v2;
    int v7 = *v4++;
    char v2 = v7;
    if (!v7) {
      return 0LL;
    }
  }

uint64_t sub_1001F4B08(uint64_t a1, _BYTE *a2)
{
  if (!a2) {
    return 0LL;
  }
  int v2 = *a2;
  if (!*a2) {
    return 0LL;
  }
  unint64_t v4 = a2 + 1;
  while (*(_WORD *)(a1 + 2) && *(unsigned __int16 *)(a1 + 2) - 1 > *(unsigned __int16 *)(a1 + 4))
  {
LABEL_9:
    if (v2 == 10)
    {
      uint64_t v5 = a1;
      uint64_t v6 = "<lf>";
    }

    else
    {
      if (v2 != 13)
      {
        uint64_t v7 = *(void *)(a1 + 8);
        uint64_t v8 = *(unsigned __int16 *)(a1 + 4);
        *(_WORD *)(a1 + 4) = v8 + 1;
        *(_BYTE *)(v7 + v8) = v2;
        goto LABEL_15;
      }

      uint64_t v5 = a1;
      uint64_t v6 = "<cr>";
    }

    sub_1001F4A7C(v5, v6);
LABEL_15:
    int v9 = *v4++;
    int v2 = v9;
    if (!v9) {
      return 0LL;
    }
  }

  if (!*(_BYTE *)a1) {
    return 0LL;
  }
  if (sub_1001F49EC(a1))
  {
    int v2 = *(v4 - 1);
    goto LABEL_9;
  }

  return 106LL;
}

uint64_t sub_1001F4BD8(uint64_t a1, _BYTE *a2, int a3)
{
  uint64_t result = 0LL;
  if (a2)
  {
    int v5 = a3;
    if (a3)
    {
      for (uint64_t i = a2; ; ++i)
      {
        if (!*(_WORD *)(a1 + 2) || *(unsigned __int16 *)(a1 + 2) - 1 <= *(unsigned __int16 *)(a1 + 4))
        {
          if (!*(_BYTE *)a1) {
            return 0LL;
          }
          if (!sub_1001F49EC(a1)) {
            return 106LL;
          }
        }

        int v7 = *i;
        if (*i)
        {
          if (v7 == 10)
          {
            uint64_t v8 = a1;
            int v9 = "<lf>";
          }

          else
          {
            if (v7 != 13)
            {
              uint64_t v10 = *(void *)(a1 + 8);
              uint64_t v11 = *(unsigned __int16 *)(a1 + 4);
              *(_WORD *)(a1 + 4) = v11 + 1;
              *(_BYTE *)(v10 + v11) = v7;
              goto LABEL_16;
            }

            uint64_t v8 = a1;
            int v9 = "<cr>";
          }
        }

        else
        {
          uint64_t v8 = a1;
          int v9 = "<null>";
        }

        sub_1001F4A7C(v8, v9);
LABEL_16:
        if (!(_WORD)--v5) {
          return 0LL;
        }
      }
    }
  }

  return result;
}

uint64_t sub_1001F4CCC(uint64_t a1, int a2)
{
  if (!a2) {
    return 0LL;
  }
  int v2 = a2;
  while (1)
  {
    if (*(_WORD *)(a1 + 2))
    {
      unsigned int v4 = *(unsigned __int16 *)(a1 + 4);
    }

    if (!*(_BYTE *)a1) {
      return 0LL;
    }
    if (!sub_1001F49EC(a1)) {
      return 106LL;
    }
    unsigned int v4 = *(unsigned __int16 *)(a1 + 4);
LABEL_8:
    --v2;
    uint64_t v5 = *(void *)(a1 + 8);
    *(_WORD *)(a1 + 4) = v4 + 1;
    *(_BYTE *)(v5 + v4) = 32;
    if (!(_BYTE)v2) {
      return 0LL;
    }
  }

uint64_t sub_1001F4D5C(uint64_t a1, unsigned int a2, int a3)
{
  else {
    int v3 = 8;
  }
  unsigned int v4 = &v7;
  char v7 = 0;
  HIBYTE(v6) = 0;
  do
  {
    *--unsigned int v4 = a0123456789abcd_0[a2 & 0xF];
    a2 >>= 4;
    --v3;
  }

  while (v3);
  return sub_1001F4A7C(a1, v4);
}

uint64_t sub_1001F4DE8(uint64_t a1, unsigned int a2)
{
  if (a2 == 0x80000000) {
    return sub_1001F4A7C(a1, "-2147483648");
  }
  unsigned int v4 = a2;
  if ((a2 & 0x80000000) != 0)
  {
    sub_1001F4A7C(a1, "-");
    unsigned int v4 = -v4;
  }

  char v7 = 0;
  uint64_t v5 = &v8;
  char v8 = 0;
  do
  {
    *--uint64_t v5 = a0123456789abcd_0[v4 % 0xA];
    BOOL v6 = v4 > 9;
    v4 /= 0xAu;
  }

  while (v6);
  return sub_1001F4A7C(a1, v5);
}

uint64_t sub_1001F4EE4(uint64_t a1, unsigned __int8 *a2, char **a3)
{
  int v3 = *a2;
  if (!*a2) {
    return 0LL;
  }
  unsigned int v4 = a2;
  while (1)
  {
    if (!*(_WORD *)(a1 + 2) || *(unsigned __int16 *)(a1 + 2) - 1 <= *(unsigned __int16 *)(a1 + 4))
    {
      if (!*(_BYTE *)a1) {
        return 0LL;
      }
      if (!sub_1001F49EC(a1)) {
        return 106LL;
      }
      int v3 = *v4;
    }

    if (v3 == 37) {
      break;
    }
    uint64_t v136 = *(void *)(a1 + 8);
    uint64_t v137 = *(unsigned __int16 *)(a1 + 4);
    *(_WORD *)(a1 + 4) = v137 + 1;
    *(_BYTE *)(v136 + v13memset((char *)&v11[1] + 1, 0, 7) = v3;
LABEL_277:
    int v138 = *++v4;
    int v3 = v138;
    if (!v138) {
      return 0LL;
    }
  }

  uint64_t v6 = 0LL;
  uint64_t v144 = 0LL;
  char v143 = 0;
  int v7 = 0;
  char v8 = 1;
  char v145 = 1;
  char v146 = 0;
  while (1)
  {
    if ((v8 & 1) == 0) {
      goto LABEL_277;
    }
    uint64_t v10 = v4 + 1;
    unsigned int v9 = v4[1];
    uint64_t result = 115LL;
    if (v9 <= 0x6B) {
      break;
    }
    switch(v4[1])
    {
      case 'p':
        unsigned int v17 = a3++;
        uint64_t v150 = *v17;
        uint64_t v18 = *(void *)(a1 + 8);
        uint64_t v19 = *(unsigned __int16 *)(a1 + 4);
        *(_WORD *)(a1 + 4) = v19 + 1;
        *(_BYTE *)(v18 + v19) = 48;
        uint64_t v20 = *(void *)(a1 + 8);
        uint64_t v21 = *(unsigned __int16 *)(a1 + 4);
        *(_WORD *)(a1 + 4) = v21 + 1;
        *(_BYTE *)(v20 + v21) = 120;
        uint64_t v22 = 7LL;
        do
        {
          uint64_t v23 = v22;
          unsigned int v24 = *((unsigned __int8 *)&v150 + v22);
          LOBYTE(v149) = 0;
          uint64_t v148 = 0LL;
          int v25 = -2;
          uint64_t v26 = &v149;
          do
          {
            *((_BYTE *)v26 - 1) = a0123456789abcd_0[v24 & 0xF];
            uint64_t v26 = (uint64_t *)((char *)v26 - 1);
            v24 >>= 4;
            BOOL v27 = __CFADD__(v25++, 1);
          }

          while (!v27);
          sub_1001F4A7C(a1, v26);
          uint64_t v22 = v23 - 1;
        }

        while (v23);
        goto LABEL_272;
      case 'q':
      case 'r':
      case 't':
      case 'v':
      case 'w':
        return result;
      case 's':
        if ((v144 & 0x100000000LL) != 0)
        {
LABEL_87:
          uint64_t v60 = (unsigned __int16 **)a3++;
          uint64_t v61 = *v60;
          if ((v146 & 1) != 0)
          {
            uint64_t v62 = a3++;
            if (v61)
            {
              int v63 = *(_DWORD *)v62;
              if ((_WORD)v63)
              {
                int v64 = (unsigned __int16)v63;
                uint64_t v65 = a1;
LABEL_206:
                sub_1001F5E64(v65, v61, v64);
                goto LABEL_254;
              }

              uint64_t v127 = a1;
              unsigned __int8 v128 = "(empty)";
              goto LABEL_253;
            }
          }

          else if (v61)
          {
            uint64_t v65 = a1;
            int v64 = 0xFFFF;
            goto LABEL_206;
          }

          uint64_t v127 = a1;
          unsigned __int8 v128 = "(null)";
LABEL_253:
          sub_1001F4A7C(v127, v128);
LABEL_254:
          char v146 = 0;
LABEL_272:
          char v8 = 0;
          goto LABEL_273;
        }

        uint64_t v129 = a3++;
        uint64_t v130 = *v129;
        if ((v146 & 1) != 0)
        {
          uint64_t v131 = a3++;
          if (v130)
          {
            int v132 = *(_DWORD *)v131;
            if ((_WORD)v132)
            {
              sub_1001F494C(a1, v130, (unsigned __int16)v132);
LABEL_259:
              char v146 = 0;
              char v8 = 0;
              BYTE4(v144) = 0;
LABEL_273:
              uint64_t v13 = v6;
              goto LABEL_274;
            }

            uint64_t v133 = a1;
            uint64_t v130 = "(empty)";
LABEL_258:
            sub_1001F4A7C(v133, v130);
            goto LABEL_259;
          }
        }

        else if (v130)
        {
          uint64_t v133 = a1;
          goto LABEL_258;
        }

        uint64_t v133 = a1;
        uint64_t v130 = "(null)";
        goto LABEL_258;
      case 'u':
        if ((v144 & 0x100000000LL) != 0 || (v143 & 1) == 0)
        {
          uint64_t v124 = a3++;
          unint64_t v67 = *(unsigned int *)v124;
        }

        else
        {
          int v66 = (unint64_t *)a3++;
          unint64_t v67 = *v66;
        }

        if ((__int16)v7 >= 1)
        {
          int v125 = (unsigned __int16)v7;
          unint64_t v126 = v67;
          do
          {
            --v125;
            BOOL v122 = v126 > 9;
            v126 /= 0xAuLL;
          }

          while (v122);
          if (v125 >= 1) {
            sub_1001F4CCC(a1, v125);
          }
        }

        sub_1001F5DD4(a1, v67);
        goto LABEL_272;
      case 'x':
        if (!(_WORD)v7) {
          int v7 = 8;
        }
        int v68 = (unsigned int *)a3++;
        sub_1001F4D5C(a1, *v68, (__int16)v7);
        goto LABEL_272;
      default:
        if (v9 == 108)
        {
          unsigned int v123 = v4[2] - 98;
          if (v123 > 0x16) {
            return result;
          }
          if (((1 << v123) & 0x4A0007) != 0)
          {
            char v8 = 1;
            uint64_t v13 = v6;
          }

          else
          {
            if (v4[2] != 108 || v4[3] != 117) {
              return result;
            }
            char v8 = 1;
            uint64_t v13 = v6;
            char v143 = 1;
          }

          BYTE4(v144) = 1;
          goto LABEL_274;
        }

        if (v9 != 126) {
          return result;
        }
        uint64_t v28 = a3;
        uint64_t v29 = *a3;
        a3 += 2;
        if (v29)
        {
          unsigned int v30 = *((_DWORD *)v28 + 2);
          if (v30 <= 3)
          {
            int v31 = *((_DWORD *)v29 + 2);
            if (v31)
            {
              if (!*(void *)v29)
              {
                sub_1001EE2A0();
                int v31 = *((_DWORD *)v29 + 2);
              }

              if (v31 <= 0)
              {
                sub_1001EE2A0();
                LOWORD(v31) = *((_WORD *)v29 + 4);
              }

              uint64_t v32 = *(void *)v29;
              unsigned int v142 = (unsigned __int16)v31;
              if (v32) {
                BOOL v33 = (unsigned __int16)v31 == 0;
              }
              else {
                BOOL v33 = 1;
              }
              if (v33) {
                sub_1000E6B88( "/Library/Caches/com.apple.xbs/Sources/MobileBluetooth_base/Stack/corestack/support/oi_varstring.c",  388,  "((bs).__data != NULL) && ((bs).__trueSize > 0)");
              }
              if ((_WORD)v31)
              {
                unsigned int v34 = 0;
                unsigned int v35 = 0;
                unsigned int v140 = v30;
                unsigned __int16 v141 = v31;
                while (1)
                {
                  switch(v30)
                  {
                    case 0u:
                      sub_1001EE2A0();
                      goto LABEL_67;
                    case 1u:
                      unsigned int v36 = v35 + 1;
                      unsigned int v34 = *(unsigned __int8 *)(v32 + (unsigned __int16)v35);
                      if (v34 < 0xC0)
                      {
                        ++v35;
                        goto LABEL_67;
                      }

                      if (v34 <= 0xFC)
                      {
                        int v38 = 5;
                        for (unsigned int i = 252; i >= v34; unsigned int i = (2 * i) & 0xF8)
                          --v38;
                      }

                      else
                      {
                        unsigned int i = 252;
                        int v38 = 5;
                      }

                      if (v38 + (unsigned __int16)v36 > (int)v142)
                      {
                        unsigned int v139 = v36;
                        sub_1001EE2A0();
                        unsigned int v36 = v139;
                      }

                      v34 &= ~i;
                      if (!v38)
                      {
                        unsigned int v35 = v36;
                        goto LABEL_57;
                      }

                      int v49 = v38;
                      unsigned int v50 = v36;
                      unsigned int v30 = v140;
                      do
                      {
                        uint64_t v51 = (unsigned __int16)v50++;
                        unsigned int v34 = *(_BYTE *)(v32 + v51) & 0x3F | (v34 << 6);
                        --v49;
                      }

                      while (v49);
                      unsigned int v35 = v36 + v38;
                      goto LABEL_67;
                    case 2u:
                      unsigned int v39 = (unsigned __int16)v35 + 2;
                      if (v39 > v142) {
                        sub_1001EE2A0();
                      }
                      uint64_t v40 = (unsigned __int8 *)(v32 + (unsigned __int16)v35);
                      int v41 = *v40;
                      LODWORD(v40) = v40[1];
                      unsigned int v34 = v41 | ((_DWORD)v40 << 8);
                      unsigned int v42 = (unsigned __int16)(v35 + 2);
                      unsigned int v35 = v42 + 2;
                      if (v42 + 2 > v142) {
                        sub_1001EE2A0();
                      }
                      unsigned int v43 = (unsigned __int8 *)(v32 + v42);
                      int v44 = v43 + 1;
                      goto LABEL_55;
                    case 3u:
                      unsigned int v39 = (unsigned __int16)v35 + 2;
                      if (v39 > v142) {
                        sub_1001EE2A0();
                      }
                      int v45 = (unsigned __int8 *)(v32 + (unsigned __int16)v35);
                      int v46 = v45[1];
                      LODWORD(v45) = *v45;
                      unsigned int v34 = v46 | ((_DWORD)v45 << 8);
                      if ((v45 & 0xFC) == 0xD8)
                      {
                        unsigned int v47 = (unsigned __int16)(v35 + 2);
                        unsigned int v35 = v47 + 2;
                        if (v47 + 2 > v142) {
                          sub_1001EE2A0();
                        }
                        int v44 = (_BYTE *)(v32 + v47);
                        unsigned int v43 = v44 + 1;
LABEL_55:
                        unsigned int v34 = (*v43 | ((*v44 & 3) << 8) & 0x3FF | ((v34 & 0x3FF) << 10)) + 0x10000;
                        unsigned int v48 = *(unsigned __int16 *)(a1 + 2);
                        unsigned int v30 = v140;
                      }

                      else
                      {
LABEL_56:
                        unsigned int v35 = v39;
LABEL_57:
                        unsigned int v30 = v140;
LABEL_67:
                        unsigned int v48 = *(unsigned __int16 *)(a1 + 2);
                        if (v34 <= 0xFE)
                        {
                          if (!*(_WORD *)(a1 + 2) || (unsigned int v52 = *(unsigned __int16 *)(a1 + 4), v48 - 1 <= v52))
                          {
                            char v8 = *(_BYTE *)a1;
                            if (!*(_BYTE *)a1) {
                              goto LABEL_231;
                            }
                            if (!sub_1001F49EC(a1)) {
                              goto LABEL_230;
                            }
                            unsigned int v52 = *(unsigned __int16 *)(a1 + 4);
                          }

                          uint64_t v53 = *(void *)(a1 + 8);
                          *(_WORD *)(a1 + 4) = v52 + 1;
                          *(_BYTE *)(v53 + v52) = v34;
                          goto LABEL_83;
                        }
                      }

                      unsigned int v54 = v48 - 7;
                      if (v48 < 7 || (unsigned int v55 = *(unsigned __int16 *)(a1 + 4), v54 <= v55))
                      {
                        char v8 = *(_BYTE *)a1;
                        if (!*(_BYTE *)a1) {
                          goto LABEL_231;
                        }
                        if (!sub_1001F49EC(a1)) {
                          goto LABEL_230;
                        }
                        unsigned int v55 = *(unsigned __int16 *)(a1 + 4);
                      }

                      uint64_t v56 = *(void *)(a1 + 8);
                      *(_WORD *)(a1 + 4) = v55 + 1;
                      *(_BYTE *)(v56 + v55) = 92;
                      LOBYTE(v149) = 0;
                      uint64_t v148 = 0LL;
                      int v57 = -6;
                      unsigned int v58 = v34;
                      uint64_t v59 = &v149;
                      do
                      {
                        *((_BYTE *)v59 - 1) = a0123456789abcd_0[v58 & 0xF];
                        uint64_t v59 = (uint64_t *)((char *)v59 - 1);
                        v58 >>= 4;
                        BOOL v27 = __CFADD__(v57++, 1);
                      }

                      while (!v27);
LABEL_83:
                      break;
                    default:
                      goto LABEL_67;
                  }
                }
              }
            }
          }
        }

        else
        {
          sub_1001F4A7C(a1, "(null)");
        }

LABEL_240:
        char v8 = 0;
        uint64_t v13 = v6;
LABEL_274:
        uint64_t v6 = v13;
        unsigned int v4 = v10;
        break;
    }
  }

  unsigned int v12 = v9 - 33;
  uint64_t v13 = 1LL;
  char v8 = 1;
  switch(v12)
  {
    case 0u:
      int v14 = a3++;
      sub_1001F142C(*(unsigned int *)v14);
      int v16 = v15;
      goto LABEL_271;
    case 2u:
      sub_1001F4A7C(a1, "0x");
      goto LABEL_128;
    case 4u:
      char v8 = 0;
      uint64_t v69 = *(void *)(a1 + 8);
      uint64_t v70 = *(unsigned __int16 *)(a1 + 4);
      *(_WORD *)(a1 + 4) = v70 + 1;
      *(_BYTE *)(v69 + v70) = 37;
      goto LABEL_273;
    case 9u:
      uint64_t v71 = (unsigned __int8 **)a3++;
      int v72 = *v71;
      if (!*v71) {
        goto LABEL_168;
      }
      uint64_t v148 = 0LL;
      uint64_t v149 = 0LL;
      sub_1001BEF1C(&v148, v72, 0);
      if (*v72)
      {
        unint64_t v73 = 0LL;
        do
        {
          unsigned int v74 = *((unsigned __int8 *)&v148 + v73);
          char v151 = 0;
          int v75 = -2;
          int v76 = &v151;
          uint64_t v150 = 0LL;
          do
          {
            *--int v76 = a0123456789abcd_0[v74 & 0xF];
            v74 >>= 4;
            BOOL v27 = __CFADD__(v75++, 1);
          }

          while (!v27);
          sub_1001F4A7C(a1, v76);
          ++v73;
        }

        while (v73 < *v72);
      }

      goto LABEL_240;
    case 0xAu:
      goto LABEL_274;
    case 0xCu:
      char v145 = 0;
      goto LABEL_273;
    case 0xEu:
      int v77 = a3++;
      int v16 = *v77;
      if (*v77)
      {
        for (uint64_t j = v16 + 1; ; ++j)
        {
          int v79 = *(j - 1);
          if (v79 == 47 || v79 == 92)
          {
            int v16 = j;
          }

          else if (!*(j - 1))
          {
            goto LABEL_271;
          }
        }
      }

      sub_1001F4A7C(a1, "(null)");
      int v16 = 0LL;
      goto LABEL_271;
    case 0xFu:
      LOBYTE(v144) = ((__int16)v7 < 1) | v144;
      goto LABEL_128;
    case 0x10u:
      int v7 = (10 * v7) | 1;
      goto LABEL_273;
    case 0x11u:
      int v80 = 2;
      goto LABEL_127;
    case 0x12u:
      int v80 = 3;
      goto LABEL_127;
    case 0x13u:
      int v80 = 4;
      goto LABEL_127;
    case 0x14u:
      int v80 = 5;
      goto LABEL_127;
    case 0x15u:
      int v80 = 6;
      goto LABEL_127;
    case 0x16u:
      int v80 = 7;
      goto LABEL_127;
    case 0x17u:
      int v80 = 8;
      goto LABEL_127;
    case 0x18u:
      int v80 = 9;
LABEL_127:
      int v7 = v80 + 10 * v7;
LABEL_128:
      char v8 = 1;
      goto LABEL_273;
    case 0x19u:
      int v81 = a3++;
      int v82 = *v81;
      if (!*v81) {
        goto LABEL_168;
      }
      for (uint64_t k = 0LL; k != 6; ++k)
      {
        if (k) {
          sub_1001F4A7C(a1, ":");
        }
        unsigned int v84 = v82[k];
        LOBYTE(v149) = 0;
        int v85 = -2;
        uint64_t v86 = &v149;
        uint64_t v148 = 0LL;
        do
        {
          *((_BYTE *)v86 - 1) = a0123456789abcd_0[v84 & 0xF];
          uint64_t v86 = (uint64_t *)((char *)v86 - 1);
          v84 >>= 4;
          BOOL v27 = __CFADD__(v85++, 1);
        }

        while (!v27);
        sub_1001F4A7C(a1, v86);
      }

      goto LABEL_240;
    case 0x1Eu:
      char v146 = 1;
      goto LABEL_273;
    case 0x1Fu:
      uint64_t v87 = a3;
      uint64_t v88 = *a3;
      a3 += 2;
      if (!v88) {
        goto LABEL_168;
      }
      uint64_t v89 = *((unsigned int *)v87 + 2);
      if (v89 <= 0x8000)
      {
        if (!(_WORD)v7) {
          int v7 = 16;
        }
        if ((_DWORD)v89)
        {
          uint64_t v90 = 0LL;
          while (v90 != 160)
          {
            unsigned int v91 = v88[v90];
            LOBYTE(v149) = 0;
            int v92 = -2;
            uint64_t v93 = &v149;
            uint64_t v148 = 0LL;
            do
            {
              *((_BYTE *)v93 - 1) = a0123456789abcd_0[v91 & 0xF];
              uint64_t v93 = (uint64_t *)((char *)v93 - 1);
              v91 >>= 4;
              BOOL v27 = __CFADD__(v92++, 1);
            }

            while (!v27);
            sub_1001F4A7C(a1, v93);
            if (++v90 == v89) {
              goto LABEL_230;
            }
          }

          sub_1001F4A7C(a1, " ...");
LABEL_230:
          char v8 = 0;
LABEL_231:
          uint64_t v13 = v6;
          goto LABEL_274;
        }

        goto LABEL_240;
      }

      uint64_t result = 101LL;
      break;
    case 0x21u:
      uint64_t v94 = a3++;
      if (*(_DWORD *)v94) {
        int v16 = "TRUE";
      }
      else {
        int v16 = "FALSE";
      }
      goto LABEL_271;
    case 0x32u:
      goto LABEL_87;
    case 0x33u:
      uint64_t v95 = a3++;
      uint64_t v96 = *v95;
      uint64_t v148 = 0LL;
      if (!v96)
      {
        uint64_t v96 = (char *)&v148;
        sub_1000B0400((uint64_t)&v148);
      }

      int v97 = *(_DWORD *)v96;
      unint64_t v98 = *((__int16 *)v96 + 2);
      uint64_t v99 = ".";
      if (v98 < 0x64) {
        uint64_t v99 = ".0";
      }
      if (v98 >= 0xA) {
        uint64_t v100 = (char *)v99;
      }
      else {
        uint64_t v100 = ".00";
      }
      sub_1001F5DD4(a1, v97 & 0x1FFF);
      sub_1001F4A7C(a1, v100);
      unint64_t v101 = v98;
      uint64_t v102 = a1;
      goto LABEL_226;
    case 0x3Au:
      uint64_t v103 = (int *)a3++;
      int v104 = *v103;
      if (v104 > 88)
      {
        switch(v104)
        {
          case 'b':
            int v16 = "\x1B[0;34m";
            break;
          case 'c':
            int v16 = "\x1B[0;36m";
            break;
          case 'd':
LABEL_255:
            int v16 = "\x1B[1;30m";
            break;
          case 'e':
          case 'f':
          case 'h':
          case 'i':
          case 'j':
          case 'k':
          case 'n':
          case 'o':
          case 'p':
          case 'q':
            goto LABEL_260;
          case 'g':
            int v16 = "\x1B[0;32m";
            break;
          case 'l':
LABEL_256:
            int v16 = "\x1B[0;37m";
            break;
          case 'm':
            int v16 = "\x1B[0;35m";
            break;
          case 'r':
            int v16 = "\x1B[0;31m";
            break;
          default:
            if (v104 == 89)
            {
              int v16 = "\x1B[1;33m";
            }

            else if (v104 == 121)
            {
              int v16 = "\x1B[0;33m";
            }

            else
            {
LABEL_260:
              int v16 = "\x1B[0;39;49m";
            }

            break;
        }
      }

      else
      {
        switch(v104)
        {
          case 'B':
            int v16 = "\x1B[1;34m";
            goto LABEL_271;
          case 'C':
            int v16 = "\x1B[1;36m";
            goto LABEL_271;
          case 'D':
            goto LABEL_255;
          case 'E':
          case 'F':
          case 'H':
          case 'I':
          case 'J':
          case 'K':
          case 'N':
          case 'O':
          case 'P':
          case 'Q':
            goto LABEL_260;
          case 'G':
            int v16 = "\x1B[1;32m";
            goto LABEL_271;
          case 'L':
            goto LABEL_256;
          case 'M':
            int v16 = "\x1B[1;35m";
            goto LABEL_271;
          case 'R':
            int v16 = "\x1B[1;31m";
            goto LABEL_271;
          default:
            if (v104 == 48)
            {
              int v16 = "\x1B[0;30m";
            }

            else
            {
              if (v104 != 87) {
                goto LABEL_260;
              }
              int v16 = "\x1B[1;37m";
            }

            break;
        }
      }

      goto LABEL_271;
    case 0x3Du:
      uint64_t v105 = (uint64_t *)a3++;
      if (*v105)
      {
        sub_1001093EC(a1, *v105, 0);
      }

      else
      {
LABEL_168:
        int v16 = "(null)";
LABEL_271:
        sub_1001F4A7C(a1, v16);
      }

      goto LABEL_272;
    case 0x40u:
      uint64_t v106 = a3++;
      uint64_t v107 = *v106;
      if ((v146 & 1) == 0)
      {
        if (v107)
        {
          sub_1001F4B08(a1, v107);
          goto LABEL_254;
        }

uint64_t sub_1001F5DD4(uint64_t a1, unint64_t a2)
{
  int v3 = (char *)&v6 + 1;
  __int16 v6 = 0;
  do
  {
    *--int v3 = a0123456789abcd_0[a2 % 0xA];
    BOOL v4 = a2 > 9;
    a2 /= 0xAuLL;
  }

  while (v4);
  return sub_1001F4A7C(a1, v3);
}

uint64_t sub_1001F5E64(uint64_t result, unsigned __int16 *a2, int a3)
{
  uint64_t v10 = a2;
  if (a2)
  {
    int v3 = a3;
    uint64_t v5 = result;
    unint64_t v6 = (unint64_t)&a2[v3];
    do
    {
      uint64_t v7 = *(void *)(v5 + 8);
      uint64_t v9 = v7 + *(unsigned __int16 *)(v5 + 4);
      __int16 v8 = *(_WORD *)(v5 + 2) + v7 - 1;
      uint64_t result = sub_10009C354((unint64_t *)&v10, v6, &v9, *(unsigned __int16 *)(v5 + 2) + v7 - 1, 0);
      *(_WORD *)(v5 + 4) = ~v8 + *(_WORD *)(v5 + 2) + v9;
      if ((_DWORD)result != 2) {
        break;
      }
      if (!*(_BYTE *)v5) {
        break;
      }
      uint64_t result = sub_1001F49EC(v5);
    }

    while ((result & 1) != 0);
  }

  return result;
}

uint64_t sub_1001F5F28( uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9)
{
  return sub_1001F4EE4(a1, a2, &a9);
}

uint64_t sub_1001F5F50(uint64_t a1)
{
  uint64_t v1 = *(void *)(a1 + 8);
  if (!v1) {
    return 0LL;
  }
  unsigned int v3 = *(unsigned __int16 *)(a1 + 4);
  if (v3 >= *(unsigned __int16 *)(a1 + 2))
  {
    sub_1001EE2A0();
    uint64_t v1 = *(void *)(a1 + 8);
    unsigned int v3 = *(unsigned __int16 *)(a1 + 4);
  }

  *(_BYTE *)(v1 + v3) = 0;
  return *(void *)(a1 + 8);
}

const char *sub_1001F5FA0()
{
  return "5.0";
}

const char *sub_1001F5FAC()
{
  return "Copyright (c) 2017 Apple Inc. All rights reserved";
}

uint64_t sub_1001F5FB8(void *a1, _WORD *a2)
{
  *a2 = 0;
  *a1 = 0LL;
  return 102LL;
}

uint64_t sub_1001F5FC8(dispatch_queue_s *a1, uint64_t (*a2)(void, void))
{
  kern_return_t v9;
  io_object_t notification;
  if (a1 && a2)
  {
    BOOL v4 = IOServiceMatching("AppleBluetoothModule");
    io_service_t MatchingService = IOServiceGetMatchingService(kIOMainPortDefault, v4);
    if (MatchingService)
    {
      io_service_t v6 = MatchingService;
      IONotificationPortRef v7 = IONotificationPortCreate(kIOMainPortDefault);
      if (v7)
      {
        __int16 v8 = v7;
        notification = 0;
        dispatch_retain(a1);
        off_1008EF8C8 = a2;
        IONotificationPortSetDispatchQueue(v8, a1);
        uint64_t v9 = IOServiceAddInterestNotification( v8,  v6,  "IOGeneralInterest",  (IOServiceInterestCallback)sub_1001F60D8,  0LL,  &notification);
        if (!v9) {
          return 1LL;
        }
        sub_1001EE0E4("Could not add interest notification on service: %#x\n", v9);
        IONotificationPortDestroy(v8);
        dispatch_release(a1);
      }

      else
      {
        sub_1001EE0E4("Cannot create notification port\n");
      }
    }

    else
    {
      sub_1001EE0E4("Cannot find AppleBluetoothModule service\n");
    }
  }

  else
  {
    sub_1001EE0E4("Invalid parameter\n");
  }

  return 0LL;
}

uint64_t sub_1001F60D8(uint64_t a1, uint64_t a2, int a3, unsigned int *a4)
{
  if (a3 == -469794804 && a4 != 0LL) {
    return off_1008EF8C8(*a4, *((void *)a4 + 1));
  }
  return result;
}

void *sub_1001F6104(unsigned __int16 *a1, uint64_t a2)
{
  uint64_t result = (void *)sub_100172A98((uint64_t)sub_1001F6188, *a1, 0LL, a2, 0);
  if (*(_WORD *)(a2 + 4))
  {
    uint64_t v5 = *((void *)a1 + 14);
    io_service_t v6 = sub_1000B1814(8uLL);
    sub_1001EF2D8(v6, a2, 0);
    return sub_1001EC124(v5, (uint64_t)v6, 8LL);
  }

  return result;
}

void sub_1001F6188(int a1, void *a2, uint64_t a3, uint64_t a4)
{
  io_service_t v6 = sub_1000B69C0(a1);
  sub_1000B6BF8((uint64_t)v6, a2, a4);
  if (sub_1001EC434(*((void *)v6 + 14)))
  {
    IONotificationPortRef v7 = (void *)sub_1001EC324(*((void *)v6 + 14), 0);
    sub_1001F6104(v6, *v7);
    sub_1000B1838(v7);
  }

uint64_t sub_1001F6200(uint64_t a1)
{
  if (!a1) {
    return 114LL;
  }
  uint64_t v2 = *(void *)(a1 + 112);
  if (!v2) {
    return 114LL;
  }
  if (sub_1001EC434(v2))
  {
    uint64_t v3 = *(void *)(a1 + 112);
    uint64_t v4 = *(void *)(a1 + 40);
    uint64_t v5 = sub_1000B1814(8uLL);
    sub_1001EF2D8(v5, v4, 0);
    sub_1001EC1DC(v3, (uint64_t)v5, 8LL);
    sub_1001EF69C(*(void **)(a1 + 40));
    uint64_t result = 0LL;
    *(void *)(a1 + 40) = 0LL;
  }

  else
  {
    sub_1001F6104((unsigned __int16 *)a1, *(void *)(a1 + 40));
    return 0LL;
  }

  return result;
}

uint64_t sub_1001F629C(uint64_t a1, uint64_t a2, int a3, _WORD *a4, uint64_t a5, char a6)
{
  uint64_t v12 = sub_10017A6F0((unsigned __int16)*a4, (uint64_t)sub_1001F64A0);
  if ((_DWORD)v12)
  {
    uint64_t v13 = v12;
    if (sub_1000A86F0())
    {
      sub_1001EE134((uint64_t)"OI_L2CAP_Register failed with result %!", v14, v15, v16, v17, v18, v19, v20, v13);
      uint64_t v21 = (os_log_s *)sub_100086554(0x18u);
      if (os_log_type_enabled(v21, OS_LOG_TYPE_ERROR)) {
        sub_100657858();
      }
    }
  }

  else
  {
    if (sub_1000A86F0())
    {
      sub_1001EE134((uint64_t)"Registered PSM %d", v22, v23, v24, v25, v26, v27, v28, (unsigned __int16)*a4);
      uint64_t v29 = (os_log_s *)sub_100086554(0x18u);
      if (os_log_type_enabled(v29, OS_LOG_TYPE_INFO))
      {
        *(_DWORD *)__int128 buf = 136446210;
        int v41 = sub_1001EDDCC();
        _os_log_impl((void *)&_mh_execute_header, v29, OS_LOG_TYPE_INFO, " %{public}s", buf, 0xCu);
      }
    }

    unsigned int v30 = sub_1000B1814(0xD8uLL);
    v30[18] = a2;
    *((_DWORD *)v30 + 38) = a3;
    *((_WORD *)v30 + 100) = 0;
    *((_DWORD *)v30 + 51) = 0;
    *((_WORD *)v30 + 98) = *a4;
    if (a1)
    {
      v30[17] = *(void *)(a1 + 8);
      *((_WORD *)v30 + 64) = *(_WORD *)a1;
    }

    v30[23] = a5;
    *((_BYTE *)v30 + 192) = a6;
    v30[8] = 0LL;
    v30[1] = 0LL;
    uint64_t v13 = sub_1000B6B34((uint64_t)v30);
    if ((_DWORD)v13)
    {
      if (sub_1000A86F0())
      {
        sub_1001EE134((uint64_t)"AddConnection failed with result %!", v31, v32, v33, v34, v35, v36, v37, v13);
        int v38 = (os_log_s *)sub_100086554(0x18u);
        if (os_log_type_enabled(v38, OS_LOG_TYPE_ERROR)) {
          sub_100657858();
        }
      }
    }

    else
    {
      ++dword_1008F6F68;
    }
  }

  return v13;
}

void sub_1001F64A0(int a1, int *a2, unsigned int a3)
{
  uint64_t v5 = sub_1000B6A4C(a1);
  if (*(_DWORD *)(v5 + 204))
  {
    if (sub_1000A86F0())
    {
      sub_1001EE134((uint64_t)"Rejecting the L2CAP connection", v6, v7, v8, v9, v10, v11, v12, v27);
      uint64_t v13 = (os_log_s *)sub_100086554(0x18u);
      if (os_log_type_enabled(v13, OS_LOG_TYPE_ERROR)) {
        sub_100657858();
      }
    }

    sub_100174B2C(0LL, 0LL, 0LL, a3, 0LL, 0, 0LL);
  }

  else
  {
    uint64_t v14 = v5;
    uint64_t v15 = *(void **)(v5 + 8);
    if (v15) {
      sub_1000B1838(v15);
    }
    *(void *)(v14 + 112) = 0LL;
    *(_OWORD *)(v14 + 80) = 0u;
    *(_OWORD *)(v14 + 96) = 0u;
    *(_OWORD *)(v14 + 48) = 0u;
    *(_OWORD *)(v14 + 64) = 0u;
    *(_OWORD *)(v14 + 16) = 0u;
    *(_OWORD *)(v14 + 32) = 0u;
    *(_OWORD *)uint64_t v14 = 0u;
    int v16 = *a2;
    *(_WORD *)(v14 + 108) = *((_WORD *)a2 + 2);
    *(_DWORD *)(v14 + 104) = v16;
    *(_WORD *)uint64_t v14 = a3;
    *(_DWORD *)(v14 + 4) = 1;
    *(void *)(v14 + 112) = sub_1001EC038(0LL, 0LL);
    uint64_t v17 = sub_100174B2C( (uint64_t)sub_1001F6674,  (uint64_t)sub_1001F6870,  (uint64_t)sub_1001F698C,  a3,  (uint64_t)&unk_100886BF0,  1,  *(void *)(v14 + 184));
    if ((_DWORD)v17)
    {
      uint64_t v18 = v17;
      if (sub_1000A86F0())
      {
        sub_1001EE134((uint64_t)"OI_L2CAP_Accept failed with result %!", v19, v20, v21, v22, v23, v24, v25, v18);
        uint64_t v26 = (os_log_s *)sub_100086554(0x18u);
        if (os_log_type_enabled(v26, OS_LOG_TYPE_ERROR)) {
          sub_100657858();
        }
      }
    }

    else
    {
      *(_DWORD *)(v14 + 204) = 1;
    }
  }

uint64_t sub_1001F6614(int a1)
{
  return sub_10017A8B8(a1);
}

uint64_t sub_1001F6638(unsigned int a1, _WORD *a2)
{
  uint64_t v3 = sub_1000B6BC4(a1);
  if (!v3) {
    return 1709LL;
  }
  uint64_t v4 = v3;
  uint64_t result = 0LL;
  *a2 = *(_WORD *)(v4 + 196);
  return result;
}

void sub_1001F6674(int a1, unsigned int a2, unsigned __int16 a3, uint64_t a4)
{
  uint64_t v7 = sub_1000B69C0(a1);
  uint64_t v8 = v7;
  v42[0] = 0LL;
  if ((_DWORD)a4)
  {
    if (sub_1000A86F0())
    {
      sub_1001EE134((uint64_t)"L2CAPConnectCB failed with result %!", v9, v10, v11, v12, v13, v14, v15, a4);
      int v16 = (os_log_s *)sub_100086554(0x18u);
      if (os_log_type_enabled(v16, OS_LOG_TYPE_ERROR)) {
        sub_100657858();
      }
    }

    *((_DWORD *)v8 + 51) = 0;
    uint64_t v17 = (void *)*((void *)v8 + 1);
    if (v17)
    {
      sub_1000B1838(v17);
      *((void *)v8 + 1) = 0LL;
    }
  }

  else
  {
    *((_DWORD *)v7 + 51) = 2;
    v7[36] = a3;
    v7[38] = a3;
    v7[37] = a2;
    uint64_t v18 = sub_1000B1814(a2);
    uint64_t v20 = v8 + 88;
    int v19 = *((_DWORD *)v8 + 44);
    *((void *)v8 + 1) = v18;
    if (v19)
    {
      if (sub_1000A86F0())
      {
        sub_1001EE134((uint64_t)"Cancelling timeout countdown", v21, v22, v23, v24, v25, v26, v27, v41);
        uint64_t v28 = (os_log_s *)sub_100086554(0x18u);
        if (os_log_type_enabled(v28, OS_LOG_TYPE_INFO))
        {
          *(_DWORD *)__int128 buf = 136446210;
          int v44 = sub_1001EDDCC();
          _os_log_impl((void *)&_mh_execute_header, v28, OS_LOG_TYPE_INFO, " %{public}s", buf, 0xCu);
        }
      }

      sub_1001EEB14(*v20);
      *uint64_t v20 = 0;
    }

    BOOL v29 = *((_DWORD *)v8 + 38) != 0;
    int v30 = *(unsigned __int16 *)(sub_1001EDBA0(0x18u) + 2LL * v29);
    v42[1] = v8 + 104;
    LOWORD(v42[0]) = 2;
    uint64_t v31 = sub_1001EE6E8((uint64_t)sub_1001F69B8, v42, v30, (int *)v8 + 44);
    if ((_DWORD)v31)
    {
      uint64_t v32 = v31;
      if (sub_1000A86F0())
      {
        sub_1001EE134( (uint64_t)"OI_Dispatch_RegisterTimedFunc failed with result %!",  v33,  v34,  v35,  v36,  v37,  v38,  v39,  v32);
        uint64_t v40 = (os_log_s *)sub_100086554(0x18u);
        if (os_log_type_enabled(v40, OS_LOG_TYPE_ERROR)) {
          sub_100657858();
        }
      }
    }
  }

void sub_1001F6870(unsigned int a1)
{
  uint64_t v2 = sub_1000B69C0(a1);
  if (v2)
  {
    uint64_t v3 = (uint64_t)v2;
    sub_1001EC070(*((void **)v2 + 14));
    *(void *)__int128 buf = 0LL;
    sub_1000B7DCC(v3);
  }

  else if (sub_1000A86F0())
  {
    sub_1001EE134( (uint64_t)"IGNORING L2CAPDisconnectCB as connection was NULL (cid = %d, reason = %!)",  v4,  v5,  v6,  v7,  v8,  v9,  v10,  a1);
    uint64_t v11 = (os_log_s *)sub_100086554(0x18u);
    if (os_log_type_enabled(v11, OS_LOG_TYPE_DEFAULT))
    {
      *(_DWORD *)__int128 buf = 136446210;
      *(void *)&uint8_t buf[4] = sub_1001EDDCC();
      _os_log_impl((void *)&_mh_execute_header, v11, OS_LOG_TYPE_DEFAULT, " %{public}s", buf, 0xCu);
    }
  }

void sub_1001F698C(int a1, void *a2, size_t a3)
{
  uint64_t v5 = sub_1000B69C0(a1);
  sub_1000B7E98((uint64_t)v5, a2, a3);
}

uint64_t sub_1001F69B8(uint64_t a1)
{
  unsigned int v1 = **(unsigned __int16 **)(a1 + 8);
  uint64_t v2 = sub_1000B6BC4(v1);
  if (*(_DWORD *)(v2 + 204) == 5) {
    sub_1001EE2A0();
  }
  *(_DWORD *)(v2 + 176) = 0;
  return sub_1000B8A34(v1);
}

void *sub_1001F69FC(uint64_t a1)
{
  if (sub_1000A86F0())
  {
    sub_1001EE134((uint64_t)"HandsfreeAoS_Register", v2, v3, v4, v5, v6, v7, v8, *(uint64_t *)v11);
    uint64_t v9 = (os_log_s *)sub_100086554(0x5Au);
    if (os_log_type_enabled(v9, OS_LOG_TYPE_DEFAULT))
    {
      *(_DWORD *)uint64_t v11 = 136446210;
      *(void *)&v11[4] = sub_1001EDDCC();
      _os_log_impl((void *)&_mh_execute_header, v9, OS_LOG_TYPE_DEFAULT, " %{public}s", v11, 0xCu);
    }
  }

  uint64_t result = calloc(1uLL, 0x88uLL);
  qword_1008EF8D0 = (uint64_t)result;
  result[16] = a1;
  return result;
}

uint64_t sub_1001F6AD0(uint64_t a1)
{
  if (sub_1000A86F0())
  {
    sub_1001EE134((uint64_t)"HandsfreeAoS_Connect - addr:%:", v2, v3, v4, v5, v6, v7, v8, a1);
    uint64_t v9 = (os_log_s *)sub_100086554(0x5Au);
    if (os_log_type_enabled(v9, OS_LOG_TYPE_DEFAULT))
    {
      *(_DWORD *)__int128 buf = 136446210;
      uint64_t v22 = sub_1001EDDCC();
      _os_log_impl((void *)&_mh_execute_header, v9, OS_LOG_TYPE_DEFAULT, " %{public}s", buf, 0xCu);
    }
  }

  if (sub_1001F6C3C(a1)) {
    return 126LL;
  }
  uint64_t v12 = (_WORD *)(sub_1001F6C88(a1) + 128);
  uint64_t v10 = sub_100174028( (uint64_t)sub_1001F6D04,  (uint64_t)sub_1001F6DF4,  (uint64_t)sub_1001F6EFC,  4099,  a1,  (uint64_t)&xmmword_1006BF0F8,  v12,  (uint64_t)&unk_100886C10);
  if ((_DWORD)v10)
  {
    sub_1001F6F30((unsigned __int16)*v12);
    if (sub_1000A86F0())
    {
      sub_1001EE134((uint64_t)"L2CAP connection attempt failed %!", v13, v14, v15, v16, v17, v18, v19, v10);
      uint64_t v20 = (os_log_s *)sub_100086554(0x5Au);
      if (os_log_type_enabled(v20, OS_LOG_TYPE_ERROR)) {
        sub_100657858();
      }
    }
  }

  return v10;
}

uint64_t sub_1001F6C3C(uint64_t a1)
{
  uint64_t v1 = 0LL;
  while (1)
  {
    uint64_t v2 = *(void *)(qword_1008EF8D0 + v1);
    if (v2)
    {
      uint64_t v3 = *(int **)(v2 + 8);
      int v4 = *v3;
      int v5 = *((unsigned __int16 *)v3 + 2);
    }

    v1 += 8LL;
    if (v1 == 128) {
      return 0LL;
    }
  }

  return v2;
}

uint64_t sub_1001F6C88(uint64_t a1)
{
  uint64_t v2 = 0LL;
  while (*(void *)(qword_1008EF8D0 + v2))
  {
    v2 += 8LL;
    if (v2 == 128) {
      return 0LL;
    }
  }

  int v4 = calloc(1uLL, 0x88uLL);
  *(void *)(qword_1008EF8D0 + v2) = v4;
  v4[1] = a1;
  uint64_t v5 = sub_10012D890(a1);
  uint64_t v6 = qword_1008EF8D0;
  **(void **)(qword_1008EF8D0 + v2) = v5;
  return *(void *)(v6 + v2);
}

void sub_1001F6D04(unsigned int a1, uint64_t a2, uint64_t a3, int a4)
{
  if (sub_1000A86F0())
  {
    sub_1001EE134((uint64_t)"L2CAPConnectCB - cid:%d inMTU:%d outMTU:%d result:%!", v6, v7, v8, v9, v10, v11, v12, a1);
    uint64_t v13 = (os_log_s *)sub_100086554(0x5Au);
    if (os_log_type_enabled(v13, OS_LOG_TYPE_DEFAULT))
    {
      *(_DWORD *)__int128 buf = 136446210;
      uint64_t v15 = sub_1001EDDCC();
      _os_log_impl((void *)&_mh_execute_header, v13, OS_LOG_TYPE_DEFAULT, " %{public}s", buf, 0xCu);
    }
  }

  if (a4) {
    sub_1001F6F30(a1);
  }
}

void sub_1001F6DF4(unsigned int a1)
{
  if (sub_1000A86F0())
  {
    sub_1001EE134((uint64_t)"L2CAPDisconnectCB - cid:%d reason:%!", v2, v3, v4, v5, v6, v7, v8, a1);
    uint64_t v9 = (os_log_s *)sub_100086554(0x5Au);
    if (os_log_type_enabled(v9, OS_LOG_TYPE_DEFAULT))
    {
      *(_DWORD *)__int128 buf = 136446210;
      uint64_t v14 = sub_1001EDDCC();
      _os_log_impl((void *)&_mh_execute_header, v9, OS_LOG_TYPE_DEFAULT, " %{public}s", buf, 0xCu);
    }
  }

  for (uint64_t i = 0LL; ; i += 8LL)
  {
    uint64_t v11 = *(void *)(qword_1008EF8D0 + i);
    if (v11)
    {
    }
  }

  uint64_t v12 = sub_1000F63EC(*(void *)v11);
  sub_1000F5F04(v12, 0);
  sub_1001F6F30(a1);
}

uint64_t sub_1001F6EFC(int a1)
{
  for (uint64_t i = 0LL; ; i += 8LL)
  {
    uint64_t v2 = *(void *)(qword_1008EF8D0 + i);
    if (v2)
    {
    }
  }

  return (*(uint64_t (**)(void))(qword_1008EF8D0 + 128))(*(void *)(v2 + 8));
}

void sub_1001F6F30(int a1)
{
  uint64_t v1 = 0LL;
  uint64_t v2 = qword_1008EF8D0;
  while (1)
  {
    uint64_t v3 = *(void *)(qword_1008EF8D0 + v1);
    if (v3)
    {
    }

    v1 += 8LL;
    if (v1 == 128) {
      return;
    }
  }

  free(*(void **)(qword_1008EF8D0 + v1));
  *(void *)(v2 + v1) = 0LL;
}

void sub_1001F6F84(uint64_t a1, char *a2, size_t a3)
{
  uint64_t v6 = sub_1001F6C3C(a1);
  if (v6)
  {
    uint64_t v7 = v6;
    uint64_t v8 = (unsigned __int8 *)(v6 + 16);
    uint64_t v9 = sub_1001EF520(v6 + 16, 1u);
    if ((_DWORD)v9)
    {
      uint64_t v10 = v9;
      if (sub_1000A86F0())
      {
        sub_1001EE134((uint64_t)"Failed to initialize mbuf - result:%!", v11, v12, v13, v14, v15, v16, v17, v10);
        uint64_t v18 = (os_log_s *)sub_100086554(0x5Au);
        if (os_log_type_enabled(v18, OS_LOG_TYPE_ERROR)) {
          sub_100657858();
        }
      }
    }

    uint64_t v19 = sub_1001EFB10(v8, a2, a3, 2u);
    if ((_DWORD)v19)
    {
      uint64_t v20 = v19;
      if (sub_1000A86F0())
      {
        sub_1001EE134((uint64_t)"Failed to append mbuf - result:%!", v21, v22, v23, v24, v25, v26, v27, v20);
        uint64_t v28 = (os_log_s *)sub_100086554(0x5Au);
        if (os_log_type_enabled(v28, OS_LOG_TYPE_ERROR)) {
          sub_100657858();
        }
      }
    }

    uint64_t v29 = sub_100172A98(0LL, *(unsigned __int16 *)(v7 + 128), 0LL, (uint64_t)v8, 0);
    if ((_DWORD)v29)
    {
      uint64_t v30 = v29;
      if ((_DWORD)v29 != 412)
      {
        if (sub_1000A86F0())
        {
          sub_1001EE134((uint64_t)"Failed to send HandsfreeAoS data - result:%!", v31, v32, v33, v34, v35, v36, v37, v30);
          uint64_t v38 = (os_log_s *)sub_100086554(0x5Au);
          if (os_log_type_enabled(v38, OS_LOG_TYPE_ERROR)) {
            goto LABEL_17;
          }
        }
      }
    }
  }

  else if (sub_1000A86F0())
  {
    sub_1001EE134( (uint64_t)"Trying to send audio data to nonexistent connection - addr:%: length:%d",  v39,  v40,  v41,  v42,  v43,  v44,  v45,  a1);
    int v46 = (os_log_s *)sub_100086554(0x5Au);
    if (os_log_type_enabled(v46, OS_LOG_TYPE_ERROR)) {
LABEL_17:
    }
      sub_100657858();
  }

uint64_t sub_1001F713C(uint64_t a1)
{
  return *(unsigned __int16 *)(sub_1001F6C3C(a1) + 128);
}

uint64_t sub_1001F7154(uint64_t a1)
{
  if (sub_1000A86F0())
  {
    sub_1001EE134((uint64_t)"HandsfreeAoS_Disconnect - addr:%:", v2, v3, v4, v5, v6, v7, v8, a1);
    uint64_t v9 = (os_log_s *)sub_100086554(0x5Au);
    if (os_log_type_enabled(v9, OS_LOG_TYPE_DEFAULT))
    {
      *(_DWORD *)__int128 buf = 136446210;
      uint64_t v22 = sub_1001EDDCC();
      _os_log_impl((void *)&_mh_execute_header, v9, OS_LOG_TYPE_DEFAULT, " %{public}s", buf, 0xCu);
    }
  }

  uint64_t v10 = sub_1001F6C3C(a1);
  uint64_t v11 = sub_1001759FC(*(unsigned __int16 *)(v10 + 128), 436LL);
  if ((_DWORD)v11)
  {
    if (sub_1000A86F0())
    {
      sub_1001EE134((uint64_t)"HandsfreeAoS failed to disconnect, reason %!", v12, v13, v14, v15, v16, v17, v18, v11);
      uint64_t v19 = (os_log_s *)sub_100086554(0x5Au);
      if (os_log_type_enabled(v19, OS_LOG_TYPE_ERROR)) {
        sub_100657858();
      }
    }
  }

  return v11;
}

uint64_t sub_1001F7278()
{
  if (sub_1000A86F0())
  {
    sub_1001EE134((uint64_t)"HandsfreeAoS_Deregister", v0, v1, v2, v3, v4, v5, v6, *(uint64_t *)v11);
    uint64_t v7 = (os_log_s *)sub_100086554(0x5Au);
    if (os_log_type_enabled(v7, OS_LOG_TYPE_DEFAULT))
    {
      *(_DWORD *)uint64_t v11 = 136446210;
      *(void *)&v11[4] = sub_1001EDDCC();
      _os_log_impl((void *)&_mh_execute_header, v7, OS_LOG_TYPE_DEFAULT, " %{public}s", v11, 0xCu);
    }
  }

  if (*(void *)qword_1008EF8D0) {
    return 126LL;
  }
  uint64_t v9 = 1LL;
  while (v9 != 16)
  {
    if (*(void *)(qword_1008EF8D0 + 8 * v9++))
    {
      break;
    }
  }

  free((void *)qword_1008EF8D0);
  uint64_t result = 0LL;
  qword_1008EF8D0 = 0LL;
  return result;
}

uint64_t sub_1001F7378(uint64_t a1)
{
  if (!qword_1008EF8D0) {
    return 0LL;
  }
  uint64_t v1 = 0LL;
  while (1)
  {
    uint64_t v2 = *(void *)(qword_1008EF8D0 + v1);
    if (v2)
    {
      uint64_t v3 = *(int **)(v2 + 8);
      int v4 = *v3;
      int v5 = *((unsigned __int16 *)v3 + 2);
    }

    v1 += 8LL;
    if (v1 == 128) {
      return 0LL;
    }
  }

  return *(unsigned __int16 *)(v2 + 128);
}

uint64_t sub_1001F73CC(uint64_t a1, _WORD *a2)
{
  if (sub_1000A86F0())
  {
    sub_1001EE134((uint64_t)"HandsfreeAoS_FastConnect_CreateChannel - addr:%:", v4, v5, v6, v7, v8, v9, v10, a1);
    uint64_t v11 = (os_log_s *)sub_100086554(0x5Au);
    if (os_log_type_enabled(v11, OS_LOG_TYPE_DEFAULT))
    {
      *(_DWORD *)__int128 buf = 136446210;
      *(void *)&uint8_t buf[4] = sub_1001EDDCC();
      _os_log_impl((void *)&_mh_execute_header, v11, OS_LOG_TYPE_DEFAULT, " %{public}s", buf, 0xCu);
    }
  }

  if (sub_1001F6C3C(a1)) {
    return 126LL;
  }
  *(_OWORD *)__int128 buf = xmmword_1006BF0F8;
  __int128 v23 = unk_1006BF108;
  uint64_t v12 = sub_100173838( 4099,  (uint64_t)buf,  a1,  (uint64_t)sub_1001F6D04,  (uint64_t)sub_1001F6DF4,  (uint64_t)sub_1001F6EFC,  a2,  (uint64_t)&unk_100886C10);
  if ((_DWORD)v12)
  {
    if (sub_1000A86F0())
    {
      sub_1001EE134( (uint64_t)"HandsfreeAoS_FastConnect_CreateChannel error creating L2CAP channel, reason %!",  v13,  v14,  v15,  v16,  v17,  v18,  v19,  v12);
      uint64_t v20 = (os_log_s *)sub_100086554(0x5Au);
      if (os_log_type_enabled(v20, OS_LOG_TYPE_ERROR)) {
        sub_100657858();
      }
    }

    sub_1001EE2A0();
  }

  *(_WORD *)(sub_1001F6C88(a1) + 128) = *a2;
  return v12;
}

void sub_1001F7554(uint64_t a1, unsigned int a2)
{
  if (sub_1000A86F0())
  {
    sub_1001EE134((uint64_t)"HandsfreeAoS_FastConnect_DestroyChannel", v4, v5, v6, v7, v8, v9, v10, v38);
    uint64_t v11 = (os_log_s *)sub_100086554(0x5Au);
    if (os_log_type_enabled(v11, OS_LOG_TYPE_DEFAULT))
    {
      *(_DWORD *)__int128 buf = 136446210;
      *(void *)&uint8_t buf[4] = sub_1001EDDCC();
      _os_log_impl((void *)&_mh_execute_header, v11, OS_LOG_TYPE_DEFAULT, " %{public}s", buf, 0xCu);
    }
  }

  uint64_t v12 = sub_1001F6C3C(a1);
  if (v12)
  {
    sub_1001F6F30(*(unsigned __int16 *)(v12 + 128));
  }

  else if (sub_1000A86F0())
  {
    sub_1001EE134( (uint64_t)"HandsfreeAoS_FastConnect_DestroyChannel no connection exists for addr:%:",  v13,  v14,  v15,  v16,  v17,  v18,  v19,  a1);
    uint64_t v20 = (os_log_s *)sub_100086554(0x5Au);
    if (os_log_type_enabled(v20, OS_LOG_TYPE_ERROR)) {
      sub_100657858();
    }
  }

  *(void *)__int128 buf = 0LL;
  if (sub_100171EC4(a2, (uint64_t *)buf) || !*(void *)buf)
  {
    if (sub_1000A86F0())
    {
      sub_1001EE134( (uint64_t)"HandsfreeAoS_FastConnect_DestroyChannel failed to get channel, cid:%d",  v22,  v23,  v24,  v25,  v26,  v27,  v28,  a2);
      uint64_t v29 = (os_log_s *)sub_100086554(0x5Au);
      if (os_log_type_enabled(v29, OS_LOG_TYPE_ERROR)) {
LABEL_18:
      }
        sub_100657858();
    }
  }

  else
  {
    sub_1001734D8(*(uint64_t *)buf);
    uint64_t v21 = sub_10012D890(a1);
    if (v21)
    {
      sub_10011286C(v21);
      return;
    }

    if (sub_1000A86F0())
    {
      sub_1001EE134( (uint64_t)"HandsfreeAoS_FastConnect_DestroyChannel NULL Handle",  v30,  v31,  v32,  v33,  v34,  v35,  v36,  v38);
      uint64_t v37 = (os_log_s *)sub_100086554(0x5Au);
      if (os_log_type_enabled(v37, OS_LOG_TYPE_ERROR)) {
        goto LABEL_18;
      }
    }
  }

void sub_1001F7734(uint64_t a1)
{
  if (!*(void *)(a1 + 224))
  {
    uint64_t v2 = sub_1002E91F8(6LL, 10LL, 1LL);
    *(void *)(a1 + 224) = v2;
    if (v2)
    {
      uint64_t v3 = v2;
      uint64_t v4 = (os_log_s *)qword_1008F7668;
      if (os_log_type_enabled((os_log_t)qword_1008F7668, OS_LOG_TYPE_DEFAULT))
      {
        uint64_t v5 = (*(uint64_t (**)(void *))(*(void *)v3 + 16LL))(v3);
        int v6 = 136446210;
        uint64_t v7 = v5;
        _os_log_impl((void *)&_mh_execute_header, v4, OS_LOG_TYPE_DEFAULT, "Creating %{public}s", (uint8_t *)&v6, 0xCu);
      }
    }
  }

void sub_1001F780C(uint64_t a1)
{
  uint64_t v1 = *(void *)(a1 + 224);
  if (v1)
  {
    uint64_t v3 = (os_log_s *)qword_1008F7668;
    if (!os_log_type_enabled((os_log_t)qword_1008F7668, OS_LOG_TYPE_DEFAULT)
      || (uint64_t v4 = (*(uint64_t (**)(uint64_t))(*(void *)v1 + 16LL))(v1),
          int v5 = 136446210,
          uint64_t v6 = v4,
          _os_log_impl( (void *)&_mh_execute_header,  v3,  OS_LOG_TYPE_DEFAULT,  "Destroying %{public}s",  (uint8_t *)&v5,  0xCu),  (uint64_t v1 = *(void *)(a1 + 224)) != 0))
    {
      (*(void (**)(uint64_t))(*(void *)v1 + 8LL))(v1);
    }

    *(void *)(a1 + 224) = 0LL;
  }

double sub_1001F78E8(uint64_t a1)
{
  *(void *)a1 = off_100886C50;
  *(void *)(a1 + 8) = off_100886CB8;
  *(void *)(a1 + 16) = &off_100886CE8;
  *(_BYTE *)(a1 + 24) = 1;
  *(void *)(a1 + 25) = 0LL;
  *(_WORD *)(a1 + 33) = 0;
  *(void *)(a1 + 48) = 0LL;
  *(void *)(a1 + 56) = 0LL;
  *(void *)(a1 + 40) = 0LL;
  *(_BYTE *)(a1 + 64) = 0;
  *(_OWORD *)(a1 + 72) = 0u;
  *(_OWORD *)(a1 + 88) = 0u;
  *(_OWORD *)(a1 + 104) = 0u;
  *(_OWORD *)(a1 + 120) = 0u;
  *(void *)(a1 + 136) = 0LL;
  *(void *)&double result = 33LL;
  *(_OWORD *)(a1 + 144) = xmmword_1006BF140;
  *(void *)(a1 + 176) = 0LL;
  *(void *)(a1 + 168) = 0LL;
  *(void *)(a1 + 160) = a1 + 168;
  *(_DWORD *)(a1 + 184) = 0;
  *(void *)(a1 + 192) = 0LL;
  *(void *)(a1 + 200) = 0LL;
  *(_DWORD *)(a1 + 216) = -1;
  *(void *)(a1 + 224) = 0LL;
  *(_DWORD *)(a1 + 232) = 96;
  return result;
}

void sub_1001F7970(uint64_t a1)
{
  uint64_t v2 = sub_1002E6E00();
  sub_10002418C(buf, "LPM");
  sub_10002418C(__p, "Enable");
  (*(void (**)(uint64_t, _BYTE *, void **, uint64_t))(*(void *)v2 + 72LL))(v2, buf, __p, a1 + 24);
  if (v27 < 0) {
    operator delete(__p[0]);
  }
  if (v31 < 0) {
    operator delete(*(void **)buf);
  }
  uint64_t v3 = sub_1002E6E00();
  sub_10002418C(buf, "LPM");
  sub_10002418C(__p, "EnableHCI");
  (*(void (**)(uint64_t, _BYTE *, void **, uint64_t))(*(void *)v3 + 72LL))(v3, buf, __p, a1 + 26);
  if (v27 < 0) {
    operator delete(__p[0]);
  }
  if (v31 < 0) {
    operator delete(*(void **)buf);
  }
  sub_1002E6E9C();
  *(_BYTE *)(a1 + 25) = sub_1002CE2B0();
  uint64_t v4 = sub_1002E6E00();
  sub_10002418C(buf, "LPM");
  sub_10002418C(__p, "ConfigFlag");
  (*(void (**)(uint64_t, _BYTE *, void **, uint64_t))(*(void *)v4 + 128LL))(v4, buf, __p, a1 + 144);
  if (v27 < 0) {
    operator delete(__p[0]);
  }
  if (v31 < 0) {
    operator delete(*(void **)buf);
  }
  uint64_t v5 = sub_1002E6E00();
  sub_10002418C(buf, "LPM");
  sub_10002418C(__p, "ScanWindow");
  (*(void (**)(uint64_t, _BYTE *, void **, uint64_t))(*(void *)v5 + 128LL))(v5, buf, __p, a1 + 152);
  if (v27 < 0) {
    operator delete(__p[0]);
  }
  if (v31 < 0) {
    operator delete(*(void **)buf);
  }
  uint64_t v6 = sub_1002E6E00();
  sub_10002418C(buf, "LPM");
  sub_10002418C(__p, "ScanInterval");
  (*(void (**)(uint64_t, _BYTE *, void **, uint64_t))(*(void *)v6 + 128LL))(v6, buf, __p, a1 + 156);
  if (v27 < 0) {
    operator delete(__p[0]);
  }
  if (v31 < 0) {
    operator delete(*(void **)buf);
  }
  uint64_t v7 = sub_1002E6E00();
  sub_10002418C(buf, "LPM");
  sub_10002418C(__p, "LoggingMode");
  (*(void (**)(uint64_t, _BYTE *, void **, uint64_t))(*(void *)v7 + 128LL))(v7, buf, __p, a1 + 148);
  if (v27 < 0) {
    operator delete(__p[0]);
  }
  if (v31 < 0) {
    operator delete(*(void **)buf);
  }
  uint64_t v8 = sub_1002E6E00();
  sub_10002418C(buf, "LPM");
  sub_10002418C(__p, "ConfigFlagAdv");
  (*(void (**)(uint64_t, _BYTE *, void **, uint64_t))(*(void *)v8 + 128LL))(v8, buf, __p, a1 + 184);
  if (v27 < 0) {
    operator delete(__p[0]);
  }
  if (v31 < 0) {
    operator delete(*(void **)buf);
  }
  uint64_t v9 = sub_1002E6E00();
  sub_10002418C(buf, "LPM");
  sub_10002418C(__p, "WhiteGloveMode");
  uint64_t v10 = (void *)(a1 + 72);
  (*(void (**)(uint64_t, _BYTE *, void **, uint64_t))(*(void *)v9 + 56LL))(v9, buf, __p, a1 + 72);
  if (v27 < 0) {
    operator delete(__p[0]);
  }
  if (v31 < 0) {
    operator delete(*(void **)buf);
  }
  uint64_t v11 = sub_1002E6E00();
  sub_10002418C(buf, "LPM");
  sub_10002418C(__p, "FactoryMode");
  uint64_t v12 = (void *)(a1 + 96);
  (*(void (**)(uint64_t, _BYTE *, void **, uint64_t))(*(void *)v11 + 56LL))(v11, buf, __p, a1 + 96);
  if (v27 < 0) {
    operator delete(__p[0]);
  }
  if (v31 < 0) {
    operator delete(*(void **)buf);
  }
  uint64_t v13 = sub_1002E6E00();
  sub_10002418C(buf, "LPM");
  sub_10002418C(__p, "LocalBDAddr");
  (*(void (**)(uint64_t, _BYTE *, void **, uint64_t))(*(void *)v13 + 56LL))(v13, buf, __p, a1 + 120);
  if (v27 < 0) {
    operator delete(__p[0]);
  }
  if (v31 < 0) {
    operator delete(*(void **)buf);
  }
  uint64_t v14 = sub_1002E6E00();
  sub_10002418C(buf, "LPM");
  sub_10002418C(__p, "HowManyKeys");
  (*(void (**)(uint64_t, _BYTE *, void **, uint64_t))(*(void *)v14 + 128LL))(v14, buf, __p, a1 + 232);
  if (v27 < 0) {
    operator delete(__p[0]);
  }
  if (v31 < 0) {
    operator delete(*(void **)buf);
  }
  *(void *)(a1 + 208) = 0LL;
  if (!*(_BYTE *)(a1 + 24) || !*(_BYTE *)(a1 + 25)) {
    goto LABEL_71;
  }
  uint64_t v15 = (os_log_s *)qword_1008F7750;
  if (os_log_type_enabled((os_log_t)qword_1008F7750, OS_LOG_TYPE_DEFAULT))
  {
    *(_WORD *)__int128 buf = 0;
    _os_log_impl((void *)&_mh_execute_header, v15, OS_LOG_TYPE_DEFAULT, "LPM mode is supported and enabled.", buf, 2u);
    uint64_t v15 = (os_log_s *)qword_1008F7750;
  }

  if (os_log_type_enabled(v15, OS_LOG_TYPE_INFO))
  {
    int v16 = *(_DWORD *)(a1 + 144);
    int v17 = *(_DWORD *)(a1 + 152);
    int v18 = *(_DWORD *)(a1 + 156);
    *(_DWORD *)__int128 buf = 67109632;
    *(_DWORD *)&uint8_t buf[4] = v16;
    *(_WORD *)&buf[8] = 1024;
    *(_DWORD *)&buf[10] = v17;
    __int16 v29 = 1024;
    int v30 = v18;
    _os_log_impl( (void *)&_mh_execute_header,  v15,  OS_LOG_TYPE_INFO,  "LPM ConfigFlag: %d ScanWindow: %d ScanInterval:%d",  buf,  0x14u);
  }

  if (qword_1008D60B0 != -1) {
    dispatch_once(&qword_1008D60B0, &stru_100886D10);
  }
  sub_1001FC5E4((uint64_t)off_1008D60A8 + 80, a1);
  uint64_t v19 = sub_1002E8D54();
  sub_1001FC8A8(v19 + 368, a1 + 8);
  uint64_t v20 = sub_1002E6B38();
  uint64_t v21 = (*(uint64_t (**)(uint64_t, uint64_t))(*(void *)v20 + 32LL))(v20, a1 + 29);
  if ((*(char *)(a1 + 95) & 0x80000000) == 0)
  {
    if (!*(_BYTE *)(a1 + 95)) {
      goto LABEL_62;
    }
LABEL_57:
    uint64_t v21 = IsAppleInternalBuild(v21, v22);
    if ((_DWORD)v21)
    {
      *(_DWORD *)(a1 + 144) |= 0x10u;
      *(_BYTE *)(a1 + 2memset((char *)&v11[1] + 1, 0, 7) = 1;
      uint64_t v23 = (os_log_s *)qword_1008F7750;
      uint64_t v21 = os_log_type_enabled((os_log_t)qword_1008F7750, OS_LOG_TYPE_DEFAULT);
      if ((_DWORD)v21)
      {
        *(_DWORD *)__int128 buf = 136315138;
        *(void *)&uint8_t buf[4] = v10;
        _os_log_impl( (void *)&_mh_execute_header,  v23,  OS_LOG_TYPE_DEFAULT,  "LPM White Glove mode: %s is enabled.",  buf,  0xCu);
      }
    }

    goto LABEL_62;
  }

  if (*(void *)(a1 + 80)) {
    goto LABEL_57;
  }
LABEL_62:
  if (*(char *)(a1 + 119) < 0)
  {
    if (!*(void *)(a1 + 104)) {
      goto LABEL_71;
    }
  }

  else if (!*(_BYTE *)(a1 + 119))
  {
    goto LABEL_71;
  }

  if (IsAppleInternalBuild(v21, v22))
  {
    *(_BYTE *)(a1 + 28) = 1;
    uint64_t v24 = (os_log_s *)qword_1008F7750;
    if (os_log_type_enabled((os_log_t)qword_1008F7750, OS_LOG_TYPE_DEFAULT))
    {
      *(_DWORD *)__int128 buf = 136315138;
      *(void *)&uint8_t buf[4] = v12;
      _os_log_impl( (void *)&_mh_execute_header,  v24,  OS_LOG_TYPE_DEFAULT,  "LPM Factory Test mode: %s is enabled.",  buf,  0xCu);
    }
  }

void sub_1001F80B0( _Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void *__p, uint64_t a11, int a12, __int16 a13, char a14, char a15, void *a16, uint64_t a17, int a18, __int16 a19, char a20, char a21)
{
  if (a15 < 0) {
    operator delete(__p);
  }
  if (a21 < 0) {
    operator delete(a16);
  }
  _Unwind_Resume(exception_object);
}

uint64_t sub_1001F813C(uint64_t a1, unsigned int a2)
{
  if (!*(_BYTE *)(a1 + 24) || !*(_BYTE *)(a1 + 25))
  {
    if (os_log_type_enabled((os_log_t)qword_1008F7750, OS_LOG_TYPE_ERROR)) {
      sub_10065CB8C();
    }
    return 11LL;
  }

  uint64_t v4 = (os_log_s *)qword_1008F7750;
  if (os_log_type_enabled((os_log_t)qword_1008F7750, OS_LOG_TYPE_DEFAULT))
  {
    *(_WORD *)__int128 buf = 0;
    _os_log_impl((void *)&_mh_execute_header, v4, OS_LOG_TYPE_DEFAULT, "Triggering LPM", buf, 2u);
  }

  io_registry_entry_t v5 = sub_1001FCE88();
  io_object_t v6 = v5;
  if (!v5) {
    goto LABEL_21;
  }
  CFTypeRef v7 = IORegistryEntrySearchCFProperty(v5, "IOService", @"IOPMUBootLPMFWOK", kCFAllocatorDefault, 1u);
  uint64_t v8 = v7;
  if (!v7)
  {
LABEL_20:
    IOObjectRelease(v6);
LABEL_21:
    uint64_t v18 = qword_1008F7750;
    if (!os_log_type_enabled((os_log_t)qword_1008F7750, OS_LOG_TYPE_INFO)) {
      goto LABEL_24;
    }
    *(_WORD *)__int128 buf = 0;
    uint64_t v13 = "Failed to get IOPMUBootLPMFWOK flag";
    uint64_t v14 = (os_log_s *)v18;
    os_log_type_t v15 = OS_LOG_TYPE_INFO;
    goto LABEL_23;
  }

  int valuePtr = 0;
  CFTypeID v9 = CFGetTypeID(v7);
  if (v9 != CFNumberGetTypeID() || !CFNumberGetValue((CFNumberRef)v8, kCFNumberSInt32Type, &valuePtr))
  {
    CFRelease(v8);
    goto LABEL_20;
  }

  int v10 = valuePtr;
  uint64_t v11 = (os_log_s *)qword_1008F7750;
  if (os_log_type_enabled((os_log_t)qword_1008F7750, OS_LOG_TYPE_INFO))
  {
    *(_DWORD *)__int128 buf = 67109120;
    *(_DWORD *)&uint8_t buf[4] = v10 != 0;
    _os_log_impl((void *)&_mh_execute_header, v11, OS_LOG_TYPE_INFO, "Get IOPMUBootLPMFWOK: %d", buf, 8u);
  }

  CFRelease(v8);
  IOObjectRelease(v6);
  if (v10)
  {
    if (!sub_1001F9008(0))
    {
      uint64_t v12 = qword_1008F7750;
      if (os_log_type_enabled((os_log_t)qword_1008F7750, OS_LOG_TYPE_DEFAULT))
      {
        *(_WORD *)__int128 buf = 0;
        uint64_t v13 = "BT_FW_OK flag is cleared.";
        uint64_t v14 = (os_log_s *)v12;
        os_log_type_t v15 = OS_LOG_TYPE_DEFAULT;
LABEL_23:
        _os_log_impl((void *)&_mh_execute_header, v14, v15, v13, buf, 2u);
      }
    }
  }

void sub_1001F8F88(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, ...)
{
}

uint64_t sub_1001F9008(int a1)
{
  kern_return_t v6;
  os_log_s *v8;
  int valuePtr;
  uint8_t buf[4];
  int v11;
  io_object_t v2 = sub_1001FCE88();
  if (!v2)
  {
LABEL_5:
    if (os_log_type_enabled((os_log_t)qword_1008F7750, OS_LOG_TYPE_ERROR)) {
      sub_10065CF78();
    }
    return 1LL;
  }

  io_object_t v3 = v2;
  int valuePtr = a1;
  CFNumberRef v4 = CFNumberCreate(kCFAllocatorDefault, kCFNumberSInt32Type, &valuePtr);
  if (!v4 || (v5 = v4, io_object_t v6 = IORegistryEntrySetCFProperty(v3, @"IOPMUBootLPMFWOK", v4), CFRelease(v5), v6))
  {
    IOObjectRelease(v3);
    goto LABEL_5;
  }

  uint64_t v8 = (os_log_s *)qword_1008F7750;
  if (os_log_type_enabled((os_log_t)qword_1008F7750, OS_LOG_TYPE_INFO))
  {
    *(_DWORD *)__int128 buf = 67109120;
    uint64_t v11 = a1;
    _os_log_impl((void *)&_mh_execute_header, v8, OS_LOG_TYPE_INFO, "Set IOPMUBootLPMFWOK to %d", buf, 8u);
  }

  IOObjectRelease(v3);
  return 0LL;
}

uint64_t sub_1001F9148(uint64_t a1, uint64_t a2)
{
  *(void *)a1 = *(void *)a2;
  sub_10002EAC8(a1 + 8, a2 + 8);
  sub_10002EAC8(a1 + 24, a2 + 24);
  char v4 = *(_BYTE *)(a2 + 44);
  *(_DWORD *)(a1 + 40) = *(_DWORD *)(a2 + 40);
  *(_BYTE *)(a1 + 44) = v4;
  return a1;
}

void *sub_1001F9194(void *a1)
{
  a1[3] = &off_10087FAA8;
  io_object_t v2 = (unsigned int *)a1[4];
  if (v2) {
    sub_1002CD254(v2);
  }
  a1[1] = &off_10087FAA8;
  io_object_t v3 = (unsigned int *)a1[2];
  if (v3) {
    sub_1002CD254(v3);
  }
  return a1;
}

void sub_1001F91DC(uint64_t a1, BOOL *a2)
{
  int valuePtr = 0;
  io_registry_entry_t v4 = sub_1001FCE88();
  if (v4)
  {
    io_object_t v5 = v4;
    io_object_t v6 = (const __CFDictionary *)IORegistryEntrySearchCFProperty( v4,  "IOService",  @"IOPMUBootLPMCtrl",  kCFAllocatorDefault,  1u);
    if (v6)
    {
      CFTypeRef v7 = v6;
      CFTypeID v8 = CFGetTypeID(v6);
      if (v8 == CFDictionaryGetTypeID())
      {
        CFTypeID v9 = (_DWORD)a1 ? @"lpm1" : @"lpm2";
        Value = (const __CFNumber *)CFDictionaryGetValue(v7, v9);
        if (Value)
        {
          CFNumberGetValue(Value, kCFNumberSInt32Type, &valuePtr);
          *a2 = valuePtr != 0;
          CFRelease(v7);
          IOObjectRelease(v5);
          return;
        }
      }

      CFRelease(v7);
    }

    IOObjectRelease(v5);
  }

  uint64_t v11 = (os_log_s *)qword_1008F7750;
  if (os_log_type_enabled((os_log_t)qword_1008F7750, OS_LOG_TYPE_ERROR)) {
    sub_10065CFA4(a1, v11, v12, v13, v14, v15, v16, v17);
  }
}

void sub_1001F92F4(id a1)
{
  uint64_t v1 = (os_log_s *)qword_1008F7750;
  if (os_log_type_enabled((os_log_t)qword_1008F7750, OS_LOG_TYPE_ERROR)) {
    sub_10065D020(v1, v2, v3, v4, v5, v6, v7, v8);
  }
  uint64_t v9 = sub_1002E6E00();
  sub_10002418C(__p, "LPM stack shutdown stuck");
  sub_1004FC14C(v9, (uint64_t *)__p, 3172327085LL);
  if (v11 < 0) {
    operator delete(__p[0]);
  }
}

void sub_1001F9378( _Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void *__p, uint64_t a11, int a12, __int16 a13, char a14, char a15)
{
  if (a15 < 0) {
    operator delete(__p);
  }
  _Unwind_Resume(exception_object);
}

uint64_t sub_1001F9394(_BYTE *a1)
{
  if ((*(_DWORD *)(sub_1002E6E9C() + 708) & 0xFFFFFFFC) == 0x14) {
    int v2 = 3;
  }
  else {
    int v2 = 2;
  }
  sub_1001FA298((uint64_t)a1, v2, 0LL);
  sub_1001FA298((uint64_t)a1, 4, 0LL);
  sub_1001FA298((uint64_t)a1, 5, 0LL);
  sub_1001FA298((uint64_t)a1, 6, 0LL);
  sub_1001FA298((uint64_t)a1, 7, 0LL);
  sub_1001FA298((uint64_t)a1, 16, 0LL);
  sub_1001FA298((uint64_t)a1, 18, 0LL);
  sub_1001FA298((uint64_t)a1, 19, 0LL);
  sub_1001FA298((uint64_t)a1, 20, 0LL);
  sub_1001FA298((uint64_t)a1, 21, 0LL);
  sub_1001FA298((uint64_t)a1, 14, 0LL);
  sub_1001FA298((uint64_t)a1, 22, 0LL);
  if (a1[26] && ((a1[144] & 1) == 0 || (a1[184] & 8) != 0)) {
    sub_1001FA298((uint64_t)a1, 15, 0LL);
  }
  return 0LL;
}

uint64_t sub_1001F94CC(uint64_t a1)
{
  int v2 = *(_DWORD *)(sub_1002E6E9C() + 708);
  memset(&v13, 0, sizeof(v13));
  uint64_t v3 = sub_1002E6E9C();
  (*(void (**)(std::string *__return_ptr))(*(void *)v3 + 16LL))(&v13);
  BOOL v4 = (v2 & 0xFFFFFFFE) == 0x14 || v2 == 23;
  if (v4 || v2 == 22 && std::string::compare(&v13, "C2") <= 0) {
    int v5 = 3;
  }
  else {
    int v5 = 2;
  }
  sub_1001FA298(a1, v5, 0LL);
  sub_1001FA298(a1, 4, 0LL);
  sub_1001FA298(a1, 5, 0LL);
  sub_1001FA298(a1, 6, 0LL);
  sub_1001FA298(a1, 7, 0LL);
  if ((*(_BYTE *)(a1 + 64) & 1) != 0)
  {
    sub_1001FA298(a1, 8, 0LL);
    uint64_t v6 = *(void **)(a1 + 160);
    if (v6 != (void *)(a1 + 168))
    {
      do
      {
        __int128 v16 = 0u;
        __int128 v17 = 0u;
        __int128 v14 = 0u;
        __int128 v15 = 0u;
        sub_1001FD498((uint64_t)&v14, (uint64_t)(v6 + 4));
        sub_1001FA298(a1, 9, (uint64_t)&v15);
        *((void *)&v16 + 1) = &off_10087FAA8;
        if ((void)v17) {
          sub_1002CD254((unsigned int *)v17);
        }
        *((void *)&v15 + 1) = &off_10087FAA8;
        if ((void)v16) {
          sub_1002CD254((unsigned int *)v16);
        }
        uint64_t v7 = (void *)v6[1];
        if (v7)
        {
          do
          {
            uint64_t v8 = v7;
            uint64_t v7 = (void *)*v7;
          }

          while (v7);
        }

        else
        {
          do
          {
            uint64_t v8 = (void *)v6[2];
            BOOL v4 = *v8 == (void)v6;
            uint64_t v6 = v8;
          }

          while (!v4);
        }

        uint64_t v6 = v8;
      }

      while (v8 != (void *)(a1 + 168));
    }
  }

  if ((*(_BYTE *)(a1 + 64) & 2) != 0)
  {
    sub_1001FA298(a1, 11, 0LL);
    while (1)
    {
      unint64_t v9 = (unsigned __int16)word_1008F709A;
      int v10 = (char *)[*(id *)(a1 + 192) count];
      uint64_t v11 = sub_1001FA298(a1, 12, 0LL);
      if ((_DWORD)v11) {
        goto LABEL_33;
      }
    }

    sub_1001FA298(a1, 13, 0LL);
  }

  sub_1001FA298(a1, 14, 0LL);
  sub_1001FA298(a1, 10, 0LL);
  if (*(_BYTE *)(a1 + 26) && ((*(_BYTE *)(a1 + 144) & 1) == 0 || (*(_BYTE *)(a1 + 184) & 8) != 0)) {
    sub_1001FA298(a1, 15, 0LL);
  }
  uint64_t v11 = 0LL;
LABEL_33:
  return v11;
}

void sub_1001F9778( _Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void *__p, uint64_t a11, int a12, __int16 a13, char a14, char a15, char a16)
{
}

uint64_t sub_1001F97B8(uint64_t a1)
{
  uint64_t v3 = (os_log_s *)qword_1008F7750;
  if (os_log_type_enabled((os_log_t)qword_1008F7750, OS_LOG_TYPE_INFO))
  {
    *(_WORD *)__int128 buf = 0;
    _os_log_impl((void *)&_mh_execute_header, v3, OS_LOG_TYPE_INFO, "Initialization for hostless mode", buf, 2u);
  }

  uint64_t v4 = *(void *)(a1 + 40);
  uint64_t v5 = *(void *)(a1 + 48);
  if (v4 != v5)
  {
    while (1)
    {
      uint64_t v38 = 0LL;
      memset(v37, 0, sizeof(v37));
      LODWORD(v37[0]) = *(_DWORD *)v4;
      if (*(char *)(v4 + 31) < 0)
      {
        sub_100024238(&v37[1], *(void **)(v4 + 8), *(void *)(v4 + 16));
      }

      else
      {
        __int128 v6 = *(_OWORD *)(v4 + 8);
        v37[3] = *(void **)(v4 + 24);
        *(_OWORD *)&v37[1] = v6;
      }

      uint64_t v38 = *(uint64_t (**)(void **))(v4 + 32);
      uint64_t v7 = (void *)HIBYTE(v37[3]);
      if (SHIBYTE(v37[3]) < 0) {
        uint64_t v7 = v37[2];
      }
      if (!v7)
      {
LABEL_52:
        char v11 = 1;
        goto LABEL_53;
      }

      bzero(buf, 0x800uLL);
      uint64_t v8 = sub_1002E6B38();
      if (SHIBYTE(v37[3]) >= 0) {
        unint64_t v9 = &v37[1];
      }
      else {
        unint64_t v9 = (void **)v37[1];
      }
      uint64_t v10 = (*(uint64_t (**)(uint64_t, void **, uint8_t *, uint64_t))(*(void *)v8 + 128LL))( v8,  v9,  buf,  2048LL);
      if ((_DWORD)v10)
      {
        char v11 = 0;
        uint64_t v1 = v10;
        goto LABEL_53;
      }

      __p = 0LL;
      uint64_t v35 = 0LL;
      uint64_t v36 = 0LL;
      int v12 = strlen((const char *)buf);
      int v13 = v12;
      if (v12)
      {
        if (v12 <= 2048)
        {
          if (v12 >= 4)
          {
            uint64_t v14 = 0LL;
            while (1)
            {
              char v41 = 0;
              __int128 v15 = v35;
              if (v35 >= v36)
              {
                unint64_t v17 = (unint64_t)__p;
                uint64_t v18 = v35 - (_BYTE *)__p;
                uint64_t v19 = v35 - (_BYTE *)__p + 1;
                if (v19 < 0) {
                  abort();
                }
                unint64_t v20 = v36 - (_BYTE *)__p;
                if (v20 >= 0x3FFFFFFFFFFFFFFFLL) {
                  size_t v21 = 0x7FFFFFFFFFFFFFFFLL;
                }
                else {
                  size_t v21 = v19;
                }
                if (v21) {
                  uint64_t v22 = (char *)operator new(v21);
                }
                else {
                  uint64_t v22 = 0LL;
                }
                uint64_t v23 = &v22[v18];
                unsigned int v24 = &v22[v18];
                char *v24 = v41;
                __int128 v16 = v24 + 1;
                if (v15 != (char *)v17)
                {
                  uint64_t v25 = &v15[~v17];
                  do
                  {
                    char v26 = *--v15;
                    (v25--)[(void)v22] = v26;
                  }

                  while (v15 != (char *)v17);
                  __int128 v15 = (char *)__p;
                  uint64_t v23 = v22;
                }

                __p = v23;
                uint64_t v35 = v16;
                uint64_t v36 = &v22[v21];
                if (v15) {
                  operator delete(v15);
                }
              }

              else
              {
                *uint64_t v35 = v41;
                __int128 v16 = v15 + 1;
              }

              uint64_t v35 = v16;
              v14 += 5LL;
              BOOL v27 = v13 <= 8;
              v13 -= 5;
              if (v27) {
                goto LABEL_44;
              }
            }

            if (os_log_type_enabled((os_log_t)qword_1008F7750, OS_LOG_TYPE_ERROR)) {
              sub_10065D0E4(&v39, v40);
            }
          }
        }

        else if (os_log_type_enabled((os_log_t)qword_1008F7750, OS_LOG_TYPE_ERROR))
        {
          sub_10065D0B8(&v42, v43);
        }
      }

void sub_1001F9B98( _Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, void *__p, uint64_t a15, uint64_t a16, uint64_t a17, void *a18, uint64_t a19, int a20, __int16 a21, char a22, char a23)
{
  if (__p) {
    operator delete(__p);
  }
  if (a23 < 0) {
    operator delete(a18);
  }
  _Unwind_Resume(exception_object);
}

uint64_t sub_1001F9BDC()
{
  uint64_t v0 = (os_log_s *)qword_1008F7750;
  if (os_log_type_enabled((os_log_t)qword_1008F7750, OS_LOG_TYPE_DEFAULT))
  {
    LOWORD(v2[0]) = 0;
    _os_log_impl( (void *)&_mh_execute_header,  v0,  OS_LOG_TYPE_DEFAULT,  "LPMManager::powerManagementEventSystemWillSleep",  (uint8_t *)v2,  2u);
  }

  v2[0] = 0LL;
  v2[1] = 0LL;
  sub_100242F28((uint64_t)v2, (uint64_t)&unk_1008F7118);
  byte_1008F7111 = 1;
  return sub_100242FAC((uint64_t)v2);
}

uint64_t sub_1001F9C6C()
{
  uint64_t v0 = (os_log_s *)qword_1008F7750;
  if (os_log_type_enabled((os_log_t)qword_1008F7750, OS_LOG_TYPE_DEFAULT))
  {
    LOWORD(v2[0]) = 0;
    _os_log_impl( (void *)&_mh_execute_header,  v0,  OS_LOG_TYPE_DEFAULT,  "LPMManager::powerManagementEventSystemWokeUp",  (uint8_t *)v2,  2u);
  }

  v2[0] = 0LL;
  v2[1] = 0LL;
  sub_100242F28((uint64_t)v2, (uint64_t)&unk_1008F7118);
  byte_1008F7111 = 0;
  sub_1002431FC(&stru_1008F7158);
  return sub_100242FAC((uint64_t)v2);
}

void sub_1001F9D00( _Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9)
{
}

uint64_t sub_1001F9D18(uint64_t a1)
{
  int v2 = (os_log_s *)qword_1008F7750;
  if (os_log_type_enabled((os_log_t)qword_1008F7750, OS_LOG_TYPE_DEFAULT))
  {
    *(_WORD *)__int128 buf = 0;
    _os_log_impl( (void *)&_mh_execute_header,  v2,  OS_LOG_TYPE_DEFAULT,  "LPMManager::powerManagementEventSystemWillShutDown",  buf,  2u);
  }

  if (*(_BYTE *)(a1 + 24) && *(_BYTE *)(a1 + 25))
  {
    uint64_t v3 = (os_log_s *)qword_1008F7750;
    if (os_log_type_enabled((os_log_t)qword_1008F7750, OS_LOG_TYPE_DEFAULT))
    {
      *(_WORD *)uint64_t v5 = 0;
      _os_log_impl( (void *)&_mh_execute_header,  v3,  OS_LOG_TYPE_DEFAULT,  "LPMManager::powerManagementEventSystemWillShutDown fOfflineADVDataPending = true",  v5,  2u);
    }

    byte_1008F7098 = 1;
  }

  return 1LL;
}

uint64_t sub_1001F9DE4(uint64_t a1)
{
  return 1LL;
}

uint64_t sub_1001F9E00(uint64_t a1, uint64_t a2, uint64_t a3)
{
  v9[0] = a2;
  v9[1] = a3;
  uint64_t v3 = (os_log_s *)qword_1008F7750;
  if (os_log_type_enabled((os_log_t)qword_1008F7750, OS_LOG_TYPE_DEFAULT))
  {
    sub_1001F9F74((uint64_t)v9, &__p);
    uint64_t v4 = (__p.__r_.__value_.__s.__size_ & 0x80u) == 0
       ? &__p
       : (std::stringbuf::string_type *)__p.__r_.__value_.__r.__words[0];
    *(_DWORD *)__int128 buf = 136315138;
    char v11 = v4;
    _os_log_impl((void *)&_mh_execute_header, v3, OS_LOG_TYPE_DEFAULT, "wifiStateChanged:%s", buf, 0xCu);
  }

  *(_OWORD *)&__p.__r_.__value_.__l.__data_ = 0uLL;
  sub_100242F28((uint64_t)&__p, (uint64_t)&unk_1008F70D0);
  if (byte_1008F7110) {
    BOOL v5 = LOBYTE(v9[0]) == 0;
  }
  else {
    BOOL v5 = 0;
  }
  if (v5)
  {
    __int128 v6 = (os_log_s *)qword_1008F7750;
    if (os_log_type_enabled((os_log_t)qword_1008F7750, OS_LOG_TYPE_DEFAULT))
    {
      *(_WORD *)__int128 buf = 0;
      _os_log_impl( (void *)&_mh_execute_header,  v6,  OS_LOG_TYPE_DEFAULT,  "wifiStateChanged and wifi power is off",  buf,  2u);
    }

    byte_1008F7110 = 0;
    sub_1002431FC(&stru_1008F70A0);
  }

  return sub_100242FAC((uint64_t)&__p);
}

void sub_1001F9F58(_Unwind_Exception *a1, uint64_t a2, ...)
{
}

uint64_t sub_1001F9F74@<X0>(uint64_t a1@<X0>, std::stringbuf::string_type *a2@<X8>)
{
  uint64_t v27 = 0LL;
  __int128 v25 = 0u;
  memset(v26, 0, sizeof(v26));
  *(_OWORD *)uint64_t v23 = 0u;
  __int128 v24 = 0u;
  memset(v22, 0, sizeof(v22));
  __int128 v21 = 0u;
  sub_1001FCFC8((uint64_t)&v21);
  uint64_t v4 = sub_1001FD17C(v22, (uint64_t)"WiFi State: powerState-", 23LL);
  if (*(_BYTE *)a1) {
    BOOL v5 = "on";
  }
  else {
    BOOL v5 = "off";
  }
  if (*(_BYTE *)a1) {
    uint64_t v6 = 2LL;
  }
  else {
    uint64_t v6 = 3LL;
  }
  uint64_t v7 = sub_1001FD17C(v4, (uint64_t)v5, v6);
  uint64_t v8 = sub_1001FD17C(v7, (uint64_t)", associated-", 13LL);
  uint64_t v9 = *(int *)(a1 + 4);
  else {
    uint64_t v10 = off_100886D90[v9];
  }
  sub_10002418C(__p, v10);
  if ((v20 & 0x80u) == 0) {
    char v11 = __p;
  }
  else {
    char v11 = (void **)__p[0];
  }
  if ((v20 & 0x80u) == 0) {
    uint64_t v12 = v20;
  }
  else {
    uint64_t v12 = (uint64_t)__p[1];
  }
  int v13 = sub_1001FD17C(v8, (uint64_t)v11, v12);
  uint64_t v14 = sub_1001FD17C(v13, (uint64_t)", 2.4GHz critical-", 18LL);
  if (*(_BYTE *)(a1 + 8)) {
    __int128 v15 = "Yes";
  }
  else {
    __int128 v15 = "No";
  }
  if (*(_BYTE *)(a1 + 8)) {
    uint64_t v16 = 3LL;
  }
  else {
    uint64_t v16 = 2LL;
  }
  sub_1001FD17C(v14, (uint64_t)v15, v16);
  std::stringbuf::str(a2, (const std::stringbuf *)((char *)v22 + 8));
  *(void *)((char *)&v22[-1]
  *(void *)&v22[0] = v17;
  if (SHIBYTE(v24) < 0) {
    operator delete(v23[1]);
  }
  std::streambuf::~streambuf((char *)v22 + 8);
  return std::ios::~ios(v26);
}

void sub_1001FA140( _Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void *__p, uint64_t a11, int a12, __int16 a13, char a14, char a15, char a16)
{
}

void sub_1001FA174(uint64_t a1)
{
  int v2 = (os_log_s *)qword_1008F7750;
  if (os_log_type_enabled((os_log_t)qword_1008F7750, OS_LOG_TYPE_DEFAULT))
  {
    *(_WORD *)__int128 buf = 0;
    _os_log_impl((void *)&_mh_execute_header, v2, OS_LOG_TYPE_DEFAULT, "LPMManager::stackDidStart", buf, 2u);
  }

  block[0] = _NSConcreteStackBlock;
  block[1] = 3221225472LL;
  block[2] = nullsub_80;
  block[3] = &unk_10087EB20;
  block[4] = a1;
  if (qword_1008EF8D8 != -1) {
    dispatch_once(&qword_1008EF8D8, block);
  }
}

void sub_1001FA234()
{
  uint64_t v0 = (os_log_s *)qword_1008F7750;
  if (os_log_type_enabled((os_log_t)qword_1008F7750, OS_LOG_TYPE_DEFAULT))
  {
    *(_WORD *)uint64_t v1 = 0;
    _os_log_impl((void *)&_mh_execute_header, v0, OS_LOG_TYPE_DEFAULT, "LPMManager::stackWillStop", v1, 2u);
  }

uint64_t sub_1001FA298(uint64_t a1, int a2, uint64_t a3)
{
  v24.__r_.__value_.__l.__cap_ = 0LL;
  uint64_t v25 = 0LL;
  uint64_t v26 = 0LL;
  uint64_t v6 = sub_10002418C(&v24.__r_.__value_.__l.__cap_, "");
  switch(a2)
  {
    case 0:
      *(_DWORD *)__int128 buf = 0;
      sub_10002418C(&v28[4], "device -D");
      char v30 = 0LL;
      sub_1001FAC6C((uint64_t *)(a1 + 40), (uint64_t)buf);
      goto LABEL_67;
    case 1:
      *(_DWORD *)__int128 buf = 1;
      sub_10002418C(&v28[4], "power off");
      char v30 = 0LL;
      sub_1001FAC6C((uint64_t *)(a1 + 40), (uint64_t)buf);
      goto LABEL_67;
    case 2:
      *(_DWORD *)__int128 buf = 2;
      sub_10002418C(&v28[4], "bcm -W");
      char v30 = 0LL;
      sub_1001FAC6C((uint64_t *)(a1 + 40), (uint64_t)buf);
      goto LABEL_67;
    case 3:
      *(_DWORD *)__int128 buf = 3;
      sub_10002418C(&v28[4], "bcm -L");
      char v30 = 0LL;
      sub_1001FAC6C((uint64_t *)(a1 + 40), (uint64_t)buf);
      goto LABEL_67;
    case 4:
      *(_DWORD *)__int128 buf = 4;
      sub_10002418C(&v28[4], "bcm -A");
      char v30 = 0LL;
      sub_1001FAC6C((uint64_t *)(a1 + 40), (uint64_t)buf);
      goto LABEL_67;
    case 5:
      *(_DWORD *)__int128 buf = 5;
      sub_10002418C(&v28[4], "bcm -Q");
      char v30 = 0LL;
      sub_1001FAC6C((uint64_t *)(a1 + 40), (uint64_t)buf);
      goto LABEL_67;
    case 6:
      *(_DWORD *)__int128 buf = 6;
      sub_10002418C(&v28[4], "bcm -x");
      char v30 = 0LL;
      sub_1001FAC6C((uint64_t *)(a1 + 40), (uint64_t)buf);
      goto LABEL_67;
    case 7:
      *(_DWORD *)__int128 buf = 7;
      sub_10002418C(&v28[4], "hci reset");
      char v30 = sub_1001FADB4;
      sub_1001FAC6C((uint64_t *)(a1 + 40), (uint64_t)buf);
      goto LABEL_67;
    case 8:
      uint64_t v7 = (std::string *)sub_1001FAE3C(a1);
      sub_1001FB0A8(v7, 78, (std::string *)&v24.__r_.__value_.__r.__words[2]);
      if (v26 >= 0) {
        cap = &v24.__r_.__value_.__s.__data_[16];
      }
      else {
        cap = (const char *)v24.__r_.__value_.__l.__cap_;
      }
      snprintf(__str, 0x800uLL, "hci cmd 0x%04X %s", 65122, cap);
      *(_DWORD *)__int128 buf = 8;
      sub_10002418C(&v28[4], __str);
      char v30 = sub_1001FB154;
      sub_1001FAC6C((uint64_t *)(a1 + 40), (uint64_t)buf);
      goto LABEL_27;
    case 9:
      uint64_t v7 = (std::string *)sub_1001FB1DC((uint64_t)v6, a3);
      sub_1001FB0A8(v7, 61, (std::string *)&v24.__r_.__value_.__r.__words[2]);
      if (v26 >= 0) {
        uint64_t v9 = &v24.__r_.__value_.__s.__data_[16];
      }
      else {
        uint64_t v9 = (const char *)v24.__r_.__value_.__l.__cap_;
      }
      snprintf(__str, 0x800uLL, "hci cmd 0x%04X %s", 65122, v9);
      *(_DWORD *)__int128 buf = 9;
      sub_10002418C(&v28[4], __str);
      char v30 = sub_1001FB154;
      sub_1001FAC6C((uint64_t *)(a1 + 40), (uint64_t)buf);
      if (v29 < 0) {
        operator delete(*(void **)&v28[4]);
      }
      goto LABEL_30;
    case 10:
      v24.__r_.__value_.__s.__data_[8] = 4;
      sub_1001FB0A8( (std::string *)&v24.__r_.__value_.__r.__words[1],  1,  (std::string *)&v24.__r_.__value_.__r.__words[2]);
      if (v26 >= 0) {
        uint64_t v10 = &v24.__r_.__value_.__s.__data_[16];
      }
      else {
        uint64_t v10 = (const char *)v24.__r_.__value_.__l.__cap_;
      }
      snprintf(__str, 0x800uLL, "hci cmd 0x%04X %s", 65122, v10);
      *(_DWORD *)__int128 buf = 10;
      sub_10002418C(&v28[4], __str);
      char v30 = sub_1001FB154;
      sub_1001FAC6C((uint64_t *)(a1 + 40), (uint64_t)buf);
      goto LABEL_67;
    case 11:
      uint64_t v7 = (std::string *)sub_1001FB390(a1);
      sub_1001FB0A8(v7, 20, (std::string *)&v24.__r_.__value_.__r.__words[2]);
      if (v26 >= 0) {
        char v11 = &v24.__r_.__value_.__s.__data_[16];
      }
      else {
        char v11 = (const char *)v24.__r_.__value_.__l.__cap_;
      }
      snprintf(__str, 0x800uLL, "hci cmd 0x%04X %s", 65122, v11);
      *(_DWORD *)__int128 buf = 11;
      sub_10002418C(&v28[4], __str);
      char v30 = sub_1001FB154;
      sub_1001FAC6C((uint64_t *)(a1 + 40), (uint64_t)buf);
LABEL_27:
      if (v29 < 0) {
        operator delete(*(void **)&v28[4]);
      }
      if (!v7) {
        goto LABEL_70;
      }
LABEL_30:
      uint64_t v12 = v7;
      goto LABEL_69;
    case 12:
      LODWORD(v24.__r_.__value_.__r.__words[1]) = 0;
      int v13 = (std::string *)sub_1001FB4B0(a1, &v24.__r_.__value_.__r.__words[1]);
      sub_1001FB0A8(v13, 233, (std::string *)&v24.__r_.__value_.__r.__words[2]);
      if (v26 >= 0) {
        uint64_t v14 = &v24.__r_.__value_.__s.__data_[16];
      }
      else {
        uint64_t v14 = (const char *)v24.__r_.__value_.__l.__cap_;
      }
      snprintf(__str, 0x800uLL, "hci cmd 0x%04X %s", 65122, v14);
      *(_DWORD *)__int128 buf = 12;
      sub_10002418C(&v28[4], __str);
      char v30 = sub_1001FB154;
      sub_1001FAC6C((uint64_t *)(a1 + 40), (uint64_t)buf);
      if (v29 < 0) {
        operator delete(*(void **)&v28[4]);
      }
      if (v13) {
        operator delete(v13);
      }
      uint64_t v15 = LODWORD(v24.__r_.__value_.__r.__words[1]);
      goto LABEL_71;
    case 13:
      v24.__r_.__value_.__s.__data_[10] = 1;
      LOWORD(v24.__r_.__value_.__r.__words[1]) = 7;
      sub_1001FB0A8( (std::string *)&v24.__r_.__value_.__r.__words[1],  3,  (std::string *)&v24.__r_.__value_.__r.__words[2]);
      if (v26 >= 0) {
        uint64_t v16 = &v24.__r_.__value_.__s.__data_[16];
      }
      else {
        uint64_t v16 = (const char *)v24.__r_.__value_.__l.__cap_;
      }
      snprintf(__str, 0x800uLL, "hci cmd 0x%04X %s", 65122, v16);
      *(_DWORD *)__int128 buf = 13;
      sub_10002418C(&v28[4], __str);
      char v30 = sub_1001FB154;
      sub_1001FAC6C((uint64_t *)(a1 + 40), (uint64_t)buf);
      goto LABEL_67;
    case 14:
      *(_DWORD *)__int128 buf = 14;
      sub_10002418C(&v28[4], "bcm -s 0x0f,0x00,0x02,0x00,0x01,0x00,0x00,0x00,0x00,0x00,0x00,0x00");
      char v30 = 0LL;
      sub_1001FAC6C((uint64_t *)(a1 + 40), (uint64_t)buf);
      goto LABEL_67;
    case 15:
      *(_DWORD *)__int128 buf = 15;
      sub_10002418C(&v28[4], "quit");
      char v30 = 0LL;
      sub_1001FAC6C((uint64_t *)(a1 + 40), (uint64_t)buf);
      goto LABEL_67;
    case 16:
      uint64_t v17 = (unsigned __int8 *)(a1 + 120);
      if (*(char *)(a1 + 143) < 0)
      {
        if (*(void *)(a1 + 128))
        {
          WORD2(v24.__r_.__value_.__r.__words[1]) = 0;
          LODWORD(v24.__r_.__value_.__r.__words[1]) = 0;
          WORD2(v24.__r_.__value_.__r.__words[0]) = 0;
          LODWORD(v24.__r_.__value_.__l.__data_) = 0;
          uint64_t v17 = *(unsigned __int8 **)v17;
LABEL_56:
          if (!sub_1003C1F48(v17, (uint64_t)&v24.__r_.__value_.__l.__size_))
          {
            uint64_t v18 = 0LL;
            uint64_t v19 = &v24.__r_.__value_.__s.__data_[13];
            do
            {
              std::string::value_type v20 = *v19--;
              v24.__r_.__value_.__s.__data_[v18++] = v20;
            }

            while (v18 != 6);
            sub_1001FB0A8(&v24, 6, (std::string *)&v24.__r_.__value_.__r.__words[2]);
            if (v26 >= 0) {
              __int128 v21 = &v24.__r_.__value_.__s.__data_[16];
            }
            else {
              __int128 v21 = (const char *)v24.__r_.__value_.__l.__cap_;
            }
            snprintf(__str, 0x800uLL, "hci cmd 0xfc01 %s", v21);
            *(_DWORD *)__int128 buf = 16;
            sub_10002418C(&v28[4], __str);
            char v30 = 0LL;
            sub_1001FAC6C((uint64_t *)(a1 + 40), (uint64_t)buf);
            if (v29 < 0) {
              operator delete(*(void **)&v28[4]);
            }
            uint64_t v22 = (os_log_s *)qword_1008F7750;
            if (os_log_type_enabled((os_log_t)qword_1008F7750, OS_LOG_TYPE_DEFAULT))
            {
              *(_DWORD *)__int128 buf = 136315138;
              *(void *)uint64_t v28 = __str;
              _os_log_impl((void *)&_mh_execute_header, v22, OS_LOG_TYPE_DEFAULT, "BCM_WRITE_BDADDR:%s", buf, 0xCu);
            }
          }

          goto LABEL_70;
        }
      }

      else if (*(_BYTE *)(a1 + 143))
      {
        WORD2(v24.__r_.__value_.__r.__words[1]) = 0;
        LODWORD(v24.__r_.__value_.__r.__words[1]) = 0;
        WORD2(v24.__r_.__value_.__r.__words[0]) = 0;
        LODWORD(v24.__r_.__value_.__l.__data_) = 0;
        goto LABEL_56;
      }

      *(_DWORD *)__int128 buf = 16;
      sub_10002418C(&v28[4], "hci cmd 0xfc01 0x98 0x98 0x98 0xC2 0x87 0x43");
      char v30 = 0LL;
      sub_1001FAC6C((uint64_t *)(a1 + 40), (uint64_t)buf);
LABEL_67:
      if (v29 < 0)
      {
        uint64_t v12 = *(std::string **)&v28[4];
LABEL_69:
        operator delete(v12);
      }

void sub_1001FAB14( _Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, void *a14, uint64_t a15, int a16, __int16 a17, char a18, char a19, uint64_t a20, void *__p, uint64_t a22, int a23, __int16 a24, char a25, char a26)
{
  if (a26 < 0) {
    operator delete(__p);
  }
  if (a19 < 0) {
    operator delete(a14);
  }
  _Unwind_Resume(exception_object);
}

void *sub_1001FAC24(void *a1)
{
  a1[5] = &off_10087FAA8;
  int v2 = (unsigned int *)a1[6];
  if (v2) {
    sub_1002CD254(v2);
  }
  a1[3] = &off_10087FAA8;
  uint64_t v3 = (unsigned int *)a1[4];
  if (v3) {
    sub_1002CD254(v3);
  }
  return a1;
}

uint64_t sub_1001FAC6C(uint64_t *a1, uint64_t a2)
{
  unint64_t v6 = a1[2];
  uint64_t result = (uint64_t)(a1 + 2);
  unint64_t v5 = v6;
  unint64_t v7 = *(void *)(result - 8);
  if (v7 >= v6)
  {
    unint64_t v10 = 0xCCCCCCCCCCCCCCCDLL * ((uint64_t)(v7 - *a1) >> 3);
    unint64_t v11 = v10 + 1;
    if (v10 + 1 > 0x666666666666666LL) {
      abort();
    }
    unint64_t v12 = 0xCCCCCCCCCCCCCCCDLL * ((uint64_t)(v5 - *a1) >> 3);
    if (2 * v12 > v11) {
      unint64_t v11 = 2 * v12;
    }
    if (v12 >= 0x333333333333333LL) {
      unint64_t v13 = 0x666666666666666LL;
    }
    else {
      unint64_t v13 = v11;
    }
    v18[4] = result;
    uint64_t v14 = (char *)sub_1001FDA44(result, v13);
    uint64_t v15 = &v14[40 * v10];
    v18[0] = v14;
    v18[1] = v15;
    v18[3] = &v14[40 * v16];
    *(_DWORD *)uint64_t v15 = *(_DWORD *)a2;
    __int128 v17 = *(_OWORD *)(a2 + 8);
    *((void *)v15 + 3) = *(void *)(a2 + 24);
    *(_OWORD *)(v15 + 8) = v17;
    *(void *)(a2 + 16) = 0LL;
    *(void *)(a2 + 24) = 0LL;
    *(void *)(a2 + 8) = 0LL;
    *((void *)v15 + 4) = *(void *)(a2 + 32);
    char v18[2] = v15 + 40;
    sub_1001FD9CC(a1, v18);
    uint64_t v9 = a1[1];
    uint64_t result = sub_1001FDA88((uint64_t)v18);
  }

  else
  {
    *(_DWORD *)unint64_t v7 = *(_DWORD *)a2;
    __int128 v8 = *(_OWORD *)(a2 + 8);
    *(void *)(v7 + 24) = *(void *)(a2 + 24);
    *(_OWORD *)(v7 + 8) = v8;
    *(void *)(a2 + 16) = 0LL;
    *(void *)(a2 + 24) = 0LL;
    *(void *)(a2 + 8) = 0LL;
    *(void *)(v7 + 32) = *(void *)(a2 + 32);
    uint64_t v9 = v7 + 40;
    a1[1] = v7 + 40;
  }

  a1[1] = v9;
  return result;
}

void sub_1001FADA0(_Unwind_Exception *a1, uint64_t a2, ...)
{
}

uint64_t sub_1001FADB4(uint64_t a1)
{
  int v2 = *(_BYTE **)a1;
  uint64_t v1 = *(void *)(a1 + 8);
  if (v1 - *(void *)a1 != 6 || *v2 != 14 || v2[1] != 4) {
    return 3LL;
  }
  uint64_t v3 = *(unsigned __int8 *)(v1 - 1);
  if (!*(_BYTE *)(v1 - 1)) {
    return 0LL;
  }
  uint64_t v4 = (os_log_s *)qword_1008F7750;
  if (os_log_type_enabled((os_log_t)qword_1008F7750, OS_LOG_TYPE_ERROR)) {
    sub_10065D110(v3, v4, v5, v6, v7, v8, v9, v10);
  }
  return 112LL;
}

char *sub_1001FAE3C(uint64_t a1)
{
  int v2 = (char *)operator new(0x4EuLL);
  int v3 = *(_DWORD *)(a1 + 148);
  v2[1] = *(_DWORD *)(a1 + 144);
  int v4 = *(_DWORD *)(a1 + 156);
  *((_WORD *)v2 + 1) = *(_DWORD *)(a1 + 152);
  *((_WORD *)v2 + 2) = v4;
  *int v2 = 1;
  v2[6] = 1;
  v2[29] = v3;
  v2[30] = *(void *)(a1 + 176);
  *(_DWORD *)(v2 + 31) = 197125;
  *(_WORD *)(v2 + 35) = 1536;
  v2[67] = 8;
  *(void *)(v2 + 3memset((char *)&v11[1] + 1, 0, 7) = 0xE004070000A0LL;
  *(_WORD *)(v2 + 45) = 0;
  *(_WORD *)(v2 + 55) = 0;
  *(void *)(v2 + 4memset((char *)&v11[1] + 1, 0, 7) = 0x100E004070000A0LL;
  *(_WORD *)(v2 + 65) = 768;
  *(void *)(v2 + 5memset((char *)&v11[1] + 1, 0, 7) = 0x100E004070000A0LL;
  *((_WORD *)v2 + 38) = 512;
  *(void *)(v2 + 68) = 0x100E004070000A0LL;
  uint64_t v5 = v2 + 13;
  if (qword_1008D5F20 != -1) {
    dispatch_once(&qword_1008D5F20, &stru_100886D30);
  }
  *uint64_t v5 = *(_OWORD *)(qword_1008D5F18 + 184);
  sub_1001F0050((uint64_t)(v2 + 7), a1 + 29, 6uLL);
  if (!v2[1])
  {
    uint64_t v6 = (os_log_s *)qword_1008F7750;
    if (os_log_type_enabled((os_log_t)qword_1008F7750, OS_LOG_TYPE_FAULT)) {
      sub_10065D3A8(v6, v7, v8, v9, v10, v11, v12, v13);
    }
  }

  if (*((unsigned __int16 *)v2 + 1) - 4 >= 0x3FFD)
  {
    uint64_t v14 = (os_log_s *)qword_1008F7750;
    if (os_log_type_enabled((os_log_t)qword_1008F7750, OS_LOG_TYPE_FAULT)) {
      sub_10065D338(v14, v15, v16, v17, v18, v19, v20, v21);
    }
  }

  if (*((unsigned __int16 *)v2 + 2) - 4 >= 0x3FFD)
  {
    uint64_t v22 = (os_log_s *)qword_1008F7750;
    if (os_log_type_enabled((os_log_t)qword_1008F7750, OS_LOG_TYPE_FAULT)) {
      sub_10065D2C8(v22, v23, v24, v25, v26, v27, v28, v29);
    }
  }

  if (v2[30] >= 9u)
  {
    char v30 = (os_log_s *)qword_1008F7750;
    if (os_log_type_enabled((os_log_t)qword_1008F7750, OS_LOG_TYPE_FAULT)) {
      sub_10065D258(v30, v31, v32, v33, v34, v35, v36, v37);
    }
  }

  if (*(_DWORD *)(v2 + 7) == dword_1008EF8E0 && *(unsigned __int16 *)(v2 + 11) == (unsigned __int16)word_1008EF8E4)
  {
    char v39 = (os_log_s *)qword_1008F7750;
    if (os_log_type_enabled((os_log_t)qword_1008F7750, OS_LOG_TYPE_FAULT)) {
      sub_10065D1E8(v39, v40, v41, v42, v43, v44, v45, v46);
    }
  }

  if (*(void *)v5 == qword_1008EF8E6 && *(void *)(v2 + 21) == unk_1008EF8EE)
  {
    double v48 = (os_log_s *)qword_1008F7750;
    if (os_log_type_enabled((os_log_t)qword_1008F7750, OS_LOG_TYPE_FAULT)) {
      sub_10065D178(v48, v49, v50, v51, v52, v53, v54, v55);
    }
  }

  return v2;
}

std::string *sub_1001FB0A8(std::string *result, int a2, std::string *a3)
{
  if (result)
  {
    if (a2 >= 1)
    {
      int v4 = result;
      uint64_t v5 = a2;
      do
      {
        __int16 v9 = 0;
        *(_DWORD *)__str = 0;
        int v6 = v4->__r_.__value_.__s.__data_[0];
        int v4 = (std::string *)((char *)v4 + 1);
        snprintf(__str, 6uLL, "0x%02x ", v6);
        uint64_t result = std::string::append(a3, __str);
        --v5;
      }

      while (v5);
    }

    if ((char)a3->__r_.__value_.__s.__size_ < 0)
    {
      uint64_t v7 = a3->__r_.__value_.__l.__size_ - 1;
      a3->__r_.__value_.__l.__size_ = v7;
      a3 = (std::string *)a3->__r_.__value_.__r.__words[0];
    }

    else
    {
      uint64_t v7 = a3->__r_.__value_.__s.__size_ - 1LL;
      a3->__r_.__value_.__s.__size_ = v7 & 0x7F;
    }

    a3->__r_.__value_.__s.__data_[v7] = 0;
  }

  return result;
}

uint64_t sub_1001FB154(uint64_t a1)
{
  uint64_t v1 = *(_BYTE **)a1;
  if (*(void *)(a1 + 8) - *(void *)a1 != 7LL || *v1 != 14 || v1[1] != 5) {
    return 3LL;
  }
  uint64_t v2 = v1[5];
  if (!v1[5]) {
    return 0LL;
  }
  int v3 = (os_log_s *)qword_1008F7750;
  if (os_log_type_enabled((os_log_t)qword_1008F7750, OS_LOG_TYPE_ERROR)) {
    sub_10065D418(v2, v3, v4, v5, v6, v7, v8, v9);
  }
  return 112LL;
}

char *sub_1001FB1DC(uint64_t a1, uint64_t a2)
{
  int v3 = (char *)operator new(0x3DuLL);
  *int v3 = 2;
  unsigned int v4 = *(unsigned __int8 *)(a2 + 40);
  v3[1] = v4;
  v3[60] = *(_BYTE *)(a2 + 44);
  uint64_t v5 = *(void *)a2;
  *((_WORD *)v3 + 1) = *(void *)a2;
  v3[4] = BYTE2(v5);
  v3[5] = BYTE3(v5);
  v3[6] = BYTE4(v5);
  v3[7] = BYTE5(v5);
  *(_OWORD *)(v3 + 24) = *(_OWORD *)sub_10056AAF0(a2 + 8);
  a2 += 24LL;
  sub_10056AAF0(a2);
  *(_OWORD *)(v3 + 8) = *(_OWORD *)sub_10056AAF0(a2);
  if (v4 >= 8)
  {
    uint64_t v6 = (os_log_s *)qword_1008F7750;
    if (os_log_type_enabled((os_log_t)qword_1008F7750, OS_LOG_TYPE_FAULT)) {
      sub_10065D5D0(v6, v7, v8, v9, v10, v11, v12, v13);
    }
  }

  if (*(_DWORD *)(v3 + 2) == dword_1008EF8E0 && *((unsigned __int16 *)v3 + 3) == (unsigned __int16)word_1008EF8E4)
  {
    uint64_t v15 = (os_log_s *)qword_1008F7750;
    if (os_log_type_enabled((os_log_t)qword_1008F7750, OS_LOG_TYPE_FAULT)) {
      sub_10065D560(v15, v16, v17, v18, v19, v20, v21, v22);
    }
  }

  if (*((void *)v3 + 3) == qword_1008EF8E6 && *((void *)v3 + 4) == unk_1008EF8EE)
  {
    uint64_t v24 = (os_log_s *)qword_1008F7750;
    if (os_log_type_enabled((os_log_t)qword_1008F7750, OS_LOG_TYPE_FAULT)) {
      sub_10065D4F0(v24, v25, v26, v27, v28, v29, v30, v31);
    }
  }

  if (*((void *)v3 + 1) == qword_1008EF8F6 && *((void *)v3 + 2) == unk_1008EF8FE)
  {
    uint64_t v33 = (os_log_s *)qword_1008F7750;
    if (os_log_type_enabled((os_log_t)qword_1008F7750, OS_LOG_TYPE_FAULT)) {
      sub_10065D480(v33, v34, v35, v36, v37, v38, v39, v40);
    }
  }

  return v3;
}

char *sub_1001FB390(uint64_t a1)
{
  uint64_t v2 = (char *)operator new(0x14uLL);
  *(_DWORD *)uint64_t v2 = 209715205;
  int v3 = *(_DWORD *)(a1 + 184);
  if (!v3)
  {
    int v3 = *(_DWORD *)(a1 + 212);
    if (v3)
    {
      id v24 = [*(id *)(a1 + 200) count];
      int v3 = *(_DWORD *)(a1 + 184);
      if (v24)
      {
        v3 |= 1u;
        *(_DWORD *)(a1 + 184) = v3;
      }
    }
  }

  v2[4] = v3;
  unsigned __int16 v4 = (unsigned __int16)[*(id *)(a1 + 192) count];
  *(_WORD *)(v2 + 5) = (unsigned __int16)[*(id *)(a1 + 200) count] + v4;
  int v5 = *(unsigned __int8 *)(a1 + 208);
  v2[7] = v5;
  unsigned __int16 v6 = (unsigned __int16)[*(id *)(a1 + 192) count];
  *((_WORD *)v2 + 4) = v6;
  *(_DWORD *)(v2 + 10) = *(_DWORD *)(a1 + 212);
  *((_WORD *)v2 + memset((char *)&v11[1] + 1, 0, 7) = (unsigned __int16)[*(id *)(a1 + 200) count];
  *((_DWORD *)v2 + 4) = 117440771;
  if (!v5)
  {
    uint64_t v7 = (os_log_s *)qword_1008F7750;
    if (os_log_type_enabled((os_log_t)qword_1008F7750, OS_LOG_TYPE_FAULT)) {
      sub_10065D6B0(v7, v8, v9, v10, v11, v12, v13, v14);
    }
  }

  if (!v6)
  {
    uint64_t v15 = (os_log_s *)qword_1008F7750;
    if (os_log_type_enabled((os_log_t)qword_1008F7750, OS_LOG_TYPE_FAULT)) {
      sub_10065D640(v15, v16, v17, v18, v19, v20, v21, v22);
    }
  }

  return v2;
}

char *sub_1001FB4B0(uint64_t a1, _DWORD *a2)
{
  unsigned __int16 v4 = (char *)operator new(0xE9uLL);
  *(_WORD *)unsigned __int16 v4 = 6;
  unint64_t v5 = (unsigned __int16)word_1008F709A;
  *((_WORD *)v4 + 1) = word_1008F709A;
  id v6 = [*(id *)(a1 + 192) count];
  unint64_t v7 = (unsigned __int16)word_1008F709A;
  id v8 = [*(id *)(a1 + 192) count];
  int v9 = (unsigned __int16)word_1008F709A;
  uint64_t v10 = 0LL;
  unsigned __int8 v11 = 0;
  *(_DWORD *)(v4 + 229) = 0;
  *(_OWORD *)(v4 + 213) = 0u;
  *(_OWORD *)(v4 + 19memset((char *)&v11[1] + 1, 0, 7) = 0u;
  *(_OWORD *)(v4 + 181) = 0u;
  *(_OWORD *)(v4 + 165) = 0u;
  *(_OWORD *)(v4 + 149) = 0u;
  *(_OWORD *)(v4 + 133) = 0u;
  *(_OWORD *)(v4 + 11memset((char *)&v11[1] + 1, 0, 7) = 0u;
  *(_OWORD *)(v4 + 101) = 0u;
  *(_OWORD *)(v4 + 85) = 0u;
  *(_OWORD *)(v4 + 69) = 0u;
  *(_OWORD *)(v4 + 53) = 0u;
  *(_OWORD *)(v4 + 3memset((char *)&v11[1] + 1, 0, 7) = 0u;
  *(_OWORD *)(v4 + 21) = 0u;
  uint64_t v12 = (id *)(a1 + 8LL * ((unint64_t)v6 <= v5) + 192);
  *(_OWORD *)(v4 + 5) = 0u;
  while ((unint64_t)[*v12 count] <= (unsigned __int16)v9)
  {
LABEL_10:
    v10 += 38LL;
    if (v10 == 228) {
      goto LABEL_15;
    }
  }

  uint64_t v13 = (void *)[*v12 objectAtIndexedSubscript:(unsigned __int16)v9];
  uint64_t v14 = v13;
  if (!v13)
  {
LABEL_9:

    goto LABEL_10;
  }

  if ((unint64_t)[v13 length] >= 7 && (unint64_t)objc_msgSend(v14, "length") < 0x26)
  {
    __int16 v18 = 0;
    int v17 = 0;
    objc_msgSend(v14, "getBytes:range:", &v17, 0, 6);
    sub_1001F0050((uint64_t)&v4[v10 + 5], (uint64_t)&v17, 6uLL);
    unsigned __int8 v15 = [v14 length];
    v4[v10 + 11] = v15 - 6;
    [v14 getBytes:&v4[v10 + 12] range:NSMakeRange(v15 - 6, 6)];
    ++v11;
    LOWORD(v9) = v9 + 1;
    goto LABEL_9;
  }

  if (os_log_type_enabled((os_log_t)qword_1008F7750, OS_LOG_TYPE_ERROR)) {
    sub_10065D720();
  }
  *a2 = 1404;

LABEL_15:
  v4[4] = v11;
  word_1008F709A += v11;
  return v4;
}

void sub_1001FB6A4(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

uint64_t sub_1001FB6B8(uint64_t a1, void *a2)
{
  id v3 = a2;
  if (*(_BYTE *)(a1 + 24) && *(_BYTE *)(a1 + 25))
  {
    if (*(void *)(a1 + 176) >= 8uLL)
    {
      if (os_log_type_enabled((os_log_t)qword_1008F7750, OS_LOG_TYPE_ERROR)) {
        sub_10065D74C();
      }
LABEL_26:
      uint64_t v4 = 1LL;
      goto LABEL_27;
    }

    sub_100241F90(uu2, v3);
    unint64_t v5 = (uint64_t **)(a1 + 160);
    if (a1 + 168 != sub_1001FDB10(a1 + 160, uu2))
    {
      if (os_log_type_enabled((os_log_t)qword_1008F7750, OS_LOG_TYPE_ERROR)) {
        sub_10065D898();
      }
      goto LABEL_26;
    }

    if (qword_1008D5F20 != -1) {
      dispatch_once(&qword_1008D5F20, &stru_100886D30);
    }
    if (!sub_10061C0F8(qword_1008D5F18, v3))
    {
      if (os_log_type_enabled((os_log_t)qword_1008F7750, OS_LOG_TYPE_ERROR)) {
        sub_10065D838();
      }
      goto LABEL_26;
    }

    int v36 = 0;
    memset(v35, 0, sizeof(v35));
    *(_OWORD *)uu2 = 0u;
    if (qword_1008D5F20 != -1) {
      dispatch_once(&qword_1008D5F20, &stru_100886D30);
    }
    sub_10062923C(qword_1008D5F18, v3, (uint64_t)uu2);
    __int128 v20 = 0u;
    __int128 v21 = 0u;
    __int128 v19 = 0u;
    if (qword_1008D5F30 != -1) {
      dispatch_once(&qword_1008D5F30, &stru_100886D70);
    }
    *(void *)&__int128 v19 = sub_1005CC198((uint64_t)off_1008D5F28, v3, 0);
    sub_10056AB04((void *)&v19 + 1, (char *)&v35[2] + 8, 0x10uLL);
    sub_10056AB04((void *)&v20 + 1, (char *)v35 + 12, 0x10uLL);
    uint64_t v6 = *(void *)(a1 + 176);
    DWORD2(v21) = v6;
    BYTE12(v21) = v6 == 0;
    if ((void)v19)
    {
      if (!sub_10056AAC8((uint64_t)&v19 + 8) && !sub_10056AAC8((uint64_t)&v20 + 8))
      {
        sub_100241F90(buf, v3);
        v18.__r_.__value_.__r.__words[0] = (std::string::size_type)buf;
        id v8 = sub_1001FD770( v5,  buf,  (uint64_t)&unk_1006C2518,  (const unsigned __int8 *__attribute__((__org_typedef(uuid_t))) *)&v18);
        sub_1001F9148((uint64_t)(v8 + 48), (uint64_t)&v19);
        int v9 = (os_log_s *)qword_1008F7750;
        if (os_log_type_enabled((os_log_t)qword_1008F7750, OS_LOG_TYPE_DEBUG))
        {
          sub_100241F90(uu1, v3);
          v18.__r_.__value_.__r.__words[0] = (std::string::size_type)uu1;
          uint64_t v10 = sub_1001FD770( v5,  uu1,  (uint64_t)&unk_1006C2518,  (const unsigned __int8 *__attribute__((__org_typedef(uuid_t))) *)&v18);
          id v11 = sub_1005BFB9C(*((void *)v10 + 6));
          id v12 = [v11 autorelease];
          sub_100241F90(v24, v3);
          __p.__r_.__value_.__r.__words[0] = (std::string::size_type)v24;
          uint64_t v13 = sub_1001FD770( v5,  v24,  (uint64_t)&unk_1006C2518,  (const unsigned __int8 *__attribute__((__org_typedef(uuid_t))) *)&__p);
          uint64_t v14 = &v18;
          sub_10056B0A4((uint64_t)(v13 + 56), &v18);
          if ((v18.__r_.__value_.__s.__size_ & 0x80u) != 0) {
            uint64_t v14 = (std::stringbuf::string_type *)v18.__r_.__value_.__r.__words[0];
          }
          sub_100241F90(v23, v3);
          uint64_t v22 = v23;
          unsigned __int8 v15 = sub_1001FD770( v5,  v23,  (uint64_t)&unk_1006C2518,  (const unsigned __int8 *__attribute__((__org_typedef(uuid_t))) *)&v22);
          sub_10056B0A4((uint64_t)(v15 + 72), &__p);
          if ((__p.__r_.__value_.__s.__size_ & 0x80u) == 0) {
            p_p = &__p;
          }
          else {
            p_p = (std::stringbuf::string_type *)__p.__r_.__value_.__r.__words[0];
          }
          *(_DWORD *)__int128 buf = 138413058;
          id v27 = v3;
          __int16 v28 = 2112;
          id v29 = v12;
          __int16 v30 = 2080;
          uint64_t v31 = v14;
          __int16 v32 = 2080;
          uint64_t v33 = p_p;
          _os_log_debug_impl( (void *)&_mh_execute_header,  v9,  OS_LOG_TYPE_DEBUG,  "Device %@ is added to the list with address: %@, irk: %s, ltk: %s",  buf,  0x2Au);
        }

        uint64_t v4 = 0LL;
        goto LABEL_31;
      }

      if (os_log_type_enabled((os_log_t)qword_1008F7750, OS_LOG_TYPE_ERROR)) {
        sub_10065D7D8();
      }
    }

    else if (os_log_type_enabled((os_log_t)qword_1008F7750, OS_LOG_TYPE_ERROR))
    {
      sub_10065D778();
    }

    uint64_t v4 = 1LL;
LABEL_31:
    *((void *)&v20 + 1) = &off_10087FAA8;
    if ((void)v21) {
      sub_1002CD254((unsigned int *)v21);
    }
    *((void *)&v19 + 1) = &off_10087FAA8;
    if ((void)v20) {
      sub_1002CD254((unsigned int *)v20);
    }
    goto LABEL_27;
  }

  if (os_log_type_enabled((os_log_t)qword_1008F7750, OS_LOG_TYPE_ERROR)) {
    sub_10065CB8C();
  }
  uint64_t v4 = 11LL;
LABEL_27:

  return v4;
}

void sub_1001FBBA0( _Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, void *__p, uint64_t a13, int a14, __int16 a15, char a16, char a17, uint64_t a18, uint64_t a19, uint64_t a20)
{
  if (a17 < 0) {
    operator delete(__p);
  }

  sub_1001F9194(&a18);
  _Unwind_Resume(a1);
}

uint64_t sub_1001FBC24(uint64_t a1, void *a2)
{
  id v3 = a2;
  if (*(_BYTE *)(a1 + 24) && *(_BYTE *)(a1 + 25))
  {
    sub_100241F90(uu2, v3);
    uint64_t v4 = (uint64_t *)sub_1001FDB10(a1 + 160, uu2);
    if ((uint64_t *)(a1 + 168) == v4)
    {
      if (os_log_type_enabled((os_log_t)qword_1008F7750, OS_LOG_TYPE_ERROR)) {
        sub_10065D8F8();
      }
      uint64_t v5 = 1LL;
    }

    else
    {
      sub_1001FDBCC((uint64_t **)(a1 + 160), v4);
      sub_1001FD610(v4 + 4);
      operator delete(v4);
      uint64_t v5 = 0LL;
    }
  }

  else
  {
    if (os_log_type_enabled((os_log_t)qword_1008F7750, OS_LOG_TYPE_ERROR)) {
      sub_10065CB8C();
    }
    uint64_t v5 = 11LL;
  }

  return v5;
}

void sub_1001FBD44(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

uint64_t sub_1001FBD5C(uint64_t a1, uint64_t **a2)
{
  if (*(_BYTE *)(a1 + 24) && *(_BYTE *)(a1 + 25))
  {
    uint64_t v2 = *(void **)(a1 + 160);
    id v3 = (void *)(a1 + 168);
    if (v2 != (void *)(a1 + 168))
    {
      uint64_t v5 = (uint64_t)(a2 + 2);
      do
      {
        __int128 v34 = 0u;
        __int128 v35 = 0u;
        __int128 v32 = 0u;
        __int128 v33 = 0u;
        sub_1001FD498((uint64_t)&v32, (uint64_t)(v2 + 4));
        uint64_t v6 = sub_100241F94((const unsigned __int8 *)&v32);
        uint64_t v7 = objc_claimAutoreleasedReturnValue(v6);
        uint64_t v8 = v7;
        uint64_t v10 = a2[1];
        unint64_t v9 = (unint64_t)a2[2];
        if ((unint64_t)v10 >= v9)
        {
          uint64_t v12 = v10 - *a2;
          uint64_t v13 = v9 - (void)*a2;
          uint64_t v14 = v13 >> 2;
          else {
            unint64_t v15 = v14;
          }
          uint64_t v31 = v5;
          if (v15) {
            uint64_t v16 = (char *)sub_100008BA0(v5, v15);
          }
          else {
            uint64_t v16 = 0LL;
          }
          int v17 = (uint64_t *)&v16[8 * v12];
          std::stringbuf::string_type v18 = &v16[8 * v15];
          __int16 v30 = v18;
          *int v17 = v8;
          id v11 = v17 + 1;
          v29.i64[1] = (uint64_t)(v17 + 1);
          __int128 v20 = *a2;
          __int128 v19 = a2[1];
          if (v19 == *a2)
          {
            int64x2_t v22 = vdupq_n_s64((unint64_t)v19);
          }

          else
          {
            do
            {
              uint64_t v21 = *--v19;
              *__int128 v19 = 0LL;
              *--int v17 = v21;
            }

            while (v19 != v20);
            int64x2_t v22 = *(int64x2_t *)a2;
            id v11 = (uint64_t *)v29.i64[1];
            std::stringbuf::string_type v18 = v30;
          }

          *a2 = v17;
          a2[1] = v11;
          int64x2_t v29 = v22;
          uint64_t v23 = (char *)a2[2];
          a2[2] = (uint64_t *)v18;
          __int16 v30 = v23;
          uint64_t v28 = v22.i64[0];
          sub_1001FDFC0((uint64_t)&v28);
        }

        else
        {
          *uint64_t v10 = v7;
          id v11 = v10 + 1;
        }

        a2[1] = v11;
        *((void *)&v34 + 1) = &off_10087FAA8;
        if ((void)v35) {
          sub_1002CD254((unsigned int *)v35);
        }
        *((void *)&v33 + 1) = &off_10087FAA8;
        if ((void)v34) {
          sub_1002CD254((unsigned int *)v34);
        }
        id v24 = (void *)v2[1];
        if (v24)
        {
          do
          {
            uint64_t v25 = v24;
            id v24 = (void *)*v24;
          }

          while (v24);
        }

        else
        {
          do
          {
            uint64_t v25 = (void *)v2[2];
            BOOL v26 = *v25 == (void)v2;
            uint64_t v2 = v25;
          }

          while (!v26);
        }

        uint64_t v2 = v25;
      }

      while (v25 != v3);
    }

    return 0LL;
  }

  else
  {
    if (os_log_type_enabled((os_log_t)qword_1008F7750, OS_LOG_TYPE_ERROR)) {
      sub_10065CB8C();
    }
    return 11LL;
  }

void sub_1001FBF80( _Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, ...)
{
  sub_1001FAC24((uint64_t *)va);
  _Unwind_Resume(a1);
}

uint64_t sub_1001FBFAC(uint64_t a1)
{
  if (*(_BYTE *)(a1 + 24) && *(_BYTE *)(a1 + 25))
  {
    uint64_t v1 = (void *)(a1 + 168);
    sub_1001FD5C8(a1 + 160, *(void **)(a1 + 168));
    uint64_t result = 0LL;
    *(v1 - 1) = v1;
    *uint64_t v1 = 0LL;
    v1[1] = 0LL;
  }

  else
  {
    if (os_log_type_enabled((os_log_t)qword_1008F7750, OS_LOG_TYPE_ERROR)) {
      sub_10065CB8C();
    }
    return 11LL;
  }

  return result;
}

uint64_t sub_1001FC020(uint64_t a1, unsigned int a2, void *a3, int a4)
{
  id v8 = a3;
  if (*(_BYTE *)(a1 + 27))
  {
LABEL_2:
    uint64_t v9 = 0LL;
    goto LABEL_3;
  }

  if (a2 == 255)
  {
    uint64_t v12 = (os_log_s *)qword_1008F7750;
    if (os_log_type_enabled((os_log_t)qword_1008F7750, OS_LOG_TYPE_DEFAULT))
    {
      LOWORD(v13) = 0;
      _os_log_impl( (void *)&_mh_execute_header,  v12,  OS_LOG_TYPE_DEFAULT,  "setOfflineAdvertisingDataAndPayload Done!",  (uint8_t *)&v13,  2u);
    }

    uint64_t v13 = 0LL;
    uint64_t v14 = 0LL;
    sub_100242F28((uint64_t)&v13, (uint64_t)&unk_1008F7058);
    byte_1008F7098 = 0;
    sub_1002431FC(&stru_1008F7028);
    sub_100242FAC((uint64_t)&v13);
    goto LABEL_2;
  }

  id v11 = (os_log_s *)qword_1008F7750;
  if (a2 < 2)
  {
    if (os_log_type_enabled((os_log_t)qword_1008F7750, OS_LOG_TYPE_DEFAULT))
    {
      LODWORD(v13) = 67109634;
      HIDWORD(v13) = a2;
      LOWORD(v14) = 1024;
      *(_DWORD *)((char *)&v14 + 2) = a4;
      HIWORD(v14) = 2112;
      id v15 = v8;
      _os_log_impl( (void *)&_mh_execute_header,  v11,  OS_LOG_TYPE_DEFAULT,  "setOfflineAdvertisingDataAndPayload set:%d interval:%d data:%@",  (uint8_t *)&v13,  0x18u);
    }

    objc_storeStrong((id *)(a1 + 8LL * a2 + 192), a3);
    uint64_t v9 = 0LL;
    *(_DWORD *)(a1 + 4LL * a2 + 208) = a4;
  }

  else
  {
    if (os_log_type_enabled((os_log_t)qword_1008F7750, OS_LOG_TYPE_ERROR)) {
      sub_10065D958();
    }
    uint64_t v9 = 3LL;
  }

LABEL_3:
  return v9;
}

  if (os_log_type_enabled((os_log_t)qword_1008F7578, OS_LOG_TYPE_DEBUG)) {
    sub_1006679E4();
  }
  if (SHIBYTE(v10) < 0) {
    operator delete(__p);
  }
}

  if (os_log_type_enabled((os_log_t)qword_1008F7578, OS_LOG_TYPE_DEBUG)) {
    sub_100667A50();
  }
  if (SHIBYTE(v10) < 0) {
    operator delete(__p);
  }
}

  if (os_log_type_enabled((os_log_t)qword_1008F7578, OS_LOG_TYPE_DEBUG)) {
    sub_100667ABC();
  }
  if (SHIBYTE(v10) < 0) {
    operator delete(__p);
  }
}

  if (os_log_type_enabled((os_log_t)qword_1008F7578, OS_LOG_TYPE_DEBUG)) {
    sub_100667B28();
  }
  if (SHIBYTE(v10) < 0) {
    operator delete(__p);
  }
}

  if (os_log_type_enabled((os_log_t)qword_1008F7578, OS_LOG_TYPE_DEBUG)) {
    sub_100667B94();
  }
  if (SHIBYTE(v10) < 0) {
    operator delete(__p);
  }
}

      if ((v4 & 0x80) == 0) {
        goto LABEL_5;
      }
      goto LABEL_4;
    }
  }

  uint64_t v13 = 0LL;
  LODWORD(v6) = sub_1003C657C(uint64, &v13);
  uint64 = 0LL;
  if (!(_DWORD)v6)
  {
    uint64 = v13;
    uint64_t v7 = *(void *)(a1 + 72);
    id v8 = *(_DWORD *)(v7 + 40);
    asid = xpc_connection_get_asid(*(xpc_connection_t *)(v7 + 16));
    uint64_t v10 = (os_log_s *)qword_1008F75F0;
    if (os_log_type_enabled((os_log_t)qword_1008F75F0, OS_LOG_TYPE_DEBUG))
    {
      *(_DWORD *)__int128 buf = 134218496;
      id v15 = v13;
      uint64_t v16 = 1024;
      int v17 = v8;
      std::stringbuf::string_type v18 = 2048;
      __int128 v19 = asid;
      _os_log_debug_impl( (void *)&_mh_execute_header,  v10,  OS_LOG_TYPE_DEBUG,  "Adding identifier mapping localDevice:%llx pid:%d asid:%llx",  buf,  0x1Cu);
    }

    if (qword_1008D61A8 != -1) {
      dispatch_once(&qword_1008D61A8, &stru_100891CE8);
    }
    sub_1004973F0(qword_1008D61A0, v13, v8, asid);
  }

  uint64_t v6 = (int)v6;
LABEL_12:
  reply = xpc_dictionary_create_reply(xdict);
  if (reply)
  {
    uint64_t v12 = reply;
    xpc_dictionary_set_uint64(reply, "kCBMsgArgLocalDeviceID", uint64);
    xpc_dictionary_set_uint64(v12, "kCBMsgArgResult", v6);
    xpc_connection_send_message(*(xpc_connection_t *)(*(void *)(a1 + 72) + 16LL), v12);
    xpc_release(v12);
  }

  if (qword_1008D61A8 != -1) {
    dispatch_once(&qword_1008D61A8, &stru_100891CE8);
  }
  sub_1004980E4(qword_1008D61A0, uint64, v6);
  uint64_t v7 = 0LL;
LABEL_8:
  reply = xpc_dictionary_create_reply(xdict);
  if (reply)
  {
    uint64_t v9 = reply;
    xpc_dictionary_set_uint64(reply, "kCBMsgArgResult", v7);
    xpc_connection_send_message(*(xpc_connection_t *)(*(void *)(a1 + 72) + 16LL), v9);
    xpc_release(v9);
  }

  LODWORD(uint64) = sub_1003C6B0C(uint64, v6, (int *)&value);
  uint64_t v7 = (os_log_s *)qword_1008F75F0;
  if (os_log_type_enabled((os_log_t)qword_1008F75F0, OS_LOG_TYPE_DEBUG)) {
    sub_10066CDB0((int *)&value, v7);
  }
  uint64 = (int)uint64;
LABEL_8:
  reply = xpc_dictionary_create_reply(xdict);
  if (reply)
  {
    uint64_t v9 = reply;
    xpc_dictionary_set_uint64(reply, "kCBMsgArgResult", uint64);
    xpc_dictionary_set_uint64(v9, "kCBMsgArgBTPowerMode", value);
    xpc_connection_send_message(*(xpc_connection_t *)(*(void *)(a1 + 72) + 16LL), v9);
    xpc_release(v9);
  }

  if (qword_1008D5F00 != -1) {
    dispatch_once(&qword_1008D5F00, &stru_100891D08);
  }
  uint64_t v7 = sub_100406554((uint64_t)off_1008D5EF8, uint64);
  if (v7)
  {
    id v8 = sub_100409680(v7, &__p);
    if (!v8)
    {
      size = __p.__r_.__value_.__s.__size_;
      if ((__p.__r_.__value_.__s.__size_ & 0x80u) != 0) {
        size = __p.__r_.__value_.__l.__size_;
      }
      if (v6 >= size + 1) {
        id v8 = 0;
      }
      else {
        id v8 = 5;
      }
    }
  }

  else
  {
    id v8 = 7;
  }

  if (v6 >= 0x200) {
    uint64_t v7 = 512LL;
  }
  else {
    uint64_t v7 = v6;
  }
  id v8 = (int)sub_1003C21F8(uint64, (char *)v11, v7);
LABEL_9:
  reply = xpc_dictionary_create_reply(xdict);
  if (reply)
  {
    uint64_t v10 = reply;
    xpc_dictionary_set_uint64(reply, "kCBMsgArgResult", v8);
    xpc_dictionary_set_string(v10, "kCBMsgArgAddressString", (const char *)v11);
    xpc_connection_send_message(*(xpc_connection_t *)(*(void *)(a1 + 72) + 16LL), v10);
    xpc_release(v10);
  }

  if (v6 >= 0x100) {
    uint64_t v7 = 256LL;
  }
  else {
    uint64_t v7 = v6;
  }
  id v8 = (int)sub_1003C26C8(uint64, (char *)v11, v7);
LABEL_9:
  reply = xpc_dictionary_create_reply(xdict);
  if (reply)
  {
    uint64_t v10 = reply;
    xpc_dictionary_set_uint64(reply, "kCBMsgArgResult", v8);
    xpc_dictionary_set_string(v10, "kCBMsgArgName", (const char *)v11);
    xpc_connection_send_message(*(xpc_connection_t *)(*(void *)(a1 + 72) + 16LL), v10);
    xpc_release(v10);
  }

  if (v6 >= 0x100) {
    uint64_t v7 = 256LL;
  }
  else {
    uint64_t v7 = v6;
  }
  id v8 = (int)sub_1003C28F0(uint64, (char *)v11, v7);
LABEL_9:
  reply = xpc_dictionary_create_reply(xdict);
  if (reply)
  {
    uint64_t v10 = reply;
    xpc_dictionary_set_uint64(reply, "kCBMsgArgResult", v8);
    xpc_dictionary_set_string(v10, "kCBMsgArgName", (const char *)v11);
    xpc_connection_send_message(*(xpc_connection_t *)(*(void *)(a1 + 72) + 16LL), v10);
    xpc_release(v10);
  }

  if (v6 >= 0x100) {
    uint64_t v7 = 256LL;
  }
  else {
    uint64_t v7 = v6;
  }
  id v8 = (int)sub_1003C2B80(uint64, (char *)v11, v7);
LABEL_9:
  reply = xpc_dictionary_create_reply(xdict);
  if (reply)
  {
    uint64_t v10 = reply;
    xpc_dictionary_set_uint64(reply, "kCBMsgArgResult", v8);
    xpc_dictionary_set_string(v10, "kCBMsgArgName", (const char *)v11);
    xpc_connection_send_message(*(xpc_connection_t *)(*(void *)(a1 + 72) + 16LL), v10);
    xpc_release(v10);
  }

  if (qword_1008D5F50 != -1) {
    dispatch_once(&qword_1008D5F50, &stru_100895658);
  }
  uint64_t v5 = sub_1003FFEB0(off_1008D5F48, (uint64_t)&v12, 1);
  if (!v5) {
    return 8LL;
  }
  uint64_t v6 = (uint64_t)v5;
  if (qword_1008D5F50 != -1)
  {
    id v11 = (uint64_t)v5;
    dispatch_once(&qword_1008D5F50, &stru_100895658);
    uint64_t v6 = v11;
  }

  uint64_t v7 = sub_1003FEFA8((uint64_t)off_1008D5F48, a1, v6);
  *a3 = v7;
  if (v7) {
    return 0LL;
  }
  else {
    return 7LL;
  }
}

  if (*(_OWORD *)(a1 + 49) == 0LL || !*(_BYTE *)(a1 + 241))
  {
    id v15 = (os_log_s *)qword_1008F7600;
    if (os_log_type_enabled((os_log_t)qword_1008F7600, OS_LOG_TYPE_DEFAULT))
    {
      uint64_t v16 = *(unsigned __int8 *)(a1 + 241);
      *(_DWORD *)std::stringbuf::string_type __p = 67109120;
      *(_DWORD *)&__p[4] = v16;
      _os_log_impl( (void *)&_mh_execute_header,  v15,  OS_LOG_TYPE_DEFAULT,  "Device not signed in / master key not available. signed in = %d",  __p,  8u);
    }

    return 1LL;
  }

  if (*(_BYTE *)(a1 + 240))
  {
    v30[0] = 0LL;
    v30[1] = 0LL;
    sub_100242F28((uint64_t)v30, a1 + 104);
    uint64_t v6 = (os_log_s *)(id)qword_1008F7600;
    if (os_log_type_enabled(v6, OS_LOG_TYPE_DEFAULT))
    {
      sub_1003CF00C((uint64_t)a2, __p);
      uint64_t v7 = v37 >= 0 ? __p : *(_BYTE **)__p;
      *(_DWORD *)__int128 buf = 136446466;
      *(void *)&uint8_t buf[4] = v7;
      __int128 v32 = 1024;
      __int128 v33 = a3;
      _os_log_impl( (void *)&_mh_execute_header,  v6,  OS_LOG_TYPE_DEFAULT,  "MagicPairingManager::updateDeviceRatchet from device %{public}s, ratchet %d",  buf,  0x12u);
      if (SHIBYTE(v37) < 0) {
        operator delete(*(void **)__p);
      }
    }

    id v8 = *(unsigned __int8 ****)(a1 + 184);
    uint64_t v9 = *(unsigned __int8 ****)(a1 + 176);
    if (v9 == v8)
    {
LABEL_16:
      id v11 = (char *)operator new(0x78uLL);
      uint64_t v12 = v11;
      *((void *)v11 + 11) = 0LL;
      uint64_t v13 = (void **)(v11 + 88);
      *((void *)v11 + 12) = 0LL;
      *((void *)v11 + 13) = 0LL;
      v11[112] = -1;
      *(void *)id v11 = a2;
      *((_DWORD *)v11 + 21) = 0;
      *(_OWORD *)(v11 + 8) = 0u;
      *(_OWORD *)(v11 + 24) = 0u;
      *(_OWORD *)(v11 + 40) = 0u;
      *(_OWORD *)(v11 + 56) = 0u;
      *((_DWORD *)v11 + 18) = 0;
      int64x2_t v29 = (unsigned __int8 **)v11;
      if (a3) {
        *((_DWORD *)v11 + 18) = a3;
      }
      if (sub_1003F01F0((uint64_t *)v11, a1 + 49, a1 + 65))
      {
        if (os_log_type_enabled((os_log_t)qword_1008F7600, OS_LOG_TYPE_ERROR)) {
          sub_10067A628();
        }
        if (v12[111] < 0) {
          operator delete(*v13);
        }
        operator delete(v12);
LABEL_24:
        uint64_t v14 = 1LL;
LABEL_62:
        sub_100242FAC((uint64_t)v30);
        return v14;
      }

      sub_100381E90((void **)(a1 + 176), &v29);
      if (qword_1008D67B8 != -1) {
        dispatch_once(&qword_1008D67B8, &stru_100896238);
      }
      sub_10053645C((uint64_t)off_1008D67B0, a2);
    }

    else
    {
      uint64_t v10 = *(unsigned __int8 ****)(a1 + 176);
      while (**v10 != a2)
      {
        if (++v10 == v8) {
          goto LABEL_16;
        }
      }

      int64x2_t v22 = *v9;
      if (**v9 != a2)
      {
        uint64_t v23 = v9 + 1;
        do
        {
          id v24 = *v23++;
          int64x2_t v22 = v24;
        }

        while (*v24 != a2);
      }

      int64x2_t v29 = v22;
      uint64_t v25 = *((_DWORD *)v22 + 18);
      BOOL v26 = (os_log_s *)(id)qword_1008F7600;
      if (os_log_type_enabled(v26, OS_LOG_TYPE_DEFAULT))
      {
        sub_1003CF00C((uint64_t)a2, buf);
        id v27 = v34 >= 0 ? buf : *(_BYTE **)buf;
        *(_DWORD *)std::stringbuf::string_type __p = 136446722;
        *(void *)&__p[4] = v27;
        *(_WORD *)&__p[12] = 1024;
        *(_DWORD *)&__p[14] = v25;
        int v36 = 1024;
        uint64_t v37 = a3;
        _os_log_impl( (void *)&_mh_execute_header,  v26,  OS_LOG_TYPE_DEFAULT,  "MagicPairingManager::updateDeviceRatchet from device %{public}s, current %d -> new %d",  __p,  0x18u);
        if (v34 < 0) {
          operator delete(*(void **)buf);
        }
      }

      uint64_t v28 = a3 - v25;
      if (a3 == v25) {
        goto LABEL_61;
      }
      if (a3 > v25)
      {
        while (1)
        {
          *(void *)std::stringbuf::string_type __p = 0LL;
          *(void *)&__p[8] = 0LL;
          int64x2_t v22 = v29;
          *(_OWORD *)(v29 + 5) = *(_OWORD *)__p;
          if (!--v28)
          {
            uint64_t v25 = a3;
            goto LABEL_53;
          }
        }

        if (os_log_type_enabled((os_log_t)qword_1008F7600, OS_LOG_TYPE_ERROR)) {
          sub_10067A850();
        }
        goto LABEL_24;
      }

  uint64_t v13 = 0LL;
  LODWORD(v6) = sub_1003B4E30(uint64, &v13);
  uint64 = 0LL;
  if (!(_DWORD)v6)
  {
    uint64 = v13;
    uint64_t v7 = *(void *)(a1 + 72);
    id v8 = *(_DWORD *)(v7 + 40);
    asid = xpc_connection_get_asid(*(xpc_connection_t *)(v7 + 16));
    if (qword_1008D61A8 != -1)
    {
      uint64_t v12 = asid;
      dispatch_once(&qword_1008D61A8, &stru_10089F278);
      asid = v12;
    }

    sub_1004973F0(qword_1008D61A0, v13, v8, asid);
  }

  uint64_t v6 = (int)v6;
LABEL_10:
  reply = xpc_dictionary_create_reply(xdict);
  if (reply)
  {
    id v11 = reply;
    xpc_dictionary_set_uint64(reply, "kCBMsgArgAccessoryManagerID", uint64);
    xpc_dictionary_set_uint64(v11, "kCBMsgArgResult", v6);
    xpc_connection_send_message(*(xpc_connection_t *)(*(void *)(a1 + 72) + 16LL), v11);
    xpc_release(v11);
  }

  uint64_t v7 = (uint64_t *)*a2;
  if (*a1 == a2)
  {
    uint64_t v9 = a2;
  }

  else
  {
    if (v7)
    {
      id v8 = (uint64_t *)*a2;
      do
      {
        uint64_t v9 = v8;
        id v8 = (uint64_t *)v8[1];
      }

      while (v8);
    }

    else
    {
      uint64_t v12 = a2;
      do
      {
        uint64_t v9 = (uint64_t *)v12[2];
        uint64_t v13 = *v9 == (void)v12;
        uint64_t v12 = v9;
      }

      while (v13);
    }

    uint64_t v14 = *((_DWORD *)v9 + 7);
    if (v14 >= *a5 && (*a5 < v14 || *((_DWORD *)v9 + 8) >= a5[1])) {
      return sub_100550C90((uint64_t)a1, a3, a5);
    }
  }

  if (v7)
  {
    *a3 = v9;
    return v9 + 1;
  }

  else
  {
    *a3 = a2;
    return a2;
  }

  if (v7) {
    free(v7);
  }
  reply = xpc_dictionary_create_reply(xdict);
  xpc_dictionary_set_uint64(reply, "kCBMsgArgStatus", v8);
  xpc_connection_send_message(*(xpc_connection_t *)(*(void *)(a1 + 72) + 16LL), reply);
  xpc_release(reply);
}

  if (v7) {
    free(v7);
  }
  reply = xpc_dictionary_create_reply(xdict);
  xpc_dictionary_set_uint64(reply, "kCBMsgArgStatus", v8);
  xpc_connection_send_message(*(xpc_connection_t *)(*(void *)(a1 + 72) + 16LL), reply);
  xpc_release(reply);
}

void sub_1001FC1D4( _Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9)
{
  _Unwind_Resume(a1);
}

uint64_t sub_1001FC1FC(uint64_t a1, void *a2)
{
  uint64_t v14 = a1;
  __int128 v28 = 0u;
  __int128 v29 = 0u;
  __int128 v30 = 0u;
  __int128 v31 = 0u;
  obuint64_t j = a2;
  id v18 = [obj countByEnumeratingWithState:&v28 objects:v34 count:16];
  if (v18)
  {
    int v16 = 0;
    uint64_t v17 = *(void *)v29;
    while (2)
    {
      for (uint64_t i = 0LL; i != v18; uint64_t i = (char *)i + 1)
      {
        if (*(void *)v29 != v17) {
          objc_enumerationMutation(obj);
        }
        id v20 = *(id *)(*((void *)&v28 + 1) + 8LL * (void)i);
        uint64_t v2 = objc_alloc_init(&OBJC_CLASS___NSMutableArray);
        uint64_t v23 = (void *)[v20 objectForKey:@"kCBMsgArgOfflineAdvertisingData"];
        uint64_t v3 = [v20 objectForKey:@"kCBMsgArgOfflineAdvertisingRotationInterval"];
        uint64_t v21 = (void *)v3;
        if (v23) {
          BOOL v4 = v3 == 0;
        }
        else {
          BOOL v4 = 1;
        }
        int v5 = !v4;
        int v19 = v5;
        if (!v4)
        {
          __int128 v26 = 0u;
          __int128 v27 = 0u;
          __int128 v24 = 0u;
          __int128 v25 = 0u;
          id v6 = v23;
          id v7 = [v6 countByEnumeratingWithState:&v24 objects:v33 count:16];
          if (v7)
          {
            uint64_t v8 = *(void *)v25;
            do
            {
              for (uint64_t j = 0LL; j != v7; uint64_t j = (char *)j + 1)
              {
                if (*(void *)v25 != v8) {
                  objc_enumerationMutation(v6);
                }
                uint64_t v10 = *(void **)(*((void *)&v24 + 1) + 8LL * (void)j);
                memset(v32, 0, 37);
                objc_msgSend(v10, "getBytes:range:", v32, 0, 6, v14);
                objc_msgSend(v10, "getBytes:range:", (char *)v32 + 13, 6, 22);
                *(_DWORD *)((char *)v32 + 9) = 1643008;
                *(_DWORD *)((char *)v32 + 6) = 5046046;
                BYTE3(v32[2]) = BYTE3(v32[2]) & 0xFC | (LOBYTE(v32[0]) >> 6);
                LOBYTE(v32[0]) |= 0xC0u;
                id v11 = [NSData dataWithBytes:v32 length:37];
                -[NSMutableArray addObject:](v2, "addObject:", v11);
              }

              id v7 = [v6 countByEnumeratingWithState:&v24 objects:v33 count:16];
            }

            while (v7);
          }

          sub_1001FC020(v14, v16++, v2, (int)[v21 intValue]);
        }

        if (!v19)
        {

          uint64_t v12 = 3LL;
          goto LABEL_26;
        }
      }

      id v18 = [obj countByEnumeratingWithState:&v28 objects:v34 count:16];
      if (v18) {
        continue;
      }
      break;
    }
  }

  sub_1001FC020(v14, 0xFFu, 0LL, -1);
  uint64_t v12 = 0LL;
LABEL_26:

  return v12;
}

void sub_1001FC51C( _Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, void *a10)
{
}

void sub_1001FC5C0(uint64_t a1)
{
  uint64_t v1 = (void *)sub_1001FD524(a1);
  operator delete(v1);
}

uint64_t sub_1001FC5D4()
{
  return 1LL;
}

uint64_t sub_1001FC5DC()
{
  return 1LL;
}

void sub_1001FC5E4(uint64_t a1, uint64_t a2)
{
  int v5 = *(char **)(a1 + 8);
  BOOL v4 = *(char **)(a1 + 16);
  if (v5 != v4)
  {
    while (*(void *)v5 != a2)
    {
      v5 += 8;
      if (v5 == v4)
      {
        int v5 = *(char **)(a1 + 16);
        break;
      }
    }
  }

  if (v5 == v4)
  {
    uint64_t v6 = a2;
    sub_1001FC66C(a1 + 8, v4, (char *)&v6);
    sub_100008A30(a1 + 8);
  }

  os_unfair_lock_unlock((os_unfair_lock_t)a1);
}

char *sub_1001FC66C(uint64_t a1, char *__src, char *a3)
{
  uint64_t v3 = a3;
  BOOL v4 = __src;
  uint64_t v6 = *(char **)(a1 + 8);
  uint64_t v8 = a1 + 16;
  unint64_t v7 = *(void *)(a1 + 16);
  if ((unint64_t)v6 >= v7)
  {
    uint64_t v13 = *(char **)a1;
    unint64_t v14 = ((uint64_t)&v6[-*(void *)a1] >> 3) + 1;
    if (v14 >> 61) {
      abort();
    }
    uint64_t v15 = __src - v13;
    uint64_t v16 = (__src - v13) >> 3;
    uint64_t v17 = v7 - (void)v13;
    if (v17 >> 2 > v14) {
      unint64_t v14 = v17 >> 2;
    }
    else {
      unint64_t v18 = v14;
    }
    uint64_t v30 = a1 + 16;
    if (v18) {
      int v19 = (char *)sub_100008BA0(a1 + 16, v18);
    }
    else {
      int v19 = 0LL;
    }
    id v20 = &v19[8 * v16];
    std::stringbuf::string_type __p = v19;
    __int128 v27 = v20;
    __int128 v28 = v20;
    __int128 v29 = &v19[8 * v18];
    if (v16 == v18)
    {
      if (v15 < 1)
      {
        if (v13 == v4) {
          unint64_t v22 = 1LL;
        }
        else {
          unint64_t v22 = v15 >> 2;
        }
        uint64_t v23 = (char *)sub_100008BA0(v8, v22);
        id v20 = &v23[8 * (v22 >> 2)];
        std::stringbuf::string_type __p = v23;
        __int128 v27 = v20;
        __int128 v29 = &v23[8 * v24];
        if (v19) {
          operator delete(v19);
        }
      }

      else
      {
        unint64_t v21 = v16 + 2;
        if (v16 >= -1) {
          unint64_t v21 = v16 + 1;
        }
        v20 -= 8 * (v21 >> 1);
        __int128 v27 = v20;
      }
    }

    *(void *)id v20 = *(void *)v3;
    __int128 v28 = v20 + 8;
    BOOL v4 = sub_100008ADC((void **)a1, (uint64_t)&__p, v4);
    if (v28 != v27) {
      v28 += (v27 - v28 + 7) & 0xFFFFFFFFFFFFFFF8LL;
    }
    if (__p) {
      operator delete(__p);
    }
  }

  else if (__src == v6)
  {
    *(void *)__src = *(void *)a3;
    *(void *)(a1 + 8) = __src + 8;
  }

  else
  {
    uint64_t v9 = __src + 8;
    uint64_t v10 = v6 - 8;
    id v11 = *(void **)(a1 + 8);
    while (v10 < v6)
    {
      uint64_t v12 = *(void *)v10;
      v10 += 8;
      *v11++ = v12;
    }

    *(void *)(a1 + 8) = v11;
    if (v6 != v9) {
      memmove(&v6[-8 * ((v6 - v9) >> 3)], __src, v6 - v9);
    }
    if (v4 <= v3) {
      v3 += 8 * (*(void *)(a1 + 8) > (unint64_t)v3);
    }
    *(void *)BOOL v4 = *(void *)v3;
  }

  return v4;
}

void sub_1001FC870( _Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void *__p, uint64_t a11, uint64_t a12)
{
  if (__p) {
    operator delete(__p);
  }
  _Unwind_Resume(exception_object);
}

void sub_1001FC8A8(uint64_t a1, uint64_t a2)
{
  BOOL v4 = *(char **)(a1 + 8);
  int v5 = *(char **)(a1 + 16);
  if (v4 == v5)
  {
    uint64_t v6 = *(char **)(a1 + 8);
    goto LABEL_10;
  }

  uint64_t v6 = *(char **)(a1 + 8);
  while (*(void *)v6 != a2)
  {
    v6 += 8;
    if (v6 == v5)
    {
      uint64_t v6 = *(char **)(a1 + 16);
      break;
    }
  }

  if (v6 == v5)
  {
    if (v4 != v5)
    {
LABEL_11:
      uint64_t v7 = a2;
      sub_1001FC95C(a1 + 8, v6, (char *)&v7);
      sub_100008A30(a1 + 8);
      goto LABEL_12;
    }

char *sub_1001FC95C(uint64_t a1, char *__src, char *a3)
{
  uint64_t v3 = a3;
  BOOL v4 = __src;
  uint64_t v6 = *(char **)(a1 + 8);
  uint64_t v8 = a1 + 16;
  unint64_t v7 = *(void *)(a1 + 16);
  if ((unint64_t)v6 >= v7)
  {
    uint64_t v13 = *(char **)a1;
    unint64_t v14 = ((uint64_t)&v6[-*(void *)a1] >> 3) + 1;
    if (v14 >> 61) {
      abort();
    }
    uint64_t v15 = __src - v13;
    uint64_t v16 = (__src - v13) >> 3;
    uint64_t v17 = v7 - (void)v13;
    if (v17 >> 2 > v14) {
      unint64_t v14 = v17 >> 2;
    }
    else {
      unint64_t v18 = v14;
    }
    uint64_t v30 = a1 + 16;
    if (v18) {
      int v19 = (char *)sub_100008BA0(a1 + 16, v18);
    }
    else {
      int v19 = 0LL;
    }
    id v20 = &v19[8 * v16];
    std::stringbuf::string_type __p = v19;
    __int128 v27 = v20;
    __int128 v28 = v20;
    __int128 v29 = &v19[8 * v18];
    if (v16 == v18)
    {
      if (v15 < 1)
      {
        if (v13 == v4) {
          unint64_t v22 = 1LL;
        }
        else {
          unint64_t v22 = v15 >> 2;
        }
        uint64_t v23 = (char *)sub_100008BA0(v8, v22);
        id v20 = &v23[8 * (v22 >> 2)];
        std::stringbuf::string_type __p = v23;
        __int128 v27 = v20;
        __int128 v29 = &v23[8 * v24];
        if (v19) {
          operator delete(v19);
        }
      }

      else
      {
        unint64_t v21 = v16 + 2;
        if (v16 >= -1) {
          unint64_t v21 = v16 + 1;
        }
        v20 -= 8 * (v21 >> 1);
        __int128 v27 = v20;
      }
    }

    *(void *)id v20 = *(void *)v3;
    __int128 v28 = v20 + 8;
    BOOL v4 = sub_100008ADC((void **)a1, (uint64_t)&__p, v4);
    if (v28 != v27) {
      v28 += (v27 - v28 + 7) & 0xFFFFFFFFFFFFFFF8LL;
    }
    if (__p) {
      operator delete(__p);
    }
  }

  else if (__src == v6)
  {
    *(void *)__src = *(void *)a3;
    *(void *)(a1 + 8) = __src + 8;
  }

  else
  {
    uint64_t v9 = __src + 8;
    uint64_t v10 = v6 - 8;
    id v11 = *(void **)(a1 + 8);
    while (v10 < v6)
    {
      uint64_t v12 = *(void *)v10;
      v10 += 8;
      *v11++ = v12;
    }

    *(void *)(a1 + 8) = v11;
    if (v6 != v9) {
      memmove(&v6[-8 * ((v6 - v9) >> 3)], __src, v6 - v9);
    }
    if (v4 <= v3) {
      v3 += 8 * (*(void *)(a1 + 8) > (unint64_t)v3);
    }
    *(void *)BOOL v4 = *(void *)v3;
  }

  return v4;
}

void sub_1001FCB60( _Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void *__p, uint64_t a11, uint64_t a12)
{
  if (__p) {
    operator delete(__p);
  }
  _Unwind_Resume(exception_object);
}

void sub_1001FCB98(uint64_t a1, uint64_t a2)
{
  BOOL v4 = *(char **)(a1 + 8);
  int v5 = *(char **)(a1 + 16);
  if (v4 == v5)
  {
    uint64_t v6 = *(char **)(a1 + 8);
    goto LABEL_10;
  }

  uint64_t v6 = *(char **)(a1 + 8);
  while (*(void *)v6 != a2)
  {
    v6 += 8;
    if (v6 == v5)
    {
      uint64_t v6 = *(char **)(a1 + 16);
      break;
    }
  }

  if (v6 == v5)
  {
    if (v4 != v5)
    {
LABEL_11:
      uint64_t v7 = a2;
      sub_1001FCC4C(a1 + 8, v6, (char *)&v7);
      sub_100008A30(a1 + 8);
      goto LABEL_12;
    }

char *sub_1001FCC4C(uint64_t a1, char *__src, char *a3)
{
  uint64_t v3 = a3;
  BOOL v4 = __src;
  uint64_t v6 = *(char **)(a1 + 8);
  uint64_t v8 = a1 + 16;
  unint64_t v7 = *(void *)(a1 + 16);
  if ((unint64_t)v6 >= v7)
  {
    uint64_t v13 = *(char **)a1;
    unint64_t v14 = ((uint64_t)&v6[-*(void *)a1] >> 3) + 1;
    if (v14 >> 61) {
      abort();
    }
    uint64_t v15 = __src - v13;
    uint64_t v16 = (__src - v13) >> 3;
    uint64_t v17 = v7 - (void)v13;
    if (v17 >> 2 > v14) {
      unint64_t v14 = v17 >> 2;
    }
    else {
      unint64_t v18 = v14;
    }
    uint64_t v30 = a1 + 16;
    if (v18) {
      int v19 = (char *)sub_100008BA0(a1 + 16, v18);
    }
    else {
      int v19 = 0LL;
    }
    id v20 = &v19[8 * v16];
    std::stringbuf::string_type __p = v19;
    __int128 v27 = v20;
    __int128 v28 = v20;
    __int128 v29 = &v19[8 * v18];
    if (v16 == v18)
    {
      if (v15 < 1)
      {
        if (v13 == v4) {
          unint64_t v22 = 1LL;
        }
        else {
          unint64_t v22 = v15 >> 2;
        }
        uint64_t v23 = (char *)sub_100008BA0(v8, v22);
        id v20 = &v23[8 * (v22 >> 2)];
        std::stringbuf::string_type __p = v23;
        __int128 v27 = v20;
        __int128 v29 = &v23[8 * v24];
        if (v19) {
          operator delete(v19);
        }
      }

      else
      {
        unint64_t v21 = v16 + 2;
        if (v16 >= -1) {
          unint64_t v21 = v16 + 1;
        }
        v20 -= 8 * (v21 >> 1);
        __int128 v27 = v20;
      }
    }

    *(void *)id v20 = *(void *)v3;
    __int128 v28 = v20 + 8;
    BOOL v4 = sub_100008ADC((void **)a1, (uint64_t)&__p, v4);
    if (v28 != v27) {
      v28 += (v27 - v28 + 7) & 0xFFFFFFFFFFFFFFF8LL;
    }
    if (__p) {
      operator delete(__p);
    }
  }

  else if (__src == v6)
  {
    *(void *)__src = *(void *)a3;
    *(void *)(a1 + 8) = __src + 8;
  }

  else
  {
    uint64_t v9 = __src + 8;
    uint64_t v10 = v6 - 8;
    id v11 = *(void **)(a1 + 8);
    while (v10 < v6)
    {
      uint64_t v12 = *(void *)v10;
      v10 += 8;
      *v11++ = v12;
    }

    *(void *)(a1 + 8) = v11;
    if (v6 != v9) {
      memmove(&v6[-8 * ((v6 - v9) >> 3)], __src, v6 - v9);
    }
    if (v4 <= v3) {
      v3 += 8 * (*(void *)(a1 + 8) > (unint64_t)v3);
    }
    *(void *)BOOL v4 = *(void *)v3;
  }

  return v4;
}

void sub_1001FCE50( _Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void *__p, uint64_t a11, uint64_t a12)
{
  if (__p) {
    operator delete(__p);
  }
  _Unwind_Resume(exception_object);
}

uint64_t sub_1001FCE88()
{
  io_iterator_t existing = 0;
  uint64_t v0 = IOServiceNameMatching("AppleDialogSPMIPMU");
  if (IOServiceGetMatchingServices(kIOMainPortDefault, v0, &existing))
  {
    if (os_log_type_enabled((os_log_t)qword_1008F7750, OS_LOG_TYPE_ERROR)) {
      sub_10065DA70();
    }
    return 0LL;
  }

  io_iterator_t v2 = existing;
  if (!existing)
  {
    int v5 = (os_log_s *)qword_1008F7750;
    if (os_log_type_enabled((os_log_t)qword_1008F7750, OS_LOG_TYPE_ERROR)) {
      sub_10065D9D4(v5, v6, v7, v8, v9, v10, v11, v12);
    }
    return 0LL;
  }

  do
  {
    if (!IOIteratorIsValid(v2)) {
      break;
    }
    uint64_t v3 = IOIteratorNext(existing);
    uint64_t v1 = v3;
    if (!(_DWORD)v3) {
      goto LABEL_16;
    }
    CFTypeRef CFProperty = IORegistryEntryCreateCFProperty(v3, @"IOPMUPrimary", 0LL, 0);
    if (CFProperty)
    {
      CFRelease(CFProperty);
      goto LABEL_16;
    }

    IOObjectRelease(v1);
    io_iterator_t v2 = existing;
  }

  while (existing);
  if (os_log_type_enabled((os_log_t)qword_1008F7750, OS_LOG_TYPE_ERROR)) {
    sub_10065DA44();
  }
  uint64_t v1 = 0LL;
LABEL_16:
  IOObjectRelease(existing);
  return v1;
}

uint64_t sub_1001FCFC8(uint64_t a1)
{
  uint64_t v2 = a1 + 16;
  uint64_t v3 = a1 + 24;
  *(void *)a1 = v4;
  *(void *)(a1 + *(void *)(v4 - 24)) = v5;
  *(void *)(a1 + 8) = 0LL;
  uint64_t v6 = (std::ios_base *)(a1 + *(void *)(*(void *)a1 - 24LL));
  std::ios_base::init(v6, (void *)(a1 + 24));
  v6[1].__vftable = 0LL;
  v6[1].__fmtflags_ = -1;
  *(void *)(a1 + 16) = v7;
  *(void *)(v2 + *(void *)(v7 - 24)) = v8;
  *(void *)a1 = v9;
  std::streambuf::basic_streambuf(v3);
  *(_OWORD *)(a1 + 88) = 0u;
  *(_OWORD *)(a1 + 104) = 0u;
  *(_DWORD *)(a1 + 120) = 24;
  return a1;
}

void sub_1001FD0CC(_Unwind_Exception *a1)
{
}

uint64_t sub_1001FD0F4(uint64_t a1)
{
  uint64_t v4 = a1 + 24;
  *(void *)(a1 + 16) = v3;
  std::streambuf::~streambuf(v4);
  std::ios::~ios(a1 + 128);
  return a1;
}

void *sub_1001FD17C(void *a1, uint64_t a2, uint64_t a3)
{
  v13[0] = 0LL;
  v13[1] = 0LL;
  std::ostream::sentry::sentry(v13, a1);
  if (LOBYTE(v13[0]))
  {
    uint64_t v6 = (uint64_t)a1 + *(void *)(*a1 - 24LL);
    uint64_t v7 = *(void *)(v6 + 40);
    int v8 = *(_DWORD *)(v6 + 8);
    int v9 = *(_DWORD *)(v6 + 144);
    if (v9 == -1)
    {
      std::ios_base::getloc((const std::ios_base *)((char *)a1 + *(void *)(*a1 - 24LL)));
      uint64_t v10 = std::locale::use_facet(&v14, &std::ctype<char>::id);
      int v9 = ((uint64_t (*)(const std::locale::facet *, uint64_t))v10->__vftable[2].~facet_0)(v10, 32LL);
      std::locale::~locale(&v14);
      *(_DWORD *)(v6 + 144) = v9;
    }

    if ((v8 & 0xB0) == 0x20) {
      uint64_t v11 = a2 + a3;
    }
    else {
      uint64_t v11 = a2;
    }
    if (!sub_1001FD2B0(v7, a2, v11, a2 + a3, v6, v9)) {
      std::ios_base::clear( (std::ios_base *)((char *)a1 + *(void *)(*a1 - 24LL)),  *(_DWORD *)((char *)a1 + *(void *)(*a1 - 24LL) + 32) | 5);
    }
  }

  std::ostream::sentry::~sentry(v13);
  return a1;
}

void sub_1001FD288( _Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, char a10, uint64_t a11, std::locale a12)
{
}

uint64_t sub_1001FD2B0(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, int __c)
{
  uint64_t v6 = a1;
  if (a1)
  {
    uint64_t v11 = *(void *)(a5 + 24);
    if (v11 <= a4 - a2) {
      int64_t v12 = 0LL;
    }
    else {
      int64_t v12 = v11 - (a4 - a2);
    }
    if (v12 >= 1)
    {
      __p[0] = 0LL;
      __p[1] = 0LL;
      uint64_t v18 = 0LL;
      sub_1001FD3F4(__p, v12, __c);
      uint64_t v13 = v18 >= 0 ? __p : (void **)__p[0];
      uint64_t v14 = (*(uint64_t (**)(uint64_t, void **, int64_t))(*(void *)v6 + 96LL))(v6, v13, v12);
      if (SHIBYTE(v18) < 0) {
        operator delete(__p[0]);
      }
      if (v14 != v12) {
        return 0LL;
      }
    }

    uint64_t v15 = a4 - a3;
    else {
      return 0LL;
    }
  }

  return v6;
}

void sub_1001FD3D8( _Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void *__p, uint64_t a11, int a12, __int16 a13, char a14, char a15)
{
  if (a15 < 0) {
    operator delete(__p);
  }
  _Unwind_Resume(exception_object);
}

void *sub_1001FD3F4(void *__b, size_t __len, int __c)
{
  if (__len >= 0x7FFFFFFFFFFFFFF8LL) {
    abort();
  }
  if (__len >= 0x17)
  {
    size_t v7 = (__len & 0xFFFFFFFFFFFFFFF8LL) + 8;
    if ((__len | 7) != 0x17) {
      size_t v7 = __len | 7;
    }
    size_t v8 = v7 + 1;
    uint64_t v6 = operator new(v7 + 1);
    __b[1] = __len;
    __b[2] = v8 | 0x8000000000000000LL;
    *__b = v6;
  }

  else
  {
    *((_BYTE *)__b + 23) = __len;
    uint64_t v6 = __b;
    if (!__len) {
      goto LABEL_9;
    }
  }

  memset(v6, __c, __len);
LABEL_9:
  *((_BYTE *)v6 + __len) = 0;
  return __b;
}

uint64_t sub_1001FD498(uint64_t a1, uint64_t a2)
{
  *(void *)(a1 + 16) = *(void *)(a2 + 16);
  *(void *)(a1 + 24) = &off_10087FAA8;
  uint64_t v4 = *(void *)(a2 + 32);
  *(void *)(a1 + 32) = v4;
  if (v4) {
    sub_1002CD1E0(v4);
  }
  uint64_t v5 = *(void *)(a2 + 48);
  *(void *)(a1 + 40) = &off_10087FAA8;
  *(void *)(a1 + 4std::iostream::~basic_iostream(v2, v3 + 8) = v5;
  if (v5) {
    sub_1002CD1E0(v5);
  }
  int v6 = *(_DWORD *)(a2 + 56);
  *(_BYTE *)(a1 + 60) = *(_BYTE *)(a2 + 60);
  *(_DWORD *)(a1 + 56) = v6;
  return a1;
}

void sub_1001FD508(_Unwind_Exception *exception_object)
{
  *(void *)(v1 + 24) = v2;
  uint64_t v4 = *(unsigned int **)(v1 + 32);
  if (v4) {
    sub_1002CD254(v4);
  }
  _Unwind_Resume(exception_object);
}

uint64_t sub_1001FD524(uint64_t a1)
{
  *(void *)a1 = off_100886C50;
  *(void *)(a1 + std::iostream::~basic_iostream(v2, v3 + 8) = off_100886CB8;
  *(void *)(a1 + 16) = &off_100886CE8;
  for (uint64_t i = 200LL; i != 184; i -= 8LL)

  sub_1001FD5C8(a1 + 160, *(void **)(a1 + 168));
  uint64_t v4 = (void **)(a1 + 40);
  sub_1001FD65C(&v4);
  return a1;
}

void sub_1001FD5C8(uint64_t a1, void *a2)
{
  if (a2)
  {
    sub_1001FD5C8(a1, *a2);
    sub_1001FD5C8(a1, a2[1]);
    sub_1001FD610(a2 + 4);
    operator delete(a2);
  }

void sub_1001FD610(void *a1)
{
  a1[5] = &off_10087FAA8;
  uint64_t v2 = (unsigned int *)a1[6];
  if (v2) {
    sub_1002CD254(v2);
  }
  a1[3] = &off_10087FAA8;
  uint64_t v3 = (unsigned int *)a1[4];
  if (v3) {
    sub_1002CD254(v3);
  }
}

void sub_1001FD65C(void ***a1)
{
  uint64_t v2 = *a1;
  if (*v2)
  {
    sub_1001FD69C((uint64_t *)v2);
    operator delete(**a1);
  }

void sub_1001FD69C(uint64_t *a1)
{
  uint64_t v2 = *a1;
  for (uint64_t i = a1[1]; i != v2; i -= 40LL)
  {
  }

  a1[1] = v2;
}

void sub_1001FD6E8(id a1)
{
  uint64_t v1 = operator new(0x230uLL);
  sub_10042BC28();
  off_1008D60A8 = v1;
}

void sub_1001FD718(_Unwind_Exception *a1)
{
}

void sub_1001FD72C(id a1)
{
  uint64_t v1 = operator new(0xEB0uLL);
  sub_10061991C();
  qword_1008D5F18 = (uint64_t)v1;
}

void sub_1001FD75C(_Unwind_Exception *a1)
{
}

unsigned __int8 *sub_1001FD770( uint64_t **a1, unsigned __int8 *uu1, uint64_t a3, const unsigned __int8 *__attribute__((__org_typedef(uuid_t))) *a4)
{
  uint64_t v11 = 0LL;
  int v6 = (unsigned __int8 **)sub_1001FD824((uint64_t)a1, &v11, uu1);
  size_t v7 = *v6;
  if (!*v6)
  {
    size_t v8 = (uint64_t **)v6;
    memset(v10, 0, sizeof(v10));
    sub_1001FD8B4((uint64_t)a1, a4, v10);
    sub_100029630(a1, v11, v8, (uint64_t *)v10[0]);
    size_t v7 = v10[0];
    v10[0] = 0LL;
    sub_1001FD944((uint64_t)v10, 0LL);
  }

  return v7;
}

void *sub_1001FD824(uint64_t a1, void *a2, unsigned __int8 *uu1)
{
  uint64_t v5 = (void *)(a1 + 8);
  uint64_t v4 = *(void *)(a1 + 8);
  if (v4)
  {
    do
    {
      while (1)
      {
        size_t v7 = (void *)v4;
        size_t v8 = (const unsigned __int8 *)(v4 + 32);
        uint64_t v4 = *v7;
        uint64_t v5 = v7;
        if (!*v7) {
          goto LABEL_9;
        }
      }

      if ((uuid_compare(v8, uu1) & 0x80000000) == 0) {
        break;
      }
      uint64_t v5 = v7 + 1;
      uint64_t v4 = v7[1];
    }

    while (v4);
  }

  else
  {
    size_t v7 = (void *)(a1 + 8);
  }

double sub_1001FD8B4@<D0>( uint64_t a1@<X0>, const unsigned __int8 *__attribute__((__org_typedef(uuid_t))) *a2@<X2>, unsigned __int8 **a3@<X8>)
{
  uint64_t v5 = (unsigned __int8 *)(a1 + 8);
  *a3 = 0LL;
  a3[1] = 0LL;
  a3[2] = 0LL;
  int v6 = (unsigned __int8 *)operator new(0x60uLL);
  *a3 = v6;
  a3[1] = v5;
  *((_BYTE *)a3 + 16) = 0;
  uuid_copy(v6 + 32, *a2);
  double result = 0.0;
  *((_OWORD *)v6 + 3) = 0u;
  *((_OWORD *)v6 + 4) = 0u;
  *((_OWORD *)v6 + 5) = 0u;
  *((void *)v6 + memset((char *)&v11[1] + 1, 0, 7) = &off_10087FAA8;
  *((void *)v6 + 9) = &off_10087FAA8;
  *((_BYTE *)a3 + 16) = 1;
  return result;
}

void sub_1001FD92C(_Unwind_Exception *a1)
{
}

void sub_1001FD944(uint64_t a1, uint64_t a2)
{
  uint64_t v2 = *(void **)a1;
  *(void *)a1 = a2;
  if (v2)
  {
    if (*(_BYTE *)(a1 + 16)) {
      sub_1001FD610(v2 + 4);
    }
    operator delete(v2);
  }

void sub_1001FD988(id a1)
{
  uint64_t v1 = operator new(0xA8uLL);
  sub_10040D0A0((uint64_t)v1);
  off_1008D6780 = v1;
}

void sub_1001FD9B8(_Unwind_Exception *a1)
{
}

uint64_t *sub_1001FD9CC(uint64_t *result, void *a2)
{
  uint64_t v3 = *result;
  uint64_t v2 = result[1];
  uint64_t v4 = a2[1];
  while (v2 != v3)
  {
    int v5 = *(_DWORD *)(v2 - 40);
    v2 -= 40LL;
    *(_DWORD *)(v4 - 40) = v5;
    v4 -= 40LL;
    __int128 v6 = *(_OWORD *)(v2 + 8);
    *(void *)(v4 + 24) = *(void *)(v2 + 24);
    *(_OWORD *)(v4 + std::iostream::~basic_iostream(v2, v3 + 8) = v6;
    *(void *)(v2 + 16) = 0LL;
    *(void *)(v2 + 24) = 0LL;
    *(void *)(v2 + std::iostream::~basic_iostream(v2, v3 + 8) = 0LL;
    *(void *)(v4 + 32) = *(void *)(v2 + 32);
  }

  a2[1] = v4;
  uint64_t v7 = *result;
  *double result = v4;
  a2[1] = v7;
  uint64_t v8 = result[1];
  result[1] = a2[2];
  a2[2] = v8;
  uint64_t v9 = result[2];
  result[2] = a2[3];
  a2[3] = v9;
  *a2 = a2[1];
  return result;
}

void *sub_1001FDA44(uint64_t a1, unint64_t a2)
{
  if (a2 >= 0x666666666666667LL) {
    sub_100008BD4();
  }
  return operator new(40 * a2);
}

uint64_t sub_1001FDA88(uint64_t a1)
{
  if (*(void *)a1) {
    operator delete(*(void **)a1);
  }
  return a1;
}

void sub_1001FDABC(uint64_t a1, uint64_t a2)
{
  uint64_t v2 = *(void *)(a1 + 16);
  if (v2 != a2)
  {
    do
    {
      uint64_t v5 = v2 - 40;
      *(void *)(a1 + 16) = v2 - 40;
      if (*(char *)(v2 - 9) < 0)
      {
        operator delete(*(void **)(v2 - 32));
        uint64_t v5 = *(void *)(a1 + 16);
      }

      uint64_t v2 = v5;
    }

    while (v5 != a2);
  }

uint64_t sub_1001FDB10(uint64_t a1, unsigned __int8 *uu2)
{
  uint64_t v2 = a1 + 8;
  uint64_t v3 = *(void *)(a1 + 8);
  if (!v3) {
    return v2;
  }
  uint64_t v5 = a1 + 8;
  do
  {
    int v6 = uuid_compare((const unsigned __int8 *)(v3 + 32), uu2);
    uint64_t v7 = (uint64_t *)(v3 + 8);
    if (v6 >= 0)
    {
      uint64_t v7 = (uint64_t *)v3;
      uint64_t v5 = v3;
    }

    uint64_t v3 = *v7;
  }

  while (*v7);
  return v5;
}

void sub_1001FDB88(id a1)
{
  uint64_t v1 = operator new(0x128uLL);
  sub_1005C69F8();
  off_1008D5F28 = v1;
}

void sub_1001FDBB8(_Unwind_Exception *a1)
{
}

uint64_t *sub_1001FDBCC(uint64_t **a1, uint64_t *a2)
{
  uint64_t v2 = (uint64_t *)a2[1];
  if (v2)
  {
    do
    {
      uint64_t v3 = v2;
      uint64_t v2 = (uint64_t *)*v2;
    }

    while (v2);
  }

  else
  {
    uint64_t v4 = a2;
    do
    {
      uint64_t v3 = (uint64_t *)v4[2];
      BOOL v5 = *v3 == (void)v4;
      uint64_t v4 = v3;
    }

    while (!v5);
  }

  if (*a1 == a2) {
    *a1 = v3;
  }
  int v6 = a1[1];
  a1[2] = (uint64_t *)((char *)a1[2] - 1);
  sub_1001FDC3C(v6, a2);
  return v3;
}

uint64_t *sub_1001FDC3C(uint64_t *result, uint64_t *a2)
{
  uint64_t v2 = *a2;
  uint64_t v3 = a2;
  if (*a2)
  {
    uint64_t v4 = (uint64_t *)a2[1];
    if (!v4)
    {
      uint64_t v3 = a2;
      goto LABEL_7;
    }

    do
    {
      uint64_t v3 = v4;
      uint64_t v4 = (uint64_t *)*v4;
    }

    while (v4);
  }

  uint64_t v2 = v3[1];
  if (v2)
  {
LABEL_7:
    int v5 = 0;
    *(void *)(v2 + 16) = v3[2];
    goto LABEL_8;
  }

  int v5 = 1;
LABEL_8:
  int v6 = (uint64_t **)v3[2];
  uint64_t v7 = *v6;
  if (*v6 == v3)
  {
    *int v6 = (uint64_t *)v2;
    if (v3 == result)
    {
      uint64_t v7 = 0LL;
      double result = (uint64_t *)v2;
    }

    else
    {
      uint64_t v7 = v6[1];
    }
  }

  else
  {
    v6[1] = (uint64_t *)v2;
  }

  int v8 = *((unsigned __int8 *)v3 + 24);
  if (v3 != a2)
  {
    uint64_t v9 = a2[2];
    v3[2] = v9;
    *(void *)(v9 + 8LL * (*(void *)a2[2] != (void)a2)) = v3;
    uint64_t v11 = *a2;
    uint64_t v10 = a2[1];
    *(void *)(v11 + 16) = v3;
    *uint64_t v3 = v11;
    v3[1] = v10;
    if (v10) {
      *(void *)(v10 + 16) = v3;
    }
    *((_BYTE *)v3 + 24) = *((_BYTE *)a2 + 24);
    if (result == a2) {
      double result = v3;
    }
  }

  if (!v8 || !result) {
    return result;
  }
  if (!v5)
  {
    *(_BYTE *)(v2 + 24) = 1;
    return result;
  }

  while (1)
  {
    uint64_t v12 = v7[2];
    if (!*((_BYTE *)v7 + 24))
    {
      *((_BYTE *)v7 + 24) = 1;
      *(_BYTE *)(v12 + 24) = 0;
      uint64_t v13 = *(uint64_t **)(v12 + 8);
      uint64_t v14 = *v13;
      *(void *)(v12 + std::iostream::~basic_iostream(v2, v3 + 8) = *v13;
      if (v14) {
        *(void *)(v14 + 16) = v12;
      }
      void v13[2] = *(void *)(v12 + 16);
      *(void *)(*(void *)(v12 + 16) + 8LL * (**(void **)(v12 + 16) != v12)) = v13;
      uint64_t *v13 = v12;
      *(void *)(v12 + 16) = v13;
      uint64_t v7 = *(uint64_t **)(*v7 + 8);
    }

    uint64_t v15 = (void *)*v7;
    if (*v7 && !*((_BYTE *)v15 + 24))
    {
      uint64_t v16 = (uint64_t *)v7[1];
      if (!v16) {
        goto LABEL_56;
      }
LABEL_55:
      if (*((_BYTE *)v16 + 24))
      {
LABEL_56:
        *((_BYTE *)v15 + 24) = 1;
        *((_BYTE *)v7 + 24) = 0;
        uint64_t v22 = v15[1];
        *uint64_t v7 = v22;
        if (v22) {
          *(void *)(v22 + 16) = v7;
        }
        v15[2] = v7[2];
        *(void *)(v7[2] + 8LL * (*(void *)v7[2] != (void)v7)) = v15;
        v15[1] = v7;
        v7[2] = (uint64_t)v15;
        uint64_t v16 = v7;
      }

      else
      {
        uint64_t v15 = v7;
      }

      uint64_t v23 = v15[2];
      *((_BYTE *)v15 + 24) = *(_BYTE *)(v23 + 24);
      *(_BYTE *)(v23 + 24) = 1;
      *((_BYTE *)v16 + 24) = 1;
      uint64_t v24 = *(uint64_t **)(v23 + 8);
      uint64_t v25 = *v24;
      *(void *)(v23 + std::iostream::~basic_iostream(v2, v3 + 8) = *v24;
      if (v25) {
        *(void *)(v25 + 16) = v23;
      }
      v24[2] = *(void *)(v23 + 16);
      *(void *)(*(void *)(v23 + 16) + 8LL * (**(void **)(v23 + 16) != v23)) = v24;
      uint64_t *v24 = v23;
      goto LABEL_72;
    }

    uint64_t v16 = (uint64_t *)v7[1];
    if (v16 && !*((_BYTE *)v16 + 24)) {
      goto LABEL_55;
    }
    *((_BYTE *)v7 + 24) = 0;
    uint64_t v17 = (uint64_t *)v7[2];
    if (v17 == result)
    {
      uint64_t v17 = result;
LABEL_53:
      *((_BYTE *)v17 + 24) = 1;
      return result;
    }

    if (!*((_BYTE *)v17 + 24)) {
      goto LABEL_53;
    }
LABEL_49:
    uint64_t v7 = *(uint64_t **)(v17[2] + 8LL * (*(void *)v17[2] == (void)v17));
  }

  if (!*((_BYTE *)v7 + 24))
  {
    *((_BYTE *)v7 + 24) = 1;
    *(_BYTE *)(v12 + 24) = 0;
    uint64_t v18 = v7[1];
    *(void *)uint64_t v12 = v18;
    if (v18) {
      *(void *)(v18 + 16) = v12;
    }
    v7[2] = *(void *)(v12 + 16);
    *(void *)(*(void *)(v12 + 16) + 8LL * (**(void **)(v12 + 16) != v12)) = v7;
    v7[1] = v12;
    *(void *)(v12 + 16) = v7;
    uint64_t v7 = *(uint64_t **)v12;
  }

  int v19 = (void *)*v7;
  if (*v7 && !*((_BYTE *)v19 + 24)) {
    goto LABEL_68;
  }
  id v20 = (uint64_t *)v7[1];
  if (!v20 || *((_BYTE *)v20 + 24))
  {
    *((_BYTE *)v7 + 24) = 0;
    uint64_t v17 = (uint64_t *)v7[2];
    if (*((_BYTE *)v17 + 24)) {
      BOOL v21 = v17 == result;
    }
    else {
      BOOL v21 = 1;
    }
    if (v21) {
      goto LABEL_53;
    }
    goto LABEL_49;
  }

  if (v19 && !*((_BYTE *)v19 + 24))
  {
LABEL_68:
    id v20 = v7;
  }

  else
  {
    *((_BYTE *)v20 + 24) = 1;
    *((_BYTE *)v7 + 24) = 0;
    uint64_t v26 = *v20;
    v7[1] = *v20;
    if (v26) {
      *(void *)(v26 + 16) = v7;
    }
    void v20[2] = v7[2];
    *(void *)(v7[2] + 8LL * (*(void *)v7[2] != (void)v7)) = v20;
    *id v20 = (uint64_t)v7;
    v7[2] = (uint64_t)v20;
    int v19 = v7;
  }

  uint64_t v23 = v20[2];
  *((_BYTE *)v20 + 24) = *(_BYTE *)(v23 + 24);
  *(_BYTE *)(v23 + 24) = 1;
  *((_BYTE *)v19 + 24) = 1;
  uint64_t v24 = *(uint64_t **)v23;
  uint64_t v27 = *(void *)(*(void *)v23 + 8LL);
  *(void *)uint64_t v23 = v27;
  if (v27) {
    *(void *)(v27 + 16) = v23;
  }
  v24[2] = *(void *)(v23 + 16);
  *(void *)(*(void *)(v23 + 16) + 8LL * (**(void **)(v23 + 16) != v23)) = v24;
  v24[1] = v23;
LABEL_72:
  *(void *)(v23 + 16) = v24;
  return result;
}

uint64_t sub_1001FDFC0(uint64_t a1)
{
  uint64_t v3 = *(void *)(a1 + 8);
  for (uint64_t i = *(void *)(a1 + 16); i != v3; uint64_t i = *(void *)(a1 + 16))
  {
    *(void *)(a1 + 16) = i - 8;
  }

  if (*(void *)a1) {
    operator delete(*(void **)a1);
  }
  return a1;
}

void sub_1001FE010(void *a1, os_log_s *a2, uint64_t a3, const char *a4, uint8_t *a5)
{
}

void sub_1001FE01C( void *a1, os_log_s *a2, uint64_t a3, const char *a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint8_t a9)
{
}

_BYTE *sub_1001FE02C(_BYTE *result, _BYTE *a2)
{
  *double result = 0;
  *a2 = 0;
  return result;
}

  ;
}

void sub_1001FE050()
{
  uint64_t v0 = objc_autoreleasePoolPush();
  sub_100243040(&stru_1008F7028);
  __cxa_atexit((void (*)(void *))sub_1002430A8, &stru_1008F7028, (void *)&_mh_execute_header);
  sub_100242DC4(&unk_1008F7058);
  __cxa_atexit((void (*)(void *))sub_100242E28, &unk_1008F7058, (void *)&_mh_execute_header);
  sub_100243040(&stru_1008F70A0);
  __cxa_atexit((void (*)(void *))sub_1002430A8, &stru_1008F70A0, (void *)&_mh_execute_header);
  sub_100242DC4(&unk_1008F70D0);
  __cxa_atexit((void (*)(void *))sub_100242E28, &unk_1008F70D0, (void *)&_mh_execute_header);
  sub_100242DC4(&unk_1008F7118);
  __cxa_atexit((void (*)(void *))sub_100242E28, &unk_1008F7118, (void *)&_mh_execute_header);
  sub_100243040(&stru_1008F7158);
  __cxa_atexit((void (*)(void *))sub_1002430A8, &stru_1008F7158, (void *)&_mh_execute_header);
  objc_autoreleasePoolPop(v0);
}

void *sub_1001FE168(uint64_t a1, uint64_t a2, __int16 a3)
{
  double result = (void *)sub_10043A0D8(a1, a2, a3);
  *double result = &off_100886DC0;
  return result;
}

void sub_1001FE188(uint64_t a1, const uint8_t *a2, CFIndex a3)
{
  if (a3)
  {
    uint64_t v5 = *a2;
    if (*(void *)(a1 + 216))
    {
      uint64_t v7 = (void *)(a1 + 192);
      if (*a2 <= 0x8Fu)
      {
        if (*a2 > 0x13u)
        {
          if ((v5 - 32) >= 3)
          {
            if ((_DWORD)v5 == 20)
            {
              int v8 = (os_log_s *)qword_1008F7730;
              if (os_log_type_enabled((os_log_t)qword_1008F7730, OS_LOG_TYPE_DEFAULT))
              {
                int v9 = (*(uint64_t (**)(void, void))(**(void **)(a1 + 8) + 32LL))( *(void *)(a1 + 8),  *(unsigned __int16 *)(a1 + 40));
                *(_DWORD *)__int128 buf = 67109376;
                *(_DWORD *)&uint8_t buf[4] = 20;
                __int16 v38 = 1024;
                int v39 = v9;
                _os_log_impl( (void *)&_mh_execute_header,  v8,  OS_LOG_TYPE_DEFAULT,  "Received exit suspend input report (ID %u), should undim %d",  buf,  0xEu);
              }

uint64_t sub_1001FE46C(uint64_t a1, void *a2)
{
  id v4 = a2;
  uint64_t v5 = (void *)[v4 valueForKey:@"ProductID"];
  unsigned int v6 = [v5 intValue];
  int v16 = 14;
  if (v6 == *(unsigned __int16 *)sub_1001FE810((uint64_t)&unk_1008F7368, &v16)
    || (int v15 = 16, v6 == *(unsigned __int16 *)sub_1001FE810((uint64_t)&unk_1008F7368, &v15))
    || (int v14 = 26, v6 == *(unsigned __int16 *)sub_1001FE810((uint64_t)&unk_1008F7368, &v14))
    || (int v13 = 27, v6 == *(unsigned __int16 *)sub_1001FE810((uint64_t)&unk_1008F7368, &v13)))
  {
    id v7 = sub_1001FE940();
    int v8 = (void *)objc_claimAutoreleasedReturnValue(v7);
    sub_1001FE85C(a1, v4, v8);

    sub_1001FE9DC(a1, v4);
  }

  else
  {
    int v16 = 15;
    if (v6 == *(unsigned __int16 *)sub_1001FE810((uint64_t)&unk_1008F7368, &v16)
      || (int v15 = 25, v6 == *(unsigned __int16 *)sub_1001FE810((uint64_t)&unk_1008F7368, &v15)))
    {
      id v10 = sub_1001FE940();
      uint64_t v11 = (void *)objc_claimAutoreleasedReturnValue(v10);
      sub_1001FE85C(a1, v4, v11);
    }

    else
    {
      id v12 = sub_1001FEAC8();
      uint64_t v11 = (void *)objc_claimAutoreleasedReturnValue(v12);
      sub_1001FE85C(a1, v4, v11);
    }
  }

  int v16 = 12;

  return 1LL;
}

void sub_1001FE65C(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

uint64_t sub_1001FE6AC(uint64_t a1, void *a2)
{
  __int128 v10 = xmmword_1006BF1BD;
  __int128 v11 = unk_1006BF1CD;
  *(_OWORD *)id v12 = xmmword_1006BF1DD;
  __int128 v8 = xmmword_1006BF19D;
  __int128 v9 = algn_1006BF1AD;
  *(_DWORD *)&v12[15] = -1073577627;
  *(void *)(a1 + 304) = a1;
  *(_BYTE *)(a1 + 312) = -16;
  id v3 = objc_msgSend(a2, "mutableCopy", v8, v9, v10, v11, *(_OWORD *)v12, *(void *)&v12[16]);
  [v3 setObject:@"Keyboard" forKeyedSubscript:@"Accessory Category"];
  [v3 setObject:&off_1008C3138 forKeyedSubscript:@"ExtendedData"];
  uint64_t v4 = sub_10043A400(a1, v3, (uint64_t)&v8, 83LL, *(unsigned __int8 *)(a1 + 312), 0LL);
  uint64_t v5 = v4;
  if (v4)
  {
    uint64_t v6 = a1 + 304;
    IOHIDUserDeviceRegisterGetReportWithReturnLengthCallback(v4, sub_1001FEC50, v6);
    IOHIDUserDeviceRegisterSetReportCallback(v5, sub_1001FEC68, v6);
  }

  else if (os_log_type_enabled((os_log_t)qword_1008F7730, OS_LOG_TYPE_ERROR))
  {
    sub_10065DC2C();
  }

  return v5;
}

void sub_1001FE7F4(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

uint64_t *sub_1001FE810(uint64_t a1, int *a2)
{
  uint64_t v2 = *(uint64_t **)(a1 + 8);
  if (!v2) {
LABEL_8:
  }
    abort();
  int v3 = *a2;
  while (1)
  {
    while (1)
    {
      int v4 = *((_DWORD *)v2 + 7);
      if (v3 >= v4) {
        break;
      }
      uint64_t v2 = (uint64_t *)*v2;
      if (!v2) {
        goto LABEL_8;
      }
    }

    if (v4 >= v3) {
      return v2 + 4;
    }
    uint64_t v2 = (uint64_t *)v2[1];
    if (!v2) {
      goto LABEL_8;
    }
  }

uint64_t sub_1001FE85C(uint64_t a1, void *a2, void *a3)
{
  id v5 = a3;
  *(void *)(a1 + 320) = a1;
  *(_BYTE *)(a1 + 32std::iostream::~basic_iostream(v2, v3 + 8) = -15;
  id v6 = v5;
  uint64_t v7 = sub_10043A400( a1,  a2,  (uint64_t)[v6 bytes],  (uint64_t)[v6 length],  *(unsigned __int8 *)(a1 + 328),  1);
  uint64_t v8 = v7;
  if (v7)
  {
    uint64_t v9 = a1 + 320;
    IOHIDUserDeviceRegisterGetReportWithReturnLengthCallback(v7, sub_1001FEC50, v9);
    IOHIDUserDeviceRegisterSetReportCallback(v8, sub_1001FEC68, v9);
  }

  else if (os_log_type_enabled((os_log_t)qword_1008F7730, OS_LOG_TYPE_ERROR))
  {
    sub_10065DC58();
  }

  return v8;
}

void sub_1001FE930(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

id sub_1001FE940()
{
  v1[10] = xmmword_1006BF2D8;
  v2[0] = unk_1006BF2E8;
  *(_OWORD *)((char *)v2 + 15) = unk_1006BF2F7;
  v1[6] = xmmword_1006BF298;
  v1[7] = unk_1006BF2A8;
  v1[8] = xmmword_1006BF2B8;
  v1[9] = unk_1006BF2C8;
  v1[2] = xmmword_1006BF258;
  v1[3] = unk_1006BF268;
  v1[4] = xmmword_1006BF278;
  v1[5] = unk_1006BF288;
  v1[0] = xmmword_1006BF238;
  v1[1] = unk_1006BF248;
  return [NSData dataWithBytes:v1 length:207];
}

uint64_t sub_1001FE9DC(uint64_t a1, void *a2)
{
  __int128 v7 = xmmword_1006BF20B;
  v8[0] = algn_1006BF21B;
  *(_OWORD *)((char *)v8 + 13) = unk_1006BF228;
  *(void *)(a1 + 352) = a1;
  *(_BYTE *)(a1 + 360) = -12;
  uint64_t v3 = sub_10043A400(a1, a2, (uint64_t)&v7, 45LL, 244LL, 2LL);
  uint64_t v4 = v3;
  if (v3)
  {
    uint64_t v5 = a1 + 352;
    IOHIDUserDeviceRegisterGetReportWithReturnLengthCallback(v3, sub_1001FEC50, v5);
    IOHIDUserDeviceRegisterSetReportCallback(v4, sub_1001FEC68, v5);
  }

  else if (os_log_type_enabled((os_log_t)qword_1008F7730, OS_LOG_TYPE_ERROR))
  {
    sub_10065DC84();
  }

  return v4;
}

id sub_1001FEAC8()
{
  v1[8] = xmmword_1006BF387;
  v1[9] = unk_1006BF397;
  *(_OWORD *)uint64_t v2 = xmmword_1006BF3A7;
  *(void *)&v2[14] = 0xC022813F85409508LL;
  v1[4] = xmmword_1006BF347;
  v1[5] = unk_1006BF357;
  v1[6] = xmmword_1006BF367;
  v1[7] = unk_1006BF377;
  v1[0] = xmmword_1006BF307;
  v1[1] = unk_1006BF317;
  v1[2] = xmmword_1006BF327;
  v1[3] = unk_1006BF337;
  return [NSData dataWithBytes:v1 length:182LL];
}

uint64_t sub_1001FEB64(uint64_t a1, void *a2)
{
  v7[0] = xmmword_1006BF1F0;
  *(_OWORD *)((char *)v7 + 11) = *(__int128 *)((char *)&xmmword_1006BF1F0 + 11);
  *(void *)(a1 + 336) = a1;
  *(_BYTE *)(a1 + 344) = -14;
  uint64_t v3 = sub_10043A400(a1, a2, (uint64_t)v7, 27LL, 242LL, 2LL);
  uint64_t v4 = v3;
  if (v3)
  {
    uint64_t v5 = a1 + 336;
    IOHIDUserDeviceRegisterGetReportWithReturnLengthCallback(v3, sub_1001FEC50, v5);
    IOHIDUserDeviceRegisterSetReportCallback(v4, sub_1001FEC68, v5);
  }

  else if (os_log_type_enabled((os_log_t)qword_1008F7730, OS_LOG_TYPE_ERROR))
  {
    sub_10065DCB0();
  }

  return v4;
}

uint64_t sub_1001FEC50(unsigned __int8 *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5)
{
  return (*(uint64_t (**)(void, uint64_t, uint64_t, uint64_t, uint64_t, void))(**(void **)a1 + 112LL))( *(void *)a1,  a2,  a3,  a4,  a5,  a1[8]);
}

uint64_t sub_1001FEC68(unsigned __int8 *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5)
{
  return (*(uint64_t (**)(void, uint64_t, uint64_t, uint64_t, uint64_t, void))(**(void **)a1 + 120LL))( *(void *)a1,  a2,  a3,  a4,  a5,  a1[8]);
}

void sub_1001FEC84(uint64_t a1)
{
  uint64_t v1 = (void *)sub_10043A18C(a1);
  operator delete(v1);
}

uint64_t **sub_1001FEC98(void *a1, unsigned __int8 *a2)
{
  int8x8_t v2 = (int8x8_t)a1[1];
  if (!*(void *)&v2) {
    return 0LL;
  }
  unint64_t v3 = *a2;
  uint8x8_t v4 = (uint8x8_t)vcnt_s8(v2);
  v4.i16[0] = vaddlv_u8(v4);
  if (v4.u32[0] > 1uLL)
  {
    unint64_t v5 = *a2;
    if (*(void *)&v2 <= v3) {
      unint64_t v5 = v3 % *(void *)&v2;
    }
  }

  else
  {
    unint64_t v5 = (v2.i32[0] - 1) & v3;
  }

  id v6 = *(uint64_t ****)(*a1 + 8 * v5);
  if (!v6) {
    return 0LL;
  }
  for (double result = *v6; result; double result = (uint64_t **)*result)
  {
    unint64_t v8 = (unint64_t)result[1];
    if (v8 == v3)
    {
    }

    else
    {
      if (v4.u32[0] > 1uLL)
      {
        if (v8 >= *(void *)&v2) {
          v8 %= *(void *)&v2;
        }
      }

      else
      {
        v8 &= *(void *)&v2 - 1LL;
      }

      if (v8 != v5) {
        return 0LL;
      }
    }
  }

  return result;
}

void *sub_1001FED4C(uint64_t a1, unsigned __int8 *a2, uint64_t a3, _BYTE **a4)
{
  unint64_t v6 = *a2;
  unint64_t v7 = *(void *)(a1 + 8);
  if (v7)
  {
    uint8x8_t v8 = (uint8x8_t)vcnt_s8((int8x8_t)v7);
    v8.i16[0] = vaddlv_u8(v8);
    if (v8.u32[0] > 1uLL)
    {
      unint64_t v9 = *a2;
      if (v7 <= v6) {
        unint64_t v9 = v6 % v7;
      }
    }

    else
    {
      unint64_t v9 = ((_DWORD)v7 - 1) & v6;
    }

    __int128 v10 = *(void ***)(*(void *)a1 + 8 * v9);
    if (v10)
    {
      __int128 v11 = *v10;
      if (*v10)
      {
        do
        {
          unint64_t v12 = v11[1];
          if (v12 == v6)
          {
          }

          else
          {
            if (v8.u32[0] > 1uLL)
            {
              if (v12 >= v7) {
                v12 %= v7;
              }
            }

            else
            {
              v12 &= v7 - 1;
            }

            if (v12 != v9) {
              break;
            }
          }

          __int128 v11 = (void *)*v11;
        }

        while (v11);
      }
    }
  }

  else
  {
    unint64_t v9 = 0LL;
  }

  __int128 v11 = operator new(0x20uLL);
  *__int128 v11 = 0LL;
  v11[1] = v6;
  *((_BYTE *)v11 + 16) = **a4;
  v11[3] = 0LL;
  float v13 = (float)(unint64_t)(*(void *)(a1 + 24) + 1LL);
  float v14 = *(float *)(a1 + 32);
  if (!v7 || (float)(v14 * (float)v7) < v13)
  {
    BOOL v15 = 1LL;
    if (v7 >= 3) {
      BOOL v15 = (v7 & (v7 - 1)) != 0;
    }
    unint64_t v16 = v15 | (2 * v7);
    unint64_t v17 = vcvtps_u32_f32(v13 / v14);
    if (v16 <= v17) {
      size_t v18 = v17;
    }
    else {
      size_t v18 = v16;
    }
    sub_10005141C(a1, v18);
    unint64_t v7 = *(void *)(a1 + 8);
    if ((v7 & (v7 - 1)) != 0)
    {
      if (v7 <= v6) {
        unint64_t v9 = v6 % v7;
      }
      else {
        unint64_t v9 = v6;
      }
    }

    else
    {
      unint64_t v9 = ((_DWORD)v7 - 1) & v6;
    }
  }

  uint64_t v19 = *(void *)a1;
  id v20 = *(void **)(*(void *)a1 + 8 * v9);
  if (v20)
  {
    *__int128 v11 = *v20;
LABEL_38:
    *id v20 = v11;
    goto LABEL_39;
  }

  *__int128 v11 = *(void *)(a1 + 16);
  *(void *)(a1 + 16) = v11;
  *(void *)(v19 + 8 * v9) = a1 + 16;
  if (*v11)
  {
    unint64_t v21 = *(void *)(*v11 + 8LL);
    if ((v7 & (v7 - 1)) != 0)
    {
      if (v21 >= v7) {
        v21 %= v7;
      }
    }

    else
    {
      v21 &= v7 - 1;
    }

    id v20 = (void *)(*(void *)a1 + 8 * v21);
    goto LABEL_38;
  }

void sub_1001FEF60(_Unwind_Exception *a1)
{
}

uint64_t sub_1001FEF74()
{
  int v5 = 0;
  __int128 v4 = 0u;
  __int128 v3 = 0u;
  __int128 v2 = 0u;
  block[0] = _NSConcreteStackBlock;
  block[1] = 3221225472LL;
  block[2] = sub_1001FEFF8;
  block[3] = &unk_100886E40;
  if (qword_1008EF908 != -1) {
    dispatch_once(&qword_1008EF908, block);
  }
  return qword_1008F7188;
}

_BYTE *sub_1001FEFF8()
{
  double result = operator new(0x170uLL);
  *(void *)double result = &off_100886E70;
  result[152] = 0;
  qword_1008F7188 = (uint64_t)result;
  return result;
}

uint64_t sub_1001FF028(uint64_t result)
{
  *(void *)double result = &off_100886E70;
  *(_BYTE *)(result + 152) = 0;
  return result;
}

uint64_t sub_1001FF044( uint64_t a1, uint64_t a2, unsigned __int16 *a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  if (*a3 > 3uLL)
  {
    float v14 = (os_log_s *)qword_1008F7620;
    if (os_log_type_enabled((os_log_t)qword_1008F7620, OS_LOG_TYPE_ERROR)) {
      sub_10065DCDC(v14, v15, v16, v17, v18, v19, v20, a8);
    }
  }

  else
  {
    uint64_t v10 = a1 + 52LL * *a3;
    __int128 v11 = *(_OWORD *)a3;
    __int128 v12 = *((_OWORD *)a3 + 1);
    __int128 v13 = *((_OWORD *)a3 + 2);
    *(_DWORD *)(v10 + 202) = *((_DWORD *)a3 + 12);
    *(_OWORD *)(v10 + 186) = v13;
    *(_OWORD *)(v10 + 170) = v12;
    *(_OWORD *)(v10 + 154) = v11;
  }

  return sub_100128D24(0x10Au, (uint64_t)(a3 + 11), a3[21], a3[22], a3[23], a3[24], a3[25], a8, a2);
}

uint64_t sub_1001FF140( uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  return sub_100128D24(0x10Bu, a2, a3, a4, a5, a6, a7, a8, a2);
}

uint64_t sub_1001FF168( uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  return sub_100128D24(0x10Eu, a2, a3, a4, a5, a6, a7, a8, a2);
}

uint64_t sub_1001FF198( uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  return sub_100128D24(0x10Fu, a2, a3, a4, a5, a6, a7, a8, a2);
}

uint64_t sub_1001FF1BC(uint64_t a1, uint64_t a2, unsigned __int16 *a3)
{
  return sub_100128D24(0x105u, a2, a3[20], a3[12], a3[13], a3[14], a3[15], a3[16], a2);
}

uint64_t sub_1001FF268( uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  return sub_1001214B4( 269,  (uint64_t)sub_1001FF2E4,  *(unsigned __int8 *)(a3 + 23),  *(unsigned __int8 *)(a3 + 22),  a5,  a6,  a7,  a8,  a2);
}

void sub_1001FF2E4(int a1)
{
  __int128 v2 = (os_log_s *)qword_1008F7620;
  if (os_log_type_enabled((os_log_t)qword_1008F7620, OS_LOG_TYPE_DEFAULT))
  {
    v3[0] = 67109120;
    v3[1] = a1;
    _os_log_impl( (void *)&_mh_execute_header,  v2,  OS_LOG_TYPE_DEFAULT,  "csSetProcedureParamsCB status=%{bluetooth:OI_STATUS}u",  (uint8_t *)v3,  8u);
  }

uint64_t sub_1001FF384( uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  return sub_1001214B4(268, (uint64_t)sub_1001FF3B0, a3, a4, a5, a6, a7, a8, a2);
}

void sub_1001FF3B0(int a1)
{
  __int128 v2 = (os_log_s *)qword_1008F7620;
  if (os_log_type_enabled((os_log_t)qword_1008F7620, OS_LOG_TYPE_DEFAULT))
  {
    v3[0] = 67109120;
    v3[1] = a1;
    _os_log_impl( (void *)&_mh_execute_header,  v2,  OS_LOG_TYPE_DEFAULT,  "csSetAfhCB status=%{bluetooth:OI_STATUS}u",  (uint8_t *)v3,  8u);
  }

uint64_t sub_1001FF450( uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  return sub_1001214B4(262, (uint64_t)sub_1001FF48C, a3, a4, a5, a6, a7, a8, a2);
}

void sub_1001FF48C(int a1)
{
  __int128 v2 = (os_log_s *)qword_1008F7620;
  if (os_log_type_enabled((os_log_t)qword_1008F7620, OS_LOG_TYPE_DEFAULT))
  {
    v3[0] = 67109120;
    v3[1] = a1;
    _os_log_impl( (void *)&_mh_execute_header,  v2,  OS_LOG_TYPE_DEFAULT,  "csSetDefaultSettingsCB status=%{bluetooth:OI_STATUS}u",  (uint8_t *)v3,  8u);
  }

void sub_1001FF52C( uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  if (sub_1001214B4(263, (uint64_t)sub_1001FF580, a3, a4, a5, a6, a7, a8, v16))
  {
    uint8x8_t v8 = (os_log_s *)qword_1008F7620;
    if (os_log_type_enabled((os_log_t)qword_1008F7620, OS_LOG_TYPE_ERROR)) {
      sub_10065DD10(v8, v9, v10, v11, v12, v13, v14, v15);
    }
  }

__n128 sub_1001FF580(int a1, uint64_t a2)
{
  __int128 v4 = (os_log_s *)qword_1008F7620;
  if (os_log_type_enabled((os_log_t)qword_1008F7620, OS_LOG_TYPE_DEFAULT))
  {
    v9[0] = 67109120;
    v9[1] = a1;
    _os_log_impl( (void *)&_mh_execute_header,  v4,  OS_LOG_TYPE_DEFAULT,  "csLeReadLocalFAETableCB status=%{bluetooth:OI_STATUS}u",  (uint8_t *)v9,  8u);
  }

  uint64_t v5 = sub_1001FEF74();
  *(_OWORD *)(v5 + 80) = *(_OWORD *)a2;
  __int128 v7 = *(_OWORD *)(a2 + 32);
  __n128 result = *(__n128 *)(a2 + 48);
  __int128 v8 = *(_OWORD *)(a2 + 16);
  *(void *)(v5 + 144) = *(void *)(a2 + 64);
  *(_OWORD *)(v5 + 112) = v7;
  *(__n128 *)(v5 + 12std::iostream::~basic_iostream(v2, v3 + 8) = result;
  *(_OWORD *)(v5 + 96) = v8;
  return result;
}

uint64_t sub_1001FF650( uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  return sub_100128D24(0x108u, a2, a3, a4, a5, a6, a7, a8, a2);
}

uint64_t sub_1001FF674( uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  return sub_1001214B4(265, (uint64_t)sub_1001FF6A0, a3, a4, a5, a6, a7, a8, a2);
}

void sub_1001FF6A0(int a1)
{
  __int128 v2 = (os_log_s *)qword_1008F7620;
  if (os_log_type_enabled((os_log_t)qword_1008F7620, OS_LOG_TYPE_DEFAULT))
  {
    v3[0] = 67109120;
    v3[1] = a1;
    _os_log_impl( (void *)&_mh_execute_header,  v2,  OS_LOG_TYPE_DEFAULT,  "csLeWriteRemoteFAETableCB status=%{bluetooth:OI_STATUS}u",  (uint8_t *)v3,  8u);
  }

__n128 sub_1001FF740(uint64_t a1, uint64_t a2, uint64_t a3)
{
  *(_OWORD *)(a1 + std::iostream::~basic_iostream(v2, v3 + 8) = *(_OWORD *)a3;
  __n128 result = *(__n128 *)(a3 + 16);
  __int128 v4 = *(_OWORD *)(a3 + 32);
  __int128 v5 = *(_OWORD *)(a3 + 48);
  *(void *)(a1 + 72) = *(void *)(a3 + 64);
  *(_OWORD *)(a1 + 56) = v5;
  *(_OWORD *)(a1 + 40) = v4;
  *(__n128 *)(a1 + 24) = result;
  return result;
}

uint64_t sub_1001FF768(uint64_t result)
{
  *(_BYTE *)(result + 152) = 1;
  return result;
}

void sub_1001FF774(uint64_t a1, int a2)
{
  __int128 v3 = (os_log_s *)qword_1008F7620;
  if (os_log_type_enabled((os_log_t)qword_1008F7620, OS_LOG_TYPE_DEFAULT))
  {
    v4[0] = 67109120;
    v4[1] = a2;
    _os_log_impl( (void *)&_mh_execute_header,  v3,  OS_LOG_TYPE_DEFAULT,  "LE_CsProcedureEnableComplete status=%{bluetooth:OI_STATUS}u",  (uint8_t *)v4,  8u);
  }

void sub_1001FF814(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, int a6)
{
  __int128 v7 = (os_log_s *)qword_1008F7620;
  if (os_log_type_enabled((os_log_t)qword_1008F7620, OS_LOG_TYPE_DEFAULT))
  {
    v8[0] = 67109120;
    v8[1] = a6;
    _os_log_impl( (void *)&_mh_execute_header,  v7,  OS_LOG_TYPE_DEFAULT,  "LE_CsSubeventResultComplete procedureDoneStatus=%{bluetooth:OI_STATUS}u",  (uint8_t *)v8,  8u);
  }

void sub_1001FF8B4(uint64_t a1, uint64_t a2, uint64_t a3, int a4)
{
  __int128 v5 = (os_log_s *)qword_1008F7620;
  if (os_log_type_enabled((os_log_t)qword_1008F7620, OS_LOG_TYPE_DEFAULT))
  {
    v6[0] = 67109120;
    v6[1] = a4;
    _os_log_impl( (void *)&_mh_execute_header,  v5,  OS_LOG_TYPE_DEFAULT,  "LE_CsSubeventResultComplete status=%{bluetooth:OI_STATUS}u",  (uint8_t *)v6,  8u);
  }

__n128 sub_1001FF954(uint64_t a1, unsigned __int16 *a2)
{
  if (*a2 <= 3uLL)
  {
    uint64_t v2 = a1 + 52LL * *a2;
    __n128 result = *(__n128 *)a2;
    __int128 v4 = *((_OWORD *)a2 + 1);
    __int128 v5 = *((_OWORD *)a2 + 2);
    *(_DWORD *)(v2 + 202) = *((_DWORD *)a2 + 12);
    *(_OWORD *)(v2 + 186) = v5;
    *(_OWORD *)(v2 + 170) = v4;
    *(__n128 *)(v2 + 154) = result;
  }

  return result;
}

uint64_t sub_1001FF988(uint64_t a1)
{
  *(_OWORD *)(a1 + std::iostream::~basic_iostream(v2, v3 + 8) = 0u;
  *(_WORD *)(a1 + 69) = 0;
  uint64_t v2 = (std::string *)(a1 + 32);
  *(_DWORD *)(a1 + 65) = 0;
  *(_BYTE *)a1 = 0;
  *(_OWORD *)(a1 + 24) = 0u;
  *(_OWORD *)(a1 + 40) = 0u;
  std::string::assign((std::string *)(a1 + 8), "");
  std::string::assign(v2, "");
  *(_BYTE *)(a1 + 56) = 2;
  *(_DWORD *)(a1 + 60) = 0;
  *(_BYTE *)(a1 + 64) = 0;
  *(_BYTE *)(a1 + 71) = 0;
  return a1;
}

void sub_1001FFA08(_Unwind_Exception *exception_object)
{
}

uint64_t sub_1001FFA38(uint64_t result, char a2)
{
  *(_BYTE *)(result + 71) = a2;
  return result;
}

void sub_1001FFA40(uint64_t a1)
{
  if (qword_1008D60C0 != -1) {
    dispatch_once(&qword_1008D60C0, &stru_100886E80);
  }
  uint64_t v2 = (uint64_t *)(a1 + 32);
  sub_1003F6234((uint64_t)off_1008D60B8, (_BYTE *)(a1 + 64), a1 + 32);
  __int128 v3 = (os_log_s *)qword_1008F7600;
  if (os_log_type_enabled((os_log_t)qword_1008F7600, OS_LOG_TYPE_DEFAULT))
  {
    if (*(_BYTE *)(a1 + 64)) {
      __int128 v4 = "Sign in";
    }
    else {
      __int128 v4 = "Sign out";
    }
    uint64_t v5 = a1 + 32;
    *(_DWORD *)__int128 buf = 136315394;
    uint64_t v10 = v4;
    __int16 v11 = 2080;
    uint64_t v12 = v5;
    _os_log_impl( (void *)&_mh_execute_header,  v3,  OS_LOG_TYPE_DEFAULT,  "Sending version info request to magnet device, local cloud sign-in status = %s, local cloud account = %s",  buf,  0x16u);
  }

  uint64_t v6 = sub_1002E8F6C();
  if (*(char *)(a1 + 55) < 0)
  {
    sub_100024238(__p, *(void **)(a1 + 32), *(void *)(a1 + 40));
  }

  else
  {
    *(_OWORD *)std::stringbuf::string_type __p = *(_OWORD *)v2;
    uint64_t v8 = *(void *)(a1 + 48);
  }

  (*(void (**)(uint64_t, uint64_t, void **))(*(void *)v6 + 72LL))(v6, 1LL, __p);
  if (SHIBYTE(v8) < 0) {
    operator delete(__p[0]);
  }
  *(_DWORD *)(a1 + 60) = 1;
  *(_BYTE *)(a1 + 56) = 2;
}

void sub_1001FFBC8( _Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, void *__p, uint64_t a10, int a11, __int16 a12, char a13, char a14)
{
  if (a14 < 0) {
    operator delete(__p);
  }
  _Unwind_Resume(exception_object);
}

void sub_1001FFBEC(uint64_t a1, int a2, std::string *__str)
{
  __int128 v3 = __str;
  *(_DWORD *)(a1 + 60) = 2;
  *(_BYTE *)a1 = a2;
  std::string::operator=((std::string *)(a1 + 8), __str);
  if (qword_1008D60C0 != -1) {
    dispatch_once(&qword_1008D60C0, &stru_100886E80);
  }
  uint64_t v6 = (void **)(a1 + 32);
  sub_1003F6234((uint64_t)off_1008D60B8, (_BYTE *)(a1 + 64), a1 + 32);
  __int128 v7 = (os_log_s *)qword_1008F7600;
  uint64_t v8 = os_log_type_enabled((os_log_t)qword_1008F7600, OS_LOG_TYPE_DEFAULT);
  if ((_DWORD)v8)
  {
    uint64_t v9 = v3;
    if (*(_BYTE *)(a1 + 64)) {
      uint64_t v10 = "Sign in";
    }
    else {
      uint64_t v10 = "Sign out";
    }
    __int16 v11 = (void *)(a1 + 32);
    *(_DWORD *)__int128 buf = 67109890;
    int v28 = a2;
    __int16 v29 = 2080;
    uint64_t v30 = v9;
    __int16 v31 = 2080;
    uint64_t v32 = v10;
    __int16 v33 = 2080;
    uint64_t v34 = v11;
    _os_log_impl( (void *)&_mh_execute_header,  v7,  OS_LOG_TYPE_DEFAULT,  "Received version info request, remote version = %d, remote cloud account = %s, local cloud sign-in status = %s , local cloud account = %s",  buf,  0x26u);
  }

  if (a2)
  {
    uint64_t size = v3->__r_.__value_.__s.__size_;
    if ((char)v3->__r_.__value_.__s.__size_ < 0)
    {
      if (v3->__r_.__value_.__l.__size_)
      {
LABEL_15:
        if (*(_BYTE *)(a1 + 64))
        {
          char v13 = *(_BYTE *)(a1 + 55);
          if (v13 < 0)
          {
            if (*(void *)(a1 + 40))
            {
LABEL_18:
              if ((size & 0x80u) == 0LL) {
                std::string::size_type v14 = v3->__r_.__value_.__s.__size_;
              }
              else {
                std::string::size_type v14 = v3->__r_.__value_.__l.__size_;
              }
              unint64_t v15 = *(void *)(a1 + 40);
              if (v13 >= 0) {
                uint64_t v16 = *(unsigned __int8 *)(a1 + 55);
              }
              else {
                uint64_t v16 = *(void *)(a1 + 40);
              }
              if (v14 == v16)
              {
                uint64_t v17 = *v6;
                if (v13 >= 0) {
                  uint64_t v18 = (unsigned __int8 *)(a1 + 32);
                }
                else {
                  uint64_t v18 = (unsigned __int8 *)*v6;
                }
                if ((size & 0x80) == 0)
                {
                  if (v3->__r_.__value_.__s.__size_)
                  {
                    while (v3->__r_.__value_.__s.__data_[0] == *v18)
                    {
                      __int128 v3 = (std::string *)((char *)v3 + 1);
                      ++v18;
                      if (!--size) {
                        goto LABEL_44;
                      }
                    }

                    goto LABEL_42;
                  }

                  goto LABEL_44;
                }

                uint64_t v8 = memcmp(v3->__r_.__value_.__l.__data_, v18, v3->__r_.__value_.__l.__size_);
                if (!(_DWORD)v8)
                {
LABEL_44:
                  if (v13 < 0)
                  {
                    uint64_t v8 = (uint64_t)sub_100024238(&v25, v17, v15);
                  }

                  else
                  {
                    __int128 v25 = *(_OWORD *)v6;
                    uint64_t v26 = *(void *)(a1 + 48);
                  }

                  sub_1001FFF44(v8, 1LL, (void **)&v25, 2LL);
                  if ((SHIBYTE(v26) & 0x80000000) == 0) {
                    goto LABEL_53;
                  }
                  p_dst = (void **)&v25;
LABEL_52:
                  operator delete(*p_dst);
LABEL_53:
                  int v19 = 4;
                  goto LABEL_54;
                }
              }

void sub_1001FFEF4( _Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, int a11, __int16 a12, char a13, char a14, uint64_t a15, char a16, uint64_t a17, int a18, __int16 a19, char a20, char a21, uint64_t a22, void *a23, uint64_t a24, int a25, __int16 a26, char a27, char a28)
{
  if (a28 < 0) {
    operator delete(a23);
  }
  _Unwind_Resume(exception_object);
}

void sub_1001FFF44(uint64_t a1, uint64_t a2, void **a3, uint64_t a4)
{
  __int128 v7 = (os_log_s *)qword_1008F7600;
  if (os_log_type_enabled((os_log_t)qword_1008F7600, OS_LOG_TYPE_DEFAULT))
  {
    uint64_t v8 = a3;
    uint64_t v9 = "Disallow";
    *(_DWORD *)__int128 buf = 67109634;
    int v14 = a2;
    __int16 v15 = 2080;
    if ((_DWORD)a4 == 2) {
      uint64_t v9 = "Allow";
    }
    uint64_t v16 = v8;
    __int16 v17 = 2080;
    uint64_t v18 = v9;
    _os_log_impl( (void *)&_mh_execute_header,  v7,  OS_LOG_TYPE_DEFAULT,  "Sending version info response to magnet device, localVersion = %d, localCloudAccount = %s, easyPairingStatus = %s",  buf,  0x1Cu);
  }

  uint64_t v10 = sub_1002E8F6C();
  if (*((char *)a3 + 23) < 0)
  {
    sub_100024238(__p, *a3, (unint64_t)a3[1]);
  }

  else
  {
    *(_OWORD *)std::stringbuf::string_type __p = *(_OWORD *)a3;
    uint64_t v12 = a3[2];
  }

  (*(void (**)(uint64_t, uint64_t, void **, uint64_t))(*(void *)v10 + 80LL))(v10, a2, __p, a4);
  if (SHIBYTE(v12) < 0) {
    operator delete(__p[0]);
  }
}

void sub_10020008C( _Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, void *__p, uint64_t a10, int a11, __int16 a12, char a13, char a14)
{
  if (a14 < 0) {
    operator delete(__p);
  }
  _Unwind_Resume(exception_object);
}

std::string *sub_1002000B0(uint64_t a1, int a2, const std::string *a3, int a4)
{
  uint64_t v8 = (os_log_s *)qword_1008F7600;
  if (os_log_type_enabled((os_log_t)qword_1008F7600, OS_LOG_TYPE_DEFAULT))
  {
    uint64_t v9 = a3;
    uint64_t v10 = "Disallow";
    v12[0] = 67109634;
    v12[1] = a2;
    __int16 v13 = 2080;
    if (a4 == 2) {
      uint64_t v10 = "Allow";
    }
    int v14 = v9;
    __int16 v15 = 2080;
    uint64_t v16 = v10;
    _os_log_impl( (void *)&_mh_execute_header,  v8,  OS_LOG_TYPE_DEFAULT,  "Received version info response, remote version = %d, remote cloud account = %s, easyPairingStatus = %s",  (uint8_t *)v12,  0x1Cu);
  }

  *(_BYTE *)(a1 + 56) = a4;
  *(_BYTE *)a1 = a2;
  *(_DWORD *)(a1 + 60) = 5;
  return std::string::operator=((std::string *)(a1 + 8), a3);
}

void sub_1002001C4(uint64_t a1, uint64_t a2)
{
  __int16 v2 = *(_WORD *)(a2 + 4);
  *(_DWORD *)(a1 + 65) = *(_DWORD *)a2;
  *(_WORD *)(a1 + 69) = v2;
  if (*(_BYTE *)a1 && *(_DWORD *)(a1 + 60) == 3)
  {
    __int128 v3 = (os_log_s *)qword_1008F7600;
    if (os_log_type_enabled((os_log_t)qword_1008F7600, OS_LOG_TYPE_DEFAULT))
    {
      *(_WORD *)__int128 v4 = 0;
      _os_log_impl( (void *)&_mh_execute_header,  v3,  OS_LOG_TYPE_DEFAULT,  "Remote device supports version info query and there is pending cloud sign-in on local device. Delay the response for pairing status request",  v4,  2u);
    }
  }

  else
  {
    sub_100200260(a1, (unsigned __int8 *)(a1 + 65));
  }

uint64_t sub_100200260(uint64_t a1, unsigned __int8 *a2)
{
  __n128 v19 = 0uLL;
  int v20 = 0;
  sub_10052523C((uint64_t)&v19);
  if (qword_1008D5F50 != -1) {
    dispatch_once(&qword_1008D5F50, &stru_100886EA0);
  }
  __int128 v3 = (unsigned __int8 *)sub_1003FFEB0(off_1008D5F48, (uint64_t)a2, 0);
  if (!v3) {
    goto LABEL_7;
  }
  if (qword_1008D67B8 != -1) {
    dispatch_once(&qword_1008D67B8, &stru_100886EC0);
  }
  if (!sub_100535750((uint64_t)off_1008D67B0, v3, &v19))
  {
    uint64_t v4 = 2LL;
    uint64_t v5 = "Paired";
  }

  else
  {
LABEL_7:
    uint64_t v4 = 1LL;
    uint64_t v5 = "Not Paired";
  }

  uint64_t v6 = (os_log_s *)qword_1008F7600;
  if (os_log_type_enabled((os_log_t)qword_1008F7600, OS_LOG_TYPE_DEFAULT))
  {
    sub_1003FE1B4(a2, __p);
    __int128 v7 = v14 >= 0 ? __p : (void **)__p[0];
    *(_DWORD *)__int128 buf = 136315394;
    uint64_t v16 = v7;
    __int16 v17 = 2080;
    uint64_t v18 = v5;
    _os_log_impl( (void *)&_mh_execute_header,  v6,  OS_LOG_TYPE_DEFAULT,  "Sending pair stauts response to magnet device for aacp device %s, pairStatus = %s",  buf,  0x16u);
    if (v14 < 0) {
      operator delete(__p[0]);
    }
  }

  uint64_t v8 = sub_1002E8F6C();
  sub_1003FE1B4(a2, v11);
  (*(void (**)(uint64_t, void **, uint64_t))(*(void *)v8 + 96LL))(v8, v11, v4);
  if (v12 < 0) {
    operator delete(v11[0]);
  }
  return nullsub_63(&v19, v9);
}

void sub_100200440( _Unwind_Exception *a1, uint64_t a2, int a3, int a4, int a5, int a6, int a7, int a8, void *__p, uint64_t a10, int a11, __int16 a12, char a13, char a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20, uint64_t a21, char a22)
{
}

BOOL sub_100200478(uint64_t a1)
{
  __int16 v2 = (os_log_s *)qword_1008F7600;
  if (os_log_type_enabled((os_log_t)qword_1008F7600, OS_LOG_TYPE_DEFAULT))
  {
    int v3 = *(unsigned __int8 *)(a1 + 71);
    int v4 = *(_DWORD *)(a1 + 60);
    if (*(_BYTE *)(a1 + 56) == 2) {
      uint64_t v5 = "Allow";
    }
    else {
      uint64_t v5 = "Disallow";
    }
    v7[0] = 67109634;
    v7[1] = v3;
    __int16 v8 = 1024;
    int v9 = v4;
    __int16 v10 = 2080;
    __int16 v11 = v5;
    _os_log_impl( (void *)&_mh_execute_header,  v2,  OS_LOG_TYPE_DEFAULT,  "Current MagnetVersion = %d, VersionInfoState = %d, EasyPairingStatus = %s",  (uint8_t *)v7,  0x18u);
  }

  if (*(_DWORD *)(a1 + 60) == 5) {
    return *(_BYTE *)(a1 + 56) == 2;
  }
  return 0LL;
}

void sub_100200588(uint64_t a1, int a2, std::string *__str)
{
  if (*(unsigned __int8 *)(a1 + 64) != a2)
  {
    int v3 = __str;
    *(_BYTE *)(a1 + 64) = a2;
    uint64_t v6 = (unsigned __int8 *)(a1 + 32);
    std::string::operator=((std::string *)(a1 + 32), __str);
    __int128 v7 = (os_log_s *)qword_1008F7600;
    uint64_t v8 = os_log_type_enabled((os_log_t)qword_1008F7600, OS_LOG_TYPE_DEFAULT);
    if ((_DWORD)v8)
    {
      int v9 = "Sign out";
      if (a2) {
        int v9 = "Sign in";
      }
      *(_DWORD *)__int128 buf = 136315394;
      __int128 v25 = v9;
      __int16 v26 = 2080;
      uint64_t v27 = v3;
      _os_log_impl( (void *)&_mh_execute_header,  v7,  OS_LOG_TYPE_DEFAULT,  "Cloud sign-in status changed, status = %s, cloudAccount = %s",  buf,  0x16u);
    }

    if (*(_DWORD *)(a1 + 60) == 3)
    {
      unint64_t v10 = *(void *)(a1 + 40);
      else {
        uint64_t v11 = *(void *)(a1 + 40);
      }
      uint64_t v12 = *(unsigned __int8 *)(a1 + 31);
      int v13 = (char)v12;
      if ((v12 & 0x80u) != 0LL) {
        uint64_t v12 = *(void *)(a1 + 16);
      }
      if (v11 == v12)
      {
        if (v13 >= 0) {
          char v14 = (unsigned __int8 *)(a1 + 8);
        }
        else {
          char v14 = *(unsigned __int8 **)(a1 + 8);
        }
        if ((*(_BYTE *)(a1 + 55) & 0x80) != 0)
        {
          __int16 v17 = *(void **)v6;
          if (memcmp(v17, v14, *(void *)(a1 + 40))) {
            goto LABEL_28;
          }
          uint64_t v8 = (uint64_t)sub_100024238(&__dst, v17, v10);
        }

        else
        {
          if (*(_BYTE *)(a1 + 55))
          {
            __int16 v15 = v6;
            uint64_t v16 = *(unsigned __int8 *)(a1 + 55);
            while (*v15 == *v14)
            {
              ++v15;
              ++v14;
              if (!--v16) {
                goto LABEL_23;
              }
            }

            goto LABEL_24;
          }

void sub_1002007C8( _Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, int a11, __int16 a12, char a13, char a14, uint64_t a15, void *a16, uint64_t a17, int a18, __int16 a19, char a20, char a21)
{
  if (a21 < 0) {
    operator delete(a16);
  }
  _Unwind_Resume(exception_object);
}

void sub_100200804(id a1)
{
  uint64_t v1 = operator new(0xF8uLL);
  sub_1003EC784((uint64_t)v1);
  off_1008D60B8 = v1;
}

void sub_100200834(_Unwind_Exception *a1)
{
}

void sub_100200848(id a1)
{
  uint64_t v1 = operator new(0x138uLL);
  sub_1003FE3E0((uint64_t)v1);
  off_1008D5F48 = v1;
}

void sub_100200878(_Unwind_Exception *a1)
{
}

void sub_10020088C(id a1)
{
  uint64_t v1 = operator new(0x198uLL);
  sub_100534AB0();
  off_1008D67B0 = v1;
}

void sub_1002008BC(_Unwind_Exception *a1)
{
}

uint64_t sub_1002008D0(uint64_t a1, unint64_t a2)
{
  unint64_t v18 = a2;
  if (a2)
  {
    v17[0] = 0LL;
    v17[1] = 0LL;
    sub_100242F28((uint64_t)v17, a1);
    uint64_t v6 = *(void **)(a1 + 72);
    uint64_t v5 = a1 + 72;
    int v4 = v6;
    if (!v6) {
      goto LABEL_13;
    }
    __int128 v7 = (void *)v5;
    do
    {
      unint64_t v8 = v4[4];
      BOOL v9 = v8 >= a2;
      if (v8 >= a2) {
        unint64_t v10 = v4;
      }
      else {
        unint64_t v10 = v4 + 1;
      }
      if (v9) {
        __int128 v7 = v4;
      }
      int v4 = (void *)*v10;
    }

    while (*v10);
    if (v7 == (void *)v5 || v7[4] > a2)
    {
LABEL_13:
      uint64_t v11 = (char *)operator new(0x10CuLL);
      *(_OWORD *)(v11 + 252) = 0u;
      *((_OWORD *)v11 + 14) = 0u;
      *((_OWORD *)v11 + 15) = 0u;
      *((_OWORD *)v11 + 12) = 0u;
      *((_OWORD *)v11 + 13) = 0u;
      *((_OWORD *)v11 + 10) = 0u;
      *((_OWORD *)v11 + 11) = 0u;
      *((_OWORD *)v11 + std::iostream::~basic_iostream(v2, v3 + 8) = 0u;
      *((_OWORD *)v11 + 9) = 0u;
      *((_OWORD *)v11 + 6) = 0u;
      *((_OWORD *)v11 + memset((char *)&v11[1] + 1, 0, 7) = 0u;
      *((_OWORD *)v11 + 4) = 0u;
      *((_OWORD *)v11 + 5) = 0u;
      *((_OWORD *)v11 + 2) = 0u;
      *((_OWORD *)v11 + 3) = 0u;
      *(_OWORD *)uint64_t v11 = 0u;
      *((_OWORD *)v11 + 1) = 0u;
      sub_1003D0100(a2, (uint64_t)__p);
      if (v16 >= 0) {
        uint64_t v12 = __p;
      }
      else {
        uint64_t v12 = (void **)__p[0];
      }
      strlcpy(v11 + 12, (const char *)v12, 0x100uLL);
      int v13 = (uint64_t **)(v5 - 8);
      if (v16 < 0) {
        operator delete(__p[0]);
      }
      __p[0] = &v18;
      sub_100029574(v13, &v18, (uint64_t)&unk_1006C2518, (uint64_t **)__p)[5] = (uint64_t)v11;
    }

    sub_100242FAC((uint64_t)v17);
    return 0LL;
  }

  else
  {
    if (os_log_type_enabled((os_log_t)qword_1008F76A0, OS_LOG_TYPE_ERROR)) {
      sub_10065DD44();
    }
    return 3LL;
  }

void sub_100200A2C( _Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void *__p, uint64_t a11, int a12, __int16 a13, char a14, char a15, char a16)
{
  if (a15 < 0) {
    operator delete(__p);
  }
  sub_100242FAC((uint64_t)&a16);
  _Unwind_Resume(a1);
}

uint64_t sub_100200A5C(uint64_t a1, unint64_t a2)
{
  unint64_t v17 = a2;
  if (a2)
  {
    v16[0] = 0LL;
    v16[1] = 0LL;
    sub_100242F28((uint64_t)v16, a1);
    uint64_t v6 = *(void **)(a1 + 72);
    uint64_t v5 = a1 + 72;
    int v4 = v6;
    if (!v6) {
      goto LABEL_13;
    }
    __int128 v7 = (void *)v5;
    do
    {
      unint64_t v8 = v4[4];
      BOOL v9 = v8 >= a2;
      if (v8 >= a2) {
        unint64_t v10 = v4;
      }
      else {
        unint64_t v10 = v4 + 1;
      }
      if (v9) {
        __int128 v7 = v4;
      }
      int v4 = (void *)*v10;
    }

    while (*v10);
    if (v7 != (void *)v5 && v7[4] <= a2)
    {
      v15[0] = (uint64_t *)&v17;
      char v14 = (void *)sub_100029574((uint64_t **)(v5 - 8), &v17, (uint64_t)&unk_1006C2518, v15)[5];
      if (v14) {
        operator delete(v14);
      }
      sub_10020166C(v5 - 8, &v17);
      uint64_t v12 = 0LL;
    }

    else
    {
LABEL_13:
      uint64_t v11 = (os_log_s *)(id)qword_1008F76A0;
      if (os_log_type_enabled(v11, OS_LOG_TYPE_ERROR))
      {
        sub_1003D0100(a2, (uint64_t)v15);
        sub_10065DD70();
      }

      uint64_t v12 = 3LL;
    }

    sub_100242FAC((uint64_t)v16);
  }

  else
  {
    if (os_log_type_enabled((os_log_t)qword_1008F76A0, OS_LOG_TYPE_ERROR)) {
      sub_10065DD44();
    }
    return 3LL;
  }

  return v12;
}

void sub_100200BD0(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, ...)
{
}

uint64_t sub_100200BF8(uint64_t a1, unint64_t a2, int a3, int a4)
{
  unint64_t v20 = a2;
  if (!a2)
  {
    if (os_log_type_enabled((os_log_t)qword_1008F76A0, OS_LOG_TYPE_ERROR)) {
      sub_10065DDBC();
    }
    return 3LL;
  }

  if (a3 >= 1)
  {
    if (os_log_type_enabled((os_log_t)qword_1008F76A0, OS_LOG_TYPE_ERROR)) {
      sub_10065DDE8();
    }
    return 3LL;
  }

  v19[0] = 0LL;
  v19[1] = 0LL;
  sub_100242F28((uint64_t)v19, a1);
  uint64_t v11 = *(void **)(a1 + 72);
  uint64_t v10 = a1 + 72;
  BOOL v9 = v11;
  if (!v11) {
    goto LABEL_19;
  }
  uint64_t v12 = (void *)v10;
  do
  {
    unint64_t v13 = v9[4];
    BOOL v14 = v13 >= a2;
    if (v13 >= a2) {
      __int16 v15 = v9;
    }
    else {
      __int16 v15 = v9 + 1;
    }
    if (v14) {
      uint64_t v12 = v9;
    }
    BOOL v9 = (void *)*v15;
  }

  while (*v15);
  if (v12 != (void *)v10 && v12[4] <= a2)
  {
    if (a3)
    {
      uint64_t v5 = 0LL;
    }

    else
    {
      unint64_t v18 = (os_log_s *)qword_1008F76A0;
      if (os_log_type_enabled((os_log_t)qword_1008F76A0, OS_LOG_TYPE_DEFAULT))
      {
        *(_DWORD *)__int128 buf = 67109120;
        *(_DWORD *)&uint8_t buf[4] = a4;
        _os_log_impl( (void *)&_mh_execute_header,  v18,  OS_LOG_TYPE_DEFAULT,  "BTLQ set Link Quality Data codec to %u",  buf,  8u);
      }

      *(void *)__int128 buf = &v20;
      uint64_t v5 = 0LL;
      *(_WORD *)(sub_100029574((uint64_t **)(v10 - 8), &v20, (uint64_t)&unk_1006C2518, (uint64_t **)buf)[5] + 10) = a4;
    }
  }

  else
  {
LABEL_19:
    char v16 = (os_log_s *)(id)qword_1008F76A0;
    if (os_log_type_enabled(v16, OS_LOG_TYPE_ERROR))
    {
      sub_1003D0100(a2, (uint64_t)buf);
      sub_10065DE14();
    }

    uint64_t v5 = 7LL;
  }

  sub_100242FAC((uint64_t)v19);
  return v5;
}

void sub_100200DF8(_Unwind_Exception *a1, uint64_t a2, ...)
{
}

uint64_t sub_100200E20(uint64_t a1, _WORD *a2)
{
  if (a2)
  {
    v13[0] = 0LL;
    v13[1] = 0LL;
    sub_100242F28((uint64_t)v13, a1);
    int v4 = *(void **)(a1 + 64);
    uint64_t v5 = a1 + 72;
    if (v4 == (void *)v5)
    {
      __int16 v10 = 0;
    }

    else
    {
      unint64_t v6 = 0LL;
      do
      {
        memcpy(&a2[134 * v6 + 1], (const void *)v4[5], 0x10CuLL);
        __int128 v7 = (void *)v4[1];
        unint64_t v8 = v4;
        if (v7)
        {
          do
          {
            int v4 = v7;
            __int128 v7 = (void *)*v7;
          }

          while (v7);
        }

        else
        {
          do
          {
            int v4 = (void *)v8[2];
            BOOL v9 = *v4 == (void)v8;
            unint64_t v8 = v4;
          }

          while (!v9);
        }

        __int16 v10 = v6 + 1;
        if (v4 == (void *)v5) {
          break;
        }
      }

      while (v6++ < 2);
    }

    *a2 = v10;
    sub_100242FAC((uint64_t)v13);
    return 0LL;
  }

  else
  {
    if (os_log_type_enabled((os_log_t)qword_1008F76A0, OS_LOG_TYPE_ERROR)) {
      sub_10065DE60();
    }
    return 3LL;
  }

id sub_100200F28(uint64_t a1)
{
  v18[0] = 0LL;
  v18[1] = 0LL;
  sub_100242F28((uint64_t)v18, a1);
  __int16 v2 = *(void **)(a1 + 64);
  int v3 = (void *)(a1 + 72);
  if (v2 == (void *)(a1 + 72))
  {
    id v16 = 0LL;
  }

  else
  {
    int v4 = objc_alloc_init(&OBJC_CLASS___NSMutableArray);
    do
    {
      uint64_t v5 = (unsigned __int8 *)v2[5];
      id v6 = objc_alloc_init(&OBJC_CLASS___CBAudioLinkQualityInfo);
      [v6 setAosState:*v5];
      [v6 setBitRate:1000 * *((unsigned __int16 *)v5 + 3)];
      int v7 = *((unsigned __int16 *)v5 + 5);
      if (v7 == 33023) {
        unsigned int v8 = 30;
      }
      else {
        unsigned int v8 = 0;
      }
      if (v7 == 2) {
        unsigned int v8 = 20;
      }
      if (*((_WORD *)v5 + 5)) {
        uint64_t v9 = v8;
      }
      else {
        uint64_t v9 = 10LL;
      }
      [v6 setCodecType:v9];
      __int16 v10 = [NSString stringWithUTF8String:v5 + 12];
      [v6 setDeviceName:v10];

      [v6 setBtBand:v5[1]];
      LOWORD(v11) = *((_WORD *)v5 + 4);
      [v6 setJitterBufferSeconds:(double)v11 / 1000.0];
      [v6 setNoiseFloor90:(char)v5[4]];
      LOBYTE(v12) = v5[2];
      [v6 setRetransmitRate:(double)v12 / 100.0];
      [v6 setRssiAverage:(char)v5[3]];
      [v6 setSignalToNoiseRatio:(char)v5[5]];
      -[NSMutableArray addObject:](v4, "addObject:", v6);

      unint64_t v13 = (void *)v2[1];
      if (v13)
      {
        do
        {
          BOOL v14 = v13;
          unint64_t v13 = (void *)*v13;
        }

        while (v13);
      }

      else
      {
        do
        {
          BOOL v14 = (void *)v2[2];
          BOOL v15 = *v14 == (void)v2;
          __int16 v2 = v14;
        }

        while (!v15);
      }

      __int16 v2 = v14;
    }

    while (v14 != v3);
    id v16 = -[NSMutableArray copy](v4, "copy");
  }

  sub_100242FAC((uint64_t)v18);
  return v16;
}

void sub_100201104( _Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9)
{
  sub_100242FAC((uint64_t)&a9);
  _Unwind_Resume(a1);
}

uint64_t sub_100201148(uint64_t a1, unint64_t a2, uint64_t a3, __int16 a4, __int16 a5)
{
  unint64_t v30 = a2;
  if (a2 && a3)
  {
    v29[0] = 0LL;
    v29[1] = 0LL;
    sub_100242F28((uint64_t)v29, a1);
    unint64_t v12 = *(void **)(a1 + 72);
    uint64_t v11 = a1 + 72;
    __int16 v10 = v12;
    if (!v12) {
      goto LABEL_14;
    }
    unint64_t v13 = (uint64_t **)(v11 - 8);
    BOOL v14 = (void *)v11;
    do
    {
      unint64_t v15 = v10[4];
      BOOL v16 = v15 >= a2;
      if (v15 >= a2) {
        unint64_t v17 = v10;
      }
      else {
        unint64_t v17 = v10 + 1;
      }
      if (v16) {
        BOOL v14 = v10;
      }
      __int16 v10 = (void *)*v17;
    }

    while (*v17);
    if (v14 != (void *)v11 && v14[4] <= a2)
    {
      v28[0] = (uint64_t *)&v30;
      uint64_t v22 = sub_100029574((uint64_t **)(v11 - 8), &v30, (uint64_t)&unk_1006C2518, v28)[5];
      if (v22)
      {
        unsigned int v23 = *(unsigned __int16 *)(a3 + 16);
        if (*(_WORD *)(a3 + 16)) {
          unsigned int v23 = 100 * *(unsigned __int16 *)(a3 + 18) / v23;
        }
        *(_BYTE *)(v22 + 2) = v23;
        *(_BYTE *)uint64_t v22 = *(_BYTE *)(v30 + 1371);
        v28[0] = (uint64_t *)&v30;
        if (!*(_BYTE *)(sub_100029574(v13, &v30, (uint64_t)&unk_1006C2518, v28)[5] + 1))
        {
          uint64_t v24 = sub_10012D9F4(v30 + 128);
          if (v24)
          {
            unsigned int v25 = *(unsigned __int8 *)(v24 + 289);
            if (v25 <= 1) {
              LOBYTE(v25) = 1;
            }
          }

          else
          {
            LOBYTE(v25) = 1;
          }

          *(_BYTE *)(v22 + 1) = v25;
        }

        uint64_t v19 = 0LL;
        char v26 = *(_BYTE *)(a3 + 6);
        *(_BYTE *)(v22 + 3) = v26;
        char v27 = *(_BYTE *)(a3 + 219);
        *(_BYTE *)(v22 + 4) = v27;
        *(_BYTE *)(v22 + 5) = v26 - v27;
        *(_WORD *)(v22 + 6) = a4;
        *(_WORD *)(v22 + std::iostream::~basic_iostream(v2, v3 + 8) = a5;
      }

      else
      {
        uint64_t v19 = 7LL;
      }
    }

    else
    {
LABEL_14:
      unint64_t v18 = (os_log_s *)(id)qword_1008F76A0;
      if (os_log_type_enabled(v18, OS_LOG_TYPE_ERROR))
      {
        sub_1003D0100(a2, (uint64_t)v28);
        sub_10065DE8C();
      }

      uint64_t v19 = 3LL;
    }

    sub_100242FAC((uint64_t)v29);
  }

  else
  {
    unint64_t v20 = (os_log_s *)qword_1008F76A0;
    if (os_log_type_enabled((os_log_t)qword_1008F76A0, OS_LOG_TYPE_ERROR)) {
      sub_10065DED8(a2, v20);
    }
    return 3LL;
  }

  return v19;
}

void sub_100201370(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, ...)
{
}

void sub_10020139C(uint64_t a1, uint64_t a2, char a3)
{
  if (qword_1008D60F0 != -1) {
    dispatch_once(&qword_1008D60F0, &stru_100886F00);
  }
  id v6 = (dispatch_queue_s *)*((void *)off_1008D60E8 + 30);
  block[0] = _NSConcreteStackBlock;
  block[1] = 3221225472LL;
  block[2] = sub_100201440;
  block[3] = &unk_100886EE0;
  void block[4] = a1;
  void block[5] = a2;
  char v8 = a3;
  dispatch_async(v6, block);
}

void sub_100201440(uint64_t a1)
{
  uint64_t v2 = *(void *)(a1 + 32);
  if (qword_1008D60F0 != -1) {
    dispatch_once(&qword_1008D60F0, &stru_100886F00);
  }
  int v3 = (void *)*((void *)off_1008D60E8 + 25);
  if (v3)
  {
    int v4 = (uint64_t *)(a1 + 40);
    unint64_t v5 = *(void *)(a1 + 40);
    id v6 = (char *)off_1008D60E8 + 200;
    do
    {
      unint64_t v7 = v3[4];
      BOOL v8 = v7 >= v5;
      if (v7 >= v5) {
        uint64_t v9 = v3;
      }
      else {
        uint64_t v9 = v3 + 1;
      }
      if (v8) {
        id v6 = (char *)v3;
      }
      int v3 = (void *)*v9;
    }

    while (*v9);
    if (v6 != (char *)off_1008D60E8 + 200 && v5 >= *((void *)v6 + 4))
    {
      char v10 = *(_BYTE *)(a1 + 48);
      uint64_t v11 = v4;
      *(_BYTE *)sub_100029574((uint64_t **)(v2 + 64), (unint64_t *)v4, (uint64_t)&unk_1006C2518, &v11)[5] = v10;
    }
  }

void sub_100201504(uint64_t a1, uint64_t a2, char a3)
{
  if (qword_1008D60F0 != -1) {
    dispatch_once(&qword_1008D60F0, &stru_100886F00);
  }
  id v6 = (dispatch_queue_s *)*((void *)off_1008D60E8 + 30);
  block[0] = _NSConcreteStackBlock;
  block[1] = 3221225472LL;
  block[2] = sub_1002015A8;
  block[3] = &unk_100886EE0;
  void block[4] = a1;
  void block[5] = a2;
  char v8 = a3;
  dispatch_async(v6, block);
}

void sub_1002015A8(uint64_t a1)
{
  uint64_t v2 = *(void *)(a1 + 32);
  if (qword_1008D60F0 != -1) {
    dispatch_once(&qword_1008D60F0, &stru_100886F00);
  }
  int v3 = (void *)*((void *)off_1008D60E8 + 25);
  if (v3)
  {
    int v4 = (uint64_t *)(a1 + 40);
    unint64_t v5 = *(void *)(a1 + 40);
    id v6 = (char *)off_1008D60E8 + 200;
    do
    {
      unint64_t v7 = v3[4];
      BOOL v8 = v7 >= v5;
      if (v7 >= v5) {
        uint64_t v9 = v3;
      }
      else {
        uint64_t v9 = v3 + 1;
      }
      if (v8) {
        id v6 = (char *)v3;
      }
      int v3 = (void *)*v9;
    }

    while (*v9);
    if (v6 != (char *)off_1008D60E8 + 200 && v5 >= *((void *)v6 + 4))
    {
      char v10 = *(_BYTE *)(a1 + 48);
      uint64_t v11 = v4;
      *(_BYTE *)(sub_100029574((uint64_t **)(v2 + 64), (unint64_t *)v4, (uint64_t)&unk_1006C2518, &v11)[5] + 1) = v10;
    }
  }

uint64_t sub_10020166C(uint64_t a1, unint64_t *a2)
{
  uint64_t v2 = *(void **)(a1 + 8);
  if (!v2) {
    return 0LL;
  }
  unint64_t v3 = *a2;
  int v4 = (uint64_t *)(a1 + 8);
  do
  {
    unint64_t v5 = v2[4];
    BOOL v6 = v5 >= v3;
    if (v5 >= v3) {
      unint64_t v7 = v2;
    }
    else {
      unint64_t v7 = v2 + 1;
    }
    if (v6) {
      int v4 = v2;
    }
    uint64_t v2 = (void *)*v7;
  }

  while (*v7);
  sub_1001FDBCC((uint64_t **)a1, v4);
  operator delete(v4);
  return 1LL;
}

void sub_1002016E4(id a1)
{
  uint64_t v1 = operator new(0x4A8uLL);
  sub_100499870();
  off_1008D60E8 = v1;
}

void sub_100201714(_Unwind_Exception *a1)
{
}

  ;
}

void sub_100201740(void *a1, int a2, os_log_t log, const char *a4, uint8_t *a5)
{
}

void sub_100201750()
{
}

void sub_1002017F4(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_100201A34(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_100201A90(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_100201AE4(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_100201E6C( _Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, id location, char a21, uint64_t a22, uint64_t a23, uint64_t a24, uint64_t a25, void *a26)
{
  objc_destroyWeak(&location);
  _Unwind_Resume(a1);
}

uint64_t sub_100201EE8(uint64_t result, uint64_t a2)
{
  *(void *)(result + 40) = *(void *)(a2 + 40);
  *(void *)(a2 + 40) = 0LL;
  return result;
}

void sub_100201EF8(uint64_t a1)
{
}

void sub_100201F00(uint64_t a1, int a2, void *a3)
{
  id v6 = a3;
  id WeakRetained = objc_loadWeakRetained((id *)(a1 + 40));
  if (WeakRetained)
  {
    BOOL v8 = (os_log_s *)qword_1008F7710;
    if (os_log_type_enabled((os_log_t)qword_1008F7710, OS_LOG_TYPE_DEFAULT))
    {
      int v21 = 67109120;
      LODWORD(vmemset(v6, 0, 22) = a2;
      _os_log_impl( (void *)&_mh_execute_header,  v8,  OS_LOG_TYPE_DEFAULT,  "[BTVCBonjourService] advertiser state handler with state %d",  (uint8_t *)&v21,  8u);
    }

    if (v6)
    {
      uint64_t v9 = (os_log_s *)qword_1008F7710;
      if (os_log_type_enabled((os_log_t)qword_1008F7710, OS_LOG_TYPE_DEFAULT))
      {
        int v21 = 138412290;
        id v22 = v6;
        _os_log_impl( (void *)&_mh_execute_header,  v9,  OS_LOG_TYPE_DEFAULT,  "[BTVCBonjourService] advertiser error %@",  (uint8_t *)&v21,  0xCu);
      }
    }

    switch(a2)
    {
      case 4:
        BOOL v14 = (os_log_s *)qword_1008F7710;
        if (os_log_type_enabled((os_log_t)qword_1008F7710, OS_LOG_TYPE_DEFAULT))
        {
          LOWORD(v21) = 0;
          _os_log_impl( (void *)&_mh_execute_header,  v14,  OS_LOG_TYPE_DEFAULT,  "[BTVCBonjourService] advertiser cancelled",  (uint8_t *)&v21,  2u);
        }

        [WeakRetained setListener:0];
        [WeakRetained _cleanupAdvertiser];
        unint64_t v15 = *(nw_error **)(*(void *)(*(void *)(a1 + 32) + 8LL) + 40LL);
        if (v15) {
          CFErrorRef v13 = nw_error_copy_cf_error(v15);
        }
        else {
          CFErrorRef v13 = 0LL;
        }
        BOOL v16 = [WeakRetained advertisingStateUpdateHandler];
        BOOL v17 = v16 == 0LL;

        if (!v17)
        {
          unint64_t v18 = (void (**)(void, void, void))objc_claimAutoreleasedReturnValue( [WeakRetained advertisingStateUpdateHandler]);
          ((void (**)(void, void, CFErrorRef))v18)[2](v18, 0LL, v13);
        }

        uint64_t v19 = *(void *)(*(void *)(a1 + 32) + 8LL);
        unint64_t v20 = *(void **)(v19 + 40);
        *(void *)(v19 + 40) = 0LL;

        goto LABEL_25;
      case 3:
        if (os_log_type_enabled((os_log_t)qword_1008F7710, OS_LOG_TYPE_ERROR)) {
          sub_10065DF90();
        }
        objc_storeStrong((id *)(*(void *)(*(void *)(a1 + 32) + 8LL) + 40LL), a3);
        CFErrorRef v13 = [WeakRetained listener];
        nw_listener_cancel(v13);
        goto LABEL_25;
      case 2:
        char v10 = (os_log_s *)qword_1008F7710;
        if (os_log_type_enabled((os_log_t)qword_1008F7710, OS_LOG_TYPE_DEFAULT))
        {
          LOWORD(v21) = 0;
          _os_log_impl( (void *)&_mh_execute_header,  v10,  OS_LOG_TYPE_DEFAULT,  "[BTVCBonjourService] advertiser is ready",  (uint8_t *)&v21,  2u);
        }

        [WeakRetained setAdvertiserState:2];
        uint64_t v11 = (void *)[WeakRetained advertisingStateUpdateHandler];
        BOOL v12 = v11 == 0LL;

        if (!v12)
        {
          CFErrorRef v13 = [WeakRetained advertisingStateUpdateHandler];
          (*((void (**)(CFErrorRef, uint64_t, void))v13 + 2))(v13, 1LL, 0LL);
LABEL_25:
        }

        break;
    }
  }
}

void sub_1002021E0(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_10020222C(uint64_t a1, void *a2)
{
  id v3 = a2;
  id WeakRetained = objc_loadWeakRetained((id *)(a1 + 32));
  unint64_t v5 = (void *)[WeakRetained _handleConnection:v3 isAdvToBrowserConnection:1];

  id v6 = (os_log_s *)qword_1008F7710;
  if (os_log_type_enabled((os_log_t)qword_1008F7710, OS_LOG_TYPE_DEFAULT))
  {
    int v7 = 138412546;
    id v8 = v3;
    __int16 v9 = 2112;
    char v10 = v5;
    _os_log_impl( (void *)&_mh_execute_header,  v6,  OS_LOG_TYPE_DEFAULT,  "[BTVCBonjourService] New Adv to browser connection %@ (endpoint %@)",  (uint8_t *)&v7,  0x16u);
  }
}

void sub_100202314(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_100202468(uint64_t a1)
{
  uint64_t v2 = (void *)[*(id *)(a1 + 32) advertiserAdvs];
  unsigned int v3 = [v2 containsObject:*(void *)(a1 + 40)];

  if (v3)
  {
    int v4 = (os_log_s *)qword_1008F7710;
    if (os_log_type_enabled((os_log_t)qword_1008F7710, OS_LOG_TYPE_DEFAULT))
    {
      uint64_t v5 = *(void *)(a1 + 40);
      int v13 = 138412290;
      uint64_t v14 = v5;
      _os_log_impl( (void *)&_mh_execute_header,  v4,  OS_LOG_TYPE_DEFAULT,  "[BTVCBonjourService] Already advertising for advData %@",  (uint8_t *)&v13,  0xCu);
    }
  }

  else
  {
    id v6 = [*(id *)(a1 + 32) advertiserAdvs];
    [v6 addObject:*(void *)(a1 + 40)];

    int v7 = (os_log_s *)qword_1008F7710;
    if (os_log_type_enabled((os_log_t)qword_1008F7710, OS_LOG_TYPE_DEFAULT))
    {
      uint64_t v8 = *(void *)(a1 + 40);
      int v13 = 138412290;
      uint64_t v14 = v8;
      _os_log_impl( (void *)&_mh_execute_header,  v7,  OS_LOG_TYPE_DEFAULT,  "[BTVCBonjourService] Starting advertising with advData %@",  (uint8_t *)&v13,  0xCu);
    }

    unsigned int v9 = [*(id *)(a1 + 32) advertiserState];
    char v10 = *(_BYTE **)(a1 + 32);
    if (v9 == 3)
    {
      v10[25] = 1;
    }

    else
    {
      unsigned int v11 = [v10 advertiserState];
      BOOL v12 = *(void **)(a1 + 32);
      if (v11 == 2) {
        [v12 _sendAdvMessageWithData:*(void *)(a1 + 40) isStart:1 completionHandler:*(void *)(a1 + 48)];
      }
      else {
        [v12 _startAdvertiser];
      }
    }
  }

void sub_1002025FC(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_100202718(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

id sub_1002027DC(uint64_t a1)
{
  unsigned __int8 v2 = [*(id *)(*(void *)(a1 + 32) + 160) containsObject:*(void *)(a1 + 40)];
  unsigned int v3 = (os_log_s *)qword_1008F7710;
  BOOL v4 = os_log_type_enabled((os_log_t)qword_1008F7710, OS_LOG_TYPE_DEFAULT);
  if ((v2 & 1) != 0)
  {
    if (v4)
    {
      uint64_t v5 = *(void *)(a1 + 40);
      int v9 = 138412290;
      uint64_t v10 = v5;
      _os_log_impl( (void *)&_mh_execute_header,  v3,  OS_LOG_TYPE_DEFAULT,  "[BTVCBonjourService] Stop advertising for advData %@",  (uint8_t *)&v9,  0xCu);
    }

    if ([*(id *)(a1 + 32) advertiserState] == 2) {
      [*(id *)(a1 + 32) _sendAdvMessageWithData:*(void *)(a1 + 40) isStart:0 completionHandler:*(void *)(a1 + 48)];
    }
    [*(id *)(*(void *)(a1 + 32) + 160) removeObject:*(void *)(a1 + 40)];
    id result = [*(id *)(*(void *)(a1 + 32) + 160) count];
    if (!result)
    {
      int v7 = (os_log_s *)qword_1008F7710;
      if (os_log_type_enabled((os_log_t)qword_1008F7710, OS_LOG_TYPE_DEFAULT))
      {
        LOWORD(v9) = 0;
        _os_log_impl( (void *)&_mh_execute_header,  v7,  OS_LOG_TYPE_DEFAULT,  "[BTVCBonjourService] No more advertisements, stopping advertiser completely.",  (uint8_t *)&v9,  2u);
      }

      *(_BYTE *)(*(void *)(a1 + 32) + 25LL) = 0;
      return [*(id *)(a1 + 32) _stopAdvertising];
    }
  }

  else
  {
    if (v4)
    {
      uint64_t v8 = *(void *)(a1 + 40);
      int v9 = 138412290;
      uint64_t v10 = v8;
      _os_log_impl( (void *)&_mh_execute_header,  v3,  OS_LOG_TYPE_DEFAULT,  "[BTVCBonjourService] Unable to stop advertising for advData %@",  (uint8_t *)&v9,  0xCu);
    }

    id result = *(id *)(a1 + 48);
    if (result) {
      return (id)(*((uint64_t (**)(id, void, void))result + 2))(result, *(void *)(a1 + 40), 0LL);
    }
  }

  return result;
}

void sub_100202A20(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_100202A30(id a1, id a2, BTVCBonjourEndpoint *a3, BOOL *a4)
{
  BOOL v4 = a3;
}

void sub_100202A6C( _Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, id a10)
{
}

void sub_100202B0C( _Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, id a10)
{
  _Unwind_Resume(a1);
}

BOOL sub_100202B2C(id a1, id a2, BTVCBonjourEndpoint *a3, BOOL *a4)
{
  return !-[BTVCBonjourEndpoint isConnected](a3, "isConnected");
}

void sub_100202DA4( _Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, id location)
{
  _Unwind_Resume(a1);
}

void sub_100202E04(uint64_t a1, int a2, void *a3)
{
  id v5 = a3;
  id v6 = (os_log_s *)qword_1008F7710;
  if (os_log_type_enabled((os_log_t)qword_1008F7710, OS_LOG_TYPE_DEFAULT))
  {
    v13[0] = 67109378;
    v13[1] = a2;
    __int16 v14 = 2112;
    id v15 = v5;
    _os_log_impl( (void *)&_mh_execute_header,  v6,  OS_LOG_TYPE_DEFAULT,  "[BTVCBonjourService] nw_browser_state_t changed:%d error:%@",  (uint8_t *)v13,  0x12u);
  }

  id WeakRetained = objc_loadWeakRetained((id *)(a1 + 32));
  uint64_t v8 = WeakRetained;
  if (WeakRetained)
  {
    if ((a2 - 2) >= 2)
    {
      if (a2 == 1)
      {
        [WeakRetained setBrowserState:2];
        int v9 = (os_log_s *)qword_1008F7710;
        if (os_log_type_enabled((os_log_t)qword_1008F7710, OS_LOG_TYPE_DEFAULT))
        {
          LOWORD(v13[0]) = 0;
          _os_log_impl( (void *)&_mh_execute_header,  v9,  OS_LOG_TYPE_DEFAULT,  "[BTVCBonjourService] BTVCBonjourServiceBrowser successfully started",  (uint8_t *)v13,  2u);
        }

        uint64_t v10 = (void *)[v8 deviceDidStartScanning];
        BOOL v11 = v10 == 0LL;

        if (!v11)
        {
          BOOL v12 = [v8 deviceDidStartScanning];
          v12[2](v12, 0LL);
        }
      }
    }

    else
    {
      [WeakRetained setBrowser:0];
      [v8 _cleanupBrowser];
    }
  }
}

void sub_100202F94(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_100202FBC(uint64_t a1, void *a2, void *a3, int a4)
{
  old_id result = a2;
  int v7 = a3;
  id WeakRetained = objc_loadWeakRetained((id *)(a1 + 32));
  if (WeakRetained)
  {
    nw_browse_result_change_t changes = nw_browse_result_get_changes(old_result, v7);
    if (changes >= 2)
    {
      uint64_t v10 = -[BTVCBonjourBrowserResultChanges initWithOldResult:freshResult:change:]( objc_alloc(&OBJC_CLASS___BTVCBonjourBrowserResultChanges),  "initWithOldResult:freshResult:change:",  old_result,  v7,  changes);
      BOOL v11 = [WeakRetained resultChanges];
      [v11 addObject:v10];

      if (a4)
      {
        BOOL v12 = [WeakRetained resultChanges];
        id v13 = [v12 copy];

        __int16 v14 = (void *)[WeakRetained resultChanges];
        [v14 removeAllObjects];

        [WeakRetained handleBrowseResults:v13];
      }
    }
  }
}

void sub_1002030C4( _Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, id a10)
{
  id v15 = v13;

  _Unwind_Resume(a1);
}

_BYTE *sub_100203180(uint64_t a1)
{
  unsigned int v2 = [*(id *)(a1 + 32) browserState];
  id result = *(_BYTE **)(a1 + 32);
  if (v2 == 3)
  {
    result[24] = 1;
  }

  else
  {
    unsigned int v4 = [result browserState];
    id v5 = *(void **)(a1 + 32);
    if (v4 == 2) {
      return [v5 _reportCachedDiscoveryResults];
    }
    else {
      return [v5 _startBrowser];
    }
  }

  return result;
}

void sub_1002032E8(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

id sub_100203358(uint64_t a1)
{
  return [*(id *)(a1 + 32) _stopBrowser];
}

void sub_1002033F8(uint64_t a1)
{
  id WeakRetained = objc_loadWeakRetained((id *)(a1 + 32));
  if (WeakRetained)
  {
    id v4 = WeakRetained;
    BOOL v2 = [WeakRetained browserState] == 2;
    id WeakRetained = v4;
    if (v2)
    {
      unsigned int v3 = (void *)[v4 browserToAdvNwToSFendpoints];
      v5[0] = _NSConcreteStackBlock;
      v5[1] = 3221225472LL;
      v5[2] = sub_1002034AC;
      v5[3] = &unk_100887070;
      v5[4] = v4;
      [v3 enumerateKeysAndObjectsUsingBlock:v5];

      id WeakRetained = v4;
    }
  }
}

void sub_10020348C( _Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, id a9)
{
  _Unwind_Resume(a1);
}

void sub_1002034AC(uint64_t a1, uint64_t a2, void *a3)
{
  id v11 = a3;
  id v4 = [*(id *)(a1 + 32) deviceFoundHandler];

  if (v4)
  {
    id v5 = [*(id *)(a1 + 32) deviceFoundHandler];
    id v6 = objc_alloc(&OBJC_CLASS___NSUUID);
    int v7 = (void *)[v11 remoteUniqueIDString];
    uint64_t v8 = -[NSUUID initWithUUIDString:](v6, "initWithUUIDString:", v7);
    int v9 = (void *)[v11 remoteAdvDataSet];
    uint64_t v10 = (void *)[v9 allObjects];
    ((void (**)(void, NSUUID *, void *))v5)[2](v5, v8, v10);
  }
}

void sub_100203588( _Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, id a10)
{
  id v15 = v13;

  _Unwind_Resume(a1);
}

void sub_1002036AC(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_1002036C0(id a1, id a2, BTVCBonjourEndpoint *a3, BOOL *a4)
{
  id v4 = a3;
}

void sub_1002036FC( _Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, id a10)
{
}

void sub_1002037DC(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

BOOL sub_1002037F8(id a1, id a2, BTVCBonjourEndpoint *a3, BOOL *a4)
{
  return !-[BTVCBonjourEndpoint isConnected](a3, "isConnected");
}

void sub_100203B78(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_100203EE0( _Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, id *location)
{
  _Unwind_Resume(a1);
}

void sub_100203F80(uint64_t a1)
{
  id WeakRetained = objc_loadWeakRetained((id *)(a1 + 32));
  unsigned int v3 = (id *)objc_loadWeakRetained((id *)(a1 + 40));
  if (v3 && WeakRetained)
  {
    id v4 = [WeakRetained remoteUniqueIDString];

    if (v4)
    {
      id v5 = (os_log_s *)(id)qword_1008F7710;
      if (os_log_type_enabled(v5, OS_LOG_TYPE_ERROR)) {
        sub_10065E11C( (uint64_t)[WeakRetained isAdvToBrowserConnection],  (uint64_t)WeakRetained,  (uint64_t)&v10);
      }

      if (*(_BYTE *)(a1 + 48)) {
        id v6 = [v3 advToBrowserUuidToSFendpoints];
      }
      else {
        id v6 = (void *)objc_claimAutoreleasedReturnValue([v3 browserToAdvUuidToSFendpoints]);
      }
      int v7 = (void *)[WeakRetained remoteUniqueIDString];
      [v6 setObject:WeakRetained forKey:v7];

      if ([WeakRetained isAdvToBrowserConnection])
      {
        uint64_t v8 = (void *)[v3[20] allObjects];
        int v9 = (void *)[WeakRetained remoteUniqueIDString];
        [v3 _sendMessage:v8 withType:@"BTVCBonjourServiceMessageTypeStartAdvertiseData" toDevice:v9 completionCallback:&stru_1008870F8];
      }
    }

    else if (os_log_type_enabled((os_log_t)qword_1008F7710, OS_LOG_TYPE_ERROR))
    {
      sub_10065E0BC();
    }
  }
}

void sub_100204144(_Unwind_Exception *a1)
{
  id v5 = v3;

  _Unwind_Resume(a1);
}

void sub_1002041C4(uint64_t a1)
{
  id WeakRetained = objc_loadWeakRetained((id *)(a1 + 32));
  id v3 = objc_loadWeakRetained((id *)(a1 + 40));
  id v4 = v3;
  if (!WeakRetained || !v3) {
    goto LABEL_20;
  }
  id v5 = (os_log_s *)(id)qword_1008F7710;
  if (os_log_type_enabled(v5, OS_LOG_TYPE_ERROR)) {
    sub_10065E168((uint64_t)[v4 isAdvToBrowserConnection], (uint64_t)v4, (uint64_t)&v29);
  }

  id v6 = [v4 remoteUniqueIDString];
  BOOL v7 = v6 == 0LL;

  if (!v7)
  {
    uint64_t v8 = (void *)[WeakRetained deviceDidDisconnectHandler];
    if (v8)
    {
      unsigned int v9 = [v4 isConnected];

      if (v9)
      {
        uint64_t v10 = [WeakRetained deviceDidDisconnectHandler];
        id v11 = objc_alloc(&OBJC_CLASS___NSUUID);
        BOOL v12 = [v4 remoteUniqueIDString];
        id v13 = -[NSUUID initWithUUIDString:](v11, "initWithUUIDString:", v12);
        ((void (**)(void, NSUUID *))v10)[2](v10, v13);
LABEL_12:

        goto LABEL_13;
      }
    }

    __int16 v14 = [WeakRetained deviceLostHandler];
    if (v14)
    {
      unsigned __int8 v15 = [v4 isAdvToBrowserConnection];

      if ((v15 & 1) == 0)
      {
        uint64_t v10 = (void (**)(void, void))objc_claimAutoreleasedReturnValue([WeakRetained deviceLostHandler]);
        BOOL v16 = objc_alloc(&OBJC_CLASS___NSUUID);
        BOOL v12 = [v4 remoteUniqueIDString];
        id v13 = -[NSUUID initWithUUIDString:](v16, "initWithUUIDString:", v12);
        ((void (*)(void (**)(void, void), NSUUID *, void))v10[2])(v10, v13, 0LL);
        goto LABEL_12;
      }
    }
  }

void sub_1002044D0(_Unwind_Exception *a1)
{
  id v6 = v3;

  _Unwind_Resume(a1);
}

void sub_1002045C0(uint64_t a1, void *a2)
{
  id v3 = a2;
  id WeakRetained = objc_loadWeakRetained((id *)(a1 + 32));
  id v5 = objc_loadWeakRetained((id *)(a1 + 40));
  id v6 = v5;
  if (WeakRetained && v5)
  {
    uint64_t v51 = 0LL;
    BOOL v7 = [NSPropertyListSerialization propertyListWithData:v3 options:0LL format:&v51 error:0LL];
    if (v7)
    {
      uint64_t v8 = (void *)[v6 remoteUniqueIDString];
      BOOL v9 = v8 == 0LL;

      uint64_t v10 = (os_log_s *)qword_1008F7710;
      if (v9)
      {
        if (os_log_type_enabled((os_log_t)qword_1008F7710, OS_LOG_TYPE_ERROR)) {
          sub_10065E21C();
        }
      }

      else
      {
        if (os_log_type_enabled((os_log_t)qword_1008F7710, OS_LOG_TYPE_DEFAULT))
        {
          *(_DWORD *)__int128 buf = 138412546;
          uint64_t v53 = v7;
          __int16 v54 = 2112;
          uint64_t v55 = v6;
          _os_log_impl( (void *)&_mh_execute_header,  v10,  OS_LOG_TYPE_DEFAULT,  "[BTVCBonjourService] Received browser endpoint message %@ from endpoint %@",  buf,  0x16u);
        }

        id v11 = [v7 objectForKeyedSubscript:@"BTVCBonjourServiceMessageType"];
        if ([v11 isEqualToString:@"BTVCBonjourServiceMessageTypeStartAdvertiseData"])
        {
          BOOL v12 = [v6 remoteAdvDataSet];
          id v13 = [v7 objectForKeyedSubscript:@"BTVCBonjourServiceMessageValue"];
          [v12 addObjectsFromArray:v13];

          __int16 v14 = (void *)[WeakRetained deviceFoundHandler];
          BOOL v15 = v14 == 0LL;

          if (!v15)
          {
            BOOL v16 = [WeakRetained deviceFoundHandler];
            BOOL v17 = objc_alloc(&OBJC_CLASS___NSUUID);
            unint64_t v18 = (void *)[v6 remoteUniqueIDString];
            uint64_t v19 = -[NSUUID initWithUUIDString:](v17, "initWithUUIDString:", v18);
            BOOL v20 = (void *)[v7 objectForKeyedSubscript:@"BTVCBonjourServiceMessageValue"];
            ((void (**)(void, NSUUID *, void *))v16)[2](v16, v19, v20);
          }
        }

        else if ([v11 isEqualToString:@"BTVCBonjourServiceMessageTypeStopAdvertiseData"])
        {
          int v21 = (void *)[v6 remoteAdvDataSet];
          id v22 = [v7 objectForKeyedSubscript:@"BTVCBonjourServiceMessageValue"];
          unsigned int v23 = (void *)objc_claimAutoreleasedReturnValue(+[NSSet setWithArray:](&OBJC_CLASS___NSSet, "setWithArray:", v22));
          [v21 minusSet:v23];

          uint64_t v24 = (void *)[WeakRetained deviceLostHandler];
          BOOL v25 = v24 == 0LL;

          if (!v25)
          {
            BOOL v26 = [WeakRetained deviceLostHandler];
            char v27 = objc_alloc(&OBJC_CLASS___NSUUID);
            int v28 = (void *)[v6 remoteUniqueIDString];
            uint64_t v29 = -[NSUUID initWithUUIDString:](v27, "initWithUUIDString:", v28);
            unint64_t v30 = (void *)[v7 objectForKeyedSubscript:@"BTVCBonjourServiceMessageValue"];
            ((void (**)(void, NSUUID *, void *))v26)[2](v26, v29, v30);
          }
        }

        else if ([v11 isEqualToString:@"BTVCBonjourServiceMessageTypeConnect"])
        {
          [v6 setIsConnected:1];
          __int16 v31 = (void *)[WeakRetained deviceDidConnectHandler];
          BOOL v32 = v31 == 0LL;

          if (!v32)
          {
            __int16 v33 = [WeakRetained deviceDidConnectHandler];
            uint64_t v34 = objc_alloc(&OBJC_CLASS___NSUUID);
            uint64_t v35 = (void *)[v6 remoteUniqueIDString];
            uint8_t v36 = -[NSUUID initWithUUIDString:](v34, "initWithUUIDString:", v35);
            ((void (**)(void, NSUUID *, void))v33)[2](v33, v36, 0LL);
          }
        }

        else if ([v11 isEqualToString:@"BTVCBonjourServiceMessageTypeDisconnect"])
        {
          [v6 setIsConnected:0];
          uint64_t v37 = (void *)[WeakRetained deviceDidDisconnectHandler];
          BOOL v38 = v37 == 0LL;

          if (!v38)
          {
            int v39 = (void (**)(void, void))objc_claimAutoreleasedReturnValue([WeakRetained deviceDidDisconnectHandler]);
            uint64_t v40 = objc_alloc(&OBJC_CLASS___NSUUID);
            uint64_t v41 = (void *)[v6 remoteUniqueIDString];
            uint64_t v42 = -[NSUUID initWithUUIDString:](v40, "initWithUUIDString:", v41);
            ((void (**)(void, NSUUID *))v39)[2](v39, v42);
          }
        }

        else if ([v11 isEqualToString:@"BTVCBonjourServiceMessageTypeDataPacket"])
        {
          uint64_t v43 = (void *)[WeakRetained deviceDidReceiveDataHandler];
          BOOL v44 = v43 == 0LL;

          if (!v44)
          {
            uint64_t v45 = (void *)[v7 objectForKeyedSubscript:@"BTVCBonjourServiceMessageValue"];
            uint64_t v46 = (void (**)(void, void, void))objc_claimAutoreleasedReturnValue( [WeakRetained deviceDidReceiveDataHandler]);
            uint64_t v47 = objc_alloc(&OBJC_CLASS___NSUUID);
            double v48 = [v6 remoteUniqueIDString];
            uint64_t v49 = -[NSUUID initWithUUIDString:](v47, "initWithUUIDString:", v48);
            ((void (**)(void, NSUUID *, void *))v46)[2](v46, v49, v45);
          }
        }

        else
        {
          uint64_t v50 = (os_log_s *)qword_1008F7710;
          if (os_log_type_enabled((os_log_t)qword_1008F7710, OS_LOG_TYPE_DEFAULT))
          {
            *(_DWORD *)__int128 buf = 138412290;
            uint64_t v53 = v11;
            _os_log_impl( (void *)&_mh_execute_header,  v50,  OS_LOG_TYPE_DEFAULT,  "[BTVCBonjourService] BTVCBonjourService unknown message type:%@",  buf,  0xCu);
          }
        }
      }
    }

    else if (os_log_type_enabled((os_log_t)qword_1008F7710, OS_LOG_TYPE_ERROR))
    {
      sub_10065E1B4();
    }
  }
}

void sub_100204BA0(_Unwind_Exception *a1)
{
  uint64_t v10 = v6;

  _Unwind_Resume(a1);
}

void sub_100204F50(_Unwind_Exception *a1)
{
  uint64_t v8 = v7;

  _Unwind_Resume(a1);
}

void sub_100204FBC(uint64_t a1, void *a2)
{
  id v4 = a2;
  uint64_t v3 = *(void *)(a1 + 32);
  if (v3) {
    (*(void (**)(uint64_t, id))(v3 + 16))(v3, v4);
  }
}

void sub_100205000( _Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, id a10)
{
}

void sub_10020513C(uint64_t a1)
{
  id WeakRetained = objc_loadWeakRetained((id *)(a1 + 64));
  uint64_t v3 = WeakRetained;
  if (WeakRetained)
  {
    id v4 = [WeakRetained _endpointForUniqueID:*(void *)(a1 + 32)];
    if (v4 && *(void *)(a1 + 40) && *(void *)(a1 + 48))
    {
      objc_msgSend(v3, "_sendMessage:withType:toEndpoint:completionCallback:");
    }

    else
    {
      if (os_log_type_enabled((os_log_t)qword_1008F7710, OS_LOG_TYPE_ERROR)) {
        sub_10065E2E4();
      }
      if (*(void *)(a1 + 56))
      {
        NSErrorUserInfoKey v7 = NSLocalizedDescriptionKey;
        uint64_t v8 = @"Unable to send message, invalid params";
        id v5 = [NSDictionary dictionaryWithObjects:forKeys:count:&v8, &v7, 1LL];
        id v6 = [NSError errorWithDomain:NSOSStatusErrorDomain code:-6705LL userInfo:v5];

        (*(void (**)(void))(*(void *)(a1 + 56) + 16LL))();
      }
    }
  }
}

void sub_1002052A4(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_100205400( _Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, void *a16, void *a17, void *a18)
{
  _Unwind_Resume(a1);
}

void sub_10020545C(uint64_t a1, void *a2)
{
  id v3 = a2;
  id v4 = *(void **)(a1 + 32);
  uint64_t v10 = *(void *)(a1 + 40);
  id v5 = [NSArray arrayWithObjects:count:1LL];
  v7[0] = _NSConcreteStackBlock;
  v7[1] = 3221225472LL;
  _DWORD v7[2] = sub_100205590;
  v7[3] = &unk_1008871E8;
  uint64_t v6 = *(void *)(a1 + 48);
  id v9 = *(id *)(a1 + 56);
  id v8 = *(id *)(a1 + 40);
  [v4 _sendMessage:v5 withType:v6 toDevice:v3 completionCallback:v7];
}

void sub_10020555C( _Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, void *a13, void *a14)
{
  _Unwind_Resume(a1);
}

void sub_100205590(uint64_t a1, void *a2)
{
  id v4 = a2;
  if (v4)
  {
    uint64_t v3 = *(void *)(a1 + 40);
    if (v3) {
      (*(void (**)(uint64_t, void, id))(v3 + 16))(v3, *(void *)(a1 + 32), v4);
    }
  }
}

void sub_1002055DC( _Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, id a10)
{
}

void sub_10020569C( _Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, void *a14)
{
  _Unwind_Resume(a1);
}

void sub_1002056C0(uint64_t a1, void *a2)
{
  id v8 = a2;
  uint64_t v3 = *(void **)(a1 + 32);
  id v4 = [*(id *)(a1 + 40) UUIDString];
  id v5 = (void *)[v3 _endpointForUniqueID:v4];

  if (!v8) {
    [v5 setIsConnected:1];
  }
  uint64_t v6 = (void *)[*(id *)(a1 + 32) deviceDidConnectHandler];

  if (v6)
  {
    NSErrorUserInfoKey v7 = [*(id *)(a1 + 32) deviceDidConnectHandler];
    ((void (**)(void, void, id))v7)[2](v7, *(void *)(a1 + 40), v8);
  }
}

void sub_100205774( _Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, id a10)
{
  _Unwind_Resume(a1);
}

void sub_100205858( _Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, void *a14)
{
  _Unwind_Resume(a1);
}

void sub_10020587C(uint64_t a1)
{
  BOOL v2 = *(void **)(a1 + 32);
  uint64_t v3 = (void *)[*(id *)(a1 + 40) UUIDString];
  id v9 = [v2 _endpointForUniqueID:v3];

  [v9 setIsConnected:0];
  id v4 = [*(id *)(a1 + 32) deviceDidDisconnectHandler];

  if (v4)
  {
    id v5 = [*(id *)(a1 + 32) deviceDidDisconnectHandler];
    v5[2](v5, *(void *)(a1 + 40));
  }

  uint64_t v6 = (void *)[*(id *)(a1 + 32) deviceLostHandler];
  if (v6)
  {
    unsigned __int8 v7 = [v9 isAdvToBrowserConnection];

    if ((v7 & 1) == 0)
    {
      id v8 = [*(id *)(a1 + 32) deviceLostHandler];
      v8[2](v8, *(void *)(a1 + 40), 0LL);
    }
  }
}

void sub_100205964( _Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, id a10)
{
  _Unwind_Resume(a1);
}

void sub_100205A9C( _Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, void *a14, void *a15, void *a16)
{
  _Unwind_Resume(a1);
}

void sub_100205AD8(uint64_t a1, void *a2)
{
  id v3 = a2;
  if (v3 && os_log_type_enabled((os_log_t)qword_1008F7710, OS_LOG_TYPE_ERROR)) {
    sub_10065E354();
  }
  uint64_t v4 = *(void *)(a1 + 48);
  if (v4) {
    (*(void (**)(uint64_t, id))(v4 + 16))(v4, v3);
  }
}

void sub_100205B50(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_100205BDC(_Unwind_Exception *a1)
{
  uint64_t v4 = v3;

  _Unwind_Resume(a1);
}

void sub_100205CE8(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

id sub_100205D64(uint64_t a1)
{
  return [*(id *)(a1 + 32) _stopAdvertising];
}

void sub_10020603C(void *a1, os_log_s *a2, uint64_t a3, const char *a4, uint8_t *a5)
{
}

uint64_t sub_100206048(uint64_t result, uint64_t a2, uint64_t a3, float a4)
{
  if ((result & 1) != 0) {
    uint64_t v4 = v5;
  }
  *(float *)a3 = a4;
  *(void *)(a3 + 4) = v4;
  *(_WORD *)(a3 + 12) = 2112;
  *(void *)(a3 + 14) = a2;
  return result;
}

  ;
}

void sub_100206084(void *a1, uint64_t a2, os_log_t log, const char *a4, ...)
{
}

  ;
}

uint64_t sub_1002060B0(uint64_t a1)
{
  BOOL v2 = (uint64_t *)(sub_100242DC4(a1) + 64);
  sub_10053C3D8(v2);
  *(_DWORD *)(a1 + 96) = 0;
  sub_10002418C((void *)(a1 + 104), "");
  *(void *)(a1 + 12std::iostream::~basic_iostream(v2, v3 + 8) = 0LL;
  sub_10053C3D8((void *)(a1 + 152));
  sub_10054A050(a1 + 192);
  *(void *)(a1 + 24std::iostream::~basic_iostream(v2, v3 + 8) = 0LL;
  *(void *)(a1 + 256) = 0LL;
  *(void *)(a1 + 264) = 0LL;
  *(_BYTE *)(a1 + 275) = 0;
  sub_10053C3D8((void *)(a1 + 280));
  *(_DWORD *)(a1 + 304) = 0;
  *(_BYTE *)(a1 + 30std::iostream::~basic_iostream(v2, v3 + 8) = 0;
  sub_100242DC4(a1 + 320);
  *(void *)(a1 + 384) = 0LL;
  sub_10053C4B4(v2);
  *(_WORD *)(a1 + 8std::iostream::~basic_iostream(v2, v3 + 8) = 0;
  *(_BYTE *)(a1 + 90) = 0;
  std::string::assign((std::string *)(a1 + 104), "");
  *(_DWORD *)(a1 + 96) = 0;
  *(_WORD *)(a1 + 136) = 0;
  *(_BYTE *)(a1 + 13std::iostream::~basic_iostream(v2, v3 + 8) = 0;
  *(_DWORD *)(a1 + 140) = 0;
  *(_DWORD *)(a1 + 144) = 0;
  sub_10053C4B4((uint64_t *)(a1 + 152));
  *(_WORD *)(a1 + 176) = 0;
  *(_DWORD *)(a1 + 180) = 0;
  *(_DWORD *)(a1 + 184) = 0;
  sub_10054A738(a1 + 192);
  if (*(char *)(a1 + 271) < 0)
  {
    **(_BYTE **)(a1 + 24std::iostream::~basic_iostream(v2, v3 + 8) = 0;
    *(void *)(a1 + 256) = 0LL;
  }

  else
  {
    *(_BYTE *)(a1 + 24std::iostream::~basic_iostream(v2, v3 + 8) = 0;
    *(_BYTE *)(a1 + 271) = 0;
  }

  *(void *)(a1 + 312) = 0LL;
  *(_DWORD *)(a1 + 272) = 0;
  sub_10053C4B4((uint64_t *)(a1 + 280));
  return a1;
}

void sub_1002061E8(_Unwind_Exception *a1, uint64_t a2, ...)
{
  sub_1002077E0((void ***)va);
  sub_100242E28(v2);
  _Unwind_Resume(a1);
}

uint64_t sub_100206294(uint64_t a1)
{
  sub_100242E28(a1 + 320);
  id v3 = (void **)(a1 + 280);
  sub_1002077E0(&v3);
  sub_10054A428(a1 + 192);
  id v3 = (void **)(a1 + 152);
  sub_1002077E0(&v3);

  id v3 = (void **)(a1 + 64);
  sub_1002077E0(&v3);
  return sub_100242E28(a1);
}

void sub_100206334( _Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, void **a10)
{
  sub_100242E28(v10 + 320);
  a10 = (void **)(v10 + 280);
  sub_1002077E0(&a10);
  sub_10065E44C(v10);
  a10 = (void **)(v10 + 64);
  sub_1002077E0(&a10);
  sub_100242E28(v10);
  _Unwind_Resume(a1);
}

uint64_t sub_100206390(uint64_t a1)
{
  uint64_t v2 = *(void **)(a1 + 312);
  if (v2)
  {
    id v3 = (os_log_s *)qword_1008F7598;
    if (!os_log_type_enabled((os_log_t)qword_1008F7598, OS_LOG_TYPE_INFO)
      || (*(_WORD *)__int128 buf = 0,
          _os_log_impl((void *)&_mh_execute_header, v3, OS_LOG_TYPE_INFO, "Deleting pending sco route change", buf, 2u),
          (uint64_t v2 = *(void **)(a1 + 312)) != 0LL))
    {
      operator delete(v2);
    }

    *(void *)(a1 + 312) = 0LL;
  }

  *(void *)__int128 buf = 0LL;
  uint64_t v10 = 0LL;
  sub_100242F28((uint64_t)buf, a1 + 320);
  uint64_t v4 = *(void **)(a1 + 384);
  if (v4)
  {
    uint64_t v5 = (os_log_s *)qword_1008F7598;
    if (os_log_type_enabled((os_log_t)qword_1008F7598, OS_LOG_TYPE_DEFAULT))
    {
      *(_WORD *)id v8 = 0;
      _os_log_impl( (void *)&_mh_execute_header,  v5,  OS_LOG_TYPE_DEFAULT,  "Canceling pending Disconnection timeout dispatch",  v8,  2u);
      uint64_t v4 = *(void **)(a1 + 384);
    }

    dispatch_block_cancel(v4);
    uint64_t v6 = *(void **)(a1 + 384);
    *(void *)(a1 + 384) = 0LL;
  }

  return sub_100242FAC((uint64_t)buf);
}

void *sub_100206494@<X0>(int *a1@<X0>, void *a2@<X8>)
{
  uint64_t v4 = *a1;
  else {
    uint64_t v5 = off_1008872A0[v4];
  }
  return sub_10002418C(a2, v5);
}

void *sub_1002064C4@<X0>(int *a1@<X0>, void *a2@<X8>)
{
  uint64_t v4 = *a1;
  else {
    uint64_t v5 = off_1008872B8[v4];
  }
  return sub_10002418C(a2, v5);
}

const char *sub_1002064F4(int *a1)
{
  uint64_t v1 = *a1;
  else {
    return off_1008872D8[v1];
  }
}

uint64_t sub_10020651C(uint64_t result, __int16 a2)
{
  *(_WORD *)(result + 8std::iostream::~basic_iostream(v2, v3 + 8) = a2;
  return result;
}

uint64_t sub_100206524(uint64_t a1)
{
  return *(unsigned __int16 *)(a1 + 88);
}

uint64_t sub_10020652C(uint64_t result, char a2)
{
  *(_BYTE *)(result + 90) = a2;
  return result;
}

uint64_t sub_100206534(uint64_t a1)
{
  return *(unsigned __int8 *)(a1 + 90);
}

char *sub_10020653C@<X0>(char *result@<X0>, uint64_t a2@<X8>)
{
  if (result[127] < 0) {
    return (char *)sub_100024238((_BYTE *)a2, *((void **)result + 13), *((void *)result + 14));
  }
  *(_OWORD *)a2 = *(_OWORD *)(result + 104);
  *(void *)(a2 + 16) = *((void *)result + 15);
  return result;
}

uint64_t sub_100206568(uint64_t a1)
{
  return *(unsigned int *)(a1 + 96);
}

std::string *sub_100206570(uint64_t a1, uint64_t a2)
{
  id result = std::string::operator=((std::string *)(a1 + 104), (const std::string *)(a2 + 8));
  *(_DWORD *)(a1 + 96) = *(_DWORD *)a2;
  return result;
}

id sub_1002065A4(uint64_t a1)
{
  return [*(id *)(a1 + 128) service];
}

id sub_1002065AC(uint64_t a1)
{
  return [*(id *)(a1 + 128) roaming];
}

void sub_1002065B4(uint64_t a1, void *a2)
{
}

BOOL sub_1002065BC(uint64_t a1)
{
  return sub_10053C918((void *)(a1 + 64));
}

BOOL sub_1002065C4(uint64_t a1)
{
  return sub_10053C8E4((void *)(a1 + 64));
}

BOOL sub_1002065CC(uint64_t a1)
{
  return sub_10053C980((void *)(a1 + 64));
}

BOOL sub_1002065D4(uint64_t a1)
{
  return sub_10053C94C((void *)(a1 + 64));
}

uint64_t sub_1002065DC(uint64_t a1)
{
  return sub_10053C878((uint64_t *)(a1 + 64));
}

uint64_t sub_1002065E4(uint64_t a1)
{
  return sub_10053C8AC((uint64_t *)(a1 + 64));
}

uint64_t sub_1002065EC(uint64_t a1)
{
  return sub_10053C844((uint64_t *)(a1 + 64));
}

uint64_t sub_1002065F4(uint64_t a1)
{
  return *(unsigned __int8 *)(a1 + 138);
}

uint64_t sub_1002065FC(uint64_t result, char a2)
{
  *(_BYTE *)(result + 13std::iostream::~basic_iostream(v2, v3 + 8) = a2;
  return result;
}

uint64_t sub_100206604@<X0>(int a1@<W8>)
{
  return sub_10053C460(a1);
}

void sub_100206610(uint64_t a1, uint64_t *a2)
{
  uint64_t v2 = a1 + 152;
}

uint64_t sub_100206648(uint64_t a1)
{
  return *(unsigned __int8 *)(a1 + 176);
}

uint64_t sub_100206650(uint64_t result, char a2)
{
  *(_BYTE *)(result + 176) = a2;
  return result;
}

uint64_t sub_100206658(uint64_t a1)
{
  return *(unsigned __int8 *)(a1 + 273);
}

uint64_t sub_100206660(uint64_t result, char a2)
{
  *(_BYTE *)(result + 273) = a2;
  return result;
}

uint64_t sub_100206668(uint64_t result, char a2)
{
  *(_BYTE *)(result + 274) = a2;
  return result;
}

uint64_t sub_100206670(uint64_t a1)
{
  return *(unsigned __int8 *)(a1 + 274);
}

std::string *sub_100206678(uint64_t a1)
{
  *(_DWORD *)(a1 + 180) = 0;
  id result = sub_10054A738(a1 + 192);
  if (*(char *)(a1 + 271) < 0)
  {
    **(_BYTE **)(a1 + 24std::iostream::~basic_iostream(v2, v3 + 8) = 0;
    *(void *)(a1 + 256) = 0LL;
  }

  else
  {
    *(_BYTE *)(a1 + 24std::iostream::~basic_iostream(v2, v3 + 8) = 0;
    *(_BYTE *)(a1 + 271) = 0;
  }

  *(_DWORD *)(a1 + 184) = 0;
  return result;
}

std::string *sub_1002066C4(uint64_t a1, uint64_t a2, const std::string *a3, int a4)
{
  id result = std::string::operator=((std::string *)(a1 + 248), a3);
  *(_DWORD *)(a1 + 180) = a4;
  return result;
}

BOOL sub_100206708(uint64_t a1, int a2)
{
  return *(_DWORD *)(a1 + 180) == a2;
}

uint64_t sub_100206718(uint64_t result)
{
  return result;
}

uint64_t sub_100206728(uint64_t result, int a2)
{
  *(_DWORD *)(result + ++*(_DWORD *)(result + 184) = a2;
  return result;
}

uint64_t sub_100206730(uint64_t a1)
{
  return *(unsigned int *)(a1 + 184);
}

std::string *sub_100206738@<X0>(uint64_t a1@<X0>, std::string *a2@<X8>)
{
  return sub_10054A580(a1 + 192, a2);
}

char *sub_100206740@<X0>(char *result@<X0>, uint64_t a2@<X8>)
{
  if (result[271] < 0) {
    return (char *)sub_100024238((_BYTE *)a2, *((void **)result + 31), *((void *)result + 32));
  }
  *(_OWORD *)a2 = *(_OWORD *)(result + 248);
  *(void *)(a2 + 16) = *((void *)result + 33);
  return result;
}

uint64_t sub_10020676C(uint64_t a1)
{
  return *(unsigned __int8 *)(a1 + 216);
}

uint64_t sub_100206774(uint64_t result, int a2)
{
  *(_DWORD *)(result + 144) = a2;
  return result;
}

uint64_t sub_10020677C(uint64_t a1, int a2)
{
  v5[0] = 0LL;
  v5[1] = 0LL;
  sub_100242F28((uint64_t)v5, a1);
  *(_DWORD *)(a1 + 140) = a2;
  return sub_100242FAC((uint64_t)v5);
}

uint64_t sub_1002067C0(uint64_t a1)
{
  v4[0] = 0LL;
  v4[1] = 0LL;
  sub_100242F28((uint64_t)v4, a1);
  uint64_t v2 = *(unsigned int *)(a1 + 140);
  sub_100242FAC((uint64_t)v4);
  return v2;
}

BOOL sub_100206804(uint64_t a1, int a2)
{
  return *(_DWORD *)(a1 + 140) == a2;
}

uint64_t sub_100206814(uint64_t result, char a2)
{
  *(_BYTE *)(result + 136) = a2;
  return result;
}

uint64_t sub_10020681C(uint64_t a1)
{
  return *(unsigned __int8 *)(a1 + 136);
}

uint64_t sub_100206824(uint64_t result, char a2)
{
  *(_BYTE *)(result + 13memset((char *)&v11[1] + 1, 0, 7) = a2;
  return result;
}

uint64_t sub_10020682C(uint64_t a1)
{
  return *(unsigned __int8 *)(a1 + 137);
}

uint64_t sub_100206834(uint64_t a1)
{
  return *(unsigned __int8 *)(a1 + 272);
}

uint64_t sub_10020683C(uint64_t result, char a2)
{
  *(_BYTE *)(result + 272) = a2;
  return result;
}

uint64_t sub_100206844(uint64_t result, char a2)
{
  *(_BYTE *)(result + 17memset((char *)&v11[1] + 1, 0, 7) = a2;
  return result;
}

uint64_t sub_10020684C(uint64_t a1)
{
  return *(unsigned __int8 *)(a1 + 177);
}

uint64_t sub_100206854@<X0>(uint64_t a1@<X0>, int a2@<W8>)
{
  v4[0] = 0LL;
  v4[1] = 0LL;
  sub_100242F28((uint64_t)v4, a1);
  sub_10053C460(a2);
  return sub_100242FAC((uint64_t)v4);
}

void sub_1002068A0( _Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9)
{
}

uint64_t sub_1002068B4(uint64_t a1, uint64_t *a2)
{
  v5[0] = 0LL;
  v5[1] = 0LL;
  sub_100242F28((uint64_t)v5, a1);
  return sub_100242FAC((uint64_t)v5);
}

void sub_100206924( _Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9)
{
}

unint64_t sub_100206938(uint64_t a1, uint64_t *a2)
{
  v9[0] = 0LL;
  v9[1] = 0LL;
  sub_100242F28((uint64_t)v9, a1);
  uint64_t v4 = a1 + 64;
  unint64_t v5 = sub_10053C7A4((uint64_t *)(a1 + 64), a2);
  unint64_t v6 = v5;
  else {
    char v7 = v5;
  }
  if ((v7 & 1) == 0) {
    sub_10020789C(v4, *a2, a2[1], 0x4EC4EC4EC4EC4EC5LL * ((a2[1] - *a2) >> 3));
  }
  sub_100242FAC((uint64_t)v9);
  return v6;
}

void sub_1002069CC( _Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9)
{
}

uint64_t sub_1002069E0(uint64_t a1)
{
  return *(unsigned __int16 *)(a1 + 12);
}

void sub_1002069E8(uint64_t a1, int a2, int a3, int a4, unsigned int a5)
{
  uint64_t v10 = (os_log_s *)qword_1008F7598;
  if (os_log_type_enabled((os_log_t)qword_1008F7598, OS_LOG_TYPE_INFO))
  {
    *(_WORD *)__int128 buf = 0;
    _os_log_impl((void *)&_mh_execute_header, v10, OS_LOG_TYPE_INFO, "Set pending sco route change", buf, 2u);
  }

  sub_100206390(a1);
  id v11 = operator new(0x10uLL);
  *id v11 = a2;
  v11[1] = a3;
  v11[2] = a4;
  *((_WORD *)v11 + 6) = a5;
  *(void *)(a1 + 312) = v11;
  if (qword_1008D9030 != -1) {
    dispatch_once(&qword_1008D9030, &stru_100887280);
  }
  v15[0] = _NSConcreteStackBlock;
  v15[1] = 3221225472LL;
  v15[2] = sub_100206B20;
  v15[3] = &unk_10087F8E0;
  v15[4] = a1;
  v15[5] = sub_1004615C4((uint64_t)off_1008D9028, a5);
  dispatch_block_t v12 = dispatch_block_create(DISPATCH_BLOCK_ENFORCE_QOS_CLASS, v15);
  id v13 = *(void **)(a1 + 384);
  *(void *)(a1 + 384) = v12;

  uint64_t v14 = sub_100405058();
  sub_100405460(v14, 3000LL, *(void **)(a1 + 384));
}

uint64_t sub_100206B20(uint64_t result)
{
  if (*(void *)(result + 40))
  {
    uint64_t v1 = *(void *)(result + 32);
    id result = sub_100206B80(v1);
    if (result)
    {
      uint64_t v2 = (os_log_s *)qword_1008F7598;
      if (os_log_type_enabled((os_log_t)qword_1008F7598, OS_LOG_TYPE_ERROR)) {
        sub_10065E4A0(v2);
      }
      return sub_100206390(v1);
    }
  }

  return result;
}

uint64_t sub_100206B80(uint64_t a1)
{
  uint64_t v2 = (os_log_s *)qword_1008F7598;
  if (os_log_type_enabled((os_log_t)qword_1008F7598, OS_LOG_TYPE_INFO))
  {
    if (*(void *)(a1 + 312)) {
      id v3 = "true";
    }
    else {
      id v3 = "false";
    }
    int v5 = 136446210;
    unint64_t v6 = v3;
    _os_log_impl( (void *)&_mh_execute_header,  v2,  OS_LOG_TYPE_INFO,  "Getting pending sco route change %{public}s",  (uint8_t *)&v5,  0xCu);
  }

  return *(void *)(a1 + 312);
}

void sub_100206C40(uint64_t a1)
{
  if (sub_100206B80(a1))
  {
    uint64_t v2 = *(unsigned int **)(a1 + 312);
    uint64_t v3 = *v2;
    uint64_t v4 = v2[1];
    uint64_t v5 = v2[2];
    unsigned int v6 = *((unsigned __int16 *)v2 + 6);
    if (qword_1008D9030 != -1) {
      dispatch_once(&qword_1008D9030, &stru_100887280);
    }
    uint64_t v7 = sub_1004615C4((uint64_t)off_1008D9028, v6);
    if (qword_1008D9030 != -1) {
      dispatch_once(&qword_1008D9030, &stru_100887280);
    }
    id v8 = sub_10045CF60((uint64_t)off_1008D9028, v6);
    if (v7) {
      BOOL v9 = v8 == 0LL;
    }
    else {
      BOOL v9 = 1;
    }
    if (v9)
    {
      uint64_t v10 = (os_log_s *)qword_1008F7598;
      if (os_log_type_enabled((os_log_t)qword_1008F7598, OS_LOG_TYPE_DEFAULT))
      {
        LOWORD(__p[0]) = 0;
        _os_log_impl( (void *)&_mh_execute_header,  v10,  OS_LOG_TYPE_DEFAULT,  "Audio device has already disconnected, cannot retry route change",  (uint8_t *)__p,  2u);
      }
    }

    else
    {
      id v11 = v8;
      sub_100206390(a1);
      dispatch_block_t v12 = (os_log_s *)qword_1008F7598;
      if (os_log_type_enabled((os_log_t)qword_1008F7598, OS_LOG_TYPE_DEFAULT))
      {
        sub_1003D0100(v7, (uint64_t)__p);
        uint64_t v14 = v16 >= 0 ? __p : (void **)__p[0];
        *(_DWORD *)__int128 buf = 141558275;
        uint64_t v18 = 1752392040LL;
        __int16 v19 = 2081;
        BOOL v20 = v14;
        _os_log_impl( (void *)&_mh_execute_header,  v12,  OS_LOG_TYPE_DEFAULT,  "Retrying sco route change to device %{private, mask.hash}s",  buf,  0x16u);
        if (v16 < 0) {
          operator delete(__p[0]);
        }
      }

      if (qword_1008D9030 != -1) {
        dispatch_once(&qword_1008D9030, &stru_100887280);
      }
      (*(void (**)(void *, uint64_t *, uint64_t, uint64_t, uint64_t))(*(void *)off_1008D9028 + 136LL))( off_1008D9028,  v11,  v3,  v4,  v5);
    }
  }

uint64_t sub_100206E6C(uint64_t a1, char a2)
{
  v5[0] = 0LL;
  v5[1] = 0LL;
  sub_100242F28((uint64_t)v5, a1);
  *(_BYTE *)(a1 + 275) = a2;
  return sub_100242FAC((uint64_t)v5);
}

uint64_t sub_100206EB0(uint64_t a1)
{
  v4[0] = 0LL;
  v4[1] = 0LL;
  sub_100242F28((uint64_t)v4, a1);
  uint64_t v2 = *(unsigned __int8 *)(a1 + 275);
  sub_100242FAC((uint64_t)v4);
  return v2;
}

uint64_t sub_100206EF4@<X0>(uint64_t a1@<X0>, int a2@<W8>)
{
  v4[0] = 0LL;
  v4[1] = 0LL;
  sub_100242F28((uint64_t)v4, a1);
  sub_10053C460(a2);
  return sub_100242FAC((uint64_t)v4);
}

void sub_100206F40( _Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9)
{
}

uint64_t sub_100206F54(uint64_t a1, uint64_t *a2)
{
  v5[0] = 0LL;
  v5[1] = 0LL;
  sub_100242F28((uint64_t)v5, a1);
  return sub_100242FAC((uint64_t)v5);
}

void sub_100206FC4( _Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9)
{
}

uint64_t sub_100206FD8(uint64_t a1)
{
  return *(unsigned int *)(a1 + 304);
}

uint64_t sub_100206FE0(uint64_t result, int a2)
{
  *(_DWORD *)(result + 304) = a2;
  return result;
}

uint64_t sub_100206FE8(uint64_t a1)
{
  return *(unsigned __int8 *)(a1 + 308);
}

uint64_t sub_100206FF0(uint64_t result, char a2)
{
  *(_BYTE *)(result + 30std::iostream::~basic_iostream(v2, v3 + 8) = a2;
  return result;
}

double sub_100206FF8(uint64_t a1, uint64_t a2, __int16 a3, int *a4)
{
  *(_DWORD *)a1 = 0;
  *(void *)(a1 + std::iostream::~basic_iostream(v2, v3 + 8) = 0LL;
  *(void *)(a1 + 152) = 0LL;
  *(void *)(a1 + 160) = 0LL;
  *(void *)(a1 + 32) = a2;
  *(_WORD *)(a1 + 40) = a3;
  *(_WORD *)(a1 + 70) = 0;
  *(void *)(a1 + 56) = 0LL;
  *(_DWORD *)(a1 + 64) = 0;
  *(_BYTE *)(a1 + 72) = 1;
  *(_BYTE *)(a1 + 6std::iostream::~basic_iostream(v2, v3 + 8) = 0;
  *(void *)(a1 + 73) = 0LL;
  *(_BYTE *)(a1 + 81) = 0;
  *(_DWORD *)(a1 + 8std::iostream::~basic_iostream(v2, v3 + 8) = 1;
  *(_BYTE *)(a1 + 92) = 0;
  *(void *)&double result = 0x100000040LL;
  *(_OWORD *)(a1 + 10std::iostream::~basic_iostream(v2, v3 + 8) = xmmword_1006BF3E0;
  *(_DWORD *)(a1 + 12std::iostream::~basic_iostream(v2, v3 + 8) = 0;
  *(_BYTE *)(a1 + 132) = 0;
  int v5 = *a4;
  *(_WORD *)(a1 + 46) = *((_WORD *)a4 + 2);
  *(_DWORD *)(a1 + 42) = v5;
  *(_WORD *)(a1 + 82) = 0;
  *(_BYTE *)(a1 + 84) = 0;
  *(_BYTE *)(a1 + 69) = 0;
  *(void *)(a1 + 4std::iostream::~basic_iostream(v2, v3 + 8) = 0LL;
  *(_DWORD *)(a1 + 144) = 0;
  *(_WORD *)(a1 + 16std::iostream::~basic_iostream(v2, v3 + 8) = 0;
  *(_BYTE *)(a1 + 170) = 0;
  *(_BYTE *)(a1 + 140) = 0;
  *(_DWORD *)(a1 + 100) = 0;
  *(_BYTE *)(a1 + 104) = 0;
  return result;
}

uint64_t sub_100207088(uint64_t a1)
{
  return a1;
}

uint64_t sub_1002070AC(uint64_t a1)
{
  uint64_t v13 = 0LL;
  __int128 v12 = 0u;
  memset(v11, 0, sizeof(v11));
  __int128 v9 = 0u;
  *(_OWORD *)std::stringbuf::string_type __p = 0u;
  __int128 v7 = 0u;
  *(_OWORD *)id v8 = 0u;
  __int128 v5 = 0u;
  *(_OWORD *)unsigned int v6 = 0u;
  sub_100532DC0((uint64_t)&v5 + 1);
  BYTE2(v6[0]) = 0;
  BYTE4(v6[0]) = 0;
  BYTE2(v8[0]) = 0;
  BYTE4(v8[0]) = 0;
  DWORD1(v11[1]) = 0;
  __int128 v7 = 0uLL;
  v6[1] = 0LL;
  LOBYTE(v8[0]) = 0;
  __int128 v9 = 0uLL;
  v8[1] = 0LL;
  LOBYTE(__p[0]) = 0;
  memset(v11, 0, 19);
  __p[1] = 0LL;
  BYTE8(v11[1]) = 1;
  BYTE2(v13) = 0;
  *(void *)((char *)&v11[1] + 14) = 0LL;
  *(void *)((char *)&v11[1] + 9) = 0LL;
  __int128 v12 = 0uLL;
  *((void *)&v11[2] + 1) = 0LL;
  LOBYTE(v13) = 0;
  LODWORD(a1) = sub_1003D2408(*(void *)(a1 + 32), (uint64_t)&v5);
  int v3 = BYTE2(v11[1]);
  if (SHIBYTE(v11[0]) < 0) {
    operator delete(__p[1]);
  }
  if (SHIBYTE(v9) < 0) {
    operator delete(v8[1]);
  }
  if (SHIBYTE(v7) < 0) {
    operator delete(v6[1]);
  }
  if (v3) {
    a1 = a1;
  }
  else {
    a1 = 0LL;
  }
  nullsub_63((char *)&v5 + 1, v1);
  return a1;
}

void sub_1002071E0( _Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9)
{
}

uint64_t sub_1002071FC(uint64_t a1, uint64_t a2)
{
  return a1;
}

uint64_t sub_100207254(uint64_t a1)
{
  uint64_t v15 = 0LL;
  __int128 v14 = 0u;
  memset(v13, 0, sizeof(v13));
  __int128 v11 = 0u;
  *(_OWORD *)std::stringbuf::string_type __p = 0u;
  __int128 v9 = 0u;
  *(_OWORD *)uint64_t v10 = 0u;
  __int128 v7 = 0u;
  *(_OWORD *)id v8 = 0u;
  sub_100532DC0((uint64_t)&v7 + 1);
  BYTE2(v8[0]) = 0;
  BYTE4(v8[0]) = 0;
  BYTE2(v10[0]) = 0;
  BYTE4(v10[0]) = 0;
  DWORD1(v13[1]) = 0;
  __int128 v9 = 0uLL;
  v8[1] = 0LL;
  LOBYTE(v10[0]) = 0;
  __int128 v11 = 0uLL;
  v10[1] = 0LL;
  LOBYTE(__p[0]) = 0;
  memset(v13, 0, 19);
  __p[1] = 0LL;
  BYTE8(v13[1]) = 1;
  BYTE2(v15) = 0;
  *(void *)((char *)&v13[1] + 14) = 0LL;
  *(void *)((char *)&v13[1] + 9) = 0LL;
  __int128 v14 = 0uLL;
  *((void *)&v13[2] + 1) = 0LL;
  LOBYTE(v15) = 0;
  BOOL v3 = sub_1003D2408(*(void *)(a1 + 32), (uint64_t)&v7);
  unsigned int v4 = DWORD1(v13[1]);
  if (SHIBYTE(v13[0]) < 0) {
    operator delete(__p[1]);
  }
  if (SHIBYTE(v11) < 0) {
    operator delete(v10[1]);
  }
  if (SHIBYTE(v9) < 0) {
    operator delete(v8[1]);
  }
  if (v3) {
    uint64_t v5 = v4;
  }
  else {
    uint64_t v5 = 0LL;
  }
  nullsub_63((char *)&v7 + 1, v2);
  return v5;
}

void sub_100207388( _Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9)
{
}

uint64_t sub_1002073A4(uint64_t a1)
{
  return *(unsigned __int16 *)(a1 + 40);
}

uint64_t sub_1002073AC(uint64_t a1)
{
  return *(void *)(a1 + 32);
}

uint64_t sub_1002073B4(uint64_t result, uint64_t a2)
{
  *(void *)(result + 4std::iostream::~basic_iostream(v2, v3 + 8) = a2;
  return result;
}

uint64_t sub_1002073BC(uint64_t a1)
{
  return *(void *)(a1 + 48);
}

unint64_t sub_1002073C4(uint64_t a1)
{
  return *(unsigned int *)(a1 + 42) | ((unint64_t)*(unsigned __int16 *)(a1 + 46) << 32);
}

uint64_t sub_1002073D4(uint64_t a1)
{
  return *(unsigned int *)(a1 + 56);
}

uint64_t sub_1002073DC(uint64_t result, int a2)
{
  *(_DWORD *)(result + 56) = a2;
  return result;
}

uint64_t sub_1002073E4(uint64_t a1)
{
  return *(unsigned __int8 *)(a1 + 60);
}

uint64_t sub_1002073EC(uint64_t result, char a2)
{
  *(_BYTE *)(result + 60) = a2;
  return result;
}

uint64_t sub_1002073F4(uint64_t a1)
{
  return *(unsigned __int8 *)(a1 + 61);
}

uint64_t sub_1002073FC(uint64_t result, char a2)
{
  *(_BYTE *)(result + 61) = a2;
  return result;
}

uint64_t sub_100207404(uint64_t a1)
{
  return *(unsigned __int8 *)(a1 + 62);
}

uint64_t sub_10020740C(uint64_t result, char a2)
{
  *(_BYTE *)(result + 62) = a2;
  return result;
}

uint64_t sub_100207414(uint64_t a1)
{
  return *(unsigned __int8 *)(a1 + 63);
}

uint64_t sub_10020741C(uint64_t result, char a2)
{
  *(_BYTE *)(result + 63) = a2;
  return result;
}

uint64_t sub_100207424(uint64_t a1)
{
  return *(unsigned __int8 *)(a1 + 64);
}

uint64_t sub_10020742C(uint64_t result, char a2)
{
  *(_BYTE *)(result + 64) = a2;
  return result;
}

uint64_t sub_100207434(uint64_t a1)
{
  return *(unsigned __int8 *)(a1 + 65);
}

uint64_t sub_10020743C(uint64_t result, char a2)
{
  *(_BYTE *)(result + 65) = a2;
  return result;
}

uint64_t sub_100207444(uint64_t result, char a2)
{
  *(_BYTE *)(result + 66) = a2;
  return result;
}

uint64_t sub_10020744C(uint64_t a1)
{
  return *(unsigned __int8 *)(a1 + 68);
}

uint64_t sub_100207454(uint64_t result, char a2)
{
  *(_BYTE *)(result + 6std::iostream::~basic_iostream(v2, v3 + 8) = a2;
  if ((a2 & 1) == 0) {
    *(_BYTE *)(result + 69) = 0;
  }
  return result;
}

uint64_t sub_100207464(uint64_t result, char a2)
{
  *(_BYTE *)(result + 69) = a2;
  return result;
}

uint64_t sub_10020746C(uint64_t a1)
{
  return *(unsigned __int8 *)(a1 + 69);
}

uint64_t sub_100207474(uint64_t a1)
{
  return *(unsigned __int8 *)(a1 + 67);
}

uint64_t sub_10020747C(uint64_t result, char a2)
{
  *(_BYTE *)(result + 6memset((char *)&v11[1] + 1, 0, 7) = a2;
  return result;
}

uint64_t sub_100207484(uint64_t a1)
{
  return *(unsigned __int8 *)(a1 + 72);
}

uint64_t sub_10020748C(uint64_t a1)
{
  return *(unsigned __int8 *)(a1 + 73);
}

uint64_t sub_100207494(uint64_t result, char a2)
{
  *(_BYTE *)(result + 73) = a2;
  return result;
}

uint64_t sub_10020749C(uint64_t a1)
{
  return *(unsigned __int8 *)(a1 + 74);
}

uint64_t sub_1002074A4(uint64_t result, char a2)
{
  *(_BYTE *)(result + 74) = a2;
  return result;
}

uint64_t sub_1002074AC(uint64_t a1)
{
  return *(unsigned __int8 *)(a1 + 75);
}

uint64_t sub_1002074B4(uint64_t result, char a2)
{
  *(_BYTE *)(result + 75) = a2;
  return result;
}

uint64_t sub_1002074BC(uint64_t a1)
{
  return *(unsigned __int8 *)(a1 + 76);
}

uint64_t sub_1002074C4(uint64_t result, char a2)
{
  *(_BYTE *)(result + 76) = a2;
  return result;
}

uint64_t sub_1002074CC(uint64_t a1)
{
  return *(unsigned __int8 *)(a1 + 79);
}

uint64_t sub_1002074D4(uint64_t result, char a2)
{
  *(_BYTE *)(result + 79) = a2;
  return result;
}

uint64_t sub_1002074DC(uint64_t a1)
{
  return *(unsigned __int8 *)(a1 + 80);
}

uint64_t sub_1002074E4(uint64_t result, char a2)
{
  *(_BYTE *)(result + 80) = a2;
  return result;
}

uint64_t sub_1002074EC(uint64_t a1)
{
  return *(unsigned __int8 *)(a1 + 77);
}

uint64_t sub_1002074F4(uint64_t result, char a2)
{
  *(_BYTE *)(result + 7memset((char *)&v11[1] + 1, 0, 7) = a2;
  return result;
}

uint64_t sub_1002074FC(uint64_t a1)
{
  return *(unsigned __int8 *)(a1 + 78);
}

uint64_t sub_100207504(uint64_t result, char a2)
{
  *(_BYTE *)(result + 7std::iostream::~basic_iostream(v2, v3 + 8) = a2;
  return result;
}

uint64_t sub_10020750C(uint64_t a1)
{
  return *(unsigned __int8 *)(a1 + 81);
}

uint64_t sub_100207514(uint64_t result, char a2)
{
  *(_BYTE *)(result + 81) = a2;
  return result;
}

uint64_t sub_10020751C(uint64_t a1)
{
  return *(unsigned __int8 *)(a1 + 101);
}

uint64_t sub_100207524(uint64_t result, char a2)
{
  *(_BYTE *)(result + 101) = a2;
  return result;
}

uint64_t sub_10020752C(uint64_t a1)
{
  return *(unsigned __int8 *)(a1 + 102);
}

uint64_t sub_100207534(uint64_t result, char a2)
{
  *(_BYTE *)(result + 102) = a2;
  return result;
}

uint64_t sub_10020753C(uint64_t a1)
{
  return *(unsigned __int8 *)(a1 + 100);
}

uint64_t sub_100207544(uint64_t result, char a2)
{
  *(_BYTE *)(result + 100) = a2;
  return result;
}

uint64_t sub_10020754C(uint64_t a1)
{
  return *(unsigned __int8 *)(a1 + 140);
}

uint64_t sub_100207554(uint64_t result, char a2)
{
  *(_BYTE *)(result + 140) = a2;
  return result;
}

uint64_t sub_10020755C(uint64_t a1)
{
  return *(unsigned int *)(a1 + 88);
}

uint64_t sub_100207564(uint64_t result, int a2)
{
  *(_DWORD *)(result + 8std::iostream::~basic_iostream(v2, v3 + 8) = a2;
  return result;
}

uint64_t sub_10020756C(uint64_t a1)
{
  return *(unsigned __int8 *)(a1 + 92);
}

uint64_t sub_100207574(uint64_t result, char a2)
{
  *(_BYTE *)(result + 92) = a2;
  return result;
}

uint64_t sub_10020757C(uint64_t result, char a2)
{
  *(_BYTE *)(result + 70) = a2;
  return result;
}

uint64_t sub_100207584(uint64_t a1)
{
  return *(unsigned __int8 *)(a1 + 70);
}

uint64_t sub_10020758C(uint64_t a1)
{
  return *(unsigned __int8 *)(a1 + 71);
}

uint64_t sub_100207594(uint64_t result, char a2)
{
  *(_BYTE *)(result + 170) = a2;
  return result;
}

uint64_t sub_10020759C(uint64_t a1)
{
  return *(unsigned __int8 *)(a1 + 170);
}

uint64_t sub_1002075A4(uint64_t result, int a2)
{
  *(_DWORD *)(result + 96) = a2;
  return result;
}

uint64_t sub_1002075AC(uint64_t result, int a2)
{
  *(_DWORD *)(result + 112) = a2;
  return result;
}

uint64_t sub_1002075B4(uint64_t a1)
{
  return *(unsigned int *)(a1 + 112);
}

uint64_t sub_1002075BC(uint64_t result, int a2)
{
  *(_DWORD *)(result + 116) = a2;
  return result;
}

uint64_t sub_1002075C4(uint64_t a1)
{
  return *(unsigned int *)(a1 + 116);
}

uint64_t sub_1002075CC(uint64_t result, int a2)
{
  *(_DWORD *)(result + 120) = a2;
  return result;
}

uint64_t sub_1002075D4(uint64_t a1)
{
  return *(unsigned int *)(a1 + 120);
}

uint64_t sub_1002075DC(uint64_t result, int a2)
{
  *(_DWORD *)(result + 12std::iostream::~basic_iostream(v2, v3 + 8) = a2;
  return result;
}

uint64_t sub_1002075E4(uint64_t a1)
{
  return *(unsigned int *)(a1 + 128);
}

uint64_t sub_1002075EC(uint64_t result, int a2)
{
  *(_DWORD *)(result + 124) = a2;
  return result;
}

uint64_t sub_1002075F4(uint64_t a1)
{
  return *(unsigned int *)(a1 + 124);
}

uint64_t sub_1002075FC(uint64_t result, char a2)
{
  *(_BYTE *)(result + 132) = a2;
  return result;
}

uint64_t sub_100207604(uint64_t a1)
{
  return *(unsigned __int8 *)(a1 + 132);
}

uint64_t sub_10020760C(uint64_t result, char a2)
{
  *(_BYTE *)(result + 82) = a2;
  return result;
}

uint64_t sub_100207614(uint64_t result, int a2)
{
  *(_DWORD *)(result + 136) = a2;
  return result;
}

uint64_t sub_10020761C(uint64_t a1)
{
  return *(unsigned int *)(a1 + 136);
}

uint64_t sub_100207624(uint64_t a1)
{
  uint64_t v13 = 0LL;
  __int128 v12 = 0u;
  memset(v11, 0, sizeof(v11));
  __int128 v9 = 0u;
  *(_OWORD *)std::stringbuf::string_type __p = 0u;
  __int128 v7 = 0u;
  *(_OWORD *)id v8 = 0u;
  __int128 v5 = 0u;
  *(_OWORD *)unsigned int v6 = 0u;
  sub_100532DC0((uint64_t)&v5 + 1);
  BYTE2(v6[0]) = 0;
  BYTE4(v6[0]) = 0;
  BYTE2(v8[0]) = 0;
  BYTE4(v8[0]) = 0;
  DWORD1(v11[1]) = 0;
  __int128 v7 = 0uLL;
  v6[1] = 0LL;
  LOBYTE(v8[0]) = 0;
  __int128 v9 = 0uLL;
  v8[1] = 0LL;
  LOBYTE(__p[0]) = 0;
  memset(v11, 0, 19);
  __p[1] = 0LL;
  BYTE8(v11[1]) = 1;
  BYTE2(v13) = 0;
  *(void *)((char *)&v11[1] + 14) = 0LL;
  *(void *)((char *)&v11[1] + 9) = 0LL;
  __int128 v12 = 0uLL;
  *((void *)&v11[2] + 1) = 0LL;
  LOBYTE(v13) = 0;
  LODWORD(a1) = sub_1003D2408(*(void *)(a1 + 32), (uint64_t)&v5);
  int v3 = BYTE11(v11[1]);
  if (SHIBYTE(v11[0]) < 0) {
    operator delete(__p[1]);
  }
  if (SHIBYTE(v9) < 0) {
    operator delete(v8[1]);
  }
  if (SHIBYTE(v7) < 0) {
    operator delete(v6[1]);
  }
  if (v3) {
    a1 = a1;
  }
  else {
    a1 = 0LL;
  }
  nullsub_63((char *)&v5 + 1, v1);
  return a1;
}

void sub_100207758( _Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9)
{
}

uint64_t sub_100207774(uint64_t a1)
{
  return *(unsigned int *)(a1 + 144);
}

__n128 sub_10020777C(uint64_t a1, __n128 *a2)
{
  if ((__n128 *)(a1 + 152) != a2)
  {
    __n128 result = *a2;
    *(__n128 *)(a1 + 152) = *a2;
  }

  return result;
}

__n128 sub_100207794@<Q0>(uint64_t a1@<X0>, __n128 *a2@<X8>)
{
  __n128 result = *(__n128 *)(a1 + 152);
  *a2 = result;
  return result;
}

uint64_t sub_1002077A0(uint64_t result, char a2)
{
  *(_BYTE *)(result + 169) = a2;
  return result;
}

uint64_t sub_1002077A8(uint64_t a1)
{
  return *(unsigned __int8 *)(a1 + 169);
}

uint64_t sub_1002077B0(uint64_t result, char a2)
{
  *(_BYTE *)(result + 103) = a2;
  return result;
}

uint64_t sub_1002077B8(uint64_t a1)
{
  return *(unsigned __int8 *)(a1 + 103);
}

uint64_t sub_1002077C0(uint64_t result)
{
  return result;
}

uint64_t sub_1002077D0(uint64_t result)
{
  *(_BYTE *)(result + ++*(_BYTE *)(result + 104) = 0;
  return result;
}

uint64_t sub_1002077D8(uint64_t a1)
{
  return *(unsigned __int8 *)(a1 + 104);
}

void sub_1002077E0(void ***a1)
{
  uint64_t v1 = *a1;
  uint64_t v2 = **a1;
  if (v2)
  {
    uint64_t v4 = (uint64_t)v1[1];
    __int128 v5 = **a1;
    if ((void *)v4 != v2)
    {
      do
      {
        v4 -= 104LL;
        sub_100207864((uint64_t)(v1 + 2), v4);
      }

      while ((void *)v4 != v2);
      __int128 v5 = **a1;
    }

    v1[1] = v2;
    operator delete(v5);
  }

void sub_100207864(uint64_t a1, uint64_t a2)
{
}

void sub_10020789C(uint64_t a1, uint64_t a2, uint64_t a3, unint64_t a4)
{
  uint64_t v8 = a1 + 16;
  __int128 v9 = *(id **)a1;
  if (0x4EC4EC4EC4EC4EC5LL * ((uint64_t)(*(void *)(a1 + 16) - *(void *)a1) >> 3) >= a4)
  {
    if (0x4EC4EC4EC4EC4EC5LL * ((uint64_t)(*(void *)(a1 + 8) - (void)v9) >> 3) >= a4)
    {
      sub_100207C1C((int)&v17, a2, a3, v9);
      uint64_t v14 = v13;
      uint64_t v15 = *(void *)(a1 + 8);
      if (v15 != v13)
      {
        do
        {
          v15 -= 104LL;
          sub_100207864(v8, v15);
        }

        while (v15 != v14);
      }

      *(void *)(a1 + std::iostream::~basic_iostream(v2, v3 + 8) = v14;
    }

    else
    {
      uint64_t v12 = a2 + 8 * ((uint64_t)(*(void *)(a1 + 8) - (void)v9) >> 3);
      sub_100207C1C((int)&v16, a2, v12, v9);
      sub_100207A48(a1, v12, a3);
    }
  }

  else
  {
    sub_100207AB8((void **)a1);
    if (a4 > 0x276276276276276LL) {
      abort();
    }
    unint64_t v10 = 0x9D89D89D89D89D8ALL * ((uint64_t)(*(void *)(a1 + 16) - *(void *)a1) >> 3);
    if (v10 <= a4) {
      unint64_t v10 = a4;
    }
    else {
      unint64_t v11 = v10;
    }
    sub_100207B24((void *)a1, v11);
    sub_100207A48(a1, a2, a3);
  }

uint64_t sub_100207A48(uint64_t result, uint64_t a2, uint64_t a3)
{
  uint64_t v3 = result;
  uint64_t v4 = *(void *)(result + 8);
  if (a2 != a3)
  {
    uint64_t v7 = 0LL;
    do
    {
      __n128 result = sub_100207B74(v4 + v7, a2 + v7);
      v7 += 104LL;
    }

    while (a2 + v7 != a3);
    v4 += v7;
  }

  *(void *)(v3 + std::iostream::~basic_iostream(v2, v3 + 8) = v4;
  return result;
}

void sub_100207AB0(_Unwind_Exception *a1)
{
  *(void *)(v1 + std::iostream::~basic_iostream(v2, v3 + 8) = v2;
  _Unwind_Resume(a1);
}

void sub_100207AB8(void **a1)
{
  uint64_t v1 = *a1;
  if (*a1)
  {
    uint64_t v3 = (uint64_t)a1[1];
    uint64_t v4 = *a1;
    if ((void *)v3 != v1)
    {
      do
      {
        v3 -= 104LL;
        sub_100207864((uint64_t)(a1 + 2), v3);
      }

      while ((void *)v3 != v1);
      uint64_t v4 = *a1;
    }

    a1[1] = v1;
    operator delete(v4);
    *a1 = 0LL;
    a1[1] = 0LL;
    a1[2] = 0LL;
  }

char *sub_100207B24(void *a1, unint64_t a2)
{
  if (a2 >= 0x276276276276277LL) {
    abort();
  }
  __n128 result = (char *)sub_100207CA4((uint64_t)(a1 + 2), a2);
  *a1 = result;
  a1[1] = result;
  a1[2] = &result[104 * v4];
  return result;
}

uint64_t sub_100207B74(uint64_t a1, uint64_t a2)
{
  *(void *)a1 = *(id *)a2;
  *(void *)(a1 + std::iostream::~basic_iostream(v2, v3 + 8) = *(void *)(a2 + 8);
  *(_DWORD *)(a1 + 16) = *(_DWORD *)(a2 + 16);
  sub_10054A424((void *)(a1 + 24));
  uint64_t v4 = (_BYTE *)(a1 + 80);
  if (*(char *)(a2 + 103) < 0)
  {
    sub_100024238(v4, *(void **)(a2 + 80), *(void *)(a2 + 88));
  }

  else
  {
    __int128 v5 = *(_OWORD *)(a2 + 80);
    *(void *)(a1 + 96) = *(void *)(a2 + 96);
    *(_OWORD *)uint64_t v4 = v5;
  }

  return a1;
}

void sub_100207BF8(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

uint64_t sub_100207C1C(int a1, uint64_t a2, uint64_t a3, id *location)
{
  uint64_t v5 = a2;
  if (a2 == a3) {
    return a2;
  }
  uint64_t v6 = a3;
  do
  {
    objc_storeStrong(location, *(id *)v5);
    uint64_t v7 = *(void **)(v5 + 8);
    *((_DWORD *)location + 4) = *(_DWORD *)(v5 + 16);
    location[1] = v7;
    sub_10054A44C((std::string *)location + 1, v5 + 24);
    std::string::operator=((std::string *)(location + 10), (const std::string *)(v5 + 80));
    location += 13;
    v5 += 104LL;
  }

  while (v5 != v6);
  return v6;
}

void *sub_100207CA4(uint64_t a1, unint64_t a2)
{
  if (a2 >= 0x276276276276277LL) {
    sub_100008BD4();
  }
  return operator new(104 * a2);
}

void sub_100207CEC(id a1)
{
  uint64_t v1 = operator new(0x350uLL);
  sub_100461C70();
  off_1008D9028 = v1;
}

void sub_100207D1C(_Unwind_Exception *a1)
{
}

xpc_connection_t *sub_100207D30( xpc_connection_t *a1, _xpc_connection_s *a2, _xpc_connection_s *name, _xpc_connection_s *targetq)
{
  *a1 = a2;
  a1[1] = name;
  a1[2] = targetq;
  mach_service = xpc_connection_create_mach_service((const char *)name, (dispatch_queue_t)targetq, 0LL);
  a1[3] = mach_service;
  a1[4] = 0LL;
  if (a1[2])
  {
    dispatch_retain((dispatch_object_t)a1[2]);
    mach_service = a1[3];
  }

  handler[0] = _NSConcreteStackBlock;
  handler[1] = 3221225472LL;
  handler[2] = sub_100207DF0;
  handler[3] = &unk_100887318;
  handler[4] = a1;
  xpc_connection_set_event_handler(mach_service, handler);
  xpc_connection_set_context(a1[3], a1);
  xpc_connection_set_finalizer_f(a1[3], (xpc_finalizer_t)sub_100207EBC);
  return a1;
}

void sub_100207DDC(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_100207DF0(uint64_t a1, void *a2)
{
}

void sub_100207DF8(void *a1, xpc_object_t object)
{
  xpc_type_t type = xpc_get_type(object);
  if (type == (xpc_type_t)&_xpc_type_dictionary)
  {
    sub_100208284(a1, object);
  }

  else if (type == (xpc_type_t)&_xpc_type_error)
  {
    sub_1002082E4(a1, object);
  }

  else
  {
    uint64_t v5 = xpc_copy_description(object);
    uint64_t v6 = (os_log_s *)qword_1008F75F0;
    if (os_log_type_enabled((os_log_t)qword_1008F75F0, OS_LOG_TYPE_ERROR)) {
      sub_10065E4E0((uint64_t)a1, (uint64_t)v5, v6);
    }
    free(v5);
  }

uint64_t sub_100207EC4(uint64_t a1)
{
  uint64_t v2 = *(dispatch_object_s **)(a1 + 16);
  if (v2) {
    dispatch_release(v2);
  }

  return a1;
}

void sub_100207EFC(uint64_t a1)
{
  uint64_t v2 = (os_log_s *)qword_1008F75F0;
  if (os_log_type_enabled((os_log_t)qword_1008F75F0, OS_LOG_TYPE_DEFAULT))
  {
    uint64_t v3 = *(void *)(a1 + 8);
    int v4 = 136315138;
    uint64_t v5 = v3;
    _os_log_impl( (void *)&_mh_execute_header,  v2,  OS_LOG_TYPE_DEFAULT,  "Opening XPC Connection %s",  (uint8_t *)&v4,  0xCu);
  }

  xpc_connection_resume(*(xpc_connection_t *)(a1 + 24));
}

void sub_100207FA8(uint64_t a1, void *a2)
{
  id v6 = a2;
  uint64_t v3 = _Block_copy(v6);
  uint64_t v4 = [v3 autorelease];
  uint64_t v5 = *(void **)(a1 + 32);
  *(void *)(a1 + 32) = v4;

  xpc_connection_cancel(*(xpc_connection_t *)(a1 + 24));
  xpc_release(*(xpc_object_t *)(a1 + 24));
}

void sub_100207FFC( _Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, id a10)
{
}

void sub_100208010(uint64_t a1, void *a2, void *a3)
{
  id v5 = a3;
  id v6 = *(_xpc_connection_s **)(a1 + 24);
  id v7 = v5;
  if (v5) {
    xpc_connection_send_message_with_reply(v6, a2, *(dispatch_queue_t *)(a1 + 16), v5);
  }
  else {
    xpc_connection_send_message(v6, a2);
  }
  xpc_release(a2);
}

void sub_100208070( _Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, id a10)
{
}

void sub_100208084(uint64_t a1, void *a2, void *a3)
{
  id v6 = a3;
  xpc_object_t v5 = xpc_connection_send_message_with_reply_sync(*(xpc_connection_t *)(a1 + 24), a2);
  if (v5)
  {
    v6[2](v6, v5);
    xpc_release(v5);
  }

  xpc_release(a2);
}

void sub_1002080EC( _Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, id a10)
{
}

void sub_100208104(uint64_t a1, char *a2, void *a3, void *a4)
{
  id v8 = a4;
  xpc_object_t v7 = sub_100208174((int)v8, a2, a3);
  sub_100208010(a1, v7, v8);
}

void sub_100208160( _Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, id a10)
{
}

xpc_object_t sub_100208174(int a1, char *string, void *a3)
{
  *(_OWORD *)keys = *(_OWORD *)off_100887338;
  object[0] = xpc_string_create(string);
  object[1] = a3;
  if (a3) {
    size_t v4 = 2LL;
  }
  else {
    size_t v4 = 1LL;
  }
  xpc_object_t v5 = xpc_dictionary_create((const char *const *)keys, object, v4);
  xpc_release(object[0]);
  if (a3) {
    xpc_release(a3);
  }
  return v5;
}

void sub_100208214(uint64_t a1, char *a2, void *a3, void *a4)
{
  id v8 = a4;
  xpc_object_t v7 = sub_100208174((int)v8, a2, a3);
  sub_100208084(a1, v7, v8);
}

void sub_100208270( _Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, id a10)
{
}

uint64_t sub_100208284(void *a1, xpc_object_t xdict)
{
  string = xpc_dictionary_get_string(xdict, "kMsgId");
  xpc_object_t value = xpc_dictionary_get_value(xdict, "kMsgArgs");
  return (**(uint64_t (***)(void, const char *, xpc_object_t))*a1)(*a1, string, value);
}

void sub_1002082E4(void *a1, void *a2)
{
  if (a2 == &_xpc_error_connection_interrupted)
  {
    sub_100208384(a1);
  }

  else if (a2 == &_xpc_error_connection_invalid)
  {
    sub_1002083DC((uint64_t)a1);
  }

  else
  {
    size_t v4 = (os_log_s *)qword_1008F75F0;
    if (os_log_type_enabled((os_log_t)qword_1008F75F0, OS_LOG_TYPE_ERROR)) {
      sub_10065E55C((uint64_t)a1, a2, v4);
    }
  }

uint64_t sub_100208384(void *a1)
{
  uint64_t v2 = (os_log_s *)qword_1008F75F0;
  if (os_log_type_enabled((os_log_t)qword_1008F75F0, OS_LOG_TYPE_ERROR)) {
    sub_10065E600((uint64_t)a1, v2, v3, v4, v5, v6, v7, v8);
  }
  return (*(uint64_t (**)(void))(*(void *)*a1 + 8LL))(*a1);
}

uint64_t sub_1002083DC(uint64_t result)
{
  if (!*(void *)(result + 32))
  {
    uint64_t v1 = (void *)result;
    uint64_t v2 = (os_log_s *)qword_1008F75F0;
    if (os_log_type_enabled((os_log_t)qword_1008F75F0, OS_LOG_TYPE_ERROR)) {
      sub_10065E668((uint64_t)v1, v2, v3, v4, v5, v6, v7, v8);
    }
    return (*(uint64_t (**)(void))(*(void *)*v1 + 16LL))(*v1);
  }

  return result;
}

void sub_10020843C(uint64_t a1)
{
  uint64_t v2 = (os_log_s *)qword_1008F75F0;
  if (os_log_type_enabled((os_log_t)qword_1008F75F0, OS_LOG_TYPE_INFO))
  {
    uint64_t v3 = *(void *)(a1 + 8);
    int v6 = 136446210;
    uint64_t v7 = v3;
    _os_log_impl( (void *)&_mh_execute_header,  v2,  OS_LOG_TYPE_INFO,  "XPCServiceConnection (%{public}s) finalized",  (uint8_t *)&v6,  0xCu);
  }

  uint64_t v4 = (void (**)(void))objc_retainBlock(*(id *)(a1 + 32));
  if (v4)
  {
    uint64_t v5 = *(void **)(a1 + 32);
    *(void *)(a1 + 32) = 0LL;

    v4[2](v4);
    _Block_release(v4);
  }
}

void sub_100208514(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

uint64_t sub_10020852C(uint64_t a1, uint64_t a2, __int16 a3)
{
  *(void *)a1 = off_100887358;
  *(void *)(a1 + std::iostream::~basic_iostream(v2, v3 + 8) = a2;
  *(_WORD *)(a1 + 40) = a3;
  *(_WORD *)(a1 + 42) = 0;
  *(void *)(a1 + 4std::iostream::~basic_iostream(v2, v3 + 8) = 0LL;
  sub_100242DC4(a1 + 64);
  sub_100243040((pthread_cond_t *)(a1 + 128));
  *(void *)(a1 + ++*(_DWORD *)(result + 184) = 0LL;
  *(void *)(a1 + 16) = dispatch_queue_create("com.apple.MobileBluetooth.InputDevice", 0LL);
  Mutable = CFDictionaryCreateMutable( kCFAllocatorDefault,  0LL,  &kCFTypeDictionaryKeyCallBacks,  &kCFTypeDictionaryValueCallBacks);
  *(void *)(a1 + 56) = Mutable;
  CFDictionarySetValue(Mutable, @"Transport", @"Bluetooth");
  return a1;
}

void sub_1002085DC(_Unwind_Exception *a1)
{
}

uint64_t sub_100208604(uint64_t a1)
{
  *(void *)a1 = off_100887358;
  if (*(void *)(a1 + 48))
  {
    uint64_t v2 = (os_log_s *)qword_1008F7730;
    if (os_log_type_enabled((os_log_t)qword_1008F7730, OS_LOG_TYPE_FAULT)) {
      sub_10065E6D0(v2, v3, v4, v5, v6, v7, v8, v9);
    }
  }

  CFRelease(*(CFTypeRef *)(a1 + 56));
  sub_1002430A8(a1 + 128);
  sub_100242E28(a1 + 64);
  return a1;
}

void sub_100208678(_Unwind_Exception *a1)
{
}

void sub_100208698(uint64_t a1)
{
  uint64_t v1 = (void *)sub_100208604(a1);
  operator delete(v1);
}

uint64_t sub_1002086AC(uint64_t a1, uint64_t a2)
{
  if (*(_BYTE *)(a1 + 43))
  {
    uint64_t v4 = (os_log_s *)qword_1008F7730;
    if (os_log_type_enabled((os_log_t)qword_1008F7730, OS_LOG_TYPE_FAULT)) {
      sub_10065E740(v4, v5, v6, v7, v8, v9, v10, v11);
    }
  }

  uint64_t result = sub_10020871C(a1, a2);
  if ((_DWORD)result) {
    *(_BYTE *)(a1 + 43) = 1;
  }
  return result;
}

uint64_t sub_10020871C(uint64_t a1, uint64_t a2)
{
  if (*(void *)(a1 + 48))
  {
    uint64_t v4 = (os_log_s *)qword_1008F7730;
    if (os_log_type_enabled((os_log_t)qword_1008F7730, OS_LOG_TYPE_FAULT)) {
      sub_10065E6D0(v4, v5, v6, v7, v8, v9, v10, v11);
    }
  }

  BOOL v12 = sub_1003D55CC(a2);
  uint64_t v13 = (os_log_s *)qword_1008F7730;
  if (!v12 && os_log_type_enabled((os_log_t)qword_1008F7730, OS_LOG_TYPE_FAULT))
  {
    LODWORD(__p) = 136446210;
    *(void *)((char *)&__p + 4) = "device->hasHIDInfos()";
    _os_log_fault_impl( (void *)&_mh_execute_header,  v13,  OS_LOG_TYPE_FAULT,  "Assertion failed: %{public}s",  (uint8_t *)&__p,  0xCu);
    uint64_t v13 = (os_log_s *)qword_1008F7730;
  }

  if (os_log_type_enabled(v13, OS_LOG_TYPE_DEFAULT))
  {
    sub_1003D0100(a2, (uint64_t)&__p);
    uint64_t v14 = v38 >= 0 ? &__p : (__int128 *)__p;
    *(_DWORD *)__int128 buf = 136446210;
    uint64_t v40 = v14;
    _os_log_impl( (void *)&_mh_execute_header,  v13,  OS_LOG_TYPE_DEFAULT,  "Creating IOHIDUserDevice for device %{public}s",  buf,  0xCu);
    if (v38 < 0) {
      operator delete((void *)__p);
    }
  }

  HIDWORD(v15) = *(unsigned __int8 *)(a2 + 131);
  LODWORD(v15) = bswap32(*(unsigned __int16 *)(a2 + 132));
  *(_DWORD *)__int128 buf = (v15 >> 16) | ((*(_BYTE *)(a2 + 130) & 0x7F) << 24);
  CFNumberRef v16 = CFNumberCreate(kCFAllocatorDefault, kCFNumberSInt32Type, buf);
  CFDictionarySetValue(*(CFMutableDictionaryRef *)(a1 + 56), @"LocationID", v16);
  CFRelease(v16);
  sub_1003FE1B4((unsigned __int8 *)(a2 + 128), &__p);
  if (v38 >= 0) {
    p_p = (const char *)&__p;
  }
  else {
    p_p = (const char *)__p;
  }
  CFStringRef v18 = CFStringCreateWithCString(kCFAllocatorDefault, p_p, 0x8000100u);
  if (v38 < 0) {
    operator delete((void *)__p);
  }
  CFDictionarySetValue(*(CFMutableDictionaryRef *)(a1 + 56), @"SerialNumber", v18);
  CFRelease(v18);
  sub_1003D0100(a2, (uint64_t)&__p);
  if (v38 >= 0) {
    __int16 v19 = (const char *)&__p;
  }
  else {
    __int16 v19 = (const char *)__p;
  }
  CFStringRef v20 = CFStringCreateWithCString(kCFAllocatorDefault, v19, 0x8000100u);
  if (v38 < 0) {
    operator delete((void *)__p);
  }
  CFDictionarySetValue(*(CFMutableDictionaryRef *)(a1 + 56), @"Product", v20);
  CFRelease(v20);
  int valuePtr = 5000000;
  CFNumberRef v21 = CFNumberCreate(kCFAllocatorDefault, kCFNumberSInt32Type, &valuePtr);
  CFDictionarySetValue(*(CFMutableDictionaryRef *)(a1 + 56), @"RequestTimeout", v21);
  CFRelease(v21);
  CFDictionarySetValue(*(CFMutableDictionaryRef *)(a1 + 56), @"HIDVirtualDevice", kCFBooleanFalse);
  *(void *)&__int128 __p = &off_10087FAA8;
  *((void *)&__p + 1) = 0LL;
  int v34 = 0;
  int v35 = 0;
  if (sub_1003D5538((_WORD *)a2, (uint64_t)&__p, (_WORD *)&v35 + 1, &v35, (_WORD *)&v34 + 1, &v34))
  {
    id v22 = (const UInt8 *)sub_10056AAF0((uint64_t)&__p);
    CFIndex v23 = sub_10056AAD8((uint64_t)&__p);
    CFDataRef v24 = CFDataCreate(kCFAllocatorDefault, v22, v23);
    CFDictionarySetValue(*(CFMutableDictionaryRef *)(a1 + 56), @"ReportDescriptor", v24);
    CFRelease(v24);
    CFNumberRef v25 = CFNumberCreate(kCFAllocatorDefault, kCFNumberSInt16Type, (char *)&v35 + 2);
    CFDictionarySetValue(*(CFMutableDictionaryRef *)(a1 + 56), @"VendorID", v25);
    CFRelease(v25);
    CFNumberRef v26 = CFNumberCreate(kCFAllocatorDefault, kCFNumberSInt16Type, &v35);
    CFDictionarySetValue(*(CFMutableDictionaryRef *)(a1 + 56), @"VendorIDSource", v26);
    CFRelease(v26);
    CFNumberRef v27 = CFNumberCreate(kCFAllocatorDefault, kCFNumberSInt16Type, (char *)&v34 + 2);
    CFDictionarySetValue(*(CFMutableDictionaryRef *)(a1 + 56), @"ProductID", v27);
    CFRelease(v27);
    CFNumberRef v28 = CFNumberCreate(kCFAllocatorDefault, kCFNumberSInt16Type, &v34);
    CFDictionarySetValue(*(CFMutableDictionaryRef *)(a1 + 56), @"VersionNumber", v28);
    CFRelease(v28);
  }

  if (sub_1003D2AF4(a2)) {
    CFDictionarySetValue(*(CFMutableDictionaryRef *)(a1 + 56), @"Manufacturer", @"Apple Inc.");
  }
  __int16 v33 = 0;
  if (sub_1003D5940((_BYTE *)a2, (_BYTE *)&v33 + 1, &v33))
  {
    if (HIBYTE(v33)) {
      CFBooleanRef v29 = kCFBooleanTrue;
    }
    else {
      CFBooleanRef v29 = kCFBooleanFalse;
    }
    CFDictionarySetValue(*(CFMutableDictionaryRef *)(a1 + 56), @"Authenticated", v29);
    CFNumberRef v30 = CFNumberCreate(kCFAllocatorDefault, kCFNumberSInt8Type, &v33);
    CFDictionarySetValue(*(CFMutableDictionaryRef *)(a1 + 56), @"IAPHIDAccessoryCategory", v30);
    CFRelease(v30);
  }

  *(void *)(a1 + ++*(_DWORD *)(result + 184) = CFDictionaryGetValue(*(CFDictionaryRef *)(a1 + 56), @"SerialNumber");
  uint64_t v31 = (*(uint64_t (**)(uint64_t, void))(*(void *)a1 + 88LL))(a1, *(void *)(a1 + 56));
  *(void *)&__int128 __p = &off_10087FAA8;
  if (*((void *)&__p + 1)) {
    sub_1002CD254(*((unsigned int **)&__p + 1));
  }
  return v31;
}

void sub_100208C08( _Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, void *__p, unsigned int *a12, int a13, __int16 a14, char a15, char a16)
{
  if (a12) {
    sub_1002CD254(a12);
  }
  _Unwind_Resume(exception_object);
}

_BYTE *sub_100208C68(_BYTE *result, uint64_t a2)
{
  if (result[43])
  {
    uint64_t v3 = (uint64_t)result;
    (*(void (**)(_BYTE *))(*(void *)result + 104LL))(result);
    sub_10020871C(v3, a2);
    return (_BYTE *)(*(uint64_t (**)(uint64_t))(*(void *)v3 + 96LL))(v3);
  }

  return result;
}

uint64_t sub_100208CC0(uint64_t a1)
{
  uint64_t v2 = (os_log_s *)qword_1008F7730;
  if (os_log_type_enabled((os_log_t)qword_1008F7730, OS_LOG_TYPE_DEFAULT))
  {
    *(_WORD *)uint64_t v4 = 0;
    _os_log_impl((void *)&_mh_execute_header, v2, OS_LOG_TYPE_DEFAULT, "Starting input device", v4, 2u);
  }

  return (*(uint64_t (**)(uint64_t))(*(void *)a1 + 96LL))(a1);
}

uint64_t sub_100208D38(uint64_t a1)
{
  return (*(uint64_t (**)(uint64_t))(*(void *)a1 + 104LL))(a1);
}

void sub_100208D44(dispatch_object_t *context)
{
}

uint64_t sub_100208D80(uint64_t result)
{
  if (result) {
    return (*(uint64_t (**)(uint64_t))(*(void *)result + 8LL))(result);
  }
  return result;
}

void sub_100208D94()
{
  uint64_t v0 = (os_log_s *)qword_1008F7730;
  if (os_log_type_enabled((os_log_t)qword_1008F7730, OS_LOG_TYPE_ERROR)) {
    sub_10065E7B0(v0, v1, v2, v3, v4, v5, v6, v7);
  }
}

void sub_100208DD4(uint64_t a1, const uint8_t *a2, CFIndex a3)
{
  if (*(void *)(a1 + 48))
  {
    uint64_t v6 = sub_1002427F8();
    uint64_t v7 = *(__IOHIDUserDevice **)(a1 + 48);
    if (!v6) {
      uint64_t v6 = mach_absolute_time();
    }
    IOHIDUserDeviceHandleReportWithTimeStamp(v7, v6, a2, a3);
  }

  else
  {
    uint64_t v8 = (os_log_s *)qword_1008F7730;
    if (os_log_type_enabled((os_log_t)qword_1008F7730, OS_LOG_TYPE_ERROR)) {
      sub_10065E7E0(v8, v9, v10, v11, v12, v13, v14, v15);
    }
  }

void sub_100208E64(uint64_t a1, char a2, int a3, uint64_t a4, uint64_t a5)
{
  v5[0] = _NSConcreteStackBlock;
  v5[1] = 3221225472LL;
  void v5[2] = sub_100208F54;
  v5[3] = &unk_1008873C8;
  char v6 = a2;
  v5[4] = a1;
  void v5[5] = a5;
  v5[6] = a4;
  sub_100208EBC(a1, a2, a3, v5);
}

void sub_100208EBC(uint64_t a1, char a2, int a3, void *a4)
{
  uint64_t v7 = a4;
  v8[0] = 0LL;
  v8[1] = 0LL;
  sub_100242F28((uint64_t)v8, a1 + 64);
  *(_BYTE *)(a1 + 176) = a2;
  *(_DWORD *)(a1 + 180) = a3;
  if (v7) {
    v7[2](v7);
  }
  sub_1002431AC((pthread_cond_t *)(a1 + 128));
  sub_100242FAC((uint64_t)v8);
}

void sub_100208F34(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void *sub_100208F54(void *result)
{
  if (*((_BYTE *)result + 56))
  {
    uint64_t v1 = *((void *)result + 4);
    uint64_t v2 = *(size_t **)(v1 + 32);
    if (v2)
    {
      if (*(void *)(v1 + 24))
      {
        size_t v3 = *v2;
        if (*((void *)result + 5) >= v3) {
          size_t v4 = v3;
        }
        else {
          size_t v4 = *((void *)result + 5);
        }
        uint64_t result = memcpy(*(void **)(v1 + 24), *((const void **)result + 6), v4);
        **(void **)(v1 + 32) = v4;
      }
    }
  }

  return result;
}

void sub_100208FAC(uint64_t a1, char a2, int a3)
{
}

BOOL sub_100208FB4(uint64_t a1, uint64_t a2)
{
  if (*(void *)(a1 + 48))
  {
    size_t v4 = (os_log_s *)qword_1008F7730;
    if (os_log_type_enabled((os_log_t)qword_1008F7730, OS_LOG_TYPE_FAULT)) {
      sub_10065E6D0(v4, v5, v6, v7, v8, v9, v10, v11);
    }
  }

  uint64_t v12 = IOHIDUserDeviceCreateWithOptions(kCFAllocatorDefault, a2, 1LL);
  uint64_t v13 = v12;
  *(void *)(a1 + 4std::iostream::~basic_iostream(v2, v3 + 8) = v12;
  if (v12)
  {
    IOHIDUserDeviceRegisterGetReportWithReturnLengthCallback(v12, sub_100209084, a1);
    IOHIDUserDeviceRegisterSetReportCallback(*(void *)(a1 + 48), sub_100209088, a1);
  }

  else
  {
    uint64_t v14 = (os_log_s *)qword_1008F7730;
    if (os_log_type_enabled((os_log_t)qword_1008F7730, OS_LOG_TYPE_ERROR)) {
      sub_10065E810(v14, v15, v16, v17, v18, v19, v20, v21);
    }
  }

  return v13 != 0;
}

uint64_t sub_100209088(uint64_t a1, int a2, int a3, uint64_t a4, uint64_t a5)
{
  v6[0] = _NSConcreteStackBlock;
  v6[1] = 3221225472LL;
  _DWORD v6[2] = sub_1002094B8;
  void v6[3] = &unk_1008873E8;
  int v7 = a2;
  int v8 = a3;
  char v6[4] = a1;
  v6[5] = a4;
  v6[6] = a5;
  return sub_1002093D0(a1, v6);
}

void sub_1002090E0(uint64_t a1)
{
  uint64_t v1 = *(void *)(a1 + 48);
  if (!v1)
  {
    size_t v3 = (os_log_s *)qword_1008F7730;
    if (!os_log_type_enabled((os_log_t)qword_1008F7730, OS_LOG_TYPE_DEFAULT)) {
      return;
    }
    LOWORD(v6[0]) = 0;
    size_t v4 = "Could not schedule IOHIDUserDevice";
    goto LABEL_7;
  }

  if (*(_BYTE *)(a1 + 42))
  {
    size_t v3 = (os_log_s *)qword_1008F7730;
    if (!os_log_type_enabled((os_log_t)qword_1008F7730, OS_LOG_TYPE_DEFAULT)) {
      return;
    }
    LOWORD(v6[0]) = 0;
    size_t v4 = "IOHIDUserDevice is already scheduled";
LABEL_7:
    _os_log_impl((void *)&_mh_execute_header, v3, OS_LOG_TYPE_DEFAULT, v4, (uint8_t *)v6, 2u);
    return;
  }

  *(_BYTE *)(a1 + 42) = 1;
  uint64_t v5 = (os_log_s *)qword_1008F7730;
  if (os_log_type_enabled((os_log_t)qword_1008F7730, OS_LOG_TYPE_DEFAULT))
  {
    v6[0] = 67109120;
    v6[1] = 1;
    _os_log_impl( (void *)&_mh_execute_header,  v5,  OS_LOG_TYPE_DEFAULT,  "Scheduling IOHIDUserDevice: fIsScheduled %d",  (uint8_t *)v6,  8u);
    uint64_t v1 = *(void *)(a1 + 48);
  }

  IOHIDUserDeviceScheduleWithDispatchQueue(v1, *(void *)(a1 + 16));
}

void sub_10020922C(uint64_t a1)
{
  uint64_t v2 = *(const void **)(a1 + 48);
  size_t v3 = (os_log_s *)qword_1008F7730;
  BOOL v4 = os_log_type_enabled((os_log_t)qword_1008F7730, OS_LOG_TYPE_DEFAULT);
  if (v2)
  {
    if (v4)
    {
      int v5 = *(unsigned __int8 *)(a1 + 42);
      v6[0] = 67109120;
      v6[1] = v5;
      _os_log_impl( (void *)&_mh_execute_header,  v3,  OS_LOG_TYPE_DEFAULT,  "Releasing IOHIDUserDevice: fIsScheduled %d",  (uint8_t *)v6,  8u);
      uint64_t v2 = *(const void **)(a1 + 48);
    }

    if (*(_BYTE *)(a1 + 42))
    {
      *(_BYTE *)(a1 + 42) = 0;
      IOHIDUserDeviceUnscheduleFromDispatchQueue(v2, *(void *)(a1 + 16));
      uint64_t v2 = *(const void **)(a1 + 48);
    }

    CFRelease(v2);
    *(void *)(a1 + 4std::iostream::~basic_iostream(v2, v3 + 8) = 0LL;
    sub_100208EBC(a1, 0, -536870212, 0LL);
  }

  else if (v4)
  {
    LOWORD(v6[0]) = 0;
    _os_log_impl( (void *)&_mh_execute_header,  v3,  OS_LOG_TYPE_DEFAULT,  "Could not release IOHIDUserDevice",  (uint8_t *)v6,  2u);
  }

  if (*(void *)(a1 + 184)) {
    *(void *)(a1 + ++*(_DWORD *)(result + 184) = 0LL;
  }
}

uint64_t sub_100209360(uint64_t a1, int a2, int a3, uint64_t a4, uint64_t a5)
{
  uint64_t v5 = 3758097090LL;
  if (a4 && a5)
  {
    v7[0] = _NSConcreteStackBlock;
    v7[1] = 3221225472LL;
    _DWORD v7[2] = sub_100209484;
    v7[3] = &unk_1008873E8;
    void v7[4] = a1;
    v7[5] = a4;
    v7[6] = a5;
    int v8 = a2;
    int v9 = a3;
    return sub_1002093D0(a1, v7);
  }

  return v5;
}

uint64_t sub_1002093D0(uint64_t a1, void *a2)
{
  size_t v3 = a2;
  v6[0] = 0LL;
  v6[1] = 0LL;
  sub_100242F28((uint64_t)v6, a1 + 64);
  if (v3[2](v3))
  {
    sub_1002430AC((pthread_cond_t *)(a1 + 128), (pthread_mutex_t *)(a1 + 64));
    if (*(_BYTE *)(a1 + 176)) {
      uint64_t v4 = 0LL;
    }
    else {
      uint64_t v4 = *(unsigned int *)(a1 + 180);
    }
  }

  else
  {
    uint64_t v4 = 3758097084LL;
  }

  sub_100242FAC((uint64_t)v6);

  return v4;
}

void sub_100209464(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

uint64_t sub_100209484(void *a1)
{
  uint64_t v1 = a1[4];
  *(void *)(v1 + 24) = a1[5];
  *(void *)(v1 + 32) = a1[6];
  return (***(uint64_t (****)(void))(v1 + 8))(*(void *)(v1 + 8));
}

uint64_t sub_1002094B8(uint64_t a1)
{
  return (*(uint64_t (**)(void))(**(void **)(*(void *)(a1 + 32) + 8LL) + 8LL))(*(void *)(*(void *)(a1 + 32) + 8LL));
}

uint64_t sub_1002094E4(uint64_t a1, int *a2, uint64_t a3, uint64_t a4, char a5)
{
  uint64_t result = sub_100242DC4();
  *(void *)(result + sub_100242E28(v1 + 64) = 0LL;
  *(void *)(result + 73) = 0LL;
  int v10 = *a2;
  *(_WORD *)(result + 6std::iostream::~basic_iostream(v2, v3 + 8) = *((_WORD *)a2 + 2);
  *(_DWORD *)(result + sub_100242E28(v1 + 64) = v10;
  LOWORD(v10) = *(_WORD *)(a3 + 4);
  *(_DWORD *)(result + 73) = *(_DWORD *)a3;
  *(_WORD *)(result + 7memset((char *)&v11[1] + 1, 0, 7) = v10;
  *(void *)(result + 8std::iostream::~basic_iostream(v2, v3 + 8) = a4;
  *(_BYTE *)(result + 72) = a5;
  return result;
}

uint64_t sub_10020954C(uint64_t a1)
{
  uint64_t v2 = (os_log_s *)qword_1008F7600;
  if (os_log_type_enabled((os_log_t)qword_1008F7600, OS_LOG_TYPE_DEFAULT))
  {
    if (*(_BYTE *)(a1 + 71) || *(_BYTE *)(a1 + 80)) {
      size_t v3 = "Yes";
    }
    else {
      size_t v3 = "No";
    }
    *(_DWORD *)__int128 buf = 136446210;
    *(void *)&uint8_t buf[4] = v3;
    _os_log_impl( (void *)&_mh_execute_header,  v2,  OS_LOG_TYPE_DEFAULT,  "start: already running..? %{public}s",  buf,  0xCu);
  }

  if (*(_BYTE *)(a1 + 71) || *(_BYTE *)(a1 + 80) || !*(void *)(a1 + 88)) {
    return 0LL;
  }
  if (qword_1008D9040 != -1) {
    dispatch_once(&qword_1008D9040, &stru_100887408);
  }
  sub_1001FFA38(qword_1008D9038, *(_BYTE *)(a1 + 72));
  if (*(unsigned __int8 *)(a1 + 72) >= 0xAu)
  {
    if (qword_1008D9040 != -1) {
      dispatch_once(&qword_1008D9040, &stru_100887408);
    }
    sub_1001FFA40(qword_1008D9038);
  }

  uint64_t v5 = (os_log_s *)qword_1008F7600;
  if (os_log_type_enabled((os_log_t)qword_1008F7600, OS_LOG_TYPE_INFO))
  {
    sub_100209898((unsigned __int8 *)(a1 + 64), buf);
    int v6 = v18;
    int v7 = *(_BYTE **)buf;
    sub_100209898((unsigned __int8 *)(a1 + 73), __p);
    int v8 = buf;
    if (v6 < 0) {
      int v8 = v7;
    }
    if (v16 >= 0) {
      int v9 = __p;
    }
    else {
      int v9 = (void **)__p[0];
    }
    *(_DWORD *)uint64_t v19 = 136315394;
    uint64_t v20 = v8;
    __int16 v21 = 2080;
    id v22 = v9;
    _os_log_impl( (void *)&_mh_execute_header,  v5,  OS_LOG_TYPE_INFO,  "sending pair status request to %s for magnet device %s ",  v19,  0x16u);
    if (v16 < 0) {
      operator delete(__p[0]);
    }
    if (v18 < 0) {
      operator delete(*(void **)buf);
    }
  }

  (***(void (****)(void, uint64_t, uint64_t))(a1 + 88))(*(void *)(a1 + 88), a1 + 64, a1 + 73);
  *(_BYTE *)(a1 + 71) = 1;
  int v10 = (os_log_s *)qword_1008F7600;
  if (os_log_type_enabled((os_log_t)qword_1008F7600, OS_LOG_TYPE_INFO))
  {
    sub_100209898((unsigned __int8 *)(a1 + 73), buf);
    int v11 = v18;
    uint64_t v12 = *(_BYTE **)buf;
    sub_100209898((unsigned __int8 *)(a1 + 64), __p);
    uint64_t v13 = buf;
    if (v11 < 0) {
      uint64_t v13 = v12;
    }
    if (v16 >= 0) {
      uint64_t v14 = __p;
    }
    else {
      uint64_t v14 = (void **)__p[0];
    }
    *(_DWORD *)uint64_t v19 = 136315394;
    uint64_t v20 = v13;
    __int16 v21 = 2080;
    id v22 = v14;
    _os_log_impl( (void *)&_mh_execute_header,  v10,  OS_LOG_TYPE_INFO,  "sending pair status request to %s  for aacp device %s ",  v19,  0x16u);
    if (v16 < 0) {
      operator delete(__p[0]);
    }
    if (v18 < 0) {
      operator delete(*(void **)buf);
    }
  }

  (***(void (****)(void, uint64_t, uint64_t))(a1 + 88))(*(void *)(a1 + 88), a1 + 73, a1 + 64);
  uint64_t result = 1LL;
  *(_BYTE *)(a1 + 80) = 1;
  *(_BYTE *)(a1 + 96) = 0;
  return result;
}

void sub_100209870( _Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, void *__p, uint64_t a14, int a15, __int16 a16, char a17, char a18)
{
  if (a18 < 0) {
    operator delete(__p);
  }
  _Unwind_Resume(exception_object);
}

void sub_100209898(unsigned __int8 *a1@<X1>, void *a2@<X8>)
{
  if (qword_1008D5F50 != -1) {
    dispatch_once(&qword_1008D5F50, &stru_100887428);
  }
  uint64_t v4 = sub_1003FFEB0(off_1008D5F48, (uint64_t)a1, 1);
  if (v4)
  {
    uint64_t v5 = (uint64_t)v4;
    sub_1003D0100((uint64_t)v4, (uint64_t)__p);
    if ((v8 & 0x80u) == 0) {
      unint64_t v6 = v8;
    }
    else {
      unint64_t v6 = (unint64_t)__p[1];
    }
    if ((char)v8 < 0)
    {
      operator delete(__p[0]);
      if (v6) {
        goto LABEL_9;
      }
    }

    else if (v6)
    {
LABEL_9:
      sub_1003CF00C(v5, a2);
      return;
    }
  }

  sub_1003FE1B4(a1, a2);
}

uint64_t sub_100209958(uint64_t a1, uint64_t a2, unsigned __int8 *a3, int a4)
{
  if (qword_1008D9040 != -1) {
    dispatch_once(&qword_1008D9040, &stru_100887408);
  }
  BOOL v8 = sub_100200478(qword_1008D9038);
  int v9 = (os_log_s *)qword_1008F7600;
  if (os_log_type_enabled((os_log_t)qword_1008F7600, OS_LOG_TYPE_DEFAULT))
  {
    if (a4 == 2) {
      int v10 = "Paired";
    }
    else {
      int v10 = "Not paired";
    }
    sub_100209898((unsigned __int8 *)a2, __p);
    if (v36 >= 0) {
      int v11 = __p;
    }
    else {
      int v11 = *(_BYTE **)__p;
    }
    uint64_t v12 = "Disallow";
    *(_DWORD *)__int128 buf = 136446722;
    if (v8) {
      uint64_t v12 = "Allow";
    }
    *(void *)&uint8_t buf[4] = v10;
    *(_WORD *)&_BYTE buf[12] = 2080;
    *(void *)&_BYTE buf[14] = v11;
    __int16 v38 = 2080;
    int v39 = v12;
    _os_log_impl( (void *)&_mh_execute_header,  v9,  OS_LOG_TYPE_DEFAULT,  "received pair status response %{public}s from device %s, isEasyPairingAllowed = %s",  buf,  0x20u);
    if (v36 < 0) {
      operator delete(*(void **)__p);
    }
  }

  v30[0] = 0LL;
  v30[1] = 0LL;
  sub_100242F28((uint64_t)v30, a1);
  if (*(_DWORD *)a2 == *(_DWORD *)(a1 + 64) && *(unsigned __int16 *)(a2 + 4) == *(unsigned __int16 *)(a1 + 68))
  {
    *(_BYTE *)(a1 + 70) = a4;
    uint64_t v15 = (_BYTE *)(a1 + 71);
    goto LABEL_25;
  }

  if (*(_DWORD *)a2 == *(_DWORD *)(a1 + 73) && *(unsigned __int16 *)(a2 + 4) == *(unsigned __int16 *)(a1 + 77))
  {
    *(_BYTE *)(a1 + 79) = a4;
    uint64_t v15 = (_BYTE *)(a1 + 80);
LABEL_25:
    _BYTE *v15 = 0;
  }

  if (!*(_BYTE *)(a1 + 71) && !*(_BYTE *)(a1 + 80))
  {
    if (v8)
    {
      int v17 = (*(_BYTE *)(a1 + 79) & *(_BYTE *)(a1 + 70));
      char v18 = (os_log_s *)qword_1008F7600;
      BOOL v19 = os_log_type_enabled((os_log_t)qword_1008F7600, OS_LOG_TYPE_DEFAULT);
      if (v17 == 2)
      {
        if (v19)
        {
          sub_100209898((unsigned __int8 *)a2, buf);
          int v20 = SHIBYTE(v38);
          __int16 v21 = *(_BYTE **)buf;
          sub_100209898(a3, __p);
          id v22 = buf;
          if (v20 < 0) {
            id v22 = v21;
          }
          if (v36 >= 0) {
            CFIndex v23 = __p;
          }
          else {
            CFIndex v23 = *(_BYTE **)__p;
          }
          *(_DWORD *)uint64_t v31 = 136315394;
          BOOL v32 = v22;
          __int16 v33 = 2080;
          int v34 = v23;
          _os_log_impl( (void *)&_mh_execute_header,  v18,  OS_LOG_TYPE_DEFAULT,  "Devices %s and %s are already paired",  v31,  0x16u);
          if (v36 < 0) {
            operator delete(*(void **)__p);
          }
          if (SHIBYTE(v38) < 0) {
            operator delete(*(void **)buf);
          }
        }

        (*(void (**)(void, uint64_t, unsigned __int8 *, uint64_t))(**(void **)(a1 + 88) + 16LL))( *(void *)(a1 + 88),  a2,  a3,  1LL);
      }

      else
      {
        if (v19)
        {
          sub_100209898((unsigned __int8 *)a2, buf);
          int v26 = SHIBYTE(v38);
          CFNumberRef v27 = *(_BYTE **)buf;
          sub_100209898(a3, __p);
          CFNumberRef v28 = buf;
          if (v26 < 0) {
            CFNumberRef v28 = v27;
          }
          if (v36 >= 0) {
            CFBooleanRef v29 = __p;
          }
          else {
            CFBooleanRef v29 = *(_BYTE **)__p;
          }
          *(_DWORD *)uint64_t v31 = 136315394;
          BOOL v32 = v28;
          __int16 v33 = 2080;
          int v34 = v29;
          _os_log_impl( (void *)&_mh_execute_header,  v18,  OS_LOG_TYPE_DEFAULT,  "Generate linkkey to pair between %s and %s",  v31,  0x16u);
          if (v36 < 0) {
            operator delete(*(void **)__p);
          }
          if (SHIBYTE(v38) < 0) {
            operator delete(*(void **)buf);
          }
        }

        *(void *)__int128 buf = 0LL;
        *(void *)&uint8_t buf[8] = 0LL;
        arc4random_buf(buf, 0x10uLL);
        (*(void (**)(void, uint64_t, uint64_t, _BYTE *, uint64_t))(**(void **)(a1 + 88) + 8LL))( *(void *)(a1 + 88),  a1 + 64,  a1 + 73,  buf,  16LL);
        (*(void (**)(void, uint64_t, uint64_t, _BYTE *, uint64_t))(**(void **)(a1 + 88) + 8LL))( *(void *)(a1 + 88),  a1 + 73,  a1 + 64,  buf,  16LL);
        *(_BYTE *)(a1 + 71) = 1;
        *(_BYTE *)(a1 + 80) = 1;
      }
    }

    else
    {
      CFDataRef v24 = (os_log_s *)qword_1008F7600;
      if (os_log_type_enabled((os_log_t)qword_1008F7600, OS_LOG_TYPE_DEFAULT))
      {
        sub_100209898((unsigned __int8 *)a2, buf);
        CFNumberRef v25 = v38 >= 0 ? buf : *(_BYTE **)buf;
        *(_DWORD *)__int128 __p = 136315138;
        *(void *)&__p[4] = v25;
        _os_log_impl( (void *)&_mh_execute_header,  v24,  OS_LOG_TYPE_DEFAULT,  "Easy pairing request is rejected from remote source %s",  __p,  0xCu);
        if (SHIBYTE(v38) < 0) {
          operator delete(*(void **)buf);
        }
      }
    }
  }

  return sub_100242FAC((uint64_t)v30);
}

void sub_100209DBC( _Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, void *__p, uint64_t a20, int a21, __int16 a22, char a23, char a24)
{
  if (a24 < 0) {
    operator delete(__p);
  }
  sub_100242FAC((uint64_t)&a9);
  _Unwind_Resume(a1);
}

void sub_100209E04(uint64_t a1, uint64_t a2, uint64_t a3, int a4)
{
  BOOL v8 = (os_log_s *)qword_1008F7600;
  if (os_log_type_enabled((os_log_t)qword_1008F7600, OS_LOG_TYPE_DEFAULT))
  {
    int v9 = a4 ? "Fail" : "Success";
    sub_100209898((unsigned __int8 *)a2, __p);
    int v10 = v16 >= 0 ? __p : (void **)__p[0];
    *(_DWORD *)__int128 buf = 136446466;
    char v18 = v9;
    __int16 v19 = 2080;
    int v20 = v10;
    _os_log_impl( (void *)&_mh_execute_header,  v8,  OS_LOG_TYPE_DEFAULT,  "Received link key store result %{public}s from device %s ",  buf,  0x16u);
    if (v16 < 0) {
      operator delete(__p[0]);
    }
  }

  if (*(_DWORD *)a2 == *(_DWORD *)(a1 + 64) && *(unsigned __int16 *)(a2 + 4) == *(unsigned __int16 *)(a1 + 68))
  {
    uint64_t v13 = (_BYTE *)(a1 + 71);
  }

  else
  {
    uint64_t v13 = (_BYTE *)(a1 + 80);
  }

  _BYTE *v13 = 0;
LABEL_22:
  int v14 = *(unsigned __int8 *)(a1 + 96) | a4;
  *(_BYTE *)(a1 + 96) |= a4;
  if (!*(_BYTE *)(a1 + 71) && !*(_BYTE *)(a1 + 80)) {
    (*(void (**)(void, uint64_t, uint64_t, void))(**(void **)(a1 + 88) + 16LL))( *(void *)(a1 + 88),  a2,  a3,  2 * (v14 != 0));
  }
}

void sub_100209FA4(id a1)
{
  uint64_t v1 = operator new(0x48uLL);
  sub_1001FFA34((uint64_t)v1);
  qword_1008D9038 = (uint64_t)v1;
}

void sub_100209FD4(_Unwind_Exception *a1)
{
}

void sub_100209FE8(id a1)
{
  uint64_t v1 = operator new(0x138uLL);
  sub_1003FE3E0((uint64_t)v1);
  off_1008D5F48 = v1;
}

void sub_10020A018(_Unwind_Exception *a1)
{
}

uint64_t sub_10020A02C(uint64_t a1, uint64_t a2, _xpc_connection_s *a3, dispatch_object_s *a4)
{
  uint64_t v5 = sub_10043E3E8(a1, a2, a3, a4);
  *(void *)uint64_t v5 = off_100887650;
  *(void *)(v5 + 144) = off_100887720;
  *(void *)(v5 + 152) = off_100887768;
  *(void *)(v5 + 160) = off_100887798;
  *(_BYTE *)(v5 + 16std::iostream::~basic_iostream(v2, v3 + 8) = 0;
  *(void *)(v5 + 176) = 0LL;
  uint64_t v6 = v5 + 216;
  *(void *)(v5 + ++*(_DWORD *)(result + 184) = 0LL;
  *(_WORD *)(v5 + 192) = 0;
  *(void *)(v5 + 204) = 0LL;
  *(void *)(v5 + 196) = 0LL;
  *(_BYTE *)(v5 + 212) = 0;
  sub_100242DC4(v5 + 216);
  *(void *)(a1 + 280) = 0LL;
  v10[0] = 0LL;
  v10[1] = 0LL;
  sub_100242F28((uint64_t)v10, v6);
  uint64_t v7 = [NSMutableDictionary dictionary];
  BOOL v8 = *(void **)(a1 + 280);
  *(void *)(a1 + 280) = v7;

  sub_100242FAC((uint64_t)v10);
  return a1;
}

void sub_10020A0E4( _Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9)
{
  sub_100242E28(v11);
  sub_100032BD4(v10);
  sub_10025D70C(v9);
  _Unwind_Resume(a1);
}

uint64_t sub_10020A134(uint64_t a1)
{
  *(void *)a1 = off_100887650;
  *(void *)(a1 + 144) = off_100887720;
  *(void *)(a1 + 152) = off_100887768;
  *(void *)(a1 + 160) = off_100887798;

  sub_100242E28(a1 + 216);
  sub_100032BD4(a1 + 176);
  return sub_10025D70C(a1);
}

void sub_10020A198(uint64_t a1)
{
  uint64_t v1 = (void *)sub_10020A134(a1);
  operator delete(v1);
}

void *sub_10020A1AC(uint64_t a1, int a2)
{
  uint64_t result = sub_10020A3C0;
  switch(a2)
  {
    case 1:
      return result;
    case 2:
      uint64_t result = sub_10020A994;
      break;
    case 7:
      uint64_t result = sub_10020AB5C;
      break;
    case 8:
      uint64_t result = sub_10020B958;
      break;
    case 9:
      uint64_t result = sub_10020BA10;
      break;
    case 10:
      uint64_t result = sub_10020BF38;
      break;
    case 12:
      uint64_t result = sub_10020BC3C;
      break;
    case 13:
      uint64_t result = sub_10020BA70;
      break;
    case 25:
      uint64_t result = sub_10020CE28;
      break;
    case 26:
      uint64_t result = sub_10020D018;
      break;
    case 27:
      uint64_t result = sub_10020A9D0;
      break;
    case 28:
      uint64_t result = sub_10020ADE8;
      break;
    case 29:
      uint64_t result = sub_10020AEB0;
      break;
    case 30:
      uint64_t result = sub_10020B574;
      break;
    case 31:
      uint64_t result = sub_10020D1BC;
      break;
    case 32:
      uint64_t result = sub_10020D824;
      break;
    case 33:
      uint64_t result = sub_10020DC7C;
      break;
    case 34:
      uint64_t result = sub_10020B818;
      break;
    case 35:
      uint64_t result = sub_10020B858;
      break;
    case 36:
      uint64_t result = sub_10020B898;
      break;
    case 37:
      uint64_t result = sub_10020AF78;
      break;
    case 38:
      uint64_t result = sub_10020B094;
      break;
    case 39:
      uint64_t result = sub_10020B264;
      break;
    case 40:
      uint64_t result = sub_10020B420;
      break;
    case 41:
      uint64_t result = sub_10020C8F0;
      break;
    case 42:
      uint64_t result = sub_10020BFF0;
      break;
    case 44:
      uint64_t result = sub_10020B8D8;
      break;
    case 47:
      uint64_t result = sub_10020B918;
      break;
    case 52:
      uint64_t result = sub_10020B6F4;
      break;
    case 53:
      uint64_t result = sub_10020DD10;
      break;
    case 54:
      uint64_t result = sub_10020DED4;
      break;
    case 55:
      uint64_t result = sub_10020E01C;
      break;
    case 58:
      uint64_t result = sub_10020E21C;
      break;
    case 59:
      uint64_t result = sub_10020E394;
      break;
    case 60:
      uint64_t result = sub_10020E4F0;
      break;
    default:
      if (os_log_type_enabled((os_log_t)qword_1008F75F0, OS_LOG_TYPE_ERROR)) {
        sub_10065E840();
      }
      uint64_t result = 0LL;
      break;
  }

  return result;
}

void sub_10020A3C0(uint64_t a1, xpc_object_t xdict)
{
  uint64_t v66 = 0LL;
  uint64_t v67 = 0LL;
  unsigned int v65 = 0LL;
  uint64_t v61 = 0LL;
  BOOL v62 = &v61;
  uint64_t v63 = 0x2020000000LL;
  int v64 = 0;
  v59[0] = 0LL;
  v59[1] = v59;
  v59[2] = 0x2020000000LL;
  char v60 = 0;
  xpc_object_t value = xpc_dictionary_get_value(xdict, "kCBMsgArgs");
  id v4 = sub_10025E1C8(value, "kCBMsgArgName");
  id v5 = v4;
  if (!sub_10025D848(value, 1, v6, v7, v8, v9, v10, v11, (uint64_t)"kCBMsgArgType") && v5)
  {
    int v12 = v67;
    uint64_t v57 = 0LL;
    uint64_t v58 = 0LL;
    uint64_t v55 = 0LL;
    uint64_t v56 = 0LL;
    uint64_t v53 = 0LL;
    uint64_t v54 = 1LL;
    id v13 = sub_10025E1C8(v65, "kCBInitOptionRestoreIdentifier");
    uint64_t v14 = objc_claimAutoreleasedReturnValue(v13);
    sub_10025D848(v65, 0, v15, v16, v17, v18, v19, v20, (uint64_t)"kCBInitOptionShowPowerAlert");
    int v21 = sub_10025E2E0(v65, "kCBManagerPrivacySupported");
    memset(v52, 0, sizeof(v52));
    xpc_connection_get_audit_token(*(void *)(a1 + 16), v52);
    id v22 = sub_10025D564(*(void *)(a1 + 16));
    uint64_t v23 = objc_claimAutoreleasedReturnValue(v22);
    CFDataRef v24 = *(void **)(a1 + 96);
    *(void *)(a1 + 96) = v23;

    id v25 = *(id *)(a1 + 96);
    int v26 = (os_log_s *)qword_1008F75F0;
    if (os_log_type_enabled((os_log_t)qword_1008F75F0, OS_LOG_TYPE_DEFAULT))
    {
      *(_DWORD *)__int128 buf = 138412546;
      *(void *)&uint8_t buf[4] = v25;
      *(_WORD *)&_BYTE buf[12] = 1024;
      *(_DWORD *)&_BYTE buf[14] = v21;
      _os_log_impl( (void *)&_mh_execute_header,  v26,  OS_LOG_TYPE_DEFAULT,  "Classic kCBManagerAppSDKVersion for app %@ : %d",  buf,  0x12u);
    }

    uint64_t v76 = 0LL;
    __int128 v74 = 0u;
    memset(v75, 0, sizeof(v75));
    __int128 v72 = 0u;
    __int128 v73 = 0u;
    __int128 v70 = 0u;
    __int128 v71 = 0u;
    memset(buf, 0, sizeof(buf));
    sub_10020E564((uint64_t)buf);
    id v5 = v25;
    CFNumberRef v27 = (const char *)[v5 UTF8String];
    size_t v28 = strlen(v27);
    CFBooleanRef v29 = sub_1001FD17C(buf, (uint64_t)v27, v28);
    CFNumberRef v30 = sub_1001FD17C(v29, (uint64_t)"-classic-", 9LL);
    uint64_t v31 = (void *)std::ostream::operator<<(v30, *(unsigned int *)(a1 + 40));
    BOOL v32 = sub_1001FD17C(v31, (uint64_t)"-", 1LL);
    std::ostream::operator<<(v32, *(void *)(a1 + 8));
    std::stringbuf::str(&v68, (const std::stringbuf *)&buf[8]);
    __int16 v33 = (void *)v14;
    int v34 = (void **)(a1 + 56);
    *(_OWORD *)int v34 = *(_OWORD *)&v68.__r_.__value_.__l.__data_;
    *(void *)(a1 + 72) = v68.__r_.__value_.__l.__cap_;
    int v35 = (os_log_s *)qword_1008F75F0;
    if (os_log_type_enabled((os_log_t)qword_1008F75F0, OS_LOG_TYPE_DEFAULT))
    {
      char v36 = (void *)(a1 + 56);
      LODWORD(v68.__r_.__value_.__l.__data_) = 136446210;
      *(std::string::size_type *)((char *)v68.__r_.__value_.__r.__words + 4) = (std::string::size_type)v36;
      _os_log_impl( (void *)&_mh_execute_header,  v35,  OS_LOG_TYPE_DEFAULT,  "Classic Received XPC check-in from session %{public}s",  (uint8_t *)&v68,  0xCu);
    }

    uint64_t v37 = v33;
    if (*(void *)(a1 + 128))
    {
      __int16 v38 = (os_log_s *)qword_1008F75F0;
      if (os_log_type_enabled((os_log_t)qword_1008F75F0, OS_LOG_TYPE_ERROR)) {
        sub_10065E924((char *)(a1 + 79), (void *)(a1 + 56), v38);
      }
    }

    else
    {
      int v39 = v66;
      if (v66 == 20161219)
      {
        uint64_t v40 = sub_100404FE8();
        v43[0] = _NSConcreteStackBlock;
        v43[1] = 3221225472LL;
        v43[2] = sub_10020E650;
        v43[3] = &unk_1008877C8;
        __int16 v51 = 0;
        uint64_t v48 = a1;
        uint64_t v49 = v58;
        id v44 = v5;
        int v50 = v12;
        id v45 = v33;
        uint64_t v46 = &v61;
        uint64_t v47 = v59;
        sub_1004054B4(v40, v43);
      }

      else
      {
        uint64_t v41 = (os_log_s *)qword_1008F75F0;
        if (os_log_type_enabled((os_log_t)qword_1008F75F0, OS_LOG_TYPE_ERROR)) {
          sub_10065E8A0(v39, v41);
        }
      }
    }

    if (SHIBYTE(v73) < 0) {
      operator delete(*((void **)&v72 + 1));
    }
    std::streambuf::~streambuf(&buf[8]);
    std::ios::~ios(v75);
  }

  uint64_t v42 = *(void *)(a1 + 128);
  if (v42) {
    (*(void (**)(uint64_t, uint64_t, void))(*(void *)a1 + 64LL))(a1, v42, *((unsigned int *)v62 + 6));
  }
  else {
    sub_10043F468(a1, 2u);
  }

  _Block_object_dispose(v59, 8);
  _Block_object_dispose(&v61, 8);
}

void sub_10020A8FC( _Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20, uint64_t a21, uint64_t a22, uint64_t a23, uint64_t a24, uint64_t a25, uint64_t a26, uint64_t a27, uint64_t a28, void *a29, uint64_t a30, uint64_t a31, uint64_t a32, uint64_t a33, void *a34, void *a35, uint64_t a36, uint64_t a37, uint64_t a38, uint64_t a39, uint64_t a40, uint64_t a41, uint64_t a42, uint64_t a43, uint64_t a44, uint64_t a45, uint64_t a46, uint64_t a47, uint64_t a48, uint64_t a49, uint64_t a50,uint64_t a51,char a52,uint64_t a53,uint64_t a54,uint64_t a55,char a56,uint64_t a57,uint64_t a58,uint64_t a59,uint64_t a60,uint64_t a61,uint64_t a62,uint64_t a63)
{
  sub_10020E784((uint64_t)&a67);
  _Block_object_dispose(&a52, 8);
  _Block_object_dispose(&a56, 8);
  _Unwind_Resume(a1);
}

void sub_10020A994(uint64_t a1)
{
}

void sub_10020A9D0(int a1, xpc_object_t xdict)
{
  xpc_object_t value = xpc_dictionary_get_value(xdict, "kCBMsgArgs");
  int v3 = sub_10025E2E0(value, "kCBMsgArgBTPowerState");
  if ((+[CBController bluetoothModificationAllowed]( &OBJC_CLASS___CBController,  "bluetoothModificationAllowed") & 1) != 0)
  {
    if (v3)
    {
      if (qword_1008D6788 != -1) {
        dispatch_once(&qword_1008D6788, &stru_100887AA0);
      }
      sub_10040D3E4((uint64_t)off_1008D6780);
    }

    else
    {
      if (qword_1008D6788 != -1) {
        dispatch_once(&qword_1008D6788, &stru_100887AA0);
      }
      sub_10040D774((uint64_t)off_1008D6780);
    }
  }

  else
  {
    id v4 = (os_log_s *)qword_1008F75F0;
    if (os_log_type_enabled((os_log_t)qword_1008F75F0, OS_LOG_TYPE_DEFAULT))
    {
      id v5 = "on";
      if (v3) {
        id v5 = "off";
      }
      int v6 = 136315138;
      uint64_t v7 = v5;
      _os_log_impl( (void *)&_mh_execute_header,  v4,  OS_LOG_TYPE_DEFAULT,  "Bluetooth Toggling is turned off by managing client,keeping the power state to %s",  (uint8_t *)&v6,  0xCu);
    }
  }

void sub_10020AB5C(uint64_t a1, xpc_object_t original)
{
  xpc_object_t reply = xpc_dictionary_create_reply(original);
  if (reply)
  {
    id v4 = reply;
    __int16 v13 = 0;
    int v12 = 0;
    if (qword_1008D60B0 != -1) {
      dispatch_once(&qword_1008D60B0, &stru_100887A40);
    }
    sub_100431644((uint64_t)off_1008D60A8, (uint64_t)&v12);
    sub_1003FE1B4((unsigned __int8 *)&v12, &__p);
    if ((__p.__r_.__value_.__s.__size_ & 0x80u) == 0) {
      p_p = &__p;
    }
    else {
      p_p = (std::string *)__p.__r_.__value_.__r.__words[0];
    }
    xpc_dictionary_set_string(v4, "kCBMsgArgAddressString", (const char *)p_p);
    if (qword_1008D6788 != -1) {
      dispatch_once(&qword_1008D6788, &stru_100887AA0);
    }
    unsigned int v6 = sub_1002075B4((uint64_t)off_1008D6780);
    xpc_dictionary_set_int64(v4, "kCBMsgArgBTPowerState", v6);
    memset(&__p, 0, sizeof(__p));
    if (qword_1008D60B0 != -1) {
      dispatch_once(&qword_1008D60B0, &stru_100887A40);
    }
    sub_10043170C((uint64_t)off_1008D60A8, &__p);
    if ((__p.__r_.__value_.__s.__size_ & 0x80u) == 0) {
      uint64_t v7 = &__p;
    }
    else {
      uint64_t v7 = (std::string *)__p.__r_.__value_.__r.__words[0];
    }
    xpc_dictionary_set_string(v4, "kCBMsgArgName", (const char *)v7);
    if (qword_1008D5F00 != -1) {
      dispatch_once(&qword_1008D5F00, &stru_100887AC0);
    }
    char v8 = sub_10040B104();
    xpc_dictionary_set_BOOL(v4, "kCBMsgArgInquiryState", v8);
    BOOL value = 0;
    if (qword_1008D60B0 != -1) {
      dispatch_once(&qword_1008D60B0, &stru_100887A40);
    }
    sub_100432384((uint64_t)off_1008D60A8, &value);
    BOOL v9 = 0;
    if (qword_1008D60B0 != -1) {
      dispatch_once(&qword_1008D60B0, &stru_100887A40);
    }
    sub_100433078((uint64_t)off_1008D60A8, &v9);
    xpc_dictionary_set_BOOL(v4, "kCBMsgArgDiscoverableState", value);
    xpc_dictionary_set_BOOL(v4, "kCBMsgArgConnectableState", v9);
    xpc_connection_send_message(*(xpc_connection_t *)(a1 + 16), v4);
    xpc_release(v4);
  }

void sub_10020ADC0( _Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, void *__p, uint64_t a12, int a13, __int16 a14, char a15, char a16)
{
  if (a16 < 0) {
    operator delete(__p);
  }
  _Unwind_Resume(exception_object);
}

uint64_t sub_10020ADE8(uint64_t a1, xpc_object_t xdict)
{
  xpc_object_t value = xpc_dictionary_get_value(xdict, "kCBMsgArgs");
  int v4 = sub_10025E2E0(value, "kCBMsgArgConnectableState");
  if (qword_1008D5F00 != -1) {
    dispatch_once(&qword_1008D5F00, &stru_100887AC0);
  }
  id v5 = off_1008D5EF8;
  unint64_t v6 = sub_100494CF8(*(void *)(a1 + 128));
  unint64_t v7 = sub_1004065D4(v5, v6);
  if (qword_1008D5F00 != -1) {
    dispatch_once(&qword_1008D5F00, &stru_100887AC0);
  }
  return sub_100406DD8(off_1008D5EF8, v7, v4);
}

uint64_t sub_10020AEB0(uint64_t a1, xpc_object_t xdict)
{
  xpc_object_t value = xpc_dictionary_get_value(xdict, "kCBMsgArgs");
  int v4 = sub_10025E2E0(value, "kCBMsgArgDiscoverableState");
  if (qword_1008D5F00 != -1) {
    dispatch_once(&qword_1008D5F00, &stru_100887AC0);
  }
  id v5 = off_1008D5EF8;
  unint64_t v6 = sub_100494CF8(*(void *)(a1 + 128));
  unint64_t v7 = sub_1004065D4(v5, v6);
  if (qword_1008D5F00 != -1) {
    dispatch_once(&qword_1008D5F00, &stru_100887AC0);
  }
  return sub_100407008(off_1008D5EF8, v7, v4);
}

void sub_10020AF78(uint64_t a1, void *a2)
{
  xpc_object_t v4 = xpc_array_create(0LL, 0LL);
  xpc_object_t value = xpc_dictionary_get_value(a2, "kCBMsgArgs");
  id v6 = sub_10025E254(value, "kCBMsgArgConnectionState");
  unint64_t v7 = (void *)objc_claimAutoreleasedReturnValue(v6);
  char v8 = v7;
  if (v7) {
    unsigned __int8 v9 = [v7 BOOLValue];
  }
  else {
    unsigned __int8 v9 = 0;
  }
  uint64_t v10 = sub_100404FE8();
  v13[0] = _NSConcreteStackBlock;
  v13[1] = 3221225472LL;
  _DWORD v13[2] = sub_10020EAB8;
  _OWORD v13[3] = &unk_100886EE0;
  unsigned __int8 v14 = v9;
  v13[4] = a1;
  v13[5] = v4;
  sub_1004054B4(v10, v13);
  xpc_object_t reply = xpc_dictionary_create_reply(a2);
  int v12 = reply;
  if (reply)
  {
    xpc_dictionary_set_value(reply, "kCBMsgArgDevices", v4);
    xpc_connection_send_message(*(xpc_connection_t *)(a1 + 16), v12);
    xpc_release(v12);
  }

  xpc_release(v4);
}

void sub_10020B080(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_10020B094(uint64_t a1, xpc_object_t xdict)
{
  xpc_object_t value = xpc_dictionary_get_value(xdict, "kCBMsgArgs");
  id v5 = sub_10025E1C8(value, "kCBMsgArgAddressString");
  id v6 = (void *)objc_claimAutoreleasedReturnValue(v5);
  unint64_t v7 = sub_1005C02B0(v6);
  if ((v7 & 0xFFFFFFFFFFFFLL) != 0)
  {
    __int128 v14 = 0uLL;
    if (qword_1008D5F30 != -1) {
      dispatch_once(&qword_1008D5F30, &stru_100887B00);
    }
    sub_1005C8684((uint64_t)off_1008D5F28, v7, 1u, 0, 0LL, 0LL, (unsigned __int8 *)&v14);
    char v8 = sub_100241F94((const unsigned __int8 *)&v14);
    unsigned __int8 v9 = (void *)objc_claimAutoreleasedReturnValue(v8);
    xpc_object_t v10 = sub_10020ECA0(v9);
  }

  else
  {
    uint64_t v11 = (os_log_s *)qword_1008F75F0;
    if (os_log_type_enabled((os_log_t)qword_1008F75F0, OS_LOG_TYPE_DEFAULT))
    {
      LODWORD(v14) = 138412290;
      *(void *)((char *)&v14 + 4) = v6;
      _os_log_impl( (void *)&_mh_execute_header,  v11,  OS_LOG_TYPE_DEFAULT,  "Warning: Invalid parameters, cannot retrieve a peer with address %@",  (uint8_t *)&v14,  0xCu);
    }

    xpc_object_t v10 = 0LL;
  }

  xpc_object_t reply = xpc_dictionary_create_reply(xdict);
  __int16 v13 = reply;
  if (reply)
  {
    xpc_dictionary_set_value(reply, "kCBMsgArgDevices", v10);
    xpc_connection_send_message(*(xpc_connection_t *)(a1 + 16), v13);
    xpc_release(v13);
  }

  if (v10) {
    xpc_release(v10);
  }
}

void sub_10020B238(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_10020B264(uint64_t a1, xpc_object_t xdict)
{
  uint64_t v25 = 0LL;
  xpc_object_t value = xpc_dictionary_get_value(xdict, "kCBMsgArgs");
  id v5 = sub_10025E0F0(value, "kCBMsgArgDeviceUUID");
  id v6 = (void *)objc_claimAutoreleasedReturnValue(v5);
  int v13 = sub_10025D848(value, 1, v7, v8, v9, v10, v11, v12, (uint64_t)"kCBMsgArgOptions");
  char v14 = sub_10025E2E0(0LL, "kCBMsgIdSessionPairingRequest");
  uint64_t v15 = sub_10025E2E0(0LL, "kCBMsgArgConnectToPAN");
  if (v13 || !v6)
  {
    sub_10043F3F4(a1, 49LL, xdict, 3);
  }

  else
  {
    uint64_t v16 = v15;
    uint64_t v17 = (void *)objc_claimAutoreleasedReturnValue( +[ConnectOptions alertOptionsWithConnectionAlerts:disconnectionAlerts:notificationAlerts:delay:bridgeTransport:]( &OBJC_CLASS___ConnectOptions,  "alertOptionsWithConnectionAlerts:disconnectionAlerts:notificationAlerts:delay:bridgeTransport:",  0LL,  0LL,  0LL,  0LL,  0LL));
    [v17 setConnectingToPANServices:v16];
    uint64_t v18 = sub_100404FE8();
    v20[0] = _NSConcreteStackBlock;
    v20[1] = 3221225472LL;
    void v20[2] = sub_10020F1C8;
    v20[3] = &unk_100881038;
    uint64_t v23 = a1;
    id v21 = v6;
    id v19 = v17;
    id v22 = v19;
    char v24 = v14;
    sub_1004054B4(v18, v20);
  }
}

void sub_10020B3E0( _Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, void *a18, void *a19)
{
  _Unwind_Resume(a1);
}

void sub_10020B420(uint64_t a1, xpc_object_t xdict)
{
  uint64_t v25 = 0LL;
  xpc_object_t value = xpc_dictionary_get_value(xdict, "kCBMsgArgs");
  id v5 = sub_10025E0F0(value, "kCBMsgArgDeviceUUID");
  id v6 = (void *)objc_claimAutoreleasedReturnValue(v5);
  char v24 = 0LL;
  if (sub_10025D848(value, 1, v7, v8, v9, v10, v11, v12, (uint64_t)"kCBMsgArgOptions") || !v6)
  {
    sub_10043F3F4(a1, 50LL, xdict, 3);
  }

  else if (!sub_10025D848(v24, 0, v13, v14, v15, v16, v17, v18, (uint64_t)"kCBCancelConnectOptionForce"))
  {
    uint64_t v19 = sub_100404FE8();
    v20[0] = _NSConcreteStackBlock;
    v20[1] = 3221225472LL;
    void v20[2] = sub_10020F318;
    v20[3] = &unk_10087FBF0;
    uint64_t v22 = a1;
    id v21 = v6;
    uint64_t v23 = v25;
    sub_1004054B4(v19, v20);
  }
}

void sub_10020B554( _Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, void *a18)
{
  _Unwind_Resume(a1);
}

void sub_10020B574(uint64_t a1, xpc_object_t xdict)
{
  xpc_object_t value = xpc_dictionary_get_value(xdict, "kCBMsgArgs");
  if (value)
  {
    xpc_object_t v4 = value;
    int v5 = sub_10025E2E0(value, "kCBMsgArgInquiryInfinite");
    int v6 = sub_10025E2E0(v4, "kCBMsgArgInquiryReportDuplicates");
    id v7 = sub_10025E254(v4, "kCBMsgArgInquiryLength");
    uint64_t v8 = (void *)objc_claimAutoreleasedReturnValue(v7);
    unsigned int v9 = [v8 intValue];

    uint64_t v10 = (os_log_s *)qword_1008F75F0;
    if (os_log_type_enabled((os_log_t)qword_1008F75F0, OS_LOG_TYPE_DEFAULT))
    {
      v12[0] = 67109632;
      v12[1] = v5;
      __int16 v13 = 1024;
      int v14 = v6;
      __int16 v15 = 1024;
      unsigned int v16 = v9;
      _os_log_impl( (void *)&_mh_execute_header,  v10,  OS_LOG_TYPE_DEFAULT,  "Bluetooth discovery Handle Inquiry Msg: continuous=%d, reportDuplicates=%d , length=%d",  (uint8_t *)v12,  0x14u);
    }

    sub_10020F888(a1, v5, v11, 0LL, 0, v6);
  }

  else if (os_log_type_enabled((os_log_t)qword_1008F75F0, OS_LOG_TYPE_ERROR))
  {
    sub_10065E99C();
  }

void sub_10020B6DC(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_10020B6F4(uint64_t a1)
{
  if (qword_1008D63D8 != -1) {
    dispatch_once(&qword_1008D63D8, &stru_100887B60);
  }
  uint64_t v2 = off_1008D63D0;
  int v3 = *(std::__shared_weak_count **)(a1 + 184);
  uint64_t v11 = *(void *)(a1 + 176);
  uint64_t v12 = v3;
  if (v3)
  {
    p_shared_owners = (unint64_t *)&v3->__shared_owners_;
    do
      unint64_t v5 = __ldxr(p_shared_owners);
    while (__stxr(v5 + 1, p_shared_owners));
  }

  sub_1004530CC(v2, &v11);
  int v6 = v12;
  if (v12)
  {
    id v7 = (unint64_t *)&v12->__shared_owners_;
    do
      unint64_t v8 = __ldaxr(v7);
    while (__stlxr(v8 - 1, v7));
    if (!v8)
    {
      ((void (*)(std::__shared_weak_count *))v6->__on_zero_shared)(v6);
      std::__shared_weak_count::__release_weak(v6);
    }
  }

  *(_WORD *)(a1 + 192) = 0;
  if (*(_BYTE *)(a1 + 212))
  {
    unsigned int v9 = (os_log_s *)qword_1008F75F0;
    if (os_log_type_enabled((os_log_t)qword_1008F75F0, OS_LOG_TYPE_DEFAULT))
    {
      v10[0] = 0;
      _os_log_impl( (void *)&_mh_execute_header,  v9,  OS_LOG_TYPE_DEFAULT,  "startInquiry: Disabling duplicate reporting.",  (uint8_t *)v10,  2u);
    }

    sub_10044F750(*(void *)(a1 + 176));
    *(_BYTE *)(a1 + 212) = 0;
  }

void sub_10020B804(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, ...)
{
}

void sub_10020B818()
{
  uint64_t v0 = (os_log_s *)qword_1008F75F0;
  if (os_log_type_enabled((os_log_t)qword_1008F75F0, OS_LOG_TYPE_ERROR)) {
    sub_10065E9C8(v0, v1, v2, v3, v4, v5, v6, v7);
  }
}

void sub_10020B858()
{
  uint64_t v0 = (os_log_s *)qword_1008F75F0;
  if (os_log_type_enabled((os_log_t)qword_1008F75F0, OS_LOG_TYPE_ERROR)) {
    sub_10065EA38(v0, v1, v2, v3, v4, v5, v6, v7);
  }
}

void sub_10020B898()
{
  uint64_t v0 = (os_log_s *)qword_1008F75F0;
  if (os_log_type_enabled((os_log_t)qword_1008F75F0, OS_LOG_TYPE_ERROR)) {
    sub_10065EAA8(v0, v1, v2, v3, v4, v5, v6, v7);
  }
}

void sub_10020B8D8()
{
  uint64_t v0 = (os_log_s *)qword_1008F75F0;
  if (os_log_type_enabled((os_log_t)qword_1008F75F0, OS_LOG_TYPE_ERROR)) {
    sub_10065EB18(v0, v1, v2, v3, v4, v5, v6, v7);
  }
}

void sub_10020B918()
{
  uint64_t v0 = (os_log_s *)qword_1008F75F0;
  if (os_log_type_enabled((os_log_t)qword_1008F75F0, OS_LOG_TYPE_ERROR)) {
    sub_10065EB88(v0, v1, v2, v3, v4, v5, v6, v7);
  }
}

void sub_10020B958(uint64_t a1, xpc_object_t xdict)
{
  uint64_t v14 = 0LL;
  xpc_object_t value = xpc_dictionary_get_value(xdict, "kCBMsgArgs");
  if (!sub_10025D848(value, 0, v4, v5, v6, v7, v8, v9, (uint64_t)"kCBMsgArgProgrammaticPairing"))
  {
    BOOL v10 = v14 != 0;
    uint64_t v11 = sub_100404FE8();
    v12[0] = _NSConcreteStackBlock;
    v12[1] = 3221225472LL;
    _DWORD v12[2] = sub_100210684;
    v12[3] = &unk_1008800D8;
    v12[4] = a1;
    BOOL v13 = v10;
    sub_1004054B4(v11, v12);
    *(_BYTE *)(a1 + 16std::iostream::~basic_iostream(v2, v3 + 8) = 1;
  }

void sub_10020BA10(uint64_t a1)
{
  uint64_t v2 = sub_100404FE8();
  v3[0] = _NSConcreteStackBlock;
  v3[1] = 3221225472LL;
  _DWORD v3[2] = sub_10021077C;
  v3[3] = &unk_10087EB20;
  v3[4] = a1;
  sub_1004054B4(v2, v3);
}

void sub_10020BA70(uint64_t a1, xpc_object_t xdict)
{
  xpc_object_t value = xpc_dictionary_get_value(xdict, "kCBMsgArgs");
  uint64_t v4 = sub_10025E0F0(value, "kCBMsgArgDeviceUUID");
  uint64_t v5 = (void *)objc_claimAutoreleasedReturnValue(v4);
  if (v5)
  {
    uint64_t v6 = (os_log_s *)qword_1008F75F0;
    if (os_log_type_enabled((os_log_t)qword_1008F75F0, OS_LOG_TYPE_DEFAULT))
    {
      uint64_t v7 = (void *)(a1 + 56);
      int v10 = 136446466;
      uint64_t v11 = v7;
      __int16 v12 = 2112;
      BOOL v13 = v5;
      _os_log_impl( (void *)&_mh_execute_header,  v6,  OS_LOG_TYPE_DEFAULT,  "Session %{public}s is asking to unpair device %@",  (uint8_t *)&v10,  0x16u);
    }

    if (qword_1008D5F30 != -1) {
      dispatch_once(&qword_1008D5F30, &stru_100887B00);
    }
    uint64_t v8 = sub_1005CC198((uint64_t)off_1008D5F28, v5, 0);
    if (qword_1008D5F50 != -1) {
      dispatch_once(&qword_1008D5F50, &stru_100887B20);
    }
    uint64_t v9 = (unsigned __int8 *)sub_10040007C(off_1008D5F48, v8, 0);
    if (v9)
    {
      if (qword_1008D67A8 != -1) {
        dispatch_once(&qword_1008D67A8, &stru_100887AE0);
      }
      sub_10052F37C((uint64_t)off_1008D67A0, v9);
    }
  }
}

void sub_10020BC20(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_10020BC3C(int a1, xpc_object_t xdict)
{
  xpc_object_t value = xpc_dictionary_get_value(xdict, "kCBMsgArgs");
  uint64_t v4 = sub_10025E0F0(value, "kCBMsgArgDeviceUUID");
  uint64_t v5 = (void *)objc_claimAutoreleasedReturnValue(v4);
  xpc_object_t v6 = xpc_dictionary_get_value(xdict, "kCBMsgArgs");
  if (!sub_10025D848(v6, 1, v7, v8, v9, v10, v11, v12, (uint64_t)"kCBMsgArgPairingType") && v5)
  {
    if (qword_1008D5F30 != -1) {
      dispatch_once(&qword_1008D5F30, &stru_100887B00);
    }
    uint64_t v13 = sub_1005CC198((uint64_t)off_1008D5F28, v5, 0);
    if (qword_1008D5F50 != -1) {
      dispatch_once(&qword_1008D5F50, &stru_100887B20);
    }
    uint64_t v14 = sub_10040007C(off_1008D5F48, v13, 0);
    if (v14)
    {
      __int16 v15 = (os_log_s *)qword_1008F75F0;
      if (os_log_type_enabled((os_log_t)qword_1008F75F0, OS_LOG_TYPE_DEFAULT))
      {
        *(_DWORD *)__int128 buf = 134218242;
        uint64_t v17 = 0LL;
        __int16 v18 = 2112;
        uint64_t v19 = v5;
        _os_log_impl( (void *)&_mh_execute_header,  v15,  OS_LOG_TYPE_DEFAULT,  "handlePairingAgentRespondToPairing: Accepting Pairing Request with Passkey %llu for the device %@",  buf,  0x16u);
      }

      if (qword_1008D67A8 != -1) {
        dispatch_once(&qword_1008D67A8, &stru_100887AE0);
      }
      sub_10052E160((uint64_t)off_1008D67A0, (uint64_t)v14, 0);
    }

    else if (os_log_type_enabled((os_log_t)qword_1008F75F0, OS_LOG_TYPE_ERROR))
    {
      sub_10065EC24();
    }
  }
}

void sub_10020BF18(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_10020BF38(uint64_t a1, void *a2)
{
  xpc_object_t v4 = xpc_array_create(0LL, 0LL);
  uint64_t v5 = sub_100404FE8();
  v8[0] = _NSConcreteStackBlock;
  v8[1] = 3221225472LL;
  void v8[2] = sub_100210864;
  v8[3] = &unk_10087F8E0;
  v8[4] = a1;
  v8[5] = v4;
  sub_1004054B4(v5, v8);
  xpc_object_t reply = xpc_dictionary_create_reply(a2);
  if (reply)
  {
    uint64_t v7 = reply;
    xpc_dictionary_set_value(reply, "kCBMsgArgDevices", v4);
    xpc_connection_send_message(*(xpc_connection_t *)(a1 + 16), v7);
    xpc_release(v7);
  }

  xpc_release(v4);
}

void sub_10020BFF0(int a1, xpc_object_t xdict)
{
  xpc_object_t value = xpc_dictionary_get_value(xdict, "kCBMsgArgs");
  if (value)
  {
    uint64_t v3 = value;
    xpc_object_t v4 = sub_10025E0F0(value, "kCBMsgArgDeviceUUID");
    uint64_t v5 = (void *)objc_claimAutoreleasedReturnValue(v4);
    if (v5)
    {
      if (qword_1008D5F30 != -1) {
        dispatch_once(&qword_1008D5F30, &stru_100887B00);
      }
      uint64_t v6 = sub_1005CC198((uint64_t)off_1008D5F28, v5, 0);
      if (qword_1008D5F50 != -1) {
        dispatch_once(&qword_1008D5F50, &stru_100887B20);
      }
      uint64_t v7 = sub_10040007C(off_1008D5F48, v6, 0);
      if (v7)
      {
        id v8 = sub_10025E1C8(v3, "kCBMsgArgName");
        uint64_t v9 = (void *)objc_claimAutoreleasedReturnValue(v8);
        __int16 v38 = v9;
        if (v9)
        {
          sub_10002418C(&__p, (char *)[v9 UTF8String]);
          sub_1003D17B0((uint64_t)v7, &__p, 1);
        }

        id v10 = sub_10025E254(v3, "kCBMsgArgSmartRoutingEnabled");
        uint64_t v11 = (void *)objc_claimAutoreleasedReturnValue(v10);
        uint64_t v37 = v11;
        if (v11) {
          sub_1003DD65C((uint64_t)v7, (uint64_t)objc_msgSend(v11, "charValue", v11, v38));
        }
        sub_1003DD9C4((uint64_t)v7);
        id v12 = sub_10025E254(v3, "kCBMsgArgInEarDetectionEnabled");
        uint64_t v46 = (void *)objc_claimAutoreleasedReturnValue(v12);
        if (v46)
        {
          if (qword_1008D5F40 != -1) {
            dispatch_once(&qword_1008D5F40, &stru_100887BA0);
          }
          sub_1003B3534((uint64_t)off_1008D5F38, (uint64_t)v7, (int)[v46 BOOLValue:v37]);
        }

        id v13 = sub_10025E254(v3, "kCBMsgArgMicMode");
        id v45 = (void *)objc_claimAutoreleasedReturnValue(v13);
        if (v45)
        {
          if (qword_1008D5F40 != -1) {
            dispatch_once(&qword_1008D5F40, &stru_100887BA0);
          }
          sub_1003B2740((uint64_t)off_1008D5F38, (uint64_t)v7, (uint64_t)[v45 unsignedIntValue]);
        }

        id v14 = sub_10025E254(v3, "kCBMsgArgDoubleTapAction");
        id v44 = v14;
        if (v44)
        {
          if (qword_1008D5F40 != -1) {
            dispatch_once(&qword_1008D5F40, &stru_100887BA0);
          }
          sub_1003B279C((uint64_t)off_1008D5F38, (uint64_t)v7, (uint64_t)[v44 unsignedIntValue]);
        }

        id v15 = sub_10025E254(v3, "kCBMsgArgDoubleTapActionEx");
        uint64_t v43 = (void *)objc_claimAutoreleasedReturnValue(v15);
        if (v43)
        {
          unsigned __int16 v16 = (unsigned __int16)[v43 unsignedIntValue];
          unsigned int v17 = HIBYTE(v16);
          unsigned int v18 = v16;
          if (qword_1008D5F40 != -1) {
            dispatch_once(&qword_1008D5F40, &stru_100887BA0);
          }
          sub_1003B27F4((uint64_t)off_1008D5F38, (uint64_t)v7, v17, v18);
        }

        id v19 = sub_10025E254(v3, "kCBMsgArgListeningMode");
        uint64_t v42 = (void *)objc_claimAutoreleasedReturnValue(v19);
        if (v42)
        {
          if (qword_1008D60E0 != -1) {
            dispatch_once(&qword_1008D60E0, &stru_100887BC0);
          }
          sub_100215778( (uint64_t)off_1008D60D8,  (uint64_t)v7,  13,  (uint64_t)objc_msgSend(v42, "unsignedIntValue", v37),  2u);
        }

        id v20 = sub_10025E254(v3, "kCBMsgArgListeningConfigs");
        uint64_t v41 = (void *)objc_claimAutoreleasedReturnValue(v20);
        if (v41)
        {
          if (qword_1008D60E0 != -1) {
            dispatch_once(&qword_1008D60E0, &stru_100887BC0);
          }
          sub_100215778( (uint64_t)off_1008D60D8,  (uint64_t)v7,  26,  (uint64_t)objc_msgSend(v41, "unsignedIntValue", v37),  2u);
        }

        id v21 = sub_10025E254(v3, "kCBMsgArgAutoAnswerCalls");
        uint64_t v40 = (void *)objc_claimAutoreleasedReturnValue(v21);
        if (v40)
        {
          if (qword_1008D60E0 != -1) {
            dispatch_once(&qword_1008D60E0, &stru_100887BC0);
          }
          uint64_t v22 = off_1008D60D8;
          else {
            uint64_t v23 = 2LL;
          }
          sub_100215778((uint64_t)v22, (uint64_t)v7, 30LL, v23, 2u);
        }

        id v24 = sub_10025E254(v3, "kCBMsgArgCrownRotationDirection");
        int v39 = (void *)objc_claimAutoreleasedReturnValue(v24);
        if (v39)
        {
          if (qword_1008D60E0 != -1) {
            dispatch_once(&qword_1008D60E0, &stru_100887BC0);
          }
          sub_100215778( (uint64_t)off_1008D60D8,  (uint64_t)v7,  28,  (uint64_t)objc_msgSend(v39, "unsignedCharValue", v37),  2u);
        }

        id v25 = sub_10025E254(v3, "kCBMsgArgSingleClickMode");
        int v26 = (void *)objc_claimAutoreleasedReturnValue(v25);
        if (v26)
        {
          if (qword_1008D60E0 != -1) {
            dispatch_once(&qword_1008D60E0, &stru_100887BC0);
          }
          sub_100215778( (uint64_t)off_1008D60D8,  (uint64_t)v7,  20,  (uint64_t)objc_msgSend(v26, "unsignedIntValue", v37),  2u);
        }

        id v27 = sub_10025E254(v3, "kCBMsgArgDoubleClickMode");
        size_t v28 = (void *)objc_claimAutoreleasedReturnValue(v27);
        if (v28)
        {
          if (qword_1008D60E0 != -1) {
            dispatch_once(&qword_1008D60E0, &stru_100887BC0);
          }
          sub_100215778( (uint64_t)off_1008D60D8,  (uint64_t)v7,  21,  (uint64_t)objc_msgSend(v28, "unsignedIntValue", v37),  2u);
        }

        id v29 = sub_10025E254(v3, "kCBMsgArgClickHoldMode");
        CFNumberRef v30 = (void *)objc_claimAutoreleasedReturnValue(v29);
        if (v30)
        {
          if (qword_1008D60E0 != -1) {
            dispatch_once(&qword_1008D60E0, &stru_100887BC0);
          }
          sub_100215778( (uint64_t)off_1008D60D8,  (uint64_t)v7,  22,  (uint64_t)objc_msgSend(v30, "unsignedIntValue", v37),  2u);
        }

        id v31 = sub_10025E254(v3, "kCBMsgArgDoubleClickInterval");
        BOOL v32 = (void *)objc_claimAutoreleasedReturnValue(v31);
        if (v32)
        {
          if (qword_1008D60E0 != -1) {
            dispatch_once(&qword_1008D60E0, &stru_100887BC0);
          }
          sub_100215778( (uint64_t)off_1008D60D8,  (uint64_t)v7,  23,  (uint64_t)objc_msgSend(v32, "unsignedIntValue", v37),  2u);
        }

        id v33 = sub_10025E254(v3, "kCBMsgArgClickHoldInterval");
        int v34 = (void *)objc_claimAutoreleasedReturnValue(v33);
        if (v34)
        {
          if (qword_1008D60E0 != -1) {
            dispatch_once(&qword_1008D60E0, &stru_100887BC0);
          }
          sub_100215778( (uint64_t)off_1008D60D8,  (uint64_t)v7,  24,  (uint64_t)objc_msgSend(v34, "unsignedIntValue", v37),  2u);
        }

        id v35 = sub_10025E254(v3, "kCBMsgArgOneBudANCMode");
        char v36 = (void *)objc_claimAutoreleasedReturnValue(v35);
        if (v36)
        {
          if (qword_1008D60E0 != -1) {
            dispatch_once(&qword_1008D60E0, &stru_100887BC0);
          }
          sub_100215778( (uint64_t)off_1008D60D8,  (uint64_t)v7,  27,  (uint64_t)objc_msgSend(v36, "unsignedIntValue", v37),  2u);
        }
      }

      else if (os_log_type_enabled((os_log_t)qword_1008F75F0, OS_LOG_TYPE_ERROR))
      {
        sub_10065ECB0();
      }
    }
  }

void sub_10020C790( _Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, void *a9, void *a10, void *a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, void *a16, void *a17, void *a18, void *a19, void *__p, uint64_t a21, int a22, __int16 a23, char a24, char a25)
{
}

void sub_10020C8D8()
{
}

void sub_10020C8F0(uint64_t a1, xpc_object_t xdict)
{
  xpc_object_t v4 = xpc_dictionary_get_value(xdict, "kCBMsgArgs");
  if (v4)
  {
    uint64_t v5 = sub_10025E0F0(v4, "kCBMsgArgDeviceUUID");
    uint64_t v6 = (void *)objc_claimAutoreleasedReturnValue(v5);
    if (v6)
    {
      if (qword_1008D5F30 != -1) {
        dispatch_once(&qword_1008D5F30, &stru_100887B00);
      }
      uint64_t v7 = sub_1005CC198((uint64_t)off_1008D5F28, v6, 0);
      if (!v7) {
        goto LABEL_31;
      }
      if (qword_1008D5F50 != -1) {
        dispatch_once(&qword_1008D5F50, &stru_100887B20);
      }
      id v8 = sub_10040007C(off_1008D5F48, v7, 0);
      if (v8)
      {
        xpc_object_t v9 = sub_10020ECA0(v6);
        char v10 = sub_1003DD840((uint64_t)v8);
        xpc_dictionary_set_BOOL(v9, "kCBMsgArgSmartRoutingSupported", v10);
        if (sub_1003DD840((uint64_t)v8))
        {
          unsigned int v11 = sub_1003DF988((uint64_t)v8);
          xpc_dictionary_set_int64(v9, "kCBMsgArgSmartRoutingEnabled", v11);
        }

        char v12 = sub_1003DF944((uint64_t)v8);
        xpc_dictionary_set_BOOL(v9, "kCBMsgArgInEarDetectionEnabled", v12);
        unsigned int v13 = sub_1003DF900((uint64_t)v8);
        xpc_dictionary_set_int64(v9, "kCBMsgArgMicMode", v13);
        unsigned int v14 = sub_1003DFA38((uint64_t)v8);
        xpc_dictionary_set_int64(v9, "kCBMsgArgListeningMode", v14);
        BOOL v15 = sub_1003DFD24((uint64_t)v8) == 1;
        xpc_dictionary_set_BOOL(v9, "kCBMsgArgAutoAnswerCalls", v15);
        unsigned int v16 = sub_1003DFCE0((uint64_t)v8);
        xpc_dictionary_set_int64(v9, "kCBMsgArgCrownRotationDirection", v16);
        int v37 = 0;
        sub_1003D7A08((uint64_t)v8, (uint64_t)&v37);
        int v17 = sub_1003D7EB4((unsigned int *)v8, 1);
        if (v37 <= 0) {
          int64_t v18 = v17;
        }
        else {
          int64_t v18 = v37;
        }
        xpc_dictionary_set_int64(v9, "kCBMsgArgBatteryPercent", v18);
        int v19 = sub_1003D7EB4((unsigned int *)v8, 2);
        xpc_dictionary_set_int64(v9, "kCBMsgArgBatteryPercentRight", v19);
        int v20 = sub_1003D7EB4((unsigned int *)v8, 4);
        xpc_dictionary_set_int64(v9, "kCBMsgArgBatteryPercentLeft", v20);
        int v21 = sub_1003D7EB4((unsigned int *)v8, 8);
        xpc_dictionary_set_int64(v9, "kCBMsgArgBatteryPercentCase", v21);
        int v22 = sub_1003D7EB4((unsigned int *)v8, 1);
        xpc_dictionary_set_int64(v9, "kCBMsgArgBatteryPercentSingle", v22);
        int v23 = sub_1003D7EB4((unsigned int *)v8, 16);
        xpc_dictionary_set_int64(v9, "kCBMsgArgBatteryPercentCombined", v23);
        if (sub_1003D2B2C((uint64_t)v8, 14))
        {
          xpc_dictionary_set_int64(v9, "kCBMsgArgDoubleTapCapability", 1LL);
          unsigned int v24 = sub_1003D635C((uint64_t)v8);
          id v25 = "kCBMsgArgDoubleTapActionEx";
        }

        else
        {
          xpc_dictionary_set_int64(v9, "kCBMsgArgDoubleTapCapability", 0LL);
          unsigned int v24 = sub_1003D635C((uint64_t)v8);
          id v25 = "kCBMsgArgDoubleTapAction";
        }

        xpc_dictionary_set_int64(v9, v25, v24);
        if (qword_1008D5F40 != -1) {
          dispatch_once(&qword_1008D5F40, &stru_100887BA0);
        }
        if (off_1008D5F38)
        {
          int64_t value = 0LL;
          sub_1003B3590((uint64_t)off_1008D5F38, (uint64_t)v8, (int *)&value + 1, (int *)&value);
          xpc_dictionary_set_int64(v9, "kCBMsgArgPrimaryInEarStatus", HIDWORD(value));
          xpc_dictionary_set_int64(v9, "kCBMsgArgSecondaryInEarStatus", value);
        }

        else if (os_log_type_enabled((os_log_t)qword_1008F75F0, OS_LOG_TYPE_ERROR))
        {
          sub_10065ECDC();
        }

        unsigned int v26 = sub_1003DFA7C((uint64_t)v8);
        xpc_dictionary_set_int64(v9, "kCBMsgArgListeningConfigs", v26);
        unsigned int v27 = sub_1003DFB48((uint64_t)v8);
        xpc_dictionary_set_int64(v9, "kCBMsgArgSingleClickMode", v27);
        unsigned int v28 = sub_1003DFB8C((uint64_t)v8);
        xpc_dictionary_set_int64(v9, "kCBMsgArgDoubleClickMode", v28);
        unsigned int v29 = sub_1003DFBD0((uint64_t)v8);
        xpc_dictionary_set_int64(v9, "kCBMsgArgClickHoldMode", v29);
        unsigned int v30 = sub_1003DFC14((uint64_t)v8);
        xpc_dictionary_set_int64(v9, "kCBMsgArgDoubleClickInterval", v30);
        unsigned int v31 = sub_1003DFC58((uint64_t)v8);
        xpc_dictionary_set_int64(v9, "kCBMsgArgClickHoldInterval", v31);
        unsigned int v32 = sub_1003DFC9C((uint64_t)v8);
        xpc_dictionary_set_int64(v9, "kCBMsgArgOneBudANCMode", v32);
        xpc_dictionary_set_BOOL(v9, "kCBMsgArgIsConnectedOverUSB", *((_BYTE *)v8 + 1296));
        unsigned int v33 = sub_1003E16E4((uint64_t)v8);
        xpc_dictionary_set_int64(v9, "kCBMsgArgColorID", v33);
        xpc_object_t reply = xpc_dictionary_create_reply(xdict);
        id v35 = reply;
        if (reply)
        {
          xpc_dictionary_set_value(reply, "kCBMsgArgState", v9);
          xpc_connection_send_message(*(xpc_connection_t *)(a1 + 16), v35);
          xpc_release(v35);
        }

        xpc_release(v9);
      }

      else
      {
LABEL_31:
        if (os_log_type_enabled((os_log_t)qword_1008F75F0, OS_LOG_TYPE_ERROR)) {
          sub_10065ECB0();
        }
      }
    }
  }

void sub_10020CDFC(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_10020CE28(uint64_t a1, xpc_object_t xdict)
{
  id v25 = 0LL;
  uint64_t v26 = 0LL;
  xpc_object_t value = xpc_dictionary_get_value(xdict, "kCBMsgArgs");
  xpc_object_t v4 = sub_10025E0F0(value, "kCBMsgArgDeviceUUID");
  uint64_t v5 = (void *)objc_claimAutoreleasedReturnValue(v4);
  if (!sub_10025D848(value, 1, v6, v7, v8, v9, v10, v11, (uint64_t)"kCBMsgArgPSM") && v5)
  {
    char v12 = (os_log_s *)qword_1008F75F0;
    if (os_log_type_enabled((os_log_t)qword_1008F75F0, OS_LOG_TYPE_DEFAULT))
    {
      *(_DWORD *)__int128 buf = 134217984;
      *(void *)&uint8_t buf[4] = v26;
      _os_log_impl( (void *)&_mh_execute_header,  v12,  OS_LOG_TYPE_DEFAULT,  "Classic handleOpenL2CAPChannel psm: %lld",  buf,  0xCu);
    }

    *(void *)__int128 buf = 0LL;
    if (!sub_10025D848(v25, 0, v13, v14, v15, v16, v17, v18, (uint64_t)"kCBL2CAPChannelInMTU"))
    {
      uint64_t v19 = sub_100404FE8();
      v20[0] = _NSConcreteStackBlock;
      v20[1] = 3221225472LL;
      void v20[2] = sub_100210A34;
      v20[3] = &unk_1008877F0;
      uint64_t v22 = a1;
      uint64_t v23 = v26;
      uint64_t v24 = *(void *)buf;
      id v21 = v5;
      sub_1004054B4(v19, v20);
    }
  }
}

void sub_10020CFEC( _Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20, void *a21)
{
  _Unwind_Resume(a1);
}

void sub_10020D018(uint64_t a1, xpc_object_t xdict)
{
  uint64_t v19 = 0LL;
  xpc_object_t value = xpc_dictionary_get_value(xdict, "kCBMsgArgs");
  xpc_object_t v4 = sub_10025E0F0(value, "kCBMsgArgDeviceUUID");
  uint64_t v5 = (void *)objc_claimAutoreleasedReturnValue(v4);
  int v12 = sub_10025D848(value, 1, v6, v7, v8, v9, v10, v11, (uint64_t)"kCBMsgArgPSM");
  uint64_t v13 = (os_log_s *)qword_1008F75F0;
  if (os_log_type_enabled((os_log_t)qword_1008F75F0, OS_LOG_TYPE_DEFAULT))
  {
    *(_DWORD *)__int128 buf = 134217984;
    uint64_t v21 = v19;
    _os_log_impl( (void *)&_mh_execute_header,  v13,  OS_LOG_TYPE_DEFAULT,  "Classic handleCloseL2CAPChannel psm: %lld",  buf,  0xCu);
  }

  if (!v12 && v5)
  {
    uint64_t v14 = sub_100404FE8();
    v15[0] = _NSConcreteStackBlock;
    v15[1] = 3221225472LL;
    v15[2] = sub_100210B28;
    v15[3] = &unk_10087FBF0;
    uint64_t v17 = a1;
    uint64_t v18 = v19;
    id v16 = v5;
    sub_1004054B4(v14, v15);
  }
}

void sub_10020D194( _Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, void *a17)
{
  _Unwind_Resume(a1);
}

void sub_10020D1BC(uint64_t a1, xpc_object_t xdict)
{
  xpc_object_t value = xpc_dictionary_get_value(xdict, "kCBMsgArgs");
  id v5 = sub_10025E1C8(value, "kCBMsgArgName");
  uint64_t v6 = (void *)objc_claimAutoreleasedReturnValue(v5);
  id v7 = sub_10025E150(value, "kCBMsgArgServiceUUID");
  uint64_t v8 = (void *)objc_claimAutoreleasedReturnValue(v7);
  id v9 = sub_10025E150(value, "kCBMsgArgSDPRecordData");
  uint64_t v10 = (void *)objc_claimAutoreleasedReturnValue(v9);
  uint64_t v11 = (os_log_s *)qword_1008F75F0;
  if (os_log_type_enabled((os_log_t)qword_1008F75F0, OS_LOG_TYPE_DEFAULT))
  {
    *(_DWORD *)__int128 buf = 138412802;
    *(void *)&uint8_t buf[4] = v8;
    *(_WORD *)&_BYTE buf[12] = 2112;
    *(void *)&_BYTE buf[14] = v6;
    *(_WORD *)&_BYTE buf[22] = 2112;
    v54[0] = v10;
    _os_log_impl( (void *)&_mh_execute_header,  v11,  OS_LOG_TYPE_DEFAULT,  "handleAddServiceToSDP: %@ with name: %@ record: %@ to SDP",  buf,  0x20u);
  }

  if (!v10)
  {
    if (!v8) {
      goto LABEL_24;
    }
    uint64_t v45 = 0LL;
    uint64_t v46 = &v45;
    uint64_t v47 = 0x2020000000LL;
    char v48 = 0;
    v44[0] = 0LL;
    v44[1] = 0LL;
    sub_100242F28((uint64_t)v44, a1 + 216);
    uint64_t v15 = *(void **)(a1 + 280);
    v41[0] = _NSConcreteStackBlock;
    v41[1] = 3221225472LL;
    v41[2] = sub_100212614;
    void v41[3] = &unk_100887928;
    id v16 = v8;
    id v42 = v16;
    uint64_t v43 = &v45;
    [v15 enumerateKeysAndObjectsUsingBlock:v41];
    uint64_t v17 = (os_log_s *)qword_1008F75F0;
    if (*((_BYTE *)v46 + 24))
    {
      if (os_log_type_enabled((os_log_t)qword_1008F75F0, OS_LOG_TYPE_ERROR)) {
        sub_10065ED94();
      }
      int64_t v18 = 15LL;
    }

    else
    {
      if (os_log_type_enabled((os_log_t)qword_1008F75F0, OS_LOG_TYPE_INFO))
      {
        sub_100494958(*(void *)(a1 + 128), (uint64_t)buf);
        uint64_t v19 = buf[23] >= 0 ? buf : *(_BYTE **)buf;
        *(_DWORD *)uint64_t v49 = 138412546;
        *(void *)&v49[4] = v16;
        __int16 v50 = 2082;
        __int16 v51 = v19;
        _os_log_impl( (void *)&_mh_execute_header,  v17,  OS_LOG_TYPE_INFO,  "Adding service %@ for session %{public}s",  v49,  0x16u);
        if ((buf[23] & 0x80000000) != 0) {
          operator delete(*(void **)buf);
        }
      }

      unsigned __int16 v40 = 0;
      char v39 = 0;
      sub_100242CA4(&v39);
      int v20 = sub_10017A9E8(&v40);
      sub_100242CD0(&v39);
      uint64_t v21 = (os_log_s *)qword_1008F75F0;
      if (v20)
      {
        if (os_log_type_enabled((os_log_t)qword_1008F75F0, OS_LOG_TYPE_ERROR)) {
          sub_10065ED34();
        }
        int64_t v18 = 4LL;
      }

      else
      {
        BOOL v24 = os_log_type_enabled((os_log_t)qword_1008F75F0, OS_LOG_TYPE_DEFAULT);
        if (v24)
        {
          *(_DWORD *)__int128 buf = 67109378;
          *(_DWORD *)&uint8_t buf[4] = v40;
          *(_WORD *)&uint8_t buf[8] = 2112;
          *(void *)&buf[10] = v16;
          _os_log_impl( (void *)&_mh_execute_header,  v21,  OS_LOG_TYPE_DEFAULT,  "psm: 0x%x assigned to service: %@",  buf,  0x12u);
        }

        uint64_t v26 = sub_1002117CC(v24, v25, v16, v40);
        unsigned int v27 = (os_log_s *)qword_1008F75F0;
        if ((_DWORD)v26)
        {
          if (os_log_type_enabled((os_log_t)qword_1008F75F0, OS_LOG_TYPE_DEFAULT))
          {
            int v28 = v40;
            sub_100494958(*(void *)(a1 + 128), (uint64_t)v49);
            unsigned int v29 = v49;
            if (v52 < 0) {
              unsigned int v29 = *(_BYTE **)v49;
            }
            *(_DWORD *)__int128 buf = 138413058;
            *(void *)&uint8_t buf[4] = v16;
            *(_WORD *)&_BYTE buf[12] = 1024;
            *(_DWORD *)&_BYTE buf[14] = v28;
            *(_WORD *)&buf[18] = 1024;
            *(_DWORD *)&buf[20] = v26;
            LOWORD(v54[0]) = 2082;
            *(void *)((char *)v54 + 2) = v29;
            _os_log_impl( (void *)&_mh_execute_header,  v27,  OS_LOG_TYPE_DEFAULT,  "Successfully added service uuid %@ with psm: 0x%x, srh: 0x%X for session %{public}s",  buf,  0x22u);
            if (v52 < 0) {
              operator delete(*(void **)v49);
            }
          }

          char v36 = (void *)[NSNumber numberWithUnsignedShort:v40];
          unsigned int v30 = (void *)objc_claimAutoreleasedReturnValue( +[NSMutableDictionary dictionaryWithObject:forKey:]( &OBJC_CLASS___NSMutableDictionary,  "dictionaryWithObject:forKey:",  v16));
          unsigned int v31 = *(void **)(a1 + 280);
          unsigned int v32 = (void *)objc_claimAutoreleasedReturnValue(+[NSNumber numberWithUnsignedInt:](&OBJC_CLASS___NSNumber, "numberWithUnsignedInt:", v26));
          [v31 setObject:v30 forKeyedSubscript:v32];

          unsigned int v33 = (os_log_s *)qword_1008F75F0;
          if (os_log_type_enabled((os_log_t)qword_1008F75F0, OS_LOG_TYPE_DEFAULT))
          {
            uint64_t v34 = *(void *)(a1 + 280);
            *(_DWORD *)__int128 buf = 138412290;
            *(void *)&uint8_t buf[4] = v34;
            _os_log_impl( (void *)&_mh_execute_header,  v33,  OS_LOG_TYPE_DEFAULT,  "currently published services in sdp: %@",  buf,  0xCu);
          }

          uint64_t v35 = sub_100404FE8();
          v37[0] = _NSConcreteStackBlock;
          v37[1] = 3221225472LL;
          void v37[2] = sub_100212708;
          v37[3] = &unk_1008878D8;
          v37[4] = a1;
          unsigned __int16 v38 = v40;
          sub_1004054B4(v35, v37);
          sub_100242CD8(&v39);

          goto LABEL_23;
        }

        if (os_log_type_enabled((os_log_t)qword_1008F75F0, OS_LOG_TYPE_ERROR)) {
          sub_10065ED08();
        }
        int64_t v18 = 14LL;
      }

      sub_100242CD8(&v39);
    }

    xpc_object_t v22 = xpc_dictionary_create(0LL, 0LL, 0LL);
    xpc_dictionary_set_int64(v22, "kCBMsgArgResult", v18);
    id v23 = v16;
    xpc_dictionary_set_data( v22,  "kCBMsgArgServiceUUID",  [v23 bytes],  (size_t)objc_msgSend(v23, "length"));
    sub_10043F1F4(a1, 46LL, v22, 1);

LABEL_23:
    sub_100242FAC((uint64_t)v44);
    _Block_object_dispose(&v45, 8);
    goto LABEL_24;
  }

  unsigned int v12 = sub_100211950(a1, v10);
  xpc_object_t reply = xpc_dictionary_create_reply(xdict);
  uint64_t v14 = reply;
  if (reply)
  {
    xpc_dictionary_set_uint64(reply, "kCBMsgArgServiceHandle", v12);
    xpc_connection_send_message(*(xpc_connection_t *)(a1 + 16), v14);
    xpc_release(v14);
  }

void sub_10020D778( _Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, int a16, char a17, char a18, uint64_t a19, uint64_t a20, uint64_t a21, uint64_t a22, id a23, uint64_t a24, char a25, uint64_t a26, char a27)
{
  sub_100242FAC((uint64_t)&a25);
  _Block_object_dispose(&a27, 8);

  _Unwind_Resume(a1);
}

void sub_10020D824(uint64_t a1, xpc_object_t xdict)
{
  xpc_object_t value = xpc_dictionary_get_value(xdict, "kCBMsgArgs");
  id v4 = sub_10025E150(value, "kCBMsgArgServiceUUID");
  id v5 = (void *)objc_claimAutoreleasedReturnValue(v4);
  int64_t int64 = xpc_dictionary_get_int64(value, "kCBMsgArgServiceHandle");
  v31[0] = 0LL;
  v31[1] = 0LL;
  sub_100242F28((uint64_t)v31, a1 + 216);
  if (v5)
  {
    id v7 = (os_log_s *)qword_1008F75F0;
    if (os_log_type_enabled((os_log_t)qword_1008F75F0, OS_LOG_TYPE_DEFAULT))
    {
      LODWORD(buf) = 138412290;
      *(void *)((char *)&buf + 4) = v5;
      _os_log_impl( (void *)&_mh_execute_header,  v7,  OS_LOG_TYPE_DEFAULT,  "remove service: %@ from SDP",  (uint8_t *)&buf,  0xCu);
    }

    *(void *)&__int128 buf = 0LL;
    *((void *)&buf + 1) = &buf;
    uint64_t v39 = 0x2020000000LL;
    int v40 = 0;
    v28[0] = 0LL;
    v28[1] = v28;
    uint64_t v29 = 0x2020000000LL;
    __int16 v30 = 0;
    uint64_t v8 = *(void **)(a1 + 280);
    v24[0] = _NSConcreteStackBlock;
    v24[1] = 3221225472LL;
    v24[2] = sub_10021278C;
    v24[3] = &unk_100887978;
    id v9 = v5;
    id v25 = v9;
    p___int128 buf = &buf;
    unsigned int v27 = v28;
    [v8 enumerateKeysAndObjectsUsingBlock:v24];
    if (*(_DWORD *)(*((void *)&buf + 1) + 24LL))
    {
      char v23 = 0;
      sub_100242CA4(&v23);
      int v10 = sub_1001E1520(*(_DWORD *)(*((void *)&buf + 1) + 24LL));
      sub_100242CD0(&v23);
      uint64_t v11 = (os_log_s *)qword_1008F75F0;
      if (os_log_type_enabled((os_log_t)qword_1008F75F0, OS_LOG_TYPE_DEFAULT))
      {
        sub_100494958(*(void *)(a1 + 128), (uint64_t)__p);
        if (v22 >= 0) {
          unsigned int v12 = __p;
        }
        else {
          unsigned int v12 = (void **)__p[0];
        }
        *(_DWORD *)unsigned int v32 = 138412802;
        id v33 = v9;
        __int16 v34 = 1024;
        int v35 = v10;
        __int16 v36 = 2082;
        int v37 = v12;
        _os_log_impl( (void *)&_mh_execute_header,  v11,  OS_LOG_TYPE_DEFAULT,  "Removed service uuid %@ with status 0x%x  for session %{public}s",  v32,  0x1Cu);
        if (v22 < 0) {
          operator delete(__p[0]);
        }
      }

      uint64_t v13 = sub_100404FE8();
      v20[0] = _NSConcreteStackBlock;
      v20[1] = 3221225472LL;
      void v20[2] = sub_10021291C;
      v20[3] = &unk_100880D70;
      void v20[4] = v28;
      v20[5] = a1;
      sub_1004054B4(v13, v20);
      sub_100242CD8(&v23);
    }

    _Block_object_dispose(v28, 8);
    _Block_object_dispose(&buf, 8);
  }

  else if ((_DWORD)int64)
  {
    uint64_t v14 = *(void **)(a1 + 280);
    uint64_t v15 = (void *)[NSNumber numberWithUnsignedInt:];
    id v16 = [v14 objectForKeyedSubscript:v15];
    LOBYTE(v14) = v16 == 0LL;

    if ((v14 & 1) != 0)
    {
      int v17 = 414;
    }

    else
    {
      LOBYTE(buf) = 0;
      sub_100242CA4(&buf);
      int v17 = sub_1001E1520(int64);
      sub_100242CD0(&buf);
      sub_100242CD8(&buf);
    }

    int64_t v18 = (os_log_s *)qword_1008F75F0;
    if (os_log_type_enabled((os_log_t)qword_1008F75F0, OS_LOG_TYPE_DEFAULT))
    {
      sub_100494958(*(void *)(a1 + 128), (uint64_t)v28);
      uint64_t v19 = v29 >= 0 ? v28 : (void **)v28[0];
      LODWORD(buf) = 67109634;
      DWORD1(buf) = int64;
      WORD4(buf) = 1024;
      *(_DWORD *)((char *)&buf + 10) = v17;
      HIWORD(buf) = 2082;
      uint64_t v39 = (uint64_t)v19;
      _os_log_impl( (void *)&_mh_execute_header,  v18,  OS_LOG_TYPE_DEFAULT,  "Removed service handle 0x%X with status 0x%X  for session %{public}s",  (uint8_t *)&buf,  0x18u);
      if (SHIBYTE(v29) < 0) {
        operator delete(v28[0]);
      }
    }
  }

  sub_100242FAC((uint64_t)v31);
}

void sub_10020DBEC( _Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20, uint64_t a21, uint64_t a22, uint64_t a23, uint64_t a24, uint64_t a25, uint64_t a26, uint64_t a27, uint64_t a28, uint64_t a29, uint64_t a30, char a31)
{
  _Unwind_Resume(a1);
}

uint64_t sub_10020DC7C(uint64_t a1)
{
  v5[0] = 0LL;
  v5[1] = 0LL;
  sub_100242F28((uint64_t)v5, a1 + 216);
  uint64_t v2 = *(void **)(a1 + 280);
  v4[0] = _NSConcreteStackBlock;
  v4[1] = 3221225472LL;
  void v4[2] = sub_10021297C;
  v4[3] = &unk_1008879C0;
  v4[4] = a1;
  [v2 enumerateKeysAndObjectsUsingBlock:v4];
  [*(id *)(a1 + 280) removeAllObjects];
  return sub_100242FAC((uint64_t)v5);
}

void sub_10020DCFC(_Unwind_Exception *a1)
{
}

void sub_10020DD10(int a1, xpc_object_t xdict)
{
  xpc_object_t value = xpc_dictionary_get_value(xdict, "kCBMsgArgs");
  uint64_t v3 = sub_10025E0F0(value, "kCBMsgArgDeviceUUID");
  id v4 = (void *)objc_claimAutoreleasedReturnValue(v3);
  int v11 = sub_10025D848(value, 1, v5, v6, v7, v8, v9, v10, (uint64_t)"kCBMsgArgRFCOMMChannelID");
  unsigned int v12 = (os_log_s *)qword_1008F75F0;
  if (os_log_type_enabled((os_log_t)qword_1008F75F0, OS_LOG_TYPE_ERROR))
  {
    *(_DWORD *)__int128 buf = 67109634;
    *(_DWORD *)uint64_t v14 = v11;
    *(_WORD *)&v14[4] = 2112;
    *(void *)&v14[6] = v4;
    __int16 v15 = 2048;
    uint64_t v16 = 0LL;
    _os_log_error_impl( (void *)&_mh_execute_header,  v12,  OS_LOG_TYPE_ERROR,  "handleOpenRFCOMMChannel failed with result 0x%x, identifier: %@, rfcommChannelID: %lld",  buf,  0x1Cu);
  }
}

void sub_10020DEBC(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_10020DED4(int a1, xpc_object_t xdict)
{
  xpc_object_t value = xpc_dictionary_get_value(xdict, "kCBMsgArgs");
  uint64_t v3 = sub_10025E0F0(value, "kCBMsgArgDeviceUUID");
  id v4 = (void *)objc_claimAutoreleasedReturnValue(v3);
  sub_10025D848(value, 1, v5, v6, v7, v8, v9, v10, (uint64_t)"kCBMsgArgRFCOMMChannelID");
  int v11 = (os_log_s *)qword_1008F75F0;
  if (os_log_type_enabled((os_log_t)qword_1008F75F0, OS_LOG_TYPE_DEFAULT))
  {
    *(_DWORD *)__int128 buf = 134217984;
    uint64_t v13 = 0LL;
    _os_log_impl( (void *)&_mh_execute_header,  v11,  OS_LOG_TYPE_DEFAULT,  "handleCloseRFCOMMChannel rfcommChannelID: %lld",  buf,  0xCu);
  }
}

void sub_10020E004(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_10020E01C(int a1, xpc_object_t xdict)
{
  xpc_object_t value = xpc_dictionary_get_value(xdict, "kCBMsgArgs");
  uint64_t v3 = sub_10025E0F0(value, "kCBMsgArgDeviceUUID");
  id v4 = (void *)objc_claimAutoreleasedReturnValue(v3);
  int v11 = sub_10025D848(value, 1, v5, v6, v7, v8, v9, v10, (uint64_t)"kCBMsgArgRFCOMMChannelID");
  unsigned int v12 = (os_log_s *)qword_1008F75F0;
  if (os_log_type_enabled((os_log_t)qword_1008F75F0, OS_LOG_TYPE_ERROR))
  {
    *(_DWORD *)__int128 buf = 67109634;
    *(_DWORD *)uint64_t v14 = v11;
    *(_WORD *)&v14[4] = 2112;
    *(void *)&v14[6] = v4;
    __int16 v15 = 2048;
    uint64_t v16 = 0LL;
    _os_log_error_impl( (void *)&_mh_execute_header,  v12,  OS_LOG_TYPE_ERROR,  "handleRFCOMMPortConfiguration failed with result 0x%x, identifier: %@, rfcommChannelID: %lld",  buf,  0x1Cu);
  }
}

void sub_10020E204(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_10020E21C(uint64_t a1, xpc_object_t xdict)
{
  xpc_object_t value = xpc_dictionary_get_value(xdict, "kCBMsgArgs");
  uint64_t v5 = sub_10025E0F0(value, "kCBMsgArgDeviceUUID");
  id v10 = [v5 autorelease];
  if (v10)
  {
    if (qword_1008D5F30 != -1) {
      dispatch_once(&qword_1008D5F30, &stru_100887B00);
    }
    uint64_t v6 = sub_1005CC198((uint64_t)off_1008D5F28, v10, 0);
    if (qword_1008D5F50 != -1) {
      dispatch_once(&qword_1008D5F50, &stru_100887B20);
    }
    uint64_t v7 = sub_10040007C(off_1008D5F48, v6, 0);
    if (v7)
    {
      if (qword_1008D60D0 != -1) {
        dispatch_once(&qword_1008D60D0, &stru_100887B40);
      }
      LODWORD(vmemset((char *)&v11[1] + 1, 0, 7) = sub_100425684((uint64_t)off_1008D60C8, (uint64_t)v7);
    }
  }

  else
  {
    LODWORD(vmemset((char *)&v11[1] + 1, 0, 7) = 0;
  }

  xpc_object_t reply = xpc_dictionary_create_reply(xdict);
  uint64_t v9 = reply;
  if (reply)
  {
    xpc_dictionary_set_int64(reply, "kCBMsgArgConnectedServices", v7);
    xpc_connection_send_message(*(xpc_connection_t *)(a1 + 16), v9);
    xpc_release(v9);
  }
}

void sub_10020E378( _Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, id a10)
{
}

void sub_10020E394(uint64_t a1, xpc_object_t original)
{
  xpc_object_t reply = xpc_dictionary_create_reply(original);
  if (reply)
  {
    id v4 = reply;
    bytes = 0LL;
    size_t length = 0LL;
    uint64_t v5 = malloc(0x3E80uLL);
    if (v5)
    {
      uint64_t v6 = v5;
      bytes = v5;
      size_t length = 0x200003E803E80LL;
      char v9 = 0;
      sub_100242CA4(&v9);
      if (!sub_1001E336C((uint64_t)&bytes))
      {
        uint64_t v7 = (os_log_s *)qword_1008F75F0;
        if (os_log_type_enabled((os_log_t)qword_1008F75F0, OS_LOG_TYPE_DEFAULT))
        {
          int v8 = *(unsigned __int16 *)bytes;
          *(_DWORD *)__int128 buf = 67109120;
          int v13 = v8;
          _os_log_impl( (void *)&_mh_execute_header,  v7,  OS_LOG_TYPE_DEFAULT,  "Sending sdp record state (%d records)",  buf,  8u);
        }

        xpc_dictionary_set_data(v4, "kCBMsgArgSDPRecordData", bytes, WORD2(length));
      }

      sub_100242CD0(&v9);
      free(v6);
      sub_100242CD8(&v9);
    }

    xpc_connection_send_message(*(xpc_connection_t *)(a1 + 16), v4);
    xpc_release(v4);
  }

void sub_10020E4D4( _Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, int a10, __int16 a11, char a12, char a13)
{
}

void sub_10020E4F0()
{
  uint64_t v0 = (os_log_s *)qword_1008F75F0;
  if (os_log_type_enabled((os_log_t)qword_1008F75F0, OS_LOG_TYPE_ERROR)) {
    sub_10065EDC0(v0, v1, v2, v3, v4, v5, v6, v7);
  }
}

uint64_t sub_10020E530(uint64_t a1, unsigned int a2)
{
  return (a2 < 0x3D) & (0x1010006008000080uLL >> a2);
}

BOOL sub_10020E554(uint64_t a1, __int16 a2)
{
  return (a2 & 0xFFFE) == 8;
}

uint64_t sub_10020E564(uint64_t a1)
{
  uint64_t v2 = a1 + 8;
  *(void *)a1 = v3;
  *(void *)(a1 + *(void *)(v3 - 24)) = v4;
  uint64_t v5 = (std::ios_base *)(a1 + *(void *)(*(void *)a1 - 24LL));
  std::ios_base::init(v5, (void *)(a1 + 8));
  v5[1].__vftable = 0LL;
  v5[1].__fmtflags_ = -1;
  std::streambuf::basic_streambuf(v2);
  *(_OWORD *)(a1 + 72) = 0u;
  *(_OWORD *)(a1 + 8std::iostream::~basic_iostream(v2, v3 + 8) = 0u;
  *(_DWORD *)(a1 + ++*(_BYTE *)(result + 104) = 16;
  return a1;
}

void sub_10020E628(_Unwind_Exception *a1)
{
}

void sub_10020E650(uint64_t a1)
{
  uint64_t v2 = *(unsigned __int8 *)(a1 + 84);
  uint64_t v3 = *(void *)(a1 + 64);
  uint64_t v4 = *(void *)(a1 + 72);
  uint64_t v5 = *(unsigned __int8 *)(a1 + 85);
  if (qword_1008D67C8 != -1) {
    dispatch_once(&qword_1008D67C8, &stru_100887A60);
  }
  uint64_t v6 = off_1008D67C0;
  unsigned int v7 = *(_DWORD *)(v3 + 40);
  int v8 = *(void **)(a1 + 32);
  else {
    std::string __p = *(std::string *)(v3 + 56);
  }
  *(void *)(v3 + 12std::ostream::~ostream(v2, v3 + 8) = sub_10027BF34( (uint64_t)v6,  v3 + 144,  v7,  v8,  &__p,  *(_DWORD *)(a1 + 80),  *(void **)(a1 + 40),  (_DWORD *)(*(void *)(*(void *)(a1 + 48) + 8LL) + 24LL),  (_BYTE *)(*(void *)(*(void *)(a1 + 56) + 8LL) + 24LL),  (v4 != 0) | (unint64_t)(v2 << 8) | (v5 << 32));
}

void sub_10020E768( _Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, void *__p, uint64_t a14, int a15, __int16 a16, char a17, char a18)
{
  if (a18 < 0) {
    operator delete(__p);
  }
  _Unwind_Resume(exception_object);
}

uint64_t sub_10020E784(uint64_t a1)
{
  uint64_t v3 = a1 + 8;
  std::streambuf::~streambuf(v3);
  std::ios::~ios(a1 + 112);
  return a1;
}

void sub_10020E808(uint64_t a1)
{
  if (*(void *)(a1 + 128))
  {
    uint64_t v2 = sub_100404FE8();
    v3[0] = _NSConcreteStackBlock;
    v3[1] = 3221225472LL;
    _DWORD v3[2] = sub_10020E9E0;
    v3[3] = &unk_10087EB20;
    v3[4] = a1;
    sub_1004054B4(v2, v3);
    *(void *)(a1 + 12std::ostream::~ostream(v2, v3 + 8) = 0LL;
  }

void sub_10020E880(uint64_t a1)
{
  uint64_t v1 = a1 + 176;
  if (*(void *)(a1 + 176))
  {
    if (qword_1008D63D8 != -1) {
      dispatch_once(&qword_1008D63D8, &stru_100887B60);
    }
    uint64_t v3 = off_1008D63D0;
    uint64_t v4 = *(std::__shared_weak_count **)(a1 + 184);
    uint64_t v15 = *(void *)(a1 + 176);
    uint64_t v16 = v4;
    if (v4)
    {
      p_shared_owners = (unint64_t *)&v4->__shared_owners_;
      do
        unint64_t v6 = __ldxr(p_shared_owners);
      while (__stxr(v6 + 1, p_shared_owners));
    }

    unint64_t v7 = sub_100452A84((uint64_t)v3, &v15);
    int v8 = v16;
    if (v16)
    {
      char v9 = (unint64_t *)&v16->__shared_owners_;
      do
        unint64_t v10 = __ldaxr(v9);
      while (__stlxr(v10 - 1, v9));
      if (!v10)
      {
        ((void (*)(std::__shared_weak_count *))v8->__on_zero_shared)(v8);
        std::__shared_weak_count::__release_weak(v8);
      }
    }

    if (qword_1008D63D8 != -1) {
      dispatch_once(&qword_1008D63D8, &stru_100887B60);
    }
    sub_100452BA4(off_1008D63D0, v7);
    __int128 v14 = 0uLL;
    sub_1002102FC(v1, &v14);
    int v11 = (std::__shared_weak_count *)*((void *)&v14 + 1);
    if (*((void *)&v14 + 1))
    {
      unsigned int v12 = (unint64_t *)(*((void *)&v14 + 1) + 8LL);
      do
        unint64_t v13 = __ldaxr(v12);
      while (__stlxr(v13 - 1, v12));
      if (!v13)
      {
        ((void (*)(std::__shared_weak_count *))v11->__on_zero_shared)(v11);
        std::__shared_weak_count::__release_weak(v11);
      }
    }
  }

void sub_10020E9CC(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, ...)
{
}

uint64_t sub_10020E9E0(uint64_t a1)
{
  uint64_t v1 = *(void *)(a1 + 32);
  if (qword_1008D9050 != -1) {
    dispatch_once(&qword_1008D9050, &stru_100887A80);
  }
  sub_100367154(qword_1008D9048, *(void *)(v1 + 128));
  if (qword_1008D67C8 != -1) {
    dispatch_once(&qword_1008D67C8, &stru_100887A60);
  }
  return sub_100277D34((uint64_t)off_1008D67C0, *(void *)(v1 + 128), 0);
}

void sub_10020EA6C(uint64_t a1, uint64_t a2, unsigned int a3)
{
  if (a3 - 2 >= 3)
  {
    if (a3) {
      int v4 = 0;
    }
    else {
      int v4 = 4;
    }
    if (a3 == 1) {
      unsigned int v3 = 5;
    }
    else {
      unsigned int v3 = v4;
    }
  }

  else
  {
    unsigned int v3 = *(_DWORD *)(a1 + 136);
  }

  sub_10043F5A4(a1, v3, a3);
}

void sub_10020EA9C(uint64_t a1, uint64_t a2, unsigned int a3)
{
}

void sub_10020EAA4(uint64_t a1, uint64_t a2, int a3)
{
}

void sub_10020EAAC(uint64_t a1, uint64_t a2, int a3)
{
}

void sub_10020EAB8(uint64_t a1)
{
  int v8 = 0LL;
  char v9 = 0LL;
  uint64_t v10 = 0LL;
  if (qword_1008D67A8 != -1) {
    dispatch_once(&qword_1008D67A8, &stru_100887AE0);
  }
  sub_10052AFEC((uint64_t)off_1008D67A0, &v8);
  uint64_t v2 = (uint64_t *)v8;
  unsigned int v3 = (uint64_t *)v9;
  if (v8 != v9)
  {
    do
    {
      int v4 = (unsigned __int8 *)*v2;
      if (sub_1003D0670(*v2) || !*(_BYTE *)(a1 + 48))
      {
        v11[0] = 0LL;
        v11[1] = 0LL;
        if (qword_1008D5F30 != -1) {
          dispatch_once(&qword_1008D5F30, &stru_100887B00);
        }
        sub_1005C8684( (uint64_t)off_1008D5F28,  ((unint64_t)v4[128] << 40) | ((unint64_t)v4[129] << 32) | ((unint64_t)v4[130] << 24) | ((unint64_t)v4[131] << 16) | ((unint64_t)v4[132] << 8) | v4[133],  1u,  0,  0LL,  0LL,  (unsigned __int8 *)v11);
        uint64_t v5 = sub_100241F94((const unsigned __int8 *)v11);
        unint64_t v6 = (void *)objc_claimAutoreleasedReturnValue(v5);
        xpc_object_t v7 = sub_10020ECA0(v6);

        xpc_array_append_value(*(xpc_object_t *)(a1 + 40), v7);
        xpc_release(v7);
      }

      ++v2;
    }

    while (v2 != v3);
    uint64_t v2 = (uint64_t *)v8;
  }

  if (v2)
  {
    char v9 = (void **)v2;
    operator delete(v2);
  }

void sub_10020EC64( _Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, void *__p, uint64_t a10)
{
  if (__p) {
    operator delete(__p);
  }
  _Unwind_Resume(exception_object);
}

xpc_object_t sub_10020ECA0(void *a1)
{
  id v1 = a1;
  xpc_object_t v2 = xpc_dictionary_create(0LL, 0LL, 0LL);
  id v3 = v1;
  int v4 = v3;
  if (v3)
  {
    *(void *)uuid = 0LL;
    uint64_t v30 = 0LL;
    [v3 getUUIDBytes:uuid];
    xpc_dictionary_set_uuid(v2, "kCBMsgArgDeviceUUID", uuid);
  }

  if (qword_1008D5F30 != -1) {
    dispatch_once(&qword_1008D5F30, &stru_100887B00);
  }
  uint64_t v5 = sub_1005CC198((uint64_t)off_1008D5F28, v4, 0);
  if (qword_1008D5F50 != -1) {
    dispatch_once(&qword_1008D5F50, &stru_100887B20);
  }
  unint64_t v6 = sub_10040007C(off_1008D5F48, v5, 0);
  uint64_t v7 = (uint64_t)v6;
  if (v6)
  {
    *(void *)uuid = 0LL;
    uint64_t v30 = 0LL;
    uint64_t v31 = 0LL;
    sub_1003D0100((uint64_t)v6, (uint64_t)uuid);
    if (SHIBYTE(v31) < 0)
    {
      if (!v30) {
        goto LABEL_14;
      }
      int v8 = *(unsigned __int8 **)uuid;
    }

    else
    {
      if (!HIBYTE(v31)) {
        goto LABEL_14;
      }
      int v8 = uuid;
    }

    xpc_dictionary_set_string(v2, "kCBMsgArgName", (const char *)v8);
LABEL_14:
    unsigned int v9 = sub_1003D0268(v7);
    xpc_dictionary_set_int64(v2, "kCBMsgArgDeviceType", v9);
    unsigned int value_4 = 0;
    unsigned int v10 = sub_1003CF350((unsigned __int8 *)v7);
    xpc_dictionary_set_int64(v2, "kCBMsgArgPairingState", v10);
    int v11 = sub_1003D0578(v7);
    xpc_dictionary_set_int64(v2, "kCBMsgArgRssi", v11);
    xpc_dictionary_set_int64(v2, "kCBMsgArgInternalState", 2LL * *(unsigned __int8 *)(v7 + 1332));
    unsigned int value = 0;
    memset(v26, 0, sizeof(v26));
    if (sub_1003D55EC(v7, &value, &v26[2], &v26[1], v26))
    {
      xpc_dictionary_set_int64(v2, "kCBMsgArgVIDSource", value);
      xpc_dictionary_set_int64(v2, "kCBMsgArgVID", v26[2]);
      xpc_dictionary_set_int64(v2, "kCBMsgArgPID", v26[1]);
      xpc_dictionary_set_int64(v2, "kCBMsgArgVersion", v26[0]);
    }

    *(_OWORD *)&__dst[1] = 0uLL;
    uint64_t v25 = 0LL;
    if (*(char *)(v7 + 415) < 0)
    {
      sub_100024238(&__dst[1], *(void **)(v7 + 392), *(void *)(v7 + 400));
    }

    else
    {
      *(_OWORD *)&__dst[1] = *(_OWORD *)(v7 + 392);
      uint64_t v25 = *(void *)(v7 + 408);
    }

    if (SHIBYTE(v25) < 0)
    {
      if (!*(void *)&__dst[3]) {
        goto LABEL_27;
      }
      unsigned int v12 = *(const char **)&__dst[1];
    }

    else
    {
      if (!HIBYTE(v25)) {
        goto LABEL_27;
      }
      unsigned int v12 = (const char *)&__dst[1];
    }

    xpc_dictionary_set_string(v2, "kCBMsgArgModelIdentifier", v12);
LABEL_27:
    __dst[0] = 0;
    if (sub_1003D6ED8(v7, __dst)) {
      xpc_dictionary_set_int64(v2, "kCBMsgArgAppleFeatureBitMask", __dst[0]);
    }
    uint64_t v23 = 0LL;
    if (sub_1003D6F90(v7, &v23)) {
      xpc_dictionary_set_int64( v2,  "kCBMsgArgExtendedAppleFeatureBitMask",  HIDWORD(v23) | ((unint64_t)v23 << 32));
    }
    string = 0LL;
    uint64_t v21 = 0LL;
    uint64_t v22 = 0LL;
    sub_1003FE1B4((unsigned __int8 *)(v7 + 128), &string);
    if (SHIBYTE(v22) < 0)
    {
      if (v21)
      {
        p_string = string;
        goto LABEL_36;
      }
    }

    else if (HIBYTE(v22))
    {
      p_string = (const char *)&string;
LABEL_36:
      xpc_dictionary_set_string(v2, "kCBMsgArgAddressString", p_string);
    }

    bytes[0] = BYTE5(v5);
    bytes[1] = BYTE4(v5);
    bytes[2] = BYTE3(v5);
    bytes[3] = BYTE2(v5);
    bytes[4] = BYTE1(v5);
    bytes[5] = v5;
    xpc_dictionary_set_data(v2, "kCBAdvDataDeviceAddress", bytes, 6uLL);
    id v14 = sub_1003E366C(v7);
    uint64_t v15 = (void *)objc_claimAutoreleasedReturnValue(v14);
    if ([v15 count])
    {
      uint64_t v16 = (void *)sub_10043E92C(v15);
      xpc_dictionary_set_value(v2, "kCBMsgArgServices", v16);
      xpc_release(v16);
    }

    xpc_dictionary_set_BOOL(v2, "kCBMsgArgIsConnectedOverUSB", *(_BYTE *)(v7 + 1296));
    if (sub_1003E16E4(v7))
    {
      unsigned int v17 = sub_1003E16E4(v7);
      xpc_dictionary_set_int64(v2, "kCBMsgArgColorID", v17);
    }

    if (SHIBYTE(v22) < 0) {
      operator delete(string);
    }
    if (SHIBYTE(v25) < 0) {
      operator delete(*(void **)&__dst[1]);
    }
    if (SHIBYTE(v31) < 0) {
      operator delete(*(void **)uuid);
    }
  }

  return v2;
}

void sub_10020F118( _Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void *a10, uint64_t a11, int a12, __int16 a13, char a14, char a15, uint64_t a16, uint64_t a17, void *__p, uint64_t a19, int a20, __int16 a21, char a22, char a23)
{
  _Unwind_Resume(a1);
}

void sub_10020F1C8(uint64_t a1)
{
  uint64_t v2 = *(void *)(a1 + 48);
  if (qword_1008D67C8 != -1) {
    dispatch_once(&qword_1008D67C8, &stru_100887A60);
  }
  sub_10027F8D4((uint64_t)off_1008D67C0, *(void *)(v2 + 128), *(void **)(a1 + 32), *(void **)(a1 + 40));
  if (qword_1008D67C8 != -1) {
    dispatch_once(&qword_1008D67C8, &stru_100887A60);
  }
  uint64_t v3 = sub_10027BC04((uint64_t)off_1008D67C0, *(void *)(v2 + 128), 2u);
  int v4 = (os_log_s *)qword_1008F75F0;
  if (os_log_type_enabled((os_log_t)qword_1008F75F0, OS_LOG_TYPE_DEFAULT))
  {
    uint64_t v5 = *(void *)(v3 + 88);
    int v6 = *(unsigned __int8 *)(a1 + 56);
    int v7 = 136315650;
    int v8 = "handleConnectPeerMsg_block_invoke";
    __int16 v9 = 2114;
    uint64_t v10 = v5;
    __int16 v11 = 1024;
    int v12 = v6;
    _os_log_impl( (void *)&_mh_execute_header,  v4,  OS_LOG_TYPE_DEFAULT,  "%s: Setting didRequestPairing for Application %{public}@ to %d",  (uint8_t *)&v7,  0x1Cu);
  }

  *(_BYTE *)(v3 + 20std::ostream::~ostream(v2, v3 + 8) = *(_BYTE *)(a1 + 56);
}

void sub_10020F318(uint64_t a1)
{
  uint64_t v2 = *(void *)(a1 + 40);
  if (qword_1008D67C8 != -1) {
    dispatch_once(&qword_1008D67C8, &stru_100887A60);
  }
  sub_100281E68((uint64_t)off_1008D67C0, *(void *)(v2 + 128), *(void **)(a1 + 32), *(void *)(a1 + 48) != 0LL, 1, 0);
}

void sub_10020F384(uint64_t a1, int a2, uint64_t a3, uint64_t a4, uint64_t a5)
{
  switch(a2)
  {
    case 0:
      uint64_t v5 = (os_log_s *)qword_1008F75F0;
      if (os_log_type_enabled((os_log_t)qword_1008F75F0, OS_LOG_TYPE_DEFAULT))
      {
        __int16 v13 = 0;
        int v6 = "Bluetooth discoveryStatus: scan started";
        int v7 = (uint8_t *)&v13;
        goto LABEL_13;
      }

      break;
    case 1:
      __int16 v9 = (os_log_s *)qword_1008F75F0;
      if (os_log_type_enabled((os_log_t)qword_1008F75F0, OS_LOG_TYPE_DEFAULT))
      {
        *(_WORD *)__int128 buf = 0;
        _os_log_impl( (void *)&_mh_execute_header,  v9,  OS_LOG_TYPE_DEFAULT,  "Bluetooth discoveryStatus: scan stopped",  buf,  2u);
      }

      sub_10020F500(a5);
      break;
    case 2:
      uint64_t v5 = (os_log_s *)qword_1008F75F0;
      if (os_log_type_enabled((os_log_t)qword_1008F75F0, OS_LOG_TYPE_DEFAULT))
      {
        __int16 v11 = 0;
        int v6 = "Bluetooth discoveryStatus: query started";
        int v7 = (uint8_t *)&v11;
        goto LABEL_13;
      }

      break;
    case 3:
      uint64_t v5 = (os_log_s *)qword_1008F75F0;
      if (os_log_type_enabled((os_log_t)qword_1008F75F0, OS_LOG_TYPE_DEFAULT))
      {
        __int16 v10 = 0;
        int v6 = "Bluetooth discoveryStatus: query stopped";
        int v7 = (uint8_t *)&v10;
LABEL_13:
        _os_log_impl((void *)&_mh_execute_header, v5, OS_LOG_TYPE_DEFAULT, v6, v7, 2u);
      }

      break;
    default:
      if (os_log_type_enabled((os_log_t)qword_1008F75F0, OS_LOG_TYPE_ERROR)) {
        sub_10065EE30();
      }
      break;
  }

void sub_10020F500(uint64_t a1)
{
  uint64_t v2 = (os_log_s *)qword_1008F75F0;
  if (os_log_type_enabled((os_log_t)qword_1008F75F0, OS_LOG_TYPE_DEFAULT))
  {
    int v3 = *(unsigned __int8 *)(a1 + 192);
    int v4 = *(unsigned __int8 *)(a1 + 193);
    v5[0] = 67109376;
    v5[1] = v3;
    __int16 v6 = 1024;
    int v7 = v4;
    _os_log_impl( (void *)&_mh_execute_header,  v2,  OS_LOG_TYPE_DEFAULT,  "restartInquiry: continuous? %d, already scanning? %d",  (uint8_t *)v5,  0xEu);
  }

  if (*(_BYTE *)(a1 + 193))
  {
    if (*(_BYTE *)(a1 + 192))
    {
      *(_BYTE *)(a1 + 193) = 0;
      sub_10020F888(a1, 1LL);
    }
  }

void sub_10020F5E0(uint64_t a1, int a2, unint64_t a3, uint64_t a4, uint64_t a5)
{
  if (qword_1008D5F50 != -1) {
    dispatch_once(&qword_1008D5F50, &stru_100887B20);
  }
  int v8 = (unsigned __int8 *)sub_1003FEF18((uint64_t)off_1008D5F48, a3);
  __p[0] = 0LL;
  __p[1] = 0LL;
  uint64_t v17 = 0LL;
  sub_1003D01A0((uint64_t)v8, (uint64_t)__p);
  v20[0] = 0LL;
  v20[1] = 0LL;
  if (qword_1008D5F30 != -1) {
    dispatch_once(&qword_1008D5F30, &stru_100887B00);
  }
  sub_1005C8684( (uint64_t)off_1008D5F28,  ((unint64_t)v8[128] << 40) | ((unint64_t)v8[129] << 32) | ((unint64_t)v8[130] << 24) | ((unint64_t)v8[131] << 16) | ((unint64_t)v8[132] << 8) | v8[133],  1u,  0,  0LL,  0LL,  (unsigned __int8 *)v20);
  __int16 v9 = sub_100241F94((const unsigned __int8 *)v20);
  __int16 v10 = (void *)objc_claimAutoreleasedReturnValue(v9);
  xpc_object_t v11 = sub_10020ECA0(v10);

  if (!a2)
  {
    sub_10043F1F4(a5, 44LL, v11, 1);
    int v12 = (os_log_s *)qword_1008F75F0;
    if (!os_log_type_enabled((os_log_t)qword_1008F75F0, OS_LOG_TYPE_DEFAULT)) {
      goto LABEL_19;
    }
    uint64_t v15 = __p;
    if (v17 < 0) {
      uint64_t v15 = (void **)__p[0];
    }
    *(_DWORD *)__int128 buf = 136315138;
    uint64_t v19 = v15;
    id v14 = "Bluetooth discoveryEvent: device found: %s";
    goto LABEL_15;
  }

  if (a2 == 2)
  {
    sub_10043F1F4(a5, 45LL, v11, 1);
    int v12 = (os_log_s *)qword_1008F75F0;
    if (!os_log_type_enabled((os_log_t)qword_1008F75F0, OS_LOG_TYPE_DEFAULT)) {
      goto LABEL_19;
    }
    __int16 v13 = __p;
    if (v17 < 0) {
      __int16 v13 = (void **)__p[0];
    }
    *(_DWORD *)__int128 buf = 136315138;
    uint64_t v19 = v13;
    id v14 = "Bluetooth discoveryEvent: device changed: %s";
LABEL_15:
    _os_log_impl((void *)&_mh_execute_header, v12, OS_LOG_TYPE_DEFAULT, v14, buf, 0xCu);
    goto LABEL_19;
  }

  if (os_log_type_enabled((os_log_t)qword_1008F75F0, OS_LOG_TYPE_ERROR)) {
    sub_10065EE90();
  }
  xpc_release(v11);
LABEL_19:
  if (SHIBYTE(v17) < 0) {
    operator delete(__p[0]);
  }
}

void sub_10020F854( _Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void *__p, uint64_t a11, int a12, __int16 a13, char a14, char a15)
{
  if (a15 < 0) {
    operator delete(__p);
  }
  _Unwind_Resume(a1);
}

void sub_10020F888(uint64_t a1, int a2, uint64_t a3, void *a4, int a5, int a6)
{
  id v11 = a4;
  int v12 = (os_log_s *)qword_1008F75F0;
  if (os_log_type_enabled((os_log_t)qword_1008F75F0, OS_LOG_TYPE_DEFAULT))
  {
    int v13 = *(unsigned __int8 *)(a1 + 193);
    *(_DWORD *)__int128 buf = 67109632;
    int v37 = a2;
    __int16 v38 = 1024;
    int v39 = v13;
    __int16 v40 = 1024;
    int v41 = a6;
    _os_log_impl( (void *)&_mh_execute_header,  v12,  OS_LOG_TYPE_DEFAULT,  "startInquiry: continuous? %d, already scanning? %d, duplicates to be reported? %d",  buf,  0x14u);
  }

  if (!*(_BYTE *)(a1 + 193))
  {
    objc_storeStrong((id *)(a1 + 200), a4);
    *(_DWORD *)(a1 + 20std::ostream::~ostream(v2, v3 + 8) = a5;
    sub_10020FB98((uint64_t *)a1);
    uint64_t v14 = *(void *)(a1 + 176);
    if (v14)
    {
      if (a6)
      {
        uint64_t v15 = (os_log_s *)qword_1008F75F0;
        if (os_log_type_enabled((os_log_t)qword_1008F75F0, OS_LOG_TYPE_DEFAULT))
        {
          *(_WORD *)__int128 buf = 0;
          _os_log_impl( (void *)&_mh_execute_header,  v15,  OS_LOG_TYPE_DEFAULT,  "startInquiry: Enabling duplicate reporting.",  buf,  2u);
          uint64_t v14 = *(void *)(a1 + 176);
        }

        sub_10044F6E0(v14);
        *(_BYTE *)(a1 + 212) = 1;
      }

      if (a2)
      {
        if (qword_1008D63D8 != -1) {
          dispatch_once(&qword_1008D63D8, &stru_100887B60);
        }
        uint64_t v16 = off_1008D63D0;
        uint64_t v17 = *(std::__shared_weak_count **)(a1 + 184);
        uint64_t v34 = *(void *)(a1 + 176);
        int v35 = v17;
        if (v17)
        {
          p_shared_owners = (unint64_t *)&v17->__shared_owners_;
          do
            unint64_t v19 = __ldxr(p_shared_owners);
          while (__stxr(v19 + 1, p_shared_owners));
        }

        int v20 = sub_100453844((uint64_t)v16, &v34, 1u, -1);
        uint64_t v21 = v35;
        if (v35)
        {
          uint64_t v22 = (unint64_t *)&v35->__shared_owners_;
          do
            unint64_t v23 = __ldaxr(v22);
          while (__stlxr(v23 - 1, v22));
          if (!v23)
          {
            ((void (*)(std::__shared_weak_count *))v21->__on_zero_shared)(v21);
            std::__shared_weak_count::__release_weak(v21);
          }
        }

        if (v20) {
          goto LABEL_4;
        }
        *(_BYTE *)(a1 + 192) = 1;
      }

      else
      {
        if (qword_1008D63D8 != -1) {
          dispatch_once(&qword_1008D63D8, &stru_100887B60);
        }
        uint64_t v24 = off_1008D63D0;
        uint64_t v25 = *(std::__shared_weak_count **)(a1 + 184);
        uint64_t v32 = *(void *)(a1 + 176);
        id v33 = v25;
        if (v25)
        {
          uint64_t v26 = (unint64_t *)&v25->__shared_owners_;
          do
            unint64_t v27 = __ldxr(v26);
          while (__stxr(v27 + 1, v26));
        }

        int v28 = sub_100453844((uint64_t)v24, &v32, 0, -1);
        uint64_t v29 = v33;
        if (v33)
        {
          uint64_t v30 = (unint64_t *)&v33->__shared_owners_;
          do
            unint64_t v31 = __ldaxr(v30);
          while (__stlxr(v31 - 1, v30));
          if (!v31)
          {
            ((void (*)(std::__shared_weak_count *))v29->__on_zero_shared)(v29);
            std::__shared_weak_count::__release_weak(v29);
          }
        }

        *(_BYTE *)(a1 + 192) = 0;
        if (v28) {
          goto LABEL_4;
        }
      }

      *(_BYTE *)(a1 + 193) = 1;
      goto LABEL_4;
    }

    if (os_log_type_enabled((os_log_t)qword_1008F75F0, OS_LOG_TYPE_ERROR)) {
      sub_10065EEF0();
    }
  }

void sub_10020FB64( _Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9)
{
  _Unwind_Resume(a1);
}

uint64_t *sub_10020FB98(uint64_t *result)
{
  id v1 = (uint64_t **)(result + 22);
  if (!result[22])
  {
    uint64_t v2 = (uint64_t)result;
    unint64_t v14 = 0LL;
    if (qword_1008D63D8 != -1) {
      dispatch_once(&qword_1008D63D8, &stru_100887B60);
    }
    int v3 = off_1008D63D0;
    unint64_t v4 = sub_100494CF8(*(void *)(v2 + 128));
    sub_100452724((uint64_t)v3, v4, &v14, &v12);
    uint64_t v5 = v13;
    if (v13)
    {
      p_shared_owners = (unint64_t *)&v13->__shared_owners_;
      do
        unint64_t v7 = __ldaxr(p_shared_owners);
      while (__stlxr(v7 - 1, p_shared_owners));
      if (!v7)
      {
        ((void (*)(std::__shared_weak_count *))v5->__on_zero_shared)(v5);
        std::__shared_weak_count::__release_weak(v5);
      }
    }

    if (qword_1008D63D8 != -1) {
      dispatch_once(&qword_1008D63D8, &stru_100887B60);
    }
    sub_1004529CC((uint64_t)off_1008D63D0, v14, &v11);
    sub_1002102FC((uint64_t)v1, &v11);
    int v8 = (std::__shared_weak_count *)*((void *)&v11 + 1);
    if (*((void *)&v11 + 1))
    {
      __int16 v9 = (unint64_t *)(*((void *)&v11 + 1) + 8LL);
      do
        unint64_t v10 = __ldaxr(v9);
      while (__stlxr(v10 - 1, v9));
      if (!v10)
      {
        ((void (*)(std::__shared_weak_count *))v8->__on_zero_shared)(v8);
        std::__shared_weak_count::__release_weak(v8);
      }
    }

    uint64_t result = *v1;
    if (*v1)
    {
      *(void *)&__int128 v11 = sub_10020F384;
      *((void *)&v11 + 1) = sub_10020F5E0;
      return (uint64_t *)sub_10044EB34(result, v14, (uint64_t *)&v11, v2);
    }
  }

  return result;
}

void sub_10020FD04(uint64_t a1, unsigned __int8 *a2)
{
  if (a2)
  {
    uint64_t v22 = 0LL;
    unint64_t v23 = 0LL;
    uint64_t v24 = 0LL;
    sub_1003D0100((uint64_t)a2, (uint64_t)&v22);
    if (SHIBYTE(v24) < 0)
    {
      unint64_t v4 = v22;
      if (!v22)
      {
        uint64_t v17 = 0LL;
        goto LABEL_33;
      }
    }

    else
    {
      unint64_t v4 = &v22;
    }

    v28[0] = 0LL;
    v28[1] = 0LL;
    if (qword_1008D5F30 != -1) {
      dispatch_once(&qword_1008D5F30, &stru_100887B00);
    }
    sub_1005C8684( (uint64_t)off_1008D5F28,  ((unint64_t)a2[128] << 40) | ((unint64_t)a2[129] << 32) | ((unint64_t)a2[130] << 24) | ((unint64_t)a2[131] << 16) | ((unint64_t)a2[132] << 8) | a2[133],  1u,  0,  0LL,  0LL,  (unsigned __int8 *)v28);
    uint64_t v5 = (void *)objc_claimAutoreleasedReturnValue(+[NSString stringWithUTF8String:](&OBJC_CLASS___NSString, "stringWithUTF8String:", v4));
    if (v5)
    {
      __int16 v6 = sub_100241F94((const unsigned __int8 *)v28);
      uint64_t v7 = objc_claimAutoreleasedReturnValue(v6);
      int v8 = (NSMutableString *)v7;
      if (v7)
      {
        v25[0] = @"kCBMsgArgDeviceUUID";
        v25[1] = @"kCBMsgArgName";
        v26[0] = v7;
        v26[1] = v5;
        __int16 v9 = (void *)objc_claimAutoreleasedReturnValue( +[NSDictionary dictionaryWithObjects:forKeys:count:]( &OBJC_CLASS___NSDictionary,  "dictionaryWithObjects:forKeys:count:",  v26,  v25,  2LL));
        sub_10043F394(a1, 45LL, v9);

        if (os_log_type_enabled((os_log_t)qword_1008F75F0, OS_LOG_TYPE_DEBUG)) {
          sub_10065F028();
        }
      }

      else if (os_log_type_enabled((os_log_t)qword_1008F75F0, OS_LOG_TYPE_ERROR))
      {
        sub_10065EFC8();
      }
    }

    else
    {
      unint64_t v10 = (os_log_s *)qword_1008F75F0;
      if (os_log_type_enabled((os_log_t)qword_1008F75F0, OS_LOG_TYPE_ERROR))
      {
        __int128 v11 = sub_100241F94((const unsigned __int8 *)v28);
        uint64_t v12 = (void *)objc_claimAutoreleasedReturnValue(v11);
        sub_10065EF7C(v12, (uint64_t)v27, v10);
      }

      int v8 = objc_alloc_init(&OBJC_CLASS___NSMutableString);
      unint64_t v13 = HIBYTE(v24);
      if (v24 < 0) {
        unint64_t v13 = v23;
      }
      if (v13)
      {
        for (unint64_t i = 0LL; i < v15; ++i)
        {
          -[NSMutableString appendFormat:](v8, "appendFormat:", @"%X ", *((unsigned __int8 *)v4 + i));
          unint64_t v15 = HIBYTE(v24);
          if (v24 < 0) {
            unint64_t v15 = v23;
          }
        }
      }

      if (os_log_type_enabled((os_log_t)qword_1008F75F0, OS_LOG_TYPE_ERROR)) {
        sub_10065EF1C();
      }
      if (qword_1008D9060 != -1) {
        dispatch_once(&qword_1008D9060, &stru_100887B80);
      }
      uint64_t v16 = qword_1008D9058;
      sub_10002418C(v20, "XpcClassicConnection::deviceNameUpdated");
      sub_10002418C(__p, "Unparseable name change");
      sub_10040C784(0.0, v16, (uint64_t *)v20, (uint64_t *)__p);
      if (v19 < 0) {
        operator delete(__p[0]);
      }
      if (v21 < 0) {
        operator delete(v20[0]);
      }
    }

    if (SHIBYTE(v24) < 0)
    {
      uint64_t v17 = v22;
LABEL_33:
      operator delete(v17);
    }
  }

void sub_100210048( _Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void *a10, uint64_t a11, int a12, __int16 a13, char a14, char a15, void *a16, uint64_t a17, int a18, __int16 a19, char a20, char a21, void *__p, uint64_t a23, int a24, __int16 a25, char a26, char a27)
{
  if (a27 < 0) {
    operator delete(__p);
  }
  _Unwind_Resume(a1);
}

void sub_1002100E0(uint64_t a1, unsigned __int8 *a2)
{
}

void sub_1002100E8(uint64_t a1, uint64_t a2)
{
  if (a2)
  {
    sub_1003D0100(a2, (uint64_t)&__p);
    BOOL v5 = v9 < 0 && __p == 0LL;
    if (v9 < 0)
    {
      operator delete(__p);
      if (v5) {
        return;
      }
    }

    else if (v5)
    {
      return;
    }

    uint64_t v6 = sub_100404FE8();
    v7[0] = _NSConcreteStackBlock;
    v7[1] = 3221225472LL;
    _DWORD v7[2] = sub_10021018C;
    v7[3] = &unk_10087F8E0;
    void v7[4] = a1;
    v7[5] = a2;
    sub_100405384(v6, v7);
  }

void sub_10021018C(uint64_t a1)
{
  uint64_t v2 = *(void *)(a1 + 32);
  if (qword_1008D5F30 != -1) {
    dispatch_once(&qword_1008D5F30, &stru_100887B00);
  }
  v11[0] = 0LL;
  v11[1] = 0LL;
  int v3 = *(unsigned __int8 **)(a1 + 40);
  sub_1005C8684( (uint64_t)off_1008D5F28,  ((unint64_t)v3[128] << 40) | ((unint64_t)v3[129] << 32) | ((unint64_t)v3[130] << 24) | ((unint64_t)v3[131] << 16) | ((unint64_t)v3[132] << 8) | v3[133],  1u,  0,  0LL,  0LL,  (unsigned __int8 *)v11);
  unint64_t v4 = sub_100241F94((const unsigned __int8 *)v11);
  BOOL v5 = [v4 autorelease];
  uint64_t v6 = v5;
  if (v5)
  {
    xpc_object_t v7 = sub_10020ECA0(v5);
    sub_10043F1F4(v2, 45LL, v7, 1);
  }

  else
  {
    int v8 = (os_log_s *)qword_1008F75F0;
    if (os_log_type_enabled((os_log_t)qword_1008F75F0, OS_LOG_TYPE_ERROR))
    {
      sub_1003CF00C(*(void *)(a1 + 40), v9);
      sub_10065F094((char *)v9, (uint64_t)v10, v8);
    }
  }
}

void sub_1002102D8(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_1002102F4(uint64_t a1, uint64_t a2)
{
}

uint64_t sub_1002102FC(uint64_t a1, __int128 *a2)
{
  __int128 v3 = *a2;
  *(void *)a2 = 0LL;
  *((void *)a2 + 1) = 0LL;
  unint64_t v4 = *(std::__shared_weak_count **)(a1 + 8);
  *(_OWORD *)a1 = v3;
  if (v4)
  {
    p_shared_owners = (unint64_t *)&v4->__shared_owners_;
    do
      unint64_t v6 = __ldaxr(p_shared_owners);
    while (__stlxr(v6 - 1, p_shared_owners));
    if (!v6)
    {
      ((void (*)(std::__shared_weak_count *))v4->__on_zero_shared)(v4);
      std::__shared_weak_count::__release_weak(v4);
    }
  }

  return a1;
}

void sub_100210360(uint64_t a1, uint64_t a2, BOOL a3)
{
  xpc_object_t v5 = xpc_dictionary_create(0LL, 0LL, 0LL);
  unint64_t v6 = (os_log_s *)qword_1008F75F0;
  if (os_log_type_enabled((os_log_t)qword_1008F75F0, OS_LOG_TYPE_DEFAULT))
  {
    xpc_object_t v7 = (void *)(a1 + 56);
    v8[0] = 67109378;
    v8[1] = a3;
    __int16 v9 = 2082;
    unint64_t v10 = v7;
    _os_log_impl( (void *)&_mh_execute_header,  v6,  OS_LOG_TYPE_DEFAULT,  "Sending 'connectable state' event with state %d to session %{public}s",  (uint8_t *)v8,  0x12u);
  }

  xpc_dictionary_set_BOOL(v5, "kCBMsgArgConnectableState", a3);
  sub_10043F1F4(a1, 6LL, v5, 1);
}

void sub_100210464(uint64_t a1, uint64_t a2, BOOL a3)
{
}

void sub_10021046C(uint64_t a1, uint64_t a2, BOOL a3)
{
  xpc_object_t v5 = xpc_dictionary_create(0LL, 0LL, 0LL);
  unint64_t v6 = (os_log_s *)qword_1008F75F0;
  if (os_log_type_enabled((os_log_t)qword_1008F75F0, OS_LOG_TYPE_DEFAULT))
  {
    xpc_object_t v7 = (void *)(a1 + 56);
    v8[0] = 67109378;
    v8[1] = a3;
    __int16 v9 = 2082;
    unint64_t v10 = v7;
    _os_log_impl( (void *)&_mh_execute_header,  v6,  OS_LOG_TYPE_DEFAULT,  "Sending 'discoverable state' event with state %d to session %{public}s",  (uint8_t *)v8,  0x12u);
  }

  xpc_dictionary_set_BOOL(v5, "kCBMsgArgDiscoverableState", a3);
  sub_10043F1F4(a1, 6LL, v5, 1);
}

void sub_100210570(uint64_t a1, uint64_t a2, BOOL a3)
{
}

void sub_100210578(uint64_t a1, uint64_t a2, BOOL a3)
{
  xpc_object_t v5 = xpc_dictionary_create(0LL, 0LL, 0LL);
  unint64_t v6 = (os_log_s *)qword_1008F75F0;
  if (os_log_type_enabled((os_log_t)qword_1008F75F0, OS_LOG_TYPE_DEFAULT))
  {
    xpc_object_t v7 = (void *)(a1 + 56);
    v8[0] = 67109378;
    v8[1] = a3;
    __int16 v9 = 2082;
    unint64_t v10 = v7;
    _os_log_impl( (void *)&_mh_execute_header,  v6,  OS_LOG_TYPE_DEFAULT,  "Sending 'inquiry state' event with state %d to session %{public}s",  (uint8_t *)v8,  0x12u);
  }

  xpc_dictionary_set_BOOL(v5, "kCBMsgArgInquiryState", a3);
  sub_10043F1F4(a1, 6LL, v5, 1);
}

void sub_10021067C(uint64_t a1, uint64_t a2, BOOL a3)
{
}

void sub_100210684(uint64_t a1)
{
  uint64_t v2 = *(void *)(a1 + 32);
  __int128 v3 = (os_log_s *)qword_1008F75F0;
  if (os_log_type_enabled((os_log_t)qword_1008F75F0, OS_LOG_TYPE_DEFAULT))
  {
    unint64_t v4 = (void *)(v2 + 56);
    int v5 = 136446210;
    unint64_t v6 = v4;
    _os_log_impl( (void *)&_mh_execute_header,  v3,  OS_LOG_TYPE_DEFAULT,  "Session %{public}s is asking to register pairing agent",  (uint8_t *)&v5,  0xCu);
  }

  if (qword_1008D67C8 != -1) {
    dispatch_once(&qword_1008D67C8, &stru_100887A60);
  }
  sub_10027EEE8((uint64_t)off_1008D67C0, *(void *)(v2 + 128), *(unsigned __int8 *)(a1 + 40));
}

void sub_10021077C(uint64_t a1)
{
  uint64_t v1 = *(void *)(a1 + 32);
  uint64_t v2 = (os_log_s *)qword_1008F75F0;
  if (os_log_type_enabled((os_log_t)qword_1008F75F0, OS_LOG_TYPE_DEFAULT))
  {
    __int128 v3 = (void *)(v1 + 56);
    int v4 = 136446210;
    int v5 = v3;
    _os_log_impl( (void *)&_mh_execute_header,  v2,  OS_LOG_TYPE_DEFAULT,  "Session %{public}s is asking to unregister pairing agent",  (uint8_t *)&v4,  0xCu);
  }

  if (qword_1008D67C8 != -1) {
    dispatch_once(&qword_1008D67C8, &stru_100887A60);
  }
  sub_10027D160((uint64_t)off_1008D67C0, *(void *)(v1 + 128));
}

void sub_100210864(uint64_t a1)
{
  int v8 = 0LL;
  __int16 v9 = 0LL;
  uint64_t v10 = 0LL;
  if (qword_1008D67A8 != -1) {
    dispatch_once(&qword_1008D67A8, &stru_100887AE0);
  }
  sub_10052AFEC((uint64_t)off_1008D67A0, &v8);
  uint64_t v2 = v8;
  __int128 v3 = v9;
  if (v8 != v9)
  {
    do
    {
      int v4 = (unsigned __int8 *)*v2;
      v11[0] = 0LL;
      v11[1] = 0LL;
      if (qword_1008D5F30 != -1) {
        dispatch_once(&qword_1008D5F30, &stru_100887B00);
      }
      sub_1005C8684( (uint64_t)off_1008D5F28,  ((unint64_t)v4[128] << 40) | ((unint64_t)v4[129] << 32) | ((unint64_t)v4[130] << 24) | ((unint64_t)v4[131] << 16) | ((unint64_t)v4[132] << 8) | v4[133],  1u,  0,  0LL,  0LL,  (unsigned __int8 *)v11);
      int v5 = sub_100241F94((const unsigned __int8 *)v11);
      unint64_t v6 = (void *)objc_claimAutoreleasedReturnValue(v5);
      xpc_object_t v7 = sub_10020ECA0(v6);

      xpc_array_append_value(*(xpc_object_t *)(a1 + 40), v7);
      xpc_release(v7);
      ++v2;
    }

    while (v2 != v3);
    uint64_t v2 = v8;
  }

  if (v2)
  {
    __int16 v9 = v2;
    operator delete(v2);
  }

void sub_1002109FC( _Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, void *__p, uint64_t a10)
{
  if (__p) {
    operator delete(__p);
  }
  _Unwind_Resume(exception_object);
}

void sub_100210A34(uint64_t a1)
{
  uint64_t v2 = *(void *)(a1 + 40);
  if (qword_1008D9050 != -1) {
    dispatch_once(&qword_1008D9050, &stru_100887A80);
  }
  uint64_t v3 = qword_1008D9048;
  unint64_t v4 = *(void *)(v2 + 128);
  int v5 = (void (***)(void, void *, uint64_t, uint64_t, void, void, void))(v2 + 152);
  int v6 = *(_DWORD *)(v2 + 40);
  uint64_t v7 = *(unsigned __int16 *)(a1 + 48);
  int v8 = *(unsigned __int16 *)(a1 + 56);
  sub_100241F90(uu, *(void *)(a1 + 32));
  sub_100365884(v3, v4, v5, v6, v7, v8, 0, 0, 0, uu, 0, 0);
}

void sub_100210B28(uint64_t a1)
{
  uint64_t v2 = *(void *)(a1 + 40);
  if (qword_1008D9050 != -1) {
    dispatch_once(&qword_1008D9050, &stru_100887A80);
  }
  uint64_t v3 = qword_1008D9048;
  unint64_t v4 = *(void *)(v2 + 128);
  uint64_t v5 = *(unsigned __int16 *)(a1 + 48);
  sub_100241F90(uu, *(void *)(a1 + 32));
  sub_100366E28(v3, v4, v5, uu);
}

void sub_100210BDC(uint64_t a1, int a2, int a3)
{
  int v6 = (os_log_s *)qword_1008F75F0;
  if (os_log_type_enabled((os_log_t)qword_1008F75F0, OS_LOG_TYPE_DEFAULT))
  {
    *(_DWORD *)__int128 buf = 67109376;
    *(_DWORD *)&uint8_t buf[4] = a2;
    LOWORD(v21) = 1024;
    *(_DWORD *)((char *)&v21 + 2) = a3;
    _os_log_impl( (void *)&_mh_execute_header,  v6,  OS_LOG_TYPE_DEFAULT,  "Classic Channel published callback PSM : %u result : %d",  buf,  0xEu);
  }

  *(void *)__int128 buf = 0LL;
  char v21 = buf;
  uint64_t v22 = 0x3032000000LL;
  unint64_t v23 = sub_100210EC0;
  uint64_t v24 = sub_100210ED0;
  id v25 = 0LL;
  uint64_t v16 = 0LL;
  uint64_t v17 = &v16;
  uint64_t v18 = 0x2020000000LL;
  int v19 = 0;
  v15[0] = 0LL;
  v15[1] = 0LL;
  sub_100242F28((uint64_t)v15, a1 + 216);
  uint64_t v7 = *(void **)(a1 + 280);
  v13[0] = _NSConcreteStackBlock;
  v13[1] = 3221225472LL;
  _DWORD v13[2] = sub_100210ED8;
  _OWORD v13[3] = &unk_100887840;
  __int16 v14 = a2;
  v13[4] = buf;
  v13[5] = &v16;
  [v7 enumerateKeysAndObjectsUsingBlock:v13];
  if (*((void *)v21 + 5))
  {
    if (a3)
    {
      if (os_log_type_enabled((os_log_t)qword_1008F75F0, OS_LOG_TYPE_ERROR)) {
        sub_10065F0FC();
      }
      char v12 = 0;
      sub_100242CA4(&v12);
      sub_1001E1520(*((_DWORD *)v17 + 6));
      sub_100242CD0(&v12);
      int v8 = *(void **)(a1 + 280);
      __int16 v9 = (void *)objc_claimAutoreleasedReturnValue( +[NSNumber numberWithUnsignedInt:]( &OBJC_CLASS___NSNumber,  "numberWithUnsignedInt:",  *((unsigned int *)v17 + 6)));
      [v8 removeObjectForKey:v9];

      sub_100242CD8(&v12);
    }

    xpc_object_t v10 = xpc_dictionary_create(0LL, 0LL, 0LL);
    xpc_dictionary_set_int64(v10, "kCBMsgArgResult", a3);
    id v11 = [*((id *)v21 + 5) bytes];
    xpc_dictionary_set_data(v10, "kCBMsgArgServiceUUID", v11, (size_t)[*((id *)v21 + 5) length]);
    sub_10043F1F4(a1, 46LL, v10, 1);
  }

  sub_100242FAC((uint64_t)v15);
  _Block_object_dispose(&v16, 8);
  _Block_object_dispose(buf, 8);
}

void sub_100210E58( _Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, int a9, __int16 a10, char a11, char a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, char a20, uint64_t a21, char a22, uint64_t a23, uint64_t a24, uint64_t a25, char a26)
{
  sub_100242CD8(&a12);
  sub_100242FAC((uint64_t)&a20);
  _Block_object_dispose(&a22, 8);
  _Block_object_dispose(&a26, 8);

  _Unwind_Resume(a1);
}

uint64_t sub_100210EC0(uint64_t result, uint64_t a2)
{
  *(void *)(result + 40) = *(void *)(a2 + 40);
  *(void *)(a2 + 40) = 0LL;
  return result;
}

void sub_100210ED0(uint64_t a1)
{
}

void sub_100210ED8(uint64_t a1, void *a2, void *a3, _BYTE *a4)
{
  id v7 = a2;
  v9[0] = _NSConcreteStackBlock;
  v9[1] = 3221225472LL;
  void v9[2] = sub_100210FA4;
  void v9[3] = &unk_100887818;
  __int16 v12 = *(_WORD *)(a1 + 48);
  __int128 v11 = *(_OWORD *)(a1 + 32);
  id v10 = v7;
  id v8 = v7;
  [a3 enumerateKeysAndObjectsUsingBlock:v9];
  if (*(void *)(*(void *)(*(void *)(a1 + 32) + 8LL) + 40LL)) {
    *a4 = 1;
  }
}

void sub_100210F88( _Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, id a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, void *a15)
{
}

void sub_100210FA4(uint64_t a1, void *a2, void *a3, _BYTE *a4)
{
  id v9 = a2;
  id v7 = a3;
  int v8 = *(unsigned __int16 *)(a1 + 56);
  if ([v9 intValue] == v8)
  {
    objc_storeStrong((id *)(*(void *)(*(void *)(a1 + 40) + 8LL) + 40LL), a3);
    *(_DWORD *)(*(void *)(*(void *)(a1 + 48) + 8) + 24) = [*(id *)(a1 + 32) intValue];
    *a4 = 1;
  }
}

void sub_10021103C( _Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, id a10)
{
  _Unwind_Resume(a1);
}

void sub_100211054(uint64_t a1, int a2, int a3)
{
}

void sub_10021105C(uint64_t a1, int a2, int a3)
{
  int v6 = (os_log_s *)qword_1008F75F0;
  if (os_log_type_enabled((os_log_t)qword_1008F75F0, OS_LOG_TYPE_DEFAULT))
  {
    *(_DWORD *)__int128 buf = 67109376;
    *(_DWORD *)&uint8_t buf[4] = a2;
    LOWORD(vmemset(v6, 0, 22) = 1024;
    *(_DWORD *)((char *)&v22 + 2) = a3;
    _os_log_impl( (void *)&_mh_execute_header,  v6,  OS_LOG_TYPE_DEFAULT,  "Classic Channel unpublished callback PSM : %u, result : %d",  buf,  0xEu);
  }

  *(void *)__int128 buf = 0LL;
  uint64_t v22 = buf;
  uint64_t v23 = 0x3032000000LL;
  uint64_t v24 = sub_100210EC0;
  id v25 = sub_100210ED0;
  id v26 = 0LL;
  uint64_t v15 = 0LL;
  uint64_t v16 = &v15;
  uint64_t v17 = 0x2020000000LL;
  int v18 = 0;
  v14[0] = 0LL;
  v14[1] = 0LL;
  sub_100242F28((uint64_t)v14, a1 + 216);
  id v7 = *(void **)(a1 + 280);
  v12[0] = _NSConcreteStackBlock;
  v12[1] = 3221225472LL;
  _DWORD v12[2] = sub_1002112F4;
  v12[3] = &unk_100887840;
  __int16 v13 = a2;
  v12[4] = buf;
  void v12[5] = &v15;
  [v7 enumerateKeysAndObjectsUsingBlock:v12];
  if (*((void *)v22 + 5))
  {
    int v8 = (os_log_s *)qword_1008F75F0;
    if (os_log_type_enabled((os_log_t)qword_1008F75F0, OS_LOG_TYPE_DEFAULT))
    {
      int v9 = *((_DWORD *)v16 + 6);
      *(_DWORD *)int v19 = 67109120;
      int v20 = v9;
      _os_log_impl( (void *)&_mh_execute_header,  v8,  OS_LOG_TYPE_DEFAULT,  "Classic Channel unpublished removing SRH 0x%X",  v19,  8u);
    }

    v19[0] = 0;
    sub_100242CA4(v19);
    sub_1001E1520(*((_DWORD *)v16 + 6));
    sub_100242CD0(v19);
    id v10 = *(void **)(a1 + 280);
    __int128 v11 = (void *)objc_claimAutoreleasedReturnValue( +[NSNumber numberWithUnsignedInt:]( &OBJC_CLASS___NSNumber,  "numberWithUnsignedInt:",  *((unsigned int *)v16 + 6)));
    [v10 removeObjectForKey:v11];

    sub_100242CD8(v19);
  }

  sub_100242FAC((uint64_t)v14);
  _Block_object_dispose(&v15, 8);
  _Block_object_dispose(buf, 8);
}

void sub_100211290( _Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, ...)
{
  uint64_t v12 = va_arg(va1, void);
  uint64_t v14 = va_arg(va1, void);
  va_copy(va2, va1);
  uint64_t v15 = va_arg(va2, void);
  uint64_t v17 = va_arg(va2, void);
  uint64_t v18 = va_arg(va2, void);
  uint64_t v19 = va_arg(va2, void);

  sub_100242CD8(va2);
  sub_100242FAC((uint64_t)va);
  _Block_object_dispose(va1, 8);
  _Block_object_dispose((const void *)(v10 - 112), 8);

  _Unwind_Resume(a1);
}

void sub_1002112F4(uint64_t a1, void *a2, void *a3, _BYTE *a4)
{
  id v7 = a2;
  v9[0] = _NSConcreteStackBlock;
  v9[1] = 3221225472LL;
  void v9[2] = sub_1002113C0;
  void v9[3] = &unk_100887818;
  __int16 v12 = *(_WORD *)(a1 + 48);
  __int128 v11 = *(_OWORD *)(a1 + 32);
  id v10 = v7;
  id v8 = v7;
  [a3 enumerateKeysAndObjectsUsingBlock:v9];
  if (*(void *)(*(void *)(*(void *)(a1 + 32) + 8LL) + 40LL)) {
    *a4 = 1;
  }
}

void sub_1002113A4( _Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, id a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, void *a15)
{
}

void sub_1002113C0(uint64_t a1, void *a2, void *a3, _BYTE *a4)
{
  id v9 = a2;
  id v7 = a3;
  int v8 = *(unsigned __int16 *)(a1 + 56);
  if ([v9 intValue] == v8)
  {
    objc_storeStrong((id *)(*(void *)(*(void *)(a1 + 40) + 8LL) + 40LL), a3);
    *(_DWORD *)(*(void *)(*(void *)(a1 + 48) + 8) + 24) = [*(id *)(a1 + 32) intValue];
    *a4 = 1;
  }
}

void sub_100211458( _Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, id a10)
{
  _Unwind_Resume(a1);
}

void sub_100211470(uint64_t a1, int a2, int a3)
{
}

void sub_100211478(uint64_t a1, void *a2, int a3, unsigned int a4, int a5, BOOL a6, int a7)
{
  id v13 = a2;
  uint64_t v14 = (os_log_s *)qword_1008F75F0;
  if (os_log_type_enabled((os_log_t)qword_1008F75F0, OS_LOG_TYPE_DEFAULT))
  {
    unint64_t v18 = __PAIR64__(a3, 67109888);
    LOWORD(v19) = 1024;
    *(_DWORD *)((char *)&v19 + 2) = a4;
    HIWORD(v19) = 1024;
    int v20 = a5;
    __int16 v21 = 1024;
    int v22 = a7;
    _os_log_impl( (void *)&_mh_execute_header,  v14,  OS_LOG_TYPE_DEFAULT,  "Classic Channel connected callback : result: 0x%x, psm: 0x%x, cid: 0x%x, sock: 0x%x",  (uint8_t *)&v18,  0x1Au);
  }

  xpc_object_t v15 = xpc_dictionary_create(0LL, 0LL, 0LL);
  id v16 = v13;
  uint64_t v17 = v16;
  if (v16)
  {
    unint64_t v18 = 0LL;
    uint64_t v19 = 0LL;
    [v16 getUUIDBytes:&v18];
    xpc_dictionary_set_uuid(v15, "kCBMsgArgDeviceUUID", (const unsigned __int8 *)&v18);
  }

  xpc_dictionary_set_int64(v15, "kCBMsgArgResult", a3);
  xpc_dictionary_set_int64(v15, "kCBMsgArgPSM", a4);
  xpc_dictionary_set_fd(v15, "kCBMsgArgSocket", a7);
  xpc_dictionary_set_BOOL(v15, "kCBMsgArgIsIncoming", a6);
  sub_10043F1F4(a1, 23LL, v15, 1);
}

void sub_100211614(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_100211638(uint64_t a1, void *a2, int a3, unsigned int a4, int a5, BOOL a6, int a7)
{
}

void sub_100211640(uint64_t a1, void *a2, int a3, unsigned int a4, int a5)
{
  id v9 = a2;
  id v10 = (os_log_s *)qword_1008F75F0;
  if (os_log_type_enabled((os_log_t)qword_1008F75F0, OS_LOG_TYPE_DEFAULT))
  {
    LODWORD(v14) = 67109632;
    HIDWORD(v14) = a3;
    LOWORD(v15) = 1024;
    *(_DWORD *)((char *)&v15 + 2) = a4;
    HIWORD(v15) = 1024;
    int v16 = a5;
    _os_log_impl( (void *)&_mh_execute_header,  v10,  OS_LOG_TYPE_DEFAULT,  "Classic Channel disconnected callback result : %d, psm : %u, cid = %u",  (uint8_t *)&v14,  0x14u);
  }

  xpc_object_t v11 = xpc_dictionary_create(0LL, 0LL, 0LL);
  id v12 = v9;
  id v13 = v12;
  if (v12)
  {
    uint64_t v14 = 0LL;
    uint64_t v15 = 0LL;
    [v12 getUUIDBytes:&v14];
    xpc_dictionary_set_uuid(v11, "kCBMsgArgDeviceUUID", (const unsigned __int8 *)&v14);
  }

  xpc_dictionary_set_int64(v11, "kCBMsgArgResult", a3);
  xpc_dictionary_set_int64(v11, "kCBMsgArgPSM", a4);
  sub_10043F1F4(a1, 24LL, v11, 1);
}

void sub_1002117A0(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_1002117C4(uint64_t a1, void *a2, int a3, unsigned int a4, int a5)
{
}

uint64_t sub_1002117CC(uint64_t a1, uint64_t a2, void *a3, int a4)
{
  id v5 = a3;
  memset(v16, 0, sizeof(v16));
  unsigned int v15 = 0;
  byte_1008EF910 = 1;
  word_1008EF912 = 2;
  dword_1008EF918 = a4;
  if ([v5 length] == (id)2)
  {
    id v6 = [v5 bytes];
    __int16 v7 = 2;
  }

  else
  {
    id v8 = [v5 length];
    id v6 = [v5 bytes];
    if (v8 == (id)4) {
      __int16 v7 = 4;
    }
    else {
      __int16 v7 = 16;
    }
  }

  unsigned __int8 v9 = atomic_load((unsigned __int8 *)&qword_1008EF930);
  if ((v9 & 1) == 0)
  {
    uint64_t v13 = (uint64_t)v6;
    if (__cxa_guard_acquire(&qword_1008EF930))
    {
      byte_1008EF920 = 3;
      word_1008EF922 = v7;
      qword_1008EF928 = v13;
      __cxa_guard_release(&qword_1008EF930);
    }
  }

  *(void *)&v16[0] = &unk_100887890;
  WORD4(v16[0]) = 3;
  char v14 = 0;
  sub_100242CA4(&v14);
  int v10 = sub_1001E139C((uint64_t)v16, (int *)&v15);
  sub_100242CD0(&v14);
  if (v10)
  {
    uint64_t v11 = 0LL;
    unsigned int v15 = 0;
  }

  else
  {
    uint64_t v11 = v15;
  }

  sub_100242CD8(&v14);

  return v11;
}

void sub_100211920(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

uint64_t sub_100211950(uint64_t a1, void *a2)
{
  id v2 = a2;
  uint64_t v3 = (os_log_s *)qword_1008F75F0;
  if (os_log_type_enabled((os_log_t)qword_1008F75F0, OS_LOG_TYPE_DEFAULT))
  {
    *(_DWORD *)__int128 buf = 138412290;
    *(void *)&uint8_t buf[4] = v2;
    _os_log_impl((void *)&_mh_execute_header, v3, OS_LOG_TYPE_DEFAULT, "addServiceDataToLocalSDP: %@", buf, 0xCu);
  }

  unint64_t v4 = v2;
  if (v2)
  {
    if ([v2 length])
    {
      uint64_t v76 = 0LL;
      uint64_t v77 = 0LL;
      *(_OWORD *)__int128 buf = 0u;
      __int128 v83 = 0u;
      unsigned int v75 = 0;
      id v59 = v2;
      id v5 = v2;
      if ([v5 bytes])
      {
        if ([v5 length])
        {
          HIBYTE(v7memset((char *)&v11[1] + 1, 0, 7) = 0;
          id v6 = v5;
          uint64_t v76 = (unsigned __int16 *)[v6 bytes];
          LOWORD(v7memset((char *)&v11[1] + 1, 0, 7) = (unsigned __int16)[v6 length];
          WORD1(v7memset((char *)&v11[1] + 1, 0, 7) = (unsigned __int16)[v6 length];
          __int16 v7 = "((byteStreamData).__data != NULL) && ((byteStreamData).__trueSize > 0)";
          int v8 = 1529;
          if (v76 && (_WORD)v77)
          {
            BYTE6(v7memset((char *)&v11[1] + 1, 0, 7) = 1;
            *(_DWORD *)((char *)&v77 + 2) = (unsigned __int16)v77;
            if ((unsigned __int16)v77 > 1u)
            {
              size_t v9 = *v76;
              WORD2(v7memset((char *)&v11[1] + 1, 0, 7) = 2;
              int v10 = (os_log_s *)qword_1008F75F0;
              if (os_log_type_enabled((os_log_t)qword_1008F75F0, OS_LOG_TYPE_DEFAULT))
              {
                LODWORD(v80) = 67109376;
                DWORD1(v80) = v9;
                WORD4(v80) = 1024;
                *(_DWORD *)((char *)&v80 + 10) = v9;
                _os_log_impl( (void *)&_mh_execute_header,  v10,  OS_LOG_TYPE_DEFAULT,  "addServiceDataToLocalSDP: Number of attributes: %d, 0x%x",  (uint8_t *)&v80,  0xEu);
              }

              uint64_t v11 = (char *)calloc(v9, 0x18uLL);
              if (v11)
              {
                if ((_DWORD)v9)
                {
                  LODWORD(v12) = 0;
                  uint64_t v13 = "ByteStream_NumReadBytesAvail(byteStreamData) >= 2";
                  while (1)
                  {
                    if (HIBYTE(v77))
                    {
                      sub_1001ED1C4((uint64_t)"/Library/Caches/com.apple.xbs/Sources/MobileBluetooth_base/Daemon/Server/Xp"
                                             "cClassicConnection.mm");
                      uint64_t v13 = "ByteStream_NumReadBytesAvail(byteStreamData) >= 2";
LABEL_95:
                      sub_1000E6B88( "/Library/Caches/com.apple.xbs/Sources/MobileBluetooth_base/Daemon/Server/XpcClassicConnection.mm",  1544,  v13);
                    }

                    if (WORD1(v77) - WORD2(v77) <= 1) {
                      goto LABEL_95;
                    }
                    if (BYTE6(v77) != 1)
                    {
                      uint64_t v13 = "(byteStreamData).__RWFlag == BYTESTREAM_READ";
                      goto LABEL_95;
                    }

                    uint64_t v14 = *(unsigned __int16 *)((char *)v76 + WORD2(v77));
                    WORD2(v77) += 2;
                    unsigned int v15 = &v11[24 * (unsigned __int16)v12];
                    *(_WORD *)unsigned int v15 = v14;
                    if (v14 <= 8 && ((1 << v14) & 0x165) != 0)
                    {
                      LOWORD(v9) = v9 - 1;
                      LODWORD(v12) = v12 - 1;
                    }

                    LODWORD(v12) = v12 + 1;
                  }

                  uint64_t v32 = (os_log_s *)qword_1008F75F0;
                  if (os_log_type_enabled((os_log_t)qword_1008F75F0, OS_LOG_TYPE_ERROR)) {
                    sub_10065F350(v14, v32, v33, v34, v35, v36, v37, v38);
                  }
                  unint64_t v4 = v59;
                  if ((_WORD)v12)
                  {
                    int v39 = v11 + 8;
                    uint64_t v12 = (unsigned __int16)v12;
                    do
                    {
                      sub_10025EB84(v39);
                      v39 += 24;
                      --v12;
                    }

                    while (v12);
                  }

                  free(v11);
                  goto LABEL_61;
                }

void sub_10021227C( _Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, void *a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20, uint64_t a21, uint64_t a22, uint64_t a23, uint64_t a24, uint64_t a25, uint64_t a26, uint64_t a27, uint64_t a28, uint64_t a29, uint64_t a30, uint64_t a31, uint64_t a32, uint64_t a33, uint64_t a34, uint64_t a35, uint64_t a36, uint64_t a37, __int16 a38, char a39, char a40, uint64_t a41, uint64_t a42, uint64_t a43, uint64_t a44, char a45)
{
  sub_100242CD8(&a40);
  _Unwind_Resume(a1);
}

id sub_100212350(uint64_t a1, uint64_t a2)
{
  uint64_t v3 = (void *)objc_claimAutoreleasedReturnValue(+[NSMutableArray array](&OBJC_CLASS___NSMutableArray, "array"));
  if (*(_WORD *)a2 == 1 && *(_BYTE *)(a2 + 8) == 6)
  {
    uint64_t v4 = *(unsigned __int16 *)(a2 + 10);
    if (*(_WORD *)(a2 + 10))
    {
      for (unint64_t i = *(__int128 **)(a2 + 16); ; ++i)
      {
        __int128 v9 = *i;
        if (!--v4) {
          return v3;
        }
      }

      if (WORD1(v9) == 16)
      {
        __int128 v10 = **((_OWORD **)&v9 + 1);
        id v6 = [NSData dataWithBytes:&v10 length:16];
        [v3 addObject:v6];
      }

      else
      {
        __int16 v7 = (void *)objc_claimAutoreleasedReturnValue( +[NSData dataWithBytes:length:]( &OBJC_CLASS___NSData,  "dataWithBytes:length:",  (char *)&v9 + 8,  4LL));
        [v3 addObject:v7];
      }
    }
  }

  return v3;
}

void sub_100212478(_Unwind_Exception *a1)
{
  uint64_t v3 = v2;

  _Unwind_Resume(a1);
}

uint64_t sub_1002124B4(uint64_t a1, uint64_t a2)
{
  if (*(_BYTE *)a2 == 6)
  {
    __int128 v11 = xmmword_1006BF460;
    if (*(_WORD *)(a2 + 2))
    {
      uint64_t v4 = 0LL;
      unint64_t v5 = 1LL;
      do
      {
        if (*(_BYTE *)(*(void *)(a2 + 8) + v4) == 6)
        {
          LODWORD(result) = sub_1002124B4(a1, *(void *)(a2 + 8) + v4);
          if ((_DWORD)result) {
            return (unsigned __int16)result;
          }
          unint64_t v7 = *(unsigned __int16 *)(a2 + 2);
        }

        else
        {
          BOOL v8 = sub_10025FC8C(*(void *)(a2 + 8) + v4, (uint64_t)&v11);
          unint64_t v7 = *(unsigned __int16 *)(a2 + 2);
          BOOL v9 = !v8 || v5 >= v7;
          if (!v9)
          {
            uint64_t v10 = *(void *)(a2 + 8) + v4;
            if (*(_BYTE *)(v10 + 16) == 1)
            {
              LODWORD(result) = *(_DWORD *)(v10 + 24);
              return (unsigned __int16)result;
            }
          }
        }

        v4 += 16LL;
        BOOL v9 = v5++ >= v7;
      }

      while (!v9);
    }
  }

  LOWORD(result) = 0;
  return (unsigned __int16)result;
}

void sub_100212590(uint64_t a1)
{
  uint64_t v2 = *(void *)(a1 + 32);
  if (qword_1008D9050 != -1) {
    dispatch_once(&qword_1008D9050, &stru_100887A80);
  }
  sub_1003643FC( qword_1008D9048,  *(void *)(v2 + 128),  v2 + 152,  *(_DWORD *)(v2 + 40),  *(_WORD *)(a1 + 40),  0,  0,  0,  0,  0,  0,  0);
}

void sub_100212614(uint64_t a1, uint64_t a2, void *a3, _BYTE *a4)
{
  v9[0] = _NSConcreteStackBlock;
  v9[1] = 3221225472LL;
  void v9[2] = sub_1002126C0;
  void v9[3] = &unk_100887900;
  id v7 = *(id *)(a1 + 32);
  uint64_t v8 = *(void *)(a1 + 40);
  id v10 = v7;
  uint64_t v11 = v8;
  [a3 enumerateKeysAndObjectsUsingBlock:v9];
  if (*(_BYTE *)(*(void *)(*(void *)(a1 + 40) + 8LL) + 24LL)) {
    *a4 = 1;
  }
}

void sub_1002126AC( _Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, void *a13)
{
}

id sub_1002126C0(uint64_t a1, uint64_t a2, void *a3, _BYTE *a4)
{
  id result = [a3 isEqualToData:*(void *)(a1 + 32)];
  if ((_DWORD)result)
  {
    *(_BYTE *)(*(void *)(*(void *)(a1 + 40) + 8LL) + 24LL) = 1;
    *a4 = 1;
  }

  return result;
}

void sub_100212708(uint64_t a1)
{
  uint64_t v2 = *(void *)(a1 + 32);
  if (qword_1008D9050 != -1) {
    dispatch_once(&qword_1008D9050, &stru_100887A80);
  }
  sub_1003643FC( qword_1008D9048,  *(void *)(v2 + 128),  v2 + 152,  *(_DWORD *)(v2 + 40),  *(_WORD *)(a1 + 40),  0,  0,  0,  0,  0,  0,  0);
}

void sub_10021278C(uint64_t a1, void *a2, void *a3, _BYTE *a4)
{
  id v7 = a2;
  v13[0] = _NSConcreteStackBlock;
  v13[1] = 3221225472LL;
  _DWORD v13[2] = sub_100212878;
  _OWORD v13[3] = &unk_100887950;
  id v8 = *(id *)(a1 + 32);
  uint64_t v9 = *(void *)(a1 + 40);
  id v14 = v8;
  uint64_t v16 = v9;
  id v10 = v7;
  uint64_t v11 = *(void *)(a1 + 48);
  id v12 = v10;
  id v15 = v10;
  uint64_t v17 = v11;
  [a3 enumerateKeysAndObjectsUsingBlock:v13];
  if (*(_DWORD *)(*(void *)(*(void *)(a1 + 40) + 8LL) + 24LL)) {
    *a4 = 1;
  }
}

void sub_100212854( _Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, id a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, void *a15, void *a16)
{
}

void sub_100212878(uint64_t a1, void *a2, void *a3, _BYTE *a4)
{
  id v8 = a2;
  id v7 = a3;
  if ([v7 isEqualToData:*(void *)(a1 + 32)])
  {
    *(_DWORD *)(*(void *)(*(void *)(a1 + 48) + 8) + 24) = [*(id *)(a1 + 40) intValue];
    *(_WORD *)(*(void *)(*(void *)(a1 + 56) + 8) + 24) = (unsigned __int16)[v8 intValue];
    *a4 = 1;
  }
}

void sub_100212904( _Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, id a10)
{
  _Unwind_Resume(a1);
}

void sub_10021291C(uint64_t a1)
{
  uint64_t v2 = *(void *)(a1 + 40);
  if (qword_1008D9050 != -1) {
    dispatch_once(&qword_1008D9050, &stru_100887A80);
  }
  sub_1003651CC( (void *)qword_1008D9048,  *(void *)(v2 + 128),  *(unsigned __int16 *)(*(void *)(*(void *)(a1 + 32) + 8LL) + 24LL));
}

void sub_10021297C(uint64_t a1, void *a2, void *a3)
{
  id v5 = a2;
  uint64_t v6 = *(void *)(a1 + 32);
  v8[0] = _NSConcreteStackBlock;
  v8[1] = 3221225472LL;
  _DWORD v8[2] = sub_100212A18;
  v8[3] = &unk_1008879A0;
  id v9 = v5;
  uint64_t v10 = v6;
  id v7 = v5;
  [a3 enumerateKeysAndObjectsUsingBlock:v8];
}

void sub_1002129FC( _Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, id a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, void *a15)
{
}

void sub_100212A18(uint64_t a1, void *a2, void *a3)
{
  id v5 = a2;
  id v6 = a3;
  uint64_t v7 = *(void *)(a1 + 40);
  char v16 = 0;
  sub_100242CA4(&v16);
  LODWORD(a1) = sub_1001E1520((int)[*(id *)(a1 + 32) intValue]);
  sub_100242CD0(&v16);
  if (!(_DWORD)a1)
  {
    id v8 = (os_log_s *)qword_1008F75F0;
    if (os_log_type_enabled((os_log_t)qword_1008F75F0, OS_LOG_TYPE_DEFAULT))
    {
      sub_100494958(*(void *)(v7 + 128), (uint64_t)__p);
      if (v15 >= 0) {
        id v9 = __p;
      }
      else {
        id v9 = (void **)__p[0];
      }
      *(_DWORD *)__int128 buf = 138412546;
      id v18 = v6;
      __int16 v19 = 2082;
      int v20 = v9;
      _os_log_impl( (void *)&_mh_execute_header,  v8,  OS_LOG_TYPE_DEFAULT,  "Successfully removed service uuid %@  for session %{public}s",  buf,  0x16u);
      if (v15 < 0) {
        operator delete(__p[0]);
      }
    }

    uint64_t v10 = sub_100404FE8();
    v11[0] = _NSConcreteStackBlock;
    v11[1] = 3221225472LL;
    void v11[2] = sub_100212BE8;
    _OWORD v11[3] = &unk_1008800B8;
    uint64_t v13 = v7;
    id v12 = v5;
    sub_100405384(v10, v11);
  }

  sub_100242CD8(&v16);
}

void sub_100212BA8( _Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, int a18, __int16 a19, char a20, char a21)
{
  _Unwind_Resume(a1);
}

void sub_100212BE8(uint64_t a1)
{
  uint64_t v2 = *(void *)(a1 + 40);
  if (qword_1008D9050 != -1) {
    dispatch_once(&qword_1008D9050, &stru_100887A80);
  }
  sub_1003651CC( (void *)qword_1008D9048,  *(void *)(v2 + 128),  (unsigned __int16)[*(id *)(a1 + 32) intValue]);
}

void sub_100212C64( uint64_t a1, void *a2, int a3, unsigned int a4, unsigned int a5, int a6, BOOL a7, int a8)
{
  id v15 = a2;
  char v16 = (os_log_s *)qword_1008F75F0;
  if (os_log_type_enabled((os_log_t)qword_1008F75F0, OS_LOG_TYPE_DEFAULT))
  {
    LODWORD(v26) = 67110400;
    HIDWORD(v26) = a3;
    LOWORD(v2memset((char *)&v11[1] + 1, 0, 7) = 1024;
    *(_DWORD *)((char *)&v27 + 2) = a4;
    HIWORD(v2memset((char *)&v11[1] + 1, 0, 7) = 1024;
    unsigned int v28 = a5;
    __int16 v29 = 1024;
    int v30 = a6;
    __int16 v31 = 1024;
    BOOL v32 = a7;
    __int16 v33 = 1024;
    int v34 = a8;
    _os_log_impl( (void *)&_mh_execute_header,  v16,  OS_LOG_TYPE_DEFAULT,  "RFCOMM Channel connected: result: 0x%x, rfcommChannelID: 0x%x, frameSize: 0x%x, link handle: 0x%x, incoming?: %d, sock: 0x%x",  (uint8_t *)&v26,  0x26u);
  }

  xpc_object_t v17 = xpc_dictionary_create(0LL, 0LL, 0LL);
  id v18 = v15;
  __int16 v19 = v18;
  if (v18)
  {
    uint64_t v26 = 0LL;
    uint64_t v27 = 0LL;
    [v18 getUUIDBytes:&v26];
    xpc_dictionary_set_uuid(v17, "kCBMsgArgDeviceUUID", (const unsigned __int8 *)&v26);
  }

  xpc_dictionary_set_int64(v17, "kCBMsgArgResult", a3);
  xpc_dictionary_set_int64(v17, "kCBMsgArgRFCOMMChannelID", a4);
  xpc_dictionary_set_int64(v17, "kCBMsgArgMTU", a5);
  xpc_dictionary_set_BOOL(v17, "kCBMsgArgIsIncoming", a7);
  xpc_dictionary_set_fd(v17, "kCBMsgArgSocket", a8);
  if (qword_1008D5F30 != -1) {
    dispatch_once(&qword_1008D5F30, &stru_100887B00);
  }
  uint64_t v20 = sub_1005CC198((uint64_t)off_1008D5F28, v19, 0);
  if (qword_1008D5F50 != -1) {
    dispatch_once(&qword_1008D5F50, &stru_100887B20);
  }
  id v21 = sub_10040007C(off_1008D5F48, v20, 0);
  if (v21)
  {
    id v22 = sub_1003E3854((uint64_t)v21, a4);
    id v23 = (void *)objc_claimAutoreleasedReturnValue(v22);
    uint64_t v24 = v23;
    if (v23)
    {
      id v25 = v23;
      xpc_dictionary_set_data( v17,  "kCBMsgArgServiceUUID",  [v25 bytes],  (size_t)[v25 length]);
    }
  }

  sub_10043F1F4(a1, 56LL, v17, 1);
}

void sub_100212F00(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_100212F3C( uint64_t a1, void *a2, int a3, unsigned int a4, unsigned int a5, int a6, BOOL a7, int a8)
{
}

void sub_100212F44(uint64_t a1, void *a2, int a3, unsigned int a4, int a5)
{
  id v9 = a2;
  uint64_t v10 = (os_log_s *)qword_1008F75F0;
  if (os_log_type_enabled((os_log_t)qword_1008F75F0, OS_LOG_TYPE_DEFAULT))
  {
    LODWORD(v14) = 67109632;
    HIDWORD(v14) = a3;
    LOWORD(v15) = 1024;
    *(_DWORD *)((char *)&v15 + 2) = a4;
    HIWORD(v15) = 1024;
    int v16 = a5;
    _os_log_impl( (void *)&_mh_execute_header,  v10,  OS_LOG_TYPE_DEFAULT,  "RFCOMM Channel disconnected: result: 0x%x, rfcommChannelID: 0x%x, link handle: 0x%x",  (uint8_t *)&v14,  0x14u);
  }

  xpc_object_t v11 = xpc_dictionary_create(0LL, 0LL, 0LL);
  id v12 = v9;
  uint64_t v13 = v12;
  if (v12)
  {
    uint64_t v14 = 0LL;
    uint64_t v15 = 0LL;
    [v12 getUUIDBytes:&v14];
    xpc_dictionary_set_uuid(v11, "kCBMsgArgDeviceUUID", (const unsigned __int8 *)&v14);
  }

  xpc_dictionary_set_int64(v11, "kCBMsgArgResult", a3);
  xpc_dictionary_set_int64(v11, "kCBMsgArgRFCOMMChannelID", a4);
  sub_10043F1F4(a1, 57LL, v11, 1);
}

void sub_1002130A4(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_1002130C8(uint64_t a1, void *a2, int a3, unsigned int a4, int a5)
{
}

char *sub_1002130D0(uint64_t a1, int a2)
{
  return off_100887448[a2];
}

void sub_1002130F8(id a1)
{
  uint64_t v1 = operator new(0x230uLL);
  sub_10042BC28();
  off_1008D60A8 = v1;
}

void sub_100213128(_Unwind_Exception *a1)
{
}

void sub_10021313C(id a1)
{
  uint64_t v1 = operator new(0x1A0uLL);
  sub_1002769A4();
  off_1008D67C0 = v1;
}

void sub_10021316C(_Unwind_Exception *a1)
{
}

void sub_100213180(id a1)
{
  uint64_t v1 = operator new(0x70uLL);
  sub_1003639FC((uint64_t)v1);
  qword_1008D9048 = (uint64_t)v1;
}

void sub_1002131B0(_Unwind_Exception *a1)
{
}

void sub_1002131C4(id a1)
{
  uint64_t v1 = operator new(0xA8uLL);
  sub_10040D0A0((uint64_t)v1);
  off_1008D6780 = v1;
}

void sub_1002131F4(_Unwind_Exception *a1)
{
}

void sub_100213208(id a1)
{
  uint64_t v1 = operator new(0x2B0uLL);
  sub_10040749C((uint64_t)v1);
  off_1008D5EF8 = v1;
}

void sub_100213238(_Unwind_Exception *a1)
{
}

void sub_10021324C(id a1)
{
  uint64_t v1 = operator new(0x260uLL);
  sub_1005285C8((uint64_t)v1);
  off_1008D67A0 = v1;
}

void sub_10021327C(_Unwind_Exception *a1)
{
}

void sub_100213290(id a1)
{
  uint64_t v1 = operator new(0x128uLL);
  sub_1005C69F8();
  off_1008D5F28 = v1;
}

void sub_1002132C0(_Unwind_Exception *a1)
{
}

void sub_1002132D4(id a1)
{
  uint64_t v1 = operator new(0x138uLL);
  sub_1003FE3E0((uint64_t)v1);
  off_1008D5F48 = v1;
}

void sub_100213304(_Unwind_Exception *a1)
{
}

void sub_100213318(id a1)
{
  uint64_t v1 = operator new(0x2C0uLL);
  sub_1004219F0();
  off_1008D60C8 = v1;
}

void sub_100213348(_Unwind_Exception *a1)
{
}

void sub_10021335C(id a1)
{
  uint64_t v1 = operator new(0x260uLL);
  sub_100451734((uint64_t)v1);
  off_1008D63D0 = v1;
}

void sub_10021338C(_Unwind_Exception *a1)
{
}

void sub_1002133A0(id a1)
{
  uint64_t v1 = operator new(0x18uLL);
  *(void *)uint64_t v1 = 0LL;
  v1[2] = 0;
  *((_BYTE *)v1 + 12) = 0;
  v1[4] = 0;
  qword_1008D9058 = (uint64_t)v1;
}

void sub_1002133D0(id a1)
{
  uint64_t v1 = operator new(0x118uLL);
  sub_1003ADFF0((uint64_t)v1);
  off_1008D5F38 = v1;
}

void sub_100213400(_Unwind_Exception *a1)
{
}

void sub_100213414(id a1)
{
  uint64_t v1 = operator new(0x2C8uLL);
  sub_100213DA8();
  off_1008D60D8 = v1;
}

void sub_100213444(_Unwind_Exception *a1)
{
}

uint64_t sub_100213458(uint64_t a1)
{
  uint64_t v2 = (void *)sub_10041BFD4(a1, "AACPService", 0x80000);
  *uint64_t v2 = off_100887BF0;
  sub_100242DC4(v2 + 41);
  *(_OWORD *)(a1 + 400) = 0u;
  *(_OWORD *)(a1 + 416) = 0u;
  if (qword_1008D60E0 != -1) {
    dispatch_once(&qword_1008D60E0, &stru_100887D00);
  }
  uint64_t v3 = off_1008D60D8;
  *(void *)(a1 + 424) = off_1008D60D8;
  sub_10041C264(a1, (uint64_t)v3);
  return a1;
}

void sub_1002134F0(_Unwind_Exception *a1)
{
  uint64_t v4 = v3;
  id v6 = *v4;
  if (*v4)
  {
    *(void *)(v1 + 40std::ostream::~ostream(v2, v3 + 8) = v6;
    operator delete(v6);
  }

  sub_100242E28(v2);
  sub_10041C0C4(v1);
  _Unwind_Resume(a1);
}

uint64_t sub_10021352C(void *a1)
{
  *a1 = off_100887BF0;
  uint64_t v2 = (void *)a1[50];
  if (v2)
  {
    a1[51] = v2;
    operator delete(v2);
  }

  sub_100242E28(a1 + 41);
  return sub_10041C0C4((uint64_t)a1);
}

void sub_100213574(void *a1)
{
  uint64_t v1 = (void *)sub_10021352C(a1);
  operator delete(v1);
}

uint64_t sub_100213588(uint64_t a1)
{
  uint64_t v2 = (os_log_s *)qword_1008F7560;
  if (os_log_type_enabled((os_log_t)qword_1008F7560, OS_LOG_TYPE_DEFAULT))
  {
    *(_WORD *)uint64_t v4 = 0;
    _os_log_impl((void *)&_mh_execute_header, v2, OS_LOG_TYPE_DEFAULT, "AACPService start", v4, 2u);
  }

  return sub_10041C414(a1);
}

uint64_t sub_1002135F8(uint64_t a1)
{
  uint64_t v2 = (os_log_s *)qword_1008F7560;
  if (os_log_type_enabled((os_log_t)qword_1008F7560, OS_LOG_TYPE_DEFAULT))
  {
    *(_WORD *)uint64_t v4 = 0;
    _os_log_impl((void *)&_mh_execute_header, v2, OS_LOG_TYPE_DEFAULT, "AACPService stop", v4, 2u);
  }

  return sub_10041C708(a1);
}

uint64_t sub_100213668(uint64_t a1, uint64_t a2)
{
  __int128 v8 = unk_100887CE0;
  if (sub_1003D518C(a2))
  {
    if (sub_1003D2E50(a2, &v8, 4u)) {
      int v4 = 4;
    }
    else {
      int v4 = 1;
    }
  }

  else
  {
    int v4 = 0;
  }

  unsigned int v5 = *(_DWORD *)(a1 + 32);
  uint64_t v9 = 0LL;
  sub_1000B0400((uint64_t)&v9);
  *(void *)&__int128 v7 = (int)v9;
  *((void *)&v7 + 1) = SWORD2(v9);
  return sub_1003D1FC4(a2, v5, v4, &v7, 0);
}

BOOL sub_10021370C(uint64_t a1, uint64_t a2, _BYTE *a3)
{
  __int128 v6 = unk_100887CF0;
  *a3 = 0;
  BOOL result = sub_1003D518C(a2);
  if (result)
  {
    BOOL result = sub_1003D2E50(a2, &v6, 4u);
    if (result) {
      *a3 = 1;
    }
  }

  return result;
}

void sub_100213770(void *a1, uint64_t a2)
{
  int v4 = (uint64_t *)a1[50];
  unsigned int v5 = (uint64_t *)a1[51];
  if (v4 == v5)
  {
LABEL_5:
    unint64_t v7 = a1[52];
    if ((unint64_t)v5 >= v7)
    {
      uint64_t v9 = v5 - v4;
      uint64_t v10 = v7 - (void)v4;
      uint64_t v11 = v10 >> 2;
      else {
        unint64_t v12 = v11;
      }
      if (v12) {
        uint64_t v13 = (char *)sub_100008BA0((uint64_t)(a1 + 52), v12);
      }
      else {
        uint64_t v13 = 0LL;
      }
      uint64_t v15 = (uint64_t *)&v13[8 * v9];
      int v16 = &v13[8 * v12];
      uint64_t *v15 = a2;
      __int128 v8 = v15 + 1;
      id v18 = (char *)a1[50];
      xpc_object_t v17 = (char *)a1[51];
      if (v17 != v18)
      {
        do
        {
          uint64_t v19 = *((void *)v17 - 1);
          v17 -= 8;
          *--uint64_t v15 = v19;
        }

        while (v17 != v18);
        xpc_object_t v17 = (char *)a1[50];
      }

      a1[50] = v15;
      a1[51] = v8;
      a1[52] = v16;
      if (v17) {
        operator delete(v17);
      }
    }

    else
    {
      *unsigned int v5 = a2;
      __int128 v8 = v5 + 1;
    }

    a1[51] = v8;
  }

  else
  {
    __int128 v6 = (void *)a1[50];
    while (*v6 != a2)
    {
      if (++v6 == v5) {
        goto LABEL_5;
      }
    }

    uint64_t v14 = (os_log_s *)qword_1008F7560;
    if (os_log_type_enabled((os_log_t)qword_1008F7560, OS_LOG_TYPE_ERROR)) {
      sub_10065F3B8(a2, v14);
    }
  }

BOOL sub_100213890(uint64_t a1, uint64_t a2)
{
  uint64_t v3 = *(void *)(a1 + 400);
  uint64_t v2 = *(void *)(a1 + 408);
  if (v3 == v2) {
    return 0LL;
  }
  uint64_t v4 = v3 + 8;
  do
  {
    uint64_t v5 = *(void *)(v4 - 8);
    BOOL result = v5 == a2;
    BOOL v7 = v5 == a2 || v4 == v2;
    v4 += 8LL;
  }

  while (!v7);
  return result;
}

void *sub_1002138C4(void *result, uint64_t a2)
{
  uint64_t v3 = (char *)result[50];
  uint64_t v2 = (char *)result[51];
  if (v3 != v2)
  {
    uint64_t v4 = result;
    uint64_t v5 = 0LL;
    while (*(void *)&v3[v5] != a2)
    {
      v5 += 8LL;
      if (&v3[v5] == v2) {
        return result;
      }
    }

    __int128 v6 = &v3[v5];
    BOOL v7 = &v3[v5 + 8];
    int64_t v8 = v2 - v7;
    if (v2 != v7) {
      BOOL result = memmove(&v3[v5], v7, v2 - v7);
    }
    v4[51] = &v6[v8];
  }

  return result;
}

uint64_t sub_10021393C()
{
  return 1LL;
}

uint64_t sub_100213944()
{
  return 1LL;
}

uint64_t sub_10021394C()
{
  return 0LL;
}

char *sub_100213954@<X0>(char *result@<X0>, uint64_t a2@<X8>)
{
  if (result[31] < 0) {
    return (char *)sub_100024238((_BYTE *)a2, *((void **)result + 1), *((void *)result + 2));
  }
  *(_OWORD *)a2 = *(_OWORD *)(result + 8);
  *(void *)(a2 + 16) = *((void *)result + 3);
  return result;
}

void sub_100213980(uint64_t a1, uint64_t a2, _WORD *a3)
{
  *a3 = 0;
}

uint64_t sub_100213988()
{
  return 1LL;
}

void sub_100213994(id a1)
{
  uint64_t v1 = operator new(0x2C8uLL);
  sub_100213DA8();
  off_1008D60D8 = v1;
}

void sub_1002139C4(_Unwind_Exception *a1)
{
}

uint64_t sub_1002139D8(uint64_t a1)
{
  return a1;
}

uint64_t sub_100213A00(uint64_t a1)
{
  uint64_t v2 = (void *)sub_100213C20(a1, 24);
  *uint64_t v2 = off_100887D30;
  v2[32] = &off_100887E08;
  v2[33] = off_100887E20;
  v2[34] = off_100887E48;
  v2[35] = &off_100887E78;
  v2[36] = off_100887E90;
  v2[37] = off_100887EC0;
  v2[43] = 0LL;
  v2[44] = 0LL;
  v2[42] = 0LL;
  v2[38] = 0LL;
  v2[39] = 0LL;
  sub_100242DC4(v2 + 45);
  *(_WORD *)(a1 + 42std::ostream::~ostream(v2, v3 + 8) = 0;
  *(_DWORD *)(a1 + 424) = 0;
  *(void *)(a1 + 440) = @"XZ";
  *(_OWORD *)(a1 + 44std::ostream::~ostream(v2, v3 + 8) = 0u;
  *(_OWORD *)(a1 + 4sub_100242E28(v1 + 64) = 0u;
  *(_DWORD *)(a1 + 480) = 1065353216;
  *(void *)(a1 + 48std::ostream::~ostream(v2, v3 + 8) = 0LL;
  *(void *)(a1 + 496) = 0LL;
  *(void *)(a1 + 504) = -1LL;
  *(void *)(a1 + 512) = -1LL;
  *(void *)(a1 + 552) = 0LL;
  *(void *)(a1 + 544) = 0LL;
  *(void *)(a1 + 536) = a1 + 544;
  sub_10023BED8((void *)(a1 + 560));
  sub_100242DC4(a1 + 648);
  *(_BYTE *)(a1 + 32std::ostream::~ostream(v2, v3 + 8) = 0;
  if (qword_1008D60B0 != -1) {
    dispatch_once(&qword_1008D60B0, &stru_100888AF0);
  }
  sub_1001FC5E4((uint64_t)off_1008D60A8 + 80, a1 + 288);
  uint64_t v3 = sub_1002E90E4();
  (*(void (**)(uint64_t, uint64_t))(*(void *)v3 + 32LL))(v3, a1 + 256);
  uint64_t v4 = sub_100405058();
  v6[0] = _NSConcreteStackBlock;
  v6[1] = 3221225472LL;
  void v6[2] = sub_100213CAC;
  void v6[3] = &unk_10087EB20;
  char v6[4] = a1;
  sub_100405384(v4, v6);
  *(_BYTE *)(a1 + 520) = 0;
  *(void *)(a1 + 424) = 0LL;
  *(_BYTE *)(a1 + 4sub_100242FAC(v1 - 32) = 0;
  *(void *)(a1 + 52std::ostream::~ostream(v2, v3 + 8) = 255LL;
  return a1;
}

void sub_100213B8C(_Unwind_Exception *a1)
{
  uint64_t v6 = *(void *)(v1 + 488);
  *(void *)(v1 + 48std::ostream::~ostream(v2, v3 + 8) = 0LL;
  if (v6) {
    (*(void (**)(uint64_t))(*(void *)v6 + 64LL))(v6);
  }
  sub_10023E7DC(v1 + 448);

  sub_100242E28(v2);
  BOOL v7 = *(void **)(v1 + 336);
  if (v7)
  {
    *(void *)(v1 + 344) = v7;
    operator delete(v7);
  }

  sub_100213D34(v1);
  _Unwind_Resume(a1);
}

uint64_t sub_100213C20(uint64_t a1, int a2)
{
  *(void *)a1 = off_1008882B8;
  sub_100242DC4(a1 + 16);
  *(_DWORD *)(a1 + 80) = 0;
  sub_100242DC4(a1 + 88);
  *(void *)(a1 + 240) = 0LL;
  *(void *)(a1 + 2sub_100242FAC(v1 - 32) = 0LL;
  *(_OWORD *)(a1 + 152) = 0u;
  *(_OWORD *)(a1 + 16std::ostream::~ostream(v2, v3 + 8) = 0u;
  *(_OWORD *)(a1 + ++*(_DWORD *)(result + 184) = 0u;
  *(_OWORD *)(a1 + 200) = 0u;
  *(void *)(a1 + 216) = 0LL;
  *(void *)(a1 + 224) = a1 + 232;
  *(_DWORD *)(a1 + 24std::ostream::~ostream(v2, v3 + 8) = a2;
  return a1;
}

void sub_100213C98(_Unwind_Exception *a1)
{
}

void sub_100213CAC(uint64_t a1)
{
  uint64_t v1 = *(void *)(a1 + 32);
  if (qword_1008D90F8 != -1) {
    dispatch_once(&qword_1008D90F8, &stru_100888B10);
  }
  sub_10054A7B0((uint64_t)off_1008D90F0, v1 + 296);
}

uint64_t sub_100213CFC(uint64_t a1)
{
  uint64_t v2 = *(void **)a1;
  if (*(void *)a1)
  {
    *(void *)(a1 + std::ostream::~ostream(v2, v3 + 8) = v2;
    operator delete(v2);
  }

  return a1;
}

uint64_t sub_100213D34(uint64_t a1)
{
  *(void *)a1 = off_1008882B8;
  sub_10023BF24(a1 + 224, *(void **)(a1 + 232));
  uint64_t v2 = *(void **)(a1 + 200);
  if (v2)
  {
    *(void *)(a1 + 20std::ostream::~ostream(v2, v3 + 8) = v2;
    operator delete(v2);
  }

  uint64_t v3 = *(void **)(a1 + 176);
  if (v3)
  {
    *(void *)(a1 + ++*(_DWORD *)(result + 184) = v3;
    operator delete(v3);
  }

  uint64_t v4 = *(void **)(a1 + 152);
  if (v4)
  {
    *(void *)(a1 + 160) = v4;
    operator delete(v4);
  }

  sub_100242E28(a1 + 88);
  sub_100242E28(a1 + 16);
  return a1;
}

uint64_t sub_100213DAC(uint64_t a1)
{
  if (qword_1008D6198 != -1) {
    dispatch_once(&qword_1008D6198, &stru_100888B30);
  }
  if (sub_10044823C((uint64_t)off_1008D6190))
  {
    uint64_t v2 = (void *)MGCopyAnswer(@"ProductVersion", 0LL);
    uint64_t v3 = (void *)[v2 componentsSeparatedByString:@"."];
    uint64_t v4 = (void *)[v3 objectAtIndexedSubscript:0];
    uint64_t v5 = (void *)objc_claimAutoreleasedReturnValue(+[NSString stringWithFormat:](&OBJC_CLASS___NSString, "stringWithFormat:", @"%@", v4));

    if ([v5 isEqualToString:off_1008D9068])
    {
      uint64_t v20 = 0LL;
      id v21 = 0LL;
      uint64_t v22 = 0LL;
      if (qword_1008D67A8 != -1) {
        dispatch_once(&qword_1008D67A8, &stru_100888B50);
      }
      sub_10052AFEC((uint64_t)off_1008D67A0, &v20);
      uint64_t v6 = (uint64_t *)v20;
      BOOL v7 = (uint64_t *)v21;
      if (v20 != v21)
      {
        do
        {
          uint64_t v8 = *v6;
          if (sub_1003D2B2C(*v6, 14))
          {
            uint64_t v9 = (os_log_s *)qword_1008F7560;
            if (os_log_type_enabled((os_log_t)qword_1008F7560, OS_LOG_TYPE_DEFAULT))
            {
              sub_1003CF00C(v8, __p);
              uint64_t v10 = v19 >= 0 ? __p : (void **)__p[0];
              *(_DWORD *)__int128 buf = 136446210;
              uint64_t v24 = v10;
              _os_log_impl( (void *)&_mh_execute_header,  v9,  OS_LOG_TYPE_DEFAULT,  "Migrating double tap settings for device %{public}s",  buf,  0xCu);
              if (v19 < 0) {
                operator delete(__p[0]);
              }
            }

            int v11 = sub_1003D635C(v8);
            sub_1003D63A0(v8, v11 | (v11 << 8));
          }

          ++v6;
        }

        while (v6 != v7);
        uint64_t v6 = (uint64_t *)v20;
      }

      if (v6)
      {
        id v21 = (void **)v6;
        operator delete(v6);
      }
    }
  }

  uint64_t v12 = sub_1002E6E9C();
  if ((sub_1002CD53C(v12, 2u) & 1) == 0) {
    *(void *)(a1 + 528) &= ~2uLL;
  }
  uint64_t v13 = sub_1002E6E9C();
  if ((sub_1002CD53C(v13, 3u) & 1) == 0) {
    *(void *)(a1 + 528) &= ~4uLL;
  }
  uint64_t v14 = sub_1002E6E9C();
  if ((sub_1002CD53C(v14, 0) & 1) == 0) {
    *(void *)(a1 + 528) &= ~8uLL;
  }
  uint64_t v15 = sub_1002E6E9C();
  if ((sub_1002CD53C(v15, 5u) & 1) == 0) {
    *(void *)(a1 + 528) &= ~0x10uLL;
  }
  uint64_t v16 = sub_1002E6E9C();
  if ((sub_1002CD53C(v16, 6u) & 1) == 0) {
    *(void *)(a1 + 528) &= ~0x20uLL;
  }
  sub_1002E6E9C();
  if (_os_feature_enabled_impl("AudioAccessoryFeatures", "AllowListeningModeOff")
    && _os_feature_enabled_impl("ConnectedAudio", "HearingProtection"))
  {
    *(void *)(a1 + 528) |= 0x200uLL;
  }

  LOBYTE(v20) = 0;
  sub_100242CA4(&v20);
  sub_10007E7CC((uint64_t)off_100887EF0);
  sub_100242CD8(&v20);
  return 0LL;
}

void sub_100214104( _Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, void *__p, uint64_t a19)
{
  if (__p) {
    operator delete(__p);
  }

  _Unwind_Resume(a1);
}

uint64_t sub_100214184(uint64_t result)
{
  *(_BYTE *)(result + 32std::ostream::~ostream(v2, v3 + 8) = 1;
  return result;
}

uint64_t sub_100214190(uint64_t result)
{
  *(_BYTE *)(result + 40) = 1;
  return result;
}

uint64_t sub_10021419C(uint64_t result)
{
  *(_BYTE *)(result + 32std::ostream::~ostream(v2, v3 + 8) = 0;
  return result;
}

uint64_t sub_1002141A4(uint64_t result)
{
  *(_BYTE *)(result + 40) = 0;
  return result;
}

void sub_1002141AC(uint64_t a1, void *a2, int a3, int a4, int a5)
{
  id v10 = a2;
  int v11 = (os_log_s *)qword_1008F7560;
  if (os_log_type_enabled((os_log_t)qword_1008F7560, OS_LOG_TYPE_DEFAULT))
  {
    *(_DWORD *)__int128 buf = 138544130;
    *(void *)unsigned int v28 = v10;
    *(_WORD *)&v28[8] = 1024;
    *(_DWORD *)&v28[10] = a3;
    __int16 v29 = 1024;
    int v30 = a4;
    __int16 v31 = 1024;
    int v32 = a5;
    _os_log_impl( (void *)&_mh_execute_header,  v11,  OS_LOG_TYPE_DEFAULT,  "AACPClient::locationUpdate - country: %{public}@, CC: %u, LEFlag: %u, HDRFlag: %u",  buf,  0x1Eu);
  }

  objc_storeStrong((id *)(a1 + 440), a2);
  uint64_t v12 = *(uint64_t **)(a1 + 336);
  for (unint64_t i = *(uint64_t **)(a1 + 344); v12 != i; ++v12)
  {
    uint64_t v14 = *v12;
    if (*v12)
    {
      unsigned int v15 = *(_DWORD *)(v14 + 80) - 8212;
      BOOL v16 = v15 > 0x10;
      int v17 = (1 << v15) & 0x116A1;
      if (!v16 && v17 != 0)
      {
        uint64_t v19 = *(void *)v14;
        if (*(void *)v14)
        {
          if ((*(unsigned int (**)(void))(**(void **)(v14 + 768) + 176LL))(*(void *)(v14 + 768)) == 1)
          {
            uint64_t v26 = -256LL;
            uint64_t v20 = sub_1002E90E4();
            (*(void (**)(uint64_t, void, uint64_t *, void))(*(void *)v20 + 16LL))( v20,  *(void *)(a1 + 440),  &v26,  *(unsigned int *)(*v12 + 80));
            int v21 = sub_100214450(a1, v19, (uint64_t)&v26);
            if (v21)
            {
              uint64_t v22 = (os_log_s *)qword_1008F7560;
              if (os_log_type_enabled((os_log_t)qword_1008F7560, OS_LOG_TYPE_ERROR))
              {
                sub_1003CF00C(v19, __p);
                id v23 = __p;
                if (v25 < 0) {
                  id v23 = (void **)__p[0];
                }
                *(_DWORD *)__int128 buf = 67109634;
                *(_DWORD *)unsigned int v28 = a3;
                *(_WORD *)&v28[4] = 2082;
                *(void *)&v28[6] = v23;
                __int16 v29 = 1024;
                int v30 = v21;
                _os_log_error_impl( (void *)&_mh_execute_header,  v22,  OS_LOG_TYPE_ERROR,  "Failed to set country code (%u) for device %{public}s with result %u",  buf,  0x18u);
                if (v25 < 0) {
                  operator delete(__p[0]);
                }
              }
            }
          }
        }
      }
    }
  }
}

void sub_100214428( _Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, void *a13)
{
}

uint64_t sub_100214450(uint64_t a1, uint64_t a2, uint64_t a3)
{
  v10[0] = 0LL;
  v10[1] = 0LL;
  sub_100242F28((uint64_t)v10, a1 + 360);
  if (a2)
  {
    for (uint64_t i = *(void *)(a1 + 336); i != *(void *)(a1 + 344); i += 8LL)
    {
      if (**(void **)i == a2)
      {
        uint64_t v7 = (*(uint64_t (**)(void, uint64_t, uint64_t))(**(void **)(*(void *)i + 768LL) + 104LL))( *(void *)(*(void *)i + 768LL),  a2,  a3);
        goto LABEL_9;
      }
    }
  }

  if (os_log_type_enabled((os_log_t)qword_1008F7560, OS_LOG_TYPE_ERROR))
  {
    sub_1003CF00C(a2, v9);
    sub_10065F474();
  }

  uint64_t v7 = 312LL;
LABEL_9:
  sub_100242FAC((uint64_t)v10);
  return v7;
}

void sub_100214550(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, ...)
{
}

void sub_100214570(uint64_t a1, void *a2, int a3, int a4, int a5)
{
}

uint64_t sub_100214578(uint64_t a1)
{
  uint64_t v2 = (os_log_s *)qword_1008F7560;
  if (os_log_type_enabled((os_log_t)qword_1008F7560, OS_LOG_TYPE_DEFAULT))
  {
    *(_WORD *)uint64_t v4 = 0;
    _os_log_impl((void *)&_mh_execute_header, v2, OS_LOG_TYPE_DEFAULT, "Register AACP Profile", v4, 2u);
  }

  if (qword_1008D9108 != -1) {
    dispatch_once(&qword_1008D9108, &stru_100888B70);
  }
  sub_10023BF64(qword_1008D9100 + 120, a1 + 280);
  return 0LL;
}

uint64_t sub_100214620(uint64_t a1)
{
  uint64_t v2 = (os_log_s *)qword_1008F7560;
  if (os_log_type_enabled((os_log_t)qword_1008F7560, OS_LOG_TYPE_DEFAULT))
  {
    *(_WORD *)uint64_t v4 = 0;
    _os_log_impl((void *)&_mh_execute_header, v2, OS_LOG_TYPE_DEFAULT, "Deregister AACP profile", v4, 2u);
  }

  if (qword_1008D9108 != -1) {
    dispatch_once(&qword_1008D9108, &stru_100888B70);
  }
  sub_100009168(qword_1008D9100 + 120, a1 + 280);
  return 0LL;
}

uint64_t sub_1002146C8(uint64_t a1, uint64_t a2)
{
  uint64_t v4 = (os_log_s *)qword_1008F7560;
  if (os_log_type_enabled((os_log_t)qword_1008F7560, OS_LOG_TYPE_DEFAULT))
  {
    sub_1003CF00C(a2, __p);
    uint64_t v5 = v11 >= 0 ? __p : (void **)__p[0];
    *(_DWORD *)__int128 buf = 136446210;
    *(void *)&uint8_t buf[4] = v5;
    _os_log_impl((void *)&_mh_execute_header, v4, OS_LOG_TYPE_DEFAULT, "disconnecting %{public}s", buf, 0xCu);
    if (v11 < 0) {
      operator delete(__p[0]);
    }
  }

  *(_OWORD *)__int128 buf = 0uLL;
  sub_100242F28((uint64_t)buf, a1 + 360);
  if (a2)
  {
    for (uint64_t i = *(void **)(a1 + 336); i != *(void **)(a1 + 344); ++i)
    {
      uint64_t v7 = (void *)*i;
      if (*(void *)*i == a2)
      {
        sub_10023EA7C((uint64_t **)(a1 + 536), a2 + 128);
        uint64_t v8 = (*(uint64_t (**)(void, uint64_t))(*(void *)v7[96] + 136LL))(v7[96], a2);
        goto LABEL_15;
      }
    }
  }

  if (os_log_type_enabled((os_log_t)qword_1008F7560, OS_LOG_TYPE_ERROR))
  {
    sub_1003CF00C(a2, __p);
    sub_10065F474();
  }

  uint64_t v8 = 312LL;
LABEL_15:
  sub_100242FAC((uint64_t)buf);
  return v8;
}

void sub_10021484C( _Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, ...)
{
}

uint64_t sub_10021486C(uint64_t a1, uint64_t a2)
{
  uint64_t v3 = (os_log_s *)qword_1008F7560;
  if (os_log_type_enabled((os_log_t)qword_1008F7560, OS_LOG_TYPE_DEFAULT))
  {
    sub_1003CF00C(a2, __p);
    uint64_t v4 = v10 >= 0 ? __p : (void **)__p[0];
    *(_DWORD *)__int128 buf = 136446210;
    uint64_t v12 = v4;
    _os_log_impl((void *)&_mh_execute_header, v3, OS_LOG_TYPE_DEFAULT, "connecting to %{public}s", buf, 0xCu);
    if (v10 < 0) {
      operator delete(__p[0]);
    }
  }

  char v8 = 0;
  sub_100242CA4(&v8);
  uint64_t v5 = sub_10007E888(a2 + 128, (uint64_t)off_100887EF0);
  sub_100242CD0(&v8);
  if ((_DWORD)v5 && os_log_type_enabled((os_log_t)qword_1008F7560, OS_LOG_TYPE_ERROR))
  {
    sub_1003CF00C(a2, __p);
    sub_10065F4C0();
  }

  if (qword_1008D60B0 != -1) {
    dispatch_once(&qword_1008D60B0, &stru_100888AF0);
  }
  uint64_t v6 = sub_1004317E0((uint64_t)off_1008D60A8, v5, 10000);
  sub_100242CD8(&v8);
  return v6;
}

void sub_1002149F0( _Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, int a9, __int16 a10, char a11, char a12)
{
}

uint64_t sub_100214A10(uint64_t a1, uint64_t a2, uint64_t a3)
{
  v10[0] = 0LL;
  v10[1] = 0LL;
  sub_100242F28((uint64_t)v10, a1 + 360);
  if (a2)
  {
    for (uint64_t i = *(void *)(a1 + 336); i != *(void *)(a1 + 344); i += 8LL)
    {
      if (**(void **)i == a2)
      {
        uint64_t v7 = (*(uint64_t (**)(void, uint64_t, uint64_t))(**(void **)(*(void *)i + 768LL) + 88LL))( *(void *)(*(void *)i + 768LL),  a2,  a3);
        goto LABEL_9;
      }
    }
  }

  if (os_log_type_enabled((os_log_t)qword_1008F7560, OS_LOG_TYPE_ERROR))
  {
    sub_1003CF00C(a2, v9);
    sub_10065F474();
  }

  uint64_t v7 = 312LL;
LABEL_9:
  sub_100242FAC((uint64_t)v10);
  return v7;
}

void sub_100214B10(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, ...)
{
}

uint64_t sub_100214B30(uint64_t a1, uint64_t a2)
{
  v8[0] = 0LL;
  v8[1] = 0LL;
  sub_100242F28((uint64_t)v8, a1 + 360);
  if (a2)
  {
    for (uint64_t i = *(void *)(a1 + 336); i != *(void *)(a1 + 344); i += 8LL)
    {
      if (**(void **)i == a2)
      {
        uint64_t v5 = (*(uint64_t (**)(void, uint64_t))(**(void **)(*(void *)i + 768LL) + 56LL))( *(void *)(*(void *)i + 768LL),  a2);
        goto LABEL_9;
      }
    }
  }

  if (os_log_type_enabled((os_log_t)qword_1008F7560, OS_LOG_TYPE_ERROR))
  {
    sub_1003CF00C(a2, v7);
    sub_10065F474();
  }

  uint64_t v5 = 312LL;
LABEL_9:
  sub_100242FAC((uint64_t)v8);
  return v5;
}

void sub_100214C20(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, ...)
{
}

uint64_t sub_100214C40(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5)
{
  v14[0] = 0LL;
  v14[1] = 0LL;
  sub_100242F28((uint64_t)v14, a1 + 360);
  if (a2)
  {
    for (uint64_t i = *(void *)(a1 + 336); i != *(void *)(a1 + 344); i += 8LL)
    {
      if (**(void **)i == a2)
      {
        uint64_t v11 = (*(uint64_t (**)(void, uint64_t, uint64_t, uint64_t, uint64_t))(**(void **)(*(void *)i + 768LL)
                                                                                    + 64LL))( *(void *)(*(void *)i + 768LL),  a2,  a3,  a4,  a5);
        goto LABEL_9;
      }
    }
  }

  if (os_log_type_enabled((os_log_t)qword_1008F7560, OS_LOG_TYPE_ERROR))
  {
    sub_1003CF00C(a2, v13);
    sub_10065F474();
  }

  uint64_t v11 = 312LL;
LABEL_9:
  sub_100242FAC((uint64_t)v14);
  return v11;
}

void sub_100214D58(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, ...)
{
}

uint64_t sub_100214D78(uint64_t a1, uint64_t a2, uint64_t a3)
{
  v10[0] = 0LL;
  v10[1] = 0LL;
  sub_100242F28((uint64_t)v10, a1 + 360);
  if (a2)
  {
    for (uint64_t i = *(void *)(a1 + 336); i != *(void *)(a1 + 344); i += 8LL)
    {
      if (**(void **)i == a2)
      {
        uint64_t v7 = (*(uint64_t (**)(void, uint64_t, uint64_t))(**(void **)(*(void *)i + 768LL) + 72LL))( *(void *)(*(void *)i + 768LL),  a2,  a3);
        goto LABEL_9;
      }
    }
  }

  if (os_log_type_enabled((os_log_t)qword_1008F7560, OS_LOG_TYPE_ERROR))
  {
    sub_1003CF00C(a2, v9);
    sub_10065F474();
  }

  uint64_t v7 = 312LL;
LABEL_9:
  sub_100242FAC((uint64_t)v10);
  return v7;
}

void sub_100214E78(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, ...)
{
}

uint64_t sub_100214E98(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5)
{
  v14[0] = 0LL;
  v14[1] = 0LL;
  sub_100242F28((uint64_t)v14, a1 + 360);
  if (a2)
  {
    for (uint64_t i = *(void *)(a1 + 336); i != *(void *)(a1 + 344); i += 8LL)
    {
      if (**(void **)i == a2)
      {
        uint64_t v11 = (*(uint64_t (**)(void, uint64_t, uint64_t, uint64_t, uint64_t))(**(void **)(*(void *)i + 768LL)
                                                                                    + 16LL))( *(void *)(*(void *)i + 768LL),  a2,  a3,  a4,  a5);
        goto LABEL_9;
      }
    }
  }

  if (os_log_type_enabled((os_log_t)qword_1008F7560, OS_LOG_TYPE_ERROR))
  {
    sub_1003CF00C(a2, v13);
    sub_10065F474();
  }

  uint64_t v11 = 312LL;
LABEL_9:
  sub_100242FAC((uint64_t)v14);
  return v11;
}

void sub_100214FB0(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, ...)
{
}

uint64_t sub_100214FD0(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5)
{
  char v10 = (os_log_s *)qword_1008F7560;
  if (os_log_type_enabled((os_log_t)qword_1008F7560, OS_LOG_TYPE_DEFAULT))
  {
    sub_1003CF00C(a2, __p);
    uint64_t v11 = v16 >= 0 ? __p : (void **)__p[0];
    *(_DWORD *)__int128 buf = 136446210;
    *(void *)&uint8_t buf[4] = v11;
    _os_log_impl( (void *)&_mh_execute_header,  v10,  OS_LOG_TYPE_DEFAULT,  "send device info message to %{public}s",  buf,  0xCu);
    if (v16 < 0) {
      operator delete(__p[0]);
    }
  }

  *(_OWORD *)__int128 buf = 0uLL;
  sub_100242F28((uint64_t)buf, a1 + 360);
  if (a2)
  {
    for (uint64_t i = *(void *)(a1 + 336); i != *(void *)(a1 + 344); i += 8LL)
    {
      if (**(void **)i == a2)
      {
        uint64_t v13 = (*(uint64_t (**)(void, uint64_t, uint64_t, uint64_t, uint64_t))(**(void **)(*(void *)i + 768LL)
                                                                                    + 144LL))( *(void *)(*(void *)i + 768LL),  a2,  a3,  a4,  a5);
        goto LABEL_15;
      }
    }
  }

  if (os_log_type_enabled((os_log_t)qword_1008F7560, OS_LOG_TYPE_ERROR))
  {
    sub_1003CF00C(a2, __p);
    sub_10065F474();
  }

  uint64_t v13 = 312LL;
LABEL_15:
  sub_100242FAC((uint64_t)buf);
  return v13;
}

void sub_100215168( _Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, ...)
{
}

uint64_t sub_100215188(uint64_t a1, uint64_t a2, unsigned int a3, const void *a4)
{
  if (!*(_BYTE *)(a1 + 328)) {
    return 111LL;
  }
  char v8 = (os_log_s *)qword_1008F7560;
  if (os_log_type_enabled((os_log_t)qword_1008F7560, OS_LOG_TYPE_DEFAULT))
  {
    sub_1003CF00C(a2, __p);
    uint64_t v9 = v15 >= 0 ? __p : (void **)__p[0];
    *(_DWORD *)__int128 buf = 136446210;
    int v17 = v9;
    _os_log_impl( (void *)&_mh_execute_header,  v8,  OS_LOG_TYPE_DEFAULT,  "send setRemoteDeviceName to %{public}s",  buf,  0xCu);
    if (v15 < 0) {
      operator delete(__p[0]);
    }
  }

  LOBYTE(__p[0]) = 0;
  sub_100242CA4(__p);
  if (sub_10007FCD0((unsigned __int8 *)(a2 + 128), 1, a3, a4)
    && os_log_type_enabled((os_log_t)qword_1008F7560, OS_LOG_TYPE_ERROR))
  {
    sub_10065F584();
  }

  uint64_t v10 = sub_10007F330((unsigned __int8 *)(a2 + 128), 255);
  sub_100242CD0(__p);
  if ((_DWORD)v10 && os_log_type_enabled((os_log_t)qword_1008F7560, OS_LOG_TYPE_ERROR)) {
    sub_10065F524();
  }
  uint64_t v11 = sub_1002E6BF0();
  if (qword_1008D60B0 != -1) {
    dispatch_once(&qword_1008D60B0, &stru_100888AF0);
  }
  uint64_t v12 = sub_1004317E0((uint64_t)off_1008D60A8, v10, 10000);
  sub_100242CD8(__p);
  return v12;
}

void sub_100215380( _Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, char a10)
{
}

uint64_t sub_10021539C(uint64_t a1, uint64_t a2)
{
  uint64_t v4 = sub_1002E6BF0();
  uint64_t v5 = objc_alloc_init(&OBJC_CLASS___NSMutableDictionary);
  if (sub_10021AF3C(a1, a2))
  {
    uint64_t v6 = +[NSNumber numberWithInt:](&OBJC_CLASS___NSNumber, "numberWithInt:", sub_1003DF900(a2));
    uint64_t v7 = (void *)objc_claimAutoreleasedReturnValue(v6);
    -[NSMutableDictionary setObject:forKey:](v5, "setObject:forKey:", v7, @"kCfgMicSide");

    char v8 = +[NSNumber numberWithBool:](&OBJC_CLASS___NSNumber, "numberWithBool:", sub_1003DF944(a2));
    uint64_t v9 = (void *)objc_claimAutoreleasedReturnValue(v8);
    -[NSMutableDictionary setObject:forKey:](v5, "setObject:forKey:", v9, @"kCfgInEarMode");

    uint64_t v10 = +[NSNumber numberWithInt:](&OBJC_CLASS___NSNumber, "numberWithInt:", sub_1003D635C(a2));
    uint64_t v11 = (void *)objc_claimAutoreleasedReturnValue(v10);
    -[NSMutableDictionary setObject:forKey:](v5, "setObject:forKey:", v11, @"kCfgDoubleTap");

    if ((sub_1003D2B2C(a2, 29) & 1) != 0 || sub_1003E0230(a2, 128))
    {
      uint64_t v12 = +[NSNumber numberWithInt:](&OBJC_CLASS___NSNumber, "numberWithInt:", sub_1003DFC14(a2));
      uint64_t v13 = (void *)objc_claimAutoreleasedReturnValue(v12);
      -[NSMutableDictionary setObject:forKey:](v5, "setObject:forKey:", v13, @"kCfgDoubleClickInt");
    }

    if (sub_1003D2B2C(a2, 30))
    {
      uint64_t v14 = +[NSNumber numberWithInt:](&OBJC_CLASS___NSNumber, "numberWithInt:", sub_1003DFBD0(a2));
      char v15 = (void *)objc_claimAutoreleasedReturnValue(v14);
      -[NSMutableDictionary setObject:forKey:](v5, "setObject:forKey:", v15, @"kCfgClickHold");
    }

    if ((sub_1003D2B2C(a2, 30) & 1) != 0 || sub_1003E0230(a2, 128))
    {
      char v16 = +[NSNumber numberWithInt:](&OBJC_CLASS___NSNumber, "numberWithInt:", sub_1003DFC58(a2));
      int v17 = (void *)objc_claimAutoreleasedReturnValue(v16);
      -[NSMutableDictionary setObject:forKey:](v5, "setObject:forKey:", v17, @"kCfgClickHoldInt");
    }

    if (sub_1003D2B2C(a2, 28))
    {
      id v18 = +[NSNumber numberWithInt:](&OBJC_CLASS___NSNumber, "numberWithInt:", sub_1003DFA7C(a2));
      uint64_t v19 = (void *)objc_claimAutoreleasedReturnValue(v18);
      -[NSMutableDictionary setObject:forKey:](v5, "setObject:forKey:", v19, @"kCfgListenModeCfgs");
    }

    if (sub_1003D2B2C(a2, 16) && sub_1003D2B2C(a2, 1))
    {
      uint64_t v20 = +[NSNumber numberWithInt:](&OBJC_CLASS___NSNumber, "numberWithInt:", sub_1003DFC9C(a2));
      int v21 = (void *)objc_claimAutoreleasedReturnValue(v20);
      -[NSMutableDictionary setObject:forKey:](v5, "setObject:forKey:", v21, @"kCfgOneBudANCMode");
    }

    else
    {
      if (!sub_1003D2B2C(a2, 16) || !sub_1003D2B2C(a2, 15))
      {
LABEL_21:
        uint64_t v23 = sub_1002E8F6C();
        sub_1003FE1B4((unsigned __int8 *)(a2 + 128), v27);
        sub_1003D0100(a2, (uint64_t)__p);
        if (v26 >= 0) {
          uint64_t v24 = __p;
        }
        else {
          uint64_t v24 = (void **)__p[0];
        }
        (*(void (**)(uint64_t, void **, NSMutableDictionary *, void **))(*(void *)v23 + 120LL))( v23,  v27,  v5,  v24);
        if (v26 < 0) {
          operator delete(__p[0]);
        }
        if (v28 < 0) {
          operator delete(v27[0]);
        }
        goto LABEL_28;
      }

      int v21 = [NSNumber numberWithInt:1LL];
      -[NSMutableDictionary setObject:forKey:](v5, "setObject:forKey:", v21, @"kCfgOneBudANCMode");
    }

    goto LABEL_21;
  }

void sub_10021570C( _Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, void *__p, uint64_t a10, int a11, __int16 a12, char a13, char a14, void *a15, uint64_t a16, int a17, __int16 a18, char a19, char a20)
{
  _Unwind_Resume(a1);
}

uint64_t sub_100215778(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, unsigned int a5)
{
  if (*(_BYTE *)(a1 + 328))
  {
    if (a5)
    {
      BOOL v10 = 0;
      switch((int)a3)
      {
        case 1:
          uint64_t v11 = (os_log_s *)qword_1008F7560;
          if (os_log_type_enabled((os_log_t)qword_1008F7560, OS_LOG_TYPE_DEFAULT))
          {
            *(_DWORD *)__int128 buf = 67109120;
            *(_DWORD *)&uint8_t buf[4] = a4;
            _os_log_impl((void *)&_mh_execute_header, v11, OS_LOG_TYPE_DEFAULT, "Set Mic Mode to value 0x%08X", buf, 8u);
          }

          uint64_t v12 = sub_1002E6BF0();
          if (((*(uint64_t (**)(uint64_t))(*(void *)v12 + 328LL))(v12) & 1) == 0)
          {
            uint64_t v13 = sub_1002E6BF0();
          }

          int v14 = 0;
          int v15 = sub_1003DF900(a2) != a4;
          BOOL v10 = v15;
          goto LABEL_170;
        case 5:
          uint64_t v23 = (os_log_s *)qword_1008F7560;
          if (os_log_type_enabled((os_log_t)qword_1008F7560, OS_LOG_TYPE_DEFAULT))
          {
            *(_DWORD *)__int128 buf = 67109120;
            *(_DWORD *)&uint8_t buf[4] = a4;
            _os_log_impl((void *)&_mh_execute_header, v23, OS_LOG_TYPE_DEFAULT, "Set Button Send Mode: %d", buf, 8u);
          }

          if ((_DWORD)a4 == 1 && !*(void *)(a1 + 488))
          {
            sub_100216D40(buf);
            uint64_t v24 = *(void *)buf;
            *(void *)__int128 buf = 0LL;
            uint64_t v25 = *(void *)(a1 + 488);
            *(void *)(a1 + 48std::ostream::~ostream(v2, v3 + 8) = v24;
            if (v25)
            {
              (*(void (**)(uint64_t))(*(void *)v25 + 64LL))(v25);
              uint64_t v26 = *(void *)buf;
              *(void *)__int128 buf = 0LL;
              if (v26) {
                (*(void (**)(uint64_t))(*(void *)v26 + 64LL))(v26);
              }
            }

            sub_1002CAC98(*(void *)(a1 + 488));
          }

          goto LABEL_130;
        case 13:
          v83[0] = 0LL;
          v83[1] = 0LL;
          sub_100242F28((uint64_t)v83, a1 + 360);
          if (!a2) {
            goto LABEL_112;
          }
          uint64_t v27 = *(void ***)(a1 + 336);
          while (2)
          {
            if (v27 == *(void ***)(a1 + 344))
            {
LABEL_112:
              if (os_log_type_enabled((os_log_t)qword_1008F7560, OS_LOG_TYPE_ERROR))
              {
                sub_1003CF00C(a2, buf);
                sub_10065F474();
              }

              uint64_t v16 = 312LL;
              goto LABEL_115;
            }

            char v28 = *v27;
            if (**v27 != a2)
            {
              ++v27;
              continue;
            }

            break;
          }

          if (sub_1003DFC9C(a2) == 2 && ((_DWORD)a4 == 4 || (_DWORD)a4 == 2))
          {
            if (sub_1003D2B2C(a2, 1))
            {
              if (sub_1003DF944(a2))
              {
                uint64_t v77 = *((unsigned __int8 *)v28 + 8);
                if (*((_BYTE *)v28 + 8) || *((_BYTE *)v28 + 9))
                {
                  int v78 = (os_log_s *)qword_1008F7560;
                  if (os_log_type_enabled((os_log_t)qword_1008F7560, OS_LOG_TYPE_ERROR)) {
                    sub_10065F6B0(v77, (uint64_t)v28, v78);
                  }
                  uint64_t v16 = 11LL;
LABEL_115:
                  uint64_t v54 = v83;
                  goto LABEL_147;
                }
              }
            }
          }

          int v79 = (os_log_s *)qword_1008F7560;
          if (os_log_type_enabled((os_log_t)qword_1008F7560, OS_LOG_TYPE_DEFAULT))
          {
            *(_DWORD *)__int128 buf = 67109120;
            *(_DWORD *)&uint8_t buf[4] = a4;
            _os_log_impl( (void *)&_mh_execute_header,  v79,  OS_LOG_TYPE_DEFAULT,  "Set ListeningMode device setting: %d",  buf,  8u);
          }

          sub_1003DDE4C(a2, a4);
          sub_100242FAC((uint64_t)v83);
          BOOL v10 = 0;
          int v15 = 1;
          int v14 = 1;
LABEL_170:
          BOOL v58 = a5 != 3;
          if (a5 != 3 && v15)
          {
            sub_10021539C(a1, a2);
            BOOL v58 = 1;
            int v15 = 1;
          }

void sub_100216ACC( _Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, void *__p, uint64_t a14, int a15, __int16 a16, char a17, char a18, char a19, uint64_t a20, uint64_t a21, uint64_t a22, uint64_t a23, uint64_t a24, uint64_t a25, uint64_t a26, uint64_t a27, int a28, __int16 a29, char a30, char a31)
{
}

void sub_100216C00(uint64_t a1, uint64_t a2)
{
  uint64_t v3 = (os_log_s *)qword_1008F7560;
  if (os_log_type_enabled((os_log_t)qword_1008F7560, OS_LOG_TYPE_DEFAULT))
  {
    sub_1003D0100(a2, (uint64_t)__p);
    if (v10 >= 0) {
      uint64_t v4 = __p;
    }
    else {
      uint64_t v4 = (void **)__p[0];
    }
    *(_DWORD *)__int128 buf = 136315138;
    uint64_t v12 = v4;
    _os_log_impl( (void *)&_mh_execute_header,  v3,  OS_LOG_TYPE_DEFAULT,  "Notify one bud ANC mode change for device %s",  buf,  0xCu);
    if (v10 < 0) {
      operator delete(__p[0]);
    }
  }

  uint64_t v5 = sub_100405058();
  v8[0] = _NSConcreteStackBlock;
  v8[1] = 3221225472LL;
  void v8[2] = sub_10023539C;
  v8[3] = &unk_10087EB20;
  void v8[4] = a2;
  sub_100405384(v5, v8);
  uint64_t v6 = sub_1004050C8();
  v7[0] = _NSConcreteStackBlock;
  v7[1] = 3221225472LL;
  _DWORD v7[2] = sub_100235400;
  void v7[3] = &unk_10087EB20;
  void v7[4] = a2;
  sub_100405384(v6, v7);
}

void *sub_100216D40@<X0>(void *a1@<X8>)
{
  uint64_t v2 = operator new(0x10uLL);
  BOOL result = sub_1002CABEC(v2);
  *a1 = v2;
  return result;
}

void sub_100216D70(_Unwind_Exception *a1)
{
}

void sub_100216D84(uint64_t a1, uint64_t a2, int a3)
{
  char v4 = sub_1003D1EC8(a2);
  uint64_t v5 = (os_log_s *)qword_1008F7560;
  BOOL v6 = os_log_type_enabled((os_log_t)qword_1008F7560, OS_LOG_TYPE_DEFAULT);
  if ((v4 & 1) != 0)
  {
    if (v6)
    {
      v7[0] = 67109120;
      v7[1] = a3;
      _os_log_impl( (void *)&_mh_execute_header,  v5,  OS_LOG_TYPE_DEFAULT,  "Notify conversation awareness changed %i",  (uint8_t *)v7,  8u);
    }

    if (qword_1008EF948 != -1) {
      dispatch_once(&qword_1008EF948, &stru_100888160);
    }
    notify_set_state(dword_1008EF950, a3 == 1);
    notify_post("com.apple.bluetoothd.conversationAwarenessValueChanged");
  }

  else if (v6)
  {
    LOWORD(v7[0]) = 0;
    _os_log_impl( (void *)&_mh_execute_header,  v5,  OS_LOG_TYPE_DEFAULT,  "Notify of conversation awareness change ignored as Adaptive Controls Share Sheet not yet shown.",  (uint8_t *)v7,  2u);
  }

uint64_t sub_100216EB4(uint64_t a1)
{
  if (qword_1008D60C0 != -1) {
    dispatch_once(&qword_1008D60C0, &stru_100888BD0);
  }
  return sub_1003F637C((uint64_t)off_1008D60B8, *(void *)(a1 + 32), 4097);
}

const char *sub_100216F08(uint64_t a1, int a2)
{
  else {
    return off_100888DD0[(char)(a2 - 1)];
  }
}

void *sub_100216F34@<X0>(uint64_t a1@<X0>, int a2@<W1>, unsigned int a3@<W2>, void *a4@<X8>)
{
  __int128 v32 = 0u;
  __int128 v33 = 0u;
  __int128 v30 = 0u;
  __int128 v31 = 0u;
  __int128 v28 = 0u;
  __int128 v29 = 0u;
  __int128 v26 = 0u;
  __int128 v27 = 0u;
  __int128 v24 = 0u;
  __int128 v25 = 0u;
  __int128 v22 = 0u;
  __int128 v23 = 0u;
  __int128 v20 = 0u;
  __int128 v21 = 0u;
  *(_OWORD *)__str = 0u;
  __int128 v19 = 0u;
  switch(a2)
  {
    case 1:
      uint64_t v10 = (char)a3;
      uint64_t v11 = off_100889050;
      goto LABEL_13;
    case 4:
      char v8 = "Off";
      switch((__int16)a3)
      {
        case 0:
          return sub_10002418C(a4, v8);
        case 1:
          char v8 = "Siri";
          break;
        case 2:
          char v8 = "Play/Pause";
          break;
        case 3:
          char v8 = "Next Track";
          break;
        case 4:
          char v8 = "Prev Track";
          break;
        default:
          else {
            char v8 = "unknown";
          }
          break;
      }

      return sub_10002418C(a4, v8);
    case 6:
      uint64_t v12 = "owned";
      uint64_t v13 = "not owned";
      goto LABEL_25;
    case 8:
      uint64_t v5 = "unknown";
      int v14 = a3;
      int v15 = "secondary";
      BOOL v16 = a3 == 2;
      BOOL v6 = "primary";
      goto LABEL_35;
    case 10:
      uint64_t v5 = "unknown";
      int v14 = a3;
      int v15 = "Enabled";
      BOOL v16 = a3 == 2;
      BOOL v6 = "Disabled";
      goto LABEL_35;
    case 11:
      snprintf(__str, 0x100uLL, "%u ms");
      return sub_10002418C(a4, __str);
    case 12:
      if (BYTE1(a3) <= 4u) {
        __asm { BR              X11 }
      }

      goto LABEL_47;
    case 13:
      if (a3 - 1 > 3) {
        goto LABEL_32;
      }
      char v8 = off_1008890A0[a3 - 1];
      return sub_10002418C(a4, v8);
    case 18:
    case 27:
    case 30:
    case 32:
    case 37:
    case 38:
    case 39:
    case 40:
    case 41:
    case 47:
    case 48:
    case 49:
    case 50:
    case 51:
    case 52:
      uint64_t v5 = "unknown";
      BOOL v6 = "Disabled";
      BOOL v7 = a3 == 2;
      goto LABEL_5;
    case 19:
      uint64_t v12 = "Enabled";
      uint64_t v13 = "Disabled";
LABEL_25:
      if (a3) {
        char v8 = (char *)v12;
      }
      else {
        char v8 = (char *)v13;
      }
      return sub_10002418C(a4, v8);
    case 20:
    case 21:
      LOBYTE(v10) = a3 - 1;
      uint64_t v10 = (char)v10;
      uint64_t v11 = off_100889138;
LABEL_13:
      char v8 = v11[v10];
      return sub_10002418C(a4, v8);
    case 22:
LABEL_47:
      snprintf(__str, 0x100uLL, "%s for left bud and %s for right bud (value 0x%X)");
      return sub_10002418C(a4, __str);
    case 23:
      if (a3 > 2) {
        goto LABEL_32;
      }
      int v17 = off_100889188;
      goto LABEL_40;
    case 24:
      if (a3 <= 2)
      {
        int v17 = off_1008891A0;
        goto LABEL_40;
      }

uint64_t sub_10021752C(uint64_t a1, uint64_t a2, uint64_t a3)
{
  v10[0] = 0LL;
  v10[1] = 0LL;
  sub_100242F28((uint64_t)v10, a1 + 360);
  if (a2)
  {
    for (uint64_t i = *(void *)(a1 + 336); i != *(void *)(a1 + 344); i += 8LL)
    {
      if (**(void **)i == a2)
      {
        uint64_t v7 = (*(uint64_t (**)(void, uint64_t, uint64_t))(**(void **)(*(void *)i + 768LL) + 96LL))( *(void *)(*(void *)i + 768LL),  a2,  a3);
        goto LABEL_9;
      }
    }
  }

  if (os_log_type_enabled((os_log_t)qword_1008F7560, OS_LOG_TYPE_ERROR))
  {
    sub_1003CF00C(a2, v9);
    sub_10065F474();
  }

  uint64_t v7 = 312LL;
LABEL_9:
  sub_100242FAC((uint64_t)v10);
  return v7;
}

void sub_10021762C(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, ...)
{
}

uint64_t sub_10021764C(uint64_t a1, uint64_t a2, uint64_t a3, unsigned int a4)
{
  v16[0] = 0LL;
  v16[1] = 0LL;
  sub_100242F28((uint64_t)v16, a1 + 360);
  char v8 = (os_log_s *)qword_1008F7560;
  BOOL v9 = os_log_type_enabled((os_log_t)qword_1008F7560, OS_LOG_TYPE_DEFAULT);
  if (v9)
  {
    uint64_t v10 = sub_100216F08(v9, a2);
    *(_DWORD *)__int128 buf = 136446722;
    BOOL v18 = v10;
    __int16 v19 = 1024;
    int v20 = a2;
    __int16 v21 = 1024;
    int v22 = a3;
    _os_log_impl( (void *)&_mh_execute_header,  v8,  OS_LOG_TYPE_DEFAULT,  "broadcastControlCommand: %{public}s (control cmd 0x%02X), value %d",  buf,  0x18u);
  }

  uint64_t v12 = *(uint64_t ***)(a1 + 336);
  uint64_t v11 = *(uint64_t ***)(a1 + 344);
  uint64_t v13 = 1LL;
  while (v12 != v11)
  {
    int v14 = *v12;
    if (*v12)
    {
      if (*v14)
      {
        uint64_t v13 = sub_100215778(a1, *v14, a2, a3, a4);
        uint64_t v11 = *(uint64_t ***)(a1 + 344);
      }
    }

    ++v12;
  }

  sub_100242FAC((uint64_t)v16);
  return v13;
}

void sub_100217784(_Unwind_Exception *exception_object)
{
}

uint64_t sub_1002177A0(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  v14[0] = 0LL;
  v14[1] = 0LL;
  sub_100242F28((uint64_t)v14, a1 + 360);
  char v8 = (os_log_s *)qword_1008F7560;
  if (os_log_type_enabled((os_log_t)qword_1008F7560, OS_LOG_TYPE_DEFAULT))
  {
    *(_DWORD *)__int128 buf = 67109376;
    int v16 = a2;
    __int16 v17 = 1024;
    int v18 = a3;
    _os_log_impl( (void *)&_mh_execute_header,  v8,  OS_LOG_TYPE_DEFAULT,  "broadcastCustomMsg: type: %u, len: %u",  buf,  0xEu);
  }

  uint64_t v10 = *(uint64_t ***)(a1 + 336);
  BOOL v9 = *(uint64_t ***)(a1 + 344);
  uint64_t v11 = 1LL;
  while (v10 != v9)
  {
    uint64_t v12 = *v10;
    if (*v10)
    {
      if (*v12)
      {
        uint64_t v11 = sub_100214E98(a1, *v12, a2, a3, a4);
        BOOL v9 = *(uint64_t ***)(a1 + 344);
      }
    }

    ++v10;
  }

  sub_100242FAC((uint64_t)v14);
  return v11;
}

void sub_1002178C8(_Unwind_Exception *exception_object)
{
}

uint64_t sub_1002178E4(double a1)
{
  if (a1 == 8000.0) {
    return 1LL;
  }
  if (a1 == 16000.0) {
    return 2LL;
  }
  if (a1 == 24000.0) {
    return 3LL;
  }
  if (a1 == 44100.0) {
    return 4LL;
  }
  if (a1 == 48000.0) {
    return 5LL;
  }
  return 0LL;
}

uint64_t sub_10021795C(uint64_t a1)
{
  v11[0] = 0LL;
  v11[1] = 0LL;
  sub_100242F28((uint64_t)v11, a1 + 360);
  uint64_t v2 = (os_log_s *)qword_1008F7560;
  if (os_log_type_enabled((os_log_t)qword_1008F7560, OS_LOG_TYPE_DEFAULT))
  {
    *(_WORD *)uint64_t v10 = 0;
    _os_log_impl( (void *)&_mh_execute_header,  v2,  OS_LOG_TYPE_DEFAULT,  "getStreamingDevice: no connected devices",  v10,  2u);
  }

  uint64_t v3 = *(uint64_t ***)(a1 + 336);
  char v4 = *(uint64_t ***)(a1 + 344);
  while (1)
  {
    if (v3 == v4)
    {
      uint64_t v7 = (os_log_s *)qword_1008F7560;
      if (os_log_type_enabled((os_log_t)qword_1008F7560, OS_LOG_TYPE_DEFAULT))
      {
        *(_WORD *)uint64_t v10 = 0;
        char v8 = "getA2DPStreamingDevice: no connected devices";
        goto LABEL_10;
      }

void sub_100217AB4(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, ...)
{
}

uint64_t sub_100217AC8(uint64_t a1, unsigned __int8 *a2, uint64_t a3)
{
  __int16 v15 = 0;
  int v14 = 0;
  if (!sub_1003FE1A4((uint64_t)&v14, a2))
  {
    if (os_log_type_enabled((os_log_t)qword_1008F7560, OS_LOG_TYPE_ERROR)) {
      sub_10065F7D8();
    }
    return 1LL;
  }

  if (qword_1008D5F50 != -1) {
    dispatch_once(&qword_1008D5F50, &stru_100888BF0);
  }
  LODWORD(__p[0]) = v14;
  WORD2(__p[0]) = v15;
  uint64_t v5 = sub_1003FFEB0(off_1008D5F48, (uint64_t)__p, 1);
  uint64_t v6 = (uint64_t)v5;
  if (v5)
  {
    int v7 = sub_1003E0164((uint64_t)v5);
    sub_1003DF238(v6, a3);
  }

  else
  {
    int v7 = 0;
  }

  if (!sub_100410EB0(a1) || v7 == (_DWORD)a3) {
    return 1LL;
  }
  BOOL v9 = (os_log_s *)qword_1008F7560;
  if (os_log_type_enabled((os_log_t)qword_1008F7560, OS_LOG_TYPE_DEFAULT))
  {
    sub_1003FE1B4((unsigned __int8 *)&v14, __p);
    uint64_t v10 = (void **)__p[0];
    uint64_t v11 = "doesn't own";
    if (v13 >= 0) {
      uint64_t v10 = __p;
    }
    if ((_DWORD)a3) {
      uint64_t v11 = "owns";
    }
    *(_DWORD *)__int128 buf = 136315394;
    __int16 v17 = v10;
    __int16 v18 = 2082;
    __int16 v19 = v11;
    _os_log_impl( (void *)&_mh_execute_header,  v9,  OS_LOG_TYPE_DEFAULT,  "Telling device %s that this source %{public}s the connection",  buf,  0x16u);
    if (v13 < 0) {
      operator delete(__p[0]);
    }
  }

  return sub_100215778(a1, v6, 6LL, a3, 1u);
}

uint64_t sub_100217CC0(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  v12[0] = 0LL;
  v12[1] = 0LL;
  sub_100242F28((uint64_t)v12, a1 + 360);
  if (a2)
  {
    for (uint64_t i = *(void *)(a1 + 336); i != *(void *)(a1 + 344); i += 8LL)
    {
      if (**(void **)i == a2)
      {
        uint64_t v9 = (*(uint64_t (**)(void, uint64_t, uint64_t, uint64_t))(**(void **)(*(void *)i + 768LL) + 112LL))( *(void *)(*(void *)i + 768LL),  a2,  a3,  a4);
        goto LABEL_9;
      }
    }
  }

  if (os_log_type_enabled((os_log_t)qword_1008F7560, OS_LOG_TYPE_ERROR))
  {
    sub_1003CF00C(a2, v11);
    sub_10065F474();
  }

  uint64_t v9 = 312LL;
LABEL_9:
  sub_100242FAC((uint64_t)v12);
  return v9;
}

void sub_100217DC8(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, ...)
{
}

uint64_t sub_100217DE8(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  v12[0] = 0LL;
  v12[1] = 0LL;
  sub_100242F28((uint64_t)v12, a1 + 360);
  if (a2)
  {
    for (uint64_t i = *(void *)(a1 + 336); i != *(void *)(a1 + 344); i += 8LL)
    {
      if (**(void **)i == a2)
      {
        uint64_t v9 = (*(uint64_t (**)(void, uint64_t, uint64_t, uint64_t))(**(void **)(*(void *)i + 768LL) + 120LL))( *(void *)(*(void *)i + 768LL),  a2,  a3,  a4);
        goto LABEL_9;
      }
    }
  }

  if (os_log_type_enabled((os_log_t)qword_1008F7560, OS_LOG_TYPE_ERROR))
  {
    sub_1003CF00C(a2, v11);
    sub_10065F804();
  }

  uint64_t v9 = 312LL;
LABEL_9:
  sub_100242FAC((uint64_t)v12);
  return v9;
}

void sub_100217EF0(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, ...)
{
}

uint64_t sub_100217F10(uint64_t a1, uint64_t a2, uint64_t a3)
{
  v10[0] = 0LL;
  v10[1] = 0LL;
  sub_100242F28((uint64_t)v10, a1 + 360);
  if (a2)
  {
    for (uint64_t i = *(void *)(a1 + 336); i != *(void *)(a1 + 344); i += 8LL)
    {
      if (**(void **)i == a2)
      {
        uint64_t v7 = (*(uint64_t (**)(void, uint64_t, uint64_t))(**(void **)(*(void *)i + 768LL) + 128LL))( *(void *)(*(void *)i + 768LL),  a2,  a3);
        goto LABEL_9;
      }
    }
  }

  if (os_log_type_enabled((os_log_t)qword_1008F7560, OS_LOG_TYPE_ERROR))
  {
    sub_1003CF00C(a2, v9);
    sub_10065F850();
  }

  uint64_t v7 = 312LL;
LABEL_9:
  sub_100242FAC((uint64_t)v10);
  return v7;
}

void sub_100218010(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, ...)
{
}

uint64_t sub_100218030(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, unsigned __int16 *a6)
{
  uint64_t v12 = (os_log_s *)qword_1008F7560;
  if (os_log_type_enabled((os_log_t)qword_1008F7560, OS_LOG_TYPE_DEFAULT))
  {
    sub_1003CF00C(a2, __p);
    char v13 = v24 >= 0 ? __p : (void **)__p[0];
    *(_DWORD *)__int128 buf = 136446978;
    *(void *)__int128 v26 = v13;
    *(_WORD *)&v26[8] = 1024;
    int v27 = a3;
    __int16 v28 = 1024;
    int v29 = a4;
    __int16 v30 = 1024;
    int v31 = a5;
    _os_log_impl( (void *)&_mh_execute_header,  v12,  OS_LOG_TYPE_DEFAULT,  "send setup command to %{public}s, setupType -> %d, opType -> %d, pldLen -> %d",  buf,  0x1Eu);
    if (v24 < 0) {
      operator delete(__p[0]);
    }
  }

  if ((_DWORD)a3 != 1)
  {
    uint64_t v19 = qword_1008F7560;
    if (!os_log_type_enabled((os_log_t)qword_1008F7560, OS_LOG_TYPE_DEFAULT)) {
      goto LABEL_15;
    }
    *(_DWORD *)__int128 buf = 67109120;
    *(_DWORD *)__int128 v26 = a3;
    int v16 = "Unsupported setup type = %d";
    __int16 v17 = (os_log_s *)v19;
    uint32_t v18 = 8;
    goto LABEL_14;
  }

  if (a5 >= 2)
  {
    if (!a6) {
      sub_1000E6B88( "/Library/Caches/com.apple.xbs/Sources/MobileBluetooth_base/Server/aacp/AACPClient.mm",  1098,  "pldData");
    }
    uint64_t v14 = qword_1008F7560;
    if (os_log_type_enabled((os_log_t)qword_1008F7560, OS_LOG_TYPE_DEFAULT))
    {
      int v15 = *a6;
      *(_DWORD *)__int128 buf = 67109376;
      *(_DWORD *)__int128 v26 = a4;
      *(_WORD *)&v26[4] = 1024;
      *(_DWORD *)&v26[6] = v15;
      v16 = "send seal setup operation opType = %d BOOL result = %d";
      __int16 v17 = (os_log_s *)v14;
      uint32_t v18 = 14;
LABEL_14:
      _os_log_impl((void *)&_mh_execute_header, v17, OS_LOG_TYPE_DEFAULT, v16, buf, v18);
    }
  }

void sub_1002182C4(_Unwind_Exception *a1, uint64_t a2, ...)
{
}

uint64_t sub_1002182E4(uint64_t a1, uint64_t a2, uint64_t a3, int a4, unsigned int a5, const void *a6)
{
  if (!*(_BYTE *)(a1 + 328)) {
    return 111LL;
  }
  bzero(&v32, 0x3E7uLL);
  char v24 = 0;
  v23[0] = 0LL;
  v23[1] = 0LL;
  sub_100242F28((uint64_t)v23, a1 + 360);
  if (a2)
  {
    for (uint64_t i = *(void **)(a1 + 336); i != *(void **)(a1 + 344); ++i)
    {
      char v13 = (void *)*i;
      if (*(void *)*i == a2) {
        goto LABEL_8;
      }
    }
  }

  char v13 = 0LL;
LABEL_8:
  uint64_t v14 = (os_log_s *)qword_1008F7560;
  if (os_log_type_enabled((os_log_t)qword_1008F7560, OS_LOG_TYPE_DEFAULT))
  {
    sub_1003CF00C(a2, __p);
    int v15 = v26 >= 0 ? __p : *(_BYTE **)__p;
    *(_DWORD *)__int128 buf = 136446722;
    *(void *)&uint8_t buf[4] = v15;
    int v16 = a4 == 1 ? "Audio Arbitration" : "Unknown";
    __int16 v28 = 2082;
    int v29 = v16;
    __int16 v30 = 1024;
    unsigned int v31 = a5;
    _os_log_impl( (void *)&_mh_execute_header,  v14,  OS_LOG_TYPE_DEFAULT,  "Send relay message to %{public}s, relayMessageType -> %{public}s, relayMessageLen -> %d",  buf,  0x1Cu);
    if (v26 < 0) {
      operator delete(*(void **)__p);
    }
  }

  if (a5 < 0x3E7)
  {
    if (v13)
    {
      if (a4 == 1)
      {
        char v22 = 0;
        sub_100242CA4(&v22);
        if (!sub_1001125B8(a2 + 128, &v24) && v24 == 2)
        {
          uint32_t v18 = (os_log_s *)qword_1008F7560;
          if (os_log_type_enabled((os_log_t)qword_1008F7560, OS_LOG_TYPE_DEFAULT))
          {
            sub_1003CF00C(a2, buf);
            uint64_t v19 = v30 >= 0 ? buf : *(_BYTE **)buf;
            *(_DWORD *)std::string __p = 136446210;
            *(void *)&__p[4] = v19;
            _os_log_impl( (void *)&_mh_execute_header,  v18,  OS_LOG_TYPE_DEFAULT,  "Unsniff ACL link with %{public}s for TiPi audio arbitration message",  __p,  0xCu);
            if (SHIBYTE(v30) < 0) {
              operator delete(*(void **)buf);
            }
          }

          sub_100113CA0(a2 + 128);
        }

        sub_100242CD0(&v22);
        sub_100242CD8(&v22);
      }

      char v32 = a4;
      memcpy(v33, a6, a5);
      buf[0] = 0;
      sub_100242CA4(buf);
      uint64_t v20 = sub_10007F56C((unsigned __int8 *)(a2 + 128), a3, (unsigned __int16)(a5 + 1), &v32);
      sub_100242CD0(buf);
      if ((_DWORD)v20 && os_log_type_enabled((os_log_t)qword_1008F7560, OS_LOG_TYPE_ERROR)) {
        sub_10065F9A0();
      }
      if (qword_1008D60B0 != -1) {
        dispatch_once(&qword_1008D60B0, &stru_100888AF0);
      }
      uint64_t v17 = sub_1004317E0((uint64_t)off_1008D60A8, v20, 10000);
      sub_100242CD8(buf);
    }

    else
    {
      if (os_log_type_enabled((os_log_t)qword_1008F7560, OS_LOG_TYPE_ERROR))
      {
        sub_1003CF00C(a2, buf);
        sub_10065F954();
      }

      uint64_t v17 = 312LL;
    }
  }

  else
  {
    if (os_log_type_enabled((os_log_t)qword_1008F7560, OS_LOG_TYPE_ERROR)) {
      sub_10065F8E8();
    }
    uint64_t v17 = 3LL;
  }

  sub_100242FAC((uint64_t)v23);
  return v17;
}

void sub_100218668( _Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, int a9, __int16 a10, char a11, char a12, char a13)
{
}

uint64_t sub_1002186B0(uint64_t a1, uint64_t a2, int a3, int *a4, unsigned int a5)
{
  if (!*(_BYTE *)(a1 + 328)) {
    return 111LL;
  }
  v20[0] = 0LL;
  v20[1] = 0LL;
  sub_100242F28((uint64_t)v20, a1 + 360);
  if (a2)
  {
    uint64_t v10 = *(void ***)(a1 + 336);
    uint64_t v11 = *(void ***)(a1 + 344);
    while (v10 != v11)
    {
      uint64_t v12 = *v10;
      if (**v10 == a2) {
        goto LABEL_8;
      }
      ++v10;
    }
  }

  uint64_t v12 = 0LL;
LABEL_8:
  char v13 = (os_log_s *)qword_1008F7560;
  if (os_log_type_enabled((os_log_t)qword_1008F7560, OS_LOG_TYPE_DEFAULT))
  {
    sub_1003CF00C(a2, __p);
    if (v22 >= 0) {
      uint64_t v14 = __p;
    }
    else {
      uint64_t v14 = (void **)__p[0];
    }
    int v15 = "Unknown";
    *(_DWORD *)__int128 buf = 136446722;
    char v24 = v14;
    else {
      int v16 = v15;
    }
    __int16 v25 = 2082;
    char v26 = v16;
    __int16 v27 = 1024;
    unsigned int v28 = a5;
    _os_log_impl( (void *)&_mh_execute_header,  v13,  OS_LOG_TYPE_DEFAULT,  "Send update request for connection priority list to %{public}s, reqType -> %{public}s, numOfConn -> %d",  buf,  0x1Cu);
    if (v22 < 0) {
      operator delete(__p[0]);
    }
  }

  if (a5 < 3)
  {
    if (v12)
    {
      if (!sub_1003D2B2C(a2, 32) || (uint64_t v17 = sub_1002189A8((uint64_t)v12, a3, a4, a5), !(_DWORD)v17))
      {
        buf[0] = 0;
        sub_100242CA4(buf);
        uint64_t v18 = sub_10007F75C((unsigned __int8 *)(a2 + 128), a5, (uint64_t)a4);
        sub_100242CD0(buf);
        if ((_DWORD)v18 && os_log_type_enabled((os_log_t)qword_1008F7560, OS_LOG_TYPE_ERROR)) {
          sub_10065FA6C();
        }
        if (qword_1008D60B0 != -1) {
          dispatch_once(&qword_1008D60B0, &stru_100888AF0);
        }
        uint64_t v17 = sub_1004317E0((uint64_t)off_1008D60A8, v18, 10000);
        sub_100242CD8(buf);
      }
    }

    else
    {
      if (os_log_type_enabled((os_log_t)qword_1008F7560, OS_LOG_TYPE_ERROR))
      {
        sub_1003CF00C(a2, buf);
        sub_10065F954();
      }

      uint64_t v17 = 312LL;
    }
  }

  else
  {
    if (os_log_type_enabled((os_log_t)qword_1008F7560, OS_LOG_TYPE_ERROR)) {
      sub_10065FA00();
    }
    uint64_t v17 = 3LL;
  }

  sub_100242FAC((uint64_t)v20);
  return v17;
}

void sub_100218970( _Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9)
{
}

uint64_t sub_1002189A8(uint64_t a1, int a2, int *a3, int a4)
{
  int v57 = a2;
  if (a2 == 2)
  {
    uint64_t v9 = (os_log_s *)qword_1008F7560;
    if (os_log_type_enabled((os_log_t)qword_1008F7560, OS_LOG_TYPE_DEFAULT))
    {
      sub_1003CF00C(*(void *)a1, &__p);
      uint64_t v10 = v61 >= 0 ? &__p : (void **)__p;
      *(_DWORD *)__int128 buf = 136446210;
      BOOL v63 = v10;
      _os_log_impl( (void *)&_mh_execute_header,  v9,  OS_LOG_TYPE_DEFAULT,  "Request Legacy Triangle connection priority list update for device %{public}s",  buf,  0xCu);
      if (v61 < 0) {
        operator delete(__p);
      }
    }

void sub_100218E5C( _Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, void *__p, uint64_t a20, int a21, __int16 a22, char a23, char a24)
{
  if (a24 < 0) {
    operator delete(__p);
  }
  _Unwind_Resume(exception_object);
}

void sub_100218E8C(uint64_t a1, uint64_t a2)
{
  uint64_t v4 = sub_1002E6BF0();
  if (((*(uint64_t (**)(uint64_t))(*(void *)v4 + 328LL))(v4) & 1) != 0)
  {
    if (qword_1008D9118 != -1) {
      dispatch_once(&qword_1008D9118, &stru_100888C30);
    }
    v5[0] = _NSConcreteStackBlock;
    v5[1] = 3221225472LL;
    _DWORD v5[2] = sub_100218F5C;
    v5[3] = &unk_10087F8E0;
    v5[4] = a1;
    void v5[5] = a2;
    sub_10041C1EC((uint64_t)off_1008D9110, v5);
  }

  else if (os_log_type_enabled((os_log_t)qword_1008F7560, OS_LOG_TYPE_ERROR))
  {
    sub_10065FB58();
  }

uint64_t sub_100218F5C(uint64_t a1)
{
  uint64_t v2 = *(void *)(a1 + 32);
  v27[0] = 0LL;
  v27[1] = 0LL;
  sub_100242F28((uint64_t)v27, v2 + 360);
  if (!*(void *)(v2 + 304))
  {
    uint64_t v3 = (os_log_s *)qword_1008F7560;
    if (os_log_type_enabled((os_log_t)qword_1008F7560, OS_LOG_TYPE_DEFAULT))
    {
      *(_WORD *)__int128 buf = 0;
      _os_log_impl((void *)&_mh_execute_header, v3, OS_LOG_TYPE_DEFAULT, "GAPA showCannotVerifyAlert", buf, 2u);
    }

    *(void *)(v2 + 312) = *(void *)(a1 + 40);
    *(_DWORD *)__int128 buf = 0;
    uint64_t v25 = 0LL;
    int v24 = 0;
    uint64_t v4 = sub_1003D8484(*(void *)(a1 + 40));
    else {
      sub_1003D55EC(*(void *)(a1 + 40), buf, (_DWORD *)&v25 + 1, &v25, &v24);
    }
    if ((v25 - 8195) <= 0x23 && ((1LL << (v25 - 3)) & 0xC0498E74DLL) != 0)
    {
      id v5 = sub_1002E95B8(@"GAPA_BT_SETTINGS_ALERT_HEADER_BEATS", @"Cannot Verify Beats");
      uint64_t v6 = (void *)objc_claimAutoreleasedReturnValue(v5);
      id v7 = sub_1002E95B8( @"GAPA_BT_SETTINGS_ALERT_MESSAGE_BEATS",  @"These headphones could not be verified as genuine Beats. Would you like to connect anyway?");
      uint64_t v8 = [v7 autorelease];
    }

    else
    {
      id v22 = sub_1002E95B8(@"GAPA_BT_SETTINGS_ALERT_HEADER", @"Cannot Verify AirPods");
      uint64_t v6 = (void *)objc_claimAutoreleasedReturnValue(v22);
      id v23 = sub_1002E95B8( @"GAPA_BT_SETTINGS_ALERT_MESSAGE",  @"These headphones could not be verified as genuine Apple AirPods. Would you like to connect anyway?");
      uint64_t v8 = objc_claimAutoreleasedReturnValue(v23);
    }

    uint64_t v9 = (void *)v8;
    id v10 = sub_1002E95B8(@"GAPA_BT_SETTINGS_ALERT_LEARNMORE", @"Learn More");
    int v11 = (void *)objc_claimAutoreleasedReturnValue(v10);
    id v12 = sub_1002E95B8(@"GAPA_BT_SETTINGS_ALERT_PAIRANYWAY", @"Connect Anyway");
    uint64_t v13 = (void *)objc_claimAutoreleasedReturnValue(v12);
    id v14 = sub_1002E95B8(@"GAPA_BT_SETTINGS_ALERT_CANCEL", @"Cancel");
    uint64_t v15 = (void *)objc_claimAutoreleasedReturnValue(v14);
    v28[0] = kCFUserNotificationAlertHeaderKey;
    v28[1] = kCFUserNotificationAlertMessageKey;
    v29[0] = v6;
    v29[1] = v9;
    void v28[2] = kCFUserNotificationAlternateButtonTitleKey;
    v28[3] = kCFUserNotificationOtherButtonTitleKey;
    void v29[2] = v11;
    char v29[3] = v13;
    v28[4] = kCFUserNotificationDefaultButtonTitleKey;
    v29[4] = v15;
    uint64_t v16 = (void *)objc_claimAutoreleasedReturnValue( +[NSDictionary dictionaryWithObjects:forKeys:count:]( &OBJC_CLASS___NSDictionary,  "dictionaryWithObjects:forKeys:count:",  v29,  v28,  5LL));
    uint64_t v17 = (const __CFDictionary *)[v16 mutableCopy];

    uint64_t v18 = CFUserNotificationCreate(kCFAllocatorDefault, 0.0, 3uLL, 0LL, v17);
    *(void *)(v2 + 304) = v18;
    RunLoopSource = CFUserNotificationCreateRunLoopSource( kCFAllocatorDefault,  v18,  (CFUserNotificationCallBack)sub_1002193C0,  0LL);
    if (RunLoopSource)
    {
      Main = CFRunLoopGetMain();
      CFRunLoopAddSource(Main, RunLoopSource, kCFRunLoopCommonModes);
      CFRelease(RunLoopSource);
    }

    else
    {
      CFUserNotificationCancel(*(CFUserNotificationRef *)(v2 + 304));
      CFRelease(*(CFTypeRef *)(v2 + 304));
      *(void *)(v2 + 304) = 0LL;
    }
  }

  return sub_100242FAC((uint64_t)v27);
}

void sub_1002192A8(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, ...)
{
  sub_100242FAC((uint64_t)va);
  _Unwind_Resume(a1);
}

uint64_t sub_100219328(uint64_t a1, _DWORD *a2)
{
  uint64_t v7 = 0LL;
  uint64_t v8 = 0LL;
  sub_1003D55EC((uint64_t)a2, (_DWORD *)&v8 + 1, &v8, (_DWORD *)&v7 + 1, &v7);
  int v3 = HIDWORD(v7);
  if (!HIDWORD(v7))
  {
    sub_1003E5EE8(a2, (_DWORD *)&v8 + 1, &v8, (_DWORD *)&v7 + 1, &v7);
    int v3 = HIDWORD(v7);
  }

  unsigned int v4 = ((v3 - 8212) < 0x11) & (0x116A1u >> (v3 - 20));
  uint64_t v5 = sub_1002E6E00();
  return v4 | (*(unsigned int (**)(uint64_t))(*(void *)v5 + 744LL))(v5);
}

void sub_1002193C0(uint64_t a1, uint64_t a2)
{
  if (qword_1008D60E0 != -1) {
    dispatch_once(&qword_1008D60E0, &stru_100888C10);
  }
  sub_100219410((uint64_t)off_1008D60D8, a2, a2);
}

void sub_100219410(uint64_t a1, uint64_t a2, uint64_t a3)
{
  if (qword_1008D9118 != -1) {
    dispatch_once(&qword_1008D9118, &stru_100888C30);
  }
  v5[0] = _NSConcreteStackBlock;
  v5[1] = 3221225472LL;
  _DWORD v5[2] = sub_1002194A0;
  v5[3] = &unk_10087F8E0;
  v5[4] = a1;
  void v5[5] = a3;
  sub_10041C1EC((uint64_t)off_1008D9110, v5);
}

uint64_t sub_1002194A0(uint64_t a1)
{
  uint64_t v2 = *(void *)(a1 + 32);
  v11[0] = 0LL;
  v11[1] = 0LL;
  sub_100242F28((uint64_t)v11, v2 + 360);
  int v3 = (os_log_s *)qword_1008F7560;
  if (os_log_type_enabled((os_log_t)qword_1008F7560, OS_LOG_TYPE_DEFAULT))
  {
    uint64_t v4 = *(void *)(a1 + 40);
    *(_DWORD *)__int128 buf = 134217984;
    uint64_t v13 = v4;
    _os_log_impl( (void *)&_mh_execute_header,  v3,  OS_LOG_TYPE_DEFAULT,  "GAPA user responded to cannot verify alert %ld",  buf,  0xCu);
  }

  uint64_t v5 = *(void *)(a1 + 40);
  if (v5)
  {
    if (v5 == 2)
    {
      uint64_t v9 = (os_log_s *)qword_1008F7560;
      if (os_log_type_enabled((os_log_t)qword_1008F7560, OS_LOG_TYPE_DEFAULT))
      {
        *(_WORD *)__int128 buf = 0;
        _os_log_impl((void *)&_mh_execute_header, v9, OS_LOG_TYPE_DEFAULT, "GAPA pairAnywayButton", buf, 2u);
      }

      if (qword_1008D60D0 != -1) {
        dispatch_once(&qword_1008D60D0, &stru_100888C50);
      }
      sub_1004287C4((int64x2_t *)off_1008D60C8, *(void *)(v2 + 312), -1);
    }

    else if (v5 == 1)
    {
      uint64_t v6 = (os_log_s *)qword_1008F7560;
      if (os_log_type_enabled((os_log_t)qword_1008F7560, OS_LOG_TYPE_DEFAULT))
      {
        *(_WORD *)__int128 buf = 0;
        _os_log_impl((void *)&_mh_execute_header, v6, OS_LOG_TYPE_DEFAULT, "GAPA learnMoreButton", buf, 2u);
      }

      if (qword_1008D60D0 != -1) {
        dispatch_once(&qword_1008D60D0, &stru_100888C50);
      }
      sub_1004287C4((int64x2_t *)off_1008D60C8, *(void *)(v2 + 312), -1);
      uint64_t v7 = (os_log_s *)qword_1008F7560;
      if (os_log_type_enabled((os_log_t)qword_1008F7560, OS_LOG_TYPE_DEFAULT))
      {
        *(_WORD *)__int128 buf = 0;
        _os_log_impl((void *)&_mh_execute_header, v7, OS_LOG_TYPE_DEFAULT, "GAPA user sent to URL", buf, 2u);
      }
    }

    else if (os_log_type_enabled((os_log_t)qword_1008F7560, OS_LOG_TYPE_ERROR))
    {
      sub_10065FB84();
    }
  }

  else
  {
    uint64_t v8 = (os_log_s *)qword_1008F7560;
    if (os_log_type_enabled((os_log_t)qword_1008F7560, OS_LOG_TYPE_DEFAULT))
    {
      *(_WORD *)__int128 buf = 0;
      _os_log_impl((void *)&_mh_execute_header, v8, OS_LOG_TYPE_DEFAULT, "GAPA cancelButton", buf, 2u);
    }

    sub_1003D84C8(*(void *)(v2 + 312), 0, 1799);
    if (qword_1008D67A8 != -1) {
      dispatch_once(&qword_1008D67A8, &stru_100888B50);
    }
    sub_10052F37C((uint64_t)off_1008D67A0, *(unsigned __int8 **)(v2 + 312));
  }

  CFRelease(*(CFTypeRef *)(v2 + 304));
  *(void *)(v2 + 304) = 0LL;
  *(void *)(v2 + 312) = 0LL;
  return sub_100242FAC((uint64_t)v11);
}

void sub_10021976C(_Unwind_Exception *exception_object)
{
}

uint64_t sub_100219788(int a1, void *__s)
{
  uint64_t v2 = qword_1008F7190;
  if ((_UNKNOWN *)qword_1008F7190 == &unk_1008F7198) {
    return 0LL;
  }
  uint64_t v4 = *((unsigned __int8 *)__s + 23);
  while (1)
  {
    uint64_t v5 = __s;
    uint64_t v6 = v4;
    if ((v4 & 0x80) != 0)
    {
      uint64_t v5 = (void *)*__s;
      uint64_t v6 = __s[1];
    }

    int v7 = *(char *)(v2 + 55);
    uint64_t v8 = v7 >= 0 ? (unsigned __int8 *)(v2 + 32) : *(unsigned __int8 **)(v2 + 32);
    int64_t v9 = v7 >= 0 ? *(unsigned __int8 *)(v2 + 55) : *(void *)(v2 + 40);
    if (!v9) {
      return *(unsigned int *)(v2 + 56);
    }
    if (v6 >= v9)
    {
      uint64_t v13 = (char *)v5 + v6;
      int v14 = *v8;
      uint64_t v15 = v5;
      do
      {
        uint64_t v16 = v6 - v9;
        if (v16 == -1) {
          break;
        }
        uint64_t v17 = (char *)memchr(v15, v14, v16 + 1);
        if (!v17) {
          break;
        }
        uint64_t v18 = v17;
        if (!memcmp(v17, v8, v9))
        {
          return *(unsigned int *)(v2 + 56);
        }

        uint64_t v15 = v18 + 1;
        uint64_t v6 = v13 - (v18 + 1);
      }

      while (v6 >= v9);
    }

    id v10 = *(void **)(v2 + 8);
    if (v10)
    {
      do
      {
        int v11 = v10;
        id v10 = (void *)*v10;
      }

      while (v10);
    }

    else
    {
      do
      {
        int v11 = *(void **)(v2 + 16);
        BOOL v12 = *v11 == v2;
        uint64_t v2 = (uint64_t)v11;
      }

      while (!v12);
    }

    uint64_t v2 = (uint64_t)v11;
    if (v11 == (void *)&unk_1008F7198) {
      return 0LL;
    }
  }

void sub_1002198C4(uint64_t a1, uint64_t a2, uint64_t a3)
{
  int v26 = *(_DWORD *)(a2 + 128);
  __int16 v27 = *(_WORD *)(a2 + 132);
  v24[0] = 0LL;
  v24[1] = 0LL;
  uint64_t v25 = 0LL;
  uint64_t v5 = sub_1003D930C(a2, 0xAu, v24);
  uint64_t v22 = 0LL;
  uint64_t v23 = 0LL;
  else {
    int v6 = sub_1003D55EC(a2, (_DWORD *)&v23 + 1, &v23, (_DWORD *)&v22 + 1, &v22);
  }
  if (*(char *)(a2 + 1503) < 0)
  {
    int v6 = sub_100024238(__p, *(void **)(a2 + 1480), *(void *)(a2 + 1488));
  }

  else
  {
    *(_OWORD *)std::string __p = *(_OWORD *)(a2 + 1480);
    uint64_t v21 = *(void *)(a2 + 1496);
  }

  unsigned int v7 = sub_100219788(v6, __p);
  if (SHIBYTE(v21) < 0) {
    operator delete(__p[0]);
  }
  id v19 = 0LL;
  if (v7 > 3) {
    uint64_t v8 = @"Unknown";
  }
  else {
    uint64_t v8 = (const __CFString *)*((void *)&off_100888F90 + (int)v7);
  }
  NSAppendPrintF_safe(&v19, "%@", v8);
  id v9 = v19;
  v30[0] = 0LL;
  v30[1] = 0LL;
  int v31 = 0;
  v28[0] = 0LL;
  v28[1] = 0LL;
  int v29 = 0;
  sub_1003DB5D0(a2, (uint64_t)v30);
  sub_1003DB604(a2, (uint64_t)v28);
  id v10 = [NSData dataWithBytes:v30 length:20LL];
  int v11 = (void *)objc_claimAutoreleasedReturnValue(+[NSData dataWithBytes:length:](&OBJC_CLASS___NSData, "dataWithBytes:length:", v28, 20LL));
  uint64_t v12 = sub_1002E8D94();
  int v17 = v26;
  __int16 v18 = v27;
  uint64_t v14 = HIDWORD(v22);
  uint64_t v13 = v23;
  if (SHIBYTE(v25) < 0)
  {
    sub_100024238(__dst, v24[0], (unint64_t)v24[1]);
  }

  else
  {
    *(_OWORD *)__int128 __dst = *(_OWORD *)v24;
    uint64_t v16 = v25;
  }

  (*(void (**)(uint64_t, int *, uint64_t, uint64_t, uint64_t, void **, id, void *, void *))(*(void *)v12 + 360LL))( v12,  &v17,  a3,  v13,  v14,  __dst,  v9,  v10,  v11);
  if (SHIBYTE(v16) < 0) {
    operator delete(__dst[0]);
  }

  if (SHIBYTE(v25) < 0) {
    operator delete(v24[0]);
  }
}

void sub_100219B2C( _Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, void *a11, uint64_t a12, int a13, __int16 a14, char a15, char a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20, uint64_t a21, uint64_t a22, uint64_t a23, uint64_t a24, void *__p, uint64_t a26, int a27, __int16 a28, char a29, char a30)
{
  if (a30 < 0) {
    operator delete(__p);
  }
  _Unwind_Resume(exception_object);
}

uint64_t sub_100219B98(uint64_t a1, uint64_t a2, unsigned int a3)
{
  v24[0] = 0LL;
  v24[1] = 0LL;
  sub_100242F28((uint64_t)v24, a1 + 360);
  uint64_t v6 = sub_1002E6E00();
  if (((*(unsigned int (**)(uint64_t))(*(void *)v6 + 712LL))(v6) & (a3 >> 9)) == 1)
  {
    unsigned int v7 = (os_log_s *)qword_1008F7560;
    BOOL v8 = os_log_type_enabled((os_log_t)qword_1008F7560, OS_LOG_TYPE_DEFAULT);
    if (v8)
    {
      *(_WORD *)__int128 buf = 0;
      _os_log_impl((void *)&_mh_execute_header, v7, OS_LOG_TYPE_DEFAULT, "GAPA hide auth fail", buf, 2u);
    }

    sub_1002198C4(v8, a2, a3 | 2);
  }

  else
  {
    uint64_t v9 = sub_1003D8484(a2);
    if ((v9 & 2) != 0)
    {
      uint64_t v14 = (os_log_s *)qword_1008F7560;
      if (os_log_type_enabled((os_log_t)qword_1008F7560, OS_LOG_TYPE_DEFAULT))
      {
        *(_DWORD *)__int128 buf = 67109120;
        *(_DWORD *)&uint8_t buf[4] = a3;
        _os_log_impl((void *)&_mh_execute_header, v14, OS_LOG_TYPE_DEFAULT, "Add new GAPA bits 0x%x", buf, 8u);
      }

      sub_1003D84C8(a2, a3, a3);
    }

    else
    {
      int v10 = sub_100219328(v9, (_DWORD *)a2);
      uint64_t v11 = a3 | 2;
      uint64_t v12 = (os_log_s *)qword_1008F7560;
      BOOL v13 = os_log_type_enabled((os_log_t)qword_1008F7560, OS_LOG_TYPE_DEFAULT);
      if (v10)
      {
        if (v13)
        {
          *(_DWORD *)__int128 buf = 67109120;
          *(_DWORD *)&uint8_t buf[4] = v11;
          _os_log_impl((void *)&_mh_execute_header, v12, OS_LOG_TYPE_DEFAULT, "Zero device GAPA 0x%x", buf, 8u);
        }

        sub_1003E5F0C(a2);
        sub_1003D6538(a2, 0, 0, 0, 0);
        sub_1003D6758(a2, 0, 0);
        sub_1003D6A34(a2, 0LL, 0);
        sub_1003DF3AC(a2);
      }

      else if (v13)
      {
        *(_DWORD *)__int128 buf = 67109120;
        *(_DWORD *)&uint8_t buf[4] = v11;
        _os_log_impl((void *)&_mh_execute_header, v12, OS_LOG_TYPE_DEFAULT, "Limited morph device GAPA 0x%x", buf, 8u);
      }

      uint64_t v15 = sub_1003D84C8(a2, v11, v11);
      sub_1002198C4(v15, a2, v11);
      int v17 = *(unsigned __int8 *)(a2 + 1435);
      memset(buf, 0, sizeof(buf));
      uint64_t v32 = 0LL;
      if (*(char *)(a2 + 1503) < 0)
      {
        int v16 = sub_100024238(buf, *(void **)(a2 + 1480), *(void *)(a2 + 1488));
      }

      else
      {
        *(_OWORD *)__int128 buf = *(_OWORD *)(a2 + 1480);
        uint64_t v32 = *(void *)(a2 + 1496);
      }

      if (SHIBYTE(v32) < 0)
      {
        int v16 = sub_100024238(__p, *(void **)buf, *(unint64_t *)&buf[8]);
      }

      else
      {
        *(_OWORD *)std::string __p = *(_OWORD *)buf;
        uint64_t v23 = v32;
      }

      int v18 = sub_100219788(v16, __p);
      if (SHIBYTE(v23) < 0) {
        operator delete(__p[0]);
      }
      id v19 = (os_log_s *)qword_1008F7560;
      if (os_log_type_enabled((os_log_t)qword_1008F7560, OS_LOG_TYPE_DEFAULT))
      {
        uint64_t v20 = buf;
        if (v32 < 0) {
          uint64_t v20 = *(uint8_t **)buf;
        }
        *(_DWORD *)uint64_t v25 = 67109634;
        int v26 = v17;
        __int16 v27 = 1024;
        int v28 = v18;
        __int16 v29 = 2080;
        __int16 v30 = v20;
        _os_log_impl( (void *)&_mh_execute_header,  v19,  OS_LOG_TYPE_DEFAULT,  "GAPA alert control userConnected=%d, deviceStartSession=%d (%s)",  v25,  0x18u);
      }

      if (v17 && v18 == 1) {
        sub_100218E8C(a1, a2);
      }
      if (SHIBYTE(v32) < 0) {
        operator delete(*(void **)buf);
      }
    }
  }

  return sub_100242FAC((uint64_t)v24);
}

void sub_100219F18( _Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, char a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, void *__p, uint64_t a20, int a21, __int16 a22, char a23, char a24)
{
}

void sub_100219F50(uint64_t a1, uint64_t a2)
{
  if ((_os_feature_enabled_impl("BluetoothFeatures", "GAPA") & 1) == 0)
  {
    uint64_t v13 = qword_1008F7560;
    if (!os_log_type_enabled((os_log_t)qword_1008F7560, OS_LOG_TYPE_DEFAULT)) {
      return;
    }
    sub_1003CF00C(a2, __p);
    if (v46[0] >= 0) {
      uint64_t v14 = __p;
    }
    else {
      uint64_t v14 = *(_BYTE **)__p;
    }
    *(_DWORD *)__int128 buf = 136315138;
    *(void *)&uint8_t buf[4] = v14;
    int v10 = "GAPA non-auth disabled for %s";
LABEL_18:
    uint64_t v11 = (os_log_s *)v13;
    uint32_t v12 = 12;
LABEL_19:
    _os_log_impl((void *)&_mh_execute_header, v11, OS_LOG_TYPE_DEFAULT, v10, buf, v12);
    if (SHIBYTE(v46[0]) < 0) {
      operator delete(*(void **)__p);
    }
    return;
  }

  uint64_t v4 = sub_1002E6E00();
  if (((*(uint64_t (**)(uint64_t))(*(void *)v4 + 736LL))(v4) & 1) == 0)
  {
    uint64_t v15 = qword_1008F7560;
    if (!os_log_type_enabled((os_log_t)qword_1008F7560, OS_LOG_TYPE_DEFAULT)) {
      return;
    }
    *(_WORD *)std::string __p = 0;
    int v16 = "GAPA non-auth is disabled by defaults write";
LABEL_25:
    int v17 = (os_log_s *)v15;
    uint32_t v18 = 2;
    goto LABEL_26;
  }

  uint64_t v5 = sub_1002E6BF0();
  if (((*(uint64_t (**)(uint64_t))(*(void *)v5 + 328LL))(v5) & 1) == 0)
  {
    uint64_t v15 = qword_1008F7560;
    if (!os_log_type_enabled((os_log_t)qword_1008F7560, OS_LOG_TYPE_DEFAULT)) {
      return;
    }
    *(_WORD *)std::string __p = 0;
    int v16 = "GAPA non-auth is disabled for this OS";
    goto LABEL_25;
  }

  if (qword_1008D5F50 != -1) {
    dispatch_once(&qword_1008D5F50, &stru_100888BF0);
  }
  if ((sub_100401058((uint64_t)off_1008D5F48) & 1) == 0)
  {
    uint64_t v13 = qword_1008F7560;
    if (!os_log_type_enabled((os_log_t)qword_1008F7560, OS_LOG_TYPE_DEFAULT)) {
      return;
    }
    sub_1003CF00C(a2, __p);
    if (v46[0] >= 0) {
      id v19 = __p;
    }
    else {
      id v19 = *(_BYTE **)__p;
    }
    *(_DWORD *)__int128 buf = 136446210;
    *(void *)&uint8_t buf[4] = v19;
    int v10 = "Device has not been unlocked (or device prefs not read yet) - disabling GAPA non-auth for %{public}s";
    goto LABEL_18;
  }

  int v6 = sub_1003D8484(a2);
  if (v6)
  {
    int v7 = v6;
    uint64_t v8 = qword_1008F7560;
    if (!os_log_type_enabled((os_log_t)qword_1008F7560, OS_LOG_TYPE_DEFAULT)) {
      return;
    }
    sub_1003CF00C(a2, __p);
    if (v46[0] >= 0) {
      uint64_t v9 = __p;
    }
    else {
      uint64_t v9 = *(_BYTE **)__p;
    }
    *(_DWORD *)__int128 buf = 136315394;
    *(void *)&uint8_t buf[4] = v9;
    __int16 v41 = 1024;
    int v42 = v7;
    int v10 = "Known GAPA result for %s cbGAPAFlags=0x%x non-auth not supported";
    uint64_t v11 = (os_log_s *)v8;
    uint32_t v12 = 18;
    goto LABEL_19;
  }

  uint64_t v38 = 0LL;
  uint64_t v39 = 0LL;
  sub_1003D55EC(a2, (_DWORD *)&v39 + 1, &v39, (_DWORD *)&v38 + 1, &v38);
  if (!sub_1003D2AF4(a2)
    || (uint64_t v20 = (void *)objc_claimAutoreleasedReturnValue( +[CBProductInfo productInfoWithProductID:]( CBProductInfo,  "productInfoWithProductID:",  HIDWORD(v38))),  v21 = ((unsigned __int16)[v20 flags] & 0x800) == 0,  v20,  v21))
  {
    uint64_t v23 = qword_1008F7560;
    if (!os_log_type_enabled((os_log_t)qword_1008F7560, OS_LOG_TYPE_DEFAULT)) {
      return;
    }
    *(_DWORD *)std::string __p = 67109888;
    *(_DWORD *)&__p[4] = HIDWORD(v39);
    *(_WORD *)&__p[8] = 1024;
    *(_DWORD *)&__p[10] = v39;
    *(_WORD *)uint64_t v45 = 1024;
    *(_DWORD *)&v45[2] = HIDWORD(v38);
    LOWORD(v46[0]) = 1024;
    *(_DWORD *)((char *)v46 + 2) = v38;
    int v16 = "No GAPA non-auth for vidSrc=%d, vid=0x%x, pid=0x%x, version=%d";
    int v17 = (os_log_s *)v23;
    uint32_t v18 = 26;
LABEL_26:
    _os_log_impl((void *)&_mh_execute_header, v17, OS_LOG_TYPE_DEFAULT, v16, __p, v18);
    return;
  }

  int v24 = sub_100219328(v22, (_DWORD *)a2);
  if (((v24 ^ 1 | sub_1003D2B2C(a2, 42)) & 1) != 0)
  {
    unsigned int v25 = 0;
  }

  else
  {
    int v26 = (os_log_s *)qword_1008F7560;
    if (os_log_type_enabled((os_log_t)qword_1008F7560, OS_LOG_TYPE_DEFAULT))
    {
      sub_1003CF00C(a2, buf);
      __int16 v27 = v43 >= 0 ? buf : *(_BYTE **)buf;
      *(_DWORD *)std::string __p = 136315650;
      *(void *)&__p[4] = v27;
      *(_WORD *)&_BYTE __p[12] = 1024;
      *(_DWORD *)uint64_t v45 = HIDWORD(v38);
      *(_WORD *)&v45[4] = 1024;
      v46[0] = 0;
      _os_log_impl( (void *)&_mh_execute_header,  v26,  OS_LOG_TYPE_DEFAULT,  "Invalid device configuration %s pid=0x%x deviceInfoGAPA=%d",  __p,  0x18u);
      if (v43 < 0) {
        operator delete(*(void **)buf);
      }
    }

    unsigned int v25 = 1024;
  }

  unsigned __int16 v37 = 0;
  char v36 = 0;
  __int16 v35 = 0;
  if (sub_1003D6EF4(a2, &v37, &v36, &v35))
  {
    uint64_t v28 = sub_1002E6E00();
    if ((*(unsigned int (**)(uint64_t))(*(void *)v28 + 720LL))(v28))
    {
      unsigned __int16 v37 = 1494;
      goto LABEL_50;
    }

    if (v37 != 76)
    {
LABEL_50:
      __int16 v29 = (os_log_s *)qword_1008F7560;
      if (os_log_type_enabled((os_log_t)qword_1008F7560, OS_LOG_TYPE_DEFAULT))
      {
        sub_1003CF00C(a2, __p);
        __int16 v30 = v46[0] >= 0 ? __p : *(_BYTE **)__p;
        *(_DWORD *)__int128 buf = 136315394;
        *(void *)&uint8_t buf[4] = v30;
        __int16 v41 = 1024;
        int v42 = v37;
        _os_log_impl( (void *)&_mh_execute_header,  v29,  OS_LOG_TYPE_DEFAULT,  "GAPA detect for %s is mfgName=0x%x",  buf,  0x12u);
        if (SHIBYTE(v46[0]) < 0) {
          operator delete(*(void **)__p);
        }
      }

      v25 |= 4u;
    }
  }

  uint64_t v31 = sub_1002E8D94();
  int v33 = *(_DWORD *)(a2 + 128);
  __int16 v34 = *(_WORD *)(a2 + 132);
  (*(void (**)(uint64_t, int *, void, void))(*(void *)v31 + 368LL))(v31, &v33, 0LL, 0LL);
  *(void *)std::string __p = a2 + 128;
  sub_10023ED80((uint64_t **)(a1 + 536), a2 + 128, (uint64_t)&unk_1006C2518, (_DWORD **)__p)[31] = 1;
  uint64_t v32 = (os_log_s *)qword_1008F7560;
  if (os_log_type_enabled((os_log_t)qword_1008F7560, OS_LOG_TYPE_DEFAULT))
  {
    *(_DWORD *)std::string __p = 67109120;
    *(_DWORD *)&__p[4] = v25;
    _os_log_impl( (void *)&_mh_execute_header,  v32,  OS_LOG_TYPE_DEFAULT,  "GAPA non-auth detect is complete flags=0x%x",  __p,  8u);
  }

  if (v25) {
    sub_100219B98(a1, a2, v25);
  }
  if (qword_1008D60C0 != -1) {
    dispatch_once(&qword_1008D60C0, &stru_100888BD0);
  }
  sub_1003F637C((uint64_t)off_1008D60B8, a2, 4102);
}

void sub_10021A580(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

BOOL sub_10021A598(uint64_t a1, uint64_t a2)
{
  return sub_10023EEEC(a1 + 536, a2 + 128) == 1;
}

uint64_t sub_10021A5BC(uint64_t a1, _DWORD *a2, uint64_t a3, char a4)
{
  if ((_os_feature_enabled_impl("BluetoothFeatures", "GAPA") & 1) == 0)
  {
    uint64_t v17 = qword_1008F7560;
    BOOL v18 = os_log_type_enabled((os_log_t)qword_1008F7560, OS_LOG_TYPE_DEFAULT);
    uint64_t result = 0LL;
    if (!v18) {
      return result;
    }
    sub_1003CF00C((uint64_t)a2, __p);
    if (v51[0] >= 0) {
      id v19 = __p;
    }
    else {
      id v19 = *(_BYTE **)__p;
    }
    *(_DWORD *)__int128 buf = 136315138;
    *(void *)&uint8_t buf[4] = v19;
    int v16 = "GAPA auth disabled for %s";
    goto LABEL_18;
  }

  uint64_t v8 = sub_1002E6E00();
  if (((*(uint64_t (**)(uint64_t))(*(void *)v8 + 728LL))(v8) & 1) == 0)
  {
    uint64_t v22 = qword_1008F7560;
    BOOL v23 = os_log_type_enabled((os_log_t)qword_1008F7560, OS_LOG_TYPE_DEFAULT);
    uint64_t result = 0LL;
    if (!v23) {
      return result;
    }
    *(_WORD *)std::string __p = 0;
    int v24 = "GAPA auth is disabled by defaults write";
    goto LABEL_25;
  }

  uint64_t v9 = sub_1002E6BF0();
  if (((*(uint64_t (**)(uint64_t))(*(void *)v9 + 328LL))(v9) & 1) == 0)
  {
    uint64_t v22 = qword_1008F7560;
    BOOL v25 = os_log_type_enabled((os_log_t)qword_1008F7560, OS_LOG_TYPE_DEFAULT);
    uint64_t result = 0LL;
    if (!v25) {
      return result;
    }
    *(_WORD *)std::string __p = 0;
    int v24 = "GAPA auth is disabled for this OS";
    goto LABEL_25;
  }

  if (qword_1008D5F50 != -1) {
    dispatch_once(&qword_1008D5F50, &stru_100888BF0);
  }
  if ((sub_100401058((uint64_t)off_1008D5F48) & 1) == 0)
  {
    uint64_t v17 = qword_1008F7560;
    BOOL v28 = os_log_type_enabled((os_log_t)qword_1008F7560, OS_LOG_TYPE_DEFAULT);
    uint64_t result = 0LL;
    if (!v28) {
      return result;
    }
    sub_1003CF00C((uint64_t)a2, __p);
    if (v51[0] >= 0) {
      __int16 v29 = __p;
    }
    else {
      __int16 v29 = *(_BYTE **)__p;
    }
    *(_DWORD *)__int128 buf = 136446210;
    *(void *)&uint8_t buf[4] = v29;
    int v16 = "Device has not been unlocked (or device prefs not read yet) - disabling GAPA auth for %{public}s";
LABEL_18:
    uint64_t v20 = (os_log_s *)v17;
    uint32_t v21 = 12;
    goto LABEL_19;
  }

  int v10 = sub_1003D8484((uint64_t)a2);
  if (v10)
  {
    int v11 = v10;
    uint64_t v12 = qword_1008F7560;
    BOOL v13 = os_log_type_enabled((os_log_t)qword_1008F7560, OS_LOG_TYPE_DEFAULT);
    uint64_t result = 0LL;
    if (!v13) {
      return result;
    }
    sub_1003CF00C((uint64_t)a2, __p);
    if (v51[0] >= 0) {
      uint64_t v15 = __p;
    }
    else {
      uint64_t v15 = *(_BYTE **)__p;
    }
    *(_DWORD *)__int128 buf = 136315394;
    *(void *)&uint8_t buf[4] = v15;
    __int16 v46 = 1024;
    int v47 = v11;
    int v16 = "Known GAPA result for %s cbGAPAFlags=0x%x auth not supported";
    goto LABEL_40;
  }

  int v30 = *(_DWORD *)(a3 + 600);
  if (!v30)
  {
    uint64_t v43 = 0LL;
    uint64_t v44 = 0LL;
    sub_1003D55EC((uint64_t)a2, (_DWORD *)&v44 + 1, &v44, (_DWORD *)&v43 + 1, &v43);
    if (!sub_1003D2AF4((uint64_t)a2)
      || (int v33 = (void *)objc_claimAutoreleasedReturnValue( +[CBProductInfo productInfoWithProductID:]( CBProductInfo,  "productInfoWithProductID:",  HIDWORD(v43))),  v34 = ((unsigned __int16)[v33 flags] & 0x800) == 0,  v33,  v34))
    {
      uint64_t v35 = qword_1008F7560;
      BOOL v36 = os_log_type_enabled((os_log_t)qword_1008F7560, OS_LOG_TYPE_DEFAULT);
      uint64_t result = 0LL;
      if (!v36) {
        return result;
      }
      *(_DWORD *)std::string __p = 67109888;
      *(_DWORD *)&__p[4] = HIDWORD(v44);
      *(_WORD *)&__p[8] = 1024;
      *(_DWORD *)&__p[10] = v44;
      *(_WORD *)int v50 = 1024;
      *(_DWORD *)&v50[2] = HIDWORD(v43);
      LOWORD(v51[0]) = 1024;
      *(_DWORD *)((char *)v51 + 2) = v43;
      int v24 = "No GAPA auth for vidSrc=%d, vid=0x%x, pid=0x%x, version=%d";
      int v26 = (os_log_s *)v35;
      uint32_t v27 = 26;
LABEL_26:
      _os_log_impl((void *)&_mh_execute_header, v26, OS_LOG_TYPE_DEFAULT, v24, __p, v27);
      return 0LL;
    }

    uint64_t v37 = sub_1003D2B2C((uint64_t)a2, 42);
    if ((v37 & 1) != 0)
    {
      int v38 = sub_100219328(v37, a2);
      uint64_t result = 1LL;
      if (v38 && (a4 & 1) == 0)
      {
        uint64_t v39 = (os_log_s *)qword_1008F7560;
        if (os_log_type_enabled((os_log_t)qword_1008F7560, OS_LOG_TYPE_DEFAULT))
        {
          sub_1003CF00C((uint64_t)a2, buf);
          int v40 = v48 >= 0 ? buf : *(_BYTE **)buf;
          *(_DWORD *)std::string __p = 136315650;
          *(void *)&__p[4] = v40;
          *(_WORD *)&_BYTE __p[12] = 1024;
          *(_DWORD *)int v50 = HIDWORD(v43);
          *(_WORD *)&v50[4] = 1024;
          v51[0] = 0;
          _os_log_impl( (void *)&_mh_execute_header,  v39,  OS_LOG_TYPE_DEFAULT,  "Invalid device configuration %s pid=0x%x isCertificateSupported=%d",  __p,  0x18u);
          if (v48 < 0) {
            operator delete(*(void **)buf);
          }
        }

        uint64_t v41 = sub_1002E6E00();
        sub_100219B98(a1, (uint64_t)a2, 0x100u);
        return 0LL;
      }

      return result;
    }

    uint64_t v22 = qword_1008F7560;
    BOOL v42 = os_log_type_enabled((os_log_t)qword_1008F7560, OS_LOG_TYPE_DEFAULT);
    uint64_t result = 0LL;
    if (!v42) {
      return result;
    }
    *(_WORD *)std::string __p = 0;
    int v24 = "Accessory device does not support GAPA auth not supported";
LABEL_25:
    int v26 = (os_log_s *)v22;
    uint32_t v27 = 2;
    goto LABEL_26;
  }

  uint64_t v12 = qword_1008F7560;
  BOOL v31 = os_log_type_enabled((os_log_t)qword_1008F7560, OS_LOG_TYPE_DEFAULT);
  uint64_t result = 0LL;
  if (v31)
  {
    sub_1003CF00C((uint64_t)a2, __p);
    if (v51[0] >= 0) {
      uint64_t v32 = __p;
    }
    else {
      uint64_t v32 = *(_BYTE **)__p;
    }
    *(_DWORD *)__int128 buf = 136315394;
    *(void *)&uint8_t buf[4] = v32;
    __int16 v46 = 1024;
    int v47 = v30;
    int v16 = "Invalid GAPA state for %s authState=%d auth not supported";
LABEL_40:
    uint64_t v20 = (os_log_s *)v12;
    uint32_t v21 = 18;
LABEL_19:
    _os_log_impl((void *)&_mh_execute_header, v20, OS_LOG_TYPE_DEFAULT, v16, buf, v21);
    if (SHIBYTE(v51[0]) < 0) {
      operator delete(*(void **)__p);
    }
    return 0LL;
  }

  return result;
}

void sub_10021AB28(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_10021AB40(uint64_t a1, uint64_t a2)
{
  if (*(_BYTE *)(a1 + 328))
  {
    if (qword_1008D9118 != -1) {
      dispatch_once(&qword_1008D9118, &stru_100888C30);
    }
    v4[0] = _NSConcreteStackBlock;
    v4[1] = 3221225472LL;
    void v4[2] = sub_10021ABD8;
    v4[3] = &unk_10087F8E0;
    v4[4] = a1;
    void v4[5] = a2;
    sub_10041C1EC((uint64_t)off_1008D9110, v4);
  }

void sub_10021ABD8(uint64_t a1)
{
}

uint64_t sub_10021ABE4(uint64_t a1, uint64_t a2, uint64_t a3, int a4, char a5)
{
  if (!*(_BYTE *)(a1 + 328)) {
    return 111LL;
  }
  if (!a2) {
    return 8LL;
  }
  v40[0] = 0LL;
  v40[1] = 0LL;
  sub_100242F28((uint64_t)v40, a1 + 360);
  for (uint64_t i = *(void ***)(a1 + 336); i != *(void ***)(a1 + 344); ++i)
  {
    int v11 = *i;
    if (**i == a2)
    {
      BOOL v13 = (os_log_s *)qword_1008F7560;
      if (os_log_type_enabled((os_log_t)qword_1008F7560, OS_LOG_TYPE_DEFAULT))
      {
        sub_1003CF00C(a2, __p);
        int v14 = v39;
        uint64_t v15 = (void **)__p[0];
        uint64_t v23 = sub_1001EDE10(a3, v16, v17, v18, v19, v20, v21, v22);
        int v24 = __p;
        if (v14 < 0) {
          int v24 = v15;
        }
        else {
          BOOL v25 = off_100888FB0[a4 - 1];
        }
        *(_DWORD *)__int128 buf = 136446722;
        BOOL v42 = v24;
        __int16 v43 = 2080;
        uint64_t v44 = v23;
        __int16 v45 = 2082;
        __int16 v46 = v25;
        _os_log_impl( (void *)&_mh_execute_header,  v13,  OS_LOG_TYPE_DEFAULT,  "setDeviceStateOnPeerSrc: device %{public}s, peer source %s, device state %{public}s",  buf,  0x20u);
        if (v39 < 0) {
          operator delete(__p[0]);
        }
      }

      if ((a5 & 1) == 0)
      {
        int v26 = sub_10021AF3C(a1, a2) ^ 1;
        if (a4 != 3) {
          LOBYTE(v26) = 1;
        }
        if ((v26 & 1) == 0
          && *(_DWORD *)a3 == dword_1008D90E8
          && *(unsigned __int16 *)(a3 + 4) == (unsigned __int16)word_1008D90EC)
        {
          BOOL v28 = (os_log_s *)qword_1008F7560;
          if (os_log_type_enabled((os_log_t)qword_1008F7560, OS_LOG_TYPE_DEFAULT))
          {
            *(_WORD *)__int128 buf = 0;
            _os_log_impl( (void *)&_mh_execute_header,  v28,  OS_LOG_TYPE_DEFAULT,  "setDeviceStateOnPeerSrc: Triangle recovery begun; starting easy pairing agent first",
              buf,
              2u);
          }

          *((_BYTE *)v11 + 72std::ostream::~ostream(v2, v3 + 8) = 1;
          sub_10021AFA4(a1, v11);
        }
      }

      if (*(_DWORD *)a3 != dword_1008D90E8 || *(unsigned __int16 *)(a3 + 4) != (unsigned __int16)word_1008D90EC)
      {
        int v36 = *(_DWORD *)a3;
        __int16 v37 = *(_WORD *)(a3 + 4);
        sub_10021B100((uint64_t)v11, (unsigned __int8 *)&v36, a4);
        LOWORD(v42) = 0;
        *(_DWORD *)__int128 buf = 0;
        if (qword_1008D60B0 != -1) {
          dispatch_once(&qword_1008D60B0, &stru_100888AF0);
        }
        sub_100431644((uint64_t)off_1008D60A8, (uint64_t)buf);
        int v34 = *(_DWORD *)buf;
        __int16 v35 = (__int16)v42;
        int v32 = *(_DWORD *)a3;
        __int16 v33 = *(_WORD *)(a3 + 4);
        sub_10021B218((uint64_t)v11, (uint64_t)&v34, (uint64_t)&v32);
        BOOL v30 = sub_10021B43C((uint64_t)v11);
        sub_10021B398(v30, a2, v30);
      }

      uint64_t v12 = 0LL;
      goto LABEL_40;
    }
  }

  if (os_log_type_enabled((os_log_t)qword_1008F7560, OS_LOG_TYPE_ERROR)) {
    sub_10065FBE8();
  }
  uint64_t v12 = 312LL;
LABEL_40:
  sub_100242FAC((uint64_t)v40);
  return v12;
}

void sub_10021AF00( _Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, void *__p, uint64_t a13, int a14, __int16 a15, char a16, char a17, char a18)
{
  if (a17 < 0) {
    operator delete(__p);
  }
  sub_100242FAC((uint64_t)&a18);
  _Unwind_Resume(a1);
}

uint64_t sub_10021AF3C(uint64_t a1, uint64_t a2)
{
  if (!*(_BYTE *)(a1 + 430)) {
    return 0LL;
  }
  if (*(_BYTE *)(a1 + 424))
  {
    BOOL v2 = 0;
    if (!a2) {
      return 0LL;
    }
  }

  else
  {
    unint64_t v3 = 0LL;
    do
    {
      unint64_t v4 = v3;
      if (v3 == 5) {
        break;
      }
      ++v3;
    }

    while (!*(_BYTE *)(a1 + 425 + v4));
    BOOL v2 = v4 > 4;
    if (!a2) {
      return 0LL;
    }
  }

  if (v2 || *(_BYTE *)(a2 + 960)) {
    return 0LL;
  }
  return sub_1003D2B2C(a2, 12);
}

void sub_10021AFA4(uint64_t a1, uint64_t *a2)
{
  uint64_t v4 = *a2;
  if ((sub_10021AF3C(a1, *a2) & 1) != 0)
  {
    uint64_t v5 = a2[6];
    if (v5)
    {
      int v6 = (os_log_s *)qword_1008F7560;
      if (os_log_type_enabled((os_log_t)qword_1008F7560, OS_LOG_TYPE_DEFAULT))
      {
        sub_1003CF00C(v4, __p);
        if (v10 >= 0) {
          int v7 = __p;
        }
        else {
          int v7 = (void **)__p[0];
        }
        *(_DWORD *)__int128 buf = 136446210;
        uint64_t v12 = v7;
        _os_log_impl( (void *)&_mh_execute_header,  v6,  OS_LOG_TYPE_DEFAULT,  "startEasyPairAgent: starting easy pair agent for %{public}s",  buf,  0xCu);
        if (v10 < 0) {
          operator delete(__p[0]);
        }
      }

      sub_10020954C(v5);
    }
  }

  else
  {
    uint64_t v8 = (os_log_s *)qword_1008F7560;
    if (os_log_type_enabled((os_log_t)qword_1008F7560, OS_LOG_TYPE_DEFAULT))
    {
      LOWORD(__p[0]) = 0;
      _os_log_impl( (void *)&_mh_execute_header,  v8,  OS_LOG_TYPE_DEFAULT,  "startEasyPairAgent: Cannot use magnet link",  (uint8_t *)__p,  2u);
    }
  }

char *sub_10021B100(uint64_t a1, unsigned __int8 *a2, int a3)
{
  int v6 = (os_log_s *)qword_1008F7560;
  if (os_log_type_enabled((os_log_t)qword_1008F7560, OS_LOG_TYPE_DEFAULT))
  {
    sub_1003FE1B4(a2, __p);
    if (v10 >= 0) {
      int v7 = __p;
    }
    else {
      int v7 = (void **)__p[0];
    }
    *(_DWORD *)__int128 buf = 136446466;
    uint64_t v12 = v7;
    __int16 v13 = 1024;
    int v14 = a3;
    _os_log_impl( (void *)&_mh_execute_header,  v6,  OS_LOG_TYPE_DEFAULT,  "fSrcConnMap Setting %{public}s to %d",  buf,  0x12u);
    if (v10 < 0) {
      operator delete(__p[0]);
    }
  }

  __p[0] = a2;
  uint64_t result = sub_10023ED80((uint64_t **)(a1 + 704), (uint64_t)a2, (uint64_t)&unk_1006C2518, (_DWORD **)__p);
  result[31] = a3;
  return result;
}

void sub_10021B218(uint64_t a1, uint64_t a2, uint64_t a3)
{
  __int16 v29 = 0;
  int v28 = 0;
  if (qword_1008D60B0 != -1) {
    dispatch_once(&qword_1008D60B0, &stru_100888AF0);
  }
  sub_100431644((uint64_t)off_1008D60A8, (uint64_t)&v28);
  int v6 = *(_DWORD *)a2;
  *(_WORD *)(a1 + 609) = *(_WORD *)(a2 + 4);
  *(_DWORD *)(a1 + 605) = v6;
  LOWORD(v6) = *(_WORD *)(a3 + 4);
  *(_DWORD *)(a1 + 611) = *(_DWORD *)a3;
  *(_WORD *)(a1 + 615) = v6;
  BOOL v8 = v28 != *(_DWORD *)a3 || v29 != *(_WORD *)(a3 + 4);
  *(_BYTE *)(a1 + 61memset((char *)&v11[1] + 1, 0, 7) = v8;
  uint64_t v9 = (os_log_s *)qword_1008F7560;
  if (os_log_type_enabled((os_log_t)qword_1008F7560, OS_LOG_TYPE_DEFAULT))
  {
    uint64_t v17 = sub_1001EDE10(a2, v10, v11, v12, v13, v14, v15, v16);
    uint64_t v25 = sub_1001EDE10(a3, v18, v19, v20, v21, v22, v23, v24);
    int v26 = *(unsigned __int8 *)(a1 + 617);
    *(_DWORD *)__int128 buf = 136446722;
    uint64_t v31 = v17;
    if (v26) {
      uint32_t v27 = "Yes";
    }
    else {
      uint32_t v27 = "No";
    }
    __int16 v32 = 2082;
    uint64_t v33 = v25;
    __int16 v34 = 2080;
    __int16 v35 = v27;
    _os_log_impl( (void *)&_mh_execute_header,  v9,  OS_LOG_TYPE_DEFAULT,  "Set source addresses in TiPi, primaryAddr %{public}s, tipiAddr %{public}s, is_primary = %s ",  buf,  0x20u);
  }

uint64_t sub_10021B398(uint64_t a1, uint64_t a2, char a3)
{
  uint64_t v5 = sub_100405058();
  v10[0] = _NSConcreteStackBlock;
  v10[1] = 3221225472LL;
  void v10[2] = sub_10023BD54;
  v10[3] = &unk_1008800D8;
  char v10[4] = a2;
  char v11 = a3;
  sub_100405384(v5, v10);
  uint64_t v6 = sub_1004050C8();
  v8[0] = _NSConcreteStackBlock;
  v8[1] = 3221225472LL;
  void v8[2] = sub_10023BDA8;
  v8[3] = &unk_1008800D8;
  void v8[4] = a2;
  char v9 = a3;
  sub_100405384(v6, v8);
  return 0LL;
}

BOOL sub_10021B43C(uint64_t a1)
{
  if (*(_BYTE *)(a1 + 617)) {
    BOOL v2 = (int *)(a1 + 611);
  }
  else {
    BOOL v2 = (int *)(a1 + 605);
  }
  int v5 = *v2;
  __int16 v6 = *((_WORD *)v2 + 2);
  uint64_t v3 = sub_10023EACC(a1 + 704, (uint64_t)&v5);
  return a1 + 712 != v3 && *(_BYTE *)(v3 + 31) == 1;
}

uint64_t sub_10021B4B4(uint64_t a1)
{
  return *(unsigned __int8 *)(a1 + 520);
}

uint64_t sub_10021B4BC(uint64_t a1, uint64_t a2, int a3)
{
  __int16 v6 = (os_log_s *)qword_1008F7560;
  BOOL v7 = os_log_type_enabled((os_log_t)qword_1008F7560, OS_LOG_TYPE_DEFAULT);
  if (v7)
  {
    BOOL v8 = "Legacy Connection";
    if (a3) {
      BOOL v8 = "TiPi Connection";
    }
    int v10 = 136446210;
    char v11 = v8;
    _os_log_impl( (void *)&_mh_execute_header,  v6,  OS_LOG_TYPE_DEFAULT,  "Notify Connection update: %{public}s",  (uint8_t *)&v10,  0xCu);
  }

  sub_10021B398(v7, a2, a3);
  *(_BYTE *)(a1 + 520) = a3;
  return 0LL;
}

uint64_t sub_10021B598(uint64_t a1, uint64_t a2)
{
  v9[0] = 0LL;
  v9[1] = 0LL;
  sub_100242F28((uint64_t)v9, a1 + 360);
  if (a2)
  {
    for (uint64_t i = *(void ***)(a1 + 336); i != *(void ***)(a1 + 344); ++i)
    {
      if (**i == a2)
      {
        char v8 = 0;
        sub_100242CA4(&v8);
        uint64_t v7 = sub_100080B20((unsigned __int8 *)(a2 + 128));
        sub_100242CD0(&v8);
        if ((_DWORD)v7 && os_log_type_enabled((os_log_t)qword_1008F7560, OS_LOG_TYPE_ERROR)) {
          sub_10065FC40();
        }
        if (qword_1008D60B0 != -1) {
          dispatch_once(&qword_1008D60B0, &stru_100888AF0);
        }
        uint64_t v5 = sub_1004317E0((uint64_t)off_1008D60A8, v7, 10000);
        sub_100242CD8(&v8);
        goto LABEL_9;
      }
    }
  }

  if (os_log_type_enabled((os_log_t)qword_1008F7560, OS_LOG_TYPE_ERROR)) {
    sub_10065FC14();
  }
  uint64_t v5 = 312LL;
LABEL_9:
  sub_100242FAC((uint64_t)v9);
  return v5;
}

void sub_10021B6CC(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, ...)
{
}

void sub_10021B6F0(int a1@<W1>, uint64_t a2@<X8>)
{
  *(void *)a2 = 0LL;
  *(void *)(a2 + std::ostream::~ostream(v2, v3 + 8) = 0LL;
  *(void *)(a2 + 16) = 0LL;
  if (qword_1008D5F50 != -1) {
    dispatch_once(&qword_1008D5F50, &stru_100888BF0);
  }
  uint64_t v16 = 0LL;
  uint64_t v17 = 0LL;
  uint64_t v18 = 0LL;
  sub_10040247C((uint64_t)off_1008D5F48, a1, (void **)&v16);
  uint64_t v4 = v16;
  uint64_t v5 = v17;
  if (v16 != v17)
  {
    while (1)
    {
      uint64_t v6 = *v4;
      if ((sub_1003D2B2C(*v4, 3) & 1) == 0)
      {
LABEL_24:
        uint64_t v4 = v16;
        goto LABEL_25;
      }

      __p[0] = 0LL;
      __p[1] = 0LL;
      uint64_t v15 = 0LL;
      sub_1003D930C(v6, 3u, __p);
      unint64_t v7 = HIBYTE(v15);
      int v8 = SHIBYTE(v15);
      if (v15 < 0) {
        unint64_t v7 = (unint64_t)__p[1];
      }
      if (v7 >= 2) {
        break;
      }
      if (v15 < 0) {
        goto LABEL_9;
      }
LABEL_10:
      if (++v4 == v5) {
        goto LABEL_24;
      }
    }

    char v9 = (os_log_s *)qword_1008F7560;
    if (os_log_type_enabled((os_log_t)qword_1008F7560, OS_LOG_TYPE_DEFAULT))
    {
      int v10 = (void **)__p[0];
      if (v8 >= 0) {
        int v10 = __p;
      }
      *(_DWORD *)__int128 buf = 136446466;
      uint64_t v20 = v10;
      __int16 v21 = 1024;
      int v22 = a1;
      _os_log_impl( (void *)&_mh_execute_header,  v9,  OS_LOG_TYPE_DEFAULT,  "getCaseSerialNumbersForAppleProductId: Retrieved serial number %{public}s belonging to pId %u",  buf,  0x12u);
    }

    unint64_t v11 = *(void *)(a2 + 8);
    if (v11 >= *(void *)(a2 + 16))
    {
      uint64_t v13 = sub_10023EFAC((char **)a2, (__int128 *)__p);
    }

    else
    {
      if (SHIBYTE(v15) < 0)
      {
        sub_100024238(*(_BYTE **)(a2 + 8), __p[0], (unint64_t)__p[1]);
      }

      else
      {
        __int128 v12 = *(_OWORD *)__p;
        *(void *)(v11 + 16) = v15;
        *(_OWORD *)unint64_t v11 = v12;
      }

      uint64_t v13 = (char *)(v11 + 24);
      *(void *)(a2 + std::ostream::~ostream(v2, v3 + 8) = v11 + 24;
    }

    *(void *)(a2 + std::ostream::~ostream(v2, v3 + 8) = v13;
    if ((v15 & 0x8000000000000000LL) == 0) {
      goto LABEL_10;
    }
LABEL_9:
    operator delete(__p[0]);
    goto LABEL_10;
  }

void sub_10021B920( _Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, void *__p, uint64_t a12, int a13, __int16 a14, char a15, char a16, void *a17, uint64_t a18)
{
  v18[1] = v19;
  if (a16 < 0) {
    operator delete(__p);
  }
  if (a17)
  {
    a18 = (uint64_t)a17;
    operator delete(a17);
  }

  a17 = v18;
  sub_100024304((void ***)&a17);
  _Unwind_Resume(a1);
}

uint64_t sub_10021B978(uint64_t a1, uint64_t a2)
{
  v7[0] = 0LL;
  v7[1] = 0LL;
  sub_100242F28((uint64_t)v7, a1 + 360);
  if (a2)
  {
    for (uint64_t i = *(void *)(a1 + 336); i != *(void *)(a1 + 344); i += 8LL)
    {
      if (**(void **)i == a2)
      {
        uint64_t v5 = *(unsigned int *)(*(void *)i + 16LL);
        goto LABEL_8;
      }
    }
  }

  uint64_t v5 = 3LL;
LABEL_8:
  sub_100242FAC((uint64_t)v7);
  return v5;
}

uint64_t sub_10021B9F0(uint64_t a1, _BYTE *a2)
{
  if (*a2)
  {
    if (*a2 != 1) {
      goto LABEL_20;
    }
    uint64_t v4 = sub_1002E6BF0();
    if ((*(unsigned int (**)(uint64_t))(*(void *)v4 + 384LL))(v4))
    {
      uint64_t v5 = a2 + 5;
      if (a2[5] != 2)
      {
        int v6 = *(_DWORD *)(a1 + 512);
        if (v6 == -1)
        {
          unint64_t v7 = (int *)(a1 + 512);
          notify_register_check("com.apple.audioaccessoryd.MuteEducationalCard", v7);
          int v6 = *v7;
        }

        notify_set_state(v6, 1uLL);
        notify_post("com.apple.audioaccessoryd.MuteEducationalCard");
        goto LABEL_13;
      }
    }

    else
    {
      uint64_t v8 = sub_1002E6BF0();
      if ((*(unsigned int (**)(uint64_t))(*(void *)v8 + 424LL))(v8))
      {
        uint64_t v5 = a2 + 5;
        if (a2[5] != 2)
        {
LABEL_13:
          *uint64_t v5 = 2;
          int v9 = 1;
LABEL_14:
          if (a2[6]) {
            BOOL v10 = a2[4] == 0;
          }
          else {
            BOOL v10 = 1;
          }
          if (v10 | v9)
          {
            a2[6] = 2;
            a2[4] = 3;
            goto LABEL_19;
          }

          goto LABEL_20;
        }
      }
    }

    int v9 = 0;
    goto LABEL_14;
  }

  if (!a2[2])
  {
    a2[2] = 2;
LABEL_19:
    uint64_t v11 = 1LL;
    goto LABEL_21;
  }

void sub_10021BBB4(uint64_t a1, uint64_t a2, int a3, int a4)
{
  *(_DWORD *)((char *)v16 + 3) = 0;
  v16[0] = 0;
  if ((a4 & 0xF) == 1)
  {
    LOBYTE(v16[0]) = 1;
    HIBYTE(v16[0]) = a4 >> 4;
    LOBYTE(v16[1]) = BYTE1(a4) & 0xF;
    BYTE1(v16[1]) = (unsigned __int16)a4 >> 12;
    BYTE2(v16[1]) = BYTE2(a4) & 0xF;
  }

  else if ((a4 & 0xF) == 0)
  {
    LOBYTE(v16[0]) = 0;
    BYTE1(v16[0]) = a4 >> 4;
    BYTE2(v16[0]) = BYTE1(a4) & 0xF;
    HIBYTE(v16[0]) = a4 >> 4;
    LOBYTE(v16[1]) = BYTE1(a4) & 0xF;
  }

  if (sub_10021B9F0(a1, v16))
  {
    unint64_t v7 = v16[0] | ((unint64_t)(LOWORD(v16[1]) | (BYTE2(v16[1]) << 16)) << 32);
    unsigned int v8 = (v16[0] >> 20) & 0xF0 | (v7 >> 24) & 0xF00 | (v7 >> 28) & 0xF000 | (LOWORD(v16[1]) | (BYTE2(v16[1]) << 16)) & 0xF0000 | 1;
    unsigned int v9 = (v16[0] >> 4) & 0xF0 | (v16[0] >> 8) & 0xF00;
    if (LOBYTE(v16[0])) {
      unsigned int v9 = 0;
    }
    if (LOBYTE(v16[0]) == 1) {
      uint64_t v10 = v8;
    }
    else {
      uint64_t v10 = v9;
    }
    int v11 = sub_100215778(a1, a2, 36LL, v10, 2u);
    __int128 v12 = (os_log_s *)qword_1008F7560;
    if (os_log_type_enabled((os_log_t)qword_1008F7560, OS_LOG_TYPE_DEFAULT))
    {
      sub_100216F34(a1, a3, v10, __p);
      uint64_t v13 = v15 >= 0 ? __p : (void **)__p[0];
      *(_DWORD *)__int128 buf = 136446210;
      uint64_t v18 = v13;
      _os_log_impl( (void *)&_mh_execute_header,  v12,  OS_LOG_TYPE_DEFAULT,  "Call Management: sending default %{public}s",  buf,  0xCu);
      if (v15 < 0) {
        operator delete(__p[0]);
      }
    }

    if (v11 == 1 && os_log_type_enabled((os_log_t)qword_1008F7560, OS_LOG_TYPE_ERROR)) {
      sub_10065FCA0();
    }
  }

uint64_t sub_10021BDC8(uint64_t a1)
{
  int v2 = *(_DWORD *)(a1 + 508);
  if (v2 == -1)
  {
    uint64_t v3 = (int *)(a1 + 508);
    notify_register_check("com.apple.audioaccessoryd.MuteState", (int *)(a1 + 508));
    int v2 = *v3;
  }

  notify_set_state(v2, 1uLL);
  return notify_post("com.apple.audioaccessoryd.MuteState");
}

uint64_t sub_10021BE18(uint64_t a1, uint64_t a2, uint64_t a3)
{
  uint64_t v6 = sub_100410EB0(a1);
  if ((_DWORD)v6)
  {
    uint64_t v6 = sub_100215778(a1, a2, 13LL, a3, 2u);
    uint64_t v7 = v6;
  }

  else
  {
    uint64_t v7 = 1LL;
  }

  sub_10021BE8C(v6, a2);
  return v7;
}

void sub_10021BE8C(uint64_t a1, uint64_t a2)
{
  uint64_t v3 = (os_log_s *)qword_1008F7560;
  if (os_log_type_enabled((os_log_t)qword_1008F7560, OS_LOG_TYPE_DEFAULT))
  {
    sub_1003D0100(a2, (uint64_t)__p);
    if (v10 >= 0) {
      uint64_t v4 = __p;
    }
    else {
      uint64_t v4 = (void **)__p[0];
    }
    *(_DWORD *)__int128 buf = 136315138;
    __int128 v12 = v4;
    _os_log_impl( (void *)&_mh_execute_header,  v3,  OS_LOG_TYPE_DEFAULT,  "Notify listen mode change for device %s",  buf,  0xCu);
    if (v10 < 0) {
      operator delete(__p[0]);
    }
  }

  uint64_t v5 = sub_100405058();
  v8[0] = _NSConcreteStackBlock;
  v8[1] = 3221225472LL;
  void v8[2] = sub_100235114;
  v8[3] = &unk_10087EB20;
  void v8[4] = a2;
  sub_100405384(v5, v8);
  uint64_t v6 = sub_1004050C8();
  v7[0] = _NSConcreteStackBlock;
  v7[1] = 3221225472LL;
  void v7[2] = sub_100235178;
  void v7[3] = &unk_10087EB20;
  void v7[4] = a2;
  sub_100405384(v6, v7);
}

void sub_10021BFCC(uint64_t a1, uint64_t a2)
{
  int v3 = sub_10021C224(a1, a2);
  unsigned __int8 v13 = v3;
  if (qword_1008D5F50 != -1) {
    dispatch_once(&qword_1008D5F50, &stru_100888BF0);
  }
  if ((sub_100401058((uint64_t)off_1008D5F48) & 1) != 0)
  {
    uint64_t v4 = sub_1002E6D7C();
    int v5 = (*(uint64_t (**)(uint64_t, uint64_t, unsigned __int8 *))(*(void *)v4 + 864LL))(v4, a2, &v13);
    sub_1003DDCA8(a2, v13, v5 != 0);
    uint64_t v6 = (os_log_s *)qword_1008F7560;
    if (os_log_type_enabled((os_log_t)qword_1008F7560, OS_LOG_TYPE_DEFAULT))
    {
      if (v13) {
        uint64_t v7 = "enabled";
      }
      else {
        uint64_t v7 = "disabled";
      }
      sub_1003CF00C(a2, __p);
      if (v17 >= 0) {
        unsigned int v8 = __p;
      }
      else {
        unsigned int v8 = *(_BYTE **)__p;
      }
      unsigned int v9 = "Success";
      *(_DWORD *)__int128 buf = 136315650;
      if (v5) {
        unsigned int v9 = "Error";
      }
      *(void *)&uint8_t buf[4] = v7;
      __int16 v19 = 2082;
      uint64_t v20 = v8;
      __int16 v21 = 2080;
      int v22 = v9;
      _os_log_impl( (void *)&_mh_execute_header,  v6,  OS_LOG_TYPE_DEFAULT,  "Device unlocked, initializing IED enable to %s for device %{public}s with read %s",  buf,  0x20u);
      if (v17 < 0) {
        operator delete(*(void **)__p);
      }
    }
  }

  else
  {
    char v10 = (os_log_s *)qword_1008F7560;
    if (os_log_type_enabled((os_log_t)qword_1008F7560, OS_LOG_TYPE_DEFAULT))
    {
      int v11 = v3 ? "enabled" : "disabled";
      sub_1003CF00C(a2, buf);
      __int128 v12 = v21 >= 0 ? buf : *(_BYTE **)buf;
      *(_DWORD *)std::string __p = 136315394;
      *(void *)&__p[4] = v11;
      __int16 v15 = 2082;
      uint64_t v16 = v12;
      _os_log_impl( (void *)&_mh_execute_header,  v10,  OS_LOG_TYPE_DEFAULT,  "Device not unlocked yet (or device prefs not read yet), initializing IED enable to %s for device %{public}s",  __p,  0x16u);
      if (SHIBYTE(v21) < 0) {
        operator delete(*(void **)buf);
      }
    }

    sub_1003DDCA8(a2, v3, 0);
  }

uint64_t sub_10021C224(uint64_t a1, uint64_t a2)
{
  if (!a2) {
    return 0LL;
  }
  uint64_t v3 = 1LL;
  if ((sub_1003D2B2C(a2, 1) & 1) == 0) {
    uint64_t v3 = sub_1003D2B2C(a2, 15);
  }
  uint64_t v4 = (os_log_s *)qword_1008F7560;
  if (os_log_type_enabled((os_log_t)qword_1008F7560, OS_LOG_TYPE_INFO))
  {
    sub_1003CF00C(a2, __p);
    int v5 = (void **)__p[0];
    uint64_t v6 = "false";
    if (v9 >= 0) {
      int v5 = __p;
    }
    if ((_DWORD)v3) {
      uint64_t v6 = "true";
    }
    *(_DWORD *)__int128 buf = 136446466;
    int v11 = v5;
    __int16 v12 = 2082;
    unsigned __int8 v13 = v6;
    _os_log_impl( (void *)&_mh_execute_header,  v4,  OS_LOG_TYPE_INFO,  "In Ear detection support state for %{public}s is %{public}s",  buf,  0x16u);
    if (v9 < 0) {
      operator delete(__p[0]);
    }
  }

  return v3;
}

uint64_t sub_10021C354(uint64_t a1, uint64_t a2)
{
  v8[0] = 0LL;
  v8[1] = 0LL;
  sub_100242F28((uint64_t)v8, a1 + 360);
  if (a2)
  {
    for (uint64_t i = *(void ***)(a1 + 336); i != *(void ***)(a1 + 344); ++i)
    {
      if (**i == a2)
      {
        unsigned int v7 = 0;
        sub_10021BFCC(a1, a2);
        uint64_t v5 = sub_1002E6D7C();
        return sub_100242FAC((uint64_t)v8);
      }
    }
  }

  return sub_100242FAC((uint64_t)v8);
}

void sub_10021C400(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, ...)
{
}

uint64_t sub_10021C418(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  v12[0] = 0LL;
  v12[1] = 0LL;
  sub_100242F28((uint64_t)v12, a1 + 360);
  if (a2)
  {
    for (uint64_t i = *(void *)(a1 + 336); i != *(void *)(a1 + 344); i += 8LL)
    {
      if (**(void **)i == a2)
      {
        uint64_t v9 = (*(uint64_t (**)(void, uint64_t, uint64_t, uint64_t))(**(void **)(*(void *)i + 768LL) + 80LL))( *(void *)(*(void *)i + 768LL),  a2,  a3,  a4);
        goto LABEL_9;
      }
    }
  }

  if (os_log_type_enabled((os_log_t)qword_1008F7560, OS_LOG_TYPE_ERROR))
  {
    sub_1003CF00C(a2, v11);
    sub_10065F474();
  }

  uint64_t v9 = 312LL;
LABEL_9:
  sub_100242FAC((uint64_t)v12);
  return v9;
}

void sub_10021C520(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, ...)
{
}

uint64_t sub_10021C540(uint64_t a1, uint64_t a2, uint64_t a3)
{
  v10[0] = 0LL;
  v10[1] = 0LL;
  sub_100242F28((uint64_t)v10, a1 + 360);
  if (a2)
  {
    for (uint64_t i = *(void *)(a1 + 336); i != *(void *)(a1 + 344); i += 8LL)
    {
      if (**(void **)i == a2)
      {
        uint64_t v7 = (*(uint64_t (**)(void, uint64_t, uint64_t))(**(void **)(*(void *)i + 768LL) + 160LL))( *(void *)(*(void *)i + 768LL),  a2,  a3);
        goto LABEL_9;
      }
    }
  }

  if (os_log_type_enabled((os_log_t)qword_1008F7560, OS_LOG_TYPE_ERROR))
  {
    sub_1003CF00C(a2, v9);
    sub_10065F474();
  }

  uint64_t v7 = 312LL;
LABEL_9:
  sub_100242FAC((uint64_t)v10);
  return v7;
}

void sub_10021C640(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, ...)
{
}

uint64_t sub_10021C660(uint64_t a1, uint64_t a2)
{
  v8[0] = 0LL;
  v8[1] = 0LL;
  sub_100242F28((uint64_t)v8, a1 + 360);
  if (a2)
  {
    for (uint64_t i = *(void *)(a1 + 336); i != *(void *)(a1 + 344); i += 8LL)
    {
      if (**(void **)i == a2)
      {
        uint64_t v5 = (*(uint64_t (**)(void, uint64_t))(**(void **)(*(void *)i + 768LL) + 168LL))( *(void *)(*(void *)i + 768LL),  a2);
        goto LABEL_9;
      }
    }
  }

  if (os_log_type_enabled((os_log_t)qword_1008F7560, OS_LOG_TYPE_ERROR))
  {
    sub_1003CF00C(a2, v7);
    sub_10065F474();
  }

  uint64_t v5 = 312LL;
LABEL_9:
  sub_100242FAC((uint64_t)v8);
  return v5;
}

void sub_10021C750(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, ...)
{
}

uint64_t sub_10021C770(uint64_t a1, uint64_t a2)
{
  char v15 = 0;
  uint64_t v4 = sub_1002E6BF0();
  if ((*(unsigned int (**)(uint64_t))(*(void *)v4 + 352LL))(v4))
  {
    int v5 = 1;
LABEL_17:
    char v15 = v5;
    goto LABEL_18;
  }

  uint64_t v6 = sub_1002E6BF0();
  if ((*(unsigned int (**)(uint64_t))(*(void *)v6 + 360LL))(v6))
  {
    int v5 = 2;
    goto LABEL_17;
  }

  uint64_t v7 = sub_1002E6BF0();
  if ((*(unsigned int (**)(uint64_t))(*(void *)v7 + 368LL))(v7))
  {
    int v5 = 3;
    goto LABEL_17;
  }

  uint64_t v8 = sub_1002E6BF0();
  if ((*(unsigned int (**)(uint64_t))(*(void *)v8 + 384LL))(v8))
  {
    int v5 = 16;
    goto LABEL_17;
  }

  uint64_t v9 = sub_1002E6BF0();
  if ((*(unsigned int (**)(uint64_t))(*(void *)v9 + 376LL))(v9))
  {
    int v5 = 32;
    goto LABEL_17;
  }

  uint64_t v10 = sub_1002E6BF0();
  if ((*(unsigned int (**)(uint64_t))(*(void *)v10 + 336LL))(v10))
  {
    int v5 = 48;
    goto LABEL_17;
  }

  uint64_t v11 = sub_1002E6BF0();
  if ((*(unsigned int (**)(uint64_t))(*(void *)v11 + 400LL))(v11))
  {
    int v5 = 49;
    goto LABEL_17;
  }

  uint64_t v12 = sub_1002E6BF0();
  if ((*(unsigned int (**)(uint64_t))(*(void *)v12 + 424LL))(v12))
  {
    int v5 = 64;
    goto LABEL_17;
  }

  int v5 = 0;
LABEL_18:
  unsigned __int8 v13 = (os_log_s *)qword_1008F7560;
  if (os_log_type_enabled((os_log_t)qword_1008F7560, OS_LOG_TYPE_DEFAULT))
  {
    *(_DWORD *)__int128 buf = 67109120;
    int v17 = v5;
    _os_log_impl((void *)&_mh_execute_header, v13, OS_LOG_TYPE_DEFAULT, "sendSourceType %d", buf, 8u);
  }

  return sub_100214FD0(a1, a2, 2LL, 1LL, (uint64_t)&v15);
}

void sub_10021C920(void *a1, unsigned __int8 *a2, int a3, int a4)
{
  char v61 = 0;
  v59[0] = 0LL;
  v59[1] = 0LL;
  uint64_t v60 = 0LL;
  if (!a2) {
    return;
  }
  v58[0] = 0LL;
  v58[1] = 0LL;
  sub_100242F28((uint64_t)v58, (uint64_t)(a1 + 45));
  int v53 = sub_10021D36C(a1, (uint64_t)a2, a3);
  sub_10021BFCC((uint64_t)a1, (uint64_t)a2);
  int v50 = a3;
  if (_os_feature_enabled_impl("BluetoothFeatures", "ConnectionSetup") && (a4 & 1) == 0)
  {
    int v51 = a4;
    __int128 v56 = 0u;
    __int128 v57 = 0u;
    *(_OWORD *)int v55 = 0u;
    *(void *)__int128 buf = a2 + 128;
    __p[0] = buf;
    uint64_t v8 = sub_10023F1E0((uint64_t)(a1 + 56), buf, (uint64_t)&unk_1006C2518, (void **)__p);
    sub_10023F4CC((uint64_t)v55, v8 + 3);
    uint64_t v9 = (os_log_s *)qword_1008F7560;
    if (os_log_type_enabled((os_log_t)qword_1008F7560, OS_LOG_TYPE_DEFAULT))
    {
      uint64_t v10 = *((void *)&v57 + 1);
      sub_1003CF00C((uint64_t)a2, __p);
      uint64_t v11 = v63 >= 0 ? __p : (void **)__p[0];
      *(_DWORD *)__int128 buf = 134218243;
      *(void *)&uint8_t buf[4] = v10;
      *(_WORD *)&_BYTE buf[12] = 2081;
      *(void *)&_BYTE buf[14] = v11;
      _os_log_impl( (void *)&_mh_execute_header,  v9,  OS_LOG_TYPE_DEFAULT,  "setupAACP: Firing %lu queued AACP events for %{private}s",  buf,  0x16u);
      if (v63 < 0) {
        operator delete(__p[0]);
      }
    }

    if ((void)v56 != *(void *)&v55[8])
    {
      uint64_t v12 = (void *)(*(void *)&v55[8] + 8 * ((unint64_t)v57 >> 9));
      unsigned __int8 v13 = (_BYTE **)(*v12 + 8 * (v57 & 0x1FF));
      uint64_t v14 = *(void *)(*(void *)&v55[8] + (((*((void *)&v57 + 1) + (void)v57) >> 6) & 0x3FFFFFFFFFFFFF8LL))
          + 8 * ((*((void *)&v57 + 1) + v57) & 0x1FF);
      while (v13 != (_BYTE **)v14)
      {
        char v15 = *v13;
        if (qword_1008D9118 != -1) {
          dispatch_once(&qword_1008D9118, &stru_100888C30);
        }
        sub_10041C240((uint64_t)off_1008D9110, v15);
        if ((_BYTE **)((char *)++v13 - *v12) == (_BYTE **)4096)
        {
          uint64_t v16 = (_BYTE **)v12[1];
          ++v12;
          unsigned __int8 v13 = v16;
        }
      }
    }

    __p[0] = a2 + 128;
    sub_100240180(a1 + 56, __p);
    sub_1002400EC(v55);
    a4 = v51;
  }

  if (a4)
  {
    sub_10021C540((uint64_t)a1, (uint64_t)a2, a1[66]);
    v55[0] = 0;
    sub_100242CA4(v55);
    uint64_t v17 = sub_1002E6BF0();
    sub_100242CD0(v55);
    else {
      uint64_t v18 = 65532LL;
    }
    sub_10021C418((uint64_t)a1, (uint64_t)a2, 0xFFFFLL, v18);
    uint64_t v19 = sub_1002E6BF0();
    uint64_t v20 = (*(uint64_t (**)(uint64_t))(*(void *)v19 + 344LL))(v19);
    if ((_DWORD)v20 && sub_10021D4BC(v20, (uint64_t)a2))
    {
      sub_100215778((uint64_t)a1, (uint64_t)a2, 11LL, 500LL, 1u);
    }

    else
    {
      uint64_t v21 = sub_1002E6BF0();
      if (((*(uint64_t (**)(uint64_t))(*(void *)v21 + 328LL))(v21) & 1) != 0
        || (uint64_t v22 = sub_1002E6BF0(), (*(unsigned int (**)(uint64_t))(*(void *)v22 + 336LL))(v22)))
      {
        if (sub_1003D2B2C((uint64_t)a2, 13))
        {
          uint64_t v23 = sub_1002E6BF0();
        }
      }
    }

    uint64_t v24 = sub_1002E6BF0();
    uint64_t v25 = (*(uint64_t (**)(uint64_t))(*(void *)v24 + 720LL))(v24);
    sub_100242CD8(v55);
  }

  sub_100214B30((uint64_t)a1, (uint64_t)a2);
  int v26 = a2[960];
  int v52 = a2[976];
  if (a2[960])
  {
    uint32_t v27 = (os_log_s *)qword_1008F7560;
    if (os_log_type_enabled((os_log_t)qword_1008F7560, OS_LOG_TYPE_DEFAULT))
    {
      sub_1003CF00C((uint64_t)a2, v55);
      int v28 = (SBYTE7(v56) & 0x80u) == 0 ? v55 : *(uint8_t **)v55;
      LODWORD(__p[0]) = 136446210;
      *(void **)((char *)__p + 4) = v28;
      _os_log_impl( (void *)&_mh_execute_header,  v27,  OS_LOG_TYPE_DEFAULT,  "Guest device %{public}s ignoring easy & magic pairing",  (uint8_t *)__p,  0xCu);
      if (SBYTE7(v56) < 0) {
        operator delete(*(void **)v55);
      }
    }

    if (sub_1003D2B2C((uint64_t)a2, 27))
    {
      __int16 v29 = (os_log_s *)qword_1008F7560;
      if (os_log_type_enabled((os_log_t)qword_1008F7560, OS_LOG_TYPE_DEFAULT))
      {
        *(_WORD *)int v55 = 0;
        _os_log_impl( (void *)&_mh_execute_header,  v29,  OS_LOG_TYPE_DEFAULT,  "Wireless Splitter sending indication that BT_ACCESSORY_TEMP_PAIRING_SESSION_ON",  v55,  2u);
      }

      sub_100217CC0((uint64_t)a1, (uint64_t)a2, 3LL, 1LL);
    }
  }

  if (qword_1008D60C0 != -1) {
    dispatch_once(&qword_1008D60C0, &stru_100888BD0);
  }
  sub_1003F6234((uint64_t)off_1008D60B8, &v61, (uint64_t)v59);
  if (qword_1008D60C0 != -1) {
    dispatch_once(&qword_1008D60C0, &stru_100888BD0);
  }
  int v30 = sub_1003EE52C((uint64_t)off_1008D60B8, (uint64_t)a2);
  *(_OWORD *)std::string __p = 0uLL;
  int v31 = a4;
  if (qword_1008D5F30 != -1) {
    dispatch_once(&qword_1008D5F30, &stru_100888C70);
  }
  sub_1005D0B84((uint64_t)off_1008D5F28, a2 + 128, (unsigned __int8 *)__p);
  if (uuid_is_null((const unsigned __int8 *)__p))
  {
    if (os_log_type_enabled((os_log_t)qword_1008F7560, OS_LOG_TYPE_ERROR))
    {
      sub_1003CF00C((uint64_t)a2, v55);
      sub_10065FCCC();
    }

    BOOL v32 = 1;
  }

  else
  {
    if (qword_1008D5F30 != -1) {
      dispatch_once(&qword_1008D5F30, &stru_100888C70);
    }
    uint64_t v33 = off_1008D5F28;
    __int16 v34 = sub_100241F94((const unsigned __int8 *)__p);
    __int16 v35 = (void *)objc_claimAutoreleasedReturnValue(v34);
    double v36 = sub_1005D71D4((uint64_t)v33, v35);

    BOOL v32 = CFAbsoluteTimeGetCurrent() - v36 > 30.0;
  }

  *(void *)__int128 buf = 0LL;
  *(void *)&uint8_t buf[8] = 0LL;
  if (qword_1008D60C0 != -1) {
    dispatch_once(&qword_1008D60C0, &stru_100888BD0);
  }
  __int16 v37 = sub_1003EE4A0((uint64_t)off_1008D60B8, (uint64_t)a2);
  if (v37 && (v37[3] == *(void *)buf ? (BOOL v38 = v37[4] == *(void *)&buf[8]) : (BOOL v38 = 0), v38))
  {
    BOOL v39 = v37[1] == *(void *)buf && v37[2] == *(void *)&buf[8];
    if (v26) {
      goto LABEL_87;
    }
  }

  else
  {
    BOOL v39 = 0;
    if (v26) {
      goto LABEL_87;
    }
  }

  if ((v30 & (v32 || v39) & 1) == 0)
  {
    int v41 = a2[988] ? v30 : 1;
    if (v41 == 1)
    {
      if (qword_1008D60C0 != -1) {
        dispatch_once(&qword_1008D60C0, &stru_100888BD0);
      }
      BOOL v42 = off_1008D60B8;
      if (sub_1003ECFD0())
      {
        if (v42[240] && v61 && !a2[989]) {
          goto LABEL_96;
        }
      }
    }
  }

void sub_10021D2CC( _Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, char a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, char a19, uint64_t a20, void *__p, uint64_t a22, int a23, __int16 a24, char a25, char a26)
{
  if (a26 < 0) {
    operator delete(__p);
  }
  _Unwind_Resume(a1);
}

void *sub_10021D36C(void *a1, uint64_t a2, int a3)
{
  uint64_t v6 = operator new(0x308uLL);
  sub_100235520((uint64_t)v6, a2, a3);
  uint64_t v8 = (void *)a1[43];
  unint64_t v7 = a1[44];
  if ((unint64_t)v8 >= v7)
  {
    uint64_t v10 = a1[42];
    uint64_t v11 = ((uint64_t)v8 - v10) >> 3;
    uint64_t v12 = v7 - v10;
    uint64_t v13 = v12 >> 2;
    else {
      unint64_t v14 = v13;
    }
    if (v14) {
      char v15 = (char *)sub_100008BA0((uint64_t)(a1 + 44), v14);
    }
    else {
      char v15 = 0LL;
    }
    uint64_t v16 = &v15[8 * v11];
    uint64_t v17 = &v15[8 * v14];
    *(void *)uint64_t v16 = v6;
    uint64_t v9 = v16 + 8;
    uint64_t v19 = (char *)a1[42];
    uint64_t v18 = (char *)a1[43];
    if (v18 != v19)
    {
      do
      {
        uint64_t v20 = *((void *)v18 - 1);
        v18 -= 8;
        *((void *)v16 - 1) = v20;
        v16 -= 8;
      }

      while (v18 != v19);
      uint64_t v18 = (char *)a1[42];
    }

    a1[42] = v16;
    a1[43] = v9;
    a1[44] = v17;
    if (v18) {
      operator delete(v18);
    }
  }

  else
  {
    *uint64_t v8 = v6;
    uint64_t v9 = v8 + 1;
  }

  a1[43] = v9;
  if ((void *)((char *)v9 - a1[42]) == (void *)8)
  {
    if (qword_1008D5F50 != -1) {
      dispatch_once(&qword_1008D5F50, &stru_100888BF0);
    }
    sub_10000876C((uint64_t)off_1008D5F48 + 240, (uint64_t)(a1 + 34));
  }

  return v6;
}

void sub_10021D4A8(_Unwind_Exception *a1)
{
}

BOOL sub_10021D4BC(uint64_t a1, uint64_t a2)
{
  if (a2)
  {
    uint64_t v9 = 0LL;
    uint64_t v10 = 0LL;
    sub_1003D55EC(a2, (_DWORD *)&v10 + 1, &v10, (_DWORD *)&v9 + 1, &v9);
    int v2 = HIDWORD(v9);
    BOOL v3 = HIDWORD(v9) == 8194 || HIDWORD(v9) == 8207;
    if (v3
      || (int v6 = v9, HIDWORD(v9) == 8195) && v9 > 0x767
      || HIDWORD(v9) == 8197 && v9 > 0x76F
      || HIDWORD(v9) == 8198 && v9 > 0x768
      || HIDWORD(v9) == 8201 && v9 >= 0x240)
    {
      uint64_t v4 = (os_log_s *)qword_1008F7560;
      if (os_log_type_enabled((os_log_t)qword_1008F7560, OS_LOG_TYPE_DEFAULT))
      {
        *(_DWORD *)__int128 buf = 67109376;
        int v12 = v2;
        __int16 v13 = 1024;
        int v14 = v9;
        _os_log_impl( (void *)&_mh_execute_header,  v4,  OS_LOG_TYPE_DEFAULT,  "AACP Config Jitter Buffer is supported. pid: %x, version: %x",  buf,  0xEu);
      }

      return 1LL;
    }

    else
    {
      unint64_t v7 = (os_log_s *)qword_1008F7560;
      BOOL v8 = os_log_type_enabled((os_log_t)qword_1008F7560, OS_LOG_TYPE_DEFAULT);
      BOOL result = 0LL;
      if (v8)
      {
        *(_DWORD *)__int128 buf = 67109376;
        int v12 = v2;
        __int16 v13 = 1024;
        int v14 = v6;
        _os_log_impl( (void *)&_mh_execute_header,  v7,  OS_LOG_TYPE_DEFAULT,  "AACP Config Jitter Buffer is NOT supported. pid: %x, version: %x",  buf,  0xEu);
        return 0LL;
      }
    }
  }

  else
  {
    BOOL result = os_log_type_enabled((os_log_t)qword_1008F7560, OS_LOG_TYPE_ERROR);
    if (result)
    {
      sub_10065FD18();
      return 0LL;
    }
  }

  return result;
}

uint64_t sub_10021D698(uint64_t a1, uint64_t a2, int a3, int a4)
{
  v81[0] = 0LL;
  v81[1] = 0LL;
  sub_100242F28((uint64_t)v81, a1 + 360);
  if (a2)
  {
    for (uint64_t i = *(void ***)(a1 + 336); ; ++i)
    {
      if (i == *(void ***)(a1 + 344)) {
        goto LABEL_6;
      }
      uint64_t v9 = *i;
      if (**i == a2) {
        break;
      }
    }

    if (a4)
    {
      uint64_t v10 = sub_1003DF900(a2);
      uint64_t v11 = sub_100215778(a1, a2, 1LL, v10, 1u);
      if (sub_10021C224(v11, a2) && *((_DWORD *)v9 + 20) != 8208)
      {
        else {
          uint64_t v12 = 1LL;
        }
        sub_100215778(a1, a2, 10LL, v12, 1u);
      }

      uint64_t v13 = sub_1003E0164(a2);
      sub_100215778(a1, a2, 6LL, v13, 1u);
      if (sub_1003D2B2C(a2, 29) && (sub_1003D2B2C(a2, 43) & 1) == 0)
      {
        uint64_t v14 = sub_1003DFC14(a2);
        sub_100215778(a1, a2, 23LL, v14, 1u);
      }

      if (sub_1003D2B2C(a2, 30))
      {
        if ((sub_1003D2B2C(a2, 38) & 1) == 0)
        {
          uint64_t v15 = sub_1003DFBD0(a2);
          sub_100215778(a1, a2, 22LL, v15, 1u);
          if ((sub_1003D2B2C(a2, 43) & 1) == 0)
          {
            uint64_t v16 = sub_1003DFC58(a2);
            sub_100215778(a1, a2, 24LL, v16, 1u);
          }
        }
      }

      if (sub_1003D2B2C(a2, 28))
      {
        uint64_t v17 = sub_1003DFA7C(a2);
        sub_100215778(a1, a2, 26LL, v17, 1u);
      }

      if (sub_1003E0350(a2, 0x15u) == 1 && sub_1003E0120(a2))
      {
        uint64_t v18 = sub_1003E0120(a2);
        sub_100215778(a1, a2, 50LL, v18, 1u);
      }

      if (_os_feature_enabled_impl("AudioAccessoryFeatures", "AllowListeningModeOff")
        && sub_1003E0350(a2, 0x13u) == 1)
      {
        uint64_t v19 = sub_1003E0054(a2);
        sub_100215778(a1, a2, 52LL, v19, 1u);
      }
    }

    if (sub_1003D2B2C(a2, 16) && sub_1003D2B2C(a2, 1) && (sub_1003D2B2C(a2, 43) & 1) == 0)
    {
      if (a4)
      {
        uint64_t v21 = sub_1003DFC9C(a2);
        sub_100215778(a1, a2, 27LL, v21, 1u);
      }
    }

    else if (sub_1003D2B2C(a2, 16) && sub_1003D2B2C(a2, 15))
    {
      uint64_t v20 = sub_1003DE484(a2, 1LL);
      sub_100216C00(v20, a2);
    }

    if (sub_1003D2B2C(a2, 32) && !sub_1003DF988(a2))
    {
      if (a4)
      {
        __int16 v29 = (os_log_s *)qword_1008F7560;
        if (os_log_type_enabled((os_log_t)qword_1008F7560, OS_LOG_TYPE_DEFAULT))
        {
          sub_1003CF00C(a2, buf);
          if (v85 >= 0) {
            int v30 = buf;
          }
          else {
            int v30 = *(_BYTE **)buf;
          }
          int v31 = sub_1003D2B2C(a2, 32);
          int v32 = sub_1003DF988(a2);
          uint64_t v33 = "No";
          *(_DWORD *)std::string __p = 136446722;
          *(void *)&__p[4] = v30;
          if (v31) {
            uint64_t v33 = "Yes";
          }
          *(_WORD *)&_BYTE __p[12] = 2080;
          *(void *)&_BYTE __p[14] = v33;
          __int16 v87 = 1024;
          int v88 = v32;
          _os_log_impl( (void *)&_mh_execute_header,  v29,  OS_LOG_TYPE_DEFAULT,  "%{public}s Initialize setSmartRouteMode via connection Tipi Support = %s current SR Mode =%d",  __p,  0x1Cu);
          if (v85 < 0) {
            operator delete(*(void **)buf);
          }
        }

        sub_1003DD65C(a2, 1LL);
      }
    }

    else if (sub_1003E0230(a2, 64))
    {
      uint64_t v22 = sub_1002E6BF0();
      if ((*(unsigned int (**)(uint64_t, uint64_t))(*(void *)v22 + 792LL))(v22, 1LL))
      {
        if (!sub_1003DF9F4(a2))
        {
          uint64_t v23 = (os_log_s *)qword_1008F7560;
          if (os_log_type_enabled((os_log_t)qword_1008F7560, OS_LOG_TYPE_DEFAULT))
          {
            sub_1003CF00C(a2, __p);
            int v24 = SHIBYTE(v87);
            uint64_t v25 = *(_BYTE **)__p;
            int v26 = sub_1003E0230(a2, 64);
            uint32_t v27 = __p;
            int v28 = "No";
            if (v24 < 0) {
              uint32_t v27 = v25;
            }
            if (v26) {
              int v28 = "Yes";
            }
            *(_DWORD *)__int128 buf = 136446466;
            *(void *)&uint8_t buf[4] = v27;
            __int16 v83 = 2080;
            char v84 = v28;
            _os_log_impl( (void *)&_mh_execute_header,  v23,  OS_LOG_TYPE_DEFAULT,  "%{public}s Initialize Spatial Audio via connection Spatial support = %s",  buf,  0x16u);
            if (SHIBYTE(v87) < 0) {
              operator delete(*(void **)__p);
            }
          }

          sub_1003DDB14(a2, 1LL);
        }
      }
    }

    uint64_t v34 = sub_1002E6BF0();
    if (((*(uint64_t (**)(uint64_t))(*(void *)v34 + 328LL))(v34) & 1) != 0
      || (uint64_t v35 = sub_1002E6BF0(), ((*(uint64_t (**)(uint64_t))(*(void *)v35 + 384LL))(v35) & 1) != 0)
      || (uint64_t v36 = sub_1002E6BF0(), (*(unsigned int (**)(uint64_t))(*(void *)v36 + 424LL))(v36)))
    {
      if (sub_1003D2B2C(a2, 14))
      {
        if (qword_1008D5F50 != -1) {
          dispatch_once(&qword_1008D5F50, &stru_100888BF0);
        }
        if ((sub_100401058((uint64_t)off_1008D5F48) & 1) != 0)
        {
          unsigned int v37 = sub_1003D635C(a2);
          uint64_t v38 = sub_1003D2B2C(a2, 22);
          uint64_t v39 = sub_10021EA3C(v38, a2, v37, v38);
          if (v37 != (_DWORD)v39) {
            sub_1003D63A0(a2, v39);
          }
          sub_100215778(a1, a2, 12LL, v39, 1u);
          int v40 = *((_DWORD *)v9 + 20);
          if (v40 == 8208)
          {
            if (!sub_1003DFD24(a2))
            {
              sub_1003DE538(a2, 1);
              sub_100215778(a1, a2, 30LL, 1LL, 1u);
            }

            int v40 = *((_DWORD *)v9 + 20);
          }

          if ((v40 == 8202 || (sub_1003E0230(a2, 32) & 1) != 0 || *((_DWORD *)v9 + 20) == 8223)
            && !sub_1003DFCE0(a2))
          {
            sub_1003DE4F4(a2, 1);
            sub_100215778(a1, a2, 28LL, 1LL, 1u);
          }
        }

        else
        {
          int v41 = (os_log_s *)qword_1008F7560;
          if (os_log_type_enabled((os_log_t)qword_1008F7560, OS_LOG_TYPE_DEFAULT))
          {
            sub_1003CF00C(a2, __p);
            BOOL v42 = v87 >= 0 ? __p : *(_BYTE **)__p;
            *(_DWORD *)__int128 buf = 136446210;
            *(void *)&uint8_t buf[4] = v42;
            _os_log_impl( (void *)&_mh_execute_header,  v41,  OS_LOG_TYPE_DEFAULT,  "Device has not been unlocked (or device prefs not read yet) - disabling double tap on %{public}s",  buf,  0xCu);
            if (SHIBYTE(v87) < 0) {
              operator delete(*(void **)__p);
            }
          }

          sub_100215778(a1, a2, 12LL, 0LL, 1u);
          *(_DWORD *)std::string __p = 0;
          __int16 v43 = *(dispatch_queue_s **)(sub_100404EB8() + 8);
          handler[0] = _NSConcreteStackBlock;
          handler[1] = 3221225472LL;
          handler[2] = sub_10021E910;
          handler[3] = &unk_100888030;
          handler[4] = a1;
          void handler[5] = a2;
          uint32_t v44 = notify_register_dispatch("com.apple.mobile.keybagd.first_unlock", (int *)__p, v43, handler);
          __int16 v45 = (os_log_s *)qword_1008F7560;
          if (v44)
          {
            if (os_log_type_enabled((os_log_t)qword_1008F7560, OS_LOG_TYPE_ERROR)) {
              sub_10065FD70();
            }
          }

          else if (os_log_type_enabled((os_log_t)qword_1008F7560, OS_LOG_TYPE_DEFAULT))
          {
            *(_WORD *)__int128 buf = 0;
            _os_log_impl( (void *)&_mh_execute_header,  v45,  OS_LOG_TYPE_DEFAULT,  "Successfully registered for MKB first unlock notification",  buf,  2u);
          }
        }

        sub_100214E98(a1, a2, 32LL, 0LL, 0LL);
      }
    }

    if (a4)
    {
      if (sub_1003D2B2C(a2, 32))
      {
        uint64_t v46 = sub_1003DF988(a2);
        if ((_DWORD)v46) {
          sub_100215778(a1, a2, 32LL, v46, 1u);
        }
      }
    }

    uint64_t v47 = sub_1002E6E00();
    if ((*(unsigned int (**)(uint64_t))(*(void *)v47 + 8LL))(v47))
    {
      unsigned int v48 = *((_DWORD *)v9 + 20) - 8194;
      if (v48 > 0xE || ((1 << v48) & 0x409B) == 0)
      {
        uint64_t v72 = sub_1002E6E00();
        uint64_t v73 = (*(uint64_t (**)(uint64_t))(*(void *)v72 + 816LL))(v72);
        sub_100215778(a1, a2, 34LL, v73, 1u);
      }
    }

    uint64_t v49 = sub_1002E6E00();
    if ((*(unsigned int (**)(uint64_t))(*(void *)v49 + 8LL))(v49))
    {
      uint64_t v50 = sub_1002E6BF0();
      if ((*(unsigned int (**)(uint64_t))(*(void *)v50 + 328LL))(v50))
      {
        unsigned int v51 = *((_DWORD *)v9 + 20) - 8212;
        if (v51 <= 0x10 && ((1 << v51) & 0x116A1) != 0)
        {
          LOBYTE(v79) = 0;
          uint64_t v52 = sub_1002E6E00();
          sub_10002418C(__p, "A2DP");
          sub_10002418C(buf, "AdaptiveEQEnable");
          (*(void (**)(uint64_t, _BYTE *, _BYTE *, uint64_t *))(*(void *)v52 + 72LL))(v52, __p, buf, &v79);
          if (v85 < 0) {
            operator delete(*(void **)buf);
          }
          if (SHIBYTE(v87) < 0) {
            operator delete(*(void **)__p);
          }
          if ((_BYTE)v79) {
            float v53 = 1.0;
          }
          else {
            float v53 = 0.0;
          }
          __int16 v54 = (float *)malloc(0x10uLL);
          *(void *)__int16 v54 = 514LL;
          void v54[2] = 9.445e21;
          v54[3] = v53;
          sub_100214E98(a1, a2, 1LL, 16LL, (uint64_t)v54);
          free(v54);
        }
      }
    }

    uint64_t v55 = sub_1002E6E00();
    if ((*(unsigned int (**)(uint64_t))(*(void *)v55 + 8LL))(v55))
    {
      uint64_t v56 = sub_1002E6BF0();
      if ((*(unsigned int (**)(uint64_t))(*(void *)v56 + 328LL))(v56))
      {
        unsigned int v57 = *((_DWORD *)v9 + 20) - 8217;
        if (v57 <= 7 && ((1 << v57) & 0xA5) != 0)
        {
          LOBYTE(v79) = 0;
          uint64_t v58 = sub_1002E6E00();
          sub_10002418C(__p, "AutomaticIEDKey");
          sub_10002418C(buf, "DefaultAutoIEDOff");
          (*(void (**)(uint64_t, _BYTE *, _BYTE *, uint64_t *))(*(void *)v58 + 72LL))(v58, __p, buf, &v79);
          if (v85 < 0) {
            operator delete(*(void **)buf);
          }
          if (SHIBYTE(v87) < 0) {
            operator delete(*(void **)__p);
          }
          __int16 v59 = (os_log_s *)qword_1008F7560;
          if (os_log_type_enabled((os_log_t)qword_1008F7560, OS_LOG_TYPE_DEFAULT))
          {
            *(_DWORD *)std::string __p = 67109120;
            *(_DWORD *)&__p[4] = v79;
            _os_log_impl( (void *)&_mh_execute_header,  v59,  OS_LOG_TYPE_DEFAULT,  "internalSetupAACP: Defaults write value to set Automatic Ear Detection off upon every connection = %d",  __p,  8u);
          }

          if ((_BYTE)v79) {
            sub_1003DDCA8(a2, 0, 1);
          }
        }
      }
    }

    unsigned int v60 = *((_DWORD *)v9 + 20) - 8212;
    if (v60 <= 0x10 && ((1 << v60) & 0x116A1) != 0)
    {
      if (a3)
      {
        LOBYTE(v79) = 0;
        memset((char *)&v79 + 1, 255, 7);
        uint64_t v61 = sub_1002E90E4();
        (*(void (**)(uint64_t, void, uint64_t *, void))(*(void *)v61 + 16LL))( v61,  *(void *)(a1 + 440),  &v79,  *((unsigned int *)v9 + 20));
        int v62 = sub_100214450(a1, a2, (uint64_t)&v79);
        if (v62)
        {
          char v63 = (os_log_s *)qword_1008F7560;
          if (os_log_type_enabled((os_log_t)qword_1008F7560, OS_LOG_TYPE_ERROR))
          {
            uint64_t v74 = *(void *)(a1 + 440);
            sub_1003CF00C(a2, buf);
            unsigned int v75 = v85 >= 0 ? buf : *(_BYTE **)buf;
            *(_DWORD *)std::string __p = 138412802;
            *(void *)&__p[4] = v74;
            *(_WORD *)&_BYTE __p[12] = 2082;
            *(void *)&_BYTE __p[14] = v75;
            __int16 v87 = 1024;
            int v88 = v62;
            _os_log_error_impl( (void *)&_mh_execute_header,  v63,  OS_LOG_TYPE_ERROR,  "Failed to set country codes for country %@ for device %{public}s with result %u",  __p,  0x1Cu);
            if (v85 < 0) {
              operator delete(*(void **)buf);
            }
          }
        }
      }
    }

    if (qword_1008D60C0 != -1) {
      dispatch_once(&qword_1008D60C0, &stru_100888BD0);
    }
    __int16 v64 = off_1008D60B8;
    if (!sub_1003ECFD0()
      || !v64[240]
      || *(_BYTE *)(a2 + 988)
      || *(_BYTE *)(a2 + 989)
      || (sub_1003D8484(a2) & 2) != 0)
    {
      goto LABEL_137;
    }

    if (qword_1008D60C0 != -1) {
      dispatch_once(&qword_1008D60C0, &stru_100888BD0);
    }
    if ((sub_1003EE52C((uint64_t)off_1008D60B8, a2) & 1) != 0)
    {
LABEL_137:
      if (qword_1008D60C0 != -1) {
        dispatch_once(&qword_1008D60C0, &stru_100888BD0);
      }
      if (qword_1008D60C0 != -1) {
        dispatch_once(&qword_1008D60C0, &stru_100888BD0);
      }
      *(void *)std::string __p = 0LL;
      *(void *)&__p[8] = 0LL;
      buf[0] = 0;
      *(_DWORD *)&buf[1] = *(_DWORD *)(a2 + 128);
      *(_WORD *)&buf[5] = *(_WORD *)(a2 + 132);
      if (qword_1008D5F20 != -1) {
        dispatch_once(&qword_1008D5F20, &stru_100888CB0);
      }
      if ((sub_10062D738(qword_1008D5F18, buf, __p) & 1) != 0) {
        goto LABEL_148;
      }
      if (qword_1008D5F50 == -1)
      {
LABEL_147:
        sub_100401ADC((uint64_t)off_1008D5F48, a2);
LABEL_148:
        if (qword_1008D60C0 != -1) {
          dispatch_once(&qword_1008D60C0, &stru_100888BD0);
        }
        uint64_t v65 = sub_1003EE4A0((uint64_t)off_1008D60B8, a2);
        uint64_t v66 = (uint64_t)v65;
        if (v65 && *((_BYTE *)v65 + 112) == 2)
        {
          int v67 = (os_log_s *)qword_1008F7600;
          if (os_log_type_enabled((os_log_t)qword_1008F7600, OS_LOG_TYPE_DEFAULT))
          {
            sub_1003D0100(a2, (uint64_t)__p);
            __int128 v68 = v87 >= 0 ? __p : *(const char **)__p;
            *(_DWORD *)__int128 buf = 141558275;
            *(void *)&uint8_t buf[4] = 1752392040LL;
            __int16 v83 = 2081;
            char v84 = v68;
            _os_log_impl( (void *)&_mh_execute_header,  v67,  OS_LOG_TYPE_DEFAULT,  "Sending magic keys 'again' to device %{private, mask.hash}s",  buf,  0x16u);
            if (SHIBYTE(v87) < 0) {
              operator delete(*(void **)__p);
            }
          }

          if (qword_1008D60C0 != -1) {
            dispatch_once(&qword_1008D60C0, &stru_100888BD0);
          }
          sub_1003EFF78((uint64_t)off_1008D60B8, v66);
          sub_10021EC58(v69, (unsigned __int8 *)a2);
        }

        if (qword_1008D60C0 != -1) {
          dispatch_once(&qword_1008D60C0, &stru_100888BD0);
        }
        sub_1003FAF10((uint64_t)off_1008D60B8, a2);
        if (sub_10021AF3C(a1, a2))
        {
          sub_10021AFA4(a1, v9);
        }

        else
        {
          __int128 v70 = (os_log_s *)qword_1008F7560;
          if (os_log_type_enabled((os_log_t)qword_1008F7560, OS_LOG_TYPE_DEFAULT))
          {
            *(_WORD *)std::string __p = 0;
            _os_log_impl( (void *)&_mh_execute_header,  v70,  OS_LOG_TYPE_DEFAULT,  "internalSetupAACP: Conditions not met for easy pairing",  __p,  2u);
          }
        }

        if (*(_BYTE *)(a1 + 520)) {
          *(_BYTE *)(a1 + 520) = 0;
        }
        return sub_100242FAC((uint64_t)v81);
      }
    }

    else
    {
      uint64_t v76 = (os_log_s *)qword_1008F7600;
      BOOL v77 = os_log_type_enabled((os_log_t)qword_1008F7600, OS_LOG_TYPE_DEFAULT);
      if (v77)
      {
        sub_1003D0100(a2, (uint64_t)__p);
        int v78 = v87 >= 0 ? __p : *(const char **)__p;
        *(_DWORD *)__int128 buf = 141558275;
        *(void *)&uint8_t buf[4] = 1752392040LL;
        __int16 v83 = 2081;
        char v84 = v78;
        _os_log_impl( (void *)&_mh_execute_header,  v76,  OS_LOG_TYPE_DEFAULT,  "Sending magic keys and renaming device %{private, mask.hash}s",  buf,  0x16u);
        if (SHIBYTE(v87) < 0) {
          operator delete(*(void **)__p);
        }
      }

      sub_10021EC58(v77, (unsigned __int8 *)a2);
      if (qword_1008D5F50 == -1) {
        goto LABEL_147;
      }
    }

    dispatch_once(&qword_1008D5F50, &stru_100888BF0);
    goto LABEL_147;
  }

void sub_10021E6CC( _Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, char a17, uint64_t a18, void *a19, uint64_t a20, int a21, __int16 a22, char a23, char a24, uint64_t a25, void *__p, uint64_t a27, int a28, __int16 a29, char a30, char a31)
{
}

uint64_t sub_10021E798(uint64_t a1, uint64_t a2)
{
  BOOL v3 = (os_log_s *)qword_1008F7560;
  if (os_log_type_enabled((os_log_t)qword_1008F7560, OS_LOG_TYPE_DEFAULT))
  {
    sub_1003D0100(a2, (uint64_t)__p);
    uint64_t v4 = v11 >= 0 ? __p : (void **)__p[0];
    *(_DWORD *)__int128 buf = 136315138;
    uint64_t v13 = v4;
    _os_log_impl( (void *)&_mh_execute_header,  v3,  OS_LOG_TYPE_DEFAULT,  "Notify in ear status change for device %s",  buf,  0xCu);
    if (v11 < 0) {
      operator delete(__p[0]);
    }
  }

  uint64_t v5 = sub_100405058();
  v9[0] = _NSConcreteStackBlock;
  v9[1] = 3221225472LL;
  void v9[2] = sub_10023504C;
  void v9[3] = &unk_10087EB20;
  void v9[4] = a2;
  sub_100405384(v5, v9);
  uint64_t v6 = sub_1004050C8();
  v8[0] = _NSConcreteStackBlock;
  v8[1] = 3221225472LL;
  void v8[2] = sub_1002350B0;
  v8[3] = &unk_10087EB20;
  void v8[4] = a2;
  sub_100405384(v6, v8);
  if (qword_1008D5F40 != -1) {
    dispatch_once(&qword_1008D5F40, &stru_100888BB0);
  }
  return sub_1003B252C((uint64_t)off_1008D5F38, a2);
}

void sub_10021E910(uint64_t a1)
{
  uint64_t v2 = *(void *)(a1 + 32);
  BOOL v3 = (os_log_s *)qword_1008F7560;
  if (os_log_type_enabled((os_log_t)qword_1008F7560, OS_LOG_TYPE_DEFAULT))
  {
    *(_DWORD *)__int128 buf = 67109120;
    int v8 = MKBDeviceUnlockedSinceBoot();
    _os_log_impl( (void *)&_mh_execute_header,  v3,  OS_LOG_TYPE_DEFAULT,  "Received MKB first unlock notification. MKBDeviceUnlockedSinceBoot returns : %d",  buf,  8u);
  }

  if (MKBDeviceUnlockedSinceBoot() != 1
    && os_log_type_enabled((os_log_t)qword_1008F7560, OS_LOG_TYPE_FAULT))
  {
    sub_10065FDD0();
  }

  uint64_t v4 = sub_100404EB8();
  v6[0] = _NSConcreteStackBlock;
  v6[1] = 3221225472LL;
  void v6[2] = sub_10021EA30;
  void v6[3] = &unk_10087F8E0;
  uint64_t v5 = *(void *)(a1 + 40);
  char v6[4] = v2;
  void v6[5] = v5;
  sub_100405460(v4, 2000LL, v6);
}

uint64_t sub_10021EA30(uint64_t a1)
{
  return sub_10021C354(*(void *)(a1 + 32), *(void *)(a1 + 40));
}

uint64_t sub_10021EA3C(uint64_t a1, uint64_t a2, unsigned int a3, int a4)
{
  if (a4) {
    LOBYTE(v6) = 3;
  }
  else {
    LOBYTE(v6) = 1;
  }
  if (a3 == 0xFFFF)
  {
    int v8 = (os_log_s *)qword_1008F7560;
    if (os_log_type_enabled((os_log_t)qword_1008F7560, OS_LOG_TYPE_DEFAULT))
    {
      sub_1003CF00C(a2, &__p);
      uint64_t v9 = v21 >= 0 ? &__p : (void **)__p;
      *(_DWORD *)__int128 buf = 136446210;
      uint64_t v23 = v9;
      _os_log_impl( (void *)&_mh_execute_header,  v8,  OS_LOG_TYPE_DEFAULT,  "Setting double tap for %{public}s for first time",  buf,  0xCu);
      if (v21 < 0) {
        operator delete(__p);
      }
    }

    int v10 = 255;
  }

  else
  {
    int v10 = a3;
    unsigned __int8 v11 = a3;
  }

  uint64_t v12 = (os_log_s *)qword_1008F7560;
  unsigned __int8 v11 = v6;
  if (os_log_type_enabled((os_log_t)qword_1008F7560, OS_LOG_TYPE_DEFAULT))
  {
    uint64_t v13 = "Siri";
    if (a4) {
      uint64_t v13 = "Next Track";
    }
    LODWORD(__p) = 67109378;
    HIDWORD(__p) = v10;
    __int16 v19 = 2082;
    uint64_t v20 = v13;
    _os_log_impl( (void *)&_mh_execute_header,  v12,  OS_LOG_TYPE_DEFAULT,  "Right double tap was %d, now %{public}s",  (uint8_t *)&__p,  0x12u);
    unsigned __int8 v11 = v6;
  }

uint64_t sub_10021EC58(uint64_t a1, unsigned __int8 *a2)
{
  v31[0] = (void *)1048592;
  v32[0] = (void *)1052672;
  v30[0] = (void *)1048584;
  BOOL v3 = malloc(0x10uLL);
  v30[1] = v3;
  uint64_t v4 = malloc(0x10uLL);
  v31[1] = v4;
  uint64_t v5 = malloc(0x10uLL);
  v32[1] = v5;
  uint64_t v33 = 401408LL;
  unsigned int v6 = malloc(6uLL);
  uint64_t v34 = v6;
  if (qword_1008D60C0 != -1) {
    dispatch_once(&qword_1008D60C0, &stru_100888BD0);
  }
  unint64_t v7 = (void *)&unk_1008D6000;
  if (sub_1003F0FC8((uint64_t)off_1008D60B8, a2, v3, v4))
  {
    uint64_t v8 = 0LL;
    goto LABEL_32;
  }

  uint64_t v9 = (os_log_s *)qword_1008F7600;
  if (os_log_type_enabled((os_log_t)qword_1008F7600, OS_LOG_TYPE_DEFAULT))
  {
    sub_1003CF00C((uint64_t)a2, __p);
    int v10 = v25;
    unsigned __int8 v11 = (void **)__p[0];
    int v12 = sub_1003CF350(a2);
    uint64_t v13 = __p;
    if (v10 < 0) {
      uint64_t v13 = v11;
    }
    *(_DWORD *)__int128 buf = 136446466;
    uint32_t v27 = v13;
    __int16 v28 = 1024;
    int v29 = v12;
    _os_log_impl( (void *)&_mh_execute_header,  v9,  OS_LOG_TYPE_DEFAULT,  "Updating magic keys to device %{public}s, paired %d",  buf,  0x12u);
    if (v25 < 0) {
      operator delete(__p[0]);
    }
    unint64_t v7 = &unk_1008D6000;
  }

  if (sub_1003CF350(a2) && sub_1003D2B2C((uint64_t)a2, 19))
  {
    if (qword_1008D60C0 != -1) {
      dispatch_once(&qword_1008D60C0, &stru_100888BD0);
    }
    uint64_t v8 = sub_1003F13C8((uint64_t)off_1008D60B8, v5, (uint64_t)v6);
  }

  else
  {
    uint64_t v8 = 1LL;
  }

  int v14 = (os_log_s *)qword_1008F7600;
  if (os_log_type_enabled((os_log_t)qword_1008F7600, OS_LOG_TYPE_DEFAULT))
  {
    sub_1003CF00C((uint64_t)a2, __p);
    int v15 = v25;
    uint64_t v16 = (void **)__p[0];
    int v17 = sub_1003CF350(a2);
    uint64_t v18 = __p;
    if (v15 < 0) {
      uint64_t v18 = v16;
    }
    *(_DWORD *)__int128 buf = 136446466;
    uint32_t v27 = v18;
    __int16 v28 = 1024;
    int v29 = v17;
    _os_log_impl( (void *)&_mh_execute_header,  v14,  OS_LOG_TYPE_DEFAULT,  "Get magic key from cloud for device %{public}s is %d",  buf,  0x12u);
    if (v25 < 0)
    {
      operator delete(__p[0]);
      if ((_DWORD)v8) {
        goto LABEL_22;
      }
LABEL_26:
      uint64_t v20 = 0LL;
      uint64_t v21 = 0xF00000000LL;
      do
      {
        char v22 = *((_BYTE *)v5 + v20);
        *((_BYTE *)v5 + v20) = *((_BYTE *)v5 + (v21 >> 32));
        *((_BYTE *)v5 + (v21 >> 32)) = v22;
        ++v20;
        v21 -= 0x100000000LL;
      }

      while (v20 != 8);
      if (qword_1008D60E0 != -1) {
        dispatch_once(&qword_1008D60E0, &stru_100888C10);
      }
      uint64_t v8 = 0LL;
      uint64_t v19 = 4LL;
      goto LABEL_31;
    }
  }

  if (!(_DWORD)v8) {
    goto LABEL_26;
  }
LABEL_22:
  if (qword_1008D60E0 != -1) {
    dispatch_once(&qword_1008D60E0, &stru_100888C10);
  }
  uint64_t v19 = 2LL;
LABEL_31:
  sub_100217DE8(v7[27], (uint64_t)a2, v19, (uint64_t)v30);
LABEL_32:
  free(v30[1]);
  free(v31[1]);
  free(v32[1]);
  free(v34);
  if (qword_1008D60E0 != -1) {
    dispatch_once(&qword_1008D60E0, &stru_100888C10);
  }
  sub_100217F10(v7[27], (uint64_t)a2, 5LL);
  return v8;
}

void sub_10021F014( _Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void *__p, uint64_t a11, int a12, __int16 a13, char a14, char a15)
{
  if (a15 < 0) {
    operator delete(__p);
  }
  _Unwind_Resume(exception_object);
}

uint64_t sub_10021F03C(uint64_t a1, uint64_t a2)
{
  if (!a2) {
    return 0LL;
  }
  uint64_t v3 = sub_1003DF944(a2);
  uint64_t v4 = (os_log_s *)qword_1008F7560;
  if (os_log_type_enabled((os_log_t)qword_1008F7560, OS_LOG_TYPE_INFO))
  {
    sub_1003CF00C(a2, __p);
    if (v9 >= 0) {
      uint64_t v5 = __p;
    }
    else {
      uint64_t v5 = (void **)__p[0];
    }
    unsigned int v6 = "Disabled";
    unsigned __int8 v11 = "In Ear detection";
    *(_DWORD *)__int128 buf = 136446722;
    if ((_DWORD)v3) {
      unsigned int v6 = "Enabled";
    }
    __int16 v12 = 2082;
    uint64_t v13 = v5;
    __int16 v14 = 2082;
    int v15 = v6;
    _os_log_impl( (void *)&_mh_execute_header,  v4,  OS_LOG_TYPE_INFO,  "%{public}s for %{public}s is %{public}s",  buf,  0x20u);
    if (v9 < 0) {
      operator delete(__p[0]);
    }
  }

  return v3;
}

uint64_t sub_10021F164(uint64_t a1, uint64_t a2, int *a3, int *a4)
{
  v28[0] = 0LL;
  v28[1] = 0LL;
  uint64_t v8 = sub_100242F28((uint64_t)v28, a1 + 360);
  if (a2)
  {
    char v9 = *(void **)(a1 + 336);
    int v10 = *(void **)(a1 + 344);
    while (v9 != v10)
    {
      unsigned __int8 v11 = (void *)*v9;
      if (*(void *)*v9 == a2)
      {
        uint64_t v14 = sub_10021F3A8(v8, *((unsigned __int8 *)v11 + 8));
        *a3 = v14;
        *a4 = sub_10021F3A8(v14, *((unsigned __int8 *)v11 + 9));
        int v15 = (os_log_s *)qword_1008F7560;
        if (os_log_type_enabled((os_log_t)qword_1008F7560, OS_LOG_TYPE_INFO))
        {
          sub_1003CF00C(a2, __p);
          int v16 = v30;
          int v17 = (void **)__p[0];
          int v18 = *a3;
          int v19 = *a4;
          uint64_t v20 = sub_1003DF944(a2);
          int v21 = v20;
          char v22 = sub_10021F3CC(v20, v19);
          uint64_t v23 = sub_10021F3CC((uint64_t)v22, v18);
          int v24 = __p;
          if (v16 < 0) {
            int v24 = v17;
          }
          *(_DWORD *)__int128 buf = 136446978;
          int v32 = v24;
          char v25 = "yes";
          __int16 v33 = 2082;
          uint64_t v34 = v23;
          if (!v21) {
            char v25 = "no";
          }
          __int16 v35 = 2082;
          uint64_t v36 = v22;
          __int16 v37 = 2080;
          uint64_t v38 = v25;
          _os_log_impl( (void *)&_mh_execute_header,  v15,  OS_LOG_TYPE_INFO,  "getInEarStatus: %{public}s primary %{public}s, secondary %{public}s, IED enabled: %s",  buf,  0x2Au);
          if (v30 < 0) {
            operator delete(__p[0]);
          }
        }

        uint64_t v26 = 0LL;
        goto LABEL_19;
      }

      ++v9;
    }
  }

  *a3 = 3;
  *a4 = 3;
  __int16 v12 = (os_log_s *)qword_1008F7560;
  if (os_log_type_enabled((os_log_t)qword_1008F7560, OS_LOG_TYPE_ERROR))
  {
    if (a2)
    {
      sub_1003CF00C(a2, buf);
      sub_10065FE48();
    }

    else
    {
      sub_10065FE08((uint64_t)__p, v12, v13);
    }
  }

  uint64_t v26 = 312LL;
LABEL_19:
  sub_100242FAC((uint64_t)v28);
  return v26;
}

void sub_10021F370( _Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, void *__p, uint64_t a12, int a13, __int16 a14, char a15, char a16)
{
  if (a16 < 0) {
    operator delete(__p);
  }
  sub_100242FAC((uint64_t)&a9);
  _Unwind_Resume(a1);
}

uint64_t sub_10021F3A8(uint64_t a1, unsigned int a2)
{
  if (a2 > 0xC) {
    return 3LL;
  }
  else {
    return dword_1006BF5C8[(char)a2];
  }
}

const char *sub_10021F3CC(uint64_t a1, unsigned int a2)
{
  if (a2 > 0xC) {
    return "unknown";
  }
  else {
    return off_100888FC8[(char)a2];
  }
}

uint64_t sub_10021F3F4(uint64_t a1, uint64_t a2, int *a3)
{
  v19[0] = 0LL;
  v19[1] = 0LL;
  sub_100242F28((uint64_t)v19, a1 + 360);
  if (a2)
  {
    for (uint64_t i = *(void *)(a1 + 336); i != *(void *)(a1 + 344); i += 8LL)
    {
      if (**(void **)i == a2)
      {
        int v9 = *(unsigned __int8 *)(*(void *)i + 10LL);
        if (v9 == 2) {
          int v10 = 2;
        }
        else {
          int v10 = 3;
        }
        if (v9 == 1) {
          int v11 = 1;
        }
        else {
          int v11 = v10;
        }
        *a3 = v11;
        __int16 v12 = (os_log_s *)qword_1008F7560;
        if (os_log_type_enabled((os_log_t)qword_1008F7560, OS_LOG_TYPE_INFO))
        {
          sub_1003D0100(a2, (uint64_t)__p);
          if (v18 >= 0) {
            uint64_t v13 = __p;
          }
          else {
            uint64_t v13 = (void **)__p[0];
          }
          int v14 = *(unsigned __int8 *)a3;
          int v15 = "unknown";
          if (v14 == 2) {
            int v15 = "right";
          }
          if (v14 == 1) {
            int v16 = "left";
          }
          else {
            int v16 = v15;
          }
          *(_DWORD *)__int128 buf = 136315394;
          int v21 = v13;
          __int16 v22 = 2082;
          uint64_t v23 = v16;
          _os_log_impl( (void *)&_mh_execute_header,  v12,  OS_LOG_TYPE_INFO,  "getPrimaryBudSide: primary bud side of %s is %{public}s",  buf,  0x16u);
          if (v18 < 0) {
            operator delete(__p[0]);
          }
        }

        uint64_t v7 = 0LL;
        goto LABEL_11;
      }
    }

    *a3 = 3;
    if (os_log_type_enabled((os_log_t)qword_1008F7560, OS_LOG_TYPE_ERROR))
    {
      sub_1003CF00C(a2, __p);
      sub_10065FEC0();
    }
  }

  else
  {
    *a3 = 3;
    if (os_log_type_enabled((os_log_t)qword_1008F7560, OS_LOG_TYPE_ERROR)) {
      sub_10065FE94();
    }
  }

  uint64_t v7 = 312LL;
LABEL_11:
  sub_100242FAC((uint64_t)v19);
  return v7;
}

void sub_10021F5E8(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, ...)
{
}

const char *sub_10021F608(uint64_t a1, int a2)
{
  uint64_t v2 = "unknown";
  if (a2 == 2) {
    uint64_t v2 = "right";
  }
  if (a2 == 1) {
    return "left";
  }
  else {
    return v2;
  }
}

void sub_10021F634(uint64_t a1, void *a2)
{
  id v3 = a2;
  if (qword_1008D5F30 != -1) {
    dispatch_once(&qword_1008D5F30, &stru_100888C70);
  }
  uint64_t v4 = sub_1005CC198((uint64_t)off_1008D5F28, v3, 0);
  *(_BYTE *)(a1 + 424) = BYTE5(v4);
  *(_BYTE *)(a1 + 425) = BYTE4(v4);
  *(_BYTE *)(a1 + 426) = BYTE3(v4);
  *(_BYTE *)(a1 + 42memset((char *)&v11[1] + 1, 0, 7) = BYTE2(v4);
  *(_BYTE *)(a1 + 42std::ostream::~ostream(v2, v3 + 8) = BYTE1(v4);
  *(_BYTE *)(a1 + 429) = v4;
  char v24 = 0;
  sub_100242CA4(&v24);
  uint64_t v5 = (unsigned __int8 *)(a1 + 432);
  int v6 = sub_10008F9A0( ((unint64_t)*(unsigned __int8 *)(a1 + 424) << 40) | ((unint64_t)*(unsigned __int8 *)(a1 + 425) << 32) | ((unint64_t)*(unsigned __int8 *)(a1 + 426) << 24) | ((unint64_t)*(unsigned __int8 *)(a1 + 427) << 16) | ((unint64_t)*(unsigned __int8 *)(a1 + 428) << 8) | *(unsigned __int8 *)(a1 + 429),  (_BYTE *)(a1 + 432));
  sub_100242CD0(&v24);
  uint64_t v7 = (os_log_s *)qword_1008F7560;
  if (v6 && os_log_type_enabled((os_log_t)qword_1008F7560, OS_LOG_TYPE_ERROR))
  {
    *(_DWORD *)std::string __p = 67109120;
    *(_DWORD *)&__p[4] = v6;
    _os_log_error_impl( (void *)&_mh_execute_header,  v7,  OS_LOG_TYPE_ERROR,  "CL get version failed with status %d",  __p,  8u);
    uint64_t v7 = (os_log_s *)qword_1008F7560;
  }

  uint64_t v8 = a1 + 424;
  if (os_log_type_enabled(v7, OS_LOG_TYPE_DEFAULT))
  {
    sub_1003FE1B4((unsigned __int8 *)(a1 + 424), __p);
    int v9 = v33 >= 0 ? __p : *(_BYTE **)__p;
    int v10 = *v5;
    *(_DWORD *)__int128 buf = 136315394;
    *(void *)&uint8_t buf[4] = v9;
    __int16 v26 = 1024;
    int v27 = v10;
    _os_log_impl( (void *)&_mh_execute_header,  v7,  OS_LOG_TYPE_DEFAULT,  "Magnet link connected with device %s with version %d",  buf,  0x12u);
    if (SHIBYTE(v33) < 0) {
      operator delete(*(void **)__p);
    }
  }

  uint64_t v23 = 0LL;
  if (qword_1008D5F10 != -1) {
    dispatch_once(&qword_1008D5F10, &stru_100888CD0);
  }
  int v11 = off_1008D5F08;
  sub_100241F90(__p, v3);
  BOOL v12 = sub_100599890((uint64_t)v11, __p, &v23);
  if (v23) {
    BOOL v13 = v12;
  }
  else {
    BOOL v13 = 0;
  }
  if (!v13) {
    goto LABEL_25;
  }
  sub_100242C98(&v24);
  int v14 = (os_log_s *)qword_1008F7560;
  if (os_log_type_enabled((os_log_t)qword_1008F7560, OS_LOG_TYPE_DEFAULT))
  {
    sub_1003FE1B4((unsigned __int8 *)(a1 + 424), buf);
    int v15 = v28 >= 0 ? buf : *(_BYTE **)buf;
    int v16 = *v5;
    int v17 = sub_10009153C(v23);
    int v18 = sub_100091468(v23);
    *(_DWORD *)std::string __p = 136315906;
    *(void *)&__p[4] = v15;
    __int16 v30 = 1024;
    int v31 = v16;
    __int16 v32 = 1024;
    int v33 = v17;
    __int16 v34 = 1024;
    int v35 = v18;
    _os_log_impl( (void *)&_mh_execute_header,  v14,  OS_LOG_TYPE_DEFAULT,  "device %s with version %d  (peerIsPhone=%d peerIsWatch=%d)",  __p,  0x1Eu);
    if (v28 < 0) {
      operator delete(*(void **)buf);
    }
  }

  char v19 = sub_100091610(v23);
  sub_100242CD0(&v24);
  if ((v19 & 1) == 0)
  {
    __int16 v22 = (os_log_s *)qword_1008F7560;
    if (os_log_type_enabled((os_log_t)qword_1008F7560, OS_LOG_TYPE_DEFAULT))
    {
      *(_WORD *)std::string __p = 0;
      _os_log_impl( (void *)&_mh_execute_header,  v22,  OS_LOG_TYPE_DEFAULT,  "Magnet link up between two devices that do not support EasyPairing",  __p,  2u);
    }

    *(_WORD *)(v8 + 4) = 0;
    *(_DWORD *)uint64_t v8 = 0;
  }

  else
  {
LABEL_25:
    *(_BYTE *)(a1 + 430) = 1;
    sub_10021FA64(a1);
    int v20 = *(_DWORD *)(a1 + 516);
    if (v20 == -1)
    {
      int v21 = (int *)(a1 + 516);
      notify_register_check("com.apple.bluetooth.magnet", v21);
      int v20 = *v21;
    }

    notify_set_state(v20, 1uLL);
    notify_post("com.apple.bluetooth.magnet");
  }

  sub_100242CD8(&v24);
}

void sub_10021FA10( _Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, int a10, __int16 a11, char a12, char a13, void *__p, uint64_t a15, int a16, __int16 a17, char a18, char a19)
{
  _Unwind_Resume(a1);
}

uint64_t sub_10021FA64(uint64_t a1)
{
  v5[0] = 0LL;
  v5[1] = 0LL;
  sub_100242F28((uint64_t)v5, a1 + 360);
  id v3 = *(uint64_t ***)(a1 + 336);
  uint64_t v2 = *(uint64_t ***)(a1 + 344);
  while (v3 != v2)
  {
    if (*v3)
    {
      sub_10021AFA4(a1, *v3);
      uint64_t v2 = *(uint64_t ***)(a1 + 344);
    }

    ++v3;
  }

  return sub_100242FAC((uint64_t)v5);
}

void sub_10021FAC8( _Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9)
{
}

void sub_10021FADC(uint64_t a1, void *a2)
{
  id v3 = a2;
  if (qword_1008D5F30 != -1) {
    dispatch_once(&qword_1008D5F30, &stru_100888C70);
  }
  uint64_t v4 = sub_1005CC198((uint64_t)off_1008D5F28, v3, 0);
  LOBYTE(v1memset((char *)&v11[1] + 1, 0, 7) = BYTE5(v4);
  BYTE1(v1memset((char *)&v11[1] + 1, 0, 7) = BYTE4(v4);
  BYTE2(v1memset((char *)&v11[1] + 1, 0, 7) = BYTE3(v4);
  HIBYTE(v1memset((char *)&v11[1] + 1, 0, 7) = BYTE2(v4);
  LOBYTE(v1std::ostream::~ostream(v2, v3 + 8) = BYTE1(v4);
  HIBYTE(v1std::ostream::~ostream(v2, v3 + 8) = v4;
  uint64_t v5 = (os_log_s *)qword_1008F7560;
  if (os_log_type_enabled((os_log_t)qword_1008F7560, OS_LOG_TYPE_DEFAULT))
  {
    id v6 = sub_1005BFB9C(v4);
    uint64_t v7 = (void *)objc_claimAutoreleasedReturnValue(v6);
    *(_DWORD *)__int128 buf = 138412290;
    *(void *)&uint8_t buf[4] = v7;
    _os_log_impl( (void *)&_mh_execute_header,  v5,  OS_LOG_TYPE_DEFAULT,  "magnet link disconnected with device %@",  buf,  0xCu);
  }

  if (v17 == *(_DWORD *)(a1 + 424) && v18 == *(_WORD *)(a1 + 428))
  {
    *(_BYTE *)(a1 + 4sub_100242FAC(v1 - 32) = 0;
    *(_DWORD *)(a1 + 424) = 0;
    *(_DWORD *)(a1 + 42memset((char *)&v11[1] + 1, 0, 7) = 0;
    *(_OWORD *)__int128 buf = 0uLL;
    sub_100242F28((uint64_t)buf, a1 + 360);
    for (uint64_t i = *(uint64_t **)(a1 + 336); i != *(uint64_t **)(a1 + 344); ++i)
    {
      BOOL v13 = (void *)*i;
      uint64_t v14 = *(void *)*i;
      sub_10021FDA4(*i);
      if (v14 && !sub_10021B43C((uint64_t)v13))
      {
        v20[0] = 0;
        sub_100242CA4(v20);
        sub_10007F8B8((unsigned __int8 *)(v14 + 128), (uint64_t)&v17, 2);
        sub_100242CD0(v20);
        *((_BYTE *)v13 + 72std::ostream::~ostream(v2, v3 + 8) = 0;
        sub_100242CD8(v20);
      }
    }

    sub_100242FAC((uint64_t)buf);
  }

  else
  {
    int v9 = (os_log_s *)qword_1008F7560;
    if (os_log_type_enabled((os_log_t)qword_1008F7560, OS_LOG_TYPE_ERROR))
    {
      id v10 = sub_1005BFB9C(v4);
      id v11 = v10;
      sub_1003FE1B4((unsigned __int8 *)(a1 + 424), buf);
      sub_10065FF0C(v11, (char *)buf, (uint64_t)v20, v9);
    }
  }

  int v15 = *(_DWORD *)(a1 + 516);
  if (v15 == -1)
  {
    int v16 = (int *)(a1 + 516);
    notify_register_check("com.apple.bluetooth.magnet", v16);
    int v15 = *v16;
  }

  notify_set_state(v15, 0LL);
  notify_post("com.apple.bluetooth.magnet");
}

void sub_10021FD48(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_10021FDA4(uint64_t a1)
{
  uint64_t v2 = *(void *)(a1 + 48);
  if (v2)
  {
    id v3 = (void *)sub_100209548(v2);
    operator delete(v3);
  }

  *(void *)(a1 + 4std::ostream::~ostream(v2, v3 + 8) = 0LL;
}

uint64_t sub_10021FDD4(uint64_t a1, uint64_t a2, int a3)
{
  uint64_t result = sub_10021AF3C(a1, a2);
  if ((_DWORD)result)
  {
    v11[0] = 0LL;
    v11[1] = 0LL;
    sub_100242F28((uint64_t)v11, a1 + 360);
    if (a2)
    {
      for (uint64_t i = *(void *)(a1 + 336); i != *(void *)(a1 + 344); i += 8LL)
      {
        if (**(void **)i == a2)
        {
          uint64_t v8 = *(void *)(*(void *)i + 48LL);
          if (v8)
          {
            int v9 = *(_DWORD *)(a2 + 128);
            __int16 v10 = *(_WORD *)(a2 + 132);
            sub_100209958(v8, a1 + 424, (unsigned __int8 *)&v9, a3);
          }

          return sub_100242FAC((uint64_t)v11);
        }
      }
    }

    return sub_100242FAC((uint64_t)v11);
  }

  return result;
}

void sub_10021FE78(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, ...)
{
}

uint64_t sub_10021FE8C(uint64_t a1, uint64_t a2, int a3)
{
  uint64_t result = sub_10021AF3C(a1, a2);
  if ((_DWORD)result)
  {
    v11[0] = 0LL;
    v11[1] = 0LL;
    sub_100242F28((uint64_t)v11, a1 + 360);
    if (a2)
    {
      for (uint64_t i = *(void *)(a1 + 336); i != *(void *)(a1 + 344); i += 8LL)
      {
        if (**(void **)i == a2)
        {
          uint64_t v8 = *(void *)(*(void *)i + 48LL);
          if (v8)
          {
            int v9 = *(_DWORD *)(a2 + 128);
            __int16 v10 = *(_WORD *)(a2 + 132);
            sub_100209E04(v8, a1 + 424, (uint64_t)&v9, a3);
          }

          return sub_100242FAC((uint64_t)v11);
        }
      }
    }

    return sub_100242FAC((uint64_t)v11);
  }

  return result;
}

void sub_10021FF30(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, ...)
{
}

uint64_t sub_10021FF44(uint64_t a1, uint64_t a2)
{
  v63[0] = 0LL;
  v63[1] = 0LL;
  sub_100242F28((uint64_t)v63, a1 + 360);
  if (a2)
  {
    for (uint64_t i = *(void **)(a1 + 336); i != *(void **)(a1 + 344); ++i)
    {
      uint64_t v5 = (void *)*i;
      if (*(void *)*i == a2) {
        goto LABEL_7;
      }
    }
  }

  uint64_t v5 = 0LL;
LABEL_7:
  id v6 = (os_log_s *)qword_1008F7560;
  if (os_log_type_enabled((os_log_t)qword_1008F7560, OS_LOG_TYPE_DEFAULT))
  {
    sub_1003CF00C(a2, __p);
    uint64_t v7 = v57 >= 0 ? __p : (void **)__p[0];
    unint64_t v8 = *(char *)(a1 + 431);
    int v9 = v8 > 3 ? "Unknown" : off_100889030[v8];
    *(_DWORD *)__int128 buf = 136446466;
    *(void *)&uint8_t buf[4] = v7;
    __int16 v67 = 2080;
    __int128 v68 = v9;
    _os_log_impl( (void *)&_mh_execute_header,  v6,  OS_LOG_TYPE_DEFAULT,  "Easy unpair request for device %{public}s; Unpair Initiator: %s",
      buf,
      0x16u);
    if (SHIBYTE(v57) < 0) {
      operator delete(__p[0]);
    }
  }

  __p[0] = 0LL;
  __p[1] = __p;
  uint64_t v58 = sub_100220874;
  __int16 v59 = nullsub_91;
  unsigned int v60 = &unk_1007C41D6;
  id v11 = (_DWORD *)(a2 + 128);
  int v10 = *(_DWORD *)(a2 + 128);
  uint64_t v57 = 0x3812000000LL;
  v61[0] = 0;
  __int16 v62 = 0;
  *(_DWORD *)&v61[1] = v10;
  __int16 v62 = *(_WORD *)(a2 + 132);
  uint64_t v12 = sub_100404FE8();
  v55[0] = _NSConcreteStackBlock;
  v55[1] = 3221225472LL;
  v55[2] = sub_10022088C;
  v55[3] = &unk_100880C30;
  uint64_t v55[4] = __p;
  sub_100405384(v12, v55);
  int v13 = *(unsigned __int8 *)(a1 + 431);
  if ((v13 | 2) == 3)
  {
    uint64_t v14 = (os_log_s *)qword_1008F7560;
    if (!os_log_type_enabled((os_log_t)qword_1008F7560, OS_LOG_TYPE_DEFAULT)) {
      goto LABEL_57;
    }
    sub_1003CF00C(a2, buf);
    int v15 = "user-switch";
    if (v13 == 1) {
      int v15 = "cloud";
    }
    int v16 = v69 >= 0 ? buf : *(_BYTE **)buf;
    *(_DWORD *)__int16 v64 = 136315394;
    *(void *)&v64[4] = v15;
    *(_WORD *)&v64[12] = 2082;
    *(void *)&v64[14] = v16;
    _os_log_impl( (void *)&_mh_execute_header,  v14,  OS_LOG_TYPE_DEFAULT,  "Skip easy unpair request from %s: %{public}s",  v64,  0x16u);
    if ((SHIBYTE(v69) & 0x80000000) == 0) {
      goto LABEL_57;
    }
    int v17 = *(void **)buf;
    goto LABEL_25;
  }

  if (!v5)
  {
    int v31 = (os_log_s *)qword_1008F7560;
    if (os_log_type_enabled((os_log_t)qword_1008F7560, OS_LOG_TYPE_DEFAULT))
    {
      sub_1003FE1B4((unsigned __int8 *)(a1 + 424), v64);
      int v32 = v65;
      int v33 = *(char **)v64;
      sub_1003CF00C(a2, v53);
      __int16 v34 = v64;
      if (v32 < 0) {
        __int16 v34 = v33;
      }
      if (v54 >= 0) {
        int v35 = v53;
      }
      else {
        int v35 = (void **)v53[0];
      }
      int v36 = *(unsigned __int8 *)(a1 + 432);
      *(_DWORD *)__int128 buf = 141558787;
      *(void *)&uint8_t buf[4] = 1752392040LL;
      __int16 v67 = 2081;
      __int128 v68 = v34;
      __int16 v69 = 2082;
      __int128 v70 = v35;
      __int16 v71 = 1024;
      int v72 = v36;
      _os_log_impl( (void *)&_mh_execute_header,  v31,  OS_LOG_TYPE_DEFAULT,  "Sending Easy Unpair request to device %{private, mask.hash}s for device %{public}s with version %d",  buf,  0x26u);
      if (v54 < 0) {
        operator delete(v53[0]);
      }
      if (v65 < 0) {
        operator delete(*(void **)v64);
      }
    }

    LODWORD(v53[0]) = *v11;
    WORD2(v53[0]) = *(_WORD *)(a2 + 132);
    *(void *)__int16 v64 = 0LL;
    *(void *)&v64[8] = 0LL;
    if (*(unsigned __int8 *)(a1 + 432) < 5u)
    {
      uint64_t v40 = sub_1002E8F6C();
      sub_1003FE1B4((unsigned __int8 *)v53, v49);
      sub_1003D0100(a2, (uint64_t)buf);
      if (v69 >= 0) {
        int v41 = buf;
      }
      else {
        int v41 = *(_BYTE **)buf;
      }
      (*(void (**)(uint64_t, void *, _BYTE *, _BYTE *, uint64_t))(*(void *)v40 + 104LL))( v40,  v49,  v41,  v64,  16LL);
      if (SHIBYTE(v69) < 0) {
        operator delete(*(void **)buf);
      }
      if ((v50 & 0x80000000) == 0) {
        goto LABEL_57;
      }
      uint64_t v39 = (void **)v49;
    }

    else
    {
      uint64_t v37 = sub_1002E8F6C();
      sub_1003FE1B4((unsigned __int8 *)v53, v51);
      sub_1003D0100(a2, (uint64_t)buf);
      if (v69 >= 0) {
        uint64_t v38 = buf;
      }
      else {
        uint64_t v38 = *(_BYTE **)buf;
      }
      (*(void (**)(uint64_t, void *, _BYTE *, _BYTE *, uint64_t, void, void))(*(void *)v37 + 112LL))( v37,  v51,  v38,  v64,  16LL,  0LL,  0LL);
      if (SHIBYTE(v69) < 0) {
        operator delete(*(void **)buf);
      }
      if ((v52 & 0x80000000) == 0) {
        goto LABEL_57;
      }
      uint64_t v39 = (void **)v51;
    }

    int v17 = *v39;
LABEL_25:
    operator delete(v17);
LABEL_57:
    uint64_t v27 = 0LL;
    *(_BYTE *)(a1 + 431) = 0;
    goto LABEL_58;
  }

  if (*(_BYTE *)(a1 + 328))
  {
    char v48 = 0;
    sub_100242CA4(&v48);
    __int16 v47 = 0;
    int v46 = 0;
    if (qword_1008D60B0 != -1) {
      dispatch_once(&qword_1008D60B0, &stru_100888AF0);
    }
    sub_100431644((uint64_t)off_1008D60A8, (uint64_t)&v46);
    sub_100242CD0(&v48);
    sub_100214C40(a1, a2, (uint64_t)&v46, 0LL, 0LL);
    *((_BYTE *)v5 + 12) = 1;
    sub_100214D78(a1, a2, (uint64_t)&v46);
    if (!sub_10021AF3C(a1, a2)
      || *(_BYTE *)(a1 + 431) && (*(_BYTE *)(a1 + 431) != 1 || *(unsigned __int8 *)(a1 + 432) > 9u))
    {
      goto LABEL_70;
    }

    __int16 v18 = (os_log_s *)qword_1008F7560;
    if (os_log_type_enabled((os_log_t)qword_1008F7560, OS_LOG_TYPE_DEFAULT))
    {
      sub_1003FE1B4((unsigned __int8 *)(a1 + 424), v64);
      int v19 = v65;
      int v20 = *(char **)v64;
      sub_1003CF00C(a2, v53);
      int v21 = v64;
      if (v19 < 0) {
        int v21 = v20;
      }
      if (v54 >= 0) {
        __int16 v22 = v53;
      }
      else {
        __int16 v22 = (void **)v53[0];
      }
      int v23 = *(unsigned __int8 *)(a1 + 432);
      *(_DWORD *)__int128 buf = 141558787;
      *(void *)&uint8_t buf[4] = 1752392040LL;
      __int16 v67 = 2081;
      __int128 v68 = v21;
      __int16 v69 = 2082;
      __int128 v70 = v22;
      __int16 v71 = 1024;
      int v72 = v23;
      _os_log_impl( (void *)&_mh_execute_header,  v18,  OS_LOG_TYPE_DEFAULT,  "Sending Easy Unpair request to device %{private, mask.hash}s for device %{public}s with version %d",  buf,  0x26u);
      if (v54 < 0) {
        operator delete(v53[0]);
      }
      if (v65 < 0) {
        operator delete(*(void **)v64);
      }
    }

    LODWORD(v53[0]) = *v11;
    WORD2(v53[0]) = *(_WORD *)(a2 + 132);
    *(void *)__int16 v64 = 0LL;
    *(void *)&v64[8] = 0LL;
    if (*(unsigned __int8 *)(a1 + 432) < 5u)
    {
      uint64_t v29 = sub_1002E8F6C();
      sub_1003FE1B4((unsigned __int8 *)v53, v42);
      sub_1003D0100(a2, (uint64_t)buf);
      if (v69 >= 0) {
        __int16 v30 = buf;
      }
      else {
        __int16 v30 = *(_BYTE **)buf;
      }
      (*(void (**)(uint64_t, void *, _BYTE *, _BYTE *, uint64_t))(*(void *)v29 + 104LL))( v29,  v42,  v30,  v64,  16LL);
      if (SHIBYTE(v69) < 0) {
        operator delete(*(void **)buf);
      }
      if ((v43 & 0x80000000) == 0) {
        goto LABEL_70;
      }
      __int16 v26 = (void **)v42;
    }

    else
    {
      uint64_t v24 = sub_1002E8F6C();
      sub_1003FE1B4((unsigned __int8 *)v53, v44);
      sub_1003D0100(a2, (uint64_t)buf);
      if (v69 >= 0) {
        char v25 = buf;
      }
      else {
        char v25 = *(_BYTE **)buf;
      }
      (*(void (**)(uint64_t, void *, _BYTE *, _BYTE *, uint64_t, void, void))(*(void *)v24 + 112LL))( v24,  v44,  v25,  v64,  16LL,  0LL,  0LL);
      if (SHIBYTE(v69) < 0) {
        operator delete(*(void **)buf);
      }
      if ((v45 & 0x80000000) == 0) {
        goto LABEL_70;
      }
      __int16 v26 = (void **)v44;
    }

    operator delete(*v26);
LABEL_70:
    *(_BYTE *)(a1 + 431) = 0;
    sub_100242CD8(&v48);
    uint64_t v27 = 1LL;
    goto LABEL_58;
  }

  if (os_log_type_enabled((os_log_t)qword_1008F7560, OS_LOG_TYPE_ERROR)) {
    sub_10065FF8C();
  }
  uint64_t v27 = 0LL;
LABEL_58:
  _Block_object_dispose(__p, 8);
  sub_100242FAC((uint64_t)v63);
  return v27;
}

void sub_100220714( _Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, void *a9, uint64_t a10, int a11, __int16 a12, char a13, char a14, uint64_t a15, uint64_t a16, int a17, __int16 a18, char a19, char a20, int a21, __int16 a22, char a23, char a24, void *__p, uint64_t a26, int a27, __int16 a28, char a29, char a30, uint64_t a31, uint64_t a32, int a33, __int16 a34, char a35, char a36, uint64_t a37, uint64_t a38, uint64_t a39, uint64_t a40, uint64_t a41, uint64_t a42, uint64_t a43, uint64_t a44, char a45)
{
  if (a30 < 0) {
    operator delete(__p);
  }
  _Block_object_dispose(&a45, 8);
  sub_100242FAC(v45 - 176);
  _Unwind_Resume(a1);
}

const char *sub_10022084C(uint64_t a1, unsigned int a2)
{
  if (a2 > 3) {
    return "Unknown";
  }
  else {
    return off_100889030[(char)a2];
  }
}

uint64_t sub_100220874(uint64_t result, uint64_t a2)
{
  int v2 = *(_DWORD *)(a2 + 48);
  *(_DWORD *)(result + 51) = *(_DWORD *)(a2 + 51);
  *(_DWORD *)(result + 4std::ostream::~ostream(v2, v3 + 8) = v2;
  return result;
}

uint64_t sub_10022088C(uint64_t a1)
{
  if (qword_1008D6608 != -1) {
    dispatch_once(&qword_1008D6608, &stru_100888CF0);
  }
  sub_10060CBEC((uint64_t)off_1008D6600, (unsigned __int8 *)(*(void *)(*(void *)(a1 + 32) + 8LL) + 48LL));
  if (qword_1008D5F20 != -1) {
    dispatch_once(&qword_1008D5F20, &stru_100888CB0);
  }
  return sub_10062AC58(qword_1008D5F18, (unsigned __int8 *)(*(void *)(*(void *)(a1 + 32) + 8LL) + 48LL));
}

uint64_t sub_100220924(uint64_t a1, uint64_t a2)
{
  v6[0] = 0LL;
  v6[1] = 0LL;
  sub_100242F28((uint64_t)v6, a1 + 360);
  if (a2)
  {
    for (uint64_t i = *(uint64_t ***)(a1 + 336); i != *(uint64_t ***)(a1 + 344); ++i)
    {
      if (**i == a2)
      {
        sub_10021AFA4(a1, *i);
        return sub_100242FAC((uint64_t)v6);
      }
    }
  }

  return sub_100242FAC((uint64_t)v6);
}

void sub_100220994( _Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9)
{
}

uint64_t sub_1002209A8(uint64_t a1, uint64_t a2, uint64_t a3, unsigned int a4)
{
  v12[0] = 0LL;
  v12[1] = 0LL;
  sub_100242F28((uint64_t)v12, a1 + 360);
  if (a2)
  {
    for (uint64_t i = *(void ***)(a1 + 336); i != *(void ***)(a1 + 344); ++i)
    {
      if (**i == a2)
      {
        uint64_t v9 = sub_100215778(a1, a2, 1LL, a3, a4);
        goto LABEL_7;
      }
    }
  }

  uint64_t v9 = 312LL;
LABEL_7:
  uint64_t v10 = sub_1003DD594(a2, a3);
  sub_10021E798(v10, a2);
  sub_100242FAC((uint64_t)v12);
  return v9;
}

void sub_100220A5C( _Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9)
{
}

uint64_t sub_100220A70(uint64_t a1, uint64_t a2, uint64_t a3)
{
  v17[0] = 0LL;
  v17[1] = 0LL;
  sub_100242F28((uint64_t)v17, a1 + 360);
  if (a2)
  {
    for (uint64_t i = *(void ***)(a1 + 336); i != *(void ***)(a1 + 344); ++i)
    {
      if (**i == a2)
      {
        if ((_DWORD)a3)
        {
          sub_100215778(a1, a2, 7LL, 0LL, 2u);
          uint64_t v13 = 4LL;
          uint64_t v14 = a3;
        }

        else
        {
          uint64_t v14 = 0xFFFFFFFFLL;
          uint64_t v13 = 7LL;
        }

        uint64_t v7 = sub_100215778(a1, a2, v13, v14, 2u);
        goto LABEL_7;
      }
    }
  }

  uint64_t v7 = 1LL;
LABEL_7:
  uint64_t v8 = sub_1002E6BF0();
  if (((*(uint64_t (**)(uint64_t))(*(void *)v8 + 328LL))(v8) & 1) != 0
    || (uint64_t v9 = sub_1002E6BF0(), ((*(uint64_t (**)(uint64_t))(*(void *)v9 + 384LL))(v9) & 1) != 0)
    || (uint64_t v10 = sub_1002E6BF0(), (*(unsigned int (**)(uint64_t))(*(void *)v10 + 424LL))(v10)))
  {
    sub_10021539C(a1, a2);
    if (qword_1008D60C0 != -1) {
      dispatch_once(&qword_1008D60C0, &stru_100888BD0);
    }
    sub_1003F637C((uint64_t)off_1008D60B8, a2, 4097);
    v15[0] = 0LL;
    v15[1] = 0LL;
    uint64_t v16 = 0LL;
    sub_10040CB88((uint64_t)v15, 4, a2);
    LODWORD(v16) = a3;
    HIDWORD(v16) = a3;
    uint64_t v11 = sub_1002E8D94();
    (*(void (**)(uint64_t, void *))(*(void *)v11 + 56LL))(v11, v15);
  }

  sub_100242FAC((uint64_t)v17);
  return v7;
}

void sub_100220BF4(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, ...)
{
}

uint64_t sub_100220C0C(uint64_t a1, uint64_t a2, unsigned int a3, unsigned int a4, int a5)
{
  int v10 = sub_1003D635C(a2);
  sub_1003D63A0(a2, a4 | (a3 << 8));
  v20[0] = 0LL;
  v20[1] = 0LL;
  sub_100242F28((uint64_t)v20, a1 + 360);
  if (a2)
  {
    for (uint64_t i = *(void ***)(a1 + 336); i != *(void ***)(a1 + 344); ++i)
    {
      if (**i == a2)
      {
        uint64_t v12 = sub_100215778(a1, a2, 12LL, a4 | (a3 << 8), 2u);
        goto LABEL_9;
      }
    }
  }

  uint64_t v12 = 1LL;
LABEL_9:
  uint64_t v13 = sub_1002E6BF0();
  if (((*(uint64_t (**)(uint64_t))(*(void *)v13 + 328LL))(v13) & 1) != 0
    || (uint64_t v14 = sub_1002E6BF0(), ((*(uint64_t (**)(uint64_t))(*(void *)v14 + 384LL))(v14) & 1) != 0)
    || (uint64_t v15 = sub_1002E6BF0(), (*(unsigned int (**)(uint64_t))(*(void *)v15 + 424LL))(v15)))
  {
    sub_10021539C(a1, a2);
    if (v10 != 0xFFFF && a5 == 2 && v10 != (a4 | (a3 << 8)))
    {
      if (qword_1008D60C0 != -1) {
        dispatch_once(&qword_1008D60C0, &stru_100888BD0);
      }
      sub_1003F637C((uint64_t)off_1008D60B8, a2, 4097);
    }

    v18[0] = 0LL;
    v18[1] = 0LL;
    unint64_t v19 = 0LL;
    sub_10040CB88((uint64_t)v18, 4, a2);
    unint64_t v19 = __PAIR64__(a3, a4);
    uint64_t v16 = sub_1002E8D94();
    (*(void (**)(uint64_t, void *))(*(void *)v16 + 56LL))(v16, v18);
  }

  sub_100242FAC((uint64_t)v20);
  return v12;
}

void sub_100220DC4(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, ...)
{
}

uint64_t sub_100220DDC(uint64_t a1, uint64_t a2, int a3, unsigned int a4)
{
  if (*(_BYTE *)(a1 + 328))
  {
    if (a3) {
      unsigned __int16 v8 = -1;
    }
    else {
      unsigned __int16 v8 = -3;
    }
    char v9 = sub_1003DF944(a2);
    int v10 = (os_log_s *)qword_1008F7560;
    if (os_log_type_enabled((os_log_t)qword_1008F7560, OS_LOG_TYPE_DEFAULT))
    {
      sub_1003D0100(a2, (uint64_t)__p);
      uint64_t v11 = (void **)__p[0];
      uint64_t v12 = "Disabled";
      if (v27 >= 0) {
        uint64_t v11 = __p;
      }
      if (a3) {
        uint64_t v12 = "Enabled";
      }
      *(_DWORD *)__int128 buf = 136315394;
      uint64_t v29 = v11;
      __int16 v30 = 2080;
      int v31 = v12;
      _os_log_impl( (void *)&_mh_execute_header,  v10,  OS_LOG_TYPE_DEFAULT,  "Set InEarDetection for device %s, InEarDetection = %s",  buf,  0x16u);
      if (v27 < 0) {
        operator delete(__p[0]);
      }
    }

    uint64_t v13 = sub_1003DDCA8(a2, a3, 1);
    sub_1002210D0(v13, a2);
    __p[0] = 0LL;
    __p[1] = 0LL;
    sub_100242F28((uint64_t)__p, a1 + 360);
    if (a2)
    {
      for (uint64_t i = *(void **)(a1 + 336); i != *(void **)(a1 + 344); ++i)
      {
        uint64_t v15 = (void *)*i;
        if (*(void *)*i == a2)
        {
          sub_10021C418(a1, a2, 0xFFFFLL, v8);
          if (a3) {
            uint64_t v25 = 2LL;
          }
          else {
            uint64_t v25 = 1LL;
          }
          uint64_t v17 = sub_100215778(a1, a2, 10LL, v25, a4);
          if ((a3 & 1) != 0)
          {
            int v16 = 0;
          }

          else
          {
            *((_BYTE *)v15 + std::ostream::~ostream(v2, v3 + 8) = 0;
            if (*((_BYTE *)v15 + 9) != 3) {
              *((_BYTE *)v15 + 9) = 0;
            }
            int v16 = 1;
          }

          goto LABEL_18;
        }
      }
    }

    int v16 = 0;
    uint64_t v17 = 312LL;
LABEL_18:
    sub_100242F54((uint64_t)__p);
    uint64_t v18 = sub_1002E6BF0();
    uint64_t v19 = sub_1002E6BF0();
    uint64_t v20 = (*(uint64_t (**)(uint64_t))(*(void *)v19 + 328LL))(v19);
    if ((v20 & 1) != 0
      || (v21 = sub_1002E6BF0(), uint64_t v20 = (*(uint64_t (**)(uint64_t))(*(void *)v21 + 384LL))(v21),
                                 (v20 & 1) != 0)
      || (v22 = sub_1002E6BF0(), uint64_t v20 = (*(uint64_t (**)(uint64_t))(*(void *)v22 + 424LL))(v22), (_DWORD)v20))
    {
      if ((v16 & 1) != 0)
      {
        if (a4 != 2) {
          goto LABEL_35;
        }
      }

      else
      {
        char v23 = v9;
        if (a4 != 2) {
          char v23 = 1;
        }
        if ((v23 & 1) != 0 || (a3 & 1) == 0) {
          goto LABEL_36;
        }
      }

      if (qword_1008D60C0 != -1) {
        dispatch_once(&qword_1008D60C0, &stru_100888BD0);
      }
      uint64_t v20 = sub_1003F637C((uint64_t)off_1008D60B8, a2, 4097);
    }

    if (!v16)
    {
LABEL_36:
      sub_100242FAC((uint64_t)__p);
      return v17;
    }

void sub_1002210B4( _Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, char a10)
{
}

uint64_t sub_1002210D0(uint64_t a1, uint64_t a2)
{
  id v3 = (os_log_s *)qword_1008F7560;
  if (os_log_type_enabled((os_log_t)qword_1008F7560, OS_LOG_TYPE_DEFAULT))
  {
    sub_1003D0100(a2, (uint64_t)__p);
    uint64_t v4 = v9 >= 0 ? __p : (void **)__p[0];
    *(_DWORD *)__int128 buf = 136315138;
    uint64_t v11 = v4;
    _os_log_impl( (void *)&_mh_execute_header,  v3,  OS_LOG_TYPE_DEFAULT,  "Notify in ear enabled change for device %s",  buf,  0xCu);
    if (v9 < 0) {
      operator delete(__p[0]);
    }
  }

  uint64_t v5 = sub_100405058();
  v7[0] = _NSConcreteStackBlock;
  v7[1] = 3221225472LL;
  void v7[2] = sub_1002351DC;
  void v7[3] = &unk_10087EB20;
  void v7[4] = a2;
  sub_100405384(v5, v7);
  if (qword_1008D6458 != -1) {
    dispatch_once(&qword_1008D6458, &stru_100888B90);
  }
  sub_100377920((void *)qword_1008D6450, a2);
  if (qword_1008D5F40 != -1) {
    dispatch_once(&qword_1008D5F40, &stru_100888BB0);
  }
  return sub_1003B2560((uint64_t)off_1008D5F38, a2);
}

uint64_t sub_100221254(uint64_t a1, uint64_t a2, int a3)
{
  id v6 = (os_log_s *)qword_1008F7560;
  if (os_log_type_enabled((os_log_t)qword_1008F7560, OS_LOG_TYPE_DEFAULT))
  {
    sub_1003CF00C(a2, __p);
    uint64_t v7 = v28 >= 0 ? __p : *(_BYTE **)__p;
    *(_DWORD *)__int128 buf = 136446466;
    *(void *)&uint8_t buf[4] = v7;
    __int16 v23 = 1024;
    int v24 = a3;
    _os_log_impl( (void *)&_mh_execute_header,  v6,  OS_LOG_TYPE_DEFAULT,  "Received primary bud side notification for device %{public}s, with bud side = %d from other end of magnet",  buf,  0x12u);
    if (SHIBYTE(v28) < 0) {
      operator delete(*(void **)__p);
    }
  }

  v21[0] = 0LL;
  v21[1] = 0LL;
  sub_100242F28((uint64_t)v21, a1 + 360);
  if (a2)
  {
    for (uint64_t i = *(unsigned __int8 ***)(a1 + 336); i != *(unsigned __int8 ***)(a1 + 344); ++i)
    {
      char v9 = *i;
      if (*(void *)*i == a2)
      {
        v9[11] = a3;
        int v10 = (os_log_s *)qword_1008F7560;
        if (os_log_type_enabled((os_log_t)qword_1008F7560, OS_LOG_TYPE_DEFAULT))
        {
          int v11 = v9[10];
          int v12 = v9[9];
          *(_DWORD *)std::string __p = 67109632;
          *(_DWORD *)&__p[4] = a3;
          *(_WORD *)&__p[8] = 1024;
          *(_DWORD *)&__p[10] = v11;
          *(_WORD *)char v27 = 1024;
          *(_DWORD *)&void v27[2] = v12;
          _os_log_impl( (void *)&_mh_execute_header,  v10,  OS_LOG_TYPE_DEFAULT,  "Primary bud info over magnet link -> %d, current connection primary bud info -> %d, current connection secon dary bud in ear status -> %d",  __p,  0x14u);
        }

        uint64_t v13 = sub_1002E6BF0();
        uint64_t v14 = 0LL;
        if (a3 != 3 && v9[10] != a3)
        {
          if (v9[9] != 3) {
            break;
          }
          uint64_t v15 = (os_log_s *)qword_1008F7560;
          if (os_log_type_enabled((os_log_t)qword_1008F7560, OS_LOG_TYPE_DEFAULT))
          {
            sub_1003CF00C(a2, buf);
            int v16 = v25 >= 0 ? buf : *(_BYTE **)buf;
            int v17 = v9[10];
            *(_DWORD *)std::string __p = 136446722;
            *(void *)&__p[4] = v16;
            *(_WORD *)&_BYTE __p[12] = 1024;
            *(_DWORD *)char v27 = v17;
            *(_WORD *)&v27[4] = 1024;
            int v28 = a3;
            _os_log_impl( (void *)&_mh_execute_header,  v15,  OS_LOG_TYPE_DEFAULT,  "Info update from Magnet, Primary bud side  for device %{public}s seen locally is different from that of co mpanion, we see  %d, and companion sees %d. Requesting connected bud to go secondary",  __p,  0x18u);
            if (v25 < 0) {
              operator delete(*(void **)buf);
            }
          }

          uint64_t v14 = sub_100215778(a1, a2, 8LL, 2LL, 1u);
          uint64_t v18 = (os_log_s *)qword_1008F7560;
          if (os_log_type_enabled((os_log_t)qword_1008F7560, OS_LOG_TYPE_DEFAULT))
          {
            sub_1003CF00C(a2, __p);
            uint64_t v19 = v28 >= 0 ? __p : *(_BYTE **)__p;
            *(_DWORD *)__int128 buf = 136315138;
            *(void *)&uint8_t buf[4] = v19;
            _os_log_impl( (void *)&_mh_execute_header,  v18,  OS_LOG_TYPE_DEFAULT,  "Schedule reconnection to W1 device after LSTO (5 seconds) on Gizmo, device addr : %s",  buf,  0xCu);
            if (SHIBYTE(v28) < 0) {
              operator delete(*(void **)__p);
            }
          }

          *(_DWORD *)std::string __p = *(_DWORD *)(a2 + 128);
          *(_WORD *)&__p[4] = *(_WORD *)(a2 + 132);
          if (qword_1008D60D0 != -1) {
            dispatch_once(&qword_1008D60D0, &stru_100888C50);
          }
          sub_1004271D4((uint64_t)off_1008D60C8, __p);
        }

        goto LABEL_34;
      }
    }
  }

  uint64_t v14 = 0LL;
LABEL_34:
  sub_100242FAC((uint64_t)v21);
  return v14;
}

void sub_1002215A8( _Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9)
{
}

uint64_t sub_1002215D0(uint64_t a1, uint64_t a2)
{
  v21[0] = 0LL;
  v21[1] = 0LL;
  sub_100242F28((uint64_t)v21, a1 + 360);
  if (a2)
  {
    for (uint64_t i = *(uint64_t **)(a1 + 336); i != *(uint64_t **)(a1 + 344); ++i)
    {
      uint64_t v5 = *i;
      if (*(void *)*i == a2)
      {
        if (sub_10021B43C(*i))
        {
          char v9 = (os_log_s *)qword_1008F7560;
          if (os_log_type_enabled((os_log_t)qword_1008F7560, OS_LOG_TYPE_DEFAULT))
          {
            if (*(_BYTE *)(v5 + 617)) {
              uint64_t v17 = v5 + 611;
            }
            else {
              uint64_t v17 = v5 + 605;
            }
            int v19 = *(_DWORD *)v17;
            __int16 v20 = *(_WORD *)(v17 + 4);
            uint64_t v18 = sub_1001EDE10((uint64_t)&v19, v10, v11, v12, v13, v14, v15, v16);
            *(_DWORD *)__int128 buf = 136446210;
            uint64_t v23 = v18;
            _os_log_impl( (void *)&_mh_execute_header,  v9,  OS_LOG_TYPE_DEFAULT,  "Peer source %{public}s is currently connected in TiPi, skip connection stealing",  buf,  0xCu);
          }

          uint64_t v6 = 17LL;
        }

        else
        {
          if (sub_10021AF3C(a1, a2))
          {
            sub_10021AFA4(a1, (uint64_t *)v5);
            uint64_t v6 = 0LL;
            goto LABEL_9;
          }

          uint64_t v6 = 1LL;
        }

        goto LABEL_7;
      }
    }
  }

  uint64_t v6 = 7LL;
LABEL_7:
  uint64_t v7 = (os_log_s *)qword_1008F7560;
  if (os_log_type_enabled((os_log_t)qword_1008F7560, OS_LOG_TYPE_DEFAULT))
  {
    *(_DWORD *)__int128 buf = 67109120;
    LODWORD(v23) = v6;
    _os_log_impl( (void *)&_mh_execute_header,  v7,  OS_LOG_TYPE_DEFAULT,  "reformTriangle: Conditions not met for easy pairing, result %d",  buf,  8u);
  }

void sub_100221778(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, ...)
{
}

uint64_t sub_100221798(uint64_t a1)
{
  return a1 + 560;
}

void sub_1002217A0(uint64_t a1)
{
  uint64_t v1 = (os_log_s *)qword_1008F7560;
  if (os_log_type_enabled((os_log_t)qword_1008F7560, OS_LOG_TYPE_DEFAULT))
  {
    *(_WORD *)__int128 buf = 0;
    _os_log_impl( (void *)&_mh_execute_header,  v1,  OS_LOG_TYPE_DEFAULT,  "statedump: ----------------- AACP connections ------------------",  buf,  2u);
  }

  *(void *)__int128 buf = 0LL;
  BOOL v42 = 0LL;
  uint64_t v43 = 0LL;
  sub_100240540(buf, a1 + 336);
  int v2 = *(uint64_t ***)buf;
  if (*(uint64_t ***)buf != v42)
  {
    while (1)
    {
      uint64_t v3 = **v2;
      int v4 = *((_DWORD *)*v2 + 20);
      uint64_t v5 = (os_log_s *)qword_1008F7560;
      if (os_log_type_enabled((os_log_t)qword_1008F7560, OS_LOG_TYPE_DEFAULT))
      {
        sub_1003CF00C(v3, &v52);
        uint64_t v6 = &v52;
        if (v53 < 0) {
          uint64_t v6 = (__int128 *)v52;
        }
        *(_DWORD *)uint32_t v44 = 136446466;
        *(void *)&v44[4] = v6;
        __int16 v45 = 1024;
        LODWORD(v46) = v4;
        _os_log_impl( (void *)&_mh_execute_header,  v5,  OS_LOG_TYPE_DEFAULT,  "statedump: Device %{public}s (pId 0x%04X)",  v44,  0x12u);
        if (SHIBYTE(v53) < 0) {
          operator delete((void *)v52);
        }
      }

      if ((v4 - 8194) > 0xE || ((1 << (v4 - 2)) & 0x409B) == 0)
      {
        uint64_t v37 = (os_log_s *)qword_1008F7560;
        if (os_log_type_enabled((os_log_t)qword_1008F7560, OS_LOG_TYPE_DEFAULT))
        {
          BOOL v38 = sub_1003D94C4(v3);
          uint64_t v39 = "no";
          if (v38) {
            uint64_t v39 = "yes";
          }
          LODWORD(v52) = 136446210;
          *(void *)((char *)&v52 + 4) = v39;
          _os_log_impl( (void *)&_mh_execute_header,  v37,  OS_LOG_TYPE_DEFAULT,  "statedump:   Dev-fused: %{public}s",  (uint8_t *)&v52,  0xCu);
        }
      }

      __int128 v52 = 0uLL;
      uint64_t v53 = 0LL;
      sub_1003D930C(v3, 0xAu, &v52);
      unint64_t v8 = HIBYTE(v53);
      int v9 = SHIBYTE(v53);
      if (v53 < 0) {
        unint64_t v8 = *((void *)&v52 + 1);
      }
      uint64_t v10 = (os_log_s *)qword_1008F7560;
      if (v8 >= 2 && os_log_type_enabled((os_log_t)qword_1008F7560, OS_LOG_TYPE_DEFAULT))
      {
        uint64_t v11 = (__int128 *)v52;
        if (v9 >= 0) {
          uint64_t v11 = &v52;
        }
        *(_DWORD *)uint32_t v44 = 136446210;
        *(void *)&v44[4] = v11;
        _os_log_impl( (void *)&_mh_execute_header,  v10,  OS_LOG_TYPE_DEFAULT,  "statedump:   Firmware version: %{public}s",  v44,  0xCu);
        uint64_t v10 = (os_log_s *)qword_1008F7560;
      }

      BOOL v12 = os_log_type_enabled(v10, OS_LOG_TYPE_DEFAULT);
      if (v12)
      {
        unsigned __int8 v13 = sub_1003DF900(v3);
        uint64_t v14 = "unknown";
        if (v13 <= 2u) {
          uint64_t v14 = off_100889050[(char)v13];
        }
        *(_DWORD *)uint32_t v44 = 136446466;
        *(void *)&v44[4] = "Mic mode";
        __int16 v45 = 2082;
        int v46 = v14;
        _os_log_impl( (void *)&_mh_execute_header,  v10,  OS_LOG_TYPE_DEFAULT,  "statedump:   %{public}s: %{public}s",  v44,  0x16u);
      }

      if (sub_10021C224(v12, v3))
      {
        uint64_t v15 = (os_log_s *)qword_1008F7560;
        if (os_log_type_enabled((os_log_t)qword_1008F7560, OS_LOG_TYPE_DEFAULT))
        {
          int v16 = sub_1003DF944(v3);
          *(_DWORD *)uint32_t v44 = 136446466;
          uint64_t v17 = "Disabled";
          if (v16) {
            uint64_t v17 = "Enabled";
          }
          *(void *)&v44[4] = "In Ear detection";
          __int16 v45 = 2082;
          int v46 = v17;
          _os_log_impl( (void *)&_mh_execute_header,  v15,  OS_LOG_TYPE_DEFAULT,  "statedump:   %{public}s: %{public}s",  v44,  0x16u);
        }
      }

      if ((sub_1003D2B2C(v3, 30) & 1) != 0) {
        break;
      }
      if ((sub_1003D2B2C(v3, 14) & 1) != 0)
      {
        int v19 = 12;
        goto LABEL_33;
      }

      if ((v4 - 8194) < 0xF && ((0x409Bu >> (v4 - 2)) & 1) != 0)
      {
        int v19 = 4;
LABEL_33:
        unsigned int v18 = sub_1003D635C(v3);
LABEL_34:
        __int16 v20 = (os_log_s *)qword_1008F7560;
        if (os_log_type_enabled((os_log_t)qword_1008F7560, OS_LOG_TYPE_DEFAULT))
        {
          uint64_t v21 = sub_100216F34(a1, v19, v18, v44);
          uint64_t v22 = sub_100216F08((uint64_t)v21, v19);
          uint64_t v23 = v47 >= 0 ? v44 : *(_BYTE **)v44;
          *(_DWORD *)char v48 = 136446466;
          uint64_t v49 = v22;
          __int16 v50 = 2082;
          unsigned int v51 = v23;
          _os_log_impl( (void *)&_mh_execute_header,  v20,  OS_LOG_TYPE_DEFAULT,  "statedump:   %{public}s: %{public}s",  v48,  0x16u);
          if (v47 < 0) {
            operator delete(*(void **)v44);
          }
        }
      }

      if ((sub_1003D2B2C(v3, 16) & 1) != 0 || sub_1003D2B2C(v3, 17))
      {
        int v24 = (os_log_s *)qword_1008F7560;
        if (os_log_type_enabled((os_log_t)qword_1008F7560, OS_LOG_TYPE_DEFAULT))
        {
          unsigned int v25 = sub_1003DFA38(v3) - 1;
          __int16 v26 = "unknown";
          if (v25 <= 3) {
            __int16 v26 = off_1008890A0[v25];
          }
          sub_10002418C(v44, v26);
          if (v47 >= 0) {
            char v27 = v44;
          }
          else {
            char v27 = *(_BYTE **)v44;
          }
          *(_DWORD *)char v48 = 136446466;
          uint64_t v49 = "Listen mode";
          __int16 v50 = 2082;
          unsigned int v51 = v27;
          _os_log_impl( (void *)&_mh_execute_header,  v24,  OS_LOG_TYPE_DEFAULT,  "statedump:   %{public}s: %{public}s",  v48,  0x16u);
          if (v47 < 0) {
            operator delete(*(void **)v44);
          }
        }
      }

      if (sub_1003D2B2C(v3, 28))
      {
        int v28 = (os_log_s *)qword_1008F7560;
        if (os_log_type_enabled((os_log_t)qword_1008F7560, OS_LOG_TYPE_DEFAULT))
        {
          uint64_t v29 = sub_1003DFA7C(v3);
          __int16 v30 = (char *)sub_1002354F8(v29, v29);
          sub_10002418C(v44, v30);
          int v31 = v47 >= 0 ? v44 : *(_BYTE **)v44;
          *(_DWORD *)char v48 = 136446466;
          uint64_t v49 = "Listening Mode Configs";
          __int16 v50 = 2082;
          unsigned int v51 = v31;
          _os_log_impl( (void *)&_mh_execute_header,  v28,  OS_LOG_TYPE_DEFAULT,  "statedump:   %{public}s: %{public}s",  v48,  0x16u);
          if (v47 < 0) {
            operator delete(*(void **)v44);
          }
        }
      }

      if (sub_1003D2B2C(v3, 16))
      {
        if (sub_1003D2B2C(v3, 1))
        {
          int v32 = (os_log_s *)qword_1008F7560;
          if (os_log_type_enabled((os_log_t)qword_1008F7560, OS_LOG_TYPE_DEFAULT))
          {
            int v33 = sub_1003DFC9C(v3);
            __int16 v34 = "unknown";
            if (v33 == 1) {
              __int16 v34 = "Enabled";
            }
            if (v33 == 2) {
              int v35 = "Disabled";
            }
            else {
              int v35 = (char *)v34;
            }
            sub_10002418C(v44, v35);
            if (v47 >= 0) {
              int v36 = v44;
            }
            else {
              int v36 = *(_BYTE **)v44;
            }
            *(_DWORD *)char v48 = 136446466;
            uint64_t v49 = "One Bud ANC Mode";
            __int16 v50 = 2082;
            unsigned int v51 = v36;
            _os_log_impl( (void *)&_mh_execute_header,  v32,  OS_LOG_TYPE_DEFAULT,  "statedump:   %{public}s: %{public}s",  v48,  0x16u);
            if (v47 < 0) {
              operator delete(*(void **)v44);
            }
          }
        }
      }

      if (SHIBYTE(v53) < 0) {
        operator delete((void *)v52);
      }
      if (++v2 == v42)
      {
        int v2 = *(uint64_t ***)buf;
        goto LABEL_81;
      }
    }

    unsigned int v18 = sub_1003DFBD0(v3);
    int v19 = 22;
    goto LABEL_34;
  }

LABEL_81:
  if (v2)
  {
    BOOL v42 = v2;
    operator delete(v2);
  }

          uint64_t v10 = 0;
          uint64_t v11 = 0;
          goto LABEL_82;
        }
      }

      else if (__p.__r_.__value_.__s.__size_ != 2 || LOWORD(__p.__r_.__value_.__l.__data_) != 12355)
      {
        goto LABEL_72;
      }

  sub_100242FAC((uint64_t)v42);
  return a5;
}

  int v41 = sub_1002E6E00();
  sub_10002418C(buf, "CONNECTION");
  sub_10002418C(__p, "LeConnectionMagnetTimeDurationFromDisabledToStageOneValue");
  BOOL v42 = (*(uint64_t (**)(uint64_t, uint8_t *, void **, int *))(*(void *)v41 + 88LL))(v41, buf, __p, &v80);
  if (v84 < 0) {
    operator delete(__p[0]);
  }
  if (v94 < 0)
  {
    operator delete(*(void **)buf);
    if (!v42) {
      goto LABEL_89;
    }
  }

  else if (!v42)
  {
    goto LABEL_89;
  }

  uint64_t v43 = (os_log_s *)qword_1008F7620;
  if (os_log_type_enabled((os_log_t)qword_1008F7620, OS_LOG_TYPE_DEFAULT))
  {
    *(_DWORD *)__int128 buf = 67109120;
    *(_DWORD *)&uint8_t buf[4] = v80;
    _os_log_impl( (void *)&_mh_execute_header,  v43,  OS_LOG_TYPE_DEFAULT,  "LeConnectionMagnetTimeDurationFromDisabledToStageOneValue =%d (override)",  buf,  8u);
  }

void sub_100221E74( _Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, void *__p, uint64_t a16)
{
}

id sub_100221ED8(uint64_t a1, uint64_t a2)
{
  unsigned __int8 v3 = atomic_load((unsigned __int8 *)&qword_1008EF940);
  if ((v3 & 1) == 0 && __cxa_guard_acquire(&qword_1008EF940))
  {
    uint64_t v23 = (void *)[NSCharacterSet alphanumericCharacterSet];
    qword_1008EF938 = [v23 invertedSet];

    __cxa_guard_release(&qword_1008EF940);
  }

  if (qword_1008D5F50 != -1) {
    dispatch_once(&qword_1008D5F50, &stru_100888BF0);
  }
  LODWORD(__p[0]) = *(_DWORD *)a2;
  WORD2(__p[0]) = *(_WORD *)(a2 + 4);
  int v4 = sub_1003FFEB0(off_1008D5F48, (uint64_t)__p, 1);
  BOOL v12 = +[NSString stringWithFormat:]( &OBJC_CLASS___NSString,  "stringWithFormat:",  @"%s",  sub_1001EDE10(a2, v5, v6, v7, v8, v9, v10, v11));
  unsigned __int8 v13 = (void *)objc_claimAutoreleasedReturnValue(v12);
  uint64_t v14 = (void *)[v13 stringByReplacingOccurrencesOfString:@":" withString:&stru_1008A57D8];

  uint64_t v15 = sub_1002E6E00();
  if ((*(unsigned int (**)(uint64_t))(*(void *)v15 + 8LL))(v15))
  {
    if (v4)
    {
      sub_1003D0100((uint64_t)v4, (uint64_t)__p);
      if (v25 >= 0) {
        int v16 = __p;
      }
      else {
        int v16 = (void **)__p[0];
      }
      uint64_t v17 = (void *)[NSString stringWithUTF8String:v16];
      if (v25 < 0) {
        operator delete(__p[0]);
      }
      unsigned int v18 = (void *)[v17 componentsSeparatedByCharactersInSet:qword_1008EF938];
      int v19 = (void *)[v18 componentsJoinedByString:&stru_1008A57D8];

      if ((unint64_t)[v19 length] < 0x41)
      {
        int v4 = v19;
      }

      else
      {
        uint64_t v20 = [v19 substringToIndex:64];

        int v4 = (void *)v20;
      }
    }

    id v21 = [NSString stringWithFormat:@"%@_%@", v14, v4];
  }

  else
  {
    id v21 = v14;
  }

  return v21;
}

void sub_100222108( _Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, void *__p, uint64_t a13, int a14, __int16 a15, char a16, char a17)
{
  __cxa_guard_abort(&qword_1008EF940);
  _Unwind_Resume(a1);
}

id sub_100222170(uint64_t a1, uint64_t a2)
{
  id v2 = sub_100221ED8(a1, a2);
  unsigned __int8 v3 = (void *)objc_claimAutoreleasedReturnValue(v2);
  int v4 = (void *)objc_claimAutoreleasedReturnValue( +[NSString stringWithFormat:]( &OBJC_CLASS___NSString,  "stringWithFormat:",  @"/private/var/mobile/Library/Logs/Bluetooth/AccessoryVersionInfo_%@.txt",  v3));

  return v4;
}

void sub_1002221C8(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

uint64_t sub_1002221D8(uint64_t a1, uint64_t a2, const void *a3, unsigned int a4)
{
  int v4 = (os_log_s *)qword_1008F7560;
  if (*(_BYTE *)(a1 + 328))
  {
    if (os_log_type_enabled((os_log_t)qword_1008F7560, OS_LOG_TYPE_DEFAULT))
    {
      sub_1003D0100(a2, (uint64_t)__p);
      uint64_t v8 = v13 >= 0 ? __p : (void **)__p[0];
      *(_DWORD *)__int128 buf = 67109635;
      unsigned int v15 = a4;
      __int16 v16 = 2160;
      uint64_t v17 = 1752392040LL;
      __int16 v18 = 2081;
      int v19 = v8;
      _os_log_impl( (void *)&_mh_execute_header,  v4,  OS_LOG_TYPE_DEFAULT,  "sendSmartRoutingInformation: Sending SR 2.0 info of length %u to %{private, mask.hash}s",  buf,  0x1Cu);
      if (v13 < 0) {
        operator delete(__p[0]);
      }
    }

    buf[0] = 0;
    sub_100242CA4(buf);
    uint64_t v9 = sub_100080D44((unsigned __int8 *)(a2 + 128), a3, a4);
    sub_100242CD0(buf);
    if ((_DWORD)v9 && os_log_type_enabled((os_log_t)qword_1008F7560, OS_LOG_TYPE_ERROR)) {
      sub_10065FFE4();
    }
    if (qword_1008D60B0 != -1) {
      dispatch_once(&qword_1008D60B0, &stru_100888AF0);
    }
    uint64_t v10 = sub_1004317E0((uint64_t)off_1008D60A8, v9, 10000);
    sub_100242CD8(buf);
  }

  else
  {
    if (os_log_type_enabled((os_log_t)qword_1008F7560, OS_LOG_TYPE_ERROR)) {
      sub_10065FFB8();
    }
    return 111LL;
  }

  return v10;
}

void sub_1002223A0( _Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, char a13)
{
}

uint64_t sub_1002223BC(uint64_t a1, uint64_t a2, const void *a3, unsigned int a4)
{
  int v4 = (os_log_s *)qword_1008F7560;
  if (*(_BYTE *)(a1 + 328))
  {
    if (os_log_type_enabled((os_log_t)qword_1008F7560, OS_LOG_TYPE_DEFAULT))
    {
      sub_1003D0100(a2, (uint64_t)__p);
      uint64_t v8 = v13 >= 0 ? __p : (void **)__p[0];
      *(_DWORD *)__int128 buf = 67109635;
      unsigned int v15 = a4;
      __int16 v16 = 2160;
      uint64_t v17 = 1752392040LL;
      __int16 v18 = 2081;
      int v19 = v8;
      _os_log_impl( (void *)&_mh_execute_header,  v4,  OS_LOG_TYPE_DEFAULT,  "sendConversationDetectMessage: Sending CD Message of length %u to %{private, mask.hash}s",  buf,  0x1Cu);
      if (v13 < 0) {
        operator delete(__p[0]);
      }
    }

    buf[0] = 0;
    sub_100242CA4(buf);
    uint64_t v9 = sub_100080E78((unsigned __int8 *)(a2 + 128), a3, a4);
    sub_100242CD0(buf);
    if ((_DWORD)v9 && os_log_type_enabled((os_log_t)qword_1008F7560, OS_LOG_TYPE_ERROR)) {
      sub_100660070();
    }
    if (qword_1008D60B0 != -1) {
      dispatch_once(&qword_1008D60B0, &stru_100888AF0);
    }
    uint64_t v10 = sub_1004317E0((uint64_t)off_1008D60A8, v9, 10000);
    sub_100242CD8(buf);
  }

  else
  {
    if (os_log_type_enabled((os_log_t)qword_1008F7560, OS_LOG_TYPE_ERROR)) {
      sub_100660044();
    }
    return 111LL;
  }

  return v10;
}

void sub_100222584( _Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, char a13)
{
}

uint64_t sub_1002225A0(uint64_t a1, uint64_t a2, uint64_t a3)
{
  unsigned __int8 v3 = (os_log_s *)qword_1008F7560;
  if (*(_BYTE *)(a1 + 328))
  {
    if (os_log_type_enabled((os_log_t)qword_1008F7560, OS_LOG_TYPE_DEFAULT))
    {
      sub_1003D0100(a2, (uint64_t)__p);
      uint64_t v6 = v12 >= 0 ? __p : (void **)__p[0];
      *(_DWORD *)__int128 buf = 134218499;
      uint64_t v14 = a3;
      __int16 v15 = 2160;
      uint64_t v16 = 1752392040LL;
      __int16 v17 = 2081;
      __int16 v18 = v6;
      _os_log_impl( (void *)&_mh_execute_header,  v3,  OS_LOG_TYPE_DEFAULT,  "sendFeatureProxCardStatusUpdate: Sending prox card status bitmask 0x%02llX to %{private, mask.hash}s",  buf,  0x20u);
      if (v12 < 0) {
        operator delete(__p[0]);
      }
    }

    uint64_t v7 = sub_1003D1EC8(a2);
    sub_1003D1E58(a2, v7 | a3);
    buf[0] = 0;
    sub_100242CA4(buf);
    uint64_t v8 = sub_10008148C((unsigned __int8 *)(a2 + 128), a3);
    sub_100242CD0(buf);
    if ((_DWORD)v8 && os_log_type_enabled((os_log_t)qword_1008F7560, OS_LOG_TYPE_ERROR)) {
      sub_1006600FC();
    }
    if (qword_1008D60B0 != -1) {
      dispatch_once(&qword_1008D60B0, &stru_100888AF0);
    }
    uint64_t v9 = sub_1004317E0((uint64_t)off_1008D60A8, v8, 10000);
    sub_100242CD8(buf);
  }

  else
  {
    if (os_log_type_enabled((os_log_t)qword_1008F7560, OS_LOG_TYPE_ERROR)) {
      sub_1006600D0();
    }
    return 111LL;
  }

  return v9;
}

void sub_100222774(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, ...)
{
}

uint64_t sub_100222790(uint64_t a1, uint64_t a2, unsigned int a3, const void *a4)
{
  int v4 = (os_log_s *)qword_1008F7560;
  if (*(_BYTE *)(a1 + 328))
  {
    if (os_log_type_enabled((os_log_t)qword_1008F7560, OS_LOG_TYPE_DEFAULT))
    {
      sub_1003D0100(a2, (uint64_t)__p);
      uint64_t v8 = v13 >= 0 ? __p : (void **)__p[0];
      *(_DWORD *)__int128 buf = 67109635;
      unsigned int v15 = a3;
      __int16 v16 = 2160;
      uint64_t v17 = 1752392040LL;
      __int16 v18 = 2081;
      int v19 = v8;
      _os_log_impl( (void *)&_mh_execute_header,  v4,  OS_LOG_TYPE_DEFAULT,  "sendSourceContextMessage: Sending source context message of length %u to %{private, mask.hash}s",  buf,  0x1Cu);
      if (v13 < 0) {
        operator delete(__p[0]);
      }
    }

    buf[0] = 0;
    sub_100242CA4(buf);
    uint64_t v9 = sub_100081534((unsigned __int8 *)(a2 + 128), a3, a4);
    sub_100242CD0(buf);
    if ((_DWORD)v9 && os_log_type_enabled((os_log_t)qword_1008F7560, OS_LOG_TYPE_ERROR)) {
      sub_100660188();
    }
    if (qword_1008D60B0 != -1) {
      dispatch_once(&qword_1008D60B0, &stru_100888AF0);
    }
    uint64_t v10 = sub_1004317E0((uint64_t)off_1008D60A8, v9, 10000);
    sub_100242CD8(buf);
  }

  else
  {
    if (os_log_type_enabled((os_log_t)qword_1008F7560, OS_LOG_TYPE_ERROR)) {
      sub_10066015C();
    }
    return 111LL;
  }

  return v10;
}

void sub_100222958( _Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, char a13)
{
}

uint64_t sub_100222974(uint64_t a1, uint64_t a2, unsigned int a3, unsigned __int8 *a4)
{
  if (*(_BYTE *)(a1 + 328))
  {
    v14[0] = 0LL;
    v14[1] = 0LL;
    sub_100242F28((uint64_t)v14, a1 + 360);
    if (a2)
    {
      for (uint64_t i = *(void ***)(a1 + 336); i != *(void ***)(a1 + 344); ++i)
      {
        if (**i == a2)
        {
          v16[0] = 0;
          sub_100242CA4(v16);
          uint64_t v11 = sub_100081150((unsigned __int8 *)(a2 + 128), a3, a4);
          sub_100242CD0(v16);
          char v12 = (os_log_s *)qword_1008F7560;
          if ((_DWORD)v11)
          {
            if (os_log_type_enabled((os_log_t)qword_1008F7560, OS_LOG_TYPE_ERROR)) {
              sub_100660214();
            }
          }

          else if (os_log_type_enabled((os_log_t)qword_1008F7560, OS_LOG_TYPE_DEFAULT))
          {
            int v13 = *a4;
            *(_DWORD *)__int128 buf = 67109120;
            *(_DWORD *)&uint8_t buf[4] = v13;
            _os_log_impl( (void *)&_mh_execute_header,  v12,  OS_LOG_TYPE_DEFAULT,  "sendAdaptiveVolumeMessage: message sent of subtype %u",  buf,  8u);
          }

          if (qword_1008D60B0 != -1) {
            dispatch_once(&qword_1008D60B0, &stru_100888AF0);
          }
          uint64_t v9 = sub_1004317E0((uint64_t)off_1008D60A8, v11, 10000);
          sub_100242CD8(v16);
          goto LABEL_10;
        }
      }
    }

    if (os_log_type_enabled((os_log_t)qword_1008F7560, OS_LOG_TYPE_ERROR))
    {
      sub_1003CF00C(a2, buf);
      sub_10065F954();
    }

    uint64_t v9 = 312LL;
LABEL_10:
    sub_100242FAC((uint64_t)v14);
  }

  else
  {
    if (os_log_type_enabled((os_log_t)qword_1008F7560, OS_LOG_TYPE_ERROR)) {
      sub_1006601E8();
    }
    return 111LL;
  }

  return v9;
}

void sub_100222B74( _Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9)
{
}

uint64_t sub_100222BA4(uint64_t a1, uint64_t a2, unsigned int a3, unsigned __int8 *a4)
{
  if (*(_BYTE *)(a1 + 328))
  {
    v14[0] = 0LL;
    v14[1] = 0LL;
    sub_100242F28((uint64_t)v14, a1 + 360);
    if (a2)
    {
      for (uint64_t i = *(void ***)(a1 + 336); i != *(void ***)(a1 + 344); ++i)
      {
        if (**i == a2)
        {
          v16[0] = 0;
          sub_100242CA4(v16);
          uint64_t v11 = sub_100081694((unsigned __int8 *)(a2 + 128), a3, a4);
          sub_100242CD0(v16);
          char v12 = (os_log_s *)qword_1008F7560;
          if ((_DWORD)v11)
          {
            if (os_log_type_enabled((os_log_t)qword_1008F7560, OS_LOG_TYPE_ERROR)) {
              sub_1006602A0();
            }
          }

          else if (os_log_type_enabled((os_log_t)qword_1008F7560, OS_LOG_TYPE_DEFAULT))
          {
            int v13 = *a4;
            *(_DWORD *)__int128 buf = 67109120;
            *(_DWORD *)&uint8_t buf[4] = v13;
            _os_log_impl( (void *)&_mh_execute_header,  v12,  OS_LOG_TYPE_DEFAULT,  "sendPMEConfigMessage: message sent of subtype %u",  buf,  8u);
          }

          if (qword_1008D60B0 != -1) {
            dispatch_once(&qword_1008D60B0, &stru_100888AF0);
          }
          uint64_t v9 = sub_1004317E0((uint64_t)off_1008D60A8, v11, 10000);
          sub_100242CD8(v16);
          goto LABEL_10;
        }
      }
    }

    if (os_log_type_enabled((os_log_t)qword_1008F7560, OS_LOG_TYPE_ERROR))
    {
      sub_1003CF00C(a2, buf);
      sub_10065F954();
    }

    uint64_t v9 = 312LL;
LABEL_10:
    sub_100242FAC((uint64_t)v14);
  }

  else
  {
    if (os_log_type_enabled((os_log_t)qword_1008F7560, OS_LOG_TYPE_ERROR)) {
      sub_100660274();
    }
    return 111LL;
  }

  return v9;
}

void sub_100222DA4( _Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9)
{
}

uint64_t sub_100222DD4(uint64_t a1, uint64_t a2, unsigned int a3, const void *a4)
{
  if (*(_BYTE *)(a1 + 328))
  {
    v13[0] = 0LL;
    v13[1] = 0LL;
    sub_100242F28((uint64_t)v13, a1 + 360);
    if (a2)
    {
      for (uint64_t i = *(void ***)(a1 + 336); i != *(void ***)(a1 + 344); ++i)
      {
        if (**i == a2)
        {
          LOBYTE(v12[0]) = 0;
          sub_100242CA4(v12);
          uint64_t v11 = sub_100081284((unsigned __int8 *)(a2 + 128), a3, a4);
          sub_100242CD0(v12);
          if ((_DWORD)v11 && os_log_type_enabled((os_log_t)qword_1008F7560, OS_LOG_TYPE_ERROR)) {
            sub_10066032C();
          }
          if (qword_1008D60B0 != -1) {
            dispatch_once(&qword_1008D60B0, &stru_100888AF0);
          }
          uint64_t v9 = sub_1004317E0((uint64_t)off_1008D60A8, v11, 10000);
          sub_100242CD8(v12);
          goto LABEL_10;
        }
      }
    }

    if (os_log_type_enabled((os_log_t)qword_1008F7560, OS_LOG_TYPE_ERROR))
    {
      sub_1003CF00C(a2, v12);
      sub_10065F954();
    }

    uint64_t v9 = 312LL;
LABEL_10:
    sub_100242FAC((uint64_t)v13);
  }

  else
  {
    if (os_log_type_enabled((os_log_t)qword_1008F7560, OS_LOG_TYPE_ERROR)) {
      sub_100660300();
    }
    return 111LL;
  }

  return v9;
}

void sub_100222F8C(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, ...)
{
}

id sub_100222FBC(uint64_t a1, unsigned int a2)
{
  char v2 = a2;
  unsigned __int8 v3 = (void *)objc_claimAutoreleasedReturnValue( +[NSString stringWithFormat:]( &OBJC_CLASS___NSString,  "stringWithFormat:",  @"%d%c%d",  (a2 >> 20) & 0xF,  (HIWORD(a2) & 0xF) + 65,  (unsigned __int16)a2 >> 4));
  if ((v2 & 0xF) != 0)
  {
    uint64_t v4 = [NSString stringWithFormat:@"%@%c" v3, v2 & 0xF | 0x60u];

    unsigned __int8 v3 = (void *)v4;
  }

  return v3;
}

void sub_100223050(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

uint64_t sub_100223060(uint64_t a1, uint64_t a2)
{
  if (qword_1008D5F50 != -1) {
    dispatch_once(&qword_1008D5F50, &stru_100888BF0);
  }
  LODWORD(__p[0]) = *(_DWORD *)a2;
  WORD2(__p[0]) = *(_WORD *)(a2 + 4);
  uint64_t v4 = sub_1003FFEB0(off_1008D5F48, (uint64_t)__p, 1);
  uint64_t v5 = (os_log_s *)qword_1008F7560;
  if (os_log_type_enabled((os_log_t)qword_1008F7560, OS_LOG_TYPE_DEFAULT))
  {
    sub_1003D0100((uint64_t)v4, (uint64_t)__p);
    int v6 = v19;
    uint64_t v7 = (void **)__p[0];
    uint64_t v15 = sub_1001EDE10(a2, v8, v9, v10, v11, v12, v13, v14);
    __int16 v16 = __p;
    if (v6 < 0) {
      __int16 v16 = v7;
    }
    *(_DWORD *)__int128 buf = 136315394;
    id v21 = v16;
    __int16 v22 = 2080;
    uint64_t v23 = v15;
    _os_log_impl( (void *)&_mh_execute_header,  v5,  OS_LOG_TYPE_DEFAULT,  "AACP Connection attempt by device %s, addr %s,",  buf,  0x16u);
    if (v19 < 0) {
      operator delete(__p[0]);
    }
  }

  return sub_100410910(a1, (uint64_t)v4, 1);
}

void sub_1002231B8( _Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void *__p, uint64_t a11, int a12, __int16 a13, char a14, char a15)
{
  if (a15 < 0) {
    operator delete(__p);
  }
  _Unwind_Resume(exception_object);
}

void sub_1002231DC(void *a1, uint64_t a2, int a3, uint64_t a4)
{
  if (qword_1008D5F50 != -1) {
    dispatch_once(&qword_1008D5F50, &stru_100888BF0);
  }
  *(_DWORD *)std::string __p = *(_DWORD *)a2;
  *(_WORD *)&__p[4] = *(_WORD *)(a2 + 4);
  uint64_t v8 = (unsigned __int8 *)sub_1003FFEB0(off_1008D5F48, (uint64_t)__p, 1);
  uint64_t v9 = (os_log_s *)qword_1008F7560;
  BOOL v10 = os_log_type_enabled((os_log_t)qword_1008F7560, OS_LOG_TYPE_DEFAULT);
  if ((_DWORD)a4)
  {
    if (v10)
    {
      sub_1003D0100((uint64_t)v8, (uint64_t)__p);
      uint64_t v11 = v31 >= 0 ? __p : *(_BYTE **)__p;
      *(_DWORD *)int v24 = 136315394;
      *(void *)&void v24[4] = v11;
      __int16 v25 = 1024;
      int v26 = a4;
      _os_log_impl( (void *)&_mh_execute_header,  v9,  OS_LOG_TYPE_DEFAULT,  "connection to device %s failed... reason %d",  v24,  0x12u);
      if (SHIBYTE(v31) < 0) {
        operator delete(*(void **)__p);
      }
    }

    if (qword_1008D60B0 != -1) {
      dispatch_once(&qword_1008D60B0, &stru_100888AF0);
    }
    int v12 = sub_1004317E0((uint64_t)off_1008D60A8, a4, 20000);
    sub_100410A5C((uint64_t)a1, (uint64_t)v8, v12);
  }

  else
  {
    if (v10)
    {
      sub_1003D0100((uint64_t)v8, (uint64_t)v24);
      int v13 = v27;
      uint64_t v14 = *(_BYTE **)v24;
      uint64_t v22 = sub_1001EDE10(a2, v15, v16, v17, v18, v19, v20, v21);
      uint64_t v23 = v24;
      *(_DWORD *)std::string __p = 136315906;
      if (v13 < 0) {
        uint64_t v23 = v14;
      }
      *(void *)&__p[4] = v23;
      __int16 v29 = 2080;
      uint64_t v30 = v22;
      __int16 v31 = 1024;
      int v32 = a3;
      __int16 v33 = 1024;
      int v34 = 0;
      _os_log_impl( (void *)&_mh_execute_header,  v9,  OS_LOG_TYPE_DEFAULT,  "Connection succeeded to device %s, addr %s, mtu %d, result %d",  __p,  0x22u);
      if (v27 < 0) {
        operator delete(*(void **)v24);
      }
    }

    sub_100410A5C((uint64_t)a1, (uint64_t)v8, 0);
    sub_10021C920(a1, v8, 1, 1);
  }

void sub_100223434( _Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, void *__p, uint64_t a10, int a11, __int16 a12, char a13, char a14)
{
  if (a14 < 0) {
    operator delete(__p);
  }
  _Unwind_Resume(exception_object);
}

void sub_100223458(void *a1, unsigned __int8 *a2, int a3)
{
  unint64_t v5 = ((unint64_t)*a2 << 40) | ((unint64_t)a2[1] << 32) | ((unint64_t)a2[2] << 24) | ((unint64_t)a2[3] << 16) | ((unint64_t)a2[4] << 8) | a2[5];
  if (qword_1008D5F50 != -1) {
    dispatch_once(&qword_1008D5F50, &stru_100888BF0);
  }
  int v6 = sub_10040007C(off_1008D5F48, v5, 1);
  if (v6)
  {
    uint64_t v7 = (uint64_t)v6;
    sub_1003DF238((uint64_t)v6, 0);
    v17[0] = 0LL;
    v17[1] = 0LL;
    sub_100242F28((uint64_t)v17, (uint64_t)(a1 + 45));
    for (uint64_t i = (uint64_t **)a1[42]; i != (uint64_t **)a1[43]; ++i)
    {
      uint64_t v9 = *i;
      if (**i == v7) {
        goto LABEL_9;
      }
    }

    uint64_t v9 = 0LL;
LABEL_9:
    BOOL v10 = (os_log_s *)qword_1008F7560;
    if (os_log_type_enabled((os_log_t)qword_1008F7560, OS_LOG_TYPE_DEFAULT)
      && ((sub_1003D0100(v7, (uint64_t)__p), v16 >= 0) ? (uint64_t v11 = __p) : (uint64_t v11 = (void **)__p[0]),
          *(_DWORD *)__int128 buf = 136315394,
          uint64_t v19 = v11,
          __int16 v20 = 1024,
          int v21 = a3,
          _os_log_impl( (void *)&_mh_execute_header,  v10,  OS_LOG_TYPE_DEFAULT,  "disconnecting %s, reason = %d",  buf,  0x12u),  v16 < 0))
    {
      operator delete(__p[0]);
      if (v9)
      {
LABEL_15:
        if ((*(unsigned int (**)(uint64_t))(*(void *)v9[96] + 176LL))(v9[96]) == 1)
        {
          sub_100411718((uint64_t)a1, v7, 0, a3);
          sub_100223724(a1, v9);
        }

void sub_100223700( _Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, ...)
{
}

void sub_100223724(void *a1, uint64_t *a2)
{
  uint64_t v4 = (char *)a1[42];
  unint64_t v5 = (char *)a1[43];
  int v6 = v4;
  if (v4 != v5)
  {
    while ((uint64_t *)*v6 != a2)
    {
      if (++v6 == (void *)v5)
      {
        int v6 = (void *)a1[43];
        break;
      }
    }
  }

  if (v6 != (void *)v5)
  {
    uint64_t v7 = *a2;
    int64_t v8 = v5 - (char *)(v6 + 1);
    a1[43] = (char *)v6 + v8;
    sub_100234EFC(a2);
    sub_10023078C(v9, (uint64_t)a2);
    sub_100232018(v10, (uint64_t)a2);
    if (qword_1008D67D8 != -1) {
      dispatch_once(&qword_1008D67D8, &stru_100888C90);
    }
    sub_1003569E8(qword_1008D67D0, v7 + 128);
    uint64_t v11 = (void *)sub_100235808((uint64_t)a2);
    operator delete(v11);
    uint64_t v4 = (char *)a1[42];
    unint64_t v5 = (char *)a1[43];
  }

  if (v4 == v5)
  {
    if (qword_1008D5F50 != -1) {
      dispatch_once(&qword_1008D5F50, &stru_100888BF0);
    }
    sub_100009168((uint64_t)off_1008D5F48 + 240, (uint64_t)(a1 + 34));
    uint64_t v12 = a1[61];
    a1[61] = 0LL;
    if (v12) {
      (*(void (**)(uint64_t))(*(void *)v12 + 64LL))(v12);
    }
  }

void sub_100223878(uint64_t *a1)
{
  if (sub_10021AF3C(a1[4], a1[5]))
  {
    v9[0] = 0LL;
    v9[1] = 0LL;
    uint64_t v10 = 0LL;
    id v2 = sub_1005BF848(a1[6]);
    id v3 = objc_claimAutoreleasedReturnValue(v2);
    sub_10002418C(v9, (char *)[v3 UTF8String]);

    uint64_t v4 = (os_log_s *)qword_1008F7560;
    if (os_log_type_enabled((os_log_t)qword_1008F7560, OS_LOG_TYPE_DEFAULT))
    {
      unint64_t v5 = v9;
      if (v10 < 0) {
        unint64_t v5 = (void **)v9[0];
      }
      *(_DWORD *)__int128 buf = 136315138;
      uint64_t v12 = v5;
      _os_log_impl( (void *)&_mh_execute_header,  v4,  OS_LOG_TYPE_DEFAULT,  "Notifying Phone/Watch of unexpected disconnection from device addr %s",  buf,  0xCu);
    }

    uint64_t v6 = sub_1002E8F6C();
    if (SHIBYTE(v10) < 0)
    {
      sub_100024238(__p, v9[0], (unint64_t)v9[1]);
    }

    else
    {
      *(_OWORD *)std::string __p = *(_OWORD *)v9;
      uint64_t v8 = v10;
    }

    (*(void (**)(uint64_t, void **))(*(void *)v6 + 136LL))(v6, __p);
    if (SHIBYTE(v8) < 0) {
      operator delete(__p[0]);
    }
    if (SHIBYTE(v10) < 0) {
      operator delete(v9[0]);
    }
  }

void sub_1002239D0( _Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, void *__p, uint64_t a10, int a11, __int16 a12, char a13, char a14, void *a15, uint64_t a16, int a17, __int16 a18, char a19, char a20)
{
  if (a14 < 0) {
    operator delete(__p);
  }
  if (a20 < 0) {
    operator delete(a15);
  }
  _Unwind_Resume(exception_object);
}

uint64_t sub_100223A1C(uint64_t result, uint64_t a2, int a3, __int16 a4)
{
  if (a3 == 30 && (a4 & 0x8000) == 0)
  {
    uint64_t v5 = result;
    v7[0] = 0LL;
    v7[1] = 0LL;
    sub_100242F28((uint64_t)v7, result + 360);
    uint64_t v6 = sub_100223ABC(v5, a2);
    if (v6)
    {
      sub_100223B00(v6);
    }

    else if (os_log_type_enabled((os_log_t)qword_1008F7560, OS_LOG_TYPE_ERROR))
    {
      sub_100660464();
    }

    return sub_100242FAC((uint64_t)v7);
  }

  return result;
}

void sub_100223AA8( _Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9)
{
}

uint64_t *sub_100223ABC(uint64_t a1, uint64_t a2)
{
  if (a2)
  {
    id v2 = *(uint64_t ***)(a1 + 336);
    id v3 = *(uint64_t ***)(a1 + 344);
    while (v2 != v3)
    {
      uint64_t result = *v2;
      uint64_t v5 = **v2;
      int v6 = *(_DWORD *)(v5 + 128);
      int v7 = *(unsigned __int16 *)(v5 + 132);
      ++v2;
    }
  }

  return 0LL;
}

uint64_t sub_100223B00(void *a1)
{
  v24[0] = 0LL;
  v24[1] = 0LL;
  sub_100242F28((uint64_t)v24, (uint64_t)(a1 + 55));
  uint64_t v2 = a1[54];
  if (!v2)
  {
LABEL_17:
    uint64_t v13 = (os_log_s *)qword_1008F7560;
    if (os_log_type_enabled((os_log_t)qword_1008F7560, OS_LOG_TYPE_INFO))
    {
      *(_WORD *)__int128 buf = 0;
      _os_log_impl( (void *)&_mh_execute_header,  v13,  OS_LOG_TYPE_INFO,  "sendEASessionPacket: No more packets to send",  buf,  2u);
    }

    return sub_100242FAC((uint64_t)v24);
  }

  while (1)
  {
    id v3 = (uint64_t *)a1[53];
    uint64_t v4 = (unsigned __int8 *)v3[2];
    uint64_t v5 = *v3;
    *(void *)(v5 + std::ostream::~ostream(v2, v3 + 8) = v3[1];
    *(void *)v3[1] = v5;
    a1[54] = v2 - 1;
    operator delete(v3);
    unint64_t v6 = *v4;
    if (v6 > 0x1F || (uint64_t v7 = a1[v6 + 20]) == 0 || !*(_BYTE *)(v7 + 97))
    {
      uint64_t v11 = (os_log_s *)qword_1008F7560;
      if (os_log_type_enabled((os_log_t)qword_1008F7560, OS_LOG_TYPE_ERROR)) {
        sub_100660490(&v22, v23, v11);
      }
      uint64_t v12 = (void *)*((void *)v4 + 1);
      if (v12) {
        operator delete[](v12);
      }
      operator delete(v4);
      goto LABEL_16;
    }

    char v21 = 0;
    sub_100242CA4(&v21);
    int v8 = sub_10007FEA0((unsigned __int8 *)(*a1 + 128LL), *v4, *((unsigned __int16 *)v4 + 1), *((const void **)v4 + 1));
    sub_100242CD0(&v21);
    if (!v8) {
      break;
    }
    uint64_t v9 = (os_log_s *)qword_1008F7560;
    if (os_log_type_enabled((os_log_t)qword_1008F7560, OS_LOG_TYPE_ERROR))
    {
      *(_DWORD *)__int128 buf = 67109120;
      int v26 = v8;
      _os_log_error_impl((void *)&_mh_execute_header, v9, OS_LOG_TYPE_ERROR, "sendEASessionPacket: error %d", buf, 8u);
    }

    uint64_t v10 = (void *)*((void *)v4 + 1);
    if (v10) {
      operator delete[](v10);
    }
    operator delete(v4);
    sub_100242CD8(&v21);
LABEL_16:
    uint64_t v2 = a1[54];
    if (!v2) {
      goto LABEL_17;
    }
  }

  if (*((unsigned __int16 *)v4 + 1) >= 3u)
  {
    uint64_t v15 = (os_log_s *)qword_1008F7560;
    if (os_log_type_enabled((os_log_t)qword_1008F7560, OS_LOG_TYPE_DEFAULT))
    {
      char v16 = (unsigned __int8 *)*((void *)v4 + 1);
      int v17 = *v16;
      int v18 = v16[1];
      LODWORD(v16) = v16[2];
      uint64_t v19 = a1[54];
      *(_DWORD *)__int128 buf = 67109888;
      int v26 = v17;
      __int16 v27 = 1024;
      int v28 = v18;
      __int16 v29 = 1024;
      int v30 = (int)v16;
      __int16 v31 = 2048;
      uint64_t v32 = v19;
      _os_log_impl( (void *)&_mh_execute_header,  v15,  OS_LOG_TYPE_DEFAULT,  "sendEASessionPacket: Packet start %02X %02X %02X; %lu remaining",
        buf,
        0x1Eu);
    }
  }

  __int16 v20 = (void *)*((void *)v4 + 1);
  if (v20) {
    operator delete[](v20);
  }
  operator delete(v4);
  sub_100242CD8(&v21);
  return sub_100242FAC((uint64_t)v24);
}

void sub_100223DB0( _Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, ...)
{
}

void sub_100223DDC(uint64_t a1, _DWORD *a2, _BYTE *a3)
{
  int v4 = sub_100219328(a1, a2);
  uint64_t v5 = (os_log_s *)qword_1008F7560;
  BOOL v6 = os_log_type_enabled((os_log_t)qword_1008F7560, OS_LOG_TYPE_DEFAULT);
  if (v4)
  {
    if (v6)
    {
      int v7 = *a3;
      v8[0] = 67109120;
      v8[1] = v7;
      _os_log_impl( (void *)&_mh_execute_header,  v5,  OS_LOG_TYPE_DEFAULT,  "GAPA device remove all %d AACP capabilities",  (uint8_t *)v8,  8u);
    }

    *a3 = 0;
  }

  else if (v6)
  {
    LOWORD(v8[0]) = 0;
    _os_log_impl( (void *)&_mh_execute_header,  v5,  OS_LOG_TYPE_DEFAULT,  "GAPA device remove limited AACP capabilities",  (uint8_t *)v8,  2u);
  }

uint64_t sub_100223EC8(uint64_t a1, uint64_t a2, unsigned __int8 a3, uint64_t a4)
{
  unsigned __int8 v49 = a3;
  v48[0] = 0LL;
  v48[1] = 0LL;
  sub_100242F28((uint64_t)v48, a1 + 360);
  if (qword_1008D5F50 != -1) {
    dispatch_once(&qword_1008D5F50, &stru_100888BF0);
  }
  *(_DWORD *)__int16 v50 = *(_DWORD *)a2;
  *(_WORD *)&v50[4] = *(_WORD *)(a2 + 4);
  int v7 = sub_1003FFEB0(off_1008D5F48, (uint64_t)v50, 1);
  int v8 = sub_100223ABC(a1, a2);
  if (v7 && v8)
  {
    uint64_t v44 = (uint64_t)v8;
    uint64_t v9 = sub_1003D8484((uint64_t)v7);
    if ((v9 & 2) != 0) {
      sub_100223DDC(v9, v7, &v49);
    }
    uint64_t v10 = (os_log_s *)qword_1008F7560;
    BOOL v11 = os_log_type_enabled((os_log_t)qword_1008F7560, OS_LOG_TYPE_DEFAULT);
    if (v11)
    {
      sub_1003CF00C((uint64_t)v7, v50);
      if (v55 >= 0) {
        uint64_t v12 = v50;
      }
      else {
        uint64_t v12 = *(uint8_t **)v50;
      }
      unsigned int v13 = v49;
      *(_DWORD *)__int128 buf = 136446466;
      uint64_t v57 = v12;
      __int16 v58 = 1024;
      int v59 = v49;
      _os_log_impl( (void *)&_mh_execute_header,  v10,  OS_LOG_TYPE_DEFAULT,  "capabilitiesResponseEvent: device %{public}s response: numCaps = %d",  buf,  0x12u);
      if (v55 < 0) {
        operator delete(*(void **)v50);
      }
    }

    else
    {
      unsigned int v13 = v49;
    }

    if (v13)
    {
      unint64_t v14 = 0LL;
      char v45 = 0;
      unint64_t v15 = v13;
      char v16 = (int *)(a4 + 1);
      while (1)
      {
        unsigned int v17 = *((unsigned __int8 *)v16 - 1);
        if (v17 <= 0x3F)
        {
          switch(*((_BYTE *)v16 - 1))
          {
            case 1:
            case 2:
              int v18 = *(unsigned __int8 *)v16;
              break;
            case 4:
              int v18 = *v16;
              break;
            case 5:
            case 6:
            case 7:
            case 0x30:
              int v18 = *v16;
              goto LABEL_39;
            case 8:
              int v18 = *v16;
              if ((*v16 & 1) != 0) {
                *(_BYTE *)(v44 + 152) = 1;
              }
              goto LABEL_19;
            case 9:
            case 0xC:
            case 0xF:
            case 0x11:
            case 0x12:
            case 0x14:
              goto LABEL_18;
            case 0xA:
              int v18 = *(unsigned __int8 *)v16;
              if ((v18 & 1) != 0)
              {
                if (qword_1008D6458 != -1) {
                  dispatch_once(&qword_1008D6458, &stru_100888B90);
                }
                sub_100378460((void *)qword_1008D6450, (uint64_t)v7);
              }

              goto LABEL_19;
            case 0xB:
              int v18 = *(unsigned __int8 *)v16;
              if ((v18 & 1) != 0)
              {
                uint64_t v21 = sub_100405058();
                v47[0] = _NSConcreteStackBlock;
                v47[1] = 3221225472LL;
                v47[2] = sub_100224978;
                v47[3] = &unk_10087EB20;
                v47[4] = v7;
                sub_100405384(v21, v47);
              }

              goto LABEL_19;
            case 0xD:
              int v18 = *(unsigned __int8 *)v16;
              if ((v18 & 1) != 0)
              {
                uint64_t v22 = sub_100405058();
                v46[0] = _NSConcreteStackBlock;
                v46[1] = 3221225472LL;
                v46[2] = sub_1002249CC;
                v46[3] = &unk_10087EB20;
                v46[4] = v7;
                sub_100405384(v22, v46);
              }

              goto LABEL_19;
            case 0x10:
              int v18 = *(unsigned __int8 *)v16;
              if (*(_BYTE *)v16)
              {
                uint64_t v23 = (os_log_s *)qword_1008F7560;
                if (os_log_type_enabled((os_log_t)qword_1008F7560, OS_LOG_TYPE_DEFAULT))
                {
                  sub_1003CF00C((uint64_t)v7, v50);
                  int v24 = v55 >= 0 ? v50 : *(uint8_t **)v50;
                  *(_DWORD *)__int128 buf = 136446210;
                  uint64_t v57 = v24;
                  _os_log_impl( (void *)&_mh_execute_header,  v23,  OS_LOG_TYPE_DEFAULT,  "capabilitiesResponseEvent: Requested case information from device %{public}s",  buf,  0xCu);
                  if (v55 < 0) {
                    operator delete(*(void **)v50);
                  }
                }

                sub_10021C660(a1, (uint64_t)v7);
              }

              char v45 = 1;
              goto LABEL_19;
            case 0x13:
              int v18 = *(unsigned __int8 *)v16;
              int v25 = _os_feature_enabled_impl("AudioAccessoryFeatures", "AllowListeningModeOff");
              if (v18 == 1) {
                int v26 = v25;
              }
              else {
                int v26 = 0;
              }
              if (v26 == 1)
              {
                if (sub_1003E0350((uint64_t)v7, 0x13u))
                {
                  int v18 = 1;
                }

                else
                {
                  uint64_t v36 = sub_1003E0054((uint64_t)v7);
                  int v18 = 1;
                  sub_100215778(a1, (uint64_t)v7, 52LL, v36, 1u);
                }
              }

              goto LABEL_39;
            case 0x15:
            case 0x16:
            case 0x17:
            case 0x18:
              goto LABEL_38;
            case 0x20:
              int v18 = *(unsigned __int8 *)v16;
              if ((v18 & 1) != 0)
              {
                if (qword_1008D6458 != -1) {
                  dispatch_once(&qword_1008D6458, &stru_100888B90);
                }
                sub_100378498((void *)qword_1008D6450, (uint64_t)v7, 1);
              }

              goto LABEL_19;
            default:
              goto LABEL_104;
          }

          goto LABEL_40;
        }

        if (*((unsigned __int8 *)v16 - 1) <= 0x9Fu)
        {
          if (*((unsigned __int8 *)v16 - 1) <= 0x5Fu)
          {
            if (v17 == 64)
            {
LABEL_18:
              int v18 = *(unsigned __int8 *)v16;
            }

            else
            {
              if (v17 != 80) {
                goto LABEL_104;
              }
              int v18 = *(unsigned __int8 *)v16;
              if (v18 == 2)
              {
                if (qword_1008D6458 != -1) {
                  dispatch_once(&qword_1008D6458, &stru_100888B90);
                }
                sub_1003786EC((void *)qword_1008D6450, (uint64_t)v7, 1);
                int v18 = 2;
              }
            }
          }

          else
          {
            switch(v17)
            {
              case 0x60u:
                goto LABEL_38;
              case 0x80u:
                int v18 = *(unsigned __int8 *)v16;
                if ((v18 & 1) != 0)
                {
                  __int16 v29 = (os_log_s *)qword_1008F7560;
                  if (os_log_type_enabled((os_log_t)qword_1008F7560, OS_LOG_TYPE_DEFAULT))
                  {
                    sub_1003CF00C((uint64_t)v7, v50);
                    int v30 = v50;
                    if (v55 < 0) {
                      int v30 = *(uint8_t **)v50;
                    }
                    *(_DWORD *)__int128 buf = 136446210;
                    uint64_t v57 = v30;
                    _os_log_impl( (void *)&_mh_execute_header,  v29,  OS_LOG_TYPE_DEFAULT,  "capabilitiesResponseEvent: Setting double click & click and hold intervals for device %{public}s",  buf,  0xCu);
                    if (v55 < 0) {
                      operator delete(*(void **)v50);
                    }
                  }

                  if ((sub_1003D2B2C((uint64_t)v7, 29) & 1) == 0 && (sub_1003D2B2C((uint64_t)v7, 43) & 1) == 0)
                  {
                    uint64_t v31 = sub_1003DFC14((uint64_t)v7);
                    sub_100215778(a1, (uint64_t)v7, 23LL, v31, 1u);
                  }

                  if ((sub_1003D2B2C((uint64_t)v7, 30) & 1) == 0 && (sub_1003D2B2C((uint64_t)v7, 43) & 1) == 0)
                  {
                    uint64_t v32 = sub_1003DFC58((uint64_t)v7);
                    sub_100215778(a1, (uint64_t)v7, 24LL, v32, 1u);
                  }
                }

                break;
              case 0x90u:
                int v18 = *(unsigned __int8 *)v16;
                if ((v18 & 1) != 0)
                {
                  if (qword_1008D6458 != -1) {
                    dispatch_once(&qword_1008D6458, &stru_100888B90);
                  }
                  sub_100378618((void *)qword_1008D6450, (uint64_t)v7, 1);
                }

                break;
              default:
                goto LABEL_104;
            }
          }
        }

        else
        {
          if (*((unsigned __int8 *)v16 - 1) > 0xCFu)
          {
            if (v17 == 208)
            {
              int v18 = *(unsigned __int8 *)v16;
              sub_1003DF588((uint64_t)v7, 208, *(_BYTE *)v16 != 0);
            }

            else
            {
              if (v17 != 224 && v17 != 240)
              {
LABEL_104:
                __int16 v33 = (os_log_s *)qword_1008F7560;
                if (os_log_type_enabled((os_log_t)qword_1008F7560, OS_LOG_TYPE_DEFAULT))
                {
                  sub_1003CF00C((uint64_t)v7, v50);
                  int v34 = v50;
                  if (v55 < 0) {
                    int v34 = *(uint8_t **)v50;
                  }
                  int v35 = *((unsigned __int8 *)v16 - 1);
                  *(_DWORD *)__int128 buf = 136446466;
                  uint64_t v57 = v34;
                  __int16 v58 = 1024;
                  int v59 = v35;
                  _os_log_impl( (void *)&_mh_execute_header,  v33,  OS_LOG_TYPE_DEFAULT,  "Warning: capabilitiesResponseEvent: device %{public}s unexpected response capId = %d",  buf,  0x12u);
                  if (v55 < 0) {
                    operator delete(*(void **)v50);
                  }
                }

                int v18 = 0;
                goto LABEL_40;
              }

void sub_10022487C( _Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20, uint64_t a21, uint64_t a22, uint64_t a23, uint64_t a24, uint64_t a25, uint64_t a26, uint64_t a27, uint64_t a28, uint64_t a29, uint64_t a30, uint64_t a31, char a32)
{
}

uint64_t sub_100224978(uint64_t a1)
{
  if (qword_1008D9030 != -1) {
    dispatch_once(&qword_1008D9030, &stru_100888D10);
  }
  return sub_10046018C((uint64_t)off_1008D9028, *(void *)(a1 + 32), 1);
}

uint64_t sub_1002249CC(uint64_t a1)
{
  if (qword_1008D9030 != -1) {
    dispatch_once(&qword_1008D9030, &stru_100888D10);
  }
  return sub_100460214((uint64_t)off_1008D9028, *(void *)(a1 + 32), 1);
}

uint64_t sub_100224A20(uint64_t a1, uint64_t a2)
{
  if (qword_1008D5F40 != -1) {
    dispatch_once(&qword_1008D5F40, &stru_100888BB0);
  }
  sub_1003B375C((uint64_t)off_1008D5F38, a2);
  uint64_t result = sub_1003E0230(a2, 64);
  if ((_DWORD)result)
  {
    int v4 = (os_log_s *)qword_1008F7560;
    if (os_log_type_enabled((os_log_t)qword_1008F7560, OS_LOG_TYPE_DEFAULT))
    {
      LOWORD(__p[0]) = 0;
      _os_log_impl((void *)&_mh_execute_header, v4, OS_LOG_TYPE_DEFAULT, "Setting up spatial audio", (uint8_t *)__p, 2u);
    }

    if (qword_1008D6458 != -1) {
      dispatch_once(&qword_1008D6458, &stru_100888B90);
    }
    sub_100378754((void *)qword_1008D6450, a2, 1);
    char v11 = 0;
    if (qword_1008D5F50 != -1) {
      dispatch_once(&qword_1008D5F50, &stru_100888BF0);
    }
    uint64_t result = sub_100401058((uint64_t)off_1008D5F48);
    if ((_DWORD)result)
    {
      uint64_t v5 = sub_1002E6D7C();
      uint64_t result = (*(uint64_t (**)(uint64_t, uint64_t, char *))(*(void *)v5 + 1208LL))(v5, a2, &v11);
      if ((_DWORD)result)
      {
        BOOL v6 = (os_log_s *)qword_1008F7560;
        if (os_log_type_enabled((os_log_t)qword_1008F7560, OS_LOG_TYPE_DEFAULT))
        {
          sub_1003CF00C(a2, __p);
          if (v10 >= 0) {
            int v7 = __p;
          }
          else {
            int v7 = (void **)__p[0];
          }
          *(_DWORD *)__int128 buf = 136446210;
          unsigned int v13 = v7;
          _os_log_impl( (void *)&_mh_execute_header,  v6,  OS_LOG_TYPE_DEFAULT,  "Initialize spatial audio to true for %{public}s",  buf,  0xCu);
          if (v10 < 0) {
            operator delete(__p[0]);
          }
        }

        CFPreferencesSetAppValue( @"spatial-audio-accessory-feature",  kCFBooleanTrue,  @"com.apple.springboard");
        CFPreferencesAppSynchronize(@"com.apple.springboard");
        uint64_t v8 = sub_1002E6D7C();
        return (*(uint64_t (**)(uint64_t, uint64_t, uint64_t))(*(void *)v8 + 1216LL))(v8, a2, 1LL);
      }
    }
  }

  return result;
}

void sub_100224C5C(uint64_t a1, uint64_t a2, int a3, int a4)
{
  if (!a2)
  {
    if (os_log_type_enabled((os_log_t)qword_1008F7560, OS_LOG_TYPE_ERROR)) {
      sub_1006604C4();
    }
    return;
  }

  unsigned int v5 = *(_DWORD *)(a2 + 80) - 8194;
  BOOL v6 = v5 > 0xE;
  int v7 = (1 << v5) & 0x409B;
  if (!v6 && v7 != 0) {
    return;
  }
  uint64_t v91 = *(void *)a2;
  if (!*(void *)a2) {
    return;
  }
  if (!*(void *)(a2 + 128))
  {
    sub_1003FE1B4((unsigned __int8 *)(v91 + 128), keys);
    if (SHIBYTE(keys[2]) >= 0) {
      unsigned int v17 = keys;
    }
    else {
      unsigned int v17 = (void **)keys[0];
    }
    CFStringRef v18 = CFStringCreateWithCString(kCFAllocatorDefault, (const char *)v17, 0x8000100u);
    if (SHIBYTE(keys[2]) < 0) {
      operator delete(keys[0]);
    }
    if (!v18)
    {
      uint64_t v74 = (os_log_s *)qword_1008F7560;
      if (os_log_type_enabled((os_log_t)qword_1008F7560, OS_LOG_TYPE_ERROR)) {
        sub_1006604F0(v91, v74);
      }
      return;
    }

    uint64_t Connection = acc_transportClient_createConnection(2LL, v18);
    if (!Connection)
    {
      unsigned int v75 = (os_log_s *)qword_1008F7560;
      if (os_log_type_enabled((os_log_t)qword_1008F7560, OS_LOG_TYPE_ERROR)) {
        sub_100660578(v91, v75);
      }
      CFRelease(v18);
      return;
    }

    *(void *)(a2 + 12std::ostream::~ostream(v2, v3 + 8) = Connection;
    CFRelease(v18);
  }

  if (*(_BYTE *)(a2 + 152))
  {
    uint64_t v10 = 0LL;
    while (1)
    {
      uint64_t v11 = *(void *)(a2 + 160 + v10);
      if (v11)
      {
        CFNullRef v12 = *(CFNullRef *)(v11 + 24);
        if (v12) {
          break;
        }
      }

      v10 += 8LL;
      if (v10 == 256)
      {
        if (os_log_type_enabled((os_log_t)qword_1008F7560, OS_LOG_TYPE_ERROR)) {
          sub_100660778();
        }
        CFNullRef v12 = kCFNull;
        break;
      }
    }

    uint64_t v13 = *(void *)(a2 + 128);
    v101[0] = _NSConcreteStackBlock;
    v101[1] = 3221225472LL;
    v101[2] = sub_100230B44;
    v101[3] = &unk_1008880A0;
    v101[4] = a1;
    v101[5] = v91;
    uint64_t Endpoint = acc_transportClient_createEndpoint(v13, 2LL, 9LL, v12, v101, 0LL);
    unint64_t v15 = (os_log_s *)qword_1008F7560;
    if (Endpoint)
    {
      if (os_log_type_enabled((os_log_t)qword_1008F7560, OS_LOG_TYPE_DEFAULT))
      {
        sub_1003CF00C(v91, keys);
        char v16 = SHIBYTE(keys[2]) >= 0 ? keys : (void **)keys[0];
        *(_DWORD *)__int128 buf = 136446466;
        *(void *)&uint8_t buf[4] = v16;
        *(_WORD *)&_BYTE buf[12] = 2112;
        *(void *)&_BYTE buf[14] = Endpoint;
        _os_log_impl( (void *)&_mh_execute_header,  v15,  OS_LOG_TYPE_DEFAULT,  "publishAccRemoteFirmware: device %{public}s endpoint = %@",  buf,  0x16u);
        if (SHIBYTE(keys[2]) < 0) {
          operator delete(keys[0]);
        }
      }

      *(void *)(a2 + 136) = Endpoint;
      *(_BYTE *)(a2 + 152) = 0;
    }

    else if (os_log_type_enabled((os_log_t)qword_1008F7560, OS_LOG_TYPE_ERROR))
    {
      sub_1006606F0(v91, v15);
    }
  }

  uint64_t v20 = 0LL;
  uint64_t v89 = kCFACCProperties_Endpoint_EA_SessionOpen;
  __int16 v87 = (void *)kCFACCInfo_Name;
  uint64_t v86 = (void *)kCFACCInfo_Manufacturer;
  char v85 = (void *)kCFACCInfo_Model;
  char v84 = (void *)kCFACCInfo_SerialNumber;
  uint64_t v83 = kCFACCInfo_HardwareVersion;
  uint64_t v21 = kCFACCInfo_FirmwareVersionActive;
  uint64_t v22 = kCFACCInfo_FirmwareVersionPending;
  uint64_t v23 = kCFACCProperties_Endpoint_EA_MatchAction;
  while (1)
  {
    int v24 = *(void **)(a2 + 8 * v20 + 160);
    if (v24)
    {
      if (!v24[11]) {
        break;
      }
    }

void sub_100225C70( _Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20, uint64_t a21, uint64_t a22, void *a23)
{
  _Unwind_Resume(a1);
}

void sub_100225D24(uint64_t a1, uint64_t a2, int a3, unsigned __int8 *a4)
{
  LODWORD(v5) = a3;
  if (qword_1008D5F50 != -1) {
    dispatch_once(&qword_1008D5F50, &stru_100888BF0);
  }
  LODWORD(__p[0]) = *(_DWORD *)a2;
  WORD2(__p[0]) = *(_WORD *)(a2 + 4);
  uint64_t v8 = sub_1003FFEB0(off_1008D5F48, (uint64_t)__p, 1);
  if (v8)
  {
    v18[0] = 0LL;
    v18[1] = 0LL;
    sub_100242F28((uint64_t)v18, a1 + 360);
    uint64_t v9 = *(uint64_t ***)(a1 + 336);
    uint64_t v10 = *(uint64_t ***)(a1 + 344);
    while (v9 != v10)
    {
      uint64_t v11 = *v9;
      if ((void *)**v9 == v8)
      {
        uint64_t v13 = (os_log_s *)qword_1008F7560;
        if (os_log_type_enabled((os_log_t)qword_1008F7560, OS_LOG_TYPE_DEFAULT))
        {
          sub_1003D0100((uint64_t)v8, (uint64_t)__p);
          unint64_t v14 = v17 >= 0 ? __p : (void **)__p[0];
          *(_DWORD *)__int128 buf = 136315394;
          uint64_t v20 = v14;
          __int16 v21 = 1024;
          int v22 = v5;
          _os_log_impl( (void *)&_mh_execute_header,  v13,  OS_LOG_TYPE_DEFAULT,  "received battery info from device %s num reports = %d",  buf,  0x12u);
          if (v17 < 0) {
            operator delete(__p[0]);
          }
        }

        if ((_DWORD)v5)
        {
          uint64_t v5 = v5;
          do
          {
            unsigned int v15 = a4[3] - 5;
            if (v15 >= 0xFFFFFFFE) {
              sub_100225F64((uint64_t)v11, *a4);
            }
            sub_10022612C(v11, a4, v15 < 0xFFFFFFFE);
            a4 += 5;
            --v5;
          }

          while (v5);
        }

        goto LABEL_23;
      }

      ++v9;
    }

    if (os_log_type_enabled((os_log_t)qword_1008F7560, OS_LOG_TYPE_ERROR)) {
      sub_10066082C();
    }
LABEL_23:
    sub_100242FAC((uint64_t)v18);
  }

  else
  {
    CFNullRef v12 = (os_log_s *)qword_1008F7560;
    if (os_log_type_enabled((os_log_t)qword_1008F7560, OS_LOG_TYPE_ERROR)) {
      sub_1006607A4(v12);
    }
  }

void sub_100225F40(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, ...)
{
}

void sub_100225F64(uint64_t a1, unsigned int a2)
{
  int v4 = (os_log_s *)qword_1008F7560;
  if (os_log_type_enabled((os_log_t)qword_1008F7560, OS_LOG_TYPE_DEFAULT))
  {
    sub_1002359E8(a2, __p);
    uint64_t v5 = v18 >= 0 ? __p : (void **)__p[0];
    *(_DWORD *)__int128 buf = 136446210;
    uint64_t v20 = v5;
    _os_log_impl((void *)&_mh_execute_header, v4, OS_LOG_TYPE_DEFAULT, "destroy battery info %{public}s", buf, 0xCu);
    if (v18 < 0) {
      operator delete(__p[0]);
    }
  }

  uint64_t v8 = *(void *)(a1 + 32);
  uint64_t v7 = a1 + 32;
  uint64_t v6 = v8;
  if (v8)
  {
    uint64_t v9 = (uint64_t **)(v7 - 8);
    uint64_t v10 = v7;
    do
    {
      unsigned int v11 = *(unsigned __int8 *)(v6 + 32);
      BOOL v12 = v11 >= a2;
      if (v11 >= a2) {
        uint64_t v13 = (uint64_t *)v6;
      }
      else {
        uint64_t v13 = (uint64_t *)(v6 + 8);
      }
      if (v12) {
        uint64_t v10 = v6;
      }
      uint64_t v6 = *v13;
    }

    while (*v13);
    if (v10 != v7 && *(unsigned __int8 *)(v10 + 32) <= a2)
    {
      uint64_t v14 = *(void *)(v10 + 40);
      if (v14)
      {
        unsigned int v15 = (os_log_s *)qword_1008F7560;
        if (os_log_type_enabled((os_log_t)qword_1008F7560, OS_LOG_TYPE_DEFAULT))
        {
          sub_1002359E8(a2, __p);
          if (v18 >= 0) {
            char v16 = __p;
          }
          else {
            char v16 = (void **)__p[0];
          }
          *(_DWORD *)__int128 buf = 136315138;
          uint64_t v20 = v16;
          _os_log_impl( (void *)&_mh_execute_header,  v15,  OS_LOG_TYPE_DEFAULT,  "battery instance for %s found. Destroying...",  buf,  0xCu);
          if (v18 < 0) {
            operator delete(__p[0]);
          }
        }

        (*(void (**)(uint64_t))(*(void *)v14 + 8LL))(v14);
      }

      sub_1001FDBCC(v9, (uint64_t *)v10);
      operator delete((void *)v10);
    }
  }

uint64_t sub_10022612C(uint64_t *a1, unsigned __int8 *a2, int a3)
{
  uint64_t v6 = a1[4];
  uint64_t v7 = (uint64_t **)(a1 + 3);
  if (v6)
  {
    unsigned int v8 = *a2;
    uint64_t v9 = a1 + 4;
    do
    {
      unsigned int v10 = *(unsigned __int8 *)(v6 + 32);
      BOOL v11 = v10 >= v8;
      if (v10 >= v8) {
        BOOL v12 = (uint64_t *)v6;
      }
      else {
        BOOL v12 = (uint64_t *)(v6 + 8);
      }
      if (v11) {
        uint64_t v9 = (uint64_t *)v6;
      }
      uint64_t v6 = *v12;
    }

    while (*v12);
    if (v9 != a1 + 4 && v8 >= *((unsigned __int8 *)v9 + 32))
    {
      CFDictionaryRef v34 = (os_log_s *)qword_1008F7560;
      if (os_log_type_enabled((os_log_t)qword_1008F7560, OS_LOG_TYPE_DEFAULT))
      {
        sub_1002359E8(v8, __p);
        if (v65 >= 0) {
          CFNumberRef v35 = __p;
        }
        else {
          CFNumberRef v35 = (void **)__p[0];
        }
        int v36 = a2[2];
        uint64_t v37 = "No";
        if (a2[3] == 1) {
          uint64_t v38 = "Yes";
        }
        else {
          uint64_t v38 = "No";
        }
        if (!a2[3]) {
          uint64_t v37 = "Yes";
        }
        *(_DWORD *)__int128 buf = 136446978;
        *(void *)&uint8_t buf[4] = v35;
        *(_WORD *)&_BYTE buf[12] = 1024;
        *(_DWORD *)&_BYTE buf[14] = v36;
        *(_WORD *)&buf[18] = 2080;
        *(void *)&buf[20] = v38;
        __int16 v67 = 2082;
        __int128 v68 = (void *)v37;
        _os_log_impl( (void *)&_mh_execute_header,  v34,  OS_LOG_TYPE_DEFAULT,  "Update Battery for %{public}s battery, battery level %d, charging = %s fully charged = %{public}s",  buf,  0x26u);
        if (v65 < 0) {
          operator delete(__p[0]);
        }
      }

      uint64_t v39 = v9[5];
      if (!v39)
      {
        int v41 = 0;
LABEL_103:
        uint64_t v32 = v41 != 0;
        goto LABEL_104;
      }

      (*(void (**)(uint64_t, void))(*(void *)v39 + 48LL))(v9[5], a2[2]);
      if (a2[3]) {
        uint64_t v40 = a2[3] == 1;
      }
      else {
        uint64_t v40 = 2LL;
      }
      (*(void (**)(uint64_t, uint64_t))(*(void *)v39 + 64LL))(v39, v40);
      sub_100235A1C(a1, *a2, buf);
      if ((buf[23] & 0x80000000) != 0)
      {
        uint64_t v42 = *(void *)&buf[8];
        operator delete(*(void **)buf);
        if (!v42) {
          goto LABEL_74;
        }
      }

      else if (!buf[23])
      {
LABEL_74:
        int v41 = 0;
        unint64_t v44 = a2[3];
        if (v44 >= 3) {
          unsigned __int8 v45 = 0;
        }
        else {
          unsigned __int8 v45 = 0x20103u >> (8 * v44);
        }
        int v46 = *a2;
        switch(*a2)
        {
          case 1u:
            int v47 = sub_1003D7EB4((unsigned int *)*a1, 1);
            unsigned int v48 = a2[2];
            if (v47 == v48) {
              goto LABEL_88;
            }
            sub_1003D8258(*a1, v48, 1);
            goto LABEL_90;
          case 2u:
            int v51 = sub_1003D7EB4((unsigned int *)*a1, 2);
            unsigned int v52 = a2[2];
            if (v51 == v52) {
              goto LABEL_88;
            }
            sub_1003D8258(*a1, v52, 2);
            goto LABEL_90;
          case 3u:
          case 5u:
          case 6u:
          case 7u:
            goto LABEL_93;
          case 4u:
            int v53 = sub_1003D7EB4((unsigned int *)*a1, 4);
            unsigned int v54 = a2[2];
            if (v53 == v54) {
              goto LABEL_88;
            }
            sub_1003D8258(*a1, v54, 4);
            goto LABEL_90;
          case 8u:
            int v55 = sub_1003D7EB4((unsigned int *)*a1, 8);
            unsigned int v56 = a2[2];
            if (v55 == v56) {
              goto LABEL_88;
            }
            sub_1003D8258(*a1, v56, 8);
            goto LABEL_90;
          default:
            if (v46 != 16) {
              goto LABEL_93;
            }
            int v49 = sub_1003D7EB4((unsigned int *)*a1, 16);
            unsigned int v50 = a2[2];
            if (v49 == v50)
            {
LABEL_88:
              int v41 = 0;
            }

            else
            {
              sub_1003D8258(*a1, v50, 16);
LABEL_90:
              int v41 = 1;
            }

LABEL_104:
  memset(buf, 0, 24);
  int v59 = a2[3];
  sub_10040CB88((uint64_t)buf, 3, 0LL);
  *(_DWORD *)&uint8_t buf[16] = v59;
  uint64_t v60 = sub_1002E8D94();
  (*(void (**)(uint64_t, _BYTE *))(*(void *)v60 + 56LL))(v60, buf);
  return v32;
}

void sub_100226994( _Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, void *__p, uint64_t a16, int a17, __int16 a18, char a19, char a20)
{
  if (a20 < 0) {
    operator delete(__p);
  }
  _Unwind_Resume(exception_object);
}

void sub_1002269E0(uint64_t a1, uint64_t a2, unsigned __int8 *a3)
{
  if (qword_1008D5F50 != -1) {
    dispatch_once(&qword_1008D5F50, &stru_100888BF0);
  }
  *(_DWORD *)__int128 buf = *(_DWORD *)a2;
  *(_WORD *)&uint8_t buf[4] = *(_WORD *)(a2 + 4);
  uint64_t v6 = sub_1003FFEB0(off_1008D5F48, (uint64_t)buf, 1);
  if (v6)
  {
    v28[0] = 0LL;
    v28[1] = 0LL;
    sub_100242F28((uint64_t)v28, a1 + 360);
    for (uint64_t i = *(unsigned __int8 ***)(a1 + 336); i != *(unsigned __int8 ***)(a1 + 344); ++i)
    {
      unsigned int v8 = *i;
      if (*(void **)*i == v6)
      {
        uint64_t v10 = sub_1003DF944((uint64_t)v6);
        if ((v10 & 1) != 0)
        {
          uint64_t v11 = sub_10021F3A8(v10, *a3);
          int v12 = v11;
          int v13 = sub_10021F3A8(v11, a3[1]);
          int v14 = v8[10];
          if (v14 == 1) {
            int v15 = 2;
          }
          else {
            int v15 = 1;
          }
          char v16 = (os_log_s *)qword_1008F7560;
          if (os_log_type_enabled((os_log_t)qword_1008F7560, OS_LOG_TYPE_DEFAULT))
          {
            sub_1003CF00C((uint64_t)v6, __p);
            char v18 = v30 >= 0 ? __p : *(_BYTE **)__p;
            uint64_t v19 = sub_10021F3CC(v17, v12);
            uint64_t v20 = sub_10021F3CC((uint64_t)v19, v13);
            *(_DWORD *)__int128 buf = 136446722;
            *(void *)&uint8_t buf[4] = v18;
            *(_WORD *)&_BYTE buf[12] = 2082;
            *(void *)&_BYTE buf[14] = v19;
            *(_WORD *)&_BYTE buf[22] = 2082;
            uint64_t v32 = v20;
            _os_log_impl( (void *)&_mh_execute_header,  v16,  OS_LOG_TYPE_DEFAULT,  "received in-ear state update from device %{public}s primary bud state = %{public}s, secondary bud state = %{public}s",  buf,  0x20u);
            if (v30 < 0) {
              operator delete(*(void **)__p);
            }
          }

          int v21 = v8[8];
          BOOL v22 = v12 != v21;
          if (v12 != v21)
          {
            v8[8] = v12;
            memset(buf, 0, sizeof(buf));
            sub_10040CB88((uint64_t)buf, 2, (uint64_t)v6);
            *(_DWORD *)&uint8_t buf[16] = v14;
            *(_DWORD *)&buf[20] = v12;
            uint64_t v23 = sub_1002E8D94();
            (*(void (**)(uint64_t, uint8_t *))(*(void *)v23 + 56LL))(v23, buf);
          }

          if (v13 != v8[9])
          {
            v8[9] = v13;
            memset(buf, 0, sizeof(buf));
            sub_10040CB88((uint64_t)buf, 2, (uint64_t)v6);
            *(_DWORD *)&uint8_t buf[16] = v15;
            *(_DWORD *)&buf[20] = v13;
            uint64_t v24 = sub_1002E8D94();
            (*(void (**)(uint64_t, uint8_t *))(*(void *)v24 + 56LL))(v24, buf);
            BOOL v22 = 1;
          }

          sub_100242F54((uint64_t)v28);
          if (v22) {
            sub_10021E798(v25, (uint64_t)v6);
          }
        }

        else
        {
          uint64_t v26 = (os_log_s *)qword_1008F7560;
          if (os_log_type_enabled((os_log_t)qword_1008F7560, OS_LOG_TYPE_DEFAULT))
          {
            sub_1003CF00C((uint64_t)v6, buf);
            unsigned int v27 = (buf[23] & 0x80u) == 0 ? buf : *(uint8_t **)buf;
            *(_DWORD *)std::string __p = 136446210;
            *(void *)&__p[4] = v27;
            _os_log_impl( (void *)&_mh_execute_header,  v26,  OS_LOG_TYPE_DEFAULT,  "Ignoring in-ear status update from device %{public}s that's disabled for tracking in-ear detection",  __p,  0xCu);
          }
        }

        goto LABEL_10;
      }
    }

    if (os_log_type_enabled((os_log_t)qword_1008F7560, OS_LOG_TYPE_ERROR)) {
      sub_1006608E0();
    }
LABEL_10:
    sub_100242FAC((uint64_t)v28);
  }

  else
  {
    uint64_t v9 = (os_log_s *)qword_1008F7560;
    if (os_log_type_enabled((os_log_t)qword_1008F7560, OS_LOG_TYPE_ERROR)) {
      sub_100660858(v9);
    }
  }

void sub_100226D34( _Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9)
{
}

void sub_100226D60(uint64_t a1, uint64_t a2, unsigned __int8 *a3)
{
  if (qword_1008D5F50 != -1) {
    dispatch_once(&qword_1008D5F50, &stru_100888BF0);
  }
  *(_DWORD *)__int128 buf = *(_DWORD *)a2;
  *(_WORD *)&uint8_t buf[4] = *(_WORD *)(a2 + 4);
  uint64_t v6 = (unsigned __int8 *)sub_1003FFEB0(off_1008D5F48, (uint64_t)buf, 1);
  if (v6)
  {
    v58[0] = 0LL;
    v58[1] = 0LL;
    sub_100242F28((uint64_t)v58, a1 + 360);
    uint64_t v7 = *(void ****)(a1 + 336);
    unsigned int v8 = *(void ****)(a1 + 344);
    if (v7 == v8)
    {
LABEL_7:
      if (os_log_type_enabled((os_log_t)qword_1008F7560, OS_LOG_TYPE_ERROR)) {
        sub_100660994();
      }
    }

    else
    {
      while (1)
      {
        uint64_t v9 = *v7;
        if (**v7 == v6) {
          break;
        }
        if (++v7 == v8) {
          goto LABEL_7;
        }
      }

      int v11 = *a3;
      if (v11 == 2) {
        int v12 = 2;
      }
      else {
        int v12 = 3;
      }
      if (v11 == 1) {
        int v13 = 1;
      }
      else {
        int v13 = v12;
      }
      int v14 = (os_log_s *)qword_1008F7560;
      if (os_log_type_enabled((os_log_t)qword_1008F7560, OS_LOG_TYPE_DEFAULT))
      {
        sub_1003CF00C((uint64_t)v6, __p);
        if (v60 >= 0) {
          int v15 = __p;
        }
        else {
          int v15 = *(_BYTE **)__p;
        }
        char v16 = "unknown";
        else {
          uint64_t v17 = v16;
        }
        char v18 = "Yes";
        int v19 = *(unsigned __int8 *)(a1 + 430);
        int v20 = a3[3];
        BOOL v21 = a3[2] == 0;
        *(_DWORD *)__int128 buf = 136447234;
        *(void *)&uint8_t buf[4] = v15;
        BOOL v22 = "not";
        if (v21) {
          char v18 = "No";
        }
        if (v19) {
          BOOL v22 = "is";
        }
        *(_WORD *)&_BYTE buf[12] = 2082;
        *(void *)int v62 = v17;
        uint64_t v23 = "disabled";
        *(_WORD *)&v62[8] = 2082;
        uint64_t v63 = v18;
        __int16 v64 = 2082;
        char v65 = v22;
        if (v20) {
          uint64_t v23 = "enabled";
        }
        __int16 v66 = 2082;
        __int16 v67 = v23;
        _os_log_impl( (void *)&_mh_execute_header,  v14,  OS_LOG_TYPE_DEFAULT,  "received role state from device %{public}s, primary bud side is %{public}s, secondary connected = %{public }s, magnet %{public}s connected, quickdisconnect %{public}s",  buf,  0x34u);
        if (v60 < 0) {
          operator delete(*(void **)__p);
        }
      }

      int v24 = *((unsigned __int8 *)v9 + 10);
      BOOL v25 = v13 != v24;
      if (v13 != v24) {
        *((_BYTE *)v9 + 10) = v13;
      }
      if (!a3[2] && sub_1003DF944((uint64_t)v6) && *((_BYTE *)v9 + 9) != 3)
      {
        *((_BYTE *)v9 + 9) = 3;
        BOOL v25 = 1;
      }

      sub_100242F54((uint64_t)v58);
      if (v25)
      {
        sub_10021E798(v26, (uint64_t)v6);
        if (sub_10021AF3C(a1, (uint64_t)v6))
        {
          unsigned int v27 = (os_log_s *)qword_1008F7560;
          if (os_log_type_enabled((os_log_t)qword_1008F7560, OS_LOG_TYPE_DEFAULT))
          {
            sub_1003FE1B4(v6 + 128, buf);
            unint64_t v28 = v62[9] >= 0 ? buf : *(_BYTE **)buf;
            *(_DWORD *)std::string __p = 67109378;
            *(_DWORD *)&__p[4] = v13;
            *(_WORD *)&__p[8] = 2082;
            *(void *)&__p[10] = v28;
            _os_log_impl( (void *)&_mh_execute_header,  v27,  OS_LOG_TYPE_DEFAULT,  "Sending current primary bud side as %d to other end of magnet link for device %{public}s",  __p,  0x12u);
            if ((v62[9] & 0x80000000) != 0) {
              operator delete(*(void **)buf);
            }
          }

          uint64_t v29 = sub_1002E8F6C();
          char v30 = v6 + 128;
          sub_1003FE1B4(v6 + 128, v56);
          (*(void (**)(uint64_t, void **, void))(*(void *)v29 + 144LL))(v29, v56, v13);
          if (v57 < 0) {
            operator delete(v56[0]);
          }
          BOOL v31 = (os_log_s *)qword_1008F7560;
          if (os_log_type_enabled((os_log_t)qword_1008F7560, OS_LOG_TYPE_DEFAULT))
          {
            int v32 = *((unsigned __int8 *)v9 + 11);
            int v33 = *((unsigned __int8 *)v9 + 9);
            *(_DWORD *)__int128 buf = 67109632;
            *(_DWORD *)&uint8_t buf[4] = v32;
            *(_WORD *)&uint8_t buf[8] = 1024;
            *(_DWORD *)&buf[10] = v13;
            *(_WORD *)int v62 = 1024;
            *(_DWORD *)&v62[2] = v33;
            _os_log_impl( (void *)&_mh_execute_header,  v31,  OS_LOG_TYPE_DEFAULT,  "Primary bud info over magnet link before -> %d, primary bud info from Headset -> %d, current connection se condary bud in ear status -> %d",  buf,  0x14u);
          }

          uint64_t v34 = sub_1002E6BF0();
          if (!(*(unsigned int (**)(uint64_t))(*(void *)v34 + 344LL))(v34)
            || (int v35 = *((unsigned __int8 *)v9 + 11), v35 == 3)
            || v13 == v35
            || *((_BYTE *)v9 + 9) != 3)
          {
            if (sub_10021B43C((uint64_t)v9))
            {
              int v41 = (os_log_s *)qword_1008F7560;
              if (os_log_type_enabled((os_log_t)qword_1008F7560, OS_LOG_TYPE_DEFAULT))
              {
                if (*((_BYTE *)v9 + 617)) {
                  int v49 = (char *)v9 + 611;
                }
                else {
                  int v49 = (char *)v9 + 605;
                }
                *(_DWORD *)std::string __p = *(_DWORD *)v49;
                *(_WORD *)&__p[4] = *((_WORD *)v49 + 2);
                uint64_t v50 = sub_1001EDE10((uint64_t)__p, v42, v43, v44, v45, v46, v47, v48);
                *(_DWORD *)__int128 buf = 136446210;
                *(void *)&uint8_t buf[4] = v50;
                _os_log_impl( (void *)&_mh_execute_header,  v41,  OS_LOG_TYPE_DEFAULT,  "Peer source %{public}s is currently connected in TiPi, skip connection stealing",  buf,  0xCu);
              }
            }

            else if (a3[3] && sub_1002274D8((uint64_t)v9))
            {
              int v51 = (os_log_s *)qword_1008F7560;
              if (os_log_type_enabled((os_log_t)qword_1008F7560, OS_LOG_TYPE_DEFAULT))
              {
                sub_1003CF00C((uint64_t)v6, buf);
                unsigned int v52 = v62[9] >= 0 ? buf : *(_BYTE **)buf;
                *(_DWORD *)std::string __p = 136446210;
                *(void *)&__p[4] = v52;
                _os_log_impl( (void *)&_mh_execute_header,  v51,  OS_LOG_TYPE_DEFAULT,  "Sending message to Phone/Watch to connect to device %{public}s",  __p,  0xCu);
                if ((v62[9] & 0x80000000) != 0) {
                  operator delete(*(void **)buf);
                }
              }

              uint64_t v53 = sub_1002E8F6C();
              sub_1003FE1B4(v30, v54);
              (*(void (**)(uint64_t, void **, BOOL))(*(void *)v53 + 128LL))(v53, v54, a3[3] != 0);
              if (v55 < 0) {
                operator delete(v54[0]);
              }
            }
          }

          else
          {
            int v36 = (os_log_s *)qword_1008F7560;
            if (os_log_type_enabled((os_log_t)qword_1008F7560, OS_LOG_TYPE_DEFAULT))
            {
              sub_1003CF00C((uint64_t)v6, __p);
              uint64_t v37 = v60 >= 0 ? __p : *(_BYTE **)__p;
              int v38 = *((unsigned __int8 *)v9 + 11);
              *(_DWORD *)__int128 buf = 136446722;
              *(void *)&uint8_t buf[4] = v37;
              *(_WORD *)&_BYTE buf[12] = 1024;
              *(_DWORD *)int v62 = v38;
              *(_WORD *)&v62[4] = 1024;
              *(_DWORD *)&v62[6] = v13;
              _os_log_impl( (void *)&_mh_execute_header,  v36,  OS_LOG_TYPE_DEFAULT,  "Info update from Headset, Primary bud side  for device %{public}s seen locally is different from that of companion, we see  %d, and companion sees %d. Requesting connected Bud to be secondary",  buf,  0x18u);
              if (v60 < 0) {
                operator delete(*(void **)__p);
              }
            }

            sub_100215778(a1, (uint64_t)v6, 8LL, 2LL, 1u);
            uint64_t v39 = (os_log_s *)qword_1008F7560;
            if (os_log_type_enabled((os_log_t)qword_1008F7560, OS_LOG_TYPE_DEFAULT))
            {
              sub_1003CF00C((uint64_t)v6, buf);
              uint64_t v40 = v62[9] >= 0 ? buf : *(_BYTE **)buf;
              *(_DWORD *)std::string __p = 136446210;
              *(void *)&__p[4] = v40;
              _os_log_impl( (void *)&_mh_execute_header,  v39,  OS_LOG_TYPE_DEFAULT,  "Schedule reconnection to W1 device after LSTO (5 seconds) on Gizmo, device : %{public}s",  __p,  0xCu);
              if ((v62[9] & 0x80000000) != 0) {
                operator delete(*(void **)buf);
              }
            }

            *(_DWORD *)__int128 buf = *(_DWORD *)v30;
            *(_WORD *)&uint8_t buf[4] = *((_WORD *)v6 + 66);
            if (qword_1008D60D0 != -1) {
              dispatch_once(&qword_1008D60D0, &stru_100888C50);
            }
            sub_1004271D4((uint64_t)off_1008D60C8, buf);
          }
        }
      }
    }

    sub_100242FAC((uint64_t)v58);
  }

  else
  {
    uint64_t v10 = (os_log_s *)qword_1008F7560;
    if (os_log_type_enabled((os_log_t)qword_1008F7560, OS_LOG_TYPE_ERROR)) {
      sub_10066090C(v10);
    }
  }

void sub_100227474( _Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, void *__p, uint64_t a10, int a11, __int16 a12, char a13, char a14, uint64_t a15, uint64_t a16, int a17, __int16 a18, char a19, char a20, char a21)
{
}

BOOL sub_1002274D8(uint64_t a1)
{
  uint64_t v2 = sub_1002E6BF0();
  if (qword_1008D60E0 != -1) {
    dispatch_once(&qword_1008D60E0, &stru_100888C10);
  }
  return !*((_BYTE *)off_1008D60D8 + 520) && !sub_10021B43C(a1) && sub_1003DF988(*(void *)a1) != 1;
}

void *sub_100227574(uint64_t a1, uint64_t a2, uint64_t a3, int a4)
{
  if (qword_1008D5F50 != -1) {
    dispatch_once(&qword_1008D5F50, &stru_100888BF0);
  }
  *(_DWORD *)__int128 buf = *(_DWORD *)a2;
  LOWORD(v30) = *(_WORD *)(a2 + 4);
  uint64_t result = sub_1003FFEB0(off_1008D5F48, (uint64_t)buf, 1);
  uint64_t v9 = (uint64_t)result;
  if (result)
  {
    v28[0] = 0LL;
    v28[1] = 0LL;
    sub_100242F28((uint64_t)v28, a1 + 360);
    for (uint64_t i = *(void **)(a1 + 336); i != *(void **)(a1 + 344); ++i)
    {
      int v11 = (void *)*i;
      if (*(void *)*i == v9) {
        goto LABEL_9;
      }
    }

    int v11 = 0LL;
LABEL_9:
    int v12 = (os_log_s *)qword_1008F7560;
    if (!os_log_type_enabled((os_log_t)qword_1008F7560, OS_LOG_TYPE_DEFAULT)) {
      goto LABEL_16;
    }
    int v13 = a4 == 1 ? "Pair success" : "Pair failed";
    sub_1003D0100(v9, (uint64_t)__p);
    int v14 = v27;
    int v15 = (void **)__p[0];
    uint64_t v23 = sub_1001EDE10(a3, v16, v17, v18, v19, v20, v21, v22);
    int v24 = __p;
    *(_DWORD *)__int128 buf = 136446722;
    if (v14 < 0) {
      int v24 = v15;
    }
    char v30 = v13;
    __int16 v31 = 2080;
    int v32 = v24;
    __int16 v33 = 2080;
    uint64_t v34 = v23;
    _os_log_impl( (void *)&_mh_execute_header,  v12,  OS_LOG_TYPE_DEFAULT,  "received easy pair response %{public}s from device %s, for address %s ",  buf,  0x20u);
    if (v27 < 0)
    {
      operator delete(__p[0]);
      if (v11)
      {
LABEL_17:
        uint64_t v25 = v11[6];
        if (v25)
        {
          *(_DWORD *)__int128 buf = *(_DWORD *)a2;
          LOWORD(v30) = *(_WORD *)(a2 + 4);
          LODWORD(__p[0]) = *(_DWORD *)a3;
          WORD2(__p[0]) = *(_WORD *)(a3 + 4);
          sub_100209E04(v25, (uint64_t)buf, (uint64_t)__p, a4 != 1);
        }
      }
    }

    else
    {
LABEL_16:
      if (v11) {
        goto LABEL_17;
      }
    }

    return (void *)sub_100242FAC((uint64_t)v28);
  }

  return result;
}

void sub_100227778( _Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void *__p, uint64_t a11, int a12, __int16 a13, char a14, char a15, char a16)
{
}

void *sub_1002277B0(uint64_t a1, uint64_t a2, unint64_t a3, int a4, int a5)
{
  if (qword_1008D5F50 != -1) {
    dispatch_once(&qword_1008D5F50, &stru_100888BF0);
  }
  uint64_t result = sub_10040007C(off_1008D5F48, a2, 1);
  if (result)
  {
    uint64_t v11 = (uint64_t)result;
    v29[0] = 0LL;
    v29[1] = 0LL;
    sub_100242F28((uint64_t)v29, a1 + 360);
    int v12 = *(void ***)(a1 + 336);
    int v13 = *(void ***)(a1 + 344);
    while (v12 != v13)
    {
      int v14 = *v12;
      if (**v12 == v11)
      {
        unint64_t v15 = sub_1001BEE0C(a3);
        int v36 = v15;
        __int16 v37 = WORD2(v15);
        uint64_t v16 = (os_log_s *)qword_1008F7560;
        if (os_log_type_enabled((os_log_t)qword_1008F7560, OS_LOG_TYPE_DEFAULT))
        {
          uint64_t v24 = sub_1001EDE10((uint64_t)&v36, v17, v18, v19, v20, v21, v22, v23);
          uint64_t v25 = "Connected";
          if (!a4) {
            uint64_t v25 = "Disconnected";
          }
          *(_DWORD *)__int128 buf = 136446722;
          uint64_t v31 = v24;
          __int16 v32 = 2082;
          __int16 v33 = v25;
          if (a5 == 1) {
            uint64_t v26 = "Source";
          }
          else {
            uint64_t v26 = "UTP";
          }
          __int16 v34 = 2082;
          int v35 = v26;
          _os_log_impl( (void *)&_mh_execute_header,  v16,  OS_LOG_TYPE_DEFAULT,  "Received connection state info : target addr = %{public}s, connState %{public}s, connType = %{public}s ",  buf,  0x20u);
        }

        if (a5 == 1)
        {
          v28[0] = BYTE5(a3);
          v28[1] = BYTE4(a3);
          void v28[2] = BYTE3(a3);
          v28[3] = BYTE2(a3);
          v28[4] = BYTE1(a3);
          void v28[5] = a3;
          sub_10021B100((uint64_t)v14, v28, a4);
          BOOL v27 = sub_10021B43C((uint64_t)v14);
          sub_10021B398(v27, v11, v27);
        }

        return (void *)sub_100242FAC((uint64_t)v29);
      }

      ++v12;
    }

    if (os_log_type_enabled((os_log_t)qword_1008F7560, OS_LOG_TYPE_ERROR))
    {
      sub_1003CF00C(v11, buf);
      sub_1006609C0();
    }

    return (void *)sub_100242FAC((uint64_t)v29);
  }

  return result;
}

void sub_1002279E4(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, ...)
{
}

void sub_100227A08(uint64_t a1, uint64_t a2, uint64_t a3, int a4)
{
  if (qword_1008D5F50 != -1) {
    dispatch_once(&qword_1008D5F50, &stru_100888BF0);
  }
  uint64_t v7 = sub_10040007C(off_1008D5F48, a2, 1);
  __p[0] = 0LL;
  __p[1] = 0LL;
  uint64_t v20 = 0LL;
  sub_10002418C(__p, "");
  if (a4 == 2)
  {
    sub_10002418C(v17, "streaming A2DP");
  }

  else if (a4 == 1)
  {
    sub_10002418C(v17, "streaming SCO");
  }

  else if (a4)
  {
    sub_10002418C(v17, "in unknown state");
  }

  else
  {
    sub_10002418C(v17, "stopped streaming");
  }

  if (SHIBYTE(v20) < 0) {
    operator delete(__p[0]);
  }
  *(_OWORD *)std::string __p = *(_OWORD *)v17;
  uint64_t v20 = v18;
  unsigned int v8 = (os_log_s *)qword_1008F7560;
  if (os_log_type_enabled((os_log_t)qword_1008F7560, OS_LOG_TYPE_DEFAULT))
  {
    sub_1003D0100((uint64_t)v7, (uint64_t)v17);
    if (v18 >= 0) {
      uint64_t v9 = v17;
    }
    else {
      uint64_t v9 = (void **)v17[0];
    }
    uint64_t v10 = __p;
    if (v20 < 0) {
      uint64_t v10 = (void **)__p[0];
    }
    *(_DWORD *)__int128 buf = 136315394;
    uint64_t v22 = v9;
    __int16 v23 = 2080;
    uint64_t v24 = v10;
    _os_log_impl( (void *)&_mh_execute_header,  v8,  OS_LOG_TYPE_DEFAULT,  "Received device %s stream state info: %s",  buf,  0x16u);
    if (SHIBYTE(v18) < 0) {
      operator delete(v17[0]);
    }
  }

  v16[0] = 0LL;
  v16[1] = 0LL;
  sub_100242F28((uint64_t)v16, a1 + 360);
  if (v7)
  {
    uint64_t v11 = *(void ****)(a1 + 336);
    int v12 = *(void ****)(a1 + 344);
    while (v11 != v12)
    {
      int v13 = *v11;
      if (**v11 == v7)
      {
        if (*((_DWORD *)v13 + 4) != a4)
        {
          if (qword_1008D5F40 != -1) {
            dispatch_once(&qword_1008D5F40, &stru_100888BB0);
          }
          sub_1003B268C((uint64_t)off_1008D5F38, (uint64_t)v7, a4);
        }

        char v14 = 0;
        *((_DWORD *)v13 + 4) = a4;
        goto LABEL_28;
      }

      ++v11;
    }
  }

  if (os_log_type_enabled((os_log_t)qword_1008F7560, OS_LOG_TYPE_ERROR))
  {
    sub_1003D0100((uint64_t)v7, (uint64_t)v17);
    sub_100660A58();
  }

  char v14 = 1;
LABEL_28:
  sub_100242F54((uint64_t)v16);
  if ((v14 & 1) != 0)
  {
    if (os_log_type_enabled((os_log_t)qword_1008F7560, OS_LOG_TYPE_ERROR))
    {
      sub_1003D0100((uint64_t)v7, (uint64_t)buf);
      sub_100660A0C();
    }
  }

  else
  {
    sub_100227D5C(v15, (uint64_t)v7, a4);
  }

  sub_100242FAC((uint64_t)v16);
  if (SHIBYTE(v20) < 0) {
    operator delete(__p[0]);
  }
}

void sub_100227D0C( _Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, char a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, void *__p, uint64_t a16, int a17, __int16 a18, char a19, char a20)
{
  if (a20 < 0) {
    operator delete(__p);
  }
  _Unwind_Resume(a1);
}

void sub_100227D5C(uint64_t a1, uint64_t a2, char a3)
{
  uint64_t v5 = (os_log_s *)qword_1008F7560;
  if (os_log_type_enabled((os_log_t)qword_1008F7560, OS_LOG_TYPE_INFO))
  {
    sub_1003D0100(a2, (uint64_t)__p);
    if (v14 >= 0) {
      uint64_t v6 = __p;
    }
    else {
      uint64_t v6 = (void **)__p[0];
    }
    *(_DWORD *)__int128 buf = 136315138;
    uint64_t v16 = v6;
    _os_log_impl( (void *)&_mh_execute_header,  v5,  OS_LOG_TYPE_INFO,  "Notify stream state change for device %s",  buf,  0xCu);
    if (v14 < 0) {
      operator delete(__p[0]);
    }
  }

  uint64_t v7 = sub_100405058();
  v11[0] = _NSConcreteStackBlock;
  v11[1] = 3221225472LL;
  void v11[2] = sub_10023522C;
  void v11[3] = &unk_1008800D8;
  void v11[4] = a2;
  char v12 = a3;
  sub_100405384(v7, v11);
  uint64_t v8 = sub_1004050C8();
  v9[0] = _NSConcreteStackBlock;
  v9[1] = 3221225472LL;
  void v9[2] = sub_100235280;
  void v9[3] = &unk_1008800D8;
  void v9[4] = a2;
  char v10 = a3;
  sub_100405384(v8, v9);
}

unsigned __int8 *sub_100227EA8(uint64_t a1, uint64_t a2, uint64_t a3, int a4)
{
  if (qword_1008D5F50 != -1) {
    dispatch_once(&qword_1008D5F50, &stru_100888BF0);
  }
  *(_DWORD *)__int128 buf = *(_DWORD *)a2;
  LOWORD(vsub_100242FAC(v1 - 32) = *(_WORD *)(a2 + 4);
  uint64_t result = (unsigned __int8 *)sub_1003FFEB0(off_1008D5F48, (uint64_t)buf, 1);
  uint64_t v9 = result;
  if (result)
  {
    v30[0] = 0LL;
    v30[1] = 0LL;
    sub_100242F28((uint64_t)v30, a1 + 360);
    for (uint64_t i = *(unsigned __int8 ****)(a1 + 336); i != *(unsigned __int8 ****)(a1 + 344); ++i)
    {
      uint64_t v11 = *i;
      if (**i == v9) {
        goto LABEL_9;
      }
    }

    uint64_t v11 = 0LL;
LABEL_9:
    char v12 = (os_log_s *)qword_1008F7560;
    if (os_log_type_enabled((os_log_t)qword_1008F7560, OS_LOG_TYPE_DEFAULT))
    {
      if (a4) {
        int v13 = "paired";
      }
      else {
        int v13 = "not paired";
      }
      sub_1003D0100((uint64_t)v9, (uint64_t)__p);
      int v14 = v29;
      uint64_t v15 = (void **)__p[0];
      uint64_t v23 = sub_1001EDE10(a3, v16, v17, v18, v19, v20, v21, v22);
      uint64_t v24 = __p;
      int v25 = *((unsigned __int8 *)v11 + 12);
      if (v14 < 0) {
        uint64_t v24 = v15;
      }
      *(_DWORD *)__int128 buf = 136446978;
      __int16 v32 = v13;
      __int16 v33 = 2080;
      __int16 v34 = v24;
      __int16 v35 = 2080;
      uint64_t v36 = v23;
      __int16 v37 = 1024;
      int v38 = v25;
      _os_log_impl( (void *)&_mh_execute_header,  v12,  OS_LOG_TYPE_DEFAULT,  "received triangle status response %{public}s from device %s, for address %s, easy unpairing? - %d",  buf,  0x26u);
      if (v29 < 0) {
        operator delete(__p[0]);
      }
    }

    else if (!v11)
    {
      return (unsigned __int8 *)sub_100242FAC((uint64_t)v30);
    }

    *((_BYTE *)v11 + 84) = a4;
    if (*((_BYTE *)v11 + 12))
    {
      *((_BYTE *)v11 + 12) = 0;
      if (qword_1008D67A8 != -1) {
        dispatch_once(&qword_1008D67A8, &stru_100888B50);
      }
      sub_10052F640((uint64_t)off_1008D67A0, v9, 2u);
    }

    else
    {
      uint64_t v26 = (uint64_t)v11[6];
      if (v26)
      {
        *(_DWORD *)__int128 buf = *(_DWORD *)a2;
        LOWORD(vsub_100242FAC(v1 - 32) = *(_WORD *)(a2 + 4);
        LODWORD(__p[0]) = *(_DWORD *)a3;
        WORD2(__p[0]) = *(_WORD *)(a3 + 4);
        if (a4) {
          int v27 = 2;
        }
        else {
          int v27 = 1;
        }
        sub_100209958(v26, (uint64_t)buf, (unsigned __int8 *)__p, v27);
      }
    }

    return (unsigned __int8 *)sub_100242FAC((uint64_t)v30);
  }

  return result;
}

void sub_100228114( _Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void *__p, uint64_t a11, int a12, __int16 a13, char a14, char a15, char a16)
{
}

uint64_t sub_100228150(uint64_t a1, uint64_t a2, int a3, uint64_t a4)
{
  LODWORD(v5) = a3;
  if (qword_1008D5F50 != -1) {
    dispatch_once(&qword_1008D5F50, &stru_100888BF0);
  }
  *(_DWORD *)__int128 buf = *(_DWORD *)a2;
  *(_WORD *)&uint8_t buf[4] = *(_WORD *)(a2 + 4);
  uint64_t v8 = (unsigned __int8 *)sub_1003FFEB0(off_1008D5F48, (uint64_t)buf, 1);
  *(_DWORD *)&v74[3] = 0;
  *(_DWORD *)uint64_t v74 = 0;
  uint64_t v85 = 0LL;
  uint64_t v86 = 0LL;
  __int128 v84 = 0uLL;
  uint64_t v82 = 0LL;
  uint64_t v83 = 0LL;
  v73[0] = 0LL;
  v73[1] = 0LL;
  sub_100242F28((uint64_t)v73, a1 + 360);
  if (v8)
  {
    for (uint64_t i = *(unsigned __int8 ****)(a1 + 336); ; ++i)
    {
      if (**i == v8) {
        break;
      }
    }

    if ((_DWORD)v5 && a4)
    {
      int v10 = v8[960];
      if (qword_1008D60C0 != -1) {
        dispatch_once(&qword_1008D60C0, &stru_100888BD0);
      }
      uint64_t v11 = off_1008D60B8;
      if (sub_1003ECFD0())
      {
        BOOL v72 = v11[240] != 0;
        if (v10) {
          goto LABEL_23;
        }
      }

      else
      {
        BOOL v72 = 0;
        if (v10) {
          goto LABEL_23;
        }
      }

      if (v8[988])
      {
        if (qword_1008D60C0 != -1) {
          dispatch_once(&qword_1008D60C0, &stru_100888BD0);
        }
        goto LABEL_22;
      }

      if (v72)
      {
LABEL_22:
        if (v8[989]) {
          goto LABEL_23;
        }
        v74[0] = 0;
        *(_DWORD *)&v74[1] = *(_DWORD *)a2;
        *(_WORD *)&v74[5] = *(_WORD *)(a2 + 4);
        if (qword_1008D6608 != -1) {
          dispatch_once(&qword_1008D6608, &stru_100888CF0);
        }
        sub_10060CFE0( (uint64_t)off_1008D6600,  ((unint64_t)v74[1] << 40) | ((unint64_t)v74[2] << 32) | ((unint64_t)v74[3] << 24) | ((unint64_t)v74[4] << 16) | ((unint64_t)v74[5] << 8) | v74[6] | ((unint64_t)v74[0] << 48),  (uint64_t)&v85);
        if (qword_1008D5F20 != -1) {
          dispatch_once(&qword_1008D5F20, &stru_100888CB0);
        }
        sub_10062D738(qword_1008D5F18, v74, &v84);
        uint64_t v5 = v5;
        for (uint64_t j = (uint64_t *)(a4 + 8); ; j += 2)
        {
          int v41 = (os_log_s *)qword_1008F7600;
          if (os_log_type_enabled((os_log_t)qword_1008F7600, OS_LOG_TYPE_DEFAULT))
          {
            int v42 = *((unsigned __int16 *)j - 4);
            int v43 = *((unsigned __int16 *)j - 3);
            sub_1003D0100((uint64_t)v8, (uint64_t)__p);
            uint64_t v44 = v81 >= 0 ? __p : *(_BYTE **)__p;
            *(_DWORD *)__int128 buf = 67109634;
            *(_DWORD *)&uint8_t buf[4] = v42;
            *(_WORD *)&uint8_t buf[8] = 1024;
            *(_DWORD *)&buf[10] = v43;
            *(_WORD *)int v76 = 2080;
            *(void *)&v76[2] = v44;
            _os_log_impl( (void *)&_mh_execute_header,  v41,  OS_LOG_TYPE_DEFAULT,  "received Key update with keyType = %x, keyCFIndex Length = %d  from device%s ",  buf,  0x18u);
            if (v81 < 0) {
              operator delete(*(void **)__p);
            }
          }

          int v45 = *((unsigned __int16 *)j - 4);
          if (v45 == 1) {
            break;
          }
LABEL_142:
          if (v45 != 4) {
            goto LABEL_171;
          }
          if (*(void *)*j == v82 && *(void *)(*j + 8) == v83)
          {
            uint64_t v62 = qword_1008F7600;
            if (!os_log_type_enabled((os_log_t)qword_1008F7600, OS_LOG_TYPE_ERROR)) {
              goto LABEL_171;
            }
            sub_1003D0100((uint64_t)v8, (uint64_t)buf);
            uint64_t v63 = buf;
            if (v76[9] < 0) {
              uint64_t v63 = *(_BYTE **)buf;
            }
            *(_DWORD *)std::string __p = 136315138;
            *(void *)&__p[4] = v63;
            __int16 v64 = (os_log_s *)v62;
            char v65 = " Received invalid Enc key from %s";
            uint32_t v66 = 12;
            goto LABEL_186;
          }

          if (qword_1008D60C0 != -1) {
            dispatch_once(&qword_1008D60C0, &stru_100888BD0);
          }
          sub_1003F1A04((uint64_t)off_1008D60B8, v8, *j);
          if (v85 == *(void *)*j && v86 == *(void *)(*j + 8)) {
            goto LABEL_171;
          }
          if (qword_1008D6608 != -1) {
            dispatch_once(&qword_1008D6608, &stru_100888CF0);
          }
          sub_1005E459C((uint64_t)off_1008D6600, v74, *j);
          uint64_t v56 = sub_1002E6C74();
          int v57 = (*(uint64_t (**)(uint64_t, unsigned __int8 *, uint64_t, uint64_t))(*(void *)v56 + 88LL))( v56,  v8,  3LL,  *j);
          BOOL v58 = (os_log_s *)qword_1008F7600;
          BOOL v59 = os_log_type_enabled((os_log_t)qword_1008F7600, OS_LOG_TYPE_ERROR);
          if (v57)
          {
            if (!v59) {
              goto LABEL_171;
            }
            sub_1003D0100((uint64_t)v8, (uint64_t)__p);
            char v60 = v81 >= 0 ? __p : *(_BYTE **)__p;
            *(_DWORD *)__int128 buf = 141558531;
            *(void *)&uint8_t buf[4] = 1752392040LL;
            *(_WORD *)&_BYTE buf[12] = 2081;
            *(void *)int v76 = v60;
            *(_WORD *)&v76[8] = 1024;
            int v77 = v57;
            _os_log_error_impl( (void *)&_mh_execute_header,  v58,  OS_LOG_TYPE_ERROR,  "Failed to store encryption key to storage for device %{private, mask.hash}s with error %d",  buf,  0x1Cu);
            if ((v81 & 0x80000000) == 0) {
              goto LABEL_171;
            }
            uint64_t v61 = *(void **)__p;
            goto LABEL_188;
          }

          if (v59)
          {
            sub_1003D0100((uint64_t)v8, (uint64_t)buf);
            CFNumberRef v70 = buf;
            if (v76[9] < 0) {
              CFNumberRef v70 = *(_BYTE **)buf;
            }
            *(_DWORD *)std::string __p = 141558275;
            *(void *)&__p[4] = 1752392040LL;
            __int16 v79 = 2081;
            uint64_t v80 = v70;
            __int16 v64 = v58;
            char v65 = "Successfully stored encryption key to storage for device %{private, mask.hash}s ";
            uint32_t v66 = 22;
LABEL_186:
            _os_log_error_impl((void *)&_mh_execute_header, v64, OS_LOG_TYPE_ERROR, v65, __p, v66);
            if ((v76[9] & 0x80000000) != 0)
            {
              uint64_t v61 = *(void **)buf;
LABEL_188:
              operator delete(v61);
            }
          }

LABEL_171:
          if (*((_WORD *)j - 4) == 256)
          {
            unsigned int v68 = *(_DWORD *)*j;
            if (qword_1008D60C0 != -1) {
              dispatch_once(&qword_1008D60C0, &stru_100888BD0);
            }
            sub_1003F1E6C((uint64_t)off_1008D60B8, v8, v68);
          }

          if (!--v5) {
            return sub_100242FAC((uint64_t)v73);
          }
        }

        if (*(void *)*j == v82 && *(void *)(*j + 8) == v83)
        {
          uint64_t v53 = (os_log_s *)qword_1008F7600;
          if (!os_log_type_enabled((os_log_t)qword_1008F7600, OS_LOG_TYPE_ERROR)) {
            goto LABEL_141;
          }
          sub_1003D0100((uint64_t)v8, (uint64_t)buf);
          __int16 v69 = buf;
          if (v76[9] < 0) {
            __int16 v69 = *(_BYTE **)buf;
          }
          *(_DWORD *)std::string __p = 136315138;
          *(void *)&__p[4] = v69;
          _os_log_error_impl( (void *)&_mh_execute_header,  v53,  OS_LOG_TYPE_ERROR,  " Received invalid IRK from %s",  __p,  0xCu);
        }

        else
        {
          if (qword_1008D60C0 != -1) {
            dispatch_once(&qword_1008D60C0, &stru_100888BD0);
          }
          sub_1003F16B8((uint64_t)off_1008D60B8, (uint64_t)v8, (_OWORD *)*j);
          if ((void)v84 == *(void *)*j && *((void *)&v84 + 1) == *(void *)(*j + 8)) {
            goto LABEL_141;
          }
          if (qword_1008D5F20 != -1) {
            dispatch_once(&qword_1008D5F20, &stru_100888CB0);
          }
          sub_100621334(qword_1008D5F18, v74, *j);
          uint64_t v48 = sub_1002E6C74();
          int v49 = (*(uint64_t (**)(uint64_t, unsigned __int8 *, uint64_t, uint64_t))(*(void *)v48 + 88LL))( v48,  v8,  2LL,  *j);
          uint64_t v50 = (os_log_s *)qword_1008F7600;
          if (v49)
          {
            if (!os_log_type_enabled((os_log_t)qword_1008F7600, OS_LOG_TYPE_ERROR)) {
              goto LABEL_141;
            }
            sub_1003D0100((uint64_t)v8, (uint64_t)__p);
            int v51 = v81 >= 0 ? __p : *(_BYTE **)__p;
            *(_DWORD *)__int128 buf = 141558531;
            *(void *)&uint8_t buf[4] = 1752392040LL;
            *(_WORD *)&_BYTE buf[12] = 2081;
            *(void *)int v76 = v51;
            *(_WORD *)&v76[8] = 1024;
            int v77 = v49;
            _os_log_error_impl( (void *)&_mh_execute_header,  v50,  OS_LOG_TYPE_ERROR,  "Failed to store IRK to storage for device %{private, mask.hash}s with error %d",  buf,  0x1Cu);
            if ((v81 & 0x80000000) == 0) {
              goto LABEL_141;
            }
            unsigned int v52 = *(void **)__p;
            goto LABEL_182;
          }

          if (!os_log_type_enabled((os_log_t)qword_1008F7600, OS_LOG_TYPE_INFO))
          {
LABEL_141:
            int v45 = *((unsigned __int16 *)j - 4);
            goto LABEL_142;
          }

          sub_1003D0100((uint64_t)v8, (uint64_t)buf);
          __int16 v67 = buf;
          if (v76[9] < 0) {
            __int16 v67 = *(_BYTE **)buf;
          }
          *(_DWORD *)std::string __p = 141558275;
          *(void *)&__p[4] = 1752392040LL;
          __int16 v79 = 2081;
          uint64_t v80 = v67;
          _os_log_impl( (void *)&_mh_execute_header,  v50,  OS_LOG_TYPE_INFO,  "Successfully stored IRK to storage for device %{private, mask.hash}s ",  __p,  0x16u);
        }

        if ((v76[9] & 0x80000000) != 0)
        {
          unsigned int v52 = *(void **)buf;
LABEL_182:
          operator delete(v52);
          goto LABEL_141;
        }

        goto LABEL_141;
      }

    *(_BYTE *)(a1 + 223memset((char *)&v11[1] + 1, 0, 7) = 0;
    __int16 v69 = sub_1002E6E00();
    sub_10002418C(buf, "BLESCAN");
    sub_10002418C(__p, "ScanCoreCoexQueryPeriod");
    CFNumberRef v70 = (*(uint64_t (**)(uint64_t, _BYTE *, void **, unsigned int *))(*(void *)v69 + 88LL))( v69,  buf,  __p,  &v136);
    if (v140 < 0) {
      operator delete(__p[0]);
    }
    if ((v142[3] & 0x80000000) != 0) {
      operator delete(*(void **)buf);
    }
    if (!v70) {
      goto LABEL_181;
    }
    __int16 v71 = v136;
    if (v136 > 4 || v136 == 3)
    {
      BOOL v72 = (os_log_s *)qword_1008F75B8;
      if (!os_log_type_enabled((os_log_t)qword_1008F75B8, OS_LOG_TYPE_DEFAULT))
      {
LABEL_181:
        uint64_t v74 = (os_log_s *)qword_1008F75B8;
        if (os_log_type_enabled((os_log_t)qword_1008F75B8, OS_LOG_TYPE_DEFAULT))
        {
          unsigned int v75 = *(unsigned __int16 *)(a1 + 2224);
          int v76 = *(unsigned __int16 *)(a1 + 2226);
          int v77 = *(unsigned __int16 *)(a1 + 2228);
          int v78 = *(unsigned __int8 *)(a1 + 2230);
          __int16 v79 = *(unsigned __int16 *)(a1 + 2232);
          uint64_t v80 = (double)v79 * 0.625;
          if (*(_BYTE *)(a1 + 2230))
          {
            char v81 = (double)v79 * 0.625;
            int v78 = *(unsigned __int16 *)(a1 + 2232);
            uint64_t v80 = 0.0;
            __int16 v79 = 0;
          }

          else
          {
            char v81 = 0.0;
          }

          uint64_t v82 = "Yes";
          uint64_t v83 = *(unsigned __int16 *)(a1 + 2240);
          if (*(_BYTE *)(a1 + 2234)) {
            __int128 v84 = "Yes";
          }
          else {
            __int128 v84 = "No";
          }
          uint64_t v85 = *(unsigned __int16 *)(a1 + 2242);
          if (!*(_BYTE *)(a1 + 2235)) {
            uint64_t v82 = "No";
          }
          *(_DWORD *)__int128 buf = 67112450;
          *(_DWORD *)&uint8_t buf[4] = v75;
          *(_WORD *)&uint8_t buf[8] = 2048;
          *(double *)&buf[10] = (double)v75 * 0.625;
          *(_WORD *)&buf[18] = 1024;
          *(_DWORD *)unsigned int v142 = v76;
          *(_WORD *)&v142[4] = 1024;
          *(_DWORD *)char v143 = v77;
          *(_WORD *)&v143[4] = 1024;
          uint64_t v144 = v78;
          char v145 = 1024;
          char v146 = v79;
          uint64_t v147 = 2048;
          uint64_t v148 = (double)v76 * 0.625;
          uint64_t v149 = 2048;
          uint64_t v150 = (double)v77 * 0.625;
          char v151 = 2048;
          uint64_t v152 = v81;
          uint64_t v153 = 2048;
          uint64_t v154 = v80;
          char v155 = 2082;
          uint64_t v156 = v84;
          uint64_t v157 = 2082;
          uint64_t v158 = v82;
          uint64_t v159 = 1024;
          uint64_t v160 = v83;
          uint64_t v161 = 1024;
          uint64_t v162 = v85;
          _os_log_impl( (void *)&_mh_execute_header,  v74,  OS_LOG_TYPE_DEFAULT,  "Overriding BLE Scan Parameters Interval %d(%.2fms) Window %d/%d/%d/%d(%.2fms/%.2fms/%.2fms/%.2fms) Concurren t %{public}s Compensation %{public}s percent %d period %d",  buf,  0x72u);
        }

        goto LABEL_191;
      }

      *(_DWORD *)__int128 buf = 67109120;
      *(_DWORD *)&uint8_t buf[4] = v71;
      uint64_t v73 = "Overriding BLE ScanCore Query Period %d failed (period must be in {0, 1, 2, 4}";
    }

    else
    {
      *(_BYTE *)(a1 + 223memset((char *)&v11[1] + 1, 0, 7) = 1;
      *(_WORD *)(a1 + 2242) = v71;
      BOOL v72 = (os_log_s *)qword_1008F75B8;
      if (!os_log_type_enabled((os_log_t)qword_1008F75B8, OS_LOG_TYPE_DEFAULT)) {
        goto LABEL_181;
      }
      *(_DWORD *)__int128 buf = 67109120;
      *(_DWORD *)&uint8_t buf[4] = v71;
      uint64_t v73 = "Overriding BLE ScanCore Query Period %d";
    }

    _os_log_impl((void *)&_mh_execute_header, v72, OS_LOG_TYPE_DEFAULT, v73, buf, 8u);
    goto LABEL_181;
  }

  if (v140 < 0) {
    operator delete(__p[0]);
  }
  if ((v142[3] & 0x80000000) != 0) {
    operator delete(*(void **)buf);
  }
LABEL_191:
  uint64_t v135 = 0;
  uint64_t v86 = sub_1002E6E00();
  sub_10002418C(buf, "BLESCAN");
  sub_10002418C(__p, "IsScanCompensationDisabled");
  __int16 v87 = (*(uint64_t (**)(uint64_t, _BYTE *, void **, char *))(*(void *)v86 + 72LL))(v86, buf, __p, &v135);
  if (v135) {
    id v88 = v87;
  }
  else {
    id v88 = 0;
  }
  if (v140 < 0) {
    operator delete(__p[0]);
  }
  if ((v142[3] & 0x80000000) != 0)
  {
    operator delete(*(void **)buf);
    if (!v88) {
      goto LABEL_203;
    }
  }

  else if (!v88)
  {
    goto LABEL_203;
  }

  uint64_t v89 = (os_log_s *)qword_1008F75B8;
  if (os_log_type_enabled((os_log_t)qword_1008F75B8, OS_LOG_TYPE_DEFAULT))
  {
    *(_WORD *)__int128 buf = 0;
    _os_log_impl((void *)&_mh_execute_header, v89, OS_LOG_TYPE_DEFAULT, "Disable ScanCore Compensation", buf, 2u);
  }

  *(_BYTE *)(a1 + 2244) = 0;
LABEL_203:
  id v90 = sub_1002E6E00();
  sub_10002418C(buf, "BLESCAN");
  sub_10002418C(__p, "ApplyRSSIOffset");
  uint64_t v91 = (int *)(a1 + 2292);
  if (!(*(unsigned int (**)(uint64_t, _BYTE *, void **, uint64_t))(*(void *)v90 + 88LL))( v90,  buf,  __p,  a1 + 2292)
    || (int v92 = *v91) == 0
    || v92 > 127)
  {
    if (v140 < 0) {
      operator delete(__p[0]);
    }
    if ((v142[3] & 0x80000000) != 0) {
      operator delete(*(void **)buf);
    }
    goto LABEL_217;
  }

  if (v140 < 0) {
    operator delete(__p[0]);
  }
  if ((v142[3] & 0x80000000) != 0) {
    operator delete(*(void **)buf);
  }
  if (v92 < -128)
  {
LABEL_217:
    *uint64_t v91 = 0;
    goto LABEL_218;
  }

  __int16 v93 = (os_log_s *)qword_1008F75B8;
  if (os_log_type_enabled((os_log_t)qword_1008F75B8, OS_LOG_TYPE_DEFAULT))
  {
    uint64_t v94 = *v91;
    *(_DWORD *)__int128 buf = 67109120;
    *(_DWORD *)&uint8_t buf[4] = v94;
    _os_log_impl((void *)&_mh_execute_header, v93, OS_LOG_TYPE_DEFAULT, "Warning: Applying RSSI offset of %d", buf, 8u);
  }

void sub_100228FF4( _Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, ...)
{
}

void *sub_100229058(uint64_t a1, uint64_t a2, int a3, uint64_t a4, uint64_t a5)
{
  if (qword_1008D5F50 != -1) {
    dispatch_once(&qword_1008D5F50, &stru_100888BF0);
  }
  *(_DWORD *)__int128 buf = *(_DWORD *)a2;
  LOWORD(v2std::ostream::~ostream(v2, v3 + 8) = *(_WORD *)(a2 + 4);
  uint64_t result = sub_1003FFEB0(off_1008D5F48, (uint64_t)buf, 1);
  uint64_t v11 = (uint64_t)result;
  if (result)
  {
    v26[0] = 0LL;
    v26[1] = 0LL;
    sub_100242F28((uint64_t)v26, a1 + 360);
    char v12 = *(void ***)(a1 + 336);
    int v13 = *(void ***)(a1 + 344);
    while (v12 != v13)
    {
      uint64_t v14 = *v12;
      if (**v12 == v11) {
        goto LABEL_9;
      }
      ++v12;
    }

    uint64_t v14 = 0LL;
LABEL_9:
    uint64_t v15 = (os_log_s *)qword_1008F7560;
    if (os_log_type_enabled((os_log_t)qword_1008F7560, OS_LOG_TYPE_DEFAULT))
    {
      uint64_t v23 = sub_1001EDE10(a2, v16, v17, v18, v19, v20, v21, v22);
      *(_DWORD *)__int128 buf = 136315906;
      uint64_t v28 = v23;
      __int16 v29 = 1024;
      int v30 = a3;
      __int16 v31 = 1024;
      int v32 = a4;
      __int16 v33 = 1024;
      int v34 = a5;
      _os_log_impl( (void *)&_mh_execute_header,  v15,  OS_LOG_TYPE_DEFAULT,  "Receive command status from device %s, commandType = %d, result -> %d, reason -> %d",  buf,  0x1Eu);
    }

    int v24 = sub_1003D2B2C(v11, 32);
    if (a3 == 20) {
      int v25 = v24;
    }
    else {
      int v25 = 0;
    }
    if (v14)
    {
      if (v25) {
        sub_100229224((uint64_t)v14, a4, a5);
      }
    }

    return (void *)sub_100242FAC((uint64_t)v26);
  }

  return result;
}

void sub_100229204( _Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9)
{
}

void sub_100229224(uint64_t a1, uint64_t a2, uint64_t a3)
{
  uint64_t v3 = *(void *)(a1 + 672);
  if (v3)
  {
    unint64_t v7 = *(void *)(a1 + 664);
    int v8 = *(_DWORD *)(*(void *)(*(void *)(a1 + 640) + ((v7 >> 7) & 0x1FFFFFFFFFFFFF8LL)) + 4 * (v7 & 0x3FF));
    *(void *)(a1 + 672) = v3 - 1;
    *(void *)(a1 + 6sub_100242E28(v1 + 64) = v7 + 1;
    sub_100240C24(a1 + 632, 1);
    if (v8 == 1)
    {
      uint64_t v9 = (os_log_s *)qword_1008F7560;
      if (*(_BYTE *)(a1 + 618))
      {
        if (os_log_type_enabled((os_log_t)qword_1008F7560, OS_LOG_TYPE_DEFAULT))
        {
          sub_1003CF00C(*(void *)a1, __p);
          int v10 = v14 >= 0 ? __p : (void **)__p[0];
          *(_DWORD *)__int128 buf = 136446210;
          uint64_t v16 = v10;
          _os_log_impl( (void *)&_mh_execute_header,  v9,  OS_LOG_TYPE_DEFAULT,  "Acknowledgement request TiPi connection priority list update for device %{public}s",  buf,  0xCu);
          if (v14 < 0) {
            operator delete(__p[0]);
          }
        }

        *(_BYTE *)(a1 + 61std::ostream::~ostream(v2, v3 + 8) = 0;
        if (qword_1008D5F40 != -1) {
          dispatch_once(&qword_1008D5F40, &stru_100888BB0);
        }
        sub_1003B2638((uint64_t)off_1008D5F38, *(void *)a1, 1LL, a2, a3);
        uint64_t v11 = *(void **)(a1 + 624);
        if (v11)
        {
          [v11 invalidate];
          char v12 = *(void **)(a1 + 624);
          *(void *)(a1 + 624) = 0LL;
        }
      }

      else if (os_log_type_enabled((os_log_t)qword_1008F7560, OS_LOG_TYPE_ERROR))
      {
        sub_100660AD0();
      }
    }
  }

  else if (os_log_type_enabled((os_log_t)qword_1008F7560, OS_LOG_TYPE_ERROR))
  {
    sub_100660AA4();
  }

void *sub_100229400(uint64_t a1, uint64_t a2, int a3, uint64_t a4)
{
  unsigned __int16 v8 = sub_10056AAD8(a4);
  uint64_t v9 = sub_10056AAF0(a4);
  return sub_100229460(a1, a2, a3, v8, v9);
}

void *sub_100229460(uint64_t a1, uint64_t a2, int a3, int a4, uint64_t a5)
{
  unsigned __int16 v47 = a4;
  if (qword_1008D5F50 != -1) {
    dispatch_once(&qword_1008D5F50, &stru_100888BF0);
  }
  *(_DWORD *)__int128 buf = *(_DWORD *)a2;
  *(_WORD *)&uint8_t buf[4] = *(_WORD *)(a2 + 4);
  uint64_t result = sub_1003FFEB0(off_1008D5F48, (uint64_t)buf, 1);
  uint64_t v14 = (uint64_t)result;
  if (result)
  {
    if (a3 <= 127)
    {
      if (a3 == 2 || a3 == 4) {
        goto LABEL_66;
      }
      if (a3 != 32)
      {
LABEL_26:
        int v24 = (os_log_s *)qword_1008F7560;
        if (!os_log_type_enabled((os_log_t)qword_1008F7560, OS_LOG_TYPE_DEFAULT)) {
          return (void *)sub_10022A2E4(a1 + 560, v14, a3, (const void *)a5, v47);
        }
        sub_1003CF00C(v14, __p);
        if (v51 >= 0) {
          int v25 = __p;
        }
        else {
          int v25 = *(_BYTE **)__p;
        }
        *(_DWORD *)__int128 buf = 136446722;
        *(void *)&uint8_t buf[4] = v25;
        *(_WORD *)&_BYTE buf[12] = 1024;
        *(_DWORD *)&_BYTE buf[14] = a3;
        *(_WORD *)&buf[18] = 1024;
        int v53 = a4;
        _os_log_impl( (void *)&_mh_execute_header,  v24,  OS_LOG_TYPE_DEFAULT,  "Received custom message from %{public}s: type 0x%x, len %u",  buf,  0x18u);
LABEL_31:
        if (v51 < 0) {
          operator delete(*(void **)__p);
        }
        return (void *)sub_10022A2E4(a1 + 560, v14, a3, (const void *)a5, v47);
      }

      uint64_t v15 = sub_1002E6BF0();
      if (((*(uint64_t (**)(uint64_t))(*(void *)v15 + 328LL))(v15) & 1) == 0)
      {
        uint64_t v16 = sub_1002E6BF0();
        if (((*(uint64_t (**)(uint64_t))(*(void *)v16 + 384LL))(v16) & 1) == 0)
        {
          uint64_t v17 = sub_1002E6BF0();
        }
      }

      uint64_t v45 = 0LL;
      uint64_t v46 = 0LL;
      sub_100242F28((uint64_t)&v45, a1 + 360);
      for (uint64_t i = *(void ***)(a1 + 336); i != *(void ***)(a1 + 344); ++i)
      {
        uint64_t v19 = *i;
        if (**i == v14)
        {
          uint64_t v43 = *(void *)((char *)v19 + 85);
          int v44 = *(_DWORD *)((char *)v19 + 93);
          if (!(*(unsigned __int16 *)((char *)&v43 + 3) | BYTE5(v43)))
          {
            *(_WORD *)((char *)&v43 + 3) = *(_WORD *)(a5 + 48);
            BYTE5(v43) = *(_BYTE *)(a5 + 50);
            LOWORD(v43) = *(_WORD *)(a5 + 36);
            BYTE2(v43) = *(_BYTE *)(a5 + 38);
            *(_WORD *)((char *)&v44 + 1) = *(_WORD *)(a5 + 54);
            HIBYTE(v44) = *(_BYTE *)(a5 + 56);
            if (100 * v43 + 10 * BYTE1(v43) + BYTE2(v43) >= 0x174
              && *((_DWORD *)v19 + 20) == 8194)
            {
              int v30 = (os_log_s *)qword_1008F7560;
              if (os_log_type_enabled((os_log_t)qword_1008F7560, OS_LOG_TYPE_DEFAULT))
              {
                sub_1003CF00C(v14, buf);
                __int16 v31 = v53 >= 0 ? buf : *(_BYTE **)buf;
                int v32 = *((_DWORD *)v19 + 20);
                *(_DWORD *)std::string __p = 136446466;
                *(void *)&__p[4] = v31;
                __int16 v49 = 1024;
                int v50 = v32;
                _os_log_impl( (void *)&_mh_execute_header,  v30,  OS_LOG_TYPE_DEFAULT,  "Enabling enhanced double tap feature support on device %{public}s (pid = 0x%x)",  __p,  0x12u);
                if (SHIBYTE(v53) < 0) {
                  operator delete(*(void **)buf);
                }
              }

              sub_1003D6FAC(v14, 14, 1);
            }

            __int16 v33 = (os_log_s *)qword_1008F7560;
            if (os_log_type_enabled((os_log_t)qword_1008F7560, OS_LOG_TYPE_DEFAULT))
            {
              *(_DWORD *)__int128 buf = 67109632;
              *(_DWORD *)&uint8_t buf[4] = BYTE3(v43);
              *(_WORD *)&uint8_t buf[8] = 1024;
              *(_DWORD *)&buf[10] = BYTE4(v43);
              *(_WORD *)&_BYTE buf[14] = 1024;
              *(_DWORD *)&uint8_t buf[16] = BYTE5(v43);
              _os_log_impl( (void *)&_mh_execute_header,  v33,  OS_LOG_TYPE_DEFAULT,  "case F/W version from Headset  %d, %d, %d",  buf,  0x14u);
              __int16 v33 = (os_log_s *)qword_1008F7560;
            }

            if (os_log_type_enabled(v33, OS_LOG_TYPE_DEFAULT))
            {
              *(_DWORD *)__int128 buf = 67109632;
              *(_DWORD *)&uint8_t buf[4] = BYTE1(v44);
              *(_WORD *)&uint8_t buf[8] = 1024;
              *(_DWORD *)&buf[10] = BYTE2(v44);
              *(_WORD *)&_BYTE buf[14] = 1024;
              *(_DWORD *)&uint8_t buf[16] = HIBYTE(v44);
              _os_log_impl( (void *)&_mh_execute_header,  v33,  OS_LOG_TYPE_DEFAULT,  "case H/W version from Headset  %d, %d, %d",  buf,  0x14u);
              __int16 v33 = (os_log_s *)qword_1008F7560;
            }

            if (os_log_type_enabled(v33, OS_LOG_TYPE_DEFAULT))
            {
              int v34 = *(unsigned __int8 *)(a5 + 36);
              int v35 = *(unsigned __int8 *)(a5 + 37);
              int v36 = *(unsigned __int8 *)(a5 + 38);
              *(_DWORD *)__int128 buf = 67109632;
              *(_DWORD *)&uint8_t buf[4] = v34;
              *(_WORD *)&uint8_t buf[8] = 1024;
              *(_DWORD *)&buf[10] = v35;
              *(_WORD *)&_BYTE buf[14] = 1024;
              *(_DWORD *)&uint8_t buf[16] = v36;
              _os_log_impl( (void *)&_mh_execute_header,  v33,  OS_LOG_TYPE_DEFAULT,  "Active Bud F/W version from Headset  %d, %d, %d",  buf,  0x14u);
              __int16 v33 = (os_log_s *)qword_1008F7560;
            }

            if (os_log_type_enabled(v33, OS_LOG_TYPE_DEFAULT))
            {
              int v37 = *(unsigned __int8 *)(a5 + 39);
              int v38 = *(unsigned __int8 *)(a5 + 40);
              int v39 = *(unsigned __int8 *)(a5 + 41);
              *(_DWORD *)__int128 buf = 67109632;
              *(_DWORD *)&uint8_t buf[4] = v37;
              *(_WORD *)&uint8_t buf[8] = 1024;
              *(_DWORD *)&buf[10] = v38;
              *(_WORD *)&_BYTE buf[14] = 1024;
              *(_DWORD *)&uint8_t buf[16] = v39;
              _os_log_impl( (void *)&_mh_execute_header,  v33,  OS_LOG_TYPE_DEFAULT,  "Pending Bud F/W version from Headset  %d, %d, %d",  buf,  0x14u);
            }

            *(void *)((char *)v19 + 85) = v43;
            *(_DWORD *)((char *)v19 + 93) = v44;
            if (qword_1008D9128 != -1) {
              dispatch_once(&qword_1008D9128, &stru_100888D30);
            }
            uint64_t v40 = (*(uint64_t (**)(void *, void))(*(void *)off_1008D9120 + 120LL))(off_1008D9120, *v19);
            if ((_DWORD)v40) {
              sub_100229BF8(v40, (uint64_t)v19);
            }
          }

          sub_100242F54((uint64_t)&v45);
          sub_100242FAC((uint64_t)&v45);
          goto LABEL_66;
        }
      }
    }

    else
    {
      if (a3 < 0x40000)
      {
        if (a3 != 128 && a3 != 1024) {
          goto LABEL_26;
        }
LABEL_66:
        if (qword_1008D67D8 != -1) {
          dispatch_once(&qword_1008D67D8, &stru_100888C90);
        }
        sub_100356C54(qword_1008D67D0, (unsigned int *)a2, a3, v47, (int *)a5);
        return (void *)sub_10022A2E4(a1 + 560, v14, a3, (const void *)a5, v47);
      }

      if (a3 != 0x40000)
      {
        if (a3 == 0x100000)
        {
          sub_10007AF34(a5, (unsigned __int16)(a4 - 2), v11, v12, v13);
          int v21 = v20;
          if (v20 == 1)
          {
            *(void *)__int128 buf = 0LL;
            *(void *)&uint8_t buf[8] = 0LL;
            uint64_t v22 = sub_100242F28((uint64_t)buf, a1 + 360);
            for (uint64_t j = *(uint64_t **)(a1 + 336); ; ++j)
            {
              if (j == *(uint64_t **)(a1 + 344))
              {
                uint64_t v28 = (uint64_t *)buf;
                return (void *)sub_100242FAC((uint64_t)v28);
              }

              if (*(void *)*j == v14) {
                break;
              }
            }

            sub_10022A19C(v22, *j, v14, &v47, a5);
            sub_100242FAC((uint64_t)buf);
          }

          int v41 = (os_log_s *)qword_1008F7560;
          if (!os_log_type_enabled((os_log_t)qword_1008F7560, OS_LOG_TYPE_DEBUG)) {
            return (void *)sub_10022A2E4(a1 + 560, v14, a3, (const void *)a5, v47);
          }
          sub_1003CF00C(v14, __p);
          if (v51 >= 0) {
            int v42 = __p;
          }
          else {
            int v42 = *(_BYTE **)__p;
          }
          *(_DWORD *)__int128 buf = 136446722;
          *(void *)&uint8_t buf[4] = v42;
          *(_WORD *)&_BYTE buf[12] = 1024;
          *(_DWORD *)&_BYTE buf[14] = v21;
          *(_WORD *)&buf[18] = 1024;
          int v53 = v47;
          _os_log_debug_impl( (void *)&_mh_execute_header,  v41,  OS_LOG_TYPE_DEBUG,  "Received AACP_CUSTOM_MESSAGE_TYPE_SENSOR_WX message from %{public}s: protocol %u, len %u",  buf,  0x18u);
          goto LABEL_31;
        }

        goto LABEL_26;
      }

      uint64_t v45 = 0LL;
      uint64_t v46 = 0LL;
      uint64_t v26 = sub_100242F28((uint64_t)&v45, a1 + 360);
      for (uint64_t k = *(uint64_t **)(a1 + 336); k != *(uint64_t **)(a1 + 344); ++k)
      {
        if (*(void *)*k == v14)
        {
          sub_10022A19C(v26, *k, v14, &v47, a5);
          __int16 v29 = (os_log_s *)qword_1008F7560;
          if (os_log_type_enabled((os_log_t)qword_1008F7560, OS_LOG_TYPE_DEBUG))
          {
            sub_1003CF00C(v14, buf);
            sub_100660AFC((uint64_t *)buf, &v47, __p, v29);
          }

          sub_100242FAC((uint64_t)&v45);
          return (void *)sub_10022A2E4(a1 + 560, v14, a3, (const void *)a5, v47);
        }
      }
    }

    uint64_t v28 = &v45;
    return (void *)sub_100242FAC((uint64_t)v28);
  }

  return result;
}

void sub_100229BC4(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, ...)
{
}

void sub_100229BF8(uint64_t a1, uint64_t a2)
{
  if (a2)
  {
    if (*(_DWORD *)(a2 + 80) == 8194)
    {
      uint64_t v3 = *(void *)a2;
      if (*(void *)a2)
      {
        int v4 = (os_log_s *)qword_1008F7560;
        if (os_log_type_enabled((os_log_t)qword_1008F7560, OS_LOG_TYPE_DEFAULT))
        {
          sub_1003D0100(v3, (uint64_t)__p);
          uint64_t v5 = __p[23] >= 0 ? __p : *(_BYTE **)__p;
          *(_DWORD *)__int128 buf = 141558275;
          *(void *)&uint8_t buf[4] = 1752392040LL;
          *(_WORD *)&_BYTE buf[12] = 2081;
          *(void *)&_BYTE buf[14] = v5;
          _os_log_impl( (void *)&_mh_execute_header,  v4,  OS_LOG_TYPE_DEFAULT,  "publishW1RemoteFirmware: Publishing F/W version for %{private, mask.hash}s",  buf,  0x16u);
          if ((__p[23] & 0x80000000) != 0) {
            operator delete(*(void **)__p);
          }
        }

        __int16 v36 = 0;
        uint64_t cStr = 0LL;
        __int16 v34 = 0;
        uint64_t v33 = 0LL;
        uint64_t v21 = *(void *)(a2 + 85);
        int v22 = *(_DWORD *)(a2 + 93);
        if (*(unsigned __int16 *)((char *)&v21 + 3) | BYTE5(v21))
        {
          sub_1003FE1B4((unsigned __int8 *)(v3 + 128), __p);
          if (__p[23] >= 0) {
            uint64_t v6 = __p;
          }
          else {
            uint64_t v6 = *(const char **)__p;
          }
          CFStringRef v7 = CFStringCreateWithCString(kCFAllocatorDefault, v6, 0x8000100u);
          if ((__p[23] & 0x80000000) != 0) {
            operator delete(*(void **)__p);
          }
          if (v7)
          {
            sprintf((char *)&cStr, "%d.%d.%d", BYTE3(v21), BYTE4(v21), BYTE5(v21));
            CFStringRef v8 = CFStringCreateWithCString(kCFAllocatorDefault, (const char *)&cStr, 0x8000100u);
            if (v8)
            {
              sprintf((char *)&v33, "%d.%d.%d", BYTE1(v22), BYTE2(v22), HIBYTE(v22));
              CFStringRef v9 = CFStringCreateWithCString(kCFAllocatorDefault, (const char *)&v33, 0x8000100u);
              if (v9)
              {
                uint64_t Connection = acc_transportClient_createConnection(2LL, v7);
                uint64_t v11 = (const void *)Connection;
                if (Connection)
                {
                  uint64_t Endpoint = acc_transportClient_createEndpoint(Connection, 2LL, 1LL, 0LL, 0LL, 0LL);
                  uint64_t v13 = (os_log_s *)qword_1008F7560;
                  if (Endpoint)
                  {
                    if (os_log_type_enabled((os_log_t)qword_1008F7560, OS_LOG_TYPE_DEFAULT))
                    {
                      *(_DWORD *)std::string __p = 138412546;
                      *(void *)&__p[4] = v11;
                      *(_WORD *)&_BYTE __p[12] = 2112;
                      *(void *)&_BYTE __p[14] = Endpoint;
                      _os_log_impl( (void *)&_mh_execute_header,  v13,  OS_LOG_TYPE_DEFAULT,  "publishW1RemoteFirmware: connection %@ endpoint %@",  __p,  0x16u);
                    }

                    *(void *)(a2 + 112) = v11;
                    *(void *)(a2 + 120) = Endpoint;
                    *(void *)std::string __p = kCFACCInfo_Name;
                    *(_OWORD *)&__p[8] = __PAIR128__(kCFACCInfo_Model, kCFACCInfo_Manufacturer);
                    uint64_t v29 = kCFACCInfo_SerialNumber;
                    uint64_t v30 = kCFACCInfo_HardwareVersion;
                    uint64_t v31 = kCFACCInfo_FirmwareVersionActive;
                    uint64_t v32 = kCFACCInfo_FirmwareVersionPending;
                    *(void *)__int128 buf = @"AirPods Case";
                    *(void *)&uint8_t buf[8] = @"Apple Inc";
                    *(void *)&uint8_t buf[16] = @"A1602";
                    CFNullRef v24 = kCFNull;
                    CFStringRef v25 = v9;
                    CFStringRef v26 = v8;
                    CFNullRef v27 = kCFNull;
                    CFDictionaryRef v14 = CFDictionaryCreate( kCFAllocatorDefault,  (const void **)__p,  (const void **)buf,  7LL,  &kCFCopyStringDictionaryKeyCallBacks,  &kCFTypeDictionaryValueCallBacks);
                    acc_transportClient_setAccessoryInfo(Endpoint, v14);
                    CFRelease(v14);
                    acc_transportClient_setPropertyForConnectionWithUUID( kCFACCProperties_Connection_HideFromUI,  kCFNull,  v11);
                    acc_transportClient_publishConnection(v11);
                    CFRelease(v7);
                    CFRelease(v8);
                    CFRelease(v9);
                  }

                  else
                  {
                    if (os_log_type_enabled((os_log_t)qword_1008F7560, OS_LOG_TYPE_ERROR)) {
                      sub_100660DC4(v3, v13);
                    }
                    CFRelease(v11);
                    CFRelease(v9);
                    CFRelease(v8);
                    CFRelease(v7);
                  }
                }

                else
                {
                  int v20 = (os_log_s *)qword_1008F7560;
                  if (os_log_type_enabled((os_log_t)qword_1008F7560, OS_LOG_TYPE_ERROR)) {
                    sub_100660D3C(v3, v20);
                  }
                  CFRelease(v9);
                  CFRelease(v8);
                  CFRelease(v7);
                }
              }

              else
              {
                uint64_t v19 = (os_log_s *)qword_1008F7560;
                if (os_log_type_enabled((os_log_t)qword_1008F7560, OS_LOG_TYPE_ERROR)) {
                  sub_100660CB4(v3, v19);
                }
                CFRelease(v8);
                CFRelease(v7);
              }
            }

            else
            {
              uint64_t v18 = (os_log_s *)qword_1008F7560;
              if (os_log_type_enabled((os_log_t)qword_1008F7560, OS_LOG_TYPE_ERROR)) {
                sub_100660C2C(v3, v18);
              }
              CFRelease(v7);
            }
          }

          else
          {
            uint64_t v17 = (os_log_s *)qword_1008F7560;
            if (os_log_type_enabled((os_log_t)qword_1008F7560, OS_LOG_TYPE_ERROR)) {
              sub_100660BA4(v3, v17);
            }
          }
        }

        else
        {
          uint64_t v15 = (os_log_s *)qword_1008F7560;
          if (os_log_type_enabled((os_log_t)qword_1008F7560, OS_LOG_TYPE_DEFAULT))
          {
            sub_1003D0100(v3, (uint64_t)__p);
            uint64_t v16 = __p[23] >= 0 ? __p : *(_BYTE **)__p;
            *(_DWORD *)__int128 buf = 141558275;
            *(void *)&uint8_t buf[4] = 1752392040LL;
            *(_WORD *)&_BYTE buf[12] = 2081;
            *(void *)&_BYTE buf[14] = v16;
            _os_log_impl( (void *)&_mh_execute_header,  v15,  OS_LOG_TYPE_DEFAULT,  "Warning: publishW1RemoteFirmware: No case version info available for %{private, mask.hash}s",  buf,  0x16u);
            if ((__p[23] & 0x80000000) != 0) {
              operator delete(*(void **)__p);
            }
          }
        }
      }
    }
  }

  else if (os_log_type_enabled((os_log_t)qword_1008F7560, OS_LOG_TYPE_ERROR))
  {
    sub_100660B78();
  }

void sub_10022A178( _Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20, uint64_t a21, uint64_t a22, void *__p, uint64_t a24, int a25, __int16 a26, char a27, char a28)
{
  if (a28 < 0) {
    operator delete(__p);
  }
  _Unwind_Resume(exception_object);
}

void sub_10022A19C(uint64_t a1, uint64_t a2, uint64_t a3, unsigned __int16 *a4, uint64_t a5)
{
  if (*a4 >= 2u && (sub_1003E0350(a3, 0xE0u) != 2 || *(_DWORD *)(a2 + 16) != 1))
  {
    unsigned __int16 v9 = *a4 - 2;
    int v10 = *(unsigned __int16 *)(a5 + v9);
    if (v10 != *(unsigned __int16 *)(a2 + 760))
    {
      uint64_t v11 = (os_log_s *)qword_1008F7560;
      if (os_log_type_enabled((os_log_t)qword_1008F7560, OS_LOG_TYPE_DEFAULT))
      {
        v12[0] = 67109120;
        v12[1] = v10;
        _os_log_impl( (void *)&_mh_execute_header,  v11,  OS_LOG_TYPE_DEFAULT,  "Received new sensor data v2 JB: %u",  (uint8_t *)v12,  8u);
      }

      *(_WORD *)(a2 + 760) = v10;
      if (qword_1008D60F0 != -1) {
        dispatch_once(&qword_1008D60F0, &stru_100888D50);
      }
      sub_1004A8854((uint64_t)off_1008D60E8, a3, v10);
    }

    *a4 = v9;
  }

uint64_t sub_10022A2E4(uint64_t a1, uint64_t a2, int a3, const void *a4, size_t a5)
{
  v30[0] = 0LL;
  v30[1] = 0LL;
  sub_100242F28((uint64_t)v30, a1 + 24);
  CFStringRef v8 = *(unint64_t **)a1;
  if (*(void *)a1 == *(void *)(a1 + 8))
  {
    uint64_t v23 = 106LL;
  }

  else
  {
    do
    {
      if (qword_1008D61A8 != -1) {
        dispatch_once(&qword_1008D61A8, &stru_100888D70);
      }
      if (sub_10049729C(qword_1008D61A0, *v8))
      {
        v8 += 4;
      }

      else
      {
        unsigned __int16 v9 = (os_log_s *)qword_1008F7560;
        if (os_log_type_enabled((os_log_t)qword_1008F7560, OS_LOG_TYPE_DEFAULT))
        {
          *(_WORD *)__int128 buf = 0;
          _os_log_impl( (void *)&_mh_execute_header,  v9,  OS_LOG_TYPE_DEFAULT,  "Warning: AACPDebugUtils, Invalid BTAccessoryManager handle - removing associated callbacks",  buf,  2u);
        }

        CFStringRef v8 = (unint64_t *)sub_1002367D8(a1, (uint64_t)v8);
      }
    }

    while (v8 != *(unint64_t **)(a1 + 8));
    uint64_t v10 = *(void *)a1;
    unint64_t v11 = ((uint64_t)v8 - *(void *)a1) >> 5;
    *(void *)__int128 buf = 0LL;
    uint64_t v28 = 0LL;
    uint64_t v29 = 0LL;
    sub_1002410B0((char *)buf, v10, (uint64_t)v8, v11);
    sub_100242F54((uint64_t)v30);
    uint64_t v12 = *(void *)buf;
    uint64_t v13 = v28;
    if (*(void *)buf != v28)
    {
      do
      {
        if (qword_1008D61A8 != -1) {
          dispatch_once(&qword_1008D61A8, &stru_100888D70);
        }
        uint64_t v14 = sub_10049729C(qword_1008D61A0, *(void *)v12);
        if (qword_1008D5F50 != -1) {
          dispatch_once(&qword_1008D5F50, &stru_100888BF0);
        }
        unint64_t v15 = sub_1003FEFA8((uint64_t)off_1008D5F48, *(void *)v12, a2);
        if ((a3 & ~*(_DWORD *)(v12 + 16)) == 0)
        {
          unint64_t v16 = v15;
          if (qword_1008D9138 != -1) {
            dispatch_once(&qword_1008D9138, &stru_100888D90);
          }
          uint64_t v17 = off_1008D9130;
          uint64_t v18 = operator new(0x50uLL);
          unint64_t v20 = *(void *)v12;
          uint64_t v19 = *(void *)(v12 + 8);
          uint64_t v21 = *(void *)(v12 + 24);
          v18[4] = 1;
          *((void *)v18 + 2) = v14;
          *((void *)v18 + 3) = v19;
          *(void *)uint64_t v18 = off_1008881B0;
          *((void *)v18 + 4) = v21;
          *((void *)v18 + 5) = v20;
          *((void *)v18 + 6) = v16;
          *((_DWORD *)v18 + 14) = a3;
          *((void *)v18 + 9) = a5;
          int v22 = malloc(a5);
          *((void *)v18 + std::ostream::~ostream(v2, v3 + 8) = v22;
          memcpy(v22, a4, a5);
          sub_1004946C4((uint64_t)v17, v18);
        }

        v12 += 32LL;
      }

      while (v12 != v13);
      uint64_t v12 = *(void *)buf;
    }

    if (v12)
    {
      uint64_t v28 = v12;
      operator delete((void *)v12);
    }

    uint64_t v23 = 0LL;
  }

  sub_100242FAC((uint64_t)v30);
  return v23;
}

void sub_10022A580( _Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, void *__p, uint64_t a12, uint64_t a13, uint64_t a14, char a15)
{
  if (__p) {
    operator delete(__p);
  }
  sub_100242FAC((uint64_t)&a15);
  _Unwind_Resume(a1);
}

void sub_10022A5BC(uint64_t a1, uint64_t a2, int a3)
{
  if (qword_1008D5F50 != -1) {
    dispatch_once(&qword_1008D5F50, &stru_100888BF0);
  }
  LODWORD(__p[0]) = *(_DWORD *)a2;
  WORD2(__p[0]) = *(_WORD *)(a2 + 4);
  uint64_t v5 = sub_1003FFEB0(off_1008D5F48, (uint64_t)__p, 1);
  uint64_t v6 = (os_log_s *)qword_1008F7560;
  if (os_log_type_enabled((os_log_t)qword_1008F7560, OS_LOG_TYPE_DEFAULT))
  {
    sub_1003D0100((uint64_t)v5, (uint64_t)__p);
    if (v9 >= 0) {
      CFStringRef v7 = __p;
    }
    else {
      CFStringRef v7 = (void **)__p[0];
    }
    *(_DWORD *)__int128 buf = 136315394;
    unint64_t v11 = v7;
    __int16 v12 = 1024;
    int v13 = a3;
    _os_log_impl( (void *)&_mh_execute_header,  v6,  OS_LOG_TYPE_DEFAULT,  "received tap interval info from device %s, tapInterval = %d",  buf,  0x12u);
    if (v9 < 0) {
      operator delete(__p[0]);
    }
  }

void sub_10022A6F4(uint64_t a1, uint64_t a2, int a3, unsigned int a4)
{
  if (qword_1008D5F50 != -1) {
    dispatch_once(&qword_1008D5F50, &stru_100888BF0);
  }
  *(_DWORD *)__int128 buf = *(_DWORD *)a2;
  *(_WORD *)uint64_t v32 = *(_WORD *)(a2 + 4);
  CFStringRef v8 = sub_1003FFEB0(off_1008D5F48, (uint64_t)buf, 1);
  uint64_t v9 = (uint64_t)v8;
  if (v8)
  {
    for (uint64_t i = *(void ****)(a1 + 336); i != *(void ****)(a1 + 344); ++i)
    {
      if (**i == v8)
      {
        __int16 v12 = (os_log_s *)qword_1008F7560;
        BOOL v13 = os_log_type_enabled((os_log_t)qword_1008F7560, OS_LOG_TYPE_DEFAULT);
        if (v13)
        {
          sub_100216F34(a1, a3, a4, v29);
          int v14 = v30;
          unint64_t v15 = (void **)v29[0];
          sub_1003CF00C(v9, __p);
          if (v14 >= 0) {
            unint64_t v15 = v29;
          }
          uint64_t v17 = sub_100216F08(v16, a3);
          if (v28 >= 0) {
            uint64_t v18 = __p;
          }
          else {
            uint64_t v18 = (void **)__p[0];
          }
          *(_DWORD *)__int128 buf = 136446978;
          *(void *)uint64_t v32 = v17;
          *(_WORD *)&v32[8] = 1024;
          *(_DWORD *)uint64_t v33 = a3;
          *(_WORD *)&v33[4] = 2082;
          __int16 v34 = v15;
          __int16 v35 = 2082;
          __int16 v36 = v18;
          _os_log_impl( (void *)&_mh_execute_header,  v12,  OS_LOG_TYPE_DEFAULT,  "Received %{public}s (control cmd 0x%02X) as %{public}s from device %{public}s",  buf,  0x26u);
          if (v28 < 0) {
            operator delete(__p[0]);
          }
          if (v30 < 0) {
            operator delete(v29[0]);
          }
        }

        switch(a3)
        {
          case 6:
            BOOL v19 = a4 == 0;
            BOOL v20 = a4 != 0;
            char v21 = v19;
            sub_10022B1FC(a1, v9, v21);
            sub_1003DF238(v9, v20);
            if (qword_1008D5F40 != -1) {
              goto LABEL_89;
            }
            goto LABEL_78;
          case 10:
            sub_100220DDC(a1, v9, a4 != 1, 2u);
            if (qword_1008D5F40 == -1) {
              goto LABEL_78;
            }
            goto LABEL_89;
          case 13:
            uint64_t v23 = (os_log_s *)qword_1008F7560;
            if (os_log_type_enabled((os_log_t)qword_1008F7560, OS_LOG_TYPE_DEFAULT))
            {
              *(_DWORD *)__int128 buf = 67109120;
              *(_DWORD *)uint64_t v32 = a4;
              _os_log_impl( (void *)&_mh_execute_header,  v23,  OS_LOG_TYPE_DEFAULT,  "Set ListeningMode device setting : ListeningMode value %d",  buf,  8u);
            }

            uint64_t v24 = sub_1003DDE4C(v9, a4);
            sub_10021BE8C(v24, v9);
            if (qword_1008D5F40 == -1) {
              goto LABEL_78;
            }
            goto LABEL_89;
          case 22:
            CFStringRef v25 = (os_log_s *)qword_1008F7560;
            if (os_log_type_enabled((os_log_t)qword_1008F7560, OS_LOG_TYPE_DEFAULT))
            {
              *(_DWORD *)__int128 buf = 67109888;
              *(_DWORD *)uint64_t v32 = a4;
              *(_WORD *)&uint8_t v32[4] = 1024;
              *(_DWORD *)&v32[6] = BYTE1(a4);
              *(_WORD *)uint64_t v33 = 1024;
              *(_DWORD *)&void v33[2] = BYTE2(a4);
              LOWORD(v34) = 1024;
              *(_DWORD *)((char *)&v34 + 2) = HIBYTE(a4);
              _os_log_impl( (void *)&_mh_execute_header,  v25,  OS_LOG_TYPE_DEFAULT,  "Received ClickHoldMode device setting: right 0x%02X, left 0x%02X, prevRight 0x%02X, prevLeft 0x%02X",  buf,  0x1Au);
            }

            sub_1003DE2DC(v9, a4);
            if (qword_1008D5F40 == -1) {
              goto LABEL_78;
            }
            goto LABEL_89;
          case 23:
            sub_1003DE3A4(v9, a4);
            if (qword_1008D5F40 != -1) {
              dispatch_once(&qword_1008D5F40, &stru_100888BB0);
            }
            sub_1003B3650((uint64_t)off_1008D5F38, v9, 16, (uint64_t)"Double Click Interval");
            return;
          case 24:
            sub_1003DE414(v9, a4);
            if (qword_1008D5F40 != -1) {
              dispatch_once(&qword_1008D5F40, &stru_100888BB0);
            }
            sub_1003B3650((uint64_t)off_1008D5F38, v9, 18, (uint64_t)"Click and Hold Interval");
            return;
          case 27:
            sub_1003DE484(v9, a4);
            if (qword_1008D5F40 != -1) {
              dispatch_once(&qword_1008D5F40, &stru_100888BB0);
            }
            sub_1003B3650((uint64_t)off_1008D5F38, v9, 21, (uint64_t)"One Bud ANC Mode");
            return;
          case 28:
            sub_1003DE4F4(v9, a4);
            if (qword_1008D5F40 == -1) {
              goto LABEL_78;
            }
            goto LABEL_89;
          case 30:
            sub_1003DE538(v9, a4);
            if (qword_1008D5F40 == -1) {
              goto LABEL_78;
            }
            goto LABEL_89;
          case 31:
            sub_1003DE57C(v9, a4);
            if (qword_1008D5F40 != -1) {
              dispatch_once(&qword_1008D5F40, &stru_100888BB0);
            }
            sub_1003B2E8C((uint64_t)off_1008D5F38, v9);
            if (qword_1008D5F40 != -1) {
              dispatch_once(&qword_1008D5F40, &stru_100888BB0);
            }
            sub_1003B3650((uint64_t)off_1008D5F38, v9, 17, (uint64_t)"Chime Volume");
            return;
          case 35:
            sub_1003DE674(v9, a4);
            if (qword_1008D5F40 != -1) {
              dispatch_once(&qword_1008D5F40, &stru_100888BB0);
            }
            sub_1003B3650((uint64_t)off_1008D5F38, v9, 20, (uint64_t)"Volume Swipe Interval");
            return;
          case 36:
            CFStringRef v26 = (os_log_s *)qword_1008F7560;
            if (os_log_type_enabled((os_log_t)qword_1008F7560, OS_LOG_TYPE_DEFAULT))
            {
              *(_DWORD *)__int128 buf = 67109120;
              *(_DWORD *)uint64_t v32 = a4;
              _os_log_impl( (void *)&_mh_execute_header,  v26,  OS_LOG_TYPE_DEFAULT,  "Prox Card Status: Received Call Management: 0x%x",  buf,  8u);
            }

            sub_1003DE7AC(v9, a4);
            sub_10021BBB4(a1, v9, 36, a4);
            if (qword_1008D5F40 == -1) {
              goto LABEL_78;
            }
            goto LABEL_89;
          case 37:
            sub_1003DE604(v9, a4);
            if (qword_1008D5F40 != -1) {
              dispatch_once(&qword_1008D5F40, &stru_100888BB0);
            }
            sub_1003B3650((uint64_t)off_1008D5F38, v9, 19, (uint64_t)"Volume Swipe Mode");
            return;
          case 38:
            sub_1003DE6E4(v9, a4);
            if (qword_1008D6458 != -1) {
              dispatch_once(&qword_1008D6458, &stru_100888B90);
            }
            sub_1003786A4((void *)qword_1008D6450, v9, a4);
            if (qword_1008D5F40 == -1) {
              goto LABEL_78;
            }
            goto LABEL_89;
          case 39:
            sub_1003DE86C(v9, a4);
            sub_10021BDC8(a1);
            if (qword_1008D5F40 == -1) {
              goto LABEL_78;
            }
            goto LABEL_89;
          case 40:
            sub_100216D84(v13, v9, a4);
            sub_1003DE914(v9, a4);
            if (qword_1008D5F40 == -1) {
              goto LABEL_78;
            }
            goto LABEL_89;
          case 41:
            sub_1003DE9BC(v9, a4);
            if (qword_1008D5F40 == -1) {
              goto LABEL_78;
            }
LABEL_89:
            dispatch_once(&qword_1008D5F40, &stru_100888BB0);
LABEL_78:
            sub_1003B2E8C((uint64_t)off_1008D5F38, v9);
            break;
          case 44:
            sub_1003E5D6C(v9, a4);
            sub_1003E5E4C(v9, BYTE1(a4));
            break;
          case 46:
            sub_1003DEAA8(v9, a4);
            break;
          case 47:
            sub_1003DECA0(v9, a4);
            break;
          case 48:
            sub_1003DEB50(v9, a4);
            break;
          case 49:
            sub_1003DEA64(v9, a4);
            if (qword_1008D5F40 != -1) {
              dispatch_once(&qword_1008D5F40, &stru_100888BB0);
            }
            sub_1003B3650((uint64_t)off_1008D5F38, v9, 24, (uint64_t)"In Case Tone");
            break;
          case 50:
            sub_1003DEBF8(v9, a4);
            break;
          case 51:
            sub_1003DED48(v9, a4);
            break;
          case 52:
            sub_1003DEDF0(v9, a4);
            break;
          default:
            int v22 = (os_log_s *)qword_1008F7560;
            if (os_log_type_enabled((os_log_t)qword_1008F7560, OS_LOG_TYPE_DEFAULT))
            {
              *(_DWORD *)__int128 buf = 67109120;
              *(_DWORD *)uint64_t v32 = a3;
              _os_log_impl( (void *)&_mh_execute_header,  v22,  OS_LOG_TYPE_DEFAULT,  "Unsupported control xpc_type_t type = %d",  buf,  8u);
            }

            break;
        }

        return;
      }
    }

    if (os_log_type_enabled((os_log_t)qword_1008F7560, OS_LOG_TYPE_ERROR)) {
      sub_100660ED4();
    }
  }

  else
  {
    unint64_t v11 = (os_log_s *)qword_1008F7560;
    if (os_log_type_enabled((os_log_t)qword_1008F7560, OS_LOG_TYPE_ERROR)) {
      sub_100660E4C(v11);
    }
  }

void sub_10022B11C( _Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, void *__p, uint64_t a13, int a14, __int16 a15, char a16, char a17)
{
  if (a17 < 0) {
    operator delete(__p);
  }
  _Unwind_Resume(exception_object);
}

uint64_t sub_10022B1FC(uint64_t a1, uint64_t a2, char a3)
{
  v16[0] = 0LL;
  v16[1] = 0LL;
  sub_100242F28((uint64_t)v16, a1 + 360);
  if (a2)
  {
    for (uint64_t i = *(void ***)(a1 + 336); i != *(void ***)(a1 + 344); ++i)
    {
      if (**i == a2)
      {
        uint64_t v8 = sub_100405058();
        v14[0] = _NSConcreteStackBlock;
        v14[1] = 3221225472LL;
        void v14[2] = sub_10023BCAC;
        v14[3] = &unk_1008800D8;
        v14[4] = a2;
        char v15 = a3;
        sub_100405384(v8, v14);
        uint64_t v9 = sub_1004050C8();
        v12[0] = _NSConcreteStackBlock;
        v12[1] = 3221225472LL;
        _DWORD v12[2] = sub_10023BD00;
        void v12[3] = &unk_1008800D8;
        v12[4] = a2;
        char v13 = a3;
        sub_100405384(v9, v12);
        goto LABEL_9;
      }
    }
  }

  CFStringRef v7 = (os_log_s *)qword_1008F7560;
  if (os_log_type_enabled((os_log_t)qword_1008F7560, OS_LOG_TYPE_DEFAULT))
  {
    *(_WORD *)unint64_t v11 = 0;
    _os_log_impl( (void *)&_mh_execute_header,  v7,  OS_LOG_TYPE_DEFAULT,  "setHijackAudioRoute unable to find AACP connection",  v11,  2u);
  }

void sub_10022B32C(_Unwind_Exception *a1)
{
}

std::string *sub_10022B340(uint64_t a1, void *a2, int a3, unsigned int a4, uint64_t a5)
{
  *(void *)&__int128 v155 = a5;
  LODWORD(v154) = a3;
  uint64_t v156 = a1;
  if (qword_1008D5F50 != -1) {
    dispatch_once(&qword_1008D5F50, &stru_100888BF0);
  }
  *(_DWORD *)uint64_t v179 = *(_DWORD *)a2;
  uint64_t v153 = a2;
  *(_WORD *)&v179[4] = *((_WORD *)a2 + 2);
  uint64_t result = (std::string *)sub_1003FFEB0(off_1008D5F48, (uint64_t)v179, 1);
  uint64_t v8 = result;
  if (!result) {
    return result;
  }
  v175[0] = 0LL;
  v175[1] = 0LL;
  uint64_t v9 = sub_100242F28((uint64_t)v175, v156 + 360);
  uint64_t v10 = *(std::string ****)(v156 + 336);
  unint64_t v11 = *(std::string ****)(v156 + 344);
  if (v10 == v11)
  {
LABEL_7:
    if (os_log_type_enabled((os_log_t)qword_1008F7560, OS_LOG_TYPE_ERROR))
    {
      sub_1003CF00C((uint64_t)v8, v179);
      sub_100660F00();
    }

    return (std::string *)sub_100242FAC((uint64_t)v175);
  }

  while (1)
  {
    __int16 v12 = *v10;
    if (**v10 == v8) {
      break;
    }
    if (++v10 == v11) {
      goto LABEL_7;
    }
  }

  if (((_DWORD)v154 - 3) <= 0xFFFFFFFD)
  {
    if (os_log_type_enabled((os_log_t)qword_1008F7560, OS_LOG_TYPE_ERROR)) {
      sub_100660F4C();
    }
    return (std::string *)sub_100242FAC((uint64_t)v175);
  }

  uint64_t v148 = &v144;
  uint64_t v13 = byte_1006BF5C4[v154];
  __chkstk_darwin(v9, v13 << 8);
  bzero(&v144 - 32 * v13, v14);
  if ((int)v13 + 2 > a4)
  {
    if (os_log_type_enabled((os_log_t)qword_1008F7560, OS_LOG_TYPE_ERROR)) {
      sub_100660FAC();
    }
    return (std::string *)sub_100242FAC((uint64_t)v175);
  }

  if (*(unsigned __int8 *)v155 > 0x1Fu)
  {
    if (os_log_type_enabled((os_log_t)qword_1008F7560, OS_LOG_TYPE_ERROR)) {
      sub_10066100C();
    }
    return (std::string *)sub_100242FAC((uint64_t)v175);
  }

  uint64_t v150 = *(unsigned __int8 *)v155;
  uint64_t v16 = 0LL;
  uint64_t v149 = (char *)(&v144 - 32 * v13 + 320);
  uint64_t v145 = v13;
  else {
    uint64_t v17 = v13;
  }
  uint64_t v151 = v17;
  uint64_t v152 = (const char *)(&v144 - 32 * v13);
  int v18 = 2;
  *(void *)&__int128 v15 = 136446466LL;
  __int128 v147 = v15;
  *(void *)&__int128 v15 = 67109632LL;
  __int128 v146 = v15;
  while (1)
  {
    while (1)
    {
      if ((unsigned __int16)v18 >= a4)
      {
        char v28 = (os_log_s *)qword_1008F7560;
        if (os_log_type_enabled((os_log_t)qword_1008F7560, OS_LOG_TYPE_ERROR))
        {
          *(_DWORD *)uint64_t v179 = v146;
          *(_DWORD *)&v179[4] = v16;
          *(_WORD *)&v179[8] = 1024;
          *(_DWORD *)&v179[10] = (unsigned __int16)v18;
          *(_WORD *)&v179[14] = 1024;
          *(_DWORD *)&v179[16] = a4;
          _os_log_error_impl( (void *)&_mh_execute_header,  v28,  OS_LOG_TYPE_ERROR,  "versionInfoEvent: Reached end of strings in version info, count %d, %d >= %d",  v179,  0x14u);
        }

        v152[256 * v16] = 0;
        goto LABEL_43;
      }

      BOOL v19 = (const char *)(v155 + (unsigned __int16)v18);
      if (v16 != 10) {
        break;
      }
      uint64_t v20 = atoi(v19);
      int v21 = v20;
      id v22 = sub_100222FBC(v20, v20);
      id v23 = objc_claimAutoreleasedReturnValue(v22);
      uint64_t v24 = (const char *)[v23 UTF8String];
      BOOL v25 = v150 == 4;
      strcpy(v149, v24);

      v18 += strlen(v19) + 1;
      if (!v25) {
        goto LABEL_43;
      }
      sub_1003DB508((uint64_t)v8, v21);
      CFStringRef v26 = (os_log_s *)qword_1008F7560;
      if (os_log_type_enabled((os_log_t)qword_1008F7560, OS_LOG_TYPE_DEFAULT))
      {
        sub_1003CF00C((uint64_t)v8, v179);
        CFNullRef v27 = v179;
        if (v179[23] < 0) {
          CFNullRef v27 = *(_BYTE **)v179;
        }
        *(_DWORD *)__int128 buf = v147;
        *(void *)&uint8_t buf[4] = v149;
        *(_WORD *)&_BYTE buf[12] = 2082;
        *(void *)&_BYTE buf[14] = v27;
        _os_log_impl( (void *)&_mh_execute_header,  v26,  OS_LOG_TYPE_DEFAULT,  "Identification - Apple Audio Device firmware version of %{public}s for device %{public}s received.",  buf,  0x16u);
        if ((v179[23] & 0x80000000) != 0) {
          operator delete(*(void **)v179);
        }
      }

      sub_1003D1398((uint64_t)v8);
      uint64_t v16 = 11LL;
      if (v151 == 11) {
        goto LABEL_46;
      }
    }

    if (strlen(v19) != 1 || *v19 != 48) {
      break;
    }
    v152[256 * v16] = 0;
    v18 += 2;
LABEL_43:
    if (++v16 == v151)
    {
      uint64_t v33 = v150;
      if ((_DWORD)v150 == 13)
      {
        sub_10002418C(&v157, v149);
        sub_1003D9644(v8, &v157);
        LODWORD(v154) = 0;
        int v36 = 0;
      }

      else
      {
        if ((_DWORD)v150 == 4)
        {
LABEL_46:
          memset(buf, 0, 24);
          uint64_t v172 = 0LL;
          uint64_t v173 = 0LL;
          uint64_t v174 = 0LL;
          sub_1003D8F04((uint64_t)v8, (uint64_t)&v172);
          uint64_t v169 = 0LL;
          uint64_t v170 = 0LL;
          uint64_t v171 = 0LL;
          sub_10024062C((char *)&v169, v172, v173, 0xAAAAAAAAAAAAAAABLL * (((char *)v173 - (char *)v172) >> 3));
          unsigned int v34 = v145;
          if (0xAAAAAAAAAAAAAAABLL * ((v170 - v169) >> 3) < 4)
          {
            LODWORD(v146) = 0;
          }

          else
          {
            else {
              unint64_t v35 = *(unsigned __int8 *)(v169 + 95);
            }
            LODWORD(v146) = v35 > 1;
          }

          *(void *)uint64_t v179 = &v169;
          sub_100024304((void ***)v179);
          sub_10002418C(&v176, "");
          int v37 = *(_OWORD **)&buf[8];
          if (*(void *)&buf[8] >= *(void *)&buf[16])
          {
            unint64_t v39 = 0xAAAAAAAAAAAAAAABLL * ((uint64_t)(*(void *)&buf[8] - *(void *)buf) >> 3);
            unint64_t v40 = v39 + 1;
            if (v39 + 1 > 0xAAAAAAAAAAAAAAALL) {
              abort();
            }
            else {
              unint64_t v41 = v40;
            }
            *(void *)&v179[32] = &buf[16];
            if (v41) {
              int v42 = (char *)sub_10023F114((uint64_t)&buf[16], v41);
            }
            else {
              int v42 = 0LL;
            }
            uint64_t v43 = &v42[24 * v39];
            __int128 v44 = v176;
            *((void *)v43 + 2) = v177;
            *(_OWORD *)uint64_t v43 = v44;
            uint64_t v177 = 0LL;
            __int128 v176 = 0uLL;
            uint64_t v46 = *(void *)buf;
            uint64_t v45 = *(void *)&buf[8];
            if (*(void *)&buf[8] == *(void *)buf)
            {
              int64x2_t v49 = vdupq_n_s64(*(unint64_t *)&buf[8]);
              unsigned __int16 v47 = &v42[24 * v39];
            }

            else
            {
              unsigned __int16 v47 = &v42[24 * v39];
              do
              {
                __int128 v48 = *(_OWORD *)(v45 - 24);
                *((void *)v47 - 1) = *(void *)(v45 - 8);
                *(_OWORD *)(v47 - 24) = v48;
                v47 -= 24;
                *(void *)(v45 - 16) = 0LL;
                *(void *)(v45 - std::ostream::~ostream(v2, v3 + 8) = 0LL;
                *(void *)(v45 - 24) = 0LL;
                v45 -= 24LL;
              }

              while (v45 != v46);
              int64x2_t v49 = *(int64x2_t *)buf;
            }

            int v50 = v43 + 24;
            *(void *)__int128 buf = v47;
            *(void *)&uint8_t buf[8] = v43 + 24;
            *(int64x2_t *)&v179[8] = v49;
            uint64_t v51 = *(void *)&buf[16];
            *(void *)&uint8_t buf[16] = &v42[24 * v41];
            *(void *)&v179[24] = v51;
            *(void *)uint64_t v179 = v49.i64[0];
            sub_10023F158((uint64_t)v179);
            *(void *)&uint8_t buf[8] = v50;
            if (SHIBYTE(v177) < 0) {
              operator delete((void *)v176);
            }
          }

          else
          {
            __int128 v38 = v176;
            *(void *)(*(void *)&buf[8] + 16LL) = v177;
            *int v37 = v38;
            *(void *)&uint8_t buf[8] = (char *)v37 + 24;
          }

          if (((_DWORD)v154 - 1) <= 1)
          {
            if (v34 <= 2) {
              uint64_t v52 = 2LL;
            }
            else {
              uint64_t v52 = v34;
            }
            for (uint64_t i = 1LL; i != v52; ++i)
            {
              sub_10002418C(&v176, (char *)&v152[256 * i]);
              unsigned int v54 = *(_OWORD **)&buf[8];
              if (*(void *)&buf[8] >= *(void *)&buf[16])
              {
                unint64_t v56 = 0xAAAAAAAAAAAAAAABLL * ((uint64_t)(*(void *)&buf[8] - *(void *)buf) >> 3);
                unint64_t v57 = v56 + 1;
                if (v56 + 1 > 0xAAAAAAAAAAAAAAALL) {
                  abort();
                }
                else {
                  unint64_t v58 = v57;
                }
                *(void *)&v179[32] = &buf[16];
                if (v58) {
                  BOOL v59 = (char *)sub_10023F114((uint64_t)&buf[16], v58);
                }
                else {
                  BOOL v59 = 0LL;
                }
                char v60 = &v59[24 * v56];
                __int128 v61 = v176;
                *((void *)v60 + 2) = v177;
                *(_OWORD *)char v60 = v61;
                uint64_t v177 = 0LL;
                __int128 v176 = 0uLL;
                uint64_t v63 = *(void *)buf;
                uint64_t v62 = *(void *)&buf[8];
                if (*(void *)&buf[8] == *(void *)buf)
                {
                  int64x2_t v66 = vdupq_n_s64(*(unint64_t *)&buf[8]);
                  __int16 v64 = &v59[24 * v56];
                }

                else
                {
                  __int16 v64 = &v59[24 * v56];
                  do
                  {
                    __int128 v65 = *(_OWORD *)(v62 - 24);
                    *((void *)v64 - 1) = *(void *)(v62 - 8);
                    *(_OWORD *)(v64 - 24) = v65;
                    v64 -= 24;
                    *(void *)(v62 - 16) = 0LL;
                    *(void *)(v62 - std::ostream::~ostream(v2, v3 + 8) = 0LL;
                    *(void *)(v62 - 24) = 0LL;
                    v62 -= 24LL;
                  }

                  while (v62 != v63);
                  int64x2_t v66 = *(int64x2_t *)buf;
                }

                __int16 v67 = v60 + 24;
                *(void *)__int128 buf = v64;
                *(void *)&uint8_t buf[8] = v60 + 24;
                *(int64x2_t *)&v179[8] = v66;
                uint64_t v68 = *(void *)&buf[16];
                *(void *)&uint8_t buf[16] = &v59[24 * v58];
                *(void *)&v179[24] = v68;
                *(void *)uint64_t v179 = v66.i64[0];
                sub_10023F158((uint64_t)v179);
                *(void *)&uint8_t buf[8] = v67;
                if (SHIBYTE(v177) < 0) {
                  operator delete((void *)v176);
                }
              }

              else
              {
                __int128 v55 = v176;
                *(void *)(*(void *)&buf[8] + 16LL) = v177;
                *unsigned int v54 = v55;
                *(void *)&uint8_t buf[8] = (char *)v54 + 24;
              }
            }
          }

          memset(v168, 0, sizeof(v168));
          sub_10024062C( (char *)v168,  *(__int128 **)buf,  *(__int128 **)&buf[8],  0xAAAAAAAAAAAAAAABLL * ((uint64_t)(*(void *)&buf[8] - *(void *)buf) >> 3));
          __int16 v69 = v152;
          memset(v167, 0, sizeof(v167));
          CFNumberRef v70 = sub_10024062C((char *)v167, v172, v173, 0xAAAAAAAAAAAAAAABLL * (((char *)v173 - (char *)v172) >> 3));
          char v71 = sub_10022C8A4((uint64_t)v70, v168, v167);
          *(void *)uint64_t v179 = v167;
          sub_100024304((void ***)v179);
          *(void *)uint64_t v179 = v168;
          sub_100024304((void ***)v179);
          if ((v71 & 1) == 0)
          {
            BOOL v72 = (os_log_s *)qword_1008F7560;
            if (os_log_type_enabled((os_log_t)qword_1008F7560, OS_LOG_TYPE_DEFAULT))
            {
              *(_WORD *)uint64_t v179 = 0;
              _os_log_impl( (void *)&_mh_execute_header,  v72,  OS_LOG_TYPE_DEFAULT,  "versionInfoEvent: New version information received",  v179,  2u);
            }

            uint64_t v73 = (void *)objc_claimAutoreleasedReturnValue( +[CBProductInfo productInfoWithProductID:]( &OBJC_CLASS___CBProductInfo,  "productInfoWithProductID:",  *((unsigned int *)v12 + 20)));
            id v74 = [v73 flags];
            int v75 = v146;
            if (v75 == 1)
            {

              goto LABEL_111;
            }

            uint64_t v164 = 0LL;
            uint64_t v165 = 0LL;
            uint64_t v166 = 0LL;
            sub_10024062C( (char *)&v164,  *(__int128 **)buf,  *(__int128 **)&buf[8],  0xAAAAAAAAAAAAAAABLL * ((uint64_t)(*(void *)&buf[8] - *(void *)buf) >> 3));
            if (0xAAAAAAAAAAAAAAABLL * ((v165 - v164) >> 3) < 4)
            {
              *(void *)uint64_t v179 = &v164;
              sub_100024304((void ***)v179);

LABEL_111:
              __int16 v69 = v152;
            }

            else
            {
              else {
                unint64_t v76 = *(unsigned __int8 *)(v164 + 95);
              }
              BOOL v142 = v76 > 1;
              *(void *)uint64_t v179 = &v164;
              sub_100024304((void ***)v179);

              __int16 v69 = v152;
              if (v142)
              {
                uint64_t v143 = sub_100404FE8();
                v162[0] = _NSConcreteStackBlock;
                v162[1] = 3321888768LL;
                v162[2] = sub_10022CAD8;
                _BYTE v162[3] = &unk_100888070;
                v162[4] = v8;
                memset(v163, 0, sizeof(v163));
                sub_10024062C( v163,  *(__int128 **)buf,  *(__int128 **)&buf[8],  0xAAAAAAAAAAAAAAABLL * ((uint64_t)(*(void *)&buf[8] - *(void *)buf) >> 3));
                sub_100405384(v143, v162);
                *(void *)uint64_t v179 = v163;
                sub_100024304((void ***)v179);
              }
            }

            memset(v161, 0, sizeof(v161));
            sub_10024062C( v161,  *(__int128 **)buf,  *(__int128 **)&buf[8],  0xAAAAAAAAAAAAAAABLL * ((uint64_t)(*(void *)&buf[8] - *(void *)buf) >> 3));
            sub_1003D8FB8((uint64_t)v8, (uint64_t)v161);
            *(void *)uint64_t v179 = v161;
            sub_100024304((void ***)v179);
            sub_1003D8F04((uint64_t)v8, (uint64_t)buf);
          }

          if (qword_1008D60C0 != -1) {
            dispatch_once(&qword_1008D60C0, &stru_100888BD0);
          }
          sub_1003F6F34((uint64_t)off_1008D60B8, (uint64_t)v8);
          int v77 = (os_log_s *)qword_1008F7560;
          if (os_log_type_enabled((os_log_t)qword_1008F7560, OS_LOG_TYPE_DEFAULT))
          {
            sub_1003CF00C((uint64_t)v8, &v176);
            int v78 = SHIBYTE(v177);
            __int16 v79 = (__int128 *)v176;
            BOOL v80 = sub_1003D94C4((uint64_t)v8);
            char v81 = &v176;
            int v82 = *((_DWORD *)v12 + 20);
            if (v78 < 0) {
              char v81 = v79;
            }
            uint64_t v83 = "no";
            *(_DWORD *)uint64_t v179 = 136446978;
            *(void *)&v179[4] = v81;
            *(_WORD *)&v179[12] = 2082;
            if (v80) {
              uint64_t v83 = "yes";
            }
            *(void *)&v179[14] = v83;
            *(_WORD *)&v179[22] = 1024;
            *(_DWORD *)&v179[24] = v82;
            *(_WORD *)&v179[28] = 2082;
            *(void *)&v179[30] = v149;
            _os_log_impl( (void *)&_mh_execute_header,  v77,  OS_LOG_TYPE_DEFAULT,  "versionInfoEvent: Device %{public}s dev-fused: %{public}s pId: 0x%x FW version: %{public}s",  v179,  0x26u);
            if (SHIBYTE(v177) < 0) {
              operator delete((void *)v176);
            }
          }

          if (strlen(v69 + 768) <= 1)
          {
            uint64_t v158 = 0LL;
            uint64_t v159 = 0LL;
            uint64_t v160 = 0LL;
            sub_10024062C( (char *)&v158,  *(__int128 **)buf,  *(__int128 **)&buf[8],  0xAAAAAAAAAAAAAAABLL * ((uint64_t)(*(void *)&buf[8] - *(void *)buf) >> 3));
            if (0xAAAAAAAAAAAAAAABLL * ((v159 - v158) >> 3) < 4
              || (*(char *)(v158 + 95) < 0 ? (unint64_t v84 = *(void *)(v158 + 80)) : (unint64_t v84 = *(unsigned __int8 *)(v158 + 95)),
                  v84 < 2))
            {
              uint64_t v85 = "?";
            }

            else
            {
              uint64_t v85 = (const char *)(*(void *)buf + 72LL);
            }

            snprintf((char *)v69 + 768, 0x100uLL, "%s", v85);
            *(void *)uint64_t v179 = &v158;
            sub_100024304((void ***)v179);
          }

          uint64_t v86 = sub_1002E6E00();
          uint64_t v87 = (*(uint64_t (**)(uint64_t))(*(void *)v86 + 160LL))(v86);
          if ((_DWORD)v87)
          {
            id v88 = sub_100222170(v87, (uint64_t)v153);
            id v89 = objc_claimAutoreleasedReturnValue(v88);
            id v90 = (const char *)[v89 UTF8String];
            uint64_t v91 = v152;
            int v92 = fopen(v90, "w");
            if (v92)
            {
              fwrite("App Version Info Collected from Accessory Device\n\n", 0x32uLL, 1uLL, v92);
              fwrite("New Features Enabled: 1\n", 0x18uLL, 1uLL, v92);
              BOOL v100 = (const char *)sub_1001EDE10((uint64_t)v153, v93, v94, v95, v96, v97, v98, v99);
              fprintf(v92, "Device Bluetooth Address: %s\n", v100);
              fprintf(v92, "Device Product ID: %d\n", *((_DWORD *)v12 + 20));
              BOOL v101 = sub_1003D94C4((uint64_t)v8);
              id v154 = v89;
              uint64_t v102 = "Prod-fused";
              if (v101) {
                uint64_t v102 = "Dev-fused";
              }
              fprintf(v92, "Fusing: %s\n\n", v102);
              unint64_t v103 = 0LL;
              uint64_t v104 = 8 * v151;
              do
              {
                int64_t v105 = strlen(v91);
                if (v103 == 32 && (int64_t v107 = v105, v105 >= 20))
                {
                  __chkstk_darwin(v105, v106);
                  unsigned int v108 = (char *)&v144 - ((v107 + 9) & 0xFFFFFFFFFFFFFFF0LL);
                  if (v109 >= 4) {
                    size_t v110 = v107 - 9;
                  }
                  else {
                    size_t v110 = 0LL;
                  }
                  bzero(v108 + 3, v110);
                  *(_WORD *)unsigned int v108 = *(_WORD *)(v91 + 3);
                  v108[2] = v91[5];
                  v108[3] = 46;
                  *((_WORD *)v108 + 2) = *((_WORD *)v91 + 3);
                  v108[6] = v91[8];
                  v108[7] = 46;
                  *((_WORD *)v108 + 4) = *(_WORD *)(v91 + 9);
                  v108[10] = v91[11];
                  v108[11] = 126;
                  memcpy(v108 + 12, v91 + 19, v107 - 19);
                  v108[v107 - 7] = 0;
                  fprintf( v92,  "%s: %s (%s)\n",  off_1008D9090[0],  (const char *)&v144 - ((v107 + 9) & 0xFFFFFFFFFFFFFFF0LL),  v91);
                }

                else
                {
                  fprintf(v92, "%s: %s\n", off_1008D9070[v103 / 8], v91);
                }

                v103 += 8LL;
                v91 += 256;
              }

              while (v104 != v103);
              fclose(v92);
              id v89 = v154;
            }

            else
            {
              int v111 = (os_log_s *)qword_1008F7560;
              if (os_log_type_enabled((os_log_t)qword_1008F7560, OS_LOG_TYPE_ERROR))
              {
                __int128 v112 = __error();
                sub_100661104((uint64_t)v89, v112, (uint64_t)&v176, v111);
              }
            }
          }

          if (qword_1008D5F30 != -1) {
            dispatch_once(&qword_1008D5F30, &stru_100888C70);
          }
          sub_1005D8024();
          int v36 = v146 ^ 1;
          *(void *)uint64_t v179 = &v172;
          sub_100024304((void ***)v179);
          *(void *)uint64_t v179 = buf;
          sub_100024304((void ***)v179);
          LODWORD(v154) = 1;
        }

        else
        {
          LODWORD(v154) = 0;
          int v36 = 0;
        }

        uint64_t v33 = v150;
      }

      uint64_t v113 = &v12[v33];
      uint64_t v114 = (uint64_t)v113[20];
      uint64_t v153 = v113 + 20;
      if (v114)
      {
        __int128 v115 = (os_log_s *)qword_1008F7560;
        if (os_log_type_enabled((os_log_t)qword_1008F7560, OS_LOG_TYPE_DEFAULT))
        {
          sub_1003CF00C((uint64_t)v8, buf);
          uint64_t v116 = (buf[23] & 0x80u) == 0 ? buf : *(uint8_t **)buf;
          int v117 = v12[16];
          *(_DWORD *)uint64_t v179 = 136446722;
          *(void *)&v179[4] = v116;
          *(_WORD *)&v179[12] = 1024;
          *(_DWORD *)&v179[14] = v33;
          *(_WORD *)&v179[18] = 2112;
          *(void *)&v179[20] = v117;
          _os_log_impl( (void *)&_mh_execute_header,  v115,  OS_LOG_TYPE_DEFAULT,  "versionInfoEvent: Overwriting already existing version info for device %{public}s (index = %d); destroying o"
            "ld CoreAcc connection %@",
            v179,
            0x1Cu);
        }

        uint64_t v118 = (void *)sub_10023C228(v114);
        operator delete(v118);
        *uint64_t v153 = 0LL;
        uint64_t v119 = (CFTypeRef *)(v12 + 16);
        if (!acc_transportClient_destroyConnection(v12[16]))
        {
          unint64_t v120 = (os_log_s *)qword_1008F7560;
          if (os_log_type_enabled((os_log_t)qword_1008F7560, OS_LOG_TYPE_ERROR)) {
            sub_100661098((uint64_t *)v12 + 16, v120, v121);
          }
        }

        for (uint64_t j = 0LL; j != 32; ++j)
        {
          unsigned int v123 = v12[j + 20];
          if (v123)
          {
            cap = (const void *)v123[3].__r_.__value_.__l.__cap_;
            if (cap)
            {
              CFRelease(cap);
              v123[3].__r_.__value_.__l.__cap_ = 0LL;
            }
          }
        }

        if (*v119)
        {
          CFRelease(*v119);
          *uint64_t v119 = 0LL;
        }

        else if (os_log_type_enabled((os_log_t)qword_1008F7560, OS_LOG_TYPE_ERROR))
        {
          sub_10066106C();
        }

        LODWORD(v154) = 1;
      }

      int v125 = operator new(0x68uLL);
      LODWORD(v151) = v36;
      uint64_t v126 = 0LL;
      v125[48] = 0;
      *((_OWORD *)v125 + 4) = 0u;
      *((_OWORD *)v125 + 5) = 0u;
      *((_OWORD *)v125 + 2) = 0u;
      *((_OWORD *)v125 + 3) = 0u;
      *(_OWORD *)int v125 = 0u;
      *((_OWORD *)v125 + 1) = 0u;
      *((_BYTE *)v125 + 96) = *(_BYTE *)(v155 + 1);
      __int128 v155 = 0x8200302uLL;
      uint64_t v127 = v152;
      do
      {
        unsigned __int8 v128 = v127;
        CFStringRef v129 = CFStringCreateWithCString(kCFAllocatorDefault, v127, 0x8000100u);
        *(void *)&v125[4 * v126] = v129;
        if (!v129)
        {
          uint64_t v130 = (os_log_s *)qword_1008F7560;
          if (os_log_type_enabled((os_log_t)qword_1008F7560, OS_LOG_TYPE_DEFAULT))
          {
            uint64_t v131 = off_1008D9070[v126];
            *(_DWORD *)uint64_t v179 = v155;
            *(void *)&v179[4] = v131;
            *(_WORD *)&v179[12] = 1024;
            *(_DWORD *)&v179[14] = v150;
            *(_WORD *)&v179[18] = 1024;
            *(_DWORD *)&v179[20] = v126;
            _os_log_impl( (void *)&_mh_execute_header,  v130,  OS_LOG_TYPE_DEFAULT,  "Warning: versionInfoEvent: Received invalid UTF-8 for %s (index %d string #%d)",  v179,  0x18u);
          }

          *(void *)&v125[4 * v126] = CFStringCreateWithCString(kCFAllocatorDefault, "", 0x8000100u);
        }

        ++v126;
        uint64_t v127 = v128 + 256;
      }

      while (v126 != 11);
      int v132 = (os_log_s *)qword_1008F7560;
      BOOL v133 = os_log_type_enabled((os_log_t)qword_1008F7560, OS_LOG_TYPE_DEFAULT);
      int v134 = v150;
      int v135 = v151;
      if (v133)
      {
        sub_1003CF00C((uint64_t)v8, v179);
        uint64_t v136 = v179[23] >= 0 ? v179 : *(_BYTE **)v179;
        *(_DWORD *)__int128 buf = v147;
        *(void *)&uint8_t buf[4] = v136;
        *(_WORD *)&_BYTE buf[12] = 1024;
        *(_DWORD *)&_BYTE buf[14] = v134;
        _os_log_impl( (void *)&_mh_execute_header,  v132,  OS_LOG_TYPE_DEFAULT,  "versionInfoEvent: Received version info from device %{public}s for EA session (index %d)",  buf,  0x12u);
        if ((v179[23] & 0x80000000) != 0) {
          operator delete(*(void **)v179);
        }
      }

      *uint64_t v153 = v125;
      int v137 = sub_1003DF544((uint64_t)v8);
      unsigned int v138 = v137 | v154 ^ 1;
      unsigned int v139 = (os_log_s *)qword_1008F7560;
      if (os_log_type_enabled((os_log_t)qword_1008F7560, OS_LOG_TYPE_DEFAULT))
      {
        unsigned int v140 = "defer";
        *(_DWORD *)uint64_t v179 = v155;
        if (v138) {
          unsigned int v140 = "go";
        }
        *(void *)&v179[4] = v140;
        *(_WORD *)&v179[12] = 1024;
        *(_DWORD *)&v179[14] = (_DWORD)v154;
        *(_WORD *)&v179[18] = 1024;
        *(_DWORD *)&v179[20] = v135;
        _os_log_impl( (void *)&_mh_execute_header,  v139,  OS_LOG_TYPE_DEFAULT,  "GAPA %s publishAccRemoteFirmware publishImmediately=%d newlyPaired=%d",  v179,  0x18u);
      }

      if (v138)
      {
        sub_100224C5C(v156, (uint64_t)v12, (int)v154, v135);
      }

      else
      {
        if (v135) {
          char v141 = 3;
        }
        else {
          char v141 = 1;
        }
        *((_BYTE *)v12 + 604) = v141;
      }

      return (std::string *)sub_100242FAC((uint64_t)v175);
    }
  }

  if ((v16 - 11) <= 1)
  {
    uint64_t v29 = -[NSUUID initWithUUIDBytes:](objc_alloc(&OBJC_CLASS___NSUUID), "initWithUUIDBytes:", v19);
    id v30 = [v29 UUIDString];
    uint64_t v31 = (const char *)[v30 UTF8String];
    strcpy((char *)&v152[256 * v16], v31);

    v18 += 17;
    goto LABEL_43;
  }

  if (strnlen(v19, 0x100uLL) < 0x100)
  {
    uint64_t v32 = strcpy((char *)&v152[256 * v16], v19);
    v18 += strlen(v32) + 1;
    goto LABEL_43;
  }

  if (os_log_type_enabled((os_log_t)qword_1008F7560, OS_LOG_TYPE_ERROR)) {
    sub_100661154();
  }
  return (std::string *)sub_100242FAC((uint64_t)v175);
}

void sub_10022C70C(_Unwind_Exception *a1)
{
  *(void *)(v2 - 144) = v1;
  sub_100024304((void ***)(v2 - 144));
  *(void *)(v2 - 216) = v2 - 256;
  sub_100024304((void ***)(v2 - 216));
  *(void *)(v2 - 256) = v2 - 176;
  sub_100024304((void ***)(v2 - 256));
  sub_100242FAC(v2 - 232);
  _Unwind_Resume(a1);
}

BOOL sub_10022C844(uint64_t a1, void *a2, unsigned int a3)
{
  if (!a3) {
    return 1LL;
  }
  uint64_t v3 = *a2 + 24LL * a3;
  else {
    unint64_t v4 = *(unsigned __int8 *)(v3 + 23);
  }
  return v4 > 1;
}

uint64_t sub_10022C8A4(uint64_t a1, __int128 **a2, __int128 **a3)
{
  uint64_t v5 = *a2;
  uint64_t v6 = a2[1];
  if (v6 == v5) {
    return 1LL;
  }
  unint64_t v8 = 0LL;
  unint64_t v9 = 0xAAAAAAAAAAAAAAABLL * (((char *)v6 - (char *)v5) >> 3);
  while (1)
  {
    if (v8)
    {
      uint64_t v25 = 0LL;
      uint64_t v26 = 0LL;
      uint64_t v27 = 0LL;
      sub_10024062C((char *)&v25, v5, v6, v9);
      if (0xAAAAAAAAAAAAAAABLL * ((v26 - v25) >> 3) <= v8
        || ((uint64_t v10 = v25 + 24 * v8, *(char *)(v10 + 23) < 0)
          ? (unint64_t v11 = *(void *)(v10 + 8))
          : (unint64_t v11 = *(unsigned __int8 *)(v10 + 23)),
            v11 < 2))
      {
        uint64_t v22 = 0LL;
        uint64_t v23 = 0LL;
        uint64_t v24 = 0LL;
        sub_10024062C((char *)&v22, *a3, a3[1], 0xAAAAAAAAAAAAAAABLL * (((char *)a3[1] - (char *)*a3) >> 3));
        if (0xAAAAAAAAAAAAAAABLL * ((v23 - v22) >> 3) <= v8)
        {
          char v28 = (void **)&v22;
          sub_100024304(&v28);
          char v28 = (void **)&v25;
          sub_100024304(&v28);
          goto LABEL_32;
        }

        uint64_t v12 = v22 + 24 * v8;
        else {
          unint64_t v13 = *(unsigned __int8 *)(v12 + 23);
        }
        char v28 = (void **)&v22;
        sub_100024304(&v28);
        char v28 = (void **)&v25;
        sub_100024304(&v28);
        if (v13 <= 1) {
          goto LABEL_32;
        }
      }

      else
      {
        char v28 = (void **)&v25;
        sub_100024304(&v28);
      }

      size_t v14 = (unsigned __int8 *)*a2 + 24 * v8;
      uint64_t v15 = (uint64_t)*a3 + 24 * v8;
      uint64_t v16 = v14[23];
      if ((v16 & 0x80u) == 0LL) {
        uint64_t v17 = v14[23];
      }
      else {
        uint64_t v17 = *((void *)v14 + 1);
      }
      uint64_t v18 = *(unsigned __int8 *)(v15 + 23);
      int v19 = (char)v18;
      if ((v18 & 0x80u) != 0LL) {
        uint64_t v18 = *(void *)(v15 + 8);
      }
      if (v17 != v18) {
        return 0LL;
      }
      if (v19 >= 0) {
        uint64_t v20 = (unsigned __int8 *)*a3 + 24 * v8;
      }
      else {
        uint64_t v20 = *(unsigned __int8 **)v15;
      }
      if ((v16 & 0x80) != 0)
      {
        goto LABEL_32;
      }

      if (v14[23]) {
        break;
      }
    }

void sub_10022CABC( _Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, char a13, uint64_t a14, uint64_t a15, void **a16)
{
  a16 = (void **)&a13;
  sub_100024304(&a16);
  _Unwind_Resume(a1);
}

void sub_10022CAD8(uint64_t a1)
{
  v13[0] = 0LL;
  v13[1] = 0LL;
  if (qword_1008D6608 != -1) {
    dispatch_once(&qword_1008D6608, &stru_100888CF0);
  }
  uint64_t v2 = *(unsigned __int8 **)(a1 + 32);
  BOOL v3 = sub_10060CFE0( (uint64_t)off_1008D6600,  ((unint64_t)v2[128] << 40) | ((unint64_t)v2[129] << 32) | ((unint64_t)v2[130] << 24) | ((unint64_t)v2[131] << 16) | ((unint64_t)v2[132] << 8) | v2[133],  (uint64_t)v13);
  unint64_t v4 = (os_log_s *)qword_1008F7560;
  if (v3)
  {
    if (os_log_type_enabled((os_log_t)qword_1008F7560, OS_LOG_TYPE_DEFAULT))
    {
      uint64_t v5 = *(void *)(a1 + 40);
      uint64_t v6 = (void *)(v5 + 72);
      int v11 = 136315138;
      uint64_t v12 = v6;
      _os_log_impl( (void *)&_mh_execute_header,  v4,  OS_LOG_TYPE_DEFAULT,  "versionInfoEvent: Setting key for %s",  (uint8_t *)&v11,  0xCu);
    }

    if (qword_1008D6608 != -1) {
      dispatch_once(&qword_1008D6608, &stru_100888CF0);
    }
    uint64_t v7 = *(void *)(a1 + 40);
    unint64_t v8 = (void *)(v7 + 72);
    unint64_t v9 = off_1008D6600;
    uint64_t v10 = (void *)[NSString stringWithUTF8String:v8];
    sub_10060CB10((uint64_t)v9, v10, (uint64_t)v13);
  }

  else if (os_log_type_enabled((os_log_t)qword_1008F7560, OS_LOG_TYPE_ERROR))
  {
    sub_1006611B4();
  }

void sub_10022CC88(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

char *sub_10022CCA0(uint64_t a1, uint64_t a2)
{
  *(void *)(a1 + 40) = 0LL;
  *(void *)(a1 + 4std::ostream::~ostream(v2, v3 + 8) = 0LL;
  uint64_t v2 = a1 + 40;
  *(void *)(v2 + 16) = 0LL;
  return sub_10024062C( (char *)v2,  *(__int128 **)(a2 + 40),  *(__int128 **)(a2 + 48),  0xAAAAAAAAAAAAAAABLL * ((uint64_t)(*(void *)(a2 + 48) - *(void *)(a2 + 40)) >> 3));
}

void sub_10022CCC8(uint64_t a1)
{
  uint64_t v1 = (void **)(a1 + 40);
  sub_100024304(&v1);
}

void sub_10022CCF0(uint64_t a1, int *a2, unsigned int a3, unsigned int a4, const UInt8 *a5)
{
  if (qword_1008D5F50 != -1) {
    dispatch_once(&qword_1008D5F50, &stru_100888BF0);
  }
  int v18 = *a2;
  __int16 v19 = *((_WORD *)a2 + 2);
  uint64_t v10 = sub_1003FFEB0(off_1008D5F48, (uint64_t)&v18, 1);
  if (v10)
  {
    uint64_t v11 = (uint64_t)v10;
    for (uint64_t i = *(void ****)(a1 + 336); ; ++i)
    {
      if (i == *(void ****)(a1 + 344))
      {
        unint64_t v13 = (os_log_s *)qword_1008F7560;
        if (os_log_type_enabled((os_log_t)qword_1008F7560, OS_LOG_TYPE_ERROR)) {
          sub_1006611E0(v11, v13);
        }
        return;
      }

      if (**i == v10) {
        break;
      }
    }

    if (a3 <= 0x1F && (size_t v14 = (*i)[a3 + 20]) != 0LL && *((_BYTE *)v14 + 97) && v14[11])
    {
      CFDataRef v15 = CFDataCreate(kCFAllocatorDefault, a5, a4);
      if ((acc_transportClient_processIncomingData(v15, v14[11]) & 1) != 0
        || (uint64_t v16 = (os_log_s *)qword_1008F7560, !os_log_type_enabled((os_log_t)qword_1008F7560, OS_LOG_TYPE_ERROR)))
      {
        if (!v15) {
          return;
        }
        goto LABEL_17;
      }

      sub_1006612E8(v11, v16);
      if (v15) {
LABEL_17:
      }
        CFRelease(v15);
    }

    else
    {
      uint64_t v17 = (os_log_s *)qword_1008F7560;
      if (os_log_type_enabled((os_log_t)qword_1008F7560, OS_LOG_TYPE_ERROR)) {
        sub_100661264(v11, v17);
      }
    }
  }

void sub_10022CE90(uint64_t a1, uint64_t a2, unsigned int a3, const UInt8 *a4)
{
  if (qword_1008D5F50 != -1) {
    dispatch_once(&qword_1008D5F50, &stru_100888BF0);
  }
  LODWORD(__p[0]) = *(_DWORD *)a2;
  WORD2(__p[0]) = *(_WORD *)(a2 + 4);
  unint64_t v8 = sub_1003FFEB0(off_1008D5F48, (uint64_t)__p, 1);
  if (v8)
  {
    uint64_t v9 = (uint64_t)v8;
    for (uint64_t i = *(void ****)(a1 + 336); ; ++i)
    {
      if (i == *(void ****)(a1 + 344))
      {
        uint64_t v12 = (os_log_s *)qword_1008F7560;
        if (os_log_type_enabled((os_log_t)qword_1008F7560, OS_LOG_TYPE_ERROR)) {
          sub_10066136C(v9, v12);
        }
        return;
      }

      uint64_t v11 = *i;
      if (**i == v8) {
        break;
      }
    }

    unint64_t v13 = (os_log_s *)qword_1008F7560;
    if (v11[17])
    {
      if (os_log_type_enabled((os_log_t)qword_1008F7560, OS_LOG_TYPE_DEFAULT))
      {
        sub_1003CF00C(v9, __p);
        if (v18 >= 0) {
          size_t v14 = __p;
        }
        else {
          size_t v14 = (void **)__p[0];
        }
        *(_DWORD *)__int128 buf = 67109378;
        unsigned int v20 = a3;
        __int16 v21 = 2082;
        uint64_t v22 = v14;
        _os_log_impl( (void *)&_mh_execute_header,  v13,  OS_LOG_TYPE_DEFAULT,  "authenticationDataEvent: Processing %d bytes received from device %{public}s",  buf,  0x12u);
        if (v18 < 0) {
          operator delete(__p[0]);
        }
      }

      CFDataRef v15 = CFDataCreate(kCFAllocatorDefault, a4, a3);
      if ((acc_transportClient_processIncomingData(v15, v11[17]) & 1) != 0
        || (uint64_t v16 = (os_log_s *)qword_1008F7560, !os_log_type_enabled((os_log_t)qword_1008F7560, OS_LOG_TYPE_ERROR)))
      {
        if (!v15) {
          return;
        }
        goto LABEL_21;
      }

      sub_100661474(v9, v16);
      if (v15) {
LABEL_21:
      }
        CFRelease(v15);
    }

    else if (os_log_type_enabled((os_log_t)qword_1008F7560, OS_LOG_TYPE_ERROR))
    {
      sub_1006613F0(v9, v13);
    }
  }

void sub_10022D0B8(uint64_t a1, uint64_t a2, int a3, uint64_t a4, uint64_t a5, unsigned __int16 *a6)
{
  if (qword_1008D5F50 != -1) {
    dispatch_once(&qword_1008D5F50, &stru_100888BF0);
  }
  *(_DWORD *)__int128 buf = *(_DWORD *)a2;
  *(_WORD *)__int16 v21 = *(_WORD *)(a2 + 4);
  uint64_t v11 = sub_1003FFEB0(off_1008D5F48, (uint64_t)buf, 1);
  if (v11)
  {
    uint64_t v12 = (uint64_t)v11;
    unint64_t v13 = (os_log_s *)qword_1008F7560;
    if (os_log_type_enabled((os_log_t)qword_1008F7560, OS_LOG_TYPE_DEFAULT))
    {
      sub_1003D0100(v12, (uint64_t)__p);
      size_t v14 = v19 >= 0 ? __p : (void **)__p[0];
      *(_DWORD *)__int128 buf = 136315906;
      *(void *)__int16 v21 = v14;
      *(_WORD *)&v21[8] = 1024;
      int v22 = a3;
      __int16 v23 = 1024;
      int v24 = a4;
      __int16 v25 = 1024;
      int v26 = a5;
      _os_log_impl( (void *)&_mh_execute_header,  v13,  OS_LOG_TYPE_DEFAULT,  "received setup command from device %s, setupType = %d, opType = %d, pldLen = %d",  buf,  0x1Eu);
      if (v19 < 0) {
        operator delete(__p[0]);
      }
    }

    if (a3 == 1)
    {
      if (a5 >= 2)
      {
        if (!a6) {
          sub_1000E6B88( "/Library/Caches/com.apple.xbs/Sources/MobileBluetooth_base/Server/aacp/AACPClient.mm",  5464,  "pldData");
        }
        CFDataRef v15 = (os_log_s *)qword_1008F7560;
        if (os_log_type_enabled((os_log_t)qword_1008F7560, OS_LOG_TYPE_DEFAULT))
        {
          int v16 = *a6;
          *(_DWORD *)__int128 buf = 67109376;
          *(_DWORD *)__int16 v21 = a4;
          *(_WORD *)&v21[4] = 1024;
          *(_DWORD *)&v21[6] = v16;
          _os_log_impl( (void *)&_mh_execute_header,  v15,  OS_LOG_TYPE_DEFAULT,  "received seal setup operation opType = %d uint64_t result = %d",  buf,  0xEu);
        }
      }

      if (qword_1008D5F40 != -1) {
        dispatch_once(&qword_1008D5F40, &stru_100888BB0);
      }
      sub_1003B256C(off_1008D5F38, v12, 1LL, a4, a5, a6);
    }

    else
    {
      uint64_t v17 = (os_log_s *)qword_1008F7560;
      if (os_log_type_enabled((os_log_t)qword_1008F7560, OS_LOG_TYPE_DEFAULT))
      {
        *(_DWORD *)__int128 buf = 67109120;
        *(_DWORD *)__int16 v21 = a3;
        _os_log_impl((void *)&_mh_execute_header, v17, OS_LOG_TYPE_DEFAULT, "Unsupported setup xpc_type_t type = %d", buf, 8u);
      }
    }
  }

void sub_10022D338(uint64_t a1, uint64_t a2, unsigned __int8 *a3)
{
  if (qword_1008D5F50 != -1) {
    dispatch_once(&qword_1008D5F50, &stru_100888BF0);
  }
  *(_DWORD *)__int128 buf = *(_DWORD *)a2;
  LOWORD(v2memset((char *)&v11[1] + 1, 0, 7) = *(_WORD *)(a2 + 4);
  uint64_t v5 = sub_1003FFEB0(off_1008D5F48, (uint64_t)buf, 1);
  if (v5)
  {
    uint64_t v6 = (os_log_s *)qword_1008F7560;
    if (os_log_type_enabled((os_log_t)qword_1008F7560, OS_LOG_TYPE_DEFAULT))
    {
      int v7 = *a3;
      int v8 = *(unsigned __int16 *)(a3 + 1);
      int v9 = *(_DWORD *)(a3 + 3);
      int v10 = *(unsigned __int16 *)(a3 + 7);
      int v11 = a3[9];
      uint64_t v12 = *(void *)(a3 + 10);
      int v13 = *(_DWORD *)(a3 + 18);
      size_t v14 = *(const char **)(a3 + 22);
      if (!v14) {
        size_t v14 = "";
      }
      *(_DWORD *)__int128 buf = 67110914;
      int v27 = v7;
      __int16 v28 = 1024;
      int v29 = v8;
      __int16 v30 = 1024;
      int v31 = v9;
      __int16 v32 = 1024;
      int v33 = v10;
      __int16 v34 = 1024;
      int v35 = v11;
      __int16 v36 = 2048;
      uint64_t v37 = v12;
      __int16 v38 = 1024;
      int v39 = v13;
      __int16 v40 = 2082;
      unint64_t v41 = v14;
      _os_log_impl( (void *)&_mh_execute_header,  v6,  OS_LOG_TYPE_DEFAULT,  "caseInfoResponseEvent: messageVersion = %u, vendorID = %u, productID = %u, vendorIDSource = %u, caseColor = %u, caseVersion = %llu, reserved = %u, caseName = %{public}s",  buf,  0x3Au);
    }

    char v15 = *a3;
    __int16 v16 = *(_WORD *)(a3 + 1);
    int v17 = *(_DWORD *)(a3 + 3);
    __int16 v18 = *(_WORD *)(a3 + 7);
    char v19 = a3[9];
    uint64_t v20 = *(void *)(a3 + 10);
    int v21 = *(_DWORD *)(a3 + 18);
    if (*(void *)(a3 + 22)) {
      int v22 = *(char **)(a3 + 22);
    }
    else {
      int v22 = "";
    }
    sub_10002418C(&__p, v22);
    sub_1003D97B4((uint64_t)v5, v15, v16, v17, v18, v19, v20, v21, &__p);
    else {
      uint64_t v23 = 65533LL;
    }
    sub_10021C418(a1, (uint64_t)v5, 0xFFFFLL, v23);
    if (qword_1008D60C0 != -1) {
      dispatch_once(&qword_1008D60C0, &stru_100888BD0);
    }
    sub_1003F8238((uint64_t)off_1008D60B8, (uint64_t)v5);
  }

void sub_10022D594( _Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, void *__p, uint64_t a13, int a14, __int16 a15, char a16, char a17)
{
  if (a17 < 0) {
    operator delete(__p);
  }
  _Unwind_Resume(exception_object);
}

void sub_10022D5B8(uint64_t a1, uint64_t a2, int a3, int a4, char *a5)
{
  if (qword_1008D5F50 != -1) {
    dispatch_once(&qword_1008D5F50, &stru_100888BF0);
  }
  int v15 = *(_DWORD *)a2;
  LOWORD(v16) = *(_WORD *)(a2 + 4);
  int v9 = sub_1003FFEB0(off_1008D5F48, (uint64_t)&v15, 1);
  if (v9)
  {
    uint64_t v10 = (uint64_t)v9;
    int v11 = (os_log_s *)qword_1008F7560;
    if (os_log_type_enabled((os_log_t)qword_1008F7560, OS_LOG_TYPE_DEFAULT))
    {
      int v12 = *a5;
      int v15 = 67109632;
      int v16 = a3;
      __int16 v17 = 1024;
      int v18 = a4;
      __int16 v19 = 1024;
      int v20 = v12;
      _os_log_impl( (void *)&_mh_execute_header,  v11,  OS_LOG_TYPE_DEFAULT,  "deviceInfoEvent: devInfoType = %u, devInfoLen = %u, devInfoData=%d",  (uint8_t *)&v15,  0x14u);
    }

    if (a3 == 1)
    {
      uint64_t v13 = sub_1003E17EC(v10, *a5);
      sub_10022D748(v13, v10);
    }

    else
    {
      size_t v14 = (os_log_s *)qword_1008F7560;
      if (os_log_type_enabled((os_log_t)qword_1008F7560, OS_LOG_TYPE_DEFAULT))
      {
        int v15 = 67109120;
        int v16 = a3;
        _os_log_impl( (void *)&_mh_execute_header,  v14,  OS_LOG_TYPE_DEFAULT,  "Unsupported device info xpc_type_t type = %d",  (uint8_t *)&v15,  8u);
      }
    }
  }

void sub_10022D748(uint64_t a1, uint64_t a2)
{
  BOOL v3 = (os_log_s *)qword_1008F7560;
  if (os_log_type_enabled((os_log_t)qword_1008F7560, OS_LOG_TYPE_DEFAULT))
  {
    sub_1003D0100(a2, (uint64_t)__p);
    if (v10 >= 0) {
      unint64_t v4 = __p;
    }
    else {
      unint64_t v4 = (void **)__p[0];
    }
    *(_DWORD *)__int128 buf = 136315138;
    int v12 = v4;
    _os_log_impl( (void *)&_mh_execute_header,  v3,  OS_LOG_TYPE_DEFAULT,  "Notify EU region bit change for device %s",  buf,  0xCu);
    if (v10 < 0) {
      operator delete(__p[0]);
    }
  }

  uint64_t v5 = sub_100405058();
  v8[0] = _NSConcreteStackBlock;
  v8[1] = 3221225472LL;
  _DWORD v8[2] = sub_1002352D4;
  v8[3] = &unk_10087EB20;
  void v8[4] = a2;
  sub_100405384(v5, v8);
  uint64_t v6 = sub_1004050C8();
  v7[0] = _NSConcreteStackBlock;
  v7[1] = 3221225472LL;
  void v7[2] = sub_100235338;
  void v7[3] = &unk_10087EB20;
  void v7[4] = a2;
  sub_100405384(v6, v7);
}

void *sub_10022D888(uint64_t a1, uint64_t a2, unsigned int *a3, int a4, unsigned __int8 *a5)
{
  uint64_t v9 = *a5;
  if (qword_1008D5F50 != -1) {
    dispatch_once(&qword_1008D5F50, &stru_100888BF0);
  }
  int v22 = *(_DWORD *)a2;
  LOWORD(v23) = *(_WORD *)(a2 + 4);
  uint64_t result = sub_1003FFEB0(off_1008D5F48, (uint64_t)&v22, 1);
  if (result)
  {
    uint64_t v11 = (uint64_t)result;
    int v12 = (os_log_s *)qword_1008F7560;
    if (os_log_type_enabled((os_log_t)qword_1008F7560, OS_LOG_TYPE_DEFAULT))
    {
      uint64_t v20 = sub_1001EDE10(a2, v13, v14, v15, v16, v17, v18, v19);
      int v21 = "Unknown";
      int v22 = 136315650;
      uint64_t v23 = v20;
      if ((_DWORD)v9 == 1) {
        int v21 = "Audio Arbitration";
      }
      __int16 v24 = 2080;
      __int16 v25 = v21;
      __int16 v26 = 1024;
      int v27 = a4 - 1;
      _os_log_impl( (void *)&_mh_execute_header,  v12,  OS_LOG_TYPE_DEFAULT,  "Receive relay message from device %s, relayMessageType -> %s, relayMessageLen -> %d",  (uint8_t *)&v22,  0x1Cu);
    }

    if (qword_1008D5F40 != -1) {
      dispatch_once(&qword_1008D5F40, &stru_100888BB0);
    }
    return (void *)sub_1003B2570((uint64_t)off_1008D5F38, v11, a3, v9, (unsigned __int16)(a4 - 1), a5 + 1);
  }

  return result;
}

uint64_t sub_10022DA2C( uint64_t a1, uint64_t a2, int a3, int a4, int a5, int a6, char *a7, unsigned int a8, char *__src)
{
  v27[0] = 0LL;
  v27[1] = 0LL;
  sub_100242F28((uint64_t)v27, a1 + 360);
  if (qword_1008D5F50 != -1) {
    dispatch_once(&qword_1008D5F50, &stru_100888BF0);
  }
  *(_DWORD *)__int128 buf = *(_DWORD *)a2;
  LOWORD(v29) = *(_WORD *)(a2 + 4);
  uint64_t v17 = sub_1003FFEB0(off_1008D5F48, (uint64_t)buf, 1);
  if (!v17 || (uint64_t v18 = *(void ****)(a1 + 336), v19 = *(void ****)(a1 + 344), v18 == v19))
  {
LABEL_7:
    int v21 = (os_log_s *)qword_1008F7560;
    if (os_log_type_enabled((os_log_t)qword_1008F7560, OS_LOG_TYPE_DEFAULT))
    {
      if (a7[23] < 0) {
        a7 = *(char **)a7;
      }
      *(_DWORD *)__int128 buf = 67110402;
      int v29 = a3;
      __int16 v30 = 1024;
      int v31 = a4;
      __int16 v32 = 1024;
      int v33 = a5;
      __int16 v34 = 1024;
      int v35 = a6;
      __int16 v36 = 2080;
      uint64_t v37 = a7;
      __int16 v38 = 1024;
      unsigned int v39 = a8;
      _os_log_impl( (void *)&_mh_execute_header,  v21,  OS_LOG_TYPE_DEFAULT,  "AACPClient::getCertificatesResponseEvent (not handled, connection is gone) - certSeqNum == %d, responseInfo == % d, endpointType == %d, serialNumberLength == %d, serialNumber == %s, certificateLength == %d",  buf,  0x2Au);
    }
  }

  else
  {
    while (1)
    {
      uint64_t v20 = *v18;
      if (**v18 == v17) {
        break;
      }
      if (++v18 == v19) {
        goto LABEL_7;
      }
    }

    int v22 = (os_log_s *)qword_1008F7560;
    if (os_log_type_enabled((os_log_t)qword_1008F7560, OS_LOG_TYPE_DEFAULT))
    {
      uint64_t v23 = a7;
      if (a7[23] < 0) {
        uint64_t v23 = *(char **)a7;
      }
      *(_DWORD *)__int128 buf = 67110402;
      int v29 = a3;
      __int16 v30 = 1024;
      int v31 = a4;
      __int16 v32 = 1024;
      int v33 = a5;
      __int16 v34 = 1024;
      int v35 = a6;
      __int16 v36 = 2080;
      uint64_t v37 = v23;
      __int16 v38 = 1024;
      unsigned int v39 = a8;
      _os_log_impl( (void *)&_mh_execute_header,  v22,  OS_LOG_TYPE_DEFAULT,  "AACPClient::getCertificatesResponseEvent - certSeqNum == %d, responseInfo == %d, endpointType == %d, serialNumbe rLength == %d, serialNumber == %s, certificateLength == %d",  buf,  0x2Au);
    }

    if (a7[23] < 0)
    {
      sub_100024238(__p, *(void **)a7, *((void *)a7 + 1));
    }

    else
    {
      *(_OWORD *)std::string __p = *(_OWORD *)a7;
      uint64_t v26 = *((void *)a7 + 2);
    }

    sub_10022DD04((uint64_t)v20, (int *)a2, a3, a4, a5, a6, (uint64_t)__p, a8, __src);
    if (SHIBYTE(v26) < 0) {
      operator delete(__p[0]);
    }
  }

  return sub_100242FAC((uint64_t)v27);
}

void sub_10022DCCC( _Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, void *__p, uint64_t a12, int a13, __int16 a14, char a15, char a16, uint64_t a17, char a18)
{
}

uint64_t sub_10022DD04( uint64_t a1, int *a2, int a3, int a4, char a5, int a6, uint64_t a7, unsigned int a8, char *__src)
{
  v39[0] = 0LL;
  v39[1] = 0LL;
  sub_100242F28((uint64_t)v39, a1 + 536);
  if (*(_BYTE *)(a1 + 528))
  {
    int v17 = *(_DWORD *)(a1 + 532);
    goto LABEL_3;
  }

  if (a3)
  {
    int v17 = *(_DWORD *)(a1 + 532);
    if (v17 != -1)
    {
LABEL_3:
      if (v17 == a3)
      {
        if (a3)
        {
          sub_10023E170( *(void *)(*(void *)(a1 + 512) - 8LL),  *(char **)(*(void *)(*(void *)(a1 + 512) - 8LL) + 8LL),  __src,  &__src[a8],  a8);
        }

        else
        {
          uint64_t v18 = operator new(0x38uLL);
          if (*(char *)(a7 + 23) < 0)
          {
            sub_100024238(__p, *(void **)a7, *(void *)(a7 + 8));
          }

          else
          {
            *(_OWORD *)std::string __p = *(_OWORD *)a7;
            uint64_t v38 = *(void *)(a7 + 16);
          }

          sub_10023DFF0((uint64_t)v18, a6, (__int128 *)__p, a8, __src, a5);
          if (SHIBYTE(v38) < 0) {
            operator delete(__p[0]);
          }
          uint64_t v19 = *(void **)(a1 + 512);
          unint64_t v20 = *(void *)(a1 + 520);
          if ((unint64_t)v19 >= v20)
          {
            uint64_t v22 = *(void *)(a1 + 504);
            uint64_t v23 = ((uint64_t)v19 - v22) >> 3;
            uint64_t v24 = v20 - v22;
            uint64_t v25 = v24 >> 2;
            else {
              unint64_t v26 = v25;
            }
            if (v26) {
              int v27 = (char *)sub_100008BA0(a1 + 520, v26);
            }
            else {
              int v27 = 0LL;
            }
            __int16 v28 = &v27[8 * v23];
            int v29 = &v27[8 * v26];
            *(void *)__int16 v28 = v18;
            int v21 = v28 + 8;
            int v31 = *(char **)(a1 + 504);
            __int16 v30 = *(char **)(a1 + 512);
            if (v30 != v31)
            {
              do
              {
                uint64_t v32 = *((void *)v30 - 1);
                v30 -= 8;
                *((void *)v28 - 1) = v32;
                v28 -= 8;
              }

              while (v30 != v31);
              __int16 v30 = *(char **)(a1 + 504);
            }

            *(void *)(a1 + 504) = v28;
            *(void *)(a1 + 512) = v21;
            *(void *)(a1 + 520) = v29;
            if (v30) {
              operator delete(v30);
            }
          }

          else
          {
            *uint64_t v19 = v18;
            int v21 = v19 + 1;
          }

          *(void *)(a1 + 512) = v21;
        }

        switch(a4)
        {
          case 2:
            *(_BYTE *)(a1 + 52std::ostream::~ostream(v2, v3 + 8) = 0;
            *(_DWORD *)(a1 + 5sub_100242FAC(v1 - 32) = -1;
            sub_100235DB8(a1);
            uint64_t v33 = sub_1002E8D94();
            int v35 = *a2;
            __int16 v36 = *((_WORD *)a2 + 2);
            (*(void (**)(uint64_t, int *, uint64_t, void))(*(void *)v33 + 368LL))(v33, &v35, 3LL, 0LL);
            break;
          case 1:
            *(_BYTE *)(a1 + 52std::ostream::~ostream(v2, v3 + 8) = 1;
            *(_DWORD *)(a1 + 5sub_100242FAC(v1 - 32) = 0;
            break;
          case 0:
            *(_BYTE *)(a1 + 52std::ostream::~ostream(v2, v3 + 8) = 0;
            ++*(_DWORD *)(a1 + 532);
            break;
        }
      }

      else if (os_log_type_enabled((os_log_t)qword_1008F7560, OS_LOG_TYPE_ERROR))
      {
        sub_100661524();
      }

      goto LABEL_40;
    }
  }

  if (os_log_type_enabled((os_log_t)qword_1008F7560, OS_LOG_TYPE_ERROR)) {
    sub_1006614F8();
  }
LABEL_40:
  sub_100242F54((uint64_t)v39);
  return sub_100242FAC((uint64_t)v39);
}

void sub_10022DFB0( _Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, void *__p, uint64_t a12, int a13, __int16 a14, char a15, char a16, uint64_t a17, char a18)
{
}

uint64_t sub_10022DFF4(uint64_t a1, uint64_t a2, uint64_t a3, int a4)
{
  v16[0] = 0LL;
  v16[1] = 0LL;
  sub_100242F28((uint64_t)v16, a1 + 360);
  if (qword_1008D5F50 != -1) {
    dispatch_once(&qword_1008D5F50, &stru_100888BF0);
  }
  LODWORD(__p) = *(_DWORD *)a2;
  WORD2(__p) = *(_WORD *)(a2 + 4);
  int v7 = sub_1003FFEB0(off_1008D5F48, (uint64_t)&__p, 1);
  if (a4 == 1)
  {
    int v8 = *(_BYTE **)a3;
    if (*(void *)(a3 + 8) - *(void *)a3 == 1LL)
    {
      uint64_t v9 = (uint64_t)v7;
      char v10 = operator new(3uLL);
      uint64_t v14 = v10 + 3;
      uint64_t v15 = v10 + 3;
      *(_WORD *)char v10 = 0;
      void v10[2] = 0;
      std::string __p = v10;
      uint64_t v11 = (os_log_s *)qword_1008F7560;
      if (os_log_type_enabled((os_log_t)qword_1008F7560, OS_LOG_TYPE_DEFAULT))
      {
        *(_DWORD *)__int128 buf = 134218240;
        uint64_t v18 = 1LL;
        __int16 v19 = 1024;
        int v20 = 1;
        _os_log_impl( (void *)&_mh_execute_header,  v11,  OS_LOG_TYPE_DEFAULT,  "AACPClient::getGyroInformationMessageEvent - received gyroInfoDataLength: %lu, gyroInfoVersion: %u",  buf,  0x12u);
        int v8 = *(_BYTE **)a3;
      }

      *char v10 = 1;
      v10[1] = (*v8 & 4) != 0;
      void v10[2] = *v8 & 1;
      sub_1003D1D50(v9, (char **)&__p);
      if (__p)
      {
        uint64_t v14 = __p;
        operator delete(__p);
      }
    }

    else if (os_log_type_enabled((os_log_t)qword_1008F7560, OS_LOG_TYPE_ERROR))
    {
      sub_100661584();
    }
  }

  else if (os_log_type_enabled((os_log_t)qword_1008F7560, OS_LOG_TYPE_ERROR))
  {
    sub_1006615E8();
  }

  return sub_100242FAC((uint64_t)v16);
}

void sub_10022E1F4( _Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void *__p, uint64_t a11, uint64_t a12, char a13)
{
  if (__p) {
    operator delete(__p);
  }
  sub_100242FAC((uint64_t)&a13);
  _Unwind_Resume(a1);
}

uint64_t sub_10022E22C( uint64_t a1, uint64_t a2, unsigned int a3, unint64_t a4, unsigned int a5, void *a6)
{
  v39[0] = 0LL;
  v39[1] = 0LL;
  sub_100242F28((uint64_t)v39, a1 + 360);
  if (a3 < 2)
  {
    uint64_t v9 = (void *)[NSDate date];
    [v9 timeIntervalSince1970];
    double v11 = v10;

    unsigned int v12 = (61681 * a5) >> 20;
    uint64_t v13 = (os_log_s *)qword_1008F7560;
    if (os_log_type_enabled((os_log_t)qword_1008F7560, OS_LOG_TYPE_DEFAULT))
    {
      *(_DWORD *)__int128 buf = 67109120;
      unsigned int v41 = (61681 * a5) >> 20;
      _os_log_impl( (void *)&_mh_execute_header,  v13,  OS_LOG_TYPE_DEFAULT,  "AACPClient::getBTEventHistoryListMessageEvent - Last %u BT Events \n",  buf,  8u);
    }

    if (a5 >= 0x11)
    {
      uint64_t v14 = 0LL;
      if (v12 <= 1) {
        uint64_t v15 = 1LL;
      }
      else {
        uint64_t v15 = v12;
      }
      uint64_t v16 = v15 + 16LL * v15;
      int v17 = 1;
      while (v14 + 17 <= (unint64_t)a5)
      {
        memset(v38, 0, 17);
        uint64_t v18 = *a6 + v14;
        char v19 = *(_BYTE *)(v18 + 16);
        v38[0] = *(_OWORD *)v18;
        LOBYTE(v38[1]) = v19;
        __int16 v37 = 0;
        int v36 = 0;
        uint64_t v20 = sub_1001F0050((uint64_t)&v36, (uint64_t)v38 + 8, 6uLL);
        id v21 = sub_10022E520(v11, v20, a4, *(unint64_t *)&v38[0]);
        uint64_t v22 = (void *)objc_claimAutoreleasedReturnValue(v21);
        id v23 = sub_10022E618((uint64_t)v22, BYTE14(v38[0]), *(unsigned __int16 *)((char *)v38 + 15));
        uint64_t v24 = (void *)objc_claimAutoreleasedReturnValue(v23);
        uint64_t v32 = sub_1001EDE10((uint64_t)&v36, v25, v26, v27, v28, v29, v30, v31);
        uint64_t v33 = (os_log_s *)qword_1008F7560;
        if (os_log_type_enabled((os_log_t)qword_1008F7560, OS_LOG_TYPE_DEFAULT))
        {
          *(_DWORD *)__int128 buf = 67109891;
          unsigned int v41 = v17;
          __int16 v42 = 2112;
          uint64_t v43 = v22;
          __int16 v44 = 2081;
          uint64_t v45 = v32;
          __int16 v46 = 2112;
          unsigned __int16 v47 = v24;
          _os_log_impl( (void *)&_mh_execute_header,  v33,  OS_LOG_TYPE_DEFAULT,  "BTEventHistory: %2d. Time: %@, BT Addr: %{private}s, Event: %@",  buf,  0x26u);
        }

        v14 += 17LL;
        ++v17;
        if (v16 == v14) {
          return sub_100242FAC((uint64_t)v39);
        }
      }

      if (os_log_type_enabled((os_log_t)qword_1008F7560, OS_LOG_TYPE_ERROR)) {
        sub_1006616A8();
      }
    }
  }

  else if (os_log_type_enabled((os_log_t)qword_1008F7560, OS_LOG_TYPE_ERROR))
  {
    sub_100661648();
  }

  return sub_100242FAC((uint64_t)v39);
}

void sub_10022E4D8( _Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, ...)
{
  sub_100242FAC((uint64_t)va);
  _Unwind_Resume(a1);
}

id sub_10022E520(double a1, uint64_t a2, unint64_t a3, unint64_t a4)
{
  unint64_t v4 = -[NSDate initWithTimeIntervalSince1970:]( objc_alloc(&OBJC_CLASS___NSDate),  "initWithTimeIntervalSince1970:",  a1 - (double)a3 / 1000000.0 + (double)a4 / 1000000.0);
  uint64_t v5 = objc_alloc_init(&OBJC_CLASS___NSDateFormatter);
  -[NSDateFormatter setDateFormat:](v5, "setDateFormat:", @"yyyy-MM-dd HH:mm:ss.SSS zzz");
  uint64_t v6 = (void *)[v5 stringFromDate:v4];
  int v7 = (void *)objc_claimAutoreleasedReturnValue(+[NSString stringWithFormat:](&OBJC_CLASS___NSString, "stringWithFormat:", @"%@", v6));

  return v7;
}

void sub_10022E5EC(_Unwind_Exception *a1)
{
  unint64_t v4 = v3;

  _Unwind_Resume(a1);
}

id sub_10022E618(uint64_t a1, unsigned int a2, unsigned int a3)
{
  switch(a2)
  {
    case 1u:
      if (a3 == 2)
      {
        BOOL v3 = +[NSString stringWithFormat:]( &OBJC_CLASS___NSString,  "stringWithFormat:",  @"Connect,        Direction: Source initiated, Status %u",  2LL,  v5);
      }

      else if (a3 == 1)
      {
        BOOL v3 = +[NSString stringWithFormat:]( &OBJC_CLASS___NSString,  "stringWithFormat:",  @"Connect,        Direction: Accessory initiated, Status %u",  1LL,  v5);
      }

      else
      {
        BOOL v3 = +[NSString stringWithFormat:]( &OBJC_CLASS___NSString,  "stringWithFormat:",  @"Connect,        Invalid direction: %u",  a3,  v5);
      }

      break;
    case 2u:
      BOOL v3 = +[NSString stringWithFormat:]( &OBJC_CLASS___NSString,  "stringWithFormat:",  @"Disconnect,     Reason: %u",  a3,  v5);
      break;
    case 3u:
      BOOL v3 = +[NSString stringWithFormat:]( &OBJC_CLASS___NSString,  "stringWithFormat:",  @"Pairing,        Status: %u",  a3,  v5);
      break;
    case 4u:
      BOOL v3 = +[NSString stringWithFormat:]( &OBJC_CLASS___NSString,  "stringWithFormat:",  @"Unpairing,      Status: %u",  a3,  v5);
      break;
    case 5u:
      BOOL v3 = +[NSString stringWithFormat:]( &OBJC_CLASS___NSString,  "stringWithFormat:",  @"UTP Connect,    Status: %u",  a3,  v5);
      break;
    case 6u:
      BOOL v3 = +[NSString stringWithFormat:]( &OBJC_CLASS___NSString,  "stringWithFormat:",  @"UTP Disconnect, Reason: %u",  a3,  v5);
      break;
    case 7u:
      BOOL v3 = +[NSString stringWithFormat:]( &OBJC_CLASS___NSString,  "stringWithFormat:",  @"LE Connect,     Status: %u",  a3,  v5);
      break;
    case 8u:
      BOOL v3 = +[NSString stringWithFormat:]( &OBJC_CLASS___NSString,  "stringWithFormat:",  @"LE Disconnect,  Reason: %u",  a3,  v5);
      break;
    case 9u:
      BOOL v3 = +[NSString stringWithFormat:]( &OBJC_CLASS___NSString,  "stringWithFormat:",  @"Connect,        Accessory Initiated, Status: %u",  a3,  v5);
      break;
    case 0xAu:
      BOOL v3 = +[NSString stringWithFormat:]( &OBJC_CLASS___NSString,  "stringWithFormat:",  @"Connect,        Source Initiated, Status: %u",  a3,  v5);
      break;
    default:
      BOOL v3 = +[NSString stringWithFormat:]( &OBJC_CLASS___NSString,  "stringWithFormat:",  @"Unknown: %X,    Status: %u",  a2,  a3);
      break;
  }

  return v3;
}

uint64_t sub_10022E7D0(uint64_t a1, uint64_t a2, void *a3)
{
  v12[0] = 0LL;
  v12[1] = 0LL;
  sub_100242F28((uint64_t)v12, a1 + 360);
  if (qword_1008D5F50 != -1) {
    dispatch_once(&qword_1008D5F50, &stru_100888BF0);
  }
  LODWORD(__p[0]) = *(_DWORD *)a2;
  WORD2(__p[0]) = *(_WORD *)(a2 + 4);
  uint64_t v5 = sub_1003FFEB0(off_1008D5F48, (uint64_t)__p, 1);
  if (v5)
  {
    uint64_t v6 = a3[1] - *a3;
    int v7 = (os_log_s *)qword_1008F7560;
    if (os_log_type_enabled((os_log_t)qword_1008F7560, OS_LOG_TYPE_DEFAULT))
    {
      sub_1003CF00C((uint64_t)v5, __p);
      int v8 = v11 >= 0 ? __p : (void **)__p[0];
      *(_DWORD *)__int128 buf = 136446466;
      uint64_t v14 = v8;
      __int16 v15 = 1024;
      int v16 = (unsigned __int16)v6;
      _os_log_impl( (void *)&_mh_execute_header,  v7,  OS_LOG_TYPE_DEFAULT,  "Conversation Detect Message Received from device %{public}s, len -> %u",  buf,  0x12u);
      if (v11 < 0) {
        operator delete(__p[0]);
      }
    }

    if (qword_1008D5F40 != -1) {
      dispatch_once(&qword_1008D5F40, &stru_100888BB0);
    }
    sub_1003B25E0(off_1008D5F38, v5, (unsigned __int16)v6, *a3);
  }

  return sub_100242FAC((uint64_t)v12);
}

void sub_10022E978(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, ...)
{
}

uint64_t sub_10022E99C(uint64_t a1, uint64_t a2, uint64_t a3, unsigned __int8 **a4)
{
  v23[0] = 0LL;
  v23[1] = 0LL;
  sub_100242F28((uint64_t)v23, a1 + 360);
  if (qword_1008D5F50 != -1) {
    dispatch_once(&qword_1008D5F50, &stru_100888BF0);
  }
  *(_DWORD *)__int128 buf = *(_DWORD *)a2;
  LOWORD(v25) = *(_WORD *)(a2 + 4);
  int v7 = sub_1003FFEB0(off_1008D5F48, (uint64_t)buf, 1);
  uint64_t v8 = (uint64_t)*a4;
  int v9 = **a4;
  if (v9 == 1)
  {
    uint64_t v13 = *(unsigned __int8 *)(v8 + 1);
    uint64_t v14 = *(unsigned __int8 *)(v8 + 2);
    uint64_t v15 = *(unsigned __int8 *)(v8 + 3);
    uint64_t v16 = *(unsigned __int16 *)(v8 + 4);
    uint64_t v17 = *(unsigned __int16 *)(v8 + 6);
    uint64_t v18 = (os_log_s *)qword_1008F7560;
    if (os_log_type_enabled((os_log_t)qword_1008F7560, OS_LOG_TYPE_DEFAULT))
    {
      *(_DWORD *)__int128 buf = 67110144;
      int v25 = v13;
      __int16 v26 = 1024;
      int v27 = v14;
      __int16 v28 = 1024;
      int v29 = v15;
      __int16 v30 = 1024;
      int v31 = v16;
      __int16 v32 = 1024;
      int v33 = v17;
      _os_log_impl( (void *)&_mh_execute_header,  v18,  OS_LOG_TYPE_DEFAULT,  "AACPClient::adaptiveVolumeMessageRecvEvent: setAdaptiveVolumeRequestTargets media: %u, telephony: %u, voiceComma nd: %u, rampUpRate: %u ms, rampDownRate: %u ms",  buf,  0x20u);
    }

    char v19 = sub_10022EC94(a1, v13 | (v14 << 8) | (v15 << 16) | (v16 << 24) | (v17 << 40));
    uint64_t v20 = (void *)objc_claimAutoreleasedReturnValue(v19);
    if (qword_1008D6458 != -1) {
      dispatch_once(&qword_1008D6458, &stru_100888B90);
    }
    sub_100377C68((void *)qword_1008D6450, (uint64_t)v7, v20);
  }

  else if (v9 == 4)
  {
    int v10 = *(unsigned __int8 *)(v8 + 1);
    char v11 = (os_log_s *)qword_1008F7560;
    if (os_log_type_enabled((os_log_t)qword_1008F7560, OS_LOG_TYPE_DEFAULT))
    {
      int v12 = *(unsigned __int8 *)(v8 + 2);
      *(_DWORD *)__int128 buf = 67109376;
      int v25 = v10;
      __int16 v26 = 1024;
      int v27 = v12;
      _os_log_impl( (void *)&_mh_execute_header,  v11,  OS_LOG_TYPE_DEFAULT,  "AACPClient::adaptiveVolumeMessageRecvEvent: setDRC mode: %u, version: %u",  buf,  0xEu);
    }

    if (qword_1008D6458 != -1) {
      dispatch_once(&qword_1008D6458, &stru_100888B90);
    }
    sub_100377CEC((void *)qword_1008D6450, (uint64_t)v7, v10 == 1);
  }

  else
  {
    id v21 = (os_log_s *)qword_1008F7560;
    if (os_log_type_enabled((os_log_t)qword_1008F7560, OS_LOG_TYPE_DEFAULT))
    {
      *(_WORD *)__int128 buf = 0;
      _os_log_impl( (void *)&_mh_execute_header,  v21,  OS_LOG_TYPE_DEFAULT,  "AACPClient::adaptiveVolumeMessageRecvEvent: invalid message type",  buf,  2u);
    }
  }

  return sub_100242FAC((uint64_t)v23);
}

void sub_10022EC64( _Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9)
{
  sub_100242FAC((uint64_t)&a9);
  _Unwind_Resume(a1);
}

NSMutableDictionary *sub_10022EC94(uint64_t a1, unint64_t a2)
{
  v15[0] = 0LL;
  v15[1] = 0LL;
  sub_100242F28((uint64_t)v15, a1 + 360);
  BOOL v3 = objc_alloc_init(&OBJC_CLASS___NSMutableDictionary);
  *(float *)&double v4 = (float)a2 / 100.0;
  uint64_t v5 = (void *)[NSNumber numberWithFloat:v4];
  -[NSMutableDictionary setObject:forKey:](v3, "setObject:forKey:", v5, @"kCBMsgArgParamAutoVolumeMediaTarget");
  *(float *)&double v6 = (float)BYTE1(a2) / 100.0;
  int v7 = [+[NSNumber numberWithFloat:] floatValue];
  -[NSMutableDictionary setObject:forKey:]( v3,  "setObject:forKey:",  v7,  @"kCBMsgArgParamAutoVolumeTelephonyTarget");
  *(float *)&double v8 = (float)BYTE2(a2) / 100.0;
  int v9 = [NSNumber numberWithFloat:v8];
  -[NSMutableDictionary setObject:forKey:](v3, "setObject:forKey:", v9, @"kCBMsgArgParamAutoVolumeVoiceTarget");
  *(float *)&double v10 = (float)(unsigned __int16)(a2 >> 24);
  char v11 = (void *)objc_claimAutoreleasedReturnValue(+[NSNumber numberWithFloat:](&OBJC_CLASS___NSNumber, "numberWithFloat:", v10));
  -[NSMutableDictionary setObject:forKey:](v3, "setObject:forKey:", v11, @"kCBMsgArgParamAutoVolumeRampUpRate");
  *(float *)&double v12 = (float)(unsigned __int16)(HIDWORD(a2) >> 8);
  uint64_t v13 = (void *)[NSNumber numberWithFloat:v12];
  -[NSMutableDictionary setObject:forKey:](v3, "setObject:forKey:", v13, @"kCBMsgArgParamAutoVolumeRampDownRate");

  sub_100242FAC((uint64_t)v15);
  return v3;
}

void sub_10022EE24( _Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9)
{
  uint64_t v15 = v12;

  sub_100242FAC((uint64_t)&a9);
  _Unwind_Resume(a1);
}

void sub_10022EE84()
{
}

void sub_10022EE8C()
{
}

uint64_t sub_10022EE94(uint64_t a1, uint64_t a2, uint64_t a3)
{
  v8[0] = 0LL;
  v8[1] = 0LL;
  sub_100242F28((uint64_t)v8, a1 + 360);
  if (qword_1008D5F50 != -1) {
    dispatch_once(&qword_1008D5F50, &stru_100888BF0);
  }
  *(_DWORD *)__int128 buf = *(_DWORD *)a2;
  LOWORD(v10) = *(_WORD *)(a2 + 4);
  uint64_t v5 = sub_1003FFEB0(off_1008D5F48, (uint64_t)buf, 1);
  double v6 = (os_log_s *)qword_1008F7560;
  if (os_log_type_enabled((os_log_t)qword_1008F7560, OS_LOG_TYPE_DEFAULT))
  {
    *(_DWORD *)__int128 buf = 134217984;
    uint64_t v10 = a3;
    _os_log_impl( (void *)&_mh_execute_header,  v6,  OS_LOG_TYPE_DEFAULT,  "Prox Card Status: Received Prox Card Features: 0x%llx",  buf,  0xCu);
  }

  sub_1003D1E58((uint64_t)v5, a3);
  return sub_100242FAC((uint64_t)v8);
}

void sub_10022EFB4( _Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9)
{
}

void sub_10022EFD4(uint64_t a1, uint64_t a2, int a3, unsigned __int8 **a4)
{
  switch(a3)
  {
    case 0:
      uint64_t v6 = qword_1008F7560;
      if (os_log_type_enabled((os_log_t)qword_1008F7560, OS_LOG_TYPE_DEFAULT))
      {
        int v7 = (*a4)[8];
        int v8 = (char)(*a4)[7];
        int v9 = (*a4)[6];
        int v10 = (*a4)[5];
        int v11 = (*a4)[4];
        int v12 = (*a4)[3];
        int v13 = *(unsigned __int16 *)(*a4 + 1);
        int v14 = **a4;
        int v35 = 67110912;
        int v36 = v14;
        __int16 v37 = 1024;
        int v38 = v13;
        __int16 v39 = 1024;
        int v40 = v12;
        __int16 v41 = 1024;
        int v42 = v11;
        __int16 v43 = 1024;
        int v44 = v10;
        __int16 v45 = 1024;
        int v46 = v9;
        __int16 v47 = 1024;
        int v48 = v8;
        __int16 v49 = 1024;
        int v50 = v7;
        uint64_t v15 = "PerfStats: Connection Record | Direction: %u, Baseband time: %u, BBFC Scan Req Received: %u, Num 2.4G conn"
              "ections: %u, Num hrb connections: %u, UTP state: %u, RSSI: %u, Audio state: %u";
        uint64_t v16 = (os_log_s *)v6;
        uint32_t v17 = 50;
        goto LABEL_13;
      }

      break;
    case 1:
      uint64_t v19 = qword_1008F7560;
      if (os_log_type_enabled((os_log_t)qword_1008F7560, OS_LOG_TYPE_DEFAULT))
      {
        int v20 = *(unsigned __int16 *)(*a4 + 9);
        int v21 = *(unsigned __int16 *)(*a4 + 7);
        int v22 = *(unsigned __int16 *)(*a4 + 5);
        int v23 = *(unsigned __int16 *)(*a4 + 3);
        int v24 = *(unsigned __int16 *)(*a4 + 1);
        int v25 = **a4;
        int v35 = 67110400;
        int v36 = v25;
        __int16 v37 = 1024;
        int v38 = v24;
        __int16 v39 = 1024;
        int v40 = v23;
        __int16 v41 = 1024;
        int v42 = v22;
        __int16 v43 = 1024;
        int v44 = v21;
        __int16 v45 = 1024;
        int v46 = v20;
        uint64_t v15 = "PerfStats: Boot time Record | Boot type: %u, Boot time total: %u, Boot time end: %u, Boot time nvram init:"
              " %u, Boot time core loading: %u, UTP setup time: %u";
        uint64_t v16 = (os_log_s *)v19;
        uint32_t v17 = 38;
        goto LABEL_13;
      }

      break;
    case 2:
      uint64_t v26 = qword_1008F7560;
      if (os_log_type_enabled((os_log_t)qword_1008F7560, OS_LOG_TYPE_DEFAULT))
      {
        int v27 = *((unsigned __int16 *)*a4 + 3);
        int v28 = *((unsigned __int16 *)*a4 + 2);
        int v29 = *((unsigned __int16 *)*a4 + 1);
        int v30 = *(unsigned __int16 *)*a4;
        int v35 = 67109888;
        int v36 = v30;
        __int16 v37 = 1024;
        int v38 = v29;
        __int16 v39 = 1024;
        int v40 = v28;
        __int16 v41 = 1024;
        int v42 = v27;
        uint64_t v15 = "PerfStats: A2dp Record | AM setup: %u, DSP setup: %u, UTP config: %u, Snoop setup: %u";
        goto LABEL_12;
      }

      break;
    case 3:
      uint64_t v26 = qword_1008F7560;
      if (os_log_type_enabled((os_log_t)qword_1008F7560, OS_LOG_TYPE_DEFAULT))
      {
        int v31 = *((unsigned __int16 *)*a4 + 3);
        int v32 = *((unsigned __int16 *)*a4 + 2);
        int v33 = *((unsigned __int16 *)*a4 + 1);
        int v34 = *(unsigned __int16 *)*a4;
        int v35 = 67109888;
        int v36 = v34;
        __int16 v37 = 1024;
        int v38 = v33;
        __int16 v39 = 1024;
        int v40 = v32;
        __int16 v41 = 1024;
        int v42 = v31;
        uint64_t v15 = "PerfStats: Sco Record | AM setup: %u, DSP setup: %u, UTP config: %u, Snoop setup: %u";
LABEL_12:
        uint64_t v16 = (os_log_s *)v26;
        uint32_t v17 = 26;
        goto LABEL_13;
      }

      break;
    default:
      uint64_t v18 = qword_1008F7560;
      if (os_log_type_enabled((os_log_t)qword_1008F7560, OS_LOG_TYPE_DEFAULT))
      {
        int v35 = 67109120;
        int v36 = a3;
        uint64_t v15 = "Invalid subtype %d";
        uint64_t v16 = (os_log_s *)v18;
        uint32_t v17 = 8;
LABEL_13:
        _os_log_impl((void *)&_mh_execute_header, v16, OS_LOG_TYPE_DEFAULT, v15, (uint8_t *)&v35, v17);
      }

      break;
  }

uint64_t sub_10022F2CC(uint64_t a1, unsigned __int8 *a2, uint64_t a3, uint64_t a4)
{
  v11[0] = 0LL;
  v11[1] = 0LL;
  sub_100242F28((uint64_t)v11, a1 + 360);
  if (qword_1008D5F30 != -1) {
    dispatch_once(&qword_1008D5F30, &stru_100888C70);
  }
  sub_1005D0B84((uint64_t)off_1008D5F28, a2, v12);
  int v7 = sub_100241F94(v12);
  int v8 = (void *)objc_claimAutoreleasedReturnValue(v7);
  uint64_t v9 = sub_1002E8F6C();
  (*(void (**)(uint64_t, void *, uint64_t, uint64_t))(*(void *)v9 + 192LL))(v9, v8, a3, a4);

  return sub_100242FAC((uint64_t)v11);
}

void sub_10022F3B0(_Unwind_Exception *a1, uint64_t a2, ...)
{
  sub_100242FAC((uint64_t)va);
  _Unwind_Resume(a1);
}

uint64_t sub_10022F3D8(uint64_t a1, uint64_t a2, uint64_t *a3)
{
  v13[0] = 0LL;
  v13[1] = 0LL;
  sub_100242F28((uint64_t)v13, a1 + 360);
  if (sub_100223ABC(a1, a2))
  {
    if (qword_1008D5F50 != -1) {
      dispatch_once(&qword_1008D5F50, &stru_100888BF0);
    }
    LODWORD(__p[0]) = *(_DWORD *)a2;
    WORD2(__p[0]) = *(_WORD *)(a2 + 4);
    uint64_t v6 = sub_1003FFEB0(off_1008D5F48, (uint64_t)__p, 1);
    if (v6)
    {
      uint64_t v7 = a3[1] - *a3;
      int v8 = (os_log_s *)qword_1008F7560;
      if (os_log_type_enabled((os_log_t)qword_1008F7560, OS_LOG_TYPE_DEFAULT))
      {
        sub_1003CF00C((uint64_t)v6, __p);
        uint64_t v9 = v12 >= 0 ? __p : (void **)__p[0];
        *(_DWORD *)__int128 buf = 136446466;
        uint64_t v15 = v9;
        __int16 v16 = 1024;
        int v17 = (unsigned __int16)v7;
        _os_log_impl( (void *)&_mh_execute_header,  v8,  OS_LOG_TYPE_DEFAULT,  "Multimodal Context Message Received from device %{public}s, len -> %u",  buf,  0x12u);
        if (v12 < 0) {
          operator delete(__p[0]);
        }
      }

      if (qword_1008D5F40 != -1) {
        dispatch_once(&qword_1008D5F40, &stru_100888BB0);
      }
      sub_1003AED6C((uint64_t)off_1008D5F38, (uint64_t)v6, (unsigned __int16)v7, *a3);
    }
  }

  else if (os_log_type_enabled((os_log_t)qword_1008F7560, OS_LOG_TYPE_ERROR))
  {
    sub_1006616D4();
  }

  return sub_100242FAC((uint64_t)v13);
}

void sub_10022F5BC(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, ...)
{
}

uint64_t sub_10022F5E0(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t *a4)
{
  v15[0] = 0LL;
  v15[1] = 0LL;
  sub_100242F28((uint64_t)v15, a1 + 360);
  if (qword_1008D5F50 != -1) {
    dispatch_once(&qword_1008D5F50, &stru_100888BF0);
  }
  *(_DWORD *)__int128 buf = *(_DWORD *)a2;
  LOWORD(v1memset((char *)&v11[1] + 1, 0, 7) = *(_WORD *)(a2 + 4);
  uint64_t v6 = sub_1003FFEB0(off_1008D5F48, (uint64_t)buf, 1);
  if (v6)
  {
    uint64_t v7 = (unsigned __int8 *)*a4;
    uint64_t v8 = a4[1] - *a4;
    uint64_t v9 = (os_log_s *)qword_1008F7560;
    if (os_log_type_enabled((os_log_t)qword_1008F7560, OS_LOG_TYPE_DEFAULT))
    {
      int v10 = *v7;
      sub_1003CF00C((uint64_t)v6, __p);
      int v11 = v14 >= 0 ? __p : (void **)__p[0];
      *(_DWORD *)__int128 buf = 67109634;
      int v17 = v10;
      __int16 v18 = 2082;
      uint64_t v19 = v11;
      __int16 v20 = 1024;
      int v21 = (unsigned __int16)v8;
      _os_log_impl( (void *)&_mh_execute_header,  v9,  OS_LOG_TYPE_DEFAULT,  "PME Config Message, subtype %d received from device %{public}s, len -> %u",  buf,  0x18u);
      if (v14 < 0) {
        operator delete(__p[0]);
      }
    }

    if (qword_1008D5F40 != -1) {
      dispatch_once(&qword_1008D5F40, &stru_100888BB0);
    }
    sub_1003AF0D4((uint64_t)off_1008D5F38, (uint64_t)v6, (unsigned __int16)v8, *a4);
  }

  return sub_100242FAC((uint64_t)v15);
}

void sub_10022F798(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, ...)
{
}

uint64_t sub_10022F7BC(uint64_t a1, uint64_t a2, int a3, uint64_t *a4)
{
  v39[0] = 0LL;
  v39[1] = 0LL;
  sub_100242F28((uint64_t)v39, a1 + 360);
  uint64_t v8 = sub_100223ABC(a1, a2);
  uint64_t v9 = (os_log_s *)qword_1008F7560;
  if (v8)
  {
    uint64_t v34 = a2;
    int v35 = v8;
    if (os_log_type_enabled((os_log_t)qword_1008F7560, OS_LOG_TYPE_DEFAULT))
    {
      uint64_t v10 = (a4[1] - *a4) >> 3;
      *(_DWORD *)__int128 buf = 67109376;
      int v41 = a3;
      __int16 v42 = 2048;
      uint64_t v43 = v10;
      _os_log_impl( (void *)&_mh_execute_header,  v9,  OS_LOG_TYPE_DEFAULT,  "tipiTableEvent: Setting state %d and table of size %zu",  buf,  0x12u);
    }

    char v36 = a3;
    uint64_t v12 = *a4;
    uint64_t v11 = a4[1];
    if (v11 != *a4)
    {
      unint64_t v13 = 0LL;
      char v14 = (os_log_s *)qword_1008F7560;
      do
      {
        if (os_log_type_enabled(v14, OS_LOG_TYPE_DEFAULT))
        {
          uint64_t v22 = sub_1001EDE10(v12 + 8 * v13, v15, v16, v17, v18, v19, v20, v21);
          uint64_t v23 = *a4 + 8 * v13;
          int v24 = *(unsigned __int8 *)(v23 + 6);
          LODWORD(v23) = *(unsigned __int8 *)(v23 + 7);
          *(_DWORD *)__int128 buf = 67109891;
          int v41 = v13 + 1;
          __int16 v42 = 2081;
          uint64_t v43 = v22;
          __int16 v44 = 1024;
          int v45 = v24;
          __int16 v46 = 1024;
          int v47 = v23;
          _os_log_impl( (void *)&_mh_execute_header,  v14,  OS_LOG_TYPE_DEFAULT,  "tipiTableEvent:   Entry %d: addr %{private}s, connectionStatus %u, stateFlags 0x%02x",  buf,  0x1Eu);
          char v14 = (os_log_s *)qword_1008F7560;
          ++v13;
          uint64_t v12 = *a4;
          uint64_t v11 = a4[1];
        }

        else
        {
          ++v13;
        }
      }

      while (v13 < (v11 - v12) >> 3);
    }

    *((_BYTE *)v35 + 729) = v36;
    sub_100240540(&__p, (uint64_t)a4);
    if (__p)
    {
      int v38 = __p;
      operator delete(__p);
    }

    sub_100242F54((uint64_t)v39);
    int v25 = objc_alloc_init(&OBJC_CLASS___CBDevice);
    uint64_t v26 = -[NSData initWithBytes:length:](objc_alloc(&OBJC_CLASS___NSData), "initWithBytes:length:", v34, 6LL);
    -[CBDevice setBtAddressData:](v25, "setBtAddressData:", v26);

    int v27 = objc_alloc_init(&OBJC_CLASS___NSMutableArray);
    uint64_t v29 = *a4;
    uint64_t v28 = a4[1];
    while (v29 != v28)
    {
      int v30 = objc_alloc_init(&OBJC_CLASS___CBDevice);
      int v31 = -[NSData initWithBytes:length:](objc_alloc(&OBJC_CLASS___NSData), "initWithBytes:length:", v29, 6LL);
      -[CBDevice setBtAddressData:](v30, "setBtAddressData:", v31);

      -[CBDevice setTipiConnectionStatus:](v30, "setTipiConnectionStatus:", *(unsigned __int8 *)(v29 + 6));
      -[CBDevice setTipiState:](v30, "setTipiState:", *(unsigned __int8 *)(v29 + 7));
      -[NSMutableArray addObject:](v27, "addObject:", v30);

      uint64_t v28 = a4[1];
      v29 += 8LL;
    }

    -[CBDevice setTipiDevices:](v25, "setTipiDevices:", v27);
    int v32 = (void *)objc_claimAutoreleasedReturnValue(+[NSNotificationCenter defaultCenter](&OBJC_CLASS___NSNotificationCenter, "defaultCenter"));
    [v32 postNotificationName:@"com.apple.bluetooth.TipiChanged" object:v25 userInfo:0];
  }

  else if (os_log_type_enabled((os_log_t)qword_1008F7560, OS_LOG_TYPE_ERROR))
  {
    sub_100661700();
  }

  return sub_100242FAC((uint64_t)v39);
}

void sub_10022FB00( _Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, void *__p, uint64_t a17, uint64_t a18, char a19)
{
  if (__p) {
    operator delete(__p);
  }
  sub_100242FAC((uint64_t)&a19);
  _Unwind_Resume(a1);
}

uint64_t sub_10022FB8C(uint64_t a1, uint64_t a2, int a3, unsigned __int8 **a4)
{
  v14[0] = 0LL;
  v14[1] = 0LL;
  sub_100242F28((uint64_t)v14, a1 + 360);
  if (sub_100223ABC(a1, a2))
  {
    if (qword_1008D5F50 != -1) {
      dispatch_once(&qword_1008D5F50, &stru_100888BF0);
    }
    LODWORD(__p[0]) = *(_DWORD *)a2;
    WORD2(__p[0]) = *(_WORD *)(a2 + 4);
    uint64_t v8 = sub_1003FFEB0(off_1008D5F48, (uint64_t)__p, 1);
    if (v8)
    {
      if (qword_1008D60F0 != -1) {
        dispatch_once(&qword_1008D60F0, &stru_100888D50);
      }
      sub_1004A88C4((uint64_t)off_1008D60E8, (uint64_t)v8, **a4);
      uint64_t v9 = (os_log_s *)qword_1008F7560;
      if (os_log_type_enabled((os_log_t)qword_1008F7560, OS_LOG_TYPE_DEFAULT))
      {
        sub_1003CF00C((uint64_t)v8, __p);
        uint64_t v10 = v13 >= 0 ? __p : (void **)__p[0];
        *(_DWORD *)__int128 buf = 136446466;
        uint64_t v16 = v10;
        __int16 v17 = 1024;
        int v18 = a3;
        _os_log_impl( (void *)&_mh_execute_header,  v9,  OS_LOG_TYPE_DEFAULT,  "Sensor Streaming Config Message received from device %{public}s, version -> %u",  buf,  0x12u);
        if (v13 < 0) {
          operator delete(__p[0]);
        }
      }

      if (qword_1008D5F40 != -1) {
        dispatch_once(&qword_1008D5F40, &stru_100888BB0);
      }
      sub_1003B25E4((uint64_t)off_1008D5F38, (uint64_t)v8);
    }
  }

  else if (os_log_type_enabled((os_log_t)qword_1008F7560, OS_LOG_TYPE_ERROR))
  {
    sub_10066172C();
  }

  return sub_100242FAC((uint64_t)v14);
}

void sub_10022FDB4(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, ...)
{
}

void sub_10022FDD8(uint64_t a1, uint64_t a2, const UInt8 *a3, unsigned int a4, int a5, int a6)
{
  uint64_t v12 = (os_log_s *)qword_1008F7560;
  if (os_log_type_enabled((os_log_t)qword_1008F7560, OS_LOG_TYPE_DEFAULT))
  {
    *(_DWORD *)__int128 buf = 68159234;
    int v27 = 6;
    __int16 v28 = 2096;
    uint64_t v29 = a2;
    __int16 v30 = 1024;
    int v31 = a5;
    __int16 v32 = 1024;
    int v33 = a6;
    __int16 v34 = 1024;
    unsigned int v35 = a4;
    __int16 v36 = 1040;
    int v37 = 72;
    __int16 v38 = 2096;
    __int16 v39 = a3;
    _os_log_impl( (void *)&_mh_execute_header,  v12,  OS_LOG_TYPE_DEFAULT,  "Received GAPA signature response from %.6P version=%u endpointType=%u dataLen=%u data=%.72P",  buf,  0x34u);
  }

  char v13 = sub_100223ABC(a1, a2);
  if (v13)
  {
    char v14 = v13;
    uint64_t v15 = *v13;
    if (*v13)
    {
      *((_DWORD *)v13 + 150) = 3;
      uint64_t v16 = sub_1002E8D94();
      int v24 = *(_DWORD *)(v15 + 128);
      __int16 v25 = *(_WORD *)(v15 + 132);
      (*(void (**)(uint64_t, int *, uint64_t, void))(*(void *)v16 + 368LL))(v16, &v24, 5LL, 0LL);
      CFDataRef v17 = CFDataCreate(kCFAllocatorDefault, a3, a4);
      Mutable = CFDictionaryCreateMutable( kCFAllocatorDefault,  0LL,  &kCFTypeDictionaryKeyCallBacks,  &kCFTypeDictionaryValueCallBacks);
      CFDictionaryAddValue(Mutable, kCFACCProperties_Endpoint_AudioProduct_AuthData, v17);
      *(_DWORD *)__int128 buf = a6;
      CFNumberRef v19 = CFNumberCreate(kCFAllocatorDefault, kCFNumberIntType, buf);
      CFDictionaryAddValue(Mutable, kCFACCProperties_Endpoint_AudioProduct_AuthInfoType, v19);
      uint64_t v20 = CFArrayCreateMutable(0LL, 0LL, 0LL);
      CFArrayAppendValue(v20, Mutable);
      int v21 = acc_transportClient_setPropertyForEndpointWithUUID( kCFACCProperties_Endpoint_AudioProduct_AuthResponse,  v20,  v14[18]);
      uint64_t v22 = (os_log_s *)qword_1008F7560;
      if (v21)
      {
        if (os_log_type_enabled((os_log_t)qword_1008F7560, OS_LOG_TYPE_DEFAULT))
        {
          *(_WORD *)uint64_t v23 = 0;
          _os_log_impl( (void *)&_mh_execute_header,  v22,  OS_LOG_TYPE_DEFAULT,  "gapaResponseEvent: Published kCFACCProperties_Endpoint_AudioProduct_AuthResponse",  v23,  2u);
        }
      }

      else if (os_log_type_enabled((os_log_t)qword_1008F7560, OS_LOG_TYPE_ERROR))
      {
        sub_100661820();
      }

      CFArrayRemoveAllValues(v20);
      CFRelease(v20);
      CFRelease(Mutable);
      CFRelease(v17);
    }

    else if (os_log_type_enabled((os_log_t)qword_1008F7560, OS_LOG_TYPE_ERROR))
    {
      sub_1006617BC();
    }
  }

  else if (os_log_type_enabled((os_log_t)qword_1008F7560, OS_LOG_TYPE_ERROR))
  {
    sub_100661758();
  }

void sub_1002300B4(uint64_t a1, uint64_t a2, int a3)
{
  if (a3 == 4098)
  {
    v7[8] = v3;
    v7[9] = v4;
    if (qword_1008D9118 != -1) {
      dispatch_once(&qword_1008D9118, &stru_100888C30);
    }
    v7[0] = _NSConcreteStackBlock;
    v7[1] = 3221225472LL;
    void v7[2] = sub_100230150;
    void v7[3] = &unk_10087F8E0;
    void v7[4] = a1;
    void v7[5] = a2;
    sub_10041C1EC((uint64_t)off_1008D9110, v7);
  }

uint64_t sub_100230150(uint64_t a1)
{
  uint64_t v2 = *(void *)(a1 + 32);
  v27[0] = 0LL;
  v27[1] = 0LL;
  sub_100242F28((uint64_t)v27, v2 + 360);
  uint64_t v3 = *(void *)(a1 + 40);
  if (v3)
  {
    for (uint64_t i = *(void **)(v2 + 336); ; ++i)
    {
      if (i == *(void **)(v2 + 344)) {
        return sub_100242FAC((uint64_t)v27);
      }
      uint64_t v5 = (void *)*i;
      if (*(void *)*i == v3) {
        break;
      }
    }

    sub_1003D0100(v3, (uint64_t)&__p);
    uint64_t v6 = (std::string *)(v5 + 7);
    if (*((char *)v5 + 79) < 0)
    {
      sub_100024238(__n, (void *)v5[7], v5[8]);
    }

    else
    {
      *(_OWORD *)__n = *(_OWORD *)&v6->__r_.__value_.__l.__data_;
      uint64_t v29 = v5[9];
    }

    int v7 = SHIBYTE(v29);
    uint64_t v8 = (void *)__n[0];
    unsigned __int8 v9 = v26;
    if ((v26 & 0x80u) == 0) {
      size_t v10 = v26;
    }
    else {
      size_t v10 = __size;
    }
    if ((v26 & 0x80u) == 0) {
      p_p = &__p;
    }
    else {
      p_p = __p;
    }
    if (v29 >= 0) {
      size_t v12 = HIBYTE(v29);
    }
    else {
      size_t v12 = __n[1];
    }
    if (v29 >= 0) {
      char v13 = __n;
    }
    else {
      char v13 = (size_t *)__n[0];
    }
    if (v12 >= v10) {
      size_t v14 = v10;
    }
    else {
      size_t v14 = v12;
    }
    BOOL v15 = memcmp(p_p, v13, v14) == 0;
    BOOL v16 = v12 == v10 && v15;
    if (v7 < 0)
    {
      operator delete(v8);
      if ((v26 & 0x80) == 0)
      {
LABEL_29:
        if (v16) {
          return sub_100242FAC((uint64_t)v27);
        }
LABEL_33:
        sub_1003D0100(*(void *)(a1 + 40), (uint64_t)&__p);
        if ((char)v26 < 0)
        {
          CFDataRef v17 = malloc(__size);
          operator delete(__p);
        }

        else
        {
          CFDataRef v17 = malloc(v26);
        }

        int v18 = &__p;
        sub_1003D0100(*(void *)(a1 + 40), (uint64_t)&__p);
        if ((v26 & 0x80u) != 0) {
          int v18 = __p;
        }
        sub_1003D0100(*(void *)(a1 + 40), (uint64_t)__n);
        if (SHIBYTE(v29) < 0)
        {
          memcpy(v17, v18, __n[1]);
          operator delete((void *)__n[0]);
        }

        else
        {
          memcpy(v17, v18, HIBYTE(v29));
        }

        uint64_t v19 = *(void *)(a1 + 40);
        sub_1003D0100(v19, (uint64_t)&__p);
        unsigned __int16 v20 = v26;
        if ((v26 & 0x80u) != 0) {
          unsigned __int16 v20 = __size;
        }
        int v21 = sub_100215188(v2, v19, v20, v17);
        if (v21 && os_log_type_enabled((os_log_t)qword_1008F7560, OS_LOG_TYPE_ERROR))
        {
          sub_1003D0100(*(void *)(a1 + 40), (uint64_t)&__p);
          sub_10066184C();
        }

        sub_1003D0100(*(void *)(a1 + 40), (uint64_t)&v23);
        std::string::operator=(v6, &v23);
        free(v17);
        return sub_100242FAC((uint64_t)v27);
      }
    }

    else if ((v9 & 0x80) == 0)
    {
      goto LABEL_29;
    }

    operator delete(__p);
    if (v16) {
      return sub_100242FAC((uint64_t)v27);
    }
    goto LABEL_33;
  }

  return sub_100242FAC((uint64_t)v27);
}

void sub_100230414( _Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, int a11, __int16 a12, char a13, char a14, void *__p, uint64_t a16, int a17, __int16 a18, char a19, char a20, char a21)
{
}

void sub_100230478(uint64_t a1, uint64_t a2, int a3)
{
}

void sub_100230480(uint64_t a1, int a2)
{
  if (a2) {
    uint64_t v3 = 1LL;
  }
  else {
    uint64_t v3 = 2LL;
  }
  uint64_t v4 = (os_log_s *)qword_1008F7560;
  if (os_log_type_enabled((os_log_t)qword_1008F7560, OS_LOG_TYPE_DEFAULT))
  {
    uint64_t v5 = "unknown";
    else {
      uint64_t v6 = (char *)v5;
    }
    sub_10002418C(__p, v6);
    if (v12 >= 0) {
      int v7 = __p;
    }
    else {
      int v7 = (void **)__p[0];
    }
    *(_DWORD *)__int128 buf = 136446210;
    size_t v14 = v7;
    _os_log_impl( (void *)&_mh_execute_header,  v4,  OS_LOG_TYPE_DEFAULT,  "VoiceTriggerSetting changed to %{public}s",  buf,  0xCu);
    if (v12 < 0) {
      operator delete(__p[0]);
    }
  }

  uint64_t v8 = *(uint64_t ***)(a1 + 336);
  unsigned __int8 v9 = *(uint64_t ***)(a1 + 344);
  while (v8 != v9)
  {
    uint64_t v10 = **v8;
    if (!*(_BYTE *)(v10 + 960)) {
      sub_100215778(a1, v10, 18LL, v3, 2u);
    }
    ++v8;
  }

void sub_1002305C4(uint64_t a1, int a2)
{
}

void sub_1002305CC(uint64_t a1, void *a2)
{
  id v3 = a2;
  uint64_t v8 = 0LL;
  unsigned __int8 v9 = 0LL;
  uint64_t v10 = 0LL;
  sub_10053C3D8(&v8);
  if (qword_1008D90F8 != -1) {
    dispatch_once(&qword_1008D90F8, &stru_100888B10);
  }
  if (sub_10054AA1C((uint64_t)off_1008D90F0))
  {
    if (os_log_type_enabled((os_log_t)qword_1008F7560, OS_LOG_TYPE_ERROR)) {
      sub_1006618B0();
    }
  }

  else
  {
    uint64_t v4 = sub_10053C584(&v8, v3);
    if (v9 == v4)
    {
      *(_DWORD *)(a1 + 500) = 0;
    }

    else
    {
      int v5 = *((_DWORD *)v4 + 4);
      *(_DWORD *)(a1 + 500) = v5;
      uint64_t v6 = (os_log_s *)qword_1008F7560;
      if (os_log_type_enabled((os_log_t)qword_1008F7560, OS_LOG_TYPE_DEFAULT))
      {
        else {
          int v7 = off_100889068[v5 - 1];
        }
        *(_DWORD *)__int128 buf = 136315138;
        *(void *)&uint8_t buf[4] = v7;
        _os_log_impl((void *)&_mh_execute_header, v6, OS_LOG_TYPE_DEFAULT, "Call status is now %s", buf, 0xCu);
      }
    }
  }

  *(void *)__int128 buf = &v8;
  sub_1002077E0((void ***)buf);
}

void sub_100230750( _Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, char a10, uint64_t a11, uint64_t a12, void **a13)
{
  a13 = (void **)&a10;
  sub_1002077E0(&a13);

  _Unwind_Resume(a1);
}

void sub_100230784(uint64_t a1, void *a2)
{
}

void sub_10023078C(uint64_t a1, uint64_t a2)
{
  if (a2)
  {
    if (*(_DWORD *)(a2 + 80) == 8194)
    {
      uint64_t v3 = *(void *)a2;
      if (*(void *)a2)
      {
        uint64_t v4 = (os_log_s *)qword_1008F7560;
        if (os_log_type_enabled((os_log_t)qword_1008F7560, OS_LOG_TYPE_DEFAULT))
        {
          sub_1003D0100(v3, (uint64_t)__p);
          int v5 = v13 >= 0 ? __p : *(_BYTE **)__p;
          uint64_t v6 = *(void *)(a2 + 112);
          uint64_t v7 = *(void *)(a2 + 120);
          *(_DWORD *)__int128 buf = 141558787;
          *(void *)&uint8_t buf[4] = 1752392040LL;
          __int16 v15 = 2081;
          BOOL v16 = v5;
          __int16 v17 = 2112;
          uint64_t v18 = v6;
          __int16 v19 = 2112;
          uint64_t v20 = v7;
          _os_log_impl( (void *)&_mh_execute_header,  v4,  OS_LOG_TYPE_DEFAULT,  "unPublishW1RemoteFirmware: Un-Publishing F/W version for %{private, mask.hash}s (connection %@ endpoint %@)",  buf,  0x2Au);
          if (v13 < 0) {
            operator delete(*(void **)__p);
          }
        }

        if ((unsigned __int16)(*(void *)(a2 + 85) >> 24) | ((unsigned __int16)WORD2(*(void *)(a2 + 85)) >> 8))
        {
          if (*(void *)(a2 + 112))
          {
            if ((acc_transportClient_destroyConnection() & 1) == 0
              && os_log_type_enabled((os_log_t)qword_1008F7560, OS_LOG_TYPE_ERROR))
            {
              sub_100661908();
            }

            CFRelease(*(CFTypeRef *)(a2 + 120));
            *(void *)(a2 + 120) = 0LL;
            CFRelease(*(CFTypeRef *)(a2 + 112));
            *(void *)(a2 + 112) = 0LL;
          }
        }

        else
        {
          uint64_t v8 = (os_log_s *)qword_1008F7560;
          if (os_log_type_enabled((os_log_t)qword_1008F7560, OS_LOG_TYPE_DEFAULT))
          {
            sub_1003D0100(v3, (uint64_t)buf);
            unsigned __int8 v9 = v17 >= 0 ? buf : *(_BYTE **)buf;
            *(_DWORD *)std::string __p = 141558275;
            *(void *)&__p[4] = 1752392040LL;
            __int16 v11 = 2081;
            char v12 = v9;
            _os_log_impl( (void *)&_mh_execute_header,  v8,  OS_LOG_TYPE_DEFAULT,  "Warning: unPublishW1RemoteFirmware: No case version info available for %{private, mask.hash}s",  __p,  0x16u);
            if (SHIBYTE(v17) < 0) {
              operator delete(*(void **)buf);
            }
          }
        }
      }
    }
  }

  else if (os_log_type_enabled((os_log_t)qword_1008F7560, OS_LOG_TYPE_ERROR))
  {
    sub_1006618DC();
  }

BOOL sub_1002309E0(uint64_t a1, uint64_t *a2, void *a3, CFStringRef theString2, const __CFString *a5)
{
  uint64_t v8 = sub_100230AD4(a1, theString2);
  *a2 = v8;
  if (!v8)
  {
    BOOL result = os_log_type_enabled((os_log_t)qword_1008F7560, OS_LOG_TYPE_ERROR);
    if (!result) {
      return result;
    }
    sub_100661934();
    return 0LL;
  }

  if (CFStringCompare(a5, *(CFStringRef *)(v8 + 144), 0LL))
  {
    BOOL result = os_log_type_enabled((os_log_t)qword_1008F7560, OS_LOG_TYPE_ERROR);
    if (!result) {
      return result;
    }
    sub_1006619FC();
    return 0LL;
  }

  uint64_t v10 = *(void *)*a2;
  *a3 = v10;
  if (v10) {
    return 1LL;
  }
  BOOL result = os_log_type_enabled((os_log_t)qword_1008F7560, OS_LOG_TYPE_ERROR);
  if (result)
  {
    sub_100661998();
    return 0LL;
  }

  return result;
}

uint64_t sub_100230AD4(uint64_t a1, CFStringRef theString2)
{
  if (theString2)
  {
    uint64_t v4 = *(uint64_t **)(a1 + 336);
    for (uint64_t i = *(uint64_t **)(a1 + 344); v4 != i; ++v4)
    {
      uint64_t v6 = *v4;
      if (*v4)
      {
        uint64_t v7 = *(const __CFString **)(v6 + 128);
        if (v7)
        {
          if (CFStringCompare(v7, theString2, 0LL) == kCFCompareEqualTo) {
            return v6;
          }
          uint64_t i = *(uint64_t **)(a1 + 344);
        }
      }
    }
  }

  return 0LL;
}

uint64_t sub_100230B44(uint64_t a1, const __CFString *a2, const __CFString *a3, const __CFData *a4)
{
  uint64_t v8 = *(void *)(a1 + 32);
  v20[0] = 0LL;
  v20[1] = 0LL;
  sub_100242F28((uint64_t)v20, v8 + 360);
  uint64_t v9 = sub_100230AD4(v8, a2);
  if (v9)
  {
    uint64_t v10 = *(void *)v9;
    if (*(void *)v9)
    {
      if (CFStringCompare(a3, *(CFStringRef *)(v9 + 136), 0LL))
      {
        if (os_log_type_enabled((os_log_t)qword_1008F7560, OS_LOG_TYPE_ERROR)) {
          sub_100661AD0();
        }
      }

      else
      {
        char v19 = 0;
        sub_100242CA4(&v19);
        unsigned __int16 Length = CFDataGetLength(a4);
        BytePtr = CFDataGetBytePtr(a4);
        int v13 = sub_100080064((unsigned __int8 *)(v10 + 128), Length, BytePtr);
        sub_100242CD0(&v19);
        size_t v14 = (os_log_s *)qword_1008F7560;
        if (os_log_type_enabled((os_log_t)qword_1008F7560, OS_LOG_TYPE_DEFAULT))
        {
          sub_1003CF00C(*(void *)(a1 + 40), __p);
          __int16 v15 = v18 >= 0 ? __p : (void **)__p[0];
          *(_DWORD *)__int128 buf = 136446466;
          uint64_t v22 = v15;
          __int16 v23 = 1024;
          int v24 = v13;
          _os_log_impl( (void *)&_mh_execute_header,  v14,  OS_LOG_TYPE_DEFAULT,  "publishAccRemoteFirmware auth data: Data sent to device %{public}s, status %d",  buf,  0x12u);
          if (v18 < 0) {
            operator delete(__p[0]);
          }
        }

        sub_100242CD8(&v19);
      }
    }
  }

  else if (os_log_type_enabled((os_log_t)qword_1008F7560, OS_LOG_TYPE_ERROR))
  {
    sub_100661A6C();
  }

  return sub_100242FAC((uint64_t)v20);
}

void sub_100230D28( _Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, int a12, __int16 a13, char a14, char a15, char a16)
{
}

uint64_t sub_100230D60(uint64_t a1, const __CFString *a2, const __CFString *a3, const __CFData *a4)
{
  uint64_t v7 = *(void *)(a1 + 32);
  v23[0] = 0LL;
  v23[1] = 0LL;
  sub_100242F28((uint64_t)v23, v7 + 360);
  uint64_t v8 = (uint64_t *)sub_100230AD4(v7, a2);
  uint64_t v9 = v8;
  if (v8)
  {
    uint64_t v10 = *v8;
    if (*v8)
    {
      unsigned int v11 = sub_100230FD0(v7, a2, a3);
      int v12 = v11;
      if (v11 <= 0x1F && (uint64_t v13 = v9[v11 + 20]) != 0 && *(void *)(v13 + 88))
      {
        if (*(_BYTE *)(v13 + 97))
        {
          unsigned int Length = CFDataGetLength(a4);
          BytePtr = CFDataGetBytePtr(a4);
          sub_100231044(v9, v12, Length, (uint64_t)BytePtr);
          return sub_100242FAC((uint64_t)v23);
        }

        BOOL v16 = (os_log_s *)qword_1008F7560;
        if (!os_log_type_enabled((os_log_t)qword_1008F7560, OS_LOG_TYPE_ERROR)) {
          return sub_100242FAC((uint64_t)v23);
        }
        sub_1003CF00C(v10, __p);
        if (v22 >= 0) {
          char v18 = __p;
        }
        else {
          char v18 = (void **)__p[0];
        }
        *(_DWORD *)__int128 buf = 136446722;
        __int16 v25 = v18;
        __int16 v26 = 2112;
        int v27 = a3;
        __int16 v28 = 1024;
        int v29 = v12;
        char v19 = "publishAccRemoteFirmware EA data: EA session currently closed on device %{public}s for endpoint %@ index %d";
      }

      else
      {
        BOOL v16 = (os_log_s *)qword_1008F7560;
        if (!os_log_type_enabled((os_log_t)qword_1008F7560, OS_LOG_TYPE_ERROR)) {
          return sub_100242FAC((uint64_t)v23);
        }
        sub_1003CF00C(v10, __p);
        if (v22 >= 0) {
          uint64_t v20 = __p;
        }
        else {
          uint64_t v20 = (void **)__p[0];
        }
        *(_DWORD *)__int128 buf = 136446722;
        __int16 v25 = v20;
        __int16 v26 = 2112;
        int v27 = a3;
        __int16 v28 = 1024;
        int v29 = v12;
        char v19 = "publishAccRemoteFirmware EA data: device %{public}s has no endpoint %@ (index = %d)";
      }

      _os_log_error_impl((void *)&_mh_execute_header, v16, OS_LOG_TYPE_ERROR, v19, buf, 0x1Cu);
      if (v22 < 0) {
        operator delete(__p[0]);
      }
    }
  }

  else if (os_log_type_enabled((os_log_t)qword_1008F7560, OS_LOG_TYPE_ERROR))
  {
    sub_100661B3C();
  }

  return sub_100242FAC((uint64_t)v23);
}

void sub_100230FA4(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, ...)
{
}

uint64_t sub_100230FD0(uint64_t a1, const __CFString *a2, const __CFString *a3)
{
  LOBYTE(v3) = -1;
  if (a2 && a3)
  {
    uint64_t v5 = sub_100230AD4(a1, a2);
    if (v5)
    {
      uint64_t v3 = 0LL;
      uint64_t v6 = v5 + 160;
      while (1)
      {
        uint64_t v7 = *(void *)(v6 + 8 * v3);
        if (v7)
        {
          uint64_t v8 = *(const __CFString **)(v7 + 88);
          if (v8)
          {
            if (CFStringCompare(a3, v8, 0LL) == kCFCompareEqualTo) {
              break;
            }
          }
        }

        if (++v3 == 32) {
          goto LABEL_9;
        }
      }
    }

    else
    {
LABEL_9:
      LOBYTE(v3) = -1;
    }
  }

  return v3;
}

uint64_t sub_100231044(uint64_t *a1, int a2, unsigned int a3, uint64_t a4)
{
  v27[0] = 0LL;
  v27[1] = 0LL;
  sub_100242F28((uint64_t)v27, (uint64_t)(a1 + 55));
  uint64_t v23 = a1[54];
  unsigned int v22 = a3;
  if (a3)
  {
    uint64_t v7 = 0LL;
    uint64_t v8 = v23 + 1;
    unsigned __int16 v9 = v22;
    do
    {
      uint64_t v10 = operator new(0x10uLL);
      unsigned int v11 = v10;
      unint64_t v12 = v7 + 1005;
      else {
        unsigned __int16 v13 = v9;
      }
      *(_BYTE *)uint64_t v10 = a2;
      v10[1] = v13;
      size_t v14 = v13;
      __int16 v15 = operator new[](v13);
      *((void *)v11 + 1) = v15;
      memcpy(v15, (const void *)(a4 + v7), v14);
      BOOL v16 = operator new(0x18uLL);
      v16[1] = a1 + 52;
      void v16[2] = v11;
      uint64_t v17 = a1[52];
      *BOOL v16 = v17;
      *(void *)(v17 + std::ostream::~ostream(v2, v3 + 8) = v16;
      a1[52] = (uint64_t)v16;
      a1[54] = v8++;
      v9 -= 1005;
      v7 += 1005LL;
    }

    while (v12 < v22);
  }

  sub_100242F54((uint64_t)v27);
  if (!v23)
  {
    char v18 = (os_log_s *)qword_1008F7560;
    if (os_log_type_enabled((os_log_t)qword_1008F7560, OS_LOG_TYPE_INFO))
    {
      sub_1003D0100(*a1, (uint64_t)__p);
      if (v26 >= 0) {
        char v19 = __p;
      }
      else {
        char v19 = (void **)__p[0];
      }
      uint64_t v20 = a1[54];
      *(_DWORD *)__int128 buf = 67110147;
      unsigned int v29 = v22;
      __int16 v30 = 2160;
      uint64_t v31 = 1752392040LL;
      __int16 v32 = 2081;
      int v33 = v19;
      __int16 v34 = 1024;
      int v35 = a2;
      __int16 v36 = 2048;
      uint64_t v37 = v20;
      _os_log_impl( (void *)&_mh_execute_header,  v18,  OS_LOG_TYPE_INFO,  "addEASessionData: Queueing %d bytes for %{private, mask.hash}s (index %d), queue size now %lu",  buf,  0x2Cu);
      if (v26 < 0) {
        operator delete(__p[0]);
      }
    }

    sub_100223B00(a1);
  }

  return sub_100242FAC((uint64_t)v27);
}

void sub_100231258( _Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, ...)
{
}

uint64_t sub_10023128C( uint64_t a1, const __CFString *a2, uint64_t a3, const __CFBoolean *a4, uint64_t a5, const __CFString *a6)
{
  uint64_t v9 = *(void *)(a1 + 32);
  v27[0] = 0LL;
  v27[1] = 0LL;
  sub_100242F28((uint64_t)v27, v9 + 360);
  uint64_t v10 = (uint64_t *)sub_100230AD4(v9, a6);
  unsigned int v11 = v10;
  if (v10)
  {
    uint64_t v12 = *v10;
    if (*v10)
    {
      unsigned int v13 = sub_100230FD0(v9, a6, a2);
      unsigned int v14 = v13;
      if (v13 <= 0x1F && (uint64_t v15 = v11[v13 + 20]) != 0 && *(void *)(v15 + 88))
      {
        BOOL v16 = (os_log_s *)qword_1008F7560;
        if (os_log_type_enabled((os_log_t)qword_1008F7560, OS_LOG_TYPE_DEFAULT))
        {
          sub_1003CF00C(v12, __p);
          uint64_t v17 = v26 >= 0 ? __p : (void **)__p[0];
          *(_DWORD *)__int128 buf = 136446978;
          unsigned int v29 = v17;
          __int16 v30 = 2112;
          uint64_t v31 = a2;
          __int16 v32 = 1024;
          unsigned int v33 = v14;
          __int16 v34 = 1024;
          BOOL v35 = kCFBooleanFalse != a4;
          _os_log_impl( (void *)&_mh_execute_header,  v16,  OS_LOG_TYPE_DEFAULT,  "publishAccRemoteFirmware EA property: Switching EA session for device %{public}s endpoint %@ index %d: enable = %d",  buf,  0x22u);
          if (v26 < 0) {
            operator delete(__p[0]);
          }
        }

        *(_BYTE *)(v15 + 9memset((char *)&v11[1] + 1, 0, 7) = kCFBooleanFalse != a4;
        char v24 = 0;
        sub_100242CA4(&v24);
        int v18 = sub_10007FE10((unsigned __int8 *)(v12 + 128), v14, kCFBooleanFalse != a4);
        sub_100242CD0(&v24);
        sub_100242F54((uint64_t)v27);
        if (v18)
        {
          char v19 = (os_log_s *)qword_1008F7560;
          if (os_log_type_enabled((os_log_t)qword_1008F7560, OS_LOG_TYPE_ERROR))
          {
            sub_1003CF00C(v12, __p);
            if (v26 >= 0) {
              uint64_t v23 = __p;
            }
            else {
              uint64_t v23 = (void **)__p[0];
            }
            *(_DWORD *)__int128 buf = 136446978;
            unsigned int v29 = v23;
            __int16 v30 = 2112;
            uint64_t v31 = a2;
            __int16 v32 = 1024;
            unsigned int v33 = v14;
            __int16 v34 = 1024;
            BOOL v35 = v18;
            _os_log_error_impl( (void *)&_mh_execute_header,  v19,  OS_LOG_TYPE_ERROR,  "publishAccRemoteFirmware EA property: Error sending EA session switch for device %{public}s endpoint %@ index %d: %d",  buf,  0x22u);
            if (v26 < 0) {
              operator delete(__p[0]);
            }
          }
        }

        sub_100242CD8(&v24);
      }

      else
      {
        uint64_t v20 = (os_log_s *)qword_1008F7560;
        if (os_log_type_enabled((os_log_t)qword_1008F7560, OS_LOG_TYPE_ERROR))
        {
          sub_1003CF00C(v12, __p);
          unsigned int v22 = v26 >= 0 ? __p : (void **)__p[0];
          *(_DWORD *)__int128 buf = 136446722;
          unsigned int v29 = v22;
          __int16 v30 = 2112;
          uint64_t v31 = a2;
          __int16 v32 = 1024;
          unsigned int v33 = v14;
          _os_log_error_impl( (void *)&_mh_execute_header,  v20,  OS_LOG_TYPE_ERROR,  "publishAccRemoteFirmware EA property: device %{public}s has no endpoint %@ (index = %d)",  buf,  0x1Cu);
          if (v26 < 0) {
            operator delete(__p[0]);
          }
        }
      }
    }
  }

  else if (os_log_type_enabled((os_log_t)qword_1008F7560, OS_LOG_TYPE_ERROR))
  {
    sub_100661BA0();
  }

  return sub_100242FAC((uint64_t)v27);
}

void sub_1002315D4(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, ...)
{
}

uint64_t sub_100231618( uint64_t a1, const __CFString *a2, uint64_t a3, const void *a4, uint64_t a5, const __CFString *a6)
{
  uint64_t v11 = *(void *)(a1 + 32);
  v40[0] = 0LL;
  v40[1] = 0LL;
  sub_100242F28((uint64_t)v40, v11 + 360);
  uint64_t v12 = (os_log_s *)qword_1008F7560;
  if (os_log_type_enabled((os_log_t)qword_1008F7560, OS_LOG_TYPE_DEFAULT))
  {
    *(_DWORD *)__int128 buf = 138412546;
    *(void *)__int16 v42 = a3;
    *(_WORD *)&v42[8] = 2112;
    *(void *)&v42[10] = a4;
    _os_log_impl( (void *)&_mh_execute_header,  v12,  OS_LOG_TYPE_DEFAULT,  "publishAccRemoteFirmware acc_transportClient_setEndpointPropertyDidChangeHandler GAPA handler property=%@ value=%@",  buf,  0x16u);
  }

  if (a4)
  {
    uint64_t v38 = 0LL;
    uint64_t v39 = 0LL;
    if (sub_1002309E0(v11, &v39, &v38, a6, a2))
    {
      uint64_t v13 = v39;
      if (*(_DWORD *)(v39 + 600) == 1)
      {
        CFTypeID v14 = CFGetTypeID(a4);
        if (v14 == CFArrayGetTypeID())
        {
          if (CFArrayGetCount((CFArrayRef)a4) == 1)
          {
            ValueAtIndex = CFArrayGetValueAtIndex((CFArrayRef)a4, 0LL);
            CFTypeID v16 = CFGetTypeID(ValueAtIndex);
            if (v16 == CFDictionaryGetTypeID())
            {
              uint64_t v17 = (const __CFDictionary *)CFArrayGetValueAtIndex((CFArrayRef)a4, 0LL);
              int v18 = v17;
              if (v17)
              {
                char v19 = (const void *)kCFACCProperties_Endpoint_AudioProduct_AuthData;
                Value = CFDictionaryGetValue(v17, kCFACCProperties_Endpoint_AudioProduct_AuthData);
                CFTypeID v21 = CFGetTypeID(Value);
                if (v21 == CFDataGetTypeID())
                {
                  unsigned int v22 = (const __CFData *)CFDictionaryGetValue(v18, v19);
                  uint64_t v23 = v22;
                  if (v22)
                  {
                    BytePtr = CFDataGetBytePtr(v22);
                    unsigned __int16 Length = CFDataGetLength(v23);
                    char v26 = (unsigned __int8 *)(v38 + 128);
                    int v27 = (os_log_s *)qword_1008F7560;
                    BOOL v28 = os_log_type_enabled((os_log_t)qword_1008F7560, OS_LOG_TYPE_DEFAULT);
                    if (v28)
                    {
                      *(_DWORD *)__int128 buf = 68158978;
                      *(_DWORD *)__int16 v42 = 6;
                      *(_WORD *)&v42[4] = 2096;
                      *(void *)&v42[6] = v26;
                      *(_WORD *)&v42[14] = 1024;
                      *(_DWORD *)&v42[16] = 1;
                      __int16 v43 = 1024;
                      int v44 = Length;
                      __int16 v45 = 1040;
                      int v46 = 32;
                      __int16 v47 = 2096;
                      int v48 = BytePtr;
                      _os_log_impl( (void *)&_mh_execute_header,  v27,  OS_LOG_TYPE_DEFAULT,  "Send gapa auth challenge to wx %.6P version=%u (%hu bytes) %.32P",  buf,  0x2Eu);
                    }

                    int v29 = sub_100231AD0(v28, v26, BytePtr, Length, 1);
                    __int16 v30 = (os_log_s *)qword_1008F7560;
                    if (os_log_type_enabled((os_log_t)qword_1008F7560, OS_LOG_TYPE_DEFAULT))
                    {
                      *(_DWORD *)__int128 buf = 67109120;
                      *(_DWORD *)__int16 v42 = v29;
                      _os_log_impl( (void *)&_mh_execute_header,  v30,  OS_LOG_TYPE_DEFAULT,  "publishAccRemoteFirmware GAPA handler: BT_AACP_CLIENT_GAPASendChallenge result %d",  buf,  8u);
                    }

                    *(_DWORD *)(v13 + 600) = 2;
                    uint64_t v31 = sub_1002E8D94();
                    uint64_t v32 = *(void *)(a1 + 40);
                    int v36 = *(_DWORD *)(v32 + 128);
                    __int16 v37 = *(_WORD *)(v32 + 132);
                    (*(void (**)(uint64_t, int *, uint64_t, void))(*(void *)v31 + 368LL))( v31,  &v36,  4LL,  0LL);
                  }

                  else if (os_log_type_enabled((os_log_t)qword_1008F7560, OS_LOG_TYPE_ERROR))
                  {
                    sub_100661C5C();
                  }
                }

                else if (os_log_type_enabled((os_log_t)qword_1008F7560, OS_LOG_TYPE_ERROR))
                {
                  __int16 v34 = CFDictionaryGetValue(v18, v19);
                  CFGetTypeID(v34);
                  CFDataGetTypeID();
                  sub_100661C88();
                }
              }

              else if (os_log_type_enabled((os_log_t)qword_1008F7560, OS_LOG_TYPE_ERROR))
              {
                sub_100661C30();
              }
            }

            else if (os_log_type_enabled((os_log_t)qword_1008F7560, OS_LOG_TYPE_ERROR))
            {
              unsigned int v33 = CFArrayGetValueAtIndex((CFArrayRef)a4, 0LL);
              CFGetTypeID(v33);
              CFDictionaryGetTypeID();
              sub_100661CC0();
            }
          }

          else if (os_log_type_enabled((os_log_t)qword_1008F7560, OS_LOG_TYPE_ERROR))
          {
            sub_100661CF8();
          }
        }

        else if (os_log_type_enabled((os_log_t)qword_1008F7560, OS_LOG_TYPE_ERROR))
        {
          CFGetTypeID(a4);
          CFArrayGetTypeID();
          sub_100661D5C();
        }
      }

      else if (os_log_type_enabled((os_log_t)qword_1008F7560, OS_LOG_TYPE_ERROR))
      {
        sub_100661D94();
      }
    }
  }

  else if (os_log_type_enabled((os_log_t)qword_1008F7560, OS_LOG_TYPE_ERROR))
  {
    sub_100661C04();
  }

  return sub_100242FAC((uint64_t)v40);
}

void sub_100231A8C(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, ...)
{
}

uint64_t sub_100231AD0(uint64_t a1, unsigned __int8 *a2, const void *a3, uint64_t a4, char a5)
{
  char v11 = 0;
  sub_100242CA4(&v11);
  uint64_t v9 = sub_100080B74(a2, a3, a4, a5);
  sub_100242CD8(&v11);
  return v9;
}

void sub_100231B38( _Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, int a10, __int16 a11, char a12, char a13)
{
}

uint64_t sub_100231B4C( uint64_t a1, const __CFString *a2, uint64_t a3, const void *a4, uint64_t a5, const __CFString *a6)
{
  uint64_t v11 = *(void *)(a1 + 32);
  v27[0] = 0LL;
  v27[1] = 0LL;
  sub_100242F28((uint64_t)v27, v11 + 360);
  uint64_t v12 = (os_log_s *)qword_1008F7560;
  if (os_log_type_enabled((os_log_t)qword_1008F7560, OS_LOG_TYPE_DEFAULT))
  {
    *(_DWORD *)__int128 buf = 138412546;
    *(void *)&uint8_t buf[4] = a3;
    __int16 v29 = 2112;
    __int16 v30 = a4;
    _os_log_impl( (void *)&_mh_execute_header,  v12,  OS_LOG_TYPE_DEFAULT,  "publishAccRemoteFirmware acc_transportClient_setEndpointPropertyDidChangeHandler GAPA auth result property=%@ value=%@",  buf,  0x16u);
  }

  CFTypeID v13 = CFGetTypeID(a4);
  if (v13 == CFNumberGetTypeID())
  {
    char valuePtr = 0;
    CFNumberGetValue((CFNumberRef)a4, kCFNumberSInt8Type, &valuePtr);
    BOOL v14 = valuePtr != 0;
    uint64_t v15 = sub_1002E6E00();
    if ((*(unsigned int (**)(uint64_t))(*(void *)v15 + 696LL))(v15))
    {
      CFTypeID v16 = (os_log_s *)qword_1008F7560;
      BOOL v14 = 1;
      if (os_log_type_enabled((os_log_t)qword_1008F7560, OS_LOG_TYPE_DEFAULT))
      {
        *(_DWORD *)__int128 buf = 67109120;
        *(_DWORD *)&uint8_t buf[4] = 1;
        _os_log_impl((void *)&_mh_execute_header, v16, OS_LOG_TYPE_DEFAULT, "Override GAPA authResult=%d", buf, 8u);
      }
    }

    uint64_t v17 = sub_1002E6E00();
    if ((*(unsigned int (**)(uint64_t))(*(void *)v17 + 704LL))(v17))
    {
      int v18 = (os_log_s *)qword_1008F7560;
      BOOL v14 = 0;
      if (os_log_type_enabled((os_log_t)qword_1008F7560, OS_LOG_TYPE_DEFAULT))
      {
        *(_DWORD *)__int128 buf = 67109120;
        *(_DWORD *)&uint8_t buf[4] = 0;
        _os_log_impl((void *)&_mh_execute_header, v18, OS_LOG_TYPE_DEFAULT, "Override GAPA authResult=%d", buf, 8u);
        BOOL v14 = 0;
      }
    }

    *(void *)__int128 buf = 0LL;
    uint64_t v25 = 0LL;
    if (sub_1002309E0(v11, (uint64_t *)buf, &v25, a6, a2))
    {
      *(_DWORD *)(*(void *)buf + 60sub_1001FD944(v1, 0LL) = 4;
      uint64_t v19 = sub_1002E8D94();
      uint64_t v20 = *(void *)(a1 + 40);
      int v23 = *(_DWORD *)(v20 + 128);
      __int16 v24 = *(_WORD *)(v20 + 132);
      (*(void (**)(uint64_t, int *, uint64_t, void))(*(void *)v19 + 368LL))(v19, &v23, 6LL, 0LL);
      if (v14)
      {
        uint64_t v21 = sub_1003D84C8(v25, 1, 1);
        sub_1002198C4(v21, *(void *)(a1 + 40), 1LL);
      }

      else
      {
        sub_100219B98(v11, v25, 0x200u);
      }
    }
  }

  else if (os_log_type_enabled((os_log_t)qword_1008F7560, OS_LOG_TYPE_ERROR))
  {
    CFGetTypeID(a4);
    CFNumberGetTypeID();
    sub_100661DF4();
  }

  return sub_100242FAC((uint64_t)v27);
}

void sub_100231E08(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, ...)
{
}

uint64_t sub_100231E34( uint64_t a1, const __CFString *a2, uint64_t a3, uint64_t a4, uint64_t a5, const __CFString *a6)
{
  uint64_t v9 = *(void *)(a1 + 32);
  v20[0] = 0LL;
  v20[1] = 0LL;
  sub_100242F28((uint64_t)v20, v9 + 360);
  uint64_t v10 = sub_100230AD4(v9, a6);
  if (v10)
  {
    uint64_t v11 = *(void *)v10;
    if (*(void *)v10)
    {
      if (CFStringCompare(a2, *(CFStringRef *)(v10 + 144), 0LL))
      {
        if (os_log_type_enabled((os_log_t)qword_1008F7560, OS_LOG_TYPE_ERROR)) {
          sub_100661E90();
        }
      }

      else
      {
        char v19 = 0;
        sub_100242CA4(&v19);
        int v12 = sub_100080ACC((unsigned __int8 *)(v11 + 128));
        sub_100242CD0(&v19);
        CFTypeID v13 = (os_log_s *)qword_1008F7560;
        if (os_log_type_enabled((os_log_t)qword_1008F7560, OS_LOG_TYPE_DEFAULT))
        {
          *(_DWORD *)__int128 buf = 67109120;
          int v22 = v12;
          _os_log_impl( (void *)&_mh_execute_header,  v13,  OS_LOG_TYPE_DEFAULT,  "publishAccRemoteFirmware cert required handler: BT_AACP_CLIENT_GetCertificates result %d",  buf,  8u);
        }

        uint64_t v14 = sub_1002E8D94();
        uint64_t v15 = *(void *)(a1 + 40);
        int v17 = *(_DWORD *)(v15 + 128);
        __int16 v18 = *(_WORD *)(v15 + 132);
        (*(void (**)(uint64_t, int *, uint64_t, void))(*(void *)v14 + 368LL))(v14, &v17, 2LL, 0LL);
        sub_100242CD8(&v19);
      }
    }
  }

  else if (os_log_type_enabled((os_log_t)qword_1008F7560, OS_LOG_TYPE_ERROR))
  {
    sub_100661E2C();
  }

  return sub_100242FAC((uint64_t)v20);
}

void sub_100231FE4(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, ...)
{
}

void sub_100232018(uint64_t a1, uint64_t a2)
{
  if (a2)
  {
    unsigned int v3 = *(_DWORD *)(a2 + 80) - 8194;
    BOOL v4 = v3 > 0xE;
    int v5 = (1 << v3) & 0x409B;
    if (v4 || v5 == 0)
    {
      uint64_t v7 = *(void *)a2;
      if (*(void *)a2)
      {
        uint64_t v8 = *(void *)(a2 + 128);
        if (v8)
        {
          uint64_t v9 = (os_log_s *)qword_1008F7560;
          if (os_log_type_enabled((os_log_t)qword_1008F7560, OS_LOG_TYPE_DEFAULT))
          {
            sub_1003D0100(v7, (uint64_t)__p);
            if (v17 >= 0) {
              uint64_t v10 = __p;
            }
            else {
              uint64_t v10 = (void **)__p[0];
            }
            *(_DWORD *)__int128 buf = 138412803;
            uint64_t v19 = v8;
            __int16 v20 = 2160;
            uint64_t v21 = 1752392040LL;
            __int16 v22 = 2081;
            int v23 = v10;
            _os_log_impl( (void *)&_mh_execute_header,  v9,  OS_LOG_TYPE_DEFAULT,  "unPublishAccRemoteFirmware: Un-Publishing connection %@ and all endpoints for %{private, mask.hash}s",  buf,  0x20u);
            if (v17 < 0) {
              operator delete(__p[0]);
            }
            uint64_t v8 = *(void *)(a2 + 128);
          }

          if (!acc_transportClient_destroyConnection(v8)
            && os_log_type_enabled((os_log_t)qword_1008F7560, OS_LOG_TYPE_ERROR))
          {
            sub_100661F28();
          }

          uint64_t v11 = 0LL;
          uint64_t v12 = a2 + 160;
          do
          {
            uint64_t v13 = *(void *)(v12 + v11);
            if (v13)
            {
              uint64_t v14 = (void *)sub_10023C228(v13);
              operator delete(v14);
              *(void *)(v12 + v11) = 0LL;
            }

            v11 += 8LL;
          }

          while (v11 != 256);
          CFRelease(*(CFTypeRef *)(a2 + 128));
          *(void *)(a2 + 12std::ostream::~ostream(v2, v3 + 8) = 0LL;
          uint64_t v15 = *(const void **)(a2 + 136);
          if (v15)
          {
            CFRelease(v15);
            *(void *)(a2 + 136) = 0LL;
          }
        }
      }
    }
  }

  else if (os_log_type_enabled((os_log_t)qword_1008F7560, OS_LOG_TYPE_ERROR))
  {
    sub_100661EFC();
  }

uint64_t sub_1002321F4( uint64_t a1, uint64_t a2, char *a3, size_t a4, char *a5, size_t a6, char *a7, size_t a8, char *a9, size_t a10, char *a11, size_t a12, char *a13, size_t a14, char *a15, size_t a16)
{
  v43[1] = 0LL;
  uint64_t v44 = a2;
  v43[0] = 0LL;
  sub_100242F28((uint64_t)v43, a1 + 360);
  __int16 v22 = *(uint64_t ***)(a1 + 336);
  int v23 = *(uint64_t ***)(a1 + 344);
  if (v22 == v23)
  {
LABEL_9:
    uint64_t v27 = 7LL;
  }

  else
  {
    size_t v38 = a6;
    size_t v39 = a8;
    while (1)
    {
      __int16 v24 = (unsigned __int8 *)*v22;
      uint64_t v25 = **v22;
      if (v25)
      {
      }

      if (++v22 == v23) {
        goto LABEL_9;
      }
    }

    __int128 __dst = a5;
    BOOL v28 = (os_log_s *)qword_1008F7560;
    if (os_log_type_enabled((os_log_t)qword_1008F7560, OS_LOG_TYPE_DEFAULT))
    {
      sub_1003D0100(v25, (uint64_t)__p);
      __int16 v29 = __p;
      if (v42 < 0) {
        __int16 v29 = (void **)__p[0];
      }
      *(_DWORD *)__int128 buf = 141558275;
      *(void *)&uint8_t buf[4] = 1752392040LL;
      __int16 v46 = 2081;
      __int16 v47 = v29;
      _os_log_impl( (void *)&_mh_execute_header,  v28,  OS_LOG_TYPE_DEFAULT,  " Returning F/W version for %{private, mask.hash}s",  buf,  0x16u);
      if (v42 < 0) {
        operator delete(__p[0]);
      }
    }

    int v30 = v24[88];
    int v31 = v24[89];
    int v32 = v24[90];
    *(_WORD *)&uint8_t buf[8] = 0;
    *(void *)__int128 buf = 0LL;
    sprintf(buf, "%d.%d.%d", v30, v31, v32);
    if (a14 < 0xA) {
      goto LABEL_23;
    }
    strlcpy(a13, buf, a14);
    size_t v33 = v39;
    sub_1003FE1B4((unsigned __int8 *)(v25 + 128), __p);
    if (v42 < 0)
    {
      size_t v34 = strlen((const char *)__p[0]) + 1;
      operator delete(__p[0]);
      BOOL v35 = v34 > a4;
      size_t v33 = v39;
      if (v35)
      {
LABEL_23:
        uint64_t v27 = 5LL;
        goto LABEL_24;
      }
    }

    else if (strlen((const char *)__p) + 1 > a4)
    {
      goto LABEL_23;
    }

    strlcpy(a3, "AirPods Case", a4);
    if (v38 < 0xD) {
      goto LABEL_23;
    }
    strlcpy(__dst, "AirPods Case", v38);
    if (a10 < 6) {
      goto LABEL_23;
    }
    strlcpy(a9, "A1602", a10);
    if (v33 < 0xA) {
      goto LABEL_23;
    }
    strlcpy(a7, "Apple Inc", v33);
    if (a16 >= 2) {
      strlcpy(a15, " ", a16);
    }
    if (a12 >= 2) {
      strlcpy(a11, " ", a12);
    }
    uint64_t v27 = 0LL;
  }

void sub_1002324E4( _Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, ...)
{
}

BOOL sub_100232508(uint64_t a1)
{
  if (qword_1008D9118 != -1) {
    dispatch_once(&qword_1008D9118, &stru_100888C30);
  }
  uint64_t v2 = off_1008D9110;
  unsigned int v3 = (char *)operator new(0x10uLL);
  *((_WORD *)v3 + 4) = 1;
  *(void *)unsigned int v3 = &off_100888320;
  *(_DWORD *)(v3 + 10) = *(_DWORD *)a1;
  *((_WORD *)v3 + memset((char *)&v11[1] + 1, 0, 7) = *(_WORD *)(a1 + 4);
  return sub_10041C240((uint64_t)v2, v3);
}

BOOL sub_100232588(uint64_t a1, __int16 a2, int a3)
{
  if (qword_1008D9118 != -1) {
    dispatch_once(&qword_1008D9118, &stru_100888C30);
  }
  uint64_t v6 = off_1008D9110;
  uint64_t v7 = (char *)operator new(0x18uLL);
  *((_WORD *)v7 + 4) = 1;
  *(void *)uint64_t v7 = &off_100888358;
  *(_DWORD *)(v7 + 10) = *(_DWORD *)a1;
  *((_WORD *)v7 + memset((char *)&v11[1] + 1, 0, 7) = *(_WORD *)(a1 + 4);
  *((_WORD *)v7 + std::ostream::~ostream(v2, v3 + 8) = a2;
  *((_DWORD *)v7 + 5) = a3;
  return sub_10041C240((uint64_t)v6, v7);
}

BOOL sub_100232620(uint64_t a1, int a2)
{
  if (qword_1008D9118 != -1) {
    dispatch_once(&qword_1008D9118, &stru_100888C30);
  }
  BOOL v4 = off_1008D9110;
  int v5 = (char *)operator new(0x18uLL);
  *((_WORD *)v5 + 4) = 1;
  *(void *)int v5 = &off_100888390;
  *(_DWORD *)(v5 + 10) = *(_DWORD *)a1;
  *((_WORD *)v5 + memset((char *)&v11[1] + 1, 0, 7) = *(_WORD *)(a1 + 4);
  *((_DWORD *)v5 + 4) = a2;
  return sub_10041C240((uint64_t)v4, v5);
}

BOOL sub_1002326B0(int *a1, unsigned __int16 *a2, unsigned int a3, int a4)
{
  if (qword_1008D9118 != -1) {
    dispatch_once(&qword_1008D9118, &stru_100888C30);
  }
  uint64_t v8 = off_1008D9110;
  uint64_t v9 = operator new(0x28uLL);
  sub_10023C38C((uint64_t)v9, a1, a2, a3, a4);
  return sub_10041C240((uint64_t)v8, v9);
}

void sub_100232740(_Unwind_Exception *a1)
{
}

BOOL sub_100232754(uint64_t a1, unsigned int a2, const void *a3)
{
  if (qword_1008D9118 != -1) {
    dispatch_once(&qword_1008D9118, &stru_100888C30);
  }
  uint64_t v6 = off_1008D9110;
  uint64_t v7 = (char *)operator new(0x20uLL);
  *((_WORD *)v7 + 4) = 1;
  *(void *)uint64_t v7 = &off_100888400;
  *(_DWORD *)(v7 + 10) = *(_DWORD *)a1;
  *((_WORD *)v7 + memset((char *)&v11[1] + 1, 0, 7) = *(_WORD *)(a1 + 4);
  v7[16] = a2;
  size_t v8 = 5LL * a2;
  uint64_t v9 = operator new[](v8);
  *((void *)v7 + 3) = v9;
  memcpy(v9, a3, v8);
  return sub_10041C240((uint64_t)v6, v7);
}

void sub_100232814(_Unwind_Exception *a1)
{
}

BOOL sub_100232828(uint64_t a1, unsigned int a2, const void *a3)
{
  if (qword_1008D9118 != -1) {
    dispatch_once(&qword_1008D9118, &stru_100888C30);
  }
  uint64_t v6 = off_1008D9110;
  uint64_t v7 = (char *)operator new(0x20uLL);
  *((_WORD *)v7 + 4) = 1;
  *(void *)uint64_t v7 = &off_100888438;
  *(_DWORD *)(v7 + 10) = *(_DWORD *)a1;
  *((_WORD *)v7 + memset((char *)&v11[1] + 1, 0, 7) = *(_WORD *)(a1 + 4);
  v7[16] = a2;
  size_t v8 = 5LL * a2;
  uint64_t v9 = operator new[](v8);
  *((void *)v7 + 3) = v9;
  memcpy(v9, a3, v8);
  return sub_10041C240((uint64_t)v6, v7);
}

void sub_1002328E8(_Unwind_Exception *a1)
{
}

BOOL sub_1002328FC(uint64_t a1, _WORD *a2)
{
  if (qword_1008D9118 != -1) {
    dispatch_once(&qword_1008D9118, &stru_100888C30);
  }
  BOOL v4 = off_1008D9110;
  int v5 = (char *)operator new(0x18uLL);
  *((_WORD *)v5 + 4) = 1;
  *(void *)int v5 = &off_100888470;
  *(_DWORD *)(v5 + 10) = *(_DWORD *)a1;
  *((_WORD *)v5 + memset((char *)&v11[1] + 1, 0, 7) = *(_WORD *)(a1 + 4);
  *((_WORD *)v5 + std::ostream::~ostream(v2, v3 + 8) = *a2;
  return sub_10041C240((uint64_t)v4, v5);
}

BOOL sub_100232990(uint64_t a1, _DWORD *a2)
{
  if (qword_1008D9118 != -1) {
    dispatch_once(&qword_1008D9118, &stru_100888C30);
  }
  BOOL v4 = off_1008D9110;
  int v5 = (char *)operator new(0x18uLL);
  *((_WORD *)v5 + 4) = 1;
  *(void *)int v5 = &off_1008884A8;
  *(_DWORD *)(v5 + 10) = *(_DWORD *)a1;
  *((_WORD *)v5 + memset((char *)&v11[1] + 1, 0, 7) = *(_WORD *)(a1 + 4);
  *((_DWORD *)v5 + 4) = *a2;
  return sub_10041C240((uint64_t)v4, v5);
}

void sub_100232A24(unsigned __int8 *a1, unsigned __int8 *a2, char a3, char a4)
{
  uint64_t v4 = *a1;
  uint64_t v5 = a1[1];
  uint64_t v6 = a1[2];
  uint64_t v7 = a1[3];
  uint64_t v8 = a1[4];
  uint64_t v9 = a1[5];
  uint64_t v10 = *a2;
  uint64_t v11 = a2[1];
  uint64_t v12 = a2[2];
  uint64_t v13 = a2[3];
  uint64_t v14 = a2[4];
  uint64_t v15 = a2[5];
  if (qword_1008D9118 != -1)
  {
    char v18 = a3;
    char v19 = a4;
    uint64_t v16 = a1[5];
    uint64_t v17 = a1[4];
    dispatch_once(&qword_1008D9118, &stru_100888C30);
    uint64_t v9 = v16;
    uint64_t v8 = v17;
    a3 = v18;
    a4 = v19;
  }

  v20[0] = _NSConcreteStackBlock;
  v20[1] = 3221225472LL;
  void v20[2] = sub_100232B44;
  v20[3] = &unk_10087FF20;
  void v20[4] = (v4 << 40) | (v5 << 32) | (v6 << 24) | (v7 << 16) | (v8 << 8) | v9;
  v20[5] = (v10 << 40) | (v11 << 32) | (v12 << 24) | (v13 << 16) | (v14 << 8) | v15;
  char v21 = a3;
  char v22 = a4;
  sub_10041C1EC((uint64_t)off_1008D9110, v20);
}

void *sub_100232B44(uint64_t a1)
{
  if (qword_1008D60E0 != -1) {
    dispatch_once(&qword_1008D60E0, &stru_100888C10);
  }
  return sub_1002277B0( (uint64_t)off_1008D60D8,  *(void *)(a1 + 32),  *(void *)(a1 + 40),  *(unsigned __int8 *)(a1 + 48),  *(unsigned __int8 *)(a1 + 49));
}

void sub_100232B9C(unsigned __int8 *a1, unsigned __int8 *a2, int a3)
{
  uint64_t v3 = *a1;
  uint64_t v4 = a1[1];
  uint64_t v5 = a1[2];
  uint64_t v6 = a1[3];
  uint64_t v7 = a1[4];
  uint64_t v8 = a1[5];
  uint64_t v9 = *a2;
  uint64_t v10 = a2[1];
  uint64_t v11 = a2[2];
  uint64_t v12 = a2[3];
  uint64_t v13 = a2[4];
  uint64_t v14 = a2[5];
  if (qword_1008D9118 != -1)
  {
    int v17 = a3;
    uint64_t v15 = a1[4];
    uint64_t v16 = a1[5];
    dispatch_once(&qword_1008D9118, &stru_100888C30);
    uint64_t v7 = v15;
    uint64_t v8 = v16;
    a3 = v17;
  }

  v18[0] = _NSConcreteStackBlock;
  v18[1] = 3221225472LL;
  void v18[2] = sub_100232CB8;
  v18[3] = &unk_10087F900;
  v18[4] = (v3 << 40) | (v4 << 32) | (v5 << 24) | (v6 << 16) | (v7 << 8) | v8;
  void v18[5] = (v9 << 40) | (v10 << 32) | (v11 << 24) | (v12 << 16) | (v13 << 8) | v14;
  int v19 = a3;
  sub_10041C1EC((uint64_t)off_1008D9110, v18);
}

void sub_100232CB8(uint64_t a1, uint64_t a2, uint64_t a3)
{
  if (qword_1008D60E0 != -1) {
    dispatch_once(&qword_1008D60E0, &stru_100888C10);
  }
  sub_100227A08((uint64_t)off_1008D60D8, *(void *)(a1 + 32), a3, *(_DWORD *)(a1 + 48));
}

BOOL sub_100232D0C(uint64_t a1, uint64_t a2, char a3)
{
  if (qword_1008D9118 != -1) {
    dispatch_once(&qword_1008D9118, &stru_100888C30);
  }
  uint64_t v6 = off_1008D9110;
  uint64_t v7 = (char *)operator new(0x18uLL);
  *((_WORD *)v7 + 4) = 1;
  *(void *)uint64_t v7 = &off_1008884E0;
  *(_DWORD *)(v7 + 10) = *(_DWORD *)a1;
  *((_WORD *)v7 + memset((char *)&v11[1] + 1, 0, 7) = *(_WORD *)(a1 + 4);
  *((_DWORD *)v7 + 4) = *(_DWORD *)a2;
  *((_WORD *)v7 + 10) = *(_WORD *)(a2 + 4);
  v7[22] = a3;
  return sub_10041C240((uint64_t)v6, v7);
}

BOOL sub_100232DB0(uint64_t a1, uint64_t a2, char a3)
{
  if (qword_1008D9118 != -1) {
    dispatch_once(&qword_1008D9118, &stru_100888C30);
  }
  uint64_t v6 = off_1008D9110;
  uint64_t v7 = (char *)operator new(0x18uLL);
  *((_WORD *)v7 + 4) = 1;
  *(void *)uint64_t v7 = &off_100888518;
  *(_DWORD *)(v7 + 10) = *(_DWORD *)a1;
  *((_WORD *)v7 + memset((char *)&v11[1] + 1, 0, 7) = *(_WORD *)(a1 + 4);
  *((_DWORD *)v7 + 4) = *(_DWORD *)a2;
  *((_WORD *)v7 + 10) = *(_WORD *)(a2 + 4);
  v7[22] = a3;
  return sub_10041C240((uint64_t)v6, v7);
}

BOOL sub_100232E54(uint64_t a1, __int16 a2)
{
  if (qword_1008D9118 != -1) {
    dispatch_once(&qword_1008D9118, &stru_100888C30);
  }
  uint64_t v4 = off_1008D9110;
  uint64_t v5 = (char *)operator new(0x18uLL);
  *((_WORD *)v5 + 4) = 1;
  *(void *)uint64_t v5 = &off_100888550;
  *(_DWORD *)(v5 + 10) = *(_DWORD *)a1;
  *((_WORD *)v5 + memset((char *)&v11[1] + 1, 0, 7) = *(_WORD *)(a1 + 4);
  *((_WORD *)v5 + std::ostream::~ostream(v2, v3 + 8) = a2;
  return sub_10041C240((uint64_t)v4, v5);
}

BOOL sub_100232EE4(int *a1, unsigned int a2, uint64_t a3, char a4)
{
  if (qword_1008D9118 != -1) {
    dispatch_once(&qword_1008D9118, &stru_100888C30);
  }
  uint64_t v8 = off_1008D9110;
  uint64_t v9 = operator new(0x28uLL);
  sub_10023C7F8((uint64_t)v9, a1, a2, a3, a4);
  return sub_10041C240((uint64_t)v8, v9);
}

void sub_100232F74(_Unwind_Exception *a1)
{
}

BOOL sub_100232F88(uint64_t a1, __int16 a2, __int16 a3, __int16 a4)
{
  if (qword_1008D9118 != -1) {
    dispatch_once(&qword_1008D9118, &stru_100888C30);
  }
  uint64_t v8 = off_1008D9110;
  uint64_t v9 = (char *)operator new(0x18uLL);
  *((_WORD *)v9 + 4) = 1;
  *(void *)uint64_t v9 = &off_1008885C0;
  *(_DWORD *)(v9 + 10) = *(_DWORD *)a1;
  *((_WORD *)v9 + memset((char *)&v11[1] + 1, 0, 7) = *(_WORD *)(a1 + 4);
  *((_WORD *)v9 + std::ostream::~ostream(v2, v3 + 8) = a2;
  *((_WORD *)v9 + 9) = a3;
  *((_WORD *)v9 + 10) = a4;
  return sub_10041C240((uint64_t)v8, v9);
}

BOOL sub_100233030(uint64_t a1, int a2, unsigned int a3, const void *a4)
{
  if (qword_1008D9118 != -1) {
    dispatch_once(&qword_1008D9118, &stru_100888C30);
  }
  uint64_t v8 = off_1008D9110;
  uint64_t v9 = (char *)operator new(0x20uLL);
  *((_WORD *)v9 + 4) = 1;
  *(void *)uint64_t v9 = &off_1008885F8;
  *(_DWORD *)(v9 + 10) = *(_DWORD *)a1;
  *((_WORD *)v9 + memset((char *)&v11[1] + 1, 0, 7) = *(_WORD *)(a1 + 4);
  *((_WORD *)v9 + std::ostream::~ostream(v2, v3 + 8) = a3;
  *((_DWORD *)v9 + 5) = a2;
  uint64_t v10 = operator new[](a3);
  *((void *)v9 + 3) = v10;
  memcpy(v10, a4, a3);
  return sub_10041C240((uint64_t)v8, v9);
}

void sub_1002330F4(_Unwind_Exception *a1)
{
}

BOOL sub_100233108(uint64_t a1, int a2)
{
  if (qword_1008D9118 != -1) {
    dispatch_once(&qword_1008D9118, &stru_100888C30);
  }
  uint64_t v4 = off_1008D9110;
  uint64_t v5 = (char *)operator new(0x18uLL);
  *((_WORD *)v5 + 4) = 1;
  *(void *)uint64_t v5 = &off_100888630;
  *(_DWORD *)(v5 + 10) = *(_DWORD *)a1;
  *((_WORD *)v5 + memset((char *)&v11[1] + 1, 0, 7) = *(_WORD *)(a1 + 4);
  *((_DWORD *)v5 + 4) = a2;
  return sub_10041C240((uint64_t)v4, v5);
}

BOOL sub_100233198(uint64_t a1, char a2, int a3)
{
  if (qword_1008D9118 != -1) {
    dispatch_once(&qword_1008D9118, &stru_100888C30);
  }
  uint64_t v6 = off_1008D9110;
  uint64_t v7 = (char *)operator new(0x18uLL);
  *((_WORD *)v7 + 4) = 1;
  *(void *)uint64_t v7 = &off_100888668;
  *(_DWORD *)(v7 + 10) = *(_DWORD *)a1;
  *((_WORD *)v7 + memset((char *)&v11[1] + 1, 0, 7) = *(_WORD *)(a1 + 4);
  v7[16] = a2;
  *((_DWORD *)v7 + 5) = a3;
  return sub_10041C240((uint64_t)v6, v7);
}

BOOL sub_100233230(uint64_t a1, char a2, unsigned int a3, const void *a4)
{
  if (qword_1008D9118 != -1) {
    dispatch_once(&qword_1008D9118, &stru_100888C30);
  }
  uint64_t v8 = off_1008D9110;
  uint64_t v9 = (char *)operator new(0x20uLL);
  *((_WORD *)v9 + 4) = 1;
  *(void *)uint64_t v9 = &off_1008886A0;
  *(_DWORD *)(v9 + 10) = *(_DWORD *)a1;
  *((_WORD *)v9 + memset((char *)&v11[1] + 1, 0, 7) = *(_WORD *)(a1 + 4);
  v9[16] = a2;
  *((_WORD *)v9 + 9) = a3;
  uint64_t v10 = operator new[](a3);
  *((void *)v9 + 3) = v10;
  memcpy(v10, a4, a3);
  return sub_10041C240((uint64_t)v8, v9);
}

void sub_1002332F4(_Unwind_Exception *a1)
{
}

BOOL sub_100233308(uint64_t a1, char a2, unsigned int a3, const void *a4)
{
  if (qword_1008D9118 != -1) {
    dispatch_once(&qword_1008D9118, &stru_100888C30);
  }
  uint64_t v8 = off_1008D9110;
  uint64_t v9 = (char *)operator new(0x20uLL);
  *((_WORD *)v9 + 4) = 1;
  *(void *)uint64_t v9 = &off_1008886D8;
  *(_DWORD *)(v9 + 10) = *(_DWORD *)a1;
  *((_WORD *)v9 + memset((char *)&v11[1] + 1, 0, 7) = *(_WORD *)(a1 + 4);
  v9[16] = a2;
  *((_WORD *)v9 + 9) = a3;
  uint64_t v10 = operator new[](a3);
  *((void *)v9 + 3) = v10;
  memcpy(v10, a4, a3);
  return sub_10041C240((uint64_t)v8, v9);
}

void sub_1002333CC(_Unwind_Exception *a1)
{
}

BOOL sub_1002333E0(uint64_t a1, unsigned int a2, const void *a3)
{
  if (qword_1008D9118 != -1) {
    dispatch_once(&qword_1008D9118, &stru_100888C30);
  }
  uint64_t v6 = off_1008D9110;
  uint64_t v7 = (char *)operator new(0x20uLL);
  *((_WORD *)v7 + 4) = 1;
  *(void *)uint64_t v7 = &off_100888710;
  *(_DWORD *)(v7 + 10) = *(_DWORD *)a1;
  *((_WORD *)v7 + memset((char *)&v11[1] + 1, 0, 7) = *(_WORD *)(a1 + 4);
  *((_WORD *)v7 + std::ostream::~ostream(v2, v3 + 8) = a2;
  uint64_t v8 = operator new[](a2);
  *((void *)v7 + 3) = v8;
  memcpy(v8, a3, a2);
  return sub_10041C240((uint64_t)v6, v7);
}

void sub_10023349C(_Unwind_Exception *a1)
{
}

BOOL sub_1002334B0(uint64_t a1, char a2, char a3, unsigned int a4, const void *a5)
{
  if (qword_1008D9118 != -1) {
    dispatch_once(&qword_1008D9118, &stru_100888C30);
  }
  uint64_t v10 = off_1008D9110;
  uint64_t v11 = (char *)operator new(0x20uLL);
  *((_WORD *)v11 + 4) = 1;
  *(void *)uint64_t v11 = &off_100888748;
  *(_DWORD *)(v11 + 10) = *(_DWORD *)a1;
  *((_WORD *)v11 + memset((char *)&v11[1] + 1, 0, 7) = *(_WORD *)(a1 + 4);
  uint8_t v11[16] = a2;
  v11[17] = a3;
  *((_WORD *)v11 + 9) = a4;
  uint64_t v12 = operator new[](a4);
  *((void *)v11 + 3) = v12;
  memcpy(v12, a5, a4);
  return sub_10041C240((uint64_t)v10, v11);
}

void sub_100233584(_Unwind_Exception *a1)
{
}

BOOL sub_100233598(int *a1, __int128 *a2)
{
  if (qword_1008D9118 != -1) {
    dispatch_once(&qword_1008D9118, &stru_100888C30);
  }
  uint64_t v4 = off_1008D9110;
  uint64_t v5 = operator new(0x38uLL);
  sub_10023CEA0((uint64_t)v5, a1, a2);
  return sub_10041C240((uint64_t)v4, v5);
}

void sub_100233610(_Unwind_Exception *a1)
{
}

BOOL sub_100233624(uint64_t a1, uint64_t a2, unsigned int a3, const void *a4)
{
  if (qword_1008D9118 != -1) {
    dispatch_once(&qword_1008D9118, &stru_100888C30);
  }
  uint64_t v8 = off_1008D9110;
  uint64_t v9 = (char *)operator new(0x20uLL);
  *((_WORD *)v9 + 4) = 1;
  *(void *)uint64_t v9 = &off_1008887B8;
  *(_DWORD *)(v9 + 10) = *(_DWORD *)a1;
  *((_WORD *)v9 + memset((char *)&v11[1] + 1, 0, 7) = *(_WORD *)(a1 + 4);
  *((_DWORD *)v9 + 4) = *(_DWORD *)a2;
  *((_WORD *)v9 + 10) = *(_WORD *)(a2 + 4);
  *((_WORD *)v9 + 11) = a3;
  uint64_t v10 = operator new[](a3);
  *((void *)v9 + 3) = v10;
  memcpy(v10, a4, a3);
  return sub_10041C240((uint64_t)v8, v9);
}

void sub_1002336F4(_Unwind_Exception *a1)
{
}

BOOL sub_100233708(int *a1, char a2, char a3, char a4, char a5, char *a6, unsigned int a7, void *a8)
{
  if (qword_1008D9118 != -1) {
    dispatch_once(&qword_1008D9118, &stru_100888C30);
  }
  uint64_t v16 = off_1008D9110;
  int v17 = operator new(0x40uLL);
  sub_10023D0BC((uint64_t)v17, a1, a2, a3, a4, a5, a6, a7, a8);
  return sub_10041C240((uint64_t)v16, v17);
}

void sub_1002337D0(_Unwind_Exception *a1)
{
}