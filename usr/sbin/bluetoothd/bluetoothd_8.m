void sub_1003FCD80( _Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, ...)
{
  void *v17;
  uint64_t v18;
  uint64_t v20;
  va_list va;
  va_start(va, a17);

  nullsub_63(v18 - 128, v20);
  sub_100242FAC((uint64_t)va);

  _Unwind_Resume(a1);
}

uint64_t sub_1003FCEF4(uint64_t result, uint64_t a2)
{
  int v2 = *(_DWORD *)(a2 + 48);
  *(_DWORD *)(result + 51) = *(_DWORD *)(a2 + 51);
  *(_DWORD *)(result + 48) = v2;
  return result;
}

uint64_t sub_1003FCF0C(uint64_t a1)
{
  if (qword_1008D6608 != -1) {
    dispatch_once(&qword_1008D6608, &stru_100896258);
  }
  sub_10060CBEC((uint64_t)off_1008D6600, (unsigned __int8 *)(*(void *)(*(void *)(a1 + 32) + 8LL) + 48LL));
  if (qword_1008D5F20 != -1) {
    dispatch_once(&qword_1008D5F20, &stru_100896278);
  }
  return sub_10062AC58(qword_1008D5F18, (unsigned __int8 *)(*(void *)(*(void *)(a1 + 32) + 8LL) + 48LL));
}

uint64_t sub_1003FCFA4(uint64_t a1)
{
  uint64_t v2 = sub_1002E8D94();
  return (*(uint64_t (**)(uint64_t, void, void))(*(void *)v2 + 336LL))( v2,  *(void *)(a1 + 32),  *(void *)(a1 + 40));
}

uint64_t sub_1003FCFD0(uint64_t a1, uint64_t a2, _OWORD *a3, _OWORD *a4, _OWORD *a5, _OWORD *a6, int a7)
{
  *(void *)(a1 + 88) = 0LL;
  uint64_t v8 = a1 + 88;
  *(void *)(a1 + 96) = 0LL;
  *(void *)(a1 + 104) = 0LL;
  *(_BYTE *)(a1 + 112) = -1;
  *(void *)a1 = a2;
  *(_OWORD *)(a1 + 8) = *a3;
  *(_OWORD *)(a1 + 24) = *a4;
  *(_DWORD *)(a1 + 72) = a7;
  *(_DWORD *)(a1 + 84) = 0;
  *(_OWORD *)(a1 + 40) = *a5;
  *(_OWORD *)(a1 + 56) = *a6;
  *(_BYTE *)(a1 + 77) = 0;
  int v9 = *(_DWORD *)(a2 + 128);
  *(_WORD *)(a1 + 82) = *(_WORD *)(a2 + 132);
  *(_DWORD *)(a1 + 78) = v9;
  sub_1003D0100(a2, (uint64_t)&v11);
  *(_OWORD *)uint64_t v8 = v11;
  *(void *)(v8 + 16) = v12;
  return a1;
}

void sub_1003FD080(_Unwind_Exception *exception_object)
{
}

void sub_1003FD09C(uint64_t a1)
{
  if ((sub_1003ECFD0() & 1) == 0)
  {
    uint64_t v61 = qword_1008F7600;
    if (!os_log_type_enabled((os_log_t)qword_1008F7600, OS_LOG_TYPE_DEFAULT)) {
      return;
    }
    *(_WORD *)buf = 0;
    v62 = "upgradeToManatee, Magic Pairing not supported";
LABEL_86:
    v63 = (os_log_s *)v61;
    uint32_t v64 = 2;
    goto LABEL_87;
  }

  if (qword_1008D5F50 != -1) {
    dispatch_once(&qword_1008D5F50, &stru_100896218);
  }
  if ((sub_100401058((uint64_t)off_1008D5F48) & 1) == 0)
  {
    uint64_t v61 = qword_1008F7600;
    if (!os_log_type_enabled((os_log_t)qword_1008F7600, OS_LOG_TYPE_DEFAULT)) {
      return;
    }
    *(_WORD *)buf = 0;
    v62 = "upgradeToManatee System has not passed first unlock (or device prefs not read yet). Do not write DeviceList to Cloud";
    goto LABEL_86;
  }

  if (*(_OWORD *)(a1 + 49) == 0LL || *(_OWORD *)(a1 + 65) == 0LL)
  {
    if (os_log_type_enabled((os_log_t)qword_1008F7600, OS_LOG_TYPE_ERROR)) {
      sub_10067B66C();
    }
    v65 = (os_log_s *)qword_1008F7600;
    if (os_log_type_enabled((os_log_t)qword_1008F7600, OS_LOG_TYPE_ERROR)) {
      sub_10067B5F8(a1 + 49, v65, v66, v67, v68, v69, v70, v71);
    }
    v72 = (os_log_s *)qword_1008F7600;
    if (os_log_type_enabled((os_log_t)qword_1008F7600, OS_LOG_TYPE_ERROR)) {
      sub_10067B580(a1, v72, v73, v74, v75, v76, v77, v78);
    }
    return;
  }

  uint64_t v80 = a1 + 65;
  uint64_t v81 = a1 + 49;
  __int16 v88 = 0;
  uint64_t v2 = sub_1002E8D54();
  (*(void (**)(uint64_t, char *))(*(void *)v2 + 72LL))(v2, (char *)&v88 + 1);
  uint64_t v3 = sub_1002E8D54();
  (*(void (**)(uint64_t, __int16 *))(*(void *)v3 + 80LL))(v3, &v88);
  uint64_t v82 = a1;
  int v4 = *(unsigned __int8 *)(a1 + 241);
  int v5 = HIBYTE(v88);
  v6 = (os_log_s *)qword_1008F7600;
  BOOL v7 = os_log_type_enabled((os_log_t)qword_1008F7600, OS_LOG_TYPE_DEFAULT);
  if (!v4 || v5)
  {
    if (!v7) {
      return;
    }
    if (*(_BYTE *)(v82 + 241)) {
      v79 = "online";
    }
    else {
      v79 = "signed in";
    }
    *(_DWORD *)buf = 136446210;
    *(void *)&buf[4] = v79;
    v62 = "Warning: Device is not %{public}s";
    v63 = v6;
    uint32_t v64 = 12;
LABEL_87:
    _os_log_impl((void *)&_mh_execute_header, v63, OS_LOG_TYPE_DEFAULT, v62, buf, v64);
    return;
  }

  if (v7)
  {
    uint64_t v8 = (uint64_t)(*(void *)(v82 + 184) - *(void *)(v82 + 176)) >> 3;
    *(_DWORD *)buf = 134217984;
    *(void *)&buf[4] = v8;
    _os_log_impl( (void *)&_mh_execute_header,  v6,  OS_LOG_TYPE_DEFAULT,  "upgradeToManatee information for %lu devices to cloud",  buf,  0xCu);
  }

  uint64_t v9 = v82;
  v10 = *(uint64_t ***)(v82 + 176);
  uint64_t v11 = *(void *)(v82 + 184) - (void)v10;
  if (v11)
  {
    unint64_t v12 = v11 >> 3;
    if (is_mul_ok(v12, 0x98uLL)) {
      size_t v13 = 152 * v12;
    }
    else {
      size_t v13 = -1LL;
    }
    __p = operator new[](v13);
    unsigned __int8 v14 = 0;
    uint64_t v15 = -(uint64_t)v10;
    while (1)
    {
      int v86 = 1;
      int v87 = 0;
      int v84 = 0;
      int v85 = 0;
      v16 = *v10;
      uint64_t v17 = **v10;
      int v18 = v14;
      v19 = (char *)&__p[76 * v14];
      int v20 = *(_DWORD *)(v17 + 128);
      *((_WORD *)v19 + 2) = *(_WORD *)(v17 + 132);
      *(_DWORD *)v19 = v20;
      *(_OWORD *)(v19 + 42) = *(_OWORD *)(v16 + 1);
      *(_OWORD *)(v19 + 58) = *(_OWORD *)(v16 + 3);
      *(_OWORD *)(v19 + 6) = *(_OWORD *)(v16 + 5);
      *(_OWORD *)(v19 + 22) = *(_OWORD *)(v16 + 7);
      int v21 = *((_DWORD *)v16 + 18);
      *(_OWORD *)(v19 + 74) = 0u;
      v22 = v19 + 74;
      *((_DWORD *)v22 - 9) = v21;
      *((_OWORD *)v22 + 1) = 0u;
      *((_OWORD *)v22 + 2) = 0u;
      *((void *)v22 + 6) = 0LL;
      sub_1003D0100(v17, (uint64_t)buf);
      unint64_t v23 = HIBYTE(v91);
      if (v91 < 0) {
        unint64_t v23 = *(void *)&buf[8];
      }
      if (v23 <= 0x37) {
        break;
      }
      unsigned __int8 v24 = 55;
      if (v91 < 0) {
        goto LABEL_27;
      }
LABEL_28:
      sub_1003D0100(v17, (uint64_t)buf);
      if (SHIBYTE(v91) < 0)
      {
        v25 = *(void **)buf;
        memcpy(v22, *(const void **)buf, v24);
        operator delete(v25);
      }

      else
      {
        memcpy(v22, buf, v24);
      }

      sub_1003D55EC(v17, &v87, &v85, &v84, &v86);
      if (!sub_1003D55EC(v17, &v87, &v85, &v84, &v86))
      {
        v26 = (os_log_s *)(id)qword_1008F7600;
        if (os_log_type_enabled(v26, OS_LOG_TYPE_DEFAULT))
        {
          sub_1003CF00C(v17, v98);
          v27 = v98;
          if (v101 < 0) {
            v27 = *(_BYTE **)v98;
          }
          *(_DWORD *)buf = 136446722;
          *(void *)&buf[4] = v27;
          *(_WORD *)&buf[12] = 1024;
          *(_DWORD *)&buf[14] = v84;
          __int16 v90 = 1024;
          int v91 = v85;
          _os_log_impl( (void *)&_mh_execute_header,  v26,  OS_LOG_TYPE_DEFAULT,  "upgradeToManatee Error fetching DeviceId for magic paired device %{public}s with pid: %x, vid: %x",  buf,  0x18u);
          if (v101 < 0) {
            operator delete(*(void **)v98);
          }
        }
      }

      v28 = (os_log_s *)(id)qword_1008F7600;
      if (os_log_type_enabled(v28, OS_LOG_TYPE_DEFAULT))
      {
        sub_1003CF00C(v17, v98);
        v29 = v98;
        if (v101 < 0) {
          v29 = *(_BYTE **)v98;
        }
        *(_DWORD *)buf = 67109890;
        *(_DWORD *)&buf[4] = v24;
        *(_WORD *)&buf[8] = 2082;
        *(void *)&buf[10] = v29;
        __int16 v90 = 1024;
        int v91 = v84;
        __int16 v92 = 1024;
        int v93 = v85;
        _os_log_impl( (void *)&_mh_execute_header,  v28,  OS_LOG_TYPE_DEFAULT,  "upgradeToManatee Uploading device with length %d for magic paired device %{public}s with pid: %x, vid: %x",  buf,  0x1Eu);
        if (v101 < 0) {
          operator delete(*(void **)v98);
        }
      }

      v30 = (char *)&__p[76 * v18];
      *((_WORD *)v30 + 71) = v85;
      *((_WORD *)v30 + 72) = v84;
      int v31 = sub_1003DF900(v17);
      if (v31 == 2) {
        char v32 = 2;
      }
      else {
        char v32 = v31 == 1;
      }
      else {
        unsigned __int8 v33 = v32;
      }
      v34 = (os_log_s *)(id)qword_1008F7600;
      if (os_log_type_enabled(v34, OS_LOG_TYPE_DEFAULT))
      {
        sub_1003CF00C(v17, buf);
        int v35 = SHIBYTE(v91);
        v36 = *(_BYTE **)buf;
        int v37 = sub_1003DF944(v17);
        v38 = buf;
        if (v35 < 0) {
          v38 = v36;
        }
        *(_DWORD *)v98 = 136446466;
        *(void *)&v98[4] = v38;
        v39 = "disabled";
        if (v37) {
          v39 = "Enabled";
        }
        __int16 v99 = 2080;
        v100 = v39;
        _os_log_impl( (void *)&_mh_execute_header,  v34,  OS_LOG_TYPE_DEFAULT,  "upgradeToManatee In Ear Detection  state for device  %{public}s is %s",  v98,  0x16u);
        if (SHIBYTE(v91) < 0) {
          operator delete(*(void **)buf);
        }
        uint64_t v9 = v82;
      }

      else {
        unsigned __int8 v40 = v33;
      }
      else {
        unsigned __int8 v41 = v40;
      }
      char v42 = sub_1003D635C(v17);
      unsigned int v43 = sub_1003D635C(v17);
      v44 = (char *)&__p[76 * v18];
      v44[148] = (v43 >> 4) & 0xF0 | v42;
      v44[147] = v41;
      if (qword_1008D60D0 != -1) {
        dispatch_once(&qword_1008D60D0, &stru_1008962B8);
      }
      *(_DWORD *)&__p[76 * v18 + 69] = sub_1004272C4((uint64_t)off_1008D60C8, *v16);
      v45 = (os_log_s *)(id)qword_1008F7600;
      if (os_log_type_enabled(v45, OS_LOG_TYPE_DEFAULT))
      {
        sub_1003CF00C(v17, buf);
        v46 = buf;
        if (v91 < 0) {
          v46 = *(_BYTE **)buf;
        }
        *(_DWORD *)v98 = 136446466;
        *(void *)&v98[4] = v46;
        __int16 v99 = 1024;
        LODWORD(v100) = v41;
        _os_log_impl( (void *)&_mh_execute_header,  v45,  OS_LOG_TYPE_DEFAULT,  "upgradeToManatee Settings mask for device %{public}s is 0x%2x",  v98,  0x12u);
        if (SHIBYTE(v91) < 0) {
          operator delete(*(void **)buf);
        }
      }

      char v47 = sub_1003E16E4(v17);
      v48 = (char *)&__p[76 * v18];
      v48[149] = v47;
      v48[130] = 2;
      char v49 = sub_1003DFBD0(v17);
      int v50 = sub_1003DFBD0(v17);
      char v51 = sub_1003DFA7C(v17);
      int v52 = sub_1003D2B2C(v17, 32);
      char v53 = sub_1003DFC9C(v17);
      if (v52) {
        int v54 = 64;
      }
      else {
        int v54 = 0;
      }
      unsigned int v55 = (32 * v50) & 0xE000 | ((v49 & 7) << 10) | ((v51 & 7) << 7) | v54 & 0xFFFFFFF3 | (4 * (v53 & 3));
      __p[76 * v18 + 75] = (32 * v50) & 0xE000 | ((v49 & 7) << 10) | ((v51 & 7) << 7) | v54 & 0xFFF3 | (4 * (v53 & 3));
      v56 = (os_log_s *)(id)qword_1008F7600;
      if (os_log_type_enabled(v56, OS_LOG_TYPE_DEFAULT))
      {
        sub_1003CF00C(v17, v98);
        if (v101 >= 0) {
          v57 = v98;
        }
        else {
          v57 = *(_BYTE **)v98;
        }
        int v58 = sub_1003DFBD0(v17);
        int v59 = sub_1003DFA7C(v17);
        int v60 = sub_1003DFC9C(v17);
        *(_DWORD *)buf = 67110402;
        *(_DWORD *)&buf[4] = v55;
        *(_WORD *)&buf[8] = 2082;
        *(void *)&buf[10] = v57;
        __int16 v90 = 1024;
        int v91 = v58;
        __int16 v92 = 1024;
        int v93 = v59;
        __int16 v94 = 1024;
        int v95 = v52;
        __int16 v96 = 1024;
        int v97 = v60;
        _os_log_impl( (void *)&_mh_execute_header,  v56,  OS_LOG_TYPE_DEFAULT,  "upgradeToManatee Listening mode configs mask %d for device %{public}s is %d-%d-%d-%d",  buf,  0x2Au);
        if (v101 < 0) {
          operator delete(*(void **)v98);
        }
        uint64_t v9 = v82;
      }

      unsigned __int8 v14 = v18 + 1;
      ++v10;
      LODWORD(v15) = v15 - 8;
      if (v10 == *(uint64_t ***)(v9 + 184))
      {
        (*(void (**)(void, _WORD *, void, uint64_t, uint64_t))(**(void **)(v9 + 168) + 168LL))( *(void *)(v9 + 168),  __p,  ((-(int)v15 - *(_DWORD *)(v9 + 176)) >> 3),  v81,  v80);
        operator delete[](__p);
        return;
      }
    }

    sub_1003D0100(v17, (uint64_t)v98);
    if (v101 >= 0) {
      unsigned __int8 v24 = v101;
    }
    else {
      unsigned __int8 v24 = v98[8];
    }
    if (v101 < 0) {
      operator delete(*(void **)v98);
    }
    if ((v91 & 0x80000000) == 0) {
      goto LABEL_28;
    }
LABEL_27:
    operator delete(*(void **)buf);
    goto LABEL_28;
  }

  (*(void (**)(void, void, void, uint64_t, uint64_t))(**(void **)(v82 + 168) + 168LL))( *(void *)(v82 + 168),  0LL,  0LL,  v81,  v80);
}

void sub_1003FDA68( _Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20, uint64_t a21, uint64_t a22, uint64_t a23, uint64_t a24, void *__p, uint64_t a26, int a27, __int16 a28, char a29, char a30)
{
  _Unwind_Resume(a1);
}

void sub_1003FDAF8(uint64_t a1)
{
}

void sub_1003FDB08(uint64_t a1, uint64_t a2)
{
  int v4 = *(char **)(a1 + 8);
  int v5 = *(char **)(a1 + 16);
  if (v4 == v5)
  {
    v6 = *(char **)(a1 + 8);
    goto LABEL_10;
  }

  v6 = *(char **)(a1 + 8);
  while (*(void *)v6 != a2)
  {
    v6 += 8;
    if (v6 == v5)
    {
      v6 = *(char **)(a1 + 16);
      break;
    }
  }

  if (v6 == v5)
  {
    if (v4 != v5)
    {
LABEL_11:
      uint64_t v7 = a2;
      sub_1003FDBBC(a1 + 8, v6, (char *)&v7);
      sub_100008A30(a1 + 8);
      goto LABEL_12;
    }

char *sub_1003FDBBC(uint64_t a1, char *__src, char *a3)
{
  uint64_t v3 = a3;
  int v4 = __src;
  v6 = *(char **)(a1 + 8);
  uint64_t v8 = a1 + 16;
  unint64_t v7 = *(void *)(a1 + 16);
  if ((unint64_t)v6 >= v7)
  {
    size_t v13 = *(char **)a1;
    unint64_t v14 = ((uint64_t)&v6[-*(void *)a1] >> 3) + 1;
    if (v14 >> 61) {
      abort();
    }
    uint64_t v15 = __src - v13;
    uint64_t v16 = (__src - v13) >> 3;
    uint64_t v17 = v7 - (void)v13;
    if (v17 >> 2 > v14) {
      unint64_t v14 = v17 >> 2;
    }
    else {
      unint64_t v18 = v14;
    }
    uint64_t v30 = a1 + 16;
    if (v18) {
      v19 = (char *)sub_100008BA0(a1 + 16, v18);
    }
    else {
      v19 = 0LL;
    }
    int v20 = &v19[8 * v16];
    __p = v19;
    v27 = v20;
    v28 = v20;
    v29 = &v19[8 * v18];
    if (v16 == v18)
    {
      if (v15 < 1)
      {
        if (v13 == v4) {
          unint64_t v22 = 1LL;
        }
        else {
          unint64_t v22 = v15 >> 2;
        }
        unint64_t v23 = (char *)sub_100008BA0(v8, v22);
        int v20 = &v23[8 * (v22 >> 2)];
        __p = v23;
        v27 = v20;
        v29 = &v23[8 * v24];
        if (v19) {
          operator delete(v19);
        }
      }

      else
      {
        unint64_t v21 = v16 + 2;
        if (v16 >= -1) {
          unint64_t v21 = v16 + 1;
        }
        v20 -= 8 * (v21 >> 1);
        v27 = v20;
      }
    }

    *(void *)int v20 = *(void *)v3;
    v28 = v20 + 8;
    int v4 = sub_100008ADC((void **)a1, (uint64_t)&__p, v4);
    if (v28 != v27) {
      v28 += (v27 - v28 + 7) & 0xFFFFFFFFFFFFFFF8LL;
    }
    if (__p) {
      operator delete(__p);
    }
  }

  else if (__src == v6)
  {
    *(void *)__src = *(void *)a3;
    *(void *)(a1 + 8) = __src + 8;
  }

  else
  {
    uint64_t v9 = __src + 8;
    v10 = v6 - 8;
    uint64_t v11 = *(void **)(a1 + 8);
    while (v10 < v6)
    {
      uint64_t v12 = *(void *)v10;
      v10 += 8;
      *v11++ = v12;
    }

    *(void *)(a1 + 8) = v11;
    if (v6 != v9) {
      memmove(&v6[-8 * ((v6 - v9) >> 3)], __src, v6 - v9);
    }
    if (v4 <= v3) {
      v3 += 8 * (*(void *)(a1 + 8) > (unint64_t)v3);
    }
    *(void *)int v4 = *(void *)v3;
  }

  return v4;
}

void sub_1003FDDC0( _Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void *__p, uint64_t a11, uint64_t a12)
{
  if (__p) {
    operator delete(__p);
  }
  _Unwind_Resume(exception_object);
}

void sub_1003FDDF8(id a1)
{
  uint64_t v1 = operator new(0x230uLL);
  sub_10042BC28();
  off_1008D60A8 = v1;
}

void sub_1003FDE28(_Unwind_Exception *a1)
{
}

void sub_1003FDE3C(id a1)
{
  uint64_t v1 = operator new(0x260uLL);
  sub_1005285C8((uint64_t)v1);
  off_1008D67A0 = v1;
}

void sub_1003FDE6C(_Unwind_Exception *a1)
{
}

void sub_1003FDE80(id a1)
{
  uint64_t v1 = operator new(0x138uLL);
  sub_1003FE3E0((uint64_t)v1);
  off_1008D5F48 = v1;
}

void sub_1003FDEB0(_Unwind_Exception *a1)
{
}

void sub_1003FDEC4(id a1)
{
  uint64_t v1 = operator new(0x198uLL);
  sub_100534AB0();
  off_1008D67B0 = v1;
}

void sub_1003FDEF4(_Unwind_Exception *a1)
{
}

void sub_1003FDF08(id a1)
{
  uint64_t v1 = operator new(0x1128uLL);
  sub_1005DDADC();
  off_1008D6600 = v1;
}

void sub_1003FDF38(_Unwind_Exception *a1)
{
}

void sub_1003FDF4C(id a1)
{
  uint64_t v1 = operator new(0xEB0uLL);
  sub_10061991C();
  qword_1008D5F18 = (uint64_t)v1;
}

void sub_1003FDF7C(_Unwind_Exception *a1)
{
}

void sub_1003FDF90(id a1)
{
  uint64_t v1 = operator new(0x2C8uLL);
  sub_100213DA8();
  off_1008D60D8 = v1;
}

void sub_1003FDFC0(_Unwind_Exception *a1)
{
}

void sub_1003FDFD4(id a1)
{
  uint64_t v1 = operator new(0x2C0uLL);
  sub_1004219F0();
  off_1008D60C8 = v1;
}

void sub_1003FE004(_Unwind_Exception *a1)
{
}

void sub_1003FE018(id a1)
{
  uint64_t v1 = operator new(0x2B0uLL);
  sub_10040749C((uint64_t)v1);
  off_1008D5EF8 = v1;
}

void sub_1003FE048(_Unwind_Exception *a1)
{
}

void sub_1003FE05C(id a1)
{
  uint64_t v1 = operator new(0x48uLL);
  sub_1001FFA34((uint64_t)v1);
  qword_1008D9038 = (uint64_t)v1;
}

void sub_1003FE08C(_Unwind_Exception *a1)
{
}

void sub_1003FE0A0(id a1)
{
  uint64_t v1 = (char *)operator new(0xF8uLL);
  *(void *)uint64_t v1 = off_100895E70;
  *((void *)v1 + 1) = off_100895F30;
  *((void *)v1 + 2) = off_100895F80;
  *((void *)v1 + 3) = off_100895FB0;
  *((void *)v1 + 4) = off_100895FD0;
  *((void *)v1 + 5) = off_100896010;
  v1[48] = 0;
  sub_100242DC4(v1 + 104);
  *((_DWORD *)v1 + 60) = 0;
  *((_OWORD *)v1 + 13) = 0u;
  *((_OWORD *)v1 + 14) = 0u;
  *((_OWORD *)v1 + 11) = 0u;
  *((_OWORD *)v1 + 12) = 0u;
  *((_WORD *)v1 + 122) = 1;
  *(_OWORD *)(v1 + 49) = 0u;
  *(_OWORD *)(v1 + 65) = 0u;
  *(_OWORD *)(v1 + 81) = 0u;
  *(void *)(v1 + 95) = 0LL;
  off_1008D60B8 = v1;
}

void sub_1003FE128(_Unwind_Exception *a1)
{
}

void *sub_1003FE13C(void *result, uint64_t a2, uint64_t a3, float a4)
{
  if (v4 >= 0) {
    int v5 = result;
  }
  else {
    int v5 = (void *)*result;
  }
  *(float *)a3 = a4;
  *(void *)(a3 + 4) = v5;
  *(_WORD *)(a3 + 12) = 2112;
  *(void *)(a3 + 14) = a2;
  return result;
}

  ;
}

void sub_1003FE190(void *a1, uint64_t a2, os_log_t log, const char *a4, ...)
{
}

BOOL sub_1003FE1A4(uint64_t a1, unsigned __int8 *a2)
{
  return sub_1001F48A0(a2, a1);
}

void *sub_1003FE1B4@<X0>(unsigned __int8 *a1@<X0>, void *a2@<X8>)
{
  *(void *)__str = 0LL;
  uint64_t v5 = 0LL;
  char v6 = 0;
  snprintf(__str, 0x12uLL, "%02X:%02X:%02X:%02X:%02X:%02X", *a1, a1[1], a1[2], a1[3], a1[4], a1[5]);
  char v7 = 0;
  return sub_10002418C(a2, __str);
}

BOOL sub_1003FE254(uint64_t a1, uint64_t a2)
{
  uint64_t v2 = *(void **)a1;
  uint64_t v3 = *(void **)(a1 + 8);
  if (*(void **)a1 != v3)
  {
    while (*v2 != a2)
    {
      if (++v2 == v3)
      {
        uint64_t v2 = *(void **)(a1 + 8);
        return v2 != v3;
      }
    }
  }

  return v2 != v3;
}

BOOL sub_1003FE288(char **a1, uint64_t a2)
{
  uint64_t v3 = *a1;
  int v4 = a1[1];
  if (*a1 != v4)
  {
    while (*(void *)v3 != a2)
    {
      v3 += 8;
      if (v3 == v4)
      {
        uint64_t v3 = a1[1];
        break;
      }
    }
  }

  if (v3 != v4)
  {
    if (v4 != v3 + 8) {
      memmove(v3, v3 + 8, v4 - (v3 + 8));
    }
    a1[1] = v4 - 8;
  }

  return v3 != v4;
}

uint64_t sub_1003FE304(uint64_t a1)
{
  *(void *)a1 = off_100896348;
  *(void *)(a1 + 8) = off_1008963D0;
  *(void *)(a1 + 16) = off_1008963F0;
  *(void *)(a1 + 24) = off_100896428;
  *(void *)(a1 + 32) = &off_100896450;
  *(void *)(a1 + 40) = off_100896468;
  sub_100242DC4(a1 + 48);
  *(void *)(a1 + 120) = 0LL;
  *(void *)(a1 + 128) = 0LL;
  *(void *)(a1 + 112) = a1 + 120;
  *(_BYTE *)(a1 + 136) = 0;
  *(void *)(a1 + 144) = 0LL;
  *(void *)(a1 + 152) = 0LL;
  *(void *)(a1 + 160) = 0LL;
  sub_100242DC4(a1 + 168);
  *(_DWORD *)(a1 + 240) = 0;
  *(void *)(a1 + 248) = 0LL;
  *(void *)(a1 + 256) = 0LL;
  *(void *)(a1 + 280) = 0LL;
  *(void *)(a1 + 288) = 0LL;
  *(void *)(a1 + 264) = 0LL;
  *(void *)(a1 + 272) = a1 + 280;
  *(_BYTE *)(a1 + 305) = 0;
  return a1;
}

void sub_1003FE3AC(_Unwind_Exception *a1)
{
  char v6 = v4;
  uint64_t v8 = *v6;
  if (*v6)
  {
    *(void *)(v1 + 152) = v8;
    operator delete(v8);
  }

  sub_10023BF24(v3, *v5);
  sub_100242E28(v2);
  _Unwind_Resume(a1);
}

uint64_t sub_1003FE3E4(uint64_t a1)
{
  *(void *)a1 = off_100896348;
  *(void *)(a1 + 8) = off_1008963D0;
  *(void *)(a1 + 16) = off_1008963F0;
  *(void *)(a1 + 24) = off_100896428;
  *(void *)(a1 + 32) = &off_100896450;
  *(void *)(a1 + 40) = off_100896468;
  sub_10023BF24(a1 + 272, *(void **)(a1 + 280));
  uint64_t v2 = *(void **)(a1 + 248);
  if (v2)
  {
    *(void *)(a1 + 256) = v2;
    operator delete(v2);
  }

  sub_100242E28(a1 + 168);
  uint64_t v3 = *(void **)(a1 + 144);
  if (v3)
  {
    *(void *)(a1 + 152) = v3;
    operator delete(v3);
  }

  sub_10023BF24(a1 + 112, *(void **)(a1 + 120));
  sub_100242E28(a1 + 48);
  return a1;
}

uint64_t sub_1003FE478(uint64_t a1)
{
  return sub_1003FE3E4(a1 - 16);
}

void sub_1003FE480(uint64_t a1)
{
  uint64_t v1 = (void *)sub_1003FE3E4(a1);
  operator delete(v1);
}

void sub_1003FE494(uint64_t a1)
{
  uint64_t v1 = (void *)sub_1003FE3E4(a1 - 16);
  operator delete(v1);
}

uint64_t sub_1003FE4AC(uint64_t a1)
{
  v29[0] = 0LL;
  v29[1] = 0LL;
  sub_100242F28((uint64_t)v29, a1 + 168);
  if (qword_1008D61A8 != -1) {
    dispatch_once(&qword_1008D61A8, &stru_1008964F0);
  }
  sub_1003B423C(qword_1008D61A0 + 8, a1 + 8);
  if (qword_1008D67B8 != -1) {
    dispatch_once(&qword_1008D67B8, &stru_100896510);
  }
  sub_10053608C(off_1008D67B0, a1 + 16);
  if (qword_1008D67E8 != -1) {
    dispatch_once(&qword_1008D67E8, &stru_100896530);
  }
  sub_1000762CC((uint64_t)off_1008D67E0 + 24, a1 + 24);
  if (qword_1008D6788 != -1) {
    dispatch_once(&qword_1008D6788, &stru_100896550);
  }
  sub_10024DD9C((uint64_t)off_1008D6780 + 80, a1 + 32);
  if (qword_1008D60B0 != -1) {
    dispatch_once(&qword_1008D60B0, &stru_100896570);
  }
  sub_1001FC5E4((uint64_t)off_1008D60A8 + 80, a1 + 40);
  atomic_store(0, (unsigned __int8 *)(a1 + 232));
  if (MKBDeviceUnlockedSinceBoot())
  {
    uint64_t v2 = (void (***)(void))sub_1002E6D7C();
    (**v2)(v2);
    uint64_t v3 = (os_log_s *)qword_1008F7578;
    if (os_log_type_enabled((os_log_t)qword_1008F7578, OS_LOG_TYPE_DEFAULT))
    {
      *(_WORD *)buf = 0;
      _os_log_impl( (void *)&_mh_execute_header,  v3,  OS_LOG_TYPE_DEFAULT,  "DeviceManager init, system already unlocked, allow read/write device settings",  buf,  2u);
    }

    atomic_store(1u, (unsigned __int8 *)(a1 + 232));
    int v4 = *(uint64_t **)(a1 + 144);
    uint64_t v5 = *(uint64_t **)(a1 + 152);
    while (v4 != v5)
      sub_1003CCB84(*v4++);
    sub_1003FE9E4((os_unfair_lock_s *)a1);
    if (qword_1008D5F00 != -1) {
      dispatch_once(&qword_1008D5F00, &stru_100896590);
    }
    sub_10040A568((uint64_t)off_1008D5EF8);
  }

  else
  {
    int out_token = 0;
    uint64_t v8 = *(dispatch_queue_s **)(sub_100404EB8() + 8);
    handler[0] = _NSConcreteStackBlock;
    handler[1] = 3221225472LL;
    handler[2] = sub_1003FEC24;
    handler[3] = &unk_10088E280;
    handler[4] = a1;
    uint64_t v9 = notify_register_dispatch("com.apple.mobile.keybagd.first_unlock", &out_token, v8, handler);
    unsigned int v11 = v9;
    if ((_DWORD)v9)
    {
      if (IsAppleInternalBuild(v9, v10))
      {
        uint64_t v26 = 0LL;
        __int128 v24 = 0u;
        memset(v25, 0, sizeof(v25));
        *(_OWORD *)unint64_t v22 = 0u;
        __int128 v23 = 0u;
        memset(v21, 0, sizeof(v21));
        *(_OWORD *)buf = 0u;
        sub_1001FCFC8((uint64_t)buf);
        uint64_t v12 = sub_1001FD17C(v21, (uint64_t)"Failed registration for MKB first unlock notification with error : ", 67LL);
        std::to_string(&__p, v11);
        if ((__p.__r_.__value_.__s.__size_ & 0x80u) == 0) {
          p_p = &__p;
        }
        else {
          p_p = (std::stringbuf::string_type *)__p.__r_.__value_.__r.__words[0];
        }
        if ((__p.__r_.__value_.__s.__size_ & 0x80u) == 0) {
          uint64_t size = __p.__r_.__value_.__s.__size_;
        }
        else {
          uint64_t size = __p.__r_.__value_.__l.__size_;
        }
        sub_1001FD17C(v12, (uint64_t)p_p, size);
        std::stringbuf::str(&__p, (const std::stringbuf *)((char *)v21 + 8));
        if ((__p.__r_.__value_.__s.__size_ & 0x80u) == 0) {
          uint64_t v15 = &__p;
        }
        else {
          uint64_t v15 = (std::stringbuf::string_type *)__p.__r_.__value_.__r.__words[0];
        }
        sub_1000BAAF0((const char *)v15);
        *(void *)&v21[0] = v16;
        if (SHIBYTE(v23) < 0) {
          operator delete(v22[1]);
        }
        std::streambuf::~streambuf((char *)v21 + 8);
        std::ios::~ios(v25);
      }

      else
      {
        unint64_t v18 = (os_log_s *)qword_1008F7578;
        if (os_log_type_enabled((os_log_t)qword_1008F7578, OS_LOG_TYPE_FAULT)) {
          sub_10067B698(v11, v18);
        }
      }
    }

    else
    {
      uint64_t v17 = (os_log_s *)qword_1008F7578;
      if (os_log_type_enabled((os_log_t)qword_1008F7578, OS_LOG_TYPE_DEFAULT))
      {
        *(_WORD *)buf = 0;
        _os_log_impl( (void *)&_mh_execute_header,  v17,  OS_LOG_TYPE_DEFAULT,  "Successfully registered for MKB first unlock notification",  buf,  2u);
      }
    }
  }

  *(_DWORD *)(a1 + 296) = 0;
  uint64_t v6 = sub_1002E6E00();
  sub_10002418C(buf, "A2DP");
  sub_10002418C(&__p, "WirelessSplitterLinkKeyTimeout");
  (*(void (**)(uint64_t, uint8_t *, std::stringbuf::string_type *, uint64_t))(*(void *)v6 + 88LL))( v6,  buf,  &__p,  a1 + 296);
  if (SBYTE7(v21[0]) < 0) {
    operator delete(*(void **)buf);
  }
  *(_DWORD *)(a1 + 300) = 0;
  *(_BYTE *)(a1 + 304) = 0;
  return sub_100242FAC((uint64_t)v29);
}

void sub_1003FE95C( _Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void *__p, uint64_t a11, int a12, __int16 a13, char a14, char a15, void *a16, uint64_t a17, int a18, __int16 a19, char a20, char a21)
{
  if (a15 < 0) {
    operator delete(__p);
  }
  sub_1001FD0F4((uint64_t)&a16);
  sub_100242FAC(v21 - 64);
  _Unwind_Resume(a1);
}

uint64_t sub_1003FE9E4(os_unfair_lock_s *a1)
{
  uint64_t v2 = (os_log_s *)qword_1008F7578;
  if (os_log_type_enabled((os_log_t)qword_1008F7578, OS_LOG_TYPE_DEFAULT))
  {
    *(_WORD *)buf = 0;
    _os_log_impl( (void *)&_mh_execute_header,  v2,  OS_LOG_TYPE_DEFAULT,  "Device Database has been updated, update device info for all paired devices",  buf,  2u);
  }

  v14[0] = 0LL;
  v14[1] = 0LL;
  sub_100242F28((uint64_t)v14, (uint64_t)&a1[42]);
  *(void *)buf = 0LL;
  uint64_t v12 = 0LL;
  uint64_t v13 = 0LL;
  sub_100240540(buf, (uint64_t)&a1[36]);
  sub_100242F54((uint64_t)v14);
  int v4 = *(uint64_t **)buf;
  uint64_t v3 = v12;
  if (*(uint64_t **)buf != v12)
  {
    do
    {
      uint64_t v5 = *v4;
      if (*v4)
      {
        uint64_t v6 = (os_log_s *)qword_1008F7578;
        if (os_log_type_enabled((os_log_t)qword_1008F7578, OS_LOG_TYPE_DEFAULT))
        {
          sub_1003CF00C(v5, __p);
          char v7 = v10 >= 0 ? __p : (void **)__p[0];
          *(_DWORD *)uint64_t v15 = 136446210;
          uint64_t v16 = v7;
          _os_log_impl( (void *)&_mh_execute_header,  v6,  OS_LOG_TYPE_DEFAULT,  "Sending 'name changed' event for device %{public}s",  v15,  0xCu);
          if (v10 < 0) {
            operator delete(__p[0]);
          }
        }

        sub_1003FFDA4(a1, v5, 6);
        if (qword_1008D60D0 != -1) {
          dispatch_once(&qword_1008D60D0, &stru_1008965B0);
        }
        sub_1004267B0((uint64_t)off_1008D60C8, v5, 0xFFFFFFFFLL, 0LL, 701LL, 0LL);
        uint64_t v3 = v12;
      }

      ++v4;
    }

    while (v4 != v3);
    int v4 = *(uint64_t **)buf;
  }

  if (v4)
  {
    uint64_t v12 = v4;
    operator delete(v4);
  }

  return sub_100242FAC((uint64_t)v14);
}

void sub_1003FEBE8( _Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, void *__p, uint64_t a16, uint64_t a17, uint64_t a18, char a19)
{
  if (__p) {
    operator delete(__p);
  }
  sub_100242FAC((uint64_t)&a19);
  _Unwind_Resume(a1);
}

void sub_1003FEC24(uint64_t a1)
{
}

void sub_1003FEC2C(uint64_t a1)
{
  uint64_t v2 = (os_log_s *)qword_1008F7578;
  if (os_log_type_enabled((os_log_t)qword_1008F7578, OS_LOG_TYPE_DEFAULT))
  {
    *(_DWORD *)buf = 67109120;
    int v7 = MKBDeviceUnlockedSinceBoot();
    _os_log_impl( (void *)&_mh_execute_header,  v2,  OS_LOG_TYPE_DEFAULT,  "DeviceManager: Received MKB first unlock notification. MKBDeviceUnlockedSinceBoot returns : %d",  buf,  8u);
  }

  if (MKBDeviceUnlockedSinceBoot() != 1
    && os_log_type_enabled((os_log_t)qword_1008F7578, OS_LOG_TYPE_FAULT))
  {
    sub_10067B708();
  }

  uint64_t v3 = (void (***)(void))sub_1002E6D7C();
  (**v3)(v3);
  uint64_t v4 = sub_100404EB8();
  v5[0] = _NSConcreteStackBlock;
  v5[1] = 3221225472LL;
  v5[2] = sub_100403074;
  v5[3] = &unk_10087EB20;
  v5[4] = a1;
  sub_100405460(v4, 2000LL, v5);
  *(_BYTE *)(a1 + 305) = 1;
}

void sub_1003FED5C(void *a1)
{
  if (qword_1008D67E8 != -1) {
    dispatch_once(&qword_1008D67E8, &stru_100896530);
  }
  sub_100009168((uint64_t)off_1008D67E0 + 24, (uint64_t)(a1 + 3));
  if (qword_1008D67B8 != -1) {
    dispatch_once(&qword_1008D67B8, &stru_100896510);
  }
  sub_1005361C4((uint64_t)off_1008D67B0, (uint64_t)(a1 + 2));
  if (qword_1008D61A8 != -1) {
    dispatch_once(&qword_1008D61A8, &stru_1008964F0);
  }
  sub_100009168(qword_1008D61A0 + 8, (uint64_t)(a1 + 1));
  if (qword_1008D60B0 != -1) {
    dispatch_once(&qword_1008D60B0, &stru_100896570);
  }
  sub_100009168((uint64_t)off_1008D60A8 + 80, (uint64_t)(a1 + 5));
  uint64_t v2 = (void *)a1[14];
  uint64_t v3 = a1 + 15;
  if (v2 != a1 + 15)
  {
    do
    {
      if (qword_1008D61A8 != -1) {
        dispatch_once(&qword_1008D61A8, &stru_1008964F0);
      }
      sub_100497354(qword_1008D61A0, v2[4]);
      uint64_t v4 = (void *)v2[1];
      if (v4)
      {
        do
        {
          uint64_t v5 = v4;
          uint64_t v4 = (void *)*v4;
        }

        while (v4);
      }

      else
      {
        do
        {
          uint64_t v5 = (void *)v2[2];
          BOOL v6 = *v5 == (void)v2;
          uint64_t v2 = v5;
        }

        while (!v6);
      }

      uint64_t v2 = v5;
    }

    while (v5 != v3);
  }

  sub_10023BF24((uint64_t)(a1 + 14), (void *)a1[15]);
  a1[15] = 0LL;
  a1[16] = 0LL;
  a1[14] = v3;
}

unint64_t sub_1003FEF18(uint64_t a1, unint64_t a2)
{
  v12[0] = 0LL;
  v12[1] = 0LL;
  sub_100242F28((uint64_t)v12, a1 + 48);
  if (a2)
  {
    BOOL v6 = *(void **)(a1 + 120);
    uint64_t v5 = (void *)(a1 + 120);
    uint64_t v4 = v6;
    if (!v6) {
      goto LABEL_13;
    }
    int v7 = v5;
    do
    {
      unint64_t v8 = v4[4];
      BOOL v9 = v8 >= a2;
      if (v8 >= a2) {
        char v10 = v4;
      }
      else {
        char v10 = v4 + 1;
      }
      if (v9) {
        int v7 = v4;
      }
      uint64_t v4 = (void *)*v10;
    }

    while (*v10);
    if (v7 != v5 && v7[4] <= a2) {
      a2 = v7[5];
    }
    else {
LABEL_13:
    }
      a2 = 0LL;
  }

  sub_100242FAC((uint64_t)v12);
  return a2;
}

unint64_t sub_1003FEFA8(uint64_t a1, unint64_t a2, uint64_t a3)
{
  v16[0] = 0LL;
  v16[1] = 0LL;
  sub_100242F28((uint64_t)v16, a1 + 48);
  unint64_t v6 = 0LL;
  if (a2 && a3)
  {
    if (qword_1008D61A8 != -1) {
      dispatch_once(&qword_1008D61A8, &stru_1008964F0);
    }
    unint64_t v7 = sub_10049729C(qword_1008D61A0, a2);
    if (!v7) {
      goto LABEL_22;
    }
    char v10 = *(uint64_t ***)(a1 + 112);
    unint64_t v8 = (uint64_t **)(a1 + 112);
    BOOL v9 = (uint64_t *)v10;
    if (v10 != v8 + 1)
    {
      do
      {
        if (v9[5] == a3)
        {
          unint64_t v6 = v9[4];
          if (v6 == a2)
          {
            unint64_t v6 = a2;
            goto LABEL_23;
          }

          if (qword_1008D61A8 != -1) {
            dispatch_once(&qword_1008D61A8, &stru_1008964F0);
          }
          if (sub_10049729C(qword_1008D61A0, v6) == v7) {
            goto LABEL_23;
          }
        }

        unsigned int v11 = (uint64_t *)v9[1];
        if (v11)
        {
          do
          {
            uint64_t v12 = (uint64_t **)v11;
            unsigned int v11 = (uint64_t *)*v11;
          }

          while (v11);
        }

        else
        {
          do
          {
            uint64_t v12 = (uint64_t **)v9[2];
            BOOL v13 = *v12 == v9;
            BOOL v9 = (uint64_t *)v12;
          }

          while (!v13);
        }

        BOOL v9 = (uint64_t *)v12;
      }

      while (v12 != v8 + 1);
    }

    if (qword_1008D61A8 != -1) {
      dispatch_once(&qword_1008D61A8, &stru_1008964F0);
    }
    unint64_t v15 = sub_100496E90(qword_1008D61A0, v7);
    if (v15)
    {
      uint64_t v17 = &v15;
      sub_100029574(v8, &v15, (uint64_t)&unk_1006C2518, (uint64_t **)&v17)[5] = a3;
      unint64_t v6 = v15;
    }

    else
    {
LABEL_22:
      unint64_t v6 = 0LL;
    }
  }

void sub_1003FF170(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, ...)
{
}

uint64_t sub_1003FF194(uint64_t a1, uint64_t a2)
{
  v14[0] = 0LL;
  v14[1] = 0LL;
  sub_100242F28((uint64_t)v14, a1 + 48);
  unint64_t v6 = *(uint64_t **)(a1 + 112);
  uint64_t v4 = (uint64_t **)(a1 + 112);
  uint64_t v5 = v6;
  if (v6 != (uint64_t *)(v4 + 1))
  {
    do
    {
      unint64_t v7 = v5[4];
      if (qword_1008D61A8 != -1) {
        dispatch_once(&qword_1008D61A8, &stru_1008964F0);
      }
      uint64_t v8 = sub_10049729C(qword_1008D61A0, v7);
      BOOL v9 = (uint64_t *)v5[1];
      if (v8 == a2)
      {
        uint64_t v12 = v5;
        if (v9)
        {
          do
          {
            char v10 = (uint64_t **)v9;
            BOOL v9 = (uint64_t *)*v9;
          }

          while (v9);
        }

        else
        {
          do
          {
            char v10 = (uint64_t **)v12[2];
            BOOL v11 = *v10 == v12;
            uint64_t v12 = (uint64_t *)v10;
          }

          while (!v11);
        }

        sub_1001FDBCC(v4, v5);
        operator delete(v5);
        if (qword_1008D61A8 != -1) {
          dispatch_once(&qword_1008D61A8, &stru_1008964F0);
        }
        sub_100497354(qword_1008D61A0, v7);
      }

      else if (v9)
      {
        do
        {
          char v10 = (uint64_t **)v9;
          BOOL v9 = (uint64_t *)*v9;
        }

        while (v9);
      }

      else
      {
        do
        {
          char v10 = (uint64_t **)v5[2];
          BOOL v11 = *v10 == v5;
          uint64_t v5 = (uint64_t *)v10;
        }

        while (!v11);
      }

      uint64_t v5 = (uint64_t *)v10;
    }

    while (v10 != v4 + 1);
  }

  return sub_100242FAC((uint64_t)v14);
}

void sub_1003FF2F8( _Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9)
{
}

uint64_t sub_1003FF30C(uint64_t a1, uint64_t a2)
{
  return sub_1003FF194(a1 - 8, a2);
}

void sub_1003FF314(uint64_t a1, uint64_t a2)
{
}

void sub_1003FF31C(uint64_t a1, uint64_t a2)
{
}

uint64_t sub_1003FF324(uint64_t a1, unsigned __int8 *a2)
{
  uint64_t result = sub_1003D0670((uint64_t)a2);
  if ((result & 1) == 0)
  {
    uint64_t v4 = (os_log_s *)qword_1008F7578;
    if (os_log_type_enabled((os_log_t)qword_1008F7578, OS_LOG_TYPE_DEFAULT))
    {
      sub_1003CF00C((uint64_t)a2, __p);
      if (v7 >= 0) {
        uint64_t v5 = __p;
      }
      else {
        uint64_t v5 = (void **)__p[0];
      }
      *(_DWORD *)buf = 136446210;
      BOOL v9 = v5;
      _os_log_impl( (void *)&_mh_execute_header,  v4,  OS_LOG_TYPE_DEFAULT,  "Device %{public}s is fully disconnected and now unpaired, resetting it",  buf,  0xCu);
      if (v7 < 0) {
        operator delete(__p[0]);
      }
    }

    return sub_1003E46E8((uint64_t)a2);
  }

  return result;
}

uint64_t sub_1003FF41C(uint64_t result, uint64_t a2, int a3)
{
  uint64_t v5 = result;
  int v6 = 0;
  if (*(_BYTE *)(a2 + 960))
  {
    sub_1003DF02C(a2, &v6);
    uint64_t result = (uint64_t)sub_1003FF4AC(v5, a2);
  }

  if (!a3)
  {
    sub_1000B0740(&v6, 0LL);
    sub_1003E3A30(a2, &v6);
    uint64_t result = sub_1003D0268(a2);
    *(_DWORD *)(v5 + 300) |= 1 << result;
  }

  return result;
}

uint64_t **sub_1003FF4AC(uint64_t a1, uint64_t a2)
{
  uint64_t v19 = a2;
  uint64_t v2 = (uint64_t **)(a1 + 272);
  if (*(void *)(a1 + 288))
  {
    uint64_t v4 = (unsigned __int8 *)(*v2)[4];
    if (v4 == (unsigned __int8 *)a2)
    {
      if (*((_BYTE *)*v2 + 40))
      {
        char v7 = (os_log_s *)qword_1008F7578;
        if (os_log_type_enabled((os_log_t)qword_1008F7578, OS_LOG_TYPE_DEFAULT))
        {
          sub_1003CF00C(a2, &__p);
          uint64_t v8 = (__p.__r_.__value_.__s.__size_ & 0x80u) == 0 ? &__p : (std::string *)__p.__r_.__value_.__r.__words[0];
          *(_DWORD *)buf = 136446210;
          *(void *)&uint8_t buf[4] = v8;
          _os_log_impl( (void *)&_mh_execute_header,  v7,  OS_LOG_TYPE_DEFAULT,  "Wireless Splitter cancelling linkkey timeout for guest device %{public}s",  buf,  0xCu);
        }

        sub_100403180(a1, 0, 0LL);
        *(_DWORD *)(a2 + 972) = 3;
      }
    }

    else
    {
      memset(&__p, 0, sizeof(__p));
      uint64_t v5 = sub_10002418C(&__p, "WS_ERROR_OTHER_DELETE_GUEST_ONLY_ONE_ALLOWED");
      else {
        std::string __dst = __p;
      }
      sub_1003FFAD8((uint64_t)v5, &__dst);
      BOOL v9 = (os_log_s *)qword_1008F7578;
      if (os_log_type_enabled((os_log_t)qword_1008F7578, OS_LOG_TYPE_DEFAULT))
      {
        sub_1003CF00C((uint64_t)v4, buf);
        int v10 = v21;
        BOOL v11 = *(_BYTE **)buf;
        sub_1003CF00C(a2, v15);
        uint64_t v12 = buf;
        if (v10 < 0) {
          uint64_t v12 = v11;
        }
        if (v16 >= 0) {
          BOOL v13 = v15;
        }
        else {
          BOOL v13 = (void **)v15[0];
        }
        *(_DWORD *)unint64_t v22 = 136446466;
        __int128 v23 = v12;
        __int16 v24 = 2082;
        v25 = v13;
        _os_log_impl( (void *)&_mh_execute_header,  v9,  OS_LOG_TYPE_DEFAULT,  "Wireless Splitter deleting guest device %{public}s, to only allow one guest at a time. New guest device will be %{public}s",  v22,  0x16u);
        if (v16 < 0) {
          operator delete(v15[0]);
        }
        if (v21 < 0) {
          operator delete(*(void **)buf);
        }
      }

      if (qword_1008D67A8 != -1) {
        dispatch_once(&qword_1008D67A8, &stru_100896630);
      }
      sub_10052F37C((uint64_t)off_1008D67A0, v4);
    }
  }

  __p.__r_.__value_.__r.__words[0] = (std::string::size_type)&v19;
  uint64_t result = sub_100404694(v2, (unint64_t *)&v19, (uint64_t)&unk_1006C2518, &__p);
  *((_BYTE *)result + 40) = 0;
  return result;
}

void sub_1003FF760( _Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, int a15, __int16 a16, char a17, char a18, uint64_t a19, void *a20, uint64_t a21, int a22, __int16 a23, char a24, char a25, uint64_t a26, void *__p, uint64_t a28, int a29, __int16 a30, char a31, char a32)
{
  if (a32 < 0) {
    operator delete(__p);
  }
  if (a25 < 0) {
    operator delete(a20);
  }
  _Unwind_Resume(exception_object);
}

uint64_t sub_1003FF7B4(uint64_t a1, uint64_t a2, int a3)
{
  return sub_1003FF41C(a1 - 24, a2, a3);
}

uint64_t sub_1003FF7BC(uint64_t a1, unint64_t a2, int a3, int a4)
{
  uint64_t result = sub_1003D0670(a2);
  if ((result & 1) != 0 || (uint64_t result = sub_1003CF350((unsigned __int8 *)a2), (result & 1) != 0))
  {
    if (!a3)
    {
      int v15 = 0;
      sub_1000B0740(&v15, 0LL);
      sub_1003E3A30(a2, &v15);
      *(_DWORD *)(a1 + 300) &= ~(1 << sub_1003D0268(a2));
      if (*(_BYTE *)(a2 + 960))
      {
        BOOL v9 = (os_log_s *)qword_1008F7578;
        if (os_log_type_enabled((os_log_t)qword_1008F7578, OS_LOG_TYPE_DEFAULT))
        {
          sub_1003CF00C(a2, &__p);
          int v10 = (__p.__r_.__value_.__s.__size_ & 0x80u) == 0 ? &__p : (std::string *)__p.__r_.__value_.__r.__words[0];
          LODWORD(buf.__r_.__value_.__l.__data_) = 136446466;
          *(std::string::size_type *)((char *)buf.__r_.__value_.__r.__words + 4) = (std::string::size_type)v10;
          WORD2(buf.__r_.__value_.__r.__words[1]) = 1024;
          *(_DWORD *)((char *)&buf.__r_.__value_.__r.__words[1] + 6) = a4;
          _os_log_impl( (void *)&_mh_execute_header,  v9,  OS_LOG_TYPE_DEFAULT,  "Wireless Splitter guest device %{public}s disconnected with reason %u",  (uint8_t *)&buf,  0x12u);
        }

        memset(&__p, 0, sizeof(__p));
        std::to_string(&__p, a4);
        memset(&buf, 0, sizeof(buf));
        BOOL v11 = std::operator+<char>(&buf, "WS_ERROR_DISCONNECTION_", &__p);
        else {
          std::string v14 = buf;
        }
        sub_1003FFAD8((uint64_t)v11, &v14);
        sub_1003DF02C(a2, &v15);
        sub_1003FFC30(a1, a2);
      }

      sub_10002418C(&__p, "");
      *(_BYTE *)(a2 + 1435) = 0;
      std::string::operator=((std::string *)(a2 + 1480), &__p);
      return sub_1003D1BD4(a2, 0);
    }
  }

  else
  {
    uint64_t v12 = (os_log_s *)qword_1008F7578;
    if (os_log_type_enabled((os_log_t)qword_1008F7578, OS_LOG_TYPE_DEFAULT))
    {
      sub_1003CF00C(a2, &__p);
      BOOL v13 = (__p.__r_.__value_.__s.__size_ & 0x80u) == 0 ? &__p : (std::string *)__p.__r_.__value_.__r.__words[0];
      LODWORD(buf.__r_.__value_.__l.__data_) = 136446210;
      *(std::string::size_type *)((char *)buf.__r_.__value_.__r.__words + 4) = (std::string::size_type)v13;
      _os_log_impl( (void *)&_mh_execute_header,  v12,  OS_LOG_TYPE_DEFAULT,  "Device %{public}s is unpaired and now fully disconnected, resetting it",  (uint8_t *)&buf,  0xCu);
    }

    return sub_1003E46E8(a2);
  }

  return result;
}

void sub_1003FFA80( _Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, void *__p, uint64_t a10, int a11, __int16 a12, char a13, char a14, uint64_t a15, uint64_t a16, void *a17, uint64_t a18, int a19, __int16 a20, char a21, char a22, void *a23, uint64_t a24, int a25, __int16 a26, char a27, char a28)
{
  if (a14 < 0) {
    operator delete(__p);
  }
  if (a28 < 0) {
    operator delete(a23);
  }
  if (a22 < 0) {
    operator delete(a17);
  }
  _Unwind_Resume(exception_object);
}

void sub_1003FFAD8(uint64_t a1, const std::string *a2)
{
  *(_OWORD *)std::string __p = 0u;
  __int128 v12 = 0u;
  __int128 v9 = 0u;
  *(_OWORD *)int v10 = 0u;
  *(_OWORD *)char v7 = 0u;
  *(_OWORD *)uint64_t v8 = 0u;
  memset(v6, 0, sizeof(v6));
  sub_10037FDD8((uint64_t)v6);
  std::string::operator=((std::string *)&__p[1], a2);
  uint64_t v3 = (os_log_s *)qword_1008F7578;
  if (os_log_type_enabled((os_log_t)qword_1008F7578, OS_LOG_TYPE_DEFAULT))
  {
    if (v12 >= 0) {
      uint64_t v4 = &__p[1];
    }
    else {
      uint64_t v4 = (void **)__p[1];
    }
    *(_DWORD *)std::string buf = 136315138;
    std::string v14 = v4;
    _os_log_impl( (void *)&_mh_execute_header,  v3,  OS_LOG_TYPE_DEFAULT,  "Wireless Splitter submitting following error metric: fErrorCode %s",  buf,  0xCu);
  }

  uint64_t v5 = sub_1002E8D94();
  (*(void (**)(uint64_t, _OWORD *))(*(void *)v5 + 168LL))(v5, v6);
  if (SHIBYTE(v12) < 0) {
    operator delete(__p[1]);
  }
  if (SHIBYTE(__p[0]) < 0) {
    operator delete(v10[0]);
  }
  if (SHIBYTE(v9) < 0) {
    operator delete(v8[1]);
  }
  if (SHIBYTE(v8[0]) < 0) {
    operator delete(v7[0]);
  }
}

void sub_1003FFC14(_Unwind_Exception *exception_object)
{
}

void sub_1003FFC30(uint64_t a1, unint64_t a2)
{
  unint64_t v15 = a2;
  uint64_t v2 = *(void **)(a1 + 280);
  if (v2)
  {
    uint64_t v4 = a1 + 272;
    uint64_t v5 = a1 + 280;
    do
    {
      unint64_t v6 = v2[4];
      BOOL v7 = v6 >= a2;
      if (v6 >= a2) {
        uint64_t v8 = v2;
      }
      else {
        uint64_t v8 = v2 + 1;
      }
      if (v7) {
        uint64_t v5 = (uint64_t)v2;
      }
      uint64_t v2 = (void *)*v8;
    }

    while (*v8);
    if (v5 != a1 + 280 && *(void *)(v5 + 32) <= a2)
    {
      *(_BYTE *)sub_100403258(a1 + 272, &v15) = 1;
      int v9 = *(_DWORD *)(a1 + 296);
      if (!v9) {
        int v9 = 480000;
      }
      uint64_t v10 = v9;
      BOOL v11 = (os_log_s *)qword_1008F7578;
      if (os_log_type_enabled((os_log_t)qword_1008F7578, OS_LOG_TYPE_DEFAULT))
      {
        sub_1003CF00C(*(void *)(*(void *)v4 + 32LL), __p);
        if (v14 >= 0) {
          __int128 v12 = __p;
        }
        else {
          __int128 v12 = (void **)__p[0];
        }
        *(_DWORD *)std::string buf = 136446466;
        uint64_t v17 = v12;
        __int16 v18 = 2048;
        uint64_t v19 = v10;
        _os_log_impl( (void *)&_mh_execute_header,  v11,  OS_LOG_TYPE_DEFAULT,  "Wireless Splitter starting linkkey timeout for guest device %{public}s with timeout %llums",  buf,  0x16u);
        if (v14 < 0) {
          operator delete(__p[0]);
        }
      }

      sub_100403180(a1, 1, v10);
    }
  }

uint64_t sub_1003FFD9C(uint64_t a1, unint64_t a2, int a3, int a4)
{
  return sub_1003FF7BC(a1 - 24, a2, a3, a4);
}

uint64_t sub_1003FFDA4(os_unfair_lock_s *a1, uint64_t a2, int a3)
{
  if (a3 != 18
    || (uint64_t v6 = sub_1002E6BF0(), !(*(unsigned int (**)(uint64_t))(*(void *)v6 + 384LL))(v6))
    || (uint64_t result = sub_100401710((uint64_t)a1), (_DWORD)result))
  {
    uint64_t v8 = (sqlite3 **)sub_1002E6CF8();
    sub_1002D3D2C(v8, a2);
    if (qword_1008D60D0 != -1) {
      dispatch_once(&qword_1008D60D0, &stru_1008965B0);
    }
    sub_10042A100((uint64_t)off_1008D60C8, a2);
    v11[0] = 0LL;
    v11[1] = 0LL;
    sub_100242F28((uint64_t)v11, (uint64_t)&a1[42]);
    v9[0] = _NSConcreteStackBlock;
    v9[1] = 3221225472LL;
    v9[2] = sub_100401998;
    v9[3] = &unk_1008964B0;
    v9[4] = a2;
    int v10 = a3;
    sub_1004018DC(a1 + 60, v9);
    return sub_100242FAC((uint64_t)v11);
  }

  return result;
}

void sub_1003FFE9C( _Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, ...)
{
}

void *sub_1003FFEB0(void *a1, uint64_t a2, int a3)
{
  if (!*(_BYTE *)a2)
  {
    uint64_t v6 = 1LL;
    while (v6 != 6)
    {
      if (*(unsigned __int8 *)(a2 + v6++))
      {
        break;
      }
    }

    uint64_t v8 = (os_log_s *)qword_1008F7578;
    if (os_log_type_enabled((os_log_t)qword_1008F7578, OS_LOG_TYPE_FAULT)) {
      sub_10067B740(v8, v9, v10, v11, v12, v13, v14, v15);
    }
  }

void sub_100400058( _Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9)
{
}

void *sub_10040007C(void *a1, uint64_t a2, int a3)
{
  if (!a2)
  {
    uint64_t v6 = (os_log_s *)qword_1008F7578;
    if (os_log_type_enabled((os_log_t)qword_1008F7578, OS_LOG_TYPE_FAULT)) {
      sub_10067B7B0(v6, v7, v8, v9, v10, v11, v12, v13);
    }
  }

  v32[0] = 0LL;
  v32[1] = 0LL;
  sub_100242F28((uint64_t)v32, (uint64_t)(a1 + 21));
  for (uint64_t i = a1[18]; i != a1[19]; i += 8LL)
  {
    uint64_t v15 = *(void **)i;
  }

  if (a3)
  {
    uint64_t v15 = operator new(0x5F0uLL);
    v31[0] = BYTE5(a2);
    v31[1] = BYTE4(a2);
    v31[2] = BYTE3(a2);
    v31[3] = BYTE2(a2);
    v31[4] = BYTE1(a2);
    v31[5] = a2;
    sub_1003CED40(v15, v31);
    unint64_t v16 = a1[20];
    uint64_t v17 = (void *)a1[19];
    if ((unint64_t)v17 >= v16)
    {
      uint64_t v19 = a1[18];
      uint64_t v20 = ((uint64_t)v17 - v19) >> 3;
      uint64_t v21 = v16 - v19;
      uint64_t v22 = v21 >> 2;
      else {
        unint64_t v23 = v22;
      }
      if (v23) {
        uint64_t v24 = (char *)sub_100008BA0((uint64_t)(a1 + 20), v23);
      }
      else {
        uint64_t v24 = 0LL;
      }
      uint64_t v25 = &v24[8 * v20];
      unint64_t v26 = &v24[8 * v23];
      *(void *)uint64_t v25 = v15;
      __int16 v18 = v25 + 8;
      v28 = (char *)a1[18];
      v27 = (char *)a1[19];
      if (v27 != v28)
      {
        do
        {
          uint64_t v29 = *((void *)v27 - 1);
          v27 -= 8;
          *((void *)v25 - 1) = v29;
          v25 -= 8;
        }

        while (v27 != v28);
        v27 = (char *)a1[18];
      }

      a1[18] = v25;
      a1[19] = v18;
      a1[20] = v26;
      if (v27) {
        operator delete(v27);
      }
    }

    else
    {
      *uint64_t v17 = v15;
      __int16 v18 = v17 + 1;
    }

    a1[19] = v18;
  }

  else
  {
    uint64_t v15 = 0LL;
  }

void sub_100400244( _Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, char a11)
{
}

std::string *sub_100400268(void *a1, uint64_t a2, std::string *a3, BOOL *a4, char *a5)
{
  *a4 = 0;
  *a5 = 0;
  v31[0] = 0LL;
  v31[1] = 0LL;
  sub_100242F28((uint64_t)v31, (uint64_t)(a1 + 21));
  LODWORD(v29.__r_.__value_.__l.__data_) = *(_DWORD *)a2;
  WORD2(v29.__r_.__value_.__r.__words[0]) = *(_WORD *)(a2 + 4);
  uint64_t v10 = (std::string *)sub_1003FFEB0(a1, (uint64_t)&v29, 1);
  int v11 = v10[26].__r_.__value_.__s.__data_[17];
  sub_1003D0C4C((uint64_t)v10, a3);
  sub_1003D0D28((uint64_t)v10, *(_BYTE *)(a2 + 13), a3);
  sub_1004006DC((uint64_t)a1, (uint64_t)v10, *(unsigned int *)(a2 + 8));
  if (sub_1003CF350((unsigned __int8 *)v10))
  {
    LODWORD(v29.__r_.__value_.__l.__data_) = 0;
    sub_1000B0740(&v29, 0LL);
    sub_1003E3A30((uint64_t)v10, &v29);
  }

  sub_100242F54((uint64_t)v31);
  uint64_t v12 = *(_BYTE **)(a2 + 16);
  if (v12 && *v12)
  {
    char v30 = 0;
    sub_100242CA4(&v30);
    int v13 = sub_10011B8C0(*(unsigned __int8 **)(a2 + 16), &__len[1], __len, a5);
    sub_100242CD0(&v30);
    *a4 = sub_1003E1D2C((uint64_t)v10, *(void **)(a2 + 16), 0xF0u);
    if (v13 || !*(void *)&__len[1] || !__len[0])
    {
LABEL_43:
      sub_100242CD8(&v30);
      goto LABEL_44;
    }

    memset(&v29, 0, sizeof(v29));
    sub_100330694(&v29, *(void **)&__len[1], __len[0]);
    if (!*a5)
    {
      sub_1003D0E18((uint64_t)v10, &v29, a3);
      goto LABEL_41;
    }

    sub_1003D01A0((uint64_t)v10, (uint64_t)&__p);
    if ((v36 & 0x80u) == 0) {
      uint64_t v14 = v36;
    }
    else {
      uint64_t v14 = *((void *)&__p + 1);
    }
    std::string::size_type size = v29.__r_.__value_.__s.__size_;
    if ((v29.__r_.__value_.__s.__size_ & 0x80u) != 0) {
      std::string::size_type size = v29.__r_.__value_.__l.__size_;
    }
    if (v14 == size)
    {
      if ((v29.__r_.__value_.__s.__size_ & 0x80u) == 0) {
        unint64_t v16 = &v29;
      }
      else {
        unint64_t v16 = (std::string *)v29.__r_.__value_.__r.__words[0];
      }
      if ((v36 & 0x80) != 0)
      {
        uint64_t v21 = (void *)__p;
        int v22 = memcmp((const void *)__p, v16, *((size_t *)&__p + 1));
        operator delete(v21);
        if (!v22) {
          goto LABEL_41;
        }
      }

      else
      {
        if (!v36) {
          goto LABEL_41;
        }
        uint64_t v17 = 0LL;
        do
        {
          int v18 = *((unsigned __int8 *)&__p + v17);
          int v19 = v16->__r_.__value_.__s.__data_[v17];
        }

        while (v18 == v19 && v36 - 1LL != v17++);
        if (v18 == v19)
        {
LABEL_41:
          goto LABEL_43;
        }
      }
    }

    else if ((v36 & 0x80) != 0)
    {
      operator delete((void *)__p);
    }

    sub_1003D0F60(v10, &v29, a3);
    unint64_t v23 = (os_log_s *)qword_1008F7578;
    if (os_log_type_enabled((os_log_t)qword_1008F7578, OS_LOG_TYPE_DEFAULT))
    {
      sub_1003CF00C((uint64_t)v10, &__p);
      uint64_t v24 = (v36 & 0x80u) == 0 ? &__p : (__int128 *)__p;
      *(_DWORD *)std::string buf = 136446210;
      v34 = v24;
      _os_log_impl( (void *)&_mh_execute_header,  v23,  OS_LOG_TYPE_DEFAULT,  "Sending 'name changed' event for device %{public}s",  buf,  0xCu);
    }

    if (qword_1008D60D0 != -1) {
      dispatch_once(&qword_1008D60D0, &stru_1008965B0);
    }
    sub_1004267B0((uint64_t)off_1008D60C8, (uint64_t)v10, 0xFFFFFFFFLL, 0LL, 701LL, 0LL);
    goto LABEL_41;
  }

void sub_10040067C( _Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, void *__p, uint64_t a10, int a11, __int16 a12, char a13, char a14, int a15, __int16 a16, char a17, char a18, char a19)
{
  if (a14 < 0) {
    operator delete(__p);
  }
  sub_100242CD8(&a18);
  sub_100242FAC((uint64_t)&a19);
  _Unwind_Resume(a1);
}

void sub_1004006DC(uint64_t a1, uint64_t a2, uint64_t a3)
{
  int v20 = 0;
  int v21 = a3;
  uint64_t v5 = sub_1003D0454(a2, &v20);
  uint64_t v6 = sub_100400D7C(v5, &v20, a2);
  int v19 = v6;
  int v7 = sub_100400D7C(v6, &v21, a2);
  int v18 = v7;
  *(void *)std::string buf = 0LL;
  sub_1000B0400((uint64_t)buf);
  *(void *)&__int128 v17 = *(int *)buf;
  *((void *)&v17 + 1) = *(__int16 *)&buf[4];
  if ((_DWORD)a3 && v7)
  {
    int v8 = v20;
    if (v20 != (_DWORD)a3)
    {
      uint64_t v9 = (os_log_s *)qword_1008F7578;
      if (os_log_type_enabled((os_log_t)qword_1008F7578, OS_LOG_TYPE_DEFAULT))
      {
        uint64_t v10 = sub_100401AB4(&v18);
        int v11 = sub_100401AB4(&v19);
        *(_DWORD *)std::string buf = 67109890;
        *(_DWORD *)&uint8_t buf[4] = a3;
        __int16 v23 = 2080;
        uint64_t v24 = v10;
        __int16 v25 = 1024;
        LODWORD(v26[0]) = v8;
        WORD2(v26[0]) = 2080;
        *(void *)((char *)v26 + 6) = v11;
        _os_log_impl( (void *)&_mh_execute_header,  v9,  OS_LOG_TYPE_DEFAULT,  "Attempting to set new class of device: %u, type: %s. Prior cached value is %u, %s",  buf,  0x22u);
      }

      sub_1003D0D8C(a2, v7, &v17);
      sub_1003D51D8(a2, a3, &v17);
      sub_1004015B8(v7, (std::string *)buf);
      sub_1003D0E18(a2, (const std::string *)buf, &v17);
      if (SBYTE3(v26[0]) < 0) {
        operator delete(*(void **)buf);
      }
      sub_1003D3A50(a2, a3);
    }
  }

  else
  {
    uint64_t v12 = (os_log_s *)qword_1008F7578;
    if (os_log_type_enabled((os_log_t)qword_1008F7578, OS_LOG_TYPE_ERROR))
    {
      int v13 = sub_100401AB4(&v18);
      sub_1003CF00C(a2, __p);
      uint64_t v14 = v16 >= 0 ? __p : (void **)__p[0];
      *(_DWORD *)std::string buf = 67109634;
      *(_DWORD *)&uint8_t buf[4] = a3;
      __int16 v23 = 2080;
      uint64_t v24 = v13;
      __int16 v25 = 2082;
      v26[0] = v14;
      _os_log_error_impl( (void *)&_mh_execute_header,  v12,  OS_LOG_TYPE_ERROR,  "Not setting new class of %u, type %s for device %{public}s because it is invalid",  buf,  0x1Cu);
      if (v16 < 0) {
        operator delete(__p[0]);
      }
    }
  }

void sub_100400928( _Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, void *__p, uint64_t a18, int a19, __int16 a20, char a21, char a22)
{
  if (a22 < 0) {
    operator delete(__p);
  }
  _Unwind_Resume(exception_object);
}

uint64_t sub_10040094C(uint64_t a1, uint64_t a2)
{
  uint64_t v30 = 0LL;
  __int128 v29 = 0u;
  memset(v28, 0, sizeof(v28));
  __int128 v26 = 0u;
  __int128 v27 = 0u;
  __int128 v24 = 0u;
  __int128 v25 = 0u;
  __int128 v22 = 0u;
  __int128 v23 = 0u;
  sub_100532DC0((uint64_t)&v22 + 1);
  BYTE2(v23) = 0;
  BYTE4(v23) = 0;
  BYTE2(v25) = 0;
  BYTE4(v25) = 0;
  HIDWORD(v28[2]) = 0;
  __int128 v24 = 0uLL;
  *((void *)&v23 + 1) = 0LL;
  LOBYTE(v25) = 0;
  __int128 v26 = 0uLL;
  *((void *)&v25 + 1) = 0LL;
  LOBYTE(v27) = 0;
  v28[0] = 0LL;
  v28[1] = 0LL;
  *((void *)&v27 + 1) = 0LL;
  *(_DWORD *)((char *)&v28[1] + 7) = 0;
  LOBYTE(v28[3]) = 1;
  BYTE2(v30) = 0;
  *(void *)((char *)&v28[3] + 6) = 0LL;
  *(void *)((char *)&v28[3] + 1) = 0LL;
  __int128 v29 = 0uLL;
  v28[5] = 0LL;
  LOBYTE(v30) = 0;
  BOOL v3 = sub_1003D2408(a2, (uint64_t)&v22);
  if (BYTE7(v29)) {
    BOOL v4 = v3;
  }
  else {
    BOOL v4 = 0;
  }
  if (!v4)
  {
    sub_1003D01A0(a2, (uint64_t)buf);
    uint64_t v7 = BYTE1(v21);
    if ((v21 & 0x8000) != 0) {
      uint64_t v7 = v18;
    }
    if (v7)
    {
      sub_1003D01A0(a2, (uint64_t)&v16);
      if (!std::string::compare(&v16, 0LL, 0xBuLL, "FLEXSMART X"))
      {
        BOOL v8 = 1;
      }

      else
      {
        sub_1003D01A0(a2, (uint64_t)&v15);
        if (!std::string::compare(&v15, "Car Kit"))
        {
          BOOL v8 = 1;
        }

        else
        {
          sub_1003D01A0(a2, (uint64_t)&v14);
          if (!std::string::compare(&v14, 0LL, 5uLL, "BTC45"))
          {
            BOOL v8 = 1;
          }

          else
          {
            sub_1003D01A0(a2, (uint64_t)&v13);
            BOOL v8 = std::string::compare(&v13, "Land Rover") == 0;
          }
        }
      }

      if ((v21 & 0x8000) == 0)
      {
LABEL_28:
        if (v8) {
          goto LABEL_29;
        }
        goto LABEL_17;
      }
    }

    else
    {
      BOOL v8 = 0;
      if ((v21 & 0x8000) == 0) {
        goto LABEL_28;
      }
    }

    operator delete(*(void **)buf);
    if (v8)
    {
LABEL_29:
      uint64_t v10 = (os_log_s *)qword_1008F7578;
      if (os_log_type_enabled((os_log_t)qword_1008F7578, OS_LOG_TYPE_DEFAULT))
      {
        sub_1003D01A0(a2, (uint64_t)buf);
        int v11 = (v21 & 0x8000) == 0 ? buf : *(uint8_t **)buf;
        LODWORD(v16.__r_.__value_.__l.__data_) = 136315138;
        *(std::string::size_type *)((char *)v16.__r_.__value_.__r.__words + 4) = (std::string::size_type)v11;
        _os_log_impl( (void *)&_mh_execute_header,  v10,  OS_LOG_TYPE_DEFAULT,  "Car Stereo Type override due to name match (%s)",  (uint8_t *)&v16,  0xCu);
        if (SBYTE1(v21) < 0) {
          operator delete(*(void **)buf);
        }
      }

      goto LABEL_35;
    }

void sub_100400CEC( _Unwind_Exception *a1, uint64_t a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, void *__p, uint64_t a14, int a15, __int16 a16, char a17, char a18, void *a19, uint64_t a20, int a21, __int16 a22, char a23, char a24, void *a25, uint64_t a26, int a27, __int16 a28, char a29, char a30, uint64_t a31, void *a32, uint64_t a33, int a34, __int16 a35, char a36, char a37, uint64_t a38, char a39)
{
  if (a18 < 0) {
    operator delete(__p);
  }
  if (a24 < 0) {
    operator delete(a19);
  }
  if (a30 < 0) {
    operator delete(a25);
  }
  if (a37 < 0) {
    operator delete(a32);
  }
  sub_1002071FC((uint64_t)&a39, a2);
  _Unwind_Resume(a1);
}

uint64_t sub_100400D7C(uint64_t a1, int *a2, uint64_t a3)
{
  int v3 = *a2;
  uint64_t result = sub_10040094C(a1, a3);
  if (!(_DWORD)result)
  {
    int v5 = v3 & 0xFC;
    uint64_t result = 15LL;
    switch(((v3 & 0x1F00u) - 256) >> 8)
    {
      case 0u:
        unsigned int v6 = v5 - 4;
        if (v6 < 0x18)
        {
          uint64_t v7 = (char *)&unk_1006C29B0;
          goto LABEL_17;
        }

        uint64_t result = 1LL;
        break;
      case 1u:
        unsigned int v6 = v5 - 4;
        if (v6 < 0x14)
        {
          uint64_t v7 = (char *)&unk_1006C29C8;
          goto LABEL_17;
        }

        uint64_t result = 2LL;
        break;
      case 2u:
        return result;
      case 3u:
        unsigned int v6 = v5 - 4;
        if (v6 < 0x48)
        {
          uint64_t v7 = (char *)&unk_1006C29DC;
          goto LABEL_17;
        }

        uint64_t result = 3LL;
        break;
      case 4u:
        uint64_t v8 = sub_1002E6BF0();
        else {
          BOOL v9 = 1;
        }
        if (v9)
        {
          if ((v3 & 0x40) != 0)
          {
            uint64_t result = 24LL;
          }

          else
          {
            unsigned int v6 = (v3 & 0x3C) - 4;
            if (v6 >= 0x18)
            {
              if ((v3 & 0x80) != 0) {
                uint64_t result = 25LL;
              }
              else {
                uint64_t result = 4LL;
              }
            }

            else
            {
              uint64_t v7 = (char *)&unk_1006C2A24;
LABEL_17:
              uint64_t result = *(unsigned int *)&v7[v6];
            }
          }
        }

        else
        {
          uint64_t result = 49LL;
        }

        break;
      case 5u:
        if ((v3 & 0x10) != 0) {
          int v10 = 35;
        }
        else {
          int v10 = 5;
        }
        if ((v3 & 0x20) != 0) {
          int v11 = 33;
        }
        else {
          int v11 = v10;
        }
        if ((v3 & 0x40) != 0) {
          unsigned int v12 = 32;
        }
        else {
          unsigned int v12 = v11;
        }
        if ((v3 & 0x80) != 0) {
          uint64_t result = 31LL;
        }
        else {
          uint64_t result = v12;
        }
        break;
      case 6u:
        unsigned int v13 = v5 - 4;
        if (v13 >= 0x14) {
          goto LABEL_32;
        }
        uint64_t result = (v13 >> 2) + 42;
        break;
      case 7u:
        int v14 = v5 - 4;
        if (v14 == 16) {
          unsigned int v15 = 40;
        }
        else {
          unsigned int v15 = 6;
        }
        if (v14 == 12) {
          uint64_t result = 41LL;
        }
        else {
          uint64_t result = v15;
        }
        break;
      default:
LABEL_32:
        uint64_t result = 0LL;
        break;
    }
  }

  return result;
}

uint64_t sub_100400F20(uint64_t a1, uint64_t a2, _DWORD *a3)
{
  *a3 = 0;
  if (qword_1008D6788 != -1) {
    dispatch_once(&qword_1008D6788, &stru_100896550);
  }
  if (qword_1008D5F50 != -1) {
    dispatch_once(&qword_1008D5F50, &stru_1008965D0);
  }
  unsigned __int8 v5 = atomic_load((unsigned __int8 *)off_1008D5F48 + 232);
  if ((v5 & 1) != 0)
  {
    uint64_t v7 = sub_1002E6BF0();
    if ((*(unsigned int (**)(uint64_t))(*(void *)v7 + 800LL))(v7) == 1)
    {
      if (qword_1008D60B0 != -1) {
        dispatch_once(&qword_1008D60B0, &stru_100896570);
      }
      int v8 = sub_10042BC7C((uint64_t)off_1008D60A8);
    }

    else
    {
      int v8 = sub_1003DF9F4(a2);
    }

    int v9 = v8;
    uint64_t result = 0LL;
    *a3 = v9;
  }

  else
  {
    if (os_log_type_enabled((os_log_t)qword_1008F7578, OS_LOG_TYPE_ERROR)) {
      sub_10067B820();
    }
    return 1LL;
  }

  return result;
}

uint64_t sub_100401058(uint64_t a1)
{
  unsigned __int8 v1 = atomic_load((unsigned __int8 *)(a1 + 232));
  return v1 & 1;
}

uint64_t sub_100401068(uint64_t a1, uint64_t a2, uint64_t a3)
{
  if (qword_1008D6788 != -1) {
    dispatch_once(&qword_1008D6788, &stru_100896550);
  }
  if (qword_1008D5F50 != -1) {
    dispatch_once(&qword_1008D5F50, &stru_1008965D0);
  }
  unsigned __int8 v5 = atomic_load((unsigned __int8 *)off_1008D5F48 + 232);
  if ((v5 & 1) != 0)
  {
    uint64_t v7 = sub_1002E6BF0();
    if ((*(unsigned int (**)(uint64_t))(*(void *)v7 + 800LL))(v7) == 1)
    {
      if (qword_1008D60B0 != -1) {
        dispatch_once(&qword_1008D60B0, &stru_100896570);
      }
      sub_100434A10((uint64_t)off_1008D60A8, a3);
    }

    else
    {
      sub_1003DDB14(a2, a3);
    }

    return 0LL;
  }

  else
  {
    if (os_log_type_enabled((os_log_t)qword_1008F7578, OS_LOG_TYPE_ERROR)) {
      sub_10067B84C();
    }
    return 1LL;
  }

uint64_t sub_10040119C(uint64_t a1, uint64_t a2, void *a3, uint64_t a4, uint64_t a5)
{
  id v8 = a3;
  int v22 = 0;
  unsigned __int8 v21 = 1;
  if (v8)
  {
    if (qword_1008D60F0 != -1) {
      dispatch_once(&qword_1008D60F0, &stru_1008965F0);
    }
    sub_1004B3544((uint64_t)off_1008D60E8, v8, &v21, &v22);
    int v9 = (os_log_s *)qword_1008F7578;
    if (os_log_type_enabled((os_log_t)qword_1008F7578, OS_LOG_TYPE_DEFAULT))
    {
      *(_DWORD *)std::string buf = 138412802;
      id v24 = v8;
      __int16 v25 = 1024;
      int v26 = a4;
      __int16 v27 = 1024;
      int v28 = a5;
      _os_log_impl( (void *)&_mh_execute_header,  v9,  OS_LOG_TYPE_DEFAULT,  "DeviceManager Set Spatial Mode: bundleID: %@, mode: %u head Tracking %d",  buf,  0x18u);
    }

    if (qword_1008D60F0 != -1) {
      dispatch_once(&qword_1008D60F0, &stru_1008965F0);
    }
    sub_1004B3264((uint64_t)off_1008D60E8, v8, a4, a5);
    *(_DWORD *)std::string buf = 0;
    uint64_t v20 = 0LL;
    int v19 = 0;
    sub_1003D55EC(a2, buf, (_DWORD *)&v20 + 1, &v20, &v19);
    if (qword_1008D60F0 != -1) {
      dispatch_once(&qword_1008D60F0, &stru_1008965F0);
    }
    int v10 = (dispatch_queue_s *)*((void *)off_1008D60E8 + 30);
    v12[0] = _NSConcreteStackBlock;
    v12[1] = 3221225472LL;
    void v12[2] = sub_1004013D8;
    v12[3] = &unk_100896490;
    id v13 = v8;
    int v14 = v22;
    int v15 = a4;
    unsigned __int8 v17 = v21;
    char v18 = a5;
    int v16 = v20;
    dispatch_async(v10, v12);
  }

  return 0LL;
}

void sub_1004013BC(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_1004013D8(uint64_t a1)
{
  if (qword_1008D60F0 != -1) {
    dispatch_once(&qword_1008D60F0, &stru_1008965F0);
  }
  sub_1004B2C2C( (uint64_t)off_1008D60E8,  *(void **)(a1 + 32),  *(_DWORD *)(a1 + 40),  *(_DWORD *)(a1 + 44),  *(unsigned __int8 *)(a1 + 52),  *(unsigned __int8 *)(a1 + 53),  *(_DWORD *)(a1 + 48));
}

uint64_t sub_100401438(uint64_t a1, uint64_t a2, void *a3, int *a4, _BYTE *a5)
{
  id v7 = a3;
  if (v7)
  {
    unsigned __int8 v16 = 1;
    unsigned __int8 v15 = 1;
    uint64_t v8 = sub_1002E8D54();
    (*(void (**)(uint64_t, unsigned __int8 *))(*(void *)v8 + 240LL))(v8, &v15);
    if (qword_1008D60F0 != -1) {
      dispatch_once(&qword_1008D60F0, &stru_1008965F0);
    }
    sub_1004B3544((uint64_t)off_1008D60E8, v7, &v16, a4);
    int v9 = v16;
    int v10 = v15;
    if (v15) {
      int v11 = v16;
    }
    else {
      int v11 = 0;
    }
    *a5 = v11;
    unsigned int v12 = (os_log_s *)qword_1008F7578;
    if (os_log_type_enabled((os_log_t)qword_1008F7578, OS_LOG_TYPE_DEBUG))
    {
      int v14 = *a4;
      *(_DWORD *)std::string buf = 138413314;
      id v18 = v7;
      __int16 v19 = 1024;
      int v20 = v14;
      __int16 v21 = 1024;
      int v22 = v9;
      __int16 v23 = 1024;
      int v24 = v10;
      __int16 v25 = 1024;
      int v26 = v11;
      _os_log_debug_impl( (void *)&_mh_execute_header,  v12,  OS_LOG_TYPE_DEBUG,  "DeviceManager Get Spatial Mode: bundleID: %@, mode: %u, headtracking: %u Accessibility Head tracking %d, returning: %u",  buf,  0x24u);
    }
  }

  return 0LL;
}

void sub_1004015A0(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

std::string *sub_1004015B8@<X0>(int a1@<W1>, std::string *a2@<X8>)
{
  a2->__r_.__value_.__r.__words[0] = 0LL;
  a2->__r_.__value_.__l.__size_ = 0LL;
  a2->__r_.__value_.__l.__cap_ = 0LL;
  sub_10002418C(a2, "Misc");
  BOOL v4 = "Laptop";
  switch(a1)
  {
    case 1:
    case 7:
      BOOL v4 = "Computer";
      break;
    case 2:
      BOOL v4 = "Phone";
      break;
    case 3:
      BOOL v4 = "Audio";
      break;
    case 4:
      BOOL v4 = "Peripheral";
      break;
    case 5:
      BOOL v4 = "Imaging";
      break;
    case 6:
      BOOL v4 = "Toy";
      break;
    case 8:
      return std::string::assign(a2, v4);
    case 9:
    case 10:
    case 14:
    case 15:
    case 18:
    case 21:
    case 22:
    case 23:
      goto LABEL_5;
    case 11:
      BOOL v4 = "PDA";
      break;
    case 12:
      BOOL v4 = "Mobile Phone";
      break;
    case 13:
      BOOL v4 = "Cordless Phone";
      break;
    case 16:
      BOOL v4 = "Headset";
      break;
    case 17:
      BOOL v4 = "Handsfree";
      break;
    case 19:
      BOOL v4 = "Speaker";
      break;
    case 20:
      BOOL v4 = "Headphones";
      break;
    case 24:
      BOOL v4 = "Keyboard";
      break;
    case 25:
      BOOL v4 = "Mouse";
      break;
    default:
      if (a1 == 49) {
        BOOL v4 = "Trackpad";
      }
      else {
LABEL_5:
      }
        BOOL v4 = "Misc";
      break;
  }

  return std::string::assign(a2, v4);
}

void sub_1004016F4(_Unwind_Exception *exception_object)
{
}

BOOL sub_100401710(uint64_t a1)
{
  uint64_t v2 = sub_1002E6BF0();
  v16[0] = 0LL;
  v16[1] = 0LL;
  sub_100242F28((uint64_t)v16, a1 + 168);
  __int128 __p = 0LL;
  int v14 = 0LL;
  uint64_t v15 = 0LL;
  sub_100240540(&__p, a1 + 144);
  sub_100242F54((uint64_t)v16);
  int v3 = (unsigned __int8 **)__p;
  BOOL v4 = v14;
  while (1)
  {
    if (v3 == v4)
    {
      int v7 = 0;
      goto LABEL_10;
    }

    unsigned __int8 v5 = *v3;
    if (sub_1003CF350(*v3))
    {
    }

    ++v3;
  }

  int v7 = 1;
LABEL_10:
  v12[0] = 0LL;
  v12[1] = 0LL;
  sub_100242F28((uint64_t)v12, a1 + 168);
  uint64_t v8 = (os_log_s *)qword_1008F7578;
  if (os_log_type_enabled((os_log_t)qword_1008F7578, OS_LOG_TYPE_DEFAULT))
  {
    int v9 = *(unsigned __int8 *)(a1 + 136);
    *(_DWORD *)std::string buf = 67109376;
    int v18 = v9;
    __int16 v19 = 1024;
    int v20 = v7;
    _os_log_impl( (void *)&_mh_execute_header,  v8,  OS_LOG_TYPE_DEFAULT,  "DeviceManager:: compute Classic incompatible device: curr %u, new %u",  buf,  0xEu);
  }

  int v10 = *(unsigned __int8 *)(a1 + 136);
  BOOL v6 = v10 != v7;
  if (v10 != v7) {
    *(_BYTE *)(a1 + 136) = v7;
  }
  sub_100242FAC((uint64_t)v12);
  if (__p)
  {
    int v14 = (unsigned __int8 **)__p;
    operator delete(__p);
  }

  sub_100242FAC((uint64_t)v16);
  return v6;
}

void sub_1004018A0( _Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, void *__p, uint64_t a13, uint64_t a14, char a15)
{
  if (__p) {
    operator delete(__p);
  }
  sub_100242FAC((uint64_t)&a15);
  _Unwind_Resume(a1);
}

void sub_1004018DC(os_unfair_lock_s *a1, void *a2)
{
  int v3 = a2;
  os_unfair_lock_lock(a1);
  unsigned __int8 v5 = 0LL;
  BOOL v6 = 0LL;
  uint64_t v7 = 0LL;
  sub_100240540(&v5, (uint64_t)&a1[2]);
  os_unfair_lock_unlock(a1);
  BOOL v4 = v5;
  if (v5 != v6)
  {
    do
      v3[2](v3, *v4++);
    while (v4 != v6);
    BOOL v4 = v5;
  }

  if (v4)
  {
    BOOL v6 = v4;
    operator delete(v4);
  }
}

void sub_100401970( _Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void *__p, uint64_t a11)
{
  _Unwind_Resume(a1);
}

uint64_t sub_100401998(uint64_t a1, uint64_t (***a2)(void, void, void))
{
  return (**a2)(a2, *(void *)(a1 + 32), *(unsigned int *)(a1 + 40));
}

BOOL sub_1004019B4(uint64_t a1)
{
  uint64_t v2 = sub_1002E6BF0();
  v6[0] = 0LL;
  v6[1] = 0LL;
  sub_100242F28((uint64_t)v6, a1 + 168);
  int v3 = (os_log_s *)qword_1008F7578;
  if (os_log_type_enabled((os_log_t)qword_1008F7578, OS_LOG_TYPE_DEBUG)) {
    sub_10067B878(a1, v3);
  }
  BOOL v4 = *(_BYTE *)(a1 + 136) != 0;
  sub_100242FAC((uint64_t)v6);
  return v4;
}

uint64_t sub_100401A48(uint64_t a1, uint64_t a2, uint64_t a3, int a4, char a5, char a6, int a7)
{
  return 0LL;
}

const char *sub_100401AB4(int *a1)
{
  uint64_t v1 = *a1;
  else {
    return off_100896650[v1];
  }
}

void sub_100401ADC(uint64_t a1, uint64_t a2)
{
}

uint64_t sub_100401AE4(uint64_t result, int a2, int a3)
{
  if (a2 == 1)
  {
    uint64_t v4 = result;
    v11[0] = 0LL;
    v11[1] = 0LL;
    sub_100242F28((uint64_t)v11, result + 168);
    uint64_t v8 = 0LL;
    int v9 = 0LL;
    uint64_t v10 = 0LL;
    sub_100240540(&v8, v4 + 144);
    sub_100242F54((uint64_t)v11);
    unsigned __int8 v5 = v8;
    BOOL v6 = v9;
    if (v8 != v9)
    {
      do
      {
        uint64_t v7 = (unsigned __int8 *)*v5;
        if (v7[960]) {
          sub_100401BF4(v4, a3, v7);
        }
        ++v5;
      }

      while (v5 != v6);
      unsigned __int8 v5 = v8;
    }

    if (v5)
    {
      int v9 = v5;
      operator delete(v5);
    }

    return sub_100242FAC((uint64_t)v11);
  }

  return result;
}

void sub_100401BC4( _Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void *__p, uint64_t a11, uint64_t a12, char a13)
{
  if (__p) {
    operator delete(__p);
  }
  sub_100242FAC((uint64_t)&a13);
  _Unwind_Resume(a1);
}

void sub_100401BF4(uint64_t a1, int a2, unsigned __int8 *a3)
{
  uint64_t v30 = a3;
  int v29 = 0;
  sub_1000B0740(&v29, 0LL);
  uint64_t v6 = v29;
  int v7 = sub_1003DEFE8((uint64_t)a3);
  if (a2 == 1)
  {
    int v8 = v7;
    uint64_t v9 = a1 + 272;
    uint64_t v10 = a1 + 280;
    int v11 = *(void **)(a1 + 280);
    if (!v11) {
      goto LABEL_16;
    }
    uint64_t v12 = a1 + 280;
    do
    {
      unint64_t v13 = v11[4];
      BOOL v14 = v13 >= (unint64_t)a3;
      else {
        uint64_t v15 = v11 + 1;
      }
      if (v14) {
        uint64_t v12 = (uint64_t)v11;
      }
      int v11 = (void *)*v15;
    }

    while (*v15);
    if (v12 == v10 || *(void *)(v12 + 32) > (unint64_t)a3)
    {
LABEL_16:
      buf.__r_.__value_.__r.__words[0] = (std::string::size_type)&v30;
      *((_BYTE *)sub_100404694((uint64_t **)(a1 + 272), (unint64_t *)&v30, (uint64_t)&unk_1006C2518, &buf) + 40) = 0;
      unsigned __int8 v16 = (os_log_s *)qword_1008F7578;
      if (os_log_type_enabled((os_log_t)qword_1008F7578, OS_LOG_TYPE_DEFAULT))
      {
        LOWORD(buf.__r_.__value_.__l.__data_) = 0;
        _os_log_impl( (void *)&_mh_execute_header,  v16,  OS_LOG_TYPE_DEFAULT,  "Wireless Splitter repopulating fGuestDevices after boot up",  (uint8_t *)&buf,  2u);
      }
    }

    unint64_t v17 = v6 - v8;
    int v18 = *(_DWORD *)(a1 + 296);
    if (v18) {
      unint64_t v19 = v18 / 1000;
    }
    else {
      unint64_t v19 = 480LL;
    }
    uint64_t v20 = v19 - v17;
    if (v19 >= v17)
    {
      if (!sub_1003D0670((uint64_t)v30) && *(void *)v9 != v10)
      {
        uint64_t v23 = *(void *)(*(void *)v9 + 32LL);
        int v24 = (os_log_s *)qword_1008F7578;
        if (v23)
        {
          if (os_log_type_enabled((os_log_t)qword_1008F7578, OS_LOG_TYPE_DEFAULT))
          {
            sub_1003CF00C(v23, &buf);
            if ((buf.__r_.__value_.__s.__size_ & 0x80u) == 0) {
              p_std::string buf = &buf;
            }
            else {
              p_std::string buf = (std::string *)buf.__r_.__value_.__r.__words[0];
            }
            uint64_t v26 = 1000 * v20;
            *(_DWORD *)int v31 = 136446466;
            uint64_t v32 = p_buf;
            __int16 v33 = 2048;
            uint64_t v34 = 1000 * v20;
            _os_log_impl( (void *)&_mh_execute_header,  v24,  OS_LOG_TYPE_DEFAULT,  "Wireless Splitter starting linkkey timeout for guest device %{public}s with timeout %llums",  v31,  0x16u);
          }

          else
          {
            uint64_t v26 = 1000 * v20;
          }

          buf.__r_.__value_.__r.__words[0] = (std::string::size_type)&v30;
          *((_BYTE *)sub_100404694((uint64_t **)(a1 + 272), (unint64_t *)&v30, (uint64_t)&unk_1006C2518, &buf) + 40) = 1;
          sub_100403180(a1, 1, v26);
        }

        else if (os_log_type_enabled((os_log_t)qword_1008F7578, OS_LOG_TYPE_ERROR))
        {
          sub_10067B8EC();
        }
      }
    }

    else
    {
      __int16 v21 = (os_log_s *)qword_1008F7578;
      if (os_log_type_enabled((os_log_t)qword_1008F7578, OS_LOG_TYPE_DEFAULT))
      {
        LOWORD(buf.__r_.__value_.__l.__data_) = 0;
        _os_log_impl( (void *)&_mh_execute_header,  v21,  OS_LOG_TYPE_DEFAULT,  "Wireless Splitter bt powered on, guest device needs to be deleted",  (uint8_t *)&buf,  2u);
      }

      memset(&buf, 0, sizeof(buf));
      int v22 = sub_10002418C(&buf, "WS_ERROR_DISCONNECTION_GUEST_NEEDS_DELETION");
      else {
        std::string __p = buf;
      }
      sub_1003FFAD8((uint64_t)v22, &__p);
      if (qword_1008D67A8 != -1) {
        dispatch_once(&qword_1008D67A8, &stru_100896630);
      }
      sub_10052F37C((uint64_t)off_1008D67A0, v30);
      sub_10020166C(v9, (unint64_t *)&v30);
    }
  }

  else if (!a2 && sub_1003D0670((uint64_t)a3))
  {
    sub_1003DF02C((uint64_t)v30, &v29);
  }

void sub_100401F98( _Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, void *__p, uint64_t a10, int a11, __int16 a12, char a13, char a14, uint64_t a15, void *a16, uint64_t a17, int a18, __int16 a19, char a20, char a21)
{
  if (a14 < 0) {
    operator delete(__p);
  }
  if (a21 < 0) {
    operator delete(a16);
  }
  _Unwind_Resume(exception_object);
}

uint64_t sub_100401FD4(uint64_t a1, int a2, int a3)
{
  return sub_100401AE4(a1 - 32, a2, a3);
}

uint64_t sub_100401FDC(uint64_t a1)
{
  v10[0] = 0LL;
  v10[1] = 0LL;
  sub_100242F28((uint64_t)v10, a1 + 168);
  std::string __p = 0LL;
  int v8 = 0LL;
  uint64_t v9 = 0LL;
  sub_100240540(&__p, a1 + 144);
  sub_100242F54((uint64_t)v10);
  uint64_t v2 = (unsigned __int8 **)__p;
  int v3 = v8;
  if (__p == v8)
  {
    uint64_t v4 = 0LL;
    if (!__p) {
      goto LABEL_9;
    }
    goto LABEL_8;
  }

  uint64_t v4 = 0LL;
  do
  {
    unsigned __int8 v5 = *v2;
    ++v2;
  }

  while (v2 != v3);
  uint64_t v2 = (unsigned __int8 **)__p;
  if (__p)
  {
LABEL_8:
    int v8 = v2;
    operator delete(v2);
  }

void sub_1004020A4( _Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void *__p, uint64_t a11, uint64_t a12, char a13)
{
  if (__p) {
    operator delete(__p);
  }
  sub_100242FAC((uint64_t)&a13);
  _Unwind_Resume(a1);
}

uint64_t sub_1004020D4(uint64_t a1)
{
  v9[0] = 0LL;
  v9[1] = 0LL;
  sub_100242F28((uint64_t)v9, a1 + 168);
  uint64_t v6 = 0LL;
  int v7 = 0LL;
  uint64_t v8 = 0LL;
  sub_100240540(&v6, a1 + 144);
  sub_100242F54((uint64_t)v9);
  if (v6 == v7)
  {
    uint64_t v2 = 0LL;
    if (!v6) {
      goto LABEL_6;
    }
    goto LABEL_5;
  }

  LODWORD(v2) = 0;
  int v3 = v6;
  do
  {
    uint64_t v4 = *v3++;
    uint64_t v2 = v2 + *(unsigned __int8 *)(v4 + 1122);
  }

  while (v3 != v7);
  if (v6)
  {
LABEL_5:
    int v7 = v6;
    operator delete(v6);
  }

void sub_100402170( _Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void *__p, uint64_t a11, uint64_t a12, char a13)
{
  if (__p) {
    operator delete(__p);
  }
  sub_100242FAC((uint64_t)&a13);
  _Unwind_Resume(a1);
}

uint64_t sub_10040219C(uint64_t a1)
{
  v9[0] = 0LL;
  v9[1] = 0LL;
  sub_100242F28((uint64_t)v9, a1 + 168);
  uint64_t v6 = 0LL;
  int v7 = 0LL;
  uint64_t v8 = 0LL;
  sub_100240540(&v6, a1 + 144);
  sub_100242F54((uint64_t)v9);
  if (v6 == v7)
  {
    unsigned __int8 v2 = 0;
    if (!v6) {
      goto LABEL_6;
    }
    goto LABEL_5;
  }

  unsigned __int8 v2 = 0;
  int v3 = v6;
  do
  {
    uint64_t v4 = *v3++;
    v2 += *(_BYTE *)(v4 + 1332);
  }

  while (v3 != v7);
  if (v6)
  {
LABEL_5:
    int v7 = v6;
    operator delete(v6);
  }

void sub_100402238( _Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void *__p, uint64_t a11, uint64_t a12, char a13)
{
  if (__p) {
    operator delete(__p);
  }
  sub_100242FAC((uint64_t)&a13);
  _Unwind_Resume(a1);
}

uint64_t sub_100402264(uint64_t a1)
{
  v10[0] = 0LL;
  v10[1] = 0LL;
  sub_100242F28((uint64_t)v10, a1 + 168);
  std::string __p = 0LL;
  uint64_t v8 = 0LL;
  uint64_t v9 = 0LL;
  sub_100240540(&__p, a1 + 144);
  sub_100242F54((uint64_t)v10);
  unsigned __int8 v2 = (unsigned __int8 **)__p;
  int v3 = v8;
  if (__p == v8)
  {
    uint64_t v4 = 0LL;
    if (!__p) {
      goto LABEL_10;
    }
    goto LABEL_9;
  }

  uint64_t v4 = 0LL;
  do
  {
    unsigned __int8 v5 = *v2;
    ++v2;
  }

  while (v2 != v3);
  unsigned __int8 v2 = (unsigned __int8 **)__p;
  if (__p)
  {
LABEL_9:
    uint64_t v8 = v2;
    operator delete(v2);
  }

void sub_100402338( _Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void *__p, uint64_t a11, uint64_t a12, char a13)
{
  if (__p) {
    operator delete(__p);
  }
  sub_100242FAC((uint64_t)&a13);
  _Unwind_Resume(a1);
}

uint64_t sub_100402368(uint64_t a1)
{
  v10[0] = 0LL;
  v10[1] = 0LL;
  sub_100242F28((uint64_t)v10, a1 + 168);
  std::string __p = 0LL;
  uint64_t v8 = 0LL;
  uint64_t v9 = 0LL;
  sub_100240540(&__p, a1 + 144);
  sub_100242F54((uint64_t)v10);
  unsigned __int8 v2 = (unsigned __int8 **)__p;
  int v3 = v8;
  if (__p == v8)
  {
    uint64_t v4 = 0LL;
    if (!__p) {
      goto LABEL_12;
    }
    goto LABEL_11;
  }

  uint64_t v4 = 0LL;
  do
  {
    unsigned __int8 v5 = *v2;
    if (sub_1003CF350(*v2)
      && sub_1003D0670((uint64_t)v5)
      && sub_1003D55CC((uint64_t)v5)
      && ((sub_1003D56A4((uint64_t)v5) & 1) != 0 || sub_1003D56B0((uint64_t)v5)))
    {
      uint64_t v4 = (v4 + 1);
    }

    ++v2;
  }

  while (v2 != v3);
  unsigned __int8 v2 = (unsigned __int8 **)__p;
  if (__p)
  {
LABEL_11:
    uint64_t v8 = v2;
    operator delete(v2);
  }

void sub_10040244C( _Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void *__p, uint64_t a11, uint64_t a12, char a13)
{
  if (__p) {
    operator delete(__p);
  }
  sub_100242FAC((uint64_t)&a13);
  _Unwind_Resume(a1);
}

uint64_t sub_10040247C@<X0>(uint64_t a1@<X0>, int a2@<W1>, void **a3@<X8>)
{
  v34[0] = 0LL;
  v34[1] = 0LL;
  sub_100242F28((uint64_t)v34, a1 + 168);
  int v31 = 0LL;
  uint64_t v32 = 0LL;
  uint64_t v33 = 0LL;
  sub_100240540(&v31, a1 + 144);
  sub_100242F54((uint64_t)v34);
  *a3 = 0LL;
  a3[1] = 0LL;
  a3[2] = 0LL;
  uint64_t v6 = v31;
  int v7 = v32;
  if (v31 != v32)
  {
    do
    {
      uint64_t v8 = *v6;
      uint64_t v29 = 0LL;
      uint64_t v30 = 0LL;
      BOOL v9 = sub_1003D55EC(v8, (_DWORD *)&v30 + 1, &v30, (_DWORD *)&v29 + 1, &v29);
      BOOL v10 = (_DWORD)v30 == 76 && v9;
      if (v10 && HIDWORD(v29) == a2)
      {
        uint64_t v12 = (os_log_s *)qword_1008F7578;
        if (os_log_type_enabled((os_log_t)qword_1008F7578, OS_LOG_TYPE_DEBUG))
        {
          sub_1003CF00C(v8, __p);
          __int16 v25 = __p;
          if (v28 < 0) {
            __int16 v25 = (void **)__p[0];
          }
          *(_DWORD *)std::string buf = 136446210;
          unsigned __int8 v36 = v25;
          _os_log_debug_impl( (void *)&_mh_execute_header,  v12,  OS_LOG_TYPE_DEBUG,  "getDevicesForAppleProductID for CaseSerial adding %{public}s",  buf,  0xCu);
          if (v28 < 0) {
            operator delete(__p[0]);
          }
        }

        BOOL v14 = (uint64_t *)a3[1];
        unint64_t v13 = (unint64_t)a3[2];
        if ((unint64_t)v14 >= v13)
        {
          uint64_t v16 = ((char *)v14 - (_BYTE *)*a3) >> 3;
          uint64_t v17 = v13 - (void)*a3;
          uint64_t v18 = v17 >> 2;
          else {
            unint64_t v19 = v18;
          }
          if (v19) {
            uint64_t v20 = (char *)sub_100008BA0((uint64_t)(a3 + 2), v19);
          }
          else {
            uint64_t v20 = 0LL;
          }
          __int16 v21 = (uint64_t *)&v20[8 * v16];
          *__int16 v21 = v8;
          uint64_t v15 = v21 + 1;
          uint64_t v23 = (char *)*a3;
          int v22 = (char *)a3[1];
          if (v22 != *a3)
          {
            do
            {
              uint64_t v24 = *((void *)v22 - 1);
              v22 -= 8;
              *--__int16 v21 = v24;
            }

            while (v22 != v23);
            int v22 = (char *)*a3;
          }

          *a3 = v21;
          a3[1] = v15;
          a3[2] = &v20[8 * v19];
          if (v22) {
            operator delete(v22);
          }
        }

        else
        {
          *BOOL v14 = v8;
          uint64_t v15 = v14 + 1;
        }

        a3[1] = v15;
      }

      ++v6;
    }

    while (v6 != v7);
    uint64_t v6 = v31;
  }

  if (v6)
  {
    uint64_t v32 = v6;
    operator delete(v6);
  }

  return sub_100242FAC((uint64_t)v34);
}

void sub_1004026D8( _Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, void *__p, uint64_t a17, uint64_t a18, char a19)
{
  if (__p) {
    operator delete(__p);
  }
  sub_100242FAC((uint64_t)&a19);
  _Unwind_Resume(a1);
}

void sub_10040272C(const void **a1@<X1>, void *a2@<X8>)
{
  uint64_t v30 = 0LL;
  v31[0] = 0LL;
  v31[1] = 0LL;
  sub_10002418C(v28, "Bluetooth Mouse M336/M337/M535");
  uint64_t v4 = operator new(0x14uLL);
  uint64_t v26 = v4 + 5;
  __int16 v27 = (char *)(v4 + 5);
  v4[4] = 325704422;
  *(_OWORD *)uint64_t v4 = xmmword_1006C2971;
  __int16 v25 = v4;
  sub_100403BE0(__dst, (__int128 *)v28, (uint64_t)&v25);
  sub_10002418C(v23, "Bluetooth Mouse M557");
  unsigned __int8 v5 = operator new(0x14uLL);
  __int16 v21 = v5 + 5;
  int v22 = (char *)(v5 + 5);
  v5[4] = 601617057;
  *(_OWORD *)unsigned __int8 v5 = xmmword_1006C2985;
  uint64_t v20 = v5;
  sub_100403BE0(v33, (__int128 *)v23, (uint64_t)&v20);
  sub_10002418C(v18, "Microsoft Sculpt Comfort Mouse");
  uint64_t v6 = operator new(0x14uLL);
  uint64_t v16 = v6 + 5;
  uint64_t v17 = (char *)(v6 + 5);
  v6[4] = 2014317364;
  *(_OWORD *)uint64_t v6 = xmmword_1006C2999;
  std::string __p = v6;
  sub_100403BE0(v34, (__int128 *)v18, (uint64_t)&__p);
  sub_1004041B8((uint64_t)&v30, __dst, 3LL);
  for (uint64_t i = 0LL; i != -18; i -= 6LL)
  {
    uint64_t v8 = &__dst[i];
    BOOL v9 = (void *)v34[i + 3];
    if (v9)
    {
      v8[16] = v9;
      operator delete(v9);
    }
  }

  if (__p)
  {
    uint64_t v16 = __p;
    operator delete(__p);
  }

  if (v19 < 0) {
    operator delete(v18[0]);
  }
  if (v20)
  {
    __int16 v21 = v20;
    operator delete(v20);
  }

  if (v24 < 0) {
    operator delete(v23[0]);
  }
  if (v25)
  {
    uint64_t v26 = v25;
    operator delete(v25);
  }

  if (v29 < 0) {
    operator delete(v28[0]);
  }
  uint64_t v10 = sub_100024098((uint64_t)&v30, a1);
  if (v31 == (void **)v10)
  {
    *a2 = 0LL;
    a2[1] = 0LL;
    a2[2] = 0LL;
  }

  else
  {
    *a2 = 0LL;
    a2[1] = 0LL;
    a2[2] = 0LL;
    uint64_t v12 = *(_BYTE **)(v10 + 56);
    int v11 = *(_BYTE **)(v10 + 64);
    size_t v13 = v11 - v12;
    if (v11 != v12)
    {
      sub_10023D39C(a2, v11 - v12);
      BOOL v14 = (char *)a2[1];
      memmove(v14, v12, v13);
      a2[1] = &v14[v13];
    }
  }

  sub_10040447C((uint64_t)&v30, v31[0]);
}

void sub_1004029C0( _Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, void *__p, uint64_t a12, uint64_t a13, void *a14, uint64_t a15, int a16, __int16 a17, char a18, char a19, void *a20, uint64_t a21, uint64_t a22, void *a23, uint64_t a24, int a25, __int16 a26, char a27, char a28, void *a29, uint64_t a30, uint64_t a31, void *a32, uint64_t a33, int a34, __int16 a35, char a36, char a37, char a38, uint64_t a39, uint64_t a40, char a41)
{
  for (uint64_t i = 96LL; i != -48; i -= 48LL)
    sub_100402AEC(v41 + i);
  if (__p) {
    operator delete(__p);
  }
  if (a19 < 0) {
    operator delete(a14);
  }
  if (a20) {
    operator delete(a20);
  }
  if (a28 < 0) {
    operator delete(a23);
  }
  if (a29) {
    operator delete(a29);
  }
  if (a37 < 0) {
    operator delete(a32);
  }
  _Unwind_Resume(a1);
}

uint64_t sub_100402AEC(uint64_t a1)
{
  unsigned __int8 v2 = *(void **)(a1 + 24);
  if (v2)
  {
    *(void *)(a1 + 32) = v2;
    operator delete(v2);
  }

  return a1;
}

BOOL sub_100402B2C(uint64_t a1, uint64_t a2)
{
  int v3 = (char *)operator new(0x14uLL);
  *((_DWORD *)v3 + 4) = 325704422;
  *(_OWORD *)int v3 = xmmword_1006C2971;
  v14[0] = (void **)v3;
  v14[1] = (void **)(v3 + 20);
  void v14[2] = (void **)(v3 + 20);
  uint64_t v4 = (char *)operator new(0x14uLL);
  *((_DWORD *)v4 + 4) = 601617057;
  *(_OWORD *)uint64_t v4 = xmmword_1006C2985;
  v14[3] = (void **)v4;
  v14[4] = (void **)(v4 + 20);
  v14[5] = (void **)(v4 + 20);
  unsigned __int8 v5 = (char *)operator new(0x14uLL);
  v14[7] = (void **)(v5 + 20);
  v14[8] = (void **)(v5 + 20);
  *((_DWORD *)v5 + 4) = 2014317364;
  *(_OWORD *)unsigned __int8 v5 = xmmword_1006C2999;
  v14[6] = (void **)v5;
  uint64_t v10 = operator new(0x48uLL);
  uint64_t v12 = v10 + 9;
  uint64_t v6 = 0LL;
  int v11 = sub_1004044C4((int)&v12, (uint64_t)v14, (uint64_t)&v15, v10);
  do
  {
    int v7 = v14[v6 + 6];
    if (v7)
    {
      v14[v6 + 7] = v7;
      operator delete(v7);
    }

    v6 -= 3LL;
  }

  while (v6 != -9);
  char v13 = 0;
  BOOL v8 = sub_1004045E4((uint64_t)v10, (uint64_t)v11, a2) != (void)v11;
  v14[0] = (void **)&v10;
  sub_100404550(v14);
  return v8;
}

void sub_100402CC0( _Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, void **a13)
{
  a13 = (void **)&a9;
  sub_100404550(&a13);
  _Unwind_Resume(a1);
}

uint64_t sub_100402D50(uint64_t a1)
{
  unsigned __int8 v2 = (os_log_s *)qword_1008F7578;
  if (os_log_type_enabled((os_log_t)qword_1008F7578, OS_LOG_TYPE_DEFAULT))
  {
    LOWORD(v6) = 0;
    _os_log_impl( (void *)&_mh_execute_header,  v2,  OS_LOG_TYPE_DEFAULT,  "statedump: ------------------ Device Manager -------------------",  (uint8_t *)&v6,  2u);
    unsigned __int8 v2 = (os_log_s *)qword_1008F7578;
  }

  if (os_log_type_enabled(v2, OS_LOG_TYPE_DEFAULT))
  {
    LOWORD(v6) = 0;
    _os_log_impl((void *)&_mh_execute_header, v2, OS_LOG_TYPE_DEFAULT, "statedump: Devices:", (uint8_t *)&v6, 2u);
  }

  v9[0] = 0LL;
  v9[1] = 0LL;
  sub_100242F28((uint64_t)v9, a1 + 168);
  uint64_t v6 = 0LL;
  int v7 = 0LL;
  uint64_t v8 = 0LL;
  sub_100240540(&v6, a1 + 144);
  sub_100242F54((uint64_t)v9);
  int v3 = v6;
  uint64_t v4 = v7;
  if (v6 != v7)
  {
    do
      sub_1003E4AC0(*v3++);
    while (v3 != v4);
    int v3 = v6;
  }

  if (v3)
  {
    int v7 = v3;
    operator delete(v3);
  }

  return sub_100242FAC((uint64_t)v9);
}

void sub_100402E64( _Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, void *__p, uint64_t a10, uint64_t a11, uint64_t a12, char a13)
{
  if (__p) {
    operator delete(__p);
  }
  sub_100242FAC((uint64_t)&a13);
  _Unwind_Resume(a1);
}

uint64_t sub_100402E94(uint64_t a1)
{
  v16[0] = 0LL;
  v16[1] = 0LL;
  sub_100242F28((uint64_t)v16, a1 + 168);
  char v13 = 0LL;
  BOOL v14 = 0LL;
  uint64_t v15 = 0LL;
  sub_100240540(&v13, a1 + 144);
  sub_100242F54((uint64_t)v16);
  unsigned __int8 v2 = v13;
  int v3 = v14;
  if (v13 != v14)
  {
    do
    {
      uint64_t v4 = *v2;
      if (sub_1003D0670(*v2))
      {
        if (qword_1008D9030 != -1) {
          dispatch_once(&qword_1008D9030, &stru_100896610);
        }
        uint64_t v5 = sub_10045D7CC((uint64_t)off_1008D9028, v4);
        if (v5) {
          unsigned __int16 v6 = sub_10020755C(v5 + 400);
        }
        else {
          unsigned __int16 v6 = 0;
        }
        uint64_t v12 = 0LL;
        int v11 = 0;
        if (sub_1003D3284(v4))
        {
          LODWORD(__p[0]) = 0;
          sub_1003D55EC(v4, __p, (_DWORD *)&v12 + 1, &v12, &v11);
        }

        sub_1003D01A0(v4, (uint64_t)__p);
        if (v10 >= 0) {
          int v7 = __p;
        }
        else {
          int v7 = (void **)__p[0];
        }
        sub_1000BAB20(v4 + 128, (const char *)v7, v6, WORD2(v12), (unsigned __int16)v12, v11);
        if (v10 < 0) {
          operator delete(__p[0]);
        }
      }

      ++v2;
    }

    while (v2 != v3);
    unsigned __int8 v2 = v13;
  }

  if (v2)
  {
    BOOL v14 = v2;
    operator delete(v2);
  }

  return sub_100242FAC((uint64_t)v16);
}

void sub_10040301C( _Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, void *a9, uint64_t a10, int a11, __int16 a12, char a13, char a14, uint64_t a15, uint64_t a16, void *__p, uint64_t a18, uint64_t a19, char a20)
{
  if (__p) {
    operator delete(__p);
  }
  sub_100242FAC((uint64_t)&a20);
  _Unwind_Resume(a1);
}

uint64_t sub_100403074(uint64_t a1)
{
  uint64_t v1 = *(void *)(a1 + 32);
  unsigned __int8 v2 = (os_log_s *)qword_1008F7578;
  if (os_log_type_enabled((os_log_t)qword_1008F7578, OS_LOG_TYPE_DEFAULT))
  {
    LOWORD(v6[0]) = 0;
    _os_log_impl( (void *)&_mh_execute_header,  v2,  OS_LOG_TYPE_DEFAULT,  "DeviceManager init, first unlock delay expired, allow read/write device settings",  (uint8_t *)v6,  2u);
  }

  v6[0] = 0LL;
  v6[1] = 0LL;
  sub_100242F28((uint64_t)v6, v1 + 168);
  atomic_store(1u, (unsigned __int8 *)(v1 + 232));
  int v3 = *(uint64_t **)(v1 + 144);
  uint64_t v4 = *(uint64_t **)(v1 + 152);
  while (v3 != v4)
    sub_1003CCB84(*v3++);
  sub_100242F54((uint64_t)v6);
  sub_1003FE9E4((os_unfair_lock_s *)v1);
  if (qword_1008D5F00 != -1) {
    dispatch_once(&qword_1008D5F00, &stru_100896590);
  }
  sub_10040A568((uint64_t)off_1008D5EF8);
  return sub_100242FAC((uint64_t)v6);
}

void sub_100403168( _Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9)
{
}

void sub_100403180(uint64_t a1, int a2, uint64_t a3)
{
  if (!a2 || qword_1008F0A18)
  {
    if (a2)
    {
      uint64_t v7 = sub_100404EB8();
      sub_100405460(v7, a3, (void *)qword_1008F0A18);
    }

    else
    {
      if (qword_1008F0A18)
      {
        dispatch_block_cancel((dispatch_block_t)qword_1008F0A18);
        uint64_t v8 = (void *)qword_1008F0A18;
      }

      else
      {
        uint64_t v8 = 0LL;
      }

      qword_1008F0A18 = 0LL;
    }
  }

  else
  {
    block[0] = _NSConcreteStackBlock;
    block[1] = 3221225472LL;
    block[2] = sub_10040335C;
    block[3] = &unk_10087EB20;
    block[4] = a1;
    dispatch_block_t v4 = dispatch_block_create(DISPATCH_BLOCK_ENFORCE_QOS_CLASS, block);
    uint64_t v5 = (void *)qword_1008F0A18;
    qword_1008F0A18 = (uint64_t)v4;

    uint64_t v6 = sub_100404EB8();
    sub_100405460(v6, a3, (void *)qword_1008F0A18);
  }

void *sub_100403258(uint64_t a1, unint64_t *a2)
{
  unsigned __int8 v2 = *(void **)(a1 + 8);
  if (!v2) {
LABEL_8:
  }
    abort();
  unint64_t v3 = *a2;
  while (1)
  {
    while (1)
    {
      unint64_t v4 = v2[4];
      if (v3 >= v4) {
        break;
      }
      unsigned __int8 v2 = (void *)*v2;
      if (!v2) {
        goto LABEL_8;
      }
    }

    if (v4 >= v3) {
      return v2 + 5;
    }
    unsigned __int8 v2 = (void *)v2[1];
    if (!v2) {
      goto LABEL_8;
    }
  }

void sub_1004032A4(uint64_t a1)
{
  *(void *)(a1 + 280) = 0LL;
  *(void *)(a1 + 288) = 0LL;
  *(void *)(a1 + 272) = a1 + 280;
  unsigned __int8 v2 = (os_log_s *)qword_1008F7578;
  if (os_log_type_enabled((os_log_t)qword_1008F7578, OS_LOG_TYPE_DEFAULT))
  {
    int v3 = 134217984;
    uint64_t v4 = 0LL;
    _os_log_impl( (void *)&_mh_execute_header,  v2,  OS_LOG_TYPE_DEFAULT,  "Wireless Splitter cleanUpGuestDevice due to unpairing  fGuestDevicesSize is %lu",  (uint8_t *)&v3,  0xCu);
  }

void sub_10040335C(uint64_t a1)
{
  uint64_t v1 = *(void *)(a1 + 32);
  unsigned __int8 v2 = (os_log_s *)qword_1008F7578;
  if (os_log_type_enabled((os_log_t)qword_1008F7578, OS_LOG_TYPE_DEFAULT))
  {
    std::string::size_type v3 = *(void *)(v1 + 288);
    LODWORD(buf.__r_.__value_.__l.__data_) = 134217984;
    *(std::string::size_type *)((char *)buf.__r_.__value_.__r.__words + 4) = v3;
    _os_log_impl( (void *)&_mh_execute_header,  v2,  OS_LOG_TYPE_DEFAULT,  "Wireless Splitter linkkey timeout check, fGuestDevicesSize is %lu",  (uint8_t *)&buf,  0xCu);
  }

  if (*(void *)(v1 + 288))
  {
    uint64_t v4 = *(void *)(v1 + 272);
    if (*(_BYTE *)(v4 + 40))
    {
      uint64_t v5 = *(unsigned __int8 **)(v4 + 32);
      uint64_t v6 = (os_log_s *)qword_1008F7578;
      if (os_log_type_enabled((os_log_t)qword_1008F7578, OS_LOG_TYPE_DEFAULT))
      {
        sub_1003CF00C((uint64_t)v5, &buf);
        uint64_t v7 = (buf.__r_.__value_.__s.__size_ & 0x80u) == 0 ? &buf : (std::string *)buf.__r_.__value_.__r.__words[0];
        *(_DWORD *)int v11 = 136446210;
        uint64_t v12 = v7;
        _os_log_impl( (void *)&_mh_execute_header,  v6,  OS_LOG_TYPE_DEFAULT,  "Wireless Splitter linkkey timeout reached, guest device %{public}s needs to be deleted",  v11,  0xCu);
      }

      memset(&buf, 0, sizeof(buf));
      uint64_t v8 = sub_10002418C(&buf, "WS_ERROR_DISCONNECTION_LINK_KEY_TIMEOUT_REACHED");
      else {
        std::string __p = buf;
      }
      sub_1003FFAD8((uint64_t)v8, &__p);
      if (qword_1008D67A8 != -1) {
        dispatch_once(&qword_1008D67A8, &stru_100896630);
      }
      sub_10052F37C((uint64_t)off_1008D67A0, v5);
      sub_1004032A4(v1);
    }
  }

void sub_100403540( _Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, void *__p, uint64_t a10, int a11, __int16 a12, char a13, char a14, uint64_t a15, void *a16, uint64_t a17, int a18, __int16 a19, char a20, char a21)
{
  if (a14 < 0) {
    operator delete(__p);
  }
  if (a21 < 0) {
    operator delete(a16);
  }
  _Unwind_Resume(exception_object);
}

void sub_10040357C(uint64_t a1, uint64_t a2, uint64_t a3, char a4)
{
  uint64_t v7 = sub_10040007C((void *)a1, a3, 1);
  if (v7)
  {
    uint64_t v8 = (uint64_t)v7;
    if (qword_1008D60B0 != -1) {
      dispatch_once(&qword_1008D60B0, &stru_100896570);
    }
    int v9 = sub_1004317E0((uint64_t)off_1008D60A8, a2, 10000);
    char v10 = (os_log_s *)qword_1008F7578;
    if (os_log_type_enabled((os_log_t)qword_1008F7578, OS_LOG_TYPE_DEFAULT))
    {
      sub_1003D0100(v8, (uint64_t)__p);
      if (v15 >= 0) {
        int v11 = __p;
      }
      else {
        int v11 = (void **)__p[0];
      }
      *(_DWORD *)std::string buf = 136315394;
      uint64_t v17 = v11;
      __int16 v18 = 1024;
      int v19 = a2;
      _os_log_impl( (void *)&_mh_execute_header,  v10,  OS_LOG_TYPE_DEFAULT,  "ACL connected aclConnectCfm for device %s status %d",  buf,  0x12u);
      if (v15 < 0) {
        operator delete(__p[0]);
      }
    }

    sub_1003D9A14(v8, v9, a4);
    v12[0] = _NSConcreteStackBlock;
    v12[1] = 3221225472LL;
    void v12[2] = sub_10040371C;
    v12[3] = &unk_1008964B0;
    void v12[4] = v8;
    int v13 = v9;
    sub_1004018DC((os_unfair_lock_s *)(a1 + 240), v12);
  }

uint64_t sub_10040371C(uint64_t a1, uint64_t a2)
{
  return (*(uint64_t (**)(uint64_t, void, void))(*(void *)a2 + 8LL))( a2,  *(void *)(a1 + 32),  *(unsigned int *)(a1 + 40));
}

void sub_100403738(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  uint64_t v7 = sub_10040007C((void *)a1, a3, 0);
  if (v7)
  {
    uint64_t v8 = (uint64_t)v7;
    if (qword_1008D60B0 != -1) {
      dispatch_once(&qword_1008D60B0, &stru_100896570);
    }
    int v9 = sub_1004317E0((uint64_t)off_1008D60A8, a2, 10000);
    if (qword_1008D60B0 != -1) {
      dispatch_once(&qword_1008D60B0, &stru_100896570);
    }
    int v10 = sub_1004317E0((uint64_t)off_1008D60A8, a4, 10000);
    sub_1003D9B88(v8, v9, v10);
    if (qword_1008D67E8 != -1) {
      dispatch_once(&qword_1008D67E8, &stru_100896530);
    }
    v11[0] = _NSConcreteStackBlock;
    v11[1] = 3221225472LL;
    void v11[2] = sub_100403898;
    v11[3] = &unk_1008964D0;
    uint8_t v11[4] = v8;
    int v12 = v9;
    int v13 = v10;
    sub_1004018DC((os_unfair_lock_s *)(a1 + 240), v11);
  }

uint64_t sub_100403898(uint64_t a1, uint64_t a2)
{
  return (*(uint64_t (**)(uint64_t, void, void, void))(*(void *)a2 + 16LL))( a2,  *(void *)(a1 + 32),  *(unsigned int *)(a1 + 40),  *(unsigned int *)(a1 + 44));
}

_BYTE *sub_1004038B4(uint64_t a1)
{
  char v15 = 0;
  sub_100242CA4(&v15);
  uint64_t v2 = sub_10010EBE0((uint64_t)&unk_1008D9858);
  if ((_DWORD)v2)
  {
    std::string::size_type v3 = (os_log_s *)qword_1008F7578;
    if (os_log_type_enabled((os_log_t)qword_1008F7578, OS_LOG_TYPE_ERROR)) {
      sub_10067B918(v2, v3, v4, v5, v6, v7, v8, v9);
    }
  }

  sub_100242CD0(&v15);
  v14[0] = 0LL;
  v14[1] = 0LL;
  sub_100242F28((uint64_t)v14, a1 + 168);
  std::string __p = 0LL;
  int v12 = 0LL;
  uint64_t v13 = 0LL;
  sub_100240540(&__p, a1 + 144);
  sub_100242F54((uint64_t)v14);
  if (__p)
  {
    int v12 = __p;
    operator delete(__p);
  }

  sub_100242FAC((uint64_t)v14);
  return sub_100242CD8(&v15);
}

void sub_100403980( _Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, void *__p, uint64_t a10, uint64_t a11, char a12)
{
  if (__p) {
    operator delete(__p);
  }
  sub_100242FAC((uint64_t)&a12);
  sub_100242CD8((_BYTE *)(v12 - 33));
  _Unwind_Resume(a1);
}

_BYTE *sub_1004039C0(uint64_t a1)
{
  return sub_1004038B4(a1 - 40);
}

_BYTE *sub_1004039C8(uint64_t a1)
{
  uint64_t v2 = (os_log_s *)qword_1008F7578;
  if (os_log_type_enabled((os_log_t)qword_1008F7578, OS_LOG_TYPE_DEFAULT))
  {
    *(_WORD *)std::string buf = 0;
    _os_log_impl((void *)&_mh_execute_header, v2, OS_LOG_TYPE_DEFAULT, "DeviceManager::stackWillStop enter", buf, 2u);
  }

  char v21 = 0;
  sub_100242CA4(&v21);
  uint64_t v3 = sub_10010ECD0((uint64_t)&unk_1008D9858);
  if ((_DWORD)v3)
  {
    uint64_t v4 = (os_log_s *)qword_1008F7578;
    if (os_log_type_enabled((os_log_t)qword_1008F7578, OS_LOG_TYPE_ERROR)) {
      sub_10067B97C(v3, v4, v5, v6, v7, v8, v9, v10);
    }
  }

  sub_10010F908();
  sub_100242CD0(&v21);
  *(void *)std::string buf = 0LL;
  uint64_t v20 = 0LL;
  sub_100242F28((uint64_t)buf, a1 + 168);
  uint64_t v12 = *(void *)(a1 + 144);
  for (uint64_t i = *(void *)(a1 + 152); v12 != i; v12 += 8LL)
  {
    unint64_t v13 = ((unint64_t)*(unsigned __int8 *)(*(void *)v12 + 128LL) << 40) | ((unint64_t)*(unsigned __int8 *)(*(void *)v12 + 129LL) << 32) | ((unint64_t)*(unsigned __int8 *)(*(void *)v12 + 130LL) << 24) | ((unint64_t)*(unsigned __int8 *)(*(void *)v12 + 131LL) << 16) | ((unint64_t)*(unsigned __int8 *)(*(void *)v12 + 132LL) << 8) | *(unsigned __int8 *)(*(void *)v12 + 133LL);
    if (v13)
    {
      uint64_t v14 = sub_100404EB8();
      v18[0] = _NSConcreteStackBlock;
      v18[1] = 3221225472LL;
      v18[2] = sub_100403BB4;
      v18[3] = &unk_10087F8E0;
      v18[4] = a1;
      v18[5] = v13;
      sub_100405384(v14, v18);
      uint64_t i = *(void *)(a1 + 152);
    }
  }

  char v15 = (os_log_s *)qword_1008F7578;
  if (os_log_type_enabled((os_log_t)qword_1008F7578, OS_LOG_TYPE_DEFAULT))
  {
    *(_WORD *)uint64_t v17 = 0;
    _os_log_impl((void *)&_mh_execute_header, v15, OS_LOG_TYPE_DEFAULT, "DeviceManager::stackWillStop exit", v17, 2u);
  }

  sub_100242FAC((uint64_t)buf);
  return sub_100242CD8(&v21);
}

void sub_100403B8C(_Unwind_Exception *a1)
{
}

void sub_100403BB4(uint64_t a1)
{
}

_BYTE *sub_100403BC8(uint64_t a1)
{
  return sub_1004039C8(a1 - 40);
}

void *sub_100403BE0(void *__dst, __int128 *a2, uint64_t a3)
{
  if (*((char *)a2 + 23) < 0)
  {
    sub_100024238(__dst, *(void **)a2, *((void *)a2 + 1));
  }

  else
  {
    __int128 v5 = *a2;
    __dst[2] = *((void *)a2 + 2);
    *(_OWORD *)std::string __dst = v5;
  }

  __dst[3] = 0LL;
  __dst[4] = 0LL;
  __dst[5] = 0LL;
  uint64_t v6 = *(const void **)a3;
  size_t v7 = *(void *)(a3 + 8) - *(void *)a3;
  if (v7)
  {
    sub_10023D39C(__dst + 3, v7);
    uint64_t v8 = (char *)__dst[4];
    memmove(v8, v6, v7);
    __dst[4] = &v8[v7];
  }

  return __dst;
}

void sub_100403C74(_Unwind_Exception *exception_object)
{
}

void sub_100403C90(int a1, uint64_t a2, unsigned __int8 *a3)
{
  unint64_t v4 = ((unint64_t)*a3 << 40) | ((unint64_t)a3[1] << 32) | ((unint64_t)a3[2] << 24) | ((unint64_t)a3[3] << 16) | ((unint64_t)a3[4] << 8) | a3[5];
  char v5 = *(_BYTE *)(a2 + 327);
  uint64_t v6 = sub_100404EB8();
  v7[0] = _NSConcreteStackBlock;
  v7[1] = 3221225472LL;
  v7[2] = sub_100403E1C;
  v7[3] = &unk_10088DA08;
  int v8 = a1;
  v7[4] = v4;
  char v9 = v5;
  sub_100405384(v6, v7);
}

void sub_100403D34(int a1, uint64_t a2, int a3)
{
  __int16 v13 = 0;
  int v12 = 0;
  if (sub_10010EF78(a2, (uint64_t)&v12))
  {
    uint64_t v6 = (os_log_s *)qword_1008F7578;
    if (os_log_type_enabled((os_log_t)qword_1008F7578, OS_LOG_TYPE_ERROR)) {
      sub_10067B9E0(a2, v6);
    }
  }

  else
  {
    unint64_t v7 = ((unint64_t)v12 << 40) | ((unint64_t)BYTE1(v12) << 32) | ((unint64_t)BYTE2(v12) << 24) | ((unint64_t)HIBYTE(v12) << 16) | ((unint64_t)v13 << 8) | HIBYTE(v13);
    uint64_t v8 = sub_100404EB8();
    v9[0] = _NSConcreteStackBlock;
    v9[1] = 3221225472LL;
    void v9[2] = sub_100403F00;
    v9[3] = &unk_10087F8E0;
    v9[4] = v7;
    int v10 = a1;
    int v11 = a3;
    sub_100405384(v8, v9);
  }

void sub_100403E1C(uint64_t a1)
{
  uint64_t v2 = (os_log_s *)qword_1008F7578;
  if (os_log_type_enabled((os_log_t)qword_1008F7578, OS_LOG_TYPE_DEFAULT))
  {
    int v3 = *(_DWORD *)(a1 + 40);
    v4[0] = 67109120;
    v4[1] = v3;
    _os_log_impl( (void *)&_mh_execute_header,  v2,  OS_LOG_TYPE_DEFAULT,  "Device connected connectCfmCb status %d",  (uint8_t *)v4,  8u);
  }

  if (qword_1008D5F50 != -1) {
    dispatch_once(&qword_1008D5F50, &stru_1008965D0);
  }
  sub_10040357C((uint64_t)off_1008D5F48, *(unsigned int *)(a1 + 40), *(void *)(a1 + 32), *(_BYTE *)(a1 + 44));
}

void sub_100403F00(uint64_t a1)
{
  if (qword_1008D5F50 != -1) {
    dispatch_once(&qword_1008D5F50, &stru_1008965D0);
  }
  sub_100403738((uint64_t)off_1008D5F48, *(unsigned int *)(a1 + 40), *(void *)(a1 + 32), *(unsigned int *)(a1 + 44));
}

void sub_100403F54(id a1)
{
  uint64_t v1 = operator new(0x120uLL);
  sub_100495250();
  qword_1008D61A0 = (uint64_t)v1;
}

void sub_100403F84(_Unwind_Exception *a1)
{
}

void sub_100403F98(id a1)
{
  uint64_t v1 = operator new(0x198uLL);
  sub_100534AB0();
  off_1008D67B0 = v1;
}

void sub_100403FC8(_Unwind_Exception *a1)
{
}

void sub_100403FDC(id a1)
{
  uint64_t v1 = operator new(0x98uLL);
  sub_1003C97E4((uint64_t)v1);
  off_1008D67E0 = v1;
}

void sub_10040400C(_Unwind_Exception *a1)
{
}

void sub_100404020(id a1)
{
  uint64_t v1 = operator new(0xA8uLL);
  sub_10040D0A0((uint64_t)v1);
  off_1008D6780 = v1;
}

void sub_100404050(_Unwind_Exception *a1)
{
}

void sub_100404064(id a1)
{
  uint64_t v1 = operator new(0x230uLL);
  sub_10042BC28();
  off_1008D60A8 = v1;
}

void sub_100404094(_Unwind_Exception *a1)
{
}

void sub_1004040A8(id a1)
{
  uint64_t v1 = operator new(0x2B0uLL);
  sub_10040749C((uint64_t)v1);
  off_1008D5EF8 = v1;
}

void sub_1004040D8(_Unwind_Exception *a1)
{
}

void sub_1004040EC(id a1)
{
  uint64_t v1 = operator new(0x2C0uLL);
  sub_1004219F0();
  off_1008D60C8 = v1;
}

void sub_10040411C(_Unwind_Exception *a1)
{
}

void sub_100404130(id a1)
{
  uint64_t v1 = operator new(0x138uLL);
  sub_1003FE304((uint64_t)v1);
  off_1008D5F48 = v1;
}

void sub_100404160(_Unwind_Exception *a1)
{
}

void sub_100404174(id a1)
{
  uint64_t v1 = operator new(0x4A8uLL);
  sub_100499870();
  off_1008D60E8 = v1;
}

void sub_1004041A4(_Unwind_Exception *a1)
{
}

uint64_t sub_1004041B8(uint64_t a1, const void **a2, uint64_t a3)
{
  *(void *)(a1 + 8) = 0LL;
  unint64_t v4 = (uint64_t *)(a1 + 8);
  *(void *)(a1 + 16) = 0LL;
  *(void *)a1 = a1 + 8;
  if (a3)
  {
    uint64_t v6 = 48 * a3;
    do
    {
      sub_100404238((uint64_t **)a1, v4, a2, (__int128 *)a2);
      a2 += 6;
      v6 -= 48LL;
    }

    while (v6);
  }

  return a1;
}

void sub_100404220(_Unwind_Exception *a1)
{
}

uint64_t *sub_100404238(uint64_t **a1, uint64_t *a2, const void **a3, __int128 *a4)
{
  uint64_t v11 = 0LL;
  int v12 = 0LL;
  uint64_t v6 = sub_10023E45C(a1, a2, &v12, &v11, a3);
  unint64_t v7 = (uint64_t *)*v6;
  if (!*v6)
  {
    uint64_t v8 = (uint64_t **)v6;
    memset(v10, 0, sizeof(v10));
    sub_1004042D8((uint64_t)a1, a4, v10);
    sub_100029630(a1, (uint64_t)v12, v8, v10[0]);
    unint64_t v7 = v10[0];
    v10[0] = 0LL;
    sub_1004043F4((uint64_t)v10, 0LL);
  }

  return v7;
}

void *sub_1004042D8@<X0>(uint64_t a1@<X0>, __int128 *a2@<X1>, void *a3@<X8>)
{
  uint64_t v5 = a1 + 8;
  *a3 = 0LL;
  a3[1] = 0LL;
  a3[2] = 0LL;
  uint64_t v6 = operator new(0x50uLL);
  *a3 = v6;
  a3[1] = v5;
  *((_BYTE *)a3 + 16) = 0;
  uint64_t result = sub_100404348(v6 + 4, a2);
  *((_BYTE *)a3 + 16) = 1;
  return result;
}

void sub_100404330(_Unwind_Exception *a1)
{
}

void *sub_100404348(void *__dst, __int128 *a2)
{
  if (*((char *)a2 + 23) < 0)
  {
    sub_100024238(__dst, *(void **)a2, *((void *)a2 + 1));
  }

  else
  {
    __int128 v4 = *a2;
    __dst[2] = *((void *)a2 + 2);
    *(_OWORD *)std::string __dst = v4;
  }

  __dst[3] = 0LL;
  __dst[4] = 0LL;
  __dst[5] = 0LL;
  uint64_t v6 = (_BYTE *)*((void *)a2 + 3);
  uint64_t v5 = (_BYTE *)*((void *)a2 + 4);
  size_t v7 = v5 - v6;
  if (v5 != v6)
  {
    sub_10023D39C(__dst + 3, v5 - v6);
    uint64_t v8 = (char *)__dst[4];
    memmove(v8, v6, v7);
    __dst[4] = &v8[v7];
  }

  return __dst;
}

void sub_1004043D8(_Unwind_Exception *exception_object)
{
}

void sub_1004043F4(uint64_t a1, uint64_t a2)
{
  uint64_t v2 = *(void **)a1;
  *(void *)a1 = a2;
  if (v2)
  {
    if (*(_BYTE *)(a1 + 16)) {
      sub_100404438((uint64_t)v2 + 32);
    }
    operator delete(v2);
  }

void sub_100404438(uint64_t a1)
{
  uint64_t v2 = *(void **)(a1 + 24);
  if (v2)
  {
    *(void *)(a1 + 32) = v2;
    operator delete(v2);
  }

void sub_10040447C(uint64_t a1, void *a2)
{
  if (a2)
  {
    sub_10040447C(a1, *a2);
    sub_10040447C(a1, a2[1]);
    sub_100404438((uint64_t)(a2 + 4));
    operator delete(a2);
  }

void *sub_1004044C4(int a1, uint64_t a2, uint64_t a3, void *a4)
{
  if (a2 != a3)
  {
    uint64_t v6 = a2;
    do
    {
      *a4 = 0LL;
      a4[1] = 0LL;
      a4[2] = 0LL;
      uint64_t v8 = *(const void **)v6;
      uint64_t v7 = *(void *)(v6 + 8);
      size_t v9 = v7 - *(void *)v6;
      if (v7 != *(void *)v6)
      {
        sub_10023D39C(a4, v7 - *(void *)v6);
        int v10 = (char *)a4[1];
        memmove(v10, v8, v9);
        a4[1] = &v10[v9];
      }

      a4 += 3;
      v6 += 24LL;
    }

    while (v6 != a3);
  }

  return a4;
}

void sub_100404550(void ***a1)
{
  uint64_t v2 = *a1;
  if (*v2)
  {
    sub_100404590((uint64_t *)v2);
    operator delete(**a1);
  }

void sub_100404590(uint64_t *a1)
{
  uint64_t v3 = *a1;
  uint64_t v2 = a1[1];
  if (v2 != *a1)
  {
    uint64_t v4 = a1[1];
    do
    {
      uint64_t v6 = *(void **)(v4 - 24);
      v4 -= 24LL;
      uint64_t v5 = v6;
      if (v6)
      {
        *(void *)(v2 - 16) = v5;
        operator delete(v5);
      }

      uint64_t v2 = v4;
    }

    while (v4 != v3);
  }

  a1[1] = v3;
}

uint64_t sub_1004045E4(uint64_t a1, uint64_t a2, uint64_t a3)
{
  uint64_t v3 = a1;
  if (a1 != a2)
  {
    uint64_t v5 = *(const void **)a3;
    size_t v6 = *(void *)(a3 + 8) - *(void *)a3;
    while (*(void *)(v3 + 8) - *(void *)v3 != v6 || memcmp(*(const void **)v3, v5, v6))
    {
      v3 += 24LL;
      if (v3 == a2) {
        return a2;
      }
    }
  }

  return v3;
}

void sub_100404650(id a1)
{
  uint64_t v1 = operator new(0x350uLL);
  sub_100461C70();
  off_1008D9028 = v1;
}

void sub_100404680(_Unwind_Exception *a1)
{
}

uint64_t **sub_100404694(uint64_t **a1, unint64_t *a2, uint64_t a3, void **a4)
{
  uint64_t v7 = a1 + 1;
  size_t v6 = a1[1];
  if (v6)
  {
    unint64_t v8 = *a2;
    while (1)
    {
      while (1)
      {
        size_t v9 = (uint64_t **)v6;
        unint64_t v10 = v6[4];
        if (v8 >= v10) {
          break;
        }
        size_t v6 = *v9;
        uint64_t v7 = v9;
        if (!*v9) {
          goto LABEL_10;
        }
      }

      if (v10 >= v8) {
        break;
      }
      size_t v6 = v9[1];
      if (!v6)
      {
        uint64_t v7 = v9 + 1;
        goto LABEL_10;
      }
    }
  }

  else
  {
    size_t v9 = a1 + 1;
LABEL_10:
    uint64_t v11 = operator new(0x30uLL);
    uint8_t v11[4] = **a4;
    *((_BYTE *)v11 + 40) = 0;
    sub_100029630(a1, (uint64_t)v9, v7, v11);
    return (uint64_t **)v11;
  }

  return v9;
}

void sub_100404754(id a1)
{
  uint64_t v1 = operator new(0x260uLL);
  sub_1005285C8((uint64_t)v1);
  off_1008D67A0 = v1;
}

void sub_100404784(_Unwind_Exception *a1)
{
}

uint64_t sub_100404798(unsigned __int8 *a1, _BYTE *a2, _BYTE *a3)
{
  __int128 v17 = 0uLL;
  int v6 = *a1;
  if (v6 == 16)
  {
LABEL_6:
    uint64_t result = sub_10063443C(a1, &v17);
    goto LABEL_7;
  }

  if (v6 != 2)
  {
    unint64_t v8 = (os_log_s *)qword_1008F7578;
    if (os_log_type_enabled((os_log_t)qword_1008F7578, OS_LOG_TYPE_FAULT)) {
      sub_10067BA50((uint64_t)a1, v8);
    }
    goto LABEL_6;
  }

  __int16 v16 = 0;
  uint64_t result = sub_10063443C(a1, &v16);
  __int128 v17 = xmmword_1006BCAA0;
  WORD1(v17) = v16;
LABEL_7:
  unsigned int v9 = 0;
  unint64_t v10 = &v17;
  int v11 = 15;
  do
  {
    int v12 = v11;
    v9 ^= *(unsigned __int8 *)v10;
    int v13 = 8;
    do
    {
      int v14 = 2 * v9;
      int v15 = (char)v9;
      unsigned int v9 = (2 * v9) ^ 9;
      if (v15 >= 0) {
        unsigned int v9 = v14;
      }
      --v13;
    }

    while (v13);
    unint64_t v10 = (__int128 *)((char *)v10 + 1);
    int v11 = v12 - 1;
  }

  while (v12);
  *a2 = (v9 >> 3) & 0xF;
  *a3 = v9 & 7;
  return result;
}

uint64_t sub_1004048CC(uint64_t a1, uint64_t a2, char *a3, uint64_t a4)
{
  for (unsigned int i = 0; a4; --a4)
  {
    char v5 = *a3++;
    unsigned int i = byte_1006C2A3C[(v5 ^ i)];
  }

  return (*(unsigned __int8 *)(a1 + ((unint64_t)i >> 3)) >> (i & 7)) & 1;
}

uint64_t sub_100404910(uint64_t a1, uint64_t a2, char *a3, uint64_t a4)
{
  for (unsigned int i = 0; a4; --a4)
  {
    char v5 = *a3++;
    unsigned int i = byte_1006C2A3C[(v5 ^ i)];
  }

  unint64_t v6 = (unint64_t)i >> 3;
  char v7 = i & 7;
  int v8 = *(unsigned __int8 *)(a1 + v6);
  int v9 = 1 << v7;
  if ((v9 & v8) != 0) {
    return 0LL;
  }
  *(_BYTE *)(a1 + v6) = v8 | v9;
  return 1LL;
}

void *sub_100404970(void *a1, int a2, unsigned int a3, unsigned int a4)
{
  *a1 = &off_1008967F0;
  uint64_t v8 = (uint64_t)(a1 + 1);
  dispatch_queue_global_t global_queue = dispatch_get_global_queue(21LL, 0LL);
  sub_100207EC0(v8, (int)a1, "com.apple.BTServer.pbap", global_queue);
  int v10 = a2 - 3;
  if ((a2 - 3) >= 7 || ((0x5Fu >> v10) & 1) == 0)
  {
    uint64_t v14 = sub_1002E6E00();
    sub_1004FC118(v14, 0);
  }

  int v11 = (&off_100896818)[v10];
  sub_100207EFC(v8);
  xpc_object_t v12 = xpc_dictionary_create(0LL, 0LL, 0LL);
  xpc_dictionary_set_string(v12, "kArgType", v11);
  xpc_dictionary_set_uint64(v12, "kArgOffset", a3);
  xpc_dictionary_set_uint64(v12, "kArgCount", a4);
  sub_100208104(v8, "Open", v12, 0LL);
  return a1;
}

void sub_100404A80(_Unwind_Exception *a1)
{
}

void *sub_100404A9C(void *a1)
{
  *a1 = &off_1008967F0;
  sub_100207EF8((uint64_t)(a1 + 1));
  return a1;
}

void sub_100404ACC(void *a1)
{
  *a1 = &off_1008967F0;
  sub_100207EF8((uint64_t)(a1 + 1));
  operator delete(a1);
}

void sub_100404AFC(uint64_t a1)
{
  v1[0] = _NSConcreteStackBlock;
  v1[1] = 3221225472LL;
  v1[2] = sub_100404B54;
  v1[3] = &unk_10087EB20;
  v1[4] = a1;
  sub_100207FA8(a1 + 8, v1);
}

uint64_t sub_100404B54(uint64_t a1)
{
  uint64_t result = *(void *)(a1 + 32);
  if (result) {
    return (*(uint64_t (**)(uint64_t))(*(void *)result + 32LL))(result);
  }
  return result;
}

uint64_t sub_100404B6C(uint64_t a1)
{
  uint64_t v4 = 0LL;
  char v5 = &v4;
  uint64_t v6 = 0x2020000000LL;
  int v7 = 0;
  v3[0] = _NSConcreteStackBlock;
  v3[1] = 3221225472LL;
  v3[2] = sub_100404C1C;
  v3[3] = &unk_10087EB00;
  v3[4] = &v4;
  sub_100208214(a1 + 8, "GetSize", 0LL, v3);
  uint64_t v1 = *((unsigned int *)v5 + 6);
  _Block_object_dispose(&v4, 8);
  return v1;
}

void sub_100404C04( _Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, ...)
{
}

uint64_t sub_100404C1C(uint64_t a1, xpc_object_t xdict)
{
  uint64_t result = xpc_dictionary_get_uint64(xdict, "kValue");
  *(_DWORD *)(*(void *)(*(void *)(a1 + 32) + 8LL) + 24LL) = result;
  return result;
}

uint64_t sub_100404C58(uint64_t a1, unsigned int a2)
{
  uint64_t v8 = 0LL;
  int v9 = &v8;
  uint64_t v10 = 0x2020000000LL;
  uint64_t v11 = 0LL;
  xpc_object_t v4 = xpc_dictionary_create(0LL, 0LL, 0LL);
  xpc_dictionary_set_uint64(v4, "kArgIndex", a2);
  v7[0] = _NSConcreteStackBlock;
  v7[1] = 3221225472LL;
  v7[2] = sub_100404D40;
  v7[3] = &unk_10087EB00;
  v7[4] = &v8;
  sub_100208214(a1 + 8, "GetRecentCall", v4, v7);
  uint64_t v5 = v9[3];
  _Block_object_dispose(&v8, 8);
  return v5;
}

void sub_100404D28( _Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, ...)
{
}

std::string *sub_100404D40(uint64_t a1, void *a2)
{
  xpc_object_t v4 = operator new(0x70uLL);
  *(_OWORD *)((char *)v4 + _Block_object_dispose(va, 8) = 0u;
  *(_OWORD *)((char *)v4 + 24) = 0u;
  *(_OWORD *)((char *)v4 + 40) = 0u;
  v4[4] = 0u;
  v4[5] = 0u;
  v4[6] = 0u;
  *(void *)(*(void *)(*(void *)(a1 + 32) + 8LL) + 24LL) = v4;
  xpc_object_t value = xpc_dictionary_get_value(a2, "kLegacyIdentifier");
  if (value) {
    LODWORD(value) = xpc_uint64_get_value(value);
  }
  **(_DWORD **)(*(void *)(*(void *)(a1 + 32) + 8LL) + 24LL) = (_DWORD)value;
  xpc_object_t v6 = xpc_dictionary_get_value(a2, "kCallerId");
  if (v6)
  {
    string_ptr = xpc_string_get_string_ptr(v6);
    std::string::assign((std::string *)(*(void *)(*(void *)(*(void *)(a1 + 32) + 8LL) + 24LL) + 8LL), string_ptr);
  }

  xpc_object_t v8 = xpc_dictionary_get_value(a2, "kStatus");
  if (v8)
  {
    int v9 = xpc_string_get_string_ptr(v8);
    std::string::assign((std::string *)(*(void *)(*(void *)(*(void *)(a1 + 32) + 8LL) + 24LL) + 32LL), v9);
  }

  uint64_t v10 = xpc_dictionary_get_value(a2, "kDate");
  if (v10) {
    uint64_t v10 = (void *)xpc_date_get_value(v10);
  }
  *(void *)(*(void *)(*(void *)(*(void *)(a1 + 32) + 8LL) + 24LL) + 56LL) = v10;
  xpc_object_t v11 = xpc_dictionary_get_value(a2, "kLabel");
  if (v11)
  {
    xpc_object_t v12 = xpc_string_get_string_ptr(v11);
    std::string::assign((std::string *)(*(void *)(*(void *)(*(void *)(a1 + 32) + 8LL) + 24LL) + 64LL), v12);
  }

  uint64_t result = (std::string *)xpc_dictionary_get_value(a2, "kProviderIdentifier");
  if (result)
  {
    uint64_t v14 = xpc_string_get_string_ptr(result);
    return std::string::assign((std::string *)(*(void *)(*(void *)(*(void *)(a1 + 32) + 8LL) + 24LL) + 88LL), v14);
  }

  return result;
}

void sub_100404EA4()
{
  uint64_t v0 = sub_1002E6E00();
  sub_1004FC118(v0, 0);
}

uint64_t sub_100404EB8()
{
  if (qword_1008F0A28 != -1) {
    dispatch_once(&qword_1008F0A28, &stru_100896850);
  }
  return qword_1008F0A20;
}

void sub_100404EF8(id a1)
{
  uint64_t v1 = operator new(0x10uLL);
  *uint64_t v1 = "com.apple.bluetooth.root";
  v1[1] = 0LL;
  qword_1008F0A20 = (uint64_t)v1;
  sub_100404F30((uint64_t)v1, QOS_CLASS_USER_INITIATED);
}

void *sub_100404F28(void *result, uint64_t a2)
{
  *uint64_t result = a2;
  result[1] = 0LL;
  return result;
}

void sub_100404F30(uint64_t a1, dispatch_qos_class_t a2)
{
  if (*(void *)(a1 + 8))
  {
    xpc_object_t v4 = (os_log_s *)qword_1008F7700;
    if (os_log_type_enabled((os_log_t)qword_1008F7700, OS_LOG_TYPE_FAULT)) {
      sub_10067BB08(v4, v5, v6);
    }
  }

  int v7 = dispatch_queue_attr_make_with_autorelease_frequency(0LL, DISPATCH_AUTORELEASE_FREQUENCY_WORK_ITEM);
  xpc_object_t v8 = dispatch_queue_attr_make_with_qos_class(v7, a2, 0);
  *(void *)(a1 + _Block_object_dispose(va, 8) = dispatch_queue_create(*(const char **)a1, v8);
  if (qword_1008D9878 != -1) {
    dispatch_once(&qword_1008D9878, &stru_1008969A8);
  }
  sub_1004055EC((dispatch_queue_s **)qword_1008D9870, *(dispatch_queue_t *)(a1 + 8));
}

uint64_t sub_100404FE8()
{
  if (qword_1008F0A38 != -1) {
    dispatch_once(&qword_1008F0A38, &stru_100896870);
  }
  return qword_1008F0A30;
}

void sub_100405028(id a1)
{
  uint64_t v1 = operator new(0x10uLL);
  *uint64_t v1 = "com.apple.bluetooth.coreBluetooth";
  v1[1] = 0LL;
  qword_1008F0A30 = (uint64_t)v1;
  sub_100404F30((uint64_t)v1, QOS_CLASS_USER_INTERACTIVE);
}

uint64_t sub_100405058()
{
  if (qword_1008F0A48 != -1) {
    dispatch_once(&qword_1008F0A48, &stru_100896890);
  }
  return qword_1008F0A40;
}

void sub_100405098(id a1)
{
  uint64_t v1 = operator new(0x10uLL);
  *uint64_t v1 = "com.apple.bluetooth.telephony";
  v1[1] = 0LL;
  qword_1008F0A40 = (uint64_t)v1;
  sub_100404F30((uint64_t)v1, QOS_CLASS_USER_INITIATED);
}

uint64_t sub_1004050C8()
{
  if (qword_1008F0A58 != -1) {
    dispatch_once(&qword_1008F0A58, &stru_1008968B0);
  }
  return qword_1008F0A50;
}

void sub_100405108(id a1)
{
  uint64_t v1 = operator new(0x10uLL);
  *uint64_t v1 = "com.apple.bluetooth.media";
  v1[1] = 0LL;
  qword_1008F0A50 = (uint64_t)v1;
  sub_100404F30((uint64_t)v1, QOS_CLASS_USER_INITIATED);
}

uint64_t sub_100405138()
{
  if (qword_1008F0A68 != -1) {
    dispatch_once(&qword_1008F0A68, &stru_1008968D0);
  }
  return qword_1008F0A60;
}

void sub_100405178(id a1)
{
  uint64_t v1 = operator new(0x10uLL);
  *uint64_t v1 = "com.apple.bluetooth.LeObserverControllerConfig";
  v1[1] = 0LL;
  qword_1008F0A60 = (uint64_t)v1;
  sub_100404F30((uint64_t)v1, QOS_CLASS_USER_INTERACTIVE);
}

uint64_t sub_1004051A8()
{
  if (qword_1008F0A78 != -1) {
    dispatch_once(&qword_1008F0A78, &stru_1008968F0);
  }
  return qword_1008F0A70;
}

void sub_1004051E8(id a1)
{
  uint64_t v1 = operator new(0x10uLL);
  *uint64_t v1 = "com.apple.bluetooth.AOPInterfaceManager";
  v1[1] = 0LL;
  qword_1008F0A70 = (uint64_t)v1;
  sub_100404F30((uint64_t)v1, QOS_CLASS_USER_INITIATED);
}

uint64_t sub_100405218()
{
  if (qword_1008F0A88 != -1) {
    dispatch_once(&qword_1008F0A88, &stru_100896910);
  }
  return qword_1008F0A80;
}

void sub_100405258(id a1)
{
  uint64_t v1 = operator new(0x10uLL);
  *uint64_t v1 = "com.apple.bluetooth.Metrics";
  v1[1] = 0LL;
  qword_1008F0A80 = (uint64_t)v1;
  sub_100404F30((uint64_t)v1, QOS_CLASS_BACKGROUND);
}

uint64_t sub_100405288()
{
  if (qword_1008F0A98 != -1) {
    dispatch_once(&qword_1008F0A98, &stru_100896930);
  }
  return qword_1008F0A90;
}

void sub_1004052C8(id a1)
{
  uint64_t v1 = operator new(0x10uLL);
  *uint64_t v1 = "com.apple.bluetooth.ClassicScan";
  v1[1] = 0LL;
  qword_1008F0A90 = (uint64_t)v1;
  sub_100404F30((uint64_t)v1, QOS_CLASS_USER_INITIATED);
}

void sub_1004052F8(uint64_t a1)
{
  if (*(void *)(a1 + 8))
  {
    if (qword_1008D9878 != -1) {
      dispatch_once(&qword_1008D9878, &stru_1008969A8);
    }
    sub_100405698((dispatch_queue_s **)qword_1008D9870, *(dispatch_queue_t *)(a1 + 8));
    dispatch_release(*(dispatch_object_t *)(a1 + 8));
    *(void *)(a1 + _Block_object_dispose(va, 8) = 0LL;
  }

uint64_t sub_100405360(uint64_t a1)
{
  return a1;
}

void sub_100405384(uint64_t a1, void *a2)
{
  id v3 = a2;
  xpc_object_t v4 = *(dispatch_queue_s **)(a1 + 8);
  if (v4
    || (uint64_t v5 = (os_log_s *)qword_1008F7700, os_log_type_enabled((os_log_t)qword_1008F7700, OS_LOG_TYPE_FAULT))
    && (int v6 = 136446210,
        int v7 = "fQueue",
        _os_log_fault_impl( (void *)&_mh_execute_header,  v5,  OS_LOG_TYPE_FAULT,  "Assertion failed: %{public}s",  (uint8_t *)&v6,  0xCu),  (xpc_object_t v4 = *(dispatch_queue_s **)(a1 + 8)) != 0LL))
  {
    dispatch_async(v4, v3);
  }
}

void sub_100405460(uint64_t a1, uint64_t a2, void *a3)
{
  int64_t v4 = 1000000 * a2;
  dispatch_block_t block = a3;
  dispatch_time_t v5 = dispatch_time(0LL, v4);
  dispatch_after(v5, *(dispatch_queue_t *)(a1 + 8), block);
}

void sub_1004054B4(uint64_t a1, void *a2)
{
  id v3 = a2;
  if (qword_1008F0A28 != -1) {
    dispatch_once(&qword_1008F0A28, &stru_100896850);
  }
  if (qword_1008F0A20 == a1)
  {
    int64_t v4 = (os_log_s *)qword_1008F7700;
    if (os_log_type_enabled((os_log_t)qword_1008F7700, OS_LOG_TYPE_FAULT)) {
      sub_10067BB7C(v4, v5, v6);
    }
  }

  dispatch_sync(*(dispatch_queue_t *)(a1 + 8), v3);
}

void sub_100405550(uint64_t a1, void *a2)
{
  id v3 = a2;
  if (qword_1008F0A28 != -1) {
    dispatch_once(&qword_1008F0A28, &stru_100896850);
  }
  if (qword_1008F0A20 == a1)
  {
    int64_t v4 = (os_log_s *)qword_1008F7700;
    if (os_log_type_enabled((os_log_t)qword_1008F7700, OS_LOG_TYPE_FAULT)) {
      sub_10067BB7C(v4, v5, v6);
    }
  }

  dispatch_async_and_wait(*(dispatch_queue_t *)(a1 + 8), v3);
}

void sub_1004055EC(dispatch_queue_s **a1, dispatch_queue_t queue)
{
  if (dispatch_queue_get_qos_class(queue, 0LL) >= QOS_CLASS_DEFAULT)
  {
    if (os_log_type_enabled((os_log_t)qword_1008F7700, OS_LOG_TYPE_DEBUG)) {
      sub_10067BBF0(queue);
    }
    int64_t v4 = *a1;
    v5[0] = _NSConcreteStackBlock;
    v5[1] = 3221225472LL;
    v5[2] = sub_100405C6C;
    v5[3] = &unk_10087F8E0;
    v5[4] = a1;
    void v5[5] = queue;
    dispatch_async(v4, v5);
  }

void sub_100405698(dispatch_queue_s **a1, dispatch_queue_t queue)
{
  if (dispatch_queue_get_qos_class(queue, 0LL) >= QOS_CLASS_DEFAULT)
  {
    if (os_log_type_enabled((os_log_t)qword_1008F7700, OS_LOG_TYPE_DEBUG)) {
      sub_10067BC60(queue);
    }
    int64_t v4 = *a1;
    v5[0] = _NSConcreteStackBlock;
    v5[1] = 3221225472LL;
    v5[2] = sub_100405CA8;
    v5[3] = &unk_10087F8E0;
    v5[4] = a1;
    void v5[5] = queue;
    dispatch_sync(v4, v5);
  }

BOOL sub_100405744(uint64_t a1, _BYTE *a2)
{
  uint64_t v2 = *(void *)(a1 + 8);
  if (v2)
  {
    (*(void (**)(_BYTE *, uint64_t))(*(void *)a2 + 24LL))(a2, v2);
  }

  else if (a2 && a2[8])
  {
    (*(void (**)(_BYTE *))(*(void *)a2 + 8LL))(a2);
  }

  return v2 != 0;
}

void sub_1004057A0(void *a1, dispatch_queue_s *a2)
{
  int64_t v4 = (void (__cdecl *)(void *))(*(uint64_t (**)(void *))(*(void *)a1 + 32LL))(a1);
  dispatch_async_f(a2, a1, v4);
}

void sub_1004057D8(void *a1, dispatch_queue_s *a2)
{
  dispatch_time_t v4 = dispatch_time(0LL, 1000000LL * a1[2]);
  uint64_t v5 = (void (__cdecl *)(void *))(*(uint64_t (**)(void *))(*a1 + 32LL))(a1);
  dispatch_after_f(v4, a2, a1, v5);
}

_BYTE *sub_10040583C(_BYTE *result)
{
  uint64_t v1 = result;
  if (!result[9]) {
    uint64_t result = (_BYTE *)(*(uint64_t (**)(_BYTE *))(*(void *)result + 16LL))(result);
  }
  if (v1[8]) {
    return (_BYTE *)(*(uint64_t (**)(_BYTE *))(*(void *)v1 + 8LL))(v1);
  }
  return result;
}

void sub_100405890(void *a1, dispatch_queue_s *a2)
{
  dispatch_time_t v4 = (unsigned int *)(a1 + 7);
  do
    unsigned int v5 = __ldaxr(v4);
  while (__stlxr(v5 + 1, v4));
  if (!v5)
  {
    sub_10040635C(&v9, a1 + 3);
    sub_1002102FC((uint64_t)(a1 + 5), &v9);
    uint64_t v6 = (std::__shared_weak_count *)*((void *)&v9 + 1);
    if (*((void *)&v9 + 1))
    {
      int v7 = (unint64_t *)(*((void *)&v9 + 1) + 8LL);
      do
        unint64_t v8 = __ldaxr(v7);
      while (__stlxr(v8 - 1, v7));
      if (!v8)
      {
        ((void (*)(std::__shared_weak_count *))v6->__on_zero_shared)(v6);
        std::__shared_weak_count::__release_weak(v6);
      }
    }
  }

  sub_1004057D8(a1, a2);
}

void sub_100405938(uint64_t a1)
{
  uint64_t v2 = *(std::__shared_weak_count **)(a1 + 32);
  if (v2)
  {
    uint64_t v3 = *(void *)(a1 + 24);
    p_shared_weak_owners = (unint64_t *)&v2->__shared_weak_owners_;
    do
      unint64_t v5 = __ldxr(p_shared_weak_owners);
    while (__stxr(v5 + 1, p_shared_weak_owners));
    uint64_t v16 = 0LL;
    __int128 v17 = std::__shared_weak_count::lock(v2);
    if (v17)
    {
      uint64_t v16 = v3;
      if (v3) {
        (*(void (**)(uint64_t))(*(void *)v3 + 16LL))(v3);
      }
    }
  }

  else
  {
    uint64_t v16 = 0LL;
    __int128 v17 = 0LL;
  }

  uint64_t v6 = (unsigned int *)(a1 + 56);
  do
  {
    unsigned int v7 = __ldaxr(v6);
    unsigned int v8 = v7 - 1;
  }

  while (__stlxr(v8, v6));
  if (!v8)
  {
    __int128 v15 = 0uLL;
    sub_1002102FC(a1 + 40, &v15);
    __int128 v9 = (std::__shared_weak_count *)*((void *)&v15 + 1);
    if (*((void *)&v15 + 1))
    {
      uint64_t v10 = (unint64_t *)(*((void *)&v15 + 1) + 8LL);
      do
        unint64_t v11 = __ldaxr(v10);
      while (__stlxr(v11 - 1, v10));
      if (!v11)
      {
        ((void (*)(std::__shared_weak_count *))v9->__on_zero_shared)(v9);
        std::__shared_weak_count::__release_weak(v9);
      }
    }
  }

  xpc_object_t v12 = v17;
  if (v17)
  {
    p_shared_owners = (unint64_t *)&v17->__shared_owners_;
    do
      unint64_t v14 = __ldaxr(p_shared_owners);
    while (__stlxr(v14 - 1, p_shared_owners));
    if (!v14)
    {
      ((void (*)(std::__shared_weak_count *))v12->__on_zero_shared)(v12);
      std::__shared_weak_count::__release_weak(v12);
    }
  }

  if (v2) {
    std::__shared_weak_count::__release_weak(v2);
  }
}

void sub_100405A5C(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, ...)
{
}

void *sub_100405A78(void *a1)
{
  a1[2] = 0LL;
  a1[1] = a1 + 2;
  a1[6] = 0LL;
  a1[7] = 0LL;
  a1[5] = 0LL;
  a1[3] = 0LL;
  a1[4] = a1 + 5;
  block[0] = _NSConcreteStackBlock;
  block[1] = 3221225472LL;
  block[2] = sub_100405B10;
  block[3] = &unk_10087EB20;
  block[4] = a1;
  if (qword_1008F0AA0 != -1) {
    dispatch_once(&qword_1008F0AA0, block);
  }
  return a1;
}

void sub_100405B10(uint64_t a1)
{
  uint64_t v1 = *(dispatch_queue_t **)(a1 + 32);
  uint64_t v2 = dispatch_queue_attr_make_with_autorelease_frequency(0LL, DISPATCH_AUTORELEASE_FREQUENCY_WORK_ITEM);
  uint64_t v3 = dispatch_queue_attr_make_with_qos_class(v2, QOS_CLASS_DEFAULT, 0);
  *uint64_t v1 = dispatch_queue_create("com.apple.bluetooth.DispatcherWatchdog", v3);
  sub_100405B5C((uint64_t)v1);
}

void sub_100405B5C(uint64_t a1)
{
  uint64_t v2 = *(void **)(a1 + 8);
  uint64_t v3 = (void *)(a1 + 16);
  if (v2 != (void *)(a1 + 16))
  {
    do
    {
      dispatch_time_t v4 = (dispatch_queue_s *)v2[4];
      block[0] = _NSConcreteStackBlock;
      block[1] = 3221225472LL;
      block[2] = sub_100406160;
      block[3] = &unk_10087F8E0;
      block[4] = a1;
      void block[5] = v4;
      dispatch_async(v4, block);
      unint64_t v5 = (void *)v2[1];
      if (v5)
      {
        do
        {
          uint64_t v6 = v5;
          unint64_t v5 = (void *)*v5;
        }

        while (v5);
      }

      else
      {
        do
        {
          uint64_t v6 = (void *)v2[2];
          BOOL v7 = *v6 == (void)v2;
          uint64_t v2 = v6;
        }

        while (!v7);
      }

      uint64_t v2 = v6;
    }

    while (v6 != v3);
  }

  dispatch_time_t v8 = dispatch_time(0LL, 300000000000LL);
  __int128 v9 = *(dispatch_queue_s **)a1;
  v10[0] = _NSConcreteStackBlock;
  v10[1] = 3221225472LL;
  void v10[2] = sub_100406228;
  v10[3] = &unk_10087EB20;
  v10[4] = a1;
  dispatch_after(v8, v9, v10);
}

uint64_t *sub_100405C6C(uint64_t a1)
{
  uint64_t v1 = *(void *)(a1 + 32);
  uint64_t result = sub_1002555B0((uint64_t **)(v1 + 8), (unint64_t *)(a1 + 40), (uint64_t *)(a1 + 40));
  ++*(void *)(v1 + 56);
  return result;
}

uint64_t sub_100405CA8(uint64_t a1)
{
  uint64_t v1 = *(void *)(a1 + 32);
  uint64_t result = sub_10020166C(v1 + 8, (unint64_t *)(a1 + 40));
  --*(void *)(v1 + 56);
  return result;
}

void sub_100405CE0(uint64_t a1)
{
  if (os_log_type_enabled((os_log_t)qword_1008F7700, OS_LOG_TYPE_ERROR)) {
    sub_10067BDE0();
  }
  uint64_t v2 = *(void **)(a1 + 8);
  if (v2 != (void *)(a1 + 16))
  {
    uint64_t v3 = (os_log_s *)qword_1008F7700;
    do
    {
      if (os_log_type_enabled(v3, OS_LOG_TYPE_ERROR))
      {
        label = dispatch_queue_get_label((dispatch_queue_t)v2[4]);
        LODWORD(buf.__r_.__value_.__l.__data_) = 136315138;
        *(std::string::size_type *)((char *)buf.__r_.__value_.__r.__words + 4) = (std::string::size_type)label;
        _os_log_error_impl((void *)&_mh_execute_header, v3, OS_LOG_TYPE_ERROR, "%s", (uint8_t *)&buf, 0xCu);
        uint64_t v3 = (os_log_s *)qword_1008F7700;
      }

      dispatch_time_t v4 = (void *)v2[1];
      if (v4)
      {
        do
        {
          unint64_t v5 = v4;
          dispatch_time_t v4 = (void *)*v4;
        }

        while (v4);
      }

      else
      {
        do
        {
          unint64_t v5 = (void *)v2[2];
          BOOL v6 = *v5 == (void)v2;
          uint64_t v2 = v5;
        }

        while (!v6);
      }

      uint64_t v2 = v5;
    }

    while (v5 != (void *)(a1 + 16));
  }

  memset(&buf, 0, sizeof(buf));
  sub_10002418C(&buf, "BT Stuck on ");
  if (os_log_type_enabled((os_log_t)qword_1008F7700, OS_LOG_TYPE_ERROR)) {
    sub_10067BDB4();
  }
  dispatch_time_t v8 = *(void **)(a1 + 32);
  if (v8 != (void *)(a1 + 40))
  {
    do
    {
      __int128 v9 = (dispatch_queue_s *)v8[4];
      uint64_t v10 = (os_log_s *)qword_1008F7700;
      if (os_log_type_enabled((os_log_t)qword_1008F7700, OS_LOG_TYPE_ERROR)) {
        sub_10067BD4C(v24, v9, &v25, v10);
      }
      unint64_t v11 = dispatch_queue_get_label(v9);
      std::string::append(&buf, v11);
      std::string::append(&buf, " ");
      xpc_object_t v12 = (void *)v8[1];
      if (v12)
      {
        do
        {
          int v13 = v12;
          xpc_object_t v12 = (void *)*v12;
        }

        while (v12);
      }

      else
      {
        do
        {
          int v13 = (void *)v8[2];
          BOOL v6 = *v13 == (void)v8;
          dispatch_time_t v8 = v13;
        }

        while (!v6);
      }

      dispatch_time_t v8 = v13;
    }

    while (v13 != (void *)(a1 + 40));
  }

  if ((buf.__r_.__value_.__s.__size_ & 0x80u) == 0) {
    p_std::string buf = &buf;
  }
  else {
    p_std::string buf = (std::string *)buf.__r_.__value_.__r.__words[0];
  }
  WriteStackshotReport_stdc(p_buf, 3735936685LL);
  if (qword_1008D9060 != -1) {
    dispatch_once(&qword_1008D9060, &stru_1008969C8);
  }
  uint64_t v15 = qword_1008D9058;
  sub_10002418C(v22, "DispatcherWatchdog");
  if ((buf.__r_.__value_.__s.__size_ & 0x80u) == 0) {
    uint64_t v16 = &buf;
  }
  else {
    uint64_t v16 = (std::string *)buf.__r_.__value_.__r.__words[0];
  }
  sub_10002418C(__p, (char *)v16);
  sub_10040C784(0.0, v15, (uint64_t *)v22, (uint64_t *)__p);
  if (v21 < 0) {
    operator delete(__p[0]);
  }
  if (v23 < 0) {
    operator delete(v22[0]);
  }
  if (qword_1008F0AB0 != -1) {
    dispatch_once(&qword_1008F0AB0, &stru_100896950);
  }
  if (byte_1008F0AA8)
  {
    sub_1001EE2A0();
    __int16 v18 = &buf;
    if ((buf.__r_.__value_.__s.__size_ & 0x80u) != 0) {
      __int16 v18 = (std::string *)buf.__r_.__value_.__r.__words[0];
    }
    qword_1008D9DB8 = (uint64_t)v18;
    uint64_t v19 = sub_1002E6E00();
    sub_1004FC118(v19, 0);
  }

  __int128 v17 = (os_log_s *)qword_1008F7700;
  if (os_log_type_enabled((os_log_t)qword_1008F7700, OS_LOG_TYPE_FAULT)) {
    sub_10067BCD0((char *)&buf.__r_.__value_.__s.__size_, &buf, v17);
  }
}

void sub_100406048( _Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, void *__p, uint64_t a12, int a13, __int16 a14, char a15, char a16, void *a17, uint64_t a18, int a19, __int16 a20, char a21, char a22, uint64_t a23, uint64_t a24, void *a25, uint64_t a26, int a27, __int16 a28, char a29, char a30)
{
  if (a16 < 0) {
    operator delete(__p);
  }
  if (a22 < 0) {
    operator delete(a17);
  }
  if (a30 < 0) {
    operator delete(a25);
  }
  _Unwind_Resume(exception_object);
}

void sub_1004060A4(id a1)
{
  uint64_t v1 = sub_1002E6E00();
  sub_10002418C(v4, "DispatcherWatchdog");
  sub_10002418C(__p, "enableCrash");
  (*(void (**)(uint64_t, void **, void **, char *))(*(void *)v1 + 72LL))(v1, v4, __p, &byte_1008F0AA8);
  if (v3 < 0) {
    operator delete(__p[0]);
  }
  if (v5 < 0) {
    operator delete(v4[0]);
  }
}

void sub_10040612C( _Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, void *__p, uint64_t a10, int a11, __int16 a12, char a13, char a14, void *a15, uint64_t a16, int a17, __int16 a18, char a19, char a20)
{
  if (a14 < 0) {
    operator delete(__p);
  }
  if (a20 < 0) {
    operator delete(a15);
  }
  _Unwind_Resume(exception_object);
}

void sub_100406160(uint64_t a1)
{
  __int128 v1 = *(_OWORD *)(a1 + 32);
  uint64_t v2 = **(dispatch_queue_s ***)(a1 + 32);
  v3[0] = _NSConcreteStackBlock;
  v3[1] = 3221225472LL;
  v3[2] = sub_1004061BC;
  v3[3] = &unk_10087F8E0;
  __int128 v4 = v1;
  dispatch_async(v2, v3);
}

uint64_t sub_1004061BC(uint64_t a1)
{
  uint64_t v2 = *(void *)(a1 + 32);
  if (os_log_type_enabled((os_log_t)qword_1008F7700, OS_LOG_TYPE_DEBUG)) {
    sub_10067BE0C(a1);
  }
  ++*(void *)(v2 + 56);
  return sub_10020166C(v2 + 32, (unint64_t *)(a1 + 40));
}

void sub_100406228(uint64_t a1)
{
}

void sub_100406230(uint64_t a1)
{
  if (os_log_type_enabled((os_log_t)qword_1008F7700, OS_LOG_TYPE_DEBUG)) {
    sub_10067BE80();
  }
  if (*(void *)(a1 + 56) != *(void *)(a1 + 24)) {
    sub_100405CE0(a1);
  }
  uint64_t v2 = *(dispatch_queue_s **)a1;
  block[0] = _NSConcreteStackBlock;
  block[1] = 3221225472LL;
  block[2] = sub_1004062D8;
  block[3] = &unk_10087EB20;
  block[4] = a1;
  dispatch_async(v2, block);
}

uint64_t sub_1004062D8(uint64_t a1)
{
  uint64_t v1 = *(void *)(a1 + 32);
  if (os_log_type_enabled((os_log_t)qword_1008F7700, OS_LOG_TYPE_DEBUG)) {
    sub_10067BEAC();
  }
  *(void *)(v1 + 56) = 0LL;
  sub_1004063E0((uint64_t **)(v1 + 32), *(void **)(v1 + 8), (void *)(v1 + 16));
  return sub_100405B5C(v1);
}

void sub_100406338(id a1)
{
  uint64_t v1 = operator new(0x40uLL);
  qword_1008D9870 = (uint64_t)sub_100405A78(v1);
}

void sub_10040635C(void *a1, void *a2)
{
  char v3 = (std::__shared_weak_count *)a2[1];
  *a1 = *a2;
  if (!v3)
  {
    a1[1] = 0LL;
    goto LABEL_5;
  }

  __int128 v4 = std::__shared_weak_count::lock(v3);
  a1[1] = v4;
  if (!v4)
  {
LABEL_5:
    sub_10040639C();
    sub_10040639C();
  }

void sub_10040639C()
{
}

void sub_1004063B0(id a1)
{
  uint64_t v1 = operator new(0x18uLL);
  *(void *)uint64_t v1 = 0LL;
  v1[2] = 0;
  *((_BYTE *)v1 + 12) = 0;
  v1[4] = 0;
  qword_1008D9058 = (uint64_t)v1;
}

uint64_t **sub_1004063E0(uint64_t **result, void *a2, void *a3)
{
  char v5 = result;
  if (result[2])
  {
    BOOL v6 = *result;
    BOOL v7 = result[1];
    *uint64_t result = (uint64_t *)(result + 1);
    v7[2] = 0LL;
    result[1] = 0LL;
    result[2] = 0LL;
    if (v6[1]) {
      dispatch_time_t v8 = (uint64_t *)v6[1];
    }
    else {
      dispatch_time_t v8 = v6;
    }
    unint64_t v14 = result;
    uint64_t v15 = v8;
    uint64_t v16 = v8;
    if (v8)
    {
      uint64_t v15 = sub_10026145C((uint64_t)v8);
      if (a2 != a3)
      {
        __int128 v9 = a2;
        do
        {
          v8[4] = v9[4];
          sub_10026EB6C(v5, v8);
          dispatch_time_t v8 = v15;
          uint64_t v16 = v15;
          if (v15) {
            uint64_t v15 = sub_10026145C((uint64_t)v15);
          }
          uint64_t v10 = (void *)v9[1];
          if (v10)
          {
            do
            {
              a2 = v10;
              uint64_t v10 = (void *)*v10;
            }

            while (v10);
          }

          else
          {
            do
            {
              a2 = (void *)v9[2];
              BOOL v11 = *a2 == (void)v9;
              __int128 v9 = a2;
            }

            while (!v11);
          }

          if (!v8) {
            break;
          }
          __int128 v9 = a2;
        }

        while (a2 != a3);
      }
    }

    uint64_t result = (uint64_t **)sub_1002614B0((uint64_t)&v14);
  }

  if (a2 != a3)
  {
    do
    {
      uint64_t result = (uint64_t **)sub_10026EBD8(v5, a2 + 4);
      xpc_object_t v12 = (void *)a2[1];
      if (v12)
      {
        do
        {
          int v13 = v12;
          xpc_object_t v12 = (void *)*v12;
        }

        while (v12);
      }

      else
      {
        do
        {
          int v13 = (void *)a2[2];
          BOOL v11 = *v13 == (void)a2;
          a2 = v13;
        }

        while (!v11);
      }

      a2 = v13;
    }

    while (v13 != a3);
  }

  return result;
}

void sub_10040652C(_Unwind_Exception *a1, uint64_t a2, ...)
{
}

void sub_100406540( void *a1, uint64_t a2, uint64_t a3, const char *a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint8_t a9)
{
}

uint64_t sub_100406554(uint64_t a1, uint64_t a2)
{
  uint64_t v3 = a1;
  v7[0] = 0LL;
  v7[1] = 0LL;
  sub_100242F28((uint64_t)v7, a1 + 96);
  if (a2)
  {
    char v5 = *(void **)(v3 + 160);
    __int128 v4 = *(void **)(v3 + 168);
    if (v5 != v4)
    {
      while (*v5 != a2)
      {
        if (++v5 == v4)
        {
          char v5 = *(void **)(v3 + 168);
          break;
        }
      }
    }

    if (v5 == v4) {
      uint64_t v3 = 0LL;
    }
  }

  else
  {
    uint64_t v3 = 0LL;
  }

  sub_100242FAC((uint64_t)v7);
  return v3;
}

unint64_t sub_1004065D4(void *a1, unint64_t a2)
{
  v22[0] = 0LL;
  v22[1] = 0LL;
  sub_100242F28((uint64_t)v22, (uint64_t)(a1 + 12));
  if (!a2) {
    goto LABEL_12;
  }
  if (qword_1008D61A8 != -1) {
    dispatch_once(&qword_1008D61A8, &stru_100896D08);
  }
  unint64_t v4 = sub_10049729C(qword_1008D61A0, a2);
  if (v4)
  {
    char v5 = (unint64_t *)a1[20];
    if (v5 == (unint64_t *)a1[21])
    {
LABEL_14:
      if (qword_1008D61A8 != -1) {
        dispatch_once(&qword_1008D61A8, &stru_100896D08);
      }
      unint64_t v6 = sub_100496E90(qword_1008D61A0, v4);
      if (v6)
      {
        unint64_t v8 = a1[22];
        __int128 v9 = (unint64_t *)a1[21];
        if ((unint64_t)v9 >= v8)
        {
          uint64_t v11 = a1[20];
          uint64_t v12 = ((uint64_t)v9 - v11) >> 3;
          uint64_t v13 = v8 - v11;
          uint64_t v14 = v13 >> 2;
          else {
            unint64_t v15 = v14;
          }
          if (v15) {
            uint64_t v16 = (char *)sub_100008BA0((uint64_t)(a1 + 22), v15);
          }
          else {
            uint64_t v16 = 0LL;
          }
          __int128 v17 = (unint64_t *)&v16[8 * v12];
          __int16 v18 = &v16[8 * v15];
          *__int128 v17 = v6;
          uint64_t v10 = v17 + 1;
          uint64_t v20 = (char *)a1[20];
          uint64_t v19 = (char *)a1[21];
          if (v19 != v20)
          {
            do
            {
              unint64_t v21 = *((void *)v19 - 1);
              v19 -= 8;
              *--__int128 v17 = v21;
            }

            while (v19 != v20);
            uint64_t v19 = (char *)a1[20];
          }

          a1[20] = v17;
          a1[21] = v10;
          a1[22] = v18;
          if (v19) {
            operator delete(v19);
          }
        }

        else
        {
          *__int128 v9 = v6;
          uint64_t v10 = v9 + 1;
        }

        a1[21] = v10;
      }
    }

    else
    {
      while (1)
      {
        unint64_t v6 = *v5;
        if (*v5 == a2) {
          break;
        }
        if (qword_1008D61A8 != -1) {
          dispatch_once(&qword_1008D61A8, &stru_100896D08);
        }
        if (sub_10049729C(qword_1008D61A0, v6) == v4) {
          goto LABEL_13;
        }
      }

      unint64_t v6 = a2;
    }
  }

  else
  {
LABEL_12:
    unint64_t v6 = 0LL;
  }

void sub_1004067E0( _Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9)
{
}

uint64_t sub_100406804(void *a1, uint64_t a2)
{
  v39[0] = 0LL;
  v39[1] = 0LL;
  sub_100242F28((uint64_t)v39, (uint64_t)(a1 + 12));
  std::string __p = 0LL;
  int v37 = 0LL;
  v38 = 0LL;
  unint64_t v4 = (unint64_t *)a1[20];
  while (v4 != (unint64_t *)a1[21])
  {
    unint64_t v5 = *v4;
    if (qword_1008D61A8 != -1) {
      dispatch_once(&qword_1008D61A8, &stru_100896D08);
    }
    if (sub_10049729C(qword_1008D61A0, v5) == a2)
    {
      unint64_t v6 = (unint64_t *)a1[21];
      int64_t v7 = (char *)v6 - (char *)(v4 + 1);
      if (v6 != v4 + 1) {
        memmove(v4, v4 + 1, (char *)v6 - (char *)(v4 + 1));
      }
      a1[21] = (char *)v4 + v7;
      unint64_t v8 = v37;
      if (v37 >= v38)
      {
        uint64_t v10 = ((char *)v37 - (_BYTE *)__p) >> 3;
        unint64_t v11 = ((char *)v38 - (_BYTE *)__p) >> 2;
        if (v11 <= v10 + 1) {
          unint64_t v11 = v10 + 1;
        }
        else {
          unint64_t v12 = v11;
        }
        if (v12) {
          uint64_t v13 = (char *)sub_100008BA0((uint64_t)&v38, v12);
        }
        else {
          uint64_t v13 = 0LL;
        }
        uint64_t v14 = (unint64_t *)&v13[8 * v10];
        *uint64_t v14 = v5;
        __int128 v9 = v14 + 1;
        uint64_t v16 = (char *)__p;
        unint64_t v15 = (char *)v37;
        if (v37 != __p)
        {
          do
          {
            unint64_t v17 = *((void *)v15 - 1);
            v15 -= 8;
            *--uint64_t v14 = v17;
          }

          while (v15 != v16);
          unint64_t v15 = (char *)__p;
        }

        std::string __p = v14;
        int v37 = v9;
        v38 = (unint64_t *)&v13[8 * v12];
        if (v15) {
          operator delete(v15);
        }
      }

      else
      {
        *int v37 = v5;
        __int128 v9 = v8 + 1;
      }

      int v37 = v9;
    }

    else
    {
      ++v4;
    }
  }

  sub_100242F54((uint64_t)v39);
  v35[0] = 0LL;
  v35[1] = 0LL;
  sub_100242F28((uint64_t)v35, (uint64_t)(a1 + 23));
  __int16 v18 = (unint64_t *)__p;
  uint64_t v19 = (void *)&unk_1008D6000;
  if (__p != v37)
  {
    char v20 = 0;
    unint64_t v21 = a1 + 80;
    int v22 = a1 + 83;
    do
    {
      unint64_t v23 = *v18;
      for (unsigned int i = (void *)a1[32]; i != a1 + 31; unsigned int i = (void *)*v25)
      {
        uint64_t v33 = (void *)i[2];
        if (*v33 == v23)
        {
          sub_100406D0C((uint64_t)(a1 + 31), &v33);
          uint64_t v26 = v33;
          if (v33)
          {
            v33[2] = 0LL;
            free((void *)v26[1]);
            v26[1] = 0LL;
            v26[4] = 0LL;
            free((void *)v26[3]);
            operator delete(v26);
          }

          char v20 = 1;
          __int16 v25 = a1 + 32;
        }

        else
        {
          __int16 v25 = i + 1;
        }
      }

      uint64_t v33 = 0LL;
      uint64_t v34 = 0LL;
      sub_100242F28((uint64_t)&v33, (uint64_t)(a1 + 72));
      __int16 v27 = a1 + 80;
      if ((void *)a1[81] != v21)
      {
        __int16 v27 = (void *)a1[81];
        while (v27[2] != v23)
        {
          __int16 v27 = (void *)v27[1];
          if (v27 == v21)
          {
            __int16 v27 = a1 + 80;
            break;
          }
        }
      }

      sub_100242F54((uint64_t)&v33);
      if (v27 != v21) {
        sub_100406DD8(a1, v23, 0);
      }
      sub_100242ECC((uint64_t)&v33);
      char v28 = a1 + 83;
      if ((void *)a1[84] != v22)
      {
        char v28 = (void *)a1[84];
        while (v28[2] != v23)
        {
          char v28 = (void *)v28[1];
          if (v28 == v22)
          {
            char v28 = a1 + 83;
            break;
          }
        }
      }

      sub_100242F54((uint64_t)&v33);
      if (v28 != v22) {
        sub_100407008(a1, v23, 0);
      }
      sub_100242FAC((uint64_t)&v33);
      ++v18;
    }

    while (v18 != v37);
    uint64_t v19 = &unk_1008D6000;
    if ((v20 & 1) != 0)
    {
      if (qword_1008D60B0 != -1) {
        dispatch_once(&qword_1008D60B0, &stru_100896D28);
      }
      sub_100432F34((uint64_t)off_1008D60A8);
      if (qword_1008D60D0 != -1) {
        dispatch_once(&qword_1008D60D0, &stru_100896D48);
      }
      sub_1000A86F0();
    }
  }

  sub_100242F54((uint64_t)v35);
  char v29 = (unint64_t *)__p;
  if (__p != v37)
  {
    do
    {
      unint64_t v30 = *v29;
      uint64_t v33 = 0LL;
      uint64_t v34 = 0LL;
      sub_100242F28((uint64_t)&v33, (uint64_t)(a1 + 52));
      uint64_t v31 = sub_10040BE38(a1[60], a1[61], v30);
      sub_10040BDF4((uint64_t)(a1 + 60), v31, a1[61]);
      sub_100242F54((uint64_t)&v33);
      sub_100407238((uint64_t)a1, v30);
      sub_100407238((uint64_t)a1, v30);
      if (qword_1008D61A8 != -1) {
        dispatch_once(&qword_1008D61A8, &stru_100896D08);
      }
      sub_100497354(v19[52], v30);
      if (qword_1008D61A8 != -1) {
        dispatch_once(&qword_1008D61A8, &stru_100896D08);
      }
      sub_10049780C(v19[52], v30);
      sub_100242FAC((uint64_t)&v33);
      ++v29;
    }

    while (v29 != v37);
  }

  sub_100242FAC((uint64_t)v35);
  if (__p)
  {
    int v37 = (unint64_t *)__p;
    operator delete(__p);
  }

  return sub_100242FAC((uint64_t)v39);
}

void sub_100406CAC( _Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, char a10, uint64_t a11, char a12, uint64_t a13, void *__p, uint64_t a15, uint64_t a16, char a17)
{
  if (__p) {
    operator delete(__p);
  }
  sub_100242FAC((uint64_t)&a17);
  _Unwind_Resume(a1);
}

void *sub_100406D0C(uint64_t a1, void *a2)
{
  v10[0] = (uint64_t)v10;
  v10[1] = (uint64_t)v10;
  void v10[2] = 0LL;
  uint64_t v2 = *(void **)(a1 + 8);
  if (v2 != (void *)a1)
  {
    do
    {
      unint64_t v6 = (void *)v2[1];
      uint64_t v5 = v2[2];
      if (v5 == *a2)
      {
        if (v6 == (void *)a1)
        {
          BOOL v8 = 1;
LABEL_8:
          unint64_t v6 = (void *)a1;
        }

        else
        {
          while (1)
          {
            uint64_t v7 = v6[2];
            BOOL v8 = v7 == v5;
            if (v7 != v5) {
              break;
            }
            unint64_t v6 = (void *)v6[1];
            if (v6 == (void *)a1) {
              goto LABEL_8;
            }
          }
        }

        sub_10040BD38((uint64_t)v10, v10, a1, v2, v6);
        if (!v8) {
          unint64_t v6 = (void *)v6[1];
        }
      }

      uint64_t v2 = v6;
    }

    while (v6 != (void *)a1);
  }

  return sub_10023DF50(v10);
}

void sub_100406DC4(_Unwind_Exception *a1, uint64_t a2, ...)
{
}

uint64_t sub_100406DD8(void *a1, unint64_t a2, int a3)
{
  v18[1] = 0LL;
  unint64_t v19 = a2;
  v18[0] = 0LL;
  sub_100242F28((uint64_t)v18, (uint64_t)(a1 + 72));
  unint64_t v6 = a1 + 80;
  if (a3)
  {
    for (unsigned int i = (void *)a1[81]; i != v6; unsigned int i = (void *)i[1])
    {
      if (i[2] == a2)
      {
        if (i != v6) {
          goto LABEL_9;
        }
        break;
      }
    }

    BOOL v8 = operator new(0x18uLL);
    v8[1] = v6;
    v8[2] = a2;
    uint64_t v9 = a1[80];
    *BOOL v8 = v9;
    *(void *)(v9 + _Block_object_dispose(va, 8) = v8;
    a1[80] = v8;
    ++a1[82];
  }

  else
  {
    sub_100409850((uint64_t)(a1 + 80), &v19);
  }

void sub_100406FE4(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, ...)
{
}

uint64_t sub_100407008(void *a1, unint64_t a2, int a3)
{
  v18[1] = 0LL;
  unint64_t v19 = a2;
  v18[0] = 0LL;
  sub_100242F28((uint64_t)v18, (uint64_t)(a1 + 72));
  unint64_t v6 = a1 + 83;
  if (a3)
  {
    for (unsigned int i = (void *)a1[84]; i != v6; unsigned int i = (void *)i[1])
    {
      if (i[2] == a2)
      {
        if (i != v6) {
          goto LABEL_9;
        }
        break;
      }
    }

    BOOL v8 = operator new(0x18uLL);
    v8[1] = v6;
    v8[2] = a2;
    uint64_t v9 = a1[83];
    *BOOL v8 = v9;
    *(void *)(v9 + _Block_object_dispose(va, 8) = v8;
    a1[83] = v8;
    ++a1[85];
  }

  else
  {
    sub_100409850((uint64_t)(a1 + 83), &v19);
  }

void sub_100407214(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, ...)
{
}

uint64_t sub_100407238(uint64_t a1, uint64_t a2)
{
  v7[0] = 0LL;
  v7[1] = 0LL;
  sub_100242F28((uint64_t)v7, a1 + 504);
  unint64_t v4 = *(void **)(a1 + 568);
  if (v4 && *v4 == a2)
  {
    operator delete(v4);
    uint64_t v5 = 0LL;
    *(void *)(a1 + 56_Block_object_dispose(va, 8) = 0LL;
  }

  else
  {
    uint64_t v5 = 7LL;
  }

  sub_100242FAC((uint64_t)v7);
  return v5;
}

uint64_t sub_1004072A4(uint64_t a1, uint64_t a2)
{
  return sub_100406804((void *)(a1 - 24), a2);
}

uint64_t sub_1004072AC(uint64_t a1)
{
  *(void *)a1 = off_1008969F8;
  *(void *)(a1 + _Block_object_dispose(va, 8) = off_100896AA0;
  *(void *)(a1 + 16) = off_100896AC8;
  *(void *)(a1 + 24) = off_100896B08;
  *(void *)(a1 + 32) = &off_100896B28;
  *(void *)(a1 + 40) = off_100896B40;
  *(void *)(a1 + 4_Block_object_dispose(va, 8) = off_100896B68;
  *(void *)(a1 + 56) = off_100896C18;
  *(_DWORD *)(a1 + 64) = 0;
  *(void *)(a1 + 72) = 0LL;
  *(void *)(a1 + 80) = 0LL;
  *(void *)(a1 + 8_Block_object_dispose(va, 8) = 0LL;
  sub_100242DC4(a1 + 96);
  *(void *)(a1 + 160) = 0LL;
  *(void *)(a1 + 16_Block_object_dispose(va, 8) = 0LL;
  *(void *)(a1 + 176) = 0LL;
  sub_100242DC4(a1 + 184);
  *(void *)(a1 + 24_Block_object_dispose(va, 8) = a1 + 248;
  *(void *)(a1 + 256) = a1 + 248;
  *(void *)(a1 + 264) = 0LL;
  *(_BYTE *)(a1 + 272) = 0;
  sub_100242DC4(a1 + 280);
  *(void *)(a1 + 40_Block_object_dispose(va, 8) = 0LL;
  *(_OWORD *)(a1 + 376) = 0u;
  *(_OWORD *)(a1 + 392) = 0u;
  *(_OWORD *)(a1 + 344) = 0u;
  *(_OWORD *)(a1 + 360) = 0u;
  sub_100242DC4(a1 + 416);
  *(void *)(a1 + 480) = 0LL;
  *(void *)(a1 + 48_Block_object_dispose(va, 8) = 0LL;
  *(void *)(a1 + 496) = 0LL;
  sub_100242DC4(a1 + 504);
  *(void *)(a1 + 56_Block_object_dispose(va, 8) = 0LL;
  sub_100242DC4(a1 + 576);
  *(void *)(a1 + 640) = a1 + 640;
  *(void *)(a1 + 64_Block_object_dispose(va, 8) = a1 + 640;
  *(void *)(a1 + 656) = 0LL;
  *(void *)(a1 + 664) = a1 + 664;
  *(void *)(a1 + 672) = a1 + 664;
  *(void *)(a1 + 680) = 0LL;
  return a1;
}

void sub_1004073D0(_Unwind_Exception *a1)
{
  uint64_t v11 = v5;
  sub_100242E28(v11);
  uint64_t v13 = *(void **)(v1 + 480);
  if (v13)
  {
    *(void *)(v1 + 48_Block_object_dispose(va, 8) = v13;
    operator delete(v13);
  }

  sub_100242E28(v7);
  sub_100242E28(v6);
  sub_10023DF50(v4);
  sub_100242E28(v3);
  uint64_t v14 = *v9;
  if (*v9)
  {
    *(void *)(v1 + 16_Block_object_dispose(va, 8) = v14;
    operator delete(v14);
  }

  sub_100242E28(v2);
  unint64_t v15 = *v8;
  if (*v8)
  {
    *(void *)(v1 + 80) = v15;
    operator delete(v15);
  }

  _Unwind_Resume(a1);
}

void sub_100407494()
{
}

uint64_t sub_1004074A0(uint64_t a1)
{
  *(void *)a1 = off_1008969F8;
  *(void *)(a1 + _Block_object_dispose(va, 8) = off_100896AA0;
  *(void *)(a1 + 16) = off_100896AC8;
  *(void *)(a1 + 24) = off_100896B08;
  *(void *)(a1 + 32) = &off_100896B28;
  *(void *)(a1 + 40) = off_100896B40;
  *(void *)(a1 + 4_Block_object_dispose(va, 8) = off_100896B68;
  *(void *)(a1 + 56) = off_100896C18;
  sub_10023DF50((void *)(a1 + 664));
  sub_10023DF50((void *)(a1 + 640));
  sub_100242E28(a1 + 576);
  sub_100242E28(a1 + 504);
  uint64_t v2 = *(void **)(a1 + 480);
  if (v2)
  {
    *(void *)(a1 + 48_Block_object_dispose(va, 8) = v2;
    operator delete(v2);
  }

  sub_100242E28(a1 + 416);
  sub_100242E28(a1 + 280);
  sub_10023DF50((void *)(a1 + 248));
  sub_100242E28(a1 + 184);
  uint64_t v3 = *(void **)(a1 + 160);
  if (v3)
  {
    *(void *)(a1 + 16_Block_object_dispose(va, 8) = v3;
    operator delete(v3);
  }

  sub_100242E28(a1 + 96);
  unint64_t v4 = *(void **)(a1 + 72);
  if (v4)
  {
    *(void *)(a1 + 80) = v4;
    operator delete(v4);
  }

  return a1;
}

uint64_t sub_1004075A0(uint64_t a1)
{
  return sub_1004074A0(a1 - 16);
}

void sub_1004075A8(uint64_t a1)
{
  uint64_t v1 = (void *)sub_1004074A0(a1);
  operator delete(v1);
}

void sub_1004075BC(uint64_t a1)
{
  uint64_t v1 = (void *)sub_1004074A0(a1 - 16);
  operator delete(v1);
}

uint64_t sub_1004075D4(uint64_t a1)
{
  if (qword_1008D61A8 != -1) {
    dispatch_once(&qword_1008D61A8, &stru_100896D08);
  }
  sub_1003B423C(qword_1008D61A0 + 8, a1 + 24);
  if (qword_1008D67E8 != -1) {
    dispatch_once(&qword_1008D67E8, &stru_100896D68);
  }
  sub_1000762CC((uint64_t)off_1008D67E0 + 24, a1 + 8);
  if (qword_1008D67A8 != -1) {
    dispatch_once(&qword_1008D67A8, &stru_100896D88);
  }
  sub_10052AB64(off_1008D67A0, a1 + 16);
  if (qword_1008D6788 != -1) {
    dispatch_once(&qword_1008D6788, &stru_100896DA8);
  }
  sub_10024DD9C((uint64_t)off_1008D6780 + 80, a1 + 32);
  if (qword_1008D6288 != -1) {
    dispatch_once(&qword_1008D6288, &stru_100896DC8);
  }
  sub_100572580((uint64_t)off_1008D6280, a1 + 40);
  if (qword_1008D5F10 != -1) {
    dispatch_once(&qword_1008D5F10, &stru_100896DE8);
  }
  sub_100594810((uint64_t)off_1008D5F08, a1 + 48, 0);
  uint64_t v2 = sub_1002E8D54();
  sub_1003FDB08(v2 + 328, a1 + 56);
  v10[0] = 0LL;
  v10[1] = 0LL;
  sub_100242F28((uint64_t)v10, a1 + 280);
  uint64_t v3 = sub_1002E6BF0();
  unint64_t v4 = (const char *)(a1 + 344);
  uint64_t v5 = sub_1002E6BF0();
  uint64_t v6 = (void *)(a1 + 368);
  uint64_t v7 = (void *)(a1 + 392);
  std::string::assign((std::string *)(a1 + 392), "Apple Inc.");
  BOOL v8 = (os_log_s *)qword_1008F7578;
  if (os_log_type_enabled((os_log_t)qword_1008F7578, OS_LOG_TYPE_DEFAULT))
  {
    *(_DWORD *)std::string buf = 136446722;
    unint64_t v12 = v4;
    __int16 v13 = 2082;
    uint64_t v14 = v6;
    __int16 v15 = 2082;
    uint64_t v16 = v7;
    _os_log_impl( (void *)&_mh_execute_header,  v8,  OS_LOG_TYPE_DEFAULT,  "Model: %{public}s, Version: %{public}s, Manufacturer: %{public}s",  buf,  0x20u);
    BOOL v8 = (os_log_s *)qword_1008F7578;
  }

  if (os_log_type_enabled(v8, OS_LOG_TYPE_DEFAULT))
  {
    *(_DWORD *)std::string buf = 136446210;
    unint64_t v12 = "/Library/Caches/com.apple.xbs/Sources/MobileBluetooth_base/Server/core/LocalDevice.mm";
    _os_log_impl((void *)&_mh_execute_header, v8, OS_LOG_TYPE_DEFAULT, "%{public}s", buf, 0xCu);
  }

  return sub_100242FAC((uint64_t)v10);
}

void sub_100407904(_Unwind_Exception *exception_object)
{
}

uint64_t sub_100407920(uint64_t a1)
{
  if (qword_1008D61A8 != -1) {
    dispatch_once(&qword_1008D61A8, &stru_100896D08);
  }
  sub_100009168(qword_1008D61A0 + 8, a1 + 24);
  if (qword_1008D67E8 != -1) {
    dispatch_once(&qword_1008D67E8, &stru_100896D68);
  }
  sub_100009168((uint64_t)off_1008D67E0 + 24, a1 + 8);
  if (qword_1008D67A8 != -1) {
    dispatch_once(&qword_1008D67A8, &stru_100896D88);
  }
  sub_10052AC9C((uint64_t)off_1008D67A0, a1 + 16);
  if (qword_1008D6788 != -1) {
    dispatch_once(&qword_1008D6788, &stru_100896DA8);
  }
  sub_100009168((uint64_t)off_1008D6780 + 80, a1 + 32);
  if (qword_1008D6288 != -1) {
    dispatch_once(&qword_1008D6288, &stru_100896DC8);
  }
  sub_1005725E8((uint64_t)off_1008D6280, a1 + 40);
  if (qword_1008D5F10 != -1) {
    dispatch_once(&qword_1008D5F10, &stru_100896DE8);
  }
  sub_100594914((uint64_t)off_1008D5F08, a1 + 48);
  uint64_t v2 = sub_1002E8D54();
  sub_10024E060(v2 + 328, a1 + 56);
  sub_100407B88(v3, 0);
  v7[0] = 0LL;
  v7[1] = 0LL;
  sub_100242F28((uint64_t)v7, a1 + 280);
  unint64_t v4 = *(unint64_t **)(a1 + 160);
  if (v4 != *(unint64_t **)(a1 + 168))
  {
    do
    {
      unint64_t v5 = *v4;
      if (qword_1008D61A8 != -1) {
        dispatch_once(&qword_1008D61A8, &stru_100896D08);
      }
      sub_100497354(qword_1008D61A0, v5);
      if (qword_1008D61A8 != -1) {
        dispatch_once(&qword_1008D61A8, &stru_100896D08);
      }
      sub_10049780C(qword_1008D61A0, v5);
      ++v4;
    }

    while (v4 != *(unint64_t **)(a1 + 168));
    unint64_t v4 = *(unint64_t **)(a1 + 160);
  }

  *(void *)(a1 + 16_Block_object_dispose(va, 8) = v4;
  return sub_100242FAC((uint64_t)v7);
}

void sub_100407B74( _Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9)
{
}

uint64_t sub_100407B88(uint64_t a1, char a2)
{
  if (qword_1008D6788 != -1) {
    dispatch_once(&qword_1008D6788, &stru_100896DA8);
  }
  return sub_10040D77C((uint64_t)off_1008D6780, a2);
}

uint64_t sub_100407BD8(uint64_t *a1, uint64_t a2, __int128 *a3, uint64_t a4)
{
  v15[0] = 0LL;
  v15[1] = 0LL;
  sub_100242F28((uint64_t)v15, (uint64_t)(a1 + 52));
  uint64_t v9 = (void *)a1[60];
  unint64_t v8 = a1[61];
  __int128 v21 = *a3;
  uint64_t v22 = *((void *)a3 + 2);
  if (v9 != (void *)v8)
  {
    while (1)
    {
      if (*v9 == a2)
      {
        BOOL v10 = (void)v21 == v9[1] && *((void *)&v21 + 1) == v9[2];
        if (v10 && v22 == v9[3]) {
          break;
        }
      }

      v9 += 6;
      if (v9 == (void *)v8) {
        goto LABEL_13;
      }
    }
  }

  if (v9 == (void *)v8)
  {
LABEL_13:
    __int128 v17 = *a3;
    uint64_t v18 = *((void *)a3 + 2);
    uint64_t v16 = a2;
    int v19 = -1;
    uint64_t v20 = a4;
    if (v8 >= a1[62])
    {
      uint64_t v13 = sub_10040C054(a1 + 60, (uint64_t)&v16);
    }

    else
    {
      *(void *)unint64_t v8 = a2;
      __int128 v12 = v17;
      *(void *)(v8 + 24) = v18;
      *(_OWORD *)(v8 + _Block_object_dispose(va, 8) = v12;
      *(_DWORD *)(v8 + 32) = -1;
      *(void *)(v8 + 40) = a4;
      uint64_t v13 = v8 + 48;
    }

    a1[61] = v13;
  }

  sub_100242FAC((uint64_t)v15);
  return 0LL;
}

void sub_100407CF0( _Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9)
{
}

uint64_t sub_100407D04(uint64_t a1, uint64_t a2, __int128 *a3)
{
  v10[0] = 0LL;
  v10[1] = 0LL;
  sub_100242F28((uint64_t)v10, a1 + 416);
  __int128 v12 = *a3;
  uint64_t v13 = *((void *)a3 + 2);
  uint64_t v6 = *(void *)(a1 + 480);
  uint64_t v7 = *(void *)(a1 + 488);
  uint64_t v11 = a2;
  uint64_t v8 = sub_10040C244(v6, v7, &v11);
  sub_10040BDF4(a1 + 480, v8, *(void *)(a1 + 488));
  sub_100242FAC((uint64_t)v10);
  return 0LL;
}

void sub_100407D84( _Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9)
{
}

uint64_t sub_100407D98(uint64_t a1, uint64_t a2, uint64_t *a3, uint64_t a4)
{
  v14[0] = 0LL;
  v14[1] = 0LL;
  sub_100242F28((uint64_t)v14, a1 + 504);
  if (*(void *)(a1 + 568))
  {
    uint64_t v8 = 101LL;
  }

  else
  {
    int v13 = 0;
    uint64_t v9 = sub_1002E6E9C();
    (*(void (**)(uint64_t, int *))(*(void *)v9 + 192LL))(v9, &v13);
    BOOL v10 = operator new(0x18uLL);
    uint64_t v8 = 0LL;
    uint64_t v11 = *a3;
    void *v10 = a2;
    v10[1] = v11;
    void v10[2] = a4;
    *(void *)(a1 + 56_Block_object_dispose(va, 8) = v10;
  }

  sub_100242FAC((uint64_t)v14);
  return v8;
}

void sub_100407E38(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, ...)
{
}

uint64_t sub_100407E4C(uint64_t a1, uint64_t a2, uint64_t a3)
{
  v10[0] = 0LL;
  v10[1] = 0LL;
  sub_100242F28((uint64_t)v10, a1 + 504);
  uint64_t v6 = *(void **)(a1 + 568);
  if (v6 && *v6 == a2)
  {
    uint64_t v8 = sub_1002E6E9C();
    uint64_t v7 = (*(uint64_t (**)(uint64_t, uint64_t))(*(void *)v8 + 192LL))(v8, a3);
  }

  else
  {
    uint64_t v7 = 7LL;
  }

  sub_100242FAC((uint64_t)v10);
  return v7;
}

void sub_100407ED0( _Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9)
{
}

uint64_t sub_100407EE4(uint64_t a1, uint64_t a2, uint64_t *a3, uint64_t a4)
{
  v12[0] = 0LL;
  v12[1] = 0LL;
  sub_100242F28((uint64_t)v12, a1 + 504);
  if (*(void *)(a1 + 568))
  {
    uint64_t v8 = 101LL;
  }

  else
  {
    uint64_t v9 = operator new(0x18uLL);
    uint64_t v8 = 0LL;
    uint64_t v10 = *a3;
    *uint64_t v9 = a2;
    v9[1] = v10;
    void v9[2] = a4;
    *(void *)(a1 + 56_Block_object_dispose(va, 8) = v9;
  }

  sub_100242FAC((uint64_t)v12);
  return v8;
}

void sub_100407F6C( _Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9)
{
}

uint64_t sub_100407F80(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7)
{
  v19[0] = 0LL;
  v19[1] = 0LL;
  sub_100242F28((uint64_t)v19, a1 + 504);
  uint64_t v14 = *(void **)(a1 + 568);
  if (v14 && *v14 == a2)
  {
    uint64_t v17 = sub_1002E8D54();
    if ((*(unsigned int (**)(uint64_t, uint64_t))(*(void *)v17 + 176LL))(v17, a3))
    {
      uint64_t v18 = sub_1002E6E9C();
      uint64_t v15 = (*(uint64_t (**)(uint64_t, uint64_t, uint64_t, uint64_t, uint64_t, uint64_t))(*(void *)v18 + 1152LL))( v18,  a3,  a4,  a5,  a6,  a7);
    }

    else
    {
      uint64_t v15 = 205LL;
    }
  }

  else
  {
    uint64_t v15 = 7LL;
  }

  sub_100242FAC((uint64_t)v19);
  return v15;
}

void sub_100408054( _Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9)
{
}

uint64_t sub_100408068(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  v17[0] = 0LL;
  v17[1] = 0LL;
  sub_100242F28((uint64_t)v17, a1 + 504);
  uint64_t v8 = (os_log_s *)qword_1008F7578;
  if (os_log_type_enabled((os_log_t)qword_1008F7578, OS_LOG_TYPE_DEFAULT))
  {
    *(_WORD *)uint64_t v16 = 0;
    _os_log_impl( (void *)&_mh_execute_header,  v8,  OS_LOG_TYPE_DEFAULT,  "(BTPowerLog): readEnhancedPowerProfileStatistics",  v16,  2u);
  }

  uint64_t v9 = *(void **)(a1 + 568);
  if (v9 && *v9 == a2)
  {
    uint64_t v13 = sub_1002E8D54();
    if ((*(unsigned int (**)(uint64_t, uint64_t))(*(void *)v13 + 176LL))(v13, a3))
    {
      uint64_t v14 = sub_1002E6E9C();
      uint64_t v11 = (*(uint64_t (**)(uint64_t, uint64_t, uint64_t))(*(void *)v14 + 1160LL))(v14, a3, a4);
    }

    else
    {
      uint64_t v15 = (os_log_s *)qword_1008F7578;
      if (os_log_type_enabled((os_log_t)qword_1008F7578, OS_LOG_TYPE_DEFAULT))
      {
        *(_WORD *)uint64_t v16 = 0;
        _os_log_impl( (void *)&_mh_execute_header,  v15,  OS_LOG_TYPE_DEFAULT,  "(BTPowerLog): (readEnhancedPowerProfileStatistics) can't read power profile stats: BT_ERROR_LOCAL_DEVICE_NOT_READY",  v16,  2u);
      }

      uint64_t v11 = 205LL;
    }
  }

  else
  {
    uint64_t v10 = (os_log_s *)qword_1008F7578;
    if (os_log_type_enabled((os_log_t)qword_1008F7578, OS_LOG_TYPE_DEFAULT))
    {
      *(_WORD *)uint64_t v16 = 0;
      _os_log_impl( (void *)&_mh_execute_header,  v10,  OS_LOG_TYPE_DEFAULT,  "(BTPowerLog): (readEnhancedPowerProfileStatistics) BT_ERROR_INVALID_HANDLE",  v16,  2u);
    }

    uint64_t v11 = 7LL;
  }

  sub_100242FAC((uint64_t)v17);
  return v11;
}

void sub_1004081D8(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, ...)
{
}

uint64_t sub_1004081EC(uint64_t a1, uint64_t a2, int a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7)
{
  v19[0] = 0LL;
  v19[1] = 0LL;
  sub_100242F28((uint64_t)v19, a1 + 504);
  uint64_t v14 = *(void **)(a1 + 568);
  if (v14 && *v14 == a2)
  {
    if (a3 == 1)
    {
      uint64_t v16 = sub_1002E6E9C();
      (*(void (**)(uint64_t))(*(void *)v16 + 1176LL))(v16);
    }

    uint64_t v17 = sub_1002E6E9C();
    uint64_t v15 = (*(uint64_t (**)(uint64_t, uint64_t, uint64_t, uint64_t, uint64_t))(*(void *)v17 + 1168LL))( v17,  a4,  a5,  a6,  a7);
  }

  else
  {
    uint64_t v15 = 7LL;
  }

  sub_100242FAC((uint64_t)v19);
  return v15;
}

void sub_1004082B4( _Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9)
{
}

uint64_t sub_1004082C8( uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17)
{
  v35[0] = 0LL;
  v35[1] = 0LL;
  sub_100242F28((uint64_t)v35, a1 + 504);
  __int16 v25 = (os_log_s *)qword_1008F7578;
  if (os_log_type_enabled((os_log_t)qword_1008F7578, OS_LOG_TYPE_DEFAULT))
  {
    *(_WORD *)std::string buf = 0;
    _os_log_impl( (void *)&_mh_execute_header,  v25,  OS_LOG_TYPE_DEFAULT,  "(BTPowerLog): readDetailedPowerProfileStatistics",  buf,  2u);
  }

  uint64_t v26 = *(void **)(a1 + 568);
  if (v26 && *v26 == a2)
  {
    uint64_t v30 = sub_1002E8D54();
    if ((*(unsigned int (**)(uint64_t, uint64_t))(*(void *)v30 + 176LL))(v30, a3))
    {
      uint64_t v31 = sub_1002E6E9C();
      uint64_t v28 = (*(uint64_t (**)(uint64_t, uint64_t, uint64_t, uint64_t, uint64_t, uint64_t, uint64_t, uint64_t, uint64_t, uint64_t, uint64_t, uint64_t, uint64_t, uint64_t, uint64_t))(*(void *)v31 + 1184LL))( v31,  a4,  a5,  a6,  a7,  a8,  a9,  a10,  a11,  a12,  a13,  a14,  a15,  a16,  a17);
      if ((_DWORD)a3)
      {
        uint64_t v32 = sub_1002E6E9C();
        (*(void (**)(uint64_t))(*(void *)v32 + 1192LL))(v32);
      }
    }

    else
    {
      uint64_t v33 = (os_log_s *)qword_1008F7578;
      if (os_log_type_enabled((os_log_t)qword_1008F7578, OS_LOG_TYPE_DEFAULT))
      {
        *(_WORD *)std::string buf = 0;
        _os_log_impl( (void *)&_mh_execute_header,  v33,  OS_LOG_TYPE_DEFAULT,  "(BTPowerLog): (readDetailedPowerProfileStatistics) can't read power profile stats: BT_ERROR_LOCAL_DEVICE_NOT_READY",  buf,  2u);
      }

      uint64_t v28 = 205LL;
    }
  }

  else
  {
    __int16 v27 = (os_log_s *)qword_1008F7578;
    if (os_log_type_enabled((os_log_t)qword_1008F7578, OS_LOG_TYPE_DEFAULT))
    {
      *(_WORD *)std::string buf = 0;
      _os_log_impl( (void *)&_mh_execute_header,  v27,  OS_LOG_TYPE_DEFAULT,  "(BTPowerLog): (readDetailedPowerProfileStatistics) BT_ERROR_INVALID_HANDLE",  buf,  2u);
    }

    uint64_t v28 = 7LL;
  }

  sub_100242FAC((uint64_t)v35);
  return v28;
}

void sub_10040849C( _Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, ...)
{
}

uint64_t sub_1004084B0(uint64_t a1, uint64_t a2, _WORD *a3)
{
  v10[0] = 0LL;
  v10[1] = 0LL;
  sub_100242F28((uint64_t)v10, a1 + 184);
  *(_BYTE *)(a2 + 35) = 0;
  *(_OWORD *)(a2 + 19) = 0u;
  *(_OWORD *)(a2 + 3) = 0u;
  *(_WORD *)a2 = 9218;
  *(_BYTE *)(a2 + 2) = 2;
  *(_BYTE *)(a2 + 3) = *(_BYTE *)(a1 + 272);
  uint64_t v6 = a1 + 248;
  uint64_t v7 = *(void *)(a1 + 256);
  if (v7 != v6)
  {
    uint64_t v8 = a2 + 4;
    do
    {
      sub_100404910(v8, 256LL, *(char **)(*(void *)(v7 + 16) + 8LL), *(void *)(*(void *)(v7 + 16) + 16LL));
      uint64_t v7 = *(void *)(v7 + 8);
    }

    while (v7 != v6);
  }

  *a3 = 36;
  sub_100242FAC((uint64_t)v10);
  return 1LL;
}

void sub_100408564( _Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9)
{
}

uint64_t sub_100408578(uint64_t a1, uint64_t a2, const void *a3, size_t a4, const void *a5, size_t a6)
{
  uint64_t v6 = 3LL;
  if (a6 && a4 && a3 && a5)
  {
    v27[0] = 0LL;
    v27[1] = 0LL;
    sub_100242F28((uint64_t)v27, a1 + 184);
    uint64_t v13 = a1 + 248;
    for (uint64_t i = *(void *)(a1 + 256); i != v13; uint64_t i = *(void *)(i + 8))
    {
      uint64_t v15 = *(void *)(i + 16);
      if (*(void *)(v15 + 16) >= a4) {
        size_t v16 = a4;
      }
      else {
        size_t v16 = *(void *)(v15 + 16);
      }
      if (!memcmp(*(const void **)(v15 + 8), a3, v16))
      {
        size_t v17 = *(void *)(v15 + 32) >= a6 ? a6 : *(void *)(v15 + 32);
      }
    }

    unint64_t v18 = *(void *)(a1 + 264);
    if (v18 >= 0x1F)
    {
      if (os_log_type_enabled((os_log_t)qword_1008F7578, OS_LOG_TYPE_ERROR)) {
        sub_10067BED8();
      }
LABEL_30:
      uint64_t v6 = 1LL;
      goto LABEL_31;
    }

    ++*(_BYTE *)(a1 + 272);
    int v19 = operator new(0x28uLL);
    void *v19 = a2;
    void v19[2] = a4;
    uint64_t v20 = malloc(a4);
    v19[1] = v20;
    memcpy(v20, a3, a4);
    v19[4] = a6;
    __int128 v21 = malloc(a6);
    v19[3] = v21;
    memcpy(v21, a5, a6);
    uint64_t v26 = v19;
    uint64_t v22 = operator new(0x18uLL);
    v22[1] = v13;
    void v22[2] = v19;
    uint64_t v23 = *(void *)(a1 + 248);
    void *v22 = v23;
    *(void *)(v23 + _Block_object_dispose(va, 8) = v22;
    *(void *)(a1 + 24_Block_object_dispose(va, 8) = v22;
    *(void *)(a1 + 264) = v18 + 1;
    if (qword_1008D60B0 != -1) {
      dispatch_once(&qword_1008D60B0, &stru_100896D28);
    }
    if (qword_1008D60D0 != -1) {
      dispatch_once(&qword_1008D60D0, &stru_100896D48);
    }
    if (sub_1000A86F0())
    {
LABEL_25:
      sub_100406D0C(v13, &v26);
      char v24 = v26;
      if (v26)
      {
        void v26[2] = 0LL;
        free((void *)v24[1]);
        v24[1] = 0LL;
        uint8_t v24[4] = 0LL;
        free((void *)v24[3]);
        operator delete(v24);
      }

      if (qword_1008D60B0 != -1) {
        dispatch_once(&qword_1008D60B0, &stru_100896D28);
      }
      sub_100432F34((uint64_t)off_1008D60A8);
      goto LABEL_30;
    }

    uint64_t v6 = 0LL;
LABEL_31:
    sub_100242FAC((uint64_t)v27);
  }

  return v6;
}

void sub_1004087DC(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, ...)
{
}

uint64_t sub_1004087F0(uint64_t a1, uint64_t a2, const void *a3, size_t a4, const void *a5, size_t a6)
{
  v17[0] = 0LL;
  v17[1] = 0LL;
  sub_100242F28((uint64_t)v17, a1 + 184);
  for (uint64_t i = *(void *)(a1 + 256); i != a1 + 248; uint64_t i = *(void *)(i + 8))
  {
    uint64_t v13 = *(void *)(i + 16);
    uint64_t v16 = v13;
    if (*(void *)v13 == a2
      && *(void *)(v13 + 16) == a4
      && !memcmp(*(const void **)(v13 + 8), a3, a4)
      && *(void *)(v13 + 32) == a6
      && !memcmp(*(const void **)(v13 + 24), a5, a6))
    {
      sub_100406D0C(a1 + 248, &v16);
      uint64_t v14 = v16;
      if (v16)
      {
        *(void *)(v16 + 16) = 0LL;
        free(*(void **)(v14 + 8));
        *(void *)(v14 + _Block_object_dispose(va, 8) = 0LL;
        *(void *)(v14 + 32) = 0LL;
        free(*(void **)(v14 + 24));
        operator delete((void *)v14);
      }

      break;
    }
  }

  ++*(_BYTE *)(a1 + 272);
  if (qword_1008D60B0 != -1) {
    dispatch_once(&qword_1008D60B0, &stru_100896D28);
  }
  if (sub_100432F34((uint64_t)off_1008D60A8)
    && os_log_type_enabled((os_log_t)qword_1008F7578, OS_LOG_TYPE_ERROR))
  {
    sub_10067BF30();
  }

  if (qword_1008D60D0 != -1) {
    dispatch_once(&qword_1008D60D0, &stru_100896D48);
  }
  sub_100242FAC((uint64_t)v17);
  return 0LL;
}

void sub_1004089CC(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, ...)
{
}

void sub_1004089E8(int a1, uint64_t a2, int a3, uint64_t a4)
{
  __int16 v13 = 0;
  int v12 = 0;
  __int16 v15 = 0;
  uint64_t v14 = 255LL;
  if (sub_10010EF78(a2, (uint64_t)&v12))
  {
    if (os_log_type_enabled((os_log_t)qword_1008F7578, OS_LOG_TYPE_ERROR)) {
      sub_10067BF88();
    }
  }

  else
  {
    if (qword_1008D5F50 != -1) {
      dispatch_once(&qword_1008D5F50, &stru_100896E08);
    }
    int v10 = v12;
    __int16 v11 = v13;
    uint64_t v7 = sub_1003FFEB0(off_1008D5F48, (uint64_t)&v10, 0);
    if (v7)
    {
      uint64_t v8 = (uint64_t)v7;
      if (a3)
      {
        uint64_t v14 = *(void *)a4;
        __int16 v15 = *(_WORD *)(a4 + 8);
      }

      if (qword_1008D5F00 != -1)
      {
        uint64_t v9 = (uint64_t)v7;
        dispatch_once(&qword_1008D5F00, &stru_100896E28);
        uint64_t v8 = v9;
      }

      sub_100408B70((uint64_t)off_1008D5EF8, a1, v8, &v14);
    }

    else if (os_log_type_enabled((os_log_t)qword_1008F7578, OS_LOG_TYPE_ERROR))
    {
      sub_10067BF5C();
    }
  }

uint64_t sub_100408B70(uint64_t a1, int a2, uint64_t a3, uint64_t *a4)
{
  v25[0] = 0LL;
  v25[1] = 0LL;
  sub_100242F28((uint64_t)v25, a1 + 416);
  uint64_t v8 = *(void *)(a1 + 480);
  uint64_t v9 = *(void *)(a1 + 488);
  if (v8 != v9)
  {
    uint64_t v22 = 0LL;
    uint64_t v23 = 0LL;
    uint64_t v24 = 0LL;
    sub_10040C458((char *)&v22, v8, v9, 0xAAAAAAAAAAAAAAABLL * ((v9 - v8) >> 4));
    sub_100242F54((uint64_t)v25);
    int v10 = (os_log_s *)qword_1008F7578;
    if (os_log_type_enabled((os_log_t)qword_1008F7578, OS_LOG_TYPE_DEFAULT))
    {
      *(_DWORD *)std::string buf = 68157954;
      int v27 = 10;
      __int16 v28 = 2096;
      char v29 = a4;
      _os_log_impl( (void *)&_mh_execute_header,  v10,  OS_LOG_TYPE_DEFAULT,  "Sending AFH map changed event to local device listeners %{AFHMap}.10P",  buf,  0x12u);
    }

    __int16 v11 = v22;
    if (v22 != v23)
    {
      while (1)
      {
        if (v11[3])
        {
          if (!a3) {
            goto LABEL_18;
          }
          if (qword_1008D5F50 != -1) {
            dispatch_once(&qword_1008D5F50, &stru_100896E08);
          }
          unint64_t v12 = sub_1003FEFA8((uint64_t)off_1008D5F48, *v11, a3);
          if (!v12)
          {
LABEL_18:
            __int16 v11 = v22;
            break;
          }

          if (qword_1008D61A8 != -1) {
            dispatch_once(&qword_1008D61A8, &stru_100896D08);
          }
          uint64_t v13 = sub_10049729C(qword_1008D61A0, *v11);
          if (v13)
          {
            if (qword_1008D9138 != -1) {
              dispatch_once(&qword_1008D9138, &stru_100896E88);
            }
            uint64_t v14 = off_1008D9130;
            __int16 v15 = operator new(0x50uLL);
            unint64_t v16 = v11[3];
            unint64_t v17 = *v11;
            unint64_t v18 = v11[5];
            uint8_t v15[4] = 1;
            *((void *)v15 + 2) = v13;
            *((void *)v15 + 3) = v16;
            *(void *)__int16 v15 = &off_100896CD8;
            *((void *)v15 + 4) = v18;
            *((void *)v15 + 5) = v17;
            *((_DWORD *)v15 + 12) = a2;
            uint64_t v19 = *a4;
            *((void *)v15 + 7) = v12;
            *((void *)v15 + _Block_object_dispose(va, 8) = v19;
            v15[36] = *((_WORD *)a4 + 4);
            sub_1004946C4((uint64_t)v14, v15);
          }

          else
          {
            sub_100242ECC((uint64_t)v25);
            uint64_t v20 = sub_10040BE38(*(void *)(a1 + 480), *(void *)(a1 + 488), *v11);
            sub_10040BDF4(a1 + 480, v20, *(void *)(a1 + 488));
            sub_100242F54((uint64_t)v25);
          }
        }

        v11 += 6;
        if (v11 == v23) {
          goto LABEL_18;
        }
      }
    }

    if (v11)
    {
      uint64_t v23 = v11;
      operator delete(v11);
    }
  }

  return sub_100242FAC((uint64_t)v25);
}

void sub_100408E18( _Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void *__p, uint64_t a11, uint64_t a12, char a13)
{
  if (__p) {
    operator delete(__p);
  }
  sub_100242FAC((uint64_t)&a13);
  _Unwind_Resume(a1);
}

uint64_t sub_100408E54(uint64_t a1, uint64_t a2, uint64_t a3)
{
  if (qword_1008D6788 != -1) {
    dispatch_once(&qword_1008D6788, &stru_100896DA8);
  }
  char v12 = 0;
  sub_100242CA4(&v12);
  uint64_t v10 = sub_10011EA98((uint64_t)nullsub_324, a3, v4, v5, v6, v7, v8, v9);
  sub_100242CD0(&v12);
  if ((_DWORD)v10)
  {
    if (os_log_type_enabled((os_log_t)qword_1008F7578, OS_LOG_TYPE_ERROR)) {
      sub_10067BFB4();
    }
    uint64_t v10 = 1LL;
  }

  sub_100242CD8(&v12);
  return v10;
}

void sub_100408F20( _Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, int a10, __int16 a11, char a12, char a13)
{
}

uint64_t sub_100408F34(uint64_t a1, uint64_t a2, uint64_t a3)
{
  uint64_t v13 = 0LL;
  if (qword_1008D6788 != -1) {
    dispatch_once(&qword_1008D6788, &stru_100896DA8);
  }
  char v12 = 0;
  sub_100242CA4(&v12);
  if (sub_10010EEE0(a3 + 128, &v13))
  {
    uint64_t v10 = 312LL;
  }

  else if (sub_10011EAC4((uint64_t)sub_1004089E8, v13, v4, v5, v6, v7, v8, v9))
  {
    if (os_log_type_enabled((os_log_t)qword_1008F7578, OS_LOG_TYPE_ERROR)) {
      sub_10067BFB4();
    }
    uint64_t v10 = 1LL;
  }

  else
  {
    sub_100242CD0(&v12);
    uint64_t v10 = 0LL;
  }

  sub_100242CD8(&v12);
  return v10;
}

void sub_100409024( _Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, int a9, __int16 a10, char a11, char a12)
{
}

uint64_t sub_100409038(uint64_t a1, char a2)
{
  if (qword_1008D6788 != -1) {
    dispatch_once(&qword_1008D6788, &stru_100896DA8);
  }
  return sub_10040D3EC((uint64_t)off_1008D6780, a2);
}

uint64_t sub_100409094(uint64_t a1, unint64_t a2, int a3)
{
  if (qword_1008D61A8 != -1) {
    dispatch_once(&qword_1008D61A8, &stru_100896D08);
  }
  uint64_t v6 = sub_100496954((void *)qword_1008D61A0, a2);
  if (v6)
  {
    uint64_t v7 = v6;
    uint64_t v8 = (os_log_s *)qword_1008F7578;
    if (os_log_type_enabled((os_log_t)qword_1008F7578, OS_LOG_TYPE_DEFAULT))
    {
      sub_100494958(v7, (uint64_t)__p);
      uint64_t v9 = (void **)__p[0];
      uint64_t v10 = "off";
      if (v13 >= 0) {
        uint64_t v9 = __p;
      }
      if (a3) {
        uint64_t v10 = "on";
      }
      *(_DWORD *)std::string buf = 136446466;
      __int16 v15 = v9;
      __int16 v16 = 2082;
      unint64_t v17 = v10;
      _os_log_impl( (void *)&_mh_execute_header,  v8,  OS_LOG_TYPE_DEFAULT,  "Session %{public}s wants denylisting %{public}s",  buf,  0x16u);
      if (v13 < 0) {
        operator delete(__p[0]);
      }
    }
  }

  if (sub_1004099B8() != a3)
  {
    if (qword_1008D60B0 != -1) {
      dispatch_once(&qword_1008D60B0, &stru_100896D28);
    }
    sub_10042FC90((uint64_t)off_1008D60A8, a3);
    sub_1004099F8(a1, 10, 0);
  }

  return 0LL;
}

uint64_t sub_100409238(uint64_t a1, _DWORD *a2)
{
  if (qword_1008D6788 != -1) {
    dispatch_once(&qword_1008D6788, &stru_100896DA8);
  }
  *a2 = sub_1002075B4((uint64_t)off_1008D6780);
  return 0LL;
}

uint64_t sub_100409290()
{
  if (qword_1008D6788 != -1) {
    dispatch_once(&qword_1008D6788, &stru_100896DA8);
  }
  return sub_10040D9F4((uint64_t)off_1008D6780);
}

uint64_t sub_1004092D0()
{
  if (qword_1008D6788 != -1) {
    dispatch_once(&qword_1008D6788, &stru_100896DA8);
  }
  return sub_10040DB10((uint64_t)off_1008D6780);
}

uint64_t sub_100409310(uint64_t a1, uint64_t a2, char *a3)
{
  if (qword_1008D6788 != -1) {
    dispatch_once(&qword_1008D6788, &stru_100896DA8);
  }
  uint64_t v5 = (os_log_s *)qword_1008F7578;
  if (os_log_type_enabled((os_log_t)qword_1008F7578, OS_LOG_TYPE_DEFAULT))
  {
    *(_DWORD *)std::string __p = 136315138;
    *(void *)&__p[4] = a3;
    _os_log_impl( (void *)&_mh_execute_header,  v5,  OS_LOG_TYPE_DEFAULT,  "Displaying power prompt on behalf of application %s",  __p,  0xCu);
  }

  uint64_t v6 = sub_1002E8E64();
  sub_10002418C(__p, a3);
  (*(void (**)(uint64_t, _BYTE *))(*(void *)v6 + 32LL))(v6, __p);
  if (v8 < 0) {
    operator delete(*(void **)__p);
  }
  return 0LL;
}

void sub_10040942C( _Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, void *__p, uint64_t a10, int a11, __int16 a12, char a13, char a14)
{
  if (a14 < 0) {
    operator delete(__p);
  }
  _Unwind_Resume(exception_object);
}

uint64_t sub_100409450(uint64_t a1, _BYTE *a2)
{
  if (qword_1008D6788 != -1) {
    dispatch_once(&qword_1008D6788, &stru_100896DA8);
  }
  *a2 = sub_10040DDD8((uint64_t)off_1008D6780);
  return 0LL;
}

void sub_1004094A8()
{
  if (qword_1008D60B0 != -1) {
    dispatch_once(&qword_1008D60B0, &stru_100896D28);
  }
  sub_100437A4C((uint64_t)off_1008D60A8);
}

uint64_t sub_1004094E8(uint64_t a1, int a2, uint64_t a3, uint64_t a4)
{
  if (qword_1008D60B0 != -1) {
    dispatch_once(&qword_1008D60B0, &stru_100896D28);
  }
  return sub_100437E18((uint64_t)off_1008D60A8, a2, a3, a4);
}

uint64_t sub_100409550(uint64_t a1, int a2)
{
  if (qword_1008D60B0 != -1) {
    dispatch_once(&qword_1008D60B0, &stru_100896D28);
  }
  return sub_100437FC0((uint64_t)off_1008D60A8, a2);
}

uint64_t sub_1004095A0()
{
  if (qword_1008D60B0 != -1) {
    dispatch_once(&qword_1008D60B0, &stru_100896D28);
  }
  return sub_1004382A0((uint64_t)off_1008D60A8);
}

uint64_t sub_1004095E0(uint64_t a1, _BYTE *a2)
{
  if (qword_1008D60B0 != -1) {
    dispatch_once(&qword_1008D60B0, &stru_100896D28);
  }
  return sub_100437DCC((uint64_t)off_1008D60A8, a2);
}

uint64_t sub_100409630(uint64_t a1, uint64_t a2)
{
  if (qword_1008D60B0 != -1) {
    dispatch_once(&qword_1008D60B0, &stru_100896D28);
  }
  return sub_100431644((uint64_t)off_1008D60A8, a2);
}

uint64_t sub_100409680(uint64_t a1, std::string *a2)
{
  if (qword_1008D60B0 != -1) {
    dispatch_once(&qword_1008D60B0, &stru_100896D28);
  }
  return sub_10043170C((uint64_t)off_1008D60A8, a2);
}

uint64_t sub_1004096D0@<X0>(uint64_t a1@<X0>, uint64_t a2@<X8>)
{
  v5[0] = 0LL;
  v5[1] = 0LL;
  sub_100242F28((uint64_t)v5, a1 + 280);
  if (*(char *)(a1 + 367) < 0)
  {
    sub_100024238((_BYTE *)a2, *(void **)(a1 + 344), *(void *)(a1 + 352));
  }

  else
  {
    *(_OWORD *)a2 = *(_OWORD *)(a1 + 344);
    *(void *)(a2 + 16) = *(void *)(a1 + 360);
  }

  return sub_100242FAC((uint64_t)v5);
}

void sub_10040973C( _Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9)
{
}

uint64_t sub_100409750@<X0>(uint64_t a1@<X0>, uint64_t a2@<X8>)
{
  v5[0] = 0LL;
  v5[1] = 0LL;
  sub_100242F28((uint64_t)v5, a1 + 280);
  if (*(char *)(a1 + 391) < 0)
  {
    sub_100024238((_BYTE *)a2, *(void **)(a1 + 368), *(void *)(a1 + 376));
  }

  else
  {
    *(_OWORD *)a2 = *(_OWORD *)(a1 + 368);
    *(void *)(a2 + 16) = *(void *)(a1 + 384);
  }

  return sub_100242FAC((uint64_t)v5);
}

void sub_1004097BC( _Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9)
{
}

uint64_t sub_1004097D0@<X0>(uint64_t a1@<X0>, uint64_t a2@<X8>)
{
  v5[0] = 0LL;
  v5[1] = 0LL;
  sub_100242F28((uint64_t)v5, a1 + 280);
  if (*(char *)(a1 + 415) < 0)
  {
    sub_100024238((_BYTE *)a2, *(void **)(a1 + 392), *(void *)(a1 + 400));
  }

  else
  {
    *(_OWORD *)a2 = *(_OWORD *)(a1 + 392);
    *(void *)(a2 + 16) = *(void *)(a1 + 408);
  }

  return sub_100242FAC((uint64_t)v5);
}

void sub_10040983C( _Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9)
{
}

void *sub_100409850(uint64_t a1, void *a2)
{
  v10[0] = (uint64_t)v10;
  v10[1] = (uint64_t)v10;
  void v10[2] = 0LL;
  uint64_t v2 = *(void **)(a1 + 8);
  if (v2 != (void *)a1)
  {
    do
    {
      uint64_t v6 = (void *)v2[1];
      uint64_t v5 = v2[2];
      if (v5 == *a2)
      {
        if (v6 == (void *)a1)
        {
          BOOL v8 = 1;
LABEL_8:
          uint64_t v6 = (void *)a1;
        }

        else
        {
          while (1)
          {
            uint64_t v7 = v6[2];
            BOOL v8 = v7 == v5;
            if (v7 != v5) {
              break;
            }
            uint64_t v6 = (void *)v6[1];
            if (v6 == (void *)a1) {
              goto LABEL_8;
            }
          }
        }

        sub_10040BD38((uint64_t)v10, v10, a1, v2, v6);
        if (!v8) {
          uint64_t v6 = (void *)v6[1];
        }
      }

      uint64_t v2 = v6;
    }

    while (v6 != (void *)a1);
  }

  return sub_10023DF50(v10);
}

void sub_100409908(_Unwind_Exception *a1, uint64_t a2, ...)
{
}

uint64_t sub_10040991C(uint64_t a1, _BYTE *a2)
{
  if (qword_1008D60B0 != -1) {
    dispatch_once(&qword_1008D60B0, &stru_100896D28);
  }
  return sub_100433078((uint64_t)off_1008D60A8, a2);
}

BOOL sub_10040996C(uint64_t a1)
{
  v4[0] = 0LL;
  v4[1] = 0LL;
  sub_100242F28((uint64_t)v4, a1 + 576);
  BOOL v2 = *(void *)(a1 + 656) != 0LL;
  sub_100242FAC((uint64_t)v4);
  return v2;
}

uint64_t sub_1004099B8()
{
  if (qword_1008D60B0 != -1) {
    dispatch_once(&qword_1008D60B0, &stru_100896D28);
  }
  return sub_1004313B0((uint64_t)off_1008D60A8);
}

uint64_t sub_1004099F8(uint64_t a1, int a2, int a3)
{
  v24[0] = _NSConcreteStackBlock;
  v24[1] = 3221225472LL;
  v24[2] = sub_10040ADF0;
  v24[3] = &unk_100896C28;
  int v25 = a2;
  int v26 = a3;
  sub_10040AD34((os_unfair_lock_s *)(a1 + 64), v24);
  v23[0] = 0LL;
  v23[1] = 0LL;
  sub_100242F28((uint64_t)v23, a1 + 416);
  uint64_t v7 = *(unint64_t **)(a1 + 480);
  uint64_t v6 = *(unint64_t **)(a1 + 488);
  if (v7 != v6)
  {
    switch(a2)
    {
      case 0:
        int v8 = 1;
        uint64_t v9 = "power changed";
        goto LABEL_15;
      case 1:
        int v8 = 2;
        uint64_t v9 = "device name changed";
        goto LABEL_15;
      case 2:
        int v8 = 4;
        uint64_t v9 = "discoverability changed";
        goto LABEL_15;
      case 3:
        int v8 = 8;
        uint64_t v9 = "connectability changed";
        goto LABEL_15;
      case 4:
        int v8 = 16;
        uint64_t v9 = "pairing status changed";
        goto LABEL_15;
      case 5:
        int v8 = 32;
        uint64_t v9 = "connection status changed";
        goto LABEL_15;
      case 6:
        int v8 = 64;
        uint64_t v9 = "discovery started";
        goto LABEL_15;
      case 7:
        int v8 = 128;
        uint64_t v9 = "discovery stopped";
        goto LABEL_15;
      case 8:
        return sub_100242FAC((uint64_t)v23);
      case 9:
        int v8 = 512;
        uint64_t v9 = "airplane mode status changed";
        goto LABEL_15;
      case 10:
        int v8 = 1024;
        uint64_t v9 = "denylist mode changed";
        goto LABEL_15;
      case 11:
        int v8 = 2048;
        uint64_t v9 = "first unlock completed";
        goto LABEL_15;
      default:
        int v8 = 0;
        uint64_t v9 = "unknown";
LABEL_15:
        uint64_t v22 = v9;
        uint64_t v10 = (os_log_s *)qword_1008F7578;
        if (os_log_type_enabled((os_log_t)qword_1008F7578, OS_LOG_TYPE_DEFAULT))
        {
          *(_DWORD *)std::string buf = 136446210;
          *(void *)&uint8_t buf[4] = v22;
          _os_log_impl( (void *)&_mh_execute_header,  v10,  OS_LOG_TYPE_DEFAULT,  "Sending '%{public}s' event to local device listeners",  buf,  0xCu);
          uint64_t v7 = *(unint64_t **)(a1 + 480);
          uint64_t v6 = *(unint64_t **)(a1 + 488);
        }

        if (v7 != v6)
        {
          do
          {
            if (v7[1])
            {
              if (qword_1008D61A8 != -1) {
                dispatch_once(&qword_1008D61A8, &stru_100896D08);
              }
              unint64_t v11 = sub_10049729C(qword_1008D61A0, *v7);
              if (v11)
              {
                if (qword_1008D61A8 != -1) {
                  dispatch_once(&qword_1008D61A8, &stru_100896D08);
                }
                if ((sub_10049828C(qword_1008D61A0, *v7) & v8) != 0)
                {
                  if (qword_1008D61A8 != -1) {
                    dispatch_once(&qword_1008D61A8, &stru_100896D08);
                  }
                  uint64_t v12 = sub_100496954((void *)qword_1008D61A0, v11);
                  if (!v12) {
                    __assert_rtn("notifyStatusEvent", "LocalDevice.mm", 1078, "session");
                  }
                  char v13 = (os_log_s *)qword_1008F7578;
                  if (os_log_type_enabled((os_log_t)qword_1008F7578, OS_LOG_TYPE_DEFAULT))
                  {
                    sub_100494958(v12, (uint64_t)buf);
                    uint64_t v14 = buf;
                    if (v28 < 0) {
                      uint64_t v14 = *(_BYTE **)buf;
                    }
                    *(_DWORD *)char v29 = 136446466;
                    uint64_t v30 = v22;
                    __int16 v31 = 2080;
                    uint64_t v32 = v14;
                    _os_log_impl( (void *)&_mh_execute_header,  v13,  OS_LOG_TYPE_DEFAULT,  "Masking '%{public}s' event from local device listener : %s",  v29,  0x16u);
                    if (v28 < 0) {
                      operator delete(*(void **)buf);
                    }
                  }
                }

                else
                {
                  if (qword_1008D9138 != -1) {
                    dispatch_once(&qword_1008D9138, &stru_100896E88);
                  }
                  __int16 v16 = off_1008D9130;
                  unint64_t v17 = operator new(0x38uLL);
                  unint64_t v19 = *v7;
                  unint64_t v18 = v7[1];
                  unint64_t v20 = v7[5];
                  v17[4] = 1;
                  *((void *)v17 + 2) = v11;
                  *((void *)v17 + 3) = v18;
                  *(void *)unint64_t v17 = &off_100896C58;
                  *((void *)v17 + 4) = v20;
                  *((void *)v17 + 5) = v19;
                  *((_DWORD *)v17 + 12) = a2;
                  *((_DWORD *)v17 + 13) = a3;
                  sub_1004946C4((uint64_t)v16, v17);
                }
              }

              else
              {
                uint64_t v15 = sub_10040BE38(*(void *)(a1 + 480), *(void *)(a1 + 488), *v7);
                sub_10040BDF4(a1 + 480, v15, *(void *)(a1 + 488));
              }
            }

            v7 += 6;
          }

          while (v7 != *(unint64_t **)(a1 + 488));
        }

        break;
    }
  }

  return sub_100242FAC((uint64_t)v23);
}

void sub_100409E30(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, ...)
{
}

uint64_t sub_100409E88(uint64_t a1, char *a2, unint64_t *a3, unint64_t a4)
{
  v45 = 0LL;
  v46 = 0LL;
  uint64_t v47 = 0LL;
  if (qword_1008D67E8 != -1) {
    dispatch_once(&qword_1008D67E8, &stru_100896D68);
  }
  sub_1003C9C48((uint64_t)off_1008D67E0, &v45);
  uint64_t v6 = (uint64_t *)v45;
  if (v45 == v46)
  {
    unint64_t v10 = 0LL;
  }

  else
  {
    uint64_t v7 = 0LL;
    int v8 = a2;
    while (a4 + v7)
    {
      sub_1003D0100(*v6, (uint64_t)&buf);
      if ((v50 & 0x80u) == 0) {
        p___int128 buf = (const char *)&buf;
      }
      else {
        p___int128 buf = (const char *)buf;
      }
      strlcpy(v8, p_buf, 0xF8uLL);
      ++v6;
      --v7;
      v8 += 248;
      if (v6 == v46)
      {
        unint64_t v10 = -v7;
        goto LABEL_16;
      }
    }

    unint64_t v11 = (os_log_s *)qword_1008F7578;
    unint64_t v10 = a4;
    if (os_log_type_enabled((os_log_t)qword_1008F7578, OS_LOG_TYPE_DEFAULT))
    {
      LODWORD(buf) = 134217984;
      *(void *)((char *)&buf + 4) = a4;
      _os_log_impl( (void *)&_mh_execute_header,  v11,  OS_LOG_TYPE_DEFAULT,  "Warning: More than %zu classic devices connected",  (uint8_t *)&buf,  0xCu);
      unint64_t v10 = a4;
    }
  }

void sub_10040A474( _Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, void *a11, void *__p, uint64_t a13, int a14, __int16 a15, char a16, char a17, void *a18, uint64_t a19, int a20, __int16 a21, char a22, char a23, void *a24, uint64_t a25, int a26, __int16 a27, char a28, char a29, void *a30, uint64_t a31, int a32, __int16 a33, char a34, char a35, void *a36, uint64_t a37, int a38, __int16 a39, char a40, char a41, uint64_t a42, uint64_t a43, uint64_t a44, uint64_t a45, uint64_t a46, uint64_t a47, uint64_t a48, uint64_t a49, uint64_t a50,void *a51,uint64_t a52)
{
  if (a17 < 0) {
    operator delete(__p);
  }
  if (a23 < 0) {
    operator delete(a18);
  }
  if (a29 < 0) {
    operator delete(a24);
  }
  if (a35 < 0) {
    operator delete(a30);
  }
  if (a41 < 0) {
    operator delete(a36);
  }

  if (a51) {
    operator delete(a51);
  }
  _Unwind_Resume(a1);
}

uint64_t sub_10040A568(uint64_t a1)
{
  return sub_1004099F8(a1, 11, 0);
}

uint64_t sub_10040A574(uint64_t a1, _BYTE *a2)
{
  if (qword_1008D60B0 != -1) {
    dispatch_once(&qword_1008D60B0, &stru_100896D28);
  }
  return sub_100432384((uint64_t)off_1008D60A8, a2);
}

BOOL sub_10040A5C4(uint64_t a1)
{
  v4[0] = 0LL;
  v4[1] = 0LL;
  sub_100242F28((uint64_t)v4, a1 + 576);
  BOOL v2 = *(void *)(a1 + 680) != 0LL;
  sub_100242FAC((uint64_t)v4);
  return v2;
}

uint64_t sub_10040A610(uint64_t a1, BOOL *a2)
{
  if (qword_1008D67A8 != -1) {
    dispatch_once(&qword_1008D67A8, &stru_100896D88);
  }
  *a2 = sub_100530008();
  if (qword_1008D5F20 != -1) {
    dispatch_once(&qword_1008D5F20, &stru_100896E68);
  }
  *a2 |= sub_10061A890(qword_1008D5F18);
  return 0LL;
}

uint64_t sub_10040A6A8(uint64_t a1, void ***a2)
{
  if (qword_1008D67A8 != -1) {
    dispatch_once(&qword_1008D67A8, &stru_100896D88);
  }
  return sub_10052AFEC((uint64_t)off_1008D67A0, a2);
}

uint64_t sub_10040A6F8(uint64_t a1, _BYTE *a2)
{
  if (qword_1008D67E8 != -1) {
    dispatch_once(&qword_1008D67E8, &stru_100896D68);
  }
  *a2 = sub_1003C9B5C((uint64_t)off_1008D67E0);
  if (qword_1008D5F10 != -1) {
    dispatch_once(&qword_1008D5F10, &stru_100896DE8);
  }
  *a2 |= sub_10059A300((uint64_t)off_1008D5F08);
  return 0LL;
}

uint64_t sub_10040A790(uint64_t a1, void **a2)
{
  if (qword_1008D67E8 != -1) {
    dispatch_once(&qword_1008D67E8, &stru_100896D68);
  }
  sub_1003C9C48((uint64_t)off_1008D67E0, a2);
  return 0LL;
}

uint64_t sub_10040A7E8(uint64_t a1, char **a2)
{
  if (qword_1008D67E8 != -1) {
    dispatch_once(&qword_1008D67E8, &stru_100896D68);
  }
  sub_1003C9DA4((uint64_t)off_1008D67E0, a2);
  return 0LL;
}

uint64_t sub_10040A840(uint64_t a1, BOOL *a2)
{
  if (qword_1008D6288 != -1) {
    dispatch_once(&qword_1008D6288, &stru_100896DC8);
  }
  *a2 = sub_100576384((uint64_t)off_1008D6280);
  return 0LL;
}

uint64_t sub_10040A898()
{
  if (qword_1008D6788 != -1) {
    dispatch_once(&qword_1008D6788, &stru_100896DA8);
  }
  if (sub_1002075B4((uint64_t)off_1008D6780) == 1)
  {
    char v5 = 0;
    sub_100242CA4(&v5);
    char v0 = sub_1000B9B18();
    uint64_t v1 = (os_log_s *)qword_1008F7578;
    if ((v0 & 1) != 0)
    {
      uint64_t v2 = 0LL;
      if (os_log_type_enabled((os_log_t)qword_1008F7578, OS_LOG_TYPE_DEFAULT))
      {
        *(_WORD *)uint64_t v4 = 0;
        _os_log_impl((void *)&_mh_execute_header, v1, OS_LOG_TYPE_DEFAULT, "Successfully started HCI tracing", v4, 2u);
        uint64_t v2 = 0LL;
      }
    }

    else
    {
      if (os_log_type_enabled((os_log_t)qword_1008F7578, OS_LOG_TYPE_ERROR)) {
        sub_10067BFE0();
      }
      uint64_t v2 = 1LL;
    }

    sub_100242CD8(&v5);
  }

  else
  {
    if (os_log_type_enabled((os_log_t)qword_1008F7578, OS_LOG_TYPE_ERROR)) {
      sub_10067C00C();
    }
    return 1LL;
  }

  return v2;
}

void sub_10040A9B4( _Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, int a10, __int16 a11, char a12, char a13)
{
}

uint64_t sub_10040A9C8(uint64_t a1, uint64_t a2, _BYTE *a3, uint64_t a4, uint64_t a5)
{
  if (qword_1008D6788 != -1) {
    dispatch_once(&qword_1008D6788, &stru_100896DA8);
  }
  if (sub_1002075B4((uint64_t)off_1008D6780) == 1)
  {
    if (a3 && *a3)
    {
      uint64_t v9 = sub_1002E6C74();
      uint64_t v10 = (*(uint64_t (**)(uint64_t, _BYTE *))(*(void *)v9 + 72LL))(v9, a3);
      if (v10 < 0)
      {
        unint64_t v11 = (os_log_s *)qword_1008F7578;
        if (os_log_type_enabled((os_log_t)qword_1008F7578, OS_LOG_TYPE_ERROR)) {
          sub_10067C064(v10, v11);
        }
      }
    }

    else
    {
      uint64_t v10 = -1LL;
    }

    if (!a5) {
      a4 = 0LL;
    }
    char v17 = 0;
    sub_100242CA4(&v17);
    if ((sub_1000B9D90(a2, a4) & 1) != 0)
    {
      uint64_t v12 = 0LL;
    }

    else
    {
      if (os_log_type_enabled((os_log_t)qword_1008F7578, OS_LOG_TYPE_ERROR)) {
        sub_10067C038();
      }
      uint64_t v12 = 1LL;
    }

    sub_100242CD0(&v17);
    char v13 = (os_log_s *)qword_1008F7578;
    if (os_log_type_enabled((os_log_t)qword_1008F7578, OS_LOG_TYPE_DEFAULT))
    {
      *(_WORD *)__int16 v16 = 0;
      _os_log_impl((void *)&_mh_execute_header, v13, OS_LOG_TYPE_DEFAULT, "Successfully stopped HCI tracing", v16, 2u);
    }

    if ((v10 & 0x8000000000000000LL) == 0)
    {
      uint64_t v14 = sub_1002E6C74();
      (*(void (**)(uint64_t, uint64_t))(*(void *)v14 + 80LL))(v14, v10);
    }

    sub_100242CD8(&v17);
  }

  else
  {
    if (os_log_type_enabled((os_log_t)qword_1008F7578, OS_LOG_TYPE_ERROR)) {
      sub_10067C00C();
    }
    return 1LL;
  }

  return v12;
}

void sub_10040AB94( _Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, int a10, __int16 a11, char a12, char a13)
{
}

uint64_t sub_10040ABB0(uint64_t a1, uint64_t a2, int a3)
{
  if (qword_1008D60B0 != -1) {
    dispatch_once(&qword_1008D60B0, &stru_100896D28);
  }
  uint64_t result = sub_1004306EC((uint64_t)off_1008D60A8);
  if (!a3) {
    return sub_1004099F8(a1, 4, 0);
  }
  return result;
}

uint64_t sub_10040AC20(uint64_t a1, uint64_t a2, int a3)
{
  return sub_10040ABB0(a1 - 16, a2, a3);
}

uint64_t sub_10040AC28(uint64_t a1, uint64_t a2, int a3)
{
  if (qword_1008D60B0 != -1) {
    dispatch_once(&qword_1008D60B0, &stru_100896D28);
  }
  uint64_t result = sub_1004306EC((uint64_t)off_1008D60A8);
  if (!a3) {
    return sub_1004099F8(a1, 4, 0);
  }
  return result;
}

uint64_t sub_10040AC98(uint64_t a1, uint64_t a2, int a3)
{
  return sub_10040AC28(a1 - 16, a2, a3);
}

uint64_t sub_10040ACA0(uint64_t a1)
{
  return sub_1004099F8(a1, 5, 0);
}

uint64_t sub_10040ACAC(uint64_t a1)
{
  return sub_1004099F8(a1 - 8, 5, 0);
}

uint64_t sub_10040ACBC(uint64_t a1)
{
  return sub_1004099F8(a1, 5, 0);
}

uint64_t sub_10040ACC8(uint64_t a1)
{
  return sub_1004099F8(a1 - 8, 5, 0);
}

uint64_t sub_10040ACE0(uint64_t a1)
{
  return sub_1004099F8(a1, 5, 0);
}

uint64_t sub_10040ACEC(uint64_t a1)
{
  return sub_1004099F8(a1 - 48, 5, 0);
}

uint64_t sub_10040ACFC(uint64_t a1)
{
  return sub_1004099F8(a1, 5, 0);
}

uint64_t sub_10040AD08(uint64_t a1)
{
  return sub_1004099F8(a1 - 48, 5, 0);
}

uint64_t sub_10040AD18(uint64_t a1)
{
  return sub_1004099F8(a1, 8, 0);
}

uint64_t sub_10040AD24(uint64_t a1)
{
  return sub_1004099F8(a1 - 40, 8, 0);
}

void sub_10040AD34(os_unfair_lock_s *a1, void *a2)
{
  uint64_t v3 = a2;
  os_unfair_lock_lock(a1);
  char v5 = 0LL;
  uint64_t v6 = 0LL;
  uint64_t v7 = 0LL;
  sub_100240540(&v5, (uint64_t)&a1[2]);
  os_unfair_lock_unlock(a1);
  uint64_t v4 = v5;
  if (v5 != v6)
  {
    do
      v3[2](v3, *v4++);
    while (v4 != v6);
    uint64_t v4 = v5;
  }

  if (v4)
  {
    uint64_t v6 = v4;
    operator delete(v4);
  }
}

void sub_10040ADC8( _Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void *__p, uint64_t a11)
{
  _Unwind_Resume(a1);
}

uint64_t sub_10040ADF0(uint64_t a1, uint64_t (***a2)(void, void, void))
{
  return (**a2)(a2, *(unsigned int *)(a1 + 32), *(unsigned int *)(a1 + 36));
}

uint64_t sub_10040AE08(uint64_t a1, int a2, int a3)
{
  v22[0] = 0LL;
  v22[1] = 0LL;
  sub_100242F28((uint64_t)v22, a1 + 416);
  uint64_t v6 = *(void *)(a1 + 480);
  uint64_t v7 = *(void *)(a1 + 488);
  if (v6 != v7)
  {
    BOOL v19 = 0LL;
    unint64_t v20 = 0LL;
    uint64_t v21 = 0LL;
    sub_10040C458((char *)&v19, v6, v7, 0xAAAAAAAAAAAAAAABLL * ((v7 - v6) >> 4));
    sub_100242F54((uint64_t)v22);
    int v8 = (os_log_s *)qword_1008F7578;
    if (os_log_type_enabled((os_log_t)qword_1008F7578, OS_LOG_TYPE_DEFAULT))
    {
      *(_WORD *)unint64_t v18 = 0;
      _os_log_impl( (void *)&_mh_execute_header,  v8,  OS_LOG_TYPE_DEFAULT,  "Sending LE Test mode stopped event to local device listeners",  v18,  2u);
    }

    uint64_t v9 = v19;
    if (v19 != v20)
    {
      do
      {
        if (v9[2])
        {
          if (qword_1008D61A8 != -1) {
            dispatch_once(&qword_1008D61A8, &stru_100896D08);
          }
          uint64_t v10 = sub_10049729C(qword_1008D61A0, *v9);
          if (v10)
          {
            if (qword_1008D9138 != -1) {
              dispatch_once(&qword_1008D9138, &stru_100896E88);
            }
            unint64_t v11 = off_1008D9130;
            uint64_t v12 = operator new(0x38uLL);
            unint64_t v13 = v9[2];
            unint64_t v14 = *v9;
            unint64_t v15 = v9[5];
            void v12[4] = 1;
            *((void *)v12 + 2) = v10;
            *((void *)v12 + 3) = v13;
            *(void *)uint64_t v12 = &off_100896C98;
            *((void *)v12 + 4) = v15;
            *((void *)v12 + 5) = v14;
            *((_DWORD *)v12 + 12) = a2;
            *((_DWORD *)v12 + 13) = a3;
            sub_1004946C4((uint64_t)v11, v12);
          }

          else
          {
            sub_100242ECC((uint64_t)v22);
            uint64_t v16 = sub_10040BE38(*(void *)(a1 + 480), *(void *)(a1 + 488), *v9);
            sub_10040BDF4(a1 + 480, v16, *(void *)(a1 + 488));
            sub_100242F54((uint64_t)v22);
          }
        }

        v9 += 6;
      }

      while (v9 != v20);
      uint64_t v9 = v19;
    }

    if (v9)
    {
      unint64_t v20 = v9;
      operator delete(v9);
    }
  }

  return sub_100242FAC((uint64_t)v22);
}

void sub_10040B008( _Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void *__p, uint64_t a11, uint64_t a12, char a13)
{
  if (__p) {
    operator delete(__p);
  }
  sub_100242FAC((uint64_t)&a13);
  _Unwind_Resume(a1);
}

uint64_t sub_10040B038(uint64_t a1)
{
  return sub_1004099F8(a1, 0, 0);
}

uint64_t sub_10040B044(uint64_t a1)
{
  return sub_1004099F8(a1 - 32, 0, 0);
}

uint64_t sub_10040B054(uint64_t a1)
{
  return sub_1004099F8(a1, 9, 0);
}

uint64_t sub_10040B060(uint64_t a1)
{
  return sub_1004099F8(a1 - 56, 9, 0);
}

uint64_t sub_10040B078(uint64_t a1, int a2)
{
  return sub_1004099F8(a1, a2, 0);
}

uint64_t sub_10040B080()
{
  if (qword_1008D63D8 != -1) {
    dispatch_once(&qword_1008D63D8, &stru_100896EA8);
  }
  if (qword_1008D6608 != -1) {
    dispatch_once(&qword_1008D6608, &stru_100896EC8);
  }
  return sub_1005F4F64((uint64_t)off_1008D6600);
}

uint64_t sub_10040B104()
{
  if (qword_1008D63D8 != -1) {
    dispatch_once(&qword_1008D63D8, &stru_100896EA8);
  }
  return sub_100453800((uint64_t)off_1008D63D0);
}

uint64_t sub_10040B144@<X0>(uint64_t a1@<X0>, std::stringbuf::string_type *a2@<X8>)
{
  uint64_t v63 = 0LL;
  __int128 v61 = 0u;
  memset(v62, 0, sizeof(v62));
  __int128 v60 = 0u;
  *(_OWORD *)std::string __p = 0u;
  __int128 v57 = 0u;
  memset(v58, 0, sizeof(v58));
  sub_1001FCFC8((uint64_t)&v57);
  __int16 v56 = 0;
  int v55 = 0;
  if (qword_1008D60B0 != -1) {
    dispatch_once(&qword_1008D60B0, &stru_100896D28);
  }
  sub_100431644((uint64_t)off_1008D60A8, (uint64_t)&v55);
  uint64_t v4 = sub_1001FD17C(v58, (uint64_t)"Name: ", 6LL);
  if (qword_1008D60B0 != -1) {
    dispatch_once(&qword_1008D60B0, &stru_100896D28);
  }
  char v5 = (char *)off_1008D60A8 + 296;
  size_t v6 = strlen(v5);
  uint64_t v7 = sub_1001FD17C(v4, (uint64_t)v5, v6);
  std::ios_base::getloc((const std::ios_base *)((char *)v7 + *(void *)(*v7 - 24LL)));
  int v8 = std::locale::use_facet(&v52, &std::ctype<char>::id);
  uint64_t v9 = ((uint64_t (*)(const std::locale::facet *, uint64_t))v8->__vftable[2].~facet_0)(v8, 10LL);
  std::locale::~locale(&v52);
  std::ostream::put(v7, v9);
  std::ostream::flush(v7);
  uint64_t v10 = sub_1001FD17C(v58, (uint64_t)"Model: ", 7LL);
  int v11 = *(char *)(a1 + 367);
  if (v11 >= 0) {
    uint64_t v12 = a1 + 344;
  }
  else {
    uint64_t v12 = *(void *)(a1 + 344);
  }
  if (v11 >= 0) {
    uint64_t v13 = *(unsigned __int8 *)(a1 + 367);
  }
  else {
    uint64_t v13 = *(void *)(a1 + 352);
  }
  unint64_t v14 = sub_1001FD17C(v10, v12, v13);
  std::ios_base::getloc((const std::ios_base *)((char *)v14 + *(void *)(*v14 - 24LL)));
  unint64_t v15 = std::locale::use_facet(&v52, &std::ctype<char>::id);
  uint64_t v16 = ((uint64_t (*)(const std::locale::facet *, uint64_t))v15->__vftable[2].~facet_0)(v15, 10LL);
  std::locale::~locale(&v52);
  std::ostream::put(v14, v16);
  std::ostream::flush(v14);
  char v17 = sub_1001FD17C(v58, (uint64_t)"SW Version: ", 12LL);
  int v18 = *(char *)(a1 + 391);
  if (v18 >= 0) {
    uint64_t v19 = a1 + 368;
  }
  else {
    uint64_t v19 = *(void *)(a1 + 368);
  }
  if (v18 >= 0) {
    uint64_t v20 = *(unsigned __int8 *)(a1 + 391);
  }
  else {
    uint64_t v20 = *(void *)(a1 + 376);
  }
  uint64_t v21 = sub_1001FD17C(v17, v19, v20);
  std::ios_base::getloc((const std::ios_base *)((char *)v21 + *(void *)(*v21 - 24LL)));
  uint64_t v22 = std::locale::use_facet(&v52, &std::ctype<char>::id);
  uint64_t v23 = ((uint64_t (*)(const std::locale::facet *, uint64_t))v22->__vftable[2].~facet_0)(v22, 10LL);
  std::locale::~locale(&v52);
  std::ostream::put(v21, v23);
  std::ostream::flush(v21);
  uint64_t v24 = sub_1001FD17C(v58, (uint64_t)"Address: ", 9LL);
  locale = (const char *)&v52;
  sub_1003FE1B4((unsigned __int8 *)&v55, &v52);
  if (v54 < 0) {
    locale = (const char *)v52.__locale_;
  }
  size_t v26 = strlen(locale);
  int v27 = sub_1001FD17C(v24, (uint64_t)locale, v26);
  std::ios_base::getloc((const std::ios_base *)((char *)v27 + *(void *)(*v27 - 24LL)));
  char v28 = std::locale::use_facet(&v64, &std::ctype<char>::id);
  uint64_t v29 = ((uint64_t (*)(const std::locale::facet *, uint64_t))v28->__vftable[2].~facet_0)(v28, 10LL);
  std::locale::~locale(&v64);
  std::ostream::put(v27, v29);
  std::ostream::flush(v27);
  if (SHIBYTE(v54) < 0) {
    operator delete(v52.__locale_);
  }
  v52.__locale_ = 0LL;
  uint64_t v53 = 0LL;
  uint64_t v54 = 0LL;
  uint64_t v30 = sub_1002E6B38();
  if (!(*(unsigned int (**)(uint64_t, std::locale *))(*(void *)v30 + 64LL))(v30, &v52))
  {
    uint64_t v31 = HIBYTE(v54);
    if (v54 < 0) {
      uint64_t v31 = v53;
    }
    if (v31)
    {
      char v32 = sub_1001FD17C(v58, (uint64_t)"FW Version: ", 12LL);
      if (v54 >= 0) {
        uint64_t v33 = &v52;
      }
      else {
        uint64_t v33 = v52.__locale_;
      }
      if (v54 >= 0) {
        uint64_t v34 = HIBYTE(v54);
      }
      else {
        uint64_t v34 = v53;
      }
      int v35 = sub_1001FD17C(v32, (uint64_t)v33, v34);
      std::ios_base::getloc((const std::ios_base *)((char *)v35 + *(void *)(*v35 - 24LL)));
      char v36 = std::locale::use_facet(&v64, &std::ctype<char>::id);
      uint64_t v37 = ((uint64_t (*)(const std::locale::facet *, uint64_t))v36->__vftable[2].~facet_0)(v36, 10LL);
      std::locale::~locale(&v64);
      std::ostream::put(v35, v37);
      std::ostream::flush(v35);
    }
  }

  char v51 = 0;
  if (qword_1008D60B0 != -1) {
    dispatch_once(&qword_1008D60B0, &stru_100896D28);
  }
  sub_100432384((uint64_t)off_1008D60A8, &v51);
  char v50 = 0;
  if (qword_1008D60B0 != -1) {
    dispatch_once(&qword_1008D60B0, &stru_100896D28);
  }
  sub_100433078((uint64_t)off_1008D60A8, &v50);
  char v38 = sub_1001FD17C(v58, (uint64_t)"Discoverable: ", 14LL);
  if (v51) {
    v39 = "Yes";
  }
  else {
    v39 = "No";
  }
  if (v51) {
    uint64_t v40 = 3LL;
  }
  else {
    uint64_t v40 = 2LL;
  }
  __int128 v41 = sub_1001FD17C(v38, (uint64_t)v39, v40);
  __int128 v42 = sub_1001FD17C(v41, (uint64_t)" Connectable: ", 14LL);
  if (v50) {
    __int128 v43 = "Yes";
  }
  else {
    __int128 v43 = "No";
  }
  if (v50) {
    uint64_t v44 = 3LL;
  }
  else {
    uint64_t v44 = 2LL;
  }
  v45 = sub_1001FD17C(v42, (uint64_t)v43, v44);
  std::ios_base::getloc((const std::ios_base *)((char *)v45 + *(void *)(*v45 - 24LL)));
  v46 = std::locale::use_facet(&v64, &std::ctype<char>::id);
  uint64_t v47 = ((uint64_t (*)(const std::locale::facet *, uint64_t))v46->__vftable[2].~facet_0)(v46, 10LL);
  std::locale::~locale(&v64);
  std::ostream::put(v45, v47);
  std::ostream::flush(v45);
  std::stringbuf::str(a2, (const std::stringbuf *)((char *)v58 + 8));
  if (SHIBYTE(v54) < 0) {
    operator delete(v52.__locale_);
  }
  *(void *)((char *)&v58[-1]
  *(void *)&v58[0] = v48;
  if (SHIBYTE(v60) < 0) {
    operator delete(__p[1]);
  }
  std::streambuf::~streambuf((char *)v58 + 8);
  return std::ios::~ios(v62);
}

void sub_10040B6FC( _Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, void *__p, uint64_t a12, int a13, __int16 a14, char a15, char a16, uint64_t a17, char a18)
{
  if (a16 < 0) {
    operator delete(__p);
  }
  sub_1001FD0F4((uint64_t)&a18);
  _Unwind_Resume(a1);
}

void sub_10040B768(uint64_t a1)
{
  unsigned int v1 = (char)__str.__r_.__value_.__s.__size_ >> 31;
  if ((__str.__r_.__value_.__s.__size_ & 0x80u) == 0) {
    int64_t size = __str.__r_.__value_.__s.__size_;
  }
  else {
    int64_t size = __str.__r_.__value_.__l.__size_;
  }
  if (size >= 1)
  {
    if ((__str.__r_.__value_.__s.__size_ & 0x80u) == 0) {
      p_str = &__str;
    }
    else {
      p_str = (std::string *)__str.__r_.__value_.__r.__words[0];
    }
    uint64_t v4 = (char *)p_str + size;
LABEL_9:
    char v5 = p_str;
    do
    {
      size_t v6 = memchr(v5, 10, size);
      if (!v6) {
        break;
      }
      if (*v6 == 10)
      {
        if (v6 != v4)
        {
          std::string::size_type v7 = v6 - (_BYTE *)p_str;
          if (v7 != -1LL)
          {
            int v8 = (os_log_s *)qword_1008F7578;
            if (os_log_type_enabled((os_log_t)qword_1008F7578, OS_LOG_TYPE_DEFAULT))
            {
              std::string::basic_string(&v10, &__str, 0LL, v7, (std::allocator<char> *)&v12);
              uint64_t v9 = (v10.__r_.__value_.__s.__size_ & 0x80u) == 0 ? &v10 : (std::string *)v10.__r_.__value_.__r.__words[0];
              *(_DWORD *)__int128 buf = 136315138;
              unint64_t v14 = v9;
              _os_log_impl((void *)&_mh_execute_header, v8, OS_LOG_TYPE_DEFAULT, "statedump: %s", buf, 0xCu);
            }

            std::string::basic_string(&v10, &__str, v7 + 1, 0xFFFFFFFFFFFFFFFFLL, (std::allocator<char> *)buf);
            std::string __str = v10;
            LOBYTE(v1) = (v10.__r_.__value_.__s.__size_ & 0x80u) != 0;
            int64_t size = (v10.__r_.__value_.__s.__size_ & 0x80u) == 0
                 ? v10.__r_.__value_.__s.__size_
                 : __str.__r_.__value_.__l.__size_;
            p_str = (v10.__r_.__value_.__s.__size_ & 0x80u) == 0
                  ? &__str
                  : (std::string *)v10.__r_.__value_.__r.__words[0];
            uint64_t v4 = (char *)p_str + size;
            if (size >= 1) {
              goto LABEL_9;
            }
          }
        }

        break;
      }

      char v5 = (std::string *)(v6 + 1);
      int64_t size = v4 - (_BYTE *)v5;
    }

    while (v4 - (_BYTE *)v5 >= 1);
  }

  if ((v1 & 1) != 0) {
    operator delete(__str.__r_.__value_.__l.__data_);
  }
}

void sub_10040B95C( _Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, void *__p, uint64_t a16, int a17, __int16 a18, char a19, char a20)
{
  if (a20 < 0) {
    operator delete(__p);
  }
  _Unwind_Resume(exception_object);
}

uint64_t sub_10040B984(uint64_t a1, uint64_t a2, unsigned __int16 a3)
{
  int v15 = a2;
  __int16 v16 = WORD2(a2);
  uint64_t v14 = 0LL;
  char v13 = 0;
  sub_100242CA4(&v13);
  if (sub_10010EEE0((uint64_t)&v15, &v14))
  {
    uint64_t v10 = 312LL;
  }

  else
  {
    if (*(_BYTE *)(v14 + 278)) {
      int v11 = sub_100191CA8();
    }
    else {
      int v11 = sub_10011E974(v14, a3, v4, v5, v6, v7, v8, v9);
    }
    if (v11)
    {
      uint64_t v10 = 1LL;
    }

    else
    {
      sub_100242CD0(&v13);
      uint64_t v10 = 0LL;
    }
  }

  sub_100242CD8(&v13);
  return v10;
}

void sub_10040BA28( _Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, int a10, __int16 a11, char a12, char a13)
{
}

void *sub_10040BA48(void *result)
{
  *uint64_t result = &off_100896C58;
  return result;
}

uint64_t sub_10040BA5C(unint64_t *a1)
{
  uint64_t result = sub_10040BAF8((uint64_t)a1, a1[2]);
  if ((_DWORD)result) {
    return (*(uint64_t (**)(unint64_t *, unint64_t, unint64_t, unint64_t))(*a1 + 40))( a1,  a1[2],  a1[3],  a1[4]);
  }
  return result;
}

uint64_t sub_10040BAA4( uint64_t a1, uint64_t a2, uint64_t (*a3)(uint64_t, uint64_t, uint64_t, uint64_t), uint64_t a4)
{
  uint64_t result = sub_10040BAF8(a1, *(void *)(a1 + 40));
  if ((_DWORD)result) {
    return sub_1003C64F8(a2, a3, *(void *)(a1 + 40), *(unsigned int *)(a1 + 48), *(unsigned int *)(a1 + 52), a4);
  }
  return result;
}

BOOL sub_10040BAF8(uint64_t a1, unint64_t a2)
{
  if (qword_1008D61A8 != -1) {
    dispatch_once(&qword_1008D61A8, &stru_100896D08);
  }
  return sub_100497204(qword_1008D61A0, a2);
}

void *sub_10040BB48(void *result)
{
  *uint64_t result = &off_100896C98;
  return result;
}

uint64_t sub_10040BB5C(unint64_t *a1)
{
  uint64_t result = sub_10040BAF8((uint64_t)a1, a1[2]);
  if ((_DWORD)result) {
    return (*(uint64_t (**)(unint64_t *, unint64_t, unint64_t, unint64_t))(*a1 + 40))( a1,  a1[2],  a1[3],  a1[4]);
  }
  return result;
}

uint64_t sub_10040BBA4( uint64_t a1, uint64_t a2, uint64_t (*a3)(uint64_t, uint64_t, uint64_t, uint64_t), uint64_t a4)
{
  uint64_t result = sub_10040BAF8(a1, *(void *)(a1 + 40));
  if ((_DWORD)result) {
    return sub_1003C64F8(a2, a3, *(void *)(a1 + 40), *(unsigned int *)(a1 + 48), *(unsigned int *)(a1 + 52), a4);
  }
  return result;
}

void *sub_10040BBF8(void *result)
{
  *uint64_t result = &off_100896CD8;
  return result;
}

uint64_t sub_10040BC0C(unint64_t *a1)
{
  uint64_t result = sub_10040BAF8((uint64_t)a1, a1[2]);
  if ((_DWORD)result) {
    return (*(uint64_t (**)(unint64_t *, unint64_t, unint64_t, unint64_t))(*a1 + 40))( a1,  a1[2],  a1[3],  a1[4]);
  }
  return result;
}

uint64_t sub_10040BC54( uint64_t a1, uint64_t a2, uint64_t (*a3)(uint64_t, uint64_t, uint64_t, uint64_t *, uint64_t), uint64_t a4)
{
  uint64_t result = sub_10040BAF8(a1, *(void *)(a1 + 40));
  if ((_DWORD)result) {
    return sub_1003C6510( a2,  a3,  *(void *)(a1 + 40),  *(unsigned int *)(a1 + 48),  *(void *)(a1 + 56),  *(void *)(a1 + 64),  *(_WORD *)(a1 + 72),  a4);
  }
  return result;
}

void sub_10040BCB0(id a1)
{
  unsigned int v1 = operator new(0x120uLL);
  sub_100495250();
  qword_1008D61A0 = (uint64_t)v1;
}

void sub_10040BCE0(_Unwind_Exception *a1)
{
}

void sub_10040BCF4(id a1)
{
  unsigned int v1 = operator new(0x230uLL);
  sub_10042BC28();
  off_1008D60A8 = v1;
}

void sub_10040BD24(_Unwind_Exception *a1)
{
}

uint64_t sub_10040BD38(uint64_t result, uint64_t *a2, uint64_t a3, void *a4, void *a5)
{
  if (a4 != a5)
  {
    uint64_t v5 = (void *)*a5;
    if (result != a3)
    {
      uint64_t v6 = 1LL;
      if (v5 != a4)
      {
        uint64_t v7 = a4;
        do
        {
          uint64_t v7 = (void *)v7[1];
          ++v6;
        }

        while (v7 != v5);
      }

      *(void *)(a3 + 16) -= v6;
      *(void *)(result + 16) += v6;
    }

    uint64_t v8 = *a4;
    *(void *)(v8 + _Block_object_dispose(va, 8) = v5[1];
    *(void *)v5[1] = v8;
    uint64_t v9 = *a2;
    *(void *)(v9 + _Block_object_dispose(va, 8) = a4;
    *a4 = v9;
    *a2 = (uint64_t)v5;
    v5[1] = a2;
  }

  return result;
}

void sub_10040BDB0(id a1)
{
  unsigned int v1 = operator new(0x2C0uLL);
  sub_1004219F0();
  off_1008D60C8 = v1;
}

void sub_10040BDE0(_Unwind_Exception *a1)
{
}

uint64_t sub_10040BDF4(uint64_t a1, uint64_t a2, uint64_t a3)
{
  if (a2 != a3)
  {
    sub_10040BEAC(a3, *(void *)(a1 + 8), a2);
    *(void *)(a1 + _Block_object_dispose(va, 8) = v5;
  }

  return a2;
}

uint64_t sub_10040BE38(uint64_t result, uint64_t a2, uint64_t a3)
{
  while (1)
  {
    if (result == a2) {
      return a2;
    }
    if (*(void *)result == a3) {
      break;
    }
    result += 48LL;
  }

  if (result != a2)
  {
    for (uint64_t i = result + 48; i != a2; i += 48LL)
    {
      if (*(void *)i != a3)
      {
        *(void *)uint64_t result = *(void *)i;
        __int128 v4 = *(_OWORD *)(i + 8);
        *(void *)(result + 24) = *(void *)(i + 24);
        *(_OWORD *)(result + _Block_object_dispose(va, 8) = v4;
        *(_DWORD *)(result + 32) = *(_DWORD *)(i + 32);
        *(void *)(result + 40) = *(void *)(i + 40);
        result += 48LL;
      }
    }
  }

  return result;
}

uint64_t sub_10040BEAC(uint64_t a1, uint64_t a2, uint64_t a3)
{
  if (a1 == a2) {
    return a1;
  }
  do
  {
    *(void *)a3 = *(void *)a1;
    __int128 v3 = *(_OWORD *)(a1 + 8);
    *(void *)(a3 + 24) = *(void *)(a1 + 24);
    *(_OWORD *)(a3 + _Block_object_dispose(va, 8) = v3;
    *(_DWORD *)(a3 + 32) = *(_DWORD *)(a1 + 32);
    *(void *)(a3 + 40) = *(void *)(a1 + 40);
    a3 += 48LL;
    a1 += 48LL;
  }

  while (a1 != a2);
  return a2;
}

void sub_10040BF00(id a1)
{
  unsigned int v1 = operator new(0x98uLL);
  sub_1003C97E4((uint64_t)v1);
  off_1008D67E0 = v1;
}

void sub_10040BF30(_Unwind_Exception *a1)
{
}

void sub_10040BF44(id a1)
{
  unsigned int v1 = operator new(0x260uLL);
  sub_1005285C8((uint64_t)v1);
  off_1008D67A0 = v1;
}

void sub_10040BF74(_Unwind_Exception *a1)
{
}

void sub_10040BF88(id a1)
{
  unsigned int v1 = operator new(0xA8uLL);
  sub_10040D0A0((uint64_t)v1);
  off_1008D6780 = v1;
}

void sub_10040BFB8(_Unwind_Exception *a1)
{
}

void sub_10040BFCC(id a1)
{
  unsigned int v1 = operator new(0x42C0uLL);
  sub_10056DFB4();
  off_1008D6280 = v1;
}

void sub_10040BFFC(_Unwind_Exception *a1)
{
}

void sub_10040C010(id a1)
{
  unsigned int v1 = operator new(0x618uLL);
  sub_10058B0A4();
  off_1008D5F08 = v1;
}

void sub_10040C040(_Unwind_Exception *a1)
{
}

uint64_t sub_10040C054(uint64_t *a1, uint64_t a2)
{
  uint64_t v2 = *a1;
  unint64_t v3 = 0xAAAAAAAAAAAAAAABLL * ((a1[1] - *a1) >> 4);
  unint64_t v4 = v3 + 1;
  if (v3 + 1 > 0x555555555555555LL) {
    abort();
  }
  uint64_t v8 = a1[2];
  uint64_t v7 = (uint64_t)(a1 + 2);
  unint64_t v9 = 0xAAAAAAAAAAAAAAABLL * ((v8 - v2) >> 4);
  if (2 * v9 > v4) {
    unint64_t v4 = 2 * v9;
  }
  if (v9 >= 0x2AAAAAAAAAAAAAALL) {
    unint64_t v10 = 0x555555555555555LL;
  }
  else {
    unint64_t v10 = v4;
  }
  uint64_t v21 = v7;
  int v11 = (char *)sub_10024EC04(v7, v10);
  char v12 = &v11[48 * v3];
  std::string __p = v11;
  uint64_t v18 = v12;
  uint64_t v20 = &v11[48 * v13];
  *(void *)char v12 = *(void *)a2;
  __int128 v14 = *(_OWORD *)(a2 + 8);
  *((void *)v12 + 3) = *(void *)(a2 + 24);
  *(_OWORD *)(v12 + _Block_object_dispose(va, 8) = v14;
  *((_DWORD *)v12 + _Block_object_dispose(va, 8) = *(_DWORD *)(a2 + 32);
  *((void *)v12 + 5) = *(void *)(a2 + 40);
  uint64_t v19 = v12 + 48;
  sub_10040C1CC(a1, &__p);
  uint64_t v15 = a1[1];
  if (v19 != v18) {
    uint64_t v19 = &v18[(v19 - v18 - 48) % 0x30uLL];
  }
  if (__p) {
    operator delete(__p);
  }
  return v15;
}

void sub_10040C180( _Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void *__p, uint64_t a11, uint64_t a12)
{
  if (__p) {
    operator delete(__p);
  }
  _Unwind_Resume(exception_object);
}

uint64_t *sub_10040C1CC(uint64_t *result, void *a2)
{
  uint64_t v3 = *result;
  uint64_t v2 = result[1];
  uint64_t v4 = a2[1];
  while (v2 != v3)
  {
    uint64_t v5 = *(void *)(v2 - 48);
    v2 -= 48LL;
    *(void *)(v4 - 4_Block_object_dispose(va, 8) = v5;
    v4 -= 48LL;
    __int128 v6 = *(_OWORD *)(v2 + 8);
    *(void *)(v4 + 24) = *(void *)(v2 + 24);
    *(_OWORD *)(v4 + _Block_object_dispose(va, 8) = v6;
    *(_DWORD *)(v4 + 32) = *(_DWORD *)(v2 + 32);
    *(void *)(v4 + 40) = *(void *)(v2 + 40);
  }

  a2[1] = v4;
  uint64_t v7 = *result;
  *uint64_t result = v4;
  a2[1] = v7;
  uint64_t v8 = result[1];
  result[1] = a2[2];
  a2[2] = v8;
  uint64_t v9 = result[2];
  result[2] = a2[3];
  a2[3] = v9;
  *a2 = a2[1];
  return result;
}

uint64_t sub_10040C244(uint64_t result, uint64_t a2, void *a3)
{
  if (result == a2) {
    return a2;
  }
  while (1)
  {
    if (*a3 == *(void *)result)
    {
      BOOL v3 = a3[1] == *(void *)(result + 8) && a3[2] == *(void *)(result + 16);
      if (v3 && a3[3] == *(void *)(result + 24)) {
        break;
      }
    }

    result += 48LL;
    if (result == a2) {
      return a2;
    }
  }

  if (result != a2)
  {
    for (uint64_t i = result + 48; i != a2; i += 48LL)
    {
      if (*a3 == *(void *)i)
      {
        BOOL v6 = a3[1] == *(void *)(i + 8) && a3[2] == *(void *)(i + 16);
        if (v6 && a3[3] == *(void *)(i + 24)) {
          continue;
        }
      }

      *(void *)uint64_t result = *(void *)i;
      __int128 v8 = *(_OWORD *)(i + 8);
      *(void *)(result + 24) = *(void *)(i + 24);
      *(_OWORD *)(result + _Block_object_dispose(va, 8) = v8;
      *(_DWORD *)(result + 32) = *(_DWORD *)(i + 32);
      *(void *)(result + 40) = *(void *)(i + 40);
      result += 48LL;
    }
  }

  return result;
}

void sub_10040C304(id a1)
{
  unsigned int v1 = operator new(0x138uLL);
  sub_1003FE3E0((uint64_t)v1);
  off_1008D5F48 = v1;
}

void sub_10040C334(_Unwind_Exception *a1)
{
}

void sub_10040C348(id a1)
{
  unsigned int v1 = operator new(0x2B0uLL);
  sub_1004072AC((uint64_t)v1);
  off_1008D5EF8 = v1;
}

void sub_10040C378(_Unwind_Exception *a1)
{
}

void sub_10040C38C(id a1)
{
  unsigned int v1 = operator new(0x128uLL);
  sub_1005C69F8();
  off_1008D5F28 = v1;
}

void sub_10040C3BC(_Unwind_Exception *a1)
{
}

void sub_10040C3D0(id a1)
{
  unsigned int v1 = operator new(0xEB0uLL);
  sub_10061991C();
  qword_1008D5F18 = (uint64_t)v1;
}

void sub_10040C400(_Unwind_Exception *a1)
{
}

void sub_10040C414(id a1)
{
  unsigned int v1 = operator new(0x68uLL);
  sub_10049435C();
  off_1008D9130 = v1;
}

void sub_10040C444(_Unwind_Exception *a1)
{
}

char *sub_10040C458(char *result, uint64_t a2, uint64_t a3, unint64_t a4)
{
  if (a4)
  {
    BOOL v6 = result;
    uint64_t result = sub_10040C4D4(result, a4);
    uint64_t v7 = *((void *)v6 + 1);
    while (a2 != a3)
    {
      *(void *)uint64_t v7 = *(void *)a2;
      __int128 v8 = *(_OWORD *)(a2 + 8);
      *(void *)(v7 + 24) = *(void *)(a2 + 24);
      *(_OWORD *)(v7 + _Block_object_dispose(va, 8) = v8;
      *(_DWORD *)(v7 + 32) = *(_DWORD *)(a2 + 32);
      *(void *)(v7 + 40) = *(void *)(a2 + 40);
      v7 += 48LL;
      a2 += 48LL;
    }

    *((void *)v6 + 1) = v7;
  }

  return result;
}

char *sub_10040C4D4(void *a1, unint64_t a2)
{
  if (a2 >= 0x555555555555556LL) {
    abort();
  }
  uint64_t result = (char *)sub_10024EC04((uint64_t)(a1 + 2), a2);
  *a1 = result;
  a1[1] = result;
  a1[2] = &result[48 * v4];
  return result;
}

void sub_10040C520(id a1)
{
  unsigned int v1 = operator new(0x260uLL);
  sub_100451734((uint64_t)v1);
  off_1008D63D0 = v1;
}

void sub_10040C550(_Unwind_Exception *a1)
{
}

void sub_10040C564(id a1)
{
  unsigned int v1 = operator new(0x1128uLL);
  sub_1005DDADC();
  off_1008D6600 = v1;
}

void sub_10040C594(_Unwind_Exception *a1)
{
}

void sub_10040C5A8(uint64_t a1)
{
  uint64_t v2 = sub_1002E6E00();
  sub_10002418C(buf, "TTRUI");
  sub_10002418C(__p, "Disable");
  (*(void (**)(uint64_t, uint8_t *, void **, uint64_t))(*(void *)v2 + 72LL))(v2, buf, __p, a1 + 12);
  if (v9 < 0) {
    operator delete(__p[0]);
  }
  if (v11 < 0) {
    operator delete(*(void **)buf);
  }
  uint64_t v3 = sub_1002E6E00();
  uint64_t v4 = sub_1002E6E00();
  sub_10002418C(buf, "TTRUIDisabledByUser");
  sub_10002418C(__p, "Disable");
  uint64_t v5 = (int *)(a1 + 16);
  (*(void (**)(uint64_t, uint8_t *, void **, int *))(*(void *)v4 + 128LL))(v4, buf, __p, v5);
  if (v9 < 0) {
    operator delete(__p[0]);
  }
  if (v11 < 0) {
    operator delete(*(void **)buf);
  }
  BOOL v6 = (os_log_s *)qword_1008F7578;
  if (os_log_type_enabled((os_log_t)qword_1008F7578, OS_LOG_TYPE_DEFAULT))
  {
    int v7 = *v5;
    *(_DWORD *)__int128 buf = 67109120;
    *(_DWORD *)&uint8_t buf[4] = v7;
    _os_log_impl((void *)&_mh_execute_header, v6, OS_LOG_TYPE_DEFAULT, "TTRUIDisabledByUser %d", buf, 8u);
  }

void sub_10040C740( _Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void *__p, uint64_t a11, int a12, __int16 a13, char a14, char a15, void *a16, uint64_t a17, int a18, __int16 a19, char a20, char a21)
{
  if (a15 < 0) {
    operator delete(__p);
  }
  if (a21 < 0) {
    operator delete(a16);
  }
  _Unwind_Resume(exception_object);
}

void sub_10040C784(double a1, uint64_t a2, uint64_t *a3, uint64_t *a4)
{
  id v12 = objc_alloc_init(&OBJC_CLASS___SDRDiagnosticReporter);
  else {
    int v7 = (uint64_t *)*a3;
  }
  __int128 v8 = (void *)objc_claimAutoreleasedReturnValue(+[NSString stringWithUTF8String:](&OBJC_CLASS___NSString, "stringWithUTF8String:", v7));
  else {
    char v9 = (uint64_t *)*a4;
  }
  unint64_t v10 = (void *)objc_claimAutoreleasedReturnValue(+[NSString stringWithUTF8String:](&OBJC_CLASS___NSString, "stringWithUTF8String:", v9));
  char v11 = (void *)objc_claimAutoreleasedReturnValue( [v12 signatureWithDomain:@"Bluetooth" type:@"Networking" subType:v8 subtypeContext:v10 detectedProcess:@"bluetoothd" triggerThresholdValues:0]);

  [v12 snapshotWithSignature:v11 duration:0 events:0 payload:0 actions:&stru_100896F08 reply:a1];
}

void sub_10040C87C( _Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, id a10)
{
  _Unwind_Resume(a1);
}

void sub_10040C8B8(id a1, NSDictionary *a2)
{
  uint64_t v2 = a2;
  uint64_t v3 = (void *)objc_claimAutoreleasedReturnValue( -[NSDictionary objectForKeyedSubscript:]( v2,  "objectForKeyedSubscript:",  kSymptomDiagnosticReplySuccess));
  unsigned int v4 = [v3 BOOLValue];

  if (v4)
  {
    id v5 = (id)objc_claimAutoreleasedReturnValue( -[NSDictionary objectForKeyedSubscript:]( v2,  "objectForKeyedSubscript:",  kSymptomDiagnosticReplySessionID));
    BOOL v6 = (os_log_s *)qword_1008F7578;
    if (os_log_type_enabled((os_log_t)qword_1008F7578, OS_LOG_TYPE_DEFAULT))
    {
      id v5 = v5;
      int v10 = 136315138;
      id v11 = [v5 UTF8String];
      _os_log_impl( (void *)&_mh_execute_header,  v6,  OS_LOG_TYPE_DEFAULT,  "ABC Snapshot successful with SessionID %s",  (uint8_t *)&v10,  0xCu);
    }
  }

  else
  {
    int v7 = (void *)objc_claimAutoreleasedReturnValue( -[NSDictionary objectForKeyedSubscript:]( v2,  "objectForKeyedSubscript:",  kSymptomDiagnosticReplyReason));
    signed int v8 = [v7 intValue];

    id v5 = (id)objc_claimAutoreleasedReturnValue( -[NSDictionary objectForKeyedSubscript:]( v2,  "objectForKeyedSubscript:",  kSymptomDiagnosticReplyReasonString));
    char v9 = (os_log_s *)qword_1008F7578;
    if (os_log_type_enabled((os_log_t)qword_1008F7578, OS_LOG_TYPE_ERROR))
    {
      id v5 = v5;
      sub_10067C0D8((uint64_t)[v5 UTF8String], (uint8_t *)&v10, v8, v9);
    }
  }
}

void sub_10040CA44(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_10040CA80(char *__s, char *a2, double a3)
{
  if (qword_1008D9060 != -1) {
    dispatch_once(&qword_1008D9060, &stru_100896F28);
  }
  sub_10002418C(v9, __s);
  BOOL v6 = sub_10002418C(__p, a2);
  sub_10040C784(a3, (uint64_t)v6, (uint64_t *)v9, (uint64_t *)__p);
  if (v8 < 0) {
    operator delete(__p[0]);
  }
  if (v10 < 0) {
    operator delete(v9[0]);
  }
}

void sub_10040CB24( _Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, void *__p, uint64_t a10, int a11, __int16 a12, char a13, char a14, void *a15, uint64_t a16, int a17, __int16 a18, char a19, char a20)
{
  if (a14 < 0) {
    operator delete(__p);
  }
  if (a20 < 0) {
    operator delete(a15);
  }
  _Unwind_Resume(exception_object);
}

void sub_10040CB58(id a1)
{
  unsigned int v1 = operator new(0x18uLL);
  *(void *)unsigned int v1 = 0LL;
  v1[2] = 0;
  *((_BYTE *)v1 + 12) = 0;
  v1[4] = 0;
  qword_1008D9058 = (uint64_t)v1;
}

uint64_t sub_10040CB88(uint64_t result, int a2, uint64_t a3)
{
  *(_DWORD *)uint64_t result = a2;
  *(void *)(result + _Block_object_dispose(va, 8) = a3;
  return result;
}

_DWORD *sub_10040CB94(_DWORD *result, int a2)
{
  *uint64_t result = a2;
  return result;
}

uint64_t sub_10040CB9C(uint64_t a1, int a2, __int128 *a3, char a4, void *a5)
{
  id v9 = a5;
  *(_DWORD *)a1 = a2;
  char v10 = (_BYTE *)(a1 + 8);
  if (*((char *)a3 + 23) < 0)
  {
    sub_100024238(v10, *(void **)a3, *((void *)a3 + 1));
  }

  else
  {
    __int128 v11 = *a3;
    *(void *)(a1 + 24) = *((void *)a3 + 2);
    *(_OWORD *)char v10 = v11;
  }

  *(_BYTE *)(a1 + 32) = a4;
  *(void *)(a1 + 40) = v9;
  return a1;
}

void sub_10040CC14(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

uint64_t sub_10040CC24(uint64_t a1, __int128 *a2, char a3, char a4)
{
  *(_DWORD *)a1 = 0;
  uint64_t v7 = a1 + 8;
  if (*((char *)a2 + 23) < 0)
  {
    sub_100024238((_BYTE *)v7, *(void **)a2, *((void *)a2 + 1));
  }

  else
  {
    __int128 v8 = *a2;
    *(void *)(v7 + 16) = *((void *)a2 + 2);
    *(_OWORD *)uint64_t v7 = v8;
  }

  *(_BYTE *)(a1 + 32) = a3;
  *(_BYTE *)(a1 + 33) = a4;
  return a1;
}

uint64_t sub_10040CC88(uint64_t a1, __int128 *a2, char a3)
{
  *(_DWORD *)a1 = 1;
  uint64_t v5 = a1 + 8;
  if (*((char *)a2 + 23) < 0)
  {
    sub_100024238((_BYTE *)v5, *(void **)a2, *((void *)a2 + 1));
  }

  else
  {
    __int128 v6 = *a2;
    *(void *)(v5 + 16) = *((void *)a2 + 2);
    *(_OWORD *)uint64_t v5 = v6;
  }

  *(_BYTE *)(a1 + 32) = a3;
  return a1;
}

uint64_t sub_10040CCE0(uint64_t a1, __int128 *a2, char a3, uint64_t a4, char a5, char a6)
{
  *(_DWORD *)a1 = 2;
  uint64_t v11 = a1 + 8;
  if (*((char *)a2 + 23) < 0)
  {
    sub_100024238((_BYTE *)v11, *(void **)a2, *((void *)a2 + 1));
  }

  else
  {
    __int128 v12 = *a2;
    *(void *)(v11 + 16) = *((void *)a2 + 2);
    *(_OWORD *)uint64_t v11 = v12;
  }

  *(_BYTE *)(a1 + 32) = a3;
  *(void *)(a1 + 40) = a4;
  *(_BYTE *)(a1 + 4_Block_object_dispose(va, 8) = a5;
  *(_BYTE *)(a1 + 49) = a6;
  return a1;
}

uint64_t sub_10040CD64(uint64_t a1, __int128 *a2, char a3, int a4)
{
  *(_DWORD *)a1 = 3;
  uint64_t v7 = a1 + 8;
  if (*((char *)a2 + 23) < 0)
  {
    sub_100024238((_BYTE *)v7, *(void **)a2, *((void *)a2 + 1));
  }

  else
  {
    __int128 v8 = *a2;
    *(void *)(v7 + 16) = *((void *)a2 + 2);
    *(_OWORD *)uint64_t v7 = v8;
  }

  *(_BYTE *)(a1 + 32) = a3;
  *(_DWORD *)(a1 + 36) = a4;
  return a1;
}

uint64_t sub_10040CDCC( uint64_t a1, __int128 *a2, char a3, char a4, char a5, char a6, char a7, __int128 *a8, __int128 *a9)
{
  *(_DWORD *)a1 = 4;
  if (*((char *)a2 + 23) < 0)
  {
    sub_100024238((_BYTE *)(a1 + 8), *(void **)a2, *((void *)a2 + 1));
  }

  else
  {
    __int128 v16 = *a2;
    *(void *)(a1 + 24) = *((void *)a2 + 2);
    *(_OWORD *)(a1 + _Block_object_dispose(va, 8) = v16;
  }

  *(_BYTE *)(a1 + 32) = a3;
  *(_BYTE *)(a1 + 33) = a4;
  *(_BYTE *)(a1 + 34) = a5;
  *(_BYTE *)(a1 + 35) = a6;
  *(_BYTE *)(a1 + 36) = a7;
  if (*((char *)a8 + 23) < 0)
  {
    sub_100024238((_BYTE *)(a1 + 40), *(void **)a8, *((void *)a8 + 1));
  }

  else
  {
    __int128 v17 = *a8;
    *(void *)(a1 + 56) = *((void *)a8 + 2);
    *(_OWORD *)(a1 + 40) = v17;
  }

  uint64_t v18 = (_BYTE *)(a1 + 64);
  if (*((char *)a9 + 23) < 0)
  {
    sub_100024238(v18, *(void **)a9, *((void *)a9 + 1));
  }

  else
  {
    __int128 v19 = *a9;
    *(void *)(a1 + 80) = *((void *)a9 + 2);
    *(_OWORD *)uint64_t v18 = v19;
  }

  return a1;
}

void sub_10040CEC0(_Unwind_Exception *exception_object)
{
}

uint64_t sub_10040CEF4( uint64_t a1, __int128 *a2, char a3, char a4, char a5, char a6, char a7, __int128 *a8, __int128 *a9)
{
  return sub_10040CDCC(a1, a2, a3, a4, a5, a6, a7, a8, a9);
}

uint64_t sub_10040CF00(uint64_t a1, __int128 *a2, char a3, void *a4)
{
  return sub_10040CB9C(a1, 5, a2, a3, a4);
}

uint64_t sub_10040CF14(uint64_t a1, __int128 *a2, char a3, void *a4, int a5, int a6)
{
  uint64_t result = sub_10040CB9C(a1, 6, a2, a3, a4);
  *(_DWORD *)(result + 4_Block_object_dispose(va, 8) = a5;
  *(_DWORD *)(result + 52) = a6;
  return result;
}

uint64_t sub_10040CF4C(uint64_t a1, __int128 *a2, char a3, void *a4)
{
  return sub_10040CB9C(a1, 7, a2, a3, a4);
}

uint64_t sub_10040CF60(uint64_t a1, __int128 *a2, char a3, void *a4, int a5)
{
  uint64_t result = sub_10040CB9C(a1, 8, a2, a3, a4);
  *(_DWORD *)(result + 4_Block_object_dispose(va, 8) = a5;
  return result;
}

uint64_t sub_10040CF94(uint64_t a1, __int128 *a2, char a3, void *a4, uint64_t a5)
{
  uint64_t result = sub_10040CB9C(a1, 9, a2, a3, a4);
  *(void *)(result + 4_Block_object_dispose(va, 8) = a5;
  return result;
}

uint64_t sub_10040CFC8(uint64_t a1, void *a2, uint64_t a3)
{
  id v5 = a2;
  *(_DWORD *)a1 = 10;
  *(void *)(a1 + _Block_object_dispose(va, 8) = v5;
  *(void *)(a1 + 16) = a3;
  return a1;
}

uint64_t sub_10040CFFC(uint64_t a1, void *a2, int a3, char a4)
{
  id v7 = a2;
  *(_DWORD *)a1 = 11;
  *(void *)(a1 + _Block_object_dispose(va, 8) = v7;
  *(_DWORD *)(a1 + 16) = a3;
  *(_BYTE *)(a1 + 20) = a4;
  return a1;
}

uint64_t sub_10040D044(uint64_t a1, void *a2)
{
  id v3 = a2;
  *(_DWORD *)a1 = 12;
  *(void *)(a1 + _Block_object_dispose(va, 8) = v3;
  return a1;
}

uint64_t sub_10040D074(uint64_t a1, uint64_t a2)
{
  uint64_t v3 = sub_1002E8D94();
  return (*(uint64_t (**)(uint64_t, uint64_t))(*(void *)v3 + 40LL))(v3, a2);
}

uint64_t sub_10040D0A0(uint64_t a1)
{
  *(void *)a1 = off_100896F58;
  *(void *)(a1 + _Block_object_dispose(va, 8) = off_100896F98;
  sub_100242DC4(a1 + 16);
  *(_DWORD *)(a1 + 80) = 0;
  *(void *)(a1 + 96) = 0LL;
  *(void *)(a1 + 104) = 0LL;
  *(void *)(a1 + 8_Block_object_dispose(va, 8) = 0LL;
  *(void *)(a1 + 144) = a1 + 144;
  *(void *)(a1 + 152) = a1 + 144;
  *(void *)(a1 + 160) = 0LL;
  *(_DWORD *)(a1 + 112) = 2;
  *(void *)(a1 + 120) = 0LL;
  *(void *)(a1 + 12_Block_object_dispose(va, 8) = 0LL;
  *(_BYTE *)(a1 + 136) = 0;
  return a1;
}

void sub_10040D0FC(uint64_t a1)
{
  uint64_t v2 = sub_1002E8D54();
  sub_1003FDB08(v2 + 328, a1 + 8);
  uint64_t v3 = sub_100404EB8();
  v4[0] = _NSConcreteStackBlock;
  v4[1] = 3221225472LL;
  void v4[2] = sub_10040D16C;
  v4[3] = &unk_10087EB20;
  v4[4] = a1;
  sub_100405384(v3, v4);
}

void sub_10040D16C(uint64_t a1)
{
}

void sub_10040D174(uint64_t a1)
{
  uint64_t v2 = (os_log_s *)qword_1008F7578;
  if (os_log_type_enabled((os_log_t)qword_1008F7578, OS_LOG_TYPE_DEFAULT))
  {
    *(_WORD *)__int128 buf = 0;
    _os_log_impl((void *)&_mh_execute_header, v2, OS_LOG_TYPE_DEFAULT, "Beginning asynchronous power init", buf, 2u);
  }

  if (!sub_10040DDE0())
  {
    *(_DWORD *)(a1 + 112) = 3;
    return;
  }

  if (qword_1008D60B0 != -1) {
    dispatch_once(&qword_1008D60B0, &stru_100896FC8);
  }
  (*(void (**)(void *))(*(void *)off_1008D60A8 + 32LL))(off_1008D60A8);
  uint64_t v3 = sub_1002E8D54();
  (*(void (**)(uint64_t, uint64_t))(*(void *)v3 + 72LL))(v3, a1 + 116);
  uint64_t v4 = sub_1002E8D54();
  (*(void (**)(uint64_t, uint64_t))(*(void *)v4 + 80LL))(v4, a1 + 117);
  int v5 = *(unsigned __int8 *)(a1 + 116);
  uint64_t v6 = *(void *)sub_1002E6B38();
  if (v5)
  {
LABEL_24:
    *(_DWORD *)(a1 + 112) = 0;
    sub_10040D518(a1);
    sub_10040D8A8(a1);
    sub_10040E234((os_unfair_lock_s *)a1, 0);
    return;
  }

void sub_10040D3BC(uint64_t a1)
{
  uint64_t v2 = sub_1002E8D54();
  sub_10024E060(v2 + 328, a1 + 8);
}

uint64_t sub_10040D3E4(uint64_t a1)
{
  return sub_10040D3EC(a1, 0);
}

uint64_t sub_10040D3EC(uint64_t a1, char a2)
{
  if (*(_DWORD *)(a1 + 112) == 3) {
    return 2LL;
  }
  int v5 = (void *)objc_claimAutoreleasedReturnValue(+[MCProfileConnection sharedConnection](&OBJC_CLASS___MCProfileConnection, "sharedConnection"));
  char v6 = [v5 isBluetoothModificationAllowed] | a2;

  if ((v6 & 1) == 0) {
    return 200LL;
  }
  if (*(_BYTE *)(a1 + 116))
  {
    id v7 = (os_log_s *)qword_1008F7578;
    if (os_log_type_enabled((os_log_t)qword_1008F7578, OS_LOG_TYPE_DEFAULT))
    {
      *(_WORD *)__int128 buf = 0;
      _os_log_impl( (void *)&_mh_execute_header,  v7,  OS_LOG_TYPE_DEFAULT,  "Ignore user preference for airplane mode power state on non-iOS/non-watchOS platforms",  buf,  2u);
    }
  }

  else
  {
    uint64_t v8 = sub_1002E6B38();
    (*(void (**)(uint64_t, uint64_t))(*(void *)v8 + 96LL))(v8, 1LL);
  }

  uint64_t v9 = sub_100404EB8();
  v10[0] = _NSConcreteStackBlock;
  v10[1] = 3221225472LL;
  void v10[2] = sub_10040D510;
  uint64_t v10[3] = &unk_10087EB20;
  v10[4] = a1;
  sub_100405384(v9, v10);
  return 0LL;
}

void sub_10040D500(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_10040D510(uint64_t a1)
{
}

void sub_10040D518(uint64_t a1)
{
  uint64_t v2 = (os_log_s *)qword_1008F7578;
  if (os_log_type_enabled((os_log_t)qword_1008F7578, OS_LOG_TYPE_DEFAULT))
  {
    *(_WORD *)__int128 buf = 0;
    _os_log_impl((void *)&_mh_execute_header, v2, OS_LOG_TYPE_DEFAULT, "Beginning asynchronous power on", buf, 2u);
  }

  if (*(_DWORD *)(a1 + 112) == 1) {
    goto LABEL_16;
  }
  *(_DWORD *)(a1 + 112) = 2;
  uint64_t v3 = sub_1002E6B38();
  int v4 = (*(uint64_t (**)(uint64_t))(*(void *)v3 + 8LL))(v3);
  if (v4)
  {
    int v5 = v4;
    do
    {
      char v6 = (os_log_s *)qword_1008F7578;
      if (os_log_type_enabled((os_log_t)qword_1008F7578, OS_LOG_TYPE_ERROR))
      {
        *(_DWORD *)__int128 buf = 67109120;
        int v12 = v5;
        _os_log_error_impl( (void *)&_mh_execute_header,  v6,  OS_LOG_TYPE_ERROR,  "Power on failed - %{bluetooth:OI_STATUS}u",  buf,  8u);
      }

      sub_10040DDE0();
      uint64_t v7 = sub_1002E6B38();
      int v5 = (*(uint64_t (**)(uint64_t))(*(void *)v7 + 8LL))(v7);
    }

    while (v5);
  }

  if (qword_1008D60B0 != -1) {
    dispatch_once(&qword_1008D60B0, &stru_100896FC8);
  }
  if (!sub_10042E258((uint64_t)off_1008D60A8))
  {
LABEL_16:
    *(_DWORD *)(a1 + 112) = 1;
    uint64_t v9 = mach_absolute_time();
    if ((unint64_t)UpTicksToSeconds(v9 - *(void *)(a1 + 120)) <= 2)
    {
      if (qword_1008D9060 != -1) {
        dispatch_once(&qword_1008D9060, &stru_100896FE8);
      }
      nullsub_63(qword_1008D9058, 1LL);
    }
  }

  else
  {
    if (os_log_type_enabled((os_log_t)qword_1008F7578, OS_LOG_TYPE_ERROR)) {
      sub_10067C18C();
    }
    uint64_t v8 = sub_1002E6B38();
    if ((*(unsigned int (**)(uint64_t))(*(void *)v8 + 16LL))(v8))
    {
      if (os_log_type_enabled((os_log_t)qword_1008F7578, OS_LOG_TYPE_ERROR)) {
        sub_10067C12C();
      }
      uint64_t v10 = sub_1002E6E00();
      sub_1004FC118(v10, 1);
    }

    *(_DWORD *)(a1 + 112) = 0;
  }

  sub_10040E234((os_unfair_lock_s *)a1, *(_DWORD *)(a1 + 112));
}

uint64_t sub_10040D774(uint64_t a1)
{
  return sub_10040D77C(a1, 0);
}

uint64_t sub_10040D77C(uint64_t a1, char a2)
{
  if (*(_DWORD *)(a1 + 112) == 3) {
    return 2LL;
  }
  int v5 = (void *)objc_claimAutoreleasedReturnValue(+[MCProfileConnection sharedConnection](&OBJC_CLASS___MCProfileConnection, "sharedConnection"));
  char v6 = [v5 isBluetoothModificationAllowed] | a2;

  if ((v6 & 1) == 0) {
    return 200LL;
  }
  if (*(_BYTE *)(a1 + 116))
  {
    uint64_t v7 = (os_log_s *)qword_1008F7578;
    if (os_log_type_enabled((os_log_t)qword_1008F7578, OS_LOG_TYPE_DEFAULT))
    {
      *(_WORD *)__int128 buf = 0;
      _os_log_impl( (void *)&_mh_execute_header,  v7,  OS_LOG_TYPE_DEFAULT,  "Ignore user preference for airplane mode power state on non-iOS/non-watchOS platforms",  buf,  2u);
    }
  }

  else
  {
    uint64_t v8 = sub_1002E6B38();
    (*(void (**)(uint64_t, void))(*(void *)v8 + 96LL))(v8, 0LL);
  }

  uint64_t v9 = sub_100404EB8();
  v10[0] = _NSConcreteStackBlock;
  v10[1] = 3221225472LL;
  void v10[2] = sub_10040D8A0;
  uint64_t v10[3] = &unk_10087EB20;
  v10[4] = a1;
  sub_100405384(v9, v10);
  return 0LL;
}

void sub_10040D890(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_10040D8A0(uint64_t a1)
{
}

void sub_10040D8A8(uint64_t a1)
{
  uint64_t v2 = (os_log_s *)qword_1008F7578;
  if (os_log_type_enabled((os_log_t)qword_1008F7578, OS_LOG_TYPE_DEFAULT))
  {
    *(_WORD *)char v6 = 0;
    _os_log_impl((void *)&_mh_execute_header, v2, OS_LOG_TYPE_DEFAULT, "Beginning asynchronous power off", v6, 2u);
  }

  if (*(_DWORD *)(a1 + 112) != 1) {
    goto LABEL_11;
  }
  *(_DWORD *)(a1 + 112) = 2;
  if (qword_1008D60B0 != -1) {
    dispatch_once(&qword_1008D60B0, &stru_100896FC8);
  }
  if (!sub_100430C6C((uint64_t)off_1008D60A8))
  {
    uint64_t v4 = sub_1002E6B38();
    if ((*(unsigned int (**)(uint64_t))(*(void *)v4 + 16LL))(v4))
    {
      if (os_log_type_enabled((os_log_t)qword_1008F7578, OS_LOG_TYPE_ERROR)) {
        sub_10067C12C();
      }
      uint64_t v5 = sub_1002E6E00();
      sub_1004FC118(v5, 1);
    }

uint64_t sub_10040D9F4(uint64_t a1)
{
  uint64_t v2 = sub_100404EB8();
  v4[0] = _NSConcreteStackBlock;
  v4[1] = 3221225472LL;
  void v4[2] = sub_10040DA58;
  v4[3] = &unk_10087EB20;
  v4[4] = a1;
  sub_100405384(v2, v4);
  return 0LL;
}

void sub_10040DA58(uint64_t a1)
{
}

void sub_10040DA60(os_unfair_lock_s *a1)
{
  uint64_t v2 = (os_log_s *)qword_1008F7578;
  if (os_log_type_enabled((os_log_t)qword_1008F7578, OS_LOG_TYPE_DEFAULT))
  {
    *(_WORD *)unsigned int v3 = 0;
    _os_log_impl((void *)&_mh_execute_header, v2, OS_LOG_TYPE_DEFAULT, "Beginning asynchronous power shutdown", v3, 2u);
  }

  if (qword_1008D60B0 != -1) {
    dispatch_once(&qword_1008D60B0, &stru_100896FC8);
  }
  sub_100430C6C((uint64_t)off_1008D60A8);
  a1[28]._os_unfair_lock_opaque = 4;
  sub_10040E234(a1, 4u);
}

uint64_t sub_10040DB10(uint64_t a1)
{
  uint64_t v2 = sub_100404EB8();
  v4[0] = _NSConcreteStackBlock;
  v4[1] = 3221225472LL;
  void v4[2] = sub_10040DB74;
  v4[3] = &unk_10087EB20;
  v4[4] = a1;
  sub_100405384(v2, v4);
  return 0LL;
}

void sub_10040DB74(uint64_t a1)
{
}

void sub_10040DB7C(os_unfair_lock_s *a1)
{
  uint64_t v2 = (os_log_s *)qword_1008F7578;
  if (os_log_type_enabled((os_log_t)qword_1008F7578, OS_LOG_TYPE_DEFAULT))
  {
    *(_WORD *)uint64_t v7 = 0;
    _os_log_impl((void *)&_mh_execute_header, v2, OS_LOG_TYPE_DEFAULT, "Beginning asynchronous power reset", v7, 2u);
  }

  if (qword_1008D60B0 != -1) {
    dispatch_once(&qword_1008D60B0, &stru_100896FC8);
  }
  int v3 = sub_100430C6C((uint64_t)off_1008D60A8);
  if (v3 && os_log_type_enabled((os_log_t)qword_1008F7578, OS_LOG_TYPE_ERROR)) {
    sub_10067C1EC();
  }
  uint64_t v4 = sub_1002E6B38();
  int v5 = (*(uint64_t (**)(uint64_t))(*(void *)v4 + 24LL))(v4);
  if (v5 && os_log_type_enabled((os_log_t)qword_1008F7578, OS_LOG_TYPE_ERROR)) {
    sub_10067C24C();
  }
  if (!(v5 | v3))
  {
    if (qword_1008D60B0 != -1) {
      dispatch_once(&qword_1008D60B0, &stru_100896FC8);
    }
    if (sub_10042E258((uint64_t)off_1008D60A8))
    {
      if (os_log_type_enabled((os_log_t)qword_1008F7578, OS_LOG_TYPE_ERROR)) {
        sub_10067C18C();
      }
      uint64_t v6 = sub_1002E6B38();
      if ((*(unsigned int (**)(uint64_t))(*(void *)v6 + 16LL))(v6))
      {
        if (os_log_type_enabled((os_log_t)qword_1008F7578, OS_LOG_TYPE_ERROR)) {
          sub_10067C12C();
        }
      }
    }

    else
    {
      sub_10040E234(a1, 1u);
    }
  }

uint64_t sub_10040DD44(uint64_t a1)
{
  *(_DWORD *)(a1 + 112) = 2;
  if (qword_1008D60B0 != -1) {
    dispatch_once(&qword_1008D60B0, &stru_100896FC8);
  }
  uint64_t v2 = sub_1004307C0((uint64_t)off_1008D60A8);
  if ((_DWORD)v2)
  {
    if (os_log_type_enabled((os_log_t)qword_1008F7578, OS_LOG_TYPE_ERROR)) {
      sub_10067C2AC();
    }
  }

  else
  {
    *(_DWORD *)(a1 + 112) = 0;
  }

  return v2;
}

uint64_t sub_10040DDD8(uint64_t a1)
{
  return *(unsigned __int8 *)(a1 + 116);
}

BOOL sub_10040DDE0()
{
  uint64_t v0 = sub_1002E8D54();
  if ((*(unsigned int (**)(uint64_t))(*(void *)v0 + 264LL))(v0))
  {
    uint64_t v1 = (os_log_s *)qword_1008F7578;
    if (os_log_type_enabled((os_log_t)qword_1008F7578, OS_LOG_TYPE_DEFAULT))
    {
      *(_WORD *)__int128 buf = 0;
      _os_log_impl( (void *)&_mh_execute_header,  v1,  OS_LOG_TYPE_DEFAULT,  "Bluetooth is running inside a Virtual Machine, so skipping chip initialization",  buf,  2u);
    }

    return sub_1000FCD0C() == 10;
  }

  uint64_t v27 = 0LL;
  __int128 v25 = 0u;
  memset(v26, 0, sizeof(v26));
  __int128 v23 = 0u;
  __int128 v24 = 0u;
  __int128 v21 = 0u;
  __int128 v22 = 0u;
  *(_OWORD *)__int128 buf = 0u;
  __int128 v20 = 0u;
  sub_10020E564((uint64_t)buf);
  while (1)
  {
    int v3 = (uint64_t (***)(void))sub_1002E6B38();
    uint64_t v4 = (**v3)(v3);
    uint64_t v5 = v4;
    if ((_DWORD)v4 == 2)
    {
      uint64_t v9 = "Unknown platform/chipset/manufacturer combination, restarting";
      uint64_t v10 = 61LL;
      goto LABEL_16;
    }

    if ((_DWORD)v4 != 213) {
      break;
    }
    uint64_t v9 = "timed out booting the chip, restarting";
    uint64_t v10 = 38LL;
LABEL_16:
    sub_1001FD17C(buf, (uint64_t)v9, v10);
    int v8 = 1;
LABEL_17:
    uint64_t v11 = (os_log_s *)qword_1008F7578;
    if (os_log_type_enabled((os_log_t)qword_1008F7578, OS_LOG_TYPE_ERROR))
    {
      std::stringbuf::str(&v17, (const std::stringbuf *)&buf[8]);
      int v12 = &v17;
      if ((v17.__r_.__value_.__s.__size_ & 0x80u) != 0) {
        int v12 = (std::stringbuf::string_type *)v17.__r_.__value_.__r.__words[0];
      }
      LODWORD(v28.__r_.__value_.__l.__data_) = 136315394;
      *(std::string::size_type *)((char *)v28.__r_.__value_.__r.__words + 4) = (std::string::size_type)v12;
      WORD2(v28.__r_.__value_.__r.__words[1]) = 1024;
      *(_DWORD *)((char *)&v28.__r_.__value_.__r.__words[1] + 6) = v5;
      _os_log_error_impl( (void *)&_mh_execute_header,  v11,  OS_LOG_TYPE_ERROR,  "%s - %{bluetooth:OI_STATUS}u",  (uint8_t *)&v28,  0x12u);
      if ((v8 & 1) != 0)
      {
LABEL_29:
        sub_1000AFE1C();
        uint64_t v13 = sub_1002E8D94();
        std::stringbuf::str(&v28, (const std::stringbuf *)&buf[8]);
        if ((v28.__r_.__value_.__s.__size_ & 0x80u) == 0) {
          __int128 v14 = &v28;
        }
        else {
          __int128 v14 = (std::stringbuf::string_type *)v28.__r_.__value_.__r.__words[0];
        }
        sub_10002418C(&v17, (char *)v14);
        (*(void (**)(uint64_t, void, std::stringbuf::string_type *))(*(void *)v13 + 112LL))( v13,  (unsigned __int16)v5,  &v17);
        if (qword_1008D60B0 != -1) {
          dispatch_once(&qword_1008D60B0, &stru_100896FC8);
        }
        uint64_t v15 = off_1008D60A8;
        std::stringbuf::str(&v16, (const std::stringbuf *)&buf[8]);
        sub_100433FBC((uint64_t)v15, v5, 0, (uint64_t)&v16);
        usleep(0xF4240u);
        _exit(1);
      }
    }

    else if (v8)
    {
      goto LABEL_29;
    }
  }

  if ((_DWORD)v4)
  {
    uint64_t v6 = sub_1001FD17C(buf, (uint64_t)"Init failed, still in high power result=", 40LL);
    std::ostream::operator<<(v6, v5);
    if (qword_1008D60B0 != -1) {
      dispatch_once(&qword_1008D60B0, &stru_100896FC8);
    }
    uint64_t v7 = off_1008D60A8;
    std::stringbuf::str(&v18, (const std::stringbuf *)&buf[8]);
    sub_100433FBC((uint64_t)v7, v5, 1, (uint64_t)&v18);
    int v8 = 0;
    goto LABEL_17;
  }

  if (SHIBYTE(v24) < 0) {
    operator delete(*((void **)&v23 + 1));
  }
  std::streambuf::~streambuf(&buf[8]);
  std::ios::~ios(v26);
  return 1LL;
}

void sub_10040E1B4( _Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, void *__p, uint64_t a13, int a14, __int16 a15, char a16, char a17, void *a18, uint64_t a19, int a20, __int16 a21, char a22, char a23, uint64_t a24, uint64_t a25, int a26, __int16 a27, char a28, char a29, char a30)
{
  if (a17 < 0) {
    operator delete(__p);
  }
  sub_10020E784((uint64_t)&a30);
  _Unwind_Resume(a1);
}

void sub_10040E234(os_unfair_lock_s *a1, unsigned int a2)
{
  uint64_t v4 = (os_log_s *)qword_1008F7578;
  if (os_log_type_enabled((os_log_t)qword_1008F7578, OS_LOG_TYPE_DEFAULT))
  {
    *(_DWORD *)__int128 buf = 67109120;
    unsigned int v12 = a2;
    _os_log_impl( (void *)&_mh_execute_header,  v4,  OS_LOG_TYPE_DEFAULT,  "Sending 'power state changed' event for local device - {powerstate: %d}",  buf,  8u);
  }

  uint64_t v5 = (os_log_s *)qword_1008F7678;
  if (os_log_type_enabled((os_log_t)qword_1008F7678, OS_LOG_TYPE_DEFAULT))
  {
    *(_DWORD *)__int128 buf = 67109120;
    unsigned int v12 = a2;
    _os_log_impl((void *)&_mh_execute_header, v5, OS_LOG_TYPE_DEFAULT, "Power state change - {powerstate: %d}", buf, 8u);
  }

  if (a2 <= 1)
  {
    uint64_t v6 = sub_100404EB8();
    v9[0] = _NSConcreteStackBlock;
    v9[1] = 3221225472LL;
    void v9[2] = sub_10040E860;
    v9[3] = &unk_10087F980;
    unsigned int v10 = a2;
    sub_100405384(v6, v9);
  }

  v7[0] = _NSConcreteStackBlock;
  v7[1] = 3221225472LL;
  void v7[2] = sub_10040E988;
  v7[3] = &unk_100896FA8;
  unsigned int v8 = a2;
  sub_10040E8CC(a1 + 20, v7);
}

void sub_10040E3A0(uint64_t a1, int a2)
{
  uint64_t v4 = (os_log_s *)qword_1008F7578;
  if (os_log_type_enabled((os_log_t)qword_1008F7578, OS_LOG_TYPE_DEFAULT))
  {
    uint64_t v5 = "false";
    if (a2) {
      uint64_t v5 = "true";
    }
    int v29 = 136446210;
    uint64_t v30 = v5;
    _os_log_impl( (void *)&_mh_execute_header,  v4,  OS_LOG_TYPE_DEFAULT,  "Setting airplane mode to %{public}s",  (uint8_t *)&v29,  0xCu);
  }

  *(_BYTE *)(a1 + 116) = a2;
  uint64_t v6 = (void *)objc_claimAutoreleasedReturnValue(+[MCProfileConnection sharedConnection](&OBJC_CLASS___MCProfileConnection, "sharedConnection"));
  unsigned __int8 v7 = [v6 isBluetoothModificationAllowed];

  if ((v7 & 1) != 0)
  {
    int v8 = *(_DWORD *)(a1 + 112);
    if ((a2 & 1) != 0)
    {
      if (!v8)
      {
        uint64_t v9 = (os_log_s *)qword_1008F7578;
        if (os_log_type_enabled((os_log_t)qword_1008F7578, OS_LOG_TYPE_DEFAULT))
        {
          LOWORD(v29) = 0;
          _os_log_impl( (void *)&_mh_execute_header,  v9,  OS_LOG_TYPE_DEFAULT,  "Override power state transition : Don't turn on bluetooth in airplane mode if current power state is off",  (uint8_t *)&v29,  2u);
        }

        uint64_t v10 = sub_1002E6B38();
        (*(void (**)(uint64_t, void))(*(void *)v10 + 112LL))(v10, 0LL);
LABEL_21:
        char v15 = 1;
LABEL_23:
        uint64_t v16 = sub_1002E6B38();
        int v17 = (*(uint64_t (**)(uint64_t))(*(void *)v16 + 104LL))(v16);
        uint64_t v18 = sub_1002E6B38();
        int v19 = (*(uint64_t (**)(uint64_t))(*(void *)v18 + 88LL))(v18);
        if (qword_1008D60B0 != -1) {
          dispatch_once(&qword_1008D60B0, &stru_100896FC8);
        }
        int v20 = sub_100435710((uint64_t)off_1008D60A8);
        if (a2)
        {
          if ((v15 & 1) == 0)
          {
            int v21 = *(_DWORD *)(a1 + 112);
            if (v17 == 1)
            {
              int v22 = v20;
              if (v21 != 1)
              {
                __int128 v23 = (os_log_s *)qword_1008F7578;
                if (os_log_type_enabled((os_log_t)qword_1008F7578, OS_LOG_TYPE_DEFAULT))
                {
                  LOWORD(v29) = 0;
                  _os_log_impl( (void *)&_mh_execute_header,  v23,  OS_LOG_TYPE_DEFAULT,  "Turn power on for airplane mode",  (uint8_t *)&v29,  2u);
                }

                sub_10040D518(a1);
              }

              if (v22 == 2)
              {
                __int128 v24 = (os_log_s *)qword_1008F7578;
                if (os_log_type_enabled((os_log_t)qword_1008F7578, OS_LOG_TYPE_DEFAULT))
                {
                  LOWORD(v29) = 0;
                  _os_log_impl( (void *)&_mh_execute_header,  v24,  OS_LOG_TYPE_DEFAULT,  "Default airplane mode denylist state is enabled. Entering grant list mode for AirplaneMode",  (uint8_t *)&v29,  2u);
                }

                if (qword_1008D60B0 != -1) {
                  dispatch_once(&qword_1008D60B0, &stru_100896FC8);
                }
                sub_10042FC90((uint64_t)off_1008D60A8, 1);
              }
            }

            else if (!v17 && v21)
            {
              uint64_t v27 = (os_log_s *)qword_1008F7578;
              if (os_log_type_enabled((os_log_t)qword_1008F7578, OS_LOG_TYPE_DEFAULT))
              {
                LOWORD(v29) = 0;
                _os_log_impl( (void *)&_mh_execute_header,  v27,  OS_LOG_TYPE_DEFAULT,  "Turn power off for airplane mode",  (uint8_t *)&v29,  2u);
              }

              sub_10040D8A8(a1);
            }
          }
        }

        else
        {
          if (*(_DWORD *)(a1 + 112) == v19) {
            char v25 = 1;
          }
          else {
            char v25 = v15;
          }
          if ((v25 & 1) == 0)
          {
            if (v19)
            {
              if (v19 == 1)
              {
                size_t v26 = (os_log_s *)qword_1008F7578;
                if (os_log_type_enabled((os_log_t)qword_1008F7578, OS_LOG_TYPE_DEFAULT))
                {
                  LOWORD(v29) = 0;
                  _os_log_impl( (void *)&_mh_execute_header,  v26,  OS_LOG_TYPE_DEFAULT,  "Exiting airplane mode : Turn power on",  (uint8_t *)&v29,  2u);
                }

                sub_10040D518(a1);
              }
            }

            else
            {
              std::stringbuf::string_type v28 = (os_log_s *)qword_1008F7578;
              if (os_log_type_enabled((os_log_t)qword_1008F7578, OS_LOG_TYPE_DEFAULT))
              {
                LOWORD(v29) = 0;
                _os_log_impl( (void *)&_mh_execute_header,  v28,  OS_LOG_TYPE_DEFAULT,  "Exiting airplane mode : Turn power off",  (uint8_t *)&v29,  2u);
              }

              sub_10040D8A8(a1);
            }
          }

          if (qword_1008D60B0 != -1) {
            dispatch_once(&qword_1008D60B0, &stru_100896FC8);
          }
          sub_10042FC90((uint64_t)off_1008D60A8, 0);
        }

        return;
      }
    }

    else if (v8)
    {
      uint64_t v13 = (os_log_s *)qword_1008F7578;
      if (os_log_type_enabled((os_log_t)qword_1008F7578, OS_LOG_TYPE_DEFAULT))
      {
        LOWORD(v29) = 0;
        _os_log_impl( (void *)&_mh_execute_header,  v13,  OS_LOG_TYPE_DEFAULT,  "Override power state transition : Don't turn off bluetooth in normal mode if current airplane mode power is on",  (uint8_t *)&v29,  2u);
      }

      uint64_t v14 = sub_1002E6B38();
      (*(void (**)(uint64_t, uint64_t))(*(void *)v14 + 96LL))(v14, 1LL);
      goto LABEL_21;
    }

    char v15 = 0;
    goto LABEL_23;
  }

  uint64_t v11 = (os_log_s *)qword_1008F7578;
  if (os_log_type_enabled((os_log_t)qword_1008F7578, OS_LOG_TYPE_DEFAULT))
  {
    unsigned int v12 = "false";
    if (a2) {
      unsigned int v12 = "true";
    }
    int v29 = 136446210;
    uint64_t v30 = v12;
    _os_log_impl( (void *)&_mh_execute_header,  v11,  OS_LOG_TYPE_DEFAULT,  "Bluetooth modification is not allowed. Ignore airplane mode change to %{public}s",  (uint8_t *)&v29,  0xCu);
  }

void sub_10040E838(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_10040E850(uint64_t a1, int a2)
{
}

uint64_t sub_10040E860(uint64_t a1)
{
  int v1 = *(_DWORD *)(a1 + 32);
  if (qword_1008D6198 != -1) {
    dispatch_once(&qword_1008D6198, &stru_100897008);
  }
  uint64_t v2 = v1 == 1;
  sub_100447F14((uint64_t)off_1008D6190, v2);
  uint64_t v3 = sub_1002E8D94();
  return (*(uint64_t (**)(uint64_t, uint64_t))(*(void *)v3 + 144LL))(v3, v2);
}

void sub_10040E8CC(os_unfair_lock_s *a1, void *a2)
{
  uint64_t v3 = a2;
  os_unfair_lock_lock(a1);
  uint64_t v5 = 0LL;
  uint64_t v6 = 0LL;
  uint64_t v7 = 0LL;
  sub_100240540(&v5, (uint64_t)&a1[2]);
  os_unfair_lock_unlock(a1);
  uint64_t v4 = v5;
  if (v5 != v6)
  {
    do
      v3[2](v3, *v4++);
    while (v4 != v6);
    uint64_t v4 = v5;
  }

  if (v4)
  {
    uint64_t v6 = v4;
    operator delete(v4);
  }
}

void sub_10040E960( _Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void *__p, uint64_t a11)
{
  _Unwind_Resume(a1);
}

uint64_t sub_10040E988(uint64_t a1, uint64_t (***a2)(void, uint64_t, void))
{
  return (**a2)(a2, 1LL, *(unsigned int *)(a1 + 32));
}

uint64_t sub_10040E9A0(uint64_t a1)
{
  v24[0] = 0LL;
  v24[1] = 0LL;
  sub_100242F28((uint64_t)v24, a1 + 16);
  uint64_t v2 = (os_log_s *)qword_1008F7578;
  if (os_log_type_enabled((os_log_t)qword_1008F7578, OS_LOG_TYPE_DEFAULT))
  {
    *(_WORD *)__int128 buf = 0;
    _os_log_impl((void *)&_mh_execute_header, v2, OS_LOG_TYPE_DEFAULT, "statedump: Power Assertion History:", buf, 2u);
  }

  double Current = CFAbsoluteTimeGetCurrent();
  int v21 = objc_alloc_init(&OBJC_CLASS___NSDateFormatter);
  -[NSDateFormatter setDateFormat:](v21, "setDateFormat:", @"yyyy-MM-dd H:mm:ss");
  uint64_t v4 = *(void *)(a1 + 152);
  for (i = a1 + 144; v4 != i; uint64_t v4 = *(void *)(v4 + 8))
  {
    int v5 = *(_DWORD *)(v4 + 20);
    uint64_t v6 = *(int *)(v4 + 16);
    int v7 = *(_DWORD *)(v4 + 24);
    double v8 = *(double *)(v4 + 32);
    int v9 = *(_DWORD *)(v4 + 40);
    char v10 = *(_BYTE *)(v4 + 44);
    int v11 = *(_DWORD *)(v4 + 48);
    __int128 v23 = (void *)objc_claimAutoreleasedReturnValue( +[NSDate dateWithTimeIntervalSinceReferenceDate:]( &OBJC_CLASS___NSDate,  "dateWithTimeIntervalSinceReferenceDate:",  v8));
    unsigned int v12 = (void *)objc_claimAutoreleasedReturnValue(-[NSDateFormatter stringFromDate:](v21, "stringFromDate:"));
    LODWORD(v13) = llround((v8 - floor(v8)) * 1000.0);
    uint64_t v14 = (void *)objc_claimAutoreleasedReturnValue( +[NSString stringWithFormat:]( &OBJC_CLASS___NSString,  "stringWithFormat:",  @"%@.%000d",  v12,  v13));
    log = (os_log_s *)qword_1008F7578;
    if (os_log_type_enabled((os_log_t)qword_1008F7578, OS_LOG_TYPE_DEFAULT))
    {
      id v15 = [v14 UTF8String];
      uint64_t v16 = "Unknown";
      int v17 = "Unknown";
      if (v5 == 1) {
        int v17 = "Destroy";
      }
      if (!v5) {
        int v17 = "Create";
      }
      uint64_t v18 = @"com.apple.bluetooth.LeBroadcaster.AdvertisingConfigAssertion";
      *(_DWORD *)__int128 buf = 136317186;
      id v26 = v15;
      __int16 v27 = 2048;
      double v28 = v8;
      __int16 v29 = 2048;
      double v30 = Current - v8;
      __int16 v31 = 2080;
      char v32 = v16;
      __int16 v33 = 2080;
      uint64_t v34 = v17;
      __int16 v35 = 2112;
      char v36 = v18;
      __int16 v37 = 1024;
      int v38 = v9;
      __int16 v39 = 1024;
      int v40 = v10 & 1;
      __int16 v41 = 1024;
      int v42 = v11;
      _os_log_impl( (void *)&_mh_execute_header,  log,  OS_LOG_TYPE_DEFAULT,  "statedump: time:%s %.3f secs(%-12.2f secs ago) source:%-22s event:%-7s %@ ret:%d fw:%d ID:%08X",  buf,  0x50u);
    }
  }

  return sub_100242FAC((uint64_t)v24);
}

void sub_10040EC80( _Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, void *a7, uint64_t a8, uint64_t a9, ...)
{
  sub_100242FAC((uint64_t)va);
  _Unwind_Resume(a1);
}

uint64_t sub_10040ECDC(uint64_t a1)
{
  uint64_t v2 = (os_log_s *)qword_1008F7578;
  if (os_log_type_enabled((os_log_t)qword_1008F7578, OS_LOG_TYPE_DEFAULT))
  {
    LOWORD(v7) = 0;
    _os_log_impl( (void *)&_mh_execute_header,  v2,  OS_LOG_TYPE_DEFAULT,  "statedump: ------------------- Power Manager -------------------",  (uint8_t *)&v7,  2u);
    uint64_t v2 = (os_log_s *)qword_1008F7578;
  }

  if (os_log_type_enabled(v2, OS_LOG_TYPE_DEFAULT))
  {
    if (*(_BYTE *)(a1 + 116)) {
      uint64_t v3 = "On";
    }
    else {
      uint64_t v3 = "Off";
    }
    int v7 = 136446210;
    double v8 = v3;
    _os_log_impl( (void *)&_mh_execute_header,  v2,  OS_LOG_TYPE_DEFAULT,  "statedump: Airplane Mode: %{public}s",  (uint8_t *)&v7,  0xCu);
    uint64_t v2 = (os_log_s *)qword_1008F7578;
  }

  if (os_log_type_enabled(v2, OS_LOG_TYPE_DEFAULT))
  {
    if (*(_BYTE *)(a1 + 117)) {
      uint64_t v4 = "On";
    }
    else {
      uint64_t v4 = "Off";
    }
    int v7 = 136446210;
    double v8 = v4;
    _os_log_impl( (void *)&_mh_execute_header,  v2,  OS_LOG_TYPE_DEFAULT,  "statedump: Low Power Mode: %{public}s",  (uint8_t *)&v7,  0xCu);
    uint64_t v2 = (os_log_s *)qword_1008F7578;
  }

  if (os_log_type_enabled(v2, OS_LOG_TYPE_DEFAULT))
  {
    if (*(_DWORD *)(a1 + 112)) {
      int v5 = "On";
    }
    else {
      int v5 = "Off";
    }
    int v7 = 136446210;
    double v8 = v5;
    _os_log_impl( (void *)&_mh_execute_header,  v2,  OS_LOG_TYPE_DEFAULT,  "statedump: Power State: %{public}s",  (uint8_t *)&v7,  0xCu);
  }

  return sub_10040E9A0(a1);
}

uint64_t sub_10040EE8C(uint64_t a1, int *a2)
{
  v21[0] = 0LL;
  v21[1] = 0LL;
  sub_100242F28((uint64_t)v21, a1 + 16);
  unint64_t v4 = *(void *)(a1 + 160);
  if (v4 >= 0x1F4)
  {
    int v5 = (os_log_s *)qword_1008F7578;
    if (os_log_type_enabled((os_log_t)qword_1008F7578, OS_LOG_TYPE_DEBUG)) {
      sub_10067C30C(v4 - 499, v4, v5);
    }
    if ((_WORD)v4 == 499)
    {
      int v7 = *(uint64_t **)(a1 + 152);
    }

    else
    {
      unint64_t v6 = (unsigned __int16)(v4 - 499) + 1LL;
      int v7 = *(uint64_t **)(a1 + 152);
      do
      {
        int v7 = (uint64_t *)v7[1];
        --v6;
      }

      while (v6 > 1);
    }

    sub_10040F0C4(a1 + 144, *(uint64_t **)(a1 + 152), v7);
  }

  double v8 = operator new(0x38uLL);
  __int128 v9 = *((_OWORD *)a2 + 1);
  v8[1] = *(_OWORD *)a2;
  v8[2] = v9;
  *((void *)v8 + 6) = *((void *)a2 + 4);
  uint64_t v10 = *(void *)(a1 + 144);
  *(void *)double v8 = v10;
  *((void *)v8 + 1) = a1 + 144;
  *(void *)(v10 + _Block_object_dispose(va, 8) = v8;
  *(void *)(a1 + 144) = v8;
  ++*(void *)(a1 + 160);
  int v11 = (os_log_s *)qword_1008F7578;
  if (os_log_type_enabled((os_log_t)qword_1008F7578, OS_LOG_TYPE_DEFAULT))
  {
    uint64_t v12 = *a2;
    uint64_t v13 = "Unknown";
    uint64_t v14 = "Unknown";
    uint64_t v15 = *((void *)a2 + 2);
    int v16 = a2[1];
    int v17 = a2[2];
    if (v16 == 1) {
      uint64_t v13 = "Destroy";
    }
    if (!v16) {
      uint64_t v13 = "Create";
    }
    else {
      uint64_t v18 = off_100897060[v17 - 1];
    }
    int v19 = a2[8];
    *(_DWORD *)__int128 buf = 134219010;
    uint64_t v23 = v15;
    __int16 v24 = 2080;
    char v25 = v14;
    __int16 v26 = 2080;
    __int16 v27 = v13;
    __int16 v28 = 2112;
    __int16 v29 = v18;
    __int16 v30 = 1024;
    int v31 = v19;
    _os_log_impl( (void *)&_mh_execute_header,  v11,  OS_LOG_TYPE_DEFAULT,  "PowerAssertionHistory push time:%.2f source:%s event:%s %@ ID:%08X",  buf,  0x30u);
  }

  return sub_100242FAC((uint64_t)v21);
}

void sub_10040F0A4( _Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9)
{
}

uint64_t *sub_10040F0C4(uint64_t a1, uint64_t *__p, uint64_t *a3)
{
  if (__p != a3)
  {
    uint64_t v5 = *a3;
    uint64_t v6 = *__p;
    *(void *)(v6 + _Block_object_dispose(va, 8) = *(void *)(*a3 + 8);
    **(void **)(v5 + _Block_object_dispose(va, 8) = v6;
    do
    {
      int v7 = (uint64_t *)__p[1];
      --*(void *)(a1 + 16);
      operator delete(__p);
      std::string __p = v7;
    }

    while (v7 != a3);
  }

  return a3;
}

void sub_10040F134(uint64_t a1)
{
  double Current = CFAbsoluteTimeGetCurrent();
  v27[0] = 0LL;
  v27[1] = 0LL;
  __int16 v26 = (uint64_t *)v27;
  if (*(_BYTE *)(a1 + 136))
  {
    uint64_t v3 = *(void *)(a1 + 152);
    if (v3 != a1 + 144)
    {
      double v4 = Current;
      char v5 = 0;
      do
      {
        uint64_t v25 = 0LL;
        __int128 v24 = 0u;
        __int128 v6 = *(_OWORD *)(v3 + 16);
        __int128 v7 = *(_OWORD *)(v3 + 32);
        uint64_t v25 = *(void *)(v3 + 48);
        *(_OWORD *)uint64_t v23 = v6;
        __int128 v24 = v7;
        int v8 = DWORD1(v6);
        if (!DWORD1(v6))
        {
          sub_10040F5F0(&v26, (unsigned int *)&v25, &v25, (uint64_t)v23);
          int v8 = HIDWORD(v23[0]);
        }

        if (v8 == 1)
        {
          __int128 v9 = v27[0];
          if (v27[0])
          {
            uint64_t v10 = (double *)v27;
            do
            {
              int v11 = (double *)v9;
              uint64_t v12 = v10;
              unsigned int v13 = *((_DWORD *)v9 + 8);
              else {
                ++v9;
              }
              __int128 v9 = (void *)*v9;
            }

            while (v9);
            if (v10 != (double *)v27)
            {
              if (v25 >= *((_DWORD *)v11 + 8))
              {
                BOOL v14 = v10[7] - *(double *)&v24 > 5400.0;
                sub_10040F6C0((uint64_t)&v26, (unsigned int *)&v25);
                v5 |= v14;
              }
            }
          }
        }

        uint64_t v3 = *(void *)(v3 + 8);
      }

      while (v3 != a1 + 144);
      uint64_t v15 = v26;
      if (v26 != (uint64_t *)v27)
      {
        do
        {
          BOOL v16 = v4 - *((double *)v15 + 7) > 5400.0;
          int v17 = (uint64_t *)v15[1];
          if (v17)
          {
            do
            {
              uint64_t v18 = v17;
              int v17 = (uint64_t *)*v17;
            }

            while (v17);
          }

          else
          {
            do
            {
              uint64_t v18 = (uint64_t *)v15[2];
              BOOL v19 = *v18 == (void)v15;
              uint64_t v15 = v18;
            }

            while (!v19);
          }

          v5 |= v16;
          uint64_t v15 = v18;
        }

        while (v18 != (uint64_t *)v27);
      }

      if ((v5 & 1) != 0)
      {
        if (qword_1008D9060 != -1) {
          dispatch_once(&qword_1008D9060, &stru_100896FE8);
        }
        uint64_t v20 = qword_1008D9058;
        sub_10002418C(v23, "Assertion");
        sub_10002418C(__p, "MAX_ASSERTION_TIME_SECONDS");
        sub_10040C784(0.0, v20, (uint64_t *)v23, (uint64_t *)__p);
        if (v22 < 0) {
          operator delete(__p[0]);
        }
        if (SBYTE7(v24) < 0) {
          operator delete(v23[0]);
        }
        *(CFAbsoluteTime *)(a1 + 12_Block_object_dispose(va, 8) = CFAbsoluteTimeGetCurrent();
      }
    }
  }

  sub_10023BF24((uint64_t)&v26, v27[0]);
}

void sub_10040F374( _Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void *__p, uint64_t a11, int a12, __int16 a13, char a14, char a15, void *a16, uint64_t a17, int a18, __int16 a19, char a20, char a21, uint64_t a22, uint64_t a23, char a24, void *a25)
{
}

void *sub_10040F3C8(void *a1)
{
  *a1 = off_100896F58;
  a1[1] = off_100896F98;
  sub_10023DF50(a1 + 18);
  uint64_t v2 = (void *)a1[11];
  if (v2)
  {
    a1[12] = v2;
    operator delete(v2);
  }

  sub_100242E28(a1 + 2);
  return a1;
}

void sub_10040F414(void *a1)
{
  *a1 = off_100896F58;
  a1[1] = off_100896F98;
  sub_10023DF50(a1 + 18);
  uint64_t v2 = (void *)a1[11];
  if (v2)
  {
    a1[12] = v2;
    operator delete(v2);
  }

  sub_100242E28(a1 + 2);
  operator delete(a1);
}

void sub_10040F460(id a1)
{
  int v1 = operator new(0x230uLL);
  sub_10042BC28();
  off_1008D60A8 = v1;
}

void sub_10040F490(_Unwind_Exception *a1)
{
}

void sub_10040F4A4(id a1)
{
  int v1 = operator new(0x18uLL);
  *(void *)int v1 = 0LL;
  v1[2] = 0;
  *((_BYTE *)v1 + 12) = 0;
  v1[4] = 0;
  qword_1008D9058 = (uint64_t)v1;
}

void sub_10040F4D4(id a1)
{
  int v1 = (char *)operator new(0x200uLL);
  *(void *)int v1 = off_100898F60;
  *((void *)v1 + 1) = &off_100898FF0;
  *((void *)v1 + 2) = off_100899008;
  *((void *)v1 + 3) = &off_100899060;
  *((void *)v1 + 4) = &off_100899078;
  sub_100242DC4(v1 + 40);
  *((void *)v1 + 14) = 0LL;
  *((_DWORD *)v1 + 30) = 0;
  *((void *)v1 + 17) = 0LL;
  *((void *)v1 + 1_Block_object_dispose(va, 8) = 0LL;
  *((void *)v1 + 16) = 0LL;
  *(_OWORD *)(v1 + 155) = 0u;
  *(_OWORD *)(v1 + 171) = 0u;
  *(_OWORD *)(v1 + 187) = 0u;
  *(_WORD *)(v1 + 203) = 1;
  *((void *)v1 + 26) = 0LL;
  *((_WORD *)v1 + 10_Block_object_dispose(va, 8) = 256;
  *((void *)v1 + 29) = 0LL;
  *((void *)v1 + 2_Block_object_dispose(va, 8) = v1 + 232;
  *((void *)v1 + 32) = 0LL;
  *((void *)v1 + 33) = 0LL;
  *((void *)v1 + 30) = 0LL;
  *((void *)v1 + 31) = v1 + 256;
  v1[272] = 0;
  *((_DWORD *)v1 + 69) = 0;
  v1[280] = 0;
  *((_WORD *)v1 + 189) = 0;
  *(void *)(v1 + 313) = 0LL;
  *(_OWORD *)(v1 + 300) = 0u;
  *(_OWORD *)(v1 + 284) = 0u;
  *(_OWORD *)(v1 + 32_Block_object_dispose(va, 8) = 0u;
  *(_OWORD *)(v1 + 344) = 0u;
  *(_OWORD *)(v1 + 360) = 0u;
  v1[376] = 0;
  *((void *)v1 + 51) = v1 + 416;
  *((void *)v1 + 52) = 0LL;
  *((void *)v1 + 55) = 0LL;
  *((void *)v1 + 56) = 0LL;
  *((void *)v1 + 53) = 0LL;
  *((void *)v1 + 54) = v1 + 440;
  *((void *)v1 + 57) = v1 + 464;
  *((void *)v1 + 5_Block_object_dispose(va, 8) = 0LL;
  *((void *)v1 + 59) = 0LL;
  *((void *)v1 + 60) = @"XZ";
  *((void *)v1 + 62) = 0LL;
  *((_DWORD *)v1 + 126) = 0;
  off_1008D6190 = v1;
}

void sub_10040F5DC(_Unwind_Exception *a1)
{
}

uint64_t **sub_10040F5F0(uint64_t **a1, unsigned int *a2, _DWORD *a3, uint64_t a4)
{
  int v8 = a1 + 1;
  __int128 v7 = a1[1];
  if (v7)
  {
    unsigned int v9 = *a2;
    while (1)
    {
      while (1)
      {
        uint64_t v10 = (uint64_t **)v7;
        unsigned int v11 = *((_DWORD *)v7 + 8);
        if (v9 >= v11) {
          break;
        }
        __int128 v7 = *v10;
        int v8 = v10;
        if (!*v10) {
          goto LABEL_10;
        }
      }

      if (v11 >= v9) {
        break;
      }
      __int128 v7 = v10[1];
      if (!v7)
      {
        int v8 = v10 + 1;
        goto LABEL_10;
      }
    }
  }

  else
  {
    uint64_t v10 = a1 + 1;
LABEL_10:
    uint64_t v12 = (char *)operator new(0x50uLL);
    *((_DWORD *)v12 + _Block_object_dispose(va, 8) = *a3;
    __int128 v13 = *(_OWORD *)(a4 + 16);
    *(_OWORD *)(v12 + 40) = *(_OWORD *)a4;
    *(_OWORD *)(v12 + 56) = v13;
    *((void *)v12 + 9) = *(void *)(a4 + 32);
    sub_100029630(a1, (uint64_t)v10, v8, (uint64_t *)v12);
    return (uint64_t **)v12;
  }

  return v10;
}

uint64_t sub_10040F6C0(uint64_t a1, unsigned int *a2)
{
  uint64_t v2 = *(void *)(a1 + 8);
  if (!v2) {
    return 0LL;
  }
  unsigned int v3 = *a2;
  uint64_t v4 = a1 + 8;
  do
  {
    unsigned int v5 = *(_DWORD *)(v2 + 32);
    BOOL v6 = v5 >= v3;
    if (v5 >= v3) {
      __int128 v7 = (uint64_t *)v2;
    }
    else {
      __int128 v7 = (uint64_t *)(v2 + 8);
    }
    if (v6) {
      uint64_t v4 = v2;
    }
    uint64_t v2 = *v7;
  }

  while (*v7);
  if (v4 == a1 + 8 || v3 < *(_DWORD *)(v4 + 32)) {
    return 0LL;
  }
  sub_1001FDBCC((uint64_t **)a1, (uint64_t *)v4);
  operator delete((void *)v4);
  return 1LL;
}

uint64_t sub_10040F738(uint64_t a1, int a2, uint64_t a3)
{
  *(_DWORD *)a1 = a2;
  uint64_t v4 = *(void *)(a3 + 8);
  *(void *)(a1 + _Block_object_dispose(va, 8) = &off_10087FAA8;
  *(void *)(a1 + 16) = v4;
  if (v4) {
    sub_1002CD1E0(v4);
  }
  *(void *)(a1 + 24) = 0LL;
  return a1;
}

size_t sub_10040F778(uint64_t a1, void *a2, size_t a3)
{
  size_t result = sub_10056ACE0(a1 + 8, a2, *(void *)(a1 + 24), a3);
  *(void *)(a1 + 24) += result;
  return result;
}

uint64_t sub_10040F7B0(uint64_t a1)
{
  unsigned __int8 __dst = 0;
  *(void *)(a1 + 24) += sub_10056ACE0(a1 + 8, &__dst, *(void *)(a1 + 24), 1uLL);
  return __dst;
}

uint64_t sub_10040F7FC(uint64_t a1)
{
  unsigned __int16 __dst = 0;
  *(void *)(a1 + 24) += sub_10056ACE0(a1 + 8, &__dst, *(void *)(a1 + 24), 2uLL);
  unsigned int v2 = bswap32(__dst) >> 16;
  if (*(_DWORD *)a1 == 1) {
    return (unsigned __int16)v2;
  }
  else {
    return __dst;
  }
}

uint64_t sub_10040F860(uint64_t a1)
{
  unsigned int __dst = 0;
  *(void *)(a1 + 24) += sub_10056ACE0(a1 + 8, &__dst, *(void *)(a1 + 24), 4uLL);
  unsigned int v2 = bswap32(__dst);
  if (*(_DWORD *)a1 == 1) {
    return v2;
  }
  else {
    return __dst;
  }
}

unint64_t sub_10040F8BC(uint64_t a1, uint64_t a2)
{
  unint64_t v3 = *(void *)(a1 + 24) + a2;
  *(void *)(a1 + 24) = v3;
  uint64_t v4 = a1 + 8;
  unint64_t result = sub_10056AAD8(a1 + 8);
  if (v3 > result)
  {
    unint64_t result = sub_10056AAD8(v4);
    *(void *)(a1 + 24) = result;
  }

  return result;
}

uint64_t sub_10040F90C(uint64_t result, int a2)
{
  *(_DWORD *)unint64_t result = a2;
  *(void *)(result + 16) = 0LL;
  *(void *)(result + 24) = 0LL;
  *(void *)(result + _Block_object_dispose(va, 8) = 0LL;
  return result;
}

char *sub_10040F91C(uint64_t a1, char *__src, int64_t a3)
{
  return sub_10023E170(a1 + 8, *(char **)(a1 + 16), __src, &__src[a3], a3);
}

char *sub_10040F938(uint64_t a1, char a2)
{
  char __src = a2;
  return sub_10023E170(a1 + 8, *(char **)(a1 + 16), &__src, (char *)&vars0, 1LL);
}

char *sub_10040F974(uint64_t a1, __int16 a2)
{
  __int16 __src = a2;
  if (*(_DWORD *)a1 == 1) {
    __int16 __src = __rev16(a2);
  }
  return sub_10023E170(a1 + 8, *(char **)(a1 + 16), (char *)&__src, (char *)&vars0, 2LL);
}

char *sub_10040F9C4(uint64_t a1, unsigned int a2)
{
  unsigned int __src = a2;
  if (*(_DWORD *)a1 == 1) {
    unsigned int __src = bswap32(a2);
  }
  return sub_10023E170(a1 + 8, *(char **)(a1 + 16), (char *)&__src, (char *)&vars0, 4LL);
}

char *sub_10040FA14(uint64_t a1, unint64_t a2)
{
  unint64_t __src = a2;
  if (*(_DWORD *)a1 == 1) {
    unint64_t __src = bswap64(a2);
  }
  return sub_10023E170(a1 + 8, *(char **)(a1 + 16), (char *)&__src, (char *)&vars0, 8LL);
}

uint64_t sub_10040FA64(uint64_t a1, uint64_t a2)
{
  if (a2)
  {
    v6[0] = 0LL;
    v6[1] = 0LL;
    sub_100242F28((uint64_t)v6, a1 + 16);
    if (*(_DWORD *)(a1 + 80))
    {
      if (os_log_type_enabled((os_log_t)qword_1008F7578, OS_LOG_TYPE_ERROR)) {
        sub_10067C4CC(a1);
      }
      goto LABEL_5;
    }

    *(_DWORD *)(a1 + 80) = 3;
    *(void *)(a1 + _Block_object_dispose(va, 8) = a2;
    sub_100242F54((uint64_t)v6);
    uint64_t v4 = (*(uint64_t (**)(uint64_t))(*(void *)a1 + 40LL))(a1);
    if ((_DWORD)v4)
    {
      if (os_log_type_enabled((os_log_t)qword_1008F7578, OS_LOG_TYPE_ERROR)) {
        sub_10067C464();
      }
    }

    else
    {
      uint64_t v4 = (*(uint64_t (**)(uint64_t))(*(void *)a1 + 48LL))(a1);
      if (!(_DWORD)v4)
      {
        sub_100242ECC((uint64_t)v6);
        *(_DWORD *)(a1 + 80) = 1;
        sub_100242F54((uint64_t)v6);
LABEL_5:
        uint64_t v4 = 0LL;
LABEL_17:
        sub_100242FAC((uint64_t)v6);
        return v4;
      }

      if (os_log_type_enabled((os_log_t)qword_1008F7578, OS_LOG_TYPE_ERROR)) {
        sub_10067C3FC();
      }
      (*(void (**)(uint64_t))(*(void *)a1 + 64LL))(a1);
    }

    *(_DWORD *)(a1 + 80) = 0;
    goto LABEL_17;
  }

  if (os_log_type_enabled((os_log_t)qword_1008F7578, OS_LOG_TYPE_ERROR)) {
    sub_10067C394(a1);
  }
  return 1LL;
}

void sub_10040FBF8( _Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9)
{
}

const char *sub_10040FC0C(unsigned int a1)
{
  if (a1 > 0x19) {
    return "Unknown";
  }
  else {
    return off_100897210[a1];
  }
}

uint64_t sub_10040FC30(uint64_t a1, int a2)
{
  v27[0] = 0LL;
  v27[1] = 0LL;
  sub_100242F28((uint64_t)v27, a1 + 16);
  if (*(_DWORD *)(a1 + 80) == 2)
  {
    sub_100242F54((uint64_t)v27);
    v26[0] = 0LL;
    v26[1] = 0LL;
    sub_100242F28((uint64_t)v26, a1 + 88);
    uint64_t v4 = *(char **)(a1 + 152);
    unsigned int v5 = *(char **)(a1 + 160);
    if (v4 == v5 && *(void *)(a1 + 176) == *(void *)(a1 + 184) && *(void *)(a1 + 200) == *(void *)(a1 + 208))
    {
      sub_100242F54((uint64_t)v26);
      if ((*(unsigned int (**)(uint64_t))(*(void *)a1 + 56LL))(a1))
      {
        if (os_log_type_enabled((os_log_t)qword_1008F7578, OS_LOG_TYPE_ERROR)) {
          sub_10067C59C();
        }
        uint64_t v17 = sub_1002E6E00();
        uint64_t v18 = (char *)sub_10040FC0C(*(_DWORD *)(a1 + 248));
        sub_10002418C(v22, v18);
        sub_1004FB370(v17, 9504LL, (uint64_t)v22, 1);
      }

      if ((*(unsigned int (**)(uint64_t))(*(void *)a1 + 64LL))(a1))
      {
        if (os_log_type_enabled((os_log_t)qword_1008F7578, OS_LOG_TYPE_ERROR)) {
          sub_10067C534();
        }
        uint64_t v19 = sub_1002E6E00();
        uint64_t v20 = (char *)sub_10040FC0C(*(_DWORD *)(a1 + 248));
        sub_10002418C(v21, v20);
        sub_1004FB370(v19, 9505LL, (uint64_t)v21, 1);
      }

      sub_100242ECC((uint64_t)v27);
      *(_DWORD *)(a1 + 80) = 0;
      sub_100242F54((uint64_t)v27);
      if (a2) {
        sub_10041C530(*(void *)(a1 + 8));
      }
    }

    else
    {
      BOOL v6 = (os_log_s *)qword_1008F7578;
      if (os_log_type_enabled((os_log_t)qword_1008F7578, OS_LOG_TYPE_DEFAULT))
      {
        __int128 v7 = sub_10040FC0C(*(_DWORD *)(a1 + 248));
        uint64_t v8 = (uint64_t)(*(void *)(a1 + 184) - *(void *)(a1 + 176)) >> 3;
        uint64_t v9 = (uint64_t)(*(void *)(a1 + 208) - *(void *)(a1 + 200)) >> 3;
        *(_DWORD *)__int128 buf = 136446978;
        *(void *)&uint8_t buf[4] = v7;
        *(_WORD *)&_BYTE buf[12] = 2048;
        *(void *)&buf[14] = (v5 - v4) >> 3;
        *(_WORD *)&buf[22] = 2048;
        uint64_t v31 = v8;
        __int16 v32 = 2048;
        uint64_t v33 = v9;
        _os_log_impl( (void *)&_mh_execute_header,  v6,  OS_LOG_TYPE_DEFAULT,  "Can't stop %{public}s profile - there are still devices attached: connecting %lu connected %lu disconnecting %lu",  buf,  0x2Au);
        uint64_t v4 = *(char **)(a1 + 152);
        unsigned int v5 = *(char **)(a1 + 160);
      }

      memset(buf, 0, sizeof(buf));
      sub_100411A54((uint64_t)buf, 0LL, v4, v5, (v5 - v4) >> 3);
      sub_100411A54( (uint64_t)buf,  *(uint64_t *)&buf[8],  *(char **)(a1 + 176),  *(char **)(a1 + 184),  (uint64_t)(*(void *)(a1 + 184) - *(void *)(a1 + 176)) >> 3);
      sub_100411A54( (uint64_t)buf,  *(uint64_t *)&buf[8],  *(char **)(a1 + 200),  *(char **)(a1 + 208),  (uint64_t)(*(void *)(a1 + 208) - *(void *)(a1 + 200)) >> 3);
      uint64_t v10 = *(uint64_t **)buf;
      for (uint64_t i = *(uint64_t **)&buf[8]; v10 != i; ++v10)
      {
        uint64_t v12 = (os_log_s *)qword_1008F7578;
        if (os_log_type_enabled((os_log_t)qword_1008F7578, OS_LOG_TYPE_ERROR))
        {
          sub_1003CF00C(*v10, __p);
          __int128 v13 = v25 >= 0 ? __p : (void **)__p[0];
          *(_DWORD *)__int16 v28 = 136446210;
          __int16 v29 = v13;
          _os_log_error_impl( (void *)&_mh_execute_header,  v12,  OS_LOG_TYPE_ERROR,  "Still attached device: %{public}s",  v28,  0xCu);
          if (v25 < 0) {
            operator delete(__p[0]);
          }
        }
      }

      if ((a2 & 1) == 0)
      {
        if (qword_1008D6788 != -1) {
          dispatch_once(&qword_1008D6788, &stru_1008971D0);
        }
        if (sub_1002075B4((uint64_t)off_1008D6780) == 1)
        {
          uint64_t v15 = sub_1002E6E00();
          BOOL v16 = (char *)sub_10040FC0C(*(_DWORD *)(a1 + 248));
          sub_10002418C(v23, v16);
          sub_1004FB370(v15, 9503LL, (uint64_t)v23, 1);
        }
      }

      if (*(void *)buf)
      {
        *(void *)&uint8_t buf[8] = *(void *)buf;
        operator delete(*(void **)buf);
      }
    }

    sub_100242FAC((uint64_t)v26);
  }

  return sub_100242FAC((uint64_t)v27);
}

void sub_100410044( _Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, void *__p, uint64_t a12, int a13, __int16 a14, char a15, char a16, uint64_t a17, uint64_t a18, int a19, __int16 a20, char a21, char a22, void *a23, uint64_t a24, int a25, __int16 a26, char a27, char a28, uint64_t a29, uint64_t a30, uint64_t a31, char a32, uint64_t a33, char a34, uint64_t a35, uint64_t a36, uint64_t a37, uint64_t a38, uint64_t a39)
{
  if (a16 < 0) {
    operator delete(__p);
  }
  sub_100242FAC((uint64_t)&a32);
  sub_100242FAC((uint64_t)&a34);
  _Unwind_Resume(a1);
}

uint64_t sub_1004100DC(uint64_t a1)
{
  __int16 v32 = 0LL;
  unsigned int __dst = 0LL;
  uint64_t v34 = 0LL;
  __int16 v29 = 0LL;
  __int16 v30 = 0LL;
  uint64_t v31 = 0LL;
  v28[0] = 0LL;
  v28[1] = 0LL;
  sub_100242F28((uint64_t)v28, a1 + 16);
  if (*(_DWORD *)(a1 + 80) == 1)
  {
    *(_DWORD *)(a1 + 80) = 2;
    sub_100242F54((uint64_t)v28);
    v27[0] = 0LL;
    v27[1] = 0LL;
    sub_100242F28((uint64_t)v27, a1 + 88);
    sub_100411A54( (uint64_t)&v32,  (uint64_t)__dst,  *(char **)(a1 + 152),  *(char **)(a1 + 160),  (uint64_t)(*(void *)(a1 + 160) - *(void *)(a1 + 152)) >> 3);
    sub_100411A54( (uint64_t)&v32,  (uint64_t)__dst,  *(char **)(a1 + 176),  *(char **)(a1 + 184),  (uint64_t)(*(void *)(a1 + 184) - *(void *)(a1 + 176)) >> 3);
    if (&v29 != (void **)(a1 + 176)) {
      sub_100240C80( (char *)&v29,  *(char **)(a1 + 176),  *(void *)(a1 + 184),  (uint64_t)(*(void *)(a1 + 184) - *(void *)(a1 + 176)) >> 3);
    }
    sub_100242F54((uint64_t)v27);
    unsigned int v2 = (uint64_t *)v32;
    unint64_t v3 = (uint64_t *)__dst;
    if (v32 == __dst) {
      goto LABEL_41;
    }
    do
    {
      uint64_t v4 = (os_log_s *)qword_1008F7578;
      if (os_log_type_enabled((os_log_t)qword_1008F7578, OS_LOG_TYPE_DEFAULT))
      {
        unsigned int v5 = *(_DWORD *)(a1 + 248);
        sub_1003CF00C(*v2, __p);
        BOOL v6 = sub_10040FC0C(v5);
        __int128 v7 = v26 >= 0 ? __p : (void **)__p[0];
        *(_DWORD *)__int128 buf = 136446466;
        char v36 = (void *)v6;
        __int16 v37 = 2082;
        int v38 = v7;
        _os_log_impl( (void *)&_mh_execute_header,  v4,  OS_LOG_TYPE_DEFAULT,  "%{public}s profile waiting for device %{public}s to disconnect",  buf,  0x16u);
        if (v26 < 0) {
          operator delete(__p[0]);
        }
      }

      ++v2;
    }

    while (v2 != v3);
    uint64_t v9 = (uint64_t *)v29;
    uint64_t v8 = v30;
    if (v29 != v30)
    {
      do
      {
        uint64_t v10 = *v9;
        unsigned int v11 = (os_log_s *)qword_1008F7578;
        if (os_log_type_enabled((os_log_t)qword_1008F7578, OS_LOG_TYPE_DEFAULT))
        {
          unsigned int v12 = *(_DWORD *)(a1 + 248);
          sub_1003CF00C(v10, __p);
          __int128 v13 = sub_10040FC0C(v12);
          BOOL v14 = v26 >= 0 ? __p : (void **)__p[0];
          *(_DWORD *)__int128 buf = 136446466;
          char v36 = (void *)v13;
          __int16 v37 = 2082;
          int v38 = v14;
          _os_log_impl( (void *)&_mh_execute_header,  v11,  OS_LOG_TYPE_DEFAULT,  "%{public}s profile is disconnecting device %{public}s",  buf,  0x16u);
          if (v26 < 0) {
            operator delete(__p[0]);
          }
        }

        if (sub_1004105BC(a1, v10))
        {
          uint64_t v15 = (os_log_s *)qword_1008F7578;
          if (os_log_type_enabled((os_log_t)qword_1008F7578, OS_LOG_TYPE_ERROR))
          {
            unsigned int v18 = *(_DWORD *)(a1 + 248);
            sub_1003CF00C(v10, __p);
            uint64_t v19 = sub_10040FC0C(v18);
            uint64_t v20 = v26 >= 0 ? __p : (void **)__p[0];
            *(_DWORD *)__int128 buf = 136446466;
            char v36 = (void *)v19;
            __int16 v37 = 2082;
            int v38 = v20;
            _os_log_error_impl( (void *)&_mh_execute_header,  v15,  OS_LOG_TYPE_ERROR,  "%{public}s profile failed to disconnect device %{public}s, forcing disconnection",  buf,  0x16u);
            if (v26 < 0) {
              operator delete(__p[0]);
            }
          }

          char v24 = 0;
          sub_100242CA4(&v24);
          int v16 = sub_10010D064(v10 + 128);
          sub_100242CD0(&v24);
          if (v16)
          {
            uint64_t v17 = (os_log_s *)qword_1008F7578;
            if (os_log_type_enabled((os_log_t)qword_1008F7578, OS_LOG_TYPE_ERROR))
            {
              sub_1003CF00C(v10, __p);
              int v21 = v26 >= 0 ? __p : (void **)__p[0];
              *(_DWORD *)__int128 buf = 136446466;
              char v36 = v21;
              __int16 v37 = 1024;
              LODWORD(v3_Block_object_dispose(va, 8) = v16;
              _os_log_error_impl( (void *)&_mh_execute_header,  v17,  OS_LOG_TYPE_ERROR,  "Force disconnect for device %{public}s failed with reason %{bluetooth:OI_STATUS}u",  buf,  0x12u);
              if (v26 < 0) {
                operator delete(__p[0]);
              }
            }
          }

          sub_1003FE288((char **)&v32, v10);
          sub_100242CD8(&v24);
        }

        ++v9;
      }

      while (v9 != v8);
    }

    if (v32 == __dst)
    {
LABEL_41:
      sub_10040FC30(a1, 0);
      uint64_t v22 = 0LL;
    }

    else
    {
      uint64_t v22 = 113LL;
    }

    sub_100242FAC((uint64_t)v27);
  }

  else
  {
    if (os_log_type_enabled((os_log_t)qword_1008F7578, OS_LOG_TYPE_ERROR)) {
      sub_10067C604(a1);
    }
    uint64_t v22 = 0LL;
  }

  sub_100242FAC((uint64_t)v28);
  if (v29)
  {
    __int16 v30 = (uint64_t *)v29;
    operator delete(v29);
  }

  if (v32)
  {
    unsigned int __dst = v32;
    operator delete(v32);
  }

  return v22;
}

void sub_100410534( _Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, int a11, __int16 a12, char a13, char a14, uint64_t a15, uint64_t a16, uint64_t a17, char a18, uint64_t a19, char a20, uint64_t a21, void *__p, uint64_t a23, uint64_t a24, void *a25, uint64_t a26)
{
}

uint64_t sub_1004105BC(uint64_t a1, uint64_t a2)
{
  v6[0] = 0LL;
  v6[1] = 0LL;
  sub_100242F28((uint64_t)v6, a1 + 88);
  if (!sub_1003FE254(a1 + 176, a2))
  {
LABEL_5:
    uint64_t v4 = 306LL;
    goto LABEL_6;
  }

  if (!sub_1003FE254(a1 + 200, a2))
  {
    sub_100242F54((uint64_t)v6);
    if (!(*(unsigned int (**)(uint64_t, uint64_t))(*(void *)a1 + 80LL))(a1, a2))
    {
      sub_100410BC8(a1, a2, 0);
      uint64_t v4 = 0LL;
      goto LABEL_6;
    }

    goto LABEL_5;
  }

  uint64_t v4 = 0LL;
LABEL_6:
  sub_100242FAC((uint64_t)v6);
  return v4;
}

void sub_100410664( _Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9)
{
}

uint64_t sub_10041067C(uint64_t a1, uint64_t a2)
{
  v18[0] = 0LL;
  v18[1] = 0LL;
  sub_100242F28((uint64_t)v18, a1 + 16);
  if (*(_DWORD *)(a1 + 80) == 1)
  {
    sub_100242F54((uint64_t)v18);
    *(void *)__int128 buf = 0LL;
    *(void *)&uint8_t buf[8] = 0LL;
    sub_100242F28((uint64_t)buf, a1 + 88);
    if (sub_1003FE254(a1 + 152, a2))
    {
      uint64_t v4 = 0LL;
    }

    else if (sub_1003FE254(a1 + 176, a2))
    {
      uint64_t v6 = *(void *)(a1 + 8);
      __int128 v7 = operator new(0x28uLL);
      int v8 = *(_DWORD *)(a1 + 248);
      void v7[4] = 1;
      *(void *)__int128 v7 = &off_1008970C8;
      *((void *)v7 + 2) = v6;
      *((void *)v7 + 3) = a2;
      *((_DWORD *)v7 + _Block_object_dispose(va, 8) = v8;
      *((_BYTE *)v7 + 36) = 0;
      sub_10041C240(v6, v7);
      uint64_t v9 = *(void *)(a1 + 8);
      uint64_t v10 = operator new(0x28uLL);
      v10[4] = 1;
      *(void *)uint64_t v10 = &off_100897170;
      *((void *)v10 + 2) = a1;
      *((void *)v10 + 3) = a2;
      *((_DWORD *)v10 + _Block_object_dispose(va, 8) = 0;
      sub_10041C240(v9, v10);
      uint64_t v4 = 0LL;
    }

    else
    {
      sub_100242F54((uint64_t)buf);
      uint64_t v4 = (*(uint64_t (**)(uint64_t, uint64_t))(*(void *)a1 + 72LL))(a1, a2);
      sub_100410910(a1, a2, 0);
      if ((_DWORD)v4) {
        sub_100410A5C(a1, a2, v4);
      }
    }

    sub_100242FAC((uint64_t)buf);
  }

  else
  {
    unsigned int v5 = (os_log_s *)qword_1008F7578;
    if (os_log_type_enabled((os_log_t)qword_1008F7578, OS_LOG_TYPE_ERROR))
    {
      sub_1003CF00C(a2, __p);
      if (v17 >= 0) {
        unsigned int v12 = __p;
      }
      else {
        unsigned int v12 = (void **)__p[0];
      }
      __int128 v13 = sub_10040FC0C(*(_DWORD *)(a1 + 248));
      BOOL v14 = "starting";
      int v15 = *(_DWORD *)(a1 + 80);
      if (v15 == 2) {
        BOOL v14 = "stopping";
      }
      *(_DWORD *)__int128 buf = 136446722;
      *(void *)&uint8_t buf[4] = v12;
      *(_WORD *)&_BYTE buf[12] = 2082;
      *(void *)&buf[14] = v13;
      if (!v15) {
        BOOL v14 = "stopped";
      }
      __int16 v20 = 2082;
      int v21 = v14;
      _os_log_error_impl( (void *)&_mh_execute_header,  v5,  OS_LOG_TYPE_ERROR,  "Can't connect to device %{public}s as %{public}s profile state is %{public}s, not started",  buf,  0x20u);
      if (v17 < 0) {
        operator delete(__p[0]);
      }
    }

    uint64_t v4 = 105LL;
  }

  sub_100242FAC((uint64_t)v18);
  return v4;
}

void sub_1004108D8(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, ...)
{
  uint64_t v6 = va_arg(va1, void);
  uint64_t v8 = va_arg(va1, void);
  sub_100242FAC((uint64_t)va1);
  sub_100242FAC((uint64_t)va);
  _Unwind_Resume(a1);
}

uint64_t sub_100410910(uint64_t a1, uint64_t a2, char a3)
{
  v24[0] = 0LL;
  v24[1] = 0LL;
  sub_100242F28((uint64_t)v24, a1 + 88);
  unint64_t v6 = *(void *)(a1 + 168);
  __int128 v7 = *(void **)(a1 + 160);
  if ((unint64_t)v7 >= v6)
  {
    uint64_t v9 = *(void *)(a1 + 152);
    uint64_t v10 = ((uint64_t)v7 - v9) >> 3;
    uint64_t v11 = v6 - v9;
    uint64_t v12 = v11 >> 2;
    else {
      unint64_t v13 = v12;
    }
    if (v13) {
      BOOL v14 = (char *)sub_100008BA0(a1 + 168, v13);
    }
    else {
      BOOL v14 = 0LL;
    }
    int v15 = &v14[8 * v10];
    int v16 = &v14[8 * v13];
    *(void *)int v15 = a2;
    uint64_t v8 = v15 + 8;
    unsigned int v18 = *(char **)(a1 + 152);
    char v17 = *(char **)(a1 + 160);
    if (v17 != v18)
    {
      do
      {
        uint64_t v19 = *((void *)v17 - 1);
        v17 -= 8;
        *((void *)v15 - 1) = v19;
        v15 -= 8;
      }

      while (v17 != v18);
      char v17 = *(char **)(a1 + 152);
    }

    *(void *)(a1 + 152) = v15;
    *(void *)(a1 + 160) = v8;
    *(void *)(a1 + 16_Block_object_dispose(va, 8) = v16;
    if (v17) {
      operator delete(v17);
    }
  }

  else
  {
    *__int128 v7 = a2;
    uint64_t v8 = v7 + 1;
  }

  *(void *)(a1 + 160) = v8;
  uint64_t v20 = *(void *)(a1 + 8);
  int v21 = operator new(0x28uLL);
  int v22 = *(_DWORD *)(a1 + 248);
  _OWORD v21[4] = 1;
  *(void *)int v21 = &off_1008970C8;
  *((void *)v21 + 2) = v20;
  *((void *)v21 + 3) = a2;
  *((_DWORD *)v21 + _Block_object_dispose(va, 8) = v22;
  *((_BYTE *)v21 + 36) = a3;
  sub_10041C240(v20, v21);
  return sub_100242FAC((uint64_t)v24);
}

void sub_100410A48( _Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9)
{
}

uint64_t sub_100410A5C(uint64_t a1, uint64_t a2, int a3)
{
  v24[1] = 0LL;
  unint64_t v25 = a2;
  v24[0] = 0LL;
  sub_100242F28((uint64_t)v24, a1 + 88);
  sub_1003FE288((char **)(a1 + 152), a2);
  if (a3)
  {
    sub_10020166C(a1 + 224, &v25);
  }

  else
  {
    unint64_t v6 = *(void *)(a1 + 192);
    __int128 v7 = *(uint64_t **)(a1 + 184);
    if ((unint64_t)v7 >= v6)
    {
      uint64_t v9 = *(void *)(a1 + 176);
      uint64_t v10 = ((uint64_t)v7 - v9) >> 3;
      uint64_t v11 = v6 - v9;
      uint64_t v12 = v11 >> 2;
      else {
        unint64_t v13 = v12;
      }
      if (v13) {
        BOOL v14 = (char *)sub_100008BA0(a1 + 192, v13);
      }
      else {
        BOOL v14 = 0LL;
      }
      int v15 = (uint64_t *)&v14[8 * v10];
      int v16 = &v14[8 * v13];
      *int v15 = a2;
      uint64_t v8 = v15 + 1;
      unsigned int v18 = *(char **)(a1 + 176);
      char v17 = *(char **)(a1 + 184);
      if (v17 != v18)
      {
        do
        {
          uint64_t v19 = *((void *)v17 - 1);
          v17 -= 8;
          *--int v15 = v19;
        }

        while (v17 != v18);
        char v17 = *(char **)(a1 + 176);
      }

      *(void *)(a1 + 176) = v15;
      *(void *)(a1 + 184) = v8;
      *(void *)(a1 + 192) = v16;
      if (v17) {
        operator delete(v17);
      }
    }

    else
    {
      *__int128 v7 = a2;
      uint64_t v8 = v7 + 1;
    }

    *(void *)(a1 + 184) = v8;
  }

  uint64_t v20 = *(void *)(a1 + 8);
  int v21 = operator new(0x28uLL);
  unint64_t v22 = v25;
  _OWORD v21[4] = 1;
  *(void *)int v21 = &off_100897170;
  *((void *)v21 + 2) = a1;
  *((void *)v21 + 3) = v22;
  *((_DWORD *)v21 + _Block_object_dispose(va, 8) = a3;
  sub_10041C240(v20, v21);
  return sub_100242FAC((uint64_t)v24);
}

void sub_100410BB4(_Unwind_Exception *a1, uint64_t a2, ...)
{
}

uint64_t sub_100410BC8(uint64_t a1, uint64_t a2, char a3)
{
  v28[0] = 0LL;
  v28[1] = 0LL;
  sub_100242F28((uint64_t)v28, a1 + 88);
  unint64_t v6 = *(void *)(a1 + 216);
  __int128 v7 = *(uint64_t **)(a1 + 208);
  if ((unint64_t)v7 >= v6)
  {
    uint64_t v9 = *(void *)(a1 + 200);
    uint64_t v10 = ((uint64_t)v7 - v9) >> 3;
    uint64_t v11 = v6 - v9;
    uint64_t v12 = v11 >> 2;
    else {
      unint64_t v13 = v12;
    }
    if (v13) {
      BOOL v14 = (char *)sub_100008BA0(a1 + 216, v13);
    }
    else {
      BOOL v14 = 0LL;
    }
    int v15 = (uint64_t *)&v14[8 * v10];
    int v16 = &v14[8 * v13];
    *int v15 = a2;
    uint64_t v8 = v15 + 1;
    unsigned int v18 = *(char **)(a1 + 200);
    char v17 = *(char **)(a1 + 208);
    if (v17 != v18)
    {
      do
      {
        uint64_t v19 = *((void *)v17 - 1);
        v17 -= 8;
        *--int v15 = v19;
      }

      while (v17 != v18);
      char v17 = *(char **)(a1 + 200);
    }

    *(void *)(a1 + 200) = v15;
    *(void *)(a1 + 20_Block_object_dispose(va, 8) = v8;
    *(void *)(a1 + 216) = v16;
    if (v17) {
      operator delete(v17);
    }
  }

  else
  {
    *__int128 v7 = a2;
    uint64_t v8 = v7 + 1;
  }

  *(void *)(a1 + 20_Block_object_dispose(va, 8) = v8;
  if (*(_DWORD *)(a1 + 248) == 24)
  {
    uint64_t v20 = (os_log_s *)qword_1008F7578;
    if (os_log_type_enabled((os_log_t)qword_1008F7578, OS_LOG_TYPE_DEFAULT))
    {
      sub_1003CF00C(a2, __p);
      if (v27 >= 0) {
        int v21 = __p;
      }
      else {
        int v21 = (void **)__p[0];
      }
      *(_DWORD *)__int128 buf = 136446210;
      __int16 v30 = v21;
      _os_log_impl( (void *)&_mh_execute_header,  v20,  OS_LOG_TYPE_DEFAULT,  "AACPClient reportDisconnectionAttempt for %{public}s",  buf,  0xCu);
      if (v27 < 0) {
        operator delete(__p[0]);
      }
    }
  }

  uint64_t v22 = *(void *)(a1 + 8);
  uint64_t v23 = operator new(0x28uLL);
  int v24 = *(_DWORD *)(a1 + 248);
  v23[4] = 1;
  *(void *)uint64_t v23 = &off_100897100;
  *((void *)v23 + 2) = v22;
  *((void *)v23 + 3) = a2;
  *((_DWORD *)v23 + _Block_object_dispose(va, 8) = v24;
  *((_BYTE *)v23 + 36) = a3;
  sub_10041C240(v22, v23);
  return sub_100242FAC((uint64_t)v28);
}

void sub_100410DC0(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, ...)
{
}

uint64_t sub_100410DE0(void *a1)
{
  v7[0] = 0LL;
  v7[1] = 0LL;
  sub_100242F28((uint64_t)v7, (uint64_t)(a1 + 11));
  unsigned int v2 = (uint64_t *)a1[22];
  unint64_t v3 = (uint64_t *)a1[23];
  if (v2 == v3)
  {
    char v4 = 0;
  }

  else
  {
    char v4 = 0;
    do
    {
      uint64_t v5 = *v2;
      if (!sub_1003FE254((uint64_t)(a1 + 25), *v2))
      {
        char v4 = 1;
      }

      ++v2;
    }

    while (v2 != v3);
  }

  sub_100242FAC((uint64_t)v7);
  return v4 & 1;
}

void sub_100410E98( _Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9)
{
}

BOOL sub_100410EB0(uint64_t a1)
{
  v4[0] = 0LL;
  v4[1] = 0LL;
  sub_100242F28((uint64_t)v4, a1 + 88);
  BOOL v2 = *(void *)(a1 + 176) != *(void *)(a1 + 184);
  sub_100242FAC((uint64_t)v4);
  return v2;
}

BOOL sub_100410EFC(uint64_t a1, uint64_t a2)
{
  v6[0] = 0LL;
  v6[1] = 0LL;
  sub_100242F28((uint64_t)v6, a1 + 88);
  BOOL v4 = sub_1003FE254(a1 + 176, a2);
  sub_100242FAC((uint64_t)v6);
  return v4;
}

void sub_100410F50( _Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9)
{
}

uint64_t sub_100410F64(uint64_t a1)
{
  v8[0] = 0LL;
  v8[1] = 0LL;
  sub_100242F28((uint64_t)v8, a1 + 88);
  BOOL v2 = *(uint64_t **)(a1 + 176);
  unint64_t v3 = *(uint64_t **)(a1 + 184);
  if (v2 == v3)
  {
    uint64_t v4 = 0LL;
  }

  else
  {
    uint64_t v4 = 0LL;
    int v5 = 0;
    do
    {
      uint64_t v6 = *v2;
      if (!v5 || v5 > (int)sub_1003E39EC(*v2))
      {
        int v5 = sub_1003E39EC(v6);
        uint64_t v4 = v6;
      }

      ++v2;
    }

    while (v2 != v3);
  }

  sub_100242FAC((uint64_t)v8);
  return v4;
}

void sub_100411004( _Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9)
{
}

uint64_t sub_100411018(uint64_t a1)
{
  v4[0] = 0LL;
  v4[1] = 0LL;
  sub_100242F28((uint64_t)v4, a1 + 88);
  uint64_t v2 = (uint64_t)(*(void *)(a1 + 184) - *(void *)(a1 + 176)) >> 3;
  sub_100242FAC((uint64_t)v4);
  return v2;
}

uint64_t sub_100411064(uint64_t a1, uint64_t a2)
{
  v12[0] = 0LL;
  v12[1] = 0LL;
  sub_100242F28((uint64_t)v12, a1 + 16);
  if (!a2 || *(_DWORD *)(a1 + 80) != 1)
  {
    if (os_log_type_enabled((os_log_t)qword_1008F7578, OS_LOG_TYPE_ERROR)) {
      sub_10067C66C();
    }
    goto LABEL_10;
  }

  sub_100242F54((uint64_t)v12);
  if (qword_1008D6788 != -1) {
    dispatch_once(&qword_1008D6788, &stru_1008971D0);
  }
  if (sub_1002075B4((uint64_t)off_1008D6780) != 1)
  {
    if (os_log_type_enabled((os_log_t)qword_1008F7578, OS_LOG_TYPE_ERROR)) {
      sub_10067C778(a1);
    }
LABEL_10:
    uint64_t v6 = 0LL;
    goto LABEL_11;
  }

  v11[0] = 0LL;
  v11[1] = 0LL;
  sub_100242F28((uint64_t)v11, a1 + 88);
  uint64_t v5 = *(void *)(a1 + 176);
  uint64_t v4 = *(void *)(a1 + 184);
  if ((*(unsigned int (**)(uint64_t))(*(void *)a1 + 16LL))(a1) <= (unint64_t)((v4 - v5) >> 3))
  {
    uint64_t v8 = (os_log_s *)qword_1008F7578;
    if (os_log_type_enabled((os_log_t)qword_1008F7578, OS_LOG_TYPE_ERROR))
    {
      unsigned int v9 = *(_DWORD *)(a1 + 248);
      int v10 = (*(uint64_t (**)(uint64_t))(*(void *)a1 + 16LL))(a1);
      sub_10067C708(v9, (uint64_t)v13, v10, v8);
    }

    uint64_t v6 = 0LL;
  }

  else
  {
    uint64_t v6 = (*(uint64_t (**)(void, uint64_t, void))(**(void **)(a1 + 8) + 128LL))( *(void *)(a1 + 8),  a2,  *(unsigned int *)(a1 + 248));
  }

  sub_100242FAC((uint64_t)v11);
LABEL_11:
  sub_100242FAC((uint64_t)v12);
  return v6;
}

void sub_100411238( _Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, char a11)
{
}

uint64_t sub_10041126C(uint64_t a1)
{
  return (*(uint64_t (**)(void))(**(void **)(a1 + 8) + 136LL))(*(void *)(a1 + 8));
}

uint64_t sub_10041127C(uint64_t a1, unint64_t a2, __int16 a3)
{
  v17[1] = 0LL;
  unint64_t v18 = a2;
  v17[0] = 0LL;
  sub_100242F28((uint64_t)v17, a1 + 88);
  uint64_t v8 = *(void **)(a1 + 232);
  __int128 v7 = (void *)(a1 + 232);
  uint64_t v6 = v8;
  if (v8)
  {
    unsigned int v9 = v7;
    do
    {
      unint64_t v10 = v6[4];
      BOOL v11 = v10 >= a2;
      if (v10 >= a2) {
        uint64_t v12 = v6;
      }
      else {
        uint64_t v12 = v6 + 1;
      }
      if (v11) {
        unsigned int v9 = v6;
      }
      uint64_t v6 = (void *)*v12;
    }

    while (*v12);
    if (v9 != v7 && v9[4] <= a2)
    {
      unint64_t v13 = (os_log_s *)qword_1008F7578;
      if (os_log_type_enabled((os_log_t)qword_1008F7578, OS_LOG_TYPE_FAULT)) {
        sub_10067C7E0(v13, v14, v15);
      }
    }
  }

  uint64_t v19 = &v18;
  *((_WORD *)sub_100411CA0((uint64_t **)v7 - 1, &v18, (uint64_t)&unk_1006C2518, &v19) + 20) = a3;
  return sub_100242FAC((uint64_t)v17);
}

void sub_10041135C(_Unwind_Exception *a1, uint64_t a2, ...)
{
}

uint64_t sub_100411370(void *a1, unint64_t a2)
{
  v14[0] = 0LL;
  v14[1] = 0LL;
  sub_100242F28((uint64_t)v14, (uint64_t)(a1 + 11));
  if (a2)
  {
    uint64_t v4 = (void *)a1[29];
    if (!v4) {
      goto LABEL_20;
    }
    uint64_t v5 = a1 + 29;
    do
    {
      unint64_t v6 = v4[4];
      BOOL v7 = v6 >= a2;
      if (v6 >= a2) {
        uint64_t v8 = v4;
      }
      else {
        uint64_t v8 = v4 + 1;
      }
      if (v7) {
        uint64_t v5 = v4;
      }
      uint64_t v4 = (void *)*v8;
    }

    while (*v8);
    if (v5 == a1 + 29 || v5[4] > a2) {
      goto LABEL_20;
    }
  }

  else
  {
    if ((*(unsigned int (**)(void *))(*a1 + 16LL))(a1) >= 2)
    {
      unsigned int v9 = (os_log_s *)qword_1008F7578;
      if (os_log_type_enabled((os_log_t)qword_1008F7578, OS_LOG_TYPE_FAULT)) {
        sub_10067C854(v9, v10, v11);
      }
    }

    uint64_t v5 = (void *)a1[28];
  }

  if (v5 == a1 + 29)
  {
LABEL_20:
    uint64_t v12 = 0LL;
    goto LABEL_21;
  }

  uint64_t v12 = *((unsigned __int16 *)v5 + 20);
LABEL_21:
  sub_100242FAC((uint64_t)v14);
  return v12;
}

void sub_100411458( _Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9)
{
}

uint64_t sub_10041146C(void *a1, int a2)
{
  v13[0] = 0LL;
  v13[1] = 0LL;
  sub_100242F28((uint64_t)v13, (uint64_t)(a1 + 11));
  if (a2)
  {
    uint64_t v4 = (void *)a1[28];
    if (v4 != a1 + 29)
    {
      while (*((unsigned __int16 *)v4 + 20) != a2)
      {
        uint64_t v5 = (void *)v4[1];
        if (v5)
        {
          do
          {
            unint64_t v6 = v5;
            uint64_t v5 = (void *)*v5;
          }

          while (v5);
        }

        else
        {
          do
          {
            unint64_t v6 = (void *)v4[2];
            BOOL v7 = *v6 == (void)v4;
            uint64_t v4 = v6;
          }

          while (!v7);
        }

        uint64_t v4 = v6;
        if (v6 == a1 + 29) {
          goto LABEL_16;
        }
      }

      goto LABEL_15;
    }

void sub_100411568( _Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9)
{
}

uint64_t sub_10041157C(uint64_t a1, uint64_t a2, uint64_t a3)
{
  int v3 = a3;
  (*(void (**)(void, uint64_t, void, uint64_t))(**(void **)(a1 + 8) + 160LL))( *(void *)(a1 + 8),  a2,  *(unsigned int *)(a1 + 248),  a3);
  v7[0] = 0LL;
  v7[1] = 0LL;
  sub_100242F28((uint64_t)v7, a1 + 16);
  if (*(_DWORD *)(a1 + 80) == 2)
  {
    sub_100242F54((uint64_t)v7);
    if (v3) {
      sub_10040FC30(a1, 1);
    }
    else {
      sub_1004105BC(a1, a2);
    }
  }

  return sub_100242FAC((uint64_t)v7);
}

void sub_100411614( _Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9)
{
}

uint64_t sub_100411628(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  uint64_t v8 = *(void *)(a1 + 8);
  uint64_t v9 = *(unsigned int *)(a1 + 248);
  if (qword_1008D60B0 != -1) {
    dispatch_once(&qword_1008D60B0, &stru_1008971F0);
  }
  uint64_t v10 = sub_1004317E0((uint64_t)off_1008D60A8, a4, 10000);
  (*(void (**)(uint64_t, uint64_t, uint64_t, uint64_t, uint64_t))(*(void *)v8 + 168LL))(v8, a2, v9, a3, v10);
  v12[0] = 0LL;
  v12[1] = 0LL;
  sub_100242F28((uint64_t)v12, a1 + 16);
  if (*(_DWORD *)(a1 + 80) == 2)
  {
    sub_100242F54((uint64_t)v12);
    sub_10040FC30(a1, 1);
  }

  return sub_100242FAC((uint64_t)v12);
}

void sub_100411704( _Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9)
{
}

uint64_t sub_100411718(uint64_t a1, uint64_t a2, int a3, int a4)
{
  v20[1] = 0LL;
  unint64_t v21 = a2;
  v20[0] = 0LL;
  sub_100242F28((uint64_t)v20, a1 + 88);
  if (*(_DWORD *)(a1 + 248) == 24
    && (uint64_t v8 = (os_log_s *)qword_1008F7578, os_log_type_enabled((os_log_t)qword_1008F7578, OS_LOG_TYPE_DEFAULT))
    && ((sub_1003CF00C(a2, __p), v19 >= 0) ? (uint64_t v9 = __p) : (uint64_t v9 = (void **)__p[0]),
        *(_DWORD *)__int128 buf = 136446210,
        uint64_t v23 = v9,
        _os_log_impl( (void *)&_mh_execute_header,  v8,  OS_LOG_TYPE_DEFAULT,  "AACPClient reportDisconnectionResult for %{public}s",  buf,  0xCu),  v19 < 0))
  {
    operator delete(__p[0]);
    if (a3) {
      return sub_100242FAC((uint64_t)v20);
    }
  }

  else if (a3)
  {
    return sub_100242FAC((uint64_t)v20);
  }

  BOOL v10 = sub_1003FE288((char **)(a1 + 152), a2);
  BOOL v11 = sub_1003FE288((char **)(a1 + 176), a2);
  if (v10 && v11)
  {
    uint64_t v12 = (os_log_s *)qword_1008F7578;
    if (os_log_type_enabled((os_log_t)qword_1008F7578, OS_LOG_TYPE_FAULT)) {
      sub_10067C8C8((unsigned int *)(a1 + 248), v12);
    }
  }

  sub_1003FE288((char **)(a1 + 200), a2);
  sub_10020166C(a1 + 224, &v21);
  if (v10)
  {
    uint64_t v13 = *(void *)(a1 + 8);
    uint64_t v14 = operator new(0x28uLL);
    unint64_t v15 = v21;
    v14[4] = 1;
    *(void *)uint64_t v14 = &off_100897170;
    *((void *)v14 + 2) = a1;
    *((void *)v14 + 3) = v15;
    *((_DWORD *)v14 + _Block_object_dispose(va, 8) = 305;
LABEL_15:
    sub_10041C240(v13, v14);
    return sub_100242FAC((uint64_t)v20);
  }

  if (v11)
  {
    uint64_t v13 = *(void *)(a1 + 8);
    uint64_t v14 = operator new(0x28uLL);
    unint64_t v16 = v21;
    v14[4] = 1;
    *(void *)uint64_t v14 = &off_1008971A8;
    *((void *)v14 + 2) = a1;
    *((void *)v14 + 3) = v16;
    *((_DWORD *)v14 + _Block_object_dispose(va, 8) = 0;
    *((_DWORD *)v14 + 9) = a4;
    goto LABEL_15;
  }

  return sub_100242FAC((uint64_t)v20);
}

void sub_100411928(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, ...)
{
}

BOOL sub_100411948(uint64_t a1, uint64_t a2, int a3, int a4)
{
  uint64_t v8 = *(void *)(a1 + 8);
  uint64_t v9 = operator new(0x30uLL);
  int v10 = *(_DWORD *)(a1 + 248);
  void v9[4] = 1;
  *(void *)uint64_t v9 = &off_100897138;
  *((void *)v9 + 2) = v8;
  *((void *)v9 + 3) = a2;
  *((_DWORD *)v9 + _Block_object_dispose(va, 8) = v10;
  *((_DWORD *)v9 + 9) = a3;
  *((_DWORD *)v9 + 10) = a4;
  return sub_10041C240(v8, v9);
}

uint64_t sub_1004119B8(uint64_t a1)
{
  return (*(uint64_t (**)(void, void, void, void))(**(void **)(a1 + 16) + 144LL))( *(void *)(a1 + 16),  *(void *)(a1 + 24),  *(unsigned int *)(a1 + 32),  *(unsigned __int8 *)(a1 + 36));
}

uint64_t sub_1004119D4(uint64_t a1)
{
  return (*(uint64_t (**)(void, void, void, void))(**(void **)(a1 + 16) + 152LL))( *(void *)(a1 + 16),  *(void *)(a1 + 24),  *(unsigned int *)(a1 + 32),  *(unsigned __int8 *)(a1 + 36));
}

uint64_t sub_1004119F0(uint64_t a1)
{
  return (*(uint64_t (**)(void, void, void, void, void))(**(void **)(a1 + 16) + 176LL))( *(void *)(a1 + 16),  *(void *)(a1 + 24),  *(unsigned int *)(a1 + 32),  *(unsigned int *)(a1 + 36),  *(unsigned int *)(a1 + 40));
}

uint64_t sub_100411A2C(uint64_t a1)
{
  return sub_10041157C(*(void *)(a1 + 16), *(void *)(a1 + 24), *(unsigned int *)(a1 + 32));
}

uint64_t sub_100411A44(uint64_t a1)
{
  return sub_100411628( *(void *)(a1 + 16),  *(void *)(a1 + 24),  *(unsigned int *)(a1 + 32),  *(unsigned int *)(a1 + 36));
}

char *sub_100411A54(uint64_t a1, uint64_t __dst, char *__src, char *a4, uint64_t a5)
{
  uint64_t v5 = (char *)__dst;
  if (a5 < 1) {
    return v5;
  }
  BOOL v7 = __src;
  uint64_t v11 = *(void *)(a1 + 16);
  uint64_t v9 = a1 + 16;
  uint64_t v10 = v11;
  unint64_t v12 = *(void *)(v9 - 8);
  if (a5 > (uint64_t)(v11 - v12) >> 3)
  {
    uint64_t v13 = *(void **)a1;
    unint64_t v14 = a5 + ((uint64_t)(v12 - *(void *)a1) >> 3);
    if (v14 >> 61) {
      abort();
    }
    uint64_t v15 = (__dst - (uint64_t)v13) >> 3;
    uint64_t v16 = v10 - (void)v13;
    if (v16 >> 2 > v14) {
      unint64_t v14 = v16 >> 2;
    }
    else {
      unint64_t v17 = v14;
    }
    uint64_t v37 = v9;
    if (v17) {
      unint64_t v18 = (char *)sub_100008BA0(v9, v17);
    }
    else {
      unint64_t v18 = 0LL;
    }
    __int16 v28 = &v18[8 * v15];
    std::string __p = v18;
    uint64_t v34 = v28;
    char v36 = &v18[8 * v17];
    uint64_t v29 = 8 * a5;
    __int16 v30 = &v28[8 * a5];
    do
    {
      uint64_t v31 = *(void *)v7;
      v7 += 8;
      *(void *)__int16 v28 = v31;
      v28 += 8;
      v29 -= 8LL;
    }

    while (v29);
    __int16 v35 = v30;
    uint64_t v5 = sub_100008ADC((void **)a1, (uint64_t)&__p, v5);
    if (v35 != v34) {
      v35 += (v34 - v35 + 7) & 0xFFFFFFFFFFFFFFF8LL;
    }
    if (__p) {
      operator delete(__p);
    }
    return v5;
  }

  uint64_t v19 = v12 - __dst;
  uint64_t v20 = (uint64_t)(v12 - __dst) >> 3;
  if (v20 >= a5)
  {
    unint64_t v21 = &__src[8 * a5];
    uint64_t v23 = *(char **)(v9 - 8);
LABEL_17:
    int v24 = &v5[8 * a5];
    unint64_t v25 = &v23[-8 * a5];
    char v26 = v23;
    if ((unint64_t)v25 < v12)
    {
      char v26 = v23;
      do
      {
        uint64_t v27 = *(void *)v25;
        v25 += 8;
        *(void *)char v26 = v27;
        v26 += 8;
      }

      while ((unint64_t)v25 < v12);
    }

    *(void *)(a1 + _Block_object_dispose(va, 8) = v26;
    if (v23 != v24) {
      memmove(&v23[-8 * ((v23 - v24) >> 3)], v5, v23 - v24);
    }
    if (v21 != v7) {
      memmove(v5, v7, v21 - v7);
    }
    return v5;
  }

  unint64_t v21 = &__src[8 * v20];
  int64_t v22 = a4 - v21;
  if (a4 != v21) {
    memmove(*(void **)(v9 - 8), &__src[8 * v20], a4 - v21);
  }
  uint64_t v23 = (char *)(v12 + v22);
  *(void *)(a1 + _Block_object_dispose(va, 8) = v12 + v22;
  if (v19 >= 1) {
    goto LABEL_17;
  }
  return v5;
}

void sub_100411C24( _Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void *__p, uint64_t a11, uint64_t a12)
{
  if (__p) {
    operator delete(__p);
  }
  _Unwind_Resume(exception_object);
}

void sub_100411C5C(id a1)
{
  int v1 = operator new(0xA8uLL);
  sub_10040D0A0((uint64_t)v1);
  off_1008D6780 = v1;
}

void sub_100411C8C(_Unwind_Exception *a1)
{
}

uint64_t **sub_100411CA0(uint64_t **a1, unint64_t *a2, uint64_t a3, void **a4)
{
  BOOL v7 = a1 + 1;
  unint64_t v6 = a1[1];
  if (v6)
  {
    unint64_t v8 = *a2;
    while (1)
    {
      while (1)
      {
        uint64_t v9 = (uint64_t **)v6;
        unint64_t v10 = v6[4];
        if (v8 >= v10) {
          break;
        }
        unint64_t v6 = *v9;
        BOOL v7 = v9;
        if (!*v9) {
          goto LABEL_10;
        }
      }

      if (v10 >= v8) {
        break;
      }
      unint64_t v6 = v9[1];
      if (!v6)
      {
        BOOL v7 = v9 + 1;
        goto LABEL_10;
      }
    }
  }

  else
  {
    uint64_t v9 = a1 + 1;
LABEL_10:
    uint64_t v11 = operator new(0x30uLL);
    uint8_t v11[4] = **a4;
    *((_WORD *)v11 + 20) = 0;
    sub_100029630(a1, (uint64_t)v9, v7, v11);
    return (uint64_t **)v11;
  }

  return v9;
}

void sub_100411D60(id a1)
{
  int v1 = operator new(0x230uLL);
  sub_10042BC28();
  off_1008D60A8 = v1;
}

void sub_100411D90(_Unwind_Exception *a1)
{
}

const char *sub_100411DA4(uint64_t a1)
{
  return sub_10040FC0C(*(_DWORD *)(a1 + 248));
}

uint64_t sub_100411DB0(uint64_t result)
{
  *(void *)unint64_t result = off_1008972F0;
  *(_BYTE *)(result + _Block_object_dispose(va, 8) = 0;
  *(_DWORD *)(result + 16) = 0;
  *(void *)(result + 24) = 0LL;
  *(void *)(result + 32) = 0LL;
  *(void *)(result + 64) = 0LL;
  *(void *)(result + 72) = 0LL;
  *(void *)(result + 56) = 0LL;
  *(void *)(result + 40) = 0LL;
  *(void *)(result + 4_Block_object_dispose(va, 8) = result + 56;
  return result;
}

void sub_100411DDC(uint64_t a1)
{
  uint64_t v2 = objc_claimAutoreleasedReturnValue(+[NSMutableDictionary dictionary](&OBJC_CLASS___NSMutableDictionary, "dictionary"));
  int v3 = *(void **)(a1 + 72);
  *(void *)(a1 + 72) = v2;

  if (qword_1008D60B0 != -1) {
    dispatch_once(&qword_1008D60B0, &stru_100897408);
  }
  sub_1001FC5E4((uint64_t)off_1008D60A8 + 80, a1);
  unsigned int v12 = 0;
  uint64_t v4 = sub_1002E6E00();
  sub_10002418C(buf, "ATT");
  sub_10002418C(__p, "ResponseTimeout");
  int v5 = (*(uint64_t (**)(uint64_t, uint8_t *, void **, unsigned int *))(*(void *)v4 + 88LL))( v4,  buf,  __p,  &v12);
  if (v12) {
    int v6 = v5;
  }
  else {
    int v6 = 0;
  }
  if (v11 < 0) {
    operator delete(__p[0]);
  }
  if (v14 < 0)
  {
    operator delete(*(void **)buf);
    if (!v6) {
      return;
    }
  }

  else if (!v6)
  {
    return;
  }

  BOOL v7 = (os_log_s *)qword_1008F75B0;
  BOOL v8 = os_log_type_enabled((os_log_t)qword_1008F75B0, OS_LOG_TYPE_DEFAULT);
  uint64_t v9 = v12;
  if (v8)
  {
    *(_DWORD *)__int128 buf = 67109120;
    *(_DWORD *)&uint8_t buf[4] = v12;
    _os_log_impl( (void *)&_mh_execute_header,  v7,  OS_LOG_TYPE_DEFAULT,  "Overriding the ATT Response timeout to %d",  buf,  8u);
    uint64_t v9 = v12;
  }

  sub_1001C2484(v9);
}

void sub_100411F64( _Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, void *__p, uint64_t a10, int a11, __int16 a12, char a13, char a14, uint64_t a15, void *a16, uint64_t a17, int a18, __int16 a19, char a20, char a21)
{
  if (a14 < 0) {
    operator delete(__p);
  }
  if (a21 < 0) {
    operator delete(a16);
  }
  _Unwind_Resume(exception_object);
}

void sub_100411FA0(unsigned __int8 *a1, __int16 a2, uint64_t a3, int a4, int a5)
{
  if (a4 == 1)
  {
    unint64_t v10 = ((unint64_t)a1[48] << 40) | ((unint64_t)a1[49] << 32) | ((unint64_t)a1[50] << 24) | ((unint64_t)a1[51] << 16) | ((unint64_t)a1[52] << 8) | a1[53];
  }

  else
  {
    if (a1[55])
    {
      unint64_t v11 = ((unint64_t)a1[57] << 40) | ((unint64_t)a1[58] << 32) | ((unint64_t)a1[59] << 24) | ((unint64_t)a1[60] << 16) | ((unint64_t)a1[61] << 8) | a1[62];
      uint64_t v12 = a1[56];
    }

    else
    {
      unint64_t v11 = ((unint64_t)a1[49] << 40) | ((unint64_t)a1[50] << 32) | ((unint64_t)a1[51] << 24) | ((unint64_t)a1[52] << 16) | ((unint64_t)a1[53] << 8) | a1[54];
      uint64_t v12 = a1[48];
    }

    unint64_t v10 = v11 | (v12 << 48);
  }

  uint64_t v13 = sub_100404FE8();
  v14[0] = _NSConcreteStackBlock;
  v14[1] = 3221225472LL;
  void v14[2] = sub_100413B74;
  v14[3] = &unk_1008973E8;
  v14[4] = a1;
  v14[5] = v10;
  __int16 v17 = a2;
  v14[6] = a3;
  int v15 = a4;
  int v16 = a5;
  sub_100405384(v13, v14);
}

void sub_1004120E0(uint64_t a1, int a2)
{
  uint64_t v4 = sub_100404FE8();
  v5[0] = _NSConcreteStackBlock;
  v5[1] = 3221225472LL;
  void v5[2] = sub_100413C08;
  v5[3] = &unk_10087EB68;
  v5[4] = a1;
  int v6 = a2;
  sub_100405384(v4, v5);
}

void sub_100412148(__int16 *a1, char a2, __int16 a3, int a4)
{
  __int16 v8 = *a1;
  uint64_t v9 = sub_100404FE8();
  v10[0] = _NSConcreteStackBlock;
  v10[1] = 3221225472LL;
  void v10[2] = sub_100413C5C;
  uint64_t v10[3] = &unk_100886EE0;
  v10[4] = a1;
  char v14 = a2;
  __int16 v12 = a3;
  __int16 v13 = v8;
  int v11 = a4;
  sub_100405384(v9, v10);
}

double sub_1004121D8(uint64_t a1)
{
  *(_BYTE *)(a1 + _Block_object_dispose(va, 8) = 1;
  *(void *)&double result = sub_1001C2420((__n128 *)off_100897320).n128_u64[0];
  return result;
}

void sub_1004121EC(uint64_t a1)
{
  if (qword_1008D60B0 != -1) {
    dispatch_once(&qword_1008D60B0, &stru_100897408);
  }
  sub_100009168((uint64_t)off_1008D60A8 + 80, a1);
}

void sub_100412240(uint64_t a1)
{
  uint64_t v2 = (os_log_s *)qword_1008F75B0;
  if (os_log_type_enabled((os_log_t)qword_1008F75B0, OS_LOG_TYPE_DEFAULT))
  {
    *(_WORD *)__int128 buf = 0;
    _os_log_impl((void *)&_mh_execute_header, v2, OS_LOG_TYPE_DEFAULT, "Gatt::stackWillStop enter", buf, 2u);
  }

  uint64_t v4 = *(void **)(a1 + 56);
  int v3 = (void *)(a1 + 56);
  *((_BYTE *)v3 - 4_Block_object_dispose(va, 8) = 0;
  sub_10023BF24((uint64_t)(v3 - 1), v4);
  *(v3 - 1) = v3;
  *int v3 = 0LL;
  v3[1] = 0LL;
  sub_1001C2470();
  int v5 = (os_log_s *)qword_1008F75B0;
  if (os_log_type_enabled((os_log_t)qword_1008F75B0, OS_LOG_TYPE_DEFAULT))
  {
    *(_WORD *)int v6 = 0;
    _os_log_impl((void *)&_mh_execute_header, v5, OS_LOG_TYPE_DEFAULT, "Gatt::stackWillStop exit", v6, 2u);
  }

id sub_100412308(uint64_t a1)
{
  return [*(id *)(a1 + 72) removeAllObjects];
}

void sub_100412310(uint64_t a1, uint64_t a2, unint64_t a3, int a4, uint64_t a5, int a6, int a7)
{
  if (*(_BYTE *)(a1 + 8))
  {
    memset(uu, 0, sizeof(uu));
    uuid_clear(uu);
    if (a6 == 1) {
      id v14 = sub_1005BF848(a3);
    }
    else {
      id v14 = sub_1005BFB9C(a3);
    }
    int v15 = (void *)objc_claimAutoreleasedReturnValue(v14);
    if (a7)
    {
      int v16 = (os_log_s *)qword_1008F75B0;
      if (os_log_type_enabled((os_log_t)qword_1008F75B0, OS_LOG_TYPE_ERROR))
      {
        *(_DWORD *)__int128 buf = 138543618;
        *(void *)uint64_t v48 = v15;
        *(_WORD *)&v48[8] = 1024;
        *(_DWORD *)&v48[10] = a7;
        _os_log_error_impl( (void *)&_mh_execute_header,  v16,  OS_LOG_TYPE_ERROR,  "Gatt device %{public}@ connected with error %{bluetooth:OI_STATUS}u",  buf,  0x12u);
        int v16 = (os_log_s *)qword_1008F75B0;
      }

      if (os_log_type_enabled(v16, OS_LOG_TYPE_FAULT)) {
        sub_10067C940(a7, v16);
      }
LABEL_37:

      return;
    }

    __int16 v17 = (os_log_s *)qword_1008F75B0;
    if (!a5 && os_log_type_enabled((os_log_t)qword_1008F75B0, OS_LOG_TYPE_FAULT))
    {
      *(_DWORD *)__int128 buf = 136446210;
      *(void *)uint64_t v48 = "pAttDBSession";
      _os_log_fault_impl((void *)&_mh_execute_header, v17, OS_LOG_TYPE_FAULT, "Assertion failed: %{public}s", buf, 0xCu);
      __int16 v17 = (os_log_s *)qword_1008F75B0;
      if (a4) {
        goto LABEL_15;
      }
    }

    else if (a4)
    {
      goto LABEL_15;
    }

    if (os_log_type_enabled(v17, OS_LOG_TYPE_FAULT))
    {
      *(_DWORD *)__int128 buf = 136446210;
      *(void *)uint64_t v48 = "gattHandle != LE_GATT_INVALID_SESSION_HANDLE";
      _os_log_fault_impl((void *)&_mh_execute_header, v17, OS_LOG_TYPE_FAULT, "Assertion failed: %{public}s", buf, 0xCu);
      __int16 v17 = (os_log_s *)qword_1008F75B0;
    }

void sub_1004128A4(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

uint64_t sub_10041291C(uint64_t a1, void *a2, int a3)
{
  id v5 = a2;
  if (!sub_100413550(a1, v5)) {
    goto LABEL_27;
  }
  int v6 = (os_log_s *)qword_1008F75B0;
  if (os_log_type_enabled((os_log_t)qword_1008F75B0, OS_LOG_TYPE_DEFAULT))
  {
    *(_WORD *)std::string __p = 0;
    _os_log_impl( (void *)&_mh_execute_header,  v6,  OS_LOG_TYPE_DEFAULT,  "GATT is connected on 2 transports! Serializing disconnection of prev in favor of current.",  __p,  2u);
  }

  sub_100241F90(uu2, v5);
  if (!*(_BYTE *)(a1 + 8)) {
    goto LABEL_27;
  }
  uint64_t v7 = sub_1001FDB10(a1 + 48, uu2);
  if (a1 + 56 == v7) {
    goto LABEL_27;
  }
  int v8 = *(_DWORD *)(v7 + 56);
  if (a3 != 2 || v8 != 1)
  {
    id v14 = (os_log_s *)qword_1008F75B0;
    BOOL v15 = os_log_type_enabled((os_log_t)qword_1008F75B0, OS_LOG_TYPE_FAULT);
    if (a3 == 1 && v8 == 2)
    {
      if (v15) {
        sub_10067C9B0((uint64_t)v5, v14);
      }
    }

    else if (v15)
    {
      *(_DWORD *)std::string __p = 138543874;
      *(void *)&__p[4] = v5;
      __int16 v18 = 1024;
      int v19 = v8;
      __int16 v20 = 1024;
      int v21 = a3;
      _os_log_fault_impl( (void *)&_mh_execute_header,  v14,  OS_LOG_TYPE_FAULT,  "Gatt device %{public}@ connected twice with previousTransport %d and currentTransport %d",  __p,  0x18u);
    }

void sub_100412BF4(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_100412C1C(uint64_t a1)
{
}

void sub_100412C34(uint64_t a1, void *a2, uint64_t a3, int a4, int a5, uint64_t a6)
{
  id v11 = a2;
  char v21 = 0;
  sub_100242CA4(&v21);
  int v12 = sub_1001C009C(a3);
  sub_100242CD0(&v21);
  if (v12 == a5 && v12)
  {
    sub_100241F90(buf, v11);
    int64_t v22 = buf;
    uint64_t v13 = sub_100413FD0( (uint64_t **)(a1 + 48),  buf,  (uint64_t)&unk_1006C2518,  (const unsigned __int8 *__attribute__((__org_typedef(uuid_t))) *)&v22);
    v13[6] = a3;
    *((_DWORD *)v13 + 14) = a4;
    *((_DWORD *)v13 + 15) = 0;
    id v14 = (os_log_s *)qword_1008F75B0;
    if (os_log_type_enabled((os_log_t)qword_1008F75B0, OS_LOG_TYPE_DEFAULT))
    {
      BOOL v15 = "CLASSIC";
      *(_DWORD *)__int128 buf = 138543874;
      id v24 = v11;
      if (a4 == 2) {
        BOOL v15 = "LE";
      }
      __int16 v25 = 2080;
      *(void *)char v26 = v15;
      *(_WORD *)&v26[8] = 2048;
      *(void *)&v26[10] = a3;
      _os_log_impl( (void *)&_mh_execute_header,  v14,  OS_LOG_TYPE_DEFAULT,  "Notify gattDeviceConnected %{public}@ transport=%s handle=%p",  buf,  0x20u);
    }

    v17[0] = _NSConcreteStackBlock;
    v17[1] = 3221225472LL;
    void v17[2] = sub_100413648;
    v17[3] = &unk_1008973C8;
    __int16 v20 = a5;
    id v18 = v11;
    uint64_t v19 = a6;
    sub_100413D54((os_unfair_lock_s *)(a1 + 16), v17);
  }

  else
  {
    int v16 = (os_log_s *)qword_1008F75B0;
    if (os_log_type_enabled((os_log_t)qword_1008F75B0, OS_LOG_TYPE_ERROR))
    {
      *(_DWORD *)__int128 buf = 138543874;
      id v24 = v11;
      __int16 v25 = 1024;
      *(_DWORD *)char v26 = a5;
      *(_WORD *)&v26[4] = 2048;
      *(void *)&v26[6] = a6;
      _os_log_error_impl( (void *)&_mh_execute_header,  v16,  OS_LOG_TYPE_ERROR,  "Gatt device %{public}@ with gattHandle %d ATT_DB_Session %p is no longer connected, not notifying of connection",  buf,  0x1Cu);
    }
  }

  sub_100242CD8(&v21);
}

void sub_100412E60( _Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, void *a13, uint64_t a14, int a15, __int16 a16, char a17)
{
  sub_100242CD8(&a17);
  _Unwind_Resume(a1);
}

void sub_100412E9C(uint64_t a1, void *a2, int a3)
{
  if (*(_BYTE *)(a1 + 8))
  {
    int v6 = (os_log_s *)qword_1008F75B0;
    if (os_log_type_enabled((os_log_t)qword_1008F75B0, OS_LOG_TYPE_DEFAULT))
    {
      int v28 = 134218240;
      int v29 = a2;
      __int16 v30 = 1024;
      LODWORD(v31) = a3;
      _os_log_impl( (void *)&_mh_execute_header,  v6,  OS_LOG_TYPE_DEFAULT,  "Gatt device disconnected on handle %p with status %{bluetooth:OI_STATUS}u",  (uint8_t *)&v28,  0x12u);
    }

    uint64_t v7 = *(unsigned __int8 **)(a1 + 48);
    if (v7 == (unsigned __int8 *)(a1 + 56))
    {
LABEL_12:
      id v11 = (os_log_s *)qword_1008F75B0;
      if (os_log_type_enabled((os_log_t)qword_1008F75B0, OS_LOG_TYPE_ERROR)) {
        sub_10067CA24(v11);
      }
    }

    else
    {
      while (*((void **)v7 + 6) != a2)
      {
        int v8 = (unsigned __int8 *)*((void *)v7 + 1);
        if (v8)
        {
          do
          {
            uint64_t v9 = v8;
            int v8 = *(unsigned __int8 **)v8;
          }

          while (v8);
        }

        else
        {
          do
          {
            uint64_t v9 = (unsigned __int8 *)*((void *)v7 + 2);
            BOOL v10 = *(void *)v9 == (void)v7;
            uint64_t v7 = v9;
          }

          while (!v10);
        }

        uint64_t v7 = v9;
      }

      uint64_t v12 = *((void *)v7 + 7);
      memset(dst, 0, sizeof(dst));
      uuid_copy(dst, v7 + 32);
      if (qword_1008D5F30 != -1) {
        dispatch_once(&qword_1008D5F30, &stru_100897448);
      }
      uint64_t v13 = off_1008D5F28;
      id v14 = sub_100241F94(dst);
      BOOL v15 = (void *)objc_claimAutoreleasedReturnValue(v14);
      sub_1005D21E8((uint64_t)v13, v15, 0);

      sub_1001FDBCC((uint64_t **)(a1 + 48), (uint64_t *)v7);
      operator delete(v7);
      v32[0] = _NSConcreteStackBlock;
      v32[1] = 3321888768LL;
      void v32[2] = sub_1004131C8;
      v32[3] = &unk_100897360;
      uuid_copy(v33, dst);
      v32[4] = a2;
      v32[5] = v12;
      sub_100413D54((os_unfair_lock_s *)(a1 + 16), v32);
      int v16 = *(void **)(a1 + 72);
      __int16 v17 = sub_100241F94(dst);
      id v18 = (void *)objc_claimAutoreleasedReturnValue(v17);
      uint64_t v19 = (void *)objc_claimAutoreleasedReturnValue([v16 objectForKey:v18]);

      if (v19)
      {
        __int16 v20 = *(void **)(a1 + 72);
        char v21 = sub_100241F94(dst);
        int64_t v22 = (void *)objc_claimAutoreleasedReturnValue(v21);
        [v20 removeObjectForKey:v22];

        uint64_t v23 = (os_log_s *)qword_1008F75B0;
        if (os_log_type_enabled((os_log_t)qword_1008F75B0, OS_LOG_TYPE_DEFAULT))
        {
          id v24 = sub_100241F94(dst);
          __int16 v25 = (void *)objc_claimAutoreleasedReturnValue(v24);
          id v26 = [*(id *)(a1 + 72) count];
          int v28 = 138543618;
          int v29 = v25;
          __int16 v30 = 2048;
          id v31 = v26;
          _os_log_impl( (void *)&_mh_execute_header,  v23,  OS_LOG_TYPE_DEFAULT,  "Found pending connection to be processed for device %{public}@. transitioningGattDevices size: %lu",  (uint8_t *)&v28,  0x16u);
        }

        uint64_t v27 = sub_100404FE8();
        sub_100405384(v27, v19);
      }
    }
  }

void sub_100413184(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_1004131C8(uint64_t a1, uint64_t a2)
{
  int v3 = sub_100241F94((const unsigned __int8 *)(a1 + 48));
  id v4 = (id)objc_claimAutoreleasedReturnValue(v3);
  (*(void (**)(uint64_t))(*(void *)a2 + 8LL))(a2);
}

void sub_10041321C( _Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, id a10)
{
}

void sub_100413230(uint64_t a1, uint64_t a2)
{
}

void sub_100413240(uint64_t a1, uint64_t a2, unsigned __int8 a3, int a4, __int16 a5, int a6)
{
  if (*(_BYTE *)(a1 + 8))
  {
    uint64_t v12 = (os_log_s *)qword_1008F75B0;
    if (a6)
    {
      if (os_log_type_enabled((os_log_t)qword_1008F75B0, OS_LOG_TYPE_FAULT))
      {
        *(_DWORD *)__int128 buf = 67109120;
        int v25 = a6;
        _os_log_fault_impl( (void *)&_mh_execute_header,  v12,  OS_LOG_TYPE_FAULT,  "Gatt callback connected with error %{bluetooth:OI_STATUS}u",  buf,  8u);
        uint64_t v12 = (os_log_s *)qword_1008F75B0;
      }

      if (os_log_type_enabled(v12, OS_LOG_TYPE_ERROR)) {
        sub_10067CA9C(a6, v12);
      }
    }

    else
    {
      if (os_log_type_enabled((os_log_t)qword_1008F75B0, OS_LOG_TYPE_DEFAULT))
      {
        *(_DWORD *)__int128 buf = 67109376;
        int v25 = a4;
        __int16 v26 = 1024;
        int v27 = 0;
        _os_log_impl( (void *)&_mh_execute_header,  v12,  OS_LOG_TYPE_DEFAULT,  "Gatt device ready with mtu %d and status %{bluetooth:OI_STATUS}u",  buf,  0xEu);
      }

      uint64_t v13 = *(const unsigned __int8 **)(a1 + 48);
      if (v13 == (const unsigned __int8 *)(a1 + 56))
      {
LABEL_17:
        __int16 v17 = (os_log_s *)qword_1008F75B0;
        if (os_log_type_enabled((os_log_t)qword_1008F75B0, OS_LOG_TYPE_FAULT)) {
          sub_10067CA60(v17);
        }
      }

      else
      {
        while (*((void *)v13 + 6) != a2)
        {
          id v14 = (unsigned __int8 *)*((void *)v13 + 1);
          if (v14)
          {
            do
            {
              BOOL v15 = (const unsigned __int8 **)v14;
              id v14 = *(unsigned __int8 **)v14;
            }

            while (v14);
          }

          else
          {
            do
            {
              BOOL v15 = (const unsigned __int8 **)*((void *)v13 + 2);
              BOOL v16 = *v15 == v13;
              uint64_t v13 = (const unsigned __int8 *)v15;
            }

            while (!v16);
          }

          uint64_t v13 = (const unsigned __int8 *)v15;
        }

        uuid_copy(uu, v13 + 32);
        if (qword_1008D5F30 != -1) {
          dispatch_once(&qword_1008D5F30, &stru_100897448);
        }
        id v18 = off_1008D5F28;
        uint64_t v19 = sub_100241F94(uu);
        __int16 v20 = (void *)objc_claimAutoreleasedReturnValue(v19);
        sub_1005CF560((uint64_t)v18, v20, a5);

        v21[0] = _NSConcreteStackBlock;
        v21[1] = 3321888768LL;
        void v21[2] = sub_1004134D4;
        void v21[3] = &unk_100897390;
        uuid_copy(v23, uu);
        v23[16] = a3;
        __int16 v22 = a4;
        sub_100413D54((os_unfair_lock_s *)(a1 + 16), v21);
      }
    }
  }

void sub_1004134BC(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_1004134D4(uint64_t a1, uint64_t a2)
{
  int v3 = sub_100241F94((const unsigned __int8 *)(a1 + 34));
  id v4 = (id)objc_claimAutoreleasedReturnValue(v3);
  (*(void (**)(uint64_t))(*(void *)a2 + 16LL))(a2);
}

void sub_10041352C( _Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, id a10)
{
}

void sub_100413540(uint64_t a1, uint64_t a2)
{
}

BOOL sub_100413550(uint64_t a1, void *a2)
{
  id v3 = a2;
  sub_100241F90(uu2, v3);
  BOOL v4 = a1 + 56 != sub_1001FDB10(a1 + 48, uu2);

  return v4;
}

void sub_1004135D4(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

uint64_t sub_1004135EC(uint64_t a1, unsigned __int8 *a2, _DWORD *a3)
{
  if (!*(_BYTE *)(a1 + 8)) {
    return 408LL;
  }
  uint64_t v5 = sub_1001FDB10(a1 + 48, a2);
  if (a1 + 56 == v5) {
    return 1LL;
  }
  uint64_t v6 = v5;
  uint64_t result = 0LL;
  *a3 = *(_DWORD *)(v6 + 56);
  return result;
}

uint64_t sub_100413648(uint64_t a1, uint64_t (***a2)(void, void, void, void))
{
  return (**a2)(a2, *(void *)(a1 + 32), *(unsigned __int16 *)(a1 + 48), *(void *)(a1 + 40));
}

BOOL sub_100413664(uint64_t a1, unsigned __int8 *a2)
{
  if (qword_1008D5F30 != -1) {
    dispatch_once(&qword_1008D5F30, &stru_100897448);
  }
  *(void *)uu2 = 0LL;
  uint64_t v6 = 0LL;
  sub_1005C8684( (uint64_t)off_1008D5F28,  ((unint64_t)a2[128] << 40) | ((unint64_t)a2[129] << 32) | ((unint64_t)a2[130] << 24) | ((unint64_t)a2[131] << 16) | ((unint64_t)a2[132] << 8) | a2[133],  0,  1u,  0LL,  0LL,  uu2);
  return a1 + 56 != sub_1001FDB10(a1 + 48, uu2);
}

uint64_t sub_10041374C(uint64_t a1, void *a2)
{
  id v2 = a2;
  if (qword_1008D5F20 != -1) {
    dispatch_once(&qword_1008D5F20, &stru_1008974A8);
  }
  if (sub_10061C0F8(qword_1008D5F18, v2))
  {
    uint64_t v3 = 1LL;
  }

  else
  {
    if (qword_1008D5F30 != -1) {
      dispatch_once(&qword_1008D5F30, &stru_100897448);
    }
    uint64_t v4 = sub_1005CC198((uint64_t)off_1008D5F28, v2, 0);
    if ((v4 & 0xFFFFFFFFFFFFLL) != 0)
    {
      if (qword_1008D5F50 != -1) {
        dispatch_once(&qword_1008D5F50, &stru_100897468);
      }
      uint64_t v3 = (uint64_t)sub_10040007C(off_1008D5F48, v4, 0);
      if (v3)
      {
        if (qword_1008D67A8 != -1) {
          dispatch_once(&qword_1008D67A8, &stru_1008974C8);
        }
        uint64_t v3 = sub_10052F32C((uint64_t)off_1008D67A0, (unsigned __int8 *)v3);
      }
    }

    else
    {
      uint64_t v3 = 0LL;
    }
  }

  return v3;
}

void sub_100413888(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

BOOL sub_1004138A0(uint64_t a1)
{
  return *(void *)(a1 + 64) != 0LL;
}

id sub_1004138B0(uint64_t a1)
{
  return [*(id *)(a1 + 72) allKeys];
}

void sub_1004138B8(uint64_t a1, const unsigned __int8 *a2, uint64_t a3, unsigned int a4)
{
  int v8 = (os_log_s *)qword_1008F75B0;
  if (os_log_type_enabled((os_log_t)qword_1008F75B0, OS_LOG_TYPE_DEFAULT))
  {
    uint64_t v9 = (_DWORD)a3 ? "Enabling" : "Disabling";
    memset(out, 0, sizeof(out));
    uuid_unparse_upper(a2, out);
    sub_10002418C(__p, out);
    BOOL v10 = v20 >= 0 ? __p : (void **)__p[0];
    *(_DWORD *)uuid_string_t out = 136446722;
    *(void *)&out[4] = v9;
    *(_WORD *)&out[12] = 1024;
    *(_DWORD *)&out[14] = a4;
    *(_WORD *)&out[18] = 2082;
    *(void *)&out[20] = v10;
    _os_log_impl( (void *)&_mh_execute_header,  v8,  OS_LOG_TYPE_DEFAULT,  "%{public}s high priority stream for %d ms for device UUID %{public}s",  (uint8_t *)out,  0x1Cu);
    if (v20 < 0) {
      operator delete(__p[0]);
    }
  }

  uuid_copy(dst, a2);
  if (!*(_BYTE *)(a1 + 8) || (uint64_t v11 = sub_1001FDB10(a1 + 48, dst), a1 + 56 == v11))
  {
    BOOL v16 = (os_log_s *)qword_1008F75B0;
    if (os_log_type_enabled((os_log_t)qword_1008F75B0, OS_LOG_TYPE_ERROR))
    {
      memset(out, 0, sizeof(out));
      uuid_unparse_upper(a2, out);
      sub_10002418C(__p, out);
      __int16 v17 = v20 >= 0 ? __p : (void **)__p[0];
      *(_DWORD *)uuid_string_t out = 136446210;
      *(void *)&out[4] = v17;
      _os_log_error_impl( (void *)&_mh_execute_header,  v16,  OS_LOG_TYPE_ERROR,  "Unable to find acl connection handle for %{public}s",  (uint8_t *)out,  0xCu);
      if (v20 < 0) {
        operator delete(__p[0]);
      }
    }
  }

  else
  {
    uint64_t v12 = *(void *)(v11 + 48);
    if ((_DWORD)a3)
    {
      if (qword_1008D6198 != -1) {
        dispatch_once(&qword_1008D6198, &stru_1008974E8);
      }
      ++*((void *)off_1008D6190 + 26);
    }

    if (*(_DWORD *)(sub_1002E6E9C() + 708) < 0x7D0u || *(_DWORD *)(sub_1002E6E9C() + 708) > 0xF9Fu)
    {
      uint64_t v18 = sub_1002E6E9C();
      (*(void (**)(uint64_t, unint64_t, uint64_t, uint64_t, uint64_t, uint64_t, uint64_t, void))(*(void *)v18 + 72LL))( v18,  *(unsigned int *)(v12 + 48) | ((unint64_t)*(unsigned __int16 *)(v12 + 52) << 32),  17LL,  4LL,  a3,  1LL,  1LL,  0LL);
    }

    else
    {
      uint64_t v13 = sub_1002E6E9C();
      if ((_DWORD)a3) {
        uint64_t v14 = 4LL;
      }
      else {
        uint64_t v14 = 0LL;
      }
      if ((_DWORD)a3) {
        uint64_t v15 = a4;
      }
      else {
        uint64_t v15 = 0LL;
      }
      (*(void (**)(uint64_t, uint64_t, uint64_t, uint64_t))(*(void *)v13 + 1656LL))(v13, v12, v14, v15);
    }
  }

void sub_100413B74(uint64_t a1)
{
  if (qword_1008D9278 != -1) {
    dispatch_once(&qword_1008D9278, &stru_100897508);
  }
  sub_100412310( qword_1008D9270,  *(void *)(a1 + 32),  *(void *)(a1 + 40),  *(unsigned __int16 *)(a1 + 64),  *(void *)(a1 + 48),  *(_DWORD *)(a1 + 56),  *(_DWORD *)(a1 + 60));
  if (qword_1008D6198 != -1) {
    dispatch_once(&qword_1008D6198, &stru_1008974E8);
  }
  *((void *)off_1008D6190 + 26) = 0LL;
}

void sub_100413C08(uint64_t a1)
{
  if (qword_1008D9278 != -1) {
    dispatch_once(&qword_1008D9278, &stru_100897508);
  }
  sub_100412E9C(qword_1008D9270, *(void **)(a1 + 32), *(_DWORD *)(a1 + 40));
}

void sub_100413C5C(uint64_t a1)
{
  if (qword_1008D9278 != -1) {
    dispatch_once(&qword_1008D9278, &stru_100897508);
  }
  sub_100413240( qword_1008D9270,  *(void *)(a1 + 32),  *(_BYTE *)(a1 + 48),  *(unsigned __int16 *)(a1 + 44),  *(_WORD *)(a1 + 46),  *(_DWORD *)(a1 + 40));
}

void sub_100413CBC(uint64_t a1, uint64_t a2)
{
}

void sub_100413CC4(uint64_t a1, uint64_t a2)
{
  uint64_t v5 = *(char **)(a1 + 8);
  uint64_t v4 = *(char **)(a1 + 16);
  if (v5 != v4)
  {
    while (*(void *)v5 != a2)
    {
      v5 += 8;
      if (v5 == v4)
      {
        uint64_t v5 = *(char **)(a1 + 16);
        break;
      }
    }
  }

  if (v5 == v4)
  {
    uint64_t v6 = a2;
    sub_1004142D4(a1 + 8, v4, (char *)&v6);
    sub_100008A30(a1 + 8);
  }

  os_unfair_lock_unlock((os_unfair_lock_t)a1);
}

void sub_100413D4C(uint64_t a1, uint64_t a2)
{
}

void sub_100413D54(os_unfair_lock_s *a1, void *a2)
{
  uint64_t v3 = a2;
  os_unfair_lock_lock(a1);
  uint64_t v5 = 0LL;
  uint64_t v6 = 0LL;
  uint64_t v7 = 0LL;
  sub_100240540(&v5, (uint64_t)&a1[2]);
  os_unfair_lock_unlock(a1);
  uint64_t v4 = v5;
  if (v5 != v6)
  {
    do
      v3[2](v3, *v4++);
    while (v4 != v6);
    uint64_t v4 = v5;
  }

  if (v4)
  {
    uint64_t v6 = v4;
    operator delete(v4);
  }
}

void sub_100413DE8( _Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void *__p, uint64_t a11)
{
  _Unwind_Resume(a1);
}

void sub_100413E18(uint64_t a1)
{
  int v1 = (void *)sub_100413E2C(a1);
  operator delete(v1);
}

uint64_t sub_100413E2C(uint64_t a1)
{
  *(void *)a1 = off_1008972F0;

  sub_10023BF24(a1 + 48, *(void **)(a1 + 56));
  id v2 = *(void **)(a1 + 24);
  if (v2)
  {
    *(void *)(a1 + 32) = v2;
    operator delete(v2);
  }

  return a1;
}

void sub_100413E7C(id a1)
{
  int v1 = operator new(0x230uLL);
  sub_10042BC28();
  off_1008D60A8 = v1;
}

void sub_100413EAC(_Unwind_Exception *a1)
{
}

void sub_100413EC0(id a1)
{
  int v1 = operator new(0x618uLL);
  sub_10058B0A4();
  off_1008D5F08 = v1;
}

void sub_100413EF0(_Unwind_Exception *a1)
{
}

void sub_100413F04(id a1)
{
  int v1 = operator new(0x128uLL);
  sub_1005C69F8();
  off_1008D5F28 = v1;
}

void sub_100413F34(_Unwind_Exception *a1)
{
}

void sub_100413F48(id a1)
{
  int v1 = operator new(0x138uLL);
  sub_1003FE3E0((uint64_t)v1);
  off_1008D5F48 = v1;
}

void sub_100413F78(_Unwind_Exception *a1)
{
}

void sub_100413F8C(id a1)
{
  int v1 = operator new(0x2C0uLL);
  sub_1004219F0();
  off_1008D60C8 = v1;
}

void sub_100413FBC(_Unwind_Exception *a1)
{
}

uint64_t *sub_100413FD0( uint64_t **a1, unsigned __int8 *uu1, uint64_t a3, const unsigned __int8 *__attribute__((__org_typedef(uuid_t))) *a4)
{
  uint64_t v9 = 0LL;
  uint64_t v6 = (uint64_t **)sub_1001FD824((uint64_t)a1, &v9, uu1);
  uint64_t result = *v6;
  if (!*v6)
  {
    memset(v8, 0, sizeof(v8));
    sub_100414070((uint64_t)a1, a4, v8);
    sub_100029630(a1, v9, v6, (uint64_t *)v8[0]);
    return (uint64_t *)v8[0];
  }

  return result;
}

void sub_100414070( uint64_t a1@<X0>, const unsigned __int8 *__attribute__((__org_typedef(uuid_t))) *a2@<X2>, unsigned __int8 **a3@<X8>)
{
  uint64_t v5 = (unsigned __int8 *)(a1 + 8);
  *a3 = 0LL;
  a3[1] = 0LL;
  a3[2] = 0LL;
  uint64_t v6 = (unsigned __int8 *)operator new(0x40uLL);
  *a3 = v6;
  a3[1] = v5;
  *((_BYTE *)a3 + 16) = 0;
  uuid_copy(v6 + 32, *a2);
  *((void *)v6 + 6) = 0LL;
  *((void *)v6 + 7) = 0LL;
  *((_BYTE *)a3 + 16) = 1;
}

void sub_1004140D0(_Unwind_Exception *a1)
{
  *int v1 = 0LL;
  operator delete(v2);
  _Unwind_Resume(a1);
}

void sub_1004140E8(id a1)
{
  int v1 = operator new(0xEB0uLL);
  sub_10061991C();
  qword_1008D5F18 = (uint64_t)v1;
}

void sub_100414118(_Unwind_Exception *a1)
{
}

void sub_10041412C(id a1)
{
  int v1 = operator new(0x260uLL);
  sub_1005285C8((uint64_t)v1);
  off_1008D67A0 = v1;
}

void sub_10041415C(_Unwind_Exception *a1)
{
}

void sub_100414170(id a1)
{
  int v1 = (char *)operator new(0x200uLL);
  *(void *)int v1 = off_100898F60;
  *((void *)v1 + 1) = &off_100898FF0;
  *((void *)v1 + 2) = off_100899008;
  *((void *)v1 + 3) = &off_100899060;
  *((void *)v1 + 4) = &off_100899078;
  sub_100242DC4(v1 + 40);
  *((void *)v1 + 14) = 0LL;
  *((_DWORD *)v1 + 30) = 0;
  *((void *)v1 + 17) = 0LL;
  *((void *)v1 + 1_Block_object_dispose(va, 8) = 0LL;
  *((void *)v1 + 16) = 0LL;
  *(_OWORD *)(v1 + 155) = 0u;
  *(_OWORD *)(v1 + 171) = 0u;
  *(_OWORD *)(v1 + 187) = 0u;
  *(_WORD *)(v1 + 203) = 1;
  *((void *)v1 + 26) = 0LL;
  *((_WORD *)v1 + 10_Block_object_dispose(va, 8) = 256;
  *((void *)v1 + 29) = 0LL;
  *((void *)v1 + 2_Block_object_dispose(va, 8) = v1 + 232;
  *((void *)v1 + 32) = 0LL;
  *((void *)v1 + 33) = 0LL;
  *((void *)v1 + 30) = 0LL;
  *((void *)v1 + 31) = v1 + 256;
  v1[272] = 0;
  *((_DWORD *)v1 + 69) = 0;
  v1[280] = 0;
  *((_WORD *)v1 + 189) = 0;
  *(void *)(v1 + 313) = 0LL;
  *(_OWORD *)(v1 + 300) = 0u;
  *(_OWORD *)(v1 + 284) = 0u;
  *(_OWORD *)(v1 + 32_Block_object_dispose(va, 8) = 0u;
  *(_OWORD *)(v1 + 344) = 0u;
  *(_OWORD *)(v1 + 360) = 0u;
  v1[376] = 0;
  *((void *)v1 + 51) = v1 + 416;
  *((void *)v1 + 52) = 0LL;
  *((void *)v1 + 55) = 0LL;
  *((void *)v1 + 56) = 0LL;
  *((void *)v1 + 53) = 0LL;
  *((void *)v1 + 54) = v1 + 440;
  *((void *)v1 + 57) = v1 + 464;
  *((void *)v1 + 5_Block_object_dispose(va, 8) = 0LL;
  *((void *)v1 + 59) = 0LL;
  *((void *)v1 + 60) = @"XZ";
  *((void *)v1 + 62) = 0LL;
  *((_DWORD *)v1 + 126) = 0;
  off_1008D6190 = v1;
}

void sub_100414278(_Unwind_Exception *a1)
{
}

void sub_10041428C(id a1)
{
  int v1 = (char *)operator new(0x50uLL);
  *(void *)int v1 = off_1008972F0;
  v1[8] = 0;
  *((_DWORD *)v1 + 4) = 0;
  *((void *)v1 + 3) = 0LL;
  *((void *)v1 + 4) = 0LL;
  *((void *)v1 + _Block_object_dispose(va, 8) = 0LL;
  *((void *)v1 + 9) = 0LL;
  *((void *)v1 + 7) = 0LL;
  *((void *)v1 + 5) = 0LL;
  *((void *)v1 + 6) = v1 + 56;
  qword_1008D9270 = (uint64_t)v1;
}

char *sub_1004142D4(uint64_t a1, char *__src, char *a3)
{
  uint64_t v3 = a3;
  uint64_t v4 = __src;
  uint64_t v6 = *(char **)(a1 + 8);
  uint64_t v8 = a1 + 16;
  unint64_t v7 = *(void *)(a1 + 16);
  if ((unint64_t)v6 >= v7)
  {
    uint64_t v13 = *(char **)a1;
    unint64_t v14 = ((uint64_t)&v6[-*(void *)a1] >> 3) + 1;
    if (v14 >> 61) {
      abort();
    }
    uint64_t v15 = __src - v13;
    uint64_t v16 = (__src - v13) >> 3;
    uint64_t v17 = v7 - (void)v13;
    if (v17 >> 2 > v14) {
      unint64_t v14 = v17 >> 2;
    }
    else {
      unint64_t v18 = v14;
    }
    uint64_t v30 = a1 + 16;
    if (v18) {
      uint64_t v19 = (char *)sub_100008BA0(a1 + 16, v18);
    }
    else {
      uint64_t v19 = 0LL;
    }
    char v20 = &v19[8 * v16];
    std::string __p = v19;
    int v27 = v20;
    int v28 = v20;
    int v29 = &v19[8 * v18];
    if (v16 == v18)
    {
      if (v15 < 1)
      {
        if (v13 == v4) {
          unint64_t v22 = 1LL;
        }
        else {
          unint64_t v22 = v15 >> 2;
        }
        uint64_t v23 = (char *)sub_100008BA0(v8, v22);
        char v20 = &v23[8 * (v22 >> 2)];
        std::string __p = v23;
        int v27 = v20;
        int v29 = &v23[8 * v24];
        if (v19) {
          operator delete(v19);
        }
      }

      else
      {
        unint64_t v21 = v16 + 2;
        if (v16 >= -1) {
          unint64_t v21 = v16 + 1;
        }
        v20 -= 8 * (v21 >> 1);
        int v27 = v20;
      }
    }

    *(void *)char v20 = *(void *)v3;
    int v28 = v20 + 8;
    uint64_t v4 = sub_100008ADC((void **)a1, (uint64_t)&__p, v4);
    if (v28 != v27) {
      v28 += (v27 - v28 + 7) & 0xFFFFFFFFFFFFFFF8LL;
    }
    if (__p) {
      operator delete(__p);
    }
  }

  else if (__src == v6)
  {
    *(void *)unint64_t __src = *(void *)a3;
    *(void *)(a1 + _Block_object_dispose(va, 8) = __src + 8;
  }

  else
  {
    uint64_t v9 = __src + 8;
    BOOL v10 = v6 - 8;
    uint64_t v11 = *(void **)(a1 + 8);
    while (v10 < v6)
    {
      uint64_t v12 = *(void *)v10;
      v10 += 8;
      *v11++ = v12;
    }

    *(void *)(a1 + _Block_object_dispose(va, 8) = v11;
    if (v6 != v9) {
      memmove(&v6[-8 * ((v6 - v9) >> 3)], __src, v6 - v9);
    }
    if (v4 <= v3) {
      v3 += 8 * (*(void *)(a1 + 8) > (unint64_t)v3);
    }
    *(void *)uint64_t v4 = *(void *)v3;
  }

  return v4;
}

void sub_1004144D8( _Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void *__p, uint64_t a11, uint64_t a12)
{
  if (__p) {
    operator delete(__p);
  }
  _Unwind_Resume(exception_object);
}

uint64_t sub_100414514(uint64_t a1)
{
  id v2 = *(void **)a1;
  if (v2)
  {
    *(void *)(a1 + _Block_object_dispose(va, 8) = v2;
    operator delete(v2);
  }

  return a1;
}

uint64_t sub_100414544(uint64_t a1)
{
  return a1;
}

uint64_t sub_10041456C(uint64_t a1, uint64_t a2)
{
  *(_OWORD *)(a1 + 16) = 0u;
  *(_OWORD *)(a1 + 32) = 0u;
  *(_OWORD *)a1 = 0u;
  sub_100242DC4(a1 + 48);
  *(void *)(a1 + 112) = a2;
  *(_DWORD *)(a1 + 132) = 0;
  *(_DWORD *)(a1 + 136) = 0;
  *(_DWORD *)(a1 + 140) = -1;
  *(void *)(a1 + 14_Block_object_dispose(va, 8) = 0LL;
  *(_BYTE *)(a1 + 156) = 2;
  return a1;
}

void sub_1004145BC(_Unwind_Exception *a1)
{
}

uint64_t sub_1004145D4(void *a1)
{
  return sub_10038CEAC(a1);
}

uint64_t sub_1004145FC()
{
  v7[0] = 0LL;
  v7[1] = 0LL;
  sub_100242F28((uint64_t)v7, (uint64_t)&unk_1008F7280);
  qword_1008F72C0 = 0LL;
  sub_100242F54((uint64_t)v7);
  uint64_t v0 = qword_1008F0AE8;
  if (qword_1008F0AE8)
  {
    free((void *)qword_1008F0AE8);
    qword_1008F0AE8 = 0LL;
  }

  sub_100414814(v0, 0);
  uint64_t v1 = sub_1002E6E00();
  sub_10002418C(buf, "SDPMirroring");
  sub_10002418C(__p, "DisableSDPMirroring");
  (*(void (**)(uint64_t, uint8_t *, void **, char *))(*(void *)v1 + 72LL))(v1, buf, __p, &byte_1008F0AF0);
  if (v6 < 0) {
    operator delete(__p[0]);
  }
  if (v9 < 0) {
    operator delete(*(void **)buf);
  }
  id v2 = (os_log_s *)qword_1008F75D8;
  if (os_log_type_enabled((os_log_t)qword_1008F75D8, OS_LOG_TYPE_DEFAULT))
  {
    *(_DWORD *)__int128 buf = 67109120;
    *(_DWORD *)&uint8_t buf[4] = byte_1008F0AF0;
    _os_log_impl((void *)&_mh_execute_header, v2, OS_LOG_TYPE_DEFAULT, "SDP Mirroring is disabled: %d", buf, 8u);
  }

  buf[0] = 0;
  sub_100242CA4(buf);
  int v3 = sub_1001E39A4((uint64_t)&off_100897528);
  sub_1001E2470(byte_1008F0AF0);
  sub_100242CD0(buf);
  if (v3 && os_log_type_enabled((os_log_t)qword_1008F75D8, OS_LOG_TYPE_ERROR)) {
    sub_10067CB0C();
  }
  sub_100242CD8(buf);
  return sub_100242FAC((uint64_t)v7);
}

void sub_1004147B0( _Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void *__p, uint64_t a11, int a12, __int16 a13, char a14, char a15, char a16, uint64_t a17, void *a18, uint64_t a19, int a20, __int16 a21, char a22, char a23)
{
}

uint64_t sub_100414814(uint64_t a1, char a2)
{
  unsigned __int128 v15 = 0u;
  memset(v14, 0, sizeof(v14));
  v13[0] = 0LL;
  v13[1] = 0LL;
  sub_100242F28((uint64_t)v13, (uint64_t)&unk_1008F7280);
  uint64_t v3 = *((void *)&xmmword_1008F72E8 + 1);
  if (*((void *)&xmmword_1008F72E8 + 1))
  {
    uint64_t v4 = (os_log_s *)qword_1008F75D8;
    if (os_log_type_enabled((os_log_t)qword_1008F75D8, OS_LOG_TYPE_DEFAULT))
    {
      *(_DWORD *)__int128 buf = 134217984;
      uint64_t v17 = v3;
      _os_log_impl( (void *)&_mh_execute_header,  v4,  OS_LOG_TYPE_DEFAULT,  "Clearing the client queue (had %lu queries)",  buf,  0xCu);
    }

    sub_100419664(v14, &qword_1008F72C8);
    while (*((void *)&xmmword_1008F72E8 + 1))
    {
      *(void *)&xmmword_1008F72E8 = xmmword_1008F72E8 + 1;
      --*((void *)&xmmword_1008F72E8 + 1);
      sub_100254FCC((uint64_t)&qword_1008F72C8, 1);
    }
  }

  if ((a2 & 1) == 0)
  {
    uint64_t v5 = qword_1008F72C0;
    if (qword_1008F72C0)
    {
      char v6 = (os_log_s *)qword_1008F75D8;
      if (os_log_type_enabled((os_log_t)qword_1008F75D8, OS_LOG_TYPE_DEFAULT))
      {
        *(_WORD *)__int128 buf = 0;
        _os_log_impl( (void *)&_mh_execute_header,  v6,  OS_LOG_TYPE_DEFAULT,  "We don't want to keep the current query alive",  buf,  2u);
        uint64_t v5 = qword_1008F72C0;
      }

      *(void *)(v5 + 120) = 0LL;
    }
  }

  sub_100242F54((uint64_t)v13);
  if (*((void *)&v15 + 1))
  {
    unint64_t v7 = v15;
    do
    {
      uint64_t v8 = *(void **)(*(void *)(*((void *)&v14[0] + 1) + ((v7 >> 6) & 0x3FFFFFFFFFFFFF8LL)) + 8 * (v7 & 0x1FF));
      uint64_t v9 = v8[15];
      if (v9) {
        (*(void (**)(uint64_t, void *, uint64_t))(*(void *)v9 + 16LL))(v9, v8, 308LL);
      }
      sub_100242E28(v8 + 6);
      BOOL v10 = (void *)sub_10038CEAC(v8);
      operator delete(v10);
      uint64_t v11 = *((void *)&v15 + 1) - 1LL;
      unint64_t v7 = v15 + 1;
      unsigned __int128 v15 = __PAIR128__(*((unint64_t *)&v15 + 1), (uint64_t)v15 + 1) + __PAIR128__(-1LL, 0LL);
      if (v7 >= 0x400)
      {
        operator delete(**((void ***)&v14[0] + 1));
        unint64_t v7 = v15 - 512;
        *((void *)&v14[0] + 1) += 8LL;
        *(void *)&unsigned __int128 v15 = v15 - 512;
        uint64_t v11 = *((void *)&v15 + 1);
      }
    }

    while (v11);
  }

  sub_100242FAC((uint64_t)v13);
  return sub_1002400EC(v14);
}

void sub_100414A30(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, ...)
{
}

uint64_t sub_100414A5C()
{
  uint64_t v0 = (os_log_s *)qword_1008F75D8;
  if (os_log_type_enabled((os_log_t)qword_1008F75D8, OS_LOG_TYPE_DEFAULT))
  {
    *(_WORD *)__int128 buf = 0;
    _os_log_impl((void *)&_mh_execute_header, v0, OS_LOG_TYPE_DEFAULT, "SdpClient::stackWillStop enter", buf, 2u);
  }

  *(void *)__int128 buf = 0LL;
  uint64_t v5 = 0LL;
  sub_100242F28((uint64_t)buf, (uint64_t)&unk_1008F7280);
  if (qword_1008F0AE8) {
    *(_BYTE *)(qword_1008F0AE8 + 212) = 1;
  }
  sub_100242F54((uint64_t)buf);
  uint64_t v1 = (os_log_s *)qword_1008F75D8;
  if (os_log_type_enabled((os_log_t)qword_1008F75D8, OS_LOG_TYPE_DEFAULT))
  {
    *(_WORD *)uint64_t v3 = 0;
    _os_log_impl((void *)&_mh_execute_header, v1, OS_LOG_TYPE_DEFAULT, "SdpClient::stackWillStop exit", v3, 2u);
  }

  return sub_100242FAC((uint64_t)buf);
}

void sub_100414B34(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, ...)
{
}

uint64_t sub_100414B48(uint64_t a1, uint64_t a2)
{
  v9[0] = 0LL;
  v9[1] = 0LL;
  sub_100242F28((uint64_t)v9, (uint64_t)&unk_1008F72F8);
  if (byte_1008D9880)
  {
    sub_100242F54((uint64_t)v9);
    *(void *)(a1 + 120) = a2;
    *(_DWORD *)(a1 + 12_Block_object_dispose(va, 8) = 1;
    v8[0] = 0LL;
    v8[1] = 0LL;
    sub_100242F28((uint64_t)v8, (uint64_t)&unk_1008F7280);
    if (qword_1008F72C0)
    {
      *(void *)__int128 buf = a1;
      sub_100419288(&qword_1008F72C8, buf);
    }

    else
    {
      if (*((void *)&xmmword_1008F72E8 + 1)) {
        sub_1001EE2A0();
      }
      qword_1008F72C0 = a1;
    }

    uint64_t v5 = *((void *)&xmmword_1008F72E8 + 1);
    sub_100242F54((uint64_t)v8);
    if (v5)
    {
      char v6 = (os_log_s *)qword_1008F75D8;
      if (os_log_type_enabled((os_log_t)qword_1008F75D8, OS_LOG_TYPE_DEFAULT))
      {
        *(_DWORD *)__int128 buf = 134217984;
        *(void *)&uint8_t buf[4] = v5;
        _os_log_impl( (void *)&_mh_execute_header,  v6,  OS_LOG_TYPE_DEFAULT,  "Waiting for %zu queries ahead of us",  buf,  0xCu);
      }
    }

    else
    {
      sub_100414D2C(a1, 0);
    }

    sub_100242FAC((uint64_t)v8);
    uint64_t v4 = 0LL;
  }

  else
  {
    if (os_log_type_enabled((os_log_t)qword_1008F75D8, OS_LOG_TYPE_ERROR)) {
      sub_10067CB6C();
    }
    sub_100242F54((uint64_t)v9);
    uint64_t v4 = 17LL;
    (*(void (**)(uint64_t, uint64_t, uint64_t))(*(void *)a2 + 16LL))(a2, a1, 17LL);
  }

  sub_100242FAC((uint64_t)v9);
  return v4;
}

void sub_100414CF8( _Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, char a11)
{
}

uint64_t sub_100414D2C(uint64_t a1, int a2)
{
  uint64_t v3 = (_DWORD *)qword_1008F0AE8;
  if (qword_1008F0AE8)
  {
    uint64_t v4 = *(void *)qword_1008F0AE8;
  }

  else
  {
    uint64_t v3 = malloc(0xD8uLL);
    qword_1008F0AE8 = (uint64_t)v3;
    uint64_t v4 = *(void *)(a1 + 112);
    *(void *)uint64_t v3 = v4;
    v3[52] = 0;
    *((_BYTE *)v3 + 212) = 0;
  }

  char v6 = (os_log_s *)qword_1008F75D8;
  if (!v4)
  {
    if (os_log_type_enabled((os_log_t)qword_1008F75D8, OS_LOG_TYPE_ERROR)) {
      sub_10067CB9C();
    }
    return 1LL;
  }

  if (os_log_type_enabled((os_log_t)qword_1008F75D8, OS_LOG_TYPE_DEFAULT))
  {
    if (v3[52]) {
      unint64_t v7 = "Retrying connection to";
    }
    else {
      unint64_t v7 = "Connecting to";
    }
    sub_1003CF00C(v4, __p);
    if (v29 >= 0) {
      uint64_t v8 = __p;
    }
    else {
      uint64_t v8 = *(_BYTE **)__p;
    }
    *(_DWORD *)__int128 buf = 136446466;
    id v31 = v7;
    __int16 v32 = 2082;
    uint64_t v33 = v8;
    _os_log_impl( (void *)&_mh_execute_header,  v6,  OS_LOG_TYPE_DEFAULT,  "%{public}s SDP server for device %{public}s",  buf,  0x16u);
    if (v29 < 0) {
      operator delete(*(void **)__p);
    }
    char v6 = (os_log_s *)qword_1008F75D8;
  }

  if (os_log_type_enabled(v6, OS_LOG_TYPE_DEFAULT))
  {
    uint64_t v9 = *(int *)(qword_1008F72C0 + 132);
    else {
      BOOL v10 = off_100897758[v9];
    }
    *(_DWORD *)std::string __p = 136315394;
    *(void *)&__p[4] = v10;
    *(_WORD *)&_BYTE __p[12] = 2080;
    *(void *)&__p[14] = "SDP_CONNECT_STATE";
    _os_log_impl( (void *)&_mh_execute_header,  v6,  OS_LOG_TYPE_DEFAULT,  "SDP Client State Change: %s -> %s\n",  __p,  0x16u);
  }

  *(_DWORD *)(qword_1008F72C0 + 132) = 1;
  if (sub_1003D17A4(*(void *)qword_1008F0AE8))
  {
    uint64_t v11 = (os_log_s *)qword_1008F75D8;
    if (os_log_type_enabled((os_log_t)qword_1008F75D8, OS_LOG_TYPE_DEFAULT))
    {
      sub_1003CF00C(*(void *)qword_1008F0AE8, __p);
      uint64_t v12 = v29 >= 0 ? __p : *(const char **)__p;
      *(_DWORD *)__int128 buf = 136446210;
      id v31 = v12;
      _os_log_impl( (void *)&_mh_execute_header,  v11,  OS_LOG_TYPE_DEFAULT,  "Applying SDP workaround for Type S Game Controllers to device %{public}s",  buf,  0xCu);
      if (v29 < 0) {
        operator delete(*(void **)__p);
      }
    }

    sub_1001DF214();
  }

  if (!a2)
  {
    __p[0] = 0;
    sub_100242CA4(__p);
    int v13 = sub_1001DF224((uint64_t)sub_100415188, (uint64_t)sub_100415200, *(void *)qword_1008F0AE8 + 128LL);
    sub_100242CD8(__p);
    if (v13) {
      goto LABEL_32;
    }
    return 0LL;
  }

  int v13 = sub_1001DF224((uint64_t)sub_100415188, (uint64_t)sub_100415200, *(void *)qword_1008F0AE8 + 128LL);
  if (!v13) {
    return 0LL;
  }
LABEL_32:
  unint64_t v14 = (os_log_s *)qword_1008F75D8;
  if (os_log_type_enabled((os_log_t)qword_1008F75D8, OS_LOG_TYPE_ERROR)) {
    sub_10067CC3C(v13, v14);
  }
  *(void *)std::string __p = 0LL;
  *(void *)&__p[8] = 0LL;
  sub_100242F28((uint64_t)__p, (uint64_t)&unk_1008F7280);
  unsigned __int128 v15 = (void *)qword_1008F72C0;
  if (!qword_1008F72C0)
  {
    sub_1001EE2A0();
    unsigned __int128 v15 = (void *)qword_1008F72C0;
  }

  qword_1008F72C0 = 0LL;
  if (*((void *)&xmmword_1008F72E8 + 1))
  {
    *(void *)&xmmword_1008F72E8 = xmmword_1008F72E8 + 1;
    --*((void *)&xmmword_1008F72E8 + 1);
    sub_100254FCC((uint64_t)&qword_1008F72C8, 1);
    qword_1008F72C0 = v16;
  }

  else
  {
    uint64_t v16 = 0LL;
  }

  sub_100242F54((uint64_t)__p);
  uint64_t v18 = v15[15];
  if (v18) {
    (*(void (**)(uint64_t, void *, uint64_t))(*(void *)v18 + 16LL))(v18, v15, 309LL);
  }
  sub_100242E28(v15 + 6);
  uint64_t v19 = (void *)sub_10038CEAC(v15);
  operator delete(v19);
  if (v16)
  {
    if (*(_BYTE *)(qword_1008F0AE8 + 212))
    {
      char v20 = (os_log_s *)qword_1008F75D8;
      if (os_log_type_enabled((os_log_t)qword_1008F75D8, OS_LOG_TYPE_FAULT)) {
        sub_10067CBCC(v20, v21, v22, v23, v24, v25, v26, v27);
      }
    }

    sub_100414D2C(v16, 1LL);
  }

  sub_100242FAC((uint64_t)__p);
  return 1LL;
}

void sub_100415138( _Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, char a9)
{
}

const char *sub_100415164(unsigned int a1)
{
  if (a1 > 0xA) {
    return "unknown sdp state";
  }
  else {
    return off_100897758[a1];
  }
}

void sub_100415188(uint64_t a1)
{
  if ((_DWORD)a1)
  {
    if (qword_1008D60B0 != -1) {
      dispatch_once(&qword_1008D60B0, &stru_100897668);
    }
    *(_DWORD *)(qword_1008F72C0 + 12_Block_object_dispose(va, 8) = sub_1004317E0((uint64_t)off_1008D60A8, a1, 10000);
    uint64_t v2 = sub_100404EB8();
    sub_100405384(v2, &stru_100897578);
  }

  else
  {
    sub_10041521C();
  }

void sub_100415200()
{
  uint64_t v0 = sub_100404EB8();
  sub_100405384(v0, &stru_100897578);
}

void sub_10041521C()
{
  __int128 v27 = xmmword_1006C2CD0;
  BOOL v0 = sub_1003D50AC(*(void *)qword_1008F0AE8, &v27);
  uint64_t v1 = (os_log_s *)qword_1008F75D8;
  if (os_log_type_enabled((os_log_t)qword_1008F75D8, OS_LOG_TYPE_DEFAULT))
  {
    if (qword_1008F72C0)
    {
      uint64_t v2 = *(int *)(qword_1008F72C0 + 132);
      else {
        uint64_t v3 = off_100897758[v2];
      }
    }

    else
    {
      uint64_t v3 = "";
    }

    int v4 = *(unsigned __int8 *)(*(void *)qword_1008F0AE8 + 784LL);
    BOOL v5 = sub_1003D2AF4(*(void *)qword_1008F0AE8);
    int v6 = *(unsigned __int8 *)(*(void *)qword_1008F0AE8 + 578LL);
    *(_DWORD *)__int128 buf = 136316162;
    char v29 = v3;
    __int16 v30 = 1024;
    *(_DWORD *)id v31 = v4;
    *(_WORD *)&uint8_t v31[4] = 1024;
    *(_DWORD *)&_BYTE v31[6] = v0;
    __int16 v32 = 1024;
    BOOL v33 = v5;
    __int16 v34 = 1024;
    int v35 = v6;
    _os_log_impl( (void *)&_mh_execute_header,  v1,  OS_LOG_TYPE_DEFAULT,  "Statemachine start: %s, d2d %d, isLocalServiceDiscoveryClassExist %d, AppleBT %d isFullSDPRequired %d",  buf,  0x24u);
  }

  uint64_t v7 = *(void *)qword_1008F0AE8;
  if (*(_BYTE *)(*(void *)qword_1008F0AE8 + 784LL))
  {
    *(_BYTE *)(v7 + 784) = 0;
    __int128 v26 = unk_100897538;
    int v8 = sub_1001DF9E0((uint64_t)sub_100415748, 0x30u, (unsigned __int8 *)&v26);
    if (v8) {
      goto LABEL_37;
    }
    uint64_t v9 = (os_log_s *)qword_1008F75D8;
    if (os_log_type_enabled((os_log_t)qword_1008F75D8, OS_LOG_TYPE_DEFAULT))
    {
      uint64_t v10 = *(int *)(qword_1008F72C0 + 132);
      else {
        uint64_t v11 = off_100897758[v10];
      }
      *(_DWORD *)__int128 buf = 136315394;
      char v29 = v11;
      __int16 v30 = 2080;
      *(void *)id v31 = "SDP_SEARCH_D2D_STATE";
      _os_log_impl( (void *)&_mh_execute_header,  v9,  OS_LOG_TYPE_DEFAULT,  "SDP Client State Change: %s -> %s\n",  buf,  0x16u);
    }

    uint64_t v20 = qword_1008F72C0;
    int v21 = 3;
    goto LABEL_36;
  }

  if (v0
    && sub_1003D2E50(v7, &v27, 0x201u)
    && *(_DWORD *)(qword_1008F72C0 + 132) != 7
    && !*(_BYTE *)(*(void *)qword_1008F0AE8 + 578LL))
  {
    uint64_t v22 = (os_log_s *)qword_1008F75D8;
    if (os_log_type_enabled((os_log_t)qword_1008F75D8, OS_LOG_TYPE_DEFAULT))
    {
      *(_WORD *)__int128 buf = 0;
      _os_log_impl( (void *)&_mh_execute_header,  v22,  OS_LOG_TYPE_DEFAULT,  "Executing Service Database State lookup",  buf,  2u);
    }

    __int128 v26 = unk_100897548;
    int v8 = sub_1001DFD4C((uint64_t)sub_1004158FC, 0, (unsigned __int8 *)&v26);
    uint64_t v23 = (os_log_s *)qword_1008F75D8;
    if (!v8)
    {
      if (os_log_type_enabled((os_log_t)qword_1008F75D8, OS_LOG_TYPE_DEFAULT))
      {
        uint64_t v24 = sub_100415164(*(_DWORD *)(qword_1008F72C0 + 132));
        *(_DWORD *)__int128 buf = 136315394;
        char v29 = v24;
        __int16 v30 = 2080;
        *(void *)id v31 = "SDP_DATABASE_QUERY_STATE";
        _os_log_impl( (void *)&_mh_execute_header,  v23,  OS_LOG_TYPE_DEFAULT,  "SDP Client State Change: %s -> %s\n",  buf,  0x16u);
      }

      uint64_t v20 = qword_1008F72C0;
      int v21 = 5;
      goto LABEL_36;
    }

    if (os_log_type_enabled((os_log_t)qword_1008F75D8, OS_LOG_TYPE_ERROR)) {
      sub_10067CD74();
    }
  }

  else
  {
    uint64_t v12 = (os_log_s *)qword_1008F75D8;
    if (os_log_type_enabled((os_log_t)qword_1008F75D8, OS_LOG_TYPE_DEFAULT))
    {
      *(_WORD *)__int128 buf = 0;
      _os_log_impl((void *)&_mh_execute_header, v12, OS_LOG_TYPE_DEFAULT, "Executing full SDP", buf, 2u);
    }

    *(_BYTE *)(*(void *)qword_1008F0AE8 + 578LL) = 0;
    __int128 v26 = 0uLL;
    __int16 v25 = 0;
    uint64_t v13 = *(void *)(qword_1008F72C0 + 112);
    int v14 = sub_10010F8B0(v13 + 128, &v25);
    unsigned __int128 v15 = &unk_1006C2BA8;
    if (!v14 && v25 == 97)
    {
      if (sub_1003D17A4(v13))
      {
        uint64_t v16 = (os_log_s *)qword_1008F75D8;
        if (os_log_type_enabled((os_log_t)qword_1008F75D8, OS_LOG_TYPE_DEFAULT))
        {
          *(_WORD *)__int128 buf = 0;
          _os_log_impl( (void *)&_mh_execute_header,  v16,  OS_LOG_TYPE_DEFAULT,  "Overriding SDP search for unauthorized Type S controller",  buf,  2u);
        }

        unsigned __int128 v15 = &unk_1006C2B98;
      }

      else
      {
        unsigned __int128 v15 = &unk_1006C2BA8;
      }
    }

    LOBYTE(v26) = 6;
    WORD1(v26) = 1;
    *((void *)&v26 + 1) = v15;
    int v8 = sub_1001DF9E0((uint64_t)sub_100415748, 0x30u, (unsigned __int8 *)&v26);
    if (!v8)
    {
      uint64_t v17 = (os_log_s *)qword_1008F75D8;
      if (os_log_type_enabled((os_log_t)qword_1008F75D8, OS_LOG_TYPE_DEFAULT))
      {
        uint64_t v18 = *(int *)(qword_1008F72C0 + 132);
        else {
          uint64_t v19 = off_100897758[v18];
        }
        *(_DWORD *)__int128 buf = 136315394;
        char v29 = v19;
        __int16 v30 = 2080;
        *(void *)id v31 = "SDP_SEARCH_STATE";
        _os_log_impl( (void *)&_mh_execute_header,  v17,  OS_LOG_TYPE_DEFAULT,  "SDP Client State Change: %s -> %s\n",  buf,  0x16u);
      }

      uint64_t v20 = qword_1008F72C0;
      int v21 = 2;
LABEL_36:
      *(_DWORD *)(v20 + 132) = v21;
    }
  }

void sub_100415748(int *a1, unsigned int a2, int a3)
{
  int v6 = (os_log_s *)qword_1008F75D8;
  if (os_log_type_enabled((os_log_t)qword_1008F75D8, OS_LOG_TYPE_DEFAULT))
  {
    uint64_t v7 = *(int *)(qword_1008F72C0 + 132);
    else {
      int v8 = off_100897758[v7];
    }
    v14[0] = 67109634;
    v14[1] = a2;
    __int16 v15 = 1024;
    int v16 = a3;
    __int16 v17 = 2080;
    uint64_t v18 = v8;
    _os_log_impl( (void *)&_mh_execute_header,  v6,  OS_LOG_TYPE_DEFAULT,  "Service search response with %d records, status %{bluetooth:OI_STATUS}u with state %s",  (uint8_t *)v14,  0x18u);
  }

  if (a3)
  {
    if (os_log_type_enabled((os_log_t)qword_1008F75D8, OS_LOG_TYPE_ERROR)) {
      sub_10067CDD4();
    }
    *(_DWORD *)(qword_1008F72C0 + 12_Block_object_dispose(va, 8) = 1;
LABEL_10:
    sub_100416100();
    return;
  }

  if (!a2)
  {
    uint64_t v13 = (os_log_s *)qword_1008F75D8;
    if (os_log_type_enabled((os_log_t)qword_1008F75D8, OS_LOG_TYPE_DEFAULT))
    {
      LOWORD(v14[0]) = 0;
      _os_log_impl( (void *)&_mh_execute_header,  v13,  OS_LOG_TYPE_DEFAULT,  "Service search yields no records, we're done",  (uint8_t *)v14,  2u);
    }

    *(_DWORD *)(qword_1008F72C0 + 12_Block_object_dispose(va, 8) = 0;
    goto LABEL_10;
  }

  uint64_t v9 = qword_1008F0AE8;
  *(_DWORD *)(qword_1008F0AE8 + 200) = a2;
  uint64_t v10 = a2;
  uint64_t v11 = (_DWORD *)(v9 + 8);
  do
  {
    int v12 = *a1++;
    *v11++ = v12;
    --v10;
  }

  while (v10);
  *(_DWORD *)(v9 + 204) = 0;
  sub_100416900();
}

void sub_1004158FC(unsigned __int8 *a1, int a2, int a3)
{
  int v6 = (os_log_s *)qword_1008F75D8;
  if (os_log_type_enabled((os_log_t)qword_1008F75D8, OS_LOG_TYPE_DEFAULT))
  {
    uint64_t v7 = *(int *)(qword_1008F72C0 + 132);
    else {
      int v8 = off_100897758[v7];
    }
    *(_DWORD *)__int128 buf = 136315650;
    *(void *)&uint8_t buf[4] = v8;
    *(_WORD *)&_BYTE buf[12] = 1024;
    *(_DWORD *)&buf[14] = a2;
    *(_WORD *)&_BYTE buf[18] = 1024;
    *(_DWORD *)&buf[20] = a3;
    _os_log_impl( (void *)&_mh_execute_header,  v6,  OS_LOG_TYPE_DEFAULT,  "Service database state response with state %s, more %d, status %{bluetooth:OI_STATUS}u",  buf,  0x18u);
  }

  if (a3)
  {
    if (a3 == 802)
    {
      uint64_t v9 = qword_1008F72C0;
      uint64_t v10 = (os_log_s *)qword_1008F75D8;
      if (*(_DWORD *)(qword_1008F72C0 + 132) == 5)
      {
        if (os_log_type_enabled((os_log_t)qword_1008F75D8, OS_LOG_TYPE_DEFAULT))
        {
          *(_WORD *)__int128 buf = 0;
          _os_log_impl( (void *)&_mh_execute_header,  v10,  OS_LOG_TYPE_DEFAULT,  "Remote device does not support ServiceDataBaseState restarting full SDP",  buf,  2u);
          uint64_t v10 = (os_log_s *)qword_1008F75D8;
          uint64_t v9 = qword_1008F72C0;
        }

        if (os_log_type_enabled(v10, OS_LOG_TYPE_DEFAULT))
        {
          uint64_t v11 = *(int *)(v9 + 132);
          else {
            int v12 = off_100897758[v11];
          }
          *(_DWORD *)__int128 buf = 136315394;
          *(void *)&uint8_t buf[4] = v12;
          *(_WORD *)&_BYTE buf[12] = 2080;
          *(void *)&buf[14] = "SDP_DATABASE_CACHE_UPDATE_REQUIRED";
          _os_log_impl( (void *)&_mh_execute_header,  v10,  OS_LOG_TYPE_DEFAULT,  "SDP Client State Change: %s -> %s\n",  buf,  0x16u);
          uint64_t v9 = qword_1008F72C0;
        }

        *(_DWORD *)(v9 + 132) = 7;
        uint64_t v26 = sub_100404EB8();
        sub_100405384(v26, &stru_1008975E8);
        return;
      }
    }

    else
    {
      uint64_t v10 = (os_log_s *)qword_1008F75D8;
    }

    if (os_log_type_enabled(v10, OS_LOG_TYPE_ERROR)) {
      sub_10067CE34();
    }
    *(_DWORD *)(qword_1008F72C0 + 12_Block_object_dispose(va, 8) = 1;
    sub_100416100();
  }

  else if ((*a1 & 0xFE) == 6)
  {
    uint64_t v13 = qword_1008F72C0;
    if (*(_DWORD *)(qword_1008F72C0 + 132) == 5)
    {
      __int128 v46 = xmmword_1006C2CD0;
      int v14 = (os_log_s *)qword_1008F75D8;
      if (os_log_type_enabled((os_log_t)qword_1008F75D8, OS_LOG_TYPE_DEFAULT))
      {
        *(_WORD *)__int128 buf = 0;
        _os_log_impl( (void *)&_mh_execute_header,  v14,  OS_LOG_TYPE_DEFAULT,  "Starting SDP database state matching",  buf,  2u);
      }

      sub_100417998(a1);
      uint64_t v15 = qword_1008F72C0;
      if (*(_DWORD *)(qword_1008F72C0 + 140) == -1)
      {
        __int128 v27 = (os_log_s *)qword_1008F75D8;
        if (os_log_type_enabled((os_log_t)qword_1008F75D8, OS_LOG_TYPE_DEFAULT))
        {
          int v28 = sub_100415164(*(_DWORD *)(v15 + 132));
          *(_DWORD *)__int128 buf = 136315394;
          *(void *)&uint8_t buf[4] = v28;
          *(_WORD *)&_BYTE buf[12] = 2080;
          *(void *)&buf[14] = "SDP_DATABASE_REMOTE_STATE_NOT_FOUND";
          _os_log_impl( (void *)&_mh_execute_header,  v27,  OS_LOG_TYPE_DEFAULT,  "SDP Client State Change: %s -> %s\n",  buf,  0x16u);
          uint64_t v15 = qword_1008F72C0;
        }

        unsigned int v29 = 6;
        *(_DWORD *)(v15 + 132) = 6;
LABEL_49:
        uint64_t v32 = qword_1008F75D8;
        if (os_log_type_enabled((os_log_t)qword_1008F75D8, OS_LOG_TYPE_DEFAULT))
        {
          BOOL v33 = sub_100415164(v29);
          *(_DWORD *)__int128 buf = 136315394;
          *(void *)&uint8_t buf[4] = v33;
          *(_WORD *)&_BYTE buf[12] = 2080;
          *(void *)&buf[14] = "SDP_DATABASE_RFCOMM_UPDATE_STATE";
          __int16 v34 = (os_log_s *)v32;
LABEL_51:
          _os_log_impl( (void *)&_mh_execute_header,  v34,  OS_LOG_TYPE_DEFAULT,  "SDP Client State Change: %s -> %s\n",  buf,  0x16u);
          uint64_t v15 = qword_1008F72C0;
        }
      }

      else
      {
        memset(buf, 0, sizeof(buf));
        uint64_t v16 = sub_1003D4C9C(*(void *)(qword_1008F72C0 + 112), (uint64_t)&v46, 0x201u, (void **)buf);
        if ((_DWORD)v16 && **(_BYTE **)buf == 1)
        {
          int v18 = *(_DWORD *)(*(void *)buf + 8LL);
          uint64_t v19 = (os_log_s *)qword_1008F75D8;
          if (os_log_type_enabled((os_log_t)qword_1008F75D8, OS_LOG_TYPE_DEFAULT))
          {
            int v20 = *(_DWORD *)(qword_1008F72C0 + 140);
            *(_DWORD *)uint64_t v47 = 67109376;
            *(_DWORD *)&v47[4] = v18;
            *(_WORD *)&v47[8] = 1024;
            *(_DWORD *)&v47[10] = v20;
            _os_log_impl( (void *)&_mh_execute_header,  v19,  OS_LOG_TYPE_DEFAULT,  "SdpServiceDataBaseState [local 0x%x, remote 0x%x]",  v47,  0xEu);
          }

          uint64_t v21 = qword_1008F72C0;
          int v22 = *(_DWORD *)(qword_1008F72C0 + 140);
          uint64_t v23 = (os_log_s *)qword_1008F75D8;
          uint64_t v16 = os_log_type_enabled((os_log_t)qword_1008F75D8, OS_LOG_TYPE_DEFAULT);
          if (v18 == v22)
          {
            if ((_DWORD)v16)
            {
              uint64_t v24 = sub_100415164(*(_DWORD *)(v21 + 132));
              *(_DWORD *)uint64_t v47 = 136315394;
              *(void *)&v47[4] = v24;
              *(_WORD *)&v47[12] = 2080;
              *(void *)&v47[14] = "SDP_DATABASE_VERIFY_COMPLETE_STATE";
              _os_log_impl( (void *)&_mh_execute_header,  v23,  OS_LOG_TYPE_DEFAULT,  "SDP Client State Change: %s -> %s\n",  v47,  0x16u);
              uint64_t v21 = qword_1008F72C0;
            }

            int v25 = 8;
          }

          else
          {
            if ((_DWORD)v16)
            {
              __int16 v30 = sub_100415164(*(_DWORD *)(v21 + 132));
              *(_DWORD *)uint64_t v47 = 136315394;
              *(void *)&v47[4] = v30;
              *(_WORD *)&v47[12] = 2080;
              *(void *)&v47[14] = "SDP_DATABASE_CACHE_UPDATE_REQUIRED";
              _os_log_impl( (void *)&_mh_execute_header,  v23,  OS_LOG_TYPE_DEFAULT,  "SDP Client State Change: %s -> %s\n",  v47,  0x16u);
              uint64_t v21 = qword_1008F72C0;
            }

            int v25 = 7;
          }

          *(_DWORD *)(v21 + 132) = v25;
        }

        id v31 = *(_OWORD **)buf;
        if (*(void *)buf != *(void *)&buf[8])
        {
          do
          {
            *(void *)uint64_t v47 = 0LL;
            *(void *)&v47[8] = 0LL;
            *(_OWORD *)uint64_t v47 = *v31;
            sub_10025EB84(v47);
            ++v31;
          }

          while (v31 != *(_OWORD **)&buf[8]);
          id v31 = *(_OWORD **)buf;
        }

        if (v31)
        {
          *(void *)&uint8_t buf[8] = v31;
          operator delete(v31);
        }

        uint64_t v15 = qword_1008F72C0;
        unsigned int v29 = *(_DWORD *)(qword_1008F72C0 + 132);
        switch(v29)
        {
          case 5u:
            int v39 = *(_DWORD *)(qword_1008F72C0 + 140);
            int v40 = (os_log_s *)qword_1008F75D8;
            BOOL v41 = os_log_type_enabled((os_log_t)qword_1008F75D8, OS_LOG_TYPE_DEFAULT);
            if (v39 != -1)
            {
              if (v41)
              {
                *(_WORD *)__int128 buf = 0;
                _os_log_impl( (void *)&_mh_execute_header,  v40,  OS_LOG_TYPE_DEFAULT,  "Local database state not found, but remote state exists, full SDP",  buf,  2u);
                int v40 = (os_log_s *)qword_1008F75D8;
                uint64_t v15 = qword_1008F72C0;
              }

              if (os_log_type_enabled(v40, OS_LOG_TYPE_DEFAULT))
              {
                uint64_t v42 = sub_100415164(*(_DWORD *)(v15 + 132));
                *(_DWORD *)__int128 buf = 136315394;
                *(void *)&uint8_t buf[4] = v42;
                *(_WORD *)&_BYTE buf[12] = 2080;
                *(void *)&buf[14] = "SDP_DATABASE_CACHE_UPDATE_REQUIRED";
                _os_log_impl( (void *)&_mh_execute_header,  v40,  OS_LOG_TYPE_DEFAULT,  "SDP Client State Change: %s -> %s\n",  buf,  0x16u);
                uint64_t v15 = qword_1008F72C0;
              }

              *(_DWORD *)(v15 + 132) = 7;
              uint64_t v43 = sub_100404EB8();
              sub_100405384(v43, &stru_100897608);
              goto LABEL_53;
            }

            if (v41)
            {
              *(_WORD *)__int128 buf = 0;
              _os_log_impl( (void *)&_mh_execute_header,  v40,  OS_LOG_TYPE_DEFAULT,  "Local database state not found and remote state does not exist, move onto RFCOMM",  buf,  2u);
              int v40 = (os_log_s *)qword_1008F75D8;
              uint64_t v15 = qword_1008F72C0;
            }

            if (os_log_type_enabled(v40, OS_LOG_TYPE_DEFAULT))
            {
              int v45 = sub_100415164(*(_DWORD *)(v15 + 132));
              *(_DWORD *)__int128 buf = 136315394;
              *(void *)&uint8_t buf[4] = v45;
              *(_WORD *)&_BYTE buf[12] = 2080;
              *(void *)&buf[14] = "SDP_DATABASE_RFCOMM_UPDATE_STATE";
              __int16 v34 = v40;
              goto LABEL_51;
            }

            break;
          case 6u:
          case 8u:
            goto LABEL_49;
          case 7u:
            sub_10041521C(v16, v17);
            goto LABEL_53;
          default:
            uint64_t v44 = (os_log_s *)qword_1008F75D8;
            if (os_log_type_enabled((os_log_t)qword_1008F75D8, OS_LOG_TYPE_ERROR)) {
              sub_10067CE94(v29, v44);
            }
            goto LABEL_53;
        }
      }

      *(_DWORD *)(v15 + 132) = 9;
LABEL_53:
      if (*(_DWORD *)(qword_1008F72C0 + 132) == 9)
      {
        int v35 = sub_1003E31E8(*(void *)(qword_1008F72C0 + 112), (void *)qword_1008F72C0);
        char v36 = (os_log_s *)qword_1008F75D8;
        BOOL v37 = os_log_type_enabled((os_log_t)qword_1008F75D8, OS_LOG_TYPE_DEFAULT);
        if (v35)
        {
          if (v37)
          {
            uint64_t v38 = *(void *)(qword_1008F72C0 + 40);
            *(_DWORD *)__int128 buf = 134217984;
            *(void *)&uint8_t buf[4] = v38;
            _os_log_impl( (void *)&_mh_execute_header,  v36,  OS_LOG_TYPE_DEFAULT,  "Found %lu services supported RFCOMM, starting channel query",  buf,  0xCu);
          }

          byte_1008D9881 = 0;
          sub_100417D9C();
        }

        else
        {
          if (v37)
          {
            *(_WORD *)__int128 buf = 0;
            _os_log_impl( (void *)&_mh_execute_header,  v36,  OS_LOG_TYPE_DEFAULT,  "No RFCOMM services, we're done",  buf,  2u);
          }

          *(_DWORD *)(qword_1008F72C0 + 12_Block_object_dispose(va, 8) = 0;
          sub_100416100();
        }
      }

      uint64_t v13 = qword_1008F72C0;
    }

    *(_DWORD *)(v13 + 140) = -1;
  }

  else if (os_log_type_enabled((os_log_t)qword_1008F75D8, OS_LOG_TYPE_ERROR))
  {
    sub_10067CF14();
  }

void sub_1004160D8( _Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, void *__p, uint64_t a16)
{
  if (__p) {
    operator delete(__p);
  }
  _Unwind_Resume(exception_object);
}

void sub_100416100()
{
  BOOL v0 = (os_log_s *)qword_1008F75D8;
  if (os_log_type_enabled((os_log_t)qword_1008F75D8, OS_LOG_TYPE_DEFAULT))
  {
    uint64_t v1 = *(int *)(qword_1008F72C0 + 132);
    else {
      uint64_t v2 = off_100897758[v1];
    }
    int v4 = 136315394;
    BOOL v5 = v2;
    __int16 v6 = 2080;
    uint64_t v7 = "SDP_DISCONNECT_STATE";
    _os_log_impl( (void *)&_mh_execute_header,  v0,  OS_LOG_TYPE_DEFAULT,  "SDP Client State Change: %s -> %s\n",  (uint8_t *)&v4,  0x16u);
  }

  *(_DWORD *)(qword_1008F72C0 + 132) = 10;
  if (sub_1001DF894())
  {
    uint64_t v3 = sub_100404EB8();
    sub_100405384(v3, &stru_100897578);
  }

void sub_100416200()
{
  int v0 = *(unsigned __int8 *)(qword_1008F0AE8 + 212);
  uint64_t v1 = *(void *)qword_1008F0AE8;
  unsigned int v34 = *(_DWORD *)(*(void *)qword_1008F0AE8 + 128LL);
  unsigned __int16 v35 = *(_WORD *)(*(void *)qword_1008F0AE8 + 132LL);
  unsigned int v2 = bswap32(v34);
  if (v2 != 693561)
  {
    unsigned int v3 = 693561;
LABEL_5:
    if (v2 < v3) {
      int v4 = -1;
    }
    else {
      int v4 = 1;
    }
    goto LABEL_8;
  }

  unsigned int v2 = bswap32(v35) >> 16;
  unsigned int v3 = 0xFFFF;
  if (v2 != 0xFFFF) {
    goto LABEL_5;
  }
  int v4 = 0;
LABEL_8:
  if (v4 < 1) {
    goto LABEL_27;
  }
  unsigned int v5 = bswap32(v34);
  unsigned int v6 = 693586;
  if (v5 != 693586 || (v6 = 0, v7 = 0, (unsigned int v5 = bswap32(v35) >> 16) != 0))
  {
    if (v5 < v6) {
      int v7 = -1;
    }
    else {
      int v7 = 1;
    }
  }

  if ((v7 & 0x80000000) == 0
    || ((uint64_t v8 = qword_1008F72C0, v9 = *(_DWORD *)(qword_1008F72C0 + 128), v9 != 307)
      ? (BOOL v10 = (v9 - 316) > 0x12)
      : (BOOL v10 = 0),
        v10))
  {
LABEL_27:
    if (!*(_BYTE *)(qword_1008F0AE8 + 212))
    {
      int v15 = *(_DWORD *)(qword_1008F0AE8 + 208);
      uint64_t v16 = qword_1008F72C0;
      int v17 = *(unsigned __int8 *)(qword_1008F72C0 + 156);
      int v18 = (os_log_s *)qword_1008F75D8;
      if (os_log_type_enabled((os_log_t)qword_1008F75D8, OS_LOG_TYPE_DEFAULT))
      {
        sub_1003CF00C(v1, buf);
        if (v37 >= 0) {
          uint64_t v19 = buf;
        }
        else {
          uint64_t v19 = *(_BYTE **)buf;
        }
        int v20 = *(_DWORD *)(qword_1008F72C0 + 128);
        *(_DWORD *)std::string __p = 136316162;
        *(void *)&__p[4] = "handleDisconnectInd";
        *(_WORD *)&_BYTE __p[12] = 2082;
        *(void *)&__p[14] = v19;
        __int16 v39 = 1024;
        int v40 = v20;
        __int16 v41 = 1024;
        int v42 = v15;
        __int16 v43 = 1024;
        int v44 = v17;
        _os_log_impl( (void *)&_mh_execute_header,  v18,  OS_LOG_TYPE_DEFAULT,  "%s: device %{public}s, result %d, attempts %d, totalRetries %d",  __p,  0x28u);
        if (v37 < 0) {
          operator delete(*(void **)buf);
        }
        uint64_t v16 = qword_1008F72C0;
      }

      int v21 = *(_DWORD *)(v16 + 128);
      if (v21 != 307 && (v21 - 316) > 0x12)
      {
        if ((v21 == 314 || v21 == 310) && (v15 < v17 || !v15 && !v17))
        {
          ++*(_DWORD *)(qword_1008F0AE8 + 208);
          uint64_t v33 = sub_100404EB8();
          sub_100405460(v33, 500LL, &stru_100897558);
          return;
        }
      }

      else if (v15 < v17)
      {
        ++*(_DWORD *)(qword_1008F0AE8 + 208);
        sub_100414D2C(v16, 1);
        return;
      }
    }
  }

  else
  {
    uint64_t v11 = (os_log_s *)qword_1008F75D8;
    if (os_log_type_enabled((os_log_t)qword_1008F75D8, OS_LOG_TYPE_DEFAULT))
    {
      sub_1003CF00C(v1, __p);
      if (v39 >= 0) {
        int v12 = __p;
      }
      else {
        int v12 = *(_BYTE **)__p;
      }
      *(_DWORD *)__int128 buf = 136446210;
      *(void *)&uint8_t buf[4] = v12;
      _os_log_impl( (void *)&_mh_execute_header,  v11,  OS_LOG_TYPE_DEFAULT,  "Unsupported legacy Q6 keyboard discovered in device %{public}s",  buf,  0xCu);
      if (SHIBYTE(v39) < 0) {
        operator delete(*(void **)__p);
      }
      uint64_t v8 = qword_1008F72C0;
    }

    *(_DWORD *)(v8 + 12_Block_object_dispose(va, 8) = 109;
  }

  if (qword_1008F0AE8)
  {
    free((void *)qword_1008F0AE8);
    qword_1008F0AE8 = 0LL;
  }

  *(void *)std::string __p = 0LL;
  *(void *)&__p[8] = 0LL;
  sub_100242F28((uint64_t)__p, (uint64_t)&unk_1008F7280);
  uint64_t v13 = qword_1008F72C0;
  if (!qword_1008F72C0)
  {
    sub_1001EE2A0();
    uint64_t v13 = qword_1008F72C0;
  }

  qword_1008F72C0 = 0LL;
  if (*((void *)&xmmword_1008F72E8 + 1))
  {
    *(void *)&xmmword_1008F72E8 = xmmword_1008F72E8 + 1;
    --*((void *)&xmmword_1008F72E8 + 1);
    sub_100254FCC((uint64_t)&qword_1008F72C8, 1);
    qword_1008F72C0 = v14;
  }

  else
  {
    uint64_t v14 = 0LL;
  }

  sub_100242F54((uint64_t)__p);
  uint64_t v23 = *(void *)(v13 + 120);
  if (v23) {
    (*(void (**)(uint64_t, uint64_t, void))(*(void *)v23 + 16LL))(v23, v13, *(unsigned int *)(v13 + 128));
  }
  sub_100242E28(v13 + 48);
  uint64_t v24 = (void *)sub_10038CEAC((void *)v13);
  operator delete(v24);
  if (v14)
  {
    if (v0)
    {
      int v25 = (os_log_s *)qword_1008F75D8;
      if (os_log_type_enabled((os_log_t)qword_1008F75D8, OS_LOG_TYPE_FAULT)) {
        sub_10067CF44(v25, v26, v27, v28, v29, v30, v31, v32);
      }
    }

    sub_100414D2C(v14, 1);
  }

  sub_100242FAC((uint64_t)__p);
}

void sub_10041660C( _Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, char a15)
{
}

void sub_100416628(id a1)
{
}

void sub_100416638()
{
  int v0 = (os_log_s *)qword_1008F75D8;
  if (os_log_type_enabled((os_log_t)qword_1008F75D8, OS_LOG_TYPE_DEFAULT))
  {
    sub_1003CF00C(*(void *)qword_1008F0AE8, __p);
    uint64_t v1 = (void **)__p[0];
    if (v15 >= 0) {
      uint64_t v1 = __p;
    }
    int v2 = *(_DWORD *)(qword_1008F0AE8 + 208);
    int v3 = *(_DWORD *)(qword_1008F72C0 + 128);
    uint64_t v4 = *(int *)(qword_1008F72C0 + 132);
    else {
      unsigned int v5 = off_100897758[v4];
    }
    *(_DWORD *)__int128 buf = 136446978;
    int v17 = v1;
    __int16 v18 = 1024;
    *(_DWORD *)uint64_t v19 = v3;
    *(_WORD *)&v19[4] = 1024;
    *(_DWORD *)&v19[6] = v2;
    __int16 v20 = 2080;
    int v21 = v5;
    _os_log_impl( (void *)&_mh_execute_header,  v0,  OS_LOG_TYPE_DEFAULT,  "SDP disconnected from device %{public}s with result %d, outstanding attempts %d, state %s",  buf,  0x22u);
    if (v15 < 0) {
      operator delete(__p[0]);
    }
  }

  uint64_t v6 = qword_1008F72C0;
  if ((*(_DWORD *)(qword_1008F72C0 + 132) - 2) <= 2)
  {
    int v7 = (os_log_s *)qword_1008F75D8;
    if (os_log_type_enabled((os_log_t)qword_1008F75D8, OS_LOG_TYPE_DEFAULT))
    {
      int v8 = *(_DWORD *)(*(void *)(v6 + 112) + 608LL);
      *(_DWORD *)__int128 buf = 67109120;
      LODWORD(v17) = v8;
      _os_log_impl( (void *)&_mh_execute_header,  v7,  OS_LOG_TYPE_DEFAULT,  "SDP disconnected during query states, version %d",  buf,  8u);
      uint64_t v6 = qword_1008F72C0;
    }

    uint64_t v9 = *(void *)(v6 + 112);
    if (!*(_DWORD *)(v9 + 608))
    {
      sub_1003CED44(v9);
      uint64_t v6 = qword_1008F72C0;
    }
  }

  BOOL v10 = (os_log_s *)qword_1008F75D8;
  if (os_log_type_enabled((os_log_t)qword_1008F75D8, OS_LOG_TYPE_DEFAULT))
  {
    uint64_t v11 = *(int *)(v6 + 132);
    else {
      int v12 = off_100897758[v11];
    }
    *(_DWORD *)__int128 buf = 136315394;
    int v17 = (void *)v12;
    __int16 v18 = 2080;
    *(void *)uint64_t v19 = "SDP_IDLE_STATE";
    _os_log_impl( (void *)&_mh_execute_header,  v10,  OS_LOG_TYPE_DEFAULT,  "SDP Client State Change: %s -> %s\n",  buf,  0x16u);
    uint64_t v6 = qword_1008F72C0;
  }

  *(_DWORD *)(v6 + 132) = 0;
  if (*(_BYTE *)(qword_1008F0AE8 + 212))
  {
    uint64_t v13 = (os_log_s *)qword_1008F75D8;
    if (os_log_type_enabled((os_log_t)qword_1008F75D8, OS_LOG_TYPE_DEFAULT))
    {
      *(_WORD *)__int128 buf = 0;
      _os_log_impl( (void *)&_mh_execute_header,  v13,  OS_LOG_TYPE_DEFAULT,  "SDPClient Disconnect dispatch called during system shut down, clean up",  buf,  2u);
    }

    sub_100416200();
  }

  else
  {
    buf[0] = 0;
    sub_100242CA4(buf);
    sub_100416200();
    sub_100242CD8(buf);
  }

void sub_1004168E0(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, ...)
{
}

void sub_100416900()
{
  __int128 v26 = unk_100897598;
  uint64_t v0 = qword_1008F0AE8;
  uint64_t v1 = *(int *)(qword_1008F0AE8 + 204);
  int v2 = (os_log_s *)qword_1008F75D8;
  if (os_log_type_enabled((os_log_t)qword_1008F75D8, OS_LOG_TYPE_DEFAULT))
  {
    int v3 = *(_DWORD *)(v0 + 200);
    if (qword_1008F72C0)
    {
      uint64_t v4 = *(int *)(qword_1008F72C0 + 132);
      else {
        unsigned int v5 = off_100897758[v4];
      }
    }

    else
    {
      unsigned int v5 = "";
    }

    *(_DWORD *)__int128 buf = 67109634;
    *(_DWORD *)uint64_t v28 = v1;
    *(_WORD *)&uint8_t v28[4] = 1024;
    *(_DWORD *)&void v28[6] = v3;
    *(_WORD *)uint64_t v29 = 2080;
    *(void *)&void v29[2] = v5;
    _os_log_impl( (void *)&_mh_execute_header,  v2,  OS_LOG_TYPE_DEFAULT,  "Issuing attribute request service-index [current %d, total %d], state %s",  buf,  0x18u);
    uint64_t v7 = qword_1008F0AE8;
    int v6 = *(_DWORD *)(qword_1008F0AE8 + 204);
  }

  else
  {
    int v6 = v1;
    uint64_t v7 = v0;
  }

  if (v6 == *(_DWORD *)(v7 + 200))
  {
    uint64_t v8 = qword_1008F72C0;
    unsigned int v9 = *(_DWORD *)(qword_1008F72C0 + 132);
    if (v9 == 3)
    {
      uint64_t v13 = (os_log_s *)qword_1008F75D8;
      if (os_log_type_enabled((os_log_t)qword_1008F75D8, OS_LOG_TYPE_DEFAULT))
      {
        *(_WORD *)__int128 buf = 0;
        uint64_t v14 = "D2D look up complete";
LABEL_25:
        _os_log_impl((void *)&_mh_execute_header, v13, OS_LOG_TYPE_DEFAULT, v14, buf, 2u);
        uint64_t v8 = qword_1008F72C0;
      }
    }

    else
    {
      if (v9 != 5)
      {
        if (v9 == 4)
        {
          __int128 v25 = unk_1008975A8;
          BOOL v10 = (os_log_s *)qword_1008F75D8;
          if (os_log_type_enabled((os_log_t)qword_1008F75D8, OS_LOG_TYPE_DEFAULT))
          {
            *(_WORD *)__int128 buf = 0;
            _os_log_impl( (void *)&_mh_execute_header,  v10,  OS_LOG_TYPE_DEFAULT,  "DID complete, start service discovery class search",  buf,  2u);
          }

          int v11 = sub_1001DF9E0((uint64_t)sub_100415748, 0x30u, (unsigned __int8 *)&v25);
          int v12 = (os_log_s *)qword_1008F75D8;
          if (v11)
          {
            if (os_log_type_enabled((os_log_t)qword_1008F75D8, OS_LOG_TYPE_ERROR)) {
              sub_10067D014();
            }
LABEL_38:
            *(_DWORD *)(qword_1008F72C0 + 12_Block_object_dispose(va, 8) = 0;
            goto LABEL_39;
          }

          if (os_log_type_enabled((os_log_t)qword_1008F75D8, OS_LOG_TYPE_DEFAULT))
          {
            uint64_t v17 = *(int *)(qword_1008F72C0 + 132);
            else {
              __int16 v18 = off_100897758[v17];
            }
            *(_DWORD *)__int128 buf = 136315394;
            *(void *)uint64_t v28 = v18;
            *(_WORD *)&v28[8] = 2080;
            *(void *)uint64_t v29 = "SDP_DATABASE_QUERY_STATE";
            _os_log_impl( (void *)&_mh_execute_header,  v12,  OS_LOG_TYPE_DEFAULT,  "SDP Client State Change: %s -> %s\n",  buf,  0x16u);
          }

          uint64_t v23 = qword_1008F72C0;
          int v24 = 5;
        }

        else
        {
          char v15 = (os_log_s *)qword_1008F75D8;
          if (os_log_type_enabled((os_log_t)qword_1008F75D8, OS_LOG_TYPE_DEFAULT))
          {
            if (v9 > 0xA) {
              uint64_t v16 = "unknown sdp state";
            }
            else {
              uint64_t v16 = off_100897688[v9];
            }
            *(_DWORD *)__int128 buf = 136315138;
            *(void *)uint64_t v28 = v16;
            _os_log_impl( (void *)&_mh_execute_header,  v15,  OS_LOG_TYPE_DEFAULT,  "Found all services, starting DID while in state %s",  buf,  0xCu);
          }

          __int128 v25 = unk_1008975B8;
          int v19 = sub_1001DF9E0((uint64_t)sub_100415748, 0x30u, (unsigned __int8 *)&v25);
          __int16 v20 = (os_log_s *)qword_1008F75D8;
          if (v19)
          {
            if (os_log_type_enabled((os_log_t)qword_1008F75D8, OS_LOG_TYPE_ERROR)) {
              sub_10067CFB4();
            }
            goto LABEL_38;
          }

          if (os_log_type_enabled((os_log_t)qword_1008F75D8, OS_LOG_TYPE_DEFAULT))
          {
            uint64_t v21 = *(int *)(qword_1008F72C0 + 132);
            else {
              int v22 = off_100897758[v21];
            }
            *(_DWORD *)__int128 buf = 136315394;
            *(void *)uint64_t v28 = v22;
            *(_WORD *)&v28[8] = 2080;
            *(void *)uint64_t v29 = "SDP_DID_STATE";
            _os_log_impl( (void *)&_mh_execute_header,  v20,  OS_LOG_TYPE_DEFAULT,  "SDP Client State Change: %s -> %s\n",  buf,  0x16u);
          }

          uint64_t v23 = qword_1008F72C0;
          int v24 = 4;
        }

        *(_DWORD *)(v23 + 132) = v24;
        return;
      }

      uint64_t v13 = (os_log_s *)qword_1008F75D8;
      if (os_log_type_enabled((os_log_t)qword_1008F75D8, OS_LOG_TYPE_DEFAULT))
      {
        *(_WORD *)__int128 buf = 0;
        uint64_t v14 = "Database state lookup complete";
        goto LABEL_25;
      }
    }

    *(_DWORD *)(v8 + 12_Block_object_dispose(va, 8) = 0;
LABEL_39:
    sub_100416100();
    return;
  }

  if (sub_1001DFD4C((uint64_t)sub_100416D88, *(_DWORD *)(v0 + 4 * v1 + 8), (unsigned __int8 *)&v26)
    && os_log_type_enabled((os_log_t)qword_1008F75D8, OS_LOG_TYPE_ERROR))
  {
    sub_10067D074();
  }

void sub_100416D88(uint64_t a1, int a2, int a3)
{
  int v6 = (os_log_s *)qword_1008F75D8;
  if (os_log_type_enabled((os_log_t)qword_1008F75D8, OS_LOG_TYPE_DEFAULT))
  {
    uint64_t v7 = *(int *)(qword_1008F72C0 + 132);
    else {
      uint64_t v8 = off_100897758[v7];
    }
    *(_DWORD *)__int128 buf = 67109378;
    *(_DWORD *)&uint8_t buf[4] = a2;
    *(_WORD *)&uint8_t buf[8] = 2080;
    *(void *)&buf[10] = v8;
    _os_log_impl( (void *)&_mh_execute_header,  v6,  OS_LOG_TYPE_DEFAULT,  "Service attribute response, more %d, state is %s",  buf,  0x12u);
  }

  if (a3)
  {
    if (os_log_type_enabled((os_log_t)qword_1008F75D8, OS_LOG_TYPE_ERROR)) {
      sub_10067D1B4();
    }
    uint64_t v9 = qword_1008F72C0;
    uint64_t v10 = *(void *)(qword_1008F72C0 + 112);
    if (v10)
    {
      if (a3 == 802 && *(_DWORD *)(qword_1008F72C0 + 132) == 5)
      {
        *(_DWORD *)(qword_1008F72C0 + 12_Block_object_dispose(va, 8) = 0;
        sub_100416100();
      }

      else
      {
        if (!*(_DWORD *)(v10 + 608))
        {
          sub_1003CED44(v10);
          uint64_t v9 = qword_1008F72C0;
        }

        *(_DWORD *)(v9 + 12_Block_object_dispose(va, 8) = 1;
        sub_100416100();
      }
    }

    else if (os_log_type_enabled((os_log_t)qword_1008F75D8, OS_LOG_TYPE_ERROR))
    {
      sub_10067D184();
    }

    return;
  }

  if ((*(_BYTE *)a1 & 0xFE) == 6)
  {
    int v64 = a2;
    int v11 = *(unsigned __int16 *)(a1 + 2);
    if ((v11 & 1) != 0)
    {
      int v42 = (os_log_s *)qword_1008F75D8;
      if (os_log_type_enabled((os_log_t)qword_1008F75D8, OS_LOG_TYPE_DEFAULT))
      {
        *(_DWORD *)__int128 buf = 67109120;
        *(_DWORD *)&uint8_t buf[4] = v11;
        _os_log_impl( (void *)&_mh_execute_header,  v42,  OS_LOG_TYPE_DEFAULT,  "This is weird, there are an odd number of elements in this sdp query %d",  buf,  8u);
      }
    }

    else if (*(_WORD *)(a1 + 2))
    {
      unint64_t v12 = 0LL;
      while (1)
      {
        __p[0] = 0LL;
        __p[1] = 0LL;
        uint64_t v13 = *(void *)(a1 + 8);
        *(_OWORD *)std::string __p = *(_OWORD *)(v13 + 16 * v12);
        __int128 v79 = 0uLL;
        __int128 v79 = *(_OWORD *)(v13 + ((16 * v12) | 0x10));
        __int128 v78 = 0uLL;
        if (LOBYTE(__p[0]) != 1)
        {
          if (os_log_type_enabled((os_log_t)qword_1008F75D8, OS_LOG_TYPE_ERROR)) {
            sub_10067D158(&v76, v77);
          }
          goto LABEL_80;
        }

        int v14 = (int)__p[1];
        if (LODWORD(__p[1]) == 9) {
          break;
        }
        if (LODWORD(__p[1]) != 1) {
          goto LABEL_58;
        }
        if (v79 == 6 && WORD1(v79))
        {
          unint64_t v15 = 0LL;
          do
          {
            uint64_t v16 = (_BYTE *)(*((void *)&v79 + 1) + 16 * v15);
            if (*v16 == 3 && sub_10025FD88(&v78, (uint64_t)v16))
            {
              uint64_t v17 = qword_1008F0AC0;
              if (qword_1008F0AC0 >= (unint64_t)qword_1008F0AC8)
              {
                uint64_t v19 = (qword_1008F0AC0 - qword_1008F0AB8) >> 4;
                unint64_t v20 = v19 + 1;
                uint64_t v21 = qword_1008F0AC8 - qword_1008F0AB8;
                if ((qword_1008F0AC8 - qword_1008F0AB8) >> 3 > v20) {
                  unint64_t v20 = v21 >> 3;
                }
                else {
                  unint64_t v22 = v20;
                }
                if (v22) {
                  uint64_t v23 = (char *)sub_1003ADAF8((uint64_t)&qword_1008F0AC8, v22);
                }
                else {
                  uint64_t v23 = 0LL;
                }
                int v24 = &v23[16 * v19];
                *(_OWORD *)int v24 = v78;
                uint64_t v26 = qword_1008F0AB8;
                __int128 v25 = (char *)qword_1008F0AC0;
                uint64_t v27 = (uint64_t)v24;
                if (qword_1008F0AC0 != qword_1008F0AB8)
                {
                  do
                  {
                    *(_OWORD *)(v27 - 16) = *((_OWORD *)v25 - 1);
                    v27 -= 16LL;
                    v25 -= 16;
                  }

                  while (v25 != (char *)v26);
                  __int128 v25 = (char *)qword_1008F0AB8;
                }

                uint64_t v18 = (uint64_t)(v24 + 16);
                qword_1008F0AB8 = v27;
                qword_1008F0AC0 = (uint64_t)(v24 + 16);
                qword_1008F0AC8 = (uint64_t)&v23[16 * v22];
                if (v25) {
                  operator delete(v25);
                }
              }

              else
              {
                *(_OWORD *)qword_1008F0AC0 = v78;
                uint64_t v18 = v17 + 16;
              }

              qword_1008F0AC0 = v18;
              uint64_t v28 = (os_log_s *)qword_1008F75D8;
              if (os_log_type_enabled((os_log_t)qword_1008F75D8, OS_LOG_TYPE_DEFAULT))
              {
                uint64_t v29 = sub_1001EBA4C(*(unsigned int *)(*((void *)&v79 + 1) + 16 * v15 + 8));
                *(_DWORD *)__int128 buf = 136446466;
                *(void *)&uint8_t buf[4] = v29;
                *(_WORD *)&_BYTE buf[12] = 1024;
                *(_DWORD *)&buf[14] = 1;
                _os_log_impl( (void *)&_mh_execute_header,  v28,  OS_LOG_TYPE_DEFAULT,  "Found service class %{public}s HFP: %d",  buf,  0x12u);
              }
            }

            ++v15;
          }

          while (v15 < WORD1(v79));
        }

LABEL_91:
    if (v64)
    {
      goto LABEL_143;
    }

    *(void *)&__int128 v79 = 0LL;
    int v43 = sub_10010EEE0(*(void *)(qword_1008F72C0 + 112) + 128LL, (uint64_t *)&v79);
    uint64_t v45 = qword_1008F0AB8;
    uint64_t v44 = qword_1008F0AC0;
    if (!v43)
    {
      if (qword_1008F0AB8 == qword_1008F0AC0)
      {
        *(void *)(qword_1008F72C0 + 14_Block_object_dispose(va, 8) = 0LL;
LABEL_135:
        uint64_t v59 = qword_1008F0AD0;
        if ((uint64_t *)qword_1008F0AD0 != &qword_1008F0AD8)
        {
          do
          {
            *(_OWORD *)__int128 buf = *(_OWORD *)(v59 + 40);
            sub_10025EB84(buf);
            __int128 v60 = *(uint64_t **)(v59 + 8);
            if (v60)
            {
              do
              {
                __int128 v61 = v60;
                __int128 v60 = (uint64_t *)*v60;
              }

              while (v60);
            }

            else
            {
              do
              {
                __int128 v61 = *(uint64_t **)(v59 + 16);
                BOOL v47 = *v61 == v59;
                uint64_t v59 = (uint64_t)v61;
              }

              while (!v47);
            }

            uint64_t v59 = (uint64_t)v61;
          }

          while (v61 != &qword_1008F0AD8);
        }

        sub_10023BF24((uint64_t)&qword_1008F0AD0, (void *)qword_1008F0AD8);
        qword_1008F0AD0 = (uint64_t)&qword_1008F0AD8;
        qword_1008F0AE0 = 0LL;
        qword_1008F0AD8 = 0LL;
        qword_1008F0AC0 = qword_1008F0AB8;
LABEL_143:
        uint64_t v62 = qword_1008F72C0;
        if (*(_DWORD *)(qword_1008F72C0 + 132) == 5)
        {
          uint64_t v63 = (os_log_s *)qword_1008F75D8;
          if (os_log_type_enabled((os_log_t)qword_1008F75D8, OS_LOG_TYPE_DEFAULT))
          {
            *(_WORD *)__int128 buf = 0;
            _os_log_impl( (void *)&_mh_execute_header,  v63,  OS_LOG_TYPE_DEFAULT,  "Database state lookup complete",  buf,  2u);
            uint64_t v62 = qword_1008F72C0;
          }

          *(_DWORD *)(v62 + 12_Block_object_dispose(va, 8) = 0;
          sub_100416100();
        }

        else
        {
          ++*(_DWORD *)(qword_1008F0AE8 + 204);
          sub_100416900();
        }

        return;
      }

      do
      {
        unint64_t v46 = *(unsigned int *)(v45 + 8);
        BOOL v47 = (v46 - 4364) > 0x12 || ((1 << (v46 - 12)) & 0x4000D) == 0;
        if (v47)
        {
          uint64_t v53 = (os_log_s *)qword_1008F75D8;
          if (os_log_type_enabled((os_log_t)qword_1008F75D8, OS_LOG_TYPE_DEFAULT))
          {
            uint64_t v54 = sub_1001EBA4C(v46);
            int v55 = *(unsigned __int16 *)(qword_1008F72C0 + 152);
            int v56 = *(unsigned __int16 *)(qword_1008F72C0 + 154);
            sub_1003CF00C(*(void *)(qword_1008F72C0 + 112), __p);
            __int128 v57 = __p;
            if (v67 < 0) {
              __int128 v57 = (void **)__p[0];
            }
            *(_DWORD *)__int128 buf = 136447234;
            *(void *)&uint8_t buf[4] = v54;
            *(_WORD *)&_BYTE buf[12] = 1024;
            *(_DWORD *)&buf[14] = v55;
            __int16 v81 = 1024;
            int v82 = v56;
            __int16 v83 = 2082;
            int v84 = v57;
            __int16 v85 = 2048;
            uint64_t v86 = v79;
            _os_log_impl( (void *)&_mh_execute_header,  v53,  OS_LOG_TYPE_DEFAULT,  "Found service class %{public}s with profile version: %x, supported features: %x. Not creating remote SDP r ecord for device %{public}s with hci handle: %p",  buf,  0x2Cu);
            if (v67 < 0) {
              operator delete(__p[0]);
            }
          }
        }

        else
        {
          uint64_t v48 = (os_log_s *)qword_1008F75D8;
          if (os_log_type_enabled((os_log_t)qword_1008F75D8, OS_LOG_TYPE_DEFAULT))
          {
            __int16 v49 = sub_1001EBA4C(v46);
            int v50 = *(unsigned __int16 *)(qword_1008F72C0 + 152);
            int v51 = *(unsigned __int16 *)(qword_1008F72C0 + 154);
            sub_1003CF00C(*(void *)(qword_1008F72C0 + 112), __p);
            std::locale v52 = __p;
            if (v67 < 0) {
              std::locale v52 = (void **)__p[0];
            }
            *(_DWORD *)__int128 buf = 136447234;
            *(void *)&uint8_t buf[4] = v49;
            *(_WORD *)&_BYTE buf[12] = 1024;
            *(_DWORD *)&buf[14] = v50;
            __int16 v81 = 1024;
            int v82 = v51;
            __int16 v83 = 2082;
            int v84 = v52;
            __int16 v85 = 2048;
            uint64_t v86 = v79;
            _os_log_impl( (void *)&_mh_execute_header,  v48,  OS_LOG_TYPE_DEFAULT,  "Found service class %{public}s with profile version: %x, supported features: %x. Creating/Updating remote SDP record for device %{public}s with hci handle: %p",  buf,  0x2Cu);
            if (v67 < 0) {
              operator delete(__p[0]);
            }
          }

          sub_1001E211C(v79, v46, *(_WORD *)(qword_1008F72C0 + 152), *(_WORD *)(qword_1008F72C0 + 154));
        }

        if ((int)v46 > 4381)
        {
          if ((int)v46 <= 4402)
          {
            if ((_DWORD)v46 == 4382)
            {
              sub_1003DAA54(*(void *)(qword_1008F72C0 + 112), *(unsigned __int16 *)(qword_1008F72C0 + 152));
              sub_1003DAB70(*(void *)(qword_1008F72C0 + 112), *(unsigned __int16 *)(qword_1008F72C0 + 154));
            }

            else if ((_DWORD)v46 == 4388)
            {
              sub_1003DB078(*(void *)(qword_1008F72C0 + 112), *(_WORD *)(qword_1008F72C0 + 152));
            }
          }

          else
          {
            switch((_DWORD)v46)
            {
              case 0x1133:
                sub_1003DAD08(*(void *)(qword_1008F72C0 + 112), *(_WORD *)(qword_1008F72C0 + 152));
                break;
              case 0x1200:
                sub_1003DAEC0(*(void *)(qword_1008F72C0 + 112), *(_WORD *)(qword_1008F72C0 + 152));
                break;
              case 0x1801:
                sub_1003DB154(*(void *)(qword_1008F72C0 + 112), *(_WORD *)(qword_1008F72C0 + 152));
                break;
            }
          }
        }

        else
        {
          switch((int)v46)
          {
            case 4353:
              sub_1003DAF9C(*(void *)(qword_1008F72C0 + 112), *(_WORD *)(qword_1008F72C0 + 152));
              break;
            case 4357:
              sub_1003DADE4(*(void *)(qword_1008F72C0 + 112), *(_WORD *)(qword_1008F72C0 + 152));
              break;
            case 4363:
              sub_1003DABCC(*(void *)(qword_1008F72C0 + 112), *(_WORD *)(qword_1008F72C0 + 152));
              sub_1003DACA8(*(void *)(qword_1008F72C0 + 112), *(_WORD *)(qword_1008F72C0 + 154));
              break;
            case 4364:
              sub_1003DA898(*(void *)(qword_1008F72C0 + 112), *(unsigned __int16 *)(qword_1008F72C0 + 152));
              sub_1003DA9B4(*(void *)(qword_1008F72C0 + 112), *(unsigned __int16 *)(qword_1008F72C0 + 154));
              break;
            case 4366:
            case 4367:
              sub_1003DA6DC(*(void *)(qword_1008F72C0 + 112), *(unsigned __int16 *)(qword_1008F72C0 + 152));
              sub_1003DA7F8(*(void *)(qword_1008F72C0 + 112), *(unsigned __int16 *)(qword_1008F72C0 + 154));
              break;
            default:
              break;
          }
        }

        v45 += 16LL;
      }

      while (v45 != qword_1008F0AC0);
      uint64_t v44 = v45;
      uint64_t v45 = qword_1008F0AB8;
    }

    *(void *)(qword_1008F72C0 + 14_Block_object_dispose(va, 8) = 0LL;
    if (v45 != v44)
    {
      do
      {
        *(_OWORD *)__int128 buf = *(_OWORD *)v45;
        uint64_t v58 = *(void *)(qword_1008F72C0 + 112);
        sub_1002DBF7C((uint64_t)v65, (uint64_t)&qword_1008F0AD0);
        sub_1003D4104(v58, (uint64_t)buf, v65);
        sub_10023BF24((uint64_t)v65, (void *)v65[1]);
        sub_10025EB84(buf);
        v45 += 16LL;
      }

      while (v45 != qword_1008F0AC0);
    }

    goto LABEL_135;
  }

  if (os_log_type_enabled((os_log_t)qword_1008F75D8, OS_LOG_TYPE_ERROR)) {
    sub_10067CF14();
  }
}

        if (os_log_type_enabled((os_log_t)qword_1008F7748, OS_LOG_TYPE_ERROR)) {
          sub_100696890();
        }
        unint64_t v32 = 4507LL;
        goto LABEL_94;
      }

      __int128 v57 = "ByteStream_NumReadBytesAvail(pBs) >= 2";
      uint64_t v58 = 2269;
    }

        uint64_t v48 = (os_log_s *)qword_1008F75A8;
        if (os_log_type_enabled((os_log_t)qword_1008F75A8, OS_LOG_TYPE_DEFAULT))
        {
          *(_WORD *)__int128 buf = 0;
          _os_log_impl( (void *)&_mh_execute_header,  v48,  OS_LOG_TYPE_DEFAULT,  "Calling PairingManager::getInstance()->leDevicePaired",  buf,  2u);
        }

        if (qword_1008D67A8 != -1) {
          dispatch_once(&qword_1008D67A8, &stru_1008A4618);
        }
        __int16 v49 = off_1008D67A0;
        char v70 = a2[1];
        int v50 = a2[2];
        int v51 = a2[3];
        std::locale v52 = a2[4];
        uint64_t v53 = a2[5];
        uint64_t v54 = a2[6];
        int v55 = *a2;
        sub_100525248(&v92, &v93);
        uint64_t v69 = (uint64_t)v49;
        if (qword_1008D5F30 != -1) {
          dispatch_once(&qword_1008D5F30, &stru_1008A45D8);
        }
        int v56 = off_1008D5F28;
        __int128 v57 = sub_100241F94(uu);
        uint64_t v58 = (void *)objc_claimAutoreleasedReturnValue(v57);
        sub_1005CC0D4((uint64_t)v56, v58, (uint64_t)&v74);
        sub_10052EBBC( v69,  (v70 << 40) | (v50 << 32) | (v51 << 24) | (v52 << 16) | (v53 << 8) | v54 | (v55 << 48),  &v92,  &v74);

        nullsub_63(&v92, v59);
        if (qword_1008D5F30 != -1) {
          dispatch_once(&qword_1008D5F30, &stru_1008A45D8);
        }
        __int128 v60 = off_1008D5F28;
        __int128 v61 = sub_100241F94(uu);
        uint64_t v62 = (void *)objc_claimAutoreleasedReturnValue(v61);
        sub_10002418C(v72, "_CTKD_");
        sub_1005CCF08((uint64_t)v60, v62, (unsigned __int8 *)v72);
        if (v73 < 0) {
          operator delete(v72[0]);
        }

LABEL_66:
        sub_100242CD8(&v79);
        nullsub_63(&v93, v40);
LABEL_67:
        __int16 v81 = &off_10087FAA8;
        if (v82) {
          sub_1002CD254(v82);
        }
LABEL_74:
        sub_100242CD8(&v83);
        goto LABEL_75;
      }

      int v42 = sub_1002E6BF0();
      int v43 = (*(uint64_t (**)(uint64_t))(*(void *)v42 + 344LL))(v42);
      if ((v43 & 1) != 0) {
        goto LABEL_83;
      }
      if (qword_1008D5F30 != -1) {
        dispatch_once(&qword_1008D5F30, &stru_1008A45D8);
      }
      uint64_t v23 = off_1008D5F28;
      uint64_t v44 = sub_100241F94(uu);
      uint64_t v4 = (void *)objc_claimAutoreleasedReturnValue(v44);
      sub_10002418C(v75, "IsAppleWatch");
      if ((sub_1005CE5A8((uint64_t)v23, v4, (uint64_t)v75) & 1) != 0)
      {
LABEL_83:
        uint64_t v45 = 0;
      }

      else
      {
        if (qword_1008D5F30 != -1) {
          dispatch_once(&qword_1008D5F30, &stru_1008A45D8);
        }
        char v67 = off_1008D5F28;
        char v68 = sub_100241F94(uu);
        uint64_t v23 = (void *)objc_claimAutoreleasedReturnValue(v68);
        if (!sub_1005CE518((uint64_t)v67, v23))
        {
          unint64_t v46 = 5;
          uint64_t v45 = 1;
          goto LABEL_85;
        }

        uint64_t v45 = 1;
      }

      unint64_t v46 = 8;
LABEL_85:
      sub_10052525C((uint64_t)buf, &v95, v46);
      sub_100525248(&v93, (__n128 *)buf);
      nullsub_63(buf, v47);
      if (v45) {

      }
      if ((v43 & 1) == 0)
      {
        if (v76 < 0) {
          operator delete(v75[0]);
        }
      }

      goto LABEL_91;
    }

    memset(dst, 0, sizeof(dst));
    *(void *)&int v97 = 0LL;
    if (qword_1008D5F30 != -1) {
      dispatch_once(&qword_1008D5F30, &stru_1008A45D8);
    }
    unsigned __int16 v35 = off_1008D5F28;
    uint64_t v36 = sub_100241F94(uu);
    unint64_t v37 = (void *)objc_claimAutoreleasedReturnValue(v36);
    sub_1005CF060((uint64_t)v35, v37, (uint64_t)dst);

    uint64_t v38 = BYTE7(v97);
    if (SBYTE7(v97) < 0)
    {
      if (!*(void *)&dst[8])
      {
        operator delete(*(void **)dst);
        goto LABEL_33;
      }
    }

    else if (!BYTE7(v97))
    {
      goto LABEL_33;
    }

    __int16 v41 = (os_log_s *)qword_1008F75A8;
    if (os_log_type_enabled((os_log_t)qword_1008F75A8, OS_LOG_TYPE_DEFAULT))
    {
      *(_WORD *)__int128 buf = 0;
      _os_log_impl( (void *)&_mh_execute_header,  v41,  OS_LOG_TYPE_DEFAULT,  "LE_Security_DeriveLinkKeyForAddress not applicable for cloud paired devices",  buf,  2u);
      uint64_t v38 = BYTE7(v97);
    }

    if (v38 < 0) {
      operator delete(*(void **)dst);
    }
    goto LABEL_74;
  }

void sub_100417978( _Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, char a20, void *a21)
{
}

void sub_100417998(unsigned __int8 *a1)
{
  int v2 = *a1;
  if ((v2 - 1) < 2)
  {
    uint64_t v4 = qword_1008F72C0;
    int v5 = *(_DWORD *)(qword_1008F72C0 + 136);
    if (v5 == 2)
    {
      *(_DWORD *)(qword_1008F72C0 + 14sub_100414D2C(qword_1008F72C0, 0) = *((_DWORD *)a1 + 2);
      uint64_t v10 = (os_log_s *)qword_1008F75D8;
      if (os_log_type_enabled((os_log_t)qword_1008F75D8, OS_LOG_TYPE_DEFAULT))
      {
        *(_DWORD *)__int128 buf = 136315394;
        uint64_t v13 = "SDP_PARSER_FOUND_ATTRIBUTE_ID_STATE";
        __int16 v14 = 2080;
        unint64_t v15 = "SDP_PARSER_IDLE_STATE";
        _os_log_impl( (void *)&_mh_execute_header,  v10,  OS_LOG_TYPE_DEFAULT,  "SDP Client Parser State Change: %s -> %s\n",  buf,  0x16u);
        uint64_t v4 = qword_1008F72C0;
      }

      *(_DWORD *)(v4 + 136) = 0;
    }

    else if (v5 == 1 && *((_DWORD *)a1 + 2) == 513)
    {
      int v6 = (os_log_s *)qword_1008F75D8;
      if (os_log_type_enabled((os_log_t)qword_1008F75D8, OS_LOG_TYPE_DEFAULT))
      {
        *(_DWORD *)__int128 buf = 136315394;
        uint64_t v13 = "SDP_PARSER_FOUND_SERVICE_CLASS_STATE";
        __int16 v14 = 2080;
        unint64_t v15 = "SDP_PARSER_FOUND_ATTRIBUTE_ID_STATE";
        _os_log_impl( (void *)&_mh_execute_header,  v6,  OS_LOG_TYPE_DEFAULT,  "SDP Client Parser State Change: %s -> %s\n",  buf,  0x16u);
        uint64_t v4 = qword_1008F72C0;
      }

      *(_DWORD *)(v4 + 136) = 2;
    }
  }

  else if ((v2 - 6) >= 2)
  {
    if (v2 == 3)
    {
      __int128 v11 = xmmword_1006C2C30;
      if (sub_10025FC8C((uint64_t)a1, (uint64_t)&v11))
      {
        uint64_t v7 = (os_log_s *)qword_1008F75D8;
        if (os_log_type_enabled((os_log_t)qword_1008F75D8, OS_LOG_TYPE_DEFAULT))
        {
          uint64_t v8 = *(int *)(qword_1008F72C0 + 136);
          else {
            uint64_t v9 = off_1008976E0[v8];
          }
          *(_DWORD *)__int128 buf = 136315394;
          uint64_t v13 = v9;
          __int16 v14 = 2080;
          unint64_t v15 = "SDP_PARSER_FOUND_SERVICE_CLASS_STATE";
          _os_log_impl( (void *)&_mh_execute_header,  v7,  OS_LOG_TYPE_DEFAULT,  "SDP Client Parser State Change: %s -> %s\n",  buf,  0x16u);
        }

        *(_DWORD *)(qword_1008F72C0 + 136) = 1;
      }
    }
  }

  else if (*((_WORD *)a1 + 1))
  {
    int v3 = 0;
    do
      sub_100417998(*((void *)a1 + 1) + 16LL * v3++);
    while (*((unsigned __int16 *)a1 + 1) > v3);
  }

void sub_100417C20(unsigned __int8 *a1)
{
  int v2 = *a1;
  if ((v2 - 1) < 2)
  {
    if (*(_DWORD *)(qword_1008F72C0 + 136) == 3) {
      *(_DWORD *)(qword_1008F72C0 + 144) = *((_DWORD *)a1 + 2);
    }
  }

  else if ((v2 - 6) >= 2)
  {
    if (v2 == 3)
    {
      __int128 v7 = xmmword_1006BDF80;
      if (sub_10025FC8C((uint64_t)a1, (uint64_t)&v7))
      {
        uint64_t v4 = (os_log_s *)qword_1008F75D8;
        if (os_log_type_enabled((os_log_t)qword_1008F75D8, OS_LOG_TYPE_DEFAULT))
        {
          uint64_t v5 = *(int *)(qword_1008F72C0 + 136);
          else {
            int v6 = off_1008976E0[v5];
          }
          *(_DWORD *)__int128 buf = 136315394;
          uint64_t v9 = v6;
          __int16 v10 = 2080;
          __int128 v11 = "SDP_PARSER_FOUND_RFCOMM_UUID_STATE";
          _os_log_impl( (void *)&_mh_execute_header,  v4,  OS_LOG_TYPE_DEFAULT,  "SDP Client Parser State Change: %s -> %s\n",  buf,  0x16u);
        }

        *(_DWORD *)(qword_1008F72C0 + 136) = 3;
      }
    }
  }

  else if (*((_WORD *)a1 + 1))
  {
    int v3 = 0;
    do
      sub_100417C20(*((void *)a1 + 1) + 16LL * v3++);
    while (*((unsigned __int16 *)a1 + 1) > v3);
  }

void sub_100417D9C()
{
  uint64_t v0 = qword_1008F72C0;
  unsigned int v1 = *(_DWORD *)(qword_1008F72C0 + 132);
  if (v1 != 9)
  {
    uint64_t v4 = (os_log_s *)qword_1008F75D8;
    if (os_log_type_enabled((os_log_t)qword_1008F75D8, OS_LOG_TYPE_ERROR)) {
      sub_10067D214(v1, v4, v5);
    }
    return;
  }

  if (*(void *)(qword_1008F72C0 + 40))
  {
    while (1)
    {
      __int128 v43 = xmmword_1006C2C50;
      __int128 v44 = xmmword_1006C2C40;
      __int128 v41 = xmmword_1006C2C70;
      __int128 v42 = xmmword_1006C2C60;
      __int128 v40 = xmmword_1006C2C80;
      __int128 v38 = xmmword_1006C2CA0;
      __int128 v39 = xmmword_1006C2C90;
      __int128 v36 = unk_1008975C8;
      __int128 v37 = xmmword_1006C2CB0;
      __int128 v35 = unk_1008975D8;
      __int128 v34 = 0uLL;
      __int128 v34 = *(_OWORD *)(*(void *)(*(void *)(v0 + 8) + ((*(void *)(v0 + 32) >> 5) & 0x7FFFFFFFFFFFFF8LL))
                      + 16LL * *(void *)(v0 + 32));
      if (!sub_10025FC8C((uint64_t)&v34, (uint64_t)&v44)
        && !sub_10025FC8C((uint64_t)&v34, (uint64_t)&v43)
        && !sub_10025FC8C((uint64_t)&v34, (uint64_t)&v42)
        && !sub_10025FC8C((uint64_t)&v34, (uint64_t)&v41)
        && !sub_10025FC8C((uint64_t)&v34, (uint64_t)&v40)
        && !sub_10025FC8C((uint64_t)&v34, (uint64_t)&v38)
        && !sub_10025FC8C((uint64_t)&v34, (uint64_t)&v37)
        && !sub_10025FC8C((uint64_t)&v34, (uint64_t)&v39))
      {
        if (!byte_1008D9881) {
          goto LABEL_24;
        }
        if (!sub_10025FC8C((uint64_t)&v34, (uint64_t)&v36))
        {
          if (!byte_1008D9881)
          {
LABEL_24:
            BOOL v6 = 1;
            goto LABEL_26;
          }
        }
      }

      uint64_t v2 = qword_1008F72C0;
      *(int64x2_t *)(qword_1008F72C0 + 32) = vaddq_s64( *(int64x2_t *)(qword_1008F72C0 + 32),  (int64x2_t)xmmword_1006BFA70);
      sub_10038D5BC(v2, 1);
      uint64_t v0 = qword_1008F72C0;
      if (!*(void *)(qword_1008F72C0 + 40)) {
        goto LABEL_16;
      }
    }

    BOOL v6 = byte_1008D9881 == 0;
LABEL_26:
    v53[0] = 0LL;
    v53[1] = 0LL;
    *(void *)__int128 buf = 1048579LL;
    int v50 = v53;
    uint64_t v51 = 131075LL;
    uint64_t v52 = 3LL;
    v48[0] = xmmword_1006C2C08;
    v48[1] = unk_1006C2C18;
    __int128 v47 = xmmword_1006C2CC0;
    uint64_t v32 = 0LL;
    uint64_t v33 = 0LL;
    v31[0] = 0LL;
    if (v34 != 3)
    {
LABEL_43:
      LOBYTE(v31[0]) = 6;
      WORD1(v31[0]) = 1;
      v31[1] = &v47;
      int v28 = sub_1001E0050((uint64_t)sub_1004182E0, (unsigned __int8 *)&v32, (unsigned __int8 *)v31);
      if (v28)
      {
        int v29 = v28;
        unsigned __int16 v30 = (os_log_s *)qword_1008F75D8;
        if (os_log_type_enabled((os_log_t)qword_1008F75D8, OS_LOG_TYPE_ERROR))
        {
          *(_DWORD *)uint64_t v45 = 67109120;
          LODWORD(v46) = v29;
          _os_log_error_impl( (void *)&_mh_execute_header,  v30,  OS_LOG_TYPE_ERROR,  "Service+RFCOMM search failed with %{bluetooth:OI_STATUS}u",  v45,  8u);
        }

        *(_DWORD *)(qword_1008F72C0 + 12_Block_object_dispose(va, 8) = 0;
        goto LABEL_20;
      }

      return;
    }

    unsigned int v7 = WORD1(v34);
    int v8 = sub_1000A86F0();
    if (v7 > 4)
    {
      if (v8)
      {
        uint64_t v18 = sub_1001EB74C(*((unsigned int **)&v34 + 1));
        sub_1001EE134((uint64_t)"Querying RFCOMM Service : %s", v19, v20, v21, v22, v23, v24, v25, (uint64_t)v18);
        uint64_t v17 = (os_log_s *)sub_100086554(0x5Cu);
        if (os_log_type_enabled(v17, OS_LOG_TYPE_DEFAULT)) {
          goto LABEL_37;
        }
      }
    }

    else if (v8)
    {
      uint64_t v9 = sub_1001EBA4C(DWORD2(v34));
      sub_1001EE134((uint64_t)"Querying RFCOMM Service : %s", v10, v11, v12, v13, v14, v15, v16, (uint64_t)v9);
      uint64_t v17 = (os_log_s *)sub_100086554(0x5Cu);
      if (os_log_type_enabled(v17, OS_LOG_TYPE_DEFAULT))
      {
LABEL_37:
        uint64_t v26 = sub_1001EDDCC();
        *(_DWORD *)uint64_t v45 = 136446210;
        unint64_t v46 = v26;
        _os_log_impl((void *)&_mh_execute_header, v17, OS_LOG_TYPE_DEFAULT, " %{public}s", v45, 0xCu);
      }
    }

    if (v34 == 3)
    {
      if (WORD1(v34) == 16)
      {
        *int v50 = **((_OWORD **)&v34 + 1);
        uint64_t v27 = buf;
      }

      else
      {
        DWORD2(v48[0]) = DWORD2(v34);
        uint64_t v27 = (uint8_t *)v48;
      }

      LOBYTE(v32) = 6;
      WORD1(v32) = 2;
      uint64_t v33 = v27;
    }

    goto LABEL_43;
  }

void sub_1004182E0(unsigned __int8 *a1, int a2, int a3)
{
  BOOL v6 = (os_log_s *)qword_1008F75D8;
  if (os_log_type_enabled((os_log_t)qword_1008F75D8, OS_LOG_TYPE_DEFAULT))
  {
    uint64_t v7 = *(int *)(qword_1008F72C0 + 132);
    else {
      int v8 = off_100897758[v7];
    }
    uint64_t v9 = *(void *)(qword_1008F72C0 + 40);
    LODWORD(v12) = 67109890;
    DWORD1(v12) = a2;
    WORD4(v12) = 1024;
    *(_DWORD *)((char *)&v12 + 1sub_100414D2C(qword_1008F72C0, 0) = a3;
    HIWORD(v12) = 2080;
    uint64_t v13 = v8;
    __int16 v14 = 2048;
    uint64_t v15 = v9;
    _os_log_impl( (void *)&_mh_execute_header,  v6,  OS_LOG_TYPE_DEFAULT,  "RFCOMM service attribute response: more %d, status %{bluetooth:OI_STATUS}u, state %s RFCOMM service size %lu",  (uint8_t *)&v12,  0x22u);
  }

  if (a3)
  {
    if (os_log_type_enabled((os_log_t)qword_1008F75D8, OS_LOG_TYPE_ERROR)) {
      sub_10067D29C();
    }
    *(_DWORD *)(qword_1008F72C0 + 12_Block_object_dispose(va, 8) = 1;
    sub_100416100();
  }

  else if ((*a1 & 0xFE) == 6)
  {
    if (*(void *)(qword_1008F72C0 + 40))
    {
      __int128 v12 = *(_OWORD *)(*(void *)(*(void *)(qword_1008F72C0 + 8)
                                  + ((*(void *)(qword_1008F72C0 + 32) >> 5) & 0x7FFFFFFFFFFFFF8LL))
                      + 16LL * *(void *)(qword_1008F72C0 + 32));
      *(_DWORD *)(qword_1008F72C0 + 144) = -1;
      sub_100417C20(a1);
      uint64_t v10 = (int64x2_t *)qword_1008F72C0;
      if (*(_DWORD *)(qword_1008F72C0 + 144) != -1)
      {
        sub_1003E307C( *(void *)(qword_1008F72C0 + 112),  (uint64_t)&v12,  (unsigned __int16)*(_DWORD *)(qword_1008F72C0 + 144));
        uint64_t v10 = (int64x2_t *)qword_1008F72C0;
      }

      void v10[2] = vaddq_s64(v10[2], (int64x2_t)xmmword_1006BFA70);
      uint64_t v11 = sub_10038D5BC((uint64_t)v10, 1);
      sub_100417D9C(v11);
    }
  }

  else if (os_log_type_enabled((os_log_t)qword_1008F75D8, OS_LOG_TYPE_ERROR))
  {
    sub_10067CF14();
  }

void sub_1004184DC(id a1)
{
  char v1 = 0;
  sub_100242CA4(&v1);
  sub_10041521C();
  sub_100242CD8(&v1);
}

void sub_100418514( _Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, int a10, __int16 a11, char a12, char a13)
{
}

void sub_100418528(id a1)
{
  char v1 = 0;
  sub_100242CA4(&v1);
  sub_10041521C();
  sub_100242CD8(&v1);
}

void sub_100418560( _Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, int a10, __int16 a11, char a12, char a13)
{
}

uint64_t sub_100418574(uint64_t a1, char a2)
{
  v4[0] = 0LL;
  v4[1] = 0LL;
  sub_100242F28((uint64_t)v4, (uint64_t)&unk_1008F72F8);
  byte_1008D9880 = a2;
  sub_100242F54((uint64_t)v4);
  return sub_100242FAC((uint64_t)v4);
}

void sub_1004185C4( _Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9)
{
}

BOOL sub_1004185D8()
{
  v4[0] = 0LL;
  v4[1] = 0LL;
  sub_100242F28((uint64_t)v4, (uint64_t)&unk_1008F7280);
  if (qword_1008F72C0)
  {
    int v0 = *(_DWORD *)(qword_1008F72C0 + 132);
    BOOL v2 = v0 != 10 && v0 != 0;
  }

  else
  {
    BOOL v2 = 0LL;
  }

  sub_100242FAC((uint64_t)v4);
  return v2;
}

uint64_t sub_10041863C(uint64_t a1, uint64_t a2)
{
  v19[0] = 0LL;
  v19[1] = 0LL;
  sub_100242F28((uint64_t)v19, (uint64_t)&unk_1008F7280);
  if (qword_1008F72C0)
  {
    uint64_t v3 = *(void *)(qword_1008F72C0 + 112);
    if (v3)
    {
      int v4 = *(_DWORD *)(v3 + 128);
      int v5 = *(unsigned __int16 *)(v3 + 132);
      if (v4 == *(_DWORD *)(a2 + 128) && v5 == *(unsigned __int16 *)(a2 + 132))
      {
LABEL_22:
        uint64_t v15 = 1LL;
        goto LABEL_23;
      }
    }
  }

  if (*((void *)&xmmword_1008F72E8 + 1))
  {
    __int128 v18 = 0u;
    memset(v17, 0, sizeof(v17));
    sub_100419ED0((uint64_t)v17, &qword_1008F72C8);
    uint64_t v7 = *((void *)&v18 + 1);
    if (*((void *)&v18 + 1))
    {
      int v8 = (void **)*((void *)&v17[0] + 1);
      unint64_t v9 = v18;
      while (1)
      {
        uint64_t v10 = (*(void **)((char *)v8 + ((v9 >> 6) & 0x3FFFFFFFFFFFFF8LL)))[v9 & 0x1FF];
        if (v10)
        {
          uint64_t v11 = *(void *)(v10 + 112);
          if (v11)
          {
            int v12 = *(_DWORD *)(v11 + 128);
            int v13 = *(unsigned __int16 *)(v11 + 132);
          }
        }

        --v7;
        *(void *)&__int128 v18 = ++v9;
        *((void *)&v18 + 1) = v7;
        if (v9 >= 0x400)
        {
          operator delete(*v8);
          int v8 = (void **)(*((void *)&v17[0] + 1) + 8LL);
          unint64_t v9 = v18 - 512;
          *((void *)&v17[0] + 1) += 8LL;
          *(void *)&__int128 v18 = v18 - 512;
          uint64_t v7 = *((void *)&v18 + 1);
        }

        if (!v7) {
          goto LABEL_19;
        }
      }

      sub_1002400EC(v17);
      goto LABEL_22;
    }

void sub_10041877C(_Unwind_Exception *a1)
{
}

uint64_t sub_100418790(uint64_t a1, int a2)
{
  uint64_t v4 = qword_1008F72C0;
  int v5 = (os_log_s *)qword_1008F75D8;
  if (os_log_type_enabled((os_log_t)qword_1008F75D8, OS_LOG_TYPE_DEFAULT))
  {
    *(_DWORD *)__int128 buf = 141558531;
    *(void *)&uint8_t buf[4] = 1752392040LL;
    *(_WORD *)&_BYTE buf[12] = 1041;
    *(_DWORD *)&buf[14] = 6;
    *(_WORD *)&_BYTE buf[18] = 2097;
    *(void *)&buf[20] = a1;
    _os_log_impl( (void *)&_mh_execute_header,  v5,  OS_LOG_TYPE_DEFAULT,  "Incoming SDP request from %{private,bluetooth:BD_ADDR,mask.hash}.6P",  buf,  0x1Cu);
  }

  if (v4)
  {
    uint64_t v6 = *(void *)(v4 + 112);
    if (v6)
    {
      int v7 = *(_DWORD *)(v6 + 128);
      int v8 = *(unsigned __int16 *)(v6 + 132);
      if (v7 == *(_DWORD *)a1 && v8 == *(unsigned __int16 *)(a1 + 4))
      {
        uint64_t v19 = (os_log_s *)qword_1008F75D8;
        if (os_log_type_enabled((os_log_t)qword_1008F75D8, OS_LOG_TYPE_DEFAULT))
        {
          *(_DWORD *)__int128 buf = 141558531;
          *(void *)&uint8_t buf[4] = 1752392040LL;
          *(_WORD *)&_BYTE buf[12] = 1041;
          *(_DWORD *)&buf[14] = 6;
          *(_WORD *)&_BYTE buf[18] = 2097;
          *(void *)&buf[20] = a1;
          _os_log_impl( (void *)&_mh_execute_header,  v19,  OS_LOG_TYPE_DEFAULT,  "Already have outgoing SDP with %{private,bluetooth:BD_ADDR,mask.hash}.6P",  buf,  0x1Cu);
        }

        return 845LL;
      }
    }
  }

  if (byte_1008F0AF0) {
    goto LABEL_10;
  }
  if (qword_1008D5F50 != -1) {
    dispatch_once(&qword_1008D5F50, &stru_100897628);
  }
  *(_DWORD *)__int128 buf = *(_DWORD *)a1;
  *(_WORD *)&uint8_t buf[4] = *(_WORD *)(a1 + 4);
  int v13 = sub_1003FFEB0(off_1008D5F48, (uint64_t)buf, 0);
  uint64_t v14 = (uint64_t)v13;
  if (!v13)
  {
LABEL_10:
    if (qword_1008D60B0 != -1) {
      dispatch_once(&qword_1008D60B0, &stru_100897668);
    }
    sub_1004364F0((uint64_t)off_1008D60A8, a1);
    int v10 = sub_100112610(a1);
    *(_DWORD *)uint64_t v53 = *(_DWORD *)a1;
    *(_WORD *)&v53[4] = *(_WORD *)(a1 + 4);
    if (qword_1008D5F50 != -1) {
      dispatch_once(&qword_1008D5F50, &stru_100897628);
    }
    *(_DWORD *)__int128 buf = *(_DWORD *)v53;
    *(_WORD *)&uint8_t buf[4] = *(_WORD *)&v53[4];
    uint64_t v11 = sub_1003FFEB0(off_1008D5F48, (uint64_t)buf, 1);
    if ((v10 & 0x1FFC) == 0x41C || (v10 & 0x1FFC) == 0x20C)
    {
      int v12 = (os_log_s *)qword_1008F75D8;
      if (os_log_type_enabled((os_log_t)qword_1008F75D8, OS_LOG_TYPE_DEFAULT))
      {
        *(_DWORD *)__int128 buf = 141558531;
        *(void *)&uint8_t buf[4] = 1752392040LL;
        *(_WORD *)&_BYTE buf[12] = 1041;
        *(_DWORD *)&buf[14] = 6;
        *(_WORD *)&_BYTE buf[18] = 2097;
        *(void *)&buf[20] = a1;
        _os_log_impl( (void *)&_mh_execute_header,  v12,  OS_LOG_TYPE_DEFAULT,  "Received incoming SDP connection from possible iPhone/iPod %{private,bluetooth:BD_ADDR,mask.hash}.6P",  buf,  0x1Cu);
      }

      if (qword_1008D9600 != -1) {
        dispatch_once(&qword_1008D9600, &stru_100897648);
      }
      sub_10041ADE4(qword_1008D95F8, a1);
    }

    else
    {
      uint64_t v17 = v11;
      uint64_t v18 = sub_100404EB8();
      v48[0] = _NSConcreteStackBlock;
      v48[1] = 3221225472LL;
      _OWORD v48[2] = sub_10041916C;
      v48[3] = &unk_10087FF20;
      v48[4] = v17;
      int v49 = v10;
      int v50 = *(_DWORD *)v53;
      __int16 v51 = *(_WORD *)&v53[4];
      sub_100405384(v18, v48);
    }

    return 845LL;
  }

  if (!sub_1003DCD9C((uint64_t)v13))
  {
    uint64_t v52 = 0LL;
    if (!sub_10010EEE0(v14 + 128, &v52))
    {
      uint64_t v20 = (os_log_s *)qword_1008F75D8;
      if (os_log_type_enabled((os_log_t)qword_1008F75D8, OS_LOG_TYPE_DEFAULT))
      {
        *(_DWORD *)__int128 buf = 141558787;
        *(void *)&uint8_t buf[4] = 1752392040LL;
        *(_WORD *)&_BYTE buf[12] = 1041;
        *(_DWORD *)&buf[14] = 6;
        *(_WORD *)&_BYTE buf[18] = 2097;
        *(void *)&buf[20] = a1;
        *(_WORD *)&buf[28] = 2048;
        *(void *)&buf[30] = v52;
        _os_log_impl( (void *)&_mh_execute_header,  v20,  OS_LOG_TYPE_DEFAULT,  "No need to stall incoming SDP request from %{private,bluetooth:BD_ADDR,mask.hash}.6P with handle %p",  buf,  0x26u);
      }

      uint64_t v21 = v52;
      __int16 v22 = sub_1003DAA10(v14);
      __int16 v23 = sub_1003DAB2C(v14);
      sub_1001E211C(v21, 4382, v22, v23);
      if (sub_1003D36E0(v14))
      {
        uint64_t v24 = (os_log_s *)qword_1008F75D8;
        if (os_log_type_enabled((os_log_t)qword_1008F75D8, OS_LOG_TYPE_DEFAULT))
        {
          sub_1003D01A0(v14, (uint64_t)buf);
          uint64_t v25 = (buf[23] & 0x80u) == 0 ? buf : *(uint8_t **)buf;
          *(_DWORD *)uint64_t v53 = 136315138;
          *(void *)&v53[4] = v25;
          _os_log_impl( (void *)&_mh_execute_header,  v24,  OS_LOG_TYPE_DEFAULT,  "Forcing legacy AVRCP SDP for device %s",  v53,  0xCu);
        }

        sub_1001E211C(v52, 4364, 260, 0);
        sub_1001E211C(v52, 4367, 260, 0);
      }

      else
      {
        uint64_t v26 = v52;
        __int16 v27 = sub_1003DA854(v14);
        __int16 v28 = sub_1003DA970(v14);
        sub_1001E211C(v26, 4364, v27, v28);
        uint64_t v29 = v52;
        __int16 v30 = sub_1003DA698(v14);
        __int16 v31 = sub_1003DA7B4(v14);
        sub_1001E211C(v29, 4367, v30, v31);
      }

      uint64_t v65 = 0LL;
      __int128 v64 = 0u;
      memset(v63, 0, sizeof(v63));
      __int128 v61 = 0u;
      *(_OWORD *)std::string __p = 0u;
      *(_OWORD *)__int128 v60 = 0u;
      memset(buf, 0, sizeof(buf));
      sub_100532DC0((uint64_t)&buf[1]);
      _BYTE buf[18] = 0;
      buf[20] = 0;
      BYTE2(v60[0]) = 0;
      BYTE4(v60[0]) = 0;
      DWORD1(v63[1]) = 0;
      memset(&buf[24], 0, 24);
      LOBYTE(v60[0]) = 0;
      __int128 v61 = 0uLL;
      v60[1] = 0LL;
      LOBYTE(__p[0]) = 0;
      memset(v63, 0, 19);
      __p[1] = 0LL;
      BYTE8(v63[1]) = 1;
      BYTE2(v65) = 0;
      *(void *)((char *)&v63[1] + 14) = 0LL;
      *(void *)((char *)&v63[1] + 9) = 0LL;
      __int128 v64 = 0uLL;
      *((void *)&v63[2] + 1) = 0LL;
      LOBYTE(v65) = 0;
      BOOL v32 = sub_1003D2408(v14, (uint64_t)buf);
      if (BYTE1(v64)) {
        BOOL v33 = v32;
      }
      else {
        BOOL v33 = 0;
      }
      if (v33 || sub_1003D34C0(v14))
      {
        __int128 v34 = (os_log_s *)qword_1008F75D8;
        if (os_log_type_enabled((os_log_t)qword_1008F75D8, OS_LOG_TYPE_DEFAULT))
        {
          sub_1003D01A0(v14, (uint64_t)v53);
          __int128 v35 = v56 >= 0 ? v53 : *(_BYTE **)v53;
          *(_DWORD *)__int128 v57 = 136315138;
          uint64_t v58 = v35;
          _os_log_impl( (void *)&_mh_execute_header,  v34,  OS_LOG_TYPE_DEFAULT,  "Forcing legacy PBAP SDP for device %s",  v57,  0xCu);
          if (v56 < 0) {
            operator delete(*(void **)v53);
          }
        }

        sub_1001E211C(v52, 4398, 256, 0);
      }

      BOOL v36 = sub_1003D2408(v14, (uint64_t)buf);
      if (BYTE2(v64)) {
        BOOL v38 = v36;
      }
      else {
        BOOL v38 = 0;
      }
      if (v38)
      {
        __int128 v39 = (os_log_s *)qword_1008F75D8;
        if (os_log_type_enabled((os_log_t)qword_1008F75D8, OS_LOG_TYPE_DEFAULT))
        {
          sub_1003D01A0(v14, (uint64_t)v53);
          __int128 v40 = v56 >= 0 ? v53 : *(_BYTE **)v53;
          *(_DWORD *)__int128 v57 = 136315138;
          uint64_t v58 = v40;
          _os_log_impl( (void *)&_mh_execute_header,  v39,  OS_LOG_TYPE_DEFAULT,  "Forcing legacy MAP SDP for device %s",  v57,  0xCu);
          if (v56 < 0) {
            operator delete(*(void **)v53);
          }
        }

        sub_1001E211C(v52, 4404, 257, 0);
      }

      if (SHIBYTE(v63[0]) < 0) {
        operator delete(__p[1]);
      }
      if (SHIBYTE(v61) < 0) {
        operator delete(v60[1]);
      }
      nullsub_63(&buf[1], v37);
    }

    __int128 v41 = (os_log_s *)qword_1008F75D8;
    if (os_log_type_enabled((os_log_t)qword_1008F75D8, OS_LOG_TYPE_DEFAULT))
    {
      int v42 = *(unsigned __int8 *)(v14 + 976);
      *(_DWORD *)__int128 buf = 136315907;
      if (v42) {
        __int128 v43 = "true";
      }
      else {
        __int128 v43 = "false";
      }
      *(void *)&uint8_t buf[4] = v43;
      *(_WORD *)&_BYTE buf[12] = 2160;
      *(void *)&buf[14] = 1752392040LL;
      *(_WORD *)&_BYTE buf[22] = 1041;
      *(_DWORD *)&uint8_t buf[24] = 6;
      *(_WORD *)&buf[28] = 2097;
      *(void *)&buf[30] = a1;
      _os_log_impl( (void *)&_mh_execute_header,  v41,  OS_LOG_TYPE_DEFAULT,  "Wireless Splitter set guest device not in contacts to '%s ' into the remote SDP record for %{private,bluetooth:B D_ADDR,mask.hash}.6P ",  buf,  0x26u);
    }

    sub_1001E1E34(v52, *(_BYTE *)(v14 + 976));
    int v44 = sub_1003D2B2C(v14, 12);
    uint64_t v45 = (os_log_s *)qword_1008F75D8;
    if (os_log_type_enabled((os_log_t)qword_1008F75D8, OS_LOG_TYPE_DEFAULT))
    {
      unint64_t v46 = v44 ? "false" : "true";
      sub_1003D01A0(v14, (uint64_t)buf);
      __int128 v47 = (buf[23] & 0x80u) == 0 ? buf : *(uint8_t **)buf;
      *(_DWORD *)uint64_t v53 = 136315394;
      *(void *)&v53[4] = v46;
      __int16 v54 = 2080;
      int v55 = v47;
      _os_log_impl( (void *)&_mh_execute_header,  v45,  OS_LOG_TYPE_DEFAULT,  "Setting requiresLegacyPnPInformationRecord to %s for device %s",  v53,  0x16u);
    }

    sub_1001E1FA8(v52, v44 ^ 1);
    goto LABEL_10;
  }

  uint64_t v15 = (os_log_s *)qword_1008F75D8;
  if (os_log_type_enabled((os_log_t)qword_1008F75D8, OS_LOG_TYPE_DEFAULT))
  {
    *(_DWORD *)__int128 buf = 141558787;
    *(void *)&uint8_t buf[4] = 1752392040LL;
    *(_WORD *)&_BYTE buf[12] = 1041;
    *(_DWORD *)&buf[14] = 6;
    *(_WORD *)&_BYTE buf[18] = 2097;
    *(void *)&buf[20] = a1;
    *(_WORD *)&buf[28] = 1024;
    *(_DWORD *)&buf[30] = a2;
    _os_log_impl( (void *)&_mh_execute_header,  v15,  OS_LOG_TYPE_DEFAULT,  "stalling incoming SDP request from %{private,bluetooth:BD_ADDR,mask.hash}.6P for cid: %d. Initiating an outgoing S DP request for SDP Mirroring",  buf,  0x22u);
  }

  sub_1003D8ABC(v14, 1);
  sub_1003D8B44(v14, a2);
  if (qword_1008D9600 != -1) {
    dispatch_once(&qword_1008D9600, &stru_100897648);
  }
  sub_10041AA14(qword_1008D95F8, v14, 0LL, 1, 2);
  return 847LL;
}

void sub_100419148( _Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, ...)
{
}

void sub_10041916C(uint64_t a1)
{
  if (*(void *)(a1 + 32))
  {
    if (qword_1008D5F50 != -1) {
      dispatch_once(&qword_1008D5F50, &stru_100897628);
    }
    sub_1004006DC((uint64_t)off_1008D5F48, *(void *)(a1 + 32), *(unsigned int *)(a1 + 40));
  }

  else
  {
    BOOL v2 = (os_log_s *)qword_1008F75D8;
    if (os_log_type_enabled((os_log_t)qword_1008F75D8, OS_LOG_TYPE_ERROR)) {
      sub_10067D2FC(a1, v2);
    }
  }

void sub_100419200(id a1)
{
  uint64_t v1 = operator new(0x138uLL);
  sub_1003FE3E0((uint64_t)v1);
  off_1008D5F48 = v1;
}

void sub_100419230(_Unwind_Exception *a1)
{
}

void sub_100419244(id a1)
{
  uint64_t v1 = operator new(0x58uLL);
  sub_10041A094(v1);
  qword_1008D95F8 = (uint64_t)v1;
}

void sub_100419274(_Unwind_Exception *a1)
{
}

void sub_100419288(void *a1, void *a2)
{
  uint64_t v4 = a1[2];
  uint64_t v5 = a1[1];
  if (v4 == v5) {
    uint64_t v6 = 0LL;
  }
  else {
    uint64_t v6 = ((v4 - v5) << 6) - 1;
  }
  uint64_t v7 = a1[5];
  unint64_t v8 = v7 + a1[4];
  if (v6 == v8)
  {
    sub_10041930C(a1);
    uint64_t v5 = a1[1];
    uint64_t v7 = a1[5];
    unint64_t v8 = a1[4] + v7;
  }

  *(void *)(*(void *)(v5 + ((v8 >> 6) & 0x3FFFFFFFFFFFFF8LL)) + 8 * (v8 & 0x1FF)) = *a2;
  a1[5] = v7 + 1;
}

void sub_10041930C(void *a1)
{
  unint64_t v2 = a1[4];
  BOOL v3 = v2 >= 0x200;
  unint64_t v4 = v2 - 512;
  if (v3)
  {
    uint64_t v5 = (uint64_t)(a1 + 3);
    uint64_t v6 = (char *)a1[3];
    a1[4] = v4;
    uint64_t v7 = (void *)a1[1];
    unint64_t v8 = (char *)a1[2];
    uint64_t v11 = *v7;
    unint64_t v9 = (char *)(v7 + 1);
    uint64_t v10 = v11;
    a1[1] = v9;
    if (v8 != v6)
    {
LABEL_33:
      *(void *)unint64_t v8 = v10;
      a1[2] += 8LL;
      return;
    }

    uint64_t v12 = (uint64_t)&v9[-*a1];
    if ((unint64_t)v9 <= *a1)
    {
      else {
        unint64_t v33 = (uint64_t)&v8[-*a1] >> 2;
      }
      __int128 v34 = (char *)sub_100008BA0(v5, v33);
      __int128 v35 = &v34[8 * (v33 >> 2)];
      uint64_t v37 = &v34[8 * v36];
      BOOL v38 = (uint64_t *)a1[1];
      unint64_t v8 = v35;
      uint64_t v39 = a1[2] - (void)v38;
      if (v39)
      {
        unint64_t v8 = &v35[v39 & 0xFFFFFFFFFFFFFFF8LL];
        uint64_t v40 = 8 * (v39 >> 3);
        __int128 v41 = &v34[8 * (v33 >> 2)];
        do
        {
          uint64_t v42 = *v38++;
          *(void *)__int128 v41 = v42;
          v41 += 8;
          v40 -= 8LL;
        }

        while (v40);
      }

      goto LABEL_30;
    }

void sub_1004195D4( _Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, void *__p, uint64_t a12, uint64_t a13)
{
  if (__p) {
    operator delete(__p);
  }
  _Unwind_Resume(a1);
}

void sub_100419620(id a1)
{
  uint64_t v1 = operator new(0x230uLL);
  sub_10042BC28();
  off_1008D60A8 = v1;
}

void sub_100419650(_Unwind_Exception *a1)
{
}

void *sub_100419664(void *a1, void *a2)
{
  if (a1 != a2)
  {
    unint64_t v4 = a2[4];
    uint64_t v5 = a2[1];
    uint64_t v6 = a2[2];
    uint64_t v7 = (char **)(v5 + 8 * (v4 >> 9));
    if (v6 == v5)
    {
      unint64_t v8 = 0LL;
      uint64_t v11 = 0LL;
      uint64_t v10 = (char *)(v5 + 8 * ((a2[5] + v4) >> 9));
    }

    else
    {
      unint64_t v8 = &(*v7)[8 * (v4 & 0x1FF)];
      unint64_t v9 = a2[5] + v4;
      uint64_t v10 = (char *)(v5 + 8 * (v9 >> 9));
      uint64_t v11 = (char *)(*(void *)v10 + 8 * (v9 & 0x1FF));
    }

    sub_1004196F4(a1, v7, v8, v10, v11);
  }

  return a1;
}

void *sub_1004196F4(void *a1, char **a2, char *a3, char *a4, char *a5)
{
  if (a5 == a3) {
    unint64_t v5 = 0LL;
  }
  else {
    unint64_t v5 = ((uint64_t)&a5[-*(void *)a4] >> 3) + ((a4 - (char *)a2) << 6) - ((a3 - *a2) >> 3);
  }
  return sub_100419728(a1, a2, a3, v5);
}

void *sub_100419728(void *a1, char **a2, char *a3, unint64_t a4)
{
  int64_t v20 = a2;
  uint64_t v21 = a3;
  unint64_t v7 = a1[5];
  if (v7 >= a4)
  {
    uint64_t v14 = a1[1];
    uint64_t v15 = (char *)(v14 + 8LL * (a1[4] >> 9));
    if (a1[2] == v14) {
      uint64_t v16 = 0LL;
    }
    else {
      uint64_t v16 = *(void *)v15 + 8 * (a1[4] & 0x1FFLL);
    }
    v22[0] = a2;
    v22[1] = a3;
    uint64_t v18 = (char **)sub_10023FC2C((uint64_t)v22, a4);
    uint64_t v23 = v15;
    uint64_t v24 = v16;
    sub_100241A5C(a2, a3, v18, v19, (uint64_t)&v23);
    return (void *)sub_100241964((uint64_t)a1, v23, v24);
  }

  else
  {
    unint64_t v9 = (char **)sub_10023FC2C((uint64_t)&v20, v7);
    uint64_t v10 = (uint64_t *)v8;
    uint64_t v11 = a1[1];
    if (a1[2] == v11) {
      uint64_t v12 = 0LL;
    }
    else {
      uint64_t v12 = *(void *)(v11 + 8LL * (a1[4] >> 9)) + 8 * (a1[4] & 0x1FFLL);
    }
    uint64_t v23 = (char *)(v11 + 8LL * (a1[4] >> 9));
    uint64_t v24 = v12;
    sub_100241A5C(v20, v21, v9, v8, (uint64_t)&v23);
    return sub_10041984C(a1, v9, v10, a4 - a1[5]);
  }

void *sub_10041984C(void *a1, void *a2, uint64_t *a3, unint64_t a4)
{
  uint64_t v8 = a1[1];
  uint64_t v9 = a1[2];
  if (v9 == v8) {
    uint64_t v10 = 0LL;
  }
  else {
    uint64_t v10 = ((v9 - v8) << 6) - 1;
  }
  unint64_t v11 = a1[5] + a1[4];
  unint64_t v12 = v10 - v11;
  if (a4 > v12)
  {
    sub_10041997C(a1, a4 - v12);
    uint64_t v8 = a1[1];
    uint64_t v9 = a1[2];
    unint64_t v11 = a1[4] + a1[5];
  }

  uint64_t v13 = (void *)(v8 + 8 * (v11 >> 9));
  if (v9 == v8) {
    uint64_t v14 = 0LL;
  }
  else {
    uint64_t v14 = *v13 + 8 * (v11 & 0x1FF);
  }
  v23[0] = v8 + 8 * (v11 >> 9);
  v23[1] = v14;
  uint64_t result = sub_10023FC2C((uint64_t)v23, a4);
  if (v14 != v16)
  {
    uint64_t v17 = a1[5];
    do
    {
      if (v13 == result) {
        uint64_t v18 = v16;
      }
      else {
        uint64_t v18 = *v13 + 4096LL;
      }
      if (v14 == v18)
      {
        uint64_t v18 = v14;
      }

      else
      {
        uint64_t v19 = (void *)v14;
        do
        {
          uint64_t v20 = *a3++;
          *v19++ = v20;
          if ((uint64_t *)((char *)a3 - *a2) == (uint64_t *)4096)
          {
            uint64_t v21 = (uint64_t *)a2[1];
            ++a2;
            a3 = v21;
          }
        }

        while (v19 != (void *)v18);
      }

      v17 += (v18 - v14) >> 3;
      if (v13 == result) {
        break;
      }
      uint64_t v22 = v13[1];
      ++v13;
      uint64_t v14 = v22;
    }

    while (v22 != v16);
    a1[5] = v17;
  }

  return result;
}

void sub_10041997C(void *a1, unint64_t a2)
{
  BOOL v3 = (char *)a1[2];
  uint64_t v4 = (uint64_t)&v3[-a1[1]];
  if (v4) {
    unint64_t v5 = a2;
  }
  else {
    unint64_t v5 = a2 + 1;
  }
  if ((v5 & 0x1FF) != 0) {
    unint64_t v6 = (v5 >> 9) + 1;
  }
  else {
    unint64_t v6 = v5 >> 9;
  }
  unint64_t v7 = a1[4];
  if (v6 >= v7 >> 9) {
    unint64_t v8 = v7 >> 9;
  }
  else {
    unint64_t v8 = v6;
  }
  if (v6 <= v7 >> 9)
  {
    for (a1[4] = v7 - (v8 << 9); v8; --v8)
    {
      uint64_t v16 = (void *)a1[1];
      uint64_t v19 = *v16;
      uint64_t v17 = (char *)(v16 + 1);
      uint64_t v18 = v19;
      a1[1] = v17;
      if (v3 == (char *)a1[3])
      {
        uint64_t v20 = (uint64_t)&v17[-*a1];
        if ((unint64_t)v17 <= *a1)
        {
          else {
            unint64_t v28 = (uint64_t)&v3[-*a1] >> 2;
          }
          uint64_t v29 = (char *)sub_100008BA0((uint64_t)(a1 + 3), v28);
          __int128 v31 = &v29[8 * (v28 >> 2)];
          __int128 v32 = (uint64_t *)a1[1];
          BOOL v3 = v31;
          uint64_t v33 = a1[2] - (void)v32;
          if (v33)
          {
            BOOL v3 = &v31[v33 & 0xFFFFFFFFFFFFFFF8LL];
            uint64_t v34 = 8 * (v33 >> 3);
            __int128 v35 = &v29[8 * (v28 >> 2)];
            do
            {
              uint64_t v36 = *v32++;
              *(void *)__int128 v35 = v36;
              v35 += 8;
              v34 -= 8LL;
            }

            while (v34);
          }

          uint64_t v37 = (char *)*a1;
          *a1 = v29;
          a1[1] = v31;
          a1[2] = v3;
          a1[3] = &v29[8 * v30];
          if (v37)
          {
            operator delete(v37);
            BOOL v3 = (char *)a1[2];
          }
        }

        else
        {
          uint64_t v21 = v20 >> 3;
          BOOL v22 = v20 >> 3 < -1;
          uint64_t v23 = (v20 >> 3) + 2;
          if (v22) {
            uint64_t v24 = v23;
          }
          else {
            uint64_t v24 = v21 + 1;
          }
          unint64_t v25 = &v17[-8 * (v24 >> 1)];
          int64_t v26 = v3 - v17;
          if (v3 != v17)
          {
            memmove(&v17[-8 * (v24 >> 1)], v17, v3 - v17);
            BOOL v3 = (char *)a1[1];
          }

          __int16 v27 = &v3[-8 * (v24 >> 1)];
          BOOL v3 = &v25[v26];
          a1[1] = v27;
          a1[2] = &v25[v26];
        }
      }

      *(void *)BOOL v3 = v18;
      BOOL v3 = (char *)(a1[2] + 8LL);
      a1[2] = v3;
    }
  }

  else
  {
    unint64_t v9 = v6 - v8;
    uint64_t v10 = a1[3] - *a1;
    if (v6 - v8 <= (v10 >> 3) - (v4 >> 3))
    {
      if (v9)
      {
        while (a1[3] != a1[2])
        {
          __p[0] = operator new(0x1000uLL);
          sub_10023FC90(a1, __p);
          --v6;
          if (!--v9) {
            goto LABEL_75;
          }
        }

        for (uint64_t i = 0LL; i != v9; ++i)
        {
          __p[0] = operator new(0x1000uLL);
          sub_10023FDA4((uint64_t)a1, __p);
          if (a1[2] - a1[1] == 8LL) {
            uint64_t v64 = 511LL;
          }
          else {
            uint64_t v64 = 512LL;
          }
          uint64_t v65 = v64 + a1[4];
          a1[4] = v65;
        }

        unint64_t v8 = v6;
      }

      else
      {
LABEL_75:
        uint64_t v65 = a1[4];
      }

      a1[4] = v65 - (v8 << 9);
      if (v8)
      {
        uint64_t v66 = (char *)a1[2];
        do
        {
          char v67 = (void *)a1[1];
          uint64_t v70 = *v67;
          char v68 = (char *)(v67 + 1);
          uint64_t v69 = v70;
          a1[1] = v68;
          if (v66 == (char *)a1[3])
          {
            uint64_t v71 = (uint64_t)&v68[-*a1];
            if ((unint64_t)v68 <= *a1)
            {
              else {
                unint64_t v78 = (uint64_t)&v66[-*a1] >> 2;
              }
              __int128 v79 = (char *)sub_100008BA0((uint64_t)(a1 + 3), v78);
              __int16 v81 = &v79[8 * (v78 >> 2)];
              int v82 = (uint64_t *)a1[1];
              uint64_t v66 = v81;
              uint64_t v83 = a1[2] - (void)v82;
              if (v83)
              {
                uint64_t v66 = &v81[v83 & 0xFFFFFFFFFFFFFFF8LL];
                uint64_t v84 = 8 * (v83 >> 3);
                __int16 v85 = &v79[8 * (v78 >> 2)];
                do
                {
                  uint64_t v86 = *v82++;
                  *(void *)__int16 v85 = v86;
                  v85 += 8;
                  v84 -= 8LL;
                }

                while (v84);
              }

              int v87 = (char *)*a1;
              *a1 = v79;
              a1[1] = v81;
              a1[2] = v66;
              a1[3] = &v79[8 * v80];
              if (v87)
              {
                operator delete(v87);
                uint64_t v66 = (char *)a1[2];
              }
            }

            else
            {
              uint64_t v72 = v71 >> 3;
              BOOL v22 = v71 >> 3 < -1;
              uint64_t v73 = (v71 >> 3) + 2;
              if (v22) {
                uint64_t v74 = v73;
              }
              else {
                uint64_t v74 = v72 + 1;
              }
              uint64_t v75 = &v68[-8 * (v74 >> 1)];
              int64_t v76 = v66 - v68;
              if (v66 != v68)
              {
                memmove(&v68[-8 * (v74 >> 1)], v68, v66 - v68);
                uint64_t v66 = (char *)a1[1];
              }

              uint64_t v77 = &v66[-8 * (v74 >> 1)];
              uint64_t v66 = &v75[v76];
              a1[1] = v77;
              a1[2] = &v75[v76];
            }
          }

          *(void *)uint64_t v66 = v69;
          uint64_t v66 = (char *)(a1[2] + 8LL);
          a1[2] = v66;
          --v8;
        }

        while (v8);
      }
    }

    else
    {
      uint64_t v11 = v4 >> 3;
      unint64_t v12 = v10 >> 2;
      if (v12 <= v9 + v11) {
        unint64_t v13 = v9 + v11;
      }
      else {
        unint64_t v13 = v12;
      }
      unint64_t v14 = v11 - v8;
      int v91 = a1 + 3;
      if (v13) {
        uint64_t v15 = (char *)sub_100008BA0((uint64_t)(a1 + 3), v13);
      }
      else {
        uint64_t v15 = 0LL;
      }
      uint64_t v38 = v8 << 9;
      __p[0] = v15;
      __p[1] = &v15[8 * v14];
      *(void **)&__int128 v90 = __p[1];
      *((void *)&v90 + 1) = &v15[8 * v13];
      do
      {
        __int16 v88 = operator new(0x1000uLL);
        sub_10023FEC0(__p, &v88);
        --v9;
      }

      while (v9);
      if (v8)
      {
        uint64_t v39 = (void *)a1[1];
        uint64_t v40 = (char *)v90;
        do
        {
          if (v40 == *((char **)&v90 + 1))
          {
            int64_t v41 = (char *)__p[1] - (char *)__p[0];
            if (__p[1] <= __p[0])
            {
              if (v40 == __p[0]) {
                unint64_t v48 = 1LL;
              }
              else {
                unint64_t v48 = (v40 - (char *)__p[0]) >> 2;
              }
              uint64_t v49 = (char *)sub_100008BA0((uint64_t)v91, v48);
              __int16 v51 = (uint64_t *)__p[1];
              uint64_t v40 = &v49[8 * (v48 >> 2)];
              uint64_t v52 = v90 - (unint64_t)__p[1];
              if ((void *)v90 != __p[1])
              {
                uint64_t v40 = &v49[8 * (v48 >> 2) + (v52 & 0xFFFFFFFFFFFFFFF8LL)];
                uint64_t v53 = 8 * (v52 >> 3);
                __int128 v54 = &v49[8 * (v48 >> 2)];
                do
                {
                  uint64_t v55 = *v51++;
                  *(void *)__int128 v54 = v55;
                  v54 += 8;
                  v53 -= 8LL;
                }

                while (v53);
              }

              char v56 = __p[0];
              __p[0] = v49;
              __p[1] = &v49[8 * (v48 >> 2)];
              *(void *)&__int128 v90 = v40;
              *((void *)&v90 + 1) = &v49[8 * v50];
              if (v56)
              {
                operator delete(v56);
                uint64_t v40 = (char *)v90;
              }
            }

            else
            {
              uint64_t v42 = v41 >> 3;
              BOOL v22 = v41 >> 3 < -1;
              uint64_t v43 = (v41 >> 3) + 2;
              if (v22) {
                uint64_t v44 = v43;
              }
              else {
                uint64_t v44 = v42 + 1;
              }
              uint64_t v45 = (char *)__p[1] - 8 * (v44 >> 1);
              int64_t v46 = v40 - (char *)__p[1];
              if (v40 != __p[1])
              {
                memmove((char *)__p[1] - 8 * (v44 >> 1), __p[1], v40 - (char *)__p[1]);
                uint64_t v40 = (char *)__p[1];
              }

              uint64_t v47 = &v40[-8 * (v44 >> 1)];
              uint64_t v40 = &v45[v46];
              __p[1] = v47;
              *(void *)&__int128 v90 = &v45[v46];
            }
          }

          *(void *)uint64_t v40 = *v39;
          uint64_t v40 = (char *)(v90 + 8);
          *(void *)&__int128 v90 = v90 + 8;
          uint64_t v39 = (void *)(a1[1] + 8LL);
          a1[1] = v39;
          --v8;
        }

        while (v8);
      }

      __int128 v57 = (void *)a1[2];
      uint64_t v58 = -7LL - (void)v57;
      while (v57 != (void *)a1[1])
      {
        --v57;
        v58 += 8LL;
        sub_10023FFD4((uint64_t)__p, v57);
      }

      uint64_t v59 = (char *)*a1;
      __int128 v60 = *(_OWORD *)__p;
      __int128 v61 = v90;
      __p[0] = *(void **)a1;
      __p[1] = v57;
      __int128 v62 = *((_OWORD *)a1 + 1);
      *(_OWORD *)a1 = v60;
      *((_OWORD *)a1 + 1) = v61;
      __int128 v90 = v62;
      a1[4] -= v38;
      if (v57 != (void *)v62) {
        *(void *)&__int128 v90 = v62 + (-(v62 + v58) & 0xFFFFFFFFFFFFFFF8LL);
      }
      if (v59) {
        operator delete(v59);
      }
    }
  }

void sub_100419E90( _Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, void *__p, uint64_t a12, uint64_t a13)
{
  if (__p) {
    operator delete(__p);
  }
  _Unwind_Resume(exception_object);
}

uint64_t sub_100419ED0(uint64_t a1, void *a2)
{
  *(_OWORD *)(a1 + 16) = 0u;
  *(_OWORD *)(a1 + sub_100242FAC(v1 - 32) = 0u;
  *(_OWORD *)a1 = 0u;
  unint64_t v4 = a2[4];
  uint64_t v5 = a2[1];
  uint64_t v6 = a2[2];
  unint64_t v7 = (char *)(v5 + 8 * (v4 >> 9));
  if (v6 == v5)
  {
    unint64_t v8 = 0LL;
    uint64_t v11 = 0LL;
    uint64_t v10 = (char *)(v5 + 8 * ((a2[5] + v4) >> 9));
  }

  else
  {
    unint64_t v8 = (uint64_t *)(*(void *)v7 + 8 * (v4 & 0x1FF));
    unint64_t v9 = a2[5] + v4;
    uint64_t v10 = (char *)(v5 + 8 * (v9 >> 9));
    uint64_t v11 = (uint64_t *)(*(void *)v10 + 8 * (v9 & 0x1FF));
  }

  sub_100419F78((void *)a1, v7, v8, v10, v11);
  return a1;
}

void sub_100419F64(_Unwind_Exception *a1)
{
}

void *sub_100419F78(void *a1, char *a2, uint64_t *a3, char *a4, uint64_t *a5)
{
  if (a5 == a3) {
    unint64_t v5 = 0LL;
  }
  else {
    unint64_t v5 = (((uint64_t)a5 - *(void *)a4) >> 3) + ((a4 - a2) << 6) - (((uint64_t)a3 - *(void *)a2) >> 3);
  }
  return sub_10041984C(a1, a2, a3, v5);
}

void sub_100419FAC()
{
  int v0 = objc_autoreleasePoolPush();
  sub_100242DC4(&unk_1008F7280);
  __cxa_atexit((void (*)(void *))sub_100242E28, &unk_1008F7280, (void *)&_mh_execute_header);
  *(_OWORD *)&qword_1008F72C8 = 0u;
  unk_1008F72D8 = 0u;
  xmmword_1008F72E8 = 0u;
  __cxa_atexit((void (*)(void *))sub_100414510, &qword_1008F72C8, (void *)&_mh_execute_header);
  sub_100242DC4(&unk_1008F72F8);
  __cxa_atexit((void (*)(void *))sub_100242E28, &unk_1008F72F8, (void *)&_mh_execute_header);
  qword_1008F0AC0 = 0LL;
  qword_1008F0AC8 = 0LL;
  qword_1008F0AB8 = 0LL;
  __cxa_atexit((void (*)(void *))sub_100414514, &qword_1008F0AB8, (void *)&_mh_execute_header);
  qword_1008F0AE0 = 0LL;
  qword_1008F0AD8 = 0LL;
  qword_1008F0AD0 = (uint64_t)&qword_1008F0AD8;
  __cxa_atexit((void (*)(void *))sub_100414544, &qword_1008F0AD0, (void *)&_mh_execute_header);
  objc_autoreleasePoolPop(v0);
}

void *sub_10041A094(void *a1)
{
  *a1 = off_1008977C0;
  sub_100242DC4(a1 + 1);
  a1[9] = 0LL;
  return a1;
}

void *sub_10041A0C8(void *a1)
{
  *a1 = off_1008977C0;
  unint64_t v2 = (os_log_s *)qword_1008F7578;
  if (os_log_type_enabled((os_log_t)qword_1008F7578, OS_LOG_TYPE_DEFAULT))
  {
    *(_WORD *)uint64_t v6 = 0;
    _os_log_impl((void *)&_mh_execute_header, v2, OS_LOG_TYPE_DEFAULT, "SDP Manager deconstructor", v6, 2u);
  }

  if (qword_1008D60B0 != -1) {
    dispatch_once(&qword_1008D60B0, &stru_1008978C0);
  }
  sub_100009168((uint64_t)off_1008D60A8 + 80, (uint64_t)a1);
  uint64_t v3 = a1[9];
  if (v3)
  {
    unint64_t v4 = (void *)sub_100405360(v3);
    operator delete(v4);
  }

  sub_100242E28(a1 + 1);
  return a1;
}

void sub_10041A194(_Unwind_Exception *a1)
{
}

void sub_10041A1AC(void *a1)
{
  uint64_t v1 = sub_10041A0C8(a1);
  operator delete(v1);
}

void sub_10041A1C0(uint64_t a1)
{
  unint64_t v2 = operator new(0x10uLL);
  sub_100404F28(v2, (uint64_t)"BT SdpMgr");
  *(void *)(a1 + 72) = v2;
  if (qword_1008D60B0 != -1) {
    dispatch_once(&qword_1008D60B0, &stru_1008978C0);
  }
  sub_1001FC5E4((uint64_t)off_1008D60A8 + 80, a1);
}

void sub_10041A230(_Unwind_Exception *a1)
{
}

uint64_t sub_10041A244(uint64_t a1)
{
  unint64_t v2 = (os_log_s *)qword_1008F7578;
  if (os_log_type_enabled((os_log_t)qword_1008F7578, OS_LOG_TYPE_DEFAULT))
  {
    LOWORD(v6[0]) = 0;
    _os_log_impl((void *)&_mh_execute_header, v2, OS_LOG_TYPE_DEFAULT, "SDP Manager stackDidStart", (uint8_t *)v6, 2u);
  }

  v6[0] = 0LL;
  v6[1] = 0LL;
  sub_100242F28((uint64_t)v6, a1 + 8);
  sub_100404F30(*(void *)(a1 + 72), QOS_CLASS_USER_INITIATED);
  *(_BYTE *)(a1 + 8sub_100414D2C(qword_1008F72C0, 0) = 1;
  uint64_t v3 = operator new(0xA0uLL);
  sub_1004145D0((uint64_t)v3, 0LL);
  sub_1004145FC();
  sub_100418574((uint64_t)v3, 1);
  unint64_t v4 = (void *)sub_1004145D4(v3);
  operator delete(v4);
  return sub_100242FAC((uint64_t)v6);
}

void sub_10041A30C( _Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9)
{
}

uint64_t sub_10041A334(uint64_t a1)
{
  unint64_t v2 = (os_log_s *)qword_1008F7578;
  if (os_log_type_enabled((os_log_t)qword_1008F7578, OS_LOG_TYPE_DEFAULT))
  {
    *(_WORD *)__int128 buf = 0;
    _os_log_impl((void *)&_mh_execute_header, v2, OS_LOG_TYPE_DEFAULT, "SdpManager::stackWillStop enter", buf, 2u);
  }

  *(void *)__int128 buf = 0LL;
  uint64_t v9 = 0LL;
  sub_100242F28((uint64_t)buf, a1 + 8);
  sub_1004052F8(*(void *)(a1 + 72));
  *(_BYTE *)(a1 + 8sub_100414D2C(qword_1008F72C0, 0) = 0;
  uint64_t v3 = operator new(0xA0uLL);
  sub_1004145D0((uint64_t)v3, 0LL);
  sub_100414A5C();
  sub_100414814((uint64_t)v3, 0);
  unint64_t v4 = (void *)sub_1004145D4(v3);
  operator delete(v4);
  unint64_t v5 = (os_log_s *)qword_1008F7578;
  if (os_log_type_enabled((os_log_t)qword_1008F7578, OS_LOG_TYPE_DEFAULT))
  {
    *(_WORD *)unint64_t v7 = 0;
    _os_log_impl((void *)&_mh_execute_header, v5, OS_LOG_TYPE_DEFAULT, "SdpManager::stackWillStop exit", v7, 2u);
  }

  return sub_100242FAC((uint64_t)buf);
}

void sub_10041A438( _Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, char a11)
{
}

uint64_t sub_10041A460(uint64_t a1, _BYTE *a2)
{
  v5[0] = 0LL;
  v5[1] = 0LL;
  sub_100242F28((uint64_t)v5, a1 + 8);
  sub_100405744(*(void *)(a1 + 72), a2);
  return sub_100242FAC((uint64_t)v5);
}

void sub_10041A4AC( _Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9)
{
}

void sub_10041A4C0(uint64_t a1, uint64_t a2)
{
  uint64_t v3 = operator new(0xA0uLL);
  sub_1004145D0((uint64_t)v3, *(void *)(a2 + 8));
  if (!*(_BYTE *)(a2 + 28)) {
    sub_100414814((uint64_t)v3, 1);
  }
  v3[156] = *(_BYTE *)(a2 + 29);
  int v4 = sub_100414B48((uint64_t)v3, a2);
  sub_100418574((uint64_t)v3, *(_BYTE *)(a2 + 28));
  if (v4)
  {
    unint64_t v5 = (void *)sub_1004145D4(v3);
    operator delete(v5);
  }

void sub_10041A54C(_Unwind_Exception *a1)
{
}

void sub_10041A560(uint64_t a1, uint64_t a2)
{
  unint64_t v2 = *(unsigned __int8 **)(a2 + 8);
  uint64_t v3 = (os_log_s *)qword_1008F7578;
  if (v2)
  {
    if (os_log_type_enabled((os_log_t)qword_1008F7578, OS_LOG_TYPE_DEFAULT))
    {
      sub_1003CF00C((uint64_t)v2, __p);
      unint64_t v5 = v27 >= 0 ? __p : (void **)__p[0];
      unsigned int v6 = *(_DWORD *)(a2 + 24);
      *(_DWORD *)__int128 buf = 136446466;
      *(void *)&uint8_t buf[4] = v5;
      __int16 v23 = 1024;
      unsigned int v24 = v6;
      _os_log_impl( (void *)&_mh_execute_header,  v3,  OS_LOG_TYPE_DEFAULT,  "SDP query has completed for device %{public}s with status %d",  buf,  0x12u);
      if (v27 < 0) {
        operator delete(__p[0]);
      }
    }

    int v21 = 0;
    sub_1003D0454((uint64_t)v2, &v21);
    if (!*(_DWORD *)(a2 + 24))
    {
      sub_1003E3BB4((uint64_t)v2, 1);
      if (sub_1003CF350(v2))
      {
        unint64_t v7 = (os_log_s *)qword_1008F7578;
        if (os_log_type_enabled((os_log_t)qword_1008F7578, OS_LOG_TYPE_DEFAULT))
        {
          sub_1003CF00C((uint64_t)v2, __p);
          unint64_t v8 = v27 >= 0 ? __p : (void **)__p[0];
          *(_DWORD *)__int128 buf = 136446210;
          *(void *)&uint8_t buf[4] = v8;
          _os_log_impl( (void *)&_mh_execute_header,  v7,  OS_LOG_TYPE_DEFAULT,  "Identification - SDP complete. Checking if we need to generate hash for device %{public}s",  buf,  0xCu);
          if (v27 < 0) {
            operator delete(__p[0]);
          }
        }

        sub_1003D1398((uint64_t)v2);
        sub_1003DCEB8((uint64_t)v2);
      }
    }

    char v20 = 0;
    uint64_t v9 = sub_1002E6E00();
    sub_10002418C(__p, "SDPMirroring");
    sub_10002418C(buf, "DisableSDPMirroring");
    (*(void (**)(uint64_t, void **, _BYTE *, char *))(*(void *)v9 + 72LL))(v9, __p, buf, &v20);
    if (v25 < 0) {
      operator delete(*(void **)buf);
    }
    if (v27 < 0) {
      operator delete(__p[0]);
    }
    char v19 = 0;
    sub_100242CA4(&v19);
    if (sub_1003D8B00((uint64_t)v2))
    {
      unsigned int v10 = sub_1003D8B88((uint64_t)v2);
      uint64_t v11 = (os_log_s *)qword_1008F7578;
      if (os_log_type_enabled((os_log_t)qword_1008F7578, OS_LOG_TYPE_DEFAULT))
      {
        sub_1003CF00C((uint64_t)v2, __p);
        unint64_t v12 = v27 >= 0 ? __p : (void **)__p[0];
        *(_DWORD *)__int128 buf = 136446466;
        *(void *)&uint8_t buf[4] = v12;
        __int16 v23 = 1024;
        unsigned int v24 = v10;
        _os_log_impl( (void *)&_mh_execute_header,  v11,  OS_LOG_TYPE_DEFAULT,  "We have a stalled incoming SDP request from device %{public}s with cid: %d. Responding to stalled request",  buf,  0x12u);
        if (v27 < 0) {
          operator delete(__p[0]);
        }
      }

      sub_1001E39D0(*(_DWORD *)(a2 + 24) == 0, v10);
      sub_1003D8ABC((uint64_t)v2, 0);
      sub_1003D8B44((uint64_t)v2, 0);
    }

    int v13 = sub_10011268C((uint64_t)(v2 + 128), v21);
    if (v13)
    {
      unint64_t v14 = (os_log_s *)qword_1008F7578;
      if (os_log_type_enabled((os_log_t)qword_1008F7578, OS_LOG_TYPE_DEFAULT))
      {
        LODWORD(__p[0]) = 67109120;
        HIDWORD(__p[0]) = v13;
        _os_log_impl( (void *)&_mh_execute_header,  v14,  OS_LOG_TYPE_DEFAULT,  "Set Remote Device class failed with %{bluetooth:OI_STATUS}u",  (uint8_t *)__p,  8u);
      }
    }

    if (qword_1008D60B0 != -1) {
      dispatch_once(&qword_1008D60B0, &stru_1008978C0);
    }
    sub_1004364F0((uint64_t)off_1008D60A8, (uint64_t)(v2 + 128));
    sub_100242CD0(&v19);
    if (!v20) {
      sub_1003DCDE0((uint64_t)v2, 0LL);
    }
    uint64_t v15 = sub_1002E6BF0();
    if ((*(unsigned int (**)(uint64_t))(*(void *)v15 + 384LL))(v15))
    {
      int v16 = sub_1003CF3A0((uint64_t)v2);
      uint64_t v17 = (os_log_s *)qword_1008F7578;
      if (os_log_type_enabled((os_log_t)qword_1008F7578, OS_LOG_TYPE_DEFAULT))
      {
        LODWORD(__p[0]) = 67109120;
        HIDWORD(__p[0]) = v16;
        _os_log_impl( (void *)&_mh_execute_header,  v17,  OS_LOG_TYPE_DEFAULT,  "Number of services %d found using PSM/RFCOMM",  (uint8_t *)__p,  8u);
      }
    }

    uint64_t v18 = *(void *)(a2 + 16);
    if (v18) {
      (*(void (**)(uint64_t, void, void))(*(void *)v18 + 16LL))( v18,  *(void *)(a2 + 8),  *(unsigned int *)(a2 + 24));
    }
    (*(void (**)(uint64_t))(*(void *)a2 + 8LL))(a2);
    sub_100242CD8(&v19);
  }

  else if (os_log_type_enabled((os_log_t)qword_1008F7578, OS_LOG_TYPE_FAULT))
  {
    sub_10067D398(v3);
  }

void sub_10041A9B8( _Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, __int16 a10, char a11, void *__p, uint64_t a13, int a14, __int16 a15, char a16, char a17, uint64_t a18, void *a19, uint64_t a20, int a21, __int16 a22, char a23, char a24)
{
}

uint64_t sub_10041AA14(uint64_t a1, uint64_t a2, uint64_t a3, char a4, char a5)
{
  unsigned int v10 = (os_log_s *)qword_1008F7578;
  if (os_log_type_enabled((os_log_t)qword_1008F7578, OS_LOG_TYPE_DEFAULT))
  {
    sub_1003CF00C(a2, __p);
    if (v16 >= 0) {
      uint64_t v11 = __p;
    }
    else {
      uint64_t v11 = (void **)__p[0];
    }
    *(_DWORD *)__int128 buf = 136446210;
    uint64_t v18 = v11;
    _os_log_impl((void *)&_mh_execute_header, v10, OS_LOG_TYPE_DEFAULT, "Running SDP on device %{public}s", buf, 0xCu);
    if (v16 < 0) {
      operator delete(__p[0]);
    }
  }

  unint64_t v12 = operator new(0x20uLL);
  *unint64_t v12 = &off_100897800;
  v12[1] = a2;
  void v12[2] = a3;
  *((_BYTE *)v12 + 2sub_100242E28(v1 + 8) = a4;
  *((_BYTE *)v12 + 29) = a5;
  int v13 = operator new(0x18uLL);
  v13[4] = 1;
  *(void *)int v13 = &off_100897828;
  *((void *)v13 + 2) = v12;
  return sub_10041A460(a1, v13);
}

void sub_10041AB60(uint64_t a1, char a2)
{
  uint64_t v3 = operator new(0xA0uLL);
  sub_1004145D0((uint64_t)v3, 0LL);
  if ((a2 & 1) == 0) {
    sub_100418574((uint64_t)v3, 0);
  }
  sub_100414814((uint64_t)v3, 1);
  int v4 = (void *)sub_1004145D4(v3);
  operator delete(v4);
}

void sub_10041ABB4(_Unwind_Exception *a1)
{
}

void sub_10041ABC8()
{
  int v0 = operator new(0xA0uLL);
  sub_1004145D0((uint64_t)v0, 0LL);
  sub_100418574((uint64_t)v0, 1);
  uint64_t v1 = (void *)sub_1004145D4(v0);
  operator delete(v1);
}

void sub_10041AC08(_Unwind_Exception *a1)
{
}

BOOL sub_10041AC1C()
{
  int v0 = operator new(0xA0uLL);
  sub_1004145D0((uint64_t)v0, 0LL);
  BOOL v1 = sub_1004185D8();
  unint64_t v2 = (void *)sub_1004145D4(v0);
  operator delete(v2);
  return v1;
}

void sub_10041AC64(_Unwind_Exception *a1)
{
}

uint64_t sub_10041AC78(uint64_t a1, uint64_t a2)
{
  uint64_t v3 = operator new(0xA0uLL);
  sub_1004145D0((uint64_t)v3, 0LL);
  uint64_t v4 = sub_10041863C((uint64_t)v3, a2);
  unint64_t v5 = (void *)sub_1004145D4(v3);
  operator delete(v5);
  return v4;
}

void sub_10041ACC8(_Unwind_Exception *a1)
{
}

void sub_10041ACDC(uint64_t a1)
{
  if (qword_1008D9600 != -1) {
    dispatch_once(&qword_1008D9600, &stru_1008978E0);
  }
  sub_10041A4C0(a1, *(void *)(a1 + 16));
}

void sub_10041AD24(uint64_t a1)
{
  if (qword_1008D9600 != -1) {
    dispatch_once(&qword_1008D9600, &stru_1008978E0);
  }
  sub_10041A560(a1, *(void *)(a1 + 16));
}

uint64_t sub_10041AD6C(uint64_t a1, uint64_t a2, int a3)
{
  *(_DWORD *)(a1 + 24) = a3;
  if (qword_1008D9600 != -1) {
    dispatch_once(&qword_1008D9600, &stru_1008978E0);
  }
  uint64_t v4 = qword_1008D95F8;
  unint64_t v5 = operator new(0x18uLL);
  v5[4] = 1;
  *(void *)unint64_t v5 = &off_100897860;
  *((void *)v5 + 2) = a1;
  return sub_10041A460(v4, v5);
}

uint64_t sub_10041ADE4(uint64_t a1, uint64_t a2)
{
  uint64_t v4 = operator new(0x18uLL);
  v4[4] = 1;
  *(void *)uint64_t v4 = &off_100897898;
  *((void *)v4 + 2) = a2;
  return sub_10041A460(a1, v4);
}

_BYTE *sub_10041AE2C(uint64_t a1)
{
  char v13 = 0;
  sub_100242CA4(&v13);
  uint64_t v2 = sub_100112610(*(void *)(a1 + 16));
  sub_100242CD0(&v13);
  if (qword_1008D5F50 != -1) {
    dispatch_once(&qword_1008D5F50, &stru_100897900);
  }
  uint64_t v3 = *(int **)(a1 + 16);
  __int16 v4 = *((_WORD *)v3 + 2);
  int v11 = *v3;
  __int16 v12 = v4;
  unint64_t v5 = sub_1003FFEB0(off_1008D5F48, (uint64_t)&v11, 1);
  if (v5)
  {
    if (qword_1008D5F50 != -1) {
      dispatch_once(&qword_1008D5F50, &stru_100897900);
    }
    sub_1004006DC((uint64_t)off_1008D5F48, (uint64_t)v5, v2);
    if (!sub_1003D518C((uint64_t)v5))
    {
      v5[784] = 1;
      if (qword_1008D60D0 != -1) {
        dispatch_once(&qword_1008D60D0, &stru_100897920);
      }
      sub_10042A100((uint64_t)off_1008D60C8, (uint64_t)v5);
      unsigned int v6 = operator new(0x20uLL);
      if (qword_1008D63D8 != -1) {
        dispatch_once(&qword_1008D63D8, &stru_100897940);
      }
      if (off_1008D63D0) {
        unint64_t v7 = (char *)off_1008D63D0 + 16;
      }
      else {
        unint64_t v7 = 0LL;
      }
      void *v6 = &off_100897800;
      v6[1] = v5;
      void v6[2] = v7;
      *((_WORD *)v6 + 14) = 513;
      if (qword_1008D9600 != -1) {
        dispatch_once(&qword_1008D9600, &stru_1008978E0);
      }
      uint64_t v8 = qword_1008D95F8;
      uint64_t v9 = operator new(0x18uLL);
      void v9[4] = 1;
      *(void *)uint64_t v9 = &off_100897828;
      *((void *)v9 + 2) = v6;
      sub_10041A460(v8, v9);
    }
  }

  return sub_100242CD8(&v13);
}

void sub_10041B014( _Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, int a10, __int16 a11, char a12, char a13)
{
}

void sub_10041B054(id a1)
{
  BOOL v1 = operator new(0x230uLL);
  sub_10042BC28();
  off_1008D60A8 = v1;
}

void sub_10041B084(_Unwind_Exception *a1)
{
}

void sub_10041B098(id a1)
{
  BOOL v1 = operator new(0x58uLL);
  *BOOL v1 = off_1008977C0;
  sub_100242DC4(v1 + 1);
  v1[9] = 0LL;
  qword_1008D95F8 = (uint64_t)v1;
}

void sub_10041B0D8(_Unwind_Exception *a1)
{
}

void sub_10041B0EC(id a1)
{
  BOOL v1 = operator new(0x138uLL);
  sub_1003FE3E0((uint64_t)v1);
  off_1008D5F48 = v1;
}

void sub_10041B11C(_Unwind_Exception *a1)
{
}

void sub_10041B130(id a1)
{
  BOOL v1 = operator new(0x2C0uLL);
  sub_1004219F0();
  off_1008D60C8 = v1;
}

void sub_10041B160(_Unwind_Exception *a1)
{
}

void sub_10041B174(id a1)
{
  BOOL v1 = operator new(0x260uLL);
  sub_100451734((uint64_t)v1);
  off_1008D63D0 = v1;
}

void sub_10041B1A4(_Unwind_Exception *a1)
{
}

uint64_t sub_10041B1B8(uint64_t a1)
{
  return a1;
}

uint64_t sub_10041B1E0(uint64_t a1)
{
  return a1;
}

uint64_t sub_10041B208(uint64_t a1)
{
  return a1;
}

void **sub_10041B230(void **a1)
{
  uint64_t v3 = a1;
  sub_10041B698(&v3);
  return a1;
}

uint64_t sub_10041B264(uint64_t a1, int *a2, uint64_t a3)
{
  *(void *)(a1 + sub_100242E28(v1 + 8) = 0LL;
  __int16 v4 = (uint64_t *)(a1 + 8);
  *(void *)(a1 + 16) = 0LL;
  *(void *)a1 = a1 + 8;
  if (a3)
  {
    uint64_t v6 = 8 * a3;
    do
    {
      sub_10041B2E0((uint64_t **)a1, v4, a2, (uint64_t *)a2);
      a2 += 2;
      v6 -= 8LL;
    }

    while (v6);
  }

  return a1;
}

void sub_10041B2C8(_Unwind_Exception *a1)
{
}

uint64_t *sub_10041B2E0(uint64_t **a1, uint64_t *a2, int *a3, uint64_t *a4)
{
  uint64_t v10 = 0LL;
  int v11 = 0LL;
  uint64_t v6 = sub_10041B368(a1, a2, &v11, &v10, a3);
  unint64_t v7 = (uint64_t *)*v6;
  if (!*v6)
  {
    uint64_t v8 = (uint64_t **)v6;
    unint64_t v7 = (uint64_t *)operator new(0x28uLL);
    *(uint64_t *)((char *)v7 + 2sub_100242E28(v1 + 8) = *a4;
    sub_100029630(a1, (uint64_t)v11, v8, v7);
  }

  return v7;
}

uint64_t *sub_10041B368(void *a1, uint64_t *a2, uint64_t **a3, uint64_t *a4, int *a5)
{
  unint64_t v5 = a1 + 1;
  if (a1 + 1 == a2 || (v6 = *a5, int v7 = *((_DWORD *)a2 + 7), *a5 < v7))
  {
    uint64_t v8 = (uint64_t *)*a2;
    if ((uint64_t *)*a1 == a2)
    {
      uint64_t v10 = a2;
LABEL_17:
      if (v8)
      {
        *a3 = v10;
        return v10 + 1;
      }

      else
      {
        *a3 = a2;
        return a2;
      }
    }

    if (v8)
    {
      uint64_t v9 = (uint64_t *)*a2;
      do
      {
        uint64_t v10 = v9;
        uint64_t v9 = (uint64_t *)v9[1];
      }

      while (v9);
    }

    else
    {
      char v13 = a2;
      do
      {
        uint64_t v10 = (uint64_t *)v13[2];
        BOOL v14 = *v10 == (void)v13;
        char v13 = v10;
      }

      while (v14);
    }

    int v15 = *a5;
    if (*((_DWORD *)v10 + 7) < *a5) {
      goto LABEL_17;
    }
    uint64_t v16 = *v5;
    if (*v5)
    {
      do
      {
        while (1)
        {
          uint64_t v17 = (uint64_t *)v16;
          int v18 = *(_DWORD *)(v16 + 28);
          if (v15 >= v18) {
            break;
          }
          uint64_t v16 = *v17;
          unint64_t v5 = v17;
          if (!*v17) {
            goto LABEL_29;
          }
        }

        if (v18 >= v15) {
          break;
        }
        unint64_t v5 = v17 + 1;
        uint64_t v16 = v17[1];
      }

      while (v16);
    }

    else
    {
      uint64_t v17 = a1 + 1;
    }

uint64_t sub_10041B510(uint64_t a1, int *a2, uint64_t a3)
{
  *(void *)(a1 + sub_100242E28(v1 + 8) = 0LL;
  __int16 v4 = (uint64_t *)(a1 + 8);
  *(void *)(a1 + 16) = 0LL;
  *(void *)a1 = a1 + 8;
  if (a3)
  {
    uint64_t v6 = 8 * a3;
    do
    {
      sub_10041B2E0((uint64_t **)a1, v4, a2, (uint64_t *)a2);
      a2 += 2;
      v6 -= 8LL;
    }

    while (v6);
  }

  return a1;
}

void sub_10041B574(_Unwind_Exception *a1)
{
}

uint64_t sub_10041B58C(uint64_t a1, int *a2, uint64_t a3)
{
  *(void *)(a1 + sub_100242E28(v1 + 8) = 0LL;
  __int16 v4 = (uint64_t *)(a1 + 8);
  *(void *)(a1 + 16) = 0LL;
  *(void *)a1 = a1 + 8;
  if (a3)
  {
    uint64_t v6 = 8 * a3;
    do
    {
      sub_10041B2E0((uint64_t **)a1, v4, a2, (uint64_t *)a2);
      a2 += 2;
      v6 -= 8LL;
    }

    while (v6);
  }

  return a1;
}

void sub_10041B5F0(_Unwind_Exception *a1)
{
}

void *sub_10041B608(void *result, uint64_t a2, uint64_t a3)
{
  uint64_t v3 = result;
  uint64_t v4 = result[1];
  if (a2 != a3)
  {
    uint64_t v7 = 0LL;
    do
    {
      uint64_t v8 = a2 + v7;
      *(void *)(v4 + v7) = *(void *)(a2 + v7);
      uint64_t result = sub_100272534((void *)(v4 + v7 + 8), a2 + v7 + 8);
      *(_DWORD *)(v4 + v7 + sub_100242FAC(v1 - 32) = *(_DWORD *)(a2 + v7 + 32);
      v7 += 40LL;
    }

    while (v8 + 40 != a3);
    v4 += v7;
  }

  v3[1] = v4;
  return result;
}

void sub_10041B690(_Unwind_Exception *a1)
{
  *(void *)(v1 + sub_100242E28(v1 + 8) = v2;
  _Unwind_Resume(a1);
}

void sub_10041B698(void ***a1)
{
  uint64_t v2 = *a1;
  if (*v2)
  {
    sub_10041B6D8((uint64_t *)v2);
    operator delete(**a1);
  }

void sub_10041B6D8(uint64_t *a1)
{
  uint64_t v2 = *a1;
  for (uint64_t i = a1[1]; i != v2; i -= 40LL)
  {
    uint64_t v4 = *(void **)(i - 32);
    if (v4)
    {
      *(void *)(i - 24) = v4;
      operator delete(v4);
    }
  }

  a1[1] = v2;
}

void sub_10041B724()
{
  int v0 = objc_autoreleasePoolPush();
  LODWORD(__dst[0]) = 0;
  WORD2(__dst[0]) = 1;
  DWORD2(__dst[0]) = 1;
  WORD6(__dst[0]) = 2;
  sub_10041B264((uint64_t)&unk_1008F7338, (int *)__dst, 2LL);
  __cxa_atexit((void (*)(void *))sub_10041B1B8, &unk_1008F7338, (void *)&_mh_execute_header);
  __dst[0] = xmmword_1006C2D40;
  __dst[1] = unk_1006C2D50;
  *(void *)&__dst[2] = 0x57E00000004LL;
  sub_10041B510((uint64_t)&unk_1008F7350, (int *)__dst, 5LL);
  __cxa_atexit((void (*)(void *))sub_10041B1E0, &unk_1008F7350, (void *)&_mh_execute_header);
  memcpy(__dst, &unk_1006C2D68, sizeof(__dst));
  sub_10041B58C((uint64_t)&unk_1008F7368, (int *)__dst, 42LL);
  __cxa_atexit((void (*)(void *))sub_10041B208, &unk_1008F7368, (void *)&_mh_execute_header);
  memset(__dst, 0, 36);
  *((void *)&__dst[2] + 1) = 0x100000001LL;
  memset(&__dst[3], 0, 28);
  __dst[5] = 0x100000001uLL;
  __dst[6] = 0uLL;
  uint64_t v1 = operator new(0x10uLL);
  *((void *)&__dst[5] + 1) = v1;
  *uint64_t v1 = xmmword_1006C2CE0;
  *(void *)&__dst[6] = v1 + 1;
  *((void *)&__dst[6] + 1) = v1 + 1;
  LODWORD(__dst[7]) = 1;
  *(_OWORD *)((char *)&__dst[7] + sub_100242E28(v1 + 8) = 0u;
  *(_OWORD *)((char *)&__dst[8] + sub_100242E28(v1 + 8) = 0u;
  uint64_t v2 = operator new(0x30uLL);
  *((void *)&__dst[8] + 1) = v2 + 3;
  *(void *)&__dst[9] = v2 + 3;
  *uint64_t v2 = xmmword_1006C2EB8;
  v2[1] = unk_1006C2EC8;
  v2[2] = xmmword_1006C2ED8;
  *(void *)&__dst[8] = v2;
  DWORD2(__dst[9]) = 2;
  memset(&__dst[10], 0, 32);
  uint64_t v3 = operator new(0x38uLL);
  *(void *)&__dst[11] = v3 + 7;
  *((void *)&__dst[11] + 1) = v3 + 7;
  v3[6] = 0x1200000011LL;
  *(_OWORD *)uint64_t v3 = xmmword_1006C2EE8;
  *((_OWORD *)v3 + 1) = unk_1006C2EF8;
  *((_OWORD *)v3 + 2) = xmmword_1006C2F08;
  *((void *)&__dst[10] + 1) = v3;
  LODWORD(__dst[12]) = 3;
  *((void *)&__dst[12] + 1) = 0x100000001LL;
  memset(&__dst[13], 0, 24);
  uint64_t v4 = operator new(0x38uLL);
  *((void *)&__dst[13] + 1) = v4 + 7;
  *(void *)&__dst[14] = v4 + 7;
  v4[6] = 0x1200000011LL;
  *(_OWORD *)uint64_t v4 = xmmword_1006C2EE8;
  *((_OWORD *)v4 + 1) = unk_1006C2EF8;
  *((_OWORD *)v4 + 2) = xmmword_1006C2F08;
  *(void *)&__dst[13] = v4;
  DWORD2(__dst[14]) = 3;
  memset(&__dst[15], 0, 32);
  unint64_t v5 = operator new(0x20uLL);
  *(void *)&__dst[16] = v5 + 2;
  *((void *)&__dst[16] + 1) = v5 + 2;
  *unint64_t v5 = xmmword_1006C2F20;
  v5[1] = unk_1006C2F30;
  *((void *)&__dst[15] + 1) = v5;
  LODWORD(__dst[17]) = 4;
  *((void *)&__dst[17] + 1) = 0x100000001LL;
  memset(&__dst[18], 0, 24);
  uint64_t v6 = operator new(0x20uLL);
  *((void *)&__dst[18] + 1) = v6 + 2;
  *(void *)&__dst[19] = v6 + 2;
  _OWORD *v6 = xmmword_1006C2F20;
  v6[1] = unk_1006C2F30;
  *(void *)&__dst[18] = v6;
  DWORD2(__dst[19]) = 4;
  __dst[20] = 0u;
  __int128 v28 = 0u;
  uint64_t v7 = operator new(0x10uLL);
  *((void *)&__dst[20] + 1) = v7;
  *uint64_t v7 = xmmword_1006C2CF0;
  *(void *)&__int128 v28 = v7 + 1;
  *((void *)&v28 + 1) = v7 + 1;
  int v29 = 5;
  uint64_t v30 = 0x100000001LL;
  __int128 v32 = 0LL;
  uint64_t v33 = 0LL;
  __int128 v31 = 0LL;
  uint64_t v8 = operator new(0x10uLL);
  __int128 v31 = v8;
  *uint64_t v8 = xmmword_1006C2CF0;
  __int128 v32 = v8 + 1;
  uint64_t v33 = v8 + 1;
  int v34 = 5;
  __int128 v35 = 0u;
  __int128 v36 = 0u;
  uint64_t v9 = operator new(0x10uLL);
  *((void *)&v35 + 1) = v9;
  *uint64_t v9 = xmmword_1006C2D00;
  *(void *)&__int128 v36 = v9 + 1;
  *((void *)&v36 + 1) = v9 + 1;
  int v37 = 6;
  uint64_t v38 = 0x100000001LL;
  uint64_t v40 = 0LL;
  int64_t v41 = 0LL;
  uint64_t v39 = 0LL;
  uint64_t v10 = operator new(0x10uLL);
  uint64_t v39 = v10;
  _OWORD *v10 = xmmword_1006C2D00;
  uint64_t v40 = v10 + 1;
  int64_t v41 = v10 + 1;
  int v42 = 6;
  __int128 v43 = 0u;
  __int128 v44 = 0u;
  uint64_t v11 = operator new(0xCuLL);
  *(void *)&__int128 v44 = v11 + 3;
  *((void *)&v44 + 1) = v11 + 3;
  *(void *)uint64_t v11 = 0x1700000016LL;
  void v11[2] = 24;
  *((void *)&v43 + 1) = v11;
  int v45 = 7;
  __int128 v46 = 0u;
  __int128 v47 = 0u;
  __int16 v12 = operator new(8uLL);
  *((void *)&v46 + 1) = v12;
  *__int16 v12 = 0x1800000017LL;
  *((void *)&v47 + 1) = v12 + 1;
  *(void *)&__int128 v47 = v12 + 1;
  int v48 = 8;
  __int128 v49 = 0u;
  __int128 v50 = 0u;
  char v13 = operator new(8uLL);
  *((void *)&v49 + 1) = v13;
  *char v13 = 0x1500000014LL;
  *((void *)&v50 + 1) = v13 + 1;
  *(void *)&__int128 v50 = v13 + 1;
  int v51 = 9;
  uint64_t v52 = 0x200000001LL;
  uint64_t v53 = 0LL;
  uint64_t v55 = 0LL;
  __int128 v54 = 0LL;
  BOOL v14 = operator new(8uLL);
  uint64_t v53 = v14;
  *BOOL v14 = 0x1D0000001CLL;
  uint64_t v55 = v14 + 1;
  __int128 v54 = v14 + 1;
  int v56 = 11;
  uint64_t v57 = 0x200000001LL;
  uint64_t v58 = 0LL;
  __int128 v60 = 0LL;
  uint64_t v59 = 0LL;
  int v15 = operator new(4uLL);
  uint64_t v58 = v15;
  *int v15 = 29;
  __int128 v60 = v15 + 1;
  uint64_t v59 = v15 + 1;
  int v61 = 12;
  uint64_t v62 = 0x200000001LL;
  uint64_t v63 = 0LL;
  uint64_t v65 = 0LL;
  uint64_t v64 = 0LL;
  uint64_t v16 = operator new(4uLL);
  uint64_t v63 = v16;
  _DWORD *v16 = 30;
  uint64_t v65 = v16 + 1;
  uint64_t v64 = v16 + 1;
  int v66 = 13;
  uint64_t v67 = 0x200000001LL;
  char v68 = 0LL;
  uint64_t v70 = 0LL;
  uint64_t v69 = 0LL;
  uint64_t v17 = operator new(4uLL);
  char v68 = v17;
  *uint64_t v17 = 31;
  uint64_t v70 = v17 + 1;
  uint64_t v69 = v17 + 1;
  int v71 = 14;
  uint64_t v72 = 0x200000001LL;
  uint64_t v73 = 0LL;
  uint64_t v75 = 0LL;
  uint64_t v74 = 0LL;
  int v18 = operator new(8uLL);
  uint64_t v73 = v18;
  *int v18 = 0x2100000020LL;
  uint64_t v75 = v18 + 1;
  uint64_t v74 = v18 + 1;
  int v76 = 15;
  uint64_t v77 = 0x200000001LL;
  unint64_t v78 = 0LL;
  uint64_t v80 = 0LL;
  __int128 v79 = 0LL;
  char v19 = operator new(0x18uLL);
  unint64_t v78 = v19;
  uint64_t v80 = (char *)(v19 + 3);
  void v19[2] = 0x2100000020LL;
  *(_OWORD *)char v19 = xmmword_1006C2F40;
  __int128 v79 = (char *)(v19 + 3);
  int v81 = 16;
  uint64_t v82 = 0x300000001LL;
  uint64_t v83 = 0LL;
  __int16 v85 = 0LL;
  uint64_t v84 = 0LL;
  uint64_t v20 = operator new(0x14uLL);
  uint64_t v83 = v20;
  __int16 v85 = (char *)(v20 + 5);
  v20[4] = 38;
  *(_OWORD *)uint64_t v20 = xmmword_1006C2F58;
  uint64_t v84 = (char *)(v20 + 5);
  int v86 = 17;
  uint64_t v87 = 0x300000001LL;
  __int16 v88 = 0LL;
  __int128 v90 = 0LL;
  v89 = 0LL;
  int v21 = operator new(0xCuLL);
  __int16 v88 = v21;
  __int128 v90 = (char *)(v21 + 3);
  *(void *)int v21 = 0x2500000024LL;
  void v21[2] = 38;
  v89 = (char *)(v21 + 3);
  int v91 = 18;
  uint64_t v92 = 0x400000001LL;
  int v93 = 0LL;
  int v95 = 0LL;
  __int16 v94 = 0LL;
  int v22 = operator new(0xCuLL);
  int v93 = v22;
  int v95 = (char *)(v22 + 3);
  *(void *)int v22 = 0x2800000027LL;
  void v22[2] = 41;
  __int16 v94 = (char *)(v22 + 3);
  int v96 = 19;
  uint64_t v97 = 0x300000001LL;
  v98 = 0LL;
  v100 = 0LL;
  __int16 v99 = 0LL;
  __int16 v23 = operator new(8uLL);
  v98 = v23;
  *__int16 v23 = 0x2300000022LL;
  v100 = v23 + 1;
  __int16 v99 = v23 + 1;
  int v101 = 20;
  uint64_t v102 = 0x300000001LL;
  v103 = 0LL;
  v105 = 0LL;
  v104 = 0LL;
  unsigned int v24 = operator new(0xCuLL);
  v103 = v24;
  v105 = (char *)(v24 + 3);
  *(void *)unsigned int v24 = 0x2500000024LL;
  void v24[2] = 38;
  v104 = (char *)(v24 + 3);
  int v106 = 21;
  qword_1008F7388 = 0LL;
  qword_1008F7390 = 0LL;
  qword_1008F7380 = 0LL;
  qword_1008F7380 = (uint64_t)operator new(0x410uLL);
  qword_1008F7388 = qword_1008F7380;
  qword_1008F7390 = qword_1008F7380 + 1040;
  sub_10041B608(&qword_1008F7380, (uint64_t)__dst, (uint64_t)&v107);
  uint64_t v25 = 1040LL;
  do
  {
    int64_t v26 = *(void **)((char *)&__dst[-2] + v25);
    if (v26)
    {
      *(void *)((char *)&__dst[-1] + v25 - sub_100242E28(v1 + 8) = v26;
      operator delete(v26);
    }

    v25 -= 40LL;
  }

  while (v25);
  __cxa_atexit((void (*)(void *))sub_10041B230, &qword_1008F7380, (void *)&_mh_execute_header);
  objc_autoreleasePoolPop(v0);
}

void sub_10041BF18( _Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, char a17)
{
  while (1)
  {
    char v19 = (void *)*((void *)v17 - 4);
    if (v19)
    {
      *((void *)v17 - 3) = v19;
      operator delete(v19);
    }

    v17 -= 40;
    if (v17 == &a17) {
      _Unwind_Resume(exception_object);
    }
  }

void sub_10041BFA0( uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, char a17)
{
  uint64_t v17 = 1040LL;
  while (1)
  {
    int v18 = *(void **)(&a17 + v17 - 32);
    if (v18)
    {
      *(void *)(&a17 + v17 - 24) = v18;
      operator delete(v18);
    }

    v17 -= 40LL;
    if (!v17) {
      JUMPOUT(0x10041BF98LL);
    }
  }

void sub_10041BFCC()
{
}

uint64_t sub_10041BFD4(uint64_t a1, char *a2, int a3)
{
  *(void *)a1 = off_100897970;
  sub_10002418C((void *)(a1 + 8), a2);
  *(_OWORD *)(a1 + 4sub_100414D2C(qword_1008F72C0, 0) = 0u;
  *(_DWORD *)(a1 + sub_100242FAC(v1 - 32) = a3;
  *(_OWORD *)(a1 + 56) = 0u;
  sub_100242DC4(a1 + 72);
  *(_OWORD *)(a1 + 136) = 0u;
  *(_OWORD *)(a1 + 152) = 0u;
  *(_OWORD *)(a1 + 16sub_100242E28(v1 + 8) = 0u;
  sub_100242DC4(a1 + 184);
  *(void *)(a1 + 24sub_100242E28(v1 + 8) = 0LL;
  sub_100242DC4(a1 + 256);
  *(_BYTE *)(a1 + 32sub_100414D2C(qword_1008F72C0, 0) = 0;
  return a1;
}

void sub_10041C06C(_Unwind_Exception *a1)
{
  uint64_t v7 = v4;
  sub_100242E28(v7);
  sub_10041E79C(v5);
  sub_100242E28(v3);
  uint64_t v9 = *v6;
  if (*v6)
  {
    *(void *)(v1 + 4sub_100242E28(v1 + 8) = v9;
    operator delete(v9);
  }

  _Unwind_Resume(a1);
}

uint64_t sub_10041C0C4(uint64_t a1)
{
  *(void *)a1 = off_100897970;
  uint64_t v2 = *(void *)(a1 + 248);
  if (v2)
  {
    uint64_t v3 = (void *)sub_100405360(v2);
    operator delete(v3);
  }

  sub_100242E28(a1 + 256);
  sub_100242E28(a1 + 184);
  sub_10041E79C((void *)(a1 + 136));
  sub_100242E28(a1 + 72);
  uint64_t v4 = *(void **)(a1 + 40);
  if (v4)
  {
    *(void *)(a1 + 4sub_100242E28(v1 + 8) = v4;
    operator delete(v4);
  }

  return a1;
}

uint64_t sub_10041C148(uint64_t a1)
{
  v7[0] = 0LL;
  v7[1] = 0LL;
  sub_100242F28((uint64_t)v7, a1 + 184);
  uint64_t v2 = *(void *)(a1 + 248);
  if (!v2)
  {
    uint64_t v3 = operator new(0x10uLL);
    uint64_t v4 = (uint64_t)v3;
    unint64_t v5 = (void *)(a1 + 8);
    sub_100404F28(v3, (uint64_t)v5);
    *(void *)(a1 + 24sub_100242E28(v1 + 8) = v4;
    sub_100404F30(v4, QOS_CLASS_USER_INITIATED);
    uint64_t v2 = *(void *)(a1 + 248);
  }

  sub_100242FAC((uint64_t)v7);
  return v2;
}

void sub_10041C1C8( _Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9)
{
}

void sub_10041C1EC(uint64_t a1, void *a2)
{
  id v4 = a2;
  uint64_t v3 = sub_10041C148(a1);
  sub_100405384(v3, v4);
}

void sub_10041C22C( _Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, id a10)
{
}

BOOL sub_10041C240(uint64_t a1, _BYTE *a2)
{
  uint64_t v3 = sub_10041C148(a1);
  return sub_100405744(v3, a2);
}

void sub_10041C264(uint64_t a1, uint64_t a2)
{
  id v4 = (os_log_s *)qword_1008F7578;
  if (os_log_type_enabled((os_log_t)qword_1008F7578, OS_LOG_TYPE_DEFAULT))
  {
    unint64_t v5 = sub_10040FC0C(*(_DWORD *)(a2 + 248));
    uint64_t v6 = (void *)(a1 + 8);
    int v22 = 136446466;
    __int16 v23 = v5;
    __int16 v24 = 2082;
    uint64_t v25 = v6;
    _os_log_impl( (void *)&_mh_execute_header,  v4,  OS_LOG_TYPE_DEFAULT,  "Registering %{public}s profile in %{public}s",  (uint8_t *)&v22,  0x16u);
  }

  uint64_t v7 = *(void **)(a1 + 40);
  uint64_t v8 = *(void **)(a1 + 48);
  uint64_t v9 = v7;
  if (v7 != v8)
  {
    while (*v9 != a2)
    {
      if (++v9 == v8)
      {
        uint64_t v9 = *(void **)(a1 + 48);
        break;
      }
    }
  }

  if (v9 == v8)
  {
    unint64_t v10 = *(void *)(a1 + 56);
    if ((unint64_t)v8 >= v10)
    {
      uint64_t v12 = v8 - v7;
      uint64_t v13 = v10 - (void)v7;
      uint64_t v14 = v13 >> 2;
      else {
        unint64_t v15 = v14;
      }
      if (v15) {
        uint64_t v16 = (char *)sub_100008BA0(a1 + 56, v15);
      }
      else {
        uint64_t v16 = 0LL;
      }
      uint64_t v17 = &v16[8 * v12];
      int v18 = &v16[8 * v15];
      *(void *)uint64_t v17 = a2;
      uint64_t v11 = v17 + 8;
      uint64_t v20 = *(char **)(a1 + 40);
      char v19 = *(char **)(a1 + 48);
      if (v19 != v20)
      {
        do
        {
          uint64_t v21 = *((void *)v19 - 1);
          v19 -= 8;
          *((void *)v17 - 1) = v21;
          v17 -= 8;
        }

        while (v19 != v20);
        char v19 = *(char **)(a1 + 40);
      }

      *(void *)(a1 + 4sub_100414D2C(qword_1008F72C0, 0) = v17;
      *(void *)(a1 + 4sub_100242E28(v1 + 8) = v11;
      *(void *)(a1 + 56) = v18;
      if (v19) {
        operator delete(v19);
      }
    }

    else
    {
      *uint64_t v8 = a2;
      uint64_t v11 = v8 + 1;
    }

    *(void *)(a1 + 4sub_100242E28(v1 + 8) = v11;
  }

uint64_t sub_10041C414(uint64_t a1)
{
  if ((*(unsigned int (**)(uint64_t))(*(void *)a1 + 32LL))(a1))
  {
    if (os_log_type_enabled((os_log_t)qword_1008F7578, OS_LOG_TYPE_ERROR)) {
      sub_10067D3D8();
    }
    return 0LL;
  }

  else
  {
    v7[0] = 0LL;
    v7[1] = 0LL;
    sub_100242F28((uint64_t)v7, a1 + 256);
    *(_BYTE *)(a1 + 32sub_100414D2C(qword_1008F72C0, 0) = 1;
    v6[0] = 0LL;
    v6[1] = 0LL;
    sub_100242F28((uint64_t)v6, a1 + 184);
    uint64_t v3 = *(void *)(a1 + 248);
    if (v3) {
      sub_100404F30(v3, QOS_CLASS_USER_INITIATED);
    }
    sub_100242F54((uint64_t)v6);
    for (uint64_t i = *(uint64_t **)(a1 + 40); i != *(uint64_t **)(a1 + 48); ++i)
    {
      uint64_t v2 = sub_10040FA64(*i, a1);
      if ((_DWORD)v2) {
        goto LABEL_12;
      }
    }

    uint64_t v2 = 0LL;
LABEL_12:
    sub_100242FAC((uint64_t)v6);
    sub_100242FAC((uint64_t)v7);
  }

  return v2;
}

void sub_10041C508(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, ...)
{
}

void sub_10041C530(uint64_t a1)
{
  uint64_t v2 = *(void *)(a1 + 64) - 1LL;
  *(void *)(a1 + 64) = v2;
  uint64_t v3 = (os_log_s *)qword_1008F7578;
  BOOL v4 = os_log_type_enabled((os_log_t)qword_1008F7578, OS_LOG_TYPE_DEFAULT);
  if (v2)
  {
    if (v4)
    {
      unint64_t v5 = (void *)(a1 + 8);
      *(_DWORD *)__int128 buf = 136446466;
      *(void *)&uint8_t buf[4] = v5;
      *(_WORD *)&_BYTE buf[12] = 2048;
      *(void *)&buf[14] = v2;
      _os_log_impl( (void *)&_mh_execute_header,  v3,  OS_LOG_TYPE_DEFAULT,  "%{public}s still has %zu profile(s) pending disconnection",  buf,  0x16u);
    }
  }

  else
  {
    if (v4)
    {
      uint64_t v6 = (void *)(a1 + 8);
      *(_DWORD *)__int128 buf = 136446210;
      *(void *)&uint8_t buf[4] = v6;
      _os_log_impl((void *)&_mh_execute_header, v3, OS_LOG_TYPE_DEFAULT, "%{public}s has stopped", buf, 0xCu);
    }

    *(void *)__int128 buf = 0LL;
    *(void *)&uint8_t buf[8] = 0LL;
    sub_100242F28((uint64_t)buf, a1 + 256);
    *(_BYTE *)(a1 + 32sub_100414D2C(qword_1008F72C0, 0) = 0;
    sub_100242F54((uint64_t)buf);
    v8[0] = 0LL;
    v8[1] = 0LL;
    sub_100242F28((uint64_t)v8, a1 + 184);
    uint64_t v7 = *(void *)(a1 + 248);
    if (v7) {
      sub_1004052F8(v7);
    }
    sub_100242F54((uint64_t)v8);
    if (qword_1008D60D0 != -1) {
      dispatch_once(&qword_1008D60D0, &stru_100897AD0);
    }
    sub_10042276C((uint64_t)off_1008D60C8, a1);
    sub_100242FAC((uint64_t)v8);
    sub_100242FAC((uint64_t)buf);
  }

void sub_10041C6D8(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, ...)
{
}

uint64_t sub_10041C708(uint64_t a1)
{
  v24[0] = 0LL;
  v24[1] = 0LL;
  sub_100242F28((uint64_t)v24, a1 + 256);
  uint64_t v2 = (os_log_s *)qword_1008F7578;
  if (*(_BYTE *)(a1 + 320))
  {
    if (os_log_type_enabled((os_log_t)qword_1008F7578, OS_LOG_TYPE_DEFAULT))
    {
      uint64_t v3 = (void *)(a1 + 8);
      *(_DWORD *)__int128 buf = 136446210;
      *(void *)&uint8_t buf[4] = v3;
      _os_log_impl( (void *)&_mh_execute_header,  v2,  OS_LOG_TYPE_DEFAULT,  "Stopping %{public}s and its registered profiles",  buf,  0xCu);
    }

    sub_100242F54((uint64_t)v24);
    v23[0] = 0LL;
    v23[1] = 0LL;
    sub_100242F28((uint64_t)v23, a1 + 72);
    BOOL v4 = *(void ***)(a1 + 144);
    uint64_t v5 = *(void *)(a1 + 152);
    *(void *)(a1 + 176) = 0LL;
    unint64_t v6 = v5 - (void)v4;
    if (v6 >= 0x11)
    {
      do
      {
        operator delete(*v4);
        uint64_t v7 = *(void *)(a1 + 152);
        BOOL v4 = (void **)(*(void *)(a1 + 144) + 8LL);
        *(void *)(a1 + 144) = v4;
        unint64_t v6 = v7 - (void)v4;
      }

      while (v6 > 0x10);
    }

    if (v6 >> 3 == 1)
    {
      uint64_t v8 = 51LL;
    }

    else
    {
      if (v6 >> 3 != 2)
      {
LABEL_16:
        sub_100242F54((uint64_t)v23);
        unint64_t v10 = *(uint64_t **)(a1 + 40);
        uint64_t v11 = *(void *)(a1 + 48) - (void)v10;
        uint64_t v12 = v11 >> 3;
        *(void *)(a1 + 64) = v11 >> 3;
        if (v11)
        {
          do
          {
            int v13 = sub_1004100DC(*v10);
            int v14 = v13;
            if (v13 != 113)
            {
              if (v13)
              {
                unint64_t v15 = (os_log_s *)qword_1008F7578;
                if (os_log_type_enabled((os_log_t)qword_1008F7578, OS_LOG_TYPE_ERROR))
                {
                  uint64_t v16 = a1 + 8;
                  *(_DWORD *)__int128 buf = 136446466;
                  *(void *)&uint8_t buf[4] = v16;
                  *(_WORD *)&_BYTE buf[12] = 1024;
                  *(_DWORD *)&buf[14] = v14;
                  _os_log_error_impl( (void *)&_mh_execute_header,  v15,  OS_LOG_TYPE_ERROR,  "Failed to stop %{public}s with result %d",  buf,  0x12u);
                }
              }

              else
              {
                --*(void *)(a1 + 64);
              }
            }

            ++v10;
          }

          while (v10 != *(uint64_t **)(a1 + 48));
          uint64_t v12 = *(void *)(a1 + 64);
        }

        if (v12)
        {
          uint64_t v17 = (os_log_s *)qword_1008F7578;
          if (os_log_type_enabled((os_log_t)qword_1008F7578, OS_LOG_TYPE_DEFAULT))
          {
            int v18 = (void *)(a1 + 8);
            *(_DWORD *)__int128 buf = 136446466;
            *(void *)&uint8_t buf[4] = v18;
            *(_WORD *)&_BYTE buf[12] = 2048;
            *(void *)&buf[14] = v12;
            _os_log_impl( (void *)&_mh_execute_header,  v17,  OS_LOG_TYPE_DEFAULT,  "%{public}s still has %zu profile(s) pending disconnection - delaying stop",  buf,  0x16u);
          }

          uint64_t v9 = 113LL;
        }

        else
        {
          sub_100242ECC((uint64_t)v24);
          *(_BYTE *)(a1 + 32sub_100414D2C(qword_1008F72C0, 0) = 0;
          sub_100242F54((uint64_t)v24);
          *(void *)__int128 buf = 0LL;
          *(void *)&uint8_t buf[8] = 0LL;
          sub_100242F28((uint64_t)buf, a1 + 184);
          uint64_t v19 = *(void *)(a1 + 248);
          if (v19) {
            sub_1004052F8(v19);
          }
          sub_100242F54((uint64_t)buf);
          uint64_t v20 = (os_log_s *)qword_1008F7578;
          if (os_log_type_enabled((os_log_t)qword_1008F7578, OS_LOG_TYPE_DEFAULT))
          {
            uint64_t v21 = (void *)(a1 + 8);
            *(_DWORD *)uint64_t v25 = 136446210;
            int64_t v26 = v21;
            _os_log_impl((void *)&_mh_execute_header, v20, OS_LOG_TYPE_DEFAULT, "%{public}s has stopped", v25, 0xCu);
          }

          sub_100242FAC((uint64_t)buf);
          uint64_t v9 = 0LL;
        }

        sub_100242FAC((uint64_t)v23);
        goto LABEL_40;
      }

      uint64_t v8 = 102LL;
    }

    *(void *)(a1 + 16sub_100242E28(v1 + 8) = v8;
    goto LABEL_16;
  }

  if (os_log_type_enabled((os_log_t)qword_1008F7578, OS_LOG_TYPE_ERROR)) {
    sub_10067D440();
  }
  uint64_t v9 = 0LL;
LABEL_40:
  sub_100242FAC((uint64_t)v24);
  return v9;
}

void sub_10041CA78(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, ...)
{
  uint64_t v4 = va_arg(va1, void);
  uint64_t v6 = va_arg(va1, void);
  sub_100242FAC((uint64_t)va);
  sub_100242FAC((uint64_t)va1);
  _Unwind_Resume(a1);
}

uint64_t sub_10041CAC0(uint64_t a1)
{
  v4[0] = 0LL;
  v4[1] = 0LL;
  sub_100242F28((uint64_t)v4, a1 + 256);
  uint64_t v2 = *(unsigned __int8 *)(a1 + 320);
  sub_100242FAC((uint64_t)v4);
  return v2;
}

BOOL sub_10041CB04(uint64_t a1, uint64_t a2)
{
  if (!a2)
  {
    uint64_t v4 = (os_log_s *)qword_1008F7578;
    if (os_log_type_enabled((os_log_t)qword_1008F7578, OS_LOG_TYPE_FAULT)) {
      sub_10067D4A8(v4, v5, v6, v7, v8, v9, v10, v11);
    }
  }

  return sub_1003D0070(a2, *(_DWORD *)(a1 + 32)) == 4;
}

uint64_t sub_10041CB6C(uint64_t a1, void *a2)
{
  if (!a2)
  {
    uint64_t v4 = (os_log_s *)qword_1008F7578;
    if (os_log_type_enabled((os_log_t)qword_1008F7578, OS_LOG_TYPE_FAULT)) {
      sub_10067D4A8(v4, v5, v6, v7, v8, v9, v10, v11);
    }
  }

  if (((*(uint64_t (**)(uint64_t))(*(void *)a1 + 32LL))(a1) & 1) != 0)
  {
    if (((*(uint64_t (**)(uint64_t, void *))(*(void *)a1 + 48LL))(a1, a2) & 1) != 0)
    {
      if (((*(uint64_t (**)(uint64_t, void *))(*(void *)a1 + 56LL))(a1, a2) & 1) != 0)
      {
        v45[0] = 0LL;
        v45[1] = 0LL;
        sub_100242F28((uint64_t)v45, a1 + 72);
        uint64_t v12 = *(void *)(a1 + 176);
        if (v12)
        {
          unint64_t v13 = *(void *)(a1 + 168);
          uint64_t v14 = *(void *)(a1 + 144);
          uint64_t v15 = *(void *)(a1 + 152);
          uint64_t v16 = (void ***)(v14 + 8 * (v13 / 0x66));
          if (v15 == v14) {
            uint64_t v17 = 0LL;
          }
          else {
            uint64_t v17 = &(*v16)[5 * (v13 % 0x66)];
          }
          unint64_t v23 = v13 + v12;
          unint64_t v24 = v23 / 0x66;
          unint64_t v25 = v23 % 0x66;
LABEL_26:
          int64_t v26 = v17 - 510;
          while (1)
          {
            uint64_t v27 = v15 == v14 ? 0LL : *(void *)(v14 + 8 * v24) + 40 * v25;
            if (*v17 == a2)
            {
              uint64_t v33 = (os_log_s *)qword_1008F7578;
              if (os_log_type_enabled((os_log_t)qword_1008F7578, OS_LOG_TYPE_INFO))
              {
                int v34 = (void *)(a1 + 8);
                sub_1003CF00C((uint64_t)a2, &__p);
                if (v41 >= 0) {
                  p_p = &__p;
                }
                else {
                  p_p = __p;
                }
                *(_DWORD *)__int128 buf = 136446466;
                __int128 v47 = v34;
                __int16 v48 = 2082;
                __int128 v49 = p_p;
                _os_log_impl( (void *)&_mh_execute_header,  v33,  OS_LOG_TYPE_INFO,  "%{public}s is currently processing another connection for device %{public}s - ignoring duplicate request",  buf,  0x16u);
                if (SHIBYTE(v41) < 0) {
                  operator delete(__p);
                }
              }

              uint64_t v18 = 302LL;
              goto LABEL_54;
            }

            v17 += 5;
            v26 += 5;
            if (*v16 == v26)
            {
              __int128 v28 = v16[1];
              ++v16;
              uint64_t v17 = v28;
              goto LABEL_26;
            }
          }
        }

        int v29 = *(_DWORD *)(a1 + 32);
        std::string __p = a2;
        int v40 = 0;
        uint64_t v41 = 0LL;
        int v42 = v29;
        char v43 = 2;
        uint64_t v44 = mach_continuous_time();
        sub_10041D048((void *)(a1 + 136), (uint64_t)&__p);
        if (*(void *)(a1 + 176) < 2uLL)
        {
          sub_100242F54((uint64_t)v45);
          uint64_t v18 = sub_10041D0FC(a1);
        }

        else
        {
          uint64_t v30 = (os_log_s *)qword_1008F7578;
          if (os_log_type_enabled((os_log_t)qword_1008F7578, OS_LOG_TYPE_DEFAULT))
          {
            __int128 v31 = (void *)(a1 + 8);
            sub_1003CF00C((uint64_t)a2, &__p);
            if (v41 >= 0) {
              __int128 v32 = &__p;
            }
            else {
              __int128 v32 = __p;
            }
            *(_DWORD *)__int128 buf = 136446466;
            __int128 v47 = v31;
            __int16 v48 = 2082;
            __int128 v49 = v32;
            _os_log_impl( (void *)&_mh_execute_header,  v30,  OS_LOG_TYPE_DEFAULT,  "%{public}s is currently processing another connection - queueing connection to device %{public}s",  buf,  0x16u);
            if (SHIBYTE(v41) < 0) {
              operator delete(__p);
            }
          }

          uint64_t v18 = 303LL;
        }

void sub_10041D01C( _Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, ...)
{
}

__n128 sub_10041D048(void *a1, uint64_t a2)
{
  uint64_t v4 = a1[2];
  uint64_t v5 = a1[1];
  uint64_t v6 = 102 * ((v4 - v5) >> 3) - 1;
  if (v4 == v5) {
    uint64_t v6 = 0LL;
  }
  unint64_t v7 = a1[5] + a1[4];
  if (v6 == v7)
  {
    sub_10041E874(a1);
    uint64_t v5 = a1[1];
    unint64_t v7 = a1[5] + a1[4];
  }

  unint64_t v8 = *(void *)(v5 + 8 * (v7 / 0x66)) + 40 * (v7 % 0x66);
  __n128 result = *(__n128 *)a2;
  __int128 v10 = *(_OWORD *)(a2 + 16);
  *(void *)(v8 + sub_100242FAC(v1 - 32) = *(void *)(a2 + 32);
  *(__n128 *)unint64_t v8 = result;
  *(_OWORD *)(v8 + 16) = v10;
  ++a1[5];
  return result;
}

uint64_t sub_10041D0FC(uint64_t a1)
{
  v22[0] = 0LL;
  v22[1] = 0LL;
  sub_100242F28((uint64_t)v22, a1 + 72);
  if (*(void *)(a1 + 176)
    && (unint64_t v2 = *(void *)(a1 + 168),
        uint64_t v3 = *(void *)(*(void *)(a1 + 144) + 8 * (v2 / 0x66)),
        unint64_t v4 = v2 % 0x66,
        !*(_DWORD *)(v3 + 40 * (v2 % 0x66) + 8)))
  {
    uint64_t v7 = *(void *)(v3 + 40 * v4);
    unint64_t v8 = (os_log_s *)qword_1008F7578;
    if (os_log_type_enabled((os_log_t)qword_1008F7578, OS_LOG_TYPE_DEFAULT))
    {
      uint64_t v9 = (void *)(a1 + 8);
      sub_1003CF00C(v7, __p);
      if (v21 >= 0) {
        __int128 v10 = __p;
      }
      else {
        __int128 v10 = (void **)__p[0];
      }
      *(_DWORD *)__int128 buf = 136446466;
      unint64_t v24 = v9;
      __int16 v25 = 2082;
      int64_t v26 = v10;
      _os_log_impl( (void *)&_mh_execute_header,  v8,  OS_LOG_TYPE_DEFAULT,  "%{public}s - handling connection that was pending for device %{public}s",  buf,  0x16u);
      if (v21 < 0) {
        operator delete(__p[0]);
      }
      unint64_t v11 = *(void *)(a1 + 168);
      uint64_t v3 = *(void *)(*(void *)(a1 + 144) + 8 * (v11 / 0x66));
      unint64_t v4 = v11 % 0x66;
    }

    *(_DWORD *)(v3 + 40 * v4 + sub_100242E28(v1 + 8) = 3;
    for (uint64_t i = *(void **)(a1 + 40); i != *(void **)(a1 + 48); ++i)
    {
      uint64_t v13 = *i;
      if ((*(unsigned int (**)(void, uint64_t))(*(void *)*i + 24LL))(*i, v7))
      {
        *(void *)(*(void *)(*(void *)(a1 + 144) + 8 * (*(void *)(a1 + 168) / 0x66uLL))
                  + 40 * (*(void *)(a1 + 168) % 0x66uLL)
                  + 16) = v13;
        sub_100242F54((uint64_t)v22);
        uint64_t v18 = operator new(0x20uLL);
        v18[4] = 1;
        *(void *)uint64_t v18 = &off_100897A70;
        *((void *)v18 + 2) = a1;
        *((void *)v18 + 3) = v7;
        uint64_t v19 = sub_10041C148(a1);
        sub_100405744(v19, v18);
        goto LABEL_3;
      }
    }

    sub_100242F54((uint64_t)v22);
    uint64_t v14 = (os_log_s *)qword_1008F7578;
    if (os_log_type_enabled((os_log_t)qword_1008F7578, OS_LOG_TYPE_DEFAULT))
    {
      uint64_t v15 = (void *)(a1 + 8);
      sub_1003CF00C(v7, __p);
      if (v21 >= 0) {
        uint64_t v16 = __p;
      }
      else {
        uint64_t v16 = (void **)__p[0];
      }
      *(_DWORD *)__int128 buf = 136446466;
      unint64_t v24 = v15;
      __int16 v25 = 2082;
      int64_t v26 = v16;
      _os_log_impl( (void *)&_mh_execute_header,  v14,  OS_LOG_TYPE_DEFAULT,  "%{public}s found no connectable profiles on device %{public}s",  buf,  0x16u);
      if (v21 < 0) {
        operator delete(__p[0]);
      }
    }

    uint64_t v17 = a1 + 136;
    *(int64x2_t *)(a1 + 16sub_100242E28(v1 + 8) = vaddq_s64(*(int64x2_t *)(a1 + 168), (int64x2_t)xmmword_1006BFA70);
    uint64_t v5 = 1LL;
    sub_10041EB88(v17, 1);
  }

  else
  {
LABEL_3:
    uint64_t v5 = 0LL;
  }

  sub_100242FAC((uint64_t)v22);
  return v5;
}

void sub_10041D414(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, ...)
{
}

uint64_t sub_10041D440(uint64_t a1, uint64_t a2)
{
  if (!a2)
  {
    unint64_t v4 = (os_log_s *)qword_1008F7578;
    if (os_log_type_enabled((os_log_t)qword_1008F7578, OS_LOG_TYPE_FAULT)) {
      sub_10067D4A8(v4, v5, v6, v7, v8, v9, v10, v11);
    }
  }

  if (((*(uint64_t (**)(uint64_t))(*(void *)a1 + 32LL))(a1) & 1) == 0
    && os_log_type_enabled((os_log_t)qword_1008F7578, OS_LOG_TYPE_ERROR))
  {
    sub_10067D518();
  }

  v22[0] = 0LL;
  v22[1] = 0LL;
  sub_100242F28((uint64_t)v22, a1 + 72);
  if (*(void *)(a1 + 176)) {
    uint64_t v12 = *(void *)(*(void *)(*(void *)(a1 + 144) + 8 * (*(void *)(a1 + 168) / 0x66uLL))
  }
                    + 40 * (*(void *)(a1 + 168) % 0x66uLL)
                    + 16);
  else {
    uint64_t v12 = 0LL;
  }
  sub_100242F54((uint64_t)v22);
  if (v12)
  {
    unint64_t v13 = sub_100411018(v12);
    if (v13 >= (*(unsigned int (**)(uint64_t))(*(void *)v12 + 16LL))(v12)
      && (uint64_t v14 = sub_100410F64(v12)) != 0
      && ((*(uint64_t (**)(uint64_t, uint64_t))(*(void *)a1 + 120LL))(a1, a2) & 1) == 0)
    {
      sub_100242ECC((uint64_t)v22);
      if (*(void *)(a1 + 176))
      {
        *(_DWORD *)(*(void *)(*(void *)(a1 + 144) + 8 * (*(void *)(a1 + 168) / 0x66uLL))
                  + 40 * (*(void *)(a1 + 168) % 0x66uLL)
                  + sub_100242E28(v1 + 8) = 2;
        sub_100242F54((uint64_t)v22);
        uint64_t v15 = (os_log_s *)qword_1008F7578;
        if (os_log_type_enabled((os_log_t)qword_1008F7578, OS_LOG_TYPE_DEFAULT))
        {
          uint64_t v16 = (void *)(a1 + 8);
          int v17 = (*(uint64_t (**)(uint64_t))(*(void *)v12 + 16LL))(v12);
          sub_1003CF00C(v14, __p);
          if (v21 >= 0) {
            uint64_t v18 = __p;
          }
          else {
            uint64_t v18 = (void **)__p[0];
          }
          *(_DWORD *)__int128 buf = 136446722;
          unint64_t v24 = v16;
          __int16 v25 = 1024;
          int v26 = v17;
          __int16 v27 = 2082;
          __int128 v28 = v18;
          _os_log_impl( (void *)&_mh_execute_header,  v15,  OS_LOG_TYPE_DEFAULT,  "%{public}s connection would exceed maximum allowed connections (%d) - disconnecting device %{public}s",  buf,  0x1Cu);
          if (v21 < 0) {
            operator delete(__p[0]);
          }
        }

        sub_1004105BC(v12, v14);
      }
    }

    else
    {
      sub_10041067C(v12, a2);
    }
  }

  else if (os_log_type_enabled((os_log_t)qword_1008F7578, OS_LOG_TYPE_ERROR))
  {
    sub_10067D580();
  }

  return sub_100242FAC((uint64_t)v22);
}

void sub_10041D718(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, ...)
{
}

BOOL sub_10041D740(uint64_t a1, uint64_t a2)
{
  if (!a2)
  {
    unint64_t v4 = (os_log_s *)qword_1008F7578;
    if (os_log_type_enabled((os_log_t)qword_1008F7578, OS_LOG_TYPE_FAULT)) {
      sub_10067D4A8(v4, v5, v6, v7, v8, v9, v10, v11);
    }
  }

  v19[0] = 0LL;
  v19[1] = 0LL;
  sub_100242F28((uint64_t)v19, a1 + 72);
  uint64_t v12 = *(void *)(a1 + 176);
  if (v12)
  {
    unint64_t v13 = (os_log_s *)qword_1008F7578;
    if (os_log_type_enabled((os_log_t)qword_1008F7578, OS_LOG_TYPE_DEFAULT))
    {
      uint64_t v14 = (void *)(a1 + 8);
      sub_1003CF00C(a2, __p);
      if (v18 >= 0) {
        uint64_t v15 = __p;
      }
      else {
        uint64_t v15 = (void **)__p[0];
      }
      *(_DWORD *)__int128 buf = 136446466;
      char v21 = v14;
      __int16 v22 = 2082;
      unint64_t v23 = v15;
      _os_log_impl( (void *)&_mh_execute_header,  v13,  OS_LOG_TYPE_DEFAULT,  "%{public}s already has a pending outgoing connection to device %{public}s",  buf,  0x16u);
      if (v18 < 0) {
        operator delete(__p[0]);
      }
    }
  }

  else
  {
    sub_100242F54((uint64_t)v19);
  }

  sub_100242FAC((uint64_t)v19);
  return v12 == 0;
}

void sub_10041D8A0(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, ...)
{
}

uint64_t sub_10041D8C0(void *a1, uint64_t a2)
{
  if (!a2)
  {
    unint64_t v4 = (os_log_s *)qword_1008F7578;
    if (os_log_type_enabled((os_log_t)qword_1008F7578, OS_LOG_TYPE_FAULT)) {
      sub_10067D4A8(v4, v5, v6, v7, v8, v9, v10, v11);
    }
  }

  v26[0] = 0LL;
  v26[1] = 0LL;
  sub_100242F28((uint64_t)v26, (uint64_t)(a1 + 9));
  uint64_t v12 = a1[22];
  if (v12)
  {
    unint64_t v13 = a1[21];
    uint64_t v14 = a1[18];
    uint64_t v15 = a1[19];
    uint64_t v16 = (void *)(v14 + 8 * (v13 / 0x66));
    if (v15 == v14) {
      int v17 = 0LL;
    }
    else {
      int v17 = (void *)(*v16 + 40 * (v13 % 0x66));
    }
    unint64_t v18 = v13 + v12;
    unint64_t v19 = v18 / 0x66;
    unint64_t v20 = v18 % 0x66;
LABEL_9:
    char v21 = v17 - 510;
    while (1)
    {
      uint64_t v22 = v15 == v14 ? 0LL : *(void *)(v14 + 8 * v19) + 40 * v20;
      if (v17 == (void *)v22) {
        break;
      }
      if (*v17 == a2)
      {
        uint64_t v24 = 1LL;
        goto LABEL_19;
      }

      v17 += 5;
      v21 += 5;
      if ((void *)*v16 == v21)
      {
        unint64_t v23 = (void *)v16[1];
        ++v16;
        int v17 = v23;
        goto LABEL_9;
      }
    }
  }

  sub_100242F54((uint64_t)v26);
  uint64_t v24 = 0LL;
LABEL_19:
  sub_100242FAC((uint64_t)v26);
  return v24;
}

void sub_10041DA00( _Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9)
{
}

uint64_t sub_10041DA14(uint64_t a1, uint64_t a2)
{
  unint64_t v4 = (os_log_s *)qword_1008F7578;
  if (!a2 && os_log_type_enabled((os_log_t)qword_1008F7578, OS_LOG_TYPE_FAULT))
  {
    LODWORD(__p[0]) = 136446210;
    *(void **)((char *)__p + 4) = "device != NULL";
    _os_log_fault_impl( (void *)&_mh_execute_header,  v4,  OS_LOG_TYPE_FAULT,  "Assertion failed: %{public}s",  (uint8_t *)__p,  0xCu);
    unint64_t v4 = (os_log_s *)qword_1008F7578;
  }

  if (os_log_type_enabled(v4, OS_LOG_TYPE_DEFAULT))
  {
    uint64_t v5 = (void *)(a1 + 8);
    sub_1003CF00C(a2, __p);
    if (v22 >= 0) {
      uint64_t v6 = __p;
    }
    else {
      uint64_t v6 = (void **)__p[0];
    }
    *(_DWORD *)__int128 buf = 136446466;
    uint64_t v24 = v5;
    __int16 v25 = 2082;
    int v26 = v6;
    _os_log_impl( (void *)&_mh_execute_header,  v4,  OS_LOG_TYPE_DEFAULT,  "%{public}s is disconnecting device %{public}s",  buf,  0x16u);
    if (v22 < 0) {
      operator delete(__p[0]);
    }
  }

  if (((*(uint64_t (**)(uint64_t))(*(void *)a1 + 32LL))(a1) & 1) != 0)
  {
    *(_OWORD *)std::string __p = 0uLL;
    sub_100242F28((uint64_t)__p, a1 + 72);
    uint64_t v7 = (int64x2_t *)(a1 + 136);
    unint64_t v8 = *(void *)(a1 + 168);
    uint64_t v9 = *(void *)(a1 + 144);
    uint64_t v10 = *(void *)(a1 + 152);
    uint64_t v11 = (void *)(v9 + 8 * (v8 / 0x66));
    if (v10 == v9) {
      uint64_t v12 = 0LL;
    }
    else {
      uint64_t v12 = *v11 + 40 * (v8 % 0x66);
    }
LABEL_19:
    uint64_t v14 = (void *)v12;
    while (1)
    {
      unint64_t v15 = v10 == v9
          ? 0LL
          : *(void *)(v9 + 8 * ((*(void *)(a1 + 176) + v8) / 0x66)) + 40 * ((*(void *)(a1 + 176) + v8) % 0x66);
      if (v14 == (void *)v15) {
        break;
      }
      if (*v14 == a2)
      {
        unint64_t v19 = (os_log_s *)qword_1008F7578;
        if (os_log_type_enabled((os_log_t)qword_1008F7578, OS_LOG_TYPE_DEFAULT))
        {
          *(_WORD *)__int128 buf = 0;
          _os_log_impl( (void *)&_mh_execute_header,  v19,  OS_LOG_TYPE_DEFAULT,  "Connection was still pending - cancelling",  buf,  2u);
        }

        sub_10041DD44(v7, v11, v12);
        uint64_t v13 = 0LL;
        goto LABEL_36;
      }

      v14 += 5;
      v12 += 40LL;
      if (*v11 + 4080LL == v12)
      {
        uint64_t v16 = v11[1];
        ++v11;
        uint64_t v12 = v16;
        goto LABEL_19;
      }
    }

    sub_100242F54((uint64_t)__p);
    for (uint64_t i = *(uint64_t **)(a1 + 40); ; ++i)
    {
      if (i == *(uint64_t **)(a1 + 48))
      {
        uint64_t v13 = 1LL;
        goto LABEL_36;
      }

      uint64_t v18 = *i;
      if (sub_100410EFC(*i, a2)) {
        break;
      }
    }

    uint64_t v13 = sub_1004105BC(v18, a2);
LABEL_36:
    sub_100242FAC((uint64_t)__p);
  }

  else
  {
    if (os_log_type_enabled((os_log_t)qword_1008F7578, OS_LOG_TYPE_ERROR)) {
      sub_10067D518();
    }
    return 105LL;
  }

  return v13;
}

void sub_10041DD1C( _Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9)
{
}

unint64_t sub_10041DD44(int64x2_t *a1, void *a2, uint64_t a3)
{
  unint64_t v4 = a1[2].u64[0];
  uint64_t v5 = a1->i64[1];
  uint64_t v6 = (uint64_t *)(v5 + 8 * (v4 / 0x66));
  if (a1[1].i64[0] == v5) {
    uint64_t v7 = 0LL;
  }
  else {
    uint64_t v7 = *v6 + 40 * (v4 % 0x66);
  }
  if (a3 == v7) {
    unint64_t v8 = 0LL;
  }
  else {
    unint64_t v8 = 102 * (a2 - v6) - 0x3333333333333333LL * ((a3 - *a2) >> 3) + 0x3333333333333333LL * ((v7 - *v6) >> 3);
  }
  v28.n128_u64[0] = v5 + 8 * (v4 / 0x66);
  v28.n128_u64[1] = v7;
  sub_10041EC58(&v28, v8);
  __n128 v9 = v28;
  uint64_t v10 = a1[2].i64[1];
  int64_t v11 = v28.n128_u64[1] - *(void *)v28.n128_u64[0];
  unint64_t v12 = 0xCCCCCCCCCCCCCCCDLL * (v11 >> 3);
  if (v8 <= (unint64_t)(v10 - 1) >> 1)
  {
    if (v11 < -39)
    {
      uint64_t v16 = (uint64_t *)(v28.n128_u64[0] - 8 * ((100 - v12) / 0x66));
      uint64_t v17 = *v16 + 40 * (102 * ((100 - v12) / 0x66) - (100 - v12)) + 4040;
    }

    else
    {
      uint64_t v16 = (uint64_t *)(v28.n128_u64[0] + 8 * ((v12 + 1) / 0x66));
      uint64_t v17 = *v16 + 40 * ((v12 + 1) % 0x66);
    }

    memset(&v28, 0, 32);
    sub_10041ED04(v6, v7, (uint64_t *)v9.n128_u64[0], v9.n128_i64[1], v16, v17, &v28);
    a1[2] = vaddq_s64(a1[2], (int64x2_t)xmmword_1006BFA70);
    sub_10041EB88((uint64_t)a1, 1);
  }

  else
  {
    if (v11 < -39)
    {
      unint64_t v18 = 100 - v12;
      uint64_t v14 = (__int128 **)(v28.n128_u64[0] - 8 * (v18 / 0x66));
      unint64_t v15 = (__int128 *)((char *)*v14 + 40 * (102 * (v18 / 0x66) - v18) + 4040);
    }

    else
    {
      unint64_t v13 = v12 + 1;
      uint64_t v14 = (__int128 **)(v28.n128_u64[0] + 8 * (v13 / 0x66));
      unint64_t v15 = (__int128 *)((char *)*v14 + 40 * (v13 % 0x66));
    }

    unint64_t v19 = a1[2].i64[0] + v10;
    uint64_t v20 = a1->i64[1];
    char v21 = (__int128 **)(v20 + 8 * (v19 / 0x66));
    if (a1[1].i64[0] == v20) {
      char v22 = 0LL;
    }
    else {
      char v22 = (char *)*v21 + 40 * (v19 % 0x66);
    }
    sub_10041EEB4(v14, v15, v21, v22, (uint64_t)&v28);
    --a1[2].i64[1];
    sub_10041EBE4(a1, 1);
  }

  unint64_t v23 = a1[2].u64[0];
  uint64_t v24 = a1->i64[1];
  __int16 v25 = (void *)(v24 + 8 * (v23 / 0x66));
  if (a1[1].i64[0] == v24) {
    unint64_t v26 = 0LL;
  }
  else {
    unint64_t v26 = *v25 + 40 * (v23 % 0x66);
  }
  v28.n128_u64[0] = (unint64_t)v25;
  v28.n128_u64[1] = v26;
  sub_10041EC58(&v28, v8);
  return v28.n128_u64[0];
}

uint64_t sub_10041E050(void *a1)
{
  if (!(*(unsigned int (**)(void *))(*a1 + 32LL))(a1) || (unint64_t v2 = (void **)a1[5], v2 == (void **)a1[6]))
  {
    LOBYTE(v3) = 0;
  }

  else
  {
    int v3 = 0;
    do
    {
      unint64_t v4 = *v2++;
      v3 |= sub_100410DE0(v4);
    }

    while (v2 != (void **)a1[6]);
  }

  return v3 & 1;
}

uint64_t sub_10041E0B8(void *a1)
{
  if ((*(unsigned int (**)(void *))(*a1 + 32LL))(a1))
  {
    for (uint64_t i = (uint64_t *)a1[5]; i != (uint64_t *)a1[6]; ++i)
    {
      uint64_t v3 = *i;
      if (sub_100410EB0(*i)) {
        return sub_100410F64(v3);
      }
    }
  }

  return 0LL;
}

uint64_t sub_10041E12C(void *a1)
{
  uint64_t result = (*(uint64_t (**)(void *))(*a1 + 32LL))(a1);
  if ((_DWORD)result)
  {
    uint64_t v3 = (uint64_t *)a1[5];
    if (v3 == (uint64_t *)a1[6])
    {
      return 0LL;
    }

    else
    {
      do
      {
        uint64_t result = sub_100410EB0(*v3);
        if ((_DWORD)result) {
          break;
        }
        ++v3;
      }

      while (v3 != (uint64_t *)a1[6]);
    }
  }

  return result;
}

uint64_t sub_10041E188(void *a1, uint64_t a2)
{
  uint64_t result = (*(uint64_t (**)(void *))(*a1 + 32LL))(a1);
  if ((_DWORD)result)
  {
    uint64_t v5 = (uint64_t *)a1[5];
    if (v5 == (uint64_t *)a1[6])
    {
      return 0LL;
    }

    else
    {
      do
      {
        uint64_t result = sub_100410EFC(*v5, a2);
        if ((_DWORD)result) {
          break;
        }
        ++v5;
      }

      while (v5 != (uint64_t *)a1[6]);
    }
  }

  return result;
}

uint64_t sub_10041E1F4(uint64_t a1, uint64_t a2, unsigned int a3, int a4)
{
  if (qword_1008D60D0 != -1) {
    dispatch_once(&qword_1008D60D0, &stru_100897AD0);
  }
  return sub_100424F28((uint64_t)off_1008D60C8, a2, *(unsigned int *)(a1 + 32), a3, a4);
}

uint64_t sub_10041E264(uint64_t a1, uint64_t a2)
{
  if (qword_1008D60D0 != -1) {
    dispatch_once(&qword_1008D60D0, &stru_100897AD0);
  }
  return sub_100425B60((uint64_t)off_1008D60C8, a2, *(unsigned int *)(a1 + 32));
}

uint64_t sub_10041E2D4(uint64_t a1, unsigned __int8 *a2, unsigned int a3, uint64_t a4)
{
  v17[0] = 0LL;
  v17[1] = 0LL;
  sub_100242F28((uint64_t)v17, a1 + 72);
  uint64_t v8 = *(void *)(a1 + 176);
  if (v8)
  {
    unint64_t v9 = *(void *)(a1 + 168);
    if (*(unsigned __int8 **)(*(void *)(*(void *)(a1 + 144) + 8 * (v9 / 0x66)) + 40 * (v9 % 0x66)) == a2)
    {
      *(void *)(a1 + 16sub_100242E28(v1 + 8) = v9 + 1;
      *(void *)(a1 + 176) = v8 - 1;
      sub_10041EB88(a1 + 136, 1);
    }
  }

  sub_100242F54((uint64_t)v17);
  if (qword_1008D60D0 != -1) {
    dispatch_once(&qword_1008D60D0, &stru_100897AD0);
  }
  sub_100423CEC((int64x2_t *)off_1008D60C8, a2, *(unsigned int *)(a1 + 32), a3, a4);
  if (!(_DWORD)a4)
  {
    if ((*(unsigned int (**)(uint64_t))(*(void *)a1 + 72LL))(a1) && (sub_1003CF350(a2) & 1) == 0)
    {
      uint64_t v10 = (os_log_s *)qword_1008F7578;
      if (os_log_type_enabled((os_log_t)qword_1008F7578, OS_LOG_TYPE_ERROR))
      {
        sub_1003CF00C((uint64_t)a2, v16);
        sub_10067D5E8((char *)v16, a1, buf, v10);
      }

      int64_t v11 = operator new(0x20uLL);
      uint8_t v11[4] = 1;
      *(void *)int64_t v11 = &off_100897AA8;
      *((void *)v11 + 2) = a1;
      *((void *)v11 + 3) = a2;
      uint64_t v12 = sub_10041C148(a1);
      sub_100405744(v12, v11);
    }

    unsigned int v13 = *(_DWORD *)(a1 + 32);
    uint64_t v18 = 0LL;
    sub_1000B0400((uint64_t)&v18);
    *(void *)&__int128 v15 = (int)v18;
    *((void *)&v15 + 1) = SWORD2(v18);
    sub_1003D1FC4((uint64_t)a2, v13, 4, &v15, 0);
  }

  sub_10041D0FC(a1);
  return sub_100242FAC((uint64_t)v17);
}

void sub_10041E4CC(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, ...)
{
}

uint64_t sub_10041E4F4(uint64_t a1, unsigned __int8 *a2, unsigned int a3, uint64_t a4, unsigned int a5)
{
  if (qword_1008D60D0 != -1) {
    dispatch_once(&qword_1008D60D0, &stru_100897AD0);
  }
  uint64_t result = sub_100425BE0((uint64_t)off_1008D60C8, a2, *(unsigned int *)(a1 + 32), a3, a4, a5);
  if (!(_DWORD)a4)
  {
    v19[0] = 0LL;
    v19[1] = 0LL;
    sub_100242F28((uint64_t)v19, a1 + 72);
    if (*(void *)(a1 + 176))
    {
      unint64_t v11 = *(void *)(a1 + 168);
      uint64_t v12 = *(void *)(*(void *)(a1 + 144) + 8 * (v11 / 0x66));
      unint64_t v13 = v11 % 0x66;
      if (*(_DWORD *)(v12 + 40 * v13 + 8) == 2)
      {
        uint64_t v14 = *(void *)(v12 + 40 * v13);
        sub_100242F54((uint64_t)v19);
        __int128 v15 = (os_log_s *)qword_1008F7578;
        if (os_log_type_enabled((os_log_t)qword_1008F7578, OS_LOG_TYPE_DEFAULT))
        {
          uint64_t v16 = (void *)(a1 + 8);
          *(_DWORD *)__int128 buf = 136446210;
          char v21 = v16;
          _os_log_impl( (void *)&_mh_execute_header,  v15,  OS_LOG_TYPE_DEFAULT,  "%{public}s had a queued connection pending this disconnection",  buf,  0xCu);
        }

        uint64_t v17 = operator new(0x20uLL);
        void v17[4] = 1;
        *(void *)uint64_t v17 = &off_100897A70;
        *((void *)v17 + 2) = a1;
        *((void *)v17 + 3) = v14;
        uint64_t v18 = sub_10041C148(a1);
        sub_100405744(v18, v17);
      }
    }

    return sub_100242FAC((uint64_t)v19);
  }

  return result;
}

void sub_10041E6B8(_Unwind_Exception *exception_object)
{
}

uint64_t sub_10041E6D4()
{
  return 2LL;
}

uint64_t sub_10041E6DC()
{
  return 2LL;
}

uint64_t sub_10041E6E4(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5)
{
  if (qword_1008D60D0 != -1) {
    dispatch_once(&qword_1008D60D0, &stru_100897AD0);
  }
  return sub_1004267B0((uint64_t)off_1008D60C8, a2, *(unsigned int *)(a1 + 32), a3, a4, a5);
}

void sub_10041E764(uint64_t a1, uint64_t a2, _BYTE *a3)
{
  *a3 = 0;
}

uint64_t sub_10041E774(uint64_t a1)
{
  return sub_10041D440(*(void *)(a1 + 16), *(void *)(a1 + 24));
}

uint64_t sub_10041E788(uint64_t a1)
{
  return (*(uint64_t (**)(void, void))(**(void **)(a1 + 16) + 88LL))( *(void *)(a1 + 16),  *(void *)(a1 + 24));
}

uint64_t sub_10041E79C(void *a1)
{
  unint64_t v2 = (void **)a1[1];
  uint64_t v3 = (void **)a1[2];
  a1[5] = 0LL;
  unint64_t v4 = (char *)v3 - (char *)v2;
  if ((unint64_t)((char *)v3 - (char *)v2) >= 0x11)
  {
    do
    {
      operator delete(*v2);
      uint64_t v3 = (void **)a1[2];
      unint64_t v2 = (void **)(a1[1] + 8LL);
      a1[1] = v2;
      unint64_t v4 = (char *)v3 - (char *)v2;
    }

    while ((unint64_t)((char *)v3 - (char *)v2) > 0x10);
  }

  unint64_t v5 = v4 >> 3;
  if (v5 == 1)
  {
    uint64_t v6 = 51LL;
  }

  else
  {
    if (v5 != 2) {
      goto LABEL_9;
    }
    uint64_t v6 = 102LL;
  }

  a1[4] = v6;
LABEL_9:
  while (v2 != v3)
  {
    uint64_t v7 = *v2++;
    operator delete(v7);
  }

  return sub_10023DF04((uint64_t)a1);
}

void sub_10041E830(id a1)
{
  uint64_t v1 = operator new(0x2C0uLL);
  sub_1004219F0();
  off_1008D60C8 = v1;
}

void sub_10041E860(_Unwind_Exception *a1)
{
}

void sub_10041E874(void *a1)
{
  unint64_t v2 = a1[4];
  BOOL v3 = v2 >= 0x66;
  unint64_t v4 = v2 - 102;
  if (v3)
  {
    uint64_t v5 = (uint64_t)(a1 + 3);
    uint64_t v6 = (char *)a1[3];
    a1[4] = v4;
    uint64_t v7 = (void *)a1[1];
    uint64_t v8 = (char *)a1[2];
    uint64_t v11 = *v7;
    unint64_t v9 = (char *)(v7 + 1);
    uint64_t v10 = v11;
    a1[1] = v9;
    if (v8 != v6)
    {
LABEL_33:
      *(void *)uint64_t v8 = v10;
      a1[2] += 8LL;
      return;
    }

    uint64_t v12 = (uint64_t)&v9[-*a1];
    if ((unint64_t)v9 <= *a1)
    {
      else {
        unint64_t v33 = (uint64_t)&v8[-*a1] >> 2;
      }
      int v34 = (char *)sub_100008BA0(v5, v33);
      __int128 v35 = &v34[8 * (v33 >> 2)];
      int v37 = &v34[8 * v36];
      uint64_t v38 = (uint64_t *)a1[1];
      uint64_t v8 = v35;
      uint64_t v39 = a1[2] - (void)v38;
      if (v39)
      {
        uint64_t v8 = &v35[v39 & 0xFFFFFFFFFFFFFFF8LL];
        uint64_t v40 = 8 * (v39 >> 3);
        uint64_t v41 = &v34[8 * (v33 >> 2)];
        do
        {
          uint64_t v42 = *v38++;
          *(void *)uint64_t v41 = v42;
          v41 += 8;
          v40 -= 8LL;
        }

        while (v40);
      }

      goto LABEL_30;
    }

void sub_10041EB3C( _Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, void *__p, uint64_t a12, uint64_t a13)
{
  if (__p) {
    operator delete(__p);
  }
  _Unwind_Resume(a1);
}

uint64_t sub_10041EB88(uint64_t a1, int a2)
{
  unint64_t v2 = *(void *)(a1 + 32);
  if (v2 < 0x66) {
    a2 = 1;
  }
  if (v2 < 0xCC) {
    int v4 = a2;
  }
  else {
    int v4 = 0;
  }
  if ((v4 & 1) == 0)
  {
    operator delete(**(void ***)(a1 + 8));
    *(void *)(a1 + 8) += 8LL;
    *(void *)(a1 + 32) -= 102LL;
  }

  return v4 ^ 1u;
}

uint64_t sub_10041EBE4(void *a1, int a2)
{
  uint64_t v3 = a1[1];
  uint64_t v2 = a1[2];
  if (v2 == v3) {
    uint64_t v4 = 0LL;
  }
  else {
    uint64_t v4 = 102 * ((v2 - v3) >> 3) - 1;
  }
  unint64_t v5 = v4 - (a1[5] + a1[4]);
  if (v5 < 0x66) {
    a2 = 1;
  }
  if (v5 < 0xCC) {
    int v7 = a2;
  }
  else {
    int v7 = 0;
  }
  if ((v7 & 1) == 0)
  {
    operator delete(*(void **)(v2 - 8));
    a1[2] -= 8LL;
  }

  return v7 ^ 1u;
}

void *sub_10041EC58(void *result, uint64_t a2)
{
  if (a2)
  {
    uint64_t v2 = (void *)*result;
    unint64_t v3 = a2 - 0x3333333333333333LL * ((uint64_t)(result[1] - *(void *)*result) >> 3);
    if ((uint64_t)v3 < 1)
    {
      unint64_t v5 = 101 - v3;
      uint64_t v6 = &v2[-(v5 / 0x66)];
      *uint64_t result = v6;
      unint64_t v4 = *v6 + 40 * (102 * (v5 / 0x66) - v5) + 4040;
    }

    else
    {
      *uint64_t result = &v2[v3 / 0x66];
      unint64_t v4 = v2[v3 / 0x66] + 40 * (v3 % 0x66);
    }

    result[1] = v4;
  }

  return result;
}

__n128 sub_10041ED04@<Q0>( uint64_t *a1@<X1>, uint64_t a2@<X2>, uint64_t *a3@<X3>, uint64_t a4@<X4>, uint64_t *a5@<X5>, uint64_t a6@<X6>, __n128 *a7@<X8>)
{
  if (a1 == a3)
  {
    uint64_t v21 = 0LL;
    __n128 v22 = 0uLL;
    uint64_t v19 = a2;
    uint64_t v18 = a4;
    uint64_t v15 = a5;
    uint64_t v16 = a6;
  }

  else
  {
    uint64_t v13 = a3 - 1;
    uint64_t v12 = *a3;
    uint64_t v21 = 0LL;
    __n128 v22 = 0uLL;
    uint64_t v14 = a4;
    uint64_t v15 = a5;
    uint64_t v16 = a6;
    while (1)
    {
      sub_10041EDF0(v12, v14, v15, v16, &v21);
      uint64_t v16 = v22.n128_i64[1];
      uint64_t v15 = (uint64_t *)v22.n128_u64[0];
      if (v13 == a1) {
        break;
      }
      uint64_t v17 = *v13--;
      uint64_t v12 = v17;
      uint64_t v14 = v17 + 4080;
      uint64_t v21 = 0LL;
      __n128 v22 = 0uLL;
    }

    uint64_t v18 = *a1 + 4080;
    uint64_t v21 = 0LL;
    __n128 v22 = 0uLL;
    uint64_t v19 = a2;
  }

  sub_10041EDF0(v19, v18, v15, v16, &v21);
  __n128 result = v22;
  a7->n128_u64[0] = (unint64_t)a3;
  a7->n128_u64[1] = a4;
  a7[1] = result;
  return result;
}

void sub_10041EDF0(uint64_t a1@<X1>, uint64_t a2@<X2>, uint64_t *a3@<X3>, uint64_t a4@<X4>, void *a5@<X8>)
{
  if (a1 == a2)
  {
    a2 = a1;
  }

  else
  {
    uint64_t v5 = *a3;
    uint64_t v6 = a4;
    uint64_t v7 = a2;
    while (1)
    {
      int64_t v8 = 0xCCCCCCCCCCCCCCCDLL * ((v6 - v5) >> 3);
      if (v8)
      {
        uint64_t v9 = -40 * v8;
        uint64_t v10 = (__int128 *)(v7 - 40);
        do
        {
          a4 = v6 - 40;
          __int128 v11 = *v10;
          __int128 v12 = v10[1];
          *(void *)(v6 - sub_100242E28(v1 + 8) = *((void *)v10 + 4);
          *(_OWORD *)(v6 - 24) = v12;
          *(_OWORD *)(v6 - 4sub_100414D2C(qword_1008F72C0, 0) = v11;
          uint64_t v10 = (__int128 *)((char *)v10 - 40);
          v6 -= 40LL;
          v9 += 40LL;
        }

        while (v9);
      }

      else
      {
        a4 = v6;
      }

      v7 -= 40 * v8;
      if (v7 == a1) {
        break;
      }
      uint64_t v13 = *--a3;
      uint64_t v5 = v13;
      uint64_t v6 = v13 + 4080;
    }

    if (*a3 + 4080 == a4)
    {
      uint64_t v14 = a3[1];
      ++a3;
      a4 = v14;
    }
  }

  *a5 = a2;
  a5[1] = a3;
  a5[2] = a4;
}

double sub_10041EEB4(__int128 **a1, __int128 *a2, __int128 **a3, char *a4, uint64_t a5)
{
  uint64_t v7 = *(uint64_t **)a5;
  uint64_t v8 = *(void *)(a5 + 8);
  if (a1 != a3)
  {
    uint64_t v10 = a1 + 1;
    for (uint64_t i = (char *)(*a1 + 255); ; uint64_t i = (char *)(v12 + 4080))
    {
      uint64_t v14 = 0LL;
      __int128 v15 = 0uLL;
      sub_10041EF54(a2, i, v7, v8, &v14);
      uint64_t v8 = *((void *)&v15 + 1);
      uint64_t v7 = (uint64_t *)v15;
      *(void *)a5 = v15;
      *(void *)(a5 + sub_100242E28(v1 + 8) = v8;
      if (v10 == a3) {
        break;
      }
      uint64_t v12 = (uint64_t)*v10++;
      a2 = (__int128 *)v12;
    }

    a2 = *a3;
  }

  uint64_t v14 = 0LL;
  __int128 v15 = 0uLL;
  sub_10041EF54(a2, a4, v7, v8, &v14);
  double result = *(double *)&v15;
  *(_OWORD *)a5 = v15;
  return result;
}

void sub_10041EF54(__int128 *a1@<X1>, char *a2@<X2>, uint64_t *a3@<X3>, uint64_t a4@<X4>, char **a5@<X8>)
{
  if (a1 == (__int128 *)a2)
  {
    a2 = (char *)a1;
  }

  else
  {
    uint64_t v5 = *a3;
    while (1)
    {
      int64_t v6 = 0xCCCCCCCCCCCCCCCDLL * ((v5 - a4 + 4080) >> 3);
      int64_t v7 = 0xCCCCCCCCCCCCCCCDLL * ((a2 - (char *)a1) >> 3);
      if (v7 >= v6) {
        int64_t v7 = v6;
      }
      if (v7)
      {
        uint64_t v8 = (__int128 *)((char *)a1 + 40 * v7);
        uint64_t v9 = 40 * v7;
        do
        {
          __int128 v10 = *a1;
          __int128 v11 = a1[1];
          *(void *)(a4 + sub_100242FAC(v1 - 32) = *((void *)a1 + 4);
          *(_OWORD *)a4 = v10;
          *(_OWORD *)(a4 + 16) = v11;
          a1 = (__int128 *)((char *)a1 + 40);
          a4 += 40LL;
          v9 -= 40LL;
        }

        while (v9);
        a1 = v8;
      }

      uint64_t v12 = a3[1];
      ++a3;
      uint64_t v5 = v12;
      a4 = v12;
    }

    if (*a3 + 4080 == a4)
    {
      uint64_t v13 = a3[1];
      ++a3;
      a4 = v13;
    }
  }

  *a5 = a2;
  a5[1] = (char *)a3;
  a5[2] = (char *)a4;
}

void sub_10041F000(uint64_t a1@<X8>)
{
  *(void *)(v1 - sub_100242E28(v1 + 8) = a1;
}

uint64_t sub_10041F014(uint64_t a1, uint64_t a2, unsigned int a3, uint64_t a4, int a5)
{
  v20[0] = 0LL;
  v20[1] = 0LL;
  sub_100242F28((uint64_t)v20, a1 + 8);
  __int128 v10 = *(void **)(a1 + 80);
  __int128 v11 = (void *)(a1 + 88);
  if (v10 != (void *)(a1 + 88))
  {
    uint64_t v12 = a5;
    do
    {
      uint64_t v13 = v10[4];
      if (v13)
      {
        if (*(_BYTE *)(*(void *)(v13 + 64) + 160LL))
        {
          xpc_object_t v14 = xpc_dictionary_create(0LL, 0LL, 0LL);
          __int128 v15 = v14;
          if (v14)
          {
            xpc_dictionary_set_uint64(v14, "kCBMsgArgID", *(void *)(v13 + 48));
            xpc_dictionary_set_uint64(v15, "kCBMsgArgPairingAgentID", a2);
            xpc_dictionary_set_uint64(v15, "kCBMsgArgResult", v12);
            xpc_dictionary_set_uint64(v15, "kCBMsgArgEvent", a3);
            xpc_dictionary_set_uint64(v15, "kCBMsgArgBTDevice", a4);
            sub_100260FEC(*(void *)(v13 + 64), "kCBMsgIdPairingAgentStatusEvent", v15, 1);
          }
        }
      }

      uint64_t v16 = (void *)v10[1];
      if (v16)
      {
        do
        {
          uint64_t v17 = v16;
          uint64_t v16 = (void *)*v16;
        }

        while (v16);
      }

      else
      {
        do
        {
          uint64_t v17 = (void *)v10[2];
          BOOL v18 = *v17 == (void)v10;
          __int128 v10 = v17;
        }

        while (!v18);
      }

      __int128 v10 = v17;
    }

    while (v17 != v11);
  }

  return sub_100242FAC((uint64_t)v20);
}

void sub_10041F180( _Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9)
{
}

uint64_t sub_10041F194(uint64_t a1, uint64_t a2, uint64_t a3, unsigned int a4)
{
  v17[0] = 0LL;
  v17[1] = 0LL;
  sub_100242F28((uint64_t)v17, a1 + 8);
  uint64_t v8 = *(void **)(a1 + 80);
  uint64_t v9 = (void *)(a1 + 88);
  if (v8 != (void *)(a1 + 88))
  {
    do
    {
      uint64_t v10 = v8[4];
      if (v10)
      {
        if (*(_BYTE *)(*(void *)(v10 + 64) + 160LL))
        {
          xpc_object_t v11 = xpc_dictionary_create(0LL, 0LL, 0LL);
          uint64_t v12 = v11;
          if (v11)
          {
            xpc_dictionary_set_uint64(v11, "kCBMsgArgID", *(void *)(v10 + 48));
            xpc_dictionary_set_uint64(v12, "kCBMsgArgPairingAgentID", a2);
            xpc_dictionary_set_uint64(v12, "kCBMsgArgBTDevice", a3);
            xpc_dictionary_set_uint64(v12, "kCBMsgArgMinLength", a4);
            sub_100260FEC(*(void *)(v10 + 64), "kCBMsgIdPairingAgentPincode", v12, 1);
          }
        }
      }

      uint64_t v13 = (void *)v8[1];
      if (v13)
      {
        do
        {
          xpc_object_t v14 = v13;
          uint64_t v13 = (void *)*v13;
        }

        while (v13);
      }

      else
      {
        do
        {
          xpc_object_t v14 = (void *)v8[2];
          BOOL v15 = *v14 == (void)v8;
          uint64_t v8 = v14;
        }

        while (!v15);
      }

      uint64_t v8 = v14;
    }

    while (v14 != v9);
  }

  return sub_100242FAC((uint64_t)v17);
}

void sub_10041F2E8( _Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9)
{
}

uint64_t sub_10041F2FC(uint64_t a1, uint64_t a2, uint64_t a3, unsigned int a4)
{
  v17[0] = 0LL;
  v17[1] = 0LL;
  sub_100242F28((uint64_t)v17, a1 + 8);
  uint64_t v8 = *(void **)(a1 + 80);
  uint64_t v9 = (void *)(a1 + 88);
  if (v8 != (void *)(a1 + 88))
  {
    do
    {
      uint64_t v10 = v8[4];
      if (v10)
      {
        if (*(_BYTE *)(*(void *)(v10 + 64) + 160LL))
        {
          xpc_object_t v11 = xpc_dictionary_create(0LL, 0LL, 0LL);
          uint64_t v12 = v11;
          if (v11)
          {
            xpc_dictionary_set_uint64(v11, "kCBMsgArgID", *(void *)(v10 + 48));
            xpc_dictionary_set_uint64(v12, "kCBMsgArgPairingAgentID", a2);
            xpc_dictionary_set_uint64(v12, "kCBMsgArgBTDevice", a3);
            xpc_dictionary_set_uint64(v12, "kCBMsgArgServices", a4);
            sub_100260FEC(*(void *)(v10 + 64), "kCBMsgIdPairingAgentAuthorization", v12, 1);
          }
        }
      }

      uint64_t v13 = (void *)v8[1];
      if (v13)
      {
        do
        {
          xpc_object_t v14 = v13;
          uint64_t v13 = (void *)*v13;
        }

        while (v13);
      }

      else
      {
        do
        {
          xpc_object_t v14 = (void *)v8[2];
          BOOL v15 = *v14 == (void)v8;
          uint64_t v8 = v14;
        }

        while (!v15);
      }

      uint64_t v8 = v14;
    }

    while (v14 != v9);
  }

  return sub_100242FAC((uint64_t)v17);
}

void sub_10041F450( _Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9)
{
}

uint64_t sub_10041F464(uint64_t a1, uint64_t a2, uint64_t a3, unsigned int a4, unsigned int a5)
{
  v20[0] = 0LL;
  v20[1] = 0LL;
  sub_100242F28((uint64_t)v20, a1 + 8);
  uint64_t v10 = *(void **)(a1 + 80);
  xpc_object_t v11 = (void *)(a1 + 88);
  if (v10 != (void *)(a1 + 88))
  {
    uint64_t v12 = a5;
    do
    {
      uint64_t v13 = v10[4];
      if (v13)
      {
        if (*(_BYTE *)(*(void *)(v13 + 64) + 160LL))
        {
          xpc_object_t v14 = xpc_dictionary_create(0LL, 0LL, 0LL);
          BOOL v15 = v14;
          if (v14)
          {
            xpc_dictionary_set_uint64(v14, "kCBMsgArgID", *(void *)(v13 + 48));
            xpc_dictionary_set_uint64(v15, "kCBMsgArgPairingAgentID", a2);
            xpc_dictionary_set_uint64(v15, "kCBMsgArgBTDevice", a3);
            xpc_dictionary_set_uint64(v15, "kCBMsgArgValue", a4);
            xpc_dictionary_set_uint64(v15, "kCBMsgArgMITM", v12);
            sub_100260FEC(*(void *)(v13 + 64), "kCBMsgIdPairingAgentUserConfirmation", v15, 1);
          }
        }
      }

      uint64_t v16 = (void *)v10[1];
      if (v16)
      {
        do
        {
          uint64_t v17 = v16;
          uint64_t v16 = (void *)*v16;
        }

        while (v16);
      }

      else
      {
        do
        {
          uint64_t v17 = (void *)v10[2];
          BOOL v18 = *v17 == (void)v10;
          uint64_t v10 = v17;
        }

        while (!v18);
      }

      uint64_t v10 = v17;
    }

    while (v17 != v11);
  }

  return sub_100242FAC((uint64_t)v20);
}

void sub_10041F5D0( _Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9)
{
}

uint64_t sub_10041F5E4(uint64_t a1, uint64_t a2, uint64_t a3, unsigned int a4)
{
  v17[0] = 0LL;
  v17[1] = 0LL;
  sub_100242F28((uint64_t)v17, a1 + 8);
  uint64_t v8 = *(void **)(a1 + 80);
  uint64_t v9 = (void *)(a1 + 88);
  if (v8 != (void *)(a1 + 88))
  {
    do
    {
      uint64_t v10 = v8[4];
      if (v10)
      {
        if (*(_BYTE *)(*(void *)(v10 + 64) + 160LL))
        {
          xpc_object_t v11 = xpc_dictionary_create(0LL, 0LL, 0LL);
          uint64_t v12 = v11;
          if (v11)
          {
            xpc_dictionary_set_uint64(v11, "kCBMsgArgID", *(void *)(v10 + 48));
            xpc_dictionary_set_uint64(v12, "kCBMsgArgPairingAgentID", a2);
            xpc_dictionary_set_uint64(v12, "kCBMsgArgBTDevice", a3);
            xpc_dictionary_set_uint64(v12, "kCBMsgArgValue", a4);
            sub_100260FEC(*(void *)(v10 + 64), "kCBMsgIdPairingAgentPassKeyDisplay", v12, 1);
          }
        }
      }

      uint64_t v13 = (void *)v8[1];
      if (v13)
      {
        do
        {
          xpc_object_t v14 = v13;
          uint64_t v13 = (void *)*v13;
        }

        while (v13);
      }

      else
      {
        do
        {
          xpc_object_t v14 = (void *)v8[2];
          BOOL v15 = *v14 == (void)v8;
          uint64_t v8 = v14;
        }

        while (!v15);
      }

      uint64_t v8 = v14;
    }

    while (v14 != v9);
  }

  return sub_100242FAC((uint64_t)v17);
}

void sub_10041F738( _Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9)
{
}

uint64_t sub_10041F74C( uint64_t a1, uint64_t a2, const void *a3, const void *a4, const void *a5, const void *a6)
{
  v21[0] = 0LL;
  v21[1] = 0LL;
  sub_100242F28((uint64_t)v21, a1 + 8);
  uint64_t v12 = *(void **)(a1 + 80);
  uint64_t v13 = (void *)(a1 + 88);
  if (v12 != (void *)(a1 + 88))
  {
    do
    {
      uint64_t v14 = v12[4];
      if (v14)
      {
        if (*(_BYTE *)(*(void *)(v14 + 64) + 160LL))
        {
          xpc_object_t v15 = xpc_dictionary_create(0LL, 0LL, 0LL);
          uint64_t v16 = v15;
          if (v15)
          {
            xpc_dictionary_set_uint64(v15, "kCBMsgArgID", *(void *)(v14 + 48));
            xpc_dictionary_set_uint64(v16, "kCBMsgArgPairingAgentID", a2);
            if (a3) {
              xpc_dictionary_set_data(v16, "kCBMsgArgC192", a3, 0x10uLL);
            }
            if (a4) {
              xpc_dictionary_set_data(v16, "kCBMsgArgR192", a4, 0x10uLL);
            }
            if (a5) {
              xpc_dictionary_set_data(v16, "kCBMsgArgC256", a5, 0x10uLL);
            }
            if (a6) {
              xpc_dictionary_set_data(v16, "kCBMsgArgR256", a6, 0x10uLL);
            }
            sub_100260FEC(*(void *)(v14 + 64), "kCBMsgIdPairingAgentOOBDataReady", v16, 1);
          }
        }
      }

      uint64_t v17 = (void *)v12[1];
      if (v17)
      {
        do
        {
          BOOL v18 = v17;
          uint64_t v17 = (void *)*v17;
        }

        while (v17);
      }

      else
      {
        do
        {
          BOOL v18 = (void *)v12[2];
          BOOL v19 = *v18 == (void)v12;
          uint64_t v12 = v18;
        }

        while (!v19);
      }

      uint64_t v12 = v18;
    }

    while (v18 != v13);
  }

  return sub_100242FAC((uint64_t)v21);
}

void sub_10041F8E4( _Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9)
{
}

uint64_t sub_10041F8F8(uint64_t result, unsigned int a2, uint64_t a3, int a4, uint64_t a5)
{
  if (a5) {
    return sub_10041F014(a5, result, a2, a3, a4);
  }
  return result;
}

uint64_t sub_10041F91C(uint64_t result, uint64_t a2, unsigned int a3, uint64_t a4)
{
  if (a4) {
    return sub_10041F194(a4, result, a2, a3);
  }
  return result;
}

uint64_t sub_10041F93C(uint64_t result, uint64_t a2, unsigned int a3, uint64_t a4)
{
  if (a4) {
    return sub_10041F2FC(a4, result, a2, a3);
  }
  return result;
}

uint64_t sub_10041F95C(uint64_t result, uint64_t a2, unsigned int a3, unsigned int a4, uint64_t a5)
{
  if (a5) {
    return sub_10041F464(a5, result, a2, a3, a4);
  }
  return result;
}

uint64_t sub_10041F980(uint64_t result, uint64_t a2, unsigned int a3, uint64_t a4)
{
  if (a4) {
    return sub_10041F5E4(a4, result, a2, a3);
  }
  return result;
}

uint64_t sub_10041F9A0( uint64_t result, const void *a2, const void *a3, const void *a4, const void *a5, uint64_t a6)
{
  if (a6) {
    return sub_10041F74C(a6, result, a2, a3, a4, a5);
  }
  return result;
}

void *sub_10041F9C8(void *a1, uint64_t a2)
{
  unint64_t v3 = sub_10043C910(a1, a2);
  *unint64_t v3 = &off_100897B00;
  v3[12] = 0LL;
  v3[11] = 0LL;
  v3[10] = v3 + 11;
  if (qword_1008F0AF8 != -1) {
    dispatch_once(&qword_1008F0AF8, &stru_100897B20);
  }
  return a1;
}

void sub_10041FA30(id a1)
{
  uint64_t v13 = "kCBMsgIdPairingAgentCreateMsg";
  uint64_t v14 = 29LL;
  xpc_object_t v15 = &v13;
  uint64_t v1 = sub_100420D4C((uint64_t)&xmmword_1008F7398, (uint64_t)&v13, (uint64_t)&unk_1006C2518, (_OWORD **)&v15);
  v1[4] = sub_10041FD08;
  void v1[5] = 0LL;
  uint64_t v13 = "kCBMsgIdPairingAgentDestroyMsg";
  uint64_t v14 = 30LL;
  xpc_object_t v15 = &v13;
  uint64_t v2 = sub_100420D4C((uint64_t)&xmmword_1008F7398, (uint64_t)&v13, (uint64_t)&unk_1006C2518, (_OWORD **)&v15);
  v2[4] = sub_10041FF38;
  v2[5] = 0LL;
  uint64_t v13 = "kCBMsgIdPairingAgentStartMsg";
  uint64_t v14 = 28LL;
  xpc_object_t v15 = &v13;
  unint64_t v3 = sub_100420D4C((uint64_t)&xmmword_1008F7398, (uint64_t)&v13, (uint64_t)&unk_1006C2518, (_OWORD **)&v15);
  void v3[4] = sub_100420164;
  void v3[5] = 0LL;
  uint64_t v13 = "kCBMsgIdPairingAgentStopMsg";
  uint64_t v14 = 27LL;
  xpc_object_t v15 = &v13;
  unint64_t v4 = sub_100420D4C((uint64_t)&xmmword_1008F7398, (uint64_t)&v13, (uint64_t)&unk_1006C2518, (_OWORD **)&v15);
  v4[4] = sub_100420228;
  void v4[5] = 0LL;
  uint64_t v13 = "kCBMsgIdPairingAgentCancelPairingMsg";
  uint64_t v14 = 36LL;
  xpc_object_t v15 = &v13;
  uint64_t v5 = sub_100420D4C((uint64_t)&xmmword_1008F7398, (uint64_t)&v13, (uint64_t)&unk_1006C2518, (_OWORD **)&v15);
  v5[4] = sub_1004202EC;
  void v5[5] = 0LL;
  uint64_t v13 = "kCBMsgIdPairingAgentSetPincodeMsg";
  uint64_t v14 = 33LL;
  xpc_object_t v15 = &v13;
  int64_t v6 = sub_100420D4C((uint64_t)&xmmword_1008F7398, (uint64_t)&v13, (uint64_t)&unk_1006C2518, (_OWORD **)&v15);
  v6[4] = sub_1004203B0;
  _OWORD v6[5] = 0LL;
  uint64_t v13 = "kCBMsgIdPairingAgentAcceptSSPMsg";
  uint64_t v14 = 32LL;
  xpc_object_t v15 = &v13;
  int64_t v7 = sub_100420D4C((uint64_t)&xmmword_1008F7398, (uint64_t)&v13, (uint64_t)&unk_1006C2518, (_OWORD **)&v15);
  void v7[4] = sub_1004204B0;
  void v7[5] = 0LL;
  uint64_t v13 = "kCBMsgIdPairingAgentDeletePairedDeviceMsg";
  uint64_t v14 = 41LL;
  xpc_object_t v15 = &v13;
  uint64_t v8 = sub_100420D4C((uint64_t)&xmmword_1008F7398, (uint64_t)&v13, (uint64_t)&unk_1006C2518, (_OWORD **)&v15);
  v8[4] = sub_1004205B0;
  v8[5] = 0LL;
  uint64_t v13 = "kCBMsgIdPairingAgentSetIOCapabilityMsg";
  uint64_t v14 = 38LL;
  xpc_object_t v15 = &v13;
  uint64_t v9 = sub_100420D4C((uint64_t)&xmmword_1008F7398, (uint64_t)&v13, (uint64_t)&unk_1006C2518, (_OWORD **)&v15);
  void v9[4] = sub_100420698;
  void v9[5] = 0LL;
  uint64_t v13 = "kCBMsgIdPairingAgentClearOOBDataForDeviceMsg";
  uint64_t v14 = 44LL;
  xpc_object_t v15 = &v13;
  uint64_t v10 = sub_100420D4C((uint64_t)&xmmword_1008F7398, (uint64_t)&v13, (uint64_t)&unk_1006C2518, (_OWORD **)&v15);
  v10[4] = sub_100420780;
  void v10[5] = 0LL;
  uint64_t v13 = "kCBMsgIdPairingAgentSetOOBDataForDeviceMsg";
  uint64_t v14 = 42LL;
  xpc_object_t v15 = &v13;
  xpc_object_t v11 = sub_100420D4C((uint64_t)&xmmword_1008F7398, (uint64_t)&v13, (uint64_t)&unk_1006C2518, (_OWORD **)&v15);
  uint8_t v11[4] = sub_100420868;
  void v11[5] = 0LL;
  uint64_t v13 = "kCBMsgIdPairingAgentGetLocalOOBDataMsg";
  uint64_t v14 = 38LL;
  xpc_object_t v15 = &v13;
  uint64_t v12 = sub_100420D4C((uint64_t)&xmmword_1008F7398, (uint64_t)&v13, (uint64_t)&unk_1006C2518, (_OWORD **)&v15);
  void v12[4] = sub_100420AF4;
  void v12[5] = 0LL;
}

uint64_t sub_10041FD08(uint64_t a1, xpc_object_t xdict)
{
  uint64_t value = 0LL;
  xpc_object_t v4 = xpc_dictionary_get_value(xdict, "kCBMsgArgs");
  uint64_t uint64 = xpc_dictionary_get_uint64(v4, "kCBMsgArgSessionID");
  uint64_t v6 = xpc_dictionary_get_uint64(v4, "kCBMsgArgID");
  if (os_log_type_enabled((os_log_t)qword_1008F75F0, OS_LOG_TYPE_DEBUG)) {
    sub_10067D678();
  }
  v15[0] = 0LL;
  v15[1] = 0LL;
  sub_100242F28((uint64_t)v15, a1 + 8);
  if (uint64)
  {
    uint64_t v7 = *(void *)(a1 + 72);
    int v8 = *(_DWORD *)(v7 + 40);
    au_asid_t asid = xpc_connection_get_asid(*(xpc_connection_t *)(v7 + 16));
    if (qword_1008D61A8 != -1) {
      dispatch_once(&qword_1008D61A8, &stru_100897B40);
    }
    if (sub_100497B94(qword_1008D61A0, uint64, v8, asid))
    {
      uint64_t v10 = calloc(1uLL, 0x48uLL);
      uint64_t v14 = v10;
      void *v10 = sub_10041F8F8;
      v10[1] = sub_10041F91C;
      void v10[2] = sub_10041F93C;
      uint64_t v10[3] = sub_10041F95C;
      void v10[5] = sub_10041F9A0;
      v10[6] = v6;
      v10[4] = sub_10041F980;
      v10[8] = *(void *)(a1 + 72);
      LODWORD(uint64) = sub_100524424(uint64, v10, a1, &value);
      if ((_DWORD)uint64)
      {
        free(v10);
      }

      else
      {
        v10[7] = value;
        sub_1002555B0((uint64_t **)(a1 + 80), (unint64_t *)&v14, (uint64_t *)&v14);
      }

      uint64_t uint64 = (int)uint64;
    }

    else
    {
      uint64_t uint64 = 7LL;
    }
  }

  else
  {
    uint64_t uint64 = 1LL;
  }

  xpc_object_t reply = xpc_dictionary_create_reply(xdict);
  uint64_t v12 = reply;
  if (reply)
  {
    xpc_dictionary_set_uint64(reply, "kCBMsgArgPairingAgentID", value);
    xpc_dictionary_set_uint64(v12, "kCBMsgArgResult", uint64);
    xpc_connection_send_message(*(xpc_connection_t *)(*(void *)(a1 + 72) + 16LL), v12);
    xpc_release(v12);
  }

  return sub_100242FAC((uint64_t)v15);
}

void sub_10041FF1C(_Unwind_Exception *a1, uint64_t a2, ...)
{
}

void sub_10041FF38(void *a1, xpc_object_t xdict)
{
  xpc_object_t value = xpc_dictionary_get_value(xdict, "kCBMsgArgs");
  uint64_t uint64 = xpc_dictionary_get_uint64(value, "kCBMsgArgPairingAgentID");
  uint64_t v6 = (os_log_s *)qword_1008F75F0;
  if (os_log_type_enabled((os_log_t)qword_1008F75F0, OS_LOG_TYPE_DEBUG)) {
    sub_10067D6D8(uint64, v6, v7, v8, v9, v10, v11, v12);
  }
  if (uint64)
  {
    v22[1] = 0LL;
    uint64_t v23 = uint64;
    v22[0] = 0LL;
    sub_100242F28((uint64_t)v22, (uint64_t)(a1 + 1));
    uint64_t v13 = (void *)a1[10];
    if (v13 != a1 + 11)
    {
      int v14 = 0;
      while (1)
      {
        uint64_t v21 = (void *)v13[4];
        if (v23 == *((void *)v21 + 7))
        {
          int v14 = sub_1005244C0(&v23);
          if (!v14)
          {
            sub_10020166C((uint64_t)(a1 + 10), (unint64_t *)&v21);
            free(v21);
            break;
          }

          xpc_object_t v15 = (os_log_s *)qword_1008F75F0;
          if (os_log_type_enabled((os_log_t)qword_1008F75F0, OS_LOG_TYPE_ERROR))
          {
            *(_DWORD *)__int128 buf = 134217984;
            uint64_t v25 = uint64;
            _os_log_error_impl( (void *)&_mh_execute_header,  v15,  OS_LOG_TYPE_ERROR,  "Could not destroy pairing agent %llx",  buf,  0xCu);
          }
        }

        uint64_t v16 = (void *)v13[1];
        if (v16)
        {
          do
          {
            uint64_t v17 = v16;
            uint64_t v16 = (void *)*v16;
          }

          while (v16);
        }

        else
        {
          do
          {
            uint64_t v17 = (void *)v13[2];
            BOOL v18 = *v17 == (void)v13;
            uint64_t v13 = v17;
          }

          while (!v18);
        }

        uint64_t v13 = v17;
        if (v17 == a1 + 11) {
          goto LABEL_20;
        }
      }
    }

    int v14 = 0;
LABEL_20:
    sub_100242FAC((uint64_t)v22);
  }

  else
  {
    int v14 = 0;
  }

  xpc_object_t reply = xpc_dictionary_create_reply(xdict);
  int64_t v20 = reply;
  if (reply)
  {
    xpc_dictionary_set_uint64(reply, "kCBMsgArgResult", v14);
    xpc_connection_send_message(*(xpc_connection_t *)(a1[9] + 16LL), v20);
    xpc_release(v20);
  }

void sub_100420144(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, ...)
{
}

void sub_100420164(uint64_t a1, xpc_object_t xdict)
{
  xpc_object_t value = xpc_dictionary_get_value(xdict, "kCBMsgArgs");
  uint64_t uint64 = xpc_dictionary_get_uint64(value, "kCBMsgArgPairingAgentID");
  if (os_log_type_enabled((os_log_t)qword_1008F75F0, OS_LOG_TYPE_DEBUG))
  {
    sub_10067D740();
  }

  else if (uint64)
  {
LABEL_3:
    uint64_t v6 = (int)sub_10052451C(uint64);
    goto LABEL_6;
  }

  uint64_t v6 = 1LL;
LABEL_6:
  xpc_object_t reply = xpc_dictionary_create_reply(xdict);
  if (reply)
  {
    uint64_t v8 = reply;
    xpc_dictionary_set_uint64(reply, "kCBMsgArgResult", v6);
    xpc_connection_send_message(*(xpc_connection_t *)(*(void *)(a1 + 72) + 16LL), v8);
    xpc_release(v8);
  }

void sub_100420228(uint64_t a1, xpc_object_t xdict)
{
  xpc_object_t value = xpc_dictionary_get_value(xdict, "kCBMsgArgs");
  uint64_t uint64 = xpc_dictionary_get_uint64(value, "kCBMsgArgPairingAgentID");
  if (os_log_type_enabled((os_log_t)qword_1008F75F0, OS_LOG_TYPE_DEBUG))
  {
    sub_10067D7A0();
  }

  else if (uint64)
  {
LABEL_3:
    uint64_t v6 = (int)sub_100524588(uint64);
    goto LABEL_6;
  }

  uint64_t v6 = 1LL;
LABEL_6:
  xpc_object_t reply = xpc_dictionary_create_reply(xdict);
  if (reply)
  {
    uint64_t v8 = reply;
    xpc_dictionary_set_uint64(reply, "kCBMsgArgResult", v6);
    xpc_connection_send_message(*(xpc_connection_t *)(*(void *)(a1 + 72) + 16LL), v8);
    xpc_release(v8);
  }

void sub_1004202EC(uint64_t a1, xpc_object_t xdict)
{
  xpc_object_t value = xpc_dictionary_get_value(xdict, "kCBMsgArgs");
  uint64_t uint64 = xpc_dictionary_get_uint64(value, "kCBMsgArgPairingAgentID");
  if (os_log_type_enabled((os_log_t)qword_1008F75F0, OS_LOG_TYPE_DEBUG))
  {
    sub_10067D800();
  }

  else if (uint64)
  {
LABEL_3:
    uint64_t v6 = (int)sub_1005245F4(uint64);
    goto LABEL_6;
  }

  uint64_t v6 = 1LL;
LABEL_6:
  xpc_object_t reply = xpc_dictionary_create_reply(xdict);
  if (reply)
  {
    uint64_t v8 = reply;
    xpc_dictionary_set_uint64(reply, "kCBMsgArgResult", v6);
    xpc_connection_send_message(*(xpc_connection_t *)(*(void *)(a1 + 72) + 16LL), v8);
    xpc_release(v8);
  }

void sub_1004203B0(uint64_t a1, xpc_object_t xdict)
{
  xpc_object_t value = xpc_dictionary_get_value(xdict, "kCBMsgArgs");
  uint64_t uint64 = xpc_dictionary_get_uint64(value, "kCBMsgArgPairingAgentID");
  uint64_t v6 = xpc_dictionary_get_uint64(value, "kCBMsgArgBTDevice");
  string = (char *)xpc_dictionary_get_string(value, "kCBMsgIdPairingAgentPincode");
  if (os_log_type_enabled((os_log_t)qword_1008F75F0, OS_LOG_TYPE_DEBUG))
  {
    sub_10067D860();
  }

  else if (uint64)
  {
LABEL_3:
    uint64_t v8 = (int)sub_10052465C(uint64, v6, string);
    goto LABEL_6;
  }

  uint64_t v8 = 1LL;
LABEL_6:
  xpc_object_t reply = xpc_dictionary_create_reply(xdict);
  if (reply)
  {
    uint64_t v10 = reply;
    xpc_dictionary_set_uint64(reply, "kCBMsgArgResult", v8);
    xpc_connection_send_message(*(xpc_connection_t *)(*(void *)(a1 + 72) + 16LL), v10);
    xpc_release(v10);
  }

void sub_1004204B0(uint64_t a1, xpc_object_t xdict)
{
  xpc_object_t value = xpc_dictionary_get_value(xdict, "kCBMsgArgs");
  uint64_t uint64 = xpc_dictionary_get_uint64(value, "kCBMsgArgPairingAgentID");
  uint64_t v6 = xpc_dictionary_get_uint64(value, "kCBMsgArgBTDevice");
  int v7 = xpc_dictionary_get_uint64(value, "kCBMsgArgError");
  if (os_log_type_enabled((os_log_t)qword_1008F75F0, OS_LOG_TYPE_DEBUG))
  {
    sub_10067D8C0();
  }

  else if (uint64)
  {
LABEL_3:
    uint64_t v8 = (int)sub_1005247A4(uint64, v6, v7);
    goto LABEL_6;
  }

  uint64_t v8 = 1LL;
LABEL_6:
  xpc_object_t reply = xpc_dictionary_create_reply(xdict);
  if (reply)
  {
    uint64_t v10 = reply;
    xpc_dictionary_set_uint64(reply, "kCBMsgArgResult", v8);
    xpc_connection_send_message(*(xpc_connection_t *)(*(void *)(a1 + 72) + 16LL), v10);
    xpc_release(v10);
  }

void sub_1004205B0(uint64_t a1, xpc_object_t xdict)
{
  xpc_object_t value = xpc_dictionary_get_value(xdict, "kCBMsgArgs");
  uint64_t uint64 = xpc_dictionary_get_uint64(value, "kCBMsgArgPairingAgentID");
  uint64_t v6 = xpc_dictionary_get_uint64(value, "kCBMsgArgBTDevice");
  if (os_log_type_enabled((os_log_t)qword_1008F75F0, OS_LOG_TYPE_DEBUG))
  {
    sub_10067D920();
  }

  else if (uint64)
  {
LABEL_3:
    uint64_t v7 = (int)sub_10052486C(uint64, v6);
    goto LABEL_6;
  }

  uint64_t v7 = 1LL;
LABEL_6:
  xpc_object_t reply = xpc_dictionary_create_reply(xdict);
  if (reply)
  {
    uint64_t v9 = reply;
    xpc_dictionary_set_uint64(reply, "kCBMsgArgResult", v7);
    xpc_connection_send_message(*(xpc_connection_t *)(*(void *)(a1 + 72) + 16LL), v9);
    xpc_release(v9);
  }

void sub_100420698(uint64_t a1, xpc_object_t xdict)
{
  xpc_object_t value = xpc_dictionary_get_value(xdict, "kCBMsgArgs");
  uint64_t uint64 = xpc_dictionary_get_uint64(value, "kCBMsgArgPairingAgentID");
  int v6 = xpc_dictionary_get_uint64(value, "kCBMsgArgIOCapabilities");
  if (os_log_type_enabled((os_log_t)qword_1008F75F0, OS_LOG_TYPE_DEBUG))
  {
    sub_10067D980();
  }

  else if (uint64)
  {
LABEL_3:
    uint64_t v7 = (int)sub_100524C70(uint64, v6);
    goto LABEL_6;
  }

  uint64_t v7 = 1LL;
LABEL_6:
  xpc_object_t reply = xpc_dictionary_create_reply(xdict);
  if (reply)
  {
    uint64_t v9 = reply;
    xpc_dictionary_set_uint64(reply, "kCBMsgArgResult", v7);
    xpc_connection_send_message(*(xpc_connection_t *)(*(void *)(a1 + 72) + 16LL), v9);
    xpc_release(v9);
  }

void sub_100420780(uint64_t a1, xpc_object_t xdict)
{
  xpc_object_t value = xpc_dictionary_get_value(xdict, "kCBMsgArgs");
  uint64_t uint64 = xpc_dictionary_get_uint64(value, "kCBMsgArgPairingAgentID");
  uint64_t v6 = xpc_dictionary_get_uint64(value, "kCBMsgArgBTDevice");
  if (os_log_type_enabled((os_log_t)qword_1008F75F0, OS_LOG_TYPE_DEBUG))
  {
    sub_10067D9E0();
  }

  else if (uint64)
  {
LABEL_3:
    uint64_t v7 = (int)sub_100524D20(uint64, v6);
    goto LABEL_6;
  }

  uint64_t v7 = 1LL;
LABEL_6:
  xpc_object_t reply = xpc_dictionary_create_reply(xdict);
  if (reply)
  {
    uint64_t v9 = reply;
    xpc_dictionary_set_uint64(reply, "kCBMsgArgResult", v7);
    xpc_connection_send_message(*(xpc_connection_t *)(*(void *)(a1 + 72) + 16LL), v9);
    xpc_release(v9);
  }

void sub_100420868(uint64_t a1, xpc_object_t xdict)
{
  xpc_object_t value = xpc_dictionary_get_value(xdict, "kCBMsgArgs");
  uint64_t uint64 = xpc_dictionary_get_uint64(value, "kCBMsgArgPairingAgentID");
  uint64_t v6 = xpc_dictionary_get_uint64(value, "kCBMsgArgBTDevice");
  size_t length = 0LL;
  int data = xpc_dictionary_get_data(value, "kCBMsgArgC192", &length);
  if (length == 16)
  {
    unsigned int v8 = 0;
  }

  else
  {
    if (os_log_type_enabled((os_log_t)qword_1008F75F0, OS_LOG_TYPE_FAULT)) {
      sub_10067DB24();
    }
    unsigned int v8 = 3;
  }

  size_t v19 = 0LL;
  uint64_t v9 = (__n128 *)xpc_dictionary_get_data(value, "kCBMsgArgR192", &v19);
  if (v19 != 16)
  {
    if (os_log_type_enabled((os_log_t)qword_1008F75F0, OS_LOG_TYPE_FAULT)) {
      sub_10067DAF8();
    }
    unsigned int v8 = 3;
  }

  size_t v18 = 0LL;
  uint64_t v10 = xpc_dictionary_get_data(value, "kCBMsgArgC256", &v18);
  if (v18 != 16)
  {
    if (os_log_type_enabled((os_log_t)qword_1008F75F0, OS_LOG_TYPE_FAULT)) {
      sub_10067DACC();
    }
    unsigned int v8 = 3;
  }

  size_t v17 = 0LL;
  uint64_t v11 = xpc_dictionary_get_data(value, "kCBMsgArgR256", &v17);
  if (v17 != 16)
  {
    if (os_log_type_enabled((os_log_t)qword_1008F75F0, OS_LOG_TYPE_FAULT)) {
      sub_10067DAA0();
    }
    unsigned int v8 = 3;
    goto LABEL_22;
  }

  if (v8)
  {
LABEL_22:
    xpc_object_t reply = xpc_dictionary_create_reply(xdict);
    if (!reply) {
      return;
    }
    xpc_object_t v15 = reply;
    uint64_t v16 = v8;
    goto LABEL_24;
  }

  uint64_t v12 = (uint64_t)v11;
  if (os_log_type_enabled((os_log_t)qword_1008F75F0, OS_LOG_TYPE_DEBUG))
  {
    sub_10067DA40();
  }

  else if (uint64)
  {
LABEL_18:
    uint64_t v13 = (int)sub_100524E04(uint64, v6, (uint64_t)data, v9, (uint64_t)v10, v12);
    goto LABEL_28;
  }

  uint64_t v13 = 1LL;
LABEL_28:
  xpc_object_t reply = xpc_dictionary_create_reply(xdict);
  if (reply)
  {
    xpc_object_t v15 = reply;
    uint64_t v16 = v13;
LABEL_24:
    xpc_dictionary_set_uint64(reply, "kCBMsgArgResult", v16);
    xpc_connection_send_message(*(xpc_connection_t *)(*(void *)(a1 + 72) + 16LL), v15);
    xpc_release(v15);
  }

void sub_100420AF4(uint64_t a1, xpc_object_t xdict)
{
  xpc_object_t value = xpc_dictionary_get_value(xdict, "kCBMsgArgs");
  uint64_t uint64 = xpc_dictionary_get_uint64(value, "kCBMsgArgPairingAgentID");
  if (os_log_type_enabled((os_log_t)qword_1008F75F0, OS_LOG_TYPE_DEBUG))
  {
    sub_10067DB50();
  }

  else if (uint64)
  {
LABEL_3:
    uint64_t v6 = (int)sub_10052500C(uint64);
    goto LABEL_6;
  }

  uint64_t v6 = 1LL;
LABEL_6:
  xpc_object_t reply = xpc_dictionary_create_reply(xdict);
  if (reply)
  {
    unsigned int v8 = reply;
    xpc_dictionary_set_uint64(reply, "kCBMsgArgResult", v6);
    xpc_connection_send_message(*(xpc_connection_t *)(*(void *)(a1 + 72) + 16LL), v8);
    xpc_release(v8);
  }

void sub_100420BC0(void *a1)
{
  uint64_t v1 = sub_100352334(a1);
  operator delete(v1);
}

BOOL sub_100420BD4(uint64_t a1, xpc_object_t xdict)
{
  string = xpc_dictionary_get_string(xdict, "kCBMsgId");
  uint64_t v11 = string;
  size_t v12 = strlen(string);
  uint64_t v5 = sub_100331854(&xmmword_1008F7398, (uint64_t)&v11);
  if (v5)
  {
    uint64_t v11 = string;
    size_t v12 = strlen(string);
    uint64_t v13 = &v11;
    uint64_t v6 = sub_100420D4C((uint64_t)&xmmword_1008F7398, (uint64_t)&v11, (uint64_t)&unk_1006C2518, (_OWORD **)&v13);
    uint64_t v7 = (void (*)(void *, xpc_object_t))v6[4];
    uint64_t v8 = v6[5];
    uint64_t v9 = (void *)(a1 + (v8 >> 1));
    if ((v8 & 1) != 0) {
      uint64_t v7 = *(void (**)(void *, xpc_object_t))(*v9 + v7);
    }
    v7(v9, xdict);
  }

  return v5 != 0LL;
}

uint64_t sub_100420CA0(void *a1)
{
  v8[0] = 0LL;
  v8[1] = 0LL;
  sub_100242F28((uint64_t)v8, (uint64_t)(a1 + 1));
  uint64_t v2 = (void *)a1[10];
  unint64_t v3 = a1 + 11;
  if (v2 != a1 + 11)
  {
    do
    {
      free((void *)v2[4]);
      xpc_object_t v4 = (void *)v2[1];
      if (v4)
      {
        do
        {
          uint64_t v5 = v4;
          xpc_object_t v4 = (void *)*v4;
        }

        while (v4);
      }

      else
      {
        do
        {
          uint64_t v5 = (void *)v2[2];
          BOOL v6 = *v5 == (void)v2;
          uint64_t v2 = v5;
        }

        while (!v6);
      }

      uint64_t v2 = v5;
    }

    while (v5 != v3);
  }

  sub_10023BF24((uint64_t)(a1 + 10), (void *)a1[11]);
  a1[11] = 0LL;
  a1[12] = 0LL;
  a1[10] = v3;
  return sub_100242FAC((uint64_t)v8);
}

void *sub_100420D4C(uint64_t a1, uint64_t a2, uint64_t a3, _OWORD **a4)
{
  unint64_t v7 = sub_1003313A4((uint64_t)&v29, *(uint64_t **)a2, *(void *)(a2 + 8));
  unint64_t v8 = v7;
  unint64_t v9 = *(void *)(a1 + 8);
  if (v9)
  {
    uint8x8_t v10 = (uint8x8_t)vcnt_s8((int8x8_t)v9);
    v10.i16[0] = vaddlv_u8(v10);
    unint64_t v11 = v10.u32[0];
    if (v10.u32[0] > 1uLL)
    {
      unint64_t v12 = v7;
      if (v7 >= v9) {
        unint64_t v12 = v7 % v9;
      }
    }

    else
    {
      unint64_t v12 = (v9 - 1) & v7;
    }

    uint64_t v13 = *(void ***)(*(void *)a1 + 8 * v12);
    if (v13)
    {
      int v14 = *v13;
      if (*v13)
      {
        uint64_t v17 = a2;
        xpc_object_t v15 = *(uint64_t **)a2;
        size_t v16 = *(void *)(v17 + 8);
        do
        {
          unint64_t v18 = *((void *)v14 + 1);
          if (v18 == v8)
          {
          }

          else
          {
            if (v11 > 1)
            {
              if (v18 >= v9) {
                v18 %= v9;
              }
            }

            else
            {
              v18 &= v9 - 1;
            }

            if (v18 != v12) {
              break;
            }
          }

          int v14 = *(void **)v14;
        }

        while (v14);
      }
    }
  }

  else
  {
    unint64_t v12 = 0LL;
  }

  int v14 = operator new(0x30uLL);
  *(void *)int v14 = 0LL;
  *((void *)v14 + 1) = v8;
  *((_OWORD *)v14 + 1) = **a4;
  *((void *)v14 + 4) = 0LL;
  *((void *)v14 + 5) = 0LL;
  float v19 = (float)(unint64_t)(*(void *)(a1 + 24) + 1LL);
  float v20 = *(float *)(a1 + 32);
  if (!v9 || (float)(v20 * (float)v9) < v19)
  {
    BOOL v21 = 1LL;
    if (v9 >= 3) {
      BOOL v21 = (v9 & (v9 - 1)) != 0;
    }
    unint64_t v22 = v21 | (2 * v9);
    unint64_t v23 = vcvtps_u32_f32(v19 / v20);
    if (v22 <= v23) {
      size_t v24 = v23;
    }
    else {
      size_t v24 = v22;
    }
    sub_10005141C(a1, v24);
    unint64_t v9 = *(void *)(a1 + 8);
    if ((v9 & (v9 - 1)) != 0)
    {
      if (v8 >= v9) {
        unint64_t v12 = v8 % v9;
      }
      else {
        unint64_t v12 = v8;
      }
    }

    else
    {
      unint64_t v12 = (v9 - 1) & v8;
    }
  }

  uint64_t v25 = *(void *)a1;
  uint64_t v26 = *(void **)(*(void *)a1 + 8 * v12);
  if (v26)
  {
    *(void *)int v14 = *v26;
LABEL_40:
    void *v26 = v14;
    goto LABEL_41;
  }

  *(void *)int v14 = *(void *)(a1 + 16);
  *(void *)(a1 + 16) = v14;
  *(void *)(v25 + 8 * v12) = a1 + 16;
  if (*(void *)v14)
  {
    unint64_t v27 = *(void *)(*(void *)v14 + 8LL);
    if ((v9 & (v9 - 1)) != 0)
    {
      if (v27 >= v9) {
        v27 %= v9;
      }
    }

    else
    {
      v27 &= v9 - 1;
    }

    uint64_t v26 = (void *)(*(void *)a1 + 8 * v27);
    goto LABEL_40;
  }

void sub_100420FA0(_Unwind_Exception *a1)
{
}

void sub_100420FB4(id a1)
{
  uint64_t v1 = operator new(0x120uLL);
  sub_100495250();
  qword_1008D61A0 = (uint64_t)v1;
}

void sub_100420FE4(_Unwind_Exception *a1)
{
}

void sub_100420FF8()
{
  int v0 = objc_autoreleasePoolPush();
  xmmword_1008F7398 = 0u;
  unk_1008F73A8 = 0u;
  dword_1008F73B8 = 1065353216;
  __cxa_atexit((void (*)(void *))sub_10041F010, &xmmword_1008F7398, (void *)&_mh_execute_header);
  objc_autoreleasePoolPop(v0);
}

uint64_t sub_100421048(uint64_t a1)
{
  return a1;
}

uint64_t sub_100421070(uint64_t a1)
{
  *(void *)a1 = off_100897B70;
  *(void *)(a1 + sub_100242E28(v1 + 8) = off_100897BE0;
  *(void *)(a1 + 16) = off_100897C10;
  *(void *)(a1 + 24) = off_100897C40;
  *(void *)(a1 + sub_100242FAC(v1 - 32) = &off_100897C60;
  sub_100242DC4(a1 + 40);
  *(_WORD *)(a1 + 112) = 0;
  *(_BYTE *)(a1 + 114) = 0;
  sub_100242DC4(a1 + 120);
  uint64_t v2 = a1 + 184;
  *(void *)(a1 + 184) = a1 + 184;
  *(void *)(a1 + 192) = a1 + 184;
  *(void *)(a1 + 20sub_100414D2C(qword_1008F72C0, 0) = 0LL;
  sub_100242DC4(a1 + 208);
  *(_OWORD *)(a1 + 28sub_100242E28(v1 + 8) = 0u;
  *(_OWORD *)(a1 + 304) = 0u;
  *(_OWORD *)(a1 + 272) = 0u;
  sub_100242DC4(a1 + 320);
  *(void *)(a1 + 384) = 0LL;
  *(void *)(a1 + 392) = 0LL;
  *(void *)(a1 + 40sub_100414D2C(qword_1008F72C0, 0) = 0LL;
  sub_100242DC4(a1 + 408);
  *(void *)(a1 + 472) = 0LL;
  *(void *)(a1 + 48sub_100414D2C(qword_1008F72C0, 0) = 0LL;
  *(void *)(a1 + 48sub_100242E28(v1 + 8) = 0LL;
  sub_100242DC4(a1 + 496);
  sub_100243040((pthread_cond_t *)(a1 + 560));
  *(void *)(a1 + 60sub_100242E28(v1 + 8) = a1 + 608;
  *(void *)(a1 + 616) = a1 + 608;
  *(void *)(a1 + 624) = 0LL;
  sub_100242DC4(a1 + 632);
  *(_WORD *)(a1 + 70sub_100414D2C(qword_1008F72C0, 0) = 0;
  *(_DWORD *)(a1 + 696) = 0;
  char v50 = 0;
  uint64_t v3 = sub_1002E6E00();
  if ((*(unsigned int (**)(uint64_t))(*(void *)v3 + 8LL))(v3))
  {
    uint64_t v4 = sub_1002E6E00();
    sub_10002418C(v48, "WiAP");
    sub_10002418C(__p, "enableSink");
    (*(void (**)(uint64_t, void **, void **, char *))(*(void *)v4 + 72LL))(v4, v48, __p, &v50);
    if (v47 < 0) {
      operator delete(__p[0]);
    }
    if (v49 < 0) {
      operator delete(v48[0]);
    }
  }

  uint64_t v5 = sub_1002E6BF0();
  v48[0] = 0LL;
  v48[1] = 0LL;
  sub_100242F28((uint64_t)v48, a1 + 120);
  if ((*(unsigned int (**)(uint64_t, uint64_t))(*(void *)v5 + 48LL))(v5, 1LL))
  {
    BOOL v6 = (os_log_s *)qword_1008F7578;
    if (os_log_type_enabled((os_log_t)qword_1008F7578, OS_LOG_TYPE_DEFAULT))
    {
      LOWORD(__p[0]) = 0;
      _os_log_impl( (void *)&_mh_execute_header,  v6,  OS_LOG_TYPE_DEFAULT,  "Supporting service handsfree",  (uint8_t *)__p,  2u);
    }

    if (qword_1008D9890 != -1) {
      dispatch_once(&qword_1008D9890, &stru_100897CF8);
    }
    uint64_t v7 = qword_1008D9888;
    unint64_t v8 = operator new(0x18uLL);
    v8[1] = v2;
    void v8[2] = v7;
    uint64_t v9 = *(void *)(a1 + 184);
    *unint64_t v8 = v9;
    *(void *)(v9 + sub_100242E28(v1 + 8) = v8;
    *(void *)(a1 + 184) = v8;
    ++*(void *)(a1 + 200);
  }

  if ((*(unsigned int (**)(uint64_t, uint64_t))(*(void *)v5 + 48LL))(v5, 32LL))
  {
    uint8x8_t v10 = (os_log_s *)qword_1008F7578;
    if (os_log_type_enabled((os_log_t)qword_1008F7578, OS_LOG_TYPE_DEFAULT))
    {
      LOWORD(__p[0]) = 0;
      _os_log_impl((void *)&_mh_execute_header, v10, OS_LOG_TYPE_DEFAULT, "Supporting service HID", (uint8_t *)__p, 2u);
    }

    if (qword_1008D9730 != -1) {
      dispatch_once(&qword_1008D9730, &stru_100897D18);
    }
    unint64_t v11 = off_1008D9728;
    unint64_t v12 = operator new(0x18uLL);
    v12[1] = v2;
    void v12[2] = v11;
    uint64_t v13 = *(void *)(a1 + 184);
    *unint64_t v12 = v13;
    *(void *)(v13 + sub_100242E28(v1 + 8) = v12;
    *(void *)(a1 + 184) = v12;
    ++*(void *)(a1 + 200);
  }

  if ((*(unsigned int (**)(uint64_t, uint64_t))(*(void *)v5 + 48LL))(v5, 16LL))
  {
    int v14 = (os_log_s *)qword_1008F7578;
    if (os_log_type_enabled((os_log_t)qword_1008F7578, OS_LOG_TYPE_DEFAULT))
    {
      LOWORD(__p[0]) = 0;
      _os_log_impl((void *)&_mh_execute_header, v14, OS_LOG_TYPE_DEFAULT, "Supporting service A2DP", (uint8_t *)__p, 2u);
    }

    if (qword_1008D98A0 != -1) {
      dispatch_once(&qword_1008D98A0, &stru_100897D38);
    }
    xpc_object_t v15 = off_1008D9898;
    size_t v16 = operator new(0x18uLL);
    v16[1] = v2;
    void v16[2] = v15;
    uint64_t v17 = *(void *)(a1 + 184);
    void *v16 = v17;
    *(void *)(v17 + sub_100242E28(v1 + 8) = v16;
    *(void *)(a1 + 184) = v16;
    ++*(void *)(a1 + 200);
  }

  if ((*(unsigned int (**)(uint64_t, uint64_t))(*(void *)v5 + 48LL))(v5, 8LL))
  {
    unint64_t v18 = (os_log_s *)qword_1008F7578;
    if (os_log_type_enabled((os_log_t)qword_1008F7578, OS_LOG_TYPE_DEFAULT))
    {
      LOWORD(__p[0]) = 0;
      _os_log_impl( (void *)&_mh_execute_header,  v18,  OS_LOG_TYPE_DEFAULT,  "Supporting service Remote",  (uint8_t *)__p,  2u);
    }

    if (qword_1008D98B0 != -1) {
      dispatch_once(&qword_1008D98B0, &stru_100897D58);
    }
    float v19 = off_1008D98A8;
    float v20 = operator new(0x18uLL);
    v20[1] = v2;
    void v20[2] = v19;
    uint64_t v21 = *(void *)(a1 + 184);
    *float v20 = v21;
    *(void *)(v21 + sub_100242E28(v1 + 8) = v20;
    *(void *)(a1 + 184) = v20;
    ++*(void *)(a1 + 200);
  }

  int v22 = (*(uint64_t (**)(uint64_t, uint64_t))(*(void *)v5 + 48LL))(v5, 128LL);
  if (v50) {
    int v23 = 0;
  }
  else {
    int v23 = v22;
  }
  if (v23 == 1)
  {
    size_t v24 = (os_log_s *)qword_1008F7578;
    if (os_log_type_enabled((os_log_t)qword_1008F7578, OS_LOG_TYPE_DEFAULT))
    {
      LOWORD(__p[0]) = 0;
      _os_log_impl( (void *)&_mh_execute_header,  v24,  OS_LOG_TYPE_DEFAULT,  "Supporting service WirelessiAP",  (uint8_t *)__p,  2u);
    }

    if (qword_1008D9128 != -1) {
      dispatch_once(&qword_1008D9128, &stru_100897D78);
    }
    uint64_t v25 = off_1008D9120;
    uint64_t v26 = operator new(0x18uLL);
    v26[1] = v2;
    void v26[2] = v25;
    uint64_t v27 = *(void *)(a1 + 184);
    void *v26 = v27;
    *(void *)(v27 + sub_100242E28(v1 + 8) = v26;
    *(void *)(a1 + 184) = v26;
    ++*(void *)(a1 + 200);
  }

  if ((*(unsigned int (**)(uint64_t, uint64_t))(*(void *)v5 + 48LL))(v5, 0x2000LL))
  {
    uint64_t v28 = (os_log_s *)qword_1008F7578;
    if (os_log_type_enabled((os_log_t)qword_1008F7578, OS_LOG_TYPE_DEFAULT))
    {
      LOWORD(__p[0]) = 0;
      _os_log_impl( (void *)&_mh_execute_header,  v28,  OS_LOG_TYPE_DEFAULT,  "Supporting service Braille",  (uint8_t *)__p,  2u);
    }

    if (qword_1008D98C0 != -1) {
      dispatch_once(&qword_1008D98C0, &stru_100897D98);
    }
    uint64_t v29 = qword_1008D98B8;
    __int128 v30 = operator new(0x18uLL);
    v30[1] = v2;
    v30[2] = v29;
    uint64_t v31 = *(void *)(a1 + 184);
    void *v30 = v31;
    *(void *)(v31 + sub_100242E28(v1 + 8) = v30;
    *(void *)(a1 + 184) = v30;
    ++*(void *)(a1 + 200);
  }

  if ((*(unsigned int (**)(uint64_t, uint64_t))(*(void *)v5 + 48LL))(v5, 0x10000LL))
  {
    __int128 v32 = (os_log_s *)qword_1008F7578;
    if (os_log_type_enabled((os_log_t)qword_1008F7578, OS_LOG_TYPE_DEFAULT))
    {
      LOWORD(__p[0]) = 0;
      _os_log_impl( (void *)&_mh_execute_header,  v32,  OS_LOG_TYPE_DEFAULT,  "Supporting service LE Audio",  (uint8_t *)__p,  2u);
    }

    if (qword_1008D98D0 != -1) {
      dispatch_once(&qword_1008D98D0, &stru_100897DB8);
    }
    uint64_t v33 = qword_1008D98C8;
    int v34 = operator new(0x18uLL);
    v34[1] = v2;
    void v34[2] = v33;
    uint64_t v35 = *(void *)(a1 + 184);
    void *v34 = v35;
    *(void *)(v35 + sub_100242E28(v1 + 8) = v34;
    *(void *)(a1 + 184) = v34;
    ++*(void *)(a1 + 200);
  }

  if ((*(unsigned int (**)(uint64_t, uint64_t))(*(void *)v5 + 48LL))(v5, 0x80000LL))
  {
    uint64_t v36 = (os_log_s *)qword_1008F7578;
    if (os_log_type_enabled((os_log_t)qword_1008F7578, OS_LOG_TYPE_DEFAULT))
    {
      LOWORD(__p[0]) = 0;
      _os_log_impl( (void *)&_mh_execute_header,  v36,  OS_LOG_TYPE_DEFAULT,  "Supporting service AACP Client",  (uint8_t *)__p,  2u);
    }

    if (qword_1008D9118 != -1) {
      dispatch_once(&qword_1008D9118, &stru_100897DD8);
    }
    int v37 = off_1008D9110;
    uint64_t v38 = operator new(0x18uLL);
    v38[1] = v2;
    v38[2] = v37;
    uint64_t v39 = *(void *)(a1 + 184);
    void *v38 = v39;
    *(void *)(v39 + sub_100242E28(v1 + 8) = v38;
    *(void *)(a1 + 184) = v38;
    ++*(void *)(a1 + 200);
  }

  if ((*(unsigned int (**)(uint64_t, uint64_t))(*(void *)v5 + 48LL))(v5, 0x100000LL))
  {
    uint64_t v40 = (os_log_s *)qword_1008F7578;
    if (os_log_type_enabled((os_log_t)qword_1008F7578, OS_LOG_TYPE_DEFAULT))
    {
      LOWORD(__p[0]) = 0;
      _os_log_impl((void *)&_mh_execute_header, v40, OS_LOG_TYPE_DEFAULT, "Supporting service GATT", (uint8_t *)__p, 2u);
    }

    if (qword_1008D98E0 != -1) {
      dispatch_once(&qword_1008D98E0, &stru_100897DF8);
    }
    uint64_t v41 = qword_1008D98D8;
    uint64_t v42 = operator new(0x18uLL);
    v42[1] = v2;
    v42[2] = v41;
    uint64_t v43 = *(void *)(a1 + 184);
    *uint64_t v42 = v43;
    *(void *)(v43 + sub_100242E28(v1 + 8) = v42;
    *(void *)(a1 + 184) = v42;
    ++*(void *)(a1 + 200);
  }

  sub_100242F54((uint64_t)v48);
  uint64_t v44 = operator new(0x10uLL);
  sub_100404F28(v44, (uint64_t)"Service Manager");
  *(void *)(a1 + 104) = v44;
  sub_100242FAC((uint64_t)v48);
  return a1;
}

void sub_1004218B0( _Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, void *__p, uint64_t a14, int a15, __int16 a16, char a17, char a18, uint64_t a19, void *a20, uint64_t a21, int a22, __int16 a23, char a24, char a25)
{
  int v34 = (void *)v26[59];
  if (v34)
  {
    v26[60] = v34;
    operator delete(v34);
  }

  sub_100242E28(v29);
  uint64_t v35 = (void *)v26[48];
  if (v35)
  {
    v26[49] = v35;
    operator delete(v35);
  }

  sub_100242E28(a10);
  sub_10041E79C(v26 + 34);
  sub_100242E28(a11);
  sub_10023DF50(v28);
  sub_100242E28(v27);
  sub_100242E28(a12);
  _Unwind_Resume(a1);
}

uint64_t sub_1004219F4(uint64_t a1)
{
  *(void *)a1 = off_100897B70;
  *(void *)(a1 + sub_100242E28(v1 + 8) = off_100897BE0;
  *(void *)(a1 + 16) = off_100897C10;
  *(void *)(a1 + 24) = off_100897C40;
  *(void *)(a1 + sub_100242FAC(v1 - 32) = &off_100897C60;
  v9[0] = 0LL;
  v9[1] = 0LL;
  uint64_t v2 = a1 + 120;
  sub_100242F28((uint64_t)v9, a1 + 120);
  sub_10023DF50((void *)(a1 + 184));
  *(_WORD *)(a1 + 70sub_100414D2C(qword_1008F72C0, 0) = 0;
  *(_DWORD *)(a1 + 696) = 0;
  sub_100242F54((uint64_t)v9);
  v8[0] = 0LL;
  v8[1] = 0LL;
  sub_100242F28((uint64_t)v8, a1 + 40);
  uint64_t v3 = *(void *)(a1 + 104);
  if (v3)
  {
    uint64_t v4 = (void *)sub_100405360(v3);
    operator delete(v4);
  }

  sub_100242FAC((uint64_t)v8);
  sub_100242FAC((uint64_t)v9);
  sub_100242E28(a1 + 632);
  sub_10023DF50((void *)(a1 + 608));
  sub_1002430A8(a1 + 560);
  sub_100242E28(a1 + 496);
  uint64_t v5 = *(void **)(a1 + 472);
  if (v5)
  {
    *(void *)(a1 + 48sub_100414D2C(qword_1008F72C0, 0) = v5;
    operator delete(v5);
  }

  sub_100242E28(a1 + 408);
  BOOL v6 = *(void **)(a1 + 384);
  if (v6)
  {
    *(void *)(a1 + 392) = v6;
    operator delete(v6);
  }

  sub_100242E28(a1 + 320);
  sub_10041E79C((void *)(a1 + 272));
  sub_100242E28(a1 + 208);
  sub_10023DF50((void *)(a1 + 184));
  sub_100242E28(v2);
  sub_100242E28(a1 + 40);
  return a1;
}

void sub_100421B24(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, ...)
{
  BOOL v6 = (void *)v3[59];
  if (v6)
  {
    v3[60] = v6;
    operator delete(v6);
  }

  sub_100242E28(v3 + 51);
  uint64_t v7 = (void *)v3[48];
  if (v7)
  {
    v3[49] = v7;
    operator delete(v7);
  }

  sub_100242E28(v3 + 40);
  sub_10041E79C(v3 + 34);
  sub_100242E28(v3 + 26);
  sub_10023DF50(v3 + 23);
  sub_100242E28(v4);
  sub_100242E28(v3 + 5);
  _Unwind_Resume(a1);
}

uint64_t sub_100421BC0(uint64_t a1)
{
  return sub_1004219F4(a1 - 32);
}

void sub_100421BC8(uint64_t a1)
{
  uint64_t v1 = (void *)sub_1004219F4(a1);
  operator delete(v1);
}

void sub_100421BDC(uint64_t a1)
{
  uint64_t v1 = (void *)sub_1004219F4(a1 - 32);
  operator delete(v1);
}

uint64_t sub_100421BF4(uint64_t a1)
{
  v3[0] = 0LL;
  v3[1] = 0LL;
  sub_100242F28((uint64_t)v3, a1 + 40);
  sub_100404F30(*(void *)(a1 + 104), QOS_CLASS_USER_INITIATED);
  sub_100242F54((uint64_t)v3);
  if (qword_1008D61A8 != -1) {
    dispatch_once(&qword_1008D61A8, &stru_100897E18);
  }
  sub_1003B423C(qword_1008D61A0 + 8, a1 + 24);
  if (qword_1008D60B0 != -1) {
    dispatch_once(&qword_1008D60B0, &stru_100897E38);
  }
  sub_1001FC5E4((uint64_t)off_1008D60A8 + 80, a1 + 8);
  return sub_100242FAC((uint64_t)v3);
}

void sub_100421CBC( _Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9)
{
}

uint64_t sub_100421CD0(uint64_t a1)
{
  *(_WORD *)(a1 + 70sub_100414D2C(qword_1008F72C0, 0) = 0;
  *(_DWORD *)(a1 + 696) = 0;
  if (qword_1008D60B0 != -1) {
    dispatch_once(&qword_1008D60B0, &stru_100897E38);
  }
  sub_100009168((uint64_t)off_1008D60A8 + 80, a1 + 8);
  if (qword_1008D61A8 != -1) {
    dispatch_once(&qword_1008D61A8, &stru_100897E18);
  }
  sub_100009168(qword_1008D61A0 + 8, a1 + 24);
  v3[0] = 0LL;
  v3[1] = 0LL;
  sub_100242F28((uint64_t)v3, a1 + 40);
  sub_1004052F8(*(void *)(a1 + 104));
  return sub_100242FAC((uint64_t)v3);
}

void sub_100421D94( _Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9)
{
}

uint64_t sub_100421DA8(uint64_t a1)
{
  v15[0] = 0LL;
  v15[1] = 0LL;
  sub_100242F28((uint64_t)v15, a1 + 40);
  *(_BYTE *)(a1 + 112) = 1;
  *(_DWORD *)(a1 + 696) = 0;
  *(_WORD *)(a1 + 70sub_100414D2C(qword_1008F72C0, 0) = 0;
  sub_100242F54((uint64_t)v15);
  v14[0] = 0LL;
  v14[1] = 0LL;
  sub_100242F28((uint64_t)v14, a1 + 120);
  uint64_t v11 = 0LL;
  unint64_t v12 = 0LL;
  uint64_t v13 = 0LL;
  sub_10042AC38(&v11, a1 + 184);
  sub_100242F54((uint64_t)v14);
  uint64_t v2 = sub_1002E8D54();
  sub_1001FC8A8(v2 + 368, a1 + 16);
  for (uint64_t i = v12; i != &v11; uint64_t i = (uint64_t *)i[1])
  {
    uint64_t v4 = i[2];
    int v5 = (*(uint64_t (**)(uint64_t))(*(void *)v4 + 16LL))(v4);
    if (v5)
    {
      BOOL v6 = (os_log_s *)qword_1008F7578;
      if (os_log_type_enabled((os_log_t)qword_1008F7578, OS_LOG_TYPE_ERROR))
      {
        (*(void (**)(void **__return_ptr, uint64_t))(*(void *)v4 + 192LL))(__p, v4);
        if (v10 >= 0) {
          uint64_t v7 = __p;
        }
        else {
          uint64_t v7 = (void **)__p[0];
        }
        *(_DWORD *)__int128 buf = 136446466;
        uint64_t v17 = v7;
        __int16 v18 = 1024;
        int v19 = v5;
        _os_log_error_impl( (void *)&_mh_execute_header,  v6,  OS_LOG_TYPE_ERROR,  "Could not start service %{public}s - result was %d",  buf,  0x12u);
        if (v10 < 0) {
          operator delete(__p[0]);
        }
      }
    }
  }

  sub_10023DF50(&v11);
  sub_100242FAC((uint64_t)v14);
  return sub_100242FAC((uint64_t)v15);
}

void sub_100421F78( _Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, ...)
{
  uint64_t v10 = va_arg(va1, void);
  uint64_t v12 = va_arg(va1, void);
  sub_100242FAC((uint64_t)va);
  sub_100242FAC((uint64_t)va1);
  _Unwind_Resume(a1);
}

uint64_t sub_100421FC0(uint64_t a1)
{
  return sub_100421DA8(a1 - 8);
}

uint64_t sub_100421FC8(uint64_t a1)
{
  uint64_t v2 = (os_log_s *)qword_1008F7578;
  if (os_log_type_enabled((os_log_t)qword_1008F7578, OS_LOG_TYPE_DEFAULT))
  {
    *(_WORD *)__int128 buf = 0;
    _os_log_impl((void *)&_mh_execute_header, v2, OS_LOG_TYPE_DEFAULT, "ServiceManager::stackWillStop enter", buf, 2u);
  }

  v33[0] = 0LL;
  v33[1] = 0LL;
  sub_100242F28((uint64_t)v33, a1 + 120);
  *(void *)__int128 buf = 0LL;
  uint64_t v31 = 0LL;
  uint64_t v32 = 0LL;
  sub_10042AC38(buf, a1 + 184);
  sub_100242F54((uint64_t)v33);
  uint64_t v3 = sub_1002E8D54();
  sub_10024E060(v3 + 368, a1 + 16);
  for (uint64_t i = v31; (uint8_t *)i != buf; uint64_t i = *(void *)(i + 8))
  {
    __p[0] = *(void **)(i + 16);
    if ((*(unsigned int (**)(void *))(*(void *)__p[0] + 32LL))(__p[0]))
    {
      *(_OWORD *)&v28.__r_.__value_.__l.__data_ = 0uLL;
      sub_100242F28((uint64_t)&v28, a1 + 496);
      int v5 = operator new(0x18uLL);
      BOOL v6 = __p[0];
      v5[1] = a1 + 608;
      void v5[2] = v6;
      uint64_t v7 = *(void *)(a1 + 608);
      *int v5 = v7;
      *(void *)(v7 + sub_100242E28(v1 + 8) = v5;
      *(void *)(a1 + 60sub_100242E28(v1 + 8) = v5;
      ++*(void *)(a1 + 624);
      sub_100242F54((uint64_t)&v28);
      if ((*(unsigned int (**)(void *))(*(void *)__p[0] + 24LL))(__p[0]) != 113)
      {
        sub_100242ECC((uint64_t)&v28);
        sub_100422444(a1 + 608, __p);
        sub_100242F54((uint64_t)&v28);
      }

      sub_100242FAC((uint64_t)&v28);
    }
  }

  v29[0] = 0LL;
  v29[1] = 0LL;
  sub_100242F28((uint64_t)v29, a1 + 496);
  while (*(void *)(a1 + 624))
  {
    if (!sub_1002431A4((pthread_cond_t *)(a1 + 560), v29, 0x2710uLL))
    {
      unint64_t v8 = (os_log_s *)qword_1008F7578;
      if (os_log_type_enabled((os_log_t)qword_1008F7578, OS_LOG_TYPE_ERROR)) {
        sub_10067DBB0((uint64_t *)(a1 + 624), v8, v9);
      }
      memset(&v28, 0, sizeof(v28));
      sub_10002418C(&v28, "ServiceManager shutdown failure, waiting for ");
      uint64_t v10 = *(void *)(*(void *)(a1 + 616) + 16LL);
      if (*(char *)(v10 + 31) < 0)
      {
        sub_100024238(__p, *(void **)(v10 + 8), *(void *)(v10 + 16));
      }

      else
      {
        __int128 v19 = *(_OWORD *)(v10 + 8);
        uint64_t v27 = *(void *)(v10 + 24);
        *(_OWORD *)std::string __p = v19;
      }

      if (v27 >= 0) {
        float v20 = __p;
      }
      else {
        float v20 = (void **)__p[0];
      }
      if (v27 >= 0) {
        std::string::size_type v21 = HIBYTE(v27);
      }
      else {
        std::string::size_type v21 = (std::string::size_type)__p[1];
      }
      std::string::append(&v28, (const std::string::value_type *)v20, v21);
      if (SHIBYTE(v27) < 0) {
        operator delete(__p[0]);
      }
      uint64_t v22 = sub_1002E6E00();
      if ((v28.__r_.__value_.__s.__size_ & 0x80u) == 0) {
        int v23 = &v28;
      }
      else {
        int v23 = (std::string *)v28.__r_.__value_.__r.__words[0];
      }
      sub_10002418C(v25, (char *)v23);
      sub_1004FB370(v22, 3715LL, (uint64_t)v25, 1);
    }
  }

  sub_10023DF50((void *)(a1 + 608));
  *(_OWORD *)&v28.__r_.__value_.__l.__data_ = 0uLL;
  sub_100242F28((uint64_t)&v28, a1 + 40);
  *(_BYTE *)(a1 + 112) = 0;
  sub_100242F54((uint64_t)&v28);
  __p[0] = 0LL;
  __p[1] = 0LL;
  sub_100242F28((uint64_t)__p, a1 + 208);
  uint64_t v11 = (os_log_s *)qword_1008F7578;
  if (os_log_type_enabled((os_log_t)qword_1008F7578, OS_LOG_TYPE_DEFAULT))
  {
    *(_WORD *)size_t v24 = 0;
    _os_log_impl( (void *)&_mh_execute_header,  v11,  OS_LOG_TYPE_DEFAULT,  "stack will stop, clearing the connection request queue",  v24,  2u);
  }

  uint64_t v12 = *(void ***)(a1 + 280);
  uint64_t v13 = *(void *)(a1 + 288);
  *(void *)(a1 + 312) = 0LL;
  unint64_t v14 = v13 - (void)v12;
  if (v14 >= 0x11)
  {
    do
    {
      operator delete(*v12);
      uint64_t v15 = *(void *)(a1 + 288);
      uint64_t v12 = (void **)(*(void *)(a1 + 280) + 8LL);
      *(void *)(a1 + 28sub_100414D2C(qword_1008F72C0, 0) = v12;
      unint64_t v14 = v15 - (void)v12;
    }

    while (v14 > 0x10);
  }

  if (v14 >> 3 == 1)
  {
    uint64_t v16 = 51LL;
  }

  else
  {
    if (v14 >> 3 != 2) {
      goto LABEL_25;
    }
    uint64_t v16 = 102LL;
  }

  *(void *)(a1 + 304) = v16;
LABEL_25:
  sub_100422510((void *)a1);
  sub_100242F54((uint64_t)__p);
  uint64_t v17 = (os_log_s *)qword_1008F7578;
  if (os_log_type_enabled((os_log_t)qword_1008F7578, OS_LOG_TYPE_DEFAULT))
  {
    *(_WORD *)size_t v24 = 0;
    _os_log_impl((void *)&_mh_execute_header, v17, OS_LOG_TYPE_DEFAULT, "ServiceManager::stackWillStop exit", v24, 2u);
  }

  sub_100242FAC((uint64_t)__p);
  sub_100242FAC((uint64_t)&v28);
  sub_100242FAC((uint64_t)v29);
  sub_10023DF50(buf);
  return sub_100242FAC((uint64_t)v33);
}

void sub_100422380( _Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void *__p, uint64_t a11, int a12, __int16 a13, char a14, char a15, uint64_t a16, uint64_t a17, int a18, __int16 a19, char a20, char a21, void *a22, uint64_t a23, int a24, __int16 a25, char a26, char a27, char a28, uint64_t a29, uint64_t a30)
{
}

void *sub_100422444(uint64_t a1, void *a2)
{
  v10[0] = (uint64_t)v10;
  v10[1] = (uint64_t)v10;
  void v10[2] = 0LL;
  uint64_t v2 = *(void **)(a1 + 8);
  if (v2 != (void *)a1)
  {
    do
    {
      BOOL v6 = (void *)v2[1];
      uint64_t v5 = v2[2];
      if (v5 == *a2)
      {
        if (v6 == (void *)a1)
        {
          BOOL v8 = 1;
LABEL_8:
          BOOL v6 = (void *)a1;
        }

        else
        {
          while (1)
          {
            uint64_t v7 = v6[2];
            BOOL v8 = v7 == v5;
            if (v7 != v5) {
              break;
            }
            BOOL v6 = (void *)v6[1];
            if (v6 == (void *)a1) {
              goto LABEL_8;
            }
          }
        }

        sub_10040BD38((uint64_t)v10, v10, a1, v2, v6);
        if (!v8) {
          BOOL v6 = (void *)v6[1];
        }
      }

      uint64_t v2 = v6;
    }

    while (v6 != (void *)a1);
  }

  return sub_10023DF50(v10);
}

void sub_1004224FC(_Unwind_Exception *a1, uint64_t a2, ...)
{
}

uint64_t sub_100422510(void *a1)
{
  v19[0] = 0LL;
  v19[1] = 0LL;
  sub_100242F28((uint64_t)v19, (uint64_t)(a1 + 26));
  uint64_t v2 = (os_log_s *)qword_1008F7578;
  if (os_log_type_enabled((os_log_t)qword_1008F7578, OS_LOG_TYPE_DEFAULT))
  {
    *(_WORD *)__int128 buf = 0;
    _os_log_impl( (void *)&_mh_execute_header,  v2,  OS_LOG_TYPE_DEFAULT,  "------------ Connection Requests ------------",  buf,  2u);
  }

  unint64_t v3 = a1[38];
  uint64_t v4 = a1[35];
  uint64_t v5 = a1[36];
  BOOL v6 = (void *)(v4 + 8 * (v3 / 0x66));
  if (v5 == v4) {
    unint64_t v7 = 0LL;
  }
  else {
    unint64_t v7 = *v6 + 40 * (v3 % 0x66);
  }
  while (1)
  {
    if (v5 == v4)
    {
      unint64_t v9 = 0LL;
    }

    else
    {
      unint64_t v8 = a1[39] + a1[38];
      unint64_t v9 = *(void *)(v4 + 8 * (v8 / 0x66)) + 40 * (v8 % 0x66);
    }

    uint64_t v10 = (os_log_s *)qword_1008F7578;
    BOOL v11 = os_log_type_enabled((os_log_t)qword_1008F7578, OS_LOG_TYPE_DEFAULT);
    if (v7 == v9) {
      break;
    }
    if (v11)
    {
      sub_1003CF00C(*(void *)v7, __p);
      uint64_t v12 = __p;
      if (v18 < 0) {
        uint64_t v12 = (void **)__p[0];
      }
      int v13 = *(_DWORD *)(v7 + 24);
      int v14 = *(_DWORD *)(v7 + 8);
      *(_DWORD *)__int128 buf = 136446722;
      std::string::size_type v21 = v12;
      __int16 v22 = 1024;
      int v23 = v13;
      __int16 v24 = 1024;
      int v25 = v14;
      _os_log_impl( (void *)&_mh_execute_header,  v10,  OS_LOG_TYPE_DEFAULT,  "Device: %{public}s with Services: 0x%x and in state %d ",  buf,  0x18u);
      if (v18 < 0) {
        operator delete(__p[0]);
      }
    }

    v7 += 40LL;
    if (v7 - *v6 == 4080)
    {
      unint64_t v15 = v6[1];
      ++v6;
      unint64_t v7 = v15;
    }

    uint64_t v4 = a1[35];
    uint64_t v5 = a1[36];
  }

  if (v11)
  {
    *(_WORD *)__int128 buf = 0;
    _os_log_impl( (void *)&_mh_execute_header,  v10,  OS_LOG_TYPE_DEFAULT,  "----------------------------------------------",  buf,  2u);
  }

  return sub_100242FAC((uint64_t)v19);
}

void sub_100422748( _Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, char a15)
{
}

uint64_t sub_100422764(uint64_t a1)
{
  return sub_100421FC8(a1 - 8);
}

uint64_t sub_10042276C(uint64_t a1, uint64_t a2)
{
  v4[1] = 0LL;
  uint64_t v5 = a2;
  v4[0] = 0LL;
  sub_100242F28((uint64_t)v4, a1 + 496);
  sub_100422444(a1 + 608, &v5);
  sub_1002431AC((pthread_cond_t *)(a1 + 560));
  return sub_100242FAC((uint64_t)v4);
}

void sub_1004227C0(_Unwind_Exception *a1, uint64_t a2, ...)
{
}

uint64_t sub_1004227DC(uint64_t a1, uint64_t a2)
{
  v6[0] = 0LL;
  v6[1] = 0LL;
  sub_100242F28((uint64_t)v6, a1 + 320);
  uint64_t v4 = sub_10042AD34(*(void *)(a1 + 384), *(void *)(a1 + 392), a2);
  sub_10042ACD0(a1 + 384, v4, *(void *)(a1 + 392));
  return sub_100242FAC((uint64_t)v6);
}

void sub_100422838( _Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9)
{
}

uint64_t sub_10042284C(uint64_t a1, uint64_t a2)
{
  return sub_1004227DC(a1 - 24, a2);
}

uint64_t sub_100422854(uint64_t *a1, uint64_t a2, uint64_t a3, int a4, uint64_t a5)
{
  v14[0] = 0LL;
  v14[1] = 0LL;
  sub_100242F28((uint64_t)v14, (uint64_t)(a1 + 40));
  BOOL v11 = (void *)a1[48];
  unint64_t v10 = a1[49];
  uint64_t v16 = a3;
  if (v11 != (void *)v10)
  {
    while (*v11 != a2 || v16 != v11[1])
    {
      v11 += 4;
      if (v11 == (void *)v10) {
        goto LABEL_7;
      }
    }
  }

  if (v11 == (void *)v10)
  {
LABEL_7:
    uint64_t v15 = a2;
    uint64_t v16 = a3;
    int v17 = a4;
    uint64_t v18 = a5;
    if (v10 >= a1[50])
    {
      uint64_t v12 = sub_10042AD9C(a1 + 48, (uint64_t)&v15);
    }

    else
    {
      *(void *)unint64_t v10 = a2;
      *(void *)(v10 + sub_100242E28(v1 + 8) = a3;
      *(_DWORD *)(v10 + 16) = a4;
      uint64_t v12 = v10 + 32;
      *(void *)(v10 + 24) = a5;
    }

    a1[49] = v12;
  }

  sub_100242FAC((uint64_t)v14);
  return 0LL;
}

void sub_100422934( _Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9)
{
}

uint64_t sub_100422948(uint64_t a1, uint64_t a2, uint64_t a3)
{
  v8[0] = 0LL;
  v8[1] = 0LL;
  sub_100242F28((uint64_t)v8, a1 + 320);
  uint64_t v6 = sub_10042AF40(*(void *)(a1 + 384), *(void *)(a1 + 392), a2, a3);
  sub_10042ACD0(a1 + 384, v6, *(void *)(a1 + 392));
  sub_100242FAC((uint64_t)v8);
  return 0LL;
}

void sub_1004229B8( _Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9)
{
}

uint64_t sub_1004229CC(void *a1, uint64_t a2)
{
  v19[0] = 0LL;
  v19[1] = 0LL;
  sub_100242F28((uint64_t)v19, (uint64_t)(a1 + 51));
  uint64_t v5 = (void *)a1[60];
  unint64_t v4 = a1[61];
  if ((unint64_t)v5 >= v4)
  {
    uint64_t v7 = a1[59];
    uint64_t v8 = ((uint64_t)v5 - v7) >> 3;
    uint64_t v9 = v4 - v7;
    uint64_t v10 = v9 >> 2;
    else {
      unint64_t v11 = v10;
    }
    if (v11) {
      uint64_t v12 = (char *)sub_100008BA0((uint64_t)(a1 + 61), v11);
    }
    else {
      uint64_t v12 = 0LL;
    }
    int v13 = &v12[8 * v8];
    int v14 = &v12[8 * v11];
    *(void *)int v13 = a2;
    uint64_t v6 = v13 + 8;
    uint64_t v16 = (char *)a1[59];
    uint64_t v15 = (char *)a1[60];
    if (v15 != v16)
    {
      do
      {
        uint64_t v17 = *((void *)v15 - 1);
        v15 -= 8;
        *((void *)v13 - 1) = v17;
        v13 -= 8;
      }

      while (v15 != v16);
      uint64_t v15 = (char *)a1[59];
    }

    a1[59] = v13;
    a1[60] = v6;
    a1[61] = v14;
    if (v15) {
      operator delete(v15);
    }
  }

  else
  {
    *uint64_t v5 = a2;
    uint64_t v6 = v5 + 1;
  }

  a1[60] = v6;
  return sub_100242FAC((uint64_t)v19);
}

void sub_100422AC0( _Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9)
{
}

uint64_t sub_100422AD4(uint64_t a1, uint64_t a2)
{
  v8[0] = 0LL;
  v8[1] = 0LL;
  sub_100242F28((uint64_t)v8, a1 + 408);
  uint64_t v5 = *(char **)(a1 + 472);
  unint64_t v4 = *(char **)(a1 + 480);
  if (v5 != v4)
  {
    while (*(void *)v5 != a2)
    {
      v5 += 8;
      if (v5 == v4)
      {
        uint64_t v5 = *(char **)(a1 + 480);
        break;
      }
    }
  }

  if (v5 != v4)
  {
    int64_t v6 = v4 - (v5 + 8);
    if (v4 != v5 + 8) {
      memmove(v5, v5 + 8, v4 - (v5 + 8));
    }
    *(void *)(a1 + 48sub_100414D2C(qword_1008F72C0, 0) = &v5[v6];
  }

  return sub_100242FAC((uint64_t)v8);
}

uint64_t sub_100422B6C(uint64_t a1, uint64_t a2, uint64_t a3, int a4, uint64_t a5, uint64_t a6, unsigned int a7)
{
  v34[0] = 0LL;
  v34[1] = 0LL;
  sub_100242F28((uint64_t)v34, a1 + 408);
  std::string __p = 0LL;
  uint64_t v32 = 0LL;
  uint64_t v33 = 0LL;
  sub_100240540(&__p, a1 + 472);
  sub_100242F54((uint64_t)v34);
  uint64_t v12 = __p;
  if (__p != v32)
  {
    if ((_DWORD)a5 == 12) {
      uint64_t v13 = a7;
    }
    else {
      uint64_t v13 = a6;
    }
    do
    {
      uint64_t v14 = v13;
      if ((a5 - 105) >= 0xFFFFFFFE)
      {
        sub_100242874(4LL);
        uint64_t v14 = a6;
      }

      (**(void (***)(void, uint64_t, uint64_t, uint64_t, uint64_t))*v12)(*v12, a2, a3, a5, v14);
      ++v12;
    }

    while (v12 != v32);
  }

  v30[0] = 0LL;
  v30[1] = 0LL;
  sub_100242F28((uint64_t)v30, a1 + 320);
  for (uint64_t i = *(void *)(a1 + 384); i != *(void *)(a1 + 392); i += 32LL)
  {
    if ((a3 & ~*(_DWORD *)(i + 16)) == 0)
    {
      if (qword_1008D61A8 != -1) {
        dispatch_once(&qword_1008D61A8, &stru_100897E18);
      }
      if (sub_10049729C(qword_1008D61A0, *(void *)i))
      {
        if (*(void *)(i + 8))
        {
          if (qword_1008D5F50 != -1) {
            dispatch_once(&qword_1008D5F50, &stru_100897E58);
          }
          unint64_t v16 = sub_1003FEFA8((uint64_t)off_1008D5F48, *(void *)i, a2);
          if (!v16)
          {
            uint64_t v17 = (os_log_s *)qword_1008F7578;
            if (os_log_type_enabled((os_log_t)qword_1008F7578, OS_LOG_TYPE_ERROR)) {
              sub_10067DC20(&v28, v29, v17);
            }
          }

          if (qword_1008D9138 != -1) {
            dispatch_once(&qword_1008D9138, &stru_100897E78);
          }
          uint64_t v18 = off_1008D9130;
          __int128 v19 = operator new(0x40uLL);
          uint64_t v20 = *(void *)(i + 24);
          v19[4] = 1;
          *((_OWORD *)v19 + 1) = *(_OWORD *)i;
          *(void *)__int128 v19 = &off_100897CC8;
          *((void *)v19 + 4) = v20;
          *((void *)v19 + 5) = v16;
          *((_DWORD *)v19 + 12) = a3;
          *((_DWORD *)v19 + 13) = a4;
          *((_DWORD *)v19 + 14) = a5;
          *((_DWORD *)v19 + 15) = a6;
          sub_1004946C4((uint64_t)v18, v19);
          std::string::size_type v21 = (os_log_s *)qword_1008F7578;
          if (os_log_type_enabled((os_log_t)qword_1008F7578, OS_LOG_TYPE_INFO))
          {
            unint64_t v22 = *(void *)i;
            *(_DWORD *)__int128 buf = 134219264;
            *(void *)uint64_t v36 = v22;
            *(_WORD *)&v36[8] = 1024;
            *(_DWORD *)int v37 = a3;
            *(_WORD *)&v37[4] = 1024;
            *(_DWORD *)uint64_t v38 = a4;
            *(_WORD *)&v38[4] = 1024;
            *(_DWORD *)uint64_t v39 = a5;
            *(_WORD *)&v39[4] = 1024;
            int v40 = a6;
            __int16 v41 = 1024;
            unsigned int v42 = a7;
            _os_log_impl( (void *)&_mh_execute_header,  v21,  OS_LOG_TYPE_INFO,  "ServiceManager notifyStatusEvent: Owner %llx, service %d, eventType %d, event %d, result %d, reason %d",  buf,  0x2Au);
          }
        }

        else
        {
          __int16 v24 = (os_log_s *)qword_1008F7578;
          if (os_log_type_enabled((os_log_t)qword_1008F7578, OS_LOG_TYPE_ERROR))
          {
            *(_DWORD *)__int128 buf = 67110144;
            *(_DWORD *)uint64_t v36 = a3;
            *(_WORD *)&v36[4] = 1024;
            *(_DWORD *)&v36[6] = a4;
            *(_WORD *)int v37 = 1024;
            *(_DWORD *)&v37[2] = a5;
            *(_WORD *)uint64_t v38 = 1024;
            *(_DWORD *)&v38[2] = a6;
            *(_WORD *)uint64_t v39 = 1024;
            *(_DWORD *)&void v39[2] = a7;
            _os_log_error_impl( (void *)&_mh_execute_header,  v24,  OS_LOG_TYPE_ERROR,  "Invalid fCallback: service %d, eventType %d, event %d, result %d, reason %d",  buf,  0x20u);
          }
        }
      }

      else
      {
        uint64_t v23 = sub_10042AD34(*(void *)(a1 + 384), *(void *)(a1 + 392), *(void *)i);
        sub_10042ACD0(a1 + 384, v23, *(void *)(a1 + 392));
      }
    }
  }

  sub_100242FAC((uint64_t)v30);
  if (__p)
  {
    uint64_t v32 = __p;
    operator delete(__p);
  }

  return sub_100242FAC((uint64_t)v34);
}

void sub_100422F50( _Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, char a20, uint64_t a21, void *__p, uint64_t a23, uint64_t a24, char a25)
{
  if (__p) {
    operator delete(__p);
  }
  sub_100242FAC((uint64_t)&a25);
  _Unwind_Resume(a1);
}

uint64_t sub_100422FA0(int64x2_t *a1, uint64_t a2)
{
  v35[0] = 0LL;
  v35[1] = 0LL;
  sub_100242F28((uint64_t)v35, (uint64_t)a1[13].i64);
  sub_100422510(a1);
  if (a1[19].i64[1]) {
    uint64_t v4 = *(void *)(*(void *)(a1[17].i64[1] + 8 * (a1[19].i64[0] / 0x66uLL)) + 40 * (a1[19].i64[0] % 0x66uLL));
  }
  else {
    uint64_t v4 = 0LL;
  }
  sub_100242F54((uint64_t)v35);
  if (!v4) {
    return sub_100242FAC((uint64_t)v35);
  }
  if (v4 == a2)
  {
    uint64_t v10 = (os_log_s *)qword_1008F7578;
    if (os_log_type_enabled((os_log_t)qword_1008F7578, OS_LOG_TYPE_DEFAULT))
    {
      sub_1003CF00C(a2, __p);
      unint64_t v11 = __p[23] >= 0 ? __p : *(_BYTE **)__p;
      LODWORD(buf) = 136446210;
      *(void *)((char *)&buf + 4) = v11;
      _os_log_impl( (void *)&_mh_execute_header,  v10,  OS_LOG_TYPE_DEFAULT,  "Removing stalled device %{public}s from connection request queue and processing next conenction.",  (uint8_t *)&buf,  0xCu);
      if ((__p[23] & 0x80000000) != 0) {
        operator delete(*(void **)__p);
      }
    }

    sub_100423730(a1, a2);
LABEL_32:
    v34[0] = 0LL;
    v34[1] = 0LL;
    sub_100242F28((uint64_t)v34, (uint64_t)&a1[7].i64[1]);
    __int128 buf = 0uLL;
    uint64_t v43 = 0LL;
    sub_10042AC38(&buf, (uint64_t)&a1[11].i64[1]);
    sub_100242F54((uint64_t)v34);
    if (qword_1008D67E8 != -1) {
      dispatch_once(&qword_1008D67E8, &stru_100897E98);
    }
    int v17 = sub_1003CA0E8((uint64_t)off_1008D67E0, a2);
    if (v17)
    {
      uint64_t v18 = (os_log_s *)qword_1008F7578;
      if (os_log_type_enabled((os_log_t)qword_1008F7578, OS_LOG_TYPE_DEFAULT))
      {
        sub_1003CF00C(a2, __p);
        __int128 v19 = __p[23] >= 0 ? __p : *(_BYTE **)__p;
        *(_DWORD *)uint64_t v36 = 136446466;
        *(void *)&v36[4] = v19;
        __int16 v37 = 1024;
        int v38 = v17;
        _os_log_impl( (void *)&_mh_execute_header,  v18,  OS_LOG_TYPE_DEFAULT,  "Device %{public}s has pending services:0x%x for a stalled connection request in the queue. Reporting conenctio n result for the pending services.",  v36,  0x12u);
        if ((__p[23] & 0x80000000) != 0) {
          operator delete(*(void **)__p);
        }
      }

      for (uint64_t i = *((void *)&buf + 1); (__int128 *)i != &buf; uint64_t i = *(void *)(i + 8))
      {
        if ((*(_DWORD *)(*(void *)(i + 16) + 32LL) & v17) != 0) {
          sub_100423CEC(a1, a2);
        }
      }
    }

    if (sub_1003D0670(a2))
    {
      std::string::size_type v21 = (os_log_s *)qword_1008F7578;
      if (os_log_type_enabled((os_log_t)qword_1008F7578, OS_LOG_TYPE_DEFAULT))
      {
        sub_1003CF00C(a2, __p);
        unint64_t v22 = __p[23] >= 0 ? __p : *(_BYTE **)__p;
        *(_DWORD *)uint64_t v36 = 136446210;
        *(void *)&v36[4] = v22;
        _os_log_impl( (void *)&_mh_execute_header,  v21,  OS_LOG_TYPE_DEFAULT,  "Force Disconnect %{public}s since it had a stalled connection request in the queue.",  v36,  0xCu);
        if ((__p[23] & 0x80000000) != 0) {
          operator delete(*(void **)__p);
        }
      }

      uint64_t v23 = a1[6].i64[1];
      *(void *)std::string __p = _NSConcreteStackBlock;
      *(void *)&__p[8] = 3221225472LL;
      *(void *)&__p[16] = sub_1004290CC;
      *(void *)&__p[24] = &unk_100886EE0;
      *(void *)&__p[32] = a1;
      uint64_t v45 = a2;
      char v46 = 1;
      sub_100405384(v23, __p);
    }

    __int16 v24 = (os_log_s *)qword_1008F7578;
    if (os_log_type_enabled((os_log_t)qword_1008F7578, OS_LOG_TYPE_DEFAULT))
    {
      sub_1003CF00C(a2, __p);
      int v25 = __p[23] >= 0 ? __p : *(_BYTE **)__p;
      *(_DWORD *)uint64_t v36 = 136446210;
      *(void *)&v36[4] = v25;
      _os_log_impl( (void *)&_mh_execute_header,  v24,  OS_LOG_TYPE_DEFAULT,  "Check if we can inititate a reconnection for the stalled device %{public}s.",  v36,  0xCu);
      if ((__p[23] & 0x80000000) != 0) {
        operator delete(*(void **)__p);
      }
    }

    *(void *)uuid_t uu = 0LL;
    uint64_t v41 = 0LL;
    if (qword_1008D5F30 != -1) {
      dispatch_once(&qword_1008D5F30, &stru_100897EB8);
    }
    sub_1005D0B84((uint64_t)off_1008D5F28, (unsigned __int8 *)(a2 + 128), uu);
    if (!uuid_is_null(uu))
    {
      if (qword_1008D5F30 != -1) {
        dispatch_once(&qword_1008D5F30, &stru_100897EB8);
      }
      uint64_t v27 = off_1008D5F28;
      uint8_t v28 = sub_100241F94(uu);
      uint64_t v29 = (void *)objc_claimAutoreleasedReturnValue(v28);
      double v30 = sub_1005D71D4((uint64_t)v27, v29);

      double Current = CFAbsoluteTimeGetCurrent();
      if (Current > v30 && Current - v30 <= 1.0)
      {
        uint64_t v32 = (os_log_s *)qword_1008F7578;
        if (os_log_type_enabled((os_log_t)qword_1008F7578, OS_LOG_TYPE_DEFAULT))
        {
          sub_1003CF00C(a2, v36);
          uint64_t v33 = v39 >= 0 ? v36 : *(_BYTE **)v36;
          *(_DWORD *)std::string __p = 136446978;
          *(void *)&__p[4] = v33;
          *(_WORD *)&_BYTE __p[12] = 1024;
          *(_DWORD *)&__p[14] = 1;
          *(_WORD *)&__p[18] = 2048;
          *(double *)&__p[20] = Current;
          *(_WORD *)&__p[28] = 2048;
          *(double *)&__p[30] = v30;
          _os_log_impl( (void *)&_mh_execute_header,  v32,  OS_LOG_TYPE_DEFAULT,  "LE Adv for the stalled device %{public}s was last seen within %d second(s). CurrentTimeStamp: %f, lastSeenTi meStamp: %f. Initiating reconnection.",  __p,  0x26u);
          if (v39 < 0) {
            operator delete(*(void **)v36);
          }
        }

        memset(__p, 0, 24);
        sub_100424360(a1, a2, -1, (const std::string *)__p, 2LL);
        if ((__p[23] & 0x80000000) != 0) {
          operator delete(*(void **)__p);
        }
      }
    }

    sub_10023DF50(&buf);
    sub_100242FAC((uint64_t)v34);
    return sub_100242FAC((uint64_t)v35);
  }

  sub_100242ECC((uint64_t)v35);
  unint64_t v5 = a1[19].u64[0];
  uint64_t v6 = a1[17].i64[1];
  uint64_t v7 = a1[18].i64[0];
  uint64_t v8 = (void *)(v6 + 8 * (v5 / 0x66));
  if (v7 == v6) {
    uint64_t v9 = 0LL;
  }
  else {
    uint64_t v9 = *v8 + 40 * (v5 % 0x66);
  }
LABEL_16:
  uint64_t v12 = (void *)v9;
  while (1)
  {
    unint64_t v13 = v7 == v6 ? 0LL : *(void *)(v6 + 8 * ((a1[19].i64[1] + v5) / 0x66)) + 40 * ((a1[19].i64[1] + v5) % 0x66);
    if (v12 == (void *)v13) {
      break;
    }
    if (*v12 == a2)
    {
      uint64_t v15 = (os_log_s *)qword_1008F7578;
      if (os_log_type_enabled((os_log_t)qword_1008F7578, OS_LOG_TYPE_DEFAULT))
      {
        sub_1003CF00C(a2, __p);
        unint64_t v16 = __p[23] >= 0 ? __p : *(_BYTE **)__p;
        LODWORD(buf) = 136446210;
        *(void *)((char *)&buf + 4) = v16;
        _os_log_impl( (void *)&_mh_execute_header,  v15,  OS_LOG_TYPE_DEFAULT,  "Removing stalled device %{public}s from connection request queue.",  (uint8_t *)&buf,  0xCu);
        if ((__p[23] & 0x80000000) != 0) {
          operator delete(*(void **)__p);
        }
      }

      sub_1003E4044(a2, 0);
      sub_10041DD44(a1 + 17, v8, v9);
      break;
    }

    v12 += 5;
    v9 += 40LL;
    if (*v8 + 4080LL == v9)
    {
      uint64_t v14 = v8[1];
      ++v8;
      uint64_t v9 = v14;
      goto LABEL_16;
    }
  }

  sub_100422510(a1);
  sub_100242F54((uint64_t)v35);
  if (v12 != (void *)v13) {
    goto LABEL_32;
  }
  return sub_100242FAC((uint64_t)v35);
}

void sub_10042369C( _Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, char a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20, uint64_t a21, uint64_t a22, void *__p, uint64_t a24, int a25, __int16 a26, char a27, char a28)
{
}

uint64_t sub_100423730(int64x2_t *a1, uint64_t a2)
{
  v28[0] = 0LL;
  v28[1] = 0LL;
  sub_100242F28((uint64_t)v28, (uint64_t)a1[13].i64);
  uint64_t v4 = (os_log_s *)qword_1008F7578;
  if (os_log_type_enabled((os_log_t)qword_1008F7578, OS_LOG_TYPE_DEFAULT))
  {
    LOWORD(__p[0]) = 0;
    _os_log_impl((void *)&_mh_execute_header, v4, OS_LOG_TYPE_DEFAULT, "processing next connection", (uint8_t *)__p, 2u);
  }

  sub_100422510(a1);
  unint64_t v5 = a1[19].u64[0];
  uint64_t v6 = a1[17].i64[1];
  uint64_t v7 = a1[18].i64[0];
  uint64_t v8 = (void *)(v6 + 8 * (v5 / 0x66));
  if (v7 == v6) {
    uint64_t v9 = 0LL;
  }
  else {
    uint64_t v9 = *v8 + 40 * (v5 % 0x66);
  }
LABEL_6:
  uint64_t v10 = v9;
  while (1)
  {
    unint64_t v11 = v7 == v6 ? 0LL : *(void *)(v6 + 8 * ((a1[19].i64[1] + v5) / 0x66)) + 40 * ((a1[19].i64[1] + v5) % 0x66);
    if (v10 == v11) {
      break;
    }
    if (*(void *)v10 == a2)
    {
      int v13 = sub_100425684((uint64_t)a1, a2);
      if (v13)
      {
        if (sub_1003D0070(a2, 0x80000u) == 4 && (v13 & 0x80000) == 0 && (*(_BYTE *)(v10 + 26) & 8) != 0)
        {
          uint64_t v14 = (os_log_s *)qword_1008F7578;
          if (os_log_type_enabled((os_log_t)qword_1008F7578, OS_LOG_TYPE_DEFAULT))
          {
            sub_1003CF00C(a2, __p);
            uint64_t v15 = v27 >= 0 ? __p : (void **)__p[0];
            *(_DWORD *)__int128 buf = 136446210;
            double v30 = v15;
            _os_log_impl( (void *)&_mh_execute_header,  v14,  OS_LOG_TYPE_DEFAULT,  "AACP is not being connected to %{public}s",  buf,  0xCu);
            if (v27 < 0) {
              operator delete(__p[0]);
            }
          }
        }
      }

      unint64_t v16 = (os_log_s *)qword_1008F7578;
      if (os_log_type_enabled((os_log_t)qword_1008F7578, OS_LOG_TYPE_DEFAULT))
      {
        sub_1003CF00C(a2, __p);
        int v17 = v27 >= 0 ? __p : (void **)__p[0];
        *(_DWORD *)__int128 buf = 136446210;
        double v30 = v17;
        _os_log_impl( (void *)&_mh_execute_header,  v16,  OS_LOG_TYPE_DEFAULT,  "Removing device %{public}s from connection request queue",  buf,  0xCu);
        if (v27 < 0) {
          operator delete(__p[0]);
        }
      }

      sub_1003E4044(a2, 0);
      if (sub_1003E453C(a2)) {
        sub_1003E4410(a2);
      }
      sub_10041DD44(a1 + 17, v8, v9);
      sub_100422510(a1);
      break;
    }

    v10 += 40LL;
    v9 += 40LL;
    if (*v8 + 4080LL == v9)
    {
      uint64_t v12 = v8[1];
      ++v8;
      uint64_t v9 = v12;
      goto LABEL_6;
    }
  }

  if (a1[19].i64[1])
  {
    uint64_t v18 = *(void *)(*(void *)(a1[17].i64[1] + 8 * (a1[19].i64[0] / 0x66uLL)) + 40 * (a1[19].i64[0] % 0x66uLL));
    uint64_t v19 = sub_1002E6BF0();
    if (qword_1008D9600 != -1) {
      dispatch_once(&qword_1008D9600, &stru_100897ED8);
    }
    if (sub_10041AC78(qword_1008D95F8, v18))
    {
      uint64_t v20 = (os_log_s *)qword_1008F7578;
      if (os_log_type_enabled((os_log_t)qword_1008F7578, OS_LOG_TYPE_DEFAULT))
      {
        sub_1003CF00C(v18, __p);
        if (v27 >= 0) {
          std::string::size_type v21 = __p;
        }
        else {
          std::string::size_type v21 = (void **)__p[0];
        }
        *(_DWORD *)__int128 buf = 136446210;
        double v30 = v21;
        _os_log_impl( (void *)&_mh_execute_header,  v20,  OS_LOG_TYPE_DEFAULT,  "Skipping next connection for device %{public}s due to SDP in progress for this device",  buf,  0xCu);
        if (v27 < 0) {
          operator delete(__p[0]);
        }
      }
    }

    else
    {
LABEL_45:
      unint64_t v22 = (os_log_s *)qword_1008F7578;
      if (os_log_type_enabled((os_log_t)qword_1008F7578, OS_LOG_TYPE_DEFAULT))
      {
        sub_1003CF00C(v18, __p);
        uint64_t v23 = v27 >= 0 ? __p : (void **)__p[0];
        *(_DWORD *)__int128 buf = 136446210;
        double v30 = v23;
        _os_log_impl( (void *)&_mh_execute_header,  v22,  OS_LOG_TYPE_DEFAULT,  "Connecting to device %{public}s",  buf,  0xCu);
        if (v27 < 0) {
          operator delete(__p[0]);
        }
      }

      if (qword_1008D67E8 != -1) {
        dispatch_once(&qword_1008D67E8, &stru_100897E98);
      }
      sub_1003CA4D8(off_1008D67E0, v18);
      sub_100422B6C((uint64_t)a1, v18, 0xFFFFFFFFLL, 0, 0LL, 0LL, 0);
      sub_1003E4044(v18, 1);
      if (qword_1008D9600 != -1) {
        dispatch_once(&qword_1008D9600, &stru_100897ED8);
      }
      sub_10041AA14( qword_1008D95F8,  v18,  (uint64_t)a1[2].i64,  0,  *(_BYTE *)(*(void *)(a1[17].i64[1] + 8 * (a1[19].i64[0] / 0x66uLL)) + 40 * (a1[19].i64[0] % 0x66uLL) + 28));
    }
  }

  else
  {
    __int16 v24 = (os_log_s *)qword_1008F7578;
    if (os_log_type_enabled((os_log_t)qword_1008F7578, OS_LOG_TYPE_DEFAULT))
    {
      LOWORD(__p[0]) = 0;
      _os_log_impl( (void *)&_mh_execute_header,  v24,  OS_LOG_TYPE_DEFAULT,  "No pending connection to process",  (uint8_t *)__p,  2u);
    }
  }

  return sub_100242FAC((uint64_t)v28);
}

void sub_100423CB8(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, ...)
{
}

uint64_t sub_100423CEC(int64x2_t *a1, unsigned __int8 *a2, uint64_t a3, unsigned int a4, uint64_t a5)
{
  v37[0] = 0LL;
  v37[1] = 0LL;
  sub_100242F28((uint64_t)v37, (uint64_t)&a1[2].i64[1]);
  if (qword_1008D67E8 != -1) {
    dispatch_once(&qword_1008D67E8, &stru_100897E98);
  }
  BOOL v10 = sub_1003CABEC((uint64_t)off_1008D67E0, a2, a3, a4, a5);
  sub_100422B6C((uint64_t)a1, (uint64_t)a2, a3, 0, 11LL, a5, 0);
  if (v10)
  {
    unint64_t v11 = (os_log_s *)qword_1008F7578;
    if (os_log_type_enabled((os_log_t)qword_1008F7578, OS_LOG_TYPE_DEFAULT))
    {
      sub_1003CF00C((uint64_t)a2, &__p);
      int v12 = SHIBYTE(v36);
      int v13 = (void **)__p;
      int v14 = sub_1003D2B2C((uint64_t)a2, 40);
      p_p = &__p;
      if (v12 < 0) {
        p_p = v13;
      }
      *(_DWORD *)__int128 buf = 136446466;
      char v39 = p_p;
      __int16 v40 = 1024;
      int v41 = v14;
      _os_log_impl( (void *)&_mh_execute_header,  v11,  OS_LOG_TYPE_DEFAULT,  "Received all connection results for device %{public}s AACP incoming %d",  buf,  0x12u);
      if (SHIBYTE(v36) < 0) {
        operator delete(__p);
      }
    }

    sub_1003D70B0((uint64_t)a2);
    if (qword_1008D9600 != -1) {
      dispatch_once(&qword_1008D9600, &stru_100897ED8);
    }
    sub_10041ABC8();
    if (qword_1008D67E8 != -1) {
      dispatch_once(&qword_1008D67E8, &stru_100897E98);
    }
    if (qword_1008D67E8 != -1) {
      dispatch_once(&qword_1008D67E8, &stru_100897E98);
    }
    if ((sub_1003C9F70((uint64_t)off_1008D67E0, (uint64_t)a2) & 1) != 0
      || _os_feature_enabled_impl("BluetoothFeatures", "AACPServerConnection")
      && (sub_1003D2B2C((uint64_t)a2, 40) & 1) != 0
      || (sub_100424FFC(a1, (uint64_t)a2, a3) & 1) == 0)
    {
LABEL_22:
      int v17 = (os_log_s *)qword_1008F7578;
      if (os_log_type_enabled((os_log_t)qword_1008F7578, OS_LOG_TYPE_DEFAULT))
      {
        sub_1003CF00C((uint64_t)a2, &__p);
        uint64_t v18 = v36 >= 0 ? &__p : (void **)__p;
        *(_DWORD *)__int128 buf = 136446210;
        char v39 = v18;
        _os_log_impl( (void *)&_mh_execute_header,  v17,  OS_LOG_TYPE_DEFAULT,  "No outgoing or AACP connection queued for device %{public}s",  buf,  0xCu);
        if (SHIBYTE(v36) < 0) {
          operator delete(__p);
        }
      }

      sub_100422B6C((uint64_t)a1, (uint64_t)a2, 0LL, 3, 902LL, 0LL, 0);
      sub_100423730(a1, (uint64_t)a2);
    }

    else
    {
      unint64_t v16 = (os_log_s *)qword_1008F7578;
      if (os_log_type_enabled((os_log_t)qword_1008F7578, OS_LOG_TYPE_DEFAULT))
      {
        LOWORD(__p) = 0;
        _os_log_impl( (void *)&_mh_execute_header,  v16,  OS_LOG_TYPE_DEFAULT,  "outgoing profile connection queud for an incoming connection, Skipping processNextConnection",  (uint8_t *)&__p,  2u);
      }
    }

    int v19 = sub_1003D0070((uint64_t)a2, 0x40000u);
    if (!(_DWORD)a5)
    {
      int v20 = v19;
      if (qword_1008D67E8 != -1) {
        dispatch_once(&qword_1008D67E8, &stru_100897E98);
      }
      char v21 = sub_1003C9F70((uint64_t)off_1008D67E0, (uint64_t)a2);
      if ((_DWORD)a3 == 32) {
        char v22 = 1;
      }
      else {
        char v22 = v21;
      }
      if ((v22 & 1) == 0 && v20 != 4 && sub_100425684((uint64_t)a1, (uint64_t)a2) == (_DWORD)a3)
      {
        if ((sub_1003D2B2C((uint64_t)a2, 12) & 1) != 0 || sub_1003D3900((uint64_t)a2))
        {
          uint64_t v23 = (os_log_s *)qword_1008F7578;
          if (os_log_type_enabled((os_log_t)qword_1008F7578, OS_LOG_TYPE_DEFAULT))
          {
            LOWORD(__p) = 0;
            _os_log_impl( (void *)&_mh_execute_header,  v23,  OS_LOG_TYPE_DEFAULT,  "Skipping missing profiles outgoing path",  (uint8_t *)&__p,  2u);
          }
        }

        else
        {
          uint64_t v24 = a1[6].i64[1];
          v33[0] = _NSConcreteStackBlock;
          v33[1] = 3221225472LL;
          void v33[2] = sub_100425770;
          v33[3] = &unk_10087EB20;
          v33[4] = a2;
          sub_100405460(v24, 7000LL, v33);
        }
      }

      uint64_t v25 = sub_1002E6BF0();
      if ((*(unsigned int (**)(uint64_t, uint64_t))(*(void *)v25 + 48LL))(v25, 16LL))
      {
        if (qword_1008D98A0 != -1) {
          dispatch_once(&qword_1008D98A0, &stru_100897D38);
        }
        if ((*(unsigned int (**)(void *))(*(void *)off_1008D9898 + 112LL))(off_1008D9898))
        {
          std::string __p = 0LL;
          uint64_t v35 = 0LL;
          uint64_t v36 = 0LL;
          if (qword_1008D67E8 != -1) {
            dispatch_once(&qword_1008D67E8, &stru_100897E98);
          }
          sub_1003C9C48((uint64_t)off_1008D67E0, &__p);
          uint64_t v26 = (uint64_t *)__p;
          if (__p != v35)
          {
            int v27 = 0;
            do
            {
              ++v26;
            }

            while (v26 != v35);
            if (v27)
            {
              uint64_t v28 = a1[6].i64[1];
              v31[0] = _NSConcreteStackBlock;
              v31[1] = 3221225472LL;
              void v31[2] = sub_100425B10;
              v31[3] = &unk_10087F980;
              int v32 = v27;
              sub_100405384(v28, v31);
            }

            uint64_t v26 = (uint64_t *)__p;
          }

          if (v26)
          {
            uint64_t v35 = v26;
            operator delete(v26);
          }
        }

        uint64_t v29 = sub_100404EB8();
        sub_100405384(v29, &stru_100897C78);
      }
    }
  }

  return sub_100242FAC((uint64_t)v37);
}

void sub_1004242A8( _Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, void *__p, uint64_t a20, int a21, __int16 a22, char a23, char a24, uint64_t a25, char a26)
{
  if (__p) {
    operator delete(__p);
  }
  sub_100242FAC((uint64_t)&a26);
  _Unwind_Resume(a1);
}

void sub_100424304(uint64_t a1, uint64_t a2, char a3)
{
  uint64_t v3 = *(void *)(a1 + 104);
  v4[0] = _NSConcreteStackBlock;
  v4[1] = 3221225472LL;
  void v4[2] = sub_1004290CC;
  v4[3] = &unk_100886EE0;
  v4[4] = a1;
  void v4[5] = a2;
  char v5 = a3;
  sub_100405384(v3, v4);
}

uint64_t sub_100424360(int64x2_t *a1, uint64_t a2, int a3, const std::string *a4, uint64_t a5)
{
  if (((char)a4->__r_.__value_.__s.__size_ & 0x80000000) == 0)
  {
    BOOL v10 = a4;
    if (!a4->__r_.__value_.__s.__size_) {
      goto LABEL_8;
    }
LABEL_7:
    unint64_t v11 = (__CFString *)objc_claimAutoreleasedReturnValue(+[NSString stringWithUTF8String:](&OBJC_CLASS___NSString, "stringWithUTF8String:", v10));
    goto LABEL_9;
  }

  if (a4->__r_.__value_.__l.__size_)
  {
    BOOL v10 = (const std::string *)a4->__r_.__value_.__r.__words[0];
    goto LABEL_7;
  }

void sub_100424DA8( _Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, char a19, uint64_t a20, char a21, uint64_t a22, void *__p, uint64_t a24, int a25, __int16 a26, char a27, char a28)
{
}

uint64_t sub_100424E54(uint64_t a1, _BYTE *a2)
{
  v5[0] = 0LL;
  v5[1] = 0LL;
  sub_100242F28((uint64_t)v5, a1 + 40);
  sub_100405744(*(void *)(a1 + 104), a2);
  return sub_100242FAC((uint64_t)v5);
}

void sub_100424EA0( _Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9)
{
}

void sub_100424EB4(uint64_t a1, void *a2)
{
  id v3 = a2;
  v4[0] = 0LL;
  v4[1] = 0LL;
  sub_100242F28((uint64_t)v4, a1 + 40);
  sub_100405384(*(void *)(a1 + 104), v3);
  sub_100242FAC((uint64_t)v4);
}

void sub_100424F08( _Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9)
{
  _Unwind_Resume(a1);
}

uint64_t sub_100424F28(uint64_t a1, uint64_t a2, uint64_t a3, unsigned int a4, int a5)
{
  v11[0] = 0LL;
  v11[1] = 0LL;
  sub_100242F28((uint64_t)v11, a1 + 40);
  if (qword_1008D67E8 != -1) {
    dispatch_once(&qword_1008D67E8, &stru_100897E98);
  }
  sub_1003CA780(off_1008D67E0, a2, a3, a4, a5);
  sub_100422B6C(a1, a2, a3, 0, 1LL, 0LL, 0);
  return sub_100242FAC((uint64_t)v11);
}

void sub_100424FE8( _Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9)
{
}

uint64_t sub_100424FFC(int64x2_t *a1, uint64_t a2, int a3)
{
  uint64_t v6 = sub_1002E6BF0();
  uint64_t result = (*(uint64_t (**)(uint64_t, uint64_t))(*(void *)v6 + 48LL))(v6, 0x80000LL);
  if ((_DWORD)result)
  {
    if (qword_1008D9118 != -1) {
      dispatch_once(&qword_1008D9118, &stru_100897DD8);
    }
    if (qword_1008D9118 != -1) {
      dispatch_once(&qword_1008D9118, &stru_100897DD8);
    }
    char v8 = (*(uint64_t (**)(void *, uint64_t))(*(void *)off_1008D9110 + 120LL))(off_1008D9110, a2);
    uint64_t result = 0LL;
    if (a3 != 0x80000 && (v8 & 1) == 0)
    {
      if (qword_1008D9118 != -1) {
        dispatch_once(&qword_1008D9118, &stru_100897DD8);
      }
      if (sub_100213890((uint64_t)off_1008D9110, a2))
      {
        uint64_t v9 = (os_log_s *)qword_1008F7578;
        if (os_log_type_enabled((os_log_t)qword_1008F7578, OS_LOG_TYPE_DEFAULT))
        {
          sub_1003CF00C(a2, &__p);
          BOOL v10 = (__p.__r_.__value_.__s.__size_ & 0x80u) == 0 ? &__p : (std::string *)__p.__r_.__value_.__r.__words[0];
          LODWORD(buf) = 136446210;
          *(void *)((char *)&buf + 4) = v10;
          _os_log_impl( (void *)&_mh_execute_header,  v9,  OS_LOG_TYPE_DEFAULT,  "Remove %{public}s from stale AACP connection device list and return false",  (uint8_t *)&buf,  0xCu);
        }

        if (qword_1008D9118 != -1) {
          dispatch_once(&qword_1008D9118, &stru_100897DD8);
        }
        sub_1002138C4(off_1008D9110, a2);
        return 0LL;
      }

      v34[0] = 0LL;
      v34[1] = 0LL;
      sub_100242F28((uint64_t)v34, (uint64_t)a1[13].i64);
      unint64_t v11 = a1[19].u64[0];
      uint64_t v12 = a1[17].i64[1];
      uint64_t v13 = a1[18].i64[0];
      int v14 = (void *)(v12 + 8 * (v11 / 0x66));
      if (v13 == v12) {
        unint64_t v15 = 0LL;
      }
      else {
        unint64_t v15 = *v14 + 40 * (v11 % 0x66);
      }
LABEL_27:
      unint64_t v16 = v15 - 4080;
      while (1)
      {
        if (v13 == v12) {
          unint64_t v17 = 0LL;
        }
        else {
          unint64_t v17 = *(void *)(v12 + 8 * ((a1[19].i64[1] + v11) / 0x66)) + 40 * ((a1[19].i64[1] + v11) % 0x66);
        }
        if (v15 == v17) {
          goto LABEL_48;
        }
        if (*(void *)v15 == a2 && (*(_BYTE *)(v15 + 26) & 8) != 0) {
          break;
        }
        v15 += 40LL;
        v16 += 40LL;
        if (*v14 == v16)
        {
          unint64_t v18 = v14[1];
          ++v14;
          unint64_t v15 = v18;
          goto LABEL_27;
        }
      }

      if (qword_1008D67E8 != -1) {
        dispatch_once(&qword_1008D67E8, &stru_100897E98);
      }
      if ((sub_1003CA0E8((uint64_t)off_1008D67E0, a2) & 0x80000) == 0)
      {
        if (qword_1008D67E8 != -1) {
          dispatch_once(&qword_1008D67E8, &stru_100897E98);
        }
        if (sub_1003CA060((uint64_t)off_1008D67E0, a2, 0x80000))
        {
          int v19 = (os_log_s *)qword_1008F7578;
          int v20 = 0;
          if (!os_log_type_enabled((os_log_t)qword_1008F7578, OS_LOG_TYPE_DEFAULT)) {
            goto LABEL_56;
          }
          sub_1003CF00C(a2, &__p);
          if ((__p.__r_.__value_.__s.__size_ & 0x80u) == 0) {
            p_p = &__p;
          }
          else {
            p_p = (std::string *)__p.__r_.__value_.__r.__words[0];
          }
          LODWORD(buf) = 136446210;
          *(void *)((char *)&buf + 4) = p_p;
          _os_log_impl( (void *)&_mh_execute_header,  v19,  OS_LOG_TYPE_DEFAULT,  "Connection request list for %{public}s has AACP -- Condition for waiting not met",  (uint8_t *)&buf,  0xCu);
LABEL_48:
          int v20 = 0;
          goto LABEL_56;
        }
      }

      int v22 = (os_log_s *)qword_1008F7578;
      if (os_log_type_enabled((os_log_t)qword_1008F7578, OS_LOG_TYPE_DEFAULT))
      {
        sub_1003CF00C(a2, &__p);
        uint64_t v23 = (__p.__r_.__value_.__s.__size_ & 0x80u) == 0 ? &__p : (std::string *)__p.__r_.__value_.__r.__words[0];
        LODWORD(buf) = 136446210;
        *(void *)((char *)&buf + 4) = v23;
        _os_log_impl( (void *)&_mh_execute_header,  v22,  OS_LOG_TYPE_DEFAULT,  "Connection request list for %{public}s has AACP pending -- Wait for it to complete",  (uint8_t *)&buf,  0xCu);
      }

      int v20 = 1;
LABEL_56:
      uint64_t v24 = a1[17].i64[1];
      if (a1[18].i64[0] == v24)
      {
        unint64_t v26 = 0LL;
      }

      else
      {
        unint64_t v25 = a1[19].i64[1] + a1[19].i64[0];
        unint64_t v26 = *(void *)(v24 + 8 * (v25 / 0x66)) + 40 * (v25 % 0x66);
      }

      if (v15 == v26)
      {
        __int128 buf = 0uLL;
        uint64_t v38 = 0LL;
        if (qword_1008D9148 != -1) {
          dispatch_once(&qword_1008D9148, &stru_100897F38);
        }
        sub_100586960((uint64_t)off_1008D9140, (void **)&buf);
        unsigned int v27 = 16;
        if (!sub_1003FE254((uint64_t)&buf, a2))
        {
          std::string::size_type v28 = a1[19].u64[1];
          if (v28) {
            unsigned int v27 = 16;
          }
          else {
            unsigned int v27 = 8;
          }
          uint64_t v29 = (os_log_s *)qword_1008F7578;
          if (os_log_type_enabled((os_log_t)qword_1008F7578, OS_LOG_TYPE_DEFAULT))
          {
            sub_1003CF00C(a2, v32);
            double v30 = v33 >= 0 ? v32 : (void **)v32[0];
            LODWORD(__p.__r_.__value_.__l.__data_) = 134218498;
            *(std::string::size_type *)((char *)__p.__r_.__value_.__r.__words + 4) = v28;
            WORD2(__p.__r_.__value_.__r.__words[1]) = 2082;
            *(std::string::size_type *)((char *)&__p.__r_.__value_.__r.__words[1] + 6) = (std::string::size_type)v30;
            HIWORD(__p.__r_.__value_.__r.__words[2]) = 1024;
            unsigned int v36 = v27;
            _os_log_impl( (void *)&_mh_execute_header,  v29,  OS_LOG_TYPE_DEFAULT,  "Connection request queue size is %luu. Initite AACP client connection request for %{public}s using watchdo g stall timeout as %d seconds",  (uint8_t *)&__p,  0x1Cu);
            if (v33 < 0) {
              operator delete(v32[0]);
            }
          }

          memset(&__p, 0, sizeof(__p));
          int v31 = sub_100424360(a1, a2, 0x80000, &__p, 2LL);
          if (!v31) {
            int v20 = 1;
          }
        }

        if ((void)buf)
        {
          *((void *)&buf + 1) = buf;
          operator delete((void *)buf);
        }
      }

      else
      {
        unsigned int v27 = 16;
      }

      sub_100242FAC((uint64_t)v34);
      if (!v20) {
        return 0LL;
      }
      if (!sub_1003E453C(a2)) {
        sub_1003E40CC(a2, v27);
      }
      return 1LL;
    }
  }

  return result;
}

void sub_10042562C( _Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, char a13, uint64_t a14, void *a15, uint64_t a16, int a17, __int16 a18, char a19, char a20, uint64_t a21, void *__p, uint64_t a23)
{
}

uint64_t sub_100425684(uint64_t a1, uint64_t a2)
{
  v11[0] = 0LL;
  v11[1] = 0LL;
  sub_100242F28((uint64_t)v11, a1 + 120);
  uint64_t v8 = 0LL;
  uint64_t v9 = 0LL;
  uint64_t v10 = 0LL;
  sub_10042AC38(&v8, a1 + 184);
  sub_100242F54((uint64_t)v11);
  uint64_t v4 = v9;
  if (v9 == &v8)
  {
    uint64_t v5 = 0LL;
  }

  else
  {
    uint64_t v5 = 0LL;
    do
    {
      uint64_t v6 = (_DWORD *)v4[2];
      uint64_t v4 = (uint64_t *)v4[1];
    }

    while (v4 != &v8);
  }

  sub_10023DF50(&v8);
  sub_100242FAC((uint64_t)v11);
  return v5;
}

void sub_100425748(_Unwind_Exception *a1, uint64_t a2, ...)
{
  uint64_t v3 = va_arg(va1, void);
  uint64_t v5 = va_arg(va1, void);
  uint64_t v6 = va_arg(va1, void);
  sub_10023DF50((uint64_t *)va);
  sub_100242FAC((uint64_t)va1);
  _Unwind_Resume(a1);
}

uint64_t sub_100425770(uint64_t a1)
{
  if (qword_1008D60D0 != -1) {
    dispatch_once(&qword_1008D60D0, &stru_100897EF8);
  }
  return sub_1004257C0((int64x2_t *)off_1008D60C8, *(void *)(a1 + 32));
}

uint64_t sub_1004257C0(int64x2_t *a1, uint64_t a2)
{
  char v4 = sub_100425684((uint64_t)a1, a2);
  int v5 = 25;
  uint64_t result = sub_1003D518C(a2);
  if ((_DWORD)result)
  {
    uint64_t result = sub_1004272C4((uint64_t)a1, a2);
    int v5 = result & 0x19;
  }

  if ((v4 & 0x19) != 0)
  {
    unsigned int v7 = v5 & ~(v4 & 0x19);
    if (v7)
    {
      uint64_t v8 = (os_log_s *)qword_1008F7578;
      if (os_log_type_enabled((os_log_t)qword_1008F7578, OS_LOG_TYPE_DEFAULT))
      {
        if ((v7 & 1) != 0) {
          uint64_t v9 = " HFP";
        }
        else {
          uint64_t v9 = "";
        }
        if (v7 >= 0x10) {
          uint64_t v10 = " A2DP";
        }
        else {
          uint64_t v10 = "";
        }
        if ((v7 & 8) != 0) {
          unint64_t v11 = " AVRCP";
        }
        else {
          unint64_t v11 = "";
        }
        if ((v4 & 1) != 0) {
          uint64_t v12 = " HFP";
        }
        else {
          uint64_t v12 = "";
        }
        if ((v4 & 0x10) != 0) {
          uint64_t v13 = " A2DP";
        }
        else {
          uint64_t v13 = "";
        }
        if ((v4 & 8) != 0) {
          int v14 = " AVRCP";
        }
        else {
          int v14 = "";
        }
        sub_1003CF00C(a2, __p);
        unint64_t v15 = __p;
        if (v23 < 0) {
          unint64_t v15 = *(_BYTE **)__p;
        }
        *(_DWORD *)__int128 buf = 136448003;
        *(void *)&uint8_t buf[4] = v9;
        __int16 v25 = 2082;
        *(void *)unint64_t v26 = v10;
        *(_WORD *)&v26[8] = 2082;
        unsigned int v27 = v11;
        *(_WORD *)std::string::size_type v28 = 2082;
        *(void *)&void v28[2] = v12;
        __int16 v29 = 2082;
        double v30 = v13;
        __int16 v31 = 2082;
        int v32 = v14;
        __int16 v33 = 2160;
        uint64_t v34 = 1752392040LL;
        __int16 v35 = 2081;
        unsigned int v36 = v15;
        _os_log_impl( (void *)&_mh_execute_header,  v8,  OS_LOG_TYPE_DEFAULT,  "Forcing connection of%{public}s%{public}s%{public}s after incoming connection of only%{public}s%{public}s%{pub lic}s for device %{private, mask.hash}s",  buf,  0x52u);
        if (v23 < 0) {
          operator delete(*(void **)__p);
        }
      }

      v19[0] = 0LL;
      v19[1] = 0LL;
      sub_100242F28((uint64_t)v19, (uint64_t)a1[13].i64);
      *(void *)__int128 buf = a2;
      *(_DWORD *)&uint8_t buf[8] = 0;
      *(void *)&void v26[2] = 0LL;
      LODWORD(v27) = v7;
      BYTE4(v27) = 2;
      *(void *)std::string::size_type v28 = mach_continuous_time();
      sub_10041D048((int64x2_t *)a1[17].i64, (uint64_t)buf);
      unint64_t v16 = (os_log_s *)qword_1008F7578;
      if (os_log_type_enabled((os_log_t)qword_1008F7578, OS_LOG_TYPE_DEFAULT))
      {
        sub_1003CF00C(a2, buf);
        unint64_t v17 = v26[9] >= 0 ? buf : *(_BYTE **)buf;
        *(_DWORD *)std::string __p = 136446466;
        *(void *)&__p[4] = v17;
        __int16 v21 = 1024;
        unsigned int v22 = v7;
        _os_log_impl( (void *)&_mh_execute_header,  v16,  OS_LOG_TYPE_DEFAULT,  "Added device %{public}s to the connction request queue for the missing services 0x%x",  __p,  0x12u);
        if ((v26[9] & 0x80000000) != 0) {
          operator delete(*(void **)buf);
        }
      }

      sub_100422510(a1);
      sub_100242F54((uint64_t)v19);
      if (qword_1008D67E8 != -1) {
        dispatch_once(&qword_1008D67E8, &stru_100897E98);
      }
      if ((sub_1003C9BD4((uint64_t)off_1008D67E0) & 1) == 0)
      {
        unint64_t v18 = (os_log_s *)qword_1008F7578;
        if (os_log_type_enabled((os_log_t)qword_1008F7578, OS_LOG_TYPE_DEFAULT))
        {
          *(_WORD *)__int128 buf = 0;
          _os_log_impl( (void *)&_mh_execute_header,  v18,  OS_LOG_TYPE_DEFAULT,  "No device currently connecting. lets process nexct connection",  buf,  2u);
        }

        sub_100423730(a1, 0LL);
      }

      return sub_100242FAC((uint64_t)v19);
    }
  }

  return result;
}

void sub_100425AE8( _Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9)
{
}

uint64_t sub_100425B10(uint64_t a1)
{
  uint64_t v2 = sub_1002E6E9C();
  return (*(uint64_t (**)(uint64_t, void))(*(void *)v2 + 64LL))(v2, *(unsigned int *)(a1 + 32));
}

void sub_100425B3C(id a1)
{
  uint64_t v1 = sub_1002E6E9C();
  (*(void (**)(uint64_t, uint64_t, uint64_t))(*(void *)v1 + 200LL))(v1, 1LL, 1LL);
}

uint64_t sub_100425B60(uint64_t a1, uint64_t a2, uint64_t a3)
{
  v7[0] = 0LL;
  v7[1] = 0LL;
  sub_100242F28((uint64_t)v7, a1 + 40);
  sub_100422B6C(a1, a2, a3, 1, 2LL, 0LL, 0);
  return sub_100242FAC((uint64_t)v7);
}

void sub_100425BCC( _Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9)
{
}

uint64_t sub_100425BE0( uint64_t a1, unsigned __int8 *a2, uint64_t a3, unsigned int a4, uint64_t a5, unsigned int a6)
{
  int v71 = a3;
  v70[0] = 0LL;
  v70[1] = 0LL;
  sub_100242F28((uint64_t)v70, a1 + 40);
  if (qword_1008D67E8 != -1) {
    dispatch_once(&qword_1008D67E8, &stru_100897E98);
  }
  unsigned int v65 = a4;
  sub_1003CB234((uint64_t)off_1008D67E0, (uint64_t)a2, a3, a4, a5, a6);
  sub_100422B6C(a1, (uint64_t)a2, a3, 1, 12LL, a5, a6);
  int v64 = a5;
  unsigned int v66 = a6;
  if ((_DWORD)a3 == 0x80000)
  {
    unint64_t v12 = *(void *)(a1 + 304);
    uint64_t v13 = *(void *)(a1 + 280);
    uint64_t v14 = *(void *)(a1 + 288);
    unint64_t v15 = (void *)(v13 + 8 * (v12 / 0x66));
    if (v14 == v13) {
      unint64_t v16 = 0LL;
    }
    else {
      unint64_t v16 = *v15 + 40 * (v12 % 0x66);
    }
    while (1)
    {
      if (v14 == v13)
      {
        unint64_t v18 = 0LL;
      }

      else
      {
        unint64_t v17 = *(void *)(a1 + 312) + *(void *)(a1 + 304);
        unint64_t v18 = *(void *)(v13 + 8 * (v17 / 0x66)) + 40 * (v17 % 0x66);
      }

      if (v16 == v18) {
        break;
      }
      if (*(unsigned __int8 **)v16 == a2 && *(_DWORD *)(v16 + 24) == 0x80000)
      {
        int v19 = (os_log_s *)qword_1008F7578;
        if (os_log_type_enabled((os_log_t)qword_1008F7578, OS_LOG_TYPE_DEFAULT))
        {
          LOWORD(buf.__r_.__value_.__l.__data_) = 0;
          _os_log_impl( (void *)&_mh_execute_header,  v19,  OS_LOG_TYPE_DEFAULT,  "Stale request for service connection request (AACP only), add device to staleAACPConnReqDevList",  (uint8_t *)&buf,  2u);
        }

        if (qword_1008D9118 != -1) {
          dispatch_once(&qword_1008D9118, &stru_100897DD8);
        }
        sub_100213770(off_1008D9110, (uint64_t)a2);
      }

      v16 += 40LL;
      if (v16 - *v15 == 4080)
      {
        unint64_t v20 = v15[1];
        ++v15;
        unint64_t v16 = v20;
      }

      uint64_t v13 = *(void *)(a1 + 280);
      uint64_t v14 = *(void *)(a1 + 288);
    }
  }

  int v21 = a3;
  if ((_DWORD)a3 == 16)
  {
    uint64_t v22 = *(void *)(a1 + 104);
    v69[0] = _NSConcreteStackBlock;
    v69[1] = 3221225472LL;
    v69[2] = sub_100426568;
    v69[3] = &unk_10087EB20;
    v69[4] = a2;
    sub_100405384(v22, v69);
  }

  uint64_t v23 = sub_1002E6BF0();
  if ((*(unsigned int (**)(uint64_t, uint64_t))(*(void *)v23 + 48LL))(v23, 16LL))
  {
    if (qword_1008D98A0 != -1) {
      dispatch_once(&qword_1008D98A0, &stru_100897D38);
    }
    if (!(*(unsigned int (**)(void *))(*(void *)off_1008D9898 + 112LL))(off_1008D9898))
    {
LABEL_37:
      uint64_t v26 = *(void *)(a1 + 104);
      v67[0] = _NSConcreteStackBlock;
      v67[1] = 3221225472LL;
      v67[2] = sub_1004265C0;
      v67[3] = &unk_10087F980;
      int v68 = 0;
      sub_100405384(v26, v67);
LABEL_38:
      if (v21 == 16)
      {
        if (qword_1008D98A0 != -1) {
          dispatch_once(&qword_1008D98A0, &stru_100897D38);
        }
        if (((*(uint64_t (**)(void *))(*(void *)off_1008D9898 + 112LL))(off_1008D9898) & 1) == 0)
        {
          uint64_t v27 = sub_100404EB8();
          sub_100405384(v27, &stru_100897C98);
        }
      }

      goto LABEL_43;
    }

    memset(&buf, 0, sizeof(buf));
    if (qword_1008D67E8 != -1) {
      dispatch_once(&qword_1008D67E8, &stru_100897E98);
    }
    sub_1003C9C48((uint64_t)off_1008D67E0, (void **)&buf.__r_.__value_.__l.__data_);
    uint64_t v24 = (void *)buf.__r_.__value_.__r.__words[0];
    if (buf.__r_.__value_.__r.__words[0] == buf.__r_.__value_.__l.__size_)
    {
      int v25 = 0;
      if (buf.__r_.__value_.__r.__words[0])
      {
LABEL_35:
        buf.__r_.__value_.__l.__size_ = (std::string::size_type)v24;
        operator delete(v24);
      }
    }

    else
    {
      int v25 = 0;
      do
      {
        if ((sub_100425684(a1, *v24) & 0x10) == 0) {
          v25 += sub_10011257C(*v24 + 128LL) ^ 1;
        }
        ++v24;
      }

      while (v24 != (void *)buf.__r_.__value_.__l.__size_);
      uint64_t v24 = (void *)buf.__r_.__value_.__r.__words[0];
      if (buf.__r_.__value_.__r.__words[0]) {
        goto LABEL_35;
      }
    }

    int v21 = a3;
    if (v25) {
      goto LABEL_38;
    }
    goto LABEL_37;
  }

void sub_1004264EC( _Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20, uint64_t a21, char a22, uint64_t a23, uint64_t a24, uint64_t a25, uint64_t a26, int a27, __int16 a28, char a29, char a30, uint64_t a31, void *__p, uint64_t a33, int a34, __int16 a35, char a36, char a37)
{
}

uint64_t sub_100426568(uint64_t a1)
{
  if (qword_1008D98B0 != -1) {
    dispatch_once(&qword_1008D98B0, &stru_100897D58);
  }
  return (*(uint64_t (**)(void *, void))(*(void *)off_1008D98A8 + 88LL))( off_1008D98A8,  *(void *)(a1 + 32));
}

uint64_t sub_1004265C0(uint64_t a1)
{
  uint64_t v2 = sub_1002E6E9C();
  return (*(uint64_t (**)(uint64_t, void))(*(void *)v2 + 64LL))(v2, *(unsigned int *)(a1 + 32));
}

void sub_1004265EC(id a1)
{
  uint64_t v1 = sub_1002E6E9C();
  (*(void (**)(uint64_t, uint64_t, uint64_t))(*(void *)v1 + 200LL))(v1, 2LL, 1LL);
}

const char *sub_100426610(int *a1)
{
  int v1 = *a1;
  if (*a1 > 2047)
  {
    if (v1 < 0x8000)
    {
      if (v1 >= 0x2000)
      {
        if (v1 == 0x2000) {
          return "Braille";
        }
        if (v1 == 0x4000) {
          return "Passive Multi Stream";
        }
      }

      else
      {
        if (v1 == 2048) {
          return "Gaming";
        }
        if (v1 == 4096) {
          return "Network (Client)";
        }
      }
    }

    else if (v1 < 0x20000)
    {
      if (v1 == 0x8000) {
        return "GATT (Client)";
      }
      if (v1 == 0x10000) {
        return "LE Audio";
      }
    }

    else
    {
      switch(v1)
      {
        case 0x20000:
          return "WirelessiAPSink";
        case 0x80000:
          return "AACP";
        case 0x100000:
          return "GATT";
      }
    }

    return "Unknown";
  }

  if (v1 > 31)
  {
    if (v1 > 255)
    {
      if (v1 == 256) {
        return "Network (Server)";
      }
      if (v1 == 512) {
        return "MAP";
      }
    }

    else
    {
      if (v1 == 32) {
        return "HID";
      }
      if (v1 == 128) {
        return "WirelessiAP";
      }
    }

    return "Unknown";
  }

  uint64_t result = "Handsfree";
  switch(v1)
  {
    case -1:
      uint64_t result = "ALL";
      break;
    case 0:
    case 3:
    case 4:
    case 5:
    case 6:
    case 7:
      return "Unknown";
    case 1:
      return result;
    case 2:
      uint64_t result = "Phonebook";
      break;
    case 8:
      uint64_t result = "Remote";
      break;
    default:
      if (v1 != 16) {
        return "Unknown";
      }
      uint64_t result = "A2DP";
      break;
  }

  return result;
}

uint64_t sub_1004267B0(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6)
{
  v12[0] = 0LL;
  v12[1] = 0LL;
  sub_100242F28((uint64_t)v12, a1 + 40);
  sub_100422B6C(a1, a2, a3, 2, a5, a6, 0);
  return sub_100242FAC((uint64_t)v12);
}

void sub_10042682C( _Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9)
{
}

void sub_100426840(uint64_t a1)
{
}

void sub_10042684C(uint64_t a1, uint64_t a2)
{
  if (*(_BYTE *)(a1 + 114))
  {
    uint64_t v2 = (os_log_s *)qword_1008F7578;
    if (os_log_type_enabled((os_log_t)qword_1008F7578, OS_LOG_TYPE_ERROR)) {
      sub_10067DDF4(v2, v3, v4);
    }
  }

  else
  {
    v20[0] = 0LL;
    v20[1] = 0LL;
    sub_100242F28((uint64_t)v20, a1 + 208);
    uint64_t v7 = *(void *)(a1 + 312);
    if (v7)
    {
      uint64_t v8 = *(void *)(a1 + 280);
      if (*(void *)(a1 + 288) != v8)
      {
        unint64_t v9 = *(void *)(a1 + 304);
        uint64_t v10 = (void *)(v8 + 8 * (v9 / 0x66));
        unint64_t v11 = (void *)(*v10 + 40 * (v9 % 0x66));
        unint64_t v12 = *(void *)(v8 + 8 * ((v9 + v7) / 0x66)) + 40 * ((v9 + v7) % 0x66);
        while (v11 != (void *)v12)
        {
          if (*v11 == a2)
          {
            uint64_t v13 = v11[4];
            uint64_t v14 = mach_continuous_time();
            if ((unint64_t)UpTicksToSeconds(v14 - v13) >= 0x3C)
            {
              uint64_t v17 = *(void *)(a1 + 104);
              v19[0] = _NSConcreteStackBlock;
              v19[1] = 3221225472LL;
              void v19[2] = sub_10042A508;
              v19[3] = &unk_10087F8E0;
              v19[4] = a1;
              v19[5] = a2;
              sub_100405384(v17, v19);
              goto LABEL_14;
            }
          }

          v11 += 5;
          if ((void *)((char *)v11 - *v10) == (void *)4080)
          {
            unint64_t v15 = (void *)v10[1];
            ++v10;
            unint64_t v11 = v15;
          }
        }
      }
    }

    unint64_t v16 = (os_log_s *)qword_1008F7578;
    if (os_log_type_enabled((os_log_t)qword_1008F7578, OS_LOG_TYPE_INFO))
    {
      *(_WORD *)unint64_t v18 = 0;
      _os_log_impl( (void *)&_mh_execute_header,  v16,  OS_LOG_TYPE_INFO,  "No device stalls detected in Service Manager",  v18,  2u);
    }

void sub_1004269F8( _Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, ...)
{
}

void sub_100426A10(uint64_t a1, uint64_t a2, int a3, char a4)
{
  if (!a3)
  {
LABEL_47:
    if (qword_1008D67E8 != -1) {
      dispatch_once(&qword_1008D67E8, &stru_100897E98);
    }
    sub_1003CA4D8(off_1008D67E0, a2);
    if (qword_1008D9600 != -1) {
      dispatch_once(&qword_1008D9600, &stru_100897ED8);
    }
    sub_10041AA14(qword_1008D95F8, a2, a1 + 32, 0, a4);
    return;
  }

  unsigned __int8 v34 = 0;
  uint64_t v7 = sub_1002E6E00();
  if ((*(unsigned int (**)(uint64_t))(*(void *)v7 + 8LL))(v7))
  {
    uint64_t v8 = sub_1002E6E00();
    sub_10002418C(buf, "FastConnect");
    sub_10002418C(&__p, "DisableFastConnect");
    (*(void (**)(uint64_t, _BYTE *, void **, unsigned __int8 *))(*(void *)v8 + 72LL))(v8, buf, &__p, &v34);
    if (SHIBYTE(v33) < 0) {
      operator delete(__p);
    }
    if (SHIBYTE(v41) < 0) {
      operator delete(*(void **)buf);
    }
    unint64_t v9 = (os_log_s *)qword_1008F7578;
    if (os_log_type_enabled((os_log_t)qword_1008F7578, OS_LOG_TYPE_DEFAULT))
    {
      *(_DWORD *)std::string buf = 67109120;
      *(_DWORD *)&uint8_t buf[4] = v34;
      _os_log_impl( (void *)&_mh_execute_header,  v9,  OS_LOG_TYPE_DEFAULT,  "Outgoing Connection, disableFastConnect = %d",  buf,  8u);
    }
  }

  uint64_t v10 = (os_log_s *)qword_1008F7578;
  if (os_log_type_enabled((os_log_t)qword_1008F7578, OS_LOG_TYPE_DEFAULT))
  {
    int v11 = sub_1003D2B2C(a2, 21);
    *(_DWORD *)std::string buf = 67109120;
    *(_DWORD *)&uint8_t buf[4] = v11;
    _os_log_impl( (void *)&_mh_execute_header,  v10,  OS_LOG_TYPE_DEFAULT,  "startConnectServices supportsProfileFastConnect:%d",  buf,  8u);
  }

  __int128 v30 = xmmword_1006C2CD0;
  std::string __p = 0LL;
  int v32 = 0LL;
  uint64_t v33 = 0LL;
  if (sub_1003D4C9C(a2, (uint64_t)&v30, 0x201u, &__p))
  {
    if (*(_BYTE *)__p == 1) {
      int v12 = *((_DWORD *)__p + 2);
    }
    else {
      int v12 = 0;
    }
  }

  else
  {
    int v12 = 0;
  }

  if (v34) {
    goto LABEL_17;
  }
  if (qword_1008D67E8 != -1) {
    dispatch_once(&qword_1008D67E8, &stru_100897E98);
  }
  if (sub_1003C9FF4((uint64_t)off_1008D67E0, a2))
  {
LABEL_92:
    if (qword_1008D9148 != -1) {
      dispatch_once(&qword_1008D9148, &stru_100897F38);
    }
    if (qword_1008D67E8 != -1) {
      dispatch_once(&qword_1008D67E8, &stru_100897E98);
    }
  }

  int v23 = sub_1003D2B2C(a2, 12);
  int v24 = v12 ? v23 : 0;
  if (v24 != 1)
  {
LABEL_17:
    uint64_t v13 = (os_log_s *)qword_1008F7578;
    if (os_log_type_enabled((os_log_t)qword_1008F7578, OS_LOG_TYPE_DEFAULT))
    {
      sub_1003CF00C(a2, v35);
      if (v36 >= 0) {
        uint64_t v14 = v35;
      }
      else {
        uint64_t v14 = *(_BYTE **)v35;
      }
      if (qword_1008D67E8 != -1) {
        dispatch_once(&qword_1008D67E8, &stru_100897E98);
      }
      BOOL v15 = sub_1003C9FF4((uint64_t)off_1008D67E0, a2) != 0;
      if (qword_1008D67E8 != -1) {
        dispatch_once(&qword_1008D67E8, &stru_100897E98);
      }
      int v16 = sub_1003CA15C((uint64_t)off_1008D67E0, a2);
      if (qword_1008D9148 != -1) {
        dispatch_once(&qword_1008D9148, &stru_100897F38);
      }
      int v17 = sub_10057F71C((uint64_t)off_1008D9140, a2);
      *(_DWORD *)std::string buf = 136447234;
      *(void *)&uint8_t buf[4] = v14;
      __int16 v38 = 1024;
      BOOL v39 = v15;
      __int16 v40 = 1024;
      int v41 = v12;
      __int16 v42 = 1024;
      int v43 = v16;
      __int16 v44 = 1024;
      int v45 = v17;
      _os_log_impl( (void *)&_mh_execute_header,  v13,  OS_LOG_TYPE_DEFAULT,  "Did not do PFC for device %{public}s. Connection for device exits: %d, SDP service database state: %d, service c onnected:%d, PFCALL:%d",  buf,  0x24u);
      if (v36 < 0) {
        operator delete(*(void **)v35);
      }
    }

    if (!v34)
    {
      if (qword_1008D9148 != -1) {
        dispatch_once(&qword_1008D9148, &stru_100897F38);
      }
      int v18 = sub_10057F71C((uint64_t)off_1008D9140, a2);
      int v19 = v12 ? 0 : v18;
      if (v19 == 1)
      {
        unint64_t v20 = (os_log_s *)qword_1008F7578;
        if (os_log_type_enabled((os_log_t)qword_1008F7578, OS_LOG_TYPE_DEFAULT))
        {
          *(_WORD *)std::string buf = 0;
          _os_log_impl( (void *)&_mh_execute_header,  v20,  OS_LOG_TYPE_DEFAULT,  "No SDP record but both supports PFC all, start PFC after SDP",  buf,  2u);
        }

        if (qword_1008D9148 != -1) {
          dispatch_once(&qword_1008D9148, &stru_100897F38);
        }
        char v21 = 1;
        goto LABEL_43;
      }
    }

    if (qword_1008D9148 == -1)
    {
      char v21 = 0;
LABEL_43:
      *((_BYTE *)off_1008D9140 + 682) = v21;
      char v22 = 1;
      goto LABEL_44;
    }

void sub_10042715C( _Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, void *__p, uint64_t a14, int a15, __int16 a16, char a17, char a18, uint64_t a19, void *a20, uint64_t a21, int a22, __int16 a23, char a24, char a25, uint64_t a26, uint64_t a27, uint64_t a28, int a29, __int16 a30, char a31, char a32)
{
  if (__p) {
    operator delete(__p);
  }
  _Unwind_Resume(exception_object);
}

uint64_t sub_1004271D4(uint64_t a1, unsigned __int8 *a2)
{
  uint64_t v4 = (os_log_s *)qword_1008F7578;
  if (os_log_type_enabled((os_log_t)qword_1008F7578, OS_LOG_TYPE_DEFAULT))
  {
    sub_1003FE1B4(a2, __p);
    if (v9 >= 0) {
      int v5 = __p;
    }
    else {
      int v5 = (void **)__p[0];
    }
    *(_DWORD *)std::string buf = 136446210;
    int v11 = v5;
    _os_log_impl( (void *)&_mh_execute_header,  v4,  OS_LOG_TYPE_DEFAULT,  "delayedConnectServices addr %{public}s",  buf,  0xCu);
    if (v9 < 0) {
      operator delete(__p[0]);
    }
  }

  int v6 = *(_DWORD *)a2;
  *(_WORD *)(a1 + 70sub_100414D2C(qword_1008F72C0, 0) = *((_WORD *)a2 + 2);
  *(_DWORD *)(a1 + 696) = v6;
  return 0LL;
}

uint64_t sub_1004272C4(uint64_t a1, uint64_t a2)
{
  v11[0] = 0LL;
  v11[1] = 0LL;
  sub_100242F28((uint64_t)v11, a1 + 120);
  uint64_t v8 = 0LL;
  char v9 = 0LL;
  uint64_t v10 = 0LL;
  sub_10042AC38(&v8, a1 + 184);
  sub_100242F54((uint64_t)v11);
  uint64_t v4 = v9;
  if (v9 == &v8)
  {
    uint64_t v5 = 0LL;
  }

  else
  {
    uint64_t v5 = 0LL;
    do
    {
      int v6 = (_DWORD *)v4[2];
      uint64_t v4 = (uint64_t *)v4[1];
    }

    while (v4 != &v8);
  }

  sub_10023DF50(&v8);
  sub_100242FAC((uint64_t)v11);
  return v5;
}

void sub_100427388(_Unwind_Exception *a1, uint64_t a2, ...)
{
  uint64_t v3 = va_arg(va1, void);
  uint64_t v5 = va_arg(va1, void);
  uint64_t v6 = va_arg(va1, void);
  sub_10023DF50((uint64_t *)va);
  sub_100242FAC((uint64_t)va1);
  _Unwind_Resume(a1);
}

_BYTE *sub_1004273B0(uint64_t a1, unsigned __int8 *a2, uint64_t a3, int a4)
{
  char v10 = 1;
  char v9 = 0;
  sub_100242CA4(&v9);
  sub_1001E6110((uint64_t)(a2 + 128), (BOOL *)&v10);
  sub_100242CD0(&v9);
  if (((a4 & 1) != 0 || !v10) && (sub_1003CF350(a2) & 1) == 0 && !sub_1003D2AF4((uint64_t)a2))
  {
    uint64_t v7 = (os_log_s *)qword_1008F7578;
    if (os_log_type_enabled((os_log_t)qword_1008F7578, OS_LOG_TYPE_DEFAULT))
    {
      *(_DWORD *)std::string buf = 67109376;
      int v12 = a4;
      __int16 v13 = 1024;
      int v14 = v10;
      _os_log_impl( (void *)&_mh_execute_header,  v7,  OS_LOG_TYPE_DEFAULT,  "Sleep workaround after SDP due device-database %d, remote ssp %d",  buf,  0xEu);
    }

    sub_1000B0964(1800);
  }

  if (qword_1008D60D0 != -1) {
    dispatch_once(&qword_1008D60D0, &stru_100897EF8);
  }
  sub_100427524((int64x2_t *)off_1008D60C8, a2, a3);
  return sub_100242CD8(&v9);
}

void sub_100427508( _Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, int a10, __int16 a11, char a12)
{
}

uint64_t sub_100427524(int64x2_t *a1, unsigned __int8 *a2, uint64_t a3)
{
  if (!(_DWORD)a3)
  {
    v88[0] = 0LL;
    v88[1] = 0LL;
    sub_100242F28((uint64_t)v88, (uint64_t)a1[13].i64);
    uint64_t v7 = a1[19].i64[1];
    if (!v7)
    {
      if (qword_1008D67E8 != -1) {
        dispatch_once(&qword_1008D67E8, &stru_100897E98);
      }
      sub_1003CA640((uint64_t)off_1008D67E0, (uint64_t)a2, 0);
      if (qword_1008D9600 != -1) {
        dispatch_once(&qword_1008D9600, &stru_100897ED8);
      }
      sub_10041ABC8();
      __int16 v13 = (os_log_s *)qword_1008F7578;
      if (os_log_type_enabled((os_log_t)qword_1008F7578, OS_LOG_TYPE_DEFAULT))
      {
        sub_1003CF00C((uint64_t)a2, v94);
        int v14 = v94[23] >= 0 ? v94 : *(_BYTE **)v94;
        *(_DWORD *)std::string buf = 136446210;
        *(void *)&uint8_t buf[4] = v14;
        _os_log_impl( (void *)&_mh_execute_header,  v13,  OS_LOG_TYPE_DEFAULT,  "Got an SDP response without a connection in progress for device %{public}s - was the pairing cancelled?",  buf,  0xCu);
        if ((v94[23] & 0x80000000) != 0) {
          operator delete(*(void **)v94);
        }
      }

      return sub_100242FAC((uint64_t)v88);
    }

    unint64_t v8 = a1[19].u64[0];
    uint64_t v9 = a1[17].i64[1];
    uint64_t v10 = a1[18].i64[0];
    int v11 = (void *)(v9 + 8 * (v8 / 0x66));
    if (v10 == v9) {
      unint64_t v12 = 0LL;
    }
    else {
      unint64_t v12 = *v11 + 40 * (v8 % 0x66);
    }
    unint64_t v15 = v8 + v7;
    unint64_t v16 = v15 / 0x66;
    unint64_t v17 = v15 % 0x66;
LABEL_24:
    unint64_t v18 = v12 - 4080;
    while (1)
    {
      uint64_t v19 = v10 == v9 ? 0LL : *(void *)(v9 + 8 * v16) + 40 * v17;
      v12 += 40LL;
      v18 += 40LL;
      if (*v11 == v18)
      {
        unint64_t v20 = v11[1];
        ++v11;
        unint64_t v12 = v20;
        goto LABEL_24;
      }
    }

    if (v10 == v9) {
      uint64_t v21 = 0LL;
    }
    else {
      uint64_t v21 = *(void *)(v9 + 8 * v16) + 40 * v17;
    }
    if (v12 == v21)
    {
      uint64_t v27 = (os_log_s *)qword_1008F7578;
      if (os_log_type_enabled((os_log_t)qword_1008F7578, OS_LOG_TYPE_DEFAULT))
      {
        sub_1003CF00C((uint64_t)a2, v94);
        std::string::size_type v28 = v94[23] >= 0 ? v94 : *(_BYTE **)v94;
        *(_DWORD *)std::string buf = 136446210;
        *(void *)&uint8_t buf[4] = v28;
        _os_log_impl( (void *)&_mh_execute_header,  v27,  OS_LOG_TYPE_DEFAULT,  "Got an SDP response without a connection in progress for device %{public}s - was there a successful incoming c onnection during the outgoing one?",  buf,  0xCu);
        if ((v94[23] & 0x80000000) != 0) {
          operator delete(*(void **)v94);
        }
      }

      if (qword_1008D67E8 != -1) {
        dispatch_once(&qword_1008D67E8, &stru_100897E98);
      }
      sub_1003CA640((uint64_t)off_1008D67E0, (uint64_t)a2, 0);
      if (qword_1008D9600 != -1) {
        dispatch_once(&qword_1008D9600, &stru_100897ED8);
      }
      sub_10041ABC8();
      sub_100423730(a1, (uint64_t)a2);
      return sub_100242FAC((uint64_t)v88);
    }

    sub_100242F54((uint64_t)v88);
    if (qword_1008D9148 != -1) {
      dispatch_once(&qword_1008D9148, &stru_100897F38);
    }
    if (sub_10057F71C((uint64_t)off_1008D9140, (uint64_t)a2))
    {
      if (qword_1008D9148 != -1) {
        dispatch_once(&qword_1008D9148, &stru_100897F38);
      }
      if (*((_BYTE *)off_1008D9140 + 682))
      {
        if (qword_1008D67E8 != -1) {
          dispatch_once(&qword_1008D67E8, &stru_100897E98);
        }
        if (sub_1003C9FF4((uint64_t)off_1008D67E0, (uint64_t)a2)
          && !sub_100425684((uint64_t)a1, (uint64_t)a2))
        {
          char v22 = (os_log_s *)qword_1008F7578;
          if (os_log_type_enabled((os_log_t)qword_1008F7578, OS_LOG_TYPE_DEFAULT))
          {
            sub_1003CF00C((uint64_t)a2, v94);
            int v23 = v94[23];
            int v24 = *(_BYTE **)v94;
            int v25 = sub_1003CF350(a2);
            uint64_t v26 = v94;
            if (v23 < 0) {
              uint64_t v26 = v24;
            }
            *(_DWORD *)std::string buf = 136446466;
            *(void *)&uint8_t buf[4] = v26;
            *(_WORD *)&_BYTE buf[12] = 1024;
            *(_DWORD *)&buf[14] = v25;
            _os_log_impl( (void *)&_mh_execute_header,  v22,  OS_LOG_TYPE_DEFAULT,  "Fast connect after SDP, device %{public}s, paired:%d",  buf,  0x12u);
            if ((v94[23] & 0x80000000) != 0) {
              operator delete(*(void **)v94);
            }
          }

          if (qword_1008D9600 != -1) {
            dispatch_once(&qword_1008D9600, &stru_100897ED8);
          }
          sub_10041ABC8();
          sub_100426A10((uint64_t)a1, (uint64_t)a2, 1, 2);
          return sub_100242FAC((uint64_t)v88);
        }

        goto LABEL_76;
      }
    }

    else if (qword_1008D9148 != -1)
    {
      dispatch_once(&qword_1008D9148, &stru_100897F38);
    }

    uint64_t v29 = *((void *)off_1008D9140 + 84);
    __int128 v30 = (os_log_s *)qword_1008F7578;
    if (os_log_type_enabled((os_log_t)qword_1008F7578, OS_LOG_TYPE_DEFAULT))
    {
      sub_1003CF00C((uint64_t)a2, buf);
      int v31 = (char)buf[23];
      int v32 = *(uint8_t **)buf;
      int v33 = sub_1003CF350(a2);
      unsigned __int8 v34 = buf;
      *(_DWORD *)__int16 v94 = 136446722;
      if (v31 < 0) {
        unsigned __int8 v34 = v32;
      }
      *(void *)&v94[4] = v34;
      *(_WORD *)&v94[12] = 1024;
      *(_DWORD *)&v94[14] = v33;
      *(_WORD *)&v94[18] = 2048;
      *(void *)&v94[20] = v29;
      _os_log_impl( (void *)&_mh_execute_header,  v30,  OS_LOG_TYPE_DEFAULT,  "Lagacy profile connection after SDP, device %{public}s, paired:%d, FC features:%llx",  v94,  0x1Cu);
    }

    if ((v29 & 0x10) != 0)
    {
      if (qword_1008D9148 != -1) {
        dispatch_once(&qword_1008D9148, &stru_100897F38);
      }
      *((_BYTE *)off_1008D9140 + 682) = 1;
    }

void sub_1004283E4( _Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20, uint64_t a21, uint64_t a22, char a23, uint64_t a24, char a25, uint64_t a26, void *__p, uint64_t a28, int a29, __int16 a30, char a31, char a32, uint64_t a33, uint64_t a34, uint64_t a35, int a36, __int16 a37, char a38, char a39)
{
}

uint64_t sub_1004284B0(uint64_t a1, unsigned __int8 *a2)
{
  uint64_t v3 = a2[128];
  uint64_t v4 = a2[129];
  uint64_t v5 = a2[130];
  uint64_t v6 = a2[131];
  uint64_t v7 = a2[132];
  uint64_t v8 = a2[133];
  if (qword_1008D5F30 != -1) {
    dispatch_once(&qword_1008D5F30, &stru_100897EB8);
  }
  v10[0] = 0LL;
  v10[1] = 0LL;
  sub_1005C8684( (uint64_t)off_1008D5F28,  (v3 << 40) | (v4 << 32) | (v5 << 24) | (v6 << 16) | (v7 << 8) | v8,  0,  1u,  0LL,  0LL,  (unsigned __int8 *)v10);
  if (qword_1008D5F10 != -1) {
    dispatch_once(&qword_1008D5F10, &stru_100897F78);
  }
  else {
    return sub_1003D24F8((uint64_t)a2) ^ 1;
  }
}

uint64_t sub_1004285E4(uint64_t a1, uint64_t a2, int a3)
{
  if (!a2)
  {
    uint64_t v6 = (os_log_s *)qword_1008F7578;
    if (os_log_type_enabled((os_log_t)qword_1008F7578, OS_LOG_TYPE_FAULT)) {
      sub_10067DE6C(v6);
    }
  }

  uint64_t v23 = 0LL;
  __int128 v22 = 0u;
  memset(v21, 0, sizeof(v21));
  __int128 v20 = 0u;
  *(_OWORD *)unint64_t v18 = 0u;
  __int128 v19 = 0u;
  *(_OWORD *)unint64_t v16 = 0u;
  __int128 v17 = 0u;
  __int128 v15 = 0u;
  sub_100532DC0((uint64_t)&v15 + 1);
  BYTE2(v16[0]) = 0;
  BYTE4(v16[0]) = 0;
  BYTE2(v18[0]) = 0;
  BYTE4(v18[0]) = 0;
  HIDWORD(v21[2]) = 0;
  __int128 v17 = 0uLL;
  v16[1] = 0LL;
  LOBYTE(v18[0]) = 0;
  __int128 v19 = 0uLL;
  v18[1] = 0LL;
  LOBYTE(v2sub_100414D2C(qword_1008F72C0, 0) = 0;
  v21[0] = 0LL;
  v21[1] = 0LL;
  *((void *)&v20 + 1) = 0LL;
  *(_DWORD *)((char *)&v21[1] + 7) = 0;
  LOBYTE(v21[3]) = 1;
  BYTE2(v23) = 0;
  *(void *)((char *)&v21[3] + 6) = 0LL;
  *(void *)((char *)&v21[3] + 1) = 0LL;
  __int128 v22 = 0uLL;
  v21[5] = 0LL;
  LOBYTE(v23) = 0;
  BOOL v7 = sub_1003D2408(a2, (uint64_t)&v15);
  if (BYTE1(v21[2])) {
    BOOL v8 = v7;
  }
  else {
    BOOL v8 = 0;
  }
  uint64_t v9 = *(void *)(a1 + 104);
  v12[0] = _NSConcreteStackBlock;
  v12[1] = 3221225472LL;
  void v12[2] = sub_1004287AC;
  v12[3] = &unk_100889658;
  void v12[4] = a1;
  void v12[5] = a2;
  int v13 = a3;
  BOOL v14 = v8;
  sub_100405384(v9, v12);
  if (SHIBYTE(v21[1]) < 0) {
    operator delete(*((void **)&v20 + 1));
  }
  if (SHIBYTE(v19) < 0) {
    operator delete(v18[1]);
  }
  if (SHIBYTE(v17) < 0) {
    operator delete(v16[1]);
  }
  return nullsub_63((char *)&v15 + 1, v10);
}

void sub_100428790( _Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, char a17)
{
}

_BYTE *sub_1004287AC(uint64_t a1)
{
  return sub_1004273B0(a1, *(unsigned __int8 **)(a1 + 40), *(unsigned int *)(a1 + 48), *(unsigned __int8 *)(a1 + 52));
}

uint64_t sub_1004287BC(uint64_t a1, uint64_t a2, int a3)
{
  return sub_1004285E4(a1 - 32, a2, a3);
}

uint64_t sub_1004287C4(int64x2_t *a1, uint64_t a2, int a3)
{
  uint64_t v6 = (os_log_s *)qword_1008F7578;
  if (os_log_type_enabled((os_log_t)qword_1008F7578, OS_LOG_TYPE_DEFAULT))
  {
    sub_1003CF00C(a2, &__p);
    BOOL v7 = v17 >= 0 ? &__p : (void **)__p;
    *(_DWORD *)std::string buf = 136446466;
    *(void *)&uint8_t buf[4] = v7;
    *(_WORD *)&_BYTE buf[12] = 1024;
    *(_DWORD *)&buf[14] = a3;
    _os_log_impl( (void *)&_mh_execute_header,  v6,  OS_LOG_TYPE_DEFAULT,  "Disconnecting services from device %{public}s with mask 0x%x",  buf,  0x12u);
    if (SHIBYTE(v17) < 0) {
      operator delete(__p);
    }
  }

  *(void *)std::string buf = 0LL;
  *(void *)&uint8_t buf[8] = 0LL;
  sub_100242F28((uint64_t)buf, (uint64_t)&a1[2].i64[1]);
  if (!a1[7].i8[0]) {
    goto LABEL_19;
  }
  sub_100242F54((uint64_t)buf);
  if (qword_1008D6788 != -1) {
    dispatch_once(&qword_1008D6788, &stru_100897F18);
  }
  if (sub_1002075B4((uint64_t)off_1008D6780))
  {
    if (qword_1008D9600 != -1) {
      dispatch_once(&qword_1008D9600, &stru_100897ED8);
    }
    sub_10041ABC8();
    sub_100423730(a1, a2);
    v14[0] = 0LL;
    v14[1] = 0LL;
    sub_100242F28((uint64_t)v14, (uint64_t)&a1[7].i64[1]);
    std::string __p = 0LL;
    uint64_t v16 = 0LL;
    uint64_t v17 = 0LL;
    sub_10042AC38(&__p, (uint64_t)&a1[11].i64[1]);
    sub_100242F54((uint64_t)v14);
    for (uint64_t i = v16; (void **)i != &__p; uint64_t i = *(void *)(i + 8))
    {
      uint64_t v9 = *(_DWORD **)(i + 16);
      if ((*(unsigned int (**)(_DWORD *))(*(void *)v9 + 32LL))(v9) && (v9[8] & a3) != 0)
      {
        uint64_t v10 = a1[6].i64[1];
        v13[0] = _NSConcreteStackBlock;
        v13[1] = 3221225472LL;
        void v13[2] = sub_100428A7C;
        v13[3] = &unk_10087F8E0;
        v13[4] = v9;
        v13[5] = a2;
        sub_100405384(v10, v13);
      }
    }

    sub_10023DF50(&__p);
    sub_100242FAC((uint64_t)v14);
    uint64_t v11 = 0LL;
  }

  else
  {
LABEL_19:
    uint64_t v11 = 202LL;
  }

  sub_100242FAC((uint64_t)buf);
  return v11;
}

void sub_100428A38( _Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, ...)
{
  uint64_t v9 = va_arg(va1, void);
  uint64_t v11 = va_arg(va1, void);
  va_copy(va2, va1);
  uint64_t v12 = va_arg(va2, void);
  uint64_t v14 = va_arg(va2, void);
  uint64_t v15 = va_arg(va2, void);
  sub_10023DF50((uint64_t *)va1);
  sub_100242FAC((uint64_t)va);
  sub_100242FAC((uint64_t)va2);
  _Unwind_Resume(a1);
}

uint64_t sub_100428A7C(uint64_t a1)
{
  return (*(uint64_t (**)(void, void))(**(void **)(a1 + 32) + 88LL))( *(void *)(a1 + 32),  *(void *)(a1 + 40));
}

uint64_t sub_100428A90(uint64_t a1, uint64_t a2)
{
  if (!a2) {
    return 3LL;
  }
  v26[0] = 0LL;
  v26[1] = 0LL;
  sub_100242F28((uint64_t)v26, a1 + 40);
  if (!*(_BYTE *)(a1 + 112)) {
    goto LABEL_29;
  }
  sub_100242F54((uint64_t)v26);
  if (qword_1008D6788 != -1) {
    dispatch_once(&qword_1008D6788, &stru_100897F18);
  }
  if (sub_1002075B4((uint64_t)off_1008D6780))
  {
    int v24 = *(_DWORD *)(a2 + 128);
    __int16 v25 = *(_WORD *)(a2 + 132);
    *(void *)uuid_t uu = 0LL;
    uint64_t v30 = 0LL;
    if (qword_1008D5F30 != -1) {
      dispatch_once(&qword_1008D5F30, &stru_100897EB8);
    }
    sub_1005D0B84((uint64_t)off_1008D5F28, (unsigned __int8 *)&v24, uu);
    if (!uuid_is_null(uu))
    {
      if (qword_1008D5F30 != -1) {
        dispatch_once(&qword_1008D5F30, &stru_100897EB8);
      }
      uint64_t v4 = off_1008D5F28;
      uint64_t v5 = sub_100241F94(uu);
      uint64_t v6 = (void *)objc_claimAutoreleasedReturnValue(v5);
      sub_10002418C(__p, "_CTKD_");
      int v7 = sub_1005CE5A8((uint64_t)v4, v6, (uint64_t)__p);
      if (v23 < 0) {
        operator delete(__p[0]);
      }

      if (v7)
      {
        if (qword_1008D5F10 != -1) {
          dispatch_once(&qword_1008D5F10, &stru_100897F78);
        }
        if (sub_100595874((uint64_t)off_1008D5F08, uu))
        {
          BOOL v8 = (os_log_s *)qword_1008F7578;
          if (os_log_type_enabled((os_log_t)qword_1008F7578, OS_LOG_TYPE_DEFAULT))
          {
            memset(out, 0, 37);
            uuid_unparse_upper(uu, out);
            sub_10002418C(v20, out);
            uint64_t v9 = v21 >= 0 ? v20 : (void **)v20[0];
            *(_DWORD *)std::string buf = 136315138;
            std::string::size_type v28 = v9;
            _os_log_impl( (void *)&_mh_execute_header,  v8,  OS_LOG_TYPE_DEFAULT,  "LE device %s is connected, forcing disconnection",  buf,  0xCu);
            if (v21 < 0) {
              operator delete(v20[0]);
            }
          }

          if (qword_1008D5F10 != -1) {
            dispatch_once(&qword_1008D5F10, &stru_100897F78);
          }
          uint64_t v10 = sub_100597F98((uint64_t)off_1008D5F08, uu, 4u);
          if ((_DWORD)v10)
          {
            uint64_t v11 = (os_log_s *)qword_1008F7578;
            if (os_log_type_enabled((os_log_t)qword_1008F7578, OS_LOG_TYPE_ERROR)) {
              sub_10067DEEC(v10, v11, v12, v13, v14, v15, v16, v17);
            }
          }
        }
      }
    }

    uint64_t v18 = 0LL;
  }

  else
  {
LABEL_29:
    uint64_t v18 = 202LL;
  }

  sub_100242FAC((uint64_t)v26);
  return v18;
}

void sub_100428D70( _Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, void *__p, uint64_t a14, int a15, __int16 a16, char a17, char a18, uint64_t a19, char a20)
{
}

void sub_100428DBC(uint64_t a1, uint64_t a2)
{
  uint64_t v2 = *(void *)(a1 + 104);
  v3[0] = _NSConcreteStackBlock;
  v3[1] = 3221225472LL;
  void v3[2] = sub_100428E14;
  v3[3] = &unk_10087F8E0;
  void v3[4] = a1;
  void v3[5] = a2;
  sub_100405384(v2, v3);
}

void sub_100428E14(uint64_t a1)
{
  uint64_t v2 = *(int64x2_t **)(a1 + 32);
  if (qword_1008D5F50 != -1) {
    dispatch_once(&qword_1008D5F50, &stru_100897E58);
  }
  uint64_t v3 = sub_10040007C(off_1008D5F48, *(void *)(a1 + 40), 1);
  if (v3)
  {
    uint64_t v4 = (uint64_t)v3;
    if (sub_1003D0670((uint64_t)v3))
    {
      uint64_t v5 = qword_1008F7578;
      if (!os_log_type_enabled((os_log_t)qword_1008F7578, OS_LOG_TYPE_DEFAULT)) {
        return;
      }
      LODWORD(__p.__r_.__value_.__l.__data_) = 67109120;
      HIDWORD(__p.__r_.__value_.__r.__words[0]) = sub_100425684((uint64_t)v2, v4);
      uint64_t v6 = "CTKD le device connected, not bridging classic services because services %x is already connected";
      int v7 = (os_log_s *)v5;
      uint32_t v8 = 8;
LABEL_16:
      _os_log_impl((void *)&_mh_execute_header, v7, OS_LOG_TYPE_DEFAULT, v6, (uint8_t *)&__p, v8);
      return;
    }

    if (qword_1008D6198 != -1) {
      dispatch_once(&qword_1008D6198, &stru_100897F58);
    }
    if (*((_BYTE *)off_1008D6190 + 198) || *((_BYTE *)off_1008D6190 + 197) || *((_BYTE *)off_1008D6190 + 199))
    {
      uint64_t v12 = qword_1008F7578;
      if (!os_log_type_enabled((os_log_t)qword_1008F7578, OS_LOG_TYPE_DEFAULT)) {
        return;
      }
      LOWORD(__p.__r_.__value_.__l.__data_) = 0;
      uint64_t v6 = "Device is currently streaming, not bridging";
      int v7 = (os_log_s *)v12;
      uint32_t v8 = 2;
      goto LABEL_16;
    }

    if ((sub_1003D03AC(v4) & 0x19) != 0 || !sub_1003D518C(v4))
    {
      uint64_t v13 = (os_log_s *)qword_1008F7578;
      if (os_log_type_enabled((os_log_t)qword_1008F7578, OS_LOG_TYPE_DEFAULT))
      {
        sub_1003CF00C(v4, &__p);
        if ((__p.__r_.__value_.__s.__size_ & 0x80u) == 0) {
          p_p = &__p;
        }
        else {
          p_p = (std::string *)__p.__r_.__value_.__r.__words[0];
        }
        *(_DWORD *)std::string buf = 136446210;
        uint64_t v17 = p_p;
        _os_log_impl( (void *)&_mh_execute_header,  v13,  OS_LOG_TYPE_DEFAULT,  "This is a disconnected CTKD device (%{public}s) that connected over LE, bringing up classic audio services as well",  buf,  0xCu);
      }

      memset(&__p, 0, sizeof(__p));
      sub_100424360(v2, v4, -1048577, &__p, 2LL);
    }
  }

  else
  {
    uint64_t v9 = (os_log_s *)qword_1008F7578;
    if (os_log_type_enabled((os_log_t)qword_1008F7578, OS_LOG_TYPE_ERROR)) {
      sub_10067DF50(v9, v10, v11);
    }
  }

void sub_1004290A8( _Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, void *__p, uint64_t a10, int a11, __int16 a12, char a13, char a14)
{
  if (a14 < 0) {
    operator delete(__p);
  }
  _Unwind_Resume(exception_object);
}

uint64_t sub_1004290CC(uint64_t a1)
{
  uint64_t v2 = *(void *)(a1 + 32);
  v5[0] = 0LL;
  v5[1] = 0LL;
  sub_100242F28((uint64_t)v5, v2 + 40);
  if (*(_BYTE *)(v2 + 112))
  {
    char v4 = 0;
    sub_100242CA4(&v4);
    sub_10010D064(*(void *)(a1 + 40) + 128LL);
    sub_100242CD0(&v4);
    if (*(_BYTE *)(a1 + 48)) {
      sub_100428A90(v2, *(void *)(a1 + 40));
    }
    sub_100242CD8(&v4);
  }

  return sub_100242FAC((uint64_t)v5);
}

void sub_100429150(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, ...)
{
}

uint64_t sub_100429174(uint64_t a1, uint64_t a2, int a3, _BYTE *a4, _DWORD *a5)
{
  int v29 = 0;
  char v28 = 0;
  v27[0] = 0LL;
  v27[1] = 0LL;
  sub_100242F28((uint64_t)v27, a1 + 120);
  uint64_t v24 = 0LL;
  __int16 v25 = 0LL;
  uint64_t v26 = 0LL;
  sub_10042AC38(&v24, a1 + 184);
  sub_100242F54((uint64_t)v27);
  *a4 = 0;
  uint64_t v10 = v25;
  if (v25 != &v24)
  {
    uint64_t v11 = (os_log_t *)&qword_1008F7578;
    do
    {
      uint64_t v12 = (_DWORD *)v10[2];
      if ((v12[8] & a3) != 0)
      {
        int v29 = 0;
        char v28 = 0;
        (*(void (**)(_DWORD *, uint64_t, char *, int *))(*(void *)v12 + 64LL))(v12, a2, &v28, &v29);
        *a5 |= v29;
        if (v28)
        {
          uint64_t v13 = *v11;
          if (os_log_type_enabled(*v11, OS_LOG_TYPE_DEFAULT))
          {
            uint64_t v14 = v11;
            (*(void (**)(void **__return_ptr, _DWORD *))(*(void *)v12 + 192LL))(v22, v12);
            int v15 = v23;
            uint64_t v16 = (void **)v22[0];
            sub_1003CF00C(a2, __p);
            uint64_t v17 = v22;
            if (v15 < 0) {
              uint64_t v17 = v16;
            }
            uint64_t v18 = __p;
            if (v21 < 0) {
              uint64_t v18 = (void **)__p[0];
            }
            *(_DWORD *)std::string buf = 136446466;
            int v31 = v17;
            __int16 v32 = 2082;
            int v33 = v18;
            _os_log_impl( (void *)&_mh_execute_header,  v13,  OS_LOG_TYPE_DEFAULT,  "%{public}s supports device %{public}s",  buf,  0x16u);
            if (v21 < 0) {
              operator delete(__p[0]);
            }
            uint64_t v11 = v14;
            if (v23 < 0) {
              operator delete(v22[0]);
            }
          }

          *a4 = 1;
        }
      }

      uint64_t v10 = (uint64_t *)v10[1];
    }

    while (v10 != &v24);
  }

  sub_10023DF50(&v24);
  return sub_100242FAC((uint64_t)v27);
}

void sub_100429384( _Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, void *__p, uint64_t a15, int a16, __int16 a17, char a18, char a19, uint64_t a20, uint64_t a21, uint64_t a22, char a23)
{
}

uint64_t sub_1004293D0(uint64_t a1)
{
  v9[0] = 0LL;
  v9[1] = 0LL;
  sub_100242F28((uint64_t)v9, a1 + 120);
  uint64_t v6 = 0LL;
  int v7 = 0LL;
  uint64_t v8 = 0LL;
  sub_10042AC38(&v6, a1 + 184);
  sub_100242F54((uint64_t)v9);
  uint64_t v2 = v7;
  if (v7 == &v6)
  {
    uint64_t v3 = 0LL;
  }

  else
  {
    LODWORD(v3) = 0;
    do
    {
      char v4 = v2 + 1;
      uint64_t v2 = (uint64_t *)v2[1];
      uint64_t v3 = *(_DWORD *)(v4[1] + 32LL) | v3;
    }

    while (v2 != &v6);
  }

  sub_10023DF50(&v6);
  sub_100242FAC((uint64_t)v9);
  return v3;
}

void sub_100429464(_Unwind_Exception *a1, uint64_t a2, ...)
{
  uint64_t v3 = va_arg(va1, void);
  uint64_t v5 = va_arg(va1, void);
  uint64_t v6 = va_arg(va1, void);
  sub_10023DF50((uint64_t *)va);
  sub_100242FAC((uint64_t)va1);
  _Unwind_Resume(a1);
}

uint64_t sub_100429488(uint64_t a1, uint64_t a2, int a3, uint64_t a4, uint64_t a5)
{
  v16[0] = 0LL;
  v16[1] = 0LL;
  sub_100242F28((uint64_t)v16, a1 + 120);
  uint64_t v13 = 0LL;
  uint64_t v14 = 0LL;
  uint64_t v15 = 0LL;
  sub_10042AC38(&v13, a1 + 184);
  sub_100242F54((uint64_t)v16);
  for (uint64_t i = v14; i != &v13; uint64_t i = (uint64_t *)i[1])
  {
    uint64_t v11 = (_DWORD *)i[2];
    if ((v11[8] & a3) != 0) {
      (*(void (**)(_DWORD *, uint64_t, uint64_t, uint64_t))(*(void *)v11 + 208LL))(v11, a2, a4, a5);
    }
  }

  sub_10023DF50(&v13);
  sub_100242FAC((uint64_t)v16);
  return 0LL;
}

void sub_10042954C(_Unwind_Exception *a1, uint64_t a2, ...)
{
  uint64_t v3 = va_arg(va1, void);
  uint64_t v5 = va_arg(va1, void);
  uint64_t v6 = va_arg(va1, void);
  sub_10023DF50((uint64_t *)va);
  sub_100242FAC((uint64_t)va1);
  _Unwind_Resume(a1);
}

uint64_t sub_100429574(uint64_t a1, uint64_t a2, int a3, uint64_t a4, uint64_t a5)
{
  v17[0] = 0LL;
  v17[1] = 0LL;
  sub_100242F28((uint64_t)v17, a1 + 120);
  uint64_t v14 = 0LL;
  uint64_t v15 = 0LL;
  uint64_t v16 = 0LL;
  sub_10042AC38(&v14, a1 + 184);
  sub_100242F54((uint64_t)v17);
  for (uint64_t i = v15; ; uint64_t i = (uint64_t *)i[1])
  {
    if (i == &v14)
    {
      uint64_t v12 = 1LL;
      goto LABEL_7;
    }

    uint64_t v11 = (_DWORD *)i[2];
    if (v11[8] == a3) {
      break;
    }
  }

  uint64_t v12 = (*(uint64_t (**)(_DWORD *, uint64_t, uint64_t, uint64_t))(*(void *)v11 + 216LL))(v11, a2, a4, a5);
LABEL_7:
  sub_10023DF50(&v14);
  sub_100242FAC((uint64_t)v17);
  return v12;
}

void sub_100429644(_Unwind_Exception *a1, uint64_t a2, ...)
{
  uint64_t v3 = va_arg(va1, void);
  uint64_t v5 = va_arg(va1, void);
  uint64_t v6 = va_arg(va1, void);
  sub_10023DF50((uint64_t *)va);
  sub_100242FAC((uint64_t)va1);
  _Unwind_Resume(a1);
}

uint64_t sub_10042966C(uint64_t a1, uint64_t a2, int a3, char *a4, size_t a5)
{
  v21[0] = 0LL;
  v21[1] = 0LL;
  sub_100242F28((uint64_t)v21, a1 + 120);
  uint64_t v18 = 0LL;
  __int128 v19 = 0LL;
  uint64_t v20 = 0LL;
  sub_10042AC38(&v18, a1 + 184);
  sub_100242F54((uint64_t)v21);
  for (uint64_t i = v19; ; uint64_t i = (uint64_t *)i[1])
  {
    if (i == &v18) {
      goto LABEL_8;
    }
    uint64_t v11 = (_DWORD *)i[2];
    if (v11[8] == a3) {
      break;
    }
  }

  uint64_t v12 = (*(uint64_t (**)(_DWORD *, uint64_t))(*(void *)v11 + 184LL))(v11, a2);
  uint64_t v13 = (void *)objc_claimAutoreleasedReturnValue(v12);
  if (!v13)
  {
LABEL_8:
    uint64_t v16 = 800LL;
    goto LABEL_9;
  }

  id v14 = v13;
  uint64_t v15 = (const char *)[v14 UTF8String];
  if (strlen(v15) >= a5)
  {
    uint64_t v16 = 5LL;
  }

  else
  {
    strlcpy(a4, v15, a5);
    uint64_t v16 = 0LL;
  }

LABEL_9:
  sub_10023DF50(&v18);
  sub_100242FAC((uint64_t)v21);
  return v16;
}

void sub_100429774(_Unwind_Exception *a1, uint64_t a2, ...)
{
  uint64_t v4 = va_arg(va1, void);
  uint64_t v6 = va_arg(va1, void);
  uint64_t v7 = va_arg(va1, void);

  sub_10023DF50((uint64_t *)va);
  sub_100242FAC((uint64_t)va1);
  _Unwind_Resume(a1);
}

uint64_t sub_1004297A8(uint64_t a1)
{
  v8[0] = 0LL;
  v8[1] = 0LL;
  sub_100242F28((uint64_t)v8, a1 + 120);
  uint64_t v5 = 0LL;
  uint64_t v6 = 0LL;
  uint64_t v7 = 0LL;
  sub_10042AC38(&v5, a1 + 184);
  sub_100242F54((uint64_t)v8);
  uint64_t v2 = v6;
  uint64_t v3 = 1LL;
  while ((uint64_t *)v2 != &v5)
  {
    uint64_t v3 = v3 & (*(unsigned int (**)(void))(**(void **)(v2 + 16) + 224LL))(*(void *)(v2 + 16));
    uint64_t v2 = *(void *)(v2 + 8);
  }

  sub_10023DF50(&v5);
  sub_100242FAC((uint64_t)v8);
  return v3;
}

void sub_100429844(_Unwind_Exception *a1, uint64_t a2, ...)
{
  uint64_t v3 = va_arg(va1, void);
  uint64_t v5 = va_arg(va1, void);
  uint64_t v6 = va_arg(va1, void);
  sub_10023DF50((uint64_t *)va);
  sub_100242FAC((uint64_t)va1);
  _Unwind_Resume(a1);
}

uint64_t sub_10042986C(uint64_t a1)
{
  return sub_1004297A8(a1 - 16);
}

uint64_t sub_100429874(uint64_t a1)
{
  v7[0] = 0LL;
  v7[1] = 0LL;
  sub_100242F28((uint64_t)v7, a1 + 120);
  uint64_t v4 = 0LL;
  uint64_t v5 = 0LL;
  uint64_t v6 = 0LL;
  sub_10042AC38(&v4, a1 + 184);
  sub_100242F54((uint64_t)v7);
  *(_BYTE *)(a1 + 113) = 1;
  sub_10023DF50(&v4);
  return sub_100242FAC((uint64_t)v7);
}

void sub_10042990C(_Unwind_Exception *a1, uint64_t a2, ...)
{
  uint64_t v3 = va_arg(va1, void);
  uint64_t v5 = va_arg(va1, void);
  uint64_t v6 = va_arg(va1, void);
  sub_10023DF50((uint64_t *)va);
  sub_100242FAC((uint64_t)va1);
  _Unwind_Resume(a1);
}

uint64_t sub_100429934(uint64_t a1)
{
  return sub_100429874(a1 - 16);
}

uint64_t sub_10042993C(uint64_t result)
{
  *(_BYTE *)(result + 113) = 0;
  return result;
}

uint64_t sub_100429944(uint64_t result)
{
  *(_BYTE *)(result + 97) = 0;
  return result;
}

uint64_t sub_10042994C@<X0>(_DWORD *a1@<X0>, std::stringbuf::string_type *a2@<X8>)
{
  uint64_t v19 = 0LL;
  __int128 v17 = 0u;
  memset(v18, 0, sizeof(v18));
  *(_OWORD *)std::string __p = 0u;
  __int128 v16 = 0u;
  memset(v14, 0, sizeof(v14));
  __int128 v13 = 0u;
  sub_1001FCFC8((uint64_t)&v13);
  int v4 = 1;
  do
  {
    LODWORD(v12.__r_.__value_.__l.__data_) = *a1 & v4;
    if (LODWORD(v12.__r_.__value_.__l.__data_))
    {
      uint64_t v5 = sub_1001FD17C(v14, (uint64_t)"", 1LL);
      uint64_t v6 = sub_100426610((int *)&v12);
      size_t v7 = strlen(v6);
      uint64_t v8 = sub_1001FD17C(v5, (uint64_t)v6, v7);
      sub_1001FD17C(v8, (uint64_t)" ", 2LL);
    }

    v4 *= 2;
  }

  while ((v4 & 0x80000000) == 0);
  std::stringbuf::str(&v12, (const std::stringbuf *)((char *)v14 + 8));
  if ((char)v12.__r_.__value_.__s.__size_ < 0)
  {
    std::string::size_type size = v12.__r_.__value_.__l.__size_;
    operator delete(v12.__r_.__value_.__l.__data_);
    if (size) {
      goto LABEL_10;
    }
  }

  else if (v12.__r_.__value_.__s.__size_)
  {
    goto LABEL_10;
  }

  sub_1001FD17C(v14, (uint64_t)"None", 4LL);
LABEL_10:
  std::stringbuf::str(a2, (const std::stringbuf *)((char *)v14 + 8));
  *(void *)((char *)&v14[-1]
  *(void *)&v14[0] = v10;
  if (SHIBYTE(v16) < 0) {
    operator delete(__p[1]);
  }
  std::streambuf::~streambuf((char *)v14 + 8);
  return std::ios::~ios(v18);
}

void sub_100429AE8(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, ...)
{
}

const char *sub_100429B04(int *a1)
{
  int v1 = *a1;
  if (*a1 > 1023)
  {
    if (v1 < 0x8000)
    {
      if (v1 <= 4095)
      {
        if (v1 == 1024) {
          return "BT_SERVICE_PASSTHROUGH";
        }
        if (v1 == 2048) {
          return "BT_SERVICE_GAMING";
        }
      }

      else
      {
        switch(v1)
        {
          case 0x1000:
            return "BT_SERVICE_NETWORK_CONSUMER";
          case 0x2000:
            return "BT_SERVICE_BRAILLE";
          case 0x4000:
            return "BT_SERVICE_PASSIVE_MULTI_STREAM";
        }
      }
    }

    else if (v1 >= 0x40000)
    {
      switch(v1)
      {
        case 0x40000:
          return "BT_SERVICE_WIRELESS_CARPLAY";
        case 0x80000:
          return "BT_SERVICE_AACP";
        case 0x100000:
          return "BT_SERVICE_GATT";
      }
    }

    else
    {
      switch(v1)
      {
        case 0x8000:
          return "BT_SERVICE_LE_GATT_CLIENT";
        case 0x10000:
          return "BT_SERVICE_LEA";
        case 0x20000:
          return "BT_SERVICE_WIRELESS_IAP_SINK";
      }
    }

    return "Unknown";
  }

  if (v1 > 15)
  {
    if (v1 > 127)
    {
      switch(v1)
      {
        case 128:
          return "BT_SERVICE_WIRELESS_IAP";
        case 256:
          return "BT_SERVICE_NET_SHARING";
        case 512:
          return "BT_SERVICE_MAP";
      }
    }

    else
    {
      switch(v1)
      {
        case 16:
          return "BT_SERVICE_A2DP";
        case 32:
          return "BT_SERVICE_HID";
        case 64:
          return "BT_SERVICE_SENSOR";
      }
    }

    return "Unknown";
  }

  uint64_t result = "BT_SERVICE_NONE";
  switch(v1)
  {
    case -1:
      uint64_t result = "BT_SERVICE_ALL";
      break;
    case 0:
      return result;
    case 1:
      uint64_t result = "BT_SERVICE_HANDSFREE";
      break;
    case 2:
      uint64_t result = "BT_SERVICE_PHONEBOOK";
      break;
    case 8:
      uint64_t result = "BT_SERVICE_REMOTE";
      break;
    default:
      return "Unknown";
  }

  return result;
}

const char *sub_100429CF0(int *a1)
{
  int v1 = *a1;
  if (*a1 <= 300)
  {
    if (v1 > 101)
    {
      if (v1 <= 110)
      {
        if (v1 == 102) {
          return "BT_SERVICE_HANDSFREE_AUDIO_DISCONNECTED";
        }
        if (v1 == 110) {
          return "BT_SERVICE_A2DP_LOW_LATENCY_ON";
        }
      }

      else
      {
        switch(v1)
        {
          case 111:
            return "BT_SERVICE_A2DP_LOW_LATENCY_OFF";
          case 201:
            return "BT_SERVICE_A2DP_AUDIO_CONNECTED";
          case 202:
            return "BT_SERVICE_A2DP_AUDIO_DISCONNECTED";
        }
      }
    }

    else if (v1 <= 10)
    {
      if (v1 == 1) {
        return "BT_SERVICE_CONNECTION_ATTEMPT";
      }
      if (v1 == 2) {
        return "BT_SERVICE_DISCONNECTION_ATTEMPT";
      }
    }

    else
    {
      switch(v1)
      {
        case 11:
          return "BT_SERVICE_CONNECTION_RESULT";
        case 12:
          return "BT_SERVICE_DISCONNECTION_RESULT";
        case 101:
          return "BT_SERVICE_HANDSFREE_AUDIO_CONNECTED";
      }
    }

    return "Unknown";
  }

  if (v1 <= 700)
  {
    if (v1 <= 500)
    {
      if (v1 == 301) {
        return "BT_SERVICE_PHONE_BOOK_SEND_INITIATED";
      }
      if (v1 == 302) {
        return "BT_SERVICE_PHONE_BOOK_SEND_COMPLETE";
      }
    }

    else
    {
      switch(v1)
      {
        case 501:
          return "BT_SERVICE_REMOTE_PLAY";
        case 502:
          return "BT_SERVICE_REMOTE_PAUSE";
        case 601:
          return "BT_SERVICE_SENSOR_RSSI";
      }
    }

    return "Unknown";
  }

  if (v1 > 702)
  {
    switch(v1)
    {
      case 703:
        return "BT_SERVICE_HIGH_POWER_DISABLED";
      case 901:
        return "BT_UI_INITIATED_CONNECTION_REQUEST";
      case 902:
        return "BT_CONNECTION_RESULT_PROCESSED";
    }

    return "Unknown";
  }

  if (v1 == 701) {
    return "BT_SERVICE_LMP_NAME_CHANGED";
  }
  else {
    return "BT_SERVICE_HIGH_POWER_ENABLED";
  }
}

void sub_100429EC8(uint64_t a1)
{
  uint64_t v2 = (os_log_s *)qword_1008F7578;
  if (os_log_type_enabled((os_log_t)qword_1008F7578, OS_LOG_TYPE_DEFAULT))
  {
    *(_WORD *)std::string buf = 0;
    _os_log_impl( (void *)&_mh_execute_header,  v2,  OS_LOG_TYPE_DEFAULT,  "statedump: ------------------ Service Manager ------------------",  buf,  2u);
    uint64_t v2 = (os_log_s *)qword_1008F7578;
  }

  if (os_log_type_enabled(v2, OS_LOG_TYPE_DEFAULT))
  {
    *(_WORD *)std::string buf = 0;
    _os_log_impl((void *)&_mh_execute_header, v2, OS_LOG_TYPE_DEFAULT, "statedump: Supported services:", buf, 2u);
    uint64_t v2 = (os_log_s *)qword_1008F7578;
  }

  for (uint64_t i = *(void *)(a1 + 192); i != a1 + 184; uint64_t i = *(void *)(i + 8))
  {
    if (os_log_type_enabled(v2, OS_LOG_TYPE_DEFAULT))
    {
      int v9 = *(_DWORD *)(*(void *)(i + 16) + 32LL);
      int v4 = sub_100426610(&v9);
      *(_DWORD *)std::string buf = 136446210;
      uint64_t v11 = v4;
      _os_log_impl((void *)&_mh_execute_header, v2, OS_LOG_TYPE_DEFAULT, "statedump:    %{public}s", buf, 0xCu);
      uint64_t v2 = (os_log_s *)qword_1008F7578;
    }
  }

  if (os_log_type_enabled(v2, OS_LOG_TYPE_DEFAULT))
  {
    *(_WORD *)std::string buf = 0;
    _os_log_impl((void *)&_mh_execute_header, v2, OS_LOG_TYPE_DEFAULT, "statedump: Services pending stop:", buf, 2u);
  }

  uint64_t v5 = a1 + 608;
  uint64_t v6 = *(void *)(a1 + 616);
  if (v6 != a1 + 608)
  {
    size_t v7 = (os_log_s *)qword_1008F7578;
    do
    {
      if (os_log_type_enabled(v7, OS_LOG_TYPE_DEFAULT))
      {
        int v9 = *(_DWORD *)(*(void *)(v6 + 16) + 32LL);
        uint64_t v8 = sub_100426610(&v9);
        *(_DWORD *)std::string buf = 136446210;
        uint64_t v11 = v8;
        _os_log_impl((void *)&_mh_execute_header, v7, OS_LOG_TYPE_DEFAULT, "statedump:    %{public}s", buf, 0xCu);
        size_t v7 = (os_log_s *)qword_1008F7578;
      }

      uint64_t v6 = *(void *)(v6 + 8);
    }

    while (v6 != v5);
  }

uint64_t sub_10042A100(uint64_t a1, uint64_t a2)
{
  v9[0] = 0LL;
  v9[1] = 0LL;
  sub_100242F28((uint64_t)v9, a1 + 120);
  uint64_t v6 = 0LL;
  uint64_t v7 = 0LL;
  uint64_t v8 = 0LL;
  sub_10042AC38(&v6, a1 + 184);
  sub_100242F54((uint64_t)v9);
  sub_10023DF50(&v6);
  return sub_100242FAC((uint64_t)v9);
}

void sub_10042A198(_Unwind_Exception *a1, uint64_t a2, ...)
{
  uint64_t v3 = va_arg(va1, void);
  uint64_t v5 = va_arg(va1, void);
  uint64_t v6 = va_arg(va1, void);
  sub_10023DF50((uint64_t *)va);
  sub_100242FAC((uint64_t)va1);
  _Unwind_Resume(a1);
}

uint64_t sub_10042A1C0(uint64_t a1, char *a2, _WORD *a3)
{
  v14[0] = 0LL;
  v14[1] = 0LL;
  sub_100242F28((uint64_t)v14, a1 + 120);
  *(void *)&__len[1] = 0LL;
  std::stringbuf::string_type v12 = 0LL;
  uint64_t v13 = 0LL;
  sub_10042AC38(&__len[1], a1 + 184);
  sub_100242F54((uint64_t)v14);
  *a3 = 0;
  uint64_t v6 = v12;
  if (v12 == &__len[1]) {
    goto LABEL_9;
  }
  while (1)
  {
    memset(v23, 0, sizeof(v23));
    __len[0] = 0;
    (*(void (**)(void, _OWORD *, _WORD *))(**((void **)v6 + 2) + 200LL))(*((void *)v6 + 2), v23, __len);
    int v7 = __len[0];
    if (__len[0]) {
      break;
    }
LABEL_5:
    uint64_t v6 = (_WORD *)*((void *)v6 + 1);
    if (v6 == &__len[1]) {
      goto LABEL_9;
    }
  }

  int v8 = (unsigned __int16)*a3;
  if (v8 + __len[0] <= 8)
  {
    memmove(&a2[(unsigned __int16)*a3], a2, __len[0]);
    *a3 += v7;
    goto LABEL_5;
  }

  int v9 = (os_log_s *)qword_1008F7578;
  if (os_log_type_enabled((os_log_t)qword_1008F7578, OS_LOG_TYPE_ERROR))
  {
    *(_DWORD *)std::string buf = 67109888;
    int v16 = v7;
    __int16 v17 = 1024;
    int v18 = v8;
    __int16 v19 = 1024;
    int v20 = v8 + v7;
    __int16 v21 = 2048;
    uint64_t v22 = 8LL;
    _os_log_error_impl( (void *)&_mh_execute_header,  v9,  OS_LOG_TYPE_ERROR,  "EIR data length: %d + data length: %d = %d > %lu",  buf,  0x1Eu);
  }

void sub_10042A388(_Unwind_Exception *a1, uint64_t a2, ...)
{
  uint64_t v3 = va_arg(va1, void);
  uint64_t v5 = va_arg(va1, void);
  uint64_t v6 = va_arg(va1, void);
  sub_10023DF50((uint64_t *)va);
  sub_100242FAC((uint64_t)va1);
  _Unwind_Resume(a1);
}

uint64_t sub_10042A3B8(int64x2_t *a1, uint64_t a2, uint64_t a3)
{
  uint64_t v6 = (os_log_s *)qword_1008F7578;
  if (os_log_type_enabled((os_log_t)qword_1008F7578, OS_LOG_TYPE_ERROR)) {
    sub_10067DF84(a2, v6);
  }
  if (qword_1008D67E8 != -1) {
    dispatch_once(&qword_1008D67E8, &stru_100897E98);
  }
  int v7 = (_DWORD *)sub_1003C9FF4((uint64_t)off_1008D67E0, a2);
  if ((_DWORD)a3 && v7 && *v7 == 3)
  {
    if (qword_1008D67E8 != -1) {
      dispatch_once(&qword_1008D67E8, &stru_100897E98);
    }
    sub_1003CA640((uint64_t)off_1008D67E0, a2, a3);
    int v8 = (os_log_s *)qword_1008F7578;
    if (os_log_type_enabled((os_log_t)qword_1008F7578, OS_LOG_TYPE_DEFAULT))
    {
      *(_WORD *)uint64_t v10 = 0;
      _os_log_impl( (void *)&_mh_execute_header,  v8,  OS_LOG_TYPE_DEFAULT,  "Removed device tracking for fast connect after SDP",  v10,  2u);
    }
  }

  sub_100422B6C((uint64_t)a1, a2, 0LL, 0, 11LL, a3, 0);
  return sub_100423730(a1, a2);
}

uint64_t sub_10042A508(uint64_t a1)
{
  *(_BYTE *)(*(void *)(a1 + 32) + 114LL) = 1;
  uint64_t v24 = 0LL;
  uint64_t v25 = 0LL;
  sub_1003D55EC(*(void *)(a1 + 40), (_DWORD *)&v25 + 1, &v25, (_DWORD *)&v24 + 1, &v24);
  uint64_t v23 = 0LL;
  __int128 v21 = 0u;
  memset(v22, 0, sizeof(v22));
  *(_OWORD *)__int16 v19 = 0u;
  __int128 v20 = 0u;
  memset(v18, 0, sizeof(v18));
  sub_10020E564((uint64_t)v18);
  uint64_t v2 = sub_1001FD17C(v18, (uint64_t)"VID:", 4LL);
  std::to_string(&v17, v25);
  if ((v17.__r_.__value_.__s.__size_ & 0x80u) == 0) {
    uint64_t v3 = &v17;
  }
  else {
    uint64_t v3 = (std::string *)v17.__r_.__value_.__r.__words[0];
  }
  if ((v17.__r_.__value_.__s.__size_ & 0x80u) == 0) {
    uint64_t size = v17.__r_.__value_.__s.__size_;
  }
  else {
    uint64_t size = v17.__r_.__value_.__l.__size_;
  }
  uint64_t v5 = sub_1001FD17C(v2, (uint64_t)v3, size);
  uint64_t v6 = sub_1001FD17C(v5, (uint64_t)" PID:", 5LL);
  std::to_string(&__p, HIDWORD(v24));
  if ((__p.__r_.__value_.__s.__size_ & 0x80u) == 0) {
    p_p = &__p;
  }
  else {
    p_p = (std::stringbuf::string_type *)__p.__r_.__value_.__r.__words[0];
  }
  if ((__p.__r_.__value_.__s.__size_ & 0x80u) == 0) {
    uint64_t v8 = __p.__r_.__value_.__s.__size_;
  }
  else {
    uint64_t v8 = __p.__r_.__value_.__l.__size_;
  }
  sub_1001FD17C(v6, (uint64_t)p_p, v8);
  if (qword_1008D9060 != -1) {
    dispatch_once(&qword_1008D9060, &stru_100897F98);
  }
  uint64_t v9 = qword_1008D9058;
  sub_10002418C(&v17, "Service Manager Stall");
  std::stringbuf::str(&__p, (const std::stringbuf *)((char *)v18 + 8));
  sub_10040C784(0.0, v9, (uint64_t *)&v17, (uint64_t *)&__p);
  uint64_t v10 = (os_log_s *)qword_1008F7578;
  if (os_log_type_enabled((os_log_t)qword_1008F7578, OS_LOG_TYPE_ERROR))
  {
    sub_1003CF00C(*(void *)(a1 + 40), &v17);
    int v12 = (char)v17.__r_.__value_.__s.__size_;
    std::string::size_type v13 = v17.__r_.__value_.__r.__words[0];
    std::stringbuf::str(&__p, (const std::stringbuf *)((char *)v18 + 8));
    id v14 = &v17;
    if (v12 < 0) {
      id v14 = (std::string *)v13;
    }
    if ((__p.__r_.__value_.__s.__size_ & 0x80u) == 0) {
      uint64_t v15 = &__p;
    }
    else {
      uint64_t v15 = (std::stringbuf::string_type *)__p.__r_.__value_.__r.__words[0];
    }
    *(_DWORD *)std::string buf = 136446466;
    uint64_t v27 = v14;
    __int16 v28 = 2080;
    int v29 = v15;
    _os_log_error_impl( (void *)&_mh_execute_header,  v10,  OS_LOG_TYPE_ERROR,  "Service Manager Stalled due to %{public}s. Triggering ABC for %s",  buf,  0x16u);
  }

  if (SHIBYTE(v20) < 0) {
    operator delete(v19[1]);
  }
  std::streambuf::~streambuf((char *)v18 + 8);
  return std::ios::~ios(v22);
}

void sub_10042A814( _Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, void *a9, uint64_t a10, int a11, __int16 a12, char a13, char a14, void *__p, uint64_t a16, int a17, __int16 a18, char a19, char a20, char a21)
{
  if (a20 < 0) {
    operator delete(__p);
  }
  sub_10020E784((uint64_t)&a21);
  _Unwind_Resume(a1);
}

void sub_10042A874()
{
}

uint64_t sub_10042A884(unint64_t *a1)
{
  uint64_t result = sub_10042A8FC((uint64_t)a1, a1[2]);
  if ((_DWORD)result) {
    return (*(uint64_t (**)(unint64_t *, unint64_t, unint64_t, unint64_t))(*a1 + 40))( a1,  a1[2],  a1[3],  a1[4]);
  }
  return result;
}

uint64_t sub_10042A8CC( uint64_t a1, uint64_t a2, uint64_t (*a3)(uint64_t, uint64_t, uint64_t, uint64_t, uint64_t, uint64_t), uint64_t a4)
{
  return sub_1003B4E10( a2,  a3,  *(void *)(a1 + 40),  *(unsigned int *)(a1 + 48),  *(unsigned int *)(a1 + 52),  *(unsigned int *)(a1 + 56),  *(unsigned int *)(a1 + 60),  a4);
}

BOOL sub_10042A8FC(uint64_t a1, unint64_t a2)
{
  if (qword_1008D61A8 != -1) {
    dispatch_once(&qword_1008D61A8, &stru_100897E18);
  }
  return sub_100497204(qword_1008D61A0, a2);
}

void sub_10042A94C(id a1)
{
  int v1 = operator new(0x248uLL);
  sub_1004881E8();
  qword_1008D9888 = (uint64_t)v1;
}

void sub_10042A97C(_Unwind_Exception *a1)
{
}

void sub_10042A990(id a1)
{
  int v1 = operator new(0x148uLL);
  sub_100493598();
  off_1008D9728 = v1;
}

void sub_10042A9C0(_Unwind_Exception *a1)
{
}

void sub_10042A9D4(id a1)
{
  int v1 = operator new(0x198uLL);
  sub_1003A1A98((uint64_t)v1);
  off_1008D9898 = v1;
}

void sub_10042AA04(_Unwind_Exception *a1)
{
}

void sub_10042AA18(id a1)
{
  int v1 = operator new(0x148uLL);
  sub_1005242D4();
  off_1008D98A8 = v1;
}

void sub_10042AA48(_Unwind_Exception *a1)
{
}

void sub_10042AA5C(id a1)
{
  int v1 = operator new(0x148uLL);
  sub_10054E6A8();
  off_1008D9120 = v1;
}

void sub_10042AA8C(_Unwind_Exception *a1)
{
}

void sub_10042AAA0(id a1)
{
  int v1 = operator new(0x148uLL);
  sub_1003C0930((uint64_t)v1);
  qword_1008D98B8 = (uint64_t)v1;
}

void sub_10042AAD0(_Unwind_Exception *a1)
{
}

void sub_10042AAE4(id a1)
{
  int v1 = operator new(0x148uLL);
  sub_1004C4914();
  qword_1008D98C8 = (uint64_t)v1;
}

void sub_10042AB14(_Unwind_Exception *a1)
{
}

void sub_10042AB28(id a1)
{
  int v1 = operator new(0x1B0uLL);
  sub_100213528((uint64_t)v1);
  off_1008D9110 = v1;
}

void sub_10042AB58(_Unwind_Exception *a1)
{
}

void sub_10042AB6C(id a1)
{
  int v1 = operator new(0x150uLL);
  sub_1005C54A8();
  qword_1008D98D8 = (uint64_t)v1;
}

void sub_10042AB9C(_Unwind_Exception *a1)
{
}

void sub_10042ABB0(id a1)
{
  int v1 = operator new(0x120uLL);
  sub_100495250();
  qword_1008D61A0 = (uint64_t)v1;
}

void sub_10042ABE0(_Unwind_Exception *a1)
{
}

void sub_10042ABF4(id a1)
{
  int v1 = operator new(0x230uLL);
  sub_10042BC28();
  off_1008D60A8 = v1;
}

void sub_10042AC24(_Unwind_Exception *a1)
{
}

void *sub_10042AC38(void *a1, uint64_t a2)
{
  *a1 = a1;
  a1[1] = a1;
  a1[2] = 0LL;
  uint64_t v3 = *(void *)(a2 + 8);
  if (v3 != a2)
  {
    uint64_t v5 = 1LL;
    uint64_t v6 = a1;
    do
    {
      int v7 = operator new(0x18uLL);
      uint64_t v8 = *(void *)(v3 + 16);
      v7[1] = a1;
      void v7[2] = v8;
      *int v7 = v6;
      v6[1] = v7;
      *a1 = v7;
      a1[2] = v5;
      uint64_t v3 = *(void *)(v3 + 8);
      ++v5;
      uint64_t v6 = v7;
    }

    while (v3 != a2);
  }

  return a1;
}

void sub_10042ACBC(_Unwind_Exception *a1)
{
}

uint64_t sub_10042ACD0(uint64_t a1, uint64_t a2, uint64_t a3)
{
  if (a2 != a3)
  {
    uint64_t v3 = *(void *)(a1 + 8);
    uint64_t v4 = a2;
    if (a3 != v3)
    {
      uint64_t v5 = 32 * ((a3 - a2) >> 5);
      uint64_t v4 = a2;
      do
      {
        *(_OWORD *)uint64_t v4 = *(_OWORD *)(v4 + v5);
        *(_DWORD *)(v4 + 16) = *(_DWORD *)(v4 + v5 + 16);
        *(void *)(v4 + 24) = *(void *)(v4 + v5 + 24);
        v4 += 32LL;
      }

      while (v4 + v5 != v3);
    }

    *(void *)(a1 + sub_100242E28(v1 + 8) = v4;
  }

  return a2;
}

uint64_t sub_10042AD34(uint64_t result, uint64_t a2, uint64_t a3)
{
  while (1)
  {
    if (result == a2) {
      return a2;
    }
    if (*(void *)result == a3) {
      break;
    }
    result += 32LL;
  }

  if (result != a2)
  {
    for (uint64_t i = result + 32; i != a2; i += 32LL)
    {
      if (*(void *)i != a3)
      {
        uint64_t v4 = *(void *)(i + 8);
        *(void *)uint64_t result = *(void *)i;
        *(void *)(result + sub_100242E28(v1 + 8) = v4;
        *(_DWORD *)(result + 16) = *(_DWORD *)(i + 16);
        *(void *)(result + 24) = *(void *)(i + 24);
        result += 32LL;
      }
    }
  }

  return result;
}

uint64_t sub_10042AD9C(uint64_t *a1, uint64_t a2)
{
  uint64_t v2 = *a1;
  uint64_t v3 = (a1[1] - *a1) >> 5;
  unint64_t v4 = v3 + 1;
  uint64_t v8 = a1[2];
  uint64_t v7 = (uint64_t)(a1 + 2);
  uint64_t v9 = v8 - v2;
  if (v9 >> 4 > v4) {
    unint64_t v4 = v9 >> 4;
  }
  else {
    unint64_t v10 = v4;
  }
  uint64_t v20 = v7;
  uint64_t v11 = (char *)sub_100240F38(v7, v10);
  int v12 = &v11[32 * v3];
  std::stringbuf::string_type __p = v11;
  std::string v17 = v12;
  __int16 v19 = &v11[32 * v13];
  *(_OWORD *)int v12 = *(_OWORD *)a2;
  *((_DWORD *)v12 + 4) = *(_DWORD *)(a2 + 16);
  *((void *)v12 + 3) = *(void *)(a2 + 24);
  int v18 = v12 + 32;
  sub_10042AEBC(a1, &__p);
  uint64_t v14 = a1[1];
  if (v18 != v17) {
    v18 += (v17 - v18 + 31) & 0xFFFFFFFFFFFFFFE0LL;
  }
  if (__p) {
    operator delete(__p);
  }
  return v14;
}

void sub_10042AE84( _Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void *__p, uint64_t a11, uint64_t a12)
{
  if (__p) {
    operator delete(__p);
  }
  _Unwind_Resume(exception_object);
}

uint64_t *sub_10042AEBC(uint64_t *result, void *a2)
{
  uint64_t v3 = *result;
  uint64_t v2 = result[1];
  uint64_t v4 = a2[1];
  if (v2 != *result)
  {
    uint64_t v5 = 0LL;
    do
    {
      uint64_t v6 = v4 + v5;
      *(_OWORD *)(v6 - sub_100242FAC(v1 - 32) = *(_OWORD *)(v2 + v5 - 32);
      *(_DWORD *)(v6 - 16) = *(_DWORD *)(v2 + v5 - 16);
      *(void *)(v6 - sub_100242E28(v1 + 8) = *(void *)(v2 + v5 - 8);
      v5 -= 32LL;
    }

    while (v2 + v5 != v3);
    v4 += v5;
  }

  a2[1] = v4;
  uint64_t v7 = *result;
  *uint64_t result = v4;
  a2[1] = v7;
  uint64_t v8 = result[1];
  result[1] = a2[2];
  a2[2] = v8;
  uint64_t v9 = result[2];
  result[2] = a2[3];
  a2[3] = v9;
  *a2 = a2[1];
  return result;
}

uint64_t sub_10042AF40(uint64_t result, uint64_t a2, uint64_t a3, uint64_t a4)
{
  if (result != a2)
  {
    while (*(void *)result != a3 || a4 != *(void *)(result + 8))
    {
      result += 32LL;
      if (result == a2) {
        return a2;
      }
    }
  }

  if (result == a2) {
    return a2;
  }
  for (uint64_t i = result + 32; i != a2; i += 32LL)
  {
    if (*(void *)i != a3 || a4 != *(void *)(i + 8))
    {
      uint64_t v5 = *(void *)(i + 8);
      *(void *)uint64_t result = *(void *)i;
      *(void *)(result + sub_100242E28(v1 + 8) = v5;
      *(_DWORD *)(result + 16) = *(_DWORD *)(i + 16);
      *(void *)(result + 24) = *(void *)(i + 24);
      result += 32LL;
    }
  }

  return result;
}

void sub_10042AFD8(id a1)
{
  int v1 = operator new(0x138uLL);
  sub_1003FE3E0((uint64_t)v1);
  off_1008D5F48 = v1;
}

void sub_10042B008(_Unwind_Exception *a1)
{
}

void sub_10042B01C(id a1)
{
  int v1 = operator new(0x68uLL);
  sub_10049435C();
  off_1008D9130 = v1;
}

void sub_10042B04C(_Unwind_Exception *a1)
{
}

void sub_10042B060(id a1)
{
  int v1 = operator new(0x98uLL);
  sub_1003C97E4((uint64_t)v1);
  off_1008D67E0 = v1;
}

void sub_10042B090(_Unwind_Exception *a1)
{
}

void sub_10042B0A4(id a1)
{
  int v1 = operator new(0x128uLL);
  sub_1005C69F8();
  off_1008D5F28 = v1;
}

void sub_10042B0D4(_Unwind_Exception *a1)
{
}

void sub_10042B0E8(id a1)
{
  int v1 = operator new(0x58uLL);
  sub_10041A094(v1);
  qword_1008D95F8 = (uint64_t)v1;
}

void sub_10042B118(_Unwind_Exception *a1)
{
}

void sub_10042B12C(id a1)
{
  int v1 = operator new(0x2C0uLL);
  sub_100421070((uint64_t)v1);
  off_1008D60C8 = v1;
}

void sub_10042B15C(_Unwind_Exception *a1)
{
}

void sub_10042B170(id a1)
{
  int v1 = operator new(0xA8uLL);
  sub_10040D0A0((uint64_t)v1);
  off_1008D6780 = v1;
}

void sub_10042B1A0(_Unwind_Exception *a1)
{
}

void sub_10042B1B4(id a1)
{
  int v1 = operator new(0x2B0uLL);
  sub_10057DEC8();
  off_1008D9140 = v1;
}

void sub_10042B1E4(_Unwind_Exception *a1)
{
}

void sub_10042B1F8(id a1)
{
  int v1 = (char *)operator new(0x200uLL);
  *(void *)int v1 = off_100898F60;
  *((void *)v1 + 1) = &off_100898FF0;
  *((void *)v1 + 2) = off_100899008;
  *((void *)v1 + 3) = &off_100899060;
  *((void *)v1 + 4) = &off_100899078;
  sub_100242DC4(v1 + 40);
  *((void *)v1 + 14) = 0LL;
  *((_DWORD *)v1 + 3sub_100414D2C(qword_1008F72C0, 0) = 0;
  *((void *)v1 + 17) = 0LL;
  *((void *)v1 + 1sub_100242E28(v1 + 8) = 0LL;
  *((void *)v1 + 16) = 0LL;
  *(_OWORD *)(v1 + 155) = 0u;
  *(_OWORD *)(v1 + 171) = 0u;
  *(_OWORD *)(v1 + 187) = 0u;
  *(_WORD *)(v1 + 203) = 1;
  *((void *)v1 + 26) = 0LL;
  *((_WORD *)v1 + 10sub_100242E28(v1 + 8) = 256;
  *((void *)v1 + 29) = 0LL;
  *((void *)v1 + 2sub_100242E28(v1 + 8) = v1 + 232;
  *((void *)v1 + sub_100242FAC(v1 - 32) = 0LL;
  *((void *)v1 + 33) = 0LL;
  *((void *)v1 + 3sub_100414D2C(qword_1008F72C0, 0) = 0LL;
  *((void *)v1 + 31) = v1 + 256;
  v1[272] = 0;
  *((_DWORD *)v1 + 69) = 0;
  v1[280] = 0;
  *((_WORD *)v1 + 189) = 0;
  *(void *)(v1 + 313) = 0LL;
  *(_OWORD *)(v1 + 30sub_100414D2C(qword_1008F72C0, 0) = 0u;
  *(_OWORD *)(v1 + 284) = 0u;
  *(_OWORD *)(v1 + 32sub_100242E28(v1 + 8) = 0u;
  *(_OWORD *)(v1 + 344) = 0u;
  *(_OWORD *)(v1 + 36sub_100414D2C(qword_1008F72C0, 0) = 0u;
  v1[376] = 0;
  *((void *)v1 + 51) = v1 + 416;
  *((void *)v1 + 52) = 0LL;
  *((void *)v1 + 55) = 0LL;
  *((void *)v1 + 56) = 0LL;
  *((void *)v1 + 53) = 0LL;
  *((void *)v1 + 54) = v1 + 440;
  *((void *)v1 + 57) = v1 + 464;
  *((void *)v1 + 5sub_100242E28(v1 + 8) = 0LL;
  *((void *)v1 + 59) = 0LL;
  *((void *)v1 + 6sub_100414D2C(qword_1008F72C0, 0) = @"XZ";
  *((void *)v1 + sub_100242E28(v3 + 62) = 0LL;
  *((_DWORD *)v1 + 126) = 0;
  off_1008D6190 = v1;
}

void sub_10042B300(_Unwind_Exception *a1)
{
}

void sub_10042B314(id a1)
{
  int v1 = operator new(0x618uLL);
  sub_10058B0A4();
  off_1008D5F08 = v1;
}

void sub_10042B344(_Unwind_Exception *a1)
{
}

void sub_10042B358(id a1)
{
  int v1 = operator new(0x18uLL);
  *(void *)int v1 = 0LL;
  v1[2] = 0;
  *((_BYTE *)v1 + 12) = 0;
  v1[4] = 0;
  qword_1008D9058 = (uint64_t)v1;
}

void sub_10042B388()
{
  int v0 = objc_autoreleasePoolPush();
  sub_10002418C(v2, "com.apple.springboard");
  sub_10002418C(v3, "com.apple.Preferences");
  sub_10002418C(v4, "com.apple.preferences");
  sub_10002418C(v5, "com.apple.figEndpoint");
  sub_10002418C(v6, "SFBluetoothPairingSession");
  sub_10002418C(v7, "com.apple.NanoSettings");
  sub_10002418C(v8, "com.apple.NanoMusic");
  sub_100329294((uint64_t)&qword_1008F73C0, v2, 7LL);
  for (uint64_t i = 0LL; i != -21; i -= 3LL)
  {
    if (SHIBYTE(v8[i + 2]) < 0) {
      operator delete((void *)v8[i]);
    }
  }

  __cxa_atexit((void (*)(void *))sub_100421048, &qword_1008F73C0, (void *)&_mh_execute_header);
  objc_autoreleasePoolPop(v0);
}

void sub_10042B4E0( _Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, char a11)
{
  uint64_t v13 = 0LL;
  while (1)
  {
    v13 -= 24LL;
    if (v13 == -168) {
      _Unwind_Resume(exception_object);
    }
  }

void sub_10042B540(uint64_t a1, int a2)
{
  uint64_t v4 = (os_log_s *)qword_1008F7578;
  if (os_log_type_enabled((os_log_t)qword_1008F7578, OS_LOG_TYPE_DEFAULT))
  {
    uint64_t v5 = "Completed";
    if (a2) {
      uint64_t v5 = "Needs to run";
    }
    uint64_t v6 = "";
    if (!*(_BYTE *)(a1 + 76)) {
      uint64_t v6 = " But Stack is not ready";
    }
    int v8 = 136446466;
    uint64_t v9 = v5;
    __int16 v10 = 2080;
    uint64_t v11 = v6;
    _os_log_impl( (void *)&_mh_execute_header,  v4,  OS_LOG_TYPE_DEFAULT,  "Current StackManager SetupBuddy state: %{public}s.%s",  (uint8_t *)&v8,  0x16u);
  }

  if (*(_BYTE *)(a1 + 557))
  {
    *(_BYTE *)(a1 + 557) = a2;
    if ((a2 & 1) == 0)
    {
      sub_10042B698(a1);
      if (*(_BYTE *)(a1 + 76))
      {
        LOBYTE(vsub_100242E28(v1 + 8) = 0;
        sub_100242CA4(&v8);
        sub_1001BDAB0();
        sub_100242CD0(&v8);
        sub_100242CD8(&v8);
      }

      uint64_t v7 = sub_1002E8D54();
      sub_10024E060(v7 + 488, a1 + 56);
    }
  }

void sub_10042B67C( _Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, char a9)
{
}

void sub_10042B698(uint64_t a1)
{
  int v1 = *(dispatch_source_s **)(a1 + 64);
  if (v1)
  {
    uint64_t v3 = (os_log_s *)qword_1008F7578;
    if (os_log_type_enabled((os_log_t)qword_1008F7578, OS_LOG_TYPE_DEFAULT))
    {
      *(_WORD *)uint64_t v4 = 0;
      _os_log_impl((void *)&_mh_execute_header, v3, OS_LOG_TYPE_DEFAULT, "StackManager setupTimer cancelled!", v4, 2u);
      int v1 = *(dispatch_source_s **)(a1 + 64);
    }

    dispatch_source_cancel(v1);
    dispatch_release(*(dispatch_object_t *)(a1 + 64));
    *(void *)(a1 + sub_100242FAC(v30 - 64) = 0LL;
  }

void sub_10042B728(uint64_t a1, int a2)
{
}

void sub_10042B730(uint64_t a1)
{
  uint64_t v2 = (os_log_s *)qword_1008F7578;
  if (os_log_type_enabled((os_log_t)qword_1008F7578, OS_LOG_TYPE_DEFAULT))
  {
    if (*(_BYTE *)(a1 + 76)) {
      uint64_t v3 = "";
    }
    else {
      uint64_t v3 = " But Stack is not ready";
    }
    int v4 = 136315138;
    uint64_t v5 = v3;
    _os_log_impl( (void *)&_mh_execute_header,  v2,  OS_LOG_TYPE_DEFAULT,  "StackManager setupTimer expired.%s",  (uint8_t *)&v4,  0xCu);
  }

  if (*(_BYTE *)(a1 + 557))
  {
    sub_10042B840(a1);
    if (*(_BYTE *)(a1 + 76))
    {
      LOBYTE(v4) = 0;
      sub_100242CA4(&v4);
      sub_1001BDAB0();
      sub_100242CD0(&v4);
      sub_100242CD8(&v4);
    }
  }

void sub_10042B824( _Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, char a9)
{
}

void sub_10042B840(uint64_t a1)
{
  if (!*(void *)(a1 + 64))
  {
    uint64_t v2 = (os_log_s *)qword_1008F7578;
    if (os_log_type_enabled((os_log_t)qword_1008F7578, OS_LOG_TYPE_DEFAULT))
    {
      *(_DWORD *)std::string buf = 134217984;
      uint64_t v9 = 43200000LL;
      _os_log_impl( (void *)&_mh_execute_header,  v2,  OS_LOG_TYPE_DEFAULT,  "StackManager setupTimer %llu ms armed!",  buf,  0xCu);
    }

    uint64_t v3 = sub_100404EB8();
    int v4 = dispatch_source_create( (dispatch_source_type_t)&_dispatch_source_type_timer,  0LL,  0LL,  *(dispatch_queue_t *)(v3 + 8));
    *(void *)(a1 + sub_100242FAC(v30 - 64) = v4;
    handler[0] = _NSConcreteStackBlock;
    handler[1] = 3221225472LL;
    handler[2] = sub_10042B97C;
    handler[3] = &unk_10087EB20;
    handler[4] = a1;
    dispatch_source_set_event_handler(v4, handler);
    uint64_t v5 = *(dispatch_source_s **)(a1 + 64);
    dispatch_time_t v6 = dispatch_time(0x8000000000000000LL, 43200000000000LL);
    dispatch_source_set_timer(v5, v6, 0xFFFFFFFFFFFFFFFFLL, 0LL);
    dispatch_activate(*(dispatch_object_t *)(a1 + 64));
  }

void sub_10042B97C(uint64_t a1)
{
  uint64_t v1 = *(void *)(a1 + 32);
  sub_10042B698(v1);
  sub_10042B730(v1);
}

void sub_10042B9A4()
{
  if (qword_1008D60B0 != -1) {
    dispatch_once(&qword_1008D60B0, &stru_1008983A0);
  }
  if (*((_BYTE *)off_1008D60A8 + 557))
  {
    int v0 = (os_log_s *)qword_1008F7578;
    if (os_log_type_enabled((os_log_t)qword_1008F7578, OS_LOG_TYPE_DEFAULT))
    {
      *(_WORD *)uint64_t v1 = 0;
      _os_log_impl( (void *)&_mh_execute_header,  v0,  OS_LOG_TYPE_DEFAULT,  "Cancel private address rotation timer since setup is not complete",  v1,  2u);
    }

    sub_1001BF0BC();
  }

uint64_t sub_10042BA44(uint64_t a1)
{
  *(void *)a1 = off_100897FC8;
  *(void *)(a1 + sub_100242E28(v1 + 8) = &off_100898068;
  *(void *)(a1 + 16) = off_100898080;
  *(void *)(a1 + 24) = &off_1008980B0;
  *(void *)(a1 + sub_100242FAC(v1 - 32) = &off_1008980C8;
  *(void *)(a1 + 4sub_100414D2C(qword_1008F72C0, 0) = &off_1008980E0;
  *(void *)(a1 + 4sub_100242E28(v1 + 8) = off_1008980F8;
  *(void *)(a1 + 56) = &off_100898138;
  *(_DWORD *)(a1 + 72) = 0;
  *(_BYTE *)(a1 + sub_10023DF50(v3 + 76) = 0;
  *(_DWORD *)(a1 + 8sub_100414D2C(qword_1008F72C0, 0) = 0;
  *(void *)(a1 + 8sub_100242E28(v1 + 8) = 0LL;
  *(void *)(a1 + 12sub_100414D2C(qword_1008F72C0, 0) = 0LL;
  *(void *)(a1 + 12sub_100242E28(v1 + 8) = 0LL;
  *(void *)(a1 + 136) = 0LL;
  *(void *)(a1 + 96) = 0LL;
  *(void *)(a1 + 104) = 0LL;
  *(_DWORD *)(a1 + 112) = 0;
  sub_100242DC4(a1 + 144);
  *(_BYTE *)(a1 + 215) = 0;
  *(_WORD *)(a1 + 21sub_100242E28(v1 + 8) = 0;
  *(_DWORD *)(a1 + 20sub_100242E28(v1 + 8) = 0;
  *(_BYTE *)(a1 + 212) = 0;
  sub_100242DC4(a1 + 224);
  *(_WORD *)(a1 + 292) = 0;
  *(_DWORD *)(a1 + 28sub_100242E28(v1 + 8) = 0;
  *(void *)(a1 + 304) = 0LL;
  *(void *)(a1 + 312) = 0LL;
  *(void *)(a1 + 296) = 0LL;
  *(_DWORD *)(a1 + 36sub_100242E28(v1 + 8) = 0xFFFF;
  *(void *)(a1 + 384) = 0LL;
  *(void *)(a1 + 392) = 0LL;
  *(void *)(a1 + 3sub_10023DF50(v3 + 76) = 0LL;
  sub_100242DC4(a1 + 408);
  *(void *)(a1 + 48sub_100414D2C(qword_1008F72C0, 0) = 0LL;
  sub_100242DC4(a1 + 488);
  *(_BYTE *)(a1 + 556) = 0;
  if (qword_1008D6198 != -1) {
    dispatch_once(&qword_1008D6198, &stru_100898420);
  }
  *(_BYTE *)(a1 + 219) = sub_10044916C() != 0.0;
  *(void *)(a1 + sub_100242FAC(v30 - 64) = 0LL;
  return a1;
}

void sub_10042BB8C(_Unwind_Exception *a1, uint64_t a2, ...)
{
  uint64_t v8 = v5;
  sub_100242E28(v8);

  sub_100242E28(v6);
  sub_100242E28(v4);
  sub_100242E28(v3);
  sub_100438558((void ***)va);
  __int16 v10 = *v7;
  if (*v7)
  {
    *(void *)(v2 + 96) = v10;
    operator delete(v10);
  }

  _Unwind_Resume(a1);
}

uint64_t sub_10042BC2C(uint64_t a1)
{
  *(_BYTE *)(a1 + 40sub_100414D2C(qword_1008F72C0, 0) = 0;
  *(_BYTE *)(a1 + 40sub_100414D2C(qword_1008F72C0, 0) = sub_10042BC7C(a1);
  *(_BYTE *)(a1 + 472) = 0;
  *(_BYTE *)(a1 + 472) = sub_10042BCE4(a1);
  *(_DWORD *)(a1 + 552) = 0;
  uint64_t v2 = sub_1002E6E00();
  uint64_t result = (*(uint64_t (**)(uint64_t))(*(void *)v2 + 656LL))(v2);
  *(_BYTE *)(a1 + 21sub_100242E28(v1 + 8) = result;
  return result;
}

uint64_t sub_10042BC7C(uint64_t a1)
{
  v4[0] = 0LL;
  v4[1] = 0LL;
  sub_100242F28((uint64_t)v4, a1 + 408);
  uint64_t v2 = *(unsigned __int8 *)(a1 + 400);
  if (!*(_BYTE *)(a1 + 400)) {
    uint64_t v2 = sub_10043498C(a1);
  }
  sub_100242FAC((uint64_t)v4);
  return v2;
}

void sub_10042BCD0( _Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9)
{
}

uint64_t sub_10042BCE4(uint64_t a1)
{
  v4[0] = 0LL;
  v4[1] = 0LL;
  sub_100242F28((uint64_t)v4, a1 + 408);
  uint64_t v2 = *(unsigned __int8 *)(a1 + 472);
  if (!*(_BYTE *)(a1 + 472)) {
    uint64_t v2 = sub_1004347C0(a1);
  }
  sub_100242FAC((uint64_t)v4);
  return v2;
}

void sub_10042BD38( _Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9)
{
}

void sub_10042BD4C()
{
  if (qword_1008F0B00 != -1) {
    dispatch_once(&qword_1008F0B00, &stru_100898140);
  }
}

void sub_10042BD74(id a1)
{
  if (sub_1000FCD0C() == 7)
  {
    char v1 = sub_10007D33C( (uint64_t (*)(void, void))sub_10042BE7C,  (uint64_t)sub_10042BFA0,  (uint64_t (*)(void, void))sub_10042C160);
    uint64_t v2 = sub_1002E6E00();
    uint64_t v3 = v2;
    if ((v1 & 1) == 0)
    {
      sub_10002418C(v6, "StackManager::initTransport");
      sub_1004FB370(v3, 3713LL, (uint64_t)v6, 1);
    }

    (*(void (**)(uint64_t, void))(*(void *)v2 + 488LL))(v2, 0LL);
    if ((sub_10007D528((uint64_t)sub_10042C218) & 1) == 0)
    {
      uint64_t v4 = sub_1002E6E00();
      sub_10002418C(v5, "StackManager::initTransport");
      sub_1004FB370(v4, 3714LL, (uint64_t)v5, 1);
    }
  }

void sub_10042BE48( _Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, void *a9, uint64_t a10, int a11, __int16 a12, char a13, char a14, char a15, uint64_t a16, int a17, __int16 a18, char a19, char a20)
{
  if (a14 < 0) {
    operator delete(a9);
  }
  _Unwind_Resume(exception_object);
}

void sub_10042BE7C(char *a1, int a2)
{
  if (a2)
  {
    if (qword_1008D60B0 != -1) {
      dispatch_once(&qword_1008D60B0, &stru_1008983A0);
    }
    sub_100431EEC((uint64_t)a1, 8, 0, (uint64_t)a1);
    if (qword_1008D60B0 != -1) {
      dispatch_once(&qword_1008D60B0, &stru_1008983A0);
    }
    uint64_t v4 = off_1008D60A8;
    sub_10002418C(&v7, a1);
    sub_1004319D0((uint64_t)v4, 1214, &v7);
  }

  if (sub_1002E8D94())
  {
    uint64_t v3 = sub_1002E8D94();
    sub_10002418C(__p, a1);
    (*(void (**)(uint64_t, uint64_t, void, void **))(*(void *)v3 + 104LL))(v3, 9LL, 0LL, __p);
    if (v6 < 0) {
      operator delete(__p[0]);
    }
  }

void sub_10042BF70( _Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, void *__p, uint64_t a10, int a11, __int16 a12, char a13, char a14, uint64_t a15, uint64_t a16, int a17, __int16 a18, char a19, char a20)
{
  if (a14 < 0) {
    operator delete(__p);
  }
  _Unwind_Resume(exception_object);
}

void sub_10042BFA0(char *a1, _BYTE *a2)
{
  if (qword_1008D6788 != -1) {
    dispatch_once(&qword_1008D6788, &stru_100898400);
  }
  int v4 = sub_1002075B4((uint64_t)off_1008D6780);
  uint64_t v5 = (os_log_s *)qword_1008F7578;
  BOOL v6 = os_log_type_enabled((os_log_t)qword_1008F7578, OS_LOG_TYPE_DEFAULT);
  if (v6)
  {
    __int128 v7 = "non-";
    if (v4 == 1) {
      __int128 v7 = "";
    }
    *(_DWORD *)std::string buf = 67109378;
    int v11 = v4;
    __int16 v12 = 2080;
    uint64_t v13 = v7;
    _os_log_impl( (void *)&_mh_execute_header,  v5,  OS_LOG_TYPE_DEFAULT,  "Controller is resetting in power state %d, treating as %sfatal",  buf,  0x12u);
  }

  if (v4 == 1)
  {
    *a2 = 1;
    if (qword_1008D60B0 != -1) {
      dispatch_once(&qword_1008D60B0, &stru_1008983A0);
    }
    sub_100431EEC(v6, 10, 0, (uint64_t)a1);
    if (qword_1008D60B0 != -1) {
      dispatch_once(&qword_1008D60B0, &stru_1008983A0);
    }
    uint64_t v8 = off_1008D60A8;
    sub_10002418C(&v9, a1);
    sub_1004319D0((uint64_t)v8, 1214, &v9);
  }

void sub_10042C13C( _Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void *__p, uint64_t a11, int a12, __int16 a13, char a14, char a15)
{
  if (a15 < 0) {
    operator delete(__p);
  }
  _Unwind_Resume(exception_object);
}

void sub_10042C160(int a1, uint64_t a2)
{
  int v4 = (os_log_s *)qword_1008F7578;
  if (os_log_type_enabled((os_log_t)qword_1008F7578, OS_LOG_TYPE_DEFAULT))
  {
    v5[0] = 67109376;
    v5[1] = a1;
    __int16 v6 = 2048;
    uint64_t v7 = a2;
    _os_log_impl( (void *)&_mh_execute_header,  v4,  OS_LOG_TYPE_DEFAULT,  "driverMetricsCb: type %u arg %llu",  (uint8_t *)v5,  0x12u);
  }

void sub_10042C218(__int128 *a1)
{
  __int128 v3 = *a1;
  uint64_t v4 = *((void *)a1 + 2);
  uint64_t v1 = sub_100404EB8();
  v2[0] = _NSConcreteStackBlock;
  v2[1] = 3221225472LL;
  v2[2] = sub_1004358BC;
  v2[3] = &unk_100888050;
  sub_100405384(v1, v2);
}

uint64_t sub_10042C278(uint64_t a1, unsigned int a2, int a3)
{
  __int16 v6 = (os_log_s *)qword_1008F7578;
  if (os_log_type_enabled((os_log_t)qword_1008F7578, OS_LOG_TYPE_DEFAULT))
  {
    uint64_t v7 = *(int *)(a1 + 72);
    else {
      uint64_t v8 = off_100898540[v7];
    }
    __int128 v9 = "StackStarted";
    if (*(_BYTE *)(a1 + 76)) {
      __int16 v10 = "StackStarted";
    }
    else {
      __int16 v10 = "StackStopped";
    }
    if (a2 > 2) {
      int v11 = "Unknown State";
    }
    else {
      int v11 = off_100898540[a2];
    }
    if (!a3) {
      __int128 v9 = "StackStopped";
    }
    int v14 = 136446978;
    uint64_t v15 = v8;
    __int16 v16 = 2082;
    std::string v17 = v10;
    __int16 v18 = 2082;
    __int16 v19 = v11;
    __int16 v20 = 2082;
    __int128 v21 = v9;
    _os_log_impl( (void *)&_mh_execute_header,  v6,  OS_LOG_TYPE_DEFAULT,  "Stack: %{public}s/%{public}s -> %{public}s/%{public}s",  (uint8_t *)&v14,  0x2Au);
  }

  *(_DWORD *)(a1 + 72) = a2;
  if (a2 == 1) {
    char v12 = a3;
  }
  else {
    char v12 = 0;
  }
  *(_BYTE *)(a1 + sub_10023DF50(v3 + 76) = v12;
  return 0LL;
}

_BYTE *sub_10042C3B8()
{
  if (qword_1008D5F50 != -1) {
    dispatch_once(&qword_1008D5F50, &stru_100898440);
  }
  sub_100402E94((uint64_t)off_1008D5F48);
  if (qword_1008D5F30 != -1) {
    dispatch_once(&qword_1008D5F30, &stru_100898460);
  }
  sub_1005DC0A8((uint64_t)off_1008D5F28);
  if (qword_1008D60B0 != -1) {
    dispatch_once(&qword_1008D60B0, &stru_1008983A0);
  }
  if (*((_BYTE *)off_1008D60A8 + 76))
  {
    char v3 = 0;
    sub_100242CA4(&v3);
    sub_100091124();
    uint64_t v0 = sub_1002E8D54();
    (*(void (**)(uint64_t))(*(void *)v0 + 56LL))(v0);
    return sub_100242CD8(&v3);
  }

  else
  {
    sub_100091124();
    uint64_t v2 = sub_1002E8D54();
    return (_BYTE *)(*(uint64_t (**)(uint64_t))(*(void *)v2 + 56LL))(v2);
  }

void sub_10042C4C0( _Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, int a10, __int16 a11, char a12, char a13)
{
}

uint64_t sub_10042C4D4(uint64_t a1)
{
  uint64_t v2 = (os_log_s *)qword_1008F7578;
  if (os_log_type_enabled((os_log_t)qword_1008F7578, OS_LOG_TYPE_DEFAULT))
  {
    *(_DWORD *)std::string buf = 136446466;
    *(void *)&uint8_t buf[4] = "Nov 21 2024";
    *(_WORD *)&_BYTE buf[12] = 2082;
    *(void *)v154 = "21:12:21";
    _os_log_impl( (void *)&_mh_execute_header,  v2,  OS_LOG_TYPE_DEFAULT,  "Starting bluetooth core stack (BUILD %{public}s %{public}s)",  buf,  0x16u);
  }

  v152[0] = 0LL;
  v152[1] = 0LL;
  sub_100242F28((uint64_t)v152, a1 + 224);
  *(_WORD *)(a1 + 292) = 0;
  *(_DWORD *)(a1 + 28sub_100242E28(v1 + 8) = 0;
  if (*(char *)(a1 + 319) < 0)
  {
    **(_BYTE **)(a1 + 296) = 0;
    *(void *)(a1 + 304) = 0LL;
  }

  else
  {
    *(_BYTE *)(a1 + 296) = 0;
    *(_BYTE *)(a1 + 319) = 0;
  }

  *(_BYTE *)(a1 + 556) = 0;
  sub_100242F54((uint64_t)v152);
  __p[0] = 0LL;
  __p[1] = 0LL;
  uint64_t v151 = 0LL;
  uint64_t v3 = sub_1002E8D54();
  sub_10038BBBC(v3 + 208, a1 + 8);
  uint64_t v4 = sub_1002E8D54();
  if (!(*(unsigned int (**)(uint64_t, void **))(*(void *)v4 + 16LL))(v4, __p))
  {
    if (v151 >= 0) {
      uint64_t v5 = __p;
    }
    else {
      uint64_t v5 = (void **)__p[0];
    }
    strlcpy("iOS", (const char *)v5, 0x82uLL);
  }

  v149 = sub_10042DCE4;
  sub_1000FC384((void **)&v149, a1);
  char v148 = 0;
  uint64_t v6 = sub_1002E6E00();
  sub_10002418C(buf, "Stack");
  sub_10002418C(v158, "force1M");
  int v7 = (*(uint64_t (**)(uint64_t, _BYTE *, _BYTE *, char *))(*(void *)v6 + 72LL))(v6, buf, v158, &v148);
  if (v148) {
    int v8 = v7;
  }
  else {
    int v8 = 0;
  }
  int v134 = v8;
  if (v161 < 0) {
    operator delete(*(void **)v158);
  }
  if ((v154[9] & 0x80000000) != 0) {
    operator delete(*(void **)buf);
  }
  if (v134)
  {
    if (os_log_type_enabled((os_log_t)qword_1008F7578, OS_LOG_TYPE_ERROR)) {
      sub_10067E3CC();
    }
    sub_10011F158();
  }

  unsigned __int8 v147 = 0;
  uint64_t v9 = sub_1002E6E00();
  sub_10002418C(buf, "LE");
  sub_10002418C(v158, "enableLELRInSetDefaultPhy");
  int v10 = (*(uint64_t (**)(uint64_t, _BYTE *, _BYTE *, unsigned __int8 *))(*(void *)v9 + 72LL))( v9,  buf,  v158,  &v147);
  if (v161 < 0) {
    operator delete(*(void **)v158);
  }
  if ((v154[9] & 0x80000000) != 0)
  {
    operator delete(*(void **)buf);
    if (!v10) {
      goto LABEL_31;
    }
  }

  else if (!v10)
  {
    goto LABEL_31;
  }

  int v11 = (os_log_s *)qword_1008F7578;
  if (os_log_type_enabled((os_log_t)qword_1008F7578, OS_LOG_TYPE_DEFAULT))
  {
    *(_DWORD *)std::string buf = 67109120;
    *(_DWORD *)&uint8_t buf[4] = v147;
    _os_log_impl((void *)&_mh_execute_header, v11, OS_LOG_TYPE_DEFAULT, "LELR for testing enableLELR=%d", buf, 8u);
  }

  LOBYTE(v134) = 1;
LABEL_31:
  sub_10011F174(v147);
  char v146 = 0;
  uint64_t v12 = sub_1002E6E00();
  sub_10002418C(buf, "Stack");
  sub_10002418C(v158, "disableConnUpdateWAR");
  int v13 = (*(uint64_t (**)(uint64_t, _BYTE *, _BYTE *, char *))(*(void *)v12 + 72LL))(v12, buf, v158, &v146);
  if (v146) {
    int v14 = v13;
  }
  else {
    int v14 = 0;
  }
  if (v161 < 0) {
    operator delete(*(void **)v158);
  }
  if ((v154[9] & 0x80000000) != 0)
  {
    operator delete(*(void **)buf);
    if (!v14) {
      goto LABEL_43;
    }
  }

  else if (!v14)
  {
    goto LABEL_43;
  }

  if (os_log_type_enabled((os_log_t)qword_1008F7578, OS_LOG_TYPE_ERROR)) {
    sub_10067E3A0();
  }
  LOBYTE(v134) = 1;
LABEL_43:
  char v145 = 0;
  uint64_t v15 = sub_1002E6E00();
  sub_10002418C(buf, "Stack");
  sub_10002418C(v158, "disableWriteCODWAR");
  int v16 = (*(uint64_t (**)(uint64_t, _BYTE *, _BYTE *, char *))(*(void *)v15 + 72LL))(v15, buf, v158, &v145);
  if (v145) {
    int v17 = v16;
  }
  else {
    int v17 = 0;
  }
  if (v161 < 0) {
    operator delete(*(void **)v158);
  }
  if ((v154[9] & 0x80000000) != 0)
  {
    operator delete(*(void **)buf);
    if (!v17) {
      goto LABEL_55;
    }
  }

  else if (!v17)
  {
    goto LABEL_55;
  }

  if (os_log_type_enabled((os_log_t)qword_1008F7578, OS_LOG_TYPE_ERROR)) {
    sub_10067E374();
  }
  LOBYTE(v134) = 1;
LABEL_55:
  uint64_t v18 = sub_1002E6E00();
  char v19 = (*(uint64_t (**)(uint64_t))(*(void *)v18 + 656LL))(v18);
  *(_BYTE *)(a1 + 21sub_100242E28(v1 + 8) = v19;
  if ((v19 & 1) == 0 && os_log_type_enabled((os_log_t)qword_1008F7578, OS_LOG_TYPE_ERROR)) {
    sub_10067E348();
  }
  unsigned __int8 v144 = 0;
  uint64_t v20 = sub_1002E6E00();
  sub_10002418C(buf, "Stack");
  sub_10002418C(v158, "disableClassicSecureConnections");
  int v21 = (*(uint64_t (**)(uint64_t, _BYTE *, _BYTE *, unsigned __int8 *))(*(void *)v20 + 72LL))( v20,  buf,  v158,  &v144);
  if (v144) {
    int v22 = v21;
  }
  else {
    int v22 = 0;
  }
  if (v161 < 0) {
    operator delete(*(void **)v158);
  }
  if ((v154[9] & 0x80000000) != 0)
  {
    operator delete(*(void **)buf);
    if (!v22) {
      goto LABEL_70;
    }
  }

  else if (!v22)
  {
    goto LABEL_70;
  }

  if (os_log_type_enabled((os_log_t)qword_1008F7578, OS_LOG_TYPE_ERROR)) {
    sub_10067E31C();
  }
  LOBYTE(v134) = 1;
LABEL_70:
  sub_1001E6890(v144);
  sub_100132480(sub_10042DD74);
  uint64_t v23 = sub_1002E6BF0();
  unsigned int v131 = (*(uint64_t (**)(uint64_t))(*(void *)v23 + 560LL))(v23);
  uint64_t v24 = sub_1002E6BF0();
  unsigned int v132 = (*(uint64_t (**)(uint64_t))(*(void *)v24 + 480LL))(v24);
  uint64_t v25 = sub_1002E6BF0();
  int v26 = (*(uint64_t (**)(uint64_t))(*(void *)v25 + 568LL))(v25);
  uint64_t v27 = sub_1002E6BF0();
  uint64_t v28 = (*(uint64_t (**)(uint64_t))(*(void *)v27 + 576LL))(v27);
  uint64_t v29 = sub_1002E6BF0();
  unsigned int v130 = (*(uint64_t (**)(uint64_t))(*(void *)v29 + 584LL))(v29);
  uint64_t v30 = sub_1002E6BF0();
  unsigned int v129 = (*(uint64_t (**)(uint64_t))(*(void *)v30 + 592LL))(v30);
  uint64_t v31 = sub_1002E6BF0();
  uint64_t v32 = (*(uint64_t (**)(uint64_t))(*(void *)v31 + 608LL))(v31);
  uint64_t v33 = sub_1002E6BF0();
  uint64_t v34 = (*(uint64_t (**)(uint64_t))(*(void *)v33 + 616LL))(v33);
  uint64_t v35 = sub_1002E6BF0();
  unsigned int v36 = (*(uint64_t (**)(uint64_t))(*(void *)v35 + 640LL))(v35);
  uint64_t v37 = sub_1002E6BF0();
  unsigned int v133 = (*(uint64_t (**)(uint64_t))(*(void *)v37 + 680LL))(v37);
  uint64_t v38 = sub_1002E6BF0();
  unsigned int v127 = (*(uint64_t (**)(uint64_t))(*(void *)v38 + 648LL))(v38);
  uint64_t v39 = sub_1002E6BF0();
  unsigned int v40 = (*(uint64_t (**)(uint64_t))(*(void *)v39 + 488LL))(v39);
  int v41 = (os_log_s *)qword_1008F7578;
  if (os_log_type_enabled((os_log_t)qword_1008F7578, OS_LOG_TYPE_DEFAULT))
  {
    *(_DWORD *)std::string buf = 67109120;
    *(_DWORD *)&uint8_t buf[4] = v40;
    _os_log_impl( (void *)&_mh_execute_header,  v41,  OS_LOG_TYPE_DEFAULT,  "initCoreStack enablePeriodicAdvertisingAdv=%d",  buf,  8u);
  }

  uint64_t v42 = sub_1002E6BF0();
  unsigned int v128 = (*(uint64_t (**)(uint64_t))(*(void *)v42 + 496LL))(v42);
  unsigned int v126 = v36;
  int v43 = (os_log_s *)qword_1008F7578;
  if (os_log_type_enabled((os_log_t)qword_1008F7578, OS_LOG_TYPE_DEFAULT))
  {
    *(_DWORD *)std::string buf = 67109120;
    *(_DWORD *)&uint8_t buf[4] = v128;
    _os_log_impl( (void *)&_mh_execute_header,  v43,  OS_LOG_TYPE_DEFAULT,  "initCoreStack enablePeriodicAdvertisingSync=%d",  buf,  8u);
  }

  uint64_t v44 = sub_1002E6BF0();
  int v45 = (*(uint64_t (**)(uint64_t))(*(void *)v44 + 504LL))(v44);
  uint64_t v46 = (os_log_s *)qword_1008F7578;
  if (os_log_type_enabled((os_log_t)qword_1008F7578, OS_LOG_TYPE_DEFAULT))
  {
    *(_DWORD *)std::string buf = 67109120;
    *(_DWORD *)&uint8_t buf[4] = v45;
    _os_log_impl( (void *)&_mh_execute_header,  v46,  OS_LOG_TYPE_DEFAULT,  "initCoreStack enablePeriodidAdvSyncTranSender=%d",  buf,  8u);
  }

  uint64_t v47 = sub_1002E6BF0();
  int v48 = (*(uint64_t (**)(uint64_t))(*(void *)v47 + 512LL))(v47);
  int v49 = (os_log_s *)qword_1008F7578;
  if (os_log_type_enabled((os_log_t)qword_1008F7578, OS_LOG_TYPE_DEFAULT))
  {
    *(_DWORD *)std::string buf = 67109120;
    *(_DWORD *)&uint8_t buf[4] = v48;
    _os_log_impl( (void *)&_mh_execute_header,  v49,  OS_LOG_TYPE_DEFAULT,  "initCoreStack enablePeriodidAdvSyncTranRecipient=%d",  buf,  8u);
  }

  uint64_t v50 = sub_1002E6BF0();
  int v51 = (*(uint64_t (**)(uint64_t))(*(void *)v50 + 744LL))(v50);
  uint64_t v52 = sub_1002E6BF0();
  int v53 = (*(uint64_t (**)(uint64_t))(*(void *)v52 + 752LL))(v52);
  unint64_t v54 = (os_log_s *)qword_1008F7578;
  if (os_log_type_enabled((os_log_t)qword_1008F7578, OS_LOG_TYPE_DEFAULT))
  {
    *(_DWORD *)std::string buf = 67109120;
    *(_DWORD *)&uint8_t buf[4] = v53;
    _os_log_impl((void *)&_mh_execute_header, v54, OS_LOG_TYPE_DEFAULT, "enable ABC logs for Magnet Timer: %d", buf, 8u);
  }

  if (qword_1008D6788 != -1) {
    dispatch_once(&qword_1008D6788, &stru_100898400);
  }
  sub_100206814((uint64_t)off_1008D6780, v53);
  if (v132)
  {
    if (os_log_type_enabled((os_log_t)qword_1008F7578, OS_LOG_TYPE_ERROR)) {
      sub_10067E2F0();
    }
    unsigned int v131 = 1;
  }

  uint64_t v55 = sub_1002E6E9C();
  uint64_t v56 = (*(uint64_t (**)(uint64_t))(*(void *)v55 + 2680LL))(v55);
  unint64_t v57 = (os_log_s *)qword_1008F7578;
  if (os_log_type_enabled((os_log_t)qword_1008F7578, OS_LOG_TYPE_DEFAULT))
  {
    if ((_DWORD)v56) {
      unsigned int v58 = "supports";
    }
    else {
      unsigned int v58 = "does not support";
    }
    *(_DWORD *)std::string buf = 136315138;
    *(void *)&uint8_t buf[4] = v58;
    _os_log_impl( (void *)&_mh_execute_header,  v57,  OS_LOG_TYPE_DEFAULT,  "This platform %s address rotation while scanning or connecting",  buf,  0xCu);
    unint64_t v57 = (os_log_s *)qword_1008F7578;
  }

  if (os_log_type_enabled(v57, OS_LOG_TYPE_DEFAULT))
  {
    if (v51) {
      uint64_t v59 = "supports";
    }
    else {
      uint64_t v59 = "does not support";
    }
    *(_DWORD *)std::string buf = 136315138;
    *(void *)&uint8_t buf[4] = v59;
    _os_log_impl( (void *)&_mh_execute_header,  v57,  OS_LOG_TYPE_DEFAULT,  "This platform %s rssi connection statistics and detection",  buf,  0xCu);
  }

  uint64_t v60 = sub_1002E6BF0();
  uint64_t v61 = (*(uint64_t (**)(uint64_t))(*(void *)v60 + 824LL))(v60);
  sub_10019E534(v132);
  sub_10019E528(v131);
  sub_1001AFB9C(v28);
  sub_1001AFBA8(v130);
  sub_1001C690C(v34 | v26);
  sub_1001C6960(v129);
  sub_1001C696C(v32);
  sub_1001C6978(v34);
  sub_1001C698C(v126);
  sub_1001C6998(v127);
  uint64_t v62 = sub_1002E6E9C();
  uint64_t v63 = (*(uint64_t (**)(uint64_t))(*(void *)v62 + 3328LL))(v62);
  int v64 = v63;
  sub_10019E550(v63);
  nullsub_63(v133, v65);
  sub_1001C6A44(v133);
  nullsub_63(v133, v66);
  sub_1001BE598(v56);
  sub_10019FB0C(v40);
  sub_1000AE764(v128);
  uint64_t v67 = sub_1002E6E9C();
  int v68 = (*(uint64_t (**)(uint64_t))(*(void *)v67 + 3480LL))(v67);
  uint64_t v69 = sub_1002E6E9C();
  int v70 = (*(uint64_t (**)(uint64_t))(*(void *)v69 + 3472LL))(v69);
  sub_1001AFE5C(v70, v68);
  sub_1001C69A4(v61);
  uint64_t v71 = (os_log_s *)qword_1008F7578;
  if (os_log_type_enabled((os_log_t)qword_1008F7578, OS_LOG_TYPE_DEFAULT))
  {
    *(_DWORD *)std::string buf = 67110400;
    *(_DWORD *)&uint8_t buf[4] = v131;
    *(_WORD *)&uint8_t buf[8] = 1024;
    *(_DWORD *)&buf[10] = v132;
    *(_WORD *)v154 = 1024;
    *(_DWORD *)&v154[2] = v34 | v26;
    *(_WORD *)&v154[6] = 1024;
    *(_DWORD *)&v154[8] = v129;
    *(_WORD *)&v154[12] = 1024;
    int v155 = v64;
    __int16 v156 = 1024;
    unsigned int v157 = v130;
    _os_log_impl( (void *)&_mh_execute_header,  v71,  OS_LOG_TYPE_DEFAULT,  "enableBTSpecAdvertisingSets=%d enableExtendedAdvertising=%d enableExtendedScanning=%d enableExtendedScanHCI=%d max AdvHandles=%d enableEnhancedConnectionsV2=%d",  buf,  0x26u);
  }

  uint64_t v72 = sub_1002E6E9C();
  else {
    uint64_t v73 = 8LL;
  }
  sub_1001BF0C0(v73);
  if (*(_DWORD *)(sub_1002E6E9C() + 708))
  {
    char v74 = (int *)sub_1002E6E9C();
  }

  if (*(_DWORD *)(sub_1002E6E9C() + 708) == 6000)
  {
    int v75 = (os_log_s *)qword_1008F7578;
    if (os_log_type_enabled((os_log_t)qword_1008F7578, OS_LOG_TYPE_DEFAULT))
    {
      *(_DWORD *)std::string buf = 136315138;
      *(void *)&uint8_t buf[4] = "initCoreStack";
      _os_log_impl( (void *)&_mh_execute_header,  v75,  OS_LOG_TYPE_DEFAULT,  "%s: register BTVirtualController callbacks",  buf,  0xCu);
    }

    if (qword_1008D9988 != -1) {
      dispatch_once(&qword_1008D9988, &stru_100898480);
    }
    sub_10064E048();
  }

  if (sub_1000A8704(1, sub_10042DDF4, 0LL))
  {
    if (os_log_type_enabled((os_log_t)qword_1008F7578, OS_LOG_TYPE_ERROR)) {
      sub_10067E290();
    }
LABEL_112:
    uint64_t v76 = 110LL;
    goto LABEL_205;
  }

  int v143 = 0;
  uint64_t v77 = sub_1002E6E00();
  sub_10002418C(buf, "LE");
  sub_10002418C(v158, "overridePrivateAddressRotationInterval");
  int v78 = (*(uint64_t (**)(uint64_t, _BYTE *, _BYTE *, int *))(*(void *)v77 + 88LL))(v77, buf, v158, &v143);
  if (v161 < 0) {
    operator delete(*(void **)v158);
  }
  if ((v154[9] & 0x80000000) != 0)
  {
    operator delete(*(void **)buf);
    if (!v78) {
      goto LABEL_122;
    }
  }

  else if (!v78)
  {
    goto LABEL_122;
  }

  int v79 = (os_log_s *)qword_1008F7578;
  if (os_log_type_enabled((os_log_t)qword_1008F7578, OS_LOG_TYPE_ERROR)) {
    sub_10067E228((uint64_t)&v143, v79, v80, v81, v82, v83, v84, v85);
  }
  sub_1001BE584((unsigned __int16)v143);
LABEL_122:
  uint64_t v86 = sub_1002E6E00();
  int v139 = 0;
  uint64_t v87 = sub_1002E6E00();
  sub_10002418C(buf, "FastR1ScanInterval");
  sub_10002418C(v158, "interval");
  int v88 = (*(uint64_t (**)(uint64_t, _BYTE *, _BYTE *, int *))(*(void *)v87 + 88LL))(v87, buf, v158, &v139);
  if (v161 < 0) {
    operator delete(*(void **)v158);
  }
  if ((v154[9] & 0x80000000) != 0)
  {
    operator delete(*(void **)buf);
    if (!v88) {
      goto LABEL_130;
    }
    goto LABEL_129;
  }

  if (v88)
  {
LABEL_129:
    buf[0] = 0;
    sub_100242CA4(buf);
    sub_1001141A4((unsigned __int16)v139);
    sub_100242CD8(buf);
  }

LABEL_130:
  int v142 = 0;
  uint64_t v89 = sub_1002E6E00();
  sub_10002418C(buf, "FastR1ScanType");
  sub_10002418C(v158, "scanType");
  int v90 = (*(uint64_t (**)(uint64_t, _BYTE *, _BYTE *, int *))(*(void *)v89 + 88LL))(v89, buf, v158, &v142);
  if (v161 < 0) {
    operator delete(*(void **)v158);
  }
  if ((v154[9] & 0x80000000) != 0)
  {
    operator delete(*(void **)buf);
    if (!v90) {
      goto LABEL_137;
    }
    goto LABEL_136;
  }

  if (v90)
  {
LABEL_136:
    buf[0] = 0;
    sub_100242CA4(buf);
    sub_1001141B0(v142);
    sub_100242CD8(buf);
  }

void sub_10042DAF4( _Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, char a19, uint64_t a20, uint64_t a21, void *a22, uint64_t a23, int a24, __int16 a25, char a26, char a27, char a28, uint64_t a29, void *__p, uint64_t a31, int a32, __int16 a33, char a34, char a35)
{
  if (a35 < 0) {
    operator delete(__p);
  }
  sub_100242CD8(&a19);
  if (a27 < 0) {
    operator delete(a22);
  }
  sub_100242FAC((uint64_t)&a28);
  _Unwind_Resume(a1);
}

uint64_t sub_10042DCE4(void *a1)
{
  off_1008F1018 = a1;
  xmmword_1008F1020 = xmmword_1006C3004;
  *(void *)((char *)&xmmword_1008F1020 + 14) = 0x101020100000000LL;
  uint64_t v1 = sub_100114368((void (*)(int))sub_1004389F4, (uint64_t)&xmmword_1008F1020);
  if ((_DWORD)v1)
  {
    if (os_log_type_enabled((os_log_t)qword_1008F7578, OS_LOG_TYPE_ERROR)) {
      sub_10067E3F8();
    }
    off_1008F1018 = 0LL;
  }

  return v1;
}

void sub_10042DD74(int a1, __int16 a2, char a3)
{
  dispatch_queue_global_t global_queue = dispatch_get_global_queue(0LL, 0LL);
  block[0] = _NSConcreteStackBlock;
  block[1] = 3221225472LL;
  block[2] = sub_100433D5C;
  block[3] = &unk_1008981A0;
  int v8 = a1;
  __int16 v9 = a2;
  char v10 = a3;
  dispatch_async(global_queue, block);
}

void sub_10042DDF4()
{
  if (qword_1008D60B0 != -1) {
    dispatch_once(&qword_1008D60B0, &stru_1008983A0);
  }
}

uint64_t sub_10042DE1C(uint64_t a1)
{
  uint64_t v2 = (os_log_s *)qword_1008F7578;
  if (os_log_type_enabled((os_log_t)qword_1008F7578, OS_LOG_TYPE_DEFAULT))
  {
    *(_WORD *)std::string buf = 0;
    _os_log_impl((void *)&_mh_execute_header, v2, OS_LOG_TYPE_DEFAULT, "Terminating core stack", buf, 2u);
  }

  *(void *)std::string buf = 0LL;
  uint64_t v7 = 0LL;
  sub_100242F28((uint64_t)buf, a1 + 224);
  *(_WORD *)(a1 + 292) = 0;
  *(_DWORD *)(a1 + 28sub_100242E28(v1 + 8) = 0;
  if (*(char *)(a1 + 319) < 0)
  {
    **(_BYTE **)(a1 + 296) = 0;
    *(void *)(a1 + 304) = 0LL;
  }

  else
  {
    *(_BYTE *)(a1 + 296) = 0;
    *(_BYTE *)(a1 + 319) = 0;
  }

  sub_100242F54((uint64_t)buf);
  char v5 = 0;
  sub_100242CA4(&v5);
  sub_100242CD0(&v5);
  sub_1000A8CA0();
  dword_1008F7478 = 103;
  byte_1008F747D = 0;
  sub_1002431FC(&stru_1008F7418);
  sub_1002431FC(&stru_1008F7448);
  uint64_t v3 = sub_1002E8D54();
  sub_10024E060(v3 + 208, a1 + 8);
  sub_100242CD8(&v5);
  sub_100242FAC((uint64_t)buf);
  return 0LL;
}

void sub_10042DF6C(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, ...)
{
}

void sub_10042DF94(char a1)
{
  dispatch_queue_global_t global_queue = dispatch_get_global_queue(2LL, 0LL);
  block[0] = _NSConcreteStackBlock;
  block[1] = 3221225472LL;
  block[2] = sub_1004361B0;
  block[3] = &unk_100898180;
  char v4 = a1;
  dispatch_async(global_queue, block);
}

uint64_t sub_10042E000()
{
  unsigned __int8 v8 = 0;
  uint64_t v0 = sub_1002E6E00();
  sub_10002418C(buf, "LE");
  sub_10002418C(__p, "enableLEPowerControl");
  int v1 = (*(uint64_t (**)(uint64_t, uint8_t *, void **, unsigned __int8 *))(*(void *)v0 + 72LL))( v0,  buf,  __p,  &v8);
  if (v7 < 0) {
    operator delete(__p[0]);
  }
  if (v11 < 0)
  {
    operator delete(*(void **)buf);
    if (!v1) {
      goto LABEL_9;
    }
  }

  else if (!v1)
  {
    goto LABEL_9;
  }

  uint64_t v2 = (os_log_s *)qword_1008F7578;
  if (os_log_type_enabled((os_log_t)qword_1008F7578, OS_LOG_TYPE_DEFAULT))
  {
    *(_DWORD *)std::string buf = 67109120;
    *(_DWORD *)&uint8_t buf[4] = v8;
    _os_log_impl( (void *)&_mh_execute_header,  v2,  OS_LOG_TYPE_DEFAULT,  "LE Power Control enableLEPowerControl=%d",  buf,  8u);
  }

void sub_10042E208( _Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, void *__p, uint64_t a10, int a11, __int16 a12, char a13, char a14, uint64_t a15, void *a16, uint64_t a17, int a18, __int16 a19, char a20, char a21)
{
}

uint64_t sub_10042E258(uint64_t a1)
{
  int v129 = 0;
  uint64_t v2 = (os_log_s *)qword_1008F7578;
  if (os_log_type_enabled((os_log_t)qword_1008F7578, OS_LOG_TYPE_DEFAULT))
  {
    LOWORD(buf) = 0;
    _os_log_impl((void *)&_mh_execute_header, v2, OS_LOG_TYPE_DEFAULT, "Starting up StackManager", (uint8_t *)&buf, 2u);
  }

  v128[0] = 0LL;
  v128[1] = 0LL;
  sub_100242F28((uint64_t)v128, a1 + 144);
  int v3 = *(_DWORD *)(a1 + 72);
  if (v3)
  {
    if (v3 == 2)
    {
      if (os_log_type_enabled((os_log_t)qword_1008F7578, OS_LOG_TYPE_ERROR)) {
        sub_10067E4B8();
      }
      uint64_t v4 = 111LL;
    }

    else
    {
      char v5 = (os_log_s *)qword_1008F7578;
      if (os_log_type_enabled((os_log_t)qword_1008F7578, OS_LOG_TYPE_DEFAULT))
      {
        LOWORD(buf) = 0;
        _os_log_impl( (void *)&_mh_execute_header,  v5,  OS_LOG_TYPE_DEFAULT,  "StackManager is already running",  (uint8_t *)&buf,  2u);
      }

      uint64_t v4 = 110LL;
    }

    goto LABEL_231;
  }

  sub_10042C278(a1, 2u, 0);
  *(_BYTE *)(a1 + 209) = 0;
  sub_100242F54((uint64_t)v128);
  uint64_t v4 = sub_10042C4D4(a1);
  if ((_DWORD)v4)
  {
    if (os_log_type_enabled((os_log_t)qword_1008F7578, OS_LOG_TYPE_ERROR)) {
      sub_10067E510();
    }
    sub_100242ECC((uint64_t)v128);
    sub_10042C278(a1, 0, 0);
    sub_100242F54((uint64_t)v128);
    goto LABEL_231;
  }

  uint64_t v6 = sub_1002E6E9C();
  sub_1002CF408(v6);
  sub_10042FA60((os_unfair_lock_s *)a1);
  sub_100242ECC((uint64_t)v128);
  sub_10042C278(a1, 1u, 0);
  *(_BYTE *)(a1 + 20sub_100242E28(v1 + 8) = 0;
  *(_WORD *)(a1 + 21sub_100414D2C(qword_1008F72C0, 0) = 0;
  *(_BYTE *)(a1 + 212) = 0;
  *(_BYTE *)(a1 + 215) = 0;
  sub_100242F54((uint64_t)v128);
  if (*(_BYTE *)(a1 + 209))
  {
    v121[0] = 0;
    LOBYTE(v123) = 0;
    LOBYTE(v119) = 0;
    uint64_t v7 = sub_1002E8D54();
    if (!(*(unsigned int (**)(uint64_t, uint8_t *, unsigned int *, int *))(*(void *)v7 + 24LL))( v7,  v121,  &v123,  &v119)) {
      (*(void (**)(uint64_t, void, void, void))(*(void *)a1 + 72LL))( a1,  v121[0],  v123,  v119);
    }
    __int128 buf = 0uLL;
    *(void *)&__int128 v131 = 0LL;
    uint64_t v8 = sub_1002E8D54();
    if (!(*(unsigned int (**)(uint64_t, __int128 *))(*(void *)v8 + 16LL))(v8, &buf))
    {
      if (SBYTE7(v131) < 0)
      {
        sub_100024238(__p, (void *)buf, *((unint64_t *)&buf + 1));
      }

      else
      {
        *(_OWORD *)std::stringbuf::string_type __p = buf;
        uint64_t v127 = v131;
      }

      (*(void (**)(uint64_t, void **))(*(void *)a1 + 40LL))(a1, __p);
      if (SHIBYTE(v127) < 0) {
        operator delete(__p[0]);
      }
    }

    if (SBYTE7(v131) < 0) {
      operator delete((void *)buf);
    }
  }

  __int16 v9 = (os_log_s *)qword_1008F7578;
  if (os_log_type_enabled((os_log_t)qword_1008F7578, OS_LOG_TYPE_DEFAULT))
  {
    LOWORD(buf) = 0;
    _os_log_impl((void *)&_mh_execute_header, v9, OS_LOG_TYPE_DEFAULT, "Done starting up stack", (uint8_t *)&buf, 2u);
  }

  uint64_t v10 = sub_1002E6BF0();
  if ((*(unsigned int (**)(uint64_t))(*(void *)v10 + 408LL))(v10))
  {
    LOBYTE(buf) = 0;
    sub_100242CA4(&buf);
    sub_100118D44(1LL);
    sub_100242CD8(&buf);
  }

  uint64_t v11 = sub_1002E8D54();
  sub_1001FC8A8(v11 + 368, a1 + 16);
  uint64_t v12 = sub_1002E6BF0();
  if ((*(unsigned int (**)(uint64_t))(*(void *)v12 + 104LL))(v12))
  {
    uint64_t v13 = sub_1002E8D54();
    sub_1004385E0(v13 + 568, a1 + 32);
    LOBYTE(buf) = 0;
    uint64_t v14 = sub_1002E8D54();
  }

  uint64_t v15 = sub_1002E6BF0();
  if ((*(unsigned int (**)(uint64_t))(*(void *)v15 + 112LL))(v15))
  {
    uint64_t v16 = sub_100405058();
    v125[0] = _NSConcreteStackBlock;
    v125[1] = 3221225472LL;
    v125[2] = sub_10042FAD8;
    v125[3] = &unk_10087EB20;
    v125[4] = a1;
    sub_1004054B4(v16, v125);
  }

  if (*(_BYTE *)(a1 + 219))
  {
    if (qword_1008D6198 != -1) {
      dispatch_once(&qword_1008D6198, &stru_100898420);
    }
    double v17 = sub_10044916C();
    double v18 = sub_10042FB88(v17);
    if (v17 == 0.0
      || (double v19 = v18,
          +[NSDate timeIntervalSinceReferenceDate](&OBJC_CLASS___NSDate, "timeIntervalSinceReferenceDate"),
          v20 >= v19))
    {
      int v22 = (os_log_s *)qword_1008F7578;
      if (os_log_type_enabled((os_log_t)qword_1008F7578, OS_LOG_TYPE_DEFAULT))
      {
        LOWORD(buf) = 0;
        _os_log_impl( (void *)&_mh_execute_header,  v22,  OS_LOG_TYPE_DEFAULT,  "Disabling denylist on expiration",  (uint8_t *)&buf,  2u);
      }

      sub_10042FC90(a1, 0);
    }

    else
    {
      v121[0] = 0;
      sub_100242CA4(v121);
      int v21 = (os_log_s *)qword_1008F7578;
      if (os_log_type_enabled((os_log_t)qword_1008F7578, OS_LOG_TYPE_DEFAULT))
      {
        LOWORD(buf) = 0;
        _os_log_impl( (void *)&_mh_execute_header,  v21,  OS_LOG_TYPE_DEFAULT,  "Re-enabling the denylist mode",  (uint8_t *)&buf,  2u);
      }

      *(_BYTE *)(a1 + 219) = 1;
      sub_1004300BC(1, v19);
      if (qword_1008D67C8 != -1) {
        dispatch_once(&qword_1008D67C8, &stru_1008984C0);
      }
      sub_100283A5C((uint64_t)off_1008D67C0, *(_BYTE *)(a1 + 219));
      sub_100242CD8(v121);
    }
  }

  if (qword_1008F0B10 != -1) {
    dispatch_once(&qword_1008F0B10, &stru_100898160);
  }
  char v124 = 0;
  unsigned int v123 = 0;
  uint64_t v23 = sub_1002E6E00();
  sub_10002418C(&buf, "Device");
  sub_10002418C(v121, "HDRForcePkt");
  int v24 = (*(uint64_t (**)(uint64_t, __int128 *, uint8_t *, char *))(*(void *)v23 + 72LL))( v23,  &buf,  v121,  &v124);
  if (v122 < 0) {
    operator delete(*(void **)v121);
  }
  if (SBYTE7(v131) < 0)
  {
    operator delete((void *)buf);
    if (!v24) {
      goto LABEL_59;
    }
  }

  else if (!v24)
  {
    goto LABEL_59;
  }

  if (qword_1008D60B0 != -1) {
    dispatch_once(&qword_1008D60B0, &stru_1008983A0);
  }
  uint64_t v25 = off_1008D60A8;
  __int128 buf = 0uLL;
  uint64_t v26 = sub_100242F28((uint64_t)&buf, (uint64_t)off_1008D60A8 + 224);
  v25[556] = 1;
  sub_100242FAC(v26);
LABEL_59:
  uint64_t v27 = sub_1002E6E00();
  sub_10002418C(&buf, "Device");
  sub_10002418C(v121, "HDRPktTypeMask");
  int v28 = (*(uint64_t (**)(uint64_t, __int128 *, uint8_t *, unsigned int *))(*(void *)v27 + 128LL))( v27,  &buf,  v121,  &v123);
  if (v122 < 0) {
    operator delete(*(void **)v121);
  }
  if (SBYTE7(v131) < 0)
  {
    operator delete((void *)buf);
    if (!v28) {
      goto LABEL_68;
    }
  }

  else if (!v28)
  {
    goto LABEL_68;
  }

  if (qword_1008D60B0 != -1) {
    dispatch_once(&qword_1008D60B0, &stru_1008983A0);
  }
  uint64_t v29 = off_1008D60A8;
  __int128 buf = 0uLL;
  uint64_t v30 = sub_100242F28((uint64_t)&buf, (uint64_t)off_1008D60A8 + 224);
  v29[556] = 1;
  sub_100242FAC(v30);
LABEL_68:
  unsigned __int8 v120 = 1;
  uint64_t v31 = sub_1002E6E00();
  sub_10002418C(&buf, "Device");
  sub_10002418C(v121, "EnableHDR");
  int v32 = (*(uint64_t (**)(uint64_t, __int128 *, uint8_t *, unsigned __int8 *))(*(void *)v31 + 72LL))( v31,  &buf,  v121,  &v120);
  if (v122 < 0) {
    operator delete(*(void **)v121);
  }
  if (SBYTE7(v131) < 0)
  {
    operator delete((void *)buf);
    if (!v32) {
      goto LABEL_77;
    }
  }

  else if (!v32)
  {
    goto LABEL_77;
  }

  if (qword_1008D60B0 != -1) {
    dispatch_once(&qword_1008D60B0, &stru_1008983A0);
  }
  uint64_t v33 = off_1008D60A8;
  __int128 buf = 0uLL;
  uint64_t v34 = sub_100242F28((uint64_t)&buf, (uint64_t)off_1008D60A8 + 224);
  v33[556] = 1;
  sub_100242FAC(v34);
LABEL_77:
  uint64_t v35 = sub_1002E6E9C();
  (*(void (**)(uint64_t, void, uint64_t))(*(void *)v35 + 1288LL))(v35, v120, 1LL);
  uint64_t v36 = sub_1002E6E9C();
  int v37 = (*(uint64_t (**)(uint64_t))(*(void *)v36 + 2536LL))(v36);
  if (v120) {
    int v38 = v37;
  }
  else {
    int v38 = 0;
  }
  if (v38 == 1)
  {
    uint64_t v39 = (os_log_s *)qword_1008F7578;
    if (os_log_type_enabled((os_log_t)qword_1008F7578, OS_LOG_TYPE_DEFAULT))
    {
      *(void *)&__int128 buf = 0x16804000200LL;
      WORD4(buf) = 1024;
      *(_DWORD *)((char *)&buf + 1sub_100414D2C(qword_1008F72C0, 0) = 1;
      _os_log_impl( (void *)&_mh_execute_header,  v39,  OS_LOG_TYPE_DEFAULT,  "Adjust sco hci buffer length bufferSize %d numBuffer %d",  (uint8_t *)&buf,  0xEu);
    }

    uint64_t v40 = sub_1002E6E9C();
    (*(void (**)(uint64_t, uint64_t, uint64_t, uint64_t, uint64_t))(*(void *)v40 + 1336LL))( v40,  1LL,  360LL,  1LL,  1LL);
  }

  uint64_t v41 = sub_1002E6E9C();
  (*(void (**)(uint64_t, uint64_t, uint64_t, uint64_t))(*(void *)v41 + 2896LL))(v41, 20LL, 1LL, 1LL);
  uint64_t v42 = sub_1002E6E9C();
  (*(void (**)(uint64_t, uint64_t))(*(void *)v42 + 1296LL))(v42, 1LL);
  if (v124)
  {
    int v43 = (os_log_s *)qword_1008F7578;
    if (os_log_type_enabled((os_log_t)qword_1008F7578, OS_LOG_TYPE_DEFAULT))
    {
      LOWORD(buf) = 0;
      _os_log_impl( (void *)&_mh_execute_header,  v43,  OS_LOG_TYPE_DEFAULT,  "Forcing HDR packet type",  (uint8_t *)&buf,  2u);
    }

    sub_10010F954(1LL);
    sub_10010F960(v123);
  }

  uint64_t v44 = sub_1002E6E9C();
  (*(void (**)(uint64_t, uint64_t))(*(void *)v44 + 352LL))(v44, 1LL);
  if (*(_BYTE *)(a1 + 218))
  {
    if (*(_DWORD *)(sub_1002E6E9C() + 708) >= 0x7D0u && *(_DWORD *)(sub_1002E6E9C() + 708) <= 0xF9Fu)
    {
      uint64_t v45 = sub_1002E6E9C();
      (*(void (**)(uint64_t, uint64_t))(*(void *)v45 + 1256LL))(v45, 1LL);
    }

    if (*(_DWORD *)(sub_1002E6E9C() + 708) && *(_DWORD *)(sub_1002E6E9C() + 708) <= 0x7CFu)
    {
      if (*(_DWORD *)(sub_1002E6E9C() + 708) < 0x13u)
      {
        uint64_t v48 = sub_1002E6E9C();
        if ((*(unsigned int (**)(uint64_t, uint64_t))(*(void *)v48 + 1256LL))(v48, 1LL))
        {
          LOBYTE(buf) = 0;
          sub_100242CA4(&buf);
          sub_10011EF18();
          sub_100242CD0(&buf);
          sub_100242CD8(&buf);
        }
      }

      else
      {
        uint64_t v46 = sub_1002E6E9C();
        (*(void (**)(uint64_t, uint64_t))(*(void *)v46 + 1272LL))(v46, 1LL);
        uint64_t v47 = sub_1002E6E9C();
        (*(void (**)(uint64_t, uint64_t))(*(void *)v47 + 1744LL))(v47, 1LL);
      }
    }
  }

  if (*(_DWORD *)(sub_1002E6E9C() + 708) && *(_DWORD *)(sub_1002E6E9C() + 708) <= 0x7CFu)
  {
    if (*(_DWORD *)(sub_1002E6E9C() + 708) >= 0x13u)
    {
      uint64_t v49 = sub_1002E6E9C();
      (*(void (**)(uint64_t, uint64_t))(*(void *)v49 + 1688LL))(v49, 1LL);
    }

    uint64_t v50 = sub_1002E6E00();
    uint64_t v51 = (*(uint64_t (**)(uint64_t))(*(void *)v50 + 8LL))(v50);
    uint64_t v52 = sub_1002E6E9C();
    (*(void (**)(uint64_t, uint64_t))(*(void *)v52 + 1040LL))(v52, v51);
  }

  uint64_t v53 = sub_1002E6E9C();
  if ((*(unsigned int (**)(uint64_t))(*(void *)v53 + 2072LL))(v53))
  {
    LOBYTE(v116) = 0;
    unsigned int v118 = 1;
    int v119 = 0;
    uint64_t v54 = sub_1002E6BF0();
    else {
      uint64_t v55 = 1LL;
    }
    uint64_t v56 = sub_1002E6E00();
    sub_10002418C(&buf, "LE");
    sub_10002418C(v121, "PowerTagV2ForceHandleEnable");
    (*(void (**)(uint64_t, __int128 *, uint8_t *, int *))(*(void *)v56 + 72LL))(v56, &buf, v121, &v116);
    if (v122 < 0) {
      operator delete(*(void **)v121);
    }
    if (SBYTE7(v131) < 0) {
      operator delete((void *)buf);
    }
    uint64_t v57 = sub_1002E6E00();
    sub_10002418C(&buf, "LE");
    sub_10002418C(v121, "PowerTagV2ForceHandleValue");
    (*(void (**)(uint64_t, __int128 *, uint8_t *, int *))(*(void *)v57 + 128LL))(v57, &buf, v121, &v119);
    if (v122 < 0) {
      operator delete(*(void **)v121);
    }
    if (SBYTE7(v131) < 0) {
      operator delete((void *)buf);
    }
    uint64_t v58 = sub_1002E6E00();
    sub_10002418C(&buf, "LE");
    sub_10002418C(v121, "PowerTagV2ForceEnableFeatureSet");
    (*(void (**)(uint64_t, __int128 *, uint8_t *, unsigned int *))(*(void *)v58 + 128LL))( v58,  &buf,  v121,  &v118);
    if (v122 < 0) {
      operator delete(*(void **)v121);
    }
    if (SBYTE7(v131) < 0) {
      operator delete((void *)buf);
    }
    if ((_BYTE)v116)
    {
      uint64_t v59 = (os_log_s *)qword_1008F7578;
      if (os_log_type_enabled((os_log_t)qword_1008F7578, OS_LOG_TYPE_DEFAULT))
      {
        LODWORD(buf) = 67109632;
        DWORD1(buf) = v118;
        WORD4(buf) = 1024;
        *(_DWORD *)((char *)&buf + 1sub_100414D2C(qword_1008F72C0, 0) = v119;
        HIWORD(buf) = 1024;
        LODWORD(v131) = v119;
        _os_log_impl( (void *)&_mh_execute_header,  v59,  OS_LOG_TYPE_DEFAULT,  "Force PowerTagV2 %d:  %d (0x%04x)",  (uint8_t *)&buf,  0x14u);
      }

      uint64_t v55 = v118;
      unsigned __int16 v60 = v119;
      if ((v118 & 4) == 0) {
        goto LABEL_130;
      }
    }

    else
    {
      unsigned __int16 v60 = 0;
      if ((v55 & 4) == 0)
      {
LABEL_130:
        uint64_t v65 = sub_1002E6E9C();
        int v66 = (*(uint64_t (**)(uint64_t, uint64_t, uint64_t, void))(*(void *)v65 + 1720LL))( v65,  v55,  1LL,  v60);
        if (v66)
        {
          uint64_t v67 = (os_log_s *)qword_1008F7578;
          if (os_log_type_enabled((os_log_t)qword_1008F7578, OS_LOG_TYPE_DEFAULT))
          {
            LODWORD(buf) = 67109120;
            DWORD1(buf) = v66;
            _os_log_impl( (void *)&_mh_execute_header,  v67,  OS_LOG_TYPE_DEFAULT,  "PowerTag BTCLK V2 error configuring %d ",  (uint8_t *)&buf,  8u);
          }
        }

        goto LABEL_133;
      }
    }

    uint64_t v63 = (os_log_s *)qword_1008F7578;
    if (os_log_type_enabled((os_log_t)qword_1008F7578, OS_LOG_TYPE_DEFAULT))
    {
      LOWORD(buf) = 0;
      _os_log_impl( (void *)&_mh_execute_header,  v63,  OS_LOG_TYPE_DEFAULT,  "PowerTag V2 BTCLK is enable ",  (uint8_t *)&buf,  2u);
    }

    uint64_t v64 = sub_1002E6BF0();
    (*(void (**)(uint64_t, uint64_t))(*(void *)v64 + 872LL))(v64, 1LL);
    goto LABEL_130;
  }

  uint64_t v61 = sub_1002E6E9C();
  if ((*(unsigned int (**)(uint64_t))(*(void *)v61 + 2064LL))(v61))
  {
    uint64_t v62 = sub_1002E6E9C();
    (*(void (**)(uint64_t, uint64_t))(*(void *)v62 + 1696LL))(v62, 1LL);
  }

LABEL_133:
  if (*(_DWORD *)(sub_1002E6E9C() + 708) == 15)
  {
    int v119 = 0;
    uint64_t v68 = sub_1002E6E00();
    sub_10002418C(&buf, "CoEx");
    sub_10002418C(v121, "EnableDebugCounters");
    int v69 = (*(uint64_t (**)(uint64_t, __int128 *, uint8_t *, int *))(*(void *)v68 + 128LL))( v68,  &buf,  v121,  &v119);
    if (v119) {
      int v70 = v69;
    }
    else {
      int v70 = 0;
    }
    if (v122 < 0) {
      operator delete(*(void **)v121);
    }
    if (SBYTE7(v131) < 0) {
      operator delete((void *)buf);
    }
    if (v70)
    {
      uint64_t v71 = sub_1002E6E9C();
      (*(void (**)(uint64_t, void))(*(void *)v71 + 1240LL))(v71, v119);
    }
  }

  uint64_t v72 = sub_1002E6E9C();
  if ((*(unsigned int (**)(uint64_t))(*(void *)v72 + 2080LL))(v72))
  {
    uint64_t v73 = sub_1002E6E9C();
    (*(void (**)(uint64_t, uint64_t, void))(*(void *)v73 + 1704LL))(v73, 1LL, 0LL);
  }

  if (*(_DWORD *)(sub_1002E6E9C() + 708) < 0x7D0u || *(_DWORD *)(sub_1002E6E9C() + 708) > 0xF9Fu) {
    goto LABEL_162;
  }
  uint64_t v74 = sub_1002E6E00();
  sub_10002418C(&buf, "fw");
  sub_10002418C(v121, "TraceMode");
  int v75 = (*(uint64_t (**)(uint64_t, __int128 *, uint8_t *, int *))(*(void *)v74 + 88LL))( v74,  &buf,  v121,  &v129);
  if (v122 < 0) {
    operator delete(*(void **)v121);
  }
  if (SBYTE7(v131) < 0) {
    operator delete((void *)buf);
  }
  if (v129 >= 0) {
    int v76 = v75;
  }
  else {
    int v76 = 0;
  }
  if (v76 == 1 && v129 <= 6)
  {
    uint64_t v77 = sub_1002E6E9C();
    (*(void (**)(uint64_t, void))(*(void *)v77 + 1264LL))(v77, v129);
    uint64_t v78 = sub_1002E6E00();
    if (((*(uint64_t (**)(uint64_t))(*(void *)v78 + 8LL))(v78) & 1) == 0)
    {
      uint64_t v79 = sub_1002E6E00();
      BOOL v80 = v129 != 0;
LABEL_161:
      (*(void (**)(uint64_t, BOOL))(*(void *)v79 + 504LL))(v79, v80);
    }
  }

  else
  {
    uint64_t v81 = sub_1002E6E00();
    if (!(*(unsigned int (**)(uint64_t))(*(void *)v81 + 8LL))(v81))
    {
      uint64_t v83 = sub_1002E6E9C();
      (*(void (**)(uint64_t, void))(*(void *)v83 + 1264LL))(v83, 0LL);
      uint64_t v79 = sub_1002E6E00();
      BOOL v80 = 0LL;
      goto LABEL_161;
    }

    uint64_t v82 = sub_1002E6E9C();
    (*(void (**)(uint64_t, uint64_t))(*(void *)v82 + 1264LL))(v82, 6LL);
  }

        uint64_t v73 = (os_log_s *)qword_1008F7728;
        if (os_log_type_enabled((os_log_t)qword_1008F7728, OS_LOG_TYPE_DEFAULT))
        {
          uint64_t v74 = *v7;
          *(_DWORD *)uint64_t v91 = 141558275;
          *(void *)&v91[4] = 1752392040LL;
          *(_WORD *)&v91[12] = 2113;
          *(void *)&v91[14] = v74;
          _os_log_impl( (void *)&_mh_execute_header,  v73,  OS_LOG_TYPE_DEFAULT,  "Disable device %{private, mask.hash}@ input",  v91,  0x16u);
        }

        sub_1002721D4((uint64_t)v45, 0);
        uint64_t v72 = 0;
LABEL_136:
        *(_BYTE *)(a2 + 129) = v72;
        sub_10027228C((uint64_t)v45, *(unsigned __int8 *)(a1 + 440) == 2);
        int v75 = operator new(0x28uLL);
        *int v75 = v45;
        v75[1] = 0LL;
        *((_DWORD *)v75 + 4) = 0;
        v75[3] = 0LL;
        v75[4] = 0LL;
        *(void *)(a1 + 536) = v75;
        sub_10026EE48((uint64_t)v45);
        int v37 = *(void **)buf;
LABEL_65:
        operator delete(v37);
LABEL_66:
        if (qword_1008D5F10 != -1) {
          dispatch_once(&qword_1008D5F10, &stru_10089C270);
        }
        int v38 = sub_10059A5A8((uint64_t)off_1008D5F08, *(void *)a2);
        uint64_t v39 = (void *)objc_claimAutoreleasedReturnValue(v38);
        if (*(_BYTE *)(a1 + 648))
        {
          sub_1004BD430(a1, v39);
        }

        else
        {
          if (qword_1008D9B20 != -1) {
            dispatch_once(&qword_1008D9B20, &stru_10089C1F0);
          }
          sub_1004BD4B0(qword_1008D9B18, v39);
        }

        uint64_t v40 = sub_1004BD514(a1, v39);
        if (v40) {
          sub_1003A2D60((uint64_t)v40, *(_WORD *)(a2 + 16));
        }

        goto LABEL_76;
      }
    }

    else
    {
      uint64_t v56 = 0;
      if ((v55 & 2) == 0) {
        goto LABEL_110;
      }
    }

    uint64_t v59 = sub_1002E6E9C();
    if (sub_1002D0F8C(v59) == 2)
    {
      unsigned __int16 v60 = (os_log_s *)qword_1008F7728;
      if (os_log_type_enabled((os_log_t)qword_1008F7728, OS_LOG_TYPE_DEFAULT))
      {
        uint64_t v61 = *v7;
        *(_DWORD *)uint64_t v91 = 141558275;
        *(void *)&v91[4] = 1752392040LL;
        *(_WORD *)&v91[12] = 2113;
        *(void *)&v91[14] = v61;
        _os_log_impl( (void *)&_mh_execute_header,  v60,  OS_LOG_TYPE_DEFAULT,  "Device %{private, mask.hash}@ supports input",  v91,  0x16u);
      }

      v56 |= 1u;
    }

    goto LABEL_110;
  }

  if (sub_1004BC11C(a1))
  {
    *(_DWORD *)uint64_t v91 = 0;
    int v21 = sub_100270164(**(void **)(a1 + 536), v91);
    if ((_DWORD)v21) {
      sub_1004BA9AC((uint64_t)v21, a2, (int)(float)(*(float *)v91 * 255.0));
    }
    int v22 = *(uint64_t **)(a1 + 536);
    if (v22[1]) {
      *(_BYTE *)(a2 + 112) = 1;
    }
    *(_DWORD *)&v90.byte0 = 0;
    sub_1002721B4(*v22, &v90);
    if ((v90.byte0 & 1) == 0) {
      goto LABEL_59;
    }
    if (qword_1008D5F30 != -1) {
      dispatch_once(&qword_1008D5F30, &stru_10089C230);
    }
    uint64_t v23 = off_1008D5F28;
    if (qword_1008D5F10 != -1) {
      dispatch_once(&qword_1008D5F10, &stru_10089C270);
    }
    int v24 = sub_10059A5A8((uint64_t)off_1008D5F08, *(void *)a2);
    uint64_t v25 = (void *)objc_claimAutoreleasedReturnValue(v24);
    sub_10002418C(v77, "Enable Input");
    uint64_t v26 = sub_1005CE5A8((uint64_t)v23, v25, (uint64_t)v77);
    if (v78 < 0) {
      operator delete(v77[0]);
    }

    if (v26)
    {
      uint64_t v27 = (os_log_s *)qword_1008F7728;
      if (os_log_type_enabled((os_log_t)qword_1008F7728, OS_LOG_TYPE_DEFAULT))
      {
        int v28 = *v7;
        *(_DWORD *)__int128 buf = 141558275;
        *(void *)&uint8_t buf[4] = 1752392040LL;
        *(_WORD *)&_BYTE buf[12] = 2113;
        *(void *)&_BYTE buf[14] = v28;
        _os_log_impl( (void *)&_mh_execute_header,  v27,  OS_LOG_TYPE_DEFAULT,  "Enable device %{private, mask.hash}@ input",  buf,  0x16u);
      }

      uint64_t v29 = 1;
      sub_1002721D4(**(void **)(a1 + 536), 1);
    }

    else
    {
LABEL_59:
      uint64_t v34 = (os_log_s *)qword_1008F7728;
      uint64_t v29 = 0;
      if (os_log_type_enabled((os_log_t)qword_1008F7728, OS_LOG_TYPE_DEFAULT))
      {
        uint64_t v35 = *v7;
        *(_DWORD *)__int128 buf = 141558275;
        *(void *)&uint8_t buf[4] = 1752392040LL;
        *(_WORD *)&_BYTE buf[12] = 2113;
        *(void *)&_BYTE buf[14] = v35;
        _os_log_impl( (void *)&_mh_execute_header,  v34,  OS_LOG_TYPE_DEFAULT,  "Disable device %{private, mask.hash}@ input",  buf,  0x16u);

        uint64_t v29 = 0;
      }
    }

    *(_BYTE *)(a2 + 129) = v29;
    if (sub_100271EC8(**(void **)(a1 + 536))) {
      sub_1004BA380(a1, a2);
    }
    uint64_t v36 = **(void **)(a1 + 536);
    sub_100272534(buf, a2 + 80);
    sub_100271FAC(v36, (uint64_t)buf);
    int v37 = *(void **)buf;
    if (!*(void *)buf) {
      goto LABEL_66;
    }
    *(void *)&uint8_t buf[8] = *(void *)buf;
    goto LABEL_65;
  }

  int v32 = os_log_type_enabled((os_log_t)qword_1008F7728, OS_LOG_TYPE_ERROR);
  if (v32) {
    sub_1006862B4();
  }
  uint64_t v33 = sub_1004BBD70(v32, *(__int128 **)a2, 12, 8);
  sub_1004B9840((uint64_t)v33, a2, 0);
LABEL_76:
}

void sub_10042F8B4( _Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, int a15, __int16 a16, char a17, char a18, uint64_t a19, uint64_t a20, uint64_t a21, uint64_t a22, uint64_t a23, uint64_t a24, uint64_t a25, void *__p, uint64_t a27, int a28, __int16 a29, char a30, char a31, char a32)
{
}

void sub_10042FA60(os_unfair_lock_s *a1)
{
  uint64_t v2 = (os_log_s *)qword_1008F7578;
  if (os_log_type_enabled((os_log_t)qword_1008F7578, OS_LOG_TYPE_DEFAULT))
  {
    *(_WORD *)int v3 = 0;
    _os_log_impl( (void *)&_mh_execute_header,  v2,  OS_LOG_TYPE_DEFAULT,  "Notifying stack listeners that the stack will start",  v3,  2u);
  }

  sub_100438418(a1 + 20, &stru_100898230);
}

uint64_t sub_10042FAD8(uint64_t a1)
{
  uint64_t v1 = *(void *)(a1 + 32);
  if (qword_1008D90F8 != -1) {
    dispatch_once(&qword_1008D90F8, &stru_1008984A0);
  }
  sub_10054A7B0((uint64_t)off_1008D90F0, v1 + 48);
  if (qword_1008D90F8 != -1) {
    dispatch_once(&qword_1008D90F8, &stru_1008984A0);
  }
  uint64_t result = sub_10054AA5C((uint64_t)off_1008D90F0);
  if (!(_DWORD)result) {
    return (*(uint64_t (**)(uint64_t, void))(*(void *)v1 + 128LL))(v1, 0LL);
  }
  return result;
}

double sub_10042FB88(double a1)
{
  uint64_t v2 = objc_autoreleasePoolPush();
  int v3 = (void *)objc_claimAutoreleasedReturnValue( +[NSDate dateWithTimeIntervalSinceReferenceDate:]( &OBJC_CLASS___NSDate,  "dateWithTimeIntervalSinceReferenceDate:",  a1));
  uint64_t v4 = (void *)objc_claimAutoreleasedReturnValue(+[NSCalendar currentCalendar](&OBJC_CLASS___NSCalendar, "currentCalendar"));
  char v5 = (void *)objc_claimAutoreleasedReturnValue([v4 components:60 fromDate:v3]);
  [v5 setHour:5];
  [v5 setDay:[v5 day] + 1];
  uint64_t v6 = (void *)objc_claimAutoreleasedReturnValue([v4 dateFromComponents:v5]);
  [v6 timeIntervalSinceReferenceDate];
  double v8 = v7;

  objc_autoreleasePoolPop(v2);
  return v8;
}

void sub_10042FC58(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_10042FC90(uint64_t a1, int a2)
{
  if (*(unsigned __int8 *)(a1 + 219) == a2)
  {
    uint64_t v3 = qword_1008F7578;
    if (!os_log_type_enabled((os_log_t)qword_1008F7578, OS_LOG_TYPE_DEFAULT)) {
      return;
    }
    uint64_t v4 = "disabled";
    if (a2) {
      uint64_t v4 = "enabled";
    }
    LODWORD(v19) = 136315138;
    *(void *)((char *)&v19 + 4) = v4;
    char v5 = "Denylist already %s";
    uint64_t v6 = (os_log_s *)v3;
    uint32_t v7 = 12;
LABEL_28:
    _os_log_impl((void *)&_mh_execute_header, v6, OS_LOG_TYPE_DEFAULT, v5, (uint8_t *)&v19, v7);
    return;
  }

  int v9 = *(_DWORD *)(a1 + 72);
  uint64_t v10 = (os_log_s *)qword_1008F7578;
  BOOL v11 = os_log_type_enabled((os_log_t)qword_1008F7578, OS_LOG_TYPE_DEFAULT);
  if (v9 != 1)
  {
    if (!v11) {
      return;
    }
    LOWORD(v19) = 0;
    char v5 = "Ignore set denylist mode due to stack not ready";
    uint64_t v6 = v10;
    uint32_t v7 = 2;
    goto LABEL_28;
  }

  if (v11)
  {
    uint64_t v12 = "disabled";
    if (a2) {
      uint64_t v12 = "enabled";
    }
    LODWORD(v19) = 136315138;
    *(void *)((char *)&v19 + 4) = v12;
    _os_log_impl((void *)&_mh_execute_header, v10, OS_LOG_TYPE_DEFAULT, "denylist mode %s", (uint8_t *)&v19, 0xCu);
  }

  *(_BYTE *)(a1 + 219) = a2;
  if (qword_1008D6788 != -1) {
    dispatch_once(&qword_1008D6788, &stru_100898400);
  }
  if (sub_10040DDD8((uint64_t)off_1008D6780))
  {
    if (a2) {
      int v13 = 2;
    }
    else {
      int v13 = 1;
    }
    sub_1004313B8(a1, v13);
  }

  if (*(_BYTE *)(a1 + 219))
  {
    __int128 v19 = 0uLL;
    uint64_t v20 = 0LL;
    if (qword_1008D67E8 != -1) {
      dispatch_once(&qword_1008D67E8, &stru_1008984E0);
    }
    sub_1003C9C48((uint64_t)off_1008D67E0, (void **)&v19);
    uint64_t v14 = (uint64_t *)v19;
    if ((void)v19 != *((void *)&v19 + 1))
    {
      do
      {
        uint64_t v15 = *v14;
        if (qword_1008D60D0 != -1) {
          dispatch_once(&qword_1008D60D0, &stru_1008983E0);
        }
        sub_100424304((uint64_t)off_1008D60C8, v15, 1);
        ++v14;
      }

      while (v14 != *((uint64_t **)&v19 + 1));
      uint64_t v14 = (uint64_t *)v19;
    }

    if (v14)
    {
      *((void *)&v19 + 1) = v14;
      operator delete(v14);
    }
  }

  if (qword_1008D5F00 != -1) {
    dispatch_once(&qword_1008D5F00, &stru_1008983C0);
  }
  sub_1004099F8((uint64_t)off_1008D5EF8, 10, 0);
  LOBYTE(v19) = 0;
  sub_100242CA4(&v19);
  if (*(_BYTE *)(a1 + 219))
  {
    if (qword_1008D6198 != -1) {
      dispatch_once(&qword_1008D6198, &stru_100898420);
    }
    +[NSDate timeIntervalSinceReferenceDate](&OBJC_CLASS___NSDate, "timeIntervalSinceReferenceDate");
    sub_1004490F8(v16);
    +[NSDate timeIntervalSinceReferenceDate](&OBJC_CLASS___NSDate, "timeIntervalSinceReferenceDate");
    double v18 = sub_10042FB88(v17);
    sub_1004300BC(1, v18);
  }

  else
  {
    if (qword_1008D6198 != -1) {
      dispatch_once(&qword_1008D6198, &stru_100898420);
    }
    sub_1004490F8(0.0);
    sub_10010F948();
  }

  sub_100242CD0(&v19);
  if (qword_1008D67C8 != -1) {
    dispatch_once(&qword_1008D67C8, &stru_1008984C0);
  }
  sub_100283A5C((uint64_t)off_1008D67C0, *(_BYTE *)(a1 + 219));
  if (qword_1008D5F30 != -1) {
    dispatch_once(&qword_1008D5F30, &stru_100898460);
  }
  sub_1005CF5F0((uint64_t)off_1008D5F28, *(_BYTE *)(a1 + 219));
  sub_10043153C((_BYTE *)a1);
  sub_100242CD8(&v19);
}

void sub_100430084( _Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, void *__p, uint64_t a10)
{
  if (__p) {
    operator delete(__p);
  }
  _Unwind_Resume(exception_object);
}

void sub_1004300BC(int a1, double a2)
{
  if (a1)
  {
    sub_10010F8F8();
    xpc_object_t v3 = xpc_dictionary_create(0LL, 0LL, 0LL);
    +[NSDate timeIntervalSinceReferenceDate](&OBJC_CLASS___NSDate, "timeIntervalSinceReferenceDate");
    xpc_dictionary_set_double(v3, XPC_ACTIVITY_DELAY, a2 - v4);
    xpc_dictionary_set_int64(v3, XPC_ACTIVITY_GRACE_PERIOD, XPC_ACTIVITY_INTERVAL_1_MIN);
    xpc_dictionary_set_string(v3, XPC_ACTIVITY_PRIORITY, XPC_ACTIVITY_PRIORITY_UTILITY);
    xpc_activity_register("com.apple.bluetooth.denylist.autoExpire", v3, &stru_100898308);
    xpc_release(v3);
  }

  else
  {
    sub_10010F948();
  }

void sub_100430180(id a1)
{
  uint64_t v1 = sub_1002E6B38();
  if (!(*(unsigned int (**)(uint64_t))(*(void *)v1 + 136LL))(v1) && sub_1000FCD0C() != 10)
  {
    if (qword_1008D60B0 != -1) {
      dispatch_once(&qword_1008D60B0, &stru_1008983A0);
    }
    sub_100430258();
    if (qword_1008D60B0 != -1) {
      dispatch_once(&qword_1008D60B0, &stru_1008983A0);
    }
    sub_100430484();
    uint64_t v2 = sub_1002E6E9C();
    if ((*(unsigned int (**)(uint64_t, uint64_t))(*(void *)v2 + 528LL))(v2, 1LL)
      && sub_1000FCD0C() == 7
      && os_log_type_enabled((os_log_t)qword_1008F7578, OS_LOG_TYPE_FAULT))
    {
      sub_10067E53C();
    }
  }

void sub_100430258()
{
  uint64_t v6 = 0LL;
  unsigned __int16 v5 = 0;
  bzero(__str, 0x400uLL);
  size_t v4 = 1024LL;
  if (sysctlbyname("kern.bootargs", __str, &v4, 0LL, 0LL) || (uint64_t v1 = strtok(__str, " ")) == 0LL)
  {
LABEL_2:
    uint64_t v0 = (os_log_s *)qword_1008F7578;
    if (os_log_type_enabled((os_log_t)qword_1008F7578, OS_LOG_TYPE_DEFAULT))
    {
      *(_WORD *)xpc_object_t v3 = 0;
      _os_log_impl( (void *)&_mh_execute_header,  v0,  OS_LOG_TYPE_DEFAULT,  "Load and send calibration data to host controller",  v3,  2u);
    }

    if (sub_100434080(@"bluetooth-taurus-calibration-bf", (UInt8 **)&v6, &v5)
      && sub_100434080(@"bluetooth-taurus-calibration", (UInt8 **)&v6, &v5)
      && sub_10043422C((UInt8 **)&v6, &v5))
    {
      if (sub_100361020() != 239
        && sub_100361020() != 262
        && sub_100361020() != 263)
      {
        if (os_log_type_enabled((os_log_t)qword_1008F7578, OS_LOG_TYPE_FAULT)) {
          sub_10067E594();
        }
        return;
      }

      sub_10043444C((uint64_t)&v6, &v5);
    }

    if (sub_1004345D8((char *)v6, v5, 0xE6u)
      && os_log_type_enabled((os_log_t)qword_1008F7578, OS_LOG_TYPE_FAULT))
    {
      sub_10067E568();
    }

    if (v6) {
      free(v6);
    }
    return;
  }

  while (!strstr(v1, "wifibt-external"))
  {
    uint64_t v1 = strtok(0LL, " ");
    if (!v1) {
      goto LABEL_2;
    }
  }

  uint64_t v2 = (os_log_s *)qword_1008F7578;
  if (os_log_type_enabled((os_log_t)qword_1008F7578, OS_LOG_TYPE_DEFAULT))
  {
    *(_WORD *)xpc_object_t v3 = 0;
    _os_log_impl( (void *)&_mh_execute_header,  v2,  OS_LOG_TYPE_DEFAULT,  "Thunderbolt to PCIe expansion chassis, so skip loading calibration data",  v3,  2u);
  }

void sub_100430484()
{
  uint64_t v14 = 0LL;
  int v13 = 0;
  v11[0] = 0LL;
  v11[1] = 0LL;
  uint64_t v12 = 0LL;
  v9[0] = 0LL;
  v9[1] = 0LL;
  uint64_t v10 = 0LL;
  sub_10002418C(v9, ".ptb");
  uint64_t v0 = (os_log_s *)qword_1008F7578;
  if (os_log_type_enabled((os_log_t)qword_1008F7578, OS_LOG_TYPE_DEFAULT))
  {
    *(_WORD *)__int128 buf = 0;
    _os_log_impl( (void *)&_mh_execute_header,  v0,  OS_LOG_TYPE_DEFAULT,  "Load and send regulatory data to host controller",  buf,  2u);
  }

  uint64_t v1 = sub_1002E8D54();
  if (SHIBYTE(v10) < 0)
  {
    sub_100024238(__p, v9[0], (unint64_t)v9[1]);
  }

  else
  {
    *(_OWORD *)std::stringbuf::string_type __p = *(_OWORD *)v9;
    uint64_t v7 = v10;
  }

  int v2 = (*(uint64_t (**)(uint64_t, void **, char **, int *, void **))(*(void *)v1 + 408LL))( v1,  __p,  &v14,  &v13,  v11);
  int v3 = v2;
  if (SHIBYTE(v7) < 0)
  {
    operator delete(__p[0]);
    if (v3)
    {
LABEL_8:
      if (os_log_type_enabled((os_log_t)qword_1008F7578, OS_LOG_TYPE_FAULT)) {
        sub_10067E5EC();
      }
      goto LABEL_19;
    }
  }

  else if (v2)
  {
    goto LABEL_8;
  }

  if (v13 < 251)
  {
    uint64_t v5 = sub_1002E6E9C();
    int v4 = (*(uint64_t (**)(uint64_t, char *, void, uint64_t))(*(void *)v5 + 3584LL))( v5,  v14,  (unsigned __int16)v13,  1LL);
  }

  else
  {
    int v4 = sub_1004345D8(v14, (unsigned __int16)v13, 0xCFu);
  }

  if (v4 && os_log_type_enabled((os_log_t)qword_1008F7578, OS_LOG_TYPE_FAULT)) {
    sub_10067E5C0();
  }
  if (v14) {
    free(v14);
  }
LABEL_19:
  if (SHIBYTE(v10) < 0) {
    operator delete(v9[0]);
  }
  if (SHIBYTE(v12) < 0) {
    operator delete(v11[0]);
  }
}

void sub_100430628( _Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, void *__p, uint64_t a10, int a11, __int16 a12, char a13, char a14, uint64_t a15, uint64_t a16, uint64_t a17, void *a18, uint64_t a19, int a20, __int16 a21, char a22, char a23)
{
  if (a14 < 0) {
    operator delete(__p);
  }
  if (a23 < 0) {
    operator delete(a18);
  }
  _Unwind_Resume(exception_object);
}

void sub_100430674(os_unfair_lock_s *a1)
{
  int v2 = (os_log_s *)qword_1008F7578;
  if (os_log_type_enabled((os_log_t)qword_1008F7578, OS_LOG_TYPE_DEFAULT))
  {
    *(_WORD *)int v3 = 0;
    _os_log_impl( (void *)&_mh_execute_header,  v2,  OS_LOG_TYPE_DEFAULT,  "Notifying stack listeners that the stack did start",  v3,  2u);
  }

  sub_100438418(a1 + 20, &stru_100898250);
}

uint64_t sub_1004306EC(uint64_t a1)
{
  v6[0] = 0LL;
  v6[1] = 0LL;
  sub_100242F28((uint64_t)v6, a1 + 144);
  if ((*(_DWORD *)(a1 + 72) | 2) == 2)
  {
    if (os_log_type_enabled((os_log_t)qword_1008F7578, OS_LOG_TYPE_ERROR)) {
      sub_10067E618();
    }
    uint64_t v2 = 111LL;
  }

  else
  {
    *(_BYTE *)(a1 + 216) = sub_100432FA0();
    uint64_t v3 = sub_100404EB8();
    int v4 = operator new(0x18uLL);
    v4[4] = 0;
    *((void *)v4 + 2) = 0LL;
    *(void *)int v4 = &off_100898358;
    sub_100405744(v3, v4);
    uint64_t v2 = 0LL;
  }

  sub_100242FAC((uint64_t)v6);
  return v2;
}

void sub_1004307AC( _Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9)
{
}

uint64_t sub_1004307C0(uint64_t a1)
{
  uint64_t v2 = (os_log_s *)qword_1008F7578;
  if (os_log_type_enabled((os_log_t)qword_1008F7578, OS_LOG_TYPE_DEFAULT))
  {
    *(_WORD *)__int128 buf = 0;
    _os_log_impl((void *)&_mh_execute_header, v2, OS_LOG_TYPE_DEFAULT, "StackManager halting stack", buf, 2u);
  }

  *(void *)__int128 buf = 0LL;
  uint64_t v29 = 0LL;
  sub_100242F28((uint64_t)buf, a1 + 144);
  int v3 = *(_DWORD *)(a1 + 72);
  if (v3)
  {
    if (v3 == 2)
    {
      if (os_log_type_enabled((os_log_t)qword_1008F7578, OS_LOG_TYPE_ERROR)) {
        sub_10067E6BC();
      }
      uint64_t v4 = 111LL;
      goto LABEL_36;
    }

    sub_10042C278(a1, 2u, 0);
    sub_100242F54((uint64_t)buf);
    uint64_t v6 = (os_log_s *)qword_1008F7578;
    if (os_log_type_enabled((os_log_t)qword_1008F7578, OS_LOG_TYPE_DEFAULT))
    {
      LOWORD(v25[0]) = 0;
      _os_log_impl( (void *)&_mh_execute_header,  v6,  OS_LOG_TYPE_DEFAULT,  "Starting event un-registerations",  (uint8_t *)v25,  2u);
    }

    uint64_t v7 = sub_1002E6BF0();
    if ((*(unsigned int (**)(uint64_t))(*(void *)v7 + 112LL))(v7))
    {
      uint64_t v8 = sub_100405058();
      v27[0] = _NSConcreteStackBlock;
      v27[1] = 3221225472LL;
      void v27[2] = sub_100430BB8;
      v27[3] = &unk_10087EB20;
      v27[4] = a1;
      sub_1004054B4(v8, v27);
    }

    uint64_t v9 = sub_1002E6BF0();
    if ((*(unsigned int (**)(uint64_t))(*(void *)v9 + 104LL))(v9))
    {
      uint64_t v10 = sub_1002E8D54();
      sub_10024E060(v10 + 568, a1 + 32);
    }

    uint64_t v11 = sub_1002E8D54();
    sub_10024E060(v11 + 368, a1 + 16);
    char v26 = 0;
    sub_100242CA4(&v26);
    int v12 = sub_1000FCD0C();
    int v13 = (os_log_s *)qword_1008F7578;
    BOOL v14 = os_log_type_enabled((os_log_t)qword_1008F7578, OS_LOG_TYPE_DEFAULT);
    if (v12 == 7)
    {
      if (v14)
      {
        LOWORD(v25[0]) = 0;
        _os_log_impl( (void *)&_mh_execute_header,  v13,  OS_LOG_TYPE_DEFAULT,  "Hard reset transport...",  (uint8_t *)v25,  2u);
      }

      if (sub_1000FC2BC())
      {
        if (os_log_type_enabled((os_log_t)qword_1008F7578, OS_LOG_TYPE_ERROR)) {
          sub_10067E690();
        }
        uint64_t v4 = 1LL;
LABEL_35:
        sub_100242CD8(&v26);
        goto LABEL_36;
      }
    }

    else
    {
      if (v14)
      {
        LOWORD(v25[0]) = 0;
        _os_log_impl((void *)&_mh_execute_header, v13, OS_LOG_TYPE_DEFAULT, "Sending HCI reset", (uint8_t *)v25, 2u);
      }

      byte_1008F74F0 = 1;
      sub_1001214B4(55, (uint64_t)sub_100430C08, v15, v16, v17, v18, v19, v20, (uint64_t)v25[0]);
      sub_100242CD0(&v26);
      int v21 = (os_log_s *)qword_1008F7578;
      if (os_log_type_enabled((os_log_t)qword_1008F7578, OS_LOG_TYPE_DEFAULT))
      {
        LOWORD(v25[0]) = 0;
        _os_log_impl( (void *)&_mh_execute_header,  v21,  OS_LOG_TYPE_DEFAULT,  "Waiting for controller reset complete",  (uint8_t *)v25,  2u);
      }

      v25[0] = 0LL;
      v25[1] = 0LL;
      sub_100242F28((uint64_t)v25, (uint64_t)&unk_1008F74B0);
      if (byte_1008F74F0) {
        sub_1002430FC(&stru_1008F7480, v25);
      }
      sub_100242FAC((uint64_t)v25);
    }

    int v22 = (os_log_s *)qword_1008F7578;
    if (os_log_type_enabled((os_log_t)qword_1008F7578, OS_LOG_TYPE_DEFAULT))
    {
      LOWORD(v25[0]) = 0;
      _os_log_impl( (void *)&_mh_execute_header,  v22,  OS_LOG_TYPE_DEFAULT,  "Configuring stack to halt",  (uint8_t *)v25,  2u);
    }

    sub_10010C6F4();
    uint64_t v23 = (os_log_s *)qword_1008F7578;
    if (os_log_type_enabled((os_log_t)qword_1008F7578, OS_LOG_TYPE_DEFAULT))
    {
      LOWORD(v25[0]) = 0;
      _os_log_impl((void *)&_mh_execute_header, v23, OS_LOG_TYPE_DEFAULT, "Halting core stack", (uint8_t *)v25, 2u);
    }

    sub_1000FC228();
    sub_1000FC218();
    uint64_t v4 = 0LL;
    goto LABEL_35;
  }

  uint64_t v5 = (os_log_s *)qword_1008F7578;
  uint64_t v4 = 0LL;
  if (os_log_type_enabled((os_log_t)qword_1008F7578, OS_LOG_TYPE_DEFAULT))
  {
    LOWORD(v25[0]) = 0;
    _os_log_impl( (void *)&_mh_execute_header,  v5,  OS_LOG_TYPE_DEFAULT,  "StackManager is already stopped",  (uint8_t *)v25,  2u);
    uint64_t v4 = 0LL;
  }

void sub_100430B7C( _Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, int a11, __int16 a12, char a13, char a14)
{
}

void sub_100430BB8(uint64_t a1)
{
  uint64_t v1 = *(void *)(a1 + 32);
  if (qword_1008D90F8 != -1) {
    dispatch_once(&qword_1008D90F8, &stru_1008984A0);
  }
  sub_10054A86C((uint64_t)off_1008D90F0, v1 + 48);
}

uint64_t sub_100430C08()
{
  v1[0] = 0LL;
  v1[1] = 0LL;
  sub_100242F28((uint64_t)v1, (uint64_t)&unk_1008F74B0);
  byte_1008F74F0 = 0;
  sub_1002431FC(&stru_1008F7480);
  return sub_100242FAC((uint64_t)v1);
}

void sub_100430C58( _Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9)
{
}

uint64_t sub_100430C6C(uint64_t a1)
{
  uint64_t v2 = (os_log_s *)qword_1008F7578;
  if (os_log_type_enabled((os_log_t)qword_1008F7578, OS_LOG_TYPE_DEFAULT))
  {
    *(_WORD *)__int128 buf = 0;
    _os_log_impl((void *)&_mh_execute_header, v2, OS_LOG_TYPE_DEFAULT, "StackManager shutting down", buf, 2u);
  }

  *(void *)__int128 buf = 0LL;
  uint64_t v27 = 0LL;
  sub_100242F28((uint64_t)buf, a1 + 144);
  int v3 = *(_DWORD *)(a1 + 72);
  if (!v3)
  {
    uint64_t v5 = (os_log_s *)qword_1008F7578;
    uint64_t v4 = 0LL;
    if (!os_log_type_enabled((os_log_t)qword_1008F7578, OS_LOG_TYPE_DEFAULT)) {
      goto LABEL_39;
    }
    *(_WORD *)uint64_t v25 = 0;
    _os_log_impl((void *)&_mh_execute_header, v5, OS_LOG_TYPE_DEFAULT, "StackManager is already stopped", v25, 2u);
LABEL_38:
    uint64_t v4 = 0LL;
    goto LABEL_39;
  }

  if (v3 != 2)
  {
    sub_10042C278(a1, 2u, 0);
    sub_100242F54((uint64_t)buf);
    if (*(_BYTE *)(a1 + 218) && *(_DWORD *)(sub_1002E6E9C() + 708) && *(_DWORD *)(sub_1002E6E9C() + 708) <= 0x7CFu)
    {
      uint64_t v6 = (os_log_s *)qword_1008F7578;
      if (os_log_type_enabled((os_log_t)qword_1008F7578, OS_LOG_TYPE_DEFAULT))
      {
        *(_WORD *)uint64_t v25 = 0;
        _os_log_impl( (void *)&_mh_execute_header,  v6,  OS_LOG_TYPE_DEFAULT,  "StackManager preparing for chip power down",  v25,  2u);
      }

      if (*(_DWORD *)(sub_1002E6E9C() + 708) <= 0x12u)
      {
        uint64_t v7 = sub_1002E6E9C();
        if ((*(unsigned int (**)(uint64_t, void))(*(void *)v7 + 1256LL))(v7, 0LL))
        {
          v25[0] = 0;
          sub_100242CA4(v25);
          sub_10011EF18();
          sub_100242CD0(v25);
          sub_100242CD8(v25);
        }
      }
    }

    uint64_t v8 = (os_log_s *)qword_1008F7578;
    if (os_log_type_enabled((os_log_t)qword_1008F7578, OS_LOG_TYPE_DEFAULT))
    {
      *(_WORD *)uint64_t v25 = 0;
      _os_log_impl((void *)&_mh_execute_header, v8, OS_LOG_TYPE_DEFAULT, "Starting event un-registerations", v25, 2u);
    }

    uint64_t v9 = sub_1002E6BF0();
    if ((*(unsigned int (**)(uint64_t))(*(void *)v9 + 112LL))(v9))
    {
      uint64_t v10 = sub_100405058();
      v24[0] = _NSConcreteStackBlock;
      v24[1] = 3221225472LL;
      void v24[2] = sub_1004310EC;
      v24[3] = &unk_10087EB20;
      void v24[4] = a1;
      sub_1004054B4(v10, v24);
    }

    uint64_t v11 = sub_1002E6BF0();
    if ((*(unsigned int (**)(uint64_t))(*(void *)v11 + 104LL))(v11))
    {
      uint64_t v12 = sub_1002E8D54();
      sub_10024E060(v12 + 568, a1 + 32);
    }

    uint64_t v13 = sub_1002E8D54();
    sub_10024E060(v13 + 368, a1 + 16);
    uint64_t v14 = (os_log_s *)qword_1008F7578;
    if (os_log_type_enabled((os_log_t)qword_1008F7578, OS_LOG_TYPE_DEFAULT))
    {
      *(_WORD *)uint64_t v25 = 0;
      _os_log_impl((void *)&_mh_execute_header, v14, OS_LOG_TYPE_DEFAULT, "Configuring stack to stop", v25, 2u);
    }

    v25[0] = 0;
    sub_100242CA4(v25);
    sub_10010C6D8();
    sub_100242CD0(v25);
    sub_10043113C((os_unfair_lock_s *)a1);
    sub_100242C98(v25);
    byte_1008F747D = 1;
    int v22 = sub_10011EBE4((uint64_t)sub_1004311B4, v15, v16, v17, v18, v19, v20, v21);
    sub_100242CD0(v25);
    if (v22)
    {
      if (os_log_type_enabled((os_log_t)qword_1008F7578, OS_LOG_TYPE_ERROR)) {
        sub_10067E748();
      }
      byte_1008F747D = 0;
    }

    else if (sub_100431224(a1) && os_log_type_enabled((os_log_t)qword_1008F7578, OS_LOG_TYPE_ERROR))
    {
      sub_10067E6E8();
    }

    sub_10042DE1C(a1);
    sub_10010C454(0LL);
    sub_100242ECC((uint64_t)buf);
    sub_10042C278(a1, 0, 0);
    *(_BYTE *)(a1 + 20sub_100242E28(v1 + 8) = 0;
    *(_WORD *)(a1 + 21sub_100414D2C(qword_1008F72C0, 0) = 0;
    *(_BYTE *)(a1 + 212) = 0;
    *(_BYTE *)(a1 + 215) = 0;
    *(_BYTE *)(a1 + 219) = 0;
    sub_100242F54((uint64_t)buf);
    if (qword_1008D67C8 != -1) {
      dispatch_once(&qword_1008D67C8, &stru_1008984C0);
    }
    sub_100283A5C((uint64_t)off_1008D67C0, *(_BYTE *)(a1 + 219));
    if (qword_1008D6198 != -1) {
      dispatch_once(&qword_1008D6198, &stru_100898420);
    }
    sub_1004490F8(0.0);
    sub_1000BB02C();
    sub_100431338((os_unfair_lock_s *)a1);
    sub_100242CD8(v25);
    goto LABEL_38;
  }

  if (os_log_type_enabled((os_log_t)qword_1008F7578, OS_LOG_TYPE_ERROR)) {
    sub_10067E4B8();
  }
  uint64_t v4 = 111LL;
LABEL_39:
  sub_100242FAC((uint64_t)buf);
  return v4;
}

void sub_1004310B0(_Unwind_Exception *a1)
{
}

void sub_1004310EC(uint64_t a1)
{
  uint64_t v1 = *(void *)(a1 + 32);
  if (qword_1008D90F8 != -1) {
    dispatch_once(&qword_1008D90F8, &stru_1008984A0);
  }
  sub_10054A86C((uint64_t)off_1008D90F0, v1 + 48);
}

void sub_10043113C(os_unfair_lock_s *a1)
{
  uint64_t v2 = (os_log_s *)qword_1008F7578;
  if (os_log_type_enabled((os_log_t)qword_1008F7578, OS_LOG_TYPE_DEFAULT))
  {
    *(_WORD *)int v3 = 0;
    _os_log_impl( (void *)&_mh_execute_header,  v2,  OS_LOG_TYPE_DEFAULT,  "Notifying stack listeners that the stack will stop",  v3,  2u);
  }

  sub_100438418(a1 + 20, &stru_100898270);
}

uint64_t sub_1004311B4(int a1)
{
  v3[0] = 0LL;
  v3[1] = 0LL;
  sub_100242F28((uint64_t)v3, (uint64_t)&unk_1008F73D8);
  byte_1008F747D = 0;
  dword_1008F7478 = a1;
  sub_1002431FC(&stru_1008F7418);
  return sub_100242FAC((uint64_t)v3);
}

void sub_100431210( _Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9)
{
}

uint64_t sub_100431224(uint64_t a1)
{
  v8[0] = 0LL;
  v8[1] = 0LL;
  sub_100242F28((uint64_t)v8, (uint64_t)&unk_1008F73D8);
  if (byte_1008F747D && !sub_1002431A4(&stru_1008F7418, v8, 0x3A98uLL))
  {
    if (sub_1002E8D94())
    {
      uint64_t v4 = sub_1002E8D94();
      __p[0] = 0LL;
      __p[1] = 0LL;
      uint64_t v7 = 0LL;
      (*(void (**)(uint64_t, uint64_t, void, void **))(*(void *)v4 + 104LL))(v4, 4LL, 0LL, __p);
      if (SHIBYTE(v7) < 0) {
        operator delete(__p[0]);
      }
    }

    sub_10002418C(&v5, "");
    sub_1004319D0(a1, 9500, &v5);
  }

  uint64_t v2 = dword_1008F7478;
  sub_100242FAC((uint64_t)v8);
  return v2;
}

void sub_1004312F8( _Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, int a11, __int16 a12, char a13, char a14, void *__p, uint64_t a16, int a17, __int16 a18, char a19, char a20)
{
  if (a20 < 0) {
    operator delete(__p);
  }
  sub_100242FAC(v20 - 32);
  _Unwind_Resume(a1);
}

void sub_100431338(os_unfair_lock_s *a1)
{
  uint64_t v2 = (os_log_s *)qword_1008F7578;
  if (os_log_type_enabled((os_log_t)qword_1008F7578, OS_LOG_TYPE_DEFAULT))
  {
    *(_WORD *)int v3 = 0;
    _os_log_impl( (void *)&_mh_execute_header,  v2,  OS_LOG_TYPE_DEFAULT,  "Notifying stack listeners that the stack did stop",  v3,  2u);
  }

  sub_100438418(a1 + 20, &stru_100898290);
}

uint64_t sub_1004313B0(uint64_t a1)
{
  return *(unsigned __int8 *)(a1 + 219);
}

uint64_t sub_1004313B8(uint64_t a1, int a2)
{
  v8[0] = 0LL;
  v8[1] = 0LL;
  sub_100242F28((uint64_t)v8, a1 + 488);
  if (*(_DWORD *)(a1 + 552) == a2)
  {
    uint64_t v4 = (os_log_s *)qword_1008F7578;
    if (os_log_type_enabled((os_log_t)qword_1008F7578, OS_LOG_TYPE_DEFAULT))
    {
      *(_DWORD *)__int128 buf = 67109376;
      int v10 = a2;
      __int16 v11 = 1024;
      int v12 = a2;
      _os_log_impl( (void *)&_mh_execute_header,  v4,  OS_LOG_TYPE_DEFAULT,  "Not writing default airplane mode grant list state. As current state (%d) == new state (%d)",  buf,  0xEu);
    }
  }

  else
  {
    if (a2 == 2) {
      __int128 v5 = @"on";
    }
    else {
      __int128 v5 = 0LL;
    }
    *(_DWORD *)(a1 + 552) = a2;
    uint64_t v6 = (os_log_s *)qword_1008F7578;
    if (os_log_type_enabled((os_log_t)qword_1008F7578, OS_LOG_TYPE_DEFAULT))
    {
      *(_DWORD *)__int128 buf = 67109120;
      int v10 = a2;
      _os_log_impl( (void *)&_mh_execute_header,  v6,  OS_LOG_TYPE_DEFAULT,  "Write default airplane mode grant list state: %d to CFPrefs",  buf,  8u);
    }

    CFPreferencesSetAppValue(@"defaultAirplaneModeDenylistState", v5, @"com.apple.BTServer");
    CFPreferencesAppSynchronize(@"com.apple.BTServer");
  }

  return sub_100242FAC((uint64_t)v8);
}

void sub_100431520( _Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9)
{
}

uint64_t sub_10043153C(_BYTE *a1)
{
  v8[0] = 0LL;
  v8[1] = 0LL;
  sub_100242F28((uint64_t)v8, (uint64_t)(a1 + 144));
  if (a1[76])
  {
    if (qword_1008D5F00 != -1) {
      dispatch_once(&qword_1008D5F00, &stru_1008983C0);
    }
    BOOL v2 = sub_10040A5C4((uint64_t)off_1008D5EF8);
    if (a1[219]) {
      BOOL v3 = 0;
    }
    else {
      BOOL v3 = v2;
    }
    a1[213] = v3;
    uint64_t v4 = sub_100404EB8();
    __int128 v5 = operator new(0x18uLL);
    v5[4] = 0;
    *((void *)v5 + 2) = 0LL;
    *(void *)__int128 v5 = &off_1008982C0;
    sub_100405744(v4, v5);
    uint64_t v6 = 0LL;
  }

  else
  {
    if (os_log_type_enabled((os_log_t)qword_1008F7578, OS_LOG_TYPE_ERROR)) {
      sub_10067E7A8();
    }
    uint64_t v6 = 111LL;
  }

  sub_100242FAC((uint64_t)v8);
  return v6;
}

void sub_100431630( _Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9)
{
}

uint64_t sub_100431644(uint64_t a1, uint64_t a2)
{
  v8[0] = 0LL;
  v8[1] = 0LL;
  sub_100242F28((uint64_t)v8, a1 + 144);
  if (*(_BYTE *)(a1 + 76))
  {
    sub_100242F54((uint64_t)v8);
    v7[0] = 0LL;
    v7[1] = 0LL;
    sub_100242F28((uint64_t)v7, a1 + 224);
    int v4 = *(_DWORD *)(a1 + 288);
    *(_WORD *)(a2 + 4) = *(_WORD *)(a1 + 292);
    *(_DWORD *)a2 = v4;
    sub_100242FAC((uint64_t)v7);
    uint64_t v5 = 0LL;
  }

  else
  {
    if (os_log_type_enabled((os_log_t)qword_1008F7578, OS_LOG_TYPE_ERROR)) {
      sub_10067E824();
    }
    uint64_t v5 = 111LL;
  }

  sub_100242FAC((uint64_t)v8);
  return v5;
}

void sub_1004316F4(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, ...)
{
}

uint64_t sub_10043170C(uint64_t a1, std::string *a2)
{
  v7[0] = 0LL;
  v7[1] = 0LL;
  sub_100242F28((uint64_t)v7, a1 + 144);
  if (*(_BYTE *)(a1 + 76))
  {
    sub_100242F54((uint64_t)v7);
    v6[0] = 0LL;
    v6[1] = 0LL;
    sub_100242F28((uint64_t)v6, a1 + 224);
    std::string::operator=(a2, (const std::string *)(a1 + 296));
    sub_100242FAC((uint64_t)v6);
    uint64_t v4 = 0LL;
  }

  else
  {
    if (os_log_type_enabled((os_log_t)qword_1008F7578, OS_LOG_TYPE_ERROR)) {
      sub_10067E824();
    }
    uint64_t v4 = 111LL;
  }

  sub_100242FAC((uint64_t)v7);
  return v4;
}

void sub_1004317B8( _Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, char a11)
{
}

uint64_t sub_1004317E0(uint64_t a1, uint64_t a2, int a3)
{
  uint64_t result = a2;
  if ((int)a2 > 733)
  {
    if ((int)a2 <= 1338)
    {
      if ((int)a2 > 924)
      {
        switch((_DWORD)a2)
        {
          case 0x39D:
            return 118LL;
          case 0x4C1:
            return 323LL;
          case 0x536:
            return 334LL;
        }
      }

      else
      {
        switch((_DWORD)a2)
        {
          case 0x2DE:
            return 327LL;
          case 0x340:
            return 332LL;
          case 0x342:
            return 333LL;
        }
      }
    }

    else if ((int)a2 <= 2042)
    {
      switch((_DWORD)a2)
      {
        case 0x53B:
          return 310LL;
        case 0x586:
          return 181LL;
        case 0x716:
          return 319LL;
      }
    }

    else if ((int)a2 > 3311)
    {
      if ((_DWORD)a2 == 3312) {
        return 317LL;
      }
      if ((_DWORD)a2 == 5014) {
        return 320LL;
      }
    }

    else
    {
      if ((_DWORD)a2 == 2043) {
        return 318LL;
      }
      if ((_DWORD)a2 == 2604) {
        return 326LL;
      }
    }

    return (a3 + a2);
  }

  if ((int)a2 <= 557)
  {
    if ((int)a2 > 149)
    {
      switch((_DWORD)a2)
      {
        case 0x96:
          return 322LL;
        case 0x97:
          return 324LL;
        case 0x1B5:
          return 331LL;
      }
    }

    else
    {
      switch((_DWORD)a2)
      {
        case 0:
          return result;
        case 0x70:
          return 316LL;
        case 0x7A:
          return 312LL;
      }
    }

    return (a3 + a2);
  }

  switch((int)a2)
  {
    case 704:
      return 329LL;
    case 705:
      return 158LL;
    case 706:
      return 151LL;
    case 707:
    case 709:
    case 710:
    case 712:
    case 713:
    case 715:
    case 717:
    case 718:
    case 719:
    case 720:
    case 721:
    case 722:
      return (a3 + a2);
    case 708:
      return 328LL;
    case 711:
      return 314LL;
    case 714:
    case 724:
      return 162LL;
    case 716:
      return 330LL;
    case 723:
      return 166LL;
    default:
      if ((_DWORD)a2 == 558)
      {
        uint64_t result = 321LL;
      }

      else
      {
        if ((_DWORD)a2 != 559) {
          return (a3 + a2);
        }
        uint64_t result = 325LL;
      }

      break;
  }

  return result;
}

void sub_1004319D0(uint64_t a1, int a2, __int128 *a3)
{
  block[0] = _NSConcreteStackBlock;
  block[1] = 3321888768LL;
  block[2] = sub_100435AA8;
  block[3] = &unk_1008981E0;
  void block[4] = a1;
  int v9 = a2;
  if (*((char *)a3 + 23) < 0)
  {
    sub_100024238(&v7, *(void **)a3, *((void *)a3 + 1));
  }

  else
  {
    __int128 v7 = *a3;
    uint64_t v8 = *((void *)a3 + 2);
  }

  if (qword_1008F1010 != -1) {
    dispatch_once(&qword_1008F1010, block);
  }
  sleep(0x384u);
  BOOL v3 = (os_log_s *)qword_1008F7578;
  if (os_log_type_enabled((os_log_t)qword_1008F7578, OS_LOG_TYPE_ERROR))
  {
    *(_DWORD *)__int128 buf = 67109120;
    int v11 = 15;
    _os_log_error_impl( (void *)&_mh_execute_header,  v3,  OS_LOG_TYPE_ERROR,  "We've been sleeping for %d minutes during a coredump, restarting",  buf,  8u);
  }

  uint64_t v4 = sub_1002E6E00();
  sub_10002418C(v5, "");
  sub_1004FB370(v4, 3706LL, (uint64_t)v5, 1);
}

void sub_100431B00( _Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, void *__p, uint64_t a10, int a11, __int16 a12, char a13, char a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, void *a20, uint64_t a21, int a22, __int16 a23, char a24, char a25)
{
  if (a14 < 0) {
    operator delete(__p);
  }
  if (a25 < 0) {
    operator delete(a20);
  }
  _Unwind_Resume(exception_object);
}

void sub_100431B3C(uint64_t a1, uint64_t a2, char a3)
{
  uint64_t v4 = sub_100404EB8();
  v5[0] = _NSConcreteStackBlock;
  v5[1] = 3221225472LL;
  _DWORD v5[2] = sub_100431B9C;
  void v5[3] = &unk_100898180;
  char v6 = a3;
  sub_100405384(v4, v5);
}

void sub_100431B9C(uint64_t a1)
{
  if (sub_1002E8D94())
  {
    uint64_t v2 = sub_1002E8D94();
    uint64_t v3 = *(unsigned __int8 *)(a1 + 32);
    __p[0] = 0LL;
    __p[1] = 0LL;
    uint64_t v5 = 0LL;
    (*(void (**)(uint64_t, uint64_t, uint64_t, void **))(*(void *)v2 + 104LL))(v2, 2LL, v3, __p);
    if (SHIBYTE(v5) < 0) {
      operator delete(__p[0]);
    }
  }

void sub_100431BFC( _Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void *__p, uint64_t a11, int a12, __int16 a13, char a14, char a15)
{
  if (a15 < 0) {
    operator delete(__p);
  }
  _Unwind_Resume(exception_object);
}

void sub_100431C18(uint64_t a1, int a2)
{
  if (a2 == 1)
  {
    if (qword_1008D9060 != -1) {
      dispatch_once(&qword_1008D9060, &stru_100898500);
    }
    uint64_t v3 = qword_1008D9058;
    sub_10002418C(v6, "TransportError");
    sub_10002418C(__p, "TransportErrorDeviceOfflineError");
    sub_10040C784(0.0, v3, (uint64_t *)v6, (uint64_t *)__p);
  }

  else
  {
    if (a2) {
      return;
    }
    if (qword_1008D9060 != -1) {
      dispatch_once(&qword_1008D9060, &stru_100898500);
    }
    uint64_t v2 = qword_1008D9058;
    sub_10002418C(v6, "TransportError");
    sub_10002418C(__p, "TransportErrorNoMemError");
    sub_10040C784(0.0, v2, (uint64_t *)v6, (uint64_t *)__p);
  }

  if (v5 < 0) {
    operator delete(__p[0]);
  }
  if (v7 < 0) {
    operator delete(v6[0]);
  }
}

void sub_100431D30( _Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, void *__p, uint64_t a10, int a11, __int16 a12, char a13, char a14, void *a15, uint64_t a16, int a17, __int16 a18, char a19, char a20)
{
  if (a14 < 0) {
    operator delete(__p);
  }
  if (a20 < 0) {
    operator delete(a15);
  }
  _Unwind_Resume(exception_object);
}

void sub_100431D6C(uint64_t a1, uint64_t a2, uint64_t a3, char *a4)
{
  qword_1008D9DB8 = (uint64_t)byte_1008F0B18;
  qword_1008D9DE8 = a3;
  if (sub_1002E8D94())
  {
    uint64_t v7 = sub_1002E8D94();
    sub_10002418C(__p, a4);
    (*(void (**)(uint64_t, uint64_t, uint64_t, void **))(*(void *)v7 + 104LL))(v7, a2, a3, __p);
    if (v12 < 0) {
      operator delete(__p[0]);
    }
  }

  if (qword_1008D9060 != -1) {
    dispatch_once(&qword_1008D9060, &stru_100898500);
  }
  uint64_t v8 = qword_1008D9058;
  sub_10002418C(__p, "FWErrorDeviceError");
  sub_10002418C(v9, a4);
  sub_10040C784(0.0, v8, (uint64_t *)__p, (uint64_t *)v9);
  if (v10 < 0) {
    operator delete(v9[0]);
  }
  if (v12 < 0) {
    operator delete(__p[0]);
  }
}

void sub_100431EB4( _Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, void *a11, uint64_t a12, int a13, __int16 a14, char a15, char a16, void *__p, uint64_t a18, int a19, __int16 a20, char a21, char a22)
{
  if (a22 < 0) {
    operator delete(__p);
  }
  _Unwind_Resume(exception_object);
}

void sub_100431EEC(uint64_t a1, int a2, int a3, uint64_t a4)
{
  v4[0] = _NSConcreteStackBlock;
  v4[1] = 3221225472LL;
  void v4[2] = sub_100431F5C;
  void v4[3] = &unk_10087F8E0;
  int v5 = a2;
  int v6 = a3;
  v4[4] = a4;
  if (qword_1008F0F18 != -1) {
    dispatch_once(&qword_1008F0F18, v4);
  }
}

void sub_100431F5C(uint64_t a1)
{
  if (sub_1002E8D94())
  {
    uint64_t v2 = sub_1002E8D94();
    uint64_t v3 = *(unsigned int *)(a1 + 40);
    uint64_t v4 = *(unsigned int *)(a1 + 44);
    sub_10002418C(__p, *(char **)(a1 + 32));
    (*(void (**)(uint64_t, uint64_t, uint64_t, void **))(*(void *)v2 + 104LL))(v2, v3, v4, __p);
    if (v6 < 0) {
      operator delete(__p[0]);
    }
  }

void sub_100431FD4( _Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void *__p, uint64_t a11, int a12, __int16 a13, char a14, char a15)
{
  if (a15 < 0) {
    operator delete(__p);
  }
  _Unwind_Resume(exception_object);
}

uint64_t sub_100431FF0(uint64_t a1)
{
  if (qword_1008D60B0 != -1) {
    dispatch_once(&qword_1008D60B0, &stru_1008983A0);
  }
  uint64_t result = sub_100432068((uint64_t)off_1008D60A8);
  if ((_DWORD)result)
  {
    *(_BYTE *)(a1 + sub_100242E28(v1 + 8) = 1;
  }

  else
  {
    *(void *)(a1 + 16) = 100LL;
    uint64_t v3 = sub_100404EB8();
    return sub_100405744(v3, (_BYTE *)a1);
  }

  return result;
}

uint64_t sub_100432068(uint64_t a1)
{
  v18[0] = 0LL;
  v18[1] = 0LL;
  sub_100242F28((uint64_t)v18, a1 + 144);
  int v2 = *(_DWORD *)(a1 + 72);
  if (v2 != 2)
  {
    if (!v2)
    {
      if (os_log_type_enabled((os_log_t)qword_1008F7578, OS_LOG_TYPE_ERROR)) {
        sub_10067E8CC();
      }
      sub_100242F54((uint64_t)v18);
      if (qword_1008D5F00 != -1) {
        dispatch_once(&qword_1008D5F00, &stru_1008983C0);
      }
      int v3 = 111;
      goto LABEL_8;
    }

    if (!*(_BYTE *)(a1 + 208))
    {
      int v8 = *(unsigned __int8 *)(a1 + 212);
      if (v8 != *(unsigned __int8 *)(a1 + 213))
      {
        buf[0] = 0;
        sub_100242CA4(buf);
        int v17 = sub_100114F18( sub_10043254C,  2 * *(unsigned __int8 *)(a1 + 213),  v11,  v12,  v13,  v14,  v15,  v16);
        sub_100242CD0(buf);
        if (v17)
        {
          if (os_log_type_enabled((os_log_t)qword_1008F7578, OS_LOG_TYPE_ERROR)) {
            sub_10067E850();
          }
          sub_100242F54((uint64_t)v18);
          if (qword_1008D5F00 != -1) {
            dispatch_once(&qword_1008D5F00, &stru_1008983C0);
          }
          sub_1004099F8((uint64_t)off_1008D5EF8, 2, 1);
        }

        else
        {
          *(_BYTE *)(a1 + 20sub_100242E28(v1 + 8) = 1;
          *(_BYTE *)(a1 + 214) = *(_BYTE *)(a1 + 213);
        }

        sub_100242CD8(buf);
        goto LABEL_9;
      }

      int v9 = (os_log_s *)qword_1008F7578;
      if (os_log_type_enabled((os_log_t)qword_1008F7578, OS_LOG_TYPE_DEFAULT))
      {
        char v10 = "discoverable";
        if (!v8) {
          char v10 = "not discoverable";
        }
        *(_DWORD *)__int128 buf = 136446210;
        uint64_t v20 = v10;
        _os_log_impl( (void *)&_mh_execute_header,  v9,  OS_LOG_TYPE_DEFAULT,  "Local device state is already %{public}s",  buf,  0xCu);
      }

      sub_100242F54((uint64_t)v18);
      if (qword_1008D5F00 != -1) {
        dispatch_once(&qword_1008D5F00, &stru_1008983C0);
      }
      if (*(_BYTE *)(a1 + 212)) {
        int v3 = 122;
      }
      else {
        int v3 = 123;
      }
LABEL_8:
      sub_1004099F8((uint64_t)off_1008D5EF8, 2, v3);
LABEL_9:
      uint64_t v4 = 1LL;
      goto LABEL_15;
    }
  }

  int v5 = (os_log_s *)qword_1008F7578;
  uint64_t v4 = 0LL;
  if (os_log_type_enabled((os_log_t)qword_1008F7578, OS_LOG_TYPE_DEFAULT))
  {
    char v6 = "busy";
    if (v2 == 2) {
      char v6 = "in flux";
    }
    *(_DWORD *)__int128 buf = 136446210;
    uint64_t v20 = v6;
    _os_log_impl( (void *)&_mh_execute_header,  v5,  OS_LOG_TYPE_DEFAULT,  "Delaying discoverability change event as stack is %{public}s",  buf,  0xCu);
    uint64_t v4 = 0LL;
  }

void sub_100432354( _Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9)
{
}

uint64_t sub_100432384(uint64_t a1, _BYTE *a2)
{
  v5[0] = 0LL;
  v5[1] = 0LL;
  sub_100242F28((uint64_t)v5, a1 + 144);
  *a2 = *(_BYTE *)(a1 + 212);
  sub_100242FAC((uint64_t)v5);
  return 0LL;
}

uint64_t sub_1004323D0(_BYTE *a1, int a2)
{
  v8[0] = 0LL;
  v8[1] = 0LL;
  sub_100242F28((uint64_t)v8, (uint64_t)(a1 + 144));
  if (a2)
  {
    if (os_log_type_enabled((os_log_t)qword_1008F7578, OS_LOG_TYPE_ERROR)) {
      sub_10067E8F8();
    }
  }

  else
  {
    int v4 = a1[214];
    a1[212] = v4;
    int v5 = (os_log_s *)qword_1008F7578;
    if (os_log_type_enabled((os_log_t)qword_1008F7578, OS_LOG_TYPE_DEFAULT))
    {
      char v6 = "discoverable";
      if (!v4) {
        char v6 = "not discoverable";
      }
      *(_DWORD *)__int128 buf = 136446210;
      char v10 = v6;
      _os_log_impl((void *)&_mh_execute_header, v5, OS_LOG_TYPE_DEFAULT, "Local device is now %{public}s", buf, 0xCu);
    }
  }

  a1[208] = 0;
  sub_100242F54((uint64_t)v8);
  if (qword_1008D5F00 != -1) {
    dispatch_once(&qword_1008D5F00, &stru_1008983C0);
  }
  sub_1004099F8((uint64_t)off_1008D5EF8, 2, a2 != 0);
  return sub_100242FAC((uint64_t)v8);
}

void sub_100432530(_Unwind_Exception *exception_object)
{
}

void sub_10043254C(int a1)
{
  uint64_t v2 = sub_100404EB8();
  v3[0] = _NSConcreteStackBlock;
  v3[1] = 3221225472LL;
  void v3[2] = sub_100438DDC;
  void v3[3] = &unk_10087F980;
  int v4 = a1;
  sub_100405384(v2, v3);
}

uint64_t sub_1004325AC(uint64_t a1)
{
  v9[0] = 0LL;
  v9[1] = 0LL;
  sub_100242F28((uint64_t)v9, a1 + 144);
  if (*(_BYTE *)(a1 + 76) && sub_100114358() >= 4)
  {
    sub_100432690();
    sub_100242F54((uint64_t)v9);
    char v8 = 0;
    sub_100242CA4(&v8);
    if (sub_10011EC58((uint64_t)sub_100432EE8, 1u, (uint64_t)byte_1008F0F20, v2, v3, v4, v5, v6)
      && os_log_type_enabled((os_log_t)qword_1008F7578, OS_LOG_TYPE_ERROR))
    {
      sub_10067E974();
    }

    sub_100242CD8(&v8);
  }

  return sub_100242FAC((uint64_t)v9);
}

void sub_100432668( _Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, int a10, __int16 a11, char a12, char a13, char a14)
{
}

void sub_100432690()
{
  char v0 = strlen("iOS");
  byte_1008F0F20[0] = v0 + 1;
  byte_1008F0F21 = 9;
  uint64_t v1 = (v0 + 1);
  memcpy(&unk_1008F0F22, "iOS", v1 - 1);
  uint64_t v2 = v1 + 1;
  dword_1008F1038 = v2;
  LOBYTE(__n[0]) = 0;
  char v49 = 0;
  uint64_t v3 = sub_1002E6E00();
  sub_10002418C(buf, "WiAP");
  sub_10002418C(&__n[1], "enableSink");
  (*(void (**)(uint64_t, uint8_t *, _WORD *, _WORD *))(*(void *)v3 + 72LL))(v3, buf, &__n[1], __n);
  if (SBYTE1(v56) < 0) {
    operator delete(*(void **)&__n[1]);
  }
  if (SBYTE7(v58) < 0) {
    operator delete(*(void **)buf);
  }
  if (LOBYTE(__n[0]))
  {
    uint64_t v4 = sub_1002E6E00();
    sub_10002418C(buf, "CarPlay");
    sub_10002418C(&__n[1], "enableLeCarPlay");
    (*(void (**)(uint64_t, uint8_t *, _WORD *, char *))(*(void *)v4 + 72LL))(v4, buf, &__n[1], &v49);
    if (SBYTE1(v56) < 0) {
      operator delete(*(void **)&__n[1]);
    }
    if (SBYTE7(v58) < 0) {
      operator delete(*(void **)buf);
    }
  }

  int v5 = dword_1008F1038;
  *(_DWORD *)&byte_1008F0F20[dword_1008F1038] = 301990656;
  dword_1008F1038 = v5 + 4;
  uint64_t v6 = sub_1002E6BF0();
  if ((*(unsigned int (**)(uint64_t, uint64_t))(*(void *)v6 + 48LL))(v6, 1LL))
  {
    int v7 = dword_1008F1038;
    *(_WORD *)&byte_1008F0F20[dword_1008F1038] = 4383;
    dword_1008F1038 = v7 + 2;
    char v8 = (os_log_s *)qword_1008F7578;
    if (os_log_type_enabled((os_log_t)qword_1008F7578, OS_LOG_TYPE_INFO))
    {
      *(_WORD *)__int128 buf = 0;
      _os_log_impl((void *)&_mh_execute_header, v8, OS_LOG_TYPE_INFO, "Advertising HFP AG", buf, 2u);
    }
  }

  uint64_t v9 = sub_1002E6BF0();
  (*(void (**)(uint64_t, uint64_t))(*(void *)v9 + 48LL))(v9, 2LL);
  uint64_t v10 = sub_1002E6BF0();
  if ((*(unsigned int (**)(uint64_t, uint64_t))(*(void *)v10 + 48LL))(v10, 16LL))
  {
    int v11 = dword_1008F1038;
    *(_WORD *)&byte_1008F0F20[dword_1008F1038] = 4362;
    dword_1008F1038 = v11 + 2;
    uint64_t v12 = (os_log_s *)qword_1008F7578;
    if (os_log_type_enabled((os_log_t)qword_1008F7578, OS_LOG_TYPE_INFO))
    {
      *(_WORD *)__int128 buf = 0;
      _os_log_impl((void *)&_mh_execute_header, v12, OS_LOG_TYPE_INFO, "Advertising A2DP Source", buf, 2u);
    }
  }

  uint64_t v13 = sub_1002E6BF0();
  if ((*(unsigned int (**)(uint64_t, uint64_t))(*(void *)v13 + 48LL))(v13, 8LL))
  {
    int v14 = dword_1008F1038;
    *(_WORD *)&byte_1008F0F20[dword_1008F1038] = 4364;
    dword_1008F1038 = v14 + 2;
    uint64_t v15 = (os_log_s *)qword_1008F7578;
    if (os_log_type_enabled((os_log_t)qword_1008F7578, OS_LOG_TYPE_INFO))
    {
      *(_WORD *)__int128 buf = 0;
      _os_log_impl((void *)&_mh_execute_header, v15, OS_LOG_TYPE_INFO, "Advertising AVRCP Target", buf, 2u);
    }
  }

  char v48 = 0;
  uint64_t v16 = sub_1002E6E00();
  if ((*(unsigned int (**)(uint64_t))(*(void *)v16 + 8LL))(v16))
  {
    uint64_t v17 = sub_1002E6E00();
    sub_10002418C(buf, "CATT");
    sub_10002418C(&__n[1], "DisableSdp");
    (*(void (**)(uint64_t, uint8_t *, _WORD *, char *))(*(void *)v17 + 72LL))(v17, buf, &__n[1], &v48);
    if (SBYTE1(v56) < 0) {
      operator delete(*(void **)&__n[1]);
    }
    if (SBYTE7(v58) < 0) {
      operator delete(*(void **)buf);
    }
  }

  if (!v48)
  {
    uint64_t v18 = sub_1002E6BF0();
    if ((*(unsigned int (**)(uint64_t, uint64_t))(*(void *)v18 + 48LL))(v18, 0x100000LL))
    {
      int v19 = dword_1008F1038;
      *(_WORD *)&byte_1008F0F20[dword_1008F1038] = 6145;
      dword_1008F1038 = v19 + 2;
      uint64_t v20 = (os_log_s *)qword_1008F7578;
      if (os_log_type_enabled((os_log_t)qword_1008F7578, OS_LOG_TYPE_INFO))
      {
        *(_WORD *)__int128 buf = 0;
        _os_log_impl((void *)&_mh_execute_header, v20, OS_LOG_TYPE_INFO, "Advertising GATT Source", buf, 2u);
      }
    }
  }

  uint64_t v21 = dword_1008F1038;
  byte_1008F0F20[v2] = dword_1008F1038 - v0 - 3;
  *(_DWORD *)&byte_1008F0F20[v21] = 117441793;
  dword_1008F1038 = v21 + 4;
  uint64_t v22 = sub_1002E6BF0();
  int v23 = (*(uint64_t (**)(uint64_t, uint64_t))(*(void *)v22 + 48LL))(v22, 128LL);
  if (LOBYTE(__n[0])) {
    int v24 = 0;
  }
  else {
    int v24 = v23;
  }
  if (v24 == 1)
  {
    char v47 = 0;
    uint64_t v25 = sub_1002E6E00();
    sub_10002418C(buf, "IAP");
    sub_10002418C(&__n[1], "enableIAP");
    (*(void (**)(uint64_t, uint8_t *, _WORD *, char *))(*(void *)v25 + 72LL))(v25, buf, &__n[1], &v47);
    if (SBYTE1(v56) < 0) {
      operator delete(*(void **)&__n[1]);
    }
    if (SBYTE7(v58) < 0) {
      operator delete(*(void **)buf);
    }
    if (v47 || (uint64_t v26 = sub_1002E6BF0(), ((*(uint64_t (**)(uint64_t))(*(void *)v26 + 384LL))(v26) & 1) == 0))
    {
      int v27 = dword_1008F1038;
      uint64_t v28 = &dword_10000000C + 3;
      int v29 = dword_1008F1038;
      do
        byte_1008F0F20[v29++] = byte_1006C301A[v28--];
      while (v28 != -1);
      int v30 = v27 + 16;
      dword_1008F1038 = v27 + 16;
      dword_1008F1038 = v27 + 32;
      int v32 = (os_log_s *)qword_1008F7578;
      if (os_log_type_enabled((os_log_t)qword_1008F7578, OS_LOG_TYPE_INFO))
      {
        *(_WORD *)__int128 buf = 0;
        _os_log_impl((void *)&_mh_execute_header, v32, OS_LOG_TYPE_INFO, "Advertising WiAP", buf, 2u);
      }
    }
  }

  uint64_t v33 = dword_1008F1038;
  byte_1008F0F20[v21 + 2] = dword_1008F1038 - v21 - 3;
  __int128 v87 = 0u;
  __int128 v88 = 0u;
  __int128 v85 = 0u;
  __int128 v86 = 0u;
  __int128 v83 = 0u;
  __int128 v84 = 0u;
  __int128 v81 = 0u;
  __int128 v82 = 0u;
  __int128 v79 = 0u;
  __int128 v80 = 0u;
  __int128 v77 = 0u;
  __int128 v78 = 0u;
  __int128 v75 = 0u;
  __int128 v76 = 0u;
  __int128 v73 = 0u;
  __int128 v74 = 0u;
  __int128 v71 = 0u;
  __int128 v72 = 0u;
  __int128 v69 = 0u;
  __int128 v70 = 0u;
  __int128 v67 = 0u;
  __int128 v68 = 0u;
  __int128 v65 = 0u;
  __int128 v66 = 0u;
  __int128 v63 = 0u;
  __int128 v64 = 0u;
  __int128 v61 = 0u;
  __int128 v62 = 0u;
  __int128 v59 = 0u;
  __int128 v60 = 0u;
  *(_OWORD *)__int128 buf = 0u;
  __int128 v58 = 0u;
  *(_DWORD *)&byte_1008F0F20[v33] = 1275133696;
  __n[0] = 0;
  dword_1008F1038 = v33 + 4;
  if (qword_1008D5F00 != -1) {
    dispatch_once(&qword_1008D5F00, &stru_1008983C0);
  }
  int v34 = sub_1004084B0((uint64_t)off_1008D5EF8, (uint64_t)buf, __n);
  unsigned int v35 = __n[0];
  if (__n[0]) {
    int v36 = v34;
  }
  else {
    int v36 = 0;
  }
  if (v36 == 1)
  {
    int v37 = dword_1008F1038;
    int v38 = dword_1008F1038 + __n[0];
    if (v38 > 240)
    {
      uint64_t v39 = (os_log_s *)qword_1008F7578;
      if (os_log_type_enabled((os_log_t)qword_1008F7578, OS_LOG_TYPE_ERROR))
      {
        *(void *)&__n[1] = __PAIR64__(v35, 67109888);
        __int16 v51 = 1024;
        int v52 = v37;
        __int16 v53 = 1024;
        int v54 = v38;
        __int16 v55 = 1024;
        int v56 = 240;
        _os_log_error_impl( (void *)&_mh_execute_header,  v39,  OS_LOG_TYPE_ERROR,  "EIR data length: %d + constEirLen: %d = %d > %d",  (uint8_t *)&__n[1],  0x1Au);
      }
    }

    else
    {
      memcpy(&byte_1008F0F20[dword_1008F1038], buf, __n[0]);
      dword_1008F1038 = v38;
    }
  }

  if (qword_1008D60D0 != -1) {
    dispatch_once(&qword_1008D60D0, &stru_1008983E0);
  }
  int v40 = sub_10042A1C0((uint64_t)off_1008D60C8, (char *)buf, __n);
  unsigned int v41 = __n[0];
  if (__n[0]) {
    int v42 = v40;
  }
  else {
    int v42 = 0;
  }
  int v43 = dword_1008F1038;
  if (v42 != 1) {
    goto LABEL_63;
  }
  int v44 = dword_1008F1038 + __n[0];
  if (v44 <= 240)
  {
    memcpy(&byte_1008F0F20[dword_1008F1038], buf, __n[0]);
    dword_1008F1038 = v44;
    goto LABEL_64;
  }

  uint64_t v45 = (os_log_s *)qword_1008F7578;
  if (os_log_type_enabled((os_log_t)qword_1008F7578, OS_LOG_TYPE_ERROR))
  {
    *(void *)&__n[1] = __PAIR64__(v41, 67109888);
    __int16 v51 = 1024;
    int v52 = v43;
    __int16 v53 = 1024;
    int v54 = v44;
    __int16 v55 = 1024;
    int v56 = 240;
    _os_log_error_impl( (void *)&_mh_execute_header,  v45,  OS_LOG_TYPE_ERROR,  "Service specific EIR data length: %d + constEirLen: %d = %d > %d",  (uint8_t *)&__n[1],  0x1Au);
    int v44 = dword_1008F1038;
  }

  else
  {
LABEL_63:
    int v44 = v43;
  }

void sub_100432E94( _Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, void *__p, uint64_t a12, int a13, __int16 a14, char a15, char a16, uint64_t a17, void *a18, uint64_t a19, int a20, __int16 a21, char a22, char a23)
{
  if (a16 < 0) {
    operator delete(__p);
  }
  if (a23 < 0) {
    operator delete(a18);
  }
  _Unwind_Resume(exception_object);
}

void sub_100432EE8(int a1)
{
  if (a1)
  {
    if (os_log_type_enabled((os_log_t)qword_1008F7578, OS_LOG_TYPE_ERROR)) {
      sub_10067EA50();
    }
  }

uint64_t sub_100432F34(uint64_t a1)
{
  uint64_t v2 = sub_100404EB8();
  v4[0] = _NSConcreteStackBlock;
  v4[1] = 3221225472LL;
  void v4[2] = sub_100432F98;
  void v4[3] = &unk_10087EB20;
  v4[4] = a1;
  sub_100405384(v2, v4);
  return 0LL;
}

uint64_t sub_100432F98(uint64_t a1)
{
  return sub_1004325AC(*(void *)(a1 + 32));
}

uint64_t sub_100432FA0()
{
  uint64_t v4 = 0LL;
  int v5 = 0LL;
  uint64_t v6 = 0LL;
  if (qword_1008D67A8 != -1) {
    dispatch_once(&qword_1008D67A8, &stru_100898520);
  }
  sub_10052AFEC((uint64_t)off_1008D67A0, &v4);
  if (qword_1008D5F00 != -1) {
    dispatch_once(&qword_1008D5F00, &stru_1008983C0);
  }
  BOOL v0 = sub_10040996C((uint64_t)off_1008D5EF8);
  uint64_t v1 = v4;
  uint64_t v2 = v5;
  if (v4)
  {
    int v5 = v4;
    operator delete(v4);
  }

  return v1 != v2 || v0;
}

void sub_10043305C( _Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void *__p, uint64_t a11)
{
  if (__p) {
    operator delete(__p);
  }
  _Unwind_Resume(exception_object);
}

uint64_t sub_100433078(uint64_t a1, _BYTE *a2)
{
  v5[0] = 0LL;
  v5[1] = 0LL;
  sub_100242F28((uint64_t)v5, a1 + 144);
  *a2 = *(_BYTE *)(a1 + 215);
  sub_100242FAC((uint64_t)v5);
  return 0LL;
}

uint64_t sub_1004330C4(uint64_t a1, int a2, int a3)
{
  v9[0] = 0LL;
  v9[1] = 0LL;
  sub_100242F28((uint64_t)v9, a1 + 144);
  if (a2)
  {
    if (os_log_type_enabled((os_log_t)qword_1008F7578, OS_LOG_TYPE_ERROR)) {
      sub_10067EAB0();
    }
  }

  else
  {
    *(_BYTE *)(a1 + 215) = a3;
    uint64_t v6 = (os_log_s *)qword_1008F7578;
    if (os_log_type_enabled((os_log_t)qword_1008F7578, OS_LOG_TYPE_DEFAULT))
    {
      int v7 = "not connectable";
      if (a3) {
        int v7 = "connectable";
      }
      *(_DWORD *)__int128 buf = 136446210;
      int v11 = v7;
      _os_log_impl((void *)&_mh_execute_header, v6, OS_LOG_TYPE_DEFAULT, "Local device is now %{public}s", buf, 0xCu);
    }
  }

  *(_BYTE *)(a1 + 20sub_100242E28(v1 + 8) = 0;
  sub_100242F54((uint64_t)v9);
  if (qword_1008D5F00 != -1) {
    dispatch_once(&qword_1008D5F00, &stru_1008983C0);
  }
  sub_1004099F8((uint64_t)off_1008D5EF8, 3, a2 != 0);
  return sub_100242FAC((uint64_t)v9);
}

void sub_100433224(_Unwind_Exception *exception_object)
{
}

uint64_t sub_100433240(uint64_t a1)
{
  v18[0] = 0LL;
  v18[1] = 0LL;
  sub_100242F28((uint64_t)v18, a1 + 144);
  int v2 = *(_DWORD *)(a1 + 72);
  if (v2 != 2)
  {
    if (!v2)
    {
      if (os_log_type_enabled((os_log_t)qword_1008F7578, OS_LOG_TYPE_ERROR)) {
        sub_10067EBA8();
      }
      sub_100242F54((uint64_t)v18);
      if (qword_1008D5F00 != -1) {
        dispatch_once(&qword_1008D5F00, &stru_1008983C0);
      }
      int v3 = 111;
      goto LABEL_8;
    }

    if (!*(_BYTE *)(a1 + 208))
    {
      int v8 = *(unsigned __int8 *)(a1 + 215);
      if (v8 != *(unsigned __int8 *)(a1 + 216))
      {
        buf[0] = 0;
        sub_100242CA4(buf);
        int v17 = sub_1001152C8( (void (*)(int))sub_100433550,  *(unsigned __int8 *)(a1 + 216),  v11,  v12,  v13,  v14,  v15,  v16);
        sub_100242CD0(buf);
        if (v17)
        {
          if (os_log_type_enabled((os_log_t)qword_1008F7578, OS_LOG_TYPE_ERROR)) {
            sub_10067EB2C();
          }
          sub_100242F54((uint64_t)v18);
          if (qword_1008D5F00 != -1) {
            dispatch_once(&qword_1008D5F00, &stru_1008983C0);
          }
          sub_1004099F8((uint64_t)off_1008D5EF8, 3, 1);
        }

        else
        {
          *(_BYTE *)(a1 + 20sub_100242E28(v1 + 8) = 1;
        }

        sub_100242CD8(buf);
        goto LABEL_9;
      }

      uint64_t v9 = (os_log_s *)qword_1008F7578;
      if (os_log_type_enabled((os_log_t)qword_1008F7578, OS_LOG_TYPE_DEFAULT))
      {
        uint64_t v10 = "connectable";
        if (!v8) {
          uint64_t v10 = "not connectable";
        }
        *(_DWORD *)__int128 buf = 136446210;
        uint64_t v20 = v10;
        _os_log_impl( (void *)&_mh_execute_header,  v9,  OS_LOG_TYPE_DEFAULT,  "Local device state is already %{public}s",  buf,  0xCu);
      }

      sub_100242F54((uint64_t)v18);
      if (qword_1008D5F00 != -1) {
        dispatch_once(&qword_1008D5F00, &stru_1008983C0);
      }
      if (*(_BYTE *)(a1 + 215)) {
        int v3 = 120;
      }
      else {
        int v3 = 121;
      }
LABEL_8:
      sub_1004099F8((uint64_t)off_1008D5EF8, 3, v3);
LABEL_9:
      uint64_t v4 = 1LL;
      goto LABEL_15;
    }
  }

  int v5 = (os_log_s *)qword_1008F7578;
  uint64_t v4 = 0LL;
  if (os_log_type_enabled((os_log_t)qword_1008F7578, OS_LOG_TYPE_DEFAULT))
  {
    uint64_t v6 = "busy";
    if (v2 == 2) {
      uint64_t v6 = "in flux";
    }
    *(_DWORD *)__int128 buf = 136446210;
    uint64_t v20 = v6;
    _os_log_impl( (void *)&_mh_execute_header,  v5,  OS_LOG_TYPE_DEFAULT,  "Delaying connectability change event as stack is %{public}s",  buf,  0xCu);
    uint64_t v4 = 0LL;
  }

void sub_100433520( _Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9)
{
}

void sub_100433550(int a1, char a2)
{
  uint64_t v4 = sub_100404EB8();
  v5[0] = _NSConcreteStackBlock;
  v5[1] = 3221225472LL;
  void v5[2] = sub_100438EAC;
  void v5[3] = &unk_100898380;
  int v6 = a1;
  char v7 = a2;
  sub_100405384(v4, v5);
}

uint64_t sub_1004335B8(int a1, unsigned int a2)
{
  v10[0] = 0LL;
  v10[1] = 0LL;
  sub_100242F28((uint64_t)v10, (uint64_t)&unk_1008F73D8);
  if (a1)
  {
    if (os_log_type_enabled((os_log_t)qword_1008F7578, OS_LOG_TYPE_ERROR))
    {
      uint64_t v4 = sub_1002E6E9C();
      int v5 = sub_1002CE354(v4, a2);
      sub_10067EC20((uint64_t)v5, (uint64_t)v11);
    }
  }

  else if (os_log_type_enabled((os_log_t)qword_1008F7578, OS_LOG_TYPE_DEBUG))
  {
    uint64_t v6 = sub_1002E6E9C();
    char v7 = sub_1002CE354(v6, a2);
    sub_10067EBD4((uint64_t)v7, (uint64_t)v11);
  }

  uint64_t v8 = sub_1002E6E9C();
  sub_1002D06F4(v8, a2);
  dword_1008F7478 = a1;
  sub_1002431FC(&stru_1008F7448);
  return sub_100242FAC((uint64_t)v10);
}

void sub_1004336B4( _Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9)
{
}

uint64_t sub_1004336D8(uint64_t a1, uint64_t a2)
{
  v28[0] = 0LL;
  v28[1] = 0LL;
  sub_100242F28((uint64_t)v28, (uint64_t)&unk_1008F73D8);
  uint64_t v4 = sub_1002E6E9C();
  if (sub_1002CF3FC(v4, a2))
  {
    if (!sub_1002431A4(&stru_1008F7448, v28, 0x3A98uLL))
    {
      if ((sub_1000B1BD0() & 1) == 0 && *(_DWORD *)(a1 + 368) == 0xFFFF)
      {
        if (os_log_type_enabled((os_log_t)qword_1008F7578, OS_LOG_TYPE_ERROR))
        {
          uint64_t v12 = sub_1002E6E9C();
          uint64_t v13 = sub_1002CE354(v12, a2);
          sub_10067ECA0((uint64_t)v13, (uint64_t)v45);
        }

        __int128 v43 = 0u;
        __int128 v44 = 0u;
        __int128 v41 = 0u;
        __int128 v42 = 0u;
        __int128 v39 = 0u;
        __int128 v40 = 0u;
        __int128 v37 = 0u;
        __int128 v38 = 0u;
        __int128 v35 = 0u;
        __int128 v36 = 0u;
        __int128 v33 = 0u;
        __int128 v34 = 0u;
        __int128 v31 = 0u;
        __int128 v32 = 0u;
        *(_OWORD *)__int128 buf = 0u;
        __int128 v30 = 0u;
        char v27 = 0;
        sub_100242CA4(&v27);
        uint64_t v14 = sub_1002E6E9C();
        uint64_t v15 = sub_1002CE354(v14, a2);
        sub_1001EE0BC( (uint64_t)buf,  256,  (uint64_t)"VSC stall detected, %s (0x%x)",  v16,  v17,  v18,  v19,  v20,  (uint64_t)v15);
        sub_1000BAAF0((const char *)buf);
        sub_100242CD0(&v27);
        if (sub_1002E8D94())
        {
          uint64_t v23 = sub_1002E8D94();
          __p[0] = 0LL;
          __p[1] = 0LL;
          uint64_t v26 = 0LL;
          (*(void (**)(uint64_t, uint64_t, uint64_t, void **))(*(void *)v23 + 104LL))(v23, 3LL, a2, __p);
          if (SHIBYTE(v26) < 0) {
            operator delete(__p[0]);
          }
        }

        sub_100242F54((uint64_t)v28);
        uint64_t v21 = sub_1002E6E9C();
        uint64_t v22 = (char *)sub_1002CE354(v21, a2);
        sub_10002418C(&v24, v22);
        sub_1004319D0(a1, 3602, &v24);
      }

      if (os_log_type_enabled((os_log_t)qword_1008F7578, OS_LOG_TYPE_ERROR))
      {
        uint64_t v5 = sub_1002E6E9C();
        uint64_t v6 = sub_1002CE354(v5, a2);
        sub_10067EC68((uint64_t)v6, (uint64_t)buf);
      }
    }
  }

  else
  {
    char v7 = (os_log_s *)qword_1008F7578;
    if (os_log_type_enabled((os_log_t)qword_1008F7578, OS_LOG_TYPE_INFO))
    {
      uint64_t v8 = sub_1002E6E9C();
      uint64_t v9 = sub_1002CE354(v8, a2);
      *(_DWORD *)__int128 buf = 136446210;
      *(void *)&uint8_t buf[4] = v9;
      _os_log_impl( (void *)&_mh_execute_header,  v7,  OS_LOG_TYPE_INFO,  "%{public}s completed prior to waiting",  buf,  0xCu);
    }
  }

  uint64_t v10 = dword_1008F7478;
  sub_100242FAC((uint64_t)v28);
  return v10;
}

void sub_100433940( _Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, void *__p, uint64_t a13, int a14, __int16 a15, char a16, char a17, uint64_t a18, uint64_t a19, int a20, __int16 a21, char a22, char a23, int a24, __int16 a25, char a26, char a27, char a28)
{
  if (a17 < 0) {
    operator delete(__p);
  }
  sub_100242CD8(&a27);
  sub_100242FAC((uint64_t)&a28);
  _Unwind_Resume(a1);
}

void sub_1004339A8(uint64_t a1, uint64_t a2)
{
  v20[0] = 0LL;
  v20[1] = 0LL;
  sub_100242F28((uint64_t)v20, a1 + 144);
  __int128 v19 = 0uLL;
  sub_10040CB94(&v19, 17);
  *(void *)((char *)&v19 + 4) = 0xDA20000003ALL;
  HIDWORD(v19) = a2;
  switch((int)a2)
  {
    case 240:
      uint64_t v4 = "received invalid data from BT chip";
      int v5 = 643;
      break;
    case 241:
      uint64_t v4 = "Timed out while waiting for data from BT Chip";
      int v5 = 644;
      break;
    case 242:
      uint64_t v4 = "Invalid receive state from BT Chip";
      int v5 = 645;
      break;
    case 243:
      uint64_t v4 = "Timed out in invalid receive state from BT Chip";
      int v5 = 646;
      break;
    case 244:
      uint64_t v4 = "Invalid packet length received from BT Chip";
      int v5 = 647;
      break;
    case 245:
      uint64_t v4 = "Core dump";
      int v5 = 3703;
      break;
    default:
      if ((_DWORD)a2)
      {
        if ((_DWORD)a2 == 8)
        {
          uint64_t v4 = "Bt chip timed out while trying to transfer data to SPMI master";
          int v5 = 652;
        }

        else
        {
          uint64_t v4 = "unknown";
          int v5 = 648;
        }
      }

      else
      {
        uint64_t v4 = "BT chip received invalid data from iOS";
        int v5 = 642;
      }

      break;
  }

  uint64_t v6 = (os_log_s *)qword_1008F7578;
  if (os_log_type_enabled((os_log_t)qword_1008F7578, OS_LOG_TYPE_ERROR))
  {
    *(_DWORD *)__int128 buf = 136446466;
    *(void *)&uint8_t buf[4] = v4;
    __int16 v22 = 1024;
    int v23 = a2;
    _os_log_error_impl( (void *)&_mh_execute_header,  v6,  OS_LOG_TYPE_ERROR,  "Hardware error - %{public}s (%u)",  buf,  0x12u);
  }

  int v7 = *(unsigned __int8 *)(a1 + 210);
  if (*(_BYTE *)(a1 + 210) || *(_BYTE *)(a1 + 211))
  {
    uint64_t v8 = (os_log_s *)qword_1008F7578;
    if (os_log_type_enabled((os_log_t)qword_1008F7578, OS_LOG_TYPE_ERROR))
    {
      uint64_t v9 = "DUT";
      if (!v7) {
        uint64_t v9 = "LE Test";
      }
      *(_DWORD *)__int128 buf = 136446210;
      *(void *)&uint8_t buf[4] = v9;
      _os_log_error_impl( (void *)&_mh_execute_header,  v8,  OS_LOG_TYPE_ERROR,  "Can not restore state while in %{public}s mode",  buf,  0xCu);
    }
  }

  if ((_DWORD)a2 == 245)
  {
    if (sub_1002E8D94())
    {
      uint64_t v14 = sub_1002E8D94();
      sub_10002418C(buf, v4);
      (*(void (**)(uint64_t, uint64_t, void, _BYTE *))(*(void *)v14 + 104LL))(v14, 1LL, 0LL, buf);
      if (v24 < 0) {
        operator delete(*(void **)buf);
      }
    }

    uint64_t v10 = sub_1002E6E00();
    (*(void (**)(uint64_t, const char *))(*(void *)v10 + 496LL))(v10, "UART core dump");
    uint64_t v11 = sub_1002E6E00();
    uint64_t v12 = *(unsigned int *)(a1 + 368);
    if (*(char *)(a1 + 399) < 0)
    {
      sub_100024238(&__dst, *(void **)(a1 + 376), *(void *)(a1 + 384));
    }

    else
    {
      __int128 __dst = *(_OWORD *)(a1 + 376);
      uint64_t v18 = *(void *)(a1 + 392);
    }

    sub_1004FB370(v11, v12, (uint64_t)&__dst, 1);
  }

  if (sub_1002E8D94())
  {
    uint64_t v15 = sub_1002E8D94();
    sub_10002418C(buf, v4);
    (*(void (**)(uint64_t, void, uint64_t, _BYTE *))(*(void *)v15 + 104LL))(v15, 0LL, a2, buf);
    if (v24 < 0) {
      operator delete(*(void **)buf);
    }
  }

  uint64_t v13 = sub_1002E8D94();
  (*(void (**)(uint64_t, __int128 *))(*(void *)v13 + 40LL))(v13, &v19);
  sub_100242F54((uint64_t)v20);
  sub_10002418C(&v16, "");
  sub_1004319D0(a1, v5, &v16);
}

void sub_100433CF0( _Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void *__p, uint64_t a11, int a12, __int16 a13, char a14, char a15, uint64_t a16, uint64_t a17, int a18, __int16 a19, char a20, char a21, uint64_t a22, uint64_t a23, uint64_t a24, char a25, uint64_t a26, uint64_t a27, uint64_t a28, int a29, __int16 a30, char a31, char a32)
{
  if (a15 < 0) {
    operator delete(__p);
  }
  sub_100242FAC((uint64_t)&a25);
  _Unwind_Resume(a1);
}

float sub_100433D5C(uint64_t a1)
{
  if (qword_1008D60B0 != -1) {
    dispatch_once(&qword_1008D60B0, &stru_1008983A0);
  }
  return sub_100433DB4( (uint64_t)off_1008D60A8,  *(_DWORD *)(a1 + 32),  *(unsigned __int16 *)(a1 + 36),  *(unsigned __int8 *)(a1 + 38));
}

float sub_100433DB4(uint64_t a1, int a2, int a3, int a4)
{
  int v6 = *(_DWORD *)(a1 + 72);
  if (v6 == 1)
  {
    if (sub_1000B0174())
    {
      __int128 v35 = 0u;
      __int128 v36 = 0u;
      __int128 v33 = 0u;
      __int128 v34 = 0u;
      __int128 v31 = 0u;
      __int128 v32 = 0u;
      __int128 v29 = 0u;
      __int128 v30 = 0u;
      __int128 v27 = 0u;
      __int128 v28 = 0u;
      __int128 v25 = 0u;
      __int128 v26 = 0u;
      __int128 v23 = 0u;
      __int128 v24 = 0u;
      *(_OWORD *)__int128 buf = 0u;
      __int128 v22 = 0u;
      char v20 = 0;
      sub_100242CA4(&v20);
      uint64_t v10 = sub_10016F5D4(a3);
      sub_1001EE0BC((uint64_t)buf, 256, (uint64_t)"HCI stall detected, %s (0x%x)", v11, v12, v13, v14, v15, (uint64_t)v10);
      sub_1000BAAF0((const char *)buf);
      sub_100242CD0(&v20);
      sub_100242CD8(&v20);
    }

    if (sub_1002E8D94())
    {
      uint64_t v17 = sub_1002E8D94();
      memset(buf, 0, sizeof(buf));
      *(void *)&__int128 v22 = 0LL;
      (*(void (**)(uint64_t, uint64_t, void, uint8_t *))(*(void *)v17 + 104LL))( v17,  5LL,  a3 | (a4 << 16),  buf);
      if (SBYTE7(v22) < 0) {
        operator delete(*(void **)buf);
      }
    }

    __int128 v16 = (char *)sub_10016F5D4(a3);
    sub_10002418C(&v19, v16);
    sub_1004319D0(a1, 621, &v19);
  }

  uint64_t v8 = (os_log_s *)qword_1008F7578;
  if (os_log_type_enabled((os_log_t)qword_1008F7578, OS_LOG_TYPE_ERROR))
  {
    *(_DWORD *)__int128 buf = 67109888;
    *(_DWORD *)&uint8_t buf[4] = v6;
    *(_WORD *)&uint8_t buf[8] = 1024;
    *(_DWORD *)&buf[10] = a3;
    *(_WORD *)&_BYTE buf[14] = 1024;
    LODWORD(v22) = a4;
    WORD2(v22) = 1024;
    *(_DWORD *)((char *)&v22 + 6) = a2;
    _os_log_error_impl( (void *)&_mh_execute_header,  v8,  OS_LOG_TYPE_ERROR,  "HCI event timeout occured during state %d on opcode 0x%x with subopcode 0x%x due to %{bluetooth:OI_STATUS}u, ignoring",  buf,  0x1Au);
  }

  return result;
}

void sub_100433F74( _Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, int a15, __int16 a16, char a17, char a18, int a19, __int16 a20, char a21, char a22, void *__p, uint64_t a24, int a25, __int16 a26, char a27, char a28)
{
  if (a28 < 0) {
    operator delete(__p);
  }
  _Unwind_Resume(exception_object);
}

void sub_100433FBC(uint64_t a1, uint64_t a2, int a3, uint64_t a4)
{
  uint64_t v7 = sub_1000FCD0C();
  int v8 = *(char *)(a4 + 23);
  if ((_DWORD)v7 == 7 && a3)
  {
    if (v8 < 0) {
      a4 = *(void *)a4;
    }
    sub_100431EEC(v7, 11, 0, a4);
    sub_10002418C(&v9, "chip boot failure");
    sub_1004319D0(a1, 1214, &v9);
  }

  if (v8 < 0) {
    a4 = *(void *)a4;
  }
  sub_100431EEC(v7, 12, 0, a4);
}

void sub_100434054( _Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void *__p, uint64_t a11, int a12, __int16 a13, char a14, char a15)
{
  if (a15 < 0) {
    operator delete(__p);
  }
  _Unwind_Resume(exception_object);
}

uint64_t sub_100434070(uint64_t a1)
{
  return *(unsigned int *)(a1 + 332);
}

uint64_t sub_100434078(uint64_t a1)
{
  return *(void *)(a1 + 336);
}

uint64_t sub_100434080(const __CFString *a1, UInt8 **a2, _WORD *a3)
{
  int v6 = IOServiceNameMatching("bluetooth");
  if (!v6) {
    return 131LL;
  }
  io_service_t MatchingService = IOServiceGetMatchingService(kIOMainPortDefault, v6);
  if (!MatchingService) {
    return 131LL;
  }
  io_object_t v8 = MatchingService;
  __int128 v9 = (const __CFData *)IORegistryEntrySearchCFProperty(MatchingService, "IODeviceTree", a1, kCFAllocatorDefault, 1u);
  if (v9)
  {
    uint64_t v10 = v9;
    CFTypeID TypeID = CFDataGetTypeID();
    if (TypeID == CFGetTypeID(v10))
    {
      CFIndex Length = CFDataGetLength(v10);
      CFIndex v13 = Length;
      if (Length)
      {
        uint64_t v14 = (UInt8 *)malloc(Length);
        *a2 = v14;
        v17.location = 0LL;
        v17.size_t length = v13;
        CFDataGetBytes(v10, v17, v14);
      }

      *a3 = v13;
    }

    CFRelease(v10);
    uint64_t v15 = 0LL;
  }

  else
  {
    uint64_t v15 = 131LL;
  }

  IOObjectRelease(v8);
  return v15;
}

uint64_t sub_10043417C(const void **a1, void *a2, uint64_t a3)
{
  uint64_t v10 = 0LL;
  int v5 = (const __CFDictionary *)AMFDRSealingMapCopyLocalDictForClass(a3, 0LL, &v10);
  int v6 = v5;
  if (a1 && v5)
  {
    Value = CFDictionaryGetValue(v5, @"BTBF");
    *a1 = Value;
    if (!Value) {
      goto LABEL_9;
    }
LABEL_7:
    CFRetain(Value);
    uint64_t v8 = 0LL;
    if (!a2) {
      goto LABEL_12;
    }
    goto LABEL_10;
  }

  if (a1)
  {
    Value = *a1;
    if (*a1) {
      goto LABEL_7;
    }
  }

uint64_t sub_10043422C(UInt8 **a1, _WORD *a2)
{
  CFDataRef theData = 0LL;
  CFTypeRef cf = 0LL;
  uint64_t v4 = (os_log_s *)qword_1008F7578;
  if (os_log_type_enabled((os_log_t)qword_1008F7578, OS_LOG_TYPE_DEFAULT))
  {
    *(_WORD *)__int128 buf = 0;
    _os_log_impl((void *)&_mh_execute_header, v4, OS_LOG_TYPE_DEFAULT, "Loading calibration of FATP stage", buf, 2u);
  }

  int v5 = (os_log_s *)qword_1008F7578;
  if (os_log_type_enabled((os_log_t)qword_1008F7578, OS_LOG_TYPE_DEFAULT))
  {
    *(_WORD *)__int128 buf = 0;
    _os_log_impl( (void *)&_mh_execute_header,  v5,  OS_LOG_TYPE_DEFAULT,  "FATP stage calibration not found, looking for Golden calibration from SMT",  buf,  2u);
  }

  if (cf) {
    CFRelease(cf);
  }
  uint64_t v6 = sub_10043417C((const void **)&theData, &cf, (uint64_t)@"0BCl");
  if ((_DWORD)v6)
  {
    uint64_t v7 = v6;
    uint64_t v8 = (__CFError *)cf;
    if (cf)
    {
      __int128 v9 = (os_log_s *)qword_1008F7578;
      if (os_log_type_enabled((os_log_t)qword_1008F7578, OS_LOG_TYPE_DEFAULT))
      {
        CFIndex Code = CFErrorGetCode(v8);
        *(_DWORD *)__int128 buf = 134217984;
        CFIndex v19 = Code;
        _os_log_impl((void *)&_mh_execute_header, v9, OS_LOG_TYPE_DEFAULT, "Loading FDR data got error %ld", buf, 0xCu);
      }
    }
  }

  else
  {
LABEL_12:
    CFIndex Length = CFDataGetLength(theData);
    CFIndex v12 = Length;
    if (Length)
    {
      CFIndex v13 = (UInt8 *)malloc(Length);
      *a1 = v13;
      v20.location = 0LL;
      v20.size_t length = v12;
      CFDataGetBytes(theData, v20, v13);
      uint64_t v14 = (os_log_s *)qword_1008F7578;
      if (os_log_type_enabled((os_log_t)qword_1008F7578, OS_LOG_TYPE_DEFAULT))
      {
        *(_DWORD *)__int128 buf = 134217984;
        CFIndex v19 = v12;
        _os_log_impl((void *)&_mh_execute_header, v14, OS_LOG_TYPE_DEFAULT, "btbf length %ld", buf, 0xCu);
      }
    }

    uint64_t v7 = 0LL;
    *a2 = v12;
  }

  if (theData) {
    CFRelease(theData);
  }
  if (cf) {
    CFRelease(cf);
  }
  return v7;
}

uint64_t sub_10043444C(uint64_t a1, _WORD *a2)
{
  v14[0] = 0LL;
  v14[1] = 0LL;
  uint64_t v15 = 0LL;
  int v13 = 0;
  uint64_t v4 = (os_log_s *)qword_1008F7578;
  if (os_log_type_enabled((os_log_t)qword_1008F7578, OS_LOG_TYPE_DEFAULT))
  {
    *(_WORD *)__int128 buf = 0;
    _os_log_impl( (void *)&_mh_execute_header,  v4,  OS_LOG_TYPE_DEFAULT,  "Looking for fail safe calibration file",  buf,  2u);
  }

  uint64_t v5 = sub_1002E8D54();
  sub_10002418C(__p, ".msf");
  uint64_t v6 = (*(uint64_t (**)(uint64_t, void **, uint64_t, int *, void **))(*(void *)v5 + 408LL))( v5,  __p,  a1,  &v13,  v14);
  uint64_t v7 = v6;
  if (v11 < 0)
  {
    operator delete(__p[0]);
    if ((_DWORD)v7) {
      goto LABEL_5;
    }
  }

  else if ((_DWORD)v6)
  {
LABEL_5:
    if (os_log_type_enabled((os_log_t)qword_1008F7578, OS_LOG_TYPE_ERROR)) {
      sub_10067ECD8();
    }
    uint64_t v7 = 131LL;
    goto LABEL_11;
  }

  *a2 = v13;
  uint64_t v8 = (os_log_s *)qword_1008F7578;
  if (os_log_type_enabled((os_log_t)qword_1008F7578, OS_LOG_TYPE_DEFAULT))
  {
    *(_WORD *)__int128 buf = 0;
    _os_log_impl((void *)&_mh_execute_header, v8, OS_LOG_TYPE_DEFAULT, "Found fail safe calibration file", buf, 2u);
    uint64_t v7 = 0LL;
  }

void sub_1004345A4( _Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void *__p, uint64_t a11, int a12, __int16 a13, char a14, char a15, uint64_t a16, void *a17, uint64_t a18, int a19, __int16 a20, char a21, char a22)
{
  if (a15 < 0) {
    operator delete(__p);
  }
  if (a22 < 0) {
    operator delete(a17);
  }
  _Unwind_Resume(exception_object);
}

uint64_t sub_1004345D8(char *a1, uint64_t a2, unsigned int a3)
{
  unsigned int v4 = a2;
  uint64_t v5 = a1;
  size_t v6 = a3;
  __chkstk_darwin(a1, a2);
  uint64_t v8 = &buf[-v7];
  bzero(&buf[-v7], v6);
  __int128 v9 = (os_log_s *)qword_1008F7578;
  if (os_log_type_enabled((os_log_t)qword_1008F7578, OS_LOG_TYPE_DEFAULT))
  {
    *(_DWORD *)__int128 buf = 67109120;
    unsigned int v22 = v4;
    _os_log_impl((void *)&_mh_execute_header, v9, OS_LOG_TYPE_DEFAULT, "Calibration/Regulatory data size %d", buf, 8u);
  }

  int v10 = v4 % a3;
  char v11 = v4 / a3 - ((unsigned __int16)(v4 % a3) == 0);
  size_t v12 = (unsigned __int16)(v4 % a3);
  size_t v13 = v6 - (unsigned __int16)v10;
  uint64_t v14 = &v8[(unsigned __int16)v10];
  while (1)
  {
    size_t v15 = v6;
    if (!v11)
    {
      bzero(v14, v13);
      size_t v15 = v12;
    }

    memcpy(v8, v5, v15);
    uint64_t v16 = *(void *)sub_1002E6E9C();
    uint64_t v17 = a3 == 230 ? (*(uint64_t (**)(void))(v16 + 3576))() : (*(uint64_t (**)(void))(v16 + 3592))();
    uint64_t v18 = v17;
    if ((_DWORD)v17) {
      break;
    }
    int v19 = v11--;
    v5 += v6;
    if (v19 < 1) {
      return 0LL;
    }
  }

  if (os_log_type_enabled((os_log_t)qword_1008F7578, OS_LOG_TYPE_ERROR)) {
    sub_10067ED04();
  }
  return v18;
}

uint64_t sub_1004347C0(uint64_t a1)
{
  int v2 = (void *)CFPreferencesCopyAppValue(@"GlobalAllowSoundProfile", @"com.apple.BTServer");
  unsigned __int8 v3 = 1;
  *(_BYTE *)(a1 + 472) = 1;
  if (v2)
  {
    else {
      unsigned __int8 v3 = 2;
    }
    *(_BYTE *)(a1 + 472) = v3;
  }

  return v3;
}

void sub_100434830(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

uint64_t sub_100434840(uint64_t a1, int a2)
{
  *(_BYTE *)(a1 + 472) = a2;
  unsigned __int8 v3 = (os_log_s *)qword_1008F7578;
  if (os_log_type_enabled((os_log_t)qword_1008F7578, OS_LOG_TYPE_DEFAULT))
  {
    v6[0] = 67109120;
    v6[1] = a2;
    _os_log_impl( (void *)&_mh_execute_header,  v3,  OS_LOG_TYPE_DEFAULT,  "Spatial Spatial Profile Global Allowed Written:  %d",  (uint8_t *)v6,  8u);
  }

  if (a2 == 1) {
    unsigned int v4 = @"on";
  }
  else {
    unsigned int v4 = @"off";
  }
  CFPreferencesSetAppValue(@"GlobalAllowSoundProfile", v4, @"com.apple.BTServer");
  return CFPreferencesAppSynchronize(@"com.apple.BTServer");
}

uint64_t sub_100434920(uint64_t a1, int a2)
{
  v5[0] = 0LL;
  v5[1] = 0LL;
  sub_100242F28((uint64_t)v5, a1 + 408);
  return sub_100242FAC((uint64_t)v5);
}

void sub_100434978( _Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9)
{
}

uint64_t sub_10043498C(uint64_t a1)
{
  int v2 = (void *)CFPreferencesCopyAppValue(@"GlobalAllowSpatial", @"com.apple.BTServer");
  if (v2)
  {
    else {
      uint64_t v3 = 2LL;
    }
    *(_BYTE *)(a1 + 40sub_100414D2C(qword_1008F72C0, 0) = v3;
  }

  else
  {
    uint64_t v3 = *(unsigned __int8 *)(a1 + 400);
  }

  return v3;
}

void sub_100434A00(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

uint64_t sub_100434A10(uint64_t a1, int a2)
{
  v5[0] = 0LL;
  v5[1] = 0LL;
  sub_100242F28((uint64_t)v5, a1 + 408);
  return sub_100242FAC((uint64_t)v5);
}

void sub_100434A68( _Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9)
{
}

uint64_t sub_100434A7C(uint64_t a1, int a2)
{
  *(_BYTE *)(a1 + 40sub_100414D2C(qword_1008F72C0, 0) = a2;
  uint64_t v3 = (os_log_s *)qword_1008F7578;
  if (os_log_type_enabled((os_log_t)qword_1008F7578, OS_LOG_TYPE_DEFAULT))
  {
    v6[0] = 67109120;
    v6[1] = a2;
    _os_log_impl( (void *)&_mh_execute_header,  v3,  OS_LOG_TYPE_DEFAULT,  "Spatial Audio Global Allowed Written:  %d",  (uint8_t *)v6,  8u);
  }

  if (a2 == 1) {
    unsigned int v4 = @"on";
  }
  else {
    unsigned int v4 = @"off";
  }
  CFPreferencesSetAppValue(@"GlobalAllowSpatial", v4, @"com.apple.BTServer");
  return CFPreferencesAppSynchronize(@"com.apple.BTServer");
}

void sub_100434B5C(uint64_t a1, void *a2, uint64_t a3, uint64_t a4)
{
  id v7 = a2;
  uint64_t v8 = (os_log_s *)qword_1008F7578;
  if (v7)
  {
    if (os_log_type_enabled((os_log_t)qword_1008F7578, OS_LOG_TYPE_DEFAULT))
    {
      *(_DWORD *)__int128 buf = 138412802;
      id v18 = v7;
      __int16 v19 = 1024;
      int v20 = a3;
      __int16 v21 = 1024;
      int v22 = a4;
      _os_log_impl( (void *)&_mh_execute_header,  v8,  OS_LOG_TYPE_DEFAULT,  "StackManager setSpatialModeWithBundleID：%@, mode:%u, headtrack:%u",  buf,  0x18u);
    }

    if (!*(void *)(a1 + 480))
    {
      __int128 v9 = sub_100434D44(a1);
      uint64_t v10 = objc_claimAutoreleasedReturnValue(v9);
      char v11 = *(void **)(a1 + 480);
      *(void *)(a1 + 48sub_100414D2C(qword_1008F72C0, 0) = v10;
    }

    size_t v12 = (void *)objc_claimAutoreleasedReturnValue( +[NSNumber numberWithBool:]( &OBJC_CLASS___NSNumber,  "numberWithBool:",  a4,  @"kCBMsgArgParamSpatialHeadTracking"));
    v15[1] = @"kCBMsgArgParamSpatialMode";
    v16[0] = v12;
    size_t v13 = (void *)objc_claimAutoreleasedReturnValue(+[NSNumber numberWithUnsignedInt:](&OBJC_CLASS___NSNumber, "numberWithUnsignedInt:", a3));
    v16[1] = v13;
    uint64_t v14 = (void *)objc_claimAutoreleasedReturnValue( +[NSDictionary dictionaryWithObjects:forKeys:count:]( &OBJC_CLASS___NSDictionary,  "dictionaryWithObjects:forKeys:count:",  v16,  v15,  2LL));

    [*(id *)(a1 + 480) setObject:v14 forKey:v7];
    sub_10043539C(a1, *(void **)(a1 + 480));
  }

  else if (os_log_type_enabled((os_log_t)qword_1008F7578, OS_LOG_TYPE_ERROR))
  {
    sub_10067ED64();
  }
}

void sub_100434D04(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

NSMutableDictionary *sub_100434D44(uint64_t a1)
{
  v49[0] = 0LL;
  v49[1] = 0LL;
  sub_100242F28((uint64_t)v49, a1 + 408);
  uint64_t v1 = *(void **)(a1 + 480);
  if (v1)
  {
    int v2 = v1;
    goto LABEL_35;
  }

  __int128 v35 = (void *)CFPreferencesCopyAppValue(@"SpatialModeDict", @"com.apple.BTServer");
  id v34 = [v35 mutableCopy];
  if (v34)
  {
    __int128 v38 = objc_alloc_init(&OBJC_CLASS___NSMutableDictionary);
    __int128 v47 = 0u;
    __int128 v48 = 0u;
    __int128 v45 = 0u;
    __int128 v46 = 0u;
    id v3 = v34;
    id v4 = [v3 countByEnumeratingWithState:&v45 objects:v57 count:16];
    if (!v4)
    {
      char v37 = 0;
      goto LABEL_24;
    }

    char v37 = 0;
    uint64_t v39 = *(void *)v46;
    while (1)
    {
      id v40 = v4;
      for (uint64_t i = 0LL; i != v40; uint64_t i = (char *)i + 1)
      {
        if (*(void *)v46 != v39) {
          objc_enumerationMutation(v3);
        }
        uint64_t v6 = *(void *)(*((void *)&v45 + 1) + 8LL * (void)i);
        id v7 = (void *)objc_claimAutoreleasedReturnValue([v3 objectForKeyedSubscript:v6]);
        uint64_t v8 = objc_opt_class(&OBJC_CLASS___NSMutableDictionary);
        if ((objc_opt_isKindOfClass(v7, v8) & 1) != 0)
        {

LABEL_12:
          size_t v12 = (os_log_s *)qword_1008F7578;
          if (os_log_type_enabled((os_log_t)qword_1008F7578, OS_LOG_TYPE_DEFAULT))
          {
            size_t v13 = (void *)objc_claimAutoreleasedReturnValue([v3 objectForKeyedSubscript:v6]);
            uint64_t v14 = (void *)objc_claimAutoreleasedReturnValue([v13 objectForKeyedSubscript:@"kCBMsgArgParamSpatialMode"]);
            unsigned int v15 = [v14 unsignedIntValue];
            uint64_t v16 = (void *)objc_claimAutoreleasedReturnValue([v3 objectForKeyedSubscript:v6]);
            uint64_t v17 = (void *)objc_claimAutoreleasedReturnValue([v16 objectForKeyedSubscript:@"kCBMsgArgParamSpatialHeadTracking"]);
            unsigned int v18 = [v17 BOOLValue];
            *(_DWORD *)__int128 buf = 138412802;
            uint64_t v52 = v6;
            __int16 v53 = 1024;
            unsigned int v54 = v15;
            __int16 v55 = 1024;
            unsigned int v56 = v18;
            _os_log_impl( (void *)&_mh_execute_header,  v12,  OS_LOG_TYPE_DEFAULT,  "StackManager Get Spatial Mode Bundle ID Dict, key: %@, value: %u headtrack: %u",  buf,  0x18u);
          }

          continue;
        }

        __int128 v9 = (void *)objc_claimAutoreleasedReturnValue([v3 objectForKeyedSubscript:v6]);
        uint64_t v10 = objc_opt_class(&OBJC_CLASS___NSDictionary);
        char isKindOfClass = objc_opt_isKindOfClass(v9, v10);

        if ((isKindOfClass & 1) != 0) {
          goto LABEL_12;
        }
        __int16 v19 = objc_alloc_init(&OBJC_CLASS___NSMutableDictionary);
        int v20 = (void *)objc_claimAutoreleasedReturnValue([v3 objectForKeyedSubscript:v6]);
        __int16 v21 = (void *)objc_claimAutoreleasedReturnValue( +[NSNumber numberWithUnsignedInt:]( NSNumber,  "numberWithUnsignedInt:",  [v20 unsignedIntValue]));

        -[NSMutableDictionary setObject:forKey:](v19, "setObject:forKey:", v21, @"kCBMsgArgParamSpatialMode");
        int v22 = (void *)objc_claimAutoreleasedReturnValue(+[NSNumber numberWithBool:](&OBJC_CLASS___NSNumber, "numberWithBool:", 1LL));
        -[NSMutableDictionary setObject:forKey:]( v19,  "setObject:forKey:",  v22,  @"kCBMsgArgParamSpatialHeadTracking");
        -[NSMutableDictionary setObject:forKey:](v38, "setObject:forKey:", v19, v6);
        __int128 v23 = (os_log_s *)qword_1008F7578;
        if (os_log_type_enabled((os_log_t)qword_1008F7578, OS_LOG_TYPE_DEFAULT))
        {
          __int128 v24 = (void *)objc_claimAutoreleasedReturnValue([v3 objectForKeyedSubscript:v6]);
          unsigned int v25 = [v24 unsignedIntValue];
          *(_DWORD *)__int128 buf = 138412546;
          uint64_t v52 = v6;
          __int16 v53 = 1024;
          unsigned int v54 = v25;
          _os_log_impl( (void *)&_mh_execute_header,  v23,  OS_LOG_TYPE_DEFAULT,  "StackManager Converting Bundle ID Dict, key: %@, value: %u",  buf,  0x12u);
        }

        char v37 = 1;
      }

      id v4 = [v3 countByEnumeratingWithState:&v45 objects:v57 count:16];
      if (!v4)
      {
LABEL_24:

        __int128 v43 = 0u;
        __int128 v44 = 0u;
        __int128 v41 = 0u;
        __int128 v42 = 0u;
        __int128 v27 = v38;
        id v28 = -[NSMutableDictionary countByEnumeratingWithState:objects:count:]( v27,  "countByEnumeratingWithState:objects:count:",  &v41,  v50,  16LL);
        if (v28)
        {
          uint64_t v29 = *(void *)v42;
          do
          {
            for (j = 0LL; j != v28; j = (char *)j + 1)
            {
              if (*(void *)v42 != v29) {
                objc_enumerationMutation(v27);
              }
              uint64_t v31 = *(void *)(*((void *)&v41 + 1) + 8LL * (void)j);
              [v3 removeObjectForKey:v31];
              __int128 v32 = (void *)objc_claimAutoreleasedReturnValue(-[NSMutableDictionary objectForKeyedSubscript:](v27, "objectForKeyedSubscript:", v31));
              [v3 setObject:v32 forKey:v31];
            }

            id v28 = -[NSMutableDictionary countByEnumeratingWithState:objects:count:]( v27,  "countByEnumeratingWithState:objects:count:",  &v41,  v50,  16LL);
          }

          while (v28);
        }

        if ((v37 & 1) != 0) {
          sub_10043539C(a1, v3);
        }
        int v2 = (NSMutableDictionary *)v3;

        goto LABEL_34;
      }
    }
  }

  __int128 v26 = (os_log_s *)qword_1008F7578;
  if (os_log_type_enabled((os_log_t)qword_1008F7578, OS_LOG_TYPE_DEFAULT))
  {
    *(_WORD *)__int128 buf = 0;
    _os_log_impl((void *)&_mh_execute_header, v26, OS_LOG_TYPE_DEFAULT, "StackManager create a new dict", buf, 2u);
  }

  int v2 = objc_alloc_init(&OBJC_CLASS___NSMutableDictionary);
LABEL_34:

LABEL_35:
  sub_100242FAC((uint64_t)v49);
  return v2;
}

void sub_100435284( _Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, void *a10, void *a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, void *a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20, uint64_t a21, uint64_t a22, uint64_t a23, uint64_t a24, uint64_t a25, uint64_t a26, uint64_t a27, uint64_t a28, uint64_t a29, uint64_t a30, uint64_t a31, uint64_t a32, uint64_t a33, uint64_t a34, uint64_t a35, uint64_t a36, char a37)
{
}

void sub_10043539C(uint64_t a1, void *a2)
{
  id v3 = a2;
  v4[0] = 0LL;
  v4[1] = 0LL;
  sub_100242F28((uint64_t)v4, a1 + 408);
  CFPreferencesSetAppValue(@"SpatialModeDict", v3, @"com.apple.BTServer");
  CFPreferencesAppSynchronize(@"com.apple.BTServer");
  sub_100242FAC((uint64_t)v4);
}

void sub_100435408(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_100435428(uint64_t a1, void *a2, _BYTE *a3, int *a4)
{
  id v7 = a2;
  if (!v7)
  {
    if (os_log_type_enabled((os_log_t)qword_1008F7578, OS_LOG_TYPE_ERROR)) {
      sub_10067EE14();
    }
    *a3 = 1;
    *a4 = 1;
  }

  uint64_t v8 = *(void **)(a1 + 480);
  if (!v8)
  {
    __int128 v9 = sub_100434D44(a1);
    uint64_t v10 = objc_claimAutoreleasedReturnValue(v9);
    char v11 = *(void **)(a1 + 480);
    *(void *)(a1 + 48sub_100414D2C(qword_1008F72C0, 0) = v10;

    uint64_t v8 = *(void **)(a1 + 480);
  }

  size_t v12 = (void *)objc_claimAutoreleasedReturnValue([v8 objectForKey:v7]);
  size_t v13 = v12;
  if (v12)
  {
    uint64_t v14 = (void *)objc_claimAutoreleasedReturnValue([v12 objectForKey:@"kCBMsgArgParamSpatialMode"]);
    unsigned int v15 = v14;
    if (v14)
    {
      *a4 = [v14 unsignedIntValue];
      uint64_t v16 = (void *)objc_claimAutoreleasedReturnValue([v13 objectForKey:@"kCBMsgArgParamSpatialHeadTracking"]);
      uint64_t v17 = v16;
      if (v16)
      {
        *a3 = [v16 BOOLValue];
      }

      else
      {
        if (os_log_type_enabled((os_log_t)qword_1008F7578, OS_LOG_TYPE_ERROR)) {
          sub_10067EDE8();
        }
        *a3 = 1;
        *a4 = 1;
      }
    }

    else
    {
      if (os_log_type_enabled((os_log_t)qword_1008F7578, OS_LOG_TYPE_ERROR)) {
        sub_10067EDBC();
      }
      if ([v7 caseInsensitiveCompare:@"com.apple.facetime"])
      {
        int v19 = 1;
        *a3 = 1;
      }

      else
      {
        *a3 = 0;
        *a3 = _os_feature_enabled_impl("CoreLocation", "Zelda");
        int v19 = 2;
      }

      *a4 = v19;
    }
  }

  else
  {
    if (os_log_type_enabled((os_log_t)qword_1008F7578, OS_LOG_TYPE_ERROR)) {
      sub_10067ED90();
    }
    if ([v7 caseInsensitiveCompare:@"com.apple.facetime"])
    {
      int v18 = 1;
      *a3 = 1;
    }

    else
    {
      *a3 = 0;
      *a3 = _os_feature_enabled_impl("CoreLocation", "Zelda");
      int v18 = 2;
    }

    *a4 = v18;
  }

  int v20 = (os_log_s *)qword_1008F7578;
  if (os_log_type_enabled((os_log_t)qword_1008F7578, OS_LOG_TYPE_DEFAULT))
  {
    int v21 = *a4;
    int v22 = *a3;
    int v23 = 138412802;
    id v24 = v7;
    __int16 v25 = 1024;
    int v26 = v21;
    __int16 v27 = 1024;
    int v28 = v22;
    _os_log_impl( (void *)&_mh_execute_header,  v20,  OS_LOG_TYPE_DEFAULT,  "StackManager Get Spatial Mode with Bundle ID: %@=>%u,%u",  (uint8_t *)&v23,  0x18u);
  }
}

void sub_1004356C8(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

uint64_t sub_100435710(uint64_t a1)
{
  v9[0] = 0LL;
  v9[1] = 0LL;
  sub_100242F28((uint64_t)v9, a1 + 488);
  uint64_t v2 = *(unsigned int *)(a1 + 552);
  if ((_DWORD)v2)
  {
    id v3 = (os_log_s *)qword_1008F7578;
    if (os_log_type_enabled((os_log_t)qword_1008F7578, OS_LOG_TYPE_DEFAULT))
    {
      *(_DWORD *)__int128 buf = 67109120;
      int v11 = v2;
      _os_log_impl( (void *)&_mh_execute_header,  v3,  OS_LOG_TYPE_DEFAULT,  "Default airplane mode denylist state is %d",  buf,  8u);
      uint64_t v2 = *(unsigned int *)(a1 + 552);
    }

    goto LABEL_13;
  }

  id v4 = (void *)CFPreferencesCopyAppValue(@"defaultAirplaneModeDenylistState", @"com.apple.BTServer");
  if (v4)
  {
    if ([@"on" isEqualToString:v4])
    {
      int v5 = 2;
LABEL_9:
      *(_DWORD *)(a1 + 552) = v5;
      goto LABEL_10;
    }

    if ([@"off" isEqualToString:v4])
    {
      int v5 = 1;
      goto LABEL_9;
    }
  }

void sub_100435894( _Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9)
{
  sub_100242FAC((uint64_t)&a9);
  _Unwind_Resume(a1);
}

void sub_1004358BC(uint64_t a1)
{
  if (qword_1008D60B0 != -1) {
    dispatch_once(&qword_1008D60B0, &stru_1008983A0);
  }
  __int128 v3 = *(_OWORD *)(a1 + 32);
  uint64_t v4 = *(void *)(a1 + 48);
  v2[0] = _NSConcreteStackBlock;
  v2[1] = 3221225472LL;
  v2[2] = sub_100435A8C;
  v2[3] = &unk_1008981C0;
  sub_100435958((uint64_t)off_1008D60A8 + 112, v2);
}

void sub_100435958(uint64_t a1, void *a2)
{
  __int128 v3 = a2;
  os_unfair_lock_lock((os_unfair_lock_t)a1);
  uint64_t v12 = 0LL;
  uint64_t v13 = 0LL;
  uint64_t v14 = 0LL;
  sub_1004393FC( (char *)&v12,  *(void **)(a1 + 8),  *(void **)(a1 + 16),  (uint64_t)(*(void *)(a1 + 16) - *(void *)(a1 + 8)) >> 4);
  os_unfair_lock_unlock((os_unfair_lock_t)a1);
  uint64_t v4 = v12;
  uint64_t v5 = v13;
  while (v4 != v5)
  {
    uint64_t v10 = 0LL;
    int v11 = 0LL;
    uint64_t v6 = *(std::__shared_weak_count **)(v4 + 8);
    if (!v6) {
      goto LABEL_14;
    }
    BOOL v7 = std::__shared_weak_count::lock(v6);
    int v11 = v7;
    if (!v7)
    {
      if (!v10) {
        goto LABEL_9;
      }
LABEL_8:
      v3[2](v3, &v10);
      BOOL v7 = v11;
      goto LABEL_9;
    }

    uint64_t v10 = *(void ***)v4;
    if (v10) {
      goto LABEL_8;
    }
LABEL_9:
    if (v7)
    {
      p_shared_owners = (unint64_t *)&v7->__shared_owners_;
      do
        unint64_t v9 = __ldaxr(p_shared_owners);
      while (__stlxr(v9 - 1, p_shared_owners));
      if (!v9)
      {
        ((void (*)(std::__shared_weak_count *))v7->__on_zero_shared)(v7);
        std::__shared_weak_count::__release_weak(v7);
      }
    }

void sub_100435A5C(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

uint64_t sub_100435A8C(uint64_t a1, void *a2)
{
  return (**(uint64_t (***)(void, void, void, void))*a2)( *a2,  *(void *)(a1 + 32),  *(void *)(a1 + 40),  *(unsigned int *)(a1 + 48));
}

void sub_100435AA8(uint64_t a1)
{
  uint64_t v2 = *(void *)(a1 + 32);
  if (*(_DWORD *)(a1 + 64) == 3703)
  {
    buf[0] = 0;
    sub_100242CA4(buf);
    sub_1000BAAF0("Host Initiated Core Dump");
    sub_100242CD0(buf);
    sub_100242CD8(buf);
  }

  uint64_t v3 = sub_1002E6E00();
  if (!(*(unsigned int (**)(uint64_t))(*(void *)v3 + 8LL))(v3))
  {
LABEL_22:
    uint64_t v9 = sub_1002E6E00();
    uint64_t v10 = *(unsigned int *)(a1 + 64);
    int v11 = (char *)(a1 + 40);
    if (*(char *)(a1 + 63) < 0)
    {
      if (*(void *)(a1 + 48))
      {
        uint64_t v12 = *(char **)v11;
LABEL_27:
        if ((*(unsigned int (**)(uint64_t, uint64_t, char *))(*(void *)v9 + 512LL))(v9, v10, v12))
        {
          uint64_t v14 = sub_1002E6E00();
          uint64_t v15 = *(unsigned int *)(a1 + 64);
          sub_10002418C(v34, v11);
          sub_1004FB370(v14, v15, (uint64_t)v34, 1);
        }

        if ((sub_1000B1B88() & 1) == 0)
        {
          uint64_t v19 = sub_1002E6E00();
          uint64_t v20 = *(unsigned int *)(a1 + 64);
          sub_10002418C(v33, v11);
          sub_1004FB370(v19, v20, (uint64_t)v33, 1);
        }

        *(_DWORD *)(v2 + 36sub_100242E28(v1 + 8) = *(_DWORD *)(a1 + 64);
        std::string::operator=((std::string *)(v2 + 376), (const std::string *)(a1 + 40));
        uint64_t v16 = sub_1002E6E9C();
        if ((*(unsigned int (**)(uint64_t))(*(void *)v16 + 1200LL))(v16))
        {
          uint64_t v21 = sub_1002E6E00();
          uint64_t v22 = *(unsigned int *)(a1 + 64);
          sub_10002418C(v32, v11);
          sub_1004FB370(v21, v22, (uint64_t)v32, 1);
        }

        int v17 = 0;
        while (1)
        {
          int v18 = v17;
          sleep(0xAu);
          int v17 = sub_1000B1BDC();
          if (v17 == v18) {
            break;
          }
          if ((sub_1000B1BD0() & 1) == 0) {
            goto LABEL_49;
          }
        }

        int v17 = v18;
LABEL_49:
        id v24 = (os_log_s *)qword_1008F7578;
        if (os_log_type_enabled((os_log_t)qword_1008F7578, OS_LOG_TYPE_ERROR))
        {
          *(_DWORD *)__int128 buf = 67109632;
          *(_DWORD *)&uint8_t buf[4] = v17;
          LOWORD(v4sub_100414D2C(qword_1008F72C0, 0) = 1024;
          *(_DWORD *)((char *)&v40 + 2) = v18;
          HIWORD(v4sub_100414D2C(qword_1008F72C0, 0) = 1024;
          LODWORD(v41) = 10;
          _os_log_error_impl( (void *)&_mh_execute_header,  v24,  OS_LOG_TYPE_ERROR,  "coreDumpPacketCounter:%d coreDumpLastPacketCounter:%d no change detected for %d seconds, aborting",  buf,  0x14u);
        }

        uint64_t v25 = sub_1002E6E00();
        uint64_t v26 = *(unsigned int *)(a1 + 64);
        else {
          size_t v27 = *(void *)(a1 + 48);
        }
        uint64_t v40 = 0LL;
        uint64_t v41 = 0LL;
        *(void *)__int128 buf = 0LL;
        int v28 = buf;
        sub_100271C18((uint64_t)buf, v27 + 21);
        if (v41 < 0) {
          int v28 = *(uint8_t **)buf;
        }
        if (v27)
        {
          else {
            uint64_t v29 = *(const void **)(a1 + 40);
          }
          memmove(v28, v29, v27);
        }

        strcpy((char *)&v28[v27], " BD_COREDUMP_TOO_LONG");
        if (v41 >= 0) {
          __int128 v30 = (char *)buf;
        }
        else {
          __int128 v30 = *(char **)buf;
        }
        sub_10002418C(v31, v30);
        sub_1004FB370(v25, v26, (uint64_t)v31, 1);
      }
    }

    else
    {
      uint64_t v12 = (char *)(a1 + 40);
      if (*(_BYTE *)(a1 + 63)) {
        goto LABEL_27;
      }
    }

    sub_1001F142C(*(unsigned int *)(a1 + 64));
    uint64_t v12 = v13;
    goto LABEL_27;
  }

  uint64_t v37 = 0LL;
  v38[0] = 0LL;
  v38[1] = 0LL;
  sub_10002418C(buf, "Firmware crash detected :(pc = 0xc6dce, lr = 0xc6de5, bcsReason = 0x0, trapReason = 0x5)");
  sub_10002418C(v42, "Firmware crash detected :(pc = 0x82c, lr = 0x7bf, bcsReason = 0x0, trapReason = 0x25)");
  sub_10002418C(v43, "pci error: kACIPCEnterLowPowerFailed: (0x2, 0x0)");
  sub_10002418C(v44, "chip boot failure");
  sub_10002418C(v45, "BD_VSC_LE_META_ADD_IRK_TO_LIST");
  sub_100329294((uint64_t)&v37, (const void **)buf, 5LL);
  for (uint64_t i = 0LL; i != -15; i -= 3LL)
  {
    if (SHIBYTE(v45[i + 2]) < 0) {
      operator delete((void *)v45[i]);
    }
  }

  if (v38 == (char **)sub_100024098((uint64_t)&v37, (const void **)(a1 + 40)))
  {
    int v5 = *(_DWORD *)(a1 + 64);
    if (v5 == 133)
    {
      if (qword_1008D9060 != -1) {
        dispatch_once(&qword_1008D9060, &stru_100898500);
      }
      uint64_t v23 = qword_1008D9058;
      sub_10002418C(buf, "FW Crash");
      sub_10002418C(__p, "OI_STATUS_ALREADY_CONNECTED");
      sub_10040C784(0.0, v23, (uint64_t *)buf, (uint64_t *)__p);
    }

    else
    {
      if (v5 != 652)
      {
LABEL_21:
        sub_10023E78C((uint64_t)&v37, v38[0]);
        goto LABEL_22;
      }

      if (qword_1008D9060 != -1) {
        dispatch_once(&qword_1008D9060, &stru_100898500);
      }
      uint64_t v6 = qword_1008D9058;
      sub_10002418C(buf, "FW Crash");
      sub_10002418C(__p, "OI_HCI_HW_ERROR_SPMI_TIMEOUT");
      sub_10040C784(0.0, v6, (uint64_t *)buf, (uint64_t *)__p);
    }

    if (v36 < 0) {
      operator delete(__p[0]);
    }
  }

  else
  {
    BOOL v7 = (os_log_s *)qword_1008F7578;
    if (os_log_type_enabled((os_log_t)qword_1008F7578, OS_LOG_TYPE_DEFAULT))
    {
      *(_WORD *)__int128 buf = 0;
      _os_log_impl( (void *)&_mh_execute_header,  v7,  OS_LOG_TYPE_DEFAULT,  "Targetted FW Crash signature found, filing ABC Snapshot",  buf,  2u);
    }

    if (qword_1008D9060 != -1) {
      dispatch_once(&qword_1008D9060, &stru_100898500);
    }
    uint64_t v8 = qword_1008D9058;
    sub_10002418C(buf, "FW Crash");
    sub_10040C784(60.0, v8, (uint64_t *)buf, (uint64_t *)(a1 + 40));
  }

  if (SHIBYTE(v41) < 0) {
    operator delete(*(void **)buf);
  }
  goto LABEL_21;
}

void sub_100436030( _Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, void *__p, uint64_t a10, int a11, __int16 a12, char a13, char a14, uint64_t a15, uint64_t a16, int a17, __int16 a18, char a19, char a20, uint64_t a21, uint64_t a22, int a23, __int16 a24, char a25, char a26, uint64_t a27, uint64_t a28, int a29, __int16 a30, char a31, char a32, void *a33, uint64_t a34, int a35, __int16 a36, char a37, char a38, char a39, uint64_t a40, uint64_t a41, void *a42, uint64_t a43, int a44, __int16 a45, char a46, char a47)
{
  if (a14 < 0) {
    operator delete(__p);
  }
  if (a47 < 0) {
    operator delete(a42);
  }
  _Unwind_Resume(exception_object);
}

void *sub_10043616C(uint64_t a1, uint64_t a2)
{
  float result = (void *)(a1 + 40);
  __int128 v3 = *(_OWORD *)(a2 + 40);
  result[2] = *(void *)(a2 + 56);
  *(_OWORD *)float result = v3;
  return result;
}

void sub_10043619C(uint64_t a1)
{
}

void sub_1004361B0(uint64_t a1)
{
  if (qword_1008D60B0 != -1) {
    dispatch_once(&qword_1008D60B0, &stru_1008983A0);
  }
  sub_1004339A8((uint64_t)off_1008D60A8, *(unsigned __int8 *)(a1 + 32));
}

uint64_t sub_1004361F8(uint64_t a1, unsigned __int8 *a2)
{
  v24[0] = 0LL;
  v24[1] = 0LL;
  sub_100242F28((uint64_t)v24, a1 + 144);
  if (*(_BYTE *)(a1 + 76))
  {
    sub_100242F54((uint64_t)v24);
    v23[0] = 0LL;
    v23[1] = 0LL;
    sub_100242F28((uint64_t)v23, a1 + 224);
    uint64_t v4 = (unsigned __int8 **)(a1 + 296);
    uint64_t v5 = a2[23];
    if ((v5 & 0x80u) == 0LL) {
      uint64_t v6 = a2[23];
    }
    else {
      uint64_t v6 = *((void *)a2 + 1);
    }
    uint64_t v7 = *(unsigned __int8 *)(a1 + 319);
    int v8 = (char)v7;
    if ((v7 & 0x80u) != 0LL) {
      uint64_t v7 = *(void *)(a1 + 304);
    }
    if (v6 == v7)
    {
      if (v8 >= 0) {
        uint64_t v9 = (unsigned __int8 *)(a1 + 296);
      }
      else {
        uint64_t v9 = *v4;
      }
      if ((v5 & 0x80) == 0)
      {
        if (a2[23])
        {
          uint64_t v10 = a2;
          while (*v10 == *v9)
          {
            ++v10;
            ++v9;
            if (!--v5) {
              goto LABEL_32;
            }
          }

          goto LABEL_20;
        }

void sub_10043649C( _Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, ...)
{
  uint64_t v8 = va_arg(va1, void);
  uint64_t v10 = va_arg(va1, void);
  sub_100242FAC((uint64_t)va);
  sub_100242FAC((uint64_t)va1);
  _Unwind_Resume(a1);
}

uint64_t sub_1004364E0(uint64_t a1)
{
  return sub_1004325AC(*(void *)(a1 + 32));
}

uint64_t sub_1004364E8(uint64_t a1, unsigned __int8 *a2)
{
  return sub_1004361F8(a1 - 8, a2);
}

uint64_t sub_1004364F0(uint64_t a1, uint64_t a2)
{
  uint64_t v28 = 0LL;
  __int128 v27 = 0u;
  memset(v26, 0, sizeof(v26));
  __int128 v24 = 0u;
  *(_OWORD *)uint64_t v25 = 0u;
  __int128 v22 = 0u;
  *(_OWORD *)uint64_t v23 = 0u;
  __int128 v20 = 0u;
  *(_OWORD *)uint64_t v21 = 0u;
  sub_100532DC0((uint64_t)&v20 + 1);
  BYTE2(v21[0]) = 0;
  BYTE4(v21[0]) = 0;
  BYTE2(v23[0]) = 0;
  BYTE4(v23[0]) = 0;
  DWORD1(v26[1]) = 0;
  __int128 v22 = 0uLL;
  v21[1] = 0LL;
  LOBYTE(v23[0]) = 0;
  __int128 v24 = 0uLL;
  v23[1] = 0LL;
  LOBYTE(v25[0]) = 0;
  memset(v26, 0, 19);
  v25[1] = 0LL;
  BYTE8(v26[1]) = 1;
  BYTE2(v2sub_100242E28(v1 + 8) = 0;
  *(void *)((char *)&v26[1] + 14) = 0LL;
  *(void *)((char *)&v26[1] + 9) = 0LL;
  __int128 v27 = 0uLL;
  *((void *)&v26[2] + 1) = 0LL;
  LOBYTE(v2sub_100242E28(v1 + 8) = 0;
  int v16 = 0;
  if (qword_1008D5F50 != -1) {
    dispatch_once(&qword_1008D5F50, &stru_100898440);
  }
  *(_DWORD *)__int128 buf = *(_DWORD *)a2;
  *(_WORD *)&uint8_t buf[4] = *(_WORD *)(a2 + 4);
  __int128 v3 = sub_1003FFEB0(off_1008D5F48, (uint64_t)buf, 1);
  if (sub_1003D2408((uint64_t)v3, (uint64_t)&v20))
  {
    if (BYTE5(v27))
    {
      uint64_t v4 = (os_log_s *)qword_1008F7578;
      if (os_log_type_enabled((os_log_t)qword_1008F7578, OS_LOG_TYPE_DEFAULT))
      {
        *(_DWORD *)__int128 buf = 68157954;
        *(_DWORD *)&uint8_t buf[4] = 6;
        *(_WORD *)&uint8_t buf[8] = 2096;
        *(void *)&buf[10] = a2;
        _os_log_impl( (void *)&_mh_execute_header,  v4,  OS_LOG_TYPE_DEFAULT,  "Invoking roleswitch disable for %{bluetooth:BD_ADDR}.6P",  buf,  0x12u);
      }

      if (sub_100117940((uint64_t)v3 + 128, 1)
        && os_log_type_enabled((os_log_t)qword_1008F7578, OS_LOG_TYPE_ERROR))
      {
        sub_10067EFC0();
      }
    }

    if (BYTE6(v27))
    {
      uint64_t v5 = (os_log_s *)qword_1008F7578;
      if (os_log_type_enabled((os_log_t)qword_1008F7578, OS_LOG_TYPE_DEFAULT))
      {
        *(_DWORD *)__int128 buf = 141558531;
        *(void *)&uint8_t buf[4] = 1752392040LL;
        *(_WORD *)&_BYTE buf[12] = 1041;
        *(_DWORD *)&_BYTE buf[14] = 6;
        __int16 v18 = 2097;
        uint64_t v19 = a2;
        _os_log_impl( (void *)&_mh_execute_header,  v5,  OS_LOG_TYPE_DEFAULT,  "Setting extended LSTO for %{private,bluetooth:BD_ADDR,mask.hash}.6P to 10000ms",  buf,  0x1Cu);
      }

      if (sub_1001178E4((uint64_t)v3 + 128, 10000)
        && os_log_type_enabled((os_log_t)qword_1008F7578, OS_LOG_TYPE_ERROR))
      {
        sub_10067F080();
      }
    }

    if (BYTE1(v28))
    {
      uint64_t v6 = (os_log_s *)qword_1008F7578;
      if (os_log_type_enabled((os_log_t)qword_1008F7578, OS_LOG_TYPE_DEFAULT))
      {
        *(_DWORD *)__int128 buf = 68157954;
        *(_DWORD *)&uint8_t buf[4] = 6;
        *(_WORD *)&uint8_t buf[8] = 2096;
        *(void *)&buf[10] = a2;
        _os_log_impl( (void *)&_mh_execute_header,  v6,  OS_LOG_TYPE_DEFAULT,  "Invoking reduced QoS Latency for %{bluetooth:BD_ADDR}.6P",  buf,  0x12u);
      }

      if (sub_100117988((uint64_t)v3 + 128, 1)
        && os_log_type_enabled((os_log_t)qword_1008F7578, OS_LOG_TYPE_ERROR))
      {
        sub_10067F020();
      }
    }
  }

  sub_1003D01A0((uint64_t)v3, (uint64_t)buf);
  uint64_t v7 = BYTE3(v19);
  if ((v19 & 0x80000000LL) != 0) {
    uint64_t v7 = *(void *)&buf[8];
  }
  if (v7)
  {
    sub_1003D01A0((uint64_t)v3, (uint64_t)&__p);
    BOOL v8 = std::string::compare(&__p, "INTEGRATED HANDSFREE") == 0;
    if ((v19 & 0x80000000LL) == 0)
    {
LABEL_28:
      if (!v8) {
        goto LABEL_37;
      }
      goto LABEL_32;
    }
  }

  else
  {
    BOOL v8 = 0;
    if ((v19 & 0x80000000LL) == 0) {
      goto LABEL_28;
    }
  }

  operator delete(*(void **)buf);
  if (!v8) {
    goto LABEL_37;
  }
LABEL_32:
  uint64_t v9 = (os_log_s *)qword_1008F7578;
  if (os_log_type_enabled((os_log_t)qword_1008F7578, OS_LOG_TYPE_DEFAULT))
  {
    *(_DWORD *)__int128 buf = 68157954;
    *(_DWORD *)&uint8_t buf[4] = 6;
    *(_WORD *)&uint8_t buf[8] = 2096;
    *(void *)&buf[10] = a2;
    _os_log_impl( (void *)&_mh_execute_header,  v9,  OS_LOG_TYPE_DEFAULT,  "Name matched, invoking roleswitch disable for %{bluetooth:BD_ADDR}.6P",  buf,  0x12u);
  }

  if (sub_100117940((uint64_t)v3 + 128, 1)
    && os_log_type_enabled((os_log_t)qword_1008F7578, OS_LOG_TYPE_ERROR))
  {
    sub_10067EFC0();
  }

void sub_100436B18( _Unwind_Exception *a1, uint64_t a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, void *__p, uint64_t a14, int a15, __int16 a16, char a17, char a18, uint64_t a19, char a20)
{
  if (a18 < 0) {
    operator delete(__p);
  }
  sub_1002071FC((uint64_t)&a20, a2);
  _Unwind_Resume(a1);
}

uint64_t sub_100436B58()
{
  char v2 = 0;
  sub_100242CA4(&v2);
  uint64_t v0 = sub_10011412C();
  sub_100242CD8(&v2);
  return v0;
}

void sub_100436B98( _Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, int a10, __int16 a11, char a12, char a13)
{
}

_BYTE *sub_100436BB0(uint64_t a1)
{
  if (*(_BYTE *)(a1 + 218))
  {
    if (*(_DWORD *)(sub_1002E6E9C() + 708))
    {
      if (*(_DWORD *)(sub_1002E6E9C() + 708) <= 0x7CFu && *(_DWORD *)(sub_1002E6E9C() + 708) <= 0x12u)
      {
        uint64_t v1 = sub_1002E6E9C();
        if ((*(unsigned int (**)(uint64_t, void))(*(void *)v1 + 1256LL))(v1, 0LL))
        {
          char v8 = 0;
          sub_100242CA4(&v8);
          sub_10011EF18();
          sub_100242CD0(&v8);
          sub_100242CD8(&v8);
        }
      }
    }
  }

  char v7 = 0;
  sub_100242CA4(&v7);
  int v2 = sub_1000A8EA8();
  sub_100242CD0(&v7);
  uint64_t v3 = sub_1002E6E9C();
  (*(void (**)(uint64_t, void, uint64_t))(*(void *)v3 + 552LL))(v3, 0LL, 1LL);
  if (v2 == 118)
  {
    uint64_t v4 = (os_log_s *)qword_1008F7578;
    if (os_log_type_enabled((os_log_t)qword_1008F7578, OS_LOG_TYPE_DEFAULT))
    {
      *(_WORD *)uint64_t v6 = 0;
      _os_log_impl((void *)&_mh_execute_header, v4, OS_LOG_TYPE_DEFAULT, "Waiting for 'YOU MAY SLEEP'", v6, 2u);
    }

    sub_1000B0964(500);
  }

  return sub_100242CD8(&v7);
}

void sub_100436CD0( _Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, int a10, __int16 a11, char a12, char a13)
{
}

_BYTE *sub_100436CF0(uint64_t a1)
{
  return sub_100436BB0(a1 - 16);
}

_BYTE *sub_100436CF8(uint64_t a1)
{
  __int128 v31 = 0u;
  __int128 v32 = 0u;
  __int128 v29 = 0u;
  __int128 v30 = 0u;
  __int128 v27 = 0u;
  __int128 v28 = 0u;
  __int128 v25 = 0u;
  __int128 v26 = 0u;
  __int128 v23 = 0u;
  __int128 v24 = 0u;
  __int128 v21 = 0u;
  __int128 v22 = 0u;
  __int128 v19 = 0u;
  __int128 v20 = 0u;
  *(_OWORD *)__big = 0u;
  __int128 v18 = 0u;
  size_t v10 = 256LL;
  sysctlbyname("kern.wakereason", __big, &v10, 0LL, 0LL);
  if (strnstr(__big, "bluetooth", 0x100uLL)) {
    BOOL v2 = 1;
  }
  else {
    BOOL v2 = strnstr(__big, "BT.Ou", 0x100uLL) != 0LL;
  }
  HIBYTE(vsub_100242FAC(v1 - 32) = 0;
  if (*(_BYTE *)(a1 + 218))
  {
    if (*(_DWORD *)(sub_1002E6E9C() + 708))
    {
      if (*(_DWORD *)(sub_1002E6E9C() + 708) <= 0x7CFu && *(_DWORD *)(sub_1002E6E9C() + 708) <= 0x12u)
      {
        uint64_t v3 = sub_1002E6E9C();
        if ((*(unsigned int (**)(uint64_t, uint64_t))(*(void *)v3 + 1256LL))(v3, 1LL))
        {
          buf[0] = 0;
          sub_100242CA4(buf);
          sub_10011EF18();
          sub_100242CD0(buf);
          sub_100242CD8(buf);
        }
      }
    }
  }

  char v9 = 0;
  sub_100242CA4(&v9);
  sub_1000A8EBC(v2);
  sub_100242CD0(&v9);
  uint64_t v4 = sub_1002E6E9C();
  (*(void (**)(uint64_t, uint64_t, uint64_t))(*(void *)v4 + 552LL))(v4, 1LL, 1LL);
  if (v2)
  {
    int v5 = *sub_10012F690(0LL);
    else {
      uint64_t v6 = *(&off_100898558 + (char)(v5 - 2));
    }
    IOPMClaimSystemWakeEvent(@"bluetooth", v6, 0LL);
  }

  else
  {
    int v5 = 0;
  }

  char v7 = (os_log_s *)qword_1008F7578;
  if (os_log_type_enabled((os_log_t)qword_1008F7578, OS_LOG_TYPE_DEFAULT))
  {
    *(_DWORD *)__int128 buf = 136315650;
    int v12 = __big;
    __int16 v13 = 1024;
    BOOL v14 = v2;
    __int16 v15 = 1024;
    int v16 = v5;
    _os_log_impl( (void *)&_mh_execute_header,  v7,  OS_LOG_TYPE_DEFAULT,  "wakeReason:%s reasonWasBluetooth:%d controllerPacketType:%d",  buf,  0x18u);
  }

  return sub_100242CD8(&v9);
}

void sub_100436F40(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, ...)
{
}

_BYTE *sub_100436F70(uint64_t a1)
{
  return sub_100436CF8(a1 - 16);
}

uint64_t sub_100436F78(uint64_t a1, unsigned int a2, int a3)
{
  v11[0] = 0LL;
  v11[1] = 0LL;
  sub_100242F28((uint64_t)v11, a1 + 144);
  if (*(_BYTE *)(a1 + 76))
  {
    sub_100242F54((uint64_t)v11);
    uint64_t v6 = sub_100404EB8();
    v10[0] = _NSConcreteStackBlock;
    v10[1] = 3221225472LL;
    void v10[2] = sub_10043708C;
    uint64_t v10[3] = &unk_10087EB20;
    v10[4] = a1;
    sub_100405384(v6, v10);
    char v9 = 0;
    sub_100242CA4(&v9);
    if (a3) {
      uint64_t v7 = a2;
    }
    else {
      uint64_t v7 = 0LL;
    }
    sub_100118D44(v7);
    sub_100242CD8(&v9);
  }

  else
  {
    *(_BYTE *)(a1 + 209) = 1;
    if (os_log_type_enabled((os_log_t)qword_1008F7578, OS_LOG_TYPE_ERROR)) {
      sub_10067E824();
    }
  }

  return sub_100242FAC((uint64_t)v11);
}

void sub_100437064( _Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, int a9, __int16 a10, char a11, char a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, char a18)
{
}

uint64_t sub_10043708C(uint64_t a1)
{
  return sub_1004325AC(*(void *)(a1 + 32));
}

uint64_t sub_100437094(uint64_t a1, unsigned int a2, int a3)
{
  return sub_100436F78(a1 - 24, a2, a3);
}

uint64_t sub_1004370A0(uint64_t a1, uint64_t a2)
{
  uint64_t v3 = sub_1002E6E9C();
  return (*(uint64_t (**)(uint64_t, uint64_t))(*(void *)v3 + 1136LL))(v3, a2);
}

uint64_t sub_1004370CC(uint64_t a1, uint64_t a2)
{
  uint64_t v3 = sub_1002E6E9C();
  return (*(uint64_t (**)(uint64_t, uint64_t))(*(void *)v3 + 1136LL))(v3, a2);
}

uint64_t sub_1004370F8(uint64_t a1)
{
  v8[0] = 0LL;
  v8[1] = 0LL;
  uint64_t v2 = sub_100242F28((uint64_t)v8, a1 + 144);
  if (*(_BYTE *)(a1 + 76))
  {
    sub_100242F54(v2);
    uint64_t v3 = sub_100404EB8();
    v6[0] = _NSConcreteStackBlock;
    v6[1] = 3221225472LL;
    _DWORD v6[2] = sub_1004371D8;
    void v6[3] = &unk_10087EB20;
    v6[4] = a1;
    sub_100405384(v3, v6);
  }

  else
  {
    uint64_t v4 = (os_log_s *)qword_1008F7578;
    if (os_log_type_enabled((os_log_t)qword_1008F7578, OS_LOG_TYPE_DEFAULT))
    {
      *(_WORD *)__int128 buf = 0;
      _os_log_impl( (void *)&_mh_execute_header,  v4,  OS_LOG_TYPE_DEFAULT,  "Ignoring CarPlay state change notification as stack is not ready",  buf,  2u);
    }
  }

  return sub_100242FAC((uint64_t)v8);
}

void sub_1004371C4(_Unwind_Exception *a1)
{
}

uint64_t sub_1004371D8(uint64_t a1)
{
  return sub_1004325AC(*(void *)(a1 + 32));
}

uint64_t sub_1004371E0(uint64_t a1)
{
  return sub_1004370F8(a1 - 40);
}

uint64_t sub_1004371EC(uint64_t a1, uint64_t a2)
{
  if (qword_1008D6198 != -1) {
    dispatch_once(&qword_1008D6198, &stru_100898420);
  }
  sub_100449054((uint64_t)off_1008D6190, a2);
  uint64_t v3 = sub_1002E6E9C();
  return (*(uint64_t (**)(uint64_t, uint64_t, uint64_t))(*(void *)v3 + 560LL))(v3, a2, 1LL);
}

uint64_t sub_100437258(uint64_t a1, uint64_t a2, __int16 *a3)
{
  v25[0] = 0LL;
  v25[1] = 0LL;
  sub_100242F28((uint64_t)v25, a1 + 144);
  __int128 v34 = 0u;
  __int128 v33 = 0u;
  __int128 v32 = 0u;
  __int128 v31 = 0u;
  __int128 v30 = 0u;
  __int128 v29 = 0u;
  uint64_t v5 = sub_1002E6E9C();
  if ((*(_DWORD *)(a1 + 72) | 2) == 2)
  {
    if (os_log_type_enabled((os_log_t)qword_1008F7578, OS_LOG_TYPE_ERROR)) {
      sub_10067E824();
    }
    uint64_t v6 = 111LL;
  }

  else
  {
    int v7 = *(_DWORD *)(v5 + 708);
    sub_100242F54((uint64_t)v25);
    if ((v7 - 2000) < 0x7D0 || (uint64_t v6 = 1LL, v7 != 6) && (v7 - 1) <= 0x7CE)
    {
      __int16 v26 = *a3;
      int v27 = *(_DWORD *)(a3 + 1);
      unsigned __int8 v28 = *((_BYTE *)a3 + 6);
      uint64_t v8 = v28;
      if (v28)
      {
        char v9 = a3 + 4;
        int v10 = 7;
        uint64_t v11 = v28;
        do
        {
          __int16 v12 = *v9++;
          *(__int16 *)((char *)&v26 + v1sub_100414D2C(qword_1008F72C0, 0) = v12;
          v10 += 2;
          --v11;
        }

        while (v11);
        int v13 = 2 * v8 + 7;
        BOOL v14 = (char *)(a3 + 36);
        uint64_t v15 = v8;
        do
        {
          char v16 = *v14++;
          *((_BYTE *)&v26 + v13++) = v16;
          --v15;
        }

        while (v15);
      }

      char v24 = 0;
      sub_100242CA4(&v24);
      int v22 = sub_10011ECB8(0LL, (3 * v8 + 7), (uint64_t)&v26, v17, v18, v19, v20, v21);
      sub_100242CD0(&v24);
      sub_100242CD8(&v24);
      uint64_t v6 = v22 != 0;
    }
  }

  sub_100242FAC((uint64_t)v25);
  return v6;
}

void sub_10043740C(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, ...)
{
}

uint64_t sub_10043743C(uint64_t a1, uint64_t a2, uint64_t a3)
{
  v24[0] = 0LL;
  v24[1] = 0LL;
  sub_100242F28((uint64_t)v24, a1 + 144);
  uint64_t v5 = sub_1002E6E9C();
  if ((*(_DWORD *)(a1 + 72) | 2) == 2)
  {
    if (os_log_type_enabled((os_log_t)qword_1008F7578, OS_LOG_TYPE_ERROR)) {
      sub_10067E824();
    }
    uint64_t v6 = 111LL;
  }

  else
  {
    int v7 = *(_DWORD *)(v5 + 708);
    sub_100242F54((uint64_t)v24);
    if ((v7 - 2000) < 0x7D0 || (uint64_t v6 = 0LL, v7 != 6) && (v7 - 1) <= 0x7CE)
    {
      *(_OWORD *)std::string __p = 0u;
      __int128 v23 = 0u;
      sub_10040F90C((uint64_t)__p, 0);
      sub_10040F938((uint64_t)__p, *(_BYTE *)a3);
      sub_10040F974((uint64_t)__p, *(_WORD *)(a3 + 2));
      sub_10040F974((uint64_t)__p, *(_WORD *)(a3 + 4));
      sub_10040F974((uint64_t)__p, *(_WORD *)(a3 + 6));
      sub_10040F974((uint64_t)__p, *(_WORD *)(a3 + 8));
      sub_10040F938((uint64_t)__p, *(_BYTE *)(a3 + 10));
      char v21 = 0;
      sub_100242CA4(&v21);
      sub_10056AB04(&v19, __p[1], v23 - (unint64_t)__p[1]);
      unsigned __int8 v8 = sub_10056AAD8((uint64_t)&v19);
      sub_10056AB04(&v17, __p[1], v23 - (unint64_t)__p[1]);
      uint64_t v9 = sub_10056AAF0((uint64_t)&v17);
      int v15 = sub_10011EC88(0LL, v8, v9, v10, v11, v12, v13, v14);
      uint64_t v17 = &off_10087FAA8;
      if (v18) {
        sub_1002CD254(v18);
      }
      uint64_t v19 = &off_10087FAA8;
      if (v20) {
        sub_1002CD254(v20);
      }
      sub_100242CD0(&v21);
      sub_100242CD8(&v21);
      if (__p[1])
      {
        *(void **)&__int128 v23 = __p[1];
        operator delete(__p[1]);
      }

      uint64_t v6 = v15 != 0;
    }
  }

  sub_100242FAC((uint64_t)v24);
  return v6;
}

void sub_1004375FC( _Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, int a14, __int16 a15, char a16, char a17, uint64_t a18, void *__p, uint64_t a20)
{
  if (__p)
  {
    a20 = (uint64_t)__p;
    operator delete(__p);
  }

  sub_100242FAC(v20 - 48);
  _Unwind_Resume(a1);
}

uint64_t sub_100437688(uint64_t a1, uint64_t a2, __int16 *a3)
{
  v24[0] = 0LL;
  v24[1] = 0LL;
  sub_100242F28((uint64_t)v24, a1 + 144);
  uint64_t v5 = sub_1002E6E9C();
  if ((*(_DWORD *)(a1 + 72) | 2) == 2)
  {
    if (os_log_type_enabled((os_log_t)qword_1008F7578, OS_LOG_TYPE_ERROR)) {
      sub_10067E824();
    }
    uint64_t v6 = 111LL;
  }

  else
  {
    int v8 = *(_DWORD *)(v5 + 708);
    sub_100242F54((uint64_t)v24);
    if ((v8 - 1) > 0xF9E)
    {
      uint64_t v6 = 1LL;
    }

    else
    {
      *(_OWORD *)std::string __p = 0u;
      __int128 v23 = 0u;
      sub_10040F90C((uint64_t)__p, 0);
      sub_10040F974((uint64_t)__p, *a3);
      sub_10040F974((uint64_t)__p, a3[1]);
      sub_10040F974((uint64_t)__p, a3[2]);
      sub_10040F974((uint64_t)__p, a3[3]);
      sub_10040F974((uint64_t)__p, a3[4]);
      sub_10040F974((uint64_t)__p, a3[5]);
      sub_10040F974((uint64_t)__p, a3[6]);
      sub_10040F974((uint64_t)__p, a3[7]);
      sub_10040F974((uint64_t)__p, a3[8]);
      sub_10040F974((uint64_t)__p, a3[9]);
      sub_10040F974((uint64_t)__p, a3[10]);
      sub_10040F974((uint64_t)__p, a3[11]);
      sub_10040F974((uint64_t)__p, a3[12]);
      sub_10040F974((uint64_t)__p, a3[13]);
      sub_10040F974((uint64_t)__p, a3[14]);
      char v21 = 0;
      sub_100242CA4(&v21);
      sub_10056AB04(&v19, __p[1], v23 - (unint64_t)__p[1]);
      unsigned __int8 v9 = sub_10056AAD8((uint64_t)&v19);
      sub_10056AB04(&v17, __p[1], v23 - (unint64_t)__p[1]);
      uint64_t v10 = sub_10056AAF0((uint64_t)&v17);
      int v16 = sub_10011ECE8(0LL, v9, v10, v11, v12, v13, v14, v15);
      uint64_t v17 = &off_10087FAA8;
      if (v18) {
        sub_1002CD254(v18);
      }
      uint64_t v19 = &off_10087FAA8;
      if (v20) {
        sub_1002CD254(v20);
      }
      sub_100242CD0(&v21);
      sub_100242CD8(&v21);
      if (__p[1])
      {
        *(void **)&__int128 v23 = __p[1];
        operator delete(__p[1]);
      }

      uint64_t v6 = v16 != 0;
    }
  }

  sub_100242FAC((uint64_t)v24);
  return v6;
}

void sub_10043789C( _Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, int a14, __int16 a15, char a16, char a17, uint64_t a18, void *__p, uint64_t a20)
{
  if (__p)
  {
    a20 = (uint64_t)__p;
    operator delete(__p);
  }

  sub_100242FAC(v20 - 32);
  _Unwind_Resume(a1);
}

uint64_t sub_100437928(uint64_t a1, uint64_t a2, char *a3)
{
  v15[0] = 0LL;
  v15[1] = 0LL;
  sub_100242F28((uint64_t)v15, a1 + 144);
  char v5 = *a3;
  uint64_t v6 = sub_1002E6E9C();
  if ((*(_DWORD *)(a1 + 72) | 2) == 2)
  {
    if (os_log_type_enabled((os_log_t)qword_1008F7578, OS_LOG_TYPE_ERROR)) {
      sub_10067E824();
    }
    uint64_t v7 = 111LL;
  }

  else
  {
    int v9 = *(_DWORD *)(v6 + 708);
    sub_100242F54((uint64_t)v15);
    if ((v9 - 1) > 0xF9E)
    {
      uint64_t v7 = 1LL;
    }

    else
    {
      char v14 = 0;
      sub_100242CA4(&v14);
      int v13 = sub_10011ED18( 0LL,  (4 * v5) | 1u,  *a3,  (uint64_t)(a3 + 2),  (uint64_t)(a3 + 34),  v10,  v11,  v12);
      sub_100242CD0(&v14);
      sub_100242CD8(&v14);
      uint64_t v7 = v13 != 0;
    }
  }

  sub_100242FAC((uint64_t)v15);
  return v7;
}

void sub_100437A24(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, ...)
{
}

void sub_100437A4C(uint64_t a1)
{
  char v34 = 2;
  uint64_t v2 = (os_log_s *)qword_1008F7578;
  if (os_log_type_enabled((os_log_t)qword_1008F7578, OS_LOG_TYPE_DEFAULT))
  {
    *(_WORD *)__int128 buf = 0;
    _os_log_impl((void *)&_mh_execute_header, v2, OS_LOG_TYPE_DEFAULT, "Putting device into test mode", buf, 2u);
  }

  *(void *)__int128 buf = 0LL;
  uint64_t v33 = 0LL;
  sub_100242F28((uint64_t)buf, a1 + 144);
  if (*(_DWORD *)(a1 + 72) != 1)
  {
    if (os_log_type_enabled((os_log_t)qword_1008F7578, OS_LOG_TYPE_ERROR)) {
      sub_10067E824();
    }
    goto LABEL_15;
  }

  sub_100242F54((uint64_t)buf);
  char v31 = 0;
  sub_100242CA4(&v31);
  byte_1008F747D = 1;
  int v10 = sub_10011EBE4((uint64_t)sub_1004311B4, v3, v4, v5, v6, v7, v8, v9);
  sub_100242CD0(&v31);
  if (v10)
  {
    if (!os_log_type_enabled((os_log_t)qword_1008F7578, OS_LOG_TYPE_ERROR)) {
      goto LABEL_32;
    }
    goto LABEL_17;
  }

  if (!sub_100431224(a1))
  {
    sub_100242C98(&v31);
    sub_1001BEC40(1);
    sub_100242CD0(&v31);
    sub_100242C98(&v31);
    byte_1008F747D = 1;
    int v17 = sub_1001214B4(71, (uint64_t)sub_1004311B4, v11, v12, v13, v14, v15, v16, 3LL);
    sub_100242CD0(&v31);
    if (v17)
    {
      if (!os_log_type_enabled((os_log_t)qword_1008F7578, OS_LOG_TYPE_ERROR)) {
        goto LABEL_32;
      }
    }

    else
    {
      if (sub_100431224(a1))
      {
        if (os_log_type_enabled((os_log_t)qword_1008F7578, OS_LOG_TYPE_ERROR)) {
          sub_10067F260();
        }
        goto LABEL_32;
      }

      sub_100242C98(&v31);
      byte_1008F747D = 1;
      int v21 = sub_10011E99C((uint64_t)sub_1004311B4, 2u, 0LL, 1LL, (uint64_t)&v34, v18, v19, v20);
      sub_100242CD0(&v31);
      if (!v21)
      {
        if (sub_100431224(a1))
        {
          if (os_log_type_enabled((os_log_t)qword_1008F7578, OS_LOG_TYPE_ERROR)) {
            sub_10067F1A0();
          }
          goto LABEL_32;
        }

        sub_100242C98(&v31);
        byte_1008F747D = 1;
        int v29 = sub_10011F14C((uint64_t)sub_1004311B4, v22, v23, v24, v25, v26, v27, v28, v30);
        sub_100242CD0(&v31);
        if (!v29)
        {
          if (!sub_100431224(a1))
          {
            sub_100242C98(&v31);
            sub_10010C454(1LL);
            sub_100242CD0(&v31);
            sub_100242ECC((uint64_t)buf);
            *(_BYTE *)(a1 + 21sub_100414D2C(qword_1008F72C0, 0) = 1;
            sub_100242CD8(&v31);
LABEL_15:
            sub_100242FAC((uint64_t)buf);
            return;
          }

          if (os_log_type_enabled((os_log_t)qword_1008F7578, OS_LOG_TYPE_ERROR)) {
            goto LABEL_31;
          }
          goto LABEL_32;
        }

        if (!os_log_type_enabled((os_log_t)qword_1008F7578, OS_LOG_TYPE_ERROR)) {
          goto LABEL_32;
        }
LABEL_17:
        sub_10067F140();
        goto LABEL_32;
      }

      if (!os_log_type_enabled((os_log_t)qword_1008F7578, OS_LOG_TYPE_ERROR)) {
        goto LABEL_32;
      }
    }

    sub_10067F200();
    goto LABEL_32;
  }

  if (os_log_type_enabled((os_log_t)qword_1008F7578, OS_LOG_TYPE_ERROR)) {
LABEL_31:
  }
    sub_10067F0E0();
LABEL_32:
  sub_1000AFE20(408LL);
  __break(1u);
}

void sub_100437DA4(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, ...)
{
}

uint64_t sub_100437DCC(uint64_t a1, _BYTE *a2)
{
  v5[0] = 0LL;
  v5[1] = 0LL;
  sub_100242F28((uint64_t)v5, a1 + 144);
  *a2 = *(_BYTE *)(a1 + 210);
  sub_100242FAC((uint64_t)v5);
  return 0LL;
}

uint64_t sub_100437E18(uint64_t a1, int a2, uint64_t a3, uint64_t a4)
{
  uint64_t v8 = (os_log_s *)qword_1008F7578;
  if (os_log_type_enabled((os_log_t)qword_1008F7578, OS_LOG_TYPE_DEFAULT))
  {
    *(_WORD *)__int128 buf = 0;
    _os_log_impl((void *)&_mh_execute_header, v8, OS_LOG_TYPE_DEFAULT, "Putting device into LE TX test mode", buf, 2u);
  }

  *(void *)__int128 buf = 0LL;
  uint64_t v19 = 0LL;
  sub_100242F28((uint64_t)buf, a1 + 144);
  if (*(_DWORD *)(a1 + 72) == 1)
  {
    if (*(_BYTE *)(a1 + 211))
    {
      if (os_log_type_enabled((os_log_t)qword_1008F7578, OS_LOG_TYPE_ERROR)) {
        sub_10067F320();
      }
      uint64_t v9 = 1LL;
    }

    else
    {
      sub_100242F54((uint64_t)buf);
      char v17 = 0;
      sub_100242CA4(&v17);
      unsigned int v15 = a2 - 2402;
      if (a2 < 2402) {
        unsigned int v15 = a2 - 2401;
      }
      uint64_t v9 = sub_1001D4FB8((v15 >> 1), a3, a4, v10, v11, v12, v13, v14);
      sub_100242CD0(&v17);
      if ((_DWORD)v9)
      {
        if (os_log_type_enabled((os_log_t)qword_1008F7578, OS_LOG_TYPE_ERROR)) {
          sub_10067F2C0();
        }
        uint64_t v9 = 111LL;
      }

      else
      {
        *(_BYTE *)(a1 + 211) = 1;
      }

      sub_100242CD8(&v17);
    }
  }

  else
  {
    if (os_log_type_enabled((os_log_t)qword_1008F7578, OS_LOG_TYPE_ERROR)) {
      sub_10067E824();
    }
    uint64_t v9 = 111LL;
  }

  sub_100242FAC((uint64_t)buf);
  return v9;
}

void sub_100437F98(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, ...)
{
}

uint64_t sub_100437FC0(uint64_t a1, int a2)
{
  uint64_t v4 = (os_log_s *)qword_1008F7578;
  if (os_log_type_enabled((os_log_t)qword_1008F7578, OS_LOG_TYPE_DEFAULT))
  {
    *(_WORD *)__int128 buf = 0;
    _os_log_impl((void *)&_mh_execute_header, v4, OS_LOG_TYPE_DEFAULT, "Putting device into LE RX test mode", buf, 2u);
  }

  *(void *)__int128 buf = 0LL;
  uint64_t v17 = 0LL;
  sub_100242F28((uint64_t)buf, a1 + 144);
  if (*(_DWORD *)(a1 + 72) == 1)
  {
    if (*(_BYTE *)(a1 + 211))
    {
      if (os_log_type_enabled((os_log_t)qword_1008F7578, OS_LOG_TYPE_ERROR)) {
        sub_10067F320();
      }
      uint64_t v5 = 1LL;
    }

    else
    {
      sub_100242F54((uint64_t)buf);
      char v15 = 0;
      sub_100242CA4(&v15);
      unsigned int v13 = a2 - 2402;
      if (a2 < 2402) {
        unsigned int v13 = a2 - 2401;
      }
      uint64_t v5 = sub_1001D4E20((v13 >> 1), v6, v7, v8, v9, v10, v11, v12);
      sub_100242CD0(&v15);
      if ((_DWORD)v5)
      {
        if (os_log_type_enabled((os_log_t)qword_1008F7578, OS_LOG_TYPE_ERROR)) {
          sub_10067F2C0();
        }
        uint64_t v5 = 111LL;
      }

      else
      {
        *(_BYTE *)(a1 + 211) = 1;
      }

      sub_100242CD8(&v15);
    }
  }

  else
  {
    if (os_log_type_enabled((os_log_t)qword_1008F7578, OS_LOG_TYPE_ERROR)) {
      sub_10067E824();
    }
    uint64_t v5 = 111LL;
  }

  sub_100242FAC((uint64_t)buf);
  return v5;
}

void sub_100438128(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, ...)
{
}

uint64_t sub_100438150(int a1, int a2)
{
  if (qword_1008D60B0 != -1) {
    dispatch_once(&qword_1008D60B0, &stru_1008983A0);
  }
  return sub_1004381A8((uint64_t)off_1008D60A8, a1, a2);
}

uint64_t sub_1004381A8(uint64_t a1, int a2, int a3)
{
  *(_BYTE *)(a1 + 211) = 0;
  uint64_t v5 = (os_log_s *)qword_1008F7578;
  if (os_log_type_enabled((os_log_t)qword_1008F7578, OS_LOG_TYPE_DEFAULT))
  {
    v7[0] = 67109376;
    v7[1] = a2;
    __int16 v8 = 1024;
    int v9 = a3;
    _os_log_impl( (void *)&_mh_execute_header,  v5,  OS_LOG_TYPE_DEFAULT,  "LE test mode stopped : %{bluetooth:OI_STATUS}u, packets = %d",  (uint8_t *)v7,  0xEu);
  }

  if (qword_1008D5F00 != -1) {
    dispatch_once(&qword_1008D5F00, &stru_1008983C0);
  }
  return sub_10040AE08((uint64_t)off_1008D5EF8, a2, a3);
}

uint64_t sub_1004382A0(uint64_t a1)
{
  uint64_t v2 = (os_log_s *)qword_1008F7578;
  if (os_log_type_enabled((os_log_t)qword_1008F7578, OS_LOG_TYPE_DEFAULT))
  {
    *(_WORD *)__int128 buf = 0;
    _os_log_impl((void *)&_mh_execute_header, v2, OS_LOG_TYPE_DEFAULT, "Stopping LE test mode", buf, 2u);
  }

  *(void *)__int128 buf = 0LL;
  uint64_t v14 = 0LL;
  sub_100242F28((uint64_t)buf, a1 + 144);
  if (*(_DWORD *)(a1 + 72) == 1)
  {
    if (*(_BYTE *)(a1 + 211))
    {
      sub_100242F54((uint64_t)buf);
      char v12 = 0;
      sub_100242CA4(&v12);
      uint64_t v10 = sub_1001D520C(sub_100438150, v3, v4, v5, v6, v7, v8, v9);
      sub_100242CD0(&v12);
      if ((_DWORD)v10)
      {
        if (os_log_type_enabled((os_log_t)qword_1008F7578, OS_LOG_TYPE_ERROR)) {
          sub_10067F378();
        }
        uint64_t v10 = 111LL;
      }

      sub_100242CD8(&v12);
    }

    else
    {
      if (os_log_type_enabled((os_log_t)qword_1008F7578, OS_LOG_TYPE_ERROR)) {
        sub_10067F34C();
      }
      uint64_t v10 = 1LL;
    }
  }

  else
  {
    if (os_log_type_enabled((os_log_t)qword_1008F7578, OS_LOG_TYPE_ERROR)) {
      sub_10067E824();
    }
    uint64_t v10 = 111LL;
  }

  sub_100242FAC((uint64_t)buf);
  return v10;
}

void sub_1004383F0(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, ...)
{
}

void sub_100438418(os_unfair_lock_s *a1, void *a2)
{
  uint64_t v3 = a2;
  os_unfair_lock_lock(a1);
  uint64_t v5 = 0LL;
  uint64_t v6 = 0LL;
  uint64_t v7 = 0LL;
  sub_100240540(&v5, (uint64_t)&a1[2]);
  os_unfair_lock_unlock(a1);
  uint64_t v4 = v5;
  if (v5 != v6)
  {
    do
      v3[2](v3, *v4++);
    while (v4 != v6);
    uint64_t v4 = v5;
  }

  if (v4)
  {
    uint64_t v6 = v4;
    operator delete(v4);
  }
}

void sub_1004384AC( _Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void *__p, uint64_t a11)
{
  _Unwind_Resume(a1);
}

void sub_1004384D4(id a1, StackEventListener *a2)
{
}

void sub_1004384E4(id a1, StackEventListener *a2)
{
}

void sub_1004384F4(id a1, StackEventListener *a2)
{
}

void sub_100438504(id a1, StackEventListener *a2)
{
}

void sub_100438524(uint64_t a1)
{
  uint64_t v1 = (void *)sub_100438F00(a1);
  operator delete(v1);
}

void sub_100438558(void ***a1)
{
  uint64_t v2 = *a1;
  if (*v2)
  {
    sub_100438598((uint64_t *)v2);
    operator delete(**a1);
  }

void sub_100438598(uint64_t *a1)
{
  uint64_t v2 = *a1;
  for (uint64_t i = a1[1]; i != v2; i -= 16LL)
  {
    uint64_t v4 = *(std::__shared_weak_count **)(i - 8);
    if (v4) {
      std::__shared_weak_count::__release_weak(v4);
    }
  }

  a1[1] = v2;
}

void sub_1004385E0(uint64_t a1, uint64_t a2)
{
  uint64_t v4 = *(char **)(a1 + 8);
  uint64_t v5 = *(char **)(a1 + 16);
  if (v4 == v5)
  {
    uint64_t v6 = *(char **)(a1 + 8);
    goto LABEL_10;
  }

  uint64_t v6 = *(char **)(a1 + 8);
  while (*(void *)v6 != a2)
  {
    v6 += 8;
    if (v6 == v5)
    {
      uint64_t v6 = *(char **)(a1 + 16);
      break;
    }
  }

  if (v6 == v5)
  {
    if (v4 != v5)
    {
LABEL_11:
      uint64_t v7 = a2;
      sub_100438694(a1 + 8, v6, (char *)&v7);
      sub_100008A30(a1 + 8);
      goto LABEL_12;
    }

char *sub_100438694(uint64_t a1, char *__src, char *a3)
{
  uint64_t v3 = a3;
  uint64_t v4 = __src;
  uint64_t v6 = *(char **)(a1 + 8);
  uint64_t v8 = a1 + 16;
  unint64_t v7 = *(void *)(a1 + 16);
  if ((unint64_t)v6 >= v7)
  {
    unsigned int v13 = *(char **)a1;
    unint64_t v14 = ((uint64_t)&v6[-*(void *)a1] >> 3) + 1;
    if (v14 >> 61) {
      abort();
    }
    uint64_t v15 = __src - v13;
    uint64_t v16 = (__src - v13) >> 3;
    uint64_t v17 = v7 - (void)v13;
    if (v17 >> 2 > v14) {
      unint64_t v14 = v17 >> 2;
    }
    else {
      unint64_t v18 = v14;
    }
    uint64_t v30 = a1 + 16;
    if (v18) {
      uint64_t v19 = (char *)sub_100008BA0(a1 + 16, v18);
    }
    else {
      uint64_t v19 = 0LL;
    }
    uint64_t v20 = &v19[8 * v16];
    std::string __p = v19;
    uint64_t v27 = v20;
    uint64_t v28 = v20;
    int v29 = &v19[8 * v18];
    if (v16 == v18)
    {
      if (v15 < 1)
      {
        if (v13 == v4) {
          unint64_t v22 = 1LL;
        }
        else {
          unint64_t v22 = v15 >> 2;
        }
        uint64_t v23 = (char *)sub_100008BA0(v8, v22);
        uint64_t v20 = &v23[8 * (v22 >> 2)];
        std::string __p = v23;
        uint64_t v27 = v20;
        int v29 = &v23[8 * v24];
        if (v19) {
          operator delete(v19);
        }
      }

      else
      {
        unint64_t v21 = v16 + 2;
        if (v16 >= -1) {
          unint64_t v21 = v16 + 1;
        }
        v20 -= 8 * (v21 >> 1);
        uint64_t v27 = v20;
      }
    }

    *(void *)uint64_t v20 = *(void *)v3;
    uint64_t v28 = v20 + 8;
    uint64_t v4 = sub_100008ADC((void **)a1, (uint64_t)&__p, v4);
    if (v28 != v27) {
      v28 += (v27 - v28 + 7) & 0xFFFFFFFFFFFFFFF8LL;
    }
    if (__p) {
      operator delete(__p);
    }
  }

  else if (__src == v6)
  {
    *(void *)unint64_t __src = *(void *)a3;
    *(void *)(a1 + sub_100242E28(v1 + 8) = __src + 8;
  }

  else
  {
    uint64_t v9 = __src + 8;
    uint64_t v10 = v6 - 8;
    uint64_t v11 = *(void **)(a1 + 8);
    while (v10 < v6)
    {
      uint64_t v12 = *(void *)v10;
      v10 += 8;
      *v11++ = v12;
    }

    *(void *)(a1 + sub_100242E28(v1 + 8) = v11;
    if (v6 != v9) {
      memmove(&v6[-8 * ((v6 - v9) >> 3)], __src, v6 - v9);
    }
    if (v4 <= v3) {
      v3 += 8 * (*(void *)(a1 + 8) > (unint64_t)v3);
    }
    *(void *)uint64_t v4 = *(void *)v3;
  }

  return v4;
}

void sub_100438898( _Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void *__p, uint64_t a11, uint64_t a12)
{
  if (__p) {
    operator delete(__p);
  }
  _Unwind_Resume(exception_object);
}

void sub_1004388D0(id a1, _xpc_activity_s *a2)
{
  if (qword_1008D6788 != -1) {
    dispatch_once(&qword_1008D6788, &stru_100898400);
  }
  int v2 = sub_10040DDD8((uint64_t)off_1008D6780);
  uint64_t v3 = (os_log_s *)qword_1008F7578;
  BOOL v4 = os_log_type_enabled((os_log_t)qword_1008F7578, OS_LOG_TYPE_DEFAULT);
  if (v2)
  {
    if (v4)
    {
      *(_WORD *)__int128 buf = 0;
      _os_log_impl( (void *)&_mh_execute_header,  v3,  OS_LOG_TYPE_DEFAULT,  "Timeout passed. Not Resetting the denylist since Airplane mode is enabled",  buf,  2u);
    }

    +[NSDate timeIntervalSinceReferenceDate](&OBJC_CLASS___NSDate, "timeIntervalSinceReferenceDate");
    double v6 = sub_10042FB88(v5);
    sub_1004300BC(1, v6);
  }

  else
  {
    if (v4)
    {
      *(_WORD *)unint64_t v7 = 0;
      _os_log_impl( (void *)&_mh_execute_header,  v3,  OS_LOG_TYPE_DEFAULT,  "Timeout passed. Resetting the denylist",  v7,  2u);
    }

    if (qword_1008D6198 != -1) {
      dispatch_once(&qword_1008D6198, &stru_100898420);
    }
    sub_1004490F8(0.0);
    sub_10010F948();
  }

void sub_1004389F4( uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  uint64_t v8 = a1;
  if ((a1 - 701) > 0x44)
  {
    if ((_DWORD)a1)
    {
      if (os_log_type_enabled((os_log_t)qword_1008F7578, OS_LOG_TYPE_ERROR)) {
        sub_10067F438();
      }
      goto LABEL_10;
    }
  }

  else if (os_log_type_enabled((os_log_t)qword_1008F7578, OS_LOG_TYPE_ERROR))
  {
    sub_10067F3D8();
  }

  uint64_t v9 = sub_10011E9D8((uint64_t)sub_100438AD8, (uint64_t)"iOS", a3, a4, a5, a6, a7, a8);
  if (!(_DWORD)v9) {
    return;
  }
  uint64_t v8 = v9;
  if (os_log_type_enabled((os_log_t)qword_1008F7578, OS_LOG_TYPE_ERROR)) {
    sub_10067EE40();
  }
LABEL_10:
  uint64_t v10 = (void (*)(uint64_t))off_1008F1018;
  if (off_1008F1018)
  {
    off_1008F1018 = 0LL;
    v10(v8);
  }

void sub_100438AD8(uint64_t a1)
{
  if (sub_100114358() < 4)
  {
    sub_100438B78(a1);
  }

  else
  {
    sub_100432690();
    uint64_t v7 = sub_10011EC58((uint64_t)sub_100438B78, 1u, (uint64_t)byte_1008F0F20, v2, v3, v4, v5, v6);
    if ((_DWORD)v7)
    {
      uint64_t v8 = v7;
      if (os_log_type_enabled((os_log_t)qword_1008F7578, OS_LOG_TYPE_ERROR)) {
        sub_10067F498();
      }
      uint64_t v9 = (void (*)(uint64_t))off_1008F1018;
      if (off_1008F1018)
      {
        off_1008F1018 = 0LL;
        v9(v8);
      }
    }
  }

void sub_100438B78(uint64_t a1)
{
  uint64_t v2 = sub_1002E6BF0();
  int v3 = (*(uint64_t (**)(uint64_t))(*(void *)v2 + 72LL))(v2);
  if ((_DWORD)a1)
  {
    if (os_log_type_enabled((os_log_t)qword_1008F7578, OS_LOG_TYPE_ERROR)) {
      sub_10067F618();
    }
LABEL_31:
    uint64_t v10 = (void (*)(uint64_t))off_1008F1018;
    if (off_1008F1018)
    {
      off_1008F1018 = 0LL;
      v10(a1);
    }

    return;
  }

  if (v3 <= 20)
  {
    if (v3 != 7)
    {
      if (v3 == 8)
      {
        __int16 v4 = 256;
        char v5 = 16;
      }

      else
      {
        if (v3 != 12) {
          goto LABEL_21;
        }
        __int16 v4 = 512;
        char v5 = 12;
      }

      goto LABEL_18;
    }

    __int16 v4 = 256;
    goto LABEL_14;
  }

  switch(v3)
  {
    case 21:
      __int16 v4 = 1024;
      char v5 = 28;
      break;
    case 40:
      __int16 v4 = 1024;
      char v5 = 72;
      break;
    case 42:
      __int16 v4 = 1792;
LABEL_14:
      char v5 = 4;
      break;
    default:
      goto LABEL_21;
  }

void sub_100438D98(id a1)
{
  uint64_t v1 = operator new(0x198uLL);
  sub_100534AB0();
  off_1008D67B0 = v1;
}

void sub_100438DC8(_Unwind_Exception *a1)
{
}

uint64_t sub_100438DDC(uint64_t a1)
{
  if (qword_1008D60B0 != -1) {
    dispatch_once(&qword_1008D60B0, &stru_1008983A0);
  }
  return sub_1004323D0(off_1008D60A8, *(_DWORD *)(a1 + 32));
}

uint64_t sub_100438E34(uint64_t a1)
{
  if (qword_1008D60B0 != -1) {
    dispatch_once(&qword_1008D60B0, &stru_1008983A0);
  }
  uint64_t result = sub_100433240((uint64_t)off_1008D60A8);
  if ((_DWORD)result)
  {
    *(_BYTE *)(a1 + sub_100242E28(v1 + 8) = 1;
  }

  else
  {
    *(void *)(a1 + 16) = 100LL;
    uint64_t v3 = sub_100404EB8();
    return sub_100405744(v3, (_BYTE *)a1);
  }

  return result;
}

uint64_t sub_100438EAC(uint64_t a1)
{
  if (qword_1008D60B0 != -1) {
    dispatch_once(&qword_1008D60B0, &stru_1008983A0);
  }
  return sub_1004330C4((uint64_t)off_1008D60A8, *(_DWORD *)(a1 + 32), *(unsigned __int8 *)(a1 + 36));
}

uint64_t sub_100438F00(uint64_t a1)
{
  *(void *)a1 = off_100897FC8;
  *(void *)(a1 + sub_100242E28(v1 + 8) = &off_100898068;
  *(void *)(a1 + 16) = off_100898080;
  *(void *)(a1 + 24) = &off_1008980B0;
  *(void *)(a1 + sub_100242FAC(v1 - 32) = &off_1008980C8;
  *(void *)(a1 + 4sub_100414D2C(qword_1008F72C0, 0) = &off_1008980E0;
  *(void *)(a1 + 4sub_100242E28(v1 + 8) = off_1008980F8;
  *(void *)(a1 + 56) = &off_100898138;
  sub_100242E28(a1 + 488);

  sub_100242E28(a1 + 408);
  sub_100242E28(a1 + 224);
  sub_100242E28(a1 + 144);
  __int16 v4 = (void **)(a1 + 120);
  sub_100438558(&v4);
  uint64_t v2 = *(void **)(a1 + 88);
  if (v2)
  {
    *(void *)(a1 + 96) = v2;
    operator delete(v2);
  }

  return a1;
}

void sub_100438FC4(id a1)
{
  uint64_t v1 = operator new(0x230uLL);
  sub_10042BA44((uint64_t)v1);
  off_1008D60A8 = v1;
}

void sub_100438FF4(_Unwind_Exception *a1)
{
}

void sub_100439008(id a1)
{
  uint64_t v1 = operator new(0x2B0uLL);
  sub_10040749C((uint64_t)v1);
  off_1008D5EF8 = v1;
}

void sub_100439038(_Unwind_Exception *a1)
{
}

void sub_10043904C(id a1)
{
  uint64_t v1 = operator new(0x2C0uLL);
  sub_1004219F0();
  off_1008D60C8 = v1;
}

void sub_10043907C(_Unwind_Exception *a1)
{
}

void sub_100439090(id a1)
{
  uint64_t v1 = operator new(0xA8uLL);
  sub_10040D0A0((uint64_t)v1);
  off_1008D6780 = v1;
}

void sub_1004390C0(_Unwind_Exception *a1)
{
}

void sub_1004390D4(id a1)
{
  uint64_t v1 = (char *)operator new(0x200uLL);
  *(void *)uint64_t v1 = off_100898F60;
  *((void *)v1 + 1) = &off_100898FF0;
  *((void *)v1 + 2) = off_100899008;
  *((void *)v1 + 3) = &off_100899060;
  *((void *)v1 + 4) = &off_100899078;
  sub_100242DC4(v1 + 40);
  *((void *)v1 + 14) = 0LL;
  *((_DWORD *)v1 + 3sub_100414D2C(qword_1008F72C0, 0) = 0;
  *((void *)v1 + 17) = 0LL;
  *((void *)v1 + 1sub_100242E28(v1 + 8) = 0LL;
  *((void *)v1 + 16) = 0LL;
  *(_OWORD *)(v1 + 155) = 0u;
  *(_OWORD *)(v1 + 171) = 0u;
  *(_OWORD *)(v1 + 187) = 0u;
  *(_WORD *)(v1 + 203) = 1;
  *((void *)v1 + 26) = 0LL;
  *((_WORD *)v1 + 10sub_100242E28(v1 + 8) = 256;
  *((void *)v1 + 29) = 0LL;
  *((void *)v1 + 2sub_100242E28(v1 + 8) = v1 + 232;
  *((void *)v1 + sub_100242FAC(v1 - 32) = 0LL;
  *((void *)v1 + 33) = 0LL;
  *((void *)v1 + 3sub_100414D2C(qword_1008F72C0, 0) = 0LL;
  *((void *)v1 + 31) = v1 + 256;
  v1[272] = 0;
  *((_DWORD *)v1 + 69) = 0;
  v1[280] = 0;
  *((_WORD *)v1 + 189) = 0;
  *(void *)(v1 + 313) = 0LL;
  *(_OWORD *)(v1 + 30sub_100414D2C(qword_1008F72C0, 0) = 0u;
  *(_OWORD *)(v1 + 284) = 0u;
  *(_OWORD *)(v1 + 32sub_100242E28(v1 + 8) = 0u;
  *(_OWORD *)(v1 + 344) = 0u;
  *(_OWORD *)(v1 + 36sub_100414D2C(qword_1008F72C0, 0) = 0u;
  v1[376] = 0;
  *((void *)v1 + 51) = v1 + 416;
  *((void *)v1 + 52) = 0LL;
  *((void *)v1 + 55) = 0LL;
  *((void *)v1 + 56) = 0LL;
  *((void *)v1 + 53) = 0LL;
  *((void *)v1 + 54) = v1 + 440;
  *((void *)v1 + 57) = v1 + 464;
  *((void *)v1 + 5sub_100242E28(v1 + 8) = 0LL;
  *((void *)v1 + 59) = 0LL;
  *((void *)v1 + 6sub_100414D2C(qword_1008F72C0, 0) = @"XZ";
  *((void *)v1 + sub_100242E28(v3 + 62) = 0LL;
  *((_DWORD *)v1 + 126) = 0;
  off_1008D6190 = v1;
}

void sub_1004391DC(_Unwind_Exception *a1)
{
}

void sub_1004391F0(id a1)
{
  uint64_t v1 = operator new(0x138uLL);
  sub_1003FE3E0((uint64_t)v1);
  off_1008D5F48 = v1;
}

void sub_100439220(_Unwind_Exception *a1)
{
}

void sub_100439234(id a1)
{
  uint64_t v1 = operator new(0x128uLL);
  sub_1005C69F8();
  off_1008D5F28 = v1;
}

void sub_100439264(_Unwind_Exception *a1)
{
}

void sub_100439278(id a1)
{
  uint64_t v1 = operator new(0x18uLL);
  sub_10064DFE0();
  off_1008D9980 = v1;
}

void sub_1004392A8(_Unwind_Exception *a1)
{
}

void sub_1004392BC(id a1)
{
  uint64_t v1 = operator new(0x48uLL);
  sub_10054A778((uint64_t)v1);
  off_1008D90F0 = v1;
}

void sub_1004392EC(_Unwind_Exception *a1)
{
}

void sub_100439300(id a1)
{
  uint64_t v1 = operator new(0x1A0uLL);
  sub_1002769A4();
  off_1008D67C0 = v1;
}

void sub_100439330(_Unwind_Exception *a1)
{
}

void sub_100439344(id a1)
{
  uint64_t v1 = operator new(0x98uLL);
  sub_1003C97E4((uint64_t)v1);
  off_1008D67E0 = v1;
}

void sub_100439374(_Unwind_Exception *a1)
{
}

void sub_100439388(id a1)
{
  uint64_t v1 = operator new(0x18uLL);
  *(void *)uint64_t v1 = 0LL;
  void v1[2] = 0;
  *((_BYTE *)v1 + 12) = 0;
  v1[4] = 0;
  qword_1008D9058 = (uint64_t)v1;
}

void sub_1004393B8(id a1)
{
  uint64_t v1 = operator new(0x260uLL);
  sub_1005285C8((uint64_t)v1);
  off_1008D67A0 = v1;
}

void sub_1004393E8(_Unwind_Exception *a1)
{
}

char *sub_1004393FC(char *result, void *a2, void *a3, unint64_t a4)
{
  if (a4)
  {
    uint64_t v6 = result;
    uint64_t result = sub_1003ADD88(result, a4);
    uint64_t v7 = (void *)*((void *)v6 + 1);
    while (a2 != a3)
    {
      uint64_t v8 = a2[1];
      *uint64_t v7 = *a2;
      v7[1] = v8;
      if (v8)
      {
        uint64_t v9 = (unint64_t *)(v8 + 16);
        do
          unint64_t v10 = __ldxr(v9);
        while (__stxr(v10 + 1, v9));
      }

      a2 += 2;
      v7 += 2;
    }

    *((void *)v6 + 1) = v7;
  }

  return result;
}

  ;
}

void sub_100439498(void *a1, uint64_t a2, os_log_t log, const char *a4, ...)
{
}

  ;
}

void sub_1004394CC()
{
  uint64_t v0 = objc_autoreleasePoolPush();
  sub_100242DC4(&unk_1008F73D8);
  __cxa_atexit((void (*)(void *))sub_100242E28, &unk_1008F73D8, (void *)&_mh_execute_header);
  sub_100243040(&stru_1008F7418);
  __cxa_atexit((void (*)(void *))sub_1002430A8, &stru_1008F7418, (void *)&_mh_execute_header);
  sub_100243040(&stru_1008F7448);
  __cxa_atexit((void (*)(void *))sub_1002430A8, &stru_1008F7448, (void *)&_mh_execute_header);
  sub_100243040(&stru_1008F7480);
  __cxa_atexit((void (*)(void *))sub_1002430A8, &stru_1008F7480, (void *)&_mh_execute_header);
  sub_100242DC4(&unk_1008F74B0);
  __cxa_atexit((void (*)(void *))sub_100242E28, &unk_1008F74B0, (void *)&_mh_execute_header);
  objc_autoreleasePoolPop(v0);
}

uint64_t sub_1004395C4(unint64_t a1, uint64_t *a2, uint64_t a3, unint64_t *a4)
{
  if (qword_1008D63D8 != -1) {
    dispatch_once(&qword_1008D63D8, &stru_100898590);
  }
  unsigned int v13 = 0LL;
  unint64_t v14 = 0LL;
  sub_100452724((uint64_t)off_1008D63D0, a1, a4, (uint64_t *)&v13);
  if (v13)
  {
    sub_10044EB34(v13, *a4, a2, a3);
    uint64_t v8 = 0LL;
  }

  else
  {
    uint64_t v8 = 7LL;
  }

  uint64_t v9 = v14;
  if (v14)
  {
    p_shared_owners = (unint64_t *)&v14->__shared_owners_;
    do
      unint64_t v11 = __ldaxr(p_shared_owners);
    while (__stlxr(v11 - 1, p_shared_owners));
    if (!v11)
    {
      ((void (*)(std::__shared_weak_count *))v9->__on_zero_shared)(v9);
      std::__shared_weak_count::__release_weak(v9);
    }
  }

  return v8;
}

void sub_1004396A0( _Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9)
{
}

uint64_t sub_1004396B4(unint64_t *a1)
{
  if (qword_1008D63D8 != -1) {
    dispatch_once(&qword_1008D63D8, &stru_100898590);
  }
  sub_100452BA4(off_1008D63D0, *a1);
  *a1 = 0LL;
  return 0LL;
}

uint64_t sub_100439710(unint64_t a1, unsigned int a2, int a3)
{
  if (qword_1008D63D8 != -1) {
    dispatch_once(&qword_1008D63D8, &stru_100898590);
  }
  uint64_t v24 = 0LL;
  uint64_t v25 = 0LL;
  sub_1004529CC((uint64_t)off_1008D63D0, a1, &v24);
  if (v24)
  {
    if (qword_1008D61A8 != -1) {
      dispatch_once(&qword_1008D61A8, &stru_100898570);
    }
    uint64_t v6 = sub_100496954((void *)qword_1008D61A0, a1);
    if (v6)
    {
      uint64_t v7 = (os_log_s *)qword_1008F7578;
      if (os_log_type_enabled((os_log_t)qword_1008F7578, OS_LOG_TYPE_DEFAULT))
      {
        sub_100494958(v6, (uint64_t)__p);
        uint64_t v8 = v23 >= 0 ? __p : (void **)__p[0];
        *(_DWORD *)__int128 buf = 136446210;
        uint64_t v27 = v8;
        _os_log_impl( (void *)&_mh_execute_header,  v7,  OS_LOG_TYPE_DEFAULT,  "Session %{public}s is asking to start classic scan",  buf,  0xCu);
        if (v23 < 0) {
          operator delete(__p[0]);
        }
      }
    }

    if (qword_1008D63D8 != -1) {
      dispatch_once(&qword_1008D63D8, &stru_100898590);
    }
    uint64_t v9 = off_1008D63D0;
    uint64_t v20 = v24;
    unint64_t v21 = v25;
    if (v25)
    {
      p_shared_owners = (unint64_t *)&v25->__shared_owners_;
      do
        unint64_t v11 = __ldxr(p_shared_owners);
      while (__stxr(v11 + 1, p_shared_owners));
    }

    uint64_t v12 = sub_100453844((uint64_t)v9, &v20, a2, a3);
    unsigned int v13 = v21;
    if (v21)
    {
      unint64_t v14 = (unint64_t *)&v21->__shared_owners_;
      do
        unint64_t v15 = __ldaxr(v14);
      while (__stlxr(v15 - 1, v14));
      if (!v15)
      {
        ((void (*)(std::__shared_weak_count *))v13->__on_zero_shared)(v13);
        std::__shared_weak_count::__release_weak(v13);
      }
    }
  }

  else
  {
    uint64_t v12 = 7LL;
  }

  uint64_t v16 = v25;
  if (v25)
  {
    uint64_t v17 = (unint64_t *)&v25->__shared_owners_;
    do
      unint64_t v18 = __ldaxr(v17);
    while (__stlxr(v18 - 1, v17));
    if (!v18)
    {
      ((void (*)(std::__shared_weak_count *))v16->__on_zero_shared)(v16);
      std::__shared_weak_count::__release_weak(v16);
    }
  }

  return v12;
}

void sub_100439960( _Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, ...)
{
}

uint64_t sub_100439990(unint64_t a1)
{
  if (qword_1008D63D8 != -1) {
    dispatch_once(&qword_1008D63D8, &stru_100898590);
  }
  uint64_t v15 = 0LL;
  uint64_t v16 = 0LL;
  sub_1004529CC((uint64_t)off_1008D63D0, a1, &v15);
  if (v15)
  {
    if (qword_1008D63D8 != -1) {
      dispatch_once(&qword_1008D63D8, &stru_100898590);
    }
    uint64_t v2 = off_1008D63D0;
    uint64_t v13 = v15;
    unint64_t v14 = v16;
    if (v16)
    {
      p_shared_owners = (unint64_t *)&v16->__shared_owners_;
      do
        unint64_t v4 = __ldxr(p_shared_owners);
      while (__stxr(v4 + 1, p_shared_owners));
    }

    uint64_t v5 = sub_100453844((uint64_t)v2, &v13, 2u, 2048);
    uint64_t v6 = v14;
    if (v14)
    {
      uint64_t v7 = (unint64_t *)&v14->__shared_owners_;
      do
        unint64_t v8 = __ldaxr(v7);
      while (__stlxr(v8 - 1, v7));
      if (!v8)
      {
        ((void (*)(std::__shared_weak_count *))v6->__on_zero_shared)(v6);
        std::__shared_weak_count::__release_weak(v6);
      }
    }
  }

  else
  {
    uint64_t v5 = 7LL;
  }

  uint64_t v9 = v16;
  if (v16)
  {
    unint64_t v10 = (unint64_t *)&v16->__shared_owners_;
    do
      unint64_t v11 = __ldaxr(v10);
    while (__stlxr(v11 - 1, v10));
    if (!v11)
    {
      ((void (*)(std::__shared_weak_count *))v9->__on_zero_shared)(v9);
      std::__shared_weak_count::__release_weak(v9);
    }
  }

  return v5;
}

void sub_100439ADC( _Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, char a11)
{
}

uint64_t sub_100439AF8(unint64_t a1)
{
  if (qword_1008D63D8 != -1) {
    dispatch_once(&qword_1008D63D8, &stru_100898590);
  }
  uint64_t v15 = 0LL;
  uint64_t v16 = 0LL;
  sub_1004529CC((uint64_t)off_1008D63D0, a1, &v15);
  if (v15)
  {
    if (qword_1008D63D8 != -1) {
      dispatch_once(&qword_1008D63D8, &stru_100898590);
    }
    uint64_t v2 = off_1008D63D0;
    uint64_t v13 = v15;
    unint64_t v14 = v16;
    if (v16)
    {
      p_shared_owners = (unint64_t *)&v16->__shared_owners_;
      do
        unint64_t v4 = __ldxr(p_shared_owners);
      while (__stxr(v4 + 1, p_shared_owners));
    }

    uint64_t v5 = sub_1004530CC(v2, &v13);
    uint64_t v6 = v14;
    if (v14)
    {
      uint64_t v7 = (unint64_t *)&v14->__shared_owners_;
      do
        unint64_t v8 = __ldaxr(v7);
      while (__stlxr(v8 - 1, v7));
      if (!v8)
      {
        ((void (*)(std::__shared_weak_count *))v6->__on_zero_shared)(v6);
        std::__shared_weak_count::__release_weak(v6);
      }
    }
  }

  else
  {
    uint64_t v5 = 7LL;
  }

  uint64_t v9 = v16;
  if (v16)
  {
    unint64_t v10 = (unint64_t *)&v16->__shared_owners_;
    do
      unint64_t v11 = __ldaxr(v10);
    while (__stlxr(v11 - 1, v10));
    if (!v11)
    {
      ((void (*)(std::__shared_weak_count *))v9->__on_zero_shared)(v9);
      std::__shared_weak_count::__release_weak(v9);
    }
  }

  return v5;
}

void sub_100439C3C( _Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, char a11)
{
}

uint64_t sub_100439C58(unint64_t a1, unint64_t *a2, unint64_t *a3, unint64_t a4)
{
  if (qword_1008D63D8 != -1) {
    dispatch_once(&qword_1008D63D8, &stru_100898590);
  }
  uint64_t v23 = 0LL;
  uint64_t v24 = 0LL;
  sub_1004529CC((uint64_t)off_1008D63D0, a1, &v23);
  if (v23)
  {
    std::string __p = 0LL;
    unint64_t v21 = 0LL;
    uint64_t v22 = 0LL;
    if ((void **)(v23 + 256) == &__p)
    {
      unint64_t v8 = 0LL;
    }

    else
    {
      sub_100240C80( (char *)&__p,  *(char **)(v23 + 256),  *(void *)(v23 + 264),  (uint64_t)(*(void *)(v23 + 264) - *(void *)(v23 + 256)) >> 3);
      unint64_t v8 = 0LL;
      if (a4 && __p != v21)
      {
        uint64_t v9 = (char *)__p + 8;
        unint64_t v10 = 1LL;
        do
        {
          uint64_t v11 = *((void *)v9 - 1);
          if (qword_1008D5F50 != -1) {
            dispatch_once(&qword_1008D5F50, &stru_1008985B0);
          }
          unint64_t v12 = sub_1003FEFA8((uint64_t)off_1008D5F48, a1, v11);
          if (!v12)
          {
            uint64_t v15 = 7LL;
            goto LABEL_20;
          }

          *a2++ = v12;
          unint64_t v13 = v10 + 1;
          if (v10 >= a4) {
            break;
          }
          ++v10;
          BOOL v14 = v9 == v21;
          v9 += 8;
        }

        while (!v14);
        unint64_t v8 = v13 - 1;
      }
    }

    uint64_t v15 = 0LL;
    *a3 = v8;
LABEL_20:
    if (__p)
    {
      unint64_t v21 = (char *)__p;
      operator delete(__p);
    }
  }

  else
  {
    uint64_t v15 = 7LL;
  }

  uint64_t v16 = v24;
  if (v24)
  {
    p_shared_owners = (unint64_t *)&v24->__shared_owners_;
    do
      unint64_t v18 = __ldaxr(p_shared_owners);
    while (__stlxr(v18 - 1, p_shared_owners));
    if (!v18)
    {
      ((void (*)(std::__shared_weak_count *))v16->__on_zero_shared)(v16);
      std::__shared_weak_count::__release_weak(v16);
    }
  }

  return v15;
}

void sub_100439E1C( _Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void *__p, uint64_t a11, uint64_t a12, char a13)
{
  if (__p) {
    operator delete(__p);
  }
  sub_100032BD4((uint64_t)&a13);
  _Unwind_Resume(a1);
}

uint64_t sub_100439E44(unint64_t a1, const void *a2, size_t a3)
{
  if (qword_1008D63D8 != -1) {
    dispatch_once(&qword_1008D63D8, &stru_100898590);
  }
  uint64_t v11 = 0LL;
  unint64_t v12 = 0LL;
  sub_1004529CC((uint64_t)off_1008D63D0, a1, &v11);
  if (v11) {
    uint64_t v6 = sub_10044F7BC(v11, a2, a3);
  }
  else {
    uint64_t v6 = 7LL;
  }
  uint64_t v7 = v12;
  if (v12)
  {
    p_shared_owners = (unint64_t *)&v12->__shared_owners_;
    do
      unint64_t v9 = __ldaxr(p_shared_owners);
    while (__stlxr(v9 - 1, p_shared_owners));
    if (!v9)
    {
      ((void (*)(std::__shared_weak_count *))v7->__on_zero_shared)(v7);
      std::__shared_weak_count::__release_weak(v7);
    }
  }

  return v6;
}

void sub_100439F14( _Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9)
{
}

uint64_t sub_100439F28(unint64_t a1, const void *a2, size_t a3)
{
  if (qword_1008D63D8 != -1) {
    dispatch_once(&qword_1008D63D8, &stru_100898590);
  }
  uint64_t v11 = 0LL;
  unint64_t v12 = 0LL;
  sub_1004529CC((uint64_t)off_1008D63D0, a1, &v11);
  if (v11) {
    uint64_t v6 = sub_10044F9EC(v11, a2, a3);
  }
  else {
    uint64_t v6 = 7LL;
  }
  uint64_t v7 = v12;
  if (v12)
  {
    p_shared_owners = (unint64_t *)&v12->__shared_owners_;
    do
      unint64_t v9 = __ldaxr(p_shared_owners);
    while (__stlxr(v9 - 1, p_shared_owners));
    if (!v9)
    {
      ((void (*)(std::__shared_weak_count *))v7->__on_zero_shared)(v7);
      std::__shared_weak_count::__release_weak(v7);
    }
  }

  return v6;
}

void sub_100439FF8( _Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9)
{
}

void sub_10043A00C(id a1)
{
  uint64_t v1 = operator new(0x120uLL);
  sub_100495250();
  qword_1008D61A0 = (uint64_t)v1;
}

void sub_10043A03C(_Unwind_Exception *a1)
{
}

void sub_10043A050(id a1)
{
  uint64_t v1 = operator new(0x260uLL);
  sub_100451734((uint64_t)v1);
  off_1008D63D0 = v1;
}

void sub_10043A080(_Unwind_Exception *a1)
{
}

void sub_10043A094(id a1)
{
  uint64_t v1 = operator new(0x138uLL);
  sub_1003FE3E0((uint64_t)v1);
  off_1008D5F48 = v1;
}

void sub_10043A0C4(_Unwind_Exception *a1)
{
}

uint64_t sub_10043A0D8(uint64_t a1, uint64_t a2, __int16 a3)
{
  uint64_t v4 = sub_10020852C(a1, a2, a3);
  *(void *)uint64_t v4 = off_1008985E0;
  *(_OWORD *)(v4 + 192) = 0u;
  *(_OWORD *)(v4 + 20sub_100242E28(v1 + 8) = 0u;
  *(_DWORD *)(v4 + 224) = 1065353216;
  sub_100242DC4(v4 + 232);
  *(void *)(a1 + 296) = 0LL;
  uint64_t v5 = objc_claimAutoreleasedReturnValue(+[NSMutableData dataWithLength:](&OBJC_CLASS___NSMutableData, "dataWithLength:", 0LL));
  uint64_t v6 = *(void **)(a1 + 296);
  *(void *)(a1 + 296) = v5;

  return a1;
}

void sub_10043A158(_Unwind_Exception *a1)
{
  sub_100242E28(v3);
  sub_100051650(v2);
  sub_100208604(v1);
  _Unwind_Resume(a1);
}

uint64_t sub_10043A18C(uint64_t a1)
{
  *(void *)a1 = off_1008985E0;
  for (uint64_t i = *(void **)(a1 + 208); i; uint64_t i = (void *)*i)
  {
    if (!i[3])
    {
      uint64_t v3 = (os_log_s *)qword_1008F7730;
      if (os_log_type_enabled((os_log_t)qword_1008F7730, OS_LOG_TYPE_FAULT)) {
        sub_10067F678(v5, &v6, v3);
      }
    }
  }

  sub_100242E28(a1 + 232);
  sub_100051650(a1 + 192);
  sub_100208604(a1);
  return a1;
}

void sub_10043A27C(uint64_t a1)
{
  uint64_t v1 = (void *)sub_10043A18C(a1);
  operator delete(v1);
}

void sub_10043A290(uint64_t a1)
{
  if (*(_BYTE *)(a1 + 42))
  {
    uint64_t v1 = (os_log_s *)qword_1008F7730;
    if (os_log_type_enabled((os_log_t)qword_1008F7730, OS_LOG_TYPE_DEFAULT))
    {
      *(_WORD *)uint64_t v4 = 0;
      _os_log_impl( (void *)&_mh_execute_header,  v1,  OS_LOG_TYPE_DEFAULT,  "Keyholed input device is already scheduled",  v4,  2u);
    }
  }

  else
  {
    *(_BYTE *)(a1 + 42) = 1;
    for (uint64_t i = *(void **)(a1 + 208); i; uint64_t i = (void *)*i)
      IOHIDUserDeviceScheduleWithDispatchQueue(i[3], *(void *)(a1 + 16));
  }

void sub_10043A328(uint64_t a1)
{
  if (*(_BYTE *)(a1 + 42))
  {
    *(_BYTE *)(a1 + 42) = 0;
    for (uint64_t i = *(void *)(a1 + 208); i; uint64_t i = sub_10043ACFC((void *)(a1 + 192), (uint64_t *)i))
    {
      IOHIDUserDeviceUnscheduleFromDispatchQueue(*(void *)(i + 24), *(void *)(a1 + 16));
      CFRelease(*(CFTypeRef *)(i + 24));
    }

    sub_100208EBC(a1, 0, -536870212, 0LL);
  }

  else
  {
    uint64_t v3 = (os_log_s *)qword_1008F7730;
    if (os_log_type_enabled((os_log_t)qword_1008F7730, OS_LOG_TYPE_DEFAULT))
    {
      *(_WORD *)uint64_t v4 = 0;
      _os_log_impl( (void *)&_mh_execute_header,  v3,  OS_LOG_TYPE_DEFAULT,  "Keyholed input device is not scheduled",  v4,  2u);
    }
  }

uint64_t sub_10043A400(uint64_t a1, void *a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6)
{
  id v11 = [a2 mutableCopy];
  unint64_t v12 = (void *)objc_claimAutoreleasedReturnValue(+[NSData dataWithBytes:length:](&OBJC_CLASS___NSData, "dataWithBytes:length:", a3, a4));
  [v11 setObject:v12 forKeyedSubscript:@"ReportDescriptor"];
  unint64_t v13 = (void *)objc_claimAutoreleasedReturnValue(+[NSNumber numberWithUnsignedChar:](&OBJC_CLASS___NSNumber, "numberWithUnsignedChar:", a5));
  [v11 setObject:v13 forKeyedSubscript:@"KeyholeReportID"];

  BOOL v14 = (void *)objc_claimAutoreleasedReturnValue(+[NSNumber numberWithUnsignedChar:](&OBJC_CLASS___NSNumber, "numberWithUnsignedChar:", a6));
  [v11 setObject:v14 forKeyedSubscript:@"bInterfaceNumber"];

  uint64_t v15 = IOHIDUserDeviceCreateWithOptions(kCFAllocatorDefault, v11, 1LL);
  if (v15)
  {
    LOBYTE(v24) = a5;
    *((void *)&v24 + 1) = v15;
    sub_10043AD3C(a1 + 192, (unsigned __int8 *)&v24, &v24);
  }

  else
  {
    uint64_t v16 = (os_log_s *)qword_1008F7730;
    if (os_log_type_enabled((os_log_t)qword_1008F7730, OS_LOG_TYPE_ERROR)) {
      sub_10067F6C4((uint64_t)v11, v16, v17, v18, v19, v20, v21, v22);
    }
  }

  return v15;
}

void sub_10043A558(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

uint64_t sub_10043A594(uint64_t a1, void *a2)
{
  *(_OWORD *)uint64_t v15 = xmmword_1006C303A;
  *(void *)&v15[14] = 0xC002810125001503LL;
  id v3 = [a2 mutableCopy];
  uint64_t v4 = (void *)objc_claimAutoreleasedReturnValue(+[NSData dataWithBytes:length:](&OBJC_CLASS___NSData, "dataWithBytes:length:", v15, 22LL));
  [v3 setObject:v4 forKeyedSubscript:@"ReportDescriptor"];
  [v3 setObject:&off_1008C3180 forKeyedSubscript:@"ExtendedData"];
  uint64_t v5 = IOHIDUserDeviceCreateWithOptions(kCFAllocatorDefault, v3, 1LL);
  if (v5)
  {
    LOBYTE(v14) = 0;
    *((void *)&v14 + 1) = v5;
    sub_10043AD3C(a1 + 192, (unsigned __int8 *)&v14, &v14);
    IOHIDUserDeviceRegisterGetReportWithReturnLengthCallback(v5, sub_100209084, a1);
    IOHIDUserDeviceRegisterSetReportCallback(v5, sub_100209088, a1);
  }

  else
  {
    uint64_t v6 = (os_log_s *)qword_1008F7730;
    if (os_log_type_enabled((os_log_t)qword_1008F7730, OS_LOG_TYPE_ERROR)) {
      sub_10067F728((uint64_t)v3, v6, v7, v8, v9, v10, v11, v12);
    }
  }

  return v5;
}

void sub_10043A6F0(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

uint64_t sub_10043A71C(uint64_t a1, int a2, int a3, void *a4, uint64_t *a5, int a6)
{
  v26[0] = 0LL;
  v26[1] = 0LL;
  sub_100242F28((uint64_t)v26, a1 + 232);
  uint64_t v12 = (os_log_s *)qword_1008F7730;
  if (os_log_type_enabled((os_log_t)qword_1008F7730, OS_LOG_TYPE_DEFAULT))
  {
    uint64_t v13 = *a5;
    *(_DWORD *)__int128 buf = 67109888;
    int v28 = a2;
    __int16 v29 = 1024;
    int v30 = a3;
    __int16 v31 = 2048;
    uint64_t v32 = v13;
    __int16 v33 = 1024;
    int v34 = a6;
    _os_log_impl( (void *)&_mh_execute_header,  v12,  OS_LOG_TYPE_DEFAULT,  "getReportWithKeyhole type = %u, reportID = 0x%x, max reportCFIndex Length = %lu, keyholeID = 0x%x",  buf,  0x1Eu);
  }

  if (a4 && a5)
  {
    uint64_t v14 = *a5;
    *a5 = 0LL;
    v24[0] = _NSConcreteStackBlock;
    v24[1] = 3221225472LL;
    void v24[2] = sub_10043AA28;
    v24[3] = &unk_100898660;
    void v24[4] = a1;
    int v25 = a3;
    uint64_t v15 = sub_1002093D0(a1, v24);
    if ((_DWORD)v15)
    {
      if (os_log_type_enabled((os_log_t)qword_1008F7730, OS_LOG_TYPE_ERROR)) {
        sub_10067F808();
      }
    }

    else
    {
      int64_t v16 = v14 + 1;
      uint64_t v23 = v16;
      *(void *)(a1 + sub_100242FAC(v1 - 32) = &v23;
      *(void *)(a1 + 24) = malloc(v16);
      v20[0] = _NSConcreteStackBlock;
      v20[1] = 3221225472LL;
      void v20[2] = sub_10043AA74;
      v20[3] = &unk_100898680;
      v20[4] = a1;
      int v21 = a2;
      char v22 = a6;
      uint64_t v15 = sub_1002093D0(a1, v20);
      if ((_DWORD)v15)
      {
        uint64_t v17 = (os_log_s *)qword_1008F7730;
        if (os_log_type_enabled((os_log_t)qword_1008F7730, OS_LOG_TYPE_ERROR))
        {
          *(_DWORD *)__int128 buf = 67109632;
          int v28 = a3;
          __int16 v29 = 1024;
          int v30 = a6;
          __int16 v31 = 1024;
          LODWORD(vsub_100242FAC(v1 - 32) = v15;
          _os_log_error_impl( (void *)&_mh_execute_header,  v17,  OS_LOG_TYPE_ERROR,  "getReportWithKeyhole 0x%x with keyholeID 0x%x failed: 0x%x",  buf,  0x14u);
        }
      }

      else
      {
        uint64_t v18 = v23;
        if (v23 < 2 || v23 > v16)
        {
          if (os_log_type_enabled((os_log_t)qword_1008F7730, OS_LOG_TYPE_ERROR)) {
            sub_10067F78C();
          }
        }

        else
        {
          memcpy(a4, (const void *)(*(void *)(a1 + 24) + 1LL), v23 - 1);
          *a5 = v18 - 1;
        }
      }

      *(void *)(a1 + sub_100242FAC(v1 - 32) = 0LL;
      free(*(void **)(a1 + 24));
      *(void *)(a1 + 24) = 0LL;
    }
  }

  else
  {
    uint64_t v15 = 3758097090LL;
    if (os_log_type_enabled((os_log_t)qword_1008F7730, OS_LOG_TYPE_ERROR)) {
      sub_10067F884();
    }
  }

  sub_100242FAC((uint64_t)v26);
  return v15;
}

void sub_10043AA08( _Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, ...)
{
}

uint64_t sub_10043AA28(uint64_t a1)
{
  uint64_t v1 = *(void *)(a1 + 32);
  __int16 v3 = 255;
  HIBYTE(v3) = *(_DWORD *)(a1 + 40);
  return (*(uint64_t (**)(void, uint64_t, uint64_t, uint64_t, __int16 *, uint64_t))(**(void **)(v1 + 8) + 8LL))( *(void *)(v1 + 8),  v1,  3LL,  255LL,  &v3,  2LL);
}

uint64_t sub_10043AA74(uint64_t a1)
{
  return (***(uint64_t (****)(void))(*(void *)(a1 + 32) + 8LL))(*(void *)(*(void *)(a1 + 32) + 8LL));
}

uint64_t sub_10043AA9C(uint64_t a1, int a2, int a3, const void *a4, size_t a5, int a6)
{
  v20[0] = 0LL;
  v20[1] = 0LL;
  sub_100242F28((uint64_t)v20, a1 + 232);
  uint64_t v12 = (os_log_s *)qword_1008F7730;
  if (os_log_type_enabled((os_log_t)qword_1008F7730, OS_LOG_TYPE_DEFAULT))
  {
    *(_DWORD *)__int128 buf = 67109888;
    int v22 = a2;
    __int16 v23 = 1024;
    int v24 = a3;
    __int16 v25 = 2048;
    size_t v26 = a5;
    __int16 v27 = 1024;
    int v28 = a6;
    _os_log_impl( (void *)&_mh_execute_header,  v12,  OS_LOG_TYPE_DEFAULT,  "setReportWithKeyhole type = %u, reportID = 0x%x, reportCFIndex Length = %lu, keyholeID = 0x%x",  buf,  0x1Eu);
  }

  if (a4 && a5)
  {
    uint64_t v13 = malloc(a5 + 1);
    *uint64_t v13 = a6;
    memcpy(v13 + 1, a4, a5);
    v17[0] = _NSConcreteStackBlock;
    v17[1] = 3221225472LL;
    void v17[2] = sub_10043ACD0;
    v17[3] = &unk_1008986A0;
    int v18 = a2;
    char v19 = a6;
    void v17[4] = a1;
    v17[5] = v13;
    v17[6] = a5 + 1;
    uint64_t v14 = sub_1002093D0(a1, v17);
    if ((_DWORD)v14)
    {
      uint64_t v15 = (os_log_s *)qword_1008F7730;
      if (os_log_type_enabled((os_log_t)qword_1008F7730, OS_LOG_TYPE_ERROR))
      {
        *(_DWORD *)__int128 buf = 67109632;
        int v22 = a3;
        __int16 v23 = 1024;
        int v24 = a6;
        __int16 v25 = 1024;
        LODWORD(v26) = v14;
        _os_log_error_impl( (void *)&_mh_execute_header,  v15,  OS_LOG_TYPE_ERROR,  "setReportWithKeyhole 0x%x with keyholeID 0x%x failed: 0x%x",  buf,  0x14u);
      }
    }

    free(v13);
  }

  else
  {
    uint64_t v14 = 3758097090LL;
    if (os_log_type_enabled((os_log_t)qword_1008F7730, OS_LOG_TYPE_ERROR)) {
      sub_10067F8E4();
    }
  }

  sub_100242FAC((uint64_t)v20);
  return v14;
}

void sub_10043ACB4( _Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, ...)
{
}

uint64_t sub_10043ACD0(uint64_t a1)
{
  return (*(uint64_t (**)(void))(**(void **)(*(void *)(a1 + 32) + 8LL) + 8LL))(*(void *)(*(void *)(a1 + 32) + 8LL));
}

uint64_t sub_10043ACFC(void *a1, uint64_t *a2)
{
  uint64_t v2 = *a2;
  sub_1002402B8(a1, a2, (uint64_t)&__p);
  __int16 v3 = __p;
  std::string __p = 0LL;
  if (v3) {
    operator delete(v3);
  }
  return v2;
}

void *sub_10043AD3C(uint64_t a1, unsigned __int8 *a2, _OWORD *a3)
{
  unint64_t v5 = *a2;
  unint64_t v6 = *(void *)(a1 + 8);
  if (v6)
  {
    uint8x8_t v7 = (uint8x8_t)vcnt_s8((int8x8_t)v6);
    v7.i16[0] = vaddlv_u8(v7);
    if (v7.u32[0] > 1uLL)
    {
      unint64_t v8 = *a2;
      if (v6 <= v5) {
        unint64_t v8 = v5 % v6;
      }
    }

    else
    {
      unint64_t v8 = ((_DWORD)v6 - 1) & v5;
    }

    uint64_t v9 = *(void ***)(*(void *)a1 + 8 * v8);
    if (v9)
    {
      uint64_t v10 = *v9;
      if (*v9)
      {
        do
        {
          unint64_t v11 = v10[1];
          if (v11 == v5)
          {
          }

          else
          {
            if (v7.u32[0] > 1uLL)
            {
              if (v11 >= v6) {
                v11 %= v6;
              }
            }

            else
            {
              v11 &= v6 - 1;
            }

            if (v11 != v8) {
              break;
            }
          }

          uint64_t v10 = (void *)*v10;
        }

        while (v10);
      }
    }
  }

  else
  {
    unint64_t v8 = 0LL;
  }

  uint64_t v10 = operator new(0x20uLL);
  void *v10 = 0LL;
  v10[1] = v5;
  *((_OWORD *)v10 + 1) = *a3;
  float v12 = (float)(unint64_t)(*(void *)(a1 + 24) + 1LL);
  float v13 = *(float *)(a1 + 32);
  if (!v6 || (float)(v13 * (float)v6) < v12)
  {
    BOOL v14 = 1LL;
    if (v6 >= 3) {
      BOOL v14 = (v6 & (v6 - 1)) != 0;
    }
    unint64_t v15 = v14 | (2 * v6);
    unint64_t v16 = vcvtps_u32_f32(v12 / v13);
    if (v15 <= v16) {
      size_t v17 = v16;
    }
    else {
      size_t v17 = v15;
    }
    sub_10005141C(a1, v17);
    unint64_t v6 = *(void *)(a1 + 8);
    if ((v6 & (v6 - 1)) != 0)
    {
      if (v6 <= v5) {
        unint64_t v8 = v5 % v6;
      }
      else {
        unint64_t v8 = v5;
      }
    }

    else
    {
      unint64_t v8 = ((_DWORD)v6 - 1) & v5;
    }
  }

  uint64_t v18 = *(void *)a1;
  char v19 = *(void **)(*(void *)a1 + 8 * v8);
  if (v19)
  {
    void *v10 = *v19;
LABEL_38:
    void *v19 = v10;
    goto LABEL_39;
  }

  void *v10 = *(void *)(a1 + 16);
  *(void *)(a1 + 16) = v10;
  *(void *)(v18 + 8 * vsub_100242E28(v1 + 8) = a1 + 16;
  if (*v10)
  {
    unint64_t v20 = *(void *)(*v10 + 8LL);
    if ((v6 & (v6 - 1)) != 0)
    {
      if (v20 >= v6) {
        v20 %= v6;
      }
    }

    else
    {
      v20 &= v6 - 1;
    }

    char v19 = (void *)(*(void *)a1 + 8 * v20);
    goto LABEL_38;
  }

void sub_10043AF48(_Unwind_Exception *a1)
{
}

uint64_t sub_10043AF5C(uint64_t a1, uint64_t a2, int a3, int a4)
{
  *(void *)a1 = off_100898730;
  sub_100242DC4(a1 + 8);
  *(_BYTE *)(a1 + 72) = 0;
  *(_DWORD *)(a1 + sub_10023DF50(v3 + 76) = a4;
  *(void *)a1 = off_1008986D0;
  *(void *)(a1 + 8sub_100414D2C(qword_1008F72C0, 0) = a2;
  *(void *)(a1 + 8sub_100242E28(v1 + 8) = off_100898708;
  sub_100242DC4(a1 + 96);
  *(_DWORD *)(a1 + 16sub_100414D2C(qword_1008F72C0, 0) = 0;
  *(_DWORD *)(a1 + 1sub_100242FAC(v30 - 64) = a3;
  *(void *)(a1 + 1sub_10023DF50(v3 + 76) = 0LL;
  *(void *)(a1 + 184) = 0LL;
  *(void *)(a1 + 16sub_100242E28(v1 + 8) = 0LL;
  return a1;
}

void sub_10043AFE0(_Unwind_Exception *a1)
{
  *uint64_t v1 = v3;
  sub_100242E28(v2);
  _Unwind_Resume(a1);
}

void *sub_10043AFFC(void *a1)
{
  *a1 = off_1008986D0;
  a1[11] = off_100898708;
  uint64_t v2 = (void *)a1[21];
  if (v2)
  {
    a1[22] = v2;
    operator delete(v2);
  }

  sub_100242E28(a1 + 12);
  *a1 = off_100898730;
  sub_100242E28(a1 + 1);
  return a1;
}

void *sub_10043B060(uint64_t a1)
{
  return sub_10043AFFC((void *)(a1 - 88));
}

void sub_10043B068(void *a1)
{
  uint64_t v1 = sub_10043AFFC(a1);
  operator delete(v1);
}

void sub_10043B07C(uint64_t a1)
{
  uint64_t v1 = sub_10043AFFC((void *)(a1 - 88));
  operator delete(v1);
}

uint64_t sub_10043B094(uint64_t a1, uint64_t a2, int a3)
{
  v8[0] = 0LL;
  v8[1] = 0LL;
  sub_100242F28((uint64_t)v8, a1 + 96);
  sub_1003FE288((char **)(a1 + 168), a2);
  sub_100242F54((uint64_t)v8);
  if (!a3)
  {
    int v7 = 0;
    sub_1000B0740(&v7, 0LL);
    v7 += 120;
    sub_1003E3A30(a2, &v7);
    (*(void (**)(void, uint64_t))(**(void **)(a1 + 80) + 24LL))(*(void *)(a1 + 80), a2);
  }

  sub_10043B154(a1);
  return sub_100242FAC((uint64_t)v8);
}

void sub_10043B13C(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, ...)
{
}

uint64_t sub_10043B154(uint64_t a1)
{
  v18[0] = 0LL;
  v18[1] = 0LL;
  sub_100242F28((uint64_t)v18, a1 + 96);
  uint64_t v2 = (os_log_s *)qword_1008F7590;
  if (os_log_type_enabled((os_log_t)qword_1008F7590, OS_LOG_TYPE_INFO))
  {
    int v3 = *(_DWORD *)(a1 + 160);
    *(_DWORD *)__int128 buf = 67109120;
    int v20 = v3;
    _os_log_impl((void *)&_mh_execute_header, v2, OS_LOG_TYPE_INFO, "Stepping scan with mode %u", buf, 8u);
  }

  int v4 = *(_DWORD *)(a1 + 160);
  if (v4 == 16)
  {
LABEL_11:
    if (sub_10043B7B4(a1)) {
      return sub_100242FAC((uint64_t)v18);
    }
    goto LABEL_12;
  }

  if (!v4)
  {
    if (sub_10043B554(a1) && sub_10043B7B4(a1))
    {
      buf[0] = 0;
      sub_100242CA4(buf);
      if (sub_10011EA10((uint64_t)sub_10043B848, 0x870u, v5, v6, v7, v8, v9, v10)
        && os_log_type_enabled((os_log_t)qword_1008F7590, OS_LOG_TYPE_ERROR))
      {
        sub_10067F978();
      }

      sub_100242CD8(buf);
      return sub_100242FAC((uint64_t)v18);
    }

    goto LABEL_11;
  }

void sub_10043B2EC( _Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, char a11)
{
}

uint64_t sub_10043B324(uint64_t a1, uint64_t a2, int a3)
{
  return sub_10043B094(a1 - 88, a2, a3);
}

void sub_10043B32C(uint64_t a1)
{
  v3[0] = 0LL;
  v3[1] = 0LL;
  sub_100242F28((uint64_t)v3, a1 + 8);
  int v2 = *(unsigned __int8 *)(a1 + 72);
  sub_100242FAC((uint64_t)v3);
  if (v2)
  {
    sub_1001EE2A0();
  }

  else
  {
    sub_10043B388(a1);
    sub_10043B154(a1);
  }

uint64_t sub_10043B388(uint64_t a1)
{
  v3[0] = 0LL;
  v3[1] = 0LL;
  sub_100242F28((uint64_t)v3, a1 + 8);
  *(_BYTE *)(a1 + 72) = 1;
  sub_100242FAC((uint64_t)v3);
  return (***(uint64_t (****)(void, uint64_t))(a1 + 80))(*(void *)(a1 + 80), a1);
}

uint64_t sub_10043B3E0(uint64_t a1)
{
  v6[0] = 0LL;
  v6[1] = 0LL;
  sub_100242F28((uint64_t)v6, a1 + 96);
  int v2 = (os_log_s *)qword_1008F7590;
  if (os_log_type_enabled((os_log_t)qword_1008F7590, OS_LOG_TYPE_DEFAULT))
  {
    int v3 = *(_DWORD *)(a1 + 160);
    *(_DWORD *)__int128 buf = 67109120;
    int v8 = v3;
    _os_log_impl((void *)&_mh_execute_header, v2, OS_LOG_TYPE_DEFAULT, "Stopping scan with mode %u", buf, 8u);
  }

  int v4 = *(_DWORD *)(a1 + 160);
  if (v4 != 128)
  {
    if (v4 == 16)
    {
      *(void *)(a1 + 1sub_10023DF50(v3 + 76) = *(void *)(a1 + 168);
      *(_DWORD *)(a1 + 16sub_100414D2C(qword_1008F72C0, 0) = 128;
      sub_100242F54((uint64_t)v6);
      if (qword_1008D9600 != -1) {
        dispatch_once(&qword_1008D9600, &stru_100898750);
      }
      sub_10041AB60(qword_1008D95F8, 1);
    }

    else if (v4)
    {
      if (os_log_type_enabled((os_log_t)qword_1008F7590, OS_LOG_TYPE_ERROR)) {
        sub_10067F9A4();
      }
    }

    else
    {
      *(_DWORD *)(a1 + 16sub_100414D2C(qword_1008F72C0, 0) = 128;
    }
  }

  return sub_100242FAC((uint64_t)v6);
}

void sub_10043B538( _Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9)
{
}

uint64_t sub_10043B554(uint64_t a1)
{
  std::string __p = 0LL;
  size_t v17 = 0LL;
  uint64_t v18 = 0LL;
  if (qword_1008D5F00 != -1) {
    dispatch_once(&qword_1008D5F00, &stru_100898770);
  }
  int v2 = sub_10040A6A8((uint64_t)off_1008D5EF8, (void ***)&__p);
  int v3 = (uint64_t *)__p;
  if (v2 || v17 == __p)
  {
    uint64_t v4 = 0LL;
    goto LABEL_5;
  }

  v14[0] = sub_10043B8E4;
  sub_10043BA84( (uint64_t)__p,  v17,  (uint64_t (**)(uint64_t, uint64_t))v14,  126 - 2 * __clz(((char *)v17 - (_BYTE *)__p) >> 3),  1);
  int v3 = (uint64_t *)__p;
  if (__p != v17)
  {
    while (1)
    {
      unsigned int v6 = *(_DWORD *)(a1 + 164);
      if (!v6) {
        goto LABEL_23;
      }
      uint64_t v7 = *v3;
      unsigned int v8 = 1;
      while ((v6 & v8) == 0)
      {
LABEL_15:
        v8 *= 2;
        if (v8 > v6) {
          goto LABEL_23;
        }
      }

      uint64_t v9 = (os_log_s *)qword_1008F7590;
      if (os_log_type_enabled((os_log_t)qword_1008F7590, OS_LOG_TYPE_DEFAULT))
      {
        sub_1003CF00C(v7, v14);
        int v10 = v15;
        uint64_t v11 = (void **)v14[0];
        int v12 = sub_1003E39EC(v7);
        *(_DWORD *)__int128 buf = 136446466;
        uint64_t v13 = v14;
        if (v10 < 0) {
          uint64_t v13 = v11;
        }
        int v20 = v13;
        __int16 v21 = 1024;
        int v22 = v12;
        _os_log_impl( (void *)&_mh_execute_header,  v9,  OS_LOG_TYPE_DEFAULT,  "Checking device %{public}s with last seen time %u",  buf,  0x12u);
        if (v15 < 0) {
          operator delete(v14[0]);
        }
      }

      sub_10043B918((void *)a1, v7);
LABEL_23:
      if (++v3 == v17)
      {
        uint64_t v4 = 1LL;
        int v3 = (uint64_t *)__p;
        goto LABEL_5;
      }
    }

    unsigned int v6 = *(_DWORD *)(a1 + 164);
    goto LABEL_15;
  }

  uint64_t v4 = 1LL;
LABEL_5:
  if (v3)
  {
    size_t v17 = v3;
    operator delete(v3);
  }

  return v4;
}

void sub_10043B774( _Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, void *__p, uint64_t a12, int a13, __int16 a14, char a15, char a16, void *a17, uint64_t a18)
{
  if (a16 < 0) {
    operator delete(__p);
  }
  if (a17) {
    operator delete(a17);
  }
  _Unwind_Resume(exception_object);
}

BOOL sub_10043B7B4(uint64_t a1)
{
  int v2 = *(uint64_t **)(a1 + 168);
  int v3 = *(uint64_t **)(a1 + 176);
  if (v2 == v3)
  {
    *(_DWORD *)(a1 + 16sub_100414D2C(qword_1008F72C0, 0) = 128;
  }

  else
  {
    uint64_t v4 = *v2;
    *(_DWORD *)(a1 + 16sub_100414D2C(qword_1008F72C0, 0) = 16;
    if (qword_1008D9600 != -1) {
      dispatch_once(&qword_1008D9600, &stru_100898750);
    }
    sub_10041AA14(qword_1008D95F8, v4, a1 + 88, 1, 2);
  }

  return v2 != v3;
}

void sub_10043B848(int a1)
{
  if (a1)
  {
    if (os_log_type_enabled((os_log_t)qword_1008F7590, OS_LOG_TYPE_ERROR)) {
      sub_10067F9D0();
    }
  }

uint64_t sub_10043B88C(uint64_t a1, uint64_t a2)
{
  v5[0] = 0LL;
  v5[1] = 0LL;
  sub_100242F28((uint64_t)v5, a1 + 8);
  *(_BYTE *)(a1 + 72) = 0;
  sub_100242FAC((uint64_t)v5);
  return (*(uint64_t (**)(void, uint64_t))(**(void **)(a1 + 80) + 40LL))(*(void *)(a1 + 80), a2);
}

BOOL sub_10043B8E4(uint64_t a1, uint64_t a2)
{
  int v3 = sub_1003E39EC(a1);
  return v3 > (int)sub_1003E39EC(a2);
}

void sub_10043B918(void *a1, uint64_t a2)
{
  uint64_t v4 = (char **)(a1 + 21);
  if (!sub_1003FE254((uint64_t)(a1 + 21), a2))
  {
    unint64_t v5 = a1[23];
    unsigned int v6 = (uint64_t *)a1[22];
    if ((unint64_t)v6 >= v5)
    {
      uint64_t v8 = ((char *)v6 - *v4) >> 3;
      uint64_t v9 = v5 - (void)*v4;
      uint64_t v10 = v9 >> 2;
      else {
        unint64_t v11 = v10;
      }
      if (v11) {
        int v12 = (char *)sub_100008BA0((uint64_t)(a1 + 23), v11);
      }
      else {
        int v12 = 0LL;
      }
      uint64_t v13 = (uint64_t *)&v12[8 * v8];
      uint64_t v14 = &v12[8 * v11];
      *uint64_t v13 = a2;
      uint64_t v7 = v13 + 1;
      uint64_t v16 = (char *)a1[21];
      char v15 = (char *)a1[22];
      if (v15 != v16)
      {
        do
        {
          uint64_t v17 = *((void *)v15 - 1);
          v15 -= 8;
          *--uint64_t v13 = v17;
        }

        while (v15 != v16);
        char v15 = *v4;
      }

      a1[21] = v13;
      a1[22] = v7;
      a1[23] = v14;
      if (v15) {
        operator delete(v15);
      }
    }

    else
    {
      uint64_t *v6 = a2;
      uint64_t v7 = v6 + 1;
    }

    a1[22] = v7;
  }

void sub_10043B9FC(id a1)
{
  uint64_t v1 = operator new(0x58uLL);
  sub_10041A094(v1);
  qword_1008D95F8 = (uint64_t)v1;
}

void sub_10043BA2C(_Unwind_Exception *a1)
{
}

void sub_10043BA40(id a1)
{
  uint64_t v1 = operator new(0x2B0uLL);
  sub_10040749C((uint64_t)v1);
  off_1008D5EF8 = v1;
}

void sub_10043BA70(_Unwind_Exception *a1)
{
}

uint64_t sub_10043BA84( uint64_t result, uint64_t *a2, uint64_t (**a3)(uint64_t, uint64_t), uint64_t a4, char a5)
{
  uint64_t v8 = (uint64_t *)result;
LABEL_2:
  uint64_t v9 = v8;
LABEL_3:
  uint64_t v10 = 1 - a4;
  while (2)
  {
    uint64_t v8 = v9;
    uint64_t v11 = v10;
    uint64_t v12 = (char *)a2 - (char *)v9;
    unint64_t v13 = a2 - v9;
    switch(v13)
    {
      case 0uLL:
      case 1uLL:
        return result;
      case 2uLL:
        uint64_t result = (*a3)(*(a2 - 1), *v9);
        if ((_DWORD)result)
        {
          uint64_t v20 = *v9;
          *uint64_t v9 = *(a2 - 1);
          *(a2 - 1) = v20;
        }

        return result;
      case 3uLL:
        return sub_10043BF18(v9, v9 + 1, a2 - 1, (unsigned int (**)(void))a3);
      case 4uLL:
        return sub_10043C3CC(v9, v9 + 1, v9 + 2, a2 - 1, (unsigned int (**)(void))a3);
      case 5uLL:
        return sub_10043C47C(v9, v9 + 1, v9 + 2, v9 + 3, a2 - 1, (unsigned int (**)(void))a3);
      default:
        if (v12 <= 191)
        {
          if ((a5 & 1) != 0) {
            return sub_10043BDC4((uint64_t)v9, a2, a3);
          }
          else {
            return sub_10043BE84((uint64_t)v9, a2, a3);
          }
        }

        if (v11 != 1)
        {
          unint64_t v14 = v13 >> 1;
          char v15 = &v9[v13 >> 1];
          if ((unint64_t)v12 < 0x401)
          {
            sub_10043BF18(&v9[v13 >> 1], v9, a2 - 1, (unsigned int (**)(void))a3);
            if ((a5 & 1) != 0) {
              goto LABEL_12;
            }
          }

          else
          {
            sub_10043BF18(v9, &v9[v13 >> 1], a2 - 1, (unsigned int (**)(void))a3);
            sub_10043BF18(v9 + 1, v15 - 1, a2 - 2, (unsigned int (**)(void))a3);
            sub_10043BF18(v9 + 2, &v9[v14 + 1], a2 - 3, (unsigned int (**)(void))a3);
            sub_10043BF18(v15 - 1, v15, &v9[v14 + 1], (unsigned int (**)(void))a3);
            uint64_t v16 = *v9;
            *uint64_t v9 = *v15;
            *char v15 = v16;
            if ((a5 & 1) != 0) {
              goto LABEL_12;
            }
          }

          if (((*a3)(*(v9 - 1), *v9) & 1) == 0)
          {
            uint64_t result = (uint64_t)sub_10043C004(v9, a2, a3);
            uint64_t v9 = (uint64_t *)result;
            goto LABEL_17;
          }

uint64_t sub_10043BDC4(uint64_t result, uint64_t *a2, uint64_t (**a3)(uint64_t, uint64_t))
{
  if ((uint64_t *)result != a2)
  {
    uint64_t v4 = (void *)result;
    unint64_t v5 = (uint64_t *)(result + 8);
    if ((uint64_t *)(result + 8) != a2)
    {
      uint64_t v7 = 0LL;
      uint64_t v8 = (uint64_t *)result;
      do
      {
        uint64_t v10 = *v8;
        uint64_t v9 = v8[1];
        uint64_t v8 = v5;
        uint64_t result = (*a3)(v9, v10);
        if ((_DWORD)result)
        {
          uint64_t v11 = *v8;
          uint64_t v12 = v7;
          while (1)
          {
            *(void *)((char *)v4 + v12 + sub_100242E28(v1 + 8) = *(void *)((char *)v4 + v12);
            if (!v12) {
              break;
            }
            uint64_t result = (*a3)(v11, *(void *)((char *)v4 + v12 - 8));
            v12 -= 8LL;
            if ((result & 1) == 0)
            {
              unint64_t v13 = (void *)((char *)v4 + v12 + 8);
              goto LABEL_10;
            }
          }

          unint64_t v13 = v4;
LABEL_10:
          *unint64_t v13 = v11;
        }

        unint64_t v5 = v8 + 1;
        v7 += 8LL;
      }

      while (v8 + 1 != a2);
    }
  }

  return result;
}

uint64_t sub_10043BE84(uint64_t result, void *a2, uint64_t (**a3)(uint64_t, uint64_t))
{
  if ((void *)result != a2)
  {
    uint64_t v4 = (void *)result;
    for (uint64_t i = (void *)(result + 8); v4 + 1 != a2; uint64_t i = v4 + 1)
    {
      uint64_t v8 = *v4;
      uint64_t v7 = v4[1];
      uint64_t v4 = i;
      uint64_t result = (*a3)(v7, v8);
      if ((_DWORD)result)
      {
        uint64_t v9 = *v4;
        uint64_t v10 = v4;
        do
        {
          uint64_t v11 = v10;
          uint64_t v12 = *--v10;
          *uint64_t v11 = v12;
          uint64_t result = (*a3)(v9, *(v11 - 2));
        }

        while ((result & 1) != 0);
        void *v10 = v9;
      }
    }
  }

  return result;
}

uint64_t sub_10043BF18(void *a1, void *a2, void *a3, unsigned int (**a4)(void))
{
  char v8 = ((uint64_t (*)(void, void))*a4)(*a2, *a1);
  uint64_t result = ((uint64_t (*)(void, void))*a4)(*a3, *a2);
  if ((v8 & 1) == 0)
  {
    if (!(_DWORD)result) {
      return result;
    }
    uint64_t v11 = *a2;
    *a2 = *a3;
    *a3 = v11;
    uint64_t v12 = *a1;
    *a1 = *a2;
    *a2 = v12;
    return 2LL;
  }

  uint64_t v10 = *a1;
  if (!(_DWORD)result)
  {
    *a1 = *a2;
    *a2 = v10;
    if (!(*a4)(*a3)) {
      return 1LL;
    }
    uint64_t v13 = *a2;
    *a2 = *a3;
    *a3 = v13;
    return 2LL;
  }

  *a1 = *a3;
  *a3 = v10;
  return 1LL;
}

uint64_t *sub_10043C004(uint64_t *a1, uint64_t *a2, uint64_t (**a3)(uint64_t, uint64_t))
{
  uint64_t v4 = a2;
  uint64_t v6 = *a1;
  if (((*a3)(*a1, *(a2 - 1)) & 1) != 0)
  {
    uint64_t v7 = a1;
    do
    {
      uint64_t v8 = v7[1];
      ++v7;
    }

    while (((*a3)(v6, v8) & 1) == 0);
  }

  else
  {
    uint64_t v9 = a1 + 1;
    do
    {
      uint64_t v7 = v9;
      if (v9 >= v4) {
        break;
      }
      ++v9;
    }

    while (!(*a3)(v6, *v7));
  }

  if (v7 < v4)
  {
    do
      uint64_t v10 = *--v4;
    while (((*a3)(v6, v10) & 1) != 0);
  }

  while (v7 < v4)
  {
    uint64_t v11 = *v7;
    *uint64_t v7 = *v4;
    *uint64_t v4 = v11;
    do
    {
      uint64_t v12 = v7[1];
      ++v7;
    }

    while (!(*a3)(v6, v12));
    do
      uint64_t v13 = *--v4;
    while (((*a3)(v6, v13) & 1) != 0);
  }

  if (v7 - 1 != a1) {
    *a1 = *(v7 - 1);
  }
  *(v7 - 1) = v6;
  return v7;
}

uint64_t *sub_10043C110(uint64_t *a1, uint64_t *a2, uint64_t (**a3)(uint64_t, uint64_t))
{
  uint64_t v6 = 0LL;
  uint64_t v7 = *a1;
  do
    char v8 = (*a3)(a1[++v6], v7);
  while ((v8 & 1) != 0);
  uint64_t v9 = &a1[v6];
  uint64_t v10 = &a1[v6 - 1];
  if (v6 == 1)
  {
    do
    {
      if (v9 >= a2) {
        break;
      }
      uint64_t v12 = *--a2;
    }

    while (((*a3)(v12, v7) & 1) == 0);
  }

  else
  {
    do
      uint64_t v11 = *--a2;
    while (!(*a3)(v11, v7));
  }

  if (v9 < a2)
  {
    uint64_t v13 = a2;
    unint64_t v14 = v9;
    do
    {
      uint64_t v15 = *v14;
      *unint64_t v14 = *v13;
      *uint64_t v13 = v15;
      do
      {
        uint64_t v16 = v14[1];
        ++v14;
      }

      while (((*a3)(v16, v7) & 1) != 0);
      do
        uint64_t v17 = *--v13;
      while (!(*a3)(v17, v7));
    }

    while (v14 < v13);
    uint64_t v10 = v14 - 1;
  }

  if (v10 != a1) {
    *a1 = *v10;
  }
  uint64_t *v10 = v7;
  return v10;
}

BOOL sub_10043C228(void *a1, void *a2, unsigned int (**a3)(void))
{
  uint64_t v6 = a2 - a1;
  BOOL result = 1LL;
  switch(v6)
  {
    case 0LL:
    case 1LL:
      return result;
    case 2LL:
      if (((unsigned int (*)(void, void))*a3)(*(a2 - 1), *a1))
      {
        uint64_t v8 = *a1;
        *a1 = *(a2 - 1);
        *(a2 - 1) = v8;
      }

      return 1LL;
    case 3LL:
      sub_10043BF18(a1, a1 + 1, a2 - 1, a3);
      return 1LL;
    case 4LL:
      sub_10043C3CC(a1, a1 + 1, a1 + 2, a2 - 1, a3);
      return 1LL;
    case 5LL:
      sub_10043C47C(a1, a1 + 1, a1 + 2, a1 + 3, a2 - 1, a3);
      return 1LL;
    default:
      uint64_t v9 = a1 + 2;
      sub_10043BF18(a1, a1 + 1, a1 + 2, a3);
      uint64_t v10 = a1 + 3;
      if (a1 + 3 == a2) {
        return 1LL;
      }
      uint64_t v11 = 0LL;
      int v12 = 0;
      break;
  }

  while (1)
  {
    if (((unsigned int (*)(void, void))*a3)(*v10, *v9))
    {
      uint64_t v13 = *v10;
      uint64_t v14 = v11;
      while (1)
      {
        uint64_t v15 = (char *)a1 + v14;
        *(void *)((char *)a1 + v14 + 24) = *(void *)((char *)a1 + v14 + 16);
        if (v14 == -16) {
          break;
        }
        v14 -= 8LL;
        if ((((uint64_t (*)(uint64_t, void))*a3)(v13, *((void *)v15 + 1)) & 1) == 0)
        {
          uint64_t v16 = (void *)((char *)a1 + v14 + 24);
          goto LABEL_12;
        }
      }

      uint64_t v16 = a1;
LABEL_12:
      void *v16 = v13;
      if (++v12 == 8) {
        return v10 + 1 == a2;
      }
    }

    uint64_t v9 = v10;
    v11 += 8LL;
    if (++v10 == a2) {
      return 1LL;
    }
  }

uint64_t sub_10043C3CC( void *a1, void *a2, void *a3, void *a4, unsigned int (**a5)(void))
{
  uint64_t result = ((uint64_t (*)(void, void))*a5)(*a4, *a3);
  if ((_DWORD)result)
  {
    uint64_t v11 = *a3;
    *a3 = *a4;
    *a4 = v11;
    uint64_t result = ((uint64_t (*)(void, void))*a5)(*a3, *a2);
    if ((_DWORD)result)
    {
      uint64_t v12 = *a2;
      *a2 = *a3;
      *a3 = v12;
      uint64_t result = ((uint64_t (*)(void, void))*a5)(*a2, *a1);
      if ((_DWORD)result)
      {
        uint64_t v13 = *a1;
        *a1 = *a2;
        *a2 = v13;
      }
    }
  }

  return result;
}

uint64_t sub_10043C47C( void *a1, void *a2, void *a3, void *a4, void *a5, unsigned int (**a6)(void))
{
  uint64_t result = ((uint64_t (*)(void, void))*a6)(*a5, *a4);
  if ((_DWORD)result)
  {
    uint64_t v13 = *a4;
    *a4 = *a5;
    *a5 = v13;
    uint64_t result = ((uint64_t (*)(void, void))*a6)(*a4, *a3);
    if ((_DWORD)result)
    {
      uint64_t v14 = *a3;
      *a3 = *a4;
      *a4 = v14;
      uint64_t result = ((uint64_t (*)(void, void))*a6)(*a3, *a2);
      if ((_DWORD)result)
      {
        uint64_t v15 = *a2;
        *a2 = *a3;
        *a3 = v15;
        uint64_t result = ((uint64_t (*)(void, void))*a6)(*a2, *a1);
        if ((_DWORD)result)
        {
          uint64_t v16 = *a1;
          *a1 = *a2;
          *a2 = v16;
        }
      }
    }
  }

  return result;
}

uint64_t *sub_10043C554(char *a1, char *a2, uint64_t *a3, uint64_t (**a4)(uint64_t, uint64_t))
{
  if (a1 != a2)
  {
    uint64_t v8 = a2 - a1;
    uint64_t v9 = (a2 - a1) >> 3;
    if (a2 - a1 >= 9)
    {
      unint64_t v10 = (unint64_t)(v9 - 2) >> 1;
      unint64_t v11 = v10 + 1;
      uint64_t v12 = &a1[8 * v10];
      do
      {
        sub_10043C6A8((uint64_t)a1, (unsigned int (**)(void, void))a4, v9, v12);
        v12 -= 8;
        --v11;
      }

      while (v11);
    }

    uint64_t v13 = a2;
    if (a2 != (char *)a3)
    {
      uint64_t v14 = (uint64_t *)a2;
      do
      {
        if ((*a4)(*v14, *(void *)a1))
        {
          uint64_t v15 = *v14;
          *uint64_t v14 = *(void *)a1;
          *(void *)a1 = v15;
          sub_10043C6A8((uint64_t)a1, (unsigned int (**)(void, void))a4, v9, a1);
        }

        ++v14;
      }

      while (v14 != a3);
      uint64_t v13 = (char *)a3;
    }

    if (v8 >= 9)
    {
      uint64_t v16 = (unint64_t)v8 >> 3;
      uint64_t v17 = a2 - 8;
      do
      {
        uint64_t v18 = *(void *)a1;
        BOOL v19 = (char *)sub_10043C7C8(a1, (unsigned int (**)(void, void))a4, v16);
        if (v17 == v19)
        {
          *(void *)BOOL v19 = v18;
        }

        else
        {
          *(void *)BOOL v19 = *(void *)v17;
          *(void *)uint64_t v17 = v18;
          sub_10043C874((uint64_t)a1, (uint64_t)(v19 + 8), a4, (v19 + 8 - a1) >> 3);
        }

        v17 -= 8;
      }

      while (v16-- > 2);
    }

    return (uint64_t *)v13;
  }

  return a3;
}

uint64_t sub_10043C6A8( uint64_t result, unsigned int (**a2)(void, void), uint64_t a3, void *a4)
{
  unint64_t v4 = a3 - 2;
  if (a3 >= 2)
  {
    unint64_t v5 = a4;
    uint64_t v6 = result;
    int64_t v7 = v4 >> 1;
    if ((uint64_t)(v4 >> 1) >= ((uint64_t)a4 - result) >> 3)
    {
      uint64_t v10 = ((uint64_t)a4 - result) >> 2;
      uint64_t v11 = v10 + 1;
      uint64_t v12 = (void *)(result + 8 * (v10 + 1));
      uint64_t v13 = v10 + 2;
      if (v10 + 2 < a3 && (*a2)(*v12, v12[1]))
      {
        ++v12;
        uint64_t v11 = v13;
      }

      uint64_t result = ((uint64_t (*)(void, void))*a2)(*v12, *v5);
      if ((result & 1) == 0)
      {
        uint64_t v14 = *v5;
        do
        {
          uint64_t v15 = v12;
          *unint64_t v5 = *v12;
          if (v7 < v11) {
            break;
          }
          uint64_t v16 = (2 * v11) | 1;
          uint64_t v12 = (void *)(v6 + 8 * v16);
          if (2 * v11 + 2 < a3)
          {
            if ((*a2)(*v12, v12[1]))
            {
              ++v12;
              uint64_t v16 = 2 * v11 + 2;
            }
          }

          uint64_t result = ((uint64_t (*)(void, uint64_t))*a2)(*v12, v14);
          unint64_t v5 = v15;
          uint64_t v11 = v16;
        }

        while (!(_DWORD)result);
        *uint64_t v15 = v14;
      }
    }
  }

  return result;
}

void *sub_10043C7C8(void *a1, unsigned int (**a2)(void, void), uint64_t a3)
{
  uint64_t v6 = 0LL;
  uint64_t v7 = a3 - 2;
  if (a3 < 2) {
    uint64_t v7 = a3 - 1;
  }
  uint64_t v8 = v7 >> 1;
  do
  {
    uint64_t v9 = &a1[v6 + 1];
    uint64_t v10 = (2 * v6) | 1;
    uint64_t v11 = 2 * v6 + 2;
    if (v11 < a3 && (*a2)(a1[v6 + 1], a1[v6 + 2]))
    {
      ++v9;
      uint64_t v10 = v11;
    }

    *a1 = *v9;
    a1 = v9;
    uint64_t v6 = v10;
  }

  while (v10 <= v8);
  return v9;
}

uint64_t sub_10043C874(uint64_t result, uint64_t a2, uint64_t (**a3)(uint64_t, uint64_t), uint64_t a4)
{
  unint64_t v4 = a4 - 2;
  if (a4 >= 2)
  {
    uint64_t v6 = result;
    unint64_t v7 = v4 >> 1;
    uint64_t v8 = (uint64_t *)(result + 8 * (v4 >> 1));
    uint64_t v9 = (uint64_t *)(a2 - 8);
    uint64_t result = (*a3)(*v8, *(void *)(a2 - 8));
    if ((_DWORD)result)
    {
      uint64_t v10 = *v9;
      do
      {
        uint64_t v11 = v8;
        *uint64_t v9 = *v8;
        if (!v7) {
          break;
        }
        unint64_t v7 = (v7 - 1) >> 1;
        uint64_t v8 = (uint64_t *)(v6 + 8 * v7);
        uint64_t result = (*a3)(*v8, v10);
        uint64_t v9 = v11;
      }

      while ((result & 1) != 0);
      *uint64_t v11 = v10;
    }
  }

  return result;
}

void *sub_10043C910(void *a1, uint64_t a2)
{
  *a1 = &off_100891BA0;
  sub_100242DC4(a1 + 1);
  a1[9] = a2;
  return a1;
}

void *sub_10043C948(void *a1, const std::string *a2)
{
  *a1 = &off_1008987A0;
  a1[1] = 30000LL;
  a1[2] = 0LL;
  unint64_t v4 = (std::string *)sub_10002418C(a1 + 3, "");
  a1[6] = a1[1];
  std::string::operator=(v4, a2);
  uint64_t v13 = 0LL;
  uint64_t v5 = sub_1002E6E00();
  sub_10002418C(buf, "ManagerStateWatchdog");
  sub_10002418C(__p, "WatchdogDuration");
  int v6 = (*(uint64_t (**)(uint64_t, _BYTE *, void **, uint64_t *))(*(void *)v5 + 144LL))(v5, buf, __p, &v13);
  if (v13) {
    int v7 = v6;
  }
  else {
    int v7 = 0;
  }
  if (v12 < 0) {
    operator delete(__p[0]);
  }
  if (v15 < 0)
  {
    operator delete(*(void **)buf);
    if (!v7) {
      return a1;
    }
  }

  else if (!v7)
  {
    return a1;
  }

  uint64_t v8 = v13;
  a1[6] = v13;
  uint64_t v9 = (os_log_s *)qword_1008F75A0;
  if (os_log_type_enabled((os_log_t)qword_1008F75A0, OS_LOG_TYPE_DEFAULT))
  {
    *(_DWORD *)__int128 buf = 134217984;
    *(void *)&uint8_t buf[4] = v8;
    _os_log_impl((void *)&_mh_execute_header, v9, OS_LOG_TYPE_DEFAULT, "Overriding fWatchdogDuration %llu.", buf, 0xCu);
  }

  return a1;
}

void sub_10043CAB8( _Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, void *__p, uint64_t a10, int a11, __int16 a12, char a13, char a14, uint64_t a15, void *a16, uint64_t a17, int a18, __int16 a19, char a20, char a21)
{
  if (a14 < 0) {
    operator delete(__p);
  }
  if (a21 < 0) {
    operator delete(a16);
  }
  _Unwind_Resume(exception_object);
}

uint64_t sub_10043CB0C(uint64_t a1)
{
  *(void *)a1 = &off_1008987A0;
  sub_10043CB4C(a1);
  return a1;
}

void sub_10043CB4C(uint64_t a1)
{
  uint64_t v1 = *(dispatch_source_s **)(a1 + 16);
  if (v1)
  {
    int v3 = (os_log_s *)qword_1008F75A0;
    if (os_log_type_enabled((os_log_t)qword_1008F75A0, OS_LOG_TYPE_DEFAULT))
    {
      unint64_t v4 = (void *)(a1 + 24);
      int v5 = 136315138;
      int v6 = v4;
      _os_log_impl( (void *)&_mh_execute_header,  v3,  OS_LOG_TYPE_DEFAULT,  "ManagerStateWatchdog %s destroyed!",  (uint8_t *)&v5,  0xCu);
      uint64_t v1 = *(dispatch_source_s **)(a1 + 16);
    }

    dispatch_source_cancel(v1);
    dispatch_release(*(dispatch_object_t *)(a1 + 16));
    *(void *)(a1 + 16) = 0LL;
  }

void sub_10043CC24(uint64_t a1)
{
  if (!*(void *)(a1 + 16))
  {
    int v2 = (os_log_s *)qword_1008F75A0;
    if (os_log_type_enabled((os_log_t)qword_1008F75A0, OS_LOG_TYPE_DEFAULT))
    {
      int v3 = (void *)(a1 + 24);
      uint64_t v4 = *(void *)(a1 + 48);
      *(_DWORD *)__int128 buf = 136315394;
      uint64_t v11 = v3;
      __int16 v12 = 2048;
      uint64_t v13 = v4;
      _os_log_impl( (void *)&_mh_execute_header,  v2,  OS_LOG_TYPE_DEFAULT,  "ManagerStateWatchdog %s %llu ms Armed!",  buf,  0x16u);
    }

    uint64_t v5 = sub_100404FE8();
    int v6 = dispatch_source_create( (dispatch_source_type_t)&_dispatch_source_type_timer,  0LL,  0LL,  *(dispatch_queue_t *)(v5 + 8));
    *(void *)(a1 + 16) = v6;
    handler[0] = _NSConcreteStackBlock;
    handler[1] = 3221225472LL;
    handler[2] = sub_10043CD7C;
    handler[3] = &unk_10087EB20;
    handler[4] = a1;
    dispatch_source_set_event_handler(v6, handler);
    int v7 = *(dispatch_source_s **)(a1 + 16);
    dispatch_time_t v8 = dispatch_time(0x8000000000000000LL, 1000000LL * *(void *)(a1 + 48));
    dispatch_source_set_timer(v7, v8, 0xFFFFFFFFFFFFFFFFLL, 0LL);
    dispatch_activate(*(dispatch_object_t *)(a1 + 16));
  }

void sub_10043CD7C(uint64_t a1)
{
}

void sub_10043CD8C(uint64_t a1)
{
  uint64_t v1 = a1;
  sub_10043CB4C(a1);
  int v2 = (os_log_s *)qword_1008F75A0;
  if (os_log_type_enabled((os_log_t)qword_1008F75A0, OS_LOG_TYPE_ERROR))
  {
    int v3 = (void *)(v1 + 24);
    LODWORD(buf) = 136315138;
    *(void *)((char *)&buf + 4) = v3;
    _os_log_error_impl( (void *)&_mh_execute_header,  v2,  OS_LOG_TYPE_ERROR,  "ManagerStateWatchdog %s timer expired",  (uint8_t *)&buf,  0xCu);
    int v2 = (os_log_s *)qword_1008F75A0;
  }

  if (os_log_type_enabled(v2, OS_LOG_TYPE_FAULT))
  {
    LOWORD(buf) = 0;
    _os_log_fault_impl((void *)&_mh_execute_header, v2, OS_LOG_TYPE_FAULT, "Bad state watchdog", (uint8_t *)&buf, 2u);
  }

  if (qword_1008D9060 != -1) {
    goto LABEL_16;
  }
  while (1)
  {
    uint64_t v4 = qword_1008D9058;
    sub_10002418C(&buf, "ManagerStateWatchdog");
    sub_10040C784(0.0, v4, (uint64_t *)&buf, (uint64_t *)(v1 + 24));
    if (SHIBYTE(v12) < 0) {
      operator delete((void *)buf);
    }
    __int128 buf = 0uLL;
    uint64_t v12 = 0LL;
    (**(void (***)(__int128 *__return_ptr, uint64_t))v1)(&buf, v1);
    uint64_t v1 = _os_log_pack_size(12LL);
    uint64_t v5 = (char *)&buf - ((__chkstk_darwin() + 15) & 0xFFFFFFFFFFFFFFF0LL);
    int v6 = __error();
    uint64_t v7 = _os_log_pack_fill( v5,  v1,  *v6,  &_mh_execute_header,  "ManagerStateWatchdog is expired. %{public}s");
    p___int128 buf = &buf;
    if (v12 < 0) {
      p___int128 buf = (__int128 *)buf;
    }
    *(_DWORD *)uint64_t v7 = 136446210;
    *(void *)(v7 + 4) = p_buf;
    os_log_t v9 = os_log_create("com.apple.bluetooth", "CBCrash");
    if (v9) {
      os_log_t v10 = v9;
    }
    else {
      os_log_t v10 = (os_log_t)&_os_log_default;
    }
    qword_1008D9DB8 = os_log_pack_send_and_compose(v5, v10, 16LL, 0LL, 0LL);
    abort_with_payload(18LL, 2LL, v5, v1, qword_1008D9DB8, 0LL);
    __break(1u);
LABEL_16:
    dispatch_once(&qword_1008D9060, &stru_1008987A8);
  }

void sub_10043CFAC(_Unwind_Exception *exception_object)
{
}

void sub_10043CFD8(id a1)
{
  uint64_t v1 = operator new(0x18uLL);
  *(void *)uint64_t v1 = 0LL;
  void v1[2] = 0;
  *((_BYTE *)v1 + 12) = 0;
  v1[4] = 0;
  qword_1008D9058 = (uint64_t)v1;
}

uint64_t sub_10043D008(uint64_t a1, uint64_t a2, int a3)
{
  *(void *)a1 = off_100898730;
  sub_100242DC4(a1 + 8);
  *(_BYTE *)(a1 + 72) = 0;
  *(_DWORD *)(a1 + sub_10023DF50(v3 + 76) = a3;
  *(void *)a1 = off_1008987D8;
  *(void *)(a1 + 8sub_100414D2C(qword_1008F72C0, 0) = a2;
  *(void *)(a1 + 8sub_100242E28(v1 + 8) = off_100898818;
  *(void *)(a1 + 96) = 0LL;
  sub_100242DC4(a1 + 104);
  *(_OWORD *)(a1 + 1sub_10023DF50(v3 + 76) = 0u;
  *(_DWORD *)(a1 + 16sub_100242E28(v1 + 8) = 0;
  *(_BYTE *)(a1 + 172) = 0;
  *(_OWORD *)(a1 + 192) = 0u;
  *(_OWORD *)(a1 + 20sub_100242E28(v1 + 8) = 0u;
  *(void *)(a1 + 96) = sub_100405288();
  return a1;
}

void sub_10043D0A4(_Unwind_Exception *a1)
{
  uint64_t v7 = (void *)v1[25];
  if (v7)
  {
    v1[26] = v7;
    operator delete(v7);
  }

  dispatch_time_t v8 = *v5;
  if (*v5)
  {
    v1[23] = v8;
    operator delete(v8);
  }

  sub_100242E28(v3);
  *uint64_t v1 = v4;
  sub_100242E28(v2);
  _Unwind_Resume(a1);
}

std::string *sub_10043D0F0(uint64_t a1, uint64_t a2)
{
  HIDWORD(v10.__r_.__value_.__r.__words[2]) = 0;
  WORD1(v10.__r_.__value_.__r.__words[2]) = 0;
  if (qword_1008D5F50 != -1) {
    dispatch_once(&qword_1008D5F50, &stru_100898910);
  }
  uint64_t v4 = off_1008D5F48;
  uint64_t v11 = 0LL;
  sub_1000B0400((uint64_t)&v11);
  v10.__r_.__value_.__r.__words[0] = (int)v11;
  v10.__r_.__value_.__l.__size_ = SWORD2(v11);
  uint64_t result = sub_100400268(v4, a2, &v10, (BOOL *)&v10.__r_.__value_.__s.__data_[19], &v10.__r_.__value_.__s.__data_[18]);
  if (result)
  {
    uint64_t v6 = (uint64_t)result;
    int v7 = (*(uint64_t (**)(void, std::string *, std::string::value_type *, void))(**(void **)(a1 + 80)
                                                                                             + 48LL))( *(void *)(a1 + 80),  result,  &v10.__r_.__value_.__s.__data_[20],  v10.__r_.__value_.__s.__data_[19]);
    *(_OWORD *)&v10.__r_.__value_.__l.__data_ = 0uLL;
    sub_100242F28((uint64_t)&v10, a1 + 104);
    std::string::value_type v8 = v10.__r_.__value_.__s.__data_[20];
    if ((v10.__r_.__value_.__s.__data_[20] & 4) != 0 && !v10.__r_.__value_.__s.__data_[18])
    {
      sub_10043D238((void *)a1, v6);
      std::string::value_type v8 = v10.__r_.__value_.__s.__data_[20];
    }

    if ((v8 & 0x10) != 0) {
      sub_10043D31C((void *)a1, v6);
    }
    sub_100242F54((uint64_t)&v10);
    uint64_t v9 = 32LL;
    if (v7) {
      uint64_t v9 = 24LL;
    }
    (*(void (**)(void))(**(void **)(a1 + 80) + v9))();
    return (std::string *)sub_100242FAC((uint64_t)&v10);
  }

  return result;
}

void sub_10043D224( _Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9)
{
}

void sub_10043D238(void *a1, uint64_t a2)
{
  uint64_t v4 = (char **)(a1 + 25);
  if (!sub_1003FE254((uint64_t)(a1 + 25), a2))
  {
    unint64_t v5 = a1[27];
    uint64_t v6 = (uint64_t *)a1[26];
    if ((unint64_t)v6 >= v5)
    {
      uint64_t v8 = ((char *)v6 - *v4) >> 3;
      uint64_t v9 = v5 - (void)*v4;
      uint64_t v10 = v9 >> 2;
      else {
        unint64_t v11 = v10;
      }
      if (v11) {
        uint64_t v12 = (char *)sub_100008BA0((uint64_t)(a1 + 27), v11);
      }
      else {
        uint64_t v12 = 0LL;
      }
      uint64_t v13 = (uint64_t *)&v12[8 * v8];
      uint64_t v14 = &v12[8 * v11];
      *uint64_t v13 = a2;
      int v7 = v13 + 1;
      uint64_t v16 = (char *)a1[25];
      char v15 = (char *)a1[26];
      if (v15 != v16)
      {
        do
        {
          uint64_t v17 = *((void *)v15 - 1);
          v15 -= 8;
          *--uint64_t v13 = v17;
        }

        while (v15 != v16);
        char v15 = *v4;
      }

      a1[25] = v13;
      a1[26] = v7;
      a1[27] = v14;
      if (v15) {
        operator delete(v15);
      }
    }

    else
    {
      uint64_t *v6 = a2;
      int v7 = v6 + 1;
    }

    a1[26] = v7;
  }

void sub_10043D31C(void *a1, uint64_t a2)
{
  uint64_t v4 = (char **)(a1 + 22);
  if (!sub_1003FE254((uint64_t)(a1 + 22), a2))
  {
    unint64_t v5 = a1[24];
    uint64_t v6 = (uint64_t *)a1[23];
    if ((unint64_t)v6 >= v5)
    {
      uint64_t v8 = ((char *)v6 - *v4) >> 3;
      uint64_t v9 = v5 - (void)*v4;
      uint64_t v10 = v9 >> 2;
      else {
        unint64_t v11 = v10;
      }
      if (v11) {
        uint64_t v12 = (char *)sub_100008BA0((uint64_t)(a1 + 24), v11);
      }
      else {
        uint64_t v12 = 0LL;
      }
      uint64_t v13 = (uint64_t *)&v12[8 * v8];
      uint64_t v14 = &v12[8 * v11];
      *uint64_t v13 = a2;
      int v7 = v13 + 1;
      uint64_t v16 = (char *)a1[22];
      char v15 = (char *)a1[23];
      if (v15 != v16)
      {
        do
        {
          uint64_t v17 = *((void *)v15 - 1);
          v15 -= 8;
          *--uint64_t v13 = v17;
        }

        while (v15 != v16);
        char v15 = *v4;
      }

      a1[22] = v13;
      a1[23] = v7;
      a1[24] = v14;
      if (v15) {
        operator delete(v15);
      }
    }

    else
    {
      uint64_t *v6 = a2;
      int v7 = v6 + 1;
    }

    a1[23] = v7;
  }

uint64_t sub_10043D400(uint64_t a1)
{
  v8[0] = 0LL;
  v8[1] = 0LL;
  sub_100242F28((uint64_t)v8, a1 + 104);
  uint64_t v2 = (os_log_s *)qword_1008F7590;
  if (os_log_type_enabled((os_log_t)qword_1008F7590, OS_LOG_TYPE_INFO))
  {
    int v3 = *(_DWORD *)(a1 + 168);
    *(_DWORD *)__int128 buf = 67109120;
    int v10 = v3;
    _os_log_impl((void *)&_mh_execute_header, v2, OS_LOG_TYPE_INFO, "Stepping scan with mode %u", buf, 8u);
  }

  int v4 = *(_DWORD *)(a1 + 168);
  if (v4 > 3)
  {
    if (v4 != 4)
    {
      if (v4 != 16)
      {
LABEL_12:
        if (*(_BYTE *)(a1 + 172))
        {
          *(_BYTE *)(a1 + 172) = 0;
        }

        else
        {
          sub_100242F54((uint64_t)v8);
          uint64_t v6 = (os_log_s *)qword_1008F7590;
          if (os_log_type_enabled((os_log_t)qword_1008F7590, OS_LOG_TYPE_INFO))
          {
            *(_DWORD *)__int128 buf = 67109120;
            int v10 = 250;
            _os_log_impl( (void *)&_mh_execute_header,  v6,  OS_LOG_TYPE_INFO,  "Sleeping %u ms before ending scan",  buf,  8u);
          }

          j__usleep(0x3D090u);
          sub_10043B88C(a1, 0LL);
        }

        return sub_100242FAC((uint64_t)v8);
      }

void sub_10043D5B0( _Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9)
{
}

BOOL sub_10043D5D0(uint64_t a1)
{
  uint64_t v1 = *(uint64_t **)(a1 + 200);
  uint64_t v2 = *(uint64_t **)(a1 + 208);
  if (v1 != v2)
  {
    uint64_t v4 = *v1;
    char v7 = 0;
    sub_100242CA4(&v7);
    uint64_t v5 = sub_10010E844((uint64_t)sub_10043DDD0, v4 + 128, 4, a1);
    sub_100242CD0(&v7);
    if ((_DWORD)v5)
    {
      *(_DWORD *)(a1 + 16sub_100242E28(v1 + 8) = 128;
      sub_10043B88C(a1, v5);
    }

    else
    {
      *(_DWORD *)(a1 + 16sub_100242E28(v1 + 8) = 4;
    }

    sub_100242CD8(&v7);
  }

  return v1 != v2;
}

void sub_10043D670( _Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, int a10, __int16 a11, char a12, char a13)
{
}

uint64_t sub_10043D684(uint64_t a1, int a2, uint64_t a3, const std::string *a4)
{
  HIDWORD(v10.__r_.__value_.__r.__words[2]) = 0;
  if (qword_1008D5F50 != -1) {
    dispatch_once(&qword_1008D5F50, &stru_100898910);
  }
  WORD2(v10.__r_.__value_.__r.__words[0]) = WORD2(a3);
  LODWORD(v10.__r_.__value_.__l.__data_) = a3;
  uint64_t v8 = (std::string *)sub_1003FFEB0(off_1008D5F48, (uint64_t)&v10, 1);
  if (!a2)
  {
    uint64_t v11 = 0LL;
    sub_1000B0400((uint64_t)&v11);
    v10.__r_.__value_.__r.__words[0] = (int)v11;
    v10.__r_.__value_.__l.__size_ = SWORD2(v11);
    sub_1003D0F60(v8, a4, &v10);
    (*(void (**)(void, std::string *))(**(void **)(a1 + 80) + 16LL))(*(void *)(a1 + 80), v8);
  }

  (*(void (**)(void, std::string *, std::string::value_type *, void))(**(void **)(a1 + 80) + 48LL))( *(void *)(a1 + 80),  v8,  &v10.__r_.__value_.__s.__data_[20],  0LL);
  *(_OWORD *)&v10.__r_.__value_.__l.__data_ = 0uLL;
  sub_100242F28((uint64_t)&v10, a1 + 104);
  sub_1003FE288((char **)(a1 + 200), (uint64_t)v8);
  if ((v10.__r_.__value_.__s.__data_[20] & 0x10) != 0) {
    sub_10043D31C((void *)a1, (uint64_t)v8);
  }
  sub_100242F54((uint64_t)&v10);
  sub_10043D400(a1);
  return sub_100242FAC((uint64_t)&v10);
}

void sub_10043D7B0( _Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9)
{
}

uint64_t sub_10043D7C4(uint64_t a1, uint64_t a2, int a3)
{
  uint64_t v6 = operator new(0x28uLL);
  v6[4] = 1;
  *(void *)uint64_t v6 = &off_1008988E8;
  *((void *)v6 + 2) = a1;
  *((_DWORD *)v6 + 6) = a3;
  *((void *)v6 + 4) = a2;
  return (*(uint64_t (**)(uint64_t, _WORD *))(*(void *)a1 + 40LL))(a1, v6);
}

uint64_t sub_10043D828(uint64_t a1, uint64_t a2, int a3)
{
  uint64_t v6 = operator new(0x28uLL);
  v6[4] = 1;
  *(void *)uint64_t v6 = &off_1008988E8;
  uint64_t v7 = *(void *)(a1 - 88);
  a1 -= 88LL;
  *((void *)v6 + 2) = a1;
  *((_DWORD *)v6 + 6) = a3;
  *((void *)v6 + 4) = a2;
  return (*(uint64_t (**)(uint64_t, _WORD *))(v7 + 40))(a1, v6);
}

uint64_t sub_10043D88C(uint64_t a1, uint64_t a2)
{
  v5[0] = 0LL;
  v5[1] = 0LL;
  sub_100242F28((uint64_t)v5, a1 + 104);
  sub_1003FE288((char **)(a1 + 176), a2);
  sub_100242F54((uint64_t)v5);
  (*(void (**)(void, uint64_t))(**(void **)(a1 + 80) + 24LL))(*(void *)(a1 + 80), a2);
  sub_10043D400(a1);
  return sub_100242FAC((uint64_t)v5);
}

void sub_10043D8FC( _Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9)
{
}

void sub_10043D910(uint64_t a1)
{
  v3[0] = 0LL;
  v3[1] = 0LL;
  sub_100242F28((uint64_t)v3, a1 + 8);
  int v2 = *(unsigned __int8 *)(a1 + 72);
  sub_100242FAC((uint64_t)v3);
  if (v2)
  {
    sub_1001EE2A0();
  }

  else
  {
    sub_10043B388(a1);
    sub_10043D400(a1);
  }

uint64_t sub_10043D96C(uint64_t a1)
{
  v21[0] = 0LL;
  v21[1] = 0LL;
  sub_100242F28((uint64_t)v21, a1 + 104);
  int v2 = (os_log_s *)qword_1008F7590;
  if (os_log_type_enabled((os_log_t)qword_1008F7590, OS_LOG_TYPE_DEFAULT))
  {
    int v3 = *(_DWORD *)(a1 + 168);
    *(_DWORD *)__int128 buf = 67109120;
    int v23 = v3;
    _os_log_impl((void *)&_mh_execute_header, v2, OS_LOG_TYPE_DEFAULT, "Stopping scan with mode %u", buf, 8u);
  }

  int v4 = *(_DWORD *)(a1 + 168);
  if (v4 > 3)
  {
    if (v4 == 4)
    {
      uint64_t v11 = *(uint64_t **)(a1 + 200);
      if (v11 != *(uint64_t **)(a1 + 208))
      {
        uint64_t v12 = *v11;
        *(void *)(a1 + 20sub_100242E28(v1 + 8) = v11;
        *(_DWORD *)(a1 + 16sub_100242E28(v1 + 8) = 128;
        sub_100242F54((uint64_t)v21);
        buf[0] = 0;
        sub_100242CA4(buf);
        sub_10010E8F8(v12 + 128, v13, v14, v15, v16, v17, v18, v19);
        sub_100242CD0(buf);
        goto LABEL_15;
      }
    }

    else if (v4 == 16)
    {
      *(void *)(a1 + 184) = *(void *)(a1 + 176);
      *(_DWORD *)(a1 + 16sub_100242E28(v1 + 8) = 128;
      sub_100242F54((uint64_t)v21);
      if (qword_1008D9600 != -1) {
        dispatch_once(&qword_1008D9600, &stru_100898930);
      }
      sub_10041AB60(qword_1008D95F8, 1);
    }
  }

  else if (v4)
  {
    if (v4 == 1)
    {
      *(_DWORD *)(a1 + 16sub_100242E28(v1 + 8) = 128;
      sub_100242F54((uint64_t)v21);
      buf[0] = 0;
      sub_100242CA4(buf);
      sub_100113738(sub_10043DB6C, a1, v5, v6, v7, v8, v9, v10);
      sub_100242CD0(buf);
LABEL_15:
      sub_100242CD8(buf);
    }
  }

  else
  {
    *(_DWORD *)(a1 + 16sub_100242E28(v1 + 8) = 128;
  }

  return sub_100242FAC((uint64_t)v21);
}

void sub_10043DB30( _Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9)
{
}

uint64_t sub_10043DB6C(uint64_t result, uint64_t a2)
{
  if (a2)
  {
    int v3 = result;
    int v4 = operator new(0x20uLL);
    v4[4] = 1;
    *(void *)int v4 = &off_1008988B0;
    *((void *)v4 + 2) = a2;
    *((_DWORD *)v4 + 6) = v3;
    return (*(uint64_t (**)(uint64_t, _WORD *))(*(void *)a2 + 40LL))(a2, v4);
  }

  return result;
}

uint64_t sub_10043DBC8(uint64_t a1)
{
  int v2 = (os_log_s *)qword_1008F7590;
  if (os_log_type_enabled((os_log_t)qword_1008F7590, OS_LOG_TYPE_INFO))
  {
    v7[0] = 67109376;
    v7[1] = 4;
    __int16 v8 = 1024;
    int v9 = 4;
    _os_log_impl( (void *)&_mh_execute_header,  v2,  OS_LOG_TYPE_INFO,  "Scanning for %u scan periods (%u x 1.28s)",  (uint8_t *)v7,  0xEu);
  }

  LOBYTE(v7[0]) = 0;
  sub_100242CA4(v7);
  uint64_t v5 = sub_100113690(10390323LL, 4LL, 64LL, sub_10043DD78, sub_10043DB6C, a1, v3, v4);
  if (!(_DWORD)v5) {
    *(_DWORD *)(a1 + 16sub_100242E28(v1 + 8) = 1;
  }
  sub_100242CD8(v7);
  return v5;
}

void sub_10043DCC8( _Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, char a9)
{
}

BOOL sub_10043DCE4(uint64_t a1)
{
  int v2 = *(uint64_t **)(a1 + 176);
  uint64_t v3 = *(uint64_t **)(a1 + 184);
  if (v2 == v3)
  {
    *(_DWORD *)(a1 + 16sub_100242E28(v1 + 8) = 128;
  }

  else
  {
    uint64_t v4 = *v2;
    *(_DWORD *)(a1 + 16sub_100242E28(v1 + 8) = 16;
    if (qword_1008D9600 != -1) {
      dispatch_once(&qword_1008D9600, &stru_100898930);
    }
    sub_10041AA14(qword_1008D95F8, v4, a1 + 88, 1, 2);
  }

  return v2 != v3;
}

uint64_t sub_10043DD78(uint64_t result, uint64_t a2)
{
  if (result)
  {
    uint64_t v3 = (__int128 *)result;
    uint64_t v4 = operator new(0x30uLL);
    sub_10043DE64((uint64_t)v4, a2, v3);
    return (*(uint64_t (**)(uint64_t, void *))(*(void *)a2 + 40LL))(a2, v4);
  }

  return result;
}

uint64_t sub_10043DDD0(uint64_t result, int *a2, std::string::value_type *a3, uint64_t a4)
{
  if (a4)
  {
    int v7 = result;
    __int16 v8 = operator new(0x40uLL);
    sub_10043DF70((uint64_t)v8, a4, v7, a2, a3);
    return (*(uint64_t (**)(uint64_t, void *))(*(void *)a4 + 40LL))(a4, v8);
  }

  return result;
}

void sub_10043DE50(_Unwind_Exception *a1)
{
}

uint64_t sub_10043DE64(uint64_t a1, uint64_t a2, __int128 *a3)
{
  *(_WORD *)(a1 + sub_100242E28(v1 + 8) = 1;
  *(void *)a1 = &off_100898840;
  *(void *)(a1 + 16) = a2;
  __int128 v4 = *a3;
  *(void *)(a1 + 4sub_100414D2C(qword_1008F72C0, 0) = *((void *)a3 + 2);
  *(_OWORD *)(a1 + 24) = v4;
  if (*((void *)a3 + 2))
  {
    uint64_t v6 = malloc(0xF0uLL);
    *(void *)(a1 + 4sub_100414D2C(qword_1008F72C0, 0) = v6;
    int v7 = (_OWORD *)*((void *)a3 + 2);
    __int128 v9 = v7[1];
    __int128 v8 = v7[2];
    _OWORD *v6 = *v7;
    v6[1] = v9;
    void v6[2] = v8;
    __int128 v10 = v7[11];
    __int128 v11 = v7[12];
    __int128 v12 = v7[14];
    v6[13] = v7[13];
    uint8_t v6[14] = v12;
    v6[11] = v10;
    v6[12] = v11;
    __int128 v13 = v7[7];
    __int128 v14 = v7[8];
    __int128 v15 = v7[10];
    v6[9] = v7[9];
    v6[10] = v15;
    v6[7] = v13;
    v6[8] = v14;
    __int128 v16 = v7[3];
    __int128 v17 = v7[4];
    __int128 v18 = v7[6];
    void v6[5] = v7[5];
    v6[6] = v18;
    void v6[3] = v16;
    v6[4] = v17;
  }

  else
  {
    *(void *)(a1 + 4sub_100414D2C(qword_1008F72C0, 0) = 0LL;
  }

  return a1;
}

std::string *sub_10043DF10(uint64_t a1)
{
  uint64_t v1 = *(void *)(a1 + 16);
  __int128 v3 = *(_OWORD *)(a1 + 24);
  uint64_t v4 = *(void *)(a1 + 40);
  return sub_10043D0F0(v1, (uint64_t)&v3);
}

uint64_t sub_10043DF48(uint64_t a1)
{
  return sub_10043D88C(*(void *)(a1 + 16), *(void *)(a1 + 32));
}

uint64_t sub_10043DF58(uint64_t a1)
{
  uint64_t v2 = *(void *)(a1 + 16);
  uint64_t v3 = *(unsigned int *)(a1 + 24);
  if ((_DWORD)v3) {
    return sub_10043B88C(v2, v3);
  }
  else {
    return sub_10043D400(v2);
  }
}

uint64_t sub_10043DF70(uint64_t a1, uint64_t a2, int a3, int *a4, std::string::value_type *__s)
{
  *(_WORD *)(a1 + sub_100242E28(v1 + 8) = 1;
  *(void *)a1 = &off_100898878;
  *(void *)(a1 + 16) = a2;
  *(_DWORD *)(a1 + 24) = a3;
  *(void *)(a1 + 4sub_100414D2C(qword_1008F72C0, 0) = 0LL;
  *(void *)(a1 + 4sub_100242E28(v1 + 8) = 0LL;
  *(void *)(a1 + 56) = 0LL;
  if (a4)
  {
    int v6 = *a4;
    *(_WORD *)(a1 + sub_100242FAC(v1 - 32) = *((_WORD *)a4 + 2);
    *(_DWORD *)(a1 + 2sub_100242E28(v1 + 8) = v6;
  }

  if (__s) {
    std::string::assign((std::string *)(a1 + 40), __s);
  }
  return a1;
}

void sub_10043DFE4(_Unwind_Exception *exception_object)
{
}

void sub_10043E000(uint64_t a1)
{
  uint64_t v1 = *(void *)(a1 + 16);
  int v2 = *(_DWORD *)(a1 + 24);
  unint64_t v3 = *(unsigned int *)(a1 + 28) | ((unint64_t)*(unsigned __int16 *)(a1 + 32) << 32);
  else {
    std::string __p = *(std::string *)(a1 + 40);
  }
  sub_10043D684(v1, v2, v3 & 0xFFFFFFFFFFFFLL, &__p);
}

void sub_10043E088( _Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, void *__p, uint64_t a10, int a11, __int16 a12, char a13, char a14)
{
  if (a14 < 0) {
    operator delete(__p);
  }
  _Unwind_Resume(exception_object);
}

void *sub_10043E0A4(void *a1)
{
  *a1 = &off_100898840;
  int v2 = (void *)a1[5];
  if (v2) {
    free(v2);
  }
  return a1;
}

void sub_10043E0DC(void *__p)
{
  void *__p = &off_100898840;
  int v2 = (void *)__p[5];
  if (v2) {
    free(v2);
  }
  operator delete(__p);
}

uint64_t sub_10043E124(uint64_t a1)
{
  *(void *)a1 = &off_100898878;
  return a1;
}

void sub_10043E160(void **__p)
{
  void *__p = &off_100898878;
  operator delete(__p);
}

void *sub_10043E19C(void *a1)
{
  *a1 = off_1008987D8;
  a1[11] = off_100898818;
  int v2 = (void *)a1[25];
  if (v2)
  {
    a1[26] = v2;
    operator delete(v2);
  }

  unint64_t v3 = (void *)a1[22];
  if (v3)
  {
    a1[23] = v3;
    operator delete(v3);
  }

  sub_100242E28(a1 + 13);
  *a1 = off_100898730;
  sub_100242E28(a1 + 1);
  return a1;
}

void sub_10043E20C(void *a1)
{
  *a1 = off_1008987D8;
  a1[11] = off_100898818;
  int v2 = (void *)a1[25];
  if (v2)
  {
    a1[26] = v2;
    operator delete(v2);
  }

  unint64_t v3 = (void *)a1[22];
  if (v3)
  {
    a1[23] = v3;
    operator delete(v3);
  }

  sub_100242E28(a1 + 13);
  *a1 = off_100898730;
  sub_100242E28(a1 + 1);
  operator delete(a1);
}

BOOL sub_10043E27C(uint64_t a1, _BYTE *a2)
{
  return sub_100405744(*(void *)(a1 + 96), a2);
}

uint64_t sub_10043E284(void *a1)
{
  *(a1 - 11) = off_1008987D8;
  *a1 = off_100898818;
  int v2 = (void *)a1[14];
  if (v2)
  {
    a1[15] = v2;
    operator delete(v2);
  }

  unint64_t v3 = (void *)a1[11];
  if (v3)
  {
    a1[12] = v3;
    operator delete(v3);
  }

  sub_100242E28(a1 + 2);
  *(a1 - 11) = off_100898730;
  return sub_100242E28(a1 - 10);
}

void sub_10043E2EC(void *a1)
{
  *(a1 - 11) = off_1008987D8;
  int v2 = a1 - 11;
  *a1 = off_100898818;
  unint64_t v3 = (void *)a1[14];
  if (v3)
  {
    a1[15] = v3;
    operator delete(v3);
  }

  uint64_t v4 = (void *)a1[11];
  if (v4)
  {
    a1[12] = v4;
    operator delete(v4);
  }

  sub_100242E28(a1 + 2);
  *(a1 - 11) = off_100898730;
  sub_100242E28(a1 - 10);
  operator delete(v2);
}

void sub_10043E360(id a1)
{
  uint64_t v1 = operator new(0x138uLL);
  sub_1003FE3E0((uint64_t)v1);
  off_1008D5F48 = v1;
}

void sub_10043E390(_Unwind_Exception *a1)
{
}

void sub_10043E3A4(id a1)
{
  uint64_t v1 = operator new(0x58uLL);
  sub_10041A094(v1);
  qword_1008D95F8 = (uint64_t)v1;
}

void sub_10043E3D4(_Unwind_Exception *a1)
{
}

uint64_t sub_10043E3E8(uint64_t a1, uint64_t a2, _xpc_connection_s *a3, dispatch_object_s *a4)
{
  uint64_t v5 = sub_10025D004(a1, a2, a3, a4);
  *(void *)uint64_t v5 = off_100898960;
  *(void *)(v5 + 12sub_100242E28(v1 + 8) = 0LL;
  *(_DWORD *)(v5 + 136) = 0;
  if (qword_1008D6788 != -1) {
    dispatch_once(&qword_1008D6788, &stru_100898A20);
  }
  *(_DWORD *)(a1 + 14sub_100414D2C(qword_1008F72C0, 0) = sub_1002075B4((uint64_t)off_1008D6780);
  return a1;
}

void sub_10043E458(_Unwind_Exception *a1)
{
}

NSDictionary *sub_10043E470(void *a1)
{
  size_t count = xpc_dictionary_get_count(a1);
  uint64_t v3 = 8 * count;
  __chkstk_darwin(count, v4);
  uint64_t v5 = (char *)applier - ((8 * count + 15) & 0xFFFFFFFFFFFFFFF0LL);
  bzero(v5, 8 * count);
  __chkstk_darwin(v6, v7);
  bzero(v5, 8 * count);
  v13[0] = 0LL;
  v13[1] = v13;
  void v13[2] = 0x2020000000LL;
  v13[3] = 0LL;
  applier[0] = _NSConcreteStackBlock;
  applier[1] = 3221225472LL;
  applier[2] = sub_10043FC7C;
  applier[3] = &unk_1008989B8;
  applier[4] = v13;
  applier[5] = v5;
  applier[6] = v5;
  xpc_dictionary_apply(a1, applier);
  __int128 v8 = -[NSDictionary initWithObjects:forKeys:count:]( objc_alloc(&OBJC_CLASS___NSDictionary),  "initWithObjects:forKeys:count:",  v5,  v5,  count);
  _Block_object_dispose(v13, 8);
  if (count)
  {
    uint64_t v9 = 8 * count;
    do
    {

      v9 -= 8LL;
    }

    while (v9);
    __int128 v10 = v5 - 8;
    do
    {

      v3 -= 8LL;
    }

    while (v3);
  }

  return v8;
}

void sub_10043E5F4(_Unwind_Exception *a1)
{
  if (v3)
  {
    uint64_t v7 = v4 - 8;
    uint64_t v8 = v1;
    do
    {

      v8 -= 8LL;
    }

    while (v8);
    uint64_t v9 = v2 - 8;
    do
    {

      v1 -= 8LL;
    }

    while (v1);
  }

  _Unwind_Resume(a1);
}

xpc_object_t sub_10043E648(void *a1)
{
  id v1 = a1;
  size_t v2 = (size_t)[v1 count];
  __chkstk_darwin();
  uint64_t v3 = (char *)v7 - ((8 * v2 + 15) & 0xFFFFFFFFFFFFFFF0LL);
  bzero(v3, 8 * v2);
  __chkstk_darwin();
  uint64_t v4 = (xpc_object_t *)v3;
  bzero(v3, 8 * v2);
  v8[0] = 0LL;
  v8[1] = v8;
  void v8[2] = 0x2020000000LL;
  void v8[3] = 0LL;
  v7[0] = _NSConcreteStackBlock;
  v7[1] = 3221225472LL;
  _DWORD v7[2] = sub_10043FFDC;
  void v7[3] = &unk_1008989E0;
  void v7[4] = v8;
  void v7[5] = v3;
  v7[6] = v3;
  [v1 enumerateKeysAndObjectsUsingBlock:v7];
  _Block_object_dispose(v8, 8);

  return i;
}

void sub_10043E7B0(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

NSArray *sub_10043E7E8(void *a1)
{
  size_t count = xpc_array_get_count(a1);
  size_t v3 = 8 * count;
  __chkstk_darwin(count, v4);
  bzero((char *)applier - ((v3 + 15) & 0xFFFFFFFFFFFFFFF0LL), v3);
  applier[0] = _NSConcreteStackBlock;
  applier[1] = 3221225472LL;
  applier[2] = sub_100440298;
  applier[3] = &unk_10088A098;
  applier[4] = (char *)applier - ((8 * count + 15) & 0xFFFFFFFFFFFFFFF0LL);
  xpc_array_apply(a1, applier);
  uint64_t v5 = -[NSArray initWithObjects:count:]( objc_alloc(&OBJC_CLASS___NSArray),  "initWithObjects:count:",  (char *)applier - ((8 * count + 15) & 0xFFFFFFFFFFFFFFF0LL),  count);
  if (count)
  {
    do
    {

      v3 -= 8LL;
    }

    while (v3);
  }

  return v5;
}

void sub_10043E900(_Unwind_Exception *exception_object)
{
  if (v2)
  {
    do
    {

      v1 -= 8LL;
    }

    while (v1);
  }

  _Unwind_Resume(exception_object);
}

xpc_object_t sub_10043E930(void *a1)
{
  id v1 = a1;
  uint64_t v2 = (char *)[v1 count];
  __chkstk_darwin();
  uint64_t v4 = (xpc_object_t *)((char *)v7 - ((v3 + 15) & 0xFFFFFFFFFFFFFFF0LL));
  bzero(v4, v3);
  v7[0] = _NSConcreteStackBlock;
  v7[1] = 3221225472LL;
  _DWORD v7[2] = sub_1004402D8;
  void v7[3] = &unk_100898A00;
  void v7[4] = v4;
  [v1 enumerateObjectsUsingBlock:v7];
  for (xpc_object_t i = xpc_array_create(v4, (size_t)v2); v2; --v2)
    xpc_release(*v4++);

  return i;
}

void sub_10043EA40(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_10043EA64(char *a1, xpc_object_t xdict)
{
  unsigned int int64 = xpc_dictionary_get_int64(xdict, "kCBMsgId");
  uint64_t v5 = (*(uint64_t (**)(char *, void))(*(void *)a1 + 32LL))(a1, (unsigned __int16)int64);
  uint64_t v7 = v6 & 1;
  uint64_t v8 = (os_log_s *)qword_1008F75F0;
  if (v7 | v5)
  {
    uint64_t v9 = (void (*)(char *, xpc_object_t))v5;
    uint64_t v10 = v6;
    if (os_log_type_enabled((os_log_t)qword_1008F75F0, OS_LOG_TYPE_DEFAULT))
    {
      uint64_t v11 = (*(uint64_t (**)(char *, void))(*(void *)a1 + 56LL))(a1, (unsigned __int16)int64);
      __int128 v12 = a1 + 56;
      if (a1[79] < 0) {
        __int128 v12 = (void *)*v12;
      }
      int v32 = 136446466;
      uint64_t v33 = v11;
      __int16 v34 = 2082;
      __int128 v35 = v12;
      _os_log_impl( (void *)&_mh_execute_header,  v8,  OS_LOG_TYPE_DEFAULT,  "Received XPC message %{public}s from session %{public}s",  (uint8_t *)&v32,  0x16u);
    }

    sub_10043ECF0(a1, xdict);
    if (!*((void *)a1 + 16)
      || (int v13 = *((_DWORD *)a1 + 34), v14 = 1, v13 != 10)
      && v13 != 5
      && (v13 != 4
       || ((*(uint64_t (**)(char *, void))(*(void *)a1 + 40LL))(a1, (unsigned __int16)int64) & 1) == 0)
      && ((*(uint64_t (**)(char *, void))(*(void *)a1 + 48LL))(a1, (unsigned __int16)int64) & 1) == 0)
    {
      else {
        unsigned int v14 = 0;
      }
    }

    uint64_t v15 = sub_1002E6E00();
    int v16 = (*(uint64_t (**)(uint64_t))(*(void *)v15 + 8LL))(v15);
    if (xdict)
    {
      if (v16)
      {
        BOOL v17 = sub_10043EE7C(v16, xdict);
        if (v17)
        {
          BOOL v18 = sub_10043EF98(v17, xdict);
          if (!v18) {
            sub_10043EFE8(v18, xdict);
          }
        }
      }
    }

    if (v14)
    {
      uint64_t v19 = &a1[v10 >> 1];
      if (v7) {
        uint64_t v9 = *(void (**)(char *, xpc_object_t))(*(void *)v19 + v9);
      }
      v9(v19, xdict);
    }

    else
    {
      uint64_t v20 = *((void *)a1 + 16);
      uint64_t v21 = (os_log_s *)qword_1008F75F0;
      BOOL v22 = os_log_type_enabled((os_log_t)qword_1008F75F0, OS_LOG_TYPE_ERROR);
      if (v20)
      {
        if (v22) {
          sub_10067FAA4((uint64_t)a1, v21);
        }
        xpc_object_t reply = xpc_dictionary_create_reply(xdict);
        if (reply)
        {
          __int16 v31 = reply;
          xpc_dictionary_set_int64(reply, "kCBMsgArgResult", 12LL);
          xpc_connection_send_message(*((xpc_connection_t *)a1 + 2), v31);
          xpc_release(v31);
        }
      }

      else if (v22)
      {
        sub_10067FA74(v21, v23, v24, v25, v26, v27, v28, v29);
      }
    }
  }

  else if (os_log_type_enabled((os_log_t)qword_1008F75F0, OS_LOG_TYPE_ERROR))
  {
    sub_10067FA04(int64, v8);
  }

void sub_10043ECF0(char *a1, void *a2)
{
  uint64_t v4 = sub_1002E6E00();
  int v5 = (*(uint64_t (**)(uint64_t))(*(void *)v4 + 448LL))(v4);
  if (a2 && v5)
  {
    if (xpc_get_type(a2) == (xpc_type_t)&_xpc_type_error)
    {
      uint64_t v11 = (os_log_s *)qword_1008F75F0;
      if (os_log_type_enabled((os_log_t)qword_1008F75F0, OS_LOG_TYPE_ERROR)) {
        sub_10067FB40(v11, v12, v13, v14, v15, v16, v17, v18);
      }
    }

    else
    {
      uint64_t v6 = xpc_copy_description(a2);
      unsigned __int16 int64 = xpc_dictionary_get_int64(a2, "kCBMsgId");
      uint64_t v8 = (os_log_s *)qword_1008F7718;
      if (os_log_type_enabled((os_log_t)qword_1008F7718, OS_LOG_TYPE_DEFAULT))
      {
        uint64_t v9 = a1 + 56;
        if (a1[79] < 0) {
          uint64_t v9 = (void *)*v9;
        }
        uint64_t v10 = (*(uint64_t (**)(char *, void))(*(void *)a1 + 56LL))(a1, int64);
        int v19 = 136446978;
        uint64_t v20 = v9;
        __int16 v21 = 2082;
        uint64_t v22 = v10;
        __int16 v23 = 1024;
        int count = xpc_dictionary_get_count(a2);
        __int16 v25 = 2080;
        uint64_t v26 = v6;
        _os_log_impl( (void *)&_mh_execute_header,  v8,  OS_LOG_TYPE_DEFAULT,  "Msg:%{public}s, Session:%{public}s, Count:%d, xpc_copy_description(args): %s ",  (uint8_t *)&v19,  0x26u);
      }

      free(v6);
    }
  }

BOOL sub_10043EE7C(int a1, xpc_object_t xdict)
{
  xpc_object_t dictionary = xpc_dictionary_get_dictionary(xdict, "kCBMsgArgs");
  if (!dictionary) {
    return 0LL;
  }
  size_t v3 = dictionary;
  if (!xpc_dictionary_get_dictionary(dictionary, "kCBMsgArgTimeXpcTimestampsTracking")) {
    return 0LL;
  }
  uint64_t v4 = sub_10043E470(v3);
  int v5 = (void *)objc_claimAutoreleasedReturnValue(v4);
  uint64_t v6 = (void *)objc_claimAutoreleasedReturnValue(+[NSDictionary dictionaryWithDictionary:](&OBJC_CLASS___NSDictionary, "dictionaryWithDictionary:", v5));

  if (v6)
  {
    uint64_t v7 = CBOptionUseCase;
    uint64_t v8 = (void *)objc_claimAutoreleasedReturnValue([v6 objectForKeyedSubscript:CBOptionUseCase]);
    if (v8)
    {
      uint64_t v9 = (void *)objc_claimAutoreleasedReturnValue([v6 objectForKeyedSubscript:v7]);
      BOOL v10 = [v9 unsignedLongValue] == (id)22;
    }

    else
    {
      BOOL v10 = 0LL;
    }
  }

  else
  {
    BOOL v10 = 0LL;
  }

  return v10;
}

void sub_10043EF64(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

BOOL sub_10043EF98(int a1, void *a2)
{
  BOOL result = 0;
  if (sub_10043EE7C(a1, a2))
  {
    xpc_object_t dictionary = xpc_dictionary_get_dictionary(a2, "kCBMsgArgs");
    if (xpc_dictionary_get_BOOL(dictionary, "kCBMsgArgTimeXpcMetricsOnlyFlag")) {
      return 1;
    }
  }

  return result;
}

void sub_10043EFE8(uint64_t a1, void *a2)
{
  size_t v3 = sub_10043E470(a2);
  uint64_t v4 = (void *)objc_claimAutoreleasedReturnValue(v3);
  id v12 = (id)objc_claimAutoreleasedReturnValue( +[NSMutableDictionary dictionaryWithDictionary:]( &OBJC_CLASS___NSMutableDictionary,  "dictionaryWithDictionary:",  v4));

  int v5 = (void *)objc_claimAutoreleasedReturnValue([v12 objectForKeyedSubscript:@"kCBMsgArgs"]);
  uint64_t v6 = (void *)objc_claimAutoreleasedReturnValue( +[NSMutableDictionary dictionaryWithDictionary:]( &OBJC_CLASS___NSMutableDictionary,  "dictionaryWithDictionary:",  v5));

  if (v6)
  {
    uint64_t v7 = (void *)objc_claimAutoreleasedReturnValue([v6 objectForKeyedSubscript:@"kCBMsgArgTimeXpcTimestampsTracking"]);
    if (v7)
    {
      uint64_t v8 = (void *)objc_claimAutoreleasedReturnValue([v6 objectForKeyedSubscript:@"kCBMsgArgTimeXpcTimestampsTracking"]);
      uint64_t v9 = (void *)objc_claimAutoreleasedReturnValue( +[NSMutableDictionary dictionaryWithDictionary:]( &OBJC_CLASS___NSMutableDictionary,  "dictionaryWithDictionary:",  v8));
    }

    else
    {
      uint64_t v9 = (void *)objc_claimAutoreleasedReturnValue(+[NSMutableDictionary dictionary](&OBJC_CLASS___NSMutableDictionary, "dictionary"));
    }

    BOOL v10 = -[NSNumber initWithLongLong:]( objc_alloc(&OBJC_CLASS___NSNumber),  "initWithLongLong:",  clock_gettime_nsec_np(_CLOCK_MONOTONIC) / 0xF4240);
    [v9 setObject:v10 forKeyedSubscript:@"kCBMsgArgTimeXpcCbAppConnHandleMsg"];

    [v6 setObject:v9 forKeyedSubscript:@"kCBMsgArgTimeXpcTimestampsTracking"];
    xpc_object_t v11 = sub_10043E648(v6);
    xpc_dictionary_set_value(a2, "kCBMsgArgs", v11);
    xpc_release(v11);
  }
}

void sub_10043F184( _Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, id a10)
{
  _Unwind_Resume(a1);
}

void sub_10043F1F4(uint64_t a1, int64_t value, void *a3, int a4)
{
  int v6 = value;
  *(_OWORD *)keys = *(_OWORD *)off_1008989A0;
  values[0] = xpc_int64_create(value);
  values[1] = a3;
  if (((v6 - 56) > 0x1C || ((1 << (v6 - 56)) & 0x10000081) == 0) && v6 != 196)
  {
    uint64_t v8 = (os_log_s *)qword_1008F75F0;
    if (os_log_type_enabled((os_log_t)qword_1008F75F0, OS_LOG_TYPE_DEBUG)) {
      sub_10067FB70((char *)a1, v6, v8);
    }
  }

  if (a3) {
    size_t v9 = 2LL;
  }
  else {
    size_t v9 = 1LL;
  }
  xpc_object_t v10 = xpc_dictionary_create((const char *const *)keys, values, v9);
  sub_10043ECF0((char *)a1, v10);
  xpc_object_t v11 = *(_xpc_connection_s **)(a1 + 16);
  if (v11)
  {
    xpc_connection_send_message(v11, v10);
  }

  else
  {
    id v12 = (os_log_s *)qword_1008F75F0;
    if (os_log_type_enabled((os_log_t)qword_1008F75F0, OS_LOG_TYPE_DEFAULT))
    {
      uint64_t v13 = (void *)(a1 + 56);
      int v14 = 136446210;
      uint64_t v15 = v13;
      _os_log_impl( (void *)&_mh_execute_header,  v12,  OS_LOG_TYPE_DEFAULT,  "Invalid Connection on session %{public}s, ignored.",  (uint8_t *)&v14,  0xCu);
    }
  }

  xpc_release(v10);
  xpc_release(values[0]);
  if (a3)
  {
    if (a4) {
      xpc_release(a3);
    }
  }

void sub_10043F394(uint64_t a1, int64_t a2, void *a3)
{
  id v6 = a3;
  xpc_object_t v5 = sub_10043E648(v6);
  sub_10043F1F4(a1, a2, v5, 1);
}

void sub_10043F3E0( _Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, id a10)
{
}

void sub_10043F3F4(uint64_t a1, int64_t a2, xpc_object_t xdict, int a4)
{
  xpc_object_t value = xpc_dictionary_get_value(xdict, "kCBMsgArgs");
  if (value)
  {
    uint64_t v8 = value;
    xpc_dictionary_set_int64(value, "kCBMsgArgResult", a4);
    sub_10043F1F4(a1, a2, v8, 0);
  }

void sub_10043F468(uint64_t a1, unsigned int a2)
{
  int v2 = *(_DWORD *)(a1 + 136);
  if (v2 != 2 && v2 != a2)
  {
    xpc_object_t v6 = xpc_dictionary_create(0LL, 0LL, 0LL);
    uint64_t v7 = (os_log_s *)qword_1008F75F0;
    if (os_log_type_enabled((os_log_t)qword_1008F75F0, OS_LOG_TYPE_DEFAULT))
    {
      if (a2 - 1 > 9) {
        uint64_t v8 = "Unknown";
      }
      else {
        uint64_t v8 = off_100898A60[a2 - 1];
      }
      size_t v9 = (void *)(a1 + 56);
      int v10 = 136446466;
      xpc_object_t v11 = v8;
      __int16 v12 = 2082;
      uint64_t v13 = v9;
      _os_log_impl( (void *)&_mh_execute_header,  v7,  OS_LOG_TYPE_DEFAULT,  "Sending 'state updated' event with state %{public}s to session %{public}s",  (uint8_t *)&v10,  0x16u);
    }

    *(_DWORD *)(a1 + 136) = a2;
    xpc_dictionary_set_int64(v6, "kCBMsgArgState", a2);
    sub_10043F1F4(a1, 6LL, v6, 1);
  }

void sub_10043F5A4(uint64_t a1, unsigned int a2, unsigned int a3)
{
  xpc_object_t v6 = xpc_dictionary_create(0LL, 0LL, 0LL);
  uint64_t v7 = v6;
  if (*(_DWORD *)(a1 + 140) == a3)
  {
    size_t v9 = (unsigned int *)(a1 + 136);
    int v8 = *(_DWORD *)(a1 + 136);
    if (v8 == 2 || v8 == a2)
    {
      xpc_release(v6);
      return;
    }
  }

  else
  {
    xpc_object_t v11 = (os_log_s *)qword_1008F75F0;
    if (os_log_type_enabled((os_log_t)qword_1008F75F0, OS_LOG_TYPE_DEFAULT))
    {
      __int16 v12 = (void *)(a1 + 56);
      int v17 = 67109378;
      *(_DWORD *)uint64_t v18 = a2;
      *(_WORD *)&_OWORD v18[4] = 2082;
      *(void *)&void v18[6] = v12;
      _os_log_impl( (void *)&_mh_execute_header,  v11,  OS_LOG_TYPE_DEFAULT,  "Sending 'power updated' event with state %d to session %{public}s",  (uint8_t *)&v17,  0x12u);
    }

    *(_DWORD *)(a1 + 14sub_100414D2C(qword_1008F72C0, 0) = a3;
    xpc_dictionary_set_int64(v7, "kCBMsgArgBTPowerState", a3);
    size_t v9 = (unsigned int *)(a1 + 136);
    int v13 = *(_DWORD *)(a1 + 136);
    if (v13 == 2 || v13 == a2) {
      goto LABEL_22;
    }
  }

  int v14 = (os_log_s *)qword_1008F75F0;
  if (os_log_type_enabled((os_log_t)qword_1008F75F0, OS_LOG_TYPE_DEFAULT))
  {
    if (a2 - 1 > 9) {
      uint64_t v15 = "Unknown";
    }
    else {
      uint64_t v15 = off_100898A60[a2 - 1];
    }
    uint64_t v16 = (void *)(a1 + 56);
    int v17 = 136446466;
    *(void *)uint64_t v18 = v15;
    *(_WORD *)&uint8_t v18[8] = 2082;
    *(void *)&v18[10] = v16;
    _os_log_impl( (void *)&_mh_execute_header,  v14,  OS_LOG_TYPE_DEFAULT,  "Sending 'state updated' event with state %{public}s to session %{public}s",  (uint8_t *)&v17,  0x16u);
  }

  *size_t v9 = a2;
  xpc_dictionary_set_int64(v7, "kCBMsgArgState", a2);
LABEL_22:
  sub_10043F1F4(a1, 6LL, v7, 1);
}

void sub_10043F7CC(uint64_t a1, int a2)
{
  if (a2) {
    unsigned int v2 = 4;
  }
  else {
    unsigned int v2 = 5;
  }
  sub_10043F468(a1, v2);
}

void sub_10043F7DC(uint64_t a1, void *a2, void *a3)
{
  id v4 = a3;
  *(void *)uuid = 0LL;
  uint64_t v7 = 0LL;
  [v4 getUUIDBytes:uuid];
  xpc_dictionary_set_uuid(a2, "kCBMsgArgDeviceUUID", uuid);
  if (qword_1008D9268 != -1) {
    dispatch_once(&qword_1008D9268, &stru_100898A40);
  }
  unsigned int v5 = sub_10038798C(qword_1008D9260, v4);
  xpc_dictionary_set_int64(a2, "kCBMsgArgATTMTU", v5);
}

void sub_10043F8A4(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

xpc_object_t sub_10043F8BC(unsigned __int8 **a1, uint64_t a2)
{
  size_t v3 = *a1;
  id v4 = a1[1];
  __chkstk_darwin(a1, 0x6666666666666668LL * ((unint64_t)(v4 - *a1) >> 2));
  xpc_object_t v6 = (xpc_object_t *)((char *)&bytes[-1] - v5);
  bzero((char *)&bytes[-1] - v5, v7);
  if (v4 == v3) {
    return xpc_array_create(v6, 0LL);
  }
  size_t v8 = 0LL;
  do
  {
    if (sub_1004403B4(a2, v3) != 1)
    {
      bytes[0] = 0LL;
      bytes[1] = 0LL;
      unsigned int v9 = sub_10063443C(v3, bytes);
      v6[v8++] = xpc_data_create(bytes, v9);
    }

    v3 += 20;
  }

  while (v3 != v4);
  xpc_object_t v10 = xpc_array_create(v6, v8);
  if (v8)
  {
    xpc_object_t v11 = v6 - 1;
    do
      xpc_release(v11[v8--]);
    while (v8);
  }

  return v10;
}

xpc_object_t sub_10043F9F4(void *a1)
{
  id v1 = a1;
  v22[1] = v1;
  id v2 = [v1 count];
  void v22[2] = v22;
  __chkstk_darwin(v2, 8LL * (void)v2);
  id v4 = (char *)v22 - ((v3 + 15) & 0xFFFFFFFFFFFFFFF0LL);
  bzero(v4, v3);
  __int128 v26 = 0u;
  __int128 v27 = 0u;
  __int128 v25 = 0u;
  __int128 v24 = 0u;
  id v5 = v1;
  id v6 = [v5 countByEnumeratingWithState:&v24 objects:v28 count:16];
  __int16 v23 = (xpc_object_t *)v4;
  if (v6)
  {
    size_t v7 = 0LL;
    uint64_t v8 = *(void *)v25;
    do
    {
      unsigned int v9 = 0LL;
      xpc_object_t v10 = v7;
      xpc_object_t v11 = &v23[(void)v7];
      do
      {
        if (*(void *)v25 != v8) {
          objc_enumerationMutation(v5);
        }
        id v12 = *(id *)(*((void *)&v24 + 1) + 8LL * (void)v9);
        id v13 = [v12 length];
        uint64_t v15 = (char *)v22 - ((__chkstk_darwin(v13, v14) + 15) & 0xFFFFFFFFFFFFFFF0LL);
        bzero(v15, (size_t)v13);
        [v12 getBytes:v15 length:v13];
        v11[(void)v9] = xpc_data_create(v15, (size_t)v13);

        unsigned int v9 = (char *)v9 + 1;
      }

      while (v6 != v9);
      id v6 = [v5 countByEnumeratingWithState:&v24 objects:v28 count:16];
      size_t v7 = (char *)v9 + (void)v10;
    }

    while (v6);
    uint64_t v16 = (char *)v9 + (void)v10;
  }

  else
  {
    uint64_t v16 = 0LL;
  }

  id v17 = [v5 count];
  uint64_t v18 = v23;
  xpc_object_t v19 = xpc_array_create(v23, (size_t)v17);
  uint64_t v20 = v18 - 1;
  while (v16)
    xpc_release(v20[(void)v16--]);

  return v19;
}

void sub_10043FC34(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

uint64_t sub_10043FC7C(void *a1, uint64_t a2, void *a3)
{
  uint64_t v5 = objc_claimAutoreleasedReturnValue(+[NSString stringWithUTF8String:](&OBJC_CLASS___NSString, "stringWithUTF8String:", a2));
  uint64_t v6 = a1[5];
  uint64_t v7 = *(void *)(*(void *)(a1[4] + 8LL) + 24LL);
  uint64_t v8 = *(void **)(v6 + 8 * v7);
  *(void *)(v6 + 8 * v7) = v5;

  unsigned int v9 = sub_10043FD08(a3);
  uint64_t v10 = objc_claimAutoreleasedReturnValue(v9);
  uint64_t v11 = a1[6];
  uint64_t v12 = *(void *)(*(void *)(a1[4] + 8LL) + 24LL);
  id v13 = *(void **)(v11 + 8 * v12);
  *(void *)(v11 + 8 * v12) = v10;

  ++*(void *)(*(void *)(a1[4] + 8LL) + 24LL);
  return 1LL;
}

NSUUID *sub_10043FD08(void *a1)
{
  xpc_type_t type = xpc_get_type(a1);
  if (type == (xpc_type_t)&_xpc_type_int64)
  {
    uint64_t v6 = +[NSNumber numberWithLongLong:](&OBJC_CLASS___NSNumber, "numberWithLongLong:", xpc_int64_get_value(a1));
    uint64_t v7 = (NSUUID *)objc_claimAutoreleasedReturnValue(v6);
    return v7;
  }

  xpc_type_t v3 = type;
  if (type == (xpc_type_t)&_xpc_type_uint64)
  {
    uint64_t v8 = +[NSNumber numberWithUnsignedLongLong:]( &OBJC_CLASS___NSNumber,  "numberWithUnsignedLongLong:",  xpc_uint64_get_value(a1));
    uint64_t v7 = (NSUUID *)objc_claimAutoreleasedReturnValue(v8);
    return v7;
  }

  if (type == (xpc_type_t)&_xpc_type_BOOL)
  {
    BOOL value = xpc_BOOL_get_value(a1);
    uint64_t v10 = &__kCFBooleanFalse;
    if (value) {
      uint64_t v10 = &__kCFBooleanTrue;
    }
    return (NSUUID *)v10;
  }

  else
  {
    if (type != (xpc_type_t)&_xpc_type_string)
    {
      if (type == (xpc_type_t)&_xpc_type_data)
      {
        uint64_t v16 = objc_alloc(&OBJC_CLASS___NSData);
        bytes_ptr = xpc_data_get_bytes_ptr(a1);
        uint64_t v7 = -[NSData initWithBytes:length:](v16, "initWithBytes:length:", bytes_ptr, xpc_data_get_length(a1));
      }

      else if (type == (xpc_type_t)&_xpc_type_uuid)
      {
        uint64_t v7 = -[NSUUID initWithUUIDBytes:]( objc_alloc(&OBJC_CLASS___NSUUID),  "initWithUUIDBytes:",  xpc_uuid_get_bytes(a1));
      }

      else if (type == (xpc_type_t)&_xpc_type_array)
      {
        uint64_t v18 = sub_10043E7E8(a1);
        uint64_t v7 = (NSUUID *)objc_claimAutoreleasedReturnValue(v18);
      }

      else if (type == (xpc_type_t)&_xpc_type_dictionary)
      {
        uint64_t v19 = sub_10043E470(a1);
        uint64_t v7 = (NSUUID *)objc_claimAutoreleasedReturnValue(v19);
      }

      else if (type == (xpc_type_t)&_xpc_type_fd)
      {
        uint64_t v20 = +[NSNumber numberWithInt:](&OBJC_CLASS___NSNumber, "numberWithInt:", xpc_fd_dup(a1));
        uint64_t v7 = (NSUUID *)objc_claimAutoreleasedReturnValue(v20);
      }

      else
      {
        if (type != (xpc_type_t)&_xpc_type_double)
        {
          id v4 = (os_log_s *)qword_1008F75F0;
          if (os_log_type_enabled((os_log_t)qword_1008F75F0, OS_LOG_TYPE_DEFAULT))
          {
            int v22 = 134217984;
            xpc_type_t v23 = v3;
            _os_log_impl( (void *)&_mh_execute_header,  v4,  OS_LOG_TYPE_DEFAULT,  "Unknown XPC type: %p",  (uint8_t *)&v22,  0xCu);
          }

          return (NSUUID *)0LL;
        }

        __int16 v21 = +[NSNumber numberWithDouble:](&OBJC_CLASS___NSNumber, "numberWithDouble:", xpc_double_get_value(a1));
        uint64_t v7 = (NSUUID *)objc_claimAutoreleasedReturnValue(v21);
      }

      return v7;
    }

    uint64_t v11 = +[NSString stringWithUTF8String:]( &OBJC_CLASS___NSString,  "stringWithUTF8String:",  xpc_string_get_string_ptr(a1));
    uint64_t v12 = objc_claimAutoreleasedReturnValue(v11);
    id v13 = (void *)v12;
    uint64_t v14 = &stru_1008A57D8;
    if (v12) {
      uint64_t v14 = (__CFString *)v12;
    }
    uint64_t v15 = v14;

    return (NSUUID *)v15;
  }

void sub_10043FFDC(void *a1, void *a2, void *a3)
{
  id v5 = a2;
  id v6 = a3;
  id v7 = v5;
  *(void *)(a1[5] + 8 * *(void *)(*(void *)(a1[4] + 8) + 24)) = [v7 UTF8String];
  *(void *)(a1[6] + 8LL * (*(void *)(*(void *)(a1[4] + 8LL) + 24LL))++) = sub_10044008C(v6);
}

void sub_100440074( _Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, id a10)
{
  _Unwind_Resume(a1);
}

uint64_t sub_10044008C(void *a1)
{
  id v1 = a1;
  if ([v1 isNSNumber])
  {
    if (CFNumberIsFloatType((CFNumberRef)v1))
    {
      [v1 doubleValue];
      xpc_object_t v3 = xpc_double_create(v2);
    }

    else
    {
      xpc_object_t v3 = xpc_int64_create((int64_t)[v1 longLongValue]);
    }
  }

  else if ([v1 isNSString])
  {
    xpc_object_t v3 = xpc_string_create((const char *)[v1 UTF8String]);
  }

  else if ([v1 isNSData])
  {
    id v4 = v1;
    xpc_object_t v3 = xpc_data_create([v4 bytes], (size_t)[v4 length]);
  }

  else
  {
    uint64_t v5 = objc_opt_class(&OBJC_CLASS___NSUUID);
    if ((objc_opt_isKindOfClass(v1, v5) & 1) != 0)
    {
      *(void *)uuid = 0LL;
      uint64_t v12 = 0LL;
      [v1 getUUIDBytes:uuid];
      xpc_object_t v3 = xpc_uuid_create(uuid);
    }

    else if ([v1 isNSArray])
    {
      xpc_object_t v3 = sub_10043E930(v1);
    }

    else if ([v1 isNSDictionary])
    {
      xpc_object_t v3 = (xpc_object_t)sub_10043E648(v1);
    }

    else
    {
      uint64_t v8 = objc_opt_class(&OBJC_CLASS___BTUUID);
      if ((objc_opt_isKindOfClass(v1, v8) & 1) != 0)
      {
        unsigned int v9 = (void *)objc_claimAutoreleasedReturnValue([v1 data]);
        uint64_t v6 = sub_10044008C();

        if (v6) {
          goto LABEL_17;
        }
        goto LABEL_16;
      }

      uint64_t v10 = objc_opt_class(&OBJC_CLASS___NSNull);
      if ((objc_opt_isKindOfClass(v1, v10) & 1) == 0)
      {
LABEL_16:
        +[NSException raise:format:]( &OBJC_CLASS___NSException,  "raise:format:",  @"Invalid Object",  @"Object %@ is invalid",  v1);
        uint64_t v6 = 0LL;
        goto LABEL_17;
      }

      xpc_object_t v3 = xpc_null_create();
    }
  }

  uint64_t v6 = (uint64_t)v3;
  if (!v3) {
    goto LABEL_16;
  }
LABEL_17:

  return v6;
}

void sub_100440270(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

uint64_t sub_100440298(uint64_t a1, uint64_t a2, uint64_t a3)
{
  uint64_t v5 = sub_10043FD08(a3);
  uint64_t v6 = objc_claimAutoreleasedReturnValue(v5);
  uint64_t v7 = *(void *)(a1 + 32);
  uint64_t v8 = *(void **)(v7 + 8 * a2);
  *(void *)(v7 + 8 * a2) = v6;

  return 1LL;
}

void sub_1004402D8(uint64_t a1, void *a2, uint64_t a3)
{
  id v5 = a2;
  *(void *)(*(void *)(a1 + 32) + 8 * a3) = sub_10044008C();
}

void sub_100440318( _Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, id a10)
{
}

void sub_10044032C(id a1)
{
  id v1 = operator new(0xA8uLL);
  sub_10040D0A0((uint64_t)v1);
  off_1008D6780 = v1;
}

void sub_10044035C(_Unwind_Exception *a1)
{
}

void sub_100440370(id a1)
{
  id v1 = operator new(0x230uLL);
  sub_100380B10();
  qword_1008D9260 = (uint64_t)v1;
}

void sub_1004403A0(_Unwind_Exception *a1)
{
}

uint64_t sub_1004403B4(uint64_t a1, unsigned __int8 *a2)
{
  double v2 = *(unsigned __int8 **)(a1 + 8);
  if (v2)
  {
    uint64_t v4 = 1LL;
    do
    {
      if (!sub_10063447C(a2, v2 + 28))
      {
        if (!sub_10063447C(v2 + 28, a2)) {
          return v4;
        }
        v2 += 8;
      }

      double v2 = *(unsigned __int8 **)v2;
    }

    while (v2);
  }

  return 0LL;
}

void sub_10044041C(void *a1, os_log_s *a2, uint64_t a3, const char *a4, uint8_t *a5)
{
}

uint64_t sub_100440428(uint64_t a1)
{
  *(void *)a1 = off_100898AC0;
  xpc_object_t v3 = *(void **)(a1 + 72);
  double v2 = *(void **)(a1 + 80);
  while (v3 != v2)
  {
    if (*v3)
    {
      (*(void (**)(void))(*(void *)*v3 + 8LL))(*v3);
      double v2 = *(void **)(a1 + 80);
    }

    ++v3;
  }

  uint64_t v4 = *(void **)(a1 + 120);
  if (v4)
  {
    *(void *)(a1 + 12_Block_object_dispose((const void *)(v2 - 88), 8) = v4;
    operator delete(v4);
  }

  sub_10023BF24(a1 + 96, *(void **)(a1 + 104));
  id v5 = *(void **)(a1 + 72);
  if (v5)
  {
    *(void *)(a1 + 8sub_100414D2C(qword_1008F72C0, 0) = v5;
    operator delete(v5);
  }

  sub_100242E28(a1 + 8);
  return a1;
}

void sub_1004404B8(uint64_t a1)
{
  id v1 = (void *)sub_100440428(a1);
  operator delete(v1);
}

uint64_t sub_1004404CC(uint64_t a1, unsigned __int8 **a2)
{
  v11[0] = 0LL;
  v11[1] = 0LL;
  sub_100242F28((uint64_t)v11, a1 + 8);
  id v5 = *(uint64_t **)(a1 + 72);
  uint64_t v4 = *(uint64_t **)(a1 + 80);
  if (v5 == v4)
  {
LABEL_8:
    uint64_t v9 = 0LL;
  }

  else
  {
    uint64_t v6 = a2[1];
    while (1)
    {
      uint64_t v7 = *a2;
      if (*a2 != v6) {
        break;
      }
LABEL_7:
      if (++v5 == v4) {
        goto LABEL_8;
      }
    }

    while (1)
    {
      uint64_t v8 = *v5;
      __n128 v13 = *(__n128 *)(*v5 + 72);
      int v14 = *(_DWORD *)(v8 + 88);
      sub_100634334(&v12, &v13);
      v7 += 20;
      if (v7 == a2[1])
      {
        uint64_t v4 = *(uint64_t **)(a1 + 80);
        uint64_t v6 = v7;
        goto LABEL_7;
      }
    }

    uint64_t v9 = 1LL;
  }

  sub_100242FAC((uint64_t)v11);
  return v9;
}

void sub_1004405C0( _Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, char a10)
{
}

uint64_t sub_1004405DC(uint64_t a1, void **a2)
{
  v20[0] = 0LL;
  v20[1] = 0LL;
  sub_100242F28((uint64_t)v20, a1 + 8);
  for (xpc_object_t i = *(void **)(a1 + 72); i != *(void **)(a1 + 80); ++i)
  {
    uint64_t v5 = (*(uint64_t (**)(void))(*(void *)*i + 16LL))(*i);
    uint64_t v6 = v5;
    uint64_t v8 = (uint64_t *)a2[1];
    unint64_t v7 = (unint64_t)a2[2];
    if ((unint64_t)v8 >= v7)
    {
      uint64_t v10 = ((char *)v8 - (_BYTE *)*a2) >> 3;
      uint64_t v11 = v7 - (void)*a2;
      uint64_t v12 = v11 >> 2;
      else {
        unint64_t v13 = v12;
      }
      if (v13) {
        int v14 = (char *)sub_100008BA0((uint64_t)(a2 + 2), v13);
      }
      else {
        int v14 = 0LL;
      }
      uint64_t v15 = (uint64_t *)&v14[8 * v10];
      *uint64_t v15 = v6;
      uint64_t v9 = v15 + 1;
      id v17 = (char *)*a2;
      uint64_t v16 = (char *)a2[1];
      if (v16 != *a2)
      {
        do
        {
          uint64_t v18 = *((void *)v16 - 1);
          v16 -= 8;
          *--uint64_t v15 = v18;
        }

        while (v16 != v17);
        uint64_t v16 = (char *)*a2;
      }

      *a2 = v15;
      a2[1] = v9;
      a2[2] = &v14[8 * v13];
      if (v16) {
        operator delete(v16);
      }
    }

    else
    {
      *uint64_t v8 = v5;
      uint64_t v9 = v8 + 1;
    }

    a2[1] = v9;
  }

  return sub_100242FAC((uint64_t)v20);
}

void sub_100440718( _Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9)
{
}

uint64_t sub_100440730(uint64_t a1, unsigned __int8 *a2, void **a3)
{
  v37[0] = 0LL;
  v37[1] = 0LL;
  sub_100242F28((uint64_t)v37, a1 + 8);
  char v36 = 0;
  sub_100242CA4(&v36);
  int v6 = sub_1000B9D24();
  if ((v6 & 1) == 0) {
    sub_100242CD0(&v36);
  }
  if (*(_BYTE *)(a1 + 144)) {
    goto LABEL_4;
  }
  if (!a2) {
    goto LABEL_37;
  }
  int v32 = *(unsigned __int8 **)(a1 + 120);
  uint64_t v33 = *(unsigned __int8 **)(a1 + 128);
  if (v32 == v33)
  {
    __int16 v34 = *(unsigned __int8 **)(a1 + 120);
  }

  else
  {
    while (!sub_1001BEC7C(v32, a2))
    {
      v32 += 20;
      if (v32 == v33)
      {
        int v32 = v33;
        break;
      }
    }

    __int16 v34 = v32;
    int v32 = *(unsigned __int8 **)(a1 + 128);
  }

  if (v34 != v32)
  {
LABEL_4:
    for (xpc_object_t i = *(void **)(a1 + 72); i != *(void **)(a1 + 80); ++i)
    {
      if (a2)
      {
        uint64_t v8 = *i;
        *(_OWORD *)__int128 buf = *(_OWORD *)(*i + 72LL);
        LODWORD(v41) = *(_DWORD *)(v8 + 88);
        sub_100634334(&v55, (__n128 *)buf);
        if (!sub_1001BEC7C(v9, a2)) {
          continue;
        }
      }

      uint64_t v10 = (*(uint64_t (**)(void))(*(void *)*i + 16LL))(*i);
      uint64_t v11 = v10;
      unint64_t v13 = (uint64_t *)a3[1];
      unint64_t v12 = (unint64_t)a3[2];
      if ((unint64_t)v13 >= v12)
      {
        uint64_t v15 = ((char *)v13 - (_BYTE *)*a3) >> 3;
        uint64_t v16 = v12 - (void)*a3;
        uint64_t v17 = v16 >> 2;
        else {
          unint64_t v18 = v17;
        }
        if (v18) {
          uint64_t v19 = (char *)sub_100008BA0((uint64_t)(a3 + 2), v18);
        }
        else {
          uint64_t v19 = 0LL;
        }
        uint64_t v20 = (uint64_t *)&v19[8 * v15];
        *uint64_t v20 = v11;
        int v14 = v20 + 1;
        int v22 = (char *)*a3;
        __int16 v21 = (char *)a3[1];
        if (v21 != *a3)
        {
          do
          {
            uint64_t v23 = *((void *)v21 - 1);
            v21 -= 8;
            *--uint64_t v20 = v23;
          }

          while (v21 != v22);
          __int16 v21 = (char *)*a3;
        }

        *a3 = v20;
        a3[1] = v14;
        a3[2] = &v19[8 * v18];
        if (v21) {
          operator delete(v21);
        }
      }

      else
      {
        *unint64_t v13 = v10;
        int v14 = v13 + 1;
      }

      a3[1] = v14;
      if (v6)
      {
        __int128 v53 = 0u;
        memset(v54, 0, sizeof(v54));
        __int128 v51 = 0u;
        __int128 v52 = 0u;
        __int128 v49 = 0u;
        __int128 v50 = 0u;
        __int128 v47 = 0u;
        __int128 v48 = 0u;
        __int128 v45 = 0u;
        __int128 v46 = 0u;
        __int128 v43 = 0u;
        __int128 v44 = 0u;
        __int128 v41 = 0u;
        __int128 v42 = 0u;
        *(_OWORD *)__int128 buf = 0u;
        *(_WORD *)&buf[1] = *(_WORD *)(a1 + 146);
        buf[3] = **(_BYTE **)(*i + 8LL);
        uint8_t buf[4] = *(_BYTE *)(*(void *)(*i + 8LL) + 1LL);
        uint64_t v24 = *(void *)(*i + 8LL);
        int v25 = *(_DWORD *)(v24 + 20);
        __n128 v55 = *(__n128 *)(v24 + 4);
        int v56 = v25;
        sub_100634334(&v39, &v55);
        buf[5] = v39.n128_u8[4];
        uint64_t v26 = *(void *)(*i + 8LL);
        int v27 = *(_DWORD *)(v26 + 20);
        __n128 v55 = *(__n128 *)(v26 + 4);
        int v56 = v27;
        sub_100634334(&v39, &v55);
        buf[6] = v39.n128_u8[5];
        __src[0] = 0LL;
        __src[1] = 0LL;
        uint64_t v28 = *i;
        __n128 v55 = *(__n128 *)(*i + 72LL);
        int v56 = *(_DWORD *)(v28 + 88);
        sub_100634334(&v39, &v55);
        unsigned int v29 = sub_10063443C((unsigned __int8 *)&v39, __src);
        buf[7] = v29;
        memcpy(&buf[8], __src, v29);
        sub_1000BAE4C(buf, v29 + 8);
      }
    }

    int v30 = (os_log_s *)qword_1008F75B0;
    if (os_log_type_enabled((os_log_t)qword_1008F75B0, OS_LOG_TYPE_INFO))
    {
      *(_WORD *)__int128 buf = 0;
      _os_log_impl((void *)&_mh_execute_header, v30, OS_LOG_TYPE_INFO, "Cached service hit!", buf, 2u);
    }

    uint64_t v31 = 0LL;
  }

  else
  {
LABEL_37:
    uint64_t v31 = 1LL;
  }

  sub_100242CD8(&v36);
  sub_100242FAC((uint64_t)v37);
  return v31;
}

void sub_100440AAC(_Unwind_Exception *a1, uint64_t a2, ...)
{
}

uint64_t sub_100440AF8(uint64_t a1, int a2, int a3, void **a4)
{
  v32[0] = 0LL;
  v32[1] = 0LL;
  sub_100242F28((uint64_t)v32, a1 + 8);
  for (xpc_object_t i = *(uint64_t **)(a1 + 72); ; ++i)
  {
    uint64_t v9 = *i;
  }

  if (!*(_BYTE *)(v9 + 128))
  {
LABEL_30:
    uint64_t v26 = 1LL;
    goto LABEL_31;
  }

  std::string __p = 0LL;
  int v30 = 0LL;
  uint64_t v31 = 0LL;
  sub_100240540(&__p, v9 + 104);
  uint64_t v10 = __p;
  if (__p != v30)
  {
    do
    {
      uint64_t v11 = (*(uint64_t (**)(void))(*(void *)*v10 + 16LL))(*v10);
      uint64_t v12 = v11;
      int v14 = (uint64_t *)a4[1];
      unint64_t v13 = (unint64_t)a4[2];
      if ((unint64_t)v14 >= v13)
      {
        uint64_t v16 = ((char *)v14 - (_BYTE *)*a4) >> 3;
        uint64_t v17 = v13 - (void)*a4;
        uint64_t v18 = v17 >> 2;
        else {
          unint64_t v19 = v18;
        }
        if (v19) {
          uint64_t v20 = (char *)sub_100008BA0((uint64_t)(a4 + 2), v19);
        }
        else {
          uint64_t v20 = 0LL;
        }
        __int16 v21 = (uint64_t *)&v20[8 * v16];
        *__int16 v21 = v12;
        uint64_t v15 = v21 + 1;
        uint64_t v23 = (char *)*a4;
        int v22 = (char *)a4[1];
        if (v22 != *a4)
        {
          do
          {
            uint64_t v24 = *((void *)v22 - 1);
            v22 -= 8;
            *--__int16 v21 = v24;
          }

          while (v22 != v23);
          int v22 = (char *)*a4;
        }

        *a4 = v21;
        a4[1] = v15;
        a4[2] = &v20[8 * v19];
        if (v22) {
          operator delete(v22);
        }
      }

      else
      {
        *int v14 = v11;
        uint64_t v15 = v14 + 1;
      }

      a4[1] = v15;
      ++v10;
    }

    while (v10 != v30);
  }

  int v25 = (os_log_s *)qword_1008F75B0;
  if (os_log_type_enabled((os_log_t)qword_1008F75B0, OS_LOG_TYPE_INFO))
  {
    __int16 v28 = 0;
    _os_log_impl((void *)&_mh_execute_header, v25, OS_LOG_TYPE_INFO, "Cached service hit!", (uint8_t *)&v28, 2u);
  }

  if (__p)
  {
    int v30 = __p;
    operator delete(__p);
  }

  uint64_t v26 = 0LL;
LABEL_31:
  sub_100242FAC((uint64_t)v32);
  return v26;
}

void sub_100440CF0( _Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void *__p, uint64_t a11, uint64_t a12, char a13)
{
}

uint64_t sub_100440D20(uint64_t a1, unsigned __int8 *a2, int a3, int a4, void **a5)
{
  v48[0] = 0LL;
  v48[1] = 0LL;
  sub_100242F28((uint64_t)v48, a1 + 8);
  char v47 = 0;
  sub_100242CA4(&v47);
  int v10 = sub_1000B9D24();
  if ((v10 & 1) == 0) {
    sub_100242CD0(&v47);
  }
  uint64_t v11 = *(uint64_t **)(a1 + 72);
  uint64_t v12 = *(uint64_t **)(a1 + 80);
  if (v11 == v12) {
    goto LABEL_7;
  }
  while (1)
  {
    uint64_t v13 = *v11;
    if (++v11 == v12) {
      goto LABEL_7;
    }
  }

  int v16 = *(unsigned __int8 *)(v13 + 160);
  if (a2)
  {
    BOOL v17 = sub_100441180(*v11, a2);
    if (v16) {
      char v18 = 1;
    }
    else {
      char v18 = v17;
    }
    if ((v18 & 1) != 0) {
      goto LABEL_16;
    }
LABEL_7:
    uint64_t v14 = 1LL;
    goto LABEL_8;
  }

  if (!*(_BYTE *)(v13 + 160)) {
    goto LABEL_7;
  }
LABEL_16:
  unint64_t v19 = (os_log_s *)qword_1008F75B0;
  if (os_log_type_enabled((os_log_t)qword_1008F75B0, OS_LOG_TYPE_INFO))
  {
    *(_WORD *)__int128 buf = 0;
    _os_log_impl((void *)&_mh_execute_header, v19, OS_LOG_TYPE_INFO, "Cached characteristics hit!", buf, 2u);
  }

  std::string __p = 0LL;
  __int128 v45 = 0LL;
  uint64_t v46 = 0LL;
  sub_100240540(&__p, v13 + 136);
  uint64_t v20 = __p;
  if (__p != v45)
  {
    do
    {
      if (!a2
        || (uint64_t v21 = *v20,
            *(_OWORD *)__int128 buf = *(_OWORD *)(*v20 + 76LL),
            LODWORD(v52) = *(_DWORD *)(v21 + 92),
            sub_100634334(&v66, (__n128 *)buf),
            sub_1001BEC7C(v22, a2)))
      {
        uint64_t v23 = (*(uint64_t (**)(void))(*(void *)*v20 + 16LL))(*v20);
        uint64_t v24 = v23;
        uint64_t v26 = (uint64_t *)a5[1];
        unint64_t v25 = (unint64_t)a5[2];
        if ((unint64_t)v26 >= v25)
        {
          uint64_t v28 = ((char *)v26 - (_BYTE *)*a5) >> 3;
          uint64_t v29 = v25 - (void)*a5;
          uint64_t v30 = v29 >> 2;
          else {
            unint64_t v31 = v30;
          }
          if (v31) {
            int v32 = (char *)sub_100008BA0((uint64_t)(a5 + 2), v31);
          }
          else {
            int v32 = 0LL;
          }
          uint64_t v33 = (uint64_t *)&v32[8 * v28];
          *uint64_t v33 = v24;
          int v27 = v33 + 1;
          __int128 v35 = (char *)*a5;
          __int16 v34 = (char *)a5[1];
          if (v34 != *a5)
          {
            do
            {
              uint64_t v36 = *((void *)v34 - 1);
              v34 -= 8;
              *--uint64_t v33 = v36;
            }

            while (v34 != v35);
            __int16 v34 = (char *)*a5;
          }

          *a5 = v33;
          a5[1] = v27;
          a5[2] = &v32[8 * v31];
          if (v34) {
            operator delete(v34);
          }
        }

        else
        {
          uint64_t *v26 = v23;
          int v27 = v26 + 1;
        }

        a5[1] = v27;
        if (v10)
        {
          __int128 v64 = 0u;
          memset(v65, 0, sizeof(v65));
          __int128 v62 = 0u;
          __int128 v63 = 0u;
          __int128 v60 = 0u;
          __int128 v61 = 0u;
          __int128 v58 = 0u;
          __int128 v59 = 0u;
          __int128 v56 = 0u;
          __int128 v57 = 0u;
          __int128 v54 = 0u;
          __int128 v55 = 0u;
          __int128 v52 = 0u;
          __int128 v53 = 0u;
          *(_OWORD *)__int128 buf = 0u;
          *(_WORD *)&buf[1] = *(_WORD *)(a1 + 146);
          buf[3] = **(_BYTE **)(*v20 + 8LL);
          uint8_t buf[4] = *(_BYTE *)(*(void *)(*v20 + 8LL) + 1LL);
          uint64_t v37 = *(void *)(*v20 + 8LL);
          int v38 = *(_DWORD *)(v37 + 20);
          __n128 v66 = *(__n128 *)(v37 + 4);
          int v67 = v38;
          sub_100634334(&v50, &v66);
          buf[5] = v50.n128_u8[4];
          uint64_t v39 = *(void *)(*v20 + 8LL);
          int v40 = *(_DWORD *)(v39 + 20);
          __n128 v66 = *(__n128 *)(v39 + 4);
          int v67 = v40;
          sub_100634334(&v50, &v66);
          buf[6] = v50.n128_u8[5];
          __src[0] = 0LL;
          __src[1] = 0LL;
          uint64_t v41 = *v20;
          __n128 v66 = *(__n128 *)(*v20 + 76LL);
          int v67 = *(_DWORD *)(v41 + 92);
          sub_100634334(&v50, &v66);
          unsigned int v42 = sub_10063443C((unsigned __int8 *)&v50, __src);
          buf[7] = v42;
          memcpy(&buf[8], __src, v42);
          sub_1000BAE4C(buf, v42 + 8);
        }
      }

      ++v20;
    }

    while (v20 != v45);
  }

  __int128 v43 = (os_log_s *)qword_1008F75B0;
  if (os_log_type_enabled((os_log_t)qword_1008F75B0, OS_LOG_TYPE_INFO))
  {
    *(_WORD *)__int128 buf = 0;
    _os_log_impl((void *)&_mh_execute_header, v43, OS_LOG_TYPE_INFO, "Cached service hit!", buf, 2u);
  }

  if (__p)
  {
    __int128 v45 = __p;
    operator delete(__p);
  }

  uint64_t v14 = 0LL;
LABEL_8:
  sub_100242CD8(&v47);
  sub_100242FAC((uint64_t)v48);
  return v14;
}

void sub_10044111C( _Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void *__p, uint64_t a11, uint64_t a12, int a13, __int16 a14, char a15, char a16, char a17)
{
}

BOOL sub_100441180(uint64_t a1, unsigned __int8 *a2)
{
  double v2 = *(unsigned __int8 **)(a1 + 168);
  xpc_object_t v3 = *(unsigned __int8 **)(a1 + 176);
  if (v2 == v3)
  {
    int v6 = *(unsigned __int8 **)(a1 + 168);
  }

  else
  {
    while (!sub_1001BEC7C(v2, a2))
    {
      v2 += 20;
      if (v2 == v3)
      {
        double v2 = v3;
        break;
      }
    }

    int v6 = v2;
    double v2 = *(unsigned __int8 **)(a1 + 176);
  }

  return v6 != v2;
}

uint64_t sub_1004411EC(uint64_t a1, __int16 a2, uint64_t a3, void **a4)
{
  v36[0] = 0LL;
  v36[1] = 0LL;
  sub_100242F28((uint64_t)v36, a1 + 8);
  uint64_t v9 = *(void *)(a1 + 104);
  uint64_t v8 = a1 + 104;
  uint64_t v7 = v9;
  if (!v9) {
    goto LABEL_38;
  }
  unsigned __int16 v10 = a2 - 2;
  uint64_t v11 = v8;
  do
  {
    unsigned int v12 = *(unsigned __int16 *)(v7 + 32);
    BOOL v13 = v12 >= v10;
    if (v12 >= v10) {
      uint64_t v14 = (uint64_t *)v7;
    }
    else {
      uint64_t v14 = (uint64_t *)(v7 + 8);
    }
    if (v13) {
      uint64_t v11 = v7;
    }
    uint64_t v7 = *v14;
  }

  while (*v14);
  if (v11 == v8) {
    goto LABEL_38;
  }
  uint64_t v15 = *(void *)(*(void *)(v11 + 40) + 8LL);
  int v16 = *(_DWORD *)(v15 + 20);
  *(_OWORD *)__int128 buf = *(_OWORD *)(v15 + 4);
  LODWORD(v3_Block_object_dispose((const void *)(v2 - 88), 8) = v16;
  sub_100634334(&v41, (__n128 *)buf);
  int v40 = 0;
  __int128 v39 = xmmword_1006C305C;
  uint64_t v17 = *(void *)(v11 + 40);
  if (*(_BYTE *)(v17 + 128))
  {
    char v18 = (os_log_s *)qword_1008F75B0;
    if (os_log_type_enabled((os_log_t)qword_1008F75B0, OS_LOG_TYPE_INFO))
    {
      *(_WORD *)__int128 buf = 0;
      _os_log_impl((void *)&_mh_execute_header, v18, OS_LOG_TYPE_INFO, "Cached descriptors hit!", buf, 2u);
    }

    memset(buf, 0, sizeof(buf));
    uint64_t v38 = 0LL;
    sub_100240540(buf, v17 + 104);
    unint64_t v19 = *(void **)buf;
    if (*(void *)buf != *(void *)&buf[8])
    {
      do
      {
        uint64_t v20 = (*(uint64_t (**)(void))(*(void *)*v19 + 16LL))(*v19);
        uint64_t v21 = v20;
        uint64_t v23 = (uint64_t *)a4[1];
        unint64_t v22 = (unint64_t)a4[2];
        if ((unint64_t)v23 >= v22)
        {
          uint64_t v25 = ((char *)v23 - (_BYTE *)*a4) >> 3;
          uint64_t v26 = v22 - (void)*a4;
          uint64_t v27 = v26 >> 2;
          else {
            unint64_t v28 = v27;
          }
          if (v28) {
            uint64_t v29 = (char *)sub_100008BA0((uint64_t)(a4 + 2), v28);
          }
          else {
            uint64_t v29 = 0LL;
          }
          uint64_t v30 = (uint64_t *)&v29[8 * v25];
          uint64_t *v30 = v21;
          uint64_t v24 = v30 + 1;
          int v32 = (char *)*a4;
          unint64_t v31 = (char *)a4[1];
          if (v31 != *a4)
          {
            do
            {
              uint64_t v33 = *((void *)v31 - 1);
              v31 -= 8;
              *--uint64_t v30 = v33;
            }

            while (v31 != v32);
            unint64_t v31 = (char *)*a4;
          }

          *a4 = v30;
          a4[1] = v24;
          a4[2] = &v29[8 * v28];
          if (v31) {
            operator delete(v31);
          }
        }

        else
        {
          *uint64_t v23 = v20;
          uint64_t v24 = v23 + 1;
        }

        a4[1] = v24;
        ++v19;
      }

      while (v19 != *(void **)&buf[8]);
      unint64_t v19 = *(void **)buf;
    }

    if (v19)
    {
      *(void *)&uint8_t buf[8] = v19;
      operator delete(v19);
    }

    uint64_t v34 = 0LL;
  }

  else
  {
LABEL_38:
    uint64_t v34 = 1LL;
  }

  sub_100242FAC((uint64_t)v36);
  return v34;
}

void sub_100441468( _Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, void *__p, uint64_t a12)
{
}

uint64_t sub_1004414A4(uint64_t a1, __int128 *a2, uint64_t **a3)
{
  v27[0] = 0LL;
  v27[1] = 0LL;
  sub_100242F28((uint64_t)v27, a1 + 8);
  for (xpc_object_t i = *a3; i != a3[1]; ++i)
  {
    __n128 v34 = 0uLL;
    int v35 = 0;
    uint64_t v7 = *(void *)(*i + 8);
    int v8 = *(_DWORD *)(v7 + 20);
    __n128 v36 = *(__n128 *)(v7 + 4);
    int v37 = v8;
    sub_100634334(&v34, &v36);
    int v33 = 0;
    __int128 v32 = xmmword_1006C3070;
    if (!sub_1001BEC7C((unsigned __int8 *)&v34, (unsigned __int8 *)&v32))
    {
      uint64_t v9 = (os_log_s *)qword_1008F75B0;
      if (os_log_type_enabled((os_log_t)qword_1008F75B0, OS_LOG_TYPE_FAULT)) {
        sub_10067FC1C(v30, &v31, v9);
      }
    }

    int v29 = 0;
    __int128 v28 = xmmword_1006C3070;
  }

  if (a2 && !*(_BYTE *)(a1 + 144))
  {
    unint64_t v10 = *(void *)(a1 + 136);
    unint64_t v11 = *(void *)(a1 + 128);
    if (v11 >= v10)
    {
      uint64_t v14 = *(void *)(a1 + 120);
      unint64_t v15 = 0xCCCCCCCCCCCCCCCDLL * ((uint64_t)(v11 - v14) >> 2);
      unint64_t v16 = v15 + 1;
      if (v15 + 1 > 0xCCCCCCCCCCCCCCCLL) {
        abort();
      }
      unint64_t v17 = 0xCCCCCCCCCCCCCCCDLL * ((uint64_t)(v10 - v14) >> 2);
      if (2 * v17 > v16) {
        unint64_t v16 = 2 * v17;
      }
      if (v17 >= 0x666666666666666LL) {
        unint64_t v18 = 0xCCCCCCCCCCCCCCCLL;
      }
      else {
        unint64_t v18 = v16;
      }
      if (v18) {
        unint64_t v19 = (char *)sub_100050420(a1 + 136, v18);
      }
      else {
        unint64_t v19 = 0LL;
      }
      uint64_t v20 = &v19[20 * v15];
      uint64_t v21 = &v19[20 * v18];
      __int128 v22 = *a2;
      *((_DWORD *)v20 + 4) = *((_DWORD *)a2 + 4);
      *(_OWORD *)uint64_t v20 = v22;
      BOOL v13 = v20 + 20;
      uint64_t v24 = *(char **)(a1 + 120);
      uint64_t v23 = *(char **)(a1 + 128);
      if (v23 != v24)
      {
        do
        {
          __int128 v25 = *(_OWORD *)(v23 - 20);
          *((_DWORD *)v20 - 1) = *((_DWORD *)v23 - 1);
          *(_OWORD *)(v20 - 2sub_100414D2C(qword_1008F72C0, 0) = v25;
          v20 -= 20;
          v23 -= 20;
        }

        while (v23 != v24);
        uint64_t v23 = *(char **)(a1 + 120);
      }

      *(void *)(a1 + 12sub_100414D2C(qword_1008F72C0, 0) = v20;
      *(void *)(a1 + 12_Block_object_dispose((const void *)(v2 - 88), 8) = v13;
      *(void *)(a1 + 136) = v21;
      if (v23) {
        operator delete(v23);
      }
    }

    else
    {
      __int128 v12 = *a2;
      *(_DWORD *)(v11 + 16) = *((_DWORD *)a2 + 4);
      *(_OWORD *)unint64_t v11 = v12;
      BOOL v13 = (char *)(v11 + 20);
    }

    *(void *)(a1 + 12_Block_object_dispose((const void *)(v2 - 88), 8) = v13;
  }

  else
  {
    *(_BYTE *)(a1 + 144) = 1;
  }

  return sub_100242FAC((uint64_t)v27);
}

void sub_100441710(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, ...)
{
}

uint64_t sub_100441730(uint64_t a1, uint64_t a2)
{
  v40[0] = 0LL;
  v40[1] = 0LL;
  sub_100242F28((uint64_t)v40, a1 + 8);
  uint64_t v5 = a1 + 104;
  uint64_t v4 = *(void *)(a1 + 104);
  int v6 = (unsigned __int16 **)(a2 + 8);
  unsigned int v7 = **(unsigned __int16 **)(a2 + 8);
  if (!v4) {
    goto LABEL_12;
  }
  uint64_t v8 = a1 + 104;
  do
  {
    unsigned int v9 = *(unsigned __int16 *)(v4 + 32);
    BOOL v10 = v9 >= v7;
    if (v9 >= v7) {
      unint64_t v11 = (uint64_t *)v4;
    }
    else {
      unint64_t v11 = (uint64_t *)(v4 + 8);
    }
    if (v10) {
      uint64_t v8 = v4;
    }
    uint64_t v4 = *v11;
  }

  while (*v11);
  if (v8 == v5 || v7 < *(unsigned __int16 *)(v8 + 32)) {
LABEL_12:
  }
    uint64_t v8 = a1 + 104;
  BOOL v13 = *(char **)(a1 + 72);
  __int128 v12 = *(char **)(a1 + 80);
  if (v13 == v12)
  {
LABEL_17:
    int v16 = 1;
  }

  else
  {
    uint64_t v14 = *(char **)(a1 + 72);
    while (1)
    {
      uint64_t v15 = *(void *)v14;
      v14 += 8;
      v13 += 8;
      if (v14 == v12) {
        goto LABEL_17;
      }
    }

    if (*(unsigned __int16 *)(v15 + 48) == *(unsigned __int16 *)(a2 + 48))
    {
      *(_OWORD *)&v42.__r_.__value_.__l.__data_ = *(_OWORD *)(v15 + 72);
      LODWORD(v42.__r_.__value_.__r.__words[2]) = *(_DWORD *)(v15 + 88);
      sub_100634334((__n128 *)&__p, (__n128 *)&v42);
      *(_OWORD *)&v42.__r_.__value_.__l.__data_ = *(_OWORD *)(a2 + 72);
      LODWORD(v42.__r_.__value_.__r.__words[2]) = *(_DWORD *)(a2 + 88);
      sub_100634334((__n128 *)buf, (__n128 *)&v42);
      if (sub_1001BEC7C((unsigned __int8 *)&__p, buf))
      {
        LOBYTE(v16) = 0;
        goto LABEL_46;
      }
    }

    unint64_t v17 = (os_log_s *)qword_1008F75B0;
    if (os_log_type_enabled((os_log_t)qword_1008F75B0, OS_LOG_TYPE_ERROR))
    {
      sub_100531170(*(void **)v14, &v42);
      int size = (char)v42.__r_.__value_.__s.__size_;
      std::string::size_type v37 = v42.__r_.__value_.__r.__words[0];
      sub_100531170((void *)a2, &__p);
      uint64_t v38 = &v42;
      if (size < 0) {
        uint64_t v38 = (std::string *)v37;
      }
      if ((__p.__r_.__value_.__s.__size_ & 0x80u) == 0) {
        p_p = &__p;
      }
      else {
        p_p = (std::string *)__p.__r_.__value_.__r.__words[0];
      }
      *(_DWORD *)__int128 buf = 136446466;
      __int128 v44 = v38;
      __int16 v45 = 2082;
      uint64_t v46 = p_p;
      _os_log_error_impl( (void *)&_mh_execute_header,  v17,  OS_LOG_TYPE_ERROR,  "Service changed while cached (was: %{public}s, now: %{public}s) - removing it",  buf,  0x16u);
    }

    sub_1004440AC(a1, v13);
    int v16 = 0;
  }

  unint64_t v18 = (uint64_t *)(*(uint64_t (**)(uint64_t))(*(void *)a2 + 16LL))(a2);
  unint64_t v19 = *(void *)(a1 + 88);
  uint64_t v20 = *(uint64_t ***)(a1 + 80);
  if ((unint64_t)v20 >= v19)
  {
    uint64_t v22 = *(void *)(a1 + 72);
    uint64_t v23 = ((uint64_t)v20 - v22) >> 3;
    uint64_t v24 = v19 - v22;
    uint64_t v25 = v24 >> 2;
    else {
      unint64_t v26 = v25;
    }
    if (v26) {
      uint64_t v27 = (char *)sub_100008BA0(a1 + 88, v26);
    }
    else {
      uint64_t v27 = 0LL;
    }
    __int128 v28 = (uint64_t **)&v27[8 * v23];
    int v29 = &v27[8 * v26];
    char *v28 = v18;
    uint64_t v21 = v28 + 1;
    uint64_t v31 = *(char **)(a1 + 72);
    uint64_t v30 = *(char **)(a1 + 80);
    if (v30 != v31)
    {
      do
      {
        __int128 v32 = (uint64_t *)*((void *)v30 - 1);
        v30 -= 8;
        *--__int128 v28 = v32;
      }

      while (v30 != v31);
      uint64_t v30 = *(char **)(a1 + 72);
    }

    *(void *)(a1 + 72) = v28;
    *(void *)(a1 + 8sub_100414D2C(qword_1008F72C0, 0) = v21;
    *(void *)(a1 + 8_Block_object_dispose((const void *)(v2 - 88), 8) = v29;
    if (v30) {
      operator delete(v30);
    }
  }

  else
  {
    *uint64_t v20 = v18;
    uint64_t v21 = v20 + 1;
  }

  *(void *)(a1 + 8sub_100414D2C(qword_1008F72C0, 0) = v21;
  LOWORD(__p.__r_.__value_.__l.__data_) = **v6;
  v42.__r_.__value_.__r.__words[0] = (std::string::size_type)&__p;
  sub_1002550B8((uint64_t **)(a1 + 96), (unsigned __int16 *)&__p, (uint64_t)&unk_1006C2518, &v42)[5] = v18;
  if (v8 == v5) {
    int v33 = 0;
  }
  else {
    int v33 = v16;
  }
  if (v33 == 1)
  {
    __n128 v34 = (os_log_s *)qword_1008F75B0;
    if (os_log_type_enabled((os_log_t)qword_1008F75B0, OS_LOG_TYPE_FAULT)) {
      sub_10067FC5C(v6, v34);
    }
    LOWORD(v42.__r_.__value_.__l.__data_) = **v6;
    sub_100329E44(a1 + 96, (unsigned __int16 *)&v42);
    return sub_100242FAC((uint64_t)v40);
  }

void sub_100441B0C( _Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, void *__p, uint64_t a16, int a17, __int16 a18, char a19, char a20)
{
}

uint64_t sub_100441B5C(void *a1, uint64_t **a2, unsigned int a3, unsigned int a4)
{
  v24[0] = 0LL;
  v24[1] = 0LL;
  sub_100242F28((uint64_t)v24, (uint64_t)(a1 + 1));
  uint64_t v8 = *a2;
  unsigned int v9 = a2[1];
  if (*a2 != v9)
  {
    do
    {
      uint64_t v10 = *v8;
      __n128 v33 = 0uLL;
      int v34 = 0;
      uint64_t v11 = *(void *)(v10 + 8);
      int v12 = *(_DWORD *)(v11 + 20);
      __n128 buf = *(__n128 *)(v11 + 4);
      int v36 = v12;
      sub_100634334(&v33, &buf);
      int v32 = 0;
      __int128 v31 = xmmword_1006C3084;
      if (!sub_1001BEC7C((unsigned __int8 *)&v33, (unsigned __int8 *)&v31))
      {
        BOOL v13 = (os_log_s *)qword_1008F75B0;
        if (os_log_type_enabled((os_log_t)qword_1008F75B0, OS_LOG_TYPE_FAULT)) {
          sub_10067FD20(v29, &v30, v13);
        }
      }

      int v28 = 0;
      __int128 v27 = xmmword_1006C3084;
      if (sub_1001BEC7C((unsigned __int8 *)&v33, (unsigned __int8 *)&v27))
      {
        sub_100441E6C(a1, v10);
        int v14 = *(unsigned __int16 *)(v10 + 72);
        for (uint64_t i = a1[9]; i != a1[10]; i += 8LL)
        {
        }

        int v16 = (os_log_s *)qword_1008F75B0;
        if (os_log_type_enabled((os_log_t)qword_1008F75B0, OS_LOG_TYPE_INFO))
        {
          buf.n128_u16[0] = 0;
          _os_log_impl( (void *)&_mh_execute_header,  v16,  OS_LOG_TYPE_INFO,  "Adding New Service Declaration For An Recently Discovered Included Service",  (uint8_t *)&buf,  2u);
          LOWORD(v14) = *(_WORD *)(v10 + 72);
        }

        __int16 v17 = *(_WORD *)(v10 + 74);
        __n128 v25 = 0uLL;
        unsigned int v26 = 0;
        __n128 buf = *(__n128 *)(v10 + 76);
        int v36 = *(_DWORD *)(v10 + 92);
        sub_100634334(&v25, &buf);
        unint64_t v18 = (char *)operator new(0xC0uLL);
        *(__n128 *)(v18 + 72) = v25;
        unsigned int v19 = v26;
        *((_DWORD *)v18 + 4) = 0;
        *(void *)unint64_t v18 = off_1008A0320;
        *((void *)v18 + 1) = v18 + 24;
        v18[96] = 0;
        *((void *)v18 + 22) = 0LL;
        *((void *)v18 + 23) = 0LL;
        *((void *)v18 + 21) = 0LL;
        *((void *)v18 + 14) = 0LL;
        *((void *)v18 + 15) = 0LL;
        *((void *)v18 + 13) = 0LL;
        v18[128] = 0;
        *((void *)v18 + 17) = 0LL;
        *((void *)v18 + 1_Block_object_dispose((const void *)(v2 - 88), 8) = 0LL;
        v18[160] = 0;
        *((void *)v18 + 19) = 0LL;
        *((_WORD *)v18 + 12) = v14;
        *((_WORD *)v18 + 13) = 0;
        *((_DWORD *)v18 + 11) = 0;
        *(_OWORD *)(v18 + 2_Block_object_dispose((const void *)(v2 - 88), 8) = xmmword_1006C3098;
        *((_WORD *)v18 + 24) = v17;
        *((void *)v18 + _Block_object_dispose((const void *)(v2 - 88), 8) = 0LL;
        *(void *)(v18 + 5sub_100414D2C(qword_1008F72C0, 0) = 0LL;
        *(void *)(v18 + 5_Block_object_dispose((const void *)(v2 - 88), 8) = 0LL;
        *((void *)v18 + 11) = v19;
        sub_100441730((uint64_t)a1, (uint64_t)v18);
        (*(void (**)(char *))(*(void *)v18 + 8LL))(v18);
      }

void sub_100441E44( _Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, char a14)
{
}

uint64_t sub_100441E6C(void *a1, uint64_t a2)
{
  v35[0] = 0LL;
  v35[1] = 0LL;
  sub_100242F28((uint64_t)v35, (uint64_t)(a1 + 1));
  uint64_t v5 = a1 + 13;
  uint64_t v4 = a1[13];
  int v6 = (uint64_t **)(a1 + 12);
  unsigned int v7 = **(unsigned __int16 **)(a2 + 8);
  if (!v4) {
    goto LABEL_12;
  }
  uint64_t v8 = a1 + 13;
  do
  {
    unsigned int v9 = *(unsigned __int16 *)(v4 + 32);
    BOOL v10 = v9 >= v7;
    if (v9 >= v7) {
      uint64_t v11 = (uint64_t *)v4;
    }
    else {
      uint64_t v11 = (uint64_t *)(v4 + 8);
    }
    if (v10) {
      uint64_t v8 = (void *)v4;
    }
    uint64_t v4 = *v11;
  }

  while (*v11);
  if (v8 == v5 || v7 < *((unsigned __int16 *)v8 + 16)) {
LABEL_12:
  }
    uint64_t v8 = a1 + 13;
  BOOL v13 = (void **)a1[9];
  int v12 = (void **)a1[10];
  if (v13 != v12)
  {
    while (v7 <= *(unsigned __int16 *)(*v13)[1] || v7 > *((unsigned __int16 *)*v13 + 24))
    {
      if (++v13 == v12) {
        goto LABEL_33;
      }
    }
  }

  if (v13 == v12)
  {
LABEL_33:
    if (os_log_type_enabled((os_log_t)qword_1008F75B0, OS_LOG_TYPE_ERROR))
    {
      sub_100531170((void *)a2, &v34);
      sub_10067FDA8();
    }

    int v21 = 0;
    goto LABEL_45;
  }

  int v14 = (os_log_s *)qword_1008F75B0;
  if (os_log_type_enabled((os_log_t)qword_1008F75B0, OS_LOG_TYPE_INFO))
  {
    sub_100531170(*v13, &v34);
    int size = (char)v34.__r_.__value_.__s.__size_;
    std::string::size_type v16 = v34.__r_.__value_.__r.__words[0];
    sub_100531170((void *)a2, &__p);
    __int16 v17 = &v34;
    if (size < 0) {
      __int16 v17 = (std::string *)v16;
    }
    if ((__p.__r_.__value_.__s.__size_ & 0x80u) == 0) {
      p_p = &__p;
    }
    else {
      p_p = (std::string *)__p.__r_.__value_.__r.__words[0];
    }
    LODWORD(buf.__r_.__value_.__l.__data_) = 136446466;
    *(std::string::size_type *)((char *)buf.__r_.__value_.__r.__words + 4) = (std::string::size_type)v17;
    WORD2(buf.__r_.__value_.__r.__words[1]) = 2082;
    *(std::string::size_type *)((char *)&buf.__r_.__value_.__r.__words[1] + 6) = (std::string::size_type)p_p;
    _os_log_impl( (void *)&_mh_execute_header,  v14,  OS_LOG_TYPE_INFO,  "Found service %{public}s for included service %{public}s",  (uint8_t *)&buf,  0x16u);
  }

  memset(&v34, 0, sizeof(v34));
  sub_100240540(&v34, (uint64_t)(*v13 + 13));
  unsigned int v19 = (uint64_t *)v34.__r_.__value_.__r.__words[0];
  if (v34.__r_.__value_.__r.__words[0] == v34.__r_.__value_.__l.__size_)
  {
LABEL_32:
    int v21 = 0;
  }

  else
  {
    while (1)
    {
      uint64_t v20 = *v19;
    }

    if (*(unsigned __int16 *)(v20 + 72) == *(unsigned __int16 *)(a2 + 72)
      && *(unsigned __int16 *)(v20 + 74) == *(unsigned __int16 *)(a2 + 74))
    {
      *(_OWORD *)&__p.__r_.__value_.__l.__data_ = *(_OWORD *)(v20 + 76);
      LODWORD(__p.__r_.__value_.__r.__words[2]) = *(_DWORD *)(v20 + 92);
      sub_100634334((__n128 *)&buf, (__n128 *)&__p);
      *(_OWORD *)&__p.__r_.__value_.__l.__data_ = *(_OWORD *)(a2 + 76);
      LODWORD(__p.__r_.__value_.__r.__words[2]) = *(_DWORD *)(a2 + 92);
      sub_100634334((__n128 *)v37, (__n128 *)&__p);
      if (sub_1001BEC7C((unsigned __int8 *)&buf, v37))
      {
        int v21 = 1;
        goto LABEL_43;
      }
    }

    uint64_t v22 = (os_log_s *)qword_1008F75B0;
    if (os_log_type_enabled((os_log_t)qword_1008F75B0, OS_LOG_TYPE_ERROR))
    {
      sub_100531170((void *)*v19, &__p);
      int v30 = (char)__p.__r_.__value_.__s.__size_;
      std::string::size_type v31 = __p.__r_.__value_.__r.__words[0];
      sub_100531170((void *)a2, &buf);
      int v32 = &__p;
      if (v30 < 0) {
        int v32 = (std::string *)v31;
      }
      p_std::string buf = &buf;
      if ((buf.__r_.__value_.__s.__size_ & 0x80u) != 0) {
        p_std::string buf = (std::string *)buf.__r_.__value_.__r.__words[0];
      }
      *(_DWORD *)std::string::size_type v37 = 136446466;
      uint64_t v38 = v32;
      __int16 v39 = 2082;
      int v40 = p_buf;
      _os_log_error_impl( (void *)&_mh_execute_header,  v22,  OS_LOG_TYPE_ERROR,  "Included service changed while cached (was: %{public}s, now: %{public}s) - removing it",  v37,  0x16u);
    }

    LOWORD(__p.__r_.__value_.__l.__data_) = **(_WORD **)(a2 + 8);
    sub_100329E44((uint64_t)v6, (unsigned __int16 *)&__p);
    sub_100282FC4(*v13, *v19);
    int v21 = 1;
  }

  uint64_t v23 = (uint64_t *)(*(uint64_t (**)(uint64_t))(*(void *)a2 + 16LL))(a2);
  sub_1003826DC(*v13, (uint64_t)v23);
  LOWORD(buf.__r_.__value_.__l.__data_) = **(_WORD **)(a2 + 8);
  __p.__r_.__value_.__r.__words[0] = (std::string::size_type)&buf;
  sub_1002550B8(v6, (unsigned __int16 *)&buf, (uint64_t)&unk_1006C2518, &__p)[5] = v23;
LABEL_43:
  if (v34.__r_.__value_.__r.__words[0])
  {
    v34.__r_.__value_.__l.__size_ = v34.__r_.__value_.__r.__words[0];
    operator delete(v34.__r_.__value_.__l.__data_);
  }

void sub_100442344( _Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void *__p, uint64_t a11, int a12, __int16 a13, char a14, char a15, char a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20, uint64_t a21, uint64_t a22, uint64_t a23, uint64_t a24, uint64_t a25, void *a26, uint64_t a27, int a28, __int16 a29, char a30, char a31)
{
  if (__p) {
    operator delete(__p);
  }
  sub_100242FAC((uint64_t)&a16);
  _Unwind_Resume(a1);
}

uint64_t sub_1004423CC(void *a1, __int128 *a2, uint64_t **a3, unsigned int a4, unsigned int a5)
{
  v18[0] = 0LL;
  v18[1] = 0LL;
  sub_100242F28((uint64_t)v18, (uint64_t)(a1 + 1));
  for (uint64_t i = *a3; i != a3[1]; ++i)
  {
    __n128 v25 = 0uLL;
    int v26 = 0;
    uint64_t v11 = *(void *)(*i + 8);
    int v12 = *(_DWORD *)(v11 + 20);
    __n128 v27 = *(__n128 *)(v11 + 4);
    int v28 = v12;
    sub_100634334(&v25, &v27);
    int v24 = 0;
    __int128 v23 = xmmword_1006C305C;
    if (!sub_1001BEC7C((unsigned __int8 *)&v25, (unsigned __int8 *)&v23))
    {
      BOOL v13 = (os_log_s *)qword_1008F75B0;
      if (os_log_type_enabled((os_log_t)qword_1008F75B0, OS_LOG_TYPE_FAULT)) {
        sub_10067FDF0(v21, &v22, v13);
      }
    }

    int v20 = 0;
    __int128 v19 = xmmword_1006C305C;
  }

  uint64_t v15 = (uint64_t *)a1[9];
  for (j = (uint64_t *)a1[10]; v15 != j; ++v15)
  {
    uint64_t v16 = *v15;
    if (**(unsigned __int16 **)(*v15 + 8) >= a4 && *(unsigned __int16 *)(v16 + 48) <= a5)
    {
      if (a2)
      {
        sub_100442B00((void *)v16, a2);
        j = (uint64_t *)a1[10];
      }

      else
      {
        *(_BYTE *)(v16 + 16sub_100414D2C(qword_1008F72C0, 0) = 1;
      }
    }
  }

  return sub_100242FAC((uint64_t)v18);
}

void sub_100442584(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, ...)
{
}

uint64_t sub_1004425A4(void *a1, uint64_t a2)
{
  v35[0] = 0LL;
  v35[1] = 0LL;
  sub_100242F28((uint64_t)v35, (uint64_t)(a1 + 1));
  uint64_t v5 = a1 + 13;
  uint64_t v4 = a1[13];
  int v6 = (uint64_t **)(a1 + 12);
  unsigned int v7 = **(unsigned __int16 **)(a2 + 8);
  if (!v4) {
    goto LABEL_12;
  }
  uint64_t v8 = a1 + 13;
  do
  {
    unsigned int v9 = *(unsigned __int16 *)(v4 + 32);
    BOOL v10 = v9 >= v7;
    if (v9 >= v7) {
      uint64_t v11 = (uint64_t *)v4;
    }
    else {
      uint64_t v11 = (uint64_t *)(v4 + 8);
    }
    if (v10) {
      uint64_t v8 = (void *)v4;
    }
    uint64_t v4 = *v11;
  }

  while (*v11);
  if (v8 == v5 || v7 < *((unsigned __int16 *)v8 + 16)) {
LABEL_12:
  }
    uint64_t v8 = a1 + 13;
  BOOL v13 = (void **)a1[9];
  int v12 = (void **)a1[10];
  if (v13 != v12)
  {
    while (v7 <= *(unsigned __int16 *)(*v13)[1] || v7 > *((unsigned __int16 *)*v13 + 24))
    {
      if (++v13 == v12) {
        goto LABEL_33;
      }
    }
  }

  if (v13 == v12)
  {
LABEL_33:
    if (os_log_type_enabled((os_log_t)qword_1008F75B0, OS_LOG_TYPE_ERROR))
    {
      sub_100531170((void *)a2, &v34);
      sub_10067FE30();
    }

    int v21 = 0;
    goto LABEL_45;
  }

  int v14 = (os_log_s *)qword_1008F75B0;
  if (os_log_type_enabled((os_log_t)qword_1008F75B0, OS_LOG_TYPE_INFO))
  {
    sub_100531170(*v13, &v34);
    int size = (char)v34.__r_.__value_.__s.__size_;
    std::string::size_type v16 = v34.__r_.__value_.__r.__words[0];
    sub_100531170((void *)a2, &__p);
    __int16 v17 = &v34;
    if (size < 0) {
      __int16 v17 = (std::string *)v16;
    }
    if ((__p.__r_.__value_.__s.__size_ & 0x80u) == 0) {
      p_p = &__p;
    }
    else {
      p_p = (std::string *)__p.__r_.__value_.__r.__words[0];
    }
    LODWORD(buf.__r_.__value_.__l.__data_) = 136446466;
    *(std::string::size_type *)((char *)buf.__r_.__value_.__r.__words + 4) = (std::string::size_type)v17;
    WORD2(buf.__r_.__value_.__r.__words[1]) = 2082;
    *(std::string::size_type *)((char *)&buf.__r_.__value_.__r.__words[1] + 6) = (std::string::size_type)p_p;
    _os_log_impl( (void *)&_mh_execute_header,  v14,  OS_LOG_TYPE_INFO,  "Found service %{public}s for characteristic %{public}s",  (uint8_t *)&buf,  0x16u);
  }

  memset(&v34, 0, sizeof(v34));
  sub_100240540(&v34, (uint64_t)(*v13 + 17));
  __int128 v19 = (uint64_t *)v34.__r_.__value_.__r.__words[0];
  if (v34.__r_.__value_.__r.__words[0] == v34.__r_.__value_.__l.__size_)
  {
LABEL_32:
    int v21 = 0;
  }

  else
  {
    while (1)
    {
      uint64_t v20 = *v19;
    }

    if (*(unsigned __int16 *)(v20 + 74) == *(unsigned __int16 *)(a2 + 74))
    {
      *(_OWORD *)&__p.__r_.__value_.__l.__data_ = *(_OWORD *)(v20 + 76);
      LODWORD(__p.__r_.__value_.__r.__words[2]) = *(_DWORD *)(v20 + 92);
      sub_100634334((__n128 *)&buf, (__n128 *)&__p);
      *(_OWORD *)&__p.__r_.__value_.__l.__data_ = *(_OWORD *)(a2 + 76);
      LODWORD(__p.__r_.__value_.__r.__words[2]) = *(_DWORD *)(a2 + 92);
      sub_100634334((__n128 *)v37, (__n128 *)&__p);
      if (sub_1001BEC7C((unsigned __int8 *)&buf, v37)
        && *(unsigned __int8 *)(*v19 + 72) == *(unsigned __int8 *)(a2 + 72))
      {
        int v21 = 1;
        goto LABEL_43;
      }
    }

    uint64_t v22 = (os_log_s *)qword_1008F75B0;
    if (os_log_type_enabled((os_log_t)qword_1008F75B0, OS_LOG_TYPE_ERROR))
    {
      sub_100531170((void *)*v19, &__p);
      int v30 = (char)__p.__r_.__value_.__s.__size_;
      std::string::size_type v31 = __p.__r_.__value_.__r.__words[0];
      sub_100531170((void *)a2, &buf);
      int v32 = &__p;
      if (v30 < 0) {
        int v32 = (std::string *)v31;
      }
      p_std::string buf = &buf;
      if ((buf.__r_.__value_.__s.__size_ & 0x80u) != 0) {
        p_std::string buf = (std::string *)buf.__r_.__value_.__r.__words[0];
      }
      *(_DWORD *)std::string::size_type v37 = 136446466;
      uint64_t v38 = v32;
      __int16 v39 = 2082;
      int v40 = p_buf;
      _os_log_error_impl( (void *)&_mh_execute_header,  v22,  OS_LOG_TYPE_ERROR,  "Characteristic changed while cached (was: %{public}s, now: %{public}s) - removing it",  v37,  0x16u);
    }

    sub_10044426C((uint64_t)a1, *v13, *v19);
    int v21 = 1;
  }

  __int128 v23 = (uint64_t *)(*(uint64_t (**)(uint64_t))(*(void *)a2 + 16LL))(a2);
  sub_100381DC0(*v13, (uint64_t)v23);
  LOWORD(buf.__r_.__value_.__l.__data_) = **(_WORD **)(a2 + 8);
  __p.__r_.__value_.__r.__words[0] = (std::string::size_type)&buf;
  sub_1002550B8(v6, (unsigned __int16 *)&buf, (uint64_t)&unk_1006C2518, &__p)[5] = v23;
LABEL_43:
  if (v34.__r_.__value_.__r.__words[0])
  {
    v34.__r_.__value_.__l.__size_ = v34.__r_.__value_.__r.__words[0];
    operator delete(v34.__r_.__value_.__l.__data_);
  }

void sub_100442A7C( _Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void *__p, uint64_t a11, int a12, __int16 a13, char a14, char a15, char a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20, uint64_t a21, uint64_t a22, uint64_t a23, uint64_t a24, uint64_t a25, void *a26, uint64_t a27, int a28, __int16 a29, char a30, char a31)
{
  if (__p) {
    operator delete(__p);
  }
  sub_100242FAC((uint64_t)&a16);
  _Unwind_Resume(a1);
}

void sub_100442B00(void *a1, __int128 *a2)
{
  unint64_t v6 = a1[23];
  uint64_t v4 = (uint64_t)(a1 + 23);
  unint64_t v5 = v6;
  unint64_t v7 = *(void *)(v4 - 8);
  if (v7 >= v6)
  {
    uint64_t v10 = a1[21];
    unint64_t v11 = 0xCCCCCCCCCCCCCCCDLL * ((uint64_t)(v7 - v10) >> 2);
    unint64_t v12 = v11 + 1;
    if (v11 + 1 > 0xCCCCCCCCCCCCCCCLL) {
      abort();
    }
    unint64_t v13 = 0xCCCCCCCCCCCCCCCDLL * ((uint64_t)(v5 - v10) >> 2);
    if (2 * v13 > v12) {
      unint64_t v12 = 2 * v13;
    }
    if (v13 >= 0x666666666666666LL) {
      unint64_t v14 = 0xCCCCCCCCCCCCCCCLL;
    }
    else {
      unint64_t v14 = v12;
    }
    if (v14) {
      uint64_t v15 = (char *)sub_100050420(v4, v14);
    }
    else {
      uint64_t v15 = 0LL;
    }
    std::string::size_type v16 = &v15[20 * v11];
    __int16 v17 = &v15[20 * v14];
    __int128 v18 = *a2;
    *((_DWORD *)v16 + 4) = *((_DWORD *)a2 + 4);
    *(_OWORD *)std::string::size_type v16 = v18;
    unsigned int v9 = v16 + 20;
    uint64_t v20 = (char *)a1[21];
    __int128 v19 = (char *)a1[22];
    if (v19 != v20)
    {
      do
      {
        __int128 v21 = *(_OWORD *)(v19 - 20);
        *((_DWORD *)v16 - 1) = *((_DWORD *)v19 - 1);
        *(_OWORD *)(v16 - 2sub_100414D2C(qword_1008F72C0, 0) = v21;
        v16 -= 20;
        v19 -= 20;
      }

      while (v19 != v20);
      __int128 v19 = (char *)a1[21];
    }

    a1[21] = v16;
    a1[22] = v9;
    a1[23] = v17;
    if (v19) {
      operator delete(v19);
    }
  }

  else
  {
    __int128 v8 = *a2;
    *(_DWORD *)(v7 + 16) = *((_DWORD *)a2 + 4);
    *(_OWORD *)unint64_t v7 = v8;
    unsigned int v9 = (char *)(v7 + 20);
  }

  a1[22] = v9;
}

uint64_t sub_100442C20(uint64_t a1, uint64_t a2, int a3)
{
  v7[0] = 0LL;
  v7[1] = 0LL;
  sub_100242F28((uint64_t)v7, a1 + 8);
  sub_100442C90(a1, a2, a3);
  return sub_100242FAC((uint64_t)v7);
}

void sub_100442C7C( _Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9)
{
}

uint64_t sub_100442C90(uint64_t a1, uint64_t a2, int a3)
{
  v20[0] = 0LL;
  v20[1] = 0LL;
  sub_100242F28((uint64_t)v20, a1 + 8);
  unint64_t v7 = *(void ***)(a1 + 72);
  unint64_t v6 = *(void ***)(a1 + 80);
  if (v7 != v6)
  {
    unsigned int v8 = **(unsigned __int16 **)(a2 + 8);
    while (v8 <= *(unsigned __int16 *)(*v7)[1] || v8 > *((unsigned __int16 *)*v7 + 24))
    {
      if (++v7 == v6) {
        goto LABEL_24;
      }
    }
  }

  if (v7 == v6)
  {
LABEL_24:
    if (os_log_type_enabled((os_log_t)qword_1008F75B0, OS_LOG_TYPE_ERROR))
    {
      sub_100531170((void *)a2, &v19);
      sub_10067FE78();
    }
  }

  else
  {
    unsigned int v9 = (os_log_s *)qword_1008F75B0;
    if (os_log_type_enabled((os_log_t)qword_1008F75B0, OS_LOG_TYPE_INFO))
    {
      sub_100531170(*v7, &v19);
      int size = (char)v19.__r_.__value_.__s.__size_;
      std::string::size_type v11 = v19.__r_.__value_.__r.__words[0];
      sub_100531170((void *)a2, &__p);
      unint64_t v12 = &v19;
      if (size < 0) {
        unint64_t v12 = (std::string *)v11;
      }
      if ((__p.__r_.__value_.__s.__size_ & 0x80u) == 0) {
        p_p = &__p;
      }
      else {
        p_p = (std::string *)__p.__r_.__value_.__r.__words[0];
      }
      *(_DWORD *)std::string buf = 136446466;
      __int128 v23 = v12;
      __int16 v24 = 2082;
      BOOL v25 = p_p;
      _os_log_impl( (void *)&_mh_execute_header,  v9,  OS_LOG_TYPE_INFO,  "Found service %{public}s for value %{public}s",  buf,  0x16u);
    }

    memset(&v19, 0, sizeof(v19));
    sub_100240540(&v19, (uint64_t)(*v7 + 17));
    std::string::size_type v14 = v19.__r_.__value_.__r.__words[0];
    if (v19.__r_.__value_.__r.__words[0] == v19.__r_.__value_.__l.__size_)
    {
LABEL_21:
      if (a3 && os_log_type_enabled((os_log_t)qword_1008F75B0, OS_LOG_TYPE_ERROR))
      {
        sub_100531170((void *)a2, &__p);
        sub_10067FEC0();
      }
    }

    else
    {
      while (**(unsigned __int16 **)(a2 + 8) - 1 != **(unsigned __int16 **)(*(void *)v14 + 8LL))
      {
        v14 += 8LL;
        if (v14 == v19.__r_.__value_.__l.__size_) {
          goto LABEL_21;
        }
      }

      uint64_t v15 = (uint64_t *)(*(uint64_t (**)(uint64_t))(*(void *)a2 + 16LL))(a2);
      uint64_t v16 = *(void *)v14;
      uint64_t v17 = *(void *)(v16 + 96);
      if (v17) {
        (*(void (**)(uint64_t))(*(void *)v17 + 8LL))(v17);
      }
      *(void *)(v16 + 96) = v15;
      *(_WORD *)std::string buf = **(_WORD **)(a2 + 8);
      __p.__r_.__value_.__r.__words[0] = (std::string::size_type)buf;
      sub_1002550B8((uint64_t **)(a1 + 96), (unsigned __int16 *)buf, (uint64_t)&unk_1006C2518, &__p)[5] = v15;
    }

    if (v19.__r_.__value_.__r.__words[0])
    {
      v19.__r_.__value_.__l.__size_ = v19.__r_.__value_.__r.__words[0];
      operator delete(v19.__r_.__value_.__l.__data_);
    }
  }

  return sub_100242FAC((uint64_t)v20);
}

void sub_100442F58( _Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, void *__p, uint64_t a10, int a11, __int16 a12, char a13, char a14, char a15)
{
  if (__p) {
    operator delete(__p);
  }
  sub_100242FAC((uint64_t)&a15);
  _Unwind_Resume(a1);
}

uint64_t sub_100442FB0(void *a1, uint64_t **a2, __int16 a3)
{
  v18[0] = 0LL;
  v18[1] = 0LL;
  sub_100242F28((uint64_t)v18, (uint64_t)(a1 + 1));
  for (uint64_t i = *a2; i != a2[1]; ++i)
    sub_100443100(a1, *i);
  uint64_t v9 = a1[13];
  unsigned int v8 = a1 + 13;
  uint64_t v7 = v9;
  if (v9)
  {
    unsigned __int16 v10 = a3 - 2;
    std::string::size_type v11 = v8;
    do
    {
      unsigned int v12 = *(unsigned __int16 *)(v7 + 32);
      BOOL v13 = v12 >= v10;
      if (v12 >= v10) {
        std::string::size_type v14 = (uint64_t *)v7;
      }
      else {
        std::string::size_type v14 = (uint64_t *)(v7 + 8);
      }
      if (v13) {
        std::string::size_type v11 = (void *)v7;
      }
      uint64_t v7 = *v14;
    }

    while (*v14);
    if (v11 != v8 && *((unsigned __int16 *)v11 + 16) <= v10)
    {
      uint64_t v15 = *(void *)(v11[5] + 8LL);
      int v16 = *(_DWORD *)(v15 + 20);
      __n128 v22 = *(__n128 *)(v15 + 4);
      int v23 = v16;
      sub_100634334(&v21, &v22);
      int v20 = 0;
      __int128 v19 = xmmword_1006C305C;
    }
  }

  return sub_100242FAC((uint64_t)v18);
}

void sub_1004430E0( _Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9)
{
}

uint64_t sub_100443100(void *a1, uint64_t a2)
{
  v59[0] = 0LL;
  v59[1] = 0LL;
  sub_100242F28((uint64_t)v59, (uint64_t)(a1 + 1));
  unint64_t v5 = a1 + 13;
  uint64_t v4 = a1[13];
  unint64_t v6 = (uint64_t **)(a1 + 12);
  unsigned int v7 = **(unsigned __int16 **)(a2 + 8);
  if (!v4) {
    goto LABEL_12;
  }
  unsigned int v8 = a1 + 13;
  do
  {
    unsigned int v9 = *(unsigned __int16 *)(v4 + 32);
    BOOL v10 = v9 >= v7;
    if (v9 >= v7) {
      std::string::size_type v11 = (uint64_t *)v4;
    }
    else {
      std::string::size_type v11 = (uint64_t *)(v4 + 8);
    }
    if (v10) {
      unsigned int v8 = (void *)v4;
    }
    uint64_t v4 = *v11;
  }

  while (*v11);
  if (v8 == v5 || v7 < *((unsigned __int16 *)v8 + 16)) {
LABEL_12:
  }
    unsigned int v8 = a1 + 13;
  BOOL v13 = (void **)a1[9];
  unsigned int v12 = (void **)a1[10];
  if (v13 != v12)
  {
    while (v7 <= *(unsigned __int16 *)(*v13)[1] || v7 > *((unsigned __int16 *)*v13 + 24))
    {
      if (++v13 == v12) {
        goto LABEL_52;
      }
    }
  }

  if (v13 == v12)
  {
LABEL_52:
    if (os_log_type_enabled((os_log_t)qword_1008F75B0, OS_LOG_TYPE_ERROR))
    {
      sub_100531170((void *)a2, &__p);
      sub_10067FF50();
    }

    int v33 = 0;
    goto LABEL_92;
  }

  std::string::size_type v14 = (os_log_s *)qword_1008F75B0;
  if (os_log_type_enabled((os_log_t)qword_1008F75B0, OS_LOG_TYPE_INFO))
  {
    sub_100531170(*v13, &__p);
    int size = (char)__p.__r_.__value_.__s.__size_;
    std::string::size_type v16 = __p.__r_.__value_.__r.__words[0];
    sub_100531170((void *)a2, &v68);
    p_p = &__p;
    if (size < 0) {
      p_p = (std::string *)v16;
    }
    if ((v68.__r_.__value_.__s.__size_ & 0x80u) == 0) {
      __int128 v18 = &v68;
    }
    else {
      __int128 v18 = (std::string *)v68.__r_.__value_.__r.__words[0];
    }
    LODWORD(buf.__r_.__value_.__l.__data_) = 136446466;
    *(std::string::size_type *)((char *)buf.__r_.__value_.__r.__words + 4) = (std::string::size_type)p_p;
    WORD2(buf.__r_.__value_.__r.__words[1]) = 2082;
    *(std::string::size_type *)((char *)&buf.__r_.__value_.__r.__words[1] + 6) = (std::string::size_type)v18;
    _os_log_impl( (void *)&_mh_execute_header,  v14,  OS_LOG_TYPE_INFO,  "Found service %{public}s for descriptor %{public}s",  (uint8_t *)&buf,  0x16u);
  }

  memset(&__p, 0, sizeof(__p));
  sub_100240540(&__p, (uint64_t)(*v13 + 17));
  __int128 v19 = (void **)__p.__r_.__value_.__r.__words[0];
  if (__p.__r_.__value_.__r.__words[0] != __p.__r_.__value_.__l.__size_)
  {
    while (1)
    {
      memset(&v68, 0, sizeof(v68));
      sub_100240540(&v68, (uint64_t)(*v19 + 13));
      int v20 = (void *)v68.__r_.__value_.__r.__words[0];
      if (v68.__r_.__value_.__r.__words[0] != v68.__r_.__value_.__l.__size_) {
        break;
      }
LABEL_34:
      char v23 = 1;
      if (v68.__r_.__value_.__r.__words[0]) {
        goto LABEL_35;
      }
LABEL_36:
      if ((v23 & 1) == 0)
      {
        int v33 = 1;
        goto LABEL_90;
      }

      if (++v19 == (void **)__p.__r_.__value_.__l.__size_) {
        goto LABEL_55;
      }
    }

    __n128 v21 = (uint64_t *)v68.__r_.__value_.__r.__words[0];
    while (1)
    {
      __n128 v22 = *(unsigned __int16 **)(*v21 + 8);
    }

    __int128 v24 = *(_OWORD *)(v22 + 2);
    LODWORD(buf.__r_.__value_.__r.__words[2]) = *((_DWORD *)v22 + 5);
    *(_OWORD *)&buf.__r_.__value_.__l.__data_ = v24;
    sub_100634334((__n128 *)&v62, (__n128 *)&buf);
    uint64_t v25 = *(void *)(a2 + 8);
    int v26 = *(_DWORD *)(v25 + 20);
    *(_OWORD *)&buf.__r_.__value_.__l.__data_ = *(_OWORD *)(v25 + 4);
    LODWORD(buf.__r_.__value_.__r.__words[2]) = v26;
    sub_100634334((__n128 *)v64, (__n128 *)&buf);
    if (!sub_1001BEC7C((unsigned __int8 *)&v62, v64))
    {
      int v27 = (os_log_s *)qword_1008F75B0;
      if (os_log_type_enabled((os_log_t)qword_1008F75B0, OS_LOG_TYPE_ERROR))
      {
        sub_100531170((void *)*v21, &buf);
        int v29 = (char)buf.__r_.__value_.__s.__size_;
        std::string::size_type v30 = buf.__r_.__value_.__r.__words[0];
        sub_100531170((void *)a2, &v62);
        p_std::string buf = &buf;
        if (v29 < 0) {
          p_std::string buf = (std::string *)v30;
        }
        if ((v62.__r_.__value_.__s.__size_ & 0x80u) == 0) {
          int v32 = &v62;
        }
        else {
          int v32 = (std::string *)v62.__r_.__value_.__r.__words[0];
        }
        *(_DWORD *)__int128 v64 = 136446466;
        __int128 v65 = p_buf;
        __int16 v66 = 2082;
        int v67 = v32;
        _os_log_error_impl( (void *)&_mh_execute_header,  v27,  OS_LOG_TYPE_ERROR,  "Replacing cached descriptor %{public}s with descriptor of different type %{public}s",  v64,  0x16u);
      }
    }

    sub_100282FC4(*v19, *v21);
    int v28 = (uint64_t *)(*(uint64_t (**)(uint64_t))(*(void *)a2 + 16LL))(a2);
    sub_1003826DC(*v19, (uint64_t)v28);
    LOWORD(v62.__r_.__value_.__l.__data_) = **(_WORD **)(a2 + 8);
    buf.__r_.__value_.__r.__words[0] = (std::string::size_type)&v62;
    char v23 = 0;
    sub_1002550B8(v6, (unsigned __int16 *)&v62, (uint64_t)&unk_1006C2518, &buf)[5] = v28;
    int v20 = (void *)v68.__r_.__value_.__r.__words[0];
    if (!v68.__r_.__value_.__r.__words[0]) {
      goto LABEL_36;
    }
LABEL_35:
    v68.__r_.__value_.__l.__size_ = (std::string::size_type)v20;
    operator delete(v20);
    goto LABEL_36;
  }

void sub_1004437F0( _Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, void *__p, uint64_t a13, int a14, __int16 a15, char a16, char a17, char a18, uint64_t a19, uint64_t a20, uint64_t a21, uint64_t a22, uint64_t a23, uint64_t a24, uint64_t a25, uint64_t a26, uint64_t a27, void *a28, uint64_t a29, int a30, __int16 a31, char a32, char a33)
{
  if (__p) {
    operator delete(__p);
  }
  sub_100242FAC((uint64_t)&a18);
  _Unwind_Resume(a1);
}

uint64_t sub_10044389C(void *a1, uint64_t a2)
{
  v5[0] = 0LL;
  v5[1] = 0LL;
  sub_100242F28((uint64_t)v5, (uint64_t)(a1 + 1));
  sub_100443100(a1, a2);
  return sub_100242FAC((uint64_t)v5);
}

void sub_1004438E8( _Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9)
{
}

uint64_t *sub_1004438FC(uint64_t a1, unsigned int a2)
{
  unsigned __int16 v14 = a2;
  v13[0] = 0LL;
  v13[1] = 0LL;
  sub_100242F28((uint64_t)v13, a1 + 8);
  uint64_t v6 = *(void *)(a1 + 104);
  uint64_t v5 = a1 + 104;
  uint64_t v4 = v6;
  if (!v6) {
    goto LABEL_12;
  }
  uint64_t v7 = v5;
  do
  {
    unsigned int v8 = *(unsigned __int16 *)(v4 + 32);
    BOOL v9 = v8 >= a2;
    if (v8 >= a2) {
      BOOL v10 = (uint64_t *)v4;
    }
    else {
      BOOL v10 = (uint64_t *)(v4 + 8);
    }
    if (v9) {
      uint64_t v7 = v4;
    }
    uint64_t v4 = *v10;
  }

  while (*v10);
  if (v7 != v5 && *(unsigned __int16 *)(v7 + 32) <= a2)
  {
    uint64_t v15 = &v14;
    std::string::size_type v11 = sub_1002550B8((uint64_t **)(v5 - 8), &v14, (uint64_t)&unk_1006C2518, &v15)[5];
  }

  else
  {
LABEL_12:
    std::string::size_type v11 = 0LL;
  }

  sub_100242FAC((uint64_t)v13);
  return v11;
}

void sub_1004439B0( _Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9)
{
}

uint64_t sub_1004439C4(uint64_t a1, unsigned __int8 *a2, unsigned __int8 *a3)
{
  v14[0] = 0LL;
  v14[1] = 0LL;
  sub_100242F28((uint64_t)v14, a1 + 8);
  uint64_t v7 = *(uint64_t **)(a1 + 72);
  if (v7 != *(uint64_t **)(a1 + 80))
  {
    while (1)
    {
      uint64_t v8 = *v7;
      __n128 v16 = *(__n128 *)(*v7 + 72);
      LODWORD(v17) = *(_DWORD *)(v8 + 88);
      sub_100634334(&v18, &v16);
LABEL_14:
    }

    if (!*a3)
    {
      uint64_t v3 = *v7;
      goto LABEL_16;
    }

    __n128 v16 = 0uLL;
    uint64_t v17 = 0LL;
    sub_100240540(&v16, *v7 + 136);
    BOOL v9 = (char *)v16.n128_u64[0];
    if (v16.n128_u64[0] == v16.n128_u64[1])
    {
      char v12 = 1;
      if (v16.n128_u64[0])
      {
LABEL_12:
        v16.n128_u64[1] = (unint64_t)v9;
        operator delete(v9);
      }
    }

    else
    {
      while (1)
      {
        uint64_t v10 = *(void *)v9;
        __n128 v18 = *(__n128 *)(*(void *)v9 + 76LL);
        int v19 = *(_DWORD *)(v10 + 92);
        sub_100634334(&v15, &v18);
        BOOL v11 = sub_1001BEC7C((unsigned __int8 *)&v15, a3);
        if (v11) {
          break;
        }
        v9 += 8;
      }

      uint64_t v3 = *(void *)v9;
LABEL_11:
      char v12 = !v11;
      BOOL v9 = (char *)v16.n128_u64[0];
      if (v16.n128_u64[0]) {
        goto LABEL_12;
      }
    }

    if ((v12 & 1) == 0) {
      goto LABEL_16;
    }
    goto LABEL_14;
  }

void sub_100443B44( _Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, char a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, void *__p, uint64_t a16)
{
}

uint64_t sub_100443B7C(uint64_t a1, unsigned int a2)
{
  v10[0] = 0LL;
  v10[1] = 0LL;
  sub_100242F28((uint64_t)v10, a1 + 8);
  uint64_t v4 = sub_1004438FC(a1, a2);
  uint64_t v5 = (uint64_t)v4;
  if (v4)
  {
    __n128 v19 = 0uLL;
    int v20 = 0;
    uint64_t v6 = v4[1];
    int v7 = *(_DWORD *)(v6 + 20);
    __n128 v21 = *(__n128 *)(v6 + 4);
    int v22 = v7;
    sub_100634334(&v19, &v21);
    int v18 = 0;
    __int128 v17 = xmmword_1006C3070;
    if (sub_1001BEC7C(v8, (unsigned __int8 *)&v17)
      || (v16 = 0, __int128 v15 = xmmword_1006C3098, sub_1001BEC7C((unsigned __int8 *)&v19, (unsigned __int8 *)&v15))
      || (v14 = 0, __int128 v13 = xmmword_1006C3084, sub_1001BEC7C((unsigned __int8 *)&v19, (unsigned __int8 *)&v13))
      || (v12 = 0, __int128 v11 = xmmword_1006C305C, sub_1001BEC7C((unsigned __int8 *)&v19, (unsigned __int8 *)&v11)))
    {
      uint64_t v5 = 0LL;
    }

    else
    {
      uint64_t v5 = (*(uint64_t (**)(uint64_t))(*(void *)v5 + 16LL))(v5);
    }
  }

  sub_100242FAC((uint64_t)v10);
  return v5;
}

void sub_100443CD0( _Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9)
{
}

uint64_t sub_100443CF0(uint64_t a1, unsigned int a2)
{
  v16[0] = 0LL;
  v16[1] = 0LL;
  sub_100242F28((uint64_t)v16, a1 + 8);
  uint64_t v4 = *(void *)(a1 + 72);
  uint64_t v5 = *(void *)(a1 + 80);
  if (v4 != v5)
  {
    while (**(unsigned __int16 **)(*(void *)v4 + 8LL) >= a2 || *(unsigned __int16 *)(*(void *)v4 + 48LL) < a2)
    {
      v4 += 8LL;
      if (v4 == v5) {
        goto LABEL_18;
      }
    }
  }

  if (v4 == v5)
  {
LABEL_18:
    __int128 v11 = (os_log_s *)qword_1008F75B0;
    if (os_log_type_enabled((os_log_t)qword_1008F75B0, OS_LOG_TYPE_ERROR)) {
      sub_10067FFE0(a2, v11);
    }
    unsigned __int16 v6 = 0;
  }

  else
  {
    unsigned __int16 v6 = *(_WORD *)(*(void *)v4 + 48LL);
    __int128 v13 = 0LL;
    int v14 = 0LL;
    uint64_t v15 = 0LL;
    sub_100240540(&v13, *(void *)v4 + 136LL);
    if (v13 != v14)
    {
      int v7 = v13;
      do
      {
        uint64_t v8 = *v7++;
        unsigned int v9 = **(unsigned __int16 **)(v8 + 8);
        if (v9 <= v6 && v9 > a2) {
          unsigned __int16 v6 = v9 - 1;
        }
      }

      while (v7 != v14);
    }

    if (v13)
    {
      int v14 = v13;
      operator delete(v13);
    }
  }

  sub_100242FAC((uint64_t)v16);
  return v6;
}

void sub_100443E0C(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, ...)
{
}

uint64_t sub_100443E20@<X0>(uint64_t a1@<X0>, unsigned int a2@<W1>, __n128 *a3@<X8>)
{
  v9[0] = 0LL;
  v9[1] = 0LL;
  sub_100242F28((uint64_t)v9, a1 + 8);
  for (uint64_t i = *(uint64_t **)(a1 + 72); ; ++i)
  {
    if (i == *(uint64_t **)(a1 + 80))
    {
      sub_10063432C(a3);
      return sub_100242FAC((uint64_t)v9);
    }

    uint64_t v7 = *i;
  }

  __n128 v10 = *(__n128 *)(v7 + 72);
  int v11 = *(_DWORD *)(v7 + 88);
  sub_100634334(a3, &v10);
  return sub_100242FAC((uint64_t)v9);
}

void sub_100443EF4( _Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9)
{
}

uint64_t sub_100443F14(uint64_t a1, unsigned int a2, unsigned int a3)
{
  v13[0] = 0LL;
  v13[1] = 0LL;
  sub_100242F28((uint64_t)v13, a1 + 8);
  uint64_t v7 = *(char **)(a1 + 72);
  unsigned __int16 v6 = *(char **)(a1 + 80);
  while (v7 != v6)
  {
    uint64_t v8 = *(void *)v7;
    if (*(unsigned __int16 *)(*(void *)v7 + 48LL) >= a2 && **(unsigned __int16 **)(v8 + 8) <= a3)
    {
      unsigned int v9 = (os_log_s *)qword_1008F75B0;
      if (os_log_type_enabled((os_log_t)qword_1008F75B0, OS_LOG_TYPE_INFO))
      {
        sub_100531170((void *)v8, &__p);
        if ((__p.__r_.__value_.__s.__size_ & 0x80u) == 0) {
          p_p = &__p;
        }
        else {
          p_p = (std::string *)__p.__r_.__value_.__r.__words[0];
        }
        *(_DWORD *)std::string buf = 136446210;
        uint64_t v15 = p_p;
        _os_log_impl((void *)&_mh_execute_header, v9, OS_LOG_TYPE_INFO, "Invalidating service %{public}s", buf, 0xCu);
      }

      sub_1004440AC(a1, v7);
      uint64_t v7 = *(char **)(a1 + 72);
      unsigned __int16 v6 = *(char **)(a1 + 80);
    }

    else
    {
      v7 += 8;
    }
  }

  *(void *)(a1 + 12_Block_object_dispose((const void *)(v2 - 88), 8) = *(void *)(a1 + 120);
  *(_BYTE *)(a1 + 144) = 0;
  return sub_100242FAC((uint64_t)v13);
}

void sub_10044408C( _Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, char a15)
{
}

uint64_t sub_1004440AC(uint64_t a1, char *a2)
{
  v16[0] = 0LL;
  v16[1] = 0LL;
  sub_100242F28((uint64_t)v16, a1 + 8);
  uint64_t v4 = *(void *)a2;
  uint64_t v5 = *(void *)a2 + 104LL;
  while (1)
  {
    sub_100240540(&__p, v5);
    unsigned __int16 v6 = __p;
    uint64_t v7 = v15;
    if (__p)
    {
      uint64_t v15 = __p;
      operator delete(__p);
    }

    if (v7 == v6) {
      break;
    }
    sub_100240540(&__p, v5);
    uint64_t v8 = *(void *)__p;
    uint64_t v15 = __p;
    operator delete(__p);
    LOWORD(__p) = **(_WORD **)(v8 + 8);
    sub_100329E44(a1 + 96, (unsigned __int16 *)&__p);
    sub_100282FC4((void *)v4, v8);
  }

  while (1)
  {
    sub_100240540(&__p, v4 + 136);
    unsigned int v9 = __p;
    __n128 v10 = v15;
    if (__p)
    {
      uint64_t v15 = __p;
      operator delete(__p);
    }

    if (v10 == v9) {
      break;
    }
    sub_100240540(&__p, v4 + 136);
    sub_10044426C(a1, (void *)v4, *(void *)__p);
    if (__p)
    {
      uint64_t v15 = __p;
      operator delete(__p);
    }
  }

  LOWORD(__p) = **(_WORD **)(v4 + 8);
  sub_100329E44(a1 + 96, (unsigned __int16 *)&__p);
  (*(void (**)(uint64_t))(*(void *)v4 + 8LL))(v4);
  int v11 = *(char **)(a1 + 80);
  int64_t v12 = v11 - (a2 + 8);
  if (v11 != a2 + 8) {
    memmove(a2, a2 + 8, v11 - (a2 + 8));
  }
  *(void *)(a1 + 8sub_100414D2C(qword_1008F72C0, 0) = &a2[v12];
  return sub_100242FAC((uint64_t)v16);
}

void sub_100444228( _Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void *__p, uint64_t a11, uint64_t a12, char a13)
{
}

uint64_t sub_10044426C(uint64_t a1, void *a2, uint64_t a3)
{
  v12[0] = 0LL;
  v12[1] = 0LL;
  sub_100242F28((uint64_t)v12, a1 + 8);
  if (*(void *)(a3 + 96))
  {
    LOWORD(__p) = *(_WORD *)(a3 + 74);
    sub_100329E44(a1 + 96, (unsigned __int16 *)&__p);
  }

  std::string __p = 0LL;
  __n128 v10 = 0LL;
  uint64_t v11 = 0LL;
  sub_100240540(&__p, a3 + 104);
  unsigned __int16 v6 = (char *)__p;
  if (__p != v10)
  {
    do
    {
      unsigned __int16 v8 = **(_WORD **)(*(void *)v6 + 8LL);
      sub_100329E44(a1 + 96, &v8);
      v6 += 8;
    }

    while (v6 != v10);
  }

  unsigned __int16 v8 = **(_WORD **)(a3 + 8);
  sub_100329E44(a1 + 96, &v8);
  sub_100444398(a2, a3);
  if (__p)
  {
    __n128 v10 = (char *)__p;
    operator delete(__p);
  }

  return sub_100242FAC((uint64_t)v12);
}

void sub_100444360( _Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void *__p, uint64_t a11, uint64_t a12, char a13)
{
}

void *sub_100444398(void *result, uint64_t a2)
{
  uint64_t v3 = result;
  uint64_t v5 = (char *)result[17];
  uint64_t v4 = (char *)result[18];
  if (v5 != v4)
  {
    while (*(void *)v5 != a2)
    {
      v5 += 8;
      if (v5 == v4)
      {
        uint64_t v5 = (char *)result[18];
        break;
      }
    }
  }

  if (v5 != v4)
  {
    int64_t v6 = v4 - (v5 + 8);
    if (v4 != v5 + 8) {
      BOOL result = memmove(v5, v5 + 8, v4 - (v5 + 8));
    }
    v3[18] = &v5[v6];
    if (a2) {
      return (void *)(*(uint64_t (**)(uint64_t))(*(void *)a2 + 8LL))(a2);
    }
  }

  return result;
}

uint64_t sub_100444430(uint64_t a1, uint64_t a2)
{
  v12[0] = 0LL;
  v12[1] = 0LL;
  sub_100242F28((uint64_t)v12, a1 + 8);
  if (os_log_type_enabled((os_log_t)qword_1008F75B0, OS_LOG_TYPE_INFO))
  {
    uint64_t v4 = *(void **)(a1 + 96);
    if (v4 != (void *)(a1 + 104))
    {
      do
      {
        uint64_t v5 = (os_log_s *)qword_1008F75B0;
        if (os_log_type_enabled((os_log_t)qword_1008F75B0, OS_LOG_TYPE_DEFAULT))
        {
          sub_100531170((void *)v4[5], &__p);
          int64_t v6 = (__p.__r_.__value_.__s.__size_ & 0x80u) == 0 ? &__p : (std::string *)__p.__r_.__value_.__r.__words[0];
          *(_DWORD *)std::string buf = 136446466;
          uint64_t v14 = a2;
          __int16 v15 = 2082;
          int v16 = v6;
          _os_log_impl( (void *)&_mh_execute_header,  v5,  OS_LOG_TYPE_DEFAULT,  "statedump: %{public}s%{public}s",  buf,  0x16u);
        }

        uint64_t v7 = (void *)v4[1];
        if (v7)
        {
          do
          {
            unsigned __int16 v8 = v7;
            uint64_t v7 = (void *)*v7;
          }

          while (v7);
        }

        else
        {
          do
          {
            unsigned __int16 v8 = (void *)v4[2];
            BOOL v9 = *v8 == (void)v4;
            uint64_t v4 = v8;
          }

          while (!v9);
        }

        uint64_t v4 = v8;
      }

      while (v8 != (void *)(a1 + 104));
    }
  }

  return sub_100242FAC((uint64_t)v12);
}

void sub_1004445B0( _Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, char a15)
{
}

void sub_1004445CC(void *a1, int a2, os_log_t log, const char *a4, uint8_t *a5)
{
}

void sub_100444790(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_10044492C( _Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, id location, char a17, uint64_t a18, uint64_t a19, uint64_t a20, uint64_t a21, void *a22)
{
  objc_destroyWeak(&location);
  _Unwind_Resume(a1);
}

uint64_t sub_100444968(uint64_t result, uint64_t a2)
{
  *(void *)(result + 4sub_100414D2C(qword_1008F72C0, 0) = *(void *)(a2 + 40);
  *(void *)(a2 + 4sub_100414D2C(qword_1008F72C0, 0) = 0LL;
  return result;
}

void sub_100444978(uint64_t a1)
{
}

void sub_100444980(uint64_t a1, int a2, void *a3)
{
  int64_t v6 = a3;
  id WeakRetained = objc_loadWeakRetained((id *)(a1 + 48));
  id v8 = WeakRetained;
  if (WeakRetained)
  {
    BOOL v9 = (nw_connection *)objc_claimAutoreleasedReturnValue([WeakRetained connection]);
    __n128 v10 = nw_connection_copy_endpoint(v9);

    if (v6) {
      int error_code = nw_error_get_error_code(v6);
    }
    else {
      int error_code = 0;
    }
    *__error() = error_code;
    int64_t v12 = (os_log_s *)(id)qword_1008F7710;
    if (os_log_type_enabled(v12, OS_LOG_TYPE_DEFAULT))
    {
      hostname = nw_endpoint_get_hostname(v10);
      int port = nw_endpoint_get_port(v10);
      int v15 = *__error();
      int v39 = 67109890;
      *(_DWORD *)uint64_t v40 = a2;
      *(_WORD *)&v40[4] = 2080;
      *(void *)&v40[6] = hostname;
      *(_WORD *)&v40[14] = 1024;
      *(_DWORD *)&v40[16] = port;
      LOWORD(v41[0]) = 1024;
      *(_DWORD *)((char *)v41 + 2) = v15;
      _os_log_impl( (void *)&_mh_execute_header,  v12,  OS_LOG_TYPE_DEFAULT,  "[BTVCBonjourEndpoint] Connection state changed to %d (host %s port %u error %d)",  (uint8_t *)&v39,  0x1Eu);
    }

    if (a2 == 5)
    {
      int v26 = (os_log_s *)(id)qword_1008F7710;
      if (os_log_type_enabled(v26, OS_LOG_TYPE_DEFAULT))
      {
        uint64_t v27 = *((void *)v8 + 6);
        int v28 = nw_endpoint_get_hostname(v10);
        int v29 = nw_endpoint_get_port(v10);
        int v39 = 138412802;
        *(void *)uint64_t v40 = v27;
        *(_WORD *)&v40[8] = 2080;
        *(void *)&v40[10] = v28;
        *(_WORD *)&v40[18] = 1024;
        v41[0] = v29;
        _os_log_impl( (void *)&_mh_execute_header,  v26,  OS_LOG_TYPE_DEFAULT,  "[BTVCBonjourEndpoint] Connection (%@) to %s port %u cancelled",  (uint8_t *)&v39,  0x1Cu);
      }

      std::string::size_type v30 = (void *)objc_claimAutoreleasedReturnValue([v8 didDisconnectHandler]);
      BOOL v31 = v30 == 0LL;

      if (!v31)
      {
        int v32 = *(nw_error **)(*(void *)(*(void *)(a1 + 40) + 8LL) + 40LL);
        if (v32) {
          CFErrorRef v33 = nw_error_copy_cf_error(v32);
        }
        else {
          CFErrorRef v33 = 0LL;
        }
        int v35 = (void (**)(void, void))objc_claimAutoreleasedReturnValue([v8 didDisconnectHandler]);
        ((void (**)(void, CFErrorRef))v35)[2](v35, v33);
      }

      unsigned int v36 = (void *)*((void *)v8 + 6);
      *((void *)v8 + 6) = 0LL;

      __int16 v37 = (void *)*((void *)v8 + 5);
      *((void *)v8 + 5) = 0LL;

      uint64_t v38 = *(void *)(*(void *)(a1 + 40) + 8LL);
      int v34 = *(nw_connection **)(v38 + 40);
      *(void *)(v38 + 4sub_100414D2C(qword_1008F72C0, 0) = 0LL;
    }

    else
    {
      if (a2 != 4)
      {
        if (a2 == 3)
        {
          int v16 = (os_log_s *)(id)qword_1008F7710;
          if (os_log_type_enabled(v16, OS_LOG_TYPE_DEFAULT))
          {
            uint64_t v17 = *((void *)v8 + 6);
            int v18 = nw_endpoint_get_hostname(v10);
            int v19 = nw_endpoint_get_port(v10);
            int v39 = 138412802;
            *(void *)uint64_t v40 = v17;
            *(_WORD *)&v40[8] = 2080;
            *(void *)&v40[10] = v18;
            *(_WORD *)&v40[18] = 1024;
            v41[0] = v19;
            _os_log_impl( (void *)&_mh_execute_header,  v16,  OS_LOG_TYPE_DEFAULT,  "[BTVCBonjourEndpoint] Connection (%@) to %s port %u succeeded! begin receiving messages",  (uint8_t *)&v39,  0x1Cu);
          }

          if (([v8 isAdvToBrowserConnection] & 1) == 0)
          {
            int v20 = (void *)objc_claimAutoreleasedReturnValue( objc_msgSend( v8,  "_getServerRemoteUUIDFromConnectionMetadata:isAdvToBrowserConnection:",  *(void *)(*(void *)(a1 + 32) + 48),  objc_msgSend(*(id *)(a1 + 32), "isAdvToBrowserConnection")));
            [v8 setRemoteUniqueIDString:v20];
          }

          __n128 v21 = (void *)objc_claimAutoreleasedReturnValue([v8 remoteUniqueIDString]);
          BOOL v22 = v21 == 0LL;

          if (v22)
          {
            if (os_log_type_enabled((os_log_t)qword_1008F7710, OS_LOG_TYPE_ERROR)) {
              sub_100680058();
            }
            nw_connection_cancel(*((nw_connection_t *)v8 + 6));
          }

          else
          {
            char v23 = (void *)objc_claimAutoreleasedReturnValue([v8 didConnectHandler]);
            BOOL v24 = v23 == 0LL;

            if (!v24)
            {
              uint64_t v25 = (void (**)(void))objc_claimAutoreleasedReturnValue([v8 didConnectHandler]);
              v25[2]();
            }

            [v8 receiveNextMessage];
          }
        }

        goto LABEL_31;
      }

      objc_storeStrong((id *)(*(void *)(*(void *)(a1 + 40) + 8LL) + 40LL), a3);
      int v34 = (nw_connection *)objc_claimAutoreleasedReturnValue([v8 connection]);
      nw_connection_cancel(v34);
    }

LABEL_31:
  }
}

void sub_100444D8C(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_100444F6C( _Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, char a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, id a20)
{
  _Block_object_dispose(&a15, 8);
  _Unwind_Resume(a1);
}

uint64_t sub_100444FBC(uint64_t a1, char *__s1, uint64_t a3)
{
  if (!strcmp(__s1, "BTVCBonjourEndpointServerUUIDHeader"))
  {
    uint64_t v5 = objc_claimAutoreleasedReturnValue(+[NSString stringWithUTF8String:](&OBJC_CLASS___NSString, "stringWithUTF8String:", a3));
    uint64_t v6 = *(void *)(*(void *)(a1 + 32) + 8LL);
    uint64_t v7 = *(void **)(v6 + 40);
    *(void *)(v6 + 4sub_100414D2C(qword_1008F72C0, 0) = v5;
  }

  return 1LL;
}

void sub_1004451B8( _Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, id location, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20, char a21, uint64_t a22, uint64_t a23, uint64_t a24, uint64_t a25, void *a26)
{
  int v29 = v28;
  objc_destroyWeak(v29);
  objc_destroyWeak(&location);
  _Block_object_dispose(&a21, 8);

  _Unwind_Resume(a1);
}

void sub_100445204(uint64_t a1, void *a2)
{
  options = a2;
  uint64_t v4 = nw_protocol_copy_ws_definition();
  uint64_t v5 = nw_protocol_options_copy_definition(options);
  BOOL is_equal = nw_protocol_definition_is_equal(v4, v5);

  if (is_equal) {
    objc_storeStrong((id *)(*(void *)(*(void *)(a1 + 32) + 8LL) + 40LL), a2);
  }
}

void sub_10044528C( _Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, id a10)
{
  _Unwind_Resume(a1);
}

nw_ws_response *sub_1004452B8(uint64_t a1, void *a2)
{
  uint64_t v3 = a2;
  id WeakRetained = (id *)objc_loadWeakRetained((id *)(a1 + 32));
  uint64_t v5 = WeakRetained;
  if (WeakRetained)
  {
    enumerator[0] = _NSConcreteStackBlock;
    enumerator[1] = 3221225472LL;
    enumerator[2] = sub_1004453AC;
    enumerator[3] = &unk_100898B50;
    enumerator[4] = WeakRetained;
    nw_ws_request_enumerate_additional_headers(v3, enumerator);
    uint64_t v6 = nw_ws_response_create(nw_ws_response_status_accept, 0LL);
    nw_ws_response_add_additional_header( v6,  "BTVCBonjourEndpointServerUUIDHeader",  (const char *)[v5[7] UTF8String]);
  }

  else
  {
    uint64_t v6 = nw_ws_response_create(nw_ws_response_status_reject, 0LL);
  }

  return v6;
}

void sub_100445384(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

uint64_t sub_1004453AC(uint64_t a1, char *__s1, uint64_t a3)
{
  if (!strcmp(__s1, "BTVCBonjourEndpointClientUUIDHeader"))
  {
    uint64_t v5 = objc_claimAutoreleasedReturnValue(+[NSString stringWithUTF8String:](&OBJC_CLASS___NSString, "stringWithUTF8String:", a3));
    uint64_t v6 = *(void *)(a1 + 32);
    uint64_t v7 = *(void **)(v6 + 64);
    *(void *)(v6 + sub_100242FAC(v30 - 64) = v5;
  }

  return 1LL;
}

void sub_10044553C(_Unwind_Exception *a1)
{
}

void sub_100445558(uint64_t a1, void *a2, void *a3, uint64_t a4, void *a5)
{
  id v8 = a2;
  BOOL v9 = a3;
  id v10 = a5;
  id WeakRetained = (nw_connection_t *)objc_loadWeakRetained((id *)(a1 + 32));
  if (WeakRetained)
  {
    int64_t v12 = (os_log_s *)qword_1008F7710;
    if (os_log_type_enabled((os_log_t)qword_1008F7710, OS_LOG_TYPE_DEFAULT))
    {
      int v20 = 138412546;
      nw_connection_t v21 = v8;
      __int16 v22 = 2112;
      id v23 = v10;
      _os_log_impl( (void *)&_mh_execute_header,  v12,  OS_LOG_TYPE_DEFAULT,  "[BTVCBonjourEndpoint] receiveNextMessage data %@ error:%@",  (uint8_t *)&v20,  0x16u);
    }

    __int128 v13 = v8;
    if (v9 && nw_content_context_get_is_final(v9))
    {
      uint64_t v14 = (os_log_s *)qword_1008F7710;
      if (os_log_type_enabled((os_log_t)qword_1008F7710, OS_LOG_TYPE_DEFAULT))
      {
        nw_connection_t v15 = WeakRetained[6];
        int v20 = 138412290;
        nw_connection_t v21 = v15;
        _os_log_impl( (void *)&_mh_execute_header,  v14,  OS_LOG_TYPE_DEFAULT,  "[BTVCBonjourEndpoint] receiveNextMessage got connection closed %@",  (uint8_t *)&v20,  0xCu);
      }

      nw_connection_cancel(WeakRetained[6]);
    }

    else if (!v10)
    {
      int v16 = (void *)objc_claimAutoreleasedReturnValue(-[nw_connection_t didReceiveDataHandler](WeakRetained, "didReceiveDataHandler"));
      if (v13) {
        BOOL v17 = v16 == 0LL;
      }
      else {
        BOOL v17 = 1;
      }
      int v18 = !v17;

      if (v18)
      {
        int v19 = (void (**)(void, void))objc_claimAutoreleasedReturnValue( -[nw_connection_t didReceiveDataHandler]( WeakRetained,  "didReceiveDataHandler"));
        ((void (**)(void, nw_connection *))v19)[2](v19, v13);
      }

      -[nw_connection_t receiveNextMessage](WeakRetained, "receiveNextMessage");
    }
  }
}

void sub_100445714(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_100445928(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_1004459A0(uint64_t a1, void *a2)
{
  uint64_t v3 = a2;
  uint64_t v4 = (os_log_s *)(id)qword_1008F7710;
  if (os_log_type_enabled(v4, OS_LOG_TYPE_DEFAULT))
  {
    id v5 = [*(id *)(a1 + 32) length];
    int v9 = 138412546;
    id v10 = v3;
    __int16 v11 = 2048;
    id v12 = v5;
    _os_log_impl( (void *)&_mh_execute_header,  v4,  OS_LOG_TYPE_DEFAULT,  "[BTVCBonjourEndpoint] nw_connection_send completed with error: %@, bytes :%lu",  (uint8_t *)&v9,  0x16u);
  }

  uint64_t v6 = *(void *)(a1 + 40);
  if (v6)
  {
    if (v3)
    {
      CFErrorRef v7 = nw_error_copy_cf_error(v3);
      uint64_t v6 = *(void *)(a1 + 40);
      CFErrorRef v8 = v7;
    }

    else
    {
      CFErrorRef v8 = 0LL;
    }

    (*(void (**)(uint64_t, CFErrorRef))(v6 + 16))(v6, v8);
  }
}

void sub_100445AAC(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_100445B84(_Unwind_Exception *a1)
{
  id v5 = v4;

  _Unwind_Resume(a1);
}

void sub_100445BC0(id a1, OS_nw_protocol_options *a2)
{
  options = a2;
  nw_tcp_options_set_enable_keepalive(options, 1);
  nw_tcp_options_set_keepalive_idle_time(options, 2u);
  nw_tcp_options_set_no_delay(options, 1);
  nw_tcp_options_set_enable_fast_open(options, 1);
}

void sub_100445C18( _Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, id a10)
{
}

uint64_t sub_100445D7C(uint64_t a1, uint64_t a2, char a3, int a4)
{
  *(void *)a1 = off_100898730;
  sub_100242DC4(a1 + 8);
  *(_BYTE *)(a1 + 72) = 0;
  *(_DWORD *)(a1 + sub_10023DF50(v3 + 76) = a4;
  *(void *)a1 = off_100898C38;
  *(void *)(a1 + 8sub_100414D2C(qword_1008F72C0, 0) = a2;
  *(void *)(a1 + 8_Block_object_dispose((const void *)(v2 - 88), 8) = off_100898C78;
  *(_BYTE *)(a1 + 96) = a3;
  *(_BYTE *)(a1 + 97) = 0;
  *(_OWORD *)(a1 + 10sub_100414D2C(qword_1008F72C0, 0) = xmmword_1006C30B0;
  *(_DWORD *)(a1 + 116) = 1000;
  *(void *)(a1 + 12sub_100414D2C(qword_1008F72C0, 0) = 0LL;
  sub_100242DC4(a1 + 128);
  *(_OWORD *)(a1 + 20sub_100414D2C(qword_1008F72C0, 0) = 0u;
  *(_DWORD *)(a1 + 192) = 0;
  *(_OWORD *)(a1 + 216) = 0u;
  *(void *)(a1 + 12sub_100414D2C(qword_1008F72C0, 0) = sub_100405288();
  return a1;
}

void sub_100445E34(_Unwind_Exception *a1)
{
  CFErrorRef v7 = *v4;
  if (*v4)
  {
    v1[26] = v7;
    operator delete(v7);
  }

  sub_100242E28(v3);
  *id v1 = v5;
  sub_100242E28(v2);
  _Unwind_Resume(a1);
}

uint64_t sub_100445E70(uint64_t a1, uint64_t a2)
{
  HIDWORD(v23.__r_.__value_.__r.__words[2]) = 0;
  WORD1(v23.__r_.__value_.__r.__words[2]) = 0;
  if (qword_1008D5F50 != -1) {
    dispatch_once(&qword_1008D5F50, &stru_100898DA8);
  }
  uint64_t v4 = off_1008D5F48;
  uint64_t v24 = 0LL;
  sub_1000B0400((uint64_t)&v24);
  v23.__r_.__value_.__r.__words[0] = (int)v24;
  v23.__r_.__value_.__l.__size_ = SWORD2(v24);
  uint64_t v5 = sub_100400268(v4, a2, &v23, (BOOL *)&v23.__r_.__value_.__s.__data_[19], &v23.__r_.__value_.__s.__data_[18]);
  if ((*(unsigned int (**)(void, std::string *, std::string::value_type *, void))(**(void **)(a1 + 80)
                                                                                                + 48LL))( *(void *)(a1 + 80),  v5,  &v23.__r_.__value_.__s.__data_[20],  v23.__r_.__value_.__s.__data_[19]))
  {
    (*(void (**)(void, std::string *))(**(void **)(a1 + 80) + 24LL))(*(void *)(a1 + 80), v5);
  }

  *(_OWORD *)&v23.__r_.__value_.__l.__data_ = 0uLL;
  sub_100242F28((uint64_t)&v23, a1 + 128);
  if (*(_DWORD *)(a1 + 192) != 128 && (v23.__r_.__value_.__s.__data_[20] & 0x10) != 0)
  {
    v5[32].__r_.__value_.__s.__data_[16] = 1;
    uint64_t v6 = (char **)(a1 + 200);
    if (!sub_1003FE254(a1 + 200, (uint64_t)v5))
    {
      unint64_t v7 = *(void *)(a1 + 216);
      CFErrorRef v8 = *(std::string ***)(a1 + 208);
      if ((unint64_t)v8 >= v7)
      {
        uint64_t v10 = ((char *)v8 - *v6) >> 3;
        uint64_t v11 = v7 - (void)*v6;
        uint64_t v12 = v11 >> 2;
        else {
          unint64_t v13 = v12;
        }
        if (v13) {
          uint64_t v14 = (char *)sub_100008BA0(a1 + 216, v13);
        }
        else {
          uint64_t v14 = 0LL;
        }
        nw_connection_t v15 = (std::string **)&v14[8 * v10];
        int v16 = &v14[8 * v13];
        *nw_connection_t v15 = v5;
        int v9 = v15 + 1;
        int v18 = *(char **)(a1 + 200);
        BOOL v17 = *(char **)(a1 + 208);
        if (v17 != v18)
        {
          do
          {
            int v19 = (std::string *)*((void *)v17 - 1);
            v17 -= 8;
            *--nw_connection_t v15 = v19;
          }

          while (v17 != v18);
          BOOL v17 = *v6;
        }

        *(void *)(a1 + 20sub_100414D2C(qword_1008F72C0, 0) = v15;
        *(void *)(a1 + 20_Block_object_dispose((const void *)(v2 - 88), 8) = v9;
        *(void *)(a1 + 216) = v16;
        if (v17) {
          operator delete(v17);
        }
      }

      else
      {
        *CFErrorRef v8 = v5;
        int v9 = v8 + 1;
      }

      *(void *)(a1 + 20_Block_object_dispose((const void *)(v2 - 88), 8) = v9;
    }

    uint64_t v20 = *(void *)(a1 + 224);
    if (v20)
    {
      *(void *)(v20 + 16) = 500LL;
    }

    else
    {
      nw_connection_t v21 = operator new(0x20uLL);
      uint8_t v21[4] = 0;
      *(void *)nw_connection_t v21 = &off_100898CD8;
      *(void *)(a1 + 224) = v21;
      *((void *)v21 + 2) = 500LL;
      *((void *)v21 + 3) = a1;
      (*(void (**)(uint64_t))(*(void *)a1 + 40LL))(a1);
    }
  }

  return sub_100242FAC((uint64_t)&v23);
}

void sub_100446084( _Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9)
{
}

uint64_t sub_100446098(uint64_t a1)
{
  v13[0] = 0LL;
  v13[1] = 0LL;
  sub_100242F28((uint64_t)v13, a1 + 128);
  uint64_t v2 = (os_log_s *)qword_1008F7590;
  if (os_log_type_enabled((os_log_t)qword_1008F7590, OS_LOG_TYPE_INFO))
  {
    int v3 = *(_DWORD *)(a1 + 192);
    *(_DWORD *)std::string buf = 67109120;
    int v15 = v3;
    _os_log_impl((void *)&_mh_execute_header, v2, OS_LOG_TYPE_INFO, "Stepping scan with mode %u", buf, 8u);
  }

  int v4 = *(_DWORD *)(a1 + 192);
  if (v4 == 16 || v4 == 1)
  {
    if (sub_100446450(a1)) {
      return sub_100242FAC((uint64_t)v13);
    }
  }

  else if (!v4)
  {
    sub_100242F54((uint64_t)v13);
    if (*(_BYTE *)(a1 + 96))
    {
      uint64_t v6 = (os_log_s *)qword_1008F7590;
      if (os_log_type_enabled((os_log_t)qword_1008F7590, OS_LOG_TYPE_DEFAULT))
      {
        int v7 = *(_DWORD *)(a1 + 100);
        *(_DWORD *)std::string buf = 67109120;
        int v15 = v7;
        _os_log_impl( (void *)&_mh_execute_header,  v6,  OS_LOG_TYPE_DEFAULT,  "Sleeping %u ms before starting first scan",  buf,  8u);
      }

      j__usleep(1000 * *(_DWORD *)(a1 + 100));
    }

    sub_100242ECC((uint64_t)v13);
    sub_1004468C4(a1);
    return sub_100242FAC((uint64_t)v13);
  }

  if (*(_BYTE *)(a1 + 97))
  {
    *(_BYTE *)(a1 + 97) = 0;
  }

  else
  {
    sub_100242F54((uint64_t)v13);
    CFErrorRef v8 = (os_log_s *)qword_1008F7590;
    if (os_log_type_enabled((os_log_t)qword_1008F7590, OS_LOG_TYPE_DEFAULT))
    {
      uint64_t v9 = 108LL;
      if (!*(_BYTE *)(a1 + 96)) {
        uint64_t v9 = 116LL;
      }
      int v10 = *(_DWORD *)(a1 + v9);
      *(_DWORD *)std::string buf = 67109120;
      int v15 = v10;
      _os_log_impl((void *)&_mh_execute_header, v8, OS_LOG_TYPE_DEFAULT, "Sleeping %u ms before ending scan", buf, 8u);
    }

    uint64_t v11 = 108LL;
    if (!*(_BYTE *)(a1 + 96)) {
      uint64_t v11 = 116LL;
    }
    j__usleep(1000 * *(_DWORD *)(a1 + v11));
    sub_10043B88C(a1, 0LL);
  }

  return sub_100242FAC((uint64_t)v13);
}

void sub_1004462A8(_Unwind_Exception *exception_object)
{
}

uint64_t sub_1004462C4(uint64_t a1)
{
  v10[0] = 0LL;
  v10[1] = 0LL;
  sub_100242F28((uint64_t)v10, a1 + 128);
  if (*(_DWORD *)(a1 + 192) == 1)
  {
    *(_BYTE *)(a1 + 97) = 1;
    char v9 = 0;
    sub_100242CA4(&v9);
    sub_100242CD0(&v9);
    sub_100242CD8(&v9);
  }

  return sub_100242FAC((uint64_t)v10);
}

void sub_100446344(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, ...)
{
}

uint64_t sub_100446368(int a1, uint64_t a2)
{
  uint64_t v4 = operator new(0x20uLL);
  v4[4] = 1;
  *(void *)uint64_t v4 = &off_100898D10;
  *((void *)v4 + 2) = a2;
  *((_DWORD *)v4 + 6) = a1;
  return (*(uint64_t (**)(uint64_t, _WORD *))(*(void *)a2 + 40LL))(a2, v4);
}

uint64_t sub_1004463BC(uint64_t a1)
{
  v4[0] = 0LL;
  v4[1] = 0LL;
  sub_100242F28((uint64_t)v4, a1 + 128);
  uint64_t v2 = *(void *)(a1 + 224);
  if (v2)
  {
    (*(void (**)(uint64_t))(*(void *)v2 + 8LL))(v2);
    *(void *)(a1 + 224) = 0LL;
  }

  if (*(_BYTE *)(a1 + 97))
  {
    *(_BYTE *)(a1 + 97) = 0;
    sub_100446450(a1);
  }

  else
  {
    sub_100242F54((uint64_t)v4);
    sub_10043B88C(a1, 0LL);
  }

  return sub_100242FAC((uint64_t)v4);
}

void sub_10044643C( _Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9)
{
}

BOOL sub_100446450(uint64_t a1)
{
  uint64_t v2 = *(uint64_t **)(a1 + 200);
  uint64_t v3 = *(uint64_t **)(a1 + 208);
  if (v2 == v3)
  {
    *(_DWORD *)(a1 + 192) = 128;
  }

  else
  {
    uint64_t v4 = *v2;
    *(_DWORD *)(a1 + 192) = 16;
    if (qword_1008D9600 != -1) {
      dispatch_once(&qword_1008D9600, &stru_100898DC8);
    }
    sub_10041AA14(qword_1008D95F8, v4, a1 + 88, 1, 2);
  }

  return v2 != v3;
}

uint64_t sub_1004464E4(uint64_t a1, uint64_t a2, int a3)
{
  uint64_t v6 = operator new(0x28uLL);
  v6[4] = 1;
  *(void *)uint64_t v6 = &off_100898D48;
  *((void *)v6 + 2) = a1;
  *((_DWORD *)v6 + 6) = a3;
  *((void *)v6 + 4) = a2;
  return (*(uint64_t (**)(uint64_t, _WORD *))(*(void *)a1 + 40LL))(a1, v6);
}

uint64_t sub_100446548(uint64_t a1, uint64_t a2, int a3)
{
  uint64_t v6 = operator new(0x28uLL);
  v6[4] = 1;
  *(void *)uint64_t v6 = &off_100898D48;
  uint64_t v7 = *(void *)(a1 - 88);
  a1 -= 88LL;
  *((void *)v6 + 2) = a1;
  *((_DWORD *)v6 + 6) = a3;
  *((void *)v6 + 4) = a2;
  return (*(uint64_t (**)(uint64_t, _WORD *))(v7 + 40))(a1, v6);
}

uint64_t sub_1004465AC(uint64_t a1, uint64_t a2)
{
  int v8 = 0;
  v7[0] = 0LL;
  v7[1] = 0LL;
  sub_100242F28((uint64_t)v7, a1 + 128);
  sub_1003FE288((char **)(a1 + 200), a2);
  sub_100242F54((uint64_t)v7);
  int v4 = (*(uint64_t (**)(void, uint64_t, int *, void))(**(void **)(a1 + 80) + 48LL))( *(void *)(a1 + 80),  a2,  &v8,  0LL);
  if (v8) {
    int v5 = 0;
  }
  else {
    int v5 = v4;
  }
  if (v5 == 1) {
    (*(void (**)(void, uint64_t))(**(void **)(a1 + 80) + 8LL))(*(void *)(a1 + 80), a2);
  }
  sub_100446098(a1);
  return sub_100242FAC((uint64_t)v7);
}

void sub_100446650(_Unwind_Exception *a1, uint64_t a2, ...)
{
}

void sub_100446664(uint64_t a1)
{
  v3[0] = 0LL;
  v3[1] = 0LL;
  sub_100242F28((uint64_t)v3, a1 + 8);
  int v2 = *(unsigned __int8 *)(a1 + 72);
  sub_100242FAC((uint64_t)v3);
  if (v2)
  {
    sub_1001EE2A0();
  }

  else
  {
    sub_10043B388(a1);
    sub_100446098(a1);
  }

uint64_t sub_1004466C0(uint64_t a1)
{
  v15[0] = 0LL;
  v15[1] = 0LL;
  sub_100242F28((uint64_t)v15, a1 + 128);
  int v2 = (os_log_s *)qword_1008F7590;
  if (os_log_type_enabled((os_log_t)qword_1008F7590, OS_LOG_TYPE_DEFAULT))
  {
    int v3 = *(_DWORD *)(a1 + 192);
    *(_DWORD *)std::string buf = 67109120;
    int v17 = v3;
    _os_log_impl((void *)&_mh_execute_header, v2, OS_LOG_TYPE_DEFAULT, "Stopping scan with mode %u", buf, 8u);
  }

  int v4 = *(uint64_t **)(a1 + 200);
  int v5 = *(uint64_t **)(a1 + 208);
  while (v4 != v5)
  {
    uint64_t v6 = *v4++;
    *(_BYTE *)(v6 + 784) = 0;
  }

  int v7 = *(_DWORD *)(a1 + 192);
  if (v7)
  {
    if (v7 == 1)
    {
      *(_DWORD *)(a1 + 192) = 128;
      sub_100242F54((uint64_t)v15);
      buf[0] = 0;
      sub_100242CA4(buf);
      sub_100113738((uint64_t (*)(void, void))sub_100446870, a1, v8, v9, v10, v11, v12, v13);
      sub_100242CD0(buf);
      sub_100242CD8(buf);
    }

    else if (v7 == 16)
    {
      *(_DWORD *)(a1 + 192) = 128;
      sub_100242F54((uint64_t)v15);
      if (qword_1008D9600 != -1) {
        dispatch_once(&qword_1008D9600, &stru_100898DC8);
      }
      sub_10041AB60(qword_1008D95F8, 1);
    }
  }

  else
  {
    *(_DWORD *)(a1 + 192) = 128;
  }

  return sub_100242FAC((uint64_t)v15);
}

void sub_100446840( _Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9)
{
}

uint64_t sub_100446870(int a1, uint64_t a2)
{
  int v4 = operator new(0x20uLL);
  v4[4] = 1;
  *(void *)int v4 = &off_100898D80;
  *((void *)v4 + 2) = a2;
  *((_DWORD *)v4 + 6) = a1;
  return (*(uint64_t (**)(uint64_t, _WORD *))(*(void *)a2 + 40LL))(a2, v4);
}

_BYTE *sub_1004468C4(uint64_t a1)
{
  int v2 = (os_log_s *)qword_1008F7590;
  if (os_log_type_enabled((os_log_t)qword_1008F7590, OS_LOG_TYPE_DEFAULT))
  {
    uint64_t v3 = 104LL;
    if (!*(_BYTE *)(a1 + 96)) {
      uint64_t v3 = 112LL;
    }
    int v4 = *(_DWORD *)(a1 + v3);
    v11[0] = 67109376;
    v11[1] = v4;
    __int16 v12 = 1024;
    int v13 = v4;
    _os_log_impl( (void *)&_mh_execute_header,  v2,  OS_LOG_TYPE_DEFAULT,  "Scanning for %u scan periods (%u x 1.28s)",  (uint8_t *)v11,  0xEu);
  }

  LOBYTE(v11[0]) = 0;
  sub_100242CA4(v11);
  uint64_t v7 = 104LL;
  if (!*(_BYTE *)(a1 + 96)) {
    uint64_t v7 = 112LL;
  }
  uint64_t v8 = sub_100113690(10390323LL, *(unsigned __int8 *)(a1 + v7), 64LL, sub_100446A44, sub_100446870, a1, v5, v6);
  sub_100242CD0(v11);
  if ((_DWORD)v8)
  {
    uint64_t v9 = (os_log_s *)qword_1008F7590;
    if (os_log_type_enabled((os_log_t)qword_1008F7590, OS_LOG_TYPE_ERROR)) {
      sub_100680134(v8, v9);
    }
    sub_10043B88C(a1, v8);
  }

  else
  {
    *(_DWORD *)(a1 + 192) = 1;
  }

  return sub_100242CD8(v11);
}

void sub_100446A28(_Unwind_Exception *exception_object)
{
}

uint64_t sub_100446A44(uint64_t result, uint64_t a2)
{
  if (result)
  {
    uint64_t v3 = result;
    int v4 = (char *)operator new(0x30uLL);
    *((_WORD *)v4 + 4) = 1;
    *(void *)int v4 = &off_100898CA0;
    *((void *)v4 + 2) = a2;
    *(_OWORD *)(v4 + 24) = *(_OWORD *)v3;
    uint64_t v5 = *(_OWORD **)(v3 + 16);
    *((void *)v4 + 5) = v5;
    if (v5)
    {
      uint64_t v6 = malloc(0xF0uLL);
      *((void *)v4 + 5) = v6;
      __int128 v7 = v5[6];
      __int128 v9 = v5[3];
      __int128 v8 = v5[4];
      void v6[5] = v5[5];
      v6[6] = v7;
      void v6[3] = v9;
      v6[4] = v8;
      __int128 v10 = v5[10];
      __int128 v12 = v5[7];
      __int128 v11 = v5[8];
      v6[9] = v5[9];
      v6[10] = v10;
      v6[7] = v12;
      v6[8] = v11;
      __int128 v13 = v5[14];
      __int128 v15 = v5[11];
      __int128 v14 = v5[12];
      v6[13] = v5[13];
      uint8_t v6[14] = v13;
      v6[11] = v15;
      v6[12] = v14;
      __int128 v17 = v5[1];
      __int128 v16 = v5[2];
      _OWORD *v6 = *v5;
      v6[1] = v17;
      void v6[2] = v16;
    }

    return (*(uint64_t (**)(uint64_t, char *))(*(void *)a2 + 40LL))(a2, v4);
  }

  return result;
}

void *sub_100446B08(void *a1)
{
  *a1 = &off_100898CA0;
  int v2 = (void *)a1[5];
  if (v2) {
    free(v2);
  }
  return a1;
}

void sub_100446B40(void *__p)
{
  void *__p = &off_100898CA0;
  int v2 = (void *)__p[5];
  if (v2) {
    free(v2);
  }
  operator delete(__p);
}

void *sub_100446B78(void *a1)
{
  *a1 = off_100898C38;
  a1[11] = off_100898C78;
  int v2 = (void *)a1[25];
  if (v2)
  {
    a1[26] = v2;
    operator delete(v2);
  }

  sub_100242E28(a1 + 16);
  *a1 = off_100898730;
  sub_100242E28(a1 + 1);
  return a1;
}

void sub_100446BD8(void *a1)
{
  *a1 = off_100898C38;
  a1[11] = off_100898C78;
  int v2 = (void *)a1[25];
  if (v2)
  {
    a1[26] = v2;
    operator delete(v2);
  }

  sub_100242E28(a1 + 16);
  *a1 = off_100898730;
  sub_100242E28(a1 + 1);
  operator delete(a1);
}

BOOL sub_100446C38(uint64_t a1, _BYTE *a2)
{
  return sub_100405744(*(void *)(a1 + 120), a2);
}

uint64_t sub_100446C40(void *a1)
{
  *(a1 - 11) = off_100898C38;
  *a1 = off_100898C78;
  int v2 = (void *)a1[14];
  if (v2)
  {
    a1[15] = v2;
    operator delete(v2);
  }

  sub_100242E28(a1 + 5);
  *(a1 - 11) = off_100898730;
  return sub_100242E28(a1 - 10);
}

void sub_100446C98(void *a1)
{
  *(a1 - 11) = off_100898C38;
  int v2 = a1 - 11;
  *a1 = off_100898C78;
  uint64_t v3 = (void *)a1[14];
  if (v3)
  {
    a1[15] = v3;
    operator delete(v3);
  }

  sub_100242E28(a1 + 5);
  *(a1 - 11) = off_100898730;
  sub_100242E28(a1 - 10);
  operator delete(v2);
}

uint64_t sub_100446CFC(uint64_t a1)
{
  uint64_t v1 = *(void *)(a1 + 16);
  __int128 v3 = *(_OWORD *)(a1 + 24);
  uint64_t v4 = *(void *)(a1 + 40);
  return sub_100445E70(v1, (uint64_t)&v3);
}

uint64_t sub_100446D3C(uint64_t a1)
{
  return sub_1004462C4(*(void *)(a1 + 24));
}

uint64_t sub_100446D4C(uint64_t a1)
{
  return sub_1004463BC(*(void *)(a1 + 16));
}

uint64_t sub_100446D5C(uint64_t a1)
{
  return sub_1004465AC(*(void *)(a1 + 16), *(void *)(a1 + 32));
}

uint64_t sub_100446D74(uint64_t a1)
{
  uint64_t v2 = *(void *)(a1 + 16);
  uint64_t v3 = *(unsigned int *)(a1 + 24);
  if ((_DWORD)v3) {
    return sub_10043B88C(v2, v3);
  }
  else {
    return sub_100446098(v2);
  }
}

void sub_100446D8C(id a1)
{
  uint64_t v1 = operator new(0x138uLL);
  sub_1003FE3E0((uint64_t)v1);
  off_1008D5F48 = v1;
}

void sub_100446DBC(_Unwind_Exception *a1)
{
}

void sub_100446DD0(id a1)
{
  uint64_t v1 = operator new(0x58uLL);
  sub_10041A094(v1);
  qword_1008D95F8 = (uint64_t)v1;
}

void sub_100446E00(_Unwind_Exception *a1)
{
}

uint64_t sub_100446E14(uint64_t a1)
{
  if (notify_register_check("com.apple.bluetooth.power", (int *)(a1 + 168))
    && os_log_type_enabled((os_log_t)qword_1008F7758, OS_LOG_TYPE_ERROR))
  {
    sub_1006802B0();
  }

  if (notify_register_check("com.apple.bluetooth.connection", (int *)(a1 + 172))
    && os_log_type_enabled((os_log_t)qword_1008F7758, OS_LOG_TYPE_ERROR))
  {
    sub_100680284();
  }

  if (notify_register_check("com.apple.bluetooth.pairing", (int *)(a1 + 176))
    && os_log_type_enabled((os_log_t)qword_1008F7758, OS_LOG_TYPE_ERROR))
  {
    sub_100680258();
  }

  if (notify_register_check("com.apple.bluetooth.pairingWithReason", (int *)(a1 + 180))
    && os_log_type_enabled((os_log_t)qword_1008F7758, OS_LOG_TYPE_ERROR))
  {
    sub_10068022C();
  }

  if (notify_register_check("com.apple.bluetooth.audio-stream", (int *)(a1 + 184))
    && os_log_type_enabled((os_log_t)qword_1008F7758, OS_LOG_TYPE_ERROR))
  {
    sub_100680200();
  }

  if (notify_register_check("com.apple.bluetooth.outgoing-le-fast-scan-level", (int *)(a1 + 188))
    && os_log_type_enabled((os_log_t)qword_1008F7758, OS_LOG_TYPE_ERROR))
  {
    sub_1006801D4();
  }

  if (notify_register_check("com.apple.bluetooth.outgoing-classic-connection-state", (int *)(a1 + 192))
    && os_log_type_enabled((os_log_t)qword_1008F7758, OS_LOG_TYPE_ERROR))
  {
    sub_1006801A8();
  }

  sub_100447074((os_unfair_lock_s *)a1);
  notify_set_state(*(_DWORD *)(a1 + 168), *(unsigned __int8 *)(a1 + 155));
  notify_post("com.apple.bluetooth.power");
  sub_1004470F0((_BYTE *)a1);
  sub_10044720C(a1);
  sub_1004472E8(a1);
  sub_1004473A4(a1);
  uint64_t v2 = (os_log_s *)qword_1008F7758;
  if (os_log_type_enabled((os_log_t)qword_1008F7758, OS_LOG_TYPE_DEFAULT))
  {
    int v4 = 138412290;
    uint64_t v5 = @"Unknown";
    _os_log_impl( (void *)&_mh_execute_header,  v2,  OS_LOG_TYPE_DEFAULT,  "Bluetooth server started (%@)",  (uint8_t *)&v4,  0xCu);
  }

  return 1LL;
}

void sub_100447074(os_unfair_lock_s *a1)
{
  v2[0] = _NSConcreteStackBlock;
  v2[1] = 3221225472LL;
  v2[2] = sub_100448220;
  v2[3] = &unk_100898DE8;
  void v2[4] = a1;
  sub_100448164(a1 + 30, v2);
}

_BYTE *sub_1004470F0(_BYTE *result)
{
  uint64_t v1 = (uint64_t)result;
  unsigned int v2 = result[197] || result[198] || result[199] || result[204] != 0;
  if (result[200] != v2)
  {
    uint64_t v3 = (os_log_s *)qword_1008F7758;
    if (os_log_type_enabled((os_log_t)qword_1008F7758, OS_LOG_TYPE_DEFAULT))
    {
      int v4 = "off";
      if (v2) {
        int v4 = "on";
      }
      int v5 = 136315138;
      uint64_t v6 = v4;
      _os_log_impl( (void *)&_mh_execute_header,  v3,  OS_LOG_TYPE_DEFAULT,  "Bluetooth Daemon: BT streaming: %s",  (uint8_t *)&v5,  0xCu);
    }

    *(_BYTE *)(v1 + 20sub_100414D2C(qword_1008F72C0, 0) = v2;
    notify_set_state(*(_DWORD *)(v1 + 184), v2);
    notify_post("com.apple.bluetooth.audio-stream");
    return (_BYTE *)sub_100448D44(v1);
  }

  return result;
}

uint64_t sub_10044720C(uint64_t a1)
{
  unsigned int v2 = (os_log_s *)qword_1008F7758;
  if (os_log_type_enabled((os_log_t)qword_1008F7758, OS_LOG_TYPE_DEFAULT))
  {
    uint64_t v3 = *(int *)(a1 + 164);
    else {
      int v4 = off_1008991C0[v3];
    }
    int v6 = 136315138;
    __int128 v7 = v4;
    _os_log_impl( (void *)&_mh_execute_header,  v2,  OS_LOG_TYPE_DEFAULT,  "Bluetooth Daemon: LE Connection scan state: %s",  (uint8_t *)&v6,  0xCu);
  }

  notify_set_state(*(_DWORD *)(a1 + 188), *(unsigned int *)(a1 + 164));
  return notify_post("com.apple.bluetooth.outgoing-le-fast-scan-level");
}

uint64_t sub_1004472E8(uint64_t a1)
{
  unsigned int v2 = (os_log_s *)qword_1008F7758;
  if (os_log_type_enabled((os_log_t)qword_1008F7758, OS_LOG_TYPE_DEFAULT))
  {
    int v3 = *(unsigned __int8 *)(a1 + 216);
    v5[0] = 67109120;
    v5[1] = v3;
    _os_log_impl( (void *)&_mh_execute_header,  v2,  OS_LOG_TYPE_DEFAULT,  "Notify outgoing classic connection state isConnecting: %d",  (uint8_t *)v5,  8u);
  }

  notify_set_state(*(_DWORD *)(a1 + 192), *(unsigned __int8 *)(a1 + 216));
  return notify_post("com.apple.bluetooth.outgoing-classic-connection-state");
}

void sub_1004473A4(uint64_t a1)
{
  unsigned int v2 = (void *)MGCopyAnswer(@"ProductVersion", 0LL);
  int v3 = v2;
  if (v2)
  {
    int v4 = (void *)objc_claimAutoreleasedReturnValue([v2 componentsSeparatedByString:@"."]);
    int v5 = (void *)objc_claimAutoreleasedReturnValue([v4 objectAtIndexedSubscript:0]);
    int v6 = (void *)objc_claimAutoreleasedReturnValue(+[NSString stringWithFormat:](&OBJC_CLASS___NSString, "stringWithFormat:", @"%@", v5));

    __int128 v7 = (void *)CFPreferencesCopyAppValue(@"MajorOSVersion", @"com.apple.BTServer");
    if (([v7 isEqualToString:v6] & 1) == 0)
    {
      __int128 v8 = (void *)objc_claimAutoreleasedReturnValue(+[MCProfileConnection sharedConnection](&OBJC_CLASS___MCProfileConnection, "sharedConnection"));
      unsigned __int8 v9 = [v8 isBluetoothModificationAllowed];

      __int128 v10 = (os_log_s *)qword_1008F7758;
      BOOL v11 = os_log_type_enabled((os_log_t)qword_1008F7758, OS_LOG_TYPE_DEFAULT);
      if ((v9 & 1) != 0)
      {
        if (v11)
        {
          *(_WORD *)std::string buf = 0;
          _os_log_impl( (void *)&_mh_execute_header,  v10,  OS_LOG_TYPE_DEFAULT,  "Major version update, setting default power state to ON",  buf,  2u);
        }

        uint64_t v12 = sub_1002E6B38();
        (*(void (**)(uint64_t, uint64_t))(*(void *)v12 + 96LL))(v12, 1LL);
        uint64_t v13 = sub_1002E6B38();
        (*(void (**)(uint64_t, uint64_t))(*(void *)v13 + 112LL))(v13, 1LL);
      }

      else if (v11)
      {
        *(_WORD *)__int128 v15 = 0;
        _os_log_impl( (void *)&_mh_execute_header,  v10,  OS_LOG_TYPE_DEFAULT,  "Major version update but bluetooth modification is not allowed",  v15,  2u);
      }

      CFPreferencesSetAppValue(@"MajorOSVersion", v6, @"com.apple.BTServer");
      CFPreferencesSynchronize(@"com.apple.BTServer", kCFPreferencesCurrentUser, kCFPreferencesAnyHost);
      *(_BYTE *)(a1 + 152) = 1;
    }
  }
}

void sub_100447580(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

BOOL sub_1004475D0()
{
  char v8 = 0;
  uint64_t v0 = sub_1002E6E00();
  sub_10002418C(v6, "BT");
  sub_10002418C(__p, "EraseAllPairedAndCachedDevice");
  uint64_t v1 = (*(uint64_t (**)(uint64_t, void **, void **, char *))(*(void *)v0 + 72LL))(v0, v6, __p, &v8);
  if (v8) {
    int v2 = v1;
  }
  else {
    int v2 = 0;
  }
  if (v5 < 0) {
    operator delete(__p[0]);
  }
  if ((v7 & 0x80000000) == 0)
  {
    if (v2) {
      goto LABEL_8;
    }
LABEL_14:
    if (qword_1008D9178 != -1) {
      dispatch_once(&qword_1008D9178, &stru_1008990A0);
    }
    BOOL result = sub_100532F64((void *)qword_1008D9170);
    if (result)
    {
      sub_10002AA58();
      return 1LL;
    }

    return result;
  }

  operator delete(v6[0]);
  if (!v2) {
    goto LABEL_14;
  }
LABEL_8:
  if (MKBDeviceUnlockedSinceBoot(v1))
  {
    sub_100298B00();
    if (qword_1008D5F30 != -1) {
      dispatch_once(&qword_1008D5F30, &stru_100899080);
    }
    sub_1005D51BC((uint64_t)off_1008D5F28);
    BOOL result = os_log_type_enabled((os_log_t)qword_1008F7758, OS_LOG_TYPE_ERROR);
    if (result)
    {
      sub_100680308();
      return 0LL;
    }
  }

  else
  {
    BOOL result = os_log_type_enabled((os_log_t)qword_1008F7758, OS_LOG_TYPE_ERROR);
    if (result)
    {
      sub_1006802DC();
      return 0LL;
    }
  }

  return result;
}

void sub_100447744( _Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void *__p, uint64_t a11, int a12, __int16 a13, char a14, char a15, void *a16, uint64_t a17, int a18, __int16 a19, char a20, char a21)
{
  if (a15 < 0) {
    operator delete(__p);
  }
  if (a21 < 0) {
    operator delete(a16);
  }
  _Unwind_Resume(exception_object);
}

void sub_100447778(uint64_t a1)
{
  *(_BYTE *)(a1 + 104) = 0;
  *(void *)(a1 + 152) = 0LL;
  *(_DWORD *)(a1 + 16sub_100414D2C(qword_1008F72C0, 0) = 0;
  if (qword_1008D60B0 != -1) {
    dispatch_once(&qword_1008D60B0, &stru_1008990C0);
  }
  sub_1001FC5E4((uint64_t)off_1008D60A8 + 80, a1);
  uint64_t v2 = sub_1002E6BF0();
  *(_BYTE *)(a1 + 32sub_100414D2C(qword_1008F72C0, 0) = (*(uint64_t (**)(uint64_t))(*(void *)v2 + 840LL))(v2);
  sub_1004478BC(a1);
  *(_BYTE *)(a1 + 272) = 0;
  *(_DWORD *)(a1 + 2sub_10023DF50(v3 + 76) = 0;
  *(_BYTE *)(a1 + 28sub_100414D2C(qword_1008F72C0, 0) = 0;
  *(_DWORD *)(a1 + 284) = 0;
  uint64_t v3 = sub_1002E8D54();
  sub_1001FCB98(v3 + 288, a1 + 8);
  uint64_t v4 = sub_1002E8EE8();
  (*(void (**)(uint64_t, uint64_t))(*(void *)v4 + 128LL))(v4, a1 + 16);
  if (qword_1008D93F8 != -1) {
    dispatch_once(&qword_1008D93F8, &stru_1008990E0);
  }
  sub_10048B8E4(qword_1008D93F0, a1 + 32);
  *(_BYTE *)(a1 + 48_Block_object_dispose((const void *)(v2 - 88), 8) = 0;
  *(void *)(a1 + 386) = 0LL;
  *(void *)(a1 + 394) = 0LL;
  *(void *)(a1 + 37_Block_object_dispose((const void *)(v2 - 88), 8) = 0LL;
  *(void *)(a1 + 399) = 0LL;
  uint64_t v5 = sub_100404EB8();
  v6[0] = _NSConcreteStackBlock;
  v6[1] = 3221225472LL;
  void v6[2] = sub_100447A64;
  void v6[3] = &unk_10087EB20;
  v6[4] = a1;
  sub_100405384(v5, v6);
}

void sub_1004478BC(uint64_t a1)
{
  uint64_t v2 = (void *)MGCopyAnswer(@"BuildVersion", 0LL);
  if (v2)
  {
    uint64_t v3 = (void *)CFPreferencesCopyAppValue(@"OSBuildVersion", @"com.apple.BTServer");
    uint64_t v4 = (os_log_s *)qword_1008F7758;
    if (os_log_type_enabled((os_log_t)qword_1008F7758, OS_LOG_TYPE_DEFAULT))
    {
      int v6 = 138412546;
      char v7 = v3;
      __int16 v8 = 2112;
      unsigned __int8 v9 = v2;
      _os_log_impl( (void *)&_mh_execute_header,  v4,  OS_LOG_TYPE_DEFAULT,  "Identification - OS build last %@, current %@",  (uint8_t *)&v6,  0x16u);
    }

    if (([v3 isEqualToString:v2] & 1) == 0)
    {
      uint64_t v5 = (os_log_s *)qword_1008F7758;
      if (os_log_type_enabled((os_log_t)qword_1008F7758, OS_LOG_TYPE_DEFAULT))
      {
        LOWORD(v6) = 0;
        _os_log_impl( (void *)&_mh_execute_header,  v5,  OS_LOG_TYPE_DEFAULT,  "Identification - OS build updated",  (uint8_t *)&v6,  2u);
      }

      CFPreferencesSetAppValue(@"OSBuildVersion", v2, @"com.apple.BTServer");
      CFPreferencesSynchronize(@"com.apple.BTServer", kCFPreferencesCurrentUser, kCFPreferencesAnyHost);
      *(_BYTE *)(a1 + 153) = 1;
    }
  }
}

void sub_100447A40(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

uint64_t sub_100447A64(uint64_t a1)
{
  uint64_t v1 = *(void *)(a1 + 32);
  __int16 v8 = 0;
  __int16 v7 = 0;
  char v6 = 0;
  int v5 = 0;
  uint64_t v2 = sub_1002E8D54();
  uint64_t result = (*(uint64_t (**)(uint64_t, char *, __int16 *, char *, __int16 *, char *, int *))(*(void *)v2 + 48LL))( v2,  (char *)&v8 + 1,  &v8,  (char *)&v7 + 1,  &v7,  &v6,  &v5);
  if (!(_DWORD)result)
  {
    *(_BYTE *)(v1 + 272) = v7;
    if (HIBYTE(v8))
    {
      int v4 = 1;
    }

    else if ((_BYTE)v8)
    {
      int v4 = 2;
    }

    else
    {
      if (!HIBYTE(v7))
      {
        *(_DWORD *)(v1 + 2sub_10023DF50(v3 + 76) = 0;
        goto LABEL_9;
      }

      int v4 = 3;
    }

    *(_DWORD *)(v1 + 2sub_10023DF50(v3 + 76) = v4;
LABEL_9:
    *(_BYTE *)(v1 + 28sub_100414D2C(qword_1008F72C0, 0) = v6;
  }

  return result;
}

void sub_100447B0C(uint64_t a1, uint64_t a2)
{
}

void sub_100447B14(uint64_t a1, uint64_t a2)
{
  int v5 = *(char **)(a1 + 8);
  int v4 = *(char **)(a1 + 16);
  if (v5 != v4)
  {
    while (*(void *)v5 != a2)
    {
      v5 += 8;
      if (v5 == v4)
      {
        int v5 = *(char **)(a1 + 16);
        break;
      }
    }
  }

  if (v5 == v4)
  {
    uint64_t v6 = a2;
    sub_10044DCCC(a1 + 8, v4, (char *)&v6);
    sub_100008A30(a1 + 8);
  }

  os_unfair_lock_unlock((os_unfair_lock_t)a1);
}

void sub_100447B9C(uint64_t a1, uint64_t a2)
{
}

uint64_t sub_100447BA4(uint64_t a1)
{
  v4[0] = 0LL;
  v4[1] = 0LL;
  sub_100242F28((uint64_t)v4, a1 + 40);
  *(_BYTE *)(a1 + 104) = 1;
  *(void *)(a1 + 38_Block_object_dispose((const void *)(v2 - 88), 8) = 0LL;
  *(void *)(a1 + 396) = 0LL;
  *(void *)(a1 + 38sub_100414D2C(qword_1008F72C0, 0) = 0LL;
  *(_DWORD *)(a1 + 403) = 0;
  sub_100242F54((uint64_t)v4);
  char v3 = 0;
  sub_100242CA4(&v3);
  sub_1001E0374(sub_100447C48);
  sub_100242CD8(&v3);
  return sub_100242FAC((uint64_t)v4);
}

void sub_100447C20( _Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, int a10, __int16 a11, char a12, char a13, char a14)
{
}

void sub_100447C48(char a1)
{
  uint64_t v2 = sub_100404EB8();
  v3[0] = _NSConcreteStackBlock;
  v3[1] = 3221225472LL;
  void v3[2] = sub_10044C6DC;
  void v3[3] = &unk_100898180;
  char v4 = a1;
  sub_100405384(v2, v3);
}

uint64_t sub_100447CA8(uint64_t a1)
{
  uint64_t v2 = (os_log_s *)qword_1008F7758;
  if (os_log_type_enabled((os_log_t)qword_1008F7758, OS_LOG_TYPE_DEFAULT))
  {
    *(_WORD *)std::string buf = 0;
    _os_log_impl((void *)&_mh_execute_header, v2, OS_LOG_TYPE_DEFAULT, "BluetoothDaemon::stackWillStop enter", buf, 2u);
  }

  *(void *)std::string buf = 0LL;
  uint64_t v10 = 0LL;
  sub_100242F28((uint64_t)buf, a1 + 40);
  *(_BYTE *)(a1 + 104) = 0;
  *(void *)(a1 + 28_Block_object_dispose((const void *)(v2 - 88), 8) = 0LL;
  *(void *)(a1 + 296) = 0LL;
  sub_100242F54((uint64_t)buf);
  sub_100447E18(a1);
  char v4 = *(void **)(a1 + 232);
  uint64_t v3 = a1 + 232;
  sub_10044DF08(v3 - 8, v4);
  *(void *)(v3 - _Block_object_dispose((const void *)(v2 - 88), 8) = v3;
  *(void *)uint64_t v3 = 0LL;
  *(void *)(v3 + _Block_object_dispose((const void *)(v2 - 88), 8) = 0LL;
  sub_10044DF94(v3 + 16, *(void **)(v3 + 24));
  *(void *)(v3 + 24) = 0LL;
  *(void *)(v3 + sub_100242FAC(v1 - 32) = 0LL;
  *(void *)(v3 + 16) = v3 + 24;
  sub_10023BF24(v3 + 200, *(void **)(v3 + 208));
  *(void *)(v3 + 20_Block_object_dispose((const void *)(v2 - 88), 8) = 0LL;
  *(void *)(v3 + 216) = 0LL;
  *(void *)(v3 + 20sub_100414D2C(qword_1008F72C0, 0) = v3 + 208;
  char v8 = 0;
  sub_100242CA4(&v8);
  sub_1001E03A0(sub_100447C48);
  sub_100242CD0(&v8);
  int v5 = (os_log_s *)qword_1008F7758;
  if (os_log_type_enabled((os_log_t)qword_1008F7758, OS_LOG_TYPE_DEFAULT))
  {
    *(_WORD *)__int16 v7 = 0;
    _os_log_impl((void *)&_mh_execute_header, v5, OS_LOG_TYPE_DEFAULT, "BluetoothDaemon::stackWillStop exit", v7, 2u);
  }

  sub_100242CD8(&v8);
  return sub_100242FAC((uint64_t)buf);
}

void sub_100447DF0(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, ...)
{
}

uint64_t sub_100447E18(uint64_t a1)
{
  v7[0] = 0LL;
  v7[1] = 0LL;
  sub_100242F28((uint64_t)v7, a1 + 40);
  uint64_t v2 = (os_log_s *)qword_1008F7758;
  if (os_log_type_enabled((os_log_t)qword_1008F7758, OS_LOG_TYPE_INFO))
  {
    *(_WORD *)uint64_t v6 = 0;
    _os_log_impl((void *)&_mh_execute_header, v2, OS_LOG_TYPE_INFO, "cancelSoftwareScanRxTimer", v6, 2u);
  }

  if (!*(_BYTE *)(a1 + 320))
  {
    uint64_t v3 = *(dispatch_source_s **)(a1 + 328);
    if (v3)
    {
      char v4 = (os_log_s *)qword_1008F7758;
      if (os_log_type_enabled((os_log_t)qword_1008F7758, OS_LOG_TYPE_INFO))
      {
        *(_WORD *)uint64_t v6 = 0;
        _os_log_impl((void *)&_mh_execute_header, v4, OS_LOG_TYPE_INFO, "fSoftwareScanRxTimer destroyed!", v6, 2u);
        uint64_t v3 = *(dispatch_source_s **)(a1 + 328);
      }

      dispatch_source_cancel(v3);
      dispatch_release(*(dispatch_object_t *)(a1 + 328));
      *(void *)(a1 + 32_Block_object_dispose((const void *)(v2 - 88), 8) = 0LL;
    }
  }

  return sub_100242FAC((uint64_t)v7);
}

uint64_t sub_100447F04(uint64_t a1)
{
  return *(unsigned __int8 *)(a1 + 153);
}

uint64_t sub_100447F0C(uint64_t a1)
{
  return *(unsigned __int8 *)(a1 + 154);
}

void sub_100447F14(uint64_t a1, uint64_t state64)
{
  if (*(unsigned __int8 *)(a1 + 155) != (_DWORD)state64)
  {
    char v2 = state64;
    *(_BYTE *)(a1 + 155) = state64;
    notify_set_state(*(_DWORD *)(a1 + 168), state64);
    notify_post("com.apple.bluetooth.power");
    if (sub_100487EA8())
    {
      char v4 = *(void **)(a1 + 112);
      if (v4)
      {
        id v5 = v4;
      }

      else
      {
        uint64_t v6 = BiomeLibrary();
        __int16 v7 = (void *)objc_claimAutoreleasedReturnValue(v6);
        char v8 = (void *)objc_claimAutoreleasedReturnValue([v7 Device]);
        unsigned __int8 v9 = (void *)objc_claimAutoreleasedReturnValue([v8 Wireless]);
        uint64_t v10 = objc_claimAutoreleasedReturnValue([v9 BluetoothPowerEnabled]);
        BOOL v11 = *(void **)(a1 + 112);
        *(void *)(a1 + 112) = v10;

        id v5 = *(id *)(a1 + 112);
        if (!v5) {
          return;
        }
      }

      uint64_t v12 = sub_100405218();
      v14[0] = _NSConcreteStackBlock;
      v14[1] = 3221225472LL;
      void v14[2] = sub_100448084;
      v14[3] = &unk_100880230;
      char v16 = v2;
      id v13 = v5;
      id v15 = v13;
      sub_100405384(v12, v14);
    }
  }

void sub_100448040(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_100448084(uint64_t a1)
{
  id v2 = objc_alloc(&OBJC_CLASS___BMDeviceBluetoothPowerEnabled);
  uint64_t v3 = (void *)objc_claimAutoreleasedReturnValue(+[NSNumber numberWithBool:](&OBJC_CLASS___NSNumber, "numberWithBool:", *(unsigned __int8 *)(a1 + 40)));
  id v5 = [v2 initWithStarting:v3];

  char v4 = (void *)objc_claimAutoreleasedReturnValue([*(id *)(a1 + 32) source]);
  [v4 sendEvent:v5];
}

void sub_10044810C( _Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, void *a10)
{
  _Unwind_Resume(a1);
}

void sub_100448134(os_unfair_lock_s *a1, uint32_t a2)
{
  if (a1[39]._os_unfair_lock_opaque != a2)
  {
    a1[39]._os_unfair_lock_opaque = a2;
    sub_100447074(a1);
  }

void sub_10044814C(os_unfair_lock_s *a1, uint32_t a2)
{
  if (a1[40]._os_unfair_lock_opaque != a2)
  {
    a1[40]._os_unfair_lock_opaque = a2;
    sub_100447074(a1);
  }

void sub_100448164(os_unfair_lock_s *a1, void *a2)
{
  uint64_t v3 = a2;
  os_unfair_lock_lock(a1);
  id v5 = 0LL;
  uint64_t v6 = 0LL;
  uint64_t v7 = 0LL;
  sub_100240540(&v5, (uint64_t)&a1[2]);
  os_unfair_lock_unlock(a1);
  char v4 = v5;
  if (v5 != v6)
  {
    do
      v3[2](v3, *v4++);
    while (v4 != v6);
    char v4 = v5;
  }

  if (v4)
  {
    uint64_t v6 = v4;
    operator delete(v4);
  }
}

void sub_1004481F8( _Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void *__p, uint64_t a11)
{
  _Unwind_Resume(a1);
}

uint64_t sub_100448220(uint64_t a1, uint64_t a2)
{
  return (*(uint64_t (**)(uint64_t, void))(*(void *)a2 + 48LL))( a2,  *(unsigned __int16 *)(*(void *)(a1 + 32) + 156LL));
}

uint64_t sub_10044823C(uint64_t a1)
{
  return *(unsigned __int8 *)(a1 + 152);
}

uint64_t sub_100448244(uint64_t a1, int a2, uint64_t a3, uint64_t a4)
{
  uint64_t v7 = 0x1000000000000LL;
  if (!a2) {
    uint64_t v7 = 0LL;
  }
  notify_set_state(*(_DWORD *)(a1 + 176), v7 | a3);
  notify_post("com.apple.bluetooth.pairing");
  notify_set_state(*(_DWORD *)(a1 + 180), a3 | (a4 << 56));
  char v8 = (os_log_s *)qword_1008F7758;
  if (os_log_type_enabled((os_log_t)qword_1008F7758, OS_LOG_TYPE_DEFAULT))
  {
    switch((int)a4)
    {
      case 200:
        unsigned __int8 v9 = "CBPairingReasonUnpairDefault";
        break;
      case 201:
        unsigned __int8 v9 = "CBPairingReasonUnpairUserSwitch";
        break;
      case 202:
        unsigned __int8 v9 = "CBPairingReasonUnpairCloud";
        break;
      case 203:
        unsigned __int8 v9 = "CBPairingReasonUnpairMagnet";
        break;
      default:
        uint64_t v10 = "?";
        if ((_DWORD)a4 == 1) {
          uint64_t v10 = "CBPairingReasonPairingDefault";
        }
        if ((_DWORD)a4) {
          unsigned __int8 v9 = v10;
        }
        else {
          unsigned __int8 v9 = "CBPairingReasonUnknown";
        }
        break;
    }

    id v11 = sub_1005BF848(a3);
    id v12 = objc_claimAutoreleasedReturnValue(v11);
    int v14 = 136315394;
    id v15 = v9;
    __int16 v16 = 2080;
    id v17 = [v12 UTF8String];
    _os_log_impl( (void *)&_mh_execute_header,  v8,  OS_LOG_TYPE_DEFAULT,  "Bluetooth Daemon: pairingReason %s, addr %s",  (uint8_t *)&v14,  0x16u);
  }

  return notify_post("com.apple.bluetooth.pairingWithReason");
}

void sub_1004483D4(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

uint64_t sub_1004483EC(uint64_t a1, uint64_t a2)
{
  *(_BYTE *)(a1 + 196) = a2;
  uint64_t v3 = sub_1002E8D94();
  return (*(uint64_t (**)(uint64_t, uint64_t))(*(void *)v3 + 616LL))(v3, a2);
}

uint64_t sub_10044841C(uint64_t a1, int a2)
{
  if (*(unsigned __int8 *)(a1 + 216) != a2)
  {
    *(_BYTE *)(a1 + 216) = a2;
    return sub_1004472E8(a1);
  }

  return a1;
}

os_unfair_lock_s *sub_100448434(os_unfair_lock_s *result, int a2, uint64_t a3)
{
  if (BYTE1(result[49]._os_unfair_lock_opaque) != a2)
  {
    id v5 = result;
    uint64_t v6 = (os_log_s *)qword_1008F7758;
    if (os_log_type_enabled((os_log_t)qword_1008F7758, OS_LOG_TYPE_DEFAULT))
    {
      id v7 = sub_1005BF848(a3);
      uint64_t v8 = objc_claimAutoreleasedReturnValue(v7);
      unsigned __int8 v9 = (void *)v8;
      uint64_t v10 = "off";
      if (a2) {
        uint64_t v10 = "on";
      }
      *(_DWORD *)std::string buf = 138543618;
      uint64_t v14 = v8;
      __int16 v15 = 2080;
      __int16 v16 = v10;
      _os_log_impl( (void *)&_mh_execute_header,  v6,  OS_LOG_TYPE_DEFAULT,  "Bluetooth Daemon: A2DP streaming to device %{public}@: %s",  buf,  0x16u);
    }

    BYTE1(v5[49]._os_unfair_lock_opaque) = a2;
    v11[0] = _NSConcreteStackBlock;
    v11[1] = 3221225472LL;
    _DWORD v11[2] = sub_10044857C;
    v11[3] = &unk_100898E08;
    uint8_t v11[4] = a3;
    char v12 = a2;
    sub_100448164(v5 + 30, v11);
    return (os_unfair_lock_s *)sub_1004470F0(v5);
  }

  return result;
}

uint64_t sub_10044857C(uint64_t a1, uint64_t (***a2)(void, void, void, uint64_t))
{
  return (**a2)(a2, *(void *)(a1 + 32), *(unsigned __int8 *)(a1 + 40), 2LL);
}

void sub_10044859C(uint64_t a1)
{
  uint64_t v15 = *(void *)(a1 + 32);
  uint64_t v1 = sub_1002E6E9C();
  if ((*(unsigned int (**)(uint64_t))(*(void *)v1 + 2688LL))(v1))
  {
    if (qword_1008D5F30 != -1) {
      dispatch_once(&qword_1008D5F30, &stru_100899080);
    }
    int v23 = 0;
    int v24 = 0;
    __int16 v22 = 0;
    id v2 = sub_1005D8C08((uint64_t)off_1008D5F28);
    __int128 v20 = 0u;
    __int128 v21 = 0u;
    __int128 v18 = 0u;
    __int128 v19 = 0u;
    id v3 = (id)objc_claimAutoreleasedReturnValue(v2);
    id v4 = [v3 countByEnumeratingWithState:&v18 objects:v26 count:16];
    if (v4)
    {
      uint64_t v5 = *(void *)v19;
      do
      {
        uint64_t v6 = 0LL;
        do
        {
          if (*(void *)v19 != v5) {
            objc_enumerationMutation(v3);
          }
          id v7 = *(id *)(*((void *)&v18 + 1) + 8LL * (void)v6);
          if (qword_1008D5F30 != -1) {
            dispatch_once(&qword_1008D5F30, &stru_100899080);
          }
          uint64_t v8 = off_1008D5F28;
          sub_10002418C(__p, "BluetoothTVRemote");
          char v9 = sub_1005CE5A8((uint64_t)v8, v7, (uint64_t)__p);
          char v10 = v9;
          if (v17 < 0)
          {
            operator delete(__p[0]);
            if ((v10 & 1) != 0) {
              goto LABEL_27;
            }
          }

          else if ((v9 & 1) != 0)
          {
            goto LABEL_27;
          }

          if (qword_1008D5F30 != -1) {
            dispatch_once(&qword_1008D5F30, &stru_100899080);
          }
          if (sub_1005D4FEC((uint64_t)off_1008D5F28, v7))
          {
            if (qword_1008D5F10 != -1) {
              dispatch_once(&qword_1008D5F10, &stru_100899100);
            }
            id v11 = off_1008D5F08;
            sub_100241F90(v25, v7);
            if (!sub_1005B12DC((uint64_t)v11, v25, (_WORD *)&v24 + 1, &v24, (_WORD *)&v23 + 1, &v23, &v22))
            {
              if (*(_BYTE *)(v15 + 198)) {
                __int16 v12 = 4;
              }
              else {
                __int16 v12 = 6;
              }
              HIWORD(v23) = 2;
              LOWORD(v23) = v12;
              if (qword_1008D5F10 != -1) {
                dispatch_once(&qword_1008D5F10, &stru_100899100);
              }
              id v13 = off_1008D5F08;
              __n128 v14 = sub_100241F90(v25, v7);
              v14.n128_u16[0] = HIWORD(v24);
              sub_1005B09DC( (uint64_t)v13,  v25,  HIWORD(v23),  (unsigned __int16)v23,  (unsigned __int16)v24,  v24,  2 * ((5 * v22) & 0x7FFF),  (float)v14.n128_u32[0] * 1.25,  (float)v14.n128_u32[0] * 1.25,  (float)v14.n128_u32[0] * 1.25);
            }
          }

void sub_1004488A4( _Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void *__p, uint64_t a11, int a12, __int16 a13, char a14, char a15)
{
  _Unwind_Resume(a1);
}

void sub_1004488F4(uint64_t a1, void *a2)
{
  id v4 = a2;
  uint64_t v5 = (os_log_s *)qword_1008F7758;
  if (os_log_type_enabled((os_log_t)qword_1008F7758, OS_LOG_TYPE_DEFAULT))
  {
    *(_DWORD *)std::string buf = 138412290;
    id v10 = v4;
    _os_log_impl( (void *)&_mh_execute_header,  v5,  OS_LOG_TYPE_DEFAULT,  "Bluetooth Daemon: Country code changed: %@",  buf,  0xCu);
  }

  objc_storeStrong((id *)(a1 + 480), a2);
  v7[0] = _NSConcreteStackBlock;
  v7[1] = 3221225472LL;
  void v7[2] = sub_100448A28;
  void v7[3] = &unk_100898E30;
  id v8 = v4;
  id v6 = v4;
  sub_100448164((os_unfair_lock_s *)(a1 + 120), v7);
}

void sub_100448A08( _Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, void *a14)
{
  _Unwind_Resume(a1);
}

uint64_t sub_100448A28(uint64_t a1, uint64_t a2)
{
  return (*(uint64_t (**)(uint64_t, void))(*(void *)a2 + 56LL))(a2, *(void *)(a1 + 32));
}

void sub_100448A40(uint64_t a1, int a2, uint64_t a3)
{
  if (*(unsigned __int8 *)(a1 + 198) != a2)
  {
    id v6 = (os_log_s *)qword_1008F7758;
    if (os_log_type_enabled((os_log_t)qword_1008F7758, OS_LOG_TYPE_DEFAULT))
    {
      id v7 = sub_1005BF848(a3);
      uint64_t v8 = objc_claimAutoreleasedReturnValue(v7);
      char v9 = (void *)v8;
      id v10 = "off";
      if (a2) {
        id v10 = "on";
      }
      *(_DWORD *)std::string buf = 138543618;
      *(void *)&uint8_t buf[4] = v8;
      *(_WORD *)&_BYTE buf[12] = 2080;
      *(void *)&_BYTE buf[14] = v10;
      _os_log_impl( (void *)&_mh_execute_header,  v6,  OS_LOG_TYPE_DEFAULT,  "Bluetooth Daemon: HFP streaming to device %{public}@: %s",  buf,  0x16u);
    }

    *(_BYTE *)(a1 + 19_Block_object_dispose((const void *)(v2 - 88), 8) = a2;
    v12[0] = _NSConcreteStackBlock;
    v12[1] = 3221225472LL;
    void v12[2] = sub_100448BBC;
    v12[3] = &unk_100898E08;
    void v12[4] = a3;
    char v13 = a2;
    sub_100448164((os_unfair_lock_s *)(a1 + 120), v12);
    sub_1004470F0((_BYTE *)a1);
    uint64_t v11 = sub_100404FE8();
    *(void *)std::string buf = _NSConcreteStackBlock;
    *(void *)&uint8_t buf[8] = 3221225472LL;
    *(void *)&uint8_t buf[16] = sub_10044859C;
    uint64_t v15 = &unk_10087EB20;
    uint64_t v16 = a1;
    sub_100405384(v11, buf);
  }

uint64_t sub_100448BBC(uint64_t a1, uint64_t (***a2)(void, void, void, uint64_t))
{
  return (**a2)(a2, *(void *)(a1 + 32), *(unsigned __int8 *)(a1 + 40), 1LL);
}

os_unfair_lock_s *sub_100448BDC(os_unfair_lock_s *result, int a2, uint64_t a3)
{
  if (HIBYTE(result[49]._os_unfair_lock_opaque) != a2)
  {
    uint64_t v5 = result;
    id v6 = (os_log_s *)qword_1008F7758;
    if (os_log_type_enabled((os_log_t)qword_1008F7758, OS_LOG_TYPE_DEFAULT))
    {
      id v7 = sub_1005BFB9C(a3);
      uint64_t v8 = objc_claimAutoreleasedReturnValue(v7);
      char v9 = (void *)v8;
      id v10 = "off";
      if (a2) {
        id v10 = "on";
      }
      *(_DWORD *)std::string buf = 138543618;
      uint64_t v14 = v8;
      __int16 v15 = 2080;
      uint64_t v16 = v10;
      _os_log_impl( (void *)&_mh_execute_header,  v6,  OS_LOG_TYPE_DEFAULT,  "Bluetooth Daemon: LEA streaming to device: %{public}@  %s",  buf,  0x16u);
    }

    HIBYTE(v5[49]._os_unfair_lock_opaque) = a2;
    v11[0] = _NSConcreteStackBlock;
    v11[1] = 3221225472LL;
    _DWORD v11[2] = sub_100448D24;
    v11[3] = &unk_100898E08;
    uint8_t v11[4] = a3;
    char v12 = a2;
    sub_100448164(v5 + 30, v11);
    return (os_unfair_lock_s *)sub_1004470F0(v5);
  }

  return result;
}

uint64_t sub_100448D24(uint64_t a1, uint64_t (***a2)(void, void, void, uint64_t))
{
  return (**a2)(a2, *(void *)(a1 + 32), *(unsigned __int8 *)(a1 + 40), 3LL);
}

uint64_t sub_100448D44(uint64_t a1)
{
  v12[0] = 0LL;
  v12[1] = 0LL;
  sub_100242F28((uint64_t)v12, a1 + 40);
  id v2 = (os_log_s *)qword_1008F7758;
  if (os_log_type_enabled((os_log_t)qword_1008F7758, OS_LOG_TYPE_DEFAULT))
  {
    int v3 = *(unsigned __int8 *)(a1 + 197);
    int v4 = *(unsigned __int8 *)(a1 + 198);
    int v5 = *(unsigned __int8 *)(a1 + 204);
    int v6 = *(unsigned __int8 *)(a1 + 200);
    p_p = &__p;
    sub_1001F9F74(a1 + 272, &__p);
    if ((__p.__r_.__value_.__s.__size_ & 0x80u) != 0) {
      p_p = (std::stringbuf::string_type *)__p.__r_.__value_.__r.__words[0];
    }
    uint64_t v8 = sub_1002E8EE8();
    int v9 = (*(uint64_t (**)(uint64_t))(*(void *)v8 + 96LL))(v8);
    *(_DWORD *)std::string buf = 67110402;
    int v14 = v3;
    __int16 v15 = 1024;
    int v16 = v4;
    __int16 v17 = 1024;
    int v18 = v5;
    __int16 v19 = 1024;
    int v20 = v6;
    __int16 v21 = 2080;
    __int16 v22 = p_p;
    __int16 v23 = 1024;
    int v24 = v9;
    _os_log_impl( (void *)&_mh_execute_header,  v2,  OS_LOG_TYPE_DEFAULT,  "coexChanged a2dp:%d hfp:%d isoPipe:%d BTStreaming:%d wifi:%s critical(UCM):%d",  buf,  0x2Au);
  }

  if (*(void *)(a1 + 240) || *(void *)(a1 + 264)) {
    sub_10044B750(a1, 1);
  }
  sub_100448164((os_unfair_lock_s *)(a1 + 120), &stru_100898F00);
  return sub_100242FAC((uint64_t)v12);
}

void sub_100448EC0( _Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void *__p, uint64_t a11, int a12, __int16 a13, char a14, char a15, char a16)
{
}

void sub_100448EF8(uint64_t a1, int a2, uint64_t a3)
{
  if (*(unsigned __int8 *)(a1 + 201) != a2)
  {
    int v6 = (os_log_s *)qword_1008F7758;
    if (os_log_type_enabled((os_log_t)qword_1008F7758, OS_LOG_TYPE_DEFAULT))
    {
      id v7 = sub_1005BF848(a3);
      uint64_t v8 = objc_claimAutoreleasedReturnValue(v7);
      int v9 = (void *)v8;
      id v10 = "off";
      if (a2) {
        id v10 = "on";
      }
      *(_DWORD *)std::string buf = 138543618;
      uint64_t v14 = v8;
      __int16 v15 = 2080;
      int v16 = v10;
      _os_log_impl( (void *)&_mh_execute_header,  v6,  OS_LOG_TYPE_DEFAULT,  "BT ACL protect mode to device %{public}@: %s",  buf,  0x16u);
    }

    *(_BYTE *)(a1 + 201) = a2;
    v11[0] = _NSConcreteStackBlock;
    v11[1] = 3221225472LL;
    _DWORD v11[2] = sub_100449038;
    v11[3] = &unk_100898E08;
    uint8_t v11[4] = a3;
    char v12 = a2;
    sub_100448164((os_unfair_lock_s *)(a1 + 120), v11);
  }

uint64_t sub_100449038(uint64_t a1, uint64_t a2)
{
  return (*(uint64_t (**)(uint64_t, void, void))(*(void *)a2 + 16LL))( a2,  *(void *)(a1 + 32),  *(unsigned __int8 *)(a1 + 40));
}

uint64_t sub_100449054(uint64_t result, char a2)
{
  *(_BYTE *)(result + 203) = a2;
  return result;
}

uint64_t sub_10044905C(uint64_t result, char a2)
{
  *(_BYTE *)(result + 202) = a2;
  return result;
}

_BYTE *sub_100449064(_BYTE *result, int a2)
{
  if (result[204] != a2)
  {
    id v2 = result;
    result[204] = a2;
    v3[0] = _NSConcreteStackBlock;
    v3[1] = 3221225472LL;
    void v3[2] = sub_1004490DC;
    void v3[3] = &unk_100898E50;
    char v4 = a2;
    sub_100448164((os_unfair_lock_s *)result + 30, v3);
    return sub_1004470F0(v2);
  }

  return result;
}

uint64_t sub_1004490DC(uint64_t a1, uint64_t (***a2)(void, void, void, uint64_t))
{
  return (**a2)(a2, 0LL, *(unsigned __int8 *)(a1 + 32), 4LL);
}

void sub_1004490F8(double a1)
{
  if (a1 <= 0.0) {
    uint64_t v1 = 0LL;
  }
  else {
    uint64_t v1 = (void *)objc_claimAutoreleasedReturnValue( +[NSDate dateWithTimeIntervalSinceReferenceDate:]( &OBJC_CLASS___NSDate,  "dateWithTimeIntervalSinceReferenceDate:"));
  }
  id v2 = v1;
  CFPreferencesSetAppValue(@"DenylistEnabledTime", v1, @"com.apple.BTServer");
}

void sub_100449158( _Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, id a10)
{
}

double sub_10044916C()
{
  uint64_t v0 = (void *)CFPreferencesCopyAppValue(@"DenylistEnabledTime", @"com.apple.BTServer");
  double v1 = 0.0;
  if (v0)
  {
    uint64_t v2 = objc_opt_class(&OBJC_CLASS___NSDate);
    if ((objc_opt_isKindOfClass(v0, v2) & 1) != 0)
    {
      [v0 timeIntervalSinceReferenceDate];
      double v1 = v3;
    }
  }

  return v1;
}

void sub_1004491DC(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

uint64_t sub_1004491EC(uint64_t a1, int a2)
{
  if (*(_DWORD *)(a1 + 164) != a2)
  {
    *(_DWORD *)(a1 + 1sub_100242FAC(v30 - 64) = a2;
    return sub_10044720C(a1);
  }

  return a1;
}

BOOL sub_100449204(_BYTE *a1)
{
  return !a1[197] && !a1[198] && !a1[199] && a1[204] == 0;
}

BOOL sub_100449234(_BYTE *a1)
{
  return !a1[198] && !a1[199] && a1[204] == 0;
}

BOOL sub_10044925C(_BYTE *a1, uint64_t a2)
{
  if (IsAppleInternalBuild(a1, a2))
  {
    if (qword_1008F1048 != -1) {
      dispatch_once(&qword_1008F1048, &stru_100898E70);
    }
    if (byte_1008F1040) {
      return 1LL;
    }
  }

  sub_1002E6E9C();
  return (sub_1000B6578() || !a1[197] && !a1[198]) && !a1[199] && a1[204] == 0;
}

void sub_1004492F4(id a1)
{
  uint64_t v1 = sub_1002E6E00();
  sub_10002418C(buf, "LE");
  sub_10002418C(__p, "AllowConnScanPrioritizationAlways");
  int v2 = (*(uint64_t (**)(uint64_t, _BYTE *, void **, char *))(*(void *)v1 + 72LL))( v1,  buf,  __p,  &byte_1008F1040);
  if (v6 < 0) {
    operator delete(__p[0]);
  }
  if (v8 < 0)
  {
    operator delete(*(void **)buf);
    if (!v2) {
      return;
    }
  }

  else if (!v2)
  {
    return;
  }

  double v3 = (os_log_s *)qword_1008F7758;
  if (os_log_type_enabled((os_log_t)qword_1008F7758, OS_LOG_TYPE_DEFAULT))
  {
    if (byte_1008F1040) {
      char v4 = "Yes";
    }
    else {
      char v4 = "No";
    }
    *(_DWORD *)std::string buf = 136315138;
    *(void *)&uint8_t buf[4] = v4;
    _os_log_impl( (void *)&_mh_execute_header,  v3,  OS_LOG_TYPE_DEFAULT,  "Warning: AllowConnScanPrioritizationAlways: %s",  buf,  0xCu);
  }

void sub_100449428( _Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void *__p, uint64_t a11, int a12, __int16 a13, char a14, char a15, void *a16, uint64_t a17, int a18, __int16 a19, char a20, char a21)
{
  if (a15 < 0) {
    operator delete(__p);
  }
  if (a21 < 0) {
    operator delete(a16);
  }
  _Unwind_Resume(exception_object);
}

BOOL sub_100449464(_BYTE *a1)
{
  return a1[197] || a1[198] || a1[200] || a1[204] != 0;
}

BOOL sub_100449494(uint64_t a1)
{
  if (!*(_BYTE *)(a1 + 197) && !*(_BYTE *)(a1 + 198)) {
    return 0LL;
  }
  if (qword_1008D6170 != -1) {
    dispatch_once(&qword_1008D6170, &stru_100899120);
  }
  return sub_100259094(qword_1008D6168);
}

uint64_t sub_1004494F0()
{
  if (qword_1008D5F50 != -1) {
    dispatch_once(&qword_1008D5F50, &stru_100899140);
  }
  int v0 = sub_100401FDC((uint64_t)off_1008D5F48);
  if (qword_1008D5F30 != -1) {
    dispatch_once(&qword_1008D5F30, &stru_100899080);
  }
  int v1 = sub_1005D8A0C((uint64_t)off_1008D5F28);
  if (v1) {
    unsigned int v2 = 3;
  }
  else {
    unsigned int v2 = 1;
  }
  if (v0) {
    return v2;
  }
  else {
    return 2 * (v1 != 0);
  }
}

void sub_100449590(uint64_t a1, uint64_t a2, int a3, int a4, int a5)
{
  if (*(_BYTE *)a2)
  {
    int v9 = *(_DWORD *)(a2 + 20) + a4;
    *(_DWORD *)(a2 + 16) += a3;
    *(_DWORD *)(a2 + 2sub_100414D2C(qword_1008F72C0, 0) = v9;
    *(_DWORD *)(a2 + 28) += a5;
  }

  *(_BYTE *)a2 = 1;
  id v10 = (os_log_s *)qword_1008F7758;
  if (os_log_type_enabled((os_log_t)qword_1008F7758, OS_LOG_TYPE_DEBUG))
  {
    sub_1004496CC((unsigned __int8 *)a2, &__p);
    if ((__p.__r_.__value_.__s.__size_ & 0x80u) == 0) {
      p_p = &__p;
    }
    else {
      p_p = (std::stringbuf::string_type *)__p.__r_.__value_.__r.__words[0];
    }
    *(_DWORD *)std::string buf = 67109890;
    int v14 = a3;
    __int16 v15 = 1024;
    int v16 = a4;
    __int16 v17 = 1024;
    int v18 = a5;
    __int16 v19 = 2080;
    int v20 = p_p;
    _os_log_debug_impl( (void *)&_mh_execute_header,  v10,  OS_LOG_TYPE_DEBUG,  "updateActualRxForRequest totalRx:%d btMCRx:%d duration:%d rxThreshold:%s",  buf,  0x1Eu);
  }

uint64_t sub_1004496CC@<X0>(unsigned __int8 *a1@<X0>, std::stringbuf::string_type *a2@<X8>)
{
  uint64_t v32 = 0LL;
  __int128 v30 = 0u;
  memset(v31, 0, sizeof(v31));
  *(_OWORD *)std::stringbuf::string_type __p = 0u;
  __int128 v29 = 0u;
  memset(v27, 0, sizeof(v27));
  sub_10020E564((uint64_t)v27);
  int v4 = (char)a1[55];
  if (v4 >= 0) {
    uint64_t v5 = (uint64_t)(a1 + 32);
  }
  else {
    uint64_t v5 = *((void *)a1 + 4);
  }
  if (v4 >= 0) {
    uint64_t v6 = a1[55];
  }
  else {
    uint64_t v6 = *((void *)a1 + 5);
  }
  id v7 = sub_1001FD17C(v27, v5, v6);
  char v8 = sub_1001FD17C(v7, (uint64_t)"(", 1LL);
  int v9 = sub_10044CB4C(*((_DWORD *)a1 + 1));
  size_t v10 = strlen(v9);
  uint64_t v11 = sub_1001FD17C(v8, (uint64_t)v9, v10);
  char v12 = sub_1001FD17C(v11, (uint64_t)") Scanning:", 11LL);
  char v13 = (void *)std::ostream::operator<<(v12, *a1);
  sub_1001FD17C(v13, (uint64_t)" ", 1LL);
  int v14 = sub_1001FD17C(v27, (uint64_t)"[totalRx=", 9LL);
  __int16 v15 = (void *)std::ostream::operator<<(v14, *((unsigned int *)a1 + 2));
  sub_1001FD17C(v15, (uint64_t)" ", 1LL);
  int v16 = sub_1001FD17C(v27, (uint64_t)"btMCRx=", 7LL);
  __int16 v17 = (void *)std::ostream::operator<<(v16, *((unsigned int *)a1 + 3));
  sub_1001FD17C(v17, (uint64_t)" ", 1LL);
  int v18 = sub_1001FD17C(v27, (uint64_t)"actualTotalRx=", 14LL);
  __int16 v19 = (void *)std::ostream::operator<<(v18, *((unsigned int *)a1 + 4));
  sub_1001FD17C(v19, (uint64_t)" ", 1LL);
  int v20 = sub_1001FD17C(v27, (uint64_t)"actualBtMCRx=", 13LL);
  __int16 v21 = (void *)std::ostream::operator<<(v20, *((unsigned int *)a1 + 5));
  sub_1001FD17C(v21, (uint64_t)" ", 1LL);
  __int16 v22 = sub_1001FD17C(v27, (uint64_t)"timeout=", 8LL);
  __int16 v23 = (void *)std::ostream::operator<<(v22, *((unsigned int *)a1 + 6));
  sub_1001FD17C(v23, (uint64_t)" ", 1LL);
  int v24 = sub_1001FD17C(v27, (uint64_t)"actualTime=", 11LL);
  uint64_t v25 = (void *)std::ostream::operator<<(v24, *((unsigned int *)a1 + 7));
  sub_1001FD17C(v25, (uint64_t)"] ", 2LL);
  std::stringbuf::str(a2, (const std::stringbuf *)((char *)v27 + 8));
  if (SHIBYTE(v29) < 0) {
    operator delete(__p[1]);
  }
  std::streambuf::~streambuf((char *)v27 + 8);
  return std::ios::~ios(v31);
}

void sub_100449930( _Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9)
{
}

uint64_t sub_100449944(uint64_t a1)
{
  v16[0] = 0LL;
  v16[1] = 0LL;
  sub_100242F28((uint64_t)v16, a1 + 40);
  unsigned int v2 = (os_log_s *)qword_1008F7758;
  BOOL v3 = os_log_type_enabled((os_log_t)qword_1008F7758, OS_LOG_TYPE_INFO);
  if (v3)
  {
    int v4 = *(_DWORD *)(a1 + 344);
    int v5 = *(_DWORD *)(a1 + 348);
    int v6 = *(_DWORD *)(a1 + 356);
    int v7 = *(_DWORD *)(a1 + 360);
    *(_DWORD *)std::string buf = 67109888;
    int v18 = v4;
    __int16 v19 = 1024;
    int v20 = v5;
    __int16 v21 = 1024;
    int v22 = v6;
    __int16 v23 = 1024;
    int v24 = v7;
    _os_log_impl( (void *)&_mh_execute_header,  v2,  OS_LOG_TYPE_INFO,  "updateActualRx fLastScan: TotalRx=%u BtMCRx=%u fLastConnectionScan: TotalRx=%u BtMCRx=%u",  buf,  0x1Au);
  }

  char v8 = *(void **)(a1 + 224);
  if (v8 != (void *)(a1 + 232))
  {
    do
    {
      sub_100449590(v3, (uint64_t)(v8 + 5), *(_DWORD *)(a1 + 344), *(_DWORD *)(a1 + 348), *(_DWORD *)(a1 + 352));
      int v9 = (void *)v8[1];
      if (v9)
      {
        do
        {
          size_t v10 = v9;
          int v9 = (void *)*v9;
        }

        while (v9);
      }

      else
      {
        do
        {
          size_t v10 = (void *)v8[2];
          BOOL v11 = *v10 == (void)v8;
          char v8 = v10;
        }

        while (!v11);
      }

      char v8 = v10;
    }

    while (v10 != (void *)(a1 + 232));
  }

  char v12 = *(void **)(a1 + 248);
  if (v12 != (void *)(a1 + 256))
  {
    do
    {
      sub_100449590(v3, (uint64_t)(v12 + 7), *(_DWORD *)(a1 + 356), *(_DWORD *)(a1 + 360), *(_DWORD *)(a1 + 364));
      char v13 = (void *)v12[1];
      if (v13)
      {
        do
        {
          int v14 = v13;
          char v13 = (void *)*v13;
        }

        while (v13);
      }

      else
      {
        do
        {
          int v14 = (void *)v12[2];
          BOOL v11 = *v14 == (void)v12;
          char v12 = v14;
        }

        while (!v11);
      }

      char v12 = v14;
    }

    while (v14 != (void *)(a1 + 256));
  }

  *(void *)(a1 + 344) = 0LL;
  *(void *)(a1 + 352) = 0LL;
  *(void *)(a1 + 36sub_100414D2C(qword_1008F72C0, 0) = 0LL;
  return sub_100242FAC((uint64_t)v16);
}

void sub_100449AEC(_Unwind_Exception *exception_object)
{
}

uint64_t sub_100449B0C(uint64_t a1, uint64_t a2, __int128 *a3, uint64_t a4)
{
  if (*(_BYTE *)(a4 + 1))
  {
    int v7 = (os_log_s *)qword_1008F7758;
    if (os_log_type_enabled((os_log_t)qword_1008F7758, OS_LOG_TYPE_INFO))
    {
      sub_1004496CC((unsigned __int8 *)a4, &__p);
      char v8 = (__p.__r_.__value_.__s.__size_ & 0x80u) == 0
         ? &__p
         : (std::stringbuf::string_type *)__p.__r_.__value_.__r.__words[0];
      *(_DWORD *)std::string buf = 136315138;
      int v26 = v8;
      _os_log_impl((void *)&_mh_execute_header, v7, OS_LOG_TYPE_INFO, "%s was cancelled , notifying", buf, 0xCu);
    }

    uint64_t v9 = *(void *)(a4 + 64);
    if (v9) {
      (*(void (**)(uint64_t, uint64_t, void, void, void, uint64_t))(v9 + 16))( v9,  a2,  *(unsigned int *)(a4 + 16),  *(unsigned int *)(a4 + 20),  *(unsigned int *)(a4 + 28),  2LL);
    }
    uint64_t v10 = *(void *)(a4 + 72);
    if (!v10) {
      return 1LL;
    }
    if (*((char *)a3 + 23) < 0)
    {
      sub_100024238(&__dst, *(void **)a3, *((void *)a3 + 1));
    }

    else
    {
      __int128 __dst = *a3;
      uint64_t v23 = *((void *)a3 + 2);
    }

    (*(void (**)(uint64_t, __int128 *, void, void, void, uint64_t))(v10 + 16))( v10,  &__dst,  *(unsigned int *)(a4 + 16),  *(unsigned int *)(a4 + 20),  *(unsigned int *)(a4 + 28),  2LL);
    if ((SHIBYTE(v23) & 0x80000000) == 0) {
      return 1LL;
    }
    p_uuid_t dst = (void **)&__dst;
    goto LABEL_37;
  }

  unsigned int v11 = *(_DWORD *)(a4 + 8);
  if (!v11 || v11 > *(_DWORD *)(a4 + 16))
  {
    unsigned int v12 = *(_DWORD *)(a4 + 12);
    if (!v12 || v12 > *(_DWORD *)(a4 + 20))
    {
      unsigned int v13 = *(_DWORD *)(a4 + 24);
      if (!v13 || v13 > *(_DWORD *)(a4 + 28)) {
        return 0LL;
      }
    }
  }

  __int16 v15 = (os_log_s *)qword_1008F7758;
  if (os_log_type_enabled((os_log_t)qword_1008F7758, OS_LOG_TYPE_INFO))
  {
    sub_1004496CC((unsigned __int8 *)a4, &__p);
    int v16 = (__p.__r_.__value_.__s.__size_ & 0x80u) == 0
        ? &__p
        : (std::stringbuf::string_type *)__p.__r_.__value_.__r.__words[0];
    *(_DWORD *)std::string buf = 136315138;
    int v26 = v16;
    _os_log_impl((void *)&_mh_execute_header, v15, OS_LOG_TYPE_INFO, "%s has completed, notifying", buf, 0xCu);
  }

  uint64_t v17 = *(void *)(a4 + 64);
  if (v17) {
    (*(void (**)(uint64_t, uint64_t, void, void, void, uint64_t))(v17 + 16))( v17,  a2,  *(unsigned int *)(a4 + 16),  *(unsigned int *)(a4 + 20),  *(unsigned int *)(a4 + 28),  1LL);
  }
  uint64_t v18 = *(void *)(a4 + 72);
  if (v18)
  {
    if (*((char *)a3 + 23) < 0)
    {
      sub_100024238(&v20, *(void **)a3, *((void *)a3 + 1));
    }

    else
    {
      __int128 v20 = *a3;
      uint64_t v21 = *((void *)a3 + 2);
    }

    (*(void (**)(uint64_t, __int128 *, void, void, void, uint64_t))(v18 + 16))( v18,  &v20,  *(unsigned int *)(a4 + 16),  *(unsigned int *)(a4 + 20),  *(unsigned int *)(a4 + 28),  1LL);
    if (SHIBYTE(v21) < 0)
    {
      p_uuid_t dst = (void **)&v20;
LABEL_37:
      operator delete(*p_dst);
    }
  }

  return 1LL;
}

void sub_100449DC0( _Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, void *a9, uint64_t a10, int a11, __int16 a12, char a13, char a14, uint64_t a15, char a16, uint64_t a17, int a18, __int16 a19, char a20, char a21)
{
  if (a14 < 0) {
    operator delete(a9);
  }
  _Unwind_Resume(exception_object);
}

uint64_t sub_100449DFC(uint64_t a1)
{
  v58[0] = 0LL;
  v58[1] = 0LL;
  sub_100242F28((uint64_t)v58, a1 + 40);
  unsigned int v2 = (os_log_s *)qword_1008F7758;
  if (os_log_type_enabled((os_log_t)qword_1008F7758, OS_LOG_TYPE_INFO))
  {
    uint64_t v3 = *(void *)(a1 + 240);
    uint64_t v4 = *(void *)(a1 + 264);
    int v5 = *(unsigned __int8 *)(a1 + 104);
    *(_DWORD *)std::string buf = 134218496;
    *(void *)&uint8_t buf[4] = v3;
    *(_WORD *)&_BYTE buf[12] = 2048;
    *(void *)&_BYTE buf[14] = v4;
    *(_WORD *)&_BYTE buf[22] = 1024;
    int v61 = v5;
    _os_log_impl( (void *)&_mh_execute_header,  v2,  OS_LOG_TYPE_INFO,  "checkForExpired fSessionThresholds:%lu fConnectScanThresholds:%lu fStackStarted:%d",  buf,  0x1Cu);
  }

  if (!*(_BYTE *)(a1 + 104)) {
    return sub_100242FAC((uint64_t)v58);
  }
  memset(buf, 0, sizeof(buf));
  int v6 = *(void **)(a1 + 224);
  __int128 v55 = 0LL;
  int v56 = 0LL;
  unint64_t v57 = 0LL;
  if (v6 == (void *)(a1 + 232)) {
    goto LABEL_40;
  }
  do
  {
    uint64_t v7 = v6[4];
    sub_10002418C(v53, "");
    __int128 v8 = *(_OWORD *)(v6 + 7);
    v47[0] = *(_OWORD *)(v6 + 5);
    v47[1] = v8;
    if (*((char *)v6 + 95) < 0)
    {
      sub_100024238(&__p, (void *)v6[9], v6[10]);
    }

    else
    {
      __int128 __p = *(_OWORD *)(v6 + 9);
      uint64_t v49 = v6[11];
    }

    int v50 = *((_DWORD *)v6 + 24);
    id v51 = objc_retainBlock((id)v6[13]);
    id v52 = objc_retainBlock((id)v6[14]);
    int v9 = sub_100449B0C((uint64_t)v52, v7, (__int128 *)v53, (uint64_t)v47);

    if (SHIBYTE(v49) < 0) {
      operator delete((void *)__p);
    }
    if (v54 < 0)
    {
      operator delete(v53[0]);
      if (!v9) {
        goto LABEL_31;
      }
    }

    else if (!v9)
    {
      goto LABEL_31;
    }

    uint64_t v10 = *(void *)&buf[8];
    if (*(void *)&buf[8] >= *(void *)&buf[16])
    {
      uint64_t v12 = (uint64_t)(*(void *)&buf[8] - *(void *)buf) >> 3;
      unint64_t v13 = (uint64_t)(*(void *)&buf[16] - *(void *)buf) >> 2;
      if (v13 <= v12 + 1) {
        unint64_t v13 = v12 + 1;
      }
      if (*(void *)&buf[16] - *(void *)buf >= 0x7FFFFFFFFFFFFFF8uLL) {
        unint64_t v14 = 0x1FFFFFFFFFFFFFFFLL;
      }
      else {
        unint64_t v14 = v13;
      }
      if (v14) {
        __int16 v15 = (char *)sub_100008BA0((uint64_t)&buf[16], v14);
      }
      else {
        __int16 v15 = 0LL;
      }
      int v16 = &v15[8 * v12];
      *(void *)int v16 = v6[4];
      unsigned int v11 = v16 + 8;
      uint64_t v18 = *(char **)buf;
      uint64_t v17 = *(char **)&buf[8];
      if (*(void *)&buf[8] != *(void *)buf)
      {
        do
        {
          uint64_t v19 = *((void *)v17 - 1);
          v17 -= 8;
          *((void *)v16 - 1) = v19;
          v16 -= 8;
        }

        while (v17 != v18);
        uint64_t v17 = *(char **)buf;
      }

      *(void *)std::string buf = v16;
      *(void *)&uint8_t buf[8] = v11;
      *(void *)&uint8_t buf[16] = &v15[8 * v14];
      if (v17) {
        operator delete(v17);
      }
    }

    else
    {
      **(void **)&uint8_t buf[8] = v6[4];
      unsigned int v11 = (void *)(v10 + 8);
    }

    *(void *)&uint8_t buf[8] = v11;
LABEL_31:
    __int128 v20 = (void *)v6[1];
    if (v20)
    {
      do
      {
        uint64_t v21 = v20;
        __int128 v20 = (void *)*v20;
      }

      while (v20);
    }

    else
    {
      do
      {
        uint64_t v21 = (void *)v6[2];
        BOOL v22 = *v21 == (void)v6;
        int v6 = v21;
      }

      while (!v22);
    }

    int v6 = v21;
  }

  while (v21 != (void *)(a1 + 232));
  uint64_t v23 = *(unint64_t **)buf;
  int v24 = *(unint64_t **)&buf[8];
  while (v23 != v24)
    sub_10044E0FC(a1 + 224, v23++);
LABEL_40:
  uint64_t v27 = *(uint64_t ***)(a1 + 248);
  uint64_t v25 = (uint64_t **)(a1 + 248);
  int v26 = v27;
  if (v27 != v25 + 1)
  {
    while (2)
    {
      int v28 = v26 + 4;
      if (*((char *)v26 + 55) < 0)
      {
        sub_100024238(__dst, v26[4], (unint64_t)v26[5]);
      }

      else
      {
        *(_OWORD *)__int128 __dst = *v28;
        unsigned int v46 = v26[6];
      }

      __int128 v29 = *(_OWORD *)(v26 + 9);
      v39[0] = *(_OWORD *)(v26 + 7);
      v39[1] = v29;
      if (*((char *)v26 + 111) < 0)
      {
        sub_100024238(&v40, v26[11], (unint64_t)v26[12]);
      }

      else
      {
        __int128 v40 = *(_OWORD *)(v26 + 11);
        unsigned int v41 = v26[13];
      }

      int v42 = *((_DWORD *)v26 + 28);
      __int128 v43 = objc_retainBlock(v26[15]);
      unsigned __int16 v44 = objc_retainBlock(v26[16]);
      int v30 = sub_100449B0C((uint64_t)v44, 0LL, (__int128 *)__dst, (uint64_t)v39);

      if (SHIBYTE(v41) < 0) {
        operator delete((void *)v40);
      }
      if (SHIBYTE(v46) < 0)
      {
        operator delete(__dst[0]);
        if (!v30) {
          goto LABEL_60;
        }
      }

      else if (!v30)
      {
        goto LABEL_60;
      }

      BOOL v31 = v56;
      if ((unint64_t)v56 >= v57)
      {
        CFErrorRef v33 = sub_10023EFAC((char **)&v55, (__int128 *)v26 + 2);
      }

      else
      {
        if (*((char *)v26 + 55) < 0)
        {
          sub_100024238(v56, v26[4], (unint64_t)v26[5]);
        }

        else
        {
          __int128 v32 = *v28;
          *((void *)v56 + 2) = v26[6];
          *BOOL v31 = v32;
        }

        CFErrorRef v33 = (char *)v31 + 24;
      }

      int v56 = v33;
LABEL_60:
      int v34 = v26[1];
      if (v34)
      {
        do
        {
          int v35 = (uint64_t **)v34;
          int v34 = (uint64_t *)*v34;
        }

        while (v34);
      }

      else
      {
        do
        {
          int v35 = (uint64_t **)v26[2];
          BOOL v22 = *v35 == (uint64_t *)v26;
          int v26 = v35;
        }

        while (!v22);
      }

      int v26 = v35;
      if (v35 == v25 + 1) {
        break;
      }
      continue;
    }
  }

  unsigned int v36 = v55;
  __int16 v37 = (const void **)v56;
  while (v36 != v37)
  {
    sub_10044E180(v25, v36);
    v36 += 3;
  }

  __int128 v59 = (char **)&v55;
  sub_100024304((void ***)&v59);
  if (*(void *)buf)
  {
    *(void *)&uint8_t buf[8] = *(void *)buf;
    operator delete(*(void **)buf);
  }

  return sub_100242FAC((uint64_t)v58);
}

void sub_10044A2B8( _Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, void *__p, uint64_t a20, int a21, __int16 a22, char a23, char a24, uint64_t a25, char a26, uint64_t a27, uint64_t a28, uint64_t a29, uint64_t a30, uint64_t a31, uint64_t a32, uint64_t a33, uint64_t a34, uint64_t a35, uint64_t a36, uint64_t a37, uint64_t a38, int a39, __int16 a40, char a41, char a42)
{
  *(void *)(v43 - 184) = v42;
  *(void *)(v43 - 152) = v43 - 192;
  sub_100024304((void ***)(v43 - 152));
  __int16 v45 = *(void **)(v43 - 144);
  if (v45)
  {
    *(void *)(v43 - 136) = v45;
    operator delete(v45);
  }

  sub_100242FAC(v43 - 168);
  _Unwind_Resume(a1);
}

uint64_t sub_10044A35C(uint64_t a1)
{
  return a1;
}

uint64_t sub_10044A39C(uint64_t a1, uint64_t a2, unsigned int *a3, unsigned int *a4, unsigned int *a5)
{
  int v6 = *(_DWORD *)(a2 + 24);
  int v8 = *(_DWORD *)(a2 + 8);
  int v7 = *(_DWORD *)(a2 + 12);
  if (v8) {
    BOOL v9 = 0;
  }
  else {
    BOOL v9 = v6 == 0;
  }
  if (v9 && v7 == 0)
  {
    __int128 v32 = (os_log_s *)qword_1008F7758;
    if (os_log_type_enabled((os_log_t)qword_1008F7758, OS_LOG_TYPE_INFO))
    {
      int v35 = *(std::stringbuf::string_type **)(a2 + 32);
      int v34 = (std::stringbuf::string_type *)(a2 + 32);
      CFErrorRef v33 = v35;
      if ((v34->__r_.__value_.__s.__size_ & 0x80u) == 0) {
        CFErrorRef v33 = v34;
      }
      *(_DWORD *)std::string buf = 136315138;
      int v39 = v33;
      _os_log_impl( (void *)&_mh_execute_header,  v32,  OS_LOG_TYPE_INFO,  "%s ignoring invalid threshold request for minimum calculation",  buf,  0xCu);
    }

    return 0LL;
  }

  else
  {
    if (v8) {
      unsigned int v14 = v8 - *(_DWORD *)(a2 + 16);
    }
    else {
      unsigned int v14 = 0;
    }
    if (v7) {
      unsigned int v15 = v7 - *(_DWORD *)(a2 + 20);
    }
    else {
      unsigned int v15 = 0;
    }
    if (v6) {
      unsigned int v16 = v6 - *(_DWORD *)(a2 + 28);
    }
    else {
      unsigned int v16 = 0;
    }
    uint64_t v17 = (os_log_s *)qword_1008F7758;
    if (os_log_type_enabled((os_log_t)qword_1008F7758, OS_LOG_TYPE_INFO))
    {
      sub_1004496CC((unsigned __int8 *)a2, &__p);
      if ((__p.__r_.__value_.__s.__size_ & 0x80u) == 0) {
        p_p = &__p;
      }
      else {
        p_p = (std::stringbuf::string_type *)__p.__r_.__value_.__r.__words[0];
      }
      unsigned int v19 = *a3;
      unsigned int v20 = *a4;
      *(_DWORD *)std::string buf = 136316418;
      int v39 = p_p;
      __int16 v40 = 1024;
      unsigned int v41 = v14;
      __int16 v42 = 1024;
      unsigned int v43 = v15;
      __int16 v44 = 1024;
      unsigned int v45 = v19;
      __int16 v46 = 1024;
      unsigned int v47 = v20;
      __int16 v48 = 1024;
      unsigned int v49 = v16;
      _os_log_impl( (void *)&_mh_execute_header,  v17,  OS_LOG_TYPE_INFO,  "%s sessionTotalRxDelta=%u sessionBtMCRxDelta=%u totalRxDeltaMs=%u btMCRxDelta=%u sessionTimeoutDelta=%u",  buf,  0x2Au);
      int v6 = *(_DWORD *)(a2 + 24);
    }

    if (v6) {
      BOOL v21 = v16 == 0;
    }
    else {
      BOOL v21 = 1;
    }
    uint64_t v23 = !v21 && v16 < *a5;
    if ((_DWORD)v23 == 1)
    {
      *a5 = v16;
      int v24 = (os_log_s *)qword_1008F7758;
      if (os_log_type_enabled((os_log_t)qword_1008F7758, OS_LOG_TYPE_INFO))
      {
        uint64_t v25 = (std::stringbuf::string_type *)(a2 + 32);
        *(_DWORD *)std::string buf = 136315394;
        int v39 = v25;
        __int16 v40 = 1024;
        unsigned int v41 = v16;
        _os_log_impl((void *)&_mh_execute_header, v24, OS_LOG_TYPE_INFO, "%s set new minimal timeout=%u", buf, 0x12u);
      }
    }

    if (*(_DWORD *)(a2 + 8))
    {
      if (v14)
      {
        if (*a3 > v14)
        {
          *a3 = v14;
          int v26 = (os_log_s *)qword_1008F7758;
          uint64_t v23 = 1LL;
          if (os_log_type_enabled((os_log_t)qword_1008F7758, OS_LOG_TYPE_INFO))
          {
            uint64_t v27 = (std::stringbuf::string_type *)(a2 + 32);
            *(_DWORD *)std::string buf = 136315394;
            int v39 = v27;
            __int16 v40 = 1024;
            unsigned int v41 = v14;
            _os_log_impl( (void *)&_mh_execute_header,  v26,  OS_LOG_TYPE_INFO,  "%s set new minimal totalRxDeltaMs=%u",  buf,  0x12u);
          }
        }
      }
    }

    if (*(_DWORD *)(a2 + 12))
    {
      if (v15)
      {
        if (*a4 > v15)
        {
          *a4 = v15;
          int v28 = (os_log_s *)qword_1008F7758;
          uint64_t v23 = 1LL;
          if (os_log_type_enabled((os_log_t)qword_1008F7758, OS_LOG_TYPE_INFO))
          {
            BOOL v31 = *(std::stringbuf::string_type **)(a2 + 32);
            int v30 = (std::stringbuf::string_type *)(a2 + 32);
            __int128 v29 = v31;
            if ((v30->__r_.__value_.__s.__size_ & 0x80u) == 0) {
              __int128 v29 = v30;
            }
            *(_DWORD *)std::string buf = 136315394;
            int v39 = v29;
            __int16 v40 = 1024;
            unsigned int v41 = v15;
            _os_log_impl( (void *)&_mh_execute_header,  v28,  OS_LOG_TYPE_INFO,  "%s set new minimal btMCRxDeltaMs=%u",  buf,  0x12u);
          }
        }
      }
    }
  }

  return v23;
}

BOOL sub_10044A714(uint64_t a1, uint64_t a2)
{
  if (*(_BYTE *)(a1 + 376)) {
    return 1LL;
  }
  if (*(_DWORD *)(a2 + 4)) {
    BOOL v6 = *(void *)(a2 + 64) == 0LL;
  }
  else {
    BOOL v6 = 1;
  }
  if (v6) {
    goto LABEL_13;
  }
  uint64_t v13 = 0LL;
  *(_OWORD *)std::stringbuf::string_type __p = 0u;
  __int128 v12 = 0u;
  __int128 v10 = 0u;
  memset(v9, 0, sizeof(v9));
  if (qword_1008D6608 != -1) {
    dispatch_once(&qword_1008D6608, &stru_100899160);
  }
  sub_1005E0630((uint64_t)off_1008D6600, *(_DWORD *)(a2 + 4), (uint64_t)v9);
  int v7 = BYTE8(v9[0]);
  uint64_t v2 = BYTE7(v9[0]) != 0;
  if (__p[1])
  {
    *(void **)&__int128 v12 = __p[1];
    operator delete(__p[1]);
  }

  unsigned int v14 = (void **)&v10;
  sub_10004FEA4(&v14);
  if (!v7)
  {
LABEL_13:
    switch(*(_DWORD *)(a2 + 56))
    {
      case 1:
        goto LABEL_32;
      case 2:
        goto LABEL_37;
      case 3:
        if (*(_BYTE *)(a1 + 197) || *(_BYTE *)(a1 + 198) || *(_BYTE *)(a1 + 200)) {
          return 1LL;
        }
        return *(_BYTE *)(a1 + 204) != 0;
      case 4:
        if (!*(_BYTE *)(a1 + 197) && !*(_BYTE *)(a1 + 198) && !*(_BYTE *)(a1 + 200) && !*(_BYTE *)(a1 + 204)) {
          goto LABEL_27;
        }
        goto LABEL_32;
      case 5:
        if (!*(_BYTE *)(a1 + 197) && !*(_BYTE *)(a1 + 198) && !*(_BYTE *)(a1 + 200) && !*(_BYTE *)(a1 + 204)) {
          goto LABEL_27;
        }
        goto LABEL_37;
      case 6:
        if (*(_BYTE *)(a1 + 197) || *(_BYTE *)(a1 + 198) || *(_BYTE *)(a1 + 200) || *(_BYTE *)(a1 + 204)) {
          return 1LL;
        }
LABEL_32:
        uint64_t v2 = *(_DWORD *)(a1 + 276) == 1;
        break;
      case 7:
        if (*(_BYTE *)(a1 + 197) || *(_BYTE *)(a1 + 198) || *(_BYTE *)(a1 + 200) || *(_BYTE *)(a1 + 204)) {
          return 1LL;
        }
LABEL_37:
        uint64_t v8 = sub_1002E8EE8();
        uint64_t v2 = (*(uint64_t (**)(uint64_t))(*(void *)v8 + 96LL))(v8);
        break;
      default:
LABEL_27:
        uint64_t v2 = 0LL;
        break;
    }
  }

  return v2;
}

uint64_t sub_10044A918(uint64_t a1)
{
  v53[0] = 0LL;
  v53[1] = 0LL;
  sub_100242F28((uint64_t)v53, a1 + 40);
  uint64_t v2 = (os_log_s *)qword_1008F7758;
  if (os_log_type_enabled((os_log_t)qword_1008F7758, OS_LOG_TYPE_INFO))
  {
    uint64_t v3 = *(void *)(a1 + 240);
    uint64_t v4 = *(void *)(a1 + 264);
    int v5 = *(unsigned __int8 *)(a1 + 104);
    *(_DWORD *)std::string buf = 134218496;
    *(void *)&uint8_t buf[4] = v3;
    *(_WORD *)&_BYTE buf[12] = 2048;
    uint64_t v55 = v4;
    *(_WORD *)int v56 = 1024;
    *(_DWORD *)&v56[2] = v5;
    _os_log_impl( (void *)&_mh_execute_header,  v2,  OS_LOG_TYPE_INFO,  "configureNextThreshold fDiscoveryScanThresholds:%lu fConnectScanThresholds:%lu fStackStarted:%d",  buf,  0x1Cu);
  }

  if (*(_BYTE *)(a1 + 104))
  {
    unsigned int v51 = -1;
    unsigned int v52 = -1;
    unsigned int v49 = -1;
    unsigned int v50 = -1;
    unsigned int v48 = -1;
    BOOL v6 = *(void **)(a1 + 224);
    if (v6 == (void *)(a1 + 232))
    {
      char v7 = 0;
    }

    else
    {
      char v7 = 0;
      do
      {
        BOOL v8 = sub_10044A714(a1, (uint64_t)(v6 + 5));
        if (v8 && !(*(unsigned __int8 *)(a1 + 320) | *((unsigned __int8 *)v6 + 41)))
        {
          int v9 = *((_DWORD *)v6 + 16);
          if (v9)
          {
            int v10 = *((_DWORD *)v6 + 13);
            if (v10 != v9)
            {
              if (v10)
              {
                *((_DWORD *)v6 + 12) = v9;
                *((_DWORD *)v6 + 13) = v9;
                unsigned int v11 = (os_log_s *)qword_1008F7758;
                char v7 = 1;
                BOOL v8 = os_log_type_enabled((os_log_t)qword_1008F7758, OS_LOG_TYPE_INFO);
                if (v8)
                {
                  sub_1004496CC((unsigned __int8 *)v6 + 40, (std::stringbuf::string_type *)buf);
                  __int128 v12 = v56[1] >= 0 ? buf : *(_BYTE **)buf;
                  *(_DWORD *)std::string v68 = 136315138;
                  __int128 v69 = v12;
                  _os_log_impl( (void *)&_mh_execute_header,  v11,  OS_LOG_TYPE_INFO,  "New coex actuals for scanRequest %s",  v68,  0xCu);
                  if ((v56[1] & 0x80000000) != 0) {
                    operator delete(*(void **)buf);
                  }
                }
              }
            }
          }
        }

        char v13 = sub_10044A39C(v8, (uint64_t)(v6 + 5), &v52, &v51, &v48);
        unsigned int v14 = (void *)v6[1];
        if (v14)
        {
          do
          {
            unsigned int v15 = v14;
            unsigned int v14 = (void *)*v14;
          }

          while (v14);
        }

        else
        {
          do
          {
            unsigned int v15 = (void *)v6[2];
            BOOL v16 = *v15 == (void)v6;
            BOOL v6 = v15;
          }

          while (!v16);
        }

        v7 |= v13;
        BOOL v6 = v15;
      }

      while (v15 != (void *)(a1 + 232));
    }

    uint64_t v17 = *(void **)(a1 + 248);
    if (v17 != (void *)(a1 + 256))
    {
      do
      {
        BOOL v18 = sub_10044A714(a1, (uint64_t)(v17 + 7));
        if (v18 && !(*(unsigned __int8 *)(a1 + 320) | *((unsigned __int8 *)v17 + 57)))
        {
          int v19 = *((_DWORD *)v17 + 20);
          if (v19)
          {
            int v20 = *((_DWORD *)v17 + 17);
            if (v20 != v19)
            {
              if (v20)
              {
                *((_DWORD *)v17 + 16) = v19;
                *((_DWORD *)v17 + 17) = v19;
                BOOL v21 = (os_log_s *)qword_1008F7758;
                char v7 = 1;
                BOOL v18 = os_log_type_enabled((os_log_t)qword_1008F7758, OS_LOG_TYPE_INFO);
                if (v18)
                {
                  sub_1004496CC((unsigned __int8 *)v17 + 56, (std::stringbuf::string_type *)buf);
                  BOOL v22 = v56[1] >= 0 ? buf : *(_BYTE **)buf;
                  *(_DWORD *)std::string v68 = 136315138;
                  __int128 v69 = v22;
                  _os_log_impl( (void *)&_mh_execute_header,  v21,  OS_LOG_TYPE_INFO,  "New coex actuals for connection %s",  v68,  0xCu);
                  if ((v56[1] & 0x80000000) != 0) {
                    operator delete(*(void **)buf);
                  }
                }
              }
            }
          }
        }

        char v23 = sub_10044A39C(v18, (uint64_t)(v17 + 7), &v50, &v49, &v48);
        int v24 = (void *)v17[1];
        if (v24)
        {
          do
          {
            uint64_t v25 = v24;
            int v24 = (void *)*v24;
          }

          while (v24);
        }

        else
        {
          do
          {
            uint64_t v25 = (void *)v17[2];
            BOOL v16 = *v25 == (void)v17;
            uint64_t v17 = v25;
          }

          while (!v16);
        }

        v7 |= v23;
        uint64_t v17 = v25;
      }

      while (v25 != (void *)(a1 + 256));
    }

    if (*(_BYTE *)(a1 + 320))
    {
      if (v52 == -1) {
        unsigned int v26 = 0;
      }
      else {
        unsigned int v26 = v52;
      }
      unsigned int v27 = v51;
      if (v51 == -1) {
        unsigned int v27 = 0;
      }
      unsigned int v51 = v27;
      unsigned int v52 = v26;
      if (v50 == -1) {
        unsigned int v28 = 0;
      }
      else {
        unsigned int v28 = v50;
      }
      unsigned int v29 = v49;
      if (v49 == -1) {
        unsigned int v29 = 0;
      }
      unsigned int v49 = v29;
      unsigned int v50 = v28;
      unsigned int v30 = v48;
      if (v48 == -1) {
        unsigned int v30 = 0;
      }
      unsigned int v48 = v30;
    }

    BOOL v31 = (os_log_s *)qword_1008F7758;
    if (os_log_type_enabled((os_log_t)qword_1008F7758, OS_LOG_TYPE_INFO))
    {
      *(_DWORD *)std::string buf = 67109120;
      *(_DWORD *)&uint8_t buf[4] = v7 & 1;
      _os_log_impl((void *)&_mh_execute_header, v31, OS_LOG_TYPE_INFO, "configChanged=%d deltas:", buf, 8u);
      BOOL v31 = (os_log_s *)qword_1008F7758;
    }

    if (os_log_type_enabled(v31, OS_LOG_TYPE_INFO))
    {
      *(_DWORD *)std::string buf = 67109376;
      *(_DWORD *)&uint8_t buf[4] = v52;
      *(_WORD *)&uint8_t buf[8] = 1024;
      *(_DWORD *)&buf[10] = v51;
      _os_log_impl( (void *)&_mh_execute_header,  v31,  OS_LOG_TYPE_INFO,  "scanTotalRxDeltaMs=%u scanBtMCRxDeltaMs=%u",  buf,  0xEu);
      BOOL v31 = (os_log_s *)qword_1008F7758;
    }

    if (os_log_type_enabled(v31, OS_LOG_TYPE_INFO))
    {
      *(_DWORD *)std::string buf = 67109376;
      *(_DWORD *)&uint8_t buf[4] = v50;
      *(_WORD *)&uint8_t buf[8] = 1024;
      *(_DWORD *)&buf[10] = v49;
      _os_log_impl( (void *)&_mh_execute_header,  v31,  OS_LOG_TYPE_INFO,  "connectTotalRxDeltaMs=%u connectBtMCRxDeltaMs=%u",  buf,  0xEu);
    }

    if (*(void *)(a1 + 240) || *(void *)(a1 + 264))
    {
      if ((v7 & 1) == 0) {
        return sub_100242FAC((uint64_t)v53);
      }
    }

    else
    {
      *(void *)(a1 + 28_Block_object_dispose((const void *)(v2 - 88), 8) = 0LL;
      *(void *)(a1 + 296) = 0LL;
      if ((v7 & 1) == 0) {
        return sub_100242FAC((uint64_t)v53);
      }
    }

    *(void *)std::string buf = 0LL;
    sub_1000B0400((uint64_t)buf);
    int v32 = *(_DWORD *)buf;
    uint64_t v33 = *(__int16 *)&buf[4];
    *(void *)(a1 + 28_Block_object_dispose((const void *)(v2 - 88), 8) = *(int *)buf;
    *(void *)(a1 + 296) = v33;
    if (*(_BYTE *)(a1 + 320))
    {
      int v34 = (os_log_s *)qword_1008F7758;
      if (os_log_type_enabled((os_log_t)qword_1008F7758, OS_LOG_TYPE_DEFAULT))
      {
        *(_DWORD *)std::string buf = 134217984;
        *(void *)&uint8_t buf[4] = v33 + 1000LL * v32;
        _os_log_impl( (void *)&_mh_execute_header,  v34,  OS_LOG_TYPE_DEFAULT,  "configChanged! Configuring controller at time %llu",  buf,  0xCu);
        int v34 = (os_log_s *)qword_1008F7758;
      }

      if (os_log_type_enabled(v34, OS_LOG_TYPE_DEFAULT))
      {
        *(_DWORD *)std::string buf = 67111424;
        *(_DWORD *)&uint8_t buf[4] = 1;
        *(_WORD *)&uint8_t buf[8] = 1024;
        *(_DWORD *)&buf[10] = 0;
        LOWORD(v55) = 1024;
        *(_DWORD *)((char *)&v55 + 2) = v48;
        HIWORD(v55) = 1024;
        *(_DWORD *)int v56 = v52;
        *(_WORD *)&v56[4] = 1024;
        unsigned int v57 = v51;
        __int16 v58 = 1024;
        unsigned int v59 = v50;
        __int16 v60 = 1024;
        unsigned int v61 = v49;
        __int16 v62 = 1024;
        int v63 = 0;
        __int16 v64 = 1024;
        int v65 = 0;
        __int16 v66 = 1024;
        int v67 = 1;
        _os_log_impl( (void *)&_mh_execute_header,  v34,  OS_LOG_TYPE_DEFAULT,  "getScanStatsWithThreshold reset %u ver %u duration %u discovery %u %u conn %u %u numAdvs %u %u canWakeupAP %u",  buf,  0x3Eu);
      }

      uint64_t v35 = sub_1002E6E9C();
      uint64_t v36 = (*(uint64_t (**)(uint64_t, uint64_t, void, void, void, void, void, void, void, char))(*(void *)v35 + 3544LL))( v35,  1LL,  0LL,  v48,  v52,  v51,  v50,  v49,  0LL,  1);
      if ((_DWORD)v36)
      {
        __int16 v37 = (os_log_s *)qword_1008F7758;
        if (os_log_type_enabled((os_log_t)qword_1008F7758, OS_LOG_TYPE_ERROR)) {
          sub_100680334(v36, v37, v38, v39, v40, v41, v42, v43);
        }
      }
    }

    else
    {
      unsigned int v44 = v49;
      if (v49 >= v51) {
        unsigned int v44 = v51;
      }
      if (v48 >= v44) {
        unsigned int v45 = v44;
      }
      else {
        unsigned int v45 = v48;
      }
      __int16 v46 = (os_log_s *)qword_1008F7758;
      if (os_log_type_enabled((os_log_t)qword_1008F7758, OS_LOG_TYPE_INFO))
      {
        *(_WORD *)std::string buf = 0;
        _os_log_impl((void *)&_mh_execute_header, v46, OS_LOG_TYPE_INFO, "configChanged! Setting soft timer", buf, 2u);
      }

      sub_10044B018(a1, v45);
    }

    sub_100448164((os_unfair_lock_s *)(a1 + 120), &stru_100898EB0);
  }

  return sub_100242FAC((uint64_t)v53);
}

void sub_10044AFE0( _Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, ...)
{
}

uint64_t sub_10044B018(uint64_t a1, unsigned int a2)
{
  v12[0] = 0LL;
  v12[1] = 0LL;
  sub_100242F28((uint64_t)v12, a1 + 40);
  uint64_t v4 = (os_log_s *)qword_1008F7758;
  if (os_log_type_enabled((os_log_t)qword_1008F7758, OS_LOG_TYPE_INFO))
  {
    *(_DWORD *)std::string buf = 67109120;
    unsigned int v14 = a2;
    _os_log_impl((void *)&_mh_execute_header, v4, OS_LOG_TYPE_INFO, "armSoftwareScanRxTimer duration=%u", buf, 8u);
  }

  if (!*(_BYTE *)(a1 + 320) && !*(void *)(a1 + 328))
  {
    int v5 = (os_log_s *)qword_1008F7758;
    if (os_log_type_enabled((os_log_t)qword_1008F7758, OS_LOG_TYPE_INFO))
    {
      *(_DWORD *)std::string buf = 67109120;
      unsigned int v14 = a2;
      _os_log_impl((void *)&_mh_execute_header, v5, OS_LOG_TYPE_INFO, "fSoftwareScanRxTimer %u ms Armed!", buf, 8u);
    }

    uint64_t v6 = sub_100404EB8();
    char v7 = dispatch_source_create( (dispatch_source_type_t)&_dispatch_source_type_timer,  0LL,  0LL,  *(dispatch_queue_t *)(v6 + 8));
    *(void *)(a1 + 32_Block_object_dispose((const void *)(v2 - 88), 8) = v7;
    handler[0] = _NSConcreteStackBlock;
    handler[1] = 3221225472LL;
    handler[2] = sub_10044C1B8;
    handler[3] = &unk_10087EB20;
    handler[4] = a1;
    dispatch_source_set_event_handler(v7, handler);
    BOOL v8 = *(dispatch_source_s **)(a1 + 328);
    dispatch_time_t v9 = dispatch_time(0x8000000000000000LL, 1000000LL * a2);
    dispatch_source_set_timer(v8, v9, 0xFFFFFFFFFFFFFFFFLL, 0LL);
    dispatch_activate(*(dispatch_object_t *)(a1 + 328));
  }

  return sub_100242FAC((uint64_t)v12);
}

void sub_10044B1C0( _Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, ...)
{
}

void sub_10044B1DC(id a1, BluetoothDaemonListener *a2)
{
}

uint64_t sub_10044B1EC(uint64_t a1)
{
  uint64_t v2 = (os_log_s *)qword_1008F7758;
  if (os_log_type_enabled((os_log_t)qword_1008F7758, OS_LOG_TYPE_INFO))
  {
    uint64_t v3 = *(void *)(a1 + 240);
    uint64_t v4 = *(void *)(a1 + 264);
    int v6 = 134218240;
    uint64_t v7 = v3;
    __int16 v8 = 2048;
    uint64_t v9 = v4;
    _os_log_impl( (void *)&_mh_execute_header,  v2,  OS_LOG_TYPE_INFO,  "evaluateScanRxThresholds fDiscoveryScanThresholds:%lu fConnectScanThresholds:%lu",  (uint8_t *)&v6,  0x16u);
  }

  sub_100449944(a1);
  sub_100449DFC(a1);
  return sub_10044A918(a1);
}

uint64_t sub_10044B2B8(uint64_t a1, uint64_t *a2)
{
  v47[0] = 0LL;
  v47[1] = 0LL;
  sub_100242F28((uint64_t)v47, a1 + 40);
  if (*(void *)(a1 + 240)) {
    BOOL v3 = 1;
  }
  else {
    BOOL v3 = *(void *)(a1 + 264) != 0LL;
  }
  char v40 = v3;
  uint64_t v4 = *a2;
  uint64_t v5 = a2[1];
  if (*a2 != v5)
  {
    int v6 = (uint64_t **)(a1 + 248);
    do
    {
      __int128 v45 = 0u;
      v46[0] = 0LL;
      *(_OWORD *)std::stringbuf::string_type __p = 0u;
      memset(v43, 0, sizeof(v43));
      v46[1] = 0LL;

      BYTE1(v43[0]) = 0;
      DWORD1(v43[0]) = 0;
      uint64_t v7 = (const unsigned __int8 *)sub_100241F90(buf, *(void *)v4);
      memset(out, 0, sizeof(out));
      uuid_unparse_upper(v7, out);
      sub_10002418C(&v42, out);
      if (SBYTE7(v45) < 0) {
        operator delete(__p[0]);
      }
      *(_OWORD *)std::stringbuf::string_type __p = *(_OWORD *)&v42.__r_.__value_.__l.__data_;
      *(void *)&__int128 v45 = v42.__r_.__value_.__l.__cap_;
      std::string::append((std::string *)__p, "-connectionScan");
      __int16 v8 = (os_log_s *)qword_1008F7758;
      if (os_log_type_enabled((os_log_t)qword_1008F7758, OS_LOG_TYPE_INFO))
      {
        if ((SBYTE7(v45) & 0x80u) == 0) {
          uint64_t v9 = __p;
        }
        else {
          uint64_t v9 = (void **)__p[0];
        }
        int v10 = *(_DWORD *)(v4 + 8);
        int v11 = *(_DWORD *)(v4 + 12);
        int v12 = *(_DWORD *)(v4 + 16);
        *(_DWORD *)uuid_string_t out = 136315906;
        *(void *)&out[4] = v9;
        *(_WORD *)&out[12] = 1024;
        *(_DWORD *)&out[14] = v10;
        *(_WORD *)&out[18] = 1024;
        *(_DWORD *)&out[20] = v11;
        *(_WORD *)&out[24] = 1024;
        *(_DWORD *)&out[26] = v12;
        _os_log_impl( (void *)&_mh_execute_header,  v8,  OS_LOG_TYPE_INFO,  "requestConnectionScanRxThreshold device=%s totalRx=%u btMCRx=%u timeout=%u",  (uint8_t *)out,  0x1Eu);
      }

      memset(out, 0, 24);
      id v13 = objc_claimAutoreleasedReturnValue([*(id *)v4 UUIDString]);
      sub_10002418C(out, (char *)[v13 UTF8String]);

      uint64_t v14 = sub_100024098((uint64_t)v6, (const void **)out);
      unsigned int v15 = *(_DWORD *)(v4 + 8);
      unsigned int v16 = *(_DWORD *)(v4 + 12);
      int v17 = *(_DWORD *)(v4 + 16);
      if (!__PAIR64__(v16, v15) && !v17)
      {
        uint64_t v18 = v14;
        if (a1 + 256 != v14)
        {
          LOBYTE(v43[0]) = 0;
          memset((char *)v43 + 8, 0, 24);
          id v19 = v46[0];
          v46[0] = 0LL;

          id v20 = v46[1];
          v46[1] = 0LL;

          *(void *)((char *)&v43[1] + 4) = *(void *)(v18 + 76);
          LOWORD(v43[0]) = *(_WORD *)(v18 + 56);
          int v21 = *(_DWORD *)(v18 + 112);
          *(_OWORD *)((char *)v43 + 4) = *(_OWORD *)(v18 + 60);
          int v22 = *(_DWORD *)(v18 + 84);
          DWORD2(v45) = v21;
          HIDWORD(v43[1]) = v22;
          char v23 = *(void **)(v18 + 120);
          if (v23)
          {
            id v24 = objc_retainBlock(v23);
            id v25 = v46[0];
            v46[0] = v24;
          }

          unsigned int v26 = *(void **)(v18 + 128);
          if (v26)
          {
            id v27 = objc_retainBlock(v26);
            id v28 = v46[1];
            v46[1] = v27;
          }

          BYTE1(v43[0]) = 1;
          unsigned int v15 = *(_DWORD *)(v4 + 8);
          unsigned int v16 = *(_DWORD *)(v4 + 12);
          int v17 = *(_DWORD *)(v4 + 16);
        }
      }

      *((void *)&v43[0] + 1) = __PAIR64__(v16, v15);
      DWORD2(v43[1]) = v17;
      id v29 = objc_retainBlock(*(id *)(v4 + 32));
      id v30 = v46[1];
      v46[1] = v29;

      DWORD2(v45) = *(_DWORD *)(v4 + 20);
      v42.__r_.__value_.__r.__words[0] = (std::string::size_type)out;
      BOOL v31 = sub_10044E21C(v6, (const void **)out, (uint64_t)&unk_1006C2518, (__int128 **)&v42);
      __int128 v32 = v43[1];
      *(_OWORD *)(v31 + 7) = v43[0];
      *(_OWORD *)(v31 + 9) = v32;
      std::string::operator=((std::string *)(v31 + 11), (const std::string *)__p);
      *((_DWORD *)v31 + 2_Block_object_dispose((const void *)(v2 - 88), 8) = DWORD2(v45);
      id v33 = objc_retainBlock(v46[0]);
      int v34 = (void *)v31[15];
      v31[15] = (uint64_t)v33;

      id v35 = objc_retainBlock(v46[1]);
      uint64_t v36 = (void *)v31[16];
      v31[16] = (uint64_t)v35;

      if (BYTE1(v43[0]))
      {
        __int16 v37 = (os_log_s *)qword_1008F7758;
        if (os_log_type_enabled((os_log_t)qword_1008F7758, OS_LOG_TYPE_INFO))
        {
          sub_1004496CC((unsigned __int8 *)v43, &v42);
          uint64_t v38 = &v42;
          if ((v42.__r_.__value_.__s.__size_ & 0x80u) != 0) {
            uint64_t v38 = (std::stringbuf::string_type *)v42.__r_.__value_.__r.__words[0];
          }
          *(_DWORD *)std::string buf = 136315138;
          unsigned int v49 = v38;
          _os_log_impl((void *)&_mh_execute_header, v37, OS_LOG_TYPE_INFO, "Session %s cancelled", buf, 0xCu);
        }
      }

      if (out[23] < 0) {
        operator delete(*(void **)out);
      }

      if (SBYTE7(v45) < 0) {
        operator delete(__p[0]);
      }
      v4 += 40LL;
    }

    while (v4 != v5);
  }

  sub_10044B750(a1, v40);
  return sub_100242FAC((uint64_t)v47);
}

void sub_10044B6F4( _Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20, uint64_t a21, uint64_t a22, uint64_t a23, uint64_t a24, uint64_t a25, uint64_t a26, uint64_t a27, uint64_t a28, char a29)
{
}

void sub_10044B750(uint64_t a1, char a2)
{
  *(void *)std::string buf = 0LL;
  sub_1000B0400((uint64_t)buf);
  uint64_t v4 = *(int *)buf;
  uint64_t v5 = *(__int16 *)&buf[4];
  uint64_t v6 = *(void *)(a1 + 288);
  uint64_t v7 = *(void *)(a1 + 296);
  *(_WORD *)&buf[6] = 0;
  v26[0] = v6;
  v26[1] = (unsigned __int16)v7;
  if ((sub_1001F42B8((uint64_t)buf, (uint64_t)v26) & 0x80000000) != 0 || (unint64_t v8 = v5 - v7 + 1000 * (v4 - v6), HIDWORD(v8)))
  {
    uint64_t v9 = (os_log_s *)qword_1008F7758;
    if (os_log_type_enabled((os_log_t)qword_1008F7758, OS_LOG_TYPE_ERROR))
    {
      uint64_t v24 = *(void *)(a1 + 296) + 1000LL * *(void *)(a1 + 288);
      *(_DWORD *)std::string buf = 134218240;
      *(void *)&uint8_t buf[4] = v5 + 1000LL * (int)v4;
      __int16 v28 = 2048;
      uint64_t v29 = v24;
      _os_log_error_impl( (void *)&_mh_execute_header,  v9,  OS_LOG_TYPE_ERROR,  "readControllerStats: currentTime %llu fSetRxThresholdVSCTime %llu",  buf,  0x16u);
    }

    unint64_t v10 = 0LL;
    unint64_t v11 = 0LL;
  }

  else
  {
    unint64_t v10 = v8 / 0x3E8;
    unint64_t v11 = v8 % 0x3E8;
  }

  sub_100447E18(a1);
  if ((a2 & 1) != 0)
  {
    if (*(_BYTE *)(a1 + 320) && (*(void *)(a1 + 240) || *(void *)(a1 + 264)))
    {
      int v12 = (os_log_s *)qword_1008F7758;
      if (os_log_type_enabled((os_log_t)qword_1008F7758, OS_LOG_TYPE_DEFAULT))
      {
        *(_WORD *)std::string buf = 0;
        _os_log_impl((void *)&_mh_execute_header, v12, OS_LOG_TYPE_DEFAULT, "readScanStatsWithThreshold", buf, 2u);
      }

      uint64_t v13 = sub_1002E6E9C();
      uint64_t v14 = (*(uint64_t (**)(uint64_t, void, uint64_t))(*(void *)v13 + 3552LL))(v13, 0LL, 1LL);
      if ((_DWORD)v14)
      {
        unsigned int v15 = (os_log_s *)qword_1008F7758;
        if (os_log_type_enabled((os_log_t)qword_1008F7758, OS_LOG_TYPE_ERROR)) {
          sub_100680398(v14, v15, v16, v17, v18, v19, v20, v21);
        }
      }
    }

    else
    {
      int v22 = (os_log_s *)qword_1008F7758;
      if (os_log_type_enabled((os_log_t)qword_1008F7758, OS_LOG_TYPE_DEFAULT))
      {
        *(_DWORD *)std::string buf = 134217984;
        *(void *)&uint8_t buf[4] = v11 + 1000 * v10;
        _os_log_impl( (void *)&_mh_execute_header,  v22,  OS_LOG_TYPE_DEFAULT,  "Host generates scanRxThresholdVSE with values %llu",  buf,  0xCu);
      }

      uint64_t v23 = sub_100404EB8();
      v25[0] = _NSConcreteStackBlock;
      v25[1] = 3321888768LL;
      void v25[2] = sub_10044BF88;
      void v25[3] = &unk_100898ED0;
      uint8_t v25[4] = a1;
      v25[5] = v10;
      v25[6] = v11;
      sub_100405384(v23, v25);
    }
  }

  else
  {
    sub_10044B1EC(a1);
  }

uint64_t sub_10044B9F8(uint64_t a1, uint64_t **a2)
{
  v49[0] = 0LL;
  v49[1] = 0LL;
  sub_100242F28((uint64_t)v49, a1 + 40);
  if (*(void *)(a1 + 240)) {
    BOOL v3 = 1;
  }
  else {
    BOOL v3 = *(void *)(a1 + 264) != 0LL;
  }
  char v42 = v3;
  uint64_t v4 = *a2;
  uint64_t v5 = a2[1];
  if (*a2 != v5)
  {
    uint64_t v7 = (void *)(a1 + 232);
    do
    {
      __int128 v47 = 0u;
      v48[0] = 0LL;
      *(_OWORD *)std::stringbuf::string_type __p = 0u;
      memset(v45, 0, sizeof(v45));
      v48[1] = 0LL;

      BYTE1(v45[0]) = 0;
      DWORD1(v45[0]) = 0;
      if (qword_1008D61A8 != -1) {
        dispatch_once(&qword_1008D61A8, &stru_100899180);
      }
      if (sub_100496CBC(qword_1008D61A0, *v4))
      {
        sub_100494958(*v4, (uint64_t)buf);
        if (SBYTE7(v47) < 0) {
          operator delete(__p[0]);
        }
        *(_OWORD *)std::stringbuf::string_type __p = *(_OWORD *)buf;
        *(void *)&__int128 v47 = *(void *)&buf[16];
      }

      else
      {
        uint64_t v58 = 0LL;
        __int128 v56 = 0u;
        memset(v57, 0, sizeof(v57));
        *(_OWORD *)char v54 = 0u;
        __int128 v55 = 0u;
        __int128 v52 = 0u;
        __int128 v53 = 0u;
        memset(buf, 0, sizeof(buf));
        sub_10020E564((uint64_t)buf);
        std::ostream::operator<<(buf, *v4);
        std::stringbuf::str(&v50, (const std::stringbuf *)&buf[8]);
        if (SBYTE7(v47) < 0) {
          operator delete(__p[0]);
        }
        *(_OWORD *)std::stringbuf::string_type __p = *(_OWORD *)&v50.__r_.__value_.__l.__data_;
        *(void *)&__int128 v47 = v50.__r_.__value_.__l.__cap_;
        *(void *)std::string buf = v6;
        *(void *)&buf[*(void *)(v6 - 24)] = v44;
        if (SHIBYTE(v55) < 0) {
          operator delete(v54[1]);
        }
        std::streambuf::~streambuf(&buf[8]);
        std::ios::~ios(v57);
      }

      std::string::append((std::string *)__p, "-scan");
      unint64_t v8 = (os_log_s *)qword_1008F7758;
      if (os_log_type_enabled((os_log_t)qword_1008F7758, OS_LOG_TYPE_INFO))
      {
        if ((SBYTE7(v47) & 0x80u) == 0) {
          uint64_t v9 = __p;
        }
        else {
          uint64_t v9 = (void **)__p[0];
        }
        int v10 = *((_DWORD *)v4 + 2);
        int v11 = *((_DWORD *)v4 + 3);
        int v12 = *((_DWORD *)v4 + 4);
        *(_DWORD *)std::string buf = 136315906;
        *(void *)&uint8_t buf[4] = v9;
        *(_WORD *)&_BYTE buf[12] = 1024;
        *(_DWORD *)&_BYTE buf[14] = v10;
        *(_WORD *)&_BYTE buf[18] = 1024;
        *(_DWORD *)&buf[20] = v11;
        *(_WORD *)&uint8_t buf[24] = 1024;
        *(_DWORD *)&buf[26] = v12;
        _os_log_impl( (void *)&_mh_execute_header,  v8,  OS_LOG_TYPE_INFO,  "requestScanRxThreshold session=%s totalRx=%u btMCRx=%u timeout=%u",  buf,  0x1Eu);
      }

      uint64_t v13 = (void *)*v7;
      if (!*v7) {
        goto LABEL_33;
      }
      unint64_t v14 = *v4;
      uint64_t v15 = a1 + 232;
      do
      {
        unint64_t v16 = v13[4];
        BOOL v17 = v16 >= v14;
        if (v16 >= v14) {
          uint64_t v18 = v13;
        }
        else {
          uint64_t v18 = v13 + 1;
        }
        if (v17) {
          uint64_t v15 = (uint64_t)v13;
        }
        uint64_t v13 = (void *)*v18;
      }

      while (*v18);
      if ((void *)v15 == v7 || v14 < *(void *)(v15 + 32)) {
LABEL_33:
      }
        uint64_t v15 = a1 + 232;
      unsigned int v19 = *((_DWORD *)v4 + 2);
      unsigned int v20 = *((_DWORD *)v4 + 3);
      int v21 = *((_DWORD *)v4 + 4);
      if (!__PAIR64__(v20, v19) && !v21 && (void *)v15 != v7)
      {
        LOBYTE(v45[0]) = 0;
        memset((char *)v45 + 8, 0, 24);
        id v22 = v48[0];
        v48[0] = 0LL;

        id v23 = v48[1];
        v48[1] = 0LL;

        *(void *)((char *)&v45[1] + 4) = *(void *)(v15 + 60);
        LOWORD(v45[0]) = *(_WORD *)(v15 + 40);
        int v24 = *(_DWORD *)(v15 + 68);
        DWORD2(v47) = *(_DWORD *)(v15 + 96);
        *(_OWORD *)((char *)v45 + 4) = *(_OWORD *)(v15 + 44);
        HIDWORD(v45[1]) = v24;
        id v25 = *(void **)(v15 + 104);
        if (v25)
        {
          id v26 = objc_retainBlock(v25);
          id v27 = v48[0];
          v48[0] = v26;
        }

        __int16 v28 = *(void **)(v15 + 112);
        if (v28)
        {
          id v29 = objc_retainBlock(v28);
          id v30 = v48[1];
          v48[1] = v29;
        }

        BYTE1(v45[0]) = 1;
        unsigned int v19 = *((_DWORD *)v4 + 2);
        unsigned int v20 = *((_DWORD *)v4 + 3);
        int v21 = *((_DWORD *)v4 + 4);
      }

      *((void *)&v45[0] + 1) = __PAIR64__(v20, v19);
      DWORD2(v45[1]) = v21;
      id v31 = objc_retainBlock((id)v4[4]);
      id v32 = v48[0];
      v48[0] = v31;

      DWORD2(v47) = *((_DWORD *)v4 + 5);
      DWORD1(v45[0]) = *((_DWORD *)v4 + 6);
      *(void *)std::string buf = v4;
      id v33 = sub_10044E404((uint64_t **)(a1 + 224), (unint64_t *)v4, (uint64_t)&unk_1006C2518, (void **)buf);
      __int128 v34 = v45[1];
      *(_OWORD *)(v33 + 5) = v45[0];
      *(_OWORD *)(v33 + 7) = v34;
      std::string::operator=((std::string *)v33 + 3, (const std::string *)__p);
      *((_DWORD *)v33 + 24) = DWORD2(v47);
      id v35 = (uint64_t *)objc_retainBlock(v48[0]);
      uint64_t v36 = v33[13];
      v33[13] = v35;

      __int16 v37 = (uint64_t *)objc_retainBlock(v48[1]);
      uint64_t v38 = v33[14];
      v33[14] = v37;

      if (BYTE1(v45[0]))
      {
        uint64_t v39 = (os_log_s *)qword_1008F7758;
        if (os_log_type_enabled((os_log_t)qword_1008F7758, OS_LOG_TYPE_INFO))
        {
          sub_1004496CC((unsigned __int8 *)v45, (std::stringbuf::string_type *)buf);
          char v40 = buf;
          if (buf[23] < 0) {
            char v40 = *(_BYTE **)buf;
          }
          LODWORD(v50.__r_.__value_.__l.__data_) = 136315138;
          *(std::string::size_type *)((char *)v50.__r_.__value_.__r.__words + 4) = (std::string::size_type)v40;
          _os_log_impl( (void *)&_mh_execute_header,  v39,  OS_LOG_TYPE_INFO,  "Session %s cancelled",  (uint8_t *)&v50,  0xCu);
          if ((buf[23] & 0x80000000) != 0) {
            operator delete(*(void **)buf);
          }
        }
      }

      if (SBYTE7(v47) < 0) {
        operator delete(__p[0]);
      }
      v4 += 5;
    }

    while (v4 != v5);
  }

  sub_10044B750(a1, v42);
  return sub_100242FAC((uint64_t)v49);
}

void sub_10044BF38( _Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20, uint64_t a21, uint64_t a22, uint64_t a23, uint64_t a24, uint64_t a25, uint64_t a26, uint64_t a27, uint64_t a28, char a29)
{
}

uint64_t sub_10044BF88(uint64_t a1)
{
  int v1 = *(_DWORD *)(a1 + 48) + 1000 * *(_DWORD *)(a1 + 40);
  return sub_10044BFB4(*(_DWORD **)(a1 + 32), v1, v1, v1, v1, v1);
}

uint64_t sub_10044BFB4(_DWORD *a1, int a2, int a3, int a4, int a5, int a6)
{
  v14[0] = 0LL;
  v14[1] = 0LL;
  sub_100242F28((uint64_t)v14, (uint64_t)(a1 + 10));
  int v12 = (os_log_s *)qword_1008F7758;
  if (os_log_type_enabled((os_log_t)qword_1008F7758, OS_LOG_TYPE_INFO))
  {
    *(_DWORD *)std::string buf = 67110144;
    int v16 = a2;
    __int16 v17 = 1024;
    int v18 = a3;
    __int16 v19 = 1024;
    int v20 = a4;
    __int16 v21 = 1024;
    int v22 = a5;
    __int16 v23 = 1024;
    int v24 = a6;
    _os_log_impl( (void *)&_mh_execute_header,  v12,  OS_LOG_TYPE_INFO,  "scanRxThresholdVSE totalRx=%u totalBTMCRx=%u, totalConnRx=%u, totalConnBTMCRx=%u totalTime=%u",  buf,  0x20u);
  }

  a1[86] = a2;
  a1[87] = a3;
  a1[88] = a6;
  a1[89] = a4;
  a1[90] = a5;
  a1[91] = a6;
  sub_10044B1EC(a1);
  return sub_100242FAC((uint64_t)v14);
}

void sub_10044C0DC( _Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9)
{
}

__n128 sub_10044C0F8(uint64_t a1, uint64_t a2)
{
  __n128 result = *(__n128 *)(a2 + 40);
  *(__n128 *)(a1 + 4sub_100414D2C(qword_1008F72C0, 0) = result;
  return result;
}

uint64_t sub_10044C108(uint64_t a1, uint64_t a2, unsigned __int8 a3)
{
  if (*(_BYTE *)(a1 + 280) && *(_BYTE *)(a1 + 272))
  {
    if (((*(_DWORD *)(a1 + 276) == 1) & a3) != 0) {
      uint64_t v3 = 4LL;
    }
    else {
      uint64_t v3 = 0LL;
    }
  }

  else
  {
    uint64_t v3 = 0LL;
  }

  if (*(_BYTE *)(a1 + 197) || *(_BYTE *)(a1 + 198) || *(_BYTE *)(a1 + 200)) {
    uint64_t v4 = 1LL;
  }
  else {
    uint64_t v4 = *(unsigned __int8 *)(a1 + 204);
  }
  if (*(_BYTE *)(a1 + 272)) {
    uint64_t v5 = 2LL * (*(_DWORD *)(a1 + 276) == 1);
  }
  else {
    uint64_t v5 = 0LL;
  }
  BOOL v6 = sub_100449494(a1);
  uint64_t v7 = 8LL;
  if (!v6) {
    uint64_t v7 = 0LL;
  }
  return v4 | v3 | v5 | v7;
}

uint64_t sub_10044C1B8(uint64_t a1)
{
  uint64_t v1 = *(void *)(a1 + 32);
  uint64_t v2 = (os_log_s *)qword_1008F7758;
  if (os_log_type_enabled((os_log_t)qword_1008F7758, OS_LOG_TYPE_INFO))
  {
    *(_WORD *)std::string buf = 0;
    _os_log_impl((void *)&_mh_execute_header, v2, OS_LOG_TYPE_INFO, "fSoftwareScanRxTimer Timer expired!", buf, 2u);
  }

  sub_100447E18(v1);
  *(void *)std::string buf = 0LL;
  sub_1000B0400((uint64_t)buf);
  uint64_t v3 = *(int *)buf;
  uint64_t v4 = *(__int16 *)&buf[4];
  uint64_t v5 = *(void *)(v1 + 288);
  uint64_t v6 = *(void *)(v1 + 296);
  *(_WORD *)&buf[6] = 0;
  v13[0] = v5;
  v13[1] = (unsigned __int16)v6;
  if ((sub_1001F42B8((uint64_t)buf, (uint64_t)v13) & 0x80000000) != 0 || (unint64_t v7 = v4 - v6 + 1000 * (v3 - v5), HIDWORD(v7)))
  {
    unint64_t v8 = (os_log_s *)qword_1008F7758;
    if (os_log_type_enabled((os_log_t)qword_1008F7758, OS_LOG_TYPE_ERROR))
    {
      uint64_t v12 = *(void *)(v1 + 296) + 1000LL * *(void *)(v1 + 288);
      *(_DWORD *)std::string buf = 134218240;
      *(void *)&uint8_t buf[4] = v4 + 1000LL * (int)v3;
      __int16 v15 = 2048;
      uint64_t v16 = v12;
      _os_log_error_impl( (void *)&_mh_execute_header,  v8,  OS_LOG_TYPE_ERROR,  "armSoftwareScanRxTimer: currentTime %llu fSetRxThresholdVSCTime %llu",  buf,  0x16u);
    }

    LODWORD(v9) = 0;
    LODWORD(v1sub_100414D2C(qword_1008F72C0, 0) = 0;
  }

  else
  {
    unint64_t v9 = v7 / 0x3E8;
    unint64_t v10 = v7 % 0x3E8;
  }

  return sub_10044BFB4( (_DWORD *)v1,  (int)v10 + 1000 * (int)v9,  (int)v10 + 1000 * (int)v9,  (int)v10 + 1000 * (int)v9,  (int)v10 + 1000 * (int)v9,  (int)v10 + 1000 * (int)v9);
}

void sub_10044C370(uint64_t a1, unint64_t a2, uint64_t a3)
{
  *(void *)&__int128 v14 = a2;
  *((void *)&v14 + 1) = a3;
  uint64_t v5 = (os_log_s *)qword_1008F7758;
  if (os_log_type_enabled((os_log_t)qword_1008F7758, OS_LOG_TYPE_DEFAULT))
  {
    sub_1001F9F74(a1 + 272, &v13);
    int size = (char)v13.__r_.__value_.__s.__size_;
    std::string::size_type v7 = v13.__r_.__value_.__r.__words[0];
    sub_1001F9F74((uint64_t)&v14, &__p);
    unint64_t v8 = &v13;
    if (size < 0) {
      unint64_t v8 = (std::stringbuf::string_type *)v7;
    }
    if ((__p.__r_.__value_.__s.__size_ & 0x80u) == 0) {
      p_p = &__p;
    }
    else {
      p_p = (std::stringbuf::string_type *)__p.__r_.__value_.__r.__words[0];
    }
    *(_DWORD *)std::string buf = 136315394;
    uint64_t v16 = v8;
    __int16 v17 = 2080;
    int v18 = p_p;
    _os_log_impl((void *)&_mh_execute_header, v5, OS_LOG_TYPE_DEFAULT, "wifiStateChanged: from %s to %s", buf, 0x16u);
    LODWORD(v1sub_100414D2C(qword_1008F72C0, 0) = DWORD1(v14);
  }

  else
  {
    unint64_t v10 = HIDWORD(a2);
  }

  int v11 = (unsigned __int8 *)(a1 + 272);
  if (*(_DWORD *)(a1 + 276) != (_DWORD)v10
    || *v11 != v14
    || *(unsigned __int8 *)(a1 + 280) != BYTE8(v14))
  {
    *(_OWORD *)int v11 = v14;
    sub_100448D44(a1);
  }

void sub_10044C4E0( _Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, void *__p, uint64_t a13, int a14, __int16 a15, char a16, char a17)
{
  if (a17 < 0) {
    operator delete(__p);
  }
  _Unwind_Resume(exception_object);
}

void sub_10044C504(uint64_t a1, unint64_t a2, uint64_t a3)
{
}

uint64_t sub_10044C50C(uint64_t a1, int a2)
{
  *(_WORD *)(a1 + 37_Block_object_dispose((const void *)(v2 - 88), 8) = a2;
  uint64_t v4 = (os_log_s *)qword_1008F7758;
  if (os_log_type_enabled((os_log_t)qword_1008F7758, OS_LOG_TYPE_INFO))
  {
    v6[0] = 67109120;
    v6[1] = a2;
    _os_log_impl((void *)&_mh_execute_header, v4, OS_LOG_TYPE_INFO, "Updated ucmWiFiBitmap 0x%x", (uint8_t *)v6, 8u);
  }

  return sub_100448D44(a1);
}

uint64_t sub_10044C5C4(uint64_t a1, int a2)
{
  return sub_10044C50C(a1 - 16, a2);
}

void sub_10044C5CC(id a1, BluetoothDaemonListener *a2)
{
}

void sub_10044C5DC(os_unfair_lock_s *a1, int a2)
{
  uint64_t v4 = (os_log_s *)qword_1008F7758;
  if (os_log_type_enabled((os_log_t)qword_1008F7758, OS_LOG_TYPE_DEFAULT))
  {
    *(_DWORD *)std::string buf = 67109120;
    int v8 = a2;
    _os_log_impl((void *)&_mh_execute_header, v4, OS_LOG_TYPE_DEFAULT, "SDP in progress changed to %d", buf, 8u);
  }

  v5[0] = _NSConcreteStackBlock;
  v5[1] = 3221225472LL;
  _DWORD v5[2] = sub_10044C6C4;
  void v5[3] = &unk_100898E50;
  char v6 = a2;
  sub_100448164(a1 + 30, v5);
}

uint64_t sub_10044C6C4(uint64_t a1, uint64_t a2)
{
  return (*(uint64_t (**)(uint64_t, void))(*(void *)a2 + 32LL))(a2, *(unsigned __int8 *)(a1 + 32));
}

void sub_10044C6DC(uint64_t a1)
{
  if (qword_1008D6198 != -1) {
    dispatch_once(&qword_1008D6198, &stru_1008991A0);
  }
  sub_10044C5DC((os_unfair_lock_s *)off_1008D6190, *(unsigned __int8 *)(a1 + 32));
}

uint64_t sub_10044C72C(uint64_t a1, __int128 *a2, int a3, uint64_t a4)
{
  v46[0] = 0LL;
  v46[1] = 0LL;
  sub_100242F28((uint64_t)v46, a1 + 40);
  if (a3 && !*(_BYTE *)a2 && *(_BYTE *)(a1 + 380))
  {
    *(CFAbsoluteTime *)(a1 + 496) = CFAbsoluteTimeGetCurrent();
    ++*(_DWORD *)(a1 + 504);
  }

  int v8 = (_BYTE *)(a1 + 380);
  __int128 v9 = *a2;
  *(_OWORD *)(a1 + 39sub_100414D2C(qword_1008F72C0, 0) = *(__int128 *)((char *)a2 + 10);
  *(_OWORD *)(a1 + 38sub_100414D2C(qword_1008F72C0, 0) = v9;
  *(_BYTE *)(a1 + 406) = a3;
  if (a1 + 408 != a4) {
    sub_10044E65C((uint64_t **)(a1 + 408), *(unsigned int **)a4, (unsigned int *)(a4 + 8));
  }
  uint64_t v45 = 0LL;
  __int128 v43 = 0u;
  memset(v44, 0, sizeof(v44));
  *(_OWORD *)std::stringbuf::string_type __p = 0u;
  __int128 v42 = 0u;
  memset(v40, 0, sizeof(v40));
  __int128 v39 = 0u;
  sub_1001FCFC8((uint64_t)&v39);
  unint64_t v10 = sub_1001FD17C(v40, (uint64_t)"Discovery scans ", 16LL);
  if (a3) {
    int v11 = "enabled ";
  }
  else {
    int v11 = "disbled ";
  }
  sub_1001FD17C(v10, (uint64_t)v11, 8LL);
  if (a3)
  {
    uint64_t v12 = *v8 ? "passive" : "active";
    uint64_t v13 = *v8 ? 7LL : 6LL;
    sub_1001FD17C(v40, (uint64_t)v12, v13);
    __int128 v14 = sub_1001FD17C(v40, (uint64_t)" with ", 6LL);
    __int16 v15 = *(_BYTE *)(a1 + 383) ? "No " : "";
    uint64_t v16 = *(_BYTE *)(a1 + 383) ? 3LL : 0LL;
    __int16 v17 = sub_1001FD17C(v14, (uint64_t)v15, v16);
    sub_1001FD17C(v17, (uint64_t)"duplicates ", 11LL);
    LOWORD(v1_Block_object_dispose((const void *)(v2 - 88), 8) = *(_WORD *)(a1 + 386);
    __int16 v19 = (void *)std::ostream::operator<<((double)v18 * 0.625);
    sub_1001FD17C(v19, (uint64_t)"/", 1LL);
    LOWORD(v2sub_100414D2C(qword_1008F72C0, 0) = *(_WORD *)(a1 + 388);
    __int16 v21 = (void *)std::ostream::operator<<((double)v20 * 0.625);
    sub_1001FD17C(v21, (uint64_t)"/", 1LL);
    LOWORD(v22) = *(_WORD *)(a1 + 392);
    __int16 v23 = (void *)std::ostream::operator<<((double)v22 * 0.625);
    sub_1001FD17C(v23, (uint64_t)"/", 1LL);
    LOWORD(v24) = *(_WORD *)(a1 + 390);
    id v25 = (void *)std::ostream::operator<<((double)v24 * 0.625);
    sub_1001FD17C(v25, (uint64_t)"//", 2LL);
    LOWORD(v26) = *(_WORD *)(a1 + 384);
    std::ostream::operator<<((double)v26 * 0.625);
    sub_1001FD17C(v40, (uint64_t)" usecases:", 10LL);
    id v27 = *(void **)(a1 + 408);
    if (v27 != (void *)(a1 + 416))
    {
      do
      {
        __int16 v28 = sub_10044CB4C(*((_DWORD *)v27 + 7));
        size_t v29 = strlen(v28);
        id v30 = sub_1001FD17C(v40, (uint64_t)v28, v29);
        sub_1001FD17C(v30, (uint64_t)",", 1LL);
        id v31 = (void *)v27[1];
        if (v31)
        {
          do
          {
            id v32 = v31;
            id v31 = (void *)*v31;
          }

          while (v31);
        }

        else
        {
          do
          {
            id v32 = (void *)v27[2];
            BOOL v33 = *v32 == (void)v27;
            id v27 = v32;
          }

          while (!v33);
        }

        id v27 = v32;
      }

      while (v32 != (void *)(a1 + 416));
    }
  }

  __int128 v34 = (os_log_s *)qword_1008F7758;
  if (os_log_type_enabled((os_log_t)qword_1008F7758, OS_LOG_TYPE_DEFAULT))
  {
    std::stringbuf::str(&v38, (const std::stringbuf *)((char *)v40 + 8));
    id v35 = (v38.__r_.__value_.__s.__size_ & 0x80u) == 0
        ? &v38
        : (std::stringbuf::string_type *)v38.__r_.__value_.__r.__words[0];
    *(_DWORD *)std::string buf = 136315138;
    unsigned int v48 = v35;
    _os_log_impl((void *)&_mh_execute_header, v34, OS_LOG_TYPE_DEFAULT, "%s", buf, 0xCu);
  }

  *(void *)((char *)&v40[-1]
  *(void *)&v40[0] = v36;
  if (SHIBYTE(v42) < 0) {
    operator delete(__p[1]);
  }
  std::streambuf::~streambuf((char *)v40 + 8);
  std::ios::~ios(v44);
  return sub_100242FAC((uint64_t)v46);
}

void sub_10044CB14(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, ...)
{
}

const char *sub_10044CB4C(int a1)
{
  if (a1 >= 0x20000)
  {
    if (a1 >= 327680)
    {
      if (a1 > 589824)
      {
        if (a1 <= 2147418111)
        {
          switch(a1)
          {
            case 589825:
              return "FindNearbyPencil";
            case 655360:
              return "AccessDigitalHomeKey";
            case 786432:
              return "ProxControlDeviceClose";
            default:
              return "?";
          }
        }

        else
        {
          switch(a1)
          {
            case 2147418112:
              __n128 result = "InternalTestNoLockScan";
              break;
            case 2147418113:
              __n128 result = "InternalTestNoScreenOffScan";
              break;
            case 2147418114:
              __n128 result = "InternalTestScanWithNoDups";
              break;
            case 2147418115:
              __n128 result = "InternalTestScanWithDups";
              break;
            case 2147418116:
              __n128 result = "InternalTestScanFor20Seconds";
              break;
            case 2147418117:
              __n128 result = "InternalTestActiveScan";
              break;
            case 2147418118:
              __n128 result = "InternalTestUUIDScan";
              break;
            case 2147418119:
              __n128 result = "InternalTestScanFor10ClockSeconds";
              break;
            case 2147418120:
              __n128 result = "InternalTestScanBoost";
              break;
            default:
              return "?";
          }
        }
      }

      else if (a1 > 458752)
      {
        switch(a1)
        {
          case 524288:
            __n128 result = "ADPD";
            break;
          case 524289:
            __n128 result = "ADPDBuffer";
            break;
          case 524290:
            __n128 result = "MicroLocation";
            break;
          case 524291:
            __n128 result = "MicroLocationLeech";
            break;
          default:
            if (a1 == 458753)
            {
              __n128 result = "PrecisionFindingFindee";
            }

            else
            {
              if (a1 != 589824) {
                return "?";
              }
              __n128 result = "FindNearbyRemote";
            }

            break;
        }
      }

      else
      {
        switch(a1)
        {
          case 393216:
            __n128 result = "CaptiveNetworkJoin";
            break;
          case 393217:
            __n128 result = "UseCaseSIMTransfer";
            break;
          case 393218:
            __n128 result = "MacSetup";
            break;
          case 393219:
            __n128 result = "AppleIDSignIn";
            break;
          case 393220:
            __n128 result = "AppleIDSignInSettings";
            break;
          default:
            if (a1 == 327680)
            {
              __n128 result = "RapportThirdParty";
            }

            else
            {
              if (a1 != 458752) {
                return "?";
              }
              __n128 result = "PrecisionFindingFinder";
            }

            break;
        }
      }
    }

    else
    {
      switch(a1)
      {
        case 131072:
          return "SharingDefault";
        case 131073:
          return "SharingPhoneAutoUnlock";
        case 131074:
          return "SharingSiriWatchAuth";
        case 131075:
          return "SharingMacAutoUnlock";
        case 131076:
          return "SharingEDTScreenOn";
        case 131077:
          return "SharingEDTWiFiDisabled";
        case 131078:
          return "SharingEDTWombatEligibleAsDefaultCamera";
        case 131079:
          return "SharingEDTWombatCameraPicker";
        case 131080:
          return "SharingWombatBackground";
        case 131081:
          return "SharingUniversalControl";
        case 131082:
          return "SharingPeopleProximity";
        case 131083:
          return "SharingEDTEnsembleOpenDisplayPrefs";
        case 131084:
          return "SharingEDTNearbydMotionStopped";
        case 131085:
          return "SharingDoubleBoostGenericScan";
        case 131086:
          return "SharingEDTIncomingAdvertisement ";
        case 131087:
          return "SharingEDTWombatStreamStart";
        case 131088:
          return "SharingOYAutoUnlock";
        case 131089:
          return "?";
        case 131090:
          return "SharingAirDrop";
        case 131091:
          return "SharingNearbyInvitationHost";
        case 131092:
          return "SharingNearbyInvitationParticipant";
        case 131093:
          return "SharingAirDropAskToAirDrop";
        case 131094:
          return "SharingAirDropTempIdentity";
        case 131095:
          return "SharingAirDropNeedsCLink";
        case 131096:
          return "SharingRemoteWidgetUpdate";
        case 131097:
          return "SharingCountryCodeUpdate";
        case 131098:
          return "SharingMacPhoneAutoUnlock";
        case 131099:
          return "SharingVisionProDiscovery";
        case 131100:
          return "SharingVisionProStateChange";
        case 131101:
          return "SharingContinuityScreen";
        case 131102:
          return "SharingEDTRemoteDisplay";
        default:
          if (a1 == 196608)
          {
            __n128 result = "DigitalIDTSA";
          }

          else
          {
            if (a1 != 0x40000) {
              return "?";
            }
            __n128 result = "DigitalCarKeyThirdParty";
          }

          break;
      }
    }
  }

  else
  {
    __n128 result = "Unspecified";
    switch(a1)
    {
      case 0:
        return result;
      case 1:
        __n128 result = "HealthKit";
        break;
      case 2:
        __n128 result = "HomeKit";
        break;
      case 3:
        __n128 result = "FindMyObjectConnection";
        break;
      case 4:
        __n128 result = "FindMyObjectConnectionTransient";
        break;
      case 5:
        __n128 result = "MIDI";
        break;
      case 6:
        __n128 result = "Continuity";
        break;
      case 7:
        __n128 result = "InstantHotSpot";
        break;
      case 8:
        __n128 result = "NearBy";
        break;
      case 9:
        __n128 result = "Sharing";
        break;
      case 10:
        __n128 result = "HearingSupport";
        break;
      case 11:
        __n128 result = "Magnet";
        break;
      case 12:
        __n128 result = "HID";
        break;
      case 13:
        __n128 result = "LEA";
        break;
      case 14:
        __n128 result = "External";
        break;
      case 15:
        __n128 result = "ExternalMedical";
        break;
      case 16:
        __n128 result = "ExternalLock";
        break;
      case 17:
        __n128 result = "ExternalWatch";
        break;
      case 18:
        __n128 result = "SmartRouting";
        break;
      case 19:
        __n128 result = "DigitalID";
        break;
      case 20:
        __n128 result = "DigitalKey";
        break;
      case 21:
        __n128 result = "DigitalCarKey";
        break;
      case 22:
        __n128 result = "HeySiri";
        break;
      case 23:
        __n128 result = "ThirdPartyApp";
        break;
      case 24:
        __n128 result = "CNJ";
        break;
      default:
        switch(a1)
        {
          case 256:
            __n128 result = "DevicePresenceDetection";
            break;
          case 257:
            __n128 result = "AudioBox";
            break;
          case 258:
            __n128 result = "SIMTransfer";
            break;
          case 259:
            __n128 result = "ProximityScreenOnLeechScan";
            break;
          case 260:
            __n128 result = "MacMigrate";
            break;
          case 263:
            __n128 result = "HIDUARTService";
            break;
          case 264:
            __n128 result = "AccessibilitySwitchControlPairing";
            break;
          case 265:
            __n128 result = "BaseBandFastConnect";
            break;
          case 266:
            __n128 result = "SafetyAlerts";
            break;
          case 267:
            __n128 result = "LECarPlay";
            break;
          case 268:
            __n128 result = "TCCBluetooth";
            break;
          case 269:
            __n128 result = "AOPBufferLeech";
            break;
          default:
            return "?";
        }

        break;
    }
  }

  return result;
}

void sub_10044D278(uint64_t a1, __int128 *a2)
{
  __int128 v3 = a2[1];
  __int128 v24 = *a2;
  __int128 v25 = v3;
  char v4 = *((_BYTE *)a2 + 32);
  __int16 v22 = *(_WORD *)((char *)a2 + 33);
  char v23 = *((_BYTE *)a2 + 35);
  *(void *)std::string buf = 0LL;
  sub_1000B0400((uint64_t)buf);
  uint64_t v5 = *(int *)buf;
  uint64_t v6 = *(__int16 *)&buf[4];
  uint64_t v7 = *(void *)(a1 + 288);
  uint64_t v8 = *(void *)(a1 + 296);
  *(_WORD *)&buf[6] = 0;
  v26[0] = v7;
  v26[1] = (unsigned __int16)v8;
  if ((sub_1001F42B8((uint64_t)buf, (uint64_t)v26) & 0x80000000) != 0 || (unint64_t v9 = v6 - v8 + 1000 * (v5 - v7), HIDWORD(v9)))
  {
    unint64_t v10 = (os_log_s *)qword_1008F7758;
    if (os_log_type_enabled((os_log_t)qword_1008F7758, OS_LOG_TYPE_ERROR))
    {
      uint64_t v14 = *(void *)(a1 + 296) + 1000LL * *(void *)(a1 + 288);
      *(_DWORD *)std::string buf = 134218240;
      *(void *)&uint8_t buf[4] = v6 + 1000LL * (int)v5;
      __int16 v28 = 2048;
      uint64_t v29 = v14;
      _os_log_error_impl( (void *)&_mh_execute_header,  v10,  OS_LOG_TYPE_ERROR,  "handleCriticalBLEStats: currentTime %llu fSetRxThresholdVSCTime %llu",  buf,  0x16u);
    }

    unint64_t v11 = 0LL;
    unint64_t v12 = 0LL;
  }

  else
  {
    unint64_t v11 = v9 / 0x3E8;
    unint64_t v12 = v9 % 0x3E8;
  }

  uint64_t v13 = sub_100404FE8();
  v15[1] = 3321888768LL;
  __int128 v16 = v24;
  __int128 v17 = v25;
  v15[0] = _NSConcreteStackBlock;
  void v15[2] = sub_10044D44C;
  v15[3] = &unk_100898F20;
  char v18 = v4;
  __int16 v19 = v22;
  char v20 = v23;
  char v21 = v4;
  uint8_t v15[4] = a1;
  v15[5] = v11;
  v15[6] = v12;
  sub_100405384(v13, v15);
}

uint64_t sub_10044D44C(uint64_t a1)
{
  uint64_t v2 = *(_DWORD **)(a1 + 32);
  __int128 v3 = (os_log_s *)qword_1008F7758;
  if (os_log_type_enabled((os_log_t)qword_1008F7758, OS_LOG_TYPE_DEFAULT))
  {
    int v4 = *(_DWORD *)(a1 + 56);
    int v5 = *(_DWORD *)(a1 + 60);
    int v6 = *(_DWORD *)(a1 + 64);
    int v7 = *(_DWORD *)(a1 + 68);
    int v8 = *(_DWORD *)(a1 + 72);
    int v9 = *(_DWORD *)(a1 + 76);
    int v10 = *(_DWORD *)(a1 + 80);
    int v11 = *(_DWORD *)(a1 + 84);
    int v12 = *(unsigned __int8 *)(a1 + 92);
    int v13 = *(_DWORD *)(a1 + 48) + 1000 * *(_DWORD *)(a1 + 40);
    v15[0] = 67111424;
    v15[1] = v4;
    __int16 v16 = 1024;
    int v17 = v5;
    __int16 v18 = 1024;
    int v19 = v6;
    __int16 v20 = 1024;
    int v21 = v7;
    __int16 v22 = 1024;
    int v23 = v8;
    __int16 v24 = 1024;
    int v25 = v9;
    __int16 v26 = 1024;
    int v27 = v10;
    __int16 v28 = 1024;
    int v29 = v11;
    __int16 v30 = 1024;
    int v31 = v12;
    __int16 v32 = 1024;
    int v33 = v13;
    _os_log_impl( (void *)&_mh_execute_header,  v3,  OS_LOG_TYPE_DEFAULT,  "handleCriticalBLEStats: scan time %u MC %u numADVs %u MC %u conn scan time %u MC %u numPassUpAdvs %u MC %u reportR eason %u sinceLastVSC %u",  (uint8_t *)v15,  0x3Eu);
  }

  return sub_10044BFB4( v2,  *(_DWORD *)(a1 + 56),  *(_DWORD *)(a1 + 60),  *(_DWORD *)(a1 + 72),  *(_DWORD *)(a1 + 76),  *(_DWORD *)(a1 + 48) + 1000 * *(_DWORD *)(a1 + 40));
}

uint64_t sub_10044D588(uint64_t a1, int a2)
{
  v7[0] = 0LL;
  v7[1] = 0LL;
  sub_100242F28((uint64_t)v7, a1 + 40);
  *(_BYTE *)(a1 + 48_Block_object_dispose((const void *)(v2 - 88), 8) = a2;
  int v4 = (os_log_s *)qword_1008F7758;
  if (os_log_type_enabled((os_log_t)qword_1008F7758, OS_LOG_TYPE_DEFAULT))
  {
    int v5 = "no";
    if (a2) {
      int v5 = "yes";
    }
    *(_DWORD *)std::string buf = 136315138;
    int v9 = v5;
    _os_log_impl((void *)&_mh_execute_header, v4, OS_LOG_TYPE_DEFAULT, "Game mode enabled: '%s'", buf, 0xCu);
  }

  return sub_100242FAC((uint64_t)v7);
}

uint64_t sub_10044D660(uint64_t a1, int a2)
{
  return sub_10044D588(a1 - 24, a2);
}

uint64_t sub_10044D668(uint64_t result, unsigned int a2)
{
  unsigned int v6 = a2;
  if (a2 != 0x20000)
  {
    uint64_t v2 = result;
    v5[0] = 0LL;
    v5[1] = 0LL;
    sub_100242F28((uint64_t)v5, result + 40);
    if (*(_BYTE *)(v2 + 104) && !*(_BYTE *)(v2 + 488))
    {
      __int128 v3 = (uint64_t **)(v2 + 432);
      int v7 = &v6;
      int v4 = sub_1002DBB90(v3, &v6, (uint64_t)&unk_1006C2518, &v7);
      ++*((_DWORD *)v4 + 8);
      int v7 = &v6;
    }

    return sub_100242FAC((uint64_t)v5);
  }

  return result;
}

void sub_10044D738( _Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9)
{
}

uint64_t sub_10044D74C(uint64_t result, unsigned int a2)
{
  unsigned int v6 = a2;
  if (a2 != 0x20000)
  {
    uint64_t v2 = result;
    v5[0] = 0LL;
    v5[1] = 0LL;
    sub_100242F28((uint64_t)v5, result + 40);
    if (*(_BYTE *)(v2 + 104))
    {
      __int128 v3 = (uint64_t **)(v2 + 432);
      int v7 = &v6;
      if (*((_DWORD *)sub_1002DBB90(v3, &v6, (uint64_t)&unk_1006C2518, &v7) + 8))
      {
        int v7 = &v6;
        int v4 = *((_DWORD *)sub_1002DBB90(v3, &v6, (uint64_t)&unk_1006C2518, &v7) + 8);
        int v7 = &v6;
        *((_DWORD *)sub_1002DBB90(v3, &v6, (uint64_t)&unk_1006C2518, &v7) + _Block_object_dispose((const void *)(v2 - 88), 8) = v4 - 1;
        int v7 = &v6;
      }
    }

    return sub_100242FAC((uint64_t)v5);
  }

  return result;
}

void sub_10044D868( _Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9)
{
}

void sub_10044D87C(uint64_t a1, void *a2, unsigned int a3, int a4)
{
  id v8 = a2;
  unsigned int v14 = a3;
  v13[0] = 0LL;
  v13[1] = 0LL;
  sub_100242F28((uint64_t)v13, a1 + 40);
  if (v8 && *(_BYTE *)(a1 + 104))
  {
    if (a4)
    {
      __int16 v15 = &v14;
      if (!sub_10044E848((uint64_t **)(a1 + 456), &v14, (uint64_t)&unk_1006C2518, &v15)[5] && !*(_BYTE *)(a1 + 488))
      {
        __int16 v15 = &v14;
        int v9 = sub_10044E848((uint64_t **)(a1 + 456), &v14, (uint64_t)&unk_1006C2518, &v15);
        objc_storeStrong((id *)v9 + 5, a2);
        int v10 = (void *)gCBDaemonServer;
        int v11 = (void *)objc_claimAutoreleasedReturnValue([v8 UUIDString]);
        [v10 recordEventWithDeviceIdentifier:v11 initiator:1 starting:1 useCase:v14];
LABEL_9:
      }
    }

    else
    {
      __int16 v15 = &v14;
      if (sub_10044E848((uint64_t **)(a1 + 456), &v14, (uint64_t)&unk_1006C2518, &v15)[5])
      {
        sub_10044E908(a1 + 456, &v14);
        int v12 = (void *)gCBDaemonServer;
        int v11 = (void *)objc_claimAutoreleasedReturnValue([v8 UUIDString]);
        [v12 recordEventWithDeviceIdentifier:v11 initiator:1 starting:0 useCase:v14];
        goto LABEL_9;
      }
    }
  }

  sub_100242FAC((uint64_t)v13);
}

void sub_10044DA00( _Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9)
{
  sub_100242FAC((uint64_t)&a9);
  _Unwind_Resume(a1);
}

void sub_10044DA30(uint64_t a1, char a2, char a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, int a8)
{
  else {
    int v8 = 0;
  }
  if (*(unsigned __int8 *)(a1 + 217) != v8)
  {
    int v10 = (os_log_s *)qword_1008F7758;
    if (os_log_type_enabled((os_log_t)qword_1008F7758, OS_LOG_TYPE_INFO))
    {
      int v11 = "False";
      if (v8) {
        int v11 = "True";
      }
      *(_DWORD *)std::string buf = 136315138;
      __int16 v15 = v11;
      _os_log_impl( (void *)&_mh_execute_header,  v10,  OS_LOG_TYPE_INFO,  "Bluetooth Daemon: AoSStateChanged, isAoSAllowed: %s",  buf,  0xCu);
    }

    *(_BYTE *)(a1 + 217) = v8;
    v12[0] = _NSConcreteStackBlock;
    v12[1] = 3221225472LL;
    void v12[2] = sub_10044DB4C;
    v12[3] = &unk_100898E50;
    char v13 = v8;
    sub_100448164((os_unfair_lock_s *)(a1 + 120), v12);
  }

uint64_t sub_10044DB4C(uint64_t a1, uint64_t a2)
{
  return (*(uint64_t (**)(uint64_t, void))(*(void *)a2 + 40LL))(a2, *(unsigned __int8 *)(a1 + 32));
}

void sub_10044DB64(uint64_t a1, char a2, char a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, int a8)
{
}

void sub_10044DBBC(id a1)
{
  uint64_t v1 = operator new(0x128uLL);
  sub_1005C69F8();
  off_1008D5F28 = v1;
}

void sub_10044DBEC(_Unwind_Exception *a1)
{
}

void sub_10044DC00(id a1)
{
  uint64_t v1 = operator new(0x90uLL);
  sub_100532F0C((uint64_t)v1);
  qword_1008D9170 = (uint64_t)v1;
}

void sub_10044DC30(_Unwind_Exception *a1)
{
}

void sub_10044DC44(id a1)
{
  uint64_t v1 = operator new(0x230uLL);
  sub_10042BC28();
  off_1008D60A8 = v1;
}

void sub_10044DC74(_Unwind_Exception *a1)
{
}

void sub_10044DC88(id a1)
{
  uint64_t v1 = operator new(0x258uLL);
  sub_10048AA64();
  qword_1008D93F0 = (uint64_t)v1;
}

void sub_10044DCB8(_Unwind_Exception *a1)
{
}

char *sub_10044DCCC(uint64_t a1, char *__src, char *a3)
{
  __int128 v3 = a3;
  int v4 = __src;
  unsigned int v6 = *(char **)(a1 + 8);
  uint64_t v8 = a1 + 16;
  unint64_t v7 = *(void *)(a1 + 16);
  if ((unint64_t)v6 >= v7)
  {
    char v13 = *(char **)a1;
    unint64_t v14 = ((uint64_t)&v6[-*(void *)a1] >> 3) + 1;
    if (v14 >> 61) {
      abort();
    }
    uint64_t v15 = __src - v13;
    uint64_t v16 = (__src - v13) >> 3;
    uint64_t v17 = v7 - (void)v13;
    if (v17 >> 2 > v14) {
      unint64_t v14 = v17 >> 2;
    }
    else {
      unint64_t v18 = v14;
    }
    uint64_t v30 = a1 + 16;
    if (v18) {
      int v19 = (char *)sub_100008BA0(a1 + 16, v18);
    }
    else {
      int v19 = 0LL;
    }
    __int16 v20 = &v19[8 * v16];
    std::stringbuf::string_type __p = v19;
    int v27 = v20;
    __int16 v28 = v20;
    int v29 = &v19[8 * v18];
    if (v16 == v18)
    {
      if (v15 < 1)
      {
        if (v13 == v4) {
          unint64_t v22 = 1LL;
        }
        else {
          unint64_t v22 = v15 >> 2;
        }
        int v23 = (char *)sub_100008BA0(v8, v22);
        __int16 v20 = &v23[8 * (v22 >> 2)];
        std::stringbuf::string_type __p = v23;
        int v27 = v20;
        int v29 = &v23[8 * v24];
        if (v19) {
          operator delete(v19);
        }
      }

      else
      {
        unint64_t v21 = v16 + 2;
        if (v16 >= -1) {
          unint64_t v21 = v16 + 1;
        }
        v20 -= 8 * (v21 >> 1);
        int v27 = v20;
      }
    }

    *(void *)__int16 v20 = *(void *)v3;
    __int16 v28 = v20 + 8;
    int v4 = sub_100008ADC((void **)a1, (uint64_t)&__p, v4);
    if (v28 != v27) {
      v28 += (v27 - v28 + 7) & 0xFFFFFFFFFFFFFFF8LL;
    }
    if (__p) {
      operator delete(__p);
    }
  }

  else if (__src == v6)
  {
    *(void *)unint64_t __src = *(void *)a3;
    *(void *)(a1 + _Block_object_dispose((const void *)(v2 - 88), 8) = __src + 8;
  }

  else
  {
    int v9 = __src + 8;
    int v10 = v6 - 8;
    int v11 = *(void **)(a1 + 8);
    while (v10 < v6)
    {
      uint64_t v12 = *(void *)v10;
      v10 += 8;
      *v11++ = v12;
    }

    *(void *)(a1 + _Block_object_dispose((const void *)(v2 - 88), 8) = v11;
    if (v6 != v9) {
      memmove(&v6[-8 * ((v6 - v9) >> 3)], __src, v6 - v9);
    }
    if (v4 <= v3) {
      v3 += 8 * (*(void *)(a1 + 8) > (unint64_t)v3);
    }
    *(void *)int v4 = *(void *)v3;
  }

  return v4;
}

void sub_10044DED0( _Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void *__p, uint64_t a11, uint64_t a12)
{
  if (__p) {
    operator delete(__p);
  }
  _Unwind_Resume(exception_object);
}

void sub_10044DF08(uint64_t a1, void *a2)
{
  if (a2)
  {
    sub_10044DF08(a1, *a2);
    sub_10044DF08(a1, a2[1]);
    sub_10044DF50((uint64_t)(a2 + 4));
    operator delete(a2);
  }

void sub_10044DF50(uint64_t a1)
{
}

void sub_10044DF94(uint64_t a1, void *a2)
{
  if (a2)
  {
    sub_10044DF94(a1, *a2);
    sub_10044DF94(a1, a2[1]);
    sub_10044DFDC((uint64_t)(a2 + 4));
    operator delete(a2);
  }

void sub_10044DFDC(uint64_t a1)
{
}

void sub_10044E030(id a1)
{
  uint64_t v1 = operator new(0x618uLL);
  sub_10058B0A4();
  off_1008D5F08 = v1;
}

void sub_10044E060(_Unwind_Exception *a1)
{
}

void sub_10044E074(id a1)
{
  uint64_t v1 = operator new(0x120uLL);
  sub_100256C70();
  qword_1008D6168 = (uint64_t)v1;
}

void sub_10044E0A4(_Unwind_Exception *a1)
{
}

void sub_10044E0B8(id a1)
{
  uint64_t v1 = operator new(0x138uLL);
  sub_1003FE3E0((uint64_t)v1);
  off_1008D5F48 = v1;
}

void sub_10044E0E8(_Unwind_Exception *a1)
{
}

uint64_t sub_10044E0FC(uint64_t a1, unint64_t *a2)
{
  uint64_t v2 = *(void **)(a1 + 8);
  if (!v2) {
    return 0LL;
  }
  unint64_t v3 = *a2;
  int v4 = (uint64_t *)(a1 + 8);
  do
  {
    unint64_t v5 = v2[4];
    BOOL v6 = v5 >= v3;
    if (v5 >= v3) {
      unint64_t v7 = v2;
    }
    else {
      unint64_t v7 = v2 + 1;
    }
    if (v6) {
      int v4 = v2;
    }
    uint64_t v2 = (void *)*v7;
  }

  while (*v7);
  sub_1001FDBCC((uint64_t **)a1, v4);
  sub_10044DF50((uint64_t)(v4 + 4));
  operator delete(v4);
  return 1LL;
}

uint64_t sub_10044E180(uint64_t **a1, const void **a2)
{
  unint64_t v3 = (uint64_t *)sub_100024098((uint64_t)a1, a2);
  int v4 = v3;
  sub_1001FDBCC(a1, v3);
  sub_10044DFDC((uint64_t)(v4 + 4));
  operator delete(v4);
  return 1LL;
}

void sub_10044E1D8(id a1)
{
  uint64_t v1 = operator new(0x1128uLL);
  sub_1005DDADC();
  off_1008D6600 = v1;
}

void sub_10044E208(_Unwind_Exception *a1)
{
}

uint64_t *sub_10044E21C(uint64_t **a1, const void **a2, uint64_t a3, __int128 **a4)
{
  uint64_t v11 = 0LL;
  BOOL v6 = (uint64_t **)sub_10023E6A4((uint64_t)a1, &v11, a2);
  unint64_t v7 = *v6;
  if (!*v6)
  {
    uint64_t v8 = v6;
    memset(v10, 0, sizeof(v10));
    sub_10044E2D0((uint64_t)a1, a4, v10);
    sub_100029630(a1, v11, v8, v10[0]);
    unint64_t v7 = v10[0];
    v10[0] = 0LL;
    sub_10044E37C((uint64_t)v10, 0LL);
  }

  return v7;
}

double sub_10044E2D0@<D0>(uint64_t a1@<X0>, __int128 **a2@<X2>, void *a3@<X8>)
{
  uint64_t v5 = a1 + 8;
  *a3 = 0LL;
  a3[1] = 0LL;
  a3[2] = 0LL;
  BOOL v6 = (char *)operator new(0x88uLL);
  *a3 = v6;
  a3[1] = v5;
  *((_BYTE *)a3 + 16) = 0;
  unint64_t v7 = v6 + 32;
  uint64_t v8 = *a2;
  if (*((char *)*a2 + 23) < 0)
  {
    sub_100024238(v7, *(void **)v8, *((void *)v8 + 1));
  }

  else
  {
    __int128 v9 = *v8;
    *((void *)v6 + 6) = *((void *)v8 + 2);
    *(_OWORD *)unint64_t v7 = v9;
  }

  double result = 0.0;
  *(_OWORD *)(v6 + 12sub_100414D2C(qword_1008F72C0, 0) = 0u;
  *(_OWORD *)(v6 + 104) = 0u;
  *(_OWORD *)(v6 + 8_Block_object_dispose((const void *)(v2 - 88), 8) = 0u;
  *(_OWORD *)(v6 + 72) = 0u;
  *(_OWORD *)(v6 + 56) = 0u;
  *((_BYTE *)a3 + 16) = 1;
  return result;
}

void sub_10044E364(_Unwind_Exception *a1)
{
}

void sub_10044E37C(uint64_t a1, uint64_t a2)
{
  uint64_t v2 = *(void **)a1;
  *(void *)a1 = a2;
  if (v2)
  {
    if (*(_BYTE *)(a1 + 16)) {
      sub_10044DFDC((uint64_t)v2 + 32);
    }
    operator delete(v2);
  }

void sub_10044E3C0(id a1)
{
  uint64_t v1 = operator new(0x120uLL);
  sub_100495250();
  qword_1008D61A0 = (uint64_t)v1;
}

void sub_10044E3F0(_Unwind_Exception *a1)
{
}

uint64_t **sub_10044E404(uint64_t **a1, unint64_t *a2, uint64_t a3, void **a4)
{
  unint64_t v7 = a1 + 1;
  BOOL v6 = a1[1];
  uint64_t v8 = a1 + 1;
  __int128 v9 = a1 + 1;
  if (v6)
  {
    unint64_t v10 = *a2;
    while (1)
    {
      while (1)
      {
        __int128 v9 = (uint64_t **)v6;
        unint64_t v11 = v6[4];
        if (v10 >= v11) {
          break;
        }
        BOOL v6 = *v9;
        uint64_t v8 = v9;
        if (!*v9) {
          goto LABEL_9;
        }
      }

      if (v11 >= v10) {
        break;
      }
      BOOL v6 = v9[1];
      if (!v6)
      {
        uint64_t v8 = v9 + 1;
        goto LABEL_9;
      }
    }
  }

  else
  {
LABEL_9:
    uint64_t v15 = 0LL;
    uint64_t v12 = (char *)operator new(0x78uLL);
    v14[1] = v7;
    *((void *)v12 + 4) = **a4;
    *(_OWORD *)(v12 + 104) = 0u;
    *(_OWORD *)(v12 + 8_Block_object_dispose((const void *)(v2 - 88), 8) = 0u;
    *(_OWORD *)(v12 + 72) = 0u;
    *(_OWORD *)(v12 + 56) = 0u;
    *(_OWORD *)(v12 + 4sub_100414D2C(qword_1008F72C0, 0) = 0u;
    LOBYTE(v15) = 1;
    sub_100029630(a1, (uint64_t)v9, v8, (uint64_t *)v12);
    v14[0] = 0LL;
    sub_10044E500((uint64_t)v14, 0LL);
    return (uint64_t **)v12;
  }

  return v9;
}

void sub_10044E500(uint64_t a1, uint64_t a2)
{
  uint64_t v2 = *(void **)a1;
  *(void *)a1 = a2;
  if (v2)
  {
    if (*(_BYTE *)(a1 + 16)) {
      sub_10044DF50((uint64_t)v2 + 32);
    }
    operator delete(v2);
  }

void sub_10044E544(id a1)
{
  uint64_t v1 = (char *)operator new(0x200uLL);
  *(void *)uint64_t v1 = off_100898F60;
  *((void *)v1 + 1) = &off_100898FF0;
  *((void *)v1 + 2) = off_100899008;
  *((void *)v1 + 3) = &off_100899060;
  *((void *)v1 + 4) = &off_100899078;
  sub_100242DC4(v1 + 40);
  *((void *)v1 + 14) = 0LL;
  *((_DWORD *)v1 + 3sub_100414D2C(qword_1008F72C0, 0) = 0;
  *((void *)v1 + 17) = 0LL;
  *((void *)v1 + 1_Block_object_dispose((const void *)(v2 - 88), 8) = 0LL;
  *((void *)v1 + 16) = 0LL;
  *(_OWORD *)(v1 + 155) = 0u;
  *(_OWORD *)(v1 + 171) = 0u;
  *(_OWORD *)(v1 + 187) = 0u;
  *(_WORD *)(v1 + 203) = 1;
  *((void *)v1 + 26) = 0LL;
  *((_WORD *)v1 + 10_Block_object_dispose((const void *)(v2 - 88), 8) = 256;
  *((void *)v1 + 29) = 0LL;
  *((void *)v1 + 2_Block_object_dispose((const void *)(v2 - 88), 8) = v1 + 232;
  *((void *)v1 + sub_100242FAC(v1 - 32) = 0LL;
  *((void *)v1 + 33) = 0LL;
  *((void *)v1 + 3sub_100414D2C(qword_1008F72C0, 0) = 0LL;
  *((void *)v1 + 31) = v1 + 256;
  v1[272] = 0;
  *((_DWORD *)v1 + 69) = 0;
  v1[280] = 0;
  *((_WORD *)v1 + 189) = 0;
  *(void *)(v1 + 313) = 0LL;
  *(_OWORD *)(v1 + 30sub_100414D2C(qword_1008F72C0, 0) = 0u;
  *(_OWORD *)(v1 + 284) = 0u;
  *(_OWORD *)(v1 + 32_Block_object_dispose((const void *)(v2 - 88), 8) = 0u;
  *(_OWORD *)(v1 + 344) = 0u;
  *(_OWORD *)(v1 + 36sub_100414D2C(qword_1008F72C0, 0) = 0u;
  v1[376] = 0;
  *((void *)v1 + 51) = v1 + 416;
  *((void *)v1 + 52) = 0LL;
  *((void *)v1 + 55) = 0LL;
  *((void *)v1 + 56) = 0LL;
  *((void *)v1 + 53) = 0LL;
  *((void *)v1 + 54) = v1 + 440;
  *((void *)v1 + 57) = v1 + 464;
  *((void *)v1 + 5_Block_object_dispose((const void *)(v2 - 88), 8) = 0LL;
  *((void *)v1 + 59) = 0LL;
  *((void *)v1 + 6sub_100414D2C(qword_1008F72C0, 0) = @"XZ";
  *((void *)v1 + sub_100242E28(v3 + 62) = 0LL;
  *((_DWORD *)v1 + 126) = 0;
  off_1008D6190 = v1;
}

void sub_10044E648(_Unwind_Exception *a1)
{
}

uint64_t **sub_10044E65C(uint64_t **result, unsigned int *a2, unsigned int *a3)
{
  uint64_t v5 = result;
  if (result[2])
  {
    BOOL v6 = *result;
    unint64_t v7 = result[1];
    *double result = (uint64_t *)(result + 1);
    void v7[2] = 0LL;
    result[1] = 0LL;
    result[2] = 0LL;
    if (v6[1]) {
      uint64_t v8 = (uint64_t *)v6[1];
    }
    else {
      uint64_t v8 = v6;
    }
    unint64_t v14 = result;
    uint64_t v15 = v8;
    uint64_t v16 = v8;
    if (v8)
    {
      uint64_t v15 = sub_10026145C((uint64_t)v8);
      if (a2 != a3)
      {
        __int128 v9 = a2;
        do
        {
          *((_DWORD *)v8 + 7) = v9[7];
          sub_1003E62BC(v5, (uint64_t)v8);
          uint64_t v8 = v15;
          uint64_t v16 = v15;
          if (v15) {
            uint64_t v15 = sub_10026145C((uint64_t)v15);
          }
          unint64_t v10 = (unsigned int *)*((void *)v9 + 1);
          if (v10)
          {
            do
            {
              a2 = v10;
              unint64_t v10 = *(unsigned int **)v10;
            }

            while (v10);
          }

          else
          {
            do
            {
              a2 = (unsigned int *)*((void *)v9 + 2);
              BOOL v11 = *(void *)a2 == (void)v9;
              __int128 v9 = a2;
            }

            while (!v11);
          }

          if (!v8) {
            break;
          }
          __int128 v9 = a2;
        }

        while (a2 != a3);
      }
    }

    double result = (uint64_t **)sub_1002614B0((uint64_t)&v14);
  }

  if (a2 != a3)
  {
    do
    {
      double result = (uint64_t **)sub_10044E7BC(v5, a2 + 7);
      uint64_t v12 = (unsigned int *)*((void *)a2 + 1);
      if (v12)
      {
        do
        {
          char v13 = v12;
          uint64_t v12 = *(unsigned int **)v12;
        }

        while (v12);
      }

      else
      {
        do
        {
          char v13 = (unsigned int *)*((void *)a2 + 2);
          BOOL v11 = *(void *)v13 == (void)a2;
          a2 = v13;
        }

        while (!v11);
      }

      a2 = v13;
    }

    while (v13 != a3);
  }

  return result;
}

void sub_10044E7A8(_Unwind_Exception *a1, uint64_t a2, ...)
{
}

uint64_t *sub_10044E7BC(uint64_t **a1, unsigned int *a2)
{
  int v4 = (uint64_t *)operator new(0x20uLL);
  unsigned int v5 = *a2;
  *((_DWORD *)v4 + 7) = *a2;
  BOOL v6 = a1 + 1;
  unint64_t v7 = a1[1];
  if (v7)
  {
    do
    {
      while (1)
      {
        BOOL v6 = (uint64_t **)v7;
        if (v5 >= *((_DWORD *)v7 + 7)) {
          break;
        }
        unint64_t v7 = (uint64_t *)*v7;
        uint64_t v8 = v6;
        if (!*v6) {
          goto LABEL_8;
        }
      }

      unint64_t v7 = (uint64_t *)v7[1];
    }

    while (v7);
    uint64_t v8 = v6 + 1;
  }

  else
  {
    uint64_t v8 = a1 + 1;
  }

uint64_t **sub_10044E848(uint64_t **a1, unsigned int *a2, uint64_t a3, _DWORD **a4)
{
  unint64_t v7 = a1 + 1;
  BOOL v6 = a1[1];
  if (v6)
  {
    unsigned int v8 = *a2;
    while (1)
    {
      while (1)
      {
        __int128 v9 = (uint64_t **)v6;
        unsigned int v10 = *((_DWORD *)v6 + 8);
        if (v8 >= v10) {
          break;
        }
        BOOL v6 = *v9;
        unint64_t v7 = v9;
        if (!*v9) {
          goto LABEL_10;
        }
      }

      if (v10 >= v8) {
        break;
      }
      BOOL v6 = v9[1];
      if (!v6)
      {
        unint64_t v7 = v9 + 1;
        goto LABEL_10;
      }
    }
  }

  else
  {
    __int128 v9 = a1 + 1;
LABEL_10:
    BOOL v11 = operator new(0x30uLL);
    v11[8] = **a4;
    *((void *)v11 + 5) = 0LL;
    sub_100029630(a1, (uint64_t)v9, v7, (uint64_t *)v11);
    return (uint64_t **)v11;
  }

  return v9;
}

uint64_t sub_10044E908(uint64_t a1, unsigned int *a2)
{
  uint64_t v2 = *(void *)(a1 + 8);
  if (!v2) {
    return 0LL;
  }
  unsigned int v3 = *a2;
  uint64_t v4 = a1 + 8;
  do
  {
    unsigned int v5 = *(_DWORD *)(v2 + 32);
    BOOL v6 = v5 >= v3;
    if (v5 >= v3) {
      unint64_t v7 = (uint64_t *)v2;
    }
    else {
      unint64_t v7 = (uint64_t *)(v2 + 8);
    }
    if (v6) {
      uint64_t v4 = v2;
    }
    uint64_t v2 = *v7;
  }

  while (*v7);
  if (v4 == a1 + 8 || v3 < *(_DWORD *)(v4 + 32)) {
    return 0LL;
  }
  sub_10044E96C((uint64_t **)a1, v4);
  return 1LL;
}

uint64_t *sub_10044E96C(uint64_t **a1, uint64_t a2)
{
  unsigned int v3 = sub_1001FDBCC(a1, (uint64_t *)a2);

  operator delete((void *)a2);
  return v3;
}

uint64_t sub_10044E9A4(uint64_t a1)
{
  *(void *)a1 = off_1008991E8;
  *(_BYTE *)(a1 + _Block_object_dispose((const void *)(v2 - 88), 8) = 1;
  *(_DWORD *)(a1 + 12) = 0;
  sub_100242DC4(a1 + 16);
  *(void *)(a1 + 8sub_100414D2C(qword_1008F72C0, 0) = 0LL;
  *(void *)(a1 + 8_Block_object_dispose((const void *)(v2 - 88), 8) = 0LL;
  *(void *)(a1 + sub_100242FAC(v5 - 96) = 0LL;
  sub_100242DC4(a1 + 104);
  *(void *)(a1 + 16_Block_object_dispose((const void *)(v2 - 88), 8) = 0LL;
  *(void *)(a1 + 1sub_10023DF50(v3 + 76) = 0LL;
  *(void *)(a1 + 184) = 0LL;
  sub_100242DC4(a1 + 192);
  *(void *)(a1 + 256) = 0LL;
  *(void *)(a1 + 2sub_100242FAC(v30 - 64) = 0LL;
  *(void *)(a1 + 28_Block_object_dispose((const void *)(v2 - 88), 8) = 0LL;
  *(void *)(a1 + 2sub_100242FAC(v5 - 96) = 0LL;
  *(void *)(a1 + 272) = 0LL;
  *(void *)(a1 + 28sub_100414D2C(qword_1008F72C0, 0) = a1 + 288;
  *(_BYTE *)(a1 + 304) = 0;
  return a1;
}

void sub_10044EA40( _Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, void **a10)
{
  uint64_t v15 = v13;
  uint64_t v16 = v12;
  a10 = v15;
  sub_100450BA8(&a10);
  sub_100242E28(v16);
  unint64_t v18 = *v14;
  if (*v14)
  {
    *(void *)(v10 + 8_Block_object_dispose((const void *)(v2 - 88), 8) = v18;
    operator delete(v18);
  }

  sub_100242E28(v11);
  _Unwind_Resume(a1);
}

uint64_t sub_10044EA8C(uint64_t a1)
{
  *(void *)a1 = off_1008991E8;
  uint64_t v2 = (void **)(a1 + 168);
  sub_100450BE8((uint64_t *)(a1 + 168));
  sub_10023BF24(a1 + 280, *(void **)(a1 + 288));
  unsigned int v3 = *(void **)(a1 + 256);
  if (v3)
  {
    *(void *)(a1 + 2sub_100242FAC(v30 - 64) = v3;
    operator delete(v3);
  }

  sub_100242E28(a1 + 192);
  BOOL v6 = v2;
  sub_100450BA8(&v6);
  sub_100242E28(a1 + 104);
  uint64_t v4 = *(void **)(a1 + 80);
  if (v4)
  {
    *(void *)(a1 + 8_Block_object_dispose((const void *)(v2 - 88), 8) = v4;
    operator delete(v4);
  }

  sub_100242E28(a1 + 16);
  return a1;
}

void sub_10044EB20(uint64_t a1)
{
  uint64_t v1 = (void *)sub_10044EA8C(a1);
  operator delete(v1);
}

uint64_t sub_10044EB34(uint64_t *a1, uint64_t a2, uint64_t *a3, uint64_t a4)
{
  v15[0] = 0LL;
  v15[1] = 0LL;
  sub_100242F28((uint64_t)v15, (uint64_t)(a1 + 2));
  uint64_t v8 = *a3;
  uint64_t v9 = a3[1];
  uint64_t v11 = (void *)a1[10];
  unint64_t v10 = a1[11];
  uint64_t v20 = *a3;
  uint64_t v21 = v9;
  if (v11 != (void *)v10)
  {
    while (*v11 != a2 || v20 != v11[1] || v21 != v11[2])
    {
      v11 += 5;
      if (v11 == (void *)v10) {
        goto LABEL_10;
      }
    }
  }

  if (v11 == (void *)v10)
  {
LABEL_10:
    uint64_t v16 = a2;
    *(void *)&__int128 v17 = v8;
    *((void *)&v17 + 1) = v9;
    int v18 = -1;
    uint64_t v19 = a4;
    if (v10 >= a1[12])
    {
      uint64_t v13 = sub_100450C3C(a1 + 10, (uint64_t)&v16);
    }

    else
    {
      *(void *)unint64_t v10 = a2;
      *(_OWORD *)(v10 + _Block_object_dispose((const void *)(v2 - 88), 8) = v17;
      *(_DWORD *)(v10 + 24) = -1;
      *(void *)(v10 + sub_100242FAC(v1 - 32) = a4;
      uint64_t v13 = v10 + 40;
    }

    a1[11] = v13;
  }

  sub_100242FAC((uint64_t)v15);
  return 0LL;
}

void sub_10044EC24( _Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9)
{
}

uint64_t sub_10044EC38(uint64_t a1, uint64_t a2, _DWORD *a3, int a4)
{
  int v6 = *(_DWORD *)(a1 + 12);
  if (v6 != 2048)
  {
    if (v6 == -1)
    {
      sub_1003D01A0(a2, (uint64_t)&v42);
      if (SHIBYTE(v44) < 0)
      {
        uint64_t v24 = v43;
        operator delete(v42);
        if (v24) {
          return 1LL;
        }
      }

      else if (HIBYTE(v44))
      {
        return 1LL;
      }

      *a3 |= 4u;
      return 1LL;
    }

    return 0LL;
  }

  if (!sub_1003D518C(a2))
  {
    if ((sub_10044F5E4(a1, a2) & 1) == 0 && !*(_BYTE *)(a2 + 785)) {
      return 0LL;
    }
    int v19 = sub_10044F5E4(a1, a2);
    uint64_t v20 = (os_log_s *)qword_1008F7590;
    BOOL v21 = os_log_type_enabled((os_log_t)qword_1008F7590, OS_LOG_TYPE_DEFAULT);
    if (v19)
    {
      if (v21)
      {
        sub_1003CF00C(a2, &v42);
        if (v44 >= 0) {
          unint64_t v22 = &v42;
        }
        else {
          unint64_t v22 = v42;
        }
        *(_DWORD *)std::stringbuf::string_type __p = 136446210;
        *(void *)&__p[4] = v22;
        int v23 = "EIR matched for device %{public}s, requesting SDP";
        goto LABEL_52;
      }
    }

    else if (v21)
    {
      sub_1003CF00C(a2, &v42);
      if (v44 >= 0) {
        int v27 = &v42;
      }
      else {
        int v27 = v42;
      }
      *(_DWORD *)std::stringbuf::string_type __p = 136446210;
      *(void *)&__p[4] = v27;
      int v23 = "EIR previously matched for device %{public}s, requesting SDP for deadvertised service(s)";
LABEL_52:
      _os_log_impl((void *)&_mh_execute_header, v20, OS_LOG_TYPE_DEFAULT, v23, __p, 0xCu);
      if (SHIBYTE(v44) < 0) {
        operator delete(v42);
      }
    }

    uint64_t v7 = 0LL;
    *a3 |= 0x10u;
    return v7;
  }

  __int128 v41 = xmmword_1006C28C0;
  unsigned __int8 v40 = 0;
  __int128 v42 = 0LL;
  __int128 v43 = 0LL;
  uint64_t v44 = 0LL;
  if (sub_1003D4C9C(a2, (uint64_t)&v41, 0xF000u, &v42) && v43 - (_BYTE *)v42 == 16)
  {
    int v10 = *(unsigned __int8 *)v42;
    int v11 = *((unsigned __int16 *)v42 + 1);
    uint64_t v12 = (os_log_s *)qword_1008F7590;
    if (v10 == 1 && v11 == 1)
    {
      int v30 = *((unsigned __int16 *)v42 + 4);
      if (os_log_type_enabled((os_log_t)qword_1008F7590, OS_LOG_TYPE_INFO))
      {
        sub_1003CF00C(a2, __p);
        int v31 = v46 >= 0 ? __p : *(_BYTE **)__p;
        *(_DWORD *)std::string buf = 136446210;
        unsigned int v48 = v31;
        _os_log_impl( (void *)&_mh_execute_header,  v12,  OS_LOG_TYPE_INFO,  "Device %{public}s supports SDP dirty byte caching",  buf,  0xCu);
        if (v46 < 0) {
          operator delete(*(void **)__p);
        }
      }

      if (sub_1003E23E8(a2, &v40))
      {
        __int16 v32 = (os_log_s *)qword_1008F7590;
        if (v30 != v40)
        {
          if (a4)
          {
            if (os_log_type_enabled((os_log_t)qword_1008F7590, OS_LOG_TYPE_DEFAULT))
            {
              sub_1003CF00C(a2, __p);
              std::stringbuf::string_type v38 = v46 >= 0 ? __p : *(_BYTE **)__p;
              *(_DWORD *)std::string buf = 136446210;
              unsigned int v48 = v38;
              _os_log_impl( (void *)&_mh_execute_header,  v32,  OS_LOG_TYPE_DEFAULT,  "EIR is newer than SDP for device %{public}s, re-requesting SDP",  buf,  0xCu);
              if (v46 < 0) {
                operator delete(*(void **)__p);
              }
            }

            goto LABEL_30;
          }

          if (os_log_type_enabled((os_log_t)qword_1008F7590, OS_LOG_TYPE_INFO))
          {
            sub_1003CF00C(a2, __p);
            __int128 v39 = v46 >= 0 ? __p : *(_BYTE **)__p;
            *(_DWORD *)std::string buf = 136446210;
            unsigned int v48 = v39;
            _os_log_impl( (void *)&_mh_execute_header,  v32,  OS_LOG_TYPE_INFO,  "SDP is newer than EIR for device %{public}s, clearing EIR",  buf,  0xCu);
            if (v46 < 0) {
              operator delete(*(void **)__p);
            }
          }

          sub_1003E19D4(a2);
          goto LABEL_62;
        }

        if (!os_log_type_enabled((os_log_t)qword_1008F7590, OS_LOG_TYPE_INFO)) {
          goto LABEL_62;
        }
        sub_1003CF00C(a2, __p);
        if (v46 >= 0) {
          int v33 = __p;
        }
        else {
          int v33 = *(_BYTE **)__p;
        }
        *(_DWORD *)std::string buf = 136446210;
        unsigned int v48 = v33;
        __int128 v34 = "Both EIR and SDP are up-to-date for device %{public}s";
        id v35 = v32;
      }

      else
      {
        uint64_t v36 = qword_1008F7590;
        if (!os_log_type_enabled((os_log_t)qword_1008F7590, OS_LOG_TYPE_INFO)) {
          goto LABEL_62;
        }
        sub_1003CF00C(a2, __p);
        if (v46 >= 0) {
          __int16 v37 = __p;
        }
        else {
          __int16 v37 = *(_BYTE **)__p;
        }
        *(_DWORD *)std::string buf = 136446210;
        unsigned int v48 = v37;
        __int128 v34 = "We have SDP but not EIR for device %{public}s";
        id v35 = (os_log_s *)v36;
      }

      _os_log_impl((void *)&_mh_execute_header, v35, OS_LOG_TYPE_INFO, v34, buf, 0xCu);
      if ((v46 & 0x80000000) == 0) {
        goto LABEL_62;
      }
      goto LABEL_61;
    }

    if (os_log_type_enabled((os_log_t)qword_1008F7590, OS_LOG_TYPE_ERROR)) {
      sub_1006803FC(v10, v11, v12);
    }
  }

  unint64_t v14 = (os_log_s *)qword_1008F7590;
  if (os_log_type_enabled((os_log_t)qword_1008F7590, OS_LOG_TYPE_INFO))
  {
    sub_1003CF00C(a2, __p);
    uint64_t v15 = v46 >= 0 ? __p : *(_BYTE **)__p;
    *(_DWORD *)std::string buf = 136446210;
    unsigned int v48 = v15;
    _os_log_impl( (void *)&_mh_execute_header,  v14,  OS_LOG_TYPE_INFO,  "Device %{public}s does not support SDP dirty byte caching",  buf,  0xCu);
    if (v46 < 0) {
      operator delete(*(void **)__p);
    }
  }

  int v16 = sub_1003E23E8(a2, &v40);
  __int128 v17 = (os_log_s *)qword_1008F7590;
  if (v16)
  {
    if (a4)
    {
      if (os_log_type_enabled((os_log_t)qword_1008F7590, OS_LOG_TYPE_DEFAULT))
      {
        sub_1003CF00C(a2, __p);
        int v18 = v46 >= 0 ? __p : *(_BYTE **)__p;
        *(_DWORD *)std::string buf = 136446210;
        unsigned int v48 = v18;
        _os_log_impl( (void *)&_mh_execute_header,  v17,  OS_LOG_TYPE_DEFAULT,  "EIR is newer than SDP for device %{public}s, re-requesting SDP",  buf,  0xCu);
        if (v46 < 0) {
          operator delete(*(void **)__p);
        }
      }

void sub_10044F324( _Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, void *__p, uint64_t a15)
{
  if (__p) {
    operator delete(__p);
  }
  _Unwind_Resume(exception_object);
}

uint64_t sub_10044F370(uint64_t a1, uint64_t a2)
{
  v20[0] = 0LL;
  v20[1] = 0LL;
  sub_100242F28((uint64_t)v20, a1 + 104);
  uint64_t v4 = *(void *)(a1 + 168);
  uint64_t v5 = *(void *)(a1 + 176);
  if (v4 == v5)
  {
LABEL_8:
    if (*(_BYTE *)(a2 + 785))
    {
      int v10 = (os_log_s *)qword_1008F7590;
      if (os_log_type_enabled((os_log_t)qword_1008F7590, OS_LOG_TYPE_DEFAULT))
      {
        sub_1003CF00C(a2, &__p);
        if (v19 >= 0) {
          p_p = (const char *)&__p;
        }
        else {
          p_p = (const char *)__p;
        }
        *(_DWORD *)std::string buf = 136446210;
        unint64_t v22 = p_p;
        _os_log_impl( (void *)&_mh_execute_header,  v10,  OS_LOG_TYPE_DEFAULT,  "SDP previously matched for device %{public}s, but no longer does",  buf,  0xCu);
        if (v19 < 0) {
          operator delete(__p);
        }
      }

      *(_BYTE *)(a2 + 785) = 0;
      uint64_t v12 = 1LL;
      goto LABEL_26;
    }

    uint64_t v12 = 0LL;
  }

  else
  {
    while (1)
    {
      std::stringbuf::string_type __p = &off_10087FAA8;
      int v6 = *(unsigned int **)(v4 + 8);
      int v18 = v6;
      if (v6) {
        sub_1002CD1E0((uint64_t)v6);
      }
      uint64_t v7 = (void *)sub_10056AAF0((uint64_t)&__p);
      size_t v8 = sub_10056AAD8((uint64_t)&__p);
      char v9 = sub_1003E39DC(a2, v7, v8);
      std::stringbuf::string_type __p = &off_10087FAA8;
      if (v18) {
        sub_1002CD254(v18);
      }
      if ((v9 & 1) != 0) {
        break;
      }
      v4 += 16LL;
      if (v4 == v5) {
        goto LABEL_8;
      }
    }

    uint64_t v12 = 1LL;
    *(_BYTE *)(a2 + 785) = 1;
  }

  uint64_t v13 = (os_log_s *)qword_1008F7590;
  if (os_log_type_enabled((os_log_t)qword_1008F7590, OS_LOG_TYPE_DEFAULT))
  {
    sub_1003CF00C(a2, &__p);
    unint64_t v14 = "did not match";
    if ((_DWORD)v12) {
      unint64_t v14 = "matched";
    }
    if (v19 >= 0) {
      uint64_t v15 = &__p;
    }
    else {
      uint64_t v15 = __p;
    }
    *(_DWORD *)std::string buf = 136446466;
    unint64_t v22 = v14;
    __int16 v23 = 2082;
    uint64_t v24 = v15;
    _os_log_impl( (void *)&_mh_execute_header,  v13,  OS_LOG_TYPE_DEFAULT,  "SDP %{public}s for device %{public}s",  buf,  0x16u);
    if (v19 < 0) {
      operator delete(__p);
    }
  }

void sub_10044F5A8(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, ...)
{
}

uint64_t sub_10044F5E4(uint64_t a1, uint64_t a2)
{
  v15[0] = 0LL;
  v15[1] = 0LL;
  sub_100242F28((uint64_t)v15, a1 + 104);
  uint64_t v4 = *(void *)(a1 + 168);
  uint64_t v5 = *(void *)(a1 + 176);
  if (v4 == v5)
  {
    uint64_t v10 = 0LL;
  }

  else
  {
    uint64_t v6 = v4 + 16;
    do
    {
      uint64_t v13 = &off_10087FAA8;
      uint64_t v7 = *(unsigned int **)(v6 - 8);
      unint64_t v14 = v7;
      if (v7) {
        sub_1002CD1E0((uint64_t)v7);
      }
      size_t v8 = (char *)sub_10056AAF0((uint64_t)&v13);
      uint64_t v9 = sub_10056AAD8((uint64_t)&v13);
      uint64_t v10 = sub_1003E2634(a2, v8, v9);
      uint64_t v13 = &off_10087FAA8;
      if (v14) {
        sub_1002CD254(v14);
      }
      if (v6 == v5) {
        char v11 = 1;
      }
      else {
        char v11 = v10;
      }
      v6 += 16LL;
    }

    while ((v11 & 1) == 0);
  }

  sub_100242FAC((uint64_t)v15);
  return v10;
}

void sub_10044F6B4(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, ...)
{
}

void sub_10044F6E0(uint64_t a1)
{
  uint64_t v2 = (os_log_s *)qword_1008F7590;
  if (os_log_type_enabled((os_log_t)qword_1008F7590, OS_LOG_TYPE_DEFAULT))
  {
    *(_WORD *)unsigned int v3 = 0;
    _os_log_impl((void *)&_mh_execute_header, v2, OS_LOG_TYPE_DEFAULT, "Enabling Reporting Duplicates.", v3, 2u);
  }

  *(_BYTE *)(a1 + 304) = 1;
}

void sub_10044F750(uint64_t a1)
{
  uint64_t v2 = (os_log_s *)qword_1008F7590;
  if (os_log_type_enabled((os_log_t)qword_1008F7590, OS_LOG_TYPE_DEFAULT))
  {
    *(_WORD *)unsigned int v3 = 0;
    _os_log_impl((void *)&_mh_execute_header, v2, OS_LOG_TYPE_DEFAULT, "Disabling Reporting Duplicates.", v3, 2u);
  }

  *(_BYTE *)(a1 + 304) = 0;
}

uint64_t sub_10044F7BC(uint64_t *a1, const void *a2, size_t a3)
{
  uint64_t v3 = 3LL;
  if (a2 && a3 - 2049 >= 0xFFFFFFFFFFFFF800LL)
  {
    v22[0] = 0LL;
    v22[1] = 0LL;
    sub_100242F28((uint64_t)v22, (uint64_t)(a1 + 13));
    if ((unint64_t)(a1[22] - a1[21]) < 0x1F1)
    {
      uint64_t v20 = 0LL;
      BOOL v21 = 0LL;
      sub_10056AB04(&v20, a2, a3);
      uint64_t v10 = (void *)a1[21];
      char v11 = (void *)a1[22];
      if (v10 == v11)
      {
LABEL_15:
        if ((unint64_t)v10 >= a1[23])
        {
          uint64_t v14 = sub_100450EAC(a1 + 21, (uint64_t)&v20);
        }

        else
        {
          void *v10 = &off_10087FAA8;
          uint64_t v13 = v21;
          v10[1] = v21;
          if (v13) {
            sub_1002CD1E0((uint64_t)v13);
          }
          uint64_t v14 = (uint64_t)(v10 + 2);
          a1[22] = (uint64_t)(v10 + 2);
        }

        a1[22] = v14;
      }

      else
      {
        while (1)
        {
          int v18 = &off_10087FAA8;
          uint64_t v12 = (unsigned int *)v10[1];
          char v19 = v12;
          if (v12) {
            sub_1002CD1E0((uint64_t)v12);
          }
          int v18 = &off_10087FAA8;
          if (v19) {
            sub_1002CD254(v19);
          }
          v10 += 2;
          if (v10 == v11)
          {
            uint64_t v10 = (void *)a1[22];
            goto LABEL_15;
          }
        }

        uint64_t v15 = (os_log_s *)qword_1008F7590;
        if (os_log_type_enabled((os_log_t)qword_1008F7590, OS_LOG_TYPE_INFO))
        {
          *(_WORD *)__int128 v17 = 0;
          _os_log_impl((void *)&_mh_execute_header, v15, OS_LOG_TYPE_INFO, "Key already exists", v17, 2u);
        }

        int v18 = &off_10087FAA8;
        if (v19) {
          sub_1002CD254(v19);
        }
      }

      uint64_t v20 = &off_10087FAA8;
      if (v21) {
        sub_1002CD254(v21);
      }
      uint64_t v3 = 0LL;
    }

    else
    {
      uint64_t v7 = (os_log_s *)qword_1008F7590;
      if (os_log_type_enabled((os_log_t)qword_1008F7590, OS_LOG_TYPE_ERROR)) {
        sub_100680480(v7, v8, v9);
      }
      uint64_t v3 = 4LL;
    }

    sub_100242FAC((uint64_t)v22);
  }

  return v3;
}

void sub_10044F990( _Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, unsigned int *a7, ...)
{
  *(void *)(v7 + 1sub_10023DF50(v3 + 76) = v8;
  if (a7) {
    sub_1002CD254(a7);
  }
  sub_100242FAC((uint64_t)va);
  _Unwind_Resume(a1);
}

uint64_t sub_10044F9EC(uint64_t a1, const void *a2, size_t a3)
{
  uint64_t result = 3LL;
  if (a2 && a3 - 2049 >= 0xFFFFFFFFFFFFF800LL)
  {
    uint64_t v7 = 0LL;
    uint64_t v8 = 0LL;
    sub_10056AB04(&v7, a2, a3);
    v6[0] = 0LL;
    v6[1] = 0LL;
    sub_100242F28((uint64_t)v6, a1 + 104);
    uint64_t v5 = sub_10044FB6C(*(void *)(a1 + 168), *(void *)(a1 + 176), (uint64_t)&v7);
    sub_10044FABC(a1 + 168, v5, *(void *)(a1 + 176));
    sub_100242FAC((uint64_t)v6);
    uint64_t v7 = &off_10087FAA8;
    if (v8) {
      sub_1002CD254(v8);
    }
    return 0LL;
  }

  return result;
}

void sub_10044FA84( _Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t (**a11)(), unsigned int *a12)
{
  a11 = &off_10087FAA8;
  if (a12) {
    sub_1002CD254(a12);
  }
  _Unwind_Resume(a1);
}

uint64_t sub_10044FABC(uint64_t a1, uint64_t a2, uint64_t a3)
{
  if (a2 != a3)
  {
    uint64_t v5 = a3;
    uint64_t v6 = *(void *)(a1 + 8);
    if (a3 == v6)
    {
      uint64_t v8 = a2;
    }

    else
    {
      uint64_t v7 = 16 * ((a3 - a2) >> 4);
      uint64_t v8 = a2;
      do
      {
        sub_10002EAC8(v8, v8 + v7);
        v8 += 16LL;
      }

      while (v8 + v7 != v6);
      uint64_t v5 = *(void *)(a1 + 8);
    }

    while (v5 != v8)
    {
      *(void *)(v5 - 16) = &off_10087FAA8;
      v5 -= 16LL;
      uint64_t v9 = *(unsigned int **)(v5 + 8);
      if (v9) {
        sub_1002CD254(v9);
      }
    }

    *(void *)(a1 + _Block_object_dispose((const void *)(v2 - 88), 8) = v8;
  }

  return a2;
}

uint64_t sub_10044FB6C(uint64_t a1, uint64_t a2, uint64_t a3)
{
  if (a1 == a2)
  {
LABEL_5:
    uint64_t v5 = a2;
  }

  else
  {
    uint64_t v5 = a1;
    while (!sub_10056AF84(v5, a3))
    {
      v5 += 16LL;
      if (v5 == a2) {
        goto LABEL_5;
      }
    }
  }

  if (v5 != a2)
  {
    for (uint64_t i = v5 + 16; i != a2; i += 16LL)
    {
      if (!sub_10056AF84(i, a3))
      {
        sub_10002EAC8(v5, i);
        v5 += 16LL;
      }
    }
  }

  return v5;
}

uint64_t sub_10044FC00(uint64_t a1)
{
  *(_BYTE *)(a1 + _Block_object_dispose((const void *)(v2 - 88), 8) = 0;
  sub_10044FC3C(a1, 0, 0LL, 0);
  return sub_10044FF68((uint64_t **)a1, 0x4E20u);
}

uint64_t sub_10044FC3C(uint64_t a1, unsigned int a2, uint64_t a3, int a4)
{
  if (a2 > 3) {
    uint64_t v7 = 0LL;
  }
  else {
    uint64_t v7 = off_100899300[a2];
  }
  uint64_t v8 = (os_log_s *)qword_1008F7590;
  if (os_log_type_enabled((os_log_t)qword_1008F7590, OS_LOG_TYPE_INFO))
  {
    LODWORD(buf) = 136446210;
    *(void *)((char *)&buf + 4) = v7;
    _os_log_impl((void *)&_mh_execute_header, v8, OS_LOG_TYPE_INFO, "Sending '%{public}s' event", (uint8_t *)&buf, 0xCu);
  }

  v25[0] = 0LL;
  v25[1] = 0LL;
  sub_100242F28((uint64_t)v25, a1 + 16);
  uint64_t v9 = *(void *)(a1 + 80);
  uint64_t v10 = *(void *)(a1 + 88);
  if (v9 != v10)
  {
    __int128 buf = 0uLL;
    uint64_t v27 = 0LL;
    sub_100451188((char *)&buf, v9, v10, 0xCCCCCCCCCCCCCCCDLL * ((v10 - v9) >> 3));
    sub_100242F54((uint64_t)v25);
    char v11 = (unint64_t *)buf;
    if ((void)buf != *((void *)&buf + 1))
    {
      do
      {
        if (v11[1])
        {
          if (a3)
          {
            if (qword_1008D5F50 != -1) {
              dispatch_once(&qword_1008D5F50, &stru_1008992C0);
            }
            unint64_t v12 = sub_1003FEFA8((uint64_t)off_1008D5F48, *v11, a3);
          }

          else
          {
            unint64_t v12 = 4294901761LL;
          }

          if (qword_1008D61A8 != -1) {
            dispatch_once(&qword_1008D61A8, &stru_1008992A0);
          }
          uint64_t v13 = sub_10049729C(qword_1008D61A0, *v11);
          if (v13 && v12)
          {
            if (qword_1008D9138 != -1) {
              dispatch_once(&qword_1008D9138, &stru_1008992E0);
            }
            uint64_t v14 = off_1008D9130;
            uint64_t v15 = operator new(0x48uLL);
            unint64_t v17 = *v11;
            unint64_t v16 = v11[1];
            unint64_t v18 = v11[4];
            uint8_t v15[4] = 1;
            *((void *)v15 + 2) = v13;
            *((void *)v15 + 3) = v16;
            *(void *)uint64_t v15 = &off_100899230;
            *((void *)v15 + 4) = v18;
            *((void *)v15 + 5) = v17;
            *((_DWORD *)v15 + 12) = a2;
            *((void *)v15 + 7) = v12;
            *((_DWORD *)v15 + 16) = a4;
            sub_1004946C4((uint64_t)v14, v15);
          }

          else
          {
            if (a2 != 1)
            {
              char v19 = (os_log_s *)qword_1008F7590;
              if (os_log_type_enabled((os_log_t)qword_1008F7590, OS_LOG_TYPE_ERROR)) {
                sub_1006804B8(&v23, v24, v19);
              }
            }

            sub_100242ECC((uint64_t)v25);
            uint64_t v20 = sub_10045128C(*(void *)(a1 + 80), *(void *)(a1 + 88), *v11);
            sub_100450E1C(a1 + 80, v20, *(void *)(a1 + 88));
            sub_100242F54((uint64_t)v25);
          }
        }

        v11 += 5;
      }

      while (v11 != *((unint64_t **)&buf + 1));
      char v11 = (unint64_t *)buf;
    }

    if (v11)
    {
      *((void *)&buf + 1) = v11;
      operator delete(v11);
    }
  }

  return sub_100242FAC((uint64_t)v25);
}

void sub_10044FF2C( _Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, char a13, uint64_t a14, void *__p, uint64_t a16)
{
  if (__p)
  {
    a16 = (uint64_t)__p;
    operator delete(__p);
  }

  sub_100242FAC((uint64_t)&a13);
  _Unwind_Resume(a1);
}

uint64_t sub_10044FF68(uint64_t **a1, unsigned int a2)
{
  v9[0] = 0LL;
  v9[1] = 0LL;
  sub_100242F28((uint64_t)v9, (uint64_t)(a1 + 24));
  uint64_t v4 = a1[32];
  if (v4 != a1[33])
  {
    do
    {
      uint64_t v8 = 0LL;
      uint64_t v8 = *v4;
      __int128 v7 = 0uLL;
      sub_1003D0220(v8, &v7);
      *(void *)&__int128 v7 = v7 + (*((void *)&v7 + 1) + (unint64_t)a2) / 0x3E8;
      *((void *)&v7 + 1) = (*((void *)&v7 + 1) + (unint64_t)a2) % 0x3E8;
      LODWORD(v1sub_100414D2C(qword_1008F72C0, 0) = v7;
      HIDWORD(v1sub_100414D2C(qword_1008F72C0, 0) = WORD4(v7);
      if (sub_1001F4468((uint64_t)&v10)
        && (uint64_t v10 = &v8, *((int *)sub_1004510C8(a1 + 35, (unint64_t *)&v8, (uint64_t)&unk_1006C2518, &v10) + 10) >= 1))
      {
        sub_100242F54((uint64_t)v9);
        ((void (*)(uint64_t **, uint64_t))(*a1)[6])(a1, v8);
        sub_100242ECC((uint64_t)v9);
        uint64_t v4 = a1[32];
      }

      else
      {
        uint64_t v10 = &v8;
        uint64_t v5 = sub_1004510C8(a1 + 35, (unint64_t *)&v8, (uint64_t)&unk_1006C2518, &v10);
        ++*((_DWORD *)v5 + 10);
        ++v4;
      }
    }

    while (v4 != a1[33]);
    sub_100242F54((uint64_t)v9);
  }

  return sub_100242FAC((uint64_t)v9);
}

void sub_1004500D8(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, ...)
{
}

uint64_t sub_1004500F4(uint64_t a1)
{
  return sub_10044FC3C(a1, 1u, 0LL, 0);
}

uint64_t sub_100450104(uint64_t a1, void *a2)
{
  v26[1] = 0LL;
  uint64_t v27 = a2;
  v26[0] = 0LL;
  sub_100242F28((uint64_t)v26, a1 + 192);
  __p[0] = &v27;
  uint64_t v3 = (char **)(a1 + 256);
  if (sub_1003FE254(a1 + 256, (uint64_t)v27))
  {
    if (*(_BYTE *)(a1 + 304))
    {
      uint64_t v4 = v27;
      int v5 = sub_1003D04BC(v27);
      sub_10045035C(a1, 0, (uint64_t)v4, v5);
      uint64_t v6 = (os_log_s *)qword_1008F7590;
      if (os_log_type_enabled((os_log_t)qword_1008F7590, OS_LOG_TYPE_DEFAULT))
      {
        sub_1003CF00C((uint64_t)v27, __p);
        if (v25 >= 0) {
          __int128 v7 = __p;
        }
        else {
          __int128 v7 = (void **)__p[0];
        }
        *(_DWORD *)__int128 buf = 136446210;
        int v29 = v7;
        _os_log_impl( (void *)&_mh_execute_header,  v6,  OS_LOG_TYPE_DEFAULT,  "Reporting discovery of previously reported device %{public}s.",  buf,  0xCu);
        if (v25 < 0) {
          operator delete(__p[0]);
        }
      }
    }
  }

  else
  {
    uint64_t v9 = *(void **)(a1 + 264);
    unint64_t v8 = *(void *)(a1 + 272);
    if ((unint64_t)v9 >= v8)
    {
      uint64_t v11 = ((char *)v9 - *v3) >> 3;
      uint64_t v12 = v8 - (void)*v3;
      uint64_t v13 = v12 >> 2;
      else {
        unint64_t v14 = v13;
      }
      if (v14) {
        uint64_t v15 = (char *)sub_100008BA0(a1 + 272, v14);
      }
      else {
        uint64_t v15 = 0LL;
      }
      unint64_t v16 = &v15[8 * v11];
      unint64_t v17 = &v15[8 * v14];
      *(void *)unint64_t v16 = v27;
      uint64_t v10 = v16 + 8;
      char v19 = *(char **)(a1 + 256);
      unint64_t v18 = *(char **)(a1 + 264);
      if (v18 != v19)
      {
        do
        {
          uint64_t v20 = *((void *)v18 - 1);
          v18 -= 8;
          *((void *)v16 - 1) = v20;
          v16 -= 8;
        }

        while (v18 != v19);
        unint64_t v18 = *v3;
      }

      *(void *)(a1 + 256) = v16;
      *(void *)(a1 + 2sub_100242FAC(v30 - 64) = v10;
      *(void *)(a1 + 272) = v17;
      if (v18) {
        operator delete(v18);
      }
    }

    else
    {
      *uint64_t v9 = v27;
      uint64_t v10 = v9 + 1;
    }

    *(void *)(a1 + 2sub_100242FAC(v30 - 64) = v10;
    sub_100242F54((uint64_t)v26);
    BOOL v21 = v27;
    int v22 = sub_1003D04BC(v27);
    sub_10045035C(a1, 0, (uint64_t)v21, v22);
  }

  return sub_100242FAC((uint64_t)v26);
}

void sub_10045033C(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, ...)
{
}

uint64_t sub_10045035C(uint64_t a1, unsigned int a2, uint64_t a3, int a4)
{
  if (!a3)
  {
    __int128 v7 = (os_log_s *)qword_1008F7590;
    if (os_log_type_enabled((os_log_t)qword_1008F7590, OS_LOG_TYPE_FAULT)) {
      sub_1006804EC(v7);
    }
  }

  if (a2 > 2) {
    unint64_t v8 = 0LL;
  }
  else {
    unint64_t v8 = off_100899320[a2];
  }
  uint64_t v9 = (os_log_s *)qword_1008F7590;
  if (os_log_type_enabled((os_log_t)qword_1008F7590, OS_LOG_TYPE_DEFAULT))
  {
    sub_1003CF00C(a3, &__p);
    uint64_t v10 = v29 >= 0 ? &__p : (void **)__p;
    *(_DWORD *)__int128 buf = 136446466;
    *(void *)&uint8_t buf[4] = v8;
    *(_WORD *)&_BYTE buf[12] = 2082;
    *(void *)&_BYTE buf[14] = v10;
    _os_log_impl( (void *)&_mh_execute_header,  v9,  OS_LOG_TYPE_DEFAULT,  "Sending '%{public}s' event for device %{public}s",  buf,  0x16u);
    if (SHIBYTE(v29) < 0) {
      operator delete(__p);
    }
  }

  *(void *)__int128 buf = 0LL;
  *(void *)&uint8_t buf[8] = 0LL;
  sub_100242F28((uint64_t)buf, a1 + 16);
  uint64_t v11 = *(void *)(a1 + 80);
  uint64_t v12 = *(void *)(a1 + 88);
  if (v11 != v12)
  {
    std::stringbuf::string_type __p = 0LL;
    __int16 v28 = 0LL;
    uint64_t v29 = 0LL;
    sub_100451188((char *)&__p, v11, v12, 0xCCCCCCCCCCCCCCCDLL * ((v12 - v11) >> 3));
    sub_100242F54((uint64_t)buf);
    uint64_t v13 = (unint64_t *)__p;
    if (__p != v28)
    {
      do
      {
        if (v13[2])
        {
          if (a3)
          {
            if (qword_1008D5F50 != -1) {
              dispatch_once(&qword_1008D5F50, &stru_1008992C0);
            }
            unint64_t v14 = sub_1003FEFA8((uint64_t)off_1008D5F48, *v13, a3);
          }

          else
          {
            unint64_t v14 = 4294901761LL;
          }

          if (qword_1008D61A8 != -1) {
            dispatch_once(&qword_1008D61A8, &stru_1008992A0);
          }
          uint64_t v15 = sub_10049729C(qword_1008D61A0, *v13);
          if (v15 && v14)
          {
            if (qword_1008D9138 != -1) {
              dispatch_once(&qword_1008D9138, &stru_1008992E0);
            }
            unint64_t v16 = off_1008D9130;
            unint64_t v17 = operator new(0x48uLL);
            unint64_t v18 = v13[2];
            unint64_t v19 = *v13;
            unint64_t v20 = v13[4];
            void v17[4] = 1;
            *((void *)v17 + 2) = v15;
            *((void *)v17 + 3) = v18;
            *(void *)unint64_t v17 = &off_100899270;
            *((void *)v17 + 4) = v20;
            *((void *)v17 + 5) = v19;
            *((_DWORD *)v17 + 12) = a2;
            *((void *)v17 + 7) = v14;
            *((_DWORD *)v17 + 16) = a4;
            sub_1004946C4((uint64_t)v16, v17);
          }

          else
          {
            BOOL v21 = (os_log_s *)qword_1008F7590;
            if (os_log_type_enabled((os_log_t)qword_1008F7590, OS_LOG_TYPE_ERROR)) {
              sub_1006804B8(&v25, v26, v21);
            }
            sub_100242ECC((uint64_t)buf);
            uint64_t v22 = sub_10045128C(*(void *)(a1 + 80), *(void *)(a1 + 88), *v13);
            sub_100450E1C(a1 + 80, v22, *(void *)(a1 + 88));
            sub_100242F54((uint64_t)buf);
          }
        }

        v13 += 5;
      }

      while (v13 != v28);
      uint64_t v13 = (unint64_t *)__p;
    }

    if (v13)
    {
      __int16 v28 = v13;
      operator delete(v13);
    }
  }

  return sub_100242FAC((uint64_t)buf);
}

void sub_1004506AC( _Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, void *__p, uint64_t a13, uint64_t a14, char a15)
{
  if (__p) {
    operator delete(__p);
  }
  sub_100242FAC((uint64_t)&a15);
  _Unwind_Resume(a1);
}

uint64_t sub_1004506E8(uint64_t a1, void *a2)
{
  v13[0] = 0LL;
  v13[1] = 0LL;
  sub_100242F28((uint64_t)v13, a1 + 192);
  BOOL v4 = sub_1003FE254(a1 + 256, (uint64_t)a2);
  sub_100242F54((uint64_t)v13);
  if (*(_DWORD *)(a1 + 12) == 2048)
  {
    if (v4)
    {
      LODWORD(__p[0]) = 0;
      if ((sub_10044EC38(a1, (uint64_t)a2, __p, 0) & 1) == 0)
      {
        int v5 = (os_log_s *)qword_1008F7590;
        if (os_log_type_enabled((os_log_t)qword_1008F7590, OS_LOG_TYPE_DEFAULT))
        {
          sub_1003CF00C((uint64_t)a2, __p);
          if (v12 >= 0) {
            uint64_t v6 = __p;
          }
          else {
            uint64_t v6 = (void **)__p[0];
          }
          *(_DWORD *)__int128 buf = 136446210;
          uint64_t v15 = v6;
          _os_log_impl( (void *)&_mh_execute_header,  v5,  OS_LOG_TYPE_DEFAULT,  "Device %{public}s no longer matches our service list",  buf,  0xCu);
          if (v12 < 0) {
            operator delete(__p[0]);
          }
        }

        uint64_t v7 = 6LL;
        goto LABEL_16;
      }

void sub_1004508C8(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, ...)
{
}

uint64_t sub_1004508E8(uint64_t a1, void *a2)
{
  v7[1] = 0LL;
  unint64_t v8 = a2;
  v7[0] = 0LL;
  sub_100242F28((uint64_t)v7, a1 + 192);
  if (sub_1003FE288((char **)(a1 + 256), (uint64_t)a2))
  {
    sub_10020166C(a1 + 280, (unint64_t *)&v8);
    sub_100242F54((uint64_t)v7);
    BOOL v4 = v8;
    int v5 = sub_1003D04BC(v8);
    sub_10045035C(a1, 1u, (uint64_t)v4, v5);
  }

  return sub_100242FAC((uint64_t)v7);
}

void sub_100450970(_Unwind_Exception *a1, uint64_t a2, ...)
{
}

void *sub_100450984(void *result)
{
  *uint64_t result = &off_100899230;
  return result;
}

uint64_t sub_100450998( uint64_t a1, uint64_t a2, uint64_t (*a3)(uint64_t, uint64_t, uint64_t, uint64_t, uint64_t), uint64_t a4)
{
  uint64_t result = sub_100450A04(a1, *(void *)(a1 + 40));
  if ((_DWORD)result)
  {
    uint64_t result = sub_100450A04(a1, *(void *)(a1 + 56));
    if ((_DWORD)result) {
      return sub_1003B4DA4( a2,  a3,  *(void *)(a1 + 40),  *(unsigned int *)(a1 + 48),  *(void *)(a1 + 56),  *(unsigned int *)(a1 + 64),  a4);
    }
  }

  return result;
}

BOOL sub_100450A04(uint64_t a1, unint64_t a2)
{
  if (qword_1008D61A8 != -1) {
    dispatch_once(&qword_1008D61A8, &stru_1008992A0);
  }
  return sub_100497204(qword_1008D61A0, a2);
}

void *sub_100450A54(void *result)
{
  *uint64_t result = &off_100899270;
  return result;
}

uint64_t sub_100450A68( uint64_t a1, uint64_t a2, uint64_t (*a3)(uint64_t, uint64_t, uint64_t, uint64_t, uint64_t), uint64_t a4)
{
  uint64_t result = sub_100450A04(a1, *(void *)(a1 + 40));
  if ((_DWORD)result)
  {
    uint64_t result = sub_100450A04(a1, *(void *)(a1 + 56));
    if ((_DWORD)result) {
      return sub_1003B4DA4( a2,  a3,  *(void *)(a1 + 40),  *(unsigned int *)(a1 + 48),  *(void *)(a1 + 56),  *(unsigned int *)(a1 + 64),  a4);
    }
  }

  return result;
}

uint64_t sub_100450AD4(unint64_t *a1)
{
  uint64_t result = sub_100450A04((uint64_t)a1, a1[2]);
  if ((_DWORD)result) {
    return (*(uint64_t (**)(unint64_t *, unint64_t, unint64_t, unint64_t))(*a1 + 40))( a1,  a1[2],  a1[3],  a1[4]);
  }
  return result;
}

uint64_t sub_100450B1C(unint64_t *a1)
{
  uint64_t result = sub_100450A04((uint64_t)a1, a1[2]);
  if ((_DWORD)result) {
    return (*(uint64_t (**)(unint64_t *, unint64_t, unint64_t, unint64_t))(*a1 + 40))( a1,  a1[2],  a1[3],  a1[4]);
  }
  return result;
}

void sub_100450B64(id a1)
{
  uint64_t v1 = operator new(0x120uLL);
  sub_100495250();
  qword_1008D61A0 = (uint64_t)v1;
}

void sub_100450B94(_Unwind_Exception *a1)
{
}

void sub_100450BA8(void ***a1)
{
  uint64_t v2 = *a1;
  if (*v2)
  {
    sub_100450BE8((uint64_t *)v2);
    operator delete(**a1);
  }

void sub_100450BE8(uint64_t *a1)
{
  uint64_t v2 = *a1;
  uint64_t v3 = a1[1];
  if (v3 != *a1)
  {
    do
    {
      *(void *)(v3 - 16) = &off_10087FAA8;
      v3 -= 16LL;
      BOOL v4 = *(unsigned int **)(v3 + 8);
      if (v4) {
        sub_1002CD254(v4);
      }
    }

    while (v3 != v2);
  }

  a1[1] = v2;
}

uint64_t sub_100450C3C(uint64_t *a1, uint64_t a2)
{
  uint64_t v2 = *a1;
  unint64_t v3 = 0xCCCCCCCCCCCCCCCDLL * ((a1[1] - *a1) >> 3);
  unint64_t v4 = v3 + 1;
  if (v3 + 1 > 0x666666666666666LL) {
    abort();
  }
  uint64_t v8 = a1[2];
  uint64_t v7 = (uint64_t)(a1 + 2);
  unint64_t v9 = 0xCCCCCCCCCCCCCCCDLL * ((v8 - v2) >> 3);
  if (2 * v9 > v4) {
    unint64_t v4 = 2 * v9;
  }
  if (v9 >= 0x333333333333333LL) {
    unint64_t v10 = 0x666666666666666LL;
  }
  else {
    unint64_t v10 = v4;
  }
  uint64_t v20 = v7;
  uint64_t v11 = (char *)sub_1001FDA44(v7, v10);
  char v12 = &v11[40 * v3];
  std::stringbuf::string_type __p = v11;
  unint64_t v17 = v12;
  unint64_t v19 = &v11[40 * v13];
  *(void *)char v12 = *(void *)a2;
  *(_OWORD *)(v12 + _Block_object_dispose((const void *)(v2 - 88), 8) = *(_OWORD *)(a2 + 8);
  *((_DWORD *)v12 + 6) = *(_DWORD *)(a2 + 24);
  *((void *)v12 + 4) = *(void *)(a2 + 32);
  unint64_t v18 = v12 + 40;
  sub_100450DAC(a1, &__p);
  uint64_t v14 = a1[1];
  if (v18 != v17) {
    unint64_t v18 = &v17[(v18 - v17 - 40) % 0x28uLL];
  }
  if (__p) {
    operator delete(__p);
  }
  return v14;
}

void sub_100450D60( _Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void *__p, uint64_t a11, uint64_t a12)
{
  if (__p) {
    operator delete(__p);
  }
  _Unwind_Resume(exception_object);
}

uint64_t *sub_100450DAC(uint64_t *result, void *a2)
{
  uint64_t v3 = *result;
  uint64_t v2 = result[1];
  uint64_t v4 = a2[1];
  while (v2 != v3)
  {
    uint64_t v5 = *(void *)(v2 - 40);
    v2 -= 40LL;
    *(void *)(v4 - 4sub_100414D2C(qword_1008F72C0, 0) = v5;
    v4 -= 40LL;
    *(_OWORD *)(v4 + _Block_object_dispose((const void *)(v2 - 88), 8) = *(_OWORD *)(v2 + 8);
    *(_DWORD *)(v4 + 24) = *(_DWORD *)(v2 + 24);
    *(void *)(v4 + sub_100242FAC(v1 - 32) = *(void *)(v2 + 32);
  }

  a2[1] = v4;
  uint64_t v6 = *result;
  *uint64_t result = v4;
  a2[1] = v6;
  uint64_t v7 = result[1];
  result[1] = a2[2];
  a2[2] = v7;
  uint64_t v8 = result[2];
  result[2] = a2[3];
  a2[3] = v8;
  *a2 = a2[1];
  return result;
}

uint64_t sub_100450E1C(uint64_t a1, uint64_t a2, uint64_t a3)
{
  if (a2 != a3)
  {
    sub_100450E60(a3, *(void *)(a1 + 8), a2);
    *(void *)(a1 + _Block_object_dispose((const void *)(v2 - 88), 8) = v5;
  }

  return a2;
}

uint64_t sub_100450E60(uint64_t a1, uint64_t a2, uint64_t a3)
{
  if (a1 == a2) {
    return a1;
  }
  do
  {
    *(void *)a3 = *(void *)a1;
    *(_OWORD *)(a3 + _Block_object_dispose((const void *)(v2 - 88), 8) = *(_OWORD *)(a1 + 8);
    *(_DWORD *)(a3 + 24) = *(_DWORD *)(a1 + 24);
    *(void *)(a3 + sub_100242FAC(v1 - 32) = *(void *)(a1 + 32);
    a3 += 40LL;
    a1 += 40LL;
  }

  while (a1 != a2);
  return a2;
}

uint64_t sub_100450EAC(uint64_t *a1, uint64_t a2)
{
  uint64_t v2 = *a1;
  uint64_t v3 = (a1[1] - *a1) >> 4;
  unint64_t v4 = v3 + 1;
  uint64_t v8 = a1[2];
  uint64_t v7 = (uint64_t)(a1 + 2);
  uint64_t v9 = v8 - v2;
  if (v9 >> 3 > v4) {
    unint64_t v4 = v9 >> 3;
  }
  else {
    unint64_t v10 = v4;
  }
  uint64_t v19 = v7;
  if (v10) {
    uint64_t v11 = (char *)sub_1003ADAF8(v7, v10);
  }
  else {
    uint64_t v11 = 0LL;
  }
  char v12 = &v11[16 * v3];
  v16[0] = v11;
  v16[1] = v12;
  unint64_t v17 = v12;
  unint64_t v18 = &v11[16 * v10];
  *(void *)char v12 = &off_10087FAA8;
  uint64_t v13 = *(void *)(a2 + 8);
  *((void *)v12 + 1) = v13;
  if (v13)
  {
    sub_1002CD1E0(v13);
    char v12 = v17;
  }

  unint64_t v17 = v12 + 16;
  sub_100450F98(a1, v16);
  uint64_t v14 = a1[1];
  sub_100451038((uint64_t)v16);
  return v14;
}

void sub_100450F84(_Unwind_Exception *a1, uint64_t a2, ...)
{
}

void sub_100450F98(uint64_t *a1, void *a2)
{
  uint64_t v5 = *a1;
  uint64_t v4 = a1[1];
  uint64_t v6 = a2[1];
  if (v4 != *a1)
  {
    do
    {
      *(void *)(v6 - 16) = &off_10087FAA8;
      v6 -= 16LL;
      uint64_t v7 = *(void *)(v4 - 8);
      *(void *)(v6 + _Block_object_dispose((const void *)(v2 - 88), 8) = v7;
      if (v7) {
        sub_1002CD1E0(v7);
      }
      v4 -= 16LL;
    }

    while (v4 != v5);
  }

  a2[1] = v6;
  uint64_t v8 = *a1;
  *a1 = v6;
  a2[1] = v8;
  uint64_t v9 = a1[1];
  a1[1] = a2[2];
  a2[2] = v9;
  uint64_t v10 = a1[2];
  a1[2] = a2[3];
  a2[3] = v10;
  *a2 = a2[1];
}

uint64_t sub_100451038(uint64_t a1)
{
  if (*(void *)a1) {
    operator delete(*(void **)a1);
  }
  return a1;
}

void sub_10045106C(uint64_t a1, uint64_t a2)
{
  uint64_t v2 = *(void *)(a1 + 16);
  while (v2 != a2)
  {
    *(void *)(v2 - 16) = &off_10087FAA8;
    v2 -= 16LL;
    *(void *)(a1 + 16) = v2;
    uint64_t v5 = *(unsigned int **)(v2 + 8);
    if (v5)
    {
      sub_1002CD254(v5);
      uint64_t v2 = *(void *)(a1 + 16);
    }
  }

uint64_t **sub_1004510C8(uint64_t **a1, unint64_t *a2, uint64_t a3, void **a4)
{
  uint64_t v7 = a1 + 1;
  uint64_t v6 = a1[1];
  if (v6)
  {
    unint64_t v8 = *a2;
    while (1)
    {
      while (1)
      {
        uint64_t v9 = (uint64_t **)v6;
        unint64_t v10 = v6[4];
        if (v8 >= v10) {
          break;
        }
        uint64_t v6 = *v9;
        uint64_t v7 = v9;
        if (!*v9) {
          goto LABEL_10;
        }
      }

      if (v10 >= v8) {
        break;
      }
      uint64_t v6 = v9[1];
      if (!v6)
      {
        uint64_t v7 = v9 + 1;
        goto LABEL_10;
      }
    }
  }

  else
  {
    uint64_t v9 = a1 + 1;
LABEL_10:
    uint64_t v11 = operator new(0x30uLL);
    uint8_t v11[4] = **a4;
    *((_DWORD *)v11 + 1sub_100414D2C(qword_1008F72C0, 0) = 0;
    sub_100029630(a1, (uint64_t)v9, v7, v11);
    return (uint64_t **)v11;
  }

  return v9;
}

char *sub_100451188(char *result, uint64_t a2, uint64_t a3, unint64_t a4)
{
  if (a4)
  {
    uint64_t v6 = result;
    uint64_t result = sub_1004511FC(result, a4);
    uint64_t v7 = *((void *)v6 + 1);
    while (a2 != a3)
    {
      *(void *)uint64_t v7 = *(void *)a2;
      *(_OWORD *)(v7 + _Block_object_dispose((const void *)(v2 - 88), 8) = *(_OWORD *)(a2 + 8);
      *(_DWORD *)(v7 + 24) = *(_DWORD *)(a2 + 24);
      *(void *)(v7 + sub_100242FAC(v1 - 32) = *(void *)(a2 + 32);
      v7 += 40LL;
      a2 += 40LL;
    }

    *((void *)v6 + 1) = v7;
  }

  return result;
}

char *sub_1004511FC(void *a1, unint64_t a2)
{
  if (a2 >= 0x666666666666667LL) {
    abort();
  }
  uint64_t result = (char *)sub_1001FDA44((uint64_t)(a1 + 2), a2);
  *a1 = result;
  a1[1] = result;
  a1[2] = &result[40 * v4];
  return result;
}

void sub_100451248(id a1)
{
  uint64_t v1 = operator new(0x138uLL);
  sub_1003FE3E0((uint64_t)v1);
  off_1008D5F48 = v1;
}

void sub_100451278(_Unwind_Exception *a1)
{
}

uint64_t sub_10045128C(uint64_t result, uint64_t a2, uint64_t a3)
{
  while (1)
  {
    if (result == a2) {
      return a2;
    }
    if (*(void *)result == a3) {
      break;
    }
    result += 40LL;
  }

  if (result != a2)
  {
    for (uint64_t i = result + 40; i != a2; i += 40LL)
    {
      if (*(void *)i != a3)
      {
        *(void *)uint64_t result = *(void *)i;
        *(_OWORD *)(result + _Block_object_dispose((const void *)(v2 - 88), 8) = *(_OWORD *)(i + 8);
        *(_DWORD *)(result + 24) = *(_DWORD *)(i + 24);
        *(void *)(result + sub_100242FAC(v1 - 32) = *(void *)(i + 32);
        result += 40LL;
      }
    }
  }

  return result;
}

void sub_1004512F8(id a1)
{
  uint64_t v1 = operator new(0x68uLL);
  sub_10049435C();
  off_1008D9130 = v1;
}

void sub_100451328(_Unwind_Exception *a1)
{
}

uint64_t sub_10045133C(uint64_t a1)
{
  *(_OWORD *)(a1 + 6_Block_object_dispose((const void *)(v2 - 88), 8) = 0u;
  *(_OWORD *)(a1 + 56) = 0u;
  *(_OWORD *)(a1 + 4sub_100414D2C(qword_1008F72C0, 0) = 0u;
  *(_OWORD *)(a1 + 24) = 0u;
  *(_OWORD *)(a1 + _Block_object_dispose((const void *)(v2 - 88), 8) = 0u;
  *(void *)a1 = off_10088BF50;
  sub_100242DC4(a1 + 8);
  *(void *)(a1 + 72) = 0LL;
  *(void *)a1 = off_100899348;
  *(void *)(a1 + sub_100242FAC(v5 - 96) = 0LL;
  *(void *)(a1 + 104) = 0LL;
  *(void *)(a1 + 8_Block_object_dispose((const void *)(v2 - 88), 8) = 0LL;
  *(_DWORD *)(a1 + 8sub_100414D2C(qword_1008F72C0, 0) = 1;
  return a1;
}

uint64_t sub_1004513A4@<X0>(uint64_t a1@<X0>, uint64_t a2@<X8>)
{
  v5[0] = 0LL;
  v5[1] = 0LL;
  sub_100242F28((uint64_t)v5, a1 + 8);
  if (*(char *)(a1 + 111) < 0)
  {
    sub_100024238((_BYTE *)a2, *(void **)(a1 + 88), *(void *)(a1 + 96));
  }

  else
  {
    *(_OWORD *)a2 = *(_OWORD *)(a1 + 88);
    *(void *)(a2 + 16) = *(void *)(a1 + 104);
  }

  return sub_100242FAC((uint64_t)v5);
}

void sub_100451410( _Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9)
{
}

void sub_100451424(std::string *a1, void *a2)
{
  id v4 = a2;
  v7[0] = 0LL;
  v7[1] = 0LL;
  sub_100242F28((uint64_t)v7, (uint64_t)&a1->__r_.__value_.__l.__size_);
  objc_storeStrong((id *)&a1[3].__r_.__value_.__l.__data_, a2);
  uint64_t v5 = (void *)objc_claimAutoreleasedReturnValue([a1[3].__r_.__value_.__l.__data_ getLocalUrl]);
  id v6 = objc_claimAutoreleasedReturnValue([v5 absoluteString]);
  a1 = (std::string *)((char *)a1 + 88);
  std::string::assign(a1, (const std::string::value_type *)[v6 UTF8String]);

  std::string::append(a1, "device_workarounds.db");
  sub_100242FAC((uint64_t)v7);
}

void sub_1004514D0( _Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9)
{
  sub_100242FAC((uint64_t)&a9);
  _Unwind_Resume(a1);
}

uint64_t sub_100451508(uint64_t a1)
{
  *(void *)a1 = off_10088BF50;

  sub_100242E28(a1 + 8);
  return a1;
}

void sub_100451554(void **a1)
{
  *a1 = off_10088BF50;

  sub_100242E28(a1 + 1);
  operator delete(a1);
}

uint64_t sub_1004515A0(uint64_t a1)
{
  *(void *)a1 = off_100899370;
  *(void *)(a1 + _Block_object_dispose((const void *)(v2 - 88), 8) = off_100899430;
  *(void *)(a1 + 16) = off_100899450;
  *(void *)(a1 + 24) = off_100899478;
  *(void *)(a1 + sub_100242FAC(v1 - 32) = off_1008994A0;
  *(void *)(a1 + 4sub_100414D2C(qword_1008F72C0, 0) = &off_1008994D0;
  sub_100242DC4(a1 + 48);
  *(_BYTE *)(a1 + 112) = 0;
  sub_100242DC4(a1 + 120);
  *(_WORD *)(a1 + 184) = 0;
  sub_100242DC4(a1 + 192);
  *(void *)(a1 + 2sub_100242FAC(v30 - 64) = 0LL;
  *(void *)(a1 + 272) = 0LL;
  *(void *)(a1 + 256) = a1 + 264;
  sub_100242DC4(a1 + 280);
  *(_OWORD *)(a1 + 36sub_100414D2C(qword_1008F72C0, 0) = 0u;
  *(_OWORD *)(a1 + 3sub_10023DF50(v3 + 76) = 0u;
  *(_OWORD *)(a1 + 344) = 0u;
  sub_100242DC4(a1 + 392);
  *(void *)(a1 + 4sub_100242FAC(v30 - 64) = 0LL;
  *(void *)(a1 + 472) = 0LL;
  *(void *)(a1 + 456) = a1 + 464;
  *(_DWORD *)(a1 + 48sub_100414D2C(qword_1008F72C0, 0) = 0;
  *(void *)(a1 + 48_Block_object_dispose((const void *)(v2 - 88), 8) = 0LL;
  *(_WORD *)(a1 + 4sub_100242FAC(v5 - 96) = 0;
  sub_100242DC4(a1 + 520);
  *(void *)(a1 + 60sub_100414D2C(qword_1008F72C0, 0) = 0LL;
  *(void *)(a1 + 592) = 0LL;
  *(void *)(a1 + 584) = a1 + 592;
  return a1;
}

void sub_1004516A4( _Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, void **a10)
{
  uint64_t v19 = v17;
  uint64_t v20 = v14;
  sub_10023BF24(v16, *v19);
  sub_100242E28(v20);
  a10 = (void **)(v11 + 368);
  sub_1004569D8(&a10);
  sub_100032BD4(v11 + 352);
  sub_100242E28(v15);
  sub_100456990(v11 + 256, *v18);
  sub_100242E28(v13);
  sub_100242E28(v12);
  sub_100242E28(v10);
  _Unwind_Resume(a1);
}

uint64_t sub_100451738(uint64_t a1)
{
  *(void *)a1 = off_100899370;
  *(void *)(a1 + _Block_object_dispose((const void *)(v2 - 88), 8) = off_100899430;
  *(void *)(a1 + 16) = off_100899450;
  *(void *)(a1 + 24) = off_100899478;
  *(void *)(a1 + sub_100242FAC(v1 - 32) = off_1008994A0;
  *(void *)(a1 + 4sub_100414D2C(qword_1008F72C0, 0) = &off_1008994D0;
  sub_10023BF24(a1 + 584, *(void **)(a1 + 592));
  sub_100242E28(a1 + 520);
  sub_10023BF24(a1 + 456, *(void **)(a1 + 464));
  sub_100242E28(a1 + 392);
  uint64_t v3 = (void **)(a1 + 368);
  sub_1004569D8(&v3);
  sub_100032BD4(a1 + 352);
  sub_100242E28(a1 + 280);
  sub_100456990(a1 + 256, *(void **)(a1 + 264));
  sub_100242E28(a1 + 192);
  sub_100242E28(a1 + 120);
  sub_100242E28(a1 + 48);
  return a1;
}

uint64_t sub_1004517F8(uint64_t a1)
{
  return sub_100451738(a1 - 16);
}

void sub_100451800(uint64_t a1)
{
  uint64_t v1 = (void *)sub_100451738(a1);
  operator delete(v1);
}

void sub_100451814(uint64_t a1)
{
  uint64_t v1 = (void *)sub_100451738(a1 - 16);
  operator delete(v1);
}

uint64_t sub_10045182C(uint64_t a1)
{
  if (qword_1008D67E8 != -1) {
    dispatch_once(&qword_1008D67E8, &stru_1008995C0);
  }
  sub_1000762CC((uint64_t)off_1008D67E0 + 24, a1 + 24);
  if (qword_1008D6608 != -1) {
    dispatch_once(&qword_1008D6608, &stru_1008995E0);
  }
  sub_10004FAD0((uint64_t)off_1008D6600 + 1872, a1 + 40);
  v27[0] = 0LL;
  v27[1] = 0LL;
  uint64_t v2 = sub_100242F28((uint64_t)v27, a1 + 48);
  *(_BYTE *)(a1 + 112) = 1;
  sub_100242F54(v2);
  sub_100451DEC(a1);
  uint64_t v3 = sub_1002E6BF0();
  if ((*(unsigned int (**)(uint64_t))(*(void *)v3 + 648LL))(v3))
  {
    uint64_t v4 = sub_1002E6E00();
    sub_10002418C(buf, "ScanCorePageScan");
    sub_10002418C(__p, "ScanCorePageScanDebugEnabled");
    int v5 = (*(uint64_t (**)(uint64_t, uint8_t *, void **, uint64_t))(*(void *)v4 + 72LL))( v4,  buf,  __p,  a1 + 497);
    if (v24 < 0) {
      operator delete(__p[0]);
    }
    if (v26 < 0)
    {
      operator delete(*(void **)buf);
      if (!v5) {
        goto LABEL_45;
      }
    }

    else if (!v5)
    {
LABEL_45:
      uint64_t v14 = sub_1002E6E00();
      if ((*(unsigned int (**)(uint64_t))(*(void *)v14 + 624LL))(v14))
      {
        LOBYTE(__p[0]) = 0;
        sub_100242CA4(__p);
        uint64_t v15 = (os_log_s *)qword_1008F7590;
        if (os_log_type_enabled((os_log_t)qword_1008F7590, OS_LOG_TYPE_DEFAULT))
        {
          *(_WORD *)__int128 buf = 0;
          _os_log_impl((void *)&_mh_execute_header, v15, OS_LOG_TYPE_DEFAULT, "Disabling BT Page Scans", buf, 2u);
        }

        sub_1001214B4(71, 0LL, v16, v17, v18, v19, v20, v21, 1LL);
        sub_100242CD8(__p);
      }

      return sub_100242FAC((uint64_t)v27);
    }

    if (*(_BYTE *)(a1 + 497))
    {
      uint64_t v6 = sub_1002E6E00();
      sub_10002418C(buf, "ScanCorePageScan");
      sub_10002418C(__p, "ScanCorePageScanInterval");
      (*(void (**)(uint64_t, uint8_t *, void **, uint64_t))(*(void *)v6 + 128LL))(v6, buf, __p, a1 + 500);
      if (v24 < 0) {
        operator delete(__p[0]);
      }
      if (v26 < 0) {
        operator delete(*(void **)buf);
      }
      uint64_t v7 = sub_1002E6E00();
      sub_10002418C(buf, "ScanCorePageScan");
      sub_10002418C(__p, "ScanCorePageScanWindow");
      (*(void (**)(uint64_t, uint8_t *, void **, uint64_t))(*(void *)v7 + 128LL))(v7, buf, __p, a1 + 504);
      if (v24 < 0) {
        operator delete(__p[0]);
      }
      if (v26 < 0) {
        operator delete(*(void **)buf);
      }
      uint64_t v8 = sub_1002E6E00();
      sub_10002418C(buf, "ScanCorePageScan");
      sub_10002418C(__p, "ScanCorePageScanInterlaced");
      (*(void (**)(uint64_t, uint8_t *, void **, uint64_t))(*(void *)v8 + 72LL))(v8, buf, __p, a1 + 508);
      if (v24 < 0) {
        operator delete(__p[0]);
      }
      if (v26 < 0) {
        operator delete(*(void **)buf);
      }
      uint64_t v9 = sub_1002E6E00();
      sub_10002418C(buf, "ScanCorePageScan");
      sub_10002418C(__p, "ScanCorePageScanDebugElnaMode");
      (*(void (**)(uint64_t, uint8_t *, void **, uint64_t))(*(void *)v9 + 72LL))(v9, buf, __p, a1 + 509);
      if (v24 < 0) {
        operator delete(__p[0]);
      }
      if (v26 < 0) {
        operator delete(*(void **)buf);
      }
      uint64_t v10 = sub_1002E6E00();
      sub_10002418C(buf, "ScanCorePageScan");
      sub_10002418C(__p, "ScanCorePageScanUseAuxScanParams");
      (*(void (**)(uint64_t, uint8_t *, void **, uint64_t))(*(void *)v10 + 72LL))(v10, buf, __p, a1 + 510);
      if (v24 < 0) {
        operator delete(__p[0]);
      }
      if (v26 < 0) {
        operator delete(*(void **)buf);
      }
      uint64_t v11 = sub_1002E6E00();
      sub_10002418C(buf, "ScanCorePageScan");
      sub_10002418C(__p, "ScanCorePageScanEnableAuxScan");
      (*(void (**)(uint64_t, uint8_t *, void **, uint64_t))(*(void *)v11 + 72LL))(v11, buf, __p, a1 + 511);
      if (v24 < 0) {
        operator delete(__p[0]);
      }
      if (v26 < 0) {
        operator delete(*(void **)buf);
      }
      uint64_t v12 = sub_1002E6E00();
      sub_10002418C(buf, "ScanCorePageScan");
      sub_10002418C(__p, "ScanCorePageScanPreemptAuxScan");
      (*(void (**)(uint64_t, uint8_t *, void **, uint64_t))(*(void *)v12 + 72LL))(v12, buf, __p, a1 + 512);
      if (v24 < 0) {
        operator delete(__p[0]);
      }
      if (v26 < 0) {
        operator delete(*(void **)buf);
      }
      uint64_t v13 = sub_1002E6E00();
      sub_10002418C(buf, "ScanCorePageScan");
      sub_10002418C(__p, "ScanCorePageScanAuxScanDurationInMs");
      (*(void (**)(uint64_t, uint8_t *, void **, uint64_t))(*(void *)v13 + 128LL))(v13, buf, __p, a1 + 516);
      if (v24 < 0) {
        operator delete(__p[0]);
      }
      if (v26 < 0) {
        operator delete(*(void **)buf);
      }
    }

    goto LABEL_45;
  }

  return sub_100242FAC((uint64_t)v27);
}

void sub_100451D30( _Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void *__p, uint64_t a11, int a12, __int16 a13, char a14, char a15, void *a16, uint64_t a17, int a18, __int16 a19, char a20, char a21)
{
  if (a15 < 0) {
    operator delete(__p);
  }
  if (a21 < 0) {
    operator delete(a16);
  }
  sub_100242FAC(v21 - 48);
  _Unwind_Resume(a1);
}

BOOL sub_100451DEC(uint64_t a1)
{
  uint64_t v39 = 0LL;
  uint64_t v40 = 0LL;
  uint64_t v41 = 0LL;
  v38[0] = 0LL;
  v38[1] = 0LL;
  sub_100242F28((uint64_t)v38, a1 + 120);
  v37[0] = 0LL;
  v37[1] = 0LL;
  sub_100242F28((uint64_t)v37, a1 + 280);
  int v2 = *(unsigned __int8 *)(a1 + 184);
  if (*(_BYTE *)(a1 + 184))
  {
    uint64_t v3 = *(void *)(a1 + 368);
    if (v3 == *(void *)(a1 + 376) || *(_DWORD *)(*(void *)v3 + 76LL) != 2)
    {
      uint64_t v11 = qword_1008F7590;
      if (os_log_type_enabled((os_log_t)qword_1008F7590, OS_LOG_TYPE_INFO))
      {
        *(_DWORD *)__int128 buf = 67109120;
        *(_DWORD *)&uint8_t buf[4] = v2;
        uint64_t v8 = "Scanning is paused with a count of %d - returning";
        uint64_t v9 = (os_log_s *)v11;
        uint32_t v10 = 8;
LABEL_13:
        _os_log_impl((void *)&_mh_execute_header, v9, OS_LOG_TYPE_INFO, v8, buf, v10);
      }

void sub_1004522C8( _Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, ...)
{
  uint64_t v12 = va_arg(va1, void);
  uint64_t v14 = va_arg(va1, void);
  va_copy(va2, va1);
  uint64_t v15 = va_arg(va2, void);
  uint64_t v17 = va_arg(va2, void);
  sub_100242FAC((uint64_t)va);
  sub_100242FAC((uint64_t)va1);
  sub_100242FAC((uint64_t)va2);
  sub_100032BD4(v10);
  _Unwind_Resume(a1);
}

uint64_t sub_100452330(uint64_t a1)
{
  return sub_10045182C(a1 - 32);
}

uint64_t sub_100452338(uint64_t a1)
{
  int v2 = (os_log_s *)qword_1008F7590;
  if (os_log_type_enabled((os_log_t)qword_1008F7590, OS_LOG_TYPE_DEFAULT))
  {
    *(_WORD *)__int128 buf = 0;
    _os_log_impl((void *)&_mh_execute_header, v2, OS_LOG_TYPE_DEFAULT, "DManager::stackWillStop enter", buf, 2u);
  }

  if (qword_1008D67E8 != -1) {
    dispatch_once(&qword_1008D67E8, &stru_1008995C0);
  }
  sub_100009168((uint64_t)off_1008D67E0 + 24, a1 + 24);
  if (qword_1008D6608 != -1) {
    dispatch_once(&qword_1008D6608, &stru_1008995E0);
  }
  sub_100009168((uint64_t)off_1008D6600 + 1872, a1 + 40);
  *(void *)__int128 buf = 0LL;
  uint64_t v18 = 0LL;
  sub_100242F28((uint64_t)buf, a1 + 48);
  *(_BYTE *)(a1 + 112) = 0;
  sub_100242F54((uint64_t)buf);
  v16[0] = 0LL;
  v16[1] = 0LL;
  sub_100242F28((uint64_t)v16, a1 + 280);
  uint64_t v3 = *(int **)(a1 + 344);
  if (v3)
  {
    uint64_t v4 = (os_log_s *)qword_1008F7590;
    if (os_log_type_enabled((os_log_t)qword_1008F7590, OS_LOG_TYPE_DEFAULT))
    {
      uint64_t v5 = v3[19];
      else {
        uint64_t v6 = off_1008996B8[v5];
      }
      *(_DWORD *)uint64_t v19 = 136446210;
      *(void *)&v19[4] = v6;
      _os_log_impl((void *)&_mh_execute_header, v4, OS_LOG_TYPE_DEFAULT, "Stopping current %{public}s scan", v19, 0xCu);
      uint64_t v3 = *(int **)(a1 + 344);
    }

    (*(void (**)(int *))(*(void *)v3 + 24LL))(v3);
  }

  int v7 = 101;
  while (*(void *)(a1 + 344))
  {
    if (!--v7)
    {
      uint64_t v11 = sub_1002E6E00();
      uint64_t v12 = *(unsigned int *)(*(void *)(a1 + 344) + 76LL);
      sub_10002418C(v15, "");
      sub_1004FB370(v11, v12, (uint64_t)v15, 1);
    }

    sub_100242F54((uint64_t)v16);
    j__usleep(0x186A0u);
    sub_100242ECC((uint64_t)v16);
  }

  sub_100242F54((uint64_t)v16);
  *(_OWORD *)uint64_t v19 = 0uLL;
  uint64_t v8 = sub_100242F28((uint64_t)v19, a1 + 120);
  *(_BYTE *)(a1 + 184) = 0;
  sub_100242F54(v8);
  v14[0] = 0LL;
  v14[1] = 0LL;
  sub_100242F28((uint64_t)v14, a1 + 392);
  sub_100452674(a1);
  uint64_t v9 = (os_log_s *)qword_1008F7590;
  if (os_log_type_enabled((os_log_t)qword_1008F7590, OS_LOG_TYPE_DEFAULT))
  {
    *(_WORD *)uint64_t v13 = 0;
    _os_log_impl((void *)&_mh_execute_header, v9, OS_LOG_TYPE_DEFAULT, "DManager::stackWillStop exit", v13, 2u);
  }

  sub_100242FAC((uint64_t)v14);
  sub_100242FAC((uint64_t)v19);
  sub_100242FAC((uint64_t)v16);
  return sub_100242FAC((uint64_t)buf);
}

void sub_1004525FC( _Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, char a10, uint64_t a11, void *__p, uint64_t a13, int a14, __int16 a15, char a16, char a17, char a18, uint64_t a19, char a20)
{
}

uint64_t sub_100452674(uint64_t a1)
{
  v6[0] = 0LL;
  v6[1] = 0LL;
  sub_100242F28((uint64_t)v6, a1 + 392);
  int v2 = *(dispatch_source_s **)(a1 + 488);
  if (v2)
  {
    uint64_t v3 = (os_log_s *)qword_1008F7590;
    if (os_log_type_enabled((os_log_t)qword_1008F7590, OS_LOG_TYPE_DEFAULT))
    {
      *(_WORD *)uint64_t v5 = 0;
      _os_log_impl((void *)&_mh_execute_header, v3, OS_LOG_TYPE_DEFAULT, "Stopping Scan Core Page Scan timer", v5, 2u);
      int v2 = *(dispatch_source_s **)(a1 + 488);
    }

    dispatch_source_cancel(v2);
    dispatch_release(*(dispatch_object_t *)(a1 + 488));
    *(void *)(a1 + 48_Block_object_dispose((const void *)(v2 - 88), 8) = 0LL;
  }

  return sub_100242FAC((uint64_t)v6);
}

uint64_t sub_10045271C(uint64_t a1)
{
  return sub_100452338(a1 - 32);
}

uint64_t sub_100452724@<X0>( uint64_t a1@<X0>, unint64_t a2@<X1>, unint64_t *a3@<X2>, uint64_t *a4@<X8>)
{
  if (qword_1008D61A8 != -1) {
    dispatch_once(&qword_1008D61A8, &stru_100899560);
  }
  uint64_t v8 = sub_100496954((void *)qword_1008D61A0, a2);
  v16[0] = 0LL;
  v16[1] = 0LL;
  sub_100242F28((uint64_t)v16, a1 + 192);
  if (qword_1008D61A8 != -1) {
    dispatch_once(&qword_1008D61A8, &stru_100899560);
  }
  unint64_t v9 = sub_100496E90(qword_1008D61A0, a2);
  *a3 = v9;
  *a4 = 0LL;
  a4[1] = 0LL;
  if (v9)
  {
    sub_100456AD4(a4);
    __p[0] = a3;
    uint64_t v10 = sub_100456BA4((uint64_t **)(a1 + 256), a3, (uint64_t)&unk_1006C2518, (uint64_t **)__p);
    sub_100452954(v10 + 5, a4);
    uint64_t v11 = (os_log_s *)qword_1008F7590;
    if (os_log_type_enabled((os_log_t)qword_1008F7590, OS_LOG_TYPE_DEFAULT))
    {
      if (v8)
      {
        sub_100494958(v8, (uint64_t)__p);
        if (v15 >= 0) {
          uint64_t v12 = __p;
        }
        else {
          uint64_t v12 = (void **)__p[0];
        }
        *(_DWORD *)__int128 buf = 136446210;
        uint64_t v18 = (const char *)v12;
        _os_log_impl( (void *)&_mh_execute_header,  v11,  OS_LOG_TYPE_DEFAULT,  "Creating discovery agent %{public}s",  buf,  0xCu);
        if (v15 < 0) {
          operator delete(__p[0]);
        }
      }

      else
      {
        *(_DWORD *)__int128 buf = 136446210;
        uint64_t v18 = "(NULL)";
        _os_log_impl( (void *)&_mh_execute_header,  v11,  OS_LOG_TYPE_DEFAULT,  "Creating discovery agent %{public}s",  buf,  0xCu);
      }
    }
  }

  return sub_100242FAC((uint64_t)v16);
}

void sub_100452924(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, ...)
{
}

void *sub_100452954(void *a1, uint64_t *a2)
{
  uint64_t v4 = *a2;
  uint64_t v3 = a2[1];
  if (v3)
  {
    uint64_t v5 = (unint64_t *)(v3 + 8);
    do
      unint64_t v6 = __ldxr(v5);
    while (__stxr(v6 + 1, v5));
  }

  int v7 = (std::__shared_weak_count *)a1[1];
  *a1 = v4;
  a1[1] = v3;
  if (v7)
  {
    p_shared_owners = (unint64_t *)&v7->__shared_owners_;
    do
      unint64_t v9 = __ldaxr(p_shared_owners);
    while (__stlxr(v9 - 1, p_shared_owners));
    if (!v9)
    {
      ((void (*)(std::__shared_weak_count *))v7->__on_zero_shared)(v7);
      std::__shared_weak_count::__release_weak(v7);
    }
  }

  return a1;
}

uint64_t sub_1004529CC@<X0>(uint64_t a1@<X0>, unint64_t a2@<X1>, void *a3@<X8>)
{
  v16[0] = 0LL;
  v16[1] = 0LL;
  sub_100242F28((uint64_t)v16, a1 + 192);
  if (!a2) {
    goto LABEL_13;
  }
  unint64_t v6 = *(void **)(a1 + 264);
  if (!v6) {
    goto LABEL_13;
  }
  int v7 = (void *)(a1 + 264);
  do
  {
    unint64_t v8 = v6[4];
    BOOL v9 = v8 >= a2;
    if (v8 >= a2) {
      uint64_t v10 = v6;
    }
    else {
      uint64_t v10 = v6 + 1;
    }
    if (v9) {
      int v7 = v6;
    }
    unint64_t v6 = (void *)*v10;
  }

  while (*v10);
  if (v7 != (void *)(a1 + 264) && v7[4] <= a2)
  {
    uint64_t v13 = v7[5];
    uint64_t v12 = v7[6];
    *a3 = v13;
    a3[1] = v12;
    if (v12)
    {
      uint64_t v14 = (unint64_t *)(v12 + 8);
      do
        unint64_t v15 = __ldxr(v14);
      while (__stxr(v15 + 1, v14));
    }
  }

  else
  {
LABEL_13:
    *a3 = 0LL;
    a3[1] = 0LL;
  }

  return sub_100242FAC((uint64_t)v16);
}

uint64_t sub_100452A84(uint64_t a1, uint64_t *a2)
{
  uint64_t v3 = a1;
  v17[0] = 0LL;
  v17[1] = 0LL;
  sub_100242F28((uint64_t)v17, a1 + 192);
  if (*a2)
  {
    uint64_t v4 = *(void **)(v3 + 256);
    uint64_t v5 = (void *)(v3 + 264);
    if (v4 != (void *)(v3 + 264))
    {
      do
      {
        uint64_t v7 = v4[5];
        unint64_t v6 = (std::__shared_weak_count *)v4[6];
        if (v6)
        {
          p_shared_owners = (unint64_t *)&v6->__shared_owners_;
          do
            unint64_t v9 = __ldxr(p_shared_owners);
          while (__stxr(v9 + 1, p_shared_owners));
        }

        uint64_t v10 = *a2;
        if (v7 == *a2)
        {
          uint64_t v3 = v4[4];
          if (v6)
          {
LABEL_10:
            uint64_t v11 = (unint64_t *)&v6->__shared_owners_;
            do
              unint64_t v12 = __ldaxr(v11);
            while (__stlxr(v12 - 1, v11));
            if (!v12)
            {
              ((void (*)(std::__shared_weak_count *))v6->__on_zero_shared)(v6);
              std::__shared_weak_count::__release_weak(v6);
            }
          }
        }

        else if (v6)
        {
          goto LABEL_10;
        }

        if (v7 == v10) {
          goto LABEL_22;
        }
        uint64_t v13 = (void *)v4[1];
        if (v13)
        {
          do
          {
            uint64_t v14 = v13;
            uint64_t v13 = (void *)*v13;
          }

          while (v13);
        }

        else
        {
          do
          {
            uint64_t v14 = (void *)v4[2];
            BOOL v15 = *v14 == (void)v4;
            uint64_t v4 = v14;
          }

          while (!v15);
        }

        uint64_t v4 = v14;
      }

      while (v14 != v5);
    }
  }

  uint64_t v3 = 0LL;
LABEL_22:
  sub_100242FAC((uint64_t)v17);
  return v3;
}

uint64_t sub_100452BA4(void *a1, unint64_t a2)
{
  unint64_t v40 = a2;
  if (qword_1008D61A8 != -1) {
    dispatch_once(&qword_1008D61A8, &stru_100899560);
  }
  uint64_t v4 = sub_100496954((void *)qword_1008D61A0, a2);
  uint64_t v5 = (os_log_s *)qword_1008F7590;
  if (os_log_type_enabled((os_log_t)qword_1008F7590, OS_LOG_TYPE_DEFAULT))
  {
    if (v4)
    {
      sub_100494958(v4, (uint64_t)__p);
      if (v39 >= 0) {
        unint64_t v6 = __p;
      }
      else {
        unint64_t v6 = (void **)__p[0];
      }
      *(_DWORD *)__int128 buf = 136446210;
      *(void *)&uint8_t buf[4] = v6;
      _os_log_impl( (void *)&_mh_execute_header,  v5,  OS_LOG_TYPE_DEFAULT,  "Destroying discovery agent %{public}s",  buf,  0xCu);
      if (v39 < 0) {
        operator delete(__p[0]);
      }
    }

    else
    {
      *(_DWORD *)__int128 buf = 136446210;
      *(void *)&uint8_t buf[4] = "(NULL)";
      _os_log_impl( (void *)&_mh_execute_header,  v5,  OS_LOG_TYPE_DEFAULT,  "Destroying discovery agent %{public}s",  buf,  0xCu);
    }
  }

  *(_OWORD *)__int128 buf = 0uLL;
  sub_100242F28((uint64_t)buf, (uint64_t)(a1 + 24));
  if (v40)
  {
    uint64_t v7 = (void *)a1[33];
    if (v7)
    {
      unint64_t v8 = (uint64_t **)(a1 + 32);
      unint64_t v9 = a1 + 33;
      do
      {
        unint64_t v10 = v7[4];
        BOOL v11 = v10 >= v40;
        if (v10 >= v40) {
          unint64_t v12 = v7;
        }
        else {
          unint64_t v12 = v7 + 1;
        }
        if (v11) {
          unint64_t v9 = v7;
        }
        uint64_t v7 = (void *)*v12;
      }

      while (*v12);
      if (v9 != a1 + 33 && v40 >= v9[4])
      {
        uint64_t v13 = v9[5];
        uint64_t v14 = v9[6];
        uint64_t v36 = v13;
        __int16 v37 = (std::__shared_weak_count *)v14;
        if (v14)
        {
          BOOL v15 = (unint64_t *)(v14 + 8);
          do
            unint64_t v16 = __ldxr(v15);
          while (__stxr(v16 + 1, v15));
          uint64_t v34 = v13;
          id v35 = (std::__shared_weak_count *)v14;
          do
            unint64_t v17 = __ldxr(v15);
          while (__stxr(v17 + 1, v15));
        }

        else
        {
          uint64_t v34 = v13;
          id v35 = 0LL;
        }

        sub_1004530CC(a1, &v34);
        uint64_t v18 = v35;
        if (v35)
        {
          p_shared_owners = (unint64_t *)&v35->__shared_owners_;
          do
            unint64_t v20 = __ldaxr(p_shared_owners);
          while (__stlxr(v20 - 1, p_shared_owners));
          if (!v20)
          {
            ((void (*)(std::__shared_weak_count *))v18->__on_zero_shared)(v18);
            std::__shared_weak_count::__release_weak(v18);
          }
        }

        __p[0] = 0LL;
        __p[1] = 0LL;
        *(void *)uint64_t v41 = &v40;
        uint64_t v21 = sub_100456BA4(v8, &v40, (uint64_t)&unk_1006C2518, (uint64_t **)v41);
        sub_1002102FC((uint64_t)(v21 + 5), (__int128 *)__p);
        uint64_t v22 = (std::__shared_weak_count *)__p[1];
        if (__p[1])
        {
          uint8_t v23 = (unint64_t *)((char *)__p[1] + 8);
          do
            unint64_t v24 = __ldaxr(v23);
          while (__stlxr(v24 - 1, v23));
          if (!v24)
          {
            ((void (*)(std::__shared_weak_count *))v22->__on_zero_shared)(v22);
            std::__shared_weak_count::__release_weak(v22);
          }
        }

        sub_1001FDBCC(v8, v9);
        sub_100032BD4((uint64_t)(v9 + 5));
        operator delete(v9);
        if (sub_100487C4C())
        {
          CTGreenTeaOsLogHandle = (os_log_s *)getCTGreenTeaOsLogHandle(qword_1008F7720);
          unint64_t v26 = CTGreenTeaOsLogHandle;
          if (CTGreenTeaOsLogHandle)
          {
            if (os_log_type_enabled(CTGreenTeaOsLogHandle, OS_LOG_TYPE_INFO))
            {
              if (v4)
              {
                sub_100494958(v4, (uint64_t)__p);
                if (v39 >= 0) {
                  uint64_t v27 = __p;
                }
                else {
                  uint64_t v27 = (void **)__p[0];
                }
                *(_DWORD *)uint64_t v41 = 136446210;
                *(void *)&_DWORD v41[4] = v27;
                _os_log_impl( (void *)&_mh_execute_header,  v26,  OS_LOG_TYPE_INFO,  "Session %{public}s is asking to destroy scan agent",  v41,  0xCu);
                if (v39 < 0) {
                  operator delete(__p[0]);
                }
              }

              else
              {
                *(_DWORD *)uint64_t v41 = 136446210;
                *(void *)&_DWORD v41[4] = "(NULL)";
                _os_log_impl( (void *)&_mh_execute_header,  v26,  OS_LOG_TYPE_INFO,  "Session %{public}s is asking to destroy scan agent",  v41,  0xCu);
              }
            }
          }
        }

        __int16 v28 = (os_log_s *)qword_1008F7590;
        if (os_log_type_enabled((os_log_t)qword_1008F7590, OS_LOG_TYPE_DEFAULT))
        {
          if (v4)
          {
            sub_100494958(v4, (uint64_t)__p);
            if (v39 >= 0) {
              unint64_t v29 = __p;
            }
            else {
              unint64_t v29 = (void **)__p[0];
            }
            *(_DWORD *)uint64_t v41 = 136446210;
            *(void *)&_DWORD v41[4] = v29;
            _os_log_impl( (void *)&_mh_execute_header,  v28,  OS_LOG_TYPE_DEFAULT,  "Session %{public}s is asking to destroy scan agent",  v41,  0xCu);
            if (v39 < 0) {
              operator delete(__p[0]);
            }
          }

          else
          {
            *(_DWORD *)uint64_t v41 = 136446210;
            *(void *)&_DWORD v41[4] = "(NULL)";
            _os_log_impl( (void *)&_mh_execute_header,  v28,  OS_LOG_TYPE_DEFAULT,  "Session %{public}s is asking to destroy scan agent",  v41,  0xCu);
          }
        }

        if (qword_1008D61A8 != -1) {
          dispatch_once(&qword_1008D61A8, &stru_100899560);
        }
        sub_100497354(qword_1008D61A0, v40);
        int v30 = v37;
        if (v37)
        {
          int v31 = (unint64_t *)&v37->__shared_owners_;
          do
            unint64_t v32 = __ldaxr(v31);
          while (__stlxr(v32 - 1, v31));
          if (!v32)
          {
            ((void (*)(std::__shared_weak_count *))v30->__on_zero_shared)(v30);
            std::__shared_weak_count::__release_weak(v30);
          }
        }
      }
    }
  }

  return sub_100242FAC((uint64_t)buf);
}

void sub_100453080(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, ...)
{
  uint64_t v5 = va_arg(va1, void);
  uint64_t v7 = va_arg(va1, void);
  uint64_t v8 = va_arg(va1, void);
  uint64_t v9 = va_arg(va1, void);
  uint64_t v10 = va_arg(va1, void);
  uint64_t v11 = va_arg(va1, void);
  uint64_t v12 = va_arg(va1, void);
  uint64_t v13 = va_arg(va1, void);
  uint64_t v14 = va_arg(va1, void);
  sub_100032BD4((uint64_t)va);
  sub_100242FAC((uint64_t)va1);
  _Unwind_Resume(a1);
}

uint64_t sub_1004530CC(void *a1, uint64_t *a2)
{
  if (qword_1008D61A8 != -1) {
    dispatch_once(&qword_1008D61A8, &stru_100899560);
  }
  uint64_t v4 = (void *)qword_1008D61A0;
  uint64_t v5 = (std::__shared_weak_count *)a2[1];
  v35[0] = *a2;
  v35[1] = (uint64_t)v5;
  if (v5)
  {
    p_shared_owners = (unint64_t *)&v5->__shared_owners_;
    do
      unint64_t v7 = __ldxr(p_shared_owners);
    while (__stxr(v7 + 1, p_shared_owners));
  }

  unint64_t v8 = sub_100452A84((uint64_t)a1, v35);
  uint64_t v9 = sub_100496954(v4, v8);
  if (v5)
  {
    uint64_t v10 = (unint64_t *)&v5->__shared_owners_;
    do
      unint64_t v11 = __ldaxr(v10);
    while (__stlxr(v11 - 1, v10));
    if (!v11)
    {
      ((void (*)(std::__shared_weak_count *))v5->__on_zero_shared)(v5);
      std::__shared_weak_count::__release_weak(v5);
    }
  }

  v34[0] = 0LL;
  v34[1] = 0LL;
  sub_100242F28((uint64_t)v34, (uint64_t)(a1 + 35));
  uint64_t v12 = a1[46];
  if (v12 != a1[47])
  {
    while (1)
    {
      std::stringbuf::string_type __p = 0LL;
      uint64_t v32 = 0LL;
      uint64_t v33 = 0LL;
      uint64_t v13 = *(void **)v12;
      uint64_t v14 = *(void *)(v12 + 8);
      std::stringbuf::string_type __p = *(void **)v12;
      uint64_t v32 = v14;
      BOOL v15 = *(std::__shared_weak_count **)(v12 + 16);
      uint64_t v33 = v15;
      if (v15)
      {
        unint64_t v16 = (unint64_t *)&v15->__shared_owners_;
        do
          unint64_t v17 = __ldxr(v16);
        while (__stxr(v17 + 1, v16));
      }

      if (v14 == *a2) {
        break;
      }
      v12 += 24LL;
      if (v15) {
        goto LABEL_24;
      }
LABEL_28:
      if (v12 == a1[47]) {
        goto LABEL_29;
      }
    }

    if (v13) {
      (*(void (**)(void *))(*(void *)v13 + 8LL))(v13);
    }
    sub_100456F30((void *)(v12 + 24), (void *)a1[47], (void *)v12);
    uint64_t v19 = v18;
    uint64_t v20 = a1[47];
    if (v20 != v18)
    {
      do
      {
        uint64_t v21 = v20 - 24;
        sub_100032BD4(v20 - 16);
        uint64_t v20 = v21;
      }

      while (v21 != v19);
      BOOL v15 = v33;
    }

    a1[47] = v19;
    uint64_t v12 = a1[46];
    if (!v15) {
      goto LABEL_28;
    }
LABEL_24:
    uint64_t v22 = (unint64_t *)&v15->__shared_owners_;
    do
      unint64_t v23 = __ldaxr(v22);
    while (__stlxr(v23 - 1, v22));
    if (!v23)
    {
      ((void (*)(std::__shared_weak_count *))v15->__on_zero_shared)(v15);
      std::__shared_weak_count::__release_weak(v15);
    }

    goto LABEL_28;
  }

void sub_100453410(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, ...)
{
}

uint64_t sub_100453458(uint64_t a1, unint64_t a2)
{
  if (qword_1008D61A8 != -1) {
    dispatch_once(&qword_1008D61A8, &stru_100899560);
  }
  uint64_t v4 = sub_100496954((void *)qword_1008D61A0, a2);
  uint64_t v5 = sub_1002E6E00();
  if ((*(unsigned int (**)(uint64_t))(*(void *)v5 + 8LL))(v5))
  {
    unint64_t v6 = (os_log_s *)qword_1008F7590;
    if (os_log_type_enabled((os_log_t)qword_1008F7590, OS_LOG_TYPE_DEFAULT))
    {
      if (v4)
      {
        sub_100494958(v4, (uint64_t)__p);
        if (v27 >= 0) {
          unint64_t v7 = __p;
        }
        else {
          unint64_t v7 = (void **)__p[0];
        }
        *(_DWORD *)__int128 buf = 136315394;
        *(void *)&uint8_t buf[4] = "sessionDetached";
        *(_WORD *)&_BYTE buf[12] = 2082;
        *(void *)&_BYTE buf[14] = v7;
        _os_log_impl( (void *)&_mh_execute_header,  v6,  OS_LOG_TYPE_DEFAULT,  "%s - session %{public}s is detaching",  buf,  0x16u);
        if (v27 < 0) {
          operator delete(__p[0]);
        }
      }

      else
      {
        *(_DWORD *)__int128 buf = 136315394;
        *(void *)&uint8_t buf[4] = "sessionDetached";
        *(_WORD *)&_BYTE buf[12] = 2082;
        *(void *)&_BYTE buf[14] = "(NULL)";
        _os_log_impl( (void *)&_mh_execute_header,  v6,  OS_LOG_TYPE_DEFAULT,  "%s - session %{public}s is detaching",  buf,  0x16u);
      }
    }
  }

  __p[0] = 0LL;
  __p[1] = 0LL;
  sub_100242F28((uint64_t)__p, a1 + 192);
  unint64_t v8 = *(uint64_t **)(a1 + 256);
  if (v8 != (uint64_t *)(a1 + 264))
  {
    do
    {
      unint64_t v9 = v8[4];
      if (qword_1008D61A8 != -1) {
        dispatch_once(&qword_1008D61A8, &stru_100899560);
      }
      if (sub_10049729C(qword_1008D61A0, v9) == a2)
      {
        uint64_t v13 = v8[6];
        *(void *)__int128 buf = v8[5];
        *(void *)&uint8_t buf[8] = v13;
        if (v13)
        {
          uint64_t v14 = (unint64_t *)(v13 + 8);
          do
            unint64_t v15 = __ldxr(v14);
          while (__stxr(v15 + 1, v14));
        }

        sub_1001FDBCC((uint64_t **)(a1 + 256), v8);
        sub_100032BD4((uint64_t)(v8 + 5));
        operator delete(v8);
        unint64_t v11 = *(uint64_t **)(a1 + 256);
        unint64_t v16 = *(std::__shared_weak_count **)&buf[8];
        v25[0] = *(void *)buf;
        v25[1] = *(void *)&buf[8];
        if (*(void *)&buf[8])
        {
          unint64_t v17 = (unint64_t *)(*(void *)&buf[8] + 8LL);
          do
            unint64_t v18 = __ldxr(v17);
          while (__stxr(v18 + 1, v17));
        }

        sub_1004530CC((void *)a1, v25);
        if (v16)
        {
          p_shared_owners = (unint64_t *)&v16->__shared_owners_;
          do
            unint64_t v20 = __ldaxr(p_shared_owners);
          while (__stlxr(v20 - 1, p_shared_owners));
          if (!v20)
          {
            ((void (*)(std::__shared_weak_count *))v16->__on_zero_shared)(v16);
            std::__shared_weak_count::__release_weak(v16);
          }
        }

        if (qword_1008D61A8 != -1) {
          dispatch_once(&qword_1008D61A8, &stru_100899560);
        }
        sub_100497354(qword_1008D61A0, v9);
        uint64_t v21 = *(std::__shared_weak_count **)&buf[8];
        if (*(void *)&buf[8])
        {
          uint64_t v22 = (unint64_t *)(*(void *)&buf[8] + 8LL);
          do
            unint64_t v23 = __ldaxr(v22);
          while (__stlxr(v23 - 1, v22));
          if (!v23)
          {
            ((void (*)(std::__shared_weak_count *))v21->__on_zero_shared)(v21);
            std::__shared_weak_count::__release_weak(v21);
          }
        }
      }

      else
      {
        uint64_t v10 = (uint64_t *)v8[1];
        if (v10)
        {
          do
          {
            unint64_t v11 = v10;
            uint64_t v10 = (uint64_t *)*v10;
          }

          while (v10);
        }

        else
        {
          do
          {
            unint64_t v11 = (uint64_t *)v8[2];
            BOOL v12 = *v11 == (void)v8;
            unint64_t v8 = v11;
          }

          while (!v12);
        }
      }

      unint64_t v8 = v11;
    }

    while (v11 != (uint64_t *)(a1 + 264));
  }

  return sub_100242FAC((uint64_t)__p);
}

void sub_1004537BC( _Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, char a10, uint64_t a11, char a12, uint64_t a13, uint64_t a14, char a15)
{
}

uint64_t sub_1004537F8(uint64_t a1, unint64_t a2)
{
  return sub_100453458(a1 - 8, a2);
}

uint64_t sub_100453800(uint64_t a1)
{
  v4[0] = 0LL;
  v4[1] = 0LL;
  sub_100242F28((uint64_t)v4, a1 + 48);
  uint64_t v2 = *(unsigned __int8 *)(a1 + 185);
  sub_100242FAC((uint64_t)v4);
  return v2;
}

uint64_t sub_100453844(uint64_t a1, uint64_t *a2, unsigned int a3, int a4)
{
  uint64_t v6 = *a2;
  *(_DWORD *)(*a2 + 12) = a4;
  if (a3 < 2)
  {
    unint64_t v16 = (std::__shared_weak_count *)a2[1];
    uint64_t v31 = v6;
    uint64_t v32 = v16;
    if (v16)
    {
      p_shared_owners = (unint64_t *)&v16->__shared_owners_;
      do
        unint64_t v18 = __ldxr(p_shared_owners);
      while (__stxr(v18 + 1, p_shared_owners));
    }

    uint64_t v12 = sub_100453A20(a1, &v31);
    uint64_t v13 = v32;
    if (!v32) {
      return v12;
    }
    uint64_t v19 = (unint64_t *)&v32->__shared_owners_;
    do
      unint64_t v15 = __ldaxr(v19);
    while (__stlxr(v15 - 1, v19));
    goto LABEL_28;
  }

  if (a3 - 2 >= 2)
  {
    if (a3 != 4) {
      return 412LL;
    }
    if (qword_1008D63D8 != -1)
    {
      int v26 = a4;
      dispatch_once(&qword_1008D63D8, &stru_1008995A0);
      a4 = v26;
    }

    unint64_t v20 = off_1008D63D0;
    uint64_t v21 = (std::__shared_weak_count *)a2[1];
    uint64_t v27 = *a2;
    __int16 v28 = v21;
    if (v21)
    {
      uint64_t v22 = (unint64_t *)&v21->__shared_owners_;
      do
        unint64_t v23 = __ldxr(v22);
      while (__stxr(v23 + 1, v22));
    }

    uint64_t v12 = sub_100453E50((uint64_t)v20, &v27, a4);
    uint64_t v13 = v28;
    if (!v28) {
      return v12;
    }
    unint64_t v24 = (unint64_t *)&v28->__shared_owners_;
    do
      unint64_t v15 = __ldaxr(v24);
    while (__stlxr(v15 - 1, v24));
LABEL_28:
    if (!v15)
    {
      ((void (*)(std::__shared_weak_count *))v13->__on_zero_shared)(v13);
      std::__shared_weak_count::__release_weak(v13);
    }

    return v12;
  }

  uint64_t v7 = sub_1002E6BF0();
  uint64_t v8 = *a2;
  unint64_t v9 = (std::__shared_weak_count *)a2[1];
  uint64_t v29 = *a2;
  int v30 = v9;
  if (v9)
  {
    uint64_t v10 = (unint64_t *)&v9->__shared_owners_;
    do
      unint64_t v11 = __ldxr(v10);
    while (__stxr(v11 + 1, v10));
    uint64_t v8 = *a2;
  }

  uint64_t v12 = sub_100453C30(a1, &v29, *(unsigned __int8 *)(v8 + 8));
  uint64_t v13 = v30;
  if (v30)
  {
    uint64_t v14 = (unint64_t *)&v30->__shared_owners_;
    do
      unint64_t v15 = __ldaxr(v14);
    while (__stlxr(v15 - 1, v14));
    goto LABEL_28;
  }

  return v12;
}

void sub_1004539F4( _Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9)
{
}

uint64_t sub_100453A20(uint64_t a1, uint64_t *a2)
{
  unint64_t v23 = 0LL;
  uint64_t v24 = 0LL;
  uint64_t v25 = 0LL;
  char v22 = 0;
  if (qword_1008D5F00 != -1) {
    dispatch_once(&qword_1008D5F00, &stru_100899638);
  }
  else {
    BOOL v4 = v22 == 0;
  }
  if (v4)
  {
    v21[0] = 0LL;
    v21[1] = 0LL;
    sub_100242F28((uint64_t)v21, a1 + 48);
    if (*(_BYTE *)(a1 + 112))
    {
      sub_100242F54((uint64_t)v21);
      uint64_t v5 = operator new(0xE0uLL);
      sub_10043D0EC(v5, a1, 0LL);
      unint64_t v23 = v5;
      sub_100452954(&v24, a2);
      v20[0] = 0LL;
      v20[1] = 0LL;
      sub_100242F28((uint64_t)v20, a1 + 280);
      if (0xAAAAAAAAAAAAAAABLL * ((uint64_t)(*(void *)(a1 + 376) - *(void *)(a1 + 368)) >> 3) < 0x20)
      {
        sub_100454070((uint64_t *)(a1 + 368), (uint64_t)&v23);
        sub_100242F54((uint64_t)v20);
        sub_100451DEC(a1);
        uint64_t v6 = 0LL;
      }

      else
      {
        if (v23) {
          (*(void (**)(void *))(*(void *)v23 + 8LL))(v23);
        }
        uint64_t v6 = 411LL;
      }

      sub_100242FAC((uint64_t)v20);
    }

    else
    {
      uint64_t v6 = 111LL;
    }

    sub_100242FAC((uint64_t)v21);
  }

  else
  {
    uint64_t v7 = (os_log_s *)qword_1008F7590;
    if (os_log_type_enabled((os_log_t)qword_1008F7590, OS_LOG_TYPE_ERROR)) {
      sub_1006805B8(v7, v9, v10, v11, v12, v13, v14, v15);
    }
    uint64_t v6 = 211LL;
  }

  unint64_t v16 = v25;
  if (v25)
  {
    p_shared_owners = (unint64_t *)&v25->__shared_owners_;
    do
      unint64_t v18 = __ldaxr(p_shared_owners);
    while (__stlxr(v18 - 1, p_shared_owners));
    if (!v18)
    {
      ((void (*)(std::__shared_weak_count *))v16->__on_zero_shared)(v16);
      std::__shared_weak_count::__release_weak(v16);
    }
  }

  return v6;
}

void sub_100453BE4(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, ...)
{
}

uint64_t sub_100453C30(uint64_t a1, uint64_t *a2, uint64_t a3)
{
  uint64_t v25 = 0LL;
  uint64_t v26 = 0LL;
  uint64_t v27 = 0LL;
  char v24 = 0;
  if (qword_1008D5F00 != -1) {
    dispatch_once(&qword_1008D5F00, &stru_100899638);
  }
  else {
    BOOL v6 = v24 == 0;
  }
  if (v6)
  {
    v23[0] = 0LL;
    v23[1] = 0LL;
    sub_100242F28((uint64_t)v23, a1 + 48);
    if (*(_BYTE *)(a1 + 112))
    {
      sub_100242F54((uint64_t)v23);
      uint64_t v7 = operator new(0xE8uLL);
      sub_100445E6C(v7, a1, a3, 1LL);
      uint64_t v25 = v7;
      sub_100452954(&v26, a2);
      v22[0] = 0LL;
      v22[1] = 0LL;
      sub_100242F28((uint64_t)v22, a1 + 280);
      if (0xAAAAAAAAAAAAAAABLL * ((uint64_t)(*(void *)(a1 + 376) - *(void *)(a1 + 368)) >> 3) < 0x20)
      {
        sub_100454070((uint64_t *)(a1 + 368), (uint64_t)&v25);
        sub_100242F54((uint64_t)v22);
        sub_100451DEC(a1);
        uint64_t v8 = 0LL;
      }

      else
      {
        if (v25) {
          (*(void (**)(void *))(*(void *)v25 + 8LL))(v25);
        }
        uint64_t v8 = 411LL;
      }

      sub_100242FAC((uint64_t)v22);
    }

    else
    {
      uint64_t v8 = 111LL;
    }

    sub_100242FAC((uint64_t)v23);
  }

  else
  {
    uint64_t v9 = (os_log_s *)qword_1008F7590;
    if (os_log_type_enabled((os_log_t)qword_1008F7590, OS_LOG_TYPE_ERROR)) {
      sub_1006805B8(v9, v11, v12, v13, v14, v15, v16, v17);
    }
    uint64_t v8 = 211LL;
  }

  unint64_t v18 = v27;
  if (v27)
  {
    p_shared_owners = (unint64_t *)&v27->__shared_owners_;
    do
      unint64_t v20 = __ldaxr(p_shared_owners);
    while (__stlxr(v20 - 1, p_shared_owners));
    if (!v20)
    {
      ((void (*)(std::__shared_weak_count *))v18->__on_zero_shared)(v18);
      std::__shared_weak_count::__release_weak(v18);
    }
  }

  return v8;
}

void sub_100453E04(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, ...)
{
}

uint64_t sub_100453E50(uint64_t a1, uint64_t *a2, int a3)
{
  uint64_t v25 = 0LL;
  uint64_t v26 = 0LL;
  uint64_t v27 = 0LL;
  char v24 = 0;
  if (qword_1008D5F00 != -1) {
    dispatch_once(&qword_1008D5F00, &stru_100899638);
  }
  else {
    BOOL v6 = v24 == 0;
  }
  if (v6)
  {
    v23[0] = 0LL;
    v23[1] = 0LL;
    sub_100242F28((uint64_t)v23, a1 + 48);
    if (*(_BYTE *)(a1 + 112))
    {
      sub_100242F54((uint64_t)v23);
      uint64_t v7 = operator new(0xC0uLL);
      sub_10043AFF8((uint64_t)v7, a1, a3, 3);
      uint64_t v25 = v7;
      sub_100452954(&v26, a2);
      v22[0] = 0LL;
      v22[1] = 0LL;
      sub_100242F28((uint64_t)v22, a1 + 280);
      if (0xAAAAAAAAAAAAAAABLL * ((uint64_t)(*(void *)(a1 + 376) - *(void *)(a1 + 368)) >> 3) < 0x20)
      {
        sub_100454070((uint64_t *)(a1 + 368), (uint64_t)&v25);
        sub_100242F54((uint64_t)v22);
        sub_100451DEC(a1);
        uint64_t v8 = 0LL;
      }

      else
      {
        if (v25) {
          (*(void (**)(void *))(*(void *)v25 + 8LL))(v25);
        }
        uint64_t v8 = 411LL;
      }

      sub_100242FAC((uint64_t)v22);
    }

    else
    {
      uint64_t v8 = 111LL;
    }

    sub_100242FAC((uint64_t)v23);
  }

  else
  {
    uint64_t v9 = (os_log_s *)qword_1008F7590;
    if (os_log_type_enabled((os_log_t)qword_1008F7590, OS_LOG_TYPE_ERROR)) {
      sub_1006805B8(v9, v11, v12, v13, v14, v15, v16, v17);
    }
    uint64_t v8 = 211LL;
  }

  unint64_t v18 = v27;
  if (v27)
  {
    p_shared_owners = (unint64_t *)&v27->__shared_owners_;
    do
      unint64_t v20 = __ldaxr(p_shared_owners);
    while (__stlxr(v20 - 1, p_shared_owners));
    if (!v20)
    {
      ((void (*)(std::__shared_weak_count *))v18->__on_zero_shared)(v18);
      std::__shared_weak_count::__release_weak(v18);
    }
  }

  return v8;
}

void sub_100454024(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, ...)
{
}

uint64_t sub_100454070(uint64_t *a1, uint64_t a2)
{
  unint64_t v6 = a1[2];
  uint64_t result = (uint64_t)(a1 + 2);
  unint64_t v5 = v6;
  unint64_t v7 = *(void *)(result - 8);
  if (v7 >= v6)
  {
    unint64_t v12 = 0xAAAAAAAAAAAAAAABLL * ((uint64_t)(v7 - *a1) >> 3);
    unint64_t v13 = v12 + 1;
    if (v12 + 1 > 0xAAAAAAAAAAAAAAALL) {
      abort();
    }
    unint64_t v14 = 0xAAAAAAAAAAAAAAABLL * ((uint64_t)(v5 - *a1) >> 3);
    if (2 * v14 > v13) {
      unint64_t v13 = 2 * v14;
    }
    if (v14 >= 0x555555555555555LL) {
      unint64_t v15 = 0xAAAAAAAAAAAAAAALL;
    }
    else {
      unint64_t v15 = v13;
    }
    uint8_t v22[4] = result;
    uint64_t v16 = (char *)sub_10023F114(result, v15);
    uint64_t v17 = &v16[24 * v12];
    v22[0] = v16;
    v22[1] = v17;
    void v22[3] = &v16[24 * v18];
    *(_OWORD *)uint64_t v17 = *(_OWORD *)a2;
    uint64_t v19 = *(void *)(a2 + 16);
    *((void *)v17 + 2) = v19;
    if (v19)
    {
      unint64_t v20 = (unint64_t *)(v19 + 8);
      do
        unint64_t v21 = __ldxr(v20);
      while (__stxr(v21 + 1, v20));
    }

    void v22[2] = v17 + 24;
    sub_100456D14(a1, v22);
    uint64_t v11 = a1[1];
    uint64_t result = sub_100456D78((uint64_t)v22);
  }

  else
  {
    *(_OWORD *)unint64_t v7 = *(_OWORD *)a2;
    uint64_t v8 = *(void *)(a2 + 16);
    *(void *)(v7 + 16) = v8;
    if (v8)
    {
      uint64_t v9 = (unint64_t *)(v8 + 8);
      do
        unint64_t v10 = __ldxr(v9);
      while (__stxr(v10 + 1, v9));
    }

    uint64_t v11 = v7 + 24;
    a1[1] = v7 + 24;
  }

  a1[1] = v11;
  return result;
}

void sub_1004541A4(_Unwind_Exception *a1, uint64_t a2, ...)
{
}

uint64_t sub_1004541B8(uint64_t a1, uint64_t a2)
{
  unint64_t v15 = 0LL;
  uint64_t v16 = 0LL;
  uint64_t v17 = 0LL;
  v14[0] = 0LL;
  v14[1] = 0LL;
  sub_100242F28((uint64_t)v14, a1 + 48);
  if (*(_BYTE *)(a1 + 112))
  {
    sub_100242F54((uint64_t)v14);
    BOOL v4 = operator new(0xB0uLL);
    sub_10045AB74(v4, a1, a2, 2LL);
    unint64_t v5 = v17;
    uint64_t v16 = 0LL;
    uint64_t v17 = 0LL;
    unint64_t v15 = v4;
    if (v5)
    {
      p_shared_owners = (unint64_t *)&v5->__shared_owners_;
      do
        unint64_t v7 = __ldaxr(p_shared_owners);
      while (__stlxr(v7 - 1, p_shared_owners));
      if (!v7)
      {
        ((void (*)(std::__shared_weak_count *))v5->__on_zero_shared)(v5);
        std::__shared_weak_count::__release_weak(v5);
      }
    }

    v13[0] = 0LL;
    v13[1] = 0LL;
    sub_100242F28((uint64_t)v13, a1 + 280);
    sub_100454344((uint64_t *)(a1 + 368), *(_OWORD **)(a1 + 368), (unint64_t)&v15);
    sub_100242F54((uint64_t)v13);
    sub_100451DEC(a1);
    sub_100242FAC((uint64_t)v13);
    uint64_t v8 = 0LL;
  }

  else
  {
    uint64_t v8 = 111LL;
  }

  sub_100242FAC((uint64_t)v14);
  uint64_t v9 = v17;
  if (v17)
  {
    unint64_t v10 = (unint64_t *)&v17->__shared_owners_;
    do
      unint64_t v11 = __ldaxr(v10);
    while (__stlxr(v11 - 1, v10));
    if (!v11)
    {
      ((void (*)(std::__shared_weak_count *))v9->__on_zero_shared)(v9);
      std::__shared_weak_count::__release_weak(v9);
    }
  }

  return v8;
}

void sub_1004542F4(_Unwind_Exception *a1, uint64_t a2, ...)
{
  uint64_t v3 = va_arg(va1, void);
  uint64_t v5 = va_arg(va1, void);
  va_copy(va2, va1);
  uint64_t v6 = va_arg(va2, void);
  uint64_t v8 = va_arg(va2, void);
  uint64_t v9 = va_arg(va2, void);
  sub_100242FAC((uint64_t)va);
  sub_100242FAC((uint64_t)va1);
  sub_100032BD4((uint64_t)va2);
  _Unwind_Resume(a1);
}

void *sub_100454344(uint64_t *a1, _OWORD *a2, unint64_t a3)
{
  BOOL v4 = a2;
  uint64_t v7 = *a1;
  unint64_t v6 = a1[1];
  uint64_t v8 = (uint64_t)a2 - *a1;
  int64_t v9 = 0xAAAAAAAAAAAAAAABLL * (v8 >> 3);
  uint64_t v11 = (uint64_t)(a1 + 2);
  unint64_t v10 = a1[2];
  if (v6 >= v10)
  {
    unint64_t v12 = 0xAAAAAAAAAAAAAAABLL * ((uint64_t)(v6 - v7) >> 3) + 1;
    if (v12 > 0xAAAAAAAAAAAAAAALL) {
      abort();
    }
    unint64_t v13 = 0xAAAAAAAAAAAAAAABLL * ((uint64_t)(v10 - v7) >> 3);
    if (2 * v13 > v12) {
      unint64_t v12 = 2 * v13;
    }
    if (v13 >= 0x555555555555555LL) {
      unint64_t v14 = 0xAAAAAAAAAAAAAAALL;
    }
    else {
      unint64_t v14 = v12;
    }
    __int16 v38 = a1 + 2;
    if (v14)
    {
      unint64_t v15 = (char *)sub_10023F114((uint64_t)(a1 + 2), v14);
      uint64_t v17 = v16;
    }

    else
    {
      unint64_t v15 = 0LL;
      uint64_t v17 = 0LL;
    }

    unint64_t v21 = &v15[8 * (v8 >> 3)];
    id v35 = v15;
    *(void *)&__int128 v36 = v21;
    *((void *)&v36 + 1) = v21;
    __int16 v37 = &v15[24 * v17];
    if (v9 == v17)
    {
      if (v8 < 1)
      {
        if ((void *)v7 == v4) {
          unint64_t v23 = 1LL;
        }
        else {
          unint64_t v23 = 0x5555555555555556LL * (v8 >> 3);
        }
        uint64_t v42 = v11;
        char v24 = (char *)sub_10023F114(v11, v23);
        uint64_t v26 = v36;
        if (*((void *)&v36 + 1) == (void)v36)
        {
          int64x2_t v29 = vdupq_n_s64(v36);
          uint64_t v27 = (uint64_t)&v24[24 * (v23 >> 2)];
        }

        else
        {
          uint64_t v27 = (uint64_t)&v24[24 * (v23 >> 2) + *((void *)&v36 + 1) - v36];
          __int16 v28 = &v24[24 * (v23 >> 2)];
          do
          {
            *(_OWORD *)__int16 v28 = *(_OWORD *)v26;
            *((void *)v28 + 2) = *(void *)(v26 + 16);
            *(void *)(v26 + _Block_object_dispose((const void *)(v2 - 88), 8) = 0LL;
            *(void *)(v26 + 16) = 0LL;
            v28 += 24;
            v26 += 24LL;
          }

          while (v28 != (char *)v27);
          int64x2_t v29 = (int64x2_t)v36;
        }

        int v30 = v37;
        char v39 = v35;
        id v35 = v24;
        *(void *)&__int128 v36 = &v24[24 * (v23 >> 2)];
        int64x2_t v40 = v29;
        *((void *)&v36 + 1) = v27;
        __int16 v37 = &v24[24 * v25];
        uint64_t v41 = v30;
        sub_100456D78((uint64_t)&v39);
        unint64_t v21 = (char *)*((void *)&v36 + 1);
      }

      else
      {
        if (v9 >= -1) {
          uint64_t v22 = v9 + 1;
        }
        else {
          uint64_t v22 = v9 + 2;
        }
        sub_100456F30(&v15[8 * (v8 >> 3)], v21, &v21[-24 * (v22 >> 1)]);
        *(void *)&__int128 v36 = v36 - 24 * (v22 >> 1);
        *((void *)&v36 + 1) = v21;
      }
    }

    *(_OWORD *)unint64_t v21 = *(_OWORD *)a3;
    uint64_t v31 = *(void *)(a3 + 16);
    *((void *)v21 + 2) = v31;
    if (v31)
    {
      uint64_t v32 = (unint64_t *)(v31 + 8);
      do
        unint64_t v33 = __ldxr(v32);
      while (__stxr(v33 + 1, v32));
      unint64_t v21 = (char *)*((void *)&v36 + 1);
    }

    *((void *)&v36 + 1) = v21 + 24;
    BOOL v4 = (void *)sub_100456E20(a1, &v35, (uint64_t)v4);
    sub_100456D78((uint64_t)&v35);
  }

  else if (a2 == (_OWORD *)v6)
  {
    *a2 = *(_OWORD *)a3;
    uint64_t v18 = *(void *)(a3 + 16);
    *(void *)(v7 + 8 * (v8 >> 3) + 16) = v18;
    if (v18)
    {
      uint64_t v19 = (unint64_t *)(v18 + 8);
      do
        unint64_t v20 = __ldxr(v19);
      while (__stxr(v20 + 1, v19));
    }

    a1[1] = (uint64_t)a2 + 24;
  }

  else
  {
    sub_100456DC8((uint64_t)a1, (uint64_t)a2, v6, (uint64_t)a2 + 24);
    *BOOL v4 = *(void *)a3;
    sub_100452954((void *)(v7 + 8 * (v8 >> 3) + 8), (uint64_t *)(a3 + 8));
  }

  return v4;
}

void sub_100454604( _Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9)
{
}

uint64_t sub_100454618(uint64_t a1)
{
  return sub_100454620(*(void *)(a1 + 32));
}

uint64_t sub_100454620(uint64_t a1)
{
  v7[0] = 0LL;
  v7[1] = 0LL;
  sub_100242F28((uint64_t)v7, a1 + 280);
  uint64_t v2 = *(int **)(a1 + 344);
  if (v2)
  {
    sub_100242F54((uint64_t)v7);
    uint64_t v3 = (os_log_s *)qword_1008F7590;
    if (os_log_type_enabled((os_log_t)qword_1008F7590, OS_LOG_TYPE_INFO))
    {
      uint64_t v4 = v2[19];
      else {
        uint64_t v5 = off_1008996B8[v4];
      }
      *(_DWORD *)__int128 buf = 136446210;
      int64_t v9 = v5;
      _os_log_impl((void *)&_mh_execute_header, v3, OS_LOG_TYPE_INFO, "Running new %{public}s scan", buf, 0xCu);
    }

    (*(void (**)(int *))(*(void *)v2 + 16LL))(v2);
  }

  return sub_100242FAC((uint64_t)v7);
}

void sub_100454718(_Unwind_Exception *exception_object)
{
}

uint64_t sub_100454734(uint64_t a1)
{
  v11[0] = 0LL;
  v11[1] = 0LL;
  sub_100242F28((uint64_t)v11, a1 + 120);
  int v2 = *(unsigned __int8 *)(a1 + 184);
  unsigned __int8 v3 = v2 + 1;
  *(_BYTE *)(a1 + 184) = v2 + 1;
  if (v2)
  {
    uint64_t v4 = (os_log_s *)qword_1008F7590;
    if (os_log_type_enabled((os_log_t)qword_1008F7590, OS_LOG_TYPE_INFO))
    {
      *(_DWORD *)__int128 buf = 67109120;
      *(_DWORD *)&uint8_t buf[4] = v3;
      _os_log_impl( (void *)&_mh_execute_header,  v4,  OS_LOG_TYPE_INFO,  "Pausing an already paused scan - new count is %d",  buf,  8u);
    }
  }

  else
  {
    *(void *)__int128 buf = 0LL;
    uint64_t v15 = 0LL;
    sub_100242F28((uint64_t)buf, a1 + 280);
    uint64_t v5 = *(int **)(a1 + 344);
    unint64_t v6 = (os_log_s *)qword_1008F7590;
    BOOL v7 = os_log_type_enabled((os_log_t)qword_1008F7590, OS_LOG_TYPE_INFO);
    if (v5)
    {
      if (v7)
      {
        uint64_t v8 = v5[19];
        else {
          int64_t v9 = off_1008996B8[v8];
        }
        *(_DWORD *)unint64_t v12 = 136446210;
        unint64_t v13 = v9;
        _os_log_impl((void *)&_mh_execute_header, v6, OS_LOG_TYPE_INFO, "Pausing current %{public}s scan", v12, 0xCu);
        uint64_t v5 = *(int **)(a1 + 344);
      }

      (*(void (**)(int *))(*(void *)v5 + 24LL))(v5);
    }

    else if (v7)
    {
      *(_WORD *)unint64_t v12 = 0;
      _os_log_impl((void *)&_mh_execute_header, v6, OS_LOG_TYPE_INFO, "Pausing DManager", v12, 2u);
    }

    sub_100242FAC((uint64_t)buf);
  }

  return sub_100242FAC((uint64_t)v11);
}

void sub_1004548E0( _Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, char a13)
{
}

uint64_t sub_10045490C(uint64_t a1)
{
  v7[0] = 0LL;
  v7[1] = 0LL;
  sub_100242F28((uint64_t)v7, a1 + 120);
  char v2 = *(_BYTE *)(a1 + 184);
  if (v2)
  {
    unsigned __int8 v3 = v2 - 1;
    *(_BYTE *)(a1 + 184) = v2 - 1;
    uint64_t v4 = (os_log_s *)qword_1008F7590;
    if (os_log_type_enabled((os_log_t)qword_1008F7590, OS_LOG_TYPE_INFO))
    {
      *(_DWORD *)__int128 buf = 67109120;
      int v9 = v3;
      _os_log_impl((void *)&_mh_execute_header, v4, OS_LOG_TYPE_INFO, "Resuming a scan - new count is %d", buf, 8u);
      unsigned __int8 v3 = *(_BYTE *)(a1 + 184);
    }

    if (!v3)
    {
      sub_100242F54((uint64_t)v7);
      sub_100451DEC(a1);
    }
  }

  else
  {
    uint64_t v5 = (os_log_s *)qword_1008F7590;
    if (os_log_type_enabled((os_log_t)qword_1008F7590, OS_LOG_TYPE_INFO))
    {
      *(_WORD *)__int128 buf = 0;
      _os_log_impl( (void *)&_mh_execute_header,  v5,  OS_LOG_TYPE_INFO,  "Tried to resume a scan that wasn't paused!",  buf,  2u);
    }
  }

  return sub_100242FAC((uint64_t)v7);
}

void sub_100454A44( _Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9)
{
}

uint64_t sub_100454A60(uint64_t a1, uint64_t a2)
{
  v9[0] = 0LL;
  v9[1] = 0LL;
  sub_100242F28((uint64_t)v9, a1 + 280);
  uint64_t v4 = (os_log_s *)qword_1008F7590;
  if (os_log_type_enabled((os_log_t)qword_1008F7590, OS_LOG_TYPE_INFO))
  {
    uint64_t v5 = *(int *)(a2 + 76);
    else {
      unint64_t v6 = off_1008996B8[v5];
    }
    *(_DWORD *)__int128 buf = 136446210;
    uint64_t v11 = v6;
    _os_log_impl((void *)&_mh_execute_header, v4, OS_LOG_TYPE_INFO, "%{public}s scan started", buf, 0xCu);
  }

  if (*(void *)(a1 + 344) == a2)
  {
    uint64_t v7 = *(void *)(a1 + 352);
    if (v7) {
      (*(void (**)(uint64_t))(*(void *)v7 + 16LL))(v7);
    }
  }

  sub_100242F54((uint64_t)v9);
  *(_BYTE *)(a1 + 185) = 1;
  if (qword_1008D5F00 != -1) {
    dispatch_once(&qword_1008D5F00, &stru_100899638);
  }
  sub_10040B078((uint64_t)off_1008D5EF8, 6);
  return sub_100242FAC((uint64_t)v9);
}

void sub_100454BAC(_Unwind_Exception *exception_object)
{
}

uint64_t sub_100454BC8(uint64_t a1, uint64_t a2)
{
  v6[0] = 0LL;
  v6[1] = 0LL;
  sub_100242F28((uint64_t)v6, a1 + 280);
  if (*(void *)(a1 + 344))
  {
    uint64_t v4 = *(void *)(a1 + 352);
    if (v4) {
      (*(void (**)(uint64_t, uint64_t))(*(void *)v4 + 40LL))(v4, a2);
    }
  }

  sub_100242F54((uint64_t)v6);
  return sub_100242FAC((uint64_t)v6);
}

void sub_100454C30( _Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9)
{
}

uint64_t sub_100454C44(uint64_t a1, uint64_t a2)
{
  uint64_t v4 = (os_log_s *)qword_1008F7590;
  if (os_log_type_enabled((os_log_t)qword_1008F7590, OS_LOG_TYPE_DEFAULT))
  {
    sub_1003CF00C(a2, __p);
    uint64_t v5 = v8 >= 0 ? __p : (void **)__p[0];
    *(_DWORD *)__int128 buf = 136446210;
    unint64_t v10 = v5;
    _os_log_impl( (void *)&_mh_execute_header,  v4,  OS_LOG_TYPE_DEFAULT,  "Sending 'name changed' event for device %{public}s",  buf,  0xCu);
    if (v8 < 0) {
      operator delete(__p[0]);
    }
  }

  if (qword_1008D60D0 != -1) {
    dispatch_once(&qword_1008D60D0, &stru_100899658);
  }
  sub_1004267B0((uint64_t)off_1008D60C8, a2, 0xFFFFFFFFLL, 0LL, 701LL, 0LL);
  return (*(uint64_t (**)(uint64_t, uint64_t))(*(void *)a1 + 8LL))(a1, a2);
}

uint64_t sub_100454D7C(uint64_t a1, uint64_t a2)
{
  v6[0] = 0LL;
  v6[1] = 0LL;
  sub_100242F28((uint64_t)v6, a1 + 280);
  if (*(void *)(a1 + 344))
  {
    uint64_t v4 = *(void *)(a1 + 352);
    if (v4) {
      (*(void (**)(uint64_t, uint64_t))(*(void *)v4 + 32LL))(v4, a2);
    }
  }

  sub_100242F54((uint64_t)v6);
  return sub_100242FAC((uint64_t)v6);
}

void sub_100454DE4( _Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9)
{
}

uint64_t sub_100454DF8(uint64_t a1, uint64_t a2)
{
  v6[0] = 0LL;
  v6[1] = 0LL;
  sub_100242F28((uint64_t)v6, a1 + 280);
  if (*(void *)(a1 + 344))
  {
    uint64_t v4 = *(void *)(a1 + 352);
    if (v4) {
      (*(void (**)(uint64_t, uint64_t))(*(void *)v4 + 48LL))(v4, a2);
    }
  }

  sub_100242F54((uint64_t)v6);
  return sub_100242FAC((uint64_t)v6);
}

void sub_100454E60( _Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9)
{
}

void sub_100454E74(uint64_t a1)
{
  if (!*(_BYTE *)(a1 + 112)) {
    goto LABEL_6;
  }
  if (qword_1008D6788 != -1) {
    dispatch_once(&qword_1008D6788, &stru_100899678);
  }
  if (sub_1002075B4((uint64_t)off_1008D6780) == 1)
  {
    uint64_t v2 = sub_100404EB8();
    v3[0] = _NSConcreteStackBlock;
    v3[1] = 3221225472LL;
    void v3[2] = sub_100454F2C;
    void v3[3] = &unk_10087EB20;
    void v3[4] = a1;
    sub_100405384(v2, v3);
  }

  else
  {
LABEL_6:
    sub_100454F34(a1);
  }

uint64_t sub_100454F2C(uint64_t a1)
{
  return sub_100454F34(*(void *)(a1 + 32));
}

uint64_t sub_100454F34(uint64_t a1)
{
  v11[0] = 0LL;
  v11[1] = 0LL;
  sub_100242F28((uint64_t)v11, a1 + 280);
  uint64_t v2 = *(void *)(a1 + 352);
  if (v2)
  {
    (*(void (**)(uint64_t))(*(void *)v2 + 24LL))(v2);
    *(void *)__int128 buf = 0LL;
    *(void *)&uint8_t buf[8] = 0LL;
    sub_1002102FC(a1 + 352, (__int128 *)buf);
    unsigned __int8 v3 = *(std::__shared_weak_count **)&buf[8];
    if (*(void *)&buf[8])
    {
      uint64_t v4 = (unint64_t *)(*(void *)&buf[8] + 8LL);
      do
        unint64_t v5 = __ldaxr(v4);
      while (__stlxr(v5 - 1, v4));
      if (!v5)
      {
        ((void (*)(std::__shared_weak_count *))v3->__on_zero_shared)(v3);
        std::__shared_weak_count::__release_weak(v3);
      }
    }
  }

  unint64_t v6 = *(int **)(a1 + 344);
  uint64_t v7 = (os_log_s *)qword_1008F7590;
  if (v6)
  {
    if (!os_log_type_enabled((os_log_t)qword_1008F7590, OS_LOG_TYPE_DEFAULT)
      || ((uint64_t v8 = v6[19], v8 > 3) ? (v9 = 0LL) : (v9 = off_1008996B8[v8]),
          *(_DWORD *)__int128 buf = 136446210,
          *(void *)&uint8_t buf[4] = v9,
          _os_log_impl((void *)&_mh_execute_header, v7, OS_LOG_TYPE_DEFAULT, "%{public}s scan completed", buf, 0xCu),
          (unint64_t v6 = *(int **)(a1 + 344)) != 0LL))
    {
      (*(void (**)(int *))(*(void *)v6 + 8LL))(v6);
    }

    *(void *)(a1 + 344) = 0LL;
  }

  else if (os_log_type_enabled((os_log_t)qword_1008F7590, OS_LOG_TYPE_INFO))
  {
    *(_WORD *)__int128 buf = 0;
    _os_log_impl((void *)&_mh_execute_header, v7, OS_LOG_TYPE_INFO, "Scan completed", buf, 2u);
  }

  sub_100242F54((uint64_t)v11);
  if (!sub_100451DEC(a1))
  {
    *(_BYTE *)(a1 + 185) = 0;
    if (qword_1008D5F00 != -1) {
      dispatch_once(&qword_1008D5F00, &stru_100899638);
    }
    sub_10040B078((uint64_t)off_1008D5EF8, 7);
  }

  return sub_100242FAC((uint64_t)v11);
}

void sub_10045511C(_Unwind_Exception *exception_object)
{
}

uint64_t sub_100455138(uint64_t a1, uint64_t a2, _DWORD *a3, int a4)
{
  int v20 = 0;
  unsigned __int8 v19 = 0;
  v18[0] = 0LL;
  v18[1] = 0LL;
  sub_100242F28((uint64_t)v18, a1 + 280);
  if (*(void *)(a1 + 344))
  {
    uint64_t v8 = *(void *)(a1 + 352);
    if (v8)
    {
      unsigned __int8 v19 = sub_10044EC38(v8, a2, &v20, a4);
      if ((v19 & 1) == 0)
      {
        uint64_t v9 = sub_1002E6BF0();
        if ((*(unsigned int (**)(uint64_t))(*(void *)v9 + 352LL))(v9) && *(_DWORD *)(a2 + 1508) == 2)
        {
          unint64_t v10 = (os_log_s *)qword_1008F7590;
          if (os_log_type_enabled((os_log_t)qword_1008F7590, OS_LOG_TYPE_DEFAULT))
          {
            sub_1003CF00C(a2, __p);
            if ((v17 & 0x80u) == 0) {
              uint64_t v11 = __p;
            }
            else {
              uint64_t v11 = (void **)__p[0];
            }
            *(_DWORD *)__int128 buf = 136446210;
            uint64_t v22 = v11;
            _os_log_impl( (void *)&_mh_execute_header,  v10,  OS_LOG_TYPE_DEFAULT,  "Received LE CarPlay in EIR from %{public}s, ignore it",  buf,  0xCu);
          }
        }

        else
        {
          unsigned int v12 = *(_DWORD *)(*(void *)(a1 + 352) + 12LL) & 0xFFFFF7FF;
          if (qword_1008D60D0 != -1) {
            dispatch_once(&qword_1008D60D0, &stru_100899658);
          }
          sub_100429174((uint64_t)off_1008D60C8, a2, v12, &v19, &v20);
          if (v19)
          {
            sub_1003D01A0(a2, (uint64_t)__p);
            if ((v17 & 0x80u) == 0) {
              unint64_t v13 = v17;
            }
            else {
              unint64_t v13 = (unint64_t)__p[1];
            }
            if (!v13) {
              v20 |= 4u;
            }
          }
        }
      }
    }
  }

  sub_100242F54((uint64_t)v18);
  *a3 = v20;
  uint64_t v14 = v19;
  sub_100242FAC((uint64_t)v18);
  return v14;
}

void sub_100455334(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, ...)
{
}

void sub_100455360(uint64_t a1, uint64_t a2)
{
  uint64_t v4 = sub_100404EB8();
  v5[0] = _NSConcreteStackBlock;
  v5[1] = 3221225472LL;
  void v5[2] = sub_1004553C4;
  void v5[3] = &unk_10087F8E0;
  void v5[4] = a1;
  void v5[5] = a2;
  sub_100405384(v4, v5);
}

void sub_1004553C4(uint64_t a1)
{
}

void sub_1004553DC(uint64_t a1, unsigned int a2, unsigned __int8 *a3, int a4, int a5)
{
  unsigned __int8 v101 = a3;
  uint64_t v9 = sub_1002E6BF0();
  unint64_t v10 = (os_log_s *)qword_1008F7590;
  if (os_log_type_enabled((os_log_t)qword_1008F7590, OS_LOG_TYPE_DEFAULT))
  {
    uint64_t v11 = "unknown";
    unsigned int v12 = "unknown";
    if (a2 <= 2) {
      unsigned int v12 = off_1008996D8[a2];
    }
    int v13 = *(_DWORD *)(a1 + 480);
    if (v13 == 1) {
      uint64_t v11 = "SCAN_CORE_PAGE_SCAN_ENABLE";
    }
    if (!v13) {
      uint64_t v11 = "SCAN_CORE_PAGE_SCAN_IDLE";
    }
    *(_DWORD *)__int128 buf = 136315394;
    *(void *)&uint8_t buf[4] = v12;
    *(_WORD *)&_BYTE buf[12] = 2080;
    uint64_t v107 = (uint64_t)v11;
    _os_log_impl( (void *)&_mh_execute_header,  v10,  OS_LOG_TYPE_DEFAULT,  "Received Scan Core Page Scan Request for event: %s, scanCorePageScanState: %s",  buf,  0x16u);
  }

  if (*(_BYTE *)(a1 + 497))
  {
    int v14 = *(_DWORD *)(a1 + 500);
    a4 = *(_DWORD *)(a1 + 504);
    int v15 = *(unsigned __int8 *)(a1 + 508);
    int v16 = *(unsigned __int8 *)(a1 + 509);
    int v17 = *(unsigned __int8 *)(a1 + 510);
    int v18 = *(unsigned __int8 *)(a1 + 511);
    int v19 = *(unsigned __int8 *)(a1 + 512);
    int v20 = *(_DWORD *)(a1 + 516);
  }

  else
  {
    int v16 = 0;
    int v15 = 0;
    LOWORD(v14) = word_1006C3182[5 * a4];
    LOWORD(a4) = 18;
    int v19 = 1;
    LOBYTE(v2sub_100414D2C(qword_1008F72C0, 0) = 50;
    int v18 = 1;
    int v17 = 1;
  }

  int v21 = *(_DWORD *)(a1 + 480);
  if (v21 == 1)
  {
    if (a2 == 2)
    {
      int v48 = v17;
      int v49 = v15;
      std::stringbuf::string_type v50 = (os_log_s *)qword_1008F7590;
      if (os_log_type_enabled((os_log_t)qword_1008F7590, OS_LOG_TYPE_DEFAULT))
      {
        *(_WORD *)__int128 buf = 0;
        _os_log_impl( (void *)&_mh_execute_header,  v50,  OS_LOG_TYPE_DEFAULT,  "Scan Core Page Scan timer expired. Clearing Scan Core Page Scan device set.",  buf,  2u);
      }

      sub_10023BF24(a1 + 456, *(void **)(a1 + 464));
      *(void *)(a1 + 4sub_100242FAC(v30 - 64) = 0LL;
      *(void *)(a1 + 472) = 0LL;
      *(void *)(a1 + 456) = a1 + 464;
      uint64_t v51 = sub_1002E6E9C();
      HIBYTE(v91) = v20;
      LOBYTE(v91) = v19 != 0;
      (*(void (**)(uint64_t, void, void, void, BOOL, BOOL, BOOL, BOOL, __int16))(*(void *)v51 + 3400LL))( v51,  0LL,  (unsigned __int16)v14,  (unsigned __int16)a4,  v49 != 0,  v16 != 0,  v48 != 0,  v18 != 0,  v91);
      sub_100452674(a1);
    }

    else
    {
      if (a2 != 1)
      {
        if (a2
          || !sub_1003CF350(v101)
          || sub_1003D0670((uint64_t)v101)
          || !sub_1003D2B2C((uint64_t)v101, 12))
        {
          return;
        }

        uint64_t v32 = *(void **)(a1 + 464);
        if (!v32) {
          goto LABEL_60;
        }
        uint64_t v33 = a1 + 464;
        do
        {
          unint64_t v34 = v32[4];
          BOOL v35 = v34 >= (unint64_t)v101;
          else {
            __int128 v36 = v32 + 1;
          }
          if (v35) {
            uint64_t v33 = (uint64_t)v32;
          }
          uint64_t v32 = (void *)*v36;
        }

        while (*v36);
        if (v33 != a1 + 464 && (unint64_t)v101 >= *(void *)(v33 + 32))
        {
          __int128 v82 = (os_log_s *)qword_1008F7590;
          if (os_log_type_enabled((os_log_t)qword_1008F7590, OS_LOG_TYPE_DEFAULT))
          {
            sub_1003CF00C((uint64_t)v101, buf);
            __int128 v83 = v108[1] >= 0 ? buf : *(_BYTE **)buf;
            *(_DWORD *)unsigned __int16 v102 = 136315138;
            *(void *)&v102[4] = v83;
            _os_log_impl( (void *)&_mh_execute_header,  v82,  OS_LOG_TYPE_DEFAULT,  "'%s' already present in Scan Core Page Scan device set.",  v102,  0xCu);
            if ((v108[1] & 0x80000000) != 0) {
              operator delete(*(void **)buf);
            }
          }
        }

        else
        {
LABEL_60:
          if (sub_1003E3C80((uint64_t)v101) > 4)
          {
            int v70 = *(char *)(a1 + 496);
            __int128 v71 = (os_log_s *)qword_1008F7590;
            BOOL v72 = os_log_type_enabled((os_log_t)qword_1008F7590, OS_LOG_TYPE_DEFAULT);
            if (a5 - v70 < 10)
            {
              if (v72)
              {
                sub_1003CF00C((uint64_t)v101, v102);
                if (v105 >= 0) {
                  __int128 v79 = v102;
                }
                else {
                  __int128 v79 = *(_BYTE **)v102;
                }
                __int128 v80 = "unknown";
                int v81 = *(_DWORD *)(a1 + 480);
                if (v81 == 1) {
                  __int128 v80 = "SCAN_CORE_PAGE_SCAN_ENABLE";
                }
                *(_DWORD *)__int128 buf = 136315650;
                *(void *)&uint8_t buf[4] = v79;
                *(_WORD *)&_BYTE buf[12] = 2080;
                uint64_t v107 = (uint64_t)"DEVICE_ADV_RECEIVED_EVENT";
                if (!v81) {
                  __int128 v80 = "SCAN_CORE_PAGE_SCAN_IDLE";
                }
                *(_WORD *)uint64_t v108 = 2080;
                *(void *)&v108[2] = v80;
                _os_log_impl( (void *)&_mh_execute_header,  v71,  OS_LOG_TYPE_DEFAULT,  "Reached maximum Scan Core Page Scan retries for Device '%s', Event: %s, State: %s.",  buf,  0x20u);
                if (v105 < 0) {
                  operator delete(*(void **)v102);
                }
              }
            }

            else
            {
              if (v72)
              {
                sub_1003CF00C((uint64_t)v101, v102);
                __int128 v73 = v105 >= 0 ? v102 : *(_BYTE **)v102;
                *(_DWORD *)__int128 buf = 67109890;
                *(_DWORD *)&uint8_t buf[4] = a5;
                *(_WORD *)&uint8_t buf[8] = 1024;
                *(_DWORD *)&buf[10] = v70;
                uint64_t v107 = 0x8200000000A0400LL;
                *(void *)uint64_t v108 = v73;
                _os_log_impl( (void *)&_mh_execute_header,  v71,  OS_LOG_TYPE_DEFAULT,  "Difference between currentLEAdvRSSI: %d and previousLEAdvRSSI:%d is greater than %d dB for device '%s'",  buf,  0x1Eu);
                if (v105 < 0) {
                  operator delete(*(void **)v102);
                }
              }

              BOOL v74 = sub_1003E3FF8((uint64_t)v101);
              __int128 v75 = v101;
              if (v74)
              {
                sub_1003E3EAC((uint64_t)v101);
                __int128 v75 = v101;
                ++*((_WORD *)v101 + 703);
              }

              sub_1003E3C40((uint64_t)v75);
              sub_1002555B0((uint64_t **)(a1 + 456), (unint64_t *)&v101, (uint64_t *)&v101);
              sub_100452674(a1);
              sub_100456494(a1, 60LL);
              sub_1003E3BF8((uint64_t)v101);
            }
          }

          else
          {
            __int16 v37 = (os_log_s *)qword_1008F7590;
            if (os_log_type_enabled((os_log_t)qword_1008F7590, OS_LOG_TYPE_DEFAULT))
            {
              sub_1003CF00C((uint64_t)v101, buf);
              __int16 v38 = v108[1] >= 0 ? buf : *(_BYTE **)buf;
              *(_DWORD *)unsigned __int16 v102 = 136315394;
              *(void *)&v102[4] = v38;
              __int16 v103 = 1024;
              int v104 = 60;
              _os_log_impl( (void *)&_mh_execute_header,  v37,  OS_LOG_TYPE_DEFAULT,  "'%s' not present in Scan Core Page Scan device set. Inserting it and resetting timer for %d seconds.",  v102,  0x12u);
              if ((v108[1] & 0x80000000) != 0) {
                operator delete(*(void **)buf);
              }
            }

            sub_1002555B0((uint64_t **)(a1 + 456), (unint64_t *)&v101, (uint64_t *)&v101);
            sub_100452674(a1);
            sub_100456494(a1, 60LL);
            sub_1003E3BF8((uint64_t)v101);
          }
        }

        return;
      }

      int v100 = v17;
      int v52 = v15;
      unsigned __int16 v97 = v14;
      sub_1003E3C40((uint64_t)v101);
      if (sub_1003E3FF8((uint64_t)v101))
      {
        sub_1003E3EAC((uint64_t)v101);
        ++*((_WORD *)v101 + 703);
      }

      __int128 v53 = *(void **)(a1 + 464);
      if (!v53) {
        return;
      }
      int v54 = v19;
      __int128 v55 = (uint64_t *)(a1 + 464);
      do
      {
        unint64_t v56 = v53[4];
        BOOL v57 = v56 >= (unint64_t)v101;
        else {
          uint64_t v58 = v53 + 1;
        }
        if (v57) {
          __int128 v55 = v53;
        }
        __int128 v53 = (void *)*v58;
      }

      while (*v58);
      log = (os_log_s *)qword_1008F7590;
      if (os_log_type_enabled((os_log_t)qword_1008F7590, OS_LOG_TYPE_DEFAULT))
      {
        sub_1003CF00C((uint64_t)v101, buf);
        if (v108[1] >= 0) {
          unsigned int v59 = buf;
        }
        else {
          unsigned int v59 = *(_BYTE **)buf;
        }
        *(_DWORD *)unsigned __int16 v102 = 136315138;
        *(void *)&v102[4] = v59;
        _os_log_impl( (void *)&_mh_execute_header,  log,  OS_LOG_TYPE_DEFAULT,  "'%s' connected. Removing it from Scan Core Page Scan device set.",  v102,  0xCu);
        if ((v108[1] & 0x80000000) != 0) {
          operator delete(*(void **)buf);
        }
        int v54 = v19;
      }

      sub_1001FDBCC((uint64_t **)(a1 + 456), v55);
      operator delete(v55);
      ++*((_WORD *)v101 + 705);
      if (*(void *)(a1 + 472)) {
        return;
      }
      __int16 v60 = (os_log_s *)qword_1008F7590;
      if (os_log_type_enabled((os_log_t)qword_1008F7590, OS_LOG_TYPE_DEFAULT))
      {
        *(_WORD *)__int128 buf = 0;
        _os_log_impl( (void *)&_mh_execute_header,  v60,  OS_LOG_TYPE_DEFAULT,  "Scan Core Page Scan device list is empty.",  buf,  2u);
      }

      uint64_t v61 = sub_1002E6E9C();
      HIBYTE(v92) = v20;
      LOBYTE(v92) = v54 != 0;
      (*(void (**)(uint64_t, void, void, void, BOOL, BOOL, BOOL, BOOL, __int16))(*(void *)v61 + 3400LL))( v61,  0LL,  v97,  (unsigned __int16)a4,  v52 != 0,  v16 != 0,  v100 != 0,  v18 != 0,  v92);
      sub_100452674(a1);
    }

    sub_1004565E4(a1, 0);
    return;
  }

  int v98 = v15;
  int v99 = v17;
  if (v21) {
    return;
  }
  switch(a2)
  {
    case 2u:
      char v39 = (os_log_s *)qword_1008F7590;
      if (os_log_type_enabled((os_log_t)qword_1008F7590, OS_LOG_TYPE_FAULT)) {
        sub_1006805E8(v39);
      }
      break;
    case 1u:
      int64x2_t v40 = *(void **)(a1 + 464);
      uint64_t v41 = v101;
      if (v40)
      {
        uint64_t v42 = a1 + 464;
        do
        {
          unint64_t v43 = v40[4];
          BOOL v44 = v43 >= (unint64_t)v101;
          else {
            uint64_t v45 = v40 + 1;
          }
          if (v44) {
            uint64_t v42 = (uint64_t)v40;
          }
          int64x2_t v40 = (void *)*v45;
        }

        while (*v45);
        if (v42 != a1 + 464 && (unint64_t)v101 >= *(void *)(v42 + 32))
        {
          char v46 = (os_log_s *)qword_1008F7590;
          if (os_log_type_enabled((os_log_t)qword_1008F7590, OS_LOG_TYPE_FAULT))
          {
            sub_1003CF00C((uint64_t)v101, v102);
            if (v105 >= 0) {
              __int128 v87 = v102;
            }
            else {
              __int128 v87 = *(_BYTE **)v102;
            }
            __int128 v88 = "unknown";
            int v89 = *(_DWORD *)(a1 + 480);
            if (v89 == 1) {
              __int128 v88 = "SCAN_CORE_PAGE_SCAN_ENABLE";
            }
            *(_DWORD *)__int128 buf = 136315650;
            *(void *)&uint8_t buf[4] = v87;
            *(_WORD *)&_BYTE buf[12] = 2080;
            uint64_t v107 = (uint64_t)"DEVICE_CONNECTED_EVENT";
            if (!v89) {
              __int128 v88 = "SCAN_CORE_PAGE_SCAN_IDLE";
            }
            *(_WORD *)uint64_t v108 = 2080;
            *(void *)&v108[2] = v88;
            _os_log_fault_impl( (void *)&_mh_execute_header,  v46,  OS_LOG_TYPE_FAULT,  "'%s' present in Scan Core Page Scan device set. Event: %s, State: %s.",  buf,  0x20u);
            if (v105 < 0) {
              operator delete(*(void **)v102);
            }
            uint64_t v41 = v101;
          }
        }
      }

      sub_1003E3C40((uint64_t)v41);
      __int128 v47 = v101;
      ++*((_WORD *)v101 + 706);
      if (sub_1003E3FF8((uint64_t)v47))
      {
        sub_1003E3EAC((uint64_t)v101);
        ++*((_WORD *)v101 + 703);
      }

      break;
    case 0u:
      uint64_t v22 = *(void **)(a1 + 464);
      unint64_t v23 = v101;
      if (v22)
      {
        uint64_t v24 = a1 + 464;
        do
        {
          unint64_t v25 = v22[4];
          BOOL v26 = v25 >= (unint64_t)v101;
          else {
            uint64_t v27 = v22 + 1;
          }
          if (v26) {
            uint64_t v24 = (uint64_t)v22;
          }
          uint64_t v22 = (void *)*v27;
        }

        while (*v27);
        if (v24 != a1 + 464 && (unint64_t)v101 >= *(void *)(v24 + 32))
        {
          uint64_t v96 = (os_log_s *)qword_1008F7590;
          if (os_log_type_enabled((os_log_t)qword_1008F7590, OS_LOG_TYPE_FAULT))
          {
            sub_1003CF00C((uint64_t)v101, v102);
            __int128 v84 = v102;
            if (v105 < 0) {
              __int128 v84 = *(_BYTE **)v102;
            }
            __int128 v85 = "unknown";
            int v86 = *(_DWORD *)(a1 + 480);
            if (v86 == 1) {
              __int128 v85 = "SCAN_CORE_PAGE_SCAN_ENABLE";
            }
            *(_DWORD *)__int128 buf = 136315650;
            *(void *)&uint8_t buf[4] = v84;
            *(_WORD *)&_BYTE buf[12] = 2080;
            uint64_t v107 = (uint64_t)"DEVICE_ADV_RECEIVED_EVENT";
            if (!v86) {
              __int128 v85 = "SCAN_CORE_PAGE_SCAN_IDLE";
            }
            *(_WORD *)uint64_t v108 = 2080;
            *(void *)&v108[2] = v85;
            _os_log_fault_impl( (void *)&_mh_execute_header,  v96,  OS_LOG_TYPE_FAULT,  "'%s' present in Scan Core Page Scan device set. Event: %s, State: %s.",  buf,  0x20u);
            if (v105 < 0) {
              operator delete(*(void **)v102);
            }
            unint64_t v23 = v101;
          }
        }
      }

      if (sub_1003CF350(v23))
      {
        int v28 = v19;
        if (!sub_1003D0670((uint64_t)v101))
        {
          if (sub_1003D2B2C((uint64_t)v101, 12))
          {
            uint64_t v95 = (uint64_t **)(a1 + 456);
            if (sub_1003E3C80((uint64_t)v101) <= 4)
            {
              int64x2_t v29 = (os_log_s *)qword_1008F7590;
              if (os_log_type_enabled((os_log_t)qword_1008F7590, OS_LOG_TYPE_DEFAULT))
              {
                sub_1003CF00C((uint64_t)v101, buf);
                int v30 = v108[1] >= 0 ? buf : *(_BYTE **)buf;
                *(_DWORD *)unsigned __int16 v102 = 136315138;
                *(void *)&v102[4] = v30;
                _os_log_impl( (void *)&_mh_execute_header,  v29,  OS_LOG_TYPE_DEFAULT,  "Adding '%s' into Scan Core Page Scan device set.",  v102,  0xCu);
                if ((v108[1] & 0x80000000) != 0) {
                  operator delete(*(void **)buf);
                }
              }

              sub_1002555B0(v95, (unint64_t *)&v101, (uint64_t *)&v101);
              uint64_t v31 = sub_1002E6E9C();
              HIBYTE(v9sub_100414D2C(qword_1008F72C0, 0) = v20;
              LOBYTE(v9sub_100414D2C(qword_1008F72C0, 0) = v28 != 0;
              (*(void (**)(uint64_t, uint64_t, void, void, BOOL, BOOL, BOOL, BOOL, __int16))(*(void *)v31 + 3400LL))( v31,  1LL,  (unsigned __int16)v14,  (unsigned __int16)a4,  v98 != 0,  v16 != 0,  v99 != 0,  v18 != 0,  v90);
              sub_100456494(a1, 60LL);
              sub_1004565E4(a1, 1);
              sub_1003E3BF8((uint64_t)v101);
              ++*((_WORD *)v101 + 694);
              return;
            }

            int v62 = *(char *)(a1 + 496);
            int v63 = (os_log_s *)qword_1008F7590;
            BOOL v64 = os_log_type_enabled((os_log_t)qword_1008F7590, OS_LOG_TYPE_DEFAULT);
            if (a5 - v62 >= 10)
            {
              if (v64)
              {
                sub_1003CF00C((uint64_t)v101, v102);
                int v65 = v105 >= 0 ? v102 : *(_BYTE **)v102;
                *(_DWORD *)__int128 buf = 67109890;
                *(_DWORD *)&uint8_t buf[4] = a5;
                *(_WORD *)&uint8_t buf[8] = 1024;
                *(_DWORD *)&buf[10] = v62;
                uint64_t v107 = 0x8200000000A0400LL;
                *(void *)uint64_t v108 = v65;
                _os_log_impl( (void *)&_mh_execute_header,  v63,  OS_LOG_TYPE_DEFAULT,  "Difference between currentLEAdvRSSI: %d and previousLEAdvRSSI:%d is greater than %d dB for device '%s'",  buf,  0x1Eu);
                if (v105 < 0) {
                  operator delete(*(void **)v102);
                }
              }

              BOOL v66 = sub_1003E3FF8((uint64_t)v101);
              int v67 = v101;
              if (v66)
              {
                sub_1003E3EAC((uint64_t)v101);
                int v67 = v101;
                ++*((_WORD *)v101 + 703);
              }

              sub_1003E3C40((uint64_t)v67);
              sub_1002555B0(v95, (unint64_t *)&v101, (uint64_t *)&v101);
              uint64_t v68 = sub_1002E6E9C();
              HIBYTE(v93) = v20;
              LOBYTE(v93) = v28 != 0;
              (*(void (**)(uint64_t, uint64_t, void, void, BOOL, BOOL, BOOL, BOOL, __int16))(*(void *)v68 + 3400LL))( v68,  1LL,  (unsigned __int16)v14,  (unsigned __int16)a4,  v98 != 0,  v16 != 0,  v99 != 0,  v18 != 0,  v93);
              sub_100456494(a1, 60LL);
              sub_1004565E4(a1, 1);
              sub_1003E3BF8((uint64_t)v101);
              __int128 v69 = v101;
              ++*((_WORD *)v101 + 694);
              ++*((_WORD *)v69 + 701);
              return;
            }

            if (v64)
            {
              sub_1003CF00C((uint64_t)v101, v102);
              if (v105 >= 0) {
                __int128 v76 = v102;
              }
              else {
                __int128 v76 = *(_BYTE **)v102;
              }
              __int128 v77 = "unknown";
              int v78 = *(_DWORD *)(a1 + 480);
              if (v78 == 1) {
                __int128 v77 = "SCAN_CORE_PAGE_SCAN_ENABLE";
              }
              *(_DWORD *)__int128 buf = 136315650;
              *(void *)&uint8_t buf[4] = v76;
              *(_WORD *)&_BYTE buf[12] = 2080;
              uint64_t v107 = (uint64_t)"DEVICE_ADV_RECEIVED_EVENT";
              if (!v78) {
                __int128 v77 = "SCAN_CORE_PAGE_SCAN_IDLE";
              }
              *(_WORD *)uint64_t v108 = 2080;
              *(void *)&v108[2] = v77;
              _os_log_impl( (void *)&_mh_execute_header,  v63,  OS_LOG_TYPE_DEFAULT,  "Reached max Scan Core Page Scan retries for Device '%s', Event: %s, State: %s.",  buf,  0x20u);
              if (v105 < 0) {
                operator delete(*(void **)v102);
              }
            }

            if (!sub_1003E3FF8((uint64_t)v101)) {
LABEL_146:
            }
              sub_1003E3CC4((uint64_t)v101);
          }
        }
      }

      break;
  }

void sub_100456258(uint64_t a1, uint64_t a2)
{
  uint64_t v3 = a1 - 24;
  uint64_t v4 = sub_100404EB8();
  v5[0] = _NSConcreteStackBlock;
  v5[1] = 3221225472LL;
  void v5[2] = sub_1004553C4;
  void v5[3] = &unk_10087F8E0;
  void v5[4] = v3;
  void v5[5] = a2;
  sub_100405384(v4, v5);
}

void sub_1004562BC(uint64_t a1, uint64_t a2, void *a3, uint64_t a4)
{
  id v7 = a3;
  int v8 = *(char *)(*(void *)(a4 + 8) + 216LL);
  if (qword_1008D60B0 != -1) {
    dispatch_once(&qword_1008D60B0, &stru_100899580);
  }
  if ((sub_1004313B0((uint64_t)off_1008D60A8) & 1) != 0
    || (uint64_t v9 = *(void *)(a4 + 8), !*(_BYTE *)(v9 + 363))
    || *(_BYTE *)(v9 + 217)
    || v8 < -85)
  {
    if (v8 <= -85)
    {
      if (qword_1008D5F50 != -1) {
        dispatch_once(&qword_1008D5F50, &stru_100899698);
      }
      uint64_t v11 = sub_10040007C(off_1008D5F48, a2, 0);
      if (v11) {
        ++v11[702];
      }
    }
  }

  else
  {
    uint64_t v10 = sub_100404EB8();
    v12[0] = _NSConcreteStackBlock;
    v12[1] = 3221225472LL;
    void v12[2] = sub_10045640C;
    v12[3] = &unk_100886EE0;
    uint8_t v12[4] = a1;
    void v12[5] = a2;
    char v13 = v8;
    sub_100405384(v10, v12);
  }
}

void sub_1004563F8(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_10045640C(uint64_t a1)
{
  uint64_t v2 = *(void *)(a1 + 32);
  if (qword_1008D5F50 != -1) {
    dispatch_once(&qword_1008D5F50, &stru_100899698);
  }
  uint64_t v3 = (unsigned __int8 *)sub_10040007C(off_1008D5F48, *(void *)(a1 + 40), 0);
  if (v3) {
    sub_1004553DC(v2, 0, v3, 1, *(char *)(a1 + 48));
  }
}

void sub_10045648C(uint64_t a1, uint64_t a2, void *a3, uint64_t a4)
{
}

uint64_t sub_100456494(uint64_t a1, uint64_t a2)
{
  v10[0] = 0LL;
  v10[1] = 0LL;
  sub_100242F28((uint64_t)v10, a1 + 392);
  uint64_t v4 = *(dispatch_source_s **)(a1 + 488);
  if (v4
    || (uint64_t v5 = sub_100404EB8(),
        v6 = dispatch_source_create( (dispatch_source_type_t)&_dispatch_source_type_timer,  0LL,  0LL,  *(dispatch_queue_t *)(v5 + 8)),  *(void *)(a1 + 488) = v6,  dispatch_source_set_event_handler(v6, &stru_100899520),  (uint64_t v4 = *(dispatch_source_s **)(a1 + 488)) != 0LL))
  {
    id v7 = (os_log_s *)qword_1008F7590;
    if (os_log_type_enabled((os_log_t)qword_1008F7590, OS_LOG_TYPE_DEFAULT))
    {
      *(_DWORD *)__int128 buf = 134217984;
      uint64_t v12 = a2;
      _os_log_impl( (void *)&_mh_execute_header,  v7,  OS_LOG_TYPE_DEFAULT,  "Start Scan Core Page Scan timer of %llu seconds",  buf,  0xCu);
      uint64_t v4 = *(dispatch_source_s **)(a1 + 488);
    }

    dispatch_time_t v8 = dispatch_time(0LL, 1000000000 * a2);
    dispatch_source_set_timer(v4, v8, 0xFFFFFFFFFFFFFFFFLL, 0LL);
    dispatch_resume(*(dispatch_object_t *)(a1 + 488));
  }

  return sub_100242FAC((uint64_t)v10);
}

void sub_1004565C8( _Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9)
{
}

void sub_1004565E4(uint64_t a1, int a2)
{
  uint64_t v4 = (os_log_s *)qword_1008F7590;
  if (os_log_type_enabled((os_log_t)qword_1008F7590, OS_LOG_TYPE_DEFAULT))
  {
    uint64_t v5 = "unknown";
    int v6 = *(_DWORD *)(a1 + 480);
    if (v6 == 1) {
      id v7 = "SCAN_CORE_PAGE_SCAN_ENABLE";
    }
    else {
      id v7 = "unknown";
    }
    if (v6) {
      dispatch_time_t v8 = v7;
    }
    else {
      dispatch_time_t v8 = "SCAN_CORE_PAGE_SCAN_IDLE";
    }
    if (a2 == 1) {
      uint64_t v5 = "SCAN_CORE_PAGE_SCAN_ENABLE";
    }
    if (!a2) {
      uint64_t v5 = "SCAN_CORE_PAGE_SCAN_IDLE";
    }
    int v9 = 136315394;
    uint64_t v10 = v8;
    __int16 v11 = 2080;
    uint64_t v12 = v5;
    _os_log_impl( (void *)&_mh_execute_header,  v4,  OS_LOG_TYPE_DEFAULT,  "Scan Core Page Scan State:  %s => %s",  (uint8_t *)&v9,  0x16u);
  }

  *(_DWORD *)(a1 + 48sub_100414D2C(qword_1008F72C0, 0) = a2;
}

void sub_1004566DC(id a1)
{
  uint64_t v1 = sub_100404EB8();
  sub_100405384(v1, &stru_100899540);
}

void sub_1004566F8(uint64_t a1)
{
  if (qword_1008D61A8 != -1) {
    dispatch_once(&qword_1008D61A8, &stru_100899560);
  }
  sub_1003B423C(qword_1008D61A0 + 8, a1 + 8);
  if (qword_1008D60B0 != -1) {
    dispatch_once(&qword_1008D60B0, &stru_100899580);
  }
  sub_1001FC5E4((uint64_t)off_1008D60A8 + 80, a1 + 32);
}

void sub_100456788(uint64_t a1)
{
  if (qword_1008D61A8 != -1) {
    dispatch_once(&qword_1008D61A8, &stru_100899560);
  }
  sub_100009168(qword_1008D61A0 + 8, a1 + 8);
  if (qword_1008D60B0 != -1) {
    dispatch_once(&qword_1008D60B0, &stru_100899580);
  }
  sub_100009168((uint64_t)off_1008D60A8 + 80, a1 + 32);
}

uint64_t sub_100456818(uint64_t result, uint64_t a2, int a3)
{
  if (!a3) {
    return (*(uint64_t (**)(uint64_t))(*(void *)result + 8LL))(result);
  }
  return result;
}

uint64_t sub_100456830(uint64_t a1, int a2)
{
  if (a2) {
    return sub_100454734(a1);
  }
  else {
    return sub_10045490C(a1);
  }
}

uint64_t sub_100456844(uint64_t result, uint64_t a2, int a3)
{
  if (!a3) {
    return (*(uint64_t (**)(uint64_t))(*(void *)(result - 16) + 8LL))(result - 16);
  }
  return result;
}

uint64_t sub_10045685C(uint64_t a1, int a2)
{
  uint64_t v2 = a1 - 24;
  if (a2) {
    return sub_100454734(v2);
  }
  else {
    return sub_10045490C(v2);
  }
}

void sub_100456874(id a1)
{
  if (qword_1008D63D8 != -1) {
    dispatch_once(&qword_1008D63D8, &stru_1008995A0);
  }
  sub_1004553DC((uint64_t)off_1008D63D0, 2u, 0LL, 1, 0);
}

void sub_1004568C4(id a1)
{
  uint64_t v1 = operator new(0x120uLL);
  sub_100495250();
  qword_1008D61A0 = (uint64_t)v1;
}

void sub_1004568F4(_Unwind_Exception *a1)
{
}

void sub_100456908(id a1)
{
  uint64_t v1 = operator new(0x230uLL);
  sub_10042BC28();
  off_1008D60A8 = v1;
}

void sub_100456938(_Unwind_Exception *a1)
{
}

void sub_10045694C(id a1)
{
  uint64_t v1 = operator new(0x260uLL);
  sub_1004515A0((uint64_t)v1);
  off_1008D63D0 = v1;
}

void sub_10045697C(_Unwind_Exception *a1)
{
}

void sub_100456990(uint64_t a1, void *a2)
{
  if (a2)
  {
    sub_100456990(a1, *a2);
    sub_100456990(a1, a2[1]);
    sub_100032BD4((uint64_t)(a2 + 5));
    operator delete(a2);
  }

void sub_1004569D8(void ***a1)
{
  uint64_t v1 = *a1;
  uint64_t v2 = (char *)**a1;
  if (v2)
  {
    uint64_t v4 = (char *)v1[1];
    uint64_t v5 = **a1;
    if (v4 != v2)
    {
      do
      {
        int v6 = v4 - 24;
        sub_100032BD4((uint64_t)(v4 - 16));
        uint64_t v4 = v6;
      }

      while (v6 != v2);
      uint64_t v5 = **a1;
    }

    v1[1] = v2;
    operator delete(v5);
  }

void sub_100456A4C(id a1)
{
  uint64_t v1 = operator new(0x98uLL);
  sub_1003C97E4((uint64_t)v1);
  off_1008D67E0 = v1;
}

void sub_100456A7C(_Unwind_Exception *a1)
{
}

void sub_100456A90(id a1)
{
  uint64_t v1 = operator new(0x1128uLL);
  sub_1005DDADC();
  off_1008D6600 = v1;
}

void sub_100456AC0(_Unwind_Exception *a1)
{
}

void *sub_100456AD4@<X0>(void *a1@<X8>)
{
  uint64_t v2 = operator new(0x150uLL);
  uint64_t result = sub_100456B1C(v2);
  *a1 = v2 + 3;
  a1[1] = v2;
  return result;
}

void sub_100456B08(_Unwind_Exception *a1)
{
}

void *sub_100456B1C(void *a1)
{
  a1[1] = 0LL;
  a1[2] = 0LL;
  *a1 = off_100899610;
  sub_10044EA88((uint64_t)(a1 + 3));
  return a1;
}

void sub_100456B50(_Unwind_Exception *a1)
{
}

void sub_100456B64(std::__shared_weak_count *this)
{
  this->__vftable = (std::__shared_weak_count_vtbl *)off_100899610;
  std::__shared_weak_count::~__shared_weak_count(this);
}

void sub_100456B74(std::__shared_weak_count *a1)
{
  a1->__vftable = (std::__shared_weak_count_vtbl *)off_100899610;
  std::__shared_weak_count::~__shared_weak_count(a1);
  operator delete(v1);
}

uint64_t sub_100456B94(uint64_t a1)
{
  return (**(uint64_t (***)(uint64_t))(a1 + 24))(a1 + 24);
}

uint64_t *sub_100456BA4(uint64_t **a1, unint64_t *a2, uint64_t a3, uint64_t **a4)
{
  id v7 = a1 + 1;
  int v6 = a1[1];
  dispatch_time_t v8 = a1 + 1;
  int v9 = a1 + 1;
  if (v6)
  {
    unint64_t v10 = *a2;
    while (1)
    {
      while (1)
      {
        int v9 = (uint64_t **)v6;
        unint64_t v11 = v6[4];
        if (v10 >= v11) {
          break;
        }
        int v6 = *v9;
        dispatch_time_t v8 = v9;
        if (!*v9) {
          goto LABEL_9;
        }
      }

      if (v11 >= v10) {
        break;
      }
      int v6 = v9[1];
      if (!v6)
      {
        dispatch_time_t v8 = v9 + 1;
        goto LABEL_9;
      }
    }
  }

  else
  {
LABEL_9:
    uint64_t v15 = 0LL;
    uint64_t v12 = (uint64_t *)operator new(0x38uLL);
    v14[1] = v7;
    uint8_t v12[4] = **a4;
    void v12[5] = 0LL;
    void v12[6] = 0LL;
    LOBYTE(v15) = 1;
    sub_100029630(a1, (uint64_t)v9, v8, v12);
    v14[0] = 0LL;
    sub_100456C8C((uint64_t)v14, 0LL);
    return v12;
  }

  return (uint64_t *)v9;
}

void sub_100456C8C(uint64_t a1, uint64_t a2)
{
  uint64_t v2 = *(void **)a1;
  *(void *)a1 = a2;
  if (v2)
  {
    if (*(_BYTE *)(a1 + 16)) {
      sub_100032BD4((uint64_t)v2 + 40);
    }
    operator delete(v2);
  }

void sub_100456CD0(id a1)
{
  uint64_t v1 = operator new(0x2B0uLL);
  sub_10040749C((uint64_t)v1);
  off_1008D5EF8 = v1;
}

void sub_100456D00(_Unwind_Exception *a1)
{
}

uint64_t *sub_100456D14(uint64_t *result, void *a2)
{
  uint64_t v3 = *result;
  uint64_t v2 = result[1];
  uint64_t v4 = a2[1];
  while (v2 != v3)
  {
    __int128 v5 = *(_OWORD *)(v2 - 24);
    v2 -= 24LL;
    *(_OWORD *)(v4 - 24) = v5;
    v4 -= 24LL;
    *(void *)(v4 + 16) = *(void *)(v2 + 16);
    *(void *)(v2 + _Block_object_dispose((const void *)(v2 - 88), 8) = 0LL;
    *(void *)(v2 + 16) = 0LL;
  }

  a2[1] = v4;
  uint64_t v6 = *result;
  *uint64_t result = v4;
  a2[1] = v6;
  uint64_t v7 = result[1];
  result[1] = a2[2];
  a2[2] = v7;
  uint64_t v8 = result[2];
  result[2] = a2[3];
  a2[3] = v8;
  *a2 = a2[1];
  return result;
}

uint64_t sub_100456D78(uint64_t a1)
{
  uint64_t v3 = *(void *)(a1 + 8);
  for (uint64_t i = *(void *)(a1 + 16); i != v3; uint64_t i = *(void *)(a1 + 16))
  {
    *(void *)(a1 + 16) = i - 24;
    sub_100032BD4(i - 16);
  }

  if (*(void *)a1) {
    operator delete(*(void **)a1);
  }
  return a1;
}

uint64_t sub_100456DC8(uint64_t a1, uint64_t a2, unint64_t a3, uint64_t a4)
{
  uint64_t v6 = *(void *)(a1 + 8);
  unint64_t v7 = a2 + v6 - a4;
  uint64_t v8 = v6;
  if (v7 < a3)
  {
    unint64_t v9 = v7;
    uint64_t v8 = *(void *)(a1 + 8);
    do
    {
      *(_OWORD *)uint64_t v8 = *(_OWORD *)v9;
      *(void *)(v8 + 16) = *(void *)(v9 + 16);
      *(void *)(v9 + _Block_object_dispose((const void *)(v2 - 88), 8) = 0LL;
      *(void *)(v9 + 16) = 0LL;
      v8 += 24LL;
      v9 += 24LL;
    }

    while (v9 < a3);
  }

  *(void *)(a1 + _Block_object_dispose((const void *)(v2 - 88), 8) = v8;
  return sub_100456ED4(a2, v7, v6);
}

uint64_t sub_100456E20(uint64_t *a1, void *a2, uint64_t a3)
{
  uint64_t result = a2[1];
  uint64_t v5 = *a1;
  uint64_t v6 = result;
  if (*a1 != a3)
  {
    uint64_t v7 = a3;
    uint64_t v6 = a2[1];
    do
    {
      __int128 v8 = *(_OWORD *)(v7 - 24);
      v7 -= 24LL;
      *(_OWORD *)(v6 - 24) = v8;
      v6 -= 24LL;
      *(void *)(v6 + 16) = *(void *)(v7 + 16);
      *(void *)(v7 + _Block_object_dispose((const void *)(v2 - 88), 8) = 0LL;
      *(void *)(v7 + 16) = 0LL;
    }

    while (v7 != v5);
  }

  a2[1] = v6;
  uint64_t v9 = a1[1];
  uint64_t v10 = a2[2];
  if (v9 != a3)
  {
    do
    {
      *(_OWORD *)uint64_t v10 = *(_OWORD *)a3;
      *(void *)(v10 + 16) = *(void *)(a3 + 16);
      *(void *)(a3 + _Block_object_dispose((const void *)(v2 - 88), 8) = 0LL;
      *(void *)(a3 + 16) = 0LL;
      v10 += 24LL;
      a3 += 24LL;
    }

    while (a3 != v9);
    uint64_t v6 = a2[1];
  }

  a2[2] = v10;
  uint64_t v11 = *a1;
  *a1 = v6;
  a2[1] = v11;
  uint64_t v12 = a1[1];
  a1[1] = a2[2];
  a2[2] = v12;
  uint64_t v13 = a1[2];
  a1[2] = a2[3];
  a2[3] = v13;
  *a2 = a2[1];
  return result;
}

uint64_t sub_100456ED4(uint64_t a1, uint64_t a2, uint64_t a3)
{
  if (a2 != a1)
  {
    uint64_t v6 = a2;
    do
    {
      uint64_t v7 = *(void *)(v6 - 24);
      v6 -= 24LL;
      *(void *)(a3 - 24) = v7;
      a3 -= 24LL;
      sub_1002102FC(a3 + 8, (__int128 *)(v6 + 8));
    }

    while (v6 != a1);
  }

  return a2;
}

void *sub_100456F30(void *a1, void *a2, void *a3)
{
  uint64_t v4 = a1;
  if (a1 == a2) {
    return a1;
  }
  uint64_t v5 = a2;
  do
  {
    uint64_t v6 = (__int128 *)(v4 + 1);
    uint64_t v7 = *v4;
    v4 += 3;
    uint64_t v8 = (uint64_t)(a3 + 1);
    *a3 = v7;
    a3 += 3;
    sub_1002102FC(v8, v6);
  }

  while (v4 != v5);
  return v5;
}

void sub_100456F90(id a1)
{
  uint64_t v1 = operator new(0x2C0uLL);
  sub_1004219F0();
  off_1008D60C8 = v1;
}

void sub_100456FC0(_Unwind_Exception *a1)
{
}

void sub_100456FD4(id a1)
{
  uint64_t v1 = operator new(0xA8uLL);
  sub_10040D0A0((uint64_t)v1);
  off_1008D6780 = v1;
}

void sub_100457004(_Unwind_Exception *a1)
{
}

void sub_100457018(id a1)
{
  uint64_t v1 = operator new(0x138uLL);
  sub_1003FE3E0((uint64_t)v1);
  off_1008D5F48 = v1;
}

void sub_100457048(_Unwind_Exception *a1)
{
}

os_log_s **sub_10045705C(os_log_s **a1)
{
  a1[1] = (os_log_s *)os_nexus_controller_create();
  uint64_t v2 = os_log_create("com.apple.bluetooth", "BTAudioSkywalk");
  uint64_t v3 = v2;
  *a1 = v2;
  if (a1[1])
  {
    if (os_log_type_enabled(v2, OS_LOG_TYPE_DEFAULT))
    {
      LODWORD(v6[0]) = 134219008;
      *(void *)((char *)v6 + 4) = 2048LL;
      WORD2(v6[1]) = 2048;
      *(void *)((char *)&v6[1] + 6) = 1LL;
      HIWORD(v6[2]) = 2048;
      void v6[3] = 1LL;
      LOWORD(v6[4]) = 2048;
      *(void *)((char *)&v6[4] + 2) = 8LL;
      WORD1(v6[5]) = 2048;
      *(void *)((char *)&v6[5] + 4) = 8LL;
      _os_log_impl( (void *)&_mh_execute_header,  v3,  OS_LOG_TYPE_DEFAULT,  "Creating skywalk nexus with NEXUS_ATTR_SLOT_BUF_SIZE: %llu, NEXUS_ATTR_RX_RINGS: %llu, NEXUS_ATTR_TX_RINGS: %llu , NEXUS_ATTR_TX_SLOTS: %llu, NEXUS_ATTR_RX_SLOTS: %llu",  (uint8_t *)v6,  0x34u);
    }

    uint64_t v4 = os_nexus_attr_create();
    os_nexus_attr_set(v4, 4LL, 2048LL);
    os_nexus_attr_set(v4, 1LL, 1LL);
    os_nexus_attr_set(v4, 0LL, 1LL);
    os_nexus_attr_set(v4, 2LL, 8LL);
    os_nexus_attr_set(v4, 3LL, 8LL);
    os_nexus_attr_set(v4, 7LL, 2LL);
    strcpy((char *)v6, "com.apple.bluetooth.AudioPipe");
    HIWORD(v6[3]) = unk_1006C31B4;
    memset(&v6[4], 0, 32);
    os_nexus_controller_register_provider(a1[1], v6, 0LL, v4, a1 + 2);
    os_nexus_attr_destroy(v4);
  }

  else if (os_log_type_enabled(v2, OS_LOG_TYPE_ERROR))
  {
    sub_10068067C();
  }

  return a1;
}

uint64_t sub_10045720C(uint64_t a1, uint64_t a2, char a3)
{
  *(void *)a1 = off_100899700;
  *(void *)(a1 + _Block_object_dispose((const void *)(v2 - 88), 8) = -1LL;
  *(void *)(a1 + 20sub_100414D2C(qword_1008F72C0, 0) = 0LL;
  *(_OWORD *)(a1 + 152) = 0u;
  *(_OWORD *)(a1 + 16_Block_object_dispose((const void *)(v2 - 88), 8) = 0u;
  *(void *)(a1 + 184) = 0LL;
  *(_BYTE *)(a1 + 20_Block_object_dispose((const void *)(v2 - 88), 8) = a3;
  mach_timebase_info((mach_timebase_info_t)(a1 + 192));
  *(void *)(a1 + 20sub_100414D2C(qword_1008F72C0, 0) = a2;
  *(void *)(a1 + 16) = os_log_create("com.apple.bluetooth", "BTAudioSkywalk");
  return a1;
}

void sub_100457280(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

uint64_t sub_1004572A4(uint64_t a1)
{
  *(void *)a1 = off_100899700;
  uint64_t v2 = *(os_log_s **)(a1 + 16);
  if (os_log_type_enabled(v2, OS_LOG_TYPE_DEFAULT))
  {
    LOWORD(v10.ident) = 0;
    _os_log_impl( (void *)&_mh_execute_header,  v2,  OS_LOG_TYPE_DEFAULT,  "Tearing down AudioSkywalkPipe",  (uint8_t *)&v10,  2u);
  }

  atomic_store(1u, (unsigned __int8 *)(a1 + 144));
  int v3 = *(_DWORD *)(a1 + 12);
  if (v3 != -1 || *(_DWORD *)(a1 + 8) != -1)
  {
    v10.ident = a1 + 144;
    *(void *)&v10.filter = 0x10000000000FFF6LL;
    v10.int data = 0LL;
    v10.uint data = 0LL;
    kevent(v3, &v10, 1, 0LL, 0, 0LL);
    kevent(*(_DWORD *)(a1 + 8), &v10, 1, 0LL, 0, 0LL);
    pthread_mutex_lock((pthread_mutex_t *)(a1 + 32));
    pthread_mutex_unlock((pthread_mutex_t *)(a1 + 32));
    pthread_cond_destroy((pthread_cond_t *)(a1 + 96));
    pthread_mutex_destroy((pthread_mutex_t *)(a1 + 32));
    int v5 = *(_DWORD *)(a1 + 8);
    if (v5 != -1) {
      close(v5);
    }
  }

  int v6 = *(_DWORD *)(a1 + 12);
  if (v6 != -1) {
    close(v6);
  }
  uint64_t v7 = *(void *)(a1 + 176);
  if (v7) {
    os_channel_destroy(v7);
  }
  uint64_t v8 = *(os_log_s **)(a1 + 16);
  if (os_log_type_enabled(v8, OS_LOG_TYPE_DEFAULT))
  {
    LOWORD(v10.ident) = 0;
    _os_log_impl( (void *)&_mh_execute_header,  v8,  OS_LOG_TYPE_DEFAULT,  "AudioSkywalkPipe torn down",  (uint8_t *)&v10,  2u);
  }

  return a1;
}

void sub_100457448(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_100457478(uint64_t a1)
{
  uint64_t v1 = (void *)sub_1004572A4(a1);
  operator delete(v1);
}

void sub_10045748C(uint64_t a1, void *a2, void *a3, void *a4)
{
  id v7 = a4;
  id v8 = a3;
  id v9 = objc_retainBlock(a2);
  kevent v10 = *(void **)(a1 + 152);
  *(void *)(a1 + 152) = v9;

  id v11 = objc_retainBlock(v8);
  uint64_t v12 = *(void **)(a1 + 160);
  *(void *)(a1 + 16sub_100414D2C(qword_1008F72C0, 0) = v11;

  id v13 = objc_retainBlock(v7);
  int v14 = *(void **)(a1 + 168);
  *(void *)(a1 + 16_Block_object_dispose((const void *)(v2 - 88), 8) = v13;

  atomic_store(0, (unsigned __int8 *)(a1 + 144));
  atomic_store(0, (unsigned __int8 *)(a1 + 145));
  if (*(void *)(a1 + 152)) {
    *(_DWORD *)(a1 + 12) = kqueue();
  }
  if (*(void *)(a1 + 160)) {
    *(_DWORD *)(a1 + _Block_object_dispose((const void *)(v2 - 88), 8) = kqueue();
  }
  uint64_t fd = os_channel_get_fd(*(void *)(a1 + 176));
  v17.ident = (int)__chkstk_darwin(fd, v16);
  *(_DWORD *)&v17.filter = 393215;
  memset(&v17.fflags, 0, 20);
  uint64_t v18 = a1 + 144;
  int v19 = 393206;
  uint64_t v21 = 0LL;
  uint64_t v20 = 0LL;
  int v22 = 0;
  if (kevent(*(_DWORD *)(a1 + 12), &v17, 2, 0LL, 0, 0LL) == -1)
  {
    if (os_log_type_enabled(*(os_log_t *)(a1 + 16), OS_LOG_TYPE_ERROR)) {
      sub_1006806A8();
    }
  }

  else if (*(void *)(a1 + 152))
  {
    pthread_mutex_init((pthread_mutex_t *)(a1 + 32), 0LL);
    pthread_cond_init((pthread_cond_t *)(a1 + 96), 0LL);
    memset(&v23, 0, sizeof(v23));
    pthread_attr_init(&v23);
    pthread_attr_setdetachstate(&v23, 2);
    pthread_create((pthread_t *)(a1 + 24), &v23, (void *(__cdecl *)(void *))sub_100457670, (void *)a1);
  }

uint64_t sub_100457670(uint64_t a1)
{
  uint64_t v2 = os_log_create("com.apple.bluetooth", "BTAudioSkywalk");
  int v3 = v2;
  uint64_t v4 = *(void *)(a1 + 200);
  if (!v4)
  {
    if (os_log_type_enabled(v2, OS_LOG_TYPE_ERROR)) {
      sub_1006806D4(v3);
    }
    uint64_t v4 = 22000LL;
    *(void *)(a1 + 20sub_100414D2C(qword_1008F72C0, 0) = 22000LL;
  }

  unint64_t v5 = 1000 * v4 * (unint64_t)*(unsigned int *)(a1 + 196) / *(unsigned int *)(a1 + 192);
  integer_t policy_info = v5;
  int v16 = v5 >> 2;
  int v17 = v16;
  int v18 = 0;
  thread_act_t v6 = mach_thread_self();
  thread_policy_set(v6, 2u, &policy_info, 4u);
  if (os_log_type_enabled(v3, OS_LOG_TYPE_DEFAULT))
  {
    LOWORD(v14.ident) = 0;
    _os_log_impl( (void *)&_mh_execute_header,  v3,  OS_LOG_TYPE_DEFAULT,  "Starting AudioSkywalk read loop",  (uint8_t *)&v14,  2u);
  }

  mach_absolute_time();
  *(void *)(a1 + 216) = 0LL;
  *(void *)(a1 + 224) = 0LL;
  id v7 = (void *)(a1 + 216);
  if (!atomic_load((unsigned __int8 *)(a1 + 144)))
  {
    unint64_t v9 = 20000000 * (unint64_t)*(unsigned int *)(a1 + 196) / *(unsigned int *)(a1 + 192);
    do
    {
      memset(&v14, 0, sizeof(v14));
      kevent(*(_DWORD *)(a1 + 12), 0LL, 0, &v14, 1, 0LL);
      if (v14.filter != -1) {
        break;
      }
      uint64_t v10 = mach_absolute_time();
      uint64_t v11 = v10;
      if (*v7 && *(void *)(a1 + 224) && v10 > *v7 + v9) {
        (*(void (**)(void))(*(void *)(a1 + 168) + 16LL))();
      }
      sub_1004578D4(a1);
      *(void *)(a1 + 216) = v11 + v5;
      *(void *)(a1 + 224) = v11;
    }

    while (!atomic_load((unsigned __int8 *)(a1 + 144)));
  }

  if (os_log_type_enabled(v3, OS_LOG_TYPE_DEFAULT))
  {
    LOWORD(v14.ident) = 0;
    _os_log_impl( (void *)&_mh_execute_header,  v3,  OS_LOG_TYPE_DEFAULT,  "Stopping AudioSkywalk read loop",  (uint8_t *)&v14,  2u);
  }

  pthread_mutex_lock((pthread_mutex_t *)(a1 + 32));
  atomic_store(1u, (unsigned __int8 *)(a1 + 145));
  pthread_cond_signal((pthread_cond_t *)(a1 + 96));
  pthread_mutex_unlock((pthread_mutex_t *)(a1 + 32));
  if (os_log_type_enabled(v3, OS_LOG_TYPE_DEFAULT))
  {
    LOWORD(v14.ident) = 0;
    _os_log_impl( (void *)&_mh_execute_header,  v3,  OS_LOG_TYPE_DEFAULT,  "AudioSkywalk read loop stopped",  (uint8_t *)&v14,  2u);
  }

  return 0LL;
}

void sub_1004578D4(uint64_t a1)
{
  uint64_t v2 = *(void *)(a1 + 176);
  if (v2)
  {
    uint64_t v3 = os_channel_ring_id(*(void *)(a1 + 176), 2LL);
    uint64_t v4 = os_channel_rx_ring(v2, v3);
    memset(v7, 0, sizeof(v7));
    uint64_t next_slot = os_channel_get_next_slot(v4, 0LL, v7);
    if (next_slot)
    {
      uint64_t v6 = next_slot;
      if (*(_BYTE *)(a1 + 208))
      {
        if (os_log_type_enabled(*(os_log_t *)(a1 + 16), OS_LOG_TYPE_DEBUG)) {
          sub_100680774();
        }
      }

      (*(void (**)(void))(*(void *)(a1 + 152) + 16LL))();
      os_channel_get_next_slot(v4, v6, v7);
      os_channel_advance_slot(v4, v6);
    }

    os_channel_sync(*(void *)(a1 + 176), 1LL);
  }

  else if (os_log_type_enabled(*(os_log_t *)(a1 + 16), OS_LOG_TYPE_ERROR))
  {
    sub_100680748();
  }

uint64_t sub_1004579D0(uint64_t result)
{
  *(void *)(result + 216) = 0LL;
  return result;
}

uint64_t sub_1004579D8(uint64_t a1, uint64_t a2, uint64_t a3, char a4)
{
  uint64_t v6 = (void *)sub_10045720C(a1, a3, a4);
  void *v6 = off_100899720;
  v6[30] = 0LL;
  id v7 = v6 + 30;
  v6[31] = 0LL;
  v6[32] = 0LL;
  v6[29] = *(void *)(a2 + 8);
  id v8 = -[NSUUID initWithUUIDBytes:](objc_alloc(&OBJC_CLASS___NSUUID), "initWithUUIDBytes:", a2 + 16);
  unint64_t v9 = *(void **)(a1 + 248);
  *(void *)(a1 + 24_Block_object_dispose((const void *)(v2 - 88), 8) = v8;

  v23[0] = 0LL;
  v23[1] = 0LL;
  [*(id *)(a1 + 248) getUUIDBytes:v23];
  v22[0] = 0LL;
  v22[1] = 0LL;
  if (os_nexus_controller_alloc_provider_instance(*(void *)(a1 + 232), v23, v22))
  {
    if (os_log_type_enabled(*(os_log_t *)(a1 + 16), OS_LOG_TYPE_ERROR)) {
      sub_100680814();
    }
  }

  else
  {
    uint64_t v10 = objc_alloc_init(&OBJC_CLASS___NSUUID);
    uint64_t v11 = *(void **)(a1 + 256);
    *(void *)(a1 + 256) = v10;

    v21[0] = 0LL;
    v21[1] = 0LL;
    [*(id *)(a1 + 256) getUUIDBytes:v21];
    os_nexus_controller_bind_provider_instance(*(void *)(a1 + 232), v22, 1LL, 0LL, 0LL, v21, 16LL, 4LL);
    os_nexus_controller_bind_provider_instance(*(void *)(a1 + 232), v22, 0LL, 0LL, 0LL, v21, 16LL, 4LL);
    uint64_t v12 = -[NSUUID initWithUUIDBytes:](objc_alloc(&OBJC_CLASS___NSUUID), "initWithUUIDBytes:", v22);
    id v13 = *(void **)(a1 + 240);
    *(void *)(a1 + 24sub_100414D2C(qword_1008F72C0, 0) = v12;

    kevent v14 = *(os_log_s **)(a1 + 16);
    BOOL v15 = os_log_type_enabled(v14, OS_LOG_TYPE_DEFAULT);
    if (v15)
    {
      uint64_t v16 = *v7;
      int v19 = 138412290;
      uint64_t v20 = v16;
      _os_log_impl( (void *)&_mh_execute_header,  v14,  OS_LOG_TYPE_DEFAULT,  "Registering Audio skywalk server channel to %@",  (uint8_t *)&v19,  0xCu);
    }

    uint64_t v17 = os_channel_attr_create(v15);
    os_channel_attr_set(v17, 7LL, 1LL);
    os_channel_attr_set_key(v17, v21, 16LL);
    *(void *)(a1 + 1sub_10023DF50(v3 + 76) = os_channel_create_extended(v22, 1LL, 0LL, 0xFFFFFFFFLL, v17);
    os_channel_attr_destroy(v17);
    if (!*(void *)(a1 + 176) && os_log_type_enabled(*(os_log_t *)(a1 + 16), OS_LOG_TYPE_ERROR)) {
      sub_1006807E8();
    }
  }

  return a1;
}

void sub_100457C10(_Unwind_Exception *a1)
{
  sub_1004572A4((uint64_t)v1);
  _Unwind_Resume(a1);
}

uint64_t sub_100457C5C(uint64_t a1)
{
  *(void *)a1 = off_100899720;
  v3[0] = 0LL;
  v3[1] = 0LL;
  [*(id *)(a1 + 240) getUUIDBytes:v3];
  os_nexus_controller_free_provider_instance(*(void *)(a1 + 232), v3);

  sub_1004572A4(a1);
  return a1;
}

void sub_100457CF8(_Unwind_Exception *a1)
{
  sub_1004572A4((uint64_t)v1);
  _Unwind_Resume(a1);
}

void sub_100457D30(uint64_t a1)
{
  uint64_t v1 = (void *)sub_100457C5C(a1);
  operator delete(v1);
}

id sub_100457D44(uint64_t a1)
{
  return *(id *)(a1 + 240);
}

id sub_100457D4C(uint64_t a1)
{
  return *(id *)(a1 + 256);
}

void sub_100457D54(uint64_t a1)
{
  if (qword_1008D9998 != -1) {
    dispatch_once(&qword_1008D9998, &stru_100899778);
  }
  sub_1003A32C0(qword_1008D9990, a1 + 48);
}

void sub_100457DA4(uint64_t a1)
{
  if (qword_1008D9998 != -1) {
    dispatch_once(&qword_1008D9998, &stru_100899778);
  }
  sub_1003A33F4(qword_1008D9990, a1 + 48);
}

uint64_t sub_100457DF4( uint64_t a1, unsigned __int16 *a2, uint64_t a3, uint64_t a4, uint64_t a5, void (*a6)(unsigned __int16 *))
{
  if (!a2)
  {
    uint64_t v12 = (os_log_s *)qword_1008F7710;
    if (os_log_type_enabled((os_log_t)qword_1008F7710, OS_LOG_TYPE_ERROR)) {
      sub_1006808CC(v12);
    }
  }

  int v13 = *a2;
  kevent v14 = (os_log_s *)qword_1008F7710;
  BOOL v15 = os_log_type_enabled((os_log_t)qword_1008F7710, OS_LOG_TYPE_DEFAULT);
  if (v15)
  {
    int v22 = 136315394;
    pthread_attr_t v23 = "TransportWrite";
    __int16 v24 = 1024;
    int v25 = v13;
    _os_log_impl((void *)&_mh_execute_header, v14, OS_LOG_TYPE_DEFAULT, "%s: opCode 0x%04X", (uint8_t *)&v22, 0x12u);
  }

  uint64_t v16 = sub_100457F80(v15, v13);
  if (!(v17 & 1 | (unint64_t)v16))
  {
    uint64_t v20 = (os_log_s *)qword_1008F7710;
    if (os_log_type_enabled((os_log_t)qword_1008F7710, OS_LOG_TYPE_ERROR))
    {
      sub_100680840(v13, v20);
      if (!a6) {
        return 1LL;
      }
    }

    else if (!a6)
    {
      return 1LL;
    }

void (*sub_100457F80(uint64_t a1, int a2))(uint64_t a1, unsigned __int16 *a2)
{
  uint64_t result = (void (*)(uint64_t, unsigned __int16 *))sub_10045818C;
  if (a2 > 8194)
  {
    if (a2 <= 8238)
    {
      id v7 = sub_1004593B8;
      if (a2 != 8220) {
        id v7 = (void (*)(uint64_t, unsigned __int16 *))sub_10045818C;
      }
      if (a2 == 8207) {
        id v8 = sub_100459260;
      }
      else {
        id v8 = v7;
      }
      unint64_t v9 = sub_100458F9C;
      uint64_t v10 = sub_100459108;
      if (a2 != 8199) {
        uint64_t v10 = (void (*)(uint64_t, unsigned __int16 *))sub_10045818C;
      }
      if (a2 != 8195) {
        unint64_t v9 = v10;
      }
      if (a2 <= 8206) {
        return v9;
      }
      else {
        return v8;
      }
    }

    else
    {
      switch(a2)
      {
        case 8245:
          uint64_t result = (void (*)(uint64_t, unsigned __int16 *))sub_100459698;
          break;
        case 8246:
          uint64_t result = sub_100459760;
          break;
        case 8247:
          uint64_t result = (void (*)(uint64_t, unsigned __int16 *))sub_1004599D4;
          break;
        case 8248:
        case 8251:
        case 8252:
        case 8253:
        case 8254:
        case 8255:
        case 8256:
        case 8257:
          return result;
        case 8249:
          uint64_t result = (void (*)(uint64_t, unsigned __int16 *))sub_100459B34;
          break;
        case 8250:
          uint64_t result = sub_100459C5C;
          break;
        case 8258:
          uint64_t result = (void (*)(uint64_t, unsigned __int16 *))sub_100459DB4;
          break;
        default:
          uint64_t v12 = sub_100459E5C;
          if (a2 != 8288) {
            uint64_t v12 = (void (*)(uint64_t, unsigned __int16 *))sub_10045818C;
          }
          if (a2 == 8239) {
            uint64_t result = sub_10045951C;
          }
          else {
            uint64_t result = v12;
          }
          break;
      }
    }
  }

  else if (a2 <= 3096)
  {
    uint64_t v3 = sub_10045824C;
    uint64_t v4 = (uint64_t (*)(uint64_t, unsigned __int8 *))sub_1004582BC;
    if (a2 != 3085) {
      uint64_t v4 = (uint64_t (*)(uint64_t, unsigned __int8 *))sub_10045818C;
    }
    if (a2 != 3075) {
      uint64_t v3 = v4;
    }
    unint64_t v5 = sub_100458198;
    uint64_t v6 = sub_1004581C8;
    if (a2 != 1029) {
      uint64_t v6 = sub_10045818C;
    }
    if (a2 != 1025) {
      unint64_t v5 = v6;
    }
    if (a2 <= 3074) {
      return (void (*)(uint64_t, unsigned __int16 *))v5;
    }
    else {
      return (void (*)(uint64_t, unsigned __int16 *))v3;
    }
  }

  else
  {
    switch(a2)
    {
      case 4097:
        uint64_t result = sub_100458550;
        break;
      case 4098:
        uint64_t result = sub_1004586C4;
        break;
      case 4099:
        uint64_t result = sub_100458838;
        break;
      case 4100:
        uint64_t result = sub_1004589A8;
        break;
      case 4101:
        uint64_t result = sub_100458B24;
        break;
      case 4102:
      case 4103:
      case 4104:
        return result;
      case 4105:
        uint64_t result = sub_100458CA0;
        break;
      default:
        uint64_t v11 = sub_100458E38;
        if (a2 != 8194) {
          uint64_t v11 = (void (*)(uint64_t, unsigned __int16 *))sub_10045818C;
        }
        if (a2 == 3097) {
          uint64_t result = sub_10045840C;
        }
        else {
          uint64_t result = v11;
        }
        break;
    }
  }

  return result;
}

uint64_t sub_10045818C(uint64_t a1, unsigned __int16 *a2)
{
  return sub_100459FD8(a1, *a2, 0);
}

uint64_t sub_100458198(uint64_t a1, unsigned __int16 *a2)
{
  return sub_10045A288(a1, 0x2EE0u);
}

uint64_t sub_1004581C8(uint64_t a1, unsigned __int16 *a2)
{
  unsigned __int16 v6 = 0;
  unsigned int v5 = 0;
  if (!a2) {
    sub_1000E6B88( "/Library/Caches/com.apple.xbs/Sources/MobileBluetooth_base/Server/Platforms/Darwin/VirtualController/BTVirtualHciC ommandChannel.mm",  205,  "(uint8_t *)buff");
  }
  int v3 = *a2;
  sub_1001F0050((uint64_t)&v5, (uint64_t)a2 + 3, 6uLL);
  sub_10045A130(a1, v3, 0);
  return sub_10045A3B4(a1, v5 | ((unint64_t)v6 << 32), 4, 0x1388u);
}

uint64_t sub_10045824C(uint64_t a1, unsigned __int8 *a2)
{
  int v3 = *a2;
  int v4 = a2[1];
  if (qword_1008D9998 != -1) {
    dispatch_once(&qword_1008D9998, &stru_100899778);
  }
  char v5 = sub_1003A34A0((id *)qword_1008D9990);
  return sub_100459FD8(a1, v3 | (v4 << 8), v5);
}

void sub_1004582BC(uint64_t a1, unsigned __int16 *a2)
{
  int v4 = (uint64_t *)operator new(0x18uLL);
  sub_10026163C((uint64_t)v4, 0xEu, 5);
  int v5 = *a2;
  unsigned __int16 v6 = (os_log_s *)qword_1008F7710;
  if (os_log_type_enabled((os_log_t)qword_1008F7710, OS_LOG_TYPE_DEFAULT))
  {
    v7[0] = 67109120;
    v7[1] = v5;
    _os_log_impl((void *)&_mh_execute_header, v6, OS_LOG_TYPE_DEFAULT, "handleHciCmd: opCode 0x%04X", (uint8_t *)v7, 8u);
  }

  if (*v4)
  {
    sub_10045A520(v4, 1);
    sub_10045A5A8((uint64_t)v4, v5);
    sub_10045A520(v4, 0);
    sub_10045A5A8((uint64_t)v4, 0);
    sub_10045A5A8((uint64_t)v4, 0);
    sub_1002E673C(a1, v4);
  }

  if (*((_BYTE *)v4 + 14) == 2) {
    *((_WORD *)v4 + 5) = *((_WORD *)v4 + 6);
  }
  operator delete(v4);
}

void sub_1004583F0(_Unwind_Exception *a1)
{
}

void sub_10045840C(uint64_t a1, unsigned __int16 *a2)
{
  int v4 = (uint64_t *)operator new(0x18uLL);
  sub_10026163C((uint64_t)v4, 0xEu, 5);
  int v5 = *a2;
  unsigned __int16 v6 = (os_log_s *)qword_1008F7710;
  if (os_log_type_enabled((os_log_t)qword_1008F7710, OS_LOG_TYPE_DEFAULT))
  {
    v7[0] = 67109120;
    v7[1] = v5;
    _os_log_impl((void *)&_mh_execute_header, v6, OS_LOG_TYPE_DEFAULT, "handleHciCmd: opCode 0x%04X", (uint8_t *)v7, 8u);
  }

  if (*v4)
  {
    sub_10045A520(v4, 1);
    sub_10045A5A8((uint64_t)v4, v5);
    sub_10045A520(v4, 0);
    sub_10045A520(v4, 0);
    sub_1002E673C(a1, v4);
  }

  if (*((_BYTE *)v4 + 14) == 2) {
    *((_WORD *)v4 + 5) = *((_WORD *)v4 + 6);
  }
  operator delete(v4);
}

void sub_100458534(_Unwind_Exception *a1)
{
}

void sub_100458550(uint64_t a1, unsigned __int16 *a2)
{
  int v4 = (uint64_t *)operator new(0x18uLL);
  sub_10026163C((uint64_t)v4, 0xEu, 12);
  int v5 = *a2;
  unsigned __int16 v6 = (os_log_s *)qword_1008F7710;
  if (os_log_type_enabled((os_log_t)qword_1008F7710, OS_LOG_TYPE_DEFAULT))
  {
    v7[0] = 67109120;
    v7[1] = v5;
    _os_log_impl((void *)&_mh_execute_header, v6, OS_LOG_TYPE_DEFAULT, "handleHciCmd: opCode 0x%04X", (uint8_t *)v7, 8u);
  }

  if (*v4)
  {
    sub_10045A520(v4, 1);
    sub_10045A5A8((uint64_t)v4, v5);
    sub_10045A520(v4, 0);
    sub_10045A520(v4, 6);
    sub_10045A5A8((uint64_t)v4, 4096);
    sub_10045A520(v4, 6);
    sub_10045A5A8((uint64_t)v4, 15);
    sub_10045A5A8((uint64_t)v4, 8718);
    sub_1002E673C(a1, v4);
  }

  if (*((_BYTE *)v4 + 14) == 2) {
    *((_WORD *)v4 + 5) = *((_WORD *)v4 + 6);
  }
  operator delete(v4);
}

void sub_1004586A8(_Unwind_Exception *a1)
{
}

void sub_1004586C4(uint64_t a1, unsigned __int16 *a2)
{
  int v4 = (uint64_t *)operator new(0x18uLL);
  sub_10026163C((uint64_t)v4, 0xEu, 68);
  int v5 = *a2;
  v11[0] = xmmword_1006C31ED;
  v11[1] = unk_1006C31FD;
  void v11[2] = xmmword_1006C320D;
  v11[3] = unk_1006C321D;
  unsigned __int16 v6 = (os_log_s *)qword_1008F7710;
  if (os_log_type_enabled((os_log_t)qword_1008F7710, OS_LOG_TYPE_DEFAULT))
  {
    int v7 = 136315394;
    id v8 = "handleHciReadLocalSupCmdsCmd";
    __int16 v9 = 1024;
    int v10 = v5;
    _os_log_impl((void *)&_mh_execute_header, v6, OS_LOG_TYPE_DEFAULT, "%s: opCode 0x%04X", (uint8_t *)&v7, 0x12u);
  }

  if (*v4)
  {
    sub_10045A520(v4, 1);
    sub_10045A5A8((uint64_t)v4, v5);
    sub_10045A520(v4, 0);
    sub_10045A64C(v4, v11, 0x40u);
    sub_1002E673C(a1, v4);
  }

  if (*((_BYTE *)v4 + 14) == 2) {
    *((_WORD *)v4 + 5) = *((_WORD *)v4 + 6);
  }
  operator delete(v4);
}

void sub_10045881C(_Unwind_Exception *a1)
{
}

void sub_100458838(uint64_t a1, unsigned __int16 *a2)
{
  int v4 = (uint64_t *)operator new(0x18uLL);
  sub_10026163C((uint64_t)v4, 0xEu, 12);
  int v5 = *a2;
  unint64_t v11 = 0x877BFFDBFE8FFEBFLL;
  unsigned __int16 v6 = (os_log_s *)qword_1008F7710;
  if (os_log_type_enabled((os_log_t)qword_1008F7710, OS_LOG_TYPE_DEFAULT))
  {
    int v7 = 136315394;
    id v8 = "handleHciReadLocalFeaturesCmd";
    __int16 v9 = 1024;
    int v10 = v5;
    _os_log_impl((void *)&_mh_execute_header, v6, OS_LOG_TYPE_DEFAULT, "%s: opCode 0x%04X", (uint8_t *)&v7, 0x12u);
  }

  if (*v4)
  {
    sub_10045A520(v4, 1);
    sub_10045A5A8((uint64_t)v4, v5);
    sub_10045A520(v4, 0);
    sub_10045A64C(v4, &v11, 8u);
    sub_1002E673C(a1, v4);
  }

  if (*((_BYTE *)v4 + 14) == 2) {
    *((_WORD *)v4 + 5) = *((_WORD *)v4 + 6);
  }
  operator delete(v4);
}

void sub_10045898C(_Unwind_Exception *a1)
{
}

void sub_1004589A8(uint64_t a1, unsigned __int16 *a2)
{
  int v4 = (uint64_t *)operator new(0x18uLL);
  sub_10026163C((uint64_t)v4, 0xEu, 14);
  int v5 = *a2;
  uint64_t v11 = 0x7F0F000000000000LL;
  unsigned __int16 v6 = (os_log_s *)qword_1008F7710;
  if (os_log_type_enabled((os_log_t)qword_1008F7710, OS_LOG_TYPE_DEFAULT))
  {
    int v7 = 136315394;
    id v8 = "handleHciReadLocalExtFeaturesCmd";
    __int16 v9 = 1024;
    int v10 = v5;
    _os_log_impl((void *)&_mh_execute_header, v6, OS_LOG_TYPE_DEFAULT, "%s: opCode 0x%04X", (uint8_t *)&v7, 0x12u);
  }

  if (*v4)
  {
    sub_10045A520(v4, 1);
    sub_10045A5A8((uint64_t)v4, v5);
    sub_10045A520(v4, 0);
    sub_10045A520(v4, 2);
    sub_10045A520(v4, 1);
    sub_10045A64C(v4, &v11, 8u);
    sub_1002E673C(a1, v4);
  }

  if (*((_BYTE *)v4 + 14) == 2) {
    *((_WORD *)v4 + 5) = *((_WORD *)v4 + 6);
  }
  operator delete(v4);
}

void sub_100458B08(_Unwind_Exception *a1)
{
}

void sub_100458B24(uint64_t a1, unsigned __int16 *a2)
{
  int v4 = (uint64_t *)operator new(0x18uLL);
  sub_10026163C((uint64_t)v4, 0xEu, 11);
  int v5 = *a2;
  unsigned __int16 v6 = (os_log_s *)qword_1008F7710;
  if (os_log_type_enabled((os_log_t)qword_1008F7710, OS_LOG_TYPE_DEFAULT))
  {
    int v7 = 136315394;
    id v8 = "handleHciReadBufferSizeCmd";
    __int16 v9 = 1024;
    int v10 = v5;
    _os_log_impl((void *)&_mh_execute_header, v6, OS_LOG_TYPE_DEFAULT, "%s: opCode 0x%04X", (uint8_t *)&v7, 0x12u);
  }

  if (*v4)
  {
    sub_10045A520(v4, 1);
    sub_10045A5A8((uint64_t)v4, v5);
    sub_10045A520(v4, 0);
    sub_10045A5A8((uint64_t)v4, 1021);
    sub_10045A520(v4, 64);
    sub_10045A5A8((uint64_t)v4, 8);
    sub_10045A5A8((uint64_t)v4, 1);
    sub_1002E673C(a1, v4);
  }

  if (*((_BYTE *)v4 + 14) == 2) {
    *((_WORD *)v4 + 5) = *((_WORD *)v4 + 6);
  }
  operator delete(v4);
}

void sub_100458C84(_Unwind_Exception *a1)
{
}

void sub_100458CA0(uint64_t a1, unsigned __int16 *a2)
{
  int v4 = (uint64_t *)operator new(0x18uLL);
  sub_10026163C((uint64_t)v4, 0xEu, 10);
  int v5 = *a2;
  if (qword_1008D9988 != -1) {
    dispatch_once(&qword_1008D9988, &stru_100899798);
  }
  unsigned __int16 v6 = (unsigned int *)off_1008D9980;
  int v7 = (os_log_s *)qword_1008F7710;
  if (os_log_type_enabled((os_log_t)qword_1008F7710, OS_LOG_TYPE_DEFAULT))
  {
    int v8 = 136315394;
    __int16 v9 = "handleHciReadBdaddrCmd";
    __int16 v10 = 1024;
    int v11 = v5;
    _os_log_impl((void *)&_mh_execute_header, v7, OS_LOG_TYPE_DEFAULT, "%s: opCode 0x%04X", (uint8_t *)&v8, 0x12u);
  }

  if (*v4)
  {
    sub_10045A520(v4, 1);
    sub_10045A5A8((uint64_t)v4, v5);
    sub_10045A520(v4, 0);
    sub_10045A714((uint64_t)v4, v6[4] | ((unint64_t)*((unsigned __int16 *)v6 + 10) << 32));
    sub_1002E673C(a1, v4);
  }

  if (*((_BYTE *)v4 + 14) == 2) {
    *((_WORD *)v4 + 5) = *((_WORD *)v4 + 6);
  }
  operator delete(v4);
}

void sub_100458E1C(_Unwind_Exception *a1)
{
}

void sub_100458E38(uint64_t a1, unsigned __int16 *a2)
{
  int v4 = (uint64_t *)operator new(0x18uLL);
  sub_10026163C((uint64_t)v4, 0xEu, 7);
  int v5 = *a2;
  unsigned __int16 v6 = (os_log_s *)qword_1008F7710;
  if (os_log_type_enabled((os_log_t)qword_1008F7710, OS_LOG_TYPE_DEFAULT))
  {
    int v7 = 136315394;
    int v8 = "handleHciLeReadBufferSizeCmd";
    __int16 v9 = 1024;
    int v10 = v5;
    _os_log_impl((void *)&_mh_execute_header, v6, OS_LOG_TYPE_DEFAULT, "%s: opCode 0x%04X", (uint8_t *)&v7, 0x12u);
  }

  if (*v4)
  {
    sub_10045A520(v4, 1);
    sub_10045A5A8((uint64_t)v4, v5);
    sub_10045A520(v4, 0);
    sub_10045A5A8((uint64_t)v4, 27);
    sub_10045A520(v4, 15);
    sub_1002E673C(a1, v4);
  }

  if (*((_BYTE *)v4 + 14) == 2) {
    *((_WORD *)v4 + 5) = *((_WORD *)v4 + 6);
  }
  operator delete(v4);
}

void sub_100458F80(_Unwind_Exception *a1)
{
}

void sub_100458F9C(uint64_t a1, unsigned __int16 *a2)
{
  int v4 = (uint64_t *)operator new(0x18uLL);
  sub_10026163C((uint64_t)v4, 0xEu, 12);
  int v5 = *a2;
  uint64_t v11 = 0xB8FF0179FFLL;
  unsigned __int16 v6 = (os_log_s *)qword_1008F7710;
  if (os_log_type_enabled((os_log_t)qword_1008F7710, OS_LOG_TYPE_DEFAULT))
  {
    int v7 = 136315394;
    int v8 = "handleHciLeReadLocalFeaturesCmd";
    __int16 v9 = 1024;
    int v10 = v5;
    _os_log_impl((void *)&_mh_execute_header, v6, OS_LOG_TYPE_DEFAULT, "%s: opCode 0x%04X", (uint8_t *)&v7, 0x12u);
  }

  if (*v4)
  {
    sub_10045A520(v4, 1);
    sub_10045A5A8((uint64_t)v4, v5);
    sub_10045A520(v4, 0);
    sub_10045A64C(v4, &v11, 8u);
    sub_1002E673C(a1, v4);
  }

  if (*((_BYTE *)v4 + 14) == 2) {
    *((_WORD *)v4 + 5) = *((_WORD *)v4 + 6);
  }
  operator delete(v4);
}

void sub_1004590EC(_Unwind_Exception *a1)
{
}

void sub_100459108(uint64_t a1, unsigned __int16 *a2)
{
  int v4 = (uint64_t *)operator new(0x18uLL);
  sub_10026163C((uint64_t)v4, 0xEu, 12);
  int v5 = *a2;
  unsigned __int16 v6 = (os_log_s *)qword_1008F7710;
  if (os_log_type_enabled((os_log_t)qword_1008F7710, OS_LOG_TYPE_DEFAULT))
  {
    int v7 = 136315394;
    int v8 = "handleLeReadAdvChannelTxPowerCmd";
    __int16 v9 = 1024;
    int v10 = v5;
    _os_log_impl((void *)&_mh_execute_header, v6, OS_LOG_TYPE_DEFAULT, "%s: opCode 0x%04X", (uint8_t *)&v7, 0x12u);
  }

  if (*v4)
  {
    sub_10045A520(v4, 1);
    sub_10045A5A8((uint64_t)v4, v5);
    sub_10045A520(v4, 0);
    sub_10045A520(v4, 10);
    sub_1002E673C(a1, v4);
  }

  if (*((_BYTE *)v4 + 14) == 2) {
    *((_WORD *)v4 + 5) = *((_WORD *)v4 + 6);
  }
  operator delete(v4);
}

void sub_100459244(_Unwind_Exception *a1)
{
}

void sub_100459260(uint64_t a1, unsigned __int16 *a2)
{
  int v4 = (uint64_t *)operator new(0x18uLL);
  sub_10026163C((uint64_t)v4, 0xEu, 5);
  int v5 = *a2;
  unsigned __int16 v6 = (os_log_s *)qword_1008F7710;
  if (os_log_type_enabled((os_log_t)qword_1008F7710, OS_LOG_TYPE_DEFAULT))
  {
    int v7 = 136315394;
    int v8 = "handleHciLeReadFilterAcceptListSizeCmd";
    __int16 v9 = 1024;
    int v10 = v5;
    _os_log_impl((void *)&_mh_execute_header, v6, OS_LOG_TYPE_DEFAULT, "%s: opCode 0x%04X", (uint8_t *)&v7, 0x12u);
  }

  if (*v4)
  {
    sub_10045A520(v4, 1);
    sub_10045A5A8((uint64_t)v4, v5);
    sub_10045A520(v4, 0);
    sub_10045A520(v4, 50);
    sub_1002E673C(a1, v4);
  }

  if (*((_BYTE *)v4 + 14) == 2) {
    *((_WORD *)v4 + 5) = *((_WORD *)v4 + 6);
  }
  operator delete(v4);
}

void sub_10045939C(_Unwind_Exception *a1)
{
}

void sub_1004593B8(uint64_t a1, unsigned __int16 *a2)
{
  int v4 = (uint64_t *)operator new(0x18uLL);
  sub_10026163C((uint64_t)v4, 0xEu, 12);
  int v5 = *a2;
  uint64_t v11 = 0x1FFFFFFFLL;
  unsigned __int16 v6 = (os_log_s *)qword_1008F7710;
  if (os_log_type_enabled((os_log_t)qword_1008F7710, OS_LOG_TYPE_DEFAULT))
  {
    int v7 = 136315394;
    int v8 = "handleHciLeReadSupportedStateCmd";
    __int16 v9 = 1024;
    int v10 = v5;
    _os_log_impl((void *)&_mh_execute_header, v6, OS_LOG_TYPE_DEFAULT, "%s: opCode 0x%04X", (uint8_t *)&v7, 0x12u);
  }

  if (*v4)
  {
    sub_10045A520(v4, 1);
    sub_10045A5A8((uint64_t)v4, v5);
    sub_10045A520(v4, 0);
    sub_10045A64C(v4, &v11, 8u);
    sub_1002E673C(a1, v4);
  }

  if (*((_BYTE *)v4 + 14) == 2) {
    *((_WORD *)v4 + 5) = *((_WORD *)v4 + 6);
  }
  operator delete(v4);
}

void sub_100459500(_Unwind_Exception *a1)
{
}

void sub_10045951C(uint64_t a1, unsigned __int16 *a2)
{
  int v4 = (uint64_t *)operator new(0x18uLL);
  sub_10026163C((uint64_t)v4, 0xEu, 12);
  int v5 = *a2;
  unsigned __int16 v6 = (os_log_s *)qword_1008F7710;
  if (os_log_type_enabled((os_log_t)qword_1008F7710, OS_LOG_TYPE_DEFAULT))
  {
    int v7 = 136315394;
    int v8 = "handleHciLeReadMaximumDataLengthCmd";
    __int16 v9 = 1024;
    int v10 = v5;
    _os_log_impl((void *)&_mh_execute_header, v6, OS_LOG_TYPE_DEFAULT, "%s: opCode 0x%04X", (uint8_t *)&v7, 0x12u);
  }

  if (*v4)
  {
    sub_10045A520(v4, 1);
    sub_10045A5A8((uint64_t)v4, v5);
    sub_10045A520(v4, 0);
    sub_10045A5A8((uint64_t)v4, 251);
    sub_10045A5A8((uint64_t)v4, 17040);
    sub_10045A5A8((uint64_t)v4, 251);
    sub_10045A5A8((uint64_t)v4, 17040);
    sub_1002E673C(a1, v4);
  }

  if (*((_BYTE *)v4 + 14) == 2) {
    *((_WORD *)v4 + 5) = *((_WORD *)v4 + 6);
  }
  operator delete(v4);
}

void sub_10045967C(_Unwind_Exception *a1)
{
}

uint64_t sub_100459698(uint64_t a1, unsigned __int8 *a2)
{
  unsigned __int16 v9 = 0;
  unsigned int v8 = 0;
  if (!a2) {
    sub_1000E6B88( "/Library/Caches/com.apple.xbs/Sources/MobileBluetooth_base/Server/Platforms/Darwin/VirtualController/BTVirtualHciC ommandChannel.mm",  537,  "(uint8_t *)buff");
  }
  int v3 = *a2;
  int v4 = a2[1];
  uint64_t v5 = a2[3];
  sub_1001F0050((uint64_t)&v8, (uint64_t)(a2 + 4), 6uLL);
  if (qword_1008D9998 != -1) {
    dispatch_once(&qword_1008D9998, &stru_100899778);
  }
  char v6 = sub_1003A3558((id *)qword_1008D9990, v5, v8 | ((unint64_t)v9 << 32));
  return sub_100459FD8(a1, v3 | (v4 << 8), v6);
}

void sub_100459760(uint64_t a1, unsigned __int16 *a2)
{
  unsigned __int16 v26 = 0;
  unsigned int v25 = 0;
  if (!a2) {
    sub_1000E6B88( "/Library/Caches/com.apple.xbs/Sources/MobileBluetooth_base/Server/Platforms/Darwin/VirtualController/BTVirtualHciC ommandChannel.mm",  578,  "(uint8_t *)buff");
  }
  int v3 = *a2;
  int v4 = *((unsigned __int8 *)a2 + 8);
  int v5 = a2[3];
  int v6 = *((unsigned __int8 *)a2 + 11);
  int v7 = *(unsigned __int16 *)((char *)a2 + 9);
  unsigned int v23 = *((unsigned __int8 *)a2 + 12);
  unsigned int v24 = *((unsigned __int8 *)a2 + 3);
  unsigned __int16 v21 = a2[2];
  unsigned int v22 = *((unsigned __int8 *)a2 + 13);
  unsigned int v20 = *((unsigned __int8 *)a2 + 14);
  sub_1001F0050((uint64_t)&v25, (uint64_t)a2 + 15, 6uLL);
  uint64_t v8 = v5 | (v4 << 16);
  uint64_t v9 = v7 | (v6 << 16);
  char v10 = *((_BYTE *)a2 + 21);
  unsigned __int8 v11 = *((_BYTE *)a2 + 22);
  unsigned __int8 v12 = *((_BYTE *)a2 + 23);
  char v13 = *((_BYTE *)a2 + 24);
  unsigned __int8 v14 = *((_BYTE *)a2 + 25);
  unsigned __int8 v15 = *((_BYTE *)a2 + 26);
  if (qword_1008D9998 != -1) {
    dispatch_once(&qword_1008D9998, &stru_100899778);
  }
  char v16 = sub_1003A3640( (id *)qword_1008D9990,  v24,  v21,  v8,  v9,  v23,  v22,  v20,  v25 | ((unint64_t)v26 << 32),  v10,  v11,  v12,  v13,  v14,  v15);
  uint64_t v17 = (uint64_t *)operator new(0x18uLL);
  sub_10026163C((uint64_t)v17, 0xEu, 6);
  int v18 = (os_log_s *)qword_1008F7710;
  if (os_log_type_enabled((os_log_t)qword_1008F7710, OS_LOG_TYPE_DEFAULT))
  {
    *(_DWORD *)__int128 buf = 136315394;
    int v28 = "handleHciLeSetExtendedAdvertisingParametersCmd";
    __int16 v29 = 1024;
    int v30 = v3;
    _os_log_impl((void *)&_mh_execute_header, v18, OS_LOG_TYPE_DEFAULT, "%s: opCode 0x%04X", buf, 0x12u);
  }

  if (*v17)
  {
    sub_10045A520(v17, 1);
    sub_10045A5A8((uint64_t)v17, v3);
    sub_10045A520(v17, v16);
    sub_10045A520(v17, 14);
    sub_1002E673C(a1, v17);
  }

  if (*((_BYTE *)v17 + 14) == 2) {
    *((_WORD *)v17 + 5) = *((_WORD *)v17 + 6);
  }
  operator delete(v17);
}

void sub_1004599B8(_Unwind_Exception *a1)
{
}

uint64_t sub_1004599D4(uint64_t a1, unsigned __int8 *a2)
{
  if (!a2) {
    sub_1000E6B88( "/Library/Caches/com.apple.xbs/Sources/MobileBluetooth_base/Server/Platforms/Darwin/VirtualController/BTVirtualHciC ommandChannel.mm",  652,  "(uint8_t *)buff");
  }
  memset(v11, 0, 251);
  int v3 = *a2;
  int v4 = a2[1];
  size_t v5 = a2[6];
  if (v5 > 0xFB)
  {
    char v9 = 18;
  }

  else
  {
    if ((_DWORD)v5 == 251) {
      sub_1000E6B88( "/Library/Caches/com.apple.xbs/Sources/MobileBluetooth_base/Server/Platforms/Darwin/VirtualController/BTVirtualHc iCommandChannel.mm",  662,  "ByteStream_NumReadBytesAvail(bs) >= (advertisingDataLength)");
    }
    uint64_t v6 = a2[3];
    uint64_t v7 = a2[4];
    uint64_t v8 = a2[5];
    memcpy(v11, a2 + 7, v5);
    if (qword_1008D9998 != -1) {
      dispatch_once(&qword_1008D9998, &stru_100899778);
    }
    char v9 = sub_1003A38D4((id *)qword_1008D9990, v6, v7, v8, v5, (uint64_t)v11);
  }

  return sub_100459FD8(a1, v3 | (v4 << 8), v9);
}

uint64_t sub_100459B34(uint64_t a1, unsigned __int8 *a2)
{
  if (!a2) {
    sub_1000E6B88( "/Library/Caches/com.apple.xbs/Sources/MobileBluetooth_base/Server/Platforms/Darwin/VirtualController/BTVirtualHciC ommandChannel.mm",  695,  "(uint8_t *)buff");
  }
  __int16 v15 = 0;
  int __dst = 0;
  int v12 = 0;
  __int16 v13 = 0;
  int v10 = 0;
  __int16 v11 = 0;
  int v4 = *a2;
  int v5 = a2[1];
  int v6 = a2[3];
  size_t v7 = a2[4];
  if (a2[4])
  {
    if (v7 > 6)
    {
      char v8 = 18;
      return sub_100459FD8(a1, v4 | (v5 << 8), v8);
    }

    memcpy(&__dst, a2 + 5, v7);
    memcpy(&v12, &a2[v7 + 5], v7);
    memcpy(&v10, &a2[(v7 + 5 + v7)], v7);
  }

  if (qword_1008D9998 != -1) {
    dispatch_once(&qword_1008D9998, &stru_100899778);
  }
  char v8 = sub_1003A39DC((id *)qword_1008D9990, v6, v7, (unsigned __int8 *)&__dst);
  return sub_100459FD8(a1, v4 | (v5 << 8), v8);
}

void sub_100459C5C(uint64_t a1, unsigned __int16 *a2)
{
  int v4 = (uint64_t *)operator new(0x18uLL);
  sub_10026163C((uint64_t)v4, 0xEu, 6);
  int v5 = *a2;
  int v6 = (os_log_s *)qword_1008F7710;
  if (os_log_type_enabled((os_log_t)qword_1008F7710, OS_LOG_TYPE_DEFAULT))
  {
    int v7 = 136315394;
    char v8 = "handleHciLeReadMaxAdvDataLengthCmd";
    __int16 v9 = 1024;
    int v10 = v5;
    _os_log_impl((void *)&_mh_execute_header, v6, OS_LOG_TYPE_DEFAULT, "%s: opCode 0x%04X", (uint8_t *)&v7, 0x12u);
  }

  if (*v4)
  {
    sub_10045A520(v4, 1);
    sub_10045A5A8((uint64_t)v4, v5);
    sub_10045A520(v4, 0);
    sub_10045A5A8((uint64_t)v4, 1650);
    sub_1002E673C(a1, v4);
  }

  if (*((_BYTE *)v4 + 14) == 2) {
    *((_WORD *)v4 + 5) = *((_WORD *)v4 + 6);
  }
  operator delete(v4);
}

void sub_100459D98(_Unwind_Exception *a1)
{
}

uint64_t sub_100459DB4(uint64_t a1, unsigned __int16 *a2)
{
  if (!a2) {
    sub_1000E6B88( "/Library/Caches/com.apple.xbs/Sources/MobileBluetooth_base/Server/Platforms/Darwin/VirtualController/BTVirtualHciC ommandChannel.mm",  738,  "(uint8_t *)buff");
  }
  int v2 = *((unsigned __int8 *)a2 + 3);
  sub_100459FD8(a1, *a2, 0);
  if (qword_1008D9998 != -1) {
    dispatch_once(&qword_1008D9998, &stru_100899778);
  }
  return sub_1003A3A78((id *)qword_1008D9990, v2);
}

void sub_100459E5C(uint64_t a1, unsigned __int16 *a2)
{
  int v4 = (uint64_t *)operator new(0x18uLL);
  sub_10026163C((uint64_t)v4, 0xEu, 10);
  int v5 = *a2;
  int v6 = (os_log_s *)qword_1008F7710;
  if (os_log_type_enabled((os_log_t)qword_1008F7710, OS_LOG_TYPE_DEFAULT))
  {
    int v7 = 136315394;
    char v8 = "handleHciLeReadBufferSizeV2Cmd";
    __int16 v9 = 1024;
    int v10 = v5;
    _os_log_impl((void *)&_mh_execute_header, v6, OS_LOG_TYPE_DEFAULT, "%s: opCode 0x%04X", (uint8_t *)&v7, 0x12u);
  }

  if (*v4)
  {
    sub_10045A520(v4, 1);
    sub_10045A5A8((uint64_t)v4, v5);
    sub_10045A520(v4, 0);
    sub_10045A5A8((uint64_t)v4, 251);
    sub_10045A5A8((uint64_t)v4, 15);
    sub_10045A5A8((uint64_t)v4, 960);
    sub_10045A5A8((uint64_t)v4, 16);
    sub_1002E673C(a1, v4);
  }

  if (*((_BYTE *)v4 + 14) == 2) {
    *((_WORD *)v4 + 5) = *((_WORD *)v4 + 6);
  }
  operator delete(v4);
}

void sub_100459FBC(_Unwind_Exception *a1)
{
}

uint64_t sub_100459FD8(uint64_t a1, int a2, char a3)
{
  int v6 = (uint64_t *)operator new(0x18uLL);
  sub_10026163C((uint64_t)v6, 0xEu, 4);
  int v7 = (os_log_s *)qword_1008F7710;
  if (os_log_type_enabled((os_log_t)qword_1008F7710, OS_LOG_TYPE_DEFAULT))
  {
    int v9 = 136315394;
    int v10 = "sendHciCommandCompleteEvent";
    __int16 v11 = 1024;
    int v12 = a2;
    _os_log_impl((void *)&_mh_execute_header, v7, OS_LOG_TYPE_DEFAULT, "%s: opCode 0x%04X", (uint8_t *)&v9, 0x12u);
  }

  if (*v6)
  {
    sub_10045A520(v6, 1);
    sub_10045A5A8((uint64_t)v6, a2);
    sub_10045A520(v6, a3);
    sub_1002E673C(a1, v6);
  }

  if (*((_BYTE *)v6 + 14) == 2) {
    *((_WORD *)v6 + 5) = *((_WORD *)v6 + 6);
  }
  operator delete(v6);
  return 1LL;
}

void sub_10045A114(_Unwind_Exception *a1)
{
}

uint64_t sub_10045A130(uint64_t a1, int a2, char a3)
{
  int v6 = (uint64_t *)operator new(0x18uLL);
  sub_10026163C((uint64_t)v6, 0xFu, 4);
  int v7 = (os_log_s *)qword_1008F7710;
  if (os_log_type_enabled((os_log_t)qword_1008F7710, OS_LOG_TYPE_DEFAULT))
  {
    int v9 = 136315394;
    int v10 = "sendHciCommandStatusEvent";
    __int16 v11 = 1024;
    int v12 = a2;
    _os_log_impl((void *)&_mh_execute_header, v7, OS_LOG_TYPE_DEFAULT, "%s: opCode 0x%04X", (uint8_t *)&v9, 0x12u);
  }

  if (*v6)
  {
    sub_10045A520(v6, a3);
    sub_10045A520(v6, 1);
    sub_10045A5A8((uint64_t)v6, a2);
    sub_1002E673C(a1, v6);
  }

  if (*((_BYTE *)v6 + 14) == 2) {
    *((_WORD *)v6 + 5) = *((_WORD *)v6 + 6);
  }
  operator delete(v6);
  return 1LL;
}

void sub_10045A26C(_Unwind_Exception *a1)
{
}

uint64_t sub_10045A288(uint64_t a1, unsigned int a2)
{
  int v4 = (uint64_t *)operator new(0x18uLL);
  sub_10026163C((uint64_t)v4, 1u, 1);
  int v5 = (os_log_s *)qword_1008F7710;
  if (os_log_type_enabled((os_log_t)qword_1008F7710, OS_LOG_TYPE_DEFAULT))
  {
    int v7 = 136315138;
    char v8 = "sendHciInquiryCompleteEvent";
    _os_log_impl((void *)&_mh_execute_header, v5, OS_LOG_TYPE_DEFAULT, "%s", (uint8_t *)&v7, 0xCu);
  }

  if (*v4)
  {
    sub_10045A520(v4, 0);
    sub_1002E6938(a1, v4, a2);
  }

  if (*((_BYTE *)v4 + 14) == 2) {
    *((_WORD *)v4 + 5) = *((_WORD *)v4 + 6);
  }
  operator delete(v4);
  return 1LL;
}

void sub_10045A398(_Unwind_Exception *a1)
{
}

uint64_t sub_10045A3B4(uint64_t a1, uint64_t a2, char a3, unsigned int a4)
{
  char v8 = (uint64_t *)operator new(0x18uLL);
  sub_10026163C((uint64_t)v8, 3u, 11);
  int v9 = (os_log_s *)qword_1008F7710;
  if (os_log_type_enabled((os_log_t)qword_1008F7710, OS_LOG_TYPE_DEFAULT))
  {
    int v11 = 136315138;
    int v12 = "sendHciConnectionCompleteEvent";
    _os_log_impl((void *)&_mh_execute_header, v9, OS_LOG_TYPE_DEFAULT, "%s", (uint8_t *)&v11, 0xCu);
  }

  if (*v8)
  {
    sub_10045A520(v8, a3);
    sub_10045A5A8((uint64_t)v8, 0);
    sub_10045A714((uint64_t)v8, a2 & 0xFFFFFFFFFFFFLL);
    sub_10045A520(v8, 1);
    sub_10045A520(v8, 0);
    sub_1002E6938(a1, v8, a4);
  }

  if (*((_BYTE *)v8 + 14) == 2) {
    *((_WORD *)v8 + 5) = *((_WORD *)v8 + 6);
  }
  operator delete(v8);
  return 1LL;
}

void sub_10045A504(_Unwind_Exception *a1)
{
}

uint64_t *sub_10045A520(uint64_t *result, char a2)
{
  if (*((_BYTE *)result + 15))
  {
    sub_1001ED1C4((uint64_t)"/Library/Caches/com.apple.xbs/Sources/MobileBluetooth_base/Server/Platforms/Darwin/VirtualCon"
                           "troller/include/BTVirtualHciPacket.h");
    goto LABEL_6;
  }

  uint64_t v2 = *((unsigned __int16 *)result + 6);
  if (*((unsigned __int16 *)result + 5) <= v2)
  {
LABEL_6:
    int v4 = "ByteStream_NumReadBytesAvail(fBs) >= 1";
    goto LABEL_8;
  }

  if (*((_BYTE *)result + 14) != 2)
  {
    int v4 = "(fBs).__RWFlag == BYTESTREAM_WRITE";
LABEL_8:
    sub_1000E6B88( "/Library/Caches/com.apple.xbs/Sources/MobileBluetooth_base/Server/Platforms/Darwin/VirtualController/include/BTVirtualHciPacket.h",  30,  v4);
  }

  uint64_t v3 = *result;
  *((_WORD *)result + 6) = v2 + 1;
  *(_BYTE *)(v3 + v2) = a2;
  return result;
}

uint64_t sub_10045A5A8(uint64_t result, __int16 a2)
{
  if (*(_BYTE *)(result + 15))
  {
    sub_1001ED1C4((uint64_t)"/Library/Caches/com.apple.xbs/Sources/MobileBluetooth_base/Server/Platforms/Darwin/VirtualCon"
                           "troller/include/BTVirtualHciPacket.h");
    goto LABEL_6;
  }

  uint64_t v2 = *(unsigned __int16 *)(result + 12);
  if (*(unsigned __int16 *)(result + 10) - (int)v2 <= 1)
  {
LABEL_6:
    uint64_t v3 = "ByteStream_NumReadBytesAvail(fBs) >= 2";
    goto LABEL_8;
  }

  if (*(_BYTE *)(result + 14) != 2)
  {
    uint64_t v3 = "(fBs).__RWFlag == BYTESTREAM_WRITE";
LABEL_8:
    sub_1000E6B88( "/Library/Caches/com.apple.xbs/Sources/MobileBluetooth_base/Server/Platforms/Darwin/VirtualController/include/BTVirtualHciPacket.h",  31,  v3);
  }

  *(_BYTE *)(*(void *)result + v2) = a2;
  *(_BYTE *)(*(void *)result + *(unsigned __int16 *)(result + 12) + 1LL) = HIBYTE(a2);
  *(_WORD *)(result + 12) += 2;
  return result;
}

void *sub_10045A64C(uint64_t *a1, const void *a2, unsigned int a3)
{
  uint64_t v6 = *a1;
  unsigned int v7 = *((unsigned __int16 *)a1 + 6);
  if (*((_BYTE *)a1 + 15))
  {
    sub_1001ED1C4((uint64_t)"/Library/Caches/com.apple.xbs/Sources/MobileBluetooth_base/Server/Platforms/Darwin/VirtualCon"
                           "troller/include/BTVirtualHciPacket.h");
    unsigned int v8 = 0;
  }

  else
  {
    unsigned int v8 = *((unsigned __int16 *)a1 + 5) - v7;
  }

  if (v8 < a3)
  {
    int v10 = "ByteStream_NumReadBytesAvail(fBs) >= (N)";
    goto LABEL_9;
  }

  if (*((_BYTE *)a1 + 14) != 2)
  {
    int v10 = "(fBs).__RWFlag == BYTESTREAM_WRITE";
LABEL_9:
    sub_1000E6B88( "/Library/Caches/com.apple.xbs/Sources/MobileBluetooth_base/Server/Platforms/Darwin/VirtualController/include/BTVirtualHciPacket.h",  34,  v10);
  }

  uint64_t result = memmove((void *)(v6 + v7), a2, a3);
  *((_WORD *)a1 + 6) += a3;
  return result;
}

uint64_t sub_10045A714(uint64_t a1, uint64_t a2)
{
  int v6 = a2;
  __int16 v7 = WORD2(a2);
  if (*(_BYTE *)(a1 + 15))
  {
    sub_1001ED1C4((uint64_t)"/Library/Caches/com.apple.xbs/Sources/MobileBluetooth_base/Server/Platforms/Darwin/VirtualCon"
                           "troller/include/BTVirtualHciPacket.h");
    goto LABEL_6;
  }

  uint64_t v3 = *(unsigned __int16 *)(a1 + 12);
  if (*(unsigned __int16 *)(a1 + 10) - (int)v3 <= 5)
  {
LABEL_6:
    int v5 = "ByteStream_NumReadBytesAvail(fBs) >= OI_BD_ADDR_BYTE_SIZE";
    goto LABEL_8;
  }

  if (*(_BYTE *)(a1 + 14) != 2)
  {
    int v5 = "(fBs).__RWFlag == BYTESTREAM_WRITE";
LABEL_8:
    sub_1000E6B88( "/Library/Caches/com.apple.xbs/Sources/MobileBluetooth_base/Server/Platforms/Darwin/VirtualController/include/BTVirtualHciPacket.h",  33,  v5);
  }

  uint64_t result = sub_1001F0050(*(void *)a1 + v3, (uint64_t)&v6, 6uLL);
  *(_WORD *)(a1 + 12) += 6;
  return result;
}

void sub_10045A7D0( uint64_t a1, __int16 a2, char a3, uint64_t a4, char a5, char a6, char a7, char a8, char a9, __int16 a10, char a11, uint64_t a12, unsigned __int8 a13, const void *a14)
{
  unsigned __int16 v21 = (uint64_t *)operator new(0x18uLL);
  sub_10026163C((uint64_t)v21, 0x3Eu, a13 + 26);
  unsigned int v22 = (os_log_s *)qword_1008F7710;
  if (os_log_type_enabled((os_log_t)qword_1008F7710, OS_LOG_TYPE_DEFAULT))
  {
    *(_DWORD *)__int128 buf = 136315394;
    unsigned int v25 = "notifyAdvReport";
    __int16 v26 = 1024;
    int v27 = 62;
    _os_log_impl((void *)&_mh_execute_header, v22, OS_LOG_TYPE_DEFAULT, "%s: eventCode 0x%04X", buf, 0x12u);
  }

  if (*v21)
  {
    sub_10045A520(v21, 13);
    sub_10045A520(v21, 1);
    sub_10045A5A8((uint64_t)v21, a2);
    sub_10045A520(v21, a3);
    sub_10045A714((uint64_t)v21, a4 & 0xFFFFFFFFFFFFLL);
    sub_10045A520(v21, a5);
    sub_10045A520(v21, a6);
    sub_10045A520(v21, a7);
    sub_10045A520(v21, a8);
    sub_10045A520(v21, a9);
    sub_10045A5A8((uint64_t)v21, a10);
    sub_10045A520(v21, a11);
    sub_10045A714((uint64_t)v21, a12 & 0xFFFFFFFFFFFFLL);
    sub_10045A520(v21, a13);
    sub_10045A64C(v21, a14, a13);
    sub_1002E673C(a1, v21);
  }

  if (*((_BYTE *)v21 + 14) == 2) {
    *((_WORD *)v21 + 5) = *((_WORD *)v21 + 6);
  }
  operator delete(v21);
}

void sub_10045A9D0(_Unwind_Exception *a1)
{
}

void sub_10045A9EC( uint64_t a1, __int16 a2, char a3, uint64_t a4, char a5, char a6, char a7, char a8, char a9, __int16 a10, char a11, uint64_t a12, unsigned __int8 a13, const void *a14)
{
}

void sub_10045AA28(id *a1)
{
  uint64_t v1 = sub_1002E6518(a1);
  operator delete(v1);
}

void sub_10045AA3C(id a1)
{
  uint64_t v1 = operator new(0x28uLL);
  sub_1003A2DF0((uint64_t)v1);
  qword_1008D9990 = (uint64_t)v1;
}

void sub_10045AA6C(_Unwind_Exception *a1)
{
}

void sub_10045AA80(id a1)
{
  uint64_t v1 = operator new(0x18uLL);
  sub_10064DFE0();
  off_1008D9980 = v1;
}

void sub_10045AAB0(_Unwind_Exception *a1)
{
}

uint64_t sub_10045AAC4(uint64_t a1, uint64_t a2, uint64_t a3, int a4)
{
  *(void *)a1 = off_100898730;
  sub_100242DC4(a1 + 8);
  *(_BYTE *)(a1 + 72) = 0;
  *(_DWORD *)(a1 + sub_10023DF50(v3 + 76) = a4;
  *(void *)a1 = off_1008997C8;
  *(void *)(a1 + 8sub_100414D2C(qword_1008F72C0, 0) = a2;
  *(void *)(a1 + 8_Block_object_dispose((const void *)(v2 - 88), 8) = 0LL;
  sub_100242DC4(a1 + 96);
  *(_DWORD *)(a1 + 16sub_100414D2C(qword_1008F72C0, 0) = 0;
  *(void *)(a1 + 16_Block_object_dispose((const void *)(v2 - 88), 8) = a3;
  *(void *)(a1 + 8_Block_object_dispose((const void *)(v2 - 88), 8) = sub_100405288();
  return a1;
}

void sub_10045AB4C(_Unwind_Exception *a1)
{
  *uint64_t v1 = v4;
  sub_100242E28(v2);
  _Unwind_Resume(a1);
}

uint64_t sub_10045AB78(uint64_t a1, int a2, uint64_t a3, const std::string *a4)
{
  if (qword_1008D5F50 != -1) {
    dispatch_once(&qword_1008D5F50, &stru_100899828);
  }
  WORD2(v11.__r_.__value_.__r.__words[0]) = WORD2(a3);
  LODWORD(v11.__r_.__value_.__l.__data_) = a3;
  unsigned int v8 = (std::string *)sub_1003FFEB0(off_1008D5F48, (uint64_t)&v11, 1);
  if (!a2)
  {
    int v9 = v8;
    if (v8)
    {
      v11.__r_.__value_.__l.__cap_ = 0LL;
      sub_1000B0400((uint64_t)&v11.__r_.__value_.__l.__cap_);
      v11.__r_.__value_.__r.__words[0] = SLODWORD(v11.__r_.__value_.__r.__words[2]);
      v11.__r_.__value_.__l.__size_ = SWORD2(v11.__r_.__value_.__r.__words[2]);
      sub_1003D0F60(v9, a4, &v11);
      (*(void (**)(void, std::string *))(**(void **)(a1 + 80) + 16LL))(*(void *)(a1 + 80), v9);
    }
  }

  return sub_10043B88C(a1, 0LL);
}

void sub_10045AC4C(uint64_t a1)
{
  v3[0] = 0LL;
  v3[1] = 0LL;
  sub_100242F28((uint64_t)v3, a1 + 8);
  int v2 = *(unsigned __int8 *)(a1 + 72);
  sub_100242FAC((uint64_t)v3);
  if (v2)
  {
    sub_1001EE2A0();
  }

  else
  {
    sub_10043B388(a1);
    sub_10045ACA8(a1);
  }

uint64_t sub_10045ACA8(uint64_t a1)
{
  v6[0] = 0LL;
  v6[1] = 0LL;
  sub_100242F28((uint64_t)v6, a1 + 96);
  int v2 = (os_log_s *)qword_1008F7590;
  if (os_log_type_enabled((os_log_t)qword_1008F7590, OS_LOG_TYPE_INFO))
  {
    int v3 = *(_DWORD *)(a1 + 160);
    *(_DWORD *)__int128 buf = 67109120;
    int v8 = v3;
    _os_log_impl((void *)&_mh_execute_header, v2, OS_LOG_TYPE_INFO, "Stepping scan with mode %u", buf, 8u);
  }

  if (*(_DWORD *)(a1 + 160))
  {
    uint64_t v4 = 114LL;
LABEL_6:
    *(_DWORD *)(a1 + 16sub_100414D2C(qword_1008F72C0, 0) = 128;
    sub_100242F54((uint64_t)v6);
    sub_10043B88C(a1, v4);
    return sub_100242FAC((uint64_t)v6);
  }

  *(_DWORD *)(a1 + 16sub_100414D2C(qword_1008F72C0, 0) = 4;
  buf[0] = 0;
  sub_100242CA4(buf);
  uint64_t v4 = sub_10010E844((uint64_t)sub_10045AF40, *(void *)(a1 + 168) + 128LL, 4, a1);
  sub_100242CD8(buf);
  if ((_DWORD)v4) {
    goto LABEL_6;
  }
  return sub_100242FAC((uint64_t)v6);
}

void sub_10045ADD0( _Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, char a11)
{
}

uint64_t sub_10045AE00(uint64_t a1)
{
  v14[0] = 0LL;
  v14[1] = 0LL;
  sub_100242F28((uint64_t)v14, a1 + 96);
  int v2 = (os_log_s *)qword_1008F7590;
  if (os_log_type_enabled((os_log_t)qword_1008F7590, OS_LOG_TYPE_DEFAULT))
  {
    int v3 = *(_DWORD *)(a1 + 160);
    *(_DWORD *)__int128 buf = 67109120;
    int v16 = v3;
    _os_log_impl((void *)&_mh_execute_header, v2, OS_LOG_TYPE_DEFAULT, "Stopping scan with mode %u", buf, 8u);
  }

  int v4 = *(_DWORD *)(a1 + 160);
  if (v4 == 4)
  {
    uint64_t v5 = *(void *)(a1 + 168);
    *(_DWORD *)(a1 + 16sub_100414D2C(qword_1008F72C0, 0) = 128;
    sub_100242F54((uint64_t)v14);
    buf[0] = 0;
    sub_100242CA4(buf);
    sub_10010E8F8(v5 + 128, v6, v7, v8, v9, v10, v11, v12);
    sub_100242CD0(buf);
    sub_100242CD8(buf);
  }

  else if (!v4)
  {
    *(_DWORD *)(a1 + 16sub_100414D2C(qword_1008F72C0, 0) = 128;
  }

  return sub_100242FAC((uint64_t)v14);
}

void sub_10045AF10( _Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9)
{
}

uint64_t sub_10045AF40(uint64_t result, int *a2, std::string::value_type *a3, uint64_t a4)
{
  if (a4)
  {
    int v7 = result;
    uint64_t v8 = operator new(0x40uLL);
    sub_10045AFD4((uint64_t)v8, a4, v7, a2, a3);
    return (*(uint64_t (**)(uint64_t, void *))(*(void *)a4 + 32LL))(a4, v8);
  }

  return result;
}

void sub_10045AFC0(_Unwind_Exception *a1)
{
}

uint64_t sub_10045AFD4(uint64_t a1, uint64_t a2, int a3, int *a4, std::string::value_type *__s)
{
  *(_WORD *)(a1 + _Block_object_dispose((const void *)(v2 - 88), 8) = 1;
  *(void *)a1 = &off_100899800;
  *(void *)(a1 + 16) = a2;
  *(_DWORD *)(a1 + 24) = a3;
  *(void *)(a1 + 4sub_100414D2C(qword_1008F72C0, 0) = 0LL;
  *(void *)(a1 + 4_Block_object_dispose((const void *)(v2 - 88), 8) = 0LL;
  *(void *)(a1 + 56) = 0LL;
  if (a4)
  {
    int v6 = *a4;
    *(_WORD *)(a1 + sub_100242FAC(v1 - 32) = *((_WORD *)a4 + 2);
    *(_DWORD *)(a1 + 2_Block_object_dispose((const void *)(v2 - 88), 8) = v6;
  }

  if (__s) {
    std::string::assign((std::string *)(a1 + 40), __s);
  }
  return a1;
}

void sub_10045B048(_Unwind_Exception *exception_object)
{
}

void sub_10045B064(uint64_t a1)
{
  uint64_t v1 = *(void *)(a1 + 16);
  int v2 = *(_DWORD *)(a1 + 24);
  unint64_t v3 = *(unsigned int *)(a1 + 28) | ((unint64_t)*(unsigned __int16 *)(a1 + 32) << 32);
  else {
    std::string __p = *(std::string *)(a1 + 40);
  }
  sub_10045AB78(v1, v2, v3 & 0xFFFFFFFFFFFFLL, &__p);
}

void sub_10045B0EC( _Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, void *__p, uint64_t a10, int a11, __int16 a12, char a13, char a14)
{
  if (a14 < 0) {
    operator delete(__p);
  }
  _Unwind_Resume(exception_object);
}

uint64_t sub_10045B108(uint64_t a1)
{
  *(void *)a1 = &off_100899800;
  return a1;
}

void sub_10045B144(void **__p)
{
  void *__p = &off_100899800;
  operator delete(__p);
}

void *sub_10045B180(void *a1)
{
  *a1 = off_1008997C8;
  sub_100242E28(a1 + 12);
  *a1 = off_100898730;
  sub_100242E28(a1 + 1);
  return a1;
}

void sub_10045B1C4(void *a1)
{
  *a1 = off_1008997C8;
  sub_100242E28(a1 + 12);
  *a1 = off_100898730;
  sub_100242E28(a1 + 1);
  operator delete(a1);
}

BOOL sub_10045B208(uint64_t a1, _BYTE *a2)
{
  return sub_100405744(*(void *)(a1 + 88), a2);
}

void sub_10045B210(id a1)
{
  uint64_t v1 = operator new(0x138uLL);
  sub_1003FE3E0((uint64_t)v1);
  off_1008D5F48 = v1;
}

void sub_10045B240(_Unwind_Exception *a1)
{
}

uint64_t sub_10045B258(uint64_t a1, uint64_t a2, unsigned int a3, uint64_t a4, int a5)
{
  v20[0] = 0LL;
  v20[1] = 0LL;
  sub_100242F28((uint64_t)v20, a1 + 8);
  uint64_t v10 = *(void **)(a1 + 80);
  uint64_t v11 = (void *)(a1 + 88);
  if (v10 != (void *)(a1 + 88))
  {
    uint64_t v12 = a5;
    do
    {
      uint64_t v13 = v10[4];
      if (v13)
      {
        if (*(_BYTE *)(*(void *)(v13 + 32) + 160LL))
        {
          xpc_object_t v14 = xpc_dictionary_create(0LL, 0LL, 0LL);
          __int16 v15 = v14;
          if (v14)
          {
            xpc_dictionary_set_uint64(v14, "kCBMsgArgID", *(void *)(v13 + 16));
            xpc_dictionary_set_uint64(v15, "kCBMsgArgDiscoveryAgentID", a2);
            xpc_dictionary_set_uint64(v15, "kCBMsgArgStatus", a3);
            xpc_dictionary_set_uint64(v15, "kCBMsgArgBTDevice", a4);
            xpc_dictionary_set_uint64(v15, "kCBMsgArgResult", v12);
            sub_100260FEC(*(void *)(v13 + 32), "kCBMsgIdDiscoveryAgentStatusEvent", v15, 1);
          }
        }
      }

      int v16 = (void *)v10[1];
      if (v16)
      {
        do
        {
          uint64_t v17 = v16;
          int v16 = (void *)*v16;
        }

        while (v16);
      }

      else
      {
        do
        {
          uint64_t v17 = (void *)v10[2];
          BOOL v18 = *v17 == (void)v10;
          uint64_t v10 = v17;
        }

        while (!v18);
      }

      uint64_t v10 = v17;
    }

    while (v17 != v11);
  }

  return sub_100242FAC((uint64_t)v20);
}

void sub_10045B3C4( _Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9)
{
}

uint64_t sub_10045B3D8(uint64_t a1, uint64_t a2, unsigned int a3, uint64_t a4, unsigned int a5)
{
  v20[0] = 0LL;
  v20[1] = 0LL;
  sub_100242F28((uint64_t)v20, a1 + 8);
  uint64_t v10 = *(void **)(a1 + 80);
  uint64_t v11 = (void *)(a1 + 88);
  if (v10 != (void *)(a1 + 88))
  {
    uint64_t v12 = a5;
    do
    {
      uint64_t v13 = v10[4];
      if (v13)
      {
        if (*(_BYTE *)(*(void *)(v13 + 32) + 160LL))
        {
          xpc_object_t v14 = xpc_dictionary_create(0LL, 0LL, 0LL);
          __int16 v15 = v14;
          if (v14)
          {
            xpc_dictionary_set_uint64(v14, "kCBMsgArgID", *(void *)(v13 + 16));
            xpc_dictionary_set_uint64(v15, "kCBMsgArgDiscoveryAgentID", a2);
            xpc_dictionary_set_uint64(v15, "kCBMsgArgEvent", a3);
            xpc_dictionary_set_uint64(v15, "kCBMsgArgBTDevice", a4);
            xpc_dictionary_set_uint64(v15, "kCBMsgArgAttributes", v12);
            sub_100260FEC(*(void *)(v13 + 32), "kCBMsgIdDiscoveryAgentDiscoveryEvent", v15, 1);
          }
        }
      }

      int v16 = (void *)v10[1];
      if (v16)
      {
        do
        {
          uint64_t v17 = v16;
          int v16 = (void *)*v16;
        }

        while (v16);
      }

      else
      {
        do
        {
          uint64_t v17 = (void *)v10[2];
          BOOL v18 = *v17 == (void)v10;
          uint64_t v10 = v17;
        }

        while (!v18);
      }

      uint64_t v10 = v17;
    }

    while (v17 != v11);
  }

  return sub_100242FAC((uint64_t)v20);
}

void sub_10045B544( _Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9)
{
}

uint64_t sub_10045B558(uint64_t result, unsigned int a2, uint64_t a3, int a4, uint64_t a5)
{
  if (a5) {
    return sub_10045B258(a5, result, a2, a3, a4);
  }
  return result;
}

uint64_t sub_10045B57C(uint64_t result, unsigned int a2, uint64_t a3, unsigned int a4, uint64_t a5)
{
  if (a5) {
    return sub_10045B3D8(a5, result, a2, a3, a4);
  }
  return result;
}

void *sub_10045B5A0(void *a1, uint64_t a2)
{
  unint64_t v3 = sub_10043C910(a1, a2);
  *unint64_t v3 = &off_100899858;
  v3[12] = 0LL;
  v3[11] = 0LL;
  v3[10] = v3 + 11;
  if (qword_1008F1050 != -1) {
    dispatch_once(&qword_1008F1050, &stru_100899878);
  }
  return a1;
}

void sub_10045B608(id a1)
{
  uint64_t v9 = "kCBMsgIdDiscoveryAgentCreateMsg";
  uint64_t v10 = 31LL;
  uint64_t v11 = &v9;
  uint64_t v1 = sub_10045C494((uint64_t)&xmmword_1008F74F8, (uint64_t)&v9, (uint64_t)&unk_1006C2518, (_OWORD **)&v11);
  v1[4] = sub_10045B804;
  void v1[5] = 0LL;
  uint64_t v9 = "kCBMsgIdDiscoveryAgentDestroyMsg";
  uint64_t v10 = 32LL;
  uint64_t v11 = &v9;
  int v2 = sub_10045C494((uint64_t)&xmmword_1008F74F8, (uint64_t)&v9, (uint64_t)&unk_1006C2518, (_OWORD **)&v11);
  void v2[4] = sub_10045BA0C;
  void v2[5] = 0LL;
  uint64_t v9 = "kCBMsgIdDiscoveryAgentStartScanMsg";
  uint64_t v10 = 34LL;
  uint64_t v11 = &v9;
  unint64_t v3 = sub_10045C494((uint64_t)&xmmword_1008F74F8, (uint64_t)&v9, (uint64_t)&unk_1006C2518, (_OWORD **)&v11);
  void v3[4] = sub_10045BC34;
  void v3[5] = 0LL;
  uint64_t v9 = "kCBMsgIdDiscoveryAgentStartScanForAdvertizedDataMsg";
  uint64_t v10 = 51LL;
  uint64_t v11 = &v9;
  int v4 = sub_10045C494((uint64_t)&xmmword_1008F74F8, (uint64_t)&v9, (uint64_t)&unk_1006C2518, (_OWORD **)&v11);
  v4[4] = sub_10045BDA4;
  void v4[5] = 0LL;
  uint64_t v9 = "kCBMsgIdDiscoveryAgentStopScanMsg";
  uint64_t v10 = 33LL;
  uint64_t v11 = &v9;
  uint64_t v5 = sub_10045C494((uint64_t)&xmmword_1008F74F8, (uint64_t)&v9, (uint64_t)&unk_1006C2518, (_OWORD **)&v11);
  void v5[4] = sub_10045BE68;
  void v5[5] = 0LL;
  uint64_t v9 = "kCBMsgIdDiscoveryAgentGetDevicesMsg";
  uint64_t v10 = 35LL;
  uint64_t v11 = &v9;
  int v6 = sub_10045C494((uint64_t)&xmmword_1008F74F8, (uint64_t)&v9, (uint64_t)&unk_1006C2518, (_OWORD **)&v11);
  v6[4] = sub_10045BF2C;
  void v6[5] = 0LL;
  uint64_t v9 = "kCBMsgIdDiscoveryAgentAddKeyMsg";
  uint64_t v10 = 31LL;
  uint64_t v11 = &v9;
  int v7 = sub_10045C494((uint64_t)&xmmword_1008F74F8, (uint64_t)&v9, (uint64_t)&unk_1006C2518, (_OWORD **)&v11);
  _OWORD v7[4] = sub_10045C108;
  void v7[5] = 0LL;
  uint64_t v9 = "kCBMsgIdDiscoveryAgentRemoveKeyMsg";
  uint64_t v10 = 34LL;
  uint64_t v11 = &v9;
  uint64_t v8 = sub_10045C494((uint64_t)&xmmword_1008F74F8, (uint64_t)&v9, (uint64_t)&unk_1006C2518, (_OWORD **)&v11);
  void v8[4] = sub_10045C204;
  v8[5] = 0LL;
}

uint64_t sub_10045B804(uint64_t a1, xpc_object_t xdict)
{
  uint64_t value = 0LL;
  xpc_object_t v4 = xpc_dictionary_get_value(xdict, "kCBMsgArgs");
  uint64_t uint64 = xpc_dictionary_get_uint64(v4, "kCBMsgArgSessionID");
  uint64_t v6 = xpc_dictionary_get_uint64(v4, "kCBMsgArgID");
  if (os_log_type_enabled((os_log_t)qword_1008F75F0, OS_LOG_TYPE_DEBUG)) {
    sub_10068094C();
  }
  v15[0] = 0LL;
  v15[1] = 0LL;
  sub_100242F28((uint64_t)v15, a1 + 8);
  if (uint64)
  {
    uint64_t v7 = *(void *)(a1 + 72);
    int v8 = *(_DWORD *)(v7 + 40);
    au_asid_t asid = xpc_connection_get_asid(*(xpc_connection_t *)(v7 + 16));
    if (qword_1008D61A8 != -1) {
      dispatch_once(&qword_1008D61A8, &stru_100899898);
    }
    if (sub_100497B94(qword_1008D61A0, uint64, v8, asid))
    {
      uint64_t v10 = (uint64_t *)calloc(1uLL, 0x28uLL);
      xpc_object_t v14 = v10;
      v10[1] = (uint64_t)sub_10045B57C;
      void v10[2] = v6;
      uint64_t *v10 = (uint64_t)sub_10045B558;
      v10[4] = *(void *)(a1 + 72);
      LODWORD(uintsub_100242FAC(v30 - 64) = sub_1004395C4(uint64, v10, a1, &value);
      if ((_DWORD)uint64)
      {
        free(v10);
      }

      else
      {
        uint64_t v10[3] = value;
        sub_1002555B0((uint64_t **)(a1 + 80), (unint64_t *)&v14, (uint64_t *)&v14);
      }

      uint64_t uint64 = (int)uint64;
    }

    else
    {
      uint64_t uint64 = 7LL;
    }
  }

  else
  {
    uint64_t uint64 = 1LL;
  }

  xpc_object_t reply = xpc_dictionary_create_reply(xdict);
  uint64_t v12 = reply;
  if (reply)
  {
    xpc_dictionary_set_uint64(reply, "kCBMsgArgDiscoveryAgentID", value);
    xpc_dictionary_set_uint64(v12, "kCBMsgArgResult", uint64);
    xpc_connection_send_message(*(xpc_connection_t *)(*(void *)(a1 + 72) + 16LL), v12);
    xpc_release(v12);
  }

  return sub_100242FAC((uint64_t)v15);
}

void sub_10045B9F0(_Unwind_Exception *a1, uint64_t a2, ...)
{
}

uint64_t sub_10045BA0C(void *a1, xpc_object_t xdict)
{
  xpc_object_t value = xpc_dictionary_get_value(xdict, "kCBMsgArgs");
  uint64_t uint64 = xpc_dictionary_get_uint64(value, "kCBMsgArgDiscoveryAgentID");
  uint64_t v6 = (os_log_s *)qword_1008F75F0;
  if (os_log_type_enabled((os_log_t)qword_1008F75F0, OS_LOG_TYPE_DEBUG)) {
    sub_1006809AC(uint64, v6, v7, v8, v9, v10, v11, v12);
  }
  v24[0] = 0LL;
  v24[1] = 0LL;
  sub_100242F28((uint64_t)v24, (uint64_t)(a1 + 1));
  if (!uint64 || (v23 = uint64, uint64_t v13 = (void *)a1[10], v13 == a1 + 11))
  {
    int v14 = 0;
  }

  else
  {
    int v14 = 0;
    do
    {
      unsigned int v22 = (void *)v13[4];
      if (v23 == *((void *)v22 + 3))
      {
        int v14 = sub_1004396B4(&v23);
        if (v14)
        {
          __int16 v15 = (os_log_s *)qword_1008F75F0;
          if (os_log_type_enabled((os_log_t)qword_1008F75F0, OS_LOG_TYPE_ERROR))
          {
            *(_DWORD *)__int128 buf = 134217984;
            uint64_t v26 = uint64;
            _os_log_error_impl( (void *)&_mh_execute_header,  v15,  OS_LOG_TYPE_ERROR,  "Could not destroy discovery agent %llx",  buf,  0xCu);
          }
        }

        else
        {
          sub_10020166C((uint64_t)(a1 + 10), (unint64_t *)&v22);
          free(v22);
          int v14 = 0;
        }
      }

      int v16 = (void *)v13[1];
      if (v16)
      {
        do
        {
          uint64_t v17 = v16;
          int v16 = (void *)*v16;
        }

        while (v16);
      }

      else
      {
        do
        {
          uint64_t v17 = (void *)v13[2];
          BOOL v18 = *v17 == (void)v13;
          uint64_t v13 = v17;
        }

        while (!v18);
      }

      uint64_t v13 = v17;
    }

    while (v17 != a1 + 11);
  }

  xpc_object_t reply = xpc_dictionary_create_reply(xdict);
  unsigned int v20 = reply;
  if (reply)
  {
    xpc_dictionary_set_uint64(reply, "kCBMsgArgResult", v14);
    xpc_connection_send_message(*(xpc_connection_t *)(a1[9] + 16LL), v20);
    xpc_release(v20);
  }

  return sub_100242FAC((uint64_t)v24);
}

void sub_10045BC14( _Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, char a13)
{
}

void sub_10045BC34(uint64_t a1, xpc_object_t xdict)
{
  xpc_object_t value = xpc_dictionary_get_value(xdict, "kCBMsgArgs");
  uint64_t uint64 = xpc_dictionary_get_uint64(value, "kCBMsgArgDiscoveryAgentID");
  uint64_t v6 = xpc_dictionary_get_uint64(value, "kCBMsgArgDiscoveryMode");
  uint64_t v7 = xpc_dictionary_get_uint64(value, "kCBMsgArgServices");
  uint64_t v8 = (os_log_s *)qword_1008F75F0;
  if (os_log_type_enabled((os_log_t)qword_1008F75F0, OS_LOG_TYPE_DEBUG))
  {
    int v12 = 134218496;
    uint64_t v13 = uint64;
    __int16 v14 = 2048;
    uint64_t v15 = v6;
    __int16 v16 = 2048;
    uint64_t v17 = v7;
    _os_log_debug_impl( (void *)&_mh_execute_header,  v8,  OS_LOG_TYPE_DEBUG,  "BTDiscoveryMsgHandler::handleBTDiscoveryAgentStartScanMsg discvoveryAgentID:%llx mode:%llx services:%llx",  (uint8_t *)&v12,  0x20u);
  }

  else if (uint64)
  {
LABEL_3:
    uint64_t v9 = (int)sub_100439710(uint64, v6, v7);
    goto LABEL_6;
  }

  uint64_t v9 = 1LL;
LABEL_6:
  xpc_object_t reply = xpc_dictionary_create_reply(xdict);
  if (reply)
  {
    uint64_t v11 = reply;
    xpc_dictionary_set_uint64(reply, "kCBMsgArgResult", v9);
    xpc_connection_send_message(*(xpc_connection_t *)(*(void *)(a1 + 72) + 16LL), v11);
    xpc_release(v11);
  }

void sub_10045BDA4(uint64_t a1, xpc_object_t xdict)
{
  xpc_object_t value = xpc_dictionary_get_value(xdict, "kCBMsgArgs");
  uint64_t uint64 = xpc_dictionary_get_uint64(value, "kCBMsgArgDiscoveryAgentID");
  if (os_log_type_enabled((os_log_t)qword_1008F75F0, OS_LOG_TYPE_DEBUG))
  {
    sub_100680A14();
  }

  else if (uint64)
  {
LABEL_3:
    uint64_t v6 = (int)sub_100439990(uint64);
    goto LABEL_6;
  }

  uint64_t v6 = 1LL;
LABEL_6:
  xpc_object_t reply = xpc_dictionary_create_reply(xdict);
  if (reply)
  {
    uint64_t v8 = reply;
    xpc_dictionary_set_uint64(reply, "kCBMsgArgResult", v6);
    xpc_connection_send_message(*(xpc_connection_t *)(*(void *)(a1 + 72) + 16LL), v8);
    xpc_release(v8);
  }

void sub_10045BE68(uint64_t a1, xpc_object_t xdict)
{
  xpc_object_t value = xpc_dictionary_get_value(xdict, "kCBMsgArgs");
  uint64_t uint64 = xpc_dictionary_get_uint64(value, "kCBMsgArgDiscoveryAgentID");
  if (os_log_type_enabled((os_log_t)qword_1008F75F0, OS_LOG_TYPE_DEBUG))
  {
    sub_100680A74();
  }

  else if (uint64)
  {
LABEL_3:
    uint64_t v6 = (int)sub_100439AF8(uint64);
    goto LABEL_6;
  }

  uint64_t v6 = 1LL;
LABEL_6:
  xpc_object_t reply = xpc_dictionary_create_reply(xdict);
  if (reply)
  {
    uint64_t v8 = reply;
    xpc_dictionary_set_uint64(reply, "kCBMsgArgResult", v6);
    xpc_connection_send_message(*(xpc_connection_t *)(*(void *)(a1 + 72) + 16LL), v8);
    xpc_release(v8);
  }

void sub_10045BF2C(uint64_t a1, xpc_object_t xdict)
{
  xpc_object_t value = xpc_dictionary_get_value(xdict, "kCBMsgArgs");
  uint64_t uint64 = xpc_dictionary_get_uint64(value, "kCBMsgArgDiscoveryAgentID");
  uint64_t v6 = xpc_dictionary_get_uint64(value, "kCbMsgArgDeviceArrayMaxSize");
  uint64_t v15 = 0LL;
  __chkstk_darwin(v6, 8 * v6);
  uint64_t v8 = (uint64_t *)((char *)&v15 - v7);
  bzero((char *)&v15 - v7, v9);
  if (os_log_type_enabled((os_log_t)qword_1008F75F0, OS_LOG_TYPE_DEBUG)) {
    sub_100680AD4();
  }
  int v10 = 1;
  xpc_object_t reply = xpc_dictionary_create_reply(xdict);
  if (reply)
  {
    int v12 = reply;
    xpc_dictionary_set_uint64(reply, "kCBMsgArgResult", v10);
    xpc_dictionary_set_uint64(v12, "kCbMsgArgDeviceArrayMaxSize", v15);
    xpc_object_t v13 = xpc_array_create(0LL, 0LL);
    if (!v10 && v15)
    {
      for (uint64_t i = 0LL; i < v15; ++i)
        xpc_array_set_uint64(v13, 0xFFFFFFFFFFFFFFFFLL, v8[i]);
    }

    xpc_dictionary_set_value(v12, "kCBMsgArgDeviceArray", v13);
    xpc_connection_send_message(*(xpc_connection_t *)(*(void *)(a1 + 72) + 16LL), v12);
    xpc_release(v13);
    xpc_release(v12);
  }

void sub_10045C108(uint64_t a1, xpc_object_t xdict)
{
  xpc_object_t value = xpc_dictionary_get_value(xdict, "kCBMsgArgs");
  uint64_t uint64 = xpc_dictionary_get_uint64(value, "kCBMsgArgDiscoveryAgentID");
  size_t length = 0LL;
  int data = xpc_dictionary_get_data(value, "kCBMsgArgKey", &length);
  if (os_log_type_enabled((os_log_t)qword_1008F75F0, OS_LOG_TYPE_DEBUG))
  {
    sub_100680B34();
  }

  else if (uint64)
  {
LABEL_3:
    uint64_t v7 = (int)sub_100439E44(uint64, data, length);
    goto LABEL_6;
  }

  uint64_t v7 = 1LL;
LABEL_6:
  xpc_object_t reply = xpc_dictionary_create_reply(xdict);
  if (reply)
  {
    size_t v9 = reply;
    xpc_dictionary_set_uint64(reply, "kCBMsgArgResult", v7);
    xpc_connection_send_message(*(xpc_connection_t *)(*(void *)(a1 + 72) + 16LL), v9);
    xpc_release(v9);
  }

void sub_10045C204(uint64_t a1, xpc_object_t xdict)
{
  xpc_object_t value = xpc_dictionary_get_value(xdict, "kCBMsgArgs");
  uint64_t uint64 = xpc_dictionary_get_uint64(value, "kCBMsgArgDiscoveryAgentID");
  size_t length = 0LL;
  int data = xpc_dictionary_get_data(value, "kCBMsgArgKey", &length);
  if (os_log_type_enabled((os_log_t)qword_1008F75F0, OS_LOG_TYPE_DEBUG))
  {
    sub_100680B94();
  }

  else if (uint64)
  {
LABEL_3:
    uint64_t v7 = (int)sub_100439F28(uint64, data, length);
    goto LABEL_6;
  }

  uint64_t v7 = 1LL;
LABEL_6:
  xpc_object_t reply = xpc_dictionary_create_reply(xdict);
  if (reply)
  {
    size_t v9 = reply;
    xpc_dictionary_set_uint64(reply, "kCBMsgArgResult", v7);
    xpc_connection_send_message(*(xpc_connection_t *)(*(void *)(a1 + 72) + 16LL), v9);
    xpc_release(v9);
  }

BOOL sub_10045C304(uint64_t a1, xpc_object_t xdict)
{
  string = xpc_dictionary_get_string(xdict, "kCBMsgId");
  uint64_t v11 = string;
  size_t v12 = strlen(string);
  uint64_t v5 = sub_100331854(&xmmword_1008F74F8, (uint64_t)&v11);
  if (v5)
  {
    uint64_t v11 = string;
    size_t v12 = strlen(string);
    xpc_object_t v13 = &v11;
    uint64_t v6 = sub_10045C494((uint64_t)&xmmword_1008F74F8, (uint64_t)&v11, (uint64_t)&unk_1006C2518, (_OWORD **)&v13);
    uint64_t v7 = (void (*)(void *, xpc_object_t))v6[4];
    uint64_t v8 = v6[5];
    size_t v9 = (void *)(a1 + (v8 >> 1));
    if ((v8 & 1) != 0) {
      uint64_t v7 = *(void (**)(void *, xpc_object_t))(*v9 + v7);
    }
    v7(v9, xdict);
  }

  return v5 != 0LL;
}

void sub_10045C3D4(void *a1)
{
  uint64_t v1 = sub_100352334(a1);
  operator delete(v1);
}

uint64_t sub_10045C3E8(void *a1)
{
  v8[0] = 0LL;
  v8[1] = 0LL;
  sub_100242F28((uint64_t)v8, (uint64_t)(a1 + 1));
  int v2 = (void *)a1[10];
  unint64_t v3 = a1 + 11;
  if (v2 != a1 + 11)
  {
    do
    {
      free((void *)v2[4]);
      xpc_object_t v4 = (void *)v2[1];
      if (v4)
      {
        do
        {
          uint64_t v5 = v4;
          xpc_object_t v4 = (void *)*v4;
        }

        while (v4);
      }

      else
      {
        do
        {
          uint64_t v5 = (void *)v2[2];
          BOOL v6 = *v5 == (void)v2;
          int v2 = v5;
        }

        while (!v6);
      }

      int v2 = v5;
    }

    while (v5 != v3);
  }

  sub_10023BF24((uint64_t)(a1 + 10), (void *)a1[11]);
  a1[11] = 0LL;
  a1[12] = 0LL;
  a1[10] = v3;
  return sub_100242FAC((uint64_t)v8);
}

void *sub_10045C494(uint64_t a1, uint64_t a2, uint64_t a3, _OWORD **a4)
{
  unint64_t v7 = sub_1003313A4((uint64_t)&v29, *(uint64_t **)a2, *(void *)(a2 + 8));
  unint64_t v8 = v7;
  unint64_t v9 = *(void *)(a1 + 8);
  if (v9)
  {
    uint8x8_t v10 = (uint8x8_t)vcnt_s8((int8x8_t)v9);
    v10.i16[0] = vaddlv_u8(v10);
    unint64_t v11 = v10.u32[0];
    if (v10.u32[0] > 1uLL)
    {
      unint64_t v12 = v7;
      if (v7 >= v9) {
        unint64_t v12 = v7 % v9;
      }
    }

    else
    {
      unint64_t v12 = (v9 - 1) & v7;
    }

    xpc_object_t v13 = *(void ***)(*(void *)a1 + 8 * v12);
    if (v13)
    {
      __int16 v14 = *v13;
      if (*v13)
      {
        uint64_t v17 = a2;
        uint64_t v15 = *(uint64_t **)a2;
        size_t v16 = *(void *)(v17 + 8);
        do
        {
          unint64_t v18 = *((void *)v14 + 1);
          if (v18 == v8)
          {
          }

          else
          {
            if (v11 > 1)
            {
              if (v18 >= v9) {
                v18 %= v9;
              }
            }

            else
            {
              v18 &= v9 - 1;
            }

            if (v18 != v12) {
              break;
            }
          }

          __int16 v14 = *(void **)v14;
        }

        while (v14);
      }
    }
  }

  else
  {
    unint64_t v12 = 0LL;
  }

  __int16 v14 = operator new(0x30uLL);
  *(void *)__int16 v14 = 0LL;
  *((void *)v14 + 1) = v8;
  *((_OWORD *)v14 + 1) = **a4;
  *((void *)v14 + 4) = 0LL;
  *((void *)v14 + 5) = 0LL;
  float v19 = (float)(unint64_t)(*(void *)(a1 + 24) + 1LL);
  float v20 = *(float *)(a1 + 32);
  if (!v9 || (float)(v20 * (float)v9) < v19)
  {
    BOOL v21 = 1LL;
    if (v9 >= 3) {
      BOOL v21 = (v9 & (v9 - 1)) != 0;
    }
    unint64_t v22 = v21 | (2 * v9);
    unint64_t v23 = vcvtps_u32_f32(v19 / v20);
    if (v22 <= v23) {
      size_t v24 = v23;
    }
    else {
      size_t v24 = v22;
    }
    sub_10005141C(a1, v24);
    unint64_t v9 = *(void *)(a1 + 8);
    if ((v9 & (v9 - 1)) != 0)
    {
      if (v8 >= v9) {
        unint64_t v12 = v8 % v9;
      }
      else {
        unint64_t v12 = v8;
      }
    }

    else
    {
      unint64_t v12 = (v9 - 1) & v8;
    }
  }

  uint64_t v25 = *(void *)a1;
  uint64_t v26 = *(void **)(*(void *)a1 + 8 * v12);
  if (v26)
  {
    *(void *)__int16 v14 = *v26;
LABEL_40:
    void *v26 = v14;
    goto LABEL_41;
  }

  *(void *)__int16 v14 = *(void *)(a1 + 16);
  *(void *)(a1 + 16) = v14;
  *(void *)(v25 + 8 * v12) = a1 + 16;
  if (*(void *)v14)
  {
    unint64_t v27 = *(void *)(*(void *)v14 + 8LL);
    if ((v9 & (v9 - 1)) != 0)
    {
      if (v27 >= v9) {
        v27 %= v9;
      }
    }

    else
    {
      v27 &= v9 - 1;
    }

    uint64_t v26 = (void *)(*(void *)a1 + 8 * v27);
    goto LABEL_40;
  }

void sub_10045C6E8(_Unwind_Exception *a1)
{
}

void sub_10045C6FC(id a1)
{
  uint64_t v1 = operator new(0x120uLL);
  sub_100495250();
  qword_1008D61A0 = (uint64_t)v1;
}

void sub_10045C72C(_Unwind_Exception *a1)
{
}

void sub_10045C740()
{
  int v0 = objc_autoreleasePoolPush();
  xmmword_1008F74F8 = 0u;
  unk_1008F7508 = 0u;
  dword_1008F7518 = 1065353216;
  __cxa_atexit((void (*)(void *))sub_10045B254, &xmmword_1008F74F8, (void *)&_mh_execute_header);
  objc_autoreleasePoolPop(v0);
}

void sub_10045C790()
{
  int v0 = (os_log_s *)qword_1008F7598;
  if (os_log_type_enabled((os_log_t)qword_1008F7598, OS_LOG_TYPE_INFO))
  {
    *(_WORD *)uint64_t v1 = 0;
    _os_log_impl((void *)&_mh_execute_header, v0, OS_LOG_TYPE_INFO, "ScoDataBufferOverflowCB", v1, 2u);
  }

void sub_10045C7F4(os_unfair_lock_s *a1, unsigned int a2, int a3, uint64_t a4, uint64_t a5)
{
  int v56 = 0;
  if (*(_BYTE *)(a5 + 8))
  {
    uint8x8_t v10 = (os_log_s *)qword_1008F7598;
    if (os_log_type_enabled((os_log_t)qword_1008F7598, OS_LOG_TYPE_DEFAULT))
    {
      *(_DWORD *)__int128 buf = 67109632;
      *(_DWORD *)&uint8_t buf[4] = a2;
      LOWORD(v5_Block_object_dispose((const void *)(v2 - 88), 8) = 1024;
      *(_DWORD *)((char *)&v58 + 2) = a3;
      HIWORD(v5_Block_object_dispose((const void *)(v2 - 88), 8) = 2048;
      *(void *)&__int128 v59 = sub_10056AAD8(a4);
      _os_log_impl( (void *)&_mh_execute_header,  v10,  OS_LOG_TYPE_DEFAULT,  "HandsfreeGateway::ScoReceiveDataCB: wakeupCause SCO Packet from BT Controller (hfpHandle=0x%hX erroneous=%hhu len=%zu)\n",  buf,  0x18u);
    }
  }

  unint64_t v11 = sub_10045CF60((uint64_t)a1, a2);
  if (v11)
  {
    v55[0] = 0LL;
    v55[1] = 0LL;
    sub_100242F28((uint64_t)v55, (uint64_t)&a1[190]);
    if (sub_1002075B4((uint64_t)(v11 + 50)) == 256
      || sub_1002075B4((uint64_t)(v11 + 50)) == 127)
    {
      if ((unint64_t)sub_10056AAD8(a4) > 1)
      {
        unsigned __int8 v13 = sub_10056AAD8(a4);
        sub_100501F04((uint64_t)v11, v13);
        __int16 v14 = (unsigned __int8 *)sub_10056AAF0(a4);
        uint64_t v15 = v14[1];
        unsigned __int8 v16 = sub_1002075D4((uint64_t)(v11 + 50));
        if (a3 || sub_10056AAD8(a4) != v16 || sub_10056AAD8(a4) < (unint64_t)(v15 + 2))
        {
          int v17 = v14[1];
          int v18 = *v14;
          char v19 = sub_10056AAD8(a4);
          v14[1] = 0;
          sub_100501F88((uint64_t)v11);
          LOBYTE(v15) = v19 - 2;
          if (!a3)
          {
            float v20 = (os_log_s *)qword_1008F7598;
            if (os_log_type_enabled((os_log_t)qword_1008F7598, OS_LOG_TYPE_ERROR))
            {
              uint64_t v51 = sub_10056AAD8(a4);
              *(_DWORD *)__int128 buf = 67110400;
              *(_DWORD *)&uint8_t buf[4] = 0;
              LOWORD(v5_Block_object_dispose((const void *)(v2 - 88), 8) = 1024;
              *(_DWORD *)((char *)&v58 + 2) = v15;
              HIWORD(v5_Block_object_dispose((const void *)(v2 - 88), 8) = 1024;
              LODWORD(v59) = v16;
              WORD2(v59) = 2048;
              *(void *)((char *)&v59 + 6) = v51;
              HIWORD(v59) = 1024;
              LODWORD(v6sub_100414D2C(qword_1008F72C0, 0) = v18;
              WORD2(v6sub_100414D2C(qword_1008F72C0, 0) = 1024;
              *(_DWORD *)((char *)&v60 + 6) = v17;
              _os_log_error_impl( (void *)&_mh_execute_header,  v20,  OS_LOG_TYPE_ERROR,  "Clearing UL voice data err:%d, length to codec:%d, maxPacketSize:%d, data.getSize():%zu, seq %d, length in payload %d",  buf,  0x2Au);
            }
          }
        }

        BOOL v21 = (char *)sub_10056AAF0(a4);
        sub_10026FF08((uint64_t)v11, v21, v15 + 2LL, *(unsigned __int8 *)(a5 + 8));
        goto LABEL_20;
      }

      if (os_log_type_enabled((os_log_t)qword_1008F7598, OS_LOG_TYPE_ERROR))
      {
LABEL_10:
        uint64_t v12 = sub_10056AAD8(a4);
        sub_100680C58((uint64_t)buf, v12);
      }

void sub_10045CF0C(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, ...)
{
}

uint64_t *sub_10045CF60(uint64_t a1, unsigned int a2)
{
  unsigned __int16 v12 = a2;
  v11[0] = 0LL;
  v11[1] = 0LL;
  sub_100242F28((uint64_t)v11, a1 + 760);
  uint64_t v4 = *(void *)(a1 + 832);
  if (!v4) {
    goto LABEL_19;
  }
  uint64_t v5 = a1 + 832;
  do
  {
    unsigned int v6 = *(unsigned __int16 *)(v4 + 32);
    BOOL v7 = v6 >= a2;
    if (v6 >= a2) {
      unint64_t v8 = (uint64_t *)v4;
    }
    else {
      unint64_t v8 = (uint64_t *)(v4 + 8);
    }
    if (v7) {
      uint64_t v5 = v4;
    }
    uint64_t v4 = *v8;
  }

  while (*v8);
  if (v5 != a1 + 832 && *(unsigned __int16 *)(v5 + 32) <= a2)
  {
    unsigned __int8 v13 = &v12;
    unint64_t v9 = sub_1002550B8((uint64_t **)(a1 + 824), &v12, (uint64_t)&unk_1006C2518, &v13)[5];
  }

  else
  {
LABEL_19:
    if (os_log_type_enabled((os_log_t)qword_1008F7598, OS_LOG_TYPE_ERROR)) {
      sub_100680E54();
    }
    unint64_t v9 = 0LL;
  }

  sub_100242FAC((uint64_t)v11);
  return v9;
}

void sub_10045D044( _Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9)
{
}

BOOL sub_10045D058( uint64_t a1, unsigned __int8 *a2, unint64_t a3, _WORD *a4, _WORD *a5, _WORD *a6, _WORD *a7)
{
  int v8 = *a2;
  int v9 = v8 & 0xF;
  if ((v8 & 0xF0) == 0x80) {
    int v10 = v8 & 0xF;
  }
  else {
    int v10 = 0;
  }
  if ((v10 - 4) < 0xFFFFFFFD)
  {
    unint64_t v11 = (os_log_s *)qword_1008F7598;
    BOOL result = os_log_type_enabled((os_log_t)qword_1008F7598, OS_LOG_TYPE_ERROR);
    if (result)
    {
      int v13 = a2[1];
      int v14 = a2[2];
      int v15 = a2[3];
      int v16 = a2[4];
      int v17 = a2[5];
      int v18 = a2[6];
      int v19 = a2[7];
      v35[0] = 67111168;
      v35[1] = v10;
      __int16 v36 = 1024;
      int v37 = v8;
      __int16 v38 = 1024;
      int v39 = v13;
      __int16 v40 = 1024;
      int v41 = v14;
      __int16 v42 = 1024;
      int v43 = v15;
      __int16 v44 = 1024;
      int v45 = v16;
      __int16 v46 = 1024;
      int v47 = v17;
      __int16 v48 = 1024;
      int v49 = v18;
      __int16 v50 = 1024;
      int v51 = v19;
      _os_log_error_impl( (void *)&_mh_execute_header,  v11,  OS_LOG_TYPE_ERROR,  "uplink frame total chunk invalid :%u, %02x,%02x,%02x,%02x,%02x,%02x,%02x,%02x",  (uint8_t *)v35,  0x38u);
      return 0LL;
    }

    return result;
  }

  if ((v8 & 0xF) == 0 || a3 == 0) {
    return 1LL;
  }
  __int16 v21 = 0;
  uint64_t v22 = 1LL;
  int v23 = 1;
  BOOL result = 1LL;
  while (1)
  {
    unsigned int v24 = a2[v22];
    if (v24 >> 4 == 10) {
      break;
    }
    if (v24 >> 4 != 9)
    {
      BOOL result = os_log_type_enabled((os_log_t)qword_1008F7598, OS_LOG_TYPE_ERROR);
      if (!result) {
        return result;
      }
      sub_100680EB8();
      return 0LL;
    }

    int v25 = v24 & 0xF0;
    unsigned int v26 = v24 & 0xF;
    if (v25 != 144) {
      unsigned int v26 = 0;
    }
    unsigned int v27 = v26;
    if (v26 >= 3)
    {
      BOOL result = os_log_type_enabled((os_log_t)qword_1008F7598, OS_LOG_TYPE_ERROR);
      if (!result) {
        return result;
      }
      sub_100680F1C();
      return 0LL;
    }

    ++v23;
    if (*a4)
    {
      if (v26) {
        goto LABEL_22;
      }
    }

    else
    {
      *a4 = v23;
      if (v26)
      {
        do
        {
LABEL_22:
          int v28 = a2[(unsigned __int16)(v23 + 1)];
          v21 += v28;
          v23 += v28 + 2;
          --v27;
        }

        while (v27);
      }
    }

    *a5 = v21 + 2 * v26;
LABEL_31:
    if ((_BYTE)--v9)
    {
      uint64_t v22 = (unsigned __int16)v23;
    }

    return result;
  }

  int v29 = v24 & 0xF0;
  int v30 = v24 & 0xF;
  if (v29 == 160) {
    unsigned int v31 = v30;
  }
  else {
    unsigned int v31 = 0;
  }
  if (v31 < 2)
  {
    int v32 = *(unsigned __int16 *)&a2[(unsigned __int16)(v23 + 1)];
    int v33 = v23 + 3;
    if (!*a6) {
      *a6 = v33;
    }
    int v34 = (unsigned __int16)*a7 + v32;
    *a7 = v34;
    int v23 = v34 + v33;
    goto LABEL_31;
  }

  BOOL result = os_log_type_enabled((os_log_t)qword_1008F7598, OS_LOG_TYPE_ERROR);
  if (!result) {
    return result;
  }
  sub_100680F7C();
  return 0LL;
}

void sub_10045D308()
{
  int v0 = (os_log_s *)qword_1008F7598;
  if (os_log_type_enabled((os_log_t)qword_1008F7598, OS_LOG_TYPE_INFO))
  {
    *(_WORD *)uint64_t v1 = 0;
    _os_log_impl((void *)&_mh_execute_header, v0, OS_LOG_TYPE_INFO, "ScoTransportReadyCB", v1, 2u);
  }

void sub_10045D36C(uint64_t a1, uint64_t a2, int a3)
{
  uint64_t v4 = (os_log_s *)qword_1008F7598;
  if (os_log_type_enabled((os_log_t)qword_1008F7598, OS_LOG_TYPE_INFO))
  {
    v5[0] = 67109120;
    v5[1] = a3;
    _os_log_impl( (void *)&_mh_execute_header,  v4,  OS_LOG_TYPE_INFO,  "ScoTxPacketCompletedCB: numCompletedPackets %d",  (uint8_t *)v5,  8u);
  }

uint64_t sub_10045D40C( uint64_t a1, int a2, unsigned int a3, uint64_t a4, int a5, int a6, int a7, int a8, unsigned __int8 a9)
{
  v22[0] = 0LL;
  v22[1] = 0LL;
  sub_100242F28((uint64_t)v22, a1 + 760);
  int v17 = (os_log_s *)qword_1008F7598;
  if (os_log_type_enabled((os_log_t)qword_1008F7598, OS_LOG_TYPE_INFO))
  {
    *(_WORD *)__int128 buf = 0;
    _os_log_impl((void *)&_mh_execute_header, v17, OS_LOG_TYPE_INFO, "eSCO parameters:", buf, 2u);
    int v17 = (os_log_s *)qword_1008F7598;
  }

  if (os_log_type_enabled(v17, OS_LOG_TYPE_INFO))
  {
    *(_DWORD *)__int128 buf = 67109120;
    int v24 = a2;
    _os_log_impl( (void *)&_mh_execute_header,  v17,  OS_LOG_TYPE_INFO,  "\t\tstatus:\t\t\t%{bluetooth:OI_STATUS}u",  buf,  8u);
    int v17 = (os_log_s *)qword_1008F7598;
  }

  if (os_log_type_enabled(v17, OS_LOG_TYPE_INFO))
  {
    *(_DWORD *)__int128 buf = 67109120;
    int v24 = a5;
    _os_log_impl((void *)&_mh_execute_header, v17, OS_LOG_TYPE_INFO, "\t\ttxInterval:\t\t%d", buf, 8u);
    int v17 = (os_log_s *)qword_1008F7598;
  }

  if (os_log_type_enabled(v17, OS_LOG_TYPE_INFO))
  {
    *(_DWORD *)__int128 buf = 67109120;
    int v24 = a6;
    _os_log_impl((void *)&_mh_execute_header, v17, OS_LOG_TYPE_INFO, "\t\treTxWindow:\t\t%d", buf, 8u);
    int v17 = (os_log_s *)qword_1008F7598;
  }

  if (os_log_type_enabled(v17, OS_LOG_TYPE_INFO))
  {
    *(_DWORD *)__int128 buf = 67109120;
    int v24 = a7;
    _os_log_impl((void *)&_mh_execute_header, v17, OS_LOG_TYPE_INFO, "\t\trxPacketLength: %d", buf, 8u);
    int v17 = (os_log_s *)qword_1008F7598;
  }

  if (os_log_type_enabled(v17, OS_LOG_TYPE_INFO))
  {
    *(_DWORD *)__int128 buf = 67109120;
    int v24 = a8;
    _os_log_impl((void *)&_mh_execute_header, v17, OS_LOG_TYPE_INFO, "\t\ttxPacketLength: %d", buf, 8u);
    int v17 = (os_log_s *)qword_1008F7598;
  }

  if (os_log_type_enabled(v17, OS_LOG_TYPE_INFO))
  {
    *(_DWORD *)__int128 buf = 67109120;
    int v24 = a9;
    _os_log_impl((void *)&_mh_execute_header, v17, OS_LOG_TYPE_INFO, "\t\tairMode:\t\t%2x", buf, 8u);
  }

  int v18 = sub_10045CF60(a1, a3);
  uint64_t v19 = (uint64_t)v18;
  if (v18)
  {
    sub_1002075CC((uint64_t)(v18 + 50), a8);
    sub_1002075DC(v19 + 400, a7);
    sub_1002075EC(v19 + 400, a5);
    sub_10020760C(v19 + 400, 0);
    if (qword_1008D5F10 != -1) {
      dispatch_once(&qword_1008D5F10, &stru_100899FB0);
    }
    sub_1005B0694((uint64_t)off_1008D5F08);
    sub_1002073B4(v19 + 400, a4);
    if (sub_100501754(v19))
    {
      sub_1005023FC(v19);
      float v20 = (os_log_s *)qword_1008F7598;
      if (os_log_type_enabled((os_log_t)qword_1008F7598, OS_LOG_TYPE_DEFAULT))
      {
        *(_WORD *)__int128 buf = 0;
        _os_log_impl( (void *)&_mh_execute_header,  v20,  OS_LOG_TYPE_DEFAULT,  "IO already started from audio layer, now that we have a connection handle, triggering sendthread to start",  buf,  2u);
      }

      sub_100502564(v19);
    }
  }

  else if (os_log_type_enabled((os_log_t)qword_1008F7598, OS_LOG_TYPE_ERROR))
  {
    sub_100680FE0();
  }

  return sub_100242FAC((uint64_t)v22);
}

void sub_10045D7B0(_Unwind_Exception *exception_object)
{
}

uint64_t sub_10045D7CC(uint64_t a1, uint64_t a2)
{
  v11[0] = 0LL;
  v11[1] = 0LL;
  sub_100242F28((uint64_t)v11, a1 + 760);
  uint64_t v4 = *(void **)(a1 + 824);
  uint64_t v5 = (void *)(a1 + 832);
  if (v4 == v5)
  {
LABEL_9:
    uint64_t v9 = 0LL;
  }

  else
  {
    while (sub_1002073AC(v4[5] + 400LL) != a2)
    {
      unsigned int v6 = (void *)v4[1];
      if (v6)
      {
        do
        {
          BOOL v7 = v6;
          unsigned int v6 = (void *)*v6;
        }

        while (v6);
      }

      else
      {
        do
        {
          BOOL v7 = (void *)v4[2];
          BOOL v8 = *v7 == (void)v4;
          uint64_t v4 = v7;
        }

        while (!v8);
      }

      uint64_t v4 = v7;
      if (v7 == v5) {
        goto LABEL_9;
      }
    }

    uint64_t v9 = v4[5];
  }

  sub_100242FAC((uint64_t)v11);
  return v9;
}

void sub_10045D880( _Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9)
{
}

uint64_t sub_10045D894(uint64_t a1, uint64_t a2)
{
  v7[0] = 0LL;
  v7[1] = 0LL;
  sub_100242F28((uint64_t)v7, a1 + 760);
  uint64_t v4 = sub_10045D7CC(a1, a2);
  if (v4) {
    uint64_t v5 = sub_10020755C(v4 + 400);
  }
  else {
    uint64_t v5 = 0LL;
  }
  sub_100242FAC((uint64_t)v7);
  return v5;
}

void sub_10045D8FC( _Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9)
{
}

BOOL sub_10045D910(uint64_t a1, uint64_t a2, __n128 *a3)
{
  v10[0] = 0LL;
  v10[1] = 0LL;
  sub_100242F28((uint64_t)v10, a1 + 760);
  uint64_t v6 = sub_10045D7CC(a1, a2);
  uint64_t v7 = v6;
  if (v6)
  {
    sub_100501ED8(v6, a3);
  }

  else if (os_log_type_enabled((os_log_t)qword_1008F7598, OS_LOG_TYPE_ERROR))
  {
    sub_1003D0100(a2, (uint64_t)v9);
    sub_100681044();
  }

  sub_100242FAC((uint64_t)v10);
  return v7 != 0;
}

void sub_10045D9F0(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, ...)
{
}

uint64_t sub_10045DA10(uint64_t a1, uint64_t a2)
{
  v6[0] = 0LL;
  v6[1] = 0LL;
  sub_100242F28((uint64_t)v6, a1 + 760);
  if (a2 && sub_10045D7CC(a1, a2))
  {
    uint64_t v4 = sub_10045D7CC(a1, a2);
    sub_100501EF0(v4);
  }

  else if (os_log_type_enabled((os_log_t)qword_1008F7598, OS_LOG_TYPE_ERROR))
  {
    sub_10068108C();
  }

  return sub_100242FAC((uint64_t)v6);
}

void sub_10045DAA0( _Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9)
{
}

uint64_t sub_10045DAB4(uint64_t a1, unsigned __int8 *a2, int a3)
{
  unsigned __int16 v55 = a3;
  v54[0] = 0LL;
  v54[1] = 0LL;
  sub_100242F28((uint64_t)v54, a1 + 760);
  uint64_t v70 = 0LL;
  __int128 v69 = 0u;
  memset(v68, 0, sizeof(v68));
  __int128 v66 = 0u;
  __int128 v67 = 0u;
  __int128 v64 = 0u;
  __int128 v65 = 0u;
  __int128 v62 = 0u;
  *(_OWORD *)int v63 = 0u;
  sub_100532DC0((uint64_t)&v62 + 1);
  BYTE2(v63[0]) = 0;
  BYTE4(v63[0]) = 0;
  BYTE2(v65) = 0;
  BYTE4(v65) = 0;
  HIDWORD(v68[2]) = 0;
  __int128 v64 = 0uLL;
  v63[1] = 0LL;
  LOBYTE(v65) = 0;
  __int128 v66 = 0uLL;
  *((void *)&v65 + 1) = 0LL;
  LOBYTE(v67) = 0;
  v68[0] = 0LL;
  v68[1] = 0LL;
  *((void *)&v67 + 1) = 0LL;
  *(_DWORD *)((char *)&v68[1] + 7) = 0;
  LOBYTE(v68[3]) = 1;
  BYTE2(v7sub_100414D2C(qword_1008F72C0, 0) = 0;
  *(void *)((char *)&v68[3] + 6) = 0LL;
  *(void *)((char *)&v68[3] + 1) = 0LL;
  __int128 v69 = 0uLL;
  v68[5] = 0LL;
  LOBYTE(v7sub_100414D2C(qword_1008F72C0, 0) = 0;
  uint64_t v6 = (os_log_s *)qword_1008F7598;
  if (os_log_type_enabled((os_log_t)qword_1008F7598, OS_LOG_TYPE_DEFAULT))
  {
    sub_1003CF00C((uint64_t)a2, __p);
    uint64_t v7 = v59 >= 0 ? __p : *(_BYTE **)__p;
    *(_DWORD *)__int128 buf = 67109378;
    LODWORD(v61[0]) = a3;
    WORD2(v61[0]) = 2082;
    *(void *)((char *)v61 + 6) = v7;
    _os_log_impl( (void *)&_mh_execute_header,  v6,  OS_LOG_TYPE_DEFAULT,  "Now tracking handle %d for device %{public}s",  buf,  0x12u);
    if (v59 < 0) {
      operator delete(*(void **)__p);
    }
  }

  uint64_t v8 = *(void *)(a1 + 832);
  if (!v8) {
    goto LABEL_18;
  }
  uint64_t v9 = a1 + 832;
  do
  {
    unsigned int v10 = *(unsigned __int16 *)(v8 + 32);
    BOOL v11 = v10 >= v55;
    if (v10 >= v55) {
      unsigned __int16 v12 = (uint64_t *)v8;
    }
    else {
      unsigned __int16 v12 = (uint64_t *)(v8 + 8);
    }
    if (v11) {
      uint64_t v9 = v8;
    }
    uint64_t v8 = *v12;
  }

  while (*v12);
  if (v9 != a1 + 832 && v55 >= *(unsigned __int16 *)(v9 + 32))
  {
    if (os_log_type_enabled((os_log_t)qword_1008F7598, OS_LOG_TYPE_ERROR)) {
      sub_100681118();
    }
  }

  else
  {
LABEL_18:
    int v13 = (os_log_s *)qword_1008F7598;
    if (os_log_type_enabled((os_log_t)qword_1008F7598, OS_LOG_TYPE_DEFAULT))
    {
      sub_1003CF00C((uint64_t)a2, __p);
      int v14 = v59 >= 0 ? __p : *(_BYTE **)__p;
      *(_DWORD *)__int128 buf = 136446210;
      v61[0] = v14;
      _os_log_impl( (void *)&_mh_execute_header,  v13,  OS_LOG_TYPE_DEFAULT,  "Creating HFPAudioDevice for device %{public}s",  buf,  0xCu);
      if (v59 < 0) {
        operator delete(*(void **)__p);
      }
    }

    int v15 = (uint64_t *)operator new(0x270uLL);
    sub_1005016D0(v15, v55, a2, a2 + 128, a1 + 280);
    *(void *)std::string __p = &v55;
    sub_1002550B8((uint64_t **)(a1 + 824), &v55, (uint64_t)&unk_1006C2518, (_WORD **)__p)[5] = v15;
    uint64_t v16 = (uint64_t)(v15 + 50);
    sub_10020747C((uint64_t)(v15 + 50), 1);
    if (sub_1003D2408((uint64_t)a2, (uint64_t)&v62))
    {
      if (BYTE5(v68[4]))
      {
        uint64_t v17 = sub_1002E6E9C();
        (*(void (**)(uint64_t, uint64_t, uint64_t))(*(void *)v17 + 216LL))(v17, 1LL, 1LL);
      }

      if (BYTE3(v69))
      {
        int v18 = (os_log_s *)qword_1008F7598;
        if (os_log_type_enabled((os_log_t)qword_1008F7598, OS_LOG_TYPE_DEFAULT))
        {
          sub_1003CF00C((uint64_t)a2, __p);
          uint64_t v19 = v59 >= 0 ? __p : *(_BYTE **)__p;
          *(_DWORD *)__int128 buf = 136315138;
          v61[0] = v19;
          _os_log_impl( (void *)&_mh_execute_header,  v18,  OS_LOG_TYPE_DEFAULT,  "device (%s) is set to disable sco!",  buf,  0xCu);
          if (v59 < 0) {
            operator delete(*(void **)__p);
          }
        }

        sub_1002074A4((uint64_t)(v15 + 50), 1);
      }
    }

    char v53 = 0;
    sub_100242CA4(&v53);
    int v20 = sub_1000EF480(v55);
    uint64_t v52 = 0LL;
    if (!sub_10010EEE0((uint64_t)(a2 + 128), &v52))
    {
      if ((*(_BYTE *)(v52 + 292) & 0x40) != 0)
      {
        uint64_t v23 = sub_1002E6E9C();
        int v21 = (*(uint64_t (**)(uint64_t))(*(void *)v23 + 2536LL))(v23);
      }

      else
      {
        int v21 = 0;
      }

      int v24 = (os_log_s *)qword_1008F7598;
      if (os_log_type_enabled((os_log_t)qword_1008F7598, OS_LOG_TYPE_DEFAULT))
      {
        int v25 = "does not support";
        if (v21) {
          int v25 = "supports";
        }
        *(_DWORD *)std::string __p = 136315138;
        *(void *)&__p[4] = v25;
        _os_log_impl( (void *)&_mh_execute_header,  v24,  OS_LOG_TYPE_DEFAULT,  "Local and remote device %s HDR eSCO",  __p,  0xCu);
      }

      sub_100207594((uint64_t)(v15 + 50), v21);
    }

    if (sub_1003D2AF4((uint64_t)a2))
    {
      unsigned int v26 = (os_log_s *)qword_1008F7598;
      if (os_log_type_enabled((os_log_t)qword_1008F7598, OS_LOG_TYPE_DEFAULT))
      {
        sub_1003CF00C((uint64_t)a2, __p);
        unsigned int v27 = v59 >= 0 ? __p : *(_BYTE **)__p;
        *(_DWORD *)__int128 buf = 136446210;
        v61[0] = v27;
        _os_log_impl( (void *)&_mh_execute_header,  v26,  OS_LOG_TYPE_DEFAULT,  "Enabling SCO Buffer Flush as %{public}s is connecting HFP",  buf,  0xCu);
        if (v59 < 0) {
          operator delete(*(void **)__p);
        }
      }

      if (sub_10010F990((uint64_t)(a2 + 128), 1)
        && os_log_type_enabled((os_log_t)qword_1008F7598, OS_LOG_TYPE_ERROR))
      {
        sub_1006810B8();
      }
    }

    char v28 = sub_1000EF4FC(v55);
    sub_100242CD0(&v53);
    int v29 = (os_log_s *)qword_1008F7598;
    if (os_log_type_enabled((os_log_t)qword_1008F7598, OS_LOG_TYPE_DEFAULT))
    {
      int v30 = sub_100206FD8(a1 + 360);
      int v31 = sub_100206FE8(a1 + 360);
      *(_DWORD *)std::string __p = 67109632;
      *(_DWORD *)&__p[4] = v20;
      *(_WORD *)&__p[8] = 1024;
      *(_DWORD *)&__p[10] = v30;
      __int16 v57 = 1024;
      int v58 = v31;
      _os_log_impl( (void *)&_mh_execute_header,  v29,  OS_LOG_TYPE_DEFAULT,  "Common BRSF feature bits %x, localCodec %x, localAoS %d",  __p,  0x14u);
    }

    if ((v20 & 0x10) != 0) {
      sub_10020742C(v16, 1);
    }
    if ((v20 & 2) != 0) {
      sub_10020743C(v16, 1);
    }
    if ((v20 & 0x20) != 0) {
      sub_100207444(v16, 1);
    }
    if ((v20 & 8) != 0)
    {
      sub_100207514(v16, 1);
      BOOL v32 = sub_1003D2408((uint64_t)a2, (uint64_t)&v62);
      if ((_BYTE)v70 && v32)
      {
        int v34 = (os_log_s *)qword_1008F7598;
        if (os_log_type_enabled((os_log_t)qword_1008F7598, OS_LOG_TYPE_DEFAULT))
        {
          sub_1003CF00C((uint64_t)a2, __p);
          uint64_t v35 = v59 >= 0 ? __p : *(_BYTE **)__p;
          *(_DWORD *)__int128 buf = 136446210;
          v61[0] = v35;
          _os_log_impl( (void *)&_mh_execute_header,  v34,  OS_LOG_TYPE_DEFAULT,  "Setting BVRA support to false for workaround: rdar://70447361 for device %{public}s",  buf,  0xCu);
          if (v59 < 0) {
            operator delete(*(void **)__p);
          }
        }

        sub_100207514(v16, 0);
      }
    }

    if ((v28 & 8) != 0)
    {
      __int16 v36 = (os_log_s *)qword_1008F7598;
      if (os_log_type_enabled((os_log_t)qword_1008F7598, OS_LOG_TYPE_DEFAULT))
      {
        *(_WORD *)std::string __p = 0;
        _os_log_impl((void *)&_mh_execute_header, v36, OS_LOG_TYPE_DEFAULT, "Local and remote supports SWB", __p, 2u);
      }

      sub_1002074F4(v16, 1);
    }

    if ((v28 & 0x10) != 0)
    {
      int v37 = (os_log_s *)qword_1008F7598;
      if (os_log_type_enabled((os_log_t)qword_1008F7598, OS_LOG_TYPE_DEFAULT))
      {
        *(_WORD *)std::string __p = 0;
        _os_log_impl( (void *)&_mh_execute_header,  v37,  OS_LOG_TYPE_DEFAULT,  "Local and remote supports Stereo LC3",  __p,  2u);
      }

      sub_100207504(v16, 1);
    }

    if ((v28 & 1) != 0)
    {
      __int16 v38 = (os_log_s *)qword_1008F7598;
      if (os_log_type_enabled((os_log_t)qword_1008F7598, OS_LOG_TYPE_DEFAULT))
      {
        *(_WORD *)std::string __p = 0;
        _os_log_impl((void *)&_mh_execute_header, v38, OS_LOG_TYPE_DEFAULT, "Local and remote supports UWBS", __p, 2u);
      }

      sub_1002074B4(v16, 1);
    }

    if ((v28 & 4) != 0)
    {
      int v39 = (os_log_s *)qword_1008F7598;
      if (os_log_type_enabled((os_log_t)qword_1008F7598, OS_LOG_TYPE_DEFAULT))
      {
        *(_WORD *)std::string __p = 0;
        _os_log_impl( (void *)&_mh_execute_header,  v39,  OS_LOG_TYPE_DEFAULT,  "Local and remote supports UWBSStereo",  __p,  2u);
      }

      sub_1003DE5C0((uint64_t)a2, 1);
      sub_1002074C4(v16, 1);
    }

    if ((v28 & 0x20) != 0)
    {
      __int16 v40 = (os_log_s *)qword_1008F7598;
      if (os_log_type_enabled((os_log_t)qword_1008F7598, OS_LOG_TYPE_DEFAULT))
      {
        *(_WORD *)std::string __p = 0;
        _os_log_impl( (void *)&_mh_execute_header,  v40,  OS_LOG_TYPE_DEFAULT,  "Local and remote supports AAC-ELD stereo 48kHz",  __p,  2u);
      }

      sub_1002074D4(v16, 1);
    }

    if ((v28 & 0x40) != 0)
    {
      int v41 = (os_log_s *)qword_1008F7598;
      if (os_log_type_enabled((os_log_t)qword_1008F7598, OS_LOG_TYPE_DEFAULT))
      {
        *(_WORD *)std::string __p = 0;
        _os_log_impl( (void *)&_mh_execute_header,  v41,  OS_LOG_TYPE_DEFAULT,  "Local and remote supports AAC-ELD stereo 48kHz 10ms",  __p,  2u);
      }

      sub_1002074E4(v16, 1);
    }

    if ((v28 & 2) != 0)
    {
      __int16 v42 = (os_log_s *)qword_1008F7598;
      if (os_log_type_enabled((os_log_t)qword_1008F7598, OS_LOG_TYPE_DEFAULT))
      {
        *(_WORD *)std::string __p = 0;
        _os_log_impl((void *)&_mh_execute_header, v42, OS_LOG_TYPE_DEFAULT, "Local and remote supports WBS", __p, 2u);
      }

      sub_100207494(v16, 1);
    }

    if ((v20 & 8) != 0)
    {
      sub_100207514(v16, 1);
      BOOL v43 = sub_1003D2408((uint64_t)a2, (uint64_t)&v62);
      if ((_BYTE)v70 && v43)
      {
        int v45 = (os_log_s *)qword_1008F7598;
        if (os_log_type_enabled((os_log_t)qword_1008F7598, OS_LOG_TYPE_DEFAULT))
        {
          sub_1003CF00C((uint64_t)a2, __p);
          __int16 v46 = v59 >= 0 ? __p : *(_BYTE **)__p;
          *(_DWORD *)__int128 buf = 136446210;
          v61[0] = v46;
          _os_log_impl( (void *)&_mh_execute_header,  v45,  OS_LOG_TYPE_DEFAULT,  "Setting BVRA support to false for workaround: rdar://70447361 for device %{public}s",  buf,  0xCu);
          if (v59 < 0) {
            operator delete(*(void **)__p);
          }
        }

        sub_100207514(v16, 0);
      }
    }

    uint64_t v47 = sub_1002E6E9C();
    else {
      char v48 = 0;
    }
    sub_100207524(v16, v48);
    uint64_t v49 = sub_1002E6BF0();
    int v50 = (*(uint64_t (**)(uint64_t))(*(void *)v49 + 240LL))(v49);
    if (v50) {
      LOBYTE(v5sub_100414D2C(qword_1008F72C0, 0) = sub_1003D2B2C((uint64_t)a2, 49);
    }
    sub_100207534(v16, v48 & v50);
    if ((sub_10020749C(v16) & 1) == 0) {
      sub_10045E558((os_unfair_lock_s *)a1, a2, (uint64_t)v15);
    }
    sub_100242CD8(&v53);
  }

  if (SHIBYTE(v68[1]) < 0) {
    operator delete(*((void **)&v67 + 1));
  }
  if (SHIBYTE(v66) < 0) {
    operator delete(*((void **)&v65 + 1));
  }
  if (SHIBYTE(v64) < 0) {
    operator delete(v63[1]);
  }
  nullsub_63((char *)&v62 + 1, v22);
  return sub_100242FAC((uint64_t)v54);
}

void sub_10045E4D8( _Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, int a11, __int16 a12, char a13, char a14, char a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20, uint64_t a21, uint64_t a22, uint64_t a23, uint64_t a24, uint64_t a25, char a26)
{
}

uint64_t sub_10045E558(os_unfair_lock_s *a1, unsigned __int8 *a2, uint64_t a3)
{
  uint64_t v88 = 0LL;
  uint64_t v89 = 0LL;
  v87[0] = 0LL;
  v87[1] = 0LL;
  sub_100242F28((uint64_t)v87, (uint64_t)&a1[190]);
  if (sub_1002074EC(a3 + 400))
  {
    int v6 = 127;
    sub_100207564(a3 + 400, 127);
  }

  else if (sub_1002074AC(a3 + 400))
  {
    int v6 = 256;
    sub_100207564(a3 + 400, 256);
  }

  else if (sub_10020748C(a3 + 400))
  {
    int v6 = 2;
    sub_100207564(a3 + 400, 2);
  }

  else
  {
    int v6 = 1;
    sub_100207564(a3 + 400, 1);
  }

  uint64_t v7 = (os_log_s *)qword_1008F7598;
  if (os_log_type_enabled((os_log_t)qword_1008F7598, OS_LOG_TYPE_DEFAULT))
  {
    p_p = &__p;
    sub_1003CF00C((uint64_t)a2, &__p);
    if (v91 < 0) {
      p_p = *(CFUUIDBytes **)&__p.byte0;
    }
    unsigned int v10 = sub_10045F408(v9, v6);
    uint64_t v11 = sub_10045D7CC((uint64_t)a1, (uint64_t)a2);
    if (v11) {
      LODWORD(v11) = sub_10020751C(v11 + 400);
    }
    *(_DWORD *)__int128 buf = 136446722;
    *(void *)&uint8_t buf[4] = p_p;
    *(_WORD *)&_BYTE buf[12] = 2080;
    *(void *)&_BYTE buf[14] = v10;
    *(_WORD *)&_BYTE buf[22] = 1024;
    LODWORD(v93) = v11;
    _os_log_impl( (void *)&_mh_execute_header,  v7,  OS_LOG_TYPE_DEFAULT,  "Creating HFPAudioDevice for device %{public}s with codec: %s, HandsfreeAoS %d",  buf,  0x1Cu);
    if (v91 < 0) {
      operator delete(*(void **)&__p.byte0);
    }
  }

  sub_1003FE1B4(a2 + 128, &__p);
  if (v91 >= 0) {
    unsigned __int16 v12 = &__p;
  }
  else {
    unsigned __int16 v12 = *(CFUUIDBytes **)&__p.byte0;
  }
  sub_10002418C(buf, (char *)v12);
  sub_10026F7E4(a3, (const void **)buf);
  if ((buf[23] & 0x80000000) != 0) {
    operator delete(*(void **)buf);
  }
  if (v91 < 0) {
    operator delete(*(void **)&__p.byte0);
  }
  sub_1003D0100((uint64_t)a2, (uint64_t)&__p);
  if (v91 >= 0) {
    int v13 = &__p;
  }
  else {
    int v13 = *(CFUUIDBytes **)&__p.byte0;
  }
  sub_10002418C(buf, (char *)v13);
  sub_10026F96C(a3, (uint64_t)buf);
  if ((buf[23] & 0x80000000) != 0) {
    operator delete(*(void **)buf);
  }
  if (v91 < 0) {
    operator delete(*(void **)&__p.byte0);
  }
  sub_1003FE1B4(a2 + 128, &__p);
  if (v91 >= 0) {
    int v14 = &__p;
  }
  else {
    int v14 = *(CFUUIDBytes **)&__p.byte0;
  }
  sub_10002418C(buf, (char *)v14);
  sub_10026F76C(a3, (uint64_t)buf);
  if ((buf[23] & 0x80000000) != 0) {
    operator delete(*(void **)buf);
  }
  if (v91 < 0) {
    operator delete(*(void **)&__p.byte0);
  }
  sub_10026F964(a3, (uint64_t)a2);
  int v15 = sub_10045F4D0((uint64_t)a1, (uint64_t)a2);
  sub_1002701AC(a3, v15);
  int v17 = sub_10045F7E8(v16, (uint64_t)a2);
  sub_1005020A4(a3, v17);
  int v19 = sub_10045F88C(v18, (uint64_t)a2);
  sub_1005020B4(a3, v19);
  uint64_t v20 = sub_10045D7CC((uint64_t)a1, (uint64_t)a2);
  if (v20) {
    int v21 = sub_100207484(v20 + 400);
  }
  else {
    int v21 = 0;
  }
  sub_1005020C4(a3, v21);
  uint64_t v22 = sub_10045D7CC((uint64_t)a1, (uint64_t)a2);
  if (v22) {
    int v23 = sub_10020748C(v22 + 400);
  }
  else {
    int v23 = 0;
  }
  sub_100502134(a3, v23);
  uint64_t v24 = sub_10045D7CC((uint64_t)a1, (uint64_t)a2);
  if (v24) {
    int v25 = sub_1002074EC(v24 + 400);
  }
  else {
    int v25 = 0;
  }
  sub_1005020D4(a3, v25);
  uint64_t v26 = sub_10045D7CC((uint64_t)a1, (uint64_t)a2);
  if (v26) {
    int v27 = sub_1002074FC(v26 + 400);
  }
  else {
    int v27 = 0;
  }
  sub_1005020E4(a3, v27);
  uint64_t v28 = sub_10045D7CC((uint64_t)a1, (uint64_t)a2);
  if (v28) {
    int v29 = sub_1002074AC(v28 + 400);
  }
  else {
    int v29 = 0;
  }
  sub_100502154(a3, v29);
  uint64_t v30 = sub_10045D7CC((uint64_t)a1, (uint64_t)a2);
  if (v30) {
    int v31 = sub_1002074BC(v30 + 400);
  }
  else {
    int v31 = 0;
  }
  sub_100502164(a3, v31);
  uint64_t v32 = sub_10045D7CC((uint64_t)a1, (uint64_t)a2);
  if (v32) {
    int v33 = sub_1002074CC(v32 + 400);
  }
  else {
    int v33 = 0;
  }
  sub_1005020F4(a3, v33);
  uint64_t v34 = sub_10045D7CC((uint64_t)a1, (uint64_t)a2);
  if (v34) {
    int v35 = sub_1002074DC(v34 + 400);
  }
  else {
    int v35 = 0;
  }
  sub_100502104(a3, v35);
  uint64_t v36 = sub_10045D7CC((uint64_t)a1, (uint64_t)a2);
  if (v36) {
    int v37 = sub_10020751C(v36 + 400);
  }
  else {
    int v37 = 0;
  }
  sub_100502124(a3, v37);
  if (qword_1008D5F50 != -1) {
    dispatch_once(&qword_1008D5F50, &stru_100899FD0);
  }
  if (sub_1004019B4((uint64_t)off_1008D5F48))
  {
    BOOL v38 = 1;
  }

  else
  {
    if (qword_1008D5F30 != -1) {
      dispatch_once(&qword_1008D5F30, &stru_100899FF0);
    }
    BOOL v38 = sub_1005CCE74((uint64_t)off_1008D5F28);
  }

  sub_100502224(a3, v38);
  uint64_t v39 = sub_10045D7CC((uint64_t)a1, (uint64_t)a2);
  if (v39) {
    int v40 = sub_100207404(v39 + 400);
  }
  else {
    int v40 = 0;
  }
  sub_10027228C(a3, v40);
  int v42 = sub_10045FA7C(v41, (uint64_t)a2);
  sub_100502094(a3, v42);
  unsigned int v43 = sub_10045FBC8((uint64_t)a1, (uint64_t)a2);
  sub_10026F638(a3, (float)v43 / 15.0);
  int v44 = sub_100207424(a3 + 400);
  sub_100270070(a3, v44);
  int v45 = (os_log_s *)qword_1008F7598;
  if (os_log_type_enabled((os_log_t)qword_1008F7598, OS_LOG_TYPE_DEFAULT))
  {
    int v46 = sub_1003D2B2C((uint64_t)a2, 32);
    *(_DWORD *)__int128 buf = 67109120;
    *(_DWORD *)&uint8_t buf[4] = v46;
    _os_log_impl((void *)&_mh_execute_header, v45, OS_LOG_TYPE_DEFAULT, "HFP setSupportsTipi %d", buf, 8u);
  }

  int v47 = sub_1003D2B2C((uint64_t)a2, 32);
  sub_1002700B8(a3, v47);
  int v48 = sub_1003DA3D8((uint64_t)a2);
  sub_100502144(a3, v48);
  int v49 = sub_1003D2B2C((uint64_t)a2, 5);
  int v50 = (os_log_s *)qword_1008F7598;
  if (os_log_type_enabled((os_log_t)qword_1008F7598, OS_LOG_TYPE_DEFAULT))
  {
    int v51 = "disabled";
    if (v49) {
      int v51 = "enabled";
    }
    *(_DWORD *)__int128 buf = 136315138;
    *(void *)&uint8_t buf[4] = v51;
    _os_log_impl((void *)&_mh_execute_header, v50, OS_LOG_TYPE_DEFAULT, "Offloading Host DSL %s", buf, 0xCu);
  }

  sub_1005022E4(a3, v49);
  int v52 = sub_1003D03AC((uint64_t)a2);
  sub_100270734(a3, v52);
  if ((sub_1003D2B2C((uint64_t)a2, 12) & 1) == 0)
  {
    BOOL v53 = sub_1003D2AF4((uint64_t)a2);
    if (!v53)
    {
      int v54 = sub_10045FC00(v53, (uint64_t)a2);
      sub_1005022F4(a3, v54);
    }
  }

  int v55 = sub_1003D2B2C((uint64_t)a2, 12);
  sub_100270224(a3, v55);
  if (qword_1008D60E0 != -1) {
    dispatch_once(&qword_1008D60E0, &stru_10089A010);
  }
  int v56 = sub_10021C224((uint64_t)off_1008D60D8, (uint64_t)a2);
  sub_10027024C(a3, v56);
  if (qword_1008D60E0 != -1) {
    dispatch_once(&qword_1008D60E0, &stru_10089A010);
  }
  if (sub_10021C224((uint64_t)off_1008D60D8, (uint64_t)a2))
  {
    *(_DWORD *)__int128 buf = 0;
    *(_DWORD *)&__p.byte0 = 0;
    if (qword_1008D60E0 != -1) {
      dispatch_once(&qword_1008D60E0, &stru_10089A010);
    }
    sub_10021F164((uint64_t)off_1008D60D8, (uint64_t)a2, (int *)buf, (int *)&__p);
    sub_10027029C(a3, buf[0], __p.byte0);
    int v86 = 3;
    if (qword_1008D60E0 != -1) {
      dispatch_once(&qword_1008D60E0, &stru_10089A010);
    }
    sub_10021F3F4((uint64_t)off_1008D60D8, (uint64_t)a2, &v86);
    sub_1002702AC(a3, v86);
    unsigned __int8 v57 = sub_1003DF900((uint64_t)a2);
    sub_1002702BC(a3, v57);
    if (qword_1008D60E0 != -1) {
      dispatch_once(&qword_1008D60E0, &stru_10089A010);
    }
    int v58 = sub_10021F03C((uint64_t)off_1008D60D8, (uint64_t)a2);
    sub_100270274(a3, v58);
  }

  if ((sub_1003D2B2C((uint64_t)a2, 12) & 1) != 0 || sub_1003D2AF4((uint64_t)a2))
  {
    if (qword_1008D60E0 != -1) {
      dispatch_once(&qword_1008D60E0, &stru_10089A010);
    }
    unsigned __int8 v59 = sub_10021B978((uint64_t)off_1008D60D8, (uint64_t)a2);
    sub_1002702CC(a3, v59);
  }

  sub_1003D55EC((uint64_t)a2, (_DWORD *)&v89 + 1, &v89, (_DWORD *)&v88 + 1, &v88);
  int v60 = sub_1003D2B2C((uint64_t)a2, 41);
  __int16 v61 = (os_log_s *)qword_1008F7598;
  if (os_log_type_enabled((os_log_t)qword_1008F7598, OS_LOG_TYPE_DEFAULT))
  {
    __int128 v62 = "Disabled";
    if (v60) {
      __int128 v62 = "Enabled";
    }
    *(_DWORD *)__int128 buf = 136315138;
    *(void *)&uint8_t buf[4] = v62;
    _os_log_impl( (void *)&_mh_execute_header,  v61,  OS_LOG_TYPE_DEFAULT,  "High Quality BiDirectional Audio %s",  buf,  0xCu);
  }

  sub_100270970(a3, v60);
  if (sub_1003D8C10((uint64_t)a2))
  {
    unsigned __int8 v63 = sub_1003DFA38((uint64_t)a2);
    sub_1002702EC(a3, v63);
  }

  if (sub_1003DFAC0((uint64_t)a2))
  {
    __int128 v64 = (os_log_s *)qword_1008F7598;
    if (os_log_type_enabled((os_log_t)qword_1008F7598, OS_LOG_TYPE_DEFAULT))
    {
      sub_1003CF00C((uint64_t)a2, buf);
      __int128 v65 = buf[23] >= 0 ? buf : *(_BYTE **)buf;
      *(_DWORD *)&__p.byte0 = 136315138;
      *(void *)&__p.byte4 = v65;
      _os_log_impl( (void *)&_mh_execute_header,  v64,  OS_LOG_TYPE_DEFAULT,  "Applying DontAutoRoute: %s",  &__p.byte0,  0xCu);
      if ((buf[23] & 0x80000000) != 0) {
        operator delete(*(void **)buf);
      }
    }

    sub_1003DE174((uint64_t)a2, 0);
    sub_100270C44(a3, 0);
  }

  if (sub_1003DFB04((uint64_t)a2))
  {
    __int128 v66 = (os_log_s *)qword_1008F7598;
    if (os_log_type_enabled((os_log_t)qword_1008F7598, OS_LOG_TYPE_DEFAULT))
    {
      sub_1003CF00C((uint64_t)a2, buf);
      __int128 v67 = buf[23] >= 0 ? buf : *(_BYTE **)buf;
      *(_DWORD *)&__p.byte0 = 136315138;
      *(void *)&__p.byte4 = v67;
      _os_log_impl( (void *)&_mh_execute_header,  v66,  OS_LOG_TYPE_DEFAULT,  "Applying AudioRouteHidden: %s",  &__p.byte0,  0xCu);
      if ((buf[23] & 0x80000000) != 0) {
        operator delete(*(void **)buf);
      }
    }

    sub_1003DE1B8((uint64_t)a2, 0);
    sub_100270CA4(a3, 1);
  }

  int v68 = sub_1003D2B2C((uint64_t)a2, 25);
  sub_100270698(a3, v68);
  int v69 = sub_1003D2B2C((uint64_t)a2, 37);
  sub_100502304(a3, v69);
  int v70 = sub_1003D2B2C((uint64_t)a2, 35);
  sub_100502334(a3, v70);
  *(void *)&__p.byte0 = 0LL;
  *(void *)&__p.byte8 = 0LL;
  if (qword_1008D5F30 != -1) {
    dispatch_once(&qword_1008D5F30, &stru_100899FF0);
  }
  sub_1005C8684( (uint64_t)off_1008D5F28,  ((unint64_t)a2[128] << 40) | ((unint64_t)a2[129] << 32) | ((unint64_t)a2[130] << 24) | ((unint64_t)a2[131] << 16) | ((unint64_t)a2[132] << 8) | a2[133],  1u,  1u,  0LL,  0LL,  buf);
  __int128 v71 = sub_100241F94(buf);
  BOOL v72 = (void *)objc_claimAutoreleasedReturnValue(v71);
  [v72 getUUIDBytes:&__p];

  sub_100270658(a3, &__p);
  sub_1003D55EC((uint64_t)a2, (_DWORD *)&v89 + 1, &v89, (_DWORD *)&v88 + 1, &v88);
  sub_100270668(a3, SHIDWORD(v88));
  sub_100270678(a3, v88);
  sub_100270688(a3, v89);
  float v73 = sub_1003E17A0((uint64_t)a2);
  sub_1002706C0(a3, v73);
  sub_100272534(buf, (uint64_t)(a2 + 1128));
  sub_100270744(a3, (int **)buf);
  if (*(void *)buf)
  {
    *(void *)&uint8_t buf[8] = *(void *)buf;
    operator delete(*(void **)buf);
  }

  int v74 = sub_1003E1830((uint64_t)a2);
  sub_100270898(a3, v74);
  int v75 = sub_1003DFC9C((uint64_t)a2);
  sub_1002705FC(a3, v75);
  int v76 = sub_1003D2B2C((uint64_t)a2, 44);
  sub_100502324(a3, v76);
  int v77 = sub_1003E0230((uint64_t)a2, 11);
  sub_100502314(a3, v77);
  if (sub_1003D2B2C((uint64_t)a2, 51))
  {
    uint64_t v78 = sub_1002E6E9C();
    int v79 = (*(uint64_t (**)(uint64_t))(*(void *)v78 + 2504LL))(v78);
  }

  else
  {
    int v79 = 0;
  }

  sub_100502344(a3, v79);
  sub_1002708F8(a3, a2[960]);
  if (qword_1008D60F0 != -1) {
    dispatch_once(&qword_1008D60F0, &stru_10089A030);
  }
  if (*((void *)off_1008D60E8 + 28))
  {
    int v80 = sub_100028D84(*((void *)off_1008D60E8 + 28));
    if (qword_1008D60F0 != -1) {
      dispatch_once(&qword_1008D60F0, &stru_10089A030);
    }
  }

  else
  {
    int v80 = 0;
  }

  if (off_1008D60E8) {
    BOOL v81 = sub_1004ACAC8((uint64_t)off_1008D60E8);
  }
  else {
    BOOL v81 = 0;
  }
  __int128 v82 = (os_log_s *)qword_1008F7598;
  if (os_log_type_enabled((os_log_t)qword_1008F7598, OS_LOG_TYPE_DEFAULT))
  {
    *(_DWORD *)__int128 buf = 67109376;
    *(_DWORD *)&uint8_t buf[4] = v81;
    *(_WORD *)&uint8_t buf[8] = 1024;
    *(_DWORD *)&buf[10] = v80;
    _os_log_impl( (void *)&_mh_execute_header,  v82,  OS_LOG_TYPE_DEFAULT,  "Publish HFP device, notify BTHAL low Latency Game: %d, HID Allow AoS: %d",  buf,  0xEu);
  }

  if ((v81 & v80) == 1) {
    sub_100460020((uint64_t)a1, (uint64_t)a2, 1);
  }
  __int16 v83 = sub_1002073A4(a3 + 400);
  *(void *)__int128 buf = _NSConcreteStackBlock;
  *(void *)&uint8_t buf[8] = 3221225472LL;
  *(void *)&uint8_t buf[16] = sub_100474D24;
  __int16 v93 = &unk_100899D10;
  uint64_t v94 = a2;
  __int16 v95 = v83;
  char v96 = 1;
  sub_100474C68(a1 + 82, buf);
  BOOL v84 = (sub_1003D8484((uint64_t)a2) & 2) == 0;
  sub_100271A54(a3, v84);
  sub_10026EE48(a3);
  return sub_100242FAC((uint64_t)v87);
}

void sub_10045F344( _Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, char a11, uint64_t a12, uint64_t a13, uint64_t a14, void *__p, uint64_t a16, int a17, __int16 a18, char a19, char a20, uint64_t a21, void *a22, uint64_t a23, int a24, __int16 a25, char a26, char a27)
{
}

const char *sub_10045F408(uint64_t a1, int a2)
{
  if (a2 <= 126)
  {
    if (a2)
    {
      if (a2 == 1)
      {
        return "CSVD";
      }

      else if (a2 == 2)
      {
        return "mSBC";
      }

      else
      {
        return "Unknown";
      }
    }

    else
    {
      return "None";
    }
  }

  else
  {
    switch(a2)
    {
      case 127:
        BOOL result = "LC3";
        break;
      case 128:
        BOOL result = "AAC-ELD-Stereo";
        break;
      case 129:
        BOOL result = "AAC-ELD-Stereo48K";
        break;
      case 130:
        BOOL result = "AAC-ELD-Stereo48K-10ms";
        break;
      default:
        if (a2 == 255)
        {
          BOOL result = "LC3-Stereo";
        }

        else
        {
          if (a2 != 256) {
            return "Unknown";
          }
          BOOL result = "AAC-ELD";
        }

        break;
    }
  }

  return result;
}

uint64_t sub_10045F4D0(uint64_t a1, uint64_t a2)
{
  uint64_t v3 = sub_10045D7CC(a1, a2);
  int v4 = sub_10045F7E8(v3, a2);
  uint64_t v5 = v3 + 400;
  else {
    uint64_t v6 = 1000LL;
  }
  if (sub_1003D2B2C(a2, 12))
  {
    *(_DWORD *)__int128 buf = 0;
    LODWORD(__p[0]) = 0;
    uint64_t v17 = 0LL;
    sub_1003D55EC(a2, buf, __p, (_DWORD *)&v17 + 1, &v17);
    else {
      uint64_t v6 = dword_1006C3274[HIDWORD(v17) - 8194];
    }
  }

  uint64_t v7 = sub_100207254(v5);
  HIDWORD(v17) = v7;
  if ((_DWORD)v7)
  {
    uint64_t v8 = (os_log_s *)qword_1008F7598;
    if (os_log_type_enabled((os_log_t)qword_1008F7598, OS_LOG_TYPE_DEFAULT))
    {
      *(_DWORD *)__int128 buf = 67109120;
      *(_DWORD *)&uint8_t buf[4] = v7;
      _os_log_impl((void *)&_mh_execute_header, v8, OS_LOG_TYPE_DEFAULT, "Modified default sco delay to: %d", buf, 8u);
    }

    uint64_t v6 = v7;
  }

  uint64_t v9 = sub_1002E6E00();
  if ((*(unsigned int (**)(uint64_t))(*(void *)v9 + 8LL))(v9))
  {
    uint64_t v10 = sub_1002E6E00();
    sub_10002418C(buf, "VoiceCommand");
    sub_10002418C(__p, "DelayInMsec");
    int v11 = (*(uint64_t (**)(uint64_t, uint8_t *, void **, char *))(*(void *)v10 + 88LL))( v10,  buf,  __p,  (char *)&v17 + 4);
    if (v16 < 0) {
      operator delete(__p[0]);
    }
    if (v21 < 0)
    {
      operator delete(*(void **)buf);
      if (!v11) {
        goto LABEL_22;
      }
    }

    else if (!v11)
    {
      goto LABEL_22;
    }

    unsigned __int16 v12 = (os_log_s *)qword_1008F7598;
    if (os_log_type_enabled((os_log_t)qword_1008F7598, OS_LOG_TYPE_DEFAULT))
    {
      *(_DWORD *)__int128 buf = 67109120;
      *(_DWORD *)&uint8_t buf[4] = HIDWORD(v17);
      _os_log_impl( (void *)&_mh_execute_header,  v12,  OS_LOG_TYPE_DEFAULT,  "Default write modified default sco delay to %dms",  buf,  8u);
    }

    uint64_t v6 = HIDWORD(v17);
  }

void sub_10045F7AC( _Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, void *__p, uint64_t a10, int a11, __int16 a12, char a13, char a14, uint64_t a15, void *a16, uint64_t a17, int a18, __int16 a19, char a20, char a21)
{
  if (a14 < 0) {
    operator delete(__p);
  }
  if (a21 < 0) {
    operator delete(a16);
  }
  _Unwind_Resume(exception_object);
}

uint64_t sub_10045F7E8(uint64_t a1, uint64_t a2)
{
  int v3 = sub_1003D062C(a2);
  LOBYTE(v4) = 1;
  switch(v3)
  {
    case 0:
      int v5 = sub_1003D0268(a2);
      unint64_t v4 = 0x302030103010201uLL >> (8 * (v5 - 16));
      break;
    case 1:
      LOBYTE(v4) = 2;
      break;
    case 2:
      return v4;
    case 3:
      LOBYTE(v4) = 4;
      break;
    case 4:
      LOBYTE(v4) = 3;
      break;
    case 5:
      LOBYTE(v4) = 5;
      break;
    default:
      LOBYTE(v4) = 0;
      break;
  }

  return v4;
}

uint64_t sub_10045F88C(uint64_t a1, uint64_t a2)
{
  uint64_t v15 = 0LL;
  __int128 v14 = 0u;
  memset(v13, 0, sizeof(v13));
  __int128 v11 = 0u;
  *(_OWORD *)CFUUIDBytes __p = 0u;
  __int128 v9 = 0u;
  *(_OWORD *)uint64_t v10 = 0u;
  __int128 v7 = 0u;
  *(_OWORD *)uint64_t v8 = 0u;
  sub_100532DC0((uint64_t)&v7 + 1);
  BYTE2(v8[0]) = 0;
  BYTE4(v8[0]) = 0;
  BYTE2(v10[0]) = 0;
  BYTE4(v10[0]) = 0;
  DWORD1(v13[1]) = 0;
  __int128 v9 = 0uLL;
  v8[1] = 0LL;
  LOBYTE(v10[0]) = 0;
  __int128 v11 = 0uLL;
  v10[1] = 0LL;
  LOBYTE(__p[0]) = 0;
  memset(v13, 0, 19);
  __p[1] = 0LL;
  BYTE8(v13[1]) = 1;
  BYTE2(v15) = 0;
  *(void *)((char *)&v13[1] + 14) = 0LL;
  *(void *)((char *)&v13[1] + 9) = 0LL;
  __int128 v14 = 0uLL;
  *((void *)&v13[2] + 1) = 0LL;
  LOBYTE(v15) = 0;
  if (a2)
  {
    if (sub_1003D2408(a2, (uint64_t)&v7))
    {
      a2 = DWORD2(v13[2]);
      if (DWORD2(v13[2]))
      {
        unint64_t v4 = (os_log_s *)qword_1008F7598;
        if (os_log_type_enabled((os_log_t)qword_1008F7598, OS_LOG_TYPE_INFO))
        {
          v6[0] = 67109120;
          v6[1] = a2;
          _os_log_impl((void *)&_mh_execute_header, v4, OS_LOG_TYPE_INFO, "DSPTuning: %d", (uint8_t *)v6, 8u);
        }
      }
    }

    else
    {
      a2 = 0LL;
    }
  }

  if (SHIBYTE(v13[0]) < 0) {
    operator delete(__p[1]);
  }
  if (SHIBYTE(v11) < 0) {
    operator delete(v10[1]);
  }
  if (SHIBYTE(v9) < 0) {
    operator delete(v8[1]);
  }
  nullsub_63((char *)&v7 + 1, v3);
  return a2;
}

void sub_10045FA18(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, ...)
{
}

uint64_t sub_10045FA34(uint64_t a1, uint64_t a2)
{
  uint64_t result = sub_10045D7CC(a1, a2);
  if (result) {
    return sub_10020748C(result + 400);
  }
  return result;
}

uint64_t sub_10045FA58(uint64_t a1, uint64_t a2)
{
  uint64_t result = sub_10045D7CC(a1, a2);
  if (result) {
    return sub_1002074AC(result + 400);
  }
  return result;
}

uint64_t sub_10045FA7C(uint64_t a1, uint64_t a2)
{
  uint64_t v13 = 0LL;
  __int128 v12 = 0u;
  memset(v11, 0, sizeof(v11));
  __int128 v9 = 0u;
  *(_OWORD *)CFUUIDBytes __p = 0u;
  __int128 v7 = 0u;
  *(_OWORD *)uint64_t v8 = 0u;
  __int128 v5 = 0u;
  *(_OWORD *)uint64_t v6 = 0u;
  sub_100532DC0((uint64_t)&v5 + 1);
  BYTE2(v6[0]) = 0;
  BYTE4(v6[0]) = 0;
  BYTE2(v8[0]) = 0;
  BYTE4(v8[0]) = 0;
  DWORD1(v11[1]) = 0;
  __int128 v7 = 0uLL;
  v6[1] = 0LL;
  LOBYTE(v8[0]) = 0;
  __int128 v9 = 0uLL;
  v8[1] = 0LL;
  LOBYTE(__p[0]) = 0;
  memset(v11, 0, 19);
  __p[1] = 0LL;
  BYTE8(v11[1]) = 1;
  BYTE2(v13) = 0;
  *(void *)((char *)&v11[1] + 14) = 0LL;
  *(void *)((char *)&v11[1] + 9) = 0LL;
  __int128 v12 = 0uLL;
  *((void *)&v11[2] + 1) = 0LL;
  LOBYTE(v13) = 0;
  if (a2)
  {
    else {
      a2 = 0LL;
    }
  }

  if (SHIBYTE(v11[0]) < 0) {
    operator delete(__p[1]);
  }
  if (SHIBYTE(v9) < 0) {
    operator delete(v8[1]);
  }
  if (SHIBYTE(v7) < 0) {
    operator delete(v6[1]);
  }
  nullsub_63((char *)&v5 + 1, v3);
  return a2;
}

void sub_10045FBAC( _Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9)
{
}

uint64_t sub_10045FBC8(uint64_t a1, uint64_t a2)
{
  uint64_t v2 = sub_10045D7CC(a1, a2);
  uint64_t v3 = 12LL;
  if (v2)
  {
    unsigned int v4 = sub_1002073F4(v2 + 400);
    if (v4) {
      return v4;
    }
    else {
      return 12LL;
    }
  }

  return v3;
}

uint64_t sub_10045FC00(uint64_t a1, uint64_t a2)
{
  switch(sub_1003D062C(a2))
  {
    case 0u:
      uint64_t v3 = (os_log_s *)qword_1008F7598;
      BOOL v4 = os_log_type_enabled((os_log_t)qword_1008F7598, OS_LOG_TYPE_DEFAULT);
      uint64_t result = 0LL;
      if (v4)
      {
        sub_1003CF00C(a2, __p);
        if (v21 >= 0) {
          uint64_t v6 = __p;
        }
        else {
          uint64_t v6 = (void **)__p[0];
        }
        *(_DWORD *)__int128 buf = 136446210;
        int v23 = v6;
        __int128 v7 = "User selected device type is unknown. Returning user selected device type as kBluetoothAudioDeviceCategoryU"
             "nknown for device %{public}s.";
        goto LABEL_12;
      }

      break;
    case 1u:
      uint64_t v10 = (os_log_s *)qword_1008F7598;
      if (os_log_type_enabled((os_log_t)qword_1008F7598, OS_LOG_TYPE_DEFAULT))
      {
        sub_1003CF00C(a2, __p);
        __int128 v11 = v21 >= 0 ? __p : (void **)__p[0];
        *(_DWORD *)__int128 buf = 136446210;
        int v23 = v11;
        _os_log_impl( (void *)&_mh_execute_header,  v10,  OS_LOG_TYPE_DEFAULT,  "Returning user selected device type as kBluetoothAudioDeviceCategoryCarkit for device %{public}s.",  buf,  0xCu);
        if (v21 < 0) {
          operator delete(__p[0]);
        }
      }

      uint64_t result = 2LL;
      break;
    case 2u:
      __int128 v12 = (os_log_s *)qword_1008F7598;
      if (os_log_type_enabled((os_log_t)qword_1008F7598, OS_LOG_TYPE_DEFAULT))
      {
        sub_1003CF00C(a2, __p);
        uint64_t v13 = v21 >= 0 ? __p : (void **)__p[0];
        *(_DWORD *)__int128 buf = 136446210;
        int v23 = v13;
        _os_log_impl( (void *)&_mh_execute_header,  v12,  OS_LOG_TYPE_DEFAULT,  "Returning user selected device type as kBluetoothAudioDeviceCategoryHeadphone for device %{public}s.",  buf,  0xCu);
        if (v21 < 0) {
          operator delete(__p[0]);
        }
      }

      uint64_t result = 1LL;
      break;
    case 3u:
      __int128 v14 = (os_log_s *)qword_1008F7598;
      if (os_log_type_enabled((os_log_t)qword_1008F7598, OS_LOG_TYPE_DEFAULT))
      {
        sub_1003CF00C(a2, __p);
        uint64_t v15 = v21 >= 0 ? __p : (void **)__p[0];
        *(_DWORD *)__int128 buf = 136446210;
        int v23 = v15;
        _os_log_impl( (void *)&_mh_execute_header,  v14,  OS_LOG_TYPE_DEFAULT,  "User selected device type is hearing aid. Returning user selected device type as kBluetoothAudioDeviceCategory HearingAid for device %{public}s.",  buf,  0xCu);
        if (v21 < 0) {
          operator delete(__p[0]);
        }
      }

      uint64_t result = 4LL;
      break;
    case 4u:
      char v16 = (os_log_s *)qword_1008F7598;
      if (os_log_type_enabled((os_log_t)qword_1008F7598, OS_LOG_TYPE_DEFAULT))
      {
        sub_1003CF00C(a2, __p);
        uint64_t v17 = v21 >= 0 ? __p : (void **)__p[0];
        *(_DWORD *)__int128 buf = 136446210;
        int v23 = v17;
        _os_log_impl( (void *)&_mh_execute_header,  v16,  OS_LOG_TYPE_DEFAULT,  "Returning user selected device type as kBluetoothAudioDeviceCategorySpeaker for device %{public}s.",  buf,  0xCu);
        if (v21 < 0) {
          operator delete(__p[0]);
        }
      }

      uint64_t result = 3LL;
      break;
    case 5u:
      uint64_t v18 = (os_log_s *)qword_1008F7598;
      if (os_log_type_enabled((os_log_t)qword_1008F7598, OS_LOG_TYPE_DEFAULT))
      {
        sub_1003CF00C(a2, __p);
        __int16 v19 = v21 >= 0 ? __p : (void **)__p[0];
        *(_DWORD *)__int128 buf = 136446210;
        int v23 = v19;
        _os_log_impl( (void *)&_mh_execute_header,  v18,  OS_LOG_TYPE_DEFAULT,  "User selected device type is other. Returning user selected device type as kBluetoothAudioDeviceCategoryOther for device %{public}s.",  buf,  0xCu);
        if (v21 < 0) {
          operator delete(__p[0]);
        }
      }

      uint64_t result = 5LL;
      break;
    default:
      uint64_t v3 = (os_log_s *)qword_1008F7598;
      BOOL v8 = os_log_type_enabled((os_log_t)qword_1008F7598, OS_LOG_TYPE_DEFAULT);
      uint64_t result = 0LL;
      if (v8)
      {
        sub_1003CF00C(a2, __p);
        if (v21 >= 0) {
          __int128 v9 = __p;
        }
        else {
          __int128 v9 = (void **)__p[0];
        }
        *(_DWORD *)__int128 buf = 136446210;
        int v23 = v9;
        __int128 v7 = "Returning user selected device type as kBluetoothAudioDeviceCategoryUnknown for device %{public}s.";
LABEL_12:
        _os_log_impl((void *)&_mh_execute_header, v3, OS_LOG_TYPE_DEFAULT, v7, buf, 0xCu);
        if (v21 < 0) {
          operator delete(__p[0]);
        }
        uint64_t result = 0LL;
      }

      break;
  }

  return result;
}

uint64_t sub_100460020(uint64_t result, uint64_t a2, int a3)
{
  if (a2)
  {
    uint64_t v5 = result;
    if ((_os_feature_enabled_impl("AudioAccessoryFeatures", "AdvancedHandsfreeGamingOnly") & 1) != 0
      || (uint64_t result = _os_feature_enabled_impl("AudioAccessoryFeatures", "AdvancedHandsfreeEverywhere"), (_DWORD)result))
    {
      uint64_t v6 = sub_1002E6BF0();
      uint64_t result = (*(uint64_t (**)(uint64_t))(*(void *)v6 + 240LL))(v6);
      if ((_DWORD)result)
      {
        uint64_t result = sub_1003D2B2C(a2, 49);
        if ((_DWORD)result)
        {
          __int128 v7 = (os_log_s *)qword_1008F7598;
          if (os_log_type_enabled((os_log_t)qword_1008F7598, OS_LOG_TYPE_DEFAULT))
          {
            BOOL v8 = "off";
            if (a3) {
              BOOL v8 = "on";
            }
            LODWORD(v1sub_100414D2C(qword_1008F72C0, 0) = 136315138;
            *(void *)((char *)&v10 + 4) = v8;
            _os_log_impl( (void *)&_mh_execute_header,  v7,  OS_LOG_TYPE_DEFAULT,  "Notify BTHAL Low Latency Game is %s",  (uint8_t *)&v10,  0xCu);
          }

          __int128 v10 = 0uLL;
          sub_100242F28((uint64_t)&v10, v5 + 760);
          uint64_t v9 = sub_10045D7CC(v5, a2);
          if (v9) {
            sub_100502114(v9, a3);
          }
          return sub_100242FAC((uint64_t)&v10);
        }
      }
    }
  }

  return result;
}

void sub_100460170(_Unwind_Exception *exception_object)
{
}

uint64_t sub_10046018C(uint64_t a1, uint64_t a2, int a3)
{
  v9[0] = 0LL;
  v9[1] = 0LL;
  sub_100242F28((uint64_t)v9, a1 + 760);
  uint64_t v6 = sub_10045D7CC(a1, a2);
  if (v6)
  {
    sub_100502314(v6, a3);
    uint64_t v7 = 0LL;
  }

  else
  {
    uint64_t v7 = 7LL;
  }

  sub_100242FAC((uint64_t)v9);
  return v7;
}

void sub_100460200( _Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9)
{
}

uint64_t sub_100460214(uint64_t a1, uint64_t a2, int a3)
{
  v9[0] = 0LL;
  v9[1] = 0LL;
  sub_100242F28((uint64_t)v9, a1 + 760);
  uint64_t v6 = sub_10045D7CC(a1, a2);
  if (v6)
  {
    sub_100502324(v6, a3);
    uint64_t v7 = 0LL;
  }

  else
  {
    uint64_t v7 = 7LL;
  }

  sub_100242FAC((uint64_t)v9);
  return v7;
}

void sub_100460288( _Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9)
{
}

void sub_10046029C( uint64_t a1, uint64_t a2, unsigned __int8 a3, void *a4, unsigned __int8 a5, unsigned __int8 a6)
{
  id v10 = a4;
  if (a2 && (uint64_t v11 = sub_1002073AC(a2 + 400)) != 0)
  {
    v12[0] = 3;
    v12[1] = sub_10026F9D0(a2, v10);
    void v12[2] = a3;
    v12[3] = a5;
    uint8_t v12[4] = a6;
    if (qword_1008D60E0 != -1) {
      dispatch_once(&qword_1008D60E0, &stru_10089A010);
    }
    if (sub_100222974((uint64_t)off_1008D60D8, v11, 5u, v12)
      && os_log_type_enabled((os_log_t)qword_1008F7598, OS_LOG_TYPE_ERROR))
    {
      sub_100681170();
    }
  }

  else if (os_log_type_enabled((os_log_t)qword_1008F7598, OS_LOG_TYPE_ERROR))
  {
    sub_100681144();
  }
}

void sub_1004603BC(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

uint64_t sub_1004603D8(uint64_t a1, uint64_t a2)
{
  v44[0] = 0LL;
  v44[1] = 0LL;
  sub_100242F28((uint64_t)v44, a1 + 760);
  if (sub_100501754(a2)) {
    return sub_100242FAC((uint64_t)v44);
  }
  int v43 = 0;
  char v42 = 0;
  sub_100242CA4(&v42);
  int v4 = sub_100119A7C((_WORD *)&v43 + 1, &v43);
  sub_100242CD0(&v42);
  if (v4 && os_log_type_enabled((os_log_t)qword_1008F7598, OS_LOG_TYPE_ERROR)) {
    sub_1006811D0();
  }
  if (a2)
  {
    uint64_t v5 = sub_1002073AC(a2 + 400);
    if (v5)
    {
      uint64_t v6 = (os_log_s *)qword_1008F7598;
      if (os_log_type_enabled((os_log_t)qword_1008F7598, OS_LOG_TYPE_DEFAULT))
      {
        int v7 = HIWORD(v43);
        int v8 = (unsigned __int16)v43;
        uint64_t v9 = sub_10020755C(a2 + 400);
        id v10 = sub_10045F408(v9, v9);
        *(_DWORD *)__int128 buf = 67109634;
        int v46 = v7;
        __int16 v47 = 1024;
        int v48 = v8;
        __int16 v49 = 2080;
        *(void *)int v50 = v10;
        _os_log_impl( (void *)&_mh_execute_header,  v6,  OS_LOG_TYPE_DEFAULT,  "ReadScoBuffer size:%hu, count:%u, codec:%s",  buf,  0x18u);
      }

      uint64_t v11 = sub_1002E6BF0();
      if (((*(uint64_t (**)(uint64_t))(*(void *)v11 + 328LL))(v11) & 1) == 0)
      {
        uint64_t v12 = sub_1002E6BF0();
      }

      if (sub_10020755C(a2 + 400) == 2)
      {
        sub_1002E6E9C();
        else {
          int v13 = 192;
        }
        HIWORD(v43) = v13;
        __int128 v14 = (os_log_s *)qword_1008F7598;
        if (os_log_type_enabled((os_log_t)qword_1008F7598, OS_LOG_TYPE_DEFAULT))
        {
          *(_DWORD *)__int128 buf = 67109120;
          int v46 = v13;
          _os_log_impl( (void *)&_mh_execute_header,  v14,  OS_LOG_TYPE_DEFAULT,  "Restore maxScoPacketSize for mSBC - %hu",  buf,  8u);
        }

        goto LABEL_28;
      }

      uint64_t v15 = sub_10045D7CC(a1, v5);
      if (v15 && sub_1002074BC(v15 + 400) && sub_10020755C(a2 + 400) == 128)
      {
        char v16 = (os_log_s *)qword_1008F7598;
        if (os_log_type_enabled((os_log_t)qword_1008F7598, OS_LOG_TYPE_DEFAULT))
        {
          *(_WORD *)__int128 buf = 0;
          _os_log_impl( (void *)&_mh_execute_header,  v16,  OS_LOG_TYPE_DEFAULT,  "Restore maxScoPacketSize for AAC-ELD Stereo",  buf,  2u);
        }

        __int16 v17 = 240;
      }

      else
      {
        if (sub_10020755C(a2 + 400) != 1)
        {
LABEL_28:
          uint64_t v19 = sub_1002E6BF0();
          if ((*(unsigned int (**)(uint64_t))(*(void *)v19 + 384LL))(v19))
          {
            if (sub_10020755C(a2 + 400) == 1)
            {
              int v20 = (os_log_s *)qword_1008F7598;
              if (os_log_type_enabled((os_log_t)qword_1008F7598, OS_LOG_TYPE_DEFAULT))
              {
                *(_WORD *)__int128 buf = 0;
                _os_log_impl( (void *)&_mh_execute_header,  v20,  OS_LOG_TYPE_DEFAULT,  "Restore macOS maxScoPacketSize for CVSD",  buf,  2u);
              }

              HIWORD(v43) = 60;
            }

            else if (sub_10020755C(a2 + 400) == 2)
            {
              sub_1002E6E9C();
              int v21 = sub_1000B6578() ? 240 : 120;
              HIWORD(v43) = v21;
              uint64_t v22 = (os_log_s *)qword_1008F7598;
              if (os_log_type_enabled((os_log_t)qword_1008F7598, OS_LOG_TYPE_DEFAULT))
              {
                *(_DWORD *)__int128 buf = 67109120;
                int v46 = v21;
                _os_log_impl( (void *)&_mh_execute_header,  v22,  OS_LOG_TYPE_DEFAULT,  "Restore macOS maxScoPacketSize for mSBC - %hu",  buf,  8u);
              }
            }
          }

          if (sub_10020755C(a2 + 400) == 255)
          {
            HIWORD(v43) = 360;
            int v23 = (os_log_s *)qword_1008F7598;
            if (os_log_type_enabled((os_log_t)qword_1008F7598, OS_LOG_TYPE_DEFAULT))
            {
              *(_DWORD *)__int128 buf = 67109120;
              int v46 = 360;
              _os_log_impl( (void *)&_mh_execute_header,  v23,  OS_LOG_TYPE_DEFAULT,  "Max SCO packet size of LC3 stereo - %hu",  buf,  8u);
            }
          }

          if (sub_10020755C(a2 + 400) == 129)
          {
            HIWORD(v43) = 360;
            uint64_t v24 = (os_log_s *)qword_1008F7598;
            if (os_log_type_enabled((os_log_t)qword_1008F7598, OS_LOG_TYPE_DEFAULT))
            {
              *(_DWORD *)__int128 buf = 67109120;
              int v46 = 360;
              _os_log_impl( (void *)&_mh_execute_header,  v24,  OS_LOG_TYPE_DEFAULT,  "Max SCO packet size of AAC-ELD stereo - %hu",  buf,  8u);
            }
          }

          if (sub_10020755C(a2 + 400) == 130)
          {
            HIWORD(v43) = 240;
            int v25 = (os_log_s *)qword_1008F7598;
            if (os_log_type_enabled((os_log_t)qword_1008F7598, OS_LOG_TYPE_DEFAULT))
            {
              *(_DWORD *)__int128 buf = 67109120;
              int v46 = 240;
              _os_log_impl( (void *)&_mh_execute_header,  v25,  OS_LOG_TYPE_DEFAULT,  "Max SCO packet size of AAC-ELD stereo 10ms - %hu",  buf,  8u);
            }
          }

          goto LABEL_48;
        }

        uint64_t v18 = (os_log_s *)qword_1008F7598;
        if (os_log_type_enabled((os_log_t)qword_1008F7598, OS_LOG_TYPE_DEFAULT))
        {
          *(_WORD *)__int128 buf = 0;
          _os_log_impl( (void *)&_mh_execute_header,  v18,  OS_LOG_TYPE_DEFAULT,  "Restore maxScoPacketSize for CVSD",  buf,  2u);
        }

        __int16 v17 = 120;
      }

      HIWORD(v43) = v17;
      goto LABEL_28;
    }
  }

void sub_100460A74( _Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, __int16 a10, char a11, char a12, int a13, char a14)
{
}

uint64_t sub_100460AB0(uint64_t a1, uint64_t a2, int a3)
{
  unsigned __int16 v20 = a3;
  v19[0] = 0LL;
  v19[1] = 0LL;
  sub_100242F28((uint64_t)v19, a1 + 760);
  uint64_t v6 = (os_log_s *)qword_1008F7598;
  if (os_log_type_enabled((os_log_t)qword_1008F7598, OS_LOG_TYPE_DEFAULT))
  {
    *(_DWORD *)__int128 buf = 67109120;
    *(_DWORD *)&uint8_t buf[4] = a3;
    _os_log_impl( (void *)&_mh_execute_header,  v6,  OS_LOG_TYPE_DEFAULT,  "Removing HFP device %d from tracked audio devices",  buf,  8u);
  }

  uint64_t v7 = *(void *)(a1 + 832);
  if (!v7) {
    goto LABEL_46;
  }
  uint64_t v8 = a1 + 832;
  do
  {
    unsigned int v9 = *(unsigned __int16 *)(v7 + 32);
    BOOL v10 = v9 >= v20;
    if (v9 >= v20) {
      uint64_t v11 = (uint64_t *)v7;
    }
    else {
      uint64_t v11 = (uint64_t *)(v7 + 8);
    }
    if (v10) {
      uint64_t v8 = v7;
    }
    uint64_t v7 = *v11;
  }

  while (*v11);
  if (v8 != a1 + 832 && v20 >= *(unsigned __int16 *)(v8 + 32))
  {
    *(void *)__int128 buf = &v20;
    uint64_t v12 = sub_1002550B8((uint64_t **)(a1 + 824), &v20, (uint64_t)&unk_1006C2518, (_WORD **)buf)[5];
    if (v12 && (sub_10020749C((uint64_t)(v12 + 50)) & 1) == 0)
    {
      if (sub_1002077A8((uint64_t)(v12 + 50)))
      {
        int v13 = (os_log_s *)qword_1008F7598;
        if (os_log_type_enabled((os_log_t)qword_1008F7598, OS_LOG_TYPE_DEFAULT))
        {
          sub_1003CF00C(a2, buf);
          __int128 v14 = SHIBYTE(v25) >= 0 ? buf : *(uint8_t **)buf;
          *(_DWORD *)int v21 = 136446210;
          uint64_t v22 = v14;
          _os_log_impl( (void *)&_mh_execute_header,  v13,  OS_LOG_TYPE_DEFAULT,  "Device %{public}s is in Expanse over A2DP. Clean up expanse A2DP states since device is unpublishing",  v21,  0xCu);
          if (SHIBYTE(v25) < 0) {
            operator delete(*(void **)buf);
          }
        }

        (*(void (**)(uint64_t, uint64_t *, void))(*(void *)a1 + 192LL))(a1, v12, 0LL);
      }

      *(void *)__int128 buf = _NSConcreteStackBlock;
      uint64_t v24 = 3221225472LL;
      int v25 = sub_100474D24;
      unsigned int v26 = &unk_100899D10;
      uint64_t v27 = a2;
      unsigned __int16 v28 = v20;
      char v29 = 0;
      sub_100474C68((os_unfair_lock_s *)(a1 + 328), buf);
      sub_10026F644((uint64_t)v12);
    }

    char v18 = 0;
    sub_100242CA4(&v18);
    if (sub_1003D2AF4(a2))
    {
      uint64_t v15 = (os_log_s *)qword_1008F7598;
      if (os_log_type_enabled((os_log_t)qword_1008F7598, OS_LOG_TYPE_DEFAULT))
      {
        sub_1003CF00C(a2, buf);
        char v16 = SHIBYTE(v25) >= 0 ? buf : *(uint8_t **)buf;
        *(_DWORD *)int v21 = 136446210;
        uint64_t v22 = v16;
        _os_log_impl( (void *)&_mh_execute_header,  v15,  OS_LOG_TYPE_DEFAULT,  "Disabling SCO Buffer Flush as %{public}s is disconnecting HFP",  v21,  0xCu);
        if (SHIBYTE(v25) < 0) {
          operator delete(*(void **)buf);
        }
      }
    }

    sub_100242CD0(&v18);
    sub_100329E44(a1 + 824, &v20);
    sub_100242CD8(&v18);
  }

  else
  {
LABEL_46:
    if (os_log_type_enabled((os_log_t)qword_1008F7598, OS_LOG_TYPE_ERROR)) {
      sub_100681230();
    }
  }

  return sub_100242FAC((uint64_t)v19);
}

void sub_100460E48(_Unwind_Exception *a1, uint64_t a2, ...)
{
}

uint64_t sub_100460E80(uint64_t a1, unsigned int a2, unsigned int a3)
{
  v9[0] = 0LL;
  v9[1] = 0LL;
  sub_100242F28((uint64_t)v9, a1 + 760);
  sub_1002E6E9C();
  if (!sub_1002D099C())
  {
LABEL_5:
    sub_100461050(a1, a2);
    return sub_100242FAC((uint64_t)v9);
  }

  if (a3 <= 9)
  {
    char v8 = 0;
    sub_100242CA4(&v8);
    BOOL v6 = sub_100133FA4();
    if (!v6)
    {
      sub_100460F58(v6, a2, 0xAu, a3 + 1);
      sub_100242CD8(&v8);
      return sub_100242FAC((uint64_t)v9);
    }

    sub_100242CD0(&v8);
    sub_100242CD8(&v8);
    goto LABEL_5;
  }

  return sub_100242FAC((uint64_t)v9);
}

void sub_100460F30(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, ...)
{
}

BOOL sub_100460F58(uint64_t a1, __int16 a2, unsigned int a3, char a4)
{
  uint64_t v7 = (os_log_s *)qword_1008F7598;
  if (os_log_type_enabled((os_log_t)qword_1008F7598, OS_LOG_TYPE_DEFAULT))
  {
    v11[0] = 67109120;
    v11[1] = a3;
    _os_log_impl( (void *)&_mh_execute_header,  v7,  OS_LOG_TYPE_DEFAULT,  "Delaying SCO connection by %d milliseconds",  (uint8_t *)v11,  8u);
  }

  char v8 = operator new(0x28uLL);
  sub_1004765F8((uint64_t)v8, a2, a4);
  void v8[2] = a3;
  uint64_t v9 = sub_100405058();
  return sub_100405744(v9, v8);
}

void sub_100461034(_Unwind_Exception *a1)
{
}

uint64_t sub_100461050(uint64_t a1, unsigned int a2)
{
  int v4 = sub_10045CF60(a1, a2);
  if (!v4)
  {
    if (os_log_type_enabled((os_log_t)qword_1008F7598, OS_LOG_TYPE_ERROR)) {
      sub_100681354();
    }
    return 0LL;
  }

  uint64_t v5 = (uint64_t)v4;
  uint64_t v6 = sub_1004615C4(a1, a2);
  uint64_t v7 = v5 + 400;
  int v8 = sub_1002073D4(v5 + 400);
  uint64_t v9 = (os_log_s *)qword_1008F7598;
  BOOL v10 = os_log_type_enabled((os_log_t)qword_1008F7598, OS_LOG_TYPE_DEFAULT);
  if (v8 != 3)
  {
    if (v10)
    {
      sub_1003CF00C(v6, __p);
      uint64_t v15 = v25 >= 0 ? __p : (void **)__p[0];
      *(_DWORD *)__int128 buf = 136446210;
      uint64_t v27 = v15;
      _os_log_impl( (void *)&_mh_execute_header,  v9,  OS_LOG_TYPE_DEFAULT,  "Making outgoing audio connection to device %{public}s",  buf,  0xCu);
      if (v25 < 0) {
        operator delete(__p[0]);
      }
    }

    sub_100242980(11LL);
    uint64_t v16 = mach_absolute_time();
    if (qword_1008D60F0 != -1) {
      dispatch_once(&qword_1008D60F0, &stru_10089A030);
    }
    *((void *)off_1008D60E8 + 23) = v16;
    if (sub_10020756C(v5 + 400))
    {
      if (sub_1002073D4(v5 + 400) == 1)
      {
        if (os_log_type_enabled((os_log_t)qword_1008F7598, OS_LOG_TYPE_ERROR)) {
          sub_100681418();
        }
        goto LABEL_41;
      }

      int v17 = sub_10046D7E4(a1, v6);
      if (!v17)
      {
LABEL_41:
        sub_1002073DC(v5 + 400, 1);
        return 1LL;
      }
    }

    else
    {
      LOBYTE(__p[0]) = 0;
      sub_100242CA4(__p);
      int v17 = sub_1000F1460(a2);
      if (!v17)
      {
        uint64_t v18 = sub_1002073AC(v5 + 400);
        int v17 = sub_10011EAF0((uint64_t)sub_10046D75C, v18 + 128);
      }

      sub_100242CD0(__p);
      sub_100242CD8(__p);
      if (!v17) {
        goto LABEL_41;
      }
    }

    if (v17 == 1806)
    {
      uint64_t v19 = (os_log_s *)qword_1008F7598;
      if (os_log_type_enabled((os_log_t)qword_1008F7598, OS_LOG_TYPE_DEFAULT))
      {
        sub_1003CF00C(v6, __p);
        unsigned __int16 v20 = v25 >= 0 ? __p : (void **)__p[0];
        *(_DWORD *)__int128 buf = 136446210;
        uint64_t v27 = v20;
        _os_log_impl( (void *)&_mh_execute_header,  v19,  OS_LOG_TYPE_DEFAULT,  "Audio is already connected to device %{public}s",  buf,  0xCu);
        if (v25 < 0) {
          operator delete(__p[0]);
        }
      }

      sub_100501F98(v5, 1, 1806);
      sub_1004694A4(a1, a2);
      return 1LL;
    }

    int v21 = (os_log_s *)qword_1008F7598;
    if (os_log_type_enabled((os_log_t)qword_1008F7598, OS_LOG_TYPE_ERROR))
    {
      sub_1003CF00C(v6, __p);
      int v23 = v25 >= 0 ? __p : (void **)__p[0];
      *(_DWORD *)__int128 buf = 136446466;
      uint64_t v27 = v23;
      __int16 v28 = 1024;
      int v29 = v17;
      _os_log_error_impl( (void *)&_mh_execute_header,  v21,  OS_LOG_TYPE_ERROR,  "Audio connection to device %{public}s failed with result %{bluetooth:OI_STATUS}u",  buf,  0x12u);
      if (v25 < 0) {
        operator delete(__p[0]);
      }
    }

    return 0LL;
  }

  if (v10)
  {
    sub_1003CF00C(v6, __p);
    uint64_t v11 = v25 >= 0 ? __p : (void **)__p[0];
    *(_DWORD *)__int128 buf = 136446210;
    uint64_t v27 = v11;
    _os_log_impl( (void *)&_mh_execute_header,  v9,  OS_LOG_TYPE_DEFAULT,  "Accepting incoming audio connection from device %{public}s",  buf,  0xCu);
    if (v25 < 0) {
      operator delete(__p[0]);
    }
  }

  LOBYTE(__p[0]) = 0;
  sub_100242CA4(__p);
  int v12 = sub_1000F14F0(a2, 1);
  uint64_t v13 = sub_1002073AC(v7);
  sub_10011EAF0((uint64_t)sub_10046D75C, v13 + 128);
  sub_100242CD0(__p);
  BOOL v14 = v12 == 0;
  if (v12)
  {
    if (os_log_type_enabled((os_log_t)qword_1008F7598, OS_LOG_TYPE_ERROR)) {
      sub_1006813B8();
    }
    sub_1002073DC(v7, 0);
    sub_100469A5C(a1, a2, 0, v12);
  }

  else
  {
    sub_1002073DC(v7, 0);
  }

  sub_100242CD8(__p);
  return v14;
}

void sub_1004614CC(_Unwind_Exception *a1, uint64_t a2, ...)
{
}

uint64_t sub_1004614EC(uint64_t a1, uint64_t a2)
{
  v11[0] = 0LL;
  v11[1] = 0LL;
  sub_100242F28((uint64_t)v11, a1 + 760);
  int v4 = *(void **)(a1 + 824);
  uint64_t v5 = (void *)(a1 + 832);
  if (v4 == v5)
  {
LABEL_9:
    uint64_t v9 = 0LL;
  }

  else
  {
    while (sub_1002073AC(v4[5] + 400LL) != a2)
    {
      uint64_t v6 = (void *)v4[1];
      if (v6)
      {
        do
        {
          uint64_t v7 = v6;
          uint64_t v6 = (void *)*v6;
        }

        while (v6);
      }

      else
      {
        do
        {
          uint64_t v7 = (void *)v4[2];
          BOOL v8 = *v7 == (void)v4;
          int v4 = v7;
        }

        while (!v8);
      }

      int v4 = v7;
      if (v7 == v5) {
        goto LABEL_9;
      }
    }

    uint64_t v9 = sub_1002073A4(v4[5] + 400LL);
  }

  sub_100242FAC((uint64_t)v11);
  return v9;
}

void sub_1004615AC( _Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9)
{
}

uint64_t sub_1004615C4(uint64_t a1, unsigned int a2)
{
  unsigned __int16 v13 = a2;
  v12[0] = 0LL;
  v12[1] = 0LL;
  sub_100242F28((uint64_t)v12, a1 + 760);
  uint64_t v4 = *(void *)(a1 + 832);
  if (!v4) {
    goto LABEL_12;
  }
  uint64_t v5 = a1 + 832;
  do
  {
    unsigned int v6 = *(unsigned __int16 *)(v4 + 32);
    BOOL v7 = v6 >= a2;
    if (v6 >= a2) {
      BOOL v8 = (uint64_t *)v4;
    }
    else {
      BOOL v8 = (uint64_t *)(v4 + 8);
    }
    if (v7) {
      uint64_t v5 = v4;
    }
    uint64_t v4 = *v8;
  }

  while (*v8);
  if (v5 != a1 + 832 && *(unsigned __int16 *)(v5 + 32) <= a2)
  {
    BOOL v14 = &v13;
    uint64_t v11 = sub_1002550B8((uint64_t **)(a1 + 824), &v13, (uint64_t)&unk_1006C2518, &v14);
    uint64_t v9 = sub_1002073AC((uint64_t)(v11[5] + 50));
  }

  else
  {
LABEL_12:
    uint64_t v9 = 0LL;
  }

  sub_100242FAC((uint64_t)v12);
  return v9;
}

void sub_100461688( _Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9)
{
}

uint64_t sub_10046169C(uint64_t a1, uint64_t a2)
{
  v12[0] = 0LL;
  v12[1] = 0LL;
  sub_100242F28((uint64_t)v12, a1 + 760);
  uint64_t v4 = *(void **)(a1 + 824);
  uint64_t v5 = (void *)(a1 + 832);
  if (v4 == v5)
  {
LABEL_12:
    uint64_t v10 = 0LL;
  }

  else
  {
    while (1)
    {
      unint64_t v6 = sub_1002073C4(v4[5] + 400LL);
      BOOL v7 = (_DWORD)v6 == *(_DWORD *)a2 && WORD2(v6) == *(unsigned __int16 *)(a2 + 4);
      if (v7) {
        break;
      }
      BOOL v8 = (void *)v4[1];
      if (v8)
      {
        do
        {
          uint64_t v9 = v8;
          BOOL v8 = (void *)*v8;
        }

        while (v8);
      }

      else
      {
        do
        {
          uint64_t v9 = (void *)v4[2];
          BOOL v7 = *v9 == (void)v4;
          uint64_t v4 = v9;
        }

        while (!v7);
      }

      uint64_t v4 = v9;
      if (v9 == v5) {
        goto LABEL_12;
      }
    }

    uint64_t v10 = sub_1002073A4(v4[5] + 400LL);
  }

  sub_100242FAC((uint64_t)v12);
  return v10;
}

void sub_100461778(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, ...)
{
}

uint64_t sub_100461790@<X0>(uint64_t a1@<X0>, unsigned int a2@<W1>, std::string *a3@<X8>)
{
  v13[0] = 0LL;
  v13[1] = 0LL;
  sub_100242F28((uint64_t)v13, a1 + 760);
  uint64_t v6 = *(void *)(a1 + 832);
  if (!v6) {
    goto LABEL_12;
  }
  uint64_t v7 = a1 + 832;
  do
  {
    unsigned int v8 = *(unsigned __int16 *)(v6 + 32);
    BOOL v9 = v8 >= a2;
    if (v8 >= a2) {
      uint64_t v10 = (uint64_t *)v6;
    }
    else {
      uint64_t v10 = (uint64_t *)(v6 + 8);
    }
    if (v9) {
      uint64_t v7 = v6;
    }
    uint64_t v6 = *v10;
  }

  while (*v10);
  if (v7 != a1 + 832 && *(unsigned __int16 *)(v7 + 32) <= a2)
  {
    uint64_t v12 = sub_1004615C4(a1, a2);
    a3->__r_.__value_.__r.__words[0] = 0LL;
    a3->__r_.__value_.__l.__size_ = 0LL;
    a3->__r_.__value_.__l.__cap_ = 0LL;
    sub_1003FE1B4((unsigned __int8 *)(v12 + 128), a3);
    std::string::append(a3, "-tsco");
  }

  else
  {
LABEL_12:
    sub_10002418C(a3, "null");
  }

  return sub_100242FAC((uint64_t)v13);
}

void sub_100461860( _Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9)
{
}

char *sub_100461890@<X0>(char *result@<X0>, uint64_t a2@<X1>, uint64_t a3@<X8>)
{
  uint64_t v3 = result;
  if (*(_DWORD *)(a2 + 768) == 32)
  {
    uint64_t v15 = 0LL;
    __int128 v14 = 0u;
    memset(v13, 0, sizeof(v13));
    __int128 v11 = 0u;
    *(_OWORD *)CFUUIDBytes __p = 0u;
    __int128 v9 = 0u;
    *(_OWORD *)uint64_t v10 = 0u;
    __int128 v7 = 0u;
    *(_OWORD *)unsigned int v8 = 0u;
    sub_100532DC0((uint64_t)&v7 + 1);
    BYTE2(v8[0]) = 0;
    BYTE4(v8[0]) = 0;
    BYTE2(v10[0]) = 0;
    BYTE4(v10[0]) = 0;
    DWORD1(v13[1]) = 0;
    __int128 v9 = 0uLL;
    v8[1] = 0LL;
    LOBYTE(v10[0]) = 0;
    __int128 v11 = 0uLL;
    v10[1] = 0LL;
    LOBYTE(__p[0]) = 0;
    memset(v13, 0, 19);
    __p[1] = 0LL;
    BYTE8(v13[1]) = 1;
    BYTE2(v15) = 0;
    *(void *)((char *)&v13[1] + 14) = 0LL;
    *(void *)((char *)&v13[1] + 9) = 0LL;
    __int128 v14 = 0uLL;
    *((void *)&v13[2] + 1) = 0LL;
    LOBYTE(v15) = 0;
    sub_1003D2408(a2, (uint64_t)&v7);
    if (SHIBYTE(v13[0]) < 0) {
      operator delete(__p[1]);
    }
    if (SHIBYTE(v11) < 0) {
      operator delete(v10[1]);
    }
    if (SHIBYTE(v9) < 0) {
      operator delete(v8[1]);
    }
    uint64_t result = (char *)nullsub_63((char *)&v7 + 1, v6);
  }

  if (v3[23] < 0) {
    return (char *)sub_100024238((_BYTE *)a3, *(void **)v3, *((void *)v3 + 1));
  }
  *(_OWORD *)a3 = *(_OWORD *)v3;
  *(void *)(a3 + 16) = *((void *)v3 + 2);
  return result;
}

void sub_1004619EC( _Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9)
{
}

uint64_t sub_100461A08(uint64_t a1, int a2)
{
  char v4 = 0;
  sub_100242CA4(&v4);
  uint64_t v2 = sub_10010F2F8();
  sub_100242CD8(&v4);
  return v2;
}

void sub_100461A64( _Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, int a10, __int16 a11, char a12, char a13)
{
}

uint64_t sub_100461A78(uint64_t a1)
{
  uint64_t v2 = sub_100213C20(a1, 2);
  *(void *)uint64_t v2 = off_1008998C8;
  *(void *)(v2 + 256) = off_100899A58;
  *(void *)(v2 + 2sub_100242FAC(v30 - 64) = off_100899A98;
  *(void *)(v2 + 272) = &off_100899AC8;
  *(void *)(v2 + 28sub_100414D2C(qword_1008F72C0, 0) = off_100899AE0;
  *(void *)(v2 + 28_Block_object_dispose((const void *)(v2 - 88), 8) = off_100899B78;
  *(void *)(v2 + 2sub_100242FAC(v5 - 96) = off_100899BA0;
  *(void *)(v2 + 304) = off_100899C08;
  *(void *)(v2 + 312) = off_100899C48;
  *(void *)(v2 + 32sub_100414D2C(qword_1008F72C0, 0) = &off_100899C78;
  *(_DWORD *)(v2 + 32_Block_object_dispose((const void *)(v2 - 88), 8) = 0;
  *(void *)(v2 + 344) = 0LL;
  *(void *)(v2 + 352) = 0LL;
  *(void *)(v2 + 336) = 0LL;
  sub_100206290(v2 + 360);
  *(_BYTE *)(a1 + 752) = 0;
  sub_100242DC4(a1 + 760);
  *(void *)(a1 + 84sub_100414D2C(qword_1008F72C0, 0) = 0LL;
  *(void *)(a1 + 8sub_100242FAC(v1 - 32) = 0LL;
  *(void *)(a1 + 824) = a1 + 832;
  uint64_t v3 = sub_1002E6E00();
  sub_10002418C(buf, "PTS");
  sub_10002418C(__p, "PhoneNumberHack");
  (*(void (**)(uint64_t, uint8_t *, void **, uint64_t))(*(void *)v3 + 72LL))(v3, buf, __p, a1 + 752);
  if (v7 < 0) {
    operator delete(__p[0]);
  }
  if (v9 < 0) {
    operator delete(*(void **)buf);
  }
  if (*(_BYTE *)(a1 + 752))
  {
    char v4 = (os_log_s *)qword_1008F7598;
    if (os_log_type_enabled((os_log_t)qword_1008F7598, OS_LOG_TYPE_DEFAULT))
    {
      *(_WORD *)__int128 buf = 0;
      _os_log_impl((void *)&_mh_execute_header, v4, OS_LOG_TYPE_DEFAULT, "PTS phone number hack enabled", buf, 2u);
    }
  }

  return a1;
}

void sub_100461BE8( _Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void *__p, uint64_t a11, int a12, __int16 a13, char a14, char a15, void *a16, uint64_t a17, int a18, __int16 a19, char a20, char a21)
{
  if (a15 < 0) {
    operator delete(__p);
  }
  if (a21 < 0) {
    operator delete(a16);
  }
  sub_10023BF24(v21 + 824, *v24);
  sub_100242E28(v23);
  sub_100206490(v22);
  unsigned int v26 = *(void **)(v21 + 336);
  if (v26)
  {
    *(void *)(v21 + 344) = v26;
    operator delete(v26);
  }

  sub_100213D34(v21);
  _Unwind_Resume(a1);
}

void sub_100461C68()
{
}

uint64_t sub_100461C74(uint64_t a1)
{
  uint64_t v2 = sub_1002E6E00();
  sub_10002418C(v10, "Handsfree");
  sub_10002418C(__p, "VVMSleep");
  (*(void (**)(uint64_t, void **, void **, int *))(*(void *)v2 + 88LL))(v2, v10, __p, &dword_1008D99A0);
  if (v9 < 0) {
    operator delete(__p[0]);
  }
  if (v11 < 0) {
    operator delete(v10[0]);
  }
  if (qword_1008D60B0 != -1) {
    dispatch_once(&qword_1008D60B0, &stru_100899F70);
  }
  sub_1001FC5E4((uint64_t)off_1008D60A8 + 80, a1 + 264);
  uint64_t v3 = sub_1002E8D54();
  sub_100475B94(v3 + 408, a1 + 272);
  uint64_t v4 = sub_100405058();
  v7[0] = _NSConcreteStackBlock;
  v7[1] = 3221225472LL;
  void v7[2] = sub_100461EB4;
  void v7[3] = &unk_10087EB20;
  _OWORD v7[4] = a1;
  sub_1004054B4(v4, v7);
  if (qword_1008D5F50 != -1) {
    dispatch_once(&qword_1008D5F50, &stru_100899FD0);
  }
  sub_10000876C((uint64_t)off_1008D5F48 + 240, a1 + 312);
  if (qword_1008D5F30 != -1) {
    dispatch_once(&qword_1008D5F30, &stru_100899FF0);
  }
  sub_1005DC2BC((uint64_t)off_1008D5F28, a1 + 320);
  if (qword_1008D67E8 != -1) {
    dispatch_once(&qword_1008D67E8, &stru_10089A070);
  }
  sub_1000762CC((uint64_t)off_1008D67E0 + 24, a1 + 288);
  if (qword_1008D67A8 != -1) {
    dispatch_once(&qword_1008D67A8, &stru_10089A090);
  }
  sub_10052AB64(off_1008D67A0, a1 + 304);
  uint64_t v5 = sub_1002E6E9C();
  sub_1002D0870(v5, a1 + 296);
  return 0LL;
}

void sub_100461E80( _Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, void *__p, uint64_t a16, int a17, __int16 a18, char a19, char a20)
{
  if (a20 < 0) {
    operator delete(__p);
  }
  _Unwind_Resume(exception_object);
}

void sub_100461EB4(uint64_t a1)
{
  uint64_t v1 = *(void *)(a1 + 32);
  if (qword_1008D90F8 != -1) {
    dispatch_once(&qword_1008D90F8, &stru_10089A050);
  }
  sub_10054A7B0((uint64_t)off_1008D90F0, v1 + 256);
  sub_100461F1C(v1);
  sub_100461FE0(v1);
  sub_10046225C(v1);
}

uint64_t sub_100461F1C(uint64_t a1)
{
  uint64_t v2 = sub_1002E6BF0();
  else {
    __int16 v3 = 3939;
  }
  uint64_t v4 = sub_1002E6BF0();
  uint64_t v5 = sub_1002E6BF0();
  if (((*(uint64_t (**)(uint64_t))(*(void *)v5 + 384LL))(v5) & 1) == 0)
  {
    if (qword_1008D90F8 != -1) {
      dispatch_once(&qword_1008D90F8, &stru_10089A050);
    }
  }

  uint64_t v6 = a1 + 360;
  sub_10020651C(v6, v3);
  return sub_10020652C(v6, 15);
}

void sub_100461FE0(uint64_t a1)
{
  int v10 = 0;
  if (qword_1008D90F8 != -1) {
    dispatch_once(&qword_1008D90F8, &stru_10089A050);
  }
  if (sub_10054A9EC((uint64_t)off_1008D90F0))
  {
    if (os_log_type_enabled((os_log_t)qword_1008F7598, OS_LOG_TYPE_ERROR)) {
      sub_10068149C();
    }
  }

  else
  {
    int v7 = (int)v11[0];
    if (SHIBYTE(v11[3]) < 0)
    {
      sub_100024238(&__p, v11[1], (unint64_t)v11[2]);
    }

    else
    {
      __int128 __p = *(_OWORD *)&v11[1];
      char v9 = v11[3];
    }

    sub_100206570(a1 + 360, (uint64_t)&v7);
    if (SHIBYTE(v9) < 0) {
      operator delete((void *)__p);
    }
  }

  if (qword_1008D90F8 != -1) {
    dispatch_once(&qword_1008D90F8, &stru_10089A050);
  }
  uint64_t v2 = sub_10054A9FC((uint64_t)off_1008D90F0);
  __int16 v3 = (void *)objc_claimAutoreleasedReturnValue(v2);
  if (v3)
  {
    sub_1002065B4(a1 + 360, v3);
  }

  else if (os_log_type_enabled((os_log_t)qword_1008F7598, OS_LOG_TYPE_ERROR))
  {
    sub_100681470();
  }

  if (qword_1008D90F8 != -1) {
    dispatch_once(&qword_1008D90F8, &stru_10089A050);
  }
  if (sub_10054AA0C((uint64_t)off_1008D90F0))
  {
    if (os_log_type_enabled((os_log_t)qword_1008F7598, OS_LOG_TYPE_ERROR)) {
      sub_100681444();
    }
  }

  else
  {
    sub_100206814(a1 + 360, v10);
  }

  __int16 v6 = 0;
  uint64_t v4 = sub_1002E8D54();
  (*(void (**)(uint64_t, char *, __int16 *))(*(void *)v4 + 96LL))(v4, (char *)&v6 + 1, &v6);
  else {
    unsigned int v5 = v6 / 0x14u + 1;
  }
  sub_100206824(a1 + 360, v5);

  if (SHIBYTE(v11[3]) < 0) {
    operator delete(v11[1]);
  }
}

void sub_100462214( _Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, void *__p, uint64_t a12, int a13, __int16 a14, char a15, char a16, uint64_t a17, uint64_t a18, void *a19, uint64_t a20, int a21, __int16 a22, char a23, char a24)
{
  if (a16 < 0) {
    operator delete(__p);
  }
  if (a24 < 0) {
    operator delete(a19);
  }
  _Unwind_Resume(exception_object);
}

void sub_10046225C(uint64_t a1)
{
  if (qword_1008D90F8 != -1) {
    dispatch_once(&qword_1008D90F8, &stru_10089A050);
  }
  if (sub_10054AA1C((uint64_t)off_1008D90F0))
  {
    if (os_log_type_enabled((os_log_t)qword_1008F7598, OS_LOG_TYPE_ERROR)) {
      sub_1006814C8();
    }
  }

  else
  {
    sub_10053C460((int)v2);
    sub_1002068B4(a1 + 360, v2);
    uint64_t v4 = (void **)v2;
    sub_1002077E0(&v4);
  }

  uint64_t v4 = (void **)v3;
  sub_1002077E0(&v4);
}

void sub_10046232C( _Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, char a10, uint64_t a11, uint64_t a12, char a13)
{
  *(void *)(v13 - 24) = &a10;
  sub_1002077E0((void ***)(v13 - 24));
  *(void *)(v13 - 24) = &a13;
  sub_1002077E0((void ***)(v13 - 24));
  _Unwind_Resume(a1);
}

uint64_t sub_100462360(uint64_t a1)
{
  uint64_t v2 = sub_1002E6E00();
  if ((*(unsigned int (**)(uint64_t))(*(void *)v2 + 8LL))(v2))
  {
    LOBYTE(v38[0]) = 0;
    uint64_t v3 = sub_1002E6E00();
    sub_10002418C(buf, "CATT");
    sub_10002418C(__p, "AudioSinkSdp");
    (*(void (**)(uint64_t, uint8_t *, void **, void *))(*(void *)v3 + 72LL))(v3, buf, __p, v38);
    if (v36 < 0) {
      operator delete(__p[0]);
    }
    if (SHIBYTE(v40) < 0) {
      operator delete(*(void **)buf);
    }
    if (LOBYTE(v38[0]))
    {
      uint64_t v4 = (os_log_s *)qword_1008F7598;
      if (os_log_type_enabled((os_log_t)qword_1008F7598, OS_LOG_TYPE_DEFAULT))
      {
        *(_WORD *)__int128 buf = 0;
        _os_log_impl((void *)&_mh_execute_header, v4, OS_LOG_TYPE_DEFAULT, "Adding HF role into SDP", buf, 2u);
      }

      *(_OWORD *)__int128 buf = xmmword_100899C88;
      int v40 = "Handsfree";
      __p[0] = buf;
      __p[1] = (void *)1;
      LOBYTE(v37) = 0;
      sub_100242CA4(&v37);
      if (sub_1000A56E0((uint64_t)__p, 0LL, 511, 387, (uint64_t)sub_100462974)
        && os_log_type_enabled((os_log_t)qword_1008F7598, OS_LOG_TYPE_ERROR))
      {
        sub_1006815B4();
      }

      sub_100242CD8(&v37);
    }
  }

  *(_OWORD *)__int128 __p = off_100899CB8;
  uint64_t v5 = sub_1002E6BF0();
  if (((*(uint64_t (**)(uint64_t, uint64_t))(*(void *)v5 + 792LL))(v5, 6LL) & 1) != 0)
  {
    int v6 = 3;
  }

  else
  {
    int v7 = (os_log_s *)qword_1008F7598;
    if (os_log_type_enabled((os_log_t)qword_1008F7598, OS_LOG_TYPE_DEFAULT))
    {
      *(_WORD *)__int128 buf = 0;
      _os_log_impl( (void *)&_mh_execute_header,  v7,  OS_LOG_TYPE_DEFAULT,  "WBS / mSBC for HFP disabled by defaults write",  buf,  2u);
    }

    int v6 = 1;
  }

  uint64_t v8 = sub_1002E6BF0();
  if ((*(unsigned int (**)(uint64_t, uint64_t))(*(void *)v8 + 792LL))(v8, 7LL))
  {
    v6 |= 0x100u;
    char v9 = (os_log_s *)qword_1008F7598;
    if (!os_log_type_enabled((os_log_t)qword_1008F7598, OS_LOG_TYPE_DEFAULT)) {
      goto LABEL_24;
    }
    *(_WORD *)__int128 buf = 0;
    int v10 = "UWBS / AAC-ELD for HFP enabled";
  }

  else
  {
    char v9 = (os_log_s *)qword_1008F7598;
    if (!os_log_type_enabled((os_log_t)qword_1008F7598, OS_LOG_TYPE_DEFAULT)) {
      goto LABEL_24;
    }
    *(_WORD *)__int128 buf = 0;
    int v10 = "UWBS / AAC-ELD for HFP disabled by defaults write";
  }

  _os_log_impl((void *)&_mh_execute_header, v9, OS_LOG_TYPE_DEFAULT, v10, buf, 2u);
LABEL_24:
  uint64_t v11 = sub_1002E6BF0();
  if ((*(unsigned int (**)(uint64_t, uint64_t))(*(void *)v11 + 792LL))(v11, 8LL))
  {
    v6 |= 0x80u;
    uint64_t v12 = (os_log_s *)qword_1008F7598;
    if (!os_log_type_enabled((os_log_t)qword_1008F7598, OS_LOG_TYPE_DEFAULT)) {
      goto LABEL_30;
    }
    *(_WORD *)__int128 buf = 0;
    uint64_t v13 = "UWBSStereo for HFP enabled";
  }

  else
  {
    uint64_t v12 = (os_log_s *)qword_1008F7598;
    if (!os_log_type_enabled((os_log_t)qword_1008F7598, OS_LOG_TYPE_DEFAULT)) {
      goto LABEL_30;
    }
    *(_WORD *)__int128 buf = 0;
    uint64_t v13 = "UWBSStereo for HFP disabled by defaults write";
  }

  _os_log_impl((void *)&_mh_execute_header, v12, OS_LOG_TYPE_DEFAULT, v13, buf, 2u);
LABEL_30:
  uint64_t v14 = sub_1002E6BF0();
  else {
    int v15 = v6;
  }
  sub_1002E6E9C();
  uint64_t v16 = sub_1002E6BF0();
  uint64_t v17 = sub_1002E6E9C();
  uint64_t v18 = sub_1002E6E9C();
  int v19 = (*(uint64_t (**)(uint64_t))(*(void *)v18 + 2496LL))(v18);
  char v34 = 0;
  sub_100242CA4(&v34);
  uint64_t v20 = a1 + 360;
  unsigned int v21 = sub_100206524(v20);
  int v22 = sub_1000EECA4((uint64_t)__p, 0LL, v21, v15, (uint64_t)sub_1004629D8, 0);
  if (!v22) {
    goto LABEL_43;
  }
  if (os_log_type_enabled((os_log_t)qword_1008F7598, OS_LOG_TYPE_ERROR)) {
    sub_100681554();
  }
  if (v22 == 140)
  {
LABEL_43:
    if (v19)
    {
      uint64_t v23 = (os_log_s *)qword_1008F7598;
      if (os_log_type_enabled((os_log_t)qword_1008F7598, OS_LOG_TYPE_DEFAULT))
      {
        *(_WORD *)__int128 buf = 0;
        _os_log_impl((void *)&_mh_execute_header, v23, OS_LOG_TYPE_DEFAULT, "Registering Handsfree AoS", buf, 2u);
      }

      sub_1001F69FC((uint64_t)sub_100462A34);
    }

    char v24 = sub_100206534(v20);
    sub_1000EF0F8(v24);
    if (!sub_1000EF120((uint64_t)sub_100462BC4, 0))
    {
      char v26 = sub_1002065A4(v20);
      char v27 = sub_1002065AC(v20);
      unsigned int v28 = sub_10020681C(v20);
      unsigned int v29 = sub_10020682C(v20);
      sub_1000F0F90(v26, v27, v28, v29);
      v38[0] = 0LL;
      v38[1] = 0LL;
      __int16 v30 = -[NSUUID initWithUUIDBytes:](objc_alloc(&OBJC_CLASS___NSUUID), "initWithUUIDBytes:", v38);
      sub_100206FE0(v20, v15);
      sub_100206FF0(v20, v19);
      int v31 = operator new(0x30uLL);
      sub_100206854(v20, (int)buf);
      sub_100475E84((uint64_t)v31, (uint64_t)buf, v30);
      uint64_t v32 = sub_100405058();
      sub_100405744(v32, v31);
      unint64_t v37 = buf;
      sub_1002077E0((void ***)&v37);

      uint64_t v25 = 0LL;
      goto LABEL_53;
    }

    if (os_log_type_enabled((os_log_t)qword_1008F7598, OS_LOG_TYPE_ERROR)) {
      sub_1006814F4();
    }
    sub_1000EF080();
  }

  uint64_t v25 = 1LL;
LABEL_53:
  sub_100242CD8(&v34);
  return v25;
}

void sub_1004628D0( _Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, int a10, __int16 a11, char a12, char a13, void *__p, uint64_t a15, int a16, __int16 a17, char a18, char a19, uint64_t a20, uint64_t a21, uint64_t a22, void *a23, uint64_t a24, int a25, __int16 a26, char a27, char a28)
{
  sub_100242CD8(&a13);
  _Unwind_Resume(a1);
}

void sub_100462974()
{
  int v0 = (os_log_s *)qword_1008F7598;
  if (os_log_type_enabled((os_log_t)qword_1008F7598, OS_LOG_TYPE_DEFAULT))
  {
    *(_WORD *)uint64_t v1 = 0;
    _os_log_impl((void *)&_mh_execute_header, v0, OS_LOG_TYPE_DEFAULT, "Received hf event", v1, 2u);
  }

BOOL sub_1004629D8(int *a1)
{
  uint64_t v2 = sub_100405058();
  uint64_t v3 = operator new(0x18uLL);
  sub_100476054((uint64_t)v3, a1);
  return sub_100405744(v2, v3);
}

void sub_100462A20(_Unwind_Exception *a1)
{
}

void sub_100462A34(uint64_t a1, const void *a2, unsigned int a3, char a4)
{
  uint64_t v7 = sub_10012D890(a1);
  __int16 v8 = sub_1000F63EC(v7);
  uint64_t v20 = &off_10087FAA8;
  unsigned int v21 = 0LL;
  if (a3)
  {
    sub_10056AB04(&v17, a2, a3);
    sub_10002EAC8((uint64_t)&v20, (uint64_t)&v17);
    uint64_t v17 = &off_10087FAA8;
    if (v18) {
      sub_1002CD254(v18);
    }
    char v9 = 0;
  }

  else
  {
    __int16 v19 = 0;
    sub_10056AB04(&v17, &v19, 2uLL);
    sub_10002EAC8((uint64_t)&v20, (uint64_t)&v17);
    uint64_t v17 = &off_10087FAA8;
    if (v18) {
      sub_1002CD254(v18);
    }
    char v9 = 2;
  }

  uint64_t v10 = sub_100405058();
  v11[0] = _NSConcreteStackBlock;
  v11[1] = 3321888768LL;
  void v11[2] = sub_100475FDC;
  _OWORD v11[3] = &unk_100899DA8;
  char v15 = a4;
  __int16 v14 = v8;
  char v16 = v9;
  uint64_t v12 = &off_10087FAA8;
  uint64_t v13 = v21;
  if (v21) {
    sub_1002CD1E0((uint64_t)v21);
  }
  sub_100405384(v10, v11);
  uint64_t v12 = &off_10087FAA8;
  if (v13) {
    sub_1002CD254(v13);
  }
  uint64_t v20 = &off_10087FAA8;
  if (v21) {
    sub_1002CD254(v21);
  }
}

void sub_100462B70( _Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, unsigned int *a17)
{
  if (a17) {
    sub_1002CD254(a17);
  }
  *(void *)(v18 - sub_100242FAC(v30 - 64) = v17;
  uint64_t v20 = *(unsigned int **)(v18 - 56);
  if (v20) {
    sub_1002CD254(v20);
  }
  _Unwind_Resume(exception_object);
}

BOOL sub_100462BC4(__int16 a1, uint64_t a2)
{
  uint64_t v4 = sub_100405058();
  uint64_t v5 = operator new(0x18uLL);
  sub_100476254((uint64_t)v5, a1, a2);
  return sub_100405744(v4, v5);
}

void sub_100462C14(_Unwind_Exception *a1)
{
}

uint64_t sub_100462C28()
{
  char v3 = 0;
  sub_100242CA4(&v3);
  if (sub_1000EF080())
  {
    if (os_log_type_enabled((os_log_t)qword_1008F7598, OS_LOG_TYPE_ERROR)) {
      sub_100681674();
    }
LABEL_4:
    uint64_t v0 = 1LL;
    goto LABEL_10;
  }

  uint64_t v1 = sub_1002E6E9C();
  if (!(*(unsigned int (**)(uint64_t))(*(void *)v1 + 2496LL))(v1))
  {
    uint64_t v0 = 0LL;
    goto LABEL_10;
  }

  uint64_t v0 = sub_1001F7278();
  if ((_DWORD)v0)
  {
    if (os_log_type_enabled((os_log_t)qword_1008F7598, OS_LOG_TYPE_ERROR)) {
      sub_100681614();
    }
    goto LABEL_4;
  }

void sub_100462CF0( _Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, int a10, __int16 a11, char a12, char a13)
{
}

uint64_t sub_100462D08(uint64_t a1)
{
  uint64_t v2 = sub_100405058();
  v5[0] = _NSConcreteStackBlock;
  v5[1] = 3221225472LL;
  _DWORD v5[2] = sub_100462E68;
  void v5[3] = &unk_10087EB20;
  void v5[4] = a1;
  sub_1004054B4(v2, v5);
  uint64_t v3 = sub_1002E8D54();
  sub_10024E060(v3 + 408, a1 + 272);
  if (qword_1008D60B0 != -1) {
    dispatch_once(&qword_1008D60B0, &stru_100899F70);
  }
  sub_100009168((uint64_t)off_1008D60A8 + 80, a1 + 264);
  if (qword_1008D5F50 != -1) {
    dispatch_once(&qword_1008D5F50, &stru_100899FD0);
  }
  sub_100009168((uint64_t)off_1008D5F48 + 240, a1 + 312);
  if (qword_1008D67E8 != -1) {
    dispatch_once(&qword_1008D67E8, &stru_10089A070);
  }
  sub_100009168((uint64_t)off_1008D67E0 + 24, a1 + 288);
  if (qword_1008D67A8 != -1) {
    dispatch_once(&qword_1008D67A8, &stru_10089A090);
  }
  sub_10052AC9C((uint64_t)off_1008D67A0, a1 + 304);
  return 0LL;
}

void sub_100462E68(uint64_t a1)
{
  uint64_t v1 = *(void *)(a1 + 32);
  if (qword_1008D90F8 != -1) {
    dispatch_once(&qword_1008D90F8, &stru_10089A050);
  }
  sub_10054A86C((uint64_t)off_1008D90F0, v1 + 256);
}

uint64_t sub_100462EB8()
{
  return 3LL;
}

BOOL sub_100462EC0(uint64_t a1, uint64_t a2)
{
  return sub_100462EE0(a2) != -1;
}

uint64_t sub_100462EE0(uint64_t a1)
{
  __int128 v14 = xmmword_1006C3380;
  __int128 __p = 0LL;
  uint64_t v12 = 0LL;
  uint64_t v13 = 0LL;
  uint64_t v3 = (__int128 *)__p;
  uint64_t v2 = v12;
  if (__p == v12) {
    goto LABEL_29;
  }
  uint64_t v4 = (__int128 *)__p;
  while (1)
  {
    if (*(_BYTE *)v4 == 6 && *((_WORD *)v4 + 1) == 2)
    {
      uint64_t v6 = *((void *)v4 + 1);
      BOOL v7 = *(_BYTE *)v6 == 3 && *(_DWORD *)(v6 + 8) == 3;
      if (v7 && *(_BYTE *)(v6 + 16) == 1) {
        break;
      }
    }

    if (++v4 == v12)
    {
      uint64_t v8 = 0xFFFFFFFFLL;
      goto LABEL_19;
    }
  }

  uint64_t v8 = *(unsigned int *)(v6 + 24);
LABEL_19:
  while (v3 != v2)
  {
    __int128 v10 = *v3;
    sub_10025EB84(&v10);
    ++v3;
    uint64_t v2 = v12;
  }

  if ((_DWORD)v8 == -1)
  {
LABEL_29:
    if (os_log_type_enabled((os_log_t)qword_1008F7598, OS_LOG_TYPE_ERROR))
    {
      sub_1003CF00C(a1, &v10);
      sub_1006816D4();
    }

    uint64_t v8 = 0xFFFFFFFFLL;
  }

  if (__p)
  {
    uint64_t v12 = (__int128 *)__p;
    operator delete(__p);
  }

  return v8;
}

void sub_100463040( _Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, void *__p, uint64_t a13)
{
}

uint64_t sub_10046306C(uint64_t a1, uint64_t a2)
{
  uint64_t v3 = (os_log_s *)qword_1008F7598;
  if (os_log_type_enabled((os_log_t)qword_1008F7598, OS_LOG_TYPE_DEFAULT))
  {
    sub_1003CF00C(a2, __p);
    uint64_t v4 = v11 >= 0 ? __p : (void **)__p[0];
    *(_DWORD *)__int128 buf = 136446210;
    uint64_t v13 = v4;
    _os_log_impl( (void *)&_mh_execute_header,  v3,  OS_LOG_TYPE_DEFAULT,  "Attempting to connect handsfree to device %{public}s",  buf,  0xCu);
    if (v11 < 0) {
      operator delete(__p[0]);
    }
  }

  LOBYTE(__p[0]) = 0;
  sub_100242CA4(__p);
  int v5 = sub_100462EE0(a2);
  int v6 = v5;
  if (v5 == -1)
  {
    uint64_t v7 = 1LL;
  }

  else
  {
    if (sub_1000F5B44(a2 + 128, v5))
    {
      if (os_log_type_enabled((os_log_t)qword_1008F7598, OS_LOG_TYPE_ERROR)) {
        sub_10068177C(v6);
      }
      uint64_t v7 = 305LL;
    }

    else
    {
      uint64_t v7 = 0LL;
    }

    uint64_t v8 = sub_1002E6E9C();
    if ((*(unsigned int (**)(uint64_t))(*(void *)v8 + 2496LL))(v8)
      && sub_1003E5B14(a2)
      && sub_1001F6AD0(a2 + 128)
      && os_log_type_enabled((os_log_t)qword_1008F7598, OS_LOG_TYPE_ERROR))
    {
      sub_10068171C();
    }
  }

  sub_100242CD8(__p);
  return v7;
}

void sub_100463218( _Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, char a10)
{
}

uint64_t sub_10046323C(uint64_t a1, uint64_t a2)
{
  v11[0] = 0LL;
  v11[1] = 0LL;
  sub_100242F28((uint64_t)v11, a1 + 760);
  unsigned int v4 = sub_10046169C(a1, a2 + 128);
  uint64_t v5 = sub_1002E6E9C();
  if ((*(unsigned int (**)(uint64_t))(*(void *)v5 + 2496LL))(v5) && sub_1003E5B14(a2))
  {
    int v6 = sub_10045CF60(a1, v4);
    uint64_t v7 = sub_1002077B8((uint64_t)(v6 + 50));
    if ((_DWORD)v7) {
      sub_1004633CC(v7, a2 + 128);
    }
    char v10 = 0;
    sub_100242CA4(&v10);
    sub_100242CD8(&v10);
  }

  char v10 = 0;
  sub_100242CA4(&v10);
  if (sub_1000F5D14(v4, 1818))
  {
    if (os_log_type_enabled((os_log_t)qword_1008F7598, OS_LOG_TYPE_ERROR)) {
      sub_1006817E4(v4);
    }
    uint64_t v8 = 1LL;
  }

  else
  {
    uint64_t v8 = 0LL;
  }

  sub_100242CD8(&v10);
  sub_100242FAC((uint64_t)v11);
  return v8;
}

void sub_100463394( _Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, int a10, __int16 a11, char a12, char a13, char a14)
{
}

_BYTE *sub_1004633CC(uint64_t a1, uint64_t a2)
{
  char v7 = 0;
  sub_100242CA4(&v7);
  uint64_t v3 = (unsigned __int16 *)sub_10012D890(a2);
  sub_100242CD0(&v7);
  uint64_t v4 = *v3;
  uint64_t v5 = sub_1002E6E9C();
  (*(void (**)(uint64_t, uint64_t, void, uint64_t))(*(void *)v5 + 1560LL))(v5, v4, 0LL, 1LL);
  return sub_100242CD8(&v7);
}

void sub_100463438( _Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, int a10, __int16 a11, char a12, char a13)
{
}

uint64_t sub_100463450(uint64_t a1, unsigned int a2, int a3)
{
  int v6 = (os_log_s *)qword_1008F7598;
  if (os_log_type_enabled((os_log_t)qword_1008F7598, OS_LOG_TYPE_DEFAULT))
  {
    LODWORD(v13) = 67109376;
    DWORD1(v13) = a2;
    WORD4(v13) = 1024;
    *(_DWORD *)((char *)&v13 + 1sub_100414D2C(qword_1008F72C0, 0) = a3;
    _os_log_impl( (void *)&_mh_execute_header,  v6,  OS_LOG_TYPE_DEFAULT,  "Handsfree device handle %d disconnected with status %{bluetooth:OI_STATUS}u",  (uint8_t *)&v13,  0xEu);
  }

  uint64_t v7 = sub_1004615C4(a1, a2);
  sub_100460AB0(a1, v7, a2);
  if (qword_1008D9108 != -1) {
    dispatch_once(&qword_1008D9108, &stru_10089A0B0);
  }
  sub_100267490(qword_1008D9100, v7);
  if (v7)
  {
    uint64_t v21 = 0LL;
    __int128 v20 = 0u;
    memset(v19, 0, sizeof(v19));
    __int128 v17 = 0u;
    *(_OWORD *)__int128 __p = 0u;
    __int128 v15 = 0u;
    *(_OWORD *)char v16 = 0u;
    __int128 v13 = 0u;
    *(_OWORD *)__int128 v14 = 0u;
    sub_100532DC0((uint64_t)&v13 + 1);
    BYTE2(v14[0]) = 0;
    BYTE4(v14[0]) = 0;
    BYTE2(v16[0]) = 0;
    BYTE4(v16[0]) = 0;
    DWORD1(v19[1]) = 0;
    __int128 v15 = 0uLL;
    v14[1] = 0LL;
    LOBYTE(v16[0]) = 0;
    __int128 v17 = 0uLL;
    v16[1] = 0LL;
    LOBYTE(__p[0]) = 0;
    memset(v19, 0, 19);
    __p[1] = 0LL;
    BYTE8(v19[1]) = 1;
    BYTE2(v21) = 0;
    *(void *)((char *)&v19[1] + 14) = 0LL;
    *(void *)((char *)&v19[1] + 9) = 0LL;
    __int128 v20 = 0uLL;
    *((void *)&v19[2] + 1) = 0LL;
    LOBYTE(v21) = 0;
    BOOL v8 = sub_1003D2408(v7, (uint64_t)&v13);
    if (BYTE5(v19[2])) {
      BOOL v9 = v8;
    }
    else {
      BOOL v9 = 0;
    }
    if (v9)
    {
      uint64_t v10 = sub_1002E6E9C();
      (*(void (**)(uint64_t, void, uint64_t))(*(void *)v10 + 216LL))(v10, 0LL, 1LL);
    }

    sub_100411718(a1, v7, 0, a3);
    if (SHIBYTE(v19[0]) < 0) {
      operator delete(__p[1]);
    }
    if (SHIBYTE(v17) < 0) {
      operator delete(v16[1]);
    }
    if (SHIBYTE(v15) < 0) {
      operator delete(v14[1]);
    }
    nullsub_63((char *)&v13 + 1, v11);
  }

  else if (os_log_type_enabled((os_log_t)qword_1008F7598, OS_LOG_TYPE_ERROR))
  {
    sub_1006818BC();
  }

  uint64_t result = sub_100410EB0(a1);
  if ((result & 1) == 0)
  {
    sub_100206678(a1 + 360);
    uint64_t result = sub_100206834(a1 + 360);
    if ((_DWORD)result) {
      return sub_10020683C(a1 + 360, 0);
    }
  }

  return result;
}

void sub_1004636E4( _Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9)
{
}

uint64_t sub_100463700(uint64_t a1)
{
  uint64_t v2 = (os_log_s *)qword_1008F7598;
  if (os_log_type_enabled((os_log_t)qword_1008F7598, OS_LOG_TYPE_DEFAULT))
  {
    *(_WORD *)__int128 buf = 0;
    _os_log_impl((void *)&_mh_execute_header, v2, OS_LOG_TYPE_DEFAULT, "Cleaning up virtual call", buf, 2u);
  }

  if (qword_1008D90F8 != -1) {
    dispatch_once(&qword_1008D90F8, &stru_10089A050);
  }
  sub_10054ADE8((uint64_t)off_1008D90F0);
  if (qword_1008D90F8 != -1) {
    dispatch_once(&qword_1008D90F8, &stru_10089A050);
  }
  sub_10054AA1C((uint64_t)off_1008D90F0);
  sub_100206938(a1 + 360, v5);
  sub_100206650(a1 + 360, 1);
  *(void *)__int128 buf = 0LL;
  uint64_t v7 = 0LL;
  uint64_t v3 = -[NSUUID initWithUUIDBytes:](objc_alloc(&OBJC_CLASS___NSUUID), "initWithUUIDBytes:", buf);
  sub_10046400C(a1, v5, v3);

  *(void *)__int128 buf = v5;
  sub_1002077E0((void ***)buf);
  return 0LL;
}

void sub_100463870( _Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, char a10, uint64_t a11, uint64_t a12, void **a13)
{
  a13 = (void **)&a10;
  sub_1002077E0(&a13);
  _Unwind_Resume(a1);
}

void sub_1004638A4(uint64_t a1, uint64_t a2, int a3)
{
  uint64_t v6 = sub_100405058();
  v7[0] = _NSConcreteStackBlock;
  v7[1] = 3221225472LL;
  void v7[2] = sub_100463918;
  void v7[3] = &unk_10087F900;
  int v8 = a3;
  _OWORD v7[4] = a1;
  void v7[5] = a2;
  sub_100405384(v6, v7);
}

uint64_t sub_100463918(uint64_t a1)
{
  uint64_t v1 = *(void *)(a1 + 32);
  if (*(_DWORD *)(a1 + 48) == 18) {
    return sub_100463A48(*(void *)(a1 + 32));
  }
  v12[0] = 0LL;
  v12[1] = 0LL;
  sub_100242F28((uint64_t)v12, v1 + 760);
  uint64_t v4 = sub_10045D7CC(v1, *(void *)(a1 + 40));
  if (v4)
  {
    sub_1003D0100(*(void *)(a1 + 40), (uint64_t)v8);
    if (v9 >= 0) {
      uint64_t v5 = (char *)v8;
    }
    else {
      uint64_t v5 = (char *)v8[0];
    }
    sub_10002418C(__p, v5);
    sub_10026F96C(v4, (uint64_t)__p);
    if (v11 < 0) {
      operator delete(__p[0]);
    }
    if (v9 < 0) {
      operator delete(v8[0]);
    }
    int v7 = sub_10045F7E8(v6, *(void *)(a1 + 40));
    sub_1005020A4(v4, v7);
  }

  return sub_100242FAC((uint64_t)v12);
}

void sub_100463A00( _Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, void *a9, uint64_t a10, int a11, __int16 a12, char a13, char a14, void *__p, uint64_t a16, int a17, __int16 a18, char a19, char a20, char a21)
{
  if (a20 < 0) {
    operator delete(__p);
  }
  if (a14 < 0) {
    operator delete(a9);
  }
  sub_100242FAC((uint64_t)&a21);
  _Unwind_Resume(a1);
}

uint64_t sub_100463A48(uint64_t a1)
{
  v12[0] = 0LL;
  v12[1] = 0LL;
  sub_100242F28((uint64_t)v12, a1 + 760);
  if (qword_1008D5F50 != -1) {
    dispatch_once(&qword_1008D5F50, &stru_100899FD0);
  }
  BOOL v2 = sub_1004019B4((uint64_t)off_1008D5F48);
  uint64_t v3 = (os_log_s *)qword_1008F7598;
  if (os_log_type_enabled((os_log_t)qword_1008F7598, OS_LOG_TYPE_DEFAULT))
  {
    *(_DWORD *)__int128 buf = 67109120;
    BOOL v14 = v2;
    _os_log_impl( (void *)&_mh_execute_header,  v3,  OS_LOG_TYPE_DEFAULT,  "Device info change for incompatible classic hid %u",  buf,  8u);
  }

  if (qword_1008D5F30 != -1) {
    dispatch_once(&qword_1008D5F30, &stru_100899FF0);
  }
  BOOL v4 = sub_1005CCE74((uint64_t)off_1008D5F28);
  uint64_t v5 = (os_log_s *)qword_1008F7598;
  if (os_log_type_enabled((os_log_t)qword_1008F7598, OS_LOG_TYPE_DEFAULT))
  {
    *(_DWORD *)__int128 buf = 67109120;
    BOOL v14 = v4;
    _os_log_impl( (void *)&_mh_execute_header,  v5,  OS_LOG_TYPE_DEFAULT,  "Device info change for incompatible LE hid %u",  buf,  8u);
  }

  uint64_t v6 = *(void **)(a1 + 824);
  if (v6 != (void *)(a1 + 832))
  {
    do
    {
      uint64_t v7 = v6[5];
      if (v7) {
        sub_100270098(v7, "kBTAudioMsgPropertyIncompatibleHidConnected", v2 || v4);
      }
      int v8 = (void *)v6[1];
      if (v8)
      {
        do
        {
          char v9 = v8;
          int v8 = (void *)*v8;
        }

        while (v8);
      }

      else
      {
        do
        {
          char v9 = (void *)v6[2];
          BOOL v10 = *v9 == (void)v6;
          uint64_t v6 = v9;
        }

        while (!v10);
      }

      uint64_t v6 = v9;
    }

    while (v9 != (void *)(a1 + 832));
  }

  return sub_100242FAC((uint64_t)v12);
}

void sub_100463C30( _Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9)
{
}

void sub_100463C54(uint64_t a1, uint64_t a2, int a3)
{
  uint64_t v5 = a1 - 312;
  uint64_t v6 = sub_100405058();
  v7[0] = _NSConcreteStackBlock;
  v7[1] = 3221225472LL;
  void v7[2] = sub_100463918;
  void v7[3] = &unk_10087F900;
  int v8 = a3;
  _OWORD v7[4] = v5;
  void v7[5] = a2;
  sub_100405384(v6, v7);
}

void sub_100463CC8(uint64_t a1, uint64_t a2, int a3)
{
  if (a3 == 4)
  {
    void v7[7] = v3;
    v7[8] = v4;
    uint64_t v6 = sub_100405058();
    v7[0] = _NSConcreteStackBlock;
    v7[1] = 3221225472LL;
    void v7[2] = sub_100463D30;
    void v7[3] = &unk_10087EB20;
    _OWORD v7[4] = a1;
    sub_100405384(v6, v7);
  }

uint64_t sub_100463D30(uint64_t a1)
{
  return sub_100463A48(*(void *)(a1 + 32));
}

void sub_100463D38(uint64_t a1, uint64_t a2, int a3)
{
}

uint64_t sub_100463D58(uint64_t a1)
{
  uint64_t v2 = a1 + 360;
  if (sub_100206834(a1 + 360))
  {
    uint64_t v3 = qword_1008F7598;
    if (os_log_type_enabled((os_log_t)qword_1008F7598, OS_LOG_TYPE_DEFAULT))
    {
      *(_WORD *)__int128 buf = 0;
      uint64_t v4 = "Could not set up virtual call, voice session is already active.";
      uint64_t v5 = (os_log_s *)v3;
      uint32_t v6 = 2;
LABEL_19:
      _os_log_impl((void *)&_mh_execute_header, v5, OS_LOG_TYPE_DEFAULT, v4, buf, v6);
    }
  }

  else if ((sub_1002065F4(a1 + 360) & 1) != 0 || !sub_100206804(a1 + 360, 0))
  {
    uint64_t v9 = qword_1008F7598;
    if (os_log_type_enabled((os_log_t)qword_1008F7598, OS_LOG_TYPE_DEFAULT))
    {
      int v10 = sub_1002065F4(v2);
      BOOL v11 = sub_100206804(v2, 0);
      uint64_t v12 = "";
      __int128 v13 = "a call is present";
      if (!v10) {
        __int128 v13 = "";
      }
      if (!v11) {
        uint64_t v12 = "a call is being set up";
      }
      *(_DWORD *)__int128 buf = 136446466;
      *(void *)&uint8_t buf[4] = v13;
      *(_WORD *)&_BYTE buf[12] = 2082;
      *(void *)&_BYTE buf[14] = v12;
      uint64_t v4 = "Could not set up virtual call because: %{public}s, %{public}s";
      uint64_t v5 = (os_log_s *)v9;
      uint32_t v6 = 22;
      goto LABEL_19;
    }
  }

  else
  {
    uint64_t v7 = (os_log_s *)qword_1008F7598;
    if (os_log_type_enabled((os_log_t)qword_1008F7598, OS_LOG_TYPE_DEFAULT))
    {
      *(_WORD *)__int128 buf = 0;
      _os_log_impl((void *)&_mh_execute_header, v7, OS_LOG_TYPE_DEFAULT, "Setting up virtual call", buf, 2u);
    }

    sub_100206650(a1 + 360, 0);
    if (qword_1008D90F8 != -1) {
      dispatch_once(&qword_1008D90F8, &stru_10089A050);
    }
    sub_10054ADD8((uint64_t)off_1008D90F0);
    if (qword_1008D90F8 != -1) {
      dispatch_once(&qword_1008D90F8, &stru_10089A050);
    }
    sub_10054AA1C((uint64_t)off_1008D90F0);
    sub_100206938(a1 + 360, v15);
    *(void *)__int128 buf = 0LL;
    *(void *)&uint8_t buf[8] = 0LL;
    int v8 = -[NSUUID initWithUUIDBytes:](objc_alloc(&OBJC_CLASS___NSUUID), "initWithUUIDBytes:", buf);
    sub_10046400C(a1, v15, v8);
  }

  *(void *)__int128 buf = v15;
  sub_1002077E0((void ***)buf);
  return 0LL;
}

void sub_100463FD4( _Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, char a10, uint64_t a11, uint64_t a12, void **a13)
{
  a13 = (void **)&a10;
  sub_1002077E0(&a13);
  _Unwind_Resume(a1);
}

void sub_10046400C(uint64_t a1, uint64_t *a2, void *a3)
{
  id v5 = a3;
  v72[0] = 0LL;
  v72[1] = 0LL;
  sub_100242F28((uint64_t)v72, a1 + 760);
  unsigned __int8 v71 = 0;
  uint64_t v70 = 0LL;
  memset(v69, 0, sizeof(v69));
  sub_10054A050(v69);
  memset(&__src, 0, sizeof(__src));
  __int16 v67 = 0;
  int v66 = 0;
  int v65 = 0;
  unsigned __int8 v64 = 0;
  uint64_t v61 = 0LL;
  uint64_t v62 = 0LL;
  uint64_t v63 = 0LL;
  sub_10053C3D8(&v61);
  uint64_t v6 = a1 + 360;
  int v58 = 0LL;
  unsigned __int8 v59 = 0LL;
  uint64_t v60 = 0LL;
  sub_100206EF4(a1 + 360, (int)&v58);
  int v55 = 0LL;
  int v56 = 0LL;
  uint64_t v57 = 0LL;
  sub_10053C3D8(&v55);
  if (qword_1008D90F8 != -1) {
    dispatch_once(&qword_1008D90F8, &stru_10089A050);
  }
  sub_10054AA3C((uint64_t)off_1008D90F0);
  for (uint64_t i = (id *)*a2; i != (id *)a2[1]; i += 13)
  {
    id v8 = *i;
    uint64_t v9 = sub_10053C584(&v58, v8);

    id v10 = *i;
    BOOL v11 = sub_10053C584(&v55, v10);

    if (v59 == v9 && v56 == v11) {
      sub_10053C464(&v61, (uint64_t)i);
    }
  }

  __int128 v13 = (os_log_s *)qword_1008F7598;
  if (os_log_type_enabled((os_log_t)qword_1008F7598, OS_LOG_TYPE_DEFAULT))
  {
    sub_10053C68C((uint64_t *)&v58, (std::string *)v75);
    if (SBYTE3(v79) >= 0) {
      BOOL v14 = v75;
    }
    else {
      BOOL v14 = *(_BYTE **)v75;
    }
    *(_DWORD *)__int128 buf = 136315138;
    *(void *)&uint8_t buf[4] = v14;
    _os_log_impl((void *)&_mh_execute_header, v13, OS_LOG_TYPE_DEFAULT, "Call(s) in A2DP Expanse: %s", buf, 0xCu);
    if (SBYTE3(v79) < 0) {
      operator delete(*(void **)v75);
    }
    __int128 v13 = (os_log_s *)qword_1008F7598;
  }

  if (os_log_type_enabled(v13, OS_LOG_TYPE_DEFAULT))
  {
    sub_10053C68C((uint64_t *)&v55, (std::string *)v75);
    if (SBYTE3(v79) >= 0) {
      __int128 v15 = v75;
    }
    else {
      __int128 v15 = *(_BYTE **)v75;
    }
    *(_DWORD *)__int128 buf = 136315138;
    *(void *)&uint8_t buf[4] = v15;
    _os_log_impl((void *)&_mh_execute_header, v13, OS_LOG_TYPE_DEFAULT, "Call(s) in Screening: %s", buf, 0xCu);
    if (SBYTE3(v79) < 0) {
      operator delete(*(void **)v75);
    }
    __int128 v13 = (os_log_s *)qword_1008F7598;
  }

  if (os_log_type_enabled(v13, OS_LOG_TYPE_DEFAULT))
  {
    sub_10053C68C(a2, (std::string *)v75);
    if (SBYTE3(v79) >= 0) {
      char v16 = v75;
    }
    else {
      char v16 = *(_BYTE **)v75;
    }
    *(_DWORD *)__int128 buf = 136315138;
    *(void *)&uint8_t buf[4] = v16;
    _os_log_impl((void *)&_mh_execute_header, v13, OS_LOG_TYPE_DEFAULT, "Current Call(s): %s", buf, 0xCu);
    if (SBYTE3(v79) < 0) {
      operator delete(*(void **)v75);
    }
    __int128 v13 = (os_log_s *)qword_1008F7598;
  }

  if (os_log_type_enabled(v13, OS_LOG_TYPE_DEFAULT))
  {
    sub_10053C68C(&v61, (std::string *)v75);
    __int128 v17 = SBYTE3(v79) >= 0 ? v75 : *(_BYTE **)v75;
    *(_DWORD *)__int128 buf = 136315138;
    *(void *)&uint8_t buf[4] = v17;
    _os_log_impl((void *)&_mh_execute_header, v13, OS_LOG_TYPE_DEFAULT, "Filtered Call(s): %s", buf, 0xCu);
    if (SBYTE3(v79) < 0) {
      operator delete(*(void **)v75);
    }
  }

  sub_10046EA5C(a1, &v61, (_BYTE *)&v67 + 1, &v64, (BOOL *)&v67, &v71, &v66, &v65, v69, &__src);
  uint64_t v18 = (os_log_s *)qword_1008F7598;
  if (os_log_type_enabled((os_log_t)qword_1008F7598, OS_LOG_TYPE_DEFAULT))
  {
    sub_10053C68C(&v61, (std::string *)v75);
    if (SBYTE3(v79) >= 0) {
      __int16 v19 = v75;
    }
    else {
      __int16 v19 = *(_BYTE **)v75;
    }
    *(_DWORD *)__int128 buf = 136315138;
    *(void *)&uint8_t buf[4] = v19;
    _os_log_impl( (void *)&_mh_execute_header,  v18,  OS_LOG_TYPE_DEFAULT,  "Updating call status for call(s): %s",  buf,  0xCu);
    if (SBYTE3(v79) < 0) {
      operator delete(*(void **)v75);
    }
    uint64_t v18 = (os_log_s *)qword_1008F7598;
  }

  BOOL v20 = os_log_type_enabled(v18, OS_LOG_TYPE_DEFAULT);
  int v21 = v64;
  int v22 = v67;
  if (v20)
  {
    id v39 = v5;
    if ((_BYTE)v67) {
      uint64_t v23 = "yes";
    }
    else {
      uint64_t v23 = "no";
    }
    sub_1002064C4(&v65, buf);
    int v24 = v74;
    uint64_t v25 = *(_BYTE **)buf;
    sub_100206494(&v66, __p);
    char v26 = buf;
    if (v24 < 0) {
      char v26 = v25;
    }
    if (v54 >= 0) {
      char v27 = __p;
    }
    else {
      char v27 = (void **)__p[0];
    }
    if (v71) {
      unsigned int v28 = "yes";
    }
    else {
      unsigned int v28 = "no";
    }
    if (HIBYTE(v67)) {
      unsigned int v29 = "yes";
    }
    else {
      unsigned int v29 = "no";
    }
    *(_DWORD *)int v75 = 136447490;
    *(void *)&v75[4] = v23;
    __int16 v76 = 1024;
    int v77 = v21;
    __int16 v78 = 2082;
    int v79 = v26;
    __int16 v80 = 2082;
    BOOL v81 = v27;
    __int16 v82 = 2082;
    __int16 v83 = v28;
    __int16 v84 = 2082;
    __int128 v85 = v29;
    _os_log_impl( (void *)&_mh_execute_header,  v18,  OS_LOG_TYPE_DEFAULT,  "callPresent: %{public}s, callState: %d, callSetup: %{public}s, heldStatus: %{public}s, heldChanged: %{public}s, vi sualVoicemail: %{public}s",  v75,  0x3Au);
    if (v54 < 0) {
      operator delete(__p[0]);
    }
    id v5 = v39;
    if (v74 < 0) {
      operator delete(*(void **)buf);
    }
  }

  char v30 = 1;
  if (!v21 && !v22) {
    char v30 = HIBYTE(v67) != 0;
  }
  if (qword_1008D9250 != -1) {
    dispatch_once(&qword_1008D9250, &stru_10089A0D0);
  }
  sub_100518A58((uint64_t)off_1008D9248, v30);
  sub_100206774(v6, v66);
  sub_10020677C(v6, v65);
  sub_10053C460((int)v52);
  sub_1002068B4(v6, v52);
  *(void *)int v75 = v52;
  sub_1002077E0((void ***)v75);
  if (v22 != sub_1002065F4(v6))
  {
    sub_10047725C(v51, a1 + 824);
    sub_10046F114(a1, v51, v22);
    sub_10023BF24((uint64_t)v51, (void *)v51[1]);
    sub_1002065FC(v6, v22 != 0);
  }

  if (sub_100206648(v6))
  {
    sub_100206650(v6, 0);
    sub_1002065FC(v6, v22 != 0);
    if ((v65 - 1) > 2)
    {
      sub_100242F54((uint64_t)v72);
      j__usleep(0x1D4C0u);
    }

    else
    {
      sub_100206668(v6, 1);
      int v31 = operator new(0x18uLL);
      void v31[4] = 1;
      *(void *)int v31 = &off_100899ED8;
      *((void *)v31 + 2) = 400LL;
      uint64_t v32 = sub_100405058();
      sub_100405744(v32, v31);
      sub_100242F54((uint64_t)v72);
      j__usleep(dword_1008D99A0);
    }

    sub_100242ECC((uint64_t)v72);
    sub_100206660(v6, 0);
  }

  else if (HIBYTE(v67))
  {
    sub_1002065FC(v6, 1);
    sub_100206650(v6, 1);
    LOBYTE(v21) = v21 & 0xFE;
    unsigned __int8 v64 = v21;
    int v65 = 0;
    sub_10020677C(v6, 0);
    sub_10047725C(v50, a1 + 824);
    sub_10046F2E0(a1, v50, (void (*)(void, void))sub_10046F4A8);
    sub_10023BF24((uint64_t)v50, (void *)v50[1]);
  }

  BOOL v33 = sub_100206708(v6, 1);
  BOOL v34 = (v21 & 4) == 0 && v33;
  if (v34 || ((BOOL v35 = sub_100206708(v6, 2), (v21 & 8) == 0) ? (v36 = v35) : (v36 = 0), v36)) {
    sub_100206678(v6);
  }
  else {
    sub_100206728(v6, 0);
  }
  v75[0] = 0;
  sub_100242CA4(v75);
  sub_1000F0EC0((v22 | HIBYTE(v67)) != 0, v65, v66);
  sub_100242CD0(v75);
  if ((v21 & 4) != 0)
  {
    sub_10047725C(v49, a1 + 824);
    sub_10046F7DC(a1, v49, v65 | (v66 << 8) | 0x10000);
    sub_10023BF24((uint64_t)v49, (void *)v49[1]);
    if (!v22 && !sub_100206730(v6))
    {
      sub_10054A424(v48);
      else {
        std::string v47 = __src;
      }
      sub_1002066C4(v6, (uint64_t)v48, &v47, 1);
      sub_10054A428(v48);
      sub_10046F9B0(a1);
    }
  }

  else
  {
    if ((v21 & 8) != 0)
    {
      sub_10054A424(v46);
      else {
        std::string __dst = __src;
      }
      sub_1002066C4(v6, (uint64_t)v46, &__dst, 2);
      sub_10054A428(v46);
      sub_10046FB70(a1);
      sub_10047725C(v44, a1 + 824);
      unint64_t v37 = v44;
      sub_10046F7DC(a1, v44, v65 | (v66 << 8));
      goto LABEL_111;
    }

    if ((v21 & 1) != 0)
    {
      sub_10047725C(v43, a1 + 824);
      unint64_t v37 = v43;
      sub_10046FC4C( a1,  v43,  (v71 << 16) | ((-991146299 * ((unint64_t)(v62 - v61) >> 3) == 1) << 24) | (v66 << 8) | v65);
      goto LABEL_111;
    }

    if ((v21 & 2) != 0)
    {
      sub_10047725C(v42, a1 + 824);
      unint64_t v37 = v42;
      sub_10046F7DC( a1,  v42,  v65 | (v66 << 8) | ((-991146299 * ((unint64_t)(v62 - v61) >> 3) == 1) << 16));
      goto LABEL_111;
    }

    if (v22 && !v65)
    {
      sub_10047725C(v41, a1 + 824);
      unint64_t v37 = v41;
      sub_10046FC4C(a1, v41, (v66 << 8) | (v71 << 16) | v65 | 0x1000000);
LABEL_111:
      sub_10023BF24((uint64_t)v37, (void *)v37[1]);
      goto LABEL_112;
    }

    if (!v22 && !v65)
    {
      sub_10047725C(v40, a1 + 824);
      unint64_t v37 = v40;
      sub_10046FE18(a1, v40, v65);
      goto LABEL_111;
    }
  }

void sub_100464AF8( _Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, char a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20, uint64_t a21, uint64_t a22, uint64_t a23, uint64_t a24, uint64_t a25, uint64_t a26, uint64_t a27, uint64_t a28, void *a29, uint64_t a30, uint64_t a31, uint64_t a32, uint64_t a33, uint64_t a34, uint64_t a35, uint64_t a36, uint64_t a37, uint64_t a38, void *a39, uint64_t a40, uint64_t a41, uint64_t a42, uint64_t a43, uint64_t a44, uint64_t a45, uint64_t a46, uint64_t a47, uint64_t a48, uint64_t a49, uint64_t a50,uint64_t a51,uint64_t a52,uint64_t a53,uint64_t a54,uint64_t a55,uint64_t a56,uint64_t a57,uint64_t a58,uint64_t a59,uint64_t a60,uint64_t a61,uint64_t a62,uint64_t a63)
{
  *(void *)(v72 - 1sub_10023DF50(v3 + 76) = &a65;
  sub_1002077E0((void ***)(v72 - 176));
  *(void *)(v72 - 1sub_10023DF50(v3 + 76) = &a68;
  sub_1002077E0((void ***)(v72 - 176));
  *(void *)(v72 - 1sub_10023DF50(v3 + 76) = &a71;
  sub_1002077E0((void ***)(v72 - 176));
  if (SLOBYTE(STACK[0x22F]) < 0) {
    operator delete((void *)STACK[0x218]);
  }
  sub_10054A428(&STACK[0x230]);
  sub_100242FAC(v72 - 224);

  _Unwind_Resume(a1);
}

uint64_t sub_100464D30(uint64_t a1, uint64_t a2, uint64_t a3)
{
  id v5 = (os_log_s *)qword_1008F7598;
  if (os_log_type_enabled((os_log_t)qword_1008F7598, OS_LOG_TYPE_DEFAULT))
  {
    sub_1003CF00C(a2, __p);
    if (v9 >= 0) {
      uint64_t v6 = __p;
    }
    else {
      uint64_t v6 = (void **)__p[0];
    }
    *(_DWORD *)__int128 buf = 136446466;
    BOOL v11 = v6;
    __int16 v12 = 2082;
    uint64_t v13 = a3;
    _os_log_impl( (void *)&_mh_execute_header,  v5,  OS_LOG_TYPE_DEFAULT,  "Received set voice command external event for device %{public}s with value %{public}s",  buf,  0x16u);
    if (v9 < 0) {
      operator delete(__p[0]);
    }
  }

  return 0LL;
}

uint64_t sub_100464E1C(uint64_t a1, uint64_t a2)
{
  v90[0] = 0LL;
  v90[1] = 0LL;
  sub_100242F28((uint64_t)v90, a1 + 760);
  uint64_t v4 = (unsigned __int16 *)(a2 + 4);
  id v5 = (unsigned __int8 *)sub_1004615C4(a1, *(unsigned __int16 *)(a2 + 4));
  if (!v5)
  {
    if (*(_DWORD *)a2 >= 2u)
    {
      if (os_log_type_enabled((os_log_t)qword_1008F7598, OS_LOG_TYPE_ERROR)) {
        sub_100681D90();
      }
      LOBYTE(__p[0]) = 0;
      sub_100242CA4(__p);
      sub_1000EF578(*v4, 2701LL);
LABEL_28:
      __int16 v19 = __p;
      goto LABEL_29;
    }

    uint64_t v6 = *(void *)(a2 + 8);
    LODWORD(__p[0]) = *(_DWORD *)v6;
    WORD2(__p[0]) = *(_WORD *)(v6 + 4);
    if (!LOBYTE(__p[0]))
    {
      uint64_t v7 = 1LL;
      while (v7 != 6)
      {
        if (*((unsigned __int8 *)__p + v7++))
        {
          break;
        }
      }

      char v9 = (os_log_s *)qword_1008F7598;
      if (os_log_type_enabled((os_log_t)qword_1008F7598, OS_LOG_TYPE_FAULT)) {
        sub_100681D1C(v9, v10, v11);
      }
LABEL_10:
      uint64_t v21 = 1LL;
      do
      {
        if (v21 == 6) {
          goto LABEL_34;
        }
      }

      while (!*((unsigned __int8 *)__p + v21++));
      if ((unint64_t)(v21 - 2) >= 5)
      {
LABEL_34:
        if (os_log_type_enabled((os_log_t)qword_1008F7598, OS_LOG_TYPE_ERROR)) {
          sub_100681920();
        }
        buf[0] = 0;
        sub_100242CA4(buf);
        sub_1000EF578(*v4, 2701LL);
        __int16 v19 = buf;
LABEL_29:
        sub_100242CD8(v19);
        return sub_100242FAC((uint64_t)v90);
      }
    }

    if (qword_1008D5F50 != -1) {
      dispatch_once(&qword_1008D5F50, &stru_100899FD0);
    }
    uint64_t v12 = *(void *)(a2 + 8);
    __int16 v13 = *(_WORD *)(v12 + 4);
    *(_DWORD *)__int128 buf = *(_DWORD *)v12;
    *(_WORD *)unsigned __int8 v101 = v13;
    id v5 = (unsigned __int8 *)sub_1003FFEB0(off_1008D5F48, (uint64_t)buf, 1);
  }

  int v14 = *(_DWORD *)a2;
  switch(*(_DWORD *)a2)
  {
    case 0:
      int v44 = sub_100411064(a1, (uint64_t)v5);
      int v45 = (os_log_s *)qword_1008F7598;
      if (os_log_type_enabled((os_log_t)qword_1008F7598, OS_LOG_TYPE_DEFAULT))
      {
        if (v5)
        {
          sub_1003CF00C((uint64_t)v5, __p);
          int v46 = (void **)__p[0];
          std::string v47 = "denying";
          if ((SBYTE7(v94) & 0x80u) == 0) {
            int v46 = __p;
          }
          if (v44) {
            std::string v47 = "accepting";
          }
          *(_DWORD *)__int128 buf = 136446466;
          *(void *)unsigned __int8 v101 = v46;
          *(_WORD *)&v101[8] = 2082;
          *(void *)&v101[10] = v47;
          _os_log_impl( (void *)&_mh_execute_header,  v45,  OS_LOG_TYPE_DEFAULT,  "Received incoming handsfree connection request for device %{public}s - %{public}s request",  buf,  0x16u);
          if (SBYTE7(v94) < 0) {
            operator delete(__p[0]);
          }
        }

        else
        {
          __int16 v82 = "denying";
          if (v44) {
            __int16 v82 = "accepting";
          }
          *(_DWORD *)__int128 buf = 136446466;
          *(void *)unsigned __int8 v101 = "NULL";
          *(_WORD *)&v101[8] = 2082;
          *(void *)&v101[10] = v82;
          _os_log_impl( (void *)&_mh_execute_header,  v45,  OS_LOG_TYPE_DEFAULT,  "Received incoming handsfree connection request for device %{public}s - %{public}s request",  buf,  0x16u);
        }
      }

      uint64_t v83 = sub_1002E6E9C();
      else {
        int v84 = 0;
      }
      LOBYTE(v87[0]) = 0;
      sub_100242CA4(v87);
      int v85 = sub_1000F5664(*v4, v44);
      if (v85) {
        int v86 = 0;
      }
      else {
        int v86 = v84;
      }
      if (v86 == 1
        && sub_1001F6AD0((uint64_t)(v5 + 128))
        && os_log_type_enabled((os_log_t)qword_1008F7598, OS_LOG_TYPE_ERROR))
      {
        sub_1003CF00C((uint64_t)v5, __p);
        sub_100681A6C();
      }

      sub_100242CD0(v87);
      if (v85 && os_log_type_enabled((os_log_t)qword_1008F7598, OS_LOG_TYPE_ERROR)) {
        sub_1006819E4(v44);
      }
      if (v44) {
        sub_100410910(a1, (uint64_t)v5, 1);
      }
      __int16 v19 = v87;
      goto LABEL_29;
    case 1:
      if (*(void *)(a2 + 8))
      {
        uint64_t v48 = *(unsigned int *)(a2 + 16);
        __int16 v49 = (os_log_s *)qword_1008F7598;
        if ((_DWORD)v48)
        {
          if (os_log_type_enabled((os_log_t)qword_1008F7598, OS_LOG_TYPE_ERROR))
          {
            sub_1003CF00C((uint64_t)v5, buf);
            sub_100681AE0();
          }

          __int16 v50 = sub_100206524(a1 + 360);
          char v89 = 0;
          sub_100242CA4(&v89);
          __int16 v51 = sub_1000EF480(*v4);
          sub_100242CD0(&v89);
          if ((_DWORD)v48 == 1814 && (v50 & 0x400) != 0 && (v51 & 0x100) != 0)
          {
            uint64_t v99 = 0LL;
            __int128 v97 = 0u;
            __int128 v98 = 0u;
            __int128 v95 = 0u;
            __int128 v96 = 0u;
            *(_OWORD *)__int128 __p = 0u;
            __int128 v94 = 0u;
            if (sub_1003D9F10((uint64_t)v5, 1, 413, 1814, (uint64_t)__p))
            {
              int v52 = (os_log_s *)qword_1008F7598;
              if (os_log_type_enabled((os_log_t)qword_1008F7598, OS_LOG_TYPE_DEFAULT))
              {
                sub_1003CF00C((uint64_t)v5, v87);
                BOOL v53 = v88 >= 0 ? v87 : (void **)v87[0];
                *(_DWORD *)char v91 = 136315138;
                __int16 v92 = v53;
                _os_log_impl( (void *)&_mh_execute_header,  v52,  OS_LOG_TYPE_DEFAULT,  "Submitting contextual metric for event 'BT_HANDSFREE_TIMEOUT_SLC_BIND_RED_FLAG' for %s",  v91,  0xCu);
                if (v88 < 0) {
                  operator delete(v87[0]);
                }
              }

              uint64_t v54 = sub_1002E8D94();
              (*(void (**)(uint64_t, void **, void))(*(void *)v54 + 248LL))(v54, __p, v5[1316]);
            }
          }

          sub_100242CD8(&v89);
        }

        else
        {
          if (os_log_type_enabled((os_log_t)qword_1008F7598, OS_LOG_TYPE_DEFAULT))
          {
            sub_1003CF00C((uint64_t)v5, __p);
            float v73 = (SBYTE7(v94) & 0x80u) == 0 ? __p : (void **)__p[0];
            *(_DWORD *)__int128 buf = 136446210;
            *(void *)unsigned __int8 v101 = v73;
            _os_log_impl( (void *)&_mh_execute_header,  v49,  OS_LOG_TYPE_DEFAULT,  "Received SLC connection complete event for device %{public}s",  buf,  0xCu);
            if (SBYTE7(v94) < 0) {
              operator delete(__p[0]);
            }
          }

          sub_10045DAB4(a1, v5, *v4);
        }

        if (qword_1008D60B0 != -1) {
          dispatch_once(&qword_1008D60B0, &stru_100899F70);
        }
        int v74 = sub_1004317E0((uint64_t)off_1008D60A8, v48, 20000);
        sub_100410A5C(a1, (uint64_t)v5, v74);
        if (!(_DWORD)v48 && sub_100411018(a1) == 1 && sub_100206708(a1 + 360, 1))
        {
          int v75 = operator new(0x20uLL);
          sub_100476560((uint64_t)v75);
          uint64_t v76 = sub_100405058();
          sub_100405744(v76, v75);
        }
      }

      else if (os_log_type_enabled((os_log_t)qword_1008F7598, OS_LOG_TYPE_ERROR))
      {
        sub_100681AB4();
      }

      return sub_100242FAC((uint64_t)v90);
    case 2:
      int v23 = *(_DWORD *)(a2 + 8);
      int v24 = (os_log_s *)qword_1008F7598;
      if ((v23 & 0xFFFFFFFE) == 0x39E)
      {
        if (os_log_type_enabled((os_log_t)qword_1008F7598, OS_LOG_TYPE_DEFAULT))
        {
          if (v5)
          {
            sub_1003CF00C((uint64_t)v5, __p);
            if ((SBYTE7(v94) & 0x80u) == 0) {
              uint64_t v25 = __p;
            }
            else {
              uint64_t v25 = (void **)__p[0];
            }
            *(_DWORD *)__int128 buf = 136446210;
            *(void *)unsigned __int8 v101 = v25;
            _os_log_impl( (void *)&_mh_execute_header,  v24,  OS_LOG_TYPE_DEFAULT,  "Received handsfree disconnection event for device %{public}s",  buf,  0xCu);
            if (SBYTE7(v94) < 0) {
              operator delete(__p[0]);
            }
          }

          else
          {
            *(_DWORD *)__int128 buf = 136446210;
            *(void *)unsigned __int8 v101 = "NULL";
            _os_log_impl( (void *)&_mh_execute_header,  v24,  OS_LOG_TYPE_DEFAULT,  "Received handsfree disconnection event for device %{public}s",  buf,  0xCu);
          }
        }
      }

      else if (os_log_type_enabled((os_log_t)qword_1008F7598, OS_LOG_TYPE_ERROR))
      {
        if (v5)
        {
          sub_1003CF00C((uint64_t)v5, __p);
          sub_100681B6C();
        }

        else
        {
          sub_100681B28(buf, v23);
        }
      }

      sub_100463450(a1, *v4, v23);
      return sub_100242FAC((uint64_t)v90);
    case 3:
    case 4:
    case 5:
    case 6:
    case 0x11:
    case 0x12:
    case 0x1B:
    case 0x1C:
      sub_100466270(a1, a2);
      return sub_100242FAC((uint64_t)v90);
    case 8:
    case 9:
    case 0xF:
    case 0x16:
      uint64_t v15 = sub_10046853C(a1, a2);
      goto LABEL_21;
    case 0xA:
    case 0xB:
    case 0xC:
    case 0x13:
      uint64_t v15 = sub_100467F84(a1, (int *)a2);
      goto LABEL_21;
    case 0xD:
      char v26 = (os_log_s *)qword_1008F7598;
      if (os_log_type_enabled((os_log_t)qword_1008F7598, OS_LOG_TYPE_DEFAULT))
      {
        if (v5)
        {
          sub_1003CF00C((uint64_t)v5, __p);
          if ((SBYTE7(v94) & 0x80u) == 0) {
            char v27 = __p;
          }
          else {
            char v27 = (void **)__p[0];
          }
          *(_DWORD *)__int128 buf = 136446210;
          *(void *)unsigned __int8 v101 = v27;
          _os_log_impl( (void *)&_mh_execute_header,  v26,  OS_LOG_TYPE_DEFAULT,  "Received voice recognition event from device %{public}s",  buf,  0xCu);
          if (SBYTE7(v94) < 0) {
            operator delete(__p[0]);
          }
        }

        else
        {
          *(_DWORD *)__int128 buf = 136446210;
          *(void *)unsigned __int8 v101 = "NULL";
          _os_log_impl( (void *)&_mh_execute_header,  v26,  OS_LOG_TYPE_DEFAULT,  "Received voice recognition event from device %{public}s",  buf,  0xCu);
        }
      }

      sub_100242874(3LL);
      uint64_t v15 = sub_1004690A0(a1, *(unsigned __int16 *)(a2 + 4), *(unsigned __int8 *)(a2 + 8));
      goto LABEL_21;
    case 0xE:
      uint64_t v60 = (os_log_s *)qword_1008F7598;
      if (os_log_type_enabled((os_log_t)qword_1008F7598, OS_LOG_TYPE_DEFAULT))
      {
        if (v5)
        {
          sub_1003CF00C((uint64_t)v5, __p);
          if ((SBYTE7(v94) & 0x80u) == 0) {
            uint64_t v61 = __p;
          }
          else {
            uint64_t v61 = (void **)__p[0];
          }
          *(_DWORD *)__int128 buf = 136446210;
          *(void *)unsigned __int8 v101 = v61;
          _os_log_impl( (void *)&_mh_execute_header,  v60,  OS_LOG_TYPE_DEFAULT,  "Received unsupported handsfree event (voice tag retrieval) from device %{public}s",  buf,  0xCu);
          if (SBYTE7(v94) < 0) {
            operator delete(__p[0]);
          }
        }

        else
        {
          *(_DWORD *)__int128 buf = 136446210;
          *(void *)unsigned __int8 v101 = "NULL";
          _os_log_impl( (void *)&_mh_execute_header,  v60,  OS_LOG_TYPE_DEFAULT,  "Received unsupported handsfree event (voice tag retrieval) from device %{public}s",  buf,  0xCu);
        }
      }

      LOBYTE(__p[0]) = 0;
      sub_100242CA4(__p);
      if (sub_1000F061C(*v4, 0LL))
      {
        if (os_log_type_enabled((os_log_t)qword_1008F7598, OS_LOG_TYPE_ERROR)) {
          sub_100681BB4();
        }
        uint64_t v16 = 0LL;
      }

      else
      {
        uint64_t v16 = 255LL;
      }

      sub_100242CD8(__p);
      goto LABEL_22;
    case 0x10:
      unsigned int v28 = (os_log_s *)qword_1008F7598;
      if (os_log_type_enabled((os_log_t)qword_1008F7598, OS_LOG_TYPE_DEFAULT))
      {
        if (v5)
        {
          sub_1003CF00C((uint64_t)v5, __p);
          if ((SBYTE7(v94) & 0x80u) == 0) {
            unsigned int v29 = __p;
          }
          else {
            unsigned int v29 = (void **)__p[0];
          }
          *(_DWORD *)__int128 buf = 136446210;
          *(void *)unsigned __int8 v101 = v29;
          _os_log_impl( (void *)&_mh_execute_header,  v28,  OS_LOG_TYPE_DEFAULT,  "Received EC/NR disable event from device %{public}s",  buf,  0xCu);
          if (SBYTE7(v94) < 0) {
            operator delete(__p[0]);
          }
        }

        else
        {
          *(_DWORD *)__int128 buf = 136446210;
          *(void *)unsigned __int8 v101 = "NULL";
          _os_log_impl( (void *)&_mh_execute_header,  v28,  OS_LOG_TYPE_DEFAULT,  "Received EC/NR disable event from device %{public}s",  buf,  0xCu);
        }
      }

      uint64_t v15 = sub_100469060(a1, *v4);
      goto LABEL_21;
    case 0x14:
      char v30 = (os_log_s *)qword_1008F7598;
      if (os_log_type_enabled((os_log_t)qword_1008F7598, OS_LOG_TYPE_DEFAULT))
      {
        if (*(_BYTE *)(a2 + 8)) {
          int v31 = "enable";
        }
        else {
          int v31 = "disable";
        }
        if (v5)
        {
          sub_1003CF00C((uint64_t)v5, __p);
          if ((SBYTE7(v94) & 0x80u) == 0) {
            uint64_t v32 = __p;
          }
          else {
            uint64_t v32 = (void **)__p[0];
          }
          *(_DWORD *)__int128 buf = 136446466;
          *(void *)unsigned __int8 v101 = v31;
          *(_WORD *)&v101[8] = 2082;
          *(void *)&v101[10] = v32;
          _os_log_impl( (void *)&_mh_execute_header,  v30,  OS_LOG_TYPE_DEFAULT,  "Received call waiting %{public}s event from device %{public}s",  buf,  0x16u);
          if (SBYTE7(v94) < 0) {
            operator delete(__p[0]);
          }
        }

        else
        {
          *(_DWORD *)__int128 buf = 136446466;
          *(void *)unsigned __int8 v101 = v31;
          *(_WORD *)&v101[8] = 2082;
          *(void *)&v101[10] = "NULL";
          _os_log_impl( (void *)&_mh_execute_header,  v30,  OS_LOG_TYPE_DEFAULT,  "Received call waiting %{public}s event from device %{public}s",  buf,  0x16u);
        }
      }

      int v77 = *(unsigned __int8 *)(a2 + 8);
      __int16 v78 = sub_10045CF60(a1, *(unsigned __int16 *)(a2 + 4));
      if (v78)
      {
        sub_10020741C((uint64_t)(v78 + 50), v77 != 0);
        uint64_t v16 = 255LL;
      }

      else
      {
        uint64_t v16 = 0LL;
      }

      goto LABEL_22;
    case 0x15:
      BOOL v33 = (os_log_s *)qword_1008F7598;
      if (os_log_type_enabled((os_log_t)qword_1008F7598, OS_LOG_TYPE_ERROR)) {
        sub_100681C14(a2, v33);
      }
      LOBYTE(__p[0]) = 0;
      sub_100242CA4(__p);
      sub_1000F5D14(*(unsigned __int16 *)(a2 + 4), *(_DWORD *)(a2 + 12));
      goto LABEL_28;
    case 0x17:
      uint64_t v62 = (os_log_s *)qword_1008F7598;
      if (os_log_type_enabled((os_log_t)qword_1008F7598, OS_LOG_TYPE_DEFAULT))
      {
        if (v5)
        {
          sub_1003CF00C((uint64_t)v5, __p);
          if ((SBYTE7(v94) & 0x80u) == 0) {
            uint64_t v63 = __p;
          }
          else {
            uint64_t v63 = (void **)__p[0];
          }
          *(_DWORD *)__int128 buf = 136446210;
          *(void *)unsigned __int8 v101 = v63;
          _os_log_impl( (void *)&_mh_execute_header,  v62,  OS_LOG_TYPE_DEFAULT,  "Received network operator request event from device %{public}s",  buf,  0xCu);
          if (SBYTE7(v94) < 0) {
            operator delete(__p[0]);
          }
        }

        else
        {
          *(_DWORD *)__int128 buf = 136446210;
          *(void *)unsigned __int8 v101 = "NULL";
          _os_log_impl( (void *)&_mh_execute_header,  v62,  OS_LOG_TYPE_DEFAULT,  "Received network operator request event from device %{public}s",  buf,  0xCu);
        }
      }

      uint64_t v15 = sub_100468DE8(a1, *v4);
      goto LABEL_21;
    case 0x18:
      BOOL v34 = (os_log_s *)qword_1008F7598;
      BOOL v35 = os_log_type_enabled((os_log_t)qword_1008F7598, OS_LOG_TYPE_DEFAULT);
      if (v35)
      {
        if (v5)
        {
          sub_1003CF00C((uint64_t)v5, __p);
          if ((SBYTE7(v94) & 0x80u) == 0) {
            BOOL v36 = __p;
          }
          else {
            BOOL v36 = (void **)__p[0];
          }
          *(_DWORD *)__int128 buf = 136446210;
          *(void *)unsigned __int8 v101 = v36;
          _os_log_impl( (void *)&_mh_execute_header,  v34,  OS_LOG_TYPE_DEFAULT,  "Received subscriber number request event from device %{public}s",  buf,  0xCu);
          if (SBYTE7(v94) < 0) {
            operator delete(__p[0]);
          }
        }

        else
        {
          *(_DWORD *)__int128 buf = 136446210;
          *(void *)unsigned __int8 v101 = "NULL";
          _os_log_impl( (void *)&_mh_execute_header,  v34,  OS_LOG_TYPE_DEFAULT,  "Received subscriber number request event from device %{public}s",  buf,  0xCu);
        }
      }

      uint64_t v15 = sub_100468B74(v35, *v4);
      goto LABEL_21;
    case 0x19:
      uint64_t v64 = qword_1008F7598;
      if (!os_log_type_enabled((os_log_t)qword_1008F7598, OS_LOG_TYPE_DEFAULT)) {
        goto LABEL_204;
      }
      if (!v5)
      {
        *(_DWORD *)__int128 buf = 136446210;
        *(void *)unsigned __int8 v101 = "NULL";
        int v79 = "Received unsupported handsfree event (response and hold query) from device %{public}s";
        goto LABEL_202;
      }

      sub_1003CF00C((uint64_t)v5, __p);
      if ((SBYTE7(v94) & 0x80u) == 0) {
        int v65 = __p;
      }
      else {
        int v65 = (void **)__p[0];
      }
      *(_DWORD *)__int128 buf = 136446210;
      *(void *)unsigned __int8 v101 = v65;
      uint64_t v57 = "Received unsupported handsfree event (response and hold query) from device %{public}s";
      goto LABEL_152;
    case 0x1A:
      uint64_t v64 = qword_1008F7598;
      if (!os_log_type_enabled((os_log_t)qword_1008F7598, OS_LOG_TYPE_DEFAULT)) {
        goto LABEL_204;
      }
      if (!v5)
      {
        *(_DWORD *)__int128 buf = 136446210;
        *(void *)unsigned __int8 v101 = "NULL";
        int v79 = "Received unsupported handsfree event (response and hold) from device %{public}s";
LABEL_202:
        __int16 v80 = (os_log_s *)v64;
        uint32_t v81 = 12;
        goto LABEL_203;
      }

      sub_1003CF00C((uint64_t)v5, __p);
      if ((SBYTE7(v94) & 0x80u) == 0) {
        int v66 = __p;
      }
      else {
        int v66 = (void **)__p[0];
      }
      *(_DWORD *)__int128 buf = 136446210;
      *(void *)unsigned __int8 v101 = v66;
      uint64_t v57 = "Received unsupported handsfree event (response and hold) from device %{public}s";
LABEL_152:
      int v58 = (os_log_s *)v64;
      uint32_t v59 = 12;
      goto LABEL_153;
    case 0x1D:
      unint64_t v37 = (os_log_s *)qword_1008F7598;
      if (os_log_type_enabled((os_log_t)qword_1008F7598, OS_LOG_TYPE_DEFAULT))
      {
        if (v5)
        {
          sub_1003CF00C((uint64_t)v5, __p);
          if ((SBYTE7(v94) & 0x80u) == 0) {
            unsigned int v38 = __p;
          }
          else {
            unsigned int v38 = (void **)__p[0];
          }
          *(_DWORD *)__int128 buf = 136446210;
          *(void *)unsigned __int8 v101 = v38;
          _os_log_impl( (void *)&_mh_execute_header,  v37,  OS_LOG_TYPE_DEFAULT,  "Received HF indicator event from device %{public}s",  buf,  0xCu);
          if (SBYTE7(v94) < 0) {
            operator delete(__p[0]);
          }
        }

        else
        {
          *(_DWORD *)__int128 buf = 136446210;
          *(void *)unsigned __int8 v101 = "NULL";
          _os_log_impl( (void *)&_mh_execute_header,  v37,  OS_LOG_TYPE_DEFAULT,  "Received HF indicator event from device %{public}s",  buf,  0xCu);
        }
      }

      uint64_t v15 = sub_1004692F0(a1, a2);
LABEL_21:
      uint64_t v16 = v15;
      goto LABEL_22;
    case 0x1E:
      id v39 = (os_log_s *)qword_1008F7598;
      if (os_log_type_enabled((os_log_t)qword_1008F7598, OS_LOG_TYPE_DEFAULT))
      {
        sub_1003CF00C((uint64_t)v5, __p);
        int v40 = (SBYTE7(v94) & 0x80u) == 0 ? __p : (void **)__p[0];
        *(_DWORD *)__int128 buf = 136446210;
        *(void *)unsigned __int8 v101 = v40;
        _os_log_impl( (void *)&_mh_execute_header,  v39,  OS_LOG_TYPE_DEFAULT,  "Received AOS Setup Complete from device %{public}s",  buf,  0xCu);
        if (SBYTE7(v94) < 0) {
          operator delete(__p[0]);
        }
      }

      uint64_t v41 = sub_10012D890((uint64_t)(v5 + 128));
      uint64_t v42 = sub_10045D894(a1, (uint64_t)v5);
      switch((_DWORD)v42)
      {
        case 0x7F:
          unsigned __int8 v67 = 0;
          int v68 = 60;
          int v69 = 4;
          int v70 = 12;
          int v71 = 60;
LABEL_162:
          sub_10045D40C(a1, 0, *v4, v41, v70, v69, v68, v71, v67);
          return sub_100242FAC((uint64_t)v90);
        case 0x81:
          unsigned __int8 v67 = 3;
          int v71 = 360;
          int v68 = 240;
          int v69 = 6;
          int v70 = 24;
          goto LABEL_162;
        case 0x82:
          int v43 = sub_10045CF60(a1, *v4);
          *((_WORD *)v43 + 286) = 0;
          v43[72] = 0LL;
          sub_10045D40C(a1, 0, *v4, v41, 24, 6, 240, 360, 3u);
          break;
        default:
          uint64_t v72 = (os_log_s *)qword_1008F7598;
          if (os_log_type_enabled((os_log_t)qword_1008F7598, OS_LOG_TYPE_ERROR)) {
            sub_100681C94(v42, v72);
          }
          break;
      }

      return sub_100242FAC((uint64_t)v90);
    default:
      uint64_t v55 = qword_1008F7598;
      if (!os_log_type_enabled((os_log_t)qword_1008F7598, OS_LOG_TYPE_DEFAULT)) {
        goto LABEL_204;
      }
      if (v5)
      {
        sub_1003CF00C((uint64_t)v5, __p);
        if ((SBYTE7(v94) & 0x80u) == 0) {
          int v56 = __p;
        }
        else {
          int v56 = (void **)__p[0];
        }
        *(_DWORD *)__int128 buf = 67109378;
        *(_DWORD *)unsigned __int8 v101 = v14;
        *(_WORD *)&v101[4] = 2082;
        *(void *)&v101[6] = v56;
        uint64_t v57 = "Received unsupported handsfree event (%d) from device %{public}s";
        int v58 = (os_log_s *)v55;
        uint32_t v59 = 18;
LABEL_153:
        _os_log_impl((void *)&_mh_execute_header, v58, OS_LOG_TYPE_DEFAULT, v57, buf, v59);
        if (SBYTE7(v94) < 0) {
          operator delete(__p[0]);
        }
      }

      else
      {
        *(_DWORD *)__int128 buf = 67109378;
        *(_DWORD *)unsigned __int8 v101 = v14;
        *(_WORD *)&v101[4] = 2082;
        *(void *)&v101[6] = "NULL";
        int v79 = "Received unsupported handsfree event (%d) from device %{public}s";
        __int16 v80 = (os_log_s *)v55;
        uint32_t v81 = 18;
LABEL_203:
        _os_log_impl((void *)&_mh_execute_header, v80, OS_LOG_TYPE_DEFAULT, v79, buf, v81);
      }

LABEL_204:
      uint64_t v16 = 4LL;
LABEL_22:
      LOBYTE(__p[0]) = 0;
      sub_100242CA4(__p);
      unsigned int v17 = *v4;
      if ((_DWORD)v16 == 255) {
        int v18 = sub_1000EF578(v17, 0LL);
      }
      else {
        int v18 = sub_1000EF604(v17, 2707, v16);
      }
      if (v18 && os_log_type_enabled((os_log_t)qword_1008F7598, OS_LOG_TYPE_ERROR)) {
        sub_100681984();
      }
      goto LABEL_28;
  }

void sub_1004660FC( _Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, int a14, __int16 a15, char a16, char a17, char a18)
{
}

void sub_100466270(uint64_t a1, uint64_t a2)
{
  uint64_t v4 = sub_10045CF60(a1, *(unsigned __int16 *)(a2 + 4));
  uint64_t v5 = (uint64_t)(v4 + 50);
  uint64_t v6 = sub_1002073AC((uint64_t)(v4 + 50));
  uint64_t v7 = v6;
  int v8 = *(_DWORD *)a2;
  if (*(int *)a2 <= 16)
  {
    int v9 = v8 - 3;
    int v8 = a1 + 360;
    switch(v9)
    {
      case 0:
        uint64_t v10 = (os_log_s *)qword_1008F7598;
        if (os_log_type_enabled((os_log_t)qword_1008F7598, OS_LOG_TYPE_DEFAULT))
        {
          if (v7)
          {
            sub_1003CF00C(v7, __p);
            if (SHIBYTE(v125[0]) >= 0) {
              uint64_t v11 = __p;
            }
            else {
              uint64_t v11 = (void **)__p[0];
            }
            *(_DWORD *)__int128 buf = 136446210;
            *(void *)&uint8_t buf[4] = v11;
            _os_log_impl( (void *)&_mh_execute_header,  v10,  OS_LOG_TYPE_DEFAULT,  "Received audio connection request event from device %{public}s",  buf,  0xCu);
            if (SHIBYTE(v125[0]) < 0) {
              operator delete(__p[0]);
            }
          }

          else
          {
            *(_DWORD *)__int128 buf = 136446210;
            *(void *)&uint8_t buf[4] = "NULL";
            _os_log_impl( (void *)&_mh_execute_header,  v10,  OS_LOG_TYPE_DEFAULT,  "Received audio connection request event from device %{public}s",  buf,  0xCu);
          }
        }

        sub_1002073DC(v5, 3);
        uint64_t v132 = 0LL;
        __int128 v131 = 0u;
        memset(v130, 0, sizeof(v130));
        __int128 v128 = 0u;
        __int128 v129 = 0u;
        __int128 v127 = 0u;
        *(_OWORD *)int v125 = 0u;
        __int128 v126 = 0u;
        *(_OWORD *)__int128 __p = 0u;
        sub_100532DC0((uint64_t)__p + 1);
        BYTE2(v125[0]) = 0;
        BYTE4(v125[0]) = 0;
        BYTE2(v127) = 0;
        BYTE4(v127) = 0;
        HIDWORD(v130[2]) = 0;
        __int128 v126 = 0uLL;
        v125[1] = 0LL;
        LOBYTE(v127) = 0;
        __int128 v128 = 0uLL;
        *((void *)&v127 + 1) = 0LL;
        LOBYTE(v129) = 0;
        v130[0] = 0LL;
        v130[1] = 0LL;
        *((void *)&v129 + 1) = 0LL;
        *(_DWORD *)((char *)&v130[1] + 7) = 0;
        LOBYTE(v130[3]) = 1;
        BYTE2(v1sub_100242FAC(v1 - 32) = 0;
        *(void *)((char *)&v130[3] + 6) = 0LL;
        *(void *)((char *)&v130[3] + 1) = 0LL;
        __int128 v131 = 0uLL;
        v130[5] = 0LL;
        LOBYTE(v1sub_100242FAC(v1 - 32) = 0;
        BOOL v68 = sub_1003D2408(v7, (uint64_t)__p);
        if (BYTE1(v130[3])) {
          BOOL v69 = v68;
        }
        else {
          BOOL v69 = 0;
        }
        if (v69 && sub_1002067C0(a1 + 360))
        {
          int v70 = (os_log_s *)qword_1008F7598;
          if (os_log_type_enabled((os_log_t)qword_1008F7598, OS_LOG_TYPE_DEFAULT))
          {
            *(_WORD *)__int128 buf = 0;
            _os_log_impl( (void *)&_mh_execute_header,  v70,  OS_LOG_TYPE_DEFAULT,  "Hack for Mercedes kicking in... auto-accepting then pulling back audio",  buf,  2u);
          }

          sub_10020757C(v5, 1);
          j__usleep(0x2710u);
          buf[0] = 0;
          sub_100242CA4(buf);
          int v71 = sub_1000F14F0(*(unsigned __int16 *)(a2 + 4), 1);
          sub_100242CD0(buf);
LABEL_134:
          sub_100242CD8(buf);
          goto LABEL_214;
        }

        if (sub_100206648(a1 + 360))
        {
          uint64_t v72 = (os_log_s *)qword_1008F7598;
          if (os_log_type_enabled((os_log_t)qword_1008F7598, OS_LOG_TYPE_DEFAULT))
          {
            *(_WORD *)__int128 buf = 0;
            _os_log_impl( (void *)&_mh_execute_header,  v72,  OS_LOG_TYPE_DEFAULT,  "Denying audio request as we are in a virtual call",  buf,  2u);
          }

          buf[0] = 0;
          sub_100242CA4(buf);
          int v71 = sub_1000F14F0(*(unsigned __int16 *)(a2 + 4), 0);
          sub_100242CD0(buf);
          goto LABEL_134;
        }

        if ((sub_1002065F4(a1 + 360) & 1) != 0
          || sub_1002065CC(a1 + 360)
          || sub_1002065D4(a1 + 360)
          || sub_1002065BC(a1 + 360))
        {
          int v74 = (os_log_s *)qword_1008F7598;
          if (os_log_type_enabled((os_log_t)qword_1008F7598, OS_LOG_TYPE_DEFAULT))
          {
            if (v7)
            {
              sub_1003CF00C(v7, buf);
              if (v121 >= 0) {
                int v75 = buf;
              }
              else {
                int v75 = *(const char **)buf;
              }
              *(_DWORD *)char v122 = 136446210;
              unsigned int v123 = v75;
              _os_log_impl( (void *)&_mh_execute_header,  v74,  OS_LOG_TYPE_DEFAULT,  "Call is present, notify CoreAudio to accept audio request from device %{public}s",  v122,  0xCu);
              if (v121 < 0) {
                operator delete(*(void **)buf);
              }
            }

            else
            {
              *(_DWORD *)char v122 = 136446210;
              unsigned int v123 = "NULL";
              _os_log_impl( (void *)&_mh_execute_header,  v74,  OS_LOG_TYPE_DEFAULT,  "Call is present, notify CoreAudio to accept audio request from device %{public}s",  v122,  0xCu);
            }
          }

          sub_100501F98((uint64_t)v4, 1, 0);
          int v71 = 0;
        }

        else
        {
          uint64_t v108 = (os_log_s *)qword_1008F7598;
          if (os_log_type_enabled((os_log_t)qword_1008F7598, OS_LOG_TYPE_DEFAULT))
          {
            if (v7)
            {
              sub_1003CF00C(v7, buf);
              if (v121 >= 0) {
                uint64_t v109 = buf;
              }
              else {
                uint64_t v109 = *(const char **)buf;
              }
              *(_DWORD *)char v122 = 136446210;
              unsigned int v123 = v109;
              _os_log_impl( (void *)&_mh_execute_header,  v108,  OS_LOG_TYPE_DEFAULT,  "We're not in a call, rejecting audio request from device %{public}s",  v122,  0xCu);
              if (v121 < 0) {
                operator delete(*(void **)buf);
              }
            }

            else
            {
              *(_DWORD *)char v122 = 136446210;
              unsigned int v123 = "NULL";
              _os_log_impl( (void *)&_mh_execute_header,  v108,  OS_LOG_TYPE_DEFAULT,  "We're not in a call, rejecting audio request from device %{public}s",  v122,  0xCu);
            }
          }

          sub_100469734(a1, v7);
          sub_1002073DC(v5, 0);
          int v71 = 0;
        }

LABEL_214:
        if (SHIBYTE(v130[1]) < 0) {
          operator delete(*((void **)&v129 + 1));
        }
        if (SHIBYTE(v128) < 0) {
          operator delete(*((void **)&v127 + 1));
        }
        if (SHIBYTE(v126) < 0) {
          operator delete(v125[1]);
        }
        nullsub_63((char *)__p + 1, v73);
        if (v71) {
          break;
        }
        return;
      case 1:
        BOOL v34 = (os_log_s *)qword_1008F7598;
        if (os_log_type_enabled((os_log_t)qword_1008F7598, OS_LOG_TYPE_DEFAULT))
        {
          if (v7)
          {
            sub_1003CF00C(v7, __p);
            if (SHIBYTE(v125[0]) >= 0) {
              BOOL v35 = __p;
            }
            else {
              BOOL v35 = (void **)__p[0];
            }
            *(_DWORD *)__int128 buf = 136446210;
            *(void *)&uint8_t buf[4] = v35;
            _os_log_impl( (void *)&_mh_execute_header,  v34,  OS_LOG_TYPE_DEFAULT,  "Received audio codec connection request event from device %{public}s",  buf,  0xCu);
            if (SHIBYTE(v125[0]) < 0) {
              operator delete(__p[0]);
            }
          }

          else
          {
            *(_DWORD *)__int128 buf = 136446210;
            *(void *)&uint8_t buf[4] = "NULL";
            _os_log_impl( (void *)&_mh_execute_header,  v34,  OS_LOG_TYPE_DEFAULT,  "Received audio codec connection request event from device %{public}s",  buf,  0xCu);
          }
        }

        sub_1002073DC(v5, 4);
        if (sub_100206648(a1 + 360))
        {
          __int16 v80 = (os_log_s *)qword_1008F7598;
          if (os_log_type_enabled((os_log_t)qword_1008F7598, OS_LOG_TYPE_DEFAULT))
          {
            LOWORD(__p[0]) = 0;
            _os_log_impl( (void *)&_mh_execute_header,  v80,  OS_LOG_TYPE_DEFAULT,  "Denying audio request as we are in a virtual call",  (uint8_t *)__p,  2u);
          }

          goto LABEL_158;
        }

        if ((sub_1002065F4(a1 + 360) & 1) != 0
          || sub_1002065CC(a1 + 360)
          || sub_1002065D4(a1 + 360)
          || sub_1002065BC(a1 + 360))
        {
          uint32_t v81 = (os_log_s *)qword_1008F7598;
          if (os_log_type_enabled((os_log_t)qword_1008F7598, OS_LOG_TYPE_DEFAULT))
          {
            if (v7)
            {
              sub_1003CF00C(v7, __p);
              if (SHIBYTE(v125[0]) >= 0) {
                __int16 v82 = __p;
              }
              else {
                __int16 v82 = (void **)__p[0];
              }
              *(_DWORD *)__int128 buf = 136446210;
              *(void *)&uint8_t buf[4] = v82;
              _os_log_impl( (void *)&_mh_execute_header,  v81,  OS_LOG_TYPE_DEFAULT,  "Call is present, notify CoreAudio to accept audio request from device %{public}s",  buf,  0xCu);
              if (SHIBYTE(v125[0]) < 0) {
                operator delete(__p[0]);
              }
            }

            else
            {
              *(_DWORD *)__int128 buf = 136446210;
              *(void *)&uint8_t buf[4] = "NULL";
              _os_log_impl( (void *)&_mh_execute_header,  v81,  OS_LOG_TYPE_DEFAULT,  "Call is present, notify CoreAudio to accept audio request from device %{public}s",  buf,  0xCu);
            }
          }

          LOBYTE(__p[0]) = 0;
          sub_100242CA4(__p);
          int v77 = sub_1000EF578(*(unsigned __int16 *)(a2 + 4), 0LL);
          sub_100242CD0(__p);
          sub_100501F98((uint64_t)v4, 1, v77);
          goto LABEL_210;
        }

        uint64_t v106 = (os_log_s *)qword_1008F7598;
        if (os_log_type_enabled((os_log_t)qword_1008F7598, OS_LOG_TYPE_DEFAULT))
        {
          if (v7)
          {
            sub_1003CF00C(v7, __p);
            if (SHIBYTE(v125[0]) >= 0) {
              uint64_t v107 = __p;
            }
            else {
              uint64_t v107 = (void **)__p[0];
            }
            *(_DWORD *)__int128 buf = 136446210;
            *(void *)&uint8_t buf[4] = v107;
            _os_log_impl( (void *)&_mh_execute_header,  v106,  OS_LOG_TYPE_DEFAULT,  "We're not in a call, rejecting audio request from device %{public}s",  buf,  0xCu);
            if (SHIBYTE(v125[0]) < 0) {
              operator delete(__p[0]);
            }
          }

          else
          {
            *(_DWORD *)__int128 buf = 136446210;
            *(void *)&uint8_t buf[4] = "NULL";
            _os_log_impl( (void *)&_mh_execute_header,  v106,  OS_LOG_TYPE_DEFAULT,  "We're not in a call, rejecting audio request from device %{public}s",  buf,  0xCu);
          }
        }

        sub_100469734(a1, v7);
        sub_1002073DC(v5, 0);
        return;
      case 2:
        if (sub_100207584(v5))
        {
          j__usleep(0x4E20u);
          LOBYTE(__p[0]) = 0;
          sub_100242CA4(__p);
          int v28 = sub_1000F604C(*(unsigned __int16 *)(a2 + 4));
          sub_100242CD0(__p);
          if (v28 && os_log_type_enabled((os_log_t)qword_1008F7598, OS_LOG_TYPE_ERROR)) {
            sub_100681E60();
          }
          char v27 = __p;
          goto LABEL_30;
        }

        int v115 = *(_DWORD *)(a2 + 8);
        uint64_t v39 = sub_100206B80(a1 + 360);
        uint64_t v113 = a1 + 360;
        if (v39)
        {
          uint64_t v40 = sub_100206B80(a1 + 360);
          int v41 = sub_1002069E0(v40);
        }

        else
        {
          int v41 = 0;
        }

        int v112 = *(unsigned __int16 *)(a2 + 4);
        uint64_t v83 = (os_log_s *)qword_1008F7598;
        if (v4 && !v115 && v7)
        {
          if (os_log_type_enabled((os_log_t)qword_1008F7598, OS_LOG_TYPE_DEFAULT))
          {
            sub_1003CF00C(v7, __p);
            int v84 = SHIBYTE(v125[0]) >= 0 ? __p : (void **)__p[0];
            *(_DWORD *)__int128 buf = 136446210;
            *(void *)&uint8_t buf[4] = v84;
            _os_log_impl( (void *)&_mh_execute_header,  v83,  OS_LOG_TYPE_DEFAULT,  "Received voice audio connected event for device %{public}s",  buf,  0xCu);
            if (SHIBYTE(v125[0]) < 0) {
              operator delete(__p[0]);
            }
          }

          sub_1002073DC(v5, 5);
          if (v39)
          {
            int v85 = (os_log_s *)qword_1008F7598;
            if (os_log_type_enabled((os_log_t)qword_1008F7598, OS_LOG_TYPE_DEFAULT))
            {
              LODWORD(__p[0]) = 67109376;
              HIDWORD(__p[0]) = v41;
              LOWORD(__p[1]) = 1024;
              *(_DWORD *)((char *)&__p[1] + 2) = v112;
              _os_log_impl( (void *)&_mh_execute_header,  v85,  OS_LOG_TYPE_DEFAULT,  "A route change was pending on hfpHandle %d and we got an audio connected event on hfpHandle %d, clearing pending route change",  (uint8_t *)__p,  0xEu);
            }

            sub_100206390(v113);
          }

          sub_100207554(v5, 1);
          uint64_t v86 = *(unsigned __int16 *)(v7 + 132);
          uint64_t v87 = *(unsigned int *)(v7 + 128);
          uint64_t v88 = sub_1002E6E9C();
          uint64_t v89 = sub_1003D0268(v7);
          (*(void (**)(uint64_t, uint64_t, uint64_t, uint64_t, uint64_t, uint64_t, uint64_t, void))(*(void *)v88 + 72LL))( v88,  (v87 | (v86 << 32)) & 0xFFFFFFFFFFFFLL,  v89,  1LL,  1LL,  1LL,  1LL,  0LL);
          *(_DWORD *)(v7 + 1320) |= 1u;
          *(_BYTE *)(v7 + 136sub_100414D2C(qword_1008F72C0, 0) = 0;
          __p[0] = 0LL;
          sub_1000B0400((uint64_t)__p);
          v119.n128_u64[0] = SLODWORD(__p[0]);
          v119.n128_u64[1] = SWORD2(__p[0]);
          sub_10020777C(v5, &v119);
          uint64_t v90 = sub_1002073AC(v5);
          sub_100411948(a1, v90, 101, 0);
          sub_100501F98((uint64_t)v4, 1, 0);
          sub_1004694A4(a1, *(unsigned __int16 *)(a2 + 4));
          if (qword_1008D9250 != -1) {
            dispatch_once(&qword_1008D9250, &stru_10089A0D0);
          }
          sub_100518A58((uint64_t)off_1008D9248, 1);
          if (qword_1008D6198 != -1) {
            dispatch_once(&qword_1008D6198, &stru_10089A0F0);
          }
          sub_100448A40( (uint64_t)off_1008D6190,  1,  ((unint64_t)*(unsigned __int8 *)(v7 + 128) << 40) | ((unint64_t)*(unsigned __int8 *)(v7 + 129) << 32) | ((unint64_t)*(unsigned __int8 *)(v7 + 130) << 24) | ((unint64_t)*(unsigned __int8 *)(v7 + 131) << 16) | ((unint64_t)*(unsigned __int8 *)(v7 + 132) << 8) | *(unsigned __int8 *)(v7 + 133));
          uint64_t v91 = sub_1002073AC(v5);
          __int16 v92 = sub_1002073A4(v5);
          sub_10046981C((os_unfair_lock_s *)a1, v91, v92, 1);
        }

        else
        {
          if (os_log_type_enabled((os_log_t)qword_1008F7598, OS_LOG_TYPE_ERROR))
          {
            if (v7)
            {
              sub_1003CF00C(v7, __p);
              if (SHIBYTE(v125[0]) >= 0) {
                int v110 = __p;
              }
              else {
                int v110 = (void **)__p[0];
              }
              *(_DWORD *)__int128 buf = 136446466;
              *(void *)&uint8_t buf[4] = v110;
              *(_WORD *)&_BYTE buf[12] = 1024;
              *(_DWORD *)&_BYTE buf[14] = v115;
              _os_log_error_impl( (void *)&_mh_execute_header,  v83,  OS_LOG_TYPE_ERROR,  "Received audio connection failure event for device %{public}s with result %{bluetooth:OI_STATUS}u",  buf,  0x12u);
              if (SHIBYTE(v125[0]) < 0) {
                operator delete(__p[0]);
              }
            }

            else
            {
              sub_100681EC0(buf, v115);
            }
          }

          sub_1004698B8();
          sub_1002073DC(v5, 0);
          ++*(_BYTE *)(v7 + 1360);
          uint64_t v93 = sub_1002073AC(v5);
          if (qword_1008D60B0 != -1) {
            dispatch_once(&qword_1008D60B0, &stru_100899F70);
          }
          int v94 = sub_1004317E0((uint64_t)off_1008D60A8, *(unsigned int *)(a2 + 8), 10000);
          sub_100411948(a1, v93, 101, v94);
          if (v39 && v41 == v112)
          {
            __int128 v95 = (os_log_s *)qword_1008F7598;
            if (os_log_type_enabled((os_log_t)qword_1008F7598, OS_LOG_TYPE_DEFAULT))
            {
              LODWORD(__p[0]) = 67109376;
              HIDWORD(__p[0]) = v41;
              LOWORD(__p[1]) = 1024;
              *(_DWORD *)((char *)&__p[1] + 2) = v112;
              _os_log_impl( (void *)&_mh_execute_header,  v95,  OS_LOG_TYPE_DEFAULT,  "A route change to hfpHandle %d was pending and failed, clearing pending route change on hfpHandle %d",  (uint8_t *)__p,  0xEu);
            }

            sub_100206390(v113);
          }

          uint64_t v114 = *(unsigned __int8 *)(v7 + 128);
          uint64_t v96 = *(unsigned __int8 *)(v7 + 129);
          uint64_t v97 = *(unsigned __int8 *)(v7 + 130);
          uint64_t v98 = *(unsigned __int8 *)(v7 + 131);
          uint64_t v99 = *(unsigned __int8 *)(v7 + 132);
          uint64_t v100 = *(unsigned __int8 *)(v7 + 133);
          uint64_t v101 = sub_1002E6E9C();
          uint64_t v102 = sub_1003D0268(v7);
          uint64_t v103 = (*(uint64_t (**)(uint64_t, unint64_t, uint64_t, uint64_t, void, void, uint64_t, void))(*(void *)v101 + 72LL))( v101,  ((unint64_t)v96 << 8) | ((unint64_t)v97 << 16) | ((unint64_t)v98 << 24) | (v99 << 32) | (v100 << 40) | v114,  v102,  1LL,  0LL,  0LL,  1LL,  0LL);
          sub_10046992C(v103, (v114 << 40) | (v96 << 32) | (v97 << 24) | (v98 << 16) | (v99 << 8) | v100, 0);
          sub_100469A5C(a1, *(unsigned __int16 *)(a2 + 4), 0, v115);
          int v104 = sub_1003D0268(v7);
          if (sub_10020754C(v5) && (v104 == 22 || v104 == 17))
          {
            uint64_t v105 = sub_100207554(v5, 0);
            sub_100460F58(v105, *(_WORD *)(a2 + 4), 0x64u, 0);
          }
        }

        return;
      case 3:
        sub_1002073B4(v5, 0LL);
        sub_1002075CC(v5, 0);
        sub_1002075DC(v5, 0);
        if (sub_100207584(v5))
        {
          BOOL v36 = (os_log_s *)qword_1008F7598;
          if (os_log_type_enabled((os_log_t)qword_1008F7598, OS_LOG_TYPE_DEFAULT))
          {
            LOWORD(__p[0]) = 0;
            _os_log_impl( (void *)&_mh_execute_header,  v36,  OS_LOG_TYPE_DEFAULT,  "Hack for Mercedes finished",  (uint8_t *)__p,  2u);
          }

          sub_10020757C(v5, 0);
          return;
        }

        if (sub_10020753C(v5) && sub_1002070AC(v5))
        {
          uint64_t v42 = (os_log_s *)qword_1008F7598;
          if (os_log_type_enabled((os_log_t)qword_1008F7598, OS_LOG_TYPE_DEFAULT))
          {
            if (v7)
            {
              sub_1003CF00C(v7, __p);
              if (SHIBYTE(v125[0]) >= 0) {
                int v43 = __p;
              }
              else {
                int v43 = (void **)__p[0];
              }
              *(_DWORD *)__int128 buf = 136446210;
              *(void *)&uint8_t buf[4] = v43;
              _os_log_impl( (void *)&_mh_execute_header,  v42,  OS_LOG_TYPE_DEFAULT,  "Device %{public}s routed away audio after ending call. Ignore route away and allowing audio layer to clo se session on its own.",  buf,  0xCu);
              if (SHIBYTE(v125[0]) < 0) {
                operator delete(__p[0]);
              }
            }

            else
            {
              *(_DWORD *)__int128 buf = 136446210;
              *(void *)&uint8_t buf[4] = "NULL";
              _os_log_impl( (void *)&_mh_execute_header,  v42,  OS_LOG_TYPE_DEFAULT,  "Device %{public}s routed away audio after ending call. Ignore route away and allowing audio layer to clo se session on its own.",  buf,  0xCu);
            }
          }

          sub_100207544(v5, 0);
          return;
        }

        sub_1002073DC(v5, 0);
        int v44 = (os_log_s *)qword_1008F7598;
        if (v7)
        {
          if (os_log_type_enabled((os_log_t)qword_1008F7598, OS_LOG_TYPE_DEFAULT))
          {
            sub_1003CF00C(v7, __p);
            int v45 = SHIBYTE(v125[0]) >= 0 ? __p : (void **)__p[0];
            *(_DWORD *)__int128 buf = 136446210;
            *(void *)&uint8_t buf[4] = v45;
            _os_log_impl( (void *)&_mh_execute_header,  v44,  OS_LOG_TYPE_DEFAULT,  "Received voice disconnection event for device %{public}s",  buf,  0xCu);
            if (SHIBYTE(v125[0]) < 0) {
              operator delete(__p[0]);
            }
          }

          uint64_t v111 = *(unsigned __int8 *)(v7 + 128);
          uint64_t v116 = *(unsigned __int8 *)(v7 + 129);
          uint64_t v46 = *(unsigned __int8 *)(v7 + 130);
          uint64_t v47 = *(unsigned __int8 *)(v7 + 131);
          uint64_t v48 = *(unsigned __int8 *)(v7 + 132);
          uint64_t v49 = *(unsigned __int8 *)(v7 + 133);
          uint64_t v50 = sub_1002E6E9C();
          uint64_t v51 = sub_1003D0268(v7);
          uint64_t v52 = (*(uint64_t (**)(uint64_t, unint64_t, uint64_t, uint64_t, void, uint64_t, uint64_t, void))(*(void *)v50 + 72LL))( v50,  ((unint64_t)v116 << 8) | ((unint64_t)v46 << 16) | ((unint64_t)v47 << 24) | (v48 << 32) | (v49 << 40) | v111,  v51,  1LL,  0LL,  1LL,  1LL,  0LL);
          sub_10046992C(v52, (v111 << 40) | (v116 << 32) | (v46 << 24) | (v47 << 16) | (v48 << 8) | v49, 0);
          uint64_t v53 = sub_1002E6BF0();
          if ((*(unsigned int (**)(uint64_t))(*(void *)v53 + 328LL))(v53)
            && sub_1003D2B2C(v7, 0)
            && sub_1003D2B2C(v7, 1)
            && sub_1003D2B2C(v7, 3))
          {
            uint64_t v54 = (os_log_s *)qword_1008F7598;
            if (os_log_type_enabled((os_log_t)qword_1008F7598, OS_LOG_TYPE_DEFAULT))
            {
              sub_1003CF00C(v7, __p);
              uint64_t v55 = SHIBYTE(v125[0]) >= 0 ? __p : (void **)__p[0];
              *(_DWORD *)__int128 buf = 136446210;
              *(void *)&uint8_t buf[4] = v55;
              _os_log_impl( (void *)&_mh_execute_header,  v54,  OS_LOG_TYPE_DEFAULT,  "Notify gizmo to reform triangle for device %{public}s if warranted",  buf,  0xCu);
              if (SHIBYTE(v125[0]) < 0) {
                operator delete(__p[0]);
              }
            }

            if (qword_1008D60E0 != -1) {
              dispatch_once(&qword_1008D60E0, &stru_10089A010);
            }
            sub_1002215D0((uint64_t)off_1008D60D8, v7);
          }

          uint64_t v56 = sub_1002E6E9C();
          (*(void (**)(uint64_t))(*(void *)v56 + 1224LL))(v56);
          *(_DWORD *)char v122 = 0;
          int v118 = 0;
          uint64_t v57 = sub_1002E6E00();
          sub_10002418C(__p, "HFP");
          sub_10002418C(buf, "DisableWBS");
          (*(void (**)(uint64_t, void **, _BYTE *, uint8_t *))(*(void *)v57 + 88LL))(v57, __p, buf, v122);
          if (v121 < 0) {
            operator delete(*(void **)buf);
          }
          if (SHIBYTE(v125[0]) < 0) {
            operator delete(__p[0]);
          }
          uint64_t v58 = sub_1002E6E00();
          sub_10002418C(__p, "HFP");
          sub_10002418C(buf, "DisableUWBS");
          (*(void (**)(uint64_t, void **, _BYTE *, int *))(*(void *)v58 + 88LL))(v58, __p, buf, &v118);
          if (v121 < 0) {
            operator delete(*(void **)buf);
          }
          if (SHIBYTE(v125[0]) < 0) {
            operator delete(__p[0]);
          }
          if (!*(_DWORD *)v122 || !v118)
          {
            if (sub_10020748C(v5))
            {
              sub_1002E6E9C();
              if (sub_1002CD2E8())
              {
                uint64_t v59 = sub_1002E6E9C();
                (*(void (**)(uint64_t, uint64_t, void, uint64_t))(*(void *)v59 + 288LL))(v59, v7, 0LL, 1LL);
              }
            }
          }

          sub_1004698B8();
          *(_DWORD *)(v7 + 1320) &= ~1u;
          __p[0] = 0LL;
          sub_1000B0400((uint64_t)__p);
          uint64_t v60 = SLODWORD(__p[0]);
          sub_100207794(v5, (__n128 *)__p);
          if (v60 - (unint64_t)__p[0] <= 0x3C)
          {
            unsigned int v61 = ++*((_BYTE *)v4 + 568);
            if (v61 < 5)
            {
LABEL_112:
              __n128 v117 = 0uLL;
              sub_10020777C(v5, &v117);
              uint64_t v64 = sub_1002073AC(v5);
              if (qword_1008D60B0 != -1) {
                dispatch_once(&qword_1008D60B0, &stru_100899F70);
              }
              int v65 = sub_1004317E0((uint64_t)off_1008D60A8, *(unsigned int *)(a2 + 8), 10000);
              sub_100411948(a1, v64, 102, v65);
              sub_100469A5C(a1, *(unsigned __int16 *)(a2 + 4), 1, 0);
              if (qword_1008D9250 != -1) {
                dispatch_once(&qword_1008D9250, &stru_10089A0D0);
              }
              sub_100518A58((uint64_t)off_1008D9248, 0);
              if (qword_1008D6198 != -1) {
                dispatch_once(&qword_1008D6198, &stru_10089A0F0);
              }
              sub_100448A40( (uint64_t)off_1008D6190,  0,  ((unint64_t)*(unsigned __int8 *)(v7 + 128) << 40) | ((unint64_t)*(unsigned __int8 *)(v7 + 129) << 32) | ((unint64_t)*(unsigned __int8 *)(v7 + 130) << 24) | ((unint64_t)*(unsigned __int8 *)(v7 + 131) << 16) | ((unint64_t)*(unsigned __int8 *)(v7 + 132) << 8) | *(unsigned __int8 *)(v7 + 133));
              uint64_t v66 = sub_1002073AC(v5);
              __int16 v67 = sub_1002073A4(v5);
              sub_10046981C((os_unfair_lock_s *)a1, v66, v67, 0);
              return;
            }

            uint64_t v62 = sub_1002073AC(v5);
            if (qword_1008D60B0 != -1) {
              dispatch_once(&qword_1008D60B0, &stru_100899F70);
            }
            int v63 = sub_1004317E0((uint64_t)off_1008D60A8, *(unsigned int *)(a2 + 8), 10000);
            sub_100411948(a1, v62, 412, v63);
          }

          *((_BYTE *)v4 + 56_Block_object_dispose((const void *)(v2 - 88), 8) = 0;
          goto LABEL_112;
        }

        if (os_log_type_enabled((os_log_t)qword_1008F7598, OS_LOG_TYPE_ERROR)) {
          sub_100681F04();
        }
        break;
      default:
        goto LABEL_54;
    }

void sub_100467EC4( _Unwind_Exception *a1, uint64_t a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, int a14, char a15, uint64_t a16, uint64_t a17, void *__p, uint64_t a19, int a20, __int16 a21, char a22, char a23, uint64_t a24, uint64_t a25, uint64_t a26, void *a27, uint64_t a28, int a29, __int16 a30, char a31, char a32)
{
}

uint64_t sub_100467F84(uint64_t a1, int *a2)
{
  uint64_t v4 = sub_1004615C4(a1, *((unsigned __int16 *)a2 + 2));
  int v5 = *a2;
  switch(*a2)
  {
    case 10:
      uint64_t v6 = (os_log_s *)qword_1008F7598;
      if (os_log_type_enabled((os_log_t)qword_1008F7598, OS_LOG_TYPE_DEFAULT))
      {
        if (v4)
        {
          sub_1003CF00C(v4, __p);
          if (v23 >= 0) {
            uint64_t v7 = __p;
          }
          else {
            uint64_t v7 = (void **)__p[0];
          }
          *(_DWORD *)__int128 buf = 136446210;
          v25[0] = v7;
          _os_log_impl( (void *)&_mh_execute_header,  v6,  OS_LOG_TYPE_DEFAULT,  "Received dial event from device %{public}s",  buf,  0xCu);
          if (v23 < 0) {
            operator delete(__p[0]);
          }
        }

        else
        {
          *(_DWORD *)__int128 buf = 136446210;
          v25[0] = "NULL";
          _os_log_impl( (void *)&_mh_execute_header,  v6,  OS_LOG_TYPE_DEFAULT,  "Received dial event from device %{public}s",  buf,  0xCu);
        }
      }

      unsigned int v17 = (_BYTE *)*((void *)a2 + 1);
      if (*v17)
      {
        unsigned int v18 = *((unsigned __int16 *)a2 + 2);
        sub_10054A384(__p, v17);
        uint64_t v19 = sub_10046A3BC(a1, v18, (uint64_t)__p);
        sub_10054A428(__p);
        goto LABEL_52;
      }

      if (os_log_type_enabled((os_log_t)qword_1008F7598, OS_LOG_TYPE_ERROR)) {
        sub_100681F30();
      }
      return 27LL;
    case 11:
      int v8 = (os_log_s *)qword_1008F7598;
      if (os_log_type_enabled((os_log_t)qword_1008F7598, OS_LOG_TYPE_DEFAULT))
      {
        if (v4)
        {
          sub_1003CF00C(v4, __p);
          if (v23 >= 0) {
            int v9 = __p;
          }
          else {
            int v9 = (void **)__p[0];
          }
          *(_DWORD *)__int128 buf = 136446210;
          v25[0] = v9;
          _os_log_impl( (void *)&_mh_execute_header,  v8,  OS_LOG_TYPE_DEFAULT,  "Received memory dial event from device %{public}s",  buf,  0xCu);
          if (v23 < 0) {
            operator delete(__p[0]);
          }
        }

        else
        {
          *(_DWORD *)__int128 buf = 136446210;
          v25[0] = "NULL";
          _os_log_impl( (void *)&_mh_execute_header,  v8,  OS_LOG_TYPE_DEFAULT,  "Received memory dial event from device %{public}s",  buf,  0xCu);
        }
      }

      uint64_t v20 = sub_10046A6AC(a1, *((unsigned __int16 *)a2 + 2), *((unsigned __int16 *)a2 + 4));
      goto LABEL_51;
    case 12:
      uint64_t v10 = (os_log_s *)qword_1008F7598;
      if (os_log_type_enabled((os_log_t)qword_1008F7598, OS_LOG_TYPE_DEFAULT))
      {
        if (v4)
        {
          sub_1003CF00C(v4, __p);
          if (v23 >= 0) {
            uint64_t v11 = __p;
          }
          else {
            uint64_t v11 = (void **)__p[0];
          }
          *(_DWORD *)__int128 buf = 136446210;
          v25[0] = v11;
          _os_log_impl( (void *)&_mh_execute_header,  v10,  OS_LOG_TYPE_DEFAULT,  "Received redial event from device %{public}s",  buf,  0xCu);
          if (v23 < 0) {
            operator delete(__p[0]);
          }
        }

        else
        {
          *(_DWORD *)__int128 buf = 136446210;
          v25[0] = "NULL";
          _os_log_impl( (void *)&_mh_execute_header,  v10,  OS_LOG_TYPE_DEFAULT,  "Received redial event from device %{public}s",  buf,  0xCu);
        }
      }

      uint64_t v20 = sub_10046A548(a1, *((unsigned __int16 *)a2 + 2));
      goto LABEL_51;
    case 19:
      int v14 = (os_log_s *)qword_1008F7598;
      BOOL v15 = os_log_type_enabled((os_log_t)qword_1008F7598, OS_LOG_TYPE_DEFAULT);
      if (v15)
      {
        if (v4)
        {
          sub_1003CF00C(v4, __p);
          if (v23 >= 0) {
            int v16 = __p;
          }
          else {
            int v16 = (void **)__p[0];
          }
          *(_DWORD *)__int128 buf = 136446210;
          v25[0] = v16;
          _os_log_impl( (void *)&_mh_execute_header,  v14,  OS_LOG_TYPE_DEFAULT,  "Received DTMF generation event from device %{public}s",  buf,  0xCu);
          if (v23 < 0) {
            operator delete(__p[0]);
          }
        }

        else
        {
          *(_DWORD *)__int128 buf = 136446210;
          v25[0] = "NULL";
          _os_log_impl( (void *)&_mh_execute_header,  v14,  OS_LOG_TYPE_DEFAULT,  "Received DTMF generation event from device %{public}s",  buf,  0xCu);
        }
      }

      uint64_t v20 = sub_10046A8A0(v15, 0LL, *((unsigned __int8 *)a2 + 8));
LABEL_51:
      uint64_t v19 = v20;
LABEL_52:
      if ((_DWORD)v19 == 255 && (*a2 - 13) >= 0xFFFFFFFD)
      {
        if (qword_1008D9250 != -1) {
          dispatch_once(&qword_1008D9250, &stru_10089A0D0);
        }
        sub_100518A58((uint64_t)off_1008D9248, 1);
        uint64_t v19 = 255LL;
      }

      break;
    default:
      uint64_t v12 = (os_log_s *)qword_1008F7598;
      if (os_log_type_enabled((os_log_t)qword_1008F7598, OS_LOG_TYPE_DEFAULT))
      {
        if (v4)
        {
          sub_1003CF00C(v4, __p);
          if (v23 >= 0) {
            unsigned int v13 = __p;
          }
          else {
            unsigned int v13 = (void **)__p[0];
          }
          *(_DWORD *)__int128 buf = 67109378;
          LODWORD(v25[0]) = v5;
          WORD2(v25[0]) = 2082;
          *(void *)((char *)v25 + 6) = v13;
          _os_log_impl( (void *)&_mh_execute_header,  v12,  OS_LOG_TYPE_DEFAULT,  "Received unhandled handsfree dialing event from stack (%d) for device %{public}s",  buf,  0x12u);
          if (v23 < 0) {
            operator delete(__p[0]);
          }
        }

        else
        {
          *(_DWORD *)__int128 buf = 67109378;
          LODWORD(v25[0]) = v5;
          WORD2(v25[0]) = 2082;
          *(void *)((char *)v25 + 6) = "NULL";
          _os_log_impl( (void *)&_mh_execute_header,  v12,  OS_LOG_TYPE_DEFAULT,  "Received unhandled handsfree dialing event from stack (%d) for device %{public}s",  buf,  0x12u);
        }
      }

      uint64_t v19 = 4LL;
      break;
  }

  return v19;
}

void sub_1004684F8(_Unwind_Exception *a1, uint64_t a2, ...)
{
}

uint64_t sub_10046853C(uint64_t a1, uint64_t a2)
{
  uint64_t v4 = sub_1004615C4(a1, *(unsigned __int16 *)(a2 + 4));
  int v5 = *(_DWORD *)a2;
  if (*(int *)a2 > 14)
  {
    if (v5 == 15)
    {
      int v14 = (os_log_s *)qword_1008F7598;
      if (os_log_type_enabled((os_log_t)qword_1008F7598, OS_LOG_TYPE_DEFAULT))
      {
        if (v4)
        {
          sub_1003CF00C(v4, __p);
          if (v22 >= 0) {
            BOOL v15 = __p;
          }
          else {
            BOOL v15 = (void **)__p[0];
          }
          *(_DWORD *)__int128 buf = 136446210;
          v24[0] = v15;
          _os_log_impl( (void *)&_mh_execute_header,  v14,  OS_LOG_TYPE_DEFAULT,  "Received call hold event (AT+CHLD) from device %{public}s",  buf,  0xCu);
          if (v22 < 0) {
            operator delete(__p[0]);
          }
        }

        else
        {
          *(_DWORD *)__int128 buf = 136446210;
          v24[0] = "NULL";
          _os_log_impl( (void *)&_mh_execute_header,  v14,  OS_LOG_TYPE_DEFAULT,  "Received call hold event (AT+CHLD) from device %{public}s",  buf,  0xCu);
        }
      }

      return sub_10046B318(a1, a2);
    }

    if (v5 == 22)
    {
      int v8 = (os_log_s *)qword_1008F7598;
      if (os_log_type_enabled((os_log_t)qword_1008F7598, OS_LOG_TYPE_DEFAULT))
      {
        if (v4)
        {
          sub_1003CF00C(v4, __p);
          if (v22 >= 0) {
            int v9 = __p;
          }
          else {
            int v9 = (void **)__p[0];
          }
          *(_DWORD *)__int128 buf = 136446210;
          v24[0] = v9;
          _os_log_impl( (void *)&_mh_execute_header,  v8,  OS_LOG_TYPE_DEFAULT,  "Received list calls request (AT+CLCC) from device %{public}s",  buf,  0xCu);
          if (v22 < 0) {
            operator delete(__p[0]);
          }
        }

        else
        {
          *(_DWORD *)__int128 buf = 136446210;
          v24[0] = "NULL";
          _os_log_impl( (void *)&_mh_execute_header,  v8,  OS_LOG_TYPE_DEFAULT,  "Received list calls request (AT+CLCC) from device %{public}s",  buf,  0xCu);
        }
      }

      sub_10046BA20(a1, *(unsigned __int16 *)(a2 + 4));
      return 255LL;
    }

void sub_100468B58( _Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, char a9)
{
}

uint64_t sub_100468B74(uint64_t a1, unsigned int a2)
{
  uint64_t v14 = 0LL;
  __int128 v12 = 0u;
  __int128 v13 = 0u;
  __int128 v11 = 0u;
  sub_10054A050(&v11);
  if (qword_1008D90F8 != -1) {
    dispatch_once(&qword_1008D90F8, &stru_10089A050);
  }
  uint64_t v3 = (os_log_s *)qword_1008F7598;
  if (os_log_type_enabled((os_log_t)qword_1008F7598, OS_LOG_TYPE_DEFAULT))
  {
    if (SBYTE7(v12) < 0)
    {
      sub_100024238(__p, (void *)v11, *((unint64_t *)&v11 + 1));
    }

    else
    {
      *(_OWORD *)__int128 __p = v11;
      uint64_t v10 = v12;
    }

    uint64_t v4 = __p;
    if (v10 < 0) {
      uint64_t v4 = (void **)__p[0];
    }
    *(_DWORD *)__int128 buf = 136315394;
    int v16 = v4;
    __int16 v17 = 1024;
    int v18 = BYTE8(v12);
    _os_log_impl( (void *)&_mh_execute_header,  v3,  OS_LOG_TYPE_DEFAULT,  "Subscriber number is %s and type of address is %d",  buf,  0x12u);
    if (SHIBYTE(v10) < 0) {
      operator delete(__p[0]);
    }
  }

  buf[0] = 0;
  sub_100242CA4(buf);
  if (SBYTE7(v12) < 0)
  {
    sub_100024238(__p, (void *)v11, *((unint64_t *)&v11 + 1));
  }

  else
  {
    *(_OWORD *)__int128 __p = v11;
    uint64_t v10 = v12;
  }

  if (v10 >= 0) {
    int v5 = __p;
  }
  else {
    int v5 = (void **)__p[0];
  }
  int v6 = sub_1000F0980(a2, (const char *)v5);
  if (SHIBYTE(v10) < 0) {
    operator delete(__p[0]);
  }
  sub_100242CD0(buf);
  if (!v6)
  {
    sub_100242CD8(buf);
LABEL_26:
    uint64_t v7 = 255LL;
    goto LABEL_27;
  }

  if (os_log_type_enabled((os_log_t)qword_1008F7598, OS_LOG_TYPE_ERROR)) {
    sub_100681F5C();
  }
  sub_100242CD8(buf);
  uint64_t v7 = 0LL;
LABEL_27:
  sub_10054A428(&v11);
  return v7;
}

void sub_100468D98( _Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, void *__p, uint64_t a10, int a11, __int16 a12, char a13, char a14, uint64_t a15, char a16)
{
}

uint64_t sub_100468DE8(uint64_t a1, unsigned int a2)
{
  uint64_t v3 = (char *)(a1 + 360);
  memset(&v14, 0, sizeof(v14));
  uint64_t v4 = sub_100206568(a1 + 360);
  uint64_t v5 = v4;
  if (v4 >= 5)
  {
    uint64_t v5 = 0LL;
    int v6 = 0LL;
  }

  else
  {
    int v6 = off_10089A130[(int)v4];
  }

  sub_10020653C(v3, (uint64_t)&__p);
  if ((char)__p.__r_.__value_.__s.__size_ < 0)
  {
    sub_100024238(&buf, __p.__r_.__value_.__l.__data_, __p.__r_.__value_.__l.__size_);
    std::string v14 = buf;
    buf.__r_.__value_.__s.__size_ = 0;
    buf.__r_.__value_.__s.__data_[0] = 0;
  }

  else
  {
    std::string v14 = __p;
  }

  if ((char)v14.__r_.__value_.__s.__size_ < 0)
  {
    std::string::size_type size = v14.__r_.__value_.__l.__size_;
    if (v14.__r_.__value_.__l.__size_ <= 0x10) {
      goto LABEL_13;
    }
    goto LABEL_12;
  }

  std::string::size_type size = v14.__r_.__value_.__s.__size_;
  if (v14.__r_.__value_.__s.__size_ >= 0x11u) {
LABEL_12:
  }
    std::string::erase(&v14, 0x10uLL, size - 16);
LABEL_13:
  int v8 = (os_log_s *)qword_1008F7598;
  if (os_log_type_enabled((os_log_t)qword_1008F7598, OS_LOG_TYPE_DEFAULT))
  {
    int v9 = &v14;
    if ((v14.__r_.__value_.__s.__size_ & 0x80u) != 0) {
      int v9 = (std::string *)v14.__r_.__value_.__r.__words[0];
    }
    LODWORD(buf.__r_.__value_.__l.__data_) = 136315394;
    *(std::string::size_type *)((char *)buf.__r_.__value_.__r.__words + 4) = (std::string::size_type)v9;
    WORD2(buf.__r_.__value_.__r.__words[1]) = 2080;
    *(std::string::size_type *)((char *)&buf.__r_.__value_.__r.__words[1] + 6) = (std::string::size_type)v6;
    _os_log_impl( (void *)&_mh_execute_header,  v8,  OS_LOG_TYPE_DEFAULT,  "Network operator is %s and mode is %s",  (uint8_t *)&buf,  0x16u);
  }

  buf.__r_.__value_.__s.__data_[0] = 0;
  sub_100242CA4(&buf);
  if ((char)v14.__r_.__value_.__s.__size_ < 0)
  {
    if (v14.__r_.__value_.__l.__size_) {
      uint64_t v10 = (std::string *)v14.__r_.__value_.__r.__words[0];
    }
    else {
      uint64_t v10 = 0LL;
    }
  }

  else if (v14.__r_.__value_.__s.__size_)
  {
    uint64_t v10 = &v14;
  }

  else
  {
    uint64_t v10 = 0LL;
  }

  if (sub_1000F0C30(a2, v5, (const char *)v10))
  {
    if (os_log_type_enabled((os_log_t)qword_1008F7598, OS_LOG_TYPE_ERROR)) {
      sub_100681FBC();
    }
    uint64_t v11 = 0LL;
  }

  else
  {
    uint64_t v11 = 255LL;
  }

  sub_100242CD8(&buf);
  return v11;
}

void sub_10046900C( _Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void *__p, uint64_t a11, int a12, __int16 a13, char a14, char a15, void *a16, uint64_t a17, int a18, __int16 a19, char a20, char a21, uint64_t a22, char a23)
{
}

uint64_t sub_100469060(uint64_t a1, unsigned int a2)
{
  uint64_t result = (uint64_t)sub_10045CF60(a1, a2);
  if (result)
  {
    uint64_t v3 = result;
    sub_10020740C(result + 400, 1);
    sub_10027228C(v3, 1);
    return 255LL;
  }

  return result;
}

uint64_t sub_1004690A0(uint64_t a1, unsigned int a2, int a3)
{
  uint64_t v6 = sub_1004615C4(a1, a2);
  uint64_t v7 = sub_10045CF60(a1, a2);
  int v8 = (os_log_s *)qword_1008F7598;
  if (os_log_type_enabled((os_log_t)qword_1008F7598, OS_LOG_TYPE_DEFAULT))
  {
    if (a3) {
      int v9 = "start";
    }
    else {
      int v9 = "end";
    }
    if (!v6)
    {
      *(_DWORD *)std::string buf = 136446466;
      uint64_t v19 = v9;
      __int16 v20 = 2082;
      uint64_t v21 = "NULL";
      _os_log_impl( (void *)&_mh_execute_header,  v8,  OS_LOG_TYPE_DEFAULT,  "Received '%{public}s voice command' event for device %{public}s",  buf,  0x16u);
      if (!a3) {
        goto LABEL_15;
      }
      goto LABEL_12;
    }

    sub_1003CF00C(v6, __p);
    if (v17 >= 0) {
      uint64_t v10 = __p;
    }
    else {
      uint64_t v10 = (void **)__p[0];
    }
    *(_DWORD *)std::string buf = 136446466;
    uint64_t v19 = v9;
    __int16 v20 = 2082;
    uint64_t v21 = (const char *)v10;
    _os_log_impl( (void *)&_mh_execute_header,  v8,  OS_LOG_TYPE_DEFAULT,  "Received '%{public}s voice command' event for device %{public}s",  buf,  0x16u);
    if (v17 < 0) {
      operator delete(__p[0]);
    }
  }

  if (!a3) {
    goto LABEL_15;
  }
LABEL_12:
  if ((sub_1002065F4(a1 + 360) & 1) != 0)
  {
LABEL_16:
    uint64_t v11 = (os_log_s *)qword_1008F7598;
    BOOL v12 = os_log_type_enabled((os_log_t)qword_1008F7598, OS_LOG_TYPE_DEFAULT);
    uint64_t result = 0LL;
    if (v12)
    {
      LOWORD(__p[0]) = 0;
      _os_log_impl( (void *)&_mh_execute_header,  v11,  OS_LOG_TYPE_DEFAULT,  "Call in progress, denying voice rec session.",  (uint8_t *)__p,  2u);
      return 0LL;
    }

    return result;
  }

uint64_t sub_1004692F0(uint64_t a1, uint64_t a2)
{
  uint64_t v4 = sub_1004615C4(a1, *(unsigned __int16 *)(a2 + 4));
  int v6 = *(_DWORD *)(a2 + 8);
  uint64_t v5 = *(unsigned int *)(a2 + 12);
  if (v6 == 2)
  {
    uint64_t v10 = (os_log_s *)qword_1008F7598;
    if (os_log_type_enabled((os_log_t)qword_1008F7598, OS_LOG_TYPE_DEFAULT))
    {
      int v11 = 67109120;
      int v12 = v5;
      _os_log_impl( (void *)&_mh_execute_header,  v10,  OS_LOG_TYPE_DEFAULT,  "Received battery level HF indicator with value: %d",  (uint8_t *)&v11,  8u);
    }

    sub_1003D7A88(v4, v5);
    if (qword_1008D5F40 != -1) {
      dispatch_once(&qword_1008D5F40, &stru_10089A110);
    }
    else {
      return 255LL;
    }
  }

  else if (v6 == 1)
  {
    uint64_t v7 = (os_log_s *)qword_1008F7598;
    if (os_log_type_enabled((os_log_t)qword_1008F7598, OS_LOG_TYPE_DEFAULT))
    {
      int v11 = 67109120;
      int v12 = v5;
      _os_log_impl( (void *)&_mh_execute_header,  v7,  OS_LOG_TYPE_DEFAULT,  "Received enhanced safety HF indicator with value: %d",  (uint8_t *)&v11,  8u);
    }

    if ((_DWORD)v5) {
      int v8 = 105;
    }
    else {
      int v8 = 106;
    }
    sub_100411948(a1, v4, v8, 0);
    return 255LL;
  }

  else
  {
    uint64_t result = os_log_type_enabled((os_log_t)qword_1008F7598, OS_LOG_TYPE_ERROR);
    if ((_DWORD)result)
    {
      sub_1006820A4();
      return 0LL;
    }
  }

  return result;
}

void sub_1004694A4(uint64_t a1, unsigned int a2)
{
  __int16 v2 = a2;
  uint64_t v4 = sub_10045CF60(a1, a2);
  if (v4)
  {
    uint64_t v5 = (uint64_t)v4;
    uint64_t v6 = (uint64_t)(v4 + 50);
    uint64_t v7 = sub_1002073AC((uint64_t)(v4 + 50));
    BOOL v8 = sub_10045F7E8(v7, v7) == 2 && sub_100207774(v6) == 1918989668;
    int v9 = sub_100206648(a1 + 360);
    if (v7
      && (v10 = v9, (unsigned int v11 = sub_10045F4D0(a1, v7)) != 0)
      && ((unsigned int v12 = v11, sub_100207774(v6) == 1920364387) || (v8 & v10) != 0))
    {
      __int128 v13 = (os_log_s *)qword_1008F7598;
      if (os_log_type_enabled((os_log_t)qword_1008F7598, OS_LOG_TYPE_DEFAULT))
      {
        int v14 = "NO";
        *(_DWORD *)std::string buf = 67109634;
        unsigned int v19 = v12;
        if (v8) {
          int v14 = "YES";
        }
        __int16 v20 = 2082;
        uint64_t v21 = v14;
        __int16 v22 = 1024;
        int v23 = v10;
        _os_log_impl( (void *)&_mh_execute_header,  v13,  OS_LOG_TYPE_DEFAULT,  "Notify HFP Transport Ready in %dMsec Carkit Doing IO = %{public}s, isInVirtualCall:%d",  buf,  0x18u);
      }

      uint64_t v15 = sub_100405058();
      v16[0] = _NSConcreteStackBlock;
      v16[1] = 3221225472LL;
      void v16[2] = sub_1004696A4;
      void v16[3] = &unk_1008878D8;
      v16[4] = a1;
      __int16 v17 = v2;
      sub_100405460(v15, v12, v16);
    }

    else
    {
      sub_100270008(v5);
    }
  }

void sub_1004696A4(uint64_t a1)
{
  uint64_t v1 = sub_10045CF60(*(void *)(a1 + 32), *(unsigned __int16 *)(a1 + 40));
  if (v1)
  {
    uint64_t v2 = (uint64_t)v1;
    if (sub_1002073D4((uint64_t)(v1 + 50)))
    {
      uint64_t v3 = (os_log_s *)qword_1008F7598;
      if (os_log_type_enabled((os_log_t)qword_1008F7598, OS_LOG_TYPE_DEFAULT))
      {
        *(_WORD *)uint64_t v4 = 0;
        _os_log_impl((void *)&_mh_execute_header, v3, OS_LOG_TYPE_DEFAULT, "Notify HFP Transport Ready", v4, 2u);
      }

      sub_100270008(v2);
    }
  }

void sub_100469734(uint64_t a1, uint64_t a2)
{
  uint64_t v2 = sub_10045D7CC(a1, a2);
  if (v2)
  {
    uint64_t v3 = v2 + 400;
    int v4 = sub_1002073D4(v2 + 400);
    if (v4 == 4)
    {
      char v8 = 0;
      sub_100242CA4(&v8);
      unsigned int v7 = sub_1002073A4(v3);
      sub_1000EF578(v7, 2701LL);
      sub_100242CD0(&v8);
      uint64_t v6 = &v8;
      goto LABEL_6;
    }

    if (v4 == 3)
    {
      char v9 = 0;
      sub_100242CA4(&v9);
      unsigned int v5 = sub_1002073A4(v3);
      sub_1000F14F0(v5, 0);
      sub_100242CD0(&v9);
      uint64_t v6 = &v9;
LABEL_6:
      sub_100242CD8(v6);
      return;
    }

    if (os_log_type_enabled((os_log_t)qword_1008F7598, OS_LOG_TYPE_ERROR)) {
      sub_100682104();
    }
  }

void sub_1004697FC( _Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, int a10, __int16 a11, char a12)
{
}

void sub_10046981C(os_unfair_lock_s *a1, uint64_t a2, __int16 a3, int a4)
{
  uint64_t v8 = sub_10045D7CC((uint64_t)a1, a2);
  uint64_t v9 = v8;
  if (v8) {
    sub_1002702DC(v8, a4);
  }
  v10[0] = _NSConcreteStackBlock;
  v10[1] = 3221225472LL;
  void v10[2] = sub_100474D60;
  uint64_t v10[3] = &unk_100899D50;
  __int16 v11 = a3;
  char v12 = a4;
  v10[4] = a2;
  void v10[5] = v9;
  sub_100474C68(a1 + 82, v10);
}

void sub_1004698B8()
{
  if (sub_1002D099C())
  {
    uint64_t v0 = (os_log_s *)qword_1008F7598;
    if (os_log_type_enabled((os_log_t)qword_1008F7598, OS_LOG_TYPE_INFO))
    {
      *(_WORD *)uint64_t v1 = 0;
      _os_log_impl((void *)&_mh_execute_header, v0, OS_LOG_TYPE_INFO, "Free Voice Buf", v1, 2u);
    }

    sub_100133F78();
  }

_BYTE *sub_10046992C(uint64_t a1, unint64_t a2, int a3)
{
  __int16 v17 = 0LL;
  unint64_t v4 = sub_1001BEE0C(a2);
  int v15 = v4;
  __int16 v16 = WORD2(v4);
  char v14 = 0;
  sub_100242CA4(&v14);
  sub_10010EEE0((uint64_t)&v15, (uint64_t *)&v17);
  uint64_t v5 = sub_10012D7D4(v17);
  sub_100242CD0(&v14);
  if (v17 && *((_BYTE *)v17 + 278))
  {
    int v6 = *((_DWORD *)v17 + 70);
    unsigned int v7 = (os_log_s *)qword_1008F7598;
    BOOL v8 = os_log_type_enabled((os_log_t)qword_1008F7598, OS_LOG_TYPE_DEFAULT);
    if (a3)
    {
      uint64_t v9 = v6 | 0x3F0000u;
      if (v8)
      {
        *(_WORD *)__int128 v13 = 0;
        int v10 = "Update connection packet types with HDR packets removed";
LABEL_8:
        _os_log_impl((void *)&_mh_execute_header, v7, OS_LOG_TYPE_DEFAULT, v10, v13, 2u);
      }
    }

    else
    {
      uint64_t v9 = v6 & 0xFFC0FFFF;
      if (v8)
      {
        *(_WORD *)__int128 v13 = 0;
        int v10 = "Update connection packet types with HDR packets included";
        goto LABEL_8;
      }
    }

    uint64_t v11 = sub_1002E6E9C();
    (*(void (**)(uint64_t, uint64_t, uint64_t, uint64_t))(*(void *)v11 + 1312LL))(v11, v5, v9, 1LL);
  }

  return sub_100242CD8(&v14);
}

void sub_100469A40( _Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, int a10, __int16 a11, char a12, char a13)
{
}

uint64_t sub_100469A5C(uint64_t a1, unsigned int a2, char a3, int a4)
{
  v26[0] = 0LL;
  v26[1] = 0LL;
  sub_100242F28((uint64_t)v26, a1 + 760);
  uint64_t v8 = sub_1004615C4(a1, a2);
  uint64_t v9 = sub_10045D7CC(a1, v8);
  int v10 = (os_log_s *)qword_1008F7598;
  if (os_log_type_enabled((os_log_t)qword_1008F7598, OS_LOG_TYPE_DEFAULT))
  {
    if (v8)
    {
      sub_1003CF00C(v8, __p);
      if (v25 >= 0) {
        uint64_t v11 = __p;
      }
      else {
        uint64_t v11 = (void **)__p[0];
      }
      *(_DWORD *)std::string buf = 136446466;
      int v28 = (const char *)v11;
      __int16 v29 = 1024;
      int v30 = a4;
      _os_log_impl( (void *)&_mh_execute_header,  v10,  OS_LOG_TYPE_DEFAULT,  "Disconnecting audio from device %{public}s status %d",  buf,  0x12u);
      if (v25 < 0) {
        operator delete(__p[0]);
      }
    }

    else
    {
      *(_DWORD *)std::string buf = 136446466;
      int v28 = "NULL";
      __int16 v29 = 1024;
      int v30 = a4;
      _os_log_impl( (void *)&_mh_execute_header,  v10,  OS_LOG_TYPE_DEFAULT,  "Disconnecting audio from device %{public}s status %d",  buf,  0x12u);
    }
  }

  uint64_t v12 = a1 + 360;
  if (sub_100206648(v12))
  {
    if (qword_1008D9030 != -1) {
      dispatch_once(&qword_1008D9030, &stru_100899F90);
    }
    sub_100463700((uint64_t)off_1008D9028);
  }

  if (v9 && sub_10020744C(v9 + 400))
  {
    __int128 v13 = (os_log_s *)qword_1008F7598;
    if (os_log_type_enabled((os_log_t)qword_1008F7598, OS_LOG_TYPE_DEFAULT))
    {
      LOWORD(__p[0]) = 0;
      _os_log_impl( (void *)&_mh_execute_header,  v13,  OS_LOG_TYPE_DEFAULT,  "Voice command was active, sco will be closed",  (uint8_t *)__p,  2u);
    }

    LOBYTE(__p[0]) = 0;
    sub_100242CA4(__p);
    sub_1000F0548(a2, 0);
    sub_100242CD0(__p);
    sub_100207454(v9 + 400, 0);
    sub_100242CD8(__p);
    char v14 = 1;
  }

  else
  {
    char v14 = 0;
  }

  if (v9)
  {
    sub_1002E6E9C();
    if (sub_1002CD664()
      && sub_10020758C(v9 + 400)
      && sub_1002065F4(v12)
      && sub_100207774(v9 + 400) == 1918989668
      && sub_10020755C(v9 + 400) != 127
      && sub_10020755C(v9 + 400) != 256
      && sub_10020755C(v9 + 400) != 128
      && sub_10020755C(v9 + 400) != 129
      && sub_10020755C(v9 + 400) != 130)
    {
      char v20 = sub_10020755C(v9 + 400) == 255 ? 1 : v14;
      if ((v20 & 1) == 0 && (a3 & 1) == 0)
      {
        uint64_t v21 = (os_log_s *)qword_1008F7598;
        if (os_log_type_enabled((os_log_t)qword_1008F7598, OS_LOG_TYPE_DEFAULT))
        {
          LOWORD(__p[0]) = 0;
          _os_log_impl( (void *)&_mh_execute_header,  v21,  OS_LOG_TYPE_DEFAULT,  "Faking SCO disconnection here, but actually letting it stay open since we're answering an incoming call",  (uint8_t *)__p,  2u);
        }

        sub_100501F98(v9, 0, a4);
        sub_1001FFA38(v9 + 400, 0);
        sub_100206774(v9 + 400, 0);
        uint64_t v18 = 0LL;
        goto LABEL_59;
      }
    }
  }

  char v23 = 0;
  sub_100242CA4(&v23);
  int v15 = sub_1000F604C(a2);
  sub_100242CD0(&v23);
  uint64_t v16 = sub_100405058();
  v22[0] = _NSConcreteStackBlock;
  v22[1] = 3221225472LL;
  void v22[2] = sub_10046D754;
  void v22[3] = &unk_10087EB20;
  uint8_t v22[4] = v12;
  sub_100405384(v16, v22);
  if (v9)
  {
    sub_1002075CC(v9 + 400, 0);
    sub_1002075DC(v9 + 400, 0);
    if (!a4)
    {
LABEL_46:
      sub_100501F98(v9, 0, a4);
      goto LABEL_47;
    }

    if (a4 != 116)
    {
      if (os_log_type_enabled((os_log_t)qword_1008F7598, OS_LOG_TYPE_ERROR))
      {
        if (v8)
        {
          sub_1003CF00C(v8, __p);
          sub_100682200();
        }

        else
        {
          sub_1006821BC((uint64_t)buf, a4);
        }
      }

      if ((a3 & 1) == 0)
      {
        if (qword_1008D60F0 != -1) {
          dispatch_once(&qword_1008D60F0, &stru_10089A030);
        }
        sub_1004AA52C((uint64_t)off_1008D60E8, v8, a4);
      }

      goto LABEL_46;
    }

    if ((sub_1000F6738() & 1) == 0)
    {
      a4 = 0;
      goto LABEL_46;
    }

    if ((sub_1003D2B2C(v8, 12) & 1) != 0)
    {
      a4 = 116;
      goto LABEL_46;
    }
  }

void sub_10046A014( _Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, int a14, __int16 a15, char a16, char a17, uint64_t a18, uint64_t a19, uint64_t a20, uint64_t a21, char a22)
{
}

_BYTE *sub_10046A070(uint64_t a1, int a2, uint64_t a3)
{
  char v23 = 0;
  sub_100242CA4(&v23);
  uint64_t v6 = sub_1000F1000(a2);
  sub_100242CD0(&v23);
  if (!v6)
  {
    if (os_log_type_enabled((os_log_t)qword_1008F7598, OS_LOG_TYPE_ERROR)) {
      sub_100682248();
    }
    goto LABEL_10;
  }

  if (qword_1008D5F50 != -1) {
    dispatch_once(&qword_1008D5F50, &stru_100899FD0);
  }
  __int16 v7 = *(_WORD *)(v6 + 4);
  LODWORD(v21[0]) = *(_DWORD *)v6;
  WORD2(v21[0]) = v7;
  uint64_t v8 = sub_1003FFEB0(off_1008D5F48, (uint64_t)v21, 1);
  if (!v8)
  {
LABEL_10:
    sub_100242C98(&v23);
    sub_1000EF578(a2, 2701LL);
    sub_100242CD0(&v23);
    return sub_100242CD8(&v23);
  }

  v21[0] = 0LL;
  v21[1] = 0LL;
  uint64_t v22 = 0LL;
  uint64_t v9 = sub_10045D7CC(a1, (uint64_t)v8);
  if (v9)
  {
    int v10 = (uint64_t *)operator new(8uLL);
    sub_10050CA44(v10, v8, a3);
    char v11 = sub_1003D79C4((uint64_t)v8);
    sub_10050CC20(v9 + 400, (uint64_t)v8, v10);
    if ((v11 & 1) != 0) {
      int v12 = 0;
    }
    else {
      int v12 = sub_1003D79C4((uint64_t)v8);
    }
    sub_10050CC30((uint64_t)v8, v10, __p);
    *(_OWORD *)uint64_t v21 = *(_OWORD *)__p;
    uint64_t v22 = v20;
    sub_100242C98(&v23);
    if (v22 >= 0) {
      __int128 v13 = v21;
    }
    else {
      __int128 v13 = (void **)v21[0];
    }
    unsigned __int16 v14 = HIBYTE(v22);
    if (v22 < 0) {
      unsigned __int16 v14 = (unsigned __int16)v21[1];
    }
    sub_1000EF174(a2, v13, v14);
    sub_100242CD0(&v23);
    if (v12)
    {
      int v15 = (os_log_s *)qword_1008F7598;
      if (os_log_type_enabled((os_log_t)qword_1008F7598, OS_LOG_TYPE_DEFAULT))
      {
        sub_1003CF00C((uint64_t)v8, __p);
        uint64_t v16 = v20 >= 0 ? __p : (void **)__p[0];
        *(_DWORD *)std::string buf = 136446210;
        char v25 = v16;
        _os_log_impl( (void *)&_mh_execute_header,  v15,  OS_LOG_TYPE_DEFAULT,  "Sending 'phonebook sync supported' event for device %{public}s",  buf,  0xCu);
        if (SHIBYTE(v20) < 0) {
          operator delete(__p[0]);
        }
      }

      sub_100411948(a1, (uint64_t)v8, 303, 0);
    }

    __int16 v17 = sub_10050CA48(v10);
    operator delete(v17);
    if (SHIBYTE(v22) < 0) {
      operator delete(v21[0]);
    }
  }

  else if (os_log_type_enabled((os_log_t)qword_1008F7598, OS_LOG_TYPE_ERROR))
  {
    sub_1003D0100((uint64_t)v8, (uint64_t)__p);
    sub_100681044();
  }

  return sub_100242CD8(&v23);
}

void sub_10046A35C( _Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, void *__p, uint64_t a14, int a15, __int16 a16, char a17, char a18, int a19, __int16 a20, char a21, char a22)
{
  if (a18 < 0) {
    operator delete(__p);
  }
  sub_100242CD8(&a22);
  _Unwind_Resume(a1);
}

uint64_t sub_10046A3BC(uint64_t a1, unsigned int a2, uint64_t a3)
{
  v14[0] = 0LL;
  v14[1] = 0LL;
  sub_100242F28((uint64_t)v14, a1 + 760);
  memset(&v13, 0, sizeof(v13));
  sub_100461790(a1, a2, &v13);
  uint64_t v6 = a1 + 360;
  if (sub_100206834(a1 + 360))
  {
    sub_10020683C(a1 + 360, 0);
    sub_10046D9C0(*(void **)(a1 + 824), (void *)(a1 + 832), (void (*)(void, void))sub_10046DA3C);
  }

  if (qword_1008D90F8 != -1) {
    dispatch_once(&qword_1008D90F8, &stru_10089A050);
  }
  __int16 v7 = off_1008D90F0;
  else {
    std::string __p = v13;
  }
  int v8 = sub_10054AC94((uint64_t)v7, a3, (uint64_t)&__p);
  int v9 = v8;
  if ((char)__p.__r_.__value_.__s.__size_ < 0)
  {
    operator delete(__p.__r_.__value_.__l.__data_);
    if (v9) {
      goto LABEL_10;
    }
  }

  else if (v8)
  {
LABEL_10:
    uint64_t v10 = 0LL;
    goto LABEL_13;
  }

  sub_100206844(v6, 1);
  uint64_t v10 = 255LL;
LABEL_13:
  sub_100242FAC((uint64_t)v14);
  return v10;
}

void sub_10046A500( _Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, void *a9, uint64_t a10, int a11, __int16 a12, char a13, char a14, void *__p, uint64_t a16, int a17, __int16 a18, char a19, char a20, char a21)
{
  if (a20 < 0) {
    operator delete(__p);
  }
  sub_100242FAC((uint64_t)&a21);
  _Unwind_Resume(a1);
}

uint64_t sub_10046A548(uint64_t a1, unsigned int a2)
{
  v11[0] = 0LL;
  v11[1] = 0LL;
  sub_100242F28((uint64_t)v11, a1 + 760);
  memset(&v10, 0, sizeof(v10));
  sub_100461790(a1, a2, &v10);
  if (qword_1008D90F8 != -1) {
    dispatch_once(&qword_1008D90F8, &stru_10089A050);
  }
  unint64_t v4 = off_1008D90F0;
  else {
    std::string __p = v10;
  }
  int v5 = sub_10054AD30((uint64_t)v4, (uint64_t)&__p);
  int v6 = v5;
  if ((char)__p.__r_.__value_.__s.__size_ < 0)
  {
    operator delete(__p.__r_.__value_.__l.__data_);
    if (v6) {
      goto LABEL_8;
    }
LABEL_12:
    uint64_t v7 = 255LL;
    goto LABEL_13;
  }

  if (!v5) {
    goto LABEL_12;
  }
LABEL_8:
  if (os_log_type_enabled((os_log_t)qword_1008F7598, OS_LOG_TYPE_ERROR)) {
    sub_1006822AC();
  }
  uint64_t v7 = 23LL;
LABEL_13:
  sub_100242FAC((uint64_t)v11);
  return v7;
}

void sub_10046A668( _Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, void *a9, uint64_t a10, int a11, __int16 a12, char a13, char a14, void *__p, uint64_t a16, int a17, __int16 a18, char a19, char a20)
{
  if (a20 < 0) {
    operator delete(__p);
  }
  sub_100242FAC(v20 - 32);
  _Unwind_Resume(a1);
}

uint64_t sub_10046A6AC(uint64_t a1, unsigned int a2, int a3)
{
  uint64_t v6 = sub_1004615C4(a1, a2);
  v22[0] = 0LL;
  v22[1] = 0LL;
  uint64_t v7 = sub_1005064B0(v22, v6);
  uint64_t v21 = 0LL;
  __int128 v19 = 0u;
  *(_OWORD *)uint64_t v20 = 0u;
  *(_OWORD *)std::string __p = 0u;
  if (!a3)
  {
    if (os_log_type_enabled((os_log_t)qword_1008F7598, OS_LOG_TYPE_ERROR)) {
      sub_1006822D8();
    }
    goto LABEL_11;
  }

  int v8 = (void *)sub_100506650(v7, (unsigned __int16)(a3 - 1));
  int v9 = v8;
  if (!v8)
  {
    if (os_log_type_enabled((os_log_t)qword_1008F7598, OS_LOG_TYPE_ERROR)) {
      sub_100682304();
    }
LABEL_11:
    uint64_t v10 = 21LL;
    goto LABEL_18;
  }

  sub_10046DAE8(v8, 0LL, (uint64_t)v13);
  if (SBYTE7(v19) < 0) {
    operator delete(__p[0]);
  }
  *(_OWORD *)std::string __p = *(_OWORD *)v13;
  *(void *)&__int128 v19 = v14;
  HIBYTE(v14) = 0;
  LOBYTE(v13[0]) = 0;
  DWORD2(v19) = v15;
  if (SHIBYTE(v21) < 0)
  {
    operator delete(v20[0]);
    *(_OWORD *)uint64_t v20 = v16;
    uint64_t v21 = v17;
    HIBYTE(v17) = 0;
    LOBYTE(v16) = 0;
    if (SHIBYTE(v14) < 0) {
      operator delete(v13[0]);
    }
  }

  else
  {
    *(_OWORD *)uint64_t v20 = v16;
    uint64_t v21 = v17;
  }

  (*(void (**)(void *))(*v9 + 8LL))(v9);
  if ((SBYTE7(v19) & 0x80u) == 0) {
    char v11 = __p;
  }
  else {
    char v11 = (void **)__p[0];
  }
  sub_10054A384(v13, v11);
  uint64_t v10 = sub_10046A3BC(a1, a2, (uint64_t)v13);
  sub_10054A428(v13);
LABEL_18:
  if (SHIBYTE(v21) < 0) {
    operator delete(v20[0]);
  }
  if (SBYTE7(v19) < 0) {
    operator delete(__p[0]);
  }
  return v10;
}

void sub_10046A874(_Unwind_Exception *a1, uint64_t a2, ...)
{
  uint64_t v3 = va_arg(va1, void);
  uint64_t v5 = va_arg(va1, void);
  uint64_t v6 = va_arg(va1, void);
  uint64_t v7 = va_arg(va1, void);
  uint64_t v8 = va_arg(va1, void);
  uint64_t v9 = va_arg(va1, void);
  uint64_t v10 = va_arg(va1, void);
  sub_10054A428((uint64_t *)va);
  sub_10046DBE4((uint64_t)va1);
  _Unwind_Resume(a1);
}

uint64_t sub_10046A8A0(uint64_t a1, uint64_t a2, int a3)
{
  char v4 = a3 - 35;
  if ((a3 - 35) < 0x17 && ((0x7FE081u >> v4) & 1) != 0)
  {
    uint64_t v6 = dword_1006C32EC[v4];
    uint64_t v7 = (os_log_s *)qword_1008F7598;
    if (os_log_type_enabled((os_log_t)qword_1008F7598, OS_LOG_TYPE_DEFAULT))
    {
      v11[0] = 67109120;
      v11[1] = a3;
      _os_log_impl((void *)&_mh_execute_header, v7, OS_LOG_TYPE_DEFAULT, "Playing DTMF tone %c", (uint8_t *)v11, 8u);
    }

    uint64_t v8 = CFURLCreateWithFileSystemPath( kCFAllocatorDefault,  @"/System/Library/Frameworks/AudioToolbox.framework",  kCFURLPOSIXPathStyle,  1u);
    uint64_t v9 = CFBundleCreate(kCFAllocatorDefault, v8);
    FunctionPointerForName = (void (*)(uint64_t))CFBundleGetFunctionPointerForName( v9,  @"AudioServicesPlaySystemSound");
    FunctionPointerForName(v6);
    CFRelease(v9);
    CFRelease(v8);
    if (qword_1008D90F8 != -1) {
      dispatch_once(&qword_1008D90F8, &stru_10089A050);
    }
    else {
      return 255LL;
    }
  }

  else
  {
    uint64_t result = os_log_type_enabled((os_log_t)qword_1008F7598, OS_LOG_TYPE_ERROR);
    if ((_DWORD)result)
    {
      sub_100682330();
      return 0LL;
    }
  }

  return result;
}

uint64_t sub_10046AA48(uint64_t a1, unsigned int a2)
{
  uint64_t v27 = 0LL;
  uint64_t v28 = 0LL;
  uint64_t v29 = 0LL;
  sub_100206854(a1 + 360, (int)&v27);
  if (sub_100411018(a1) == 1)
  {
    char v4 = sub_10045CF60(a1, a2);
    if (v4) {
      sub_1001FFA38((uint64_t)(v4 + 50), 1);
    }
  }

  sub_100206678(a1 + 360);
  if (!sub_10053C918(&v27) && !sub_10053C8E4(&v27))
  {
    if (os_log_type_enabled((os_log_t)qword_1008F7598, OS_LOG_TYPE_ERROR)) {
      sub_1006823BC();
    }
    goto LABEL_28;
  }

  if (!sub_100206804(a1 + 360, 1))
  {
    uint64_t v5 = (os_log_s *)qword_1008F7598;
    if (os_log_type_enabled((os_log_t)qword_1008F7598, OS_LOG_TYPE_ERROR))
    {
      int v24 = sub_1002067C0(a1 + 360);
      sub_1002064C4(&v24, buf);
      int v16 = v26;
      uint64_t v17 = *(uint8_t **)buf;
      int v21 = 1;
      sub_1002064C4(&v21, v22);
      uint64_t v18 = buf;
      if (v16 < 0) {
        uint64_t v18 = v17;
      }
      if (v23 >= 0) {
        __int128 v19 = v22;
      }
      else {
        __int128 v19 = (void **)v22[0];
      }
      *(_DWORD *)int v31 = 136446466;
      uint64_t v32 = v18;
      __int16 v33 = 2082;
      BOOL v34 = v19;
      _os_log_error_impl( (void *)&_mh_execute_header,  v5,  OS_LOG_TYPE_ERROR,  "Unexpected answer event as our call setup state is %{public}s, not %{public}s",  v31,  0x16u);
      if (v23 < 0) {
        operator delete(v22[0]);
      }
      if (v26 < 0) {
        operator delete(*(void **)buf);
      }
    }
  }

  if (v27 == v28)
  {
LABEL_21:
    if (os_log_type_enabled((os_log_t)qword_1008F7598, OS_LOG_TYPE_ERROR)) {
      sub_100682390();
    }
    goto LABEL_28;
  }

  uint64_t v6 = v27 + 104;
  while (1)
  {
    int v7 = *(_DWORD *)(v6 - 88);
    if (v7 == 5) {
      break;
    }
    BOOL v8 = v7 == 6 || v6 == v28;
    v6 += 104LL;
    if (v8)
    {
      if (v7 != 6) {
        goto LABEL_21;
      }
      break;
    }
  }

  if (qword_1008D90F8 != -1) {
    dispatch_once(&qword_1008D90F8, &stru_10089A050);
  }
  uint64_t v9 = off_1008D90F0;
  else {
    std::string __p = v30;
  }
  int v10 = sub_10054AA6C((uint64_t)v9, (uint64_t)&__p);
  int v11 = v10;
  if ((char)__p.__r_.__value_.__s.__size_ < 0)
  {
    operator delete(__p.__r_.__value_.__l.__data_);
    if (v11) {
      goto LABEL_28;
    }
  }

  else if (v10)
  {
LABEL_28:
    uint64_t v12 = 0LL;
    goto LABEL_29;
  }

  uint64_t v14 = sub_10045CF60(a1, a2);
  if (sub_100207624((uint64_t)(v14 + 50)))
  {
    LOBYTE(v22[0]) = 0;
    v31[0] = 0;
    LOBYTE(v24) = 0;
    int v15 = (os_log_s *)qword_1008F7598;
    if (os_log_type_enabled((os_log_t)qword_1008F7598, OS_LOG_TYPE_DEFAULT))
    {
      *(_WORD *)std::string buf = 0;
      _os_log_impl( (void *)&_mh_execute_header,  v15,  OS_LOG_TYPE_DEFAULT,  "This kit requires a hack to answer incoming calls.",  buf,  2u);
    }

    buf[0] = 0;
    sub_100242CA4(buf);
    sub_1000F0F28((BOOL *)v22, v31, &v24);
    sub_1000EFA28(a2, 1);
    sub_1000EFB4C(a2, 0);
    sub_100242CD0(buf);
    sub_100242CD8(buf);
  }

  uint64_t v12 = 255LL;
LABEL_29:
  *(void *)std::string buf = &v27;
  sub_1002077E0((void ***)buf);
  return v12;
}

void sub_10046ADE8( _Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, int a11, __int16 a12, char a13, char a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, char *__p, uint64_t a21, int a22, __int16 a23, char a24, char a25, uint64_t a26, char a27)
{
  std::string __p = &a27;
  sub_1002077E0((void ***)&__p);
  _Unwind_Resume(a1);
}

uint64_t sub_10046AE6C(uint64_t a1, unsigned int a2)
{
  v26[0] = 0LL;
  v26[1] = 0LL;
  sub_100242F28((uint64_t)v26, a1 + 760);
  char v4 = sub_10045CF60(a1, a2);
  uint64_t v5 = sub_1004615C4(a1, a2);
  if (v4) {
    sub_1001FFA38((uint64_t)(v4 + 50), 0);
  }
  uint64_t v6 = a1 + 360;
  if (sub_1002065BC(a1 + 360) || sub_1002065C4(a1 + 360))
  {
    int v7 = sub_1002065DC(a1 + 360);
    BOOL v8 = (os_log_s *)qword_1008F7598;
    BOOL v9 = os_log_type_enabled((os_log_t)qword_1008F7598, OS_LOG_TYPE_DEFAULT);
    if (!v7)
    {
      if (v9)
      {
        *(_WORD *)std::string buf = 0;
        _os_log_impl((void *)&_mh_execute_header, v8, OS_LOG_TYPE_DEFAULT, "Found incoming call to reject", buf, 2u);
      }

      uint64_t v12 = sub_10046DC24(a1, a2);
      goto LABEL_23;
    }

    if (v9)
    {
      *(_WORD *)std::string buf = 0;
      _os_log_impl( (void *)&_mh_execute_header,  v8,  OS_LOG_TYPE_DEFAULT,  "We have both an incoming and active call, hanging up the active call.",  buf,  2u);
    }
  }

  if (sub_1002065DC(a1 + 360) || sub_1002065E4(a1 + 360))
  {
    int v10 = (os_log_s *)qword_1008F7598;
    if (os_log_type_enabled((os_log_t)qword_1008F7598, OS_LOG_TYPE_DEFAULT))
    {
      *(_WORD *)std::string buf = 0;
      _os_log_impl((void *)&_mh_execute_header, v10, OS_LOG_TYPE_DEFAULT, "Found active call to hang up", buf, 2u);
    }

    if (v4) {
      sub_100207544((uint64_t)(v4 + 50), 1);
    }
    if (qword_1008D90F8 != -1) {
      dispatch_once(&qword_1008D90F8, &stru_10089A050);
    }
    int v11 = sub_10054AB14((uint64_t)off_1008D90F0);
LABEL_17:
    if (v11) {
      uint64_t v12 = 0LL;
    }
    else {
      uint64_t v12 = 255LL;
    }
    goto LABEL_23;
  }

  if (sub_100206648(a1 + 360))
  {
    uint64_t v14 = (os_log_s *)qword_1008F7598;
    if (os_log_type_enabled((os_log_t)qword_1008F7598, OS_LOG_TYPE_DEFAULT))
    {
      *(_WORD *)std::string buf = 0;
      _os_log_impl( (void *)&_mh_execute_header,  v14,  OS_LOG_TYPE_DEFAULT,  "Found ongoing virtual call - Acking device and notifying upper layers.",  buf,  2u);
    }

    sub_100411948(a1, v5, 104, 0);
    uint64_t v12 = 255LL;
  }

  else
  {
    int v15 = sub_1002065EC(a1 + 360);
    int v16 = (os_log_s *)qword_1008F7598;
    if (v15)
    {
      if (os_log_type_enabled((os_log_t)qword_1008F7598, OS_LOG_TYPE_DEFAULT))
      {
        *(_WORD *)std::string buf = 0;
        _os_log_impl((void *)&_mh_execute_header, v16, OS_LOG_TYPE_DEFAULT, "Hanging up held call.", buf, 2u);
      }

      if (qword_1008D90F8 != -1) {
        dispatch_once(&qword_1008D90F8, &stru_10089A050);
      }
      int v11 = sub_10054AB24((uint64_t)off_1008D90F0);
      goto LABEL_17;
    }

    if (os_log_type_enabled((os_log_t)qword_1008F7598, OS_LOG_TYPE_ERROR))
    {
      *(_WORD *)std::string buf = 0;
      _os_log_error_impl( (void *)&_mh_execute_header,  v16,  OS_LOG_TYPE_ERROR,  "Hangup event was unexpected - dumping state and call list...",  buf,  2u);
      int v16 = (os_log_s *)qword_1008F7598;
    }

    if (os_log_type_enabled(v16, OS_LOG_TYPE_ERROR))
    {
      int v23 = sub_1002067C0(v6);
      uint64_t v17 = v24;
      sub_1002064C4(&v23, v24);
      if (v25 < 0) {
        uint64_t v17 = (void **)v24[0];
      }
      uint64_t v18 = "no";
      if (sub_1002065BC(v6)) {
        __int128 v19 = "yes";
      }
      else {
        __int128 v19 = "no";
      }
      if (sub_1002065C4(v6)) {
        uint64_t v18 = "yes";
      }
      sub_100206854(v6, (int)v21);
      sub_10053C68C(v21, &__p);
      if ((__p.__r_.__value_.__s.__size_ & 0x80u) == 0) {
        p_p = &__p;
      }
      else {
        p_p = (std::string *)__p.__r_.__value_.__r.__words[0];
      }
      *(_DWORD *)std::string buf = 136446978;
      uint64_t v29 = v17;
      __int16 v30 = 2082;
      int v31 = v19;
      __int16 v32 = 2082;
      __int16 v33 = v18;
      __int16 v34 = 2082;
      BOOL v35 = p_p;
      _os_log_error_impl( (void *)&_mh_execute_header,  v16,  OS_LOG_TYPE_ERROR,  "callSetup: %{public}s, callRinging: %{public}s, callWaiting: %{public}s, calls: %{public}s",  buf,  0x2Au);
      uint64_t v27 = (void **)v21;
      sub_1002077E0(&v27);
      if (v25 < 0) {
        operator delete(v24[0]);
      }
    }

    uint64_t v12 = 0LL;
  }

void sub_10046B2C4( _Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, void *__p, uint64_t a18, int a19, __int16 a20, char a21, char a22, char a23, uint64_t a24, uint64_t a25)
{
  if (a22 < 0) {
    operator delete(__p);
  }
  sub_100242FAC((uint64_t)&a23);
  _Unwind_Resume(a1);
}

uint64_t sub_10046B318(uint64_t a1, uint64_t a2)
{
  int v4 = *(_DWORD *)(a2 + 8);
  uint64_t v5 = sub_1004615C4(a1, *(unsigned __int16 *)(a2 + 4));
  switch(v4)
  {
    case 0:
      uint64_t v6 = (os_log_s *)qword_1008F7598;
      if (os_log_type_enabled((os_log_t)qword_1008F7598, OS_LOG_TYPE_DEFAULT))
      {
        if (v5)
        {
          sub_1003CF00C(v5, __p);
          if (v26 >= 0) {
            int v7 = __p;
          }
          else {
            int v7 = (void **)__p[0];
          }
          *(_DWORD *)std::string buf = 136446210;
          v28[0] = v7;
          _os_log_impl( (void *)&_mh_execute_header,  v6,  OS_LOG_TYPE_DEFAULT,  "Received release held calls event from device %{public}s",  buf,  0xCu);
          if (v26 < 0) {
            operator delete(__p[0]);
          }
        }

        else
        {
          *(_DWORD *)std::string buf = 136446210;
          v28[0] = "NULL";
          _os_log_impl( (void *)&_mh_execute_header,  v6,  OS_LOG_TYPE_DEFAULT,  "Received release held calls event from device %{public}s",  buf,  0xCu);
        }
      }

      return sub_10046BE80(a1, *(unsigned __int16 *)(a2 + 4));
    case 1:
      uint64_t v14 = (os_log_s *)qword_1008F7598;
      if (os_log_type_enabled((os_log_t)qword_1008F7598, OS_LOG_TYPE_DEFAULT))
      {
        if (v5)
        {
          sub_1003CF00C(v5, __p);
          if (v26 >= 0) {
            int v15 = __p;
          }
          else {
            int v15 = (void **)__p[0];
          }
          *(_DWORD *)std::string buf = 136446210;
          v28[0] = v15;
          _os_log_impl( (void *)&_mh_execute_header,  v14,  OS_LOG_TYPE_DEFAULT,  "Received release active calls and answer incoming call event from device %{public}s",  buf,  0xCu);
          if (v26 < 0) {
            operator delete(__p[0]);
          }
        }

        else
        {
          *(_DWORD *)std::string buf = 136446210;
          v28[0] = "NULL";
          _os_log_impl( (void *)&_mh_execute_header,  v14,  OS_LOG_TYPE_DEFAULT,  "Received release active calls and answer incoming call event from device %{public}s",  buf,  0xCu);
        }
      }

      return sub_10046C08C(a1, *(unsigned __int16 *)(a2 + 4));
    case 2:
      int v16 = (os_log_s *)qword_1008F7598;
      if (os_log_type_enabled((os_log_t)qword_1008F7598, OS_LOG_TYPE_DEFAULT))
      {
        if (v5)
        {
          sub_1003CF00C(v5, __p);
          if (v26 >= 0) {
            uint64_t v17 = __p;
          }
          else {
            uint64_t v17 = (void **)__p[0];
          }
          *(_DWORD *)std::string buf = 136446210;
          v28[0] = v17;
          _os_log_impl( (void *)&_mh_execute_header,  v16,  OS_LOG_TYPE_DEFAULT,  "Received hold active calls event from device %{public}s",  buf,  0xCu);
          if (v26 < 0) {
            operator delete(__p[0]);
          }
        }

        else
        {
          *(_DWORD *)std::string buf = 136446210;
          v28[0] = "NULL";
          _os_log_impl( (void *)&_mh_execute_header,  v16,  OS_LOG_TYPE_DEFAULT,  "Received hold active calls event from device %{public}s",  buf,  0xCu);
        }
      }

      return sub_10046C434(a1, *(unsigned __int16 *)(a2 + 4));
    case 3:
      uint64_t v18 = (os_log_s *)qword_1008F7598;
      if (os_log_type_enabled((os_log_t)qword_1008F7598, OS_LOG_TYPE_DEFAULT))
      {
        if (v5)
        {
          sub_1003CF00C(v5, __p);
          if (v26 >= 0) {
            __int128 v19 = __p;
          }
          else {
            __int128 v19 = (void **)__p[0];
          }
          *(_DWORD *)std::string buf = 136446210;
          v28[0] = v19;
          _os_log_impl( (void *)&_mh_execute_header,  v18,  OS_LOG_TYPE_DEFAULT,  "Received add held call event from device %{public}s",  buf,  0xCu);
          if (v26 < 0) {
            operator delete(__p[0]);
          }
        }

        else
        {
          *(_DWORD *)std::string buf = 136446210;
          v28[0] = "NULL";
          _os_log_impl( (void *)&_mh_execute_header,  v18,  OS_LOG_TYPE_DEFAULT,  "Received add held call event from device %{public}s",  buf,  0xCu);
        }
      }

      return sub_10046C790(a1);
    case 4:
      uint64_t v20 = (os_log_s *)qword_1008F7598;
      if (os_log_type_enabled((os_log_t)qword_1008F7598, OS_LOG_TYPE_DEFAULT))
      {
        if (v5)
        {
          sub_1003CF00C(v5, __p);
          if (v26 >= 0) {
            int v21 = __p;
          }
          else {
            int v21 = (void **)__p[0];
          }
          *(_DWORD *)std::string buf = 136446210;
          v28[0] = v21;
          _os_log_impl( (void *)&_mh_execute_header,  v20,  OS_LOG_TYPE_DEFAULT,  "Received call transfer event from device %{public}s",  buf,  0xCu);
          if (v26 < 0) {
            operator delete(__p[0]);
          }
        }

        else
        {
          *(_DWORD *)std::string buf = 136446210;
          v28[0] = "NULL";
          _os_log_impl( (void *)&_mh_execute_header,  v20,  OS_LOG_TYPE_DEFAULT,  "Received call transfer event from device %{public}s",  buf,  0xCu);
        }
      }

      sub_10046C824();
      return 4LL;
    default:
      if (v4 < 10) {
        goto LABEL_49;
      }
      int v8 = 1;
      unsigned int v9 = v4;
      do
      {
        unsigned int v10 = v9;
        v9 /= 0xAu;
        v8 *= 10;
      }

      while (v10 > 0x63);
      int v11 = v4 - v8 * v9;
      if (v9 == 2)
      {
        int v23 = (os_log_s *)qword_1008F7598;
        if (os_log_type_enabled((os_log_t)qword_1008F7598, OS_LOG_TYPE_DEFAULT))
        {
          if (v5)
          {
            sub_1003CF00C(v5, __p);
            if (v26 >= 0) {
              int v24 = __p;
            }
            else {
              int v24 = (void **)__p[0];
            }
            *(_DWORD *)std::string buf = 67109378;
            LODWORD(v28[0]) = v11;
            WORD2(v28[0]) = 2082;
            *(void *)((char *)v28 + 6) = v24;
            _os_log_impl( (void *)&_mh_execute_header,  v23,  OS_LOG_TYPE_DEFAULT,  "Received private conference event for call index %d from device %{public}s",  buf,  0x12u);
            if (v26 < 0) {
              operator delete(__p[0]);
            }
          }

          else
          {
            *(_DWORD *)std::string buf = 67109378;
            LODWORD(v28[0]) = v11;
            WORD2(v28[0]) = 2082;
            *(void *)((char *)v28 + 6) = "NULL";
            _os_log_impl( (void *)&_mh_execute_header,  v23,  OS_LOG_TYPE_DEFAULT,  "Received private conference event for call index %d from device %{public}s",  buf,  0x12u);
          }
        }

        return sub_10046CE20(a1, 0LL, v11);
      }

      else if (v9 == 1)
      {
        uint64_t v12 = (os_log_s *)qword_1008F7598;
        if (os_log_type_enabled((os_log_t)qword_1008F7598, OS_LOG_TYPE_DEFAULT))
        {
          if (v5)
          {
            sub_1003CF00C(v5, __p);
            if (v26 >= 0) {
              std::string v13 = __p;
            }
            else {
              std::string v13 = (void **)__p[0];
            }
            *(_DWORD *)std::string buf = 67109378;
            LODWORD(v28[0]) = v11;
            WORD2(v28[0]) = 2082;
            *(void *)((char *)v28 + 6) = v13;
            _os_log_impl( (void *)&_mh_execute_header,  v12,  OS_LOG_TYPE_DEFAULT,  "Received release active call event for call index %d from device %{public}s",  buf,  0x12u);
            if (v26 < 0) {
              operator delete(__p[0]);
            }
          }

          else
          {
            *(_DWORD *)std::string buf = 67109378;
            LODWORD(v28[0]) = v11;
            WORD2(v28[0]) = 2082;
            *(void *)((char *)v28 + 6) = "NULL";
            _os_log_impl( (void *)&_mh_execute_header,  v12,  OS_LOG_TYPE_DEFAULT,  "Received release active call event for call index %d from device %{public}s",  buf,  0x12u);
          }
        }

        return sub_10046C868(a1, 0LL, v11);
      }

      else
      {
LABEL_49:
        if (os_log_type_enabled((os_log_t)qword_1008F7598, OS_LOG_TYPE_ERROR)) {
          sub_1006823E8();
        }
        return 4LL;
      }
  }

uint64_t sub_10046BA20(uint64_t a1, unsigned int a2)
{
  uint64_t v28 = 0LL;
  uint64_t v29 = 0LL;
  uint64_t v30 = 0LL;
  sub_10053C3D8(&v28);
  __int128 __p = 0uLL;
  uint64_t v27 = 0LL;
  uint64_t v25 = 0LL;
  __int128 v24 = 0u;
  memset(v23, 0, sizeof(v23));
  sub_10054A050(v23);
  uint64_t v4 = sub_1004615C4(a1, a2);
  uint64_t v5 = a1 + 360;
  if ((sub_100206658(v5) & 1) != 0 || (sub_100206670(v5) & 1) != 0) {
    goto LABEL_35;
  }
  sub_100206854(v5, (int)v21);
  sub_10020789C( (uint64_t)&v28,  (uint64_t)v21[0],  (uint64_t)v21[1],  0x4EC4EC4EC4EC4EC5LL * (((char *)v21[1] - (char *)v21[0]) >> 3));
  v20.__r_.__value_.__r.__words[0] = (std::string::size_type)v21;
  sub_1002077E0((void ***)&v20);
  uint64_t v6 = v28;
  if (v28 == v29) {
    goto LABEL_34;
  }
  while (1)
  {
    int v7 = *(_DWORD *)(v6 + 16) - 1;
    if (v7 >= 7)
    {
      uint64_t v14 = (os_log_s *)qword_1008F7598;
      if (os_log_type_enabled((os_log_t)qword_1008F7598, OS_LOG_TYPE_ERROR))
      {
        sub_10046DE34(v6, v21);
        int v15 = v21;
        if (v22 < 0) {
          int v15 = (void **)v21[0];
        }
        *(_DWORD *)std::string buf = 136315138;
        __int16 v33 = v15;
        _os_log_error_impl( (void *)&_mh_execute_header,  v14,  OS_LOG_TYPE_ERROR,  "Found invalid call status - skipping call: %s",  buf,  0xCu);
        if (SHIBYTE(v22) < 0) {
          operator delete(v21[0]);
        }
      }

      goto LABEL_29;
    }

    unsigned int v8 = dword_1006C3348[v7];
    sub_10054A44C((std::string *)v23, v6 + 24);
    uint64_t v9 = *(unsigned int *)(v6 + 8);
    int v10 = *(unsigned __int8 *)(v6 + 12);
    int v11 = *(unsigned __int8 *)(v6 + 13);
    sub_100461890((char *)(v6 + 80), v4, (uint64_t)v21);
    if (SHIBYTE(v27) < 0) {
      operator delete((void *)__p);
    }
    __int128 __p = *(_OWORD *)v21;
    uint64_t v27 = v22;
    LOBYTE(v21[0]) = 0;
    sub_100242CA4(v21);
    BOOL v12 = sub_10054A42C((uint64_t)v23);
    if (v12)
    {
      std::string v13 = 0LL;
    }

    else
    {
      sub_10054A580((uint64_t)v23, &v20);
      std::string v13 = (v20.__r_.__value_.__s.__size_ & 0x80u) == 0 ? &v20 : (std::string *)v20.__r_.__value_.__r.__words[0];
    }

    if (SHIBYTE(v27) < 0)
    {
      p_p = *((void *)&__p + 1) ? (const char *)__p : 0LL;
    }

    else
    {
      p_p = (const char *)&__p;
      if (!HIBYTE(v27)) {
        p_p = 0LL;
      }
    }

    int v17 = sub_1000F0A60(a2, v9, v10 == 0, v8, 0, v11 != 0, (const char *)v13, v23[24], p_p);
    sub_100242CD0(v21);
    if (v17) {
      break;
    }
    sub_10053C464(v31, v6);
    sub_100242CD8(v21);
LABEL_29:
    v6 += 104LL;
    if (v6 == v29) {
      goto LABEL_34;
    }
  }

  if (os_log_type_enabled((os_log_t)qword_1008F7598, OS_LOG_TYPE_ERROR)) {
    sub_100682448();
  }
  sub_100242CD8(v21);
LABEL_34:
  sub_10053C460((int)v19);
  sub_100206610(v5, v19);
  v21[0] = v19;
  sub_1002077E0((void ***)v21);
LABEL_35:
  sub_10054A428(v23);
  if (SHIBYTE(v27) < 0) {
    operator delete((void *)__p);
  }
  *(void *)int v23 = &v28;
  sub_1002077E0((void ***)v23);
  *(void *)int v23 = v31;
  sub_1002077E0((void ***)v23);
  return 255LL;
}

void sub_10046BDB8( _Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, void *a17, uint64_t a18, int a19, __int16 a20, char a21, char a22, uint64_t a23, uint64_t a24, uint64_t a25, uint64_t a26, uint64_t a27, uint64_t a28, uint64_t a29, uint64_t a30, uint64_t a31, uint64_t a32, uint64_t a33, void *__p, uint64_t a35, int a36, __int16 a37, char a38, char a39)
{
  if (a39 < 0) {
    operator delete(__p);
  }
  a26 = v39 - 176;
  sub_1002077E0((void ***)&a26);
  a26 = v39 - 152;
  sub_1002077E0((void ***)&a26);
  _Unwind_Resume(a1);
}

uint64_t sub_10046BE80(uint64_t a1, unsigned int a2)
{
  BOOL v12 = (void **)&v8;
  sub_1002077E0(&v12);
  int v4 = sub_1002067C0(a1 + 360);
  if (sub_10053C918(v10) || sub_10053C8E4(v10))
  {
    uint64_t v5 = sub_10046DC24(a1, a2);
    goto LABEL_14;
  }

  if (v4)
  {
    if (os_log_type_enabled((os_log_t)qword_1008F7598, OS_LOG_TYPE_ERROR))
    {
      int v7 = sub_1002067C0(a1 + 360);
      sub_1002064C4(&v7, &v8);
      sub_1006824D4();
    }

void sub_10046C048( _Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, void **a10, uint64_t a11, uint64_t a12, char a13)
{
  a10 = (void **)&a13;
  sub_1002077E0(&a10);
  _Unwind_Resume(a1);
}

uint64_t sub_10046C08C(uint64_t a1, unsigned int a2)
{
  uint64_t v3 = a1 + 360;
  if (sub_1002065C4(v3))
  {
    if (!sub_100206804(v3, 1))
    {
      int v4 = (os_log_s *)qword_1008F7598;
      if (os_log_type_enabled((os_log_t)qword_1008F7598, OS_LOG_TYPE_ERROR))
      {
        int v19 = sub_1002067C0(v3);
        sub_1002064C4(&v19, v20);
        int v10 = v21;
        int v11 = (void **)v20[0];
        int v16 = 1;
        sub_1002064C4(&v16, v17);
        BOOL v12 = v20;
        if (v10 < 0) {
          BOOL v12 = v11;
        }
        if (v18 >= 0) {
          std::string v13 = v17;
        }
        else {
          std::string v13 = (void **)v17[0];
        }
        *(_DWORD *)std::string buf = 136446466;
        __int128 v24 = v12;
        __int16 v25 = 2082;
        char v26 = v13;
        _os_log_error_impl( (void *)&_mh_execute_header,  v4,  OS_LOG_TYPE_ERROR,  "Unexpected release active calls event as our call setup state is %{public}s, not %{public}s",  buf,  0x16u);
        if (v18 < 0) {
          operator delete(v17[0]);
        }
        if (v21 < 0) {
          operator delete(v20[0]);
        }
      }
    }

    if (qword_1008D90F8 != -1) {
      dispatch_once(&qword_1008D90F8, &stru_10089A050);
    }
    uint64_t v5 = off_1008D90F0;
    else {
      std::string __dst = v22;
    }
    else {
      uint64_t v7 = 255LL;
    }
    if ((char)__dst.__r_.__value_.__s.__size_ < 0)
    {
      uint64_t v8 = (void *)__dst.__r_.__value_.__r.__words[0];
LABEL_35:
      operator delete(v8);
      goto LABEL_39;
    }

    goto LABEL_39;
  }

  if (!sub_100206804(v3, 0))
  {
    if (sub_1002065E4(v3))
    {
      if (qword_1008D90F8 != -1) {
        dispatch_once(&qword_1008D90F8, &stru_10089A050);
      }
      else {
        uint64_t v7 = 255LL;
      }
      goto LABEL_39;
    }

    if (os_log_type_enabled((os_log_t)qword_1008F7598, OS_LOG_TYPE_ERROR)) {
      sub_100682548();
    }
LABEL_38:
    uint64_t v7 = 0LL;
    goto LABEL_39;
  }

  if (!sub_1002065DC(v3) && !sub_1002065EC(v3))
  {
    if (os_log_type_enabled((os_log_t)qword_1008F7598, OS_LOG_TYPE_ERROR)) {
      sub_10068251C();
    }
    goto LABEL_38;
  }

  if (qword_1008D90F8 != -1) {
    dispatch_once(&qword_1008D90F8, &stru_10089A050);
  }
  uint64_t v6 = off_1008D90F0;
  else {
    std::string __p = v22;
  }
  else {
    uint64_t v7 = 255LL;
  }
  if ((char)__p.__r_.__value_.__s.__size_ < 0)
  {
    uint64_t v8 = (void *)__p.__r_.__value_.__r.__words[0];
    goto LABEL_35;
  }

void sub_10046C3CC( _Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, void *__p, uint64_t a10, int a11, __int16 a12, char a13, char a14, uint64_t a15, uint64_t a16, uint64_t a17, int a18, __int16 a19, char a20, char a21, uint64_t a22, uint64_t a23, uint64_t a24, uint64_t a25, uint64_t a26, uint64_t a27, uint64_t a28, int a29, __int16 a30, char a31, char a32)
{
  if (a14 < 0) {
    operator delete(__p);
  }
  _Unwind_Resume(exception_object);
}

uint64_t sub_10046C434(uint64_t a1, unsigned int a2)
{
  uint64_t v3 = a1 + 360;
  if (sub_1002065C4(a1 + 360))
  {
    if (!sub_100206804(a1 + 360, 1))
    {
      int v4 = (os_log_s *)qword_1008F7598;
      if (os_log_type_enabled((os_log_t)qword_1008F7598, OS_LOG_TYPE_ERROR))
      {
        int v19 = sub_1002067C0(v3);
        sub_1002064C4(&v19, v20);
        int v10 = v21;
        int v11 = (void **)v20[0];
        int v16 = 1;
        sub_1002064C4(&v16, v17);
        BOOL v12 = v20;
        if (v10 < 0) {
          BOOL v12 = v11;
        }
        if (v18 >= 0) {
          std::string v13 = v17;
        }
        else {
          std::string v13 = (void **)v17[0];
        }
        *(_DWORD *)std::string buf = 136446466;
        __int128 v24 = v12;
        __int16 v25 = 2082;
        char v26 = v13;
        _os_log_error_impl( (void *)&_mh_execute_header,  v4,  OS_LOG_TYPE_ERROR,  "Unexpected hold active calls event as our call setup state is %{public}s, not %{public}s",  buf,  0x16u);
        if (v18 < 0) {
          operator delete(v17[0]);
        }
        if (v21 < 0) {
          operator delete(v20[0]);
        }
      }
    }

    if (qword_1008D90F8 != -1) {
      dispatch_once(&qword_1008D90F8, &stru_10089A050);
    }
    uint64_t v5 = off_1008D90F0;
    else {
      std::string __dst = v22;
    }
    else {
      uint64_t v7 = 255LL;
    }
    if ((char)__dst.__r_.__value_.__s.__size_ < 0)
    {
      uint64_t v8 = (void *)__dst.__r_.__value_.__r.__words[0];
LABEL_30:
      operator delete(v8);
    }
  }

  else if (sub_100206804(a1 + 360, 0))
  {
    if (sub_1002065DC(a1 + 360) || sub_1002065EC(a1 + 360))
    {
      if (qword_1008D90F8 != -1) {
        dispatch_once(&qword_1008D90F8, &stru_10089A050);
      }
      uint64_t v6 = off_1008D90F0;
      else {
        std::string __p = v22;
      }
      else {
        uint64_t v7 = 255LL;
      }
      if ((char)__p.__r_.__value_.__s.__size_ < 0)
      {
        uint64_t v8 = (void *)__p.__r_.__value_.__r.__words[0];
        goto LABEL_30;
      }
    }

    else
    {
      if (os_log_type_enabled((os_log_t)qword_1008F7598, OS_LOG_TYPE_ERROR)) {
        sub_100682574();
      }
      uint64_t v7 = 0LL;
    }
  }

  else
  {
    if (os_log_type_enabled((os_log_t)qword_1008F7598, OS_LOG_TYPE_ERROR)) {
      sub_1006825A0();
    }
    uint64_t v7 = 3LL;
  }

  return v7;
}

void sub_10046C728( _Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, void *__p, uint64_t a10, int a11, __int16 a12, char a13, char a14, uint64_t a15, uint64_t a16, uint64_t a17, int a18, __int16 a19, char a20, char a21, uint64_t a22, uint64_t a23, uint64_t a24, uint64_t a25, uint64_t a26, uint64_t a27, uint64_t a28, int a29, __int16 a30, char a31, char a32)
{
  if (a14 < 0) {
    operator delete(__p);
  }
  _Unwind_Resume(exception_object);
}

uint64_t sub_10046C790(uint64_t a1)
{
  if (sub_1002065EC(a1 + 360))
  {
    if (qword_1008D90F8 != -1) {
      dispatch_once(&qword_1008D90F8, &stru_10089A050);
    }
    else {
      return 255LL;
    }
  }

  else
  {
    uint64_t result = os_log_type_enabled((os_log_t)qword_1008F7598, OS_LOG_TYPE_ERROR);
    if ((_DWORD)result)
    {
      sub_1006825CC();
      return 0LL;
    }
  }

  return result;
}

uint64_t sub_10046C824()
{
  if (os_log_type_enabled((os_log_t)qword_1008F7598, OS_LOG_TYPE_ERROR)) {
    sub_1006825F8();
  }
  return 4LL;
}

uint64_t sub_10046C868(uint64_t a1, uint64_t a2, int a3)
{
  uint64_t v32 = 0LL;
  __int16 v33 = 0LL;
  uint64_t v34 = 0LL;
  uint64_t v4 = a1 + 360;
  sub_100206604((int)&v32);
  uint64_t v29 = 0LL;
  uint64_t v30 = 0LL;
  uint64_t v31 = 0LL;
  sub_100206854(v4, (int)&v29);
  memset(uu, 0, sizeof(uu));
  uuid_clear(uu);
  if (qword_1008D90F8 != -1) {
    dispatch_once(&qword_1008D90F8, &stru_10089A050);
  }
  if ((sub_10054ADF8((uint64_t)off_1008D90F0) & 1) != 0)
  {
    if (a3)
    {
      uint64_t v5 = (id *)sub_10053C610((uint64_t *)&v32, a3);
      uint64_t v6 = (uint64_t)v5;
      if (v33 == v5)
      {
        int v16 = (id *)sub_10053C610((uint64_t *)&v29, a3);
        uint64_t v17 = (uint64_t)v16;
        if (v30 != v16)
        {
          id v18 = *v16;
          sub_100241F90(src, v18);
          uuid_copy(uu, src);

          if (uuid_is_null(uu))
          {
            if (os_log_type_enabled((os_log_t)qword_1008F7598, OS_LOG_TYPE_ERROR))
            {
              sub_10046DE34(v17, src);
              sub_100682684();
            }
          }
        }
      }

      else
      {
        id v7 = *v5;
        sub_100241F90(src, v7);
        uuid_copy(uu, src);

        if (uuid_is_null(uu) && os_log_type_enabled((os_log_t)qword_1008F7598, OS_LOG_TYPE_ERROR))
        {
          sub_10046DE34(v6, src);
          sub_1006826CC();
        }
      }
    }

    else
    {
      uint64_t v9 = (os_log_s *)qword_1008F7598;
      if (os_log_type_enabled((os_log_t)qword_1008F7598, OS_LOG_TYPE_DEFAULT))
      {
        *(_WORD *)src = 0;
        _os_log_impl( (void *)&_mh_execute_header,  v9,  OS_LOG_TYPE_DEFAULT,  "Allowing zero index release active call command - finding index of oldest call",  src,  2u);
      }

      uint64_t v10 = (uint64_t)v32;
      if (v32 == v33) {
        goto LABEL_30;
      }
      int v11 = 0;
      do
      {
        int v12 = *(_DWORD *)(v10 + 8);
        if (!v11 || v12 < v11)
        {
          id v13 = *(id *)v10;
          sub_100241F90(src, v13);
          uuid_copy(uu, src);

          if (uuid_is_null(uu))
          {
            uint64_t v14 = (os_log_s *)qword_1008F7598;
            if (os_log_type_enabled((os_log_t)qword_1008F7598, OS_LOG_TYPE_ERROR))
            {
              sub_10046DE34(v10, src);
              int v15 = src;
              if (v36 < 0) {
                int v15 = *(unsigned __int8 **)src;
              }
              *(_DWORD *)std::string buf = 67109378;
              int v38 = v12;
              __int16 v39 = 2080;
              uint64_t v40 = v15;
              _os_log_error_impl( (void *)&_mh_execute_header,  v14,  OS_LOG_TYPE_ERROR,  "Found invalid call in sent calls at index %d (call: %s)",  buf,  0x12u);
              if (v36 < 0) {
                operator delete(*(void **)src);
              }
            }
          }

          int v11 = v12;
        }

        v10 += 104LL;
      }

      while ((id *)v10 != v33);
      if (!v11)
      {
LABEL_30:
        int v19 = v29;
        if (v29 != v30)
        {
          int v20 = 0;
          do
          {
            int v21 = *((_DWORD *)v19 + 2);
            if (!v20 || v21 < v20)
            {
              id v22 = *v19;
              sub_100241F90(src, v22);
              uuid_copy(uu, src);

              if (uuid_is_null(uu))
              {
                int v23 = (os_log_s *)qword_1008F7598;
                if (os_log_type_enabled((os_log_t)qword_1008F7598, OS_LOG_TYPE_ERROR))
                {
                  sub_10046DE34((uint64_t)v19, src);
                  __int128 v24 = v36 >= 0 ? src : *(unsigned __int8 **)src;
                  *(_DWORD *)std::string buf = 67109378;
                  int v38 = v21;
                  __int16 v39 = 2080;
                  uint64_t v40 = v24;
                  _os_log_error_impl( (void *)&_mh_execute_header,  v23,  OS_LOG_TYPE_ERROR,  "Found invalid call in current calls at index %d (call: %s)",  buf,  0x12u);
                  if (v36 < 0) {
                    operator delete(*(void **)src);
                  }
                }
              }

              int v20 = v21;
            }

            v19 += 13;
          }

          while (v19 != v30);
        }
      }
    }

    if (uuid_is_null(uu))
    {
      if (os_log_type_enabled((os_log_t)qword_1008F7598, OS_LOG_TYPE_ERROR)) {
        sub_100682624();
      }
      uint64_t v8 = 21LL;
    }

    else
    {
      if (qword_1008D90F8 != -1) {
        dispatch_once(&qword_1008D90F8, &stru_10089A050);
      }
      __int16 v25 = off_1008D90F0;
      char v26 = sub_100241F94(uu);
      uint64_t v27 = (void *)objc_claimAutoreleasedReturnValue(v26);
      else {
        uint64_t v8 = 255LL;
      }
    }
  }

  else
  {
    uint64_t v8 = 4LL;
  }

  *(void *)uuid_t uu = &v29;
  sub_1002077E0((void ***)uu);
  uint64_t v29 = (void **)&v32;
  sub_1002077E0(&v29);
  return v8;
}

void sub_10046CD78( _Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, void **a11, uint64_t a12, uint64_t a13, char a14)
{
  *(void *)(v14 - 104) = &a11;
  sub_1002077E0((void ***)(v14 - 104));
  a11 = (void **)&a14;
  sub_1002077E0(&a11);
  _Unwind_Resume(a1);
}

uint64_t sub_10046CE20(uint64_t a1, uint64_t a2, int a3)
{
  uint64_t v32 = 0LL;
  __int16 v33 = 0LL;
  uint64_t v34 = 0LL;
  uint64_t v4 = a1 + 360;
  sub_100206604((int)&v32);
  uint64_t v29 = 0LL;
  uint64_t v30 = 0LL;
  uint64_t v31 = 0LL;
  sub_100206854(v4, (int)&v29);
  memset(uu, 0, sizeof(uu));
  uuid_clear(uu);
  if (qword_1008D90F8 != -1) {
    dispatch_once(&qword_1008D90F8, &stru_10089A050);
  }
  if ((sub_10054ADF8((uint64_t)off_1008D90F0) & 1) != 0)
  {
    if (a3)
    {
      uint64_t v5 = (id *)sub_10053C610((uint64_t *)&v32, a3);
      uint64_t v6 = (uint64_t)v5;
      if (v33 == v5)
      {
        int v16 = (id *)sub_10053C610((uint64_t *)&v29, a3);
        uint64_t v17 = (uint64_t)v16;
        if (v30 != v16)
        {
          id v18 = *v16;
          sub_100241F90(src, v18);
          uuid_copy(uu, src);

          if (uuid_is_null(uu))
          {
            if (os_log_type_enabled((os_log_t)qword_1008F7598, OS_LOG_TYPE_ERROR))
            {
              sub_10046DE34(v17, src);
              sub_100682684();
            }
          }
        }
      }

      else
      {
        id v7 = *v5;
        sub_100241F90(src, v7);
        uuid_copy(uu, src);

        if (uuid_is_null(uu) && os_log_type_enabled((os_log_t)qword_1008F7598, OS_LOG_TYPE_ERROR))
        {
          sub_10046DE34(v6, src);
          sub_1006826CC();
        }
      }
    }

    else
    {
      uint64_t v9 = (os_log_s *)qword_1008F7598;
      if (os_log_type_enabled((os_log_t)qword_1008F7598, OS_LOG_TYPE_DEFAULT))
      {
        *(_WORD *)src = 0;
        _os_log_impl( (void *)&_mh_execute_header,  v9,  OS_LOG_TYPE_DEFAULT,  "Allowing zero index private conference command - finding index of oldest call",  src,  2u);
      }

      uint64_t v10 = (uint64_t)v32;
      if (v32 == v33) {
        goto LABEL_30;
      }
      int v11 = 0;
      do
      {
        int v12 = *(_DWORD *)(v10 + 8);
        if (!v11 || v12 < v11)
        {
          id v13 = *(id *)v10;
          sub_100241F90(src, v13);
          uuid_copy(uu, src);

          if (uuid_is_null(uu))
          {
            uint64_t v14 = (os_log_s *)qword_1008F7598;
            if (os_log_type_enabled((os_log_t)qword_1008F7598, OS_LOG_TYPE_ERROR))
            {
              sub_10046DE34(v10, src);
              int v15 = src;
              if (v36 < 0) {
                int v15 = *(unsigned __int8 **)src;
              }
              *(_DWORD *)std::string buf = 67109378;
              int v38 = v12;
              __int16 v39 = 2080;
              uint64_t v40 = v15;
              _os_log_error_impl( (void *)&_mh_execute_header,  v14,  OS_LOG_TYPE_ERROR,  "Found invalid call in sent calls at index %d (call: %s)",  buf,  0x12u);
              if (v36 < 0) {
                operator delete(*(void **)src);
              }
            }
          }

          int v11 = v12;
        }

        v10 += 104LL;
      }

      while ((id *)v10 != v33);
      if (!v11)
      {
LABEL_30:
        int v19 = v29;
        if (v29 != v30)
        {
          int v20 = 0;
          do
          {
            int v21 = *((_DWORD *)v19 + 2);
            if (!v20 || v21 < v20)
            {
              id v22 = *v19;
              sub_100241F90(src, v22);
              uuid_copy(uu, src);

              if (uuid_is_null(uu))
              {
                int v23 = (os_log_s *)qword_1008F7598;
                if (os_log_type_enabled((os_log_t)qword_1008F7598, OS_LOG_TYPE_ERROR))
                {
                  sub_10046DE34((uint64_t)v19, src);
                  __int128 v24 = v36 >= 0 ? src : *(unsigned __int8 **)src;
                  *(_DWORD *)std::string buf = 67109378;
                  int v38 = v21;
                  __int16 v39 = 2080;
                  uint64_t v40 = v24;
                  _os_log_error_impl( (void *)&_mh_execute_header,  v23,  OS_LOG_TYPE_ERROR,  "Found invalid call in current calls at index %d (call: %s)",  buf,  0x12u);
                  if (v36 < 0) {
                    operator delete(*(void **)src);
                  }
                }
              }

              int v20 = v21;
            }

            v19 += 13;
          }

          while (v19 != v30);
        }
      }
    }

    if (uuid_is_null(uu))
    {
      if (os_log_type_enabled((os_log_t)qword_1008F7598, OS_LOG_TYPE_ERROR)) {
        sub_100682714();
      }
      uint64_t v8 = 21LL;
    }

    else
    {
      if (qword_1008D90F8 != -1) {
        dispatch_once(&qword_1008D90F8, &stru_10089A050);
      }
      __int16 v25 = off_1008D90F0;
      char v26 = sub_100241F94(uu);
      uint64_t v27 = (void *)objc_claimAutoreleasedReturnValue(v26);
      else {
        uint64_t v8 = 255LL;
      }
    }
  }

  else
  {
    uint64_t v8 = 4LL;
  }

  *(void *)uuid_t uu = &v29;
  sub_1002077E0((void ***)uu);
  uint64_t v29 = (void **)&v32;
  sub_1002077E0(&v29);
  return v8;
}

void sub_10046D330( _Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, void **a11, uint64_t a12, uint64_t a13, char a14)
{
  *(void *)(v14 - 104) = &a11;
  sub_1002077E0((void ***)(v14 - 104));
  a11 = (void **)&a14;
  sub_1002077E0(&a11);
  _Unwind_Resume(a1);
}

void sub_10046D3D8(uint64_t a1, int a2, unsigned int a3, int a4)
{
  if (a2)
  {
    if (os_log_type_enabled((os_log_t)qword_1008F7598, OS_LOG_TYPE_ERROR)) {
      sub_100682774();
    }
  }

  else if (a3)
  {
    uint64_t v5 = sub_10045CF60(a1, a3);
    if (v5) {
      sub_100207614((uint64_t)(v5 + 50), a4);
    }
  }

_BYTE *sub_10046D44C(uint64_t a1, uint64_t a2, unsigned int a3, char a4, unsigned int a5)
{
  char v35 = 0;
  sub_100242CA4(&v35);
  uint64_t v6 = a2 + 400;
  int v7 = sub_1002073A4(v6);
  char v8 = sub_1000EF480(v7);
  sub_100242CD0(&v35);
  uint64_t v9 = (os_log_s *)qword_1008F7598;
  if (os_log_type_enabled((os_log_t)qword_1008F7598, OS_LOG_TYPE_DEFAULT))
  {
    int v10 = sub_1002075C4(v6);
    *(_DWORD *)std::string buf = 67109632;
    unsigned int v37 = a3;
    __int16 v38 = 1024;
    unsigned int v39 = a5;
    __int16 v40 = 1024;
    int v41 = v10;
    _os_log_impl( (void *)&_mh_execute_header,  v9,  OS_LOG_TYPE_DEFAULT,  "Initiating SCO connection with delay of %d milliseconds, codec %d, lastCodec %d",  buf,  0x14u);
  }

  if (sub_1002075C4(v6) == a5)
  {
    BOOL v11 = 0;
    if ((v8 & 0x80) == 0)
    {
LABEL_5:
      int v12 = 0;
      goto LABEL_10;
    }
  }

  else
  {
    BOOL v11 = sub_1002075C4(v6) != 0;
    if ((v8 & 0x80) == 0) {
      goto LABEL_5;
    }
  }

  int v12 = sub_1002073D4(v6) != 5 || v11;
LABEL_10:
  id v13 = (unsigned __int8 *)sub_1002073AC(v6);
  uint64_t v14 = v13[128];
  uint64_t v15 = v13[129];
  uint64_t v16 = v13[130];
  uint64_t v17 = v13[131];
  uint64_t v18 = v13[132];
  uint64_t v19 = v13[133];
  uint64_t v20 = sub_1002E6E9C();
  sub_1003D0268((uint64_t)v13);
  uint64_t v31 = (v16 << 16) | (v15 << 8) | (v17 << 24) | (v18 << 32) | (v19 << 40) | v14;
  uint64_t v21 = (*(uint64_t (**)(uint64_t))(*(void *)v20 + 72LL))(v20);
  uint64_t v22 = sub_100461A08(v21, a5);
  unint64_t v23 = (v14 << 40) | (v15 << 32) | (v16 << 24) | (v17 << 16) | (v18 << 8) | v19;
  sub_10046992C(v22, v23, v22 ^ 1);
  if (v12)
  {
    sub_100242C98(&v35);
    unsigned int v24 = sub_1002073A4(v6);
    int v25 = sub_1000F0D28(v24, a5);
    sub_100242CD0(&v35);
    if (v25)
    {
      if (os_log_type_enabled((os_log_t)qword_1008F7598, OS_LOG_TYPE_ERROR)) {
        sub_1006827D4();
      }
      uint64_t v26 = sub_1002E6E9C();
      uint64_t v27 = sub_1003D0268((uint64_t)v13);
      uint64_t v28 = (*(uint64_t (**)(uint64_t, uint64_t, uint64_t, uint64_t, void, void, uint64_t, void))(*(void *)v26 + 72LL))( v26,  v31,  v27,  1LL,  0LL,  0LL,  1LL,  0LL);
      sub_10046992C(v28, v23, 0);
    }
  }

  else
  {
    uint64_t v29 = sub_1002073A4(v6);
    sub_100460F58(v29, v29, a3, a4);
  }

  return sub_100242CD8(&v35);
}

void sub_10046D724( _Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, int a12, __int16 a13, char a14, char a15)
{
}

void sub_10046D754(uint64_t a1)
{
}

void sub_10046D75C(int a1, uint64_t a2, int a3, __int16 a4)
{
  if (a2)
  {
    __int16 v7 = sub_1000F63EC(a2);
    uint64_t v8 = sub_100405058();
    v9[0] = _NSConcreteStackBlock;
    v9[1] = 3221225472LL;
    void v9[2] = sub_100476694;
    _OWORD v9[3] = &unk_10087EB68;
    __int16 v12 = v7;
    int v10 = a1;
    int v11 = a3;
    __int16 v13 = a4;
    sub_100405384(v8, v9);
  }

uint64_t sub_10046D7E4(uint64_t a1, uint64_t a2)
{
  uint64_t v4 = sub_10045D7CC(a1, a2);
  int v5 = sub_1002077B8(v4 + 400);
  uint64_t v6 = (os_log_s *)qword_1008F7598;
  if (os_log_type_enabled((os_log_t)qword_1008F7598, OS_LOG_TYPE_DEFAULT))
  {
    sub_1003CF00C(a2, __p);
    __int16 v7 = v17 >= 0 ? __p : (void **)__p[0];
    *(_DWORD *)std::string buf = 136446466;
    uint64_t v19 = v7;
    __int16 v20 = 1024;
    int v21 = v5;
    _os_log_impl( (void *)&_mh_execute_header,  v6,  OS_LOG_TYPE_DEFAULT,  "Transitioning to HandsfreeAoS - device:%{public}s isInAdvancedSniff:%d",  buf,  0x12u);
    if (v17 < 0) {
      operator delete(__p[0]);
    }
  }

  LOBYTE(__p[0]) = 0;
  sub_100242CA4(__p);
  uint64_t v8 = a2 + 128;
  uint64_t v9 = (unsigned __int16 *)sub_10012D890(a2 + 128);
  sub_100242CD0(__p);
  if (v5)
  {
    unsigned int v10 = sub_10046169C(a1, v8);
    sub_100242C98(__p);
    uint64_t v11 = sub_1000F1044(v10);
  }

  else
  {
    uint64_t v12 = sub_1001F713C(v8);
    uint64_t v13 = sub_1002E6E9C();
    BYTE2(v15) = 1;
    LOWORD(v15) = 2;
    (*(void (**)(uint64_t, void, uint64_t, uint64_t, uint64_t, uint64_t, void, uint64_t, uint64_t, int))(*(void *)v13 + 1520LL))( v13,  *v9,  24LL,  20LL,  8LL,  1LL,  0LL,  v12,  0x2D000000001LL,  v15);
    uint64_t v11 = 0LL;
  }

  sub_100242CD8(__p);
  return v11;
}

void sub_10046D998(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, ...)
{
}

void (*sub_10046D9C0( void *a1, void *a2, void (*a3)(void, void)))(void, void)
{
  if (a1 != a2)
  {
    int v5 = a1;
    do
    {
      a3(*((unsigned __int16 *)v5 + 16), v5[5]);
      uint64_t v6 = (void *)v5[1];
      if (v6)
      {
        do
        {
          __int16 v7 = v6;
          uint64_t v6 = (void *)*v6;
        }

        while (v6);
      }

      else
      {
        do
        {
          __int16 v7 = (void *)v5[2];
          BOOL v8 = *v7 == (void)v5;
          int v5 = v7;
        }

        while (!v8);
      }

      int v5 = v7;
    }

    while (v7 != a2);
  }

  return a3;
}

_BYTE *sub_10046DA3C(unsigned __int16 a1, uint64_t a2)
{
  uint64_t v3 = a2 + 400;
  uint64_t result = (_BYTE *)sub_10020744C(a2 + 400);
  if ((_DWORD)result)
  {
    sub_100207454(v3, 0);
    char v6 = 0;
    sub_100242CA4(&v6);
    int v5 = sub_1000F0548(a1, 0);
    sub_100242CD0(&v6);
    if (v5)
    {
      if (os_log_type_enabled((os_log_t)qword_1008F7598, OS_LOG_TYPE_ERROR)) {
        sub_100682834();
      }
    }

    return sub_100242CD8(&v6);
  }

  return result;
}

void sub_10046DAD4( _Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, int a10, __int16 a11, char a12, char a13)
{
}

void *sub_10046DAE8@<X0>(void *result@<X0>, unint64_t a2@<X1>, uint64_t a3@<X8>)
{
  uint64_t v4 = result[29];
  if (0x6DB6DB6DB6DB6DB7LL * ((result[30] - v4) >> 3) <= a2)
  {
    *(void *)(a3 + sub_100242FAC(v1 - 32) = 0LL;
    *(void *)(a3 + 4sub_100414D2C(qword_1008F72C0, 0) = 0LL;
    *(void *)(a3 + 4_Block_object_dispose((const void *)(v2 - 88), 8) = 0LL;
    *(void *)(a3 + _Block_object_dispose((const void *)(v2 - 88), 8) = 0LL;
    *(void *)(a3 + 16) = 0LL;
    *(void *)a3 = 0LL;
    *(_DWORD *)(a3 + 24) = 0;
  }

  else
  {
    char v6 = (__int128 *)(v4 + 56 * a2);
    if (*((char *)v6 + 23) < 0)
    {
      sub_100024238((_BYTE *)a3, *(void **)v6, *((void *)v6 + 1));
    }

    else
    {
      __int128 v7 = *v6;
      *(void *)(a3 + 16) = *((void *)v6 + 2);
      *(_OWORD *)a3 = v7;
    }

    uint64_t v8 = v4 + 56 * a2;
    *(_DWORD *)(a3 + 24) = *(_DWORD *)(v8 + 24);
    uint64_t result = (void *)(a3 + 32);
    uint64_t v9 = (__int128 *)(v8 + 32);
    if (*((char *)v6 + 55) < 0)
    {
      return sub_100024238(result, *(void **)v9, *(void *)(v4 + 56 * a2 + 40));
    }

    else
    {
      __int128 v10 = *v9;
      *(void *)(a3 + 4_Block_object_dispose((const void *)(v2 - 88), 8) = *((void *)v9 + 2);
      *(_OWORD *)uint64_t result = v10;
    }
  }

  return result;
}

void sub_10046DBC8(_Unwind_Exception *exception_object)
{
}

uint64_t sub_10046DBE4(uint64_t a1)
{
  return a1;
}

uint64_t sub_10046DC24(uint64_t a1, unsigned int a2)
{
  uint64_t v4 = a1 + 360;
  sub_100206678(a1 + 360);
  int v5 = sub_10045CF60(a1, a2);
  if (v5) {
    sub_1001FFA38((uint64_t)(v5 + 50), 0);
  }
  if (sub_1002065BC(v4) || sub_1002065C4(v4))
  {
    if (!sub_100206804(v4, 1))
    {
      char v6 = (os_log_s *)qword_1008F7598;
      if (os_log_type_enabled((os_log_t)qword_1008F7598, OS_LOG_TYPE_ERROR))
      {
        int v15 = sub_1002067C0(v4);
        sub_1002064C4(&v15, v16);
        int v8 = v17;
        uint64_t v9 = (void **)v16[0];
        int v12 = 1;
        sub_1002064C4(&v12, __p);
        __int128 v10 = v16;
        if (v8 < 0) {
          __int128 v10 = v9;
        }
        if (v14 >= 0) {
          uint64_t v11 = __p;
        }
        else {
          uint64_t v11 = (void **)__p[0];
        }
        *(_DWORD *)std::string buf = 136446466;
        uint64_t v19 = v10;
        __int16 v20 = 2082;
        int v21 = v11;
        _os_log_error_impl( (void *)&_mh_execute_header,  v6,  OS_LOG_TYPE_ERROR,  "Attempting to reject incoming call but call setup is %{public}s instead of %{public}s",  buf,  0x16u);
        if (v14 < 0) {
          operator delete(__p[0]);
        }
        if (v17 < 0) {
          operator delete(v16[0]);
        }
      }
    }

    if (qword_1008D90F8 != -1) {
      dispatch_once(&qword_1008D90F8, &stru_10089A050);
    }
    else {
      return 255LL;
    }
  }

  else
  {
    uint64_t result = os_log_type_enabled((os_log_t)qword_1008F7598, OS_LOG_TYPE_ERROR);
    if ((_DWORD)result)
    {
      sub_100682860();
      return 0LL;
    }
  }

  return result;
}

void sub_10046DE10( _Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, void *__p, uint64_t a15, int a16, __int16 a17, char a18, char a19)
{
  if (a19 < 0) {
    operator delete(__p);
  }
  _Unwind_Resume(exception_object);
}

void *sub_10046DE34@<X0>(uint64_t a1@<X0>, void *a2@<X8>)
{
  __int128 v36 = 0u;
  __int128 v37 = 0u;
  __int128 v34 = 0u;
  __int128 v35 = 0u;
  __int128 v32 = 0u;
  __int128 v33 = 0u;
  __int128 v30 = 0u;
  __int128 v31 = 0u;
  __int128 v29 = 0u;
  __int128 v27 = 0u;
  __int128 v28 = 0u;
  __int128 v25 = 0u;
  __int128 v26 = 0u;
  __int128 v23 = 0u;
  __int128 v24 = 0u;
  *(_OWORD *)std::string __str = 0u;
  int v4 = *(_DWORD *)(a1 + 8);
  int v5 = *(unsigned __int8 *)(a1 + 12);
  char v6 = __p;
  sub_10054A554((char *)(a1 + 24), (uint64_t)__p);
  if (v21 < 0) {
    char v6 = (void **)__p[0];
  }
  __int128 v7 = (const char *)(a1 + 80);
  unsigned int v8 = *(_DWORD *)(a1 + 16) - 1;
  if (v8 > 6) {
    uint64_t v9 = "unknown";
  }
  else {
    uint64_t v9 = off_10089A158[v8];
  }
  int v10 = *(unsigned __int8 *)(a1 + 13);
  int v11 = *(unsigned __int8 *)(a1 + 14);
  int v12 = *(unsigned __int8 *)(a1 + 15);
  id v13 = objc_claimAutoreleasedReturnValue([*(id *)a1 UUIDString]);
  char v14 = (const char *)[v13 UTF8String];
  int v15 = " (CallScreening)";
  uint64_t v16 = "";
  if (!v12) {
    int v15 = "";
  }
  char v17 = " (Expanse)";
  if (!v11) {
    char v17 = "";
  }
  if (v10) {
    uint64_t v16 = ", conf";
  }
  uint64_t v18 = "Outgoing to";
  if (!v5) {
    uint64_t v18 = "Incoming from";
  }
  snprintf( __str,  0x100uLL,  "[#%d: %s %s %s (%s%s%s%s ID:%s)]",  v4,  v18,  (const char *)v6,  v7,  v9,  v16,  v17,  v15,  v14);

  if (v21 < 0) {
    operator delete(__p[0]);
  }
  return sub_10002418C(a2, __str);
}

void sub_10046DFF0( _Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, void *__p, uint64_t a19, int a20, __int16 a21, char a22, char a23)
{
  if (a23 < 0) {
    operator delete(__p);
  }
  _Unwind_Resume(a1);
}

void sub_10046E020(uint64_t a1, uint64_t a2, char *a3)
{
  uint64_t v5 = sub_10045D7CC(a1, a2);
  char v6 = (os_log_s *)qword_1008F7598;
  if (!os_log_type_enabled((os_log_t)qword_1008F7598, OS_LOG_TYPE_DEFAULT)) {
    goto LABEL_8;
  }
  __int128 v7 = a3;
  if (a3[23] < 0) {
    __int128 v7 = *(char **)a3;
  }
  sub_1003CF00C(a2, __p);
  unsigned int v8 = v13 >= 0 ? __p : (void **)__p[0];
  *(_DWORD *)std::string buf = 136446466;
  int v15 = v7;
  __int16 v16 = 2082;
  char v17 = v8;
  _os_log_impl( (void *)&_mh_execute_header,  v6,  OS_LOG_TYPE_DEFAULT,  "Sending '%{public}s Siri status event for device %{public}s",  buf,  0x16u);
  if (v13 < 0)
  {
    operator delete(__p[0]);
    if (!v5) {
      return;
    }
  }

  else
  {
LABEL_8:
    if (!v5) {
      return;
    }
  }

  LOBYTE(__p[0]) = 0;
  sub_100242CA4(__p);
  unsigned int v9 = sub_1002073A4(v5 + 400);
  if (a3[23] < 0)
  {
    int v11 = a3;
    a3 = *(char **)a3;
    uint64_t v10 = *((void *)v11 + 1);
  }

  else
  {
    LOWORD(v1sub_100414D2C(qword_1008F72C0, 0) = a3[23];
  }

  sub_1000EF174(v9, a3, (unsigned __int16)v10);
  sub_100242CD0(__p);
  sub_100242CD8(__p);
}

void sub_10046E178( _Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, char a10)
{
}

void sub_10046E194(uint64_t a1, void *a2)
{
  id v3 = a2;
  int v12 = 0LL;
  char v13 = 0LL;
  uint64_t v14 = 0LL;
  sub_10053C3D8(&v12);
  memset(v11, 0, sizeof(v11));
  sub_10053C3D8(v11);
  if (qword_1008D90F8 != -1) {
    dispatch_once(&qword_1008D90F8, &stru_10089A050);
  }
  if (sub_10054AA1C((uint64_t)off_1008D90F0))
  {
    if (os_log_type_enabled((os_log_t)qword_1008F7598, OS_LOG_TYPE_ERROR)) {
      sub_10068288C();
    }
  }

  else
  {
    uint64_t v4 = a1 + 360;
    sub_100206854(a1 + 360, (int)&v9);
    sub_10020789C((uint64_t)v11, (uint64_t)v9, v10, 0x4EC4EC4EC4EC4EC5LL * ((v10 - (uint64_t)v9) >> 3));
    int v15 = (void ***)&v9;
    sub_1002077E0((void ***)&v15);
    if ((sub_100206938(a1 + 360, (uint64_t *)&v12) & 1) == 0)
    {
      if (sub_10053C9B4((uint64_t *)v11, (uint64_t *)&v12))
      {
        sub_10046400C(a1, (uint64_t *)&v12, v3);
      }

      else
      {
        uint64_t v5 = sub_10053C584(&v12, v3);
        char v6 = v5;
        if (v13 != v5 && *((_DWORD *)v5 + 4) == 5)
        {
          sub_10054A424(__dst);
          else {
            std::string __p = *(std::string *)(v6 + 10);
          }
          sub_1002066C4(v4, (uint64_t)__dst, &__p, 1);
          sub_10054A428(__dst);
        }
      }
    }
  }

  unsigned int v9 = v11;
  sub_1002077E0((void ***)&v9);
  v11[0] = (void **)&v12;
  sub_1002077E0(v11);
}

void sub_10046E378( _Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, void *__p, uint64_t a10, int a11, __int16 a12, char a13, char a14, char a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20, uint64_t a21, uint64_t a22)
{
  a22 = v23 - 88;
  sub_1002077E0((void ***)&a22);
  *(void *)(v23 - 8_Block_object_dispose((const void *)(v2 - 88), 8) = v23 - 64;
  sub_1002077E0((void ***)(v23 - 88));

  _Unwind_Resume(a1);
}

void sub_10046E404(uint64_t a1, void *a2)
{
}

void sub_10046E40C(uint64_t a1)
{
  if (qword_1008D90F8 != -1) {
    dispatch_once(&qword_1008D90F8, &stru_10089A050);
  }
  if (sub_10054A9EC((uint64_t)off_1008D90F0))
  {
    if (os_log_type_enabled((os_log_t)qword_1008F7598, OS_LOG_TYPE_ERROR)) {
      sub_1006828B8();
    }
  }

  else
  {
    int v2 = (int)v5[0];
    if (SHIBYTE(v5[3]) < 0)
    {
      sub_100024238(&__p, v5[1], (unint64_t)v5[2]);
    }

    else
    {
      __int128 __p = *(_OWORD *)&v5[1];
      uint64_t v4 = v5[3];
    }

    sub_100206570(a1 + 360, (uint64_t)&v2);
    if (SHIBYTE(v4) < 0) {
      operator delete((void *)__p);
    }
  }

  if (SHIBYTE(v5[3]) < 0) {
    operator delete(v5[1]);
  }
}

void sub_10046E514( _Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void *__p, uint64_t a11, int a12, __int16 a13, char a14, char a15, uint64_t a16, void *a17, uint64_t a18, int a19, __int16 a20, char a21, char a22)
{
  if (a15 < 0) {
    operator delete(__p);
  }
  if (a22 < 0) {
    operator delete(a17);
  }
  _Unwind_Resume(exception_object);
}

void sub_10046E548(uint64_t a1)
{
}

_BYTE *sub_10046E550(uint64_t a1)
{
  uint64_t v1 = a1;
  sub_100461F1C(a1);
  char v5 = 0;
  sub_100242CA4(&v5);
  v1 += 360LL;
  __int16 v2 = sub_100206524(v1);
  sub_1000EF0D4(v2);
  char v3 = sub_100206534(v1);
  sub_1000EF0F8(v3);
  return sub_100242CD8(&v5);
}

void sub_10046E5A8( _Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, int a10, __int16 a11, char a12, char a13)
{
}

_BYTE *sub_10046E5BC(uint64_t a1)
{
  return sub_10046E550(a1 - 256);
}

void sub_10046E5C4(void *a1)
{
  if (qword_1008D90F8 != -1) {
    dispatch_once(&qword_1008D90F8, &stru_10089A050);
  }
  uint64_t v2 = sub_10054A9FC((uint64_t)off_1008D90F0);
  char v3 = (void *)objc_claimAutoreleasedReturnValue(v2);
  if (v3)
  {
    sub_10046E674(a1, 0LL, 0LL, v3);
  }

  else if (os_log_type_enabled((os_log_t)qword_1008F7598, OS_LOG_TYPE_ERROR))
  {
    sub_1006828E4();
  }
}

void sub_10046E664(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_10046E674(void *a1, char *a2, _BYTE *a3, void *a4)
{
  id v7 = a4;
  v38[0] = 0LL;
  v38[1] = 0LL;
  sub_100242F28((uint64_t)v38, (uint64_t)(a1 + 95));
  uint64_t v8 = (uint64_t)(a1 + 45);
  if (a2)
  {
    int v9 = *a2;
    BOOL v10 = v9 != sub_10020681C((uint64_t)(a1 + 45));
    sub_100206814((uint64_t)(a1 + 45), *a2);
    if (a3) {
      goto LABEL_3;
    }
  }

  else
  {
    BOOL v10 = 0;
    if (a3)
    {
LABEL_3:
      if (*a3 == 100) {
        unsigned int v11 = 5;
      }
      else {
        unsigned int v11 = *a3 / 0x14u + 1;
      }
      int v12 = sub_10020682C((uint64_t)(a1 + 45));
      sub_100206824((uint64_t)(a1 + 45), v11);
      BOOL v13 = v11 != v12;
      if (v7) {
        goto LABEL_7;
      }
LABEL_10:
      int v18 = 0;
      int v19 = 0;
      goto LABEL_11;
    }
  }

  BOOL v13 = 0;
  if (!v7) {
    goto LABEL_10;
  }
LABEL_7:
  unsigned int v14 = [v7 service];
  unsigned int v15 = sub_1002065A4((uint64_t)(a1 + 45));
  unsigned int v16 = [v7 roaming];
  unsigned int v17 = sub_1002065AC((uint64_t)(a1 + 45));
  sub_1002065B4((uint64_t)(a1 + 45), v7);
  int v18 = v14 ^ v15;
  int v19 = v16 ^ v17;
LABEL_11:
  if (v10 || v13 || (v18 & 1) != 0 || v19)
  {
    char v37 = 0;
    sub_100242CA4(&v37);
    if (a1[105])
    {
      __int16 v20 = (void *)a1[103];
      char v21 = a1 + 104;
      if (v20 != a1 + 104)
      {
        do
        {
          if (v10)
          {
            unsigned int v22 = *((unsigned __int16 *)v20 + 16);
            uint64_t v23 = sub_10020681C(v8);
            sub_1000EFFC8(v22, v23);
          }

          if (v13)
          {
            unsigned int v24 = *((unsigned __int16 *)v20 + 16);
            uint64_t v25 = sub_10020682C(v8);
            sub_1000EFE84(v24, v25);
          }

          if (v18)
          {
            unsigned int v26 = *((unsigned __int16 *)v20 + 16);
            int v27 = sub_1002065A4(v8);
            sub_1000EF90C(v26, v27);
          }

          if (v19)
          {
            unsigned int v28 = *((unsigned __int16 *)v20 + 16);
            int v29 = sub_1002065AC(v8);
            sub_1000F0148(v28, v29);
          }

          __int128 v30 = (void *)v20[1];
          if (v30)
          {
            do
            {
              __int128 v31 = v30;
              __int128 v30 = (void *)*v30;
            }

            while (v30);
          }

          else
          {
            do
            {
              __int128 v31 = (void *)v20[2];
              BOOL v32 = *v31 == (void)v20;
              __int16 v20 = v31;
            }

            while (!v32);
          }

          __int16 v20 = v31;
        }

        while (v31 != v21);
      }
    }

    else
    {
      if (v10)
      {
        uint64_t v33 = sub_10020681C((uint64_t)(a1 + 45));
        sub_1000EFFC8(0, v33);
      }

      if (v13)
      {
        uint64_t v34 = sub_10020682C((uint64_t)(a1 + 45));
        sub_1000EFE84(0, v34);
      }

      if (v18)
      {
        int v35 = sub_1002065A4((uint64_t)(a1 + 45));
        sub_1000EF90C(0, v35);
      }

      if (v19)
      {
        int v36 = sub_1002065AC((uint64_t)(a1 + 45));
        sub_1000F0148(0, v36);
      }
    }

    sub_100242CD8(&v37);
  }

  sub_100242FAC((uint64_t)v38);
}

void sub_10046E8F8(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, ...)
{
  _Unwind_Resume(a1);
}

void sub_10046E934(uint64_t a1)
{
}

void sub_10046E93C(void *a1, char a2)
{
  char v2 = a2;
  sub_10046E674(a1, &v2, 0LL, 0LL);
}

void sub_10046E968(uint64_t a1, char a2)
{
  char v2 = a2;
  sub_10046E674((void *)(a1 - 256), &v2, 0LL, 0LL);
}

void sub_10046E998(uint64_t a1, uint64_t a2, char a3)
{
  v6[0] = 0LL;
  v6[1] = v6;
  void v6[2] = 0x2020000000LL;
  char v7 = a3;
  uint64_t v4 = sub_100405058();
  v5[0] = _NSConcreteStackBlock;
  v5[1] = 3221225472LL;
  _DWORD v5[2] = sub_10046EA34;
  uint64_t v5[3] = &unk_100880D70;
  void v5[4] = v6;
  void v5[5] = a1;
  sub_100405384(v4, v5);
  _Block_object_dispose(v6, 8);
}

void sub_10046EA1C( _Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, ...)
{
}

void sub_10046EA34(uint64_t a1)
{
}

void sub_10046EA50(uint64_t a1, uint64_t a2, char a3)
{
}

void sub_10046EA5C( uint64_t a1, uint64_t *a2, _BYTE *a3, _BYTE *a4, BOOL *a5, _BYTE *a6, int *a7, int *a8, std::string *a9, std::string *a10)
{
  uint64_t v55 = 0LL;
  uint64_t v56 = 0LL;
  uint64_t v57 = 0LL;
  uint64_t v51 = a1 + 360;
  sub_100206854(a1 + 360, (int)&v55);
  v60[0] = 0LL;
  v60[1] = 0LL;
  int v12 = -[NSUUID initWithUUIDBytes:](objc_alloc(&OBJC_CLASS___NSUUID), "initWithUUIDBytes:", v60);
  *a4 = 0;
  uint64_t v13 = *a2;
  if (*a2 == a2[1])
  {
    int v52 = 0;
    int v15 = 0;
    int v14 = 0;
LABEL_59:
    BOOL v40 = v15 > 0;
    if (v14 > 0) {
      BOOL v40 = 1;
    }
    BOOL v41 = !v40;
    int v42 = 1;
    if (v41) {
      int v43 = 2;
    }
    else {
      int v43 = 1;
    }
    if (v52 <= 0) {
      int v43 = 0;
    }
    *a7 = v43;
    BOOL v44 = v15 > 0 || v52 > 0;
    *a5 = v44;
    if ((*a4 & 0xC) == 0)
    {
      if ((*a4 & 1) != 0 || *a3)
      {
        int v42 = 2;
      }

      else
      {
        if ((*a4 & 2) == 0) {
          goto LABEL_76;
        }
        int v42 = 3;
      }
    }

    *a8 = v42;
    goto LABEL_76;
  }

  int v14 = 0;
  int v15 = 0;
  int v52 = 0;
  while (2)
  {
    id v16 = *(id *)v13;
    if ([v16 isEqual:v12])
    {
      BOOL v17 = *(_DWORD *)(v13 + 16) == 7;

      if (!v17)
      {
        uint64_t v18 = qword_1008F7598;
        if (os_log_type_enabled((os_log_t)qword_1008F7598, OS_LOG_TYPE_ERROR))
        {
          sub_10046DE34(v13, __p);
          int v19 = __p;
          if (v54 < 0) {
            int v19 = (void **)__p[0];
          }
          *(_DWORD *)std::string buf = 136315138;
          uint64_t v59 = v19;
          __int16 v20 = (os_log_s *)v18;
          char v21 = "Invalid call status - empty identifier is reserved for virtual calls: %s";
LABEL_54:
          _os_log_error_impl((void *)&_mh_execute_header, v20, OS_LOG_TYPE_ERROR, v21, buf, 0xCu);
          if (v54 < 0) {
            operator delete(__p[0]);
          }
        }

        goto LABEL_56;
      }
    }

    else
    {
    }

    switch(*(_DWORD *)(v13 + 16))
    {
      case 1:
        id v22 = *(id *)v13;
        uint64_t v23 = sub_10053C584(&v55, v22);

        ++v15;
        if (v56 == v23 || *((_DWORD *)v23 + 4) != 2) {
          goto LABEL_56;
        }
        goto LABEL_28;
      case 2:
        id v28 = *(id *)v13;
        int v29 = sub_10053C584(&v55, v28);

        ++v52;
        if (v56 == v29 || *((_DWORD *)v29 + 4) != 1) {
          goto LABEL_56;
        }
        if (!sub_10020684C(v51))
        {
LABEL_28:
          *a6 = 1;
LABEL_56:
          v13 += 104LL;
          if (v13 == a2[1]) {
            goto LABEL_59;
          }
          continue;
        }

        sub_100206844(v51, 0);
        int v45 = (os_log_s *)qword_1008F7598;
        if (os_log_type_enabled((os_log_t)qword_1008F7598, OS_LOG_TYPE_INFO))
        {
          LOWORD(__p[0]) = 0;
          _os_log_impl( (void *)&_mh_execute_header,  v45,  OS_LOG_TYPE_INFO,  "We're actually dialing a call and putting another one on hold. This is TC_AG_TWC_BV_05_I!",  (uint8_t *)__p,  2u);
        }

void sub_10046F09C( _Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20, void **a21, uint64_t a22, uint64_t a23, char a24)
{
  a21 = (void **)&a24;
  sub_1002077E0(&a21);
  _Unwind_Resume(a1);
}

void sub_10046F114(uint64_t a1, void *a2, char a3)
{
  char v16 = a3;
  char v3 = a2 + 1;
  uint64_t v4 = (void *)*a2;
  if ((void *)*a2 != a2 + 1)
  {
    uint64_t v5 = a1 + 360;
    do
    {
      uint64_t v6 = sub_1002073AC(v4[5] + 400LL);
      if (sub_100206708(v5, 1))
      {
        if (*(_BYTE *)(v6 + 128))
        {
LABEL_5:
          if (*(_BYTE *)(v6 + 984))
          {
            char v7 = (os_log_s *)qword_1008F7598;
            if (os_log_type_enabled((os_log_t)qword_1008F7598, OS_LOG_TYPE_DEFAULT))
            {
              sub_1003D0100(v6, (uint64_t)__p);
              uint64_t v8 = __p;
              if (v15 < 0) {
                uint64_t v8 = (void **)__p[0];
              }
              *(_DWORD *)std::string buf = 141558275;
              uint64_t v18 = 1752392040LL;
              __int16 v19 = 2081;
              __int16 v20 = v8;
              _os_log_impl( (void *)&_mh_execute_header,  v7,  OS_LOG_TYPE_DEFAULT,  "Wireless Splitter suppressing UpdateCallStatus for device %{private, mask.hash}s due to WS being enabled",  buf,  0x16u);
              if (v15 < 0) {
                operator delete(__p[0]);
              }
            }

            goto LABEL_16;
          }
        }

        else
        {
          uint64_t v9 = 0LL;
          while (v9 != 5)
          {
            if (*(unsigned __int8 *)(v6 + 129 + v9++))
            {
              break;
            }
          }
        }
      }

      sub_100477044(&v16, *((_WORD *)v4 + 16), v4[5]);
LABEL_16:
      unsigned int v11 = (void *)v4[1];
      if (v11)
      {
        do
        {
          int v12 = v11;
          unsigned int v11 = (void *)*v11;
        }

        while (v11);
      }

      else
      {
        do
        {
          int v12 = (void *)v4[2];
          BOOL v13 = *v12 == (void)v4;
          uint64_t v4 = v12;
        }

        while (!v13);
      }

      uint64_t v4 = v12;
    }

    while (v12 != v3);
  }

void sub_10046F2E0(uint64_t a1, void *a2, void (*a3)(void, void))
{
  char v3 = a2 + 1;
  uint64_t v4 = (void *)*a2;
  if ((void *)*a2 != a2 + 1)
  {
    uint64_t v6 = a1 + 360;
    do
    {
      uint64_t v7 = sub_1002073AC(v4[5] + 400LL);
      if (sub_100206708(v6, 1))
      {
        if (*(_BYTE *)(v7 + 128))
        {
LABEL_5:
          if (*(_BYTE *)(v7 + 984))
          {
            uint64_t v8 = (os_log_s *)qword_1008F7598;
            if (os_log_type_enabled((os_log_t)qword_1008F7598, OS_LOG_TYPE_DEFAULT))
            {
              sub_1003D0100(v7, (uint64_t)__p);
              uint64_t v9 = __p;
              if (v16 < 0) {
                uint64_t v9 = (void **)__p[0];
              }
              *(_DWORD *)std::string buf = 141558275;
              uint64_t v18 = 1752392040LL;
              __int16 v19 = 2081;
              __int16 v20 = v9;
              _os_log_impl( (void *)&_mh_execute_header,  v8,  OS_LOG_TYPE_DEFAULT,  "Wireless Splitter suppressing UpdateCallStatus for device %{private, mask.hash}s due to WS being enabled",  buf,  0x16u);
              if (v16 < 0) {
                operator delete(__p[0]);
              }
            }

            goto LABEL_16;
          }
        }

        else
        {
          uint64_t v10 = 0LL;
          while (v10 != 5)
          {
            if (*(unsigned __int8 *)(v7 + 129 + v10++))
            {
              break;
            }
          }
        }
      }

      a3(*((unsigned __int16 *)v4 + 16), v4[5]);
LABEL_16:
      int v12 = (void *)v4[1];
      if (v12)
      {
        do
        {
          BOOL v13 = v12;
          int v12 = (void *)*v12;
        }

        while (v12);
      }

      else
      {
        do
        {
          BOOL v13 = (void *)v4[2];
          BOOL v14 = *v13 == (void)v4;
          uint64_t v4 = v13;
        }

        while (!v14);
      }

      uint64_t v4 = v13;
    }

    while (v13 != v3);
  }

void sub_10046F4A8(unsigned __int16 a1, uint64_t a2)
{
  if (sub_100207474(a2 + 400))
  {
    if (qword_1008D9030 != -1) {
      dispatch_once(&qword_1008D9030, &stru_100899F90);
    }
    uint64_t v3 = sub_1004615C4((uint64_t)off_1008D9028, a1);
    uint64_t v4 = sub_1002E6BF0();
    if (((*(uint64_t (**)(uint64_t))(*(void *)v4 + 384LL))(v4) & 1) == 0)
    {
      uint64_t v5 = (os_log_s *)qword_1008F7598;
      if (os_log_type_enabled((os_log_t)qword_1008F7598, OS_LOG_TYPE_DEFAULT))
      {
        int v12 = 2;
        uint64_t v6 = v13;
        sub_1002064C4(&v12, v13);
        if (v14 < 0) {
          uint64_t v6 = (void **)v13[0];
        }
        if (v3)
        {
          sub_1003CF00C(v3, __p);
          if (v16 >= 0) {
            uint64_t v7 = __p;
          }
          else {
            uint64_t v7 = *(const char **)__p;
          }
          *(_DWORD *)std::string buf = 136446466;
          uint64_t v18 = v6;
          __int16 v19 = 2082;
          __int16 v20 = v7;
          _os_log_impl( (void *)&_mh_execute_header,  v5,  OS_LOG_TYPE_DEFAULT,  "Sending call setup %{public}s to device %{public}s",  buf,  0x16u);
          if (v16 < 0) {
            operator delete(*(void **)__p);
          }
        }

        else
        {
          *(_DWORD *)std::string buf = 136446466;
          uint64_t v18 = v6;
          __int16 v19 = 2082;
          __int16 v20 = "NULL";
          _os_log_impl( (void *)&_mh_execute_header,  v5,  OS_LOG_TYPE_DEFAULT,  "Sending call setup %{public}s to device %{public}s",  buf,  0x16u);
        }

        if (v14 < 0) {
          operator delete(v13[0]);
        }
      }

      LOBYTE(v13[0]) = 0;
      sub_100242CA4(v13);
      int v8 = sub_1000EFB4C(a1, 2u);
      sub_100242CD8(v13);
      if (v8) {
        goto LABEL_31;
      }
    }

    uint64_t v9 = (os_log_s *)qword_1008F7598;
    if (os_log_type_enabled((os_log_t)qword_1008F7598, OS_LOG_TYPE_DEFAULT))
    {
      if (v3)
      {
        sub_1003CF00C(v3, v13);
        if (v14 >= 0) {
          uint64_t v10 = v13;
        }
        else {
          uint64_t v10 = (void **)v13[0];
        }
        *(_DWORD *)__int128 __p = 136446210;
        *(void *)&__p[4] = v10;
        _os_log_impl( (void *)&_mh_execute_header,  v9,  OS_LOG_TYPE_DEFAULT,  "Sending call status call active to device %{public}s",  __p,  0xCu);
        if (v14 < 0) {
          operator delete(v13[0]);
        }
      }

      else
      {
        *(_DWORD *)__int128 __p = 136446210;
        *(void *)&__p[4] = "NULL";
        _os_log_impl( (void *)&_mh_execute_header,  v9,  OS_LOG_TYPE_DEFAULT,  "Sending call status call active to device %{public}s",  __p,  0xCu);
      }
    }

    LOBYTE(v13[0]) = 0;
    sub_100242CA4(v13);
    int v11 = sub_1000EFA28(a1, 1);
    sub_100242CD8(v13);
    if (v11)
    {
LABEL_31:
      if (os_log_type_enabled((os_log_t)qword_1008F7598, OS_LOG_TYPE_ERROR)) {
        sub_100682910();
      }
    }
  }

void sub_10046F7A4( _Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void *__p, uint64_t a11, int a12, __int16 a13, char a14, char a15)
{
  if (a15 < 0) {
    operator delete(__p);
  }
  _Unwind_Resume(exception_object);
}

void sub_10046F7DC(uint64_t a1, void *a2, int a3)
{
  __int16 v16 = a3;
  char v17 = BYTE2(a3);
  uint64_t v3 = a2 + 1;
  uint64_t v4 = (void *)*a2;
  if ((void *)*a2 != a2 + 1)
  {
    uint64_t v5 = a1 + 360;
    do
    {
      uint64_t v6 = sub_1002073AC(v4[5] + 400LL);
      if (sub_100206708(v5, 1))
      {
        if (*(_BYTE *)(v6 + 128))
        {
LABEL_5:
          if (*(_BYTE *)(v6 + 984))
          {
            uint64_t v7 = (os_log_s *)qword_1008F7598;
            if (os_log_type_enabled((os_log_t)qword_1008F7598, OS_LOG_TYPE_DEFAULT))
            {
              sub_1003D0100(v6, (uint64_t)__p);
              int v8 = __p;
              if (v15 < 0) {
                int v8 = (void **)__p[0];
              }
              *(_DWORD *)std::string buf = 141558275;
              uint64_t v19 = 1752392040LL;
              __int16 v20 = 2081;
              char v21 = v8;
              _os_log_impl( (void *)&_mh_execute_header,  v7,  OS_LOG_TYPE_DEFAULT,  "Wireless Splitter suppressing UpdateCallStatus for device %{private, mask.hash}s due to WS being enabled",  buf,  0x16u);
              if (v15 < 0) {
                operator delete(__p[0]);
              }
            }

            goto LABEL_16;
          }
        }

        else
        {
          uint64_t v9 = 0LL;
          while (v9 != 5)
          {
            if (*(unsigned __int8 *)(v6 + 129 + v9++))
            {
              break;
            }
          }
        }
      }

      sub_100477564((unsigned __int8 *)&v16, *((_WORD *)v4 + 16), v4[5]);
LABEL_16:
      int v11 = (void *)v4[1];
      if (v11)
      {
        do
        {
          int v12 = v11;
          int v11 = (void *)*v11;
        }

        while (v11);
      }

      else
      {
        do
        {
          int v12 = (void *)v4[2];
          BOOL v13 = *v12 == (void)v4;
          uint64_t v4 = v12;
        }

        while (!v13);
      }

      uint64_t v4 = v12;
    }

    while (v12 != v3);
  }

uint64_t sub_10046F9B0(uint64_t a1)
{
  v9[0] = 0LL;
  v9[1] = 0LL;
  sub_100242F28((uint64_t)v9, a1 + 760);
  if (sub_100206708(a1 + 360, 0))
  {
    char v2 = (os_log_s *)qword_1008F7598;
    if (os_log_type_enabled((os_log_t)qword_1008F7598, OS_LOG_TYPE_INFO))
    {
      *(_WORD *)std::string buf = 0;
      uint64_t v3 = "Cannot send ring because ring status is not ringing";
LABEL_13:
      _os_log_impl((void *)&_mh_execute_header, v2, OS_LOG_TYPE_INFO, v3, buf, 2u);
    }
  }

  else if (sub_100206804(a1 + 360, 1))
  {
    if (sub_100410EB0(a1))
    {
      if (sub_100206708(a1 + 360, 1))
      {
        sub_10047725C(v7, a1 + 824);
        sub_10046F2E0(a1, v7, (void (*)(void, void))sub_1004704C4);
        sub_10023BF24((uint64_t)v7, (void *)v7[1]);
      }

      sub_100206718(a1 + 360);
      uint64_t v4 = operator new(0x20uLL);
      sub_100476560((uint64_t)v4);
      void v4[2] = 3000LL;
      uint64_t v5 = sub_100405058();
      sub_100405744(v5, v4);
    }

    else
    {
      char v2 = (os_log_s *)qword_1008F7598;
      if (os_log_type_enabled((os_log_t)qword_1008F7598, OS_LOG_TYPE_INFO))
      {
        *(_WORD *)std::string buf = 0;
        uint64_t v3 = "Cannot send ring because we are not connected";
        goto LABEL_13;
      }
    }
  }

  else
  {
    char v2 = (os_log_s *)qword_1008F7598;
    if (os_log_type_enabled((os_log_t)qword_1008F7598, OS_LOG_TYPE_INFO))
    {
      *(_WORD *)std::string buf = 0;
      uint64_t v3 = "Cannot send ring because is not incoming";
      goto LABEL_13;
    }
  }

  return sub_100242FAC((uint64_t)v9);
}

void sub_10046FB34( _Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, char a10, void *a11)
{
}

uint64_t sub_10046FB70(uint64_t a1)
{
  v6[0] = 0LL;
  v6[1] = 0LL;
  sub_100242F28((uint64_t)v6, a1 + 760);
  char v2 = (os_log_s *)qword_1008F7598;
  if (os_log_type_enabled((os_log_t)qword_1008F7598, OS_LOG_TYPE_DEFAULT))
  {
    *(_WORD *)std::string buf = 0;
    _os_log_impl( (void *)&_mh_execute_header,  v2,  OS_LOG_TYPE_DEFAULT,  "Sending call waiting notification to all connected devices",  buf,  2u);
  }

  sub_10047725C(v4, a1 + 824);
  sub_10046F2E0(a1, v4, (void (*)(void, void))sub_10046FFE4);
  sub_10023BF24((uint64_t)v4, (void *)v4[1]);
  sub_100206718(a1 + 360);
  return sub_100242FAC((uint64_t)v6);
}

void sub_10046FC24( _Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, char a10, void *a11)
{
}

void sub_10046FC4C(uint64_t a1, void *a2, int a3)
{
  int v16 = a3;
  uint64_t v3 = a2 + 1;
  uint64_t v4 = (void *)*a2;
  if ((void *)*a2 != a2 + 1)
  {
    uint64_t v5 = a1 + 360;
    do
    {
      uint64_t v6 = sub_1002073AC(v4[5] + 400LL);
      if (sub_100206708(v5, 1))
      {
        if (*(_BYTE *)(v6 + 128))
        {
LABEL_5:
          if (*(_BYTE *)(v6 + 984))
          {
            uint64_t v7 = (os_log_s *)qword_1008F7598;
            if (os_log_type_enabled((os_log_t)qword_1008F7598, OS_LOG_TYPE_DEFAULT))
            {
              sub_1003D0100(v6, (uint64_t)__p);
              int v8 = __p;
              if (v15 < 0) {
                int v8 = (void **)__p[0];
              }
              *(_DWORD *)std::string buf = 141558275;
              uint64_t v18 = 1752392040LL;
              __int16 v19 = 2081;
              __int16 v20 = v8;
              _os_log_impl( (void *)&_mh_execute_header,  v7,  OS_LOG_TYPE_DEFAULT,  "Wireless Splitter suppressing UpdateCallStatus for device %{private, mask.hash}s due to WS being enabled",  buf,  0x16u);
              if (v15 < 0) {
                operator delete(__p[0]);
              }
            }

            goto LABEL_16;
          }
        }

        else
        {
          uint64_t v9 = 0LL;
          while (v9 != 5)
          {
            if (*(unsigned __int8 *)(v6 + 129 + v9++))
            {
              break;
            }
          }
        }
      }

      sub_100477A50((unsigned __int8 *)&v16, *((_WORD *)v4 + 16), v4[5]);
LABEL_16:
      uint64_t v11 = (void *)v4[1];
      if (v11)
      {
        do
        {
          int v12 = v11;
          uint64_t v11 = (void *)*v11;
        }

        while (v11);
      }

      else
      {
        do
        {
          int v12 = (void *)v4[2];
          BOOL v13 = *v12 == (void)v4;
          uint64_t v4 = v12;
        }

        while (!v13);
      }

      uint64_t v4 = v12;
    }

    while (v12 != v3);
  }

void sub_10046FE18(uint64_t a1, void *a2, unsigned __int8 a3)
{
  unsigned __int8 v16 = a3;
  uint64_t v3 = a2 + 1;
  uint64_t v4 = (void *)*a2;
  if ((void *)*a2 != a2 + 1)
  {
    uint64_t v5 = a1 + 360;
    do
    {
      uint64_t v6 = sub_1002073AC(v4[5] + 400LL);
      if (sub_100206708(v5, 1))
      {
        if (*(_BYTE *)(v6 + 128))
        {
LABEL_5:
          if (*(_BYTE *)(v6 + 984))
          {
            uint64_t v7 = (os_log_s *)qword_1008F7598;
            if (os_log_type_enabled((os_log_t)qword_1008F7598, OS_LOG_TYPE_DEFAULT))
            {
              sub_1003D0100(v6, (uint64_t)__p);
              int v8 = __p;
              if (v15 < 0) {
                int v8 = (void **)__p[0];
              }
              *(_DWORD *)std::string buf = 141558275;
              uint64_t v18 = 1752392040LL;
              __int16 v19 = 2081;
              __int16 v20 = v8;
              _os_log_impl( (void *)&_mh_execute_header,  v7,  OS_LOG_TYPE_DEFAULT,  "Wireless Splitter suppressing UpdateCallStatus for device %{private, mask.hash}s due to WS being enabled",  buf,  0x16u);
              if (v15 < 0) {
                operator delete(__p[0]);
              }
            }

            goto LABEL_16;
          }
        }

        else
        {
          uint64_t v9 = 0LL;
          while (v9 != 5)
          {
            if (*(unsigned __int8 *)(v6 + 129 + v9++))
            {
              break;
            }
          }
        }
      }

      sub_100477F9C(&v16, *((_WORD *)v4 + 16), v4[5]);
LABEL_16:
      uint64_t v11 = (void *)v4[1];
      if (v11)
      {
        do
        {
          int v12 = v11;
          uint64_t v11 = (void *)*v11;
        }

        while (v11);
      }

      else
      {
        do
        {
          int v12 = (void *)v4[2];
          BOOL v13 = *v12 == (void)v4;
          uint64_t v4 = v12;
        }

        while (!v13);
      }

      uint64_t v4 = v12;
    }

    while (v12 != v3);
  }

void sub_10046FFE4(unsigned __int16 a1, uint64_t a2)
{
  if (qword_1008D9030 != -1) {
    dispatch_once(&qword_1008D9030, &stru_100899F90);
  }
  uint64_t v4 = (char *)off_1008D9028;
  if (sub_100207474(a2 + 400))
  {
    if (qword_1008D9030 != -1) {
      dispatch_once(&qword_1008D9030, &stru_100899F90);
    }
    uint64_t v5 = sub_1004615C4((uint64_t)off_1008D9028, a1);
    if (qword_1008D9030 != -1) {
      dispatch_once(&qword_1008D9030, &stru_100899F90);
    }
    uint64_t v6 = sub_10045CF60((uint64_t)off_1008D9028, a1);
    if (qword_1008D9030 != -1) {
      dispatch_once(&qword_1008D9030, &stru_100899F90);
    }
    uint64_t v7 = sub_10045CF60((uint64_t)off_1008D9028, a1);
    if ((sub_100207434((uint64_t)(v7 + 50)) & 1) != 0)
    {
LABEL_12:
      int v8 = v4 + 360;
      uint64_t v9 = (os_log_s *)qword_1008F7598;
      if (os_log_type_enabled((os_log_t)qword_1008F7598, OS_LOG_TYPE_DEFAULT))
      {
        uint64_t v10 = &v27;
        sub_100206738((uint64_t)v8, &v27);
        if ((v27.__r_.__value_.__s.__size_ & 0x80u) != 0) {
          uint64_t v10 = (std::string *)v27.__r_.__value_.__r.__words[0];
        }
        uint64_t v11 = v24;
        sub_100206740(v8, (uint64_t)v24);
        if (v25 < 0) {
          uint64_t v11 = (void **)v24[0];
        }
        if (v5)
        {
          sub_1003CF00C(v5, __p);
          if (v23 >= 0) {
            int v12 = __p;
          }
          else {
            int v12 = (void **)__p[0];
          }
          LODWORD(buf.__r_.__value_.__l.__data_) = 136315650;
          *(std::string::size_type *)((char *)buf.__r_.__value_.__r.__words + 4) = (std::string::size_type)v10;
          WORD2(buf.__r_.__value_.__r.__words[1]) = 2080;
          *(std::string::size_type *)((char *)&buf.__r_.__value_.__r.__words[1] + 6) = (std::string::size_type)v11;
          HIWORD(buf.__r_.__value_.__r.__words[2]) = 2082;
          int v29 = (const char *)v12;
          _os_log_impl( (void *)&_mh_execute_header,  v9,  OS_LOG_TYPE_DEFAULT,  "Sending call waiting notification for call %s %s to device %{public}s",  (uint8_t *)&buf,  0x20u);
          if (v23 < 0) {
            operator delete(__p[0]);
          }
        }

        else
        {
          LODWORD(buf.__r_.__value_.__l.__data_) = 136315650;
          *(std::string::size_type *)((char *)buf.__r_.__value_.__r.__words + 4) = (std::string::size_type)v10;
          WORD2(buf.__r_.__value_.__r.__words[1]) = 2080;
          *(std::string::size_type *)((char *)&buf.__r_.__value_.__r.__words[1] + 6) = (std::string::size_type)v11;
          HIWORD(buf.__r_.__value_.__r.__words[2]) = 2082;
          int v29 = "NULL";
          _os_log_impl( (void *)&_mh_execute_header,  v9,  OS_LOG_TYPE_DEFAULT,  "Sending call waiting notification for call %s %s to device %{public}s",  (uint8_t *)&buf,  0x20u);
        }

        if (v25 < 0) {
          operator delete(v24[0]);
        }
      }

      sub_100206740(v8, (uint64_t)&v27);
      sub_100461890((char *)&v27, v5, (uint64_t)&buf);
      std::string v26 = buf;
      buf.__r_.__value_.__s.__size_ = 0;
      buf.__r_.__value_.__s.__data_[0] = 0;
      v27.__r_.__value_.__s.__data_[0] = 0;
      sub_100242CA4(&v27);
      sub_100206738((uint64_t)v8, &buf);
      int size = (char)buf.__r_.__value_.__s.__size_;
      std::string::size_type v17 = buf.__r_.__value_.__r.__words[0];
      uint64_t v18 = sub_10020676C((uint64_t)v8);
      if (size >= 0) {
        p_std::string buf = &buf;
      }
      else {
        p_std::string buf = (std::string *)v17;
      }
      if ((v26.__r_.__value_.__s.__size_ & 0x80u) == 0) {
        __int16 v20 = &v26;
      }
      else {
        __int16 v20 = (std::string *)v26.__r_.__value_.__r.__words[0];
      }
      int v21 = sub_1000F0708(a1, (const char *)p_buf, v18, (const char *)v20);
      sub_100242CD0(&v27);
      if (v21)
      {
        if (os_log_type_enabled((os_log_t)qword_1008F7598, OS_LOG_TYPE_ERROR)) {
          sub_100682970();
        }
      }

      sub_100242CD8(&v27);
      if ((char)v26.__r_.__value_.__s.__size_ < 0)
      {
        char v15 = (void *)v26.__r_.__value_.__r.__words[0];
        goto LABEL_50;
      }
    }

    else
    {
      BOOL v13 = (os_log_s *)qword_1008F7598;
      if (os_log_type_enabled((os_log_t)qword_1008F7598, OS_LOG_TYPE_DEFAULT))
      {
        if (!v5)
        {
          LODWORD(v27.__r_.__value_.__l.__data_) = 136446210;
          *(std::string::size_type *)((char *)v27.__r_.__value_.__r.__words + 4) = (std::string::size_type)"NULL";
          _os_log_impl( (void *)&_mh_execute_header,  v13,  OS_LOG_TYPE_DEFAULT,  "Device %{public}s does not support call waiting!",  (uint8_t *)&v27,  0xCu);
          return;
        }

        sub_1003CF00C(v5, &buf);
        char v14 = (buf.__r_.__value_.__s.__size_ & 0x80u) == 0 ? &buf : (std::string *)buf.__r_.__value_.__r.__words[0];
        LODWORD(v27.__r_.__value_.__l.__data_) = 136446210;
        *(std::string::size_type *)((char *)v27.__r_.__value_.__r.__words + 4) = (std::string::size_type)v14;
        _os_log_impl( (void *)&_mh_execute_header,  v13,  OS_LOG_TYPE_DEFAULT,  "Device %{public}s does not support call waiting!",  (uint8_t *)&v27,  0xCu);
        if ((char)buf.__r_.__value_.__s.__size_ < 0)
        {
          char v15 = (void *)buf.__r_.__value_.__r.__words[0];
LABEL_50:
          operator delete(v15);
        }
      }
    }
  }

void sub_10047043C( _Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, void *__p, uint64_t a13, int a14, __int16 a15, char a16, char a17, uint64_t a18, uint64_t a19, int a20, __int16 a21, char a22, char a23, uint64_t a24, void *a25, uint64_t a26, int a27, __int16 a28, char a29, char a30, uint64_t a31, void *a32, uint64_t a33, int a34, __int16 a35, char a36, char a37)
{
  if (a17 < 0) {
    operator delete(__p);
  }
  if (a30 < 0) {
    operator delete(a25);
  }
  _Unwind_Resume(exception_object);
}

void sub_1004704C4(unsigned __int16 a1, uint64_t a2)
{
  if (qword_1008D9030 != -1) {
    dispatch_once(&qword_1008D9030, &stru_100899F90);
  }
  uint64_t v4 = (char *)off_1008D9028;
  uint64_t v5 = a2 + 400;
  if (sub_100207474(v5))
  {
    uint64_t v6 = v4 + 360;
    if (qword_1008D9030 != -1) {
      dispatch_once(&qword_1008D9030, &stru_100899F90);
    }
    uint64_t v7 = sub_1004615C4((uint64_t)off_1008D9028, a1);
    int v8 = (os_log_s *)qword_1008F7598;
    if (os_log_type_enabled((os_log_t)qword_1008F7598, OS_LOG_TYPE_DEFAULT))
    {
      uint64_t v9 = &v23;
      sub_100206738((uint64_t)v6, &v23);
      if ((v23.__r_.__value_.__s.__size_ & 0x80u) != 0) {
        uint64_t v9 = (std::string *)v23.__r_.__value_.__r.__words[0];
      }
      uint64_t v10 = v21;
      sub_100206740(v6, (uint64_t)v21);
      if (v22 < 0) {
        uint64_t v10 = (void **)v21[0];
      }
      if (v7)
      {
        sub_1003CF00C(v7, __p);
        if (v20 >= 0) {
          uint64_t v11 = __p;
        }
        else {
          uint64_t v11 = (void **)__p[0];
        }
        LODWORD(buf.__r_.__value_.__l.__data_) = 136315650;
        *(std::string::size_type *)((char *)buf.__r_.__value_.__r.__words + 4) = (std::string::size_type)v9;
        WORD2(buf.__r_.__value_.__r.__words[1]) = 2080;
        *(std::string::size_type *)((char *)&buf.__r_.__value_.__r.__words[1] + 6) = (std::string::size_type)v10;
        HIWORD(buf.__r_.__value_.__r.__words[2]) = 2082;
        std::string v26 = (const char *)v11;
        _os_log_impl( (void *)&_mh_execute_header,  v8,  OS_LOG_TYPE_DEFAULT,  "Sending ring notification for call %s %s to device %{public}s",  (uint8_t *)&buf,  0x20u);
        if (v20 < 0) {
          operator delete(__p[0]);
        }
      }

      else
      {
        LODWORD(buf.__r_.__value_.__l.__data_) = 136315650;
        *(std::string::size_type *)((char *)buf.__r_.__value_.__r.__words + 4) = (std::string::size_type)v9;
        WORD2(buf.__r_.__value_.__r.__words[1]) = 2080;
        *(std::string::size_type *)((char *)&buf.__r_.__value_.__r.__words[1] + 6) = (std::string::size_type)v10;
        HIWORD(buf.__r_.__value_.__r.__words[2]) = 2082;
        std::string v26 = "NULL";
        _os_log_impl( (void *)&_mh_execute_header,  v8,  OS_LOG_TYPE_DEFAULT,  "Sending ring notification for call %s %s to device %{public}s",  (uint8_t *)&buf,  0x20u);
      }

      if (v22 < 0) {
        operator delete(v21[0]);
      }
    }

    sub_100206740(v6, (uint64_t)&v23);
    sub_100461890((char *)&v23, v7, (uint64_t)&buf);
    std::string v24 = buf;
    buf.__r_.__value_.__s.__size_ = 0;
    buf.__r_.__value_.__s.__data_[0] = 0;
    v23.__r_.__value_.__s.__data_[0] = 0;
    sub_100242CA4(&v23);
    p_std::string buf = &buf;
    sub_100206738((uint64_t)v6, &buf);
    if ((buf.__r_.__value_.__s.__size_ & 0x80u) != 0) {
      p_std::string buf = (std::string *)buf.__r_.__value_.__r.__words[0];
    }
    uint64_t v13 = sub_10020676C((uint64_t)v6);
    int size = (char)v24.__r_.__value_.__s.__size_;
    std::string::size_type v15 = v24.__r_.__value_.__r.__words[0];
    int v16 = sub_10020749C(v5);
    if (size >= 0) {
      std::string::size_type v17 = &v24;
    }
    else {
      std::string::size_type v17 = (std::string *)v15;
    }
    int v18 = sub_1000F02F4(a1, (const char *)p_buf, v13, (const char *)v17, v16);
    sub_100242CD0(&v23);
    if (v18 && os_log_type_enabled((os_log_t)qword_1008F7598, OS_LOG_TYPE_ERROR)) {
      sub_1006829D0();
    }
    sub_100242CD8(&v23);
  }

void sub_100470808( _Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, void *__p, uint64_t a14, int a15, __int16 a16, char a17, char a18, void *a19, uint64_t a20, int a21, __int16 a22, char a23, char a24, uint64_t a25, uint64_t a26, int a27, __int16 a28, char a29, char a30, uint64_t a31, void *a32, uint64_t a33, int a34, __int16 a35, char a36, char a37)
{
}

void sub_100470890()
{
  if (sub_1002D099C())
  {
    uint64_t v0 = (os_log_s *)qword_1008F7598;
    if (os_log_type_enabled((os_log_t)qword_1008F7598, OS_LOG_TYPE_INFO))
    {
      *(_WORD *)uint64_t v1 = 0;
      _os_log_impl((void *)&_mh_execute_header, v0, OS_LOG_TYPE_INFO, "Reserve Voice Buf", v1, 2u);
    }

    sub_100133F48();
  }

_BYTE *sub_100470904(uint64_t a1, uint64_t a2, uint64_t a3)
{
  uint64_t v5 = a3 + 400;
  if (sub_1002070AC(a3 + 400))
  {
    char v9 = 0;
    sub_100242CA4(&v9);
    sub_100113CA0(a2 + 128);
    sub_100242CD8(&v9);
    unsigned int v6 = 2000;
  }

  else
  {
    unsigned int v6 = 0;
  }

  uint64_t v7 = sub_10020755C(v5);
  return sub_10046D44C(v7, a3, v6, 0, v7);
}

void sub_100470998( _Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, int a10, __int16 a11, char a12, char a13)
{
}

_BYTE *sub_1004709AC(uint64_t a1, uint64_t a2, uint64_t a3)
{
  uint64_t v5 = (os_log_s *)qword_1008F7598;
  if (os_log_type_enabled((os_log_t)qword_1008F7598, OS_LOG_TYPE_DEFAULT))
  {
    int v6 = sub_10020744C(a3 + 400);
    uint64_t v7 = "ringtones";
    if (v6) {
      uint64_t v7 = "voice-command";
    }
    int v11 = 136446210;
    int v12 = v7;
    _os_log_impl( (void *)&_mh_execute_header,  v5,  OS_LOG_TYPE_DEFAULT,  "Making sco connection for playing %{public}s",  (uint8_t *)&v11,  0xCu);
  }

  uint64_t v8 = a1 + 360;
  if (sub_1002067C0(v8) != 1 && (sub_100206834(v8) & 1) == 0 && (sub_10020744C(a3 + 400) & 1) == 0)
  {
    if (qword_1008D9030 != -1) {
      dispatch_once(&qword_1008D9030, &stru_100899F90);
    }
    sub_100463D58((uint64_t)off_1008D9028);
  }

  uint64_t v9 = sub_10020755C(a3 + 400);
  return sub_10046D44C(v9, a3, 0, 0, v9);
}

_BYTE *sub_100470AF4(uint64_t a1, unint64_t a2, uint64_t a3)
{
  unsigned int v6 = sub_1004614EC(a1, a2);
  if (qword_1008D9108 != -1) {
    dispatch_once(&qword_1008D9108, &stru_10089A0B0);
  }
  BOOL v8 = !sub_100267404(qword_1008D9100, a2)
    && (uint64_t v7 = sub_10020746C(a3 + 400), (v7 & 1) == 0)
    && sub_10045F7E8(v7, a2) == 2;
  if (!sub_10020750C(a3 + 400) || v8)
  {
    sub_100463D58(a1);
  }

  else
  {
    uint64_t v9 = (os_log_s *)qword_1008F7598;
    if (os_log_type_enabled((os_log_t)qword_1008F7598, OS_LOG_TYPE_DEFAULT))
    {
      sub_1003CF00C(a2, __p);
      uint64_t v10 = v14 >= 0 ? __p : (void **)__p[0];
      *(_DWORD *)std::string buf = 136446210;
      int v16 = v10;
      _os_log_impl( (void *)&_mh_execute_header,  v9,  OS_LOG_TYPE_DEFAULT,  "Starting voice command session for device %{public}s",  buf,  0xCu);
      if (v14 < 0) {
        operator delete(__p[0]);
      }
    }

    if ((sub_10020744C(a3 + 400) & 1) == 0)
    {
      LOBYTE(__p[0]) = 0;
      sub_100242CA4(__p);
      sub_1000F0548(v6, 1);
      sub_100242CD0(__p);
      sub_100207454(a3 + 400, 1);
      sub_100242CD8(__p);
    }
  }

  sub_100242874(6LL);
  uint64_t v11 = sub_10020755C(a3 + 400);
  return sub_10046D44C(v11, a3, 0, 0, v11);
}

void sub_100470CC8(_Unwind_Exception *a1, uint64_t a2, ...)
{
}

uint64_t sub_100470CE4(uint64_t a1, uint64_t a2, int a3, uint64_t a4)
{
  v20[0] = 0LL;
  v20[1] = 0LL;
  sub_100242F28((uint64_t)v20, a1 + 760);
  uint64_t v7 = (os_log_s *)qword_1008F7598;
  BOOL v8 = os_log_type_enabled((os_log_t)qword_1008F7598, OS_LOG_TYPE_DEFAULT);
  if (v8)
  {
    uint64_t v9 = sub_10045F408(v8, a3);
    LODWORD(buf.__r_.__value_.__l.__data_) = 136315138;
    *(std::string::size_type *)((char *)buf.__r_.__value_.__r.__words + 4) = (std::string::size_type)v9;
    _os_log_impl( (void *)&_mh_execute_header,  v7,  OS_LOG_TYPE_DEFAULT,  "RegisterScoChannel codecID: %s\n",  (uint8_t *)&buf,  0xCu);
  }

  if (a3 <= 254)
  {
    uint64_t v10 = &off_1008D99A8;
    uint64_t v11 = &unk_1008D99C0;
    switch(a3)
    {
      case 127:
        goto LABEL_32;
      case 128:
        uint64_t v10 = (_UNKNOWN **)&unk_1008D9A20;
        uint64_t v11 = &unk_1008D9A38;
        goto LABEL_32;
      case 129:
        uint64_t v10 = (_UNKNOWN **)&unk_1008D9A48;
        uint64_t v11 = &unk_1008D9A60;
        goto LABEL_14;
      case 130:
        uint64_t v10 = (_UNKNOWN **)&unk_1008D9A70;
        uint64_t v11 = &unk_1008D9A88;
        goto LABEL_14;
      default:
        if (a3 != 2) {
          goto LABEL_27;
        }
        uint64_t v10 = &off_1008D9A98;
        uint64_t v11 = &unk_1008D9AB0;
        goto LABEL_28;
    }
  }

  if (a3 != 255)
  {
    if (a3 == 256)
    {
      uint64_t v10 = (_UNKNOWN **)&unk_1008D99F8;
      uint64_t v11 = &unk_1008D9A10;
      goto LABEL_32;
    }

void sub_10047108C( _Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, void *__p, uint64_t a16, int a17, __int16 a18, char a19, char a20)
{
}

uint64_t sub_1004710D8(uint64_t a1, char a2)
{
  v5[0] = 0LL;
  v5[1] = 0LL;
  sub_100242F28((uint64_t)v5, a1 + 760);
  if (os_log_type_enabled((os_log_t)qword_1008F7598, OS_LOG_TYPE_ERROR)) {
    sub_100682B50();
  }
  sub_100206668(a1 + 360, a2);
  return sub_100242FAC((uint64_t)v5);
}

void sub_100471158( _Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9)
{
}

uint64_t sub_10047116C(uint64_t a1, uint64_t a2)
{
  v8[0] = 0LL;
  v8[1] = 0LL;
  sub_100242F28((uint64_t)v8, a1 + 760);
  uint64_t v4 = (os_log_s *)qword_1008F7598;
  if (os_log_type_enabled((os_log_t)qword_1008F7598, OS_LOG_TYPE_DEFAULT))
  {
    *(_WORD *)uint64_t v7 = 0;
    _os_log_impl((void *)&_mh_execute_header, v4, OS_LOG_TYPE_DEFAULT, "HFP stream will start", v7, 2u);
  }

  if ((sub_100270EE4(a2) & 1) != 0)
  {
    sub_1002075FC(a2 + 400, 1);
    sub_1004603D8(a1, a2);
    sub_100502564(a2);
  }

  else
  {
    uint64_t v5 = (os_log_s *)qword_1008F7598;
    if (os_log_type_enabled((os_log_t)qword_1008F7598, OS_LOG_TYPE_DEFAULT))
    {
      *(_WORD *)uint64_t v7 = 0;
      _os_log_impl( (void *)&_mh_execute_header,  v5,  OS_LOG_TYPE_DEFAULT,  "Audio device is not valid, not handling streamWillStart",  v7,  2u);
    }
  }

  return sub_100242FAC((uint64_t)v8);
}

void sub_100471264(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, ...)
{
}

uint64_t sub_100471278(uint64_t a1, uint64_t a2)
{
  return sub_10047116C(a1 - 280, a2);
}

uint64_t sub_100471280(uint64_t a1, uint64_t a2)
{
  v7[0] = 0LL;
  v7[1] = 0LL;
  sub_100242F28((uint64_t)v7, a1 + 760);
  char v3 = sub_100270EE4(a2);
  uint64_t v4 = (os_log_s *)qword_1008F7598;
  if ((v3 & 1) != 0)
  {
    if (os_log_type_enabled((os_log_t)qword_1008F7598, OS_LOG_TYPE_DEBUG))
    {
      sub_100682BE0();
      if (a2) {
        goto LABEL_4;
      }
    }

    else if (a2)
    {
LABEL_4:
      sub_1005026F0(a2);
      return sub_100242FAC((uint64_t)v7);
    }

    if (os_log_type_enabled((os_log_t)qword_1008F7598, OS_LOG_TYPE_ERROR)) {
      sub_100682BB4();
    }
  }

  else if (os_log_type_enabled((os_log_t)qword_1008F7598, OS_LOG_TYPE_DEFAULT))
  {
    *(_WORD *)unsigned int v6 = 0;
    _os_log_impl( (void *)&_mh_execute_header,  v4,  OS_LOG_TYPE_DEFAULT,  "Audio device is not valid, not handling streamAudioAvailable",  v6,  2u);
  }

  return sub_100242FAC((uint64_t)v7);
}

void sub_100471364(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, ...)
{
}

uint64_t sub_100471378(uint64_t a1, uint64_t a2)
{
  return sub_100471280(a1 - 280, a2);
}

uint64_t sub_100471380(uint64_t a1, uint64_t a2)
{
  v7[0] = 0LL;
  v7[1] = 0LL;
  sub_100242F28((uint64_t)v7, a1 + 760);
  char v3 = (os_log_s *)qword_1008F7598;
  if (os_log_type_enabled((os_log_t)qword_1008F7598, OS_LOG_TYPE_DEFAULT))
  {
    *(_WORD *)unsigned int v6 = 0;
    _os_log_impl((void *)&_mh_execute_header, v3, OS_LOG_TYPE_DEFAULT, "Stream did stop!", v6, 2u);
  }

  if ((sub_100270EE4(a2) & 1) != 0)
  {
    if (a2)
    {
      sub_100501764(a2);
      sub_1002075FC(a2 + 400, 0);
    }
  }

  else
  {
    uint64_t v4 = (os_log_s *)qword_1008F7598;
    if (os_log_type_enabled((os_log_t)qword_1008F7598, OS_LOG_TYPE_DEFAULT))
    {
      *(_WORD *)unsigned int v6 = 0;
      _os_log_impl( (void *)&_mh_execute_header,  v4,  OS_LOG_TYPE_DEFAULT,  "Audio device is not valid, not handling streamDidStop",  v6,  2u);
    }
  }

  return sub_100242FAC((uint64_t)v7);
}

void sub_10047146C(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, ...)
{
}

uint64_t sub_100471480(uint64_t a1, uint64_t a2)
{
  return sub_100471380(a1 - 280, a2);
}

void sub_100471488(uint64_t a1, uint64_t a2)
{
  uint64_t v4 = sub_100405058();
  v5[0] = _NSConcreteStackBlock;
  v5[1] = 3221225472LL;
  void v5[2] = sub_1004714EC;
  uint64_t v5[3] = &unk_10087F8E0;
  void v5[4] = a1;
  void v5[5] = a2;
  sub_100405384(v4, v5);
}

uint64_t sub_1004714EC(uint64_t a1)
{
  uint64_t v2 = *(void *)(a1 + 32);
  v9[0] = 0LL;
  v9[1] = 0LL;
  sub_100242F28((uint64_t)v9, v2 + 760);
  char v3 = (os_log_s *)qword_1008F7598;
  if (os_log_type_enabled((os_log_t)qword_1008F7598, OS_LOG_TYPE_DEFAULT))
  {
    *(_WORD *)BOOL v8 = 0;
    _os_log_impl( (void *)&_mh_execute_header,  v3,  OS_LOG_TYPE_DEFAULT,  "Stream reset, closing SCO if it wasn't closed",  v8,  2u);
  }

  if ((sub_100270EE4(*(void *)(a1 + 40)) & 1) != 0)
  {
    uint64_t v4 = *(void *)(a1 + 40);
    if (v4 && sub_1002073AC(v4 + 400) && sub_1002073D4(*(void *)(a1 + 40) + 400LL))
    {
      unsigned int v5 = sub_1002073A4(*(void *)(a1 + 40) + 400LL);
      sub_100469A5C(v2, v5, 0, 0);
    }
  }

  else
  {
    unsigned int v6 = (os_log_s *)qword_1008F7598;
    if (os_log_type_enabled((os_log_t)qword_1008F7598, OS_LOG_TYPE_DEFAULT))
    {
      *(_WORD *)BOOL v8 = 0;
      _os_log_impl( (void *)&_mh_execute_header,  v6,  OS_LOG_TYPE_DEFAULT,  "Audio device is not valid, not handling streamDidReset",  v8,  2u);
    }
  }

  return sub_100242FAC((uint64_t)v9);
}

void sub_100471608(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, ...)
{
}

void sub_100471620(uint64_t a1, uint64_t a2)
{
  uint64_t v3 = a1 - 280;
  uint64_t v4 = sub_100405058();
  v5[0] = _NSConcreteStackBlock;
  v5[1] = 3221225472LL;
  void v5[2] = sub_1004714EC;
  uint64_t v5[3] = &unk_10087F8E0;
  void v5[4] = v3;
  void v5[5] = a2;
  sub_100405384(v4, v5);
}

uint64_t sub_100471684(uint64_t a1, uint64_t a2, float a3)
{
  v17[0] = 0LL;
  v17[1] = 0LL;
  sub_100242F28((uint64_t)v17, a1 + 760);
  if ((sub_100270EE4(a2) & 1) != 0)
  {
    if (a2)
    {
      uint64_t v5 = a2 + 400;
      unsigned int v6 = sub_1002073A4(v5);
      uint64_t v7 = sub_1002073AC(v5);
      else {
        float v8 = a3 * 15.0;
      }
      int v13 = sub_1002073F4(v5);
      char v14 = (os_log_s *)qword_1008F7598;
      BOOL v15 = os_log_type_enabled((os_log_t)qword_1008F7598, OS_LOG_TYPE_DEFAULT);
      if (v13 == (int)v8)
      {
        if (v15)
        {
          *(_DWORD *)std::string buf = 67109120;
          int v19 = (int)v8;
          uint64_t v10 = "Speaker volume is a duplicate value %d, not sending to external device";
          uint64_t v11 = v14;
          uint32_t v12 = 8;
          goto LABEL_12;
        }
      }

      else
      {
        if (v15)
        {
          *(_DWORD *)std::string buf = 67109120;
          int v19 = (int)v8;
          _os_log_impl((void *)&_mh_execute_header, v14, OS_LOG_TYPE_DEFAULT, "Volume did update to %d", buf, 8u);
        }

        buf[0] = 0;
        sub_100242CA4(buf);
        sub_1000EF838(v6, (int)v8);
        sub_100242CD0(buf);
        sub_1002073FC(v5, (int)v8);
        sub_100242CD8(buf);
      }
    }

    else if (os_log_type_enabled((os_log_t)qword_1008F7598, OS_LOG_TYPE_ERROR))
    {
      sub_100682C0C();
    }
  }

  else
  {
    uint64_t v9 = qword_1008F7598;
    if (os_log_type_enabled((os_log_t)qword_1008F7598, OS_LOG_TYPE_DEFAULT))
    {
      *(_WORD *)std::string buf = 0;
      uint64_t v10 = "Audio device is not valid, not handling volumeDidUpdate";
      uint64_t v11 = (os_log_s *)v9;
      uint32_t v12 = 2;
LABEL_12:
      _os_log_impl((void *)&_mh_execute_header, v11, OS_LOG_TYPE_DEFAULT, v10, buf, v12);
    }
  }

  return sub_100242FAC((uint64_t)v17);
}

void sub_10047189C( _Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9)
{
}

uint64_t sub_1004718D8(uint64_t a1, uint64_t a2, float a3)
{
  return sub_100471684(a1 - 280, a2, a3);
}

uint64_t sub_1004718E0(uint64_t a1, uint64_t a2, float a3)
{
  v17[0] = 0LL;
  v17[1] = 0LL;
  sub_100242F28((uint64_t)v17, a1 + 760);
  if ((sub_100270EE4(a2) & 1) != 0)
  {
    if (a2)
    {
      uint64_t v5 = a2 + 400;
      unsigned int v6 = sub_1002073A4(v5);
      uint64_t v7 = sub_1002073AC(v5);
      else {
        float v8 = a3 * 15.0;
      }
      int v13 = sub_1002073E4(v5);
      char v14 = (os_log_s *)qword_1008F7598;
      BOOL v15 = os_log_type_enabled((os_log_t)qword_1008F7598, OS_LOG_TYPE_DEFAULT);
      if (v13 == (int)v8)
      {
        if (v15)
        {
          *(_DWORD *)std::string buf = 67109120;
          int v19 = (int)v8;
          uint64_t v10 = "Input volume is a duplicate value %d, not sending to external device";
          uint64_t v11 = v14;
          uint32_t v12 = 8;
          goto LABEL_12;
        }
      }

      else
      {
        if (v15)
        {
          *(_DWORD *)std::string buf = 67109120;
          int v19 = (int)v8;
          _os_log_impl((void *)&_mh_execute_header, v14, OS_LOG_TYPE_DEFAULT, "Input volume did update to %d", buf, 8u);
        }

        buf[0] = 0;
        sub_100242CA4(buf);
        sub_1000EF764(v6, (int)v8);
        sub_100242CD0(buf);
        sub_1002073EC(v5, (int)v8);
        sub_100242CD8(buf);
      }
    }

    else if (os_log_type_enabled((os_log_t)qword_1008F7598, OS_LOG_TYPE_ERROR))
    {
      sub_100682C0C();
    }
  }

  else
  {
    uint64_t v9 = qword_1008F7598;
    if (os_log_type_enabled((os_log_t)qword_1008F7598, OS_LOG_TYPE_DEFAULT))
    {
      *(_WORD *)std::string buf = 0;
      uint64_t v10 = "Audio device is not valid, not handling inputVolumeDidUpdate";
      uint64_t v11 = (os_log_s *)v9;
      uint32_t v12 = 2;
LABEL_12:
      _os_log_impl((void *)&_mh_execute_header, v11, OS_LOG_TYPE_DEFAULT, v10, buf, v12);
    }
  }

  return sub_100242FAC((uint64_t)v17);
}

void sub_100471AF8( _Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9)
{
}

uint64_t sub_100471B34(uint64_t a1, uint64_t a2, float a3)
{
  return sub_1004718E0(a1 - 280, a2, a3);
}

void sub_100471B3C(uint64_t a1, uint64_t a2, uint64_t a3)
{
  unsigned int v6 = (os_log_s *)qword_1008F7598;
  if (os_log_type_enabled((os_log_t)qword_1008F7598, OS_LOG_TYPE_DEFAULT))
  {
    v8[0] = 67109120;
    v8[1] = a3;
    _os_log_impl( (void *)&_mh_execute_header,  v6,  OS_LOG_TYPE_DEFAULT,  "SCO sample Rate updated to %d ",  (uint8_t *)v8,  8u);
  }

  if ((sub_100270EE4(a2) & 1) != 0)
  {
    (*(void (**)(uint64_t, uint64_t, uint64_t, void, void))(*(void *)a1 + 264LL))(a1, a2, a3, 0LL, 0LL);
  }

  else
  {
    uint64_t v7 = (os_log_s *)qword_1008F7598;
    if (os_log_type_enabled((os_log_t)qword_1008F7598, OS_LOG_TYPE_DEFAULT))
    {
      LOWORD(v8[0]) = 0;
      _os_log_impl( (void *)&_mh_execute_header,  v7,  OS_LOG_TYPE_DEFAULT,  "Audio device is not valid, not handling scoSampleRateDidUpdate",  (uint8_t *)v8,  2u);
    }
  }

void sub_100471C60(uint64_t a1, uint64_t a2, uint64_t a3)
{
}

void sub_100471C68(uint64_t a1, uint64_t a2, char a3)
{
  uint64_t v6 = sub_100405058();
  v7[0] = _NSConcreteStackBlock;
  v7[1] = 3221225472LL;
  void v7[2] = sub_100471CDC;
  uint64_t v7[3] = &unk_100886EE0;
  _OWORD v7[4] = a1;
  void v7[5] = a2;
  char v8 = a3;
  sub_100405384(v6, v7);
}

uint64_t sub_100471CDC(uint64_t a1)
{
  uint64_t v2 = *(void *)(a1 + 32);
  v12[0] = 0LL;
  v12[1] = 0LL;
  sub_100242F28((uint64_t)v12, v2 + 760);
  if ((sub_100270EE4(*(void *)(a1 + 40)) & 1) != 0)
  {
    uint64_t v3 = *(void *)(a1 + 40);
    if (v3)
    {
      uint64_t v4 = sub_1002073AC(v3 + 400);
      if (v4)
      {
        uint64_t v5 = (os_log_s *)qword_1008F7598;
        if (os_log_type_enabled((os_log_t)qword_1008F7598, OS_LOG_TYPE_DEFAULT))
        {
          int v6 = *(unsigned __int8 *)(a1 + 48);
          sub_1003CF00C(v4, __p);
          if (v11 >= 0) {
            uint64_t v7 = __p;
          }
          else {
            uint64_t v7 = (void **)__p[0];
          }
          *(_DWORD *)std::string buf = 67109378;
          int v14 = v6;
          __int16 v15 = 2082;
          char v16 = v7;
          _os_log_impl( (void *)&_mh_execute_header,  v5,  OS_LOG_TYPE_DEFAULT,  "Setting allowScoForTBT to %d for device %{public}s",  buf,  0x12u);
          if (v11 < 0) {
            operator delete(__p[0]);
          }
        }

        sub_1003DA3E0(v4, *(unsigned __int8 *)(a1 + 48));
      }
    }
  }

  else
  {
    char v8 = (os_log_s *)qword_1008F7598;
    if (os_log_type_enabled((os_log_t)qword_1008F7598, OS_LOG_TYPE_DEFAULT))
    {
      LOWORD(__p[0]) = 0;
      _os_log_impl( (void *)&_mh_execute_header,  v8,  OS_LOG_TYPE_DEFAULT,  "Audio device is not valid, not handling allowSCOForTBTDidUpdate",  (uint8_t *)__p,  2u);
    }
  }

  return sub_100242FAC((uint64_t)v12);
}

void sub_100471E60(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, ...)
{
}

void sub_100471E84(uint64_t a1, uint64_t a2, char a3)
{
}

void sub_100471E8C(uint64_t a1, uint64_t a2, char a3)
{
  __int16 v5 = sub_1002073A4(a2 + 400);
  uint64_t v6 = sub_100405058();
  v7[0] = _NSConcreteStackBlock;
  v7[1] = 3221225472LL;
  void v7[2] = sub_100471F0C;
  uint64_t v7[3] = &unk_100893298;
  _OWORD v7[4] = a1;
  __int16 v8 = v5;
  char v9 = a3;
  sub_100405384(v6, v7);
}

uint64_t sub_100471F0C(uint64_t a1)
{
  uint64_t v2 = *(void *)(a1 + 32);
  v34[0] = 0LL;
  v34[1] = 0LL;
  sub_100242F28((uint64_t)v34, v2 + 760);
  uint64_t v3 = sub_10045CF60(v2, *(unsigned __int16 *)(a1 + 40));
  if (v3)
  {
    uint64_t v4 = (uint64_t)(v3 + 50);
    uint64_t v5 = sub_1002073AC((uint64_t)(v3 + 50));
    if (sub_1003D2B2C(v5, 12))
    {
      uint64_t v6 = (os_log_s *)qword_1008F7598;
      if (os_log_type_enabled((os_log_t)qword_1008F7598, OS_LOG_TYPE_DEFAULT))
      {
        sub_1003CF00C(v5, v39);
        if (v41 >= 0) {
          uint64_t v7 = v39;
        }
        else {
          uint64_t v7 = *(uint8_t **)v39;
        }
        LODWORD(buf.__r_.__value_.__l.__data_) = 136446210;
        *(std::string::size_type *)((char *)buf.__r_.__value_.__r.__words + 4) = (std::string::size_type)v7;
        _os_log_impl( (void *)&_mh_execute_header,  v6,  OS_LOG_TYPE_DEFAULT,  "Received expanseInA2DP for Apple audio device %{public}s",  (uint8_t *)&buf,  0xCu);
        if (SHIBYTE(v41) < 0) {
          operator delete(*(void **)v39);
        }
      }
    }

    else
    {
      int v8 = sub_100206EB0(v2 + 360);
      sub_100206E6C(v2 + 360, *(_BYTE *)(a1 + 42));
      char v9 = (os_log_s *)qword_1008F7598;
      if (os_log_type_enabled((os_log_t)qword_1008F7598, OS_LOG_TYPE_DEFAULT))
      {
        int v10 = *(unsigned __int8 *)(a1 + 42);
        *(_DWORD *)unsigned int v39 = 67109376;
        *(_DWORD *)&v39[4] = v8;
        LOWORD(v4sub_100414D2C(qword_1008F72C0, 0) = 1024;
        *(_DWORD *)((char *)&v40 + 2) = v10;
        _os_log_impl( (void *)&_mh_execute_header,  v9,  OS_LOG_TYPE_DEFAULT,  "Expanse in A2DP state changed from %d to %d",  v39,  0xEu);
      }

      int v11 = *(unsigned __int8 *)(a1 + 42);
      uint32_t v12 = (os_log_s *)qword_1008F7598;
      BOOL v13 = os_log_type_enabled((os_log_t)qword_1008F7598, OS_LOG_TYPE_DEFAULT);
      if (v11)
      {
        if (v13)
        {
          sub_1003CF00C(v5, v39);
          int v14 = v41 >= 0 ? v39 : *(uint8_t **)v39;
          LODWORD(buf.__r_.__value_.__l.__data_) = 136446210;
          *(std::string::size_type *)((char *)buf.__r_.__value_.__r.__words + 4) = (std::string::size_type)v14;
          _os_log_impl( (void *)&_mh_execute_header,  v12,  OS_LOG_TYPE_DEFAULT,  "Setting IsInExpanseOverA2DP to true for device %{public}s",  (uint8_t *)&buf,  0xCu);
          if (SHIBYTE(v41) < 0) {
            operator delete(*(void **)v39);
          }
        }

        sub_1002077A0(v4, 1);
        *(void *)unsigned int v39 = 0LL;
        BOOL v40 = 0LL;
        uint64_t v41 = 0LL;
        sub_10053C3D8(v39);
        if (qword_1008D90F8 != -1) {
          dispatch_once(&qword_1008D90F8, &stru_10089A050);
        }
        sub_10054AA2C((uint64_t)off_1008D90F0);
        __int16 v15 = (os_log_s *)qword_1008F7598;
        if (os_log_type_enabled((os_log_t)qword_1008F7598, OS_LOG_TYPE_DEFAULT))
        {
          sub_10053C68C((uint64_t *)v39, &buf);
          char v16 = (buf.__r_.__value_.__s.__size_ & 0x80u) == 0 ? &buf : (std::string *)buf.__r_.__value_.__r.__words[0];
          LODWORD(v35.__r_.__value_.__l.__data_) = 136315138;
          *(std::string::size_type *)((char *)v35.__r_.__value_.__r.__words + 4) = (std::string::size_type)v16;
          _os_log_impl( (void *)&_mh_execute_header,  v15,  OS_LOG_TYPE_DEFAULT,  "Current Call(s) in expanse: %s",  (uint8_t *)&v35,  0xCu);
        }

        sub_10053C460((int)v33);
        sub_100206F54(v2 + 360, v33);
        buf.__r_.__value_.__r.__words[0] = (std::string::size_type)v33;
        sub_1002077E0((void ***)&buf);
        for (uint64_t i = *(uint8_t **)v39; i != (uint8_t *)v40; i += 104)
        {
          if (*((_DWORD *)i + 4) == 1)
          {
            std::string v27 = (os_log_s *)qword_1008F7598;
            if (os_log_type_enabled((os_log_t)qword_1008F7598, OS_LOG_TYPE_DEFAULT))
            {
              LOWORD(buf.__r_.__value_.__l.__data_) = 0;
              _os_log_impl( (void *)&_mh_execute_header,  v27,  OS_LOG_TYPE_DEFAULT,  "Update overall call(s) status after a current active call has entered expanse",  (uint8_t *)&buf,  2u);
            }

            memset(&buf, 0, sizeof(buf));
            sub_10053C3D8(&buf);
            if (qword_1008D90F8 != -1) {
              dispatch_once(&qword_1008D90F8, &stru_10089A050);
            }
            sub_10054AA1C((uint64_t)off_1008D90F0);
            *(_OWORD *)&v35.__r_.__value_.__l.__data_ = 0uLL;
            id v28 = -[NSUUID initWithUUIDBytes:](objc_alloc(&OBJC_CLASS___NSUUID), "initWithUUIDBytes:", &v35);
            sub_10046400C(v2, (uint64_t *)&buf, v28);

            goto LABEL_71;
          }
        }
      }

      else
      {
        if (v13)
        {
          sub_1003CF00C(v5, v39);
          int v18 = v41 >= 0 ? v39 : *(uint8_t **)v39;
          LODWORD(buf.__r_.__value_.__l.__data_) = 136446210;
          *(std::string::size_type *)((char *)buf.__r_.__value_.__r.__words + 4) = (std::string::size_type)v18;
          _os_log_impl( (void *)&_mh_execute_header,  v12,  OS_LOG_TYPE_DEFAULT,  "Setting IsInExpanseOverA2DP to false for device %{public}s",  (uint8_t *)&buf,  0xCu);
          if (SHIBYTE(v41) < 0) {
            operator delete(*(void **)v39);
          }
        }

        sub_1002077A0(v4, 0);
        *(void *)unsigned int v39 = 0LL;
        BOOL v40 = 0LL;
        uint64_t v41 = 0LL;
        sub_10053C3D8(v39);
        if (qword_1008D90F8 != -1) {
          dispatch_once(&qword_1008D90F8, &stru_10089A050);
        }
        sub_10054AA1C((uint64_t)off_1008D90F0);
        memset(&buf, 0, sizeof(buf));
        sub_100206EF4(v2 + 360, (int)&buf);
        int v19 = (os_log_s *)qword_1008F7598;
        if (os_log_type_enabled((os_log_t)qword_1008F7598, OS_LOG_TYPE_DEFAULT))
        {
          sub_10053C68C((uint64_t *)&buf, &v35);
          if ((v35.__r_.__value_.__s.__size_ & 0x80u) == 0) {
            char v20 = &v35;
          }
          else {
            char v20 = (std::string *)v35.__r_.__value_.__r.__words[0];
          }
          *(_DWORD *)uint64_t v36 = 136315138;
          char v37 = v20;
          _os_log_impl((void *)&_mh_execute_header, v19, OS_LOG_TYPE_DEFAULT, "Call(s) in A2DP expanse: %s", v36, 0xCu);
          int v19 = (os_log_s *)qword_1008F7598;
        }

        if (os_log_type_enabled(v19, OS_LOG_TYPE_DEFAULT))
        {
          sub_10053C68C((uint64_t *)v39, &v35);
          int v21 = (v35.__r_.__value_.__s.__size_ & 0x80u) == 0 ? &v35 : (std::string *)v35.__r_.__value_.__r.__words[0];
          *(_DWORD *)uint64_t v36 = 136315138;
          char v37 = v21;
          _os_log_impl((void *)&_mh_execute_header, v19, OS_LOG_TYPE_DEFAULT, "Current Call(s): %s", v36, 0xCu);
        }

        if (buf.__r_.__value_.__r.__words[0] == buf.__r_.__value_.__l.__size_)
        {
          BOOL v25 = 1;
        }

        else
        {
          std::string::size_type v22 = buf.__r_.__value_.__r.__words[0] + 104;
          do
          {
            id v23 = *(id *)(v22 - 104);
            std::string v24 = sub_10053C584((id **)v39, v23);

            BOOL v25 = v40 == v24;
            BOOL v26 = v40 != v24 || v22 == buf.__r_.__value_.__l.__size_;
            v22 += 104LL;
          }

          while (!v26);
        }

        sub_10053C4B4((uint64_t *)&buf);
        sub_10053C460((int)v32);
        sub_100206F54(v2 + 360, v32);
        v35.__r_.__value_.__r.__words[0] = (std::string::size_type)v32;
        sub_1002077E0((void ***)&v35);
        if (!v25)
        {
          int v29 = (os_log_s *)qword_1008F7598;
          if (os_log_type_enabled((os_log_t)qword_1008F7598, OS_LOG_TYPE_DEFAULT))
          {
            LOWORD(v35.__r_.__value_.__l.__data_) = 0;
            _os_log_impl( (void *)&_mh_execute_header,  v29,  OS_LOG_TYPE_DEFAULT,  "Update overall call(s) status since a current active call has exited expanse",  (uint8_t *)&v35,  2u);
          }

          *(_OWORD *)&v35.__r_.__value_.__l.__data_ = 0uLL;
          char v30 = -[NSUUID initWithUUIDBytes:](objc_alloc(&OBJC_CLASS___NSUUID), "initWithUUIDBytes:", &v35);
          sub_10046400C(v2, (uint64_t *)v39, v30);
        }

void sub_10047260C( _Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, char a15, uint64_t a16, void ***a17, uint64_t a18, uint64_t a19, uint64_t a20, uint64_t a21, uint64_t a22, void **a23)
{
  a17 = &a23;
  sub_1002077E0((void ***)&a17);
  a23 = (void **)(v24 - 112);
  sub_1002077E0(&a23);
  sub_100242FAC((uint64_t)&a15);
  _Unwind_Resume(a1);
}

void sub_1004726E0(uint64_t a1, uint64_t a2, char a3)
{
}

void sub_1004726E8(uint64_t a1, uint64_t a2, int a3)
{
  uint64_t v4 = (os_log_s *)qword_1008F7598;
  BOOL v5 = os_log_type_enabled((os_log_t)qword_1008F7598, OS_LOG_TYPE_DEFAULT);
  if (a3)
  {
    if (!v5) {
      return;
    }
    __int16 v9 = 0;
    uint64_t v6 = "Call Screening Property is set.";
    uint64_t v7 = (uint8_t *)&v9;
  }

  else
  {
    if (!v5) {
      return;
    }
    __int16 v8 = 0;
    uint64_t v6 = "Call Screening Property is cleared.";
    uint64_t v7 = (uint8_t *)&v8;
  }

  _os_log_impl((void *)&_mh_execute_header, v4, OS_LOG_TYPE_DEFAULT, v6, v7, 2u);
}

void sub_100472778()
{
  if (os_log_type_enabled((os_log_t)qword_1008F7598, OS_LOG_TYPE_ERROR)) {
    sub_100682C9C();
  }
}

_BYTE *sub_1004727BC(uint64_t a1, uint64_t a2)
{
  uint64_t v2 = a2 + 400;
  uint64_t v3 = sub_1002073AC(a2 + 400);
  uint64_t v4 = (os_log_s *)qword_1008F7598;
  if (os_log_type_enabled((os_log_t)qword_1008F7598, OS_LOG_TYPE_DEFAULT))
  {
    sub_1003CF00C(v3, __p);
    if (v9 >= 0) {
      BOOL v5 = __p;
    }
    else {
      BOOL v5 = (void **)__p[0];
    }
    *(_DWORD *)std::string buf = 136446210;
    int v11 = v5;
    _os_log_impl( (void *)&_mh_execute_header,  v4,  OS_LOG_TYPE_DEFAULT,  "Transitioning HFP audio to unidirectional for device %{public}s",  buf,  0xCu);
    if (v9 < 0) {
      operator delete(__p[0]);
    }
  }

  unsigned int v6 = sub_1002073A4(v2);
  LOBYTE(__p[0]) = 0;
  sub_100242CA4(__p);
  sub_1000F1330(v6);
  return sub_100242CD8(__p);
}

void sub_1004728C8(_Unwind_Exception *a1, uint64_t a2, ...)
{
}

void sub_1004728E8(uint64_t a1, uint64_t a2, int a3)
{
  uint64_t v4 = (os_log_s *)qword_1008F7598;
  if (os_log_type_enabled((os_log_t)qword_1008F7598, OS_LOG_TYPE_DEFAULT))
  {
    v5[0] = 67109120;
    v5[1] = a3;
    _os_log_impl( (void *)&_mh_execute_header,  v4,  OS_LOG_TYPE_DEFAULT,  "HandsfreeGateway setAudioTransport to advanced sniff %d",  (uint8_t *)v5,  8u);
  }

void sub_100472998(uint64_t a1, uint64_t a2, int a3, int a4, int a5)
{
  int v10 = (os_log_s *)qword_1008F7598;
  if (os_log_type_enabled((os_log_t)qword_1008F7598, OS_LOG_TYPE_DEFAULT))
  {
    *(_DWORD *)std::string buf = 67109888;
    int v29 = a4;
    __int16 v30 = 1024;
    *(_DWORD *)uint64_t v31 = a5;
    *(_WORD *)&uint8_t v31[4] = 1024;
    *(_DWORD *)&_BYTE v31[6] = sub_10020755C(a2 + 400);
    *(_WORD *)BOOL v32 = 1024;
    *(_DWORD *)&void v32[2] = sub_10020756C(a2 + 400);
    _os_log_impl( (void *)&_mh_execute_header,  v10,  OS_LOG_TYPE_DEFAULT,  "setAudioCodec updateStereoCodec %d, inputCodecID %d callcodec %d AoS %d",  buf,  0x1Au);
  }

  if (a2)
  {
    uint64_t v11 = a2 + 400;
    uint64_t v12 = sub_1002073AC(a2 + 400);
    if (v12)
    {
      uint64_t v13 = v12;
      int v14 = a5;
      if ((a4 & 1) == 0) {
        int v14 = sub_10020755C(v11);
      }
      if (a3 == 48000 && v14 == 130)
      {
        char v15 = 0;
        int v16 = 130;
      }

      else if (a3 == 48000 && v14 == 129)
      {
        char v15 = 0;
        int v16 = 129;
      }

      else if (a3 == 48000 && v14 == 255)
      {
        char v15 = 0;
        int v16 = 255;
      }

      else if (a3 == 24000 && v14 == 128)
      {
        char v15 = 0;
        int v16 = 128;
      }

      else
      {
        uint64_t v17 = sub_10045D7CC(a1, v13);
        if (v17 && (char v18 = sub_1002074EC(v17 + 400), a3 == 24000) && (v18 & 1) != 0)
        {
          char v15 = 0;
          int v16 = 127;
        }

        else
        {
          char v19 = sub_10045FA58(a1, v13);
          if (a3 == 24000 && (v19 & 1) != 0)
          {
            char v15 = 0;
            int v16 = 256;
          }

          else
          {
            char v20 = sub_10045FA34(a1, v13);
            if (a3 == 16000 && (v20 & 1) != 0)
            {
              char v15 = 0;
              int v16 = 2;
            }

            else if (a3 == 8000)
            {
              char v15 = 0;
              int v16 = 1;
            }

            else
            {
              if (os_log_type_enabled((os_log_t)qword_1008F7598, OS_LOG_TYPE_ERROR)) {
                sub_100682D20();
              }
              int v16 = 0;
              char v15 = 1;
            }
          }
        }
      }

      if (a5 || (a4 & 1) != 0 || (int v21 = sub_10020756C(v11), a3 != 48000) || !v21)
      {
        if ((v15 & 1) != 0)
        {
          int v16 = 0;
          goto LABEL_46;
        }
      }

      else
      {
        if (os_log_type_enabled((os_log_t)qword_1008F7598, OS_LOG_TYPE_ERROR)) {
          sub_100682CF4();
        }
        int v16 = 130;
      }

      sub_100207564(v11, v16);
LABEL_46:
      std::string::size_type v22 = (os_log_s *)qword_1008F7598;
      BOOL v23 = os_log_type_enabled((os_log_t)qword_1008F7598, OS_LOG_TYPE_DEFAULT);
      if (v23)
      {
        uint64_t v24 = sub_10045F408(v23, v16);
        sub_1003D0100(v13, (uint64_t)__p);
        if (v27 >= 0) {
          BOOL v25 = __p;
        }
        else {
          BOOL v25 = (void **)__p[0];
        }
        *(_DWORD *)std::string buf = 67110147;
        int v29 = v14;
        __int16 v30 = 2080;
        *(void *)uint64_t v31 = v24;
        *(_WORD *)&v31[8] = 1024;
        *(_DWORD *)BOOL v32 = a3;
        *(_WORD *)&v32[4] = 2160;
        uint64_t v33 = 1752392040LL;
        __int16 v34 = 2081;
        std::string v35 = v25;
        _os_log_impl( (void *)&_mh_execute_header,  v22,  OS_LOG_TYPE_DEFAULT,  "setAudioCodec stereoCodecID %d, new codec %s sampleRate %d for device %{private, mask.hash}s",  buf,  0x2Cu);
        if (v27 < 0) {
          operator delete(__p[0]);
        }
      }

      return;
    }
  }

  if (os_log_type_enabled((os_log_t)qword_1008F7598, OS_LOG_TYPE_ERROR)) {
    sub_100682CC8();
  }
}

void sub_100472D44(uint64_t a1, uint64_t a2, int a3, int a4, int a5)
{
}

void sub_100472D4C(uint64_t a1, uint64_t a2, int a3)
{
  uint64_t v6 = a2 + 400;
  uint64_t v7 = sub_1002073AC(a2 + 400);
  if (a3 > 1935827570)
  {
    if (a3 != 1935827571)
    {
      if (a3 == 1936221033)
      {
        uint64_t v12 = (os_log_s *)qword_1008F7598;
        if (os_log_type_enabled((os_log_t)qword_1008F7598, OS_LOG_TYPE_DEFAULT))
        {
          sub_1003D0100(v7, (uint64_t)&__p);
          uint64_t v13 = SBYTE3(v31) >= 0 ? &__p : (void **)__p;
          *(_DWORD *)BOOL v23 = 141558275;
          *(void *)&v23[4] = 1752392040LL;
          __int16 v24 = 2081;
          BOOL v25 = v13;
          _os_log_impl( (void *)&_mh_execute_header,  v12,  OS_LOG_TYPE_DEFAULT,  "Sco data source selected for HCI for device %{private, mask.hash}s",  v23,  0x16u);
          if (SBYTE3(v31) < 0) {
            operator delete(__p);
          }
        }

        int v10 = 2;
        int v11 = 2;
        goto LABEL_38;
      }

      goto LABEL_40;
    }

    int v16 = (os_log_s *)qword_1008F7598;
    if (os_log_type_enabled((os_log_t)qword_1008F7598, OS_LOG_TYPE_DEFAULT))
    {
      sub_1003D0100(v7, (uint64_t)&__p);
      if (SBYTE3(v31) >= 0) {
        p_p = &__p;
      }
      else {
        p_p = (void **)__p;
      }
      *(_DWORD *)BOOL v23 = 141558275;
      *(void *)&v23[4] = 1752392040LL;
      __int16 v24 = 2081;
      BOOL v25 = p_p;
      _os_log_impl( (void *)&_mh_execute_header,  v16,  OS_LOG_TYPE_DEFAULT,  "Sco data source selected for baseband to PCM for device %{private, mask.hash}s",  v23,  0x16u);
      if (SBYTE3(v31) < 0) {
        operator delete(__p);
      }
      int v16 = (os_log_s *)qword_1008F7598;
    }

    if (os_log_type_enabled(v16, OS_LOG_TYPE_DEFAULT))
    {
      LOWORD(__p) = 0;
      _os_log_impl( (void *)&_mh_execute_header,  v16,  OS_LOG_TYPE_DEFAULT,  "Highland Park I2S to PCM route selected. Forcing CVSD.",  (uint8_t *)&__p,  2u);
    }

    int v10 = 1;
    sub_100207564(v6, 1);
LABEL_37:
    int v11 = 3;
LABEL_38:
    uint64_t v18 = sub_1002E6E9C();
    sub_1002D0934(v18, v7, v10);
    sub_1002075A4(v6, v11);
    int v19 = sub_10020755C(v6);
    sub_100470CE4(a1, v7, v19, a2);
    return;
  }

  if (a3 == 1935765619)
  {
    int v14 = (os_log_s *)qword_1008F7598;
    if (os_log_type_enabled((os_log_t)qword_1008F7598, OS_LOG_TYPE_DEFAULT))
    {
      sub_1003D0100(v7, (uint64_t)&__p);
      char v15 = SBYTE3(v31) >= 0 ? &__p : (void **)__p;
      *(_DWORD *)BOOL v23 = 141558275;
      *(void *)&v23[4] = 1752392040LL;
      __int16 v24 = 2081;
      BOOL v25 = v15;
      _os_log_impl( (void *)&_mh_execute_header,  v14,  OS_LOG_TYPE_DEFAULT,  "Sco data source selected for AP I2S 8kHz for device %{private, mask.hash}s",  v23,  0x16u);
      if (SBYTE3(v31) < 0) {
        operator delete(__p);
      }
    }

    int v10 = 3;
    goto LABEL_37;
  }

  if (a3 == 1935765620)
  {
    __int16 v8 = (os_log_s *)qword_1008F7598;
    if (os_log_type_enabled((os_log_t)qword_1008F7598, OS_LOG_TYPE_DEFAULT))
    {
      sub_1003D0100(v7, (uint64_t)&__p);
      if (SBYTE3(v31) >= 0) {
        char v9 = &__p;
      }
      else {
        char v9 = (void **)__p;
      }
      *(_DWORD *)BOOL v23 = 141558275;
      *(void *)&v23[4] = 1752392040LL;
      __int16 v24 = 2081;
      BOOL v25 = v9;
      _os_log_impl( (void *)&_mh_execute_header,  v8,  OS_LOG_TYPE_DEFAULT,  "Sco data source selected for AP I2S 16kHz for device %{private, mask.hash}s",  v23,  0x16u);
      if (SBYTE3(v31) < 0) {
        operator delete(__p);
      }
    }

    int v10 = 4;
    int v11 = 4;
    goto LABEL_38;
  }

void sub_100473248(uint64_t a1, uint64_t a2, int a3, int a4, int a5)
{
  __int16 v9 = sub_1002073A4(a2 + 400);
  uint64_t v10 = sub_100405058();
  v11[0] = _NSConcreteStackBlock;
  v11[1] = 3221225472LL;
  _DWORD v11[2] = sub_1004732DC;
  _OWORD v11[3] = &unk_100899CF0;
  void v11[4] = a1;
  __int16 v15 = v9;
  int v12 = a4;
  int v13 = a5;
  int v14 = a3;
  sub_100405384(v10, v11);
}

uint64_t sub_1004732DC(uint64_t a1)
{
  uint64_t v2 = *(void *)(a1 + 32);
  v34[0] = 0LL;
  v34[1] = 0LL;
  sub_100242F28((uint64_t)v34, v2 + 760);
  uint64_t v3 = sub_10045CF60(v2, *(unsigned __int16 *)(a1 + 52));
  uint64_t v4 = v3;
  if (!v3)
  {
    uint64_t v15 = qword_1008F7598;
    if (!os_log_type_enabled((os_log_t)qword_1008F7598, OS_LOG_TYPE_DEFAULT)) {
      return sub_100242FAC((uint64_t)v34);
    }
    int v16 = *(unsigned __int16 *)(a1 + 52);
    *(_DWORD *)std::string buf = 67109120;
    *(_DWORD *)&uint8_t buf[4] = v16;
    uint64_t v17 = "No AudioDevice found for handle %d, not handling selectScoDataSource";
    uint64_t v18 = (os_log_s *)v15;
    uint32_t v19 = 8;
LABEL_8:
    _os_log_impl((void *)&_mh_execute_header, v18, OS_LOG_TYPE_DEFAULT, v17, buf, v19);
    return sub_100242FAC((uint64_t)v34);
  }

  uint64_t v5 = (uint64_t)(v3 + 50);
  uint64_t v6 = sub_1002073AC((uint64_t)(v3 + 50));
  if (!v6) {
    return sub_100242FAC((uint64_t)v34);
  }
  int v7 = *(_DWORD *)(a1 + 40);
  if (!v7)
  {
    char v20 = (os_log_s *)qword_1008F7598;
    if (os_log_type_enabled((os_log_t)qword_1008F7598, OS_LOG_TYPE_DEFAULT))
    {
      sub_1003CF00C(v6, buf);
      int v21 = (SBYTE7(v43) & 0x80u) == 0 ? buf : *(uint8_t **)buf;
      *(_DWORD *)std::string v35 = 136446210;
      *(void *)uint64_t v36 = v21;
      _os_log_impl( (void *)&_mh_execute_header,  v20,  OS_LOG_TYPE_DEFAULT,  "Sco route is disabled for device %{public}s",  v35,  0xCu);
      if (SBYTE7(v43) < 0) {
        operator delete(*(void **)buf);
      }
    }

    if (sub_1002073D4(v5))
    {
      unsigned int v22 = sub_1002073A4(v5);
      sub_100469A5C(v2, v22, 0, 116);
      return sub_100242FAC((uint64_t)v34);
    }

    uint64_t v30 = qword_1008F7598;
    if (!os_log_type_enabled((os_log_t)qword_1008F7598, OS_LOG_TYPE_DEFAULT)) {
      return sub_100242FAC((uint64_t)v34);
    }
    *(_WORD *)std::string buf = 0;
    uint64_t v17 = "already disconnected no need disconnect audio";
    uint64_t v18 = (os_log_s *)v30;
    uint32_t v19 = 2;
    goto LABEL_8;
  }

  sub_100206774((uint64_t)(v4 + 50), v7);
  unsigned int v8 = sub_1002073A4((uint64_t)(v4 + 50));
  char v33 = 0;
  sub_100242CA4(&v33);
  BOOL v9 = sub_10011A138(0LL);
  BOOL v10 = sub_1000F6188(v8);
  int v11 = sub_1000F6024(v8);
  sub_100242CD0(&v33);
  uint64_t v44 = 0LL;
  *(_OWORD *)std::string buf = 0u;
  __int128 v43 = 0u;
  int v12 = *(_DWORD *)(a1 + 44);
  uint64_t v13 = sub_10045D7CC(v2, v6);
  if (v13) {
    int v14 = sub_1002074BC(v13 + 400);
  }
  else {
    int v14 = 0;
  }
  sub_100473764(v12, v14, (uint64_t)buf);
  if (v10)
  {
    *(_DWORD *)std::string v35 = sub_10020755C((uint64_t)(v4 + 50));
    BOOL v10 = sub_1004781E8(buf, (unsigned int *)v35) == 0LL;
  }

  if (v9 || v10 || v11 == 4)
  {
    BOOL v23 = (os_log_s *)qword_1008F7598;
    if (os_log_type_enabled((os_log_t)qword_1008F7598, OS_LOG_TYPE_DEFAULT))
    {
      sub_1003D0100(v6, (uint64_t)__p);
      __int16 v24 = v32 >= 0 ? __p : (void **)__p[0];
      *(_DWORD *)std::string v35 = 136446978;
      *(void *)uint64_t v36 = v24;
      *(_WORD *)&v36[8] = 1024;
      BOOL v37 = v9;
      __int16 v38 = 1024;
      BOOL v39 = v10;
      __int16 v40 = 1024;
      BOOL v41 = v11 == 4;
      _os_log_impl( (void *)&_mh_execute_header,  v23,  OS_LOG_TYPE_DEFAULT,  "Deferring route change to %{public}s, will retry when disconnect stack event fires - possibleSCOActivity:%d samp leRateChangedWhileScoWasOpen:%d isHandsfreeAoSDisconnecting:%d",  v35,  0x1Eu);
      if (v32 < 0) {
        operator delete(__p[0]);
      }
    }

    sub_1002069E8(v2 + 360, *(_DWORD *)(a1 + 48), *(_DWORD *)(a1 + 40), *(_DWORD *)(a1 + 44), v8);
    if (v10)
    {
      BOOL v25 = (os_log_s *)qword_1008F7598;
      if (os_log_type_enabled((os_log_t)qword_1008F7598, OS_LOG_TYPE_DEFAULT))
      {
        uint64_t v26 = sub_10020755C(v5);
        int v27 = sub_10047389C(v26, v26);
        int v28 = *(_DWORD *)(a1 + 44);
        *(_DWORD *)std::string v35 = 67109376;
        *(_DWORD *)uint64_t v36 = v27;
        *(_WORD *)&uint8_t v36[4] = 1024;
        *(_DWORD *)&v36[6] = v28;
        _os_log_impl( (void *)&_mh_execute_header,  v25,  OS_LOG_TYPE_DEFAULT,  "Sample rate changed from %d to %d while doing 2->1 sco session workaround, exlicitly closing sco here before c hanging sample rate",  v35,  0xEu);
      }

      sub_100242C98(&v33);
      sub_1000F604C(v8);
    }
  }

  else
  {
    (*(void (**)(uint64_t, uint64_t *, void, void, void))(*(void *)v2 + 144LL))( v2,  v4,  *(unsigned int *)(a1 + 48),  *(unsigned int *)(a1 + 40),  *(unsigned int *)(a1 + 44));
  }

  sub_100051650((uint64_t)buf);
  sub_100242CD8(&v33);
  return sub_100242FAC((uint64_t)v34);
}

void sub_100473700( _Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, int a12, __int16 a13, char a14, char a15, char a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20, uint64_t a21, char a22)
{
}

uint64_t sub_100473764@<X0>(int a1@<W1>, int a2@<W2>, uint64_t a3@<X8>)
{
  if (a1 <= 23999)
  {
    if (a1 == 8000)
    {
      LODWORD(v_Block_object_dispose(va, 8) = 1;
LABEL_19:
      uint64_t v4 = a3;
      uint64_t v5 = 1LL;
      return sub_10047829C(v4, (unsigned int *)&v8, v5);
    }

    if (a1 != 16000) {
      goto LABEL_14;
    }
    int v6 = 2;
LABEL_18:
    LODWORD(v_Block_object_dispose(va, 8) = v6;
    goto LABEL_19;
  }

  if (a1 == 24000)
  {
    if (a2) {
      int v6 = 128;
    }
    else {
      int v6 = 256;
    }
    goto LABEL_18;
  }

  if (a1 == 32000)
  {
    int v6 = 127;
    goto LABEL_18;
  }

  if (a1 != 48000)
  {
LABEL_14:
    if (os_log_type_enabled((os_log_t)qword_1008F7598, OS_LOG_TYPE_ERROR)) {
      sub_100682D88();
    }
    goto LABEL_16;
  }

  if (!a2)
  {
LABEL_16:
    LODWORD(v_Block_object_dispose(va, 8) = 0;
    goto LABEL_19;
  }

  uint64_t v8 = 0x8200000081LL;
  uint64_t v4 = a3;
  uint64_t v5 = 2LL;
  return sub_10047829C(v4, (unsigned int *)&v8, v5);
}

uint64_t sub_10047389C(uint64_t a1, int a2)
{
  uint64_t result = 24000LL;
  if (a2 > 128)
  {
    if (a2 == 256) {
      return result;
    }
  }

  else
  {
    if (a2 == 1) {
      return 8000LL;
    }
    if (a2 == 2) {
      return 16000LL;
    }
  }

  uint64_t result = os_log_type_enabled((os_log_t)qword_1008F7598, OS_LOG_TYPE_ERROR);
  if ((_DWORD)result)
  {
    sub_100682DE8();
    return 0LL;
  }

  return result;
}

void sub_100473940(uint64_t a1, uint64_t a2, int a3, int a4, int a5)
{
}

uint64_t sub_100473948(uint64_t a1, uint64_t a2, uint64_t a3, int a4, uint64_t a5)
{
  v19[0] = 0LL;
  v19[1] = 0LL;
  sub_100242F28((uint64_t)v19, a1 + 760);
  if ((sub_100270EE4(a2) & 1) != 0)
  {
    if (a2) {
      uint64_t v10 = sub_1002073AC(a2 + 400);
    }
    else {
      uint64_t v10 = 0LL;
    }
    char v18 = 0;
    sub_100242CA4(&v18);
    sub_100470890();
    sub_100242CD0(&v18);
    (*(void (**)(uint64_t, uint64_t, uint64_t, void, void))(*(void *)a1 + 264LL))(a1, a2, a5, 0LL, 0LL);
    (*(void (**)(uint64_t, uint64_t, uint64_t))(*(void *)a1 + 280LL))(a1, a2, a3);
    switch(a4)
    {
      case 1918989668:
        uint64_t v13 = (os_log_s *)qword_1008F7598;
        if (os_log_type_enabled((os_log_t)qword_1008F7598, OS_LOG_TYPE_DEFAULT))
        {
          *(_DWORD *)std::string buf = 67109120;
          int v21 = a5;
          _os_log_impl( (void *)&_mh_execute_header,  v13,  OS_LOG_TYPE_DEFAULT,  "Sco route reason is kBluetoothAudioDeviceSCOEnableReasonAudioIO:%d",  buf,  8u);
        }

        sub_1004709AC(a1, v14, a2);
        break;
      case 1919115628:
        uint64_t v15 = (os_log_s *)qword_1008F7598;
        BOOL v16 = os_log_type_enabled((os_log_t)qword_1008F7598, OS_LOG_TYPE_DEFAULT);
        if (v16)
        {
          *(_DWORD *)std::string buf = 67109120;
          int v21 = a5;
          _os_log_impl( (void *)&_mh_execute_header,  v15,  OS_LOG_TYPE_DEFAULT,  "Sco route reason is kBluetoothAudioDeviceSCOEnableReasonCall:%d",  buf,  8u);
        }

        sub_100470904(v16, v10, a2);
        break;
      case 1920364387:
        int v12 = (os_log_s *)qword_1008F7598;
        if (os_log_type_enabled((os_log_t)qword_1008F7598, OS_LOG_TYPE_DEFAULT))
        {
          *(_DWORD *)std::string buf = 67109120;
          int v21 = a5;
          _os_log_impl( (void *)&_mh_execute_header,  v12,  OS_LOG_TYPE_DEFAULT,  "Sco route reason is kBluetoothAudioDeviceSCOEnableReasonVoiceCommand:%d",  buf,  8u);
        }

        sub_100470AF4(a1, v10, a2);
        break;
    }

    sub_100242CD8(&v18);
  }

  else
  {
    int v11 = (os_log_s *)qword_1008F7598;
    if (os_log_type_enabled((os_log_t)qword_1008F7598, OS_LOG_TYPE_DEFAULT))
    {
      *(_WORD *)std::string buf = 0;
      _os_log_impl( (void *)&_mh_execute_header,  v11,  OS_LOG_TYPE_DEFAULT,  "Audio device is not valid, not setting sco data source",  buf,  2u);
    }
  }

  return sub_100242FAC((uint64_t)v19);
}

void sub_100473BE4(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, ...)
{
}

uint64_t sub_100473C18(uint64_t a1, uint64_t a2, uint64_t a3, int a4, uint64_t a5)
{
  return sub_100473948(a1 - 280, a2, a3, a4, a5);
}

uint64_t sub_100473C20(uint64_t a1, uint64_t a2)
{
  uint64_t v3 = sub_10045D7CC(a1, a2);
  if (!v3) {
    return 1LL;
  }
  uint64_t v4 = v3;
  uint64_t v9 = 0LL;
  if (qword_1008D60E0 != -1) {
    dispatch_once(&qword_1008D60E0, &stru_10089A010);
  }
  uint64_t v5 = sub_10021F164((uint64_t)off_1008D60D8, a2, (int *)&v9 + 1, (int *)&v9);
  sub_10027029C(v4, BYTE4(v9), v9);
  int v8 = 3;
  if (qword_1008D60E0 != -1) {
    dispatch_once(&qword_1008D60E0, &stru_10089A010);
  }
  sub_10021F3F4((uint64_t)off_1008D60D8, a2, &v8);
  sub_1002702AC(v4, v8);
  unsigned __int8 v6 = sub_1003DF900(a2);
  sub_1002702BC(v4, v6);
  return v5;
}

uint64_t sub_100473D20(uint64_t a1, uint64_t a2)
{
  uint64_t v3 = sub_10045D7CC(a1, a2);
  if (!v3) {
    return 1LL;
  }
  uint64_t v4 = v3;
  unsigned __int8 v5 = sub_1003DFA38(a2);
  sub_1002702EC(v4, v5);
  return 0LL;
}

uint64_t sub_100473D68(uint64_t a1, uint64_t a2)
{
  uint64_t v3 = sub_10045D7CC(a1, a2);
  if (!v3) {
    return 1LL;
  }
  uint64_t v4 = v3;
  if (qword_1008D60E0 != -1) {
    dispatch_once(&qword_1008D60E0, &stru_10089A010);
  }
  int v5 = sub_10021F03C((uint64_t)off_1008D60D8, a2);
  sub_100270274(v4, v5);
  return 0LL;
}

uint64_t sub_100473DE0(uint64_t a1, uint64_t a2, int a3)
{
  uint64_t v4 = sub_10045D7CC(a1, a2);
  if (!v4) {
    return 1LL;
  }
  sub_1002702CC(v4, a3);
  return 0LL;
}

uint64_t sub_100473E18(uint64_t a1, uint64_t a2)
{
  uint64_t v3 = sub_10045D7CC(a1, a2);
  if (!v3) {
    return 1LL;
  }
  uint64_t v4 = v3;
  int v5 = sub_1003E1830(a2);
  sub_100270898(v4, v5);
  return 0LL;
}

uint64_t sub_100473E60(uint64_t a1, uint64_t a2)
{
  uint64_t v3 = sub_10045D7CC(a1, a2);
  if (!v3) {
    return 1LL;
  }
  uint64_t v4 = v3;
  int v5 = sub_1003DFC9C(a2);
  sub_1002705FC(v4, v5);
  return 0LL;
}

uint64_t sub_100473EA8(uint64_t a1, uint64_t a2, _WORD *a3, _WORD *a4)
{
  uint64_t v4 = sub_1000F64B8(a2, 8, a3, a4, 0);
  if ((_DWORD)v4 && os_log_type_enabled((os_log_t)qword_1008F7598, OS_LOG_TYPE_ERROR)) {
    sub_100682E48();
  }
  return v4;
}

_BYTE *sub_100473F04(uint64_t a1, uint64_t a2, unsigned __int16 *a3, unsigned __int16 *a4)
{
  uint64_t v8 = sub_1004615C4(a1, *a4);
  if (v8) {
    sub_100460AB0(a1, v8, *a4);
  }
  char v10 = 0;
  sub_100242CA4(&v10);
  sub_1000F17B4(a2, *a3, *a4);
  return sub_100242CD8(&v10);
}

void sub_100473F7C( _Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, int a10, __int16 a11, char a12, char a13)
{
}

uint64_t sub_100473F90( uint64_t a1, uint64_t a2, unint64_t a3, __int16 *a4, unsigned __int16 *a5, int a6)
{
  __int16 v27 = 0;
  unsigned int v26 = 0;
  *(_DWORD *)&__src[3] = 33621253;
  *(_DWORD *)std::string __src = 84082945;
  *(_DWORD *)&v24[3] = 0;
  *(_DWORD *)__int16 v24 = 0;
  __int16 v11 = sub_1000F64A8();
  sub_1000F1E30(*a5, &v26);
  sub_1000F1EB8(*a5, (uint64_t)__src, 7u);
  sub_1000F1E48(*a5, (BOOL *)v24, 7u);
  sub_1000F1F08(*a5, &v27);
  if (qword_1008D9108 != -1) {
    dispatch_once(&qword_1008D9108, &stru_10089A0B0);
  }
  int v12 = sub_100266BFC(qword_1008D9100, a3);
  sub_10040F938(a2, 3);
  sub_10040F938(a2, 2);
  sub_10040F974(a2, 104);
  sub_10040F938(a2, 16);
  sub_10040F938(a2, 4);
  sub_10040F9C4(a2, v26);
  sub_10040F938(a2, 18);
  sub_10040F938(a2, 7);
  sub_10040F91C(a2, __src, 7LL);
  sub_10040F938(a2, 19);
  sub_10040F938(a2, 7);
  sub_10040F91C(a2, v24, 7LL);
  sub_10040F938(a2, 21);
  sub_10040F938(a2, 2);
  sub_10040F974(a2, v27);
  sub_10040F938(a2, 27);
  sub_10040F938(a2, 2);
  if (v12) {
    __int16 v13 = 15;
  }
  else {
    __int16 v13 = 7;
  }
  sub_10040F974(a2, v13);
  __int16 v23 = 0;
  char v22 = 0;
  __int16 v21 = 0;
  uint64_t v14 = sub_100173ADC((unsigned __int16)*a4, &v21, &v23, &v22);
  if ((_DWORD)v14)
  {
    if (os_log_type_enabled((os_log_t)qword_1008F7598, OS_LOG_TYPE_ERROR)) {
      sub_100682ED4();
    }
  }

  else
  {
    sub_10040F938(a2, 1);
    sub_10040F938(a2, 7);
    sub_10040F974(a2, *a4);
    sub_10040F974(a2, v21);
    sub_10040F974(a2, v23);
    sub_10040F938(a2, v22);
  }

  sub_10040F938(a2, 26);
  sub_10040F938(a2, 6);
  sub_10040F938(a2, 8);
  sub_10040F938(a2, 1);
  sub_10040F938(a2, 255);
  sub_10040F938(a2, 0);
  sub_10040F974(a2, v11);
  if (a6)
  {
    __int16 v20 = 0;
    char v19 = 0;
    __int16 v18 = 0;
    unsigned int v15 = sub_1001F7378(a3 + 128);
    __int16 v16 = v15;
    uint64_t v14 = sub_100173ADC(v15, &v18, &v20, &v19);
    if ((_DWORD)v14)
    {
      if (os_log_type_enabled((os_log_t)qword_1008F7598, OS_LOG_TYPE_ERROR)) {
        sub_100682E74();
      }
    }

    else
    {
      sub_10040F938(a2, 28);
      sub_10040F938(a2, 7);
      sub_10040F974(a2, v16);
      sub_10040F974(a2, v18);
      sub_10040F974(a2, v20);
      sub_10040F938(a2, v19);
    }
  }

  return v14;
}

uint64_t sub_100474304( uint64_t a1, uint64_t a2, uint64_t a3, unsigned int a4, unsigned __int16 *a5, _BYTE *a6, _BYTE *a7, _BYTE *a8)
{
  v48[0] = 0LL;
  v48[1] = 0LL;
  sub_100242F28((uint64_t)v48, a1 + 760);
  int v9 = sub_10056AAD8(a2 + 8) - *(_DWORD *)(a2 + 24);
  *(_DWORD *)((char *)v47 + 3) = 0;
  v47[0] = 0;
  uint64_t v46 = 0LL;
  *a8 = 0;
  unsigned int v10 = v9 << 16;
  if (v9 << 16 < 1)
  {
    uint64_t v11 = 0LL;
  }

  else
  {
    uint64_t v11 = 0LL;
    uint64_t v34 = a3 + 128;
    do
    {
      int v12 = (char)sub_10040F7B0(a2);
      if (v12 < 0)
      {
        unsigned int v13 = sub_10040F7FC(a2);
        int v9 = HIWORD(v10) - 3;
      }

      else
      {
        unsigned int v13 = sub_10040F7B0(a2);
        LOWORD(v9) = v9 - 2;
      }

      int v14 = v12 & 0x7F;
      switch(v12 & 0x7F)
      {
        case 1:
          unsigned __int16 v15 = v13 - 7;
          if (v13 < 7) {
            goto LABEL_39;
          }
          __int16 v16 = sub_10040F7FC(a2);
          sub_10040F7FC(a2);
          __int16 v17 = sub_10040F7FC(a2);
          sub_10040F7B0(a2);
          buf[0] = 0;
          sub_100242CA4(buf);
          if (sub_100171EC4(a4, (uint64_t *)&v46) || !sub_10017AB4C(v46))
          {
            __int16 v18 = (os_log_s *)qword_1008F7598;
            if (os_log_type_enabled((os_log_t)qword_1008F7598, OS_LOG_TYPE_ERROR)) {
              sub_100682F00(&v44, v45, v18);
            }
          }

          else
          {
            *(_WORD *)(sub_10017AB4C(v46) + _Block_object_dispose(va, 8) = v16;
            *(_WORD *)(sub_10017AB4C(v46) + sub_100242FAC(v11 - 32) = v17;
            sub_1001DA9EC(v34, a4);
          }

          sub_100242CD0(buf);
          goto LABEL_49;
        case 3:
          if (v13 != 2) {
            goto LABEL_39;
          }
          sub_10040F7FC(a2);
          goto LABEL_44;
        case 0x10:
          if (v13 != 4) {
            goto LABEL_39;
          }
          __int16 v20 = sub_10040F860(a2);
          buf[0] = 0;
          sub_100242CA4(buf);
          sub_1000F1DE8(*a5, v20);
          sub_100242CD0(buf);
          goto LABEL_21;
        case 0x11:
          __int16 v21 = sub_1000B17F4(v13);
          if (!v21) {
            goto LABEL_39;
          }
          sub_10040F778(a2, v21, v13);
          buf[0] = 0;
          sub_100242CA4(buf);
          sub_1000F1958(*a5, v21, v13);
          sub_100242CD0(buf);
          sub_1000B1838(v21);
          goto LABEL_21;
        case 0x14:
          if (v13 != 1) {
            goto LABEL_39;
          }
          int v22 = sub_10040F7B0(a2);
          buf[0] = 0;
          sub_100242CA4(buf);
          sub_1000F18EC(*a5, v22 == 1);
          sub_100242CD0(buf);
LABEL_21:
          sub_100242CD8(buf);
          goto LABEL_44;
        case 0x16:
          if (v13 != 1) {
            goto LABEL_39;
          }
          *a6 = sub_10040F7B0(a2) + 1;
          goto LABEL_44;
        case 0x17:
          if (v13 != 1) {
            goto LABEL_39;
          }
          *a7 = sub_10040F7B0(a2);
          goto LABEL_44;
        case 0x18:
          unsigned __int16 v15 = v13 - 7;
          if (v13 < 7) {
            goto LABEL_39;
          }
          sub_10040F778(a2, v47, 7uLL);
          buf[0] = 0;
          sub_100242CA4(buf);
          sub_1000F1C84(*a5, v47, 7u);
          sub_100242CD0(buf);
LABEL_49:
          char v32 = buf;
          goto LABEL_53;
        case 0x19:
          if (v13 != 1) {
            goto LABEL_39;
          }
          sub_10040F7B0(a2);
          *a8 = 1;
          goto LABEL_44;
        case 0x1A:
          unsigned __int16 v15 = v13;
          if (v13 >= 6)
          {
            char v23 = sub_10040F7B0(a2);
            int v24 = sub_10040F7B0(a2);
            __int16 v25 = sub_10040F7B0(a2);
            sub_10040F7B0(a2);
            unsigned int v26 = sub_10040F7FC(a2);
            buf[0] = 0;
            sub_100242CA4(buf);
            uint64_t v11 = sub_1001DF01C(a4, v23, v26, v25, v24);
            sub_100242CD0(buf);
            sub_100242CD8(buf);
            unsigned __int16 v15 = v13 - 6;
          }

          break;
        case 0x1B:
          unsigned __int16 v15 = v13 - 8;
          if (v13 < 8) {
            goto LABEL_39;
          }
          sub_10040F7FC(a2);
          sub_10040F7FC(a2);
          sub_10040F7FC(a2);
          sub_10040F7FC(a2);
          *(_WORD *)(a3 + 5sub_10023DF50(v3 + 76) = 257;
          break;
        case 0x1C:
          unsigned __int16 v15 = v13 - 7;
          if (v13 < 7) {
            goto LABEL_39;
          }
          __int16 v27 = sub_10040F7FC(a2);
          sub_10040F7FC(a2);
          __int16 v28 = sub_10040F7FC(a2);
          sub_10040F7B0(a2);
          *(void *)std::string buf = 0LL;
          char v43 = 0;
          sub_100242CA4(&v43);
          unsigned int v29 = sub_1001F7378(v34);
          if (sub_100171EC4(v29, (uint64_t *)buf) || !sub_10017AB4C(*(unsigned int **)buf))
          {
            uint64_t v30 = (os_log_s *)qword_1008F7598;
            if (os_log_type_enabled((os_log_t)qword_1008F7598, OS_LOG_TYPE_ERROR)) {
              sub_100682F34(&v41, v42, v30);
            }
            uint64_t v11 = 114LL;
          }

          else
          {
            *(_WORD *)(sub_10017AB4C(*(unsigned int **)buf) + _Block_object_dispose(va, 8) = v27;
            *(_WORD *)(sub_10017AB4C(*(unsigned int **)buf) + sub_100242FAC(v11 - 32) = v28;
          }

          char v32 = (uint8_t *)&v43;
LABEL_53:
          sub_100242CD8(v32);
          break;
        default:
          char v19 = (os_log_s *)qword_1008F7598;
          if (os_log_type_enabled((os_log_t)qword_1008F7598, OS_LOG_TYPE_ERROR))
          {
            *(_DWORD *)std::string buf = 67109120;
            *(_DWORD *)&uint8_t buf[4] = v12 & 0x7F;
            _os_log_error_impl( (void *)&_mh_execute_header,  v19,  OS_LOG_TYPE_ERROR,  "parseHFPDescriptor Key not recognized %d",  buf,  8u);
          }

void sub_100474914(_Unwind_Exception *a1)
{
}

uint64_t sub_100474990(uint64_t a1, uint64_t a2, char a3)
{
  unsigned __int8 v6 = (os_log_s *)qword_1008F7598;
  if (os_log_type_enabled((os_log_t)qword_1008F7598, OS_LOG_TYPE_DEFAULT))
  {
    sub_1003CF00C(a2, __p);
    if (v10 >= 0) {
      int v7 = __p;
    }
    else {
      int v7 = (void **)__p[0];
    }
    *(_DWORD *)std::string buf = 136446210;
    int v12 = v7;
    _os_log_impl( (void *)&_mh_execute_header,  v6,  OS_LOG_TYPE_DEFAULT,  "Fast Connect HFP Report Connection attempt for %{public}s",  buf,  0xCu);
    if (v10 < 0) {
      operator delete(__p[0]);
    }
  }

  return sub_100410910(a1, a2, a3);
}

void sub_100474A88( uint64_t a1, unsigned __int8 *a2, unsigned __int16 *a3, char *a4, char *a5, int a6, uint64_t a7)
{
  int v14 = (os_log_s *)qword_1008F7598;
  if (os_log_type_enabled((os_log_t)qword_1008F7598, OS_LOG_TYPE_DEFAULT))
  {
    v22[0] = 67109120;
    v22[1] = a7;
    _os_log_impl( (void *)&_mh_execute_header,  v14,  OS_LOG_TYPE_DEFAULT,  "Fast Connect HFP Setup Complete result %d",  (uint8_t *)v22,  8u);
  }

  if ((_DWORD)a7)
  {
    if (qword_1008D60B0 != -1) {
      dispatch_once(&qword_1008D60B0, &stru_100899F70);
    }
    int v15 = sub_1004317E0((uint64_t)off_1008D60A8, a7, 20000);
    sub_100410A5C(a1, (uint64_t)a2, v15);
  }

  else
  {
    if (qword_1008D60B0 != -1) {
      dispatch_once(&qword_1008D60B0, &stru_100899F70);
    }
    int v16 = sub_1004317E0((uint64_t)off_1008D60A8, 0LL, 20000);
    sub_100410A5C(a1, (uint64_t)a2, v16);
    sub_10045DAB4(a1, a2, *a3);
    __int16 v17 = sub_10045CF60(a1, *a3);
    if (v17)
    {
      uint64_t v18 = (uint64_t)v17;
      uint64_t v19 = (uint64_t)(v17 + 50);
      sub_1002073FC((uint64_t)(v17 + 50), *a4);
      LOBYTE(v2sub_100414D2C(qword_1008F72C0, 0) = *a4;
      sub_10026F638(v18, (float)v20 / 15.0);
      sub_1002073EC(v19, *a5);
      if (a6)
      {
        sub_10020740C(v19, 1);
        int v21 = sub_100207404(v19);
        sub_10027228C(v18, v21);
      }
    }
  }

void sub_100474C68(os_unfair_lock_s *a1, void *a2)
{
  uint64_t v3 = a2;
  os_unfair_lock_lock(a1);
  int v5 = 0LL;
  unsigned __int8 v6 = 0LL;
  uint64_t v7 = 0LL;
  sub_100240540(&v5, (uint64_t)&a1[2]);
  os_unfair_lock_unlock(a1);
  uint64_t v4 = v5;
  if (v5 != v6)
  {
    do
      v3[2](v3, *v4++);
    while (v4 != v6);
    uint64_t v4 = v5;
  }

  if (v4)
  {
    unsigned __int8 v6 = v4;
    operator delete(v4);
  }
}

void sub_100474CFC( _Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void *__p, uint64_t a11)
{
  _Unwind_Resume(a1);
}

uint64_t sub_100474D24(uint64_t a1, uint64_t a2)
{
  return (*(uint64_t (**)(uint64_t, void, void, void))(*(void *)a2 + 8LL))( a2,  *(void *)(a1 + 32),  *(unsigned __int16 *)(a1 + 40),  *(unsigned __int8 *)(a1 + 42));
}

uint64_t sub_100474D44(uint64_t a1, uint64_t a2)
{
  return (*(uint64_t (**)(uint64_t, void, void, void))(*(void *)a2 + 16LL))( a2,  *(void *)(a1 + 32),  *(void *)(a1 + 40),  *(unsigned __int16 *)(a1 + 48));
}

uint64_t sub_100474D60(uint64_t a1, uint64_t (***a2)(void, uint64_t, uint64_t, uint64_t, uint64_t))
{
  uint64_t v3 = *(unsigned __int16 *)(a1 + 48);
  uint64_t v4 = *(unsigned __int8 *)(a1 + 50);
  uint64_t v5 = *(void *)(a1 + 32);
  uint64_t v6 = sub_1002077B8(*(void *)(a1 + 40) + 400LL);
  return (**a2)(a2, v5, v3, v4, v6);
}

uint64_t sub_100474DB4(uint64_t a1, uint64_t a2, int a3)
{
  uint64_t v5 = sub_10045D7CC(a1, a2);
  uint64_t v6 = (os_log_s *)qword_1008F7598;
  if (v5)
  {
    uint64_t v7 = v5;
    if (os_log_type_enabled((os_log_t)qword_1008F7598, OS_LOG_TYPE_DEFAULT))
    {
      sub_1003CF00C(a2, __p);
      uint64_t v8 = (void **)__p[0];
      int v9 = "No";
      if (v12 >= 0) {
        uint64_t v8 = __p;
      }
      if (a3) {
        int v9 = "Yes";
      }
      *(_DWORD *)std::string buf = 136446466;
      int v14 = v8;
      __int16 v15 = 2082;
      int v16 = v9;
      _os_log_impl( (void *)&_mh_execute_header,  v6,  OS_LOG_TYPE_DEFAULT,  "setAllowsAutoRoute: %{public}s, allows %{public}s",  buf,  0x16u);
      if (v12 < 0) {
        operator delete(__p[0]);
      }
    }

    sub_100270C44(v7, a3);
    return 0LL;
  }

  else
  {
    if (os_log_type_enabled((os_log_t)qword_1008F7598, OS_LOG_TYPE_ERROR)) {
      sub_100682F68();
    }
    return 1LL;
  }

uint64_t sub_100474EFC(uint64_t a1, uint64_t a2, int a3)
{
  uint64_t v5 = sub_10045D7CC(a1, a2);
  uint64_t v6 = (os_log_s *)qword_1008F7598;
  if (v5)
  {
    uint64_t v7 = v5;
    if (os_log_type_enabled((os_log_t)qword_1008F7598, OS_LOG_TYPE_DEFAULT))
    {
      sub_1003CF00C(a2, __p);
      uint64_t v8 = (void **)__p[0];
      int v9 = "No";
      if (v12 >= 0) {
        uint64_t v8 = __p;
      }
      if (a3) {
        int v9 = "Yes";
      }
      *(_DWORD *)std::string buf = 136446466;
      int v14 = v8;
      __int16 v15 = 2082;
      int v16 = v9;
      _os_log_impl( (void *)&_mh_execute_header,  v6,  OS_LOG_TYPE_DEFAULT,  "setAudioRouteHidden: %{public}s, %{public}s",  buf,  0x16u);
      if (v12 < 0) {
        operator delete(__p[0]);
      }
    }

    sub_100270CA4(v7, a3);
    return 0LL;
  }

  else
  {
    if (os_log_type_enabled((os_log_t)qword_1008F7598, OS_LOG_TYPE_ERROR)) {
      sub_100682F94();
    }
    return 1LL;
  }

uint64_t sub_100475044(uint64_t a1, uint64_t a2, int a3)
{
  uint64_t v4 = sub_10045D7CC(a1, a2);
  if (v4)
  {
    sub_100270BE4(v4, a3);
    return 0LL;
  }

  else
  {
    if (os_log_type_enabled((os_log_t)qword_1008F7598, OS_LOG_TYPE_ERROR)) {
      sub_100682FC0();
    }
    return 1LL;
  }

uint64_t sub_1004750A4(uint64_t a1, uint64_t a2, int a3)
{
  uint64_t v4 = sub_10045D7CC(a1, a2);
  uint64_t v5 = (os_log_s *)qword_1008F7598;
  if (v4)
  {
    uint64_t v6 = v4;
    if (os_log_type_enabled((os_log_t)qword_1008F7598, OS_LOG_TYPE_DEFAULT))
    {
      uint64_t v7 = "No";
      if (a3) {
        uint64_t v7 = "Yes";
      }
      int v9 = 136315138;
      char v10 = v7;
      _os_log_impl( (void *)&_mh_execute_header,  v5,  OS_LOG_TYPE_DEFAULT,  "Smart Route: [HFP] Tipi Connection status : %s",  (uint8_t *)&v9,  0xCu);
    }

    sub_100270010(v6, a3);
    return 0LL;
  }

  else
  {
    if (os_log_type_enabled((os_log_t)qword_1008F7598, OS_LOG_TYPE_ERROR)) {
      sub_100682FEC();
    }
    return 1LL;
  }

void sub_1004751A4(uint64_t a1, uint64_t a2, int a3)
{
  uint64_t v5 = sub_10045D7CC(a1, a2);
  if (v5)
  {
    uint64_t v6 = v5;
    else {
      int v7 = dword_1006C3364[a3 - 1];
    }
    uint64_t v8 = (os_log_s *)qword_1008F7598;
    if (os_log_type_enabled((os_log_t)qword_1008F7598, OS_LOG_TYPE_DEFAULT))
    {
      sub_1003CF00C(a2, __p);
      if (v13 >= 0) {
        int v9 = __p;
      }
      else {
        int v9 = (void **)__p[0];
      }
      *(_DWORD *)std::string buf = 67109634;
      int v15 = a3;
      __int16 v16 = 1024;
      int v17 = v7;
      __int16 v18 = 2082;
      uint64_t v19 = v9;
      _os_log_impl( (void *)&_mh_execute_header,  v8,  OS_LOG_TYPE_DEFAULT,  "User selected device type is %d. Setting category as %d for device %{public}s.",  buf,  0x18u);
      if (v13 < 0) {
        operator delete(__p[0]);
      }
    }

    sub_1005022F4(v6, v7);
    int v11 = sub_10045F7E8(v10, a2);
    sub_1005020A4(v6, v11);
  }

  else if (os_log_type_enabled((os_log_t)qword_1008F7598, OS_LOG_TYPE_ERROR))
  {
    sub_100683018();
  }

void sub_100475314(uint64_t a1, char a2, uint64_t a3, char a4)
{
  uint64_t v8 = sub_100405058();
  v9[0] = _NSConcreteStackBlock;
  v9[1] = 3221225472LL;
  void v9[2] = sub_100475390;
  _OWORD v9[3] = &unk_10087FF20;
  void v9[4] = a1;
  void v9[5] = a3;
  char v10 = a4;
  char v11 = a2;
  sub_100405384(v8, v9);
}

void sub_100475390(uint64_t a1)
{
  uint64_t v2 = *(void *)(a1 + 32);
  unsigned int v3 = sub_10046169C(v2, *(void *)(a1 + 40));
  uint64_t v4 = sub_10045CF60(v2, v3);
  if (v4)
  {
    uint64_t v5 = (uint64_t)v4;
    uint64_t v6 = (uint64_t)(v4 + 50);
    int v23 = sub_1002073D4((uint64_t)(v4 + 50));
    uint64_t v7 = sub_1002073AC(v6);
    int v8 = sub_1002077B8(v6);
    int v9 = (os_log_s *)qword_1008F7598;
    if (os_log_type_enabled((os_log_t)qword_1008F7598, OS_LOG_TYPE_DEFAULT))
    {
      sub_1003CF00C(v7, __p);
      uint64_t v20 = v7;
      if (v22 >= 0) {
        char v10 = __p;
      }
      else {
        char v10 = (void **)__p[0];
      }
      char v11 = sub_1002CF1F4(*(unsigned __int8 *)(a1 + 48));
      int v12 = *(unsigned __int8 *)(a1 + 49);
      char v13 = sub_1002064F4(&v23);
      *(_DWORD *)std::string buf = 136447234;
      __int16 v25 = v10;
      __int16 v26 = 2080;
      __int16 v27 = v11;
      __int16 v28 = 1024;
      int v29 = v12;
      __int16 v30 = 2080;
      uint64_t v31 = v13;
      __int16 v32 = 1024;
      int v33 = v8;
      _os_log_impl( (void *)&_mh_execute_header,  v9,  OS_LOG_TYPE_DEFAULT,  "advancedSniffModeChanged - device:%{public}s mode:%s status:%d audioState:%s isInAdvancedSniff:%d",  buf,  0x2Cu);
      if (v22 < 0) {
        operator delete(__p[0]);
      }
      uint64_t v7 = v20;
    }

    int v14 = *(unsigned __int8 *)(a1 + 48);
    BOOL v15 = v14 == 240;
    if (v14 == 240) {
      char v16 = v8;
    }
    else {
      char v16 = 0;
    }
    if ((v16 & 1) == 0)
    {
      char v17 = v15;
      sub_1002077B0(v6, v17);
      if (v23 != 1) {
        goto LABEL_24;
      }
      if (*(_BYTE *)(a1 + 49))
      {
        sub_100475638(v2, v5);
        return;
      }

      if (*(unsigned __int8 *)(a1 + 48) != 240
        || (uint64_t v18 = sub_1002077D0(v6),
            sub_1004757D8(v18, *(void *)(a1 + 40)),
            buf[0] = 0,
            sub_100242CA4(buf),
            sub_1000F1044(v3),
            sub_100242CD8(buf),
            v23 == 1))
      {
        int v19 = 3;
      }

      else
      {
LABEL_24:
        int v19 = 1;
      }

      if (qword_1008D60F0 != -1) {
        dispatch_once(&qword_1008D60F0, &stru_10089A030);
      }
      sub_1004B4480((uint64_t)off_1008D60E8, v7, v19);
    }
  }

  else if (os_log_type_enabled((os_log_t)qword_1008F7598, OS_LOG_TYPE_ERROR))
  {
    sub_100683044();
  }

void sub_100475604( _Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, void *__p, uint64_t a12, int a13, __int16 a14, char a15, char a16, uint64_t a17, char a18)
{
}

void sub_100475638(uint64_t a1, uint64_t a2)
{
  uint64_t v4 = a2 + 400;
  sub_1002077C0(a2 + 400);
  int v5 = sub_1002077D8(v4);
  uint64_t v6 = sub_1002073AC(v4);
  uint64_t v7 = (os_log_s *)qword_1008F7598;
  if (os_log_type_enabled((os_log_t)qword_1008F7598, OS_LOG_TYPE_DEFAULT))
  {
    sub_1003CF00C(v6, __p);
    int v8 = v13 >= 0 ? __p : (void **)__p[0];
    *(_DWORD *)std::string buf = 136446466;
    BOOL v15 = v8;
    __int16 v16 = 1024;
    int v17 = v5;
    _os_log_impl( (void *)&_mh_execute_header,  v7,  OS_LOG_TYPE_DEFAULT,  "retryHandsfreeAoSCall - device:%{public}s handsfreeAoSRetryCount:%d",  buf,  0x12u);
    if (v13 < 0) {
      operator delete(__p[0]);
    }
  }

  if (v5 == 2)
  {
    sub_100501F98(a2, 0, 114);
    sub_1002073DC(v4, 0);
    int v9 = (os_log_s *)qword_1008F7598;
    if (os_log_type_enabled((os_log_t)qword_1008F7598, OS_LOG_TYPE_FAULT)) {
      sub_1006830A8(v9);
    }
  }

  else
  {
    uint64_t v10 = sub_100405058();
    v11[0] = _NSConcreteStackBlock;
    v11[1] = 3221225472LL;
    _DWORD v11[2] = sub_1004758D8;
    _OWORD v11[3] = &unk_10087F8E0;
    void v11[4] = a1;
    void v11[5] = v6;
    sub_100405460(v10, 250LL, v11);
  }

_BYTE *sub_1004757D8(uint64_t a1, uint64_t a2)
{
  char v7 = 0;
  sub_100242CA4(&v7);
  unsigned int v3 = (unsigned __int16 *)sub_10012D890(a2);
  sub_100242CD0(&v7);
  uint64_t v4 = *v3;
  uint64_t v5 = sub_1002E6E9C();
  (*(void (**)(uint64_t, uint64_t, uint64_t, uint64_t))(*(void *)v5 + 1560LL))(v5, v4, 1LL, 1LL);
  return sub_100242CD8(&v7);
}

void sub_100475844( _Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, int a10, __int16 a11, char a12, char a13)
{
}

void sub_10047585C(uint64_t a1, char a2, uint64_t a3, char a4)
{
  uint64_t v7 = a1 - 296;
  uint64_t v8 = sub_100405058();
  v9[0] = _NSConcreteStackBlock;
  v9[1] = 3221225472LL;
  void v9[2] = sub_100475390;
  _OWORD v9[3] = &unk_10087FF20;
  void v9[4] = v7;
  void v9[5] = a3;
  char v10 = a4;
  char v11 = a2;
  sub_100405384(v8, v9);
}

uint64_t sub_1004758D8(uint64_t a1)
{
  return sub_10046D7E4(*(void *)(a1 + 32), *(void *)(a1 + 40));
}

uint64_t sub_1004758E4(uint64_t a1)
{
  *(void *)a1 = off_1008998C8;
  *(void *)(a1 + 256) = off_100899A58;
  *(void *)(a1 + 2sub_100242FAC(v30 - 64) = off_100899A98;
  *(void *)(a1 + 272) = &off_100899AC8;
  *(void *)(a1 + 28sub_100414D2C(qword_1008F72C0, 0) = off_100899AE0;
  *(void *)(a1 + 28_Block_object_dispose(va, 8) = off_100899B78;
  *(void *)(a1 + 2sub_100242FAC(v5 - 96) = off_100899BA0;
  *(void *)(a1 + 304) = off_100899C08;
  *(void *)(a1 + 312) = off_100899C48;
  *(void *)(a1 + 32sub_100414D2C(qword_1008F72C0, 0) = &off_100899C78;
  sub_10023BF24(a1 + 824, *(void **)(a1 + 832));
  sub_100242E28(a1 + 760);
  sub_100206490(a1 + 360);
  uint64_t v2 = *(void **)(a1 + 336);
  if (v2)
  {
    *(void *)(a1 + 344) = v2;
    operator delete(v2);
  }

  return sub_100213D34(a1);
}

void sub_100475974(uint64_t a1)
{
  *(void *)a1 = off_1008998C8;
  *(void *)(a1 + 256) = off_100899A58;
  *(void *)(a1 + 2sub_100242FAC(v30 - 64) = off_100899A98;
  *(void *)(a1 + 272) = &off_100899AC8;
  *(void *)(a1 + 28sub_100414D2C(qword_1008F72C0, 0) = off_100899AE0;
  *(void *)(a1 + 28_Block_object_dispose(va, 8) = off_100899B78;
  *(void *)(a1 + 2sub_100242FAC(v5 - 96) = off_100899BA0;
  *(void *)(a1 + 304) = off_100899C08;
  *(void *)(a1 + 312) = off_100899C48;
  *(void *)(a1 + 32sub_100414D2C(qword_1008F72C0, 0) = &off_100899C78;
  sub_10023BF24(a1 + 824, *(void **)(a1 + 832));
  sub_100242E28(a1 + 760);
  sub_100206490(a1 + 360);
  uint64_t v2 = *(void **)(a1 + 336);
  if (v2)
  {
    *(void *)(a1 + 344) = v2;
    operator delete(v2);
  }

  unsigned int v3 = (void *)sub_100213D34(a1);
  operator delete(v3);
}

uint64_t sub_100475A5C(uint64_t a1)
{
  uint64_t v2 = a1 - 304;
  *(void *)(a1 - 304) = off_1008998C8;
  *(void *)(a1 - 4_Block_object_dispose(va, 8) = off_100899A58;
  *(void *)(a1 - 4sub_100414D2C(qword_1008F72C0, 0) = off_100899A98;
  *(void *)(a1 - sub_100242FAC(v11 - 32) = &off_100899AC8;
  *(void *)(a1 - 24) = off_100899AE0;
  *(void *)(a1 - 16) = off_100899B78;
  *(void *)(a1 - _Block_object_dispose(va, 8) = off_100899BA0;
  *(void *)a1 = off_100899C08;
  *(void *)(a1 + _Block_object_dispose(va, 8) = off_100899C48;
  *(void *)(a1 + 16) = &off_100899C78;
  sub_10023BF24(a1 + 520, *(void **)(a1 + 528));
  sub_100242E28(a1 + 456);
  sub_100206490(a1 + 56);
  unsigned int v3 = *(void **)(a1 + 32);
  if (v3)
  {
    *(void *)(a1 + 4sub_100414D2C(qword_1008F72C0, 0) = v3;
    operator delete(v3);
  }

  return sub_100213D34(v2);
}

void sub_100475AF0(uint64_t a1)
{
  uint64_t v2 = a1 - 304;
  *(void *)(a1 - 304) = off_1008998C8;
  *(void *)(a1 - 4_Block_object_dispose(va, 8) = off_100899A58;
  *(void *)(a1 - 4sub_100414D2C(qword_1008F72C0, 0) = off_100899A98;
  *(void *)(a1 - sub_100242FAC(v11 - 32) = &off_100899AC8;
  *(void *)(a1 - 24) = off_100899AE0;
  *(void *)(a1 - 16) = off_100899B78;
  *(void *)(a1 - _Block_object_dispose(va, 8) = off_100899BA0;
  *(void *)a1 = off_100899C08;
  *(void *)(a1 + _Block_object_dispose(va, 8) = off_100899C48;
  *(void *)(a1 + 16) = &off_100899C78;
  sub_10023BF24(a1 + 520, *(void **)(a1 + 528));
  sub_100242E28(a1 + 456);
  sub_100206490(a1 + 56);
  unsigned int v3 = *(void **)(a1 + 32);
  if (v3)
  {
    *(void *)(a1 + 4sub_100414D2C(qword_1008F72C0, 0) = v3;
    operator delete(v3);
  }

  uint64_t v4 = (void *)sub_100213D34(v2);
  operator delete(v4);
}

void sub_100475B94(uint64_t a1, uint64_t a2)
{
  uint64_t v4 = *(char **)(a1 + 8);
  uint64_t v5 = *(char **)(a1 + 16);
  if (v4 == v5)
  {
    uint64_t v6 = *(char **)(a1 + 8);
    goto LABEL_10;
  }

  uint64_t v6 = *(char **)(a1 + 8);
  while (*(void *)v6 != a2)
  {
    v6 += 8;
    if (v6 == v5)
    {
      uint64_t v6 = *(char **)(a1 + 16);
      break;
    }
  }

  if (v6 == v5)
  {
    if (v4 != v5)
    {
LABEL_11:
      uint64_t v7 = a2;
      sub_100475C48(a1 + 8, v6, (char *)&v7);
      sub_100008A30(a1 + 8);
      goto LABEL_12;
    }

char *sub_100475C48(uint64_t a1, char *__src, char *a3)
{
  unsigned int v3 = a3;
  uint64_t v4 = __src;
  uint64_t v6 = *(char **)(a1 + 8);
  uint64_t v8 = a1 + 16;
  unint64_t v7 = *(void *)(a1 + 16);
  if ((unint64_t)v6 >= v7)
  {
    char v13 = *(char **)a1;
    unint64_t v14 = ((uint64_t)&v6[-*(void *)a1] >> 3) + 1;
    if (v14 >> 61) {
      abort();
    }
    uint64_t v15 = __src - v13;
    uint64_t v16 = (__src - v13) >> 3;
    uint64_t v17 = v7 - (void)v13;
    if (v17 >> 2 > v14) {
      unint64_t v14 = v17 >> 2;
    }
    else {
      unint64_t v18 = v14;
    }
    uint64_t v30 = a1 + 16;
    if (v18) {
      int v19 = (char *)sub_100008BA0(a1 + 16, v18);
    }
    else {
      int v19 = 0LL;
    }
    uint64_t v20 = &v19[8 * v16];
    __int128 __p = v19;
    __int16 v27 = v20;
    __int16 v28 = v20;
    int v29 = &v19[8 * v18];
    if (v16 == v18)
    {
      if (v15 < 1)
      {
        if (v13 == v4) {
          unint64_t v22 = 1LL;
        }
        else {
          unint64_t v22 = v15 >> 2;
        }
        int v23 = (char *)sub_100008BA0(v8, v22);
        uint64_t v20 = &v23[8 * (v22 >> 2)];
        __int128 __p = v23;
        __int16 v27 = v20;
        int v29 = &v23[8 * v24];
        if (v19) {
          operator delete(v19);
        }
      }

      else
      {
        unint64_t v21 = v16 + 2;
        if (v16 >= -1) {
          unint64_t v21 = v16 + 1;
        }
        v20 -= 8 * (v21 >> 1);
        __int16 v27 = v20;
      }
    }

    *(void *)uint64_t v20 = *(void *)v3;
    __int16 v28 = v20 + 8;
    uint64_t v4 = sub_100008ADC((void **)a1, (uint64_t)&__p, v4);
    if (v28 != v27) {
      v28 += (v27 - v28 + 7) & 0xFFFFFFFFFFFFFFF8LL;
    }
    if (__p) {
      operator delete(__p);
    }
  }

  else if (__src == v6)
  {
    *(void *)std::string __src = *(void *)a3;
    *(void *)(a1 + _Block_object_dispose(va, 8) = __src + 8;
  }

  else
  {
    int v9 = __src + 8;
    char v10 = v6 - 8;
    char v11 = *(void **)(a1 + 8);
    while (v10 < v6)
    {
      uint64_t v12 = *(void *)v10;
      v10 += 8;
      *v11++ = v12;
    }

    *(void *)(a1 + _Block_object_dispose(va, 8) = v11;
    if (v6 != v9) {
      memmove(&v6[-8 * ((v6 - v9) >> 3)], __src, v6 - v9);
    }
    if (v4 <= v3) {
      v3 += 8 * (*(void *)(a1 + 8) > (unint64_t)v3);
    }
    *(void *)uint64_t v4 = *(void *)v3;
  }

  return v4;
}

void sub_100475E4C( _Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void *__p, uint64_t a11, uint64_t a12)
{
  if (__p) {
    operator delete(__p);
  }
  _Unwind_Resume(exception_object);
}

uint64_t sub_100475E84(uint64_t a1, uint64_t a2, void *a3)
{
  id v4 = a3;
  *(_WORD *)(a1 + _Block_object_dispose(va, 8) = 1;
  *(void *)a1 = off_100899D80;
  sub_10053C460(a1 + 16);
  *(void *)(a1 + 4sub_100414D2C(qword_1008F72C0, 0) = v4;
  return a1;
}

void sub_100475EDC(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

uint64_t sub_100475EEC(uint64_t a1)
{
  *(void *)a1 = off_100899D80;

  unsigned int v3 = (void **)(a1 + 16);
  sub_1002077E0(&v3);
  return a1;
}

void sub_100475F38(id *a1)
{
  *a1 = off_100899D80;

  uint64_t v2 = a1 + 2;
  sub_1002077E0(&v2);
  operator delete(a1);
}

void sub_100475F88(uint64_t a1)
{
  if (qword_1008D9030 != -1) {
    dispatch_once(&qword_1008D9030, &stru_100899F90);
  }
  sub_10046400C((uint64_t)off_1008D9028, (uint64_t *)(a1 + 16), *(void **)(a1 + 40));
}

void sub_100475FDC(uint64_t a1)
{
  uint64_t v2 = 0LL;
  uint64_t v3 = 0LL;
  LOBYTE(v3) = *(_BYTE *)(a1 + 50);
  if (qword_1008D9030 != -1) {
    dispatch_once(&qword_1008D9030, &stru_100899F90);
  }
  sub_10045C7F4( (os_unfair_lock_s *)off_1008D9028,  *(unsigned __int16 *)(a1 + 48),  *(unsigned __int8 *)(a1 + 51),  a1 + 32,  (uint64_t)&v2);
}

uint64_t sub_100476054(uint64_t a1, int *a2)
{
  *(_WORD *)(a1 + _Block_object_dispose(va, 8) = 1;
  *(void *)a1 = off_100899DE8;
  id v4 = malloc(0x18uLL);
  *(void *)(a1 + 16) = v4;
  if (v4)
  {
    uint64_t v5 = v4;
    *(_OWORD *)id v4 = *(_OWORD *)a2;
    void v4[2] = *((void *)a2 + 2);
    int v6 = *a2;
    if (*a2 < 2)
    {
      char v13 = malloc(6uLL);
      v5[1] = v13;
      uint64_t v14 = *((void *)a2 + 1);
      __int16 v15 = *(_WORD *)(v14 + 4);
      *(_DWORD *)char v13 = *(_DWORD *)v14;
      void v13[2] = v15;
    }

    else
    {
      if (v6 == 7)
      {
        size_t v16 = *((unsigned __int16 *)a2 + 8);
        char v11 = malloc(v16);
        v5[1] = v11;
        uint64_t v12 = (const char *)*((void *)a2 + 1);
        size_t v10 = v16;
        goto LABEL_9;
      }

      if (v6 == 10)
      {
        unint64_t v7 = (const char *)*((void *)a2 + 1);
        size_t v8 = strlen(v7);
        int v9 = malloc(v8 + 1);
        v5[1] = v9;
        size_t v10 = strlen(v7) + 1;
        char v11 = v9;
        uint64_t v12 = v7;
LABEL_9:
        memmove(v11, v12, v10);
      }
    }
  }

  else
  {
    char v18 = 0;
    sub_100242CA4(&v18);
    sub_1000EF578(*((unsigned __int16 *)a2 + 2), 2701LL);
    sub_100242CD8(&v18);
  }

  return a1;
}

void sub_100476174( _Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, int a10, __int16 a11, char a12, char a13)
{
}

void sub_10047618C(uint64_t a1)
{
  uint64_t v1 = (void *)sub_1004761F0(a1);
  operator delete(v1);
}

uint64_t sub_1004761A0(uint64_t a1)
{
  if (qword_1008D9030 != -1) {
    dispatch_once(&qword_1008D9030, &stru_100899F90);
  }
  return sub_100464E1C((uint64_t)off_1008D9028, *(void *)(a1 + 16));
}

uint64_t sub_1004761F0(uint64_t a1)
{
  *(void *)a1 = off_100899DE8;
  uint64_t v2 = *(void *)(a1 + 16);
  if (v2)
  {
    if (*(_DWORD *)v2 <= 0xAu && ((1 << *(_DWORD *)v2) & 0x483) != 0) {
      free(*(void **)(v2 + 8));
    }
    free(*(void **)(a1 + 16));
  }

  return a1;
}

uint64_t sub_100476254(uint64_t a1, __int16 a2, uint64_t a3)
{
  *(_WORD *)(a1 + _Block_object_dispose(va, 8) = 1;
  *(void *)a1 = off_100899E20;
  *(_WORD *)(a1 + 1sub_100414D2C(qword_1008F72C0, 0) = a2;
  uint64_t v5 = malloc(0x28uLL);
  *(void *)(a1 + 16) = v5;
  uint64_t v6 = a1 + 16;
  *(_DWORD *)uint64_t v5 = *(_DWORD *)a3;
  v5[8] = *(_WORD *)(a3 + 16);
  unint64_t v7 = *(const char **)(a3 + 8);
  size_t v8 = strlen(v7);
  int v9 = (char *)malloc(v8 + 1);
  *((void *)v5 + 1) = v9;
  if (v9)
  {
    size_t v10 = v9;
  }

  else
  {
    char v11 = (os_log_s *)qword_1008F7598;
    if (os_log_type_enabled((os_log_t)qword_1008F7598, OS_LOG_TYPE_FAULT))
    {
      *(_DWORD *)unint64_t v21 = 134217984;
      *(void *)&uint8_t v21[4] = strlen(v7) + 1;
      _os_log_fault_impl((void *)&_mh_execute_header, v11, OS_LOG_TYPE_FAULT, "Could not allocate %lu bytes", v21, 0xCu);
      size_t v10 = *(char **)(*(void *)v6 + 8LL);
      unint64_t v7 = *(const char **)(a3 + 8);
    }

    else
    {
      size_t v10 = 0LL;
    }
  }

  size_t v12 = strlen(v7);
  strlcpy(v10, v7, v12 + 1);
  char v13 = malloc(0x18uLL);
  *(void *)(*(void *)v6 + 32LL) = v13;
  if (!v13)
  {
    sub_100683120(a1 + 16, v21);
    char v13 = *(void **)v21;
  }

  uint64_t v14 = *(__int128 **)(a3 + 32);
  __int128 v15 = *v14;
  void v13[2] = *((void *)v14 + 2);
  *(_OWORD *)char v13 = v15;
  uint64_t v16 = *(void *)(a3 + 32);
  size_t v17 = *(unsigned __int16 *)(v16 + 18);
  char v18 = malloc(v17);
  *(void *)(*(void *)(*(void *)v6 + 32LL) + 8LL) = v18;
  if (!v18)
  {
    int v19 = (os_log_s *)qword_1008F7598;
    if (os_log_type_enabled((os_log_t)qword_1008F7598, OS_LOG_TYPE_FAULT))
    {
      *(_DWORD *)unint64_t v21 = 67109120;
      *(_DWORD *)&uint8_t v21[4] = v17;
      _os_log_fault_impl((void *)&_mh_execute_header, v19, OS_LOG_TYPE_FAULT, "Could not allocate %d bytes", v21, 8u);
      char v18 = *(void **)(*(void *)(*(void *)v6 + 32LL) + 8LL);
      uint64_t v16 = *(void *)(a3 + 32);
      size_t v17 = *(unsigned __int16 *)(v16 + 18);
    }

    else
    {
      char v18 = 0LL;
    }
  }

  memcpy(v18, *(const void **)(v16 + 8), v17);
  *(void *)(*(void *)(a1 + 16) + 24LL) = *(void *)(*(void *)(*(void *)(a1 + 16) + 32LL) + 8LL)
                                           + *(void *)(a3 + 24)
                                           - *(void *)(*(void *)(a3 + 32) + 8LL);
  return a1;
}

void sub_10047649C(uint64_t a1)
{
  uint64_t v1 = (void *)sub_100476504(a1);
  operator delete(v1);
}

_BYTE *sub_1004764B0(uint64_t a1)
{
  if (qword_1008D9030 != -1) {
    dispatch_once(&qword_1008D9030, &stru_100899F90);
  }
  return sub_10046A070((uint64_t)off_1008D9028, *(unsigned __int16 *)(a1 + 10), *(void *)(a1 + 16));
}

uint64_t sub_100476504(uint64_t a1)
{
  *(void *)a1 = off_100899E20;
  free(*(void **)(*(void *)(a1 + 16) + 8LL));
  free(*(void **)(*(void *)(*(void *)(a1 + 16) + 32LL) + 8LL));
  free(*(void **)(*(void *)(a1 + 16) + 32LL));
  free(*(void **)(a1 + 16));
  return a1;
}

uint64_t sub_100476560(uint64_t a1)
{
  if (qword_1008D9030 != -1) {
    dispatch_once(&qword_1008D9030, &stru_100899F90);
  }
  uint64_t v2 = off_1008D9028;
  *(_WORD *)(a1 + _Block_object_dispose(va, 8) = 1;
  *(void *)(a1 + 16) = 0LL;
  *(void *)(a1 + 24) = v2;
  *(void *)a1 = &off_100899E58;
  return a1;
}

void *sub_1004765D0(void *result)
{
  if (*(_DWORD *)(result[3] + 80LL) == 1) {
    return (void *)(*(uint64_t (**)(void *))(*result + 40LL))(result);
  }
  return result;
}

uint64_t sub_1004765F0(uint64_t a1, uint64_t a2)
{
  return sub_10046F9B0(a2);
}

uint64_t sub_1004765F8(uint64_t a1, __int16 a2, char a3)
{
  if (qword_1008D9030 != -1) {
    dispatch_once(&qword_1008D9030, &stru_100899F90);
  }
  uint64_t v6 = off_1008D9028;
  *(_WORD *)(a1 + _Block_object_dispose(va, 8) = 1;
  *(void *)(a1 + 16) = 0LL;
  *(void *)(a1 + 24) = v6;
  *(void *)a1 = &off_100899E98;
  *(_WORD *)(a1 + sub_100242FAC(v11 - 32) = a2;
  *(_BYTE *)(a1 + 34) = a3;
  return a1;
}

uint64_t sub_100476680(uint64_t a1, uint64_t a2)
{
  return sub_100460E80(a2, *(unsigned __int16 *)(a1 + 32), *(unsigned __int8 *)(a1 + 34));
}

void sub_100476694(uint64_t a1)
{
  if (qword_1008D9030 != -1) {
    dispatch_once(&qword_1008D9030, &stru_100899F90);
  }
  sub_10046D3D8((uint64_t)off_1008D9028, *(_DWORD *)(a1 + 32), *(unsigned __int16 *)(a1 + 40), *(_DWORD *)(a1 + 36));
}

uint64_t sub_1004766F4()
{
  if (qword_1008D9030 != -1) {
    dispatch_once(&qword_1008D9030, &stru_100899F90);
  }
  return sub_1004710D8((uint64_t)off_1008D9028, 0);
}

void sub_100476738()
{
  uint64_t v0 = sub_100405058();
  sub_100405384(v0, &stru_100899F00);
}

void sub_100476754(uint64_t a1, char a2, const void *a3, unsigned int a4, uint64_t a5, uint64_t *a6)
{
  char v18 = 0LL;
  int v19 = 0LL;
  sub_10056AB04(&v18, a3, a4);
  LOWORD(a1) = sub_1000F633C(a1);
  char v9 = *((_BYTE *)a6 + 8);
  uint64_t v10 = *a6;
  uint64_t v11 = sub_100405058();
  v12[0] = _NSConcreteStackBlock;
  v12[1] = 3321888768LL;
  void v12[2] = sub_1004769FC;
  v12[3] = &unk_100899F20;
  char v16 = v9;
  __int16 v15 = a1;
  char v17 = a2;
  uint8_t v12[4] = v10;
  char v13 = &off_10087FAA8;
  uint64_t v14 = v19;
  if (v19) {
    sub_1002CD1E0((uint64_t)v19);
  }
  sub_100405384(v11, v12);
  char v13 = &off_10087FAA8;
  if (v14) {
    sub_1002CD254(v14);
  }
  char v18 = &off_10087FAA8;
  if (v19) {
    sub_1002CD254(v19);
  }
}

void sub_100476844( _Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, unsigned int *a15, uint64_t a16, uint64_t a17, unsigned int *a18)
{
  if (a15) {
    sub_1002CD254(a15);
  }
  if (a18) {
    sub_1002CD254(a18);
  }
  _Unwind_Resume(exception_object);
}

void sub_100476884()
{
  uint64_t v0 = sub_100405058();
  sub_100405384(v0, &stru_100899F50);
}

void sub_1004768A0(uint64_t a1, __int16 a2)
{
  __int16 v3 = sub_1000F633C(a1);
  uint64_t v4 = sub_100405058();
  v5[0] = _NSConcreteStackBlock;
  v5[1] = 3221225472LL;
  _DWORD v5[2] = sub_100476AEC;
  uint64_t v5[3] = &unk_10087F980;
  __int16 v6 = v3;
  __int16 v7 = a2;
  sub_100405384(v4, v5);
}

void sub_10047690C(int a1, uint64_t a2, char a3, char a4, __int16 a5, __int16 a6, char a7)
{
  __int16 v14 = sub_1000F633C(a2);
  uint64_t v15 = sub_100405058();
  v16[0] = _NSConcreteStackBlock;
  v16[1] = 3221225472LL;
  void v16[2] = sub_100476B38;
  void v16[3] = &unk_100889658;
  int v17 = a1;
  __int16 v18 = v14;
  v16[4] = a2;
  char v21 = a3;
  char v22 = a4;
  __int16 v19 = a5;
  __int16 v20 = a6;
  char v23 = a7;
  sub_100405384(v15, v16);
}

void sub_1004769C4(id a1)
{
  if (qword_1008D9030 != -1) {
    dispatch_once(&qword_1008D9030, &stru_100899F90);
  }
  sub_10045C790();
}

void sub_1004769FC(uint64_t a1)
{
  uint64_t v2 = *(void *)(a1 + 32);
  uint64_t v3 = 0LL;
  LOBYTE(v3) = *(_BYTE *)(a1 + 58);
  if (qword_1008D9030 != -1) {
    dispatch_once(&qword_1008D9030, &stru_100899F90);
  }
  sub_10045C7F4( (os_unfair_lock_s *)off_1008D9028,  *(unsigned __int16 *)(a1 + 56),  *(unsigned __int8 *)(a1 + 59),  a1 + 40,  (uint64_t)&v2);
}

void sub_100476A78(uint64_t a1, uint64_t a2)
{
  uint64_t v3 = *(void *)(a2 + 48);
  *(void *)(a1 + 4sub_100414D2C(qword_1008F72C0, 0) = &off_10087FAA8;
  *(void *)(a1 + 4_Block_object_dispose(va, 8) = v3;
  if (v3) {
    sub_1002CD1E0(v3);
  }
}

void sub_100476A98(uint64_t a1)
{
  *(void *)(a1 + 4sub_100414D2C(qword_1008F72C0, 0) = &off_10087FAA8;
  uint64_t v1 = *(unsigned int **)(a1 + 48);
  if (v1) {
    sub_1002CD254(v1);
  }
}

void sub_100476AB4(id a1)
{
  if (qword_1008D9030 != -1) {
    dispatch_once(&qword_1008D9030, &stru_100899F90);
  }
  sub_10045D308();
}

void sub_100476AEC(uint64_t a1)
{
  if (qword_1008D9030 != -1) {
    dispatch_once(&qword_1008D9030, &stru_100899F90);
  }
  sub_10045D36C(a1, 0LL, *(unsigned __int16 *)(a1 + 34));
}

uint64_t sub_100476B38(uint64_t a1)
{
  if (qword_1008D9030 != -1) {
    dispatch_once(&qword_1008D9030, &stru_100899F90);
  }
  return sub_10045D40C( (uint64_t)off_1008D9028,  *(_DWORD *)(a1 + 40),  *(unsigned __int16 *)(a1 + 44),  *(void *)(a1 + 32),  *(unsigned __int8 *)(a1 + 50),  *(unsigned __int8 *)(a1 + 51),  *(unsigned __int16 *)(a1 + 46),  *(unsigned __int16 *)(a1 + 48),  *(_BYTE *)(a1 + 52));
}

void sub_100476BB4(id a1)
{
  uint64_t v1 = operator new(0x230uLL);
  sub_10042BC28();
  off_1008D60A8 = v1;
}

void sub_100476BE4(_Unwind_Exception *a1)
{
}

void sub_100476BF8(id a1)
{
  uint64_t v1 = operator new(0x350uLL);
  sub_100461A78((uint64_t)v1);
  off_1008D9028 = v1;
}

void sub_100476C28(_Unwind_Exception *a1)
{
}

void sub_100476C3C(id a1)
{
  uint64_t v1 = operator new(0x618uLL);
  sub_10058B0A4();
  off_1008D5F08 = v1;
}

void sub_100476C6C(_Unwind_Exception *a1)
{
}

void sub_100476C80(id a1)
{
  uint64_t v1 = operator new(0x138uLL);
  sub_1003FE3E0((uint64_t)v1);
  off_1008D5F48 = v1;
}

void sub_100476CB0(_Unwind_Exception *a1)
{
}

void sub_100476CC4(id a1)
{
  uint64_t v1 = operator new(0x128uLL);
  sub_1005C69F8();
  off_1008D5F28 = v1;
}

void sub_100476CF4(_Unwind_Exception *a1)
{
}

void sub_100476D08(id a1)
{
  uint64_t v1 = operator new(0x2C8uLL);
  sub_100213DA8();
  off_1008D60D8 = v1;
}

void sub_100476D38(_Unwind_Exception *a1)
{
}

void sub_100476D4C(id a1)
{
  uint64_t v1 = operator new(0x4A8uLL);
  sub_100499870();
  off_1008D60E8 = v1;
}

void sub_100476D7C(_Unwind_Exception *a1)
{
}

void sub_100476D90(id a1)
{
  uint64_t v1 = operator new(0x48uLL);
  sub_10054A778((uint64_t)v1);
  off_1008D90F0 = v1;
}

void sub_100476DC0(_Unwind_Exception *a1)
{
}

void sub_100476DD4(id a1)
{
  uint64_t v1 = operator new(0x98uLL);
  sub_1003C97E4((uint64_t)v1);
  off_1008D67E0 = v1;
}

void sub_100476E04(_Unwind_Exception *a1)
{
}

void sub_100476E18(id a1)
{
  uint64_t v1 = operator new(0x260uLL);
  sub_1005285C8((uint64_t)v1);
  off_1008D67A0 = v1;
}

void sub_100476E48(_Unwind_Exception *a1)
{
}

void sub_100476E5C(id a1)
{
  uint64_t v1 = operator new(0x98uLL);
  sub_100266BF8();
  qword_1008D9100 = (uint64_t)v1;
}

void sub_100476E8C(_Unwind_Exception *a1)
{
}

void sub_100476EA0(id a1)
{
  uint64_t v1 = operator new(0x230uLL);
  sub_100271B18((uint64_t)v1);
  off_1008D9248 = v1;
}

void sub_100476ED0(_Unwind_Exception *a1)
{
}

void sub_100476EE4(id a1)
{
  uint64_t v1 = (char *)operator new(0x200uLL);
  *(void *)uint64_t v1 = off_100898F60;
  *((void *)v1 + 1) = &off_100898FF0;
  *((void *)v1 + 2) = off_100899008;
  *((void *)v1 + 3) = &off_100899060;
  *((void *)v1 + 4) = &off_100899078;
  sub_100242DC4(v1 + 40);
  *((void *)v1 + 14) = 0LL;
  *((_DWORD *)v1 + 3sub_100414D2C(qword_1008F72C0, 0) = 0;
  *((void *)v1 + 17) = 0LL;
  *((void *)v1 + 1_Block_object_dispose(va, 8) = 0LL;
  *((void *)v1 + 16) = 0LL;
  *(_OWORD *)(v1 + 155) = 0u;
  *(_OWORD *)(v1 + 171) = 0u;
  *(_OWORD *)(v1 + 187) = 0u;
  *(_WORD *)(v1 + 203) = 1;
  *((void *)v1 + 26) = 0LL;
  *((_WORD *)v1 + 10_Block_object_dispose(va, 8) = 256;
  *((void *)v1 + 29) = 0LL;
  *((void *)v1 + 2_Block_object_dispose(va, 8) = v1 + 232;
  *((void *)v1 + sub_100242FAC(v11 - 32) = 0LL;
  *((void *)v1 + 33) = 0LL;
  *((void *)v1 + 3sub_100414D2C(qword_1008F72C0, 0) = 0LL;
  *((void *)v1 + 31) = v1 + 256;
  v1[272] = 0;
  *((_DWORD *)v1 + 69) = 0;
  v1[280] = 0;
  *((_WORD *)v1 + 189) = 0;
  *(void *)(v1 + 313) = 0LL;
  *(_OWORD *)(v1 + 30sub_100414D2C(qword_1008F72C0, 0) = 0u;
  *(_OWORD *)(v1 + 284) = 0u;
  *(_OWORD *)(v1 + 32_Block_object_dispose(va, 8) = 0u;
  *(_OWORD *)(v1 + 344) = 0u;
  *(_OWORD *)(v1 + 36sub_100414D2C(qword_1008F72C0, 0) = 0u;
  v1[376] = 0;
  *((void *)v1 + 51) = v1 + 416;
  *((void *)v1 + 52) = 0LL;
  *((void *)v1 + 55) = 0LL;
  *((void *)v1 + 56) = 0LL;
  *((void *)v1 + 53) = 0LL;
  *((void *)v1 + 54) = v1 + 440;
  *((void *)v1 + 57) = v1 + 464;
  *((void *)v1 + 5_Block_object_dispose(va, 8) = 0LL;
  *((void *)v1 + 59) = 0LL;
  *((void *)v1 + 6sub_100414D2C(qword_1008F72C0, 0) = @"XZ";
  *((void *)v1 + sub_100242E28(v3 + 62) = 0LL;
  *((_DWORD *)v1 + 126) = 0;
  off_1008D6190 = v1;
}

void sub_100476FEC(_Unwind_Exception *a1)
{
}

void sub_100477000(id a1)
{
  uint64_t v1 = operator new(0x118uLL);
  sub_1003ADFF0((uint64_t)v1);
  off_1008D5F38 = v1;
}

void sub_100477030(_Unwind_Exception *a1)
{
}

_BYTE *sub_100477044(_BYTE *a1, unsigned __int16 a2, uint64_t a3)
{
  uint64_t result = (_BYTE *)sub_100207474(a3 + 400);
  if ((_DWORD)result)
  {
    if (qword_1008D9030 != -1) {
      dispatch_once(&qword_1008D9030, &stru_100899F90);
    }
    uint64_t v6 = sub_1004615C4((uint64_t)off_1008D9028, a2);
    __int16 v7 = (os_log_s *)qword_1008F7598;
    if (os_log_type_enabled((os_log_t)qword_1008F7598, OS_LOG_TYPE_DEFAULT))
    {
      if (*a1) {
        size_t v8 = "call active";
      }
      else {
        size_t v8 = "no call active";
      }
      if (v6)
      {
        sub_1003CF00C(v6, __p);
        if (v12 >= 0) {
          char v9 = __p;
        }
        else {
          char v9 = (void **)__p[0];
        }
        *(_DWORD *)std::string buf = 136446466;
        __int16 v14 = v8;
        __int16 v15 = 2082;
        char v16 = (const char *)v9;
        _os_log_impl( (void *)&_mh_execute_header,  v7,  OS_LOG_TYPE_DEFAULT,  "Sending call status %{public}s to device %{public}s",  buf,  0x16u);
        if (v12 < 0) {
          operator delete(__p[0]);
        }
      }

      else
      {
        *(_DWORD *)std::string buf = 136446466;
        __int16 v14 = v8;
        __int16 v15 = 2082;
        char v16 = "NULL";
        _os_log_impl( (void *)&_mh_execute_header,  v7,  OS_LOG_TYPE_DEFAULT,  "Sending call status %{public}s to device %{public}s",  buf,  0x16u);
      }
    }

    LOBYTE(__p[0]) = 0;
    sub_100242CA4(__p);
    int v10 = sub_1000EFA28(a2, *a1);
    sub_100242CD0(__p);
    if (v10)
    {
      if (os_log_type_enabled((os_log_t)qword_1008F7598, OS_LOG_TYPE_ERROR)) {
        sub_1006831D0();
      }
    }

    return sub_100242CD8(__p);
  }

  return result;
}

void sub_100477240( _Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, char a10)
{
}

uint64_t *sub_10047725C(uint64_t *a1, uint64_t a2)
{
  a1[2] = 0LL;
  a1[1] = 0LL;
  *a1 = (uint64_t)(a1 + 1);
  sub_1004772B0(a1, *(unsigned __int16 **)a2, (unsigned __int16 *)(a2 + 8));
  return a1;
}

void sub_100477298(_Unwind_Exception *a1)
{
}

uint64_t *sub_1004772B0(uint64_t *result, unsigned __int16 *a2, unsigned __int16 *a3)
{
  if (a2 != a3)
  {
    uint64_t v4 = a2;
    uint64_t v5 = (uint64_t **)result;
    uint64_t v6 = result + 1;
    do
    {
      uint64_t result = sub_100477334(v5, v6, v4 + 16, (_OWORD *)v4 + 2);
      __int16 v7 = (unsigned __int16 *)*((void *)v4 + 1);
      if (v7)
      {
        do
        {
          size_t v8 = v7;
          __int16 v7 = *(unsigned __int16 **)v7;
        }

        while (v7);
      }

      else
      {
        do
        {
          size_t v8 = (unsigned __int16 *)*((void *)v4 + 2);
          BOOL v9 = *(void *)v8 == (void)v4;
          uint64_t v4 = v8;
        }

        while (!v9);
      }

      uint64_t v4 = v8;
    }

    while (v8 != a3);
  }

  return result;
}

uint64_t *sub_100477334(uint64_t **a1, uint64_t *a2, unsigned __int16 *a3, _OWORD *a4)
{
  uint64_t v10 = 0LL;
  uint64_t v11 = 0LL;
  uint64_t v6 = sub_1004773BC(a1, a2, &v11, &v10, a3);
  __int16 v7 = (uint64_t *)*v6;
  if (!*v6)
  {
    size_t v8 = (uint64_t **)v6;
    __int16 v7 = (uint64_t *)operator new(0x30uLL);
    *((_OWORD *)v7 + 2) = *a4;
    sub_100029630(a1, (uint64_t)v11, v8, v7);
  }

  return v7;
}

uint64_t *sub_1004773BC(void *a1, uint64_t *a2, uint64_t **a3, uint64_t *a4, unsigned __int16 *a5)
{
  uint64_t v5 = a1 + 1;
  if (a1 + 1 == a2 || (v6 = *a5, unsigned int v7 = *((unsigned __int16 *)a2 + 16), v6 < v7))
  {
    size_t v8 = (uint64_t *)*a2;
    if ((uint64_t *)*a1 == a2)
    {
      uint64_t v10 = a2;
LABEL_17:
      if (v8)
      {
        *a3 = v10;
        return v10 + 1;
      }

      else
      {
        *a3 = a2;
        return a2;
      }
    }

    if (v8)
    {
      BOOL v9 = (uint64_t *)*a2;
      do
      {
        uint64_t v10 = v9;
        BOOL v9 = (uint64_t *)v9[1];
      }

      while (v9);
    }

    else
    {
      char v13 = a2;
      do
      {
        uint64_t v10 = (uint64_t *)v13[2];
        BOOL v14 = *v10 == (void)v13;
        char v13 = v10;
      }

      while (v14);
    }

    unsigned int v15 = *a5;
    uint64_t v16 = *v5;
    if (*v5)
    {
      do
      {
        while (1)
        {
          int v17 = (uint64_t *)v16;
          unsigned int v18 = *(unsigned __int16 *)(v16 + 32);
          if (v15 >= v18) {
            break;
          }
          uint64_t v16 = *v17;
          uint64_t v5 = v17;
          if (!*v17) {
            goto LABEL_29;
          }
        }

        if (v18 >= v15) {
          break;
        }
        uint64_t v5 = v17 + 1;
        uint64_t v16 = v17[1];
      }

      while (v16);
    }

    else
    {
      int v17 = a1 + 1;
    }

void sub_100477564(unsigned __int8 *a1, unsigned __int16 a2, uint64_t a3)
{
  uint64_t v5 = a3 + 400;
  int v6 = sub_100207434(a3 + 400);
  if (sub_100207474(v5))
  {
    if (qword_1008D9030 != -1) {
      dispatch_once(&qword_1008D9030, &stru_100899F90);
    }
    uint64_t v7 = sub_1004615C4((uint64_t)off_1008D9028, a2);
    if (v6)
    {
      size_t v8 = (os_log_s *)qword_1008F7598;
      if (os_log_type_enabled((os_log_t)qword_1008F7598, OS_LOG_TYPE_DEFAULT))
      {
        int v22 = a1[1];
        BOOL v9 = v23;
        sub_100206494(&v22, v23);
        if (v24 < 0) {
          BOOL v9 = (void **)v23[0];
        }
        if (v7)
        {
          sub_1003CF00C(v7, __p);
          if (v21 >= 0) {
            uint64_t v10 = __p;
          }
          else {
            uint64_t v10 = (void **)__p[0];
          }
          *(_DWORD *)std::string buf = 136446466;
          __int16 v26 = v9;
          __int16 v27 = 2082;
          __int16 v28 = (const char *)v10;
          _os_log_impl( (void *)&_mh_execute_header,  v8,  OS_LOG_TYPE_DEFAULT,  "Sending call held status %{public}s to device %{public}s",  buf,  0x16u);
          if (v21 < 0) {
            operator delete(__p[0]);
          }
        }

        else
        {
          *(_DWORD *)std::string buf = 136446466;
          __int16 v26 = v9;
          __int16 v27 = 2082;
          __int16 v28 = "NULL";
          _os_log_impl( (void *)&_mh_execute_header,  v8,  OS_LOG_TYPE_DEFAULT,  "Sending call held status %{public}s to device %{public}s",  buf,  0x16u);
        }

        if (v24 < 0) {
          operator delete(v23[0]);
        }
      }

      char v19 = 0;
      sub_100242CA4(&v19);
      int v14 = sub_1000EFCD8(a2, a1[1]);
      if (!v14)
      {
        unsigned int v15 = (os_log_s *)qword_1008F7598;
        if (os_log_type_enabled((os_log_t)qword_1008F7598, OS_LOG_TYPE_DEFAULT))
        {
          int v22 = *a1;
          uint64_t v16 = v23;
          sub_1002064C4(&v22, v23);
          if (v24 < 0) {
            uint64_t v16 = (void **)v23[0];
          }
          if (v7)
          {
            sub_1003CF00C(v7, __p);
            if (v21 >= 0) {
              int v17 = __p;
            }
            else {
              int v17 = (void **)__p[0];
            }
            *(_DWORD *)std::string buf = 136446466;
            __int16 v26 = v16;
            __int16 v27 = 2082;
            __int16 v28 = (const char *)v17;
            _os_log_impl( (void *)&_mh_execute_header,  v15,  OS_LOG_TYPE_DEFAULT,  "Sending call setup %{public}s to device %{public}s",  buf,  0x16u);
            if (v21 < 0) {
              operator delete(__p[0]);
            }
          }

          else
          {
            *(_DWORD *)std::string buf = 136446466;
            __int16 v26 = v16;
            __int16 v27 = 2082;
            __int16 v28 = "NULL";
            _os_log_impl( (void *)&_mh_execute_header,  v15,  OS_LOG_TYPE_DEFAULT,  "Sending call setup %{public}s to device %{public}s",  buf,  0x16u);
          }

          if (v24 < 0) {
            operator delete(v23[0]);
          }
        }

        int v14 = sub_1000EFB4C(a2, *a1);
      }

      unsigned int v18 = (void **)&v19;
    }

    else
    {
      if (!a1[2]) {
        return;
      }
      uint64_t v11 = (os_log_s *)qword_1008F7598;
      if (os_log_type_enabled((os_log_t)qword_1008F7598, OS_LOG_TYPE_DEFAULT))
      {
        int v22 = *a1;
        char v12 = v23;
        sub_1002064C4(&v22, v23);
        if (v24 < 0) {
          char v12 = (void **)v23[0];
        }
        if (v7)
        {
          sub_1003CF00C(v7, __p);
          if (v21 >= 0) {
            char v13 = __p;
          }
          else {
            char v13 = (void **)__p[0];
          }
          *(_DWORD *)std::string buf = 136446466;
          __int16 v26 = v12;
          __int16 v27 = 2082;
          __int16 v28 = (const char *)v13;
          _os_log_impl( (void *)&_mh_execute_header,  v11,  OS_LOG_TYPE_DEFAULT,  "Sending call setup %{public}s to device %{public}s",  buf,  0x16u);
          if (v21 < 0) {
            operator delete(__p[0]);
          }
        }

        else
        {
          *(_DWORD *)std::string buf = 136446466;
          __int16 v26 = v12;
          __int16 v27 = 2082;
          __int16 v28 = "NULL";
          _os_log_impl( (void *)&_mh_execute_header,  v11,  OS_LOG_TYPE_DEFAULT,  "Sending call setup %{public}s to device %{public}s",  buf,  0x16u);
        }

        if (v24 < 0) {
          operator delete(v23[0]);
        }
      }

      LOBYTE(v23[0]) = 0;
      sub_100242CA4(v23);
      int v14 = sub_1000EFB4C(a2, *a1);
      unsigned int v18 = v23;
    }

    sub_100242CD8(v18);
    if (v14)
    {
      if (os_log_type_enabled((os_log_t)qword_1008F7598, OS_LOG_TYPE_ERROR)) {
        sub_100682910();
      }
    }
  }

void sub_1004779F0( _Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, int a9, __int16 a10, char a11, char a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, void *__p, uint64_t a18, int a19, __int16 a20, char a21, char a22)
{
  if (a22 < 0) {
    operator delete(__p);
  }
  sub_100242CD8(&a12);
  _Unwind_Resume(a1);
}

void sub_100477A50(unsigned __int8 *a1, unsigned __int16 a2, uint64_t a3)
{
  uint64_t v5 = a3 + 400;
  int v6 = sub_100207434(a3 + 400);
  if (sub_100207474(v5))
  {
    if (qword_1008D9030 != -1) {
      dispatch_once(&qword_1008D9030, &stru_100899F90);
    }
    uint64_t v7 = sub_1004615C4((uint64_t)off_1008D9028, a2);
    if (v6)
    {
      size_t v8 = (os_log_s *)qword_1008F7598;
      if (os_log_type_enabled((os_log_t)qword_1008F7598, OS_LOG_TYPE_DEFAULT))
      {
        int v22 = *a1;
        BOOL v9 = v23;
        sub_1002064C4(&v22, v23);
        if (v24 < 0) {
          BOOL v9 = (void **)v23[0];
        }
        if (v7)
        {
          sub_1003CF00C(v7, __p);
          if (v21 >= 0) {
            uint64_t v10 = __p;
          }
          else {
            uint64_t v10 = (void **)__p[0];
          }
          *(_DWORD *)std::string buf = 136446466;
          __int16 v26 = v9;
          __int16 v27 = 2082;
          __int16 v28 = (const char *)v10;
          _os_log_impl( (void *)&_mh_execute_header,  v8,  OS_LOG_TYPE_DEFAULT,  "Sending call setup %{public}s to device %{public}s",  buf,  0x16u);
          if (v21 < 0) {
            operator delete(__p[0]);
          }
        }

        else
        {
          *(_DWORD *)std::string buf = 136446466;
          __int16 v26 = v9;
          __int16 v27 = 2082;
          __int16 v28 = "NULL";
          _os_log_impl( (void *)&_mh_execute_header,  v8,  OS_LOG_TYPE_DEFAULT,  "Sending call setup %{public}s to device %{public}s",  buf,  0x16u);
        }

        if (v24 < 0) {
          operator delete(v23[0]);
        }
      }

      if (a1[2] && a1[1] != 1)
      {
        LOBYTE(v23[0]) = 0;
        sub_100242CA4(v23);
        sub_100242CD8(v23);
      }

      char v19 = 0;
      sub_100242CA4(&v19);
      int v14 = sub_1000EFB4C(a2, *a1);
      if (!v14)
      {
        unsigned int v15 = (os_log_s *)qword_1008F7598;
        if (os_log_type_enabled((os_log_t)qword_1008F7598, OS_LOG_TYPE_DEFAULT))
        {
          int v22 = a1[1];
          uint64_t v16 = v23;
          sub_100206494(&v22, v23);
          if (v24 < 0) {
            uint64_t v16 = (void **)v23[0];
          }
          if (v7)
          {
            sub_1003CF00C(v7, __p);
            if (v21 >= 0) {
              int v17 = __p;
            }
            else {
              int v17 = (void **)__p[0];
            }
            *(_DWORD *)std::string buf = 136446466;
            __int16 v26 = v16;
            __int16 v27 = 2082;
            __int16 v28 = (const char *)v17;
            _os_log_impl( (void *)&_mh_execute_header,  v15,  OS_LOG_TYPE_DEFAULT,  "Sending call held status %{public}s to device %{public}s",  buf,  0x16u);
            if (v21 < 0) {
              operator delete(__p[0]);
            }
          }

          else
          {
            *(_DWORD *)std::string buf = 136446466;
            __int16 v26 = v16;
            __int16 v27 = 2082;
            __int16 v28 = "NULL";
            _os_log_impl( (void *)&_mh_execute_header,  v15,  OS_LOG_TYPE_DEFAULT,  "Sending call held status %{public}s to device %{public}s",  buf,  0x16u);
          }

          if (v24 < 0) {
            operator delete(v23[0]);
          }
        }

        int v14 = sub_1000EFCD8(a2, a1[1]);
      }

      unsigned int v18 = (void **)&v19;
    }

    else
    {
      if (!a1[3]) {
        return;
      }
      uint64_t v11 = (os_log_s *)qword_1008F7598;
      if (os_log_type_enabled((os_log_t)qword_1008F7598, OS_LOG_TYPE_DEFAULT))
      {
        int v22 = *a1;
        char v12 = v23;
        sub_1002064C4(&v22, v23);
        if (v24 < 0) {
          char v12 = (void **)v23[0];
        }
        if (v7)
        {
          sub_1003CF00C(v7, __p);
          if (v21 >= 0) {
            char v13 = __p;
          }
          else {
            char v13 = (void **)__p[0];
          }
          *(_DWORD *)std::string buf = 136446466;
          __int16 v26 = v12;
          __int16 v27 = 2082;
          __int16 v28 = (const char *)v13;
          _os_log_impl( (void *)&_mh_execute_header,  v11,  OS_LOG_TYPE_DEFAULT,  "Sending call setup %{public}s to device %{public}s",  buf,  0x16u);
          if (v21 < 0) {
            operator delete(__p[0]);
          }
        }

        else
        {
          *(_DWORD *)std::string buf = 136446466;
          __int16 v26 = v12;
          __int16 v27 = 2082;
          __int16 v28 = "NULL";
          _os_log_impl( (void *)&_mh_execute_header,  v11,  OS_LOG_TYPE_DEFAULT,  "Sending call setup %{public}s to device %{public}s",  buf,  0x16u);
        }

        if (v24 < 0) {
          operator delete(v23[0]);
        }
      }

      LOBYTE(v23[0]) = 0;
      sub_100242CA4(v23);
      int v14 = sub_1000EFB4C(a2, *a1);
      unsigned int v18 = v23;
    }

    sub_100242CD8(v18);
    if (v14)
    {
      if (os_log_type_enabled((os_log_t)qword_1008F7598, OS_LOG_TYPE_ERROR)) {
        sub_100682910();
      }
    }
  }

void sub_100477F38( _Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, int a9, __int16 a10, char a11, char a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, void *__p, uint64_t a18, int a19, __int16 a20, char a21, char a22)
{
  if (a22 < 0) {
    operator delete(__p);
  }
  sub_100242CD8(&a12);
  _Unwind_Resume(a1);
}

_BYTE *sub_100477F9C(unsigned __int8 *a1, unsigned __int16 a2, uint64_t a3)
{
  uint64_t result = (_BYTE *)sub_100207474(a3 + 400);
  if ((_DWORD)result)
  {
    if (qword_1008D9030 != -1) {
      dispatch_once(&qword_1008D9030, &stru_100899F90);
    }
    uint64_t v6 = sub_1004615C4((uint64_t)off_1008D9028, a2);
    uint64_t v7 = (os_log_s *)qword_1008F7598;
    if (os_log_type_enabled((os_log_t)qword_1008F7598, OS_LOG_TYPE_DEFAULT))
    {
      int v13 = *a1;
      size_t v8 = v14;
      sub_1002064C4(&v13, v14);
      if (v15 < 0) {
        size_t v8 = (void **)v14[0];
      }
      if (v6)
      {
        sub_1003CF00C(v6, __p);
        if (v12 >= 0) {
          BOOL v9 = __p;
        }
        else {
          BOOL v9 = (void **)__p[0];
        }
        *(_DWORD *)std::string buf = 136446466;
        int v17 = v8;
        __int16 v18 = 2082;
        char v19 = (const char *)v9;
        _os_log_impl( (void *)&_mh_execute_header,  v7,  OS_LOG_TYPE_DEFAULT,  "Sending call setup %{public}s to device %{public}s",  buf,  0x16u);
        if (v12 < 0) {
          operator delete(__p[0]);
        }
      }

      else
      {
        *(_DWORD *)std::string buf = 136446466;
        int v17 = v8;
        __int16 v18 = 2082;
        char v19 = "NULL";
        _os_log_impl( (void *)&_mh_execute_header,  v7,  OS_LOG_TYPE_DEFAULT,  "Sending call setup %{public}s to device %{public}s",  buf,  0x16u);
      }

      if (v15 < 0) {
        operator delete(v14[0]);
      }
    }

    LOBYTE(v14[0]) = 0;
    sub_100242CA4(v14);
    int v10 = sub_1000EFB4C(a2, *a1);
    sub_100242CD0(v14);
    if (v10)
    {
      if (os_log_type_enabled((os_log_t)qword_1008F7598, OS_LOG_TYPE_ERROR)) {
        sub_100683230();
      }
    }

    return sub_100242CD8(v14);
  }

  return result;
}

void sub_1004781B4( _Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, void *__p, uint64_t a15, int a16, __int16 a17, char a18, char a19)
{
  if (a19 < 0) {
    operator delete(__p);
  }
  _Unwind_Resume(exception_object);
}

uint64_t *sub_1004781E8(void *a1, unsigned int *a2)
{
  int8x8_t v2 = (int8x8_t)a1[1];
  if (!*(void *)&v2) {
    return 0LL;
  }
  unint64_t v3 = *a2;
  uint8x8_t v4 = (uint8x8_t)vcnt_s8(v2);
  v4.i16[0] = vaddlv_u8(v4);
  if (v4.u32[0] > 1uLL)
  {
    unint64_t v5 = *a2;
    if (*(void *)&v2 <= v3) {
      unint64_t v5 = v3 % *(void *)&v2;
    }
  }

  else
  {
    unint64_t v5 = (v2.i32[0] - 1) & v3;
  }

  uint64_t v6 = *(uint64_t ***)(*a1 + 8 * v5);
  if (!v6) {
    return 0LL;
  }
  for (uint64_t result = *v6; result; uint64_t result = (uint64_t *)*result)
  {
    unint64_t v8 = result[1];
    if (v8 == v3)
    {
      if (*((_DWORD *)result + 4) == (_DWORD)v3) {
        return result;
      }
    }

    else
    {
      if (v4.u32[0] > 1uLL)
      {
        if (v8 >= *(void *)&v2) {
          v8 %= *(void *)&v2;
        }
      }

      else
      {
        v8 &= *(void *)&v2 - 1LL;
      }

      if (v8 != v5) {
        return 0LL;
      }
    }
  }

  return result;
}

uint64_t sub_10047829C(uint64_t a1, unsigned int *a2, uint64_t a3)
{
  *(_OWORD *)a1 = 0u;
  *(_OWORD *)(a1 + 16) = 0u;
  *(_DWORD *)(a1 + sub_100242FAC(v11 - 32) = 1065353216;
  if (a3)
  {
    uint64_t v5 = 4 * a3;
    do
    {
      sub_100478310(a1, a2, a2);
      ++a2;
      v5 -= 4LL;
    }

    while (v5);
  }

  return a1;
}

void sub_1004782FC(_Unwind_Exception *a1)
{
}

void *sub_100478310(uint64_t a1, unsigned int *a2, _DWORD *a3)
{
  unint64_t v5 = *a2;
  unint64_t v6 = *(void *)(a1 + 8);
  if (v6)
  {
    uint8x8_t v7 = (uint8x8_t)vcnt_s8((int8x8_t)v6);
    v7.i16[0] = vaddlv_u8(v7);
    if (v7.u32[0] > 1uLL)
    {
      unint64_t v8 = *a2;
      if (v6 <= v5) {
        unint64_t v8 = v5 % v6;
      }
    }

    else
    {
      unint64_t v8 = ((_DWORD)v6 - 1) & v5;
    }

    BOOL v9 = *(void ***)(*(void *)a1 + 8 * v8);
    if (v9)
    {
      int v10 = *v9;
      if (*v9)
      {
        do
        {
          unint64_t v11 = v10[1];
          if (v11 == v5)
          {
            if (*((_DWORD *)v10 + 4) == (_DWORD)v5) {
              return v10;
            }
          }

          else
          {
            if (v7.u32[0] > 1uLL)
            {
              if (v11 >= v6) {
                v11 %= v6;
              }
            }

            else
            {
              v11 &= v6 - 1;
            }

            if (v11 != v8) {
              break;
            }
          }

          int v10 = (void *)*v10;
        }

        while (v10);
      }
    }
  }

  else
  {
    unint64_t v8 = 0LL;
  }

  int v10 = operator new(0x18uLL);
  void *v10 = 0LL;
  v10[1] = v5;
  *((_DWORD *)v10 + 4) = *a3;
  float v12 = (float)(unint64_t)(*(void *)(a1 + 24) + 1LL);
  float v13 = *(float *)(a1 + 32);
  if (!v6 || (float)(v13 * (float)v6) < v12)
  {
    BOOL v14 = 1LL;
    if (v6 >= 3) {
      BOOL v14 = (v6 & (v6 - 1)) != 0;
    }
    unint64_t v15 = v14 | (2 * v6);
    unint64_t v16 = vcvtps_u32_f32(v12 / v13);
    if (v15 <= v16) {
      size_t v17 = v16;
    }
    else {
      size_t v17 = v15;
    }
    sub_10005141C(a1, v17);
    unint64_t v6 = *(void *)(a1 + 8);
    if ((v6 & (v6 - 1)) != 0)
    {
      if (v6 <= v5) {
        unint64_t v8 = v5 % v6;
      }
      else {
        unint64_t v8 = v5;
      }
    }

    else
    {
      unint64_t v8 = ((_DWORD)v6 - 1) & v5;
    }
  }

  uint64_t v18 = *(void *)a1;
  char v19 = *(void **)(*(void *)a1 + 8 * v8);
  if (v19)
  {
    void *v10 = *v19;
LABEL_38:
    void *v19 = v10;
    goto LABEL_39;
  }

  void *v10 = *(void *)(a1 + 16);
  *(void *)(a1 + 16) = v10;
  *(void *)(v18 + 8 * v_Block_object_dispose(va, 8) = a1 + 16;
  if (*v10)
  {
    unint64_t v20 = *(void *)(*v10 + 8LL);
    if ((v6 & (v6 - 1)) != 0)
    {
      if (v20 >= v6) {
        v20 %= v6;
      }
    }

    else
    {
      v20 &= v6 - 1;
    }

    char v19 = (void *)(*(void *)a1 + 8 * v20);
    goto LABEL_38;
  }

void sub_10047851C(_Unwind_Exception *a1)
{
}

void *sub_100478530(void *result, uint64_t a2, int a3, float a4)
{
  if (v4 >= 0) {
    unint64_t v5 = result;
  }
  else {
    unint64_t v5 = (void *)*result;
  }
  *(float *)a2 = a4;
  *(_DWORD *)(a2 + 4) = a3;
  *(_WORD *)(a2 + _Block_object_dispose(va, 8) = 2080;
  *(void *)(a2 + 1sub_100414D2C(qword_1008F72C0, 0) = v5;
  return result;
}

  ;
}

uint64_t sub_100478564(uint64_t result, uint64_t a2, float a3)
{
  *(float *)uint64_t result = a3;
  *(void *)(result + 4) = a2;
  *(_WORD *)(result + 12) = 1024;
  *(_DWORD *)(result + 14) = 2;
  return result;
}

  ;
}

uint64_t sub_100478590@<X0>(uint64_t result@<X0>, int a2@<W1>, uint64_t a3@<X8>)
{
  *(void *)(result + 4) = a3;
  *(_WORD *)(result + 12) = 1024;
  *(_DWORD *)(result + 14) = a2;
  return result;
}

void *sub_1004785A4(void *a1)
{
  *a1 = off_10089A1A0;
  id v2 = +[CloudPairing sharedInstance](&OBJC_CLASS___CloudPairing, "sharedInstance");
  return a1;
}

void sub_1004785E4(uint64_t a1, void *a2)
{
  id v2 = a2;
  unint64_t v3 = (os_log_s *)qword_1008F7588;
  if (os_log_type_enabled((os_log_t)qword_1008F7588, OS_LOG_TYPE_DEFAULT))
  {
    *(_WORD *)std::string buf = 0;
    _os_log_impl((void *)&_mh_execute_header, v3, OS_LOG_TYPE_DEFAULT, "CloudPairing start", buf, 2u);
  }

  int v4 = objc_autoreleasePoolPush();
  unint64_t v5 = (void *)objc_claimAutoreleasedReturnValue(+[NSMutableArray array](&OBJC_CLASS___NSMutableArray, "array"));
  unint64_t v6 = (void *)objc_claimAutoreleasedReturnValue(+[NSMutableArray array](&OBJC_CLASS___NSMutableArray, "array"));
  __int128 v17 = 0u;
  __int128 v18 = 0u;
  __int128 v15 = 0u;
  __int128 v16 = 0u;
  id v7 = v2;
  id v8 = [v7 countByEnumeratingWithState:&v15 objects:v20 count:16];
  if (v8)
  {
    uint64_t v9 = *(void *)v16;
    do
    {
      for (uint64_t i = 0LL; i != v8; uint64_t i = (char *)i + 1)
      {
        if (*(void *)v16 != v9) {
          objc_enumerationMutation(v7);
        }
        unint64_t v11 = *(void **)(*((void *)&v15 + 1) + 8LL * (void)i);
        float v12 = [v11 UUIDString];
        [v5 addObject:v12];

        float v13 = (void *)objc_claimAutoreleasedReturnValue([v7 objectForKeyedSubscript:v11]);
        [v6 addObject:v13];
      }

      id v8 = [v7 countByEnumeratingWithState:&v15 objects:v20 count:16];
    }

    while (v8);
  }

  BOOL v14 = (void *)objc_claimAutoreleasedReturnValue(+[CloudPairing sharedInstance](&OBJC_CLASS___CloudPairing, "sharedInstance"));
  [v14 registerWithCloudPairedDevices:v5 identifiers:v6];

  objc_autoreleasePoolPop(v4);
}

void sub_1004787C8(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_100478834()
{
  id v0 = (id)objc_claimAutoreleasedReturnValue(+[CloudPairing sharedInstance](&OBJC_CLASS___CloudPairing, "sharedInstance"));
  [v0 printDebug];
}

void sub_100478870( _Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, id a10)
{
}

void sub_100478884()
{
  id v0 = (id)objc_claimAutoreleasedReturnValue(+[CloudPairing sharedInstance](&OBJC_CLASS___CloudPairing, "sharedInstance"));
  [v0 sendCloudKitPush];
}

void sub_1004788C0( _Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, id a10)
{
}

void sub_1004788D4()
{
  id v0 = (id)objc_claimAutoreleasedReturnValue(+[CloudPairing sharedInstance](&OBJC_CLASS___CloudPairing, "sharedInstance"));
  [v0 fetchManateeStatus];
}

void sub_100478910( _Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, id a10)
{
}

id sub_100478924()
{
  id v0 = (void *)objc_claimAutoreleasedReturnValue(+[CloudPairing sharedInstance](&OBJC_CLASS___CloudPairing, "sharedInstance"));
  id v1 = [v0 getAccountStatus];

  return v1;
}

void sub_100478960(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_100478970(uint64_t a1, uint64_t *a2)
{
  id v5 = (id)objc_claimAutoreleasedReturnValue(+[CloudPairing sharedInstance](&OBJC_CLASS___CloudPairing, "sharedInstance"));
  unint64_t v3 = (void *)objc_claimAutoreleasedReturnValue([v5 cloudClient]);
  int v4 = (void *)objc_claimAutoreleasedReturnValue(+[NSString stringWithUTF8String:](&OBJC_CLASS___NSString, "stringWithUTF8String:", a2));
  [v3 deviceRecord:v4 completion:&stru_10089A210];
}

void sub_1004789F8( _Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, id a10)
{
  float v12 = v11;

  _Unwind_Resume(a1);
}

void sub_100478A28(id a1, BTCloudDevice *a2, NSError *a3)
{
  int v4 = a2;
  id v5 = a3;
  unint64_t v6 = v5;
  id v7 = (os_log_s *)qword_1008F7588;
  if (!v4 || v5)
  {
    if (os_log_type_enabled((os_log_t)qword_1008F7588, OS_LOG_TYPE_ERROR)) {
      sub_100683290();
    }
  }

  else
  {
    if (os_log_type_enabled((os_log_t)qword_1008F7588, OS_LOG_TYPE_DEFAULT))
    {
      *(_DWORD *)std::string buf = 138412290;
      __int128 v16 = v4;
      _os_log_impl( (void *)&_mh_execute_header,  v7,  OS_LOG_TYPE_DEFAULT,  "[Inquiry] fetched cloud device: %@",  buf,  0xCu);
    }

    uint64_t v8 = sub_1002E9258();
    id v9 = objc_claimAutoreleasedReturnValue(-[BTCloudDevice bluetoothAddress](v4, "bluetoothAddress"));
    sub_10002418C(v13, (char *)[v9 UTF8String]);
    id v10 = objc_claimAutoreleasedReturnValue(-[BTCloudDevice nickname](v4, "nickname"));
    sub_10002418C(__p, (char *)[v10 UTF8String]);
    (*(void (**)(uint64_t, void **, void **))(*(void *)v8 + 176LL))(v8, v13, __p);
    if (v12 < 0) {
      operator delete(__p[0]);
    }

    if (v14 < 0) {
      operator delete(v13[0]);
    }
  }
}

void sub_100478BAC( _Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, void *__p, uint64_t a10, int a11, __int16 a12, char a13, char a14, void *a15, uint64_t a16, int a17, __int16 a18, char a19, char a20)
{
  if (a14 < 0) {
    operator delete(__p);
  }

  if (a20 < 0) {
    operator delete(a15);
  }

  _Unwind_Resume(a1);
}

void sub_100478C0C(uint64_t a1, uint64_t a2)
{
  id v3 = (id)objc_claimAutoreleasedReturnValue(+[CloudPairing sharedInstance](&OBJC_CLASS___CloudPairing, "sharedInstance"));
  [v3 multipleAdvInstancesInitialized:a2];
}

void sub_100478C50( _Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, id a10)
{
}

void sub_100478C64(uint64_t a1, uint64_t *a2)
{
  id v2 = a2;
  if (*((char *)a2 + 23) < 0)
  {
    if (!a2[1]) {
      return;
    }
  }

  else if (!*((_BYTE *)a2 + 23))
  {
    return;
  }

  id v3 = (void *)objc_claimAutoreleasedReturnValue(+[CloudPairing sharedInstance](&OBJC_CLASS___CloudPairing, "sharedInstance"));
  int v4 = (void *)objc_claimAutoreleasedReturnValue(+[NSString stringWithUTF8String:](&OBJC_CLASS___NSString, "stringWithUTF8String:", v2));
  unint64_t v6 = v4;
  id v5 = (void *)objc_claimAutoreleasedReturnValue(+[NSArray arrayWithObjects:count:](&OBJC_CLASS___NSArray, "arrayWithObjects:count:", &v6, 1LL));
  [v3 sendCloudpairingRetry:v5];
}

void sub_100478D48(_Unwind_Exception *a1)
{
  int v4 = v3;

  _Unwind_Resume(a1);
}

void sub_100478DBC(id a1)
{
  id v1 = objc_alloc_init(&OBJC_CLASS___CloudPairing);
  id v2 = (void *)qword_1008F1058;
  qword_1008F1058 = (uint64_t)v1;
}

void sub_100478E24(id a1)
{
  id v1 = objc_alloc_init(&OBJC_CLASS___BTCloudServicesClient);
  id v2 = (void *)qword_1008F1068;
  qword_1008F1068 = (uint64_t)v1;

  [(id)qword_1008F1068 setInterruptionHandler:&stru_10089A270];
  [(id)qword_1008F1068 setInvalidationHandler:&stru_10089A290];
}

void sub_100478E74(id a1)
{
  id v1 = (os_log_s *)qword_1008F7588;
  if (os_log_type_enabled((os_log_t)qword_1008F7588, OS_LOG_TYPE_DEFAULT))
  {
    *(_WORD *)id v2 = 0;
    _os_log_impl((void *)&_mh_execute_header, v1, OS_LOG_TYPE_DEFAULT, "Cloud InterruptionHandler", v2, 2u);
  }

void sub_100478ED8(id a1)
{
  id v1 = (os_log_s *)qword_1008F7588;
  if (os_log_type_enabled((os_log_t)qword_1008F7588, OS_LOG_TYPE_DEFAULT))
  {
    *(_WORD *)id v2 = 0;
    _os_log_impl((void *)&_mh_execute_header, v1, OS_LOG_TYPE_DEFAULT, "Cloud InvalidationHandler", v2, 2u);
  }

void sub_100479424( _Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20, id location, uint64_t a22, int a23, __int16 a24, char a25, char a26)
{
  _Unwind_Resume(a1);
}

uint64_t sub_1004794A0(uint64_t a1, int a2)
{
  int v4 = (os_log_s *)(id)qword_1008F7588;
  if (os_log_type_enabled(v4, OS_LOG_TYPE_DEFAULT))
  {
    v7[0] = 67109120;
    v7[1] = MKBDeviceUnlockedSinceBoot();
    _os_log_impl( (void *)&_mh_execute_header,  v4,  OS_LOG_TYPE_DEFAULT,  "Received first unlock notification. returns : %d",  (uint8_t *)v7,  8u);
  }

  id WeakRetained = objc_loadWeakRetained((id *)(a1 + 32));
  [WeakRetained startUpServices];

  return notify_cancel(a2);
}

void sub_100479574(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

id sub_100479714(uint64_t a1)
{
  id v2 = (os_log_s *)qword_1008F7588;
  if (os_log_type_enabled((os_log_t)qword_1008F7588, OS_LOG_TYPE_DEFAULT))
  {
    *(_WORD *)int v4 = 0;
    _os_log_impl( (void *)&_mh_execute_header,  v2,  OS_LOG_TYPE_DEFAULT,  "BTAudioCloudSyncMonitor: BTCloudSoundProfileChangedNotification Received",  v4,  2u);
  }

  return [*(id *)(a1 + 32) soundProfileChanged];
}

void sub_1004798DC(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_1004799B8( _Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, ...)
{
}

id sub_1004799D4(uint64_t a1)
{
  id result = [*(id *)(a1 + 32) _generateKeys];
  *(_BYTE *)(*(void *)(*(void *)(a1 + 40) + 8LL) + 24LL) = (_BYTE)result;
  return result;
}

void sub_100479D40(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_100479FB0( _Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, id location)
{
  __int128 v18 = v16;

  objc_destroyWeak(v17);
  objc_destroyWeak(&location);

  _Unwind_Resume(a1);
}

void sub_100479FF4(uint64_t a1, void *a2)
{
  id v2 = (id *)(a1 + 32);
  id v3 = a2;
  id WeakRetained = objc_loadWeakRetained(v2);
  [WeakRetained _handleMsg:v3];
}

void sub_10047A03C( _Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, id a10)
{
  _Unwind_Resume(a1);
}

LABEL_659:
                                                      }

                                                      else if (!((unsigned __int16)v466 >> 13) || !v399)
                                                      {
                                                        v406 = (os_log_s *)&_os_log_default;
                                                        v407 = &_os_log_default;
                                                        if (os_log_type_enabled( (os_log_t)&_os_log_default,  OS_LOG_TYPE_FAULT))
                                                        {
                                                          LODWORD(v544[0].__r_.__value_.__l.__data_) = v452;
                                                          HIDWORD(v544[0].__r_.__value_.__r.__words[0]) = (unsigned __int16)v466 >> 13;
                                                          LOWORD(v544[0].__r_.__value_.__r.__words[1]) = 1024;
                                                          *(_DWORD *)((char *)&v544[0].__r_.__value_.__r.__words[1] + 2) = (v466 >> 10) & 7;
                                                          _os_log_fault_impl( (void *)&_mh_execute_header,  (os_log_t)&_os_log_default,  OS_LOG_TYPE_FAULT,  "CloudPairing: Unknown value caught for Press and Hold config s. Left: %d, Right %d",  (uint8_t *)v544,  0xEu);
                                                        }

                                                        goto LABEL_659;
                                                      }

                                                      v408 = (os_log_s *)(id)qword_1008F7600;
                                                      v409 = os_log_type_enabled(v408, OS_LOG_TYPE_DEFAULT);
                                                      if ((_DWORD)v464 && (v464 & 7) == (_DWORD)v462)
                                                      {
                                                        if (v409)
                                                        {
                                                          sub_1003CF00C(v478, &v550);
                                                          v410 = (char)v550.__r_.__value_.__s.__size_;
                                                          v411 = v550.__r_.__value_.__r.__words[0];
                                                          v412 = sub_1003DFA7C(v478);
                                                          LODWORD(v544[0].__r_.__value_.__l.__data_) = v457;
                                                          v413 = &v550;
                                                          if (v410 < 0) {
                                                            v413 = (std::string *)v411;
                                                          }
                                                          *(std::string::size_type *)((char *)v544[0].__r_.__value_.__r.__words
                                                                                    + 4) = (std::string::size_type)v413;
                                                          WORD2(v544[0].__r_.__value_.__r.__words[1]) = 1024;
                                                          *(_DWORD *)((char *)&v544[0].__r_.__value_.__r.__words[1] + 6) = v412;
                                                          WORD1(v544[0].__r_.__value_.__r.__words[2]) = 1024;
                                                          HIDWORD(v544[0].__r_.__value_.__r.__words[2]) = (_DWORD)v464;
                                                          _os_log_impl( (void *)&_mh_execute_header,  v408,  OS_LOG_TYPE_DEFAULT,  "Cloud: Listening mode config update is from new services lay er for device %{public}s, current value: %d, cloud configs(LSv2): %d",  (uint8_t *)v544,  0x18u);
                                                        }

                                                        goto LABEL_675;
                                                      }

                                                      if (v409)
                                                      {
                                                        sub_1003CF00C(v478, &v550);
                                                        v414 = (v550.__r_.__value_.__s.__size_ & 0x80u) == 0
                                                             ? &v550
                                                             : (std::string *)v550.__r_.__value_.__r.__words[0];
                                                        v415 = sub_1003DFA7C(v478);
                                                        v416 = sub_1003DFA7C(v478);
                                                        LODWORD(v544[0].__r_.__value_.__l.__data_) = v457;
                                                        *(std::string::size_type *)((char *)v544[0].__r_.__value_.__r.__words
                                                                                  + 4) = (std::string::size_type)v414;
                                                        WORD2(v544[0].__r_.__value_.__r.__words[1]) = 1024;
                                                        *(_DWORD *)((char *)&v544[0].__r_.__value_.__r.__words[1] + 6) = v415;
                                                        WORD1(v544[0].__r_.__value_.__r.__words[2]) = 1024;
                                                        HIDWORD(v544[0].__r_.__value_.__r.__words[2]) = v416 | v462;
                                                        _os_log_impl( (void *)&_mh_execute_header,  v408,  OS_LOG_TYPE_DEFAULT,  "Cloud: Listening mode config update for device %{public}s, cur rent value: %d, cloud configs(+adaptive support): %d",  (uint8_t *)v544,  0x18u);
                                                      }

                                                      v464 = (id)(sub_1003DFA7C(v478) | v462);
                                                      if ((_DWORD)v464)
                                                      {
LABEL_675:
                                                        if (sub_1003DFA7C(v478) != (_DWORD)v464)
                                                        {
                                                          if (qword_1008D60E0 != -1) {
                                                            dispatch_once(&qword_1008D60E0, &stru_10089A4D8);
                                                          }
                                                          sub_100215778( (uint64_t)off_1008D60D8,  v478,  26LL,  (uint64_t)v464,  4u);
                                                          v417 = (os_log_s *)(id)qword_1008F7600;
                                                          if (os_log_type_enabled(v417, OS_LOG_TYPE_DEFAULT))
                                                          {
                                                            sub_1003CF00C(v478, v544);
                                                            v418 = (char)v544[0].__r_.__value_.__s.__size_;
                                                            v419 = v544[0].__r_.__value_.__r.__words[0];
                                                            v420 = sub_1003DFA7C(v478);
                                                            LODWORD(v550.__r_.__value_.__l.__data_) = v455;
                                                            v421 = v544;
                                                            if (v418 < 0) {
                                                              v421 = (std::string *)v419;
                                                            }
                                                            *(std::string::size_type *)((char *)v550.__r_.__value_.__r.__words
                                                                                      + 4) = (std::string::size_type)v421;
                                                            WORD2(v550.__r_.__value_.__r.__words[1]) = 1024;
                                                            *(_DWORD *)((char *)&v550.__r_.__value_.__r.__words[1] + 6) = v420;
                                                            _os_log_impl( (void *)&_mh_execute_header,  v417,  OS_LOG_TYPE_DEFAULT,  "Cloud: Listening mode config updated for device %{public}s , new configs %d",  (uint8_t *)&v550,  0x12u);
                                                          }
                                                        }
                                                      }

                                                      v422 = (v466 >> 2) & 3;
                                                      v423 = (os_log_s *)(id)qword_1008F7600;
                                                      if (os_log_type_enabled(v423, OS_LOG_TYPE_DEFAULT))
                                                      {
                                                        sub_1003CF00C(v478, &v550);
                                                        v424 = (char)v550.__r_.__value_.__s.__size_;
                                                        v425 = v550.__r_.__value_.__r.__words[0];
                                                        v426 = sub_1003DFC9C(v478);
                                                        LODWORD(v544[0].__r_.__value_.__l.__data_) = v457;
                                                        v427 = &v550;
                                                        if (v424 < 0) {
                                                          v427 = (std::string *)v425;
                                                        }
                                                        *(std::string::size_type *)((char *)v544[0].__r_.__value_.__r.__words
                                                                                  + 4) = (std::string::size_type)v427;
                                                        WORD2(v544[0].__r_.__value_.__r.__words[1]) = 1024;
                                                        *(_DWORD *)((char *)&v544[0].__r_.__value_.__r.__words[1] + 6) = v426;
                                                        WORD1(v544[0].__r_.__value_.__r.__words[2]) = 1024;
                                                        HIDWORD(v544[0].__r_.__value_.__r.__words[2]) = (v466 >> 2) & 3;
                                                        _os_log_impl( (void *)&_mh_execute_header,  v423,  OS_LOG_TYPE_DEFAULT,  "Cloud: One Bud ANC mode update for device %{public}s, current value: %d, cloud value %d",  (uint8_t *)v544,  0x18u);
                                                      }

                                                      v428 = sub_1003D2B2C(v478, 43);
                                                      if ((_DWORD)v422) {
                                                        v429 = v428;
                                                      }
                                                      else {
                                                        v429 = 1;
                                                      }
                                                      if ((v429 & 1) == 0
                                                        && sub_1003DFC9C(v478) != (_DWORD)v422)
                                                      {
                                                        if (qword_1008D60E0 != -1) {
                                                          dispatch_once(&qword_1008D60E0, &stru_10089A4D8);
                                                        }
                                                        sub_100215778((uint64_t)off_1008D60D8, v478, 27LL, v422, 4u);
                                                        v430 = (os_log_s *)(id)qword_1008F7600;
                                                        if (os_log_type_enabled(v430, OS_LOG_TYPE_DEFAULT))
                                                        {
                                                          sub_1003CF00C(v478, v544);
                                                          v431 = (char)v544[0].__r_.__value_.__s.__size_;
                                                          v432 = v544[0].__r_.__value_.__r.__words[0];
                                                          v433 = sub_1003DFC9C(v478);
                                                          LODWORD(v550.__r_.__value_.__l.__data_) = v455;
                                                          v434 = v544;
                                                          if (v431 < 0) {
                                                            v434 = (std::string *)v432;
                                                          }
                                                          *(std::string::size_type *)((char *)v550.__r_.__value_.__r.__words
                                                                                    + 4) = (std::string::size_type)v434;
                                                          WORD2(v550.__r_.__value_.__r.__words[1]) = 1024;
                                                          *(_DWORD *)((char *)&v550.__r_.__value_.__r.__words[1] + 6) = v433;
                                                          _os_log_impl( (void *)&_mh_execute_header,  v430,  OS_LOG_TYPE_DEFAULT,  "Cloud: One Bud ANC mode updated for device %{public}s, new mode %d",  (uint8_t *)&v550,  0x12u);
                                                        }
                                                      }

                                                      if (sub_1003D2B2C(v478, 32)
                                                        && !sub_1003DF988(v478))
                                                      {
                                                        v435 = (os_log_s *)(id)qword_1008F7600;
                                                        if (os_log_type_enabled(v435, OS_LOG_TYPE_DEFAULT))
                                                        {
                                                          sub_1003CF00C(v478, &v550);
                                                          if ((v550.__r_.__value_.__s.__size_ & 0x80u) == 0) {
                                                            v436 = &v550;
                                                          }
                                                          else {
                                                            v436 = (std::string *)v550.__r_.__value_.__r.__words[0];
                                                          }
                                                          v437 = sub_1003D2B2C(v478, 32);
                                                          v438 = sub_1003DF988(v478);
                                                          LODWORD(v544[0].__r_.__value_.__l.__data_) = v457;
                                                          v439 = "No";
                                                          if (v437) {
                                                            v439 = "Yes";
                                                          }
                                                          *(std::string::size_type *)((char *)v544[0].__r_.__value_.__r.__words
                                                                                    + 4) = (std::string::size_type)v436;
                                                          WORD2(v544[0].__r_.__value_.__r.__words[1]) = 2080;
                                                          *(std::string::size_type *)((char *)&v544[0].__r_.__value_.__r.__words[1]
                                                                                    + 6) = (std::string::size_type)v439;
                                                          HIWORD(v544[0].__r_.__value_.__r.__words[2]) = 1024;
                                                          LODWORD(v544[1].__r_.__value_.__l.__data_) = v438;
                                                          _os_log_impl( (void *)&_mh_execute_header,  v435,  OS_LOG_TYPE_DEFAULT,  "Cloud: %{public}s Initialize setSmartRouteMode via cloud Tip i Supint port = %s current SR Mode =%d",  (uint8_t *)v544,  0x1Cu);
                                                        }

                                                        sub_1003DD65C(v478, 1LL);
                                                      }

                                                      v440 = (os_log_s *)(id)qword_1008F7600;
                                                      if (os_log_type_enabled(v440, OS_LOG_TYPE_DEFAULT))
                                                      {
                                                        sub_1003CF00C(v478, &v550);
                                                        v441 = (char)v550.__r_.__value_.__s.__size_;
                                                        v442 = v550.__r_.__value_.__r.__words[0];
                                                        v443 = sub_1003D2B2C(v478, 32);
                                                        LODWORD(v544[0].__r_.__value_.__l.__data_) = v457;
                                                        v444 = &v550;
                                                        if (v441 < 0) {
                                                          v444 = (std::string *)v442;
                                                        }
                                                        *(std::string::size_type *)((char *)v544[0].__r_.__value_.__r.__words
                                                                                  + 4) = (std::string::size_type)v444;
                                                        WORD2(v544[0].__r_.__value_.__r.__words[1]) = 1024;
                                                        *(_DWORD *)((char *)&v544[0].__r_.__value_.__r.__words[1] + 6) = v443;
                                                        WORD1(v544[0].__r_.__value_.__r.__words[2]) = 1024;
                                                        HIDWORD(v544[0].__r_.__value_.__r.__words[2]) = (v466 & 0x40) >> 6;
                                                        _os_log_impl( (void *)&_mh_execute_header,  v440,  OS_LOG_TYPE_DEFAULT,  "Cloud: TiPi supported flag update from listeningServices mask %{public}s, current local value: %d, listeningServices mask value: %d",  (uint8_t *)v544,  0x18u);
                                                      }

                                                      if ((v466 & 0x40) != 0
                                                        && (sub_1003D2B2C(v478, 32) & 1) == 0)
                                                      {
                                                        sub_1003D6FAC(v478, 32, 1);
                                                      }
                                                    }
                                                  }

                                                  else
                                                  {
                                                  }
                                                }

                                                else
                                                {
                                                }
                                              }

                                              else
                                              {
                                              }
                                            }

                                            else
                                            {
                                            }
                                          }

                                          else
                                          {
                                          }
                                        }

                                        else
                                        {
                                        }
                                      }

                                      else
                                      {
                                      }
                                    }

                                    else
                                    {
                                    }
                                  }

                                  else
                                  {
                                  }

LABEL_722:
                                  if (SHIBYTE(v551[2]) < 0) {
                                    operator delete(v551[0]);
                                  }
                                  goto LABEL_724;
                                }

                                v294 = 1LL;
                                while (v294 != 6)
                                {
                                  if (*((unsigned __int8 *)&v490 + v294++))
                                  {
                                    break;
                                  }
                                }
                              }

                              if (os_log_type_enabled((os_log_t)qword_1008F7600, OS_LOG_TYPE_ERROR)) {
                                sub_1006836A0(&v488, (_BYTE *)v473);
                              }
                              goto LABEL_722;
                            }

LABEL_724:
                            *(void *)&v479 = v479 + 1;
                          }

                          while ((std::string *)v479 != v477);
                          v449 = (std::string *)[(id)v475 countByEnumeratingWithState:&v492 objects:v540 count:16];
                          v477 = v449;
                          if (!v449)
                          {
LABEL_734:

                            break;
                          }
                        }
                      }
                    }
                  }
                }
              }

              goto LABEL_110;
            }

            __int128 v17 = (id)_CFXPCCreateCFObjectFromXPCMessage(v9);
            v236 = (os_log_s *)qword_1008F7588;
            if (os_log_type_enabled((os_log_t)qword_1008F7588, OS_LOG_TYPE_DEFAULT))
            {
              LOWORD(v544[0].__r_.__value_.__l.__data_) = 0;
              _os_log_impl( (void *)&_mh_execute_header,  v236,  OS_LOG_TYPE_DEFAULT,  "Devices magic info removed",  (uint8_t *)v544,  2u);
            }

            if (!sub_1002E9258()) {
              goto LABEL_110;
            }
            v237 = -[CloudPairing iCloudSignedIn](self, "iCloudSignedIn");
            v238 = v17 ? v237 : 0;
            if (v238 != 1) {
              goto LABEL_110;
            }
            v477 = (std::string *)objc_claimAutoreleasedReturnValue([v17 objectForKeyedSubscript:@"records"]);
            v239 = objc_opt_class(&OBJC_CLASS___NSData);
            if ((objc_opt_isKindOfClass(v477, v239) & 1) != 0)
            {
              v543[0] = objc_opt_class(&OBJC_CLASS___NSArray);
              v543[1] = objc_opt_class(&OBJC_CLASS___NSString);
              v543[2] = objc_opt_class(&OBJC_CLASS___BTMagicPairingSettings);
              v240 = (void *)objc_claimAutoreleasedReturnValue( +[NSArray arrayWithObjects:count:]( &OBJC_CLASS___NSArray,  "arrayWithObjects:count:",  v543,  3LL));
              v241 = (void *)objc_claimAutoreleasedReturnValue(+[NSSet setWithArray:](&OBJC_CLASS___NSSet, "setWithArray:", v240));
              *(void *)&v475 = objc_claimAutoreleasedReturnValue( +[NSKeyedUnarchiver unarchivedObjectOfClasses:fromData:error:]( &OBJC_CLASS___NSKeyedUnarchiver,  "unarchivedObjectOfClasses:fromData:error:",  v241,  v477,  0LL));

              if ((void)v475)
              {
                v242 = objc_opt_class(&OBJC_CLASS___NSArray);
                if ((objc_opt_isKindOfClass(v475, v242) & 1) != 0)
                {
                  v498 = 0u;
                  v499 = 0u;
                  v496 = 0u;
                  v497 = 0u;
                  *(void *)&v480 = (id)v475;
                  v243 = [(id)v480 countByEnumeratingWithState:&v496 objects:v542 count:16];
                  if (!v243) {
                    goto LABEL_387;
                  }
                  v245 = *(void *)v497;
                  *(void *)&v244 = 138412290LL;
                  v479 = v244;
                  *(void *)&v244 = 136446210LL;
                  v478 = v244;
                  *(void *)&v244 = 136315138LL;
                  v476 = v244;
                  while (1)
                  {
                    v246 = 0LL;
                    do
                    {
                      if (*(void *)v497 != v245) {
                        objc_enumerationMutation((id)v480);
                      }
                      v247 = *(void **)(*((void *)&v496 + 1) + 8LL * (void)v246);
                      v248 = objc_opt_class(&OBJC_CLASS___BTMagicPairingSettings);
                      if ((objc_opt_isKindOfClass(v247, v248) & 1) != 0)
                      {
                        v249 = (os_log_s *)qword_1008F7600;
                        if (os_log_type_enabled((os_log_t)qword_1008F7600, OS_LOG_TYPE_DEFAULT))
                        {
                          LODWORD(v544[0].__r_.__value_.__l.__data_) = v479;
                          *(std::string::size_type *)((char *)v544[0].__r_.__value_.__r.__words + 4) = (std::string::size_type)v247;
                          _os_log_impl( (void *)&_mh_execute_header,  v249,  OS_LOG_TYPE_DEFAULT,  "Device magic Info to be removed: %@",  (uint8_t *)v544,  0xCu);
                        }

                        WORD2(v539) = 0;
                        LODWORD(v539) = 0;
                        memset(v544, 0, 24);
                        v250 = objc_claimAutoreleasedReturnValue([v247 bluetoothAddress]);
                        sub_10002418C(v544, (char *)[v250 UTF8String]);

                        if ((v544[0].__r_.__value_.__s.__size_ & 0x80u) == 0) {
                          v251 = v544;
                        }
                        else {
                          v251 = (std::string *)v544[0].__r_.__value_.__r.__words[0];
                        }
                        if (sub_1003FE1A4((uint64_t)&v539, (unsigned __int8 *)v251))
                        {
                          if ((_BYTE)v539)
                          {
LABEL_356:
                            if (qword_1008D5F50 != -1) {
                              dispatch_once(&qword_1008D5F50, &stru_10089A4B8);
                            }
                            v252 = (unsigned __int8 *)sub_1003FFEB0(off_1008D5F48, (uint64_t)&v539, 0);
                            if (v252)
                            {
                              if (qword_1008D60C0 != -1) {
                                dispatch_once(&qword_1008D60C0, &stru_10089A498);
                              }
                              v253 = sub_1003EE4A0((uint64_t)off_1008D60B8, (uint64_t)v252);
                              v254 = (os_log_s *)(id)qword_1008F7600;
                              v255 = v254;
                              if (v253)
                              {
                                if (os_log_type_enabled(v254, OS_LOG_TYPE_DEFAULT))
                                {
                                  sub_1003CF00C((uint64_t)v252, v551);
                                  v256 = v551;
                                  if (SHIBYTE(v551[2]) < 0) {
                                    v256 = (void **)v551[0];
                                  }
                                  LODWORD(v550.__r_.__value_.__l.__data_) = v478;
                                  *(std::string::size_type *)((char *)v550.__r_.__value_.__r.__words + 4) = (std::string::size_type)v256;
                                  _os_log_impl( (void *)&_mh_execute_header,  v255,  OS_LOG_TYPE_DEFAULT,  "Remove magic paired device: %{public}s",  (uint8_t *)&v550,  0xCu);
                                  if (SHIBYTE(v551[2]) < 0) {
                                    operator delete(v551[0]);
                                  }
                                }

                                if (qword_1008D60C0 != -1) {
                                  dispatch_once(&qword_1008D60C0, &stru_10089A498);
                                }
                                sub_1003EE5AC((uint64_t)off_1008D60B8, v252, 0);
                              }

                              else
                              {
                                if (os_log_type_enabled(v254, OS_LOG_TYPE_INFO))
                                {
                                  sub_1003CF00C((uint64_t)v252, v551);
                                  v260 = v551;
                                  if (SHIBYTE(v551[2]) < 0) {
                                    v260 = (void **)v551[0];
                                  }
                                  LODWORD(v550.__r_.__value_.__l.__data_) = v478;
                                  *(std::string::size_type *)((char *)v550.__r_.__value_.__r.__words + 4) = (std::string::size_type)v260;
                                  _os_log_impl( (void *)&_mh_execute_header,  v255,  OS_LOG_TYPE_INFO,  "Cannot find magic paired device to remove: %{public}s",  (uint8_t *)&v550,  0xCu);
                                  if (SHIBYTE(v551[2]) < 0) {
                                    operator delete(v551[0]);
                                  }
                                }
                              }
                            }

LABEL_376:
                            goto LABEL_378;
                          }

                          v257 = 1LL;
                          while (v257 != 6)
                          {
                            if (v540[v257++ - 16])
                            {
                              break;
                            }
                          }
                        }

                        v259 = (os_log_s *)qword_1008F7600;
                        if (os_log_type_enabled((os_log_t)qword_1008F7600, OS_LOG_TYPE_ERROR))
                        {
                          LODWORD(v551[0]) = v476;
                          *(void **)((char *)v551 + 4) = v251;
                          _os_log_error_impl( (void *)&_mh_execute_header,  v259,  OS_LOG_TYPE_ERROR,  "Received invalid device address for device record: %s",  (uint8_t *)v551,  0xCu);
                        }

                        goto LABEL_376;
                      }

LABEL_378:
                      v246 = (char *)v246 + 1;
                    }

                    while (v246 != v243);
                    v261 = [(id)v480 countByEnumeratingWithState:&v496 objects:v542 count:16];
                    v243 = v261;
                    if (!v261)
                    {
LABEL_387:

                      break;
                    }
                  }
                }
              }
            }

            goto LABEL_110;
          }

          __int128 v17 = (id)_CFXPCCreateCFObjectFromXPCMessage(v9);
          v202 = (os_log_s *)(id)qword_1008F7600;
          if (os_log_type_enabled(v202, OS_LOG_TYPE_DEFAULT))
          {
            v203 = objc_claimAutoreleasedReturnValue([v17 debugDescription]);
            v204 = [v203 UTF8String];
            LODWORD(v544[0].__r_.__value_.__l.__data_) = 136446210;
            *(std::string::size_type *)((char *)v544[0].__r_.__value_.__r.__words + 4) = (std::string::size_type)v204;
            _os_log_impl( (void *)&_mh_execute_header,  v202,  OS_LOG_TYPE_DEFAULT,  "Device support info updated from cloudkit = %{public}s",  (uint8_t *)v544,  0xCu);
          }

          if (!sub_1002E9258() || !v17) {
            goto LABEL_110;
          }
          *(void *)&v470 = objc_claimAutoreleasedReturnValue([v17 objectForKeyedSubscript:@"records"]);
          v205 = objc_opt_class(&OBJC_CLASS___NSData);
          if ((objc_opt_isKindOfClass(v470, v205) & 1) != 0)
          {
            v547[0] = objc_opt_class(&OBJC_CLASS___NSArray);
            v547[1] = objc_opt_class(&OBJC_CLASS___NSString);
            v547[2] = objc_opt_class(&OBJC_CLASS___BTCloudDeviceSupportInformation);
            v206 = (void *)objc_claimAutoreleasedReturnValue( +[NSArray arrayWithObjects:count:]( &OBJC_CLASS___NSArray,  "arrayWithObjects:count:",  v547,  3LL));
            v207 = (void *)objc_claimAutoreleasedReturnValue(+[NSSet setWithArray:](&OBJC_CLASS___NSSet, "setWithArray:", v206));
            *(void *)&v469 = objc_claimAutoreleasedReturnValue( +[NSKeyedUnarchiver unarchivedObjectOfClasses:fromData:error:]( &OBJC_CLASS___NSKeyedUnarchiver,  "unarchivedObjectOfClasses:fromData:error:",  v207,  (void)v470,  0LL));

            if ((void)v469)
            {
              v208 = objc_opt_class(&OBJC_CLASS___NSArray);
              if ((objc_opt_isKindOfClass(v469, v208) & 1) != 0)
              {
                v505 = 0u;
                v506 = 0u;
                v503 = 0u;
                v504 = 0u;
                *(void *)&v478 = (id)v469;
                *(void *)&v480 = [(id)v478 countByEnumeratingWithState:&v503 objects:v546 count:16];
                if (!(void)v480) {
                  goto LABEL_330;
                }
                v477 = (std::string *)&v544[1].__r_.__value_.__r.__words[1];
                *(void *)&v472 = (char *)&v539 + 1;
                *(void *)&v479 = *(void *)v504;
                *(void *)&v473 = (char *)v550.__r_.__value_.__r.__words + 1;
                *(void *)&v209 = 136446210LL;
                v471 = v209;
                while (1)
                {
                  v210 = 0LL;
                  do
                  {
                    if (*(void *)v504 != (void)v479) {
                      objc_enumerationMutation((id)v478);
                    }
                    v211 = *(void **)(*((void *)&v503 + 1) + 8 * v210);
                    v212 = objc_opt_class(&OBJC_CLASS___BTCloudDeviceSupportInformation);
                    if ((objc_opt_isKindOfClass(v211, v212) & 1) != 0)
                    {
                      v213 = (void *)objc_claimAutoreleasedReturnValue([v211 bluetoothAddress]);
                      v214 = sub_1005C02B0(v213);

                      if (v214)
                      {
                        if (qword_1008D5F50 != -1) {
                          dispatch_once(&qword_1008D5F50, &stru_10089A4B8);
                        }
                        v215 = (std::string *)sub_10040007C(off_1008D5F48, v214, 0);
                        v216 = v215;
                        if (v215)
                        {
                          if (v215[5].__r_.__value_.__s.__data_[8])
                          {
LABEL_297:
                            v217 = (os_log_s *)(id)qword_1008F7600;
                            if (os_log_type_enabled(v217, OS_LOG_TYPE_DEFAULT))
                            {
                              sub_1003CF00C((uint64_t)v216, v544);
                              v218 = v544;
                              if ((v544[0].__r_.__value_.__s.__size_ & 0x80u) != 0) {
                                v218 = (std::string *)v544[0].__r_.__value_.__r.__words[0];
                              }
                              LODWORD(v551[0]) = v471;
                              *(void **)((char *)v551 + 4) = v218;
                              _os_log_impl( (void *)&_mh_execute_header,  v217,  OS_LOG_TYPE_DEFAULT,  "DeviceSupportInformationRecordsUpdated for %{public}s",  (uint8_t *)v551,  0xCu);
                            }

                            v219 = (void *)objc_claimAutoreleasedReturnValue(-[CloudPairing cloudClient](self, "cloudClient"));
                            v220 = (void *)objc_claimAutoreleasedReturnValue([v211 bluetoothAddress]);
                            v502[0] = _NSConcreteStackBlock;
                            v502[1] = 3221225472LL;
                            v502[2] = sub_100480590;
                            v502[3] = &unk_1008960A8;
                            v502[5] = v216;
                            v502[4] = v211;
                            [v219 deviceRecord:v220 completion:v502];

                            v221 = (void *)objc_claimAutoreleasedReturnValue([v211 ancAssetVersion]);
                            LODWORD(v219) = (unint64_t)[v221 length] > 1;

                            if ((_DWORD)v219)
                            {
                              v222 = objc_claimAutoreleasedReturnValue([v211 ancAssetVersion]);
                              sub_10002418C(&v501, (char *)[v222 UTF8String]);
                              sub_1003D9644(v216, &v501);
                            }

                            v545 = 0LL;
                            memset(v544, 0, sizeof(v544));
                            sub_10002418C(v477, "");
                            sub_1003D9724((uint64_t)v216, (uint64_t)v544);
                            v223 = (void *)objc_claimAutoreleasedReturnValue([v211 caseFirmwareVersion]);
                            v224 = v223 == 0LL;

                            if (v224
                              || (v225 = (void *)objc_claimAutoreleasedReturnValue([v211 caseFirmwareVersion]),
                                  v226 = [v225 longLongValue],
                                  v225,
                                  !v226))
                            {
                              LODWORD(v4sub_10023DF50(v3 + 76) = 0;
                            }

                            else
                            {
                              v544[0].__r_.__value_.__l.__cap_ = (std::string::size_type)v226;
                              LODWORD(v4sub_10023DF50(v3 + 76) = 1;
                            }

                            v227 = (void *)objc_claimAutoreleasedReturnValue([v211 caseName]);
                            v228 = (unint64_t)[v227 length] > 1;

                            if (v228)
                            {
                              v229 = objc_claimAutoreleasedReturnValue([v211 caseName]);
                              std::string::assign( v477,  (const std::string::value_type *)[v229 UTF8String]);

LABEL_321:
                              v233 = v544[0].__r_.__value_.__s.__data_[0];
                              LODWORD(v4sub_10023DF50(v3 + 76) = *(unsigned __int16 *)&v544[0].__r_.__value_.__s.__data_[2];
                              v234 = HIDWORD(v544[0].__r_.__value_.__r.__words[0]);
                              v235 = v544[0].__r_.__value_.__r.__words[1];
                              LODWORD(v475) = v544[0].__r_.__value_.__s.__data_[10];
                              *(void *)&v474 = v544[0].__r_.__value_.__l.__cap_;
                              if (SHIBYTE(v545) < 0) {
                                sub_100024238( &v500,  (void *)v544[1].__r_.__value_.__l.__size_,  v544[1].__r_.__value_.__l.__cap_);
                              }
                              else {
                                v500 = *v477;
                              }
                              sub_1003D97B4((uint64_t)v216, v233, v476, v234, v235, v475, v474, 0, &v500);
                            }

                            else if ((_DWORD)v476)
                            {
                              goto LABEL_321;
                            }

                            if (SHIBYTE(v545) < 0) {
                              operator delete((void *)v544[1].__r_.__value_.__l.__size_);
                            }
                            goto LABEL_328;
                          }

                          v230 = 0LL;
                          while (v230 != 5)
                          {
                            v231 = v230;
                            if (*((unsigned __int8 *)&v215[5].__r_.__value_.__r.__words[1] + ++v230))
                            {
                              if (v231 < 5) {
                                goto LABEL_297;
                              }
                              break;
                            }
                          }
                        }

                        if (os_log_type_enabled((os_log_t)qword_1008F7600, OS_LOG_TYPE_ERROR)) {
                          sub_100683674(&v539, (_BYTE *)v472);
                        }
                      }

                      else if (os_log_type_enabled((os_log_t)qword_1008F7600, OS_LOG_TYPE_ERROR))
                      {
                        sub_100683648(&v550, (_BYTE *)v473);
                      }
                    }

LABEL_268:
                    if (SHIBYTE(v551[2]) < 0) {
                      operator delete(v551[0]);
                    }
                  }

                  ++v169;
                }

                while (v169 != (void)v480);
                *(void *)&v480 = unk_1008FB918(v477, "countByEnumeratingWithState:objects:count:", &v515, v552, 16LL);
                if (!(void)v480)
                {
LABEL_272:

                  break;
                }
              }
            }
          }
        }

        goto LABEL_110;
      }

      __int128 v17 = (id)_CFXPCCreateCFObjectFromXPCMessage(v9);
      uint64_t v106 = (os_log_s *)qword_1008F7588;
      if (os_log_type_enabled((os_log_t)qword_1008F7588, OS_LOG_TYPE_INFO))
      {
        LODWORD(v544[0].__r_.__value_.__l.__data_) = 138412290;
        *(std::string::size_type *)((char *)v544[0].__r_.__value_.__r.__words + 4) = (std::string::size_type)v17;
        _os_log_impl( (void *)&_mh_execute_header,  v106,  OS_LOG_TYPE_INFO,  "Process RemoveCloudPairedDevice: %@",  (uint8_t *)v544,  0xCu);
      }

      uint64_t v107 = (void *)objc_claimAutoreleasedReturnValue([v17 objectForKey:@"kCloudDeviceUniqueID"]);
      uint64_t v108 = objc_opt_class(&OBJC_CLASS___NSString);
      if ((objc_opt_isKindOfClass(v107, v108) & 1) != 0)
      {
        uint64_t v109 = (void *)objc_claimAutoreleasedReturnValue([v17 objectForKey:@"kCloudDeviceUniqueID"]);

        if (v109)
        {
          int v110 = (os_log_s *)qword_1008F7588;
          if (os_log_type_enabled((os_log_t)qword_1008F7588, OS_LOG_TYPE_DEFAULT))
          {
            LODWORD(v544[0].__r_.__value_.__l.__data_) = 138412290;
            *(std::string::size_type *)((char *)v544[0].__r_.__value_.__r.__words + 4) = (std::string::size_type)v109;
            _os_log_impl( (void *)&_mh_execute_header,  v110,  OS_LOG_TYPE_DEFAULT,  "Removing CloudPairedDevice value: %@",  (uint8_t *)v544,  0xCu);
          }

          uint64_t v111 = sub_100404FE8();
          v527[0] = _NSConcreteStackBlock;
          v527[1] = 3221225472LL;
          v527[2] = sub_10048049C;
          v527[3] = &unk_10087EA48;
          int v112 = v109;
          v528 = v112;
          sub_100405384(v111, v527);

          goto LABEL_110;
        }
      }

      else
      {
      }

      unsigned __int8 v120 = qword_1008F7588;
      if (!os_log_type_enabled((os_log_t)qword_1008F7588, OS_LOG_TYPE_INFO))
      {
LABEL_110:

LABEL_111:
        goto LABEL_112;
      }

      LODWORD(v544[0].__r_.__value_.__l.__data_) = 138412290;
      *(std::string::size_type *)((char *)v544[0].__r_.__value_.__r.__words + 4) = 0LL;
      uint64_t v66 = "Invalid RemoveCloudPairedDevice value: %@";
      __int16 v67 = (os_log_s *)v120;
      BOOL v68 = OS_LOG_TYPE_INFO;
      BOOL v69 = 12;
    }

    _os_log_impl((void *)&_mh_execute_header, v67, v68, v66, (uint8_t *)v544, v69);
    goto LABEL_110;
  }

void sub_10047F630(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

id sub_100480468(uint64_t a1)
{
  id result = [*(id *)(a1 + 32) handleXPCUnpairCommand:*(void *)(a1 + 40)];
  *(_BYTE *)(*(void *)(*(void *)(a1 + 48) + 8LL) + 24LL) = (_BYTE)result;
  return result;
}

void sub_10048049C(uint64_t a1)
{
  if (qword_1008D5F20 != -1) {
    dispatch_once(&qword_1008D5F20, &stru_10089A478);
  }
  uint64_t v2 = qword_1008D5F18;
  sub_10002418C(__p, (char *)[*(id *)(a1 + 32) UTF8String]);
  sub_100625934(v2, (unsigned __int8 *)__p);
  if (v4 < 0) {
    operator delete(__p[0]);
  }
}

void sub_100480524( _Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void *__p, uint64_t a11, int a12, __int16 a13, char a14, char a15)
{
  if (a15 < 0) {
    operator delete(__p);
  }
  _Unwind_Resume(exception_object);
}

void sub_100480540(uint64_t a1)
{
  if (qword_1008D5F20 != -1) {
    dispatch_once(&qword_1008D5F20, &stru_10089A478);
  }
  sub_100625C0C(qword_1008D5F18, *(void **)(a1 + 32));
}

void sub_100480590(uint64_t a1, void *a2, void *a3)
{
  id v5 = a2;
  id v6 = a3;
  id v7 = v6;
  if (v5 && !v6)
  {
    uint64_t v128 = 0LL;
    uint64_t v129 = 0LL;
    uint64_t v130 = 0LL;
    int v8 = sub_1003D8F04(*(void *)(a1 + 40), (uint64_t)&v128);
    __int128 __dst = 0uLL;
    uint64_t v127 = 0LL;
    id v9 = (void *)objc_claimAutoreleasedReturnValue([v5 modelNumber]);
    if ((unint64_t)[v9 length] < 2)
    {
      if (v8)
      {
        if (*(char *)(v128 + 47) < 0)
        {
          sub_100024238(&__dst, *(void **)(v128 + 24), *(void *)(v128 + 32));
        }

        else
        {
          __int128 __dst = *(_OWORD *)(v128 + 24);
          uint64_t v127 = *(void *)(v128 + 40);
        }
      }

      else
      {
        sub_10002418C(&__dst, "");
      }
    }

    else
    {
      id v10 = objc_claimAutoreleasedReturnValue([v5 modelNumber]);
      sub_10002418C(&__dst, (char *)[v10 UTF8String]);
    }

    __int128 v124 = 0uLL;
    uint64_t v125 = 0LL;
    unint64_t v11 = (void *)objc_claimAutoreleasedReturnValue([v5 manufacturer]);
    if ((unint64_t)[v11 length] < 2)
    {
      if (v8)
      {
        if (*(char *)(v128 + 71) < 0)
        {
          sub_100024238(&v124, *(void **)(v128 + 48), *(void *)(v128 + 56));
        }

        else
        {
          __int128 v124 = *(_OWORD *)(v128 + 48);
          uint64_t v125 = *(void *)(v128 + 64);
        }
      }

      else
      {
        sub_10002418C(&v124, "");
      }
    }

    else
    {
      id v12 = objc_claimAutoreleasedReturnValue([v5 manufacturer]);
      sub_10002418C(&v124, (char *)[v12 UTF8String]);
    }

    __int128 v122 = 0uLL;
    uint64_t v123 = 0LL;
    float v13 = (void *)objc_claimAutoreleasedReturnValue([*(id *)(a1 + 32) caseSerialNumber]);
    if ((unint64_t)[v13 length] < 2)
    {
      if (v8)
      {
        if (*(char *)(v128 + 95) < 0)
        {
          sub_100024238(&v122, *(void **)(v128 + 72), *(void *)(v128 + 80));
        }

        else
        {
          __int128 v122 = *(_OWORD *)(v128 + 72);
          uint64_t v123 = *(void *)(v128 + 88);
        }
      }

      else
      {
        sub_10002418C(&v122, "");
      }
    }

    else
    {
      id v14 = objc_claimAutoreleasedReturnValue([*(id *)(a1 + 32) caseSerialNumber]);
      sub_10002418C(&v122, (char *)[v14 UTF8String]);
    }

    __int128 v120 = 0uLL;
    uint64_t v121 = 0LL;
    __int128 v15 = (void *)objc_claimAutoreleasedReturnValue([*(id *)(a1 + 32) hardwareVersion]);
    if ((unint64_t)[v15 length] < 2)
    {
      if (v8)
      {
        if (*(char *)(v128 + 167) < 0)
        {
          sub_100024238(&v120, *(void **)(v128 + 144), *(void *)(v128 + 152));
        }

        else
        {
          __int128 v120 = *(_OWORD *)(v128 + 144);
          uint64_t v121 = *(void *)(v128 + 160);
        }
      }

      else
      {
        sub_10002418C(&v120, "");
      }
    }

    else
    {
      id v16 = objc_claimAutoreleasedReturnValue([*(id *)(a1 + 32) hardwareVersion]);
      sub_10002418C(&v120, (char *)[v16 UTF8String]);
    }

    __int128 v118 = 0uLL;
    uint64_t v119 = 0LL;
    __int128 v17 = (void *)objc_claimAutoreleasedReturnValue([*(id *)(a1 + 32) leftBudSerialNumber]);
    if ((unint64_t)[v17 length] < 2)
    {
      if (v8)
      {
        if (*(char *)(v128 + 215) < 0)
        {
          sub_100024238(&v118, *(void **)(v128 + 192), *(void *)(v128 + 200));
        }

        else
        {
          __int128 v118 = *(_OWORD *)(v128 + 192);
          uint64_t v119 = *(void *)(v128 + 208);
        }
      }

      else
      {
        sub_10002418C(&v118, "");
      }
    }

    else
    {
      id v18 = objc_claimAutoreleasedReturnValue([*(id *)(a1 + 32) leftBudSerialNumber]);
      sub_10002418C(&v118, (char *)[v18 UTF8String]);
    }

    v116[0] = 0LL;
    v116[1] = 0LL;
    uint64_t v117 = 0LL;
    char v19 = (void *)objc_claimAutoreleasedReturnValue([*(id *)(a1 + 32) rightBudSerialNumber]);
    if ((unint64_t)[v19 length] < 2)
    {
      if (v8)
      {
        if (*(char *)(v128 + 239) < 0)
        {
          sub_100024238(v116, *(void **)(v128 + 216), *(void *)(v128 + 224));
        }

        else
        {
          *(_OWORD *)uint64_t v116 = *(_OWORD *)(v128 + 216);
          uint64_t v117 = *(void *)(v128 + 232);
        }
      }

      else
      {
        sub_10002418C(v116, "");
      }
    }

    else
    {
      id v20 = objc_claimAutoreleasedReturnValue([*(id *)(a1 + 32) rightBudSerialNumber]);
      sub_10002418C(v116, (char *)[v20 UTF8String]);
    }

    v114[0] = 0LL;
    v114[1] = 0LL;
    uint64_t v115 = 0LL;
    char v21 = (void *)objc_claimAutoreleasedReturnValue([*(id *)(a1 + 32) budsFirmwareVersion]);
    if ((unint64_t)[v21 length] < 2)
    {
      if (v8)
      {
        if (*(char *)(v128 + 263) < 0)
        {
          sub_100024238(v114, *(void **)(v128 + 240), *(void *)(v128 + 248));
        }

        else
        {
          *(_OWORD *)uint64_t v114 = *(_OWORD *)(v128 + 240);
          uint64_t v115 = *(void *)(v128 + 256);
        }
      }

      else
      {
        sub_10002418C(v114, "");
      }
    }

    else
    {
      id v22 = objc_claimAutoreleasedReturnValue([*(id *)(a1 + 32) budsFirmwareVersion]);
      sub_10002418C(v114, (char *)[v22 UTF8String]);
    }

    int64x2_t v112 = 0uLL;
    v113[0] = 0LL;
    sub_10002418C(__p, "");
    char v23 = (_OWORD *)v112.i64[1];
    if (v112.i64[1] >= v113[0])
    {
      unint64_t v26 = 0xAAAAAAAAAAAAAAABLL * ((v112.i64[1] - v112.i64[0]) >> 3);
      unint64_t v27 = v26 + 1;
      if (v26 + 1 > 0xAAAAAAAAAAAAAAALL) {
        abort();
      }
      if (0x5555555555555556LL * ((v113[0] - v112.i64[0]) >> 3) > v27) {
        unint64_t v27 = 0x5555555555555556LL * ((v113[0] - v112.i64[0]) >> 3);
      }
      if (0xAAAAAAAAAAAAAAABLL * ((v113[0] - v112.i64[0]) >> 3) >= 0x555555555555555LL) {
        unint64_t v28 = 0xAAAAAAAAAAAAAAALL;
      }
      else {
        unint64_t v28 = v27;
      }
      int v134 = v113;
      if (v28) {
        int v29 = (char *)sub_10023F114((uint64_t)v113, v28);
      }
      else {
        int v29 = 0LL;
      }
      uint64_t v30 = &v29[24 * v26];
      __int128 v31 = *(_OWORD *)__p;
      *((void *)v30 + 2) = v111;
      *(_OWORD *)uint64_t v30 = v31;
      __p[1] = 0LL;
      uint64_t v111 = 0LL;
      __p[0] = 0LL;
      uint64_t v32 = v112.i64[1];
      uint64_t v33 = v112.i64[0];
      if (v112.i64[1] == v112.i64[0])
      {
        int64x2_t v36 = vdupq_n_s64(v112.u64[1]);
        uint64_t v34 = &v29[24 * v26];
      }

      else
      {
        uint64_t v34 = &v29[24 * v26];
        do
        {
          __int128 v35 = *(_OWORD *)(v32 - 24);
          *((void *)v34 - 1) = *(void *)(v32 - 8);
          *(_OWORD *)(v34 - 24) = v35;
          v34 -= 24;
          *(void *)(v32 - 16) = 0LL;
          *(void *)(v32 - _Block_object_dispose(va, 8) = 0LL;
          *(void *)(v32 - 24) = 0LL;
          v32 -= 24LL;
        }

        while (v32 != v33);
        int64x2_t v36 = v112;
      }

      __int16 v25 = v30 + 24;
      v112.i64[0] = (uint64_t)v34;
      v112.i64[1] = (uint64_t)(v30 + 24);
      int64x2_t v132 = v36;
      uint64_t v37 = v113[0];
      v113[0] = &v29[24 * v28];
      uint64_t v133 = v37;
      __int128 v131 = (void **)v36.i64[0];
      sub_10023F158((uint64_t)&v131);
      v112.i64[1] = (uint64_t)v25;
      if (SHIBYTE(v111) < 0)
      {
        operator delete(__p[0]);
        __int16 v25 = (char *)v112.i64[1];
      }
    }

    else
    {
      __int128 v24 = *(_OWORD *)__p;
      *(void *)(v112.i64[1] + 16) = v111;
      *char v23 = v24;
      __int16 v25 = (char *)v23 + 24;
      v112.i64[1] = (uint64_t)v23 + 24;
    }

    if ((unint64_t)v25 >= v113[0])
    {
      BOOL v39 = sub_10023EFAC((char **)&v112, &__dst);
    }

    else
    {
      if (SHIBYTE(v127) < 0)
      {
        sub_100024238(v25, (void *)__dst, *((unint64_t *)&__dst + 1));
      }

      else
      {
        __int128 v38 = __dst;
        *((void *)v25 + 2) = v127;
        *(_OWORD *)__int16 v25 = v38;
      }

      BOOL v39 = v25 + 24;
    }

    v112.i64[1] = (uint64_t)v39;
    if ((unint64_t)v39 >= v113[0])
    {
      uint8_t v41 = sub_10023EFAC((char **)&v112, &v124);
    }

    else
    {
      if (SHIBYTE(v125) < 0)
      {
        sub_100024238(v39, (void *)v124, *((unint64_t *)&v124 + 1));
      }

      else
      {
        __int128 v40 = v124;
        *((void *)v39 + 2) = v125;
        *(_OWORD *)BOOL v39 = v40;
      }

      uint8_t v41 = v39 + 24;
    }

    v112.i64[1] = (uint64_t)v41;
    if ((unint64_t)v41 >= v113[0])
    {
      char v43 = sub_10023EFAC((char **)&v112, &v122);
    }

    else
    {
      if (SHIBYTE(v123) < 0)
      {
        sub_100024238(v41, (void *)v122, *((unint64_t *)&v122 + 1));
      }

      else
      {
        __int128 v42 = v122;
        *((void *)v41 + 2) = v123;
        *(_OWORD *)uint8_t v41 = v42;
      }

      char v43 = v41 + 24;
    }

    v112.i64[1] = (uint64_t)v43;
    if (v8)
    {
      if (*(char *)(v128 + 119) < 0)
      {
        sub_100024238(__p, *(void **)(v128 + 96), *(void *)(v128 + 104));
      }

      else
      {
        *(_OWORD *)__int128 __p = *(_OWORD *)(v128 + 96);
        uint64_t v111 = *(void *)(v128 + 112);
      }
    }

    else
    {
      sub_10002418C(__p, "");
    }

    uint8_t v44 = (_OWORD *)v112.i64[1];
    if (v112.i64[1] >= v113[0])
    {
      unint64_t v46 = 0xAAAAAAAAAAAAAAABLL * ((v112.i64[1] - v112.i64[0]) >> 3);
      unint64_t v47 = v46 + 1;
      if (v46 + 1 > 0xAAAAAAAAAAAAAAALL) {
        abort();
      }
      if (0x5555555555555556LL * ((v113[0] - v112.i64[0]) >> 3) > v47) {
        unint64_t v47 = 0x5555555555555556LL * ((v113[0] - v112.i64[0]) >> 3);
      }
      if (0xAAAAAAAAAAAAAAABLL * ((v113[0] - v112.i64[0]) >> 3) >= 0x555555555555555LL) {
        unint64_t v48 = 0xAAAAAAAAAAAAAAALL;
      }
      else {
        unint64_t v48 = v47;
      }
      int v134 = v113;
      if (v48) {
        uint64_t v49 = (char *)sub_10023F114((uint64_t)v113, v48);
      }
      else {
        uint64_t v49 = 0LL;
      }
      __int16 v50 = &v49[24 * v46];
      __int128 v51 = *(_OWORD *)__p;
      *((void *)v50 + 2) = v111;
      *(_OWORD *)__int16 v50 = v51;
      __p[1] = 0LL;
      uint64_t v111 = 0LL;
      __p[0] = 0LL;
      uint64_t v52 = v112.i64[1];
      uint64_t v53 = v112.i64[0];
      if (v112.i64[1] == v112.i64[0])
      {
        int64x2_t v56 = vdupq_n_s64(v112.u64[1]);
        char v54 = &v49[24 * v46];
      }

      else
      {
        char v54 = &v49[24 * v46];
        do
        {
          __int128 v55 = *(_OWORD *)(v52 - 24);
          *((void *)v54 - 1) = *(void *)(v52 - 8);
          *(_OWORD *)(v54 - 24) = v55;
          v54 -= 24;
          *(void *)(v52 - 16) = 0LL;
          *(void *)(v52 - _Block_object_dispose(va, 8) = 0LL;
          *(void *)(v52 - 24) = 0LL;
          v52 -= 24LL;
        }

        while (v52 != v53);
        int64x2_t v56 = v112;
      }

      uint64_t v57 = v50 + 24;
      v112.i64[0] = (uint64_t)v54;
      v112.i64[1] = (uint64_t)(v50 + 24);
      int64x2_t v132 = v56;
      uint64_t v58 = v113[0];
      v113[0] = &v49[24 * v48];
      uint64_t v133 = v58;
      __int128 v131 = (void **)v56.i64[0];
      sub_10023F158((uint64_t)&v131);
      v112.i64[1] = (uint64_t)v57;
      if (SHIBYTE(v111) < 0)
      {
        operator delete(__p[0]);
        if (!v8) {
          goto LABEL_97;
        }
      }

      else if (!v8)
      {
        goto LABEL_97;
      }
    }

    else
    {
      __int128 v45 = *(_OWORD *)__p;
      *(void *)(v112.i64[1] + 16) = v111;
      _OWORD *v44 = v45;
      v112.i64[1] = (uint64_t)v44 + 24;
      if (!v8)
      {
LABEL_97:
        sub_10002418C(__p, "");
LABEL_117:
        uint64_t v59 = (_OWORD *)v112.i64[1];
        if (v112.i64[1] >= v113[0])
        {
          unint64_t v62 = 0xAAAAAAAAAAAAAAABLL * ((v112.i64[1] - v112.i64[0]) >> 3);
          unint64_t v63 = v62 + 1;
          if (v62 + 1 > 0xAAAAAAAAAAAAAAALL) {
            abort();
          }
          if (0x5555555555555556LL * ((v113[0] - v112.i64[0]) >> 3) > v63) {
            unint64_t v63 = 0x5555555555555556LL * ((v113[0] - v112.i64[0]) >> 3);
          }
          if (0xAAAAAAAAAAAAAAABLL * ((v113[0] - v112.i64[0]) >> 3) >= 0x555555555555555LL) {
            unint64_t v64 = 0xAAAAAAAAAAAAAAALL;
          }
          else {
            unint64_t v64 = v63;
          }
          int v134 = v113;
          if (v64) {
            int v65 = (char *)sub_10023F114((uint64_t)v113, v64);
          }
          else {
            int v65 = 0LL;
          }
          uint64_t v66 = &v65[24 * v62];
          __int128 v67 = *(_OWORD *)__p;
          *((void *)v66 + 2) = v111;
          *(_OWORD *)uint64_t v66 = v67;
          __p[1] = 0LL;
          uint64_t v111 = 0LL;
          __p[0] = 0LL;
          uint64_t v68 = v112.i64[1];
          uint64_t v69 = v112.i64[0];
          if (v112.i64[1] == v112.i64[0])
          {
            int64x2_t v72 = vdupq_n_s64(v112.u64[1]);
            int v70 = &v65[24 * v62];
          }

          else
          {
            int v70 = &v65[24 * v62];
            do
            {
              __int128 v71 = *(_OWORD *)(v68 - 24);
              *((void *)v70 - 1) = *(void *)(v68 - 8);
              *(_OWORD *)(v70 - 24) = v71;
              v70 -= 24;
              *(void *)(v68 - 16) = 0LL;
              *(void *)(v68 - _Block_object_dispose(va, 8) = 0LL;
              *(void *)(v68 - 24) = 0LL;
              v68 -= 24LL;
            }

            while (v68 != v69);
            int64x2_t v72 = v112;
          }

          unsigned int v61 = v66 + 24;
          v112.i64[0] = (uint64_t)v70;
          v112.i64[1] = (uint64_t)(v66 + 24);
          int64x2_t v132 = v72;
          uint64_t v73 = v113[0];
          v113[0] = &v65[24 * v64];
          uint64_t v133 = v73;
          __int128 v131 = (void **)v72.i64[0];
          sub_10023F158((uint64_t)&v131);
          v112.i64[1] = (uint64_t)v61;
          if (SHIBYTE(v111) < 0)
          {
            operator delete(__p[0]);
            unsigned int v61 = (char *)v112.i64[1];
          }
        }

        else
        {
          __int128 v60 = *(_OWORD *)__p;
          *(void *)(v112.i64[1] + 16) = v111;
          *uint64_t v59 = v60;
          unsigned int v61 = (char *)v59 + 24;
          v112.i64[1] = (uint64_t)v59 + 24;
        }

        if ((unint64_t)v61 >= v113[0])
        {
          int v75 = sub_10023EFAC((char **)&v112, &v120);
        }

        else
        {
          if (SHIBYTE(v121) < 0)
          {
            sub_100024238(v61, (void *)v120, *((unint64_t *)&v120 + 1));
          }

          else
          {
            __int128 v74 = v120;
            *((void *)v61 + 2) = v121;
            *(_OWORD *)unsigned int v61 = v74;
          }

          int v75 = v61 + 24;
        }

        v112.i64[1] = (uint64_t)v75;
        if (v8)
        {
          if (*(char *)(v128 + 191) < 0)
          {
            sub_100024238(__p, *(void **)(v128 + 168), *(void *)(v128 + 176));
          }

          else
          {
            *(_OWORD *)__int128 __p = *(_OWORD *)(v128 + 168);
            uint64_t v111 = *(void *)(v128 + 184);
          }
        }

        else
        {
          sub_10002418C(__p, "");
        }

        int v76 = (_OWORD *)v112.i64[1];
        if (v112.i64[1] >= v113[0])
        {
          unint64_t v79 = 0xAAAAAAAAAAAAAAABLL * ((v112.i64[1] - v112.i64[0]) >> 3);
          unint64_t v80 = v79 + 1;
          if (v79 + 1 > 0xAAAAAAAAAAAAAAALL) {
            abort();
          }
          if (0x5555555555555556LL * ((v113[0] - v112.i64[0]) >> 3) > v80) {
            unint64_t v80 = 0x5555555555555556LL * ((v113[0] - v112.i64[0]) >> 3);
          }
          if (0xAAAAAAAAAAAAAAABLL * ((v113[0] - v112.i64[0]) >> 3) >= 0x555555555555555LL) {
            unint64_t v81 = 0xAAAAAAAAAAAAAAALL;
          }
          else {
            unint64_t v81 = v80;
          }
          int v134 = v113;
          if (v81) {
            __int16 v82 = (char *)sub_10023F114((uint64_t)v113, v81);
          }
          else {
            __int16 v82 = 0LL;
          }
          uint64_t v83 = &v82[24 * v79];
          __int128 v84 = *(_OWORD *)__p;
          *((void *)v83 + 2) = v111;
          *(_OWORD *)uint64_t v83 = v84;
          __p[1] = 0LL;
          uint64_t v111 = 0LL;
          __p[0] = 0LL;
          uint64_t v85 = v112.i64[1];
          uint64_t v86 = v112.i64[0];
          if (v112.i64[1] == v112.i64[0])
          {
            int64x2_t v89 = vdupq_n_s64(v112.u64[1]);
            uint64_t v87 = &v82[24 * v79];
          }

          else
          {
            uint64_t v87 = &v82[24 * v79];
            do
            {
              __int128 v88 = *(_OWORD *)(v85 - 24);
              *((void *)v87 - 1) = *(void *)(v85 - 8);
              *(_OWORD *)(v87 - 24) = v88;
              v87 -= 24;
              *(void *)(v85 - 16) = 0LL;
              *(void *)(v85 - _Block_object_dispose(va, 8) = 0LL;
              *(void *)(v85 - 24) = 0LL;
              v85 -= 24LL;
            }

            while (v85 != v86);
            int64x2_t v89 = v112;
          }

          int v78 = v83 + 24;
          v112.i64[0] = (uint64_t)v87;
          v112.i64[1] = (uint64_t)(v83 + 24);
          int64x2_t v132 = v89;
          uint64_t v90 = v113[0];
          v113[0] = &v82[24 * v81];
          uint64_t v133 = v90;
          __int128 v131 = (void **)v89.i64[0];
          sub_10023F158((uint64_t)&v131);
          v112.i64[1] = (uint64_t)v78;
          if (SHIBYTE(v111) < 0)
          {
            operator delete(__p[0]);
            int v78 = (char *)v112.i64[1];
          }
        }

        else
        {
          __int128 v77 = *(_OWORD *)__p;
          *(void *)(v112.i64[1] + 16) = v111;
          *int v76 = v77;
          int v78 = (char *)v76 + 24;
          v112.i64[1] = (uint64_t)v76 + 24;
        }

        if ((unint64_t)v78 >= v113[0])
        {
          __int16 v92 = sub_10023EFAC((char **)&v112, &v118);
        }

        else
        {
          if (SHIBYTE(v119) < 0)
          {
            sub_100024238(v78, (void *)v118, *((unint64_t *)&v118 + 1));
          }

          else
          {
            __int128 v91 = v118;
            *((void *)v78 + 2) = v119;
            *(_OWORD *)int v78 = v91;
          }

          __int16 v92 = v78 + 24;
        }

        v112.i64[1] = (uint64_t)v92;
        if ((unint64_t)v92 >= v113[0])
        {
          int v94 = sub_10023EFAC((char **)&v112, (__int128 *)v116);
        }

        else
        {
          if (SHIBYTE(v117) < 0)
          {
            sub_100024238(v92, v116[0], (unint64_t)v116[1]);
          }

          else
          {
            __int128 v93 = *(_OWORD *)v116;
            *((void *)v92 + 2) = v117;
            *(_OWORD *)__int16 v92 = v93;
          }

          int v94 = v92 + 24;
        }

        v112.i64[1] = (uint64_t)v94;
        if ((unint64_t)v94 >= v113[0])
        {
          uint64_t v96 = sub_10023EFAC((char **)&v112, (__int128 *)v114);
        }

        else
        {
          if (SHIBYTE(v115) < 0)
          {
            sub_100024238(v94, v114[0], (unint64_t)v114[1]);
          }

          else
          {
            __int128 v95 = *(_OWORD *)v114;
            *((void *)v94 + 2) = v115;
            *(_OWORD *)int v94 = v95;
          }

          uint64_t v96 = v94 + 24;
        }

        v112.i64[1] = (uint64_t)v96;
        if (v8 && 0xAAAAAAAAAAAAAAABLL * ((v129 - v128) >> 3) >= 0xF)
        {
          uint64_t v97 = (__int128 *)(v128 + 264);
          if ((unint64_t)v96 >= v113[0])
          {
            uint64_t v99 = sub_10023EFAC((char **)&v112, v97);
          }

          else
          {
            if (*(char *)(v128 + 287) < 0)
            {
              sub_100024238(v96, *(void **)(v128 + 264), *(void *)(v128 + 272));
            }

            else
            {
              __int128 v98 = *v97;
              *((void *)v96 + 2) = *(void *)(v128 + 280);
              *(_OWORD *)uint64_t v96 = v98;
            }

            uint64_t v99 = v96 + 24;
          }

          v112.i64[1] = (uint64_t)v99;
          uint64_t v100 = (__int128 *)(v128 + 288);
          if ((unint64_t)v99 >= v113[0])
          {
            uint64_t v102 = sub_10023EFAC((char **)&v112, v100);
          }

          else
          {
            if (*(char *)(v128 + 311) < 0)
            {
              sub_100024238(v99, *(void **)(v128 + 288), *(void *)(v128 + 296));
            }

            else
            {
              __int128 v101 = *v100;
              *((void *)v99 + 2) = *(void *)(v128 + 304);
              *(_OWORD *)uint64_t v99 = v101;
            }

            uint64_t v102 = v99 + 24;
          }

          v112.i64[1] = (uint64_t)v102;
          uint64_t v103 = (__int128 *)(v128 + 312);
          if ((unint64_t)v102 >= v113[0])
          {
            uint64_t v105 = sub_10023EFAC((char **)&v112, v103);
          }

          else
          {
            if (*(char *)(v128 + 335) < 0)
            {
              sub_100024238(v102, *(void **)(v128 + 312), *(void *)(v128 + 320));
            }

            else
            {
              __int128 v104 = *v103;
              *((void *)v102 + 2) = *(void *)(v128 + 328);
              *(_OWORD *)uint64_t v102 = v104;
            }

            uint64_t v105 = v102 + 24;
          }

          v112.i64[1] = (uint64_t)v105;
          uint64_t v106 = (__int128 *)(v128 + 336);
          if ((unint64_t)v105 >= v113[0])
          {
            uint64_t v96 = sub_10023EFAC((char **)&v112, v106);
          }

          else
          {
            if (*(char *)(v128 + 359) < 0)
            {
              sub_100024238(v105, *(void **)(v128 + 336), *(void *)(v128 + 344));
            }

            else
            {
              __int128 v107 = *v106;
              *((void *)v105 + 2) = *(void *)(v128 + 352);
              *(_OWORD *)uint64_t v105 = v107;
            }

            uint64_t v96 = v105 + 24;
          }

          v112.i64[1] = (uint64_t)v96;
        }

        uint64_t v108 = *(void *)(a1 + 40);
        memset(v109, 0, sizeof(v109));
        sub_10024062C( (char *)v109,  (__int128 *)v112.i64[0],  (__int128 *)v96,  0xAAAAAAAAAAAAAAABLL * ((uint64_t)&v96[-v112.i64[0]] >> 3));
        sub_1003D8FB8(v108, (uint64_t)v109);
        __int128 v131 = v109;
        sub_100024304(&v131);
        __int128 v131 = (void **)&v112;
        sub_100024304(&v131);
        if (SHIBYTE(v115) < 0) {
          operator delete(v114[0]);
        }
        if (SHIBYTE(v117) < 0) {
          operator delete(v116[0]);
        }
        if (SHIBYTE(v119) < 0) {
          operator delete((void *)v118);
        }
        if (SHIBYTE(v121) < 0) {
          operator delete((void *)v120);
        }
        if (SHIBYTE(v123) < 0) {
          operator delete((void *)v122);
        }
        if (SHIBYTE(v125) < 0) {
          operator delete((void *)v124);
        }
        if (SHIBYTE(v127) < 0) {
          operator delete((void *)__dst);
        }
        __int128 v131 = (void **)&v128;
        sub_100024304(&v131);
        goto LABEL_226;
      }
    }

    if (*(char *)(v128 + 143) < 0)
    {
      sub_100024238(__p, *(void **)(v128 + 120), *(void *)(v128 + 128));
    }

    else
    {
      *(_OWORD *)__int128 __p = *(_OWORD *)(v128 + 120);
      uint64_t v111 = *(void *)(v128 + 136);
    }

    goto LABEL_117;
  }

  if (os_log_type_enabled((os_log_t)qword_1008F7600, OS_LOG_TYPE_ERROR)) {
    sub_100683708();
  }
LABEL_226:
}

void sub_1004814D0( _Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, char *a13, uint64_t a14, int a15, __int16 a16, char a17, char a18, uint64_t a19, char a20, uint64_t a21, uint64_t a22, uint64_t a23, void *__p, uint64_t a25, int a26, __int16 a27, char a28, char a29, uint64_t a30, void *a31, uint64_t a32, int a33, __int16 a34, char a35, char a36, uint64_t a37, void *a38, uint64_t a39, int a40, __int16 a41, char a42, char a43, uint64_t a44, void *a45, uint64_t a46, int a47, __int16 a48, char a49, char a50,uint64_t a51,void *a52,uint64_t a53,int a54,__int16 a55,char a56,char a57)
{
  a13 = &a20;
  sub_100024304((void ***)&a13);
  if (a29 < 0) {
    operator delete(__p);
  }
  if (a36 < 0) {
    operator delete(a31);
  }
  if (a43 < 0) {
    operator delete(a38);
  }
  if (a50 < 0) {
    operator delete(a45);
  }
  if (a57 < 0) {
    operator delete(a52);
  }
  *(void *)(v58 - 1sub_10023DF50(v3 + 76) = v58 - 144;
  sub_100024304((void ***)(v58 - 176));

  _Unwind_Resume(a1);
}

void sub_1004816FC(id a1, BTCloudDevice *a2, NSError *a3)
{
  char v4 = a2;
  id v5 = a3;
  if (v4)
  {
    id v6 = (void *)objc_claimAutoreleasedReturnValue(-[BTCloudDevice nickname](v4, "nickname"));
    id v7 = [v6 length];

    if (v7)
    {
      int v8 = (os_log_s *)(id)qword_1008F7600;
      if (os_log_type_enabled(v8, OS_LOG_TYPE_DEFAULT))
      {
        id v9 = (void *)objc_claimAutoreleasedReturnValue(-[BTCloudDevice bluetoothAddress](v4, "bluetoothAddress"));
        id v10 = (void *)objc_claimAutoreleasedReturnValue(-[BTCloudDevice nickname](v4, "nickname"));
        *(_DWORD *)std::string buf = 138412546;
        char v19 = v9;
        __int16 v20 = 2112;
        char v21 = v10;
        _os_log_impl( (void *)&_mh_execute_header,  v8,  OS_LOG_TYPE_DEFAULT,  "Cloud: Magic Settings Update Fetch Name for device: %@ - %@",  buf,  0x16u);
      }

      uint64_t v11 = sub_1002E9258();
      id v12 = objc_claimAutoreleasedReturnValue(-[BTCloudDevice bluetoothAddress](v4, "bluetoothAddress"));
      sub_10002418C(v16, (char *)[v12 UTF8String]);
      id v13 = objc_claimAutoreleasedReturnValue(-[BTCloudDevice nickname](v4, "nickname"));
      sub_10002418C(__p, (char *)[v13 UTF8String]);
      (*(void (**)(uint64_t, void **, void **))(*(void *)v11 + 176LL))(v11, v16, __p);
      if (v15 < 0) {
        operator delete(__p[0]);
      }

      if (v17 < 0) {
        operator delete(v16[0]);
      }
    }
  }
}

void sub_1004818B4( _Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, void *__p, uint64_t a10, int a11, __int16 a12, char a13, char a14, void *a15, uint64_t a16, int a17, __int16 a18, char a19, char a20)
{
  _Unwind_Resume(a1);
}

void sub_1004819F0( _Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, id a10)
{
}

void sub_100481A04(id a1, BTCloudSoundProfileRecord *a2, NSError *a3)
{
  char v4 = a2;
  id v5 = a3;
  id v6 = (os_log_s *)qword_1008F7588;
  BOOL v7 = os_log_type_enabled((os_log_t)qword_1008F7588, OS_LOG_TYPE_DEFAULT);
  if (!v4 || v5)
  {
    if (v7)
    {
      int v12 = 138412290;
      id v13 = v5;
      _os_log_impl( (void *)&_mh_execute_header,  v6,  OS_LOG_TYPE_DEFAULT,  "BTAudioCloudSyncMonitor: Unable to fetch Spatial Profile:Error: %@",  (uint8_t *)&v12,  0xCu);
    }

    if (qword_1008D60F0 == -1) {
      goto LABEL_14;
    }
    goto LABEL_16;
  }

  if (v7)
  {
    int v12 = 138412546;
    id v13 = 0LL;
    __int16 v14 = 2112;
    char v15 = v4;
    _os_log_impl( (void *)&_mh_execute_header,  v6,  OS_LOG_TYPE_DEFAULT,  "BTAudioCloudSyncMonitor: fetched Spatial Profile:Error: %@ Profile %@",  (uint8_t *)&v12,  0x16u);
  }

  int v8 = (void *)objc_claimAutoreleasedReturnValue(-[BTCloudSoundProfileRecord soundProfileData](v4, "soundProfileData"));
  BOOL v9 = v8 == 0LL;

  if (v9)
  {
    if (qword_1008D60F0 == -1)
    {
LABEL_14:
      sub_1004B3BB0((uint64_t)off_1008D60E8, 0LL);
      goto LABEL_15;
    }

void sub_100481BC0(_Unwind_Exception *a1)
{
  char v4 = v3;

  _Unwind_Resume(a1);
}

void sub_100481DB4(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_100481ED0(_Unwind_Exception *a1)
{
  id v5 = v4;

  _Unwind_Resume(a1);
}

void sub_100482120(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_100482390( _Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, id location)
{
  _Unwind_Resume(a1);
}

void sub_1004823EC(uint64_t a1)
{
  uint64_t v2 = objc_autoreleasePoolPush();
  id WeakRetained = objc_loadWeakRetained((id *)(a1 + 32));
  id v4 = WeakRetained;
  if (WeakRetained)
  {
    uint64_t v5 = WeakRetained[30];
    id v6 = (os_log_s *)qword_1008F7588;
    BOOL v7 = os_log_type_enabled((os_log_t)qword_1008F7588, OS_LOG_TYPE_DEFAULT);
    if (v5)
    {
      if (v7)
      {
        *(_WORD *)std::string buf = 0;
        _os_log_impl( (void *)&_mh_execute_header,  v6,  OS_LOG_TYPE_DEFAULT,  "Already Registered cloudkit.xpc service",  buf,  2u);
      }
    }

    else
    {
      if (v7)
      {
        *(_WORD *)std::string buf = 0;
        _os_log_impl((void *)&_mh_execute_header, v6, OS_LOG_TYPE_DEFAULT, "Register cloudkit.xpc service", buf, 2u);
      }

      xpc_connection_t mach_service = xpc_connection_create_mach_service( "com.apple.bluetooth.cloudkit.xpc",  *((dispatch_queue_t *)v4 + 43),  1uLL);
      BOOL v9 = (void *)*((void *)v4 + 30);
      *((void *)v4 + 3sub_100414D2C(qword_1008F72C0, 0) = mach_service;

      id v10 = (_xpc_connection_s *)*((void *)v4 + 30);
      if (v10)
      {
        handler[0] = _NSConcreteStackBlock;
        handler[1] = 3221225472LL;
        handler[2] = sub_100482580;
        handler[3] = &unk_10087FB40;
        id v12 = v4;
        xpc_connection_set_event_handler(v10, handler);
        xpc_connection_resume(*((xpc_connection_t *)v4 + 30));
      }

      else if (os_log_type_enabled((os_log_t)qword_1008F7588, OS_LOG_TYPE_ERROR))
      {
        sub_1006837FC();
      }
    }
  }

  objc_autoreleasePoolPop(v2);
}

void sub_10048255C( _Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, void *a14)
{
  _Unwind_Resume(a1);
}

id sub_100482580(uint64_t a1, uint64_t a2)
{
  return [*(id *)(a1 + 32) _handleConnectionEvent:a2];
}

void sub_100482830(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_10048287C(id a1, NSString *a2, NSDictionary *a3, BOOL *a4)
{
  uint64_t v5 = a2;
  id v6 = a3;
  BOOL v7 = (os_log_s *)qword_1008F7588;
  if (os_log_type_enabled((os_log_t)qword_1008F7588, OS_LOG_TYPE_DEFAULT))
  {
    int v8 = 138412546;
    BOOL v9 = v5;
    __int16 v10 = 2112;
    uint64_t v11 = v6;
    _os_log_impl( (void *)&_mh_execute_header,  v7,  OS_LOG_TYPE_DEFAULT,  "statedump:        Address: %@ - Dict: %@",  (uint8_t *)&v8,  0x16u);
  }
}

void sub_100482A7C(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_10048312C( _Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, int a14, __int16 a15, char a16, char a17, uint64_t a18, uint64_t a19, uint64_t a20, uint64_t a21, void *__p, uint64_t a23, int a24, __int16 a25, char a26, char a27)
{
  _Unwind_Resume(a1);
}

void sub_100483658(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_100483870( _Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, void *a14, void *a15, void *a16, void *a17, uint64_t a18, char a19, uint64_t a20, uint64_t a21, uint64_t a22, uint64_t a23, id a24)
{
  _Block_object_dispose(&a19, 8);
  _Unwind_Resume(a1);
}

uint64_t sub_1004838C8(uint64_t result, uint64_t a2)
{
  *(void *)(result + 4sub_100414D2C(qword_1008F72C0, 0) = *(void *)(a2 + 40);
  *(void *)(a2 + 4sub_100414D2C(qword_1008F72C0, 0) = 0LL;
  return result;
}

void sub_1004838D8(uint64_t a1)
{
}

void sub_1004838E0(uint64_t a1)
{
  uint64_t v2 = objc_claimAutoreleasedReturnValue( [*(id *)(a1 + 32) _generateCloudPairingIDWithResponse:*(void *)(a1 + 40) localKeys:*(void *)(a1 + 48) from:*(void *)(a1 + 56) forProtocolID:*(void *)(a1 + 64)]);
  uint64_t v3 = *(void *)(*(void *)(a1 + 72) + 8LL);
  id v4 = *(void **)(v3 + 40);
  *(void *)(v3 + 4sub_100414D2C(qword_1008F72C0, 0) = v2;
}

void sub_1004851F8( _Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, void *a11, void *a12, uint64_t a13, uint64_t a14, void *a15, void *a16, void *a17, void *a18, void *a19, void *a20, void *a21, uint64_t a22, uint64_t a23, uint64_t a24, void *a25, uint64_t a26, uint64_t a27, void *a28, uint64_t a29, uint64_t a30, void *a31, uint64_t a32, uint64_t a33, void *a34, uint64_t a35, uint64_t a36, uint64_t a37, uint64_t a38, uint64_t a39, void *__p, uint64_t a41, uint64_t a42, uint64_t a43, uint64_t a44, uint64_t a45, uint64_t a46, uint64_t a47, uint64_t a48, uint64_t a49, unsigned int *a50)
{
  if (a50) {
    sub_1002CD254(a50);
  }

  _Unwind_Resume(a1);
}

void *sub_1004856D8(void *a1)
{
  *a1 = &off_10089A548;
  uint64_t v2 = (unsigned int *)a1[1];
  if (v2) {
    sub_1002CD254(v2);
  }
  return a1;
}

void sub_10048582C(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_100485908(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_100485D98( _Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, void *a15)
{
  _Block_object_dispose((const void *)(v18 - 128), 8);
  _Unwind_Resume(a1);
}

void sub_100485E10(uint64_t a1, void *a2, void *a3, _BYTE *a4)
{
  id v8 = a2;
  BOOL v9 = (void *)objc_claimAutoreleasedReturnValue([a3 objectForKeyedSubscript:@"IDSLocalID"]);
  unsigned int v10 = [v9 isEqualToString:*(void *)(a1 + 32)];

  if (v10)
  {
    objc_storeStrong((id *)(*(void *)(*(void *)(a1 + 40) + 8LL) + 40LL), a2);
    uint64_t v11 = (os_log_s *)qword_1008F7588;
    if (os_log_type_enabled((os_log_t)qword_1008F7588, OS_LOG_TYPE_DEFAULT))
    {
      uint64_t v12 = *(void *)(*(void *)(*(void *)(a1 + 40) + 8LL) + 40LL);
      int v13 = 138412290;
      uint64_t v14 = v12;
      _os_log_impl((void *)&_mh_execute_header, v11, OS_LOG_TYPE_DEFAULT, "MUC - RSA found: %@", (uint8_t *)&v13, 0xCu);
    }

    *a4 = 1;
  }
}

void sub_100485F2C(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_10048610C( _Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, int a10, __int16 a11, char a12, char a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, id a18, uint64_t a19, char a20, uint64_t a21, uint64_t a22, uint64_t a23, uint64_t a24, id a25)
{
  _Block_object_dispose(&a20, 8);
  _Unwind_Resume(a1);
}

void sub_100486154(uint64_t a1, void *a2, void *a3, _BYTE *a4)
{
  id v8 = a2;
  BOOL v9 = (void *)objc_claimAutoreleasedReturnValue([a3 objectForKeyedSubscript:@"IDSLocalID"]);
  unsigned int v10 = [v9 isEqualToString:*(void *)(a1 + 32)];

  if (v10)
  {
    objc_storeStrong((id *)(*(void *)(*(void *)(a1 + 40) + 8LL) + 40LL), a2);
    uint64_t v11 = (os_log_s *)qword_1008F7588;
    if (os_log_type_enabled((os_log_t)qword_1008F7588, OS_LOG_TYPE_DEFAULT))
    {
      uint64_t v12 = *(void *)(*(void *)(*(void *)(a1 + 40) + 8LL) + 40LL);
      int v13 = 138412290;
      uint64_t v14 = v12;
      _os_log_impl((void *)&_mh_execute_header, v11, OS_LOG_TYPE_DEFAULT, "MUC - RSA found: %@", (uint8_t *)&v13, 0xCu);
    }

    *a4 = 1;
  }
}

void sub_100486270(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_10048637C( _Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, void *a13, uint64_t a14, char a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, id a20)
{
  _Block_object_dispose(&a15, 8);
  _Unwind_Resume(a1);
}

void sub_1004863A8(uint64_t a1, void *a2, void *a3)
{
  id v5 = a2;
  id v6 = a3;
  if ([v5 isEqualToString:*(void *)(a1 + 32)])
  {
    uint64_t v7 = objc_claimAutoreleasedReturnValue([v6 objectForKeyedSubscript:@"IRK"]);
    uint64_t v8 = *(void *)(*(void *)(a1 + 40) + 8LL);
    BOOL v9 = *(void **)(v8 + 40);
    *(void *)(v8 + 4sub_100414D2C(qword_1008F72C0, 0) = v7;

    unsigned int v10 = (os_log_s *)(id)qword_1008F7588;
    if (os_log_type_enabled(v10, OS_LOG_TYPE_DEFAULT))
    {
      uint64_t v11 = (void *)objc_claimAutoreleasedReturnValue([v6 objectForKeyedSubscript:@"IRK"]);
      uint64_t v12 = *(void *)(a1 + 32);
      int v13 = 138412546;
      uint64_t v14 = v11;
      __int16 v15 = 2112;
      uint64_t v16 = v12;
      _os_log_impl( (void *)&_mh_execute_header,  v10,  OS_LOG_TYPE_DEFAULT,  "MUC - IRK: %@ found for RSA: %@",  (uint8_t *)&v13,  0x16u);
    }
  }
}

void sub_1004864E0(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_1004866F8( _Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, int a10, __int16 a11, char a12, char a13)
{
  _Unwind_Resume(a1);
}

void sub_100486A2C(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, ...)
{
  _Unwind_Resume(a1);
}

void sub_100486B98( _Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, void *a15, uint64_t a16, char a17, uint64_t a18, uint64_t a19, uint64_t a20, uint64_t a21, id a22)
{
  _Block_object_dispose(&a17, 8);
  _Unwind_Resume(a1);
}

void sub_100486BD4(uint64_t a1)
{
  uint64_t v2 = objc_claimAutoreleasedReturnValue([*(id *)(a1 + 32) _getPairedDeviceForIDSIdentifier:*(void *)(a1 + 40)]);
  uint64_t v3 = *(void *)(*(void *)(a1 + 48) + 8LL);
  id v4 = *(void **)(v3 + 40);
  *(void *)(v3 + 4sub_100414D2C(qword_1008F72C0, 0) = v2;
}

void sub_10048724C( _Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, void *a11, void *a12, uint64_t a13, uint64_t a14, uint64_t a15, void *a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20, uint64_t a21, void *__p, uint64_t a23, int a24, __int16 a25, char a26, char a27, uint64_t a28, uint64_t a29, uint64_t a30, uint64_t a31, uint64_t a32, uint64_t a33, uint64_t a34, uint64_t a35, uint64_t a36, uint64_t a37, uint64_t a38, uint64_t a39, void *a40)
{
  _Block_object_dispose((const void *)(v43 - 160), 8);
  _Unwind_Resume(a1);
}

void sub_10048735C(uint64_t a1, void *a2, void *a3, _BYTE *a4)
{
  id v8 = a2;
  BOOL v9 = (void *)objc_claimAutoreleasedReturnValue([a3 objectForKeyedSubscript:@"IDSLocalID"]);
  unsigned int v10 = [v9 isEqualToString:*(void *)(a1 + 32)];

  if (v10)
  {
    objc_storeStrong((id *)(*(void *)(*(void *)(a1 + 40) + 8LL) + 40LL), a2);
    uint64_t v11 = (os_log_s *)qword_1008F7588;
    if (os_log_type_enabled((os_log_t)qword_1008F7588, OS_LOG_TYPE_DEFAULT))
    {
      uint64_t v12 = *(void *)(*(void *)(*(void *)(a1 + 40) + 8LL) + 40LL);
      int v13 = 138412290;
      uint64_t v14 = v12;
      _os_log_impl((void *)&_mh_execute_header, v11, OS_LOG_TYPE_DEFAULT, "MUC - RSA found: %@", (uint8_t *)&v13, 0xCu);
    }

    *a4 = 1;
  }
}

void sub_100487478(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_100487658(_Unwind_Exception *a1)
{
  id v5 = v2;

  _Unwind_Resume(a1);
}

uint64_t sub_1004878A8(uint64_t a1)
{
  *(void *)a1 = &off_10089A468;
  sub_10032E424(a1 + 16, *(void **)(a1 + 24));
  return a1;
}

void sub_1004878DC(void **a1)
{
  *a1 = &off_10089A468;
  sub_10032E424((uint64_t)(a1 + 2), a1[3]);
  operator delete(a1);
}

void sub_100487910(id a1)
{
  uint64_t v1 = operator new(0xEB0uLL);
  sub_10061991C();
  qword_1008D5F18 = (uint64_t)v1;
}

void sub_100487940(_Unwind_Exception *a1)
{
}

void sub_100487954(id a1)
{
  uint64_t v1 = operator new(0xF8uLL);
  sub_1003EC784((uint64_t)v1);
  off_1008D60B8 = v1;
}

void sub_100487984(_Unwind_Exception *a1)
{
}

void sub_100487998(id a1)
{
  uint64_t v1 = operator new(0x138uLL);
  sub_1003FE3E0((uint64_t)v1);
  off_1008D5F48 = v1;
}

void sub_1004879C8(_Unwind_Exception *a1)
{
}

void sub_1004879DC(id a1)
{
  uint64_t v1 = operator new(0x2C8uLL);
  sub_100213DA8();
  off_1008D60D8 = v1;
}

void sub_100487A0C(_Unwind_Exception *a1)
{
}

void sub_100487A20(id a1)
{
  uint64_t v1 = operator new(0x4A8uLL);
  sub_100499870();
  off_1008D60E8 = v1;
}

void sub_100487A50(_Unwind_Exception *a1)
{
}

void sub_100487A64(id a1)
{
  uint64_t v1 = operator new(0x128uLL);
  sub_1005C69F8();
  off_1008D5F28 = v1;
}

void sub_100487A94(_Unwind_Exception *a1)
{
}

void sub_100487AA8(void *__p)
{
  void *__p = &off_10089A548;
  uint64_t v2 = (unsigned int *)__p[1];
  if (v2) {
    sub_1002CD254(v2);
  }
  operator delete(__p);
}

void sub_100487AE0(id a1)
{
  uint64_t v1 = operator new(0x42C0uLL);
  sub_10056DFB4();
  off_1008D6280 = v1;
}

void sub_100487B10(_Unwind_Exception *a1)
{
}

uint64_t sub_100487B24(uint64_t result, uint64_t a2, uint64_t a3, float a4)
{
  *(float *)a3 = a4;
  *(void *)(a3 + 4) = 1752392040LL;
  *(_WORD *)(a3 + 12) = 2081;
  *(void *)(a3 + 14) = result;
  *(_WORD *)(a3 + 22) = 2112;
  *(void *)(a3 + 24) = a2;
  return result;
}

void sub_100487B50(void *a1@<X0>, const char *a2@<X3>, uint8_t *a3@<X4>, os_log_s *a4@<X8>)
{
}

uint64_t sub_100487B60()
{
  if (qword_1008F1078 != -1) {
    dispatch_once(&qword_1008F1078, &stru_10089A578);
  }
  return byte_1008F1080;
}

void sub_100487BA0(id a1)
{
  byte_1008F1080 = NSClassFromString(@"_CDContextualKeyPath") != 0LL;
}

uint64_t sub_100487BCC()
{
  if (qword_1008F1088 != -1) {
    dispatch_once(&qword_1008F1088, &stru_10089A598);
  }
  return byte_1008F1090;
}

void sub_100487C0C(id a1)
{
  byte_1008F1090 = NSClassFromString(@"CMDeviceOrientationManager") != 0LL;
}

BOOL sub_100487C38()
{
  return &__CTServerConnectionRegisterBlockForNotification != 0LL;
}

BOOL sub_100487C4C()
{
  return &_ct_green_tea_logger_create != 0LL;
}

uint64_t sub_100487C60()
{
  if (qword_1008F1098 != -1) {
    dispatch_once(&qword_1008F1098, &stru_10089A5B8);
  }
  return byte_1008F10A0;
}

void sub_100487CA0(id a1)
{
  byte_1008F10A0 = NSClassFromString(@"MAAsset") != 0LL;
}

BOOL sub_100487CCC()
{
  return &_WiFiManagerClientCreate != 0LL;
}

BOOL sub_100487CE0()
{
  return &_NETRBClientCreate != 0LL;
}

BOOL sub_100487CF4()
{
  return &_PLLogRegisteredEvent != 0LL;
}

BOOL sub_100487D08()
{
  return &_BYSetupAssistantNeedsToRun != 0LL;
}

BOOL sub_100487D1C()
{
  return &TCCAccessRequest != 0LL;
}

uint64_t sub_100487D30()
{
  if (qword_1008F10A8 != -1) {
    dispatch_once(&qword_1008F10A8, &stru_10089A5D8);
  }
  return byte_1008F10B0;
}

void sub_100487D70(id a1)
{
  byte_1008F10B0 = NSClassFromString(@"VTPreferences") != 0LL;
}

uint64_t sub_100487D9C()
{
  if (qword_1008F10B8 != -1) {
    dispatch_once(&qword_1008F10B8, &stru_10089A5F8);
  }
  return byte_1008F10C0;
}

void sub_100487DDC(id a1)
{
  byte_1008F10C0 = NSClassFromString(@"AWDServerConnection") != 0LL;
}

uint64_t sub_100487E08()
{
  if (qword_1008F10C8 != -1) {
    dispatch_once(&qword_1008F10C8, &stru_10089A618);
  }
  return byte_1008F10D0;
}

void sub_100487E48(id a1)
{
  Class v1 = NSClassFromString(@"BMDeviceBluetoothGATTSession");
  byte_1008F10D0 = v1 != 0LL;
  if (!v1 && os_log_type_enabled((os_log_t)qword_1008F7758, OS_LOG_TYPE_ERROR)) {
    sub_100683BF8();
  }
}

uint64_t sub_100487EA8()
{
  if (qword_1008F10D8 != -1) {
    dispatch_once(&qword_1008F10D8, &stru_10089A638);
  }
  return byte_1008F10E0;
}

void sub_100487EE8(id a1)
{
  Class v1 = NSClassFromString(@"BMDeviceBluetoothPowerEnabled");
  byte_1008F10E0 = v1 != 0LL;
  if (!v1 && os_log_type_enabled((os_log_t)qword_1008F7758, OS_LOG_TYPE_ERROR)) {
    sub_100683C24();
  }
}

uint64_t sub_100487F48()
{
  if (qword_1008F10E8 != -1) {
    dispatch_once(&qword_1008F10E8, &stru_10089A658);
  }
  return byte_1008F10F0;
}

void sub_100487F88(id a1)
{
  byte_1008F10F0 = NSClassFromString(@"BTCloudSoundProfileRecord") != 0LL;
}

uint64_t sub_100487FB4()
{
  if (qword_1008F10F8 != -1) {
    dispatch_once(&qword_1008F10F8, &stru_10089A678);
  }
  return byte_1008F1100;
}

void sub_100487FF4(id a1)
{
  byte_1008F1100 = NSClassFromString(@"NWConnection") != 0LL;
}

uint64_t sub_100488020()
{
  if (qword_1008F1108 != -1) {
    dispatch_once(&qword_1008F1108, &stru_10089A698);
  }
  return byte_1008F1110;
}

void sub_100488060(id a1)
{
  Class v1 = NSClassFromString(@"RDEstimate");
  byte_1008F1110 = v1 != 0LL;
  if (!v1 && os_log_type_enabled((os_log_t)qword_1008F7758, OS_LOG_TYPE_ERROR)) {
    sub_100683C50();
  }
}

void *sub_1004880C0(void *a1)
{
  uint64_t v2 = (void *)sub_10041BFD4((uint64_t)a1, "HandsfreeService", 1);
  *uint64_t v2 = off_10089A6C8;
  sub_100242DC4(v2 + 41);
  a1[49] = 0LL;
  sub_100242DC4(a1 + 50);
  a1[58] = 0LL;
  a1[59] = 0LL;
  a1[62] = 0LL;
  a1[63] = 0LL;
  a1[60] = 0LL;
  a1[61] = a1 + 62;
  sub_100242DC4(a1 + 64);
  if (qword_1008D9030 != -1) {
    dispatch_once(&qword_1008D9030, &stru_10089A7B8);
  }
  uint64_t v3 = off_1008D9028;
  a1[49] = off_1008D9028;
  sub_10041C264((uint64_t)a1, (uint64_t)v3);
  return a1;
}

void sub_100488180(_Unwind_Exception *a1)
{
  uint64_t v6 = v4;
  sub_100242E28(v6);
  sub_10023BF24(v1 + 488, *v5);
  id v8 = *(void **)(v1 + 464);
  if (v8)
  {
    *(void *)(v1 + 472) = v8;
    operator delete(v8);
  }

  sub_100242E28(v3);
  sub_100242E28(v2);
  sub_10041C0C4(v1);
  _Unwind_Resume(a1);
}

uint64_t sub_1004881EC(uint64_t a1, uint64_t a2)
{
  __int128 v15 = xmmword_1006C3380;
  memset(v17, 0, sizeof(v17));
  char v14 = 0;
  int v13 = 0;
  if (sub_1003D518C(a2))
  {
    if (sub_1003D2E50(a2, &v15, 4u)) {
      int v4 = 4;
    }
    else {
      int v4 = 1;
    }
    goto LABEL_24;
  }

  BOOL v5 = sub_1003E235C(a2, v17, &v14);
  if (v14) {
    BOOL v6 = v5;
  }
  else {
    BOOL v6 = 0;
  }
  if (v6)
  {
    BOOL v7 = sub_10011B978((unsigned __int8 *)v17, 4382, &v13) == 0;
LABEL_20:
    int v9 = v7;
    int v4 = 4 * v9;
    goto LABEL_24;
  }

  if (qword_1008D5F40 != -1) {
    dispatch_once(&qword_1008D5F40, &stru_10089A7D8);
  }
  if (!sub_1003B1864((uint64_t)off_1008D5F38, a2))
  {
    BOOL v7 = sub_1003D0070(a2, 1u) == 4;
    goto LABEL_20;
  }

  LODWORD(v12) = 0;
  sub_1003D0454(a2, &v12);
  if ((v12 & 0x1F00) == 0x400) {
    int v8 = 4;
  }
  else {
    int v8 = 1;
  }
  if ((_DWORD)v12) {
    int v4 = v8;
  }
  else {
    int v4 = 0;
  }
LABEL_24:
  unsigned int v10 = *(_DWORD *)(a1 + 32);
  uint64_t v16 = 0LL;
  sub_1000B0400((uint64_t)&v16);
  *(void *)&__int128 v12 = (int)v16;
  *((void *)&v12 + 1) = SWORD2(v16);
  return sub_1003D1FC4(a2, v10, v4, &v12, 0);
}

uint64_t sub_1004883AC(uint64_t a1, uint64_t a2, _BYTE *a3)
{
  int v10 = 0;
  __int128 v11 = xmmword_1006C3380;
  memset(v12, 0, sizeof(v12));
  char v9 = 0;
  int v8 = 0;
  *a3 = 0;
  if (sub_1003D518C(a2))
  {
    uint64_t result = sub_1003D2E50(a2, &v11, 4u);
    if ((result & 1) == 0) {
      return result;
    }
LABEL_17:
    *a3 = 1;
    return result;
  }

  if (sub_1003E235C(a2, v12, &v9))
  {
    if (v9)
    {
      uint64_t result = sub_10011B978((unsigned __int8 *)v12, 4382, &v8);
      if (!(_DWORD)result) {
        goto LABEL_17;
      }
    }
  }

  uint64_t result = sub_1003D0454(a2, &v10);
  if ((_DWORD)result && (v10 & 0x200000) != 0)
  {
    int v6 = v10 & 0x1F00;
    BOOL v7 = (v10 & 0xFC) != 0x1C && v6 == 1024;
    if (v7 || (v10 & 0x1FFC) == 0x118 || v6 == 1792 && ((v10 & 0xF4) == 4 || (v10 & 0xF8) == 0x10)) {
      goto LABEL_17;
    }
  }

  return result;
}

uint64_t sub_100488508(uint64_t a1, uint64_t a2, unsigned int a3, uint64_t a4, unsigned int a5)
{
  int v5 = a4;
  uint64_t result = sub_10041E4F4(a1, (unsigned __int8 *)a2, a3, a4, a5);
  if (!v5)
  {
    if (sub_1003D7BB0(a2)) {
      sub_1003D7C3C(a2);
    }
    if (*(_BYTE *)(a2 + 576)) {
      *(_WORD *)(a2 + 5sub_10023DF50(v3 + 76) = 0;
    }
    if (qword_1008D5F40 != -1) {
      dispatch_once(&qword_1008D5F40, &stru_10089A7D8);
    }
    uint64_t result = sub_1003B1864((uint64_t)off_1008D5F38, a2);
    if ((_DWORD)result)
    {
      if (qword_1008D5F40 != -1) {
        dispatch_once(&qword_1008D5F40, &stru_10089A7D8);
      }
      return sub_1003B2408((uint64_t)off_1008D5F38, a2);
    }
  }

  return result;
}

uint64_t sub_1004885D0(uint64_t a1, uint64_t a2, char *__s1, _BYTE *a4)
{
  if (__s1 && a4)
  {
    if (!strncmp(__s1, "com.apple.BT.VoiceCommand.State", 0x1FuLL))
    {
      uint64_t result = *(void *)(a1 + 392);
      if (!result) {
        return result;
      }
      sub_100464D30(result, a2, (uint64_t)a4);
    }

    else if (!strncmp(__s1, "BT_KEY_ALLOW_SCO_FOR_TBT", 0x18uLL))
    {
      sub_1003DA3E0(a2, *a4 != 0);
    }

    return 0LL;
  }

  else
  {
    int v8 = (os_log_s *)qword_1008F7598;
    if (os_log_type_enabled((os_log_t)qword_1008F7598, OS_LOG_TYPE_ERROR)) {
      sub_100683C7C(v8, v9, v10, v11, v12, v13, v14, v15);
    }
    return 1LL;
  }

uint64_t sub_100488698(uint64_t a1, unint64_t a2, char *__s1, __int16 *a4)
{
  if (!__s1 || !a4)
  {
    uint64_t v9 = (os_log_s *)qword_1008F7598;
    if (os_log_type_enabled((os_log_t)qword_1008F7598, OS_LOG_TYPE_ERROR)) {
      sub_100683C7C(v9, v10, v11, v12, v13, v14, v15, v16);
    }
    return 1LL;
  }

  if (!strncmp(__s1, "BT_KEY_HFP_AG_ECNR_STATE", 0x18uLL))
  {
    uint64_t v18 = sub_10045D7CC(*(void *)(a1 + 392), a2);
    if (v18)
    {
      int v8 = sub_100207404(v18 + 400);
      goto LABEL_19;
    }

    return 1LL;
  }

  if (!strncmp(__s1, "BT_KEY_SIRI_EYESFREE_MODE", 0x19uLL))
  {
    if (qword_1008D9108 != -1) {
      dispatch_once(&qword_1008D9108, &stru_10089A7F8);
    }
    int v8 = sub_1002672E4(qword_1008D9100, a2);
    goto LABEL_19;
  }

  if (!strncmp(__s1, "BT_KEY_SIRI_AUDIO_STATE", 0x17uLL))
  {
    if (qword_1008D9108 != -1) {
      dispatch_once(&qword_1008D9108, &stru_10089A7F8);
    }
    int v8 = sub_100267374(qword_1008D9100, a2);
    goto LABEL_19;
  }

  if (strncmp(__s1, "BT_KEY_ALLOW_SCO_FOR_TBT", 0x18uLL)) {
    return 1LL;
  }
  int v8 = sub_1003DA3D8(a2);
LABEL_19:
  int v19 = v8;
  uint64_t result = 0LL;
  if (v19) {
    __int16 v20 = 49;
  }
  else {
    __int16 v20 = 48;
  }
  *a4 = v20;
  return result;
}

void sub_100488818(uint64_t a1)
{
  uint64_t v1 = (void *)sub_10048882C(a1);
  operator delete(v1);
}

uint64_t sub_10048882C(uint64_t a1)
{
  *(void *)a1 = off_10089A6C8;
  sub_100242E28(a1 + 512);
  sub_10023BF24(a1 + 488, *(void **)(a1 + 496));
  uint64_t v2 = *(void **)(a1 + 464);
  if (v2)
  {
    *(void *)(a1 + 472) = v2;
    operator delete(v2);
  }

  sub_100242E28(a1 + 400);
  sub_100242E28(a1 + 328);
  return sub_10041C0C4(a1);
}

void sub_10048888C(id a1)
{
  uint64_t v1 = operator new(0x350uLL);
  sub_100461C70();
  off_1008D9028 = v1;
}

void sub_1004888BC(_Unwind_Exception *a1)
{
}

void sub_1004888D0(id a1)
{
  uint64_t v1 = operator new(0x118uLL);
  sub_1003ADFF0((uint64_t)v1);
  off_1008D5F38 = v1;
}

void sub_100488900(_Unwind_Exception *a1)
{
}

void sub_100488914(id a1)
{
  uint64_t v1 = operator new(0x98uLL);
  sub_100266BF8();
  qword_1008D9100 = (uint64_t)v1;
}

void sub_100488944(_Unwind_Exception *a1)
{
}

void sub_100488A84( _Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, objc_super a9)
{
  a9.super_class = (Class)&OBJC_CLASS___BTVCLinkScanner;
  -[_Unwind_Exception dealloc](&a9, "dealloc");
  _Unwind_Resume(a1);
}

void sub_100488BF4(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_100488C70( _Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, id obj)
{
  _Unwind_Resume(a1);
}

void sub_100488DF0( _Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, void *a17, void *a18)
{
  _Unwind_Resume(a1);
}

void sub_100488E24(uint64_t a1)
{
}

double sub_100488EB0(uint64_t a1)
{
  uint64_t v2 = *(void **)(*(void *)(a1 + 32) + 48LL);
  if (v2)
  {
    uint64_t v3 = v2;
    dispatch_source_cancel(v3);
    uint64_t v4 = *(void *)(a1 + 32);
    int v5 = *(void **)(v4 + 48);
    *(void *)(v4 + 4_Block_object_dispose(va, 8) = 0LL;
  }

  double result = *(double *)(a1 + 40);
  *(double *)(*(void *)(a1 + 32) + 224LL) = result;
  return result;
}

id sub_100488FAC(uint64_t a1)
{
  *(_BYTE *)(*(void *)(a1 + 32) + 9LL) = 1;
  return [*(id *)(a1 + 32) _activateWithCompletion:*(void *)(a1 + 40)];
}

void sub_1004892AC(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

id sub_100489378(uint64_t a1)
{
  return [*(id *)(a1 + 32) _scanEnable:*(unsigned __int8 *)(a1 + 40)];
}

void sub_100489578( _Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, id location)
{
}

void sub_1004895A4(uint64_t a1)
{
  id WeakRetained = objc_loadWeakRetained((id *)(a1 + 32));
  uint64_t v2 = (os_log_s *)qword_1008F7710;
  if (os_log_type_enabled((os_log_t)qword_1008F7710, OS_LOG_TYPE_DEFAULT))
  {
    int v3 = 136315138;
    uint64_t v4 = "-[BTVCLinkScanner _scanEnable:]_block_invoke";
    _os_log_impl((void *)&_mh_execute_header, v2, OS_LOG_TYPE_DEFAULT, "%s startRetrier\n", (uint8_t *)&v3, 0xCu);
  }

  [WeakRetained _restartIfNeeded:1];
}

void sub_100489664(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

id sub_1004896D4(uint64_t a1)
{
  return [*(id *)(a1 + 32) _invalidate];
}

void sub_1004898C8(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_100489998(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

uint64_t sub_1004899A8(uint64_t result)
{
  *(_BYTE *)(*(void *)(result + 32) + 72LL) = 1;
  return result;
}

_BYTE *sub_1004899B8(uint64_t a1)
{
  *(_BYTE *)(*(void *)(a1 + 32) + 72LL) = 0;
  double result = *(_BYTE **)(a1 + 32);
  if (result[9])
  {
    if (!result[11]) {
      return [result _restartIfNeeded];
    }
  }

  return result;
}

void sub_100489A90(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

_BYTE *sub_100489AAC(uint64_t a1)
{
  double result = *(_BYTE **)(a1 + 32);
  if (!result[72]) {
    return [result _restartIfNeeded];
  }
  return result;
}

id sub_10048A010(uint64_t a1)
{
  return [*(id *)(a1 + 32) _timeoutTimerFired];
}

void sub_10048A1D0(_Unwind_Exception *exception_object)
{
}

void sub_10048A2A8(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_10048A3B0(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_10048A554(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_10048A658(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_10048A7C8(uint64_t *a1, uint64_t a2)
{
  BOOL v7 = 0;
  sub_100272194(*a1, &v7);
  if (!v7 || ((int v4 = *(_DWORD *)(a1[1] + 8)) != 0 ? (v5 = v4 == 2) : (v5 = 1), v5))
  {
    int v6 = (pthread_t *)operator new(0xF0uLL);
    sub_1004C3AE0(v6, a2);
LABEL_8:
    a1[3] = (uint64_t)v6;
LABEL_9:
    sub_1002432DC(v6);
    return;
  }

  if (v4 == 1)
  {
    int v6 = (pthread_t *)operator new(0x100uLL);
    sub_1004C4118(v6, a2);
    goto LABEL_8;
  }

  int v6 = (pthread_t *)a1[3];
  if (v6) {
    goto LABEL_9;
  }
}

void sub_10048A870(_Unwind_Exception *a1)
{
}

uint64_t sub_10048A888(uint64_t a1)
{
  uint64_t v1 = *(unsigned __int8 **)(a1 + 8);
  uint64_t v2 = *(void *)(a1 + 16);
  if (v2 == 2)
  {
    if (*(_BYTE *)a1 != 5) {
      return 0LL;
    }
    int v5 = *v1;
    if (v5 != 214)
    {
      if (v5 != 213) {
        return 0LL;
      }
      int v4 = v1[1];
      goto LABEL_11;
    }

    int v7 = v1[1];
LABEL_17:
    if (v7 == 52 || v7 == 10) {
      return 1LL;
    }
    if (v7) {
      return 0LL;
    }
    return 2LL;
  }

  if (v2 != 3 || *v1 != 83) {
    return 0LL;
  }
  int v3 = v1[1];
  if (v3 == 214)
  {
    int v7 = v1[2];
    goto LABEL_17;
  }

  if (v3 != 213) {
    return 0LL;
  }
  int v4 = v1[2];
LABEL_11:
  uint64_t result = 1LL;
  if (v4 <= 11)
  {
    if (v4)
    {
      if (v4 == 7) {
        return result;
      }
      return 0LL;
    }

    return 2LL;
  }

  if (v4 != 12 && v4 != 15) {
    return 0LL;
  }
  return result;
}

uint64_t sub_10048A948(uint64_t a1)
{
  uint64_t v2 = (void *)sub_100213C20(a1, 10);
  *uint64_t v2 = off_10089A8A0;
  v2[32] = off_10089A998;
  v2[33] = off_10089A9D0;
  v2[34] = off_10089A9F8;
  v2[35] = &off_10089AA38;
  v2[36] = off_10089AA50;
  v2[37] = off_10089AA80;
  v2[38] = &off_10089AB30;
  v2[39] = off_10089AB48;
  sub_100242DC4(v2 + 40);
  *(_DWORD *)(a1 + 384) = 0;
  *(void *)(a1 + 424) = 0LL;
  *(_OWORD *)(a1 + 392) = 0u;
  *(_OWORD *)(a1 + 40_Block_object_dispose(va, 8) = 0u;
  sub_100242DC4(a1 + 448);
  sub_100243040((pthread_cond_t *)(a1 + 512));
  *(void *)(a1 + 56_Block_object_dispose(va, 8) = 0LL;
  *(void *)(a1 + 592) = 0LL;
  *(void *)(a1 + 584) = 0LL;
  *(_DWORD *)(a1 + 56sub_100414D2C(qword_1008F72C0, 0) = 0;
  *(_WORD *)(a1 + 5sub_100242FAC(v30 - 64) = 0;
  *(void *)(a1 + 5sub_10023DF50(v3 + 76) = a1 + 584;
  return a1;
}

void sub_10048AA0C(_Unwind_Exception *a1)
{
  uint64_t v4 = v3;
  sub_100242E28(v4);

  int v6 = *(void **)(v1 + 392);
  if (v6)
  {
    *(void *)(v1 + 40sub_100414D2C(qword_1008F72C0, 0) = v6;
    operator delete(v6);
  }

  sub_100242E28(v2);
  sub_100213D34(v1);
  _Unwind_Resume(a1);
}

uint64_t sub_10048AA68(uint64_t a1)
{
  *(void *)a1 = off_10089A8A0;
  *(void *)(a1 + 256) = off_10089A998;
  *(void *)(a1 + 2sub_100242FAC(v30 - 64) = off_10089A9D0;
  *(void *)(a1 + 272) = off_10089A9F8;
  *(void *)(a1 + 28sub_100414D2C(qword_1008F72C0, 0) = &off_10089AA38;
  *(void *)(a1 + 28_Block_object_dispose(va, 8) = off_10089AA50;
  *(void *)(a1 + 2sub_100242FAC(v5 - 96) = off_10089AA80;
  *(void *)(a1 + 304) = &off_10089AB30;
  *(void *)(a1 + 312) = off_10089AB48;
  sub_100492D98(a1 + 576, *(void **)(a1 + 584));

  sub_1002430A8(a1 + 512);
  sub_100242E28(a1 + 448);

  uint64_t v2 = *(void **)(a1 + 392);
  if (v2)
  {
    *(void *)(a1 + 40sub_100414D2C(qword_1008F72C0, 0) = v2;
    operator delete(v2);
  }

  sub_100242E28(a1 + 320);
  return sub_100213D34(a1);
}

uint64_t sub_10048AB14(uint64_t a1)
{
  return sub_10048AA68(a1 - 264);
}

uint64_t sub_10048AB1C(uint64_t a1)
{
  return sub_10048AA68(a1 - 272);
}

void sub_10048AB24(uint64_t a1)
{
  uint64_t v1 = (void *)sub_10048AA68(a1);
  operator delete(v1);
}

void sub_10048AB38(uint64_t a1)
{
  uint64_t v1 = (void *)sub_10048AA68(a1 - 264);
  operator delete(v1);
}

void sub_10048AB50(uint64_t a1)
{
  uint64_t v1 = (void *)sub_10048AA68(a1 - 272);
  operator delete(v1);
}

uint64_t sub_10048AB68(uint64_t a1)
{
  os_log_t v2 = os_log_create("com.apple.bluetooth", "HIDProfileDispatch");
  uint64_t v3 = *(void **)(a1 + 416);
  *(void *)(a1 + 416) = v2;

  *(void *)(a1 + 4sub_100242FAC(v11 - 32) = os_signpost_id_make_with_pointer(*(os_log_t *)(a1 + 416), (const void *)a1);
  os_log_t v4 = os_log_create("com.apple.bluetooth", "HIDProfileMutex");
  int v5 = *(void **)(a1 + 424);
  *(void *)(a1 + 424) = v4;

  *(void *)(a1 + 44sub_100414D2C(qword_1008F72C0, 0) = os_signpost_id_make_with_pointer(*(os_log_t *)(a1 + 424), (const void *)a1);
  if (qword_1008D67A8 != -1) {
    dispatch_once(&qword_1008D67A8, &stru_10089ACC0);
  }
  sub_10052AB64(off_1008D67A0, a1 + 272);
  if (qword_1008D5F10 != -1) {
    dispatch_once(&qword_1008D5F10, &stru_10089ACE0);
  }
  sub_100594810((uint64_t)off_1008D5F08, a1 + 296, 0);
  if (qword_1008D5F60 != -1) {
    dispatch_once(&qword_1008D5F60, &stru_10089AD00);
  }
  sub_100008EA4(qword_1008D5F58 + 40, a1 + 312);
  uint64_t v6 = sub_1002E8D54();
  sub_1003CBF90(v6 + 728, a1 + 280);
  uint64_t v7 = sub_1002E8D54();
  (*(void (**)(uint64_t, uint64_t))(*(void *)v7 + 152LL))(v7, a1 + 562);
  uint64_t v8 = sub_1002E8D54();
  sub_1001FC8A8(v8 + 368, a1 + 288);
  uint64_t v9 = sub_1002E6BF0();
  if ((*(unsigned int (**)(uint64_t))(*(void *)v9 + 280LL))(v9))
  {
    uint64_t v10 = sub_1002E8D54();
    sub_1004922F8(v10 + 1168, a1 + 304);
    uint64_t v11 = sub_1002E8D54();
    (*(void (**)(uint64_t, uint64_t))(*(void *)v11 + 200LL))(v11, a1 + 563);
  }

  else
  {
    uint64_t v12 = (os_log_s *)qword_1008F7730;
    if (os_log_type_enabled((os_log_t)qword_1008F7730, OS_LOG_TYPE_DEFAULT))
    {
      *(_WORD *)uint64_t v14 = 0;
      _os_log_impl( (void *)&_mh_execute_header,  v12,  OS_LOG_TYPE_DEFAULT,  "Low Latency Gaming not eligible for this device",  v14,  2u);
    }
  }

  return 0LL;
}

uint64_t sub_10048AD54()
{
  char v2 = 0;
  sub_100242CA4(&v2);
  uint64_t v0 = sub_1000F8DF0(&dword_1006C33B8, off_10089AB78);
  sub_100242CD0(&v2);
  if ((_DWORD)v0)
  {
    if (os_log_type_enabled((os_log_t)qword_1008F7730, OS_LOG_TYPE_ERROR)) {
      sub_100683DE4();
    }
    uint64_t v0 = 1LL;
  }

  sub_100242CD8(&v2);
  return v0;
}