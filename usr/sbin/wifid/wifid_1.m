void sub_100086CB0(void *a1, uint64_t a2, uint64_t a3)
{
  void *v5;
  const void *v6;
  CFArrayRef v7;
  CFArrayRef v8;
  CFIndex Count;
  CFIndex v10;
  CFIndex i;
  const void *ValueAtIndex;
  uint64_t v13;
  uint64_t v14;
  void *v15;
  void *v16;
  CFIndex v17;
  void *v18;
  void *v19;
  void block[5];
  v5 = objc_autoreleasePoolPush();
  if (qword_100219F60) {
    [qword_100219F60 WFLog:@"Enter: %s:%d\n" message:3];
  }
  objc_autoreleasePoolPop(v5);
  *(_BYTE *)(a3 + 2136) = 1;
  pthread_mutex_lock(&stru_100218F08);
  pthread_mutex_lock(&stru_100218F48);
  dispatch_assert_queue_V2(*(dispatch_queue_t *)(a3 + 32));
  v6 = (const void *)sub_10003BEDC((uint64_t)a1);
  v7 = sub_10006C77C((CFArrayRef)a3);
  v8 = v7;
  if (v7)
  {
    Count = CFArrayGetCount(v7);
    if (Count >= 1)
    {
      v10 = Count;
      for (i = 0LL; i != v10; ++i)
      {
        ValueAtIndex = CFArrayGetValueAtIndex(v8, i);
        v13 = sub_10003BEDC((uint64_t)ValueAtIndex);
        if (v13)
        {
          v14 = sub_10004CE2C(v13);
          if (v14) {
            [*(id *)(a3 + 2144) addFaultEvent:24 forInterface:v14];
          }
        }
      }
    }
  }

  else
  {
    v19 = objc_autoreleasePoolPush();
    if (qword_100219F60) {
      [qword_100219F60 WFLog:@"__WiFiManagerSoftErrorDextCrashedEvent: failed to get device managers"];
    }
    objc_autoreleasePoolPop(v19);
  }

  *(_BYTE *)(a3 + 1576) = 0;
  block[0] = _NSConcreteStackBlock;
  block[1] = 3221225472LL;
  block[2] = sub_10008B8BC;
  block[3] = &unk_1001E2620;
  block[4] = a3;
  dispatch_async((dispatch_queue_t)qword_100219F80, block);
  if (v8) {
    CFRelease(v8);
  }
  sub_1000F5F00((uint64_t)a1);
  sub_1000D0428((uint64_t)a1);
  sub_1000CD264((uint64_t)a1);
  sub_1000CEBA4((uint64_t)a1);
  CFSetApplyFunction(*(CFSetRef *)(a3 + 136), (CFSetApplierFunction)sub_10008B8F0, a1);
  CFSetRemoveValue(*(CFMutableSetRef *)(a3 + 104), a1);
  CFSetRemoveValue(*(CFMutableSetRef *)(a3 + 96), v6);
  v15 = objc_autoreleasePoolPush();
  v16 = (void *)qword_100219F60;
  if (qword_100219F60)
  {
    v17 = CFSetGetCount(*(CFSetRef *)(a3 + 104));
    objc_msgSend( v16,  "WFLog:message:",  3,  "Finished Clean up %s:%d devm_count:%ld dev_count:%ld\n",  "__WiFiManagerDeviceRemovedCallback",  7007,  v17,  CFSetGetCount(*(CFSetRef *)(a3 + 96)));
  }

  objc_autoreleasePoolPop(v15);
  pthread_mutex_unlock(&stru_100218F48);
  pthread_mutex_unlock(&stru_100218F08);
  sub_100085AAC(*(const __SCDynamicStore **)(a3 + 72), 0LL, (const __CFArray *)a3);
  v18 = objc_autoreleasePoolPush();
  if (qword_100219F60) {
    [qword_100219F60 WFLog:@"Exit: %s:%d %ld\n" message:3];
  }
  objc_autoreleasePoolPop(v18);
}

uint64_t sub_100086F54(uint64_t a1, uint64_t a2)
{
  return *(unsigned __int8 *)(a2 + 2136);
}

void sub_100086F5C(void *a1, uint64_t a2, uint64_t a3)
{
  v6[0] = a3;
  v6[1] = 0xAAAAAAAA0000002FLL;
  v6[2] = 0LL;
  uint64_t v7 = 0LL;
  CFSetApplyFunction(*(CFSetRef *)(a3 + 104), (CFSetApplierFunction)sub_1000662CC, v6);
  int v5 = v7;
  *(_DWORD *)(a3 + 324) = v7;
  if (v5 == 1)
  {
    sub_10006570C(a3, 1LL, 1LL, 0LL);
    sub_10006B818(a3, *(_DWORD *)(a3 + 1816), 0LL, 0);
  }

  CFSetApplyFunction(*(CFSetRef *)(a3 + 136), (CFSetApplierFunction)sub_10008B8F4, a1);
}

void sub_100086FF8(uint64_t a1, uint64_t a2, uint64_t a3, const __CFDictionary *a4)
{
  CFAbsoluteTime Current = CFAbsoluteTimeGetCurrent();
  CFDateRef v8 = CFDateCreate(kCFAllocatorDefault, Current);
  v9 = *(const void **)(a3 + 1992);
  if (v9)
  {
    CFRelease(v9);
    *(void *)(a3 + 1992) = 0LL;
  }

  if (!a4)
  {
LABEL_65:
    if (!v8) {
      return;
    }
    goto LABEL_66;
  }

  Value = (void *)CFDictionaryGetValue(a4, @"LINK_CHANGED_NETWORK");
  sub_1000D5088(a1, 0LL);
  if (!Value)
  {
    *(_BYTE *)(a3 + 1944) = 0;
    uint64_t v16 = sub_1000D8D08(a1);
    if (v16)
    {
      v17 = (void *)v16;
      objc_autoreleasePoolPop(objc_autoreleasePoolPush());
      objc_autoreleasePoolPop(objc_autoreleasePoolPush());
      if (sub_100098E6C(v17))
      {
        v18 = objc_autoreleasePoolPush();
        if (qword_100219F60) {
          [(id)qword_100219F60 WFLog:4, "%s: removing ONE TIME PASSWORD for network %@", "__WiFiManagerDeviceLinkCallback", sub_100095BC8(v17) message];
        }
        objc_autoreleasePoolPop(v18);
        sub_100099D38(v17);
      }

      v19 = (const __CFNumber *)CFDictionaryGetValue(a4, @"LINKDOWN_REASON_CODE");
      v20 = v19;
      int valuePtr = 0;
      if (v19) {
        CFNumberGetValue(v19, kCFNumberIntType, &valuePtr);
      }
      *(_BYTE *)(a3 + 2088) = 0;
      if (sub_10009DF44((uint64_t)v17))
      {
        LOBYTE(context) = 0;
        v21 = (const __CFNumber *)CFDictionaryGetValue(a4, @"LINK_DEBOUNCE_STATE");
        if (v21)
        {
          CFNumberGetValue(v21, kCFNumberSInt8Type, &context);
          if ((_BYTE)context)
          {
            *(CFAbsoluteTime *)(a3 + 2048) = CFAbsoluteTimeGetCurrent();
            *(_DWORD *)(a3 + 2064) = valuePtr;
            if (CFDictionaryGetValue(a4, @"LINKDOWN_SUBREASON_CODE")) {
              CFNumberGetValue(v20, kCFNumberIntType, (void *)(a3 + 2068));
            }
            *(_BYTE *)(a3 + 2088) = 1;
          }
        }
      }

      CFIndex v45 = 0LL;
      CFIndex context = -1LL;
      v22 = (const __SCPreferences *)sub_100072F14((void *)a3, @"List of known networks");
      if (v22)
      {
        v23 = v22;
        if (sub_10003A25C(v22))
        {
          v24 = (void *)sub_10003AFF4((uint64_t)"__WiFiManagerUpdateNetworkUsageTime");
          v25 = (const __CFArray *)sub_100063560(a3);
          if (v25
            && (v26 = v25, sub_1000730D4(*(_DWORD *)(a3 + 312), v25, v17, &context, &v45), context != -1)
            && (ValueAtIndex = (CFDictionaryRef *)CFArrayGetValueAtIndex(v26, context)) != 0LL
            && (v28 = ValueAtIndex, (unint64_t v29 = sub_10009A1FC(ValueAtIndex)) != 0))
          {
            v30 = (const __CFDate *)v29;
            v43 = v8;
            v31 = v24;
            double v32 = sub_10009A340((uint64_t)v28);
            double v33 = CFAbsoluteTimeGetCurrent();
            double v34 = v32 + v33 - CFDateGetAbsoluteTime(v30);
            sub_10009A35C((uint64_t)v28, v34);
            v35 = objc_autoreleasePoolPush();
            if (qword_100219F60) {
              [(id)qword_100219F60 WFLog:3, "Total connection time to %@ %f", sub_100095BC8(v17), *(void *)&v34 message];
            }
            objc_autoreleasePoolPop(v35);
            int v36 = sub_10007332C(a3, v26);
            sub_100071D74(a3, v28, 0);
            v24 = v31;
            CFDateRef v8 = v43;
          }

          else
          {
            int v36 = 0;
          }

          sub_10003A310(v23, v36);

          if (v36) {
            sub_100061B50(v37, 2LL, a3);
          }
        }
      }
    }

    if (*(void *)(a3 + 120) == 3348380076LL) {
      sub_1000F7038(a1, 1);
    }
    goto LABEL_64;
  }

  *(_BYTE *)(a3 + 1944) = 1;
  if (*(_BYTE *)(a3 + 1280) || sub_10009DF44((uint64_t)Value))
  {
    *(_BYTE *)(a3 + 1280) = 0;
    dispatch_source_set_timer(*(dispatch_source_t *)(a3 + 1304), 0xFFFFFFFFFFFFFFFFLL, 0xFFFFFFFFFFFFFFFFLL, 0LL);
    CFIndex context = a3;
    unint64_t v47 = 0xAAAAAA0000000042LL;
    unint64_t v48 = 0xAAAAAAAA00000000LL;
    CFSetApplyFunction(*(CFSetRef *)(a3 + 104), (CFSetApplierFunction)sub_1000662CC, &context);
    sub_10008BA70(a3, 1);
    kdebug_trace(731381772LL, 0LL, 0LL, 0LL, 0LL);
    v11 = objc_autoreleasePoolPush();
    if (qword_100219F60) {
      [qword_100219F60 WFLog:@"__WiFiManagerDeviceLinkCallback: LINK_UP: so disabled the carplay mode ###STOP_CAAJ"];
    }
    objc_autoreleasePoolPop(v11);
  }

  if (*(_BYTE *)(a3 + 1328))
  {
    dispatch_source_set_timer(*(dispatch_source_t *)(a3 + 1344), 0xFFFFFFFFFFFFFFFFLL, 0xFFFFFFFFFFFFFFFFLL, 0LL);
    *(_BYTE *)(a3 + 1328) = 0;
    v12 = objc_autoreleasePoolPush();
    if (qword_100219F60) {
      [qword_100219F60 WFLog:@"__WiFiManagerDeviceLinkCallback: LINK_UP: so disabled the companion assisted mode ###STOP_CAAJ"];
    }
    objc_autoreleasePoolPop(v12);
    CFIndex context = *(void *)(a3 + 1336);
    unint64_t v47 = *(void *)(a3 + 1352);
    sub_100037AC4((uint64_t)&context, Value);
  }

  if (sub_100078748(a3, Value))
  {
    v13 = objc_autoreleasePoolPush();
    if (qword_100219F60) {
      [(id)qword_100219F60 WFLog:3, "%s: %@ is joined first time, so now enable it", "__WiFiManagerDeviceLinkCallback", sub_100095BC8(Value) message];
    }
    objc_autoreleasePoolPop(v13);
    sub_10009E934(Value, 0);
    sub_100077498(a3, Value, 1u);
  }

  if (_os_feature_enabled_impl("WiFiManager", "LinkUpEventAfter4way")
    && (sub_100096E90((uint64_t)Value) || sub_100096D08((const __CFDictionary *)Value)))
  {
    v14 = objc_autoreleasePoolPush();
    if (qword_100219F60) {
      [qword_100219F60 WFLog:@"__WiFiManagerDeviceLinkCallback: Hold off dispatching client link up event until 4 way completes."];
    }
    objc_autoreleasePoolPop(v14);
    int v15 = 0;
  }

  else
  {
    int v15 = 1;
  }

  if (*(_BYTE *)(a3 + 2088))
  {
    LOBYTE(context) = 0;
    v38 = (const __CFNumber *)CFDictionaryGetValue(a4, @"LINK_DEBOUNCE_RESULT");
    if (v38)
    {
      CFNumberGetValue(v38, kCFNumberSInt8Type, &context);
      BOOL v39 = (_BYTE)context != 0;
    }

    else
    {
      BOOL v39 = 0;
    }

    *(_BYTE *)(a3 + 2073) = v39;
  }

  if (*(void *)(a3 + 120) == 3348380076LL)
  {
    BOOL v40 = sub_10009E054((uint64_t)Value);
    sub_1000F7038(a1, v40);
  }

  CFDictionaryRef v41 = sub_100012CEC((uint64_t)Value);
  if (v41)
  {
    CFDictionaryRef v42 = v41;
    CFDictionaryReplaceValue(a4, @"LINK_CHANGED_NETWORK", v41);
    CFRelease(v42);
    if ((v15 & 1) != 0)
    {
LABEL_64:
      CFIndex context = a3;
      unint64_t v47 = a1;
      unint64_t v48 = (unint64_t)a4;
      CFSetApplyFunction(*(CFSetRef *)(a3 + 136), (CFSetApplierFunction)sub_10008BCAC, &context);
      goto LABEL_65;
    }
  }

  else if (v15)
  {
    goto LABEL_64;
  }

  *(void *)(a3 + 1992) = CFDictionaryCreateCopy(kCFAllocatorDefault, a4);
  if (v8) {
LABEL_66:
  }
    CFRelease(v8);
}

void sub_10008766C(uint64_t a1, uint64_t a2, uint64_t a3, CFDictionaryRef theDict, void *a5)
{
  if (!a3 || !theDict) {
    return;
  }
  v10 = CFDictionaryGetValue(theDict, @"autoJoinNetwork");
  if (v10)
  {
    CFDictionaryRef v11 = sub_100012CEC((uint64_t)v10);
    if (v11)
    {
      CFDictionaryRef v12 = v11;
      CFDictionaryReplaceValue(theDict, @"autoJoinNetwork", v11);
      CFRelease(v12);
    }
  }

  value = 0LL;
  CFDictionaryGetValueIfPresent(theDict, @"autoJoinStatus", (const void **)&value);
  if (value && CFStringCompare((CFStringRef)value, @"autoJoinAlreadyAssoicated", 0LL) == kCFCompareEqualTo)
  {
    v14 = sub_10007D140((const __CFArray *)a3);
    int v15 = (const __CFString *)sub_100095BC8(v14);
    if (v15)
    {
      if (*(_BYTE *)(a3 + 1328))
      {
        uint64_t v16 = *(const __CFString **)(a3 + 1336);
        if (v16)
        {
          if (CFStringCompare(v15, v16, 0LL) == kCFCompareEqualTo)
          {
            dispatch_source_set_timer( *(dispatch_source_t *)(a3 + 1344),  0xFFFFFFFFFFFFFFFFLL,  0xFFFFFFFFFFFFFFFFLL,  0LL);
            *(_BYTE *)(a3 + 1328) = 0;
            v17 = objc_autoreleasePoolPush();
            if (qword_100219F60) {
              [qword_100219F60 WFLog:@"__WiFiManagerDeviceAutoJoinCallback: already associated, so disabled the companion assisted mode ###STOP_CAAJ"];
            }
            objc_autoreleasePoolPop(v17);
          }
        }
      }
    }

    MutableCFDictionaryRef Copy = CFDictionaryCreateMutableCopy(kCFAllocatorDefault, 0LL, theDict);
    CFDictionarySetValue(MutableCopy, @"autoJoinStatus", @"autoJoinSuccess");
    CFDictionaryRef Copy = CFDictionaryCreateCopy(kCFAllocatorDefault, MutableCopy);
    if (MutableCopy) {
      CFRelease(MutableCopy);
    }
    if (v14) {
      CFRelease(v14);
    }
    if (Copy) {
      CFRelease(Copy);
    }
  }

  else
  {
    context[0] = a1;
    context[1] = theDict;
    CFSetApplyFunction(*(CFSetRef *)(a3 + 136), (CFSetApplierFunction)sub_10008BD00, context);
  }

  if ((_os_feature_enabled_impl("CoreWiFi", "UnifiedAutoJoin") & 1) == 0)
  {
    if ([value isEqualToString:@"autoJoinAssociating"]
      || ([value isEqualToString:@"autoJoinWaiting"] & 1) != 0
      || [value isEqualToString:@"autoJoinEAPNeedsUserFix"])
    {
      [+[WiFiXPCManager sharedXPCManager](WiFiXPCManager, "sharedXPCManager") autoJoinUpdatedWithState:3 interfaceName:a2];
    }

    else
    {
      if ([value isEqualToString:@"autoJoinAssociationFailure"]
        || [value isEqualToString:@"autoJoinNetworkNotFound"]
        || [value isEqualToString:@"autoJoinAborted"])
      {
        id v20 = +[WiFiXPCManager sharedXPCManager](&OBJC_CLASS___WiFiXPCManager, "sharedXPCManager");
        uint64_t v21 = 0LL;
      }

      else
      {
        id v20 = +[WiFiXPCManager sharedXPCManager](&OBJC_CLASS___WiFiXPCManager, "sharedXPCManager");
        uint64_t v21 = 1LL;
      }

      [v20 autoJoinEndedWithResult:v21 interfaceName:a2];
    }
  }

void sub_100087A2C(uint64_t a1, int a2, uint64_t a3, CFDictionaryRef theDict)
{
  if (a3 && theDict)
  {
    Value = CFDictionaryGetValue(theDict, @"userJoinNetwork");
    if (Value)
    {
      CFDictionaryRef v8 = sub_100012CEC((uint64_t)Value);
      if (v8)
      {
        CFDictionaryRef v9 = v8;
        CFDictionaryReplaceValue(theDict, @"userJoinNetwork", v8);
        CFRelease(v9);
      }
    }

    v10[0] = a1;
    v10[1] = theDict;
    CFSetApplyFunction(*(CFSetRef *)(a3 + 136), (CFSetApplierFunction)sub_10008BD1C, v10);
  }

void sub_100087AC8(uint64_t a1, uint64_t a2, uint64_t a3, void *a4)
{
  if (a3)
  {
    if (a4)
    {
      CFDictionaryRef v8 = sub_100012CEC((uint64_t)a4);
      if (v8)
      {
        CFDictionaryRef v9 = v8;
        v10 = *(const __CFDictionary **)(a3 + 1992);
        if (v10 && (MutableCFDictionaryRef Copy = CFDictionaryCreateMutableCopy(kCFAllocatorDefault, 0LL, v10)) != 0LL
          || (MutableCFDictionaryRef Copy = CFDictionaryCreateMutable( kCFAllocatorDefault,  0LL,  &kCFTypeDictionaryKeyCallBacks,  &kCFTypeDictionaryValueCallBacks)) != 0LL)
        {
          CFDictionarySetValue(MutableCopy, @"LINK_CHANGED_IS_LINKDOWN", kCFBooleanFalse);
          CFDictionarySetValue(MutableCopy, @"LINK_CHANGED_NETWORK", v9);
          CFRelease(v9);
          sub_100077498(a3, a4, 1u);
          CFDictionaryRef v12 = objc_autoreleasePoolPush();
          if (qword_100219F60) {
            [qword_100219F60 WFLog:@"%s: outranking state overridden. Replaying link event to clients." message:3];
          }
          objc_autoreleasePoolPop(v12);
          context[0] = a3;
          context[1] = a1;
          void context[2] = MutableCopy;
          CFSetApplyFunction(*(CFSetRef *)(a3 + 136), (CFSetApplierFunction)sub_10008BCAC, context);
          [+[WiFiXPCManager sharedXPCManager](WiFiXPCManager, "sharedXPCManager") replayLinkUpEventWithInterfaceName:a2];
          CFRelease(MutableCopy);
        }

        else
        {
          CFRelease(v9);
        }
      }
    }
  }

void sub_100087C50(uint64_t a1, uint64_t a2, CFDictionaryRef theDict)
{
  if (a2 && theDict)
  {
    Value = (const __CFBoolean *)CFDictionaryGetValue(theDict, @"HostApEnabled");
    BOOL v7 = Value && CFBooleanGetValue(Value);
    *(_BYTE *)(a2 + 1040) = v7;
    v8[0] = a1;
    v8[1] = theDict;
    CFSetApplyFunction(*(CFSetRef *)(a2 + 136), (CFSetApplierFunction)sub_10008BD38, v8);
  }

void sub_100087CD0(uint64_t a1, uint64_t a2, char a3)
{
  if (a2)
  {
    *(_BYTE *)(a2 + 1041) = a3;
    v4 = objc_autoreleasePoolPush();
    if (qword_100219F60)
    {
      int v5 = "disabled";
      if (*(_BYTE *)(a2 + 1043) == 1) {
        v6 = "enabled";
      }
      else {
        v6 = "disabled";
      }
      if (*(_BYTE *)(a2 + 1041) == 1) {
        int v5 = "enabled";
      }
      [qword_100219F60 WFLog:message:3, "%s: MIS Discovery Req state %s Current state %s", "__WiFiManagerDeviceMISDiscoverStateChangeCallback", v6, v5];
    }

    objc_autoreleasePoolPop(v4);
  }

void sub_100087D64(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  v4[0] = a1;
  v4[1] = a3;
  CFSetApplyFunction(*(CFSetRef *)(a4 + 136), (CFSetApplierFunction)sub_10008BD54, v4);
}

void sub_100087D94(uint64_t a1, uint64_t a2, const void *a3, uint64_t a4, uint64_t a5, _BYTE *a6)
{
  if (a3 && a6[1040])
  {
    if (!a6[1920]
      || ((unsigned int v8 = a6[1921], v9 = v8 > 0xE, v10 = (1 << v8) & 0x5440, !v9) ? (v11 = v10 == 0) : (v11 = 1),
          !v11))
    {
      CFDictionaryRef v12 = objc_autoreleasePoolPush();
      if (qword_100219F60) {
        [qword_100219F60 WFLog:@"%s: MIS state is enabled. Force-disabling before association." message:4];
      }
      objc_autoreleasePoolPop(v12);
      sub_10006DFA8((uint64_t)a6, 0LL, 0);
    }
  }

void sub_100087E58(uint64_t a1, uint64_t a2, void *a3, uint64_t a4, uint64_t a5)
{
  id v6 = a3;
  if (*(void *)(a5 + 1544))
  {
    *(_BYTE *)(a5 + 1576) = 0;
    v7[0] = _NSConcreteStackBlock;
    v7[1] = 3221225472LL;
    v7[2] = sub_10008BF58;
    v7[3] = &unk_1001E4350;
    v7[4] = v6;
    v7[5] = a5;
    dispatch_async((dispatch_queue_t)qword_100219F80, v7);
  }

void sub_100087ED4(uint64_t a1, uint64_t a2, void *a3, uint64_t a4, uint64_t a5, uint64_t a6)
{
  if (a3 && a6)
  {
    int v10 = objc_autoreleasePoolPush();
    if (qword_100219F60) {
      [(id)qword_100219F60 WFLog:3, "%s: network %@, requestedInformation %@ err %d", "__WiFiManagerDidAssociateCallback", sub_100095BC8(a3), a4, a5 message];
    }
    objc_autoreleasePoolPop(v10);
    sub_1000A0508((uint64_t)a3);
    if (sub_100078748(a6, a3))
    {
      BOOL v11 = objc_autoreleasePoolPush();
      if (qword_100219F60) {
        [(id)qword_100219F60 WFLog:3, "%s: %@ is joined first time, so now enable it", "__WiFiManagerDidAssociateCallback", sub_100095BC8(a3) message];
      }
      objc_autoreleasePoolPop(v11);
      sub_10009E934(a3, 0);
    }

    sub_100077498(a6, a3, 1u);
    sub_10006570C(a6, 1LL, 2LL, 0LL);
    sub_10008BF8C(a6, *(unsigned __int8 *)(a6 + 24), 1);
  }

void sub_100088018(uint64_t a1, uint64_t a2, void *a3, uint64_t a4, uint64_t a5, uint64_t a6)
{
  int valuePtr = 0;
  sub_10008BD70(a6, a3, a2);
  if (a3
    && sub_1000951FC((uint64_t)a3, @"WPS_PROB_RESP_IE")
    && objc_msgSend( +[WiFiAnalyticsManager sharedWiFiAnalyticsManager]( WiFiAnalyticsManager,  "sharedWiFiAnalyticsManager"),  "deviceAnalyticsClient"))
  {
    BOOL v9 = objc_autoreleasePoolPush();
    id v10 = [WiFiAnalyticsManager sharedWiFiAnalyticsManager].deviceAnalyticsClient;
    BOOL v11 = sub_1000951FC((uint64_t)a3, @"BSSID");
    unsigned int v12 = [v10 parsedBeaconInfoIsStored:v11 ssid:sub_100095BC8(a3)];
    v13 = objc_autoreleasePoolPush();
    v14 = (void *)qword_100219F60;
    if (qword_100219F60)
    {
      if (v12) {
        int v15 = "does not need";
      }
      else {
        int v15 = "needs";
      }
      uint64_t v16 = sub_100095BC8(a3);
      [v14 WFLog:3, "%s: ParsedBeaconInfo %s submission for ssid:%@ bssid:%@ ", "__WiFiManagerBSSIDChangedCallback", v15, v16, sub_1000951FC((uint64_t)a3, @"BSSID") message];
    }

    objc_autoreleasePoolPop(v13);
    if ((v12 & 1) == 0) {
      sub_1000346F8(a6, a3, 0);
    }
    objc_autoreleasePoolPop(v9);
  }

  sub_100077498(a6, a3, 1u);
  sub_1000951FC((uint64_t)a3, @"BSSID");
  objc_autoreleasePoolPop(objc_autoreleasePoolPush());
  v17 = objc_autoreleasePoolPush();
  if (qword_100219F60) {
    [(id)qword_100219F60 WFLog:3, "%s: BSSID changed. Updating private mac networks for network : %@", "__WiFiManagerBSSIDChangedCallback", sub_100095BC8(a3) message];
  }
  objc_autoreleasePoolPop(v17);
  context[0] = a3;
  context[1] = a1;
  CFSetApplyFunction(*(CFSetRef *)(a6 + 136), (CFSetApplierFunction)sub_10008C168, context);
  if (sub_10009DF44((uint64_t)a3))
  {
    BOOL v18 = sub_10009E054((uint64_t)a3);
    sub_10008B8F8(a6, a1, v18);
  }

  v19 = (const __CFNumber *)sub_100096A74((uint64_t)a3);
  if (v19)
  {
    CFNumberGetValue(v19, kCFNumberIntType, &valuePtr);
    if (a3)
    {
      if (*(void *)(a6 + 120) == 3348380076LL)
      {
        BOOL v20 = sub_10009E054((uint64_t)a3);
        sub_1000F7038(a1, v20);
      }
    }
  }

void sub_100088268(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, int a5, uint64_t a6)
{
  if (a5)
  {
    if (!*(_BYTE *)(a6 + 2088)) {
      return;
    }
    BOOL v7 = (_BYTE *)(a6 + 2088);
    goto LABEL_4;
  }

  uint64_t v8 = *(void *)(a6 + 1992);
  if (v8)
  {
    context[0] = a6;
    context[1] = a1;
    void context[2] = v8;
    CFSetApplyFunction(*(CFSetRef *)(a6 + 136), (CFSetApplierFunction)sub_10008BCAC, context);
    kdebug_trace(731381836LL, 0LL, 0LL, 0LL, 0LL);
    BOOL v9 = objc_autoreleasePoolPush();
    if (qword_100219F60) {
      [qword_100219F60 WFLog:@"__WiFiManagerJoinDoneCallback: Dispatching client link up event."];
    }
    objc_autoreleasePoolPop(v9);
  }

  if (*(_BYTE *)(a6 + 2088))
  {
    BOOL v7 = (_BYTE *)(a6 + 2088);
    if (*(_BYTE *)(a6 + 2073))
    {
      id v10 = objc_autoreleasePoolPush();
      if (qword_100219F60) {
        [qword_100219F60 WFLog:@"Debounce succeeded."];
      }
      objc_autoreleasePoolPop(v10);
      *(CFAbsoluteTime *)(a6 + 2056) = CFAbsoluteTimeGetCurrent();
      if (*(_BYTE *)(a6 + 2074))
      {
        BOOL v11 = *(dispatch_source_s **)(a6 + 2080);
        dispatch_time_t v12 = dispatch_time(0LL, 3000000000LL);
        dispatch_source_set_timer(v11, v12, 0xFFFFFFFFFFFFFFFFLL, 0LL);
      }

      goto LABEL_5;
    }

LABEL_4:
    *(_WORD *)(a6 + 2073) = 0;
LABEL_5:
    if (!*(_BYTE *)(a6 + 2073) || !*(_BYTE *)(a6 + 2074)) {
      sub_10008C174(a6);
    }
    *BOOL v7 = 0;
  }

const void *sub_1000883C8( const void *a1, int a2, uint64_t a3, uint64_t a4, CFDictionaryRef *a5, const __CFDictionary *a6, uint64_t a7)
{
  byte_100219930 = 0;
  if (*(_DWORD *)(a7 + 612) == 2) {
    goto LABEL_5;
  }
  if (!*(void *)(a7 + 672))
  {
    v14 = objc_autoreleasePoolPush();
    if (qword_100219F60) {
      [(id)qword_100219F60 WFLog:3, "%s: type %@(%d), display is off", "__WiFiManagerRequestCallback", sub_10003B428(a3), a3 message];
    }
    goto LABEL_22;
  }

  if ((*(_BYTE *)(a7 + 656) & 0x11) == 0)
  {
    v14 = objc_autoreleasePoolPush();
    if (qword_100219F60) {
      [(id)qword_100219F60 WFLog:3, "%s: type %@(%d), no FG wifi app", "__WiFiManagerRequestCallback", sub_10003B428(a3), a3 message];
    }
LABEL_22:
    objc_autoreleasePoolPop(v14);
LABEL_13:
    id v10 = 0LL;
    goto LABEL_15;
  }

const void *sub_1000885B0( uint64_t a1, int a2, uint64_t a3, uint64_t a4, void *a5, const __CFDictionary *a6, uint64_t a7)
{
  byte_100219930 = 0;
  if (*(_DWORD *)(a7 + 612) == 2) {
    goto LABEL_5;
  }
  if (!*(void *)(a7 + 672))
  {
    v14 = objc_autoreleasePoolPush();
    if (qword_100219F60) {
      [(id)qword_100219F60 WFLog:3, "%s: type %@(%d), display is off", "__WiFiManagerColocatedRequestCallback", sub_10003B428(a3), a3 message];
    }
    goto LABEL_22;
  }

  if ((*(_BYTE *)(a7 + 656) & 0x11) == 0)
  {
    v14 = objc_autoreleasePoolPush();
    if (qword_100219F60) {
      [(id)qword_100219F60 WFLog:3, "%s: type %@(%d), no FG wifi app", "__WiFiManagerColocatedRequestCallback", sub_10003B428(a3), a3 message];
    }
LABEL_22:
    objc_autoreleasePoolPop(v14);
LABEL_13:
    id v10 = 0LL;
    goto LABEL_15;
  }

void sub_10008878C(uint64_t a1, uint64_t a2, const void *a3, void *a4, int a5, uint64_t a6)
{
  if (!a3 || !a4) {
    return;
  }
  uint64_t v7 = a6;
  context[1] = -1431655766;
  context[0] = a5;
  CFTypeRef v43 = 0LL;
  v44 = 0LL;
  uint64_t v45 = a1;
  uint64_t v46 = a6;
  CFTypeRef v9 = sub_10003A9C4(kCFAllocatorDefault, a3);
  CFTypeRef cf = v9;
  if (!v9)
  {
    dispatch_time_t v12 = objc_autoreleasePoolPush();
    if (qword_100219F60) {
      [(id)qword_100219F60 WFLog:4, "%s: serialization failed for scan data: %@", "__WiFiManagerDispatchClientScanCacheUpdateEvent", a3 message];
    }
    objc_autoreleasePoolPop(v12);
    goto LABEL_16;
  }

  CFTypeRef v10 = v9;
  CFTypeRef v43 = sub_10003A9C4(kCFAllocatorDefault, a4);
  if (v43)
  {
    Value = (const __CFDictionary *)CFDictionaryGetValue((CFDictionaryRef)a3, @"scanRequest");
    if (Value) {
      v44 = CFDictionaryGetValue(Value, @"ScanReqClientPid");
    }
    CFSetApplyFunction(*(CFSetRef *)(v7 + 136), (CFSetApplierFunction)sub_10008C5B4, context);
    CFTypeRef v10 = cf;
    if (!cf) {
      goto LABEL_16;
    }
  }

  else
  {
    v13 = objc_autoreleasePoolPush();
    if (qword_100219F60) {
      [(id)qword_100219F60 WFLog:4, "%s: serialization failed for trimmed scan data: %@", "__WiFiManagerDispatchClientScanCacheUpdateEvent", a4 message];
    }
    objc_autoreleasePoolPop(v13);
  }

  CFRelease(v10);
  CFTypeRef cf = 0LL;
LABEL_16:
  if (v43) {
    CFRelease(v43);
  }
  v14 = objc_autoreleasePoolPush();
  [*(id *)(v7 + 200) update80211dCountryCodes:a4];
  objc_autoreleasePoolPop(v14);
  if (&_RDUpdateCountryCodeFromWiFiAPs)
  {
    id v15 = [a4 objectForKey:@"scanRequest"];
    id v16 = [a4 objectForKey:@"scanResults"];
    if (objc_msgSend(objc_msgSend(v15, "objectForKey:", @"SCAN_CHANNELS"), "count") != (id)1)
    {
      __int128 v39 = 0u;
      __int128 v40 = 0u;
      __int128 v37 = 0u;
      __int128 v38 = 0u;
      id v17 = [v16 countByEnumeratingWithState:&v37 objects:context count:16];
      if (v17)
      {
        id v18 = v17;
        uint64_t v36 = v7;
        unint64_t v19 = 0LL;
        BOOL v20 = 0LL;
        uint64_t v21 = *(void *)v38;
        do
        {
          for (i = 0LL; i != v18; i = (char *)i + 1)
          {
            if (*(void *)v38 != v21) {
              objc_enumerationMutation(v16);
            }
            id v23 = objc_msgSend( objc_msgSend(*(id *)(*((void *)&v37 + 1) + 8 * (void)i), "objectForKey:", @"80211D_IE"),  "objectForKey:",  @"IE_KEY_80211D_COUNTRY_CODE");
            if (v23)
            {
              v24 = v23;
              if (!v20) {
                BOOL v20 = -[NSCountedSet initWithCapacity:]( objc_alloc(&OBJC_CLASS___NSCountedSet),  "initWithCapacity:",  0LL);
              }
              -[NSCountedSet addObject:](v20, "addObject:", [v24 uppercaseString]);
              ++v19;
            }
          }

          id v18 = [v16 countByEnumeratingWithState:&v37 objects:context count:16];
        }

        while (v18);
        if (v19 < 3)
        {
          v35 = 0LL;
        }

        else
        {
          v25 = -[NSCountedSet objectEnumerator](v20, "objectEnumerator");
          v26 = -[NSEnumerator nextObject](v25, "nextObject");
          if (v26)
          {
            v27 = v26;
            v28 = 0LL;
            id v29 = 0LL;
            unint64_t v30 = 0LL;
            do
            {
              id v31 = -[NSCountedSet countForObject:](v20, "countForObject:", v27);
              BOOL v33 = (unint64_t)v31 < 2 || (unint64_t)v31 < v30;
              if (v33) {
                id v34 = (id)v30;
              }
              else {
                id v34 = v31;
              }
              if (!v33)
              {
                id v29 = (id)v30;
                v28 = v27;
              }

              v27 = -[NSEnumerator nextObject](v25, "nextObject");
              unint64_t v30 = (unint64_t)v34;
            }

            while (v27);
          }

          else
          {
            id v34 = 0LL;
            id v29 = 0LL;
            v28 = 0LL;
          }

          if (v34 == v29) {
            v35 = 0LL;
          }
          else {
            v35 = v28;
          }
        }

        uint64_t v7 = v36;
      }

      else
      {
        BOOL v20 = 0LL;
        v35 = 0LL;
      }

      sub_10006FDB0(v7, v35, 0);
    }
  }

void sub_100088B38(void *context, uint64_t a2, uint64_t a3)
{
}

void sub_100088B50(uint64_t a1, uint64_t a2, char a3, uint64_t a4)
{
  v4[0] = 0xAAAAAAAAAAAAAAAALL;
  v4[1] = a1;
  LOBYTE(v4[0]) = a3;
  CFSetApplyFunction(*(CFSetRef *)(a4 + 136), (CFSetApplierFunction)sub_10008C890, v4);
}

void sub_100088B88(uint64_t a1, uint64_t a2, uint64_t a3, const void *a4)
{
  if (a3)
  {
    if (a4)
    {
      unint64_t v12 = 0xAAAAAAAAAAAAAA01LL;
      context[0] = a3;
      context[1] = a1;
      CFTypeRef cf = sub_10003A9C4(kCFAllocatorDefault, a4);
      CFIndex Count = CFSetGetCount(*(CFSetRef *)(a3 + 136));
      uint64_t v13 = 0LL;
      uint64_t v14 = 0LL;
      CFIndex v11 = Count;
      CFSetApplyFunction(*(CFSetRef *)(a3 + 136), (CFSetApplierFunction)sub_10008C8A0, context);
      if (cf) {
        CFRelease(cf);
      }
      [+[WiFiXPCManager sharedXPCManager](WiFiXPCManager, "sharedXPCManager") sendWiFiAssistEventWithInterfaceName:a2 linkQualityMetricInfo:a4];
    }

    uint64_t v8 = *(void **)(a3 + 1496);
    if (v8) {
      sub_10000F790((void *)a3, v8, 12, a4);
    }
  }

void sub_100088C4C(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  if (a3)
  {
    if (a4)
    {
      context[0] = a3;
      context[1] = a1;
      void context[2] = a4;
      CFSetApplyFunction(*(CFSetRef *)(a3 + 136), (CFSetApplierFunction)sub_10008C8CC, context);
    }
  }

void sub_100088C88(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  if (a3)
  {
    if (a4)
    {
      context[0] = a3;
      context[1] = a1;
      void context[2] = a4;
      CFSetApplyFunction(*(CFSetRef *)(a3 + 136), (CFSetApplierFunction)sub_10008C8F0, context);
    }
  }

void sub_100088CC4(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  if (a3)
  {
    if (a4)
    {
      context[0] = a3;
      context[1] = a1;
      void context[2] = a4;
      CFSetApplyFunction(*(CFSetRef *)(a3 + 136), (CFSetApplierFunction)sub_10008C914, context);
    }
  }

void sub_100088D00(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  if (a3)
  {
    if (a4)
    {
      context[0] = a3;
      context[1] = a1;
      void context[2] = a4;
      CFSetApplyFunction(*(CFSetRef *)(a3 + 136), (CFSetApplierFunction)sub_10008C938, context);
    }
  }

void sub_100088D3C(uint64_t a1, uint64_t a2, uint64_t a3)
{
  if (a3 && *(_BYTE *)(a3 + 2088))
  {
    v4 = objc_autoreleasePoolPush();
    if (qword_100219F60) {
      [qword_100219F60 WFLog:@"Debounce failed" message:3];
    }
    objc_autoreleasePoolPop(v4);
    *(_WORD *)(a3 + 2073) = 0;
    sub_10008C174(a3);
    *(_BYTE *)(a3 + 2088) = 0;
  }

void sub_100088DBC(int a1, uint64_t a2, uint64_t a3, CFDictionaryRef theDict)
{
  __int16 v38 = 0;
  __int16 v37 = 0;
  __int16 v36 = 0;
  value = 0LL;
  uint64_t v35 = 0LL;
  CFNumberRef v32 = 0LL;
  CFNumberRef number = 0LL;
  CFNumberRef v30 = 0LL;
  CFNumberRef v31 = 0LL;
  CFNumberRef v28 = 0LL;
  CFNumberRef v29 = 0LL;
  CFNumberRef v27 = 0LL;
  if (a3 && theDict)
  {
    unsigned __int8 valuePtr = -86;
    uint64_t v7 = (const __CFNumber *)CFDictionaryGetValue(theDict, @"ASR_SESSION_STATE");
    if (v7)
    {
      CFNumberGetValue(v7, kCFNumberSInt8Type, &valuePtr);
      int v8 = *(unsigned __int8 *)(a3 + 1960);
      int v9 = v8;
      if (v8 != valuePtr)
      {
        CFTypeRef v10 = objc_autoreleasePoolPush();
        if (qword_100219F60) {
          [qword_100219F60 WFLog:@"11ax ASR session: new-state = 0x%x, prev-state = 0x%x" message:3 valuePtr:*(unsigned __int8 *)(a3 + 1960)];
        }
        objc_autoreleasePoolPop(v10);
        int v9 = *(unsigned __int8 *)(a3 + 1960);
        int v8 = valuePtr;
      }

      if (!v9 && v8)
      {
        *(CFAbsoluteTime *)(a3 + 1968) = CFAbsoluteTimeGetCurrent();
        CFIndex v11 = objc_autoreleasePoolPush();
        if (qword_100219F60) {
          [(id)qword_100219F60 WFLog:3 message:"11ax ASR session: STARTED"];
        }
        objc_autoreleasePoolPop(v11);
        int v9 = *(unsigned __int8 *)(a3 + 1960);
        int v8 = valuePtr;
      }

      if (v9 && !v8)
      {
        double v12 = CFAbsoluteTimeGetCurrent() - *(double *)(a3 + 1968);
        uint64_t v13 = objc_autoreleasePoolPush();
        if (qword_100219F60) {
          [qword_100219F60 WFLog:@"11ax ASR session: duration = %f seconds" message:4];
        }
        objc_autoreleasePoolPop(v13);
        sub_100037EEC(v12);
        LOBYTE(v8) = valuePtr;
      }

      *(_BYTE *)(a3 + 1960) = v8;
    }

    uint64_t v14 = (const __CFNumber *)CFDictionaryGetValue(theDict, @"RT_TRAFFIC_STATE");
    id v15 = v14;
    if (v14) {
      CFNumberGetValue(v14, kCFNumberSInt8Type, (char *)&v38 + 1);
    }
    int ValueIfPresent = CFDictionaryGetValueIfPresent(theDict, @"QUAL_SCORE", (const void **)&value);
    uint64_t v17 = 0LL;
    if (ValueIfPresent)
    {
      CFNumberRef v18 = 0LL;
      if (value)
      {
        if (CFDictionaryGetValueIfPresent((CFDictionaryRef)value, @"CHANQUAL_SCORE", (const void **)&number)
          && number)
        {
          CFNumberGetValue(number, kCFNumberSInt8Type, &v38);
        }

        if (CFDictionaryGetValueIfPresent((CFDictionaryRef)value, @"TX_LATENCY_SCORE", (const void **)&v30)
          && v30)
        {
          CFNumberGetValue(v30, kCFNumberSInt8Type, (char *)&v37 + 1);
        }

        if (CFDictionaryGetValueIfPresent((CFDictionaryRef)value, @"RX_LATENCY_SCORE", (const void **)&v29)
          && v29)
        {
          CFNumberGetValue(v29, kCFNumberSInt8Type, &v37);
        }

        if (CFDictionaryGetValueIfPresent((CFDictionaryRef)value, @"P95_TX_LATENCY_SCORE", (const void **)&v32)
          && v32)
        {
          CFNumberGetValue(v32, kCFNumberSInt32Type, (char *)&v35 + 4);
        }

        int v19 = CFDictionaryGetValueIfPresent( (CFDictionaryRef)value,  @"LINK_RECOMMENDATION_FLAGS",  (const void **)&v31);
        uint64_t v17 = 0LL;
        CFNumberRef v18 = v31;
        if (v19 && v31)
        {
          CFNumberGetValue(v31, kCFNumberSInt32Type, &v35);
          CFNumberRef v18 = v31;
          uint64_t v17 = (int)v35;
        }
      }
    }

    else
    {
      CFNumberRef v18 = 0LL;
    }

    uint64_t v20 = 0x7FFFFFFFFFFFFFFFLL;
    if (number) {
      uint64_t v21 = (char)v38;
    }
    else {
      uint64_t v21 = 0x7FFFFFFFFFFFFFFFLL;
    }
    if (v30) {
      uint64_t v22 = SHIBYTE(v37);
    }
    else {
      uint64_t v22 = 0x7FFFFFFFFFFFFFFFLL;
    }
    if (v29) {
      uint64_t v23 = (char)v37;
    }
    else {
      uint64_t v23 = 0x7FFFFFFFFFFFFFFFLL;
    }
    if (v28) {
      uint64_t v24 = SHIBYTE(v36);
    }
    else {
      uint64_t v24 = 0x7FFFFFFFFFFFFFFFLL;
    }
    if (v27) {
      uint64_t v25 = (char)v36;
    }
    else {
      uint64_t v25 = 0x7FFFFFFFFFFFFFFFLL;
    }
    if (v32) {
      uint64_t v26 = SHIDWORD(v35);
    }
    else {
      uint64_t v26 = 0x7FFFFFFFFFFFFFFFLL;
    }
    if (!v18) {
      uint64_t v17 = 0x7FFFFFFFFFFFFFFFLL;
    }
    if (v15) {
      uint64_t v20 = HIBYTE(v38);
    }
    [*(id *)(a3 + 2144) updateWithChQualScore:v21 txLatencyScore:v22 rxLatencyScore:v23 txLossScore:v24 rxLossScore:v25 txLatencyP95:v26 linkRecommendationFlags:v17 r tTrafficStatus:v20 forInterface:a2];
  }

void sub_100089168(uint64_t a1, uint64_t a2, uint64_t a3, int a4)
{
  context[1] = a1;
  int v6 = -1431655766;
  context[0] = a3;
  int v5 = a4;
  CFSetApplyFunction(*(CFSetRef *)(a3 + 136), (CFSetApplierFunction)sub_10008C95C, context);
}

void sub_1000891A4(uint64_t a1, uint64_t a2, uint64_t a3, char a4)
{
  *(_BYTE *)(a3 + 737) = a4;
  context[1] = a1;
  unint64_t v5 = 0xAAAAAAAAAAAAAAAALL;
  context[0] = a3;
  LOBYTE(v5) = a4;
  CFSetApplyFunction(*(CFSetRef *)(a3 + 136), (CFSetApplierFunction)sub_10008D904, context);
}

void sub_1000891E4(uint64_t a1, uint64_t a2, uint64_t a3)
{
  int v3 = *(_DWORD *)(a3 + 740) + 1;
  *(_DWORD *)(a3 + 740) = v3;
  context[1] = a1;
  int v6 = -1431655766;
  context[0] = a3;
  int v5 = v3;
  CFSetApplyFunction(*(CFSetRef *)(a3 + 136), (CFSetApplierFunction)sub_10008C9E0, context);
}

void sub_10008922C(uint64_t a1, uint64_t a2, uint64_t a3)
{
  *(_DWORD *)(a3 + 740) = 0;
  context[1] = a1;
  void context[2] = 0xAAAAAAAA00000000LL;
  context[0] = a3;
  CFSetApplyFunction(*(CFSetRef *)(a3 + 136), (CFSetApplierFunction)sub_10008C9E0, context);
}

void sub_10008926C(uint64_t a1, int a2, uint64_t a3, int a4, void *value)
{
  if (a3)
  {
    int valuePtr = -1431655766;
    switch(a4)
    {
      case 0:
        int v8 = *(__CFDictionary **)(a3 + 1632);
        int v9 = off_1001E3570;
        goto LABEL_14;
      case 2:
        int valuePtr = (int)value;
        CFNumberRef v10 = CFNumberCreate(kCFAllocatorDefault, kCFNumberCFIndexType, &valuePtr);
        CFDictionarySetValue(*(CFMutableDictionaryRef *)(a3 + 1632), @"DiagnosticsBssEnv", v10);
        if (v10) {
          CFRelease(v10);
        }
        break;
      case 3:
        int v8 = *(__CFDictionary **)(a3 + 1632);
        int v9 = off_1001E35A8;
        goto LABEL_14;
      case 4:
        CFDictionarySetValue(*(CFMutableDictionaryRef *)(a3 + 1632), @"DiagnosticsScan", value);
        int v8 = *(__CFDictionary **)(a3 + 1632);
        CFIndex v11 = @"DiagnosticsScanDone";
        double v12 = &kCFBooleanFalse;
        goto LABEL_9;
      case 5:
        int v8 = *(__CFDictionary **)(a3 + 1632);
        CFIndex v11 = @"DiagnosticsScanDone";
        double v12 = &kCFBooleanTrue;
LABEL_9:
        CFBooleanRef v13 = *v12;
        goto LABEL_15;
      case 6:
        unsigned int v14 = [CFArrayGetValueAtIndex((CFArrayRef)value, 1) isEqualToString:@"www.apple.com"];
        int v8 = *(__CFDictionary **)(a3 + 1632);
        if (v14) {
          int v9 = off_1001E35B0;
        }
        else {
          int v9 = off_1001E35B8;
        }
        goto LABEL_14;
      case 7:
        int v8 = *(__CFDictionary **)(a3 + 1632);
        int v9 = off_1001E35C0;
LABEL_14:
        CFIndex v11 = *v9;
        CFBooleanRef v13 = (CFBooleanRef)value;
LABEL_15:
        CFDictionarySetValue(v8, v11, v13);
        break;
      default:
        break;
    }

    CFNumberRef v15 = CFNumberCreate(kCFAllocatorDefault, kCFNumberCFIndexType, (const void *)(a3 + 892));
    CFDictionarySetValue(*(CFMutableDictionaryRef *)(a3 + 1632), @"DiagnosticsBluetooth", v15);
    if (v15) {
      CFRelease(v15);
    }
    id v16 = *(__CFDictionary **)(a3 + 1632);
    uint64_t v17 = sub_10008FDAC(*(_DWORD *)(a3 + 1240));
    CFDictionarySetValue(v16, @"DiagnosticsMotion", v17);
    if (*(void *)(a3 + 1656))
    {
      CFNumberRef v18 = objc_autoreleasePoolPush();
      if (qword_100219F60) {
        [(id)qword_100219F60 WFLog:3, "%s: diagnostics report %@", "__WiFiManagerDiagnosticsStartCallback", *(void *)(a3 + 1632) message];
      }
      objc_autoreleasePoolPop(v18);
      int v19 = *(const void **)(a3 + 1632);
      uint64_t context = a1;
      CFTypeRef cf = sub_10003A9C4(kCFAllocatorDefault, v19);
      CFSetApplyFunction(*(CFSetRef *)(a3 + 136), (CFSetApplierFunction)sub_10008CA64, &context);
      if (cf) {
        CFRelease(cf);
      }
    }
  }

void sub_1000894C8(uint64_t a1, void *a2, uint64_t a3)
{
  if (!a3)
  {
    int v5 = objc_autoreleasePoolPush();
    if (qword_100219F60) {
      [qword_100219F60 WFLog:@"%s: manager ref is null" message:4];
    }
    goto LABEL_10;
  }

  int v5 = objc_autoreleasePoolPush();
  if (!a2)
  {
    if (qword_100219F60) {
      [qword_100219F60 WFLog:@"%s: network is null" message:3];
    }
LABEL_10:
    objc_autoreleasePoolPop(v5);
    return;
  }

  if (qword_100219F60) {
    [(id)qword_100219F60 WFLog:3, "%s: association to recommened network %@", "__WiFiManagerRecommendedNetworkAssociationCallback", sub_100095BC8(a2) message];
  }
  objc_autoreleasePoolPop(v5);
  sub_100072038(a3, a2, 14LL);
}

void sub_1000895C4(uint64_t a1, uint64_t a2, uint64_t a3)
{
  v3[0] = a1;
  v3[1] = a3;
  CFSetApplyFunction(*(CFSetRef *)(a2 + 136), (CFSetApplierFunction)sub_10008CA80, v3);
}

void sub_1000895F8(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  if (a2 && a3)
  {
    if (a4) {
      objc_autoreleasePoolPop(objc_autoreleasePoolPush());
    }
  }

void sub_10008961C(uint64_t a1, uint64_t a2)
{
  uint64_t v3 = sub_1000DD84C(a1);
  if (*(_DWORD *)(a2 + 1760) != (_DWORD)v3)
  {
    uint64_t v4 = v3;
    int v5 = objc_autoreleasePoolPush();
    if (qword_100219F60) {
      [qword_100219F60 WFLog:@"%s WiFiMC : band support changed. Before : %d, after : %d" message:3];
    }
    objc_autoreleasePoolPop(v5);
    *(_DWORD *)(a2 + 1760) = v4;
    sub_10006FAFC((void *)a2, @"WiFiCountryBandSupportKey", v4, 1);
  }

void sub_1000896D0(uint64_t a1, uint64_t a2, uint64_t a3, int a4)
{
  if (a3)
  {
    v5[0] = a1;
    v5[1] = a2;
    if (a4) {
      uint64_t v4 = (void (__cdecl *)(const void *, void *))sub_10008CA9C;
    }
    else {
      uint64_t v4 = (void (__cdecl *)(const void *, void *))sub_10008CAA8;
    }
    CFSetApplyFunction(*(CFSetRef *)(a3 + 136), v4, v5);
  }

void sub_10008971C(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  context[0] = a1;
  context[1] = a2;
  void context[2] = a4;
  CFSetApplyFunction(*(CFSetRef *)(a3 + 136), (CFSetApplierFunction)sub_10008CAB4, context);
}

void sub_100089750(const void *a1, uint64_t a2, CFDictionaryRef theDict, uint64_t a4)
{
  Value = CFDictionaryGetValue(theDict, @"DRIVER_AVAILABLE");
  int v9 = (const __CFString *)CFDictionaryGetValue(theDict, @"DRIVER_AVAILABLE_KEY_SUBREASON_STRING");
  CFNumberRef v10 = *(const void **)(a4 + 616);
  if (v10)
  {
    CFIndex v11 = v9;
    if (CFEqual(Value, v10))
    {
      if (!v11 || CFStringCompare(@"Driver Booted", v11, 1uLL))
      {
        double v12 = objc_autoreleasePoolPush();
        if (qword_100219F60) {
          [(id)qword_100219F60 WFLog:3, "%s: driver availability: %@ hasn't changed, bail out\n", "__WiFiManagerDispatchDeviceAvailable", Value message];
        }
        objc_autoreleasePoolPop(v12);
        return;
      }
    }
  }

  CFBooleanRef v13 = objc_autoreleasePoolPush();
  if (qword_100219F60) {
    [(id)qword_100219F60 WFLog:3, "%s: driver availability: %@, previously: %@\n", "__WiFiManagerDispatchDeviceAvailable", Value, *(void *)(a4 + 616) message];
  }
  objc_autoreleasePoolPop(v13);
  *(void *)(a4 + 616) = Value;
  if (!CFEqual(Value, kCFBooleanTrue))
  {
    uint64_t v20 = (const __CFString *)CFDictionaryGetValue(theDict, @"DRIVER_AVAILABLE_REASON_STRING");
    if (CFStringCompare(@"Watchdog", v20, 1uLL))
    {
      uint64_t v21 = (const __CFString *)CFDictionaryGetValue(theDict, @"DRIVER_AVAILABLE_REASON_STRING");
      if (CFStringCompare(@"DextCrashed", v21, 1uLL) == kCFCompareEqualTo && *(_BYTE *)(a4 + 1944) == 1)
      {
        uint64_t v22 = sub_1000D8D08((uint64_t)a1);
        if (v22)
        {
          uint64_t v23 = v22;
        }
      }
    }

    goto LABEL_32;
  }

  block[0] = _NSConcreteStackBlock;
  block[1] = 3221225472LL;
  block[2] = sub_10008CBF8;
  block[3] = &unk_1001E2620;
  block[4] = a4;
  dispatch_async((dispatch_queue_t)qword_100219F80, block);
  sub_10000F790((void *)a4, *(void **)(a4 + 1496), 10, a1);
  unsigned int v14 = (const __CFString *)CFDictionaryGetValue(theDict, @"DRIVER_AVAILABLE_REASON_STRING");
  if (CFStringCompare(@"DextCrashed", v14, 1uLL) == kCFCompareEqualTo)
  {
    CFNumberRef v15 = *(void **)(a4 + 200);
    if (v15)
    {
      id v16 = [v15 getLocaleCountryCode];
      char v17 = [*(id *)(a4 + 200) getLocaleSource];
      if (*(_BYTE *)(a4 + 1756) && v16)
      {
        int v18 = sub_1000DD7B4((uint64_t)a1, v16, v17);
        int v19 = objc_autoreleasePoolPush();
        if (v18)
        {
          if (qword_100219F60) {
            [(id)qword_100219F60 WFLog:3, "%s WiFiCC : Successfully Reapplied country : [%@] after DextCrashed", "__WiFiManagerDispatchDeviceAvailable", v16 message];
          }
          objc_autoreleasePoolPop(v19);
          goto LABEL_32;
        }

        if (qword_100219F60) {
          [(id)qword_100219F60 WFLog:3, "%s WiFiCC : Could not apply : [%@] after DextCrashed. Determining locale...", "__WiFiManagerDispatchDeviceAvailable", v16 message];
        }
        uint64_t v25 = v19;
      }

      else
      {
        uint64_t v24 = objc_autoreleasePoolPush();
        if (qword_100219F60) {
          [qword_100219F60 WFLog:@"%s WiFiCC : Dext Crashed. Locale not available. Determining fresh locale..." message:3];
        }
        uint64_t v25 = v24;
      }

      objc_autoreleasePoolPop(v25);
      [*(id *)(a4 + 200) determineAndSetLocale:0];
    }
  }

void sub_100089AB8(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  v4[0] = a1;
  v4[1] = a3;
  CFSetApplyFunction(*(CFSetRef *)(a4 + 136), (CFSetApplierFunction)sub_10008CC20, v4);
}

void sub_100089AE8(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  v4[0] = a1;
  v4[1] = a3;
  CFSetApplyFunction(*(CFSetRef *)(a4 + 136), (CFSetApplierFunction)sub_10008CC3C, v4);
}

void sub_100089B18( uint64_t a1, uint64_t a2, uint64_t a3, unsigned int a4, unsigned int a5, unsigned int a6, uint64_t a7, uint64_t a8)
{
  if (a8)
  {
    kdebug_trace(731381776LL, 0LL, 0LL, 0LL, 0LL);
    CFBooleanRef v13 = objc_autoreleasePoolPush();
    if (qword_100219F60) {
      [(id)qword_100219F60 WFLog:4, "%s: <%@> [%@] isMainIf? %d, isIPV4Routable <%d>, is IPV6Routable <%d>", "__WiFiManagerIPv4Callback", a2, a3, a4, a5, a6 message];
    }
    objc_autoreleasePoolPop(v13);
  }

void sub_100089BCC(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  context[0] = a1;
  context[1] = a2;
  void context[2] = a3;
  CFSetApplyFunction(*(CFSetRef *)(a4 + 136), (CFSetApplierFunction)sub_10008CC58, context);
}

void sub_100089C00(int a1, int a2, void *a3, CFDictionaryRef theDict)
{
}

uint64_t sub_100089C0C(uint64_t a1, void *a2, uint64_t a3)
{
  return sub_100077498(a3, a2, 1u);
}

uint64_t sub_100089C40(uint64_t result, _DWORD *a2, _BYTE *a3, uint64_t a4)
{
  if (result)
  {
    if (a4)
    {
      *a2 = *(_DWORD *)(a4 + 840);
      *a3 = *(_BYTE *)(a4 + 322);
    }
  }

  return result;
}

void sub_100089C5C(void *a1, uint64_t a2, const void *a3, uint64_t a4)
{
  if (!a4)
  {
    CFNumberRef v10 = objc_autoreleasePoolPush();
    if (qword_100219F60) {
      [qword_100219F60 WFLog:@"%s: manager is NULL!"];
    }
    goto LABEL_18;
  }

  if (!a1)
  {
    CFNumberRef v10 = objc_autoreleasePoolPush();
    if (qword_100219F60) {
      [qword_100219F60 WFLog:@"deviceManager is NULL!"];
    }
    goto LABEL_18;
  }

  int v7 = a2;
  switch((_DWORD)a2)
  {
    case 0x12:
      int v8 = *(void **)(a4 + 1512);
LABEL_9:
      [v8 updateHUDWithMessage:a3];
      return;
    case 0x11:
      int v8 = *(void **)(a4 + 1504);
      goto LABEL_9;
    case 0x10:
      objc_msgSend(*(id *)(a4 + 1504), "incrementCount", a2, a3);
      [*(id *)(a4 + 1504) submitABCReportWithReason:0];
      [*(id *)(a4 + 1504) submitMetric];
      sub_1000F2110((uint64_t)a1, -1);
      return;
  }

  int v9 = *(void **)(a4 + 1496);
  if (v9)
  {
    sub_10000F790(a1, v9, v7, a3);
    return;
  }

  CFNumberRef v10 = objc_autoreleasePoolPush();
  if (qword_100219F60) {
    [qword_100219F60 WFLog:@"%s: softErrorManager is NULL!"];
  }
LABEL_18:
  objc_autoreleasePoolPop(v10);
}

void sub_100089DB4(uint64_t a1, uint64_t a2)
{
}

void sub_100089DC0(uint64_t a1, const void *a2, uint64_t a3, const __CFDictionary *a4)
{
  v89 = 0LL;
  v90 = 0LL;
  v87 = 0LL;
  CFIndex v88 = -1LL;
  unsigned int v86 = 0;
  uint64_t v84 = 0LL;
  v85 = 0LL;
  unsigned __int8 v83 = 0;
  value = 0LL;
  unsigned int valuePtr = 0;
  CFNumberRef number = 0LL;
  unsigned int v79 = 0;
  CFNumberRef v78 = 0LL;
  unsigned int v77 = 0;
  int v8 = objc_autoreleasePoolPush();
  if (qword_100219F60) {
    [(id)qword_100219F60 WFLog:3, "%s: Processing __WiFiManagerBssSteerCallback for ifName:%@", "__WiFiManagerBssSteerCallback", a2 message];
  }
  objc_autoreleasePoolPop(v8);
  if (CFDictionaryGetValueIfPresent(a4, @"P2P_BSS_STEERING_REQUEST_TYPE", (const void **)&value))
  {
    CFNumberGetValue((CFNumberRef)value, kCFNumberSInt32Type, &valuePtr);
    int v9 = objc_autoreleasePoolPush();
    if (qword_100219F60) {
      [qword_100219F60 WFLog:message:3, "%s: Steering Request type:%u!", "__WiFiManagerBssSteerCallback", valuePtr];
    }
    objc_autoreleasePoolPop(v9);
  }

  if (value)
  {
    CFNumberRef v10 = (CFDictionaryRef *)sub_1000D3348(a1, a2);
    CFIndex v11 = v10;
    if (v10) {
      id v12 = sub_1000A335C((uint64_t)v10);
    }
    else {
      id v12 = 0LL;
    }
    unsigned int v69 = objc_msgSend(objc_msgSend(v12, "channel"), "band");
    CFBooleanRef v13 = sub_1000A063C(v11);
    BOOL v14 = 0;
    if (v11 && v90)
    {
      if (sub_100095BC8(v11))
      {
        CFNumberRef v15 = (const __CFString *)sub_100095BC8(v11);
        BOOL v14 = CFStringCompare(v15, (CFStringRef)v90, 0LL) == kCFCompareEqualTo;
      }

      else
      {
        BOOL v14 = 0;
      }
    }

    if (CFDictionaryGetValueIfPresent(a4, @"CHANNEL_FLAGS", (const void **)&v85))
    {
      if (v85) {
        CFNumberGetValue((CFNumberRef)v85, kCFNumberIntType, (char *)&v84 + 4);
      }
    }

    else
    {
      v85 = 0LL;
    }

    if (CFDictionaryGetValueIfPresent(a4, @"CHANNEL", (const void **)&v87))
    {
      if (v87)
      {
        CFNumberGetValue((CFNumberRef)v87, kCFNumberSInt32Type, &v86);
        id v16 = v87;
      }

      else
      {
        id v16 = 0LL;
      }
    }

    else
    {
      id v16 = 0LL;
      v87 = 0LL;
    }

    unint64_t v17 = (unint64_t)+[WiFiUsagePrivacyFilter bandFromFlags:OrChannel:]( &OBJC_CLASS___WiFiUsagePrivacyFilter,  "bandFromFlags:OrChannel:",  v85,  v16);
    if (v85) {
      BOOL v18 = HIDWORD(v84) == 0;
    }
    else {
      BOOL v18 = 1;
    }
    uint64_t v19 = v18;
    if (CFDictionaryGetValueIfPresent(a4, @"BAND_PREFERENCE", (const void **)&number))
    {
      if (number)
      {
        CFNumberGetValue(number, kCFNumberSInt32Type, &v79);
        if (v79 - 1 >= 3) {
          unint64_t v17 = v17;
        }
        else {
          unint64_t v17 = v79 - 1;
        }
      }
    }

    else
    {
      CFNumberRef number = 0LL;
    }

    if (CFDictionaryGetValueIfPresent(a4, @"ROAM_FLAGS", (const void **)&v78))
    {
      if (v78) {
        CFNumberGetValue(v78, kCFNumberSInt32Type, &v77);
      }
    }

    else
    {
      CFNumberRef v78 = 0LL;
    }

    if (valuePtr >= 2)
    {
      if (valuePtr == 2)
      {
        v72 = a2;
        uint64_t v74 = a1;
        uint64_t v26 = v13;
        id v27 = v12;
        CFNumberRef v28 = +[WiFiUsageMonitor sharedInstance](&OBJC_CLASS___WiFiUsageMonitor, "sharedInstance");
        if (v86) {
          BOOL v29 = v87 == 0LL;
        }
        else {
          BOOL v29 = 1;
        }
        if (v29) {
          uint64_t v30 = 0x7FFFFFFFFFFFFFFFLL;
        }
        else {
          uint64_t v30 = v86;
        }
        CFNumberRef v31 = v90;
        if (v89)
        {
          if (CFStringCompare(@"ff:ff:ff:ff:ff:ff", (CFStringRef)v89, 0LL)) {
            CFNumberRef v32 = v89;
          }
          else {
            CFNumberRef v32 = 0LL;
          }
        }

        else
        {
          CFNumberRef v32 = 0LL;
        }

        LOWORD(v67) = [v26 isStandalone6G];
        -[WiFiUsageMonitor setSteeringRequest:preferredChannel:preferredBand:preferredSSID:targetSSIDDiffersFromCurrent:preferredBSS:ssidIsSplit:transitionCandidates:]( v28,  "setSteeringRequest:preferredChannel:preferredBand:preferredSSID:targetSSIDDiffersFromCurrent:preferredBSS:ssid IsSplit:transitionCandidates:",  2LL,  v30,  v17,  v31,  !v14,  v32,  v67);
        v57 = objc_autoreleasePoolPush();
        if (qword_100219F60) {
          [(id)qword_100219F60 WFLog:3, "%s: Current Network ssid is :%@", "__WiFiManagerBssSteerCallback", sub_100095BC8(v11) message];
        }
        objc_autoreleasePoolPop(v57);
        id v12 = v27;
        if (v11) {
          sub_1000CE074(v74, v72, 1017LL, "__WiFiManagerBssSteerCallback", 9074LL);
        }
        BOOL v33 = 0LL;
        id v34 = 0LL;
        CFNumberRef v35 = 0LL;
        CFBooleanRef v13 = v26;
        if (!v12) {
          goto LABEL_131;
        }
LABEL_130:
        CFRelease(v12);
LABEL_131:
        if (v11) {
          CFRelease(v11);
        }
        if (v33) {
          CFRelease(v33);
        }
        if (v34) {
          CFRelease(v34);
        }
        if (v35) {
          CFRelease(v35);
        }
        if (v13) {
          CFRelease(v13);
        }
        return;
      }

      BOOL v33 = 0LL;
      id v34 = 0LL;
      goto LABEL_68;
    }

    v71 = a2;
    v73 = (void *)a1;
    v75 = v13;
    id v70 = v12;
    uint64_t v20 = +[WiFiUsageMonitor sharedInstance](&OBJC_CLASS___WiFiUsageMonitor, "sharedInstance");
    if (v86) {
      BOOL v21 = v87 == 0LL;
    }
    else {
      BOOL v21 = 1;
    }
    if (v21) {
      uint64_t v22 = 0x7FFFFFFFFFFFFFFFLL;
    }
    else {
      uint64_t v22 = v86;
    }
    uint64_t v23 = v90;
    BOOL v24 = !v14;
    if (v89)
    {
      if (CFStringCompare(@"ff:ff:ff:ff:ff:ff", (CFStringRef)v89, 0LL)) {
        uint64_t v25 = v89;
      }
      else {
        uint64_t v25 = 0LL;
      }
    }

    else
    {
      uint64_t v25 = 0LL;
    }

    LOWORD(v67) = [v75 isStandalone6G];
    -[WiFiUsageMonitor setSteeringRequest:preferredChannel:preferredBand:preferredSSID:targetSSIDDiffersFromCurrent:preferredBSS:ssidIsSplit:transitionCandidates:]( v20,  "setSteeringRequest:preferredChannel:preferredBand:preferredSSID:targetSSIDDiffersFromCurrent:preferredBSS:ssidIsSp lit:transitionCandidates:",  v19,  v22,  v17,  v23,  v24,  v25,  v67);
    uint64_t v36 = sub_100063560(a3);
    if (!v36)
    {
      v62 = objc_autoreleasePoolPush();
      id v12 = v70;
      if (qword_100219F60) {
        [qword_100219F60 WFLog:@"__WiFiManagerBssSteerCallback: Known networks cache is Null!"];
      }
      objc_autoreleasePoolPop(v62);
      BOOL v33 = 0LL;
      id v34 = 0LL;
      CFNumberRef v35 = 0LL;
LABEL_110:
      CFBooleanRef v13 = v75;
      if (!v12) {
        goto LABEL_131;
      }
      goto LABEL_130;
    }

    __int16 v37 = (const __CFArray *)v36;
    if (v90)
    {
      id v34 = sub_100094CE8((const __CFString *)v90);
      __int16 v38 = objc_autoreleasePoolPush();
      if (!v34)
      {
        if (qword_100219F60) {
          [qword_100219F60 WFLog:@"%s: Failed in creating the network!" message:3];
        }
        objc_autoreleasePoolPop(v38);
        BOOL v33 = 0LL;
        id v34 = 0LL;
        goto LABEL_109;
      }

      if (qword_100219F60) {
        [(id)qword_100219F60 WFLog:3, "%s: Current Network ssid is :%@", "__WiFiManagerBssSteerCallback", sub_100095BC8(v11) message];
      }
      objc_autoreleasePoolPop(v38);
      if (!v11)
      {
        int v42 = 0;
        int v41 = 0;
LABEL_86:
        CFTypeRef v43 = objc_autoreleasePoolPush();
        if (qword_100219F60)
        {
          v44 = "doFullJoin";
          if (v42) {
            v44 = "doRoam";
          }
          [qword_100219F60 WFLog:@"%s:%d %s !\n" message:3];
        }

        objc_autoreleasePoolPop(v43);
        if ((v42 & 1) != 0)
        {
          if (v41)
          {
            uint64_t v45 = objc_autoreleasePoolPush();
            id v12 = v70;
            CFBooleanRef v13 = v75;
            if (qword_100219F60) {
              [qword_100219F60 WFLog:@"%s: Try any Roam candidate" message:3];
            }
            objc_autoreleasePoolPop(v45);
            uint64_t v46 = 0LL;
            goto LABEL_113;
          }

          uint64_t v46 = (const __CFString *)CFDictionaryGetValue(a4, @"BSSID");
          id v12 = v70;
          CFBooleanRef v13 = v75;
          if (v46)
          {
LABEL_113:
            if (v87)
            {
              if (number)
              {
                v53 = objc_autoreleasePoolPush();
                if (qword_100219F60) {
                  [qword_100219F60 WFLog:@"%s: Band Preference :%u!" message:3];
                }
                objc_autoreleasePoolPop(v53);
              }

              v54 = objc_autoreleasePoolPush();
              if (qword_100219F60) {
                [qword_100219F60 WFLog:@"Calling for Roam" message:3];
              }
              objc_autoreleasePoolPop(v54);
              v85 = (void *)CFDictionaryGetValue(a4, @"CHANNEL_FLAGS");
              v55 = (const __CFNumber *)CFDictionaryGetValue(a4, @"CHANNEL");
              if (!v85)
              {
                CFNumberRef v35 = 0LL;
                if (v55) {
LABEL_151:
                }
                  CFNumberGetValue(v55, kCFNumberSInt8Type, &v84);
LABEL_152:
                sub_1000DFCCC(v73, (int)v71, v46, v84, SHIDWORD(v84), v79, v77);
                v59 = objc_autoreleasePoolPush();
                if (qword_100219F60) {
                  [(id)qword_100219F60 WFLog:3, "%s:Cached steering request bssid (%@), channel (%u), band (%d), channel flags(0x%x), roam flags(0x%x)", "__WiFiManagerBssSteerCallback", v46, v84, v79, HIDWORD(v84), v77 message];
                }
                objc_autoreleasePoolPop(v59);
                id v12 = v70;
                CFBooleanRef v13 = v75;
                if (_os_feature_enabled_impl("CoreWiFi", "SSIDTransition") && v69 == 3)
                {
                  if (v83 == 2) {
                    uint64_t v60 = 55LL;
                  }
                  else {
                    uint64_t v60 = 54LL;
                  }
                  sub_10006FFDC(a3, v60);
                }

                else
                {
                  sub_1000EDFE8((uint64_t)v73, v46, (unint64_t)v87, v35, number, v78);
                }

                BOOL v33 = 0LL;
                if (!v70) {
                  goto LABEL_131;
                }
                goto LABEL_130;
              }

              CFNumberGetValue((CFNumberRef)v85, kCFNumberIntType, (char *)&v84 + 4);
              if ((v84 & 0x800000000LL) != 0)
              {
                char v56 = 1;
              }

              else
              {
                if ((v84 & 0x1000000000LL) == 0) {
                  goto LABEL_146;
                }
                char v56 = 2;
              }

              unsigned __int8 v83 = v56;
LABEL_146:
              if ((v84 & 0x200000000000LL) != 0) {
                unsigned __int8 v83 = 3;
              }
              CFNumberRef v35 = CFNumberCreate(kCFAllocatorDefault, kCFNumberCharType, &v83);
              v58 = objc_autoreleasePoolPush();
              if (qword_100219F60) {
                [qword_100219F60 WFLog:@"message" message:[NSString stringWithFormat:@"%s: WiFiRoam : Band for roam : %d", "__WiFiManagerBssSteerCallback", v83]];
              }
              objc_autoreleasePoolPop(v58);
              if (v55) {
                goto LABEL_151;
              }
              goto LABEL_152;
            }

            v66 = objc_autoreleasePoolPush();
            if (qword_100219F60) {
              [qword_100219F60 WFLog:@"Channel not present"];
            }
            objc_autoreleasePoolPop(v66);
            BOOL v33 = 0LL;
LABEL_68:
            CFNumberRef v35 = 0LL;
            if (!v12) {
              goto LABEL_131;
            }
            goto LABEL_130;
          }

          v63 = objc_autoreleasePoolPush();
          if (qword_100219F60) {
            [qword_100219F60 WFLog:@"%s: bssid is not present in Steering Dictionary" message:3];
          }
        }

        else
        {
          sub_100077EB8(v37, v34, &v88);
          if (v88 == -1)
          {
            v63 = objc_autoreleasePoolPush();
            if (qword_100219F60) {
              [(id)qword_100219F60 WFLog:3, "%s: %@ does not  exist", "__WiFiManagerBssSteerCallback", v90 message];
            }
          }

          else
          {
            ValueAtIndex = CFArrayGetValueAtIndex(v37, v88);
            unint64_t v48 = objc_autoreleasePoolPush();
            if (!ValueAtIndex)
            {
              if (qword_100219F60) {
                [(id)qword_100219F60 WFLog:3, "%s: %@ does not  exist in the Known Network List", "__WiFiManagerBssSteerCallback", v90 message];
              }
              v64 = v48;
              goto LABEL_191;
            }

            if (qword_100219F60) {
              [(id)qword_100219F60 WFLog:3, "known network ssid: %@: \n", sub_100095BC8(ValueAtIndex) message];
            }
            objc_autoreleasePoolPop(v48);
            if (v11) {
              sub_1000CE074((uint64_t)v73, v71, 1017LL, "__WiFiManagerBssSteerCallback", 8968LL);
            }
            v49 = sub_100094E60((uint64_t)kCFAllocatorDefault, (uint64_t)ValueAtIndex);
            if (v49)
            {
              BOOL v33 = v49;
              v50 = CFDictionaryGetValue(a4, @"BSSID");
              if (v50)
              {
                v51 = v50;
                if (v87) {
                  sub_10009582C((uint64_t)v33, @"CHANNEL", v87);
                }
                sub_10009582C((uint64_t)v33, @"BSSID", v51);
                sub_10009582C((uint64_t)v33, @"FORCE_BSSID", kCFBooleanTrue);
                if (sub_1000951FC((uint64_t)v33, @"BSSID"))
                {
                  sub_100095524((uint64_t)v33, (uint64_t)ValueAtIndex);
                  v52 = objc_autoreleasePoolPush();
                  if (qword_100219F60) {
                    [qword_100219F60 WFLog:@"__WiFiManagerBssSteerCallback: found matching network in scan results, proceeding with association"];
                  }
                  objc_autoreleasePoolPop(v52);
                  context[0] = a3;
                  context[1] = 0xAAAAAAAA00000059LL;
                  void context[2] = v33;
                  void context[3] = 0LL;
                  CFSetApplyFunction(*(CFSetRef *)(a3 + 104), (CFSetApplierFunction)sub_1000662CC, context);
                }
              }

              else
              {
                v65 = objc_autoreleasePoolPush();
                if (qword_100219F60) {
                  [qword_100219F60 WFLog:@"message: bssid is not present in Steering Dictionary"];
                }
                objc_autoreleasePoolPop(v65);
              }

              goto LABEL_109;
            }

            v63 = objc_autoreleasePoolPush();
            if (qword_100219F60) {
              [qword_100219F60 WFLog:@"%s: Unable to copy known network" message:3];
            }
          }
        }

        v64 = v63;
LABEL_191:
        objc_autoreleasePoolPop(v64);
        BOOL v33 = 0LL;
LABEL_109:
        CFNumberRef v35 = 0LL;
        id v12 = v70;
        goto LABEL_110;
      }

      int v39 = sub_100099404((uint64_t)v11, (uint64_t)v34);
      __int128 v40 = objc_autoreleasePoolPush();
      if (!v39)
      {
        if (qword_100219F60) {
          [qword_100219F60 WFLog:@"%s: Different network from current - attempting Roam !\n" message:3];
        }
        int v41 = 1;
        goto LABEL_84;
      }

      if (qword_100219F60) {
        [qword_100219F60 WFLog:@"%s: Same network as current - doing Roam !\n" message:3];
      }
    }

    else
    {
      __int128 v40 = objc_autoreleasePoolPush();
      if (qword_100219F60) {
        [qword_100219F60 WFLog:@"message: %s: Ssid not present in the dictionary! - doing Roam\n" message:@"__WiFiManagerBssSteerCallback"];
      }
      id v34 = 0LL;
    }

    int v41 = 0;
LABEL_84:
    objc_autoreleasePoolPop(v40);
    int v42 = 1;
    goto LABEL_86;
  }

  v61 = objc_autoreleasePoolPush();
  if (qword_100219F60) {
    [qword_100219F60 WFLog:@"Failed to get steering request type\n"];
  }
  objc_autoreleasePoolPop(v61);
}

void sub_10008AA44(uint64_t a1, char a2, char a3, uint64_t a4)
{
  if (a4)
  {
    *(_BYTE *)(a4 + 1920) = a2;
    *(_BYTE *)(a4 + 1921) = a3;
  }

void sub_10008AA54(uint64_t a1, const void *a2, uint64_t a3, uint64_t a4)
{
  if (a4)
  {
    int v7 = objc_autoreleasePoolPush();
    if (qword_100219F60) {
      [(id)qword_100219F60 WFLog:3, "%s: type: %d network: %@", "__WiFiManagerUserNotificationPresentationCallback", a3, a2 message];
    }
    objc_autoreleasePoolPop(v7);
    int v8 = -[NSDictionary initWithObjectsAndKeys:]( objc_alloc(&OBJC_CLASS___NSDictionary),  "initWithObjectsAndKeys:",  sub_100095BC8(a2),  @"ssid",  +[NSNumber numberWithInt:](&OBJC_CLASS___NSNumber, "numberWithInt:", a3),  @"notificationType",  @"notification",  @"type",  @"presentation",  @"trigger",  0LL);
    uint64_t context = v8;
    CFSetApplyFunction(*(CFSetRef *)(a4 + 136), (CFSetApplierFunction)sub_10008CC68, &context);
    if (v8) {
      CFRelease(v8);
    }
  }

void sub_10008AB8C(uint64_t a1, const void *a2, uint64_t a3, uint64_t a4, uint64_t a5)
{
  uint64_t v16 = 0LL;
  unint64_t v17 = &v16;
  uint64_t v18 = 0x2020000000LL;
  uint64_t v19 = 0LL;
  if (a5)
  {
    int v9 = objc_autoreleasePoolPush();
    if (qword_100219F60) {
      [(id)qword_100219F60 WFLog:3, "%s: type: %d response: %d network: %@", "__WiFiManagerUserNotificationResponseCallback", a3, a4, a2 message];
    }
    objc_autoreleasePoolPop(v9);
    if ((_DWORD)a3 != 1)
    {
      CFNumberRef v10 = objc_autoreleasePoolPush();
      if (qword_100219F60) {
        [qword_100219F60 WFLog:@"__WiFiManagerUserNotificationResponseCallback: no blacklisting for notification of type %d response %d" message:3 a3:a4];
      }
      goto LABEL_8;
    }

    if ((_DWORD)a4 == 5)
    {
      CFNumberRef v10 = objc_autoreleasePoolPush();
      if (qword_100219F60) {
        [qword_100219F60 WFLog:@"%s: not blacklisting system cancelled recommendation" message:3];
      }
LABEL_8:
      objc_autoreleasePoolPop(v10);
      goto LABEL_12;
    }

    if (a2)
    {
      CFTypeRef v11 = CFRetain(a2);
      v17[3] = (uint64_t)v11;
    }

    id v12 = *(dispatch_queue_s **)(a5 + 32);
    block[0] = _NSConcreteStackBlock;
    block[1] = 3221225472LL;
    block[2] = sub_10008CC70;
    block[3] = &unk_1001E43A0;
    block[4] = &v16;
    void block[5] = a5;
    int v14 = 1;
    int v15 = a4;
    dispatch_async(v12, block);
  }

void sub_10008AD0C(_Unwind_Exception *a1)
{
}

uint64_t sub_10008AD24(uint64_t a1, uint64_t a2)
{
  if (a2) {
    return *(void *)(a2 + 1936);
  }
  else {
    return 0LL;
  }
}

void sub_10008AD38(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  if (a2 && a3)
  {
    if (a4) {
      objc_autoreleasePoolPop(objc_autoreleasePoolPush());
    }
  }

void sub_10008AD5C(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  if (!a3)
  {
    CFNumberRef v10 = objc_autoreleasePoolPush();
    if (qword_100219F60) {
      [qword_100219F60 WFLog:@"%s: manager is NULL!"];
    }
    goto LABEL_13;
  }

  if (!a1)
  {
    CFNumberRef v10 = objc_autoreleasePoolPush();
    if (qword_100219F60) {
      [qword_100219F60 WFLog:@"%s: deviceManager is NULL!"];
    }
LABEL_13:
    objc_autoreleasePoolPop(v10);
    return;
  }

  int v8 = objc_autoreleasePoolPush();
  if (a4)
  {
    if (qword_100219F60) {
      [(id)qword_100219F60 WFLog:3, "%s: p2pThreadCoexEvent intf :%@", "__WiFiManagerP2pThreadCoexEventCallback", a2 message];
    }
    objc_autoreleasePoolPop(v8);
    context[0] = a3;
    context[1] = a1;
    void context[2] = a4;
    int v9 = objc_autoreleasePoolPush();
    if (qword_100219F60) {
      [qword_100219F60 WFLog:@"%s: p2pThreadCoexEvent deviceManager :%p" message:3,  "%s: p2pThreadCoexEvent deviceManager :%p",  "__WiFiManagerDispatchClientP2pThreadCoexEvent",  a1];
    }
    objc_autoreleasePoolPop(v9);
    CFSetApplyFunction(*(CFSetRef *)(a3 + 136), (CFSetApplierFunction)sub_10008CE28, context);
  }

  else
  {
    if (qword_100219F60) {
      [qword_100219F60 WFLog:@"%s: p2pThreadCoexEvent data is NULL!"];
    }
    objc_autoreleasePoolPop(v8);
  }

void sub_10008AEDC(int a1, int a2, CFArrayRef theArray, uint64_t a4)
{
  CFIndex Count = CFArrayGetCount(theArray);
  if (!a4)
  {
    v54 = objc_autoreleasePoolPush();
    if (qword_100219F60) {
      [qword_100219F60 WFLog:@"%s: null manager" message:4];
    }
    goto LABEL_64;
  }

  CFIndex v7 = Count;
  int v8 = *(const void **)(a4 + 2152);
  if (v8)
  {
    CFRelease(v8);
    *(void *)(a4 + 2152) = 0LL;
  }

  CFMutableArrayRef Mutable = CFArrayCreateMutable(kCFAllocatorDefault, 0LL, &kCFTypeArrayCallBacks);
  if (!Mutable)
  {
    *(void *)(a4 + 2152) = 0LL;
    *(_BYTE *)(a4 + 2160) = 0;
    return;
  }

  CFNumberRef v10 = Mutable;
  CFIndex v64 = v7;
  CFTypeRef v11 = (const __CFArray *)sub_100063560(a4);
  if (!v11) {
    goto LABEL_24;
  }
  id v12 = v11;
  uint64_t v65 = a4;
  CFIndex v13 = CFArrayGetCount(v11);
  CFIndex v14 = CFArrayGetCount(theArray);
  int v15 = objc_autoreleasePoolPush();
  if (qword_100219F60) {
    [qword_100219F60 WFLog:@"[NWTRANSIT]: %s: Colocated Network CFIndex Count = %ld " message:3 v14];
  }
  objc_autoreleasePoolPop(v15);
  if (v14 < 1)
  {
LABEL_19:
    CFIndex v23 = CFArrayGetCount(v10);
    a4 = v65;
    if (v23 >= 1)
    {
      CFIndex v24 = v23;
      for (CFIndex i = 0LL; i != v24; ++i)
      {
        ValueAtIndex = CFArrayGetValueAtIndex(v10, i);
        id v27 = objc_autoreleasePoolPush();
        if (qword_100219F60) {
          [(id)qword_100219F60 WFLog:3, "[NWTRANSIT]: Colocated Network %@ ", ValueAtIndex message];
        }
        objc_autoreleasePoolPop(v27);
      }
    }

    goto LABEL_24;
  }

  CFIndex v16 = 0LL;
  while (1)
  {
    unint64_t v17 = (const __CFDictionary *)CFArrayGetValueAtIndex(theArray, v16);
    if (v17) {
      break;
    }
LABEL_18:
    if (++v16 == v14) {
      goto LABEL_19;
    }
  }

  Value = (const __CFString *)CFDictionaryGetValue(v17, @"SSID_STR");
  if (Value)
  {
    if (v13 >= 1)
    {
      uint64_t v19 = Value;
      for (CFIndex j = 0LL; j != v13; ++j)
      {
        BOOL v21 = CFArrayGetValueAtIndex(v12, j);
        uint64_t v22 = (const __CFString *)sub_1000951FC((uint64_t)v21, @"SSID_STR");
        if (v22 && CFStringCompare(v22, v19, 0LL) == kCFCompareEqualTo) {
          CFArrayAppendValue(v10, v21);
        }
      }
    }

    goto LABEL_18;
  }

  v62 = objc_autoreleasePoolPush();
  if (qword_100219F60) {
    [qword_100219F60 WFLog:@"SSID is NULL!"];
  }
  objc_autoreleasePoolPop(v62);
  a4 = v65;
LABEL_24:
  *(void *)(a4 + 2152) = v10;
  CFNumberRef v28 = sub_10007D140((const __CFArray *)a4);
  if (v28)
  {
    uint64_t v29 = (uint64_t)v28;
    uint64_t v30 = (const __CFDictionary *)sub_1000951FC((uint64_t)v28, @"PRIVATE_MAC_ADDRESS");
    if (v30)
    {
      CFNumberRef v31 = v30;
      CFTypeID TypeID = CFDictionaryGetTypeID();
      if (TypeID == CFGetTypeID(v31)) {
        CFDictionaryGetValue(v31, @"PRIVATE_MAC_ADDRESS_TYPE");
      }
    }

    BOOL v33 = sub_1000951FC(v29, @"WiFiNetworkRouterMac");
    id v34 = objc_autoreleasePoolPush();
    if (qword_100219F60) {
      [(id)qword_100219F60 WFLog:3, "Router MAC Address: %@", v33 message];
    }
    objc_autoreleasePoolPop(v34);
    CFNumberRef v35 = sub_1000951FC(v29, @"WiFiNetworkRouterIP");
    uint64_t v36 = objc_autoreleasePoolPush();
    if (qword_100219F60) {
      [(id)qword_100219F60 WFLog:3, "Router IP Address: %@", v35 message];
    }
    objc_autoreleasePoolPop(v36);
  }

  __int16 v37 = (const __CFArray *)sub_100063560(a4);
  if (!v37) {
    goto LABEL_62;
  }
  __int16 v38 = v37;
  CFIndex v39 = CFArrayGetCount(v37);
  CFIndex v40 = CFArrayGetCount(v10);
  int v41 = objc_autoreleasePoolPush();
  if (qword_100219F60) {
    [qword_100219F60 WFLog:@"[NWTRANSIT]: %s: Run Colocated Networks against Private Filters. ColocatedNetwork CFIndex Count = %ld " message:@"__WiFiManagerColocatedCachePrivacyFilters" v40];
  }
  objc_autoreleasePoolPop(v41);
  if (!v40)
  {
LABEL_62:
    *(_BYTE *)(a4 + 2160) = 0;
    v54 = objc_autoreleasePoolPush();
    if (qword_100219F60) {
      objc_msgSend((id)qword_100219F60, "WFLog:message:", 3, "[NWTRANSIT]: Colocated Group is not valid", v63);
    }
LABEL_64:
    objc_autoreleasePoolPop(v54);
    return;
  }

  if (v40 >= 1)
  {
    CFIndex v42 = 0LL;
    while (1)
    {
      CFTypeRef v43 = CFArrayGetValueAtIndex(v10, v42);
      if (v43) {
        break;
      }
      if (v40 == ++v42) {
        goto LABEL_41;
      }
    }

    uint64_t v47 = (uint64_t)v43;
    if (v39 < 1) {
      goto LABEL_59;
    }
    CFIndex v48 = 0LL;
    while (1)
    {
      v49 = (const __CFDictionary *)CFArrayGetValueAtIndex(v38, v48);
      if (v39 == ++v48) {
        goto LABEL_59;
      }
    }

    if (v49)
    {
      v50 = objc_autoreleasePoolPush();
      if (qword_100219F60) {
        [(id)qword_100219F60 WFLog:3, "[NWTRANSIT]: Network %@ is present in Known Network list", v47 message];
      }
      objc_autoreleasePoolPop(v50);
      int v51 = sub_100098058((uint64_t)v49);
      unsigned int v52 = v51 | sub_100096D08(v49);
      v53 = objc_autoreleasePoolPush();
      if (v52)
      {
        if (qword_100219F60) {
          [(id)qword_100219F60 WFLog:3, "[NWTRANSIT]: Network %@ is Secure", v47 message];
        }
        objc_autoreleasePoolPop(v53);
        v57 = objc_autoreleasePoolPush();
        if (qword_100219F60) {
          [(id)qword_100219F60 WFLog:3, "[NWTRANSIT]: Network %@ has same Subnet", v47 message];
        }
        objc_autoreleasePoolPop(v57);
        v58 = objc_autoreleasePoolPush();
        if (qword_100219F60) {
          [(id)qword_100219F60 WFLog:3, "[NWTRANSIT]: Network %@ has same Auto-Join Policy", v47 message];
        }
        objc_autoreleasePoolPop(v58);
        v59 = (const __CFDictionary *)sub_1000951FC(0LL, @"PRIVATE_MAC_ADDRESS");
        if (v59)
        {
          uint64_t v60 = v59;
          CFTypeID v61 = CFDictionaryGetTypeID();
          if (v61 == CFGetTypeID(v60)) {
            CFDictionaryGetValue(v60, @"PRIVATE_MAC_ADDRESS_TYPE");
          }
        }

        v53 = objc_autoreleasePoolPush();
        if (qword_100219F60) {
          [(id)qword_100219F60 WFLog:3, "[NWTRANSIT]: Network %@ has same Privacy Policy", v47 message];
        }
      }

      else if (qword_100219F60)
      {
        [(id)qword_100219F60 WFLog:3, "[NWTRANSIT]: Network %@ is Not Secure", v47 message];
      }
    }

    else
    {
LABEL_59:
      v53 = objc_autoreleasePoolPush();
      if (qword_100219F60) {
        [(id)qword_100219F60 WFLog:3, "[NWTRANSIT]: Network %@ is not present in Known Network list", v47 message];
      }
    }

    objc_autoreleasePoolPop(v53);
    goto LABEL_62;
  }

void sub_10008B578(uint64_t a1, uint64_t a2)
{
  CFMutableStringRef Mutable = CFStringCreateMutable(kCFAllocatorDefault, 0LL);
  if (a2)
  {
    else {
      BOOL v5 = 1;
    }
    if (!v5)
    {
      if (CFStringCompare(Mutable, @"XZ", 0LL)
        && CFStringCompare(Mutable, &stru_1001EB6E0, 0LL)
        && CFStringCompare(Mutable, @"X0", 0LL)
        && CFStringCompare(Mutable, @"X2", 0LL)
        && CFStringCompare(Mutable, @"X3", 0LL))
      {
        int v6 = sub_1000DD7B4(a1, Mutable, 0);
        CFIndex v7 = objc_autoreleasePoolPush();
        if (v6)
        {
          if (qword_100219F60) {
            [(id)qword_100219F60 WFLog:3, "%s WiFiCC : Successfully initilaized country to HW on boot : %@", "__WiFiManagerUpdateCountryOnInitCallback", Mutable message];
          }
        }

        else if (qword_100219F60)
        {
          [(id)qword_100219F60 WFLog:3, "%s WiFiCC : Unable to initialize country to HW on boot : %@", "__WiFiManagerUpdateCountryOnInitCallback", Mutable message];
        }
      }

      else
      {
        CFIndex v7 = objc_autoreleasePoolPush();
        if (qword_100219F60) {
          [qword_100219F60 WFLog:@"WiFiCC : User Defaults does not have valid country code" message:3 v9 v10];
        }
      }

      objc_autoreleasePoolPop(v7);
      goto LABEL_20;
    }

    if (Mutable) {
LABEL_20:
    }
      CFRelease(Mutable);
  }

  else
  {
    int v8 = objc_autoreleasePoolPush();
    if (qword_100219F60) {
      [qword_100219F60 WFLog:@"%s: null manager" message:4];
    }
    objc_autoreleasePoolPop(v8);
    if (Mutable) {
      goto LABEL_20;
    }
  }

void sub_10008B748(int a1, int a2, CFDictionaryRef theDict, uint64_t a4)
{
  if (a4)
  {
    if (theDict)
    {
      Value = CFDictionaryGetValue(theDict, @"P2P_CC_COUNTRY");
      if (Value)
      {
        int v6 = Value;
        CFIndex v7 = objc_autoreleasePoolPush();
        if (qword_100219F60) {
          [(id)qword_100219F60 WFLog:3, "Country from Peer : [%@]", v6 message];
        }
        objc_autoreleasePoolPop(v7);
        int v8 = *(void **)(a4 + 200);
        if (v8) {
          [v8 updatePeerCountryCode:v6];
        }
      }
    }
  }

  else
  {
    uint64_t v9 = objc_autoreleasePoolPush();
    if (qword_100219F60) {
      [qword_100219F60 WFLog:@"__WiFiManagerPeerCountryEventCallback: null manager"];
    }
    objc_autoreleasePoolPop(v9);
  }

void sub_10008B834(uint64_t a1, int *a2, int a3, uint64_t a4, unsigned int a5, uint64_t a6)
{
  if (a6)
  {
    int v6 = *(void **)(a6 + 1560);
    if (v6)
    {
      if (a3 == 238)
      {
        int v8 = +[NSNumber numberWithInteger:](&OBJC_CLASS___NSNumber, "numberWithInteger:", *a2);
        uint64_t v9 = v6;
        uint64_t v10 = 238LL;
        goto LABEL_8;
      }

      if (a3 == 239)
      {
        int v8 = +[NSData dataWithBytes:length:](&OBJC_CLASS___NSData, "dataWithBytes:length:", a2, a5);
        uint64_t v9 = v6;
        uint64_t v10 = 239LL;
LABEL_8:
        [v9 handleEvent:v10 withData:v8 interface:a4];
      }
    }
  }

BOOL sub_10008B8BC(uint64_t a1)
{
  BOOL result = sub_10013C1A0(*(void *)(a1 + 32) + 1568LL, 0);
  *(_BYTE *)(*(void *)(a1 + 32) + 1576LL) = result;
  return result;
}

void sub_10008B8F8(uint64_t a1, uint64_t a2, int a3)
{
  int valuePtr = 0;
  CFMutableStringRef Mutable = CFDictionaryCreateMutable(0LL, 0LL, &kCFTypeDictionaryKeyCallBacks, &kCFTypeDictionaryValueCallBacks);
  if (Mutable)
  {
    CFIndex v7 = Mutable;
    int v8 = (const void **)&kCFBooleanTrue;
    if (!a3) {
      int v8 = (const void **)&kCFBooleanFalse;
    }
    CFDictionarySetValue(Mutable, @"BT_SCAN_INTERVAL_RELAX_ENABLE", *v8);
    CFNumberRef v9 = CFNumberCreate(kCFAllocatorDefault, kCFNumberSInt32Type, &valuePtr);
    if (v9)
    {
      CFNumberRef v10 = v9;
      CFDictionarySetValue(v7, @"BT_SCAN_INTERVAL_RELAX_REASON", v9);
      CFRelease(v10);
      context[0] = a1;
      context[1] = a2;
      void context[2] = v7;
      CFSetApplyFunction(*(CFSetRef *)(a1 + 136), (CFSetApplierFunction)sub_10008BC28, context);
      CFRelease(v7);
    }

    else
    {
      CFRelease(v7);
      id v12 = objc_autoreleasePoolPush();
      if (qword_100219F60) {
        [qword_100219F60 WFLog:@"__WiFiManagerDispatchClientBTScanIntervalRelaxEvent: Could not allocate reasonRef"];
      }
      objc_autoreleasePoolPop(v12);
    }
  }

  else
  {
    CFTypeRef v11 = objc_autoreleasePoolPush();
    if (qword_100219F60) {
      [qword_100219F60 WFLog:@"%s: Could not allocate BTScanIntervalRelax" message:4];
    }
    objc_autoreleasePoolPop(v11);
  }

void sub_10008BA70(uint64_t a1, int a2)
{
  if (*(unsigned __int8 *)(a1 + 1312) != a2)
  {
    uint64_t v4 = &kCFBooleanTrue;
    if (!a2) {
      uint64_t v4 = &kCFBooleanFalse;
    }
    keys[0] = @"appPolicyUUID";
    keys[1] = @"appPolicyState";
    CFBooleanRef v5 = *v4;
    values[0] = @"CARPLAY_UUID";
    values[1] = v5;
    CFDictionaryRef v6 = CFDictionaryCreate( kCFAllocatorDefault,  (const void **)keys,  (const void **)values,  2LL,  &kCFTypeDictionaryKeyCallBacks,  &kCFTypeDictionaryValueCallBacks);
    if (v6)
    {
      CFDictionaryRef v7 = v6;
      context[0] = a1;
      context[1] = 0xAAAAAAAA00000041LL;
      void context[2] = v6;
      void context[3] = 1LL;
      CFSetApplyFunction(*(CFSetRef *)(a1 + 104), (CFSetApplierFunction)sub_1000662CC, context);
      CFRelease(v7);
    }

    *(_BYTE *)(a1 + 1312) = a2 != 0;
  }

void sub_10008BB90(uint64_t a1, uint64_t a2, uint64_t a3)
{
  if (sub_10009E054(a3)) {
    sub_10008B8F8(a1, a2, 0);
  }
  CFBooleanRef v5 = objc_autoreleasePoolPush();
  if (qword_100219F60) {
    [qword_100219F60 WFLog:@"Lost link to Carplay network. Reset Carplay mode."];
  }
  objc_autoreleasePoolPop(v5);
  sub_10007CD78(a1, 0, 0LL);
  sub_10008BA70(a1, 0);
}

void sub_10008BC28(uint64_t a1, uint64_t a2)
{
  if (a2 && *(void *)a2 && *(void *)(a2 + 8))
  {
    sub_10003DA20(a1, *(void *)(a2 + 8), *(const void **)(a2 + 16));
  }

  else
  {
    v2 = objc_autoreleasePoolPush();
    if (qword_100219F60) {
      [qword_100219F60 WFLog:@"__WiFiManagerDispatchBTScanIntervalRelaxEvent: Invalid arguments"];
    }
    objc_autoreleasePoolPop(v2);
  }

void sub_10008BCAC(uint64_t a1, uint64_t a2)
{
  if (a2 && *(void *)(a2 + 8))
  {
    if (*(void *)a2) {
      sub_10003D8AC(a1, *(void *)(a2 + 8), *(const void **)(a2 + 16));
    }
  }

void sub_10008BCD0(uint64_t a1)
{
}

void sub_10008BD00(uint64_t a1, uint64_t a2)
{
  if (a2)
  {
    if (*(void *)a2) {
      sub_10003D8B8(a1, *(void *)a2, *(const void **)(a2 + 8));
    }
  }

void sub_10008BD1C(uint64_t a1, uint64_t a2)
{
  if (a2)
  {
    if (*(void *)a2) {
      sub_10003D8C4(a1, *(void *)a2, *(const void **)(a2 + 8));
    }
  }

void sub_10008BD38(uint64_t a1, uint64_t a2)
{
  if (a2)
  {
    if (*(void *)a2) {
      sub_10003D8D0(a1, *(void *)a2, *(const void **)(a2 + 8));
    }
  }

void sub_10008BD54(uint64_t a1, uint64_t a2)
{
  if (a2)
  {
    if (*(void *)a2) {
      sub_10003D948(a1, *(void *)a2, *(const void **)(a2 + 8));
    }
  }

void sub_10008BD70(uint64_t a1, const void *a2, uint64_t a3)
{
  if (!a2) {
    return;
  }
  uint64_t v4 = *(const __CFDictionary **)(a1 + 216);
  if (!v4) {
    return;
  }
  CFDictionaryRef v7 = sub_100095BC8(a2);
  Value = (const __CFString *)CFDictionaryGetValue(v4, v7);
  SCPreferencesSynchronize(*(SCPreferencesRef *)(a1 + 904));
  CFNumberRef v9 = SCNetworkSetCopyAll(*(SCPreferencesRef *)(a1 + 904));
  if (!v9) {
    return;
  }
  CFNumberRef v10 = v9;
  uint64_t v23 = a3;
  CFIndex Count = CFArrayGetCount(v9);
  if (Count < 1) {
    goto LABEL_21;
  }
  CFIndex v12 = Count;
  CFIndex v13 = 0LL;
  while (1)
  {
    ValueAtIndex = (const __SCNetworkSet *)CFArrayGetValueAtIndex(v10, v13);
    if (!ValueAtIndex) {
      goto LABEL_15;
    }
    int v15 = ValueAtIndex;
    CFStringRef Name = SCNetworkSetGetName(ValueAtIndex);
    unint64_t v17 = objc_autoreleasePoolPush();
    if (qword_100219F60) {
      [(id)qword_100219F60 WFLog:3, "%s: set for network %@: %@", "__WiFiManagerApplyNetworkSettings", sub_100095BC8(a2), Name message];
    }
    objc_autoreleasePoolPop(v17);
    if (!Value) {
      break;
    }
    if (SCNetworkSetGetSetID(v15))
    {
      CFStringRef SetID = SCNetworkSetGetSetID(v15);
      uint64_t v19 = Value;
      goto LABEL_14;
    }

void sub_10008BF58(uint64_t a1)
{
  *(_BYTE *)(*(void *)(a1 + 40) + 1624) = [*(id *)(*(void *)(a1 + 40) + 1544) WiFiDriverTriggeredTTRHandler:*(void *)(a1 + 32)];
}

void sub_10008BF8C(uint64_t a1, int a2, int a3)
{
  unsigned int v6 = [+[WiFiXPCManager sharedXPCManager](WiFiXPCManager, "sharedXPCManager") isDisableAutoJoinActivityRegistered];
  if (!a2 || (CFSetGetCount(*(CFSetRef *)(a1 + 160)) ? (int v7 = 1) : (int v7 = v6), v7 == 1))
  {
    if (CFSetGetCount(*(CFSetRef *)(a1 + 160))) {
      int v8 = 1;
    }
    else {
      int v8 = v6;
    }
    if (v8 == 1)
    {
      CFNumberRef v9 = objc_autoreleasePoolPush();
      if (qword_100219F60) {
        [(id)qword_100219F60 WFLog:3, "%s: auto-join disabled by %@ (activity=%d)", "__WiFiManagerSetEnableInternal", *(void *)(a1 + 160), v6 message];
      }
      objc_autoreleasePoolPop(v9);
    }

    int v10 = 0;
    if (a3) {
      goto LABEL_17;
    }
LABEL_16:
    goto LABEL_17;
  }

  int v10 = 1;
  if (!a3) {
    goto LABEL_16;
  }
LABEL_17:
  CFTypeRef v11 = objc_autoreleasePoolPush();
  if (qword_100219F60)
  {
    CFIndex v12 = "Disabling";
    if (v10) {
      CFIndex v12 = "Enabling";
    }
    objc_msgSend((id)qword_100219F60, "WFLog:message:", 3, "%s automatic association", v12);
  }

  objc_autoreleasePoolPop(v11);
  *(_BYTE *)(a1 + 26) = v10;
  if (v10 && *(_BYTE *)(a1 + 1328))
  {
    CFIndex v13 = objc_autoreleasePoolPush();
    if (qword_100219F60) {
      [qword_100219F60 WFLog:@"__WiFiManagerSetEnableInternal: start the priority autojoin timer ###START_CAAJ"];
    }
    objc_autoreleasePoolPop(v13);
    CFIndex v14 = *(dispatch_source_s **)(a1 + 1344);
    dispatch_time_t v15 = dispatch_time(0LL, 30000000000LL);
    dispatch_source_set_timer(v14, v15, 0xFFFFFFFFFFFFFFFFLL, 0LL);
    int v10 = *(unsigned __int8 *)(a1 + 26);
  }

  uint64_t context = a1;
  unint64_t v18 = 0xAAAAAAAAAAAAAAAALL;
  if (v10) {
    int v16 = 6;
  }
  else {
    int v16 = 15;
  }
  LODWORD(v1_Block_object_dispose((const void *)(v1 - 80), 8) = v16;
  uint64_t v19 = 0LL;
  uint64_t v20 = 1LL;
  CFSetApplyFunction(*(CFSetRef *)(a1 + 104), (CFSetApplierFunction)sub_1000662CC, &context);
}

void sub_10008C168(uint64_t a1, uint64_t a2)
{
}

void sub_10008C174(uint64_t a1)
{
  int v2 = *(unsigned __int8 *)(a1 + 2073);
  if (*(_BYTE *)(a1 + 2073)) {
    uint64_t v3 = ((*(double *)(a1 + 2056) - *(double *)(a1 + 2048)) * 1000.0);
  }
  else {
    uint64_t v3 = 0xFFFFFFFFLL;
  }
  int v4 = *(unsigned __int8 *)(a1 + 2072);
  int v5 = *(unsigned __int8 *)(a1 + 2074);
  uint64_t v6 = *(unsigned int *)(a1 + 2064);
  uint64_t v7 = *(unsigned int *)(a1 + 2068);
  int v8 = objc_autoreleasePoolPush();
  if (qword_100219F60)
  {
    if (v5) {
      CFNumberRef v9 = "yes";
    }
    else {
      CFNumberRef v9 = "no";
    }
    if (v2) {
      int v10 = "yes";
    }
    else {
      int v10 = "no";
    }
    if (v4) {
      CFTypeRef v11 = "yes";
    }
    else {
      CFTypeRef v11 = "no";
    }
    [(id)qword_100219F60 WFLog:3, "%s: duration %u ms, session up ? %s, debounce succeeded ? %s, debounce timed out ? %s, reason %@(%d), subReason %d", "__WiFiManagerSubmitCarPlayLinkDownSuppressionMetrics", v3, v9, v10, v11, sub_10003B050(v6), v6, v7 message];
  }

  objc_autoreleasePoolPop(v8);
  char v18 = -86;
  v12[1] = -1431655766;
  v12[0] = v3;
  CFIndex v13 = sub_10003B050(v6);
  int v14 = v7;
  char v15 = v4;
  char v16 = v2;
  char v17 = v5;
  uint64_t v19 = @"Unknown";
  *(void *)&__int128 v20 = @"Unknown";
  *((void *)&v20 + 1) = @"Unknown";
  if (*(void *)(a1 + 2096))
  {
    uint64_t v19 = *(const __CFString **)(a1 + 2096);
    __int128 v20 = *(_OWORD *)(a1 + 2104);
  }

  sub_100038E04(v12);
}

void sub_10008C2D8(uint64_t a1, void *a2)
{
  int v4 = sub_1000ABA7C(a1);
  if (v4 != 5)
  {
    if (v4) {
      return;
    }
    int v5 = sub_1000ABA8C(a1);
    if ((v5 & 0xFFFFFFFE) == 2 && (byte_100219930 & 1) != 0)
    {
      uint64_t v6 = &dword_100219914;
    }

    else
    {
      if (v5 != 1)
      {
LABEL_11:
        byte_100219930 = 0;
        int v8 = sub_1000ABA8C(a1);
        if (v8 == 2)
        {
          a2[88] = 1LL;
        }

        else if (v8 == 1)
        {
          uint64_t v9 = sub_100091DAC(a1);
          if (v9)
          {
            int v10 = (void *)v9;
            CFAbsoluteTime Current = CFAbsoluteTimeGetCurrent();
            CFDateRef v12 = CFDateCreate(kCFAllocatorDefault, Current);
            if (v12)
            {
              CFDateRef v13 = v12;
              sub_10009A194(v10, 1, v12);
              CFRelease(v13);
            }

            int v14 = objc_autoreleasePoolPush();
            if (qword_100219F60) {
              [(id)qword_100219F60 WFLog:3, "Attempting addition of %@.", sub_100095BC8(v10) message];
            }
            objc_autoreleasePoolPop(v14);
            sub_100072038((uint64_t)a2, v10, 6LL);
          }

          else
          {
            char v15 = objc_autoreleasePoolPush();
            if (qword_100219F60) {
              [(id)qword_100219F60 WFLog:3 message:"Received Ask to join response accepted but network object is NULL"];
            }
            objc_autoreleasePoolPop(v15);
          }
        }

        char v16 = (const void *)a2[24];
        if (v16)
        {
          CFRelease(v16);
          a2[24] = 0LL;
        }

        return;
      }

      uint64_t v6 = &dword_100219918;
    }

    ++*v6;
    goto LABEL_11;
  }

  if (sub_1000ABA8C(a1) == 2)
  {
    uint64_t v7 = (dispatch_queue_s *)a2[4];
    block[0] = _NSConcreteStackBlock;
    block[1] = 3221225472LL;
    block[2] = sub_10008C4B4;
    block[3] = &unk_1001E2620;
    block[4] = a2;
    dispatch_async(v7, block);
  }

void sub_10008C4B4(uint64_t a1)
{
  CFAbsoluteTime Current = CFAbsoluteTimeGetCurrent();
  CFDateRef v3 = CFDateCreate(kCFAllocatorDefault, Current);
  int v4 = sub_10003AEF8((uint64_t)v3, 5LL, 0LL, 0LL);
  int v5 = objc_autoreleasePoolPush();
  if (qword_100219F60) {
    [qword_100219F60 WFLog:@"%s: user chose to mute join recommendation" message:3];
  }
  objc_autoreleasePoolPop(v5);
  sub_10006B818(*(void *)(a1 + 32), *(_DWORD *)(*(void *)(a1 + 32) + 1816LL), v4, 0);
  if (v4) {
    CFRelease(v4);
  }
  if (v3) {
    CFRelease(v3);
  }
}

uint64_t sub_10008C588(uint64_t a1, uint64_t a2)
{
  uint64_t result = sub_10003C1D4(a1, *(void *)(a2 + 8));
  if (!(_DWORD)result) {
    *(_DWORD *)a2 = 0;
  }
  return result;
}

void sub_10008C5B4(CFTypeRef cf, uint64_t a2)
{
  uint64_t v4 = *(void *)(a2 + 40);
  if (!*(void *)(a2 + 24)
    || (int v5 = sub_10003BED4((uint64_t)cf),
        LODWORD(valuePtr[0]) = -1431655766,
        CFNumberGetValue(*(CFNumberRef *)(a2 + 24), kCFNumberIntType, valuePtr),
        LODWORD(valuePtr[0]) != v5))
  {
    if (*(void *)(v4 + 32))
    {
      valuePtr[0] = 0LL;
      valuePtr[1] = valuePtr;
      valuePtr[2] = 0x2020000000LL;
      CFTypeRef v16 = (CFTypeRef)0xAAAAAAAAAAAAAAAALL;
      CFTypeRef v16 = CFRetain(cf);
      v13[0] = 0LL;
      v13[1] = v13;
      v13[2] = 0x2020000000LL;
      CFTypeRef v14 = (CFTypeRef)0xAAAAAAAAAAAAAAAALL;
      CFTypeRef v14 = CFRetain(*(CFTypeRef *)(a2 + 32));
      v11[0] = 0LL;
      v11[1] = v11;
      v11[2] = 0x2020000000LL;
      CFTypeRef v12 = (CFTypeRef)0xAAAAAAAAAAAAAAAALL;
      CFTypeRef v12 = CFRetain(*(CFTypeRef *)(a2 + 8));
      v9[0] = 0LL;
      v9[1] = v9;
      v9[2] = 0x2020000000LL;
      CFTypeRef v10 = (CFTypeRef)0xAAAAAAAAAAAAAAAALL;
      CFTypeRef v10 = CFRetain(*(CFTypeRef *)(a2 + 16));
      uint64_t v6 = *(dispatch_queue_s **)(v4 + 32);
      block[0] = _NSConcreteStackBlock;
      block[1] = 3221225472LL;
      block[2] = sub_10008C7C4;
      block[3] = &unk_1001E4378;
      block[4] = valuePtr;
      void block[5] = v13;
      void block[6] = v11;
      block[7] = v9;
      dispatch_async(v6, block);
      _Block_object_dispose(v9, 8);
      _Block_object_dispose(v11, 8);
      _Block_object_dispose(v13, 8);
      _Block_object_dispose(valuePtr, 8);
    }

    else
    {
      uint64_t v7 = objc_autoreleasePoolPush();
      if (qword_100219F60) {
        [qword_100219F60 WFLog:@"%s: queue not yet setup. Invoking callback directly." message:3];
      }
      objc_autoreleasePoolPop(v7);
      sub_10003D8E8((uint64_t)cf, *(void *)(a2 + 32), *(const void **)(a2 + 8), *(const void **)(a2 + 16));
    }
  }

void sub_10008C784( _Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, ...)
{
}

void sub_10008C7C4(void *a1)
{
  int v2 = *(const void **)(*(void *)(a1[4] + 8LL) + 24LL);
  if (v2)
  {
    CFRelease(v2);
    *(void *)(*(void *)(a1[4] + 8LL) + 24LL) = 0LL;
  }

  CFDateRef v3 = *(const void **)(*(void *)(a1[5] + 8LL) + 24LL);
  if (v3)
  {
    CFRelease(v3);
    *(void *)(*(void *)(a1[5] + 8LL) + 24LL) = 0LL;
  }

  uint64_t v4 = *(const void **)(*(void *)(a1[6] + 8LL) + 24LL);
  if (v4)
  {
    CFRelease(v4);
    *(void *)(*(void *)(a1[6] + 8LL) + 24LL) = 0LL;
  }

  int v5 = *(const void **)(*(void *)(a1[7] + 8LL) + 24LL);
  if (v5)
  {
    CFRelease(v5);
    *(void *)(*(void *)(a1[7] + 8LL) + 24LL) = 0LL;
  }

void sub_10008C890(uint64_t a1, unsigned __int8 *a2)
{
}

void sub_10008C8A0(uint64_t a1, uint64_t a2)
{
  if (a2 && *(void *)a2 && *(void *)(a2 + 8))
  {
    if (*(void *)(a2 + 24)) {
      sub_10003D9D8(a1, *(void *)(a2 + 8), *(const void **)(a2 + 16));
    }
  }

void sub_10008C8CC(uint64_t a1, uint64_t a2)
{
  if (a2 && *(void *)a2)
  {
    if (*(void *)(a2 + 8)) {
      sub_10003D9E4(a1, *(void *)(a2 + 8), *(const void **)(a2 + 16));
    }
  }

void sub_10008C8F0(uint64_t a1, uint64_t a2)
{
  if (a2 && *(void *)a2)
  {
    if (*(void *)(a2 + 8)) {
      sub_10003D9F0(a1, *(void *)(a2 + 8), *(const void **)(a2 + 16));
    }
  }

void sub_10008C914(uint64_t a1, uint64_t a2)
{
  if (a2 && *(void *)a2)
  {
    if (*(void *)(a2 + 8)) {
      sub_10003D9FC(a1, *(void *)(a2 + 8), *(const void **)(a2 + 16));
    }
  }

void sub_10008C938(uint64_t a1, uint64_t a2)
{
  if (a2 && *(void *)a2)
  {
    if (*(void *)(a2 + 8)) {
      sub_10003DA08(a1, *(void *)(a2 + 8), *(const void **)(a2 + 16));
    }
  }

void sub_10008C95C(uint64_t a1, uint64_t a2)
{
  if (a2 && *(void *)a2 && *(void *)(a2 + 8))
  {
    sub_10003DB00(a1, *(void *)(a2 + 8), *(_DWORD *)(a2 + 16));
  }

  else
  {
    int v2 = objc_autoreleasePoolPush();
    if (qword_100219F60) {
      [qword_100219F60 WFLog:@"Invalid arguments" message:@"__WiFiManagerDispatchCarPlayNetworkTypeChangeEvent"];
    }
    objc_autoreleasePoolPop(v2);
  }

void sub_10008C9E0(uint64_t a1, uint64_t a2)
{
  if (a2 && *(void *)a2 && *(void *)(a2 + 8))
  {
    sub_10003DA50(a1, *(void *)(a2 + 8), *(_DWORD *)(a2 + 16));
  }

  else
  {
    int v2 = objc_autoreleasePoolPush();
    if (qword_100219F60) {
      [qword_100219F60 WFLog:@"Invalid arguments" message:@"__WiFiManagerDispatchM1M4Handshake24GHzCountEvent"];
    }
    objc_autoreleasePoolPop(v2);
  }

void sub_10008CA64(uint64_t a1, uint64_t a2)
{
  if (a2)
  {
    if (*(void *)a2) {
      sub_10003DBB0(a1, *(void *)a2, *(const void **)(a2 + 8));
    }
  }

void sub_10008CA80(uint64_t a1, uint64_t a2)
{
  if (a2)
  {
    if (*(void *)a2) {
      sub_10003E104(a1, *(void *)a2, *(const void **)(a2 + 8));
    }
  }

void sub_10008CA9C(uint64_t a1, uint64_t a2)
{
}

void sub_10008CAA8(uint64_t a1, uint64_t a2)
{
}

void sub_10008CAB4(uint64_t a1, uint64_t a2)
{
  if (a1)
  {
    uint64_t v4 = *(const __CFDictionary **)(a2 + 16);
    if (v4)
    {
      Value = CFDictionaryGetValue(*(CFDictionaryRef *)(a2 + 16), @"WiFiHostApStateIdentifier");
      if (!Value || !CFEqual(Value, kCFBooleanTrue))
      {
        uint64_t v6 = CFDictionaryGetValue(v4, @"LINK_CHANGED_IS_LINKDOWN");
        if (v6)
        {
          if (CFEqual(v6, kCFBooleanTrue))
          {
            uint64_t v7 = (const __CFArray *)sub_10003C0F4(a1);
            if (v7)
            {
              int v8 = v7;
              if (CFArrayGetCount(v7) >= 1)
              {
                CFIndex v9 = 0LL;
                while (1)
                {
                  ValueAtIndex = CFArrayGetValueAtIndex(v8, v9);
                  if (ValueAtIndex)
                  {
                  }

                  if (++v9 >= CFArrayGetCount(v8)) {
                    goto LABEL_17;
                  }
                }

                MutableCFDictionaryRef Copy = CFArrayCreateMutableCopy(kCFAllocatorDefault, 0LL, v8);
                if (MutableCopy)
                {
                  CFTypeRef v12 = MutableCopy;
                  CFArrayRemoveValueAtIndex(MutableCopy, v9);
                  sub_10003C168(a1, v12);
                  CFRelease(v12);
                }

                else
                {
                  sub_10003C168(a1, 0LL);
                }
              }
            }
          }
        }
      }
    }
  }

void sub_10008CBF8(uint64_t a1)
{
}

void sub_10008CC04(uint64_t a1, uint64_t a2)
{
  if (a2)
  {
    if (*(void *)a2) {
      sub_10003DBBC(a1, *(void *)a2, *(const void **)(a2 + 8));
    }
  }

void sub_10008CC20(uint64_t a1, uint64_t a2)
{
  if (a2)
  {
    if (*(void *)a2) {
      sub_10003DE98(a1, *(void *)a2, *(const void **)(a2 + 8));
    }
  }

void sub_10008CC3C(uint64_t a1, uint64_t a2)
{
  if (a2)
  {
    if (*(void *)a2) {
      sub_10003DEA4(a1, *(void *)a2, *(const void **)(a2 + 8));
    }
  }

void sub_10008CC58(uint64_t a1, uint64_t a2)
{
}

void sub_10008CC68(uint64_t a1, const void **a2)
{
}

void sub_10008CC70(uint64_t a1)
{
  int v2 = sub_100095BC8(*(const void **)(*(void *)(*(void *)(a1 + 32) + 8LL) + 24LL));
  sub_100077FBC(*(void **)(a1 + 40), v2, 0LL, 0LL, *(unsigned int *)(a1 + 48));
  CFNumberRef v3 = CFNumberCreate(kCFAllocatorDefault, kCFNumberCFIndexType, (const void *)(a1 + 48));
  CFNumberRef v4 = CFNumberCreate(kCFAllocatorDefault, kCFNumberCFIndexType, (const void *)(a1 + 52));
  keys[0] = @"ssid";
  keys[1] = @"type";
  keys[2] = @"notificationType";
  keys[3] = @"response";
  keys[4] = @"trigger";
  values[0] = (void *)v2;
  values[1] = @"notification";
  values[2] = v3;
  values[3] = v4;
  values[4] = @"dismissal";
  CFDictionaryRef v5 = CFDictionaryCreate( kCFAllocatorDefault,  (const void **)keys,  (const void **)values,  5LL,  &kCFTypeDictionaryKeyCallBacks,  &kCFTypeDictionaryValueCallBacks);
  CFDictionaryRef v7 = v5;
  CFSetApplyFunction(*(CFSetRef *)(*(void *)(a1 + 40) + 136LL), (CFSetApplierFunction)sub_10008CC68, &v7);
  if (v5) {
    CFRelease(v5);
  }
  if (v4) {
    CFRelease(v4);
  }
  if (v3) {
    CFRelease(v3);
  }
  uint64_t v6 = *(const void **)(*(void *)(*(void *)(a1 + 32) + 8LL) + 24LL);
  if (v6)
  {
    CFRelease(v6);
    *(void *)(*(void *)(*(void *)(a1 + 32) + 8LL) + 24LL) = 0LL;
  }

void sub_10008CE28(uint64_t a1, uint64_t a2)
{
  if (a2 && *(void *)a2 && *(void *)(a2 + 8))
  {
    CFNumberRef v4 = objc_autoreleasePoolPush();
    if (qword_100219F60) {
      [qword_100219F60 WFLog:@"%s: p2pThreadCoexEvent client :%p" message:3,  "__WiFiManagerDispatchP2pThreadCoexEvent",  a1];
    }
    objc_autoreleasePoolPop(v4);
    sub_10003E1AC(a1, *(void *)(a2 + 8), *(const void **)(a2 + 16));
  }

  else
  {
    CFDictionaryRef v5 = objc_autoreleasePoolPush();
    if (qword_100219F60) {
      [qword_100219F60 WFLog:@"Invalid arguments" message:@"__WiFiManagerDispatchP2pThreadCoexEvent"];
    }
    objc_autoreleasePoolPop(v5);
  }

void sub_10008CEFC(uint64_t a1, const __CFArray *a2)
{
  CFNumberRef v4 = objc_alloc_init(&OBJC_CLASS___NSMutableDictionary);
  CFDictionaryRef v5 = +[NSNumber numberWithInteger:](&OBJC_CLASS___NSNumber, "numberWithInteger:", *(unsigned __int8 *)(a1 + 2160));
  uint64_t v6 = +[NSNumber numberWithInteger:](&OBJC_CLASS___NSNumber, "numberWithInteger:", *(void *)(a1 + 2168));
  if (a2)
  {
    CFDictionaryRef v7 = v6;
    CFIndex Count = CFArrayGetCount(a2);
    CFIndex v9 = objc_autoreleasePoolPush();
    if (qword_100219F60) {
      [qword_100219F60 WFLog:@"[NWTRANSIT]: %s: Colocated Network CFIndex Count = %ld " message:3, @"__WiFiManagerSetColocatedNetworks", Count];
    }
    objc_autoreleasePoolPop(v9);
    if (Count)
    {
      -[NSMutableDictionary setObject:forKey:](v4, "setObject:forKey:", a2, @"COLOCATED_NETWORK_GROUP");
      -[NSMutableDictionary setObject:forKey:](v4, "setObject:forKey:", v5, @"COLOCATED_NETWORK_GROUP_STATUS");
      -[NSMutableDictionary setObject:forKey:](v4, "setObject:forKey:", v7, @"COLOCATED_NETWORK_GROUP_SCOPE_ID");
    }
  }

  context[0] = a1;
  context[1] = 0xAAAAAAAA00000085LL;
  void context[2] = v4;
  void context[3] = 1LL;
  CFSetApplyFunction(*(CFSetRef *)(a1 + 104), (CFSetApplierFunction)sub_1000662CC, context);
}

void sub_10008D030(uint64_t a1, int a2)
{
  int v4 = a2;
  if (a1)
  {
    context[0] = a1;
    context[1] = 0xAAAAAAAA0000003ALL;
    void context[2] = &v4;
    void context[3] = 1LL;
    CFSetApplyFunction(*(CFSetRef *)(a1 + 104), (CFSetApplierFunction)sub_1000662CC, context);
    if (v4 == -536870272) {
      -[WiFiUserInteractionMonitor resetBackgroundApps]( +[WiFiUserInteractionMonitor sharedInstance](&OBJC_CLASS___WiFiUserInteractionMonitor, "sharedInstance"),  "resetBackgroundApps");
    }
  }

  else
  {
    int v2 = objc_autoreleasePoolPush();
    if (qword_100219F60) {
      [qword_100219F60 WFLog:@"%s: null manager ref" message:3];
    }
    objc_autoreleasePoolPop(v2);
  }

void sub_10008D0F4(uint64_t a1, io_registry_entry_t a2, int a3)
{
  if (!a1 || !a2) {
    return;
  }
  uint64_t v6 = (void *)sub_10003AFF4((uint64_t)"__WiFiManagerBatteryEventCallback");
  int v7 = *(unsigned __int8 *)(a1 + 322);
  uint64_t valuePtr = 0LL;
  properties[0] = 0LL;
  double Current = CFAbsoluteTimeGetCurrent();
  double v9 = *(double *)(a1 + 848);
  if (v9 != 0.0 && Current < v9) {
    goto LABEL_32;
  }
  uint64_t CFProperties = IORegistryEntryCreateCFProperties(a2, properties, kCFAllocatorDefault, 0);
  if ((_DWORD)CFProperties) {
    BOOL v12 = 1;
  }
  else {
    BOOL v12 = properties[0] == 0LL;
  }
  if (v12)
  {
    CFTypeRef v16 = objc_autoreleasePoolPush();
    if (qword_100219F60) {
      [qword_100219F60 WFLog:@"%s: IORegistryEntryCreateCFProperties failed with error %d" message:4, "__WiFiManagerGetBatteryLevel", CFProperties];
    }
    objc_autoreleasePoolPop(v16);
    goto LABEL_19;
  }

  Value = (const __CFNumber *)CFDictionaryGetValue(properties[0], @"CurrentCapacity");
  if (!Value
    || !CFNumberGetValue(Value, kCFNumberIntType, &valuePtr)
    || (CFTypeRef v14 = (const __CFNumber *)CFDictionaryGetValue(properties[0], @"MaxCapacity")) == 0LL
    || !CFNumberGetValue(v14, kCFNumberIntType, (char *)&valuePtr + 4))
  {
LABEL_19:
    int v15 = 0;
    goto LABEL_20;
  }

  int v15 = 1;
LABEL_20:
  if (properties[0])
  {
    CFRelease(properties[0]);
    properties[0] = 0LL;
  }

  unsigned int v17 = *(_DWORD *)(a1 + 840);
  if (v15)
  {
    unsigned int v18 = (100 * valuePtr) / HIDWORD(valuePtr);
    *(_DWORD *)(a1 + 840) = v18;
    *(double *)(a1 + 84_Block_object_dispose((const void *)(v15 - 96), 8) = Current + (double)(60 * (v18 / 0xA));
    if (v17 <= 9)
    {
      if (v18 < 0xA) {
        goto LABEL_32;
      }
    }

    else if (v18 >= 0xA)
    {
      goto LABEL_32;
    }
  }

  else
  {
    *(_DWORD *)(a1 + 840) = 0;
    *(void *)(a1 + 84_Block_object_dispose((const void *)(v15 - 96), 8) = 0LL;
    if (v17 <= 9) {
      goto LABEL_32;
    }
  }

  uint64_t v19 = objc_autoreleasePoolPush();
  if (qword_100219F60) {
    [qword_100219F60 WFLog:@"Battery state has changed. Remaining %d percent" message:3];
  }
  objc_autoreleasePoolPop(v19);
LABEL_32:
  if (a3 == -536723200)
  {
    CFTypeRef CFProperty = IORegistryEntryCreateCFProperty(a2, @"ExternalConnected", kCFAllocatorDefault, 0);
    int v21 = CFProperty;
    if (CFProperty && CFEqual(CFProperty, kCFBooleanTrue))
    {
      if (!*(_BYTE *)(a1 + 322))
      {
        uint64_t v22 = objc_autoreleasePoolPush();
        if (qword_100219F60) {
          [(id)qword_100219F60 WFLog:3 message:"External power source attached"];
        }
        objc_autoreleasePoolPop(v22);
        if ((*(_BYTE *)(a1 + 656) & 0xF) == 0 && *(_DWORD *)(a1 + 612) != 2) {
          sub_10006BB24(a1);
        }
        *(_BYTE *)(a1 + 322) = 1;
      }
    }

    else
    {
      if (*(_BYTE *)(a1 + 322))
      {
        *(_BYTE *)(a1 + 322) = 0;
        uint64_t v23 = objc_autoreleasePoolPush();
        if (qword_100219F60) {
          [(id)qword_100219F60 WFLog:3 message:"External power source removed"];
        }
        objc_autoreleasePoolPop(v23);
        if ((*(_BYTE *)(a1 + 656) & 0xF) == 0) {
          sub_100070330(a1);
        }
      }

      if (!v21)
      {
        if (!*(_DWORD *)(a1 + 840))
        {
          CFIndex v24 = objc_autoreleasePoolPush();
          if (qword_100219F60) {
            [qword_100219F60 WFLog:@"%s: externally powered platform. Cancelling disassociation timer." message:3];
          }
          objc_autoreleasePoolPop(v24);
          if ((*(_BYTE *)(a1 + 656) & 0xF) == 0 && *(_DWORD *)(a1 + 612) != 2) {
            sub_10006BB24(a1);
          }
          *(_BYTE *)(a1 + 322) = 1;
        }

        goto LABEL_49;
      }
    }

    CFRelease(v21);
  }

void sub_10008D4D4(void *a1, int a2)
{
  BOOL v4 = sub_10007F0C8(a1, @"LoggingFileEnabled", byte_100219F58);
  if (v4) {
    CFBooleanRef v5 = kCFBooleanTrue;
  }
  else {
    CFBooleanRef v5 = kCFBooleanFalse;
  }
  sub_10006D08C(a1, @"LoggingFileEnabled", v5, a2);
  BOOL v6 = sub_10007F0C8(a1, @"LoggingFileClassC", byte_100219F59);
  if (v6) {
    CFBooleanRef v7 = kCFBooleanTrue;
  }
  else {
    CFBooleanRef v7 = kCFBooleanFalse;
  }
  sub_10006D08C(a1, @"LoggingFileClassC", v7, a2);
  v8[0] = (const __CFString *)sub_10006AA50(a1, @"LoggingLoggerFile");
  v8[1] = (const __CFString *)sub_10006AA50(a1, @"LoggingLoggerSize");
  void v8[2] = (const __CFString *)sub_10006AA50(a1, @"LoggingLoggerLevel");
  v8[3] = (const __CFString *)sub_10006AA50(a1, @"LoggingLoggerLifeSpan");
  v8[4] = (const __CFString *)sub_10006AA50(a1, @"LoggingLoggerPrivacy");
  sub_10005DE74((uint64_t)a1, v4, v6, v8);
}

BOOL sub_10008D634(void *a1)
{
  BOOL valuePtr = 1LL;
  int v2 = sub_10006AA50(a1, @"AllowEnable");
  if (!v2) {
    return valuePtr;
  }
  CFNumberRef v3 = v2;
  CFTypeID TypeID = CFNumberGetTypeID();
  if (TypeID == CFGetTypeID(v3))
  {
    CFNumberGetValue(v3, kCFNumberCFIndexType, &valuePtr);
    return valuePtr;
  }

  CFTypeID v5 = CFBooleanGetTypeID();
  if (v5 != CFGetTypeID(v3))
  {
    int v8 = objc_autoreleasePoolPush();
    if (qword_100219F60) {
      [qword_100219F60 WFLog:@"%s: cannot read BOOLean value" message:4];
    }
    goto LABEL_9;
  }

  BOOL valuePtr = v3 == kCFBooleanTrue;
  CFNumberRef v6 = CFNumberCreate(kCFAllocatorDefault, kCFNumberCFIndexType, &valuePtr);
  if (v6)
  {
    CFNumberRef v7 = v6;
    sub_10006D08C(a1, @"AllowEnable", v6, 1);
    CFRelease(v7);
  }

  else
  {
    double v9 = objc_autoreleasePoolPush();
    if (qword_100219F60) {
      [qword_100219F60 WFLog:@"__WiFiManagerReadPowerState: error creating CFNumber" message:4];
    }
    objc_autoreleasePoolPop(v9);
  }

  CFTypeRef v10 = (const __CFDictionary *)CFPreferencesCopyAppValue( @"original-network-state",  @"com.apple.preferences.network");
  if (v10)
  {
    CFTypeRef v11 = v10;
    MutableCFDictionaryRef Copy = CFDictionaryCreateMutableCopy(kCFAllocatorDefault, 0LL, v10);
    CFRelease(v11);
    if (MutableCopy)
    {
      uint64_t v21 = 1LL;
      Value = (const __CFBoolean *)CFDictionaryGetValue(MutableCopy, @"wifi-network");
      if (Value)
      {
        CFTypeRef v14 = Value;
        CFTypeID v15 = CFBooleanGetTypeID();
        if (v15 == CFGetTypeID(v14))
        {
          uint64_t v16 = 4LL;
          if (v14 == kCFBooleanTrue) {
            uint64_t v16 = 1LL;
          }
          uint64_t v21 = v16;
          CFNumberRef v17 = CFNumberCreate(kCFAllocatorDefault, kCFNumberCFIndexType, &v21);
          if (v17)
          {
            CFNumberRef v18 = v17;
            CFDictionarySetValue(MutableCopy, @"wifi-network", v17);
            CFPreferencesSetAppValue( @"original-network-state",  MutableCopy,  @"com.apple.preferences.network");
            CFRelease(v18);
          }

          else
          {
            uint64_t v19 = objc_autoreleasePoolPush();
            if (qword_100219F60) {
              [qword_100219F60 WFLog:@"%s: error creating CFNumber" message:4];
            }
            objc_autoreleasePoolPop(v19);
          }
        }
      }

      CFPreferencesAppSynchronize(@"com.apple.preferences.network");
      CFRelease(MutableCopy);
      return valuePtr;
    }

    int v8 = objc_autoreleasePoolPush();
    if (qword_100219F60) {
      [qword_100219F60 WFLog:@"%s: no previousSettings" message:4];
    }
LABEL_9:
    objc_autoreleasePoolPop(v8);
  }

  return valuePtr;
}

uint64_t sub_10008D8FC(uint64_t a1, unsigned __int8 *a2)
{
  return sub_10003C418(a1, *a2);
}

void sub_10008D904(uint64_t a1, uint64_t a2)
{
  if (a2 && *(void *)a2 && *(void *)(a2 + 8))
  {
    sub_10003DA2C(a1, *(void *)(a2 + 8), *(unsigned __int8 *)(a2 + 16));
  }

  else
  {
    int v2 = objc_autoreleasePoolPush();
    if (qword_100219F60) {
      [qword_100219F60 WFLog:@"__WiFiManagerDispatch24GHzNetworkInCriticalStateEvent: Invalid arguments"];
    }
    objc_autoreleasePoolPop(v2);
  }

void sub_10008D988(int a1, int a2, int a3, int a4, uint64_t a5, dispatch_queue_s **cf)
{
  if ((_DWORD)a5)
  {
    CFTypeRef v14 = objc_autoreleasePoolPush();
    if (qword_100219F60) {
      [qword_100219F60 WFLog:@"BT callback failure, result %d" message:4];
    }
  }

  else if (cf)
  {
    CFTypeID v10 = CFGetTypeID(cf);
    uint64_t v11 = qword_1002198E0;
    if (!qword_1002198E0)
    {
      pthread_once(&stru_100218EA0, (void (*)(void))sub_100060AA8);
      uint64_t v11 = qword_1002198E0;
    }

    if (v10 == v11)
    {
      BOOL v12 = cf[4];
      if (v12)
      {
        block[0] = _NSConcreteStackBlock;
        block[1] = 3221225472LL;
        block[2] = sub_10008DE18;
        block[3] = &unk_1001E43D8;
        int v17 = a3;
        int v18 = a4;
        block[4] = cf;
        int v19 = a2;
        int v20 = 0;
        dispatch_async(v12, block);
        return;
      }

      CFTypeRef v14 = objc_autoreleasePoolPush();
      if (qword_100219F60) {
        [qword_100219F60 WFLog:@"%s: manager queue null" message:4];
      }
    }

    else
    {
      CFTypeRef v14 = objc_autoreleasePoolPush();
      if (qword_100219F60) {
        [qword_100219F60 WFLog:@"BT callback failure, invalid userData type"];
      }
    }
  }

  else
  {
    CFTypeRef v14 = objc_autoreleasePoolPush();
    if (qword_100219F60) {
      [qword_100219F60 WFLog:@"%s: BT callback failure, null userData" message:4];
    }
  }

  objc_autoreleasePoolPop(v14);
}

void sub_10008DB34(uint64_t a1, int a2, uint64_t a3, dispatch_queue_s **cf)
{
  if ((_DWORD)a3)
  {
    uint64_t v11 = objc_autoreleasePoolPush();
    if (qword_100219F60) {
      [qword_100219F60 WFLog:@"__WiFiManagerBluetoothLocalDeviceCallback: BT callback failure, result %d" message:4, "%s: BT callback failure, result %d", "__WiFiManagerBluetoothLocalDeviceCallback", a3];
    }
  }

  else if (cf)
  {
    CFTypeID v7 = CFGetTypeID(cf);
    uint64_t v8 = qword_1002198E0;
    if (!qword_1002198E0)
    {
      pthread_once(&stru_100218EA0, (void (*)(void))sub_100060AA8);
      uint64_t v8 = qword_1002198E0;
    }

    if (v7 == v8)
    {
      double v9 = cf[4];
      if (v9)
      {
        block[0] = _NSConcreteStackBlock;
        block[1] = 3221225472LL;
        block[2] = sub_10008DEFC;
        block[3] = &unk_1001E4418;
        int v14 = a2;
        block[4] = cf;
        void block[5] = a1;
        dispatch_async(v9, block);
        return;
      }

      uint64_t v11 = objc_autoreleasePoolPush();
      if (qword_100219F60) {
        [qword_100219F60 WFLog:@"%s: manager queue null" message:4];
      }
    }

    else
    {
      uint64_t v11 = objc_autoreleasePoolPush();
      if (qword_100219F60) {
        [qword_100219F60 WFLog:@"BT callback failure, invalid userData type"];
      }
    }
  }

  else
  {
    uint64_t v11 = objc_autoreleasePoolPush();
    if (qword_100219F60) {
      [qword_100219F60 WFLog:@"%s: BT callback failure, null userData" message:4];
    }
  }

  objc_autoreleasePoolPop(v11);
}

void *sub_10008DCD8(void *result)
{
  *(void *)(result[4] + 872LL) = result[5];
  *(void *)(result[4] + 880LL) = result[6];
  *(_DWORD *)(result[4] + 892LL) = 0;
  return result;
}

void sub_10008DCF8(uint64_t a1)
{
  uint64_t v2 = *(void *)(a1 + 32);
  *(_DWORD *)(v2 + 892) = 0;
  sub_10008DDB4(v2, 102, 0);
  *(void *)(*(void *)(a1 + 32) + 872LL) = 0LL;
  *(void *)(*(void *)(a1 + 32) + 880LL) = 0LL;
  if (*(_DWORD *)(a1 + 40) == 2)
  {
    CFNumberRef v6 = sub_10006A2E8;
    uint64_t v3 = BTSessionAttachWithQueue("com.apple.wifi.manager", &v6, *(void *)(a1 + 32), qword_100219F80);
    if ((_DWORD)v3)
    {
      uint64_t v4 = v3;
      CFTypeID v5 = objc_autoreleasePoolPush();
      if (qword_100219F60) {
        [qword_100219F60 WFLog:@"Unable to attach to Mobile Bluetooth result=0x%X" message:4];
      }
      objc_autoreleasePoolPop(v5);
    }
  }

void sub_10008DDB4(uint64_t a1, int a2, int a3)
{
  if (*(_DWORD *)(a1 + 900) != a2 || *(_DWORD *)(a1 + 896) != a3)
  {
    *(_DWORD *)(a1 + 900) = a2;
    *(_DWORD *)(a1 + 896) = a3;
    v3[0] = a1;
    v3[1] = 0xAAAAAAAA0000000CLL;
    void v3[2] = 0LL;
    v3[3] = 1LL;
    CFSetApplyFunction(*(CFSetRef *)(a1 + 104), (CFSetApplierFunction)sub_1000662CC, v3);
  }

void sub_10008DE18(uint64_t a1)
{
  if (!*(_DWORD *)(a1 + 40))
  {
    int v2 = *(_DWORD *)(a1 + 44);
    if (v2 == 11)
    {
      if (*(_DWORD *)(a1 + 52) && *(_DWORD *)(a1 + 48) != -1) {
        return;
      }
      CFNumberRef v6 = objc_autoreleasePoolPush();
      if (qword_100219F60) {
        [(id)qword_100219F60 WFLog:3 message:"Bluetooth Paging Stopped."];
      }
      objc_autoreleasePoolPop(v6);
      uint64_t v4 = *(void *)(a1 + 32);
      int v5 = *(_DWORD *)(v4 + 892) & 0xFFFFFFF7;
    }

    else
    {
      if (v2 || *(_DWORD *)(a1 + 48) != -1) {
        return;
      }
      uint64_t v3 = objc_autoreleasePoolPush();
      if (qword_100219F60) {
        [(id)qword_100219F60 WFLog:3 message:"Bluetooth Paging Started."];
      }
      objc_autoreleasePoolPop(v3);
      uint64_t v4 = *(void *)(a1 + 32);
      int v5 = *(_DWORD *)(v4 + 892) | 8;
    }

    *(_DWORD *)(v4 + 892) = v5;
    sub_10008DDB4(v4, 102, v5);
  }

void sub_10008DEFC(uint64_t a1)
{
  int v2 = *(_DWORD *)(a1 + 48);
  if (v2)
  {
    if (v2 == 7)
    {
      double v9 = objc_autoreleasePoolPush();
      if (qword_100219F60) {
        [(id)qword_100219F60 WFLog:3 message:"Bluetooth Inquiry Stopped."];
      }
      objc_autoreleasePoolPop(v9);
      uint64_t v4 = *(void *)(a1 + 32);
      int v5 = *(_DWORD *)(v4 + 892) & 0xFFFFFFFB;
    }

    else
    {
      if (v2 != 6) {
        return;
      }
      uint64_t v3 = objc_autoreleasePoolPush();
      if (qword_100219F60) {
        [(id)qword_100219F60 WFLog:3 message:"Bluetooth Inquiry Started."];
      }
      objc_autoreleasePoolPop(v3);
      uint64_t v4 = *(void *)(a1 + 32);
      int v5 = *(_DWORD *)(v4 + 892) | 4;
    }

    *(_DWORD *)(v4 + 892) = v5;
    sub_10008DDB4(v4, 102, v5);
  }

  else
  {
    int v10 = -1431655766;
    uint64_t Power = BTLocalDeviceGetPower(*(void *)(a1 + 40), &v10);
    if ((_DWORD)Power)
    {
      uint64_t v7 = Power;
      uint64_t v8 = objc_autoreleasePoolPush();
      if (qword_100219F60) {
        [qword_100219F60 WFLog:@"Failed to obtain Bluetooth Local Device power state.  result=0x%X" message:4 v7];
      }
      objc_autoreleasePoolPop(v8);
    }

    else
    {
      sub_10008DDB4(*(void *)(a1 + 32), 104, v10 != 0);
    }
  }

void sub_10008E038(uint64_t a1)
{
  uint64_t v2 = *(void *)(a1 + 192);
  if (v2)
  {
    if (sub_1000ABA7C(v2) == 5)
    {
      uint64_t v3 = objc_autoreleasePoolPush();
      if (qword_100219F60) {
        [qword_100219F60 WFLog:@"%s: pending notification is join recommendation stopping abort" message:3];
      }
      objc_autoreleasePoolPop(v3);
    }

    else
    {
      sub_1000ABAC8(*(void *)(a1 + 192));
      uint64_t v4 = *(const void **)(a1 + 192);
      if (v4)
      {
        CFRelease(v4);
        *(void *)(a1 + 192) = 0LL;
      }
    }
  }

void sub_10008E0D0(uint64_t a1)
{
}

void sub_10008E100(uint64_t a1)
{
  uint64_t v2 = *(_BYTE **)(a1 + 32);
  if (!v2[1128])
  {
    uint64_t v3 = objc_autoreleasePoolPush();
    if (qword_100219F60) {
      [qword_100219F60 WFLog:@"%s: Starting cloud sync engine after exceeding %ds waiting for auto-join attempt" message:3];
    }
    objc_autoreleasePoolPop(v3);
    uint64_t v4 = *(void *)(a1 + 32);
    *(_BYTE *)(v4 + 112_Block_object_dispose((const void *)(v15 - 96), 8) = 1;
    WiFiCloudSyncEngineScheduleWithQueue(*(void *)(v4 + 1136), qword_100219F88);
    CFRetain(*(CFTypeRef *)(*(void *)(a1 + 32) + 1136LL));
    block[0] = _NSConcreteStackBlock;
    block[1] = 3221225472LL;
    block[2] = sub_10008E1E4;
    block[3] = &unk_1001E2620;
    block[4] = *(void *)(a1 + 32);
    dispatch_async((dispatch_queue_t)qword_100219F88, block);
    uint64_t v2 = *(_BYTE **)(a1 + 32);
  }

  CFRelease(v2);
}

void sub_10008E1E4(uint64_t a1)
{
}

void sub_10008E214(id a1, BOOL a2)
{
  if (a2)
  {
    uint64_t v2 = objc_autoreleasePoolPush();
    if (qword_100219F60) {
      [qword_100219F60 WFLog:@"%s retrying to init deviceAnalyticsClient" message:3];
    }
    objc_autoreleasePoolPop(v2);
    [WiFiAnalyticsManager sharedWiFiAnalyticsManager].deviceAnalyticsClient
  }

void sub_10008E284(CFArrayRef theArray, const void *a2, CFIndex *a3)
{
  if (a3)
  {
    *a3 = -1LL;
    if (theArray)
    {
      CFIndex Count = CFArrayGetCount(theArray);
      if (Count)
      {
        CFIndex v7 = Count;
        if (Count < 1)
        {
          CFIndex v8 = 0LL;
        }

        else
        {
          CFIndex v8 = 0LL;
          while (1)
          {
            ValueAtIndex = CFArrayGetValueAtIndex(theArray, v8);
            if (v7 == ++v8) {
              goto LABEL_12;
            }
          }

          *a3 = v8;
        }

        if (v8 == v7)
        {
LABEL_12:
          int v10 = objc_autoreleasePoolPush();
          if (qword_100219F60) {
            [(id)qword_100219F60 WFLog:3, "%s: network %@ not found", "__GetNetworkWithSameSsid", sub_100095BC8(a2) message];
          }
          objc_autoreleasePoolPop(v10);
        }
      }
    }
  }

void sub_10008E388(uint64_t a1, const void **a2)
{
}

void sub_10008E390(uint64_t a1, uint64_t a2)
{
  uint64_t v2 = *(dispatch_queue_s **)(qword_100219908 + 32);
  v3[0] = _NSConcreteStackBlock;
  v3[1] = 3221225472LL;
  void v3[2] = sub_10008E57C;
  v3[3] = &unk_1001E2C30;
  void v3[4] = a2;
  v3[5] = qword_100219908;
  dispatch_async(v2, v3);
}

void sub_10008E3EC(void *a1, const void *a2)
{
  if (a1)
  {
    uint64_t v4 = (void *)sub_100095BC8(a2);
    id v5 = [v4 stringByAppendingString:sub_10009ECAC((uint64_t)a2)];
    CFNumberRef v6 = objc_autoreleasePoolPush();
    CFIndex v7 = objc_opt_new(&OBJC_CLASS___NSMutableDictionary);
    -[NSMutableDictionary setObject:forKeyedSubscript:]( v7,  "setObject:forKeyedSubscript:",  +[NSDate date](&OBJC_CLASS___NSDate, "date"),  @"timestamp");
    -[NSMutableDictionary setObject:forKeyedSubscript:]( v7,  "setObject:forKeyedSubscript:",  sub_10009ECAC((uint64_t)a2),  @"bundleID");
    CFIndex v8 = objc_autoreleasePoolPush();
    if (qword_100219F60) {
      [(id)qword_100219F60 WFLog:3, "%s: Add item:%@ at sessionKey:%@", "__WiFiManagerAddSessionBasedNetwork", v7, v5 message];
    }
    objc_autoreleasePoolPop(v8);
    double v9 = (void *)a1[173];
    if (v9) {
      int v10 = (NSMutableDictionary *)[v9 mutableCopy];
    }
    else {
      int v10 = objc_opt_new(&OBJC_CLASS___NSMutableDictionary);
    }
    uint64_t v11 = v10;
    -[NSMutableDictionary setObject:forKeyedSubscript:](v11, "setObject:forKeyedSubscript:", v7, v5);
    sub_10006D08C(a1, @"SessionBasedNetworkList", v11, 0);
    sub_1000806E0((uint64_t)a1, v11);
  }

  else
  {
    CFNumberRef v6 = objc_autoreleasePoolPush();
    if (qword_100219F60) {
      [qword_100219F60 WFLog:@"__WiFiManagerAddSessionBasedNetwork: manager ref is null"];
    }
  }

  objc_autoreleasePoolPop(v6);
}

void sub_10008E57C(uint64_t a1)
{
  uint64_t v2 = objc_autoreleasePoolPush();
  if (qword_100219F60) {
    [qword_100219F60 WFLog:@"%s: response %lu" message:3];
  }
  objc_autoreleasePoolPop(v2);
  uint64_t v3 = *(void *)(a1 + 40);
  if (v3)
  {
    ValueAtIndex = (void *)CFArrayGetValueAtIndex(*(CFArrayRef *)(v3 + 1456), 0LL);
    if (ValueAtIndex)
    {
      id v5 = ValueAtIndex;
      id v6 = [ValueAtIndex network];
      if (v6)
      {
        CFIndex v7 = v6;
        id v8 = [v5 client];
        uint64_t v9 = *(void *)(a1 + 32);
        if (v9 == 3)
        {
          CFDateRef v13 = objc_autoreleasePoolPush();
          if (qword_100219F60) {
            [(id)qword_100219F60 WFLog:3 message:"System cancelled user notification."];
          }
          objc_autoreleasePoolPop(v13);
          char v14 = 0;
          uint64_t v15 = 2LL;
        }

        else if (v9 == 1)
        {
          uint64_t v16 = objc_autoreleasePoolPush();
          if (qword_100219F60) {
            [(id)qword_100219F60 WFLog:3 message:"User did not give consent to add network."];
          }
          objc_autoreleasePoolPop(v16);
          char v14 = 0;
          uint64_t v15 = 1LL;
        }

        else if (v9)
        {
          char v14 = 0;
          uint64_t v15 = 0x7FFFFFFFLL;
        }

        else
        {
          uint64_t v10 = 25LL;
          if ([v5 originator] != 1)
          {
            else {
              uint64_t v10 = 8LL;
            }
          }

          uint64_t v11 = sub_1000A5ADC((uint64_t)v7);
          uint64_t v12 = objc_autoreleasePoolPush();
          if (qword_100219F60) {
            objc_msgSend( (id)qword_100219F60,  "WFLog:message:",  3,  "User gave consent to add network (sessionBased=%d, isAccessory=%d)",  objc_msgSend(v5, "sessionBased"),  v11 != 0);
          }
          objc_autoreleasePoolPop(v12);
          if (v11)
          {
            sub_100072038(*(void *)(a1 + 40), v7, v10);
            sub_10008E3EC(*(void **)(a1 + 40), v7);
          }

          else
          {
            unsigned int v17 = [v5 sessionBased];
            int v18 = *(void **)(a1 + 40);
            if (v17)
            {
              sub_10008E3EC(v18, v7);
              sub_10007307C(v7);
            }

            else
            {
              sub_100072038((uint64_t)v18, v7, v10);
            }
          }

          if (sub_100095318((BOOL)v7))
          {
            CFIndex v24 = objc_autoreleasePoolPush();
            if (qword_100219F60) {
              [qword_100219F60 WFLog:@"%s: skipping association for HS20 network" message:3];
            }
            objc_autoreleasePoolPop(v24);
            char v14 = 0;
            uint64_t v15 = 0LL;
          }

          else
          {
            uint64_t v19 = *(void *)(a1 + 40);
            if (!*(_DWORD *)(v19 + 324))
            {
              sub_10006EF98(v19, 1u, 0LL);
              uint64_t v19 = *(void *)(a1 + 40);
            }

            context[0] = v19;
            context[1] = 0xAAAAAAAA00000045LL;
            void context[2] = v7;
            void context[3] = 0LL;
            CFSetApplyFunction(*(CFSetRef *)(v19 + 104), (CFSetApplierFunction)sub_1000662CC, context);
            uint64_t v15 = 0x7FFFFFFFLL;
            char v14 = 1;
          }
        }

        if (*(void *)(*(void *)(a1 + 40) + 1408LL))
        {
          Main = CFRunLoopGetMain();
          CFRunLoopRemoveSource(Main, *(CFRunLoopSourceRef *)(*(void *)(a1 + 40) + 1408LL), kCFRunLoopDefaultMode);
        }

        if ((v14 & 1) == 0)
        {
          if (v8) {
            sub_10003DBC8((uint64_t)v8, *(void *)(a1 + 40), (uint64_t)v7, v15);
          }
          if ([v5 callback]) {
            ((void (*)(void, id, uint64_t, id))[v5 callback])( *(void *)(a1 + 40),  objc_msgSend(v5, "network"),  v15,  objc_msgSend(v5, "context"));
          }
          CFArrayRemoveValueAtIndex(*(CFMutableArrayRef *)(*(void *)(a1 + 40) + 1456LL), 0LL);
          sub_100075ED4(*(void *)(a1 + 40));
        }
      }
    }

    uint64_t v21 = *(void *)(a1 + 40);
    if (v21)
    {
      uint64_t v22 = *(const void **)(v21 + 1408);
      if (v22)
      {
        CFRelease(v22);
        *(void *)(*(void *)(a1 + 40) + 1408LL) = 0LL;
        uint64_t v21 = *(void *)(a1 + 40);
      }

      uint64_t v23 = *(const void **)(v21 + 1416);
      if (v23)
      {
        CFRelease(v23);
        *(void *)(*(void *)(a1 + 40) + 1416LL) = 0LL;
      }
    }
  }

void sub_10008E8F8(uint64_t a1)
{
  if (*(void *)(*(void *)(*(void *)(a1 + 32) + 8LL) + 24LL))
  {
    CNForgetSSID();
    uint64_t v2 = *(const void **)(*(void *)(*(void *)(a1 + 32) + 8LL) + 24LL);
    if (v2)
    {
      CFRelease(v2);
      *(void *)(*(void *)(*(void *)(a1 + 32) + 8LL) + 24LL) = 0LL;
    }
  }

void sub_10008E948(int a1, CFMutableStringRef theString)
{
  if ((a1 & 1) != 0)
  {
    CFStringAppend(theString, @" Pwr");
    if ((a1 & 2) == 0)
    {
LABEL_3:
      if ((a1 & 0x800000) == 0) {
        goto LABEL_4;
      }
      goto LABEL_24;
    }
  }

  else if ((a1 & 2) == 0)
  {
    goto LABEL_3;
  }

  CFStringAppend(theString, @" Lnk");
  if ((a1 & 0x800000) == 0)
  {
LABEL_4:
    if ((a1 & 4) == 0) {
      goto LABEL_5;
    }
    goto LABEL_25;
  }

LABEL_36:
  CFStringAppend(theString, @" WowEn");
  if ((a1 & 0x4000) == 0)
  {
LABEL_17:
    if ((a1 & 0x80000000) == 0) {
      goto LABEL_18;
    }
    goto LABEL_38;
  }

  if (!*v7
    || !CFDictionaryGetValueIfPresent(a3, @"DIRECTED_NETWORK", (const void **)&v32)
    || v32 == kCFBooleanTrue
    || (CFIndex Count = CFArrayGetCount(*(CFArrayRef *)(a5 + 3528))) == 0
    || !v8)
  {
LABEL_53:
    if (!v8) {
      return;
    }
    goto LABEL_54;
  }

  v36.length = Count;
  v36.location = 0LL;
  FirstIndexOfValue = CFArrayGetFirstIndexOfValue(*(CFArrayRef *)(a5 + 3528), v36, v8);
  if (FirstIndexOfValue != -1)
  {
    ValueAtIndex = CFArrayGetValueAtIndex(*(CFArrayRef *)(a5 + 3528), FirstIndexOfValue);
    if (ValueAtIndex)
    {
      if (sub_100097324(ValueAtIndex))
      {
        id v27 = objc_autoreleasePoolPush();
        if (qword_100219F60) {
          [(id)qword_100219F60 WFLog:4, "Correcting directed property for broadcast network %@", sub_100095BC8(v8) message];
        }
        objc_autoreleasePoolPop(v27);
        *CFIndex v7 = 0;
        sub_100097394((uint64_t)v8, 0);
        sub_1000DAB00((dispatch_queue_s **)a5, v8);
      }
    }
  }

  SCNetworkInterfaceSetPrimaryRank(a1[682], a4);
  unsigned int v17 = objc_autoreleasePoolPush();
  if (qword_100219F60)
  {
    if ((_DWORD)a4) {
      int v18 = "kSCNetworkServicePrimaryRankNever";
    }
    else {
      int v18 = "kSCNetworkServicePrimaryRankDefault";
    }
    [(id)qword_100219F60 WFLog:3, "%s: setting interface rank %s for network %@", "__WiFiDeviceManagerSetInterfaceRank", v18, sub_100095BC8(a2) message];
  }

  objc_autoreleasePoolPop(v17);
  if (v10) {
LABEL_42:
  }
    CFRelease(v10);
}

  v46[0] = @"IO80211InterfaceBGScanDynamicProfileStartTime";
  v47[0] = +[NSNumber numberWithUnsignedInteger:]( NSNumber,  "numberWithUnsignedInteger:",  [a3 scanFrequency]);
  v46[1] = @"IO80211InterfaceBGScanDynamicProfileScanFreq";
  uint64_t v25 = +[NSNumber numberWithUnsignedInteger:]( NSNumber,  "numberWithUnsignedInteger:",  [a3 scanFrequency]);
  v46[2] = @"IO80211InterfaceBGScanDynamicProfileDuration";
  v47[1] = v25;
  v47[2] = &off_100204C38;
  uint64_t v26 = sub_1000FB078( a1,  a2,  @"IO80211InterfaceBGDynamicProfileParams",  +[NSDictionary dictionaryWithObjects:forKeys:count:]( &OBJC_CLASS___NSDictionary,  "dictionaryWithObjects:forKeys:count:",  v47,  v46,  3LL));
  if (!(_DWORD)v26)
  {
LABEL_51:
    if (([a3 modifyMap] & 0x20) == 0
      || (v44 = @"IO80211InterfaceBGScanLostNetTO",
          uint64_t v45 = +[NSNumber numberWithUnsignedInteger:]( NSNumber,  "numberWithUnsignedInteger:",  [a3 lostNetworkScanCount]),  v26 = sub_1000FB078( a1,  a2,  @"IO80211InterfaceBGScanParams",  +[NSDictionary dictionaryWithObjects:forKeys:count:]( NSDictionary,  "dictionaryWithObjects:forKeys:count:",  &v45,  &v44,  1)),  !(_DWORD)v26))
    {
      uint64_t v26 = 0LL;
    }
  }

      if (++v11 == v8) {
        goto LABEL_39;
      }
    }
  }

  uint64_t v12 = 8LL;
LABEL_39:
  if (!CFArrayGetCount(v10))
  {
    CFNumberRef v32 = objc_autoreleasePoolPush();
    BOOL v33 = v44;
    if (qword_100219F60) {
      [qword_100219F60 WFLog:@"__WiFiDeviceManagerScanMRUNetworkChannels: No MRU channels"];
    }
    objc_autoreleasePoolPop(v32);
    if (v33) {
      CFRelease(v33);
    }
    CFRelease(v10);
    *(_DWORD *)(a1 + 3276) = v12;
    return sub_1001050F0(a1);
  }

  id v27 = v44;
  if (v44)
  {
    CFNumberRef v28 = objc_autoreleasePoolPush();
    if (qword_100219F60)
    {
      uint64_t v29 = +[NSString stringWithFormat:]( &OBJC_CLASS___NSString,  "stringWithFormat:",  @"%s",  -[NSString UTF8String]( +[NSString stringWithFormat:]( &OBJC_CLASS___NSString,  "stringWithFormat:",  @"{%@*} %@",  @"AUTOJOIN, SCAN",  +[NSString stringWithFormat:]( &OBJC_CLASS___NSString,  "stringWithFormat:",  @"Scanning(%s) for MRU Networks",  "Active")),  "UTF8String"));
      if (os_log_type_enabled((os_log_t)&_os_log_default, OS_LOG_TYPE_DEFAULT))
      {
        uint64_t v30 = -[NSString UTF8String]( +[NSString stringWithFormat:]( &OBJC_CLASS___NSString,  "stringWithFormat:",  @"[WiFiPolicy] %s",  -[NSString UTF8String](v29, "UTF8String")),  "UTF8String");
        *(_DWORD *)buf = 136446210;
        uint64_t v46 = v30;
        _os_log_impl( (void *)&_mh_execute_header,  (os_log_t)&_os_log_default,  OS_LOG_TYPE_DEFAULT,  "%{public}s",  buf,  0xCu);
      }
    }

    objc_autoreleasePoolPop(v28);
    if (os_log_type_enabled((os_log_t)&_os_log_default, OS_LOG_TYPE_DEFAULT))
    {
      *(_DWORD *)buf = 136315394;
      uint64_t v46 = "Active";
      uint64_t v47 = 2112;
      CFIndex v48 = v27;
      _os_log_impl( (void *)&_mh_execute_header,  (os_log_t)&_os_log_default,  OS_LOG_TYPE_DEFAULT,  "{AUTOJOIN, SCAN} Scanning(%s) for MRU Networks: %@",  buf,  0x16u);
    }

    CFRelease(v27);
  }

  CFNumberRef v31 = sub_1001036C0(a1, *(const __CFArray **)(a1 + 3544), v10, 0, 2LL);
  CFRelease(v10);
  if ((_DWORD)v31)
  {
LABEL_67:
    uint64_t v36 = objc_autoreleasePoolPush();
    __int16 v37 = (void *)qword_100219F60;
    if (qword_100219F60)
    {
      int v41 = (const char *)v31;
      __int16 v38 = "multi-stage auto-join: Error scanning for MRU Networks, err=%d";
      CFIndex v39 = 4LL;
      goto LABEL_69;
    }

    uint64_t v26 = +[NSError errorWithDomain:code:userInfo:]( &OBJC_CLASS___NSError,  "errorWithDomain:code:userInfo:",  v27,  v28,  0LL);
LABEL_23:
    CFRelease(v14);
    CFNumberRef v31 = v23;
    goto LABEL_24;
  }

  uint64_t v26 = +[NSError errorWithDomain:code:userInfo:]( &OBJC_CLASS___NSError,  "errorWithDomain:code:userInfo:",  NSPOSIXErrorDomain,  22LL,  0LL);
  CFNumberRef v31 = (const __CFArray *)v14;
LABEL_24:
  CFRelease(v31);
  if (!v26) {
    return;
  }
LABEL_25:
  if ([a3 response])
  {
    CFNumberRef v32 = (void (**)(id, NSError *, void))[a3 response];
    v32[2](v32, v26, 0LL);
  }
}

LABEL_38:
  CFStringAppend(theString, @" WeightAvgLQM");
  if ((a1 & 0x10000) == 0)
  {
LABEL_19:
    if ((a1 & 0x20000) == 0) {
      goto LABEL_20;
    }
    goto LABEL_40;
  }

  if (v20) {
    goto LABEL_39;
  }
}

        CFNumberRef v32 = CFArrayGetCount(Mutable);
        if (v32)
        {
          v71.location = 0LL;
          v71.length = v32;
          CFArraySortValues(Mutable, v71, (CFComparatorFunction)sub_10009C290, 0LL);
        }

        BOOL v33 = sub_1000A335C((uint64_t)v5);
        id v34 = [*(id *)(a1 + 6632) isNetworkInDenyListedState:3 scanResult:v33];
        if (!v5)
        {
          CFIndex v40 = 0;
LABEL_59:
          if (v32 >= 17)
          {
            v73.length = v32 - 16;
            v73.location = 16LL;
            CFArrayReplaceValues(Mutable, v73, 0LL, 0LL);
          }

          CFIndex v42 = CFArrayGetCount(Mutable);
          if (v42 >= 1)
          {
            CFTypeRef v43 = v42;
            v44 = 0LL;
            while (1)
            {
              uint64_t v45 = CFArrayGetValueAtIndex(Mutable, v44);
              uint64_t v46 = sub_100095BC8(v45);
              if ([*(id *)(a1 + 6632) isNetworkDenyListedForAutoJoinDueToTrigDisc:v33 RSSI:0 timestamp:0]
                && !CFSetContainsValue(*(CFSetRef *)(a1 + 3592), v45))
              {
                CFIndex v40 = 1;
              }

              if (([*(id *)(a1 + 6632) isNetworkDenyListedForAutoJoinDueToTrigDisc:v33 RSSI:0 timestamp:0] & 1) == 0 && CFSetContainsValue(*(CFSetRef *)(a1 + 3592), v45))
              {
                CFIndex v40 = 1;
              }

              if ((sub_1000DAF1C(a1, v45) || sub_10009CF04((uint64_t)v45) || sub_100095318((BOOL)v45))
                && !CFSetContainsValue(*(CFSetRef *)(a1 + 3600), v45))
              {
                break;
              }

              if (!sub_1000DAF1C(a1, v45)
                && !sub_10009CF04((uint64_t)v45)
                && !sub_100095318((BOOL)v45)
                && CFSetContainsValue(*(CFSetRef *)(a1 + 3600), v45))
              {
                uint64_t v47 = objc_autoreleasePoolPush();
                if (qword_100219F60) {
                  [(id)qword_100219F60 WFLog:3, "%s Force reprogram Bgscan list for clear hotspot %@", "WiFiDeviceManagerSetBackgroundScan", v46 message];
                }
                goto LABEL_81;
              }

              if (v43 == ++v44) {
                goto LABEL_82;
              }
            }

            uint64_t v47 = objc_autoreleasePoolPush();
            if (qword_100219F60) {
              [(id)qword_100219F60 WFLog:3, "%s Force reprogram Bgscan list for hotspot %@", "WiFiDeviceManagerSetBackgroundScan", v46 message];
            }
LABEL_81:
            objc_autoreleasePoolPop(v47);
            CFIndex v40 = 1;
          }

    CFIndex v24 = *(const void **)(a1 + 3728);
    if (v24)
    {
      CFRelease(v24);
      *(void *)(a1 + 372_Block_object_dispose((const void *)(v15 - 96), 8) = 0LL;
    }

    uint64_t v25 = *(const void **)(a1 + 3744);
    if (v25)
    {
      CFRelease(v25);
      *(void *)(a1 + 3744) = 0LL;
    }

    *(_BYTE *)(a1 + 3736) = 0;
    return;
  }

  int v20 = objc_autoreleasePoolPush();
  if (qword_100219F60) {
    objc_msgSend((id)qword_100219F60, "WFLog:message:", 3, "[NWTRANSIT]: Not Associated, Bail out");
  }
  objc_autoreleasePoolPop(v20);
}

uint64_t sub_10008EB4C(uint64_t a1, uint64_t a2)
{
  if (a2)
  {
    uint64_t v4 = objc_autoreleasePoolPush();
    if (qword_100219F60) {
      [(id)qword_100219F60 WFLog:3, "%s Device Analytics Store File:%@", "__WiFiManagerDeviceAnalyticsTestParamsAndCopyResponse_block_invoke", a2 message];
    }
    objc_autoreleasePoolPop(v4);
    *(void *)(*(void *)(*(void *)(a1 + 40) + 8LL) + 24LL) = -[NSString initWithString:]( objc_alloc(&OBJC_CLASS___NSString),  "initWithString:",  a2);
  }

  return dispatch_semaphore_signal(*(dispatch_semaphore_t *)(a1 + 32));
}

uint64_t sub_10008EBE0(uint64_t a1, uint64_t a2)
{
  if (a2)
  {
    *(void *)(*(void *)(*(void *)(a1 + 40) + 8LL) + 24LL) = -[NSDictionary initWithDictionary:]( objc_alloc(&OBJC_CLASS___NSDictionary),  "initWithDictionary:",  a2);
    uint64_t v4 = objc_autoreleasePoolPush();
    if (qword_100219F60) {
      [(id)qword_100219F60 WFLog:3, "%s: Updated configuration with %s", "__WiFiManagerDeviceAnalyticsTestParamsAndCopyResponse_block_invoke_2", -[NSString UTF8String]( +[NSString stringWithFormat:](NSString, "stringWithFormat:", @"%@", a2), "UTF8String") message];
    }
    objc_autoreleasePoolPop(v4);
  }

  return dispatch_semaphore_signal(*(dispatch_semaphore_t *)(a1 + 32));
}

void sub_10008EC98(uint64_t a1, uint64_t val)
{
  uint64_t state64 = 0LL;
  if (notify_is_valid_token(val))
  {
    notify_get_state(val, &state64);
    uint64_t v4 = *(dispatch_queue_s **)(a1 + 32);
    if (v4)
    {
      block[0] = _NSConcreteStackBlock;
      block[1] = 3221225472LL;
      block[2] = sub_10008EDA8;
      block[3] = &unk_1001E2C30;
      block[4] = a1;
      void block[5] = state64;
      dispatch_async(v4, block);
    }

    else
    {
      id v5 = objc_autoreleasePoolPush();
      if (qword_100219F60) {
        [qword_100219F60 WFLog:@"%s: probably WiFiManager is in middle of closing." message:4];
      }
      objc_autoreleasePoolPop(v5);
    }
  }

  else
  {
    id v6 = objc_autoreleasePoolPush();
    if (qword_100219F60) {
      [qword_100219F60 WFLog:@"__WiFiManagerNotifyBatterySaverModeConfiguration: invalid token %d" message:4, val];
    }
    objc_autoreleasePoolPop(v6);
  }

void sub_10008EDA8(uint64_t a1)
{
}

BOOL sub_10008EDB8(uint64_t a1)
{
  BOOL result = sub_10013C1A0(*(void *)(a1 + 32) + 1568LL, 1);
  *(_BYTE *)(*(void *)(a1 + 32) + 1576LL) = result;
  return result;
}

void sub_10008EDEC(uint64_t a1, const void **a2)
{
}

BOOL sub_10008EDFC(const __SCNetworkSet *a1, const __CFArray *a2)
{
  uint64_t v4 = SCNetworkSetCopyServices(a1);
  if (v4)
  {
    id v5 = v4;
    if (CFArrayGetCount(v4) >= 1)
    {
      BOOL v6 = 0;
      CFIndex v7 = 0LL;
      while (1)
      {
        ValueAtIndex = (const __SCNetworkService *)CFArrayGetValueAtIndex(v5, v7);
        if (ValueAtIndex)
        {
          uint64_t v9 = ValueAtIndex;
          if (a2 && (v17.length = CFArrayGetCount(a2), v17.location = 0LL, CFArrayContainsValue(a2, v17, v9)))
          {
            uint64_t v10 = objc_autoreleasePoolPush();
            if (qword_100219F60) {
              [(id)qword_100219F60 WFLog:3, "%s: service ID %@ found in exclude list. Not removing it.", "__WiFiManagerRemoveMatchingServiceForSet", SCNetworkServiceGetServiceID(v9), v16 message];
            }
          }

          else
          {
            Interface = SCNetworkServiceGetInterface(v9);
            if (!Interface) {
              goto LABEL_15;
            }
            CFStringRef InterfaceType = SCNetworkInterfaceGetInterfaceType(Interface);
            if (!InterfaceType || !CFEqual(InterfaceType, kSCNetworkInterfaceTypeIEEE80211)) {
              goto LABEL_15;
            }
            unsigned int v13 = SCNetworkServiceRemove(v9);
            BOOL v6 = (v6 | v13) != 0;
            uint64_t v10 = objc_autoreleasePoolPush();
            if (qword_100219F60) {
              [(id)qword_100219F60 WFLog:3, "%s: service removal status for set %@: %d", "__WiFiManagerRemoveMatchingServiceForSet", SCNetworkSetGetSetID(a1), v13 message];
            }
          }

          objc_autoreleasePoolPop(v10);
        }

uint64_t sub_10008EFD4(uint64_t a1)
{
  uint64_t v2 = objc_autoreleasePoolPush();
  if (qword_100219F60) {
    [qword_100219F60 WFLog:@"%s: sc prefs clean up done !!", "__WiFiManagerRemoveSCNetworkSets_block_invoke"];
  }
  objc_autoreleasePoolPop(v2);
  return sub_100071B18(*(void **)(a1 + 32), @"IsOrphanedSCCleanUpRequired", kCFBooleanFalse);
}

void sub_10008F050(uint64_t a1)
{
  if (-[WiFiUserInteractionMonitor isInHomeScreen]( +[WiFiUserInteractionMonitor sharedInstance](&OBJC_CLASS___WiFiUserInteractionMonitor, "sharedInstance"),  "isInHomeScreen"))
  {
    uint64_t v2 = *(const void **)(*(void *)(*(void *)(a1 + 32) + 8LL) + 24LL);
    if (v2)
    {
      CFRelease(v2);
      *(void *)(*(void *)(*(void *)(a1 + 32) + 8LL) + 24LL) = 0LL;
    }
  }

  uint64_t v3 = *(void *)(a1 + 32);
  v5[0] = *(void *)(a1 + 40);
  v5[1] = 0xAAAAAAAA0000006ALL;
  void v5[2] = *(void *)(*(void *)(v3 + 8) + 24LL);
  v5[3] = 1LL;
  CFSetApplyFunction(*(CFSetRef *)(v5[0] + 104LL), (CFSetApplierFunction)sub_1000662CC, v5);
  uint64_t v4 = *(const void **)(*(void *)(*(void *)(a1 + 32) + 8LL) + 24LL);
  if (v4)
  {
    CFRelease(v4);
    *(void *)(*(void *)(*(void *)(a1 + 32) + 8LL) + 24LL) = 0LL;
  }

void sub_10008F100(uint64_t a1)
{
  v1[0] = *(void *)(a1 + 32);
  v1[1] = 0xAAAAAAAA00000009LL;
  v1[2] = 0LL;
  v1[3] = 1LL;
  CFSetApplyFunction(*(CFSetRef *)(v1[0] + 104LL), (CFSetApplierFunction)sub_1000662CC, v1);
}

CFStringRef sub_10008FA54(int a1)
{
  else {
    return off_1001E45C0[a1 - 2];
  }
}

void sub_10008FC20(uint64_t a1, void *a2)
{
  if (a2 && [a2 confidence] == (id)2)
  {
    [*(id *)(a1 + 32) setMotionState:5];
    if ([a2 stationary])
    {
      else {
        uint64_t v4 = 1LL;
      }
      [*(id *)(a1 + 32) setMotionState:v4];
    }

    if ([*(id *)(a1 + 32) motionState] == 4
      || [*(id *)(a1 + 32) motionState] == 6)
    {
      id v5 = objc_autoreleasePoolPush();
      if (qword_100219F60) {
        [(id)qword_100219F60 WFLog:4, "%s [MOTION] MotionState: %@ - (%@)", "-[WiFiManagerMotionServices startMonitoringMotionState]_block_invoke", sub_10008FDAC((int)objc_msgSend(*(id *)(a1 + 32), "motionState")), a2 message];
      }
      objc_autoreleasePoolPop(v5);
    }

    objc_msgSend(objc_msgSend(a2, "startDate"), "timeIntervalSinceReferenceDate");
    [*(id *)(a1 + 32) setMotionStartTime:];
    BOOL v6 = (dispatch_queue_s *)[*(id *)(a1 + 32) queue];
    block[0] = _NSConcreteStackBlock;
    block[1] = 3221225472LL;
    block[2] = sub_10008FDF8;
    block[3] = &unk_1001E2AF0;
    block[4] = *(void *)(a1 + 32);
    dispatch_async(v6, block);
  }

CFStringRef sub_10008FDAC(int a1)
{
  uint64_t v2 = objc_autoreleasePoolPush();
  else {
    uint64_t v3 = off_1001E4630[a1 - 1];
  }
  objc_autoreleasePoolPop(v2);
  return v3;
}

id sub_10008FDF8(uint64_t a1)
{
  return [*(id *)(a1 + 32) dispatchMotionCallback];
}

id sub_1000900CC(uint64_t a1, uint64_t a2, uint64_t a3)
{
  id v5 = objc_autoreleasePoolPush();
  if (qword_100219F60) {
    [(id)qword_100219F60 WFLog:3, "%s: [MOTION] Walking Started alarm triggered, error %@", "-[WiFiManagerMotionServices setupWalkingStartedAlarm]_block_invoke", a3 message];
  }
  objc_autoreleasePoolPop(v5);
  [*(id *)(a1 + 32) setMotionState:2];
  BOOL v6 = (dispatch_queue_s *)[*(id *)(a1 + 32) queue];
  block[0] = _NSConcreteStackBlock;
  block[1] = 3221225472LL;
  block[2] = sub_100090190;
  block[3] = &unk_1001E2AF0;
  block[4] = *(void *)(a1 + 32);
  dispatch_async(v6, block);
  return [*(id *)(a1 + 32) setupWalkingEndedAlarm];
}

id sub_100090190(uint64_t a1)
{
  return [*(id *)(a1 + 32) dispatchMotionCallback];
}

id sub_1000902FC(uint64_t a1, uint64_t a2, uint64_t a3)
{
  id v5 = objc_autoreleasePoolPush();
  if (qword_100219F60) {
    [(id)qword_100219F60 WFLog:3, "%s: [MOTION] Walking Ended alarm triggered, error %@", "-[WiFiManagerMotionServices setupWalkingEndedAlarm]_block_invoke", a3 message];
  }
  objc_autoreleasePoolPop(v5);
  [*(id *)(a1 + 32) setMotionState:2];
  BOOL v6 = (dispatch_queue_s *)[*(id *)(a1 + 32) queue];
  block[0] = _NSConcreteStackBlock;
  block[1] = 3221225472LL;
  block[2] = sub_1000903C0;
  block[3] = &unk_1001E2AF0;
  block[4] = *(void *)(a1 + 32);
  dispatch_async(v6, block);
  return [*(id *)(a1 + 32) setupWalkingStartedAlarm];
}

id sub_1000903C0(uint64_t a1)
{
  return [*(id *)(a1 + 32) dispatchMotionCallback];
}

id sub_10009052C(uint64_t a1, uint64_t a2, uint64_t a3)
{
  id v5 = objc_autoreleasePoolPush();
  if (qword_100219F60) {
    [(id)qword_100219F60 WFLog:3, "%s: [MOTION] driving started alarm triggered........., error %@", "-[WiFiManagerMotionServices setupDrivingStartedAlarm]_block_invoke", a3 message];
  }
  objc_autoreleasePoolPop(v5);
  [*(id *)(a1 + 32) setMotionState:4];
  BOOL v6 = (dispatch_queue_s *)[*(id *)(a1 + 32) queue];
  block[0] = _NSConcreteStackBlock;
  block[1] = 3221225472LL;
  block[2] = sub_1000905F0;
  block[3] = &unk_1001E2AF0;
  block[4] = *(void *)(a1 + 32);
  dispatch_async(v6, block);
  return [*(id *)(a1 + 32) setupDrivingEndedAlarm];
}

id sub_1000905F0(uint64_t a1)
{
  return [*(id *)(a1 + 32) dispatchMotionCallback];
}

id sub_10009075C(uint64_t a1, uint64_t a2, uint64_t a3)
{
  id v5 = objc_autoreleasePoolPush();
  if (qword_100219F60) {
    [(id)qword_100219F60 WFLog:3, "%s: [MOTION] Driving ended alarm triggered..........., error %@", "-[WiFiManagerMotionServices setupDrivingEndedAlarm]_block_invoke", a3 message];
  }
  objc_autoreleasePoolPop(v5);
  [*(id *)(a1 + 32) setMotionState:2];
  BOOL v6 = (dispatch_queue_s *)[*(id *)(a1 + 32) queue];
  block[0] = _NSConcreteStackBlock;
  block[1] = 3221225472LL;
  block[2] = sub_100090820;
  block[3] = &unk_1001E2AF0;
  block[4] = *(void *)(a1 + 32);
  dispatch_async(v6, block);
  return [*(id *)(a1 + 32) setupDrivingStartedAlarm];
}

id sub_100090820(uint64_t a1)
{
  return [*(id *)(a1 + 32) dispatchMotionCallback];
}

WiFiManagerMotionServices *sub_100090908(uint64_t a1, uint64_t a2, uint64_t a3)
{
  BOOL v6 = objc_autoreleasePoolPush();
  if (!a1)
  {
    uint64_t v10 = objc_autoreleasePoolPush();
    if (qword_100219F60) {
      [qword_100219F60 WFLog:@"%s: null manager" message:3];
    }
    goto LABEL_12;
  }

  if (!a3)
  {
    uint64_t v10 = objc_autoreleasePoolPush();
    if (qword_100219F60) {
      [qword_100219F60 WFLog:@"%s: null motionStateChangeCb" message:3];
    }
    goto LABEL_12;
  }

  CFIndex v7 = objc_alloc_init(&OBJC_CLASS___WiFiManagerMotionServices);
  if (!v7)
  {
    uint64_t v10 = objc_autoreleasePoolPush();
    if (qword_100219F60) {
      [qword_100219F60 WFLog:@"%s: motionServices is null" message:3];
    }
LABEL_12:
    objc_autoreleasePoolPop(v10);
    id v8 = 0LL;
    goto LABEL_5;
  }

  id v8 = v7;
  -[WiFiManagerMotionServices setManager:](v7, "setManager:", a1);
  -[WiFiManagerMotionServices setMotionStateChangeCb:](v8, "setMotionStateChangeCb:", a3);
  -[WiFiManagerMotionServices setQueue:](v8, "setQueue:", a2);
  -[WiFiManagerMotionServices startMonitoringMotionState](v8, "startMonitoringMotionState");
LABEL_5:
  objc_autoreleasePoolPop(v6);
  return v8;
}

void sub_100090A40(void *a1)
{
  uint64_t v2 = objc_autoreleasePoolPush();
  if (a1)
  {
    [a1 stopMonitoringMotionState];
  }

  else
  {
    uint64_t v3 = objc_autoreleasePoolPush();
    if (qword_100219F60) {
      [qword_100219F60 WFLog:@"%s: null motionServices" message:3];
    }
    objc_autoreleasePoolPop(v3);
  }

  objc_autoreleasePoolPop(v2);
}

void sub_100090AC0(void *a1, dispatch_queue_s *a2)
{
  *((_BYTE *)a1 + 4_Block_object_dispose((const void *)(v15 - 96), 8) = 0;
  *((_BYTE *)a1 + _Block_object_dispose((const void *)(v15 - 96), 8) = 0;
  uint64_t v4 = opendir("/private/var/dextcores");
  if (v4)
  {
    *a1 = "/private/var/dextcores";
    closedir(v4);
  }

  else
  {
    *a1 = "/private/var/cores";
  }

  a1[3] = a2;
  id v5 = a2;
  unsigned int v6 = sub_10013BAE8();
  if (v6) {
    int v7 = v6;
  }
  else {
    int v7 = 5;
  }
  *((_DWORD *)a1 + 9) = v7;
  unsigned int v8 = sub_10013BAA0();
  if (v8) {
    int v9 = v8;
  }
  else {
    int v9 = 360;
  }
  *((_DWORD *)a1 + _Block_object_dispose((const void *)(v15 - 96), 8) = v9;
  uint64_t v22 = 9221LL;
  uint64_t v10 = fsctl((const char *)*a1, 0xC0084A44uLL, &v22, 0);
  uint64_t v11 = objc_autoreleasePoolPush();
  if (qword_100219F60) {
    [qword_100219F60 WFLog:@"fsctl for %s returns %d" message:3,  "WiFiDextCrashMarkCoreFilesPurgable",  *a1,  v10];
  }
  objc_autoreleasePoolPop(v11);
  dispatch_source_t v12 = dispatch_source_create((dispatch_source_type_t)&_dispatch_source_type_timer, 0LL, 0LL, a2);
  a1[2] = v12;
  if (v12)
  {
    dispatch_set_context(v12, a1);
    dispatch_source_set_event_handler_f((dispatch_source_t)a1[2], (dispatch_function_t)sub_10013BB30);
    dispatch_activate((dispatch_object_t)a1[2]);
    unsigned int v13 = (dispatch_source_s *)a1[2];
    dispatch_time_t v14 = dispatch_time(0LL, 10000000000LL);
    dispatch_source_set_timer(v13, v14, 60000000000LL * *((int *)a1 + 8), 0x8BB2C97000uLL);
LABEL_17:
    uint64_t v15 = objc_autoreleasePoolPush();
    if (qword_100219F60) {
      [qword_100219F60 WFLog:@"WiFiDextCrashProcessInit timer enabled:%d startTime:%d period:%d (min) leeway:%d (min) maxFiles:%d corefile_directory:%s" message:3 "%s  timer enabled:%d startTime:%d period:%d (min) leeway:%d (min) maxFiles:%d corefile_directory:%s" "WiFiDextCrashProcessInit" *((_DWORD *)a1 + 8) < 1441 10  *((unsigned int *)a1 + 8) 10  *((unsigned int *)a1 + 9)  *a1];
    }
    goto LABEL_19;
  }

  uint64_t v15 = objc_autoreleasePoolPush();
  if (qword_100219F60) {
    [qword_100219F60 WFLog:@"Error: failed to create dextcrash handling timer" message:4 v16 v17 v18 v19 v20 v21];
  }
LABEL_19:
  objc_autoreleasePoolPop(v15);
}

void sub_100090CEC(uint64_t a1)
{
  uint64_t v2 = *(dispatch_object_s **)(a1 + 16);
  if (v2)
  {
    dispatch_release(v2);
    *(void *)(a1 + 16) = 0LL;
  }

  uint64_t v3 = *(void **)(a1 + 24);
  if (v3)
  {

    *(void *)(a1 + 24) = 0LL;
  }

uint64_t sub_100090D28()
{
  uint64_t result = qword_100219938;
  if (!qword_100219938)
  {
    pthread_once(&stru_100218EB8, (void (*)(void))sub_100090D64);
    return qword_100219938;
  }

  return result;
}

CFMutableDictionaryRef sub_100090D64()
{
  qword_100219938 = _CFRuntimeRegisterClass(&unk_1001E4660);
  CFMutableDictionaryRef result = CFDictionaryCreateMutable(kCFAllocatorDefault, 0LL, 0LL, 0LL);
  qword_100219940 = (uint64_t)result;
  return result;
}

void *sub_100090DAC(uint64_t a1, uint64_t a2, int a3, int a4)
{
  if (a2 < 1) {
    return 0LL;
  }
  if (!qword_100219938) {
    pthread_once(&stru_100218EB8, (void (*)(void))sub_100090D64);
  }
  Instance = (_OWORD *)_CFRuntimeCreateInstance(a1);
  int v9 = Instance;
  if (Instance)
  {
    Instance[5] = 0u;
    Instance[6] = 0u;
    Instance[3] = 0u;
    Instance[4] = 0u;
    Instance[1] = 0u;
    Instance[2] = 0u;
    *((_DWORD *)Instance + 4) = a3;
    if (!a4
      || ((v12.version = 0LL, memset(&v12.retain, 0, 24), v12.info = Instance, !a3)
        ? (uint64_t v10 = (uint64_t)CFMachPortCreate(kCFAllocatorDefault, (CFMachPortCallBack)sub_100090EB4, &v12, 0LL))
        : (uint64_t v10 = sub_10003AE38()),
          (v9[7] = v10) != 0LL))
    {
      void v9[3] = a2;
      return v9;
    }

    CFRelease(v9);
    return 0LL;
  }

  return v9;
}

void sub_100090EB4(int a1, mach_msg_header_t *a2, int a3, CFIndex *cf)
{
  if (cf)
  {
    CFRetain(cf);
    unsigned int v6 = (mach_msg_header_t *)CFAllocatorAllocate(0LL, cf[3], 0LL);
    if (!v6)
    {
LABEL_19:
      CFRelease(cf);
      return;
    }

    int v7 = v6;
    mach_port_t msgh_remote_port = a2->msgh_remote_port;
    v6->msgh_bits = a2->msgh_bits & 0x1F;
    v6->msgh_size = 36;
    *(void *)&v6->mach_port_t msgh_remote_port = msgh_remote_port;
    v6->msgh_id = a2->msgh_id + 100;
    if (a2->msgh_id == 70)
    {
      v6->msgh_bits = 0;
      v6->mach_port_t msgh_remote_port = 0;
      v6[1].mach_port_t msgh_remote_port = 0;
      p_mach_port_t msgh_remote_port = &v6[1].msgh_remote_port;
      uint64_t v10 = (void (*)(CFIndex *, CFIndex))cf[12];
      if (v10) {
        v10(cf, cf[13]);
      }
    }

    else
    {
      NDR_record_t v11 = NDR_record;
      v6[1].mach_port_t msgh_remote_port = -303;
      p_mach_port_t msgh_remote_port = &v6[1].msgh_remote_port;
      *(NDR_record_t *)&v6[1].msgh_bits = v11;
      CFMachPortContext v12 = (void (*)(CFIndex *, mach_msg_header_t *, mach_msg_header_t *, CFIndex))cf[10];
      if (v12) {
        v12(cf, a2, v6, cf[11]);
      }
    }

    if ((v7->msgh_bits & 0x80000000) == 0 && *p_msgh_remote_port)
    {
      if (*p_msgh_remote_port == -305) {
        goto LABEL_18;
      }
      a2->mach_port_t msgh_remote_port = 0;
      mach_msg_destroy(a2);
    }

    if (v7->msgh_remote_port)
    {
      if ((v7->msgh_bits & 0x1F) == 0x12) {
        mach_msg_option_t v13 = 1;
      }
      else {
        mach_msg_option_t v13 = 17;
      }
    }

    else if ((v7->msgh_bits & 0x80000000) == 0)
    {
      goto LABEL_18;
    }

    mach_msg_destroy(v7);
LABEL_18:
    CFAllocatorDeallocate(0LL, v7);
    goto LABEL_19;
  }

uint64_t sub_100091024(uint64_t a1, uint64_t a2)
{
  uint64_t result = dispatch_mach_create_f("WiFiManager/base", a2, a1, sub_100091078);
  *(void *)(a1 + 72) = result;
  if (result) {
    return dispatch_mach_connect(result, *(unsigned int *)(a1 + 16), 0LL, 0LL);
  }
  return result;
}

void sub_100091078(uint64_t a1, uint64_t a2, uint64_t a3)
{
  switch(a2)
  {
    case 8LL:
      dispatch_release(*(dispatch_object_t *)(a1 + 72));
      CFRelease((CFTypeRef)a1);
      break;
    case 7LL:
      uint64_t msg = dispatch_mach_msg_get_msg(a3, 0LL);
      mach_port_mod_refs(mach_task_self_, *(_DWORD *)(msg + 12), 1u, -1);
      break;
    case 2LL:
      if (*(_DWORD *)(dispatch_mach_msg_get_msg(a3, 0LL) + 20) == 70)
      {
        id v5 = *(void (**)(uint64_t, void))(a1 + 96);
        if (v5) {
          v5(a1, *(void *)(a1 + 104));
        }
      }

      else if ((dispatch_mach_mig_demux(0LL, &off_1001E4A60, 1LL, a3) & 1) == 0)
      {
        int v7 = (mach_msg_header_t *)dispatch_mach_msg_get_msg(a3, 0LL);
        mach_msg_destroy(v7);
      }

      break;
  }

uint64_t sub_100091164(uint64_t result)
{
  if (result)
  {
    uint64_t result = *(void *)(result + 72);
    if (result) {
      return dispatch_mach_cancel();
    }
  }

  return result;
}

void sub_100091178(uint64_t a1, CFRunLoopRef rl, CFRunLoopMode mode)
{
  *(void *)(a1 + 32) = rl;
  *(void *)(a1 + 40) = mode;
  RunLoopSource = *(__CFRunLoopSource **)(a1 + 48);
  if (RunLoopSource {
    || (RunLoopSource = CFMachPortCreateRunLoopSource(kCFAllocatorDefault, *(CFMachPortRef *)(a1 + 56), 1LL),
  }
        (*(void *)(a1 + 4_Block_object_dispose((const void *)(v15 - 96), 8) = RunLoopSource) != 0LL))
  {
    CFRunLoopAddSource(rl, RunLoopSource, mode);
  }

void sub_1000911EC(uint64_t a1, __CFRunLoop *cf1, const __CFString *a3)
{
  if (cf1)
  {
    if (a3)
    {
      int v7 = (void *)(a1 + 32);
      unsigned int v6 = *(const void **)(a1 + 32);
      if (v6)
      {
        if (*(void *)(a1 + 40))
        {
          if (CFEqual(cf1, v6))
          {
            if (CFEqual(a3, *(CFTypeRef *)(a1 + 40)))
            {
              *int v7 = 0LL;
              v7[1] = 0LL;
              unsigned int v8 = *(__CFRunLoopSource **)(a1 + 48);
              if (v8)
              {
                CFRunLoopRemoveSource(cf1, v8, a3);
                int v9 = *(const void **)(a1 + 48);
                if (v9)
                {
                  CFRelease(v9);
                  *(void *)(a1 + 4_Block_object_dispose((const void *)(v15 - 96), 8) = 0LL;
                }
              }
            }
          }
        }
      }
    }
  }

uint64_t sub_100091278(uint64_t result, uint64_t a2, uint64_t a3)
{
  *(void *)(result + 80) = a2;
  *(void *)(result + 8_Block_object_dispose((const void *)(v15 - 96), 8) = a3;
  return result;
}

uint64_t sub_100091280(uint64_t result, uint64_t a2, uint64_t a3)
{
  *(void *)(result + 96) = a2;
  *(void *)(result + 104) = a3;
  return result;
}

uint64_t sub_100091288(unsigned int a1, const void *a2)
{
  if (qword_100219940) {
    CFDictionarySetValue((CFMutableDictionaryRef)qword_100219940, (const void *)a1, a2);
  }
  return pthread_mutex_unlock(&stru_100218EC8);
}

uint64_t sub_1000912D4(unsigned int a1)
{
  if (qword_100219940) {
    CFDictionaryRemoveValue((CFMutableDictionaryRef)qword_100219940, (const void *)a1);
  }
  return pthread_mutex_unlock(&stru_100218EC8);
}

const void *sub_100091318(unsigned int a1)
{
  if (qword_100219940)
  {
    Value = CFDictionaryGetValue((CFDictionaryRef)qword_100219940, (const void *)a1);
    uint64_t v3 = Value;
    if (Value) {
      CFRetain(Value);
    }
  }

  else
  {
    uint64_t v3 = 0LL;
  }

  pthread_mutex_unlock(&stru_100218EC8);
  return v3;
}

const void *sub_10009137C(unsigned int a1, uint64_t a2)
{
  uint64_t v3 = sub_100091318(a1);
  uint64_t v4 = v3;
  if (v3 && CFGetTypeID(v3) != a2)
  {
    CFRelease(v4);
    return 0LL;
  }

  return v4;
}

void sub_1000913C4(uint64_t a1)
{
  uint64_t v2 = *(__CFMachPort **)(a1 + 56);
  if (v2)
  {
    CFMachPortInvalidate(v2);
    uint64_t v3 = *(const void **)(a1 + 56);
    if (v3)
    {
      CFRelease(v3);
      *(void *)(a1 + 56) = 0LL;
    }
  }

  uint64_t v4 = *(const void **)(a1 + 48);
  if (v4)
  {
    CFRelease(v4);
    *(void *)(a1 + 4_Block_object_dispose((const void *)(v15 - 96), 8) = 0LL;
  }

void sub_1000916E8(id a1, id a2, unint64_t a3, BOOL *a4)
{
  if (a2) {
    dispatch_source_cancel((dispatch_source_t)a2);
  }
}

void sub_10009179C(uint64_t a1)
{
  uint64_t v2 = objc_autoreleasePoolPush();
  if (qword_100219F60) {
    [qword_100219F60 WFLog:@"Received signal %d" message:4];
  }
  objc_autoreleasePoolPop(v2);
  if (*(_DWORD *)(a1 + 48) == 15)
  {
    uint64_t v3 = (void *)MGCopyAnswerWithError(@"LowPowerExpressModesSupported", 0LL, 0LL);
    uint64_t v4 = v3;
    if (v3 && [v3 count])
    {
      sub_10006EF98(*(void *)(*(void *)(a1 + 32) + 8LL), 0, @"LPEM");
    }

    else if (os_log_type_enabled((os_log_t)&_os_log_default, OS_LOG_TYPE_INFO))
    {
      *(_DWORD *)buf = 136315138;
      unsigned int v6 = "-[WiFiManagerLifeCycle handleSignal:onQueue:]_block_invoke";
      _os_log_impl( (void *)&_mh_execute_header,  (os_log_t)&_os_log_default,  OS_LOG_TYPE_INFO,  "%s: LPEM mode not supported. Not powering off on SIGTERM",  buf,  0xCu);
    }
  }

  sub_100074498(*(void *)(*(void *)(a1 + 32) + 8LL), 1, 1, 0);
  [*(id *)(a1 + 32) stopOnQueue:*(void *)(a1 + 40)];
  exit(*(_DWORD *)(a1 + 48));
}

uint64_t start()
{
  v14[0] = 0LL;
  v14[1] = v14;
  v14[2] = 0x3052000000LL;
  v14[3] = sub_100091BF4;
  v14[4] = sub_100091C04;
  v14[5] = 0LL;
  v0 = objc_autoreleasePoolPush();
  if ((_set_user_dir_suffix("com.apple.wifi.manager") & 1) == 0
    && os_log_type_enabled((os_log_t)&_os_log_default, OS_LOG_TYPE_ERROR))
  {
    sub_100154204();
  }

  NSTemporaryDirectory();
  +[NSError _setFileNameLocalizationEnabled:](&OBJC_CLASS___NSError, "_setFileNameLocalizationEnabled:", 0LL);
  uint64_t v1 = dispatch_queue_attr_make_with_autorelease_frequency(0LL, DISPATCH_AUTORELEASE_FREQUENCY_WORK_ITEM);
  qword_100219F90 = (uint64_t)dispatch_queue_create("com.apple.wifid.managerQueue", v1);
  if (!qword_100219F90) {
    goto LABEL_27;
  }
  if (&_wd_endpoint_register)
  {
    wd_endpoint_register("com.apple.wifid.watchdog");
    uint64_t v2 = wd_endpoint_add_queue(qword_100219F90);
    wd_endpoint_activate(v2);
  }

  uint64_t v3 = dispatch_queue_attr_make_with_autorelease_frequency(0LL, DISPATCH_AUTORELEASE_FREQUENCY_WORK_ITEM);
  qword_100219F80 = (uint64_t)dispatch_queue_create("com.apple.wifid.serialQueue", v3);
  if (qword_100219F80
    && (uint64_t v4 = dispatch_queue_attr_make_with_autorelease_frequency(0LL, DISPATCH_AUTORELEASE_FREQUENCY_WORK_ITEM),
        (qword_100219F88 = (uint64_t)dispatch_queue_create("com.apple.wifi.network-sync", v4)) != 0))
  {
    id v5 = CFLocaleCopyCurrent();
    unsigned int v6 = CFDateFormatterCreate(0LL, v5, kCFDateFormatterShortStyle, kCFDateFormatterMediumStyle);
    qword_100219F98 = (uint64_t)v6;
    if (v6) {
      CFDateFormatterSetFormat(v6, @"MM/dd/yy HH:mm:ss.SSS");
    }
    if (v5) {
      CFRelease(v5);
    }
    pthread_mutex_init(&stru_100218F08, 0LL);
    pthread_mutex_init(&stru_100218F48, 0LL);
    byte_100219FA0 = os_variant_is_darwinos(0LL);
    if (objc_opt_class(&OBJC_CLASS___MSDKDemoState))
    {
      uint64_t v13 = 0LL;
      byte_100219FA2 = -[MSDKDemoState isStoreDemoModeEnabled:]( +[MSDKDemoState sharedInstance](&OBJC_CLASS___MSDKDemoState, "sharedInstance"),  "isStoreDemoModeEnabled:",  &v13);
    }

    block[0] = _NSConcreteStackBlock;
    block[1] = 3221225472LL;
    block[2] = sub_100091C10;
    block[3] = &unk_1001E42A0;
    block[4] = v14;
    dispatch_async((dispatch_queue_t)qword_100219F90, block);
    int v7 = 1;
  }

  else
  {
LABEL_27:
    int v7 = 0;
  }

  objc_autoreleasePoolPop(v0);
  if (v7)
  {
    -[NSRunLoop run](+[NSRunLoop mainRunLoop](&OBJC_CLASS___NSRunLoop, "mainRunLoop"), "run");
    unsigned int v8 = objc_autoreleasePoolPush();
    v11[0] = _NSConcreteStackBlock;
    v11[1] = 3221225472LL;
    v11[2] = sub_100091C58;
    void v11[3] = &unk_1001E42A0;
    v11[4] = v14;
    dispatch_async((dispatch_queue_t)qword_100219F90, v11);
    objc_autoreleasePoolPop(v8);
  }

  int v9 = objc_autoreleasePoolPush();
  if (qword_100219F98)
  {
    CFRelease((CFTypeRef)qword_100219F98);
    qword_100219F98 = 0LL;
  }

  if (qword_100219F80)
  {
    dispatch_release((dispatch_object_t)qword_100219F80);
    qword_100219F80 = 0LL;
  }

  if (qword_100219F88)
  {
    dispatch_release((dispatch_object_t)qword_100219F88);
    qword_100219F88 = 0LL;
  }

  if (qword_100219F90)
  {
    dispatch_release((dispatch_object_t)qword_100219F90);
    qword_100219F90 = 0LL;
  }

  objc_autoreleasePoolPop(v9);
  _Block_object_dispose(v14, 8);
  return 0LL;
}

void sub_100091BD8( _Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, ...)
{
}

void sub_100091BF4(uint64_t a1, uint64_t a2)
{
}

void sub_100091C04(uint64_t a1)
{
}

id sub_100091C10(uint64_t a1)
{
  *(void *)(*(void *)(*(void *)(a1 + 32) + 8LL) + 40LL) = objc_alloc_init(&OBJC_CLASS___WiFiManagerLifeCycle);
  return [*(id *)(*(void *)(*(void *)(a1 + 32) + 8) + 40) startOnQueue:qword_100219F90];
}

void sub_100091C58(uint64_t a1)
{
  *(void *)(*(void *)(*(void *)(a1 + 32) + 8LL) + 40LL) = 0LL;
}

uint64_t sub_100091CA8(uint64_t a1, uint64_t a2, uint64_t a3)
{
  if (!qword_100219948) {
    pthread_once(&stru_100218F88, (void (*)(void))sub_1000920A8);
  }
  uint64_t Instance = _CFRuntimeCreateInstance(a1);
  *(void *)(Instance + 72) = 850045863LL;
  *(_OWORD *)(Instance + 80) = 0u;
  *(_OWORD *)(Instance + 96) = 0u;
  *(_OWORD *)(Instance + 112) = 0u;
  *(void *)(Instance + 12_Block_object_dispose(va, 8) = 0LL;
  int v7 = (char *)malloc(a3 * a2);
  *(void *)(Instance + 40) = v7;
  if (v7)
  {
    *(void *)(Instance + 56) = v7;
    *(void *)(Instance + 64) = v7;
    *(void *)(Instance + 4_Block_object_dispose(va, 8) = &v7[a3 * a2];
    *(void *)(Instance + 16) = a2;
    *(void *)(Instance + 24) = 0LL;
    *(void *)(Instance + 32) = a3;
    *(_BYTE *)(Instance + 136) = 0;
  }

  else
  {
    unsigned int v8 = objc_autoreleasePoolPush();
    if (qword_100219F60) {
      [qword_100219F60 WFLog:@"%s allocation error (likely OOM)", @"WiFiCircularBufferCreate"];
    }
    objc_autoreleasePoolPop(v8);
    CFRelease((CFTypeRef)Instance);
    return 0LL;
  }

  return Instance;
}

uint64_t sub_100091DAC(uint64_t a1)
{
  return *(void *)(a1 + 24);
}

uint64_t sub_100091DB4(uint64_t a1, const void *a2)
{
  uint64_t v4 = (pthread_mutex_t *)(a1 + 72);
  pthread_mutex_lock((pthread_mutex_t *)(a1 + 72));
  memcpy(*(void **)(a1 + 56), a2, *(void *)(a1 + 32));
  uint64_t v5 = *(void *)(a1 + 48);
  uint64_t v6 = *(void *)(a1 + 56) + *(void *)(a1 + 32);
  *(void *)(a1 + 56) = v6;
  if (v6 == v5) {
    *(void *)(a1 + 56) = *(void *)(a1 + 40);
  }
  unint64_t v7 = *(void *)(a1 + 24);
  if (v7 < *(void *)(a1 + 16)) {
    *(void *)(a1 + 24) = v7 + 1;
  }
  return pthread_mutex_unlock(v4);
}

uint64_t sub_100091E30(uint64_t a1, void *a2)
{
  uint64_t v4 = (pthread_mutex_t *)(a1 + 72);
  pthread_mutex_lock((pthread_mutex_t *)(a1 + 72));
  sub_100091E74(a1, a2);
  return pthread_mutex_unlock(v4);
}

void *sub_100091E74(uint64_t a1, void *__dst)
{
  if (*(void *)(a1 + 24))
  {
    uint64_t result = memcpy(__dst, *(const void **)(a1 + 64), *(void *)(a1 + 32));
    uint64_t v4 = *(void *)(a1 + 64) + *(void *)(a1 + 32);
    *(void *)(a1 + 64) = v4;
    if (v4 == *(void *)(a1 + 48)) {
      *(void *)(a1 + 64) = *(void *)(a1 + 40);
    }
    --*(void *)(a1 + 24);
  }

  else
  {
    uint64_t v5 = objc_autoreleasePoolPush();
    if (qword_100219F60) {
      [qword_100219F60 WFLog:@"%s when empty" message:3];
    }
    objc_autoreleasePoolPop(v5);
    return (void *)pthread_mutex_unlock((pthread_mutex_t *)(a1 + 72));
  }

  return result;
}

void sub_100091F34(uint64_t a1, void *a2)
{
  if (*(_BYTE *)(a1 + 136))
  {
    sub_100091E74(a1, a2);
  }

  else
  {
    uint64_t v2 = objc_autoreleasePoolPush();
    if (qword_100219F60) {
      [qword_100219F60 WFLog:@"%s write locked not locked" message:@"WiFiCircularBufferWriteLockedGet"];
    }
    objc_autoreleasePoolPop(v2);
  }

void sub_100091FA4(uint64_t a1)
{
  if (*(_BYTE *)(a1 + 136))
  {
    uint64_t v1 = objc_autoreleasePoolPush();
    if (qword_100219F60) {
      [qword_100219F60 WFLog:@"%s write lock already locked" message:@"WiFiCircularBufferTakeWriteLock"];
    }
    objc_autoreleasePoolPop(v1);
  }

  else
  {
    pthread_mutex_lock((pthread_mutex_t *)(a1 + 72));
    *(_BYTE *)(a1 + 136) = 1;
  }

void sub_100092028(uint64_t a1)
{
  if (*(_BYTE *)(a1 + 136))
  {
    pthread_mutex_unlock((pthread_mutex_t *)(a1 + 72));
    *(_BYTE *)(a1 + 136) = 0;
  }

  else
  {
    uint64_t v2 = objc_autoreleasePoolPush();
    if (qword_100219F60) {
      [qword_100219F60 WFLog:@"%s write lock not locked" message:@"WiFiCircularBufferReleaseWriteLock"];
    }
    objc_autoreleasePoolPop(v2);
  }

uint64_t sub_1000920A8()
{
  uint64_t result = _CFRuntimeRegisterClass(&unk_1001E4728);
  qword_100219948 = result;
  return result;
}

void sub_1000920CC(uint64_t a1)
{
  *(void *)(a1 + 16) = 0LL;
  *(void *)(a1 + 24) = 0LL;
  *(void *)(a1 + 32) = 0LL;
  *(void *)(a1 + 56) = 0LL;
  *(void *)(a1 + 64) = 0LL;
  *(void *)(a1 + 4_Block_object_dispose(va, 8) = 0LL;
  free(*(void **)(a1 + 40));
}

void sub_100092A40( _Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, id location)
{
}

id sub_100092A68(uint64_t a1)
{
  id WeakRetained = objc_loadWeakRetained((id *)(a1 + 32));
  uint64_t v2 = (void *)[WeakRetained cachedBudget];

  return v2;
}

void sub_100092CB0(uint64_t a1, void *a2)
{
  id v3 = a2;
  id WeakRetained = (id *)objc_loadWeakRetained((id *)(a1 + 32));
  uint64_t v5 = WeakRetained;
  id v6 = WeakRetained[1];
  if (v6)
  {
    [WeakRetained[5] acknowledgePowerBudget:v3 forClientId:WeakRetained[18] error:0];
    uint64_t v19 = 0LL;
    uint64_t v20 = &v19;
    uint64_t v21 = 0x2020000000LL;
    id v22 = (id)0xAAAAAAAAAAAAAAAALL;
    id v22 = [v5 WiFiBatteryManagerHandleCpmsAllocatedBudgetReturnIndex:v3];
    uint64_t v7 = sub_10003BEDC((uint64_t)v6);
    uint64_t v8 = sub_1000511DC(v7);
    uint64_t v9 = v20[3];
    uint64_t v10 = objc_autoreleasePoolPush();
    if (v9 == v8)
    {
      if (qword_100219F60) {
        [qword_100219F60 WFLog:@"%s: WiFiBatteryMgmt :  Budget to be written is %lu, last was %lu : ignoring" message:3, v20[3], v8];
      }
    }

    else
    {
      if (qword_100219F60) {
        [qword_100219F60 WFLog:@"%s: WiFiBatteryMgmt :  Budget to be written is %lu (last was %lu) !" message:3, @"-[WiFiBatteryManager WiFiBatteryManagerCpmsCallbackConfiguration:]_block_invoke", v20[3], v8];
      }
      objc_autoreleasePoolPop(v10);
      uint64_t v11 = sub_1000E48A8((uint64_t)v6);
      CFMachPortContext v12 = (void *)objc_claimAutoreleasedReturnValue(v11);

      if (v12)
      {
        CFRetain(v6);
        uint64_t v13 = sub_1000E48A8((uint64_t)v6);
        dispatch_time_t v14 = (dispatch_queue_s *)objc_claimAutoreleasedReturnValue(v13);
        block[0] = _NSConcreteStackBlock;
        block[1] = 3221225472LL;
        block[2] = sub_100092ECC;
        block[3] = &unk_1001E47B8;
        uint64_t v17 = &v19;
        uint64_t v18 = v6;
        uint64_t v16 = v5;
        dispatch_async(v14, block);

LABEL_12:
        _Block_object_dispose(&v19, 8);
        goto LABEL_13;
      }

      uint64_t v10 = objc_autoreleasePoolPush();
      if (qword_100219F60) {
        [qword_100219F60 WFLog:@"%s: null manager queue." message:3];
      }
    }

    objc_autoreleasePoolPop(v10);
    goto LABEL_12;
  }

void sub_100092EB4( _Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, ...)
{
}

void sub_100092ECC(uint64_t a1)
{
  uint64_t v2 = sub_1000E48A8(*(void *)(a1 + 48));
  id v3 = (void *)objc_claimAutoreleasedReturnValue(v2);

  uint64_t v4 = objc_autoreleasePoolPush();
  if (v3)
  {
    if (qword_100219F60) {
      [qword_100219F60 WFLog:@"%s: WiFiBatteryMgmt :  Async CPMS Handler " message:3];
    }
    objc_autoreleasePoolPop(v4);
    uint64_t v5 = sub_10003BEDC(*(void *)(a1 + 48));
    int v6 = sub_100050F18(v5, *(_DWORD *)(*(void *)(*(void *)(a1 + 40) + 8LL) + 24LL));
    if (!v6) {
      goto LABEL_8;
    }
    int v7 = v6;
    uint64_t v8 = objc_autoreleasePoolPush();
    if (qword_100219F60) {
      [qword_100219F60 WFLog:@"message:3:%s: WiFiBatteryMgmt : Unable to set the Async budget value to FW "];
    }
    objc_autoreleasePoolPop(v8);
    if (v7 != 82) {
LABEL_8:
    }
      [*(id *)(a1 + 32) WiFiBatteryManagerHandlePowerAdmissionResponse:*(unsigned int *)(*(void *)(*(void *)(a1 + 40) + 8) + 24)];
  }

  else
  {
    if (qword_100219F60) {
      [qword_100219F60 WFLog:@"%s: null manager queue." message:3];
    }
    objc_autoreleasePoolPop(v4);
  }

  CFRelease(*(CFTypeRef *)(a1 + 48));
}

void sub_1000930E0(uint64_t a1, void *a2)
{
  id v3 = a2;
  id WeakRetained = objc_loadWeakRetained((id *)(a1 + 32));
  uint64_t v5 = (const void *)WeakRetained[1];
  int v6 = [NSDate date];
  int v7 = (void *)[WeakRetained asyncPPMBudgetTimestamp];
  [v6 timeIntervalSinceDate:v7];
  double v9 = v8;

  if (v5)
  {
    uint64_t v10 = sub_1000E48A8((uint64_t)v5);
    uint64_t v11 = (void *)objc_claimAutoreleasedReturnValue(v10);

    if (v11)
    {
      if (v3)
      {
        CFMachPortContext v12 = (const __CFDictionary *)[v3 objectForKey:@"CDResourceAvailabilityKeyRetryReason"];
        if (v12)
        {
          uint64_t v24 = 0LL;
          uint64_t v25 = &v24;
          uint64_t v26 = 0x2020000000LL;
          unint64_t v27 = 0xAAAAAAAAAAAAAAAALL;
          Value = (const __CFNumber *)CFDictionaryGetValue(v12, @"com.apple.duet.ppm-bgt.wifi");
          if (Value && v9 >= 5.0)
          {
            [WeakRetained setAsyncPPMBudgetTimestamp:v6];
            CFNumberGetValue(Value, kCFNumberLongLongType, v25 + 3);
            dispatch_time_t v14 = objc_autoreleasePoolPush();
            if (qword_100219F60) {
              [qword_100219F60 WFLog:@"WiFiBatteryMgmt called back received wifibudget is %llu" message:v25[3]];
            }
            objc_autoreleasePoolPop(v14);
            uint64_t v15 = (void *)[WeakRetained cachedBudget];
            uint64_t v16 = (void *)objc_claimAutoreleasedReturnValue(+[NSNumber numberWithLongLong:](&OBJC_CLASS___NSNumber, "numberWithLongLong:", v25[3]));
            [v15 setObject:v16 forKey:@"kCPMSPowerLegacyPPM"];

            CFRetain(v5);
            uint64_t v17 = sub_1000E48A8((uint64_t)v5);
            uint64_t v18 = (dispatch_queue_s *)objc_claimAutoreleasedReturnValue(v17);
            block[0] = _NSConcreteStackBlock;
            block[1] = 3221225472LL;
            block[2] = sub_10009335C;
            block[3] = &unk_1001E47B8;
            id v22 = &v24;
            uint64_t v23 = v5;
            uint64_t v21 = WeakRetained;
            dispatch_async(v18, block);
          }

          _Block_object_dispose(&v24, 8);
        }
      }
    }

    else
    {
      uint64_t v19 = objc_autoreleasePoolPush();
      if (qword_100219F60) {
        [qword_100219F60 WFLog:@"%s: null manager queue." message:3];
      }
      objc_autoreleasePoolPop(v19);
    }
  }
}

void sub_100093344( _Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, ...)
{
}

void sub_10009335C(uint64_t a1)
{
  uint64_t v2 = sub_1000E48A8(*(void *)(a1 + 48));
  id v3 = (void *)objc_claimAutoreleasedReturnValue(v2);

  uint64_t v4 = objc_autoreleasePoolPush();
  if (v3)
  {
    if (qword_100219F60) {
      objc_msgSend( (id)qword_100219F60,  "WFLog:message:",  3,  "%s: WiFiBatteryMgmt :  Async PPM Handler ",  "-[WiFiBatteryManager WiFiBatteryManagerPpmCallbackConfiguration:]_block_invoke_2");
    }
    objc_autoreleasePoolPop(v4);
    uint64_t v5 = sub_10003BEDC(*(void *)(a1 + 48));
    sub_100050F18(v5, *(_DWORD *)(*(void *)(*(void *)(a1 + 40) + 8LL) + 24LL));
    [*(id *)(a1 + 32) WiFiBatteryManagerHandlePowerAdmissionResponse:*(unsigned int *)(*(void *)(*(void *)(a1 + 40) + 8) + 24)];
  }

  else
  {
    if (qword_100219F60) {
      [qword_100219F60 WFLog:@"%s: null manager queue." message:3];
    }
    objc_autoreleasePoolPop(v4);
  }

  CFRelease(*(CFTypeRef *)(a1 + 48));
}

void sub_100093434(uint64_t a1, uint64_t a2, void *a3)
{
  id v5 = a3;
  id WeakRetained = (uint64_t *)objc_loadWeakRetained((id *)(a1 + 32));
  int v7 = WeakRetained;
  double v8 = (const void *)WeakRetained[1];
  if (v8)
  {
    uint64_t v9 = sub_1000E48A8(WeakRetained[1]);
    uint64_t v10 = (void *)objc_claimAutoreleasedReturnValue(v9);

    if (v10)
    {
      if (a2 != 2)
      {
        CFRetain(v8);
        uint64_t v11 = sub_1000E48A8((uint64_t)v8);
        CFMachPortContext v12 = (dispatch_queue_s *)objc_claimAutoreleasedReturnValue(v11);
        block[0] = _NSConcreteStackBlock;
        block[1] = 3221225472LL;
        block[2] = sub_10009355C;
        block[3] = &unk_1001E4808;
        uint64_t v16 = v8;
        uint64_t v15 = v7;
        uint64_t v17 = a2;
        dispatch_async(v12, block);
      }
    }

    else
    {
      uint64_t v13 = objc_autoreleasePoolPush();
      if (qword_100219F60) {
        [qword_100219F60 WFLog:@"%s: null manager queue." message:3];
      }
      objc_autoreleasePoolPop(v13);
    }
  }
}

void sub_10009355C(uint64_t a1)
{
  uint64_t v2 = sub_1000E48A8(*(void *)(a1 + 40));
  id v3 = (void *)objc_claimAutoreleasedReturnValue(v2);

  uint64_t v4 = objc_autoreleasePoolPush();
  if (v3)
  {
    if (qword_100219F60) {
      [qword_100219F60 WFLog:@"%s:WiFiBatteryMgmt : PPM Admission Handler" message:3];
    }
    objc_autoreleasePoolPop(v4);
    if (*(void *)(a1 + 48) == 1LL) {
      uint64_t v5 = 100LL;
    }
    else {
      uint64_t v5 = 0LL;
    }
    [*(id *)(a1 + 32) WiFiBatteryManagerHandlePowerAdmissionResponse:v5];
  }

  else
  {
    if (qword_100219F60) {
      [qword_100219F60 WFLog:@"%s: null manager queue." message:3];
    }
    objc_autoreleasePoolPop(v4);
  }

  CFRelease(*(CFTypeRef *)(a1 + 40));
}

uint64_t sub_10009499C()
{
  uint64_t result = qword_100219950;
  if (!qword_100219950)
  {
    pthread_once(&stru_100219020, (void (*)(void))sub_1000949D8);
    return qword_100219950;
  }

  return result;
}

CFSetRef sub_1000949D8()
{
  qword_100219950 = _CFRuntimeRegisterClass(&unk_1001E4850);
  *(_OWORD *)values = *(_OWORD *)&off_1001E48B0;
  __int128 v3 = *(_OWORD *)&off_1001E48C0;
  uint64_t v4 = @"AcceptEAPTypes";
  qword_100219958 = (uint64_t)CFArrayCreate(kCFAllocatorDefault, (const void **)values, 5LL, &kCFTypeArrayCallBacks);
  v1[0] = *(_OWORD *)&off_1001E48D8;
  v1[1] = *(_OWORD *)&off_1001E48E8;
  CFSetRef result = CFSetCreate(kCFAllocatorDefault, (const void **)v1, 4LL, &kCFTypeSetCallBacks);
  qword_100219960 = (uint64_t)result;
  return result;
}

_WORD *sub_100094AAC(uint64_t a1, CFTypeRef cf)
{
  if (!cf) {
    goto LABEL_9;
  }
  CFTypeID v4 = CFGetTypeID(cf);
  if (v4 != CFDictionaryGetTypeID())
  {
    uint64_t v18 = objc_autoreleasePoolPush();
    if (qword_100219F60) {
      [qword_100219F60 WFLog:@"%s: record is of type %ld!!" message:4];
    }
    goto LABEL_29;
  }

  Value = (const __CFString *)CFDictionaryGetValue((CFDictionaryRef)cf, @"SSID_STR");
  if (Value)
  {
    CFTypeID TypeID = CFStringGetTypeID();
    if (TypeID != CFGetTypeID(Value)) {
      return 0LL;
    }
  }

  if (!sub_10009FFBC(Value) && !CFDictionaryGetValue((CFDictionaryRef)cf, @"DomainName"))
  {
    uint64_t v18 = objc_autoreleasePoolPush();
    if (qword_100219F60) {
      [qword_100219F60 WFLog:@"%s: SSID not valid length" message:3 v19];
    }
LABEL_29:
    objc_autoreleasePoolPop(v18);
    return 0LL;
  }

  int v7 = CFDictionaryGetValue((CFDictionaryRef)cf, @"SSID");
  if (v7)
  {
    double v8 = v7;
    CFTypeID v9 = CFDataGetTypeID();
    if (v9 != CFGetTypeID(v8)) {
      return 0LL;
    }
  }

_WORD *sub_100094CE8(const __CFString *a1)
{
  if (!a1)
  {
    uint64_t v10 = objc_autoreleasePoolPush();
    if (qword_100219F60) {
      [qword_100219F60 WFLog:@"%s: null ssid" message:3];
    }
    goto LABEL_13;
  }

  CFMutableStringRef Mutable = CFDictionaryCreateMutable( kCFAllocatorDefault,  0LL,  &kCFTypeDictionaryKeyCallBacks,  &kCFTypeDictionaryValueCallBacks);
  if (!Mutable)
  {
    uint64_t v10 = objc_autoreleasePoolPush();
    if (qword_100219F60) {
      [qword_100219F60 WFLog:@"%s: null networkRecord" message:3];
    }
LABEL_13:
    objc_autoreleasePoolPop(v10);
    return 0LL;
  }

  __int128 v3 = Mutable;
  CFDictionarySetValue(Mutable, @"SSID_STR", a1);
  CFDataRef ExternalRepresentation = CFStringCreateExternalRepresentation(kCFAllocatorDefault, a1, 0x8000100u, 0);
  if (ExternalRepresentation)
  {
    CFDataRef v5 = ExternalRepresentation;
    CFDictionarySetValue(v3, @"SSID", ExternalRepresentation);
    CFRelease(v5);
  }

  __int16 valuePtr = 2;
  CFNumberRef v6 = CFNumberCreate(kCFAllocatorDefault, kCFNumberSInt16Type, &valuePtr);
  if (v6)
  {
    CFNumberRef v7 = v6;
    CFDictionarySetValue(v3, @"AP_MODE", v6);
    CFRelease(v7);
  }

  double v8 = sub_100094AAC((uint64_t)kCFAllocatorDefault, v3);
  CFRelease(v3);
  return v8;
}

_WORD *sub_100094E60(uint64_t a1, uint64_t a2)
{
  CFSetRef result = sub_100094AAC((uint64_t)kCFAllocatorDefault, *(CFTypeRef *)(a2 + 16));
  result[12] = *(_WORD *)(a2 + 24);
  return result;
}

CFMutableDictionaryRef sub_100094E98(uint64_t a1)
{
  return CFDictionaryCreateMutableCopy(kCFAllocatorDefault, 0LL, *(CFDictionaryRef *)(a1 + 16));
}

CFDictionaryRef sub_100094EB4(uint64_t a1)
{
  MutableCFDictionaryRef Copy = CFDictionaryCreateMutableCopy(kCFAllocatorDefault, 0LL, *(CFDictionaryRef *)(a1 + 16));
  uint64_t v2 = MutableCopy;
  if (MutableCopy)
  {
    if (!CFDictionaryGetValue(MutableCopy, @"SSID_STR"))
    {
      CFDataRef v5 = v2;
      uint64_t v2 = 0LL;
LABEL_10:
      CFRelease(v5);
      return v2;
    }

    Value = (const __CFDictionary *)CFDictionaryGetValue(v2, @"EnterpriseProfile");
    if (Value)
    {
      CFTypeID v4 = CFDictionaryCreateMutableCopy(kCFAllocatorDefault, 0LL, Value);
      if (v4)
      {
        CFDataRef v5 = v4;
        CFNumberRef v6 = (const __CFDictionary *)CFDictionaryGetValue(v4, @"EAPClientConfiguration");
        if (v6)
        {
          CFNumberRef v7 = CFDictionaryCreateMutableCopy(kCFAllocatorDefault, 0LL, v6);
          if (v7)
          {
            double v8 = v7;
            CFDictionaryRemoveValue(v7, @"UserPassword");
            CFDictionaryRemoveValue(v8, @"TLSSaveTrustExceptions");
            CFDictionaryRemoveValue(v8, @"TLSUserTrustProceedCertificateChain");
            CFDictionarySetValue(v5, @"EAPClientConfiguration", v8);
            CFRelease(v8);
          }
        }

        CFDictionarySetValue(v2, @"EnterpriseProfile", v5);
        goto LABEL_10;
      }
    }
  }

  return v2;
}

CFDictionaryRef sub_100094FD8(CFDictionaryRef *a1, const void *a2)
{
  CFTypeID v4 = (const __CFDictionary *)sub_1000951FC((uint64_t)a1, @"EnterpriseProfile");
  if (!v4) {
    return 0LL;
  }
  MutableCFDictionaryRef Copy = CFDictionaryCreateMutableCopy(kCFAllocatorDefault, 0LL, v4);
  CFNumberRef v6 = MutableCopy;
  if (MutableCopy)
  {
    CFDictionarySetValue(MutableCopy, @"EnableUserInterface", kCFBooleanFalse);
    Value = (const __CFDictionary *)CFDictionaryGetValue(v6, @"EAPClientConfiguration");
    if (Value)
    {
      double v8 = CFDictionaryCreateMutableCopy(kCFAllocatorDefault, 0LL, Value);
      if (v8)
      {
        CFTypeID v9 = v8;
        if (a2)
        {
          CFDictionarySetValue(v8, @"UserPassword", a2);
LABEL_23:
          CFDictionarySetValue(v6, @"EAPClientConfiguration", v9);
          CFRelease(v9);
          return v6;
        }

        if (sub_100095318((BOOL)a1))
        {
          CFStringRef v10 = sub_100095370((uint64_t)a1);
          uint64_t v11 = objc_autoreleasePoolPush();
          if (qword_100219F60)
          {
            CFMachPortContext v12 = "non-null";
            if (!v10) {
              CFMachPortContext v12 = "null";
            }
            [qword_100219F60 WFLog:@"%s: __WiFiNetworkCopyPasswordForAccount() returned a %s password" message:3 v12];
          }

          objc_autoreleasePoolPop(v11);
          if (!v10)
          {
            CFStringRef v10 = sub_100095408(a1);
            if (!v10)
            {
              uint64_t v13 = objc_autoreleasePoolPush();
              if (qword_100219F60) {
                [qword_100219F60 WFLog:@"%s: Password for EAP profile NULL after fetch by account name and normal method, attempting password f etch by domain name " message:3];
              }
              objc_autoreleasePoolPop(v13);
              CFStringRef v10 = sub_1000954F8((uint64_t)a1);
              if (!v10)
              {
                CFBooleanRef v14 = objc_autoreleasePoolPush();
                if (qword_100219F60) {
                  [qword_100219F60 WFLog:@"%s: Password for EAP profile still NULL after attempted fetch by domain name" message:3];
                }
                objc_autoreleasePoolPop(v14);
                goto LABEL_23;
              }
            }
          }
        }

        else
        {
          CFStringRef v10 = sub_100095408(a1);
          if (!v10) {
            goto LABEL_23;
          }
        }

        CFDictionarySetValue(v9, @"UserPassword", v10);
        CFRelease(v10);
        goto LABEL_23;
      }
    }
  }

  return v6;
}

const void *sub_1000951FC(uint64_t a1, void *key)
{
  if (!a1)
  {
    CFTypeID v9 = objc_autoreleasePoolPush();
    if (qword_100219F60) {
      [qword_100219F60 WFLog:@"%s: null network" message:3];
    }
    goto LABEL_12;
  }

  __int128 v3 = *(const __CFDictionary **)(a1 + 16);
  if (!v3)
  {
    CFTypeID v9 = objc_autoreleasePoolPush();
    if (qword_100219F60) {
      [qword_100219F60 WFLog:@"%s: null network record" message:3];
    }
LABEL_12:
    objc_autoreleasePoolPop(v9);
    return 0LL;
  }

  CFDataRef v5 = (const __CFArray *)qword_100219958;
  if (!qword_100219958) {
    return CFDictionaryGetValue(v3, key);
  }
  v10.length = CFArrayGetCount((CFArrayRef)qword_100219958);
  v10.location = 0LL;
  int v6 = CFArrayContainsValue(v5, v10, key);
  __int128 v3 = *(const __CFDictionary **)(a1 + 16);
  if (!v6) {
    return CFDictionaryGetValue(v3, key);
  }
  Value = (const __CFDictionary *)CFDictionaryGetValue(v3, @"EnterpriseProfile");
  if (Value)
  {
    __int128 v3 = (const __CFDictionary *)CFDictionaryGetValue(Value, @"EAPClientConfiguration");
    if (v3) {
      return CFDictionaryGetValue(v3, key);
    }
  }

  return 0LL;
}

BOOL sub_100095318(BOOL result)
{
  if (result)
  {
    uint64_t v1 = result;
    return CFDictionaryGetValue(*(CFDictionaryRef *)(result + 16), @"HOTSPOT20_IE")
        || CFDictionaryGetValue(*(CFDictionaryRef *)(v1 + 16), @"DomainName") != 0LL;
  }

  return result;
}

CFStringRef sub_100095370(uint64_t a1)
{
  uint64_t v1 = (__CFString *)sub_1000951FC(a1, @"HS20AccountName");
  uint64_t v2 = objc_autoreleasePoolPush();
  if (qword_100219F60) {
    [(id)qword_100219F60 WFLog:3, "%s: HS 2.0 account name from WiFiNetworkGetProperty() is %@", "__WiFiNetworkCopyPasswordForAccount", v1 message];
  }
  objc_autoreleasePoolPop(v2);
  if (v1 && CFStringGetLength(v1) >= 1) {
    return sub_1000AC858(v1);
  }
  else {
    return 0LL;
  }
}

CFStringRef sub_100095408(CFDictionaryRef *a1)
{
  if (os_log_type_enabled((os_log_t)&_os_log_default, OS_LOG_TYPE_DEFAULT))
  {
    int v5 = 136315394;
    int v6 = "WiFiNetworkCopyPassword";
    __int16 v7 = 2112;
    double v8 = sub_100095CB0(a1);
    _os_log_impl( (void *)&_mh_execute_header,  (os_log_t)&_os_log_default,  OS_LOG_TYPE_DEFAULT,  "%s: Copy password for Network %@",  (uint8_t *)&v5,  0x16u);
  }

  if (!a1
    || !CFDictionaryContainsKey(a1[2], @"PayloadUUID")
    || (v2 = sub_100095CB0(a1), (CFStringRef result = sub_1000ADF40(v2)) == 0LL))
  {
    CFTypeID v4 = (__CFString *)sub_100095CB0(a1);
    return sub_1000AC858(v4);
  }

  return result;
}

__CFString *sub_1000954F8(uint64_t a1)
{
  CFStringRef result = (__CFString *)sub_1000951FC(a1, @"DomainName");
  if (result) {
    return (__CFString *)sub_1000AC858(result);
  }
  return result;
}

void sub_100095524(uint64_t a1, uint64_t a2)
{
  if (a1)
  {
    if (CFDictionaryGetValue(*(CFDictionaryRef *)(a1 + 16), @"WEP") == kCFBooleanTrue)
    {
      CFTypeID v4 = sub_1000951FC(a2, @"WEP_AUTH_Flags");
      if (v4) {
        sub_10009582C(a1, @"WEP_AUTH_Flags", v4);
      }
    }
  }

  if (sub_100095B4C(a2))
  {
    int v5 = sub_1000951FC(a2, @"EnterpriseProfile");
    if (v5) {
      sub_10009582C(a1, @"EnterpriseProfile", v5);
    }
  }

  if (a2 && CFDictionaryGetValue(*(CFDictionaryRef *)(a2 + 16), @"DomainName") && sub_100095318(a1))
  {
    int v6 = sub_1000951FC(a2, @"DisplayedOperatorName");
    if (v6) {
      sub_10009582C(a1, @"HS2NetworkBadge", v6);
    }
    __int16 v7 = sub_1000951FC(a2, @"HS20AccountName");
    if (v7 || (__int16 v7 = sub_100095BC8((const void *)a2)) != 0LL)
    {
      sub_10009582C(a1, @"HS20AccountName", v7);
      double v8 = objc_autoreleasePoolPush();
      if (qword_100219F60) {
        [(id)qword_100219F60 WFLog:3, "%s: Setting HS 2.0 account name to %@ for network %@", "WiFiNetworkMergeForAssociation", v7, sub_100095CB0((const void *)a1) message];
      }
      objc_autoreleasePoolPop(v8);
    }
  }

  CFTypeID v9 = sub_1000951FC(a2, @"TransitionDisabledFlags");
  if (v9) {
    sub_10009582C(a1, @"TransitionDisabledFlags", v9);
  }
  CFRange v10 = (void *)CWFCoreWiFiSpecificAttributesKey;
  uint64_t v11 = sub_1000951FC(a2, CWFCoreWiFiSpecificAttributesKey);
  if (v11) {
    sub_10009582C(a1, v10, v11);
  }
  CFMachPortContext v12 = sub_1000951FC(a2, @"PolicyUUID");
  if (v12) {
    sub_10009582C(a1, @"PolicyUUID", v12);
  }
  uint64_t v13 = sub_1000951FC(a2, @"PayloadUUID");
  if (v13) {
    sub_10009582C(a1, @"PayloadUUID", v13);
  }
  sub_100095D1C((const void *)a1, a2);
  if (&_CNForgetSSID)
  {
    CFBooleanRef v14 = (void *)kCNSCaptiveNetworkProperty;
    BOOL v15 = sub_1000951FC(a2, kCNSCaptiveNetworkProperty);
    sub_10009582C(a1, v14, v15);
  }

  CFBooleanRef v16 = sub_1000951FC(a2, @"WiFiNetworkUserAcceptedRecommendationAt");
  sub_10009582C(a1, @"WiFiNetworkUserAcceptedRecommendationAt", v16);
  if (*(__int16 *)(a1 + 24) == -1)
  {
    int v17 = *(unsigned __int16 *)(a2 + 24);
    if (v17 != 0xFFFF) {
      *(_WORD *)(a1 + 24) = v17;
    }
  }

BOOL sub_1000957F4(BOOL result)
{
  if (result) {
    return CFDictionaryGetValue(*(CFDictionaryRef *)(result + 16), @"WEP") == kCFBooleanTrue;
  }
  return result;
}

void sub_10009582C(uint64_t a1, void *key, const void *a3)
{
  if (!a1)
  {
    unint64_t v27 = objc_autoreleasePoolPush();
    if (qword_100219F60) {
      [qword_100219F60 WFLog:@"%s: null network" message:3];
    }
    goto LABEL_45;
  }

  CFTypeID v4 = *(const __CFDictionary **)(a1 + 16);
  if (!v4)
  {
    unint64_t v27 = objc_autoreleasePoolPush();
    if (qword_100219F60) {
      [qword_100219F60 WFLog:@"%s: null network record" message:3];
    }
LABEL_45:
    objc_autoreleasePoolPop(v27);
    return;
  }

  __int16 v7 = (const __CFArray *)qword_100219958;
  if (qword_100219958
    && (v28.length = CFArrayGetCount((CFArrayRef)qword_100219958),
        v28.location = 0LL,
        int v8 = CFArrayContainsValue(v7, v28, key),
        CFTypeID v4 = *(const __CFDictionary **)(a1 + 16),
        v8))
  {
    Value = (const __CFDictionary *)CFDictionaryGetValue(v4, @"EnterpriseProfile");
    if (!Value || (v10 = Value, (MutableCFDictionaryRef Copy = CFDictionaryCreateMutableCopy(kCFAllocatorDefault, 0LL, Value)) == 0LL))
    {
      BOOL v20 = 0;
      int v17 = 0LL;
      goto LABEL_28;
    }

    CFMachPortContext v12 = MutableCopy;
    uint64_t v13 = (const __CFDictionary *)CFDictionaryGetValue(v10, @"EAPClientConfiguration");
    if (v13 && (CFBooleanRef v14 = CFDictionaryCreateMutableCopy(kCFAllocatorDefault, 0LL, v13)) != 0LL)
    {
      BOOL v15 = v14;
      CFBooleanRef v16 = CFDictionaryGetValue(v14, key);
      int v17 = v16;
      if (v16) {
        CFRetain(v16);
      }
      CFDictionarySetValue(v15, key, a3);
      CFDictionarySetValue(v12, @"EAPClientConfiguration", v15);
      CFRelease(v15);
    }

    else
    {
      int v17 = 0LL;
    }

    CFDictionarySetValue(*(CFMutableDictionaryRef *)(a1 + 16), @"EnterpriseProfile", v12);
    CFRelease(v12);
  }

  else
  {
    uint64_t v18 = CFDictionaryGetValue(v4, key);
    int v17 = v18;
    if (v18) {
      CFRetain(v18);
    }
    uint64_t v19 = *(__CFDictionary **)(a1 + 16);
    if (a3) {
      CFDictionarySetValue(v19, key, a3);
    }
    else {
      CFDictionaryRemoveValue(v19, key);
    }
    if (CFEqual(key, @"EnterpriseProfile") && !sub_100096C08(*(const __CFDictionary **)(a1 + 16)))
    {
      unsigned int v21 = sub_100097F80(*(const __CFDictionary **)(a1 + 16));
      int v22 = sub_100096E90(a1);
      if (v21) {
        sub_100096D18(a1, 1, v22);
      }
      else {
        sub_100096ED0(a1, v22);
      }
    }
  }

  BOOL v20 = v17 != 0LL;
  if (!a3 && v17)
  {
LABEL_27:
    BOOL v20 = 1;
    goto LABEL_30;
  }

BOOL sub_100095B4C(uint64_t a1)
{
  return a1 && !sub_100098380(a1) && sub_1000984A8(*(const __CFDictionary **)(a1 + 16));
}

BOOL sub_100095B88(BOOL result)
{
  if (result) {
    return CFDictionaryGetValue(*(CFDictionaryRef *)(result + 16), @"DomainName") != 0LL;
  }
  return result;
}

void sub_100095BB8(uint64_t a1, const void *a2)
{
}

const void *sub_100095BC8(const void *result)
{
  if (result)
  {
    uint64_t v1 = (uint64_t)result;
    CFStringRef result = sub_1000951FC((uint64_t)result, @"SSID_STR");
    if (!result)
    {
      uint64_t v2 = (const __CFData *)sub_1000951FC(v1, @"SSID");
      if (v2
        && ((__int128 v3 = v2, (v4 = CFStringCreateFromExternalRepresentation(kCFAllocatorDefault, v2, 0x8000100u)) != 0LL)
         || (CFStringRef v4 = CFStringCreateFromExternalRepresentation(kCFAllocatorDefault, v3, 0)) != 0LL)
        || (CFStringRef v4 = CFStringCreateWithCString(kCFAllocatorDefault, "", 0x8000100u)) != 0LL)
      {
        sub_10009582C(v1, @"SSID_STR", v4);
        CFRelease(v4);
      }

      return sub_1000951FC(v1, @"SSID_STR");
    }
  }

  return result;
}

CFStringRef sub_100095CB0(const void *a1)
{
  if (!a1) {
    return 0LL;
  }
  uint64_t v2 = (const __CFString *)sub_100095BC8(a1);
  __int128 v3 = v2;
  if ((!v2 || !CFStringGetLength(v2)) && sub_100095318((BOOL)a1))
  {
    CFStringRef v4 = sub_1000951FC((uint64_t)a1, @"DomainName");
    if (v4) {
      return (const __CFString *)v4;
    }
  }

  return v3;
}

void sub_100095D1C(const void *a1, uint64_t a2)
{
  if (!a1)
  {
    uint64_t v11 = objc_autoreleasePoolPush();
    if (qword_100219F60) {
      [qword_100219F60 WFLog:@"%s: null destNetwork" message:3 v12 v13];
    }
    goto LABEL_10;
  }

  if (!a2)
  {
    uint64_t v11 = objc_autoreleasePoolPush();
    if (qword_100219F60) {
      [qword_100219F60 WFLog:@"%s: null srcNetwork" message:3 v12 v13];
    }
    goto LABEL_10;
  }

  sub_1000A0508((uint64_t)a1);
  BOOL v4 = sub_10009A128(a2);
  sub_100099ED0((uint64_t)a1, v4);
  if (!v4)
  {
    int v5 = objc_autoreleasePoolPush();
    if (qword_100219F60) {
      [(id)qword_100219F60 WFLog:3, "%s: preserving all AJ-disabled-related properties for network %@", "WiFiNetworkMergeAutoJoinProperties", sub_100095BC8(a1) message];
    }
    objc_autoreleasePoolPop(v5);
    int v6 = sub_1000951FC(a2, @"networkDisabledClientName");
    sub_10009582C((uint64_t)a1, @"networkDisabledClientName", v6);
    __int16 v7 = sub_1000951FC(a2, @"networkDisabledReason");
    sub_10009582C((uint64_t)a1, @"networkDisabledReason", v7);
    int v8 = sub_1000951FC(a2, @"networkDisabledTimestamp");
    sub_10009582C((uint64_t)a1, @"networkDisabledTimestamp", v8);
    CFTypeID v9 = sub_1000951FC(a2, @"WiFiNetworkDisabledUntilDate");
    if (v9)
    {
      CFRange v10 = v9;
      sub_10009582C((uint64_t)a1, @"WiFiNetworkDisabledUntilDate", v9);
      uint64_t v11 = objc_autoreleasePoolPush();
      if (qword_100219F60) {
        [(id)qword_100219F60 WFLog:3, "%s: preserved disabledUntil for %@ network with %@", "WiFiNetworkMergeAutoJoinProperties", sub_100095BC8(a1), v10 message];
      }
LABEL_10:
      objc_autoreleasePoolPop(v11);
    }
  }

void sub_100095F10(uint64_t a1, uint64_t a2)
{
  if (a2)
  {
    sub_100095F5C((CFMutableDictionaryRef *)a1, *(CFDictionaryRef *)(a2 + 16));
    if (*(__int16 *)(a1 + 24) == -1)
    {
      int v4 = *(unsigned __int16 *)(a2 + 24);
      if (v4 != 0xFFFF) {
        *(_WORD *)(a1 + 24) = v4;
      }
    }
  }

void sub_100095F5C(CFMutableDictionaryRef *a1, CFDictionaryRef theDict)
{
  if (!a1) {
    return;
  }
  if (!theDict) {
    return;
  }
  __int128 v3 = a1;
  unsigned int Count = CFDictionaryGetCount(theDict);
  uint64_t v5 = Count;
  if (!Count) {
    return;
  }
  size_t v6 = 8LL * Count;
  __int16 v7 = (const void **)malloc(v6);
  CFIndex v40 = (const void **)malloc(v6);
  CFDictionaryGetKeysAndValues(theDict, v7, v40);
  uint64_t v8 = 0LL;
  int v9 = 0;
  char v43 = 0;
  uint64_t v39 = v5;
  do
  {
    if (CFStringCompare(@"LEAKY_AP_LEARNED_DATA", (CFStringRef)v7[v8], 0LL) == kCFCompareEqualTo)
    {
      CFRange v10 = objc_autoreleasePoolPush();
      if (qword_100219F60) {
        [(id)qword_100219F60 WFLog:3, "%s: Found APPLE80211KEY_LEAKY_AP_LEARNED_DATA for network %@", "WiFiNetworkMergeProperties", sub_100095BC8(v3) message];
      }
      objc_autoreleasePoolPop(v10);
      char v43 = 1;
    }

    if (!sub_100095318((BOOL)v3)
      || CFStringCompare(@"SSID_STR", (CFStringRef)v7[v8], 0LL)
      && CFStringCompare(@"SSID", (CFStringRef)v7[v8], 0LL))
    {
      if (CFStringCompare(@"PRIVATE_MAC_ADDRESS", (CFStringRef)v7[v8], 0LL) == kCFCompareEqualTo) {
        goto LABEL_68;
      }
      if (CFStringCompare(@"EnterpriseProfile", (CFStringRef)v7[v8], 0LL) == kCFCompareEqualTo)
      {
        uint64_t v13 = (const __CFDictionary *)sub_1000951FC((uint64_t)v3, @"EnterpriseProfile");
        CFMutableStringRef Mutable = v13;
        if (!v13) {
          CFMutableStringRef Mutable = CFDictionaryCreateMutable( kCFAllocatorDefault,  0LL,  &kCFTypeDictionaryKeyCallBacks,  &kCFTypeDictionaryValueCallBacks);
        }
        BOOL v15 = (const __CFDictionary *)v40[v8];
        CFBooleanRef v16 = sub_10009656C(Mutable, v15);
        __int16 valuePtr = 0LL;
        value = 0LL;
        CFDictionaryGetValueIfPresent(v15, @"EAPClientConfiguration", (const void **)&valuePtr);
        CFDictionaryGetValueIfPresent(Mutable, @"EAPClientConfiguration", (const void **)&value);
        int v17 = valuePtr;
        if (valuePtr)
        {
          uint64_t v18 = value;
          uint64_t v19 = value;
          if (!value)
          {
            uint64_t v19 = CFDictionaryCreateMutable( kCFAllocatorDefault,  0LL,  &kCFTypeDictionaryKeyCallBacks,  &kCFTypeDictionaryValueCallBacks);
            value = v19;
            int v17 = valuePtr;
          }

          CFDictionaryRef v20 = sub_10009656C((CFDictionaryRef)v19, v17);
          Default = CFAllocatorGetDefault();
          MutableCFDictionaryRef Copy = CFDictionaryCreateMutableCopy(Default, 0LL, v16);
          CFDictionarySetValue(MutableCopy, @"EAPClientConfiguration", v20);
          sub_10009582C((uint64_t)v3, @"EnterpriseProfile", MutableCopy);
          if (MutableCopy) {
            CFRelease(MutableCopy);
          }
          if (v20) {
            CFRelease(v20);
          }
          if (!v18 && value)
          {
            CFRelease(value);
            value = 0LL;
          }

          if (v16) {
LABEL_40:
          }
            CFRelease(v16);
        }

        else
        {
          sub_10009582C((uint64_t)v3, @"EnterpriseProfile", v16);
          if (v16) {
            goto LABEL_40;
          }
        }

        if (!v13 && Mutable) {
          CFRelease(Mutable);
        }
        int v9 = 1;
        uint64_t v5 = v39;
        goto LABEL_68;
      }

      if (CFStringCompare(@"HomePropertyFromMobilewifitool", (CFStringRef)v7[v8], 0LL)
        && CFStringCompare(@"COLOCATED_NETWORK_SCOPE_ID", (CFStringRef)v7[v8], 0LL))
      {
        if (CFStringCompare(@"NetworkOfInterestHomeState", (CFStringRef)v7[v8], 0LL) == kCFCompareEqualTo)
        {
          uint64_t v11 = (const __CFNumber *)v40[v8];
          LODWORD(valuePtr) = 0;
          if (sub_100096670((uint64_t)v3))
          {
            if (v11) {
              CFNumberGetValue(v11, kCFNumberSInt32Type, &valuePtr);
            }
          }
        }

        if (CFStringCompare(@"networkKnownBSSListKey", (CFStringRef)v7[v8], 0LL) == kCFCompareEqualTo
          && (uint64_t v23 = (const __CFArray *)sub_1000951FC((uint64_t)v3, @"networkKnownBSSListKey"),
              (theArray = (const __CFArray *)v40[v8]) != 0LL)
          && (CFDateRef v24 = v23) != 0LL)
        {
          CFIndex v25 = CFArrayGetCount(theArray);
          CFIndex v26 = CFArrayGetCount(v24);
          CFMutableArrayRef v27 = CFArrayCreateMutableCopy(kCFAllocatorDefault, 0LL, v24);
          CFIndex v41 = v25;
          if (v25 >= 1)
          {
            CFIndex v28 = 0LL;
            __int16 v38 = v3;
            do
            {
              ValueAtIndex = (const __CFDictionary *)CFArrayGetValueAtIndex(theArray, v28);
              if (ValueAtIndex)
              {
                uint64_t v30 = ValueAtIndex;
                CFNumberRef v31 = v27;
                CFNumberRef v32 = (const __CFString *)CFDictionaryGetValue(ValueAtIndex, @"BSSID");
                if (v26 < 1)
                {
LABEL_60:
                  CFMutableArrayRef v27 = v31;
                  CFArrayAppendValue(v31, v30);
                }

                else
                {
                  BOOL v33 = v32;
                  id v34 = 0LL;
                  CFIndex v35 = 0LL;
                  while (1)
                  {
                    uint64_t v36 = (const __CFDictionary *)CFArrayGetValueAtIndex(v24, v35);
                    if (v36) {
                      id v34 = (const __CFString *)CFDictionaryGetValue(v36, @"BSSID");
                    }
                    if (v34 && v33 && CFStringCompare(v34, v33, 1uLL) == kCFCompareEqualTo) {
                      break;
                    }
                    if (v26 == ++v35) {
                      goto LABEL_60;
                    }
                  }

                  CFMutableArrayRef v27 = v31;
                  CFArraySetValueAtIndex(v31, v35, v30);
                }

                __int128 v3 = v38;
              }

              ++v28;
            }

            while (v28 != v41);
          }

          sub_10009582C((uint64_t)v3, @"networkKnownBSSListKey", v27);
          if (v27) {
            CFRelease(v27);
          }
          int v9 = 1;
        }

        else if (CFStringCompare(@"lastUpdated", (CFStringRef)v7[v8], 0LL) || v9 != 1)
        {
          CFRetain(v40[v8]);
          CFDictionarySetValue(v3[2], v7[v8], v40[v8]);
          CFRelease(v40[v8]);
        }

        uint64_t v5 = v39;
      }
    }

    else
    {
      uint64_t v12 = objc_autoreleasePoolPush();
      if (qword_100219F60) {
        [(id)qword_100219F60 WFLog:3, "%s: skip %@ merge for hs20 network %@", "WiFiNetworkMergeProperties", v7[v8], sub_100095BC8(v3) message];
      }
      objc_autoreleasePoolPop(v12);
    }

LABEL_68:
    ++v8;
  }

  while (v8 != v5);
  if ((v43 & 1) == 0 && sub_1000951FC((uint64_t)v3, @"LEAKY_AP_LEARNED_DATA"))
  {
    CFDictionaryRemoveValue(v3[2], @"LEAKY_AP_LEARNED_DATA");
    __int16 v37 = objc_autoreleasePoolPush();
    if (qword_100219F60) {
      [(id)qword_100219F60 WFLog:3, "%s: Removing APPLE80211KEY_LEAKY_AP_LEARNED_DATA for network %@", "WiFiNetworkMergeProperties", sub_100095BC8(v3) message];
    }
    objc_autoreleasePoolPop(v37);
  }

  free(v40);
  free(v7);
}

  objc_autoreleasePoolPop(v4);
}

CFDictionaryRef sub_10009656C(CFDictionaryRef result, CFDictionaryRef theDict)
{
  if (result)
  {
    __int128 v3 = result;
    if (theDict && (Count = CFDictionaryGetCount(theDict), (uint64_t v5 = Count) != 0))
    {
      size_t v6 = 8LL * Count;
      __int16 v7 = (const void **)malloc(v6);
      uint64_t v8 = (const void **)malloc(v6);
      Default = CFAllocatorGetDefault();
      MutableCFDictionaryRef Copy = CFDictionaryCreateMutableCopy(Default, 0LL, v3);
      CFDictionaryGetKeysAndValues(theDict, v7, v8);
      unint64_t v11 = 0LL;
      uint64_t v12 = 8 * v5;
      do
      {
        CFDictionaryGetValueIfPresent(MutableCopy, v7[v11 / 8], 0LL);
        CFDictionaryAddValue(MutableCopy, v7[v11 / 8], v8[v11 / 8]);
        v11 += 8LL;
      }

      while (v12 != v11);
      free(v8);
      free(v7);
      uint64_t v13 = CFAllocatorGetDefault();
      CFDictionaryRef Copy = CFDictionaryCreateCopy(v13, MutableCopy);
      CFRelease(MutableCopy);
      return Copy;
    }

    else
    {
      BOOL v15 = CFAllocatorGetDefault();
      return CFDictionaryCreateCopy(v15, v3);
    }
  }

  return result;
}

CFNumberRef sub_100096670(uint64_t a1)
{
  unsigned int valuePtr = 0;
  if (a1)
  {
    CFStringRef result = (const __CFNumber *)sub_1000951FC(a1, @"NetworkOfInterestHomeState");
    if (result)
    {
      int Value = CFNumberGetValue(result, kCFNumberSInt32Type, &valuePtr);
      if (valuePtr - 3 >= 0xFFFFFFFE || Value == 0) {
        return (const __CFNumber *)valuePtr;
      }
      else {
        return 0LL;
      }
    }
  }

  else
  {
    int v4 = objc_autoreleasePoolPush();
    if (qword_100219F60) {
      [qword_100219F60 WFLog:@"%s: null network" message:3];
    }
    objc_autoreleasePoolPop(v4);
    return 0LL;
  }

  return result;
}

const void *sub_100096710(uint64_t a1)
{
  return sub_1000951FC(a1, @"networkKnownBSSListKey");
}

CFDictionaryRef sub_10009671C(const __CFDictionary *result)
{
  if (result)
  {
    uint64_t v1 = result;
    CFStringRef result = (const __CFDictionary *)CFDictionaryGetValue(result, @"SSID_STR");
    if (!result)
    {
      int Value = (const __CFData *)CFDictionaryGetValue(v1, @"SSID");
      if (Value
        && ((__int128 v3 = Value, (v4 = CFStringCreateFromExternalRepresentation(kCFAllocatorDefault, Value, 0x8000100u)) != 0LL)
         || (CFStringRef v4 = CFStringCreateFromExternalRepresentation(kCFAllocatorDefault, v3, 0)) != 0LL)
        || (CFStringRef v4 = CFStringCreateWithCString(kCFAllocatorDefault, "", 0x8000100u)) != 0LL)
      {
        CFDictionarySetValue(v1, @"SSID_STR", v4);
        CFRelease(v4);
      }

      return (const __CFDictionary *)CFDictionaryGetValue(v1, @"SSID_STR");
    }
  }

  return result;
}

CFStringRef sub_100096804(const void *a1)
{
  CFStringRef result = (const __CFString *)sub_1000951FC((uint64_t)a1, @"SSID");
  if (!result)
  {
    CFStringRef result = (const __CFString *)sub_100095BC8(a1);
    if (result)
    {
      CFStringRef result = (const __CFString *)CFStringCreateExternalRepresentation(kCFAllocatorDefault, result, 0x8000100u, 0);
      if (result)
      {
        __int128 v3 = result;
        sub_10009582C((uint64_t)a1, @"SSID", result);
        CFRelease(v3);
        return (const __CFString *)sub_1000951FC((uint64_t)a1, @"SSID");
      }
    }
  }

  return result;
}

CFDataRef sub_1000968A4(uint64_t a1)
{
  CFDataRef result = (CFDataRef)sub_1000951FC(a1, @"BSSID");
  if (result)
  {
    uint64_t v2 = (const __CFString *)result;
    CFTypeID v3 = CFGetTypeID(result);
    if (v3 == CFStringGetTypeID()
      && (uint64_t v4 = 0LL, v5[0] = 0LL, *(_DWORD *)((char *)v5 + 7) = 0, CFStringGetCString(v2, (char *)&v4, 19LL, 0x8000100u)))
    {
      CFDataRef result = (CFDataRef)ether_aton((const char *)&v4);
      if (result) {
        return CFDataCreate(kCFAllocatorDefault, (const UInt8 *)result, 6LL);
      }
    }

    else
    {
      return 0LL;
    }
  }

  return result;
}

CFArrayRef sub_100096968(const __CFArray *result)
{
  if (result)
  {
    uint64_t v1 = (uint64_t)result;
    CFDataRef result = (const __CFArray *)sub_1000951FC((uint64_t)result, @"BSSID");
    if (!result)
    {
      CFDataRef result = (const __CFArray *)sub_1000951FC(v1, @"networkKnownBSSListKey");
      if (result)
      {
        uint64_t v2 = result;
        CFDataRef result = (const __CFArray *)CFArrayGetCount(result);
        if (result)
        {
          CFIndex Count = CFArrayGetCount(v2);
          CFDataRef result = (const __CFArray *)CFArrayGetValueAtIndex(v2, Count - 1);
          if (result) {
            return (const __CFArray *)CFDictionaryGetValue(result, @"BSSID");
          }
        }
      }
    }
  }

  return result;
}

const void *sub_1000969E4(const void *result)
{
  if (result) {
    return sub_1000951FC((uint64_t)result, @"SCAN_BSSID_LIST");
  }
  return result;
}

CFArrayRef sub_1000969F8(const __CFArray *result)
{
  if (result)
  {
    uint64_t v1 = (uint64_t)result;
    CFDataRef result = (const __CFArray *)sub_1000951FC((uint64_t)result, @"CHANNEL");
    if (!result)
    {
      CFDataRef result = (const __CFArray *)sub_1000951FC(v1, @"networkKnownBSSListKey");
      if (result)
      {
        uint64_t v2 = result;
        CFDataRef result = (const __CFArray *)CFArrayGetCount(result);
        if (result)
        {
          CFIndex Count = CFArrayGetCount(v2);
          CFDataRef result = (const __CFArray *)CFArrayGetValueAtIndex(v2, Count - 1);
          if (result) {
            return (const __CFArray *)CFDictionaryGetValue(result, @"CHANNEL");
          }
        }
      }
    }
  }

  return result;
}

const void *sub_100096A74(uint64_t a1)
{
  if (a1) {
    return sub_1000951FC(a1, @"CHANNEL");
  }
  uint64_t v2 = objc_autoreleasePoolPush();
  if (qword_100219F60) {
    objc_msgSend((id)qword_100219F60, "WFLog:message:", 3, "%s: null network", "WiFiNetworkGetChannel");
  }
  objc_autoreleasePoolPop(v2);
  return 0LL;
}

uint64_t sub_100096AE4(uint64_t a1, void *a2, void *a3)
{
  *a3 = 0xFFFFFFFF80000000LL;
  *a2 = 37LL;
  uint64_t result = (uint64_t)sub_1000951FC(a1, @"RATES");
  if (result)
  {
    size_t v6 = (const __CFArray *)result;
    uint64_t result = CFArrayGetCount((CFArrayRef)result);
    if (result >= 1)
    {
      uint64_t v7 = result;
      for (CFIndex i = 0LL; i != v7; ++i)
      {
        uint64_t result = (uint64_t)CFArrayGetValueAtIndex(v6, i);
        int valuePtr = -1431655766;
        if (result)
        {
          int v9 = (const void *)result;
          CFTypeID TypeID = CFNumberGetTypeID();
          uint64_t result = CFGetTypeID(v9);
          if (TypeID == result)
          {
            uint64_t result = CFNumberGetValue((CFNumberRef)v9, kCFNumberIntType, &valuePtr);
            uint64_t v11 = valuePtr;
            if (*a3 < valuePtr) {
              *a3 = valuePtr;
            }
            if (*a2 > v11) {
              *a2 = v11;
            }
          }
        }
      }
    }
  }

  return result;
}

CFNumberRef sub_100096BD0(const __CFNumber *result)
{
  if (result)
  {
    uint64_t v1 = (const __CFNumber *)sub_1000951FC((uint64_t)result, @"RSSI");
    return sub_10003AC9C(v1);
  }

  return result;
}

CFNumberRef sub_100096BF4(uint64_t a1, void *a2)
{
  uint64_t v2 = (const __CFNumber *)sub_1000951FC(a1, a2);
  return sub_10003AC9C(v2);
}

BOOL sub_100096C08(const __CFDictionary *a1)
{
  int Value = (const __CFDictionary *)CFDictionaryGetValue(a1, @"WPA_IE");
  CFTypeID v3 = (const __CFDictionary *)CFDictionaryGetValue(a1, @"RSN_IE");
  if (Value && (CFTypeID TypeID = CFDictionaryGetTypeID(), sub_10003AE00(TypeID, Value)))
  {
    BOOL v5 = 1LL;
  }

  else
  {
    BOOL v5 = 0LL;
  }

  if (!v5)
  {
    if (v3)
    {
      BOOL v5 = 1LL;
      if (!sub_1000A4E24(v3, 1)
        && !sub_1000A4E24(v3, 0)
        && !sub_1000A4E24(v3, 3)
        && !sub_1000A4E24(v3, 5)
        && !sub_1000A4E24(v3, 12))
      {
        return sub_1000A4E24(v3, 13) != 0;
      }
    }
  }

  return v5;
}

CFDictionaryRef sub_100096D08(const __CFDictionary *result)
{
  if (result) {
    return sub_100097F80(*((const __CFDictionary **)result + 2));
  }
  return result;
}

void sub_100096D18(int a1, int a2, int a3)
{
  if (a2)
  {
    CFMutableArrayRef Mutable = CFArrayCreateMutable(kCFAllocatorDefault, 0LL, &kCFTypeArrayCallBacks);
    values = Mutable;
    if (Mutable)
    {
      size_t v6 = Mutable;
      uint64_t valuePtr = 8LL;
      CFNumberRef v7 = CFNumberCreate(kCFAllocatorDefault, kCFNumberCFIndexType, &valuePtr);
      if (v7)
      {
        CFNumberRef v8 = v7;
        CFArrayAppendValue(v6, v7);
        CFRelease(v8);
      }

      if (a3)
      {
        uint64_t valuePtr = 2LL;
        CFNumberRef v9 = CFNumberCreate(kCFAllocatorDefault, kCFNumberCFIndexType, &valuePtr);
        if (v9)
        {
          CFNumberRef v10 = v9;
          CFArrayAppendValue(v6, v9);
          CFRelease(v10);
        }
      }

      else
      {
        sub_10009582C(a1, @"ALLOW_WPA2_PSK");
      }

      keys = @"IE_KEY_RSN_AUTHSELS";
      CFDictionaryRef v11 = CFDictionaryCreate( kCFAllocatorDefault,  (const void **)&keys,  (const void **)&values,  1LL,  &kCFTypeDictionaryKeyCallBacks,  &kCFTypeDictionaryValueCallBacks);
      if (v11)
      {
        CFDictionaryRef v12 = v11;
        sub_10009582C(a1, @"RSN_IE");
        CFRelease(v12);
      }

      CFRelease(values);
    }
  }

  else
  {
    sub_10009582C(a1, @"RSN_IE");
  }

uint64_t sub_100096E90(uint64_t result)
{
  if (result)
  {
    uint64_t v1 = *(const __CFDictionary **)(result + 16);
    else {
      return sub_100098068(v1);
    }
  }

  return result;
}

void sub_100096ED0(uint64_t a1, int a2)
{
  int v2 = a1;
  if (a2)
  {
    uint64_t v3 = 2LL * (sub_1000951FC(a1, @"EnterpriseProfile") == 0LL);
    uint64_t valuePtr = v3;
    values = CFNumberCreate(kCFAllocatorDefault, kCFNumberCFIndexType, &valuePtr);
    if (values)
    {
      CFTypeRef cf = CFArrayCreate(kCFAllocatorDefault, (const void **)&values, 1LL, &kCFTypeArrayCallBacks);
      if (cf)
      {
        CFNumberRef v8 = @"IE_KEY_RSN_AUTHSELS";
        CFDictionaryRef v4 = CFDictionaryCreate( kCFAllocatorDefault,  (const void **)&v8,  &cf,  1LL,  &kCFTypeDictionaryKeyCallBacks,  &kCFTypeDictionaryValueCallBacks);
        if (v4)
        {
          CFDictionaryRef v5 = v4;
          sub_10009582C(v2, @"RSN_IE");
          CFRelease(v5);
        }

        if (cf)
        {
          CFRelease(cf);
          CFTypeRef cf = 0LL;
        }
      }

      if (values)
      {
        CFRelease(values);
        values = 0LL;
      }
    }

    uint64_t valuePtr = v3;
    values = CFNumberCreate(kCFAllocatorDefault, kCFNumberCFIndexType, &valuePtr);
    if (values)
    {
      CFTypeRef cf = CFArrayCreate(kCFAllocatorDefault, (const void **)&values, 1LL, &kCFTypeArrayCallBacks);
      if (cf)
      {
        CFNumberRef v8 = @"IE_KEY_WPA_AUTHSELS";
        CFDictionaryRef v6 = CFDictionaryCreate( kCFAllocatorDefault,  (const void **)&v8,  &cf,  1LL,  &kCFTypeDictionaryKeyCallBacks,  &kCFTypeDictionaryValueCallBacks);
        if (v6)
        {
          CFDictionaryRef v7 = v6;
          sub_10009582C(v2, @"WPA_IE");
          CFRelease(v7);
        }

        if (cf)
        {
          CFRelease(cf);
          CFTypeRef cf = 0LL;
        }
      }

      if (values) {
        CFRelease(values);
      }
    }
  }

  else
  {
    sub_10009582C(a1, @"RSN_IE");
    sub_10009582C(v2, @"WPA_IE");
  }

void sub_1000970C0(uint64_t a1, void *a2, uint64_t a3)
{
  uint64_t valuePtr = a3;
  CFNumberRef v5 = CFNumberCreate(kCFAllocatorDefault, kCFNumberCFIndexType, &valuePtr);
  if (v5)
  {
    CFNumberRef v6 = v5;
    sub_10009582C(a1, a2, v5);
    CFRelease(v6);
  }

double sub_10009712C(uint64_t a1, void *a2)
{
  int v2 = sub_1000951FC(a1, a2);
  return sub_10003AC38(v2);
}

void sub_100097140(uint64_t a1, void *a2, double a3)
{
  double valuePtr = a3;
  CFNumberRef v5 = CFNumberCreate(kCFAllocatorDefault, kCFNumberDoubleType, &valuePtr);
  if (v5)
  {
    CFNumberRef v6 = v5;
    sub_10009582C(a1, a2, v5);
    CFRelease(v6);
  }

CFNumberRef sub_1000971AC(uint64_t a1)
{
  uint64_t result = (const __CFNumber *)sub_1000951FC(a1, @"AP_MODE");
  if (result)
  {
    __int16 valuePtr = -21846;
    uint64_t result = (const __CFNumber *)CFNumberGetValue(result, kCFNumberSInt16Type, &valuePtr);
    if ((_DWORD)result) {
      return (const __CFNumber *)(valuePtr == 1);
    }
  }

  return result;
}

uint64_t sub_1000971F8(const void *a1)
{
  int v2 = (const __CFNumber *)sub_1000951FC((uint64_t)a1, @"HIDDEN_NETWORK");
  unsigned int v3 = sub_10003AC9C(v2);
  if (v3) {
    goto LABEL_2;
  }
  CFNumberRef v5 = (const __CFNumber *)sub_1000951FC((uint64_t)a1, @"scanWasDirected");
  if (!sub_10003AC9C(v5))
  {
    unsigned int v3 = sub_100097264(a1);
LABEL_2:
    unsigned int v4 = 0;
    goto LABEL_5;
  }

  unsigned int v3 = 0;
  unsigned int v4 = 1;
LABEL_5:
  if (v3) {
    return 1LL;
  }
  else {
    return v4;
  }
}

BOOL sub_100097264(const void *a1)
{
  uint64_t v1 = sub_100095BC8(a1);
  if (v1 && (int v2 = v1, !CFEqual(v1, &stru_1001EB6E0))) {
    return CFEqual(v2, @" ") != 0;
  }
  else {
    return 1LL;
  }
}

BOOL sub_1000972B8(uint64_t a1)
{
  CFBooleanRef v1 = (CFBooleanRef)sub_1000951FC(a1, @"AmbiguousSSIDs");
  return v1 && v1 == kCFBooleanTrue;
}

BOOL sub_1000972F0(const void *a1)
{
  CFBooleanRef v1 = (const __CFString *)sub_100095BC8(a1);
  return v1 && CFStringHasSuffix(v1, @"_nomap");
}

uint64_t sub_100097324(const void *a1)
{
  int v2 = (const __CFNumber *)sub_1000951FC((uint64_t)a1, @"UserDirected");
  uint64_t v3 = sub_10003AC9C(v2);
  if (v3 || !sub_1000971F8(a1))
  {
    unsigned int v4 = 0;
  }

  else
  {
    sub_10009582C((uint64_t)a1, @"UserDirected", kCFBooleanTrue);
    unsigned int v4 = 1;
  }

  if (v3) {
    return 1LL;
  }
  else {
    return v4;
  }
}

void sub_100097394(uint64_t a1, int a2)
{
  int v2 = (const void **)&kCFBooleanTrue;
  if (!a2) {
    int v2 = (const void **)&kCFBooleanFalse;
  }
  sub_10009582C(a1, @"UserDirected", *v2);
}

BOOL sub_1000973BC(uint64_t a1)
{
  return &_CNForgetSSID
      && CFDictionaryGetValue(*(CFDictionaryRef *)(a1 + 16), kCNSCaptiveNetworkProperty) == kCFBooleanTrue;
}

BOOL sub_10009740C(uint64_t a1)
{
  return &_CNForgetSSID
      && CFDictionaryGetValue(*(CFDictionaryRef *)(a1 + 16), kCNSNetworkWasCaptiveProperty) == kCFBooleanTrue;
}

const void *sub_10009745C(uint64_t a1)
{
  if (a1 && (CFBooleanRef v1 = *(const __CFDictionary **)(a1 + 16)) != 0LL) {
    return CFDictionaryGetValue(v1, @"DiagnosticsBssEnv");
  }
  else {
    return 0LL;
  }
}

uint64_t sub_100097480(uint64_t a1)
{
  if (!&_CNForgetSSID) {
    return 0LL;
  }
  value = 0LL;
  int ValueIfPresent = CFDictionaryGetValueIfPresent( *(CFDictionaryRef *)(a1 + 16),  kCNSCaptiveNetworkProperty,  (const void **)&value);
  if (value == kCFBooleanTrue) {
    unsigned int v2 = 2;
  }
  else {
    unsigned int v2 = 1;
  }
  if (ValueIfPresent) {
    return v2;
  }
  else {
    return 0LL;
  }
}

BOOL sub_1000974EC(uint64_t a1)
{
  if (!a1)
  {
    uint64_t v13 = objc_autoreleasePoolPush();
    if (qword_100219F60) {
      [qword_100219F60 WFLog:@"%s: null network." message:4, "WiFiNetworkIsWoWAllowed", v17];
    }
    goto LABEL_26;
  }

  unsigned int v2 = *(const void **)(a1 + 16);
  if (!v2)
  {
    uint64_t v13 = objc_autoreleasePoolPush();
    if (qword_100219F60) {
      [qword_100219F60 WFLog:@"%s: null network record." message:4];
    }
    goto LABEL_26;
  }

  CFTypeID v3 = CFGetTypeID(v2);
  if (v3 != CFDictionaryGetTypeID())
  {
    CFBooleanRef v14 = objc_autoreleasePoolPush();
    if (qword_100219F60) {
      [qword_100219F60 WFLog:@"%s: bad record type %ld" message:4, "WiFiNetworkIsWoWAllowed", CFGetTypeID(*(CFTypeRef *)(a1 + 16))];
    }
    BOOL v15 = v14;
    goto LABEL_27;
  }

  int Value = CFDictionaryGetValue(*(CFDictionaryRef *)(a1 + 16), @"IE");
  if (!Value) {
    return 1LL;
  }
  CFNumberRef v5 = Value;
  CFTypeID v6 = CFGetTypeID(Value);
  if (v6 != CFDataGetTypeID())
  {
    uint64_t v13 = objc_autoreleasePoolPush();
    if (qword_100219F60) {
      [qword_100219F60 WFLog:@"__WiFiNetworkIsWoWAllowed: bad ieList type %ld" message:4];
    }
LABEL_26:
    BOOL v15 = v13;
LABEL_27:
    objc_autoreleasePoolPop(v15);
    return 1LL;
  }

  BytePtr = CFDataGetBytePtr((CFDataRef)v5);
  if (!BytePtr) {
    return 1LL;
  }
  CFNumberRef v8 = BytePtr;
  CFIndex Length = CFDataGetLength((CFDataRef)v5);
  if (Length << 32 < 1) {
    return 1LL;
  }
  uint64_t v10 = 0LL;
  while (*v8 != 221 || v8[1] != 10 || *(_DWORD *)(v8 + 2) != 116528896 || *(_DWORD *)(v8 + 5) != 50397446)
  {
    uint64_t v12 = v8[1] + 2LL;
    v10 += v12;
    v8 += v12;
  }

  return (v8[9] & 3) != 1;
}

uint64_t sub_100097700(uint64_t a1)
{
  if (!a1)
  {
    CFTypeID v6 = objc_autoreleasePoolPush();
    if (qword_100219F60) {
      [qword_100219F60 WFLog:@"%s: null network." message:@"WiFiNetworkIsApplePersonalHotspot" v16];
    }
    goto LABEL_11;
  }

  unsigned int v2 = *(const void **)(a1 + 16);
  if (!v2)
  {
    CFTypeID v6 = objc_autoreleasePoolPush();
    if (qword_100219F60) {
      [qword_100219F60 WFLog:@"%s: null network record." message:4 v16];
    }
    goto LABEL_11;
  }

  CFTypeID v3 = CFGetTypeID(v2);
  if (v3 != CFDictionaryGetTypeID())
  {
    CFNumberRef v8 = objc_autoreleasePoolPush();
    if (qword_100219F60) {
      [qword_100219F60 WFLog:@"%s: bad record type %ld" message:4, "%s: bad record type %ld", "WiFiNetworkIsApplePersonalHotspot", CFGetTypeID(*(CFTypeRef *)(a1 + 16))];
    }
    CFDictionaryRef v7 = v8;
    goto LABEL_15;
  }

  int Value = CFDictionaryGetValue(*(CFDictionaryRef *)(a1 + 16), @"IsPersonalHotspot");
  if (Value && CFEqual(Value, kCFBooleanTrue)) {
    return 1LL;
  }
  uint64_t result = (uint64_t)CFDictionaryGetValue(*(CFDictionaryRef *)(a1 + 16), @"IE");
  if (!result) {
    return result;
  }
  CFNumberRef v9 = (const void *)result;
  CFTypeID v10 = CFGetTypeID((CFTypeRef)result);
  if (v10 != CFDataGetTypeID())
  {
    CFTypeID v6 = objc_autoreleasePoolPush();
    if (qword_100219F60) {
      [qword_100219F60 WFLog:@"__WiFiNetworkIsAppleDevice: bad ieList type %ld" message:4];
    }
LABEL_11:
    CFDictionaryRef v7 = v6;
LABEL_15:
    objc_autoreleasePoolPop(v7);
    return 0LL;
  }

  uint64_t result = (uint64_t)CFDataGetBytePtr((CFDataRef)v9);
  if (result)
  {
    CFDictionaryRef v11 = (unsigned __int8 *)result;
    CFIndex Length = CFDataGetLength((CFDataRef)v9);
    if (Length << 32 >= 1)
    {
      uint64_t v13 = 0LL;
      while (*v11 != 221 || v11[1] != 10 || *(_DWORD *)(v11 + 2) != 116528896 || *(_DWORD *)(v11 + 5) != 50397446)
      {
        uint64_t v15 = v11[1] + 2LL;
        v13 += v15;
        v11 += v15;
      }

      return 1LL;
    }

    return 0LL;
  }

  return result;
}

CFDataRef sub_100097934(uint64_t a1)
{
  if (!a1)
  {
    uint64_t v17 = objc_autoreleasePoolPush();
    if (qword_100219F60) {
      [qword_100219F60 WFLog:@"%s: null network." message:@"WiFiNetworkFoundNanIe"];
    }
    goto LABEL_29;
  }

  unsigned int v2 = *(const void **)(a1 + 16);
  if (!v2)
  {
    uint64_t v17 = objc_autoreleasePoolPush();
    if (qword_100219F60) {
      [qword_100219F60 WFLog:@"%s: null network record." message:4];
    }
LABEL_29:
    uint64_t v18 = v17;
LABEL_33:
    objc_autoreleasePoolPop(v18);
    return 0LL;
  }

  CFTypeID v3 = CFGetTypeID(v2);
  if (v3 != CFDictionaryGetTypeID())
  {
    uint64_t v19 = objc_autoreleasePoolPush();
    if (qword_100219F60) {
      [qword_100219F60 WFLog:@"%s: bad record type %ld" message:4 "%s: bad record type %ld" "WiFiNetworkFoundNanIe" CFGetTypeID(*(CFTypeRef *)(a1 + 16))]
    }
    uint64_t v18 = v19;
    goto LABEL_33;
  }

  uint64_t result = (const __CFData *)CFDictionaryGetValue(*(CFDictionaryRef *)(a1 + 16), @"IE");
  if (!result) {
    return result;
  }
  CFNumberRef v5 = result;
  uint64_t result = (const __CFData *)CFDataGetBytePtr(result);
  if (!result) {
    return result;
  }
  CFTypeID v6 = (unsigned __int8 *)result;
  CFIndex Length = CFDataGetLength(v5);
  if (Length << 32 < 1) {
    return 0LL;
  }
  uint64_t v8 = 0LL;
  unint64_t v9 = (unint64_t)&v6[(int)Length];
  while (1)
  {
    CFTypeID v10 = v6 + 6;
    if (*v6 == 221
      && (unint64_t)v10 <= v9
      && *(_DWORD *)(v6 + 2) == 116528896
      && (unint64_t)(v6 + 9) <= v9)
    {
      break;
    }

uint64_t sub_100097B1C(uint64_t a1)
{
  if (a1)
  {
    uint64_t result = sub_100097700(a1);
    if ((_DWORD)result)
    {
      uint64_t result = (uint64_t)sub_100097934(a1);
      if ((_DWORD)result) {
        return sub_1000951FC(a1, @"WiFiNetworkNANServiceID") != 0LL;
      }
    }
  }

  else
  {
    CFTypeID v3 = objc_autoreleasePoolPush();
    if (qword_100219F60) {
      objc_msgSend((id)qword_100219F60, "WFLog:message:", 4, "%s: null network.", "WiFiNetworkIsNanPH");
    }
    objc_autoreleasePoolPop(v3);
    return 0LL;
  }

  return result;
}

CFDataRef sub_100097BB8(uint64_t a1, unsigned __int8 *a2)
{
  uint64_t result = (const __CFData *)CFDictionaryGetValue(*(CFDictionaryRef *)(a1 + 16), @"IE");
  if (result)
  {
    unsigned int v4 = result;
    uint64_t result = (const __CFData *)CFDataGetBytePtr(result);
    if (result)
    {
      CFNumberRef v5 = (unsigned __int8 *)result;
      CFIndex Length = CFDataGetLength(v4);
      if (Length << 32 < 1)
      {
        return 0LL;
      }

      else
      {
        uint64_t v7 = 0LL;
        while (*v5 != 221 || v5[1] != 13 || *(_DWORD *)(v5 + 2) != 116528896 || *(_DWORD *)(v5 + 5) != 100729350)
        {
          uint64_t v9 = v5[1] + 2LL;
          v7 += v9;
          v5 += v9;
        }

        int v10 = *(_DWORD *)(v5 + 9);
        *((_WORD *)a2 + 2) = *(_WORD *)(v5 + 13);
        *(_DWORD *)a2 = v10;
        CFDictionaryRef v11 = objc_autoreleasePoolPush();
        if (qword_100219F60) {
          objc_msgSend( (id)qword_100219F60,  "WFLog:message:",  3,  "%s: BT MAC found in Apple IE %02X:%02X:%02X:%02X:%02X:%02X",  "__WiFiNetworkGetBtMacFromIe",  *a2,  a2[1],  a2[2],  a2[3],  a2[4],  a2[5]);
        }
        objc_autoreleasePoolPop(v11);
        return (const __CFData *)1;
      }
    }
  }

  return result;
}

const UInt8 *sub_100097D04(uint64_t a1)
{
  unsigned int v2 = malloc(0x11uLL);
  int Value = (const __CFData *)CFDictionaryGetValue(*(CFDictionaryRef *)(a1 + 16), @"IE");
  if (!Value) {
    goto LABEL_23;
  }
  unsigned int v4 = Value;
  BytePtr = CFDataGetBytePtr(Value);
  if (!BytePtr) {
    goto LABEL_24;
  }
  CFIndex Length = CFDataGetLength(v4);
  if (Length << 32 < 1)
  {
LABEL_23:
    BytePtr = 0LL;
    goto LABEL_24;
  }

  uint64_t v7 = 0LL;
  unint64_t v8 = (unint64_t)&BytePtr[(int)Length];
  while (1)
  {
    uint64_t v9 = (unsigned __int16 *)(BytePtr + 6);
    if (*BytePtr == 221
      && (unint64_t)v9 <= v8
      && *(_DWORD *)(BytePtr + 2) == 116528896
      && (unint64_t)(BytePtr + 9) <= v8)
    {
      break;
    }

const UInt8 *sub_100097E6C(uint64_t a1, uint64_t a2, _DWORD *a3)
{
  int Value = (const __CFData *)CFDictionaryGetValue(*(CFDictionaryRef *)(a1 + 16), @"IE");
  if (*a3 < 3u || Value == 0LL) {
    return 0LL;
  }
  uint64_t v7 = Value;
  uint64_t result = CFDataGetBytePtr(Value);
  if (!result) {
    return result;
  }
  uint64_t v9 = result;
  CFIndex Length = CFDataGetLength(v7);
  if (Length << 32 < 1) {
    return 0LL;
  }
  uint64_t v11 = 0LL;
  while (1)
  {
    uint64_t v12 = v9[1];
    uint64_t v14 = v12 + 2;
    v11 += v14;
    v9 += v14;
  }

  __int16 v15 = *((_WORD *)v9 + 1);
  *(_BYTE *)(a2 + 2) = v9[4];
  *(_WORD *)a2 = v15;
  *a3 = 3;
  return (const UInt8 *)1;
}

BOOL sub_100097F2C(BOOL result)
{
  if (result)
  {
    uint64_t v1 = result;
    unsigned int v2 = *(const __CFDictionary **)(result + 16);
    return sub_100098004(v2)
  }

  return result;
}

CFDictionaryRef sub_100097F80(const __CFDictionary *a1)
{
  uint64_t result = (const __CFDictionary *)CFDictionaryGetValue(a1, @"RSN_IE");
  if (result)
  {
    unsigned int v2 = result;
    int v3 = sub_1000A4E24(result, 8);
    int v4 = sub_1000A4E24(v2, 9) | v3;
    int v5 = sub_1000A4E24(v2, 24);
    return v4 | v5 | sub_1000A4E24(v2, 25);
  }

  return result;
}

uint64_t sub_100097FF4(uint64_t result)
{
  if (result) {
    return sub_100098004(*(const __CFDictionary **)(result + 16));
  }
  return result;
}

uint64_t sub_100098004(const __CFDictionary *a1)
{
  int Value = (const __CFDictionary *)CFDictionaryGetValue(a1, @"WPA_IE");
  if (Value && (v2 = Value, CFTypeID TypeID = CFDictionaryGetTypeID(), sub_10003AE00(TypeID, v2))) {
    return sub_1000A4E24(v2, 2);
  }
  else {
    return 0LL;
  }
}

uint64_t sub_100098058(uint64_t result)
{
  if (result) {
    return sub_100098068(*(const __CFDictionary **)(result + 16));
  }
  return result;
}

uint64_t sub_100098068(const __CFDictionary *a1)
{
  if (sub_1000980BC(a1))
  {
    LOBYTE(result) = 1;
  }

  else
  {
    int Value = (const __CFNumber *)CFDictionaryGetValue(a1, @"ALLOW_WPA2_PSK");
    LOBYTE(result) = sub_10003AC9C(Value);
  }

  return result;
}

CFDictionaryRef sub_1000980AC(const __CFDictionary *result)
{
  if (result) {
    return sub_1000980BC(*((const __CFDictionary **)result + 2));
  }
  return result;
}

CFDictionaryRef sub_1000980BC(const __CFDictionary *result)
{
  if (result)
  {
    uint64_t result = (const __CFDictionary *)CFDictionaryGetValue(result, @"RSN_IE");
    if (result)
    {
      uint64_t v1 = result;
      else {
        return sub_1000A4E24(v1, 6 != 0);
      }
    }
  }

  return result;
}

void *sub_100098124(void *result)
{
  if (result)
  {
    uint64_t v1 = (const __CFDictionary *)*((void *)result + 2);
    value = 0LL;
    int valuePtr = 0;
    unsigned int v2 = (const __CFDictionary *)CFDictionaryGetValue(v1, @"EXT_CAPS");
    uint64_t result = 0LL;
    if (v2)
    {
      uint64_t result = (void *)CFDictionaryGetValueIfPresent(v2, @"BEACON_PROTECTION", (const void **)&value);
      if ((_DWORD)result)
      {
        uint64_t result = value;
        if (value)
        {
          CFNumberGetValue((CFNumberRef)value, kCFNumberIntType, &valuePtr);
          return (void *)(valuePtr == 1);
        }
      }
    }
  }

  return result;
}

CFDictionaryRef *sub_10009819C(CFDictionaryRef *result)
{
  if (result)
  {
    uint64_t result = (CFDictionaryRef *)CFDictionaryGetValue(result[2], @"RSN_IE");
    if (result)
    {
      uint64_t result = (CFDictionaryRef *)CFDictionaryGetValue((CFDictionaryRef)result, @"IE_KEY_RSN_CAPS");
      if (result)
      {
        uint64_t result = (CFDictionaryRef *)CFDictionaryGetValue((CFDictionaryRef)result, @"OCV");
        if (result) {
          return (CFDictionaryRef *)(CFBooleanGetValue((CFBooleanRef)result) == 1);
        }
      }
    }
  }

  return result;
}

CFDictionaryRef sub_1000981F0(const __CFDictionary *result)
{
  if (result) {
    return sub_100098200(*((const __CFDictionary **)result + 2));
  }
  return result;
}

CFDictionaryRef sub_100098200(const __CFDictionary *a1)
{
  uint64_t result = sub_100097F80(a1);
  if ((_DWORD)result)
  {
    uint64_t result = (const __CFDictionary *)CFDictionaryGetValue(a1, @"RSN_XE");
    if (result)
    {
      uint64_t result = (const __CFDictionary *)CFDictionaryGetValue(result, @"IE_KEY_RSNXE_CAPS");
      if (result)
      {
        int Value = (const __CFBoolean *)CFDictionaryGetValue(result, @"RSNXE_SAE_PK");
        return CFBooleanGetValue(Value == 1);
      }
    }
  }

  return result;
}

CFDictionaryRef sub_100098260(const __CFDictionary *result)
{
  if (result)
  {
    uint64_t v1 = (const __CFDictionary *)*((void *)result + 2);
    value = 0LL;
    uint64_t result = sub_100097F80(v1);
    if ((_DWORD)result)
    {
      uint64_t result = sub_100098200(v1);
      if ((_DWORD)result)
      {
        uint64_t result = (const __CFDictionary *)CFDictionaryGetValue(v1, @"EXT_CAPS");
        if (result)
        {
          int valuePtr = -1431655766;
          uint64_t result = (const __CFDictionary *)CFDictionaryGetValueIfPresent( result,  @"SAE_PK_PASSWD_USED",  (const void **)&value);
          if ((_DWORD)result) {
            return CFNumberGetValue((CFNumberRefvalue, kCFNumberSInt32Type, &valuePtr)
          }
                                         && valuePtr == 1);
        }
      }
    }
  }

  return result;
}

BOOL sub_1000982F4(BOOL result)
{
  if (result) {
    return (~sub_10009831C(*(const __CFDictionary **)(result + 16)) & 7) == 0;
  }
  return result;
}

CFNumberRef sub_10009831C(const __CFDictionary *a1)
{
  unsigned int valuePtr = 0;
  uint64_t result = (const __CFNumber *)CFDictionaryGetValue(a1, @"WAPI");
  if (result)
  {
    CFNumberGetValue(result, kCFNumberIntType, &valuePtr);
    return (const __CFNumber *)valuePtr;
  }

  return result;
}

BOOL sub_100098358(BOOL result)
{
  if (result) {
    return (~sub_10009831C(*(const __CFDictionary **)(result + 16)) & 0xB) == 0;
  }
  return result;
}

BOOL sub_100098380(BOOL result)
{
  if (result)
  {
    uint64_t v1 = result;
    return (~sub_10009831C(*(const __CFDictionary **)(result + 16)) & 0xB) == 0
        || (~sub_10009831C(*(const __CFDictionary **)(v1 + 16)) & 7) == 0;
  }

  return result;
}

uint64_t sub_1000983D0(uint64_t result)
{
  if (result)
  {
    uint64_t v1 = *(const __CFDictionary **)(result + 16);
    int Value = (const __CFNumber *)CFDictionaryGetValue(v1, @"SCAN_RESULT_OWE_MULTI_SSID");
    LOBYTE(result) = sub_10003AC9C(Value);
    if (!(_BYTE)result)
    {
      int v3 = (const __CFNumber *)CFDictionaryGetValue(v1, @"ALLOW_OWE_TSN");
      LOBYTE(result) = sub_10003AC9C(v3);
    }
  }

  return result;
}

CFDictionaryRef sub_100098424(const __CFDictionary *result)
{
  if (result) {
    return sub_100098434(*((const __CFDictionary **)result + 2));
  }
  return result;
}

CFDictionaryRef sub_100098434(const __CFDictionary *a1)
{
  uint64_t result = (const __CFDictionary *)CFDictionaryGetValue(a1, @"RSN_IE");
  if (result)
  {
    uint64_t result = (const __CFDictionary *)sub_1000A4E24(result, 18);
    if ((_DWORD)result)
    {
      int Value = (const __CFNumber *)CFDictionaryGetValue(a1, @"SCAN_RESULT_OWE_MULTI_SSID");
      if (sub_10003AC9C(Value))
      {
        return 0LL;
      }

      else
      {
        int v4 = (const __CFNumber *)CFDictionaryGetValue(a1, @"ALLOW_OWE_TSN");
        return sub_10003AC9C(v4 == 0LL);
      }
    }
  }

  return result;
}

BOOL sub_1000984A8(const __CFDictionary *a1)
{
  return sub_100096C08(a1) || CFDictionaryGetValue(a1, @"EnterpriseProfile") != 0LL;
}

BOOL sub_1000984F0(BOOL result)
{
  if (result)
  {
    uint64_t v1 = result;
    uint64_t result = sub_100095B4C(result);
    if (result) {
      return sub_100098574(v1, 17)
    }
          || sub_100098574(v1, 21)
          || sub_100098574(v1, 25)
  }

  return result;
}

CFArrayRef sub_100098574(uint64_t a1, int a2)
{
  int valuePtr = a2;
  uint64_t result = (const __CFArray *)sub_100095B4C(a1);
  if ((_DWORD)result)
  {
    uint64_t result = (const __CFArray *)sub_1000951FC(a1, @"AcceptEAPTypes");
    if (result)
    {
      int v4 = result;
      uint64_t result = CFNumberCreate(kCFAllocatorDefault, kCFNumberIntType, &valuePtr);
      if (result)
      {
        int v5 = result;
        v8.length = CFArrayGetCount(v4);
        v8.location = 0LL;
        FirstIndexOfint Value = CFArrayGetFirstIndexOfValue(v4, v8, v5);
        CFRelease(v5);
        return (const __CFArray *)(FirstIndexOfValue != -1);
      }
    }
  }

  return result;
}

BOOL sub_10009860C(uint64_t a1)
{
  return a1 && CFDictionaryContainsKey(*(CFDictionaryRef *)(a1 + 16), @"PayloadUUID");
}

BOOL sub_100098644(uint64_t a1)
{
  int valuePtr = 0;
  if (!a1) {
    return 1LL;
  }
  int Value = (const __CFNumber *)CFDictionaryGetValue(*(CFDictionaryRef *)(a1 + 16), @"IsWiFiNetworkShareble");
  if (!Value) {
    return 1LL;
  }
  CFNumberGetValue(Value, kCFNumberIntType, &valuePtr);
  return valuePtr != 0;
}

BOOL sub_10009869C(uint64_t a1)
{
  return a1 && CFDictionaryContainsKey(*(CFDictionaryRef *)(a1 + 16), @"BundleIdentifier");
}

void sub_1000986D4(uint64_t a1)
{
  if (sub_10009870C(a1) != 0.0) {
    CFAbsoluteTimeGetCurrent();
  }
}

double sub_10009870C(uint64_t a1)
{
  double valuePtr = 0.0;
  if (!a1)
  {
    int v3 = objc_autoreleasePoolPush();
    if (qword_100219F60) {
      [qword_100219F60 WFLog:@"%s: null network" message:3];
    }
    objc_autoreleasePoolPop(v3);
    return 0.0;
  }

  uint64_t v1 = (const __CFNumber *)sub_1000951FC(a1, @"WiFiNetworkExpirationDate");
  if (!v1) {
    return 0.0;
  }
  CFNumberGetValue(v1, kCFNumberDoubleType, &valuePtr);
  return valuePtr;
}

void sub_10009879C(uint64_t a1, CFDateRef theDate)
{
  if (a1)
  {
    if (theDate)
    {
      double AbsoluteTime = CFDateGetAbsoluteTime(theDate);
      sub_100097140(a1, @"WiFiNetworkExpirationDate", AbsoluteTime);
    }

    else
    {
      int v4 = objc_autoreleasePoolPush();
      if (qword_100219F60) {
        [qword_100219F60 WFLog:@"%s: null expire date, removing property" message:3];
      }
      objc_autoreleasePoolPop(v4);
      sub_10009582C(a1, @"WiFiNetworkExpirationDate", 0LL);
    }
  }

BOOL sub_100098850(uint64_t a1)
{
  if (a1) {
    return sub_1000951FC(a1, @"WiFiNetworkExpirationDate") != 0LL;
  }
  unsigned int v2 = objc_autoreleasePoolPush();
  if (qword_100219F60) {
    objc_msgSend((id)qword_100219F60, "WFLog:message:", 3, "%s: null network", "WiFiNetworkIsExpirable");
  }
  objc_autoreleasePoolPop(v2);
  return 0LL;
}

void sub_1000988D0(uint64_t a1, int a2)
{
  unsigned int v2 = (const void **)&kCFBooleanTrue;
  if (!a2) {
    unsigned int v2 = (const void **)&kCFBooleanFalse;
  }
  sub_10009582C(a1, @"WEP", *v2);
}

void sub_1000988F8(uint64_t a1, int a2)
{
  if (a2)
  {
    CFMutableArrayRef Mutable = CFArrayCreateMutable(kCFAllocatorDefault, 0LL, &kCFTypeArrayCallBacks);
    values = Mutable;
    if (Mutable)
    {
      int v4 = Mutable;
      uint64_t valuePtr = 18LL;
      CFNumberRef v5 = CFNumberCreate(kCFAllocatorDefault, kCFNumberCFIndexType, &valuePtr);
      if (v5)
      {
        CFNumberRef v6 = v5;
        CFArrayAppendValue(v4, v5);
        CFRelease(v6);
      }

      keys = @"IE_KEY_RSN_AUTHSELS";
      CFDictionaryRef v7 = CFDictionaryCreate( kCFAllocatorDefault,  (const void **)&keys,  (const void **)&values,  1LL,  &kCFTypeDictionaryKeyCallBacks,  &kCFTypeDictionaryValueCallBacks);
      if (v7)
      {
        CFDictionaryRef v8 = v7;
        sub_10009582C(a1, @"RSN_IE", v7);
        CFRelease(v8);
      }

      CFRelease(values);
    }
  }

  else
  {
    sub_10009582C(a1, @"RSN_IE", 0LL);
  }

void sub_100098A08(uint64_t a1, int a2)
{
  if (a2)
  {
    uint64_t valuePtr = 1LL;
    values = CFNumberCreate(kCFAllocatorDefault, kCFNumberCFIndexType, &valuePtr);
    if (values)
    {
      CFTypeRef cf = CFArrayCreate(kCFAllocatorDefault, (const void **)&values, 1LL, &kCFTypeArrayCallBacks);
      if (cf)
      {
        CFDictionaryRef v7 = @"IE_KEY_RSN_AUTHSELS";
        CFDictionaryRef v3 = CFDictionaryCreate( kCFAllocatorDefault,  (const void **)&v7,  &cf,  1LL,  &kCFTypeDictionaryKeyCallBacks,  &kCFTypeDictionaryValueCallBacks);
        if (v3)
        {
          CFDictionaryRef v4 = v3;
          sub_10009582C(a1, @"RSN_IE", v3);
          CFRelease(v4);
        }

        if (cf)
        {
          CFRelease(cf);
          CFTypeRef cf = 0LL;
        }
      }

      if (values)
      {
        CFRelease(values);
        values = 0LL;
      }
    }

    uint64_t valuePtr = 1LL;
    values = CFNumberCreate(kCFAllocatorDefault, kCFNumberCFIndexType, &valuePtr);
    if (values)
    {
      CFTypeRef cf = CFArrayCreate(kCFAllocatorDefault, (const void **)&values, 1LL, &kCFTypeArrayCallBacks);
      if (cf)
      {
        CFDictionaryRef v7 = @"IE_KEY_WPA_AUTHSELS";
        CFDictionaryRef v5 = CFDictionaryCreate( kCFAllocatorDefault,  (const void **)&v7,  &cf,  1LL,  &kCFTypeDictionaryKeyCallBacks,  &kCFTypeDictionaryValueCallBacks);
        if (v5)
        {
          CFDictionaryRef v6 = v5;
          sub_10009582C(a1, @"WPA_IE", v5);
          CFRelease(v6);
        }

        if (cf)
        {
          CFRelease(cf);
          CFTypeRef cf = 0LL;
        }
      }

      if (values) {
        CFRelease(values);
      }
    }
  }

  else
  {
    sub_10009582C(a1, @"RSN_IE", 0LL);
    sub_10009582C(a1, @"WPA_IE", 0LL);
    sub_10009582C(a1, @"EnterpriseProfile", 0LL);
  }

BOOL sub_100098BF8(uint64_t a1)
{
  if (!sub_100095B4C(a1))
  {
    if (!sub_100096E90(a1))
    {
      if (a1)
      {
        if (CFDictionaryGetValue(*(CFDictionaryRef *)(a1 + 16), @"WEP") != kCFBooleanTrue && !sub_100098380(a1)) {
          return sub_100097F80(*(const __CFDictionary **)(a1 + 16)) != 0;
        }
      }

      else
      {
        BOOL result = sub_100098380(0LL);
        if (!result) {
          return result;
        }
      }
    }

    return 1LL;
  }

  return !sub_100098CC0(a1)
}

CFArrayRef sub_100098CC0(uint64_t a1)
{
  if (!sub_100095B4C(a1)) {
    return 0LL;
  }
  unsigned int v2 = (const __CFArray *)sub_1000951FC(a1, @"AcceptEAPTypes");
  if (v2)
  {
    int valuePtr = 13;
    CFNumberRef v3 = CFNumberCreate(kCFAllocatorDefault, kCFNumberIntType, &valuePtr);
    if (v3)
    {
      CFNumberRef v4 = v3;
      v7.length = CFArrayGetCount(v2);
      v7.location = 0LL;
      unsigned int v2 = (const __CFArray *)(CFArrayGetFirstIndexOfValue(v2, v7, v4) != -1);
      CFRelease(v4);
      return v2;
    }

    return 0LL;
  }

  return v2;
}

BOOL sub_100098D64(uint64_t a1)
{
  int v11 = 18;
  int valuePtr = 13;
  BOOL result = sub_100095B4C(a1);
  if (result)
  {
    CFNumberRef v3 = (const __CFArray *)sub_1000951FC(a1, @"AcceptEAPTypes");
    if (v3 && (v4 = v3, (CFNumberRef v5 = CFNumberCreate(kCFAllocatorDefault, kCFNumberIntType, &valuePtr)) != 0LL))
    {
      CFNumberRef v6 = v5;
      v13.length = CFArrayGetCount(v4);
      v13.location = 0LL;
      FirstIndexOfint Value = CFArrayGetFirstIndexOfValue(v4, v13, v6);
      CFRelease(v6);
      CFNumberRef v8 = CFNumberCreate(kCFAllocatorDefault, kCFNumberIntType, &v11);
      if (v8)
      {
        CFNumberRef v9 = v8;
        v14.length = CFArrayGetCount(v4);
        v14.location = 0LL;
        CFIndex v10 = CFArrayGetFirstIndexOfValue(v4, v14, v9);
        CFRelease(v9);
      }

      else
      {
        CFIndex v10 = -1LL;
      }

      if (FirstIndexOfValue != -1) {
        return 0LL;
      }
    }

    else
    {
      CFIndex v10 = -1LL;
    }

    return v10 == -1;
  }

  return result;
}

const void *sub_100098E6C(const void *result)
{
  if (result)
  {
    BOOL result = sub_1000951FC((uint64_t)result, @"OneTimeUserPassword");
    if (result) {
      return (const void *)(CFEqual(result, kCFBooleanTrue) != 0);
    }
  }

  return result;
}

uint64_t sub_100098EA8(uint64_t a1)
{
  return sub_100098EB0(*(const __CFDictionary **)(a1 + 16));
}

uint64_t sub_100098EB0(const __CFDictionary *a1)
{
  else {
    int v2 = 2 * (sub_100098068(a1) != 0);
  }
  if (sub_1000984A8(a1)) {
    v2 |= 8u;
  }
  unsigned int v3 = v2 | (CFDictionaryGetValue(a1, @"WEP") == kCFBooleanTrue);
  else {
    return v3;
  }
}

uint64_t sub_100098F54(unsigned int a1, unsigned int a2)
{
  if ((a1 & a2 & 4) == 0 || ((a2 ^ a1) & 8) != 0)
  {
    if (a1 >= a2) {
      unsigned int v8 = 0;
    }
    else {
      unsigned int v8 = -1;
    }
    if (a1 <= a2) {
      return v8;
    }
    else {
      return 1LL;
    }
  }

  else
  {
    unsigned int v2 = a1 & 0xFFFFFFFB;
    unsigned int v3 = a2 & 0xFFFFFFFB;
    if ((a1 & 0xFFFFFFFB) > (a2 & 0xFFFFFFFB)) {
      int v4 = 1;
    }
    else {
      int v4 = -1;
    }
    if (v3) {
      int v5 = v4;
    }
    else {
      int v5 = -1;
    }
    if (v2) {
      unsigned int v6 = v5;
    }
    else {
      unsigned int v6 = 1;
    }
    if (v2 == v3) {
      return 0LL;
    }
    else {
      return v6;
    }
  }

uint64_t sub_100098FAC(const __CFDictionary **cf, const __CFDictionary **a2)
{
  uint64_t result = 0LL;
  if (cf && a2)
  {
    CFTypeID v5 = CFGetTypeID(cf);
    uint64_t v6 = qword_100219950;
    if (!qword_100219950)
    {
      pthread_once(&stru_100219020, (void (*)(void))sub_1000949D8);
      uint64_t v6 = qword_100219950;
    }

    if (v5 != v6) {
      return 0LL;
    }
    CFTypeID v7 = CFGetTypeID(a2);
    uint64_t v8 = qword_100219950;
    if (!qword_100219950)
    {
      pthread_once(&stru_100219020, (void (*)(void))sub_1000949D8);
      uint64_t v8 = qword_100219950;
    }

    if (v7 != v8) {
      return 0LL;
    }
    int v9 = sub_100098EB0(cf[2]);
    int v10 = sub_100098EB0(a2[2]);
    int v33 = sub_100097F80(cf[2])
    int v30 = v10;
    int v13 = sub_100097F80(a2[2])
    unsigned int v31 = sub_100098434(cf[2]);
    unsigned int v32 = sub_100098434(a2[2]);
    CFBooleanRef Value = (CFBooleanRef)CFDictionaryGetValue(cf[2], @"ALLOW_WPA2_PSK");
    CFBooleanRef v15 = (CFBooleanRef)CFDictionaryGetValue(a2[2], @"ALLOW_WPA2_PSK");
    CFBooleanRef v16 = (CFBooleanRef)CFDictionaryGetValue(cf[2], @"ALLOW_OWE_TSN");
    unint64_t v17 = (unint64_t)CFDictionaryGetValue(a2[2], @"ALLOW_OWE_TSN");
    int v18 = ((unint64_t)Value | (unint64_t)v16) == 0;
    int v19 = ((unint64_t)v15 | v17) == 0;
    if (v18 != v19)
    {
      CFDictionaryRef v20 = (const __CFBoolean *)v17;
      int v29 = v9;
      if (v33)
      {
        BOOL v21 = sub_1000992D0((uint64_t)cf) != 3;
        if ((v13 & 1) == 0)
        {
LABEL_20:
          CFBooleanRef v22 = kCFBooleanTrue;
LABEL_31:
          if (v15 == v22 && v21) {
            return 0LL;
          }
          int v9 = v29;
          if ((v19 & v13) == 1)
          {
            int v25 = sub_1000992D0((uint64_t)a2);
            int v26 = v30;
            if (v25 == 3) {
              int v26 = v30 | 2;
            }
            int v30 = v26;
          }

          BOOL v27 = v31 && sub_1000992D0((uint64_t)cf) != 3;
          if (v32)
          {
            int v28 = sub_1000992D0((uint64_t)a2);
            if (v16 == v22 && v28 != 3) {
              return 0LL;
            }
          }

          if (v20 == v22 && v27) {
            return 0LL;
          }
LABEL_23:
          if (!v9 || !v30 || (v30 & v9) != 0) {
            return (v9 == 0) ^ (v30 != 0);
          }
          return 0LL;
        }
      }

      else
      {
        BOOL v21 = 0;
        if ((v13 & 1) == 0) {
          goto LABEL_20;
        }
      }

      int v23 = sub_1000992D0((uint64_t)a2);
      BOOL v24 = Value == kCFBooleanTrue;
      CFBooleanRef v22 = kCFBooleanTrue;
      if (v24 && v23 != 3) {
        return 0LL;
      }
      goto LABEL_31;
    }

    uint64_t result = 0LL;
    if (v33 == v13 && v31 == v32) {
      goto LABEL_23;
    }
  }

  return result;
}

uint64_t sub_1000992D0(uint64_t result)
{
  int v9 = 0;
  if (result)
  {
    uint64_t v1 = (const void *)result;
    CFTypeID v2 = CFGetTypeID((CFTypeRef)result);
    uint64_t v3 = qword_100219950;
    if (!qword_100219950)
    {
      pthread_once(&stru_100219020, (void (*)(void))sub_1000949D8);
      uint64_t v3 = qword_100219950;
    }

    if (v2 == v3)
    {
      int v4 = sub_1000951FC((uint64_t)v1, @"CHANNEL");
      CFTypeID v5 = (const __CFNumber *)sub_1000951FC((uint64_t)v1, @"CHANNEL_FLAGS");
      if (v5)
      {
        int valuePtr = 0;
        CFNumberGetValue(v5, kCFNumberIntType, &valuePtr);
        if ((valuePtr & 8) != 0) {
          return 1LL;
        }
        if ((valuePtr & 0x10) != 0) {
          return 2LL;
        }
        if ((valuePtr & 0x2000) != 0) {
          return 3LL;
        }
      }

      uint64_t v1 = v4;
      if (!v4) {
        return 0LL;
      }
    }

    else
    {
      CFTypeID v6 = CFGetTypeID(v1);
      if (v6 != CFNumberGetTypeID()) {
        return 0LL;
      }
    }

    CFNumberGetValue((CFNumberRef)v1, kCFNumberIntType, &v9);
    if (v9)
    {
      if (v9 < 15) {
        return 1LL;
      }
      uint64_t v7 = 0LL;
      while (v9 != dword_100218F98[v7])
      {
        if (++v7 == 33) {
          return 0LL;
        }
      }

      return 2LL;
    }

    return 0LL;
  }

  return result;
}

uint64_t sub_100099404(uint64_t a1, uint64_t a2)
{
  uint64_t result = 0LL;
  if (a1 && a2)
  {
    uint64_t result = sub_100099458(*(const void **)(a1 + 16), *(const __CFDictionary **)(a2 + 16));
    if ((_DWORD)result) {
      return sub_1000994B0(*(CFTypeRef *)(a1 + 16), *(const __CFDictionary **)(a1 + 16), @"AP_MODE") != 0;
    }
  }

  return result;
}

uint64_t sub_100099458(const void *a1, const __CFDictionary *a2)
{
  uint64_t v3 = sub_1000994B0(a1, a2, @"SSID_STR");
  uint64_t v4 = v3;
  if (a1)
  {
    if ((_DWORD)v3)
    {
      CFBooleanRef Value = (const __CFString *)CFDictionaryGetValue((CFDictionaryRef)a1, @"SSID_STR");
      if (Value)
      {
        if (!CFStringGetLength(Value)) {
          return 0LL;
        }
      }
    }
  }

  return v4;
}

uint64_t sub_1000994B0(CFTypeRef cf, const __CFDictionary *a2, const void *a3)
{
  uint64_t result = 0LL;
  if (cf && a2)
  {
    CFTypeID v7 = CFGetTypeID(cf);
    if (v7 == CFGetTypeID(a2))
    {
      CFTypeID v8 = CFGetTypeID(cf);
      if (v8 == CFDictionaryGetTypeID())
      {
        int v9 = (const __CFDictionary *)cf;
        if (!a3)
        {
          uint64_t v12 = a2;
          return CFEqual(v9, v12);
        }

        CFBooleanRef Value = (const __CFDictionary *)CFDictionaryGetValue((CFDictionaryRef)cf, a3);
        int v11 = (const __CFDictionary *)CFDictionaryGetValue(a2, a3);
        if (Value == v11) {
          return 1LL;
        }
        uint64_t v12 = v11;
        if ((Value != 0LL) != (v11 == 0LL))
        {
          int v9 = Value;
          return CFEqual(v9, v12);
        }
      }
    }

    return 0LL;
  }

  return result;
}

uint64_t sub_100099588(uint64_t a1, uint64_t a2)
{
  if (a1 && a2) {
    return sub_10009959C(a1, a2);
  }
  else {
    return 0LL;
  }
}

uint64_t sub_10009959C(uint64_t a1, uint64_t a2)
{
  if (a1 && a2 && sub_100095318(a1) && sub_100095318(a2)) {
    return sub_1000994B0(*(CFTypeRef *)(a1 + 16), *(const __CFDictionary **)(a2 + 16), @"DomainName");
  }
  else {
    return 0LL;
  }
}

BOOL sub_1000995FC(uint64_t a1, uint64_t a2)
{
  BOOL result = 0LL;
  if (a1)
  {
    if (a2) {
      return sub_1000994B0( *(CFTypeRef *)(a1 + 16),  *(const __CFDictionary **)(a2 + 16),  @"SSID_STR") != 0;
    }
  }

  return result;
}

uint64_t sub_100099638(uint64_t a1, uint64_t a2)
{
  if (a1 | a2) {
    uint64_t v3 = -1LL;
  }
  else {
    uint64_t v3 = 0LL;
  }
  if (a2) {
    uint64_t result = 1LL;
  }
  else {
    uint64_t result = v3;
  }
  if (!a1 || !a2) {
    return result;
  }
  BOOL v6 = sub_100099810(a1);
  BOOL v7 = sub_100099810(a2);
  BOOL v8 = sub_100095318(a1);
  BOOL v9 = sub_100095318(a2);
  if (v6 || v8 || v7 || v9)
  {
    BOOL v16 = !v6 && !v8;
    if (!v16 && !v7 && !v9) {
      return 1LL;
    }
    if (v16 && (v7 || v9)) {
      return -1LL;
    }
    if (v6 && v9) {
      return 1LL;
    }
    if (v8 && v7) {
      return -1LL;
    }
    if (v8 && v9)
    {
      unint64_t v17 = (const __CFBoolean *)sub_1000951FC(a1, @"HS20HomeOperatorNetwork");
      int v18 = (const __CFBoolean *)sub_1000951FC(a2, @"HS20HomeOperatorNetwork");
      if (v17 == kCFBooleanTrue && v18 != kCFBooleanTrue) {
        return -1LL;
      }
      if (v17 != kCFBooleanTrue && v18 == kCFBooleanTrue) {
        return 1LL;
      }
    }
  }

  unsigned int v10 = sub_100098EB0(*(const __CFDictionary **)(a1 + 16));
  unsigned int v11 = sub_100098EB0(*(const __CFDictionary **)(a2 + 16));
  int v12 = sub_100098F54(v10, v11);
  if (v12 == 1) {
    return -1LL;
  }
  if (v12 == -1) {
    return 1LL;
  }
  uint64_t valuePtr = 0LL;
  int v13 = (const __CFNumber *)sub_1000951FC(a1, @"Strength");
  if (v13) {
    CFNumberGetValue(v13, kCFNumberFloatType, (char *)&valuePtr + 4);
  }
  CFRange v14 = (const __CFNumber *)sub_1000951FC(a2, @"Strength");
  if (v14)
  {
    CFNumberGetValue(v14, kCFNumberFloatType, &valuePtr);
    float v15 = *(float *)&valuePtr;
  }

  else
  {
    float v15 = 0.0;
  }

  else {
    return -1LL;
  }
}

BOOL sub_100099810(uint64_t a1)
{
  if (sub_1000951FC(a1, @"DomainName")) {
    return 0LL;
  }
  if (sub_1000951FC(a1, @"IsHotspot") == kCFBooleanTrue
    || &_CNForgetSSID
    && CFDictionaryGetValue(*(CFDictionaryRef *)(a1 + 16), kCNSCaptiveNetworkProperty) == kCFBooleanTrue
    || sub_100098574(a1, 18)
    || sub_100098574(a1, 23))
  {
    return 1LL;
  }

  return sub_10009CEA8(a1) != 0;
}

BOOL sub_1000998D0(uint64_t a1)
{
  return sub_1000951FC(a1, @"HS20HomeOperatorNetwork") == kCFBooleanTrue;
}

__CFString *sub_100099900(CFDictionaryRef *a1)
{
  CFTypeID v2 = sub_100095408(a1);
  if (v2 && !sub_1000951FC((uint64_t)a1, @"RSN_IE"))
  {
    uint64_t v3 = (const __CFData *)sub_100096804(a1);
    uint64_t v4 = sub_1000ADBF8(v2, v3);
    CFRelease(v2);
    return v4;
  }

  return (__CFString *)v2;
}

uint64_t sub_10009997C(uint64_t a1)
{
  unsigned int valuePtr = 3;
  CFTypeID v2 = (const __CFNumber *)sub_1000951FC(a1, @"ShareMode");
  if (v2) {
    CFNumberGetValue(v2, kCFNumberIntType, &valuePtr);
  }
  BOOL v3 = a1 && CFDictionaryContainsKey(*(CFDictionaryRef *)(a1 + 16), @"PayloadUUID");
  BOOL v4 = sub_100095B4C(a1);
  int v5 = sub_100096E90(a1);
  if (a1)
  {
    BOOL v6 = CFDictionaryGetValue(*(CFDictionaryRef *)(a1 + 16), @"WEP") == kCFBooleanTrue;
    BOOL v7 = sub_100097F80(*(const __CFDictionary **)(a1 + 16)) == 0;
  }

  else
  {
    BOOL v6 = 0;
    BOOL v7 = 1;
  }

  if (v5) {
    BOOL v7 = 0;
  }
  if (v4) {
    BOOL v7 = 1;
  }
  if (v3 || v6 || v7) {
    return 1LL;
  }
  else {
    return valuePtr;
  }
}

__CFString *sub_100099A80(const void *a1, const __CFString *a2)
{
  BOOL v3 = (const __CFData *)sub_100096804(a1);
  return sub_1000ADBF8(a2, v3);
}

uint64_t sub_100099AA8(CFDictionaryRef *a1, BOOL *a2, double a3)
{
  if (os_log_type_enabled((os_log_t)&_os_log_default, OS_LOG_TYPE_DEFAULT))
  {
    int v9 = 136315394;
    unsigned int v10 = "WiFiNetworkCopyPasswordWithTimeout";
    __int16 v11 = 2112;
    int v12 = sub_100095CB0(a1);
    _os_log_impl( (void *)&_mh_execute_header,  (os_log_t)&_os_log_default,  OS_LOG_TYPE_DEFAULT,  "%s: Copy password for Network/account %@",  (uint8_t *)&v9,  0x16u);
  }

  if (!a1
    || !CFDictionaryContainsKey(a1[2], @"PayloadUUID")
    || (BOOL v6 = sub_100095CB0(a1), (result = sub_1000AE154(v6, a2, a3)) == 0))
  {
    BOOL v8 = sub_100095CB0(a1);
    return sub_1000AC330(v8, a2, a3);
  }

  return result;
}

uint64_t sub_100099BB8(const void *a1, const __CFString *a2, BOOL *a3, double a4)
{
  BOOL v7 = sub_100095CB0(a1);
  return sub_1000ACF10(v7, a2, a3, a4);
}

CFStringRef sub_100099BF4(const void *a1)
{
  uint64_t v1 = sub_100095CB0(a1);
  return sub_1000ACD7C(v1);
}

CFStringRef sub_100099C08(const void *a1)
{
  uint64_t v1 = sub_100095CB0(a1);
  return sub_1000ADF40(v1);
}

uint64_t sub_100099C1C(const void *a1, BOOL *a2, double a3)
{
  int v5 = sub_100095CB0(a1);
  return sub_1000AE154(v5, a2, a3);
}

BOOL sub_100099C50(const void *a1, const __CFString *a2)
{
  BOOL v3 = (__CFString *)sub_100095CB0(a1);
  if (os_log_type_enabled((os_log_t)&_os_log_default, OS_LOG_TYPE_DEFAULT))
  {
    int v5 = 136315394;
    BOOL v6 = "WiFiNetworkSetPassword";
    __int16 v7 = 2112;
    BOOL v8 = v3;
    _os_log_impl( (void *)&_mh_execute_header,  (os_log_t)&_os_log_default,  OS_LOG_TYPE_DEFAULT,  "%s: Set password for Network/account %@",  (uint8_t *)&v5,  0x16u);
  }

  return sub_1000AD2DC(v3, a2);
}

BOOL sub_100099D14(const void *a1, const __CFString *a2)
{
  BOOL v3 = (__CFString *)sub_100095CB0(a1);
  return sub_1000AD678(v3, a2);
}

uint64_t sub_100099D38(const void *a1)
{
  if (os_log_type_enabled((os_log_t)&_os_log_default, OS_LOG_TYPE_DEFAULT))
  {
    int v4 = 136315394;
    int v5 = "WiFiNetworkRemovePassword";
    __int16 v6 = 2112;
    __int16 v7 = sub_100095CB0(a1);
    _os_log_impl( (void *)&_mh_execute_header,  (os_log_t)&_os_log_default,  OS_LOG_TYPE_DEFAULT,  "%s: Remove password for Network/account %@",  (uint8_t *)&v4,  0x16u);
  }

  CFTypeID v2 = sub_100095CB0(a1);
  return sub_1000AD680(v2);
}

uint64_t sub_100099DFC(const void *a1)
{
  uint64_t v1 = sub_100095CB0(a1);
  return sub_1000AD810(v1);
}

CFStringRef sub_100099E10(CFDictionaryRef *a1)
{
  CFStringRef result = sub_100095408(a1);
  if (result)
  {
    CFRelease(result);
    return (CFStringRef)1;
  }

  return result;
}

uint64_t sub_100099E30(void *a1)
{
  uint64_t result = (uint64_t)sub_100095370((uint64_t)a1);
  if (result)
  {
LABEL_3:
    CFRelease((CFTypeRef)result);
    return 1LL;
  }

  BOOL v3 = sub_100095BC8(a1);
  int v4 = sub_1000951FC((uint64_t)a1, @"HS20AccountName");
  if (!v3 || v4 && CFEqual(v3, v4)) {
    return 0LL;
  }
  uint64_t result = (uint64_t)sub_100095408((CFDictionaryRef *)a1);
  if (result) {
    goto LABEL_3;
  }
  return result;
}

uint64_t sub_100099EB4()
{
  return 1LL;
}

uint64_t sub_100099EBC(const void *a1)
{
  uint64_t v1 = sub_100095CB0(a1);
  return sub_1000AD818(v1);
}

void sub_100099ED0(uint64_t a1, int a2)
{
  if (a1)
  {
    int v4 = (const void **)&kCFBooleanTrue;
    int v5 = *(__CFDictionary **)(a1 + 16);
    if (!a2) {
      int v4 = (const void **)&kCFBooleanFalse;
    }
    CFDictionarySetValue(v5, @"enabled", *v4);
    if (a2)
    {
      sub_100099F8C(a1, 0LL);
      CFDictionaryRemoveValue(*(CFMutableDictionaryRef *)(a1 + 16), @"networkDisabledTimestamp");
      CFDictionaryRemoveValue(*(CFMutableDictionaryRef *)(a1 + 16), @"networkDisabledReason");
      CFDictionaryRemoveValue(*(CFMutableDictionaryRef *)(a1 + 16), @"networkDisabledClientName");
      __int16 v6 = *(__CFDictionary **)(a1 + 16);
      __int16 v7 = @"prevJoined";
    }

    else
    {
      __int16 v6 = *(__CFDictionary **)(a1 + 16);
      __int16 v7 = @"WiFiNetworkUserAcceptedRecommendationAt";
    }

    CFDictionaryRemoveValue(v6, v7);
  }

void sub_100099F8C(uint64_t a1, const void *a2)
{
  if (a1)
  {
    CFTypeID v2 = a2;
    BOOL v3 = (const void *)a1;
    if (!a2)
    {
      int v4 = objc_autoreleasePoolPush();
      if (qword_100219F60) {
        [(id)qword_100219F60 WFLog:3, "%s: Clearing disable-until property for SSID '%@'", "WiFiNetworkSetDisabledUntilDate", sub_100095BC8(v3) message];
      }
      objc_autoreleasePoolPop(v4);
      a1 = (uint64_t)v3;
      CFTypeID v2 = 0LL;
    }

    sub_10009582C(a1, @"WiFiNetworkDisabledUntilDate", v2);
  }

void sub_10009A048(CFMutableDictionaryRef *a1, int a2, const void *a3)
{
  if (a1)
  {
    if (a3)
    {
      CFTypeID TypeID = CFStringGetTypeID();
      if (TypeID == CFGetTypeID(a3))
      {
        if (os_log_type_enabled((os_log_t)&_os_log_default, OS_LOG_TYPE_ERROR)) {
          sub_100154248(a1, a2, (uint64_t)a3);
        }
        BOOL v7 = sub_10009A128((uint64_t)a1);
        if (!a2 && v7)
        {
          sub_10009582C((uint64_t)a1, @"networkDisabledReason", a3);
          CFAbsoluteTime Current = CFAbsoluteTimeGetCurrent();
          CFDateRef v9 = CFDateCreate(kCFAllocatorDefault, Current);
          if (v9)
          {
            CFDateRef v10 = v9;
            CFDictionarySetValue(a1[2], @"networkDisabledTimestamp", v9);
            CFRelease(v10);
          }
        }
      }
    }
  }

  sub_100099ED0((uint64_t)a1, a2);
}

BOOL sub_10009A128(uint64_t a1)
{
  CFBooleanRef Value = CFDictionaryGetValue(*(CFDictionaryRef *)(a1 + 16), @"enabled");
  return !Value || CFEqual(Value, kCFBooleanFalse) == 0;
}

BOOL sub_10009A16C(uint64_t a1)
{
  return CFDictionaryGetValue(*(CFDictionaryRef *)(a1 + 16), @"enabled") != 0LL;
}

void sub_10009A194(const void *a1, int a2, const void *a3)
{
  __int16 v6 = (const void *)sub_10009A1FC(a1);
  if (v6) {
    sub_10009582C((uint64_t)a1, @"prevJoined", v6);
  }
  if (a2) {
    BOOL v7 = @"lastJoined";
  }
  else {
    BOOL v7 = @"lastAutoJoined";
  }
  sub_10009582C((uint64_t)a1, v7, a3);
}

unint64_t sub_10009A1FC(const void *a1)
{
  unint64_t v2 = (unint64_t)sub_1000951FC((uint64_t)a1, @"lastJoined");
  unint64_t result = (unint64_t)sub_1000951FC((uint64_t)a1, @"lastAutoJoined");
  if (v2 | result)
  {
    int v5 = (const __CFDate *)result;
    if (!result) {
      unint64_t result = v2;
    }
    if (v2 && v5)
    {
      if (CFDateCompare((CFDateRef)v2, v5, 0LL) == kCFCompareGreaterThan) {
        return v2;
      }
      else {
        return (unint64_t)v5;
      }
    }
  }

  else
  {
    int v4 = objc_autoreleasePoolPush();
    if (qword_100219F60) {
      [(id)qword_100219F60 WFLog:4, "Network %@ Both autojoin and user join dates are NULL", sub_100095BC8(a1) message];
    }
    objc_autoreleasePoolPop(v4);
    return 0LL;
  }

  return result;
}

const void *sub_10009A2C4(uint64_t a1, int a2)
{
  if (a2) {
    unint64_t v2 = @"lastJoined";
  }
  else {
    unint64_t v2 = @"lastAutoJoined";
  }
  return sub_1000951FC(a1, v2);
}

double sub_10009A2E0(const void *a1)
{
  unint64_t v2 = (const __CFDate *)sub_10009A1FC(a1);
  BOOL v3 = (const __CFDate *)sub_1000951FC((uint64_t)a1, @"prevJoined");
  if (v2 && v3) {
    return CFDateGetTimeIntervalSinceDate(v2, v3);
  }
  double result = -1.0;
  if (v2) {
    return 0.0;
  }
  return result;
}

double sub_10009A340(uint64_t a1)
{
  uint64_t v1 = sub_1000951FC(a1, @"networkUsage");
  return sub_10003AC38(v1);
}

void sub_10009A35C(uint64_t a1, double a2)
{
}

const void *sub_10009A36C(uint64_t a1)
{
  if (a1) {
    return sub_1000951FC(a1, @"CHANNEL_FLAGS");
  }
  unint64_t v2 = objc_autoreleasePoolPush();
  if (qword_100219F60) {
    [qword_100219F60 WFLog:@"%s: null network" message:3];
  }
  objc_autoreleasePoolPop(v2);
  return 0LL;
}

CFNumberRef sub_10009A3DC(uint64_t a1)
{
  uint64_t v1 = (const __CFNumber *)sub_1000951FC(a1, @"PHY_MODE");
  return sub_10003AC9C(v1);
}

uint64_t sub_10009A3FC(uint64_t a1)
{
  unsigned __int16 valuePtr = 0;
  if (!a1)
  {
    BOOL v3 = objc_autoreleasePoolPush();
    if (qword_100219F60) {
      [qword_100219F60 WFLog:@"%s: null network" message:3];
    }
    goto LABEL_9;
  }

  uint64_t v1 = (const __CFNumber *)sub_1000951FC(a1, @"CHANNEL_WIDTH");
  if (!v1)
  {
    BOOL v3 = objc_autoreleasePoolPush();
    if (qword_100219F60) {
      [qword_100219F60 WFLog:@"%s: null APPLE80211KEY_CHANNEL_WIDTH" message:3];
    }
LABEL_9:
    objc_autoreleasePoolPop(v3);
    return 0LL;
  }

  CFNumberGetValue(v1, kCFNumberSInt16Type, &valuePtr);
  return valuePtr;
}

uint64_t sub_10009A4B8(int a1)
{
  if (a1 < 1) {
    return 0LL;
  }
  uint64_t v2 = 0LL;
  while (dword_100218F98[v2] != a1)
  {
    if (++v2 == 33) {
      return 0LL;
    }
  }

  return 2LL;
}

void sub_10009A504(const void *a1)
{
  CFAbsoluteTime Current = CFAbsoluteTimeGetCurrent();
  CFDateRef v3 = CFDateCreate(kCFAllocatorDefault, Current);
  CFDateRef v4 = v3;
  if (!a1 || !v3) {
    goto LABEL_47;
  }
  int v5 = sub_1000951FC((uint64_t)a1, @"CHANNEL");
  if (v5)
  {
    __int16 v6 = v5;
    BOOL v7 = sub_1000951FC((uint64_t)a1, @"CHANNEL_FLAGS");
    if (v7)
    {
      BOOL v8 = v7;
      CFTypeRef cf2 = sub_1000951FC((uint64_t)a1, @"BSSID");
      if (cf2)
      {
        theArray = CFArrayCreateMutable(kCFAllocatorDefault, 0LL, &kCFTypeArrayCallBacks);
        if (theArray)
        {
          CFDateRef v9 = (const __CFArray *)sub_1000951FC((uint64_t)a1, @"networkKnownBSSListKey");
          if (!v9) {
            goto LABEL_18;
          }
          CFDateRef v10 = v9;
          if (CFArrayGetCount(v9) < 1) {
            goto LABEL_18;
          }
          __int16 v11 = 0LL;
          CFIndex v12 = 0LL;
          do
          {
            ValueAtIndex = (const __CFDictionary *)CFArrayGetValueAtIndex(v10, v12);
            if (ValueAtIndex)
            {
              CFRange v14 = ValueAtIndex;
              CFBooleanRef Value = CFDictionaryGetValue(ValueAtIndex, @"BSSID");
              if (Value)
              {
                if (CFEqual(Value, cf2)) {
                  __int16 v11 = v14;
                }
                else {
                  CFArrayAppendValue(theArray, v14);
                }
              }
            }

            ++v12;
          }

          while (v12 < CFArrayGetCount(v10));
          if (v11) {
            MutableCFDictionaryRef Copy = CFDictionaryCreateMutableCopy(kCFAllocatorDefault, 0LL, v11);
          }
          else {
LABEL_18:
          }
            MutableCFDictionaryRef Copy = CFDictionaryCreateMutable( kCFAllocatorDefault,  0LL,  &kCFTypeDictionaryKeyCallBacks,  &kCFTypeDictionaryValueCallBacks);
          unint64_t v17 = MutableCopy;
          if (MutableCopy)
          {
            CFDictionarySetValue(MutableCopy, @"BSSID", cf2);
            CFDictionarySetValue(v17, @"CHANNEL", v6);
            CFDictionarySetValue(v17, @"CHANNEL_FLAGS", v8);
            CFDictionarySetValue(v17, @"lastRoamed", v4);
            int v18 = (const __CFNumber *)sub_1000951FC((uint64_t)a1, @"CHANNEL_FLAGS");
            if (v18)
            {
              int valuePtr = 0;
              CFNumberGetValue(v18, kCFNumberSInt32Type, &valuePtr);
              if ((valuePtr & 0x2000) != 0)
              {
                int v19 = (const __CFArray *)sub_1000951FC((uint64_t)a1, @"ORIG_RNR_CHANNEL_LIST");
                if (v19)
                {
                  CFDictionaryRef v20 = v19;
                  if (CFArrayGetCount(v19) >= 1)
                  {
                    id v34 = v6;
                    CFIndex v35 = a1;
                    uint64_t v36 = v4;
                    CFIndex v21 = 0LL;
                    CFBooleanRef v22 = 0LL;
                    int v23 = 0LL;
                    BOOL v24 = 0LL;
                    int v25 = 0LL;
                    while (!v25 || !v23)
                    {
                      int v26 = (const __CFDictionary *)CFArrayGetValueAtIndex(v20, v21);
                      if (v26)
                      {
                        BOOL v27 = v26;
                        int v28 = CFDictionaryGetValue(v26, @"CHANNEL");
                        int v29 = (const __CFNumber *)CFDictionaryGetValue(v27, @"CHANNEL_FLAGS");
                        if (v28)
                        {
                          int v30 = v29;
                          if (v29)
                          {
                            int v39 = 0;
                            CFNumberGetValue(v29, kCFNumberSInt32Type, &v39);
                            if ((v39 & 8) != 0)
                            {
                              int v25 = v28;
                              BOOL v24 = v30;
                            }

                            else if ((v39 & 0x10) != 0)
                            {
                              int v23 = v28;
                              CFBooleanRef v22 = v30;
                            }
                          }
                        }
                      }

                      if (CFArrayGetCount(v20) <= ++v21)
                      {
                        if (!v23) {
                          goto LABEL_37;
                        }
                        break;
                      }
                    }

                    CFDictionarySetValue(v17, @"colocated5GHzRNRChannel", v23);
                    CFDictionarySetValue(v17, @"colocated5GHzRNRChannelFlags", v22);
LABEL_37:
                    a1 = v35;
                    CFDateRef v4 = v36;
                    __int16 v6 = v34;
                    if (v25)
                    {
                      CFDictionarySetValue(v17, @"colocated2GHzRNRChannel", v25);
                      CFDictionarySetValue(v17, @"colocated2GHzRNRChannelFlags", v24);
                    }
                  }
                }
              }
            }

            unsigned int v31 = sub_1000951FC((uint64_t)a1, @"LEAKY_AP_LEARNED_DATA");
            if (v31)
            {
              CFDictionarySetValue(v17, @"LEAKY_AP_LEARNED_DATA", v31);
              sub_10009582C((uint64_t)a1, @"LEAKY_AP_LEARNED_DATA", 0LL);
              unsigned int v32 = objc_autoreleasePoolPush();
              if (qword_100219F60) {
                [qword_100219F60 WFLog:@"message: moved leaky AP info to bss dictionary" message:3];
              }
              objc_autoreleasePoolPop(v32);
            }

            CFArrayAppendValue(theArray, v17);
            sub_10009582C((uint64_t)a1, @"networkKnownBSSListKey", theArray);
            int v33 = objc_autoreleasePoolPush();
            if (qword_100219F60) {
              [(id)qword_100219F60 WFLog:3, "%s: successfully prepared known BSS info for %@ (bssid: %@, channel: %@)", "WiFiNetworkPrepareKnownBssList", sub_100095BC8(a1), cf2, v6 message];
            }
            objc_autoreleasePoolPop(v33);
            CFRelease(theArray);
          }

          else
          {
            unint64_t v17 = theArray;
          }

          CFRelease(v17);
LABEL_47:
          if (!v4) {
            return;
          }
        }
      }
    }
  }

  CFRelease(v4);
}

void sub_10009A95C(uint64_t a1, CFArrayRef theArray)
{
  if (a1)
  {
    if (theArray)
    {
      if (CFArrayGetCount(theArray) >= 1)
      {
        CFDateRef v4 = (const __CFArray *)sub_1000951FC(a1, @"networkKnownBSSListKey");
        if (v4)
        {
          int v5 = v4;
          CFMutableArrayRef Mutable = CFArrayCreateMutable(kCFAllocatorDefault, 0LL, &kCFTypeArrayCallBacks);
          if (Mutable)
          {
            BOOL v7 = Mutable;
            if (CFArrayGetCount(v5) >= 1)
            {
              CFIndex v8 = 0LL;
              do
              {
                ValueAtIndex = (const __CFDictionary *)CFArrayGetValueAtIndex(v5, v8);
                if (ValueAtIndex)
                {
                  CFDateRef v10 = ValueAtIndex;
                  CFBooleanRef Value = CFDictionaryGetValue(ValueAtIndex, @"BSSID");
                  if (Value)
                  {
                    CFIndex v12 = Value;
                    v15.length = CFArrayGetCount(theArray);
                    v15.location = 0LL;
                    if (CFArrayGetFirstIndexOfValue(theArray, v15, v12) == -1)
                    {
                      CFArrayAppendValue(v7, v10);
                    }

                    else
                    {
                      int v13 = objc_autoreleasePoolPush();
                      if (qword_100219F60) {
                        [qword_100219F60 WFLog:@"%s: Removed known BSS from index %ld" message:3, "%s: Removed known BSS from index %ld",  "WiFiNetworkRemoveBssFromKnownList",  v8];
                      }
                      objc_autoreleasePoolPop(v13);
                    }
                  }
                }

                ++v8;
              }

              while (v8 < CFArrayGetCount(v5));
            }

            CFRange v14 = objc_autoreleasePoolPush();
            if (qword_100219F60) {
              [(id)qword_100219F60 WFLog:3, "%s: updated known BSS list after removal - %@", "WiFiNetworkRemoveBssFromKnownList", v7 message];
            }
            objc_autoreleasePoolPop(v14);
            sub_10009582C(a1, @"networkKnownBSSListKey", v7);
            CFRelease(v7);
          }
        }
      }
    }
  }

void sub_10009AB20(const void *a1, const void *a2)
{
  CFAbsoluteTime Current = CFAbsoluteTimeGetCurrent();
  CFDateRef v5 = CFDateCreate(kCFAllocatorDefault, Current);
  if (!a1 || !a2) {
    goto LABEL_30;
  }
  __int16 v6 = (void *)sub_1000951FC((uint64_t)a2, @"CHANNEL");
  BOOL v7 = (void *)sub_1000951FC((uint64_t)a2, @"CHANNEL_FLAGS");
  CFIndex v8 = sub_1000951FC((uint64_t)a2, @"BSSID");
  if (v8)
  {
    CFDateRef v9 = v8;
    CFMutableArrayRef Mutable = CFArrayCreateMutable(kCFAllocatorDefault, 0LL, &kCFTypeArrayCallBacks);
    if (Mutable)
    {
      __int16 v11 = Mutable;
      int v28 = v7;
      CFIndex v12 = objc_autoreleasePoolPush();
      if (qword_100219F60) {
        [(id)qword_100219F60 WFLog:3, "%s: BSS updated - current BSS: %@ (%@)", "WiFiNetworkSetKnownBssUsageData", v9, v6 message];
      }
      value = v6;
      objc_autoreleasePoolPop(v12);
      int v13 = (const __CFArray *)sub_1000951FC((uint64_t)a1, @"networkKnownBSSListKey");
      if (!v13) {
        goto LABEL_20;
      }
      CFRange v14 = v13;
      BOOL v27 = v5;
      if (CFArrayGetCount(v13) < 1)
      {
        CFRange v15 = 0LL;
      }

      else
      {
        CFRange v15 = 0LL;
        CFIndex v16 = 0LL;
        do
        {
          ValueAtIndex = (const __CFDictionary *)CFArrayGetValueAtIndex(v14, v16);
          if (ValueAtIndex)
          {
            int v18 = ValueAtIndex;
            int v19 = CFDictionaryGetValue(ValueAtIndex, @"BSSID");
            if (v19)
            {
              if (CFEqual(v19, v9)) {
                CFRange v15 = v18;
              }
              else {
                CFArrayAppendValue(v11, v18);
              }
            }
          }

          ++v16;
        }

        while (v16 < CFArrayGetCount(v14));
      }

      CFDateRef v5 = v27;
      if (v15) {
        MutableCFDictionaryRef Copy = CFDictionaryCreateMutableCopy(kCFAllocatorDefault, 0LL, v15);
      }
      else {
LABEL_20:
      }
        MutableCFDictionaryRef Copy = CFDictionaryCreateMutable( kCFAllocatorDefault,  0LL,  &kCFTypeDictionaryKeyCallBacks,  &kCFTypeDictionaryValueCallBacks);
      CFIndex v21 = MutableCopy;
      if (MutableCopy)
      {
        CFDictionarySetValue(MutableCopy, @"BSSID", v9);
        CFDictionarySetValue(v21, @"CHANNEL", value);
        CFDictionarySetValue(v21, @"CHANNEL_FLAGS", v28);
        CFDictionarySetValue(v21, @"lastRoamed", v5);
        CFArrayAppendValue(v11, v21);
        if (CFArrayGetCount(v11) >= 21)
        {
          CFBooleanRef v22 = objc_autoreleasePoolPush();
          if (qword_100219F60) {
            [(id)qword_100219F60 WFLog:3, "%s: known BSS list has grown beyond maximum. Removing %@", "WiFiNetworkSetKnownBssUsageData", CFArrayGetValueAtIndex(v11, 0) message];
          }
          objc_autoreleasePoolPop(v22);
          CFArrayRemoveValueAtIndex(v11, 0LL);
        }

        int v23 = objc_autoreleasePoolPush();
        BOOL v24 = (void *)qword_100219F60;
        if (qword_100219F60)
        {
          int v25 = sub_100095BC8(a1);
          [v24 WFLog:2, "%s: known BSS stats for %@ - num. of BSS = %ld", "WiFiNetworkSetKnownBssUsageData", v25, CFArrayGetCount(v11) message];
        }

        objc_autoreleasePoolPop(v23);
        sub_10009582C((uint64_t)a2, @"networkKnownBSSListKey", v11);
        sub_10009582C((uint64_t)a1, @"networkKnownBSSListKey", v11);
        CFRelease(v21);
      }

      CFRelease(v11);
    }

void sub_10009AEBC(const void *a1, const void *a2, double a3, double a4, double a5)
{
  if (a1 && a2)
  {
    CFDateRef v10 = sub_1000951FC((uint64_t)a1, @"BSSID");
    if (v10)
    {
      __int16 v11 = v10;
      CFMutableArrayRef Mutable = CFArrayCreateMutable(kCFAllocatorDefault, 0LL, &kCFTypeArrayCallBacks);
      if (Mutable)
      {
        int v13 = Mutable;
        CFRange v14 = (const __CFArray *)sub_1000951FC((uint64_t)a1, @"networkKnownBSSListKey");
        if (v14)
        {
          CFRange v15 = v14;
          if (CFArrayGetCount(v14) >= 1)
          {
            CFIndex v16 = 0LL;
            CFIndex v17 = 0LL;
            do
            {
              ValueAtIndex = (const __CFDictionary *)CFArrayGetValueAtIndex(v15, v17);
              if (ValueAtIndex)
              {
                int v19 = ValueAtIndex;
                CFBooleanRef Value = CFDictionaryGetValue(ValueAtIndex, @"BSSID");
                if (Value)
                {
                  if (CFEqual(Value, v11)) {
                    CFIndex v16 = v19;
                  }
                  else {
                    CFArrayAppendValue(v13, v19);
                  }
                }
              }

              ++v17;
            }

            while (v17 < CFArrayGetCount(v15));
            if (v16)
            {
              MutableCFDictionaryRef Copy = CFDictionaryCreateMutableCopy(kCFAllocatorDefault, 0LL, v16);
              if (MutableCopy)
              {
                CFBooleanRef v22 = MutableCopy;
                CFDictionarySetValue( MutableCopy,  @"networkLocnLat",  +[NSNumber numberWithDouble:](&OBJC_CLASS___NSNumber, "numberWithDouble:", a3));
                CFDictionarySetValue( v22,  @"networkLocnLong",  +[NSNumber numberWithDouble:](&OBJC_CLASS___NSNumber, "numberWithDouble:", a4));
                CFDictionarySetValue( v22,  @"networkLocnAccuracy",  +[NSNumber numberWithDouble:](&OBJC_CLASS___NSNumber, "numberWithDouble:", a5));
                CFDictionarySetValue(v22, @"networkLocnTimestamp", a2);
                CFArrayAppendValue(v13, v22);
                sub_10009582C((uint64_t)a1, @"networkKnownBSSListKey", v13);
                CFRelease(v22);
              }
            }
          }
        }

        CFRelease(v13);
      }
    }

    else
    {
      int v23 = objc_autoreleasePoolPush();
      if (qword_100219F60) {
        [(id)qword_100219F60 WFLog:3, "%s: failed to get BSSID from %@", "WiFiNetworkSetBSSLocation", sub_100095BC8(a1) message];
      }
      objc_autoreleasePoolPop(v23);
    }
  }

void sub_10009B14C(const void *a1, const __CFString *a2, uint64_t a3)
{
  if (a1 && a3)
  {
    __int16 v6 = sub_100095BC8(a1);
    if (a2)
    {
      CFMutableArrayRef Mutable = CFArrayCreateMutable(kCFAllocatorDefault, 0LL, &kCFTypeArrayCallBacks);
      if (Mutable)
      {
        CFIndex v8 = Mutable;
        CFDateRef v9 = (const __CFArray *)sub_1000951FC((uint64_t)a1, @"networkKnownBSSListKey");
        if (v9)
        {
          CFDateRef v10 = v9;
          if (CFArrayGetCount(v9) >= 1)
          {
            CFIndex v11 = 0LL;
            do
            {
              ValueAtIndex = (const __CFDictionary *)CFArrayGetValueAtIndex(v10, v11);
              if (ValueAtIndex)
              {
                int v13 = ValueAtIndex;
                CFBooleanRef Value = (const __CFString *)CFDictionaryGetValue(ValueAtIndex, @"BSSID");
                if (Value)
                {
                  if (CFStringCompare(Value, a2, 1uLL))
                  {
                    CFArrayAppendValue(v8, v13);
                  }

                  else
                  {
                    MutableCFDictionaryRef Copy = CFDictionaryCreateMutableCopy(kCFAllocatorDefault, 0LL, v13);
                    if (MutableCopy)
                    {
                      CFMutableDictionaryRef v16 = MutableCopy;
                      (*(void (**)(uint64_t, CFMutableDictionaryRef))(a3 + 16))(a3, MutableCopy);
                      CFArrayAppendValue(v8, v16);
                      CFRelease(v16);
                    }
                  }
                }
              }

              ++v11;
            }

            while (v11 < CFArrayGetCount(v10));
          }
        }

        sub_10009582C((uint64_t)a1, @"networkKnownBSSListKey", v8);
        CFRelease(v8);
      }
    }

    else
    {
      CFIndex v17 = v6;
      int v18 = objc_autoreleasePoolPush();
      if (qword_100219F60) {
        [(id)qword_100219F60 WFLog:3, "%s: failed to get BSSID from %@", "WiFiNetworkSetBSSProperty", v17 message];
      }
      objc_autoreleasePoolPop(v18);
    }
  }

void sub_10009B324(const void *a1, const void *a2)
{
  if (a1 && a2)
  {
    CFDateRef v4 = sub_1000951FC((uint64_t)a1, @"BSSID");
    if (v4)
    {
      CFDateRef v5 = v4;
      CFMutableArrayRef Mutable = CFArrayCreateMutable(kCFAllocatorDefault, 0LL, &kCFTypeArrayCallBacks);
      if (Mutable)
      {
        BOOL v7 = Mutable;
        CFIndex v8 = objc_autoreleasePoolPush();
        if (qword_100219F60) {
          [(id)qword_100219F60 WFLog:3, "%s: BSS updated - current BSS: %@ (awdl=%@)", "WiFiNetworkSetBSSAWDLRealTimeModeTimestamp", v5, a2 message];
        }
        objc_autoreleasePoolPop(v8);
        CFDateRef v9 = (const __CFArray *)sub_1000951FC((uint64_t)a1, @"networkKnownBSSListKey");
        if (v9)
        {
          CFDateRef v10 = v9;
          if (CFArrayGetCount(v9) >= 1)
          {
            CFIndex v11 = 0LL;
            CFIndex v12 = 0LL;
            do
            {
              ValueAtIndex = (const __CFDictionary *)CFArrayGetValueAtIndex(v10, v12);
              if (ValueAtIndex)
              {
                CFRange v14 = ValueAtIndex;
                CFBooleanRef Value = CFDictionaryGetValue(ValueAtIndex, @"BSSID");
                if (Value)
                {
                  if (CFEqual(Value, v5)) {
                    CFIndex v11 = v14;
                  }
                  else {
                    CFArrayAppendValue(v7, v14);
                  }
                }
              }

              ++v12;
            }

            while (v12 < CFArrayGetCount(v10));
            if (v11)
            {
              MutableCFDictionaryRef Copy = CFDictionaryCreateMutableCopy(kCFAllocatorDefault, 0LL, v11);
              if (MutableCopy)
              {
                CFIndex v17 = MutableCopy;
                CFDictionarySetValue(MutableCopy, @"AWDLRealTimeModeTimestamp", a2);
                CFArrayAppendValue(v7, v17);
                sub_10009582C((uint64_t)a1, @"networkKnownBSSListKey", v7);
                CFRelease(v17);
              }
            }
          }
        }

        CFRelease(v7);
      }
    }

    else
    {
      int v18 = objc_autoreleasePoolPush();
      if (qword_100219F60) {
        [(id)qword_100219F60 WFLog:3, "%s: failed to get BSSID from %@", "WiFiNetworkSetBSSAWDLRealTimeModeTimestamp", sub_100095BC8(a1) message];
      }
      objc_autoreleasePoolPop(v18);
    }
  }

void sub_10009B560(uint64_t a1, const void *a2, int a3, int a4)
{
  int v41 = a4;
  int v42 = a3;
  if (a1 && a2)
  {
    CFIndex v8 = sub_1000951FC((uint64_t)a2, @"BSSID");
    if (v8)
    {
      CFDateRef v9 = v8;
      CFMutableArrayRef Mutable = CFArrayCreateMutable(kCFAllocatorDefault, 0LL, &kCFTypeArrayCallBacks);
      CFIndex v11 = objc_autoreleasePoolPush();
      if (Mutable)
      {
        int v38 = a4;
        int v39 = a3;
        if (qword_100219F60) {
          [(id)qword_100219F60 WFLog:3, "%s: BSS late roam data - %@ current BSS: %@", "WiFiNetworkSetBssLateRoamInfo", sub_100095BC8(a2), v9 message];
        }
        objc_autoreleasePoolPop(v11);
        CFIndex v12 = (const __CFArray *)sub_1000951FC(a1, @"networkKnownBSSListKey");
        if (!v12) {
          goto LABEL_46;
        }
        int v13 = v12;
        if (CFArrayGetCount(v12) < 1)
        {
          CFRange v14 = 0LL;
        }

        else
        {
          CFRange v14 = 0LL;
          CFIndex v15 = 0LL;
          do
          {
            ValueAtIndex = (const __CFDictionary *)CFArrayGetValueAtIndex(v13, v15);
            if (ValueAtIndex)
            {
              CFIndex v17 = ValueAtIndex;
              CFBooleanRef Value = CFDictionaryGetValue(ValueAtIndex, @"BSSID");
              if (Value)
              {
                if (CFEqual(Value, v9)) {
                  CFRange v14 = v17;
                }
                else {
                  CFArrayAppendValue(Mutable, v17);
                }
              }
            }

            ++v15;
          }

          while (v15 < CFArrayGetCount(v13));
        }

        if (!v14) {
          goto LABEL_46;
        }
        MutableCFDictionaryRef Copy = CFDictionaryCreateMutableCopy(kCFAllocatorDefault, 0LL, v14);
        if (!MutableCopy)
        {
          id v34 = objc_autoreleasePoolPush();
          if (qword_100219F60) {
            [qword_100219F60 WFLog:@"%s: Failed to create newBssDict" message:4];
          }
          objc_autoreleasePoolPop(v34);
          goto LABEL_46;
        }

        CFMutableDictionaryRef v20 = MutableCopy;
        CFIndex v21 = (const __CFDictionary *)CFDictionaryGetValue(v14, @"lateRoamInfo");
        if (v21)
        {
          CFBooleanRef v22 = v21;
          int v23 = objc_autoreleasePoolPush();
          if (qword_100219F60) {
            [(id)qword_100219F60 WFLog:4, "%s: Creating new Late Roam Info %@ - %@", "WiFiNetworkSetBssLateRoamInfo", sub_100095BC8(a2), v9 message];
          }
          objc_autoreleasePoolPop(v23);
          BOOL v24 = CFDictionaryCreateMutableCopy(kCFAllocatorDefault, 0LL, v22);
        }

        else
        {
          BOOL v24 = CFDictionaryCreateMutable( kCFAllocatorDefault,  0LL,  &kCFTypeDictionaryKeyCallBacks,  &kCFTypeDictionaryValueCallBacks);
        }

        int v25 = v24;
        if (!v24)
        {
          CFIndex v35 = objc_autoreleasePoolPush();
          if (qword_100219F60) {
            [qword_100219F60 WFLog:@"Failed to create newLateRoamInfoDict"];
          }
          objc_autoreleasePoolPop(v35);
          goto LABEL_45;
        }

        int v26 = (const __CFNumber *)CFDictionaryGetValue(v24, @"lateRoamMinDelta");
        if (v26 && (int valuePtr = 0, CFNumberGetValue(v26, kCFNumberIntType, &valuePtr)) && valuePtr <= v39)
        {
          CFNumberRef v27 = 0LL;
        }

        else
        {
          CFNumberRef v28 = CFNumberCreate(kCFAllocatorDefault, kCFNumberIntType, &v42);
          if (!v28)
          {
            uint64_t v36 = objc_autoreleasePoolPush();
            if (qword_100219F60) {
              [qword_100219F60 WFLog:@"Failed to create newMinDeltaRef"];
            }
            objc_autoreleasePoolPop(v36);
            goto LABEL_44;
          }

          CFNumberRef v27 = v28;
          CFDictionarySetValue(v25, @"lateRoamMinDelta", v28);
        }

        int v29 = (const __CFNumber *)CFDictionaryGetValue(v25, @"lateRoamMaxDelta");
        if (v29 && (int valuePtr = 0, CFNumberGetValue(v29, kCFNumberIntType, &valuePtr)) && valuePtr >= v38)
        {
          CFNumberRef v30 = 0LL;
        }

        else
        {
          CFNumberRef v31 = CFNumberCreate(kCFAllocatorDefault, kCFNumberIntType, &v41);
          if (!v31)
          {
            __int16 v37 = objc_autoreleasePoolPush();
            if (qword_100219F60) {
              [qword_100219F60 WFLog:@"%s: Failed to create newMaxDeltaRef" message:4];
            }
            objc_autoreleasePoolPop(v37);
            CFNumberRef v30 = 0LL;
            if (!v27) {
              goto LABEL_42;
            }
LABEL_41:
            CFRelease(v27);
LABEL_42:
            if (v30) {
              CFRelease(v30);
            }
LABEL_44:
            CFRelease(v25);
LABEL_45:
            CFRelease(v20);
LABEL_46:
            CFRelease(Mutable);
            return;
          }

          CFNumberRef v30 = v31;
          CFDictionarySetValue(v25, @"lateRoamMaxDelta", v31);
        }

        CFDictionarySetValue(v20, @"lateRoamInfo", v25);
        CFArrayAppendValue(Mutable, v20);
        unsigned int v32 = objc_autoreleasePoolPush();
        if (qword_100219F60) {
          [(id)qword_100219F60 WFLog:3, "%s: Updated BSS late roam data - %@ current BSS: %@", "WiFiNetworkSetBssLateRoamInfo", sub_100095BC8(a2), v9 message];
        }
        objc_autoreleasePoolPop(v32);
        sub_10009582C((uint64_t)a2, @"networkKnownBSSListKey", Mutable);
        sub_10009582C(a1, @"networkKnownBSSListKey", Mutable);
        if (!v27) {
          goto LABEL_42;
        }
        goto LABEL_41;
      }

      if (qword_100219F60) {
        [qword_100219F60 WFLog:@"Failed to create newBssList"];
      }
      objc_autoreleasePoolPop(v11);
    }

    else
    {
      int v33 = objc_autoreleasePoolPush();
      if (qword_100219F60) {
        [(id)qword_100219F60 WFLog:4, "%s: Failed to get BSSID from %@", "WiFiNetworkSetBssLateRoamInfo", sub_100095BC8(a2) message];
      }
      objc_autoreleasePoolPop(v33);
    }
  }

void sub_10009BAA4(uint64_t a1, const __CFString *a2, uint64_t a3)
{
  double Current = CFAbsoluteTimeGetCurrent();
  int v47 = 0;
  int valuePtr = 0;
  int v46 = 0;
  if (!a1 || !a2) {
    return;
  }
  int v7 = a3 - 3;
  if ((a3 - 3) >= 3)
  {
    int v13 = objc_autoreleasePoolPush();
    if (qword_100219F60) {
      [qword_100219F60 WFLog:@"Incorrect reason code, bailing out!"];
    }
    objc_autoreleasePoolPop(v13);
    return;
  }

  CFAbsoluteTime v8 = Current;
  int v40 = dword_10017F964[v7];
  int v41 = dword_10017F958[v7];
  CFDateRef v9 = (const __CFDate *)sub_1000951FC(a1, @"knownBSSUpdatedDate");
  CFDateRef v10 = CFDateCreate(kCFAllocatorDefault, v8);
  if (!v9)
  {
    int v12 = 1;
    goto LABEL_12;
  }

  double v11 = v8 - CFDateGetAbsoluteTime(v9);
  if (v11 > 2592000.0)
  {
    int v12 = 0;
    LOBYTE(v9) = 1;
LABEL_12:
    sub_10009582C(a1, @"knownBSSUpdatedDate", v10);
    char v14 = v12;
    char v44 = (char)v9;
    goto LABEL_13;
  }

  LOBYTE(v9) = 0;
  char v14 = 0;
  int v12 = 1;
  char v44 = 1;
  if (v11 > 1296000.0) {
    goto LABEL_12;
  }
LABEL_13:
  int v42 = v12;
  uint64_t v38 = a1;
  CFDateRef cf = v10;
  CFIndex v15 = (const __CFArray *)sub_1000951FC(a1, @"networkKnownBSSListKey");
  CFMutableArrayRef Mutable = CFArrayCreateMutable(kCFAllocatorDefault, 0LL, &kCFTypeArrayCallBacks);
  if (Mutable)
  {
    CFIndex v17 = Mutable;
    if (v15 && CFArrayGetCount(v15) >= 1)
    {
      CFIndex v18 = 0LL;
      char v43 = v14 | v9;
      int v19 = @"BSSID";
      do
      {
        ValueAtIndex = (const __CFDictionary *)CFArrayGetValueAtIndex(v15, v18);
        if (!ValueAtIndex) {
          goto LABEL_46;
        }
        CFIndex v21 = ValueAtIndex;
        CFBooleanRef Value = (const __CFString *)CFDictionaryGetValue(ValueAtIndex, v19);
        if (!Value) {
          goto LABEL_46;
        }
        int v23 = Value;
        if (CFStringCompare(Value, a2, 0LL))
        {
          int v46 = 0;
          int v47 = 0;
          if ((v43 & 1) == 0)
          {
            CFArrayAppendValue(v17, v21);
            goto LABEL_46;
          }
        }

        else
        {
          int v47 = v41;
          int v46 = v40;
        }

        BOOL v24 = (const __CFNumber *)CFDictionaryGetValue(v21, @"beaconLossCount");
        if (v24)
        {
          CFNumberGetValue(v24, kCFNumberIntType, &valuePtr);
          if ((v44 & 1) != 0)
          {
            if (!v42) {
              goto LABEL_29;
            }
            int v25 = valuePtr & 0xFF00 | (v47 + valuePtr);
          }

          else
          {
            int v25 = v47 | (valuePtr << 8);
          }

          int v47 = v25;
        }

__CFDictionary *sub_10009BF08(uint64_t a1)
{
  uint64_t v1 = (const __CFArray *)sub_1000951FC(a1, @"networkKnownBSSListKey");
  if (!v1) {
    return 0LL;
  }
  uint64_t v2 = v1;
  CFMutableArrayRef Mutable = CFDictionaryCreateMutable( kCFAllocatorDefault,  0LL,  &kCFTypeDictionaryKeyCallBacks,  &kCFTypeDictionaryValueCallBacks);
  if (Mutable && CFArrayGetCount(v2) >= 1)
  {
    CFIndex v4 = 0LL;
    do
    {
      ValueAtIndex = (const __CFDictionary *)CFArrayGetValueAtIndex(v2, v4);
      if (ValueAtIndex)
      {
        __int16 v6 = ValueAtIndex;
        CFBooleanRef Value = CFDictionaryGetValue(ValueAtIndex, @"CHANNEL");
        if (Value)
        {
          CFAbsoluteTime v8 = Value;
          CFDateRef v9 = CFStringCreateMutable(kCFAllocatorDefault, 0LL);
          if (v9)
          {
            CFDateRef v10 = v9;
            CFStringAppendFormat(v9, 0LL, @"%@", v8);
            CFDictionarySetValue(Mutable, v10, v6);
            CFRelease(v10);
          }
        }
      }

      ++v4;
    }

    while (v4 < CFArrayGetCount(v2));
  }

  return Mutable;
}

uint64_t sub_10009C030(const void *a1, const void *a2)
{
  uint64_t v2 = 0LL;
  int valuePtr = 0;
  unsigned int v18 = 0;
  if (a1 && a2)
  {
    CFDateRef v5 = (const __CFArray *)sub_1000951FC((uint64_t)a1, @"networkKnownBSSListKey");
    uint64_t v2 = (uint64_t)v5;
    if (v5)
    {
      if (CFArrayGetCount(v5) < 1)
      {
LABEL_10:
        uint64_t v2 = 0LL;
      }

      else
      {
        CFIndex v6 = 0LL;
        while (1)
        {
          ValueAtIndex = (const __CFDictionary *)CFArrayGetValueAtIndex((CFArrayRef)v2, v6);
          if (ValueAtIndex)
          {
            CFAbsoluteTime v8 = ValueAtIndex;
            CFBooleanRef Value = CFDictionaryGetValue(ValueAtIndex, @"BSSID");
            if (Value)
            {
              if (CFEqual(Value, a2)) {
                break;
              }
            }
          }

          if (++v6 >= CFArrayGetCount((CFArrayRef)v2)) {
            goto LABEL_10;
          }
        }

        CFIndex v15 = (const __CFNumber *)CFDictionaryGetValue(v8, @"beaconLossCount");
        if (v15)
        {
          CFNumberGetValue(v15, kCFNumberIntType, &valuePtr);
          int valuePtr = BYTE1(valuePtr) + valuePtr;
        }

        CFMutableDictionaryRef v16 = (const __CFNumber *)CFDictionaryGetValue(v8, @"trigDisconnectCount");
        if (v16)
        {
          CFNumberGetValue(v16, kCFNumberIntType, &v18);
          unsigned int v18 = BYTE1(v18) + v18;
          BOOL v17 = v18 > 2;
        }

        else
        {
          BOOL v17 = 0;
        }

        uint64_t v2 = valuePtr > 5 || v17;
      }
    }

    CFDateRef v10 = objc_autoreleasePoolPush();
    double v11 = (void *)qword_100219F60;
    if (qword_100219F60)
    {
      int v12 = sub_100095BC8(a1);
      int v13 = "yes";
      if (!(_DWORD)v2) {
        int v13 = "no";
      }
      [v11 WFLog:3, "%s: %@ - %@ - %s - {bcnloss:%d trgDisc:%d}", "WiFiNetworkIsEdgeBss", v12, a2, v13, valuePtr, v18 message];
    }

    objc_autoreleasePoolPop(v10);
  }

  return v2;
}

uint64_t sub_10009C1E4(uint64_t a1, uint64_t a2)
{
  if (a1 | a2) {
    uint64_t v3 = -1LL;
  }
  else {
    uint64_t v3 = 0LL;
  }
  if (a2) {
    uint64_t result = 1LL;
  }
  else {
    uint64_t result = v3;
  }
  if (a1 && a2)
  {
    CFIndex v6 = sub_1000951FC(a1, @"networkUsage");
    double v7 = sub_10003AC38(v6);
    CFAbsoluteTime v8 = sub_1000951FC(a2, @"networkUsage");
    double v9 = sub_10003AC38(v8);
    if (v7 >= v9)
    {
      if (v7 <= v9) {
        return sub_10009C290(a1, a2);
      }
      else {
        return -1LL;
      }
    }

    else
    {
      return 1LL;
    }
  }

  return result;
}

uint64_t sub_10009C290(uint64_t a1, uint64_t a2)
{
  if (a1 | a2) {
    uint64_t v3 = -1LL;
  }
  else {
    uint64_t v3 = 0LL;
  }
  if (a2) {
    uint64_t result = 1LL;
  }
  else {
    uint64_t result = v3;
  }
  if (a1 && a2)
  {
    CFIndex v6 = (const __CFDate *)sub_1000951FC(a1, @"lastAutoJoined");
    double v7 = (const __CFDate *)sub_1000951FC(a1, @"lastJoined");
    CFAbsoluteTime v8 = v7;
    if (v6 && v7)
    {
      CFComparisonResult v9 = CFDateCompare(v6, v7, 0LL);
      if (v9 == kCFCompareGreaterThan) {
        CFDateRef v10 = v6;
      }
      else {
        CFDateRef v10 = 0LL;
      }
      if (v9 == kCFCompareEqualTo) {
        CFDateRef v10 = v8;
      }
      if (v9 == kCFCompareLessThan) {
        CFIndex v6 = v8;
      }
      else {
        CFIndex v6 = v10;
      }
    }

    else if (!v6)
    {
      CFIndex v6 = v7;
    }

    double v11 = (const __CFDate *)sub_1000951FC(a2, @"lastAutoJoined");
    int v12 = (const __CFDate *)sub_1000951FC(a2, @"lastJoined");
    int v13 = v12;
    if (v11 && v12)
    {
      CFComparisonResult v14 = CFDateCompare(v11, v12, 0LL);
      if (v14 != kCFCompareLessThan)
      {
        if (v14)
        {
          int v13 = v11;
          if (v14 != kCFCompareGreaterThan)
          {
            BOOL v15 = 0;
            BOOL v16 = v6 != 0LL;
LABEL_34:
            if (v16) {
              return -1LL;
            }
            else {
              return v15;
            }
          }
        }
      }
    }

    else if (v11)
    {
      int v13 = v11;
    }

    BOOL v16 = v6 != 0LL;
    BOOL v15 = v13 != 0LL;
    if (!v6 || !v13) {
      goto LABEL_34;
    }
    CFComparisonResult v17 = CFDateCompare(v6, v13, 0LL);
    if (v17 == kCFCompareGreaterThan) {
      return -1LL;
    }
    else {
      return v17 == kCFCompareLessThan;
    }
  }

  return result;
}

BOOL sub_10009C3F0(uint64_t a1, uint64_t a2)
{
  uint64_t valuePtr = 0LL;
  if (a1 | a2) {
    uint64_t v2 = -1LL;
  }
  else {
    uint64_t v2 = 0LL;
  }
  if (a2) {
    uint64_t v2 = 1LL;
  }
  if (a1 && a2)
  {
    CFIndex v4 = (const __CFNumber *)sub_1000951FC(a1, @"Strength");
    if (v4) {
      CFNumberGetValue(v4, kCFNumberFloatType, (char *)&valuePtr + 4);
    }
    CFDateRef v5 = (const __CFNumber *)sub_1000951FC(a2, @"Strength");
    if (v5)
    {
      CFNumberGetValue(v5, kCFNumberFloatType, &valuePtr);
      float v6 = *(float *)&valuePtr;
    }

    else
    {
      float v6 = 0.0;
    }

    uint64_t v2 = -1LL;
  }

  return v2;
}

CFArrayRef sub_10009C498(uint64_t a1)
{
  int valuePtr = 0;
  uint64_t result = (const __CFArray *)sub_1000951FC(a1, @"networkKnownBSSListKey");
  if (result)
  {
    uint64_t v2 = result;
    CFIndex Count = CFArrayGetCount(result);
    if (Count >= 2)
    {
      CFIndex v4 = Count;
      uint64_t v5 = 0LL;
      uint64_t v6 = 0LL;
      uint64_t v7 = 0LL;
      CFIndex v8 = 0LL;
      unsigned int v17 = -1431655766;
      do
      {
        ValueAtIndex = (const __CFDictionary *)CFArrayGetValueAtIndex(v2, v8);
        if (ValueAtIndex)
        {
          CFDateRef v10 = ValueAtIndex;
          CFBooleanRef Value = (const __CFNumber *)CFDictionaryGetValue(ValueAtIndex, @"CHANNEL");
          int v12 = (const __CFNumber *)CFDictionaryGetValue(v10, @"CHANNEL_FLAGS");
          if (Value)
          {
            int v13 = v12;
            if (v12)
            {
              CFNumberGetValue(Value, kCFNumberSInt32Type, &valuePtr);
              CFNumberGetValue(v13, kCFNumberSInt32Type, &v17);
              if (valuePtr)
              {
                if (v17)
                {
                  if ((v17 & 8) != 0)
                  {
                    ++v7;
                  }

                  else if ((v17 & 0x10) != 0)
                  {
                    ++v6;
                  }

                  else
                  {
                    v5 += ((unint64_t)v17 >> 13) & 1;
                  }
                }
              }
            }
          }
        }

        ++v8;
      }

      while (v4 != v8);
      return (const __CFArray *)(v6 > 1 || v7 > 1 || v5 > 1);
    }

    else
    {
      return 0LL;
    }
  }

  return result;
}

uint64_t sub_10009C5D4(uint64_t a1, uint64_t a2, _BYTE *a3)
{
  if (!(a1 | a2)) {
    return 0LL;
  }
  if (a1)
  {
    int v6 = sub_10009CD54(a1);
    if (v6 == 1)
    {
      uint64_t v7 = objc_autoreleasePoolPush();
      if (qword_100219F60) {
        [(id)qword_100219F60 WFLog:3, "NOI (1) '%@' is forced-fix", sub_100095BC8((const void *)a1) message];
      }
      objc_autoreleasePoolPop(v7);
      int v8 = 1;
    }

    else
    {
      int v8 = 0;
    }

    unsigned int v12 = sub_100096670(a1);
    if (v12 == 1)
    {
      int v13 = objc_autoreleasePoolPush();
      if (qword_100219F60) {
        [(id)qword_100219F60 WFLog:3, "NOI (1) '%@' has home-state", sub_100095BC8((const void *)a1) message];
      }
      objc_autoreleasePoolPop(v13);
      int v10 = 1;
    }

    else
    {
      int v10 = 0;
    }

    BOOL v11 = CFDictionaryContainsKey(*(CFDictionaryRef *)(a1 + 16), @"PayloadUUID") != 0;
    CFComparisonResult v14 = (const __CFDate *)sub_1000951FC(a1, @"addedAt");
    if (!a2)
    {
      uint64_t result = -1LL;
      if (v6 == 1) {
        return result;
      }
LABEL_45:
      if (v12 == 1) {
        return result;
      }
      return 0LL;
    }

    theDate = v14;
  }

  else
  {
    if (!a2) {
      return 0LL;
    }
    int v10 = 0;
    int v8 = 0;
    BOOL v11 = 0;
    theDate = 0LL;
  }

  int v15 = sub_10009CD54(a2);
  if (v15 == 1)
  {
    BOOL v16 = objc_autoreleasePoolPush();
    if (qword_100219F60) {
      [(id)qword_100219F60 WFLog:3, "NOI (1) '%@' is forced-fix", sub_100095BC8((const void *)a2) message];
    }
    objc_autoreleasePoolPop(v16);
  }

  unsigned int v12 = sub_100096670(a2);
  if (v12 == 1)
  {
    unsigned int v17 = objc_autoreleasePoolPush();
    if (qword_100219F60) {
      [(id)qword_100219F60 WFLog:3, "NOI (2) '%@' has home-state", sub_100095BC8((const void *)a2) message];
    }
    objc_autoreleasePoolPop(v17);
  }

  int v18 = CFDictionaryContainsKey(*(CFDictionaryRef *)(a2 + 16), @"PayloadUUID");
  int v19 = (const __CFDate *)sub_1000951FC(a2, @"addedAt");
  if (!a1 || !a2)
  {
    if (v8) {
      uint64_t result = -1LL;
    }
    else {
      uint64_t result = 1LL;
    }
    if (v8 || v15 == 1) {
      return result;
    }
    uint64_t result = v10 ? -1LL : 1LL;
    if (v10) {
      return result;
    }
    goto LABEL_45;
  }

  if (v8 && v15 == 1)
  {
    CFMutableDictionaryRef v20 = (const __CFDate *)sub_10009CE28(a1);
    CFIndex v21 = (const __CFDate *)sub_10009CE28(a2);
    CFComparisonResult v22 = CFDateCompare(v20, v21, 0LL);
    int v23 = objc_autoreleasePoolPush();
    BOOL v24 = (void *)qword_100219F60;
    if (v22 != kCFCompareLessThan)
    {
      if (qword_100219F60)
      {
        int v25 = sub_100095BC8((const void *)a1);
        int v26 = sub_100095BC8((const void *)a2);
        [v24 WFLog:3, "Both (%@) and (%@) force fixed. Preferred (1), the most recently force fixed: %@", v25, v26, sub_100095BC8((const void *)a1), v68 message];
      }

uint64_t sub_10009CD54(uint64_t a1)
{
  if (!a1)
  {
    uint64_t v5 = objc_autoreleasePoolPush();
    if (qword_100219F60) {
      objc_msgSend((id)qword_100219F60, "WFLog:message:", 3, "%s: null network", "WiFiNetworkGetForcedHomeFix");
    }
LABEL_9:
    objc_autoreleasePoolPop(v5);
    return 0LL;
  }

  uint64_t v1 = (const __CFBoolean *)sub_1000951FC(a1, @"NetworkForcedHomeFix");
  if (v1)
  {
    uint64_t v2 = v1;
    CFTypeID v3 = CFGetTypeID(v1);
    if (v3 == CFBooleanGetTypeID()) {
      return CFBooleanGetValue(v2);
    }
    uint64_t v5 = objc_autoreleasePoolPush();
    if (qword_100219F60) {
      objc_msgSend((id)qword_100219F60, "WFLog:message:", 3, "%s: invalid value type", "WiFiNetworkGetForcedHomeFix");
    }
    goto LABEL_9;
  }

  return 0LL;
}

const void *sub_10009CE28(uint64_t a1)
{
  if (a1) {
    return sub_1000951FC(a1, @"kWiFiNetworkLastHomeForceFixDateKey");
  }
  uint64_t v2 = objc_autoreleasePoolPush();
  if (qword_100219F60) {
    objc_msgSend((id)qword_100219F60, "WFLog:message:", 3, "%s: null network", "WiFiNetworkGetLastHomeForceFixDate");
  }
  objc_autoreleasePoolPop(v2);
  return 0LL;
}

CFDictionaryRef sub_10009CEA8(uint64_t a1)
{
  char valuePtr = 0;
  uint64_t result = (const __CFDictionary *)CFDictionaryGetValue(*(CFDictionaryRef *)(a1 + 16), @"11U_INTERWORKING_IE");
  if (result)
  {
    uint64_t result = (const __CFDictionary *)CFDictionaryGetValue(result, @"INTERWORKING_ACCESS_NETWORK_TYPE");
    if (result)
    {
      CFNumberGetValue(result, kCFNumberSInt8Type, &valuePtr);
      return (valuePtr & 0xFE == 2);
    }
  }

  return result;
}

BOOL sub_10009CF04(uint64_t a1)
{
  return CFDictionaryGetValue(*(CFDictionaryRef *)(a1 + 16), @"IsHotspot") == kCFBooleanTrue
      || sub_100099810(a1)
      || sub_100095318(a1);
}

void sub_10009CF6C(uint64_t a1, __CFString *a2)
{
  value = kCFBooleanFalse;
  if (a2)
  {
    CFIndex v4 = (const __CFString *)CFDictionaryGetValue(*(CFDictionaryRef *)(a1 + 16), @"DomainName");
    if (v4)
    {
      uint64_t v5 = v4;
      CFStringAppend(a2, @"\nDomain name ");
      CFStringAppend(a2, v5);
    }

    int v6 = (const __CFArray *)CFDictionaryGetValue(*(CFDictionaryRef *)(a1 + 16), @"RoamingConsortiumOIs");
    if (v6)
    {
      uint64_t v7 = v6;
      CFIndex Count = CFArrayGetCount(v6);
      if (Count)
      {
        uint64_t v9 = Count;
        CFStringAppend(a2, @"\nRoaming Consortium OI ");
        if (v9 >= 1)
        {
          for (CFIndex i = 0LL; i != v9; ++i)
          {
            ValueAtIndex = (const __CFString *)CFArrayGetValueAtIndex(v7, i);
            CFStringAppend(a2, ValueAtIndex);
            CFStringAppend(a2, @" ");
          }
        }
      }
    }

    unsigned int v12 = (const __CFArray *)CFDictionaryGetValue(*(CFDictionaryRef *)(a1 + 16), @"NaiRealmName");
    if (v12)
    {
      int v13 = v12;
      CFIndex v14 = CFArrayGetCount(v12);
      if (v14)
      {
        uint64_t v15 = v14;
        CFStringAppend(a2, @"\nNAI Realm Name ");
        if (v15 >= 1)
        {
          for (CFIndex j = 0LL; j != v15; ++j)
          {
            unsigned int v17 = (const __CFString *)CFArrayGetValueAtIndex(v13, j);
            CFStringAppend(a2, v17);
            CFStringAppend(a2, @" ");
          }
        }
      }
    }

    int v18 = (const __CFArray *)CFDictionaryGetValue(*(CFDictionaryRef *)(a1 + 16), @"MCCandMNC");
    if (v18)
    {
      int v19 = v18;
      CFIndex v20 = CFArrayGetCount(v18);
      if (v20)
      {
        uint64_t v21 = v20;
        CFStringAppend(a2, @"\n3GPP MCC&MNC ");
        if (v21 >= 1)
        {
          for (CFIndex k = 0LL; k != v21; ++k)
          {
            int v23 = (const __CFString *)CFArrayGetValueAtIndex(v19, k);
            CFStringAppend(a2, v23);
            CFStringAppend(a2, @" ");
          }
        }
      }
    }

    BOOL v24 = (const __CFString *)CFDictionaryGetValue(*(CFDictionaryRef *)(a1 + 16), @"DisplayedOperatorName");
    if (v24)
    {
      int v25 = v24;
      CFStringAppend(a2, @"\nFriendly Operator Name ");
      CFStringAppend(a2, v25);
    }

    if (CFDictionaryGetValueIfPresent(*(CFDictionaryRef *)(a1 + 16), @"SPRoaming", (const void **)&value))
    {
      CFStringAppend(a2, @"\nRoaming set to: ");
      if (value) {
        int v26 = @"true";
      }
      else {
        int v26 = @"false";
      }
      CFStringAppend(a2, v26);
    }
  }

__CFDictionary *sub_10009D1EC(uint64_t a1)
{
  CFMutableArrayRef Mutable = CFDictionaryCreateMutable( kCFAllocatorDefault,  0LL,  &kCFTypeDictionaryKeyCallBacks,  &kCFTypeDictionaryValueCallBacks);
  if (Mutable)
  {
    CFBooleanRef Value = CFDictionaryGetValue(*(CFDictionaryRef *)(a1 + 16), @"DomainName");
    if (Value) {
      CFDictionaryAddValue(Mutable, @"DomainName", Value);
    }
    CFIndex v4 = CFDictionaryGetValue(*(CFDictionaryRef *)(a1 + 16), @"DisplayedOperatorName");
    if (v4) {
      CFDictionaryAddValue(Mutable, @"DisplayedOperatorName", v4);
    }
    uint64_t v5 = CFDictionaryGetValue(*(CFDictionaryRef *)(a1 + 16), @"RoamingConsortiumOIs");
    if (v5) {
      CFDictionaryAddValue(Mutable, @"RoamingConsortiumOIs", v5);
    }
    int v6 = CFDictionaryGetValue(*(CFDictionaryRef *)(a1 + 16), @"NaiRealmName");
    if (v6) {
      CFDictionaryAddValue(Mutable, @"NaiRealmName", v6);
    }
    uint64_t v7 = CFDictionaryGetValue(*(CFDictionaryRef *)(a1 + 16), @"MCCandMNC");
    if (v7) {
      CFDictionaryAddValue(Mutable, @"MCCandMNC", v7);
    }
  }

  return Mutable;
}

void sub_10009D31C(uint64_t a1, int a2)
{
  uint64_t v2 = (const void **)&kCFBooleanTrue;
  if (!a2) {
    uint64_t v2 = (const void **)&kCFBooleanFalse;
  }
  sub_10009582C(a1, @"HS20ProvisionedNetwork", *v2);
}

BOOL sub_10009D344(uint64_t a1)
{
  return sub_1000951FC(a1, @"HS20ProvisionedNetwork") == kCFBooleanTrue;
}

void sub_10009D374(uint64_t a1, int a2)
{
  uint64_t v2 = (const void **)&kCFBooleanTrue;
  if (!a2) {
    uint64_t v2 = (const void **)&kCFBooleanFalse;
  }
  sub_10009582C(a1, @"HS20HomeOperatorNetwork", *v2);
}

const void *sub_10009D39C(uint64_t a1)
{
  uint64_t result = sub_1000951FC(a1, @"HS2NetworkBadge");
  if (!result) {
    return sub_10009D3D8(a1);
  }
  return result;
}

const void *sub_10009D3D8(uint64_t a1)
{
  uint64_t v1 = (const __CFDictionary *)sub_1000951FC(a1, @"HS20GasResponse");
  if (v1
    && (CFBooleanRef Value = (const __CFArray *)CFDictionaryGetValue(v1, @"ANQP_OPERATOR_NAMES_LIST")) != 0LL
    && (CFTypeID v3 = Value, CFArrayGetCount(Value) >= 1)
    && (ValueAtIndex = (const __CFDictionary *)CFArrayGetValueAtIndex(v3, 0LL)) != 0LL)
  {
    return CFDictionaryGetValue(ValueAtIndex, @"ANQP_OPERATOR_NAME");
  }

  else
  {
    return 0LL;
  }

const void *sub_10009D448(uint64_t a1)
{
  return sub_1000951FC(a1, @"HS20GasResponse");
}

const void *sub_10009D454(uint64_t a1)
{
  uint64_t v2 = (const __CFDictionary *)sub_1000951FC(a1, @"HS20GasResponse");
  if (!v2) {
    return sub_1000951FC(a1, @"DomainName");
  }
  CFBooleanRef Value = (const __CFArray *)CFDictionaryGetValue(v2, @"ANQP_DOMAIN_NAME_LIST");
  if (Value && (CFIndex v4 = Value, CFArrayGetCount(Value) >= 1)) {
    return CFArrayGetValueAtIndex(v4, 0LL);
  }
  else {
    return 0LL;
  }
}

void sub_10009D4D4(uint64_t a1, const void *a2)
{
  if (sub_1000951FC(a1, @"HS20GasResponse")) {
    sub_10009582C(a1, @"HS20GasResponse", 0LL);
  }
  sub_10009582C(a1, @"HS20GasResponse", a2);
}

uint64_t sub_10009D528(const void *a1, const void *a2)
{
  uint64_t v2 = 0LL;
  if (a1 && a2)
  {
    CFIndex v4 = (const __CFDictionary *)sub_1000951FC((uint64_t)a1, @"HS20GasResponse");
    if (v4)
    {
      uint64_t v5 = v4;
      int v6 = sub_1000951FC((uint64_t)a2, @"DomainName");
      CFBooleanRef Value = (const __CFArray *)CFDictionaryGetValue(v5, @"ANQP_DOMAIN_NAME_LIST");
      if (Value && (int v8 = Value, CFArrayGetCount(Value) >= 1))
      {
        CFIndex v9 = 0LL;
        while (1)
        {
          ValueAtIndex = CFArrayGetValueAtIndex(v8, v9);
          if (ValueAtIndex)
          {
            if (v6)
            {
              BOOL v11 = ValueAtIndex;
              if (CFEqual(ValueAtIndex, v6)) {
                break;
              }
            }
          }

          if (++v9 >= CFArrayGetCount(v8)) {
            goto LABEL_11;
          }
        }

        uint64_t v27 = objc_autoreleasePoolPush();
        int v28 = (void *)qword_100219F60;
        if (qword_100219F60)
        {
          if (sub_100095318((BOOL)a1)) {
            uint64_t v29 = sub_10009D454((uint64_t)a1);
          }
          else {
            uint64_t v29 = sub_100095BC8(a1);
          }
          [v28 WFLog:3, "%s: found matching domain name %@ in GAS response from scannedNetwork, marking %@ provisioned", "WiFiNetworkIsScannedNetworkMatchingHS20Account", v11, v29 message];
        }

        objc_autoreleasePoolPop(v27);
        char v12 = 0;
        uint64_t v2 = 1LL;
      }

      else
      {
LABEL_11:
        uint64_t v2 = 0LL;
        char v12 = 1;
      }

      int v13 = (const __CFBoolean *)sub_1000951FC((uint64_t)a2, @"SPRoaming");
      CFIndex v14 = objc_autoreleasePoolPush();
      if (qword_100219F60)
      {
        if (v13 == kCFBooleanFalse) {
          uint64_t v15 = "%s: roaming is disabled for account %@";
        }
        else {
          uint64_t v15 = "%s: roaming is enabled for account %@";
        }
        [qword_100219F60 WFLog:@"WiFiNetworkIsScannedNetworkMatchingHS20Account" message:3 v15];
      }

      objc_autoreleasePoolPop(v14);
      BOOL v16 = (const __CFArray *)sub_1000951FC((uint64_t)a2, @"MCCandMNC");
      if (v16)
      {
        unsigned int v17 = v16;
        CFIndex Count = CFArrayGetCount(v16);
        char v19 = v12 ^ 1;
        if (Count < 1) {
          char v19 = 1;
        }
        if ((v19 & 1) == 0)
        {
          CFIndex v20 = 0LL;
          while (1)
          {
            uint64_t v21 = CFArrayGetValueAtIndex(v17, v20);
            if (v21)
            {
              CFComparisonResult v22 = v21;
              int v23 = objc_autoreleasePoolPush();
              if (qword_100219F60) {
                [(id)qword_100219F60 WFLog:3, "%s:%d found MCCMNC in account %@", "WiFiNetworkIsScannedNetworkMatchingHS20Account", 5627, v22 message];
              }
              objc_autoreleasePoolPop(v23);
              BOOL v24 = (const __CFArray *)CFDictionaryGetValue(v5, @"ANQP_CELL_NETWORK_INFO");
              if (v24)
              {
                int v25 = v24;
                int v26 = objc_autoreleasePoolPush();
                if (qword_100219F60) {
                  [(id)qword_100219F60 WFLog:3, "%s:%d found cellInfoArray count %ld %@", "WiFiNetworkIsScannedNetworkMatchingHS20Account", 5631, CFArrayGetCount(v25), v25 message];
                }
                objc_autoreleasePoolPop(v26);
                v61.length = CFArrayGetCount(v25);
                v61.location = 0LL;
                if (CFArrayContainsValue(v25, v61, v22)) {
                  break;
                }
              }
            }

            if (++v20 >= CFArrayGetCount(v17))
            {
              uint64_t v2 = 0LL;
              goto LABEL_37;
            }
          }

          CFNumberRef v30 = objc_autoreleasePoolPush();
          if (qword_100219F60) {
            [(id)qword_100219F60 WFLog:3, "%s: found response from 3GPP %@, marking %@ provisioned", "WiFiNetworkIsScannedNetworkMatchingHS20Account", v22, sub_100095BC8(a1) message];
          }
          objc_autoreleasePoolPop(v30);
          uint64_t v2 = 1LL;
        }
      }

LABEL_76:
              uint64_t v2 = 0LL;
            }

            int v56 = 1;
LABEL_78:
            CFIndex v57 = CFArrayGetCount(v47);
            if (v56)
            {
              if (++v49 < v57) {
                continue;
              }
            }

            return v2;
          }
        }
      }
    }

    else
    {
      return 0LL;
    }
  }

  return v2;
}

            goto LABEL_81;
          }

                                CFRelease(v11);
                                goto LABEL_77;
                              }

                              int v40 = NSPOSIXErrorDomain;
                              int v46 = NSLocalizedDescriptionKey;
                              int v47 = +[NSString stringWithFormat:]( &OBJC_CLASS___NSString,  "stringWithFormat:",  @"User join is in progress (count=%d)",  v24);
                              goto LABEL_118;
                            }

                            int v41 = NSPOSIXErrorDomain;
                            int v46 = NSLocalizedDescriptionKey;
                            BOOL v42 = @"Interface not up";
                          }

                          int v47 = v42;
                        }

                        else
                        {
                          int v41 = NSPOSIXErrorDomain;
                          int v46 = NSLocalizedDescriptionKey;
                          int v47 = +[NSString stringWithFormat:]( &OBJC_CLASS___NSString,  "stringWithFormat:",  @"Thermal index (%d) is below disabled threshold (%d)",  0LL,  0LL);
                        }

                        int v26 = +[NSDictionary dictionaryWithObjects:forKeys:count:]( &OBJC_CLASS___NSDictionary,  "dictionaryWithObjects:forKeys:count:",  &v47,  &v46,  1LL);
                        uint64_t v27 = v41;
                        int v28 = 1LL;
LABEL_81:
                        int v25 = +[NSError errorWithDomain:code:userInfo:]( &OBJC_CLASS___NSError,  "errorWithDomain:code:userInfo:",  v27,  v28,  v26);
                        uint64_t v5 = 0LL;
                        if (!v11) {
                          goto LABEL_77;
                        }
                        goto LABEL_76;
                      }

                      if ((a2 > 0x3A || ((1LL << a2) & 0x6F0048F1C000200LL) == 0)
                        && !CWFIsAutoJoinRetryTrigger(a2))
                      {
                        goto LABEL_153;
                      }

                      char v12 = objc_autoreleasePoolPush();
                      if (a2 == 28 && *(_BYTE *)(v5 + 6848) && *(void *)(v5 + 6928))
                      {
                        int v13 = objc_autoreleasePoolPush();
                        if (qword_100219F60) {
                          [qword_100219F60 WFLog:@"%s: Transition OK. Auto Hotspot Network recommendation" message:3];
                        }
LABEL_67:
                        objc_autoreleasePoolPop(v13);
                        goto LABEL_68;
                      }

                      if (!*(void *)(v5 + 3520))
                      {
                        CFIndex v20 = objc_autoreleasePoolPush();
                        if (qword_100219F60) {
                          [qword_100219F60 WFLog:@"__WiFiDeviceManagerUnifiedAutoJoinIsStateSuitableForNetworkTransition: no known networks"];
                        }
                        goto LABEL_151;
                      }

                      if (*(_DWORD *)(v5 + 20) != 1)
                      {
                        CFIndex v20 = objc_autoreleasePoolPush();
                        if (qword_100219F60) {
                          [qword_100219F60 WFLog:@"%s: wifi is off" message:3];
                        }
                        goto LABEL_151;
                      }

                      if (!*(_BYTE *)(v5 + 3403))
                      {
                        CFIndex v20 = objc_autoreleasePoolPush();
                        if (qword_100219F60) {
                          [qword_100219F60 WFLog:@"%s: not associated" message:3 v43];
                        }
                        goto LABEL_151;
                      }

                      if (sub_1000E0348(v5) && sub_1000DF3FC(v5))
                      {
                        CFIndex v20 = objc_autoreleasePoolPush();
                        if (qword_100219F60) {
                          [qword_100219F60 WFLog:@"%s: Active Ranging Session" message:3, "%s: Active Ranging Session", "__WiFiDeviceManagerUnifiedAutoJoinIsStateSuitableForNetworkTransition", v43];
                        }
                        goto LABEL_151;
                      }

                      if (*(_BYTE *)(v5 + 6616))
                      {
LABEL_46:
                        if (a2 - 56 > 0xFFFFFFFFFFFFFFFBLL)
                        {
LABEL_68:
                          objc_autoreleasePoolPop(v12);
                          goto LABEL_69;
                        }

                        if (*(_BYTE *)(v5 + 3400))
                        {
                          CFIndex v20 = objc_autoreleasePoolPush();
                          if (qword_100219F60) {
                            [qword_100219F60 WFLog:@"voip on going" message:3];
                          }
                        }

                        else if (*(_BYTE *)(v5 + 3401))
                        {
                          CFIndex v20 = objc_autoreleasePoolPush();
                          if (qword_100219F60) {
                            [qword_100219F60 WFLog:@"%s: call on going" message:3];
                          }
                        }

                        else if (*(_BYTE *)(v5 + 3402))
                        {
                          CFIndex v20 = objc_autoreleasePoolPush();
                          if (qword_100219F60) {
                            [qword_100219F60 WFLog:@"%s: media playing" message:3];
                          }
                        }

                        else if (*(_BYTE *)(v5 + 3406))
                        {
                          CFIndex v20 = objc_autoreleasePoolPush();
                          if (qword_100219F60) {
                            [qword_100219F60 WFLog:@"%s: Awdl RealTime is active" message:3 v43];
                          }
                        }

                        else
                        {
                          if (a2 == 32 || a2 == 47) {
                            goto LABEL_68;
                          }
                          if (*(_BYTE *)(v5 + 3404))
                          {
                            CFIndex v20 = objc_autoreleasePoolPush();
                            if (qword_100219F60) {
                              [qword_100219F60 WFLog:@"%s: on a moving network" message:3 v43];
                            }
                          }

                          else if (*(_BYTE *)(v5 + 5490))
                          {
                            CFIndex v20 = objc_autoreleasePoolPush();
                            if (qword_100219F60) {
                              [qword_100219F60 WFLog:@"Airplay over Infra is active"];
                            }
                          }

                          else if (*(_BYTE *)(v5 + 5488))
                          {
                            CFIndex v20 = objc_autoreleasePoolPush();
                            if (qword_100219F60) {
                              [qword_100219F60 WFLog:@"%s: in carplay" message:3 v43];
                            }
                          }

                          else if (*(int *)(v5 + 3384) >= 5)
                          {
                            CFIndex v20 = objc_autoreleasePoolPush();
                            if (qword_100219F60) {
                              [qword_100219F60 WFLog:@"%s: already tried enough times" message:3 v43];
                            }
                          }

                          else
                          {
                            double Current = CFAbsoluteTimeGetCurrent();
                            uint64_t v15 = *(double *)(v5 + 3392);
                            if (v15 == 0.0 || (BOOL v16 = Current - v15, v16 > 30.0))
                            {
                              unsigned int v17 = CFAbsoluteTimeGetCurrent();
                              int v18 = *(double *)(v5 + 3408);
                              if (v18 == 0.0) {
                                goto LABEL_68;
                              }
                              char v19 = v17 - v18;
                              if (v19 > 10.0) {
                                goto LABEL_68;
                              }
                              CFIndex v44 = v19;
                              CFIndex v20 = objc_autoreleasePoolPush();
                              if (qword_100219F60) {
                                [qword_100219F60 WFLog:@"%s: timeSinceLinkUp %f" message:3, "__WiFiDeviceManagerUnifiedAutoJoinIsStateSuitableForNetworkTransition", *(void *)&v44];
                              }
                            }

                            else
                            {
                              uint64_t v45 = v16;
                              CFIndex v20 = objc_autoreleasePoolPush();
                              if (qword_100219F60) {
                                [qword_100219F60 WFLog:@"%s: timeSinceLastScan %f" message:3, "__WiFiDeviceManagerUnifiedAutoJoinIsStateSuitableForNetworkTransition", *(void *)&v45];
                              }
                            }
                          }
                        }

                        goto LABEL_151;
                      }

                      if (*(_BYTE *)(v5 + 6600))
                      {
                        int v13 = objc_autoreleasePoolPush();
                        if (qword_100219F60) {
                          [qword_100219F60 WFLog:@"%s: Transition ok when its within colocated scope" message:3];
                        }
                        goto LABEL_67;
                      }

                      uint64_t v29 = (const void *)sub_10004CE2C(*(void *)(v5 + 64));
                      CFNumberRef v30 = sub_1000DEA34(v5, v29, 1);
                      CFComparisonResult v31 = v30;
                      if (a2 > 0x37 || ((1LL << a2) & 0xF0800100000000LL) == 0)
                      {
                        if (v30 && sub_100097700((uint64_t)v30))
                        {
LABEL_86:
                          CFRelease(v31);
LABEL_87:
                          if (a2 == 47
                            || a2 == 32
                            || a2 == 45
                            || (a2 & 0xFFFFFFFFFFFFFFFCLL) == 0x34
                            || *(_DWORD *)(v5 + 176) == 3)
                          {
                            goto LABEL_46;
                          }

                          CFIndex v20 = objc_autoreleasePoolPush();
                          if (qword_100219F60) {
                            [qword_100219F60 WFLog:@"__WiFiDeviceManagerUnifiedAutoJoinIsStateSuitableForNetworkTransition: display is on" message:3];
                          }
LABEL_151:
                          objc_autoreleasePoolPop(v20);
LABEL_152:
                          objc_autoreleasePoolPop(v12);
LABEL_153:
                          int v46 = NSLocalizedDescriptionKey;
                          int v47 = @"Already associated, and network transition not permitted";
                          int v25 = +[NSError errorWithDomain:code:userInfo:]( &OBJC_CLASS___NSError,  "errorWithDomain:code:userInfo:",  NSPOSIXErrorDomain,  37LL,  +[NSDictionary dictionaryWithObjects:forKeys:count:]( &OBJC_CLASS___NSDictionary,  "dictionaryWithObjects:forKeys:count:",  &v47,  &v46,  1LL));
                          uint64_t v5 = 0LL;
                          goto LABEL_76;
                        }

                        if (*(_BYTE *)(v5 + 3405))
                        {
                          unsigned int v32 = objc_autoreleasePoolPush();
                          if (qword_100219F60) {
                            [qword_100219F60 WFLog:@"%s: network switched by user" message:3];
                          }
                          objc_autoreleasePoolPop(v32);
                          if (v31) {
                            CFRelease(v31);
                          }
                          goto LABEL_152;
                        }
                      }

                      if (!v31) {
                        goto LABEL_87;
                      }
                      goto LABEL_86;
                    }

                    uint64_t v21 = NSPOSIXErrorDomain;
                    int v46 = NSLocalizedDescriptionKey;
                    CFComparisonResult v22 = @"Hosted AWDL session is active";
                  }

                  int v47 = v22;
                  int v26 = +[NSDictionary dictionaryWithObjects:forKeys:count:]( &OBJC_CLASS___NSDictionary,  "dictionaryWithObjects:forKeys:count:",  &v47,  &v46,  1LL);
                  uint64_t v27 = v21;
                  int v28 = 37LL;
                  goto LABEL_81;
                }

                uint64_t v38 = NSPOSIXErrorDomain;
                int v46 = NSLocalizedDescriptionKey;
                int v47 = +[NSString stringWithFormat:]( &OBJC_CLASS___NSString,  "stringWithFormat:",  @"MIS is enabled (wifi_count=%d, bt_count=%d, block_scan=%d, mis_disc_state=%d)",  *(unsigned __int8 *)(v5 + 5352),  *(unsigned __int8 *)(v5 + 5353),  *(unsigned __int8 *)(v5 + 5320),  *(unsigned __int8 *)(v5 + 5213));
                goto LABEL_111;
              }

              uint64_t v38 = NSPOSIXErrorDomain;
              int v46 = NSLocalizedDescriptionKey;
              CFIndex v39 = @"WiFi direct mode is enabled";
            }

            int v47 = v39;
LABEL_111:
            CFIndex v33 = +[NSDictionary dictionaryWithObjects:forKeys:count:]( &OBJC_CLASS___NSDictionary,  "dictionaryWithObjects:forKeys:count:",  &v47,  &v46,  1LL);
            CFIndex v34 = v38;
            CFNumberRef v35 = 37LL;
            goto LABEL_124;
          }

          int v46 = NSLocalizedDescriptionKey;
          int v47 = @"WiFi is OFF";
          CFIndex v33 = +[NSDictionary dictionaryWithObjects:forKeys:count:]( &OBJC_CLASS___NSDictionary,  "dictionaryWithObjects:forKeys:count:",  &v47,  &v46,  1LL);
          CFIndex v34 = NSPOSIXErrorDomain;
          CFNumberRef v35 = 82LL;
LABEL_124:
          int v25 = +[NSError errorWithDomain:code:userInfo:]( &OBJC_CLASS___NSError,  "errorWithDomain:code:userInfo:",  v34,  v35,  v33);
          uint64_t v5 = 0LL;
          goto LABEL_77;
        }

        BOOL v36 = NSPOSIXErrorDomain;
        int v46 = NSLocalizedDescriptionKey;
        uint64_t v37 = @"Auto-join is disabled by user (and not in priority link setup)";
      }

      else
      {
        BOOL v36 = NSPOSIXErrorDomain;
        int v46 = NSLocalizedDescriptionKey;
        uint64_t v37 = @"Auto-join is disabled";
      }

      int v47 = v37;
      CFIndex v33 = +[NSDictionary dictionaryWithObjects:forKeys:count:]( &OBJC_CLASS___NSDictionary,  "dictionaryWithObjects:forKeys:count:",  &v47,  &v46,  1LL);
      CFIndex v34 = v36;
      CFNumberRef v35 = 1LL;
      goto LABEL_124;
    }

    int v46 = NSLocalizedDescriptionKey;
    int v47 = @"No auto-join manager configured";
    CFIndex v33 = +[NSDictionary dictionaryWithObjects:forKeys:count:]( &OBJC_CLASS___NSDictionary,  "dictionaryWithObjects:forKeys:count:",  &v47,  &v46,  1LL);
    CFIndex v34 = NSPOSIXErrorDomain;
    CFNumberRef v35 = 6LL;
    goto LABEL_124;
  }

CFDictionaryRef *sub_10009DBF8(CFDictionaryRef *result)
{
  __int16 valuePtr = 0;
  __int16 v3 = 0;
  if (result)
  {
    uint64_t v1 = result;
    uint64_t result = (CFDictionaryRef *)CFDictionaryGetValue(result[2], @"EXT_CAPS");
    if (result)
    {
      uint64_t result = (CFDictionaryRef *)CFDictionaryGetValue((CFDictionaryRef)result, @"BSS_TRANS_MGMT");
      if (result)
      {
        CFNumberGetValue((CFNumberRef)result, kCFNumberSInt8Type, &valuePtr);
        if ((_BYTE)valuePtr)
        {
          uint64_t result = (CFDictionaryRef *)CFDictionaryGetValue(v1[2], @"QBSS_LOAD_IE");
          if (result)
          {
            uint64_t v2 = (const __CFDictionary *)result;
            uint64_t result = (CFDictionaryRef *)CFDictionaryGetValue((CFDictionaryRef)result, @"QBSS_CHAN_UTIL");
            if (result)
            {
              CFNumberGetValue((CFNumberRef)result, kCFNumberSInt8Type, (char *)&valuePtr + 1);
              uint64_t result = (CFDictionaryRef *)CFDictionaryGetValue(v2, @"QBSS_STA_COUNT");
              if (result)
              {
                CFNumberGetValue((CFNumberRef)result, kCFNumberSInt16Type, &v3);
                return (CFDictionaryRef *)(v3 == -1);
              }
            }
          }
        }

        else
        {
          return 0LL;
        }
      }
    }
  }

  return result;
}

void sub_10009DCC8(const void *a1, const void *a2)
{
  if (!a1)
  {
    int v6 = objc_autoreleasePoolPush();
    if (qword_100219F60) {
      [qword_100219F60 WFLog:@"%s: null network" message:3];
    }
    goto LABEL_11;
  }

  if (!a2)
  {
    int v6 = objc_autoreleasePoolPush();
    if (qword_100219F60) {
      [qword_100219F60 WFLog:@"%s: null modDate" message:3];
    }
LABEL_11:
    uint64_t v7 = v6;
LABEL_15:
    objc_autoreleasePoolPop(v7);
    return;
  }

  CFIndex v4 = sub_100095BC8(a1);
  uint64_t v5 = objc_autoreleasePoolPush();
  if (!v4)
  {
    if (qword_100219F60) {
      [qword_100219F60 WFLog:@"%s: null ssid" message:3];
    }
    uint64_t v7 = v5;
    goto LABEL_15;
  }

  if (qword_100219F60) {
    [(id)qword_100219F60 WFLog:3, "%s: for network <%@>, modDate %@", "WiFiNetworkSetPasswordModificationDate", v4, a2 message];
  }
  objc_autoreleasePoolPop(v5);
  sub_10009582C((uint64_t)a1, @"WiFiNetworkPasswordModificationDate", a2);
}

const void *sub_10009DE04(uint64_t a1)
{
  if (a1) {
    return sub_1000951FC(a1, @"WiFiNetworkPasswordModificationDate");
  }
  uint64_t v2 = objc_autoreleasePoolPush();
  if (qword_100219F60) {
    [qword_100219F60 WFLog:@"%s: null network" message:3];
  }
  objc_autoreleasePoolPop(v2);
  return 0LL;
}

CFTypeRef sub_10009DE84(const void *a1)
{
  if (a1)
  {
    uint64_t v1 = sub_100095CB0(a1);
    return sub_1000ACD84(v1);
  }

  else
  {
    __int16 v3 = objc_autoreleasePoolPush();
    if (qword_100219F60) {
      [qword_100219F60 WFLog:@"%s: null network" message:3];
    }
    objc_autoreleasePoolPop(v3);
    return 0LL;
  }

CFDictionaryRef sub_10009DEFC(uint64_t a1)
{
  uint64_t result = (const __CFDictionary *)CFDictionaryGetValue(*(CFDictionaryRef *)(a1 + 16), @"APPLE_DEVICE_IE");
  if (result)
  {
    CFBooleanRef Value = (CFBooleanRef)CFDictionaryGetValue(result, @"APPLE_DEVICE_IE_FEATURE_SUPPORTS_CARPLAY");
    return Value && Value == kCFBooleanTrue;
  }

  return result;
}

uint64_t sub_10009DF44(uint64_t a1)
{
  if (!a1)
  {
    CFIndex v9 = objc_autoreleasePoolPush();
    if (qword_100219F60) {
      [qword_100219F60 WFLog:@"%s: null network" message:3];
    }
    goto LABEL_20;
  }

  uint64_t v2 = *(const __CFDictionary **)(a1 + 16);
  if (!v2)
  {
    CFIndex v9 = objc_autoreleasePoolPush();
    if (qword_100219F60) {
      [qword_100219F60 WFLog:@"%s: null network record" message:3];
    }
LABEL_20:
    objc_autoreleasePoolPop(v9);
    return 0LL;
  }

  CFBooleanRef Value = (const __CFDictionary *)CFDictionaryGetValue(v2, @"APPLE_DEVICE_IE");
  if (Value)
  {
    CFBooleanRef v4 = (CFBooleanRef)CFDictionaryGetValue(Value, @"APPLE_DEVICE_IE_FEATURE_SUPPORTS_CARPLAY");
    if (v4) {
      BOOL v5 = v4 == kCFBooleanTrue;
    }
    else {
      BOOL v5 = 0;
    }
    uint64_t v6 = v5;
  }

  else
  {
    uint64_t v6 = 0LL;
  }

  uint64_t v7 = CFDictionaryGetValue(*(CFDictionaryRef *)(a1 + 16), @"CARPLAY_NETWORK");
  if (v7)
  {
    if (CFEqual(v7, kCFBooleanTrue)) {
      return 1LL;
    }
    else {
      return v6;
    }
  }

  return v6;
}

BOOL sub_10009E054(uint64_t a1)
{
  uint64_t v2 = (const __CFNumber *)sub_1000951FC(a1, @"CHANNEL");
  unsigned int v7 = -1431655766;
  __int16 v3 = (const __CFNumber *)sub_1000951FC(a1, @"CHANNEL_FLAGS");
  if (v3)
  {
    unsigned int valuePtr = 0;
    CFNumberGetValue(v3, kCFNumberIntType, &valuePtr);
    return (valuePtr >> 3) & 1;
  }

  else
  {
    CFNumberGetValue(v2, kCFNumberSInt32Type, &v7);
    BOOL v5 = objc_autoreleasePoolPush();
    if (qword_100219F60) {
      [qword_100219F60 WFLog:@"%s : Current channel %d\n" message:@"WiFiNetworkIs24GHzNetwork" v7];
    }
    objc_autoreleasePoolPop(v5);
    return v7 - 1 < 0xE;
  }

uint64_t sub_10009E120(uint64_t a1)
{
  uint64_t v2 = sub_1000951FC(a1, @"CARPLAY_NETWORK");
  if (v2 && CFEqual(v2, kCFBooleanTrue))
  {
    if (sub_1000951FC(a1, @"lastJoined")
      || a1 && CFDictionaryContainsKey(*(CFDictionaryRef *)(a1 + 16), @"PayloadUUID"))
    {
      unsigned int v3 = 2;
    }

    else
    {
      unsigned int v3 = 1;
    }
  }

  else
  {
    unsigned int v3 = 0;
  }

  if (sub_100095318(a1)) {
    return 3LL;
  }
  else {
    return v3;
  }
}

CFIndex sub_10009E1B8(CFIndex result)
{
  if (result)
  {
    uint64_t v1 = (const __CFArray *)result;
    uint64_t result = CFArrayGetCount((CFArrayRef)result);
    if (result >= 1)
    {
      for (CFIndex i = 0LL; i < result; ++i)
      {
        ValueAtIndex = CFArrayGetValueAtIndex(v1, i);
        if (ValueAtIndex)
        {
          CFBooleanRef v4 = ValueAtIndex;
          BOOL v5 = objc_autoreleasePoolPush();
          if (qword_100219F60) {
            [(id)qword_100219F60 WFLog:3, "%@", v4[2] message];
          }
          objc_autoreleasePoolPop(v5);
        }

        uint64_t result = CFArrayGetCount(v1);
      }
    }
  }

  return result;
}

void sub_10009E264(uint64_t a1)
{
}

const void *sub_10009E2A0(uint64_t a1, const __CFString *a2)
{
  uint64_t v15 = 0LL;
  if (!a1)
  {
    CFIndex v14 = objc_autoreleasePoolPush();
    if (qword_100219F60) {
      objc_msgSend((id)qword_100219F60, "WFLog:message:", 3, "%s: null network", "WiFiNetworkCopyLeakyStatus");
    }
    goto LABEL_28;
  }

  if (!a2)
  {
    CFIndex v14 = objc_autoreleasePoolPush();
    if (qword_100219F60) {
      [qword_100219F60 WFLog:@"%s: null bssid" message:3];
    }
    goto LABEL_28;
  }

  CFBooleanRef v4 = (const __CFString *)sub_1000951FC(a1, @"BSSID");
  if (!v4)
  {
    CFIndex v14 = objc_autoreleasePoolPush();
    if (qword_100219F60) {
      [qword_100219F60 WFLog:@"%s: null bssidFromNetwork" message:3];
    }
    goto LABEL_28;
  }

  if (CFStringCompare(a2, v4, 0LL) == kCFCompareEqualTo)
  {
    uint64_t result = sub_1000951FC(a1, @"LEAKY_AP_LEARNED_DATA");
    if (!result) {
      return result;
    }
    goto LABEL_14;
  }

  BOOL v5 = (const __CFArray *)sub_1000951FC(a1, @"networkKnownBSSListKey");
  if (!v5)
  {
    CFIndex v14 = objc_autoreleasePoolPush();
    if (qword_100219F60) {
      [qword_100219F60 WFLog:@"%s: null knownBssids" message:3];
    }
    goto LABEL_28;
  }

  uint64_t v6 = v5;
  CFIndex Count = CFArrayGetCount(v5);
  if (!Count)
  {
    CFIndex v14 = objc_autoreleasePoolPush();
    if (qword_100219F60) {
      [qword_100219F60 WFLog:@"%s: no knownBssids" message:3];
    }
LABEL_28:
    objc_autoreleasePoolPop(v14);
    return 0LL;
  }

  CFIndex v8 = Count;
  if (Count < 1) {
    return 0LL;
  }
  CFIndex v9 = 0LL;
  while (1)
  {
    ValueAtIndex = (const __CFDictionary *)CFArrayGetValueAtIndex(v6, v9);
    if (ValueAtIndex)
    {
      BOOL v11 = ValueAtIndex;
      CFBooleanRef Value = (const __CFString *)CFDictionaryGetValue(ValueAtIndex, @"BSSID");
      if (CFStringCompare(a2, Value, 0LL) == kCFCompareEqualTo) {
        break;
      }
    }

    if (v8 == ++v9) {
      return 0LL;
    }
  }

  uint64_t result = CFDictionaryGetValue(v11, @"LEAKY_AP_LEARNED_DATA");
  if (result)
  {
LABEL_14:
    Apple80211CopyLeakyAPStatus(result, &v15);
    return (const void *)v15;
  }

  return result;
}

BOOL sub_10009E4BC(uint64_t a1, const __CFString *a2)
{
  uint64_t v2 = (const __CFNumber *)sub_10009E2A0(a1, a2);
  if (v2)
  {
    unsigned int v3 = v2;
    char valuePtr = -86;
    CFNumberGetValue(v2, kCFNumberSInt8Type, &valuePtr);
    BOOL v4 = valuePtr == 2;
    CFRelease(v3);
  }

  else
  {
    uint64_t v6 = objc_autoreleasePoolPush();
    if (qword_100219F60) {
      [qword_100219F60 WFLog:@"null leaky number" message:3];
    }
    objc_autoreleasePoolPop(v6);
    return 0LL;
  }

  return v4;
}

CFDictionaryRef sub_10009E558(uint64_t a1)
{
  uint64_t result = (const __CFDictionary *)sub_1000951FC(a1, @"11U_INTERWORKING_IE");
  if (result)
  {
    uint64_t result = (const __CFDictionary *)CFDictionaryGetValue(result, @"INTERWORKING_ACCESS_NETWORK_TYPE");
    if (result)
    {
      char valuePtr = 0;
      CFNumberGetValue(result, kCFNumberSInt8Type, &valuePtr);
      return valuePtr == 2;
    }
  }

  return result;
}

BOOL sub_10009E5AC(uint64_t a1)
{
  if (sub_100095318(a1)
    || &_CNForgetSSID
    && CFDictionaryGetValue(*(CFDictionaryRef *)(a1 + 16), kCNSCaptiveNetworkProperty) == kCFBooleanTrue)
  {
    unsigned int v2 = sub_10009E558(a1);
  }

  else
  {
    unsigned int v2 = 0;
  }

  return sub_100097700(a1) || sub_10009DF44(a1) || v2;
}

uint64_t sub_10009E640(uint64_t a1)
{
  int valuePtr = 0;
  unsigned int v2 = (const __CFNumber *)sub_1000951FC(a1, @"SaveDataMode");
  if (v2)
  {
    CFNumberGetValue(v2, kCFNumberSInt32Type, &valuePtr);
    BOOL v3 = valuePtr == 1;
    if (valuePtr) {
      return v3;
    }
  }

  else
  {
    BOOL v3 = 0LL;
  }

  return v3;
}

CFNumberRef sub_10009E6CC(uint64_t a1)
{
  unsigned int valuePtr = 0;
  uint64_t result = (const __CFNumber *)sub_1000951FC(a1, @"SaveDataMode");
  if (result)
  {
    CFNumberGetValue(result, kCFNumberSInt32Type, &valuePtr);
    return (const __CFNumber *)valuePtr;
  }

  return result;
}

double sub_10009E70C(uint64_t a1)
{
  double valuePtr = 0.0;
  uint64_t v1 = (const __CFNumber *)sub_1000951FC(a1, @"NetworkQualityResponsiveness");
  if (v1) {
    CFNumberGetValue(v1, kCFNumberDoubleType, &valuePtr);
  }
  unsigned int v2 = objc_autoreleasePoolPush();
  if (qword_100219F60) {
    [qword_100219F60 WFLog:@"%s: retrieved %.3f" message:3, "WiFiNetworkGetNetworkQualityResponsiveness", *(void *)&valuePtr];
  }
  objc_autoreleasePoolPop(v2);
  return valuePtr;
}

const void *sub_10009E798(uint64_t a1)
{
  uint64_t v1 = sub_1000951FC(a1, @"NetworkQualityDate");
  unsigned int v2 = objc_autoreleasePoolPush();
  if (qword_100219F60) {
    [(id)qword_100219F60 WFLog:3, "%s: retrieved %@", "WiFiNetworkGetNetworkQualityDate", v1 message];
  }
  objc_autoreleasePoolPop(v2);
  return v1;
}

void sub_10009E80C(const void *a1, const void *a2, double a3)
{
  double valuePtr = a3;
  uint64_t v6 = objc_autoreleasePoolPush();
  if (qword_100219F60) {
    [(id)qword_100219F60 WFLog:3, "%s: %@, %.3f %@", "WiFiNetworkSetNetworkQuality", sub_100095BC8(a1), *(void *)&a3, a2 message];
  }
  objc_autoreleasePoolPop(v6);
  CFNumberRef v7 = CFNumberCreate(kCFAllocatorDefault, kCFNumberDoubleType, &valuePtr);
  if (v7)
  {
    CFNumberRef v8 = v7;
    sub_10009582C((uint64_t)a1, @"NetworkQualityResponsiveness", v7);
    sub_10009582C((uint64_t)a1, @"NetworkQualityDate", a2);
    CFRelease(v8);
  }

  else
  {
    CFIndex v9 = objc_autoreleasePoolPush();
    if (qword_100219F60) {
      [qword_100219F60 WFLog:@"CFNumberCreate failed" message:4];
    }
    objc_autoreleasePoolPop(v9);
  }

void sub_10009E934(const void *a1, unsigned int a2)
{
  BOOL v4 = objc_autoreleasePoolPush();
  if (a1)
  {
    if (qword_100219F60) {
      [(id)qword_100219F60 WFLog:3, "%s: %@, %d", "WiFiNetworkDisableAutoJoinUntilFirstUserJoin", sub_100095BC8(a1), a2 message];
    }
    objc_autoreleasePoolPop(v4);
    BOOL v5 = (const void **)&kCFBooleanTrue;
    if (!a2) {
      BOOL v5 = (const void **)&kCFBooleanFalse;
    }
    sub_10009582C((uint64_t)a1, @"DisableWiFiAutoJoinUntilFirstUserJoin", *v5);
  }

  else
  {
    if (qword_100219F60) {
      [qword_100219F60 WFLog:@"%s: null network" message:3];
    }
    objc_autoreleasePoolPop(v4);
  }

uint64_t sub_10009EA20(uint64_t a1)
{
  if (!a1)
  {
    BOOL v5 = objc_autoreleasePoolPush();
    if (qword_100219F60) {
      [qword_100219F60 WFLog:@"%s: null network" message:3];
    }
LABEL_9:
    objc_autoreleasePoolPop(v5);
    return 0LL;
  }

  uint64_t v1 = (const __CFBoolean *)sub_1000951FC(a1, @"DisableWiFiAutoJoinUntilFirstUserJoin");
  if (v1)
  {
    unsigned int v2 = v1;
    CFTypeID v3 = CFGetTypeID(v1);
    if (v3 == CFBooleanGetTypeID()) {
      return CFBooleanGetValue(v2);
    }
    BOOL v5 = objc_autoreleasePoolPush();
    if (qword_100219F60) {
      [qword_100219F60 WFLog:@"WiFiNetworkIsAutoJoinDisabledUntilFirstUserJoin: invalid value type"];
    }
    goto LABEL_9;
  }

  return 0LL;
}

CFBooleanRef sub_10009EAF4(const __CFDictionary **a1)
{
  if (!a1)
  {
    BOOL v5 = objc_autoreleasePoolPush();
    if (qword_100219F60) {
      [qword_100219F60 WFLog:@"%s: null network" message:3];
    }
    goto LABEL_12;
  }

  uint64_t result = (const __CFBoolean *)sub_1000951FC((uint64_t)a1, @"WiFiNetworkAttributeIsPublic");
  if (!result) {
    return result;
  }
  CFTypeID v3 = result;
  CFTypeID v4 = CFGetTypeID(result);
  if (v4 != CFBooleanGetTypeID())
  {
    BOOL v5 = objc_autoreleasePoolPush();
    if (qword_100219F60) {
      [qword_100219F60 WFLog:@"WiFiNetworkIsInfrequentlyJoinedPublicNetwork: invalid value type"];
    }
LABEL_12:
    objc_autoreleasePoolPop(v5);
    return 0LL;
  }

  uint64_t result = (const __CFBoolean *)CFBooleanGetValue(v3);
  if ((_DWORD)result) {
    return (const __CFBoolean *)(sub_10009A2E0(a1) > 1209600.0);
  }
  return result;
}

BOOL sub_10009EBF8(uint64_t a1)
{
  CFBooleanRef v1 = (CFBooleanRef)sub_1000951FC(a1, @"CaptiveBypass");
  return v1 && v1 == kCFBooleanTrue;
}

void sub_10009EC30(uint64_t a1, const void *a2)
{
  if (a1)
  {
    sub_10009582C(a1, @"BundleIdentifier", a2);
  }

  else
  {
    unsigned int v2 = objc_autoreleasePoolPush();
    if (qword_100219F60) {
      [qword_100219F60 WFLog:@"%s: null network" message:3];
    }
    objc_autoreleasePoolPop(v2);
  }

const void *sub_10009ECAC(uint64_t a1)
{
  if (a1) {
    return sub_1000951FC(a1, @"BundleIdentifier");
  }
  unsigned int v2 = objc_autoreleasePoolPush();
  if (qword_100219F60) {
    objc_msgSend((id)qword_100219F60, "WFLog:message:", 3, "%s: null network", "WiFiNetworkGetBundleIdentifier");
  }
  objc_autoreleasePoolPop(v2);
  return 0LL;
}

void sub_10009ED2C(uint64_t a1, unsigned int a2)
{
  if (a1)
  {
    sub_1000970C0(a1, @"NetworkOriginator", a2);
  }

  else
  {
    unsigned int v2 = objc_autoreleasePoolPush();
    if (qword_100219F60) {
      [qword_100219F60 WFLog:@"%s: null network" message:3];
    }
    objc_autoreleasePoolPop(v2);
  }

void sub_10009EDAC(uint64_t a1, const void *a2)
{
  if (a1)
  {
    sub_10009582C(a1, @"NetworkOriginatorName", a2);
  }

  else
  {
    unsigned int v2 = objc_autoreleasePoolPush();
    if (qword_100219F60) {
      [qword_100219F60 WFLog:@"%s: null network" message:3];
    }
    objc_autoreleasePoolPop(v2);
  }

CFNumberRef sub_10009EE28(uint64_t a1)
{
  if (a1)
  {
    CFBooleanRef v1 = (const __CFNumber *)sub_1000951FC(a1, @"NetworkOriginator");
    return sub_10003AC9C(v1);
  }

  else
  {
    CFTypeID v3 = objc_autoreleasePoolPush();
    if (qword_100219F60) {
      objc_msgSend((id)qword_100219F60, "WFLog:message:", 3, "%s: null network", "WiFiNetworkGetOriginator");
    }
    objc_autoreleasePoolPop(v3);
    return 0LL;
  }

uint64_t sub_10009EEA4(uint64_t a1)
{
  uint64_t v1 = 1LL;
  unsigned int valuePtr = 1;
  unsigned int v2 = (const __CFNumber *)sub_1000951FC(a1, @"UserRole");
  if (v2)
  {
    CFNumberGetValue(v2, kCFNumberIntType, &valuePtr);
    return valuePtr;
  }

  return v1;
}

uint64_t sub_10009EEF4(const __CFArray *a1, uint64_t a2)
{
  CFIndex v2 = -1LL;
  if (a1 && a2 && CFArrayGetCount(a1) >= 1)
  {
    CFIndex v2 = 0LL;
    while (1)
    {
      ValueAtIndex = (CFTypeRef *)CFArrayGetValueAtIndex(a1, v2);
      if (ValueAtIndex)
      {
        uint64_t v6 = ValueAtIndex;
        CFTypeID v7 = CFGetTypeID(ValueAtIndex);
        uint64_t v8 = qword_100219950;
        if (!qword_100219950)
        {
          pthread_once(&stru_100219020, (void (*)(void))sub_1000949D8);
          uint64_t v8 = qword_100219950;
        }
      }

      if (++v2 >= CFArrayGetCount(a1)) {
        return -1LL;
      }
    }
  }

  return v2;
}

BOOL sub_10009EFD8(uint64_t a1)
{
  if (a1)
  {
    uint64_t v1 = (const __CFNumber *)sub_1000951FC(a1, @"NetworkOriginator");
    return sub_10003AC9C(v1) == 2;
  }

  else
  {
    CFTypeID v3 = objc_autoreleasePoolPush();
    if (qword_100219F60) {
      [qword_100219F60 WFLog:@"%s: null network" message:3];
    }
    objc_autoreleasePoolPop(v3);
    return 0LL;
  }

const void *sub_10009F05C(uint64_t a1)
{
  if (a1) {
    return sub_1000951FC(a1, @"WiFiNetworkDisabledUntilDate");
  }
  CFIndex v2 = objc_autoreleasePoolPush();
  if (qword_100219F60) {
    [qword_100219F60 WFLog:@"%s: null network" message:3];
  }
  objc_autoreleasePoolPop(v2);
  return 0LL;
}

CFArrayRef sub_10009F0DC(const void *a1)
{
  if (!a1)
  {
    CFTypeID v7 = objc_autoreleasePoolPush();
    if (qword_100219F60) {
      objc_msgSend((id)qword_100219F60, "WFLog:message:", 3, "%s: null network", "WiFiNetworkCanExposeIMSI");
    }
    goto LABEL_17;
  }

  if (!sub_100098574((uint64_t)a1, 18) && !sub_100098574((uint64_t)a1, 23))
  {
    uint64_t result = sub_100098574((uint64_t)a1, 50);
    if (!(_DWORD)result) {
      return result;
    }
  }

  CFTypeID v3 = (const __CFDictionary *)sub_1000951FC((uint64_t)a1, @"EnterpriseProfile");
  if (!v3)
  {
    uint64_t v8 = objc_autoreleasePoolPush();
    if (qword_100219F60) {
      [(id)qword_100219F60 WFLog:3, "%s: no eapProfile for %@", "WiFiNetworkCanExposeIMSI", sub_100095BC8(a1) message];
    }
    CFIndex v9 = v8;
    goto LABEL_18;
  }

  CFBooleanRef Value = CFDictionaryGetValue(v3, @"EAPClientConfiguration");
  CFTypeID v5 = CFGetTypeID(Value);
  if (v5 != CFDictionaryGetTypeID())
  {
    CFTypeID v7 = objc_autoreleasePoolPush();
    if (qword_100219F60) {
      [qword_100219F60 WFLog:@"WiFiNetworkCanExposeIMSI: invalid EAP client configuration"];
    }
LABEL_17:
    CFIndex v9 = v7;
LABEL_18:
    objc_autoreleasePoolPop(v9);
    return 0LL;
  }

  if (CFDictionaryContainsKey((CFDictionaryRef)Value, @"EAPSIMAKAEncryptedIdentityEnabled"))
  {
    uint64_t v6 = (const __CFNumber *)CFDictionaryGetValue((CFDictionaryRef)Value, @"EAPSIMAKAEncryptedIdentityEnabled");
    return (const __CFArray *)(sub_10003AC9C(v6) == 0LL);
  }

  else
  {
    int v10 = objc_autoreleasePoolPush();
    if (qword_100219F60) {
      [qword_100219F60 WFLog:@"%s: missing encrypted identity key" message:3];
    }
    objc_autoreleasePoolPop(v10);
    return (const __CFArray *)1;
  }

void sub_10009F2A4(uint64_t a1)
{
  if (a1)
  {
    if (CFDictionaryContainsKey(*(CFDictionaryRef *)(a1 + 16), @"enabled")) {
      CFDictionaryRemoveValue(*(CFMutableDictionaryRef *)(a1 + 16), @"enabled");
    }
    if (CFDictionaryContainsKey(*(CFDictionaryRef *)(a1 + 16), @"lastAutoJoined")) {
      CFDictionaryRemoveValue(*(CFMutableDictionaryRef *)(a1 + 16), @"lastAutoJoined");
    }
    if (CFDictionaryContainsKey(*(CFDictionaryRef *)(a1 + 16), @"lastJoined")) {
      CFDictionaryRemoveValue(*(CFMutableDictionaryRef *)(a1 + 16), @"lastJoined");
    }
    if (CFDictionaryContainsKey(*(CFDictionaryRef *)(a1 + 16), @"prevJoined")) {
      CFDictionaryRemoveValue(*(CFMutableDictionaryRef *)(a1 + 16), @"prevJoined");
    }
    if (CFDictionaryContainsKey(*(CFDictionaryRef *)(a1 + 16), @"lastRoamed")) {
      CFDictionaryRemoveValue(*(CFMutableDictionaryRef *)(a1 + 16), @"lastRoamed");
    }
  }

  else
  {
    CFIndex v2 = objc_autoreleasePoolPush();
    if (qword_100219F60) {
      [qword_100219F60 WFLog:@"%s: null network" message:3];
    }
    objc_autoreleasePoolPop(v2);
  }

CFDictionaryRef *sub_10009F3D4(CFDictionaryRef *result)
{
  char valuePtr = -1;
  if (result)
  {
    uint64_t result = (CFDictionaryRef *)CFDictionaryGetValue(result[2], @"11U_INTERWORKING_IE");
    if (result)
    {
      uint64_t result = (CFDictionaryRef *)CFDictionaryGetValue( (CFDictionaryRef)result,  @"INTERWORKING_ACCESS_VENTURE_GRP");
      if (result)
      {
        CFNumberGetValue((CFNumberRef)result, kCFNumberSInt8Type, &valuePtr);
        return (CFDictionaryRef *)(valuePtr == 11);
      }
    }
  }

  return result;
}

CFDictionaryRef *sub_10009F434(CFDictionaryRef *result)
{
  char valuePtr = -1;
  if (result)
  {
    uint64_t result = (CFDictionaryRef *)CFDictionaryGetValue(result[2], @"11U_INTERWORKING_IE");
    if (result)
    {
      uint64_t result = (CFDictionaryRef *)CFDictionaryGetValue( (CFDictionaryRef)result,  @"INTERWORKING_ACCESS_VENTURE_GRP");
      if (result)
      {
        CFNumberGetValue((CFNumberRef)result, kCFNumberSInt8Type, &valuePtr);
        return (CFDictionaryRef *)(valuePtr == 10);
      }
    }
  }

  return result;
}

CFDictionaryRef sub_10009F494(uint64_t a1)
{
  char valuePtr = -1;
  uint64_t result = (const __CFDictionary *)CFDictionaryGetValue(*(CFDictionaryRef *)(a1 + 16), @"11U_INTERWORKING_IE");
  if (result)
  {
    uint64_t result = (const __CFDictionary *)CFDictionaryGetValue(result, @"INTERWORKING_ACCESS_NETWORK_TYPE");
    if (result)
    {
      CFNumberGetValue(result, kCFNumberSInt8Type, &valuePtr);
      char v2 = valuePtr + 1;
      if ((valuePtr + 1) < 0x13u && ((0x6007Fu >> v2) & 1) != 0)
      {
        return (const __CFDictionary *)dword_10017F970[v2];
      }

      else
      {
        CFTypeID v3 = objc_autoreleasePoolPush();
        if (qword_100219F60) {
          [qword_100219F60 WFLog:@"message:%s unhandled type trying to convert from apple8021_access_network_t -> WiFiAdvertisedNetworkType" message:@"WiFiNetworkGetAdvertisedNetworkType"];
        }
        objc_autoreleasePoolPop(v3);
        return 0LL;
      }
    }
  }

  return result;
}

uint64_t sub_10009F564(CFDictionaryRef *a1, void *a2)
{
  uint64_t v13 = 0LL;
  CFTypeID v4 = objc_autoreleasePoolPush();
  if (qword_100219F60) {
    [(id)qword_100219F60 WFLog:3, "%s: network %@ path %@", "WiFiNetworkArchiveToPath", sub_100095BC8(a1), a2, v13 message];
  }
  objc_autoreleasePoolPop(v4);
  id v5 = [a2 stringByDeletingLastPathComponent];
  if (-[NSFileManager fileExistsAtPath:]( +[NSFileManager defaultManager](&OBJC_CLASS___NSFileManager, "defaultManager"),  "fileExistsAtPath:",  v5)
    || -[NSFileManager createDirectoryAtPath:withIntermediateDirectories:attributes:error:]( +[NSFileManager defaultManager](&OBJC_CLASS___NSFileManager, "defaultManager"),  "createDirectoryAtPath:withIntermediateDirectories:attributes:error:",  v5,  0LL,  0LL,  &v13))
  {
    CFDictionaryRef Copy = CFDictionaryCreateCopy(kCFAllocatorDefault, a1[2]);
    CFTypeID v7 = +[NSPropertyListSerialization dataWithPropertyList:format:options:error:]( &OBJC_CLASS___NSPropertyListSerialization,  "dataWithPropertyList:format:options:error:",  Copy,  200LL,  0LL,  0LL);
    if (v7)
    {
      if (-[NSFileManager createFileAtPath:contents:attributes:]( +[NSFileManager defaultManager](&OBJC_CLASS___NSFileManager, "defaultManager"),  "createFileAtPath:contents:attributes:",  a2,  v7,  0LL))
      {
        uint64_t v8 = 1LL;
        if (!Copy) {
          return v8;
        }
        goto LABEL_17;
      }

      CFIndex v9 = objc_autoreleasePoolPush();
      if (qword_100219F60) {
        [(id)qword_100219F60 WFLog:4, "%s: unable to archive network dictionary in %@", "WiFiNetworkArchiveToPath", a2 message];
      }
    }

    else
    {
      CFIndex v9 = objc_autoreleasePoolPush();
      if (qword_100219F60) {
        [qword_100219F60 WFLog:@"%s: unable to archive network dictionary" message:4];
      }
    }

    objc_autoreleasePoolPop(v9);
    uint64_t v8 = 0LL;
    if (Copy) {
LABEL_17:
    }
      CFRelease(Copy);
  }

  else
  {
    int v10 = objc_autoreleasePoolPush();
    if (qword_100219F60) {
      [(id)qword_100219F60 WFLog:4, "%s: unable to create directory at path %@", "WiFiNetworkArchiveToPath", v5 message];
    }
    objc_autoreleasePoolPop(v10);
    return 0LL;
  }

  return v8;
}

_WORD *sub_10009F740(uint64_t a1)
{
  if (!a1)
  {
    CFTypeID v4 = objc_autoreleasePoolPush();
    id v5 = (void *)qword_100219F60;
    if (!qword_100219F60) {
      goto LABEL_13;
    }
    uint64_t v6 = "%s: path is nil";
LABEL_9:
    uint64_t v7 = 3LL;
LABEL_12:
    [v5 WFLog:v7 message:v6 WFLogTypeWiFiNetworkCreateFromPath v8];
    goto LABEL_13;
  }

  char v2 = -[NSFileManager contentsAtPath:]( +[NSFileManager defaultManager](&OBJC_CLASS___NSFileManager, "defaultManager"),  "contentsAtPath:",  a1);
  if (!v2)
  {
    CFTypeID v4 = objc_autoreleasePoolPush();
    id v5 = (void *)qword_100219F60;
    if (!qword_100219F60) {
      goto LABEL_13;
    }
    uint64_t v8 = a1;
    uint64_t v6 = "%s: data at path %@ is nil";
    goto LABEL_9;
  }

  uint64_t result = sub_100094AAC( 0LL,  +[NSPropertyListSerialization propertyListWithData:options:format:error:]( &OBJC_CLASS___NSPropertyListSerialization,  "propertyListWithData:options:format:error:",  v2,  0LL,  0LL,  0LL));
  if (!result)
  {
    CFTypeID v4 = objc_autoreleasePoolPush();
    id v5 = (void *)qword_100219F60;
    if (qword_100219F60)
    {
      uint64_t v8 = a1;
      uint64_t v6 = "%s: unable to create WiFiNetworkRef at path %@";
      uint64_t v7 = 4LL;
      goto LABEL_12;
    }

uint64_t sub_10009F854(uint64_t result, __int16 a2)
{
  *(_WORD *)(result + 24) = a2;
  return result;
}

uint64_t sub_10009F85C(uint64_t a1)
{
  return *(unsigned __int16 *)(a1 + 24);
}

void sub_10009F864(const void *a1, int a2)
{
  int valuePtr = a2;
  if (a1)
  {
    if ((a2 - 1) > 1)
    {
      int valuePtr = 0;
      CFNumberRef v8 = CFNumberCreate(kCFAllocatorDefault, kCFNumberIntType, &valuePtr);
      CFIndex v9 = objc_autoreleasePoolPush();
      if (qword_100219F60) {
        [(id)qword_100219F60 WFLog:3, "%s: Setting NOI work-state for '%@' to 'Unknown'", "WiFiNetworkSetNetworkOfInterestWorkType", sub_100095BC8(a1) message];
      }
      objc_autoreleasePoolPop(v9);
    }

    else
    {
      CFTypeID v4 = objc_autoreleasePoolPush();
      id v5 = (void *)qword_100219F60;
      if (qword_100219F60)
      {
        uint64_t v6 = sub_100095BC8(a1);
        uint64_t v7 = "NotWork";
        if (a2 == 1) {
          uint64_t v7 = "Work";
        }
        [v5 WFLog:3, "%s: Setting NOI work-state for '%@' to '%s'", "WiFiNetworkSetNetworkOfInterestWorkType", v6, v7 message];
      }

      objc_autoreleasePoolPop(v4);
      CFNumberRef v8 = CFNumberCreate(kCFAllocatorDefault, kCFNumberIntType, &valuePtr);
    }

    sub_10009582C((uint64_t)a1, @"NetworkOfInterestWorkState", v8);
    if (v8) {
      CFRelease(v8);
    }
  }

CFNumberRef sub_10009F9B8(uint64_t a1)
{
  unsigned int valuePtr = 0;
  if (a1)
  {
    uint64_t result = (const __CFNumber *)sub_1000951FC(a1, @"NetworkOfInterestWorkState");
    if (result)
    {
      int Value = CFNumberGetValue(result, kCFNumberSInt32Type, &valuePtr);
      if (valuePtr - 3 >= 0xFFFFFFFE || Value == 0) {
        return (const __CFNumber *)valuePtr;
      }
      else {
        return 0LL;
      }
    }
  }

  else
  {
    CFTypeID v4 = objc_autoreleasePoolPush();
    if (qword_100219F60) {
      [qword_100219F60 WFLog:@"%s: null network" message:3];
    }
    objc_autoreleasePoolPop(v4);
    return 0LL;
  }

  return result;
}

void sub_10009FA58(const void *a1, int a2)
{
  int valuePtr = a2;
  if (a1)
  {
    if ((a2 - 1) > 1)
    {
      int valuePtr = 0;
      CFNumberRef v7 = CFNumberCreate(kCFAllocatorDefault, kCFNumberIntType, &valuePtr);
      CFNumberRef v8 = objc_autoreleasePoolPush();
      if (qword_100219F60) {
        [(id)qword_100219F60 WFLog:3, "%s: Setting NOI home-state for '%@' to 'Unknown'", "WiFiNetworkSetNetworkOfInterestHomeType", sub_100095BC8(a1) message];
      }
      objc_autoreleasePoolPop(v8);
    }

    else
    {
      CFTypeID v4 = objc_autoreleasePoolPush();
      id v5 = (void *)qword_100219F60;
      if (qword_100219F60)
      {
        uint64_t v6 = sub_100095BC8(a1);
        [v5 WFLog:3, "%s: Setting NOI home-state for '%@' to '%@'", "WiFiNetworkSetNetworkOfInterestHomeType", v6, sub_10003B334(a2) message];
      }

      objc_autoreleasePoolPop(v4);
      CFNumberRef v7 = CFNumberCreate(kCFAllocatorDefault, kCFNumberIntType, &valuePtr);
    }

    sub_10009582C((uint64_t)a1, @"NetworkOfInterestHomeState", v7);
    if (v7) {
      CFRelease(v7);
    }
  }

void sub_10009FBA8(const void *a1, int a2)
{
  if (a1)
  {
    CFTypeID v4 = (const void **)&kCFBooleanFalse;
    if (a2) {
      CFTypeID v4 = (const void **)&kCFBooleanTrue;
    }
    sub_10009582C((uint64_t)a1, @"NetworkForcedHomeFix", *v4);
    if (a2)
    {
      CFAbsoluteTime Current = CFAbsoluteTimeGetCurrent();
      CFDateRef v6 = CFDateCreate(kCFAllocatorDefault, Current);
      sub_10009FC8C(a1, v6);
      if (v6) {
        CFRelease(v6);
      }
    }
  }

  else
  {
    CFNumberRef v7 = objc_autoreleasePoolPush();
    if (qword_100219F60) {
      [qword_100219F60 WFLog:@"%s: null network" message:3];
    }
    objc_autoreleasePoolPop(v7);
  }

void sub_10009FC8C(const void *a1, const void *a2)
{
  if (!a1)
  {
    CFDateRef v6 = objc_autoreleasePoolPush();
    if (qword_100219F60) {
      [qword_100219F60 WFLog:@"%s: null network" message:3];
    }
    goto LABEL_11;
  }

  if (!a2)
  {
    CFDateRef v6 = objc_autoreleasePoolPush();
    if (qword_100219F60) {
      [qword_100219F60 WFLog:@"%s: null modDate" message:3];
    }
LABEL_11:
    CFNumberRef v7 = v6;
LABEL_15:
    objc_autoreleasePoolPop(v7);
    return;
  }

  CFTypeID v4 = sub_100095BC8(a1);
  id v5 = objc_autoreleasePoolPush();
  if (!v4)
  {
    if (qword_100219F60) {
      [qword_100219F60 WFLog:@"%s: null ssid" message:3];
    }
    CFNumberRef v7 = v5;
    goto LABEL_15;
  }

  if (qword_100219F60) {
    [(id)qword_100219F60 WFLog:3, "%s: for network <%@>, modDate %@", "WiFiNetworkSetLastHomeForceFixDate", v4, a2 message];
  }
  objc_autoreleasePoolPop(v5);
  sub_10009582C((uint64_t)a1, @"kWiFiNetworkLastHomeForceFixDateKey", a2);
}

uint64_t sub_10009FDC8(uint64_t a1)
{
  unsigned int valuePtr = 0;
  if (!a1)
  {
    char v2 = objc_autoreleasePoolPush();
    if (qword_100219F60) {
      objc_msgSend((id)qword_100219F60, "WFLog:message:", 3, "%s: null network", "WiFiNetworkGetLOIType");
    }
    goto LABEL_6;
  }

  uint64_t v1 = (const __CFNumber *)sub_1000951FC(a1, @"NetworkAtLocationOfInterestType");
  if (!v1)
  {
    char v2 = objc_autoreleasePoolPush();
    if (qword_100219F60) {
      [qword_100219F60 WFLog:@"%s: null stateRef" message:3];
    }
    goto LABEL_6;
  }

  if (!CFNumberGetValue(v1, kCFNumberSInt32Type, &valuePtr))
  {
    char v2 = objc_autoreleasePoolPush();
    if (qword_100219F60) {
      [qword_100219F60 WFLog:@"%s: Failed to get kWiFiNetworkAtLocationOfInterestTypeKey" message:3];
    }
LABEL_6:
    objc_autoreleasePoolPop(v2);
  }

  return valuePtr;
}

void sub_10009FEB4(const void *a1, unsigned int a2)
{
  unsigned int valuePtr = a2;
  CFNumberRef v3 = CFNumberCreate(kCFAllocatorDefault, kCFNumberIntType, &valuePtr);
  CFTypeID v4 = objc_autoreleasePoolPush();
  id v5 = (void *)qword_100219F60;
  if (v3)
  {
    if (qword_100219F60)
    {
      CFDateRef v6 = sub_10003B3B0(valuePtr);
      [v5 WFLog:3, "%s: Setting NetworkLocationOfInterestType=%@(%d) for %@", "WiFiNetworkSetLOIType", v6, valuePtr, sub_100095BC8(a1) message];
    }

    objc_autoreleasePoolPop(v4);
    sub_10009582C((uint64_t)a1, @"NetworkAtLocationOfInterestType", v3);
    CFRelease(v3);
  }

  else
  {
    if (qword_100219F60) {
      [qword_100219F60 WFLog:@"Failed to create CFNumber while setting NetworkAtLocationOfInterestType=%d" message:4 valuePtr];
    }
    objc_autoreleasePoolPop(v4);
  }

BOOL sub_10009FFBC(const __CFString *a1)
{
  if (!a1) {
    return 1LL;
  }
  if (CFEqual(a1, @"_AppleWi-FiInternetTetheringSSID_")) {
    return 1LL;
  }
  return CFStringGetLength(a1) < 33;
}

BOOL sub_1000A0010(const void *a1)
{
  uint64_t v1 = sub_100095BC8(a1);
  if (qword_100219960) {
    BOOL v2 = v1 == 0LL;
  }
  else {
    BOOL v2 = 1;
  }
  return !v2 && CFSetContainsValue((CFSetRef)qword_100219960, v1);
}

CFNumberRef sub_1000A0050(const __CFNumber *result)
{
  if (result)
  {
    if (*((void *)result + 2))
    {
      uint64_t v1 = (const __CFNumber *)sub_1000951FC((uint64_t)result, @"ShareableStatus");
      return sub_10003AC9C(v1);
    }

    else
    {
      return 0LL;
    }
  }

  return result;
}

void sub_1000A0088(uint64_t a1, const void *a2)
{
  if (a1) {
    sub_10009582C(a1, @"WalletIdentifier", a2);
  }
}

const void *sub_1000A00A4(const void *result)
{
  if (result) {
    return sub_1000951FC((uint64_t)result, @"WalletIdentifier");
  }
  return result;
}

void sub_1000A00BC(uint64_t a1, uint64_t a2)
{
  uint64_t valuePtr = a2;
  values = CFNumberCreate(kCFAllocatorDefault, kCFNumberCFIndexType, &valuePtr);
  if (values)
  {
    CFArrayRef v3 = CFArrayCreate(kCFAllocatorDefault, (const void **)&values, 1LL, &kCFTypeArrayCallBacks);
    if (!v3)
    {
      uint64_t v12 = objc_autoreleasePoolPush();
      if (qword_100219F60) {
        [qword_100219F60 WFLog:@"build array failed for mode (%d)" message:@"WiFiNetworkUpdateWPARSNAuthType" 4];
      }
      objc_autoreleasePoolPop(v12);
      goto LABEL_40;
    }

    CFArrayRef v4 = v3;
    if ((unint64_t)(valuePtr - 1) < 2)
    {
      uint64_t v13 = (const __CFDictionary *)sub_1000951FC(a1, @"RSN_IE");
      if (v13)
      {
        MutableCFDictionaryRef Copy = CFDictionaryCreateMutableCopy(kCFAllocatorDefault, 0LL, v13);
        if (MutableCopy)
        {
          uint64_t v15 = MutableCopy;
          int Value = (const __CFArray *)CFDictionaryGetValue(v13, @"IE_KEY_RSN_AUTHSELS");
          if (!Value || CFArrayGetCount(Value) >= 2)
          {
            CFDictionaryReplaceValue(v15, @"IE_KEY_RSN_AUTHSELS", v4);
            sub_10009582C(a1, @"RSN_IE", v15);
          }

          CFRelease(v15);
        }
      }

      else
      {
        int v18 = objc_autoreleasePoolPush();
        if (qword_100219F60) {
          [qword_100219F60 WFLog:@"message" message:[NSString stringWithFormat:@"%s RSN auth type (%d) has no RSN IE", @"WiFiNetworkUpdateWPARSNAuthType", valuePtr]];
        }
        objc_autoreleasePoolPop(v18);
      }

      char v19 = (const __CFDictionary *)sub_1000951FC(a1, @"WPA_IE");
      if (v19)
      {
        CFIndex v20 = v19;
        CFTypeID TypeID = CFDictionaryGetTypeID();
        if (sub_10003AE00(TypeID, v20))
        {
          CFMutableDictionaryRef v22 = CFDictionaryCreateMutableCopy(kCFAllocatorDefault, 0LL, v20);
          if (v22)
          {
            CFNumberRef v8 = v22;
            int v23 = (const __CFArray *)CFDictionaryGetValue(v13, @"IE_KEY_WPA_AUTHSELS");
            if (v23 && CFArrayGetCount(v23) < 2) {
              goto LABEL_35;
            }
            CFDictionaryReplaceValue(v8, @"IE_KEY_WPA_AUTHSELS", v4);
            int v10 = @"WPA_IE";
            goto LABEL_34;
          }

uint64_t sub_1000A0430(uint64_t a1)
{
  if (a1)
  {
    BOOL v2 = (const __CFNumber *)sub_1000951FC(a1, @"kWiFiNetworkSSIDHarvestStatusKey");
    uint64_t result = (uint64_t)sub_10003AC9C(v2);
    if (!(_DWORD)result)
    {
      CFBooleanRef v4 = (CFBooleanRef)sub_1000951FC(a1, @"WiFiNetworkAttributeHighPopularity");
      if (v4 == kCFBooleanTrue)
      {
        if (sub_1000951FC(a1, @"WiFiNetworkAttributeIsPublic") == v4) {
          return 3LL;
        }
        else {
          return 0LL;
        }
      }

      else
      {
        return 0LL;
      }
    }
  }

  else
  {
    id v5 = objc_autoreleasePoolPush();
    if (qword_100219F60) {
      [qword_100219F60 WFLog:@"%s: null network" message:3];
    }
    objc_autoreleasePoolPop(v5);
    return 1LL;
  }

  return result;
}

void sub_1000A0508(uint64_t a1)
{
  if (a1)
  {
    if (CFDictionaryContainsKey(*(CFDictionaryRef *)(a1 + 16), @"enabled")) {
      CFDictionaryRemoveValue(*(CFMutableDictionaryRef *)(a1 + 16), @"enabled");
    }
    if (CFDictionaryContainsKey(*(CFDictionaryRef *)(a1 + 16), @"WiFiNetworkDisabledUntilDate")) {
      CFDictionaryRemoveValue(*(CFMutableDictionaryRef *)(a1 + 16), @"WiFiNetworkDisabledUntilDate");
    }
    if (CFDictionaryContainsKey(*(CFDictionaryRef *)(a1 + 16), @"networkDisabledClientName")) {
      CFDictionaryRemoveValue(*(CFMutableDictionaryRef *)(a1 + 16), @"networkDisabledClientName");
    }
    if (CFDictionaryContainsKey(*(CFDictionaryRef *)(a1 + 16), @"networkDisabledReason")) {
      CFDictionaryRemoveValue(*(CFMutableDictionaryRef *)(a1 + 16), @"networkDisabledReason");
    }
    if (CFDictionaryContainsKey(*(CFDictionaryRef *)(a1 + 16), @"networkDisabledTimestamp")) {
      CFDictionaryRemoveValue(*(CFMutableDictionaryRef *)(a1 + 16), @"networkDisabledTimestamp");
    }
  }

  else
  {
    BOOL v2 = objc_autoreleasePoolPush();
    if (qword_100219F60) {
      [qword_100219F60 WFLog:@"%s: null network" message:3];
    }
    objc_autoreleasePoolPop(v2);
  }

void *sub_1000A063C(CFDictionaryRef *a1)
{
  uint64_t context = objc_autoreleasePoolPush();
  if (!a1 || !sub_1000A1A8C())
  {
    v82 = 0LL;
    goto LABEL_141;
  }

  id v2 = objc_alloc_init((Class)sub_1000A1A8C());
  [v2 setSSID:sub_100096804(a1)];
  sub_100095318((BOOL)a1);
  [v2 setSupportedSecurityTypes:0];
  v82 = v2;
  if (!sub_100098380((BOOL)a1))
  {
    if (sub_1000983D0((uint64_t)a1))
    {
      CFDateRef v6 = v2;
      unint64_t v7 = 768LL;
    }

    else
    {
      if (!sub_100098434(a1[2]))
      {
        if (CFDictionaryGetValue(a1[2], @"WEP") == kCFBooleanTrue)
        {
          objc_msgSend( v2,  "setSupportedSecurityTypes:",  (unint64_t)objc_msgSend(v2, "supportedSecurityTypes") | 1);
          if (sub_100095B4C((uint64_t)a1))
          {
            uint64_t v21 = v2;
            uint64_t v22 = 5LL;
          }

          else
          {
            unsigned int v77 = (void *)sub_1000951FC((uint64_t)a1, @"WEP_AUTH_Flags");
            if (!v77) {
              goto LABEL_14;
            }
            CFNumberRef v78 = v77;
            unsigned __int8 v79 = [v77 intValue];
            [v78 intValue];
            unsigned __int8 v80 = [v78 intValue];
            if ((v79 & 1) != 0)
            {
              if ((v80 & 4) == 0) {
                goto LABEL_14;
              }
              uint64_t v21 = v82;
              uint64_t v22 = 3LL;
            }

            else
            {
              if ((v80 & 4) == 0) {
                goto LABEL_14;
              }
              uint64_t v21 = v82;
              uint64_t v22 = 4LL;
            }
          }

          [v21 setWEPSubtype:v22];
        }

        goto LABEL_14;
      }

      unint64_t v7 = (unint64_t)[v2 supportedSecurityTypes] | 0x100;
      CFDateRef v6 = v2;
    }

    [v6 setSupportedSecurityTypes:v7];
    goto LABEL_14;
  }

  [v2 setSupportedSecurityTypes:([v2 supportedSecurityTypes] | 2)];
  unsigned int v3 = [sub_1000951FC((uint64_t)a1, @"WAPI") intValue];
  if ((~v3 & 0xB) == 0)
  {
    CFBooleanRef v4 = v2;
    uint64_t v5 = 2LL;
LABEL_10:
    [v4 setWAPISubtype:v5];
    goto LABEL_14;
  }

  if ((~v3 & 7) == 0)
  {
    CFBooleanRef v4 = v2;
    uint64_t v5 = 1LL;
    goto LABEL_10;
  }

LABEL_70:
  [v82 setAddReason:v20];
  [v82 setAddedAt:sub_1000951FC((uint64_t)a1, @"addedAt")];
  [v82 setUpdatedAt:sub_1000951FC((uint64_t)a1, @"lastUpdated")];
  [v82 setEAPProfile:[sub_1000951FC((uint64_t)a1, @"EnterpriseProfile") objectForKeyedSubscript:@"EAPClientConfiguration"]];
  [v82 setDomainName:sub_1000951FC((uint64_t)a1, @"DomainName")];
  [v82 setDisplayedOperatorName:sub_1000951FC((uint64_t)a1, @"DisplayedOperatorName")];
  [v82 setServiceProviderRoamingEnabled:sub_1000951FC((uint64_t)a1, @"SPRoaming") != kCFBooleanFalse];
  [v82 setCellularNetworkInfo:sub_1000951FC((uint64_t)a1, @"MCCandMNC")];
  [v82 setNAIRealmNameList:sub_1000951FC((uint64_t)a1, @"NaiRealmName")];
  objc_msgSend(v82, "setRoamingConsortiumList:", sub_1000951FC((uint64_t)a1, @"RoamingConsortiumOIs"));
  [v82 setUserPreferredNetworkNames:sub_1000951FC((uint64_t)a1, @"userPreferredNetworkNames")];
  [v82 setUserPreferredPasspointDomains:sub_1000951FC((uint64_t)a1, @"userPreferredPasspointDomains")];
  [v82 setNetworkGroupID:sub_1000951FC((uint64_t)a1, @"networkGroupID")];
  [v82 setNetworkGroupPriority:[sub_1000951FC((uint64_t)a1, @"networkGroupPriority") unsignedIntegerValue]];
  [v82 setLastDiscoveredAt:sub_1000951FC((uint64_t)a1, @"discoveredAt")];
  int v23 = (void *)sub_1000951FC((uint64_t)a1, @"TransitionDisabledFlags");
  if (v23) {
    [v82 setTransitionDisabledFlags:[v23 unsignedIntegerValue]];
  }
  [v82 setStandalone6G:[sub_1000951FC((uint64_t)a1, @"Standalone") boolValue]];
  BOOL v24 = (const __CFArray *)sub_1000951FC((uint64_t)a1, @"networkKnownBSSListKey");
  if (v24)
  {
    int v25 = v24;
    if (CFArrayGetCount(v24))
    {
      __int128 v98 = 0u;
      __int128 v99 = 0u;
      __int128 v96 = 0u;
      __int128 v97 = 0u;
      obCFIndex j = v25;
      id v86 = -[__CFArray countByEnumeratingWithState:objects:count:]( v25,  "countByEnumeratingWithState:objects:count:",  &v96,  v113,  16LL);
      if (v86)
      {
        id v87 = 0LL;
        uint64_t v85 = *(void *)v97;
        uint64_t v84 = CWFCoreWiFiSpecificAttributesKey;
        do
        {
          for (CFIndex i = 0LL; i != v86; CFIndex i = (char *)i + 1)
          {
            if (*(void *)v97 != v85) {
              objc_enumerationMutation(obj);
            }
            uint64_t v27 = *(void **)(*((void *)&v96 + 1) + 8LL * (void)i);
            uint64_t v105 = 0LL;
            v106 = &v105;
            uint64_t v107 = 0x3052000000LL;
            v108 = sub_1000A671C;
            v109 = sub_1000A672C;
            int v28 = (objc_class *)qword_100219978;
            uint64_t v110 = qword_100219978;
            if (!qword_100219978)
            {
              v100 = _NSConcreteStackBlock;
              uint64_t v101 = 3221225472LL;
              v102 = sub_1000A6834;
              v103 = &unk_1001E42A0;
              v104 = &v105;
              sub_1000A6834((uint64_t)&v100);
              int v28 = (objc_class *)v106[5];
            }

            _Block_object_dispose(&v105, 8);
            id v29 = objc_alloc_init(v28);
            objc_msgSend( v29,  "setBSSID:",  CWFCorrectEthernetAddressString(objc_msgSend(v27, "objectForKeyedSubscript:", @"BSSID")));
            id v30 = [v27 objectForKeyedSubscript:@"CHANNEL"];
            id v31 = [v27 objectForKeyedSubscript:@"CHANNEL_FLAGS"];
            if (v30)
            {
              unsigned int v32 = v31;
              if (v31)
              {
                id v33 = objc_alloc_init((Class)sub_1000A1B54());
                objc_msgSend(v33, "setChannel:", objc_msgSend(v30, "integerValue"));
                objc_msgSend(v33, "setFlags:", objc_msgSend(v32, "unsignedIntegerValue"));
                [v29 setChannel:v33];
              }
            }

            if ([v29 BSSID] && objc_msgSend(v29, "channel"))
            {
              [v29 setLastAssociatedAt:[v27 objectForKeyedSubscript:@"lastRoamed"]];
              id v34 = [v27 objectForKeyedSubscript:@"networkLocnLat"];
              id v35 = [v27 objectForKeyedSubscript:@"networkLocnLong"];
              id v36 = [v27 objectForKeyedSubscript:@"networkLocnAccuracy"];
              id v37 = [v27 objectForKeyedSubscript:@"networkLocnTimestamp"];
              if (v34)
              {
                if (v35)
                {
                  if (v36)
                  {
                    id v38 = v37;
                    if (v37)
                    {
                      uint64_t v105 = 0LL;
                      v106 = &v105;
                      uint64_t v107 = 0x3052000000LL;
                      v108 = sub_1000A671C;
                      v109 = sub_1000A672C;
                      CFIndex v39 = (objc_class *)qword_100219988;
                      uint64_t v110 = qword_100219988;
                      if (!qword_100219988)
                      {
                        v100 = _NSConcreteStackBlock;
                        uint64_t v101 = 3221225472LL;
                        v102 = sub_1000A68DC;
                        v103 = &unk_1001E42A0;
                        v104 = &v105;
                        sub_1000A68DC((uint64_t)&v100);
                        CFIndex v39 = (objc_class *)v106[5];
                      }

                      _Block_object_dispose(&v105, 8);
                      id v40 = objc_alloc(v39);
                      [v34 doubleValue];
                      double v42 = v41;
                      [v35 doubleValue];
                      double v44 = v43;
                      uint64_t v105 = 0LL;
                      v106 = &v105;
                      uint64_t v107 = 0x2020000000LL;
                      uint64_t v45 = off_100219998;
                      v108 = (void (*)(uint64_t, uint64_t))off_100219998;
                      if (!off_100219998)
                      {
                        int v46 = (void *)sub_1000A6930();
                        uint64_t v45 = dlsym(v46, "CLLocationCoordinate2DMake");
                        v106[3] = (uint64_t)v45;
                        off_100219998 = v45;
                      }

                      _Block_object_dispose(&v105, 8);
                      if (!v45) {
                        sub_100154318();
                      }
                      double v47 = ((double (*)(double, double))v45)(v42, v44);
                      double v49 = v48;
                      [v36 doubleValue];
                      objc_msgSend( v29,  "setLocation:",   objc_msgSend( v40,  "initWithCoordinate:altitude:horizontalAccuracy:verticalAccuracy:timestamp:",  v38,  v47,  v49,  0.0,  v50,  0.0));
                    }
                  }
                }
              }

              id v51 = [v27 objectForKeyedSubscript:@"colocated2GHzRNRChannel"];
              id v52 = [v27 objectForKeyedSubscript:@"colocated2GHzRNRChannelFlags"];
              if (v51)
              {
                v53 = v52;
                if (v52)
                {
                  id v54 = objc_alloc_init((Class)sub_1000A1B54());
                  [v54 setChannel:[v51 integerValue]];
                  [v54 setFlags:[v53 unsignedIntegerValue]];
                  [v29 setColocated2GHzRNRChannel:v54];
                }
              }

              id v55 = [v27 objectForKeyedSubscript:@"colocated5GHzRNRChannel"];
              id v56 = [v27 objectForKeyedSubscript:@"colocated5GHzRNRChannelFlags"];
              if (v55)
              {
                CFIndex v57 = v56;
                if (v56)
                {
                  id v58 = objc_alloc_init((Class)sub_1000A1B54());
                  [v58 setChannel:[v55 integerValue]];
                  [v58 setFlags:[v57 unsignedIntegerValue]];
                  [v29 setColocated5GHzRNRChannel:v58];
                }
              }

              [v29 setAWDLRealTimeModeTimestamp:[v27 objectForKeyedSubscript:@"AWDLRealTimeModeTimestamp"]];
              [v29 setIPv4NetworkSignature:[v27 objectForKeyedSubscript:@"IPv4NetworkSignature"]];
              objc_msgSend( v29,  "setIPv6NetworkSignature:",  objc_msgSend(v27, "objectForKeyedSubscript:", @"IPv6NetworkSignature"));
              [v29 setDHCPServerID:[v27 objectForKeyedSubscript:@"DHCPServerID"]];
              [v29 setDHCPv6ServerID:[v27 objectForKeyedSubscript:@"DHCPv6ServerID"]];
              id v59 = +[NSMutableDictionary dictionary](&OBJC_CLASS___NSMutableDictionary, "dictionary");
              __int128 v94 = 0u;
              __int128 v95 = 0u;
              __int128 v92 = 0u;
              __int128 v93 = 0u;
              id v60 = +[CWFBSS supportedOSSpecificKeys](&OBJC_CLASS___CWFBSS, "supportedOSSpecificKeys");
              id v61 = [v60 countByEnumeratingWithState:&v92 objects:v112 count:16];
              if (v61)
              {
                uint64_t v62 = *(void *)v93;
                do
                {
                  for (CFIndex j = 0LL; j != v61; CFIndex j = (char *)j + 1)
                  {
                    if (*(void *)v93 != v62) {
                      objc_enumerationMutation(v60);
                    }
                    objc_msgSend( v59,  "setObject:forKeyedSubscript:",  sub_1000951FC((uint64_t)a1, *(void **)(*((void *)&v92 + 1) + 8 * (void)j)),  *(void *)(*((void *)&v92 + 1) + 8 * (void)j));
                  }

                  id v61 = [v60 countByEnumeratingWithState:&v92 objects:v112 count:16];
                }

                while (v61);
              }

              if ([v59 count]) {
                id v64 = v59;
              }
              else {
                id v64 = 0LL;
              }
              [v29 setOSSpecificAttributes:v64];
              objc_msgSend(v29, "setCoreWiFiSpecificAttributes:", objc_msgSend(v27, "objectForKeyedSubscript:", v84));
              id v65 = v87;
              if (!v87) {
                id v65 = +[NSMutableSet set](&OBJC_CLASS___NSMutableSet, "set");
              }
              id v87 = v65;
              [v65 addObject:v29];
            }
          }

          id v86 = -[__CFArray countByEnumeratingWithState:objects:count:]( obj,  "countByEnumeratingWithState:objects:count:",  &v96,  v113,  16LL);
        }

        while (v86);
      }

      else
      {
        id v87 = 0LL;
      }

      [v82 setBSSList:v87];
    }
  }

  [v82 setPrivacyProxyEnabled:sub_1000A1C1C((uint64_t)a1)];
  [v82 setPrivacyProxyBlockedReason:sub_1000951FC((uint64_t)a1, @"PrivacyProxyBlockedReason")];
  if (sub_1000951FC((uint64_t)a1, @"WiFiNetworkAttributeIsMoving"))
  {
    v66 = sub_1000951FC((uint64_t)a1, @"WiFiNetworkAttributeIsMoving");
    if (CFEqual(v66, kCFBooleanTrue)) {
      uint64_t v67 = 1LL;
    }
    else {
      uint64_t v67 = 2LL;
    }
  }

  else
  {
    uint64_t v67 = 0LL;
  }

  [v82 setMovingAttribute:v67];
  if (sub_1000951FC((uint64_t)a1, @"WiFiNetworkAttributeIsPublic"))
  {
    uint64_t v68 = sub_1000951FC((uint64_t)a1, @"WiFiNetworkAttributeIsPublic");
    if (CFEqual(v68, kCFBooleanTrue)) {
      uint64_t v69 = 1LL;
    }
    else {
      uint64_t v69 = 2LL;
    }
  }

  else
  {
    uint64_t v69 = 0LL;
  }

  [v82 setPublicAttribute:v69];
  [v82 setCarplayUUID:sub_1000951FC((uint64_t)a1, @"CARPLAY_UUID")];
  [v82 setCarplayNetwork:sub_10009DF44((uint64_t)a1) != 0];
  [v82 setPersonalHotspot:sub_100097700((uint64_t)a1) != 0];
  [v82 setNANServiceID:sub_1000951FC((uint64_t)a1, @"WiFiNetworkNANServiceID")];
  [v82 setPublicAirPlayNetwork:sub_1000A1D44((uint64_t)a1) != 0];
  [v82 setDNSHeuristicsFilteredNetwork:[sub_1000951FC((uint64_t)a1, @"FilteredNetwork") boolValue]];
  [v82 setDNSHeuristicsFailureStateInfo:sub_1000951FC((uint64_t)a1, @"DNSFailures")];
  id v70 = +[NSMutableDictionary dictionary](&OBJC_CLASS___NSMutableDictionary, "dictionary");
  __int128 v90 = 0u;
  __int128 v91 = 0u;
  __int128 v88 = 0u;
  __int128 v89 = 0u;
  id v71 = +[CWFNetworkProfile supportedOSSpecificKeys](&OBJC_CLASS___CWFNetworkProfile, "supportedOSSpecificKeys");
  id v72 = [v71 countByEnumeratingWithState:&v88 objects:v111 count:16];
  if (v72)
  {
    uint64_t v73 = *(void *)v89;
    do
    {
      for (CFIndex k = 0LL; k != v72; CFIndex k = (char *)k + 1)
      {
        if (*(void *)v89 != v73) {
          objc_enumerationMutation(v71);
        }
        objc_msgSend( v70,  "setObject:forKeyedSubscript:",  sub_1000951FC((uint64_t)a1, *(void **)(*((void *)&v88 + 1) + 8 * (void)k)),  *(void *)(*((void *)&v88 + 1) + 8 * (void)k));
      }

      id v72 = [v71 countByEnumeratingWithState:&v88 objects:v111 count:16];
    }

    while (v72);
  }

  if ([v70 count]) {
    id v75 = v70;
  }
  else {
    id v75 = 0LL;
  }
  [v82 setOSSpecificAttributes:v75];
  [v82 setCoreWiFiSpecificAttributes:sub_1000951FC((uint64_t)a1, CWFCoreWiFiSpecificAttributesKey)];
LABEL_141:
  objc_autoreleasePoolPop(context);
  return v82;
}

    if (!v8)
    {
LABEL_72:
      if (v13) {
        CFRelease(v13);
      }
      if (v33) {
        CFRelease(v33);
      }
      return;
    }

    objc_autoreleasePoolPop(v36);
    return sub_1001050F0(a1);
  }

  *(_DWORD *)(a1 + 3276) = v12;
  return (const __CFArray *)v12;
}

    if (++v37 == v4) {
      goto LABEL_71;
    }
  }

  id v40 = 0LL;
  while (1)
  {
    double v41 = (void *)CFArrayGetValueAtIndex(v35, v40);
    if (!v41) {
      goto LABEL_67;
    }
    double v42 = v41;
    if (sub_10009D528(v39, v42))
    {
      sub_10009D31C((uint64_t)v39, 1);
      sub_100095524((uint64_t)v39, (uint64_t)v42);
      goto LABEL_70;
    }

void sub_1000A1A64( _Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20, uint64_t a21, uint64_t a22, uint64_t a23, uint64_t a24, uint64_t a25, uint64_t a26, uint64_t a27, uint64_t a28, uint64_t a29, uint64_t a30, uint64_t a31, uint64_t a32, uint64_t a33, uint64_t a34, uint64_t a35, uint64_t a36, uint64_t a37, uint64_t a38, uint64_t a39, uint64_t a40, uint64_t a41, uint64_t a42, uint64_t a43, uint64_t a44, uint64_t a45, uint64_t a46, char a47)
{
}

uint64_t sub_1000A1A8C()
{
  uint64_t v3 = 0LL;
  CFBooleanRef v4 = &v3;
  uint64_t v5 = 0x3052000000LL;
  CFDateRef v6 = sub_1000A671C;
  unint64_t v7 = sub_1000A672C;
  uint64_t v0 = qword_100219968;
  uint64_t v8 = qword_100219968;
  if (!qword_100219968)
  {
    v2[0] = _NSConcreteStackBlock;
    v2[1] = 3221225472LL;
    v2[2] = sub_1000A6738;
    v2[3] = &unk_1001E42A0;
    v2[4] = &v3;
    sub_1000A6738((uint64_t)v2);
    uint64_t v0 = v4[5];
  }

  _Block_object_dispose(&v3, 8);
  return v0;
}

void sub_1000A1B3C( _Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, ...)
{
}

uint64_t sub_1000A1B54()
{
  uint64_t v3 = 0LL;
  CFBooleanRef v4 = &v3;
  uint64_t v5 = 0x3052000000LL;
  CFDateRef v6 = sub_1000A671C;
  unint64_t v7 = sub_1000A672C;
  uint64_t v0 = qword_100219980;
  uint64_t v8 = qword_100219980;
  if (!qword_100219980)
  {
    v2[0] = _NSConcreteStackBlock;
    v2[1] = 3221225472LL;
    v2[2] = sub_1000A6888;
    v2[3] = &unk_1001E42A0;
    v2[4] = &v3;
    sub_1000A6888((uint64_t)v2);
    uint64_t v0 = v4[5];
  }

  _Block_object_dispose(&v3, 8);
  return v0;
}

void sub_1000A1C04( _Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, ...)
{
}

BOOL sub_1000A1C1C(uint64_t a1)
{
  if (a1)
  {
    if (CFDictionaryContainsKey(*(CFDictionaryRef *)(a1 + 16), @"PrivacyProxyEnabled")) {
      return sub_1000951FC(a1, @"PrivacyProxyEnabled") == kCFBooleanTrue;
    }
  }

  else
  {
    uint64_t v3 = objc_autoreleasePoolPush();
    if (qword_100219F60) {
      [qword_100219F60 WFLog:@"%s: null network" message:3];
    }
    objc_autoreleasePoolPop(v3);
  }

  return 1LL;
}

const void *sub_1000A1CC4(uint64_t a1)
{
  if (a1) {
    return sub_1000951FC(a1, @"PrivacyProxyBlockedReason");
  }
  id v2 = objc_autoreleasePoolPush();
  if (qword_100219F60) {
    [qword_100219F60 WFLog:@"%s: null network" message:3];
  }
  objc_autoreleasePoolPop(v2);
  return 0LL;
}

uint64_t sub_1000A1D44(uint64_t a1)
{
  if (a1)
  {
    uint64_t result = CFDictionaryContainsKey(*(CFDictionaryRef *)(a1 + 16), @"PublicAirPlayNetwork");
    if ((_DWORD)result) {
      return sub_1000951FC(a1, @"PublicAirPlayNetwork") == kCFBooleanTrue;
    }
  }

  else
  {
    uint64_t v3 = objc_autoreleasePoolPush();
    if (qword_100219F60) {
      objc_msgSend((id)qword_100219F60, "WFLog:message:", 3, "%s: null network", "WiFiNetworkIsPublicAirPlayNetwork");
    }
    objc_autoreleasePoolPop(v3);
    return 0LL;
  }

  return result;
}

_WORD *sub_1000A1DEC(void *a1, void *a2)
{
  CFBooleanRef v4 = objc_autoreleasePoolPush();
  uint64_t v5 = sub_1000A1A8C();
  CFDateRef v6 = 0LL;
  if (a1 && v5)
  {
    uint64_t v7 = sub_1000A1A8C();
    uint64_t v8 = objc_opt_class(v7);
    if ((objc_opt_isKindOfClass(a1, v8) & 1) == 0)
    {
      CFDateRef v6 = 0LL;
      goto LABEL_223;
    }

    id v9 = +[NSMutableDictionary dictionary](&OBJC_CLASS___NSMutableDictionary, "dictionary");
    if (!a2 || [a2 containsObject:&off_100204860])
    {
      objc_msgSend(v9, "addEntriesFromDictionary:", objc_msgSend(a1, "OSSpecificAttributes"));
      if (![v9 objectForKey:@"AP_MODE"]) {
        [v9 setObject:&off_100204818 forKeyedSubscript:@"AP_MODE"];
      }
    }

    id v10 = [a1 coreWiFiSpecificAttributes];
    uint64_t v84 = CWFCoreWiFiSpecificAttributesKey;
    objc_msgSend(v9, "setObject:forKeyedSubscript:", v10);
    v82 = v4;
    if (a2)
    {
      if ([a2 containsObject:&off_100204878])
      {
        objc_msgSend(v9, "setObject:forKeyedSubscript:", objc_msgSend(a1, "SSID"), @"SSID");
        objc_msgSend(v9, "setObject:forKeyedSubscript:", objc_msgSend(a1, "networkName"), @"SSID_STR");
      }

      if (([a2 containsObject:&off_100204890] & 1) == 0)
      {
LABEL_61:
        if (![a2 containsObject:&off_100204908])
        {
LABEL_65:
LABEL_66:
          if ([a1 hiddenState] == (id)1)
          {
            unsigned int v32 = &__kCFBooleanTrue;
          }

          else
          {
            if ([a1 hiddenState] != (id)2) {
              goto LABEL_71;
            }
            unsigned int v32 = &__kCFBooleanFalse;
          }

          [v9 setObject:v32 forKeyedSubscript:@"UserDirected"];
LABEL_71:
          if (!a2)
          {
LABEL_73:
            if (!a2)
            {
              objc_msgSend(v9, "setObject:forKeyedSubscript:", objc_msgSend(a1, "payloadUUID"), @"PayloadUUID");
LABEL_81:
              objc_msgSend(v9, "setObject:forKeyedSubscript:", objc_msgSend(a1, "bundleID"), @"BundleIdentifier");
              if (!a2)
              {
                else {
                  id v34 = &__kCFBooleanTrue;
                }
                [v9 setObject:v34 forKeyedSubscript:@"enabled"];
LABEL_93:
                id v35 = [a1 lowDataMode];
                id v36 = &off_100204758;
                if (v35 == (id)2) {
                  id v36 = &off_100204818;
                }
                if (v35 == (id)1) {
                  id v37 = &off_100204770;
                }
                else {
                  id v37 = v36;
                }
                [v9 setObject:v37 forKeyedSubscript:@"SaveDataMode"];
                if (!a2)
                {
                  objc_msgSend( v9,  "setObject:forKeyedSubscript:",  objc_msgSend(a1, "lastJoinedByUserAt"),  @"lastJoined");
LABEL_104:
                  objc_msgSend( v9,  "setObject:forKeyedSubscript:",  objc_msgSend(a1, "lastJoinedBySystemAt"),  @"lastAutoJoined");
                  if (!a2)
                  {
LABEL_106:
                    id v38 = [a1 addReason];
                    CFIndex v39 = 0LL;
                    id v40 = &off_1002047B8;
                    char v41 = 1;
                    double v42 = &off_100204770;
                    switch((unint64_t)v38)
                    {
                      case 2uLL:
                      case 3uLL:
                      case 4uLL:
                      case 5uLL:
                        goto LABEL_107;
                      case 6uLL:
                        double v42 = &off_100204848;
                        goto LABEL_107;
                      case 7uLL:
                        CFIndex v39 = 0LL;
                        id v40 = &off_100204770;
                        double v42 = &off_100204830;
                        goto LABEL_119;
                      case 8uLL:
                        double v42 = &off_100204788;
                        goto LABEL_107;
                      case 9uLL:
                        double v42 = &off_100204A10;
                        goto LABEL_107;
                      case 0xAuLL:
                        CFIndex v39 = 0LL;
                        double v42 = &off_100204818;
                        goto LABEL_119;
                      case 0xBuLL:
                        double v42 = &off_1002048C0;
                        goto LABEL_107;
                      case 0xCuLL:
                        CFIndex v39 = 0LL;
                        id v40 = &off_100204770;
                        double v42 = &off_1002047A0;
                        goto LABEL_119;
                      case 0xDuLL:
                        double v42 = &off_1002047A0;
LABEL_107:
                        double v43 = @"WiFiManagerKnownNetworksEventType";
                        double v44 = v9;
                        uint64_t v45 = v42;
                        goto LABEL_121;
                      case 0xEuLL:
                        CFIndex v39 = 0LL;
                        double v42 = &off_100204758;
                        goto LABEL_119;
                      case 0xFuLL:
                        goto LABEL_119;
                      case 0x10uLL:
                        [v9 setObject:&off_1002049F8 forKeyedSubscript:@"WiFiManagerKnownNetworksEventType"];
                        CFIndex v39 = &off_100204890;
                        goto LABEL_120;
                      case 0x11uLL:
                        char v41 = 0;
                        CFIndex v39 = &off_100204878;
                        id v40 = &off_1002049F8;
                        double v42 = &off_100204788;
LABEL_119:
                        [v9 setObject:v40 forKeyedSubscript:@"WiFiManagerKnownNetworksEventType"];
                        [v9 setObject:v42 forKeyedSubscript:@"NetworkOriginator"];
                        if ((v41 & 1) == 0)
                        {
LABEL_120:
                          double v43 = @"WiFiNetworkAttributeSource";
                          double v44 = v9;
                          uint64_t v45 = v39;
LABEL_121:
                          [v44 setObject:v45 forKeyedSubscript:v43];
                        }

                        break;
                      default:
                        break;
                    }

                    if (!a2)
                    {
                      objc_msgSend( v9,  "setObject:forKeyedSubscript:",  objc_msgSend(a1, "addedAt", v40),  @"addedAt");
LABEL_128:
                      id v46 = [a1 EAPProfile];
                      if (v46)
                      {
                        __int128 v90 = @"EAPClientConfiguration";
                        id v91 = v46;
                        double v47 = +[NSDictionary dictionaryWithObjects:forKeys:count:]( &OBJC_CLASS___NSDictionary,  "dictionaryWithObjects:forKeys:count:",  &v91,  &v90,  1LL);
                      }

                      else
                      {
                        double v47 = 0LL;
                      }

                      [v9 setObject:v47 forKeyedSubscript:@"EnterpriseProfile"];
                      if (!a2)
                      {
                        objc_msgSend( v9,  "setObject:forKeyedSubscript:",  objc_msgSend(a1, "domainName"),  @"DomainName");
LABEL_137:
                        objc_msgSend( v9,  "setObject:forKeyedSubscript:",  objc_msgSend(a1, "displayedOperatorName"),  @"DisplayedOperatorName");
                        if (!a2)
                        {
                          objc_msgSend( v9,  "setObject:forKeyedSubscript:",  +[NSNumber numberWithBool:]( NSNumber,  "numberWithBool:",  objc_msgSend(a1, "isServiceProviderRoamingEnabled")),  @"SPRoaming");
LABEL_143:
                          objc_msgSend( v9,  "setObject:forKeyedSubscript:",  objc_msgSend(a1, "cellularNetworkInfo"),  @"MCCandMNC");
                          if (!a2)
                          {
                            objc_msgSend( v9,  "setObject:forKeyedSubscript:",  objc_msgSend(a1, "NAIRealmNameList"),  @"NaiRealmName");
LABEL_149:
                            objc_msgSend( v9,  "setObject:forKeyedSubscript:",  objc_msgSend(a1, "roamingConsortiumList"),  @"RoamingConsortiumOIs");
                            if (!a2)
                            {
                              objc_msgSend( v9,  "setObject:forKeyedSubscript:",  objc_msgSend(a1, "userPreferredNetworkNames"),  @"userPreferredNetworkNames");
LABEL_155:
                              objc_msgSend( v9,  "setObject:forKeyedSubscript:",  objc_msgSend(a1, "userPreferredPasspointDomains"),  @"userPreferredPasspointDomains");
                              if (!a2)
                              {
                                objc_msgSend( v9,  "setObject:forKeyedSubscript:",  objc_msgSend(a1, "networkGroupID"),  @"networkGroupID");
LABEL_161:
                                objc_msgSend( v9,  "setObject:forKeyedSubscript:",  objc_msgSend(a1, "networkGroupPriority"),  @"networkGroupPriority");
                                if (!a2)
                                {
                                  objc_msgSend( v9,  "setObject:forKeyedSubscript:",  objc_msgSend(a1, "lastDiscoveredAt"),  @"discoveredAt");
LABEL_167:
                                  id v48 = +[NSMutableSet set](&OBJC_CLASS___NSMutableSet, "set");
                                  id v49 = [a1 BSSList];
                                  if (v49)
                                  {
                                    double v50 = v49;
                                    unsigned __int8 v79 = a2;
                                    unsigned __int8 v80 = v9;
                                    v81 = a1;
                                    __int128 v87 = 0u;
                                    __int128 v88 = 0u;
                                    __int128 v85 = 0u;
                                    __int128 v86 = 0u;
                                    id v51 = [v49 countByEnumeratingWithState:&v85 objects:v89 count:16];
                                    if (v51)
                                    {
                                      id v52 = v51;
                                      id v53 = 0LL;
                                      uint64_t v54 = *(void *)v86;
                                      id v55 = &ACAccountStoreDidChangeNotification_ptr;
                                      unsigned __int8 v83 = v50;
                                      do
                                      {
                                        for (CFIndex i = 0LL; i != v52; CFIndex i = (char *)i + 1)
                                        {
                                          if (*(void *)v86 != v54) {
                                            objc_enumerationMutation(v50);
                                          }
                                          CFIndex v57 = *(void **)(*((void *)&v85 + 1) + 8LL * (void)i);
                                          id v58 = [v57 BSSID];
                                          if (v58)
                                          {
                                            id v59 = (const char *)[v58 UTF8String];
                                            if (v59)
                                            {
                                              id v60 = ether_aton(v59);
                                              if (v60)
                                              {
                                                id v61 = ether_ntoa(v60);
                                                if (v61)
                                                {
                                                  id v62 = [(id)v55[407] stringWithUTF8String:v61];
                                                  if (v62)
                                                  {
                                                    id v63 = v62;
                                                    if (([v48 containsObject:v62] & 1) == 0)
                                                    {
                                                      [v48 addObject:v63];
                                                      id v64 = +[NSMutableDictionary dictionary]( &OBJC_CLASS___NSMutableDictionary,  "dictionary");
                                                      objc_msgSend( v64,  "addEntriesFromDictionary:",  objc_msgSend(v57, "OSSpecificAttributes"));
                                                      [v64 setObject:v63 forKeyedSubscript:@"BSSID"];
                                                      id v65 = [v57 channel];
                                                      if (v65)
                                                      {
                                                        v66 = v65;
                                                        objc_msgSend( v64,  "setObject:forKeyedSubscript:",  +[NSNumber numberWithUnsignedInteger:]( NSNumber,  "numberWithUnsignedInteger:",  objc_msgSend(v65, "channel")),  @"CHANNEL");
                                                        objc_msgSend( v64,  "setObject:forKeyedSubscript:",  +[NSNumber numberWithUnsignedInt:]( NSNumber,  "numberWithUnsignedInt:",  objc_msgSend(v66, "flags")),  @"CHANNEL_FLAGS");
                                                      }

                                                      id v67 = [v57 location];
                                                      if (v67)
                                                      {
                                                        uint64_t v68 = v67;
                                                        [v67 coordinate];
                                                        [v64 setObject:[NSNumber numberWithDouble:v64] forKeyedSubscript:@"networkLocnLat"];
                                                        [v68 coordinate];
                                                        [v64 setObject:+[NSNumber numberWithDouble:]( NSNumber,  "numberWithDouble:",  v69) forKeyedSubscript:@"networkLocnLong"];
                                                        [v68 horizontalAccuracy];
                                                        [v64 setObject:+[NSNumber numberWithDouble:]( NSNumber,  "numberWithDouble:") forKeyedSubscript:@"networkLocnAccuracy"];
                                                        objc_msgSend( v64,  "setObject:forKeyedSubscript:",  objc_msgSend(v68, "timestamp"),  @"networkLocnTimestamp");
                                                      }

                                                      objc_msgSend( v64,  "setObject:forKeyedSubscript:",  objc_msgSend(v57, "lastAssociatedAt"),  @"lastRoamed");
                                                      id v70 = [v57 colocated2GHzRNRChannel];
                                                      if (v70)
                                                      {
                                                        id v71 = v70;
                                                        objc_msgSend( v64,  "setObject:forKeyedSubscript:",  +[NSNumber numberWithUnsignedInteger:]( NSNumber,  "numberWithUnsignedInteger:",  objc_msgSend(v70, "channel")),  @"colocated2GHzRNRChannel");
                                                        objc_msgSend( v64,  "setObject:forKeyedSubscript:",  +[NSNumber numberWithUnsignedInt:]( NSNumber,  "numberWithUnsignedInt:",  objc_msgSend(v71, "flags")),  @"colocated2GHzRNRChannelFlags");
                                                      }

                                                      id v72 = [v57 colocated5GHzRNRChannel];
                                                      if (v72)
                                                      {
                                                        uint64_t v73 = v72;
                                                        objc_msgSend( v64,  "setObject:forKeyedSubscript:",  +[NSNumber numberWithUnsignedInteger:]( NSNumber,  "numberWithUnsignedInteger:",  objc_msgSend(v72, "channel")),  @"colocated5GHzRNRChannel");
                                                        objc_msgSend( v64,  "setObject:forKeyedSubscript:",  +[NSNumber numberWithUnsignedInt:]( NSNumber,  "numberWithUnsignedInt:",  objc_msgSend(v73, "flags")),  @"colocated5GHzRNRChannelFlags");
                                                      }

                                                      objc_msgSend( v64,  "setObject:forKeyedSubscript:",  objc_msgSend(v57, "AWDLRealTimeModeTimestamp"),  @"AWDLRealTimeModeTimestamp");
                                                      objc_msgSend( v64,  "setObject:forKeyedSubscript:",  objc_msgSend(v57, "IPv4NetworkSignature"),  @"IPv4NetworkSignature");
                                                      objc_msgSend( v64,  "setObject:forKeyedSubscript:",  objc_msgSend(v57, "IPv6NetworkSignature"),  @"IPv6NetworkSignature");
                                                      objc_msgSend( v64,  "setObject:forKeyedSubscript:",  objc_msgSend(v57, "DHCPServerID"),  @"DHCPServerID");
                                                      objc_msgSend( v64,  "setObject:forKeyedSubscript:",  objc_msgSend(v57, "DHCPv6ServerID"),  @"DHCPv6ServerID");
                                                      objc_msgSend( v64,  "setObject:forKeyedSubscript:",  objc_msgSend(v57, "coreWiFiSpecificAttributes"),  v84);
                                                      if (!v53) {
                                                        id v53 = +[NSMutableArray array]( &OBJC_CLASS___NSMutableArray,  "array");
                                                      }
                                                      [v53 addObject:v64];
                                                      double v50 = v83;
                                                      id v55 = &ACAccountStoreDidChangeNotification_ptr;
                                                    }
                                                  }
                                                }
                                              }
                                            }
                                          }
                                        }

                                        id v52 = [v50 countByEnumeratingWithState:&v85 objects:v89 count:16];
                                      }

                                      while (v52);
                                    }

                                    else
                                    {
                                      id v53 = 0LL;
                                    }

                                    id v9 = v80;
                                    [v80 setObject:v53 forKeyedSubscript:@"networkKnownBSSListKey"];
                                    a1 = v81;
                                    CFBooleanRef v4 = v82;
                                    a2 = v79;
                                  }

                                  if (!a2)
                                  {
                                    [v9 setObject:[NSNumber numberWithBool:[a1 isPrivacyProxyEnabled]] forKeyedSubscript:@"PrivacyProxyEnabled"];
                                    goto LABEL_201;
                                  }

LABEL_196:
                                  if ([a2 containsObject:&off_100204B78]) {
                                    objc_msgSend( v9,  "setObject:forKeyedSubscript:",  +[NSNumber numberWithBool:]( NSNumber,  "numberWithBool:",  objc_msgSend(a1, "isPrivacyProxyEnabled")),  @"PrivacyProxyEnabled");
                                  }
                                  if (([a2 containsObject:&off_100204B90] & 1) == 0)
                                  {
LABEL_202:
                                    if (![a2 containsObject:&off_100204BA8])
                                    {
LABEL_209:
LABEL_210:
                                      id v76 = [a1 publicAttribute];
                                      if (v76 == (id)1)
                                      {
                                        unsigned int v77 = &__kCFBooleanTrue;
                                      }

                                      else
                                      {
                                        if (v76 != (id)2) {
                                          goto LABEL_215;
                                        }
                                        unsigned int v77 = &__kCFBooleanFalse;
                                      }

                                      [v9 setObject:v77 forKeyedSubscript:@"WiFiNetworkAttributeIsPublic"];
LABEL_215:
                                      if (!a2)
                                      {
                                        objc_msgSend( v9,  "setObject:forKeyedSubscript:",  +[NSNumber numberWithUnsignedInt:]( NSNumber,  "numberWithUnsignedInt:",  objc_msgSend(a1, "transitionDisabledFlags")),  @"TransitionDisabledFlags");
LABEL_221:
                                        objc_msgSend( v9,  "setObject:forKeyedSubscript:",  +[NSNumber numberWithBool:]( NSNumber,  "numberWithBool:",  objc_msgSend(a1, "isStandalone6G")),  @"Standalone");
LABEL_222:
                                        objc_msgSend( v9,  "setObject:forKeyedSubscript:",  objc_msgSend(a1, "carplayUUID"),  @"CARPLAY_UUID");
                                        objc_msgSend( v9,  "setObject:forKeyedSubscript:",  +[NSNumber numberWithBool:]( NSNumber,  "numberWithBool:",  objc_msgSend(a1, "isPersonalHotspot")),  @"IsPersonalHotspot");
                                        objc_msgSend( v9,  "setObject:forKeyedSubscript:",  objc_msgSend(a1, "NANServiceID"),  @"WiFiNetworkNANServiceID");
                                        objc_msgSend( v9,  "setObject:forKeyedSubscript:",  +[NSNumber numberWithBool:]( NSNumber,  "numberWithBool:",  objc_msgSend(a1, "isPublicAirPlayNetwork")),  @"PublicAirPlayNetwork");
                                        objc_msgSend( v9,  "setObject:forKeyedSubscript:",  +[NSNumber numberWithBool:]( NSNumber,  "numberWithBool:",  objc_msgSend(a1, "isDNSHeuristicsFilteredNetwork")),  @"FilteredNetwork");
                                        objc_msgSend( v9,  "setObject:forKeyedSubscript:",  objc_msgSend(a1, "DNSHeuristicsFailureStateInfo"),  @"DNSFailures");
                                        CFDateRef v6 = sub_100094AAC((uint64_t)kCFAllocatorDefault, v9);
                                        goto LABEL_223;
                                      }

LABEL_216:
                                      if ([a2 containsObject:&off_100204BD8]) {
                                        objc_msgSend( v9,  "setObject:forKeyedSubscript:",  +[NSNumber numberWithUnsignedInt:]( NSNumber,  "numberWithUnsignedInt:",  objc_msgSend(a1, "transitionDisabledFlags")),  @"TransitionDisabledFlags");
                                      }
                                      goto LABEL_221;
                                    }

LABEL_203:
                                    id v74 = [a1 movingAttribute];
                                    if (v74 == (id)1)
                                    {
                                      id v75 = &__kCFBooleanTrue;
                                    }

                                    else
                                    {
                                      if (v74 != (id)2) {
                                        goto LABEL_208;
                                      }
                                      id v75 = &__kCFBooleanFalse;
                                    }

                                    [v9 setObject:v75 forKeyedSubscript:@"WiFiNetworkAttributeIsMoving"];
LABEL_208:
                                    if (!a2) {
                                      goto LABEL_210;
                                    }
                                    goto LABEL_209;
                                  }

LABEL_201:
                                  objc_msgSend( v9,  "setObject:forKeyedSubscript:",  objc_msgSend(a1, "privacyProxyBlockedReason"),  @"PrivacyProxyBlockedReason");
                                  if (!a2) {
                                    goto LABEL_203;
                                  }
                                  goto LABEL_202;
                                }

LABEL_162:
                                if ([a2 containsObject:&off_100204B48]) {
                                  objc_msgSend( v9,  "setObject:forKeyedSubscript:",  objc_msgSend(a1, "lastDiscoveredAt"),  @"discoveredAt");
                                }
                                goto LABEL_167;
                              }

          __int128 v88 = objc_autoreleasePoolPush();
          if (qword_100219F60) {
            [qword_100219F60 WFLog:@"Retrying (WFMacRandomisation : Attempting again for migration? <%d> autojoin association of %@ with retry count %ld" message:3 v101 sub_100095BC8(v107) *(void *)(a1 + 1120)];
          }
          objc_autoreleasePoolPop(v88);
          *(int64x2_t *)(a1 + 1112) = vaddq_s64(*(int64x2_t *)(a1 + 1112), (int64x2_t)xmmword_10017FBE0);
          uint64_t v84 = v106;
          goto LABEL_166;
        }

        if (CFArrayGetCount(v85))
        {
          uint64_t v84 = v106;
          if (*(void *)(a1 + 1120) < 2uLL) {
            goto LABEL_162;
          }
          goto LABEL_160;
        }

        break;
    }

    uint64_t v84 = v106;
    goto LABEL_160;
  }

  id v52 = (uint64_t)sub_1000F17B8(a1);
LABEL_168:
  __int128 v89 = objc_autoreleasePoolPush();
  if (qword_100219F60) {
    [qword_100219F60 WFLog:@"__WiFiDeviceManagerProcessAssociationResult: error %d, state %d\n" message:3];
  }
  objc_autoreleasePoolPop(v89);
  if (_os_feature_enabled_impl("CoreWiFi", "UnifiedAutoJoin"))
  {
    if ((_DWORD)v52 == 14)
    {
      id v52 = 14LL;
    }

    else
    {
      sub_10010D14C(a1, @"autoJoinAssociationFailure", 0LL, 0LL);
      sub_100109874(a1, (uint64_t)a2, (int)a4, CWFManagerErrorDomain, (uint64_t)@"Association failed");
      id v52 = 0LL;
    }
  }

  else
  {
    if ((_DWORD)v52 == 12) {
      id v52 = sub_10010824C(a1);
    }
  }

  if (v11) {
    CFRelease(v11);
  }
LABEL_77:
  objc_autoreleasePoolPop(context);
  return v52;
}

LABEL_156:
                              if ([a2 containsObject:&off_100204B18]) {
                                objc_msgSend( v9,  "setObject:forKeyedSubscript:",  objc_msgSend(a1, "networkGroupID"),  @"networkGroupID");
                              }
                              goto LABEL_161;
                            }

  if (values) {
    CFRelease(values);
  }
  return v11;
}

LABEL_150:
                            if ([a2 containsObject:&off_100204AE8]) {
                              objc_msgSend( v9,  "setObject:forKeyedSubscript:",  objc_msgSend(a1, "userPreferredNetworkNames"),  @"userPreferredNetworkNames");
                            }
                            goto LABEL_155;
                          }

      objc_autoreleasePoolPop(v53);
      goto LABEL_151;
    }

    if (v63)
    {
      char v41 = sub_10009A340((uint64_t)v63);
      double v42 = (const __CFDate *)sub_10009A1FC(v63);
      if (v42)
      {
        char v41 = v41 + CFDateGetTimeIntervalSinceDate(v5, v42);
LABEL_108:
        if (v41 < (double)v60)
        {
          uint64_t v7 = 1LL;
          CFDateRef v6 = v63;
LABEL_151:
          if (theArray)
          {
            sub_10009A95C((uint64_t)v40, theArray);
            CFRelease(theArray);
          }

LABEL_144:
                          if ([a2 containsObject:&off_100204AB8]) {
                            objc_msgSend( v9,  "setObject:forKeyedSubscript:",  objc_msgSend(a1, "NAIRealmNameList"),  @"NaiRealmName");
                          }
                          goto LABEL_149;
                        }

LABEL_138:
                        if ([a2 containsObject:&off_100204A88]) {
                          objc_msgSend( v9,  "setObject:forKeyedSubscript:",  +[NSNumber numberWithBool:]( NSNumber,  "numberWithBool:",  objc_msgSend(a1, "isServiceProviderRoamingEnabled")),  @"SPRoaming");
                        }
                        goto LABEL_143;
                      }

id sub_1000A335C(uint64_t a1)
{
  id v2 = objc_autoreleasePoolPush();
  if (sub_1000A3ACC()
    && (uint64_t v3 = sub_1000A3B94(), a1)
    && v3
    && (CFDictionaryRef Copy = CFDictionaryCreateCopy(kCFAllocatorDefault, *(CFDictionaryRef *)(a1 + 16))) != 0LL)
  {
    CFDictionaryRef v5 = Copy;
    id v22 = v2;
    id v6 = [sub_1000951FC(a1, @"HS20GasResponse") mutableCopy];
    [v6 setObject:0 forKeyedSubscript:@"ANQP_STATUS"];
    [v6 setObject:0 forKeyedSubscript:@"BSSID"];
    [v6 setObject:0 forKeyedSubscript:@"CHANNEL"];
    [v6 setObject:0 forKeyedSubscript:@"CHANNEL_FLAGS"];
    id v7 = -[__CFDictionary mutableCopy](v5, "mutableCopy");
    [v7 setObject:v6 forKeyedSubscript:@"ANQP_PARSED"];
    id v8 = +[NSMutableDictionary dictionary](&OBJC_CLASS___NSMutableDictionary, "dictionary");
    __int128 v27 = 0u;
    __int128 v28 = 0u;
    __int128 v29 = 0u;
    __int128 v30 = 0u;
    id v9 = +[CWFScanResult supportedOSSpecificKeys](&OBJC_CLASS___CWFScanResult, "supportedOSSpecificKeys");
    id v10 = [v9 countByEnumeratingWithState:&v27 objects:v32 count:16];
    if (v10)
    {
      id v11 = v10;
      uint64_t v12 = *(void *)v28;
      do
      {
        for (CFIndex i = 0LL; i != v11; CFIndex i = (char *)i + 1)
        {
          if (*(void *)v28 != v12) {
            objc_enumerationMutation(v9);
          }
          objc_msgSend( v8,  "setObject:forKeyedSubscript:",  sub_1000951FC(a1, *(void **)(*((void *)&v27 + 1) + 8 * (void)i)),  *(void *)(*((void *)&v27 + 1) + 8 * (void)i));
        }

        id v11 = [v9 countByEnumeratingWithState:&v27 objects:v32 count:16];
      }

      while (v11);
    }

    if ([v8 count]) {
      id v14 = v8;
    }
    else {
      id v14 = 0LL;
    }
    [v7 setObject:v14 forKeyedSubscript:sub_1000A3B94()];
    v34[0] = @"IsWiFiNetworkShareble";
    v34[1] = @"NetworkOriginator";
    v34[2] = @"CaptiveBypass";
    v34[3] = @"DiagnosticsBssEnv";
    v34[4] = @"DisableWiFiAutoJoinUntilFirstUserJoin";
    v34[5] = @"DisplayedOperatorName";
    v34[6] = @"DomainName";
    v34[7] = @"HS20GasResponse";
    v34[8] = @"HS20HomeOperatorNetwork";
    v34[9] = @"HS20ProvisionedNetwork";
    v34[10] = @"HS2NetworkBadge";
    v34[11] = @"HS20AccountName";
    v34[12] = @"MCCandMNC";
    v34[13] = @"NaiRealmName";
    v34[14] = @"NetworkAtLocationOfInterestType";
    v34[15] = @"WiFiNetworkAttributeHighPopularity";
    v34[16] = @"WiFiNetworkAttributeHighQuality";
    v34[17] = @"WiFiNetworkAttributeIsMoving";
    v34[18] = @"WiFiNetworkAttributeIsPotentiallyCaptive";
    v34[19] = @"WiFiNetworkAttributeIsPotentiallyMoving";
    v34[20] = @"WiFiNetworkAttributeIsSuspicious";
    v34[21] = @"WiFiNetworkAttributeIsTCPGood";
    v34[22] = @"WiFiNetworkAttributeLowPopularity";
    v34[23] = @"WiFiNetworkAttributeLowQuality";
    v34[24] = @"WiFiNetworkAttributePopularityScore";
    v34[25] = @"WiFiNetworkAttributeProminentDisplay";
    v34[26] = @"WiFiNetworkAttributeQualityScore";
    v34[27] = @"WiFiNetworkAttributeSource";
    v34[28] = @"BundleIdentifier";
    v34[29] = @"SIMIdentifiers";
    v34[30] = @"WiFiNetworkDisabledUntilDate";
    v34[31] = @"EnterpriseProfile";
    v34[32] = @"WiFiNetworkExpirationDate";
    v34[33] = @"NetworkForcedHomeFix";
    v34[34] = @"kWiFiNetworkLastHomeForceFixDateKey";
    v34[35] = @"NetworkOfInterestHomeState";
    v34[36] = @"NetworkOfInterestWorkState";
    v34[37] = @"WiFiNetworkPasswordModificationDate";
    v34[38] = @"PayloadUUID";
    v34[39] = @"SaveDataMode";
    v34[40] = @"NetworkQualityResponsiveness";
    v34[41] = @"NetworkQualityDate";
    v34[42] = @"ShareableEAPConfig";
    v34[43] = @"ShareableEAPTrustExceptions";
    v34[44] = @"ShareableStatus";
    v34[45] = @"ShareMode";
    v34[46] = @"kWiFiNetworkSSIDHarvestStatusKey";
    v34[47] = @"UserRole";
    v34[48] = @"WalletIdentifier";
    v34[49] = @"addedAt";
    v34[50] = @"knownBSSUpdatedDate";
    v34[51] = @"lastAutoJoined";
    v34[52] = @"lastJoined";
    v34[53] = @"lastRoamed";
    v34[54] = @"lastUpdated";
    v34[55] = @"WiFiManagerKnownNetworksEventType";
    v34[56] = @"networkDisabledClientName";
    v34[57] = @"networkDisabledReason";
    v34[58] = @"networkDisabledTimestamp";
    v34[59] = @"enabled";
    v34[60] = @"networkKnownBSSListKey";
    v34[61] = @"scanWasDirected";
    v34[62] = @"prevJoined";
    v34[63] = @"UserDirected";
    v34[64] = @"networkUsage";
    v34[65] = @"RoamingConsortiumOIs";
    v34[66] = @"SPRoaming";
    v34[67] = @"PolicyUUID";
    v34[68] = @"PrivacyProxyEnabled";
    v34[69] = @"TransitionDisabledFlags";
    v34[70] = @"Standalone";
    v34[71] = @"PublicAirPlayNetwork";
    v34[72] = @"PrivacyProxyBlockedReason";
    v34[73] = @"FilteredNetwork";
    v34[74] = @"DNSFailures";
    uint64_t v15 = +[NSArray arrayWithObjects:count:](&OBJC_CLASS___NSArray, "arrayWithObjects:count:", v34, 75LL);
    if (&_CNForgetSSID)
    {
      v33[0] = kCNSCaptiveNetworkProperty;
      v33[1] = kCNSNetworkWasCaptiveProperty;
      uint64_t v15 = -[NSArray arrayByAddingObjectsFromArray:]( v15,  "arrayByAddingObjectsFromArray:",  +[NSArray arrayWithObjects:count:](&OBJC_CLASS___NSArray, "arrayWithObjects:count:", v33, 2LL));
    }

    __int128 v23 = 0u;
    __int128 v24 = 0u;
    __int128 v25 = 0u;
    __int128 v26 = 0u;
    id v16 = -[NSArray countByEnumeratingWithState:objects:count:]( v15,  "countByEnumeratingWithState:objects:count:",  &v23,  v31,  16LL);
    if (v16)
    {
      id v17 = v16;
      uint64_t v18 = *(void *)v24;
      do
      {
        for (CFIndex j = 0LL; j != v17; CFIndex j = (char *)j + 1)
        {
          if (*(void *)v24 != v18) {
            objc_enumerationMutation(v15);
          }
          [v7 setObject:0 forKeyedSubscript:*(void *)(*((void *)&v23 + 1) + 8 * (void)j)];
        }

        id v17 = -[NSArray countByEnumeratingWithState:objects:count:]( v15,  "countByEnumeratingWithState:objects:count:",  &v23,  v31,  16LL);
      }

      while (v17);
    }

    id v20 = [objc_alloc((Class)sub_1000A3ACC()) initWithScanRecord:v7 includeProperties:0];
    objc_autoreleasePoolPop(v22);
    CFRelease(v5);
  }

  else
  {
    objc_autoreleasePoolPop(v2);
    return 0LL;
  }

  return v20;
}

uint64_t sub_1000A3ACC()
{
  uint64_t v3 = 0LL;
  CFBooleanRef v4 = &v3;
  uint64_t v5 = 0x3052000000LL;
  id v6 = sub_1000A671C;
  id v7 = sub_1000A672C;
  uint64_t v0 = qword_1002199A0;
  uint64_t v8 = qword_1002199A0;
  if (!qword_1002199A0)
  {
    v2[0] = _NSConcreteStackBlock;
    v2[1] = 3221225472LL;
    v2[2] = sub_1000A69D8;
    v2[3] = &unk_1001E42A0;
    v2[4] = &v3;
    sub_1000A69D8((uint64_t)v2);
    uint64_t v0 = v4[5];
  }

  _Block_object_dispose(&v3, 8);
  return v0;
}

void sub_1000A3B7C( _Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, ...)
{
}

uint64_t sub_1000A3B94()
{
  uint64_t v3 = 0LL;
  CFBooleanRef v4 = &v3;
  uint64_t v5 = 0x2020000000LL;
  uint64_t v0 = (void *)qword_1002199A8;
  uint64_t v6 = qword_1002199A8;
  if (!qword_1002199A8)
  {
    uint64_t v1 = (void *)sub_1000A678C();
    uint64_t v0 = dlsym(v1, "CWFScanResultPropertyOSSpecificAttributesKey");
    v4[3] = (uint64_t)v0;
    qword_1002199A8 = (uint64_t)v0;
  }

  _Block_object_dispose(&v3, 8);
  if (!v0) {
    sub_10015437C();
  }
  return *(void *)v0;
}

void sub_1000A3C18( _Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9)
{
}

uint64_t sub_1000A3C30(const void **a1, const __CFDictionary **a2)
{
  CFBooleanRef v4 = sub_1000951FC((uint64_t)a1, @"WiFiNetworkNANServiceID");
  uint64_t v5 = sub_1000951FC((uint64_t)a2, @"WiFiNetworkNANServiceID");
  if (v4) {
    BOOL v6 = v5 == 0LL;
  }
  else {
    BOOL v6 = 1;
  }
  if (!v6 && CFEqual(v4, v5)) {
    return 1LL;
  }
  uint64_t result = 0LL;
  if (!a1 || !a2) {
    return result;
  }
  if (!sub_100099458(a1[2], a2[2]))
  {
    if (!sub_1000A6408(a1, a2, 0))
    {
      int v8 = sub_10009959C((uint64_t)a1, (uint64_t)a2);
      return v8 != 0;
    }

    return 1LL;
  }

  if ((!sub_100095318((BOOL)a1) || sub_100095318((BOOL)a2))
    && (sub_100095318((BOOL)a1) || !sub_100095318((BOOL)a2)))
  {
    uint64_t result = sub_1000A6668((const __CFDictionary *)a1[2], a2[2]);
    if (!(_DWORD)result) {
      return result;
    }
    int v8 = sub_1000994B0(a1[2], a2[2], @"AP_MODE");
    return v8 != 0;
  }

  id v9 = objc_autoreleasePoolPush();
  id v10 = (void *)qword_100219F60;
  if (qword_100219F60)
  {
    id v11 = sub_10009D454((uint64_t)a1);
    [v10 WFLog:3, "%s: Same SSID HS20 networks - network1: %@ (domain='%@'), network2: %@ (domain='%@')", "__WiFiNetworkEqualIgnoreAuthType", a1, v11, a2, sub_10009D454((uint64_t)a2) message];
  }

  objc_autoreleasePoolPop(v9);
  return 0LL;
}

void *sub_1000A3DB0(void *a1)
{
  id v2 = objc_autoreleasePoolPush();
  uint64_t v3 = sub_1000A3ACC();
  if (a1
    && v3
    && (v4 = sub_1000A3ACC(), uint64_t v5 = objc_opt_class(v4), (objc_opt_isKindOfClass(a1, v5) & 1) != 0)
    && (id v6 = objc_msgSend(objc_msgSend(a1, "scanRecord"), "mutableCopy")) != 0
    && (id v7 = v6,
        objc_msgSend(v6, "addEntriesFromDictionary:", objc_msgSend(a1, "OSSpecificAttributes")),
        (int v8 = sub_100094AAC((uint64_t)kCFAllocatorDefault, v7)) != 0LL))
  {
    id v9 = v8;
    id v10 = [a1 matchingKnownNetworkProfile];
    if (v10)
    {
      id v11 = (CFDictionaryRef *)sub_1000A1DEC(v10, 0LL);
      uint64_t v12 = v11;
      if (v11 && (CFDictionaryRef Copy = CFDictionaryCreateCopy(kCFAllocatorDefault, v11[2])) != 0LL)
      {
        CFDictionaryRef v14 = Copy;
        id v15 = [v7 copy];
        [v7 setDictionary:v14];
        [v7 addEntriesFromDictionary:v15];
        id v16 = sub_100094AAC((uint64_t)kCFAllocatorDefault, v7);
        CFRelease(v14);
      }

      else
      {
        id v16 = 0LL;
      }
    }

    else
    {
      id v16 = (void *)CFRetain(v9);
      uint64_t v12 = 0LL;
    }

    id v17 = sub_1000951FC((uint64_t)v12, @"WPA_IE");
    uint64_t v18 = sub_1000951FC((uint64_t)v9, @"WPA_IE");
    unsigned int v19 = sub_1000951FC((uint64_t)v12, @"RSN_IE");
    id v20 = sub_1000951FC((uint64_t)v9, @"RSN_IE");
    if (v19 && v17 && v20 && !v18) {
      sub_10009582C((uint64_t)v16, @"WPA_IE", 0LL);
    }
    objc_autoreleasePoolPop(v2);
    if (v12) {
      CFRelease(v12);
    }
    CFRelease(v9);
  }

  else
  {
    objc_autoreleasePoolPop(v2);
    return 0LL;
  }

  return v16;
}

CFDictionaryRef sub_1000A3FB0(const __CFDictionary *result)
{
  if (result)
  {
    uint64_t result = (const __CFDictionary *)sub_1000951FC((uint64_t)result, @"WPS_PROB_RESP_IE");
    if (result)
    {
      uint64_t result = (const __CFDictionary *)CFDictionaryGetValue(result, @"IE_KEY_WPS_MANUFACTURER");
      if (result)
      {
        uint64_t v1 = result;
        CFTypeID TypeID = CFStringGetTypeID();
        if (TypeID == CFGetTypeID(v1)) {
          return v1;
        }
        else {
          return 0LL;
        }
      }
    }
  }

  return result;
}

CFDictionaryRef sub_1000A4008(const __CFDictionary *result)
{
  if (result)
  {
    uint64_t result = (const __CFDictionary *)sub_1000951FC((uint64_t)result, @"WPS_PROB_RESP_IE");
    if (result)
    {
      uint64_t result = (const __CFDictionary *)CFDictionaryGetValue(result, @"IE_KEY_WPS_MODEL_NAME");
      if (result)
      {
        uint64_t v1 = result;
        CFTypeID TypeID = CFStringGetTypeID();
        if (TypeID == CFGetTypeID(v1)) {
          return v1;
        }
        else {
          return 0LL;
        }
      }
    }
  }

  return result;
}

CFDictionaryRef sub_1000A4060(const __CFDictionary *result)
{
  if (result)
  {
    uint64_t result = (const __CFDictionary *)sub_1000951FC((uint64_t)result, @"WPS_PROB_RESP_IE");
    if (result)
    {
      uint64_t result = (const __CFDictionary *)CFDictionaryGetValue(result, @"IE_KEY_WPS_MODEL_NUM");
      if (result)
      {
        uint64_t v1 = result;
        CFTypeID TypeID = CFStringGetTypeID();
        if (TypeID == CFGetTypeID(v1)) {
          return v1;
        }
        else {
          return 0LL;
        }
      }
    }
  }

  return result;
}

uint64_t sub_1000A40B8(uint64_t a1)
{
  if (a1) {
    sub_1000951FC(a1, @"WPS_PROB_RESP_IE");
  }
  return 0LL;
}

CFDataRef sub_1000A40DC(const __CFData *a1, const __CFData *a2, const __CFData *a3, CFStringRef theString)
{
  CFDataRef v4 = 0LL;
  *(_OWORD *)md = 0u;
  __int128 v28 = 0u;
  *(void *)&__int128 v5 = 0xAAAAAAAAAAAAAAAALL;
  *((void *)&v5 + 1) = 0xAAAAAAAAAAAAAAAALL;
  bytes[0] = v5;
  bytes[1] = v5;
  if (a1 && a3)
  {
    if (theString)
    {
      id v9 = kCFAllocatorDefault;
      CFDataRef ExternalRepresentation = CFStringCreateExternalRepresentation(kCFAllocatorDefault, theString, 0x8000100u, 0);
    }

    else
    {
      if (SecRandomCopyBytes(kSecRandomDefault, 0x20uLL, bytes)) {
        return 0LL;
      }
      id v9 = kCFAllocatorDefault;
      CFDataRef ExternalRepresentation = CFDataCreate(kCFAllocatorDefault, (const UInt8 *)bytes, 32LL);
    }

    id v11 = ExternalRepresentation;
    CFMutableArrayRef Mutable = CFDataCreateMutable(v9, 0LL);
    if (Mutable)
    {
      BytePtr = CFDataGetBytePtr(v11);
      CFDictionaryRef v14 = CFDataGetBytePtr(a1);
      id v15 = CFDataGetBytePtr(a3);
      if (a2) {
        id v16 = CFDataGetBytePtr(a2);
      }
      else {
        id v16 = 0LL;
      }
      CFIndex Length = CFDataGetLength(a1);
      CFDataAppendBytes(Mutable, v14, Length);
      CFDataAppendBytes(Mutable, v15, 6LL);
      CFIndex v18 = CFDataGetLength(v11);
      CFDataAppendBytes(Mutable, BytePtr, v18);
      if (a2 && v16)
      {
        CFIndex v19 = CFDataGetLength(a2);
        CFDataAppendBytes(Mutable, v16, v19);
      }

      CFIndex v20 = CFDataGetLength(a1);
      CFIndex v21 = v20 + CFDataGetLength(v11) + 6;
      if (a2) {
        LODWORD(v21) = CFDataGetLength(a2) + v21;
      }
      MutableBytePtr = CFDataGetMutableBytePtr(Mutable);
      *(void *)&v25.wbuf[14] = 0xAAAAAAAAAAAAAAAALL;
      *(void *)&__int128 v23 = 0xAAAAAAAAAAAAAAAALL;
      *((void *)&v23 + 1) = 0xAAAAAAAAAAAAAAAALL;
      *(_OWORD *)&v25.wbuf[6] = v23;
      *(_OWORD *)&v25.wbuf[10] = v23;
      *(_OWORD *)&v25.hash[6] = v23;
      *(_OWORD *)&v25.wbuf[2] = v23;
      *(_OWORD *)v25.count = v23;
      *(_OWORD *)&v25.hash[2] = v23;
      CC_SHA256_Init(&v25);
      CC_SHA256_Update(&v25, MutableBytePtr, v21);
      CC_SHA256_Final(md, &v25);
    }

    v25.count[0] = *(_DWORD *)md;
    LOWORD(v25.count[1]) = *(_WORD *)&md[4];
    LOBYTE(v25.count[0]) = md[0] & 0xFC | 2;
    CFDataRef v4 = CFDataCreate(v9, (const UInt8 *)&v25, 6LL);
    if (Mutable) {
      CFRelease(Mutable);
    }
    if (v11) {
      CFRelease(v11);
    }
  }

  return v4;
}

CFDataRef sub_1000A4350(const __CFData *a1, const __CFData *a2, CFStringRef theString)
{
  CFDataRef v3 = 0LL;
  __int16 v22 = 0;
  *(_DWORD *)CFIndex v21 = 0;
  *(_OWORD *)md = 0u;
  __int128 v27 = 0u;
  *(void *)&__int128 v4 = 0xAAAAAAAAAAAAAAAALL;
  *((void *)&v4 + 1) = 0xAAAAAAAAAAAAAAAALL;
  bytes[0] = v4;
  bytes[1] = v4;
  *(_OWORD *)__int128 v23 = v4;
  __int128 v24 = v4;
  if (a1 && a2)
  {
    if (theString)
    {
      id v7 = kCFAllocatorDefault;
      CFDataRef ExternalRepresentation = CFStringCreateExternalRepresentation(kCFAllocatorDefault, theString, 0x8000100u, 0);
      id v9 = kSecRandomDefault;
    }

    else
    {
      id v9 = kSecRandomDefault;
      if (SecRandomCopyBytes(kSecRandomDefault, 0x20uLL, v23)) {
        return 0LL;
      }
      id v7 = kCFAllocatorDefault;
      CFDataRef ExternalRepresentation = CFDataCreate(kCFAllocatorDefault, v23, 32LL);
    }

    if (SecRandomCopyBytes(v9, 0x20uLL, bytes))
    {
      CFDataRef v3 = 0LL;
    }

    else
    {
      CFMutableArrayRef Mutable = CFDataCreateMutable(v7, 0LL);
      if (Mutable)
      {
        BytePtr = CFDataGetBytePtr(ExternalRepresentation);
        uint64_t v12 = CFDataGetBytePtr(a1);
        unsigned __int16 v13 = CFDataGetBytePtr(a2);
        CFIndex Length = CFDataGetLength(a1);
        CFDataAppendBytes(Mutable, v12, Length);
        CFDataAppendBytes(Mutable, v13, 6LL);
        CFIndex v15 = CFDataGetLength(ExternalRepresentation);
        CFDataAppendBytes(Mutable, BytePtr, v15);
        CFDataAppendBytes(Mutable, (const UInt8 *)bytes, 32LL);
        int v16 = CFDataGetLength(a1);
        LODWORD(v13) = v16 + CFDataGetLength(ExternalRepresentation);
        MutableBytePtr = CFDataGetMutableBytePtr(Mutable);
        *(void *)&v20.wbuf[14] = 0xAAAAAAAAAAAAAAAALL;
        *(void *)&__int128 v18 = 0xAAAAAAAAAAAAAAAALL;
        *((void *)&v18 + 1) = 0xAAAAAAAAAAAAAAAALL;
        *(_OWORD *)&v20.wbuf[6] = v18;
        *(_OWORD *)&v20.wbuf[10] = v18;
        *(_OWORD *)&v20.hash[6] = v18;
        *(_OWORD *)&v20.wbuf[2] = v18;
        *(_OWORD *)v20.count = v18;
        *(_OWORD *)&v20.hash[2] = v18;
        CC_SHA256_Init(&v20);
        CC_SHA256_Update(&v20, MutableBytePtr, (_DWORD)v13 + 38);
        CC_SHA256_Final(md, &v20);
      }

      *(_DWORD *)CFIndex v21 = *(_DWORD *)md;
      __int16 v22 = *(_WORD *)&md[4];
      v21[0] = md[0] & 0xFC | 2;
      CFDataRef v3 = CFDataCreate(v7, v21, 6LL);
      if (Mutable) {
        CFRelease(Mutable);
      }
    }

    if (ExternalRepresentation) {
      CFRelease(ExternalRepresentation);
    }
  }

  return v3;
}

CFDataRef sub_1000A45B8(const __CFData *a1, const __CFString *a2)
{
  CFDataRef v2 = 0LL;
  *(void *)&__int128 v3 = 0xAAAAAAAAAAAAAAAALL;
  *((void *)&v3 + 1) = 0xAAAAAAAAAAAAAAAALL;
  *(_OWORD *)bytes = v3;
  __int128 v19 = v3;
  *(_OWORD *)md = 0u;
  __int128 v17 = 0u;
  if (a1 && a2)
  {
    CFDataRef ExternalRepresentation = CFStringCreateExternalRepresentation(kCFAllocatorDefault, a2, 0x8000100u, 0);
    CFMutableDataRef Mutable = CFDataCreateMutable(kCFAllocatorDefault, 0LL);
    if (!Mutable)
    {
      *(_OWORD *)bytes = 0u;
      __int128 v19 = 0u;
      CFDataRef v2 = CFDataCreate(kCFAllocatorDefault, bytes, 32LL);
      if (!ExternalRepresentation) {
        return v2;
      }
      goto LABEL_5;
    }

    id v7 = Mutable;
    BytePtr = CFDataGetBytePtr(ExternalRepresentation);
    id v9 = CFDataGetBytePtr(a1);
    CFDataAppendBytes(v7, v9, 6LL);
    CFIndex Length = CFDataGetLength(ExternalRepresentation);
    CFDataAppendBytes(v7, BytePtr, Length);
    int v11 = CFDataGetLength(ExternalRepresentation);
    MutableBytePtr = CFDataGetMutableBytePtr(v7);
    *(void *)&v15.wbuf[14] = 0xAAAAAAAAAAAAAAAALL;
    *(void *)&__int128 v13 = 0xAAAAAAAAAAAAAAAALL;
    *((void *)&v13 + 1) = 0xAAAAAAAAAAAAAAAALL;
    *(_OWORD *)&v15.wbuf[6] = v13;
    *(_OWORD *)&v15.wbuf[10] = v13;
    *(_OWORD *)&v15.hash[6] = v13;
    *(_OWORD *)&v15.wbuf[2] = v13;
    *(_OWORD *)v15.count = v13;
    *(_OWORD *)&v15.hash[2] = v13;
    CC_SHA256_Init(&v15);
    CC_SHA256_Update(&v15, MutableBytePtr, v11 + 6);
    CC_SHA256_Final(md, &v15);
    *(_OWORD *)bytes = *(_OWORD *)md;
    __int128 v19 = v17;
    CFDataRef v2 = CFDataCreate(kCFAllocatorDefault, bytes, 32LL);
    CFRelease(v7);
    if (ExternalRepresentation) {
LABEL_5:
    }
      CFRelease(ExternalRepresentation);
  }

  return v2;
}

uint64_t sub_1000A4754(uint64_t result)
{
  if (result)
  {
    uint64_t v1 = result;
    return !sub_100095B4C(result)
        && CFDictionaryGetValue(*(CFDictionaryRef *)(v1 + 16), @"WEP") != kCFBooleanTrue
        && !sub_100096E90(v1)
        && !sub_100098380(v1)
  }

  return result;
}

const void *sub_1000A47DC(const __CFArray *a1, const __CFDictionary **a2)
{
  uint64_t result = 0LL;
  uint64_t v4 = 0LL;
  CFIndex idx = -1LL;
  if (a1 && a2)
  {
    sub_1000A4840(a1, a2, &idx, &v4);
    if (idx == -1) {
      return 0LL;
    }
    else {
      return CFArrayGetValueAtIndex(a1, idx);
    }
  }

  return result;
}

void sub_1000A4840(const __CFArray *a1, const __CFDictionary **a2, CFIndex *a3, void *a4)
{
  if (!a1) {
    goto LABEL_12;
  }
  CFIndex Count = CFArrayGetCount(a1);
  if (!Count) {
    goto LABEL_12;
  }
  if (!a2) {
    goto LABEL_18;
  }
  uint64_t v9 = Count;
  CFTypeID v10 = CFGetTypeID(a2);
  uint64_t v11 = qword_100219950;
  if (!qword_100219950)
  {
    pthread_once(&stru_100219020, (void (*)(void))sub_1000949D8);
    uint64_t v11 = qword_100219950;
  }

  if (v10 != v11)
  {
LABEL_18:
    CFDictionaryRef v14 = objc_autoreleasePoolPush();
    if (qword_100219F60) {
      [qword_100219F60 WFLog:@"%s: invalid network ref" message:4];
    }
    objc_autoreleasePoolPop(v14);
    goto LABEL_12;
  }

  if (v9 < 1)
  {
LABEL_12:
    CFIndex v12 = -1LL;
    goto LABEL_13;
  }

  CFIndex v12 = 0LL;
  while (1)
  {
    ValueAtIndex = (CFTypeRef *)CFArrayGetValueAtIndex(a1, v12);
    if (ValueAtIndex)
    {
    }

    if (v9 == ++v12) {
      goto LABEL_12;
    }
  }

uint64_t sub_1000A496C(uint64_t a1)
{
  if (a1) {
    return sub_1000A1D44(a1) ^ 1;
  }
  else {
    return 1LL;
  }
}

BOOL sub_1000A4990(CFDictionaryRef *a1)
{
  CFDataRef v2 = sub_1000A063C(a1);
  id v3 = sub_1000A335C((uint64_t)a1);
  else {
    LOBYTE(v4) = 1;
  }
  unsigned __int8 v5 = [v2 supportedSecurityTypes];
  if (v2) {
    CFRelease(v2);
  }
  if (v3) {
    CFRelease(v3);
  }
  BOOL v6 = sub_10009DF44((uint64_t)a1) == 0;
  BOOL result = v6;
  if (v6) {
    char v8 = v4;
  }
  else {
    char v8 = 1;
  }
  if ((v8 & 1) == 0)
  {
    if (sub_100099810((uint64_t)a1)
      || sub_100095318((BOOL)a1)
      || sub_10009CF04((uint64_t)a1)
      || sub_10009CEA8((uint64_t)a1))
    {
      return 1LL;
    }

    if (a1)
    {
      if (!CFDictionaryGetValue(a1[2], @"DomainName")
        && !CFDictionaryContainsKey(a1[2], @"BundleIdentifier")
        && !sub_10009EFD8((uint64_t)a1)
        && !sub_1000951FC((uint64_t)a1, @"WalletIdentifier"))
      {
LABEL_25:
      }
    }

    else if (!sub_10009EFD8(0LL))
    {
      goto LABEL_25;
    }

    return 1LL;
  }

  return result;
}

BOOL sub_1000A4B04(uint64_t a1)
{
  return sub_1000A5ADC(a1) != 0LL;
}

uint64_t sub_1000A4B20(uint64_t a1, __int32 *a2)
{
  unsigned int v4 = *(const __CFDictionary **)(a1 + 16);
  if (v4)
  {
    int Value = (const __CFDictionary *)CFDictionaryGetValue(v4, @"RSN_IE");
    BOOL v6 = (const __CFDictionary *)CFDictionaryGetValue(*(CFDictionaryRef *)(a1 + 16), @"WPA_IE");
    if (Value)
    {
      BOOL v7 = sub_1000A4E24(Value, 2) != 0;
      int v8 = sub_1000A4E24(Value, 1);
      if (v8) {
        int v9 = (8 * v7) | 4;
      }
      else {
        int v9 = 8 * v7;
      }
      v35.i32[0] = v9;
      v35.i32[1] = v8 | (2 * v7);
      unsigned int v34 = sub_1000A4E24(Value, 3) == 0;
      unsigned int v10 = sub_1000A4E24(Value, 4) == 0;
      unsigned int v11 = sub_1000A4E24(Value, 5) == 0;
      unsigned int v12 = sub_1000A4E24(Value, 6) == 0;
      unsigned int v13 = sub_1000A4E24(Value, 8) == 0;
      unsigned int v14 = sub_1000A4E24(Value, 9) == 0;
      unsigned int v15 = sub_1000A4E24(Value, 24) == 0;
      unsigned int v16 = sub_1000A4E24(Value, 25) == 0;
      unsigned int v17 = sub_1000A4E24(Value, 12) == 0;
      int8x8_t v18 = vbsl_s8( (int8x8_t)vcltz_s32(vshl_n_s32(vdup_n_s32(v34), 0x1FuLL)),  v35,  vorr_s8(v35, (int8x8_t)0x400000080LL));
      int8x8_t v19 = vbsl_s8( (int8x8_t)vcltz_s32(vshl_n_s32(vdup_n_s32(v10), 0x1FuLL)),  v18,  vorr_s8(v18, (int8x8_t)0x800000010LL));
      int8x8_t v20 = vbsl_s8( (int8x8_t)vcltz_s32(vshl_n_s32(vdup_n_s32(v11), 0x1FuLL)),  v19,  vorr_s8(v19, (int8x8_t)0x1000000800LL));
      int8x8_t v21 = vbsl_s8( (int8x8_t)vcltz_s32(vshl_n_s32(vdup_n_s32(v12), 0x1FuLL)),  v20,  vorr_s8(v20, (int8x8_t)0x2000000400LL));
      int8x8_t v22 = vbsl_s8( (int8x8_t)vcltz_s32(vshl_n_s32(vdup_n_s32(v13), 0x1FuLL)),  v21,  vorr_s8(v21, (int8x8_t)0x8000001000LL));
      int8x8_t v23 = vbsl_s8( (int8x8_t)vcltz_s32(vshl_n_s32(vdup_n_s32(v14), 0x1FuLL)),  v22,  vorr_s8(v22, (int8x8_t)0x10000002000LL));
      int8x8_t v24 = vbsl_s8( (int8x8_t)vcltz_s32(vshl_n_s32(vdup_n_s32(v15), 0x1FuLL)),  v23,  vorr_s8(v23, (int8x8_t)0x80000000010000LL));
      int8x8_t v25 = vbsl_s8( (int8x8_t)vcltz_s32(vshl_n_s32(vdup_n_s32(v16), 0x1FuLL)),  v24,  vorr_s8(v24, (int8x8_t)0x100000000020000LL));
      int8x8_t v26 = vbsl_s8( (int8x8_t)vcltz_s32(vshl_n_s32(vdup_n_s32(v17), 0x1FuLL)),  v25,  vorr_s8(v25, (int8x8_t)0x80000004000LL));
      __int32 v27 = sub_1000A4E24(Value, 13);
      v28.i32[0] = 0;
      v29.i32[0] = v27;
      int8x8_t v30 = vbsl_s8(vdup_lane_s8(vceq_s8(v29, v28), 0), v26, vorr_s8(v26, (int8x8_t)0x100000008000LL));
    }

    else
    {
      int8x8_t v30 = 0LL;
    }

    uint64_t v32 = v30.u32[0];
    __int32 v31 = v30.i32[1];
    if (v6)
    {
      uint64_t v32 = v32 | sub_1000A4E24(v6, 1);
    }
  }

  else
  {
    __int32 v31 = 0;
    uint64_t v32 = 0xFFFFLL;
  }

  if (a2) {
    *a2 = v31;
  }
  return v32;
}

uint64_t sub_1000A4E24(const __CFDictionary *a1, int a2)
{
  int Value = (const __CFArray *)CFDictionaryGetValue(a1, @"IE_KEY_RSN_AUTHSELS");
  if (Value
    || (uint64_t result = (uint64_t)CFDictionaryGetValue(a1, @"IE_KEY_WPA_AUTHSELS"),
        (int Value = (const __CFArray *)result) != 0LL))
  {
    CFIndex Count = CFArrayGetCount(Value);
    if (Count < 1)
    {
      return 0LL;
    }

    else
    {
      CFIndex v7 = Count;
      CFIndex v8 = 0LL;
      while (1)
      {
        int valuePtr = -1431655766;
        ValueAtIndex = (const __CFNumber *)CFArrayGetValueAtIndex(Value, v8);
        if (CFNumberGetValue(ValueAtIndex, kCFNumberSInt32Type, &valuePtr))
        {
          if (valuePtr == a2) {
            break;
          }
        }

        if (v7 == ++v8) {
          return 0LL;
        }
      }

      return 1LL;
    }
  }

  return result;
}

uint64_t sub_1000A4EE8(const void *a1)
{
  if (!a1) {
    return 0LL;
  }
  unint64_t v2 = 0LL;
  id v3 = &byte_10017F940;
  do
  {
    unsigned int v4 = sub_1000968A4((uint64_t)a1);
    if (v4)
    {
      unsigned __int8 v5 = v4;
      memset(buffer, 170, 6);
      v16.location = 0LL;
      v16.length = 6LL;
      CFDataGetBytes(v4, v16, buffer);
      if (buffer[0] == *(v3 - 2)
        && buffer[1] == *(v3 - 1)
        && buffer[2] == *v3)
      {
        if (os_log_type_enabled((os_log_t)&_os_log_default, OS_LOG_TYPE_DEFAULT))
        {
          BOOL v6 = sub_100095BC8(a1);
          *(_DWORD *)buf = 136315650;
          unsigned int v11 = "WiFiNetworkIsProblematicForEncryptedDNS";
          __int16 v12 = 2112;
          unsigned int v13 = v6;
          __int16 v14 = 2112;
          unsigned int v15 = v5;
          _os_log_impl( (void *)&_mh_execute_header,  (os_log_t)&_os_log_default,  OS_LOG_TYPE_DEFAULT,  "%s: network %@ (%@) is known to be problematic for DoT/DoH",  buf,  0x20u);
        }

        uint64_t v7 = 1LL;
      }

      else
      {
        uint64_t v7 = 0LL;
      }

      CFRelease(v5);
    }

    else
    {
      uint64_t v7 = 0LL;
    }

    if (v2 > 1) {
      break;
    }
    ++v2;
    v3 += 3;
  }

  while (!(_DWORD)v7);
  return v7;
}

void sub_1000A5080(uint64_t a1, const void *a2)
{
  if (!a1)
  {
    BOOL v6 = objc_autoreleasePoolPush();
    if (qword_100219F60) {
      objc_msgSend((id)qword_100219F60, "WFLog:message:", 3, "%s: null network", "WiFiNetworkAddSIMIdentifier");
    }
    goto LABEL_9;
  }

  if (!a2)
  {
    BOOL v6 = objc_autoreleasePoolPush();
    if (qword_100219F60) {
      objc_msgSend((id)qword_100219F60, "WFLog:message:", 3, "%s: null simId", "WiFiNetworkAddSIMIdentifier");
    }
LABEL_9:
    objc_autoreleasePoolPop(v6);
    return;
  }

  unsigned int v4 = (const __CFArray *)sub_1000951FC(a1, @"SIMIdentifiers");
  if (v4) {
    MutableCFDictionaryRef Copy = CFArrayCreateMutableCopy(kCFAllocatorDefault, 0LL, v4);
  }
  else {
    MutableCFDictionaryRef Copy = CFArrayCreateMutable(kCFAllocatorDefault, 0LL, &kCFTypeArrayCallBacks);
  }
  uint64_t v7 = MutableCopy;
  v8.length = CFArrayGetCount(MutableCopy);
  v8.location = 0LL;
  if (CFArrayGetFirstIndexOfValue(v7, v8, a2) == -1) {
    CFArrayAppendValue(v7, a2);
  }
  sub_10009582C(a1, @"SIMIdentifiers", v7);
  if (v7) {
    CFRelease(v7);
  }
}

void sub_1000A51D4(uint64_t a1, const void *a2)
{
  if (!a1)
  {
    BOOL v6 = objc_autoreleasePoolPush();
    if (qword_100219F60) {
      objc_msgSend((id)qword_100219F60, "WFLog:message:", 3, "%s: null network", "WiFiNetworkRemoveSIMIdentifier");
    }
    goto LABEL_9;
  }

  if (!a2)
  {
    BOOL v6 = objc_autoreleasePoolPush();
    if (qword_100219F60) {
      [qword_100219F60 WFLog:@"%s: null simId" message:3];
    }
LABEL_9:
    objc_autoreleasePoolPop(v6);
    return;
  }

  unsigned int v4 = (const __CFArray *)sub_1000951FC(a1, @"SIMIdentifiers");
  if (v4) {
    MutableCFDictionaryRef Copy = CFArrayCreateMutableCopy(kCFAllocatorDefault, 0LL, v4);
  }
  else {
    MutableCFDictionaryRef Copy = CFArrayCreateMutable(kCFAllocatorDefault, 0LL, &kCFTypeArrayCallBacks);
  }
  uint64_t v7 = MutableCopy;
  v10.length = CFArrayGetCount(MutableCopy);
  v10.location = 0LL;
  FirstIndexOfint Value = CFArrayGetFirstIndexOfValue(v7, v10, a2);
  if (FirstIndexOfValue != -1) {
    CFArrayRemoveValueAtIndex(v7, FirstIndexOfValue);
  }
  if (CFArrayGetCount(v7)) {
    int v9 = v7;
  }
  else {
    int v9 = 0LL;
  }
  sub_10009582C(a1, @"SIMIdentifiers", v9);
  if (v7) {
    CFRelease(v7);
  }
}

void sub_1000A5334(uint64_t a1, CFDictionaryRef *a2, const void *a3)
{
  if (a1 && a2)
  {
    if (CFDictionaryGetValue(a2[2], @"DomainName"))
    {
      BOOL v6 = sub_10009D454((uint64_t)a2);
      if (v6)
      {
        uint64_t v7 = v6;
        CFRange v8 = (const __CFDictionary *)sub_1000951FC(a1, @"userPreferredPasspointDomains");
        int v9 = v8
           ? CFDictionaryCreateMutableCopy(kCFAllocatorDefault, 0LL, v8)
           : CFDictionaryCreateMutable( kCFAllocatorDefault,  0LL,  &kCFTypeDictionaryKeyCallBacks,  &kCFTypeDictionaryValueCallBacks);
        __int16 v14 = v9;
        if (v9)
        {
          if (a3) {
            CFDictionaryAddValue(v9, v7, a3);
          }
          else {
            CFDictionaryRemoveValue(v9, v7);
          }
          CFIndex Count = CFDictionaryGetCount(v14);
          CFRange v16 = @"userPreferredPasspointDomains";
          if (Count)
          {
LABEL_16:
            uint64_t v17 = a1;
            int8x8_t v18 = v14;
LABEL_25:
            sub_10009582C(v17, v16, v18);
            CFRelease(v14);
            return;
          }

const void *sub_1000A54CC(uint64_t a1, CFDictionaryRef *a2)
{
  if (!a1 || !a2) {
    return 0LL;
  }
  if (CFDictionaryGetValue(a2[2], @"DomainName"))
  {
    unsigned int v4 = sub_10009D454((uint64_t)a2);
    if (!v4) {
      return 0LL;
    }
    unsigned __int8 v5 = v4;
    BOOL v6 = @"userPreferredPasspointDomains";
  }

  else
  {
    uint64_t v7 = sub_100095BC8(a2);
    if (!v7) {
      return 0LL;
    }
    unsigned __int8 v5 = v7;
    BOOL v6 = @"userPreferredNetworkNames";
  }

  CFRange v8 = (const __CFDictionary *)sub_1000951FC(a1, v6);
  if (v8) {
    return CFDictionaryGetValue(v8, v5);
  }
  return 0LL;
}

void sub_1000A5560(uint64_t a1, int a2)
{
  if (a1)
  {
    unint64_t v2 = (const void **)&kCFBooleanTrue;
    if (!a2) {
      unint64_t v2 = (const void **)&kCFBooleanFalse;
    }
    sub_10009582C(a1, @"PrivacyProxyEnabled", *v2);
  }

  else
  {
    id v3 = objc_autoreleasePoolPush();
    if (qword_100219F60) {
      objc_msgSend((id)qword_100219F60, "WFLog:message:", 3, "%s: null network", "WiFiNetworkSetPrivacyProxyEnabled");
    }
    objc_autoreleasePoolPop(v3);
  }

void sub_1000A55F8(uint64_t a1, const void *a2)
{
  if (a1)
  {
    sub_10009582C(a1, @"PrivacyProxyBlockedReason", a2);
  }

  else
  {
    unint64_t v2 = objc_autoreleasePoolPush();
    if (qword_100219F60) {
      [qword_100219F60 WFLog:@"%s: null network" message:3];
    }
    objc_autoreleasePoolPop(v2);
  }

BOOL sub_1000A5674(uint64_t a1)
{
  CFAbsoluteTime Current = CFAbsoluteTimeGetCurrent();
  id v3 = CFDateCreate(kCFAllocatorDefault, Current);
  unsigned int v4 = (const __CFDate *)sub_1000951FC(a1, @"lastJoined");
  double TimeIntervalSinceDate = CFDateGetTimeIntervalSinceDate(v3, v4);
  if (sub_10009F9B8(a1) == 1
    || sub_100096670(a1) == 1
    || (!&_CNForgetSSID
     || CFDictionaryGetValue(*(CFDictionaryRef *)(a1 + 16), kCNSCaptiveNetworkProperty) != kCFBooleanTrue)
    && !sub_1000951FC(a1, @"WiFiNetworkAttributeIsPublic")
    && !sub_10009EFD8(a1))
  {
    BOOL v6 = 1LL;
    if (!v3) {
      return v6;
    }
LABEL_4:
    CFRelease(v3);
    return v6;
  }

  BOOL v6 = TimeIntervalSinceDate < 86400.0 && TimeIntervalSinceDate > -1.0;
  if (v3) {
    goto LABEL_4;
  }
  return v6;
}

BOOL sub_1000A5784(uint64_t a1)
{
  return !_os_feature_enabled_impl("WiFiManager", "SlowWiFiDPSTuning") || sub_1000A5674(a1);
}

uint64_t sub_1000A57CC(CFDictionaryRef *a1)
{
  uint64_t result = (uint64_t)sub_10009F3D4(a1);
  if ((_DWORD)result) {
    return 1LL;
  }
  return result;
}

BOOL sub_1000A580C(uint64_t a1)
{
  return sub_1000951FC(a1, @"WiFiNetworkAttributeIsLowQuality") != 0LL;
}

void sub_1000A5834(uint64_t a1, int a2)
{
  if (a1)
  {
    unint64_t v2 = (const void **)&kCFBooleanTrue;
    if (!a2) {
      unint64_t v2 = (const void **)&kCFBooleanFalse;
    }
    sub_10009582C(a1, @"PublicAirPlayNetwork", *v2);
  }

  else
  {
    id v3 = objc_autoreleasePoolPush();
    if (qword_100219F60) {
      [qword_100219F60 WFLog:@"%s: null network" message:3];
    }
    objc_autoreleasePoolPop(v3);
  }

void *sub_1000A58CC(uint64_t a1)
{
  if (a1)
  {
    uint64_t result = (void *)sub_1000951FC(a1, CWFCoreWiFiSpecificAttributesKey);
    if (result) {
      return (void *)([[result objectForKey:CWFNetworkProfilePropertyDisable6EModeKey] integerValue] == 2);
    }
  }

  else
  {
    unint64_t v2 = objc_autoreleasePoolPush();
    if (qword_100219F60) {
      [qword_100219F60 WFLog:@"%s: null network" message:3];
    }
    objc_autoreleasePoolPop(v2);
    return 0LL;
  }

  return result;
}

void sub_1000A5964(uint64_t a1, const void *a2)
{
  if (a1)
  {
    sub_10009582C(a1, @"DisplayFriendlyName", a2);
  }

  else
  {
    unint64_t v2 = objc_autoreleasePoolPush();
    if (qword_100219F60) {
      objc_msgSend((id)qword_100219F60, "WFLog:message:", 3, "%s: null network", "WiFiNetworkSetDisplayFriendlyName");
    }
    objc_autoreleasePoolPop(v2);
  }

const void *sub_1000A59E0(uint64_t a1)
{
  if (a1) {
    return sub_1000951FC(a1, @"DisplayFriendlyName");
  }
  unint64_t v2 = objc_autoreleasePoolPush();
  if (qword_100219F60) {
    [qword_100219F60 WFLog:@"%s: null network" message:3];
  }
  objc_autoreleasePoolPop(v2);
  return 0LL;
}

void sub_1000A5A60(uint64_t a1, const void *a2)
{
  if (a1)
  {
    sub_10009582C(a1, @"AccessoryIdentifier", a2);
  }

  else
  {
    unint64_t v2 = objc_autoreleasePoolPush();
    if (qword_100219F60) {
      [qword_100219F60 WFLog:@"%s: null network" message:3];
    }
    objc_autoreleasePoolPop(v2);
  }

const void *sub_1000A5ADC(uint64_t a1)
{
  if (a1) {
    return sub_1000951FC(a1, @"AccessoryIdentifier");
  }
  unint64_t v2 = objc_autoreleasePoolPush();
  if (qword_100219F60) {
    [qword_100219F60 WFLog:@"%s: null network" message:3];
  }
  objc_autoreleasePoolPop(v2);
  return 0LL;
}

BOOL sub_1000A5B5C(uint64_t a1)
{
  return sub_1000A5ADC(a1) == 0LL;
}

void sub_1000A5B78(void *a1)
{
  if (a1)
  {
    CFTypeID v2 = CFGetTypeID(a1);
    uint64_t v3 = qword_100219950;
    if (!qword_100219950)
    {
      pthread_once(&stru_100219020, (void (*)(void))sub_1000949D8);
      uint64_t v3 = qword_100219950;
    }

    if (v2 == v3)
    {
      unsigned int v4 = (const void *)a1[2];
      if (v4)
      {
        CFRelease(v4);
        a1[2] = 0LL;
      }
    }
  }

BOOL sub_1000A5BE4(void *a1, void *a2)
{
  uint64_t v2 = 0LL;
  if (a1)
  {
    uint64_t v3 = a2;
    if (a2)
    {
      unsigned int v4 = a1;
      CFTypeID v5 = CFGetTypeID(a1);
      uint64_t v6 = qword_100219950;
      if (!qword_100219950)
      {
        pthread_once(&stru_100219020, (void (*)(void))sub_1000949D8);
        uint64_t v6 = qword_100219950;
      }

      if (v5 == v6) {
        uint64_t v7 = v4;
      }
      else {
        uint64_t v7 = 0LL;
      }
      CFTypeID v8 = CFGetTypeID(v3);
      uint64_t v9 = qword_100219950;
      if (!qword_100219950)
      {
        pthread_once(&stru_100219020, (void (*)(void))sub_1000949D8);
        uint64_t v9 = qword_100219950;
      }

      if (v8 == v9) {
        CFRange v10 = v3;
      }
      else {
        CFRange v10 = 0LL;
      }
      CFTypeID TypeID = CFDictionaryGetTypeID();
      if (TypeID != CFGetTypeID(v4))
      {
        uint64_t v12 = qword_100219950;
        if (!qword_100219950)
        {
          pthread_once(&stru_100219020, (void (*)(void))sub_1000949D8);
          uint64_t v12 = qword_100219950;
        }

        if (v12 == CFGetTypeID(v4)) {
          unsigned int v4 = (void *)v4[2];
        }
        else {
          unsigned int v4 = 0LL;
        }
      }

      CFTypeID v13 = CFDictionaryGetTypeID();
      if (v13 != CFGetTypeID(v3))
      {
        uint64_t v14 = qword_100219950;
        if (!qword_100219950)
        {
          pthread_once(&stru_100219020, (void (*)(void))sub_1000949D8);
          uint64_t v14 = qword_100219950;
        }

        if (v14 != CFGetTypeID(v3)) {
          return 0LL;
        }
        uint64_t v3 = (void *)v3[2];
      }

      uint64_t v2 = 0LL;
      if (v4)
      {
        if (v3)
        {
          if (sub_100099458(v4, (const __CFDictionary *)v3))
          {
            if (sub_100095318((BOOL)v7) && !sub_100095318((BOOL)v10)
              || !sub_100095318((BOOL)v7) && sub_100095318((BOOL)v10))
            {
              int8x8_t v23 = objc_autoreleasePoolPush();
              if (qword_100219F60) {
                [(id)qword_100219F60 WFLog:3, "%s: SSIDs match (%@), but networks have different HS20 properties.", "__WiFiNetworkEqual", sub_100095BC8(v7) message];
              }
              objc_autoreleasePoolPop(v23);
              return 0LL;
            }

            if (!sub_1000A6668((const __CFDictionary *)v4, (const __CFDictionary *)v3)
              || !sub_1000994B0(v4, (const __CFDictionary *)v3, @"AP_MODE"))
            {
              return 0LL;
            }

            int v44 = sub_100098EB0((const __CFDictionary *)v4);
            int v43 = sub_100098EB0((const __CFDictionary *)v3);
            int v15 = sub_100097F80((const __CFDictionary *)v4)
            int v25 = sub_100097F80((const __CFDictionary *)v3)
            unsigned int v45 = sub_100098434((const __CFDictionary *)v4);
            unsigned int v46 = sub_100098434((const __CFDictionary *)v3);
            CFBooleanRef Value = (CFBooleanRef)CFDictionaryGetValue((CFDictionaryRef)v4, @"ALLOW_WPA2_PSK");
            CFBooleanRef v27 = (CFBooleanRef)CFDictionaryGetValue((CFDictionaryRef)v3, @"ALLOW_WPA2_PSK");
            CFBooleanRef v28 = (CFBooleanRef)CFDictionaryGetValue((CFDictionaryRef)v4, @"ALLOW_OWE_TSN");
            unint64_t v29 = (unint64_t)CFDictionaryGetValue((CFDictionaryRef)v3, @"ALLOW_OWE_TSN");
            int v30 = ((unint64_t)Value | (unint64_t)v28) == 0;
            int v31 = ((unint64_t)v27 | v29) == 0;
            if (v30 != v31)
            {
              uint64_t v32 = (const __CFBoolean *)v29;
              if (v15) {
                BOOL v33 = sub_1000992D0((uint64_t)v7) != 3;
              }
              else {
                BOOL v33 = 0;
              }
              if ((v25 & 1) == 0)
              {
                CFBooleanRef v35 = kCFBooleanTrue;
                goto LABEL_72;
              }

              BOOL v42 = v33;
              int v34 = sub_1000992D0((uint64_t)v10);
              BOOL v20 = Value == kCFBooleanTrue;
              CFBooleanRef v35 = kCFBooleanTrue;
              if (!v20)
              {
                BOOL v33 = v42;
                goto LABEL_72;
              }

              BOOL v33 = v42;
              if (v34 == 3)
              {
LABEL_72:
                if (v27 == v35 && v33) {
                  return 0LL;
                }
                if ((v30 & v15) == 1)
                {
                  int v36 = sub_1000992D0((uint64_t)v7);
                  int v37 = v44;
                  if (v36 == 3) {
                    int v37 = v44 | 2;
                  }
                  int v44 = v37;
                }

                if ((v31 & v25) == 1)
                {
                  int v38 = sub_1000992D0((uint64_t)v10);
                  int v39 = v43;
                  if (v38 == 3) {
                    int v39 = v43 | 2;
                  }
                  int v43 = v39;
                }

                BOOL v40 = v45 && sub_1000992D0((uint64_t)v7) != 3;
                if (v46)
                {
                  int v41 = sub_1000992D0((uint64_t)v10);
                  if (v28 == v35 && v41 != 3) {
                    return 0LL;
                  }
                }

                if (v32 == v35 && v40) {
                  return 0LL;
                }
LABEL_61:
                if (!v44 || !v43 || (v43 & v44) != 0) {
                  return (v44 == 0) ^ (v43 != 0);
                }
              }

              return 0LL;
            }

            uint64_t v2 = 0LL;
            if (v15 == v25 && v45 == v46) {
              goto LABEL_61;
            }
          }

          else
          {
            CFRange v16 = (const __CFNumber *)sub_1000951FC((uint64_t)v7, @"networkRole");
            unsigned int v17 = sub_10003AC9C(v16);
            int8x8_t v18 = (const __CFNumber *)sub_1000951FC((uint64_t)v10, @"networkRole");
            unsigned int v19 = sub_10003AC9C(v18);
            BOOL v20 = (v17 & 0xFFFFFFFE) == 2 || v17 == 4;
            if (v20 || v19 - 2 <= 2)
            {
              return v17 == v19;
            }

            else
            {
              uint64_t v2 = 1LL;
              if (!sub_1000A6408(v7, v10, 1u))
              {
                int8x8_t v21 = (const __CFString *)sub_100095BC8(v7);
                if (CFStringGetLength(v21)) {
                  return 0LL;
                }
                int8x8_t v22 = (const __CFString *)sub_100095BC8(v10);
                if (CFStringGetLength(v22)) {
                  return 0LL;
                }
                return sub_10009959C((uint64_t)v7, (uint64_t)v10) != 0;
              }
            }
          }
        }
      }
    }
  }

  return v2;
}

CFHashCode sub_1000A6104(const void *a1)
{
  if (a1 && (uint64_t v1 = sub_100095BC8(a1)) != 0LL) {
    return CFHash(v1);
  }
  else {
    return 0LL;
  }
}

CFStringRef sub_1000A6128(const __CFDictionary **cf)
{
  valuePtr[0] = 0;
  if (!cf) {
    return @"Invalid network ref";
  }
  uint64_t v2 = qword_100219950;
  if (!qword_100219950)
  {
    pthread_once(&stru_100219020, (void (*)(void))sub_1000949D8);
    uint64_t v2 = qword_100219950;
  }

  if (v2 != CFGetTypeID(cf)) {
    return @"Invalid network ref";
  }
  uint64_t v3 = (const __CFNumber *)sub_100096A74((uint64_t)cf);
  if (v3) {
    CFNumberGetValue(v3, kCFNumberSInt32Type, valuePtr);
  }
  unint64_t v29 = sub_100095BC8(cf);
  unsigned int v28 = sub_100097324(cf);
  BOOL v27 = sub_100095B4C((uint64_t)cf);
  unsigned int v26 = sub_100097F80(cf[2]);
  BOOL v25 = sub_100096E90((uint64_t)cf) != 0;
  BOOL v24 = CFDictionaryGetValue(cf[2], @"WEP") == kCFBooleanTrue;
  int8x8_t v23 = sub_10009831C(cf[2]);
  uint64_t v22 = sub_10009E120((uint64_t)cf);
  int8x8_t v21 = sub_1000951FC((uint64_t)cf, @"enabled");
  BOOL v20 = sub_1000951FC((uint64_t)cf, @"SaveDataMode");
  unsigned int v19 = sub_1000951FC((uint64_t)cf, @"NetworkQualityResponsiveness");
  unsigned int v4 = sub_1000951FC((uint64_t)cf, @"NetworkQualityDate");
  unsigned int v5 = sub_100096670((uint64_t)cf);
  uint64_t v6 = @"Unknown";
  if (v5 == 1) {
    uint64_t v6 = @"Home";
  }
  if (v5 == 2) {
    uint64_t v7 = @"Not Home";
  }
  else {
    uint64_t v7 = v6;
  }
  unsigned int v8 = sub_10009CD54((uint64_t)cf);
  uint64_t v9 = sub_1000951FC((uint64_t)cf, @"TransitionDisabledFlags");
  unsigned int v10 = sub_100097934((uint64_t)cf);
  unsigned int v11 = sub_100097700((uint64_t)cf);
  unsigned int v12 = sub_1000A1D44((uint64_t)cf);
  unsigned int v13 = sub_1000A58CC((uint64_t)cf);
  BOOL v14 = sub_100095318((BOOL)cf);
  int v15 = cf[2];
  uint64_t v16 = valuePtr[0];
  int v17 = CFDictionaryContainsKey(v15, @"BundleIdentifier");
  return CFStringCreateWithFormat( kCFAllocatorDefault,  0LL,  @"%@: isHidden=%d, isEAP=%d, isSAE=%d, isWPA=%d, isWEP=%d, WAPI=%d, type=%d, enabled=%@, saveData=%@, responsiveness=%@ (%@) isHome=%@, isForceFixed=%d, transitionDisabledFlags=%@, foundNanIe=%d, isPH=%d, isPublicAirPlayNetwork=%d, is6EDisabled=%d, hs20=%d, Channel=%d, isBundleIdentifierPresent=%d",  v29,  v28,  v27,  v26,  v25,  v24,  v23,  v22,  v21,  v20,  v19,  v4,  v7,  v8,  v9,  v10,  v11,  v12,  v13,  v14,  v16,  v17 != 0);
}

uint64_t sub_1000A6408(const void *a1, const void *a2, unsigned int a3)
{
  uint64_t v3 = 0LL;
  if (a1 && a2)
  {
    if (sub_100095318((BOOL)a1) && sub_100095318((BOOL)a2))
    {
      uint64_t v7 = (const __CFString *)sub_100095BC8(a1);
      unsigned int v8 = (const __CFString *)sub_100095BC8(a2);
      uint64_t v9 = (const __CFString *)sub_1000951FC((uint64_t)a1, @"HS20AccountName");
      unsigned int v10 = (const __CFString *)sub_1000951FC((uint64_t)a2, @"HS20AccountName");
      unsigned int v11 = (const __CFString *)sub_10009D454((uint64_t)a1);
      unsigned int v12 = (const __CFString *)sub_10009D454((uint64_t)a2);
      unsigned int v13 = objc_autoreleasePoolPush();
      if (qword_100219F60) {
        objc_msgSend( (id)qword_100219F60,  "WFLog:message:",  3,  "%s: HS20 - ssid1: %@, account1: %@, domain1: %@; ssid2: %@, account2: %@, domain2: %@, GAS check: %d",
      }
          "__WiFiIsSameHS20Account",
          v7,
          v9,
          v11,
          v8,
          v10,
          v12,
          a3);
      objc_autoreleasePoolPop(v13);
      if (v7 && v10 && CFStringCompare(v7, v10, 0LL) == kCFCompareEqualTo
        || v8 && v9 && CFStringCompare(v8, v9, 0LL) == kCFCompareEqualTo)
      {
        return 1LL;
      }

      if (v9 && v10 && v11 && v12 && CFStringCompare(v11, v12, 0LL) == kCFCompareEqualTo)
      {
        BOOL v14 = objc_autoreleasePoolPush();
        if (qword_100219F60) {
          [(id)qword_100219F60 WFLog:3, "%s: found matching domain %@ on two accounts. Accounts are %@ and %@", "__WiFiIsSameHS20Account", v11, v9, v10, v16 message];
        }
        goto LABEL_23;
      }

      if (!a3)
      {
        BOOL v14 = objc_autoreleasePoolPush();
        if (qword_100219F60) {
          [(id)qword_100219F60 WFLog:3, "%s: Skip GAS content check for domainName %@ and domainName %@", "__WiFiIsSameHS20Account", v11, v12 message];
        }
        uint64_t v3 = 0LL;
        goto LABEL_29;
      }

      if (sub_10009D528(a1, a2) || sub_10009D528(a2, a1))
      {
        BOOL v14 = objc_autoreleasePoolPush();
        if (qword_100219F60) {
          objc_msgSend( (id)qword_100219F60,  "WFLog:message:",  3,  "%s: HS20 - found matching attribute in GAS response - ssid1: %@, account1 %@; ssid2: %@, account: %@",
        }
            "__WiFiIsSameHS20Account",
            v7,
            v9,
            v8,
            v10);
LABEL_23:
        uint64_t v3 = 1LL;
LABEL_29:
        objc_autoreleasePoolPop(v14);
        return v3;
      }
    }

    return 0LL;
  }

  return v3;
}

uint64_t sub_1000A6668(const __CFDictionary *a1, const __CFDictionary *a2)
{
  if (CFDictionaryGetValue(a1, @"forceBGScanParamsCompare") != kCFBooleanTrue
    && CFDictionaryGetValue(a2, @"forceBGScanParamsCompare") != kCFBooleanTrue)
  {
    return 1LL;
  }

  uint64_t result = sub_1000994B0(a1, a2, @"BSSID");
  if ((_DWORD)result)
  {
    uint64_t result = sub_1000994B0(a1, a2, @"ENTRY_NETWORK");
    if ((_DWORD)result) {
      return sub_1000994B0(a1, a2, @"EXIT_NETWORK");
    }
  }

  return result;
}

void sub_1000A671C(uint64_t a1, uint64_t a2)
{
}

void sub_1000A672C(uint64_t a1)
{
}

Class sub_1000A6738(uint64_t a1)
{
  Class result = objc_getClass("CWFNetworkProfile");
  *(void *)(*(void *)(*(void *)(a1 + 32) + 8LL) + 40LL) = result;
  if (!*(void *)(*(void *)(*(void *)(a1 + 32) + 8LL) + 40LL)) {
    sub_1001543E0();
  }
  qword_100219968 = *(void *)(*(void *)(*(void *)(a1 + 32) + 8LL) + 40LL);
  return result;
}

uint64_t sub_1000A678C()
{
  uint64_t v2 = 0LL;
  if (!qword_100219970)
  {
    __int128 v3 = off_1001E48F8;
    uint64_t v4 = 0LL;
    qword_100219970 = _sl_dlopen(&v3, &v2);
  }

  uint64_t v0 = qword_100219970;
  if (!qword_100219970) {
    sub_100154444(&v2);
  }
  if (v2) {
    free(v2);
  }
  return v0;
}

Class sub_1000A6834(uint64_t a1)
{
  Class result = objc_getClass("CWFBSS");
  *(void *)(*(void *)(*(void *)(a1 + 32) + 8LL) + 40LL) = result;
  if (!*(void *)(*(void *)(*(void *)(a1 + 32) + 8LL) + 40LL)) {
    sub_1001544A8();
  }
  qword_100219978 = *(void *)(*(void *)(*(void *)(a1 + 32) + 8LL) + 40LL);
  return result;
}

Class sub_1000A6888(uint64_t a1)
{
  Class result = objc_getClass("CWFChannel");
  *(void *)(*(void *)(*(void *)(a1 + 32) + 8LL) + 40LL) = result;
  if (!*(void *)(*(void *)(*(void *)(a1 + 32) + 8LL) + 40LL)) {
    sub_10015450C();
  }
  qword_100219980 = *(void *)(*(void *)(*(void *)(a1 + 32) + 8LL) + 40LL);
  return result;
}

Class sub_1000A68DC(uint64_t a1)
{
  Class result = objc_getClass("CLLocation");
  *(void *)(*(void *)(*(void *)(a1 + 32) + 8LL) + 40LL) = result;
  if (!*(void *)(*(void *)(*(void *)(a1 + 32) + 8LL) + 40LL)) {
    sub_100154570();
  }
  qword_100219988 = *(void *)(*(void *)(*(void *)(a1 + 32) + 8LL) + 40LL);
  return result;
}

uint64_t sub_1000A6930()
{
  uint64_t v2 = 0LL;
  if (!qword_100219990)
  {
    __int128 v3 = off_1001E4910;
    uint64_t v4 = 0LL;
    qword_100219990 = _sl_dlopen(&v3, &v2);
  }

  uint64_t v0 = qword_100219990;
  if (!qword_100219990) {
    sub_1001545D4(&v2);
  }
  if (v2) {
    free(v2);
  }
  return v0;
}

Class sub_1000A69D8(uint64_t a1)
{
  Class result = objc_getClass("CWFScanResult");
  *(void *)(*(void *)(*(void *)(a1 + 32) + 8LL) + 40LL) = result;
  if (!*(void *)(*(void *)(*(void *)(a1 + 32) + 8LL) + 40LL)) {
    sub_100154638();
  }
  qword_1002199A0 = *(void *)(*(void *)(*(void *)(a1 + 32) + 8LL) + 40LL);
  return result;
}

void sub_1000A7C08( _Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, ...)
{
}

uint64_t sub_1000A7C20(uint64_t result, uint64_t a2)
{
  *(void *)(result + 40) = *(void *)(a2 + 40);
  *(void *)(a2 + 40) = 0LL;
  return result;
}

void sub_1000A7C30(uint64_t a1)
{
}

void sub_1000A7C38(uint64_t a1)
{
  id v2 = *(id *)(*(void *)(*(void *)(a1 + 32) + 8LL) + 40LL);
  __int128 v3 = (dispatch_queue_s *)qword_1002199B0;
  block[0] = _NSConcreteStackBlock;
  block[1] = 3221225472LL;
  block[2] = sub_1000A7CC8;
  block[3] = &unk_1001E4930;
  uint64_t v4 = *(void *)(a1 + 32);
  id v7 = v2;
  uint64_t v8 = v4;
  id v5 = v2;
  dispatch_sync(v3, block);
}

id sub_1000A7CC8(uint64_t a1)
{
  return [*(id *)(a1 + 32) _updateNetworkOnManagerQueue:*(void *)(*(void *)(*(void *)(a1 + 40) + 8) + 40)];
}

uint64_t sub_1000A96B8()
{
  uint64_t result = qword_1002199C0;
  if (!qword_1002199C0)
  {
    pthread_once(&stru_100219030, (void (*)(void))sub_1000A96F4);
    return qword_1002199C0;
  }

  return result;
}

uint64_t sub_1000A96F4()
{
  qword_1002199C0 = _CFRuntimeRegisterClass(&unk_1001E4958);
  qword_1002199C8 = (uint64_t)CFDictionaryCreateMutable(kCFAllocatorDefault, 0LL, 0LL, 0LL);
  return pthread_mutex_init(&stru_100219040, 0LL);
}

uint64_t sub_1000A9748(uint64_t a1, const void *a2)
{
  CFMutableDictionaryRef Mutable = CFDictionaryCreateMutable( kCFAllocatorDefault,  0LL,  &kCFTypeDictionaryKeyCallBacks,  &kCFTypeDictionaryValueCallBacks);
  if (!Mutable) {
    return 0LL;
  }
  id v5 = Mutable;
  if (sub_10012FD80())
  {
    uint64_t v6 = (const __CFString *)sub_10012FD94((uint64_t)@"WIFI_ASK_TO_JOIN_TITLE");
    id v7 = (const __CFString *)sub_10012FD94((uint64_t)@"WIFI_ASK_TO_JOIN_CANCEL_BUTTON");
  }

  else
  {
    uint64_t v8 = objc_autoreleasePoolPush();
    if (qword_100219F60) {
      [qword_100219F60 WFLog:@"WiFiNotificationCreateAskToJoin: localization not available"];
    }
    objc_autoreleasePoolPop(v8);
    id v7 = @"Cancel";
    uint64_t v6 = @"Select a Wireless Network";
  }

  CFDictionarySetValue(v5, kCFUserNotificationAlertHeaderKey, v6);
  CFDictionarySetValue(v5, kCFUserNotificationDefaultButtonTitleKey, v7);
  uint64_t v9 = sub_1000A98CC(a1, 0, 0, a2, v5, 0LL, 0LL);
  if (!v9)
  {
    unsigned int v12 = objc_autoreleasePoolPush();
    if (qword_100219F60) {
      [qword_100219F60 WFLog:@"%s: failed to create notification of type ask to join" message:3];
    }
    objc_autoreleasePoolPop(v12);
    return 0LL;
  }

  uint64_t v10 = v9;
  CFRelease(v5);
  return v10;
}

uint64_t sub_1000A98CC( uint64_t a1, int a2, int a3, const void *a4, __CFDictionary *a5, CFOptionFlags a6, const void *a7)
{
  if (!a5) {
    return 0LL;
  }
  do
  {
    unsigned int v10 = __ldxr((unsigned int *)&unk_100219080);
    uint64_t v11 = v10 + 1;
  }

  while (__stxr(v11, (unsigned int *)&unk_100219080));
  uint64_t v12 = sub_1000A9E44(a1, a2, a3, a4, a7, v11);
  if (v12)
  {
    SInt32 error = -1431655766;
    BundleWithIdentifier = CFBundleGetBundleWithIdentifier(@"com.apple.wifi.manager");
    if (BundleWithIdentifier)
    {
      CFURLRef v14 = CFBundleCopyBundleURL(BundleWithIdentifier);
      if (v14)
      {
        CFURLRef v15 = v14;
        CFDictionarySetValue(a5, kCFUserNotificationLocalizationURLKey, v14);
        CFRelease(v15);
      }
    }

    if (SBUserNotificationDismissOnLock)
    {
      CFDictionarySetValue(a5, SBUserNotificationDismissOnLock, kCFBooleanTrue);
      CFDictionarySetValue(a5, SBUserNotificationAlertMessageDelimiterKey, &stru_1001EB6E0);
    }

    if (a2) {
      goto LABEL_19;
    }
    uint64_t v16 = objc_autoreleasePoolPush();
    if (qword_100219F60) {
      [qword_100219F60 WFLog:@"__WiFiNotificationCreateCFUN: adding extensionItem for ask to join notification (id: %d)", v11];
    }
    objc_autoreleasePoolPop(v16);
    int v17 = objc_alloc_init(&OBJC_CLASS___NSExtensionItem);
    int8x8_t v18 = -[NSDictionary initWithObjectsAndKeys:]( objc_alloc(&OBJC_CLASS___NSDictionary),  "initWithObjectsAndKeys:",  +[NSNumber numberWithInt:](&OBJC_CLASS___NSNumber, "numberWithInt:", v11),  @"notificationId",  0LL);
    -[NSExtensionItem setUserInfo:](v17, "setUserInfo:", v18);
    uint64_t v25 = 0LL;
    BOOL v27 = v17;
    unsigned int v19 = +[NSKeyedArchiver archivedDataWithRootObject:requiringSecureCoding:error:]( &OBJC_CLASS___NSKeyedArchiver,  "archivedDataWithRootObject:requiringSecureCoding:error:",  +[NSArray arrayWithObjects:count:](&OBJC_CLASS___NSArray, "arrayWithObjects:count:", &v27, 1LL),  1LL,  &v25);
    if (v25)
    {
      BOOL v20 = objc_autoreleasePoolPush();
      if (qword_100219F60) {
        [(id)qword_100219F60 WFLog:4, "%s: error archiving extensionItem %@", "__WiFiNotificationCreateCFUN", v25 message];
      }
      objc_autoreleasePoolPop(v20);
      if (!v17) {
        goto LABEL_17;
      }
    }

    else
    {
      CFDictionarySetValue(a5, SBUserNotificationExtensionItemsKey, v19);
      if (!v17)
      {
LABEL_17:
        if (v18) {
          CFRelease(v18);
        }
LABEL_19:
        CFUserNotificationRef v21 = CFUserNotificationCreate(kCFAllocatorDefault, 0.0, a6, &error, a5);
        *(void *)(v12 + 120) = v21;
        if (v21)
        {
          CFUserNotificationRef v22 = v21;
          pthread_mutex_lock(&stru_100219040);
          CFDictionarySetValue((CFMutableDictionaryRef)qword_1002199C8, v22, (const void *)v12);
          pthread_mutex_unlock(&stru_100219040);
          CFRunLoopSourceRef RunLoopSource = CFUserNotificationCreateRunLoopSource( kCFAllocatorDefault,  *(CFUserNotificationRef *)(v12 + 120),  (CFUserNotificationCallBack)sub_1000ABFB8,  0LL);
          *(void *)(v12 + 56) = RunLoopSource;
          if (RunLoopSource) {
            return v12;
          }
        }

        CFRelease((CFTypeRef)v12);
        return 0LL;
      }
    }

    CFRelease(v17);
    goto LABEL_17;
  }

  return v12;
}

uint64_t sub_1000A9BC4(uint64_t a1, const void *a2, int a3, const void *a4, CFDictionaryRef theDict, int a6)
{
  uint64_t v6 = 0LL;
  if (!a4 || !theDict) {
    return v6;
  }
  if (!CFDictionaryGetValue(theDict, @"TLSServerCertificateChain"))
  {
    int8x8_t v23 = objc_autoreleasePoolPush();
    if (qword_100219F60) {
      [qword_100219F60 WFLog:@"WiFiNotificationCreateEAPTrust: server certificate chain is null"];
    }
    objc_autoreleasePoolPop(v23);
    return 0LL;
  }

  if (a6 != 2)
  {
    do
      unsigned int v20 = __ldxr((unsigned int *)&unk_100219080);
    while (__stxr(v20 + 1, (unsigned int *)&unk_100219080));
    uint64_t v6 = sub_1000A9E44(a1, 2, a6, a2, theDict, v20 + 1);
    if (!v6) {
      return v6;
    }
    goto LABEL_12;
  }

  CFMutableDictionaryRef Mutable = CFDictionaryCreateMutable( kCFAllocatorDefault,  0LL,  &kCFTypeDictionaryKeyCallBacks,  &kCFTypeDictionaryValueCallBacks);
  if (!Mutable) {
    return 0LL;
  }
  unsigned int v13 = Mutable;
  CFURLRef v14 = (const __CFString *)sub_10012FD94((uint64_t)@"WIFI_OPEN_SETTINGS_CERTIFICATE_TITLE");
  CFURLRef v15 = sub_100095BC8(a4);
  CFStringRef v16 = CFStringCreateWithFormat(kCFAllocatorDefault, 0LL, v14, v15);
  CFDictionarySetValue(v13, kCFUserNotificationAlertHeaderKey, v16);
  if (v16) {
    CFRelease(v16);
  }
  id v17 = sub_10012FD94((uint64_t)@"WIFI_OPEN_SETTINGS_CERTIFICATE_ACCEPT_BUTTON");
  CFDictionarySetValue(v13, kCFUserNotificationDefaultButtonTitleKey, v17);
  id v18 = sub_10012FD94((uint64_t)@"WIFI_OPEN_SETTINGS_CERTIFICATE_VIEW_BUTTON");
  CFDictionarySetValue(v13, kCFUserNotificationAlternateButtonTitleKey, v18);
  id v19 = sub_10012FD94((uint64_t)@"WIFI_CANCEL");
  CFDictionarySetValue(v13, kCFUserNotificationOtherButtonTitleKey, v19);
  uint64_t v6 = sub_1000A98CC(a1, 2, 2, a2, v13, 0LL, 0LL);
  CFRelease(v13);
  if (v6)
  {
    *(void *)(v6 + 24) = CFRetain(a4);
    *(void *)(v6 + 112) = CFRetain(theDict);
LABEL_12:
    CFUserNotificationRef v21 = objc_autoreleasePoolPush();
    if (qword_100219F60) {
      [qword_100219F60 WFLog:@"Dispatching EAP Trust panel(%d)" message:3];
    }
    objc_autoreleasePoolPop(v21);
    *(void *)(v6 + 24) = CFRetain(a4);
  }

  return v6;
}

uint64_t sub_1000A9E44(uint64_t a1, int a2, int a3, const void *a4, const void *a5, int a6)
{
  if (!qword_1002199C0) {
    pthread_once(&stru_100219030, (void (*)(void))sub_1000A96F4);
  }
  uint64_t Instance = _CFRuntimeCreateInstance(a1);
  uint64_t v13 = Instance;
  if (Instance)
  {
    *(_OWORD *)(Instance + 16) = 0u;
    *(_OWORD *)(Instance + 96) = 0u;
    *(_OWORD *)(Instance + 112) = 0u;
    *(_OWORD *)(Instance + 64) = 0u;
    *(_OWORD *)(Instance + 80) = 0u;
    *(_OWORD *)(Instance + 32) = 0u;
    *(_OWORD *)(Instance + 4_Block_object_dispose(va, 8) = 0u;
    *(_DWORD *)(Instance + 32) = a2;
    *(_DWORD *)(Instance + 36) = a3;
    *(_DWORD *)(Instance + 40) = a6;
    if (a4) {
      *(void *)(Instance + 16) = CFRetain(a4);
    }
    if (a5) {
      *(void *)(v13 + 112) = CFRetain(a5);
    }
  }

  return v13;
}

uint64_t sub_1000A9F0C(uint64_t a1, uint64_t a2, uint64_t a3, CFDictionaryRef *a4, int a5)
{
  CFStringRef v9 = sub_100095408(a4);
  if (v9) {
    goto LABEL_8;
  }
  CFStringRef v10 = sub_100099C08(a4);
  if (v10)
  {
    CFStringRef v9 = v10;
    uint64_t v11 = objc_autoreleasePoolPush();
    if (qword_100219F60) {
      [(id)qword_100219F60 WFLog:4, "%s: found password with non-syncable attribute for network %@.", "WiFiNotificationCreatePassword", sub_100095BC8(a4) message];
    }
    objc_autoreleasePoolPop(v11);
LABEL_8:
    CFRelease(v9);
    int v12 = 0;
    goto LABEL_9;
  }

  int v12 = 1;
LABEL_9:
  CFMutableDictionaryRef Mutable = CFDictionaryCreateMutable( kCFAllocatorDefault,  0LL,  &kCFTypeDictionaryKeyCallBacks,  &kCFTypeDictionaryValueCallBacks);
  if (!Mutable) {
    return 0LL;
  }
  CFURLRef v14 = Mutable;
  BOOL v15 = sub_10012FD80();
  CFStringRef v16 = objc_autoreleasePoolPush();
  if (qword_100219F60) {
    [qword_100219F60 WFLog:@"WiFiNotificationCreatePassword: localizationAvailable=%d" message:3];
  }
  objc_autoreleasePoolPop(v16);
  if (!v15)
  {
    if (a5 == 2)
    {
      BOOL v31 = sub_100098D64((uint64_t)a4);
      uint64_t v32 = sub_100095BC8(a4);
      if (v31) {
        CFStringRef v33 = CFStringCreateWithFormat(kCFAllocatorDefault, 0LL, @"Incorrect Wi-Fi Credentials for %@", v32);
      }
      else {
        CFStringRef v33 = CFStringCreateWithFormat(kCFAllocatorDefault, 0LL, @"Incorrect Wi-Fi Password for %@", v32);
      }
      CFStringRef v47 = v33;
      CFDictionarySetValue(v14, kCFUserNotificationAlertHeaderKey, v33);
      if (v47) {
        CFRelease(v47);
      }
      else {
        unsigned int v28 = @"Enter Password";
      }
    }

    else
    {
      if (a5 != 1)
      {
LABEL_58:
        CFDictionarySetValue(v14, kCFUserNotificationAlternateButtonTitleKey, @"Cancel");
        id v48 = sub_100095BC8(a4);
        int v44 = (__CFArray *)CFStringCreateWithFormat(kCFAllocatorDefault, 0LL, @"Enter the password for %@.", v48);
        CFStringRef v42 = 0LL;
        if (v44) {
          goto LABEL_59;
        }
        uint64_t v62 = 0LL;
LABEL_82:
        CFRelease(v14);
        return v62;
      }

      else {
        int v26 = v12;
      }
      if (v26) {
        BOOL v27 = @"Wi-Fi Password";
      }
      else {
        BOOL v27 = @"Incorrect Wi-Fi Password";
      }
      CFDictionarySetValue(v14, kCFUserNotificationAlertHeaderKey, v27);
      unsigned int v28 = @"Join";
    }

    CFDictionarySetValue(v14, kCFUserNotificationDefaultButtonTitleKey, v28);
    goto LABEL_58;
  }

  int v17 = sub_1000F3150(a2);
  if (a5 == 2)
  {
    if (sub_100098D64((uint64_t)a4))
    {
      unint64_t v29 = @"WIFI_OPEN_SETTINGS_CREDENTIALS_TITLE";
      int v30 = @"WIFI_OPEN_SETTINGS_CREDENTIALS_TITLE_CH";
    }

    else
    {
      unint64_t v29 = @"WIFI_OPEN_SETTINGS_PASSWORD_TITLE";
      int v30 = @"WIFI_OPEN_SETTINGS_PASSWORD_TITLE_CH";
    }

    if (v17) {
      uint64_t v34 = (uint64_t)v30;
    }
    else {
      uint64_t v34 = (uint64_t)v29;
    }
    CFBooleanRef v35 = (const __CFString *)sub_10012FD94(v34);
    int v36 = sub_100095BC8(a4);
    CFStringRef v37 = CFStringCreateWithFormat(kCFAllocatorDefault, 0LL, v35, v36);
    CFDictionarySetValue(v14, kCFUserNotificationAlertHeaderKey, v37);
    if (v37) {
      CFRelease(v37);
    }
    else {
      uint64_t v25 = @"WIFI_OPEN_SETTINGS_PASSWORD_BUTTON";
    }
  }

  else
  {
    if (a5 != 1) {
      goto LABEL_48;
    }
    unsigned int v18 = sub_100098E6C(a4);
    id v19 = @"WIFI_PASSWORD_TITLE";
    if (v18) {
      int v20 = 1;
    }
    else {
      int v20 = v12;
    }
    BOOL v21 = v20 == 0;
    CFUserNotificationRef v22 = @"WIFI_PASSWORD_TITLE_CH";
    if (!v21)
    {
      id v19 = @"WIFI_OTP_PASSWORD_TITLE";
      CFUserNotificationRef v22 = @"WIFI_OTP_PASSWORD_TITLE_CH";
    }

    if (v17) {
      uint64_t v23 = (uint64_t)v22;
    }
    else {
      uint64_t v23 = (uint64_t)v19;
    }
    id v24 = sub_10012FD94(v23);
    CFDictionarySetValue(v14, kCFUserNotificationAlertHeaderKey, v24);
    uint64_t v25 = @"WIFI_JOIN";
  }

  id v38 = sub_10012FD94((uint64_t)v25);
  CFDictionarySetValue(v14, kCFUserNotificationDefaultButtonTitleKey, v38);
LABEL_48:
  id v39 = sub_10012FD94((uint64_t)@"WIFI_CANCEL");
  CFDictionarySetValue(v14, kCFUserNotificationAlternateButtonTitleKey, v39);
  BOOL v40 = sub_100095BC8(a4);
  CFStringRef v41 = CFStringCreateWithFormat(kCFAllocatorDefault, 0LL, @"%c%@%c", 8LL, v40, 127LL);
  if (!v41)
  {
    uint64_t v62 = 0LL;
    goto LABEL_82;
  }

  CFStringRef v42 = v41;
  CFMutableArrayRef v43 = CFArrayCreateMutable(kCFAllocatorDefault, 0LL, &kCFTypeArrayCallBacks);
  if (v43)
  {
    int v44 = v43;
    id v45 = sub_10012FD94((uint64_t)@"WIFI_PASSWORD_MESSAGE_PREFIX");
    CFArrayAppendValue(v44, v45);
    CFArrayAppendValue(v44, v42);
    id v46 = sub_10012FD94((uint64_t)@"WIFI_PASSWORD_MESSAGE_SUFFIX");
    CFArrayAppendValue(v44, v46);
LABEL_59:
    int v66 = v12;
    id v67 = (const void *)a2;
    uint64_t v49 = a1;
    CFDictionarySetValue(v14, kCFUserNotificationAlertMessageKey, v44);
    CFRelease(v44);
    CFDictionarySetValue(v14, kCFUserNotificationTextFieldTitlesKey, &stru_1001EB6E0);
    BOOL v50 = sub_100098D64((uint64_t)a4);
    if (a5 == 1 && v50)
    {
      id v51 = CFArrayCreateMutable(kCFAllocatorDefault, 0LL, &kCFTypeArrayCallBacks);
      id v52 = v51;
      if (!v51
        || (!v15
          ? (CFArrayAppendValue(v51, @"Username"), uint64_t v54 = @"Password")
          : (id v53 = sub_10012FD94((uint64_t)@"WIFI_USERNAME_TEXT_TITLE"),
             CFArrayAppendValue(v52, v53),
             uint64_t v54 = (const __CFString *)sub_10012FD94((uint64_t)@"WIFI_PASSWORD_TEXT_TITLE")),
            CFArrayAppendValue(v52, v54),
            CFDictionarySetValue(v14, kCFUserNotificationTextFieldTitlesKey, v52),
            (CFMutableArrayRef v55 = CFArrayCreateMutable(kCFAllocatorDefault, 0LL, &kCFTypeArrayCallBacks)) == 0LL))
      {
        uint64_t v62 = 0LL;
        id v61 = 0LL;
        goto LABEL_77;
      }

      id v56 = v55;
      CFIndex v57 = (const __CFString *)sub_1000951FC((uint64_t)a4, @"UserName");
      if (v57) {
        id v58 = v57;
      }
      else {
        id v58 = &stru_1001EB6E0;
      }
      CFArrayAppendValue(v56, v58);
      CFArrayAppendValue(v56, &stru_1001EB6E0);
      CFDictionarySetValue(v14, kCFUserNotificationTextFieldValuesKey, v56);
      char v59 = 1;
    }

    else
    {
      id v56 = 0LL;
      id v52 = 0LL;
      char v59 = 0;
      id v61 = 0LL;
      CFOptionFlags v60 = 0LL;
      if (a5 != 1)
      {
LABEL_71:
        uint64_t v62 = sub_1000A98CC(v49, 1, a5, v67, v14, v60, 0LL);
        if (v62)
        {
          id v63 = objc_autoreleasePoolPush();
          if (qword_100219F60)
          {
            id v64 = "no";
            if (v66) {
              id v64 = "yes";
            }
            [qword_100219F60 WFLog:message:3, @"Dispatching password panel(%d), missing password=%s", *(unsigned int *)(v62 + 40), v64];
          }

          objc_autoreleasePoolPop(v63);
          *(void *)(v62 + 24) = CFRetain(a4);
        }

uint64_t sub_1000AA610(uint64_t a1, const void *a2, int a3, const void *a4, int a5)
{
  if (!a4)
  {
    uint64_t v11 = objc_autoreleasePoolPush();
    int v12 = (void *)qword_100219F60;
    if (!qword_100219F60) {
      goto LABEL_6;
    }
    uint64_t v13 = "%s: null network.";
    goto LABEL_26;
  }

  CFStringRef v9 = sub_1000951FC((uint64_t)a4, @"WiFiNetworkUserAcceptedRecommendationAt");
  if (v9)
  {
    CFStringRef v10 = v9;
    uint64_t v11 = objc_autoreleasePoolPush();
    int v12 = (void *)qword_100219F60;
    if (!qword_100219F60)
    {
LABEL_6:
      objc_autoreleasePoolPop(v11);
      return 0LL;
    }

    int v30 = v10;
    uint64_t v13 = "%s: user already accepted join recommendation for this network at %@. Suppressing alert.";
    uint64_t v14 = 3LL;
LABEL_5:
    objc_msgSend(v12, "WFLog:message:", v14, v13, "WiFiNotificationCreateJoinRecommendation", v30);
    goto LABEL_6;
  }

  CFMutableDictionaryRef Mutable = CFDictionaryCreateMutable( kCFAllocatorDefault,  0LL,  &kCFTypeDictionaryKeyCallBacks,  &kCFTypeDictionaryValueCallBacks);
  if (!Mutable)
  {
    uint64_t v11 = objc_autoreleasePoolPush();
    int v12 = (void *)qword_100219F60;
    if (!qword_100219F60) {
      goto LABEL_6;
    }
    uint64_t v13 = "%s: null alert.";
LABEL_26:
    uint64_t v14 = 4LL;
    goto LABEL_5;
  }

  int v17 = Mutable;
  else {
    unsigned int v18 = @"WIFI_ASK_TO_JOIN_NETWORK_AVAILABLE_TITLE";
  }
  id v19 = sub_10012FD94((uint64_t)v18);
  CFDictionarySetValue(v17, kCFUserNotificationAlertHeaderKey, v19);
  id v20 = sub_10012FD94((uint64_t)@"WIFI_ASK_TO_JOIN_JOIN_BUTTON");
  CFDictionarySetValue(v17, kCFUserNotificationDefaultButtonTitleKey, v20);
  id v21 = sub_10012FD94((uint64_t)@"WIFI_ASK_TO_JOIN_CANCEL_BUTTON");
  CFDictionarySetValue(v17, kCFUserNotificationAlternateButtonTitleKey, v21);
  if (a5 == 12) {
    CFUserNotificationRef v22 = @"WIFI_ASK_TO_JOIN_NETWORK_HOTSPOT_RECOMMENDED_BODY";
  }
  else {
    CFUserNotificationRef v22 = @"WIFI_ASK_TO_JOIN_NETWORK_AVAILABLE_BODY";
  }
  uint64_t v23 = (const __CFString *)sub_10012FD94((uint64_t)v22);
  id v24 = sub_100095BC8(a4);
  CFStringRef v25 = CFStringCreateWithFormat(kCFAllocatorDefault, 0LL, v23, v24);
  if (!v25)
  {
    unint64_t v29 = objc_autoreleasePoolPush();
    if (qword_100219F60) {
      [qword_100219F60 WFLog:@"%s: null messageString." message:4];
    }
    objc_autoreleasePoolPop(v29);
    CFRelease(v17);
    return 0LL;
  }

  CFStringRef v26 = v25;
  CFDictionarySetValue(v17, kCFUserNotificationAlertMessageKey, v25);
  uint64_t v15 = sub_1000A98CC(a1, a5, 0, a2, v17, 0LL, 0LL);
  if (v15)
  {
    *(void *)(v15 + 24) = CFRetain(a4);
    BOOL v27 = objc_autoreleasePoolPush();
    if (qword_100219F60) {
      [qword_100219F60 WFLog:message:3, @"Dispatching Join Recommendation Notification(%d)", *(unsigned int *)(v15 + 40)];
    }
    objc_autoreleasePoolPop(v27);
  }

  CFRelease(v17);
  CFRelease(v26);
  return v15;
}

uint64_t sub_1000AA904(uint64_t a1, const void *a2, uint64_t a3, const void *a4)
{
  if (!a4)
  {
    id v19 = objc_autoreleasePoolPush();
    if (qword_100219F60) {
      [qword_100219F60 WFLog:@"%s: null network." message:@"WiFiNotificationCreateJoinFailureCaptive"];
    }
    objc_autoreleasePoolPop(v19);
    return 0LL;
  }

  CFMutableDictionaryRef Mutable = CFDictionaryCreateMutable( kCFAllocatorDefault,  0LL,  &kCFTypeDictionaryKeyCallBacks,  &kCFTypeDictionaryValueCallBacks);
  if (!Mutable) {
    return 0LL;
  }
  uint64_t v8 = Mutable;
  if (sub_10012FD80())
  {
    CFStringRef v9 = (const __CFString *)sub_10012FD94((uint64_t)@"WIFI_JOIN_NETWORK_FAILURE_CAPTIVE_TITLE");
    CFStringRef v10 = sub_100095BC8(a4);
    CFStringRef v11 = CFStringCreateWithFormat(kCFAllocatorDefault, 0LL, v9, v10);
    int v12 = (const __CFString *)sub_10012FD94((uint64_t)@"WIFI_FAILURE_OK");
  }

  else
  {
    uint64_t v13 = objc_autoreleasePoolPush();
    if (qword_100219F60) {
      [qword_100219F60 WFLog:@"%s: localization not available" message:@"WiFiNotificationCreateJoinFailureCaptive"];
    }
    objc_autoreleasePoolPop(v13);
    uint64_t v14 = sub_100095BC8(a4);
    CFStringRef v11 = CFStringCreateWithFormat(kCFAllocatorDefault, 0LL, @"Unable to join the network\n%@", v14);
    int v12 = @"OK";
  }

  CFDictionarySetValue(v8, kCFUserNotificationAlertHeaderKey, v11);
  if (v11) {
    CFRelease(v11);
  }
  CFDictionarySetValue(v8, kCFUserNotificationDefaultButtonTitleKey, v12);
  uint64_t v15 = sub_1000A98CC(a1, 6, 0, a2, v8, 0LL, 0LL);
  if (!v15)
  {
    id v20 = objc_autoreleasePoolPush();
    if (qword_100219F60) {
      [qword_100219F60 WFLog:@"%s: failed to create notification of type join failure captive" message:3];
    }
    objc_autoreleasePoolPop(v20);
    CFRelease(v8);
    return 0LL;
  }

  uint64_t v16 = v15;
  CFRelease(v8);
  *(void *)(v16 + 24) = CFRetain(a4);
  int v17 = objc_autoreleasePoolPush();
  if (qword_100219F60) {
    objc_msgSend( (id)qword_100219F60,  "WFLog:message:",  3,  "Dispatching Join Failure Captive Notification(%d)",  *(unsigned int *)(v16 + 40));
  }
  objc_autoreleasePoolPop(v17);
  return v16;
}

uint64_t sub_1000AAB60(uint64_t a1, const void *a2, uint64_t a3, const void *a4)
{
  if (!a4)
  {
    id v19 = objc_autoreleasePoolPush();
    if (qword_100219F60) {
      objc_msgSend((id)qword_100219F60, "WFLog:message:", 4, "%s: null network.", "WiFiNotificationCreateJoinFailure");
    }
    objc_autoreleasePoolPop(v19);
    return 0LL;
  }

  CFMutableDictionaryRef Mutable = CFDictionaryCreateMutable( kCFAllocatorDefault,  0LL,  &kCFTypeDictionaryKeyCallBacks,  &kCFTypeDictionaryValueCallBacks);
  if (!Mutable) {
    return 0LL;
  }
  uint64_t v8 = Mutable;
  if (sub_10012FD80())
  {
    CFStringRef v9 = (const __CFString *)sub_10012FD94((uint64_t)@"WIFI_JOIN_NETWORK_FAILURE_TITLE");
    CFStringRef v10 = sub_100095BC8(a4);
    CFStringRef v11 = CFStringCreateWithFormat(kCFAllocatorDefault, 0LL, v9, v10);
    int v12 = (const __CFString *)sub_10012FD94((uint64_t)@"WIFI_FAILURE_OK");
  }

  else
  {
    uint64_t v13 = objc_autoreleasePoolPush();
    if (qword_100219F60) {
      [qword_100219F60 WFLog:@"%s: localization not available" message:@"WiFiNotificationCreateJoinFailure"];
    }
    objc_autoreleasePoolPop(v13);
    uint64_t v14 = sub_100095BC8(a4);
    CFStringRef v11 = CFStringCreateWithFormat(kCFAllocatorDefault, 0LL, @"Unable to join the network\n%@", v14);
    int v12 = @"OK";
  }

  CFDictionarySetValue(v8, kCFUserNotificationAlertHeaderKey, v11);
  if (v11) {
    CFRelease(v11);
  }
  CFDictionarySetValue(v8, kCFUserNotificationDefaultButtonTitleKey, v12);
  uint64_t v15 = sub_1000A98CC(a1, 7, 0, a2, v8, 0LL, 0LL);
  if (!v15)
  {
    id v20 = objc_autoreleasePoolPush();
    if (qword_100219F60) {
      [qword_100219F60 WFLog:@"%s: failed to create notification of type join failure" message:@"WiFiNotificationCreateJoinFailure"];
    }
    objc_autoreleasePoolPop(v20);
    CFRelease(v8);
    return 0LL;
  }

  uint64_t v16 = v15;
  CFRelease(v8);
  *(void *)(v16 + 24) = CFRetain(a4);
  int v17 = objc_autoreleasePoolPush();
  if (qword_100219F60) {
    [qword_100219F60 WFLog:@"Dispatching Join Failure Notification(%d)" message:3 * *(unsigned int *)(v16 + 40)];
  }
  objc_autoreleasePoolPop(v17);
  return v16;
}

uint64_t sub_1000AADBC(uint64_t a1, uint64_t a2, int a3, void *a4, CFDictionaryRef theDict)
{
  if (!a4)
  {
    id v52 = objc_autoreleasePoolPush();
    if (qword_100219F60) {
      [qword_100219F60 WFLog:@"%s: nil networks manager." message:@"WiFiNotificationCreateColocatedJoin"];
    }
    goto LABEL_62;
  }

  if (!theDict)
  {
    id v52 = objc_autoreleasePoolPush();
    if (qword_100219F60) {
      [qword_100219F60 WFLog:@"WiFiNotificationCreateColocatedJoin: additional inforation is null"];
    }
    goto LABEL_62;
  }

  CFBooleanRef Value = CFDictionaryGetValue(theDict, @"SSID_STR");
  if (!Value)
  {
    id v52 = objc_autoreleasePoolPush();
    if (qword_100219F60) {
      [qword_100219F60 WFLog:@"WiFiNotificationCreateColocatedJoin: network SSID string is null"];
    }
LABEL_62:
    objc_autoreleasePoolPop(v52);
    return 0LL;
  }

  CFStringRef v10 = Value;
  CFMutableDictionaryRef Mutable = CFDictionaryCreateMutable( kCFAllocatorDefault,  0LL,  &kCFTypeDictionaryKeyCallBacks,  &kCFTypeDictionaryValueCallBacks);
  if (!Mutable) {
    return 0LL;
  }
  CFMutableDictionaryRef v12 = Mutable;
  uint64_t v56 = a1;
  BOOL v13 = sub_10012FD80();
  uint64_t v14 = (const void *)a2;
  int v15 = sub_1000F3150(a2);
  id v16 = [a4 numberOfCandidates];
  if (!v16)
  {
    id v53 = objc_autoreleasePoolPush();
    if (qword_100219F60) {
      [(id)qword_100219F60 WFLog:4 message:"No colocated candidates"];
    }
    CFStringRef v36 = 0LL;
LABEL_69:
    objc_autoreleasePoolPop(v53);
    CFRelease(v12);
    uint64_t v48 = 0LL;
    if (!v36) {
      return v48;
    }
    goto LABEL_51;
  }

  id v17 = v16;
  id v18 = [a4 colocatedNetworks];
  id v19 = v18;
  if (v17 == (id)1)
  {
    unsigned int v28 = sub_1000A3DB0([v18 objectAtIndex:0]);
    CFUserNotificationRef v22 = sub_100095BC8(v28);
    if (v13)
    {
      unint64_t v29 = (const __CFString *)sub_10012FD94((uint64_t)@"WIFI_LIMITED_COMPATIBILITY_JOIN_ONE_TITLE");
      CFStringRef v30 = CFStringCreateWithFormat(kCFAllocatorDefault, 0LL, v29, v22);
      CFDictionarySetValue(v12, kCFUserNotificationAlertHeaderKey, v30);
      if (v30) {
        CFRelease(v30);
      }
      if (v15) {
        BOOL v31 = @"WIFI_LIMITED_COMPATIBILITY_JOIN_ONE_BODY_CH";
      }
      else {
        BOOL v31 = @"WIFI_LIMITED_COMPATIBILITY_JOIN_ONE_BODY";
      }
      BOOL v27 = (const __CFString *)sub_10012FD94((uint64_t)v31);
      goto LABEL_22;
    }

    CFDictionarySetValue(v12, kCFUserNotificationAlertHeaderKey, @"Related Wi-Fi Network Available");
    BOOL v40 = objc_autoreleasePoolPush();
    uint64_t v37 = a1;
    if (qword_100219F60) {
      [qword_100219F60 WFLog:@"WiFiNotificationCreateColocatedJoin: localization not available"];
    }
    objc_autoreleasePoolPop(v40);
    CFStringRef v39 = CFStringCreateWithFormat( kCFAllocatorDefault,  0LL,  @"%@ has a separate network name on this Wi-Fi network, which may affect some experiences. Do you want to also join %@?",  v10,  v22);
  }

  else
  {
    if (v17 != (id)2)
    {
      if (!v13)
      {
        CFDictionarySetValue(v12, kCFUserNotificationAlertHeaderKey, @"Related Wi-Fi Networks Available");
        id v51 = objc_autoreleasePoolPush();
        if (qword_100219F60) {
          [qword_100219F60 WFLog:@"%s: localization not available" message:3];
        }
        objc_autoreleasePoolPop(v51);
        CFStringRef v35 = CFStringCreateWithFormat( kCFAllocatorDefault,  0LL,  @"%@ has separate network names on this Wi-Fi network, which may affect some experiences. Do you want to also join those networks?",  v10);
        goto LABEL_31;
      }

      uint64_t v32 = (const __CFString *)sub_10012FD94((uint64_t)@"WIFI_LIMITED_COMPATIBILITY_JOIN_MANY_TITLE");
      CFStringRef v33 = CFStringCreateWithFormat(kCFAllocatorDefault, 0LL, v32, 0LL);
      CFDictionarySetValue(v12, kCFUserNotificationAlertHeaderKey, v33);
      if (v33) {
        CFRelease(v33);
      }
      if (v15) {
        uint64_t v34 = @"WIFI_LIMITED_COMPATIBILITY_JOIN_MANY_BODY_CH";
      }
      else {
        uint64_t v34 = @"WIFI_LIMITED_COMPATIBILITY_JOIN_MANY_BODY";
      }
      BOOL v27 = (const __CFString *)sub_10012FD94((uint64_t)v34);
LABEL_30:
      CFStringRef v35 = CFStringCreateWithFormat(kCFAllocatorDefault, 0LL, v27, v10, v54, v55);
LABEL_31:
      CFStringRef v36 = v35;
      uint64_t v37 = v56;
      goto LABEL_39;
    }

    id v20 = sub_1000A3DB0([v18 objectAtIndex:0]);
    id v21 = sub_1000A3DB0([v19 objectAtIndex:1]);
    CFUserNotificationRef v22 = sub_100095BC8(v20);
    uint64_t v23 = sub_100095BC8(v21);
    if (v13)
    {
      id v24 = (const __CFString *)sub_10012FD94((uint64_t)@"WIFI_LIMITED_COMPATIBILITY_JOIN_TWO_TITLE");
      CFStringRef v25 = CFStringCreateWithFormat(kCFAllocatorDefault, 0LL, v24, v22, v23);
      CFDictionarySetValue(v12, kCFUserNotificationAlertHeaderKey, v25);
      if (v25) {
        CFRelease(v25);
      }
      if (v15) {
        CFStringRef v26 = @"WIFI_LIMITED_COMPATIBILITY_JOIN_TWO_BODY_CH";
      }
      else {
        CFStringRef v26 = @"WIFI_LIMITED_COMPATIBILITY_JOIN_TWO_BODY";
      }
      BOOL v27 = (const __CFString *)sub_10012FD94((uint64_t)v26);
      CFMutableArrayRef v55 = v23;
LABEL_22:
      uint64_t v54 = v22;
      goto LABEL_30;
    }

    CFDictionarySetValue(v12, kCFUserNotificationAlertHeaderKey, @"Related Wi-Fi Networks Available");
    id v38 = objc_autoreleasePoolPush();
    uint64_t v37 = v56;
    if (qword_100219F60) {
      [qword_100219F60 WFLog:@"%s: localization not available" message:3];
    }
    objc_autoreleasePoolPop(v38);
    CFStringRef v39 = CFStringCreateWithFormat( kCFAllocatorDefault,  0LL,  @"%@ has separate network names on this Wi-Fi network, which may affect some experiences. Do you want to also join %@ & %@?",  v10,  v22,  v23);
  }

  CFStringRef v36 = v39;
LABEL_39:
  BOOL v41 = sub_10012FD80();
  if (v41) {
    CFStringRef v42 = (const __CFString *)sub_10012FD94((uint64_t)@"WIFI_LIMITED_COMPATIBILITY_JOIN_BUTTON_OK");
  }
  else {
    CFStringRef v42 = @"Join";
  }
  id v43 = [[SBSMutableUserNotificationButtonDefinition alloc] initWithTitle:v42];
  [v43 setIsPreferredButton:1];
  [v43 setPresentationStyle:0];
  if (v41) {
    int v44 = (const __CFString *)sub_10012FD94((uint64_t)@"WIFI_LIMITED_COMPATIBILITY_JOIN_BUTTON_CANCEL");
  }
  else {
    int v44 = @"Not Now";
  }
  id v45 = [[SBSMutableUserNotificationButtonDefinition alloc] initWithTitle:v44];
  id v46 = -[NSArray initWithObjects:]( [NSArray alloc],  "initWithObjects:",  [v45 build],  objc_msgSend(v43, "build"),  0);

  CFDictionarySetValue(v12, SBSUserNotificationButtonDefinitionsKey, v46);
  if (v46) {
    CFRelease(v46);
  }
  CFDictionarySetValue(v12, kCFUserNotificationAlertMessageKey, v36);
  uint64_t v47 = sub_1000A98CC(v37, 13, 0, v14, v12, 0LL, theDict);
  if (!v47)
  {
    id v53 = objc_autoreleasePoolPush();
    if (qword_100219F60) {
      [qword_100219F60 WFLog:@"%s: failed to create notification of limited compatibility assisted join" message:3];
    }
    goto LABEL_69;
  }

  uint64_t v48 = v47;
  CFRelease(v12);
  uint64_t v49 = objc_autoreleasePoolPush();
  if (qword_100219F60) {
    [qword_100219F60 WFLog:message:3, @"Dispatching colocated join Notification(%d)", *(unsigned int *)(v48 + 40)];
  }
  objc_autoreleasePoolPop(v49);
  if (v36) {
LABEL_51:
  }
    CFRelease(v36);
  return v48;
}

uint64_t sub_1000AB45C(uint64_t a1, const void *a2, uint64_t a3, const void *a4)
{
  uint64_t v7 = sub_1000F2108((uint64_t)a2);
  if (!a4)
  {
    id v21 = objc_autoreleasePoolPush();
    if (qword_100219F60) {
      [qword_100219F60 WFLog:@"%s: null network." message:@"WiFiNotificationCreateAutoHotspotError"];
    }
    goto LABEL_20;
  }

  uint64_t v8 = v7;
  CFMutableDictionaryRef Mutable = CFDictionaryCreateMutable( kCFAllocatorDefault,  0LL,  &kCFTypeDictionaryKeyCallBacks,  &kCFTypeDictionaryValueCallBacks);
  if (!Mutable)
  {
    id v21 = objc_autoreleasePoolPush();
    if (qword_100219F60) {
      [qword_100219F60 WFLog:@"%s: null alert." message:@"WiFiNotificationCreateAutoHotspotError"];
    }
LABEL_20:
    objc_autoreleasePoolPop(v21);
    return 0LL;
  }

  CFStringRef v10 = Mutable;
  if ((_DWORD)v8 == 2)
  {
    CFStringRef v11 = (const __CFString *)sub_10012FD94((uint64_t)@"PERSONAL_HOTSPOT_DECLINED_BODY");
    CFMutableDictionaryRef v12 = sub_100095BC8(a4);
    CFStringRef v13 = CFStringCreateWithFormat(kCFAllocatorDefault, 0LL, v11, v12);
  }

  else
  {
    if (MGGetBoolAnswer(@"apple-internal-install"))
    {
      uint64_t v14 = (const __CFString *)sub_10012FD94((uint64_t)@"PERSONAL_HOTSPOT_START_FAILURE_BODY_INTERNAL");
      uint64_t v23 = sub_100095BC8(a4);
      CFStringRef v15 = CFStringCreateWithFormat(kCFAllocatorDefault, 0LL, v14, v23, v8);
    }

    else
    {
      id v16 = (const __CFString *)sub_10012FD94((uint64_t)@"PERSONAL_HOTSPOT_START_FAILURE_BODY");
      id v24 = sub_100095BC8(a4);
      CFStringRef v15 = CFStringCreateWithFormat(kCFAllocatorDefault, 0LL, v16, v24);
    }

    CFStringRef v13 = v15;
    id v17 = sub_10012FD94((uint64_t)@"PERSONAL_HOTSPOT_REMOTE_FAILURE_TITLE");
    CFDictionarySetValue(v10, kCFUserNotificationAlertHeaderKey, v17);
  }

  if (!v13)
  {
    CFUserNotificationRef v22 = objc_autoreleasePoolPush();
    if (qword_100219F60) {
      [qword_100219F60 WFLog:@"null messageString."];
    }
    objc_autoreleasePoolPop(v22);
    CFRelease(v10);
    return 0LL;
  }

  CFDictionarySetValue(v10, kCFUserNotificationDefaultButtonTitleKey, @"OK");
  CFDictionarySetValue(v10, kCFUserNotificationAlertMessageKey, v13);
  uint64_t v18 = sub_1000A98CC(a1, 11, 0, a2, v10, 0LL, 0LL);
  if (v18)
  {
    id v19 = objc_autoreleasePoolPush();
    if (qword_100219F60) {
      [qword_100219F60 WFLog:@"Dispatching Auto Hotspot Join Failure Panel(%d)" message:3 *(unsigned int *)(v18 + 40)];
    }
    objc_autoreleasePoolPop(v19);
    *(void *)(v18 + 24) = CFRetain(a4);
  }

  CFRelease(v10);
  CFRelease(v13);
  return v18;
}

uint64_t sub_1000AB724(uint64_t a1, const void *a2, int a3, const void *a4)
{
  if (!a4)
  {
    CFStringRef v9 = objc_autoreleasePoolPush();
    CFStringRef v10 = (void *)qword_100219F60;
    if (!qword_100219F60) {
      goto LABEL_6;
    }
    CFStringRef v11 = "%s: null network.";
    goto LABEL_20;
  }

  uint64_t v7 = sub_1000951FC((uint64_t)a4, @"WiFiNetworkUserAcceptedRecommendationAt");
  if (v7)
  {
    uint64_t v8 = v7;
    CFStringRef v9 = objc_autoreleasePoolPush();
    CFStringRef v10 = (void *)qword_100219F60;
    if (!qword_100219F60)
    {
LABEL_6:
      objc_autoreleasePoolPop(v9);
      return 0LL;
    }

    CFStringRef v26 = v8;
    CFStringRef v11 = "%s: user already accepted join recommendation for this network at %@. Suppressing alert.";
    uint64_t v12 = 3LL;
LABEL_5:
    objc_msgSend(v10, "WFLog:message:", v12, v11, "WiFiNotificationCreateAskToJoinHotspot", v26);
    goto LABEL_6;
  }

  CFMutableDictionaryRef Mutable = CFDictionaryCreateMutable( kCFAllocatorDefault,  0LL,  &kCFTypeDictionaryKeyCallBacks,  &kCFTypeDictionaryValueCallBacks);
  if (!Mutable)
  {
    CFStringRef v9 = objc_autoreleasePoolPush();
    CFStringRef v10 = (void *)qword_100219F60;
    if (!qword_100219F60) {
      goto LABEL_6;
    }
    CFStringRef v11 = "%s: null alert.";
LABEL_20:
    uint64_t v12 = 4LL;
    goto LABEL_5;
  }

  CFStringRef v15 = Mutable;
  id v16 = sub_10012FD94((uint64_t)@"PERSONAL_HOTSPOT_NEARBY_TITLE");
  CFDictionarySetValue(v15, kCFUserNotificationAlertHeaderKey, v16);
  id v17 = sub_10012FD94((uint64_t)@"WIFI_JOIN_NETWORK_JOIN");
  CFDictionarySetValue(v15, kCFUserNotificationDefaultButtonTitleKey, v17);
  id v18 = sub_10012FD94((uint64_t)@"WIFI_JOIN_NETWORK_CANCEL");
  CFDictionarySetValue(v15, kCFUserNotificationAlternateButtonTitleKey, v18);
  id v19 = (const __CFString *)sub_10012FD94((uint64_t)@"PERSONAL_HOTSPOT_NEARBY_BODY");
  id v20 = sub_100095BC8(a4);
  CFStringRef v21 = CFStringCreateWithFormat(kCFAllocatorDefault, 0LL, v19, v20);
  if (!v21)
  {
    CFStringRef v25 = objc_autoreleasePoolPush();
    if (qword_100219F60) {
      [qword_100219F60 WFLog:@"WiFiNotificationCreateAskToJoinHotspot: null messageString."];
    }
    objc_autoreleasePoolPop(v25);
    CFRelease(v15);
    return 0LL;
  }

  CFStringRef v22 = v21;
  CFDictionarySetValue(v15, kCFUserNotificationAlertMessageKey, v21);
  uint64_t v13 = sub_1000A98CC(a1, 10, 0, a2, v15, 0LL, 0LL);
  if (v13)
  {
    uint64_t v23 = objc_autoreleasePoolPush();
    if (qword_100219F60) {
      objc_msgSend( (id)qword_100219F60,  "WFLog:message:",  3,  "Dispatching Auto Hotspot Panel(%d)",  *(unsigned int *)(v13 + 40));
    }
    objc_autoreleasePoolPop(v23);
    *(void *)(v13 + 24) = CFRetain(a4);
  }

  CFRelease(v15);
  CFRelease(v22);
  return v13;
}

uint64_t sub_1000AB9E4( uint64_t a1, int a2, uint64_t a3, const void *a4, int a5, CFDictionaryRef *a6, CFDictionaryRef theDict)
{
  switch(a2)
  {
    case 0:
      uint64_t result = sub_1000A9748(a1, a4);
      break;
    case 1:
    case 3:
      uint64_t result = sub_1000A9F0C(a1, (uint64_t)a4, a3, a6, a3);
      break;
    case 2:
      uint64_t result = sub_1000A9BC4(a1, a4, a3, a6, theDict, a3);
      break;
    case 5:
    case 12:
      uint64_t result = sub_1000AA610(a1, a4, a3, a6, a2);
      break;
    case 6:
      uint64_t result = sub_1000AA904(a1, a4, a3, a6);
      break;
    case 7:
      uint64_t result = sub_1000AAB60(a1, a4, a3, a6);
      break;
    case 10:
      uint64_t result = sub_1000AB724(a1, a4, a3, a6);
      break;
    case 11:
      uint64_t result = sub_1000AB45C(a1, a4, a3, a6);
      break;
    default:
      uint64_t result = 0LL;
      break;
  }

  return result;
}

uint64_t sub_1000ABA7C(uint64_t a1)
{
  return *(unsigned int *)(a1 + 32);
}

uint64_t sub_1000ABA84(uint64_t a1)
{
  return *(unsigned int *)(a1 + 36);
}

uint64_t sub_1000ABA8C(uint64_t a1)
{
  return *(unsigned int *)(a1 + 96);
}

uint64_t sub_1000ABA94(uint64_t a1)
{
  return *(unsigned int *)(a1 + 40);
}

uint64_t sub_1000ABA9C(uint64_t a1)
{
  return *(void *)(a1 + 16);
}

BOOL sub_1000ABAA4(uint64_t a1)
{
  unsigned int v1 = *(_DWORD *)(a1 + 32);
  BOOL v2 = v1 > 0xC;
  int v3 = (1 << v1) & 0x1425;
  return !v2 && v3 != 0;
}

void sub_1000ABAC8(uint64_t a1)
{
  if (!*(_DWORD *)(a1 + 96))
  {
    switch(*(_DWORD *)(a1 + 32))
    {
      case 0:
        BOOL v2 = objc_autoreleasePoolPush();
        int v3 = (void *)qword_100219F60;
        if (!qword_100219F60) {
          goto LABEL_21;
        }
        uint64_t v4 = "Canceling Ask To Join panel";
        break;
      case 1:
      case 3:
        BOOL v2 = objc_autoreleasePoolPush();
        int v3 = (void *)qword_100219F60;
        if (!qword_100219F60) {
          goto LABEL_21;
        }
        uint64_t v4 = "Canceling pending password panel";
        break;
      case 2:
        id v5 = objc_autoreleasePoolPush();
        if (qword_100219F60) {
          [(id)qword_100219F60 WFLog:3 message:"Canceling EAP Trust panel"];
        }
        objc_autoreleasePoolPop(v5);
        goto LABEL_22;
      case 5:
        BOOL v2 = objc_autoreleasePoolPush();
        int v3 = (void *)qword_100219F60;
        if (!qword_100219F60) {
          goto LABEL_21;
        }
        uint64_t v4 = "Canceling Join Recommendation panel";
        break;
      case 7:
        BOOL v2 = objc_autoreleasePoolPush();
        int v3 = (void *)qword_100219F60;
        if (!qword_100219F60) {
          goto LABEL_21;
        }
        uint64_t v4 = "Canceling Join Failure panel";
        break;
      case 0xA:
        BOOL v2 = objc_autoreleasePoolPush();
        int v3 = (void *)qword_100219F60;
        if (!qword_100219F60) {
          goto LABEL_21;
        }
        uint64_t v4 = "Canceling Ask-To-Join Hotspot";
        break;
      case 0xB:
        BOOL v2 = objc_autoreleasePoolPush();
        int v3 = (void *)qword_100219F60;
        if (!qword_100219F60) {
          goto LABEL_21;
        }
        uint64_t v4 = "Canceling Auto Hotspot Failure";
        break;
      case 0xC:
        BOOL v2 = objc_autoreleasePoolPush();
        int v3 = (void *)qword_100219F60;
        if (!qword_100219F60) {
          goto LABEL_21;
        }
        uint64_t v4 = "Canceling Auto Hotspot Join Recommendation";
        break;
      default:
        goto LABEL_22;
    }

    [v3 WFLog:3 message:v4];
LABEL_21:
    objc_autoreleasePoolPop(v2);
    CFUserNotificationCancel(*(CFUserNotificationRef *)(a1 + 120));
LABEL_22:
    sub_1000ABDB4(a1, 3);
  }

void sub_1000ABC68(void *a1, int a2, CFTypeRef cf)
{
}

void sub_1000ABC98(uint64_t a1, uint64_t a2)
{
  *(void *)(a1 + 4_Block_object_dispose(va, 8) = a2;
  if (*(void *)(a1 + 56))
  {
    Main = CFRunLoopGetMain();
    CFRunLoopAddSource(Main, *(CFRunLoopSourceRef *)(a1 + 56), kCFRunLoopDefaultMode);
  }

void sub_1000ABCE0(uint64_t a1)
{
  *(void *)(a1 + 4_Block_object_dispose(va, 8) = 0LL;
  if (*(void *)(a1 + 56))
  {
    Main = CFRunLoopGetMain();
    CFRunLoopRemoveSource(Main, *(CFRunLoopSourceRef *)(a1 + 56), kCFRunLoopDefaultMode);
  }

uint64_t sub_1000ABD28(uint64_t result, uint64_t a2, uint64_t a3)
{
  *(void *)(result + 64) = a2;
  *(void *)(result + 72) = a3;
  return result;
}

CFDictionaryRef sub_1000ABD30(uint64_t a1, const void *a2)
{
  uint64_t result = *(const __CFDictionary **)(a1 + 104);
  if (result) {
    return (const __CFDictionary *)CFDictionaryGetValue(result, a2);
  }
  return result;
}

void *sub_1000ABD40(void *result, CFTypeRef cf)
{
  if (cf)
  {
    uint64_t v3 = (uint64_t)result;
    uint64_t v4 = (const void *)result[13];
    if (v4)
    {
      CFRelease(v4);
      *(void *)(v3 + 104) = 0LL;
    }

    uint64_t result = CFRetain(cf);
    *(void *)(v3 + 104) = result;
    if (!*(_DWORD *)(v3 + 32))
    {
      id v5 = result;
      uint64_t v6 = *(const void **)(v3 + 24);
      if (v6)
      {
        CFRelease(v6);
        *(void *)(v3 + 24) = 0LL;
        id v5 = *(const void **)(v3 + 104);
      }

      uint64_t result = sub_100094AAC((uint64_t)kCFAllocatorDefault, v5);
      *(void *)(v3 + 24) = result;
    }
  }

  return result;
}

void sub_1000ABDB4(uint64_t a1, int a2)
{
  *(_DWORD *)(a1 + 96) = a2;
  uint64_t v3 = objc_autoreleasePoolPush();
  if (qword_100219F60)
  {
    uint64_t v4 = *(int *)(a1 + 96);
    else {
      id v5 = off_1001E49B8[v4];
    }
    [(id)qword_100219F60 WFLog:3, "Notification response received. Type=%d (%@) ResponseType=%d.", *(unsigned int *)(a1 + 32), v5, v4 message];
  }

  objc_autoreleasePoolPop(v3);
  uint64_t v6 = *(void (**)(uint64_t, void))(a1 + 64);
  if (v6) {
    v6(a1, *(void *)(a1 + 72));
  }
  uint64_t v7 = *(void (**)(uint64_t, void))(a1 + 80);
  if (v7) {
    v7(a1, *(void *)(a1 + 88));
  }
}

__CFString *sub_1000ABE6C(unsigned int a1)
{
  if (a1 > 5) {
    return 0LL;
  }
  else {
    return off_1001E49B8[a1];
  }
}

void sub_1000ABE8C(uint64_t a1)
{
  block[0] = _NSConcreteStackBlock;
  block[1] = 3221225472LL;
  block[2] = sub_1000ABFB0;
  block[3] = &unk_1001E2620;
  void block[4] = a1;
  dispatch_sync(&_dispatch_main_q, block);
  unsigned int v2 = *(_DWORD *)(a1 + 32);
  BOOL v3 = v2 > 0xD;
  int v4 = (1 << v2) & 0x3CEB;
  if (!v3 && v4 != 0)
  {
    uint64_t v6 = *(const void **)(a1 + 120);
    if (v6)
    {
      pthread_mutex_lock(&stru_100219040);
      CFDictionaryRemoveValue((CFMutableDictionaryRef)qword_1002199C8, v6);
      pthread_mutex_unlock(&stru_100219040);
      CFUserNotificationCancel(*(CFUserNotificationRef *)(a1 + 120));
      uint64_t v7 = *(const void **)(a1 + 120);
      if (v7)
      {
        CFRelease(v7);
        *(void *)(a1 + 120) = 0LL;
      }
    }
  }

  uint64_t v8 = *(const void **)(a1 + 16);
  if (v8)
  {
    CFRelease(v8);
    *(void *)(a1 + 16) = 0LL;
  }

  CFStringRef v9 = *(const void **)(a1 + 112);
  if (v9)
  {
    CFRelease(v9);
    *(void *)(a1 + 112) = 0LL;
  }

  CFStringRef v10 = *(const void **)(a1 + 24);
  if (v10)
  {
    CFRelease(v10);
    *(void *)(a1 + 24) = 0LL;
  }

  CFStringRef v11 = *(const void **)(a1 + 104);
  if (v11)
  {
    CFRelease(v11);
    *(void *)(a1 + 104) = 0LL;
  }

  uint64_t v12 = *(const void **)(a1 + 56);
  if (v12)
  {
    CFRelease(v12);
    *(void *)(a1 + 56) = 0LL;
  }

void sub_1000ABFB0(uint64_t a1)
{
}

void sub_1000ABFB8(const void *a1, uint64_t a2)
{
  uint64_t v10 = 0LL;
  CFStringRef v11 = &v10;
  uint64_t v12 = 0x2020000000LL;
  uint64_t v13 = 0LL;
  if (a1)
  {
    pthread_mutex_lock(&stru_100219040);
    CFBooleanRef Value = CFDictionaryGetValue((CFDictionaryRef)qword_1002199C8, a1);
    id v5 = Value;
    if (Value) {
      CFRetain(Value);
    }
    pthread_mutex_unlock(&stru_100219040);
    void v11[3] = (uint64_t)v5;
    if (v5)
    {
      if (v5[6])
      {
        CFTypeID v6 = CFGetTypeID(v5);
        uint64_t v7 = qword_1002199C0;
        if (!qword_1002199C0)
        {
          pthread_once(&stru_100219030, (void (*)(void))sub_1000A96F4);
          uint64_t v7 = qword_1002199C0;
        }

        if (v6 == v7)
        {
          CFRetain(a1);
          uint64_t v8 = *(dispatch_queue_s **)(v11[3] + 48);
          block[0] = _NSConcreteStackBlock;
          block[1] = 3221225472LL;
          block[2] = sub_1000AC120;
          block[3] = &unk_1001E43A0;
          void block[4] = &v10;
          void block[5] = a2;
          void block[6] = a1;
          dispatch_async(v8, block);
          goto LABEL_12;
        }

        id v5 = (void *)v11[3];
        if (!v5) {
          goto LABEL_12;
        }
      }

      CFRelease(v5);
      void v11[3] = 0LL;
    }
  }

void sub_1000AC108( _Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, ...)
{
}

void sub_1000AC120(uint64_t a1)
{
  uint64_t v2 = *(unsigned int *)(*(void *)(*(void *)(*(void *)(a1 + 32) + 8LL) + 24LL) + 36LL);
  BOOL v3 = objc_autoreleasePoolPush();
  if (qword_100219F60) {
    [qword_100219F60 WFLog:message:@"__WiFiNotificationCFUNCallback_block_invoke" message:*(void *)(a1 + 40) type:*(unsigned int *)(*(void *)(*(void *)(*(void *)(a1 + 32) + 8) + 24) + 32) inputType:v2];
  }
  objc_autoreleasePoolPop(v3);
  uint64_t v4 = *(void *)(a1 + 32);
  uint64_t v5 = *(void *)(*(void *)(v4 + 8) + 24LL);
  if ((_DWORD)v2 != 1)
  {
    int v6 = *(_DWORD *)(v5 + 32);
    if (v6 != 13) {
      goto LABEL_14;
    }
  }

  uint64_t v7 = *(const void **)(v5 + 104);
  if (v7)
  {
    CFRelease(v7);
    *(void *)(*(void *)(*(void *)(*(void *)(a1 + 32) + 8LL) + 24LL) + 104LL) = 0LL;
    uint64_t v5 = *(void *)(*(void *)(*(void *)(a1 + 32) + 8LL) + 24LL);
  }

  *(void *)(*(void *)(*(void *)(*(void *)(a1 + 32) + 8LL) + 24LL) + 104LL) = CFUserNotificationGetResponseDictionary(*(CFUserNotificationRef *)(v5 + 120));
  uint64_t v4 = *(void *)(a1 + 32);
  uint64_t v8 = *(void *)(*(void *)(v4 + 8) + 24LL);
  CFStringRef v9 = *(const void **)(v8 + 104);
  if (v9)
  {
    CFRetain(v9);
    uint64_t v4 = *(void *)(a1 + 32);
    uint64_t v8 = *(void *)(*(void *)(v4 + 8) + 24LL);
  }

  int v6 = *(_DWORD *)(v8 + 32);
  if (v6 != 13)
  {
LABEL_14:
    uint64_t v12 = *(void *)(a1 + 40) & 3LL;
    if (v12 != 3)
    {
      if (v12 != 1)
      {
        if (v12)
        {
          int v11 = 0;
          goto LABEL_30;
        }

        if (v6 == 2)
        {
          int v11 = 1;
          goto LABEL_30;
        }

        if ((_DWORD)v2 != 2)
        {
          if (v6) {
            int v11 = 1;
          }
          else {
            int v11 = 2;
          }
          goto LABEL_30;
        }

        goto LABEL_26;
      }

      if ((_DWORD)v2 == 2 && v6 == 2)
      {
LABEL_26:
        int v11 = 4;
        goto LABEL_30;
      }
    }

    int v11 = 2;
    goto LABEL_30;
  }

  unsigned int v10 = [CFUserNotificationGetResponseDictionary(*(CFUserNotificationRef *)(v8 + 120)) objectForKey:SBSUserNotificationButtonDefinitionResponseIndexKey] intValue];
  if (v10) {
    int v11 = v10 == 1;
  }
  else {
    int v11 = 2;
  }
  uint64_t v4 = *(void *)(a1 + 32);
LABEL_30:
  uint64_t v14 = *(void **)(*(void *)(v4 + 8) + 24LL);
  CFDictionaryRef ResponseDictionary = CFUserNotificationGetResponseDictionary(*(CFUserNotificationRef *)(a1 + 48));
  sub_1000ABD40(v14, ResponseDictionary);
  CFRelease(*(CFTypeRef *)(a1 + 48));
  sub_1000ABDB4(*(void *)(*(void *)(*(void *)(a1 + 32) + 8LL) + 24LL), v11);
  id v16 = *(const void **)(*(void *)(*(void *)(a1 + 32) + 8LL) + 24LL);
  if (v16)
  {
    CFRelease(v16);
    *(void *)(*(void *)(*(void *)(a1 + 32) + 8LL) + 24LL) = 0LL;
  }

uint64_t sub_1000AC330(const void *a1, BOOL *a2, double a3)
{
  uint64_t v20 = 0LL;
  CFStringRef v21 = &v20;
  uint64_t v22 = 0x2020000000LL;
  uint64_t v23 = 0LL;
  if (a1)
  {
    if (MKBGetDeviceLockState(0LL) == 1 && !MKBUserUnlockedSinceBoot(0LL))
    {
      uint64_t v14 = objc_autoreleasePoolPush();
      if (qword_100219F60) {
        [(id)qword_100219F60 WFLog:3, "Cannot copy password for %@. Device wasn't unlocked yet", a1 message];
      }
      objc_autoreleasePoolPop(v14);
    }

    else
    {
      int v6 = dispatch_semaphore_create(0LL);
      uint64_t v16 = 0LL;
      id v17 = &v16;
      uint64_t v18 = 0x2020000000LL;
      char v19 = 0;
      CFRetain(a1);
      dispatch_queue_global_t global_queue = dispatch_get_global_queue(0LL, 0LL);
      block[0] = _NSConcreteStackBlock;
      block[1] = 3221225472LL;
      block[2] = sub_1000AC524;
      block[3] = &unk_1001E49F0;
      void block[6] = &v16;
      void block[7] = a1;
      void block[4] = v6;
      void block[5] = &v20;
      dispatch_async(global_queue, block);
      dispatch_time_t v8 = dispatch_time(0LL, (uint64_t)(a3 * 1000000000.0));
      BOOL v9 = dispatch_semaphore_wait(v6, v8) != 0;
      unsigned int v10 = v17;
      *((_BYTE *)v17 + 24) = v9;
      *a2 = v9;
      if (*((_BYTE *)v10 + 24))
      {
        int v11 = objc_autoreleasePoolPush();
        if (qword_100219F60) {
          [qword_100219F60 WFLog:@"%s:SecItemCopyMatching timed out, timeout %f\n" message:4];
        }
        objc_autoreleasePoolPop(v11);
      }

      dispatch_release(v6);
      _Block_object_dispose(&v16, 8);
    }
  }

  uint64_t v12 = v21[3];
  _Block_object_dispose(&v20, 8);
  return v12;
}

void sub_1000AC4F8(_Unwind_Exception *a1)
{
}

uint64_t sub_1000AC524(uint64_t a1)
{
  CFTypeRef result = 0LL;
  uint64_t v2 = sub_1000AC664(*(const void **)(a1 + 56), 0LL, 0LL, 0, 0, 1);
  BOOL v3 = v2;
  if (v2)
  {
    uint64_t v4 = SecItemCopyMatching(v2, &result);
    if ((_DWORD)v4) {
      BOOL v5 = 1;
    }
    else {
      BOOL v5 = result == 0LL;
    }
    if (!v5)
    {
      *(void *)(*(void *)(*(void *)(a1 + 40) + 8LL) + 24LL) = CFStringCreateFromExternalRepresentation( kCFAllocatorDefault,  (CFDataRef)result,  0x8000100u);
      goto LABEL_11;
    }
  }

  else
  {
    uint64_t v4 = 0LL;
  }

  int v6 = objc_autoreleasePoolPush();
  if (qword_100219F60) {
    [(id)qword_100219F60 WFLog:4, "%s:[%@] Error result %d \n", "WiFiSecurityCopyPasswordWithTimeout_block_invoke", *(void *)(a1 + 56), v4 message];
  }
  objc_autoreleasePoolPop(v6);
LABEL_11:
  if (result)
  {
    CFRelease(result);
    CFTypeRef result = 0LL;
  }

  if (v3) {
    CFRelease(v3);
  }
  if (*(_BYTE *)(*(void *)(*(void *)(a1 + 48) + 8LL) + 24LL))
  {
    uint64_t v7 = *(const void **)(*(void *)(*(void *)(a1 + 40) + 8LL) + 24LL);
    if (v7)
    {
      CFRelease(v7);
      *(void *)(*(void *)(*(void *)(a1 + 40) + 8LL) + 24LL) = 0LL;
    }
  }

  CFRelease(*(CFTypeRef *)(a1 + 56));
  return dispatch_semaphore_signal(*(dispatch_semaphore_t *)(a1 + 32));
}

__CFDictionary *sub_1000AC664(const void *a1, const void *a2, const void *a3, int a4, int a5, int a6)
{
  if (!a1)
  {
    CFStringRef v15 = objc_autoreleasePoolPush();
    if (qword_100219F60) {
      [qword_100219F60 WFLog:@"%s: null account" message:4];
    }
    goto LABEL_18;
  }

  CFMutableDictionaryRef Mutable = CFDictionaryCreateMutable(kCFAllocatorDefault, 0LL, 0LL, 0LL);
  if (!Mutable)
  {
    CFStringRef v15 = objc_autoreleasePoolPush();
    if (qword_100219F60) {
      [(id)qword_100219F60 WFLog:4, "%s: failed to create query for %@", "__WiFiSecurityCreateQuery", a1 message];
    }
LABEL_18:
    objc_autoreleasePoolPop(v15);
    return 0LL;
  }

  uint64_t v13 = Mutable;
  CFDictionarySetValue(Mutable, kSecClass, kSecClassGenericPassword);
  CFDictionarySetValue(v13, kSecAttrAccount, a1);
  CFDictionarySetValue(v13, kSecAttrService, @"AirPort");
  CFDictionarySetValue(v13, kSecAttrSynchronizable, kSecAttrSynchronizableAny);
  if (a2) {
    CFDictionarySetValue(v13, kSecAttrLabel, a2);
  }
  if (a3) {
    CFDictionarySetValue(v13, kSecAttrDescription, a3);
  }
  if (a6) {
    CFDictionarySetValue(v13, kSecUseSystemKeychain, kCFBooleanTrue);
  }
  if (!a4) {
    CFDictionarySetValue(v13, kSecReturnData, kCFBooleanTrue);
  }
  if (a5) {
    CFDictionarySetValue(v13, kSecReturnAttributes, kCFBooleanTrue);
  }
  return v13;
}

CFStringRef sub_1000AC858(__CFString *a1)
{
  CFStringRef result = sub_1000AC8EC(a1, 1);
  if (!result)
  {
    BOOL v3 = getprogname();
    if (!strncmp("sharingd", v3, 8uLL)) {
      return sub_1000ACA44((NSMutableString *)a1);
    }
    uint64_t v4 = getprogname();
    if (!strncmp("HPSetup", v4, 7uLL)) {
      return sub_1000ACA44((NSMutableString *)a1);
    }
    BOOL v5 = getprogname();
    if (!strncmp("HDSViewService", v5, 0xEuLL)) {
      return sub_1000ACA44((NSMutableString *)a1);
    }
    else {
      return 0LL;
    }
  }

  return result;
}

CFStringRef sub_1000AC8EC(const __CFString *a1, int a2)
{
  CFStringRef v2 = a1;
  if (!a1) {
    return v2;
  }
  if (MKBGetDeviceLockState(0LL) != 1 || MKBUserUnlockedSinceBoot(0LL))
  {
    uint64_t v4 = sub_1000AC664(v2, 0LL, 0LL, 0, 0, a2);
    BOOL v5 = v4;
    CFTypeRef result = 0LL;
    if (v4)
    {
      uint64_t v6 = SecItemCopyMatching(v4, &result);
      if (!(_DWORD)v6 && result)
      {
        CFStringRef v2 = CFStringCreateFromExternalRepresentation(kCFAllocatorDefault, (CFDataRef)result, 0x8000100u);
LABEL_12:
        if (result)
        {
          CFRelease(result);
          CFTypeRef result = 0LL;
        }

        if (v5) {
          CFRelease(v5);
        }
        return v2;
      }
    }

    else
    {
      uint64_t v6 = 0LL;
    }

    uint64_t v7 = objc_autoreleasePoolPush();
    if (qword_100219F60) {
      [(id)qword_100219F60 WFLog:4, "%s:[%@] Error result %d \n", "__WiFiSecurityCopyPassword", v2, v6 message];
    }
    objc_autoreleasePoolPop(v7);
    CFStringRef v2 = 0LL;
    goto LABEL_12;
  }

  dispatch_time_t v8 = objc_autoreleasePoolPush();
  if (qword_100219F60) {
    [(id)qword_100219F60 WFLog:3, "Cannot copy password for %@. Device wasn't unlocked yet", v2 message];
  }
  objc_autoreleasePoolPop(v8);
  return 0LL;
}

CFStringRef sub_1000ACA44(NSMutableString *a1)
{
  CFStringRef v2 = objc_autoreleasePoolPush();
  CFTypeRef result = 0LL;
  if (a1)
  {
    if (-[NSMutableString length](a1, "length"))
    {
      BOOL v3 = sub_1000AE514(a1);
      uint64_t v4 = v3;
      if (v3 && -[NSMutableString length](v3, "length"))
      {
        if (os_log_type_enabled((os_log_t)&_os_log_default, OS_LOG_TYPE_DEFAULT))
        {
          *(_DWORD *)buf = 136315650;
          uint64_t v14 = "WiFiSecurityCopyPasswordFromPasswordBackup";
          __int16 v15 = 2112;
          uint64_t v16 = a1;
          __int16 v17 = 2112;
          uint64_t v18 = v4;
          _os_log_impl( (void *)&_mh_execute_header,  (os_log_t)&_os_log_default,  OS_LOG_TYPE_DEFAULT,  "%s: ssid %@ (%@)",  buf,  0x20u);
        }

        id v5 = +[NSMutableDictionary dictionary](&OBJC_CLASS___NSMutableDictionary, "dictionary");
        [v5 setObject:kSecClassGenericPassword forKey:kSecClass];
        [v5 setObject:v4 forKey:kSecAttrAccount];
        [v5 setObject:@"AirPort" forKey:kSecAttrService];
        [v5 setObject:&__kCFBooleanTrue forKey:kSecReturnData];
        OSStatus v6 = SecItemCopyMatching((CFDictionaryRef)v5, &result);
        if (!v6 && result)
        {
          CFStringRef v7 = CFStringCreateFromExternalRepresentation(kCFAllocatorDefault, (CFDataRef)result, 0x8000100u);
          goto LABEL_14;
        }

        if (!os_log_type_enabled((os_log_t)&_os_log_default, OS_LOG_TYPE_DEFAULT)) {
          goto LABEL_13;
        }
        *(_DWORD *)buf = 136315650;
        uint64_t v14 = "WiFiSecurityCopyPasswordFromPasswordBackup";
        __int16 v15 = 2112;
        uint64_t v16 = v4;
        __int16 v17 = 1024;
        LODWORD(v1_Block_object_dispose((const void *)(v1 - 80), 8) = v6;
        dispatch_time_t v8 = "%s:[%@] error result %d \n";
        uint32_t v9 = 28;
      }

      else
      {
        if (!os_log_type_enabled((os_log_t)&_os_log_default, OS_LOG_TYPE_DEFAULT)) {
          goto LABEL_13;
        }
        *(_DWORD *)buf = 136315138;
        uint64_t v14 = "WiFiSecurityCopyPasswordFromPasswordBackup";
        dispatch_time_t v8 = "%s: error: empty ssid hash";
        uint32_t v9 = 12;
      }

      _os_log_impl((void *)&_mh_execute_header, (os_log_t)&_os_log_default, OS_LOG_TYPE_DEFAULT, v8, buf, v9);
LABEL_13:
      CFStringRef v7 = 0LL;
      goto LABEL_14;
    }

    if (os_log_type_enabled((os_log_t)&_os_log_default, OS_LOG_TYPE_DEFAULT))
    {
      *(_DWORD *)buf = 136315138;
      uint64_t v14 = "WiFiSecurityCopyPasswordFromPasswordBackup";
      int v11 = "%s: error: empty ssid";
      goto LABEL_23;
    }
  }

  else if (os_log_type_enabled((os_log_t)&_os_log_default, OS_LOG_TYPE_DEFAULT))
  {
    *(_DWORD *)buf = 136315138;
    uint64_t v14 = "WiFiSecurityCopyPasswordFromPasswordBackup";
    int v11 = "%s: null ssid";
LABEL_23:
    _os_log_impl((void *)&_mh_execute_header, (os_log_t)&_os_log_default, OS_LOG_TYPE_DEFAULT, v11, buf, 0xCu);
  }

  CFStringRef v7 = 0LL;
  uint64_t v4 = 0LL;
LABEL_14:

  if (result) {
    CFRelease(result);
  }
  objc_autoreleasePoolPop(v2);
  return v7;
}

CFStringRef sub_1000ACD7C(const __CFString *a1)
{
  return sub_1000AC8EC(a1, 0);
}

CFTypeRef sub_1000ACD84(const void *a1)
{
  CFTypeRef result = 0LL;
  if (!a1)
  {
    uint32_t v9 = objc_autoreleasePoolPush();
    if (qword_100219F60) {
      [qword_100219F60 WFLog:@"%s: null account" message:4 v10];
    }
    goto LABEL_21;
  }

  if (MKBGetDeviceLockState(0LL) == 1 && !MKBUserUnlockedSinceBoot(0LL))
  {
    uint32_t v9 = objc_autoreleasePoolPush();
    if (qword_100219F60) {
      [(id)qword_100219F60 WFLog:4, "%s: Cannot get keychain attributes for %@. Device wasn't unlocked yet", "WiFiSecurityCopyPasswordModificationDate", a1 message];
    }
LABEL_21:
    objc_autoreleasePoolPop(v9);
    CFTypeRef v6 = 0LL;
    BOOL v3 = 0LL;
    goto LABEL_12;
  }

  CFStringRef v2 = sub_1000AC664(a1, 0LL, 0LL, 0, 1, 1);
  BOOL v3 = v2;
  if (v2)
  {
    uint64_t v4 = SecItemCopyMatching(v2, &result);
    if (!(_DWORD)v4 && result)
    {
      CFBooleanRef Value = CFDictionaryGetValue((CFDictionaryRef)result, kSecAttrModificationDate);
      CFTypeRef v6 = CFRetain(Value);
      goto LABEL_12;
    }
  }

  else
  {
    uint64_t v4 = 0LL;
  }

  CFStringRef v7 = objc_autoreleasePoolPush();
  if (qword_100219F60) {
    [(id)qword_100219F60 WFLog:4, "%s:[%@] Error result %d", "WiFiSecurityCopyPasswordModificationDate", a1, v4 message];
  }
  objc_autoreleasePoolPop(v7);
  CFTypeRef v6 = 0LL;
LABEL_12:
  if (result)
  {
    CFRelease(result);
    CFTypeRef result = 0LL;
  }

  if (v3) {
    CFRelease(v3);
  }
  return v6;
}

uint64_t sub_1000ACF10(const void *a1, const __CFString *a2, BOOL *a3, double a4)
{
  BOOL v27 = 0;
  dispatch_time_t v8 = objc_autoreleasePoolPush();
  if (qword_100219F60) {
    [(id)qword_100219F60 WFLog:3, "%s: for account %@", "WiFiSecuritySetPasswordWithTimeout", a1 message];
  }
  objc_autoreleasePoolPop(v8);
  if (!a1)
  {
    uint64_t v22 = objc_autoreleasePoolPush();
    if (qword_100219F60) {
      [qword_100219F60 WFLog:@"%s: null account" message:4 v25];
    }
    goto LABEL_35;
  }

  if (!a2)
  {
    uint64_t v22 = objc_autoreleasePoolPush();
    if (qword_100219F60) {
      [qword_100219F60 WFLog:@"%s: null password" message:@"WiFiSecuritySetPasswordWithTimeout" v25];
    }
    goto LABEL_35;
  }

  if (!CFStringGetLength(a2))
  {
    uint64_t v22 = objc_autoreleasePoolPush();
    if (qword_100219F60) {
      [(id)qword_100219F60 WFLog:4, "%s: Error: Empty password for account %@", "WiFiSecuritySetPasswordWithTimeout", a1 message];
    }
LABEL_35:
    objc_autoreleasePoolPop(v22);
    return 0LL;
  }

  CFDataRef ExternalRepresentation = CFStringCreateExternalRepresentation(kCFAllocatorDefault, a2, 0x8000100u, 0);
  uint64_t v10 = (const __CFString *)sub_1000AC330(a1, &v27, a4);
  int v11 = v10;
  BOOL v12 = v27;
  if (v27)
  {
    uint64_t v13 = 0LL;
    *a3 = 1;
    uint64_t v14 = 4294899568LL;
  }

  else
  {
    if (v10)
    {
      if (CFStringCompare(a2, v10, 0LL) == kCFCompareEqualTo)
      {
        *a3 = v12;
        uint64_t v20 = 1LL;
        goto LABEL_25;
      }

      __int16 v15 = sub_1000AC664(a1, 0LL, 0LL, 1, 0, 1);
      if (!v15)
      {
        uint64_t v23 = objc_autoreleasePoolPush();
        if (qword_100219F60) {
          [qword_100219F60 WFLog:@"%s: null query" message:4];
        }
        objc_autoreleasePoolPop(v23);
        uint64_t v20 = 0LL;
        goto LABEL_25;
      }

      uint64_t v13 = v15;
      CFMutableDictionaryRef Mutable = CFDictionaryCreateMutable(kCFAllocatorDefault, 0LL, 0LL, 0LL);
      CFDictionarySetValue(Mutable, kSecValueData, ExternalRepresentation);
      CFDictionarySetValue(Mutable, kSecAttrLabel, a1);
      CFDictionarySetValue(Mutable, kSecAttrDescription, @"AirPort network password");
      uint64_t v14 = SecItemUpdate(v13, Mutable);
      if (Mutable) {
        CFRelease(Mutable);
      }
    }

    else
    {
      __int16 v17 = sub_1000AC664(a1, a1, @"AirPort network password", 1, 0, 1);
      if (!v17)
      {
        id v24 = objc_autoreleasePoolPush();
        if (qword_100219F60) {
          [qword_100219F60 WFLog:@"%s: null query" message:4];
        }
        objc_autoreleasePoolPop(v24);
        uint64_t v20 = 0LL;
        if (ExternalRepresentation) {
          goto LABEL_27;
        }
        return v20;
      }

      uint64_t v13 = v17;
      CFTypeRef result = (CFTypeRef)0xAAAAAAAAAAAAAAAALL;
      CFDictionarySetValue(v17, kSecValueData, ExternalRepresentation);
      CFDictionarySetValue(v13, kSecAttrAccessible, kSecAttrAccessibleAfterFirstUnlock);
      CFDictionarySetValue(v13, kSecAttrSynchronizable, kCFBooleanTrue);
      uint64_t v14 = SecItemAdd(v13, &result);
    }

    *a3 = v12;
    if (!(_DWORD)v14)
    {
      notify_post("com.apple.wifid.WiFiPasswordChanged");
      uint64_t v19 = 1LL;
      goto LABEL_22;
    }
  }

  uint64_t v18 = objc_autoreleasePoolPush();
  if (qword_100219F60) {
    [(id)qword_100219F60 WFLog:4, "%s:[%@] Error result %d \n", "WiFiSecuritySetPasswordWithTimeout", a1, v14 message];
  }
  objc_autoreleasePoolPop(v18);
  uint64_t v19 = 0LL;
  uint64_t v20 = 0LL;
  if (!v13)
  {
    if (!v11) {
      goto LABEL_26;
    }
LABEL_25:
    CFRelease(v11);
    goto LABEL_26;
  }

BOOL sub_1000AD2DC(__CFString *a1, const __CFString *a2)
{
  return sub_1000AD2E4(a1, a2, 1);
}

BOOL sub_1000AD2E4(__CFString *a1, CFStringRef theString, int a3)
{
  if (!a1)
  {
    uint64_t v16 = objc_autoreleasePoolPush();
    if (qword_100219F60) {
      [qword_100219F60 WFLog:@"%s: null account" message:4];
    }
    goto LABEL_29;
  }

  if (!theString)
  {
    uint64_t v16 = objc_autoreleasePoolPush();
    if (qword_100219F60) {
      [qword_100219F60 WFLog:@"%s: null password" message:4];
    }
    goto LABEL_29;
  }

  if (!CFStringGetLength(theString))
  {
    uint64_t v16 = objc_autoreleasePoolPush();
    if (qword_100219F60) {
      [(id)qword_100219F60 WFLog:4, "%s: Error: Empty password for account %@", "__WiFiSecuritySetPassword", a1 message];
    }
LABEL_29:
    objc_autoreleasePoolPop(v16);
    return 0LL;
  }

  CFDataRef ExternalRepresentation = CFStringCreateExternalRepresentation(kCFAllocatorDefault, theString, 0x8000100u, 0);
  CFStringRef v7 = sub_1000AC858(a1);
  if (v7)
  {
    if (CFStringCompare(theString, v7, 0LL) == kCFCompareEqualTo)
    {
      BOOL v13 = 1LL;
LABEL_19:
      CFRelease(v7);
      goto LABEL_20;
    }

    dispatch_time_t v8 = sub_1000AC664(a1, 0LL, 0LL, 1, 0, a3);
    if (!v8)
    {
      __int16 v17 = objc_autoreleasePoolPush();
      if (qword_100219F60) {
        [qword_100219F60 WFLog:@"%s: null query" message:4];
      }
      objc_autoreleasePoolPop(v17);
      BOOL v13 = 0LL;
      goto LABEL_19;
    }

    uint32_t v9 = v8;
    CFMutableDictionaryRef Mutable = CFDictionaryCreateMutable(kCFAllocatorDefault, 0LL, 0LL, 0LL);
    CFDictionarySetValue(Mutable, kSecValueData, ExternalRepresentation);
    CFDictionarySetValue(Mutable, kSecAttrLabel, a1);
    CFDictionarySetValue(Mutable, kSecAttrDescription, @"AirPort network password");
    uint64_t v11 = SecItemUpdate(v9, Mutable);
    if (Mutable) {
      CFRelease(Mutable);
    }
  }

  else
  {
    BOOL v12 = sub_1000AC664(a1, a1, @"AirPort network password", 1, 0, a3);
    if (!v12)
    {
      uint64_t v18 = objc_autoreleasePoolPush();
      if (qword_100219F60) {
        objc_msgSend((id)qword_100219F60, "WFLog:message:", 4, "%s: null query", "__WiFiSecuritySetPassword");
      }
      objc_autoreleasePoolPop(v18);
      BOOL v13 = 0LL;
      if (ExternalRepresentation) {
        goto LABEL_21;
      }
      return v13;
    }

    uint32_t v9 = v12;
    CFTypeRef result = (CFTypeRef)0xAAAAAAAAAAAAAAAALL;
    CFDictionarySetValue(v12, kSecValueData, ExternalRepresentation);
    CFDictionarySetValue(v9, kSecAttrAccessible, kSecAttrAccessibleAfterFirstUnlock);
    CFDictionarySetValue(v9, kSecAttrSynchronizable, kCFBooleanTrue);
    uint64_t v11 = SecItemAdd(v9, &result);
  }

  BOOL v13 = (_DWORD)v11 == 0;
  if ((_DWORD)v11)
  {
    uint64_t v14 = objc_autoreleasePoolPush();
    if (qword_100219F60) {
      [(id)qword_100219F60 WFLog:4, "%s:[%@] Error result %d \n", "__WiFiSecuritySetPassword", a1, v11 message];
    }
    objc_autoreleasePoolPop(v14);
  }

  else
  {
    notify_post("com.apple.wifid.WiFiPasswordChanged");
  }

  CFRelease(v9);
  if (v7) {
    goto LABEL_19;
  }
LABEL_20:
  if (ExternalRepresentation) {
LABEL_21:
  }
    CFRelease(ExternalRepresentation);
  return v13;
}

BOOL sub_1000AD678(__CFString *a1, const __CFString *a2)
{
  return sub_1000AD2E4(a1, a2, 0);
}

uint64_t sub_1000AD680(const void *a1)
{
  CFStringRef v2 = objc_autoreleasePoolPush();
  if (qword_100219F60) {
    [(id)qword_100219F60 WFLog:4, "%s: Removing password for %@", "WiFiSecurityRemovePassword", a1 message];
  }
  objc_autoreleasePoolPop(v2);
  return sub_1000AD6E8(a1, 1);
}

uint64_t sub_1000AD6E8(const void *a1, int a2)
{
  if (!a1)
  {
    uint32_t v9 = objc_autoreleasePoolPush();
    if (qword_100219F60) {
      [qword_100219F60 WFLog:@"%s: null account" message:4];
    }
    goto LABEL_13;
  }

  BOOL v3 = sub_1000AC664(a1, 0LL, 0LL, 0, 0, a2);
  if (!v3)
  {
    uint32_t v9 = objc_autoreleasePoolPush();
    if (qword_100219F60) {
      [qword_100219F60 WFLog:@"%s: null query" message:4];
    }
LABEL_13:
    CFStringRef v7 = v9;
LABEL_7:
    objc_autoreleasePoolPop(v7);
    return 0LL;
  }

  uint64_t v4 = v3;
  uint64_t v5 = SecItemDelete(v3);
  CFRelease(v4);
  if ((_DWORD)v5)
  {
    CFTypeRef v6 = objc_autoreleasePoolPush();
    if (qword_100219F60) {
      [(id)qword_100219F60 WFLog:4, "%s:[%@] Error result %d \n", "__WiFiSecurityRemovePassword", a1, v5 message];
    }
    CFStringRef v7 = v6;
    goto LABEL_7;
  }

  notify_post("com.apple.wifid.WiFiPasswordChanged");
  return 1LL;
}

uint64_t sub_1000AD810(const void *a1)
{
  return sub_1000AD6E8(a1, 0);
}

uint64_t sub_1000AD818(const void *a1)
{
  CFTypeRef result = 0LL;
  if (a1)
  {
    if (MKBGetDeviceLockState(0LL) != 1 || MKBUserUnlockedSinceBoot(0LL))
    {
      CFStringRef v2 = sub_1000AC664(a1, 0LL, 0LL, 0, 1, 1);
      BOOL v3 = v2;
      if (v2)
      {
        uint64_t v4 = SecItemCopyMatching(v2, &result);
        if (!(_DWORD)v4 && result)
        {
          CFBooleanRef Value = (const __CFBoolean *)CFDictionaryGetValue((CFDictionaryRef)result, kSecAttrSynchronizable);
          if (Value)
          {
            uint64_t v6 = CFBooleanGetValue(Value);
            goto LABEL_14;
          }

          goto LABEL_13;
        }
      }

      else
      {
        uint64_t v4 = 0LL;
      }

      CFStringRef v7 = objc_autoreleasePoolPush();
      if (qword_100219F60) {
        [(id)qword_100219F60 WFLog:4, "%s:[%@] Error result %d \n", "WiFiSecurityIsPasswordSyncing", a1, v4 message];
      }
      objc_autoreleasePoolPop(v7);
LABEL_13:
      uint64_t v6 = 0LL;
      goto LABEL_14;
    }

    uint32_t v9 = objc_autoreleasePoolPush();
    if (qword_100219F60) {
      [(id)qword_100219F60 WFLog:4, "%s: Cannot get keychain attributes for %@. Device wasn't unlocked yet", "WiFiSecurityIsPasswordSyncing", a1 message];
    }
  }

  else
  {
    uint32_t v9 = objc_autoreleasePoolPush();
    if (qword_100219F60) {
      objc_msgSend((id)qword_100219F60, "WFLog:message:", 4, "%s: null account", "WiFiSecurityIsPasswordSyncing", v10);
    }
  }

  objc_autoreleasePoolPop(v9);
  uint64_t v6 = 0LL;
  BOOL v3 = 0LL;
LABEL_14:
  if (result)
  {
    CFRelease(result);
    CFTypeRef result = 0LL;
  }

  if (v3) {
    CFRelease(v3);
  }
  return v6;
}

BOOL sub_1000AD9A8(__CFString *a1, uint64_t a2)
{
  if (!a1)
  {
    uint64_t v16 = objc_autoreleasePoolPush();
    if (qword_100219F60) {
      [qword_100219F60 WFLog:@"%s: null account" message:3];
    }
    goto LABEL_18;
  }

  CFStringRef v4 = sub_1000AC858(a1);
  if (!v4)
  {
    uint64_t v16 = objc_autoreleasePoolPush();
    if (qword_100219F60) {
      [qword_100219F60 WFLog:@"%s: null existingPassword" message:3];
    }
LABEL_18:
    objc_autoreleasePoolPop(v16);
    return 0LL;
  }

  CFStringRef v5 = v4;
  uint64_t v6 = sub_1000AC664(a1, 0LL, 0LL, 0, 0, 1);
  if (!v6)
  {
    __int16 v17 = objc_autoreleasePoolPush();
    if (qword_100219F60) {
      objc_msgSend((id)qword_100219F60, "WFLog:message:", 3, "%s: null query", "WiFiSecuritySetPasswordSyncable");
    }
    objc_autoreleasePoolPop(v17);
    CFRelease(v5);
    return 0LL;
  }

  CFStringRef v7 = v6;
  CFMutableDictionaryRef Mutable = CFDictionaryCreateMutable(kCFAllocatorDefault, 0LL, 0LL, 0LL);
  if (Mutable)
  {
    uint32_t v9 = Mutable;
    uint64_t v10 = (const void **)&kCFBooleanFalse;
    if ((_DWORD)a2) {
      uint64_t v10 = (const void **)&kCFBooleanTrue;
    }
    CFDictionarySetValue(Mutable, kSecAttrSynchronizable, *v10);
    CFDictionaryRemoveValue(v7, kSecReturnData);
    uint64_t v11 = SecItemUpdate(v7, v9);
    BOOL v12 = (_DWORD)v11 == 0;
    if ((_DWORD)v11)
    {
      uint64_t v13 = v11;
      uint64_t v14 = objc_autoreleasePoolPush();
      if (qword_100219F60) {
        [(id)qword_100219F60 WFLog:4, "%s:[%@]%d Error result %d \n", "WiFiSecuritySetPasswordSyncable", a1, a2, v13 message];
      }
      objc_autoreleasePoolPop(v14);
    }

    CFRelease(v9);
  }

  else
  {
    uint64_t v18 = objc_autoreleasePoolPush();
    if (qword_100219F60) {
      objc_msgSend((id)qword_100219F60, "WFLog:message:", 3, "%s: null newVal", "WiFiSecuritySetPasswordSyncable");
    }
    objc_autoreleasePoolPop(v18);
    BOOL v12 = 0LL;
  }

  CFRelease(v5);
  CFRelease(v7);
  return v12;
}

__CFString *sub_1000ADBF8(const __CFString *a1, const __CFData *a2)
{
  CFMutableDictionaryRef Mutable = 0LL;
  if (a1 && a2)
  {
    *(_OWORD *)bytes = 0u;
    __int128 v13 = 0u;
    CStringPtr = CFStringGetCStringPtr(a1, 0x8000100u);
    BytePtr = CFDataGetBytePtr(a2);
    CFIndex Length = CFDataGetLength(a2);
    CFStringRef v7 = CFDataCreate(kCFAllocatorDefault, bytes, 32LL);
    if (!v7)
    {
      return 0LL;
    }

    else
    {
      dispatch_time_t v8 = v7;
      uint32_t v9 = CFDataGetBytePtr(v7);
      if (CFDataGetLength(v8) == 32)
      {
        CFMutableDictionaryRef Mutable = CFStringCreateMutable(kCFAllocatorDefault, 64LL);
        for (uint64_t i = 0LL; i != 32; ++i)
          CFStringAppendFormat(Mutable, 0LL, @"%02x", v9[i]);
      }

      else
      {
        CFMutableDictionaryRef Mutable = 0LL;
      }

      CFRelease(v8);
    }
  }

  return Mutable;
}

CFTypeRef sub_1000ADD48()
{
  CFTypeRef result = 0LL;
  if (MKBGetDeviceLockState(0LL) == 1 && !MKBUserUnlockedSinceBoot(0LL))
  {
    uint64_t v6 = objc_autoreleasePoolPush();
    if (qword_100219F60) {
      [qword_100219F60 WFLog:@"Cannot get all airport keychain attributes. Device wasn't unlocked yet" message:4];
    }
    goto LABEL_12;
  }

  CFMutableDictionaryRef Mutable = CFDictionaryCreateMutable(kCFAllocatorDefault, 0LL, 0LL, 0LL);
  if (!Mutable)
  {
    uint64_t v6 = objc_autoreleasePoolPush();
    if (qword_100219F60) {
      [qword_100219F60 WFLog:@"%s: failed to create query" message:4];
    }
LABEL_12:
    objc_autoreleasePoolPop(v6);
    return 0LL;
  }

  uint64_t v1 = Mutable;
  CFDictionarySetValue(Mutable, kSecClass, kSecClassGenericPassword);
  CFDictionarySetValue(v1, kSecMatchLimit, kSecMatchLimitAll);
  CFDictionarySetValue(v1, kSecAttrService, @"AirPort");
  CFDictionarySetValue(v1, kSecAttrSynchronizable, kSecAttrSynchronizableAny);
  CFDictionarySetValue(v1, kSecReturnAttributes, kCFBooleanTrue);
  CFDictionarySetValue(v1, kSecUseSystemKeychain, kCFBooleanTrue);
  uint64_t v2 = SecItemCopyMatching(v1, &result);
  if ((_DWORD)v2 && result)
  {
    uint64_t v3 = v2;
    CFStringRef v4 = objc_autoreleasePoolPush();
    if (qword_100219F60) {
      [qword_100219F60 WFLog:@"WiFiSecurityCopyAttributesForAllAirPortEntries Error result %d" message:4];
    }
    objc_autoreleasePoolPop(v4);
  }

  CFRelease(v1);
  return result;
}

CFStringRef sub_1000ADF40(const __CFString *a1)
{
  CFStringRef v1 = a1;
  CFTypeRef result = 0LL;
  if (!a1) {
    return v1;
  }
  uint64_t v2 = objc_autoreleasePoolPush();
  if (qword_100219F60) {
    [(id)qword_100219F60 WFLog:3, "%s: Attempting to fetch non-syncable password for account %@", "WiFiSecurityCopyNonSyncablePassword", v1 message];
  }
  objc_autoreleasePoolPop(v2);
  if (MKBGetDeviceLockState(0LL) == 1 && !MKBUserUnlockedSinceBoot(0LL))
  {
    uint32_t v9 = objc_autoreleasePoolPush();
    if (qword_100219F60) {
      [(id)qword_100219F60 WFLog:3, "Cannot copy password for %@. Device wasn't unlocked yet", v1 message];
    }
    objc_autoreleasePoolPop(v9);
    CFStringRef v4 = 0LL;
    goto LABEL_18;
  }

  CFMutableDictionaryRef Mutable = CFDictionaryCreateMutable(kCFAllocatorDefault, 0LL, 0LL, 0LL);
  CFStringRef v4 = Mutable;
  if (!Mutable)
  {
LABEL_18:
    CFStringRef v1 = 0LL;
    goto LABEL_19;
  }

  CFDictionarySetValue(Mutable, kSecClass, kSecClassGenericPassword);
  CFDictionarySetValue(v4, kSecAttrAccount, v1);
  CFDictionarySetValue(v4, kSecAttrService, @"AirPort");
  CFDictionarySetValue(v4, kSecUseSystemKeychain, kCFBooleanTrue);
  CFDictionarySetValue(v4, kSecReturnData, kCFBooleanTrue);
  uint64_t v5 = SecItemCopyMatching(v4, &result);
  if ((_DWORD)v5) {
    BOOL v6 = 1;
  }
  else {
    BOOL v6 = result == 0LL;
  }
  if (v6)
  {
    uint64_t v7 = v5;
    dispatch_time_t v8 = objc_autoreleasePoolPush();
    if (qword_100219F60) {
      [(id)qword_100219F60 WFLog:3, "%s:[%@] Error result %d", "WiFiSecurityCopyNonSyncablePassword", v1, v7 message];
    }
    objc_autoreleasePoolPop(v8);
    goto LABEL_18;
  }

  CFStringRef v1 = CFStringCreateFromExternalRepresentation(kCFAllocatorDefault, (CFDataRef)result, 0x8000100u);
LABEL_19:
  if (result)
  {
    CFRelease(result);
    CFTypeRef result = 0LL;
  }

  if (v4) {
    CFRelease(v4);
  }
  return v1;
}

uint64_t sub_1000AE154(const void *a1, BOOL *a2, double a3)
{
  uint64_t v20 = 0LL;
  CFStringRef v21 = &v20;
  uint64_t v22 = 0x2020000000LL;
  uint64_t v23 = 0LL;
  if (a1)
  {
    if (MKBGetDeviceLockState(0LL) == 1 && !MKBUserUnlockedSinceBoot(0LL))
    {
      uint64_t v14 = objc_autoreleasePoolPush();
      if (qword_100219F60) {
        [(id)qword_100219F60 WFLog:3, "Cannot copy password for %@. Device wasn't unlocked yet", a1 message];
      }
      objc_autoreleasePoolPop(v14);
    }

    else
    {
      BOOL v6 = dispatch_semaphore_create(0LL);
      uint64_t v16 = 0LL;
      __int16 v17 = &v16;
      uint64_t v18 = 0x2020000000LL;
      char v19 = 0;
      CFRetain(a1);
      dispatch_queue_global_t global_queue = dispatch_get_global_queue(0LL, 0LL);
      block[0] = _NSConcreteStackBlock;
      block[1] = 3221225472LL;
      block[2] = sub_1000AE348;
      block[3] = &unk_1001E49F0;
      void block[6] = &v16;
      void block[7] = a1;
      void block[4] = v6;
      void block[5] = &v20;
      dispatch_async(global_queue, block);
      dispatch_time_t v8 = dispatch_time(0LL, (uint64_t)(a3 * 1000000000.0));
      BOOL v9 = dispatch_semaphore_wait(v6, v8) != 0;
      uint64_t v10 = v17;
      *((_BYTE *)v17 + 24) = v9;
      *a2 = v9;
      if (*((_BYTE *)v10 + 24))
      {
        uint64_t v11 = objc_autoreleasePoolPush();
        if (qword_100219F60) {
          [qword_100219F60 WFLog:@"%s:SecItemCopyMatching timed out, timeout %f\n" message:4];
        }
        objc_autoreleasePoolPop(v11);
      }

      dispatch_release(v6);
      _Block_object_dispose(&v16, 8);
    }
  }

  uint64_t v12 = v21[3];
  _Block_object_dispose(&v20, 8);
  return v12;
}

void sub_1000AE31C(_Unwind_Exception *a1)
{
}

uint64_t sub_1000AE348(uint64_t a1)
{
  CFTypeRef result = 0LL;
  CFMutableDictionaryRef Mutable = CFDictionaryCreateMutable(kCFAllocatorDefault, 0LL, 0LL, 0LL);
  uint64_t v3 = Mutable;
  if (Mutable)
  {
    CFDictionarySetValue(Mutable, kSecClass, kSecClassGenericPassword);
    CFDictionarySetValue(v3, kSecAttrAccount, *(const void **)(a1 + 56));
    CFDictionarySetValue(v3, kSecAttrService, @"AirPort");
    CFDictionarySetValue(v3, kSecUseSystemKeychain, kCFBooleanTrue);
    CFDictionarySetValue(v3, kSecReturnData, kCFBooleanTrue);
    uint64_t v4 = SecItemCopyMatching(v3, &result);
    if ((_DWORD)v4) {
      BOOL v5 = 1;
    }
    else {
      BOOL v5 = result == 0LL;
    }
    if (!v5)
    {
      *(void *)(*(void *)(*(void *)(a1 + 40) + 8LL) + 24LL) = CFStringCreateFromExternalRepresentation( kCFAllocatorDefault,  (CFDataRef)result,  0x8000100u);
      goto LABEL_11;
    }
  }

  else
  {
    uint64_t v4 = 0LL;
  }

  BOOL v6 = objc_autoreleasePoolPush();
  if (qword_100219F60) {
    [(id)qword_100219F60 WFLog:4, "%s:[%@] Error result %d \n", "WiFiSecurityCopyNonSyncablePasswordWithTimeout_block_invoke", *(void *)(a1 + 56), v4 message];
  }
  objc_autoreleasePoolPop(v6);
LABEL_11:
  if (result)
  {
    CFRelease(result);
    CFTypeRef result = 0LL;
  }

  if (v3) {
    CFRelease(v3);
  }
  if (*(_BYTE *)(*(void *)(*(void *)(a1 + 48) + 8LL) + 24LL))
  {
    uint64_t v7 = *(const void **)(*(void *)(*(void *)(a1 + 40) + 8LL) + 24LL);
    if (v7)
    {
      CFRelease(v7);
      *(void *)(*(void *)(*(void *)(a1 + 40) + 8LL) + 24LL) = 0LL;
    }
  }

  CFRelease(*(CFTypeRef *)(a1 + 56));
  return dispatch_semaphore_signal(*(dispatch_semaphore_t *)(a1 + 32));
}

NSMutableString *sub_1000AE514(void *a1)
{
  uint64_t v2 = objc_autoreleasePoolPush();
  *(void *)&__int128 v3 = 0xAAAAAAAAAAAAAAAALL;
  *((void *)&v3 + 1) = 0xAAAAAAAAAAAAAAAALL;
  macOut[0] = v3;
  macOut[1] = v3;
  uint64_t v4 = (const char *)[a1 cStringUsingEncoding:4];
  size_t v5 = strlen(v4);
  CCHmac(2u, "CURRENT_NETWORK", 0xFuLL, v4, v5, macOut);
  BOOL v6 = -[NSMutableString initWithCapacity:](objc_alloc(&OBJC_CLASS___NSMutableString), "initWithCapacity:", 64LL);
  for (uint64_t i = 0LL; i != 32; ++i)
    -[NSMutableString appendFormat:](v6, "appendFormat:", @"%02x", *((unsigned __int8 *)macOut + i));
  objc_autoreleasePoolPop(v2);
  return v6;
}

BOOL sub_1000AE60C(uint64_t a1, uint64_t a2)
{
  uint64_t v4 = objc_autoreleasePoolPush();
  size_t v5 = dispatch_semaphore_create(0LL);
  uint64_t v12 = 0LL;
  __int128 v13 = &v12;
  uint64_t v14 = 0x2020000000LL;
  int v15 = 0;
  v11[0] = _NSConcreteStackBlock;
  v11[1] = 3221225472LL;
  v11[2] = sub_1000AE7E4;
  void v11[3] = &unk_1001E4A18;
  v11[4] = a1;
  void v11[5] = a2;
  v11[6] = v5;
  v11[7] = &v12;
  dispatch_async(&_dispatch_main_q, v11);
  dispatch_time_t v6 = dispatch_time(0LL, 1000000000LL);
  uint64_t v7 = dispatch_semaphore_wait(v5, v6);
  BOOL v8 = os_log_type_enabled((os_log_t)&_os_log_default, OS_LOG_TYPE_DEFAULT);
  if (v7)
  {
    if (v8)
    {
      *(_DWORD *)buf = 136315394;
      __int16 v17 = "WiFiSecuritySavePasswordForPasswordBackup";
      __int16 v18 = 2112;
      uint64_t v19 = a1;
      _os_log_impl( (void *)&_mh_execute_header,  (os_log_t)&_os_log_default,  OS_LOG_TYPE_DEFAULT,  "%s:[%@] timed out\n",  buf,  0x16u);
    }

    BOOL v9 = 0LL;
  }

  else
  {
    if (v8)
    {
      *(_DWORD *)buf = 136315394;
      __int16 v17 = "WiFiSecuritySavePasswordForPasswordBackup";
      __int16 v18 = 2112;
      uint64_t v19 = a1;
      _os_log_impl( (void *)&_mh_execute_header,  (os_log_t)&_os_log_default,  OS_LOG_TYPE_DEFAULT,  "%s:[%@] completed\n",  buf,  0x16u);
    }

    BOOL v9 = *((_DWORD *)v13 + 6) == 0;
  }

  dispatch_release(v5);
  _Block_object_dispose(&v12, 8);
  objc_autoreleasePoolPop(v4);
  return v9;
}

uint64_t sub_1000AE7E4(uint64_t a1)
{
  CFTypeRef result = (CFTypeRef)0xAAAAAAAAAAAAAAAALL;
  uint64_t v2 = *(void **)(a1 + 32);
  if (!v2)
  {
    if (!os_log_type_enabled((os_log_t)&_os_log_default, OS_LOG_TYPE_DEFAULT)) {
      goto LABEL_28;
    }
    *(_DWORD *)buf = 136315138;
    __int16 v17 = "WiFiSecuritySavePasswordForPasswordBackup_block_invoke";
    uint64_t v12 = "%s: null ssid";
LABEL_24:
    uint32_t v13 = 12;
LABEL_27:
    _os_log_impl((void *)&_mh_execute_header, (os_log_t)&_os_log_default, OS_LOG_TYPE_DEFAULT, v12, buf, v13);
    goto LABEL_28;
  }

  if (!*(void *)(a1 + 40))
  {
    if (!os_log_type_enabled((os_log_t)&_os_log_default, OS_LOG_TYPE_DEFAULT)) {
      goto LABEL_28;
    }
    *(_DWORD *)buf = 136315138;
    __int16 v17 = "WiFiSecuritySavePasswordForPasswordBackup_block_invoke";
    uint64_t v12 = "%s: null password";
    goto LABEL_24;
  }

  if (![v2 length])
  {
    if (!os_log_type_enabled((os_log_t)&_os_log_default, OS_LOG_TYPE_DEFAULT)) {
      goto LABEL_28;
    }
    *(_DWORD *)buf = 136315138;
    __int16 v17 = "WiFiSecuritySavePasswordForPasswordBackup_block_invoke";
    uint64_t v12 = "%s: error: empty ssid";
    goto LABEL_24;
  }

  if (![*(id *)(a1 + 40) length])
  {
    if (os_log_type_enabled((os_log_t)&_os_log_default, OS_LOG_TYPE_DEFAULT))
    {
      uint64_t v14 = *(NSMutableString **)(a1 + 32);
      *(_DWORD *)buf = 136315394;
      __int16 v17 = "WiFiSecuritySavePasswordForPasswordBackup_block_invoke";
      __int16 v18 = 2112;
      uint64_t v19 = v14;
      uint64_t v12 = "%s: error: empty password for ssid %@";
      uint32_t v13 = 22;
      goto LABEL_27;
    }

BOOL sub_1000AEC14(uint64_t a1)
{
  uint64_t v2 = objc_autoreleasePoolPush();
  __int128 v3 = dispatch_semaphore_create(0LL);
  uint64_t v10 = 0LL;
  uint64_t v11 = &v10;
  uint64_t v12 = 0x2020000000LL;
  int v13 = 0;
  block[0] = _NSConcreteStackBlock;
  block[1] = 3221225472LL;
  block[2] = sub_1000AEDE8;
  block[3] = &unk_1001E4A40;
  void block[5] = v3;
  void block[6] = &v10;
  void block[4] = a1;
  dispatch_async(&_dispatch_main_q, block);
  dispatch_time_t v4 = dispatch_time(0LL, 1000000000LL);
  uint64_t v5 = dispatch_semaphore_wait(v3, v4);
  BOOL v6 = os_log_type_enabled((os_log_t)&_os_log_default, OS_LOG_TYPE_DEFAULT);
  if (v5)
  {
    if (v6)
    {
      *(_DWORD *)buf = 136315394;
      int v15 = "WiFiSecurityRemovePasswordFromPasswordBackup";
      __int16 v16 = 2112;
      uint64_t v17 = a1;
      _os_log_impl( (void *)&_mh_execute_header,  (os_log_t)&_os_log_default,  OS_LOG_TYPE_DEFAULT,  "%s:[%@] timed out\n",  buf,  0x16u);
    }

    BOOL v7 = 0LL;
  }

  else
  {
    if (v6)
    {
      *(_DWORD *)buf = 136315394;
      int v15 = "WiFiSecurityRemovePasswordFromPasswordBackup";
      __int16 v16 = 2112;
      uint64_t v17 = a1;
      _os_log_impl( (void *)&_mh_execute_header,  (os_log_t)&_os_log_default,  OS_LOG_TYPE_DEFAULT,  "%s:[%@] completed\n",  buf,  0x16u);
    }

    BOOL v7 = *((_DWORD *)v11 + 6) == 0;
  }

  dispatch_release(v3);
  _Block_object_dispose(&v10, 8);
  objc_autoreleasePoolPop(v2);
  return v7;
}

uint64_t sub_1000AEDE8(uint64_t a1)
{
  uint64_t v2 = *(void **)(a1 + 32);
  if (!v2)
  {
    if (os_log_type_enabled((os_log_t)&_os_log_default, OS_LOG_TYPE_DEFAULT))
    {
      int v12 = 136315138;
      int v13 = "WiFiSecurityRemovePasswordFromPasswordBackup_block_invoke";
      uint64_t v11 = "%s: null ssid";
LABEL_18:
      _os_log_impl( (void *)&_mh_execute_header,  (os_log_t)&_os_log_default,  OS_LOG_TYPE_DEFAULT,  v11,  (uint8_t *)&v12,  0xCu);
    }

uint64_t sub_1000AF0CC()
{
  uint64_t result = qword_1002199D0;
  if (!qword_1002199D0)
  {
    pthread_once(&stru_100219088, (void (*)(void))sub_1000AF108);
    return qword_1002199D0;
  }

  return result;
}

uint64_t sub_1000AF108()
{
  qword_1002199D0 = _CFRuntimeRegisterClass(&unk_1001E4A68);
  return notify_register_check("com.apple.wifi.manager.available", &dword_100219098);
}

double sub_1000AF13C(uint64_t a1, uint64_t a2, uint64_t a3)
{
  if (a2 && a3)
  {
    if (!qword_1002199D0) {
      pthread_once(&stru_100219088, (void (*)(void))sub_1000AF108);
    }
    uint64_t Instance = _CFRuntimeCreateInstance(a1);
    if (Instance)
    {
      double result = 0.0;
      *(_OWORD *)(Instance + 16) = 0u;
      *(_OWORD *)(Instance + 32) = 0u;
      *(void *)(Instance + 16) = a3;
      *(void *)(Instance + 40) = a2;
    }
  }

  return result;
}

uint64_t sub_1000AF1BC(uint64_t a1, uint64_t a2)
{
  *(void *)(a1 + 24) = a2;
  uint64_t v4 = *(void *)(a1 + 32);
  if (v4)
  {
    uint64_t v5 = 0LL;
  }

  else
  {
    mach_port_t sp = -1431655766;
    id v6 = sub_100090DAC((uint64_t)kCFAllocatorDefault, 60LL, sp, 0);
    *(void *)(a1 + 32) = v6;
    if (!v6) {
      return 0LL;
    }
    unsigned int v7 = sub_10003BEB4((uint64_t)v6);
    sub_100091288(v7, (const void *)a1);
    uint64_t v4 = *(void *)(a1 + 32);
    uint64_t v5 = 1LL;
  }

  sub_100091024(v4, a2);
  return v5;
}

uint64_t sub_1000AF270(uint64_t a1)
{
  return sub_100091164(*(void *)(a1 + 32));
}

uint64_t sub_1000AF278(const __CFString *a1)
{
  if (CFStringCompare(a1, @"MWS_BT_COEX_ULOFDMA_DISABLE", 0LL) == kCFCompareEqualTo) {
    return 358LL;
  }
  if (CFStringCompare(a1, @"MWS_RC1_COEX_ULOFDMA_DISABLE", 0LL) == kCFCompareEqualTo) {
    return 519LL;
  }
  if (CFStringCompare(a1, @"MWS_RC2_COEX_ULOFDMA_DISABLE", 0LL) == kCFCompareEqualTo) {
    return 520LL;
  }
  if (CFStringCompare(a1, @"MWS_LE_SCAN_PARAM_INFO", 0LL) == kCFCompareEqualTo) {
    return 521LL;
  }
  if (CFStringCompare(a1, @"MWSType7BITMAPWiFiEnh", 0LL) == kCFCompareEqualTo) {
    return 540LL;
  }
  if (CFStringCompare(a1, @"MWSCOEXBITMAPWiFiEnh", 0LL) == kCFCompareEqualTo) {
    return 541LL;
  }
  if (CFStringCompare(a1, @"MWSOCLBITMAPWiFiEnh", 0LL) == kCFCompareEqualTo) {
    return 542LL;
  }
  if (CFStringCompare(a1, @"MWS_RFEM_CONFIG_Enh", 0LL) == kCFCompareEqualTo) {
    return 543LL;
  }
  if (CFStringCompare(a1, @"MWS_ASSOC_PROTECTION_BITMAP_Enh", 0LL) == kCFCompareEqualTo) {
    return 544LL;
  }
  if (CFStringCompare(a1, @"MWS_SCAN_FREQ_Enh", 0LL) == kCFCompareEqualTo) {
    return 545LL;
  }
  if (CFStringCompare(a1, @"MWS_SCAN_FREQ_MODE_Enh", 0LL) == kCFCompareEqualTo) {
    return 546LL;
  }
  if (CFStringCompare(a1, @"MWS_CONDITION_ID_BITMAP_Enh", 0LL) == kCFCompareEqualTo) {
    return 547LL;
  }
  if (CFStringCompare(a1, @"MWS_ANTENNA_SELECTION_Enh", 0LL) == kCFCompareEqualTo) {
    return 548LL;
  }
  if (CFStringCompare(a1, @"MWS_TIME_SHARING_Enh", 0LL)) {
    return 0LL;
  }
  return 539LL;
}

uint64_t sub_1000AF450( unsigned int a1, int a2, uint64_t a3, int a4, unsigned int *a5, _DWORD *a6, __int128 *a7)
{
  *a5 = 0;
  *a6 = 0;
  uint64_t v14 = qword_1002199D0;
  if (!qword_1002199D0)
  {
    pthread_once(&stru_100219088, (void (*)(void))sub_1000AF108);
    uint64_t v14 = qword_1002199D0;
  }

  int v15 = (uint64_t *)sub_10009137C(a1, v14);
  if (v15)
  {
    __int16 v16 = v15;
    uint64_t v17 = v15[2];
    __int128 v18 = a7[1];
    v26[0] = *a7;
    v26[1] = v18;
    uint64_t v19 = sub_10003BA5C((uint64_t)kCFAllocatorDefault, a2, v17, a3, 60LL, a4, v26);
    if (v19)
    {
      __int16 v20 = (const void *)v19;
      if (!sub_10003B930(v19))
      {
        uint64_t v23 = objc_autoreleasePoolPush();
        if (qword_100219F60) {
          [(id)qword_100219F60 WFLog:4, "%s Client %@ has no entitlement", "kern_return_t _wifi_manager_open(mach_port_t, int, int, mach_port_t, mach_port_t *, int *, audit_token_t)", sub_10003BEDC((uint64_t)v20) message];
        }
        objc_autoreleasePoolPop(v23);
        *a6 = 1;
        CFRelease(v20);
        goto LABEL_13;
      }

      sub_10003DE38((uint64_t)v20, (uint64_t)sub_1000AF674, (uint64_t)v16);
      sub_10003BEA4((uint64_t)v20, v16[3]);
      sub_1000709D4(v16[2], v20);
      unsigned int v21 = sub_10003BECC((uint64_t)v20);
      *a5 = v21;
      sub_100091288(v21, v20);
      if (a2 != 1)
      {
LABEL_13:
        CFRelease(v16);
        return 0LL;
      }

      uint64_t v22 = objc_autoreleasePoolPush();
      if (qword_100219F60) {
        [(id)qword_100219F60 WFLog:4, "Attached client %@ is background application", sub_10003BEDC((uint64_t)v20) message];
      }
    }

    else
    {
      uint64_t v22 = objc_autoreleasePoolPush();
      if (qword_100219F60) {
        objc_msgSend((id)qword_100219F60, "WFLog:message:", 4, "Failed to create WiFi Manager client for pid=%d", a3);
      }
    }

    objc_autoreleasePoolPop(v22);
    goto LABEL_13;
  }

  uint64_t v25 = objc_autoreleasePoolPush();
  if (qword_100219F60) {
    [(id)qword_100219F60 WFLog:4 message:"Failed to acquire WiFiServerRef for mach port"];
  }
  objc_autoreleasePoolPop(v25);
  return 0LL;
}

void sub_1000AF674(void *a1, uint64_t a2)
{
  uint64_t v4 = sub_10003BEDC((uint64_t)a1);
  NSLog(@"%s: Client %@ terminated, cleanup state", "__WiFiServerClientTerminationCallback", v4);
  uint64_t v5 = sub_10003BEC4((uint64_t)a1);
  sub_10006E6B8(v5, a1, 0, 2);
  sub_10006EE28(v5, a1, 0);
  sub_10006E5F0(v5, (uint64_t)a1);
  id v6 = (const __CFUUID *)sub_10003BEE4((uint64_t)a1);
  CFStringRef v7 = CFUUIDCreateString(kCFAllocatorDefault, v6);
  sub_10007A468(v5, (uint64_t)v7);
  sub_100071570(*(void *)(a2 + 16), a1);
  sub_10003DE38((uint64_t)a1, 0LL, 0LL);
  if (v7) {
    CFRelease(v7);
  }
  if (a1) {
    CFRelease(a1);
  }
}

uint64_t sub_1000AF780(unsigned int a1)
{
  uint64_t v2 = sub_10003B8D0();
  __int128 v3 = sub_10009137C(a1, v2);
  if (v3)
  {
    uint64_t v4 = v3;
    sub_10003DE40((uint64_t)v3);
    CFRelease(v4);
  }

  return 0LL;
}

uint64_t sub_1000AF7C4(unsigned int a1, int a2)
{
  uint64_t v4 = sub_10003B8D0();
  uint64_t v5 = sub_10009137C(a1, v4);
  if (v5)
  {
    id v6 = v5;
    if ((sub_10003BEEC((uint64_t)v5) & 1) != 0)
    {
      uint64_t v8 = sub_10003BEC4((uint64_t)v6);
      if (v8)
      {
        uint64_t v9 = v8;
        uint64_t v10 = objc_autoreleasePoolPush();
        if (qword_100219F60)
        {
          if (a2) {
            uint64_t v11 = "ON";
          }
          else {
            uint64_t v11 = "OFF";
          }
          [(id)qword_100219F60 WFLog:3, "Manager power %s requested by %@", v11, sub_10003BEDC((uint64_t)v6) message];
        }

        objc_autoreleasePoolPop(v10);
        int v12 = (const __CFString *)sub_10003BEDC((uint64_t)v6);
        sub_10006FC28(v9, a2, v12);
      }
    }

    else
    {
      CFStringRef v7 = objc_autoreleasePoolPush();
      if (qword_100219F60) {
        [(id)qword_100219F60 WFLog:4, "%s Client %@ has no entitlement", "kern_return_t _wifi_manager_set_power(mach_port_t, int)", sub_10003BEDC((uint64_t)v6) message];
      }
      objc_autoreleasePoolPop(v7);
    }

    CFRelease(v6);
  }

  return 0LL;
}

uint64_t sub_1000AF8F4(unsigned int a1, _DWORD *a2)
{
  *a2 = 0;
  uint64_t v4 = sub_10003B8D0();
  uint64_t v5 = sub_10009137C(a1, v4);
  if (v5)
  {
    id v6 = v5;
    if ((sub_10003BEEC((uint64_t)v5) & 1) != 0)
    {
      uint64_t v8 = sub_10003BEC4((uint64_t)v6);
      if (v8) {
        *a2 = sub_10006EF90(v8);
      }
    }

    else
    {
      CFStringRef v7 = objc_autoreleasePoolPush();
      if (qword_100219F60) {
        [(id)qword_100219F60 WFLog:4, "%s Client %@ has no entitlement", "kern_return_t _wifi_manager_get_power(mach_port_t, int *)", sub_10003BEDC((uint64_t)v6) message];
      }
      objc_autoreleasePoolPop(v7);
    }

    CFRelease(v6);
  }

  return 0LL;
}

uint64_t sub_1000AF9B4(unsigned int a1, unsigned int a2)
{
  uint64_t v4 = sub_10003B8D0();
  uint64_t v5 = sub_10009137C(a1, v4);
  if (v5)
  {
    id v6 = v5;
    if ((sub_10003BEEC((uint64_t)v5) & 1) != 0)
    {
      uint64_t v8 = sub_10003BEC4((uint64_t)v6);
      if (v8)
      {
        uint64_t v9 = v8;
        uint64_t v10 = objc_autoreleasePoolPush();
        if (qword_100219F60)
        {
          if (a2) {
            uint64_t v11 = "ON";
          }
          else {
            uint64_t v11 = "OFF";
          }
          [(id)qword_100219F60 WFLog:3, "Manager power %s requested by %@", v11, sub_10003BEDC((uint64_t)v6) message];
        }

        objc_autoreleasePoolPop(v10);
        int v12 = (const void *)sub_10003BEDC((uint64_t)v6);
        sub_10006EF98(v9, a2, v12);
      }
    }

    else
    {
      CFStringRef v7 = objc_autoreleasePoolPush();
      if (qword_100219F60) {
        [(id)qword_100219F60 WFLog:4, "%s Client %@ has no entitlement", "kern_return_t _wifi_manager_set_power_ext(mach_port_t, int)", sub_10003BEDC((uint64_t)v6) message];
      }
      objc_autoreleasePoolPop(v7);
    }

    CFRelease(v6);
  }

  return 0LL;
}

uint64_t sub_1000AFAE4(unsigned int a1, _DWORD *a2)
{
  *a2 = 0;
  uint64_t v4 = sub_10003B8D0();
  uint64_t v5 = sub_10009137C(a1, v4);
  if (v5)
  {
    id v6 = v5;
    if ((sub_10003BEEC((uint64_t)v5) & 1) != 0)
    {
      uint64_t v8 = sub_10003BEC4((uint64_t)v6);
      if (v8) {
        *a2 = sub_10006C92C(v8);
      }
    }

    else
    {
      CFStringRef v7 = objc_autoreleasePoolPush();
      if (qword_100219F60) {
        [(id)qword_100219F60 WFLog:4, "%s Client %@ has no entitlement", "kern_return_t _wifi_manager_get_ask_to_join_state(mach_port_t, int *)", sub_10003BEDC((uint64_t)v6) message];
      }
      objc_autoreleasePoolPop(v7);
    }

    CFRelease(v6);
  }

  return 0LL;
}

uint64_t sub_1000AFBA4(unsigned int a1, _DWORD *a2)
{
  *a2 = 0;
  uint64_t v4 = sub_10003B8D0();
  uint64_t v5 = sub_10009137C(a1, v4);
  if (v5)
  {
    id v6 = v5;
    if ((sub_10003BEEC((uint64_t)v5) & 1) != 0)
    {
      if (!sub_10003BEC4((uint64_t)v6))
      {
LABEL_12:
        CFRelease(v6);
        return 0LL;
      }

      CFStringRef v7 = objc_autoreleasePoolPush();
      uint64_t v8 = (void *)qword_100219F60;
      if (qword_100219F60)
      {
        uint64_t v9 = sub_10003BEDC((uint64_t)v6);
        if (*a2) {
          uint64_t v10 = "Associated";
        }
        else {
          uint64_t v10 = "Unassociated";
        }
        [v8 WFLog:3, "NAN Client Assoc state queried by %@ is %s", v9, v10 message];
      }
    }

    else
    {
      CFStringRef v7 = objc_autoreleasePoolPush();
      if (qword_100219F60) {
        [(id)qword_100219F60 WFLog:4, "%s Client %@ has no entitlement", "kern_return_t _wifi_manager_get_nanclient_assoc_status(mach_port_t, int *)", sub_10003BEDC((uint64_t)v6) message];
      }
    }

    objc_autoreleasePoolPop(v7);
    goto LABEL_12;
  }

  return 0LL;
}

uint64_t sub_1000AFCAC(unsigned int a1, double a2)
{
  uint64_t v4 = sub_10003B8D0();
  uint64_t v5 = sub_10009137C(a1, v4);
  if (v5)
  {
    id v6 = v5;
    if ((sub_10003BEEC((uint64_t)v5) & 1) != 0)
    {
      uint64_t v8 = sub_10003BEC4((uint64_t)v6);
      if (v8)
      {
        uint64_t v9 = v8;
        uint64_t v10 = objc_autoreleasePoolPush();
        if (qword_100219F60) {
          [(id)qword_100219F60 WFLog:3, "%@ requested NAN Off Head Connection expiry of %f seconds ", sub_10003BEDC((uint64_t)v6), *(void *)&a2 message];
        }
        objc_autoreleasePoolPop(v10);
        sub_10007C288(v9, a2);
      }
    }

    else
    {
      CFStringRef v7 = objc_autoreleasePoolPush();
      if (qword_100219F60) {
        [(id)qword_100219F60 WFLog:4, "%s Client %@ has no entitlement", "kern_return_t _wifi_manager_set_nan_off_head_connection_expiry(mach_port_t, double)", sub_10003BEDC((uint64_t)v6) message];
      }
      objc_autoreleasePoolPop(v7);
    }

    CFRelease(v6);
  }

  return 0LL;
}

uint64_t sub_1000AFDBC(unsigned int a1, void *a2)
{
  *a2 = 0LL;
  uint64_t v4 = sub_10003B8D0();
  uint64_t v5 = sub_10009137C(a1, v4);
  if (v5)
  {
    id v6 = v5;
    if ((sub_10003BEEC((uint64_t)v5) & 1) != 0)
    {
      uint64_t v8 = (const __CFArray *)sub_10003BEC4((uint64_t)v6);
      if (!v8)
      {
LABEL_9:
        CFRelease(v6);
        return 0LL;
      }

      *(double *)a2 = sub_10007C328(v8);
      CFStringRef v7 = objc_autoreleasePoolPush();
      if (qword_100219F60) {
        [(id)qword_100219F60 WFLog:3, "NAN Off Head Connection expiry queried by %@ is %f", sub_10003BEDC((uint64_t)v6), *a2 message];
      }
    }

    else
    {
      CFStringRef v7 = objc_autoreleasePoolPush();
      if (qword_100219F60) {
        [(id)qword_100219F60 WFLog:4, "%s Client %@ has no entitlement", "kern_return_t _wifi_manager_get_nan_off_head_connection_expiry(mach_port_t, double *)", sub_10003BEDC((uint64_t)v6) message];
      }
    }

    objc_autoreleasePoolPop(v7);
    goto LABEL_9;
  }

  return 0LL;
}

uint64_t sub_1000AFEB8(unsigned int a1, int a2)
{
  uint64_t v4 = sub_10003B8D0();
  uint64_t v5 = (const __CFString *)sub_10009137C(a1, v4);
  if (v5)
  {
    id v6 = v5;
    if ((sub_10003BEEC((uint64_t)v5) & 1) != 0)
    {
      uint64_t v8 = sub_10003BEC4((uint64_t)v6);
      if (v8)
      {
        uint64_t v9 = v8;
        uint64_t v10 = objc_autoreleasePoolPush();
        if (qword_100219F60)
        {
          if (a2) {
            uint64_t v11 = "Enable";
          }
          else {
            uint64_t v11 = "Disable";
          }
          [(id)qword_100219F60 WFLog:3, "%s MIS set state requested by %@", v11, sub_10003BEDC((uint64_t)v6) message];
        }

        objc_autoreleasePoolPop(v10);
        sub_10006DFA8(v9, v6, a2);
      }
    }

    else
    {
      CFStringRef v7 = objc_autoreleasePoolPush();
      if (qword_100219F60) {
        [(id)qword_100219F60 WFLog:4, "%s Client %@ has no entitlement", "kern_return_t _wifi_manager_set_mis_state(mach_port_t, int)", sub_10003BEDC((uint64_t)v6) message];
      }
      objc_autoreleasePoolPop(v7);
    }

    CFRelease(v6);
  }

  return 0LL;
}

uint64_t sub_1000AFFE0(unsigned int a1, _DWORD *a2)
{
  *a2 = 0;
  uint64_t v4 = sub_10003B8D0();
  uint64_t v5 = sub_10009137C(a1, v4);
  if (v5)
  {
    id v6 = v5;
    if ((sub_10003BEEC((uint64_t)v5) & 1) != 0)
    {
      uint64_t v8 = sub_10003BEC4((uint64_t)v6);
      if (!v8)
      {
LABEL_12:
        CFRelease(v6);
        return 0LL;
      }

      *a2 = sub_10006E174(v8);
      CFStringRef v7 = objc_autoreleasePoolPush();
      uint64_t v9 = (void *)qword_100219F60;
      if (qword_100219F60)
      {
        uint64_t v10 = sub_10003BEDC((uint64_t)v6);
        if (*a2) {
          uint64_t v11 = "Enable";
        }
        else {
          uint64_t v11 = "Disable";
        }
        [v9 WFLog:3, "MIS state queried by %@ is %s", v10, v11 message];
      }
    }

    else
    {
      CFStringRef v7 = objc_autoreleasePoolPush();
      if (qword_100219F60) {
        [(id)qword_100219F60 WFLog:4, "%s Client %@ has no entitlement", "kern_return_t _wifi_manager_get_mis_state(mach_port_t, int *)", sub_10003BEDC((uint64_t)v6) message];
      }
    }

    objc_autoreleasePoolPop(v7);
    goto LABEL_12;
  }

  return 0LL;
}

uint64_t sub_1000B00F0( unsigned int a1, int a2, uint64_t a3, unsigned int a4, uint64_t a5, UInt8 *a6, unsigned int a7, UInt8 *a8, unsigned int a9, int a10)
{
  uint64_t v18 = sub_10003B8D0();
  uint64_t v19 = (const __CFString *)sub_10009137C(a1, v18);
  if (v19)
  {
    __int16 v20 = v19;
    if ((sub_10003BEEC((uint64_t)v19) & 1) == 0)
    {
      unsigned int v21 = objc_autoreleasePoolPush();
      if (qword_100219F60) {
        [(id)qword_100219F60 WFLog:4, "%s Client %@ has no entitlement", "kern_return_t _wifi_manager_set_mis_discovery_state(mach_port_t, int, int, int, int, vm_offset_t, mach_msg_typ e_number_t, vm_offset_t, mach_msg_type_number_t, int)", sub_10003BEDC((uint64_t)v20) message];
      }
      objc_autoreleasePoolPop(v21);
      goto LABEL_6;
    }

    uint64_t v23 = sub_10003BEC4((uint64_t)v20);
    if (!v23)
    {
LABEL_6:
      CFPropertyListRef v22 = v20;
LABEL_28:
      CFRelease(v22);
      return 0LL;
    }

    uint64_t v24 = v23;
    CFStringRef v36 = a8;
    CFIndex v35 = a9;
    uint64_t v25 = sub_10003BEDC((uint64_t)v20);
    else {
      BOOL v26 = 0;
    }
    if (v26) {
      uint64_t v27 = 1LL;
    }
    else {
      uint64_t v27 = a4;
    }
    unsigned int v28 = objc_autoreleasePoolPush();
    if (qword_100219F60)
    {
      unint64_t v29 = "Enable";
      if (!a2) {
        unint64_t v29 = "Disable";
      }
      [(id)qword_100219F60 WFLog:3, "%s MIS Discoverability requested by %@ with immediateDisable=%u hidden=%u Force2.4GHz Channel=%u\n", v29, v25, a3, v27, a5, a9, v36 message];
    }

    objc_autoreleasePoolPop(v28);
    sub_10006E598(v24, a2, v27, a3, v25);
    CFStringRef v30 = (const __CFString *)sub_10003A7C0(a6, a7);
    CFPropertyListRef v22 = sub_10003A7C0(v36, v35);
    if (v30)
    {
      int v31 = sub_10004D68C(v30);
      BOOL v33 = a10 == 8 || v31 != 0;
      sub_10006E1B8(v24, v20, a2, a3, a5, v33);
      CFRelease(v20);
      __int16 v20 = v30;
    }

    else
    {
      sub_10006E1B8(v24, v20, a2, a3, a5, a10 == 8);
    }

    CFRelease(v20);
    if (v22) {
      goto LABEL_28;
    }
  }

  return 0LL;
}

uint64_t sub_1000B0314(unsigned int a1, _DWORD *a2)
{
  *a2 = 0;
  uint64_t v4 = sub_10003B8D0();
  uint64_t v5 = sub_10009137C(a1, v4);
  if (v5)
  {
    id v6 = v5;
    if ((sub_10003BEEC((uint64_t)v5) & 1) != 0)
    {
      uint64_t v8 = sub_10003BEC4((uint64_t)v6);
      if (v8) {
        *a2 = sub_10006E520(v8);
      }
    }

    else
    {
      CFStringRef v7 = objc_autoreleasePoolPush();
      if (qword_100219F60) {
        [(id)qword_100219F60 WFLog:4, "%s Client %@ has no entitlement", "kern_return_t _wifi_manager_get_mis_discovery_state(mach_port_t, int *)", sub_10003BEDC((uint64_t)v6) message];
      }
      objc_autoreleasePoolPop(v7);
    }

    CFRelease(v6);
  }

  return 0LL;
}

uint64_t sub_1000B03D4(unsigned int a1, int a2)
{
  uint64_t v4 = sub_10003B8D0();
  uint64_t v5 = sub_10009137C(a1, v4);
  if (v5)
  {
    id v6 = v5;
    if ((sub_10003BEEC((uint64_t)v5) & 1) != 0)
    {
      uint64_t v8 = sub_10003BEC4((uint64_t)v6);
      if (v8)
      {
        uint64_t v9 = v8;
        uint64_t v10 = objc_autoreleasePoolPush();
        if (qword_100219F60)
        {
          if (a2) {
            uint64_t v11 = "Enable";
          }
          else {
            uint64_t v11 = "Disable";
          }
          [(id)qword_100219F60 WFLog:4, "%s WoW requested by %@", v11, sub_10003BEDC((uint64_t)v6) message];
        }

        objc_autoreleasePoolPop(v10);
        sub_10006E6B8(v9, v6, a2, 2);
      }
    }

    else
    {
      CFStringRef v7 = objc_autoreleasePoolPush();
      if (qword_100219F60) {
        [(id)qword_100219F60 WFLog:4, "%s Client %@ has no entitlement", "kern_return_t _wifi_manager_set_wow_state(mach_port_t, int)", sub_10003BEDC((uint64_t)v6) message];
      }
      objc_autoreleasePoolPop(v7);
    }

    CFRelease(v6);
  }

  return 0LL;
}

uint64_t sub_1000B0500(unsigned int a1, vm_offset_t *a2, mach_msg_type_number_t *a3)
{
  *a2 = 0LL;
  *a3 = 0;
  uint64_t v6 = sub_10003B8D0();
  CFStringRef v7 = sub_10009137C(a1, v6);
  if (v7)
  {
    uint64_t v8 = v7;
    if ((sub_10003BEEC((uint64_t)v7) & 1) != 0)
    {
      uint64_t v10 = sub_10003BEC4((uint64_t)v8);
      if (v10)
      {
        uint64_t v11 = sub_10006EB54(v10);
        if (v11)
        {
          int v12 = v11;
          sub_10003A920(v11, a2, a3);
          CFRelease(v12);
        }
      }
    }

    else
    {
      uint64_t v9 = objc_autoreleasePoolPush();
      if (qword_100219F60) {
        [(id)qword_100219F60 WFLog:4, "%s Client %@ has no entitlement", "kern_return_t _wifi_manager_copy_wow_state(mach_port_t, vm_offset_t *, mach_msg_type_number_t *)", sub_10003BEDC((uint64_t)v8) message];
      }
      objc_autoreleasePoolPop(v9);
    }

    CFRelease(v8);
  }

  return 0LL;
}

uint64_t sub_1000B05E0(unsigned int a1, vm_offset_t *a2, mach_msg_type_number_t *a3)
{
  *a2 = 0LL;
  *a3 = 0;
  uint64_t v6 = sub_10003B8D0();
  CFStringRef v7 = sub_10009137C(a1, v6);
  if (v7)
  {
    uint64_t v8 = v7;
    if ((sub_10003BEEC((uint64_t)v7) & 1) != 0)
    {
      if (sub_10003BEC4((uint64_t)v8))
      {
        uint64_t v10 = (const void *)sub_10000B77C();
        if (v10)
        {
          uint64_t v11 = v10;
          sub_10003A920(v10, a2, a3);
          CFRelease(v11);
        }
      }
    }

    else
    {
      uint64_t v9 = objc_autoreleasePoolPush();
      if (qword_100219F60) {
        [(id)qword_100219F60 WFLog:4, "%s Client %@ has no entitlement", "kern_return_t _wifi_manager_get_mac_randomisation_parameters(mach_port_t, vm_offset_t *, mach_msg_type_number_t *)", sub_10003BEDC((uint64_t)v8) message];
      }
      objc_autoreleasePoolPop(v9);
    }

    CFRelease(v8);
  }

  return 0LL;
}

uint64_t sub_1000B06C0(unsigned int a1, UInt8 *a2, unsigned int a3, _DWORD *a4)
{
  uint64_t v8 = sub_10003B8D0();
  uint64_t v9 = sub_10009137C(a1, v8);
  if (v9)
  {
    uint64_t v10 = v9;
    if ((sub_10003BEEC((uint64_t)v9) & 1) == 0)
    {
      uint64_t v11 = objc_autoreleasePoolPush();
      if (qword_100219F60) {
        [(id)qword_100219F60 WFLog:4, "%s Client %@ has no entitlement", "kern_return_t _wifi_manager_get_privatemac_network_switch_state(mach_port_t, vm_offset_t, mach_msg_type_number_t, int *)", sub_10003BEDC((uint64_t)v10) message];
      }
      objc_autoreleasePoolPop(v11);
      goto LABEL_8;
    }

    if (!sub_10003BEC4((uint64_t)v10)
      || (CFPropertyListRef v12 = sub_10003A7C0(a2, a3), *a4 = sub_10000B784(), CFRelease(v10), (v10 = v12) != 0LL))
    {
LABEL_8:
      CFRelease(v10);
    }
  }

  return 0LL;
}

uint64_t sub_1000B07B8(unsigned int a1, int a2, _DWORD *a3)
{
  *a3 = 0;
  uint64_t v6 = sub_10003B8D0();
  CFStringRef v7 = (void *)sub_10009137C(a1, v6);
  if (v7)
  {
    uint64_t v8 = v7;
    if ((sub_10003BEEC((uint64_t)v7) & 1) != 0)
    {
      uint64_t v10 = sub_10003BEC4((uint64_t)v8);
      if (v10)
      {
        uint64_t v11 = v10;
        CFPropertyListRef v12 = objc_autoreleasePoolPush();
        if (qword_100219F60)
        {
          if (a2) {
            int v13 = "quiescing";
          }
          else {
            int v13 = "unquiescing";
          }
          [(id)qword_100219F60 WFLog:3, "WiFi %s requested by %@", v13, sub_10003BEDC((uint64_t)v8) message];
        }

        objc_autoreleasePoolPop(v12);
        *a3 = sub_10006EE28(v11, v8, a2);
      }
    }

    else
    {
      uint64_t v9 = objc_autoreleasePoolPush();
      if (qword_100219F60) {
        [(id)qword_100219F60 WFLog:4, "%s Client %@ has no entitlement", "kern_return_t _wifi_manager_set_quiesce_state(mach_port_t, int, int *)", sub_10003BEDC((uint64_t)v8) message];
      }
      objc_autoreleasePoolPop(v9);
    }

    CFRelease(v8);
  }

  return 0LL;
}

uint64_t sub_1000B08F4(unsigned int a1, _DWORD *a2)
{
  *a2 = 0;
  uint64_t v4 = sub_10003B8D0();
  uint64_t v5 = sub_10009137C(a1, v4);
  if (v5)
  {
    uint64_t v6 = v5;
    if ((sub_10003BEEC((uint64_t)v5) & 1) != 0)
    {
      uint64_t v8 = sub_10003BEC4((uint64_t)v6);
      if (v8) {
        *a2 = sub_10006F480(v8);
      }
    }

    else
    {
      CFStringRef v7 = objc_autoreleasePoolPush();
      if (qword_100219F60) {
        [(id)qword_100219F60 WFLog:4, "%s Client %@ has no entitlement", "kern_return_t _wifi_manager_get_quiesce_state(mach_port_t, int *)", sub_10003BEDC((uint64_t)v6) message];
      }
      objc_autoreleasePoolPop(v7);
    }

    CFRelease(v6);
  }

  return 0LL;
}

uint64_t sub_1000B09B4(unsigned int a1, _DWORD *a2)
{
  *a2 = 0;
  uint64_t v4 = sub_10003B8D0();
  uint64_t v5 = sub_10009137C(a1, v4);
  if (v5)
  {
    uint64_t v6 = v5;
    if ((sub_10003BEEC((uint64_t)v5) & 1) != 0)
    {
      uint64_t v8 = sub_10003BEC4((uint64_t)v6);
      if (v8) {
        *a2 = sub_10006F6C4(v8);
      }
    }

    else
    {
      CFStringRef v7 = objc_autoreleasePoolPush();
      if (qword_100219F60) {
        [(id)qword_100219F60 WFLog:4, "%s Client %@ has no entitlement", "kern_return_t _wifi_manager_get_wow_capability(mach_port_t, int *)", sub_10003BEDC((uint64_t)v6) message];
      }
      objc_autoreleasePoolPop(v7);
    }

    CFRelease(v6);
  }

  return 0LL;
}

uint64_t sub_1000B0A74(unsigned int a1, UInt8 *a2, unsigned int a3, _DWORD *a4)
{
  *a4 = 0;
  uint64_t v8 = sub_10003B8D0();
  uint64_t v9 = sub_10009137C(a1, v8);
  if (v9)
  {
    uint64_t v10 = v9;
    if ((sub_10003BEEC((uint64_t)v9) & 1) != 0)
    {
      uint64_t v12 = sub_10003BEC4((uint64_t)v10);
      if (v12)
      {
        uint64_t v13 = v12;
        uint64_t v14 = (void *)sub_10003A7C0(a2, a3);
        if (v14)
        {
          int v15 = v14;
          *a4 = sub_100079070(v13, v14);
          CFRelease(v15);
        }
      }
    }

    else
    {
      uint64_t v11 = objc_autoreleasePoolPush();
      if (qword_100219F60) {
        [(id)qword_100219F60 WFLog:4, "%s Client %@ has no entitlement", "kern_return_t _wifi_manager_merge_known_networks(mach_port_t, vm_offset_t, mach_msg_type_number_t, int *)", sub_10003BEDC((uint64_t)v10) message];
      }
      objc_autoreleasePoolPop(v11);
    }

    CFRelease(v10);
  }

  sub_10003A8FC((vm_address_t)a2, a3);
  return 0LL;
}

uint64_t sub_1000B0B78(unsigned int a1, _DWORD *a2)
{
  *a2 = 0;
  uint64_t v4 = sub_10003B8D0();
  uint64_t v5 = sub_10009137C(a1, v4);
  if (v5)
  {
    uint64_t v6 = v5;
    if ((sub_10003BEEC((uint64_t)v5) & 1) != 0)
    {
      uint64_t v8 = sub_10003BEC4((uint64_t)v6);
      if (v8) {
        *a2 = sub_10006F7D4(v8);
      }
    }

    else
    {
      CFStringRef v7 = objc_autoreleasePoolPush();
      if (qword_100219F60) {
        [(id)qword_100219F60 WFLog:4, "%s Client %@ has no entitlement", "kern_return_t _wifi_manager_is_tethering_supported(mach_port_t, int *)", sub_10003BEDC((uint64_t)v6) message];
      }
      objc_autoreleasePoolPop(v7);
    }

    CFRelease(v6);
  }

  return 0LL;
}

uint64_t sub_1000B0C38(unsigned int a1, vm_offset_t *a2, mach_msg_type_number_t *a3)
{
  *a2 = 0LL;
  *a3 = 0;
  uint64_t v6 = sub_10003B8D0();
  CFStringRef v7 = sub_10009137C(a1, v6);
  if (v7)
  {
    uint64_t v8 = v7;
    if ((sub_10003BEEC((uint64_t)v7) & 1) != 0)
    {
      uint64_t v10 = sub_10003BEC4((uint64_t)v8);
      if (v10)
      {
        id v11 = sub_1000847F0(v10);
        if (v11)
        {
          uint64_t v12 = v11;
          uint64_t v13 = objc_autoreleasePoolPush();
          if (qword_100219F60) {
            [(id)qword_100219F60 WFLog:3, "%s:MIS Stats requested by %@", "_wifi_manager_copy_mis_stats", sub_10003BEDC((uint64_t)v8) message];
          }
          objc_autoreleasePoolPop(v13);
          sub_10003A920(v12, a2, a3);
        }
      }
    }

    else
    {
      uint64_t v9 = objc_autoreleasePoolPush();
      if (qword_100219F60) {
        [(id)qword_100219F60 WFLog:4, "%s Client %@ has no entitlement", "kern_return_t _wifi_manager_copy_mis_stats(mach_port_t, vm_offset_t *, mach_msg_type_number_t *)", sub_10003BEDC((uint64_t)v8) message];
      }
      objc_autoreleasePoolPop(v9);
    }

    CFRelease(v8);
  }

  return 0LL;
}

uint64_t sub_1000B0D64(unsigned int a1)
{
  uint64_t v2 = sub_10003B8D0();
  __int128 v3 = sub_10009137C(a1, v2);
  if (v3)
  {
    uint64_t v4 = v3;
    if ((sub_10003BEEC((uint64_t)v3) & 1) != 0)
    {
      uint64_t v6 = sub_10003BEC4((uint64_t)v4);
      if (!v6)
      {
LABEL_9:
        CFRelease(v4);
        return 0LL;
      }

      sub_10008487C(v6);
      uint64_t v5 = objc_autoreleasePoolPush();
      if (qword_100219F60) {
        [(id)qword_100219F60 WFLog:3, "%s:MIS Stats reset requested by %@", "_wifi_manager_reset_mis_stats", sub_10003BEDC((uint64_t)v4) message];
      }
    }

    else
    {
      uint64_t v5 = objc_autoreleasePoolPush();
      if (qword_100219F60) {
        [(id)qword_100219F60 WFLog:4, "%s Client %@ has no entitlement", "kern_return_t _wifi_manager_reset_mis_stats(mach_port_t)", sub_10003BEDC((uint64_t)v4) message];
      }
    }

    objc_autoreleasePoolPop(v5);
    goto LABEL_9;
  }

  return 0LL;
}

uint64_t sub_1000B0E54(unsigned int a1, _DWORD *a2)
{
  *a2 = 0;
  uint64_t v4 = sub_10003B8D0();
  uint64_t v5 = sub_10009137C(a1, v4);
  if (v5)
  {
    uint64_t v6 = v5;
    if ((sub_10003BEEC((uint64_t)v5) & 1) != 0)
    {
      uint64_t v8 = sub_10003BEC4((uint64_t)v6);
      if (v8) {
        *a2 = sub_10006F85C(v8);
      }
    }

    else
    {
      CFStringRef v7 = objc_autoreleasePoolPush();
      if (qword_100219F60) {
        [(id)qword_100219F60 WFLog:4, "%s Client %@ has no entitlement", "kern_return_t _wifi_manager_is_always_on_wifi_supported(mach_port_t, int *)", sub_10003BEDC((uint64_t)v6) message];
      }
      objc_autoreleasePoolPop(v7);
    }

    CFRelease(v6);
  }

  return 0LL;
}

uint64_t sub_1000B0F14(unsigned int a1, vm_offset_t *a2, mach_msg_type_number_t *a3)
{
  *a2 = 0LL;
  *a3 = 0;
  uint64_t v6 = sub_10003B8D0();
  CFStringRef v7 = (__CFDictionary *)sub_10009137C(a1, v6);
  if (v7)
  {
    uint64_t v8 = v7;
    if ((sub_10003BEEC((uint64_t)v7) & 1) != 0)
    {
      uint64_t v10 = sub_10003BEC4((uint64_t)v8);
      if (!v10) {
        goto LABEL_9;
      }
      id v11 = sub_10007A2E0(v10);
      if (v11)
      {
        uint64_t v12 = v11;
        sub_10003A920(v11, a2, a3);
        CFRelease(v8);
        uint64_t v8 = v12;
        goto LABEL_9;
      }

      uint64_t v9 = objc_autoreleasePoolPush();
      if (qword_100219F60) {
        [qword_100219F60 WFLog:@"%s Null localeStatsDict" message:4];
      }
    }

    else
    {
      uint64_t v9 = objc_autoreleasePoolPush();
      if (qword_100219F60) {
        [(id)qword_100219F60 WFLog:4, "%s Client %@ has no entitlement", "kern_return_t _wifi_manager_copy_locale_stats(mach_port_t, vm_offset_t *, mach_msg_type_number_t *)", sub_10003BEDC((uint64_t)v8) message];
      }
    }

    objc_autoreleasePoolPop(v9);
LABEL_9:
    CFRelease(v8);
  }

  return 0LL;
}

uint64_t sub_1000B1028(unsigned int a1, UInt8 *a2, unsigned int a3, _DWORD *a4)
{
  *a4 = 0;
  uint64_t v8 = sub_10003B8D0();
  uint64_t v9 = sub_10009137C(a1, v8);
  if (v9)
  {
    uint64_t v10 = v9;
    if ((sub_10003BEEC((uint64_t)v9) & 1) != 0)
    {
      uint64_t v12 = sub_10003BEC4((uint64_t)v10);
      if (v12)
      {
        uint64_t v13 = v12;
        uint64_t v14 = (const __CFString *)sub_10003A7C0(a2, a3);
        if (v14)
        {
          int v15 = v14;
          if (!sub_10006F8A0(v13, v14))
          {
            __int16 v16 = objc_autoreleasePoolPush();
            if (qword_100219F60) {
              [(id)qword_100219F60 WFLog:4 message:"Unable to set mis password"];
            }
            objc_autoreleasePoolPop(v16);
          }

          CFRelease(v15);
        }
      }
    }

    else
    {
      id v11 = objc_autoreleasePoolPush();
      if (qword_100219F60) {
        [(id)qword_100219F60 WFLog:4, "%s Client %@ has no entitlement", "kern_return_t _wifi_manager_mis_set_password(mach_port_t, vm_offset_t, mach_msg_type_number_t, int *)", sub_10003BEDC((uint64_t)v10) message];
      }
      objc_autoreleasePoolPop(v11);
      *a4 = 1;
    }

    CFRelease(v10);
  }

  sub_10003A8FC((vm_address_t)a2, a3);
  return 0LL;
}

uint64_t sub_1000B1164(unsigned int a1, vm_offset_t *a2, mach_msg_type_number_t *a3)
{
  *a2 = 0LL;
  *a3 = 0;
  uint64_t v6 = sub_10003B8D0();
  CFStringRef v7 = sub_10009137C(a1, v6);
  if (v7)
  {
    uint64_t v8 = v7;
    if ((sub_10003BEEC((uint64_t)v7) & 1) == 0)
    {
      uint64_t v9 = objc_autoreleasePoolPush();
      if (qword_100219F60) {
        [(id)qword_100219F60 WFLog:4, "%s Client %@ has no entitlement", "kern_return_t _wifi_manager_mis_copy_password(mach_port_t, vm_offset_t *, mach_msg_type_number_t *)", sub_10003BEDC((uint64_t)v8) message];
      }
LABEL_10:
      objc_autoreleasePoolPop(v9);
      goto LABEL_11;
    }

    uint64_t v10 = sub_10003BEC4((uint64_t)v8);
    if (v10)
    {
      CFStringRef v11 = sub_10006F928(v10);
      if (!v11)
      {
        uint64_t v9 = objc_autoreleasePoolPush();
        if (qword_100219F60) {
          objc_msgSend((id)qword_100219F60, "WFLog:message:", 4, "Unable to copy mis password", v14, v15);
        }
        goto LABEL_10;
      }

      CFStringRef v12 = v11;
      sub_10003A920(v11, a2, a3);
      CFRelease(v12);
    }

uint64_t sub_1000B1268(unsigned int a1, int a2)
{
  uint64_t v4 = sub_10003B8D0();
  uint64_t v5 = sub_10009137C(a1, v4);
  if (v5)
  {
    uint64_t v6 = v5;
    if ((sub_10003BEEC((uint64_t)v5) & 1) != 0)
    {
      uint64_t v8 = sub_10003BEC4((uint64_t)v6);
      if (v8) {
        sub_10006F994(v8, a2);
      }
    }

    else
    {
      CFStringRef v7 = objc_autoreleasePoolPush();
      if (qword_100219F60) {
        [(id)qword_100219F60 WFLog:4, "%s Client %@ has no entitlement", "kern_return_t _wifi_manager_set_retry_cap(mach_port_t, int)", sub_10003BEDC((uint64_t)v6) message];
      }
      objc_autoreleasePoolPop(v7);
    }

    CFRelease(v6);
  }

  return 0LL;
}

uint64_t sub_1000B1324(unsigned int a1, _DWORD *a2)
{
  *a2 = 0;
  uint64_t v4 = sub_10003B8D0();
  uint64_t v5 = sub_10009137C(a1, v4);
  if (v5)
  {
    uint64_t v6 = v5;
    if ((sub_10003BEEC((uint64_t)v5) & 1) != 0)
    {
      uint64_t v8 = sub_10003BEC4((uint64_t)v6);
      if (v8) {
        *a2 = sub_10006F9DC(v8);
      }
    }

    else
    {
      CFStringRef v7 = objc_autoreleasePoolPush();
      if (qword_100219F60) {
        [(id)qword_100219F60 WFLog:4, "%s Client %@ has no entitlement", "kern_return_t _wifi_manager_get_retry_cap(mach_port_t, int *)", sub_10003BEDC((uint64_t)v6) message];
      }
      objc_autoreleasePoolPop(v7);
    }

    CFRelease(v6);
  }

  return 0LL;
}

uint64_t sub_1000B13E4( unsigned int a1, UInt8 *a2, unsigned int a3, vm_offset_t *a4, mach_msg_type_number_t *a5)
{
  *a4 = 0LL;
  *a5 = 0;
  uint64_t v10 = sub_10003B8D0();
  CFStringRef v11 = sub_10009137C(a1, v10);
  if (v11)
  {
    CFStringRef v12 = v11;
    if ((sub_10003BEEC((uint64_t)v11) & 1) == 0)
    {
      uint64_t v13 = objc_autoreleasePoolPush();
      if (qword_100219F60) {
        [(id)qword_100219F60 WFLog:4, "%s Client %@ has no entitlement", "kern_return_t _wifi_manager_copy_property(mach_port_t, vm_offset_t, mach_msg_type_number_t, vm_offset_t *, mac h_msg_type_number_t *)", sub_10003BEDC((uint64_t)v12) message];
      }
      objc_autoreleasePoolPop(v13);
      goto LABEL_17;
    }

    uint64_t v14 = sub_10003BEC4((uint64_t)v12);
    if (!v14 || (uint64_t v15 = (void *)v14, (v16 = (const __CFString *)sub_10003A7C0(a2, a3)) == 0LL))
    {
LABEL_17:
      CFRelease(v12);
      goto LABEL_18;
    }

    uint64_t v17 = v16;
    CFTypeID v18 = CFGetTypeID(v16);
    if (v18 != CFStringGetTypeID()) {
      goto LABEL_16;
    }
    if (CFStringCompare(v17, @"carplayParameters", 0LL))
    {
      if (CFStringCompare(v17, @"HotspotDataUsage", 0LL))
      {
        if (CFStringCompare(v17, @"Custom network settings", 0LL))
        {
          uint64_t v19 = sub_10006F6C0(v15, v17);
          if (v19) {
            sub_10003A920(v19, a4, a5);
          }
          goto LABEL_16;
        }

        __int16 v20 = sub_100082A9C(v15);
        if (!v20)
        {
LABEL_16:
          CFRelease(v17);
          goto LABEL_17;
        }
      }

      else
      {
        __int16 v20 = (const void *)sub_100082ADC();
        if (!v20) {
          goto LABEL_16;
        }
      }
    }

    else
    {
      __int16 v20 = sub_10007D398((uint64_t)v15);
      if (!v20) {
        goto LABEL_16;
      }
    }

    unsigned int v21 = v20;
    sub_10003A920(v20, a4, a5);
    CFRelease(v21);
    goto LABEL_16;
  }

uint64_t sub_1000B15B4(unsigned int a1, UInt8 *a2, unsigned int a3, UInt8 *a4, unsigned int a5, _DWORD *a6)
{
  *a6 = 0;
  uint64_t v12 = sub_10003B8D0();
  uint64_t v13 = sub_10009137C(a1, v12);
  if (v13)
  {
    uint64_t v14 = v13;
    if ((sub_10003BEEC((uint64_t)v13) & 1) == 0)
    {
      uint64_t v15 = objc_autoreleasePoolPush();
      if (qword_100219F60) {
        [(id)qword_100219F60 WFLog:4, "%s Client %@ has no entitlement", "kern_return_t _wifi_manager_set_property(mach_port_t, vm_offset_t, mach_msg_type_number_t, vm_offset_t, mach_m sg_type_number_t, int *)", sub_10003BEDC((uint64_t)v14) message];
      }
      objc_autoreleasePoolPop(v15);
      *a6 = 1;
      goto LABEL_30;
    }

    uint64_t v16 = sub_10003BEC4((uint64_t)v14);
    if (!v16)
    {
LABEL_30:
      CFRelease(v14);
      goto LABEL_31;
    }

    uint64_t v17 = (const __CFArray *)v16;
    CFTypeID v18 = (const __CFString *)sub_10003A7C0(a2, a3);
    CFPropertyListRef v19 = sub_10003A7C0(a4, a5);
    if (!v18)
    {
LABEL_28:
      if (v19) {
        CFRelease(v19);
      }
      goto LABEL_30;
    }

    __int16 v20 = objc_autoreleasePoolPush();
    if (qword_100219F60) {
      [(id)qword_100219F60 WFLog:3, "ManagerClient[%@] setProperty[%@] = %@", sub_10003BEDC((uint64_t)v14), v18, v19 message];
    }
    objc_autoreleasePoolPop(v20);
    if (CFStringCompare(v18, @"carplayParameters", 0LL))
    {
      if (CFStringCompare(v18, @"HotspotDataUsage", 0LL))
      {
        if (CFStringCompare(v18, @"FamilyHotspotPreferences", 0LL) == kCFCompareEqualTo)
        {
          sub_1000829B4(v17, (uint64_t)v19);
          goto LABEL_27;
        }

        if (CFStringCompare(v18, @"Custom network settings", 0LL) == kCFCompareEqualTo)
        {
          sub_100082AA4((uint64_t)v17, (uint64_t)v19);
          goto LABEL_27;
        }

        if (CFStringCompare(v18, @"PerpetualWiFiScanEnabled", 0LL) == kCFCompareEqualTo)
        {
          sub_1000841D4(v17, (const __CFBoolean *)v19);
          goto LABEL_27;
        }

        if (!sub_100071B18(v17, v18, v19))
        {
          unsigned int v21 = objc_autoreleasePoolPush();
          CFPropertyListRef v22 = (void *)qword_100219F60;
          if (qword_100219F60)
          {
            uint64_t v23 = "Unable to Set Property";
LABEL_22:
            [v22 WFLog:4 message:v23];
            goto LABEL_23;
          }

          goto LABEL_23;
        }
      }

      else if (!sub_10000B784())
      {
        unsigned int v21 = objc_autoreleasePoolPush();
        CFPropertyListRef v22 = (void *)qword_100219F60;
        if (qword_100219F60)
        {
          uint64_t v23 = "Unable to Reset Hotspot Data Usage";
          goto LABEL_22;
        }

uint64_t sub_1000B1874(unsigned int a1, vm_offset_t *a2, mach_msg_type_number_t *a3)
{
  *a2 = 0LL;
  *a3 = 0;
  uint64_t v6 = sub_10003B8D0();
  CFStringRef v7 = sub_10009137C(a1, v6);
  if (v7)
  {
    uint64_t v8 = v7;
    if ((sub_10003BEEC((uint64_t)v7) & 1) != 0)
    {
      uint64_t v10 = (const __CFArray *)sub_10003BEC4((uint64_t)v8);
      if (v10)
      {
        CFStringRef v11 = sub_10006C77C(v10);
        if (v11)
        {
          uint64_t v12 = v11;
          uint64_t v13 = sub_10003BEF4((uint64_t)v8, v11);
          if (v13)
          {
            uint64_t v14 = v13;
            sub_10003A920(v13, a2, a3);
            CFRelease(v14);
          }

          CFRelease(v12);
        }
      }
    }

    else
    {
      uint64_t v9 = objc_autoreleasePoolPush();
      if (qword_100219F60) {
        [(id)qword_100219F60 WFLog:4, "%s Client %@ has no entitlement", "kern_return_t _wifi_manager_copy_devices(mach_port_t, vm_offset_t *, mach_msg_type_number_t *)", sub_10003BEDC((uint64_t)v8) message];
      }
      objc_autoreleasePoolPop(v9);
    }

    CFRelease(v8);
  }

  return 0LL;
}

uint64_t sub_1000B1978(unsigned int a1, int a2, vm_offset_t *a3, mach_msg_type_number_t *a4)
{
  *a3 = 0LL;
  *a4 = 0;
  uint64_t v8 = sub_10003B8D0();
  uint64_t v9 = sub_10009137C(a1, v8);
  if (v9)
  {
    uint64_t v10 = v9;
    if ((sub_10003BEEC((uint64_t)v9) & 1) != 0)
    {
      uint64_t v12 = sub_10003BEC4((uint64_t)v10);
      if (v12)
      {
        uint64_t v13 = a2 ? sub_10006CB48(v12) : sub_10006CA28(v12);
        uint64_t v14 = v13;
        if (v13)
        {
          uint64_t v15 = sub_10003A464(v13);
          if (v15)
          {
            uint64_t v16 = v15;
            sub_10003A920(v15, a3, a4);
            CFRelease(v16);
          }

          CFRelease(v14);
        }
      }
    }

    else
    {
      CFStringRef v11 = objc_autoreleasePoolPush();
      if (qword_100219F60) {
        [(id)qword_100219F60 WFLog:4, "%s Client %@ has no entitlement", "kern_return_t _wifi_manager_copy_networks(mach_port_t, int, vm_offset_t *, mach_msg_type_number_t *)", sub_10003BEDC((uint64_t)v10) message];
      }
      objc_autoreleasePoolPop(v11);
    }

    CFRelease(v10);
  }

  return 0LL;
}

uint64_t sub_1000B1A88(unsigned int a1, UInt8 *a2, CFIndex a3)
{
  uint64_t v6 = sub_10003B8D0();
  CFStringRef v7 = sub_10009137C(a1, v6);
  if (v7)
  {
    uint64_t v8 = v7;
    if ((sub_10003BEEC((uint64_t)v7) & 1) != 0)
    {
      uint64_t v10 = sub_10003BEC4((uint64_t)v8);
      if (v10)
      {
        uint64_t v11 = v10;
        uint64_t v12 = sub_1000B1C5C(a2, a3);
        if (v12)
        {
          uint64_t v13 = v12;
          uint64_t v14 = objc_autoreleasePoolPush();
          uint64_t v15 = (void *)qword_100219F60;
          if (qword_100219F60)
          {
            uint64_t v16 = sub_100095BC8(v13);
            [v15 WFLog:3, "Add network <%@>, requested by %@", v16, sub_10003BEDC((uint64_t)v8) message];
          }

          objc_autoreleasePoolPop(v14);
          uint64_t v17 = (const __CFString *)sub_10003BEDC((uint64_t)v8);
          if (CFStringCompare(v17, @"profiled", 0LL))
          {
            CFTypeID v18 = (const __CFString *)sub_10003BEDC((uint64_t)v8);
            if (CFStringCompare(v18, @"mobilewifitool", 0LL))
            {
              uint64_t v19 = v11;
              __int16 v20 = v13;
              uint64_t v21 = 1LL;
            }

            else
            {
              uint64_t v19 = v11;
              __int16 v20 = v13;
              uint64_t v21 = 23LL;
            }

            sub_100072038(v19, v20, v21);
          }

          else
          {
            sub_100072038(v11, v13, 17LL);
            sub_10009582C((uint64_t)v13, @"UpdateReason", @"ProfileAddition");
            sub_100083754(v11, v13);
          }

          CFRelease(v13);
        }
      }
    }

    else
    {
      uint64_t v9 = objc_autoreleasePoolPush();
      if (qword_100219F60) {
        [(id)qword_100219F60 WFLog:4, "%s Client %@ has no entitlement", "kern_return_t _wifi_manager_add_network(mach_port_t, vm_offset_t, mach_msg_type_number_t)", sub_10003BEDC((uint64_t)v8) message];
      }
      objc_autoreleasePoolPop(v9);
    }

    CFRelease(v8);
  }

  sub_10003A8FC((vm_address_t)a2, a3);
  return 0LL;
}

_WORD *sub_1000B1C5C(UInt8 *a1, CFIndex length)
{
  CFPropertyListRef v2 = sub_10003A7C0(a1, length);
  if (!v2) {
    return 0LL;
  }
  __int128 v3 = v2;
  CFTypeID v4 = CFGetTypeID(v2);
  if (v4 == CFDictionaryGetTypeID()) {
    uint64_t v5 = sub_100094AAC((uint64_t)kCFAllocatorDefault, v3);
  }
  else {
    uint64_t v5 = 0LL;
  }
  CFRelease(v3);
  return v5;
}

uint64_t sub_1000B1CCC(unsigned int a1, UInt8 *a2, CFIndex a3, UInt8 *a4, unsigned int a5)
{
  uint64_t v10 = sub_10003B8D0();
  uint64_t v11 = sub_10009137C(a1, v10);
  if (v11)
  {
    uint64_t v12 = v11;
    if ((sub_10003BEEC((uint64_t)v11) & 1) != 0)
    {
      uint64_t v14 = sub_10003BEC4((uint64_t)v12);
      if (v14)
      {
        uint64_t v15 = v14;
        uint64_t v16 = sub_1000B1C5C(a2, a3);
        if (v16)
        {
          uint64_t v17 = v16;
          CFTypeID v18 = 0LL;
          if (!a4
            || !a5
            || (CFTypeID v18 = (const __CFDictionary *)sub_10003A7C0(a4, a5),
                CFTypeID v19 = CFGetTypeID(v18),
                v19 == CFDictionaryGetTypeID()))
          {
            sub_100074A94(v15, (uint64_t)v12, v17, v18, 0LL, 0LL);
          }

          CFRelease(v17);
          if (v18) {
            CFRelease(v18);
          }
        }
      }
    }

    else
    {
      uint64_t v13 = objc_autoreleasePoolPush();
      if (qword_100219F60) {
        [(id)qword_100219F60 WFLog:4, "%s Client %@ has no entitlement", "kern_return_t _wifi_manager_add_network_async(mach_port_t, vm_offset_t, mach_msg_type_number_t, vm_offset_t, m ach_msg_type_number_t)", sub_10003BEDC((uint64_t)v12) message];
      }
      objc_autoreleasePoolPop(v13);
    }

    CFRelease(v12);
  }

  sub_10003A8FC((vm_address_t)a2, a3);
  sub_10003A8FC((vm_address_t)a4, a5);
  return 0LL;
}

uint64_t sub_1000B1E34(unsigned int a1, UInt8 *a2, CFIndex a3)
{
  uint64_t v6 = sub_10003B8D0();
  CFStringRef v7 = sub_10009137C(a1, v6);
  if (v7)
  {
    uint64_t v8 = v7;
    if ((sub_10003BEEC((uint64_t)v7) & 1) != 0)
    {
      uint64_t v10 = sub_10003BEC4((uint64_t)v8);
      if (v10)
      {
        uint64_t v11 = v10;
        uint64_t v12 = sub_1000B1C5C(a2, a3);
        if (v12)
        {
          uint64_t v13 = v12;
          uint64_t v14 = (const __CFString *)sub_10003BEDC((uint64_t)v8);
          uint64_t v15 = objc_autoreleasePoolPush();
          if (qword_100219F60) {
            [(id)qword_100219F60 WFLog:3, "Update network <%@>, requested by %@", sub_100095BC8(v13), v14 message];
          }
          objc_autoreleasePoolPop(v15);
          if (CFStringCompare(v14, @"configd", 0LL) == kCFCompareEqualTo)
          {
            uint64_t v16 = objc_autoreleasePoolPush();
            if (qword_100219F60) {
              [qword_100219F60 WFLog:@"%s: removing internal properties from network" message:3];
            }
            objc_autoreleasePoolPop(v16);
            sub_10009F2A4((uint64_t)v13);
          }

          sub_100077498(v11, v13, 1u);
          CFRelease(v13);
        }
      }
    }

    else
    {
      uint64_t v9 = objc_autoreleasePoolPush();
      if (qword_100219F60) {
        [(id)qword_100219F60 WFLog:4, "%s Client %@ has no entitlement", "kern_return_t _wifi_manager_update_network(mach_port_t, vm_offset_t, mach_msg_type_number_t)", sub_10003BEDC((uint64_t)v8) message];
      }
      objc_autoreleasePoolPop(v9);
    }

    CFRelease(v8);
  }

  sub_10003A8FC((vm_address_t)a2, a3);
  return 0LL;
}

uint64_t sub_1000B1FE0(unsigned int a1, UInt8 *a2, CFIndex a3, uint64_t a4)
{
  uint64_t v8 = sub_10003B8D0();
  uint64_t v9 = sub_10009137C(a1, v8);
  if (v9)
  {
    uint64_t v10 = v9;
    if ((sub_10003BEEC((uint64_t)v9) & 1) != 0)
    {
      uint64_t v12 = sub_10003BEC4((uint64_t)v10);
      if (v12)
      {
        uint64_t v13 = v12;
        uint64_t v14 = sub_1000B1C5C(a2, a3);
        if (v14)
        {
          uint64_t v15 = v14;
          uint64_t v16 = objc_autoreleasePoolPush();
          uint64_t v17 = (void *)qword_100219F60;
          if (qword_100219F60)
          {
            CFTypeID v18 = sub_100095BC8(v15);
            [v17 WFLog:3, "Remove network <%@>, requested by %@", v18, sub_10003BEDC((uint64_t)v10) message];
          }

          objc_autoreleasePoolPop(v16);
          sub_100076340(v13, v15, a4);
          CFRelease(v15);
        }
      }
    }

    else
    {
      uint64_t v11 = objc_autoreleasePoolPush();
      if (qword_100219F60) {
        [(id)qword_100219F60 WFLog:4, "%s Client %@ has no entitlement", "kern_return_t _wifi_manager_remove_network(mach_port_t, vm_offset_t, mach_msg_type_number_t, int)", sub_10003BEDC((uint64_t)v10) message];
      }
      objc_autoreleasePoolPop(v11);
    }

    CFRelease(v10);
  }

  sub_10003A8FC((vm_address_t)a2, a3);
  return 0LL;
}

uint64_t sub_1000B213C(unsigned int a1, UInt8 *a2, unsigned int a3)
{
  uint64_t v6 = sub_10003B8D0();
  CFStringRef v7 = (const __CFString *)sub_10009137C(a1, v6);
  if (v7)
  {
    uint64_t v8 = v7;
    if ((sub_10003BEEC((uint64_t)v7) & 1) != 0)
    {
      uint64_t v10 = sub_10003BEC4((uint64_t)v8);
      if (v10)
      {
        uint64_t v11 = v10;
        uint64_t v12 = (const __CFString *)sub_10003A7C0(a2, a3);
        if (v12)
        {
          uint64_t v13 = v12;
          CFTypeID v14 = CFGetTypeID(v12);
          if (v14 == CFStringGetTypeID()) {
            sub_1000783F0(v11, v13);
          }
          CFRelease(v8);
          uint64_t v8 = v13;
        }
      }
    }

    else
    {
      uint64_t v9 = objc_autoreleasePoolPush();
      if (qword_100219F60) {
        [(id)qword_100219F60 WFLog:4, "%s Client %@ has no entitlement", "kern_return_t _wifi_manager_remove_networks_with_bundle_identifier(mach_port_t, vm_offset_t, mach_msg_type_number_t)", sub_10003BEDC((uint64_t)v8) message];
      }
      objc_autoreleasePoolPop(v9);
    }

    CFRelease(v8);
  }

  sub_10003A8FC((vm_address_t)a2, a3);
  return 0LL;
}

uint64_t sub_1000B224C(unsigned int a1, UInt8 *a2, unsigned int a3, unsigned __int8 a4)
{
  uint64_t v8 = sub_10003B8D0();
  uint64_t v9 = sub_10009137C(a1, v8);
  if (v9)
  {
    uint64_t v10 = v9;
    if ((sub_10003BEEC((uint64_t)v9) & 1) != 0)
    {
      uint64_t v12 = sub_10003BEC4((uint64_t)v10);
      if (v12)
      {
        uint64_t v13 = v12;
        CFTypeID v14 = (const __CFString *)sub_10003A7C0(a2, a3);
        if (v14)
        {
          uint64_t v15 = v14;
          CFTypeID v16 = CFGetTypeID(v14);
          if (v16 == CFStringGetTypeID())
          {
            uint64_t v17 = sub_10006C93C(v13, v15);
            if (v17)
            {
              CFTypeID v18 = v17;
              CFIndex Count = CFArrayGetCount(v17);
              if (Count >= 1)
              {
                CFIndex v20 = Count;
                for (CFIndex i = 0LL; i != v20; ++i)
                {
                  ValueAtIndex = (void *)CFArrayGetValueAtIndex(v18, i);
                  if (ValueAtIndex) {
                    sub_10007853C(v13, ValueAtIndex, a4, 0);
                  }
                }
              }

              CFRelease(v18);
            }
          }

          CFRelease(v15);
        }
      }
    }

    else
    {
      uint64_t v11 = objc_autoreleasePoolPush();
      if (qword_100219F60) {
        [(id)qword_100219F60 WFLog:4, "%s Client %@ has no entitlement", "kern_return_t _wifi_manager_set_networks_state_with_bundle_identifier(mach_port_t, vm_offset_t, mach_msg_type_number_t, int)", sub_10003BEDC((uint64_t)v10) message];
      }
      objc_autoreleasePoolPop(v11);
    }

    CFRelease(v10);
  }

  sub_10003A8FC((vm_address_t)a2, a3);
  return 0LL;
}

uint64_t sub_1000B23C4(unsigned int a1, UInt8 *a2, CFIndex a3, int a4, char a5)
{
  uint64_t v10 = sub_10003B8D0();
  uint64_t v11 = sub_10009137C(a1, v10);
  if (v11)
  {
    uint64_t v12 = v11;
    if ((sub_10003BEEC((uint64_t)v11) & 1) == 0)
    {
      uint64_t v13 = objc_autoreleasePoolPush();
      if (qword_100219F60) {
        [(id)qword_100219F60 WFLog:4, "%s Client %@ has no entitlement", "kern_return_t _wifi_manager_set_network_state(mach_port_t, vm_offset_t, mach_msg_type_number_t, int, int)", sub_10003BEDC((uint64_t)v12) message];
      }
      objc_autoreleasePoolPop(v13);
      goto LABEL_19;
    }

    uint64_t v14 = sub_10003BEC4((uint64_t)v12);
    if (!v14 || (uint64_t v15 = v14, (v16 = sub_1000B1C5C(a2, a3)) == 0LL))
    {
LABEL_19:
      CFRelease(v12);
      goto LABEL_20;
    }

    uint64_t v17 = v16;
    CFTypeID v18 = objc_autoreleasePoolPush();
    if (qword_100219F60)
    {
      if (a4) {
        CFTypeID v19 = "ENABLED";
      }
      else {
        CFTypeID v19 = "DISABLED";
      }
      [(id)qword_100219F60 WFLog:4, "Auto join %s by %@ for %@", v19, sub_10003BEDC((uint64_t)v12), v17 message];
    }

    objc_autoreleasePoolPop(v18);
    if (os_log_type_enabled((os_log_t)&_os_log_default, OS_LOG_TYPE_ERROR))
    {
      sub_10015469C(a4, (uint64_t)v12, (uint64_t)v17);
      if (a4) {
        goto LABEL_15;
      }
    }

    else if (a4)
    {
LABEL_15:
      sub_10007853C(v15, v17, a4, a5);
LABEL_18:
      CFRelease(v17);
      goto LABEL_19;
    }

    CFIndex v20 = (const void *)sub_10003BEDC((uint64_t)v12);
    sub_10009582C((uint64_t)v17, @"networkDisabledClientName", v20);
    sub_10007853C(v15, v17, 0, a5);
    sub_10006D6CC(v15, 1u);
    goto LABEL_18;
  }

uint64_t sub_1000B25A4(unsigned int a1, UInt8 *a2, CFIndex a3, _DWORD *a4)
{
  *a4 = 0;
  uint64_t v8 = sub_10003B8D0();
  uint64_t v9 = sub_10009137C(a1, v8);
  if (v9)
  {
    uint64_t v10 = v9;
    if ((sub_10003BEEC((uint64_t)v9) & 1) != 0)
    {
      uint64_t v12 = sub_10003BEC4((uint64_t)v10);
      if (v12)
      {
        uint64_t v13 = v12;
        uint64_t v14 = sub_1000B1C5C(a2, a3);
        if (v14)
        {
          uint64_t v15 = v14;
          *a4 = sub_1000786E0(v13, v14);
          CFRelease(v15);
        }
      }
    }

    else
    {
      uint64_t v11 = objc_autoreleasePoolPush();
      if (qword_100219F60) {
        [(id)qword_100219F60 WFLog:4, "%s Client %@ has no entitlement", "kern_return_t _wifi_manager_get_network_state(mach_port_t, vm_offset_t, mach_msg_type_number_t, int *)", sub_10003BEDC((uint64_t)v10) message];
      }
      objc_autoreleasePoolPop(v11);
    }

    CFRelease(v10);
  }

  sub_10003A8FC((vm_address_t)a2, a3);
  return 0LL;
}

uint64_t sub_1000B26A8(unsigned int a1, uint64_t a2, uint64_t a3, UInt8 *a4, unsigned int a5)
{
  uint64_t v10 = sub_10003B8D0();
  uint64_t v11 = sub_10009137C(a1, v10);
  if (v11)
  {
    uint64_t v12 = v11;
    if ((sub_10003BEEC((uint64_t)v11) & 1) == 0)
    {
      uint64_t v13 = objc_autoreleasePoolPush();
      if (qword_100219F60) {
        [(id)qword_100219F60 WFLog:4, "%s Client %@ has no entitlement", "kern_return_t _wifi_manager_indicate_carplay_hid_event_received(mach_port_t, int, int, vm_offset_t, mach_msg_type_number_t)", sub_10003BEDC((uint64_t)v12) message];
      }
      objc_autoreleasePoolPop(v13);
      goto LABEL_12;
    }

    uint64_t v14 = sub_10003BEC4((uint64_t)v12);
    if (v14)
    {
      uint64_t v15 = v14;
      CFPropertyListRef v16 = sub_10003A7C0(a4, a5);
      if (v16)
      {
        uint64_t v17 = v16;
        CFTypeID v18 = CFGetTypeID(v16);
        if (v18 == CFStringGetTypeID())
        {
          sub_100071C5C(v15, a2, a3, (uint64_t)v17);
          CFRelease(v17);
          goto LABEL_12;
        }

        CFRelease(v17);
      }

      sub_100071C5C(v15, a2, a3, 0LL);
    }

uint64_t sub_1000B27EC(unsigned int a1, uint64_t a2, uint64_t a3, UInt8 *a4, unsigned int a5)
{
  uint64_t v10 = sub_10003B8D0();
  uint64_t v11 = sub_10009137C(a1, v10);
  if (v11)
  {
    uint64_t v12 = v11;
    if ((sub_10003BEEC((uint64_t)v11) & 1) == 0)
    {
      uint64_t v13 = objc_autoreleasePoolPush();
      if (qword_100219F60) {
        [(id)qword_100219F60 WFLog:4, "%s Client %@ has no entitlement", "kern_return_t _wifi_manager_dispatch_notification_response(mach_port_t, int, int, vm_offset_t, mach_msg_type_number_t)", sub_10003BEDC((uint64_t)v12) message];
      }
      objc_autoreleasePoolPop(v13);
      goto LABEL_12;
    }

    uint64_t v14 = sub_10003BEC4((uint64_t)v12);
    if (v14)
    {
      uint64_t v15 = v14;
      CFPropertyListRef v16 = sub_10003A7C0(a4, a5);
      if (v16)
      {
        uint64_t v17 = v16;
        CFTypeID v18 = CFGetTypeID(v16);
        if (v18 == CFDictionaryGetTypeID())
        {
          sub_100071B6C(v15, a2, a3, v17);
          CFRelease(v17);
          goto LABEL_12;
        }

        CFRelease(v17);
      }

      sub_100071B6C(v15, a2, a3, 0LL);
    }

uint64_t sub_1000B2930(unsigned int a1, int a2)
{
  uint64_t v4 = sub_10003B8D0();
  uint64_t v5 = sub_10009137C(a1, v4);
  if (v5)
  {
    uint64_t v6 = v5;
    if ((sub_10003BEEC((uint64_t)v5) & 1) != 0)
    {
      uint64_t v8 = sub_10003BEC4((uint64_t)v6);
      if (!v8)
      {
LABEL_17:
        CFRelease(v6);
        return 0LL;
      }

      uint64_t v9 = v8;
      if (a2)
      {
        sub_100071774(v8, v6);
        else {
          sub_10006B744(v9, 2);
        }
      }

      else
      {
        sub_100071AB4(v8, v6);
      }

      CFStringRef v7 = objc_autoreleasePoolPush();
      if (qword_100219F60)
      {
        if (a2) {
          uint64_t v10 = "ENABLED";
        }
        else {
          uint64_t v10 = "DISABLED";
        }
        [(id)qword_100219F60 WFLog:3, "Auto join %s by %@", v10, sub_10003BEDC((uint64_t)v6) message];
      }
    }

    else
    {
      CFStringRef v7 = objc_autoreleasePoolPush();
      if (qword_100219F60) {
        [(id)qword_100219F60 WFLog:4, "%s Client %@ has no entitlement", "kern_return_t _wifi_manager_set_enable_state(mach_port_t, int)", sub_10003BEDC((uint64_t)v6) message];
      }
    }

    objc_autoreleasePoolPop(v7);
    goto LABEL_17;
  }

  return 0LL;
}

uint64_t sub_1000B2A88(unsigned int a1, uint64_t a2)
{
  uint64_t v4 = sub_10003B8D0();
  uint64_t v5 = sub_10009137C(a1, v4);
  if (v5)
  {
    uint64_t v6 = v5;
    if ((sub_10003BEEC((uint64_t)v5) & 1) != 0)
    {
      uint64_t v8 = sub_10003BEC4((uint64_t)v6);
      if (v8)
      {
        uint64_t v9 = v8;
        uint64_t v10 = objc_autoreleasePoolPush();
        if (qword_100219F60) {
          [(id)qword_100219F60 WFLog:3, "%@ requested association mode %d", sub_10003BEDC((uint64_t)v6), a2 message];
        }
        objc_autoreleasePoolPop(v10);
        sub_10006CEA4(v9, a2, 0);
      }
    }

    else
    {
      CFStringRef v7 = objc_autoreleasePoolPush();
      if (qword_100219F60) {
        [(id)qword_100219F60 WFLog:4, "%s Client %@ has no entitlement", "kern_return_t _wifi_manager_set_association_mode(mach_port_t, int)", sub_10003BEDC((uint64_t)v6) message];
      }
      objc_autoreleasePoolPop(v7);
    }

    CFRelease(v6);
  }

  return 0LL;
}

uint64_t sub_1000B2B98(unsigned int a1, _DWORD *a2)
{
  *a2 = 1;
  uint64_t v4 = sub_10003B8D0();
  uint64_t v5 = sub_10009137C(a1, v4);
  if (v5)
  {
    uint64_t v6 = v5;
    if ((sub_10003BEEC((uint64_t)v5) & 1) != 0)
    {
      uint64_t v8 = sub_10003BEC4((uint64_t)v6);
      if (v8) {
        *a2 = sub_10006D9EC(v8);
      }
    }

    else
    {
      CFStringRef v7 = objc_autoreleasePoolPush();
      if (qword_100219F60) {
        [(id)qword_100219F60 WFLog:4, "%s Client %@ has no entitlement", "kern_return_t _wifi_manager_get_association_mode(mach_port_t, int *)", sub_10003BEDC((uint64_t)v6) message];
      }
      objc_autoreleasePoolPop(v7);
    }

    CFRelease(v6);
  }

  return 0LL;
}

uint64_t sub_1000B2C5C(unsigned int a1, uint64_t a2)
{
  uint64_t v4 = sub_10003B8D0();
  uint64_t v5 = sub_10009137C(a1, v4);
  if (v5)
  {
    uint64_t v6 = v5;
    if ((sub_10003BEEC((uint64_t)v5) & 1) != 0)
    {
      uint64_t v8 = sub_10003BEC4((uint64_t)v6);
      if (v8)
      {
        uint64_t v9 = v8;
        uint64_t v10 = objc_autoreleasePoolPush();
        if (qword_100219F60) {
          [(id)qword_100219F60 WFLog:3, "%@ requested ask-to-join preference %d", sub_10003BEDC((uint64_t)v6), a2 message];
        }
        objc_autoreleasePoolPop(v10);
        sub_10006D9F4(v9, a2, 0);
      }
    }

    else
    {
      CFStringRef v7 = objc_autoreleasePoolPush();
      if (qword_100219F60) {
        [(id)qword_100219F60 WFLog:4, "%s Client %@ has no entitlement", "kern_return_t _wifi_manager_set_asktojoin_preference(mach_port_t, int)", sub_10003BEDC((uint64_t)v6) message];
      }
      objc_autoreleasePoolPop(v7);
    }

    CFRelease(v6);
  }

  return 0LL;
}

uint64_t sub_1000B2D70(unsigned int a1, _DWORD *a2)
{
  *a2 = 1;
  uint64_t v4 = sub_10003B8D0();
  uint64_t v5 = sub_10009137C(a1, v4);
  if (v5)
  {
    uint64_t v6 = v5;
    if ((sub_10003BEEC((uint64_t)v5) & 1) != 0)
    {
      uint64_t v8 = sub_10003BEC4((uint64_t)v6);
      if (v8) {
        *a2 = sub_10006DB1C(v8);
      }
    }

    else
    {
      CFStringRef v7 = objc_autoreleasePoolPush();
      if (qword_100219F60) {
        [(id)qword_100219F60 WFLog:4, "%s Client %@ has no entitlement", "kern_return_t _wifi_manager_get_asktojoin_preference(mach_port_t, int *)", sub_10003BEDC((uint64_t)v6) message];
      }
      objc_autoreleasePoolPop(v7);
    }

    CFRelease(v6);
  }

  return 0LL;
}

uint64_t sub_1000B2E34(unsigned int a1, int a2)
{
  uint64_t v4 = sub_10003B8D0();
  uint64_t v5 = sub_10009137C(a1, v4);
  if (v5)
  {
    uint64_t v6 = v5;
    char v7 = sub_10003BEEC((uint64_t)v5);
    uint64_t v8 = objc_autoreleasePoolPush();
    uint64_t v9 = (void *)qword_100219F60;
    if ((v7 & 1) != 0)
    {
      if (qword_100219F60)
      {
        uint64_t v10 = sub_10003BEDC((uint64_t)v6);
        switch(a2)
        {
          case 1:
            uint64_t v11 = "background";
            break;
          case 3:
            uint64_t v11 = "cloud";
            break;
          case 4:
            uint64_t v11 = "sidekick";
            break;
          default:
            uint64_t v11 = "normal";
            if (a2 == 5) {
              uint64_t v11 = "sidekick-unittest";
            }
            break;
        }

        [v9 WFLog:3, "Client %@ set type to %s application", v10, v11 message];
      }

      objc_autoreleasePoolPop(v8);
      if (sub_10003BEB4((uint64_t)v6) != a2)
      {
        uint64_t v12 = sub_10003BEC4((uint64_t)v6);
        if (v12)
        {
          uint64_t v13 = v12;
          sub_100071570(v12, v6);
          sub_10003BEBC((uint64_t)v6, a2);
          sub_1000709D4(v13, v6);
        }
      }
    }

    else
    {
      if (qword_100219F60) {
        [(id)qword_100219F60 WFLog:4, "%s Client %@ has no entitlement", "kern_return_t _wifi_manager_set_client_type(mach_port_t, int)", sub_10003BEDC((uint64_t)v6) message];
      }
      objc_autoreleasePoolPop(v8);
    }

    CFRelease(v6);
  }

  return 0LL;
}

uint64_t sub_1000B2FA8(unsigned int a1, uint64_t a2)
{
  uint64_t v4 = sub_10003B8D0();
  uint64_t v5 = sub_10009137C(a1, v4);
  if (v5)
  {
    uint64_t v6 = v5;
    if ((sub_10003BEEC((uint64_t)v5) & 1) != 0)
    {
      sub_10003DC70((uint64_t)v6, a2);
    }

    else
    {
      char v7 = objc_autoreleasePoolPush();
      if (qword_100219F60) {
        [(id)qword_100219F60 WFLog:4, "%s Client %@ has no entitlement", "kern_return_t _wifi_manager_set_event_mask(mach_port_t, uint64_t)", sub_10003BEDC((uint64_t)v6) message];
      }
      objc_autoreleasePoolPop(v7);
    }

    CFRelease(v6);
  }

  return 0LL;
}

uint64_t sub_1000B305C(unsigned int a1, UInt8 *a2, unsigned int a3)
{
  uint64_t v6 = sub_10003B8D0();
  char v7 = sub_10009137C(a1, v6);
  if (v7)
  {
    uint64_t v8 = v7;
    if ((sub_10003BEEC((uint64_t)v7) & 1) != 0)
    {
      uint64_t v10 = sub_10003BEC4((uint64_t)v8);
      if (v10)
      {
        uint64_t v11 = v10;
        CFPropertyListRef v12 = sub_10003A7C0(a2, a3);
        if (v12)
        {
          uint64_t v13 = (void *)v12;
          CFTypeID v14 = CFGetTypeID(v12);
          if (v14 == CFArrayGetTypeID() && (uint64_t v15 = sub_10003A530((const __CFArray *)v13)) != 0LL)
          {
            CFPropertyListRef v16 = v15;
            sub_10006F530(v11, v15);
            CFRelease(v13);
            uint64_t v17 = v16;
          }

          else
          {
            uint64_t v17 = (__CFArray *)v13;
          }

          CFRelease(v17);
        }
      }
    }

    else
    {
      uint64_t v9 = objc_autoreleasePoolPush();
      if (qword_100219F60) {
        [(id)qword_100219F60 WFLog:4, "%s Client %@ has no entitlement", "kern_return_t _wifi_manager_set_background_scan_networks(mach_port_t, vm_offset_t, mach_msg_type_number_t)", sub_10003BEDC((uint64_t)v8) message];
      }
      objc_autoreleasePoolPop(v9);
    }

    CFRelease(v8);
  }

  sub_10003A8FC((vm_address_t)a2, a3);
  return 0LL;
}

uint64_t sub_1000B3188(unsigned int a1, _DWORD *a2)
{
  *a2 = 0;
  uint64_t v4 = sub_10003B8D0();
  uint64_t v5 = sub_10009137C(a1, v4);
  if (v5)
  {
    uint64_t v6 = v5;
    if ((sub_10003BEEC((uint64_t)v5) & 1) != 0)
    {
      uint64_t v8 = sub_10003BEC4((uint64_t)v6);
      if (v8) {
        *a2 = sub_10006F74C(v8);
      }
    }

    else
    {
      char v7 = objc_autoreleasePoolPush();
      if (qword_100219F60) {
        [(id)qword_100219F60 WFLog:4, "%s Client %@ has no entitlement", "kern_return_t _wifi_manager_get_bgscancache_state(mach_port_t, int *)", sub_10003BEDC((uint64_t)v6) message];
      }
      objc_autoreleasePoolPop(v7);
    }

    CFRelease(v6);
  }

  return 0LL;
}

uint64_t sub_1000B3248(unsigned int a1, UInt8 *a2, unsigned int a3)
{
  uint64_t v6 = sub_10003B8D0();
  char v7 = sub_10009137C(a1, v6);
  if (v7)
  {
    uint64_t v8 = v7;
    uint64_t v9 = sub_10003BEC4((uint64_t)v7);
    if (v9)
    {
      uint64_t v10 = v9;
      if ((sub_10003BEEC((uint64_t)v8) & 1) != 0)
      {
        CFPropertyListRef v12 = sub_10003A7C0(a2, a3);
        if (v12)
        {
          uint64_t v13 = v12;
          sub_10007A4FC(v10, (uint64_t)v12);
          CFRelease(v13);
        }
      }

      else
      {
        uint64_t v11 = objc_autoreleasePoolPush();
        if (qword_100219F60) {
          [(id)qword_100219F60 WFLog:4, "%s Client %@ has no entitlement", "kern_return_t _wifi_manager_set_bgscan_cache_state(mach_port_t, vm_offset_t, mach_msg_type_number_t)", sub_10003BEDC((uint64_t)v8) message];
        }
        objc_autoreleasePoolPop(v11);
      }
    }

    CFRelease(v8);
  }

  sub_10003A8FC((vm_address_t)a2, a3);
  return 0LL;
}

uint64_t sub_1000B3340(unsigned int a1, int a2)
{
  uint64_t v4 = sub_10003B8D0();
  uint64_t v5 = sub_10009137C(a1, v4);
  if (v5)
  {
    uint64_t v6 = v5;
    if ((sub_10003BEEC((uint64_t)v5) & 1) != 0)
    {
      uint64_t v8 = sub_10003BEC4((uint64_t)v6);
      if (v8)
      {
        uint64_t v9 = v8;
        uint64_t v10 = objc_autoreleasePoolPush();
        uint64_t v11 = (void *)qword_100219F60;
        if (qword_100219F60)
        {
          uint64_t v12 = sub_10003BEDC((uint64_t)v6);
          uint64_t v13 = "enabled";
          if (!a2) {
            uint64_t v13 = "disabled";
          }
          [v11 WFLog:3, "%@ requested scan backoff reporting to be %s", v12, v13 message];
        }

        objc_autoreleasePoolPop(v10);
        sub_10007A544(v9, a2);
      }
    }

    else
    {
      char v7 = objc_autoreleasePoolPush();
      if (qword_100219F60) {
        [(id)qword_100219F60 WFLog:4, "%s Client %@ has no entitlement", "kern_return_t _wifi_manager_set_scan_backoff_report(mach_port_t, int)", sub_10003BEDC((uint64_t)v6) message];
      }
      objc_autoreleasePoolPop(v7);
    }

    CFRelease(v6);
  }

  return 0LL;
}

uint64_t sub_1000B3464(unsigned int a1, UInt8 *a2, unsigned int a3)
{
  uint64_t v6 = sub_10003B8D0();
  char v7 = sub_10009137C(a1, v6);
  if (v7)
  {
    uint64_t v8 = v7;
    uint64_t v9 = sub_10003BEC4((uint64_t)v7);
    if (v9)
    {
      uint64_t v10 = v9;
      if ((sub_10003BEEC((uint64_t)v8) & 1) != 0)
      {
        uint64_t v12 = (const __CFDictionary *)sub_10003A7C0(a2, a3);
        if (v12)
        {
          uint64_t v13 = v12;
          sub_10007B0B0(v10, v12);
          CFRelease(v13);
        }
      }

      else
      {
        uint64_t v11 = objc_autoreleasePoolPush();
        if (qword_100219F60) {
          [(id)qword_100219F60 WFLog:4, "%s Client %@ has no entitlement", "kern_return_t _wifi_manager_set_test_params(mach_port_t, vm_offset_t, mach_msg_type_number_t)", sub_10003BEDC((uint64_t)v8) message];
        }
        objc_autoreleasePoolPop(v11);
      }
    }

    CFRelease(v8);
  }

  sub_10003A8FC((vm_address_t)a2, a3);
  return 0LL;
}

uint64_t sub_1000B355C( unsigned int a1, UInt8 *a2, unsigned int a3, vm_offset_t *a4, mach_msg_type_number_t *a5)
{
  *a4 = 0LL;
  *a5 = 0;
  uint64_t v10 = sub_10003B8D0();
  uint64_t v11 = (const __CFDictionary *)sub_10009137C(a1, v10);
  if (!v11)
  {
    CFTypeID v14 = -[NSNumber initWithBool:](objc_alloc(&OBJC_CLASS___NSNumber), "initWithBool:", 0LL);
    if (!v14) {
      goto LABEL_16;
    }
    goto LABEL_15;
  }

  uint64_t v12 = v11;
  if ((sub_10003BEEC((uint64_t)v11) & 1) == 0)
  {
    uint64_t v13 = objc_autoreleasePoolPush();
    if (qword_100219F60) {
      [(id)qword_100219F60 WFLog:4, "%s Client %@ has no entitlement", "kern_return_t _wifi_manager_copy_test_params(mach_port_t, vm_offset_t, mach_msg_type_number_t, vm_offset_t *, ma ch_msg_type_number_t *)", sub_10003BEDC((uint64_t)v12) message];
    }
LABEL_5:
    objc_autoreleasePoolPop(v13);
    CFTypeID v14 = -[NSNumber initWithBool:](objc_alloc(&OBJC_CLASS___NSNumber), "initWithBool:", 0LL);
    uint64_t v15 = v12;
LABEL_13:
    CFRelease(v15);
    goto LABEL_14;
  }

  uint64_t v16 = sub_10003BEC4((uint64_t)v12);
  if (!v16)
  {
    uint64_t v13 = objc_autoreleasePoolPush();
    if (qword_100219F60) {
      [(id)qword_100219F60 WFLog:4, "%s: unable to find manager for client %@", "_wifi_manager_copy_test_params", sub_10003BEDC((uint64_t)v12) message];
    }
    goto LABEL_5;
  }

  uint64_t v17 = v16;
  CFTypeID v18 = (const __CFDictionary *)sub_10003A7C0(a2, a3);
  CFTypeID v19 = objc_autoreleasePoolPush();
  if (qword_100219F60) {
    [(id)qword_100219F60 WFLog:3, "%s: Calling WiFiManagerSetTestParamsAndCopyResponse with request:%@", "_wifi_manager_copy_test_params", v18 message];
  }
  objc_autoreleasePoolPop(v19);
  CFIndex v20 = sub_10007B374(v17, v18);
  CFTypeID v14 = (NSNumber *)v20;
  if (v20) {
    sub_10003A920(v20, a4, a5);
  }
  CFRelease(v12);
  if (v18)
  {
    uint64_t v15 = v18;
    goto LABEL_13;
  }

uint64_t sub_1000B3740(unsigned int a1, vm_offset_t *a2, mach_msg_type_number_t *a3)
{
  *a2 = 0LL;
  *a3 = 0;
  uint64_t v6 = sub_10003B8D0();
  char v7 = sub_10009137C(a1, v6);
  if (v7)
  {
    uint64_t v8 = v7;
    if ((sub_10003BEEC((uint64_t)v7) & 1) == 0)
    {
      uint64_t v9 = objc_autoreleasePoolPush();
      if (qword_100219F60) {
        [(id)qword_100219F60 WFLog:4, "%s Client %@ has no entitlement", "kern_return_t _wifi_manager_copy_version_info(mach_port_t, vm_offset_t *, mach_msg_type_number_t *)", sub_10003BEDC((uint64_t)v8) message];
      }
LABEL_10:
      objc_autoreleasePoolPop(v9);
      goto LABEL_11;
    }

    if (sub_10003BEC4((uint64_t)v8))
    {
      CFStringRef v10 = sub_100079F88();
      if (!v10)
      {
        uint64_t v9 = objc_autoreleasePoolPush();
        if (qword_100219F60) {
          [qword_100219F60 WFLog:@"Unable to copy client names" message:4 v13 v14];
        }
        goto LABEL_10;
      }

      CFStringRef v11 = v10;
      sub_10003A920(v10, a2, a3);
      CFRelease(v11);
    }

uint64_t sub_1000B3844(unsigned int a1, vm_offset_t *a2, mach_msg_type_number_t *a3)
{
  *a2 = 0LL;
  *a3 = 0;
  uint64_t v6 = sub_10003B8D0();
  char v7 = sub_10009137C(a1, v6);
  if (v7)
  {
    uint64_t v8 = v7;
    if ((sub_10003BEEC((uint64_t)v7) & 1) == 0)
    {
      uint64_t v9 = objc_autoreleasePoolPush();
      if (qword_100219F60) {
        [(id)qword_100219F60 WFLog:4, "%s Client %@ has no entitlement", "kern_return_t _wifi_manager_copy_client_names(mach_port_t, vm_offset_t *, mach_msg_type_number_t *)", sub_10003BEDC((uint64_t)v8) message];
      }
LABEL_10:
      objc_autoreleasePoolPop(v9);
      goto LABEL_11;
    }

    uint64_t v10 = sub_10003BEC4((uint64_t)v8);
    if (v10)
    {
      CFMutableArrayRef v11 = sub_10007A000(v10);
      if (!v11)
      {
        uint64_t v9 = objc_autoreleasePoolPush();
        if (qword_100219F60) {
          objc_msgSend((id)qword_100219F60, "WFLog:message:", 4, "Unable to copy client names", v14, v15);
        }
        goto LABEL_10;
      }

      CFMutableArrayRef v12 = v11;
      sub_10003A920(v11, a2, a3);
      CFRelease(v12);
    }

uint64_t sub_1000B3948( unsigned int a1, UInt8 *a2, unsigned int a3, UInt8 *a4, unsigned int a5, vm_offset_t *a6, mach_msg_type_number_t *a7)
{
  *a6 = 0LL;
  *a7 = 0;
  uint64_t v14 = sub_10003B8D0();
  uint64_t v15 = sub_10009137C(a1, v14);
  if (v15)
  {
    uint64_t v16 = v15;
    if ((sub_10003BEEC((uint64_t)v15) & 1) != 0)
    {
      CFPropertyListRef v18 = sub_10003A7C0(a2, a3);
      CFTypeID v19 = (const __CFString *)sub_10003A7C0(a4, a5);
      CFIndex v20 = v19;
      if (v18 && v19)
      {
        uint64_t v32 = a4;
        uint64_t v21 = sub_10003C078((uint64_t)v16, v18);
        if (!v21) {
          goto LABEL_25;
        }
        uint64_t v22 = (uint64_t)v21;
        CFTypeID v23 = CFGetTypeID(v20);
        if (v23 == CFStringGetTypeID() && CFEqual(v20, @"IO80211InterfaceWoWWakeUpParams"))
        {
          uint64_t v24 = objc_autoreleasePoolPush();
          if (qword_100219F60)
          {
            uint64_t context = v24;
            [(id)qword_100219F60 WFLog:3, "%s: %@ querying %@ on %@", "_wifi_device_copy_property", sub_10003BEDC((uint64_t)v16), v20, v18 message];
            uint64_t v24 = context;
          }

          objc_autoreleasePoolPop(v24);
        }

        uint64_t v25 = sub_10003BEDC(v22);
        CFDictionaryRef v26 = sub_100044010(v25, v18, v20);
        CFTypeID v27 = CFGetTypeID(v20);
        if (v27 == CFStringGetTypeID() && CFEqual(v20, @"IO80211InterfaceWoWWakeUpParams"))
        {
          unsigned int v28 = objc_autoreleasePoolPush();
          if (qword_100219F60)
          {
            contexta = v28;
            [(id)qword_100219F60 WFLog:3, "%s: %@ querying %@ on %@ received %@", "_wifi_device_copy_property", sub_10003BEDC((uint64_t)v16), v20, v18, v26 message];
            unsigned int v28 = contexta;
          }

          objc_autoreleasePoolPop(v28);
        }

        if (v26)
        {
          sub_10003A920(v26, a6, a7);
          CFRelease(v18);
        }

        else
        {
LABEL_25:
          CFDictionaryRef v26 = (CFDictionaryRef)v18;
        }

        CFRelease(v26);
        a4 = v32;
      }

      else
      {
        if (v18) {
          CFRelease(v18);
        }
        if (!v20) {
          goto LABEL_23;
        }
      }

      CFRelease(v20);
    }

    else
    {
      uint64_t v17 = objc_autoreleasePoolPush();
      if (qword_100219F60) {
        [(id)qword_100219F60 WFLog:4, "%s Client %@ has no entitlement", "kern_return_t _wifi_device_copy_property(mach_port_t, vm_offset_t, mach_msg_type_number_t, vm_offset_t, mach_m sg_type_number_t, vm_offset_t *, mach_msg_type_number_t *)", sub_10003BEDC((uint64_t)v16) message];
      }
      objc_autoreleasePoolPop(v17);
    }

uint64_t sub_1000B3BD4( unsigned int a1, UInt8 *a2, unsigned int a3, UInt8 *a4, unsigned int a5, UInt8 *a6, unsigned int a7)
{
  uint64_t v14 = sub_10003B8D0();
  uint64_t v15 = sub_10009137C(a1, v14);
  if (v15)
  {
    uint64_t v16 = v15;
    if ((sub_10003BEEC((uint64_t)v15) & 1) == 0)
    {
      uint64_t v17 = objc_autoreleasePoolPush();
      if (qword_100219F60) {
        [(id)qword_100219F60 WFLog:4, "%s Client %@ has no entitlement", "kern_return_t _wifi_device_set_property(mach_port_t, vm_offset_t, mach_msg_type_number_t, vm_offset_t, mach_ms g_type_number_t, vm_offset_t, mach_msg_type_number_t)", sub_10003BEDC((uint64_t)v16) message];
      }
      objc_autoreleasePoolPop(v17);
LABEL_18:
      CFRelease(v16);
      goto LABEL_19;
    }

    unsigned int v26 = a3;
    CFTypeID v27 = a2;
    CFPropertyListRef v18 = sub_10003A7C0(a2, a3);
    CFPropertyListRef v19 = sub_10003A7C0(a4, a5);
    CFPropertyListRef v20 = sub_10003A7C0(a6, a7);
    uint64_t v21 = v20;
    if (v18 && v19 && v20)
    {
      uint64_t v22 = (uint64_t *)sub_10003C078((uint64_t)v16, v18);
      if (v22)
      {
        CFTypeID v23 = v22;
        uint64_t v24 = objc_autoreleasePoolPush();
        if (qword_100219F60) {
          [(id)qword_100219F60 WFLog:3, "DeviceClient[%@] setProperty[%@] = %@", sub_10003BEDC((uint64_t)v16), v19, v21 message];
        }
        objc_autoreleasePoolPop(v24);
        sub_1000FB078(v23, v18, v19, v21);
      }
    }

    else if (!v18)
    {
      goto LABEL_14;
    }

    CFRelease(v18);
LABEL_14:
    if (v21) {
      CFRelease(v21);
    }
    a2 = v27;
    a3 = v26;
    if (v19) {
      CFRelease(v19);
    }
    goto LABEL_18;
  }

uint64_t sub_1000B3DCC( unsigned int a1, UInt8 *a2, unsigned int a3, UInt8 *a4, unsigned int a5, UInt8 *a6, unsigned int a7, _DWORD *a8)
{
  uint64_t v16 = sub_10003B8D0();
  uint64_t v17 = sub_10009137C(a1, v16);
  if (v17)
  {
    CFPropertyListRef v18 = v17;
    id v38 = a4;
    if ((sub_10003BEEC((uint64_t)v17) & 1) == 0)
    {
      CFPropertyListRef v19 = objc_autoreleasePoolPush();
      if (qword_100219F60) {
        [(id)qword_100219F60 WFLog:4, "%s Client %@ has no entitlement", "kern_return_t _wifi_device_set_coex_parameters(mach_port_t, vm_offset_t, mach_msg_type_number_t, vm_offset_t, mach_msg_type_number_t, vm_offset_t, mach_msg_type_number_t, int *)", sub_10003BEDC((uint64_t)v18) message];
      }
      objc_autoreleasePoolPop(v19);
      *a8 = 1;
LABEL_34:
      CFRelease(v18);
      a4 = v38;
      goto LABEL_35;
    }

    CFPropertyListRef v20 = sub_10003A7C0(a2, a3);
    uint64_t v21 = (const __CFString *)sub_10003A7C0(a4, a5);
    unsigned int v37 = a7;
    uint64_t v22 = (const __CFDictionary *)sub_10003A7C0(a6, a7);
    CFTypeID v23 = v22;
    if (!v20 || !v21 || !v22)
    {
      *a8 = 22;
      if (!v20) {
        goto LABEL_30;
      }
      goto LABEL_29;
    }

    uint64_t v24 = sub_10003C078((uint64_t)v18, v20);
    if (!v24)
    {
      *a8 = 6;
      goto LABEL_29;
    }

    uint64_t v25 = (uint64_t)v24;
    CFStringRef v36 = a6;
    CFTypeID TypeID = CFStringGetTypeID();
    if (TypeID != CFGetTypeID(v21)) {
      goto LABEL_17;
    }
    if (CFStringCompare(v21, @"BSP_Command", 0LL) == kCFCompareEqualTo)
    {
      sub_1000F72E8(v25, v23);
      goto LABEL_28;
    }

    if (CFStringCompare(v21, @"MWS_BT_A2DP_LLA_TRAFFIC_INDICATION", 0LL) == kCFCompareEqualTo)
    {
      int valuePtr = 0;
      int v31 = objc_autoreleasePoolPush();
      a6 = v36;
      if (qword_100219F60)
      {
        uint64_t context = v31;
        [(id)qword_100219F60 WFLog:3, "%s: client %@ calling APPLE80211KEY_MWS_BT_A2DP_LLA_TRAFFIC_INDICATION", "_wifi_device_set_coex_parameters", sub_10003BEDC((uint64_t)v18) message];
        int v31 = context;
      }

      objc_autoreleasePoolPop(v31);
      CFNumberGetValue(v23, kCFNumberIntType, &valuePtr);
      sub_1000F7030(v25, valuePtr);
      goto LABEL_29;
    }

    if (CFStringCompare(v21, @"MWS_Blacklisted_Channels", 0LL) == kCFCompareEqualTo)
    {
      uint64_t v32 = objc_autoreleasePoolPush();
      if (qword_100219F60) {
        [(id)qword_100219F60 WFLog:3, "%s: client %@ calling APPLE80211KEY_MWS_BLACKLISTED_CHANNELS", "_wifi_device_set_coex_parameters", sub_10003BEDC((uint64_t)v18) message];
      }
      objc_autoreleasePoolPop(v32);
      sub_1000D75B0(v25, v23);
      goto LABEL_28;
    }

    if (CFStringCompare(v21, @"MWS_BT_CONNECTION_REPORT", 0LL) == kCFCompareEqualTo)
    {
      BOOL v33 = objc_autoreleasePoolPush();
      if (qword_100219F60) {
        [(id)qword_100219F60 WFLog:3, "%s: client %@ calling APPLE80211KEY_MWS_BT_CONNECTION_REPORT", "_wifi_device_set_coex_parameters", sub_10003BEDC((uint64_t)v18) message];
      }
      objc_autoreleasePoolPop(v33);
      sub_1000D7248(v25, v23);
      goto LABEL_28;
    }

    uint64_t v27 = sub_1000AF278(v21);
    if ((_DWORD)v27)
    {
      uint64_t v28 = v27;
      uint64_t v29 = sub_10003BEDC(v25);
      sub_10003EC6C(v29, v20, v28, 0LL, (uint64_t)v23);
    }

    else
    {
LABEL_17:
      uint64_t v30 = sub_10003BEDC(v25);
      *a8 = sub_1000447A8(v30, v20, v21, (uint64_t)v23);
    }

uint64_t sub_1000B4168( unsigned int a1, UInt8 *a2, unsigned int a3, vm_offset_t *a4, mach_msg_type_number_t *a5)
{
  int valuePtr = 0;
  *a4 = 0LL;
  *a5 = 0;
  uint64_t v10 = sub_10003B8D0();
  CFMutableArrayRef v11 = sub_10009137C(a1, v10);
  if (v11)
  {
    CFMutableArrayRef v12 = v11;
    uint64_t v13 = objc_autoreleasePoolPush();
    if (qword_100219F60) {
      [(id)qword_100219F60 WFLog:3, "Copy current network requested by %@", sub_10003BEDC((uint64_t)v12) message];
    }
    objc_autoreleasePoolPop(v13);
    if ((sub_10003BEEC((uint64_t)v12) & 1) == 0)
    {
      uint64_t v14 = objc_autoreleasePoolPush();
      if (qword_100219F60) {
        [(id)qword_100219F60 WFLog:4, "%s Client %@ has no entitlement", "kern_return_t _wifi_device_copy_current_network(mach_port_t, vm_offset_t, mach_msg_type_number_t, vm_offset_t *, mach_msg_type_number_t *)", sub_10003BEDC((uint64_t)v12) message];
      }
      objc_autoreleasePoolPop(v14);
      goto LABEL_26;
    }

    uint64_t v15 = (const __CFDictionary *)sub_10003A7C0(a2, a3);
    if (!v15)
    {
LABEL_26:
      CFRelease(v12);
      goto LABEL_27;
    }

    CFDictionaryRef v16 = v15;
    uint64_t v17 = sub_10003C078((uint64_t)v12, v15);
    if (!v17 || (CFPropertyListRef v18 = sub_1000D3348((uint64_t)v17, v16)) == 0LL)
    {
      CFDictionaryRef v26 = v16;
LABEL_25:
      CFRelease(v26);
      goto LABEL_26;
    }

    CFPropertyListRef v19 = v18;
    if (sub_100095B4C((uint64_t)v18))
    {
      if ((sub_10003BEEC((uint64_t)v12) & 0x11) == 1)
      {
        if (!sub_10003E1B8((uint64_t)v12, @"com.apple.wifi.eap-nearby-device-setup-config-copy"))
        {
          CFTypeID v23 = objc_autoreleasePoolPush();
          if (qword_100219F60) {
            [(id)qword_100219F60 WFLog:4, "%s Client %@ is not entitled for EAPNearbySetup", "kern_return_t _wifi_device_copy_current_network(mach_port_t, vm_offset_t, mach_msg_type_number_t, vm_offse t_t *, mach_msg_type_number_t *)", sub_10003BEDC((uint64_t)v12) message];
          }
          objc_autoreleasePoolPop(v23);
          goto LABEL_22;
        }

        sub_10003BA54((uint64_t)v12, 17);
      }

      int valuePtr = sub_1000F08B0(v19);
      if (valuePtr == 1 && !sub_1000F0918(v19))
      {
        int valuePtr = 4;
        Default = CFAllocatorGetDefault();
        CFNumberRef v21 = CFNumberCreate(Default, kCFNumberIntType, &valuePtr);
        if (v21)
        {
          CFNumberRef v22 = v21;
          sub_10009582C((uint64_t)v19, @"ShareableStatus", v21);
          CFRelease(v22);
        }
      }
    }

uint64_t sub_1000B43E0(unsigned int a1, UInt8 *a2, unsigned int a3)
{
  uint64_t v6 = sub_10003B8D0();
  char v7 = sub_10009137C(a1, v6);
  if (v7)
  {
    uint64_t v8 = v7;
    if ((sub_10003BEEC((uint64_t)v7) & 1) != 0)
    {
      CFPropertyListRef v10 = sub_10003A7C0(a2, a3);
      if (v10)
      {
        CFMutableArrayRef v11 = v10;
        CFMutableArrayRef v12 = sub_10003C078((uint64_t)v8, v10);
        if (v12)
        {
          uint64_t v13 = (uint64_t)v12;
          uint64_t v14 = objc_autoreleasePoolPush();
          if (qword_100219F60) {
            [(id)qword_100219F60 WFLog:3, "Disassociation requested by %@", sub_10003BEDC((uint64_t)v8) message];
          }
          objc_autoreleasePoolPop(v14);
          sub_1000CE074(v13, v11, 1001LL, "_wifi_device_disassociate", 2900LL);
        }

        CFRelease(v11);
      }
    }

    else
    {
      uint64_t v9 = objc_autoreleasePoolPush();
      if (qword_100219F60) {
        [(id)qword_100219F60 WFLog:4, "%s Client %@ has no entitlement", "kern_return_t _wifi_device_disassociate(mach_port_t, vm_offset_t, mach_msg_type_number_t)", sub_10003BEDC((uint64_t)v8) message];
      }
      objc_autoreleasePoolPop(v9);
    }

    CFRelease(v8);
  }

  sub_10003A8FC((vm_address_t)a2, a3);
  return 0LL;
}

uint64_t sub_1000B4534(unsigned int a1, UInt8 *a2, unsigned int a3, int a4)
{
  uint64_t v8 = sub_10003B8D0();
  uint64_t v9 = sub_10009137C(a1, v8);
  if (v9)
  {
    CFPropertyListRef v10 = v9;
    if ((sub_10003BEEC((uint64_t)v9) & 1) != 0)
    {
      CFPropertyListRef v12 = sub_10003A7C0(a2, a3);
      if (v12)
      {
        uint64_t v13 = v12;
        uint64_t v14 = sub_10003C078((uint64_t)v10, v12);
        if (v14)
        {
          uint64_t v15 = (uint64_t)v14;
          CFDictionaryRef v16 = objc_autoreleasePoolPush();
          if (qword_100219F60) {
            [(id)qword_100219F60 WFLog:3, "Disassociation requested by %@", sub_10003BEDC((uint64_t)v10) message];
          }
          objc_autoreleasePoolPop(v16);
          if (a4 == 2) {
            unsigned int v17 = 1015;
          }
          else {
            unsigned int v17 = 1001;
          }
          if (a4 == 1) {
            uint64_t v18 = 1011LL;
          }
          else {
            uint64_t v18 = v17;
          }
          sub_1000CE074(v15, v13, v18, "_wifi_device_disassociate_with_reason", 2946LL);
        }

        CFRelease(v13);
      }
    }

    else
    {
      CFMutableArrayRef v11 = objc_autoreleasePoolPush();
      if (qword_100219F60) {
        [(id)qword_100219F60 WFLog:4, "%s Client %@ has no entitlement", "kern_return_t _wifi_device_disassociate_with_reason(mach_port_t, vm_offset_t, mach_msg_type_number_t, int)", sub_10003BEDC((uint64_t)v10) message];
      }
      objc_autoreleasePoolPop(v11);
    }

    CFRelease(v10);
  }

  sub_10003A8FC((vm_address_t)a2, a3);
  return 0LL;
}

uint64_t sub_1000B46A4(unsigned int a1, UInt8 *a2, unsigned int a3, UInt8 *a4, unsigned int a5, _DWORD *a6)
{
  uint64_t valuePtr = 0LL;
  uint64_t v118 = 0LL;
  int v115 = 1;
  int v116 = 0;
  *a6 = -3900;
  uint64_t v12 = sub_10003B8D0();
  uint64_t v13 = sub_10009137C(a1, v12);
  if (!v13) {
    goto LABEL_142;
  }
  uint64_t v14 = v13;
  if ((sub_10003BEEC((uint64_t)v13) & 1) == 0)
  {
    uint64_t v15 = objc_autoreleasePoolPush();
    if (qword_100219F60) {
      [(id)qword_100219F60 WFLog:4, "%s Client %@ has no entitlement", "kern_return_t _wifi_device_scan_async(mach_port_t, vm_offset_t, mach_msg_type_number_t, vm_offset_t, mach_msg_ty pe_number_t, int *)", sub_10003BEDC((uint64_t)v14) message];
    }
    objc_autoreleasePoolPop(v15);
    goto LABEL_141;
  }

  CFPropertyListRef v16 = sub_10003A7C0(a2, a3);
  unsigned int v17 = (const __CFDictionary *)sub_10003A7C0(a4, a5);
  uint64_t v18 = v17;
  if (!v16 || !v17) {
    goto LABEL_137;
  }
  uint64_t v110 = sub_10003C078((uint64_t)v14, v16);
  if (!v110)
  {
    __int128 v99 = objc_autoreleasePoolPush();
    if (qword_100219F60) {
      [(id)qword_100219F60 WFLog:4, "%s: unable to find device manager for interface %@", "_wifi_device_scan_async", v16 message];
    }
    objc_autoreleasePoolPop(v99);
    goto LABEL_138;
  }

  CFBooleanRef Value = (const __CFNumber *)CFDictionaryGetValue(v18, @"SCAN_MAXAGE");
  if (Value) {
    CFNumberGetValue(Value, kCFNumberSInt32Type, (char *)&valuePtr + 4);
  }
  CFPropertyListRef v20 = (const __CFNumber *)CFDictionaryGetValue(v18, @"SCAN_NUM_SCANS");
  if (v20) {
    CFNumberGetValue(v20, kCFNumberCFIndexType, &v118);
  }
  CFNumberRef v21 = (const __CFNumber *)CFDictionaryGetValue(v18, @"SCAN_LOW_PRIORITY");
  if (v21) {
    CFNumberGetValue(v21, kCFNumberCFIndexType, &valuePtr);
  }
  CFNumberRef v22 = (const __CFNumber *)CFDictionaryGetValue(v18, @"SCAN_LOW_LATENCY");
  if (v22) {
    CFNumberGetValue(v22, kCFNumberCFIndexType, &v116);
  }
  theDict = v18;
  CFTypeID v23 = CFDictionaryGetValue(v18, @"SSID_STR");
  CFDictionaryRef v24 = objc_autoreleasePoolPush();
  CFDictionaryRef v25 = (void *)qword_100219F60;
  if (v23)
  {
    if (qword_100219F60)
    {
      uint64_t v26 = sub_10003BEDC((uint64_t)v14);
      uint64_t v27 = "low";
      if ((_DWORD)valuePtr) {
        uint64_t v28 = "low";
      }
      else {
        uint64_t v28 = "normal";
      }
      if (!v116) {
        uint64_t v27 = "normal";
      }
      [v25 WFLog:3, "Async directed scan for %@ requested by %@ for %ld iterations with maxage=%d priority %s and latency %s on %@", v23, v26, v118, HIDWORD(valuePtr), v28, v27, v16 message];
    }
  }

  else if (qword_100219F60)
  {
    uint64_t v29 = sub_10003BEDC((uint64_t)v14);
    uint64_t v30 = "low";
    if ((_DWORD)valuePtr) {
      int v31 = "low";
    }
    else {
      int v31 = "normal";
    }
    if (!v116) {
      uint64_t v30 = "normal";
    }
    [v25 WFLog:3, "Async scan requested by %@ for %ld iterations with maxage=%d priority %s and latency %s on %@", v29, v118, HIDWORD(valuePtr), v31, v30, v16, v101 message];
  }

  objc_autoreleasePoolPop(v24);
  *a6 = 0;
  int v32 = sub_10003C0CC((uint64_t)v14);
  if ((v32 & 1) != 0)
  {
    CFStringRef v42 = objc_autoreleasePoolPush();
    uint64_t v18 = theDict;
    if (qword_100219F60) {
      objc_msgSend((id)qword_100219F60, "WFLog:message:", 4, "Already scanning, will not queue request. ");
    }
    objc_autoreleasePoolPop(v42);
    sub_10003C424((uint64_t)v14, (uint64_t)v110, v16, 0LL, 37);
    goto LABEL_138;
  }

  int v33 = v32;
  uint64_t v18 = theDict;
  MutableCFDictionaryRef Copy = CFDictionaryCreateMutableCopy(kCFAllocatorDefault, 0LL, theDict);
  if (!MutableCopy)
  {
    *a6 = -3901;
    goto LABEL_138;
  }

  CFIndex v35 = MutableCopy;
  int v104 = v33;
  v108 = a6;
  CFStringRef v36 = (const __CFArray *)CFDictionaryGetValue(theDict, @"SCAN_CHANNELS");
  uint64_t v107 = v35;
  unsigned int v106 = a3;
  uint64_t v105 = v16;
  if (!v36 || (unsigned int v37 = v36, CFArrayGetCount(v36) < 1))
  {
    id v43 = objc_autoreleasePoolPush();
    if (qword_100219F60) {
      [(id)qword_100219F60 WFLog:3, "%s: Scan Requested with Empty Channels List (Scan all channels!) by %@ \n", "_wifi_device_scan_async", sub_10003BEDC((uint64_t)v14) message];
    }
    objc_autoreleasePoolPop(v43);
    if (sub_10003BEDC((uint64_t)v14))
    {
      int v44 = (const __CFString *)sub_10003BEDC((uint64_t)v14);
      CFComparisonResult v45 = CFStringCompare(v44, @"WirelessStress", 0LL);
      id v46 = (const __CFString *)sub_10003BEDC((uint64_t)v14);
      if (CFStringCompare(v46, @"coreautomationd", 0LL) == kCFCompareEqualTo
        || (theArray = 0LL, v109 = 0LL, v113 = 0LL, v45 == kCFCompareEqualTo))
      {
        v103 = a4;
        CFMutableDictionaryRef Mutable = CFArrayCreateMutable(kCFAllocatorDefault, 0LL, &kCFTypeArrayCallBacks);
        CFMutableArrayRef v48 = CFArrayCreateMutable(kCFAllocatorDefault, 0LL, &kCFTypeArrayCallBacks);
        theArray = Mutable;
        v113 = v48;
        if (!Mutable || !v48)
        {
          v109 = 0LL;
          _DWORD *v108 = -3902;
          goto LABEL_130;
        }

        if (sub_1000E10D0((uint64_t)v110, Mutable))
        {
          _DWORD *v108 = -3902;
          v100 = objc_autoreleasePoolPush();
          if (qword_100219F60) {
            [qword_100219F60 WFLog:@"Error - Device failed to return supported channels! \n"];
          }
          objc_autoreleasePoolPop(v100);
          v109 = 0LL;
          uint64_t v18 = theDict;
          BOOL v41 = Mutable;
          goto LABEL_131;
        }

        if (CFArrayGetCount(Mutable) >= 1)
        {
          CFIndex v49 = 0LL;
          do
          {
            ValueAtIndex = (const __CFDictionary *)CFArrayGetValueAtIndex(Mutable, v49);
            if (ValueAtIndex)
            {
              id v51 = ValueAtIndex;
              id v52 = CFDictionaryGetValue(ValueAtIndex, @"SUP_CHANNEL");
              if (v52)
              {
                id v53 = v52;
                uint64_t v54 = CFDictionaryGetValue(v51, @"SUP_CHANNEL_FLAGS");
                if (v54)
                {
                  CFMutableArrayRef v55 = v54;
                  uint64_t v56 = CFDictionaryCreateMutable( kCFAllocatorDefault,  0LL,  &kCFTypeDictionaryKeyCallBacks,  &kCFTypeDictionaryValueCallBacks);
                  if (!v56)
                  {
                    v109 = 0LL;
                    _DWORD *v108 = -3901;
                    a4 = v103;
                    goto LABEL_148;
                  }

                  CFIndex v57 = v56;
                  CFDictionaryAddValue(v56, @"CHANNEL", v53);
                  CFDictionaryAddValue(v57, @"CHANNEL_FLAGS", v55);
                  CFArrayAppendValue(v113, v57);
                  CFRelease(v57);
                }
              }
            }

            ++v49;
            CFMutableDictionaryRef Mutable = theArray;
          }

          while (CFArrayGetCount(theArray) > v49);
        }

        CFDictionarySetValue(v35, @"SCAN_CHANNELS", v113);
        v109 = 0LL;
        a4 = v103;
        goto LABEL_89;
      }
    }

    else
    {
      theArray = 0LL;
      v109 = 0LL;
      v113 = 0LL;
    }

void sub_1000B5420(uint64_t a1, const void *a2, const __CFArray *a3, uint64_t a4, const void *a5)
{
  int v10 = sub_10003C0CC((uint64_t)a5);
  CFMutableArrayRef v11 = objc_autoreleasePoolPush();
  uint64_t v12 = (void *)qword_100219F60;
  if (qword_100219F60)
  {
    uint64_t v13 = sub_10003BEDC((uint64_t)a5);
    if (a3) {
      CFIndex Count = CFArrayGetCount(a3);
    }
    else {
      CFIndex Count = 0LL;
    }
    [v12 WFLog:3, "Async scan request completed for %@ (%d), found %ld networks", v13, a4, Count message];
  }

  objc_autoreleasePoolPop(v11);
  if (_os_feature_enabled_impl("CoreWiFi", "WiFi6EMaxCompatibility"))
  {
    uint64_t v15 = (const __CFString *)sub_10003BEDC((uint64_t)a5);
    if (CFStringCompare(v15, @"configd", 0LL) == kCFCompareEqualTo
      && (~sub_10003C0DC((uint64_t)a5) & 3) == 0)
    {
      sub_1000DA75C(a1, a3);
    }
  }

  sub_10003C424((uint64_t)a5, a1, a2, a3, a4);
  sub_10003C0D4((uint64_t)a5, v10 & 0xFFFFFFFE);
  if (a5)
  {
    if ((v10 & 1) != 0) {
      CFRelease(a5);
    }
  }

uint64_t sub_1000B5580(unsigned int a1, UInt8 *a2, unsigned int a3, UInt8 *a4, unsigned int a5, _DWORD *a6)
{
  *a6 = 0;
  uint64_t v12 = sub_10003B8D0();
  uint64_t v13 = sub_10009137C(a1, v12);
  if (v13)
  {
    uint64_t v14 = v13;
    if ((sub_10003BEEC((uint64_t)v13) & 1) == 0)
    {
      uint64_t v15 = objc_autoreleasePoolPush();
      if (qword_100219F60) {
        [(id)qword_100219F60 WFLog:4, "%s Client %@ has no entitlement", "kern_return_t _wifi_device_assoc_async(mach_port_t, vm_offset_t, mach_msg_type_number_t, vm_offset_t, mach_msg _type_number_t, int *)", sub_10003BEDC((uint64_t)v14) message];
      }
      objc_autoreleasePoolPop(v15);
      *a6 = 1;
      goto LABEL_31;
    }

    CFPropertyListRef v16 = sub_10003A7C0(a2, a3);
    CFPropertyListRef v17 = sub_10003A7C0(a4, a5);
    uint64_t v18 = v17;
    if (!v16 || !v17)
    {
      if (v16) {
        CFRelease(v16);
      }
      if (!v18) {
        goto LABEL_31;
      }
      goto LABEL_30;
    }

    CFPropertyListRef v19 = sub_10003C078((uint64_t)v14, v16);
    if (!v19 || (CFPropertyListRef v20 = v19, (v21 = (const __CFData *)sub_100094AAC((uint64_t)kCFAllocatorDefault, v18)) == 0LL))
    {
      CFNumberRef v22 = (const __CFData *)v16;
      goto LABEL_29;
    }

    CFNumberRef v22 = v21;
    uint64_t v34 = a4;
    CFTypeID v23 = objc_autoreleasePoolPush();
    if (qword_100219F60) {
      [(id)qword_100219F60 WFLog:3, "Async association requested by %@", sub_10003BEDC((uint64_t)v14) message];
    }
    objc_autoreleasePoolPop(v23);
    int v24 = sub_10003C0CC((uint64_t)v14);
    if ((v24 & 2) != 0)
    {
      uint64_t v29 = objc_autoreleasePoolPush();
      if (qword_100219F60) {
        objc_msgSend((id)qword_100219F60, "WFLog:message:", 4, "Already associating, will not queue request. ");
      }
      objc_autoreleasePoolPop(v29);
      sub_10003C570((uint64_t)v14, v20, (const __CFData *)v16, v22, 0LL, 37);
      goto LABEL_28;
    }

    int v25 = v24;
    sub_10003C0D4((uint64_t)v14, v24 | 2);
    sub_1000D0428((uint64_t)v20);
    sub_1000D03E4((uint64_t)v20);
    if (sub_10003BEDC((uint64_t)v14))
    {
      uint64_t v26 = (const void *)sub_10003BEDC((uint64_t)v14);
      int v27 = CFEqual(v26, @"mobilewifitool");
      if (_os_feature_enabled_impl("WiFiManager", "FindAndJoinNetworkAPI")
        && v27
        && sub_10003E1B8((uint64_t)v14, @"com.apple.wifi.manager-assoc-find-and-join-network"))
      {
        uint64_t v28 = sub_1000E4698((uint64_t)v20, (uint64_t)v16, v22, 0LL, (uint64_t)sub_1000B58D4, (uint64_t)v14);
        goto LABEL_23;
      }
    }

    else
    {
      _os_feature_enabled_impl("WiFiManager", "FindAndJoinNetworkAPI");
    }

    uint64_t v30 = (const __CFString *)sub_10003BEDC((uint64_t)v14);
    uint64_t v28 = sub_1000E1104((uint64_t)v20, v16, v22, 0LL, v30, (uint64_t)sub_1000B58D4, (uint64_t)v14, 1008LL);
LABEL_23:
    uint64_t v31 = v28;
    if ((_DWORD)v28)
    {
      int v32 = objc_autoreleasePoolPush();
      if (qword_100219F60) {
        [qword_100219F60 WFLog:@"Error returned by Associate Async %d" message:4];
      }
      objc_autoreleasePoolPop(v32);
      sub_10003C0D4((uint64_t)v14, v25 & 0xFFFFFFFD);
    }

    else
    {
      CFRetain(v14);
    }

void sub_1000B58D4( const void *a1, const __CFData *a2, const __CFData *a3, const __CFData *a4, uint64_t a5, const void *a6)
{
  int v12 = sub_10003C0CC((uint64_t)a6);
  uint64_t v13 = objc_autoreleasePoolPush();
  if (qword_100219F60) {
    [(id)qword_100219F60 WFLog:3, "Async association request completed for %@ (%d)", sub_10003BEDC((uint64_t)a6), a5 message];
  }
  objc_autoreleasePoolPop(v13);
  sub_1000D02BC((uint64_t)a1);
  sub_10003C570((uint64_t)a6, a1, a2, a3, a4, a5);
  sub_10003C0D4((uint64_t)a6, v12 & 0xFFFFFFFD);
  if (a6)
  {
    if ((v12 & 2) != 0) {
      CFRelease(a6);
    }
  }

uint64_t sub_1000B59D4(unsigned int a1, UInt8 *a2, unsigned int a3, _DWORD *a4)
{
  *a4 = 0;
  uint64_t v8 = sub_10003B8D0();
  uint64_t v9 = sub_10009137C(a1, v8);
  if (v9)
  {
    int v10 = v9;
    if ((sub_10003BEEC((uint64_t)v9) & 1) != 0)
    {
      CFPropertyListRef v12 = sub_10003A7C0(a2, a3);
      if (v12)
      {
        uint64_t v13 = v12;
        uint64_t v14 = sub_10003C078((uint64_t)v10, v12);
        if (v14)
        {
          uint64_t v15 = (uint64_t)v14;
        }

        CFRelease(v13);
      }
    }

    else
    {
      CFMutableArrayRef v11 = objc_autoreleasePoolPush();
      if (qword_100219F60) {
        [(id)qword_100219F60 WFLog:4, "%s Client %@ has no entitlement", "kern_return_t _wifi_device_get_power(mach_port_t, vm_offset_t, mach_msg_type_number_t, int *)", sub_10003BEDC((uint64_t)v10) message];
      }
      objc_autoreleasePoolPop(v11);
    }

    CFRelease(v10);
  }

  sub_10003A8FC((vm_address_t)a2, a3);
  return 0LL;
}

uint64_t sub_1000B5AE8(unsigned int a1, UInt8 *a2, unsigned int a3, uint64_t a4, _DWORD *a5)
{
  *a5 = 0;
  uint64_t v10 = sub_10003B8D0();
  CFMutableArrayRef v11 = sub_10009137C(a1, v10);
  if (v11)
  {
    CFPropertyListRef v12 = v11;
    if ((sub_10003BEEC((uint64_t)v11) & 1) != 0)
    {
      CFPropertyListRef v14 = sub_10003A7C0(a2, a3);
      if (v14)
      {
        uint64_t v15 = v14;
        CFPropertyListRef v16 = sub_10003C078((uint64_t)v12, v14);
        if (v16)
        {
          uint64_t v17 = (uint64_t)v16;
          uint64_t v18 = objc_autoreleasePoolPush();
          if (qword_100219F60)
          {
            if ((_DWORD)a4) {
              CFPropertyListRef v19 = "ON";
            }
            else {
              CFPropertyListRef v19 = "OFF";
            }
            [(id)qword_100219F60 WFLog:3, "Device power %s requested by %@", v19, sub_10003BEDC((uint64_t)v12) message];
          }

          objc_autoreleasePoolPop(v18);
          uint64_t v20 = sub_1000DDE04(v17, v15, a4);
          if ((_DWORD)v20)
          {
            uint64_t v21 = v20;
            CFNumberRef v22 = objc_autoreleasePoolPush();
            if (qword_100219F60) {
              objc_msgSend( (id)qword_100219F60,  "WFLog:message:",  4,  "Unable to set power state(%d) to %d. deviceManager=%p",  v21,  a4,  v17);
            }
            objc_autoreleasePoolPop(v22);
          }
        }

        CFRelease(v15);
      }
    }

    else
    {
      uint64_t v13 = objc_autoreleasePoolPush();
      if (qword_100219F60) {
        [(id)qword_100219F60 WFLog:4, "%s Client %@ has no entitlement", "kern_return_t _wifi_device_set_power(mach_port_t, vm_offset_t, mach_msg_type_number_t, int, int *)", sub_10003BEDC((uint64_t)v12) message];
      }
      objc_autoreleasePoolPop(v13);
      *a5 = 1;
    }

    CFRelease(v12);
  }

  sub_10003A8FC((vm_address_t)a2, a3);
  return 0LL;
}

uint64_t sub_1000B5C9C( unsigned int a1, UInt8 *a2, unsigned int a3, uint64_t a4, UInt8 *a5, unsigned int a6, _DWORD *a7)
{
  *a7 = 0;
  uint64_t v14 = sub_10003B8D0();
  uint64_t v15 = sub_10009137C(a1, v14);
  if (!v15)
  {
    *a7 = 74;
    goto LABEL_53;
  }

  CFPropertyListRef v16 = v15;
  if ((sub_10003BEEC((uint64_t)v15) & 1) != 0)
  {
    uint64_t v18 = (const __CFString *)sub_10003A7C0(a2, a3);
    CFPropertyListRef v19 = (const __CFDictionary *)sub_10003A7C0(a5, a6);
    uint64_t v20 = v19;
    if (!v18 || (_DWORD)a4 != 4 && !v19)
    {
      *a7 = 72;
      goto LABEL_48;
    }

    CFIndex v49 = sub_10003C078((uint64_t)v16, v18);
    if (v49)
    {
      theDict = v20;
      if ((_DWORD)a4 == 4)
      {
        kdebug_trace(731381784LL, 0LL, 0LL, 0LL, 0LL);
        uint64_t v21 = objc_autoreleasePoolPush();
        if (qword_100219F60) {
          [(id)qword_100219F60 WFLog:4, "%@ starting AWDL", sub_10003BEDC((uint64_t)v16), v45 message];
        }
      }

      else
      {
        uint64_t v21 = objc_autoreleasePoolPush();
        if (qword_100219F60) {
          [(id)qword_100219F60 WFLog:3, "%@ starting network role (%d)", sub_10003BEDC((uint64_t)v16), a4 message];
        }
      }

      objc_autoreleasePoolPop(v21);
      int v22 = sub_10003C0CC((uint64_t)v16);
      if ((v22 & 8) == 0)
      {
        int v23 = v22;
        unsigned int v46 = a6;
        uint64_t v47 = a5;
        int v24 = (const __CFArray *)sub_10003C0F4((uint64_t)v16);
        if (v24)
        {
          int v25 = v24;
          if (CFArrayGetCount(v24))
          {
            if (CFArrayGetCount(v25) >= 1)
            {
              CFIndex v26 = 0LL;
              while (1)
              {
                ValueAtIndex = CFArrayGetValueAtIndex(v25, v26);
                if (ValueAtIndex)
                {
                  uint64_t v28 = (uint64_t)ValueAtIndex;
                }

                if (++v26 >= CFArrayGetCount(v25)) {
                  goto LABEL_23;
                }
              }

              int v44 = objc_autoreleasePoolPush();
              if (qword_100219F60) {
                [(id)qword_100219F60 WFLog:3, "%s: client %@ has already brought up network of role %ld", "_wifi_device_start_network", sub_10003BEDC((uint64_t)v16), (int)a4 message];
              }
              objc_autoreleasePoolPop(v44);
              sub_10003C754((uint64_t)v16, (uint64_t)v49, v18, 37, v28, 0LL);
              a5 = v47;
              uint64_t v20 = theDict;
              a6 = v46;
LABEL_48:
              if (!v18) {
                goto LABEL_50;
              }
              goto LABEL_49;
            }
          }
        }

void sub_1000B6264( uint64_t a1, const void *a2, uint64_t a3, const void *a4, const __CFData *a5, const void *a6)
{
  if (a6) {
    int v12 = sub_10003C0CC((uint64_t)a6) & 0xFFFFFFF7;
  }
  else {
    int v12 = 0;
  }
  uint64_t v13 = objc_autoreleasePoolPush();
  if ((_DWORD)a3)
  {
    if (qword_100219F60) {
      [(id)qword_100219F60 WFLog:3, "Failed to start network requested by %@, %d", sub_10003BEDC((uint64_t)a6), a3 message];
    }
    objc_autoreleasePoolPop(v13);
    if (a4 && ((unint64_t)sub_100096BF4((uint64_t)a4, @"networkRole") & 0xFFFFFFFFFFFFFFFELL) == 2)
    {
      uint64_t v14 = (void *)sub_10003BEDC((uint64_t)a6);
      sub_1000DD024(a1, 0, 0, 0, v14);
      sub_1000DC9E4(a1, 0);
      sub_1000CF880(a1, 4, 0);
    }
  }

  else
  {
    if (qword_100219F60) {
      [(id)qword_100219F60 WFLog:3, "Started network %@ requested by %@", a4, sub_10003BEDC((uint64_t)a6) message];
    }
    objc_autoreleasePoolPop(v13);
    uint64_t v15 = (const __CFArray *)sub_10003C0F4((uint64_t)a6);
    if (v15)
    {
      MutableCFDictionaryRef Copy = CFArrayCreateMutableCopy(kCFAllocatorDefault, 0LL, v15);
      if (MutableCopy)
      {
        uint64_t v17 = MutableCopy;
        CFArrayAppendValue(MutableCopy, a4);
        sub_10003C168((uint64_t)a6, v17);
        CFRelease(v17);
      }

      else
      {
        sub_10003C168((uint64_t)a6, 0LL);
      }
    }
  }

  sub_10003C0D4((uint64_t)a6, v12);
  sub_10003C754((uint64_t)a6, a1, a2, a3, (uint64_t)a4, a5);
  if (a6) {
    CFRelease(a6);
  }
}

uint64_t sub_1000B6450(unsigned int a1, UInt8 *a2, unsigned int a3, UInt8 *a4, unsigned int a5, int *a6)
{
  *a6 = 0;
  uint64_t v12 = sub_10003B8D0();
  uint64_t v13 = sub_10009137C(a1, v12);
  if (!v13)
  {
    *a6 = 74;
    goto LABEL_30;
  }

  uint64_t v14 = v13;
  if ((sub_10003BEEC((uint64_t)v13) & 1) != 0)
  {
    unsigned int v45 = a3;
    CFPropertyListRef v16 = sub_10003A7C0(a2, a3);
    CFPropertyListRef v17 = sub_10003A7C0(a4, a5);
    uint64_t v18 = v17;
    if (!v16 || !v17)
    {
      int v22 = 0LL;
      *a6 = 72;
      if (!v16) {
        goto LABEL_25;
      }
      goto LABEL_24;
    }

    id v43 = a2;
    unsigned int v44 = a5;
    CFPropertyListRef v19 = sub_10003C078((uint64_t)v14, v16);
    if (v19)
    {
      uint64_t v20 = (uint64_t)v19;
      uint64_t v21 = sub_100094AAC((uint64_t)kCFAllocatorDefault, v18);
      if (v21)
      {
        int v22 = v21;
        CFStringRef v42 = a4;
        int v23 = objc_autoreleasePoolPush();
        int v24 = (void *)qword_100219F60;
        if (qword_100219F60)
        {
          uint64_t v25 = sub_10003BEDC((uint64_t)v14);
          [v24 WFLog:3, "%@ stopping network %@", v25, sub_100095BC8(v22) message];
        }

        objc_autoreleasePoolPop(v23);
        CFIndex v26 = (const __CFArray *)sub_10003C0F4((uint64_t)v14);
        if (v26 && (int v27 = v26, CFArrayGetCount(v26) >= 1))
        {
          CFIndex v28 = 0LL;
          while (1)
          {
            ValueAtIndex = CFArrayGetValueAtIndex(v27, v28);
            if (ValueAtIndex)
            {
              uint64_t v30 = ValueAtIndex;
              if (CFEqual(ValueAtIndex, v22)) {
                break;
              }
            }

            if (++v28 >= CFArrayGetCount(v27)) {
              goto LABEL_18;
            }
          }

          CFComparisonResult v35 = objc_autoreleasePoolPush();
          if (qword_100219F60)
          {
            BOOL v40 = (void *)qword_100219F60;
            uint64_t context = v35;
            CFMutableArrayRef v39 = sub_100095BC8(v30);
            [v40 WFLog:3, "%s: removing network %@ for client %@ started network list.", "_wifi_device_stop_network", v39, sub_10003BEDC((uint64_t)v14) message];
            CFComparisonResult v35 = context;
          }

          objc_autoreleasePoolPop(v35);
          uint64_t v31 = sub_100096BF4((uint64_t)v30, @"networkRole");
          MutableCFDictionaryRef Copy = CFArrayCreateMutableCopy(kCFAllocatorDefault, 0LL, v27);
          if (MutableCopy)
          {
            unsigned int v37 = MutableCopy;
            CFArrayRemoveValueAtIndex(MutableCopy, v28);
            sub_10003C168((uint64_t)v14, v37);
            CFRelease(v37);
          }

          else
          {
            sub_10003C168((uint64_t)v14, 0LL);
          }
        }

        else
        {
LABEL_18:
          uint64_t v31 = 0LL;
        }

        int v32 = sub_1000E5F48(v20, v16, v22, (uint64_t)sub_1000B67F8, (uint64_t)v14);
        *a6 = v32;
        a4 = v42;
        if (!v32)
        {
          if (((unint64_t)v31 & 0xFFFFFFFFFFFFFFFELL) == 2)
          {
            int v33 = (void *)sub_10003BEDC((uint64_t)v14);
            sub_1000DD024(v20, 0, 0, 0, v33);
            sub_1000DC9E4(v20, 0);
            sub_1000CF880(v20, 4, 0);
          }

          CFRetain(v14);
        }

        a5 = v44;
        a2 = v43;
        goto LABEL_24;
      }

      int v38 = 72;
    }

    else
    {
      int v38 = 74;
    }

    int v22 = 0LL;
    *a6 = v38;
    a2 = v43;
LABEL_24:
    CFRelease(v16);
LABEL_25:
    if (v22) {
      CFRelease(v22);
    }
    a3 = v45;
    if (v18) {
      CFRelease(v18);
    }
    goto LABEL_29;
  }

  uint64_t v15 = objc_autoreleasePoolPush();
  if (qword_100219F60) {
    [(id)qword_100219F60 WFLog:4, "%s Client %@ has no entitlement", "kern_return_t _wifi_device_stop_network(mach_port_t, vm_offset_t, mach_msg_type_number_t, vm_offset_t, mach_msg_ty pe_number_t, int *)", sub_10003BEDC((uint64_t)v14) message];
  }
  objc_autoreleasePoolPop(v15);
  *a6 = 1;
LABEL_29:
  CFRelease(v14);
LABEL_30:
  sub_10003A8FC((vm_address_t)a2, a3);
  sub_10003A8FC((vm_address_t)a4, a5);
  return 0LL;
}

void sub_1000B67F8(uint64_t a1, const void *a2, int a3, const __CFData *a4, const void *a5)
{
  if (a5) {
    CFRelease(a5);
  }
}

uint64_t sub_1000B6840( unsigned int a1, UInt8 *a2, unsigned int a3, uint64_t a4, vm_offset_t *a5, mach_msg_type_number_t *a6, int *a7)
{
  *a5 = 0LL;
  *a6 = 0;
  *a7 = 0;
  uint64_t v13 = sub_10003B8D0();
  uint64_t v14 = sub_10009137C(a1, v13);
  if (!v14)
  {
    *a7 = 74;
    goto LABEL_12;
  }

  uint64_t v15 = v14;
  if ((sub_10003BEEC((uint64_t)v14) & 1) == 0)
  {
    CFPropertyListRef v16 = objc_autoreleasePoolPush();
    if (qword_100219F60) {
      [(id)qword_100219F60 WFLog:4, "%s Client %@ has no entitlement", "kern_return_t _wifi_device_copy_interface_state_info(mach_port_t, vm_offset_t, mach_msg_type_number_t, int, vm_o ffset_t *, mach_msg_type_number_t *, int *)", sub_10003BEDC((uint64_t)v15) message];
    }
    objc_autoreleasePoolPop(v16);
    *a7 = 1;
    goto LABEL_11;
  }

  CFPropertyListRef v17 = (const __CFString *)sub_10003A7C0(a2, a3);
  if (v17)
  {
    uint64_t v18 = v17;
    CFPropertyListRef v19 = sub_10003C078((uint64_t)v15, v17);
    if (v19)
    {
      uint64_t v20 = sub_1000DF0C8((uint64_t)v19, v18);
      if (v20)
      {
        uint64_t v21 = v20;
        sub_10003A920(v20, a5, a6);
        CFRelease(v18);
        int v22 = (const __CFString *)v21;
LABEL_10:
        CFRelease(v22);
        goto LABEL_11;
      }

      int v24 = 5;
    }

    else
    {
      int v24 = 74;
    }

    *a7 = v24;
    int v22 = v18;
    goto LABEL_10;
  }

uint64_t sub_1000B699C( unsigned int a1, UInt8 *a2, unsigned int a3, uint64_t a4, vm_offset_t *a5, mach_msg_type_number_t *a6, int *a7)
{
  *a5 = 0LL;
  *a6 = 0;
  *a7 = 0;
  uint64_t v13 = sub_10003B8D0();
  uint64_t v14 = sub_10009137C(a1, v13);
  if (!v14)
  {
    *a7 = 74;
    goto LABEL_28;
  }

  uint64_t v15 = v14;
  if ((sub_10003BEEC((uint64_t)v14) & 1) == 0)
  {
    CFPropertyListRef v16 = objc_autoreleasePoolPush();
    if (qword_100219F60) {
      [(id)qword_100219F60 WFLog:4, "%s Client %@ has no entitlement", "kern_return_t _wifi_device_copy_networks(mach_port_t, vm_offset_t, mach_msg_type_number_t, int, vm_offset_t *, m ach_msg_type_number_t *, int *)", sub_10003BEDC((uint64_t)v15) message];
    }
    objc_autoreleasePoolPop(v16);
    *a7 = 1;
    goto LABEL_27;
  }

  CFPropertyListRef v17 = (__CFArray *)sub_10003A7C0(a2, a3);
  if (v17)
  {
    uint64_t v18 = v17;
    CFPropertyListRef v19 = sub_10003C078((uint64_t)v15, v17);
    if (v19)
    {
      uint64_t v20 = sub_1000DEFF8((uint64_t)v19);
      uint64_t v21 = v20;
      if (v20)
      {
        uint64_t v34 = a6;
        unsigned int v35 = a3;
        CFStringRef v36 = a2;
        if (CFArrayGetCount(v20) >= 1)
        {
          for (CFIndex i = 0LL; i < CFArrayGetCount(v21); ++i)
          {
            ValueAtIndex = CFArrayGetValueAtIndex(v21, i);
            if (ValueAtIndex)
            {
              int v24 = ValueAtIndex;
              uint64_t v25 = sub_100096BF4((uint64_t)ValueAtIndex, @"networkRole");
              if ((v25 & 0xFFFFFFFE) == 2)
              {
                CFIndex v26 = (void *)sub_10003BEC4((uint64_t)v15);
                CFDictionaryRef v27 = sub_1000828E8(v26);
                CFIndex v28 = objc_autoreleasePoolPush();
                if (v27)
                {
                  if (qword_100219F60) {
                    [(id)qword_100219F60 WFLog:3, "%s: attaching interface data usage to %@", "_wifi_device_copy_networks", sub_100095BC8(v24) message];
                  }
                  objc_autoreleasePoolPop(v28);
                  sub_10009582C((uint64_t)v24, @"InterfaceDataUsageV1", v27);
                  CFRelease(v27);
                  continue;
                }

                if (qword_100219F60) {
                  [(id)qword_100219F60 WFLog:3, "%s: no interface data usage for %@", "_wifi_device_copy_networks", sub_100095BC8(v24), v33 message];
                }
              }

              else
              {
                CFIndex v28 = objc_autoreleasePoolPush();
                if (qword_100219F60) {
                  [(id)qword_100219F60 WFLog:3, "%s: network %@ has invalid role (%d)", "_wifi_device_copy_networks", sub_100095BC8(v24), v25 message];
                }
              }

              objc_autoreleasePoolPop(v28);
            }
          }
        }

        uint64_t v29 = sub_10003A464(v21);
        if (v29)
        {
          uint64_t v30 = v29;
          sub_10003A920(v29, a5, v34);
          CFRelease(v18);
          uint64_t v18 = v30;
          a2 = v36;
          a3 = v35;
          goto LABEL_25;
        }

        int v32 = 5;
        a2 = v36;
        a3 = v35;
      }

      else
      {
        int v32 = 5;
      }
    }

    else
    {
      uint64_t v21 = 0LL;
      int v32 = 74;
    }

    *a7 = v32;
LABEL_25:
    CFRelease(v18);
    if (v21) {
      CFRelease(v21);
    }
  }

uint64_t sub_1000B6CA8(unsigned int a1, UInt8 *a2, unsigned int a3, uint64_t a4, unsigned int *a5)
{
  *a5 = 0;
  uint64_t v10 = sub_10003B8D0();
  CFMutableArrayRef v11 = sub_10009137C(a1, v10);
  if (v11)
  {
    uint64_t v12 = v11;
    if ((sub_10003BEEC((uint64_t)v11) & 1) != 0)
    {
      CFPropertyListRef v14 = sub_10003A7C0(a2, a3);
      if (v14)
      {
        uint64_t v15 = v14;
        CFPropertyListRef v16 = sub_10003C078((uint64_t)v12, v14);
        if (v16)
        {
          uint64_t v17 = (uint64_t)v16;
          uint64_t v18 = objc_autoreleasePoolPush();
          if (qword_100219F60)
          {
            if ((_DWORD)a4) {
              CFPropertyListRef v19 = "enabled";
            }
            else {
              CFPropertyListRef v19 = "disabled";
            }
            [(id)qword_100219F60 WFLog:3, "WiFi Direct Mode %s, requested by %@", v19, sub_10003BEDC((uint64_t)v12) message];
          }

          objc_autoreleasePoolPop(v18);
          unsigned int v20 = sub_1000DEF3C(v17, (uint64_t)v15, a4);
          *a5 = v20;
          if (v20)
          {
            uint64_t v21 = objc_autoreleasePoolPush();
            if (qword_100219F60) {
              [qword_100219F60 WFLog:@"Unable to set WiFi Direct state to 0x%X, 0x%X. deviceManager=%p" message:4 a4:a5:v17];
            }
            objc_autoreleasePoolPop(v21);
          }
        }

        else
        {
          *a5 = 74;
        }

        CFRelease(v15);
      }
    }

    else
    {
      uint64_t v13 = objc_autoreleasePoolPush();
      if (qword_100219F60) {
        [(id)qword_100219F60 WFLog:4, "%s Client %@ has no entitlement", "kern_return_t _wifi_device_set_wifi_direct_state(mach_port_t, vm_offset_t, mach_msg_type_number_t, int, int *)", sub_10003BEDC((uint64_t)v12) message];
      }
      objc_autoreleasePoolPop(v13);
      *a5 = 1;
    }

    CFRelease(v12);
  }

  else
  {
    *a5 = 74;
  }

  sub_10003A8FC((vm_address_t)a2, a3);
  return 0LL;
}

uint64_t sub_1000B6E80(unsigned int a1, UInt8 *a2, unsigned int a3, unint64_t a4)
{
  uint64_t v8 = sub_10003B8D0();
  uint64_t v9 = sub_10009137C(a1, v8);
  if (v9)
  {
    uint64_t v10 = v9;
    if ((sub_10003BEEC((uint64_t)v9) & 1) != 0)
    {
      CFPropertyListRef v12 = sub_10003A7C0(a2, a3);
      if (v12)
      {
        uint64_t v13 = v12;
        CFPropertyListRef v14 = sub_10003C078((uint64_t)v10, v12);
        if (v14)
        {
          uint64_t v15 = (uint64_t)v14;
          uint64_t v16 = sub_10003BEC4((uint64_t)v10);
          if (((unint64_t)sub_10003DCF8((uint64_t)v10, v15) ^ a4) == 0x8000)
          {
            uint64_t v17 = objc_autoreleasePoolPush();
            if ((a4 & 0x8000) != 0)
            {
              if (qword_100219F60) {
                [(id)qword_100219F60 WFLog:3, "%s: client %@ requested diagnostics event", "_wifi_device_set_event_mask", sub_10003BEDC((uint64_t)v10) message];
              }
              objc_autoreleasePoolPop(v17);
              uint64_t v19 = sub_10003DC78((uint64_t)v10);
              sub_10003DC70((uint64_t)v10, v19 | 0x8000);
              sub_100070794(v16);
            }

            else
            {
              if (qword_100219F60) {
                [(id)qword_100219F60 WFLog:3, "%s: client %@ stopped diagnostics event", "_wifi_device_set_event_mask", sub_10003BEDC((uint64_t)v10) message];
              }
              objc_autoreleasePoolPop(v17);
              uint64_t v18 = sub_10003DC78((uint64_t)v10);
              sub_10003DC70((uint64_t)v10, v18 & 0xFFFFFFFFFFFF7FFFLL);
              sub_100070904(v16);
            }
          }

          sub_10003DC80((uint64_t)v10, v15, v13, a4);
          sub_10007089C(v16, v15, a4);
        }

        CFRelease(v13);
      }
    }

    else
    {
      CFMutableArrayRef v11 = objc_autoreleasePoolPush();
      if (qword_100219F60) {
        [(id)qword_100219F60 WFLog:4, "%s Client %@ has no entitlement", "kern_return_t _wifi_device_set_event_mask(mach_port_t, vm_offset_t, mach_msg_type_number_t, uint64_t)", sub_10003BEDC((uint64_t)v10) message];
      }
      objc_autoreleasePoolPop(v11);
    }

    CFRelease(v10);
  }

  sub_10003A8FC((vm_address_t)a2, a3);
  return 0LL;
}

uint64_t sub_1000B7088( unsigned int a1, UInt8 *a2, unsigned int a3, UInt8 *a4, unsigned int a5, UInt8 *a6, unsigned int a7, _DWORD *a8)
{
  *a8 = -3900;
  uint64_t v16 = sub_10003B8D0();
  uint64_t v17 = sub_10009137C(a1, v16);
  if (v17)
  {
    uint64_t v18 = v17;
    if ((sub_10003BEEC((uint64_t)v17) & 1) == 0)
    {
      uint64_t v19 = objc_autoreleasePoolPush();
      if (qword_100219F60) {
        [(id)qword_100219F60 WFLog:4, "%s Client %@ has no entitlement", "kern_return_t _wifi_device_gas_start_async(mach_port_t, vm_offset_t, mach_msg_type_number_t, vm_offset_t, mach _msg_type_number_t, vm_offset_t, mach_msg_type_number_t, int *)", sub_10003BEDC((uint64_t)v18) message];
      }
      objc_autoreleasePoolPop(v19);
LABEL_32:
      CFRelease(v18);
      goto LABEL_33;
    }

    unsigned int v40 = a3;
    CFPropertyListRef v20 = sub_10003A7C0(a2, a3);
    uint64_t v21 = (const __CFDictionary *)sub_10003A7C0(a6, a7);
    CFPropertyListRef v22 = sub_10003A7C0(a4, a5);
    CFDateRef cf = v21;
    CFTypeRef v39 = v22;
    if (v20 && v21 && (int v23 = (const __CFArray *)v22) != 0LL)
    {
      unsigned int v37 = a2;
      int v24 = sub_10003C078((uint64_t)v18, v20);
      if (v24)
      {
        uint64_t v25 = (uint64_t)v24;
        CFIndex v26 = sub_10003A530(v23);
        if (v26)
        {
          MutableCFDictionaryRef Copy = CFDictionaryCreateMutableCopy(kCFAllocatorDefault, 0LL, v21);
          CFIndex v28 = MutableCopy;
          if (MutableCopy)
          {
            CFStringRef v36 = a4;
            CFDictionaryAddValue(MutableCopy, @"GAS_NETWORKS", v26);
            uint64_t v29 = objc_autoreleasePoolPush();
            if (qword_100219F60) {
              [(id)qword_100219F60 WFLog:3, "Async GAS query requested by %@ on %@", sub_10003BEDC((uint64_t)v18), v20 message];
            }
            objc_autoreleasePoolPop(v29);
            *a8 = 0;
            int v30 = sub_10003C0CC((uint64_t)v18);
            if ((v30 & 4) != 0)
            {
              uint64_t v33 = objc_autoreleasePoolPush();
              if (qword_100219F60) {
                [qword_100219F60 WFLog:@"Already GAS querying, will not queue request."];
              }
              objc_autoreleasePoolPop(v33);
              sub_10003C9DC((uint64_t)v18, v25, v20, 0LL, 37);
              a4 = v36;
            }

            else
            {
              int v31 = v30;
              sub_10003C0D4((uint64_t)v18, v30 | 4);
              int v32 = sub_1000E68D4(v25, v20, v28, (uint64_t)sub_1000B73D0, (uint64_t)v18);
              *a8 = v32;
              if (v32) {
                sub_10003C0D4((uint64_t)v18, v31 & 0xFFFFFFFB);
              }
              else {
                CFRetain(v18);
              }
              a4 = v36;
            }
          }
        }

        else
        {
          CFIndex v28 = 0LL;
        }
      }

      else
      {
        unsigned int v35 = objc_autoreleasePoolPush();
        if (qword_100219F60) {
          [(id)qword_100219F60 WFLog:4, "%s: unable to find device manager for interface %@", "_wifi_device_gas_start_async", v20 message];
        }
        objc_autoreleasePoolPop(v35);
        CFIndex v28 = 0LL;
        CFIndex v26 = 0LL;
      }

      a2 = v37;
    }

    else
    {
      CFIndex v28 = 0LL;
      CFIndex v26 = 0LL;
      if (!v20) {
        goto LABEL_24;
      }
    }

    CFRelease(v20);
LABEL_24:
    if (cf) {
      CFRelease(cf);
    }
    a3 = v40;
    if (v28) {
      CFRelease(v28);
    }
    if (v39) {
      CFRelease(v39);
    }
    if (v26) {
      CFRelease(v26);
    }
    goto LABEL_32;
  }

void sub_1000B73D0(uint64_t a1, const void *a2, const __CFArray *a3, uint64_t a4, const void *a5)
{
  int v10 = sub_10003C0CC((uint64_t)a5);
  CFMutableArrayRef v11 = objc_autoreleasePoolPush();
  if (qword_100219F60) {
    [(id)qword_100219F60 WFLog:3, "Gas request completed for %@ (%d)", sub_10003BEDC((uint64_t)a5), a4 message];
  }
  objc_autoreleasePoolPop(v11);
  sub_10003C9DC((uint64_t)a5, a1, a2, a3, a4);
  sub_10003C0D4((uint64_t)a5, v10 & 0xFFFFFFFB);
  if (a5)
  {
    if ((v10 & 4) != 0) {
      CFRelease(a5);
    }
  }

uint64_t sub_1000B74B4( unsigned int a1, UInt8 *a2, unsigned int a3, uint64_t a4, UInt8 *a5, unsigned int a6, unsigned int *a7)
{
  *a7 = 0;
  uint64_t v14 = sub_10003B8D0();
  uint64_t v15 = sub_10009137C(a1, v14);
  if (v15)
  {
    uint64_t v16 = v15;
    if ((sub_10003BEEC((uint64_t)v15) & 1) != 0)
    {
      CFPropertyListRef v18 = sub_10003A7C0(a2, a3);
      if (v18)
      {
        uint64_t v19 = v18;
        uint64_t v33 = sub_10003C078((uint64_t)v16, v18);
        if (v33)
        {
          int v32 = (const __CFArray *)sub_10003A7C0(a5, a6);
          kdebug_trace(731381796LL, 0LL, 0LL, 0LL, 0LL);
          CFPropertyListRef v20 = objc_autoreleasePoolPush();
          if (qword_100219F60)
          {
            BOOL v21 = (_DWORD)a4 == 0;
            uint64_t v31 = a4;
            unsigned int v22 = a3;
            int v23 = a2;
            unsigned int v24 = a6;
            uint64_t v25 = a5;
            if (v21) {
              CFIndex v26 = "OFF";
            }
            else {
              CFIndex v26 = "ON";
            }
            int v30 = v26;
            a5 = v25;
            a6 = v24;
            a2 = v23;
            a3 = v22;
            a4 = v31;
            [(id)qword_100219F60 WFLog:4, "Set device rangeable %s requested by %@", v30, sub_10003BEDC((uint64_t)v16) message];
          }

          objc_autoreleasePoolPop(v20);
          unsigned int v27 = sub_1000E6BD4((uint64_t)v33, (uint64_t)v19, a4, v32);
          *a7 = v27;
          if (v27)
          {
            CFIndex v28 = objc_autoreleasePoolPush();
            if (qword_100219F60) {
              [qword_100219F60 WFLog:@"Unable to set rangeable state(%d) to %d. deviceManager=%p" message:4];
            }
            objc_autoreleasePoolPop(v28);
          }

          if (v32) {
            CFRelease(v32);
          }
        }

        CFRelease(v19);
      }
    }

    else
    {
      uint64_t v17 = objc_autoreleasePoolPush();
      if (qword_100219F60) {
        [(id)qword_100219F60 WFLog:4, "%s Client %@ has no entitlement", "kern_return_t _wifi_device_set_rangeable(mach_port_t, vm_offset_t, mach_msg_type_number_t, int, vm_offset_t, m ach_msg_type_number_t, int *)", sub_10003BEDC((uint64_t)v16) message];
      }
      objc_autoreleasePoolPop(v17);
      *a7 = 1;
    }

    CFRelease(v16);
  }

  sub_10003A8FC((vm_address_t)a2, a3);
  sub_10003A8FC((vm_address_t)a5, a6);
  return 0LL;
}

uint64_t sub_1000B76F0( unsigned int a1, UInt8 *a2, unsigned int a3, int a4, UInt8 *a5, unsigned int a6, unsigned int *a7)
{
  *a7 = 0;
  uint64_t v14 = sub_10003B8D0();
  uint64_t v15 = sub_10009137C(a1, v14);
  if (v15)
  {
    uint64_t v16 = v15;
    if ((sub_10003BEEC((uint64_t)v15) & 1) == 0)
    {
      uint64_t v17 = objc_autoreleasePoolPush();
      if (qword_100219F60) {
        [(id)qword_100219F60 WFLog:4, "%s Client %@ has no entitlement", "kern_return_t _wifi_device_set_ranging_identifier(mach_port_t, vm_offset_t, mach_msg_type_number_t, int, vm_of fset_t, mach_msg_type_number_t, int *)", sub_10003BEDC((uint64_t)v16) message];
      }
      objc_autoreleasePoolPop(v17);
      *a7 = 1;
      goto LABEL_22;
    }

    CFPropertyListRef v18 = sub_10003A7C0(a2, a3);
    if (!v18)
    {
LABEL_22:
      CFRelease(v16);
      goto LABEL_23;
    }

    uint64_t v19 = v18;
    bytes = a5;
    CFPropertyListRef v20 = sub_10003C078((uint64_t)v16, v18);
    if (v20)
    {
      uint64_t v21 = (uint64_t)v20;
      if (!a4)
      {
        MutableCFDictionaryRef Copy = 0LL;
        int v23 = 0LL;
        goto LABEL_13;
      }

      unsigned int v22 = (const __CFDictionary *)sub_10003A7C0(a5, a6);
      if (v22)
      {
        int v23 = v22;
        MutableCFDictionaryRef Copy = CFDictionaryCreateMutableCopy(kCFAllocatorDefault, 0LL, v22);
        if (!MutableCopy)
        {
LABEL_20:
          CFRelease(v23);
          goto LABEL_21;
        }

uint64_t sub_1000B78D0( unsigned int a1, UInt8 *a2, unsigned int a3, UInt8 *a4, unsigned int a5, uint64_t a6, _DWORD *a7)
{
  *a7 = -3900;
  uint64_t v14 = sub_10003B8D0();
  uint64_t v15 = sub_10009137C(a1, v14);
  if (v15)
  {
    uint64_t v16 = v15;
    if ((sub_10003BEEC((uint64_t)v15) & 1) != 0)
    {
      CFPropertyListRef v18 = sub_10003A7C0(a2, a3);
      if (v18)
      {
        uint64_t v19 = v18;
        uint64_t v31 = a2;
        CFPropertyListRef v20 = sub_10003C078((uint64_t)v16, v18);
        unsigned int v32 = a5;
        if (v20)
        {
          uint64_t v21 = (uint64_t)v20;
          unsigned int v22 = (const __CFArray *)sub_10003A7C0(a4, a5);
          if (v22)
          {
            int v23 = v22;
            kdebug_trace(731381800LL, 0LL, 0LL, 0LL, 0LL);
            unsigned int v24 = objc_autoreleasePoolPush();
            if (qword_100219F60) {
              [(id)qword_100219F60 WFLog:4, "Async ranging requested by %@ on %@ timeout %d", sub_10003BEDC((uint64_t)v16), v19, a6 message];
            }
            objc_autoreleasePoolPop(v24);
            *a7 = 0;
            int v25 = sub_10003C0CC((uint64_t)v16);
            if ((v25 & 0x10) != 0)
            {
              CFIndex v28 = objc_autoreleasePoolPush();
              if (qword_100219F60) {
                [qword_100219F60 WFLog:@"Already ranging, will not queue request."];
              }
              objc_autoreleasePoolPop(v28);
              sub_10003D298((uint64_t)v16, v21, v19, 0LL, 37);
            }

            else
            {
              int v26 = v25;
              sub_10003C0D4((uint64_t)v16, v25 | 0x10);
              int v27 = sub_1000E6BEC(v21, v19, v23, (uint64_t)sub_1000B7B70, (uint64_t)v16, (double)(int)a6);
              *a7 = v27;
              if (v27) {
                sub_10003C0D4((uint64_t)v16, v26 & 0xFFFFFFEF);
              }
              else {
                CFRetain(v16);
              }
            }

            CFRelease(v23);
          }
        }

        else
        {
          int v30 = objc_autoreleasePoolPush();
          if (qword_100219F60) {
            [(id)qword_100219F60 WFLog:4, "%s: unable to find device manager for interface %@", "_wifi_device_ranging_start_async", v19 message];
          }
          objc_autoreleasePoolPop(v30);
        }

        CFRelease(v19);
        a5 = v32;
        a2 = v31;
      }
    }

    else
    {
      uint64_t v17 = objc_autoreleasePoolPush();
      if (qword_100219F60) {
        [(id)qword_100219F60 WFLog:4, "%s Client %@ has no entitlement", "kern_return_t _wifi_device_ranging_start_async(mach_port_t, vm_offset_t, mach_msg_type_number_t, vm_offset_t, mach_msg_type_number_t, int, int *)", sub_10003BEDC((uint64_t)v16) message];
      }
      objc_autoreleasePoolPop(v17);
    }

    CFRelease(v16);
  }

  sub_10003A8FC((vm_address_t)a2, a3);
  sub_10003A8FC((vm_address_t)a4, a5);
  return 0LL;
}

void sub_1000B7B70(uint64_t a1, const void *a2, const void *a3, uint64_t a4, const void *a5)
{
  int v10 = sub_10003C0CC((uint64_t)a5);
  kdebug_trace(731381812LL, 0LL, 0LL, 0LL, 0LL);
  CFMutableArrayRef v11 = objc_autoreleasePoolPush();
  if (qword_100219F60) {
    [(id)qword_100219F60 WFLog:4, "Ranging request completed for %@ (%d)", sub_10003BEDC((uint64_t)a5), a4 message];
  }
  objc_autoreleasePoolPop(v11);
  sub_10003D298((uint64_t)a5, a1, a2, a3, a4);
  sub_10003C0D4((uint64_t)a5, v10 & 0xFFFFFFEF);
  if (a5)
  {
    if ((v10 & 0x10) != 0) {
      CFRelease(a5);
    }
  }

uint64_t sub_1000B7C70(unsigned int a1, uint64_t a2)
{
  uint64_t v4 = sub_10003B8D0();
  uint64_t v5 = sub_10009137C(a1, v4);
  if (v5)
  {
    uint64_t v6 = v5;
    if ((sub_10003BEEC((uint64_t)v5) & 1) != 0)
    {
      uint64_t v8 = sub_10003BEC4((uint64_t)v6);
      if (v8) {
        sub_10007CC1C(v8, a2);
      }
    }

    else
    {
      char v7 = objc_autoreleasePoolPush();
      if (qword_100219F60) {
        [(id)qword_100219F60 WFLog:4, "%s Client %@ has no entitlement", "kern_return_t _wifi_manager_set_thermal_index(mach_port_t, int)", sub_10003BEDC((uint64_t)v6) message];
      }
      objc_autoreleasePoolPop(v7);
    }

    CFRelease(v6);
  }

  return 0LL;
}

uint64_t sub_1000B7D2C(unsigned int a1, _DWORD *a2)
{
  *a2 = 100;
  uint64_t v4 = sub_10003B8D0();
  uint64_t v5 = sub_10009137C(a1, v4);
  if (v5)
  {
    uint64_t v6 = v5;
    if ((sub_10003BEEC((uint64_t)v5) & 1) != 0)
    {
      uint64_t v8 = sub_10003BEC4((uint64_t)v6);
      if (v8) {
        *a2 = sub_10007CB2C(v8);
      }
    }

    else
    {
      char v7 = objc_autoreleasePoolPush();
      if (qword_100219F60) {
        [(id)qword_100219F60 WFLog:4, "%s Client %@ has no entitlement", "kern_return_t _wifi_manager_get_thermal_index(mach_port_t, int *)", sub_10003BEDC((uint64_t)v6) message];
      }
      objc_autoreleasePoolPop(v7);
    }

    CFRelease(v6);
  }

  return 0LL;
}

uint64_t sub_1000B7DF0( unsigned int a1, UInt8 *a2, unsigned int a3, UInt8 *a4, unsigned int a5, vm_offset_t *a6, mach_msg_type_number_t *a7, _DWORD *a8)
{
  CFTypeRef cf = 0LL;
  *a6 = 0LL;
  *a7 = 0;
  *a8 = -3900;
  uint64_t v16 = sub_10003B8D0();
  uint64_t v17 = sub_10009137C(a1, v16);
  if (!v17) {
    goto LABEL_18;
  }
  CFPropertyListRef v18 = v17;
  if ((sub_10003BEEC((uint64_t)v17) & 1) != 0)
  {
    CFPropertyListRef v20 = sub_10003A7C0(a2, a3);
    unsigned int v21 = a5;
    unsigned int v22 = v20;
    unsigned int v29 = v21;
    int v23 = (const __CFDictionary *)sub_10003A7C0(a4, v21);
    unsigned int v24 = v23;
    if (v22 && v23)
    {
      CFIndex v28 = a4;
      int v25 = sub_10003C078((uint64_t)v18, v22);
      int v26 = objc_autoreleasePoolPush();
      if (v25)
      {
        if (qword_100219F60) {
          [(id)qword_100219F60 WFLog:3, "%s: received debug request: %@", "_wifi_device_debug_command", v24 message];
        }
        objc_autoreleasePoolPop(v26);
        *a8 = sub_1000E7210((uint64_t)v25, (uint64_t)v22, v24, (CFMutableDictionaryRef *)&cf);
        a4 = v28;
        if (cf) {
          sub_10003A920(cf, a6, a7);
        }
      }

      else
      {
        if (qword_100219F60) {
          [(id)qword_100219F60 WFLog:4, "%s: unable to find device manager for interface %@", "_wifi_device_debug_command", v22 message];
        }
        objc_autoreleasePoolPop(v26);
        a4 = v28;
      }
    }

    else if (!v22)
    {
LABEL_14:
      a5 = v29;
      if (v24) {
        CFRelease(v24);
      }
      goto LABEL_16;
    }

    CFRelease(v22);
    goto LABEL_14;
  }

  uint64_t v19 = objc_autoreleasePoolPush();
  if (qword_100219F60) {
    [(id)qword_100219F60 WFLog:4, "%s Client %@ has no entitlement", "kern_return_t _wifi_device_debug_command(mach_port_t, vm_offset_t, mach_msg_type_number_t, vm_offset_t, mach_msg_t ype_number_t, vm_offset_t *, mach_msg_type_number_t *, int *)", sub_10003BEDC((uint64_t)v18) message];
  }
  objc_autoreleasePoolPop(v19);
LABEL_16:
  CFRelease(v18);
  if (cf)
  {
    CFRelease(cf);
    CFTypeRef cf = 0LL;
  }

uint64_t sub_1000B8010( unsigned int a1, UInt8 *a2, unsigned int a3, vm_offset_t *a4, mach_msg_type_number_t *a5)
{
  *a4 = 0LL;
  *a5 = 0;
  uint64_t v10 = sub_10003B8D0();
  CFMutableArrayRef v11 = sub_10009137C(a1, v10);
  if (v11)
  {
    CFPropertyListRef v12 = v11;
    if ((sub_10003BEEC((uint64_t)v11) & 1) != 0)
    {
      CFPropertyListRef v14 = sub_10003A7C0(a2, a3);
      if (v14)
      {
        uint64_t v15 = (void *)v14;
        uint64_t v16 = sub_10003C078((uint64_t)v12, v14);
        if (v16 && (uint64_t v17 = sub_1000DE98C((uint64_t)v16, v15)) != 0LL)
        {
          CFPropertyListRef v18 = v17;
          sub_10003A920(v17, a4, a5);
          CFRelease(v15);
          uint64_t v19 = v18;
        }

        else
        {
          uint64_t v19 = (__CFDictionary *)v15;
        }

        CFRelease(v19);
      }
    }

    else
    {
      uint64_t v13 = objc_autoreleasePoolPush();
      if (qword_100219F60) {
        [(id)qword_100219F60 WFLog:4, "%s Client %@ has no entitlement", "kern_return_t _wifi_device_copy_roam_stats(mach_port_t, vm_offset_t, mach_msg_type_number_t, vm_offset_t *, ma ch_msg_type_number_t *)", sub_10003BEDC((uint64_t)v12) message];
      }
      objc_autoreleasePoolPop(v13);
    }

    CFRelease(v12);
  }

  sub_10003A8FC((vm_address_t)a2, a3);
  return 0LL;
}

uint64_t sub_1000B8140(unsigned int a1, UInt8 *a2, unsigned int a3, UInt8 *a4, unsigned int a5, _DWORD *a6)
{
  *a6 = -3900;
  uint64_t v12 = sub_10003B8D0();
  uint64_t v13 = sub_10009137C(a1, v12);
  if (v13)
  {
    CFPropertyListRef v14 = v13;
    if ((sub_10003BEEC((uint64_t)v13) & 1) == 0)
    {
      uint64_t v15 = objc_autoreleasePoolPush();
      if (qword_100219F60) {
        [(id)qword_100219F60 WFLog:4, "%s Client %@ has no entitlement", "kern_return_t _wifi_device_set_trgdisc_params(mach_port_t, vm_offset_t, mach_msg_type_number_t, vm_offset_t, m ach_msg_type_number_t, int *)", sub_10003BEDC((uint64_t)v14) message];
      }
      objc_autoreleasePoolPop(v15);
LABEL_13:
      CFRelease(v14);
      goto LABEL_14;
    }

    CFPropertyListRef v16 = sub_10003A7C0(a2, a3);
    uint64_t v17 = (const __CFDictionary *)sub_10003A7C0(a4, a5);
    CFPropertyListRef v18 = v17;
    if (v16 && v17)
    {
      uint64_t v19 = sub_10003C078((uint64_t)v14, v16);
      if (v19)
      {
        *a6 = sub_1000E9078((uint64_t)v19, v18);
      }

      else
      {
        unsigned int v21 = objc_autoreleasePoolPush();
        if (qword_100219F60) {
          [(id)qword_100219F60 WFLog:4, "%s: unable to find device manager for interface %@", "_wifi_device_set_trgdisc_params", v16 message];
        }
        objc_autoreleasePoolPop(v21);
      }
    }

    else if (!v16)
    {
LABEL_11:
      if (v18) {
        CFRelease(v18);
      }
      goto LABEL_13;
    }

    CFRelease(v16);
    goto LABEL_11;
  }

uint64_t sub_1000B82C8(unsigned int a1, UInt8 *a2, unsigned int a3)
{
  uint64_t v6 = sub_10003B8D0();
  char v7 = sub_10009137C(a1, v6);
  if (v7)
  {
    uint64_t v8 = v7;
    uint64_t v9 = sub_10003BEC4((uint64_t)v7);
    if (v9)
    {
      uint64_t v10 = v9;
      if ((sub_10003BEEC((uint64_t)v8) & 1) != 0)
      {
        CFPropertyListRef v12 = sub_10003A7C0(a2, a3);
        sub_10007A98C(v10);
        if (v12) {
          CFRelease(v12);
        }
      }

      else
      {
        CFMutableArrayRef v11 = objc_autoreleasePoolPush();
        if (qword_100219F60) {
          [(id)qword_100219F60 WFLog:4, "%s Client %@ has no entitlement", "kern_return_t _wifi_manager_dump_logs(mach_port_t, vm_offset_t, mach_msg_type_number_t)", sub_10003BEDC((uint64_t)v8) message];
        }
        objc_autoreleasePoolPop(v11);
      }
    }

    CFRelease(v8);
  }

  sub_10003A8FC((vm_address_t)a2, a3);
  return 0LL;
}

uint64_t sub_1000B83C0(unsigned int a1, UInt8 *a2, CFIndex a3)
{
  uint64_t v6 = sub_10003B8D0();
  char v7 = sub_10009137C(a1, v6);
  if (v7)
  {
    uint64_t v8 = v7;
    if ((sub_10003BEEC((uint64_t)v7) & 1) != 0)
    {
      uint64_t v10 = sub_10003BEC4((uint64_t)v8);
      if (v10)
      {
        CFMutableArrayRef v11 = (const __SCPreferences *)v10;
        CFPropertyListRef v12 = sub_1000B84B8(a2, a3);
        if (v12)
        {
          uint64_t v13 = v12;
          sub_10007DA58(v11, v12);
          CFRelease(v13);
        }
      }
    }

    else
    {
      uint64_t v9 = objc_autoreleasePoolPush();
      if (qword_100219F60) {
        [(id)qword_100219F60 WFLog:4, "%s Client %@ has no entitlement", "kern_return_t _wifi_manager_add_policy(mach_port_t, vm_offset_t, mach_msg_type_number_t, int)", sub_10003BEDC((uint64_t)v8) message];
      }
      objc_autoreleasePoolPop(v9);
    }

    CFRelease(v8);
  }

  sub_10003A8FC((vm_address_t)a2, a3);
  return 0LL;
}

CFDictionaryRef sub_1000B84B8(UInt8 *a1, CFIndex length)
{
  CFPropertyListRef v2 = (const __CFDictionary *)sub_10003A7C0(a1, length);
  __int128 v3 = v2;
  if (v2 && (CFTypeID v4 = CFGetTypeID(v2), v4 == CFDictionaryGetTypeID()))
  {
    uint64_t v5 = sub_100012960(kCFAllocatorDefault, v3);
    CFRelease(v3);
    __int128 v3 = 0LL;
  }

  else
  {
    uint64_t v5 = 0LL;
  }

  if (v5) {
    return (const __CFDictionary *)v5;
  }
  else {
    return v3;
  }
}

uint64_t sub_1000B852C(unsigned int a1, UInt8 *a2, CFIndex a3)
{
  uint64_t v6 = sub_10003B8D0();
  char v7 = sub_10009137C(a1, v6);
  if (v7)
  {
    uint64_t v8 = v7;
    if ((sub_10003BEEC((uint64_t)v7) & 1) != 0)
    {
      uint64_t v10 = sub_10003BEC4((uint64_t)v8);
      if (v10)
      {
        uint64_t v11 = v10;
        CFPropertyListRef v12 = sub_1000B84B8(a2, a3);
        if (v12)
        {
          uint64_t v13 = v12;
          sub_10007DC70(v11, v12);
          CFRelease(v13);
        }
      }
    }

    else
    {
      uint64_t v9 = objc_autoreleasePoolPush();
      if (qword_100219F60) {
        [(id)qword_100219F60 WFLog:4, "%s Client %@ has no entitlement", "kern_return_t _wifi_manager_remove_policy(mach_port_t, vm_offset_t, mach_msg_type_number_t, int)", sub_10003BEDC((uint64_t)v8) message];
      }
      objc_autoreleasePoolPop(v9);
    }

    CFRelease(v8);
  }

  sub_10003A8FC((vm_address_t)a2, a3);
  return 0LL;
}

uint64_t sub_1000B8624(unsigned int a1, vm_offset_t *a2, mach_msg_type_number_t *a3)
{
  *a2 = 0LL;
  *a3 = 0;
  uint64_t v6 = sub_10003B8D0();
  char v7 = sub_10009137C(a1, v6);
  if (v7)
  {
    uint64_t v8 = v7;
    if ((sub_10003BEEC((uint64_t)v7) & 1) != 0)
    {
      uint64_t v10 = sub_10003BEC4((uint64_t)v8);
      if (v10)
      {
        uint64_t v11 = sub_10007DE60(v10);
        if (v11)
        {
          CFPropertyListRef v12 = v11;
          uint64_t v13 = sub_100012DBC(v11);
          if (v13)
          {
            CFPropertyListRef v14 = v13;
            sub_10003A920(v13, a2, a3);
            CFRelease(v14);
          }

          CFRelease(v12);
        }
      }
    }

    else
    {
      uint64_t v9 = objc_autoreleasePoolPush();
      if (qword_100219F60) {
        [(id)qword_100219F60 WFLog:4, "%s Client %@ has no entitlement", "kern_return_t _wifi_manager_copy_policies(mach_port_t, vm_offset_t *, mach_msg_type_number_t *)", sub_10003BEDC((uint64_t)v8) message];
      }
      objc_autoreleasePoolPop(v9);
    }

    CFRelease(v8);
  }

  return 0LL;
}

uint64_t sub_1000B8720(unsigned int a1, _DWORD *a2)
{
  *a2 = 0;
  uint64_t v4 = sub_10003B8D0();
  uint64_t v5 = sub_10009137C(a1, v4);
  if (v5)
  {
    uint64_t v6 = v5;
    if ((sub_10003BEEC((uint64_t)v5) & 1) != 0)
    {
      uint64_t v8 = sub_10003BEC4((uint64_t)v6);
      if (v8) {
        *a2 = sub_1000759EC(v8);
      }
    }

    else
    {
      char v7 = objc_autoreleasePoolPush();
      if (qword_100219F60) {
        [(id)qword_100219F60 WFLog:4, "%s Client %@ has no entitlement", "kern_return_t _wifi_manager_is_restriction_policy_active(mach_port_t, int *)", sub_10003BEDC((uint64_t)v6) message];
      }
      objc_autoreleasePoolPop(v7);
    }

    CFRelease(v6);
  }

  return 0LL;
}

uint64_t sub_1000B87E0(unsigned int a1, unsigned __int8 a2, UInt8 *a3, unsigned int a4)
{
  uint64_t v8 = objc_autoreleasePoolPush();
  if (qword_100219F60) {
    [qword_100219F60 WFLog:@"%s is called\n" message:4];
  }
  objc_autoreleasePoolPop(v8);
  uint64_t v9 = sub_10003B8D0();
  uint64_t v10 = sub_10009137C(a1, v9);
  if (v10)
  {
    uint64_t v11 = v10;
    if ((sub_10003BEEC((uint64_t)v10) & 1) != 0)
    {
      uint64_t v13 = sub_10003BEC4((uint64_t)v11);
      if (v13)
      {
        uint64_t v14 = v13;
        CFPropertyListRef v15 = sub_10003A7C0(a3, a4);
        sub_10007CCE8(v14, a2, v15);
        if (v15) {
          CFRelease(v15);
        }
        goto LABEL_11;
      }

      CFPropertyListRef v12 = objc_autoreleasePoolPush();
      if (qword_100219F60) {
        [qword_100219F60 WFLog:@"_wifi_manager_set_incar_state: invalid manager\n"];
      }
    }

    else
    {
      CFPropertyListRef v12 = objc_autoreleasePoolPush();
      if (qword_100219F60) {
        [(id)qword_100219F60 WFLog:4, "%s Client %@ has no entitlement", "kern_return_t _wifi_manager_set_incar_state(mach_port_t, int, vm_offset_t, mach_msg_type_number_t)", sub_10003BEDC((uint64_t)v11) message];
      }
    }

    objc_autoreleasePoolPop(v12);
LABEL_11:
    CFRelease(v11);
    goto LABEL_12;
  }

  uint64_t v17 = objc_autoreleasePoolPush();
  if (qword_100219F60) {
    [qword_100219F60 WFLog:@"%s: invalid client\n" message:4];
  }
  objc_autoreleasePoolPop(v17);
LABEL_12:
  sub_10003A8FC((vm_address_t)a3, a4);
  return 0LL;
}

uint64_t sub_1000B8990( unsigned int a1, UInt8 *a2, unsigned int a3, UInt8 *a4, unsigned int a5, vm_offset_t *a6, mach_msg_type_number_t *a7, _DWORD *a8)
{
  *a6 = 0LL;
  *a7 = 0;
  *a8 = 0;
  uint64_t v15 = sub_10003B8D0();
  CFPropertyListRef v16 = (__CFArray *)sub_10009137C(a1, v15);
  if (v16)
  {
    uint64_t v17 = v16;
    if ((sub_10003BEEC((uint64_t)v16) & 1) == 0)
    {
      uint64_t v18 = objc_autoreleasePoolPush();
      if (qword_100219F60) {
        [(id)qword_100219F60 WFLog:4, "%s Client %@ has no entitlement", "kern_return_t _wifi_device_wowblacklist_command(mach_port_t, vm_offset_t, mach_msg_type_number_t, vm_offset_t, mach_msg_type_number_t, vm_offset_t *, mach_msg_type_number_t *, int *)", sub_10003BEDC((uint64_t)v17) message];
      }
LABEL_5:
      objc_autoreleasePoolPop(v18);
LABEL_15:
      CFRelease(v17);
      goto LABEL_16;
    }

    CFPropertyListRef v19 = sub_10003A7C0(a2, a3);
    if (!v19)
    {
      uint64_t v18 = objc_autoreleasePoolPush();
      if (qword_100219F60) {
        [qword_100219F60 WFLog:@"_wifi_device_wowblacklist_command:interface is NULL!"];
      }
      goto LABEL_5;
    }

    CFPropertyListRef v20 = v19;
    unsigned int v21 = sub_10003C078((uint64_t)v17, v19);
    int v30 = a4;
    if (v21)
    {
      uint64_t v22 = (uint64_t)v21;
      int v23 = (const __CFDictionary *)sub_10003A7C0(a4, a5);
      unsigned int v24 = objc_autoreleasePoolPush();
      if (qword_100219F60) {
        [(id)qword_100219F60 WFLog:3, "%s: Calling WiFiDeviceManagerProcessWoWBlacklistCommands with request:%@", "_wifi_device_wowblacklist_command", v23 message];
      }
      objc_autoreleasePoolPop(v24);
      int v25 = sub_1000D7770(v22, v23);
      int v26 = v25;
      if (v25) {
        sub_10003A920(v25, a6, a7);
      }
    }

    else
    {
      CFIndex v28 = objc_autoreleasePoolPush();
      if (qword_100219F60) {
        [(id)qword_100219F60 WFLog:4, "%s: unable to find device manager for interface %@", "_wifi_device_wowblacklist_command", v20 message];
      }
      objc_autoreleasePoolPop(v28);
      int v23 = 0LL;
      int v26 = 0LL;
    }

    CFRelease(v20);
    CFRelease(v17);
    if (v23) {
      CFRelease(v23);
    }
    uint64_t v17 = v26;
    a4 = v30;
    if (v26) {
      goto LABEL_15;
    }
  }

uint64_t sub_1000B8BC8(unsigned int a1, vm_offset_t *a2, mach_msg_type_number_t *a3)
{
  *a2 = 0LL;
  *a3 = 0;
  uint64_t v6 = sub_10003B8D0();
  char v7 = sub_10009137C(a1, v6);
  if (v7)
  {
    uint64_t v8 = v7;
    if ((sub_10003BEEC((uint64_t)v7) & 1) != 0)
    {
      uint64_t v10 = sub_10003BEC4((uint64_t)v8);
      if (v10)
      {
        uint64_t v11 = sub_10007EC9C(v10);
        if (v11)
        {
          CFPropertyListRef v12 = v11;
          uint64_t v13 = objc_autoreleasePoolPush();
          if (qword_100219F60) {
            [(id)qword_100219F60 WFLog:3, "%s:Leech location requested by %@", "_wifi_manager_copy_leeched_location", sub_10003BEDC((uint64_t)v8) message];
          }
          objc_autoreleasePoolPop(v13);
          sub_10003A920(v12, a2, a3);
          CFRelease(v12);
        }
      }
    }

    else
    {
      uint64_t v9 = objc_autoreleasePoolPush();
      if (qword_100219F60) {
        [(id)qword_100219F60 WFLog:4, "%s Client %@ has no entitlement", "kern_return_t _wifi_manager_copy_leeched_location(mach_port_t, vm_offset_t *, mach_msg_type_number_t *)", sub_10003BEDC((uint64_t)v8) message];
      }
      objc_autoreleasePoolPop(v9);
    }

    CFRelease(v8);
  }

  return 0LL;
}

uint64_t sub_1000B8CFC(unsigned int a1, UInt8 *a2, CFIndex a3, vm_offset_t *a4, mach_msg_type_number_t *a5)
{
  *a4 = 0LL;
  *a5 = 0;
  uint64_t v10 = sub_10003B8D0();
  uint64_t v11 = sub_10009137C(a1, v10);
  if (v11)
  {
    CFPropertyListRef v12 = v11;
    if ((sub_10003BEEC((uint64_t)v11) & 1) != 0)
    {
      uint64_t v14 = sub_10003BEC4((uint64_t)v12);
      if (v14)
      {
        uint64_t v15 = v14;
        CFPropertyListRef v16 = sub_1000B1C5C(a2, a3);
        if (v16)
        {
          uint64_t v17 = v16;
          uint64_t v18 = objc_autoreleasePoolPush();
          CFPropertyListRef v19 = (void *)qword_100219F60;
          if (qword_100219F60)
          {
            CFPropertyListRef v20 = sub_100095BC8(v17);
            [v19 WFLog:3, "%s:%@ requested by %@", "_wifi_manager_copy_geotags_for_network", v20, sub_10003BEDC((uint64_t)v12) message];
          }

          objc_autoreleasePoolPop(v18);
          id v21 = sub_10007E7C8(v15, (uint64_t)v17);
          if (v21)
          {
            uint64_t v22 = v21;
            sub_10003A920(v21, a4, a5);
            CFRelease(v22);
          }

          CFRelease(v17);
        }
      }
    }

    else
    {
      uint64_t v13 = objc_autoreleasePoolPush();
      if (qword_100219F60) {
        [(id)qword_100219F60 WFLog:4, "%s Client %@ has no entitlement", "kern_return_t _wifi_manager_copy_geotags_for_network(mach_port_t, vm_offset_t, mach_msg_type_number_t, vm_offs et_t *, mach_msg_type_number_t *)", sub_10003BEDC((uint64_t)v12) message];
      }
      objc_autoreleasePoolPop(v13);
    }

    CFRelease(v12);
  }

  sub_10003A8FC((vm_address_t)a2, a3);
  return 0LL;
}

uint64_t sub_1000B8E88(unsigned int a1, UInt8 *a2, CFIndex a3, double a4, double a5)
{
  if (a4 < -90.0 || a4 > 90.0)
  {
    uint64_t v22 = objc_autoreleasePoolPush();
    if (qword_100219F60) {
      [qword_100219F60 WFLog:@"Invalid latitude value" message:@"_wifi_manager_set_geotag_for_network"];
    }
    goto LABEL_21;
  }

  if (a5 < -180.0 || a5 > 180.0)
  {
    uint64_t v22 = objc_autoreleasePoolPush();
    if (qword_100219F60) {
      [qword_100219F60 WFLog:@"Invalid longitude value" message:@"_wifi_manager_set_geotag_for_network"];
    }
LABEL_21:
    objc_autoreleasePoolPop(v22);
    goto LABEL_16;
  }

  uint64_t v10 = sub_10003B8D0();
  uint64_t v11 = sub_10009137C(a1, v10);
  if (v11)
  {
    CFPropertyListRef v12 = v11;
    if ((sub_10003BEEC((uint64_t)v11) & 1) != 0)
    {
      uint64_t v14 = sub_10003BEC4((uint64_t)v12);
      if (v14)
      {
        uint64_t v15 = v14;
        CFPropertyListRef v16 = sub_1000B1C5C(a2, a3);
        if (v16)
        {
          uint64_t v17 = v16;
          uint64_t v18 = objc_autoreleasePoolPush();
          CFPropertyListRef v19 = (void *)qword_100219F60;
          if (qword_100219F60)
          {
            CFPropertyListRef v20 = sub_100095BC8(v17);
            [v19 WFLog:3, "%s:%@ requested by %@", "_wifi_manager_set_geotag_for_network", v20, sub_10003BEDC((uint64_t)v12) message];
          }

          objc_autoreleasePoolPop(v18);
          sub_10007E8B4(v15, v17, a4, a5);
          CFRelease(v17);
        }
      }
    }

    else
    {
      uint64_t v13 = objc_autoreleasePoolPush();
      if (qword_100219F60) {
        [(id)qword_100219F60 WFLog:4, "%s Client %@ has no entitlement", "kern_return_t _wifi_manager_set_geotag_for_network(mach_port_t, vm_offset_t, mach_msg_type_number_t, double, double)", sub_10003BEDC((uint64_t)v12) message];
      }
      objc_autoreleasePoolPop(v13);
    }

    CFRelease(v12);
  }

uint64_t sub_1000B90A8( unsigned int a1, int a2, vm_offset_t *a3, mach_msg_type_number_t *a4, double a5, double a6)
{
  *a3 = 0LL;
  *a4 = 0;
  if (a5 < -90.0 || a5 > 90.0)
  {
    int v25 = objc_autoreleasePoolPush();
    if (qword_100219F60) {
      [qword_100219F60 WFLog:@"Invalid latitude value" message:4];
    }
    goto LABEL_24;
  }

  if (a6 < -180.0 || a6 > 180.0)
  {
    int v25 = objc_autoreleasePoolPush();
    if (qword_100219F60) {
      [qword_100219F60 WFLog:@"Invalid longitude value" message:@"_wifi_manager_copy_networks_at_location"];
    }
LABEL_24:
    objc_autoreleasePoolPop(v25);
    return 0LL;
  }

  uint64_t v12 = sub_10003B8D0();
  uint64_t v13 = sub_10009137C(a1, v12);
  if (v13)
  {
    uint64_t v14 = v13;
    if ((sub_10003BEEC((uint64_t)v13) & 1) != 0)
    {
      uint64_t v17 = sub_10003BEC4((uint64_t)v14);
      if (v17)
      {
        uint64_t v18 = v17;
        CFPropertyListRef v19 = objc_autoreleasePoolPush();
        if (qword_100219F60) {
          [(id)qword_100219F60 WFLog:3, "%s:(%f,%f) requested by %@", "_wifi_manager_copy_networks_at_location", *(void *)&a5, *(void *)&a6, sub_10003BEDC((uint64_t)v14) message];
        }
        objc_autoreleasePoolPop(v19);
        CFPropertyListRef v20 = (const __CFArray *)sub_10007EA44(v18, a2 != 0, a5, a6);
        if (v20)
        {
          id v21 = v20;
          uint64_t v22 = sub_10003A464(v20);
          if (v22)
          {
            int v23 = v22;
            sub_10003A920(v22, a3, a4);
            CFRelease(v23);
          }

          CFRelease(v14);
          CFPropertyListRef v16 = v21;
          goto LABEL_18;
        }
      }
    }

    else
    {
      uint64_t v15 = objc_autoreleasePoolPush();
      if (qword_100219F60) {
        [(id)qword_100219F60 WFLog:4, "%s Client %@ has no entitlement", "kern_return_t _wifi_manager_copy_networks_at_location(mach_port_t, double, double, int, vm_offset_t *, mach_ms g_type_number_t *)", sub_10003BEDC((uint64_t)v14) message];
      }
      objc_autoreleasePoolPop(v15);
    }

    CFPropertyListRef v16 = (const __CFArray *)v14;
LABEL_18:
    CFRelease(v16);
  }

  return 0LL;
}

uint64_t sub_1000B92DC(unsigned int a1, UInt8 *a2, CFIndex a3, vm_offset_t *a4, mach_msg_type_number_t *a5)
{
  *a4 = 0LL;
  *a5 = 0;
  uint64_t v10 = sub_10003B8D0();
  uint64_t v11 = sub_10009137C(a1, v10);
  if (v11)
  {
    uint64_t v12 = v11;
    if ((sub_10003BEEC((uint64_t)v11) & 1) != 0)
    {
      uint64_t v14 = sub_10003BEC4((uint64_t)v12);
      if (v14)
      {
        uint64_t v15 = v14;
        CFPropertyListRef v16 = sub_1000B1C5C(a2, a3);
        if (v16)
        {
          uint64_t v17 = v16;
          uint64_t v18 = objc_autoreleasePoolPush();
          CFPropertyListRef v19 = (void *)qword_100219F60;
          if (qword_100219F60)
          {
            CFPropertyListRef v20 = sub_100095BC8(v17);
            [v19 WFLog:3, "%s:%@ requested by %@", "_wifi_manager_copy_score_for_network", v20, sub_10003BEDC((uint64_t)v12) message];
          }

          objc_autoreleasePoolPop(v18);
          id v21 = sub_10007EBC4(v15, (uint64_t)v17);
          if (v21)
          {
            uint64_t v22 = v21;
            sub_10003A920(v21, a4, a5);
            CFRelease(v22);
          }

          CFRelease(v17);
        }
      }
    }

    else
    {
      uint64_t v13 = objc_autoreleasePoolPush();
      if (qword_100219F60) {
        [(id)qword_100219F60 WFLog:4, "%s Client %@ has no entitlement", "kern_return_t _wifi_manager_copy_score_for_network(mach_port_t, vm_offset_t, mach_msg_type_number_t, vm_offset _t *, mach_msg_type_number_t *)", sub_10003BEDC((uint64_t)v12) message];
      }
      objc_autoreleasePoolPop(v13);
    }

    CFRelease(v12);
  }

  sub_10003A8FC((vm_address_t)a2, a3);
  return 0LL;
}

uint64_t sub_1000B9468(unsigned int a1, UInt8 *a2, unsigned int a3, UInt8 *a4, unsigned int a5, _DWORD *a6)
{
  value = 0LL;
  unsigned int valuePtr = 1024;
  *a6 = 0;
  uint64_t v12 = sub_10003B8D0();
  uint64_t v13 = (const __CFDictionary *)sub_10009137C(a1, v12);
  if (!v13) {
    goto LABEL_20;
  }
  uint64_t v14 = v13;
  if ((sub_10003BEEC((uint64_t)v13) & 1) == 0)
  {
    uint64_t v15 = objc_autoreleasePoolPush();
    if (qword_100219F60) {
      [(id)qword_100219F60 WFLog:4, "%s Client %@ has no entitlement", "kern_return_t _wifi_device_soft_error_notification(mach_port_t, vm_offset_t, mach_msg_type_number_t, vm_offset_t, mach_msg_type_number_t, int *)", sub_10003BEDC((uint64_t)v14) message];
    }
    objc_autoreleasePoolPop(v15);
    *a6 = 1;
    goto LABEL_6;
  }

  CFPropertyListRef v17 = sub_10003A7C0(a2, a3);
  if (!v17)
  {
LABEL_6:
    CFPropertyListRef v16 = v14;
LABEL_19:
    CFRelease(v16);
    goto LABEL_20;
  }

  uint64_t v18 = v17;
  CFPropertyListRef v19 = sub_10003C078((uint64_t)v14, v17);
  if (v19)
  {
    uint64_t v20 = (uint64_t)v19;
    id v21 = (const __CFDictionary *)sub_10003A7C0(a4, a5);
    if (CFDictionaryGetValueIfPresent(v21, @"APPLE80211KEY_SOFT_ERROR_EVENT_TYPE", (const void **)&value))
    {
      if (value)
      {
        CFNumberGetValue((CFNumberRef)value, kCFNumberSInt32Type, &valuePtr);
        if (valuePtr < 0x13)
        {
          sub_1000EDDB0(v20);
          goto LABEL_17;
        }

        uint64_t v22 = objc_autoreleasePoolPush();
        int v23 = (void *)qword_100219F60;
        if (!qword_100219F60) {
          goto LABEL_16;
        }
        uint64_t v28 = valuePtr;
        unsigned int v24 = "%s: Invalid SoftError Event:%u";
      }

      else
      {
        uint64_t v22 = objc_autoreleasePoolPush();
        int v23 = (void *)qword_100219F60;
        if (!qword_100219F60) {
          goto LABEL_16;
        }
        unsigned int v24 = "%s: SoftErrorEventNum is Null!";
      }

      uint64_t v25 = 3LL;
    }

    else
    {
      uint64_t v22 = objc_autoreleasePoolPush();
      int v23 = (void *)qword_100219F60;
      if (!qword_100219F60)
      {
LABEL_16:
        objc_autoreleasePoolPop(v22);
        goto LABEL_17;
      }

      unsigned int v24 = "%s: No APPLE80211KEY_SOFT_ERROR_EVENT_TYPE Key ";
      uint64_t v25 = 4LL;
    }

    objc_msgSend(v23, "WFLog:message:", v25, v24, "_wifi_device_soft_error_notification", v28);
    goto LABEL_16;
  }

  int v27 = objc_autoreleasePoolPush();
  if (qword_100219F60) {
    [(id)qword_100219F60 WFLog:4, "%s: unable to find device manager for interface %@", "_wifi_device_soft_error_notification", v18 message];
  }
  objc_autoreleasePoolPop(v27);
  id v21 = 0LL;
LABEL_17:
  CFRelease(v18);
  CFRelease(v14);
  if (v21)
  {
    CFPropertyListRef v16 = v21;
    goto LABEL_19;
  }

uint64_t sub_1000B96D8(unsigned int a1, vm_offset_t *a2, mach_msg_type_number_t *a3)
{
  *a2 = 0LL;
  *a3 = 0;
  uint64_t v6 = sub_10003B8D0();
  char v7 = sub_10009137C(a1, v6);
  if (v7)
  {
    uint64_t v8 = v7;
    if ((sub_10003BEEC((uint64_t)v7) & 1) != 0)
    {
      uint64_t v10 = sub_10003BEC4((uint64_t)v8);
      if (v10)
      {
        uint64_t v11 = sub_10007F190(v10);
        if (v11)
        {
          uint64_t v12 = v11;
          sub_10003A920(v11, a2, a3);
          CFRelease(v12);
        }
      }
    }

    else
    {
      uint64_t v9 = objc_autoreleasePoolPush();
      if (qword_100219F60) {
        [(id)qword_100219F60 WFLog:4, "%s Client %@ has no entitlement", "kern_return_t _wifi_manager_copy_softerror_counters(mach_port_t, vm_offset_t *, mach_msg_type_number_t *)", sub_10003BEDC((uint64_t)v8) message];
      }
      objc_autoreleasePoolPop(v9);
    }

    CFRelease(v8);
  }

  return 0LL;
}

uint64_t sub_1000B97B8(unsigned int a1, vm_offset_t *a2, mach_msg_type_number_t *a3)
{
  *a2 = 0LL;
  *a3 = 0;
  uint64_t v6 = sub_10003B8D0();
  char v7 = sub_10009137C(a1, v6);
  if (v7)
  {
    uint64_t v8 = v7;
    if ((sub_10003BEEC((uint64_t)v7) & 1) != 0)
    {
      uint64_t v10 = (const __CFArray *)sub_10003BEC4((uint64_t)v8);
      if (v10)
      {
        uint64_t v11 = sub_10007F628(v10);
        if (v11)
        {
          uint64_t v12 = v11;
          CFDictionaryRef v13 = sub_100012CEC((uint64_t)v11);
          if (v13)
          {
            CFDictionaryRef v14 = v13;
            sub_10003A920(v13, a2, a3);
            CFRelease(v14);
          }

          CFRelease(v12);
        }
      }
    }

    else
    {
      uint64_t v9 = objc_autoreleasePoolPush();
      if (qword_100219F60) {
        [(id)qword_100219F60 WFLog:4, "%s Client %@ has no entitlement", "kern_return_t _wifi_manager_copy_current_session_based_network(mach_port_t, vm_offset_t *, mach_msg_type_number_t *)", sub_10003BEDC((uint64_t)v8) message];
      }
      objc_autoreleasePoolPop(v9);
    }

    CFRelease(v8);
  }

  return 0LL;
}

uint64_t sub_1000B98B4(unsigned int a1, uint64_t a2)
{
  uint64_t v4 = sub_10003B8D0();
  uint64_t v5 = sub_10009137C(a1, v4);
  if (v5)
  {
    uint64_t v6 = v5;
    if ((sub_10003BEEC((uint64_t)v5) & 1) != 0)
    {
      uint64_t v8 = sub_10003BEC4((uint64_t)v6);
      if (v8)
      {
        uint64_t v9 = v8;
        uint64_t v10 = objc_autoreleasePoolPush();
        if (qword_100219F60) {
          [(id)qword_100219F60 WFLog:3, "Set user auto join enabled requested by %@ enabled %d", sub_10003BEDC((uint64_t)v6), a2 message];
        }
        objc_autoreleasePoolPop(v10);
        uint64_t v11 = sub_10003BEDC((uint64_t)v6);
        sub_10006570C(v9, a2, 0LL, v11);
      }
    }

    else
    {
      char v7 = objc_autoreleasePoolPush();
      if (qword_100219F60) {
        [(id)qword_100219F60 WFLog:4, "%s Client %@ has no entitlement", "kern_return_t _wifi_manager_set_user_auto_join_state(mach_port_t, int)", sub_10003BEDC((uint64_t)v6) message];
      }
      objc_autoreleasePoolPop(v7);
    }

    CFRelease(v6);
  }

  return 0LL;
}

uint64_t sub_1000B99D0(unsigned int a1, _DWORD *a2)
{
  uint64_t v4 = sub_10003B8D0();
  uint64_t v5 = sub_10009137C(a1, v4);
  if (v5)
  {
    uint64_t v6 = v5;
    if ((sub_10003BEEC((uint64_t)v5) & 1) != 0)
    {
      uint64_t v8 = sub_10003BEC4((uint64_t)v6);
      if (!v8)
      {
LABEL_12:
        CFRelease(v6);
        return 0LL;
      }

      *a2 = sub_1000653FC(v8);
      char v7 = objc_autoreleasePoolPush();
      uint64_t v9 = (void *)qword_100219F60;
      if (qword_100219F60)
      {
        uint64_t v10 = sub_10003BEDC((uint64_t)v6);
        if (*a2) {
          uint64_t v11 = "Enable";
        }
        else {
          uint64_t v11 = "Disable";
        }
        [v9 WFLog:3, "User auto join state queried by %@ is %s", v10, v11 message];
      }
    }

    else
    {
      char v7 = objc_autoreleasePoolPush();
      if (qword_100219F60) {
        [(id)qword_100219F60 WFLog:4, "%s Client %@ has no entitlement", "kern_return_t _wifi_manager_get_user_auto_join_state(mach_port_t, int *)", sub_10003BEDC((uint64_t)v6) message];
      }
    }

    objc_autoreleasePoolPop(v7);
    goto LABEL_12;
  }

  return 0LL;
}

uint64_t sub_1000B9ADC(unsigned int a1)
{
  uint64_t v2 = sub_10003B8D0();
  __int128 v3 = sub_10009137C(a1, v2);
  if (v3)
  {
    uint64_t v4 = v3;
    if ((sub_10003BEEC((uint64_t)v3) & 1) != 0)
    {
      uint64_t v6 = sub_10003BEC4((uint64_t)v4);
      if (v6)
      {
        uint64_t v7 = v6;
        uint64_t v8 = objc_autoreleasePoolPush();
        if (qword_100219F60) {
          [(id)qword_100219F60 WFLog:3, "Orphaned SC sets removal requested by %@", sub_10003BEDC((uint64_t)v4) message];
        }
        objc_autoreleasePoolPop(v8);
        sub_10007FD6C(v7);
      }
    }

    else
    {
      uint64_t v5 = objc_autoreleasePoolPush();
      if (qword_100219F60) {
        [(id)qword_100219F60 WFLog:4, "%s Client %@ has no entitlement", "kern_return_t _wifi_manager_remove_orphaned_sc_network_sets(mach_port_t)", sub_10003BEDC((uint64_t)v4) message];
      }
      objc_autoreleasePoolPop(v5);
    }

    CFRelease(v4);
  }

  return 0LL;
}

uint64_t sub_1000B9BD8(unsigned int a1)
{
  uint64_t v2 = sub_10003B8D0();
  __int128 v3 = sub_10009137C(a1, v2);
  if (v3)
  {
    uint64_t v4 = v3;
    if ((sub_10003BEEC((uint64_t)v3) & 1) != 0)
    {
      uint64_t v6 = sub_10003BEC4((uint64_t)v4);
      if (v6)
      {
        uint64_t v7 = v6;
        uint64_t v8 = objc_autoreleasePoolPush();
        if (qword_100219F60) {
          [(id)qword_100219F60 WFLog:3, "Migration of wifi plist requested by %@", sub_10003BEDC((uint64_t)v4) message];
        }
        objc_autoreleasePoolPop(v8);
        sub_100080BEC(v7);
      }
    }

    else
    {
      uint64_t v5 = objc_autoreleasePoolPush();
      if (qword_100219F60) {
        [(id)qword_100219F60 WFLog:4, "%s Client %@ has no entitlement", "kern_return_t _wifi_manager_migrate_list(mach_port_t)", sub_10003BEDC((uint64_t)v4) message];
      }
      objc_autoreleasePoolPop(v5);
    }

    CFRelease(v4);
  }

  return 0LL;
}

uint64_t sub_1000B9CD4(unsigned int a1, double a2)
{
  uint64_t v4 = sub_10003B8D0();
  uint64_t v5 = sub_10009137C(a1, v4);
  if (v5)
  {
    uint64_t v6 = v5;
    if ((sub_10003BEEC((uint64_t)v5) & 1) != 0)
    {
      uint64_t v8 = sub_10003BEC4((uint64_t)v6);
      if (v8)
      {
        uint64_t v9 = v8;
        uint64_t v10 = objc_autoreleasePoolPush();
        if (qword_100219F60) {
          [(id)qword_100219F60 WFLog:3, "Unused geotags removal requested by %@, with retention period %f secs", sub_10003BEDC((uint64_t)v6), *(void *)&a2 message];
        }
        objc_autoreleasePoolPop(v10);
        sub_10007EE3C(v9, a2);
      }
    }

    else
    {
      uint64_t v7 = objc_autoreleasePoolPush();
      if (qword_100219F60) {
        [(id)qword_100219F60 WFLog:4, "%s Client %@ has no entitlement", "kern_return_t _wifi_manager_remove_unused_network_geotags(mach_port_t, double)", sub_10003BEDC((uint64_t)v6) message];
      }
      objc_autoreleasePoolPop(v7);
    }

    CFRelease(v6);
  }

  return 0LL;
}

uint64_t sub_1000B9DE4(unsigned int a1, uint64_t a2, double a3)
{
  uint64_t v6 = sub_10003B8D0();
  uint64_t v7 = sub_10009137C(a1, v6);
  if (v7)
  {
    uint64_t v8 = v7;
    if ((sub_10003BEEC((uint64_t)v7) & 1) != 0)
    {
      uint64_t v10 = sub_10003BEC4((uint64_t)v8);
      if (v10)
      {
        uint64_t v11 = v10;
        uint64_t v12 = objc_autoreleasePoolPush();
        if (qword_100219F60) {
          [(id)qword_100219F60 WFLog:3, "Schedule unused geotags removal at interval %d mins requested by %@, with retention period %f secs", a2, sub_10003BEDC((uint64_t)v8), *(void *)&a3 message];
        }
        objc_autoreleasePoolPop(v12);
        sub_10007EEF4(v11, (int)a2, a3);
      }
    }

    else
    {
      uint64_t v9 = objc_autoreleasePoolPush();
      if (qword_100219F60) {
        [(id)qword_100219F60 WFLog:4, "%s Client %@ has no entitlement", "kern_return_t _wifi_manager_schedule_unused_network_geotags_removal_test(mach_port_t, double, int)", sub_10003BEDC((uint64_t)v8) message];
      }
      objc_autoreleasePoolPop(v9);
    }

    CFRelease(v8);
  }

  return 0LL;
}

uint64_t sub_1000B9F08(unsigned int a1)
{
  uint64_t v2 = sub_10003B8D0();
  __int128 v3 = sub_10009137C(a1, v2);
  if (v3)
  {
    uint64_t v4 = v3;
    if ((sub_10003BEEC((uint64_t)v3) & 1) != 0)
    {
      uint64_t v6 = sub_10003BEC4((uint64_t)v4);
      if (v6)
      {
        uint64_t v7 = v6;
        uint64_t v8 = objc_autoreleasePoolPush();
        if (qword_100219F60) {
          [(id)qword_100219F60 WFLog:3, "Unschedule unused network geotags removal test requested by %@", sub_10003BEDC((uint64_t)v4) message];
        }
        objc_autoreleasePoolPop(v8);
        sub_10007EFE0(v7);
      }
    }

    else
    {
      uint64_t v5 = objc_autoreleasePoolPush();
      if (qword_100219F60) {
        [(id)qword_100219F60 WFLog:4, "%s Client %@ has no entitlement", "kern_return_t _wifi_manager_unschedule_unused_network_geotags_removal_test(mach_port_t)", sub_10003BEDC((uint64_t)v4) message];
      }
      objc_autoreleasePoolPop(v5);
    }

    CFRelease(v4);
  }

  return 0LL;
}

uint64_t sub_1000BA004( unsigned int a1, UInt8 *a2, unsigned int a3, UInt8 *a4, unsigned int a5, vm_offset_t *a6, mach_msg_type_number_t *a7)
{
  uint64_t v14 = sub_10003B8D0();
  uint64_t v15 = (const __CFDictionary *)sub_10009137C(a1, v14);
  if (!v15) {
    goto LABEL_19;
  }
  CFPropertyListRef v16 = v15;
  if ((sub_10003BEEC((uint64_t)v15) & 1) == 0)
  {
    CFPropertyListRef v17 = objc_autoreleasePoolPush();
    if (qword_100219F60) {
      [(id)qword_100219F60 WFLog:4, "%s Client %@ has no entitlement", "kern_return_t _wifi_device_autojoinblacklist_command(mach_port_t, vm_offset_t, mach_msg_type_number_t, vm_offset _t, mach_msg_type_number_t, vm_offset_t *, mach_msg_type_number_t *)", sub_10003BEDC((uint64_t)v16) message];
    }
LABEL_5:
    objc_autoreleasePoolPop(v17);
LABEL_18:
    CFRelease(v16);
    goto LABEL_19;
  }

  CFPropertyListRef v18 = sub_10003A7C0(a2, a3);
  if (!v18)
  {
    CFPropertyListRef v17 = objc_autoreleasePoolPush();
    if (qword_100219F60) {
      [qword_100219F60 WFLog:@"%s:interface is NULL!" message:3];
    }
    goto LABEL_5;
  }

  CFPropertyListRef v19 = v18;
  uint64_t v20 = sub_10003C078((uint64_t)v16, v18);
  uint64_t v33 = a4;
  if (v20)
  {
    uint64_t v21 = (uint64_t)v20;
    uint64_t v22 = (const __CFDictionary *)sub_10003A7C0(a4, a5);
    int v23 = objc_autoreleasePoolPush();
    if (qword_100219F60) {
      [(id)qword_100219F60 WFLog:3, "%s: Calling WiFiDeviceManagerProcessAutoJoinBlacklistCommandsAndCopyResponse with request:%@", "_wifi_device_autojoinblacklist_command", v22 message];
    }
    objc_autoreleasePoolPop(v23);
    unsigned int v24 = sub_1000EFAB0(v21, v22);
    uint64_t v25 = v24;
    if (v24)
    {
      if (CFDictionaryContainsKey(v24, @"networks"))
      {
        if (CFDictionaryContainsKey(v25, @"reasons"))
        {
          CFBooleanRef Value = (const __CFArray *)CFDictionaryGetValue(v25, @"networks");
          int v27 = sub_10003A464(Value);
          if (v27)
          {
            uint64_t v28 = v27;
            CFDictionarySetValue(v25, @"networks", v27);
            CFRelease(v28);
            sub_10003A920(v25, a6, a7);
            goto LABEL_15;
          }

          uint64_t v31 = objc_autoreleasePoolPush();
          if (qword_100219F60) {
            [qword_100219F60 WFLog:@"_wifi_device_autojoinblacklist_command - _WiFiCreateRecordsFromNetworks failed"];
          }
        }

        else
        {
          uint64_t v31 = objc_autoreleasePoolPush();
          if (qword_100219F60) {
            [qword_100219F60 WFLog:@"%s No blacklist reasons in response" message:3];
          }
        }
      }

      else
      {
        uint64_t v31 = objc_autoreleasePoolPush();
        if (qword_100219F60) {
          [qword_100219F60 WFLog:@"%s No blacklisted WiFiNetworkRef (records) in response" message:3];
        }
      }

      objc_autoreleasePoolPop(v31);
    }
  }

  else
  {
    int v30 = objc_autoreleasePoolPush();
    if (qword_100219F60) {
      [(id)qword_100219F60 WFLog:4, "%s: unable to find device manager for interface %@", "_wifi_device_autojoinblacklist_command", v19 message];
    }
    objc_autoreleasePoolPop(v30);
    uint64_t v22 = 0LL;
    uint64_t v25 = 0LL;
  }

uint64_t sub_1000BA330(unsigned int a1, UInt8 *a2, CFIndex a3, uint64_t a4, UInt8 *a5, unsigned int a6)
{
  uint64_t v12 = sub_10003B8D0();
  CFDictionaryRef v13 = sub_10009137C(a1, v12);
  if (v13)
  {
    uint64_t v14 = v13;
    if ((sub_10003BEEC((uint64_t)v13) & 1) != 0)
    {
      uint64_t v16 = sub_10003BEC4((uint64_t)v14);
      if (v16)
      {
        CFPropertyListRef v17 = (const __CFArray *)v16;
        if (a2) {
          CFPropertyListRef v18 = sub_1000B1C5C(a2, a3);
        }
        else {
          CFPropertyListRef v18 = 0LL;
        }
        CFPropertyListRef v19 = (const __CFDictionary *)sub_10003A7C0(a5, a6);
        sub_100081694(v17, v18, a4, v19);
        if (v19) {
          CFRelease(v19);
        }
        if (v18) {
          CFRelease(v18);
        }
      }
    }

    else
    {
      uint64_t v15 = objc_autoreleasePoolPush();
      if (qword_100219F60) {
        [(id)qword_100219F60 WFLog:4, "%s Client %@ has no entitlement", "kern_return_t _wifi_manager_simulate_notification(mach_port_t, vm_offset_t, mach_msg_type_number_t, int, vm_of fset_t, mach_msg_type_number_t)", sub_10003BEDC((uint64_t)v14) message];
      }
      objc_autoreleasePoolPop(v15);
    }

    CFRelease(v14);
  }

  sub_10003A8FC((vm_address_t)a5, a6);
  return 0LL;
}

uint64_t sub_1000BA46C(unsigned int a1, UInt8 *a2, unsigned int a3, _DWORD *a4)
{
  uint64_t v8 = sub_10003B8D0();
  uint64_t v9 = sub_10009137C(a1, v8);
  if (v9)
  {
    uint64_t v10 = v9;
    CFPropertyListRef v11 = sub_10003A7C0(a2, a3);
    if (!v11)
    {
      uint64_t v20 = objc_autoreleasePoolPush();
      if (qword_100219F60) {
        [qword_100219F60 WFLog:@"%s:interface is NULL!" message:3];
      }
      objc_autoreleasePoolPop(v20);
      uint64_t v12 = v10;
      goto LABEL_19;
    }

    uint64_t v12 = v11;
    if ((sub_10003BEEC((uint64_t)v10) & 1) != 0)
    {
      uint64_t v15 = sub_10003C078((uint64_t)v10, v12);
      uint64_t v16 = objc_autoreleasePoolPush();
      if (v15)
      {
        if (qword_100219F60) {
          [(id)qword_100219F60 WFLog:3, "Destroy EAP trust exceptions sent by: %@", sub_10003BEDC((uint64_t)v10) message];
        }
        objc_autoreleasePoolPop(v16);
        int v17 = sub_1000F0CB8((uint64_t)v15, v12);
        CFPropertyListRef v18 = objc_autoreleasePoolPush();
        if (v17)
        {
          if (qword_100219F60) {
            [qword_100219F60 WFLog:@"%s Did destroy EAP trust exceptions for the current network." message:3];
          }
          objc_autoreleasePoolPop(v18);
          *a4 = 0;
        }

        else
        {
          if (qword_100219F60) {
            [qword_100219F60 WFLog:@"%s **Failed to destroy EAP trust exceptions for the current network." message:3];
          }
          objc_autoreleasePoolPop(v18);
          *a4 = -3900;
        }

        goto LABEL_18;
      }

      if (qword_100219F60) {
        [(id)qword_100219F60 WFLog:4, "%s: unable to find device manager for interface %@", "_wifi_device_destroy_eap_trust_current_network", v12 message];
      }
      uint64_t v14 = v16;
    }

    else
    {
      CFDictionaryRef v13 = objc_autoreleasePoolPush();
      if (qword_100219F60) {
        [(id)qword_100219F60 WFLog:4, "%s Client %@ has no entitlement", "kern_return_t _wifi_device_destroy_eap_trust_current_network(mach_port_t, vm_offset_t, mach_msg_type_number_t, int *)", sub_10003BEDC((uint64_t)v10) message];
      }
      uint64_t v14 = v13;
    }

    objc_autoreleasePoolPop(v14);
LABEL_18:
    CFRelease(v10);
LABEL_19:
    CFRelease(v12);
  }

  return 0LL;
}

uint64_t sub_1000BA690(unsigned int a1)
{
  uint64_t v2 = sub_10003B8D0();
  __int128 v3 = sub_10009137C(a1, v2);
  if (v3)
  {
    uint64_t v4 = v3;
    if ((sub_10003BEEC((uint64_t)v3) & 1) != 0)
    {
      if (sub_10003BEC4((uint64_t)v4))
      {
        uint64_t v6 = objc_autoreleasePoolPush();
        if (qword_100219F60) {
          [(id)qword_100219F60 WFLog:3, "Trigger gizmo/IDS sync engine to check for password changes %@", sub_10003BEDC((uint64_t)v4) message];
        }
        objc_autoreleasePoolPop(v6);
        sub_100081C8C();
      }
    }

    else
    {
      uint64_t v5 = objc_autoreleasePoolPush();
      if (qword_100219F60) {
        [(id)qword_100219F60 WFLog:4, "%s Client %@ has no entitlement", "kern_return_t _wifi_manager_tigger_gizmo_sync_password_check(mach_port_t)", sub_10003BEDC((uint64_t)v4) message];
      }
      objc_autoreleasePoolPop(v5);
    }

    CFRelease(v4);
  }

  return 0LL;
}

uint64_t sub_1000BA78C(unsigned int a1, vm_offset_t *a2, mach_msg_type_number_t *a3)
{
  *a2 = 0LL;
  *a3 = 0;
  uint64_t v6 = sub_10003B8D0();
  uint64_t v7 = sub_10009137C(a1, v6);
  if (v7)
  {
    uint64_t v8 = v7;
    if ((sub_10003BEEC((uint64_t)v7) & 1) == 0)
    {
      uint64_t v9 = objc_autoreleasePoolPush();
      if (qword_100219F60) {
        [(id)qword_100219F60 WFLog:4, "%s Client %@ has no entitlement", "kern_return_t _wifi_manager_copy_ssid_most_used_geo_tagged_to_current_location(mach_port_t, vm_offset_t *, mac h_msg_type_number_t *)", sub_10003BEDC((uint64_t)v8) message];
      }
LABEL_10:
      objc_autoreleasePoolPop(v9);
      goto LABEL_11;
    }

    uint64_t v10 = sub_10003BEC4((uint64_t)v8);
    if (v10)
    {
      CFStringRef v11 = sub_100081CA0(v10);
      if (!v11)
      {
        uint64_t v9 = objc_autoreleasePoolPush();
        if (qword_100219F60) {
          objc_msgSend( (id)qword_100219F60,  "WFLog:message:",  4,  "Unable to copy SSID representing most used network that's geo tagged to current device location",  v14,  v15);
        }
        goto LABEL_10;
      }

      CFStringRef v12 = v11;
      sub_10003A920(v11, a2, a3);
      CFRelease(v12);
    }

uint64_t sub_1000BA890(unsigned int a1, _DWORD *a2)
{
  if (!a2) {
    return 0LL;
  }
  *a2 = 0;
  uint64_t v4 = sub_10003B8D0();
  uint64_t v5 = sub_10009137C(a1, v4);
  if (!v5) {
    return 0LL;
  }
  uint64_t v6 = v5;
  if ((sub_10003BEEC((uint64_t)v5) & 1) != 0)
  {
    uint64_t v9 = sub_10003BEC4((uint64_t)v6);
    uint64_t v8 = 0LL;
    if (v9) {
      *a2 = sub_1000821A4(v9);
    }
  }

  else
  {
    uint64_t v7 = objc_autoreleasePoolPush();
    if (qword_100219F60) {
      [(id)qword_100219F60 WFLog:4, "%s Client %@ has no entitlement", "kern_return_t _wifi_manager_is_wpa3_personal_supported(mach_port_t, int *)", sub_10003BEDC((uint64_t)v6) message];
    }
    objc_autoreleasePoolPop(v7);
    uint64_t v8 = 2LL;
  }

  CFRelease(v6);
  return v8;
}

uint64_t sub_1000BA96C(unsigned int a1, _DWORD *a2)
{
  if (!a2) {
    return 0LL;
  }
  *a2 = 0;
  uint64_t v4 = sub_10003B8D0();
  uint64_t v5 = sub_10009137C(a1, v4);
  if (!v5) {
    return 0LL;
  }
  uint64_t v6 = v5;
  if ((sub_10003BEEC((uint64_t)v5) & 1) != 0)
  {
    uint64_t v9 = sub_10003BEC4((uint64_t)v6);
    uint64_t v8 = 0LL;
    if (v9) {
      *a2 = sub_10008222C(v9);
    }
  }

  else
  {
    uint64_t v7 = objc_autoreleasePoolPush();
    if (qword_100219F60) {
      [(id)qword_100219F60 WFLog:4, "%s Client %@ has no entitlement", "kern_return_t _wifi_manager_is_hotspot_wpa3_personal_supported(mach_port_t, int *)", sub_10003BEDC((uint64_t)v6) message];
    }
    objc_autoreleasePoolPop(v7);
    uint64_t v8 = 2LL;
  }

  CFRelease(v6);
  return v8;
}

uint64_t sub_1000BAA48(uint64_t a1, _DWORD *a2)
{
  *a2 = 0;
  return 0LL;
}

uint64_t sub_1000BAA54(unsigned int a1, _DWORD *a2)
{
  if (!a2) {
    return 0LL;
  }
  *a2 = 0;
  uint64_t v4 = sub_10003B8D0();
  uint64_t v5 = sub_10009137C(a1, v4);
  if (!v5) {
    return 0LL;
  }
  uint64_t v6 = v5;
  if ((sub_10003BEEC((uint64_t)v5) & 1) != 0)
  {
    uint64_t v9 = sub_10003BEC4((uint64_t)v6);
    uint64_t v8 = 0LL;
    if (v9) {
      *a2 = sub_1000821E8(v9);
    }
  }

  else
  {
    uint64_t v7 = objc_autoreleasePoolPush();
    if (qword_100219F60) {
      [(id)qword_100219F60 WFLog:4, "%s Client %@ has no entitlement", "kern_return_t _wifi_manager_is_wpa3_enterprise_supported(mach_port_t, int *)", sub_10003BEDC((uint64_t)v6) message];
    }
    objc_autoreleasePoolPop(v7);
    uint64_t v8 = 2LL;
  }

  CFRelease(v6);
  return v8;
}

uint64_t sub_1000BAB30(unsigned int a1, _DWORD *a2)
{
  if (!a2) {
    return 0LL;
  }
  *a2 = 0;
  uint64_t v4 = sub_10003B8D0();
  uint64_t v5 = sub_10009137C(a1, v4);
  if (!v5) {
    return 0LL;
  }
  uint64_t v6 = v5;
  if ((sub_10003BEEC((uint64_t)v5) & 1) != 0)
  {
    uint64_t v9 = sub_10003BEC4((uint64_t)v6);
    uint64_t v8 = 0LL;
    if (v9) {
      *a2 = sub_100082270(v9);
    }
  }

  else
  {
    uint64_t v7 = objc_autoreleasePoolPush();
    if (qword_100219F60) {
      [(id)qword_100219F60 WFLog:4, "%s Client %@ has no entitlement", "kern_return_t _wifi_manager_is_mfp_capable_device(mach_port_t, int *)", sub_10003BEDC((uint64_t)v6) message];
    }
    objc_autoreleasePoolPop(v7);
    uint64_t v8 = 2LL;
  }

  CFRelease(v6);
  return v8;
}

uint64_t sub_1000BAC0C(unsigned int a1, uint64_t a2)
{
  uint64_t v4 = sub_10003B8D0();
  uint64_t v5 = sub_10009137C(a1, v4);
  if (v5)
  {
    uint64_t v6 = v5;
    if ((sub_10003BEEC((uint64_t)v5) & 1) != 0)
    {
      uint64_t v8 = sub_10003BEC4((uint64_t)v6);
      if (v8)
      {
        uint64_t v9 = (_DWORD *)v8;
        uint64_t v10 = objc_autoreleasePoolPush();
        if (qword_100219F60) {
          [(id)qword_100219F60 WFLog:3, "%@ requested auto instant hotspot mode %d", sub_10003BEDC((uint64_t)v6), a2 message];
        }
        objc_autoreleasePoolPop(v10);
        sub_1000823EC(v9, a2, 0);
      }
    }

    else
    {
      uint64_t v7 = objc_autoreleasePoolPush();
      if (qword_100219F60) {
        [(id)qword_100219F60 WFLog:4, "%s Client %@ has no entitlement", "kern_return_t _wifi_manager_set_auto_instant_hotspot_mode(mach_port_t, int)", sub_10003BEDC((uint64_t)v6) message];
      }
      objc_autoreleasePoolPop(v7);
    }

    CFRelease(v6);
  }

  return 0LL;
}

uint64_t sub_1000BAD20(unsigned int a1, _DWORD *a2)
{
  *a2 = 1;
  uint64_t v4 = sub_10003B8D0();
  uint64_t v5 = sub_10009137C(a1, v4);
  if (v5)
  {
    uint64_t v6 = v5;
    if ((sub_10003BEEC((uint64_t)v5) & 1) != 0)
    {
      uint64_t v8 = sub_10003BEC4((uint64_t)v6);
      if (v8) {
        *a2 = sub_1000824A4(v8);
      }
    }

    else
    {
      uint64_t v7 = objc_autoreleasePoolPush();
      if (qword_100219F60) {
        [(id)qword_100219F60 WFLog:4, "%s Client %@ has no entitlement", "kern_return_t _wifi_manager_get_auto_instant_hotspot_mode(mach_port_t, int *)", sub_10003BEDC((uint64_t)v6) message];
      }
      objc_autoreleasePoolPop(v7);
    }

    CFRelease(v6);
  }

  return 0LL;
}

uint64_t sub_1000BADE4(unsigned int a1, uint64_t a2)
{
  uint64_t v4 = sub_10003B8D0();
  uint64_t v5 = sub_10009137C(a1, v4);
  if (v5)
  {
    uint64_t v6 = v5;
    if ((sub_10003BEEC((uint64_t)v5) & 1) != 0)
    {
      uint64_t v8 = sub_10003BEC4((uint64_t)v6);
      if (v8)
      {
        uint64_t v9 = v8;
        uint64_t v10 = objc_autoreleasePoolPush();
        if (qword_100219F60) {
          [(id)qword_100219F60 WFLog:3, "%@ requested Set Share My Personal Hotspot mode %d", sub_10003BEDC((uint64_t)v6), a2 message];
        }
        objc_autoreleasePoolPop(v10);
        sub_100082454(v9, a2, 0);
      }
    }

    else
    {
      uint64_t v7 = objc_autoreleasePoolPush();
      if (qword_100219F60) {
        [(id)qword_100219F60 WFLog:4, "%s Client %@ has no entitlement", "kern_return_t _wifi_manager_set_share_personal_hotspot_mode(mach_port_t, int)", sub_10003BEDC((uint64_t)v6) message];
      }
      objc_autoreleasePoolPop(v7);
    }

    CFRelease(v6);
  }

  return 0LL;
}

uint64_t sub_1000BAEF4(unsigned int a1, _DWORD *a2)
{
  *a2 = 1;
  uint64_t v4 = sub_10003B8D0();
  uint64_t v5 = sub_10009137C(a1, v4);
  if (v5)
  {
    uint64_t v6 = v5;
    if ((sub_10003BEEC((uint64_t)v5) & 1) != 0)
    {
      uint64_t v8 = sub_10003BEC4((uint64_t)v6);
      if (v8) {
        *a2 = sub_100082518(v8);
      }
    }

    else
    {
      uint64_t v7 = objc_autoreleasePoolPush();
      if (qword_100219F60) {
        [(id)qword_100219F60 WFLog:4, "%s Client %@ has no entitlement", "kern_return_t _wifi_manager_get_share_personal_hotspot_mode(mach_port_t, int *)", sub_10003BEDC((uint64_t)v6) message];
      }
      objc_autoreleasePoolPop(v7);
    }

    CFRelease(v6);
  }

  return 0LL;
}

uint64_t sub_1000BAFB8(unsigned int a1, uint64_t a2)
{
  uint64_t v4 = sub_10003B8D0();
  uint64_t v5 = sub_10009137C(a1, v4);
  if (v5)
  {
    uint64_t v6 = v5;
    if ((sub_10003BEEC((uint64_t)v5) & 1) != 0)
    {
      uint64_t v8 = sub_10003BEC4((uint64_t)v6);
      if (v8)
      {
        uint64_t v9 = v8;
        uint64_t v10 = objc_autoreleasePoolPush();
        if (qword_100219F60) {
          [(id)qword_100219F60 WFLog:3, "%@ requested Set AutoInstant Hotspot Test Mode %d", sub_10003BEDC((uint64_t)v6), a2 message];
        }
        objc_autoreleasePoolPop(v10);
        sub_1000825D4(v9, a2);
      }
    }

    else
    {
      uint64_t v7 = objc_autoreleasePoolPush();
      if (qword_100219F60) {
        [(id)qword_100219F60 WFLog:4, "%s Client %@ has no entitlement", "kern_return_t _wifi_manager_set_auto_instant_hotspot_test_mode(mach_port_t, int)", sub_10003BEDC((uint64_t)v6) message];
      }
      objc_autoreleasePoolPop(v7);
    }

    CFRelease(v6);
  }

  return 0LL;
}

uint64_t sub_1000BB0C8(unsigned int a1, double a2)
{
  uint64_t v4 = sub_10003B8D0();
  uint64_t v5 = sub_10009137C(a1, v4);
  if (v5)
  {
    uint64_t v6 = v5;
    if ((sub_10003BEEC((uint64_t)v5) & 1) != 0)
    {
      uint64_t v8 = sub_10003BEC4((uint64_t)v6);
      if (v8)
      {
        uint64_t v9 = v8;
        uint64_t v10 = objc_autoreleasePoolPush();
        if (qword_100219F60) {
          [(id)qword_100219F60 WFLog:3, "%@ requested auto instant hotspot trigger interval %f seconds ", sub_10003BEDC((uint64_t)v6), *(void *)&a2 message];
        }
        objc_autoreleasePoolPop(v10);
        sub_1000825B0(v9, a2);
      }
    }

    else
    {
      uint64_t v7 = objc_autoreleasePoolPush();
      if (qword_100219F60) {
        [(id)qword_100219F60 WFLog:4, "%s Client %@ has no entitlement", "kern_return_t _wifi_manager_set_auto_instant_hotspot_trigger_interval(mach_port_t, double)", sub_10003BEDC((uint64_t)v6) message];
      }
      objc_autoreleasePoolPop(v7);
    }

    CFRelease(v6);
  }

  return 0LL;
}

uint64_t sub_1000BB1D8(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, _DWORD *a5)
{
  *a5 = 0;
  return 0LL;
}

uint64_t sub_1000BB1E4(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, _DWORD *a6)
{
  *a6 = -3903;
  return 0LL;
}

uint64_t sub_1000BB1F4(unsigned int a1, _DWORD *a2)
{
  *a2 = 0;
  uint64_t v4 = sub_10003B8D0();
  uint64_t v5 = sub_10009137C(a1, v4);
  if (v5)
  {
    uint64_t v6 = v5;
    if ((sub_10003BEEC((uint64_t)v5) & 1) != 0)
    {
      uint64_t v8 = sub_10003BEC4((uint64_t)v6);
      if (v8) {
        *a2 = sub_1000822D0(v8, 1LL);
      }
    }

    else
    {
      uint64_t v7 = objc_autoreleasePoolPush();
      if (qword_100219F60) {
        [(id)qword_100219F60 WFLog:4, "%s Client %@ has no entitlement", "kern_return_t _wifi_manager_is_infra_allowed(mach_port_t, int *)", sub_10003BEDC((uint64_t)v6) message];
      }
      objc_autoreleasePoolPop(v7);
    }

    CFRelease(v6);
  }

  return 0LL;
}

uint64_t sub_1000BB2B8(unsigned int a1, _DWORD *a2)
{
  *a2 = 0;
  uint64_t v4 = sub_10003B8D0();
  uint64_t v5 = sub_10009137C(a1, v4);
  if (v5)
  {
    uint64_t v6 = v5;
    if ((sub_10003BEEC((uint64_t)v5) & 1) != 0)
    {
      uint64_t v8 = sub_10003BEC4((uint64_t)v6);
      if (v8) {
        *a2 = sub_1000822B4(v8, 2);
      }
    }

    else
    {
      uint64_t v7 = objc_autoreleasePoolPush();
      if (qword_100219F60) {
        [(id)qword_100219F60 WFLog:4, "%s Client %@ has no entitlement", "kern_return_t _wifi_manager_is_p2p_allowed(mach_port_t, int *)", sub_10003BEDC((uint64_t)v6) message];
      }
      objc_autoreleasePoolPop(v7);
    }

    CFRelease(v6);
  }

  return 0LL;
}

uint64_t sub_1000BB37C( unsigned int a1, UInt8 *a2, CFIndex a3, UInt8 *a4, unsigned int a5, UInt8 *a6, unsigned int a7, _DWORD *a8)
{
  *a8 = 0;
  uint64_t v16 = sub_10003B8D0();
  int v17 = sub_10009137C(a1, v16);
  if (v17)
  {
    CFPropertyListRef v18 = v17;
    if ((sub_10003BEEC((uint64_t)v17) & 1) != 0)
    {
      uint64_t v20 = sub_10003BEC4((uint64_t)v18);
      if (v20)
      {
        uint64_t v21 = v20;
        uint64_t v22 = sub_1000B1C5C(a2, a3);
        if (v22)
        {
          int v23 = v22;
          unsigned int v29 = a5;
          int v30 = a4;
          unsigned int v24 = (void *)sub_10003A7C0(a4, a5);
          CFPropertyListRef v25 = sub_10003A7C0(a6, a7);
          if (v24)
          {
            int v26 = objc_autoreleasePoolPush();
            if (qword_100219F60) {
              [(id)qword_100219F60 WFLog:3, "ManagerClient[%@] setNetworkProperty[%@] = %@", sub_10003BEDC((uint64_t)v18), v24, v25 message];
            }
            objc_autoreleasePoolPop(v26);
            if (!sub_100078E60(v21, v23, v24, v25))
            {
              int v27 = objc_autoreleasePoolPush();
              if (qword_100219F60) {
                [(id)qword_100219F60 WFLog:4 message:"unable to set property"];
              }
              objc_autoreleasePoolPop(v27);
            }

            CFRelease(v24);
          }

          if (v25) {
            CFRelease(v25);
          }
          CFRelease(v18);
          CFPropertyListRef v18 = v23;
          a4 = v30;
          a5 = v29;
        }
      }
    }

    else
    {
      CFPropertyListRef v19 = objc_autoreleasePoolPush();
      if (qword_100219F60) {
        [(id)qword_100219F60 WFLog:4, "%s Client %@ has no entitlement", "kern_return_t _wifi_manager_set_network_property(mach_port_t, vm_offset_t, mach_msg_type_number_t, vm_offset_t, mach_msg_type_number_t, vm_offset_t, mach_msg_type_number_t, int *)", sub_10003BEDC((uint64_t)v18) message];
      }
      objc_autoreleasePoolPop(v19);
      *a8 = 1;
    }

    CFRelease(v18);
  }

  sub_10003A8FC((vm_address_t)a4, a5);
  sub_10003A8FC((vm_address_t)a6, a7);
  sub_10003A8FC((vm_address_t)a2, a3);
  return 0LL;
}

uint64_t sub_1000BB5A8(unsigned int a1, vm_offset_t *a2, mach_msg_type_number_t *a3)
{
  *a2 = 0LL;
  *a3 = 0;
  uint64_t v6 = sub_10003B8D0();
  uint64_t v7 = sub_10009137C(a1, v6);
  if (v7)
  {
    uint64_t v8 = v7;
    if ((sub_10003BEEC((uint64_t)v7) & 1) != 0)
    {
      uint64_t v10 = (void *)sub_10003BEC4((uint64_t)v8);
      if (v10)
      {
        CFStringRef v11 = sub_100082828(v10);
        if (v11)
        {
          CFStringRef v12 = v11;
          sub_10003A920(v11, a2, a3);
          CFRelease(v8);
          uint64_t v8 = v12;
        }
      }
    }

    else
    {
      uint64_t v9 = objc_autoreleasePoolPush();
      if (qword_100219F60) {
        [(id)qword_100219F60 WFLog:4, "%s Client %@ has no entitlement", "kern_return_t _wifi_manager_copy_family_hotspot_preferences(mach_port_t, vm_offset_t *, mach_msg_type_number_t *)", sub_10003BEDC((uint64_t)v8) message];
      }
      objc_autoreleasePoolPop(v9);
    }

    CFRelease(v8);
  }

  return 0LL;
}

uint64_t sub_1000BB68C(unsigned int a1, _DWORD *a2)
{
  *a2 = 0;
  uint64_t v4 = sub_10003B8D0();
  uint64_t v5 = sub_10009137C(a1, v4);
  if (v5)
  {
    uint64_t v6 = v5;
    if ((sub_10003BEEC((uint64_t)v5) & 1) != 0)
    {
      uint64_t v8 = sub_10003BEC4((uint64_t)v6);
      if (v8) {
        *a2 = sub_10006FCE4(v8);
      }
    }

    else
    {
      uint64_t v7 = objc_autoreleasePoolPush();
      if (qword_100219F60) {
        [(id)qword_100219F60 WFLog:4, "%s Client %@ has no entitlement", "kern_return_t _wifi_manager_is_power_modification_disabled(mach_port_t, int *)", sub_10003BEDC((uint64_t)v6) message];
      }
      objc_autoreleasePoolPop(v7);
    }

    CFRelease(v6);
  }

  return 0LL;
}

uint64_t sub_1000BB74C(unsigned int a1, _DWORD *a2)
{
  *a2 = 0;
  uint64_t v4 = sub_10003B8D0();
  uint64_t v5 = sub_10009137C(a1, v4);
  if (v5)
  {
    uint64_t v6 = v5;
    if ((sub_10003BEEC((uint64_t)v5) & 1) != 0)
    {
      uint64_t v8 = sub_10003BEC4((uint64_t)v6);
      if (v8) {
        *a2 = sub_100082C08(v8);
      }
    }

    else
    {
      uint64_t v7 = objc_autoreleasePoolPush();
      if (qword_100219F60) {
        [(id)qword_100219F60 WFLog:4, "%s Client %@ has no entitlement", "kern_return_t _wifi_manager_is_personal_hotspot_modification_disabled(mach_port_t, int *)", sub_10003BEDC((uint64_t)v6) message];
      }
      objc_autoreleasePoolPop(v7);
    }

    CFRelease(v6);
  }

  return 0LL;
}

uint64_t sub_1000BB80C( unsigned int a1, UInt8 *a2, unsigned int a3, vm_offset_t *a4, mach_msg_type_number_t *a5)
{
  *a4 = 0LL;
  *a5 = 0;
  uint64_t v10 = sub_10003B8D0();
  CFStringRef v11 = (NSMutableArray *)sub_10009137C(a1, v10);
  if (v11)
  {
    CFStringRef v12 = v11;
    if ((sub_10003BEEC((uint64_t)v11) & 1) == 0)
    {
      CFDictionaryRef v13 = objc_autoreleasePoolPush();
      if (qword_100219F60) {
        [(id)qword_100219F60 WFLog:4, "%s Client %@ has no entitlement", "kern_return_t _wifi_device_copy_network_recommendations(mach_port_t, vm_offset_t, mach_msg_type_number_t, vm_o ffset_t *, mach_msg_type_number_t *)", sub_10003BEDC((uint64_t)v12) message];
      }
      objc_autoreleasePoolPop(v13);
LABEL_11:
      CFRelease(v12);
      goto LABEL_12;
    }

    CFPropertyListRef v14 = sub_10003A7C0(a2, a3);
    if (!v14) {
      goto LABEL_11;
    }
    uint64_t v15 = v14;
    uint64_t v16 = sub_10003C078((uint64_t)v12, v14);
    if (v16)
    {
      int v17 = sub_1000F2C9C((uint64_t)v16);
      CFPropertyListRef v18 = v17;
      if (v17) {
        sub_10003A920(v17, a4, a5);
      }
    }

    else
    {
      CFPropertyListRef v18 = 0LL;
    }

    CFRelease(v15);
    CFRelease(v12);
    CFStringRef v12 = v18;
    if (v18) {
      goto LABEL_11;
    }
  }

uint64_t sub_1000BB944(unsigned int a1, UInt8 *a2, unsigned int a3)
{
  uint64_t v6 = sub_10003B8D0();
  uint64_t v7 = sub_10009137C(a1, v6);
  if (v7)
  {
    uint64_t v8 = v7;
    if ((sub_10003BEEC((uint64_t)v7) & 1) != 0)
    {
      CFPropertyListRef v10 = sub_10003A7C0(a2, a3);
      if (v10)
      {
        CFStringRef v11 = v10;
        CFStringRef v12 = sub_10003C078((uint64_t)v8, v10);
        if (v12)
        {
          sub_1000F3158((uint64_t)v12);
          CFDictionaryRef v13 = (void *)sub_10003BEC4((uint64_t)v8);
          if (v13) {
            sub_100082A4C(v13);
          }
        }

        CFRelease(v11);
      }
    }

    else
    {
      uint64_t v9 = objc_autoreleasePoolPush();
      if (qword_100219F60) {
        [(id)qword_100219F60 WFLog:4, "%s Client %@ has no entitlement", "kern_return_t _wifi_device_reset_availability_engine(mach_port_t, vm_offset_t, mach_msg_type_number_t)", sub_10003BEDC((uint64_t)v8) message];
      }
      objc_autoreleasePoolPop(v9);
    }

    CFRelease(v8);
  }

  sub_10003A8FC((vm_address_t)a2, a3);
  return 0LL;
}

uint64_t sub_1000BBA44(unsigned int a1, UInt8 *a2, unsigned int a3)
{
  uint64_t v6 = sub_10003B8D0();
  uint64_t v7 = sub_10009137C(a1, v6);
  if (v7)
  {
    uint64_t v8 = v7;
    if ((sub_10003BEEC((uint64_t)v7) & 1) != 0)
    {
      uint64_t v10 = sub_10003BEC4((uint64_t)v8);
      if (v10)
      {
        CFStringRef v11 = (const __CFNumber *)v10;
        CFStringRef v12 = (const __CFDictionary *)sub_10003A7C0(a2, a3);
        sub_100082F78(v11, v12);
        if (v12) {
          CFRelease(v12);
        }
      }
    }

    else
    {
      uint64_t v9 = objc_autoreleasePoolPush();
      if (qword_100219F60) {
        [(id)qword_100219F60 WFLog:4, "%s Client %@ has no entitlement", "kern_return_t _wifi_manager_set_user_interaction_override(mach_port_t, vm_offset_t, mach_msg_type_number_t)", sub_10003BEDC((uint64_t)v8) message];
      }
      objc_autoreleasePoolPop(v9);
    }

    CFRelease(v8);
  }

  sub_10003A8FC((vm_address_t)a2, a3);
  return 0LL;
}

uint64_t sub_1000BBB3C(unsigned int a1, UInt8 *a2, unsigned int a3)
{
  uint64_t v6 = sub_10003B8D0();
  uint64_t v7 = sub_10009137C(a1, v6);
  if (v7)
  {
    uint64_t v8 = v7;
    if ((sub_10003BEEC((uint64_t)v7) & 1) != 0)
    {
      uint64_t v10 = sub_10003BEC4((uint64_t)v8);
      if (v10)
      {
        CFStringRef v11 = (const __CFNumber *)v10;
        CFStringRef v12 = (const __CFDictionary *)sub_10003A7C0(a2, a3);
        sub_100083078(v11, v12);
        if (v12) {
          CFRelease(v12);
        }
      }
    }

    else
    {
      uint64_t v9 = objc_autoreleasePoolPush();
      if (qword_100219F60) {
        [(id)qword_100219F60 WFLog:4, "%s Client %@ has no entitlement", "kern_return_t _wifi_manager_set_user_interaction_nw_override(mach_port_t, vm_offset_t, mach_msg_type_number_t)", sub_10003BEDC((uint64_t)v8) message];
      }
      objc_autoreleasePoolPop(v9);
    }

    CFRelease(v8);
  }

  sub_10003A8FC((vm_address_t)a2, a3);
  return 0LL;
}

uint64_t sub_1000BBC34( unsigned int a1, UInt8 *a2, unsigned int a3, uint64_t a4, UInt8 *a5, unsigned int a6, _DWORD *a7)
{
  *a7 = 0;
  uint64_t v13 = sub_10003B8D0();
  CFPropertyListRef v14 = sub_10009137C(a1, v13);
  if (v14)
  {
    uint64_t v15 = v14;
    if ((sub_10003BEEC((uint64_t)v14) & 1) == 0)
    {
      uint64_t v16 = objc_autoreleasePoolPush();
      if (qword_100219F60) {
        [(id)qword_100219F60 WFLog:4, "%s Client %@ has no entitlement", "kern_return_t _wifi_manager_set_private_mac_pref(mach_port_t, vm_offset_t, mach_msg_type_number_t, int, vm_off set_t, mach_msg_type_number_t, int *)", sub_10003BEDC((uint64_t)v15) message];
      }
      objc_autoreleasePoolPop(v16);
      *a7 = 1;
      goto LABEL_6;
    }

    if (!sub_10003BEC4((uint64_t)v15) || (CFPropertyListRef v18 = sub_10003A7C0(a2, a3)) == 0LL)
    {
LABEL_6:
      CFPropertyListRef v17 = v15;
LABEL_14:
      CFRelease(v17);
      goto LABEL_15;
    }

    CFPropertyListRef v19 = v18;
    CFPropertyListRef v17 = sub_10003A7C0(a5, a6);
    if (!sub_10000B784())
    {
      uint64_t v20 = objc_autoreleasePoolPush();
      if (qword_100219F60) {
        [(id)qword_100219F60 WFLog:4 message:"WFMacRandomisation : Unable to Set private mac preference"];
      }
      objc_autoreleasePoolPop(v20);
    }

    CFRelease(v19);
    CFRelease(v15);
    if (v17) {
      goto LABEL_14;
    }
  }

uint64_t sub_1000BBDB4( unsigned int a1, UInt8 *a2, unsigned int a3, UInt8 *a4, unsigned int a5, vm_offset_t *a6, mach_msg_type_number_t *a7)
{
  uint64_t v14 = sub_10003B8D0();
  uint64_t v15 = (const __CFDictionary *)sub_10009137C(a1, v14);
  if (!v15) {
    goto LABEL_21;
  }
  uint64_t v16 = v15;
  if ((sub_10003BEEC((uint64_t)v15) & 1) == 0)
  {
    CFPropertyListRef v17 = objc_autoreleasePoolPush();
    if (qword_100219F60) {
      [(id)qword_100219F60 WFLog:4, "%s Client %@ has no entitlement", "kern_return_t _wifi_device_bssblacklist_command(mach_port_t, vm_offset_t, mach_msg_type_number_t, vm_offset_t, m ach_msg_type_number_t, vm_offset_t *, mach_msg_type_number_t *)", sub_10003BEDC((uint64_t)v16) message];
    }
LABEL_5:
    objc_autoreleasePoolPop(v17);
LABEL_20:
    CFRelease(v16);
    goto LABEL_21;
  }

  CFPropertyListRef v18 = sub_10003A7C0(a2, a3);
  if (!v18)
  {
    CFPropertyListRef v17 = objc_autoreleasePoolPush();
    if (qword_100219F60) {
      [qword_100219F60 WFLog:@"%s:interface is NULL!" message:3];
    }
    goto LABEL_5;
  }

  CFPropertyListRef v19 = v18;
  uint64_t v20 = sub_10003C078((uint64_t)v16, v18);
  uint64_t v33 = a4;
  if (v20)
  {
    uint64_t v21 = (uint64_t)v20;
    uint64_t v22 = (const __CFDictionary *)sub_10003A7C0(a4, a5);
    int v23 = objc_autoreleasePoolPush();
    if (qword_100219F60) {
      [(id)qword_100219F60 WFLog:3, "%s: Calling WiFiDeviceManagerProcessBssBlacklistCommandsAndCopyResponse with request:%@", "_wifi_device_bssblacklist_command", v22 message];
    }
    objc_autoreleasePoolPop(v23);
    unsigned int v24 = sub_1000F3238(v21, v22);
    CFPropertyListRef v25 = v24;
    if (v24)
    {
      if (CFDictionaryContainsKey(v24, @"networks"))
      {
        if (CFDictionaryContainsKey(v25, @"reasons"))
        {
          if (CFDictionaryContainsKey(v25, @"timestamps"))
          {
            if (CFDictionaryContainsKey(v25, @"reasonData"))
            {
              CFBooleanRef Value = (const __CFArray *)CFDictionaryGetValue(v25, @"networks");
              int v27 = sub_10003A464(Value);
              if (v27)
              {
                uint64_t v28 = v27;
                CFDictionarySetValue(v25, @"networks", v27);
                CFRelease(v28);
                sub_10003A920(v25, a6, a7);
                goto LABEL_17;
              }

              uint64_t v31 = objc_autoreleasePoolPush();
              if (qword_100219F60) {
                [qword_100219F60 WFLog:@"_wifi_device_bssblacklist_command - _WiFiCreateRecordsFromNetworks failed" message:3];
              }
            }

            else
            {
              uint64_t v31 = objc_autoreleasePoolPush();
              if (qword_100219F60) {
                [qword_100219F60 WFLog:@"message: %s No blacklist reasonData in response" message:3];
              }
            }
          }

          else
          {
            uint64_t v31 = objc_autoreleasePoolPush();
            if (qword_100219F60) {
              [qword_100219F60 WFLog:@"%s No blacklist timestamps in response" message:3];
            }
          }
        }

        else
        {
          uint64_t v31 = objc_autoreleasePoolPush();
          if (qword_100219F60) {
            [qword_100219F60 WFLog:@"%s No blacklist reasons in response" message:3];
          }
        }
      }

      else
      {
        uint64_t v31 = objc_autoreleasePoolPush();
        if (qword_100219F60) {
          [qword_100219F60 WFLog:@"%s No blacklisted WiFiNetworkRef (records) in response" message:3];
        }
      }

      objc_autoreleasePoolPop(v31);
    }
  }

  else
  {
    int v30 = objc_autoreleasePoolPush();
    if (qword_100219F60) {
      [(id)qword_100219F60 WFLog:4, "%s: unable to find device manager for interface %@", "_wifi_device_bssblacklist_command", v19 message];
    }
    objc_autoreleasePoolPop(v30);
    uint64_t v22 = 0LL;
    CFPropertyListRef v25 = 0LL;
  }

uint64_t sub_1000BC168(unsigned int a1, UInt8 *a2, unsigned int a3, UInt8 *a4, CFIndex a5)
{
  uint64_t v10 = sub_10003B8D0();
  CFStringRef v11 = sub_10009137C(a1, v10);
  if (v11)
  {
    CFStringRef v12 = v11;
    if ((sub_10003BEEC((uint64_t)v11) & 1) == 0)
    {
      uint64_t v13 = objc_autoreleasePoolPush();
      if (qword_100219F60) {
        [(id)qword_100219F60 WFLog:4, "%s Client %@ has no entitlement", "kern_return_t _wifi_device_update_network_property(mach_port_t, vm_offset_t, mach_msg_type_number_t, vm_offset _t, mach_msg_type_number_t)", sub_10003BEDC((uint64_t)v12) message];
      }
      objc_autoreleasePoolPop(v13);
      goto LABEL_6;
    }

    uint64_t v15 = sub_10003BEC4((uint64_t)v12);
    if (!v15 || (uint64_t v16 = v15, (v17 = sub_1000B1C5C(a4, a5)) == 0LL))
    {
LABEL_6:
      CFPropertyListRef v14 = v12;
LABEL_14:
      CFRelease(v14);
      goto LABEL_15;
    }

    CFPropertyListRef v18 = v17;
    unsigned int v26 = a3;
    CFPropertyListRef v14 = sub_10003A7C0(a2, a3);
    uint64_t v19 = sub_10003BEDC((uint64_t)v12);
    uint64_t v20 = sub_10003C078((uint64_t)v12, v14);
    if (v20)
    {
      uint64_t v21 = (uint64_t)v20;
      uint64_t v22 = objc_autoreleasePoolPush();
      if (qword_100219F60) {
        [(id)qword_100219F60 WFLog:3, "Update network <%@>, requested by %@", sub_100095BC8(v18), v19 message];
      }
      objc_autoreleasePoolPop(v22);
      sub_100077498(v16, v18, 1u);
      unsigned int v23 = [sub_1000A063C((CFDictionaryRef *)v18) disable6EMode] == (id)2;
      unsigned int v24 = sub_100095BC8(v18);
      sub_1000DF8C0(v21, v14, v24, v23);
    }

    CFRelease(v18);
    CFRelease(v12);
    a3 = v26;
    if (v14) {
      goto LABEL_14;
    }
  }

uint64_t sub_1000BC34C(unsigned int a1, UInt8 *a2, unsigned int a3)
{
  uint64_t v6 = sub_10003B8D0();
  uint64_t v7 = sub_10009137C(a1, v6);
  if (v7)
  {
    uint64_t v8 = v7;
    uint64_t v9 = sub_10003BEC4((uint64_t)v7);
    if (v9)
    {
      uint64_t v10 = v9;
      if ((sub_10003BEEC((uint64_t)v8) & 1) != 0)
      {
        CFPropertyListRef v12 = sub_10003A7C0(a2, a3);
        if (v12)
        {
          CFPropertyListRef v14 = v12;
          nullsub_1(v10, v12, v13);
          CFRelease(v14);
        }
      }

      else
      {
        CFStringRef v11 = objc_autoreleasePoolPush();
        if (qword_100219F60) {
          [(id)qword_100219F60 WFLog:4, "%s Client %@ has no entitlement", "kern_return_t _wifi_manager_set_mac_randomisation_params(mach_port_t, vm_offset_t, mach_msg_type_number_t)", sub_10003BEDC((uint64_t)v8) message];
        }
        objc_autoreleasePoolPop(v11);
      }
    }

    CFRelease(v8);
  }

  sub_10003A8FC((vm_address_t)a2, a3);
  return 0LL;
}

uint64_t sub_1000BC444(unsigned int a1, UInt8 *a2, CFIndex a3)
{
  uint64_t v6 = sub_10003B8D0();
  uint64_t v7 = sub_10009137C(a1, v6);
  if (v7)
  {
    uint64_t v8 = v7;
    if ((sub_10003BEEC((uint64_t)v7) & 1) != 0)
    {
      uint64_t v10 = sub_10003BEC4((uint64_t)v8);
      if (v10)
      {
        uint64_t v11 = v10;
        CFPropertyListRef v12 = sub_1000B1C5C(a2, a3);
        if (v12)
        {
          uint64_t v13 = v12;
          uint64_t v14 = sub_10003BEDC((uint64_t)v8);
          uint64_t v15 = objc_autoreleasePoolPush();
          if (qword_100219F60) {
            [(id)qword_100219F60 WFLog:3, "WFMacRandomisation : Update Private Mac Network <%@>, requested by %@", sub_100095BC8(v13), v14 message];
          }
          objc_autoreleasePoolPop(v15);
          sub_100083754(v11, v13);
          CFRelease(v13);
        }
      }
    }

    else
    {
      uint64_t v9 = objc_autoreleasePoolPush();
      if (qword_100219F60) {
        [(id)qword_100219F60 WFLog:4, "%s Client %@ has no entitlement", "kern_return_t _wifi_manager_update_privateMac_network(mach_port_t, vm_offset_t, mach_msg_type_number_t)", sub_10003BEDC((uint64_t)v8) message];
      }
      objc_autoreleasePoolPop(v9);
    }

    CFRelease(v8);
  }

  sub_10003A8FC((vm_address_t)a2, a3);
  return 0LL;
}

uint64_t sub_1000BC590(unsigned int a1, UInt8 *a2, CFIndex length, _DWORD *a4)
{
  unsigned int v5 = length;
  *a4 = 0;
  uint64_t v8 = sub_1000B1C5C(a2, length);
  if (v8)
  {
    uint64_t v9 = v8;
    uint64_t v10 = sub_10003B8D0();
    uint64_t v11 = sub_10009137C(a1, v10);
    if (!v11)
    {
LABEL_14:
      CFRelease(v9);
      goto LABEL_15;
    }

    CFPropertyListRef v12 = v11;
    if ((sub_10003BEEC((uint64_t)v11) & 1) != 0)
    {
      if (!sub_10003BEC4((uint64_t)v12))
      {
LABEL_13:
        CFRelease(v12);
        goto LABEL_14;
      }

      *a4 = sub_10000B784();
      uint64_t v13 = objc_autoreleasePoolPush();
      uint64_t v14 = (void *)qword_100219F60;
      if (qword_100219F60)
      {
        uint64_t v15 = sub_10003BEDC((uint64_t)v12);
        if (*a4) {
          uint64_t v16 = "Required";
        }
        else {
          uint64_t v16 = "Not Required";
        }
        [v14 WFLog:3, "Determining if special (quick) probe required for network. Client :  %@ Result %s", v15, v16 message];
      }
    }

    else
    {
      uint64_t v13 = objc_autoreleasePoolPush();
      if (qword_100219F60) {
        [(id)qword_100219F60 WFLog:4, "%s Client %@ has no entitlement", "kern_return_t _wifi_manager_private_mac_is_quick_probe_required(mach_port_t, vm_offset_t, mach_msg_type_number_t, int *)", sub_10003BEDC((uint64_t)v12) message];
      }
    }

    objc_autoreleasePoolPop(v13);
    goto LABEL_13;
  }

uint64_t sub_1000BC6E4(unsigned int a1, uint64_t a2, UInt8 *a3, CFIndex a4)
{
  uint64_t v8 = sub_10003B8D0();
  uint64_t v9 = sub_10009137C(a1, v8);
  if (v9)
  {
    uint64_t v10 = v9;
    if ((sub_10003BEEC((uint64_t)v9) & 1) != 0)
    {
      CFPropertyListRef v12 = sub_1000B1C5C(a3, a4);
      if (v12)
      {
        uint64_t v13 = v12;
        uint64_t v14 = sub_10003BEC4((uint64_t)v10);
        if (v14)
        {
          uint64_t v15 = v14;
          uint64_t v16 = objc_autoreleasePoolPush();
          if (qword_100219F60) {
            [(id)qword_100219F60 WFLog:3, "%@ WFMacRandomisation : private MAC probe result <%d>", sub_10003BEDC((uint64_t)v10), a2 message];
          }
          objc_autoreleasePoolPop(v16);
          nullsub_1(v15, v13, a2);
        }

        CFRelease(v10);
        uint64_t v10 = v13;
      }
    }

    else
    {
      uint64_t v11 = objc_autoreleasePoolPush();
      if (qword_100219F60) {
        [(id)qword_100219F60 WFLog:4, "%s Client %@ has no entitlement", "kern_return_t _wifi_manager_private_mac_probe_result(mach_port_t, int, vm_offset_t, mach_msg_type_number_t)", sub_10003BEDC((uint64_t)v10) message];
      }
      objc_autoreleasePoolPop(v11);
    }

    CFRelease(v10);
  }

  sub_10003A8FC((vm_address_t)a3, a4);
  return 0LL;
}

uint64_t sub_1000BC830(unsigned int a1, UInt8 *a2, unsigned int a3)
{
  uint64_t v6 = sub_10003B8D0();
  uint64_t v7 = sub_10009137C(a1, v6);
  if (v7)
  {
    uint64_t v8 = v7;
    uint64_t v9 = sub_10003BEC4((uint64_t)v7);
    if (v9)
    {
      uint64_t v10 = v9;
      if ((sub_10003BEEC((uint64_t)v8) & 1) != 0)
      {
        CFPropertyListRef v12 = sub_10003A7C0(a2, a3);
        if (v12)
        {
          uint64_t v13 = v12;
          sub_10008370C(v10, (uint64_t)v12);
          CFRelease(v13);
        }
      }

      else
      {
        uint64_t v11 = objc_autoreleasePoolPush();
        if (qword_100219F60) {
          [(id)qword_100219F60 WFLog:4, "%s Client %@ has no entitlement", "kern_return_t _wifi_manager_set_adaptive_roam_params(mach_port_t, vm_offset_t, mach_msg_type_number_t)", sub_10003BEDC((uint64_t)v8) message];
        }
        objc_autoreleasePoolPop(v11);
      }
    }

    CFRelease(v8);
  }

  sub_10003A8FC((vm_address_t)a2, a3);
  return 0LL;
}

uint64_t sub_1000BC928(unsigned int a1, _DWORD *a2)
{
  *a2 = 0;
  uint64_t v4 = sub_10003B8D0();
  unsigned int v5 = sub_10009137C(a1, v4);
  if (v5)
  {
    uint64_t v6 = v5;
    if ((sub_10003BEEC((uint64_t)v5) & 1) != 0)
    {
      uint64_t v8 = sub_10003BEC4((uint64_t)v6);
      if (v8) {
        *a2 = sub_10006F5F4(v8);
      }
    }

    else
    {
      uint64_t v7 = objc_autoreleasePoolPush();
      if (qword_100219F60) {
        [(id)qword_100219F60 WFLog:4, "%s Client %@ has no entitlement", "kern_return_t _wifi_manager_is_multi_band(mach_port_t, int *)", sub_10003BEDC((uint64_t)v6) message];
      }
      objc_autoreleasePoolPop(v7);
    }

    CFRelease(v6);
  }

  return 0LL;
}

uint64_t sub_1000BC9E8(unsigned int a1, _DWORD *a2)
{
  *a2 = 0;
  uint64_t v4 = sub_10003B8D0();
  unsigned int v5 = sub_10009137C(a1, v4);
  if (v5)
  {
    uint64_t v6 = v5;
    if ((sub_10003BEEC((uint64_t)v5) & 1) != 0)
    {
      uint64_t v8 = (void *)sub_10003BEC4((uint64_t)v6);
      if (v8) {
        *a2 = sub_10006F638(v8);
      }
    }

    else
    {
      uint64_t v7 = objc_autoreleasePoolPush();
      if (qword_100219F60) {
        [(id)qword_100219F60 WFLog:4, "%s Client %@ has no entitlement", "kern_return_t _wifi_manager_get_hardware_failure(mach_port_t, int *)", sub_10003BEDC((uint64_t)v6) message];
      }
      objc_autoreleasePoolPop(v7);
    }

    CFRelease(v6);
  }

  return 0LL;
}

uint64_t sub_1000BCAA8(unsigned int a1)
{
  uint64_t v2 = sub_10003B8D0();
  __int128 v3 = sub_10009137C(a1, v2);
  if (v3)
  {
    uint64_t v4 = v3;
    uint64_t v5 = sub_10003BEC4((uint64_t)v3);
    if (v5)
    {
      uint64_t v6 = (void *)v5;
      if ((sub_10003BEEC((uint64_t)v4) & 1) == 0)
      {
        uint64_t v7 = objc_autoreleasePoolPush();
        if (qword_100219F60) {
          [(id)qword_100219F60 WFLog:4, "%s Client %@ has no entitlement", "kern_return_t _wifi_manager_reset_network_settings(mach_port_t)", sub_10003BEDC((uint64_t)v4) message];
        }
LABEL_10:
        objc_autoreleasePoolPop(v7);
        goto LABEL_11;
      }

      if (!sub_10003E1B8((uint64_t)v4, @"com.apple.wifi.manager-access"))
      {
        uint64_t v7 = objc_autoreleasePoolPush();
        if (qword_100219F60) {
          [(id)qword_100219F60 WFLog:4, "%s Client %@ is not entitled to reset network settings", "kern_return_t _wifi_manager_reset_network_settings(mach_port_t)", sub_10003BEDC((uint64_t)v4) message];
        }
        goto LABEL_10;
      }

      sub_100083920(v6);
    }

uint64_t sub_1000BCBB4(unsigned int a1)
{
  uint64_t v2 = sub_10003B8D0();
  __int128 v3 = sub_10009137C(a1, v2);
  if (v3)
  {
    uint64_t v4 = v3;
    uint64_t v5 = sub_10003BEC4((uint64_t)v3);
    if (v5)
    {
      uint64_t v6 = v5;
      if ((sub_10003BEEC((uint64_t)v4) & 1) != 0)
      {
        nullsub_1(v6, 0LL, v7);
      }

      else
      {
        uint64_t v8 = objc_autoreleasePoolPush();
        if (qword_100219F60) {
          [(id)qword_100219F60 WFLog:4, "%s Client %@ has no entitlement", "kern_return_t _wifi_manager_purge_expired_known_networks(mach_port_t)", sub_10003BEDC((uint64_t)v4) message];
        }
        objc_autoreleasePoolPop(v8);
      }
    }

    CFRelease(v4);
  }

  return 0LL;
}

uint64_t sub_1000BCC74(unsigned int a1)
{
  uint64_t v2 = sub_10003B8D0();
  __int128 v3 = sub_10009137C(a1, v2);
  if (v3)
  {
    uint64_t v4 = v3;
    char v5 = sub_10003BEEC((uint64_t)v3);
    uint64_t v6 = objc_autoreleasePoolPush();
    if ((v5 & 1) != 0)
    {
      if (qword_100219F60) {
        [(id)qword_100219F60 WFLog:3, "Cleanup of log buffer files requested by %@", sub_10003BEDC((uint64_t)v4) message];
      }
      objc_autoreleasePoolPop(v6);
      sub_10005DCEC();
    }

    else
    {
      if (qword_100219F60) {
        [(id)qword_100219F60 WFLog:4, "%s Client %@ has no entitlement", "kern_return_t _wifi_manager_cleanup_log_buffer_files(mach_port_t)", sub_10003BEDC((uint64_t)v4) message];
      }
      objc_autoreleasePoolPop(v6);
    }

    CFRelease(v4);
  }

  return 0LL;
}

uint64_t sub_1000BCD4C(unsigned int a1, UInt8 *a2, unsigned int a3, unsigned int *a4)
{
  *a4 = 0;
  uint64_t v8 = sub_10003B8D0();
  uint64_t v9 = sub_10009137C(a1, v8);
  if (v9)
  {
    uint64_t v10 = v9;
    if ((sub_10003BEEC((uint64_t)v9) & 1) != 0)
    {
      CFPropertyListRef v12 = sub_10003A7C0(a2, a3);
      if (v12)
      {
        uint64_t v13 = v12;
        CFRelease(v13);
      }
    }

    else
    {
      uint64_t v11 = objc_autoreleasePoolPush();
      if (qword_100219F60) {
        [(id)qword_100219F60 WFLog:4, "%s Client %@ has no entitlement", "kern_return_t _wifi_device_get_app_state(mach_port_t, vm_offset_t, mach_msg_type_number_t, int *)", sub_10003BEDC((uint64_t)v10) message];
      }
      objc_autoreleasePoolPop(v11);
    }

    CFRelease(v10);
  }

  sub_10003A8FC((vm_address_t)a2, a3);
  return 0LL;
}

uint64_t sub_1000BCE4C(unsigned int a1, int a2)
{
  uint64_t v4 = sub_10003B8D0();
  char v5 = sub_10009137C(a1, v4);
  if (v5)
  {
    uint64_t v6 = v5;
    if ((sub_10003BEEC((uint64_t)v5) & 1) != 0)
    {
      uint64_t v8 = sub_10003BEC4((uint64_t)v6);
      if (v8)
      {
        uint64_t v9 = v8;
        uint64_t v10 = objc_autoreleasePoolPush();
        if (qword_100219F60)
        {
          uint64_t v11 = "on-to";
          if (!a2) {
            uint64_t v11 = "out-of";
          }
          [qword_100219F60 WFLog:@"kern_return_t _wifi_manager_wificall_handover_notification(mach_port_t, int)" message:@"%s: WiFiCall handover notification: call moved %s WiFi"];
        }

        objc_autoreleasePoolPop(v10);
        if (a2) {
          sub_10007A7B4(v9);
        }
        else {
          sub_10007A8A0(v9);
        }
      }
    }

    else
    {
      uint64_t v7 = objc_autoreleasePoolPush();
      if (qword_100219F60) {
        [(id)qword_100219F60 WFLog:4, "%s Client %@ has no entitlement", "kern_return_t _wifi_manager_wificall_handover_notification(mach_port_t, int)", sub_10003BEDC((uint64_t)v6) message];
      }
      objc_autoreleasePoolPop(v7);
    }

    CFRelease(v6);
  }

  return 0LL;
}

uint64_t sub_1000BCF6C(unsigned int a1, UInt8 *a2, unsigned int a3)
{
  uint64_t v6 = sub_10003B8D0();
  uint64_t v7 = sub_10009137C(a1, v6);
  if (v7)
  {
    uint64_t v8 = v7;
    if ((sub_10003BEEC((uint64_t)v7) & 1) != 0)
    {
      CFPropertyListRef v10 = sub_10003A7C0(a2, a3);
      if (v10)
      {
        uint64_t v11 = v10;
        uint64_t v12 = sub_10003BEC4((uint64_t)v8);
        if (v12) {
          sub_10006BBE4(v12, v11, 0);
        }
        CFRelease(v11);
      }
    }

    else
    {
      uint64_t v9 = objc_autoreleasePoolPush();
      if (qword_100219F60) {
        [(id)qword_100219F60 WFLog:4, "%s Client %@ has no entitlement", "kern_return_t _wifi_device_insert_missing_network_service(mach_port_t, vm_offset_t, mach_msg_type_number_t)", sub_10003BEDC((uint64_t)v8) message];
      }
      objc_autoreleasePoolPop(v9);
    }

    CFRelease(v8);
  }

  sub_10003A8FC((vm_address_t)a2, a3);
  return 0LL;
}

uint64_t sub_1000BD060(unsigned int a1, vm_offset_t *a2, mach_msg_type_number_t *a3)
{
  *a2 = 0LL;
  *a3 = 0;
  uint64_t v6 = sub_10003B8D0();
  uint64_t v7 = sub_10009137C(a1, v6);
  if (v7)
  {
    uint64_t v8 = v7;
    if ((sub_10003BEEC((uint64_t)v7) & 1) != 0)
    {
      uint64_t v10 = sub_10003BEC4((uint64_t)v8);
      if (v10)
      {
        uint64_t v11 = (const __CFArray *)v10;
        uint64_t v12 = objc_autoreleasePoolPush();
        if (qword_100219F60) {
          [(id)qword_100219F60 WFLog:3, "%s: requested by %@", "_wifi_manager_copy_movement_states", sub_10003BEDC((uint64_t)v8) message];
        }
        objc_autoreleasePoolPop(v12);
        uint64_t v13 = sub_100084040(v11);
        if (v13)
        {
          uint64_t v14 = v13;
          sub_10003A920(v13, a2, a3);
          CFRelease(v14);
        }
      }
    }

    else
    {
      uint64_t v9 = objc_autoreleasePoolPush();
      if (qword_100219F60) {
        [(id)qword_100219F60 WFLog:4, "%s Client %@ has no entitlement", "kern_return_t _wifi_manager_copy_movement_states(mach_port_t, vm_offset_t *, mach_msg_type_number_t *)", sub_10003BEDC((uint64_t)v8) message];
      }
      objc_autoreleasePoolPop(v9);
    }

    CFRelease(v8);
  }

  return 0LL;
}

uint64_t sub_1000BD198(unsigned int a1, UInt8 *a2, unsigned int a3)
{
  uint64_t v6 = sub_10003B8D0();
  uint64_t v7 = sub_10009137C(a1, v6);
  if (v7)
  {
    uint64_t v8 = v7;
    if ((sub_10003BEEC((uint64_t)v7) & 1) != 0)
    {
      if (sub_10003BEC4((uint64_t)v8))
      {
        CFPropertyListRef v10 = sub_10003A7C0(a2, a3);
        if (v10) {
          CFRelease(v10);
        }
      }
    }

    else
    {
      uint64_t v9 = objc_autoreleasePoolPush();
      if (qword_100219F60) {
        [(id)qword_100219F60 WFLog:4, "%s Client %@ has no entitlement", "kern_return_t _wifi_manager_set_simulated_movement_states(mach_port_t, vm_offset_t, mach_msg_type_number_t)", sub_10003BEDC((uint64_t)v8) message];
      }
      objc_autoreleasePoolPop(v9);
    }

    CFRelease(v8);
  }

  sub_10003A8FC((vm_address_t)a2, a3);
  return 0LL;
}

uint64_t sub_1000BD278(unsigned int a1, int a2)
{
  uint64_t v4 = sub_10003B8D0();
  char v5 = sub_10009137C(a1, v4);
  if (v5)
  {
    uint64_t v6 = v5;
    if ((sub_10003BEEC((uint64_t)v5) & 1) != 0)
    {
      uint64_t v8 = sub_10003BEC4((uint64_t)v6);
      if (v8)
      {
        uint64_t v9 = v8;
        CFPropertyListRef v10 = objc_autoreleasePoolPush();
        if (qword_100219F60)
        {
          if (a2) {
            uint64_t v11 = "ON";
          }
          else {
            uint64_t v11 = "OFF";
          }
          [(id)qword_100219F60 WFLog:3, "Manager low power mode %s requested by %@", v11, sub_10003BEDC((uint64_t)v6) message];
        }

        objc_autoreleasePoolPop(v10);
        sub_10003BEDC((uint64_t)v6);
        sub_100084080(v9, a2);
      }
    }

    else
    {
      uint64_t v7 = objc_autoreleasePoolPush();
      if (qword_100219F60) {
        [(id)qword_100219F60 WFLog:4, "%s Client %@ has no entitlement", "kern_return_t _wifi_manager_set_battery_save_mode(mach_port_t, int)", sub_10003BEDC((uint64_t)v6) message];
      }
      objc_autoreleasePoolPop(v7);
    }

    CFRelease(v6);
  }

  return 0LL;
}

uint64_t sub_1000BD3A8(unsigned int a1, _DWORD *a2)
{
  uint64_t v4 = sub_10003B8D0();
  char v5 = sub_10009137C(a1, v4);
  if (v5)
  {
    uint64_t v6 = v5;
    if ((sub_10003BEEC((uint64_t)v5) & 1) != 0)
    {
      uint64_t v8 = sub_10003BEC4((uint64_t)v6);
      if (v8) {
        *a2 = sub_1000841CC(v8);
      }
    }

    else
    {
      uint64_t v7 = objc_autoreleasePoolPush();
      if (qword_100219F60) {
        [(id)qword_100219F60 WFLog:4, "%s Client %@ has no entitlement", "kern_return_t _wifi_manager_get_battery_save_mode(mach_port_t, int *)", sub_10003BEDC((uint64_t)v6) message];
      }
      objc_autoreleasePoolPop(v7);
    }

    CFRelease(v6);
  }

  return 0LL;
}

uint64_t sub_1000BD464(unsigned int a1, UInt8 *a2, unsigned int a3)
{
  uint64_t v6 = sub_10003B8D0();
  uint64_t v7 = sub_10009137C(a1, v6);
  if (v7)
  {
    uint64_t v8 = v7;
    uint64_t v9 = sub_10003BEC4((uint64_t)v7);
    if (v9)
    {
      uint64_t v10 = v9;
      if ((sub_10003BEEC((uint64_t)v8) & 1) != 0)
      {
        CFPropertyListRef v12 = sub_10003A7C0(a2, a3);
        if (v12)
        {
          uint64_t v13 = v12;
          sub_100084478(v10, (uint64_t)v12);
          CFRelease(v13);
        }
      }

      else
      {
        uint64_t v11 = objc_autoreleasePoolPush();
        if (qword_100219F60) {
          [(id)qword_100219F60 WFLog:4, "%s Client %@ has no entitlement", "kern_return_t _wifi_manager_initiate_network_transition(mach_port_t, vm_offset_t, mach_msg_type_number_t)", sub_10003BEDC((uint64_t)v8) message];
        }
        objc_autoreleasePoolPop(v11);
      }
    }

    CFRelease(v8);
  }

  sub_10003A8FC((vm_address_t)a2, a3);
  return 0LL;
}

uint64_t sub_1000BD55C(uint64_t a1)
{
  uint64_t v2 = *(void *)(a1 + 32);
  if (v2)
  {
    unsigned int v3 = sub_10003BEB4(v2);
    sub_1000912D4(v3);
    uint64_t v2 = *(void *)(a1 + 32);
  }

  return sub_100091164(v2);
}

uint64_t sub_1000BD590(unsigned int a1)
{
  if (a1 < 3) {
    return a1 + 1LL;
  }
  else {
    return 0LL;
  }
}

uint64_t sub_1000BD5A0(uint64_t a1)
{
  if (a1 == 3) {
    return 2LL;
  }
  else {
    return a1 == 2;
  }
}

uint64_t sub_1000BD5B8(int a1)
{
  if (a1 == 1) {
    return 1LL;
  }
  else {
    return 2LL;
  }
}

BOOL sub_1000BD5C8(uint64_t a1)
{
  return a1 == 1;
}

uint64_t sub_1000BD5D4(unsigned int a1)
{
  if (a1 < 3) {
    return a1 + 1LL;
  }
  else {
    return 0x7FFFFFFFFFFFFFFFLL;
  }
}

uint64_t sub_1000BD5E8(int a1)
{
  else {
    return qword_10017F9F8[a1 - 1];
  }
}

CFStringRef sub_1000BDC98(unsigned int a1)
{
  if (a1 > 0x14) {
    return @"Bogus";
  }
  else {
    return off_1001E5400[a1];
  }
}

uint64_t sub_1000BDCBC()
{
  kern_return_t v0;
  kern_return_t v1;
  void *v2;
  if (!qword_1002199D8)
  {
    qword_1002199D8 = _CFRuntimeRegisterClass(&unk_1001E4DF8);
    if (!qword_1002199D8) {
      sub_100154758();
    }
    uint64_t v0 = IOMasterPort(0, dword_1002199E0);
    if (v0)
    {
      uint64_t v1 = v0;
      uint64_t v2 = objc_autoreleasePoolPush();
      if (qword_100219F60) {
        [qword_100219F60 WFLog:@"%s: can't get mach master port: %ld\n" message:4];
      }
      objc_autoreleasePoolPop(v2);
    }
  }

  return qword_1002199D8;
}

uint64_t sub_1000BDD64(uint64_t a1, const void *a2, dispatch_queue_s *a3)
{
  uint64_t v6 = objc_autoreleasePoolPush();
  uint64_t v7 = objc_autoreleasePoolPush();
  if (qword_100219F60) {
    objc_msgSend((id)qword_100219F60, "WFLog:message:", 4, "%s: entering", "WiFiDeviceManagerCreate");
  }
  objc_autoreleasePoolPop(v7);
  if (!a2) {
    goto LABEL_115;
  }
  sub_1000BDCBC();
  uint64_t Instance = _CFRuntimeCreateInstance(a1);
  if (!Instance) {
    goto LABEL_115;
  }
  uint64_t v9 = Instance;
  bzero((void *)(Instance + 16), 0x2338uLL);
  CFRetain(a2);
  *(void *)(v9 + 64) = a2;
  uint64_t v10 = sub_100133FF0((uint64_t)kCFAllocatorDefault);
  *(void *)(v9 + 96) = v10;
  if (!v10) {
    goto LABEL_114;
  }
  *(_DWORD *)(v9 + 10_Block_object_dispose((const void *)(v1 - 80), 8) = 0;
  *(_BYTE *)(v9 + 104) = 0;
  uint64_t v11 = sub_100013FE8((uint64_t)kCFAllocatorDefault, (uint64_t)a2, a3);
  *(void *)(v9 + 120) = v11;
  if (!v11) {
    goto LABEL_114;
  }
  if (+[WiFiAIRAgent sharedInstance](&OBJC_CLASS___WiFiAIRAgent, "sharedInstance")) {
    -[WiFiAIRAgent setWiFiManagerQueue:]( +[WiFiAIRAgent sharedInstance](&OBJC_CLASS___WiFiAIRAgent, "sharedInstance"),  "setWiFiManagerQueue:",  a3);
  }
  dispatch_source_t v12 = dispatch_source_create((dispatch_source_type_t)&_dispatch_source_type_timer, 0LL, 0LL, a3);
  *(void *)(v9 + 312) = v12;
  if (!v12)
  {
    unsigned int v83 = objc_autoreleasePoolPush();
    if (qword_100219F60) {
      [qword_100219F60 WFLog:@"Error: failed to create retry.timer" message:4];
    }
    goto LABEL_113;
  }

  dispatch_set_context(v12, (void *)v9);
  dispatch_source_set_event_handler_f(*(dispatch_source_t *)(v9 + 312), (dispatch_function_t)sub_1000BF474);
  dispatch_source_t v13 = dispatch_source_create((dispatch_source_type_t)&_dispatch_source_type_timer, 0LL, 0LL, a3);
  *(void *)(v9 + 360) = v13;
  if (!v13)
  {
    unsigned int v83 = objc_autoreleasePoolPush();
    if (qword_100219F60) {
      [qword_100219F60 WFLog:@"Error: failed to create autoJoinDeferral.timer" message:4];
    }
    goto LABEL_113;
  }

  dispatch_set_context(v13, (void *)v9);
  dispatch_source_set_event_handler_f(*(dispatch_source_t *)(v9 + 360), (dispatch_function_t)sub_1000BF668);
  CFMutableSetRef Mutable = CFSetCreateMutable(kCFAllocatorDefault, 0LL, &kCFTypeSetCallBacks);
  *(void *)(v9 + 3496) = Mutable;
  if (!Mutable) {
    goto LABEL_114;
  }
  CFMutableArrayRef v15 = CFArrayCreateMutable(kCFAllocatorDefault, 0LL, &kCFTypeArrayCallBacks);
  *(void *)(v9 + 352_Block_object_dispose((const void *)(v1 - 80), 8) = v15;
  if (!v15) {
    goto LABEL_114;
  }
  CFMutableArrayRef v16 = CFArrayCreateMutable(kCFAllocatorDefault, 0LL, &kCFTypeArrayCallBacks);
  *(void *)(v9 + 3520) = v16;
  if (!v16) {
    goto LABEL_114;
  }
  CFMutableArrayRef v17 = CFArrayCreateMutable(kCFAllocatorDefault, 0LL, &kCFTypeArrayCallBacks);
  *(void *)(v9 + 3544) = v17;
  if (!v17) {
    goto LABEL_114;
  }
  CFMutableArrayRef v18 = CFArrayCreateMutable(kCFAllocatorDefault, 0LL, &kCFTypeArrayCallBacks);
  *(void *)(v9 + 3536) = v18;
  if (!v18) {
    goto LABEL_114;
  }
  CFMutableArrayRef v19 = CFArrayCreateMutable(kCFAllocatorDefault, 0LL, &kCFTypeArrayCallBacks);
  *(void *)(v9 + 356_Block_object_dispose((const void *)(v1 - 80), 8) = v19;
  if (!v19) {
    goto LABEL_114;
  }
  CFMutableArrayRef v20 = CFArrayCreateMutable(kCFAllocatorDefault, 0LL, &kCFTypeArrayCallBacks);
  *(void *)(v9 + 3560) = v20;
  if (!v20) {
    goto LABEL_114;
  }
  CFMutableArrayRef v21 = CFArrayCreateMutable(kCFAllocatorDefault, 0LL, &kCFTypeArrayCallBacks);
  *(void *)(v9 + 3552) = v21;
  if (!v21) {
    goto LABEL_114;
  }
  uint64_t v22 = -[WiFiTimeDeferredNetworksAJManager initWithArgs:]( objc_alloc(&OBJC_CLASS___WiFiTimeDeferredNetworksAJManager),  "initWithArgs:",  v9);
  *(void *)(v9 + 364_Block_object_dispose((const void *)(v1 - 80), 8) = v22;
  -[WiFiTimeDeferredNetworksAJManager setDeferIntervalSecs:](v22, "setDeferIntervalSecs:", 60.0);
  [*(id *)(v9 + 3648) setNumDaysSinceAssocOverrideDeferral:2];
  CFMutableArrayRef v23 = CFArrayCreateMutable(kCFAllocatorDefault, 0LL, &kCFTypeArrayCallBacks);
  *(void *)(v9 + 3320) = v23;
  if (!v23) {
    goto LABEL_114;
  }
  *(void *)(v9 + 332_Block_object_dispose((const void *)(v1 - 80), 8) = 0LL;
  CFMutableArrayRef v24 = CFArrayCreateMutable(kCFAllocatorDefault, 0LL, &kCFTypeArrayCallBacks);
  *(void *)(v9 + 3616) = v24;
  if (!v24) {
    goto LABEL_114;
  }
  CFMutableArrayRef v25 = CFArrayCreateMutable(kCFAllocatorDefault, 0LL, &kCFTypeArrayCallBacks);
  *(void *)(v9 + 3624) = v25;
  if (!v25) {
    goto LABEL_114;
  }
  CFMutableArrayRef v26 = CFArrayCreateMutable(kCFAllocatorDefault, 0LL, &kCFTypeArrayCallBacks);
  *(void *)(v9 + 3576) = v26;
  if (!v26) {
    goto LABEL_114;
  }
  CFMutableArrayRef v27 = CFArrayCreateMutable(kCFAllocatorDefault, 0LL, &kCFTypeArrayCallBacks);
  *(void *)(v9 + 3584) = v27;
  if (!v27) {
    goto LABEL_114;
  }
  CFMutableArrayRef v28 = CFArrayCreateMutable(kCFAllocatorDefault, 0LL, &kCFTypeArrayCallBacks);
  *(void *)(v9 + 3632) = v28;
  if (!v28) {
    goto LABEL_114;
  }
  CFMutableArrayRef v29 = CFArrayCreateMutable(kCFAllocatorDefault, 0LL, &kCFTypeArrayCallBacks);
  *(void *)(v9 + 3280) = v29;
  if (!v29) {
    goto LABEL_114;
  }
  CFMutableSetRef v30 = CFSetCreateMutable(kCFAllocatorDefault, 0LL, &kCFTypeSetCallBacks);
  *(void *)(v9 + 3312) = v30;
  if (!v30) {
    goto LABEL_114;
  }
  CFMutableArrayRef v31 = CFArrayCreateMutable(kCFAllocatorDefault, 0LL, &kCFTypeArrayCallBacks);
  *(void *)(v9 + 1096) = v31;
  if (!v31) {
    goto LABEL_114;
  }
  CFMutableArrayRef v32 = CFArrayCreateMutable(kCFAllocatorDefault, 0LL, &kCFTypeArrayCallBacks);
  *(void *)(v9 + 272) = v32;
  if (!v32) {
    goto LABEL_114;
  }
  uint64_t v33 = sub_1000BF728((char *)dword_10021909C, 3LL);
  *(void *)(v9 + 5360) = v33;
  if (!v33) {
    goto LABEL_114;
  }
  uint64_t v34 = sub_1000BF728((char *)&dword_1002190A8, 2LL);
  *(void *)(v9 + 536_Block_object_dispose((const void *)(v1 - 80), 8) = v34;
  if (!v34) {
    goto LABEL_114;
  }
  CFMutableSetRef v35 = CFSetCreateMutable(kCFAllocatorDefault, 0LL, &kCFTypeSetCallBacks);
  *(void *)(v9 + 3592) = v35;
  if (!v35) {
    goto LABEL_114;
  }
  CFMutableSetRef v36 = CFSetCreateMutable(kCFAllocatorDefault, 0LL, &kCFTypeSetCallBacks);
  *(void *)(v9 + 3600) = v36;
  if (!v36) {
    goto LABEL_114;
  }
  CFMutableArrayRef v37 = CFArrayCreateMutable(kCFAllocatorDefault, 0LL, &kCFTypeArrayCallBacks);
  *(void *)(v9 + 376) = v37;
  if (!v37) {
    goto LABEL_114;
  }
  CFArrayRef ArrayBySeparatingStrings = CFStringCreateArrayBySeparatingStrings( kCFAllocatorDefault,  @"Preferences SpringBoard Carousel WiFiPickerExtens Setup budd sharingd demod BundledIntentHandler SiriViewService assistantd assistant_service Siri SettingsIntentExtension NanoSettings PineBoard TVSettings SoundBoard RealityControlCenter MuseBuddyApp mobilewifitool WirelessStress coreautomationd wifiutil NanoWiFiViewService ATKWiFiFramework WiFiViewService hQT XCTestInternalAngel HPSetup AirPlaySenderUIApp TVSetup deviceaccessd AccessorySetupUI",  @" ");
  *(void *)(v9 + 492_Block_object_dispose((const void *)(v1 - 80), 8) = ArrayBySeparatingStrings;
  if (!ArrayBySeparatingStrings) {
    goto LABEL_114;
  }
  *(_BYTE *)(v9 + 3480) = 1;
  *(_DWORD *)(v9 + 3484) = 0;
  sub_10004C7A0((uint64_t)a2, (uint64_t)sub_1000BF7D0, v9);
  sub_10004C7AC((uint64_t)a2, (uint64_t)sub_1000BF7D0, v9);
  sub_10004C6F8((uint64_t)a2, (uint64_t)sub_1000C0094, v9);
  sub_10004C704((uint64_t)a2, (uint64_t)sub_1000C0288, v9);
  sub_10004C710((uint64_t)a2, (uint64_t)sub_1000C1E94, v9);
  sub_10004C728((uint64_t)a2, (uint64_t)sub_1000C1EB4, v9);
  sub_10004C71C((uint64_t)a2, (uint64_t)sub_1000C2058, v9);
  sub_10004C758((uint64_t)a2, (uint64_t)sub_1000C2318, v9);
  sub_10004C764((uint64_t)a2, (uint64_t)sub_1000C28B8, v9);
  sub_10004C770((uint64_t)a2, (uint64_t)sub_1000C298C, v9);
  sub_10004C77C((uint64_t)a2, (uint64_t)sub_1000C2E08, v9);
  sub_10004C788((uint64_t)a2, (uint64_t)sub_1000C2FA0, v9);
  sub_10004C794((uint64_t)a2, (uint64_t)sub_1000C3028, v9);
  sub_10004C7B8((uint64_t)a2, (uint64_t)sub_1000C31A4, v9);
  sub_10004C7F4((uint64_t)a2, (uint64_t)sub_1000C34F0, v9);
  sub_10004C7DC((uint64_t)a2, (uint64_t)sub_1000C3664, v9);
  sub_10004C7E8((uint64_t)a2, (uint64_t)sub_1000C397C, v9);
  sub_10004C734((uint64_t)a2, (uint64_t)sub_1000C3DFC, v9);
  sub_10004C800((uint64_t)a2, (uint64_t)sub_1000C415C, v9);
  sub_10004C80C((uint64_t)a2, (uint64_t)sub_1000C417C, v9);
  sub_10004C818((uint64_t)a2, (uint64_t)sub_1000C419C, v9);
  sub_10004C824((uint64_t)a2, (uint64_t)sub_1000C4DD4, v9);
  sub_10004C830((uint64_t)a2, (uint64_t)sub_1000C4DF4, v9);
  sub_10004C83C((uint64_t)a2, (uint64_t)sub_1000C4E14, v9);
  sub_10004C848((uint64_t)a2, (uint64_t)sub_1000C52E4, v9);
  sub_10004C854((uint64_t)a2, (uint64_t)sub_1000C5304, v9);
  sub_10004C86C((uint64_t)a2, (uint64_t)sub_1000C5324, v9);
  sub_10004C878((uint64_t)a2, (uint64_t)sub_1000C5454, v9);
  sub_10004C860((uint64_t)a2, (uint64_t)sub_1000C5520, v9);
  v87[0] = _NSConcreteStackBlock;
  v87[1] = 3221225472LL;
  v87[2] = sub_1000C5534;
  v87[3] = &unk_1001E4AC8;
  v87[4] = v9;
  -[WiFiUsageMonitor setFaultEventHandler:]( +[WiFiUsageMonitor sharedInstance](&OBJC_CLASS___WiFiUsageMonitor, "sharedInstance"),  "setFaultEventHandler:",  v87);
  sub_10004C884((uint64_t)a2, (uint64_t)sub_1000C573C, v9);
  sub_10004C6EC((uint64_t)a2, (uint64_t)sub_1000C5AE0, v9);
  sub_10004C7C4((uint64_t)a2, (uint64_t)sub_1000C5B00, v9);
  sub_10004C7D0((uint64_t)a2, (uint64_t)sub_1000C5B20, v9);
  sub_10004C890((uint64_t)a2, (uint64_t)sub_1000C5B40, v9);
  sub_10004C89C((uint64_t)a2, (uint64_t)sub_1000C5E84, v9);
  sub_10004C8A8((uint64_t)a2, (uint64_t)sub_1000C6118, v9);
  sub_10001664C(*(void *)(v9 + 120), (uint64_t)sub_1000C612C, v9);
  sub_100016768(*(void *)(v9 + 120), (uint64_t)sub_1000C63C8, v9);
  sub_100016810(*(void *)(v9 + 120), (uint64_t)sub_1000C63D0, v9);
  sub_10004C8B4((uint64_t)a2, (uint64_t)sub_1000C6630, v9);
  sub_10004C8C0((uint64_t)a2, (uint64_t)sub_1000C67F4, v9);
  sub_10004C8CC((uint64_t)a2, (uint64_t)sub_1000C699C, v9);
  sub_10004C8D8((uint64_t)a2, (uint64_t)sub_1000C69BC, v9);
  sub_10004C8E4((uint64_t)a2, (uint64_t)sub_1000C6A78, v9);
  sub_10004C8F0((uint64_t)a2, (uint64_t)sub_1000C6B64, v9);
  sub_10004C8FC((uint64_t)a2, (uint64_t)sub_1000C715C, v9);
  sub_10004C908((uint64_t)a2, (uint64_t)sub_1000C7788, v9);
  sub_10004C914((uint64_t)a2, (uint64_t)sub_1000C7838, v9);
  sub_10004C920((uint64_t)a2, (uint64_t)sub_1000C7904, v9);
  sub_10004C958((uint64_t)a2, (uint64_t)sub_1000C7920, v9);
  sub_10004C740((uint64_t)a2, (uint64_t)sub_1000C7A74, v9);
  sub_10004C74C((uint64_t)a2, (uint64_t)sub_1000C7D60, v9);
  sub_10004C964((uint64_t)a2, (uint64_t)sub_1000C7DBC, v9);
  sub_10004C970((uint64_t)a2, (uint64_t)sub_1000C8170, v9);
  sub_10004C97C((uint64_t)a2, (uint64_t)sub_1000C8250, v9);
  sub_10004C988((uint64_t)a2, (uint64_t)sub_1000C8564, v9);
  sub_10004C994((uint64_t)a2, (uint64_t)nullsub_8, v9);
  sub_10004C9A0((uint64_t)a2, (uint64_t)sub_1000C8BDC, v9);
  sub_10004C9AC((uint64_t)a2, (uint64_t)sub_1000C8C04, v9);
  sub_10004C9D0((uint64_t)a2, (uint64_t)sub_1000C8E30, v9);
  sub_10004C9B8((uint64_t)a2, (uint64_t)nullsub_9, v9);
  sub_10004C9C4((uint64_t)a2, (uint64_t)sub_1000C8F60, v9);
  sub_10004C9DC((uint64_t)a2, (uint64_t)sub_1000C8FC4, v9);
  sub_10004CA00((uint64_t)a2, (uint64_t)sub_1000C9098, v9);
  sub_10004CA18((uint64_t)a2, (uint64_t)sub_1000C90B8, v9);
  sub_10004CA0C((uint64_t)a2, (uint64_t)sub_1000C90D8, v9);
  sub_10004CA30((uint64_t)a2, (uint64_t)sub_1000C910C, v9);
  sub_10004CA48((uint64_t)a2, (uint64_t)sub_1000C9128, v9);
  LocalCenter = CFNotificationCenterGetLocalCenter();
  CFNotificationCenterAddObserver( LocalCenter,  (const void *)v9,  (CFNotificationCallback)sub_1000C9400,  @"com.apple.wifid.wifiroammanagerroamnotification",  0LL,  CFNotificationSuspensionBehaviorDeliverImmediately);
  sub_10004CA24((uint64_t)a2, (uint64_t)sub_1000C9788, v9);
  sub_10004CA3C((uint64_t)a2, (uint64_t)sub_1000C97F4, v9);
  CFNotificationCenterAddObserver( LocalCenter,  (const void *)v9,  (CFNotificationCallback)sub_1000C9808,  @"WiFiChipResetRequested",  0LL,  CFNotificationSuspensionBehaviorDeliverImmediately);
  *(void *)(v9 + 4936) = 0LL;
  *(_WORD *)(v9 + 5352) = 0;
  *(_BYTE *)(v9 + 5354) = 0;
  *(void *)(v9 + 5440) = 0LL;
  *(_DWORD *)(v9 + 5447) = 0;
  *(CFAbsoluteTime *)(v9 + 5240) = CFAbsoluteTimeGetCurrent() + 315360000.0;
  dispatch_source_t v40 = dispatch_source_create((dispatch_source_type_t)&_dispatch_source_type_timer, 0LL, 0LL, a3);
  *(void *)(v9 + 5232) = v40;
  if (!v40)
  {
    uint64_t v84 = objc_autoreleasePoolPush();
    if (qword_100219F60) {
      [qword_100219F60 WFLog:@"WiFiDeviceManagerCreate: Error: failed to create mis.misIdleTimer"];
    }
    goto LABEL_104;
  }

  dispatch_set_context(v40, (void *)v9);
  dispatch_source_set_event_handler_f(*(dispatch_source_t *)(v9 + 5232), (dispatch_function_t)sub_1000C9890);
  *(_DWORD *)(v9 + 5224) = 0;
  *(void *)(v9 + 6736) = 0x4072C00000000000LL;
  dispatch_source_t v41 = dispatch_source_create((dispatch_source_type_t)&_dispatch_source_type_timer, 0LL, 0LL, a3);
  *(void *)(v9 + 5312) = v41;
  if (!v41)
  {
    uint64_t v84 = objc_autoreleasePoolPush();
    if (qword_100219F60) {
      [qword_100219F60 WFLog:@"WiFiDeviceManagerCreate: Error: failed to create mis.misBroadcastToHiddenTimer"];
    }
    goto LABEL_104;
  }

  dispatch_set_context(v41, (void *)v9);
  dispatch_source_set_event_handler_f(*(dispatch_source_t *)(v9 + 5312), (dispatch_function_t)sub_1000C9B28);
  dispatch_source_t v42 = dispatch_source_create((dispatch_source_type_t)&_dispatch_source_type_timer, 0LL, 0LL, a3);
  *(void *)(v9 + 5504) = v42;
  if (!v42)
  {
    uint64_t v84 = objc_autoreleasePoolPush();
    if (qword_100219F60) {
      [qword_100219F60 WFLog:@"Error: failed to create priorityLinkSetupPhase.timer" message:4];
    }
    goto LABEL_104;
  }

  dispatch_set_context(v42, (void *)v9);
  dispatch_source_set_event_handler_f(*(dispatch_source_t *)(v9 + 5504), (dispatch_function_t)sub_1000C9BCC);
  *(_DWORD *)(v9 + 5512) = 0;
  dispatch_source_t v43 = dispatch_source_create((dispatch_source_type_t)&_dispatch_source_type_timer, 0LL, 0LL, a3);
  *(void *)(v9 + 8544) = v43;
  if (!v43)
  {
    uint64_t v84 = objc_autoreleasePoolPush();
    if (qword_100219F60) {
      [qword_100219F60 WFLog:@"Error: failed to create _24GHzInfraNetworkData.timer" message:4];
    }
    goto LABEL_104;
  }

  dispatch_set_context(v43, (void *)v9);
  dispatch_source_set_event_handler_f(*(dispatch_source_t *)(v9 + 8544), (dispatch_function_t)sub_1000C9C34);
  dispatch_source_t v44 = dispatch_source_create((dispatch_source_type_t)&_dispatch_source_type_timer, 0LL, 0LL, a3);
  *(void *)(v9 + 8584) = v44;
  if (!v44)
  {
    uint64_t v84 = objc_autoreleasePoolPush();
    if (qword_100219F60) {
      [qword_100219F60 WFLog:@"Error: failed to create carPlayHidEventCtx.timer" message:4];
    }
    goto LABEL_104;
  }

  dispatch_set_context(v44, (void *)v9);
  dispatch_source_set_event_handler_f(*(dispatch_source_t *)(v9 + 8584), (dispatch_function_t)sub_1000C9CA8);
  dispatch_source_t v45 = dispatch_source_create((dispatch_source_type_t)&_dispatch_source_type_timer, 0LL, 0LL, a3);
  *(void *)(v9 + 992) = v45;
  if (!v45)
  {
    uint64_t v84 = objc_autoreleasePoolPush();
    if (qword_100219F60) {
      [qword_100219F60 WFLog:@"Error: failed to create carPlayLinkDownCtx.timer" message:4];
    }
    goto LABEL_104;
  }

  dispatch_set_context(v45, (void *)v9);
  dispatch_source_set_event_handler_f(*(dispatch_source_t *)(v9 + 992), (dispatch_function_t)sub_1000C9D1C);
  dispatch_source_t v46 = dispatch_source_create((dispatch_source_type_t)&_dispatch_source_type_timer, 0LL, 0LL, a3);
  *(void *)(v9 + 104_Block_object_dispose((const void *)(v1 - 80), 8) = v46;
  if (!v46)
  {
    uint64_t v84 = objc_autoreleasePoolPush();
    if (qword_100219F60) {
      [qword_100219F60 WFLog:@"Error: failed to create carPlayLpcStats.timer" message:4];
    }
    goto LABEL_104;
  }

  dispatch_set_context(v46, (void *)v9);
  dispatch_source_set_event_handler_f(*(dispatch_source_t *)(v9 + 1048), (dispatch_function_t)sub_1000C9DA4);
  dispatch_source_t v47 = dispatch_source_create((dispatch_source_type_t)&_dispatch_source_type_timer, 0LL, 0LL, a3);
  *(void *)(v9 + 5520) = v47;
  if (!v47)
  {
    uint64_t v84 = objc_autoreleasePoolPush();
    if (qword_100219F60) {
      [qword_100219F60 WFLog:@"Error: failed to create assocStateMonitor.timer" message:4];
    }
LABEL_104:
    objc_autoreleasePoolPop(v84);
    goto LABEL_114;
  }

  dispatch_set_context(v47, (void *)v9);
  dispatch_source_set_event_handler_f(*(dispatch_source_t *)(v9 + 5520), (dispatch_function_t)sub_1000CA414);
  *(void *)(v9 + 5536) = 0LL;
  *(void *)(v9 + 552_Block_object_dispose((const void *)(v1 - 80), 8) = 0LL;
  *(_BYTE *)(v9 + 5544) = 0;
  CFMutableArrayRef v48 = CFUUIDCreate(kCFAllocatorDefault);
  if (v48)
  {
    CFIndex v49 = v48;
    *(void *)(v9 + 5480) = CFUUIDCreateString(kCFAllocatorDefault, v48);
    CFRelease(v49);
  }

  *(void *)(v9 + 328_Block_object_dispose((const void *)(v1 - 80), 8) = 0LL;
  *(_OWORD *)(v9 + 556_Block_object_dispose((const void *)(v1 - 80), 8) = 0u;
  *(_WORD *)(v9 + 5600) = 1;
  *(_BYTE *)(v9 + 34) = 0;
  *(_DWORD *)(v9 + 6200) = 0;
  *(_BYTE *)(v9 + 620_Block_object_dispose((const void *)(v1 - 80), 8) = 0;
  *(_WORD *)(v9 + 36) = 257;
  *(_BYTE *)(v9 + 6176) = 0;
  bzero((void *)(v9 + 5608), 0x238uLL);
  *(_BYTE *)(v9 + 3_Block_object_dispose((const void *)(v1 - 80), 8) = 1;
  *(void *)(v9 + 6152) = CFArrayCreateMutable(kCFAllocatorDefault, 0LL, &kCFTypeArrayCallBacks);
  *(void *)(v9 + 604_Block_object_dispose((const void *)(v1 - 80), 8) = CFSetCreateMutable(kCFAllocatorDefault, 0LL, &kCFTypeSetCallBacks);
  *(void *)(v9 + 6056) = CFSetCreateMutable(kCFAllocatorDefault, 0LL, &kCFTypeSetCallBacks);
  *(void *)(v9 + 1160) = CFArrayCreateMutable(kCFAllocatorDefault, 0LL, &kCFTypeArrayCallBacks);
  CFMutableDictionaryRef v50 = CFDictionaryCreateMutable( kCFAllocatorDefault,  0LL,  &kCFTypeDictionaryKeyCallBacks,  &kCFTypeDictionaryValueCallBacks);
  *(void *)(v9 + 3672) = v50;
  if (!v50) {
    goto LABEL_114;
  }
  CFMutableSetRef v51 = CFSetCreateMutable(kCFAllocatorDefault, 0LL, &kCFTypeSetCallBacks);
  *(void *)(v9 + 5264) = v51;
  if (!v51) {
    goto LABEL_114;
  }
  CFMutableSetRef v52 = CFSetCreateMutable(kCFAllocatorDefault, 0LL, &kCFTypeSetCallBacks);
  *(void *)(v9 + 5272) = v52;
  if (!v52) {
    goto LABEL_114;
  }
  CFMutableSetRef v53 = CFSetCreateMutable(kCFAllocatorDefault, 0LL, &kCFTypeSetCallBacks);
  *(void *)(v9 + 5280) = v53;
  if (!v53) {
    goto LABEL_114;
  }
  CFMutableSetRef v54 = CFSetCreateMutable(kCFAllocatorDefault, 0LL, &kCFTypeSetCallBacks);
  *(void *)(v9 + 528_Block_object_dispose((const void *)(v1 - 80), 8) = v54;
  if (!v54) {
    goto LABEL_114;
  }
  CFMutableSetRef v55 = CFSetCreateMutable(kCFAllocatorDefault, 0LL, &kCFTypeSetCallBacks);
  *(void *)(v9 + 5296) = v55;
  if (!v55) {
    goto LABEL_114;
  }
  CFMutableSetRef v56 = CFSetCreateMutable(kCFAllocatorDefault, 0LL, &kCFTypeSetCallBacks);
  *(void *)(v9 + 5304) = v56;
  if (!v56) {
    goto LABEL_114;
  }
  *(void *)(v9 + 6440) = 0LL;
  *(_OWORD *)(v9 + 640_Block_object_dispose((const void *)(v1 - 80), 8) = 0u;
  *(_OWORD *)(v9 + 6424) = 0u;
  *(_OWORD *)(v9 + 6376) = 0u;
  *(_OWORD *)(v9 + 6392) = 0u;
  *(_OWORD *)(v9 + 6344) = 0u;
  *(_OWORD *)(v9 + 6360) = 0u;
  *(_OWORD *)(v9 + 6312) = 0u;
  *(_OWORD *)(v9 + 632_Block_object_dispose((const void *)(v1 - 80), 8) = 0u;
  *(_OWORD *)(v9 + 6280) = 0u;
  *(_OWORD *)(v9 + 6296) = 0u;
  if (_os_feature_enabled_impl("WiFiManager", "NetworkDenyList"))
  {
    sub_10004CE2C(*(void *)(v9 + 64));
    CFIndex v57 = -[CWFNetworkDenyList initWithDenyListDeviceProfile:]( objc_alloc(&OBJC_CLASS___CWFNetworkDenyList),  "initWithDenyListDeviceProfile:",  1LL);
    -[CWFNetworkDenyList setEnabled:](v57, "setEnabled:", 1LL);
    v90[0] = _NSConcreteStackBlock;
    v90[1] = 3221225472LL;
    v90[2] = sub_1000FD8E8;
    v90[3] = &unk_1001E4E58;
    v90[4] = v9;
    -[CWFNetworkDenyList setBatteryInfoHandler:](v57, "setBatteryInfoHandler:", v90);
    v89[0] = _NSConcreteStackBlock;
    v89[1] = 3221225472LL;
    v89[2] = sub_1000FD9E8;
    v89[3] = &unk_1001E4E78;
    v89[4] = v9;
    -[CWFNetworkDenyList setIsUserModeInteractiveHandler:](v57, "setIsUserModeInteractiveHandler:", v89);
    v88[0] = _NSConcreteStackBlock;
    v88[1] = 3221225472LL;
    v88[2] = sub_1000FDA10;
    v88[3] = &unk_1001E4E98;
    v88[4] = v9;
    -[CWFNetworkDenyList setDenyListDidUpdateHandler:](v57, "setDenyListDidUpdateHandler:", v88);
    *(void *)(v9 + 6632) = v57;
    if (!v57) {
      goto LABEL_114;
    }
  }

  else
  {
    CFIndex v58 = -[WiFiNetworkDenyListManager initWithArgs:interfaceName:]( objc_alloc(&OBJC_CLASS___WiFiNetworkDenyListManager),  "initWithArgs:interfaceName:",  v9,  sub_10004CE2C(*(void *)(v9 + 64)));
    *(void *)(v9 + 6624) = v58;
    if (!v58) {
      goto LABEL_114;
    }
    char v59 = -[WiFiNetworkDenyListManager networkDenyList](v58, "networkDenyList");
    *(void *)(v9 + 6632) = v59;
    if (!v59) {
      goto LABEL_114;
    }
  }

  *(void *)(v9 + 6640) = 0LL;
  *(_WORD *)(v9 + 6584) = -1;
  *(void *)(v9 + 660_Block_object_dispose((const void *)(v1 - 80), 8) = +[WiFiNOIManager sharedWiFiNOIManagerWithQueue:]( &OBJC_CLASS___WiFiNOIManager,  "sharedWiFiNOIManagerWithQueue:",  a3);
  *(_DWORD *)(v9 + 72) = MGGetSInt32Answer(@"DeviceClassNumber", 0LL);
  *(void *)(v9 + 80) = MGGetProductType();
  *(_BYTE *)(v9 + 8_Block_object_dispose((const void *)(v1 - 80), 8) = MGGetBoolAnswer(@"wapi");
  *(_BYTE *)(v9 + 6616) = *(_DWORD *)(v9 + 72) == 7;
  *(void *)(v9 + 6640) = 0LL;
  *(_DWORD *)(v9 + 664_Block_object_dispose((const void *)(v1 - 80), 8) = 0;
  *(_BYTE *)(v9 + 6696) = 0;
  CFMutableDictionaryRef v60 = CFDictionaryCreateMutable( kCFAllocatorDefault,  0LL,  &kCFTypeDictionaryKeyCallBacks,  &kCFTypeDictionaryValueCallBacks);
  *(void *)(v9 + 7016) = v60;
  if (!v60) {
    goto LABEL_114;
  }
  dispatch_source_t v61 = dispatch_source_create((dispatch_source_type_t)&_dispatch_source_type_timer, 0LL, 0LL, a3);
  *(void *)(v9 + 6760) = v61;
  if (!v61)
  {
    unsigned int v83 = objc_autoreleasePoolPush();
    if (qword_100219F60) {
      [qword_100219F60 WFLog:@"Error: failed to create autoHotspotScanTimer" message:4];
    }
    goto LABEL_113;
  }

  dispatch_set_context(v61, (void *)v9);
  dispatch_source_set_event_handler_f(*(dispatch_source_t *)(v9 + 6760), (dispatch_function_t)sub_1000CA478);
  *(CFAbsoluteTime *)(v9 + 6776) = CFAbsoluteTimeGetCurrent() + 315360000.0;
  dispatch_source_t v62 = dispatch_source_create((dispatch_source_type_t)&_dispatch_source_type_timer, 0LL, 0LL, a3);
  *(void *)(v9 + 676_Block_object_dispose((const void *)(v1 - 80), 8) = v62;
  if (!v62)
  {
    unsigned int v83 = objc_autoreleasePoolPush();
    if (qword_100219F60) {
      [qword_100219F60 WFLog:@"Error: failed to create autoHotspotLockStateTimer" message:4];
    }
    goto LABEL_113;
  }

  dispatch_set_context(v62, (void *)v9);
  dispatch_source_set_event_handler_f(*(dispatch_source_t *)(v9 + 6768), (dispatch_function_t)sub_1000CA6A4);
  id v63 = objc_alloc_init(&OBJC_CLASS___WiFiHotspotInterface);
  *(void *)(v9 + 672_Block_object_dispose((const void *)(v1 - 80), 8) = v63;
  if (v63)
  {
    CFMutableArrayRef v64 = CFArrayCreateMutable(kCFAllocatorDefault, 0LL, &kCFTypeArrayCallBacks);
    *(void *)(v9 + 6792) = v64;
    if (!v64) {
      goto LABEL_114;
    }
    *(_BYTE *)(v9 + 6849) = 0;
    *(_BYTE *)(v9 + 6752) = 0;
    *(_BYTE *)(v9 + 6920) = 0;
    *(void *)(v9 + 6904) = 0LL;
    *(void *)(v9 + 6896) = 0LL;
    CFMutableArrayRef v65 = CFArrayCreateMutable(kCFAllocatorDefault, 0LL, &kCFTypeArrayCallBacks);
    *(void *)(v9 + 6864) = v65;
    if (!v65) {
      goto LABEL_114;
    }
    CFMutableArrayRef v66 = CFArrayCreateMutable(kCFAllocatorDefault, 0LL, &kCFTypeArrayCallBacks);
    *(void *)(v9 + 6872) = v66;
    if (!v66) {
      goto LABEL_114;
    }
    CFMutableArrayRef v67 = CFArrayCreateMutable(kCFAllocatorDefault, 0LL, &kCFTypeArrayCallBacks);
    *(void *)(v9 + 6880) = v67;
    if (!v67) {
      goto LABEL_114;
    }
    uint64_t v68 = objc_alloc_init(&OBJC_CLASS___NSMutableArray);
    *(void *)(v9 + 688_Block_object_dispose((const void *)(v1 - 80), 8) = v68;
    if (!v68) {
      goto LABEL_114;
    }
    *(void *)(v9 + 6856) = 0LL;
    *(int64x2_t *)(v9 + 6816) = vdupq_n_s64(0x405E000000000000uLL);
    *(_DWORD *)(v9 + 6840) = 2;
    *(void *)(v9 + 6832) = 0x300000002LL;
    *(_BYTE *)(v9 + 6976) = 0;
    *(void *)(v9 + 692_Block_object_dispose((const void *)(v1 - 80), 8) = 0LL;
    *(_DWORD *)(v9 + 6936) = 0;
    *(_BYTE *)(v9 + 6960) = 0;
    *(void *)(v9 + 6952) = 0LL;
    *(void *)(v9 + 6944) = 0LL;
    double v69 = *(void **)(v9 + 6728);
    v86[0] = _NSConcreteStackBlock;
    v86[1] = 3221225472LL;
    v86[2] = sub_1000CA7F0;
    v86[3] = &unk_1001E4B08;
    v86[4] = v9;
    [v69 registerHotspotInterfaceUpdateNetworkCallback:v86 withCallbackContext:v9];
  }

  *(_BYTE *)(v9 + 7009) = 0;
  *(_BYTE *)(v9 + 6996) = 0;
  CFMutableArrayRef v70 = CFArrayCreateMutable(kCFAllocatorDefault, 0LL, &kCFTypeArrayCallBacks);
  *(void *)(v9 + 3696) = v70;
  if (!v70 {
    || (CFMutableArrayRef v71 = CFArrayCreateMutable(kCFAllocatorDefault, 0LL, &kCFTypeArrayCallBacks),
  }
        (*(void *)(v9 + 372_Block_object_dispose((const void *)(v1 - 80), 8) = v71) == 0LL))
  {
LABEL_114:
    CFRelease((CFTypeRef)v9);
LABEL_115:
    v81 = objc_autoreleasePoolPush();
    if (qword_100219F60) {
      [qword_100219F60 WFLog:@"%s: exiting, Error: failed to create deviceManager ref" message:4];
    }
    uint64_t v9 = 0LL;
    goto LABEL_81;
  }

  *(_BYTE *)(v9 + 40) = 0;
  *(_BYTE *)(v9 + 7264) = 0;
  *(_DWORD *)(v9 + 44) = 0;
  *(_DWORD *)(v9 + 47) = 0;
  dispatch_source_t v72 = dispatch_source_create((dispatch_source_type_t)&_dispatch_source_type_timer, 0LL, 0LL, a3);
  *(void *)(v9 + 7272) = v72;
  if (!v72 {
    || (dispatch_set_context(v72, (void *)v9),
  }
        dispatch_source_set_event_handler_f(*(dispatch_source_t *)(v9 + 7272), (dispatch_function_t)sub_1000CCA94),
        *(_BYTE *)(v9 + 728_Block_object_dispose((const void *)(v1 - 80), 8) = 0,
        dispatch_source_t v73 = dispatch_source_create((dispatch_source_type_t)&_dispatch_source_type_timer, 0LL, 0LL, a3),
        (*(void *)(v9 + 7296) = v73) == 0LL))
  {
    unsigned int v83 = objc_autoreleasePoolPush();
    if (qword_100219F60) {
      [qword_100219F60 WFLog:@"%s: failed to create bssBlacklist.expiryTimer" message:4];
    }
    goto LABEL_113;
  }

  dispatch_set_context(v73, (void *)v9);
  dispatch_source_set_event_handler_f(*(dispatch_source_t *)(v9 + 7296), (dispatch_function_t)sub_1000CCB08);
  dispatch_source_t v74 = dispatch_source_create((dispatch_source_type_t)&_dispatch_source_type_timer, 0LL, 0LL, a3);
  *(void *)(v9 + 716_Block_object_dispose((const void *)(v1 - 80), 8) = v74;
  if (!v74)
  {
    unsigned int v83 = objc_autoreleasePoolPush();
    if (qword_100219F60) {
      [qword_100219F60 WFLog:@"%s: failed to create dps.displayTimer" message:4];
    }
    goto LABEL_113;
  }

  dispatch_set_context(v74, (void *)v9);
  dispatch_source_set_event_handler_f(*(dispatch_source_t *)(v9 + 7168), (dispatch_function_t)sub_1000CCB7C);
  dispatch_source_t v75 = dispatch_source_create((dispatch_source_type_t)&_dispatch_source_type_timer, 0LL, 0LL, a3);
  *(void *)(v9 + 720_Block_object_dispose((const void *)(v1 - 80), 8) = v75;
  if (!v75)
  {
    unsigned int v83 = objc_autoreleasePoolPush();
    if (qword_100219F60) {
      [qword_100219F60 WFLog:@"WiFiDeviceManagerCreate: failed to create slowWiFi.displayTimer"];
    }
LABEL_113:
    objc_autoreleasePoolPop(v83);
    goto LABEL_114;
  }

  dispatch_set_context(v75, (void *)v9);
  dispatch_source_set_event_handler_f(*(dispatch_source_t *)(v9 + 7208), (dispatch_function_t)sub_1000CCCAC);
  dispatch_source_t v76 = *(dispatch_source_t *)(v9 + 8920);
  if (v76
    || (dispatch_source_t v76 = dispatch_source_create((dispatch_source_type_t)&_dispatch_source_type_timer, 0LL, 0LL, a3),
        (*(void *)(v9 + 8920) = v76) != 0LL))
  {
    dispatch_set_context(v76, (void *)v9);
    dispatch_source_set_event_handler_f(*(dispatch_source_t *)(v9 + 8920), (dispatch_function_t)sub_1000CCDC0);
    dispatch_activate(*(dispatch_object_t *)(v9 + 8920));
  }

  dispatch_source_t v77 = *(dispatch_source_t *)(v9 + 3760);
  if (v77
    || (dispatch_source_t v77 = dispatch_source_create((dispatch_source_type_t)&_dispatch_source_type_timer, 0LL, 0LL, a3),
        (*(void *)(v9 + 3760) = v77) != 0LL))
  {
    dispatch_set_context(v77, (void *)v9);
    dispatch_source_set_event_handler_f(*(dispatch_source_t *)(v9 + 3760), (dispatch_function_t)sub_1000CD0B4);
    dispatch_activate(*(dispatch_object_t *)(v9 + 3760));
  }

  *(void *)(v9 + 3720) = 0LL;
  *(_BYTE *)(v9 + 3680) = 1;
  *(void *)(v9 + 3704) = MGCopyAnswer(@"WifiAddressData", 0LL);
  *(void *)(v9 + 7344) = 0LL;
  *(_DWORD *)(v9 + 7336) = 0;
  *(CFAbsoluteTime *)(v9 + 7256) = CFAbsoluteTimeGetCurrent();
  *(_BYTE *)(v9 + 724_Block_object_dispose((const void *)(v1 - 80), 8) = 0;
  *(void *)(v9 + 696) = 0LL;
  *(_OWORD *)(v9 + 1064) = 0u;
  *(_DWORD *)(v9 + 548_Block_object_dispose((const void *)(v1 - 80), 8) = 0;
  *(_BYTE *)(v9 + 5492) = 0;
  CFNumberRef v78 = objc_alloc_init(&OBJC_CLASS___WiFiScanObserver);
  *(void *)(v9 + 6664) = v78;
  id v79 = objc_alloc_init(&OBJC_CLASS___WiFiSettlementConfiguration);
  id v80 = [[WiFiSettlementObserver alloc] initWithScanProvider:v78 configuration:v79];
  *(void *)(v9 + 892_Block_object_dispose((const void *)(v1 - 80), 8) = v80;
  v85[0] = _NSConcreteStackBlock;
  v85[1] = 3221225472LL;
  v85[2] = sub_1000CD178;
  v85[3] = &unk_1001E4B28;
  v85[4] = v9;
  [v80 addSettlementCallback:v85];

  *(_BYTE *)(v9 + 9017) = 0;
  v81 = objc_autoreleasePoolPush();
  if (qword_100219F60) {
    objc_msgSend((id)qword_100219F60, "WFLog:message:", 4, "%s: exiting", "WiFiDeviceManagerCreate");
  }
LABEL_81:
  objc_autoreleasePoolPop(v81);
  objc_autoreleasePoolPop(v6);
  return v9;
}

void sub_1000BF474(uint64_t a1)
{
  int v2 = *(_DWORD *)(a1 + 3272);
  unsigned int v3 = objc_autoreleasePoolPush();
  if (v2 == 1)
  {
    if (qword_100219F60)
    {
      uint64_t v4 = +[NSString stringWithFormat:]( &OBJC_CLASS___NSString,  "stringWithFormat:",  @"%s",  -[NSString UTF8String]( +[NSString stringWithFormat:]( &OBJC_CLASS___NSString,  "stringWithFormat:",  @"{%@+} %@",  @"AUTOJOIN",  +[NSString stringWithFormat:]( &OBJC_CLASS___NSString,  "stringWithFormat:",  @"Retrying auto association")),  "UTF8String"));
      if (os_log_type_enabled((os_log_t)&_os_log_default, OS_LOG_TYPE_DEFAULT))
      {
        *(_DWORD *)buf = 136446210;
        uint64_t v6 = -[NSString UTF8String]( +[NSString stringWithFormat:]( &OBJC_CLASS___NSString,  "stringWithFormat:",  @"[WiFiPolicy] %s",  -[NSString UTF8String](v4, "UTF8String")),  "UTF8String");
        _os_log_impl( (void *)&_mh_execute_header,  (os_log_t)&_os_log_default,  OS_LOG_TYPE_DEFAULT,  "%{public}s",  buf,  0xCu);
      }
    }

    objc_autoreleasePoolPop(v3);
    *(_DWORD *)(a1 + 3272) = 0;
    if ((_os_feature_enabled_impl("CoreWiFi", "UnifiedAutoJoin") & 1) == 0)
    {
      [+[WiFiXPCManager sharedXPCManager](WiFiXPCManager, "sharedXPCManager") autoJoinStartedWithTrigger:4 interfaceName:sub_100043E8C(*(void *)(a1 + 64))];
      sub_1000D0CB8(a1, 0, (uint64_t)"__WiFiDeviceManagerRetryTimerCallback");
    }
  }

  else
  {
    if (qword_100219F60) {
      [(id)qword_100219F60 WFLog:3, "Attempting auto association retry but auto join state already is %@.", sub_1000BDC98(*(_DWORD *)(a1 + 3272)) message];
    }
    objc_autoreleasePoolPop(v3);
  }

void sub_1000BF668(uint64_t a1)
{
  int v2 = objc_autoreleasePoolPush();
  if (qword_100219F60) {
    [(id)qword_100219F60 WFLog:3 message:"Auto-join deferral expired. Triggering auto-join."];
  }
  objc_autoreleasePoolPop(v2);
  *(_DWORD *)(a1 + 352) = 0;
  *(void *)(a1 + 36_Block_object_dispose((const void *)(v1 - 80), 8) = 0LL;
  *(_DWORD *)(a1 + 192) = 12;
  if (_os_feature_enabled_impl("CoreWiFi", "UnifiedAutoJoin"))
  {
    sub_1000F5F98(a1, 0xEuLL);
  }

  else
  {
    [+[WiFiXPCManager sharedXPCManager](WiFiXPCManager, "sharedXPCManager") autoJoinStartedWithTrigger:14 interfaceName:sub_100043E8C(*(void *)(a1 + 64))];
    sub_1000D0A5C(a1, 2LL, (uint64_t)"__WiFiDeviceManagerDeferralTimerCallback");
  }

__CFArray *sub_1000BF728(char *a1, CFIndex capacity)
{
  int v2 = capacity;
  uint64_t v4 = capacity;
  CFMutableSetRef Mutable = CFArrayCreateMutable(kCFAllocatorDefault, capacity, &kCFTypeArrayCallBacks);
  if (v2 >= 1)
  {
    CFIndex v6 = 0LL;
    do
    {
      CFNumberRef v7 = CFNumberCreate(kCFAllocatorDefault, kCFNumberIntType, a1);
      if (v7)
      {
        CFNumberRef v8 = v7;
        CFArraySetValueAtIndex(Mutable, v6, v7);
        CFRelease(v8);
      }

      ++v6;
      a1 += 4;
    }

    while (v4 != v6);
  }

  return Mutable;
}

void sub_1000BF7D0(uint64_t a1, const void *a2, uint64_t a3)
{
  if (a3)
  {
    CFIndex v6 = objc_autoreleasePoolPush();
    CFNumberRef v7 = sub_1000DEA34(a3, a2, 1);
    if (!v7)
    {
LABEL_41:
      objc_autoreleasePoolPop(v6);
      return;
    }

    CFNumberRef v8 = v7;
    sub_1000A4754((uint64_t)v7);
    if (sub_10003E7A4(*(void *)(a3 + 64)))
    {
      int v9 = sub_10003E534(*(void *)(a3 + 64));
      uint64_t v10 = (const void *)sub_100043E8C(a1);
      if (v9)
      {
        sub_10003EC6C(a1, v10, 482LL, 0LL, (uint64_t)kCFBooleanTrue);
        uint64_t v11 = objc_autoreleasePoolPush();
        if (qword_100219F60)
        {
          uint64_t v12 = sub_10004CE2C(*(void *)(a3 + 64));
          dispatch_source_t v13 = +[NSString stringWithFormat:]( &OBJC_CLASS___NSString,  "stringWithFormat:",  @"%s",  -[NSString UTF8String]( +[NSString stringWithFormat:]( &OBJC_CLASS___NSString,  "stringWithFormat:",  @"{%@-} %@",  @"AUTOJOIN",  +[NSString stringWithFormat:]( &OBJC_CLASS___NSString,  "stringWithFormat:",  @"WiFi(%@) has valid IP Address and primary interface for network: %@, Preventing Disassociation",  v12,  sub_100095BC8(v8))),  "UTF8String"));
          if (os_log_type_enabled((os_log_t)&_os_log_default, OS_LOG_TYPE_DEFAULT))
          {
            LODWORD(buf) = 136446210;
            *(void *)((char *)&buf + 4) = -[NSString UTF8String]( +[NSString stringWithFormat:]( &OBJC_CLASS___NSString,  "stringWithFormat:",  @"[WiFiPolicy] %s",  -[NSString UTF8String](v13, "UTF8String")),  "UTF8String");
            _os_log_impl( (void *)&_mh_execute_header,  (os_log_t)&_os_log_default,  OS_LOG_TYPE_DEFAULT,  "%{public}s",  (uint8_t *)&buf,  0xCu);
          }
        }
      }

      else
      {
        sub_10003EC6C(a1, v10, 482LL, 0LL, (uint64_t)kCFBooleanFalse);
        uint64_t v11 = objc_autoreleasePoolPush();
        if (qword_100219F60)
        {
          uint64_t v16 = sub_10004CE2C(*(void *)(a3 + 64));
          CFMutableArrayRef v17 = +[NSString stringWithFormat:]( &OBJC_CLASS___NSString,  "stringWithFormat:",  @"%s",  -[NSString UTF8String]( +[NSString stringWithFormat:]( &OBJC_CLASS___NSString,  "stringWithFormat:",  @"{%@-} %@",  @"AUTOJOIN",  +[NSString stringWithFormat:]( &OBJC_CLASS___NSString,  "stringWithFormat:",  @"WiFi(%@) has valid IP Address but not the primary interface for network: %@, Preventing Disassociation",  v16,  sub_100095BC8(v8))),  "UTF8String"));
          if (os_log_type_enabled((os_log_t)&_os_log_default, OS_LOG_TYPE_ERROR))
          {
            LODWORD(buf) = 136446210;
            *(void *)((char *)&buf + 4) = -[NSString UTF8String]( +[NSString stringWithFormat:]( &OBJC_CLASS___NSString,  "stringWithFormat:",  @"[WiFiPolicy] %s",  -[NSString UTF8String](v17, "UTF8String")),  "UTF8String");
            _os_log_impl( (void *)&_mh_execute_header,  (os_log_t)&_os_log_default,  OS_LOG_TYPE_ERROR,  "%{public}s",  (uint8_t *)&buf,  0xCu);
          }
        }
      }

      objc_autoreleasePoolPop(v11);
LABEL_19:
      char v18 = 0;
LABEL_20:
      CFMutableArrayRef v19 = sub_1000A47DC(*(const __CFArray **)(a3 + 3696), (const __CFDictionary **)v8);
      char v20 = v18 ^ 1;
      if (!a1) {
        char v20 = 1;
      }
      if ((v20 & 1) == 0)
      {
        CFMutableArrayRef v21 = v19;
        if (sub_100054B94(a1, v8))
        {
          uint64_t v22 = objc_autoreleasePoolPush();
          if (qword_100219F60) {
            [(id)qword_100219F60 WFLog:3, "%s: WFMacRandomisation : Network <%@> falling back to physical Mac since Interface not routable.", "__WiFiDeviceManagerPrimaryTimeoutCallback", sub_100095BC8(v8) message];
          }
          objc_autoreleasePoolPop(v22);
          if (*(_BYTE *)(a3 + 3680))
          {
            CFMutableArrayRef v23 = *(void (**)(uint64_t, void *, void))(a3 + 4704);
            if (v23) {
              v23(a3, v8, *(void *)(a3 + 4712));
            }
            if (v21)
            {
              *(void *)((char *)&buf + 4) = 0xAAAAAAAAAAAAAAAALL;
              LODWORD(buf) = 3;
              sub_100037928((uint64_t)v21, (uint64_t)&buf);
              sub_100037694((unsigned int *)&buf);
            }

            CFMutableArrayRef v24 = *(void **)(a3 + 7320);
            if (v24) {
              [v24 addFaultEvent:11 forInterface:a2];
            }
          }
        }

        else if (v21)
        {
          unint64_t v47 = 0xAAAAAAAAAAAAAAAALL;
          unsigned int v46 = 6;
          sub_100037928((uint64_t)v21, (uint64_t)&v46);
          sub_100037694(&v46);
          CFMutableArrayRef v25 = objc_autoreleasePoolPush();
          CFMutableArrayRef v26 = (void *)qword_100219F60;
          if (qword_100219F60)
          {
            CFMutableArrayRef v27 = sub_100095BC8(v8);
            [v26 WFLog:3, "%s: WFMacRandomisation : Network <%@> failed to get routable interface. PrivateMac used : <0 = used : %d>", "__WiFiDeviceManagerPrimaryTimeoutCallback", v27, v47 message];
          }

          objc_autoreleasePoolPop(v25);
          CFMutableArrayRef v28 = (const __CFDictionary *)sub_1000951FC((uint64_t)v21, @"PRIVATE_MAC_ADDRESS");
          if (v28)
          {
            CFTypeID TypeID = CFDictionaryGetTypeID();
            if (TypeID == CFGetTypeID(v28))
            {
              CFBooleanRef Value = (const __CFData *)CFDictionaryGetValue(v28, @"PRIVATE_MAC_ADDRESS_VALUE");
              if (sub_10003B498(Value))
              {
                if (!sub_1000971AC((uint64_t)v8) && *(void *)(a3 + 4736))
                {
                  if (*(void *)(a3 + 240))
                  {
                    *(void *)&__int128 buf = 0LL;
                    *((void *)&buf + 1) = &buf;
                    uint64_t v49 = 0x2020000000LL;
                    uint64_t v50 = 0LL;
                    CFTypeRef v41 = CFRetain(v21);
                    *(void *)(*((void *)&buf + 1) + 24LL) = v41;
                    CFRetain((CFTypeRef)a3);
                    dispatch_source_t v42 = *(dispatch_queue_s **)(a3 + 240);
                    block[0] = _NSConcreteStackBlock;
                    block[1] = 3221225472LL;
                    block[2] = sub_1000FDA5C;
                    block[3] = &unk_1001E2D48;
                    void block[4] = &buf;
                    void block[5] = a3;
                    dispatch_async(v42, block);
                    _Block_object_dispose(&buf, 8);
                  }

                  else
                  {
                    dispatch_source_t v43 = objc_autoreleasePoolPush();
                    if (qword_100219F60) {
                      [qword_100219F60 WFLog:@"%s: null queue." message:4];
                    }
                    objc_autoreleasePoolPop(v43);
                  }
                }
              }
            }
          }
        }
      }

      CFRelease(v8);
      goto LABEL_41;
    }

    uint64_t v14 = *(void **)(a3 + 7320);
    if (v14) {
      [v14 addFaultEvent:13 forInterface:sub_10004CE2C(*(void *)(a3 + 64))];
    }
    if (sub_1000971AC((uint64_t)v8))
    {
      CFMutableArrayRef v15 = objc_autoreleasePoolPush();
      if (qword_100219F60) {
        [(id)qword_100219F60 WFLog:3 message:"Ad-Hoc Network. Preventing disassociation"];
      }
      objc_autoreleasePoolPop(v15);
      goto LABEL_19;
    }

    if (*(_DWORD *)(a3 + 3272) != 14)
    {
      dispatch_source_t v44 = sub_1000951FC((uint64_t)v8, @"BSSID");
      CFMutableArrayRef v31 = objc_autoreleasePoolPush();
      if (qword_100219F60)
      {
        uint64_t v32 = sub_10004CE2C(*(void *)(a3 + 64));
        uint64_t v33 = sub_10003E7A4(*(void *)(a3 + 64)) ? "primary" : "routable";
        uint64_t v34 = +[NSString stringWithFormat:]( &OBJC_CLASS___NSString,  "stringWithFormat:",  @"%s",  -[NSString UTF8String]( +[NSString stringWithFormat:]( &OBJC_CLASS___NSString,  "stringWithFormat:",  @"{%@-} %@",  @"AUTOJOIN",  +[NSString stringWithFormat:]( &OBJC_CLASS___NSString,  "stringWithFormat:",  @"WiFi(%@) failed to become %s interface for network: %@",  v32,  v33,  sub_100095BC8(v8),  v44)),  "UTF8String"));
        if (os_log_type_enabled((os_log_t)&_os_log_default, OS_LOG_TYPE_ERROR))
        {
          LODWORD(buf) = 136446210;
          *(void *)((char *)&buf + 4) = -[NSString UTF8String]( +[NSString stringWithFormat:]( &OBJC_CLASS___NSString,  "stringWithFormat:",  @"[WiFiPolicy] %s",  -[NSString UTF8String](v34, "UTF8String")),  "UTF8String");
          _os_log_impl( (void *)&_mh_execute_header,  (os_log_t)&_os_log_default,  OS_LOG_TYPE_ERROR,  "%{public}s",  (uint8_t *)&buf,  0xCu);
        }
      }

      objc_autoreleasePoolPop(v31);
      if (sub_100095B4C((uint64_t)v8))
      {
        sub_10004EC40(*(void *)(a3 + 64), v8, 0);
      }

      else
      {
        int v38 = (const __CFDate *)sub_10009A2C4((uint64_t)v8, 1);
        CFTypeRef v39 = (const __CFDate *)sub_10009A2C4((uint64_t)v8, 0);
        if (!v39 || v38 && CFDateCompare(v38, v39, 0LL) == kCFCompareGreaterThan)
        {
          dispatch_source_t v40 = objc_autoreleasePoolPush();
          if (qword_100219F60) {
            [(id)qword_100219F60 WFLog:3 message:"Network was intentionally joined.  Preventing disassociation."];
          }
          objc_autoreleasePoolPop(v40);
          goto LABEL_67;
        }
      }

      sub_1000CE074(a3, a2, 1005LL, "__WiFiDeviceManagerPrimaryTimeoutCallback", 7809LL);
      if (sub_1000957F4((BOOL)v8)
        && !sub_100095B4C((uint64_t)v8)
        && (sub_100096BF4((uint64_t)v8, @"WEP_AUTH_Flags") & 4) != 0)
      {
        id v35 = sub_1000A335C(*(void *)(a3 + 3504));
        if (([*(id *)(a3 + 6632) isNetworkInDenyListedState:1 scanResult:v35] & 1) == 0
          && *(_DWORD *)(a3 + 3272) == 14)
        {
          CFMutableSetRef v36 = objc_autoreleasePoolPush();
          if (qword_100219F60) {
            [(id)qword_100219F60 WFLog:3, "Dispatched password panel for open auth WEP network: %@", sub_100095BC8(v8) message];
          }
          objc_autoreleasePoolPop(v36);
        }

        id v37 = sub_1000D1BDC(a3, 1LL, 0LL, (uint64_t)v44, 5LL);
        [*(id *)(a3 + 6632) setNetworkDenyListInfo:v37 forScanResult:v35];
      }
    }

void sub_1000C0074( _Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, ...)
{
}

void sub_1000C0094(uint64_t a1, const void *a2, uint64_t a3)
{
  if (a3)
  {
    unsigned int v5 = sub_10004CE50(*(void *)(a3 + 64), a2);
    CFIndex v6 = objc_autoreleasePoolPush();
    CFNumberRef v7 = (void *)qword_100219F60;
    if (qword_100219F60)
    {
      CFNumberRef v8 = sub_10003AE44(v5);
      objc_msgSend( v7,  "WFLog:message:",  3,  "%s: device powered %s, manager->poweredState %s",  "__WiFiDeviceManagerPowerEventCallback",  v8,  sub_10003AE44(*(_DWORD *)(a3 + 20)));
    }

    objc_autoreleasePoolPop(v6);
    if (v5 == 1)
    {
      uint64_t v9 = *(unsigned int *)(a3 + 20);
      if ((_DWORD)v9 == 1)
      {
        *(_DWORD *)(a3 + 192) = 3;
        if (_os_feature_enabled_impl("CoreWiFi", "UnifiedAutoJoin"))
        {
          sub_1000F5F98(a3, 0x12uLL);
        }

        else
        {
          [+[WiFiXPCManager sharedXPCManager](WiFiXPCManager, "sharedXPCManager") autoJoinStartedWithTrigger:18 interfaceName:sub_100043E8C(*(void *)(a3 + 64))];
          sub_1000D0A5C(a3, 2LL, (uint64_t)"__WiFiDeviceManagerPowerEventCallback");
        }

        sub_1000D4854(a3);
        goto LABEL_13;
      }
    }

    else
    {
      uint64_t v16 = 0LL;
      __int128 v14 = 0u;
      __int128 v15 = 0u;
      uint64_t v12 = 3LL;
      memset(v11, 0, sizeof(v11));
      DWORD2(v11[0]) = 3;
      CFStringRef v13 = CFStringCreateWithFormat(kCFAllocatorDefault, 0LL, @"%@", @"Power Off");
      sub_1000DC1AC(a3, (uint64_t)v11);
      sub_1000DC604(a3);
      uint64_t v9 = *(unsigned int *)(a3 + 20);
      if (v5 == (_DWORD)v9)
      {
LABEL_13:
        uint64_t v10 = *(void **)(a3 + 7320);
        if (v10) {
          [v10 setPowerState:v5 != 0 forInterface:a2];
        }
        return;
      }
    }

    sub_1000DDF64(a3, (uint64_t)a2);
    goto LABEL_13;
  }

void sub_1000C0288(int a1, const void *a2, uint64_t a3, CFDictionaryRef theDict)
{
  if (!a3 || !theDict) {
    return;
  }
  v170 = (unsigned __int8 *)(a3 + 5208);
  int v188 = 0;
  uint64_t v187 = 0LL;
  CFBooleanRef Value = (void *)CFDictionaryGetValue(theDict, @"LINK_CHANGED_NETWORK");
  CFNumberRef v8 = Value;
  else {
    uint64_t v9 = 0LL;
  }
  int v169 = *(unsigned __int8 *)(a3 + 3403);
  v170[1392] = 0;
  *(_DWORD *)(a3 + 3384) = 0;
  uint64_t v10 = *(const void **)(a3 + 6592);
  if (v10)
  {
    CFRelease(v10);
    *(void *)(a3 + 6592) = 0LL;
  }

  if (*(void *)(a3 + 4032))
  {
    uint64_t v183 = 0LL;
    v184 = &v183;
    uint64_t v185 = 0x2020000000LL;
    uint64_t v186 = 0LL;
    uint64_t v179 = 0LL;
    v180 = &v179;
    uint64_t v181 = 0x2020000000LL;
    uint64_t v182 = 0LL;
    if (a2)
    {
      CFTypeRef v11 = CFRetain(a2);
      v184[3] = (uint64_t)v11;
    }

    CFTypeRef v12 = CFRetain(theDict);
    v180[3] = (uint64_t)v12;
    if (!Value) {
      goto LABEL_55;
    }
    int v13 = *(unsigned __int8 *)(a3 + 3404);
    int v14 = *(unsigned __int8 *)(a3 + 3424);
    if (*(_BYTE *)(a3 + 55))
    {
      __int128 v15 = objc_autoreleasePoolPush();
      if (qword_100219F60) {
        [(id)qword_100219F60 WFLog:4 message:"!!!! Simulating wifi-assist override condition (Debug Mode) !!!!"];
      }
      objc_autoreleasePoolPop(v15);
    }

    if (v13 || *(_BYTE *)(a3 + 55) && *(_BYTE *)(a3 + 52))
    {
      char v16 = 0;
      int v17 = 1;
    }

    else
    {
      int v17 = 0;
      char v16 = 1;
    }

    *(_BYTE *)(a3 + 52) = v17;
    if (v14 || *(_BYTE *)(a3 + 55) && *(_BYTE *)(a3 + 54))
    {
      *(_BYTE *)(a3 + 54) = 1;
      unsigned int v18 = v17 + 1;
    }

    else
    {
      *(_BYTE *)(a3 + 54) = 0;
      if ((v16 & 1) != 0)
      {
        CFDictionarySetValue(theDict, @"WIFI_ASSIST_OVERRIDE", kCFBooleanFalse);
        CFMutableSetRef v30 = objc_autoreleasePoolPush();
        if (qword_100219F60) {
          [qword_100219F60 WFLog:@"__WiFiDeviceManagerOverrideGoodRssiWiFiAssist: wifi-assist override to auto" message:4];
        }
        goto LABEL_45;
      }

      unsigned int v18 = 1;
    }

    CFDictionarySetValue(theDict, @"WIFI_ASSIST_OVERRIDE", kCFBooleanTrue);
    CFMutableArrayRef v19 = objc_autoreleasePoolPush();
    if (qword_100219F60) {
      [(id)qword_100219F60 WFLog:4, "%s: wifi-assist override to On for %@", "__WiFiDeviceManagerOverrideGoodRssiWiFiAssist", sub_100095BC8(Value) message];
    }
    objc_autoreleasePoolPop(v19);
    if (v18 > 1)
    {
      CFMutableSetRef Mutable = CFArrayCreateMutable(kCFAllocatorDefault, 0LL, &kCFTypeArrayCallBacks);
      if (Mutable)
      {
        valuePtr[0] = 0;
        CFNumberRef v27 = CFNumberCreate(kCFAllocatorDefault, kCFNumberIntType, valuePtr);
        if (!v27) {
          goto LABEL_328;
        }
        CFArrayAppendValue(Mutable, v27);
        CFMutableArrayRef v28 = objc_autoreleasePoolPush();
        if (qword_100219F60) {
          [(id)qword_100219F60 WFLog:4, "%s: wifi-assist override reason moving network %@", "__WiFiDeviceManagerOverrideGoodRssiWiFiAssist", sub_100095BC8(Value) message];
        }
        objc_autoreleasePoolPop(v28);
        CFRelease(v27);
        valuePtr[0] = 1;
        CFNumberRef v20 = CFNumberCreate(kCFAllocatorDefault, kCFNumberIntType, valuePtr);
        if (v20)
        {
          CFArrayAppendValue(Mutable, v20);
          CFMutableArrayRef v29 = objc_autoreleasePoolPush();
          if (qword_100219F60) {
            [(id)qword_100219F60 WFLog:4, "%s:wifi-assist override reason network bad reputation %@", "__WiFiDeviceManagerOverrideGoodRssiWiFiAssist", sub_100095BC8(Value) message];
          }
          objc_autoreleasePoolPop(v29);
          CFDictionarySetValue(theDict, @"WIFI_ASSIST_OVERRIDE_REASONS", Mutable);
        }

        else
        {
LABEL_328:
          v165 = objc_autoreleasePoolPush();
          if (qword_100219F60) {
            [qword_100219F60 WFLog:@"%s: CFNumberCreate failed" message:4];
          }
          objc_autoreleasePoolPop(v165);
          CFNumberRef v20 = 0LL;
        }

        goto LABEL_47;
      }

      CFMutableSetRef v30 = objc_autoreleasePoolPush();
      if (qword_100219F60) {
        [qword_100219F60 WFLog:@"%s: CFArrayCreateMutable failed" message:4];
      }
    }

    else
    {
      valuePtr[0] = *(_BYTE *)(a3 + 52) == 0;
      CFNumberRef v20 = CFNumberCreate(kCFAllocatorDefault, kCFNumberIntType, valuePtr);
      if (v20)
      {
        CFDictionarySetValue(theDict, @"WIFI_ASSIST_OVERRIDE_REASON", v20);
        CFMutableArrayRef v21 = objc_autoreleasePoolPush();
        uint64_t v22 = (void *)qword_100219F60;
        if (qword_100219F60)
        {
          int v23 = *(unsigned __int8 *)(a3 + 52);
          CFMutableArrayRef v24 = sub_100095BC8(Value);
          CFMutableArrayRef v25 = "moving";
          if (!v23) {
            CFMutableArrayRef v25 = "bad reputation";
          }
          [v22 WFLog:4, "%s: wifi-assist override reason %s network %@", "__WiFiDeviceManagerOverrideGoodRssiWiFiAssist", v25, v24 message];
        }

        objc_autoreleasePoolPop(v21);
        goto LABEL_46;
      }

      CFMutableSetRef v30 = objc_autoreleasePoolPush();
      if (qword_100219F60) {
        [qword_100219F60 WFLog:@"%s: CFNumberCreate failed" message:4];
      }
    }

LABEL_218:
          v170[1640] = 0;
          v109 = *(const void **)(a3 + 6928);
          if (v109)
          {
            CFRelease(v109);
            *(void *)(a3 + 692_Block_object_dispose(va, 8) = 0LL;
          }

          *(void *)(a3 + 692_Block_object_dispose(va, 8) = 0LL;
          v170[1731] = 0;
          char v110 = !v56;
          if (!v9) {
            char v110 = 1;
          }
          if ((v110 & 1) == 0)
          {
            v111 = (const __CFString *)sub_1000951FC((uint64_t)v9, @"BSSID");
            sub_10009BAA4((uint64_t)v9, v111, v57);
            v112 = objc_autoreleasePoolPush();
            if (qword_100219F60) {
              [qword_100219F60 WFLog:@"__WiFiDeviceManagerLinkEventCallback: updating network disconnect reason to %d" message:3 v57];
            }
            objc_autoreleasePoolPop(v112);
            sub_1000DAB00((dispatch_queue_s **)a3, v9);
          }

          sub_10001BBC8(*(void *)(a3 + 120), 0LL, 1LL, 0);
          if (*(_BYTE *)(a3 + 433)) {
            sub_1000F5218(a3, 2LL);
          }
          [*(id *)(a3 + 3648) setLinkDown];
          if (*(_BYTE *)(a3 + 433))
          {
            v113 = CFDictionaryCreateMutable(0LL, 0LL, &kCFTypeDictionaryKeyCallBacks, &kCFTypeDictionaryValueCallBacks);
            LODWORD(v183) = *(unsigned __int8 *)(a3 + 417);
            CFNumberRef v114 = CFNumberCreate(kCFAllocatorDefault, kCFNumberSInt32Type, &v183);
            CFDictionarySetValue(v113, @"CATS_SCAN_METRIC_CACHE_HITS", v114);
            if (v114) {
              CFRelease(v114);
            }
            LODWORD(v179) = *(unsigned __int8 *)(a3 + 418);
            CFNumberRef v115 = CFNumberCreate(kCFAllocatorDefault, kCFNumberSInt32Type, &v179);
            CFDictionarySetValue(v113, @"CATS_SCAN_METRIC_CACHE_MISS", v115);
            if (v115) {
              CFRelease(v115);
            }
            sub_100037FD4(v113);
            if (v113) {
              CFRelease(v113);
            }
          }

          int v116 = (const __CFDictionary **)v9;
          if (!v9) {
            int v116 = *(const __CFDictionary ***)(a3 + 3504);
          }
          v171[0] = _NSConcreteStackBlock;
          v171[1] = 3221225472LL;
          v171[2] = sub_1000FEDD0;
          v171[3] = &unk_1001E4ED8;
          char v173 = v174;
          v171[4] = a3;
          v171[5] = v58;
          unsigned int v172 = v176;
          sub_1000D8E24(a3, v116, (uint64_t)v171);
          if (v9)
          {
            int v117 = sub_10009DF44((uint64_t)v9);
            uint64_t v118 = (const __CFDictionary **)v9;
            if (v117)
            {
              *(_BYTE *)(a3 + 984) = v174 == 0;
              if ((unint64_t)(v58 - 1) > 1)
              {
                sub_1000FE674(a3, (uint64_t)v9, v58, v176);
              }

              else
              {
                *(void *)(a3 + 96_Block_object_dispose(va, 8) = sub_100094E60((uint64_t)kCFAllocatorDefault, (uint64_t)v9);
                *(_DWORD *)(a3 + 976) = v58;
                *(_DWORD *)(a3 + 980) = v176;
                CFRange v119 = *(dispatch_source_s **)(a3 + 992);
                dispatch_time_t v120 = dispatch_time(0LL, 10000000000LL);
                dispatch_source_set_timer(v119, v120, 0xFFFFFFFFFFFFFFFFLL, 0LL);
                v121 = objc_autoreleasePoolPush();
                if (qword_100219F60) {
                  [qword_100219F60 WFLog:@"__WiFiDeviceManagerLinkEventCallback trigger 10 second timer to check whether or not CarPlay disconnect is intended."];
                }
                objc_autoreleasePoolPop(v121);
              }

              dispatch_source_set_timer( *(dispatch_source_t *)(a3 + 1048),  0xFFFFFFFFFFFFFFFFLL,  0xFFFFFFFFFFFFFFFFLL,  0LL);
              uint64_t v118 = (const __CFDictionary **)v9;
            }
          }

          else
          {
            uint64_t v118 = *(const __CFDictionary ***)(a3 + 3504);
          }

          v122 = sub_1000A47DC(*(const __CFArray **)(a3 + 3696), v118);
          if (v122)
          {
            LODWORD(v187) = 1;
            sub_100037928((uint64_t)v122, (uint64_t)&v187);
            sub_100037694((unsigned int *)&v187);
          }

          sub_1000FEE48(a3);
          CFArrayRemoveAllValues(*(CFMutableArrayRef *)(a3 + 272));
          if (v168 != 14 && v169)
          {
            *(_DWORD *)(a3 + 192) = 4;
            if (_os_feature_enabled_impl("CoreWiFi", "UnifiedAutoJoin"))
            {
              sub_1000F5F98(a3, 2uLL);
            }

            else
            {
              [+[WiFiXPCManager sharedXPCManager](WiFiXPCManager, "sharedXPCManager") autoJoinStartedWithTrigger:2 interfaceName:sub_100043E8C(*(void *)(a3 + 64))];
              sub_1000D0A5C(a3, 2LL, (uint64_t)"__WiFiDeviceManagerLinkEventCallback");
            }
          }

          if (*(void *)(a3 + 5400) && !*(_BYTE *)(a3 + 3297))
          {
            v123 = objc_autoreleasePoolPush();
            if (qword_100219F60) {
              [qword_100219F60 WFLog:@"__WiFiDeviceManagerLinkEventCallback: disassociated and auto-join disabled. Releasing PPM resource."];
            }
            objc_autoreleasePoolPop(v123);
            sub_1000D0894(a3);
          }

          if (*(_DWORD *)(a3 + 72) == 7)
          {
            v124 = *(dispatch_source_s **)(a3 + 5520);
            dispatch_time_t v125 = dispatch_time(0LL, 45000000000LL);
            dispatch_source_set_timer(v124, v125, 0xFFFFFFFFFFFFFFFFLL, 0LL);
          }

          v126 = objc_autoreleasePoolPush();
          [*(id *)(a3 + 6608) disarmHomeNetworkTransitionTimer];
          [*(id *)(a3 + 6688) dismissJoinAlerts];
          objc_autoreleasePoolPop(v126);
          v127 = (const __CFNumber *)CFDictionaryGetValue(theDict, @"CLIENT_REASON");
          v128 = v170;
          if (!v127) {
            goto LABEL_277;
          }
          CFNumberGetValue(v127, kCFNumberIntType, &v175);
          unsigned int v129 = v175;
          if (v175 == 2)
          {
            int v130 = sub_100053B20(*(void *)(a3 + 64));
            if (v9 && v130 == 1)
            {
              v131 = sub_100094E60((uint64_t)kCFAllocatorDefault, (uint64_t)v9);
              if (v131)
              {
                v132 = v131;
                v133 = objc_autoreleasePoolPush();
                if (qword_100219F60) {
                  [(id)qword_100219F60 WFLog:3, "%s: client disabled link due to captive %@", "__WiFiDeviceManagerLinkEventCallback", sub_100095BC8(v132) message];
                }
                objc_autoreleasePoolPop(v133);
                uint64_t v134 = sub_100043E8C(*(void *)(a3 + 64));
                sub_1000EF770(a3, v134, 6LL, 0LL, v132, 0LL);
                CFRelease(v132);
LABEL_276:
                v128 = v170;
                goto LABEL_277;
              }

              goto LABEL_277;
            }

            unsigned int v129 = v175;
          }

          if (v129)
          {
            v135 = objc_autoreleasePoolPush();
            v136 = (void *)qword_100219F60;
            if (qword_100219F60)
            {
              v137 = sub_100095BC8(v9);
              v138 = sub_10003B3FC(v175);
              uint64_t v139 = v175;
              unsigned int v140 = sub_100053B20(*(void *)(a3 + 64));
              [v136 WFLog:3, "%s: client disabled network %@ with reason %@(%d) assocType %@", "__WiFiDeviceManagerLinkEventCallback", v137, v138, v139, sub_10003B474(v140) message];
            }

            objc_autoreleasePoolPop(v135);
            goto LABEL_276;
          }

        if (++v99 == v95)
        {
LABEL_236:
          if (Mutable)
          {
            if (CFStringGetLength(Mutable))
            {
              v123 = objc_autoreleasePoolPush();
              if (qword_100219F60) {
                [(id)qword_100219F60 WFLog:4, "Skipped the non-matching hidden networks - %@", Mutable message];
              }
              objc_autoreleasePoolPop(v123);
            }

            CFRelease(Mutable);
          }

          if (*(_DWORD *)(a1 + 3272) == 3 && CFArrayGetCount(*(CFArrayRef *)(a1 + 1104)) >= 1)
          {
            v124 = 0LL;
            do
            {
              dispatch_time_t v125 = CFArrayGetValueAtIndex(*(CFArrayRef *)(a1 + 1104), v124);
              if (sub_1000992D0((uint64_t)v125) == 1
                && !sub_100096BF4((uint64_t)v125, @"AJFoundOnDualBand")
                && !sub_100097264(v125))
              {
                v126 = CFStringCreateMutable(kCFAllocatorDefault, 0LL);
                ++*(_DWORD *)(a1 + 5840);
                if (v126)
                {
                  v127 = v126;
                  sub_1001067FC(a1, v125, v126);
                  v128 = objc_autoreleasePoolPush();
                  if (qword_100219F60) {
                    [(id)qword_100219F60 WFLog:4, "AJScan: Network found on 2Ghz only: {{ %@ }}", v127 message];
                  }
                  objc_autoreleasePoolPop(v128);
                  CFRelease(v127);
                }
              }

              ++v124;
            }

            while (v124 < CFArrayGetCount(*(CFArrayRef *)(a1 + 1104)));
          }

          sub_100106AF8(a1);
          [*(id *)(a1 + 3648) setScanResultsWithAutoJoinSessionCompletion:v38 complete:1];
          if (*(_DWORD *)(a1 + 3272) == 2)
          {
            unsigned int v129 = 0LL;
            int v130 = 0;
            v131 = 0;
            do
            {
              v132 = *(_DWORD *)&buf[v129];
              if (v132 > 9) {
                v131 = 1;
              }
              if (v132 > v130) {
                int v130 = *(_DWORD *)&buf[v129];
              }
              v129 += 4LL;
            }

            while (v129 != 52);
            v133 = v130 << 16;
          }

          else
          {
            v131 = 0;
            v133 = 0;
          }

          uint64_t v134 = CFArrayGetCount(*(CFArrayRef *)(a1 + 1104));
          v135 = (v134 - v97);
          v136 = CFArrayGetCount(*(CFArrayRef *)(a1 + 3560));
          v137 = CFArrayGetCount(*(CFArrayRef *)(a1 + 3552));
          v138 = v137;
          *(_DWORD *)(a1 + 5852) += v97;
          *(_DWORD *)(a1 + 5844) += v137;
          *(_DWORD *)(a1 + 5848) += v136;
          *(_DWORD *)(a1 + 5856) += v135;
          if (*(_DWORD *)(a1 + 3272) == 2)
          {
            *(_DWORD *)(a1 + 6136) = v133 | (2 * ((_DWORD)v97 != 0)) | (8 * (v131 != 0)) | (v134 != (_DWORD)v97) | (16 * ((_DWORD)v136 != 0)) | (4 * ((_DWORD)v137 != 0));
            if ((_DWORD)v97
              || v134
              || (_DWORD)v136
              || (_DWORD)v137
              || v131
              || *(_BYTE *)(a1 + 5600)
              || *(_BYTE *)(a1 + 3296))
            {
              uint64_t v139 = objc_autoreleasePoolPush();
              if (qword_100219F60) {
                objc_msgSend( (id)qword_100219F60,  "WFLog:message:",  4,  "AJScan: Found {%d Nw, %d hidden %d HS, %d HS20, busych %d, force %d} 2.4Ghz network, triggering 5Ghz scan\n",  v135,  v97,  v136,  v138,  v131,  *(unsigned __int8 *)(a1 + 3296));
              }
              objc_autoreleasePoolPop(v139);
              if ((_DWORD)v97) {
                ++*(_DWORD *)(a1 + 5812);
              }
              if (v134 != (_DWORD)v97) {
                ++*(_DWORD *)(a1 + 5828);
              }
              if ((_DWORD)v136) {
                ++*(_DWORD *)(a1 + 5820);
              }
              if ((_DWORD)v138) {
                ++*(_DWORD *)(a1 + 5816);
              }
              if (v131) {
                ++*(_DWORD *)(a1 + 5824);
              }
              unsigned int v140 = sub_1001010A4(a1);
              goto LABEL_312;
            }
          }

          sub_100107114(a1, *(const __CFArray **)(a1 + 1104));
          sub_100107114(a1, *(const __CFArray **)(a1 + 3560));
          sub_100107114(a1, *(const __CFArray **)(a1 + 3552));
          sub_100107620(*(const __CFArray **)(a1 + 1104), 1, (CFTypeRef *)(a1 + 1144));
LABEL_351:
          v165 = contexta;
          if (contexta)
          {
            v166 = a1;
            goto LABEL_375;
          }

          unsigned int v140 = sub_1001088A8(a1);
          goto LABEL_312;
        }
      }

    case 5:
      int v52 = *(const __CFArray **)(a1 + 1088);
      CFMutableSetRef v53 = *(_DWORD *)(a1 + 1080);
      contextb = objc_autoreleasePoolPush();
      if (!v53)
      {
        CFMutableSetRef v54 = *(const __CFArray **)(a1 + 3544);
        CFMutableSetRef v55 = *(void *)(a1 + 1136);
        *(void *)(a1 + 1136) = v55 + 1;
        BOOL v56 = CFArrayGetValueAtIndex(v54, v55);
        if (v52)
        {
          uint64_t v57 = v56;
          if (v56)
          {
            sub_10010622C(a1, v52);
            sub_100107620(v52, 0, 0LL);
            if (*(void *)(a1 + 1104)
              || (uint64_t v58 = CFArrayCreateMutable(kCFAllocatorDefault, 0LL, &kCFTypeArrayCallBacks),
                  (*(void *)(a1 + 1104) = v58) != 0LL))
            {
              uint64_t v59 = CFArrayGetCount(v52);
              if (v59)
              {
                id v60 = v59;
                v198.location = 0LL;
                v198.length = v59;
                if (CFArrayGetFirstIndexOfValue(v52, v198, v57) != -1)
                {
                  uint64_t v187 = CFArrayGetCount(*(CFArrayRef *)(a1 + 1104));
                  if (v60 >= 1)
                  {
                    unsigned int v61 = 0LL;
                    alloc = (CFAllocatorRef)v60;
                    do
                    {
                      int v62 = (const __CFDictionary **)CFArrayGetValueAtIndex(v52, v61);
                      if (v62)
                      {
                        unsigned int v63 = v62;
                        v191 = 0;
                        CFMutableArrayRef v64 = sub_1000FD668(a1, v62, 1, &v191);
                        if ((uint64_t)sub_100096BF4((uint64_t)v63, @"RSSI") >= (int)v64)
                        {
                          uint64_t v71 = sub_100094E60((uint64_t)kCFAllocatorDefault, (uint64_t)v63);
                          if (v71)
                          {
                            unsigned int v72 = v71;
                            sub_100095524((uint64_t)v71, (uint64_t)v57);
                            if (sub_1000951FC((uint64_t)v72, @"BSSID"))
                            {
                              dispatch_source_t v73 = *(void *)(a1 + 1112);
                              if (v73 < v187)
                              {
                                uint64_t v183 = v72;
                                do
                                {
                                  uint64_t v74 = (const __CFDictionary **)CFArrayGetValueAtIndex(*(CFArrayRef *)(a1 + 1104), v73);
                                  if (v74)
                                  {
                                    dispatch_source_t v75 = v74;
                                    if (sub_100098FAC(v74, v63))
                                    {
                                      dispatch_source_t v76 = sub_1000A335C((uint64_t)v75);
                                      if (![*(id *)(a1 + 6632) isNetworkInDenyListedState:1 scanResult:v76]) {
                                        goto LABEL_120;
                                      }
                                      *(void *)__int128 buf = 0LL;
                                      unsigned int valuePtr = 0.0;
                                      if ([*(id *)(a1 + 6632) isNetworkDenyListedForAutoJoinDueToTrigDisc:v76 RSSI:buf timestamp:&valuePtr])
                                      {
                                        if (sub_10001D56C( *(_DWORD **)(a1 + 120),  v75,  *(int *)buf,  valuePtr)) {
                                          goto LABEL_120;
                                        }
                                      }

                                      else
                                      {
                                        if (sub_1000FD1E4(a1, v75))
                                        {
LABEL_120:

                                          CFArraySetValueAtIndex(*(CFMutableArrayRef *)(a1 + 1104), v73, v72);
                                          break;
                                        }

                                        int v77 = objc_autoreleasePoolPush();
                                        if (qword_100219F60) {
                                          [(id)qword_100219F60 WFLog:3, "Skipping problematic network %@ for auto-join", sub_100095BC8(v75) message];
                                        }
                                        objc_autoreleasePoolPop(v77);
                                        id v60 = (uint64_t)alloc;
                                        unsigned int v72 = v183;
                                      }
                                    }
                                  }

                                  ++v73;
                                }

                                while (v187 != v73);
                              }
                            }

                            CFRelease(v72);
                            unsigned int v3 = (void **)&qword_100219F60;
                          }
                        }

                        else
                        {
                          int v65 = objc_autoreleasePoolPush();
                          char v66 = *v3;
                          if (*v3)
                          {
                            CFMutableArrayRef v67 = v3;
                            uint64_t v68 = sub_100095BC8(v63);
                            double v69 = sub_100096BF4((uint64_t)v63, @"RSSI");
                            else {
                              CFMutableArrayRef v70 = off_1001E57A8[v191 - 1];
                            }
                            [v66 WFLog:4, "Filtered hidden network %@ with RSSI %ld (%@ threshold %d)", v68, v69, v70, v64 message];
                            unsigned int v3 = v67;
                            id v60 = (uint64_t)alloc;
                          }

                          objc_autoreleasePoolPop(v65);
                        }
                      }

                      ++v61;
                    }

                    while (v61 != v60);
                  }
                }
              }
            }
          }
        }

        int v78 = sub_100109094(a1, *(const void **)(a1 + 1152));
        goto LABEL_124;
      }

      int v78 = sub_100105840(a1, v53);
LABEL_124:
      id v79 = v78;
      objc_autoreleasePoolPop(contextb);
      *(_DWORD *)(a1 + 3272) = v79;
      if (v79 > 1) {
        goto LABEL_342;
      }
      goto LABEL_313;
    case 6:
    case 7:
    case 8:
    case 9:
    case 0xA:
    case 0xB:
      unsigned int v5 = *(const __CFArray **)(a1 + 1088);
      CFIndex v6 = *(unsigned int *)(a1 + 1080);
      CFNumberRef v7 = CFArrayGetCount(*(CFArrayRef *)(a1 + 3616));
      CFNumberRef v8 = objc_autoreleasePoolPush();
      if (qword_100219F60)
      {
        uint64_t v9 = +[NSString stringWithFormat:]( &OBJC_CLASS___NSString,  "stringWithFormat:",  @"%s",  -[NSString UTF8String]( +[NSString stringWithFormat:]( &OBJC_CLASS___NSString,  "stringWithFormat:",  @"{%@*} %@",  @"AUTOJOIN",  +[NSString stringWithFormat:]( &OBJC_CLASS___NSString,  "stringWithFormat:",  @"%s: current state: %@",  "__WiFiDeviceManagerProcessMultiStageScanResults",  sub_1000BDC98(*(_DWORD *)(a1 + 3272)))),  "UTF8String"));
        if (os_log_type_enabled((os_log_t)&_os_log_default, OS_LOG_TYPE_DEFAULT))
        {
          uint64_t v10 = -[NSString UTF8String]( +[NSString stringWithFormat:]( &OBJC_CLASS___NSString,  "stringWithFormat:",  @"[WiFiPolicy] %s",  -[NSString UTF8String](v9, "UTF8String")),  "UTF8String");
          *(_DWORD *)__int128 buf = 136446210;
          *(void *)&uint8_t buf[4] = v10;
          _os_log_impl( (void *)&_mh_execute_header,  (os_log_t)&_os_log_default,  OS_LOG_TYPE_DEFAULT,  "%{public}s",  buf,  0xCu);
        }
      }

      objc_autoreleasePoolPop(v8);
      if ((_DWORD)v6)
      {
        uint64_t v167 = *(__CFArray **)(a1 + 3280);
        if (v167) {
          CFArrayRemoveAllValues(v167);
        }
        goto LABEL_355;
      }

      CFTypeRef v11 = *(_DWORD *)(a1 + 3272);
      if (v11 == 11) {
        unsigned int v5 = *(const __CFArray **)(a1 + 1096);
      }
      if (!v5) {
        goto LABEL_355;
      }
      if ((v11 & 0xFFFFFFFE) == 0xA)
      {
        sub_100106158(a1);
        *(CFAbsoluteTime *)(a1 + 328_Block_object_dispose(va, 8) = CFAbsoluteTimeGetCurrent();
      }

      if (!*(void *)(a1 + 1104))
      {
        CFTypeRef v12 = CFArrayCreateMutable(kCFAllocatorDefault, 0LL, &kCFTypeArrayCallBacks);
        *(void *)(a1 + 1104) = v12;
        if (!v12) {
          goto LABEL_355;
        }
      }

      sub_10010622C(a1, v5);
      int v13 = CFArrayGetCount(v5);
      int v14 = CFArrayGetCount(*(CFArrayRef *)(a1 + 3568));
      __int128 v15 = objc_autoreleasePoolPush();
      uint64_t v186 = v14;
      if (qword_100219F60) {
        [(id)qword_100219F60 WFLog:3, "%s: scanned# %ld, known# %ld, isHS20AccountConfigured %d, topRankedKnownNetwork %@", "__WiFiDeviceManagerProcessMultiStageScanResults", v13, v14, v7 > 0, sub_100095BC8(*(const void **)(a1 + 3368)) message];
      }
      objc_autoreleasePoolPop(v15);
      char v16 = v7 <= 0 && v14 == 0;
      if (v16 || v13 < 1) {
        goto LABEL_56;
      }
      for (CFIndex i = 0LL; i != v13; ++i)
      {
        unsigned int v18 = (void *)CFArrayGetValueAtIndex(v5, i);
        if (!v18) {
          continue;
        }
        CFMutableArrayRef v19 = v18;
        sub_100106604(a1, v18);
        if (v7 >= 1 && sub_100095318((BOOL)v19))
        {
          CFArrayAppendValue(*(CFMutableArrayRef *)(a1 + 1104), v19);
          continue;
        }

        CFNumberRef v20 = *(const void **)(a1 + 3368);
        if (v20 && ((CFMutableArrayRef v21 = *(_DWORD *)(a1 + 3272), v21 == 9) || v21 == 7))
        {
          if (CFEqual(v20, v19) != 1) {
            continue;
          }
          *(_DWORD *)__int128 buf = -1431655766;
          uint64_t v22 = sub_1000FD668(a1, v19, 1, (int *)buf);
          int v23 = sub_100096BF4((uint64_t)v19, @"RSSI");
          CFMutableArrayRef v24 = objc_autoreleasePoolPush();
          CFMutableArrayRef v25 = (void *)qword_100219F60;
          if ((uint64_t)v23 < (int)v22)
          {
            int v14 = v186;
            if (qword_100219F60)
            {
              uint64_t context = (void *)sub_100095BC8(v19);
              CFMutableArrayRef v26 = sub_100096BF4((uint64_t)v19, @"RSSI");
              else {
                CFNumberRef v27 = off_1001E57A8[*(_DWORD *)buf - 1];
              }
              [v25 WFLog:4, "Filtered top network %@ with RSSI %ld (%@ threshold %d)", context, v26, v27, v22 message];
            }

            objc_autoreleasePoolPop(v24);
            continue;
          }

          if (qword_100219F60) {
            [(id)qword_100219F60 WFLog:3, "%s: found the top network to match scanned network %@", "__WiFiDeviceManagerProcessMultiStageScanResults", sub_100095BC8(v19) message];
          }
          objc_autoreleasePoolPop(v24);
          CFArrayAppendValue(*(CFMutableArrayRef *)(a1 + 1104), *(const void **)(a1 + 3368));
          CFMutableSetRef v30 = *(void *)(a1 + 3368);
          int v14 = v186;
        }

        else
        {
          v196.location = 0LL;
          v196.length = v14;
          CFMutableArrayRef v28 = CFArrayGetFirstIndexOfValue(*(CFArrayRef *)(a1 + 3568), v196, v19);
          if (v28 == -1) {
            continue;
          }
          CFMutableArrayRef v29 = CFArrayGetValueAtIndex(*(CFArrayRef *)(a1 + 3568), v28);
          if (!v29) {
            continue;
          }
          CFMutableSetRef v30 = (uint64_t)v29;
          if (sub_10009DF44((uint64_t)v29))
          {
          }
        }

        CFMutableArrayRef v31 = sub_100094E60((uint64_t)kCFAllocatorDefault, (uint64_t)v19);
        if (v31)
        {
          uint64_t v32 = v31;
          sub_100095524((uint64_t)v31, v30);
          uint64_t v33 = *(const __CFArray **)(a1 + 1104);
          v197.length = CFArrayGetCount(v33);
          v197.location = 0LL;
          uint64_t v34 = CFArrayGetFirstIndexOfValue(v33, v197, v32);
          id v35 = *(__CFArray **)(a1 + 1104);
          if (v34 == -1)
          {
            CFArrayAppendValue(v35, v32);
          }

          else
          {
            CFMutableSetRef v36 = CFArrayGetValueAtIndex(v35, v34);
            char v37 = sub_10009712C((uint64_t)v36, @"Strength");
          }

          CFRelease(v32);
          int v14 = v186;
        }
      }

LABEL_277:
          v128[1489] = 0;
          sub_1000DE0D0(a3, 6u, valuePtr[0]);
          *(_DWORD *)(a3 + 3460) = 0;
          *(_OWORD *)(a3 + 3780) = 0u;
          *(_OWORD *)(a3 + 3796) = 0u;
          *(void *)(a3 + 3809) = 0LL;
          if (v9 && sub_100098BF8((uint64_t)v9))
          {
            v141 = sub_100095CB0(v9);
            sub_1000AEC14((uint64_t)v141);
          }

          goto LABEL_319;
        }

LABEL_108:
        CFNumberGetValue(v55, kCFNumberIntType, &v176);
        goto LABEL_109;
      }

      if (valuePtr[0] == 2)
      {
        BOOL v56 = *(_DWORD *)(a3 + 6200) < -80;
        uint64_t v57 = (4 * v56);
        if (!v55) {
          goto LABEL_109;
        }
        goto LABEL_108;
      }
    }

    LOBYTE(v56) = 0;
    uint64_t v57 = 0LL;
    if (!v55) {
      goto LABEL_109;
    }
    goto LABEL_108;
  }

  *CFMutableSetRef v36 = 256;
  if (sub_10009E054((uint64_t)Value))
  {
    *(_BYTE *)CFMutableSetRef v36 = 1;
    *(_OWORD *)(a3 + 8480) = 0u;
    *(_OWORD *)(a3 + 8496) = 0u;
    *(_OWORD *)(a3 + 8512) = 0u;
    *(CFAbsoluteTime *)(a3 + 852_Block_object_dispose(va, 8) = CFAbsoluteTimeGetCurrent();
  }

  sub_1000EB060(a3, (uint64_t)a2);
  if (*(_DWORD *)(a3 + 72) == 7) {
    dispatch_source_set_timer(*(dispatch_source_t *)(a3 + 5520), 0xFFFFFFFFFFFFFFFFLL, 0xFFFFFFFFFFFFFFFFLL, 0LL);
  }
  char v37 = 1;
  *(_BYTE *)(a3 + 3403) = 1;
  *(CFAbsoluteTime *)(a3 + 340_Block_object_dispose(va, 8) = CFAbsoluteTimeGetCurrent();
  if (!sub_10009F434((CFDictionaryRef *)Value)) {
    char v37 = objc_msgSend( +[WiFiAnalyticsManager sharedWiFiAnalyticsManager]( WiFiAnalyticsManager,  "sharedWiFiAnalyticsManager"),  "isMovingNetwork:",  Value);
  }
  sub_1000CF7C4(a3, v37);
  *(_BYTE *)(a3 + 3424) = 0;
  *(_WORD *)(a3 + 3440) = 0;
  if (v9
    && kCFBooleanFalse == sub_1000951FC((uint64_t)v9, @"WiFiNetworkAttributeIsTCPGood")
    && objc_msgSend( +[WiFiAnalyticsManager sharedWiFiAnalyticsManager]( WiFiAnalyticsManager,  "sharedWiFiAnalyticsManager"),  "isHistoricallyBadLinkQualityNetwork:",  Value))
  {
    *(_BYTE *)(a3 + 3424) = 1;
  }

  if (!*(_BYTE *)(a3 + 3404)) {
    sub_1000CFA74((unsigned __int8 *)a3);
  }
  sub_1000D3650(a3, Value);
  sub_100052728(*(void *)(a3 + 64), (uint64_t)Value);
  if (v170[3])
  {
    if (sub_1000DCBFC(a3, 4LL))
    {
      sub_1000D36F4((void *)a3, Value, 1, 3LL);
      int v38 = objc_autoreleasePoolPush();
      if (qword_100219F60) {
        [qword_100219F60 WFLog:@"%s: setting interface rank %s : reason %s ",  "__WiFiDeviceManagerLinkEventCallback",  "kSCNetworkServicePrimaryRankNever",  " Concurrency"];
      }
      objc_autoreleasePoolPop(v38);
    }

    else
    {
      sub_1000CE074(a3, a2, 1007LL, "__WiFiDeviceManagerLinkEventCallback", 8849LL);
    }
  }

  else
  {
    sub_1000D36F4((void *)a3, Value, 0, 0LL);
  }

  sub_1000D3A2C(a3, Value);
  if (v9)
  {
    unsigned int v63 = sub_10009C498((uint64_t)v9);
    CFMutableArrayRef v64 = sub_1000951FC((uint64_t)Value, @"BSSID");
    int v65 = sub_10009C030(v9, v64);
    char v66 = v65;
    if (v65)
    {
      CFMutableArrayRef v67 = objc_autoreleasePoolPush();
      uint64_t v68 = (void *)qword_100219F60;
      if (qword_100219F60)
      {
        double v69 = sub_1000951FC((uint64_t)Value, @"BSSID");
        [v68 WFLog:3, "Edge BSS detected - BSSID %@ SSID %@", v69, sub_100095BC8(Value) message];
      }

      objc_autoreleasePoolPop(v67);
    }

    if (v63)
    {
      CFMutableArrayRef v70 = objc_autoreleasePoolPush();
      if (qword_100219F60) {
        [(id)qword_100219F60 WFLog:3, "Detected multiAP environment for %@", sub_100095BC8(v9) message];
      }
      objc_autoreleasePoolPop(v70);
    }

    uint64_t v71 = *(void *)(a3 + 64);
    unsigned int v72 = sub_1000FDC1C(a3, v9);
    sub_10003E8CC(v71, (uint64_t)a2, v9, v72, 0LL, 0LL, 0);
    dispatch_source_t v73 = v9;
  }

  else
  {
    sub_10003E8CC(*(void *)(a3 + 64), (uint64_t)a2, 0LL, 1u, 0LL, 0LL, 0);
    char v66 = 0;
    dispatch_source_t v73 = Value;
  }

  sub_10001BBC8(*(void *)(a3 + 120), v73, 0LL, v66);
  [*(id *)(a3 + 3648) setLinkUpForNetwork:v73];
  if (*(_BYTE *)(a3 + 433)) {
    *(_WORD *)(a3 + 417) = 0;
  }
  *(CFAbsoluteTime *)(a3 + 704) = CFAbsoluteTimeGetCurrent();
  *(CFAbsoluteTime *)(a3 + 952) = CFAbsoluteTimeGetCurrent();
  uint64_t v74 = *(void *)(a3 + 968);
  if (v74)
  {
    dispatch_source_t v75 = (const __CFString *)sub_1000951FC((uint64_t)v73, @"SSID_STR");
    dispatch_source_t v76 = (const __CFString *)sub_1000951FC(v74, @"SSID_STR");
    int v77 = 0;
    int v78 = 1021;
    if (v75 && v76)
    {
      if (CFStringCompare(v75, v76, 0LL))
      {
        int v77 = 0;
      }

      else
      {
        int v78 = *(_DWORD *)(a3 + 976);
        int v77 = *(_DWORD *)(a3 + 980);
        id v79 = objc_autoreleasePoolPush();
        if (qword_100219F60) {
          [(id)qword_100219F60 WFLog:3, "%s: SSID (%@) matches", "__WiFiDeviceManagerLinkEventCallback", v75 message];
        }
        objc_autoreleasePoolPop(v79);
      }
    }

    dispatch_source_set_timer(*(dispatch_source_t *)(a3 + 992), 0xFFFFFFFFFFFFFFFFLL, 0xFFFFFFFFFFFFFFFFLL, 0LL);
    sub_1000FE674(a3, v74, v78, v77);
    id v80 = *(const void **)(a3 + 968);
    if (v80)
    {
      CFRelease(v80);
      *(void *)(a3 + 96_Block_object_dispose(va, 8) = 0LL;
    }
  }

  if (sub_10009DF44((uint64_t)Value))
  {
    *(_OWORD *)(a3 + 76_Block_object_dispose(va, 8) = 0u;
    *(_OWORD *)(a3 + 784) = 0u;
    *(void *)(a3 + 944) = 0LL;
    *(_OWORD *)(a3 + 912) = 0u;
    *(_OWORD *)(a3 + 92_Block_object_dispose(va, 8) = 0u;
    *(_OWORD *)(a3 + 880) = 0u;
    *(_OWORD *)(a3 + 896) = 0u;
    *(_OWORD *)(a3 + 84_Block_object_dispose(va, 8) = 0u;
    *(_OWORD *)(a3 + 864) = 0u;
    *(_OWORD *)(a3 + 816) = 0u;
    *(_OWORD *)(a3 + 832) = 0u;
    *(_OWORD *)(a3 + 800) = 0u;
    *(_OWORD *)(a3 + 736) = 0u;
    *(_OWORD *)(a3 + 752) = 0u;
    *(_DWORD *)(a3 + 74_Block_object_dispose(va, 8) = 0x7FFFFFFF;
    *(_DWORD *)(a3 + 76_Block_object_dispose(va, 8) = 0x7FFFFFFF;
    *(_DWORD *)(a3 + 840) = 0x7FFFFFFF;
    *(_DWORD *)(a3 + 792) = 0x7FFFFFFF;
    *(void *)(a3 + 816) = 0xFFFFFF807FFFFFFFLL;
    *(CFAbsoluteTime *)(a3 + 736) = CFAbsoluteTimeGetCurrent();
    *(_DWORD *)(a3 + 884) = 0;
    *(_BYTE *)(a3 + 1000) = 0;
    *(void *)(a3 + 1024) = 0LL;
    *(_OWORD *)(a3 + 100_Block_object_dispose(va, 8) = 0u;
    *(void *)(a3 + 1040) = 0LL;
    *(void *)(a3 + 1032) = 0LL;
  }

  v177[0] = _NSConcreteStackBlock;
  v177[1] = 3221225472LL;
  v177[2] = sub_1000FEC90;
  v177[3] = &unk_1001E4B88;
  v177[4] = a3;
  sub_1000D8E24(a3, (const __CFDictionary **)v73, (uint64_t)v177);
  v81 = sub_1000A47DC(*(const __CFArray **)(a3 + 3696), (const __CFDictionary **)v73);
  if (v81)
  {
    LODWORD(v187) = 0;
    sub_100037928((uint64_t)v81, (uint64_t)&v187);
    sub_100037694((unsigned int *)&v187);
  }

  CFIndex Count = CFArrayGetCount(*(CFArrayRef *)(a3 + 3528));
  LODWORD(v183) = 0;
  v170[376] = 0;
  if (Count)
  {
    v190.length = Count;
    v190.location = 0LL;
    FirstIndexOfCFBooleanRef Value = CFArrayGetFirstIndexOfValue(*(CFArrayRef *)(a3 + 3528), v190, Value);
    if (FirstIndexOfValue != -1)
    {
      ValueAtIndex = CFArrayGetValueAtIndex(*(CFArrayRef *)(a3 + 3528), FirstIndexOfValue);
      if (ValueAtIndex)
      {
        uint64_t v85 = (uint64_t)ValueAtIndex;
        __int128 v86 = (const __CFNumber *)sub_1000951FC((uint64_t)ValueAtIndex, @"WiFiManagerKnownNetworksEventType");
        CFNumberRef v87 = v86;
        if (v86) {
          CFNumberGetValue(v86, kCFNumberIntType, &v183);
        }
        if (!sub_10009860C(v85) && (!v87 || (_DWORD)v183 != 3))
        {
          v170[376] = 1;
          CFNumberRef v88 = objc_autoreleasePoolPush();
          if (qword_100219F60) {
            [(id)qword_100219F60 WFLog:3 message:"Enabling learning logic for Hidden property of the network\n"];
          }
          objc_autoreleasePoolPop(v88);
        }
      }
    }
  }

  __int128 v89 = v170;
  if (v170[1800] && v170[3] && *v170 <= 0xDu && (v170[1801] & 4) != 0)
  {
    if ((int v90 = sub_100096BF4((uint64_t)Value, @"CHANNEL"), v91 = *v170, v91 <= 0xD)
      && v90 <= 13
      && v91 != v90
      || v91 >= 0xF && v90 >= 15 && v91 != v90)
    {
      unsigned __int8 *v170 = v90;
      __int128 v92 = objc_autoreleasePoolPush();
      if (qword_100219F60) {
        [qword_100219F60 WFLog:@"Update MIS channel %d\n" message:3];
      }
      objc_autoreleasePoolPop(v92);
      __int128 v89 = v170;
    }
  }

  if (*(void *)(a3 + 6728))
  {
    v89[1641] = 0;
    if (CFArrayGetCount(*(CFArrayRef *)(a3 + 6864)))
    {
      CFArrayRemoveAllValues(*(CFMutableArrayRef *)(a3 + 6864));
      BOOL v93 = objc_autoreleasePoolPush();
      if (qword_100219F60) {
        [qword_100219F60 WFLog:@"Clearing all user suppressed Auto Hotspot Devices \n"];
      }
      objc_autoreleasePoolPop(v93);
    }

    if ([*(id *)(a3 + 6888) count]) {
      [*(id *)(a3 + 6888) removeAllObjects];
    }
    int v94 = sub_1000951FC((uint64_t)Value, @"SSID_STR");
    if (sub_100097700((uint64_t)Value))
    {
      if (CFArrayGetCount(*(CFArrayRef *)(a3 + 6872)))
      {
        CFIndex v95 = CFArrayGetCount(*(CFArrayRef *)(a3 + 6872));
        if (v95 >= 1)
        {
          CFIndex v96 = v95;
          CFIndex v97 = 0LL;
          while (1)
          {
            __int128 v98 = CFArrayGetValueAtIndex(*(CFArrayRef *)(a3 + 6872), v97);
            if (v96 == ++v97) {
              goto LABEL_286;
            }
          }

          v144 = objc_autoreleasePoolPush();
          if (qword_100219F60) {
            [(id)qword_100219F60 WFLog:3, "%s: Connected to Personal Hotspot %@ Unblacklisting %@\n", "__WiFiDeviceManagerClearSuppressedAutoHotSpotDevices", v94, v98 message];
          }
          objc_autoreleasePoolPop(v144);
          CFArrayRemoveValueAtIndex(*(CFMutableArrayRef *)(a3 + 6872), v97);
        }
      }
    }

    unsigned int v5 = objc_autoreleasePoolPush();
    if (qword_100219F60) {
      [qword_100219F60 WFLog:@"%s: triggerReason not present" message:3];
    }
    goto LABEL_45;
  }

  CFMutableArrayRef v28 = (const __CFDictionary *)CFDictionaryGetValue(a2, @"ConfigThreshold");
  if (v28)
  {
    CFMutableArrayRef v29 = v28;
    CFMutableSetRef v30 = objc_autoreleasePoolPush();
    if (qword_100219F60) {
      [qword_100219F60 WFLog:@"Processing WiFiDeviceManagerProcessWoWBlacklistCommand: ConfigThreshold" message:3];
    }
    objc_autoreleasePoolPop(v30);
    CFMutableArrayRef v31 = (const __CFNumber *)CFDictionaryGetValue(v29, @"triggerReason");
    if (v31)
    {
      CFNumberGetValue(v31, kCFNumberSInt32Type, (char *)&valuePtr + 4);
      uint64_t v32 = (const __CFNumber *)CFDictionaryGetValue(v29, @"perBSSIDThresh");
      if (v32)
      {
        CFNumberGetValue(v32, kCFNumberSInt32Type, &valuePtr);
        [*(id *)(a1 + 6632) setDenyListingThresholds:SHIDWORD(valuePtr) value:valuePtr forSSIDThresholds:0];
      }

      else
      {
        int v38 = objc_autoreleasePoolPush();
        if (qword_100219F60) {
          [qword_100219F60 WFLog:@"message:perBSSIDThresh not present"];
        }
        objc_autoreleasePoolPop(v38);
      }

      CFTypeRef v39 = (const __CFNumber *)CFDictionaryGetValue(v29, @"perSSIDThresh");
      if (v39)
      {
        CFNumberGetValue(v39, kCFNumberSInt32Type, &v92);
        [*(id *)(a1 + 6632) setDenyListingThresholds:SHIDWORD(valuePtr) value:v92 forSSIDThresholds:1];
LABEL_46:
        CFDictionaryRef Copy = 0LL;
        goto LABEL_88;
      }

      unsigned int v5 = objc_autoreleasePoolPush();
      if (qword_100219F60) {
        [qword_100219F60 WFLog:@"message: perSSIDThresh not present"];
      }
LABEL_45:
      objc_autoreleasePoolPop(v5);
      goto LABEL_46;
    }

    goto LABEL_108;
  }

  if (CFDictionaryContainsKey(a2, @"copyWoWBlacklistedNetworks"))
  {
    uint64_t v33 = objc_autoreleasePoolPush();
    uint64_t v34 = (const __CFString *)[*(id *)(a1 + 6632) denyListedNetworkSSIDs:3];
    id v35 = objc_autoreleasePoolPush();
    if (qword_100219F60) {
      [(id)qword_100219F60 WFLog:3, "%s: wowBlacklistedNetworksSsidList: %@", "__WiFiDeviceManagerWoWBlacklistCopyBlacklistedNetworksString", v34 message];
    }
    objc_autoreleasePoolPop(v35);
    CFDictionaryRef Copy = (__CFArray *)CFStringCreateCopy(kCFAllocatorDefault, v34);
    objc_autoreleasePoolPop(v33);
    CFMutableSetRef v36 = objc_autoreleasePoolPush();
    if (qword_100219F60) {
      [(id)qword_100219F60 WFLog:3, "%s: blacklist:%@", "WiFiDeviceManagerProcessWoWBlacklistCommandsAndCopyResponse", Copy message];
    }
    char v37 = v36;
    goto LABEL_87;
  }

  dispatch_source_t v40 = (const __CFDictionary *)CFDictionaryGetValue(a2, @"copyWoWBlacklistedNetworkProblemList");
  if (!v40)
  {
    if (CFDictionaryContainsKey(a2, @"copyBlacklistHistoryDump"))
    {
      dispatch_source_t v73 = objc_autoreleasePoolPush();
      if (qword_100219F60) {
        [qword_100219F60 WFLog:@"Processing WiFiDeviceManagerProcessWoWBlacklistCommand: copyBlacklistHistoryDump" message:3];
      }
      objc_autoreleasePoolPop(v73);
      [*(id *)(a1 + 6632) removeExpiredDenyListedState:3];
      uint64_t v74 = sub_1000D8278(a1);
    }

    else
    {
      dispatch_source_t v75 = (const __CFDictionary *)CFDictionaryGetValue(a2, @"configTimeout");
      if (v75)
      {
        dispatch_source_t v76 = v75;
        int v77 = objc_autoreleasePoolPush();
        if (qword_100219F60) {
          [(id)qword_100219F60 WFLog:3, "%s: Processing WiFiDeviceManagerProcessWoWBlacklistCommand: configTimeout:%@", "WiFiDeviceManagerProcessWoWBlacklistCommandsAndCopyResponse", v76 message];
        }
        objc_autoreleasePoolPop(v77);
        int v78 = (const __CFNumber *)CFDictionaryGetValue(v76, @"timeoutValue");
        if (v78)
        {
          if (CFNumberGetValue(v78, kCFNumberDoubleType, &v94)) {
            [*(id *)(a1 + 6632) setDenyListedStateExpiryIntervalInSec:3 state:v94];
          }
          goto LABEL_46;
        }

        unsigned int v5 = objc_autoreleasePoolPush();
        if (qword_100219F60) {
          [qword_100219F60 WFLog:@"numref is NULL!"];
        }
        goto LABEL_45;
      }

      if (!CFDictionaryContainsKey(a2, @"copyWoWBlacklistThreshold")) {
        goto LABEL_46;
      }
      id v79 = objc_autoreleasePoolPush();
      if (qword_100219F60) {
        [qword_100219F60 WFLog:@"Processing WiFiDeviceManagerProcessWoWBlacklistCommand: copyWoWBlacklistThreshold" message:3];
      }
      objc_autoreleasePoolPop(v79);
      uint64_t v74 = sub_1000D880C(a1);
    }

    CFDictionaryRef Copy = v74;
    goto LABEL_88;
  }

  CFTypeRef v41 = v40;
  dispatch_source_t v42 = objc_autoreleasePoolPush();
  if (qword_100219F60) {
    [qword_100219F60 WFLog:@"Processing WiFiDeviceManagerProcessWoWBlacklistCommand: copyWoWBlacklistedNetworkProblemList" message:3];
  }
  objc_autoreleasePoolPop(v42);
  cf1 = CFDictionaryGetValue(v41, @"SSID_STR");
  if (!cf1) {
    goto LABEL_110;
  }
  dispatch_source_t v43 = objc_autoreleasePoolPush();
  CFDictionaryRef Copy = CFArrayCreateMutable(kCFAllocatorDefault, 0LL, &kCFTypeArrayCallBacks);
  if (!Copy)
  {
    id v80 = objc_autoreleasePoolPush();
    v81 = (void *)qword_100219F60;
    if (!qword_100219F60) {
      goto LABEL_120;
    }
    v82 = "%s: problematicState is NULL!";
LABEL_116:
    unsigned int v83 = 3LL;
LABEL_119:
    [v81 WFLog:v83 message:v82 __WiFiDeviceManagerCopyWoWDenyListProblemList];
    goto LABEL_120;
  }

  __int128 v86 = [*(id *)(a1 + 6632) networksInDenyListedState:3];
  if (!v86)
  {
    id v80 = objc_autoreleasePoolPush();
    v81 = (void *)qword_100219F60;
    if (!qword_100219F60) {
      goto LABEL_120;
    }
    v82 = "%s: networkDenyListTimestamps is NULL";
    goto LABEL_116;
  }

  dispatch_source_t v44 = objc_alloc_init(&OBJC_CLASS___NSMutableArray);
  if (!v44)
  {
    id v80 = objc_autoreleasePoolPush();
    v81 = (void *)qword_100219F60;
    if (qword_100219F60)
    {
      v82 = "%s: networkDenyListTimestampList is NULL";
      unsigned int v83 = 4LL;
      goto LABEL_119;
    }

LABEL_286:
    if (CFArrayGetCount(*(CFArrayRef *)(a3 + 6880)))
    {
      CFIndex v145 = CFArrayGetCount(*(CFArrayRef *)(a3 + 6880));
      if (v145 >= 1)
      {
        CFIndex v146 = v145;
        CFIndex v147 = 0LL;
        while (1)
        {
          v148 = CFArrayGetValueAtIndex(*(CFArrayRef *)(a3 + 6880), v147);
          if (v148)
          {
            v149 = v148;
            if (sub_100097700((uint64_t)Value))
            {
              v150 = sub_100095BC8(v149);
              if (CFEqual(v94, v150)) {
                break;
              }
            }
          }

          if (v146 == ++v147) {
            goto LABEL_299;
          }
        }

        v151 = objc_autoreleasePoolPush();
        if (qword_100219F60) {
          [(id)qword_100219F60 WFLog:3, "%s: Allowlisting Personal Hotspot %@\n", "__WiFiDeviceManagerClearSuppressedAutoHotSpotDevices", sub_100095BC8(v149) message];
        }
        objc_autoreleasePoolPop(v151);
        CFArrayRemoveValueAtIndex(*(CFMutableArrayRef *)(a3 + 6880), v147);
      }
    }
  }

LABEL_299:
  int v152 = sub_100096BF4((uint64_t)Value, @"RSSI");
  uint64_t v153 = *(void *)(a3 + 64);
  int v154 = sub_100053B20(v153);
  sub_100028A60(v153, 1, 0, v154, dword_100219FA4, v152, v73, SHIDWORD(v187));
  uint64_t v155 = *(void *)(a3 + 3504);
  if (v155 && sub_100097700(v155))
  {
    LODWORD(v183) = -1431655766;
    uint64_t v156 = sub_10005439C(*(void *)(a3 + 64), &v183);
    if ((_DWORD)v156)
    {
      uint64_t v157 = v156;
      LODWORD(v183) = 111;
      v158 = objc_autoreleasePoolPush();
      if (qword_100219F60) {
        [qword_100219F60 WFLog:@" fail to get auth type after connect, error %d" message:3 v157];
      }
    }

    else
    {
      v158 = objc_autoreleasePoolPush();
      if (qword_100219F60) {
        [qword_100219F60 WFLog:@"Auth type for PH client is 0x%X" message:3 v183];
      }
    }

    objc_autoreleasePoolPop(v158);
    uint64_t v159 = v183;
    BOOL v160 = sub_1000957F4(*(void *)(a3 + 3504));
    int v161 = sub_100096D08(*(const __CFDictionary **)(a3 + 3504));
    *(_DWORD *)(a3 + 6460) = sub_100027DE8(v159, v160, v161);
  }

  dword_100219FA4 = 0;
  sub_1000DE0D0(a3, 3u, 0LL);
  *(_BYTE *)(a3 + 8773) = 0;
  int v162 = sub_10009A3FC((uint64_t)Value);
  *(_WORD *)(a3 + 3857) = 0;
  if (v162 > 79)
  {
    if (v162 == 80)
    {
      char v163 = 2;
      goto LABEL_318;
    }

    if (v162 == 160)
    {
      char v163 = 3;
      goto LABEL_318;
    }
  }

  else if (v162 == 20)
  {
    *(_BYTE *)(a3 + 3856) = 0;
  }

  else if (v162 == 40)
  {
    char v163 = 1;
LABEL_318:
    *(_BYTE *)(a3 + 3856) = v163;
  }

void sub_1000C1E70(_Unwind_Exception *a1)
{
}

uint64_t sub_1000C1E94(uint64_t a1, uint64_t a2)
{
  int v2 = *(uint64_t (**)(uint64_t, void))(a2 + 4016);
  if (v2) {
    return v2(a2, *(void *)(a2 + 4024));
  }
  else {
    return 0LL;
  }
}

void sub_1000C1EB4(uint64_t a1, const void *a2, uint64_t a3, uint64_t a4)
{
  CFNumberRef v7 = (const void *)sub_100040CF8(a1);
  if (a3)
  {
    if (a2 && (_DWORD)a4 && v7 && CFEqual(v7, a2))
    {
      if (sub_10004B9C0(*(void *)(a3 + 64)))
      {
        int64_t v8 = sub_100040CF8(*(void *)(a3 + 64));
        if (v8)
        {
          uint64_t v9 = (const void *)v8;
          *(_DWORD *)(a3 + 5416) = 0;
          sub_10004FAA4(*(void *)(a3 + 64), v8, (uint64_t)sub_1000FF0B4, a3);
          sub_10004FAB0(*(void *)(a3 + 64), v9, (uint64_t)sub_1000FF280, a3);
          sub_10004C92C(*(void *)(a3 + 64), v9, (uint64_t)sub_1000FF530, a3);
          sub_10004FADC(*(void *)(a3 + 64), v9, (uint64_t)sub_1000FF860, a3);
          sub_1000544F4(*(void *)(a3 + 64), v9, (uint64_t)sub_1000FF928, a3);
          sub_100054C64(*(void *)(a3 + 64), v9, (uint64_t)sub_1000FFB58, a3);
          goto LABEL_9;
        }

        CFTypeRef v11 = objc_autoreleasePoolPush();
        if (qword_100219F60) {
          [qword_100219F60 WFLog:@"%s: null awdlIfname." message:3];
        }
      }

      else
      {
        CFTypeRef v11 = objc_autoreleasePoolPush();
        if (qword_100219F60) {
          [qword_100219F60 WFLog:@"%s: AWDL is not supported on the device." message:3];
        }
      }

      objc_autoreleasePoolPop(v11);
LABEL_10:
      uint64_t v10 = *(void (**)(uint64_t, const void *, void, uint64_t))(a3 + 4416);
      if (v10) {
        v10(a3, a2, *(void *)(a3 + 4424), a4);
      }
      return;
    }

void sub_1000C2058(uint64_t a1, uint64_t a2, uint64_t *a3, int a4)
{
  if (!a3 || !a3[514]) {
    return;
  }
  int valuePtr = -1431655766;
  keys = @"HostApEnabled";
  values = kCFBooleanFalse;
  if (!a4)
  {
    CFDictionaryRef v15 = CFDictionaryCreate( 0LL,  (const void **)&keys,  (const void **)&values,  1LL,  &kCFTypeDictionaryKeyCallBacks,  &kCFTypeDictionaryValueCallBacks);
    ((void (*)(uint64_t *, uint64_t, CFDictionaryRef))a3[514])(a3, a3[515], v15);
    int v17 = objc_autoreleasePoolPush();
    if (qword_100219F60) {
      [qword_100219F60 WFLog:@"%s: hostAP stopped" message:3];
    }
    objc_autoreleasePoolPop(v17);
    int v13 = 0LL;
    goto LABEL_27;
  }

  unsigned int v5 = sub_1000DEFF8((uint64_t)a3);
  CFIndex v6 = v5;
  if (v5 && (int Count = CFArrayGetCount(v5), Count >= 1))
  {
    CFIndex v8 = 0LL;
    uint64_t v9 = Count;
    do
    {
      ValueAtIndex = CFArrayGetValueAtIndex(v6, v8);
      uint64_t v11 = (uint64_t)ValueAtIndex;
      if (ValueAtIndex)
      {
        CFTypeRef v12 = (const __CFNumber *)sub_1000951FC((uint64_t)ValueAtIndex, @"networkRole");
        if (v12)
        {
          CFNumberGetValue(v12, kCFNumberSInt32Type, &valuePtr);
          if (valuePtr == 3) {
            goto LABEL_13;
          }
          uint64_t v11 = 0LL;
        }
      }

      ++v8;
    }

    while (v9 != v8);
    if (!v11) {
      goto LABEL_22;
    }
LABEL_13:
    int v13 = sub_100012CEC(v11);
    if (v13)
    {
      MutableCFDictionaryRef Copy = CFDictionaryCreateMutableCopy(kCFAllocatorDefault, 0LL, v13);
      if (MutableCopy)
      {
        CFDictionaryRef v15 = MutableCopy;
        CFDictionaryAddValue(MutableCopy, @"HostApEnabled", kCFBooleanTrue);
        char v16 = objc_autoreleasePoolPush();
        if (qword_100219F60) {
          [qword_100219F60 WFLog:@"%s: hostAP started" message:3];
        }
        objc_autoreleasePoolPop(v16);
        ((void (*)(uint64_t *, uint64_t, CFDictionaryRef))a3[514])(a3, a3[515], v15);
        if (!v6) {
          goto LABEL_27;
        }
        goto LABEL_26;
      }
    }
  }

  else
  {
LABEL_22:
    int v13 = 0LL;
  }

  unsigned int v18 = objc_autoreleasePoolPush();
  if (qword_100219F60) {
    [qword_100219F60 WFLog:@"__WiFiDeviceManagerHostApStateChangedEventCallback: Error. Stopping HostAP network."];
  }
  objc_autoreleasePoolPop(v18);
  CFMutableArrayRef v19 = (const void *)sub_100043E8C(a3[8]);
  sub_1000DBA44((uint64_t)a3, v19, 0LL, 0LL, 0LL);
  CFDictionaryRef v15 = 0LL;
  if (!v6) {
    goto LABEL_27;
  }
LABEL_26:
  CFRelease(v6);
LABEL_27:
  if (v15) {
    CFRelease(v15);
  }
  if (v13) {
    CFRelease(v13);
  }
}

void sub_1000C2318(uint64_t a1, const void *a2, uint64_t a3)
{
  if (!a3) {
    return;
  }
  *(_DWORD *)(a3 + 6200) = 0;
  unsigned int v5 = sub_1000DEA34(a3, a2, 1);
  if (!v5) {
    return;
  }
  CFIndex v6 = v5;
  CFNumberRef v7 = (_WORD *)(a3 + 8558);
  CFIndex v8 = *(const __CFArray **)(a3 + 3520);
  if (v8)
  {
    v44.length = CFArrayGetCount(*(CFArrayRef *)(a3 + 3520));
    v44.location = 0LL;
    FirstIndexOfCFBooleanRef Value = CFArrayGetFirstIndexOfValue(v8, v44, v6);
    if (FirstIndexOfValue != -1)
    {
      ValueAtIndex = CFArrayGetValueAtIndex(*(CFArrayRef *)(a3 + 3520), FirstIndexOfValue);
      uint64_t v11 = (const __CFString *)sub_1000951FC((uint64_t)ValueAtIndex, @"BSSID");
      sub_10009BAA4((uint64_t)ValueAtIndex, v11, 1LL);
      sub_10009AB20(ValueAtIndex, v6);
      if (_os_feature_enabled_impl("CoreWiFi", "UnifiedAutoJoin"))
      {
        id v12 = sub_1000E359C(a3);
        if (v12)
        {
          int v13 = v12;
          uint64_t v14 = *(void *)(a3 + 6744);
          [v12 coordinate];
          CLLocationDegrees v16 = v15;
          [v13 coordinate];
          CLLocationDegrees v18 = v17;
          [v13 horizontalAccuracy];
          sub_10007E304(v14, ValueAtIndex, v16, v18, v19, [v13 timestamp]);
        }
      }

      sub_1000DAB00((dispatch_queue_s **)a3, ValueAtIndex);
      CFNumberRef v20 = sub_1000951FC((uint64_t)v6, @"BSSID");
      int v42 = sub_10009C030(ValueAtIndex, v20);
      if (v42)
      {
        CFMutableArrayRef v21 = objc_autoreleasePoolPush();
        uint64_t v22 = (void *)qword_100219F60;
        if (qword_100219F60)
        {
          int v23 = sub_1000951FC((uint64_t)v6, @"BSSID");
          [v22 WFLog:3, "Edge BSS detected - BSSID %@ SSID %@", v23, sub_100095BC8(v6) message];
        }

        objc_autoreleasePoolPop(v21);
      }

      if (sub_10009C498((uint64_t)ValueAtIndex))
      {
        CFMutableArrayRef v24 = objc_autoreleasePoolPush();
        if (qword_100219F60) {
          [(id)qword_100219F60 WFLog:3, "Detected multiAP environment for %@", sub_100095BC8(v6) message];
        }
        objc_autoreleasePoolPop(v24);
      }

      uint64_t v25 = *(void *)(a3 + 64);
      unsigned int v26 = sub_1000FDC1C(a3, ValueAtIndex);
      sub_10003E8CC(v25, (uint64_t)a2, ValueAtIndex, v26, 0LL, 0LL, 0);
      CFMutableSetRef Mutable = CFDictionaryCreateMutable( kCFAllocatorDefault,  0LL,  &kCFTypeDictionaryKeyCallBacks,  &kCFTypeDictionaryValueCallBacks);
      CFAbsoluteTime Current = CFAbsoluteTimeGetCurrent();
      CFDateRef v29 = CFDateCreate(kCFAllocatorDefault, Current);
      CFDateRef v30 = v29;
      if (Mutable && v29)
      {
        CFMutableArrayRef v31 = sub_1000951FC(*(void *)(a3 + 3504), @"BSSID");
        uint64_t v32 = sub_1000951FC(*(void *)(a3 + 3504), @"CHANNEL");
        uint64_t v33 = sub_1000951FC((uint64_t)v6, @"BSSID");
        uint64_t v34 = sub_1000951FC((uint64_t)v6, @"CHANNEL");
        if (v31)
        {
          if (v32)
          {
            if (v33)
            {
              id v35 = v34;
              if (v34)
              {
                CFDictionarySetValue(Mutable, @"RoamOriginBSSID", v31);
                CFDictionarySetValue(Mutable, @"RoamOriginChannel", v32);
                CFDictionarySetValue(Mutable, @"RoamDestBSSID", v33);
                CFDictionarySetValue(Mutable, @"RoamDestChannel", v35);
                CFDictionarySetValue(Mutable, @"RoamTimestamp", v30);
                CFMutableSetRef v36 = *(const __CFArray **)(a3 + 272);
                CFIndex Count = CFArrayGetCount(v36);
                CFArrayInsertValueAtIndex(v36, Count % 100, Mutable);
              }
            }
          }
        }
      }

      else if (!Mutable)
      {
LABEL_26:
        if (v30) {
          CFRelease(v30);
        }
        CFNumberRef v7 = (_WORD *)(a3 + 8558);
        char v38 = v42;
        goto LABEL_29;
      }

      CFRelease(Mutable);
      goto LABEL_26;
    }
  }

  char v38 = 0;
LABEL_29:
  *CFNumberRef v7 = 256;
  if (sub_10009E054((uint64_t)v6))
  {
    *(_BYTE *)CFNumberRef v7 = 1;
    *(_OWORD *)(a3 + 8480) = 0u;
    *(_OWORD *)(a3 + 8496) = 0u;
    *(_OWORD *)(a3 + 8512) = 0u;
    *(CFAbsoluteTime *)(a3 + 852_Block_object_dispose((const void *)(v1 - 136), 8) = CFAbsoluteTimeGetCurrent();
  }

  sub_1000EB060(a3, (uint64_t)a2);
  ++*(_DWORD *)(a3 + 744);
  CFTypeRef v39 = objc_autoreleasePoolPush();
  if (qword_100219F60) {
    objc_msgSend( (id)qword_100219F60,  "WFLog:message:",  3,  "%s: transition attempts# %d",  "__WiFiDeviceManagerUpdateNetworkTransitionStateOnBssidChanged",  *(unsigned int *)(a3 + 3384));
  }
  objc_autoreleasePoolPop(v39);
  *(_DWORD *)(a3 + 3384) = -1;
  if (!*(_BYTE *)(a3 + 6616))
  {
    else {
      sub_1000D66BC(a3, 4);
    }
  }

  sub_1000D3650(a3, v6);
  sub_10001BBC8(*(void *)(a3 + 120), v6, 2LL, v38);
  sub_1000FEE48(a3);
  dispatch_source_t v40 = *(void (**)(uint64_t, const void *, void *, void, void, void))(a3 + 3896);
  if (v40) {
    v40(a3, a2, v6, 0LL, 0LL, *(void *)(a3 + 3904));
  }
  CFTypeRef v41 = *(void (**)(uint64_t, const void *, void, uint64_t, void))(a3 + 4384);
  if (v41) {
    v41(a3, a2, *(void *)(a3 + 4392), 1LL, 0LL);
  }
  if (*(void *)(a3 + 7320))
  {
    v43[0] = _NSConcreteStackBlock;
    v43[1] = 3221225472LL;
    v43[2] = sub_1001001B0;
    v43[3] = &unk_1001E4B88;
    v43[4] = a3;
    sub_1000D8E24(a3, (const __CFDictionary **)v6, (uint64_t)v43);
  }

  if (+[WiFiAIRAgent sharedInstance](&OBJC_CLASS___WiFiAIRAgent, "sharedInstance")) {
    -[WiFiAIRAgent processRoamEvent:]( +[WiFiAIRAgent sharedInstance](&OBJC_CLASS___WiFiAIRAgent, "sharedInstance"),  "processRoamEvent:",  v6);
  }
  CFRelease(v6);
  sub_1000DE0D0(a3, 4u, 0LL);
}

void sub_1000C28B8(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  if (a3)
  {
    id v7 = +[WiFiRoamManager sharedWiFiRoamManager](&OBJC_CLASS___WiFiRoamManager, "sharedWiFiRoamManager");
    if (v7)
    {
      [v7 setRoamStart:a4 forInterface:a2];
      sub_10001DEA0(*(void *)(a3 + 120));
      return;
    }

    CFIndex v8 = objc_autoreleasePoolPush();
    if (qword_100219F60) {
      [qword_100219F60 WFLog:@"__WiFiDeviceManagerRoamScanStartEventCallback, roamManager is NULL"];
    }
  }

  else
  {
    CFIndex v8 = objc_autoreleasePoolPush();
    if (qword_100219F60) {
      [qword_100219F60 WFLog:@"__WiFiDeviceManagerRoamScanStartEventCallback, WiFiDeviceManagerRef is NULL"];
    }
  }

  objc_autoreleasePoolPop(v8);
}

void sub_1000C298C(uint64_t a1, const void *a2, uint64_t a3, const __CFDictionary *a4)
{
  uint64_t v39 = 0LL;
  *(void *)int valuePtr = 0LL;
  uint64_t v38 = 0LL;
  *(void *)&__int128 v4 = 0xAAAAAAAAAAAAAAAALL;
  *((void *)&v4 + 1) = 0xAAAAAAAAAAAAAAAALL;
  __int128 v35 = v4;
  unint64_t v37 = 0xAAAAAAAAAAAAAAAALL;
  __int128 v34 = v4;
  DWORD1(v35) = 0;
  HIDWORD(v35) = 0;
  CFMutableSetRef v36 = @"Unknown";
  if (!a3) {
    return;
  }
  uint64_t v9 = sub_1000DEA34(a3, a2, 1);
  uint64_t v32 = *(void *)(a3 + 3504);
  CFBooleanRef Value = (const __CFNumber *)CFDictionaryGetValue(a4, @"APPLE80211KEY_SUPPLICANTEVENT_TSN_DISABLED_FLAGS");
  if (Value) {
    CFNumberGetValue(Value, kCFNumberSInt32Type, &valuePtr[1]);
  }
  if (v9)
  {
    uint64_t v11 = *(const __CFArray **)(a3 + 3520);
    if (v11)
    {
      v41.length = CFArrayGetCount(*(CFArrayRef *)(a3 + 3520));
      v41.location = 0LL;
      FirstIndexOfCFBooleanRef Value = CFArrayGetFirstIndexOfValue(v11, v41, v9);
      if (FirstIndexOfValue == -1) {
        ValueAtIndex = 0LL;
      }
      else {
        ValueAtIndex = CFArrayGetValueAtIndex(*(CFArrayRef *)(a3 + 3520), FirstIndexOfValue);
      }
LABEL_13:
      double v15 = (const __CFNumber *)sub_100096A74((uint64_t)v9);
      int v16 = sub_1000992D0((uint64_t)v9);
      if (v15)
      {
        __int16 v33 = -21846;
        CFNumberGetValue(v15, kCFNumberSInt16Type, &v33);
        WORD2(v35) = v33;
      }

      if (v16) {
        WORD3(v35) = v16;
      }
      goto LABEL_17;
    }
  }

  uint64_t v14 = objc_autoreleasePoolPush();
  if (qword_100219F60) {
    [qword_100219F60 WFLog:@"%s: Known network hasn't created, update transition disabled flag after assoc finish" message:3];
  }
  objc_autoreleasePoolPop(v14);
  ValueAtIndex = 0LL;
  if (v9) {
    goto LABEL_13;
  }
LABEL_17:
  if (sub_10004D6BC(a1))
  {
    double v17 = (const __CFNumber *)CFDictionaryGetValue(a4, @"APPLE80211KEY_SUPPLICANTEVENT_EAPOL_START_M1_DURATION");
    if (v17) {
      CFNumberGetValue(v17, kCFNumberSInt32Type, valuePtr);
    }
    CLLocationDegrees v18 = (const __CFNumber *)CFDictionaryGetValue(a4, @"APPLE80211KEY_SUPPLICANTEVENT_M1_M2_DURATION");
    if (v18) {
      CFNumberGetValue(v18, kCFNumberSInt32Type, (char *)&v39 + 4);
    }
    double v19 = (const __CFNumber *)CFDictionaryGetValue(a4, @"APPLE80211KEY_SUPPLICANTEVENT_M2_M3_DURATION");
    if (v19) {
      CFNumberGetValue(v19, kCFNumberSInt32Type, &v39);
    }
    CFNumberRef v20 = (const __CFNumber *)CFDictionaryGetValue(a4, @"APPLE80211KEY_SUPPLICANTEVENT_M3_M4_DURATION");
    if (v20) {
      CFNumberGetValue(v20, kCFNumberSInt32Type, (char *)&v38 + 4);
    }
    CFMutableArrayRef v21 = (const __CFNumber *)CFDictionaryGetValue(a4, @"APPLE80211KEY_SUPPLICANTEVENT_TOTAL_4WAY_DURATION");
    if (v21) {
      CFNumberGetValue(v21, kCFNumberSInt32Type, &v38);
    }
    uint64_t v22 = (const __CFBoolean *)CFDictionaryGetValue(a4, @"APPLE80211KEY_SUPPLICANTEVENT_JOINING_NEW_NETWORK");
    int v23 = objc_autoreleasePoolPush();
    if (qword_100219F60) {
      [qword_100219F60 WFLog:@"4WayHSDuration (us): eapol_start_m1_dur: %d m1_m2_dur: %d m2_m3_dur %d m3_m4_dur: %d total_4way_hs_dur: %d Auto- Joining New Network: %d" message:3 valuePtr[0],  HIDWORD(v39),  v39,  HIDWORD(v38),  v38,  CFBooleanGetValue(v22)];
    }
    objc_autoreleasePoolPop(v23);
    *(void *)&__int128 v34 = __PAIR64__(HIDWORD(v39), valuePtr[0]);
    *((void *)&v34 + 1) = __PAIR64__(HIDWORD(v38), v39);
    LODWORD(v35) = v38;
    if (*(_DWORD *)(a3 + 5388) == 102)
    {
      BOOL v24 = (*(_BYTE *)(a3 + 5384) & 2) != 0 || *(_BYTE *)(a3 + 49) != 0;
      BYTE8(v35) = v24;
      if ((*(_BYTE *)(a3 + 5384) & 1) != 0)
      {
        BOOL v25 = 1;
LABEL_38:
        BYTE9(v35) = v25;
        HIDWORD(v35) = *(_DWORD *)(a3 + 6200);
        LOBYTE(v37) = CFBooleanGetValue(v22) != 0;
        unsigned int v26 = sub_1000951FC((uint64_t)v9, @"BSSID");
        if (v26)
        {
          CFNumberRef v27 = (const __CFString *)+[WiFiUsageAccessPointProfile profileForBSSID:]( &OBJC_CLASS___WiFiUsageAccessPointProfile,  "profileForBSSID:",  v26);
          if (v27) {
            CFMutableSetRef v36 = v27;
          }
        }

        sub_100038B38((unsigned int *)&v34);
        goto LABEL_42;
      }
    }

    else
    {
      BYTE8(v35) = *(_BYTE *)(a3 + 49) != 0;
    }

    BOOL v25 = *(_BYTE *)(a3 + 50) != 0;
    goto LABEL_38;
  }

LABEL_42:
  if (v9)
  {
    if (sub_10009E054((uint64_t)v9))
    {
      CFMutableArrayRef v28 = *(void (**)(uint64_t, const void *, void))(a3 + 4352);
      if (v28)
      {
        v28(a3, a2, *(void *)(a3 + 4360));
        CFDateRef v29 = objc_autoreleasePoolPush();
        if (qword_100219F60) {
          [(id)qword_100219F60 WFLog:3 message:"Signal WiFi to incriment 24GHz M1M4 Handshake Count"];
        }
        objc_autoreleasePoolPop(v29);
      }
    }
  }

  CFDateRef v30 = objc_autoreleasePoolPush();
  if (qword_100219F60) {
    [qword_100219F60 WFLog:@"message: Getting transition disabled flags,  %u" message:3];
  }
  objc_autoreleasePoolPop(v30);
  int v31 = valuePtr[1];
  if (valuePtr[1] != 0x80000000)
  {
    *(_DWORD *)(a3 + 3464) = valuePtr[1];
    if (v32 && v31)
    {
      sub_10009582C( v32,  @"TransitionDisabledFlags",  +[NSNumber numberWithUnsignedInt:](&OBJC_CLASS___NSNumber, "numberWithUnsignedInt:"));
      int v31 = valuePtr[1];
    }

    sub_100100228((dispatch_queue_s **)a3, ValueAtIndex, v31, 1);
  }

  if (v9) {
    CFRelease(v9);
  }
}

      __int16 v33 = objc_autoreleasePoolPush();
      if (qword_100219F60) {
        [(id)qword_100219F60 WFLog:3, "%s: mru channels: %@", "__WiFiDeviceManagerTransitionToNetwork", v21 message];
      }
      objc_autoreleasePoolPop(v33);
      if (sub_10009860C((uint64_t)a2))
      {
        __int128 v34 = *(_DWORD *)(a1 + 128);
        __int128 v35 = (const __CFArray *)a2;
        CFMutableSetRef v36 = 0LL;
      }

      else
      {
        unint64_t v37 = sub_100097324(a2);
        __int128 v34 = *(_DWORD *)(a1 + 128);
        if (v37) {
          __int128 v35 = (const __CFArray *)a2;
        }
        else {
          __int128 v35 = 0LL;
        }
        CFMutableSetRef v36 = Mutable;
      }

      uint64_t v38 = sub_1000ED0D0(v35, v36, v34, 0x6Eu, 1);
      int v52 = v21;
      if (v38)
      {
        if (sub_10010F7B4(a1))
        {
          ++*(_DWORD *)(a1 + 6064);
          uint64_t v39 = malloc(0x28uLL);
          if (v39)
          {
            dispatch_source_t v40 = v39;
            *uint64_t v39 = a1;
            v39[1] = 0LL;
            v39[3] = 0LL;
            CFRange v41 = v32;
            if (CFDictionaryContainsKey(v38, @"SSID_STR")) {
              int v42 = 1;
            }
            else {
              int v42 = CFDictionaryContainsKey(v38, @"SCAN_SSID_LIST") != 0;
            }
            v40[32] = v42;
            dispatch_source_t v43 = (const void *)sub_100043E8C(*(void *)(a1 + 64));
            CFRange v44 = sub_1000E0CC4(a1, v43, v38, 0LL, (uint64_t)sub_1001103EC, (uint64_t)v40, 0LL, 15LL);
            if ((_DWORD)v44)
            {
              CFMutableArrayRef v48 = v44;
              id v49 = objc_autoreleasePoolPush();
              if (qword_100219F60) {
                [qword_100219F60 WFLog:@"Error initiating scan request: %d" message:4];
              }
              objc_autoreleasePoolPop(v49);
              free(v40);
            }

            else
            {
              uint64_t v45 = *(const void **)(a1 + 3368);
              if (v45) {
                CFRelease(v45);
              }
              *(void *)(a1 + 336_Block_object_dispose((const void *)(v1 - 136), 8) = a2;
              CFRetain(a2);
            }

            goto LABEL_60;
          }

          CFRange v41 = v32;
          uint64_t v47 = objc_autoreleasePoolPush();
          if (qword_100219F60) {
            [qword_100219F60 WFLog:@"%s: null scanData" message:4];
          }
        }

        else
        {
          CFRange v41 = v32;
          uint64_t v47 = objc_autoreleasePoolPush();
          if (qword_100219F60) {
            [qword_100219F60 WFLog:@"__WiFiDeviceManagerTransitionToNetwork: not now..."];
          }
        }

        objc_autoreleasePoolPop(v47);
LABEL_60:
        CFRelease(v38);
LABEL_61:
        if (v52) {
          CFRelease(v52);
        }
        if ((v41 & 1) == 0) {
          CFRelease(Mutable);
        }
        if (v14) {
          CFRelease(v14);
        }
        goto LABEL_67;
      }

      CFRange v41 = v32;
      unsigned int v46 = objc_autoreleasePoolPush();
      if (qword_100219F60) {
        [qword_100219F60 WFLog:@"%s: failed to create scan request" message:3];
      }
LABEL_81:
      objc_autoreleasePoolPop(v46);
      goto LABEL_61;
    }
  }

  else
  {
    id v12 = objc_autoreleasePoolPush();
    if (qword_100219F60) {
      [qword_100219F60 WFLog:@"__WiFiDeviceManagerTransitionToNetwork: invalid input"];
    }
    objc_autoreleasePoolPop(v12);
  }

                  self = v33;
                  if (objc_msgSend(objc_msgSend(v14, "network"), "type") == (id)1
                    || objc_msgSend(objc_msgSend(v14, "network"), "type") == (id)2
                    || objc_msgSend(objc_msgSend(v14, "network"), "type") == (id)3)
                  {
                    BOOL v25 = objc_autoreleasePoolPush();
                    if (qword_100219F60) {
                      [(id)qword_100219F60 WFLog:3, "%s: %@ contains a network type (%lu) that is not recommendable", "-[WiFiScanResultsPreparer _prepareScanResults:]", -[WiFiScanObserverNetwork SSID](v36, "SSID"), objc_msgSend(objc_msgSend(v14, "network"), "type") message];
                    }
                    objc_autoreleasePoolPop(v25);
                    sub_10009582C((uint64_t)v11, @"WiFiNetworkAttributeIsNotRecommendable", kCFBooleanTrue);
                  }

                  unsigned int v26 = objc_msgSend(objc_msgSend(v14, "network"), "popularityScore");
                  if (v26)
                  {
                    CFNumberRef v27 = v26;
                    sub_1000970C0( (uint64_t)v11,  @"WiFiNetworkAttributePopularityScore",  (uint64_t)[v26 score]);
                    else {
                      CFMutableArrayRef v28 = @"WiFiNetworkAttributeHighPopularity";
                    }
                    sub_10009582C((uint64_t)v11, v28, kCFBooleanTrue);
                  }

                  sub_1000970C0( (uint64_t)v11,  @"WiFiNetworkAttributeSource",  (uint64_t)objc_msgSend(objc_msgSend(v14, "network"), "source"));
                  uint64_t v9 = v31;
                  id v7 = v32;
LABEL_54:
                  if (-[WiFiScanResultsPreparer disableProminentFiltering](self, "disableProminentFiltering")
                    || +[WiFiScanResultsPreparer wifiNetworkShouldBeProminentlyDisplayed:]( &OBJC_CLASS___WiFiScanResultsPreparer,  "wifiNetworkShouldBeProminentlyDisplayed:",  v11))
                  {
                    sub_10009582C((uint64_t)v11, @"WiFiNetworkAttributeProminentDisplay", kCFBooleanTrue);
                    -[WiFiScanResultsPreparer setProminentScanResultsCount:]( self,  "setProminentScanResultsCount:",  (char *)-[WiFiScanResultsPreparer prominentScanResultsCount](self, "prominentScanResultsCount")
                    + 1);
                  }
                }

                else if (!sub_1000971F8(v11))
                {
                  goto LABEL_54;
                }
              }
            }
          }

          uint64_t v10 = v35 + 1;
        }

        while ((id)(v35 + 1) != v34);
        __int128 v34 = [v7 countByEnumeratingWithState:&v42 objects:v47 count:16];
      }

      while (v34);
    }

    -[WiFiScanResultsPreparer setPreparedScanResults:](self, "setPreparedScanResults:", v7);
    CFIndex v6 = v29;
    unsigned int v5 = v30;
  }

  else
  {
    id v7 = 0LL;
  }

  if (v6) {
  objc_autoreleasePoolPop(v5);
  }
}

  unsigned int v26 = (void *)v58[3];
  if (v26) {
    xpc_release(v26);
  }
  CFNumberRef v27 = *((unsigned __int8 *)v62 + 24);
  _Block_object_dispose(&v57, 8);
  _Block_object_dispose(&v61, 8);
  return v27;
}

void sub_1000C2E08(uint64_t a1, const void *a2, uint64_t a3, void *a4)
{
  if (!a3)
  {
    int v16 = objc_autoreleasePoolPush();
    if (qword_100219F60) {
      [qword_100219F60 WFLog:@"__WiFiDeviceManagerRoamScanEndEventCallback, WiFiDeviceManagerRef is NULL"];
    }
    goto LABEL_15;
  }

  id v7 = +[WiFiRoamManager sharedWiFiRoamManager](&OBJC_CLASS___WiFiRoamManager, "sharedWiFiRoamManager");
  if (!v7)
  {
    int v16 = objc_autoreleasePoolPush();
    if (qword_100219F60) {
      [qword_100219F60 WFLog:@"__WiFiDeviceManagerRoamScanEndEventCallback, roamManager is NULL"];
    }
LABEL_15:
    objc_autoreleasePoolPop(v16);
    return;
  }

  CFIndex v8 = v7;
  uint64_t v9 = sub_1000DEA34(a3, a2, 1);
  if (v9)
  {
    uint64_t v10 = v9;
    [v8 setRoamEndState:a4 forInterface:a2];
    if ([v8 canSubmitMetrics])
    {
      id v11 = [v8 copyRoamStatus];
      if (v11)
      {
        id v12 = v11;
        int v13 = objc_autoreleasePoolPush();
        uint64_t v14 = +[NSMutableDictionary dictionaryWithDictionary:]( &OBJC_CLASS___NSMutableDictionary,  "dictionaryWithDictionary:",  v12);
        id v15 = [a4 objectForKey:@"ROAM_CACHE"];
        if (v15) {
          -[NSMutableDictionary setObject:forKey:](v14, "setObject:forKey:", v15, @"ROAM_CACHE");
        }
        sub_1001002A4(a3, v10, (const __CFDictionary *)v14);
        objc_autoreleasePoolPop(v13);
        CFRelease(v12);
      }
    }

    CFRelease(v10);
  }

void sub_1000C2FA0(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  id v6 = +[WiFiRoamManager sharedWiFiRoamManager](&OBJC_CLASS___WiFiRoamManager, "sharedWiFiRoamManager");
  if (v6)
  {
    [v6 setRoamPrep:a4 forInterface:a2];
  }

  else
  {
    id v7 = objc_autoreleasePoolPush();
    if (qword_100219F60) {
      [qword_100219F60 WFLog:@"%s, roamManager is NULL" message:4];
    }
    objc_autoreleasePoolPop(v7);
  }

void sub_1000C3028(uint64_t a1, const void *a2, uint64_t a3)
{
  unsigned int v5 = objc_autoreleasePoolPush();
  if (a3)
  {
    id v6 = (const __CFDictionary *)sub_1000DEA34(a3, a2, 1);
    if (v6)
    {
      id v7 = v6;
      CFIndex v8 = *(const void **)(a3 + 3504);
      if (!v8
        || !CFEqual(v6, v8)
        || sub_100096E90((uint64_t)v7)
        || sub_100095B4C((uint64_t)v7)
        || sub_100096D08(v7))
      {
        uint64_t v9 = objc_autoreleasePoolPush();
        if (qword_100219F60) {
          [(id)qword_100219F60 WFLog:2 message:"APPLE80211_M_DECRYPTION_FAILURE! omitting disassociate because this is a WPA network"];
        }
        objc_autoreleasePoolPop(v9);
      }

      else
      {
        uint64_t v10 = sub_1000951FC(*(void *)(a3 + 3504), @"BSSID");
        id v11 = objc_autoreleasePoolPush();
        if (qword_100219F60) {
          [(id)qword_100219F60 WFLog:3 message:"Received a decryption failure from the device.  Disassociating. "];
        }
        objc_autoreleasePoolPop(v11);
        sub_1000CE074(a3, a2, 1004LL, "__WiFiDeviceManagerDecryptionEventCallback", 7711LL);
        id v12 = sub_1000A335C(*(void *)(a3 + 3504));
        [*(id *)(a3 + 6632) isNetworkInDenyListedState:1 scanResult:v12];
        id v13 = sub_1000D1BDC(a3, 3LL, 0LL, (uint64_t)v10, 5LL);
        [*(id *)(a3 + 6632) setNetworkDenyListInfo:v13 forScanResult:v12];
      }

      CFRelease(v7);
    }
  }

  objc_autoreleasePoolPop(v5);
}

void sub_1000C31A4(uint64_t a1, const void *a2, const __CFArray *a3, uint64_t a4)
{
  if (!a4) {
    return;
  }
  *(_BYTE *)(a4 + 3296) = 1;
  if (!sub_1000DD47C(a4))
  {
    uint64_t v9 = 0LL;
LABEL_6:
    CFIndex Count = 0LL;
    goto LABEL_7;
  }

  id v7 = sub_100040538(*(void *)(a4 + 64), a2);
  if (v7)
  {
    CFIndex Count = (CFIndex)v7;
    uint64_t v9 = 0LL;
    goto LABEL_7;
  }

  int v16 = sub_10003A530(a3);
  uint64_t v9 = v16;
  if (!v16) {
    goto LABEL_6;
  }
  CFIndex Count = CFArrayGetCount(v16);
  if (Count)
  {
    CFIndex v17 = CFArrayGetCount(*(CFArrayRef *)(a4 + 3576));
    if (v17)
    {
      if (Count < 1) {
        goto LABEL_46;
      }
      uint64_t v18 = v17;
      CFIndex v19 = 0LL;
      CFIndex v20 = -1LL;
      do
      {
        ValueAtIndex = CFArrayGetValueAtIndex(v9, v19);
        if (ValueAtIndex)
        {
          uint64_t v22 = sub_100095BC8(ValueAtIndex);
          if (v18 >= 1)
          {
            int v23 = v22;
            if (v22)
            {
              CFIndex v24 = 0LL;
              while (1)
              {
                BOOL v25 = CFArrayGetValueAtIndex(*(CFArrayRef *)(a4 + 3576), v24);
                if (v25)
                {
                  unsigned int v26 = sub_100095BC8(v25);
                  if (v26)
                  {
                    if (CFEqual(v23, v26)) {
                      break;
                    }
                  }
                }

                if (v18 == ++v24) {
                  goto LABEL_39;
                }
              }

              if (v24 < v20 || v20 == -1) {
                CFIndex v20 = v24;
              }
            }
          }
        }

void sub_1000C34F0(uint64_t a1, const void *a2, uint64_t a3)
{
  unsigned int v5 = objc_autoreleasePoolPush();
  id v6 = objc_autoreleasePoolPush();
  if (qword_100219F60) {
    [qword_100219F60 WFLog:@"Processing BlackList Network Event"];
  }
  objc_autoreleasePoolPop(v6);
  if (a3)
  {
    id v7 = sub_1000DEA34(a3, a2, 1);
    CFIndex v8 = objc_autoreleasePoolPush();
    if (v7)
    {
      if (qword_100219F60) {
        [(id)qword_100219F60 WFLog:3, "%s: Blacklisting %@ for Background Scan", "__WiFiDeviceManagerBlackListNetworkCallback", sub_100095BC8(v7) message];
      }
      objc_autoreleasePoolPop(v8);
      id v9 = sub_1000A335C((uint64_t)v7);
      CFIndex v10 = sub_1000951FC((uint64_t)v7, @"BSSID");
      id v11 = sub_1000D1BDC(a3, 2LL, 0LL, (uint64_t)v10, 3LL);
      [*(id *)(a3 + 6632) setNetworkDenyListInfo:v11 forScanResult:v9];
      [*(id *)(a3 + 7320) addFaultEvent:22 forInterface:a2];

      CFRelease(v7);
    }

    else
    {
      if (qword_100219F60) {
        [qword_100219F60 WFLog:@"%s: Received blackList event, but we are not associated" message:4];
      }
      objc_autoreleasePoolPop(v8);
    }
  }

  objc_autoreleasePoolPop(v5);
}

void sub_1000C3664( uint64_t a1, uint64_t a2, uint64_t a3, unsigned int a4, unsigned __int8 *a5, unsigned __int16 *a6, uint64_t a7)
{
  id v7 = (unsigned __int8 *)(a7 + 5209);
  if (*(_BYTE *)(a7 + 5211))
  {
    *id v7 = a3;
    *(_BYTE *)(a7 + 5352) = a3;
    id v13 = objc_autoreleasePoolPush();
    if (qword_100219F60) {
      objc_msgSend((id)qword_100219F60, "WFLog:message:", 3, "MIS STA Associated: %d associated clients", *v7);
    }
    objc_autoreleasePoolPop(v13);
    if (a5)
    {
      CFDataRef v19 = CFDataCreate(kCFAllocatorDefault, a5, 6LL);
      CFIndex v20 = objc_autoreleasePoolPush();
      if (qword_100219F60)
      {
        if (v7[43]) {
          CFMutableArrayRef v21 = " Hidden ";
        }
        else {
          CFMutableArrayRef v21 = "Broadcast";
        }
        if ((a4 & 1) != 0)
        {
          uint64_t v22 = " Auto Hotspot Client ";
        }

        else if ((a4 & 2) != 0)
        {
          uint64_t v22 = "Instant Hotspot Client ";
        }

        else
        {
          uint64_t v22 = "Broadcast iOS Client";
          if ((a4 & 4) == 0) {
            uint64_t v22 = " Others ";
          }
        }

        [(id)qword_100219F60 WFLog:3, "%s: MIS Mode: %s, Client Type: %s client macAddr: %@", "__WiFiDeviceManagerSTAArriveCallback", v21, v22, v19 message];
      }

      objc_autoreleasePoolPop(v20);
      if ((a4 & 3) != 0)
      {
        CFIndex v24 = (CFMutableSetRef *)(a7 + 5288);
      }

      else
      {
        CFIndex Count = CFSetGetCount(*(CFSetRef *)(a7 + 5264));
        CFIndex v24 = (CFMutableSetRef *)(a7 + 5280);
        if (!Count) {
          CFIndex v24 = (CFMutableSetRef *)(a7 + 5296);
        }
      }

      CFSetAddValue(*v24, v19);
      if (v19) {
        CFRelease(v19);
      }
      sub_1000DCD9C(a7, 0);
    }

    if (!_MISSetHostCount || _MISSetHostCount(*(void *)(a7 + 4936), 2, a3, v14, v15, v16, v17, v18))
    {
      unsigned int v26 = objc_autoreleasePoolPush();
      if (qword_100219F60) {
        [qword_100219F60 WFLog:@"%s: Error updating host count at MIS Service" message:4];
      }
      objc_autoreleasePoolPop(v26);
    }

    if (*v7 == 5) {
      sub_100100900(a7, 1);
    }
    sub_1000DC9F0(a7, 0LL);
    *(CFAbsoluteTime *)(a7 + 532_Block_object_dispose((const void *)(v1 - 136), 8) = CFAbsoluteTimeGetCurrent() + 3.0;
    v7[111] = 1;
    sub_1000EF100(a7, 1, a6, a4, 0);
    int v23 = objc_autoreleasePoolPush();
    CFNumberRef v27 = *(void **)(a7 + 7320);
    if (v27)
    {
      if (a5)
      {
        a5 = +[NSString stringWithFormat:]( &OBJC_CLASS___NSString,  "stringWithFormat:",  @"%.2X:%.2X:%.2X:%.2X:%.2X:%.2X",  *a5,  a5[1],  a5[2],  a5[3],  a5[4],  a5[5]);
        CFNumberRef v27 = *(void **)(a7 + 7320);
      }

      [v27 addSoftApClientEvent:1 identifier:a5 isAppleClient:(a4 | sub_10003AEB0(a6)) != 0 isInstantHotspot:(a4 >> 1) & 1 isAutoHotspot:a4 & 1 isHidden:v7[43] != 0];
    }
  }

  else
  {
    int v23 = objc_autoreleasePoolPush();
    if (qword_100219F60) {
      [qword_100219F60 WFLog:@"%s: called while MIS is disabled" message:4];
    }
  }

  objc_autoreleasePoolPop(v23);
}

void sub_1000C397C( uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, unsigned __int8 *a5, unsigned __int16 *a6, uint64_t a7)
{
  id v9 = a5;
  id v13 = (unsigned __int8 *)(a7 + 5209);
  if (a5) {
    uint64_t v14 = +[NSString stringWithFormat:]( &OBJC_CLASS___NSString,  "stringWithFormat:",  @"%.2X:%.2X:%.2X:%.2X:%.2X:%.2X",  *a5,  a5[1],  a5[2],  a5[3],  a5[4],  a5[5]);
  }
  else {
    uint64_t v14 = 0LL;
  }
  uint64_t v15 = objc_autoreleasePoolPush();
  if (qword_100219F60) {
    [(id)qword_100219F60 WFLog:4, "%s ifname %@ staNum %d sta_capabilities %d macString %@ \n", "__WiFiDeviceManagerSTALeaveCallback", a2, a3, a4, v14 message];
  }
  objc_autoreleasePoolPop(v15);
  if (v13[2])
  {
    unsigned int v21 = *v13;
    if ((_DWORD)a3 == 255)
    {
      uint64_t v22 = objc_autoreleasePoolPush();
      if (qword_100219F60) {
        [(id)qword_100219F60 WFLog:3 message:"MIS no traffic for long time. Tear down MIS"];
      }
      objc_autoreleasePoolPop(v22);
      int v28 = v13[4];
      if (!_MISSetHostCount || _MISSetHostCount(*(void *)(a7 + 4936), 2, 0LL, v23, v24, v25, v26, v27))
      {
        CFDateRef v29 = objc_autoreleasePoolPush();
        if (qword_100219F60) {
          [qword_100219F60 WFLog:@"__WiFiDeviceManagerSTALeaveCallback: Error updating host count at MIS Service"];
        }
        objc_autoreleasePoolPop(v29);
      }

      unsigned __int8 *v13 = 0;
      if (v13[2] && !v28)
      {
        CFDateRef v30 = objc_autoreleasePoolPush();
        if (qword_100219F60) {
          [qword_100219F60 WFLog:@"MIS idle timer expired, disabling tethering"];
        }
        objc_autoreleasePoolPop(v30);
        sub_1000DC604(a7);
        uint64_t v39 = 0LL;
        memset(v38, 0, sizeof(v38));
        DWORD2(v38[0]) = 7;
        sub_1000DC1AC(a7, (uint64_t)v38);
      }
    }

    else
    {
      if (v21 >= a3)
      {
        unsigned __int8 *v13 = a3;
        if (_MISSetHostCount)
        {
          if (_MISSetHostCount(*(void *)(a7 + 4936), 2, a3, v16, v17, v18, v19, v20))
          {
            uint64_t v32 = objc_autoreleasePoolPush();
            if (qword_100219F60) {
              [qword_100219F60 WFLog:@"__WiFiDeviceManagerSTALeaveCallback: Error updating host count at MIS Service"];
            }
            objc_autoreleasePoolPop(v32);
          }
        }
      }

      __int16 v33 = objc_autoreleasePoolPush();
      if (qword_100219F60) {
        [qword_100219F60 WFLog:@"MIS STA Disassociated: %d associated clients" message:3 *v13];
      }
      objc_autoreleasePoolPop(v33);
    }

    v13[143] = *v13;
    if (v9)
    {
      CFDataRef v34 = CFDataCreate(kCFAllocatorDefault, v9, 6LL);
      __int128 v35 = objc_autoreleasePoolPush();
      if (qword_100219F60) {
        [(id)qword_100219F60 WFLog:3, "%s: misIsHidden: %d, client macAddr: %@", "__WiFiDeviceManagerSTALeaveCallback", v13[43], v34 message];
      }
      objc_autoreleasePoolPop(v35);
      CFSetRemoveValue(*(CFMutableSetRef *)(a7 + 5280), v34);
      CFSetRemoveValue(*(CFMutableSetRef *)(a7 + 5288), v34);
      CFSetRemoveValue(*(CFMutableSetRef *)(a7 + 5296), v34);
      if (v34) {
        CFRelease(v34);
      }
      sub_1000DCD9C(a7, 0);
    }

    if ((_DWORD)a3 != 255 && v13[1] == -*v13 && !v13[4])
    {
      CFMutableSetRef v36 = objc_autoreleasePoolPush();
      if (qword_100219F60) {
        [qword_100219F60 WFLog:@"%s: Starting MIS idle timer" message:3];
      }
      objc_autoreleasePoolPop(v36);
      sub_1000DC9F0(a7, 3LL);
    }

    sub_1000EF100(a7, 0, a6, 0, 0);
    if (v21 >= 5 && *v13 <= 4u) {
      sub_100100900(a7, 0);
    }
    int v31 = objc_autoreleasePoolPush();
    unint64_t v37 = *(void **)(a7 + 7320);
    if (v37)
    {
      if (v9)
      {
        id v9 = +[NSString stringWithFormat:]( &OBJC_CLASS___NSString,  "stringWithFormat:",  @"%.2X:%.2X:%.2X:%.2X:%.2X:%.2X",  *v9,  v9[1],  v9[2],  v9[3],  v9[4],  v9[5]);
        unint64_t v37 = *(void **)(a7 + 7320);
      }

      [v37 addSoftApClientEvent:0 identifier:v9 isAppleClient:sub_10003AEB0(a6) != 0 isInstantHotspot:(a4 >> 1) & 1 isAutoHotspot:a4 & 1 isHidden:v13[43] != 0];
    }
  }

  else
  {
    int v31 = objc_autoreleasePoolPush();
    if (qword_100219F60) {
      [qword_100219F60 WFLog:@"%s: called while MIS is disabled" message:@"__WiFiDeviceManagerSTALeaveCallback"];
    }
  }

  objc_autoreleasePoolPop(v31);
}

void sub_1000C3DFC(uint64_t a1, const void *a2, void *a3, uint64_t a4, uint64_t a5, void *a6)
{
  if (a6)
  {
    CFIndex v10 = (void (*)(void *, const void *, void *, uint64_t, uint64_t, void))a6[518];
    if (v10) {
      v10(a6, a2, a3, a4, a5, a6[519]);
    }
    id v11 = objc_autoreleasePoolPush();
    if (a6[915])
    {
      if (a3) {
        obCFIndex j = [a3 objectForKey:@"scanResults"];
      }
      else {
        obCFIndex j = 0LL;
      }
      id v34 = +[NSMutableSet set](&OBJC_CLASS___NSMutableSet, "set");
      id v35 = +[NSMutableSet set](&OBJC_CLASS___NSMutableSet, "set");
      id v12 = sub_1000DEA34((uint64_t)a6, a2, 1);
      uint64_t v32 = a6;
      __int16 v33 = v11;
      uint64_t v30 = a1;
      int v31 = a2;
      CFTypeRef cf = v12;
      if (v12)
      {
        id v13 = (const __CFArray *)v12;
        unint64_t v37 = sub_100095BC8(v12);
        CFMutableSetRef v36 = sub_100096968(v13);
      }

      else
      {
        CFMutableSetRef v36 = 0LL;
        unint64_t v37 = 0LL;
      }

      __int128 v43 = 0u;
      __int128 v44 = 0u;
      __int128 v41 = 0u;
      __int128 v42 = 0u;
      id v40 = [obj countByEnumeratingWithState:&v41 objects:v45 count:16];
      if (v40)
      {
        uint64_t v39 = *(void *)v42;
        do
        {
          for (CFIndex i = 0LL; i != v40; CFIndex i = (char *)i + 1)
          {
            if (*(void *)v42 != v39) {
              objc_enumerationMutation(obj);
            }
            uint64_t v15 = *(void **)(*((void *)&v41 + 1) + 8LL * (void)i);
            uint64_t v16 = objc_autoreleasePoolPush();
            id v17 = [v15 objectForKey:@"SSID_STR"];
            id v18 = [v15 objectForKey:@"BSSID"];
            id v19 = [v15 objectForKey:@"CHANNEL_FLAGS"];
            id v20 = [v15 objectForKey:@"CHANNEL"];
            id v21 = [v15 objectForKey:@"RSSI"];
            id v22 = [v15 objectForKey:@"WPS_PROB_RESP_IE"];
            if (v18)
            {
              id v23 = v22;
              id v24 = [WiFiUsageBssDetails bssWithIdentifier:v18 channel:[v20 integerValue] channelFlags:[v19 integerValue] rssi:[v21 integerValue]];
              if (v24)
              {
                id v25 = v24;
                if (!v17
                  || !v37
                  || (unsigned __int8 v26 = [v17 isEqualToString:v37], v27 = v34, (v26 & 1) == 0))
                {
                  uint64_t v27 = v35;
                }

                [v27 addObject:v25];
                if (v23 && v36 && [v18 isEqual:v36]) {
                  -[WiFiUsageMonitor updateWPSInfo:]( +[WiFiUsageMonitor sharedInstance](&OBJC_CLASS___WiFiUsageMonitor, "sharedInstance"),  "updateWPSInfo:",  v15);
                }
              }
            }

            objc_autoreleasePoolPop(v16);
          }

          id v40 = [obj countByEnumeratingWithState:&v41 objects:v45 count:16];
        }

        while (v40);
      }

      CFMutableArrayRef Mutable = CFArrayCreateMutable(kCFAllocatorDefault, 0LL, &kCFTypeArrayCallBacks);
      sub_100044CD4(v30, Mutable);
      [(id)v32[915] setScanningState:0 client:0 neighborBSS:v34 otherBSS:v35 withChannelInfoList:Mutable withRequest:0 forInterface:v31];
      if (cf) {
        CFRelease(cf);
      }
      id v11 = v33;
      if (Mutable) {
        CFRelease(Mutable);
      }
    }

    objc_autoreleasePoolPop(v11);
  }

uint64_t sub_1000C415C(uint64_t a1, uint64_t a2, uint64_t a3)
{
  if (a3)
  {
    unsigned int v3 = *(uint64_t (**)(uint64_t, uint64_t, void))(a3 + 4000);
    if (v3) {
      return v3(a3, a2, *(void *)(a3 + 4008));
    }
  }

  return result;
}

uint64_t sub_1000C417C(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  if (a4)
  {
    __int128 v4 = *(uint64_t (**)(uint64_t, uint64_t, uint64_t, void))(a4 + 4208);
    if (v4) {
      return v4(a4, a2, a3, *(void *)(a4 + 4216));
    }
  }

  return result;
}

void sub_1000C419C(int a1, const void *a2, uint64_t a3, CFDictionaryRef theDict)
{
  float v69 = 0.0;
  if (!a3) {
    return;
  }
  id v7 = (_BYTE *)(a3 + 6994);
  if (theDict)
  {
    if (!*(_BYTE *)(a3 + 7352) || !*(_BYTE *)(a3 + 8558) || *(_BYTE *)(a3 + 8560))
    {
LABEL_67:
      value = 0LL;
      v80[0] = 0LL;
      int v77 = 0LL;
      int v78 = 0LL;
      uint64_t v74 = 0LL;
      dispatch_source_t v75 = 0LL;
      uint64_t v72 = 0LL;
      uint64_t valuePtr = 0LL;
      uint64_t v71 = 0LL;
      int v70 = 0;
      uint64_t v35 = *(void *)(a3 + 3504);
      if (v35)
      {
        if (sub_10009DF44(v35))
        {
          dispatch_source_t v76 = (void *)CFDictionaryGetValue(theDict, @"RSSI");
          if (v76)
          {
            if (CFAbsoluteTimeGetCurrent() - *(double *)(a3 + 736) >= 5.0 && *(_BYTE *)(a3 + 940))
            {
              ++*(_DWORD *)(a3 + 880);
              int v36 = HIDWORD(v72);
              unsigned int v37 = *(_DWORD *)(a3 + 880);
              if (SHIDWORD(v72) >= 1)
              {
                int v38 = *(_DWORD *)(a3 + 748);
                if (v38 >= SHIDWORD(v72)) {
                  int v38 = HIDWORD(v72);
                }
                *(_DWORD *)(a3 + 74_Block_object_dispose((const void *)(v1 - 136), 8) = v38;
                int v39 = *(_DWORD *)(a3 + 752);
                if (v39 <= v36) {
                  int v39 = v36;
                }
                *(_DWORD *)(a3 + 752) = v39;
                *(double *)(a3 + 760) = *(double *)(a3 + 760) + ((double)v36 - *(double *)(a3 + 760)) / (double)v37;
                *(_DWORD *)(a3 + 756) = v36;
              }

              int v40 = v72;
              if ((int)v72 >= 1)
              {
                int v41 = *(_DWORD *)(a3 + 768);
                *(_DWORD *)(a3 + 76_Block_object_dispose((const void *)(v1 - 136), 8) = v41;
                int v42 = *(_DWORD *)(a3 + 772);
                if (v42 <= v40) {
                  int v42 = v40;
                }
                *(_DWORD *)(a3 + 772) = v42;
                *(double *)(a3 + 784) = *(double *)(a3 + 784) + ((double)v40 - *(double *)(a3 + 784)) / (double)v37;
                *(_DWORD *)(a3 + 776) = v40;
              }

              int v43 = valuePtr;
              if ((int)valuePtr >= 1)
              {
                int v44 = *(_DWORD *)(a3 + 840);
                *(_DWORD *)(a3 + 840) = v44;
                int v45 = *(_DWORD *)(a3 + 844);
                if (v45 <= v43) {
                  int v45 = v43;
                }
                *(_DWORD *)(a3 + 844) = v45;
                *(double *)(a3 + 856) = *(double *)(a3 + 856) + ((double)v43 - *(double *)(a3 + 856)) / (double)v37;
                *(_DWORD *)(a3 + 84_Block_object_dispose((const void *)(v1 - 136), 8) = v43;
              }

              int v46 = HIDWORD(valuePtr);
              if (SHIDWORD(valuePtr) >= 1)
              {
                int v47 = *(_DWORD *)(a3 + 792);
                if (v47 >= SHIDWORD(valuePtr)) {
                  int v47 = HIDWORD(valuePtr);
                }
                *(_DWORD *)(a3 + 792) = v47;
                int v48 = *(_DWORD *)(a3 + 796);
                if (v48 <= v46) {
                  int v48 = v46;
                }
                *(_DWORD *)(a3 + 796) = v48;
                *(double *)(a3 + 80_Block_object_dispose((const void *)(v1 - 136), 8) = *(double *)(a3 + 808) + ((double)v46 - *(double *)(a3 + 808)) / (double)v37;
                *(_DWORD *)(a3 + 800) = v46;
              }

              int v49 = HIDWORD(v71);
              if (v71 < 0)
              {
                int v50 = *(_DWORD *)(a3 + 816);
                if (v50 >= SHIDWORD(v71)) {
                  int v50 = HIDWORD(v71);
                }
                *(_DWORD *)(a3 + 816) = v50;
                int v51 = *(_DWORD *)(a3 + 820);
                if (v51 <= v49) {
                  int v51 = v49;
                }
                *(_DWORD *)(a3 + 820) = v51;
                *(double *)(a3 + 832) = *(double *)(a3 + 832) + ((double)v49 - *(double *)(a3 + 832)) / (double)v37;
                *(_DWORD *)(a3 + 824) = v49;
              }

              int v52 = v71;
              *(_DWORD *)(a3 + 4LL * ((v37 - 1) % 0xC) + 88_Block_object_dispose((const void *)(v1 - 136), 8) = v71;
              if (v52)
              {
                unsigned int v53 = *(_DWORD *)(a3 + 936) + 1;
                *(_DWORD *)(a3 + 936) = v53;
                if (v53 >= 3
                  && (*(double *)(a3 + 872) == 0.0 || CFAbsoluteTimeGetCurrent() - *(double *)(a3 + 872) >= 60.0))
                {
                  ++*(_DWORD *)(a3 + 864);
                  CFMutableSetRef v54 = objc_autoreleasePoolPush();
                  if (qword_100219F60) {
                    [qword_100219F60 WFLog:@"%s: numberOfTxErrorEvents increased to %d" message:3, "%s: numberOfTxErrorEvents increased to %d",  "__WiFiDeviceManagerTrackCarPlayLinkQuality",  *(unsigned int *)(a3 + 864)];
                  }
                  objc_autoreleasePoolPop(v54);
                  *(CFAbsoluteTime *)(a3 + 872) = CFAbsoluteTimeGetCurrent();
                }
              }

              if (*(_DWORD *)(a3 + 4LL * (*(_DWORD *)(a3 + 880) % 0xCu) + 888)) {
                --*(_DWORD *)(a3 + 936);
              }
              *(void *)(a3 + 944) += v70;
              CFMutableSetRef v55 = objc_autoreleasePoolPush();
              if (qword_100219F60) {
                objc_msgSend( (id)qword_100219F60,  "WFLog:message:",  3,  "%s: rssi(max:min:avg:last) %d:%d:%d:%d, snr %d:%d:%d:%d, cca %d:%d:%d:%d, txRate %d:%d:%d:%d, rxRate % d:%d:%d:%d, numberOfTxErrorEvents %u, numberOfNoneZeroPer %u, roamedCount %u, totalTxFrames %llu",  "__WiFiDeviceManagerTrackCarPlayLinkQuality",  *(unsigned int *)(a3 + 820),  *(unsigned int *)(a3 + 816),  (int)*(double *)(a3 + 832),  *(unsigned int *)(a3 + 824),  *(unsigned int *)(a3 + 796),  *(unsigned int *)(a3 + 792),  (int)*(double *)(a3 + 808),  *(unsigned int *)(a3 + 800),  *(unsigned int *)(a3 + 844),  *(unsigned int *)(a3 + 840),  (int)*(double *)(a3 + 856),  *(unsigned int *)(a3 + 848),  *(unsigned int *)(a3 + 752),  *(unsigned int *)(a3 + 748),  (int)*(double *)(a3 + 760),  *(unsigned int *)(a3 + 756),  *(unsigned int *)(a3 + 772),  *(unsigned int *)(a3 + 768),  (int)*(double *)(a3 + 784),  *(unsigned int *)(a3 + 776),  *(unsigned int *)(a3 + 864),  *(unsigned int *)(a3 + 936),  *(unsigned int *)(a3 + 744),  *(void *)(a3 + 944));
              }
              objc_autoreleasePoolPop(v55);
            }
          }
        }
      }

      goto LABEL_135;
    }

    value = 0LL;
    v80[0] = 0LL;
    int v77 = 0LL;
    int v78 = 0LL;
    dispatch_source_t v75 = 0LL;
    dispatch_source_t v76 = 0LL;
    uint64_t valuePtr = 0LL;
    uint64_t v74 = 0LL;
    uint64_t v71 = 0LL;
    uint64_t v72 = 0LL;
    int v70 = 0;
    double v8 = *(double *)(a3 + 8496);
    if (v8 == 0.0) {
      double v9 = (double)SHIDWORD(valuePtr);
    }
    else {
      double v9 = v8 * 0.6 + (double)SHIDWORD(valuePtr) * 0.4;
    }
    *(double *)(a3 + 8496) = v9;
    int v10 = (int)v9;
    double v11 = 1.0;
    if (v10 <= 39) {
      double v11 = *(double *)(a3 + 8LL * (v10 & ~(v10 >> 31)) + 7360);
    }
    double v12 = *(double *)(a3 + 8504);
    if (v12 == 0.0) {
      double v13 = (double)(int)valuePtr;
    }
    else {
      double v13 = v12 * 0.6 + (double)(int)valuePtr * 0.4;
    }
    *(double *)(a3 + 8504) = v13;
    unsigned int v14 = (int)v13 & ~((int)v13 >> 31);
    if (v14 >= 0x63) {
      unsigned int v14 = 99;
    }
    double v15 = *(double *)(a3 + 8LL * v14 + 7680);
    double v16 = *(double *)(a3 + 8512);
    *(double *)(a3 + 8512) = v16;
    double v17 = *(double *)(a3 + 8520);
    *(double *)(a3 + 8520) = v17;
    double v18 = v11 * v16;
    double v19 = v11 * v17;
    double v20 = *(double *)(a3 + 8480);
    if (v20 == 0.0) {
      double v21 = (double)(v70 + HIDWORD(v72));
    }
    else {
      double v21 = v20 * 0.6 + (double)(v70 + HIDWORD(v72)) * 0.4;
    }
    double v22 = v15 * v18;
    double v23 = v15 * v19;
    *(double *)(a3 + 8480) = v21;
    double v24 = *(double *)(a3 + 8488);
    if (v24 == 0.0) {
      double v25 = (double)(int)v72;
    }
    else {
      double v25 = v24 * 0.6 + (double)(int)v72 * 0.4;
    }
    *(double *)(a3 + 848_Block_object_dispose((const void *)(v1 - 136), 8) = v25;
    double Current = CFAbsoluteTimeGetCurrent();
    double v27 = Current - *(double *)(a3 + 8528);
    if (v27 <= 0.0) {
      double v27 = 5.0;
    }
    *(double *)(a3 + 852_Block_object_dispose((const void *)(v1 - 136), 8) = Current;
    double v28 = *(double *)(a3 + 8480) * 800.0 * 8.0 / 1000.0 / v27;
    double v29 = *(double *)(a3 + 8488) * 800.0 * 8.0 / 1000.0 / v27;
    if (v28 / (v22 + 0.01) <= 0.99) {
      double v30 = v28 / (v22 + 0.01);
    }
    else {
      double v30 = 0.99;
    }
    if (v29 / (v23 + 0.01) <= 0.99) {
      double v31 = v29 / (v23 + 0.01);
    }
    else {
      double v31 = 0.99;
    }
    char v32 = 1;
    if (v30 <= 0.05 && v31 <= 0.05)
    {
      if (v30 >= 0.01 || v31 >= 0.01) {
        goto LABEL_61;
      }
      char v32 = 0;
    }

    *(_BYTE *)(a3 + 8561) = v32;
LABEL_61:
    __int16 v33 = objc_autoreleasePoolPush();
    if (qword_100219F60)
    {
      if (*(_BYTE *)(a3 + 8561)) {
        id v34 = "Yes";
      }
      else {
        id v34 = "No";
      }
      [qword_100219F60 WFLog:message:3, "%s: SNR %.1lf, CCA %.1lf, Tx bandwidth %.1lf (kbps), Rx bandwidth %.1lf, Tx data rate %.1lf (kbps), Rx data rate %.1lf, Tx air time %.3lf %%, Rx air time %.3lf %%, Good background traffic ? %s", "__WiFiDeviceManagerMonitor24GHzInfraNetworkTraffic", *(void *)(a3 + 8496), *(void *)(a3 + 8504), *(void *)&v22, *(void *)&v23, *(void *)&v28, *(void *)&v29, v30 * 100.0, v31 * 100.0, v34];
    }

    objc_autoreleasePoolPop(v33);
    sub_1000EB060(a3, (uint64_t)a2);
    goto LABEL_67;
  }

uint64_t sub_1000C4DD4(uint64_t a1, uint64_t a2, uint64_t a3)
{
  if (a3)
  {
    unsigned int v3 = *(uint64_t (**)(uint64_t, uint64_t, void))(a3 + 4240);
    if (v3) {
      return v3(a3, a2, *(void *)(a3 + 4248));
    }
  }

  return result;
}

uint64_t sub_1000C4DF4(uint64_t a1, uint64_t a2, uint64_t a3)
{
  if (a3)
  {
    unsigned int v3 = *(uint64_t (**)(uint64_t, uint64_t, void))(a3 + 4256);
    if (v3) {
      return v3(a3, a2, *(void *)(a3 + 4264));
    }
  }

  return result;
}

void sub_1000C4E14(int a1, uint64_t a2, uint64_t a3, CFDictionaryRef theDict)
{
  if (a3 && theDict)
  {
    if (!*(void *)(a3 + 7320)) {
      goto LABEL_34;
    }
    uint64_t valuePtr = 0LL;
    CFBooleanRef Value = (const __CFNumber *)CFDictionaryGetValue(theDict, @"BSP_EventType");
    if (Value)
    {
      CFNumberGetValue(Value, kCFNumberLongLongType, &valuePtr);
      int v8 = valuePtr;
      double v9 = (const __CFDictionary *)CFDictionaryGetValue(theDict, @"BSP_EventParams");
      if (v9)
      {
        int v10 = v9;
        if (v8 == 18)
        {
          double v31 = (const __CFNumber *)CFDictionaryGetValue(v9, @"BSP_CoexMode");
          if (v31)
          {
            CFNumberGetValue(v31, kCFNumberLongLongType, &valuePtr);
            BOOL v32 = valuePtr != 0;
          }

          else
          {
            BOOL v32 = 0LL;
          }

          [*(id *)(a3 + 7320) updateIsBSPActive:v32];
          goto LABEL_34;
        }

        if (v8 != 19)
        {
LABEL_34:
          int v39 = *(void (**)(uint64_t, uint64_t, void, CFDictionaryRef))(a3 + 4784);
          if (v39) {
            v39(a3, a2, *(void *)(a3 + 4792), theDict);
          }
          return;
        }

        [*(id *)(a3 + 7320) updateIsBSPActive:1];
        double v11 = (const __CFNumber *)CFDictionaryGetValue(v10, @"BSP_LQM_Overflowed");
        if (v11)
        {
          CFNumberGetValue(v11, kCFNumberLongLongType, &valuePtr);
          BOOL v12 = valuePtr != 0;
          double v13 = (const __CFNumber *)CFDictionaryGetValue(v10, @"BSP_LQM_TimeToTST");
          if (v13)
          {
            CFNumberGetValue(v13, kCFNumberLongLongType, &valuePtr);
            uint64_t v46 = valuePtr;
            unsigned int v14 = (const __CFNumber *)CFDictionaryGetValue(v10, @"BSP_LQM_SampleDurationMS");
            if (!v14)
            {
              BOOL v33 = 0LL;
              BOOL v34 = 0LL;
              uint64_t v28 = 0x7FFFFFFFFFFFFFFFLL;
              uint64_t v24 = 0x7FFFFFFFFFFFFFFFLL;
              uint64_t v35 = 0x7FFFFFFFFFFFFFFFLL;
              uint64_t v36 = 0x7FFFFFFFFFFFFFFFLL;
              uint64_t v38 = 0x7FFFFFFFFFFFFFFFLL;
              uint64_t v19 = 0x7FFFFFFFFFFFFFFFLL;
              uint64_t v22 = 0x7FFFFFFFFFFFFFFFLL;
              uint64_t v26 = 0x7FFFFFFFFFFFFFFFLL;
              uint64_t v30 = 0x7FFFFFFFFFFFFFFFLL;
              uint64_t v37 = v46;
              goto LABEL_33;
            }

            CFNumberGetValue(v14, kCFNumberLongLongType, &valuePtr);
            uint64_t v45 = valuePtr;
            double v15 = (const __CFNumber *)CFDictionaryGetValue(v10, @"BSP_LQM_IsScanActive");
            if (v15)
            {
              CFNumberGetValue(v15, kCFNumberLongLongType, &valuePtr);
              BOOL v44 = valuePtr != 0;
              double v16 = (const __CFNumber *)CFDictionaryGetValue(v10, @"BSP_LQM_IsP2PActive");
              if (v16)
              {
                CFNumberGetValue(v16, kCFNumberLongLongType, &valuePtr);
                BOOL v43 = valuePtr != 0;
                double v17 = (const __CFNumber *)CFDictionaryGetValue(v10, @"BSP_LQM_TriggerCount");
                if (v17)
                {
                  CFNumberGetValue(v17, kCFNumberLongLongType, &valuePtr);
                  uint64_t v42 = valuePtr;
                  double v18 = (const __CFNumber *)CFDictionaryGetValue(v10, @"BSP_LQM_MutePercentage");
                  if (v18)
                  {
                    CFNumberGetValue(v18, kCFNumberLongLongType, &valuePtr);
                    uint64_t v19 = valuePtr;
                    double v20 = (const __CFNumber *)CFDictionaryGetValue(v10, @"BSP_LQM_MaxMuteMS");
                    if (v20)
                    {
                      CFNumberGetValue(v20, kCFNumberLongLongType, &valuePtr);
                      uint64_t v41 = valuePtr;
                      double v21 = (const __CFNumber *)CFDictionaryGetValue(v10, @"BSP_LQM_AvgMuteMS");
                      if (v21)
                      {
                        CFNumberGetValue(v21, kCFNumberLongLongType, &valuePtr);
                        uint64_t v22 = valuePtr;
                        double v23 = (const __CFNumber *)CFDictionaryGetValue(v10, @"BSP_LQM_ErrorPercentage");
                        if (v23)
                        {
                          CFNumberGetValue(v23, kCFNumberLongLongType, &valuePtr);
                          uint64_t v24 = valuePtr;
                          double v25 = (const __CFNumber *)CFDictionaryGetValue( v10,  @"BSP_LQM_TimeoutPercentageOfTriggers");
                          if (v25)
                          {
                            CFNumberGetValue(v25, kCFNumberLongLongType, &valuePtr);
                            uint64_t v26 = valuePtr;
                            double v27 = (const __CFNumber *)CFDictionaryGetValue( v10,  @"BSP_LQM_RejectOrFailPercentageOfTriggers");
                            if (v27)
                            {
                              CFNumberGetValue(v27, kCFNumberLongLongType, &valuePtr);
                              uint64_t v28 = valuePtr;
                              double v29 = (const __CFNumber *)CFDictionaryGetValue(v10, @"BSP_LQM_MaxConsecutiveFails");
                              if (v29)
                              {
                                CFNumberGetValue(v29, kCFNumberLongLongType, &valuePtr);
                                uint64_t v30 = valuePtr;
LABEL_45:
                                uint64_t v37 = v46;
                                BOOL v34 = v43;
                                BOOL v33 = v44;
                                uint64_t v38 = v45;
                                uint64_t v35 = v41;
                                uint64_t v36 = v42;
                                goto LABEL_33;
                              }
                            }

                            else
                            {
                              uint64_t v28 = 0x7FFFFFFFFFFFFFFFLL;
                            }

uint64_t sub_1000C52E4(uint64_t a1, uint64_t a2, uint64_t a3)
{
  if (a3)
  {
    unsigned int v3 = *(uint64_t (**)(uint64_t, uint64_t, void))(a3 + 4800);
    if (v3) {
      return v3(a3, a2, *(void *)(a3 + 4808));
    }
  }

  return result;
}

uint64_t sub_1000C5304(uint64_t a1, uint64_t a2, uint64_t a3)
{
  if (a3)
  {
    unsigned int v3 = *(uint64_t (**)(uint64_t, uint64_t, void))(a3 + 4272);
    if (v3) {
      return v3(a3, a2, *(void *)(a3 + 4280));
    }
  }

  return result;
}

void sub_1000C5324(int a1, uint64_t a2, uint64_t a3, CFDictionaryRef theDict)
{
  if (a3)
  {
    id v6 = *(void (**)(uint64_t, uint64_t, void, CFDictionaryRef))(a3 + 4288);
    if (v6) {
      v6(a3, a2, *(void *)(a3 + 4296), theDict);
    }
    sub_10001C254(*(void *)(a3 + 120), theDict);
    CFBooleanRef Value = (const __CFDictionary *)CFDictionaryGetValue(theDict, @"QUAL_SCORE");
    if (Value)
    {
      int valuePtr = 0;
      int v8 = (const __CFNumber *)CFDictionaryGetValue(Value, @"LINK_RECOMMENDATION_FLAGS");
      if (v8)
      {
        CFNumberGetValue(v8, kCFNumberSInt32Type, &valuePtr);
        char v11 = 0;
        double v9 = (const __CFNumber *)CFDictionaryGetValue(theDict, @"RT_TRAFFIC_STATE");
        if (v9)
        {
          CFNumberGetValue(v9, kCFNumberSInt8Type, &v11);
          *(_BYTE *)(a3 + 3469) = v11 & 3;
          if (_os_feature_enabled_impl("WiFiManager", "RealTimeRoamSuppression"))
          {
            int v10 = *(unsigned __int8 *)(a3 + 6994);
            if (*(_BYTE *)(a3 + 6994))
            {
              if (-[WiFiUserInteractionMonitor isWiFiCallInProgress]( +[WiFiUserInteractionMonitor sharedInstance]( &OBJC_CLASS___WiFiUserInteractionMonitor,  "sharedInstance"),  "isWiFiCallInProgress")
                || (int v10 = *(unsigned __int8 *)(a3 + 3469), *(_BYTE *)(a3 + 3469)))
              {
                int v10 = (*(_DWORD *)(a3 + 3460) & 1) == 0;
              }
            }
          }

          else
          {
            int v10 = 0;
          }

          if (valuePtr != *(_DWORD *)(a3 + 3460) || v10 != *(unsigned __int8 *)(a3 + 3468))
          {
            *(_DWORD *)(a3 + 3460) = valuePtr;
            sub_1000CCDC0(a3);
          }
        }
      }
    }
  }

void sub_1000C5454(int a1, uint64_t a2, uint64_t a3, CFDictionaryRef theDict)
{
  if (a3)
  {
    id v6 = *(void (**)(uint64_t, uint64_t, void, CFDictionaryRef))(a3 + 4304);
    if (v6) {
      v6(a3, a2, *(void *)(a3 + 4312), theDict);
    }
    *(void *)&__int128 v7 = 0xAAAAAAAAAAAAAAAALL;
    *((void *)&v7 + 1) = 0xAAAAAAAAAAAAAAAALL;
    *(_OWORD *)&v9[12] = v7;
    __int128 v8 = v7;
    *(_OWORD *)double v9 = v7;
    sub_10001CE8C(*(void *)(a3 + 120), theDict);
    sub_10001C4E0(*(void *)(a3 + 120), (uint64_t)&v8);
    if (arc4random_uniform(0x63u) <= 1) {
      sub_1000D9F74(a3, (uint64_t)&v8);
    }
  }

void sub_1000C5520(int a1, int a2, uint64_t a3, CFDictionaryRef theDict)
{
  if (a3) {
    sub_10001C4F8(*(void *)(a3 + 120), theDict);
  }
}

void sub_1000C5534(uint64_t a1, const __CFString *a2)
{
}

void sub_1000C553C(uint64_t a1, const __CFString *a2)
{
  if (a2) {
    int v2 = a2;
  }
  else {
    int v2 = @"SoftErrorTriggeredChipReset";
  }
  if (!a1)
  {
    __int128 v8 = objc_autoreleasePoolPush();
    if (qword_100219F60) {
      [qword_100219F60 WFLog:@"%s: manager is NULL" message:3];
    }
    goto LABEL_22;
  }

  if (!*(void *)(a1 + 64))
  {
    __int128 v8 = objc_autoreleasePoolPush();
    if (qword_100219F60) {
      [qword_100219F60 WFLog:@"message: %s: manager->device is NULL" message:@"WiFiDeviceManagerResetChip"];
    }
    goto LABEL_22;
  }

  CFMutableDictionaryRef Mutable = CFDictionaryCreateMutable( kCFAllocatorDefault,  0LL,  &kCFTypeDictionaryKeyCallBacks,  &kCFTypeDictionaryValueCallBacks);
  if (!Mutable)
  {
    __int128 v8 = objc_autoreleasePoolPush();
    if (qword_100219F60) {
      [qword_100219F60 WFLog:@"%s: resetTriggerInfo allocation failed!" message:3];
    }
LABEL_22:
    objc_autoreleasePoolPop(v8);
    return;
  }

  unsigned int v5 = Mutable;
  if (CFStringGetLength(v2) <= 0 && MGGetBoolAnswer(@"InternalBuild"))
  {
    id v6 = objc_autoreleasePoolPush();
    if (qword_100219F60) {
      [qword_100219F60 WFLog:@"%s: Will request to chip reset with no triggerReason" message:4];
    }
    objc_autoreleasePoolPop(v6);
    if (os_log_type_enabled((os_log_t)&_os_log_default, OS_LOG_TYPE_FAULT)) {
      sub_100154780();
    }
  }

  CFDictionaryAddValue(v5, @"CHIP_RESET_TRIGGER", v2);
  __int128 v7 = objc_autoreleasePoolPush();
  if (qword_100219F60) {
    [(id)qword_100219F60 WFLog:3, "%s: Calling ChipReset with reason:%@", "WiFiDeviceManagerResetChip", v2 message];
  }
  objc_autoreleasePoolPop(v7);
  sub_100053538(*(void *)(a1 + 64), v5);
  CFRelease(v5);
}

void sub_1000C573C(int a1, uint64_t a2, CFDictionaryRef theDict, uint64_t a4)
{
  if (a4)
  {
    id v6 = *(void (**)(uint64_t, uint64_t, CFDictionaryRef, void))(a4 + 4464);
    if (v6) {
      v6(a4, a2, theDict, *(void *)(a4 + 4472));
    }
    if (theDict)
    {
      CFBooleanRef Value = (const __CFBoolean *)CFDictionaryGetValue(theDict, @"DRIVER_AVAILABLE");
      if (Value)
      {
        *(_BYTE *)(a4 + 3480) = CFBooleanGetValue(Value);
        __int128 v8 = (const __CFNumber *)CFDictionaryGetValue(theDict, @"DRIVER_AVAILABLE_REASON");
        if (v8) {
          CFNumberGetValue(v8, kCFNumberSInt32Type, (void *)(a4 + 3484));
        }
        if (!*(_BYTE *)(a4 + 3480))
        {
          sub_10010E744(a4);
          int v11 = *(_DWORD *)(a4 + 3484);
          if (v11 == -528345084)
          {
            BOOL v12 = objc_autoreleasePoolPush();
            if (qword_100219F60) {
              [(id)qword_100219F60 WFLog:3 message:"clearing slowWiFi HUD on S2R"];
            }
            objc_autoreleasePoolPop(v12);
            sub_10010E868(a4);
            *(_BYTE *)(a4 + 348_Block_object_dispose((const void *)(v1 - 136), 8) = 0;
            int v11 = *(_DWORD *)(a4 + 3484);
          }

          else
          {
            *(_BYTE *)(a4 + 348_Block_object_dispose((const void *)(v1 - 136), 8) = 1;
          }

          if (v11 == -528336895) {
            [*(id *)(a4 + 6632) removeDenyListStateWithDenyListRemoveReason:7];
          }
          if (*(void *)(a4 + 4936))
          {
            int v13 = *(_DWORD *)(a4 + 3484);
            if (v13 == -528345084 || v13 == -528336891) {
              return;
            }
            unsigned int v14 = objc_autoreleasePoolPush();
            if (qword_100219F60) {
              [qword_100219F60 WFLog:@"%s: MIS is in session. Driver is unavailable. Starting recovery timer!" message:3];
            }
            objc_autoreleasePoolPop(v14);
            *(_BYTE *)(a4 + 5214) = 1;
            sub_1000DC9F0(a4, 1LL);
          }

          sub_1000D0428(a4);
          return;
        }

        if (!*(void *)(a4 + 4936) || !*(_BYTE *)(a4 + 5214)) {
          goto LABEL_38;
        }
        double v9 = objc_autoreleasePoolPush();
        if (qword_100219F60) {
          [qword_100219F60 WFLog:@"%s: MIS is in recovery. Driver is available. Restarting MIS network!" message:3];
        }
        objc_autoreleasePoolPop(v9);
        if (*(_BYTE *)(a4 + 5211) != 1 || *(_BYTE *)(a4 + 5214) || *(_BYTE *)(a4 + 5215) || *(_BYTE *)(a4 + 5378))
        {
          if (*(_DWORD *)(a4 + 5336))
          {
            int v10 = objc_autoreleasePoolPush();
            if (qword_100219F60) {
              [qword_100219F60 WFLog:@"MIS start in pending, current state: %d" message:3];
            }
            goto LABEL_37;
          }

          uint64_t v21 = 0LL;
          memset(v20, 0, sizeof(v20));
          DWORD1(v20[0]) = 4;
          sub_1000DC1AC(a4, (uint64_t)v20);
          int v10 = objc_autoreleasePoolPush();
          double v15 = (void *)qword_100219F60;
          if (!qword_100219F60)
          {
LABEL_37:
            objc_autoreleasePoolPop(v10);
LABEL_38:
            if (_os_feature_enabled_impl("CoreWiFi", "UnifiedAutoJoin"))
            {
              if (*(_BYTE *)(a4 + 3488)) {
                sub_1000F5F98(a4, 7uLL);
              }
            }

            else
            {
              [+[WiFiXPCManager sharedXPCManager](WiFiXPCManager, "sharedXPCManager") autoJoinStartedWithTrigger:7 interfaceName:sub_100043E8C(*(void *)(a4 + 64))];
              sub_1000D0A5C(a4, 2LL, (uint64_t)"WiFiDeviceManagerAutoAssociateStart");
            }

            *(_BYTE *)(a4 + 724_Block_object_dispose((const void *)(v1 - 136), 8) = 0;
            *(_BYTE *)(a4 + 348_Block_object_dispose((const void *)(v1 - 136), 8) = 0;
            if (*(_BYTE *)(a4 + 3489))
            {
              LocalCenter = CFNotificationCenterGetLocalCenter();
              CFNotificationCenterPostNotification(LocalCenter, @"WiFiChipResetCompleted", 0LL, 0LL, 1u);
              *(_BYTE *)(a4 + 3489) = 0;
              double v18 = objc_autoreleasePoolPush();
              if (qword_100219F60) {
                [qword_100219F60 WFLog:@"__WiFiDeviceManagerAvailableCallback announced driver availability (WiFiChipResetCompleted)"];
              }
              objc_autoreleasePoolPop(v18);
            }

            return;
          }

          double v16 = "User disabled MIS";
        }

        else
        {
          int v10 = objc_autoreleasePoolPush();
          double v15 = (void *)qword_100219F60;
          if (!qword_100219F60) {
            goto LABEL_37;
          }
          double v16 = "MIS is already enabled";
        }

        objc_msgSend(v15, "WFLog:message:", 3, v16, v19);
        goto LABEL_37;
      }
    }
  }

uint64_t sub_1000C5AE0(uint64_t a1, uint64_t a2, uint64_t a3)
{
  if (a3)
  {
    unsigned int v3 = *(uint64_t (**)(uint64_t, uint64_t, void))(a3 + 3968);
    if (v3) {
      return v3(a3, a2, *(void *)(a3 + 3976));
    }
  }

  return result;
}

uint64_t sub_1000C5B00(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  if (a4)
  {
    __int128 v4 = *(uint64_t (**)(uint64_t, uint64_t, uint64_t, void))(a4 + 4176);
    if (v4) {
      return v4(a4, a2, a3, *(void *)(a4 + 4040));
    }
  }

  return result;
}

uint64_t sub_1000C5B20(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  if (a4)
  {
    __int128 v4 = *(uint64_t (**)(uint64_t, uint64_t, uint64_t, void))(a4 + 4192);
    if (v4) {
      return v4(a4, a2, a3, *(void *)(a4 + 4040));
    }
  }

  return result;
}

void sub_1000C5B40(uint64_t a1, const __CFString *a2, const __CFDictionary *a3, uint64_t a4)
{
  if (a4)
  {
    uint64_t v20 = a4 + 5496;
    *(_BYTE *)(a4 + 5496) = 0;
    dispatch_source_set_timer(*(dispatch_source_t *)(a4 + 5504), 0xFFFFFFFFFFFFFFFFLL, 0xFFFFFFFFFFFFFFFFLL, 0LL);
    *(_DWORD *)(a4 + 68_Block_object_dispose((const void *)(v1 - 136), 8) = 0;
    *(void *)(a4 + 680) = 0LL;
    __int128 v7 = objc_autoreleasePoolPush();
    if (qword_100219F60) {
      [qword_100219F60 WFLog:@"%s: Disabling critical phase" message:3];
    }
    objc_autoreleasePoolPop(v7);
    __int128 v8 = (const __CFString *)sub_100043E8C(a1);
    BOOL v9 = 0LL;
    if (a2 && v8) {
      BOOL v9 = CFStringCompare(v8, a2, 0LL) == kCFCompareEqualTo;
    }
    BOOL v10 = sub_10003E7A4(a1);
    if (v10)
    {
      int v11 = sub_100040538(a1, a2);
      BOOL v12 = v11;
    }

    else
    {
      BOOL v12 = 0LL;
    }

    BOOL v13 = sub_10003E890(a1);
    uint64_t v14 = sub_10003E8AC(a1);
    BOOL v15 = sub_10003E8B8(a1);
    double v16 = *(void (**)(uint64_t, const __CFString *, const void *, BOOL, BOOL, uint64_t, BOOL, void))(a4 + 4400);
    if (v16) {
      v16(a4, a2, v12, v9, v13, v14, v15, *(void *)(a4 + 4408));
    }
    if (v10 && v9)
    {
      double v17 = objc_autoreleasePoolPush();
      [*(id *)(a4 + 6608) disarmHomeNetworkTransitionTimer];
      [*(id *)(a4 + 6608) armHomeNetworkTransitionTimer:a4];
      objc_autoreleasePoolPop(v17);
    }

    double v18 = objc_autoreleasePoolPush();
    if (qword_100219F60)
    {
      uint64_t v19 = +[NSString stringWithFormat:]( &OBJC_CLASS___NSString,  "stringWithFormat:",  @"%s",  -[NSString UTF8String]( +[NSString stringWithFormat:]( &OBJC_CLASS___NSString,  "stringWithFormat:",  @"{%@-} %@",  @"AUTOJOIN",  +[NSString stringWithFormat:]( &OBJC_CLASS___NSString,  "stringWithFormat:",  @"%s: ip address configuration completed for %@",  "__WiFiDeviceManagerRouterIpv4Callback",  sub_100095BC8(v12))),  "UTF8String"));
      if (os_log_type_enabled((os_log_t)&_os_log_default, OS_LOG_TYPE_DEFAULT))
      {
        *(_DWORD *)__int128 buf = 136446210;
        double v23 = -[NSString UTF8String]( +[NSString stringWithFormat:]( &OBJC_CLASS___NSString,  "stringWithFormat:",  @"[WiFiPolicy] %s",  -[NSString UTF8String](v19, "UTF8String")),  "UTF8String");
        _os_log_impl( (void *)&_mh_execute_header,  (os_log_t)&_os_log_default,  OS_LOG_TYPE_DEFAULT,  "%{public}s",  buf,  0xCu);
      }
    }

    objc_autoreleasePoolPop(v18);
    if (v12) {
      CFRelease(v12);
    }
    sub_100015FDC(*(void *)(a4 + 120), a2, a3);
    if (*(_BYTE *)(v20 + 1352))
    {
      else {
        sub_1000D0A5C(a4, 2LL, (uint64_t)"__WiFiDeviceManagerRouterIpv4Callback");
      }
    }

    sub_1000DE0D0(a4, 5u, v13 | (2 * ((_DWORD)v14 != 0)));
    *(_BYTE *)(a4 + 3441) = 1;
    sub_1000D3350(a4);
  }

void sub_1000C5E84(uint64_t a1, const void *a2, uint64_t a3)
{
  if (!a3)
  {
    BOOL v12 = objc_autoreleasePoolPush();
    if (qword_100219F60) {
      [qword_100219F60 WFLog:@"__WiFiDeviceManagerWiFiPrimaryInfCallback: manager is null"];
    }
    goto LABEL_17;
  }

  sub_100015578(*(void *)(a3 + 120));
  unsigned int v5 = sub_1000DEA34(a3, a2, 1);
  if (!v5)
  {
    BOOL v12 = objc_autoreleasePoolPush();
    if (qword_100219F60) {
      [qword_100219F60 WFLog:@"network is null" message:4];
    }
LABEL_17:
    objc_autoreleasePoolPop(v12);
    return;
  }

  id v6 = v5;
  if (!*(_BYTE *)(a3 + 3440))
  {
    if (!*(_BYTE *)(a3 + 3441))
    {
      __int128 v7 = objc_autoreleasePoolPush();
      if (qword_100219F60)
      {
        __int128 v8 = +[NSString stringWithFormat:]( &OBJC_CLASS___NSString,  "stringWithFormat:",  @"%s",  -[NSString UTF8String]( +[NSString stringWithFormat:]( &OBJC_CLASS___NSString,  "stringWithFormat:",  @"{%@-} %@",  @"AUTOJOIN",  +[NSString stringWithFormat:]( &OBJC_CLASS___NSString,  "stringWithFormat:",  @"%s: ip address configuration completed for %@",  "__WiFiDeviceManagerWiFiPrimaryInfCallback",  sub_100095BC8(v6))),  "UTF8String"));
        if (os_log_type_enabled((os_log_t)&_os_log_default, OS_LOG_TYPE_DEFAULT))
        {
          *(_DWORD *)__int128 buf = 136446210;
          uint64_t v14 = -[NSString UTF8String]( +[NSString stringWithFormat:]( &OBJC_CLASS___NSString,  "stringWithFormat:",  @"[WiFiPolicy] %s",  -[NSString UTF8String](v8, "UTF8String")),  "UTF8String");
          _os_log_impl( (void *)&_mh_execute_header,  (os_log_t)&_os_log_default,  OS_LOG_TYPE_DEFAULT,  "%{public}s",  buf,  0xCu);
        }
      }

      objc_autoreleasePoolPop(v7);
      sub_1000DE0D0(a3, 5u, 4LL);
    }

    sub_10010E980(a3, v6, 0);
    if (sub_100098BF8((uint64_t)v6))
    {
      CFStringRef v9 = sub_100095408((CFDictionaryRef *)v6);
      if (v9)
      {
        CFStringRef v10 = v9;
        int v11 = sub_100095CB0(v6);
        sub_1000AE60C((uint64_t)v11, (uint64_t)v10);
        CFRelease(v10);
      }
    }
  }

  *(_BYTE *)(a3 + 3440) = 1;
  CFRelease(v6);
}

uint64_t sub_1000C6118(uint64_t a1, uint64_t a2, uint64_t a3, int a4)
{
  if (a3) {
    return sub_1000153D8(*(void *)(a3 + 120), a2, a4);
  }
  return result;
}

void sub_1000C612C(uint64_t a1, const void *a2, uint64_t a3, int a4, uint64_t a5)
{
  CFStringRef v9 = objc_autoreleasePoolPush();
  if (!a3)
  {
    double v18 = objc_autoreleasePoolPush();
    if (qword_100219F60) {
      [qword_100219F60 WFLog:@"Device Manager is NULL"];
    }
    goto LABEL_19;
  }

  if (!a2)
  {
    double v18 = objc_autoreleasePoolPush();
    if (qword_100219F60) {
      [qword_100219F60 WFLog:@"%s, Device IfName is NULL" message:4];
    }
LABEL_19:
    objc_autoreleasePoolPop(v18);
    goto LABEL_14;
  }

  CFStringRef v10 = sub_1000DEA34(a3, a2, 1);
  int v11 = sub_1000951FC((uint64_t)v10, @"BSSID");
  if (v11)
  {
    if (v10)
    {
      uint64_t v12 = (uint64_t)v11;
      BOOL v13 = objc_autoreleasePoolPush();
      if (qword_100219F60) {
        [(id)qword_100219F60 WFLog:3, "%s: LQAMgr Trigger Disconnected and Blacklisted Network %@", "__WiFiLQAMgrTrigDiscEventCallback", sub_100095BC8(v10) message];
      }
      objc_autoreleasePoolPop(v13);
      sub_1000CE074(a3, a2, 1000LL, "__WiFiLQAMgrTrigDiscEventCallback", 10203LL);
      id v14 = sub_1000A335C((uint64_t)v10);
      id v15 = sub_1000D1BDC(a3, 6LL, a4, v12, 1LL);
      [*(id *)(a3 + 6632) setNetworkDenyListInfo:v15 forScanResult:v14];
      -[WiFiUsageMonitor setTdLogic_deferJoin:perBSSID:]( +[WiFiUsageMonitor sharedInstance](WiFiUsageMonitor, "sharedInstance"),  "setTdLogic_deferJoin:perBSSID:",  60 * [*(id *)(a3 + 6632) denyListThresholdForReason:6 forSSIDThresholds:1],  60 * [*(id *)(a3 + 6632) denyListThresholdForReason:6 forSSIDThresholds:0]);

      if (*(_BYTE *)(a3 + 6208))
      {
        double v16 = *(void (**)(uint64_t, uint64_t, uint64_t, void))(a3 + 4544);
        if (v16)
        {
          v16(a3, 6LL, a5, *(void *)(a3 + 4552));
        }

        else
        {
          double v17 = objc_autoreleasePoolPush();
          if (qword_100219F60) {
            [qword_100219F60 WFLog:@"__WiFiDeviceManagerTriggerDisconnectNotification: softErrorManagerService callback is NULL!"];
          }
          objc_autoreleasePoolPop(v17);
        }
      }

uint64_t sub_1000C63C8(uint64_t a1, const void *a2, uint64_t a3)
{
  return sub_1000FDAE4(a3, a2);
}

uint64_t sub_1000C63D0(uint64_t a1, uint64_t a2, const void *a3, uint64_t a4)
{
  if (!a4)
  {
    uint64_t v12 = objc_autoreleasePoolPush();
    if (qword_100219F60) {
      [qword_100219F60 WFLog:@"%s: devicemanager null" message:4];
    }
    goto LABEL_26;
  }

  if (!a3)
  {
    uint64_t v12 = objc_autoreleasePoolPush();
    if (qword_100219F60) {
      [qword_100219F60 WFLog:@"%s: transitionNetwork null" message:4];
    }
    goto LABEL_26;
  }

  if (*(_BYTE *)(a4 + 6600))
  {
    uint64_t v12 = objc_autoreleasePoolPush();
    if (qword_100219F60) {
      [qword_100219F60 WFLog:@"%s: already in progress" message:4];
    }
    goto LABEL_26;
  }

  if (!sub_1000D33E4((void *)a4, a3))
  {
    uint64_t v12 = objc_autoreleasePoolPush();
    if (qword_100219F60) {
      [(id)qword_100219F60 WFLog:4, "%s: transitionNetwork %@ is not a known network", "__WiFiDeviceManagerColocatedScopeTransitionCallback", sub_100095BC8(a3) message];
    }
    goto LABEL_26;
  }

  id v6 = (const void *)sub_10004CE2C(*(void *)(a4 + 64));
  __int128 v7 = sub_1000DEA34(a4, v6, 1);
  if (!v7)
  {
    uint64_t v12 = objc_autoreleasePoolPush();
    if (qword_100219F60) {
      [qword_100219F60 WFLog:@"%s: current Network null" message:4];
    }
LABEL_26:
    objc_autoreleasePoolPop(v12);
    return 0LL;
  }

  __int128 v8 = v7;
  if (sub_100110894(a4, (uint64_t)v7, (uint64_t)a3))
  {
    if (_os_feature_enabled_impl("CoreWiFi", "UnifiedAutoJoin"))
    {
      sub_1000F5F98(a4, 0x27uLL);
    }

    else
    {
      CFStringRef v9 = *(const void **)(a4 + 6592);
      if (v9)
      {
        CFRelease(v9);
        *(void *)(a4 + 6592) = 0LL;
      }

      *(void *)(a4 + 6592) = sub_100094E60((uint64_t)kCFAllocatorDefault, (uint64_t)a3);
      sub_1000D66BC(a4, 7);
    }

    uint64_t v10 = 1LL;
  }

  else
  {
    BOOL v13 = objc_autoreleasePoolPush();
    if (qword_100219F60) {
      [qword_100219F60 WFLog:@"%s: ColocatedScopeIds mismatch" message:4];
    }
    objc_autoreleasePoolPop(v13);
    uint64_t v10 = 0LL;
  }

  CFRelease(v8);
  return v10;
}

void sub_1000C6630(int a1, uint64_t a2, uint64_t a3, CFTypeRef cf)
{
  unsigned int valuePtr = 0;
  if (!a3)
  {
    uint64_t v10 = objc_autoreleasePoolPush();
    int v11 = (void *)qword_100219F60;
    if (!qword_100219F60) {
      goto LABEL_12;
    }
    uint64_t v12 = "%s: manager is NULL !";
    goto LABEL_23;
  }

  if (!cf || (CFTypeID v7 = CFGetTypeID(cf), v7 != CFDictionaryGetTypeID()))
  {
    uint64_t v10 = objc_autoreleasePoolPush();
    int v11 = (void *)qword_100219F60;
    if (!qword_100219F60)
    {
LABEL_12:
      objc_autoreleasePoolPop(v10);
      return;
    }

    uint64_t v12 = "%s:NULL event Data";
    uint64_t v13 = 3LL;
LABEL_11:
    [v11 WFLog:v13 message:v12 __WiFiDeviceManagerLeakyAPEventCallback];
    goto LABEL_12;
  }

  CFBooleanRef Value = (const __CFNumber *)CFDictionaryGetValue((CFDictionaryRef)cf, @"LEAKY_AP_STATS_VER");
  if (!Value)
  {
    uint64_t v10 = objc_autoreleasePoolPush();
    int v11 = (void *)qword_100219F60;
    if (!qword_100219F60) {
      goto LABEL_12;
    }
    uint64_t v12 = "%s, leakyAPStatsVersionRef is NULL";
LABEL_23:
    uint64_t v13 = 4LL;
    goto LABEL_11;
  }

  CFNumberGetValue(Value, kCFNumberSInt32Type, &valuePtr);
  if (valuePtr == 2)
  {
    uint64_t v14 = *(void (**)(uint64_t, uint64_t, void, CFTypeRef))(a3 + 4480);
    if (v14) {
      v14(a3, a2, *(void *)(a3 + 4488), cf);
    }
  }

  else
  {
    if (valuePtr == 1)
    {
      CFStringRef v9 = objc_autoreleasePoolPush();
      if (qword_100219F60) {
        [qword_100219F60 WFLog:@"Ignoring Leaky AP report version %d" message:3];
      }
    }

    else
    {
      CFStringRef v9 = objc_autoreleasePoolPush();
      if (qword_100219F60) {
        [qword_100219F60 WFLog:@"Unknown LEaky AP report version %d" message:4];
      }
    }

    objc_autoreleasePoolPop(v9);
  }

void sub_1000C67F4(uint64_t a1, void *a2)
{
  int valuePtr = 1;
  if (!a2)
  {
    uint64_t v10 = objc_autoreleasePoolPush();
    if (qword_100219F60) {
      [qword_100219F60 WFLog:@"%s: manager is NULL !" message:4];
    }
    goto LABEL_17;
  }

  if (!a2[15])
  {
    uint64_t v10 = objc_autoreleasePoolPush();
    if (qword_100219F60) {
      [qword_100219F60 WFLog:@"%s: LQA manager is NULL !" message:4];
    }
LABEL_17:
    objc_autoreleasePoolPop(v10);
    return;
  }

  CFNumberRef v3 = CFNumberCreate(kCFAllocatorDefault, kCFNumberSInt32Type, &valuePtr);
  if (v3)
  {
    CFNumberRef v4 = v3;
    uint64_t v5 = a2[8];
    id v6 = (const void *)sub_100043E8C(v5);
    sub_10003EC6C(v5, v6, 538LL, 0LL, (uint64_t)v4);
    CFRelease(v4);
  }

  if (!a2[694])
  {
    CFMutableDictionaryRef Mutable = CFDictionaryCreateMutable(0LL, 0LL, &kCFTypeDictionaryKeyCallBacks, &kCFTypeDictionaryValueCallBacks);
    a2[694] = Mutable;
    if (sub_1000EB574((uint64_t)a2, Mutable, 5LL, dword_10017FB7C, 3u, 1u, 0LL, 0LL))
    {
      __int128 v8 = (const void *)a2[694];
      if (v8)
      {
        CFRelease(v8);
        a2[694] = 0LL;
      }

      CFStringRef v9 = objc_autoreleasePoolPush();
      if (qword_100219F60) {
        [qword_100219F60 WFLog:@"%s: Triggering Active Probe failed!" message:4];
      }
      objc_autoreleasePoolPop(v9);
    }
  }

uint64_t sub_1000C699C(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  if (a4)
  {
    CFNumberRef v4 = *(uint64_t (**)(uint64_t, uint64_t, uint64_t, void))(a4 + 4496);
    if (v4) {
      return v4(a4, a2, a3, *(void *)(a4 + 4504));
    }
  }

  return result;
}

void sub_1000C69BC(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  uint64_t v6 = a4;
  if (a3)
  {
    CFNumberRef v4 = *(void (**)(uint64_t, uint64_t, uint64_t *, void))(a3 + 4544);
    if (v4)
    {
      v4(a3, 5LL, &v6, *(void *)(a3 + 4552));
      return;
    }

    uint64_t v5 = objc_autoreleasePoolPush();
    if (qword_100219F60) {
      [qword_100219F60 WFLog:@"%s: softErrorManagerService callback is NULL!" message:3];
    }
  }

  else
  {
    uint64_t v5 = objc_autoreleasePoolPush();
    if (qword_100219F60) {
      [qword_100219F60 WFLog:@"%s: deviceManagerRef is NULL!"];
    }
  }

  objc_autoreleasePoolPop(v5);
}

void sub_1000C6A78(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  if (a3)
  {
    if (a4)
    {
      CFNumberRef v4 = *(void (**)(uint64_t, uint64_t, uint64_t, void))(a3 + 4544);
      if (v4)
      {
        v4(a3, 4LL, a4, *(void *)(a3 + 4552));
        return;
      }

      uint64_t v5 = objc_autoreleasePoolPush();
      if (qword_100219F60) {
        [qword_100219F60 WFLog:@"%s: softErrorManagerService callback is NULL!" message:3];
      }
    }

    else
    {
      uint64_t v5 = objc_autoreleasePoolPush();
      if (qword_100219F60) {
        [qword_100219F60 WFLog:@"%s: txFailHistoryData is NULL!"];
      }
    }
  }

  else
  {
    uint64_t v5 = objc_autoreleasePoolPush();
    if (qword_100219F60) {
      [qword_100219F60 WFLog:@"%s: deviceManagerRef is NULL!"];
    }
  }

  objc_autoreleasePoolPop(v5);
}

void sub_1000C6B64(uint64_t a1, const void *a2, uint64_t a3, const __CFDictionary *a4)
{
  int valuePtr = 0;
  if (!a3)
  {
    BOOL v43 = objc_autoreleasePoolPush();
    if (qword_100219F60) {
      [qword_100219F60 WFLog:@"%s: deviceManagerRef is NULL!"];
    }
    goto LABEL_60;
  }

  if (!a1)
  {
    BOOL v43 = objc_autoreleasePoolPush();
    if (qword_100219F60) {
      [qword_100219F60 WFLog:@"%s: device is NULL!"];
    }
LABEL_60:
    objc_autoreleasePoolPop(v43);
    return;
  }

  __int128 v8 = (CFDictionaryRef *)sub_100052664(a1);
  if (!a4)
  {
    BOOL v44 = objc_autoreleasePoolPush();
    if (qword_100219F60) {
      [qword_100219F60 WFLog:@"dict is NULL!"];
    }
    objc_autoreleasePoolPop(v44);
    CFMutableArrayRef v33 = 0LL;
    uint64_t v13 = 0LL;
    goto LABEL_70;
  }

  CFBooleanRef Value = (const __CFNumber *)CFDictionaryGetValue(a4, @"ROAMEDEVENT_STATUS");
  if (!Value
    || ((CFNumberGetValue(Value, kCFNumberSInt32Type, &valuePtr), int v10 = 0, (valuePtr + 528350197) > 0x3E)
     || ((1LL << (valuePtr - 11)) & 0x73C0000000000017LL) == 0)
    && valuePtr != -528350204)
  {
    int v10 = 1;
  }

  int v11 = CFDictionaryGetValue(a4, @"ROAMEDEVENT_ORIGIN_ADDR");
  uint64_t v12 = sub_1000DEA34(a3, a2, 1);
  if (v12)
  {
    uint64_t v13 = v12;
    int v50 = v10;
    int v49 = v11;
    sub_100052728(*(void *)(a3 + 64), (uint64_t)v12);
    uint64_t context = objc_autoreleasePoolPush();
    if (sub_1000511F0(*(void *)(a3 + 64)))
    {
      uint64_t v14 = (void *)CFDictionaryGetValue(a4, @"ROAM_STATUS_SUBSTATE_INFO");
      if (v14)
      {
        id v15 = v14;
        id v16 = [v14 objectForKey:@"ROAM_STATUS_SUBSTATE_FLAGS"];
        if (v16)
        {
          if ([v16 intValue])
          {
            id v17 = [v15 objectForKey:@"BSSID"];
            if (v17)
            {
              double v18 = v17;
              __int16 v54 = 0;
              int v53 = 0;
              uint64_t v19 = [v17 bytes];
              if (v53 != *(_DWORD *)v19 || v54 != v19[2])
              {
                uint64_t v21 = ether_ntoa((const ether_addr *)[v18 bytes]);
                uint64_t v22 = v21
                    ? +[NSString stringWithUTF8String:](&OBJC_CLASS___NSString, "stringWithUTF8String:", v21)
                    : 0LL;
                double v23 = sub_10010A36C(v15, (uint64_t)v22);
                if (v23)
                {
                  uint64_t v24 = v23;
                  if (-[NSMutableArray count](v23, "count"))
                  {
                    int v48 = v8;
                    double v25 = sub_100094E60((uint64_t)kCFAllocatorDefault, (uint64_t)v13);
                    sub_10009582C((uint64_t)v25, @"BSSID", v22);
                    int v47 = v25;
                    id v26 = sub_1000A335C((uint64_t)v25);
                    if (-[NSMutableArray count](v24, "count"))
                    {
                      unint64_t v27 = 0LL;
                      do
                      {
                        id v28 = sub_1000D1BDC( a3,  8LL,  (uint64_t)-[NSMutableArray objectAtIndex:](v24, "objectAtIndex:", v27),  (uint64_t)v22,  2LL);
                        [*(id *)(a3 + 6632) setNetworkDenyListInfo:v28 forScanResult:v26];

                        ++v27;
                      }

                      while (v27 < (unint64_t)-[NSMutableArray count](v24, "count"));
                    }

                    double v29 = *(void **)(a3 + 7320);
                    if (v29) {
                      [v29 addFaultEvent:9 forInterface:sub_100043E8C(*(void *)(a3 + 64))];
                    }
                    __int128 v8 = v48;
                    if (v47) {
                      CFRelease(v47);
                    }
                  }
                }
              }
            }
          }
        }
      }

      else
      {
        uint64_t v45 = objc_autoreleasePoolPush();
        if (qword_100219F60) {
          [qword_100219F60 WFLog:@"dict for roam status is nil" message:4];
        }
        objc_autoreleasePoolPop(v45);
      }
    }

    objc_autoreleasePoolPop(context);
    if (sub_100053CFC(a1))
    {
      id v30 = +[WiFiRoamManager sharedWiFiRoamManager](&OBJC_CLASS___WiFiRoamManager, "sharedWiFiRoamManager");
      int v31 = v50;
      if (!v30)
      {
        uint64_t v46 = objc_autoreleasePoolPush();
        if (qword_100219F60) {
          [qword_100219F60 WFLog:@"%s, roamManager is NULL" message:4];
        }
        objc_autoreleasePoolPop(v46);
        CFMutableArrayRef v33 = 0LL;
        goto LABEL_70;
      }

      BOOL v32 = v30;
      if (v50) {
        CFMutableArrayRef v33 = sub_10004DCC4(*(void *)(a3 + 64));
      }
      else {
        CFMutableArrayRef v33 = 0LL;
      }
      [v32 setRoamStatus:a4 withBeaconCache:v33 forInterface:a2];
    }

    else
    {
      CFMutableArrayRef v33 = 0LL;
      int v31 = v50;
    }

    sub_1001002A4(a3, v13, a4);
LABEL_41:
    BOOL v34 = *(void (**)(uint64_t, uint64_t, void, void))(a3 + 4544);
    if (v34)
    {
      v34(a3, 11LL, 0LL, *(void *)(a3 + 4552));
    }

    else
    {
      uint64_t v35 = objc_autoreleasePoolPush();
      if (qword_100219F60) {
        [qword_100219F60 WFLog:@"%s: softErrorManagerService callback is NULL!"];
      }
      objc_autoreleasePoolPop(v35);
    }

    uint64_t v36 = *(void (**)(uint64_t, void, const __CFDictionary *))(a3 + 4624);
    if (v36) {
      v36(a3, *(void *)(a3 + 4632), a4);
    }
    int v37 = valuePtr;
    if (!valuePtr)
    {
      uint64_t v38 = *(dispatch_source_s **)(a3 + 8920);
      dispatch_time_t v39 = dispatch_time(0LL, 1000000000LL);
      dispatch_source_set_timer(v38, v39, 0xFFFFFFFFFFFFFFFFLL, 0LL);
      int v37 = valuePtr;
    }

    if (v8 && v37 && ((v31 ^ 1) & 1) == 0)
    {
      if (!v33) {
        CFMutableArrayRef v33 = sub_10004DCC4(*(void *)(a3 + 64));
      }
      id v40 = sub_1000A335C((uint64_t)v8);
      id v41 = [v40 scanResultWithMatchingKnownNetworkProfile:sub_1000A063C(v8)];
      id v42 = objc_msgSend( (id)CWFKnownNetworksSupportingSeamlessSSIDTransitionForScanResult( v41,  objc_msgSend(objc_msgSend(*(id *)(a3 + 8776), "knownNetworks"), "allObjects"),  1),  "valueForKey:",  @"SSID");
      -[WiFiUsageMonitor updateKnownNetworksSupportingSeamless:forBSS:andSSID:beaconCache:]( +[WiFiUsageMonitor sharedInstance](&OBJC_CLASS___WiFiUsageMonitor, "sharedInstance"),  "updateKnownNetworksSupportingSeamless:forBSS:andSSID:beaconCache:",  v42,  v49,  sub_100095BC8(v13),  v33);
      goto LABEL_71;
    }

void sub_1000C715C(uint64_t a1, const void *a2, uint64_t a3, const __CFDictionary *a4)
{
  CFTypeID v7 = objc_autoreleasePoolPush();
  if (!a3)
  {
    int v51 = objc_autoreleasePoolPush();
    if (qword_100219F60) {
      [qword_100219F60 WFLog:@"%s: deviceManagerRef is NULL!"];
    }
    goto LABEL_74;
  }

  __int128 v8 = sub_1000DEA34(a3, a2, 1);
  if (!v8)
  {
    int v51 = objc_autoreleasePoolPush();
    if (qword_100219F60) {
      [qword_100219F60 WFLog:@"%s: currentNetwork is NULL!"];
    }
LABEL_74:
    objc_autoreleasePoolPop(v51);
    goto LABEL_68;
  }

  CFStringRef v9 = v8;
  int v10 = (unsigned __int8 *)malloc(0x38uLL);
  if (!v10)
  {
    int v52 = objc_autoreleasePoolPush();
    if (qword_100219F60) {
      [qword_100219F60 WFLog:@"%s: null afMetric" message:3];
    }
    objc_autoreleasePoolPop(v52);
    goto LABEL_67;
  }

  int v11 = v10;
  *((void *)v10 + 6) = 0LL;
  *((_OWORD *)v10 + 1) = 0u;
  *((_OWORD *)v10 + 2) = 0u;
  *(_OWORD *)int v10 = 0u;
  uint64_t v12 = objc_autoreleasePoolPush();
  if (qword_100219F60) {
    [(id)qword_100219F60 WFLog:3, "%s: received action frame event for network %@: %@", "__WiFiDeviceManagerActionFrameEventCallback", sub_100095BC8(v9), a4 message];
  }
  objc_autoreleasePoolPop(v12);
  uint64_t v13 = sub_100096968((const __CFArray *)v9);
  if (!v13)
  {
LABEL_12:
    buffer[0] = 0;
    double v18 = kCFAllocatorDefault;
    id v17 = buffer;
    CFIndex v19 = 1LL;
    goto LABEL_13;
  }

  uint64_t v14 = (const __CFString *)v13;
  CFTypeID v15 = CFGetTypeID(v13);
  if (v15 != CFStringGetTypeID())
  {
    CFTypeID v20 = CFGetTypeID(v14);
    if (v20 == CFDataGetTypeID())
    {
      CFRetain(v14);
LABEL_14:
      v54.location = 0LL;
      v54.length = 3LL;
      CFDataGetBytes((CFDataRef)v14, v54, v11);
      CFRelease(v14);
      goto LABEL_15;
    }

    goto LABEL_12;
  }

  memset(buffer, 170, 19);
  CFStringGetCString(v14, buffer, 19LL, 0);
  id v16 = ether_aton(buffer);
  if (!v16) {
    goto LABEL_15;
  }
  id v17 = (char *)v16;
  double v18 = kCFAllocatorDefault;
  CFIndex v19 = 6LL;
LABEL_13:
  uint64_t v14 = (const __CFString *)CFDataCreate(v18, (const UInt8 *)v17, v19);
  if (v14) {
    goto LABEL_14;
  }
LABEL_15:
  CFBooleanRef Value = (const __CFNumber *)CFDictionaryGetValue(a4, @"CATEGORY_CODE");
  if (Value) {
    CFNumberGetValue(Value, kCFNumberSInt8Type, v11 + 8);
  }
  uint64_t v22 = (const __CFNumber *)CFDictionaryGetValue(a4, @"ACTION_CODE");
  if (v22) {
    CFNumberGetValue(v22, kCFNumberSInt8Type, v11 + 9);
  }
  double v23 = (const __CFNumber *)CFDictionaryGetValue(a4, @"DIALOG_TOKEN");
  if (v23) {
    CFNumberGetValue(v23, kCFNumberSInt8Type, v11 + 10);
  }
  uint64_t v24 = (const __CFNumber *)CFDictionaryGetValue(a4, @"PREF_CANDIDATE_INCLUDED");
  if (v24) {
    CFNumberGetValue(v24, kCFNumberSInt8Type, v11 + 18);
  }
  double v25 = (const __CFNumber *)CFDictionaryGetValue(a4, @"ABRIDGED");
  if (v25) {
    CFNumberGetValue(v25, kCFNumberSInt8Type, v11 + 19);
  }
  id v26 = (const __CFNumber *)CFDictionaryGetValue(a4, @"DISASSOC_IMMINENT");
  if (v26) {
    CFNumberGetValue(v26, kCFNumberSInt8Type, v11 + 20);
  }
  unint64_t v27 = (const __CFNumber *)CFDictionaryGetValue(a4, @"BSS_TERM_INCLUDED");
  if (v27) {
    CFNumberGetValue(v27, kCFNumberSInt8Type, v11 + 21);
  }
  id v28 = (const __CFNumber *)CFDictionaryGetValue(a4, @"ESS_TERM_INCLUDED");
  if (v28) {
    CFNumberGetValue(v28, kCFNumberSInt8Type, v11 + 22);
  }
  double v29 = (const __CFNumber *)CFDictionaryGetValue(a4, @"DISASSOC_TIMEOUT");
  if (v29) {
    CFNumberGetValue(v29, kCFNumberSInt16Type, v11 + 14);
  }
  id v30 = (const __CFNumber *)CFDictionaryGetValue(a4, @"VALIDITY_INTERVAL");
  if (v30) {
    CFNumberGetValue(v30, kCFNumberSInt8Type, v11 + 16);
  }
  int v31 = (const __CFNumber *)CFDictionaryGetValue(a4, @"BTM_RSP_STATUS");
  if (v31) {
    CFNumberGetValue(v31, kCFNumberSInt8Type, v11 + 11);
  }
  BOOL v32 = (const __CFNumber *)CFDictionaryGetValue(a4, @"BSS_TERM_DELAY");
  if (v32) {
    CFNumberGetValue(v32, kCFNumberSInt8Type, v11 + 17);
  }
  *((_DWORD *)v11 + 1) = sub_1000FDC1C(a3, v9);
  CFMutableArrayRef v33 = (const __CFNumber *)sub_100096A74((uint64_t)v9);
  if (v33) {
    CFNumberGetValue(v33, kCFNumberSInt32Type, v11 + 24);
  }
  BOOL v34 = (const __CFNumber *)sub_10009A36C((uint64_t)v9);
  if (v34) {
    CFNumberGetValue(v34, kCFNumberSInt32Type, v11 + 36);
  }
  *((_DWORD *)v11 + 7) = sub_10009A3FC((uint64_t)v9);
  *((_DWORD *)v11 + _Block_object_dispose((const void *)(v1 - 136), 8) = sub_10009A3DC((uint64_t)v9);
  uint64_t v35 = (const __CFDictionary *)sub_1000951FC((uint64_t)v9, @"WPS_PROB_RESP_IE");
  if (v35)
  {
    uint64_t v36 = v35;
    int v37 = (const __CFString *)CFDictionaryGetValue(v35, @"IE_KEY_WPS_MODEL_NAME");
    if (v37 && (uint64_t v38 = v37, TypeID = CFStringGetTypeID(), TypeID == CFGetTypeID(v38)))
    {
      CFStringRef Copy = CFStringCreateCopy(kCFAllocatorDefault, v38);
    }

    else
    {
      id v41 = objc_autoreleasePoolPush();
      if (qword_100219F60) {
        [qword_100219F60 WFLog:@"%s: bad type for wpsModelName. Not a CFString or NULL" message:4];
      }
      objc_autoreleasePoolPop(v41);
      CFStringRef Copy = 0LL;
    }

    *((void *)v11 + 5) = Copy;
    id v42 = (const __CFString *)CFDictionaryGetValue(v36, @"IE_KEY_WPS_MODEL_NUM");
    if (v42 && (BOOL v43 = v42, v44 = CFStringGetTypeID(), v44 == CFGetTypeID(v43)))
    {
      CFStringRef v45 = CFStringCreateCopy(kCFAllocatorDefault, v43);
    }

    else
    {
      uint64_t v46 = objc_autoreleasePoolPush();
      if (qword_100219F60) {
        [qword_100219F60 WFLog:@"__WiFiDeviceManagerActionFrameEventCallback: bad type for wpsModelNumber. Not a CFString or NULL" message:4];
      }
      objc_autoreleasePoolPop(v46);
      CFStringRef v45 = 0LL;
    }

    *((void *)v11 + 6) = v45;
  }

  int v47 = *(void **)(a3 + 7320);
  if (v47)
  {
    int v48 = v11[9];
    if (v48 == 8)
    {
      [v47 sentBssTransitionResponse:a2 status:v11[11] terminationDelayRequested:v11[17] != 0];
    }

    else if (v48 == 7)
    {
      [v47 receivedBssTransitionRequest:a2 candidateListIncluded:v11[18] != 0 isAbridged:v11[19] != 0 disassociationImminent:v11[20] != 0 bssTerminationIncluded:v11[21] != 0 essD isassociationImminent:v11[22] != 0];
    }
  }

  sub_100030E80((uint64_t)v11);
  int v49 = (const void *)*((void *)v11 + 5);
  if (v49)
  {
    CFRelease(v49);
    *((void *)v11 + 5) = 0LL;
  }

  int v50 = (const void *)*((void *)v11 + 6);
  if (v50) {
    CFRelease(v50);
  }
  free(v11);
LABEL_67:
  CFRelease(v9);
LABEL_68:
  objc_autoreleasePoolPop(v7);
}

void sub_1000C7788(uint64_t a1, uint64_t a2, id *a3, __CFDictionary **a4)
{
  if (a3)
  {
    if (a4)
    {
      *a4 = sub_10010E0E0(a3);
      return;
    }

    CFNumberRef v4 = objc_autoreleasePoolPush();
    if (qword_100219F60) {
      [qword_100219F60 WFLog:@"%s: AJMetrics is NULL!"];
    }
  }

  else
  {
    CFNumberRef v4 = objc_autoreleasePoolPush();
    if (qword_100219F60) {
      [qword_100219F60 WFLog:@"%s: deviceManagerRef is NULL!"];
    }
  }

  objc_autoreleasePoolPop(v4);
}

void sub_1000C7838(uint64_t a1, uint64_t a2, uint64_t a3, CFMutableDictionaryRef *a4)
{
  if (!a3)
  {
    CFTypeID v7 = objc_autoreleasePoolPush();
    if (qword_100219F60) {
      [qword_100219F60 WFLog:@"%s: deviceManagerRef is NULL!"];
    }
    goto LABEL_11;
  }

  if (!a4)
  {
    CFTypeID v7 = objc_autoreleasePoolPush();
    if (qword_100219F60) {
      [qword_100219F60 WFLog:@"%s: LPHSMetrics is NULL!"];
    }
LABEL_11:
    objc_autoreleasePoolPop(v7);
    return;
  }

  uint64_t v5 = *(const __CFDictionary **)(a3 + 6984);
  if (v5) {
    MutableCFStringRef Copy = CFDictionaryCreateMutableCopy(kCFAllocatorDefault, 0LL, v5);
  }
  else {
    MutableCFStringRef Copy = 0LL;
  }
  *a4 = MutableCopy;
}

uint64_t sub_1000C7904(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5)
{
  uint64_t v5 = *(uint64_t (**)(uint64_t, uint64_t, void, uint64_t))(a5 + 4592);
  if (v5) {
    return v5(a5, a2, *(void *)(a5 + 4600), a3);
  }
  return result;
}

void sub_1000C7920(int a1, int a2, CFDictionaryRef theDict, uint64_t a4, uint64_t a5)
{
  CFBooleanRef Value = CFDictionaryGetValue(theDict, @"SOFTAP_LPM");
  if (Value)
  {
    CFTypeID v7 = Value;
    if (CFEqual(Value, kCFBooleanFalse))
    {
      IOPMAssertionID v8 = *(_DWORD *)(a5 + 5220);
      if (v8 && !IOPMAssertionRelease(v8))
      {
        CFStringRef v9 = objc_autoreleasePoolPush();
        if (qword_100219F60) {
          objc_msgSend( (id)qword_100219F60,  "WFLog:message:",  3,  "All Clients in Sleep/Inactive Mode, Releasing Power Assertion for SoftAP LPM\n");
        }
        objc_autoreleasePoolPop(v9);
        *(_DWORD *)(a5 + 5220) = 0;
      }
    }

    else if (CFEqual(v7, kCFBooleanTrue) && !*(_DWORD *)(a5 + 5220))
    {
      int v10 = (_DWORD *)(a5 + 5220);
      int v11 = sub_10004CE34();
      uint64_t v12 = IOPMAssertionCreateWithName(@"NoIdleSleepAssertion", 0xFFu, v11, (IOPMAssertionID *)(a5 + 5220));
      uint64_t v13 = objc_autoreleasePoolPush();
      if ((_DWORD)v12)
      {
        if (qword_100219F60) {
          [qword_100219F60 WFLog:@"Unable to prevent idle sleep during MIS Session, error=%d" message:4 v12];
        }
        objc_autoreleasePoolPop(v13);
        _DWORD *v10 = 0;
      }

      else
      {
        if (qword_100219F60) {
          objc_msgSend( (id)qword_100219F60,  "WFLog:message:",  3,  "Clients are in active mode, Holding Power Assertion for SoftAP LPM\n");
        }
        objc_autoreleasePoolPop(v13);
      }
    }
  }

void sub_1000C7A74(uint64_t a1, const void *a2, uint64_t a3)
{
  uint64_t v6 = objc_autoreleasePoolPush();
  id v7 = -[WiFiPerfPerAssoc getBSSIDForCurrentSession]( +[WiFiPerfPerAssoc sharedInstance](&OBJC_CLASS___WiFiPerfPerAssoc, "sharedInstance"),  "getBSSIDForCurrentSession");
  IOPMAssertionID v8 = sub_1000DEA34(a3, a2, 1);
  CFStringRef v9 = sub_1000951FC((uint64_t)v8, @"BSSID");
  int v10 = *(void **)(a3 + 3504);
  if (!v9)
  {
    id v16 = +[WiFiPerfPerAssoc sharedInstance](&OBJC_CLASS___WiFiPerfPerAssoc, "sharedInstance");
    uint64_t v17 = sub_100053B28(a1);
    double v18 = v16;
    uint64_t v19 = 0LL;
    CFTypeID v20 = v10;
    goto LABEL_25;
  }

  int v11 = v9;
  if (v8)
  {
    double v29 = v6;
    uint64_t context = objc_autoreleasePoolPush();
    CFDictionaryRef v12 = sub_100012CEC((uint64_t)v8);
    uint64_t v13 = -[NSMutableDictionary initWithDictionary:]( objc_alloc(&OBJC_CLASS___NSMutableDictionary),  "initWithDictionary:",  v12);
    uint64_t v14 = *(void *)(a3 + 64);
    if (v14)
    {
      *(_DWORD *)(a3 + 1200) = -1;
      bzero((void *)(a3 + 1204), 0x808uLL);
      int v15 = sub_100050DC8(v14, a3 + 1204);
      *(_DWORD *)(a3 + 1200) = v15;
      if (v15) {
        goto LABEL_10;
      }
    }

    else if (*(_DWORD *)(a3 + 1200))
    {
      goto LABEL_10;
    }

    if (*(_DWORD *)(a3 + 1204))
    {
      uint64_t v21 = +[NSData dataWithBytes:length:](&OBJC_CLASS___NSData, "dataWithBytes:length:", a3 + 1208);
LABEL_11:
      CFNumberRef v22 = CFNumberCreate(kCFAllocatorDefault, kCFNumberCharType, (const void *)(a3 + 3256));
      if (v22)
      {
        CFNumberRef v23 = v22;
        -[NSMutableDictionary setObject:forKeyedSubscript:]( v13,  "setObject:forKeyedSubscript:",  v22,  @"IS_BEACON_AT_HE_RATE");
        CFRelease(v23);
      }

      [*(id *)(a3 + 7320) updateBeaconInfo:v21 andParsedIE:v13 forInterface:sub_100043E8C(*(void *)(a3 + 64))];
      if (v12) {
        CFRelease(v12);
      }
      if (v13) {
        CFRelease(v13);
      }
      objc_autoreleasePoolPop(context);
      uint64_t v6 = v29;
      if (*(_DWORD *)(a3 + 1200))
      {
        uint64_t v24 = objc_autoreleasePoolPush();
        if (qword_100219F60) {
          [qword_100219F60 WFLog:@"%s unable to fetch RawBeacon (err:%d)" message:@"__WiFiDeviceFetchCurrentBeaconData" error:*(unsigned int *)(a3 + 1200)];
        }
        objc_autoreleasePoolPop(v24);
      }

      goto LABEL_21;
    }

void sub_1000C7D60(uint64_t a1, uint64_t a2, uint64_t a3)
{
  CFNumberRef v4 = *(void (**)(uint64_t, void))(a3 + 4864);
  if (v4) {
    v4(a3, *(void *)(a3 + 4872));
  }
}

void sub_1000C7DBC(uint64_t a1, const void *a2, const __CFDictionary *a3, uint64_t a4, uint64_t a5)
{
  __int16 valuePtr = 0;
  char v34 = 0;
  id v7 = (_BYTE *)(a5 + 5584);
  BOOL v32 = 0LL;
  value = 0LL;
  int v31 = 0LL;
  IOPMAssertionID v8 = sub_1000DEA34(a5, a2, 1);
  int ValueIfPresent = CFDictionaryGetValueIfPresent(a3, @"INTERNET_ACCESS", (const void **)&value);
  int v10 = value;
  if (ValueIfPresent) {
    BOOL v11 = value == 0LL;
  }
  else {
    BOOL v11 = 1;
  }
  if (!v11)
  {
    CFDictionaryRef v12 = *(const void **)(a5 + 5568);
    if (v12)
    {
      if (CFEqual(value, v12)) {
        goto LABEL_22;
      }
      int v10 = value;
    }

    *(void *)(a5 + 556_Block_object_dispose((const void *)(v1 - 136), 8) = v10;
    if (v8)
    {
      int v13 = sub_10009E120((uint64_t)v8);
      if ((v13 - 1) > 1)
      {
        uint64_t v17 = 0LL;
      }

      else
      {
        int v14 = v13;
        if (*(void *)(a5 + 5568))
        {
          int v15 = objc_autoreleasePoolPush();
          if (qword_100219F60)
          {
            if (*(const CFBooleanRef *)(a5 + 5568) == kCFBooleanTrue) {
              id v16 = "SET";
            }
            else {
              id v16 = "ZERO";
            }
            [qword_100219F60 WFLog:@"%s: internetAccess bit %s" message:3];
          }

          objc_autoreleasePoolPop(v15);
        }

        if (v14 == 1) {
          uint64_t v17 = 3LL;
        }
        else {
          uint64_t v17 = 0LL;
        }
      }

      sub_1000D36F4((void *)a5, v8, 1, v17);
    }
  }

void sub_1000C8170(uint64_t a1, uint64_t a2, int a3, uint64_t a4, uint64_t a5)
{
  id v10 = 0LL;
  id v7 = *(id *)(a5 + 9024);
  if (v7 || (id v7 = objc_alloc_init(&OBJC_CLASS___AWDLServiceDiscoveryManager), (*(void *)(a5 + 9024) = v7) != 0LL))
  {
    if (a3)
    {
      if (([v7 suspendAWDLWithError:&v10] & 1) == 0)
      {
        CFStringRef v9 = objc_autoreleasePoolPush();
        if (qword_100219F60) {
          [qword_100219F60 WFLog:3, @"SUSPEND AWDL for interface %@ FAILED, returned %ld", a2, [v10 code]];
        }
LABEL_11:
        objc_autoreleasePoolPop(v9);
      }
    }

    else if (([v7 resumeAWDLWithError:&v10] & 1) == 0)
    {
      CFStringRef v9 = objc_autoreleasePoolPush();
      if (qword_100219F60) {
        [qword_100219F60 WFLog:@"RESUME AWDL for interface %@ FAILED, returned %ld" code:[v10 code]];
      }
      goto LABEL_11;
    }
  }

void sub_1000C8250(uint64_t a1, const void *a2, uint64_t a3, const __CFDictionary *a4)
{
  if (a3)
  {
    value = 0LL;
    uint64_t v8 = sub_100111848((_BYTE *)a3);
    else {
      BOOL v9 = v8 == 0;
    }
    int v10 = !v9;
    BOOL v11 = objc_autoreleasePoolPush();
    if (qword_100219F60)
    {
      CFDictionaryRef v12 = "FALSE";
      if (v10) {
        CFDictionaryRef v12 = "TRUE";
      }
      [qword_100219F60 WFLog:@"DPS: latencySensitiveApps_bitmap:%llu isCriticalAppState:%s" message:3 v8 v12];
    }

    objc_autoreleasePoolPop(v11);
    int v13 = sub_1000DEA34(a3, a2, 1);
    if (v13)
    {
      int v14 = v13;
      if (sub_1000A5B5C((uint64_t)v13))
      {
        unsigned int v15 = 0;
        if (!CFBooleanGetValue((CFBooleanRef)value))
        {
          unsigned int v15 = 0;
LABEL_20:
          sub_10003387C(a1, a4, v15, v10);
          double Current = CFAbsoluteTimeGetCurrent();
          double v17 = *(double *)(a3 + 7048);
          if (v17 == 0.0 || v17 + 120.0 <= Current)
          {
            *(_DWORD *)(a3 + 7184) = v15;
            double v18 = objc_autoreleasePoolPush();
            if (qword_100219F60) {
              [(id)qword_100219F60 WFLog:3 message:"DPS/DNS Symptoms HUD: starting display"];
            }
            objc_autoreleasePoolPop(v18);
            uint64_t v19 = objc_autoreleasePoolPush();
            if (*(_DWORD *)(a3 + 7184))
            {
              *(void *)(a3 + 7176) = 0LL;
              CFTypeID v20 = +[NSString stringWithFormat:]( &OBJC_CLASS___NSString,  "stringWithFormat:",  @"DNS Stall: %llus",  0LL);
            }

            else
            {
              *(void *)(a3 + 7176) = 5LL;
              CFTypeID v20 = +[NSString stringWithFormat:]( &OBJC_CLASS___NSString,  "stringWithFormat:",  @"Data Stall: %llus",  5LL);
            }

            uint64_t v21 = v20;
            if (!*(_BYTE *)(a3 + 7189))
            {
              *(_BYTE *)(a3 + 7189) = 1;
              if (MGGetBoolAnswer(@"InternalBuild"))
              {
                CFNumberRef v22 = *(void (**)(uint64_t, uint64_t, NSString *, void))(a3 + 4544);
                if (v22) {
                  v22(a3, 18LL, v21, *(void *)(a3 + 4552));
                }
              }

              CFNumberRef v23 = *(dispatch_source_s **)(a3 + 7168);
              dispatch_time_t v24 = dispatch_time(0LL, 1000000000LL);
              dispatch_source_set_timer(v23, v24, 0xFFFFFFFFFFFFFFFFLL, 0LL);
            }

            objc_autoreleasePoolPop(v19);
            sub_10001DC80(*(void *)(a3 + 120), 1);
          }

          sub_1000DE0D0(a3, 0, 0LL);
          goto LABEL_34;
        }

        if (!*(_BYTE *)(a3 + 5488))
        {
          unsigned int v15 = 4;
          goto LABEL_20;
        }

        dispatch_time_t v26 = objc_autoreleasePoolPush();
        if (qword_100219F60) {
          objc_msgSend( (id)qword_100219F60,  "WFLog:message:",  4,  "%s: DNSSymptoms notification not allowed when Carplay is Active",  "__WiFiDeviceManagerHandleDpsEvent",  v27);
        }
      }

      else
      {
        dispatch_time_t v26 = objc_autoreleasePoolPush();
        if (qword_100219F60) {
          [(id)qword_100219F60 WFLog:4, "%s: network='%@' doesn't support DPS recovery", "__WiFiDeviceManagerHandleDpsEvent", v14 message];
        }
      }

      objc_autoreleasePoolPop(v26);
LABEL_34:
      CFRelease(v14);
      return;
    }

    double v25 = objc_autoreleasePoolPush();
    if (qword_100219F60) {
      [qword_100219F60 WFLog:@"__WiFiDeviceManagerHandleDpsEvent, curNetwork is NULL"];
    }
    objc_autoreleasePoolPop(v25);
  }

void sub_1000C8564(uint64_t a1, const void *a2, uint64_t a3, const __CFDictionary *a4)
{
  id v7 = objc_autoreleasePoolPush();
  uint64_t valuePtr = 0LL;
  double Current = CFAbsoluteTimeGetCurrent();
  if (!a3)
  {
    dispatch_time_t v39 = objc_autoreleasePoolPush();
    if (qword_100219F60) {
      [qword_100219F60 WFLog:@"Device Manager is NULL" message:4 "%s, Device Manager is NULL" "__WiFiDeviceManagerHandleSlowWiFiEvent"];
    }
    goto LABEL_65;
  }

  if (!a2)
  {
    dispatch_time_t v39 = objc_autoreleasePoolPush();
    if (qword_100219F60) {
      [qword_100219F60 WFLog:@"%s, Device IfName is NULL" message:4];
    }
    goto LABEL_65;
  }

  double v9 = Current;
  CFBooleanRef Value = CFDictionaryGetValue(a4, @"SLOWWIFI_IS_BAP_AP");
  if (!Value)
  {
    dispatch_time_t v39 = objc_autoreleasePoolPush();
    if (qword_100219F60) {
      [qword_100219F60 WFLog:@"%s, isBadAP key not found" message:4];
    }
    goto LABEL_65;
  }

  BOOL v11 = Value;
  CFDictionaryRef v12 = (const __CFNumber *)CFDictionaryGetValue(a4, @"SLOWWIFI_ACTION_REASON");
  CFNumberGetValue(v12, kCFNumberIntType, (char *)&valuePtr + 4);
  int v13 = (const __CFNumber *)CFDictionaryGetValue(a4, @"SLOWWIFI_ACTION_STAGE");
  CFNumberGetValue(v13, kCFNumberIntType, &valuePtr);
  if (!CFEqual(v11, kCFBooleanFalse))
  {
    id v16 = *(void **)(a3 + 7320);
    if (v16) {
      [v16 addFaultEvent:10 forInterface:sub_100043E8C(*(void *)(a3 + 64))];
    }
    double v17 = CFDictionaryGetValue(a4, @"SLOWWIFI_RECOVERY_ENABLED");
    if (v17)
    {
      if (CFEqual(v17, kCFBooleanTrue))
      {
        if (v12)
        {
          double v18 = sub_1000DEA34(a3, a2, 1);
          if (v18)
          {
            unsigned int v15 = v18;
            uint64_t v19 = sub_1000951FC((uint64_t)v18, @"BSSID");
            if (v19)
            {
              CFTypeID v20 = v19;
              uint64_t v21 = CFDictionaryGetValue(a4, @"SLOWWIFI_BSSID");
              if (v21)
              {
                uint64_t v22 = (uint64_t)v21;
                if (CFEqual(v20, v21))
                {
                  CFNumberRef v23 = sub_100094E60((uint64_t)kCFAllocatorDefault, (uint64_t)v15);
                  id v24 = sub_1000A335C((uint64_t)v23);
                  BOOL v25 = sub_1000A5B5C((uint64_t)v23);
                  dispatch_time_t v26 = objc_autoreleasePoolPush();
                  if (v25)
                  {
                    if (qword_100219F60) {
                      [(id)qword_100219F60 WFLog:4, "%s: SlowWiFi detection blacklisted BSSID:%@", "__WiFiDeviceManagerHandleSlowWiFiEvent", v22 message];
                    }
                    objc_autoreleasePoolPop(v26);
                    id v27 = sub_1000D1BDC(a3, 8LL, SHIDWORD(valuePtr), v22, 2LL);
                    [*(id *)(a3 + 6632) setNetworkDenyListInfo:v27 forScanResult:v24];
                    [*(id *)(a3 + 6632) setNetworkDenyListInfo:v27 forScanResult:v24];
                    [*(id *)(a3 + 6632) setNetworkDenyListInfo:v27 forScanResult:v24];

                    if (!v23) {
                      goto LABEL_23;
                    }
                  }

                  else
                  {
                    if (qword_100219F60) {
                      [qword_100219F60 WFLog:@"%s, network does not support slow wifi recovery" message:3, 1];
                    }
                    objc_autoreleasePoolPop(v26);
                    if (!v23) {
                      goto LABEL_23;
                    }
                  }

                  CFRelease(v23);
LABEL_23:

                  goto LABEL_24;
                }

                id v40 = objc_autoreleasePoolPush();
                if (qword_100219F60) {
                  [qword_100219F60 WFLog:@"%s, event BSSID not equal to current BSSID" message:4];
                }
              }

              else
              {
                id v40 = objc_autoreleasePoolPush();
                if (qword_100219F60) {
                  [qword_100219F60 WFLog:@"__WiFiDeviceManagerHandleSlowWiFiEvent, event BSSID is NULL"];
                }
              }
            }

            else
            {
              id v40 = objc_autoreleasePoolPush();
              if (qword_100219F60) {
                [qword_100219F60 WFLog:@"%s, current BSSID is NULL" message:4];
              }
            }

            objc_autoreleasePoolPop(v40);
            goto LABEL_34;
          }

          dispatch_time_t v39 = objc_autoreleasePoolPush();
          if (qword_100219F60) {
            [qword_100219F60 WFLog:@"%s, curNetwork is NULL" message:4];
          }
        }

        else
        {
          dispatch_time_t v39 = objc_autoreleasePoolPush();
          if (qword_100219F60) {
            [qword_100219F60 WFLog:@"SlowWiFi reason not found"];
          }
        }
      }

      else
      {
        dispatch_time_t v39 = objc_autoreleasePoolPush();
        if (qword_100219F60) {
          [qword_100219F60 WFLog:@"SlowWiFi recovery not enabled" message:4];
        }
      }
    }

    else
    {
      dispatch_time_t v39 = objc_autoreleasePoolPush();
      if (qword_100219F60) {
        [qword_100219F60 WFLog:@"%s, isRecoveryEnabled key not found" message:4];
      }
    }

LABEL_65:
    objc_autoreleasePoolPop(v39);
    goto LABEL_35;
  }

  int v14 = objc_autoreleasePoolPush();
  if (qword_100219F60) {
    [qword_100219F60 WFLog:@"SlowWiFiEvent not due to AP"];
  }
  objc_autoreleasePoolPop(v14);
  unsigned int v15 = *(void **)(a3 + 7320);
  if (v15)
  {
    [v15 addFaultEvent:19 forInterface:sub_100043E8C(*(void *)(a3 + 64))];
    unsigned int v15 = 0LL;
  }

void sub_1000C8BDC(uint64_t a1, uint64_t a2, uint64_t a3)
{
  else {
    sub_1000F2110(a3, -1);
  }
}

void sub_1000C8C04(uint64_t a1, const void *a2, uint64_t a3, void *a4)
{
  uint64_t v8 = objc_autoreleasePoolPush();
  if (!a3)
  {
    double v17 = objc_autoreleasePoolPush();
    if (qword_100219F60) {
      [qword_100219F60 WFLog:@"%s manager is NULL" message:4];
    }
    goto LABEL_22;
  }

  if (!a4)
  {
    double v17 = objc_autoreleasePoolPush();
    if (qword_100219F60) {
      [qword_100219F60 WFLog:@"dict is NULL" message:4];
    }
    goto LABEL_22;
  }

  if (!sub_1000511F0(a1))
  {
    double v17 = objc_autoreleasePoolPush();
    if (qword_100219F60) {
      [qword_100219F60 WFLog:@"%s Pruned event received when BssBlacklisting is not supported! Bailing" message:4];
    }
    goto LABEL_22;
  }

  id v9 = [a4 objectForKey:@"PRUNEEVENT_REASON"];
  id v10 = [a4 objectForKey:@"BSSID"];
  if (!v10) {
    goto LABEL_13;
  }
  if (!v9) {
    goto LABEL_13;
  }
  BOOL v11 = v10;
  CFDictionaryRef v12 = sub_100040538(a1, a2);
  if (!v12)
  {
    double v17 = objc_autoreleasePoolPush();
    if (qword_100219F60) {
      [qword_100219F60 WFLog:@"message: %s Current network is NULL. Not handling the BSS pruned event" message:@"__WiFiDeviceManagerHandleBssPrunedEvent"];
    }
LABEL_22:
    objc_autoreleasePoolPop(v17);
    goto LABEL_13;
  }

  int v13 = v12;
  int v14 = (NSString *)ether_ntoa((const ether_addr *)[v11 bytes]);
  if (v14) {
    int v14 = +[NSString stringWithUTF8String:](&OBJC_CLASS___NSString, "stringWithUTF8String:", v14);
  }
  sub_10009582C((uint64_t)v13, @"BSSID", v14);
  id v15 = sub_1000A335C((uint64_t)v13);
  if (v15)
  {
    id v16 = v15;
    [*(id *)(a3 + 6632) processDenyListedBSSForMetrics:v15];
    CFRelease(v16);
  }

  else
  {
    double v18 = objc_autoreleasePoolPush();
    if (qword_100219F60) {
      [qword_100219F60 WFLog:@"message: %s Current network is NULL. Not handling the BSS pruned event" message:@"__WiFiDeviceManagerHandleBssPrunedEvent"];
    }
    objc_autoreleasePoolPop(v18);
  }

  CFRelease(v13);
LABEL_13:
  objc_autoreleasePoolPop(v8);
}

void sub_1000C8E30(uint64_t a1, uint64_t a2, uint64_t a3, void *a4)
{
  if (!a3)
  {
    id v7 = objc_autoreleasePoolPush();
    if (qword_100219F60) {
      [qword_100219F60 WFLog:@"__WiFiDeviceManagerHandleTrafficInfoEvent" message:@"%s manager is NULL"];
    }
    uint64_t v8 = v7;
    goto LABEL_12;
  }

  uint64_t v6 = objc_autoreleasePoolPush();
  if (!a4)
  {
    if (qword_100219F60) {
      [qword_100219F60 WFLog:@"dict is NULL" message:4];
    }
    uint64_t v8 = v6;
LABEL_12:
    objc_autoreleasePoolPop(v8);
    return;
  }

  if (qword_100219F60) {
    [(id)qword_100219F60 WFLog:3, "Traffic Info Event Dictionary %@", a4 message];
  }
  objc_autoreleasePoolPop(v6);
  sub_10001FEF8( *(void *)(a3 + 120),  objc_msgSend(objc_msgSend(a4, "objectForKey:", @"CRITICAL_TRAFFIC_STATE"), "intValue") | (objc_msgSend(objc_msgSend(a4, "objectForKey:", @"NON_CRITICAL_TRAFFIC_STATE"), "intValue") << 8));
}

uint64_t sub_1000C8F60(uint64_t a1, uint64_t a2, uint64_t *a3, uint64_t a4)
{
  uint64_t result = a3[506];
  if (result)
  {
    uint64_t v8 = (uint64_t (*)(uint64_t *, uint64_t, uint64_t, void, uint64_t))a3[506];
    uint64_t v7 = sub_100043E8C(a3[8]);
    return v8(a3, v7, a4, 0LL, a3[507]);
  }

  return result;
}

void sub_1000C8FC4(uint64_t a1, uint64_t a2, uint64_t a3)
{
  if (a3)
  {
    CFNumberRef v4 = *(const __CFString **)(a3 + 7304);
    if (v4) {
      BOOL v5 = CFStringGetLength(v4) != 0;
    }
    else {
      BOOL v5 = 0LL;
    }
    uint64_t v6 = objc_autoreleasePoolPush();
    if (qword_100219F60) {
      [qword_100219F60 WFLog:@"%s: countryCodeDidBecomeAvailable=%d __WiFiDeviceManagerGetMISGlobalState=%d manager->mis.misEnabled=%d manager->softapUserPreferredBand=%d manager->mis.misChannel=%d" message:3, "__WiFiDeviceManagerProcessSupportedChannelInfoChangedEvent", v5, 0, *(unsigned __int8 *)(a3 + 5211), *(unsigned int *)(a3 + 7000), *(unsigned __int8 *)(a3 + 5208)];
    }
  }

  else
  {
    uint64_t v6 = objc_autoreleasePoolPush();
    if (qword_100219F60) {
      [qword_100219F60 WFLog:@"%s: null manager" message:4 v7, v8, v9, v10, v11];
    }
  }

  objc_autoreleasePoolPop(v6);
}

uint64_t sub_1000C9098(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  if (a4)
  {
    CFNumberRef v4 = *(uint64_t (**)(uint64_t, uint64_t, uint64_t, void))(a4 + 4816);
    if (v4) {
      return v4(a4, a2, a3, *(void *)(a4 + 4040));
    }
  }

  return result;
}

uint64_t sub_1000C90B8(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  if (a4)
  {
    CFNumberRef v4 = *(uint64_t (**)(uint64_t, uint64_t, uint64_t, void))(a4 + 4848);
    if (v4) {
      return v4(a4, a2, a3, *(void *)(a4 + 4040));
    }
  }

  return result;
}

void sub_1000C90D8(uint64_t a1, uint64_t a2, __int128 *a3, uint64_t a4)
{
  if (a4)
  {
    *(void *)(a4 + 3809) = 0LL;
    *(_OWORD *)(a4 + 3780) = 0u;
    *(_OWORD *)(a4 + 3796) = 0u;
    if (a3)
    {
      __int128 v4 = *a3;
      __int128 v5 = a3[1];
      *(void *)(a4 + 3809) = *(void *)((char *)a3 + 29);
      *(_OWORD *)(a4 + 3780) = v4;
      *(_OWORD *)(a4 + 3796) = v5;
    }

    sub_1000D3350(a4);
  }

uint64_t sub_1000C910C(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6)
{
  if (a6) {
    return (*(uint64_t (**)(uint64_t, uint64_t, uint64_t, uint64_t, uint64_t, void))(a6 + 4912))( a6,  a2,  a3,  a4,  a5,  *(void *)(a6 + 4920));
  }
  return result;
}

void sub_1000C9128(uint64_t a1, uint64_t a2, uint64_t a3, const void *a4, CFTypeRef *a5)
{
  if (!a3)
  {
    id v24 = objc_autoreleasePoolPush();
    if (qword_100219F60) {
      [qword_100219F60 WFLog:@"%s: manager is NULL!" message:3];
    }
    goto LABEL_32;
  }

  if (!a4)
  {
    id v24 = objc_autoreleasePoolPush();
    if (qword_100219F60) {
      [qword_100219F60 WFLog:@"%s: inNetwork is NULL!"];
    }
    goto LABEL_32;
  }

  if (!a5)
  {
    id v24 = objc_autoreleasePoolPush();
    if (qword_100219F60) {
      [qword_100219F60 WFLog:@"%s: outAccount is NULL!"];
    }
LABEL_32:
    objc_autoreleasePoolPop(v24);
    return;
  }

  *a5 = 0LL;
  uint64_t v7 = *(const __CFArray **)(a3 + 3616);
  if (v7)
  {
    CFIndex Count = CFArrayGetCount(*(CFArrayRef *)(a3 + 3616));
    v25.location = 0LL;
    v25.length = Count;
    FirstIndexOfCFBooleanRef Value = CFArrayGetFirstIndexOfValue(v7, v25, a4);
    if (FirstIndexOfValue != -1)
    {
      CFIndex v10 = FirstIndexOfValue;
      ValueAtIndex = (void *)CFArrayGetValueAtIndex(v7, FirstIndexOfValue);
      CFDictionaryRef v12 = sub_1000951FC((uint64_t)a4, @"HS20AccountName");
      int v13 = sub_1000951FC((uint64_t)ValueAtIndex, @"HS20AccountName");
      if (!v12 && v13 && sub_100099E30(ValueAtIndex))
      {
        int v14 = objc_autoreleasePoolPush();
        if (qword_100219F60) {
          [(id)qword_100219F60 WFLog:3, "%s: immediately matched HS2.0 account %@, returning %@", "__WiFiDeviceManagerRequestForNextMatchingHS20AccountCallback", sub_100095BC8(ValueAtIndex), ValueAtIndex message];
        }
        objc_autoreleasePoolPop(v14);
        id v15 = ValueAtIndex;
        goto LABEL_24;
      }

      CFIndex v16 = v10 + 1;
      if (v10 + 1 < Count)
      {
        do
        {
          double v17 = (void *)CFArrayGetValueAtIndex(v7, v16);
          if (v17)
          {
            double v18 = v17;
            if (sub_100099588((uint64_t)a4, (uint64_t)v17))
            {
              int v19 = sub_100099E30(v18);
              CFTypeID v20 = objc_autoreleasePoolPush();
              uint64_t v21 = (void *)qword_100219F60;
              if (v19)
              {
                if (qword_100219F60)
                {
                  CFNumberRef v23 = sub_100095BC8(v18);
                  [v21 WFLog:3, "%s: found HS2.0 account %@ matching %@, returning %@", "__WiFiDeviceManagerRequestForNextMatchingHS20AccountCallback", v23, sub_100095BC8(a4), v18 message];
                }

                objc_autoreleasePoolPop(v20);
                id v15 = v18;
LABEL_24:
                *a5 = CFRetain(v15);
                return;
              }

              if (qword_100219F60)
              {
                uint64_t v22 = sub_100095BC8(v18);
                [v21 WFLog:3, "%s: next HS2.0 account %@ matching %@ has no credentials, skipping", "__WiFiDeviceManagerRequestForNextMatchingHS20AccountCallback", v22, sub_100095BC8(a4) message];
              }

              objc_autoreleasePoolPop(v20);
            }
          }

          ++v16;
        }

        while (Count != v16);
      }
    }
  }

void sub_1000C9400(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, const __CFDictionary *a5)
{
  unsigned __int8 valuePtr = 0;
  if (a2)
  {
    uint64_t v8 = objc_autoreleasePoolPush();
    if (a5)
    {
      if (qword_100219F60) {
        [(id)qword_100219F60 WFLog:3, "%s:Notification %@ received", "__WiFiDeviceManagerRoamNotificationCallback", a3 message];
      }
      objc_autoreleasePoolPop(v8);
      CFBooleanRef Value = (const __CFNumber *)CFDictionaryGetValue(a5, @"com.apple.wifid.wifiroammangerroamtype");
      uint64_t v8 = objc_autoreleasePoolPush();
      if (Value)
      {
        if (qword_100219F60) {
          [(id)qword_100219F60 WFLog:3, "%s: kWiFiRoamManagerRoamTypeKey value is %@", "__WiFiDeviceManagerRoamNotificationCallback", Value message];
        }
        int v26 = -1431655766;
        objc_autoreleasePoolPop(v8);
        CFNumberGetValue(Value, kCFNumberCharType, &valuePtr);
        CFIndex v10 = (const __CFNumber *)CFDictionaryGetValue(a5, @"com.apple.wifid.wifiroammangerroamreason");
        uint64_t v11 = objc_autoreleasePoolPush();
        if (v10)
        {
          if (qword_100219F60) {
            [(id)qword_100219F60 WFLog:3, "%s: kWiFiRoamManagerRoamReasonKey value is %@", "__WiFiDeviceManagerRoamNotificationCallback", v10 message];
          }
          objc_autoreleasePoolPop(v11);
          CFNumberGetValue(v10, kCFNumberIntType, &v26);
          if (valuePtr >= 3u)
          {
            int v19 = objc_autoreleasePoolPush();
            if (qword_100219F60) {
              [qword_100219F60 WFLog:@"Invalid band preference" message:4];
            }
          }

          else
          {
            CFMutableDictionaryRef Mutable = CFDictionaryCreateMutable( kCFAllocatorDefault,  0LL,  &kCFTypeDictionaryKeyCallBacks,  &kCFTypeDictionaryValueCallBacks);
            if (Mutable)
            {
              int v13 = Mutable;
              __int16 v25 = -1;
              *(_DWORD *)bytes = -1;
              CFDataRef v14 = CFDataCreate(kCFAllocatorDefault, bytes, 6LL);
              if (v14)
              {
                CFDataRef v15 = v14;
                CFDictionaryAddValue(v13, @"BSSID", v14);
                CFNumberRef v16 = CFNumberCreate(0LL, kCFNumberCharType, &valuePtr);
                if (v16)
                {
                  CFNumberRef v17 = v16;
                  CFDictionaryAddValue(v13, @"BAND_PREFERENCE", v16);
                  CFRelease(v17);
                  double v18 = objc_autoreleasePoolPush();
                  if (qword_100219F60) {
                    [(id)qword_100219F60 WFLog:3, "%s:calling DeviceSetRoam with :%@", "__WiFiDeviceManagerRoamNotificationCallback", v13 message];
                  }
                  objc_autoreleasePoolPop(v18);
                  sub_10005341C(*(void *)(a2 + 64), (uint64_t)v13);
                }

                else
                {
                  CFNumberRef v23 = objc_autoreleasePoolPush();
                  if (qword_100219F60) {
                    [qword_100219F60 WFLog:@"%s: numRef is NULL" message:4];
                  }
                  objc_autoreleasePoolPop(v23);
                }

                CFRelease(v15);
              }

              else
              {
                uint64_t v22 = objc_autoreleasePoolPush();
                if (qword_100219F60) {
                  [qword_100219F60 WFLog:@"%s: bssidDataRef is NULL" message:4];
                }
                objc_autoreleasePoolPop(v22);
              }

              CFRelease(v13);
              return;
            }

            int v19 = objc_autoreleasePoolPush();
            if (qword_100219F60) {
              [qword_100219F60 WFLog:@"__WiFiDeviceManagerRoamNotificationCallback: bssidInfo is NULL"];
            }
          }

          CFTypeID v20 = v19;
        }

        else
        {
          if (qword_100219F60) {
            [qword_100219F60 WFLog:@"__WiFiDeviceManagerRoamNotificationCallback: numRef for kWiFiRoamManagerRoamReason is NULL"];
          }
          CFTypeID v20 = v11;
        }

        objc_autoreleasePoolPop(v20);
        return;
      }

      if (qword_100219F60) {
        [qword_100219F60 WFLog:@"%s: numRef for kWiFiRoamManagerRoamType is NULL" message:4];
      }
    }

    else if (qword_100219F60)
    {
      [qword_100219F60 WFLog:@"%s: userInfo is NULL" message:4];
    }

    objc_autoreleasePoolPop(v8);
    return;
  }

  uint64_t v21 = objc_autoreleasePoolPush();
  if (qword_100219F60) {
    [qword_100219F60 WFLog:@"__WiFiDeviceManagerRoamNotificationCallback: manager is NULL"];
  }
  objc_autoreleasePoolPop(v21);
}

void sub_1000C9788(uint64_t a1, uint64_t a2, uint64_t a3, int a4, int a5)
{
  if (a3)
  {
    sub_1000D9790(a3, a4, a5);
  }

  else
  {
    __int128 v5 = objc_autoreleasePoolPush();
    if (qword_100219F60) {
      [qword_100219F60 WFLog:@"%s: null manager" message:4];
    }
    objc_autoreleasePoolPop(v5);
  }

void sub_1000C97F4(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  if (a4)
  {
    __int128 v4 = *(void **)(a4 + 7320);
    if (v4) {
      [v4 updateScanForwardStats:];
    }
  }

void sub_1000C9808(uint64_t a1, uint64_t a2)
{
  if (a2)
  {
    sub_1000C553C(a2, @"TriggerWatchdog");
    *(_BYTE *)(a2 + 3489) = 1;
  }

  else
  {
    CFNumberRef v3 = objc_autoreleasePoolPush();
    if (qword_100219F60) {
      [qword_100219F60 WFLog:@"__WiFiDeviceManagerChipResetRequestedCallback: manager is NULL"];
    }
    objc_autoreleasePoolPop(v3);
  }

void sub_1000C9890(uint64_t a1)
{
  if (a1)
  {
    int v2 = (unsigned __int8 *)(a1 + 5209);
    char v3 = *(_BYTE *)(a1 + 5209);
    char v4 = *(_BYTE *)(a1 + 5210);
    uint64_t v5 = *(unsigned __int8 *)(a1 + 5213);
    if (*(_DWORD *)(a1 + 5224) == 5)
    {
      CFSetRemoveValue(*(CFMutableSetRef *)(a1 + 5264), @"wifid");
      sub_1000DCD9C(a1, 0);
      uint64_t v6 = *(const __CFSet **)(a1 + 5264);
      if (!v6 || !CFSetGetCount(v6))
      {
        uint64_t v7 = *(const __CFSet **)(a1 + 5272);
        if (!v7 || !CFSetGetCount(v7))
        {
          uint64_t v8 = objc_autoreleasePoolPush();
          if (qword_100219F60) {
            [(id)qword_100219F60 WFLog:3 message:"No Discovery Client"];
          }
          objc_autoreleasePoolPop(v8);
          uint64_t v5 = 0LL;
          v2[4] = 0;
        }
      }
    }

    if (*(void *)(a1 + 4128))
    {
      sub_1000DCD9C(a1, 0);
      (*(void (**)(uint64_t, void, uint64_t))(a1 + 4128))(a1, *(void *)(a1 + 4136), v5);
    }

    unsigned __int8 v9 = v4 + v3;
    CFIndex v10 = objc_autoreleasePoolPush();
    if (qword_100219F60)
    {
      uint64_t v11 = "Enabled";
      if (v2[2]) {
        CFDictionaryRef v12 = "Enabled";
      }
      else {
        CFDictionaryRef v12 = "Disabled";
      }
      if (!(_DWORD)v5) {
        uint64_t v11 = "Disabled";
      }
      [qword_100219F60 WFLog:message:3, @"MIS idle timer expired. MIS is %s, associated clients = %d, nan associated clients = %d, discovery is %s", v12, v9, v2[1], v11];
    }

    objc_autoreleasePoolPop(v10);
    BOOL v16 = (~v2[1800] & 5) == 0
       && ((int v13 = *(const __CFSet **)(a1 + 5280)) == 0LL || !CFSetGetCount(v13))
       && ((CFDataRef v14 = *(const __CFSet **)(a1 + 5296)) == 0LL || !CFSetGetCount(v14))
       && ((CFDataRef v15 = *(const __CFSet **)(a1 + 5304)) == 0LL || !CFSetGetCount(v15))
       && *(_DWORD *)(a1 + 5224) == 4;
    if (v2[5]) {
      goto LABEL_28;
    }
    if (v2[2])
    {
      BOOL v19 = !v16;
      if (!v9) {
        BOOL v19 = 0;
      }
      if (!v19 && !(_DWORD)v5)
      {
LABEL_28:
        CFNumberRef v17 = objc_autoreleasePoolPush();
        if (qword_100219F60) {
          [qword_100219F60 WFLog:@"MIS idle timer expired (inRecovery: %d) (Concurrent Mode: %d), disabling tethering" message:3 v2[5] v16];
        }
        objc_autoreleasePoolPop(v17);
        uint64_t v21 = 0LL;
        memset(v20, 0, sizeof(v20));
        DWORD2(v20[0]) = 2;
        sub_1000DC1AC(a1, (uint64_t)v20);
        sub_1000DC604(a1);
      }
    }

    *(_DWORD *)(a1 + 5224) = 0;
  }

  else
  {
    double v18 = objc_autoreleasePoolPush();
    if (qword_100219F60) {
      [qword_100219F60 WFLog:@"%s: manager is NULL" message:4];
    }
    objc_autoreleasePoolPop(v18);
  }

void sub_1000C9B28(uint64_t a1)
{
  int v2 = *(dispatch_source_s **)(a1 + 5312);
  CFAbsoluteTime Current = CFAbsoluteTimeGetCurrent();
  dispatch_time_t v4 = dispatch_time(0LL, (uint64_t)((Current + 315360000.0) * 1000000000.0));
  dispatch_source_set_timer(v2, v4, 0xFFFFFFFFFFFFFFFFLL, 0LL);
  uint64_t v5 = objc_autoreleasePoolPush();
  if (qword_100219F60) {
    [qword_100219F60 WFLog:@"%s: Timer Expired\n" message:3];
  }
  objc_autoreleasePoolPop(v5);
  sub_1000DD0A4(a1);
}

void sub_1000C9BCC(uint64_t a1)
{
  int v2 = objc_autoreleasePoolPush();
  if (qword_100219F60) {
    [qword_100219F60 WFLog:@"%s: timeout - resetting critical phase state" message:3];
  }
  objc_autoreleasePoolPop(v2);
  *(_BYTE *)(a1 + 5496) = 0;
}

void sub_1000C9C34(uint64_t a1)
{
  int v2 = objc_autoreleasePoolPush();
  if (qword_100219F60) {
    [qword_100219F60 WFLog:@"%s: timeout - calling __WiFiDeviceManagerEvaluate24GHzInfraNetworkState" message:3];
  }
  objc_autoreleasePoolPop(v2);
  sub_1000EB060(a1, 0LL);
  *(_BYTE *)(a1 + 8552) = 0;
}

uint64_t sub_1000C9CA8(uint64_t a1)
{
  int v2 = objc_autoreleasePoolPush();
  if (qword_100219F60) {
    [qword_100219F60 WFLog:@"CarPlay HID session timed out"];
  }
  objc_autoreleasePoolPop(v2);
  uint64_t result = sub_100050E48(*(void *)(a1 + 64), 1);
  *(_BYTE *)(a1 + 8592) = 0;
  return result;
}

void sub_1000C9D1C(uint64_t a1)
{
  int v2 = objc_autoreleasePoolPush();
  if (qword_100219F60) {
    [qword_100219F60 WFLog:@"__WiFiDeviceManagerCarPlayLinkDownMonitorTimerCallback: timed out"];
  }
  objc_autoreleasePoolPop(v2);
  uint64_t v3 = *(void *)(a1 + 968);
  if (v3)
  {
    sub_1000FE674(a1, v3, 1021, 0);
    dispatch_time_t v4 = *(const void **)(a1 + 968);
    if (v4)
    {
      CFRelease(v4);
      *(void *)(a1 + 96_Block_object_dispose((const void *)(v1 - 136), 8) = 0LL;
    }
  }

void sub_1000C9DA4(uint64_t a1)
{
  __int128 v79 = 0uLL;
  int v2 = malloc(0x400uLL);
  if (v2)
  {
    uint64_t v3 = v2;
    uint64_t v4 = *(void *)(a1 + 64);
    uint64_t v5 = (const __CFString *)sub_100043E8C(v4);
    uint64_t v6 = sub_100044AD4(v4, v5, "dump", "lpc", 0, v3, 0x400u);
    if (!(_DWORD)v6)
    {
      v3[1023] = 0;
      uint64_t v7 =  -[NSString initWithCString:encoding:]( objc_alloc(&OBJC_CLASS___NSString),  "initWithCString:encoding:",  v3,  4LL);
      if (!v7)
      {
        CFTypeID v20 = objc_autoreleasePoolPush();
        if (qword_100219F60) {
          objc_msgSend( (id)qword_100219F60,  "WFLog:message:",  4,  "%s: failed to alloc string",  "__WiFiDeviceManagerGetLPCStats",  v52,  v53,  v54,  v55,  v56,  v57,  v58);
        }
        goto LABEL_19;
      }

      uint64_t v8 = v7;
      unsigned __int8 v9 = +[NSRegularExpression regularExpressionWithPattern:options:error:]( &OBJC_CLASS___NSRegularExpression,  "regularExpressionWithPattern:options:error:",  @"valid (\\d)",  0LL,  0LL);
      uint64_t v10 = 0LL;
      if (v9)
      {
        uint64_t v11 = -[NSRegularExpression matchesInString:options:range:]( v9,  "matchesInString:options:range:",  v8,  0LL,  0LL,  -[NSString length](v8, "length"));
        __int128 v71 = 0u;
        __int128 v72 = 0u;
        __int128 v73 = 0u;
        __int128 v74 = 0u;
        id v12 = -[NSArray countByEnumeratingWithState:objects:count:]( v11,  "countByEnumeratingWithState:objects:count:",  &v71,  v78,  16LL);
        if (v12)
        {
          id v13 = v12;
          char v14 = 0;
          uint64_t v15 = *(void *)v72;
          do
          {
            for (CFIndex i = 0LL; i != v13; CFIndex i = (char *)i + 1)
            {
              if (*(void *)v72 != v15) {
                objc_enumerationMutation(v11);
              }
              id v17 = [*(id *)(*((void *)&v71 + 1) + 8 * (void)i) rangeAtIndex:1];
              if (-[NSString isEqualToString:]( -[NSString substringWithRange:](v8, "substringWithRange:", v17, v18),  "isEqualToString:",  @"1"))
              {
                char v14 = 1;
              }
            }

            id v13 = -[NSArray countByEnumeratingWithState:objects:count:]( v11,  "countByEnumeratingWithState:objects:count:",  &v71,  v78,  16LL);
          }

          while (v13);
          if ((v14 & 1) != 0)
          {
            uint64_t v21 = +[NSRegularExpression regularExpressionWithPattern:options:error:]( &OBJC_CLASS___NSRegularExpression,  "regularExpressionWithPattern:options:error:",  @"min_offset -(\\d+.\\d)dB",  0LL,  0LL);
            uint64_t v10 = 0LL;
            if (v21)
            {
              uint64_t v22 = -[NSRegularExpression matchesInString:options:range:]( v21,  "matchesInString:options:range:",  v8,  0LL,  0LL,  -[NSString length](v8, "length"));
              __int128 v67 = 0u;
              __int128 v68 = 0u;
              __int128 v69 = 0u;
              __int128 v70 = 0u;
              id v23 = -[NSArray countByEnumeratingWithState:objects:count:]( v22,  "countByEnumeratingWithState:objects:count:",  &v67,  v77,  16LL);
              if (v23)
              {
                id v24 = v23;
                uint64_t v25 = *(void *)v68;
                do
                {
                  for (CFIndex j = 0LL; j != v24; CFIndex j = (char *)j + 1)
                  {
                    if (*(void *)v68 != v25) {
                      objc_enumerationMutation(v22);
                    }
                    id v27 = [*(id *)(*((void *)&v67 + 1) + 8 * (void)j) rangeAtIndex:1];
                    -[NSString doubleValue]( -[NSString substringWithRange:](v8, "substringWithRange:", v27, v28),  "doubleValue");
                  }

                  uint64_t v10 = v29;
                  id v24 = -[NSArray countByEnumeratingWithState:objects:count:]( v22,  "countByEnumeratingWithState:objects:count:",  &v67,  v77,  16LL);
                }

                while (v24);
              }
            }

            unsigned __int8 v9 = +[NSRegularExpression regularExpressionWithPattern:options:error:]( &OBJC_CLASS___NSRegularExpression,  "regularExpressionWithPattern:options:error:",  @"Rates\\W+TX\\s+:(\\s+\\d+\\(\\d+%\\)){3}\\s+(\\d+)\\(\\d+%\\)",  0LL,  0LL);
            if (v9)
            {
              int v30 = -[NSRegularExpression matchesInString:options:range:]( v9,  "matchesInString:options:range:",  v8,  0LL,  0LL,  -[NSString length](v8, "length"));
              __int128 v63 = 0u;
              __int128 v64 = 0u;
              __int128 v65 = 0u;
              __int128 v66 = 0u;
              id v31 = -[NSArray countByEnumeratingWithState:objects:count:]( v30,  "countByEnumeratingWithState:objects:count:",  &v63,  v76,  16LL);
              if (v31)
              {
                id v32 = v31;
                uint64_t v33 = *(void *)v64;
                do
                {
                  for (CFIndex k = 0LL; k != v32; CFIndex k = (char *)k + 1)
                  {
                    if (*(void *)v64 != v33) {
                      objc_enumerationMutation(v30);
                    }
                    id v35 = [*(id *)(*((void *)&v63 + 1) + 8 * (void)k) rangeAtIndex:2];
                    int v37 = -[NSString longLongValue]( -[NSString substringWithRange:](v8, "substringWithRange:", v35, v36),  "longLongValue");
                  }

                  unsigned __int8 v9 = v37;
                  id v32 = -[NSArray countByEnumeratingWithState:objects:count:]( v30,  "countByEnumeratingWithState:objects:count:",  &v63,  v76,  16LL);
                }

                while (v32);
              }

              else
              {
                unsigned __int8 v9 = 0LL;
              }
            }

            dispatch_time_t v38 = +[NSRegularExpression regularExpressionWithPattern:options:error:]( &OBJC_CLASS___NSRegularExpression,  "regularExpressionWithPattern:options:error:",  @"Offsets\\W+TX\\s+:\\s+\\d+\\((\\d+)%\\)\\s+\\d+\\((\\d+)%\\)\\s+\\d+\\((\\d+)%\\)\\s+\\d+\\((\\d+)%\\)",  0LL,  0LL);
            if (v38)
            {
              dispatch_time_t v39 = -[NSRegularExpression matchesInString:options:range:]( v38,  "matchesInString:options:range:",  v8,  0LL,  0LL,  -[NSString length](v8, "length"));
              __int128 v59 = 0u;
              __int128 v60 = 0u;
              __int128 v61 = 0u;
              __int128 v62 = 0u;
              id v40 = -[NSArray countByEnumeratingWithState:objects:count:]( v39,  "countByEnumeratingWithState:objects:count:",  &v59,  v75,  16LL);
              if (v40)
              {
                id v41 = v40;
                uint64_t v42 = *(void *)v60;
                do
                {
                  for (m = 0LL; m != v41; m = (char *)m + 1)
                  {
                    if (*(void *)v60 != v42) {
                      objc_enumerationMutation(v39);
                    }
                    uint64_t v44 = 0LL;
                    CFStringRef v45 = *(void **)(*((void *)&v59 + 1) + 8LL * (void)m);
                    do
                    {
                      id v46 = [v45 rangeAtIndex:v44 + 1];
                      *((_DWORD *)&v79 + v44++) = -[NSString integerValue]( -[NSString substringWithRange:]( v8,  "substringWithRange:",  v46,  v47),  "integerValue");
                    }

                    while (v44 != 4);
                  }

                  id v41 = -[NSArray countByEnumeratingWithState:objects:count:]( v39,  "countByEnumeratingWithState:objects:count:",  &v59,  v75,  16LL);
                }

                while (v41);
              }
            }

            *(_BYTE *)(a1 + 1000) = 1;
            *(void *)(a1 + 100_Block_object_dispose((const void *)(v1 - 136), 8) = v10;
            *(_OWORD *)(a1 + 1016) = v79;
            *(void *)(a1 + 1032) = v9;
            BOOL v19 = "yes";
            goto LABEL_17;
          }
        }

        unsigned __int8 v9 = 0LL;
      }

      BOOL v19 = "no";
LABEL_17:
      CFTypeID v20 = objc_autoreleasePoolPush();
      if (qword_100219F60) {
        [qword_100219F60 WFLog:@"%s: is LPC valid ? %s, min_offset -%.1f dB, topMcsTxCount %llu (AMPDU), txOffset %d:%d:%d:%d (%%)" message:3 v19 v10 v9 v79 DWORD1(v79) DWORD2(v79) HIDWORD(v79)];
      }
LABEL_19:
      objc_autoreleasePoolPop(v20);
      free(v3);
      return;
    }

    uint64_t v49 = v6;
    int v50 = objc_autoreleasePoolPush();
    if (qword_100219F60) {
      [qword_100219F60 WFLog:@"%s: failed to get LPC stats" message:4];
    }
    objc_autoreleasePoolPop(v50);
    free(v3);
  }

  else
  {
    int v48 = objc_autoreleasePoolPush();
    if (qword_100219F60) {
      [qword_100219F60 WFLog:@"%s: failed to alloc buf" message:4];
    }
    objc_autoreleasePoolPop(v48);
    uint64_t v49 = 4294963395LL;
  }

  int v51 = objc_autoreleasePoolPush();
  if (qword_100219F60) {
    objc_msgSend((id)qword_100219F60, "WFLog:message:", 4, "%s: error %d", "__WiFiDeviceManagerGetLPCStats", v49);
  }
  objc_autoreleasePoolPop(v51);
}

void sub_1000CA414(uint64_t a1)
{
  int v2 = objc_autoreleasePoolPush();
  if (qword_100219F60) {
    [qword_100219F60 WFLog:@"__WiFiDeviceManagerAssocStateTimerCallback: Assoc timeout timer fired, triggering CoreCapture"];
  }
  objc_autoreleasePoolPop(v2);
  sub_1000EE564(a1);
}

void sub_1000CA478(uint64_t a1)
{
  int v2 = *(_DWORD *)(a1 + 3272);
  uint64_t v3 = objc_autoreleasePoolPush();
  if (v2 == 16)
  {
    if (qword_100219F60)
    {
      uint64_t v4 = +[NSString stringWithFormat:]( &OBJC_CLASS___NSString,  "stringWithFormat:",  @"%s",  -[NSString UTF8String]( +[NSString stringWithFormat:]( &OBJC_CLASS___NSString,  "stringWithFormat:",  @"{%@+} %@",  @"AUTOJOIN",  +[NSString stringWithFormat:]( &OBJC_CLASS___NSString,  "stringWithFormat:",  @"Scanning for Hotspot Devices Timeout")),  "UTF8String"));
      if (os_log_type_enabled((os_log_t)&_os_log_default, OS_LOG_TYPE_DEFAULT))
      {
        *(_DWORD *)__int128 buf = 136446210;
        uint64_t v7 = -[NSString UTF8String]( +[NSString stringWithFormat:]( &OBJC_CLASS___NSString,  "stringWithFormat:",  @"[WiFiPolicy] %s",  -[NSString UTF8String](v4, "UTF8String")),  "UTF8String");
        _os_log_impl( (void *)&_mh_execute_header,  (os_log_t)&_os_log_default,  OS_LOG_TYPE_DEFAULT,  "%{public}s",  buf,  0xCu);
      }
    }

    objc_autoreleasePoolPop(v3);
    if (_os_feature_enabled_impl("CoreWiFi", "UnifiedAutoJoin"))
    {
      uint64_t v5 = *(void *)(a1 + 8816);
      if (v5)
      {
        (*(void (**)(uint64_t, NSError *, void))(v5 + 16))( v5,  +[NSError errorWithDomain:code:userInfo:]( &OBJC_CLASS___NSError,  "errorWithDomain:code:userInfo:",  NSPOSIXErrorDomain,  60LL,  0LL),  0LL);
        _Block_release(*(const void **)(a1 + 8816));
        *(void *)(a1 + 8816) = 0LL;
      }
    }

    if (*(_DWORD *)(a1 + 3272) == 16) {
      sub_1000CABEC(a1, 0);
    }
    *(_DWORD *)(a1 + 3272) = sub_1000F17B8(a1);
    *(void *)(a1 + 6824) = 0LL;
  }

  else
  {
    if (qword_100219F60) {
      [(id)qword_100219F60 WFLog:3, "%s: Scanning Hotspot Device timeout in state %@.", "__WiFiDeviceManagerScanHotspotDeviceTimeoutCallback", sub_1000BDC98(*(_DWORD *)(a1 + 3272)) message];
    }
    objc_autoreleasePoolPop(v3);
  }

CFAbsoluteTime sub_1000CA6A4(uint64_t a1)
{
  uint64_t v2 = *(void *)(a1 + 64);
  uint64_t v3 = (const void *)sub_100043E8C(v2);
  uint64_t v4 = sub_100040538(v2, v3);
  if (v4)
  {
    uint64_t v5 = v4;
    if (sub_100097700((uint64_t)v4))
    {
      uint64_t v6 = objc_autoreleasePoolPush();
      if (qword_100219F60) {
        [qword_100219F60 WFLog:@"Device in Lock state over an 60 minutes. Disconnect from Hotspot!!"];
      }
      objc_autoreleasePoolPop(v6);
      uint64_t v7 = (const void *)sub_100043E8C(*(void *)(a1 + 64));
      sub_1000CE074(a1, v7, 1019LL, "__WiFiDeviceManagerAutoHotspotLockStateTimeoutCallback", 36585LL);
    }

    uint64_t v8 = *(dispatch_source_s **)(a1 + 6768);
    dispatch_time_t v9 = dispatch_time(0LL, 315360000000000000LL);
    dispatch_source_set_timer(v8, v9, 0xFFFFFFFFFFFFFFFFLL, 0LL);
    *(CFAbsoluteTime *)(a1 + 6776) = CFAbsoluteTimeGetCurrent() + 315360000.0;
    CFRelease(v5);
  }

  else
  {
    uint64_t v11 = *(dispatch_source_s **)(a1 + 6768);
    dispatch_time_t v12 = dispatch_time(0LL, 315360000000000000LL);
    dispatch_source_set_timer(v11, v12, 0xFFFFFFFFFFFFFFFFLL, 0LL);
    CFAbsoluteTime result = CFAbsoluteTimeGetCurrent() + 315360000.0;
    *(CFAbsoluteTime *)(a1 + 6776) = result;
  }

  return result;
}

void sub_1000CA7F0(uint64_t a1, char a2, dispatch_queue_s **cf)
{
  if (cf)
  {
    if (cf[30])
    {
      CFRetain(cf);
      uint64_t v6 = cf[30];
      block[0] = _NSConcreteStackBlock;
      block[1] = 3221225472LL;
      block[2] = sub_1000CA8FC;
      block[3] = &unk_1001E4AE8;
      uint64_t v7 = *(void *)(a1 + 32);
      void block[4] = cf;
      void block[5] = v7;
      char v10 = a2;
      dispatch_async(v6, block);
      return;
    }

    uint64_t v8 = objc_autoreleasePoolPush();
    if (qword_100219F60) {
      [qword_100219F60 WFLog:@"%s: null queue." message:@"WiFiDeviceManagerCreate_block_invoke_2"];
    }
  }

  else
  {
    uint64_t v8 = objc_autoreleasePoolPush();
    if (qword_100219F60) {
      [qword_100219F60 WFLog:@"%s: null deviceManager" message:3];
    }
  }

  objc_autoreleasePoolPop(v8);
}

void sub_1000CA8FC(uint64_t a1)
{
  uint64_t v2 = *(void **)(a1 + 32);
  if (v2[30])
  {
    uint64_t v3 = *(void *)(a1 + 40);
    uint64_t v4 = *(unsigned int *)(v3 + 3272);
    dispatch_source_set_timer(*(dispatch_source_t *)(v3 + 6760), 0xFFFFFFFFFFFFFFFFLL, 0xFFFFFFFFFFFFFFFFLL, 0LL);
    uint64_t v5 = objc_autoreleasePoolPush();
    if (qword_100219F60)
    {
      if (*(_BYTE *)(a1 + 48)) {
        uint64_t v6 = "found";
      }
      else {
        uint64_t v6 = "not found";
      }
      [qword_100219F60 WFLog:@"%s: hotspot networks %s" message:3,  "WiFiDeviceManagerCreate_block_invoke_3",  v6];
    }

    objc_autoreleasePoolPop(v5);
    if (*(_BYTE *)(a1 + 48))
    {
      id v7 = [*(id *)(*(void *)(a1 + 40) + 6728) copySortedHotspotDevicesByAutoPreferences];
      uint64_t v8 = objc_autoreleasePoolPush();
      if (qword_100219F60) {
        [(id)qword_100219F60 WFLog:3, "%s: sorted hotspot device list %@", "WiFiDeviceManagerCreate_block_invoke_3", v7 message];
      }
      objc_autoreleasePoolPop(v8);
      __int128 v18 = 0u;
      __int128 v19 = 0u;
      __int128 v16 = 0u;
      __int128 v17 = 0u;
      id v9 = [v7 countByEnumeratingWithState:&v16 objects:v20 count:16];
      if (v9)
      {
        id v10 = v9;
        uint64_t v11 = *(void *)v17;
        do
        {
          for (CFIndex i = 0LL; i != v10; CFIndex i = (char *)i + 1)
          {
            if (*(void *)v17 != v11) {
              objc_enumerationMutation(v7);
            }
            CFArrayAppendValue( *(CFMutableArrayRef *)(*(void *)(a1 + 40) + 6792LL),  *(const void **)(*((void *)&v16 + 1) + 8LL * (void)i));
          }

          id v10 = [v7 countByEnumeratingWithState:&v16 objects:v20 count:16];
        }

        while (v10);
      }

      *(CFAbsoluteTime *)(*(void *)(a1 + 40) + 680kdebug_trace(731381764LL, 0LL, 0LL, 0LL, 0LL) = CFAbsoluteTimeGetCurrent();
    }

    else
    {
      id v7 = 0LL;
    }

    if (_os_feature_enabled_impl("CoreWiFi", "UnifiedAutoJoin"))
    {
      uint64_t v13 = *(void *)(*(void *)(a1 + 40) + 8816LL);
      if (v13)
      {
        (*(void (**)(uint64_t, void, id))(v13 + 16))(v13, 0LL, v7);
        _Block_release(*(const void **)(*(void *)(a1 + 40) + 8816LL));
        *(void *)(*(void *)(a1 + 40) + 8816LL) = 0LL;
      }
    }

    if ((v4 - 20) > 0xFFFFFFFB)
    {
      if (sub_1000CAC54(*(void *)(a1 + 40)))
      {
        sub_1000CACC4(*(void *)(a1 + 40));
      }

      else
      {
        uint64_t v15 = objc_autoreleasePoolPush();
        if (qword_100219F60) {
          [qword_100219F60 WFLog:@"Auto hotspot attempt canceled because user auto join is disabled."];
        }
        objc_autoreleasePoolPop(v15);
      }
    }

    else
    {
      char v14 = objc_autoreleasePoolPush();
      if (qword_100219F60) {
        [qword_100219F60 WFLog:@"%s: Received Update Hotspot Devices in state %d" message:3 v4];
      }
      objc_autoreleasePoolPop(v14);
      sub_1000CABEC(*(void *)(a1 + 40), 0);
    }

    CFRelease(*(CFTypeRef *)(a1 + 32));
  }

  else
  {
    CFRelease(v2);
  }

uint64_t sub_1000CABE4(uint64_t a1)
{
  return *(unsigned int *)(a1 + 3272);
}

CFAbsoluteTime sub_1000CABEC(uint64_t a1, int a2)
{
  uint64_t v3 = *(void **)(a1 + 6728);
  if (a2)
  {
    [v3 startBrowsing];
    CFAbsoluteTime result = CFAbsoluteTimeGetCurrent();
    *(CFAbsoluteTime *)(a1 + 6912) = result;
    ++*(_DWORD *)(a1 + 6164);
  }

  else if ([v3 isScanning])
  {
    [*(id *)(a1 + 6728) stopBrowsing];
    CFAbsoluteTime result = *(double *)(a1 + 6168) + CFAbsoluteTimeGetCurrent() - *(double *)(a1 + 6912);
    *(CFAbsoluteTime *)(a1 + 616_Block_object_dispose((const void *)(v1 - 136), 8) = result;
  }

  return result;
}

uint64_t sub_1000CAC54(uint64_t a1)
{
  if (a1) {
    return *(unsigned __int8 *)(a1 + 6272);
  }
  uint64_t v2 = objc_autoreleasePoolPush();
  if (qword_100219F60) {
    [qword_100219F60 WFLog:@"%s: null device manager" message:4];
  }
  objc_autoreleasePoolPop(v2);
  return 0LL;
}

void sub_1000CACC4(uint64_t a1)
{
  uint64_t v2 = objc_autoreleasePoolPush();
  uint64_t v3 = (void **)&qword_100219F60;
  if (qword_100219F60)
  {
    uint64_t v4 = +[NSString stringWithFormat:]( &OBJC_CLASS___NSString,  "stringWithFormat:",  @"%s",  -[NSString UTF8String]( +[NSString stringWithFormat:]( &OBJC_CLASS___NSString,  "stringWithFormat:",  @"{%@+} %@",  @"AUTOJOIN",  +[NSString stringWithFormat:]( &OBJC_CLASS___NSString,  "stringWithFormat:",  @"%s: current state: %@",  "__WiFiDeviceManagerStateMachineRun",  sub_1000BDC98(*(_DWORD *)(a1 + 3272)))),  "UTF8String"));
    if (os_log_type_enabled((os_log_t)&_os_log_default, OS_LOG_TYPE_DEFAULT))
    {
      *(_DWORD *)__int128 buf = 136446210;
      *(void *)&uint8_t buf[4] = -[NSString UTF8String]( +[NSString stringWithFormat:]( &OBJC_CLASS___NSString,  "stringWithFormat:",  @"[WiFiPolicy] %s",  -[NSString UTF8String](v4, "UTF8String")),  "UTF8String");
      _os_log_impl( (void *)&_mh_execute_header,  (os_log_t)&_os_log_default,  OS_LOG_TYPE_DEFAULT,  "%{public}s",  buf,  0xCu);
    }
  }

  objc_autoreleasePoolPop(v2);
  switch(*(_DWORD *)(a1 + 3272))
  {
    case 0:
    case 1:
      CFArrayRemoveAllValues(*(CFMutableArrayRef *)(a1 + 3552));
      CFArrayRemoveAllValues(*(CFMutableArrayRef *)(a1 + 3560));
      [*(id *)(a1 + 3648) clearScanResultsForAutoJoinSessionReset];
      uint64_t v49 = (const __CFString *)sub_10004CE2C(*(void *)(a1 + 64));
      sub_100031A9C(a1, v49, 0LL);
      objc_autoreleasePoolPop(objc_autoreleasePoolPush());
      if (*(_BYTE *)(a1 + 24)
        && sub_1000452B8(*(void *)(a1 + 64))
        && (*(_DWORD *)(a1 + 5512) == 1 || *(_BYTE *)(a1 + 5496) || !*(_DWORD *)(a1 + 28)))
      {
        int v50 = objc_autoreleasePoolPush();
        if (qword_100219F60) {
          [qword_100219F60 WFLog:@"Attempting multi-stage auto join mStageAutoJoinAttempts=%d" message:3];
        }
        objc_autoreleasePoolPop(v50);
        unsigned int v51 = sub_100100A88(a1);
      }

      else
      {
        uint64_t v155 = objc_autoreleasePoolPush();
        if (qword_100219F60) {
          objc_msgSend( (id)qword_100219F60,  "WFLog:message:",  3,  "Fallback to existing auto-join mStageAutoJoinAttempts=%d",  *(unsigned int *)(a1 + 28));
        }
        objc_autoreleasePoolPop(v155);
        unsigned int v51 = sub_1001010A4(a1);
      }

      goto LABEL_318;
    case 2:
    case 3:
    case 4:
      dispatch_time_t v38 = *(const __CFArray **)(a1 + 1088);
      int v39 = *(_DWORD *)(a1 + 1080);
      CFIndex Count = CFArrayGetCount(*(CFArrayRef *)(a1 + 3616));
      CFMutableStringRef Mutable = CFStringCreateMutable(kCFAllocatorDefault, 0LL);
      int contexta = v39;
      if (!v38 || v39) {
        goto LABEL_349;
      }
      int v195 = 0;
      __int128 v193 = 0u;
      __int128 v194 = 0u;
      *(_OWORD *)__int128 buf = 0u;
      sub_100106158(a1);
      int v42 = *(_DWORD *)(a1 + 3272);
      if (v42 == 4 || v42 == 2)
      {
        BOOL v43 = *(const void **)(a1 + 1144);
        if (v43)
        {
          CFRelease(v43);
          *(void *)(a1 + 1144) = 0LL;
        }
      }

      uint64_t v44 = *(const __CFArray **)(a1 + 1104);
      if (!v44)
      {
        uint64_t v44 = CFArrayCreateMutable(kCFAllocatorDefault, 0LL, &kCFTypeArrayCallBacks);
        *(void *)(a1 + 1104) = v44;
      }

      CFMutableArrayRef v45 = *(CFMutableArrayRef *)(a1 + 1160);
      if (!v45)
      {
        CFMutableArrayRef v45 = CFArrayCreateMutable(kCFAllocatorDefault, 0LL, &kCFTypeArrayCallBacks);
        *(void *)(a1 + 1160) = v45;
        uint64_t v44 = *(const __CFArray **)(a1 + 1104);
      }

      if (!v44 || !v45)
      {
LABEL_349:
        if (Mutable) {
          CFRelease(Mutable);
        }
        goto LABEL_351;
      }

      int v46 = *(_DWORD *)(a1 + 3272);
      if (!*(_BYTE *)(a1 + 5600) || v46 != 3) {
        goto LABEL_166;
      }
      CFIndex v47 = CFArrayGetCount(v44);
      CFIndex v48 = CFArrayGetCount(*(CFArrayRef *)(a1 + 3560)) + v47;
      if (v48 + CFArrayGetCount(*(CFArrayRef *)(a1 + 3552)))
      {
        int v46 = *(_DWORD *)(a1 + 3272);
LABEL_166:
        int v182 = 1;
      }

      else
      {
        int v182 = 0;
      }

      sub_10010622C(a1, v38);
      CFIndex v95 = CFArrayGetCount(v38);
      CFIndex v189 = CFArrayGetCount(*(CFArrayRef *)(a1 + 3544));
      CFIndex v96 = CFArrayGetCount(*(CFArrayRef *)(a1 + 3536));
      uint64_t v97 = 0LL;
      CFIndex range = v96;
      BOOL v98 = Count <= 0 && v96 == 0;
      if (v98 || v95 < 1) {
        goto LABEL_236;
      }
      CFIndex v99 = 0LL;
      uint64_t v97 = 0LL;
      while (1)
      {
        ValueAtIndex = (void *)CFArrayGetValueAtIndex(v38, v99);
        if (!ValueAtIndex) {
          goto LABEL_218;
        }
        CFDateRef v101 = ValueAtIndex;
        if (*(_DWORD *)(a1 + 3272) == 2)
        {
          unsigned int v102 = (const __CFNumber *)sub_1000951FC((uint64_t)ValueAtIndex, @"CHANNEL");
          LODWORD(valuePtr) = 0;
          if (v102)
          {
            CFNumberGetValue(v102, kCFNumberSInt32Type, &valuePtr);
          }
        }

        if (Count >= 1 && sub_100095318((BOOL)v101))
        {
          CFArrayAppendValue(*(CFMutableArrayRef *)(a1 + 1104), v101);
        }

        else
        {
          if (sub_100097264(v101))
          {
            if (v189)
            {
              if (CFArrayGetCount(*(CFArrayRef *)(a1 + 3544)) < 1)
              {
LABEL_191:
                if (Mutable) {
                  sub_100106504(a1, v101, Mutable);
                }
              }

              else
              {
                CFIndex v103 = 0LL;
                while (1)
                {
                  int v104 = (const __CFDictionary **)CFArrayGetValueAtIndex(*(CFArrayRef *)(a1 + 3544), v103);
                  if (!v104) {
                    break;
                  }
                  if (++v103 >= CFArrayGetCount(*(CFArrayRef *)(a1 + 3544))) {
                    goto LABEL_191;
                  }
                }

                uint64_t v118 = objc_autoreleasePoolPush();
                if (qword_100219F60) {
                  [qword_100219F60 WFLog:@"knownHiddenNetwork is NULL!, Added the hidden scan result"];
                }
                objc_autoreleasePoolPop(v118);
LABEL_215:
                if (v182) {
                  CFArrayAppendValue(*(CFMutableArrayRef *)(a1 + 1104), v101);
                }
                uint64_t v97 = (v97 + 1);
              }
            }

            goto LABEL_218;
          }

          v201.location = 0LL;
          v201.length = range;
          FirstIndexOfCFBooleanRef Value = CFArrayGetFirstIndexOfValue(*(CFArrayRef *)(a1 + 3536), v201, v101);
          if (FirstIndexOfValue != -1)
          {
            unsigned int v106 = CFArrayGetValueAtIndex(*(CFArrayRef *)(a1 + 3536), FirstIndexOfValue);
            if (v106)
            {
              uint64_t v107 = (uint64_t)v106;
              if (!sub_10009DF44((uint64_t)v106) || sub_10009DEFC((uint64_t)v101))
              {
                sub_100106604(a1, v101);
                if (sub_1000FC698(a1, v101, 0))
                {
                  v108 = sub_100094E60((uint64_t)kCFAllocatorDefault, (uint64_t)v101);
                  if (v108)
                  {
                    v109 = v108;
                    sub_100095524((uint64_t)v108, v107);
                    char v110 = *(const __CFArray **)(a1 + 1104);
                    v202.length = CFArrayGetCount(v110);
                    v202.location = 0LL;
                    CFIndex v111 = CFArrayGetFirstIndexOfValue(v110, v202, v109);
                    if (v111 != -1)
                    {
                      CFIndex idx = v111;
                      unsigned int v175 = CFArrayGetValueAtIndex(*(CFArrayRef *)(a1 + 1104), v111);
                      sub_1000970C0((uint64_t)v175, @"AJFoundOnDualBand", 1LL);
                      unsigned int v176 = v109;
                      sub_1000970C0((uint64_t)v109, @"AJFoundOnDualBand", 1LL);
                      v112 = CFStringCreateMutable(kCFAllocatorDefault, 0LL);
                      CFMutableStringRef v113 = CFStringCreateMutable(kCFAllocatorDefault, 0LL);
                      CFTypeRef cf = v112;
                      if (v112 && v113)
                      {
                        CFNumberRef v114 = v113;
                        sub_1001067FC(a1, v175, v112);
                        sub_1001067FC(a1, v176, v114);
                        CFNumberRef v115 = objc_autoreleasePoolPush();
                        if (qword_100219F60)
                        {
                          int v116 = v115;
                          [(id)qword_100219F60 WFLog:3, "AJScan: Network found on two bands: {{ %@ }}, {{ %@ }}", cf, v114 message];
                          CFNumberRef v115 = v116;
                        }

                        objc_autoreleasePoolPop(v115);
                        CFMutableStringRef v113 = v114;
                      }

                      CFMutableStringRef v174 = v113;
                      double v117 = sub_10009712C((uint64_t)v175, @"Strength");
                      v109 = v176;
                      if (cf) {
                        CFRelease(cf);
                      }
                      if (v174) {
                        CFRelease(v174);
                      }
                      ++*(_DWORD *)(a1 + 5836);
LABEL_235:
                      CFRelease(v109);
                      goto LABEL_218;
                    }

                    CFRange v119 = CFStringCreateMutable(kCFAllocatorDefault, 0LL);
                    cfa = v119;
                    if (*(_DWORD *)(a1 + 3272) == 3)
                    {
                      if (v119)
                      {
                        sub_1001067FC(a1, v109, v119);
                        dispatch_time_t v120 = objc_autoreleasePoolPush();
                        if (qword_100219F60)
                        {
                          v121 = v120;
                          [(id)qword_100219F60 WFLog:4, "AJScan: Network found on 5Ghz only: {{ %@ }}", cfa message];
                          dispatch_time_t v120 = v121;
                        }

                        objc_autoreleasePoolPop(v120);
                      }

                      ++*(_DWORD *)(a1 + 5832);
                      v122 = objc_autoreleasePoolPush();
                      if (v182)
                      {
                        if (qword_100219F60) {
                          [(id)qword_100219F60 WFLog:4, "AJScan: Used Network found on 5Ghz: {{ %@ }}", cfa message];
                        }
                        objc_autoreleasePoolPop(v122);
                        goto LABEL_229;
                      }

                      if (qword_100219F60) {
                        [(id)qword_100219F60 WFLog:4, "AJScan: Missed Network found on 5Ghz: {{ %@ }}", cfa message];
                      }
                      objc_autoreleasePoolPop(v122);
                    }

                    else
                    {
LABEL_229:
                      CFArrayAppendValue(*(CFMutableArrayRef *)(a1 + 1104), v109);
                    }

                    if (cfa) {
                      CFRelease(cfa);
                    }
                    goto LABEL_235;
                  }
                }
              }
            }
          }
        }

LABEL_342:
      if (!*(void *)(a1 + 3264)) {
        *(void *)(a1 + 3264) = sub_10003AFF4((uint64_t)"__WiFiDeviceManagerStateMachineRun");
      }
      return;
    case 0xC:
    case 0xF:
      unsigned int v51 = sub_100101580( a1,  *(void **)(a1 + 1176),  *(const __CFDictionary **)(a1 + 1184),  *(unsigned int *)(a1 + 1168));
      goto LABEL_318;
    case 0xD:
      int v188 = *(_DWORD *)(a1 + 3336);
      if (!v188)
      {
        id v80 = *(const __CFArray **)(a1 + 3328);
        if (v80)
        {
          if (!*(void *)(a1 + 1104))
          {
            *(void *)(a1 + 1104) = CFArrayCreateMutable(kCFAllocatorDefault, 0LL, &kCFTypeArrayCallBacks);
            id v80 = *(const __CFArray **)(a1 + 3328);
          }

          if (CFArrayGetCount(v80))
          {
            if (CFArrayGetCount(*(CFArrayRef *)(a1 + 3616)))
            {
              CFIndex v81 = CFArrayGetCount(*(CFArrayRef *)(a1 + 3328));
              if (v81)
              {
                uint64_t v82 = v81;
                CFMutableArrayRef v83 = CFArrayCreateMutable(kCFAllocatorDefault, 0LL, &kCFTypeArrayCallBacks);
                if (v83)
                {
                  uint64_t v84 = v83;
                  if (v82 >= 1)
                  {
                    for (CFIndex j = 0LL; v82 != j; ++j)
                    {
                      __int128 v86 = (void *)CFArrayGetValueAtIndex(*(CFArrayRef *)(a1 + 3328), j);
                      if (v86)
                      {
                        CFNumberRef v87 = v86;
                        if (sub_10009A128((uint64_t)v86))
                        {
                          CFNumberRef v88 = *(const __CFArray **)(a1 + 3632);
                          v199.length = CFArrayGetCount(v88);
                          v199.location = 0LL;
                          if (CFArrayGetFirstIndexOfValue(v88, v199, v87) == -1)
                          {
                            if (sub_1000FC698(a1, v87, 0))
                            {
                              v200.length = CFArrayGetCount(v84);
                              v200.location = 0LL;
                              if (CFArrayContainsValue(v84, v200, v87)) {
                                continue;
                              }
                              CFArrayAppendValue(v84, v87);
                              __int128 v89 = objc_autoreleasePoolPush();
                              if (qword_100219F60) {
                                [(id)qword_100219F60 WFLog:3, "%s: found provisioned network %@, adding to tmp array", "__WiFiDeviceManagerFilterProvisionedHS20Networks", sub_100095BC8(v87) message];
                              }
                            }

                            else
                            {
                              __int128 v89 = objc_autoreleasePoolPush();
                              if (qword_100219F60) {
                                [(id)qword_100219F60 WFLog:3, "%s: Provisioned HS2.0 network %@ not eligible for aj", "__WiFiDeviceManagerFilterProvisionedHS20Networks", sub_100095BC8(v87) message];
                              }
                            }
                          }

                          else
                          {
                            __int128 v89 = objc_autoreleasePoolPush();
                            if (qword_100219F60) {
                              [(id)qword_100219F60 WFLog:3, "%s: HS2.0 network %@ is in disabled network list", "__WiFiDeviceManagerFilterProvisionedHS20Networks", sub_100095BC8(v87) message];
                            }
                          }
                        }

                        else
                        {
                          __int128 v89 = objc_autoreleasePoolPush();
                          if (qword_100219F60) {
                            [(id)qword_100219F60 WFLog:3, "%s: network is disabled %@", "__WiFiDeviceManagerFilterProvisionedHS20Networks", sub_100095BC8(v87) message];
                          }
                        }

                        objc_autoreleasePoolPop(v89);
                      }
                    }
                  }

                  CFArrayRemoveAllValues(*(CFMutableArrayRef *)(a1 + 3328));
                  if (CFArrayGetCount(v84))
                  {
                    __int128 v92 = *(__CFArray **)(a1 + 3328);
                    v203.length = CFArrayGetCount(v84);
                    v203.location = 0LL;
                    CFArrayAppendArray(v92, v84, v203);
                    CFRelease(v84);
                    BOOL v93 = *(__CFArray **)(a1 + 1104);
                    int v94 = *(const __CFArray **)(a1 + 3328);
                    v204.length = CFArrayGetCount(v94);
                    v204.location = 0LL;
                    CFArrayAppendArray(v93, v94, v204);
                    goto LABEL_300;
                  }

                  CFIndex v146 = objc_autoreleasePoolPush();
                  if (qword_100219F60) {
                    [(id)qword_100219F60 WFLog:3 message:"No provisioned HS2.0 networks found"];
                  }
                  objc_autoreleasePoolPop(v146);
                  CFRelease(v84);
                }
              }

              else
              {
                v170 = objc_autoreleasePoolPush();
                if (qword_100219F60) {
                  [(id)qword_100219F60 WFLog:3 message:"No GAS responses to filter"];
                }
                objc_autoreleasePoolPop(v170);
              }

              CFIndex v147 = objc_autoreleasePoolPush();
              if (qword_100219F60) {
                [(id)qword_100219F60 WFLog:3 message:"No suitable HS2.0 networks found"];
              }
LABEL_299:
              objc_autoreleasePoolPop(v147);
LABEL_300:
              v148 = *(const void **)(a1 + 3328);
              if (v148)
              {
                CFRelease(v148);
                *(void *)(a1 + 332_Block_object_dispose((const void *)(v1 - 136), 8) = 0LL;
              }

              CFIndex v149 = CFArrayGetCount(*(CFArrayRef *)(a1 + 3560));
              if (v149)
              {
                CFIndex v150 = v149;
                v151 = *(__CFArray **)(a1 + 1104);
                if (!v151)
                {
                  v151 = CFArrayCreateMutable(kCFAllocatorDefault, 0LL, &kCFTypeArrayCallBacks);
                  *(void *)(a1 + 1104) = v151;
                  if (!v151)
                  {
                    v171 = objc_autoreleasePoolPush();
                    if (qword_100219F60) {
                      [qword_100219F60 WFLog:@"%s: null scan.candidates.networks" message:3];
                    }
                    objc_autoreleasePoolPop(v171);
LABEL_374:
                    uint64_t v166 = a1;
                    int v165 = v188;
LABEL_375:
                    unsigned int v140 = sub_100105840(v166, v165);
                    goto LABEL_312;
                  }
                }

                v205.location = 0LL;
                v205.length = v150;
                CFArrayAppendArray(v151, *(CFArrayRef *)(a1 + 3560), v205);
                int v152 = objc_autoreleasePoolPush();
                if (qword_100219F60) {
                  [qword_100219F60 WFLog:@"message: %s: Appending deffered networks to candidates list" message:@"__WiFiDeviceManagerProcessGasResponses"];
                }
                objc_autoreleasePoolPop(v152);
              }

              CFArrayRemoveAllValues(*(CFMutableArrayRef *)(a1 + 3552));
              CFArrayRemoveAllValues(*(CFMutableArrayRef *)(a1 + 3560));
              [*(id *)(a1 + 3648) clearScanResultsForAutoJoinSessionReset];
              sub_100107114(a1, *(const __CFArray **)(a1 + 1104));
              uint64_t v153 = objc_autoreleasePoolPush();
              if (qword_100219F60) {
                [(id)qword_100219F60 WFLog:3, "%s:%d manager->state.scan.candidates.networks %@", "__WiFiDeviceManagerProcessGasResponses", 27068, *(void *)(a1 + 1104) message];
              }
              objc_autoreleasePoolPop(v153);
              if (sub_1001079F0(a1))
              {
LABEL_311:
                unsigned int v140 = sub_10010824C(a1);
                goto LABEL_312;
              }

              goto LABEL_374;
            }

            CFIndex v147 = objc_autoreleasePoolPush();
            int v168 = (void *)qword_100219F60;
            if (!qword_100219F60) {
              goto LABEL_299;
            }
            int v169 = "No HS2.0 accounts";
          }

          else
          {
            CFIndex v147 = objc_autoreleasePoolPush();
            int v168 = (void *)qword_100219F60;
            if (!qword_100219F60) {
              goto LABEL_299;
            }
            int v169 = "GAS Query returned response count=0. Continuing...";
          }
        }

        else
        {
          CFIndex v147 = objc_autoreleasePoolPush();
          int v168 = (void *)qword_100219F60;
          if (!qword_100219F60) {
            goto LABEL_299;
          }
          int v169 = "GAS Query returned no responses. Continuing...";
        }

        objc_msgSend(v168, "WFLog:message:", 3, v169, v172);
        goto LABEL_299;
      }

      CFIndex v147 = objc_autoreleasePoolPush();
      if (qword_100219F60) {
        [qword_100219F60 WFLog:@"GAS Query failed with err=%d. Continuing..." message:3];
      }
      goto LABEL_299;
    case 0xE:
    case 0x11:
      unsigned int v51 = sub_100102A84(a1);
LABEL_318:
      *(_DWORD *)(a1 + 3272) = v51;
      goto LABEL_339;
    case 0x10:
      if (_os_feature_enabled_impl("CoreWiFi", "UnifiedAutoJoin"))
      {
LABEL_346:
        uint64_t v164 = objc_autoreleasePoolPush();
        if (qword_100219F60) {
          [qword_100219F60 WFLog:@"__WiFiDeviceManagerStateMachineRun with state=%d not allowed with Unified Auto-Join" message:3];
        }
        objc_autoreleasePoolPop(v164);
        goto LABEL_338;
      }

      unsigned int v90 = sub_100102F9C(a1);
LABEL_157:
      *(_DWORD *)(a1 + 3272) = v90;
      if (v90 <= 1) {
        goto LABEL_336;
      }
      goto LABEL_342;
    case 0x12:
      unsigned int v90 = sub_1001034F4(a1, *(void *)(a1 + 6856));
      goto LABEL_157;
    case 0x13:
      if (*(_BYTE *)(a1 + 6960))
      {
        unsigned int v91 = objc_autoreleasePoolPush();
        if (qword_100219F60) {
          [qword_100219F60 WFLog:@"%s: Waiting on Enable Remote Hotspot" message:3];
        }
        objc_autoreleasePoolPop(v91);
LABEL_335:
        if (*(_DWORD *)(a1 + 3272) <= 1u)
        {
LABEL_336:
          int v154 = off_1001E3C80;
          goto LABEL_337;
        }

        goto LABEL_342;
      }

      v141 = *(const void **)(a1 + 6856);
      if (*(void *)(a1 + 6944))
      {
        v142 = (__CFString *)objc_msgSend( objc_msgSend(*(id *)(a1 + 6728), "getHotspotDeviceName:", *(void *)(a1 + 6856)),  "copy");
        if ([*(id *)(a1 + 6944) code] == (id)-71146)
        {
          v143 = objc_autoreleasePoolPush();
          if (qword_100219F60) {
            [(id)qword_100219F60 WFLog:3 message:"Connection Failure: Server blocked"];
          }
          objc_autoreleasePoolPop(v143);
          CFArrayAppendValue(*(CFMutableArrayRef *)(a1 + 6872), v141);
          sub_1000CABEC(a1, 0);
          *(void *)(a1 + 6824) = 0LL;
          *(_DWORD *)(a1 + 6832) = 0;
          *(_DWORD *)(a1 + 3272) = 0;
          sub_10010BEEC(a1, v142, 2u);
          *(void *)(a1 + 6856) = 0LL;
        }

        int v144 = *(_DWORD *)(a1 + 6832);
        CFIndex v145 = objc_autoreleasePoolPush();
        if (v144)
        {
          if (qword_100219F60) {
            [(id)qword_100219F60 WFLog:3, "Error (%@) enabling hotspot... Retry %d", *(void *)(a1 + 6944), *(unsigned int *)(a1 + 6832) message];
          }
          objc_autoreleasePoolPop(v145);
          --*(_DWORD *)(a1 + 6832);
          *(_DWORD *)(a1 + 3272) = 18;
          sub_1000CACC4(a1);
        }

        else
        {
          if (qword_100219F60) {
            [(id)qword_100219F60 WFLog:3, "Error (%@) enabling hotspot after max retry", *(void *)(a1 + 6944) message];
          }
          objc_autoreleasePoolPop(v145);
          sub_1000CABEC(a1, 0);
          *(_DWORD *)(a1 + 3272) = 0;
          *(void *)(a1 + 6824) = 0LL;
          sub_10010BEEC(a1, v142, 1u);
        }

        *(_DWORD *)(a1 + 644_Block_object_dispose((const void *)(v1 - 136), 8) = [*(id *)(a1 + 6944) code];
        *(_BYTE *)(a1 + 6456) = [*(id *)(a1 + 6728) isFamilyHotspot:v141];
        sub_1000325B0((unsigned int *)(a1 + 6448));

        goto LABEL_334;
      }

      if (*(void *)(a1 + 6952))
      {
        uint64_t v156 = objc_autoreleasePoolPush();
        if (qword_100219F60) {
          [(id)qword_100219F60 WFLog:3, "Hotspot Enabled %@", *(void *)(a1 + 6952) message];
        }
        objc_autoreleasePoolPop(v156);
        uint64_t v157 = (const __CFString *)[*(id *)(a1 + 6952) objectForKey:@"ssid" sub_1000CABEC(a1, 0)];
        v158 = sub_100094CE8(v157);
        if (v158)
        {
          uint64_t v159 = (uint64_t)v158;
          sub_100099C50(v158, (const __CFString *)[*(id *)(a1 + 6952) objectForKey:@"password"]);
          sub_10009582C(v159, @"CHANNEL", [*(id *)(a1 + 6952) objectForKey:@"channel"]);
          BOOL v160 = *(const void **)(a1 + 6808);
          if (v160) {
            CFRelease(v160);
          }
          *(void *)(a1 + 680_Block_object_dispose((const void *)(v1 - 136), 8) = v159;
          *(CFAbsoluteTime *)(a1 + 696_Block_object_dispose((const void *)(v1 - 136), 8) = CFAbsoluteTimeGetCurrent();
          int v161 = sub_10010C020(a1, *(const __CFArray **)(a1 + 6808), *(unsigned __int8 *)(a1 + 6920));
          if (!v161)
          {
            *(_DWORD *)(a1 + 3272) = 20;
            *(_DWORD *)(a1 + 644_Block_object_dispose((const void *)(v1 - 136), 8) = 0;
            *(_BYTE *)(a1 + 6456) = [*(id *)(a1 + 6728) isFamilyHotspot:v141];
            *(_BYTE *)(a1 + 6457) = 1;
            sub_10010B9B4((uint64_t *)a1, @"userJoinScanning", 0LL);
LABEL_334:

            *(void *)(a1 + 6952) = 0LL;
            goto LABEL_335;
          }

          *(_DWORD *)(a1 + 644_Block_object_dispose((const void *)(v1 - 136), 8) = v161;
          *(_BYTE *)(a1 + 6456) = [*(id *)(a1 + 6728) isFamilyHotspot:v141];
          sub_1000325B0((unsigned int *)(a1 + 6448));
          sub_10010B9B4((uint64_t *)a1, @"userJoinAssociationFailed", 0LL);
        }

        int v162 = *(void **)(a1 + 6952);
        if (v162)
        {

          *(void *)(a1 + 6952) = 0LL;
        }
      }

      *(void *)(a1 + 6824) = 0LL;
      goto LABEL_335;
    default:
      goto LABEL_342;
  }

id sub_1000CCA94(uint64_t a1)
{
  uint64_t v2 = objc_autoreleasePoolPush();
  if (qword_100219F60) {
    [qword_100219F60 WFLog:@"%s: BssBlacklist expiry timer fired" message:3];
  }
  objc_autoreleasePoolPop(v2);
  [*(id *)(a1 + 6632) removeExpiredDenyListedState:2];
  return [*(id *)(a1 + 6632) removeExpiredDenyListedState:1];
}

id sub_1000CCB08(uint64_t a1)
{
  uint64_t v2 = objc_autoreleasePoolPush();
  if (qword_100219F60) {
    [qword_100219F60 WFLog:@"%s: EAPATNotifBlacklist expiry timer fired" message:3];
  }
  objc_autoreleasePoolPop(v2);
  id result = [*(id *)(a1 + 6632) removeExpiredDenyListedState:4];
  *(_BYTE *)(a1 + 728_Block_object_dispose((const void *)(v1 - 136), 8) = 0;
  return result;
}

void sub_1000CCB7C(uint64_t a1)
{
  uint64_t v2 = objc_autoreleasePoolPush();
  if (a1)
  {
    uint64_t v3 = *(void *)(a1 + 7176) + 1LL;
    *(void *)(a1 + 7176) = v3;
    if (*(_DWORD *)(a1 + 7184))
    {
      if (!sub_10001D874(*(void *)(a1 + 120))) {
        goto LABEL_11;
      }
      uint64_t v4 = +[NSString stringWithFormat:]( &OBJC_CLASS___NSString,  "stringWithFormat:",  @"DNS Stall: %llus",  *(void *)(a1 + 7176));
    }

    else
    {
      uint64_t v4 = +[NSString stringWithFormat:](&OBJC_CLASS___NSString, "stringWithFormat:", @"Data Stall: %llus", v3);
    }

    uint64_t v5 = v4;
    if (*(_BYTE *)(a1 + 7189))
    {
      if (MGGetBoolAnswer(@"InternalBuild"))
      {
        uint64_t v6 = *(void (**)(uint64_t, uint64_t, NSString *, void))(a1 + 4544);
        if (v6) {
          v6(a1, 18LL, v5, *(void *)(a1 + 4552));
        }
      }

      CFIndex v7 = *(dispatch_source_s **)(a1 + 7168);
      dispatch_time_t v8 = dispatch_time(0LL, 1000000000LL);
      dispatch_source_set_timer(v7, v8, 0xFFFFFFFFFFFFFFFFLL, 0LL);
      goto LABEL_12;
    }

void sub_1000CCCAC(uint64_t a1)
{
  uint64_t v2 = objc_autoreleasePoolPush();
  if (a1)
  {
    uint64_t v3 = *(void *)(a1 + 7224);
    *(void *)(a1 + 7224) = v3 - 1;
    uint64_t v4 = *(void *)(a1 + 7216) + 1LL;
    *(void *)(a1 + 7216) = v4;
    if (v3 >= 2
      && (uint64_t v5 = +[NSString stringWithFormat:](&OBJC_CLASS___NSString, "stringWithFormat:", @"Slow WiFi: %llus", v4),
          *(_BYTE *)(a1 + 7240)))
    {
      uint64_t v6 = v5;
      if (MGGetBoolAnswer(@"InternalBuild"))
      {
        CFIndex v7 = *(void (**)(uint64_t, uint64_t, NSString *, void))(a1 + 4544);
        if (v7) {
          v7(a1, 17LL, v6, *(void *)(a1 + 4552));
        }
      }

      dispatch_time_t v8 = *(dispatch_source_s **)(a1 + 7208);
      dispatch_time_t v9 = dispatch_time(0LL, 1000000000LL);
      dispatch_source_set_timer(v8, v9, 0xFFFFFFFFFFFFFFFFLL, 0LL);
    }

    else
    {
      sub_10010E868(a1);
    }
  }

  else if (qword_100219F60)
  {
    [qword_100219F60 WFLog:@"__WiFiDeviceManagerSlowWiFiHUDTimerExpiryHandler: null manager."];
  }

  objc_autoreleasePoolPop(v2);
}

void sub_1000CCDC0(uint64_t a1)
{
  if (!a1)
  {
    __int128 v19 = objc_autoreleasePoolPush();
    if (qword_100219F60) {
      [qword_100219F60 WFLog:@"__WiFiDeviceManagerAdaptiveRoamTimerCallback: null manager."];
    }
    goto LABEL_45;
  }

  uint64_t v2 = *(void *)(a1 + 64);
  if (!v2)
  {
    __int128 v19 = objc_autoreleasePoolPush();
    if (qword_100219F60) {
      [qword_100219F60 WFLog:@"%s: null device." message:4];
    }
LABEL_45:
    objc_autoreleasePoolPop(v19);
    goto LABEL_46;
  }

  uint64_t v3 = (const void *)sub_10004CE2C(v2);
  uint64_t v4 = sub_1000DEA34(a1, v3, 1);
  if (!v4)
  {
LABEL_46:
    int v21 = 0LL;
    goto LABEL_21;
  }

  uint64_t v5 = v4;
  if (_os_feature_enabled_impl("WiFiManager", "RealTimeRoamSuppression") && *(_BYTE *)(a1 + 6994))
  {
    if (-[WiFiUserInteractionMonitor isWiFiCallInProgress]( +[WiFiUserInteractionMonitor sharedInstance](&OBJC_CLASS___WiFiUserInteractionMonitor, "sharedInstance"),  "isWiFiCallInProgress")
      || (unsigned int v6 = *(unsigned __int8 *)(a1 + 3469), *(_BYTE *)(a1 + 3469)))
    {
      unsigned int v6 = (*(_BYTE *)(a1 + 3460) & 1) == 0;
    }

    if (*(_BYTE *)(a1 + 3406)) {
      uint64_t v7 = 1LL;
    }
    else {
      uint64_t v7 = v6;
    }
    if ((_DWORD)v7)
    {
      if (!*(_BYTE *)(a1 + 3468))
      {
        int v21 = objc_alloc_init(&OBJC_CLASS___NSMutableDictionary);
        if (*(_BYTE *)(a1 + 3406)) {
          uint64_t v8 = 4294967186LL;
        }
        else {
          uint64_t v8 = 4294967216LL;
        }
        -[NSMutableDictionary setObject:forKey:]( v21,  "setObject:forKey:",  +[NSNumber numberWithInt:](&OBJC_CLASS___NSNumber, "numberWithInt:", v8),  @"IO80211InterfaceAdaptiveRoamRSSITrigger");
        uint64_t v9 = *(void *)(a1 + 64);
        id v10 = (const void *)sub_100043E8C(v9);
        sub_10003EC6C(v9, v10, 532LL, 0LL, (uint64_t)v21);
        *(_BYTE *)(a1 + 346_Block_object_dispose((const void *)(v1 - 136), 8) = 1;
        [*(id *)(a1 + 7320) updateWithRoamingSuppression:v7];
        goto LABEL_25;
      }
    }

    else if (*(_BYTE *)(a1 + 3468))
    {
      *(_BYTE *)(a1 + 346_Block_object_dispose((const void *)(v1 - 136), 8) = 0;
      id v12 = +[WiFiRoamManager sharedWiFiRoamManager](&OBJC_CLASS___WiFiRoamManager, "sharedWiFiRoamManager");
      +[NSDate timeIntervalSinceReferenceDate](&OBJC_CLASS___NSDate, "timeIntervalSinceReferenceDate");
      [v12 setLastRoamSuppressionRemovalTime:];
      int v21 = 0LL;
      int v11 = 1;
      goto LABEL_26;
    }

    int v21 = 0LL;
LABEL_25:
    int v11 = 0;
LABEL_26:
    CFIndex v13 = objc_autoreleasePoolPush();
    CFIndex v14 = (void *)qword_100219F60;
    if (qword_100219F60)
    {
      uint64_t v15 = "YES";
      if ((_DWORD)v7) {
        BOOL v16 = "YES";
      }
      else {
        BOOL v16 = "NO";
      }
      CFTypeID v20 = v16;
      if (*(_BYTE *)(a1 + 3468)) {
        __int128 v17 = "YES";
      }
      else {
        __int128 v17 = "NO";
      }
      if (-[WiFiUserInteractionMonitor isRealTimeAppActive]( +[WiFiUserInteractionMonitor sharedInstance](&OBJC_CLASS___WiFiUserInteractionMonitor, "sharedInstance"),  "isRealTimeAppActive"))
      {
        __int128 v18 = "YES";
      }

      else
      {
        __int128 v18 = "NO";
      }

      if (!-[WiFiUserInteractionMonitor isWiFiCallInProgress]( +[WiFiUserInteractionMonitor sharedInstance](&OBJC_CLASS___WiFiUserInteractionMonitor, "sharedInstance"),  "isWiFiCallInProgress")) {
        uint64_t v15 = "NO";
      }
      [v14 WFLog:3, "%s: isRoamSuppressionRecommended=%s (applied=%s) isRealTimeAppActive=%s isWiFiCallInProgress=%s currentNetwork=% @ roamSuppressionRequest=%@", "__WiFiDeviceManagerAdaptiveRoamTimerCallback", v20, v17, v18, v15, sub_100095BC8(v5), v21 message];
    }

    objc_autoreleasePoolPop(v13);
    if (*(_BYTE *)(a1 + 3468)) {
      goto LABEL_20;
    }
    goto LABEL_19;
  }

  int v11 = 0;
  uint64_t v7 = 0LL;
  int v21 = 0LL;
  *(_BYTE *)(a1 + 346_Block_object_dispose((const void *)(v1 - 136), 8) = 0;
LABEL_19:
  [*(id *)(a1 + 7320) updateWithRoamingSuppression:v7];
  sub_10010E980(a1, v5, v11);
LABEL_20:
  CFRelease(v5);
LABEL_21:
}

void sub_1000CD0B4(uint64_t a1)
{
  uint64_t v2 = *(void *)(a1 + 64);
  if (v2)
  {
    int v3 = *(unsigned __int8 *)(a1 + 3406);
    uint64_t v4 = (const void *)sub_10004CE2C(v2);
    uint64_t v5 = sub_1000DEA34(a1, v4, 1);
    if (v5)
    {
      unsigned int v6 = v5;
      sub_1000DF940(a1, v3);
      CFRelease(v6);
    }
  }

  else
  {
    uint64_t v7 = objc_autoreleasePoolPush();
    if (qword_100219F60) {
      [qword_100219F60 WFLog:@"%s: null device." message:4];
    }
    objc_autoreleasePoolPop(v7);
  }

void sub_1000CD178(uint64_t a1, uint64_t a2, void *a3)
{
  uint64_t v5 = *(void *)(a1 + 32);
  unsigned int v6 = objc_autoreleasePoolPush();
  if (qword_100219F60) {
    [(id)qword_100219F60 WFLog:3, "%s: settlement status=%ld userInfo='%@'", "__WiFiDeviceManagerHandleSettlementChange", a2, a3 message];
  }
  objc_autoreleasePoolPop(v6);
  if (*(void *)(v5 + 4384))
  {
    id v7 = [a3 mutableCopy];
    [v7 setObject:[NSNumber numberWithInteger:a2] forKey:@"settlement"];
    uint64_t v8 = sub_10004CE2C(*(void *)(v5 + 64));
    (*(void (**)(uint64_t, uint64_t, void, uint64_t, id))(v5 + 4384))(v5, v8, *(void *)(v5 + 4392), 7LL, v7);
    if (v7) {
      CFRelease(v7);
    }
  }

uint64_t sub_1000CD264(uint64_t result)
{
  *(_BYTE *)(result + 8912) = 1;
  return result;
}

uint64_t sub_1000CD274(uint64_t a1)
{
  return *(unsigned __int8 *)(a1 + 8912);
}

uint64_t sub_1000CD280(uint64_t a1, uint64_t a2, uint64_t a3)
{
  BOOL v26 = 0;
  uint64_t v3 = *(unsigned __int8 *)(a1 + 16);
  if (*(_BYTE *)(a1 + 16)) {
    return v3;
  }
  uint64_t v3 = sub_10004703C(*(void **)(a1 + 64), a2, a3);
  if (!(_DWORD)v3) {
    return v3;
  }
  *(_BYTE *)(a1 + 16) = 1;
  uint64_t v5 = *(void *)(a1 + 64);
  unsigned int v6 = (const void *)sub_100043E8C(v5);
  *(_DWORD *)(a1 + 20) = sub_10004CE50(v5, v6);
  *(_DWORD *)(a1 + 12_Block_object_dispose((const void *)(v1 - 136), 8) = sub_10004CE40(*(void *)(a1 + 64));
  *(_OWORD *)(a1 + 132) = xmmword_10017FBA0;
  [*(id *)(a1 + 3648) setUsageRankForDeferral:3];
  id v7 = (const __CFString *)sub_100043E8C(*(void *)(a1 + 64));
  uint64_t v8 = SCNetworkInterfaceCopyAll();
  CFIndex Count = CFArrayGetCount(v8);
  if (Count >= 1)
  {
    CFIndex v10 = Count;
    CFIndex v11 = 0LL;
    while (1)
    {
      ValueAtIndex = (const __SCNetworkInterface *)CFArrayGetValueAtIndex(v8, v11);
      if (ValueAtIndex)
      {
        CFIndex v13 = ValueAtIndex;
        BSDCFStringRef Name = SCNetworkInterfaceGetBSDName(ValueAtIndex);
        if (BSDName)
        {
          if (CFStringCompare(BSDName, v7, 1uLL) == kCFCompareEqualTo) {
            break;
          }
        }
      }

      if (v10 == ++v11) {
        goto LABEL_9;
      }
    }

    CFRetain(v13);
    if (!v8) {
      goto LABEL_11;
    }
    goto LABEL_10;
  }

void sub_1000CD56C(uint64_t a1, dispatch_queue_s *a2)
{
  uint64_t v4 = objc_autoreleasePoolPush();
  uint64_t v5 = objc_autoreleasePoolPush();
  if (qword_100219F60) {
    [qword_100219F60 WFLog:@"%s: entering" message:4];
  }
  objc_autoreleasePoolPop(v5);
  if (a2)
  {
    if (!*(_BYTE *)(a1 + 16) || *(void *)(a1 + 240))
    {
      unsigned int v6 = objc_autoreleasePoolPush();
      if (qword_100219F60) {
        [qword_100219F60 WFLog:@"WiFiDeviceManagerScheduleWithQueue: exiting, Error: not opened or queue already assigned"];
      }
      goto LABEL_101;
    }

    *(void *)(a1 + 240) = a2;
    sub_100047814(*(void *)(a1 + 64), a2);
    sub_100016128(*(void *)(a1 + 120), *(void *)(a1 + 240));
    id v7 = *(dispatch_object_s **)(a1 + 312);
    if (v7) {
      dispatch_activate(v7);
    }
    uint64_t v8 = *(dispatch_object_s **)(a1 + 360);
    if (v8) {
      dispatch_activate(v8);
    }
    if (!*(void *)(a1 + 5432)
      && (sub_10004B9CC(*(void *)(a1 + 64)) || sub_10004D678(*(void *)(a1 + 64))))
    {
      context.version = 0LL;
      memset(&context.retain, 0, 24);
      context.info = (void *)a1;
      SCDynamicStoreRef v9 = SCDynamicStoreCreate( kCFAllocatorDefault,  @"WiFiDeviceManager",  (SCDynamicStoreCallBack)sub_1000CF0FC,  &context);
      *(void *)(a1 + 5432) = v9;
      if (!v9)
      {
        CFIndex v11 = objc_autoreleasePoolPush();
        if (qword_100219F60) {
          [qword_100219F60 WFLog:@"SCDynamicStoreCreate failed" message:4];
        }
        goto LABEL_27;
      }

      sub_1000CF5E4(a1);
      if (!SCDynamicStoreSetDispatchQueue(*(SCDynamicStoreRef *)(a1 + 5432), *(dispatch_queue_t *)(a1 + 240)))
      {
        CFIndex v10 = objc_autoreleasePoolPush();
        if (qword_100219F60) {
          [qword_100219F60 WFLog:@"Error setting dynamic store queue."];
        }
        objc_autoreleasePoolPop(v10);
      }

      if (!SCDynamicStoreSetDisconnectCallBack(*(void *)(a1 + 5432), sub_1000CF68C))
      {
        CFIndex v11 = objc_autoreleasePoolPush();
        if (qword_100219F60) {
          [qword_100219F60 WFLog:@"Error subscribing to the dynamic store disconnect event."];
        }
LABEL_27:
        objc_autoreleasePoolPop(v11);
      }
    }

    id v12 = *(dispatch_object_s **)(a1 + 5232);
    if (v12) {
      dispatch_activate(v12);
    }
    CFIndex v13 = *(dispatch_object_s **)(a1 + 5312);
    if (v13) {
      dispatch_activate(v13);
    }
    CFIndex v14 = *(dispatch_object_s **)(a1 + 5504);
    if (v14) {
      dispatch_activate(v14);
    }
    uint64_t v15 = *(dispatch_object_s **)(a1 + 8544);
    if (v15) {
      dispatch_activate(v15);
    }
    int v16 = *(dispatch_object_s **)(a1 + 8584);
    if (v16) {
      dispatch_activate(v16);
    }
    char v17 = *(dispatch_object_s **)(a1 + 992);
    if (v17) {
      dispatch_activate(v17);
    }
    uint64_t v18 = *(dispatch_object_s **)(a1 + 1048);
    if (v18) {
      dispatch_activate(v18);
    }
    __int128 v19 = *(dispatch_object_s **)(a1 + 5520);
    if (v19) {
      dispatch_activate(v19);
    }
    CFTypeID v20 = *(dispatch_object_s **)(a1 + 6760);
    if (v20) {
      dispatch_activate(v20);
    }
    int v21 = *(dispatch_object_s **)(a1 + 6768);
    if (v21) {
      dispatch_activate(v21);
    }
    uint64_t v22 = *(dispatch_object_s **)(a1 + 7272);
    if (v22) {
      dispatch_activate(v22);
    }
    id v23 = *(dispatch_object_s **)(a1 + 7296);
    if (v23) {
      dispatch_activate(v23);
    }
    id v24 = *(dispatch_object_s **)(a1 + 7168);
    if (v24) {
      dispatch_activate(v24);
    }
    uint64_t v25 = *(dispatch_object_s **)(a1 + 7208);
    if (v25) {
      dispatch_activate(v25);
    }
    BOOL v26 = *(void **)(a1 + 5400);
    if (v26)
    {
      unsigned int v27 = [v26 setupDevice:a1];
      CFIndex v28 = objc_autoreleasePoolPush();
      if (v27)
      {
        if (qword_100219F60) {
          [qword_100219F60 WFLog:@"WiFiBatteryMgmt batteryManager setup" message:3];
        }
      }

      else if (qword_100219F60)
      {
        [qword_100219F60 WFLog:@"WiFiBatteryMgmt batteryManager setup failed. WiFi will default to full throttle"];
      }
    }

    else
    {
      CFIndex v28 = objc_autoreleasePoolPush();
      if (qword_100219F60) {
        [qword_100219F60 WFLog:@"WiFiBatteryMgmt No Battery Power Manager support from CoreOS. WiFi will default to full throttle."];
      }
    }

    objc_autoreleasePoolPop(v28);
    sub_100055A54(*(void *)(a1 + 64));
    uint64_t v29 = *(void (**)(uint64_t, void))(a1 + 4896);
    if (v29) {
      v29(a1, *(void *)(a1 + 4904));
    }
    uint64_t v30 = objc_autoreleasePoolPush();
    if (qword_100219F60) {
      [qword_100219F60 WFLog:@"WiFiCC : Attempted setting available country code"];
    }
    objc_autoreleasePoolPop(v30);
    sub_1000CF6EC(v31, (const void *)a1, 0LL);
    uint64_t v32 = *(void *)(a1 + 64);
    uint64_t v33 = (const void *)sub_100043E8C(v32);
    CFIndex v34 = (void *)sub_100040538(v32, v33);
    if (v34)
    {
      id v35 = v34;
      unsigned int v36 = sub_10009DF44((uint64_t)v34);
      double v37 = objc_autoreleasePoolPush();
      if (qword_100219F60) {
        [(id)qword_100219F60 WFLog:3, "%s: associated to %@, isCarplay %d", "WiFiDeviceManagerScheduleWithQueue", sub_100095BC8(v35), v36 message];
      }
      objc_autoreleasePoolPop(v37);
      char v38 = 1;
      *(_BYTE *)(a1 + 3403) = 1;
      *(_BYTE *)(a1 + 548_Block_object_dispose((const void *)(v1 - 136), 8) = v36;
      -[WiFiUserInteractionMonitor updateIsCarPlay:]( +[WiFiUserInteractionMonitor sharedInstance](&OBJC_CLASS___WiFiUserInteractionMonitor, "sharedInstance"),  "updateIsCarPlay:",  v36 != 0);
      if (!sub_10009F434((CFDictionaryRef *)v35)) {
        char v38 = objc_msgSend( +[WiFiAnalyticsManager sharedWiFiAnalyticsManager]( WiFiAnalyticsManager,  "sharedWiFiAnalyticsManager"),  "isMovingNetwork:",  v35);
      }
      sub_1000CF7C4(a1, v38);
      sub_1000CF880(a1, 1, 1);
      if (!*(_BYTE *)(a1 + 3404)) {
        sub_1000CFA74((unsigned __int8 *)a1);
      }
      CFRelease(v35);
    }

    sub_1000CE480(a1);
    if (_os_feature_enabled_impl("CoreWiFi", "UnifiedAutoJoin"))
    {
      id v39 = objc_alloc_init(&OBJC_CLASS___CWFAutoJoinManager);
      *(void *)(a1 + 8776) = v39;
      if (v39 && (id v40 = objc_alloc_init(&OBJC_CLASS___NSMutableDictionary), (*(void *)(a1 + 8848) = v40) != 0LL))
      {
        context.version = (CFIndex)_NSConcreteStackBlock;
        context.info = (void *)3221225472LL;
        context.retain = (const void *(__cdecl *)(const void *))sub_100113714;
        context.release = (void (__cdecl *)(const void *))&unk_1001E51F8;
        context.copyDescription = (CFStringRef (__cdecl *)(const void *))a1;
        [*(id *)(a1 + 8776) setAllowAutoJoinHandler:&context];
        handler = _NSConcreteStackBlock;
        uint64_t v77 = 3221225472LL;
        unsigned int v78 = sub_100114450;
        unsigned int v79 = &unk_1001E5218;
        uint64_t v80 = a1;
        [*(id *)(a1 + 8776) setAllowKnownNetworkHandler:&handler];
        [*(id *)(a1 + 8776) setKnownNetworkComparator:0];
        if (*(_BYTE *)(a1 + 6616))
        {
          __int128 v71 = _NSConcreteStackBlock;
          uint64_t v72 = 3221225472LL;
          CFIndex v73 = sub_10011483C;
          __int128 v74 = &unk_1001E5238;
          uint64_t v75 = a1;
          [*(id *)(a1 + 8776) setKnownNetworkComparator:&v71];
        }

        v70[0] = _NSConcreteStackBlock;
        v70[1] = 3221225472LL;
        v70[2] = sub_10011491C;
        v70[3] = &unk_1001E5258;
        v70[4] = a1;
        [*(id *)(a1 + 8776) setScanForNetworksHandler:v70];
        v69[0] = _NSConcreteStackBlock;
        v69[1] = 3221225472LL;
        v69[2] = sub_1001152D0;
        v69[3] = &unk_1001E5278;
        v69[4] = a1;
        [*(id *)(a1 + 8776) setPerformGASQueryHandler:v69];
        v68[0] = _NSConcreteStackBlock;
        v68[1] = 3221225472LL;
        v68[2] = sub_100115728;
        v68[3] = &unk_1001E5298;
        v68[4] = a1;
        [*(id *)(a1 + 8776) setAllowJoinCandidateHandler:v68];
        v67[0] = _NSConcreteStackBlock;
        v67[1] = 3221225472LL;
        v67[2] = sub_100115B4C;
        v67[3] = &unk_1001E52B8;
        v67[4] = a1;
        [*(id *)(a1 + 8776) setJoinCandidateComparator:v67];
        v66[0] = _NSConcreteStackBlock;
        v66[1] = 3221225472LL;
        v66[2] = sub_100115C24;
        v66[3] = &unk_1001E52D8;
        v66[4] = a1;
        [*(id *)(a1 + 8776) setAssociateToNetworkHandler:v66];
        v65[0] = _NSConcreteStackBlock;
        v65[1] = 3221225472LL;
        v65[2] = sub_1001161A4;
        v65[3] = &unk_1001E52F8;
        v65[4] = a1;
        [*(id *)(a1 + 8776) setAllowAutoHotspotHandler:v65];
        v64[0] = _NSConcreteStackBlock;
        v64[1] = 3221225472LL;
        v64[2] = sub_100116724;
        v64[3] = &unk_1001E5318;
        v64[4] = a1;
        [*(id *)(a1 + 8776) setAllowHotspotHandler:v64];
        v63[0] = _NSConcreteStackBlock;
        v63[1] = 3221225472LL;
        v63[2] = sub_100116D08;
        v63[3] = &unk_1001E5338;
        v63[4] = a1;
        [*(id *)(a1 + 8776) setBrowseForHotspotsHandler:v63];
        v62[0] = _NSConcreteStackBlock;
        v62[1] = 3221225472LL;
        v62[2] = sub_100116F78;
        v62[3] = &unk_1001E5358;
        v62[4] = a1;
        [*(id *)(a1 + 8776) setConnectToHotspotHandler:v62];
        v61[0] = _NSConcreteStackBlock;
        v61[1] = 3221225472LL;
        v61[2] = sub_10011719C;
        v61[3] = &unk_1001E5378;
        v61[4] = a1;
        [*(id *)(a1 + 8776) setEventHandler:v61];
        v60[0] = _NSConcreteStackBlock;
        v60[1] = 3221225472LL;
        v60[2] = sub_100117528;
        v60[3] = &unk_1001E5398;
        v60[4] = a1;
        [*(id *)(a1 + 8776) setUpdateKnownNetworkHandler:v60];
        CFRetain((CFTypeRef)a1);
        [*(id *)(a1 + 8776) setTargetQueue:*(void *)(a1 + 240)];
        [*(id *)(a1 + 8776) setLockdownModeEnabled:byte_100219FA1 != 0];
        id v41 = "SUCCEEDED";
      }

      else
      {
        id v41 = "FAILED";
      }

      int v42 = objc_autoreleasePoolPush();
      if (qword_100219F60) {
        [qword_100219F60 WFLog:@"UAJM setup %s" message:3];
      }
      objc_autoreleasePoolPop(v42);
      sub_1000F5F98(a1, 8uLL);
    }

    if (*(_BYTE *)(a1 + 433)) {
      sub_1000F5218(a1, 6LL);
    }
    if (*(void *)(a1 + 8960))
    {
      CFMutableArrayRef v45 = objc_autoreleasePoolPush();
      if (qword_100219F60) {
        [qword_100219F60 WFLog:@"kernel event monitor already initialized."];
      }
      goto LABEL_94;
    }

    int v43 = socket(32, 3, 1);
    if ((v43 & 0x80000000) == 0)
    {
      unsigned int v44 = v43;
      LODWORD(v72) = 2;
      __int128 v71 = (void **)(&_mh_execute_header + 1);
      if (ioctl(v43, 0x800C6502uLL, &v71))
      {
        CFMutableArrayRef v45 = objc_autoreleasePoolPush();
        uint64_t v46 = qword_100219F60;
        if (qword_100219F60)
        {
          CFIndex v47 = __error();
          CFIndex v59 = strerror(*v47);
          CFIndex v48 = "%s: SIOCSKEVFILT failed (%s)";
LABEL_92:
          uint64_t v49 = (void *)v46;
LABEL_93:
          objc_msgSend(v49, "WFLog:message:", 4, v48, "__WiFiDeviceManagerSetupKernelEventMonitor", v59);
        }
      }

      else
      {
        int v50 = dispatch_source_create( (dispatch_source_type_t)&_dispatch_source_type_read,  v44,  0LL,  *(dispatch_queue_t *)(a1 + 240));
        *(void *)(a1 + 8960) = v50;
        if (v50)
        {
          handler = _NSConcreteStackBlock;
          uint64_t v77 = 3221225472LL;
          unsigned int v78 = sub_10011842C;
          unsigned int v79 = &unk_1001E53E0;
          LODWORD(v80) = v44;
          dispatch_source_set_cancel_handler(v50, &handler);
          unsigned int v51 = *(dispatch_source_s **)(a1 + 8960);
          context.version = (CFIndex)_NSConcreteStackBlock;
          context.info = (void *)3221225472LL;
          context.retain = (const void *(__cdecl *)(const void *))sub_100118434;
          context.release = (void (__cdecl *)(const void *))&unk_1001E43F8;
          unsigned int v82 = v44;
          context.copyDescription = (CFStringRef (__cdecl *)(const void *))a1;
          dispatch_source_set_event_handler(v51, &context);
          dispatch_activate(*(dispatch_object_t *)(a1 + 8960));
          uint64_t v52 = objc_autoreleasePoolPush();
          if (qword_100219F60) {
            [qword_100219F60 WFLog:@"kernel event monitor started"];
          }
          objc_autoreleasePoolPop(v52);
          sub_10011861C(a1);
          goto LABEL_99;
        }

        CFMutableArrayRef v45 = objc_autoreleasePoolPush();
        uint64_t v49 = (void *)qword_100219F60;
        if (qword_100219F60)
        {
          CFIndex v48 = "%s: null manager->kernelEventSource";
          goto LABEL_93;
        }
      }

void sub_1000CE074(uint64_t a1, const void *a2, uint64_t a3, const char *a4, uint64_t a5)
{
  if (!*(_BYTE *)(a1 + 248))
  {
    CFIndex v10 = *(void (**)(uint64_t, const void *, void, void, void, void))(a1 + 3880);
    if (v10) {
      v10(a1, a2, 0LL, 0LL, 0LL, *(void *)(a1 + 3888));
    }
    CFIndex v11 = (const __CFDictionary **)sub_1000DEA34(a1, a2, 1);
    id v12 = objc_autoreleasePoolPush();
    CFIndex v13 = (void *)qword_100219F60;
    if (qword_100219F60)
    {
      CFIndex v14 = sub_10003B050(a3);
      uint64_t v15 = "";
      if (a4) {
        uint64_t v15 = a4;
      }
      [v13 WFLog:3, "%s: network=%@ reason=%@(%d) asked to Disassociate by <%s:%d> ", "WiFiDeviceManagerDisassociate", v11, v14, a3, v15, a5 message];
    }

    objc_autoreleasePoolPop(v12);
    if (*(void *)(a1 + 7320))
    {
      id v16 = (id)sub_100043E8C(*(void *)(a1 + 64));
      uint64_t v17 = *(void *)(a1 + 7320);
      v27[0] = _NSConcreteStackBlock;
      v27[1] = 3221225472LL;
      v27[2] = sub_1000DFBFC;
      v27[3] = &unk_1001E4BB0;
      int v28 = a3;
      v27[4] = v17;
      v27[5] = v16;
      sub_1000D8E24(a1, v11, (uint64_t)v27);
    }

    sub_10004EC50(*(void *)(a1 + 64), a2, 0, a3);
    sub_10001BBC8(*(void *)(a1 + 120), 0LL, 1LL, 0);
    *(_WORD *)(a1 + 6584) = -1;
    uint64_t v18 = objc_autoreleasePoolPush();
    [*(id *)(a1 + 6608) asyncTrackNetworksOfInterest:1];
    objc_autoreleasePoolPop(v18);
    *(_DWORD *)(a1 + 664_Block_object_dispose((const void *)(v1 - 136), 8) = 0;
    if (!*(void *)(a1 + 3864))
    {
LABEL_17:
      if (!v11) {
        return;
      }
      goto LABEL_18;
    }

    if (*(void *)(a1 + 240))
    {
      uint64_t v23 = 0LL;
      id v24 = &v23;
      uint64_t v25 = 0x2020000000LL;
      uint64_t v26 = 0LL;
      if (a2)
      {
        CFTypeRef v19 = CFRetain(a2);
        v24[3] = (uint64_t)v19;
      }

      CFRetain((CFTypeRef)a1);
      CFTypeID v20 = *(dispatch_queue_s **)(a1 + 240);
      block[0] = _NSConcreteStackBlock;
      block[1] = 3221225472LL;
      block[2] = sub_1000DFC4C;
      block[3] = &unk_1001E2D48;
      void block[4] = &v23;
      void block[5] = a1;
      dispatch_async(v20, block);
      _Block_object_dispose(&v23, 8);
      goto LABEL_17;
    }

    int v21 = objc_autoreleasePoolPush();
    if (qword_100219F60) {
      [qword_100219F60 WFLog:@"%s: runloop not yet setup. Invoking didAssociate callback directly." message:3];
    }
    objc_autoreleasePoolPop(v21);
    (*(void (**)(uint64_t, const void *, void, void, void, void))(a1 + 3864))( a1,  a2,  0LL,  0LL,  0LL,  *(void *)(a1 + 3872));
    if (v11) {
LABEL_18:
    }
      CFRelease(v11);
  }

void sub_1000CE31C( _Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, ...)
{
}

void sub_1000CE334(uint64_t a1, int a2)
{
  if (!a1) {
    goto LABEL_12;
  }
  if (a2 && !*(_BYTE *)(a1 + 5422))
  {
    uint64_t v3 = objc_autoreleasePoolPush();
    if (qword_100219F60) {
      [qword_100219F60 WFLog:@"Setting AWDL MAC address in use"];
    }
    objc_autoreleasePoolPop(v3);
    [+[WiFiP2PSPITransactionRequestor shared](WiFiP2PSPITransactionRequestor, "shared") beginTransaction:15 completionHandler:0];
    return;
  }

  if (!a2 && *(_BYTE *)(a1 + 5422))
  {
    uint64_t v4 = objc_autoreleasePoolPush();
    if (qword_100219F60) {
      [qword_100219F60 WFLog:@"Setting AWDL MAC address not in use"];
    }
    objc_autoreleasePoolPop(v4);
    [+[WiFiP2PSPITransactionRequestor shared](WiFiP2PSPITransactionRequestor, "shared") endTransaction:15];
  }

  else
  {
LABEL_12:
    uint64_t v5 = objc_autoreleasePoolPush();
    if (qword_100219F60)
    {
      unsigned int v6 = "";
      if (!a2) {
        unsigned int v6 = "not ";
      }
      [qword_100219F60 WFLog:@"__WiFiDeviceManagerSetAwdlMacAddressInUse: Skip setting AWDL MAC address %sin use, already configured" message:2 v6];
    }

    objc_autoreleasePoolPop(v5);
  }

void sub_1000CE480(uint64_t a1)
{
  if (a1)
  {
    uint64_t v2 = (const void *)sub_100043E8C(*(void *)(a1 + 64));
    uint64_t v3 = (const __CFDictionary **)sub_1000DEA34(a1, v2, 1);
    if (!v2) {
      goto LABEL_19;
    }
    uint64_t v4 = objc_autoreleasePoolPush();
    uint64_t v5 = *(void **)(a1 + 7320);
    if (v5)
    {
LABEL_18:
      [v5 startMonitoringWiFiInterface:v2 withLinkSessionOnly:0];
      [*(id *)(a1 + 7320) setPowerState:*(_DWORD *)(a1 + 20) == 1 forInterface:v2];
      [*(id *)(a1 + 7320) setCurrentApplicationName:*(void *)(a1 + 200) withAttributes:0];
      v26[0] = _NSConcreteStackBlock;
      v26[1] = 3221225472LL;
      __int128 v26[2] = sub_100112A90;
      v26[3] = &unk_1001E4C80;
      v26[4] = a1;
      v26[5] = v2;
      sub_1000D8E24(a1, v3, (uint64_t)v26);
      objc_autoreleasePoolPop(v4);
LABEL_19:
      if (v3) {
        CFRelease(v3);
      }
      return;
    }

    uint64_t v25 = v4;
    int v6 = *(_DWORD *)(a1 + 176);
    *(void *)(a1 + 7320) = +[WiFiUsageMonitor sharedInstance](&OBJC_CLASS___WiFiUsageMonitor, "sharedInstance");
    int v7 = *(_DWORD *)(a1 + 72);
    if (v7 == 4)
    {
      uint64_t v8 = @"en0";
    }

    else
    {
      if (v7 == 7)
      {
        id v24 = 0LL;
LABEL_10:
        SCDynamicStoreRef v9 = objc_autoreleasePoolPush();
        CFIndex v10 = (void *)qword_100219F60;
        if (qword_100219F60)
        {
          int v11 = sub_10006DCC8(*(void *)(a1 + 6744));
          id v12 = @"NO";
          if (!v11) {
            id v12 = @"YES";
          }
          [v10 WFLog:3, "%s: mode:%@", "__WiFiDeviceManagerInitializeWiFiUsageMonitor", v12 message];
        }

        objc_autoreleasePoolPop(v9);
        uint64_t v13 = sub_10001DD0C(*(void *)(a1 + 120));
        uint64_t v15 = v14;
        uint64_t v22 = v13;
        uint64_t v23 = *(void **)(a1 + 7320);
        id v16 = sub_10008FDAC(*(_DWORD *)(a1 + 3344));
        if (*(_BYTE *)(a1 + 3401)) {
          BOOL v17 = 1LL;
        }
        else {
          BOOL v17 = *(_BYTE *)(a1 + 3400) != 0;
        }
        BOOL v18 = *(_BYTE *)(a1 + 3402) != 0;
        BOOL v19 = *(_BYTE *)(a1 + 3456) != 0;
        LOBYTE(v21) = sub_10006DCC8(*(void *)(a1 + 6744)) == 0;
        LOBYTE(v20) = 0;
        [v23 initializeDeviceLockState:v6 != 1 displayState:(v6 - 1) < 2 motionState:v16 callState:v17 mediaState:v18 chargingState:v19 companionConnectionState :v20 andSecondaryInterfaceName:v24 compatibilityMode:v21 badLinkRssi:v22 goodLinkRssi:v15];
        uint64_t v5 = *(void **)(a1 + 7320);
        uint64_t v4 = v25;
        goto LABEL_18;
      }

      uint64_t v8 = *(const __CFString **)(a1 + 6192);
    }

    id v24 = v8;
    goto LABEL_10;
  }

void sub_1000CE6E0(uint64_t a1)
{
  uint64_t v2 = objc_autoreleasePoolPush();
  uint64_t v25 = 0LL;
  uint64_t v26 = &v25;
  uint64_t v27 = 0x3052000000LL;
  int v28 = sub_1000F3F84;
  uint64_t v29 = sub_1000F3F94;
  uint64_t v30 = 0LL;
  if (a1)
  {
    if (sub_1000511F0(*(void *)(a1 + 64)))
    {
      uint64_t v3 = sub_1000F3918(a1, &off_100205840);
      uint64_t v4 = v3;
      if (v3)
      {
        if (CFDictionaryContainsKey(v3, @"networks"))
        {
          id v5 = -[__CFDictionary objectForKeyedSubscript:](v4, "objectForKeyedSubscript:", @"networks");
          id v6 = -[__CFDictionary objectForKeyedSubscript:](v4, "objectForKeyedSubscript:", @"reasons");
          if (v5
            && (int v7 = v6, v8 = [v5 count], v8 == objc_msgSend(v7, "count"))
            && [v7 count])
          {
            id v9 = +[NSMutableArray array](&OBJC_CLASS___NSMutableArray, "array");
            v26[5] = (uint64_t)v9;
            v24[0] = _NSConcreteStackBlock;
            v24[1] = 3221225472LL;
            v24[2] = sub_1000F3FA0;
            v24[3] = &unk_1001E4D60;
            v24[4] = &v25;
            [v5 enumerateObjectsUsingBlock:v24];
          }

          else
          {
            uint64_t v22 = objc_autoreleasePoolPush();
            if (qword_100219F60) {
              [qword_100219F60 WFLog:@"3 No networks denylisted in BSS and AutoJoin denylists" message:@"WiFiDeviceManagerProcessBSSAndAutoJoinDenyListUpdate"];
            }
            objc_autoreleasePoolPop(v22);
          }

          if (*(void *)(a1 + 7280)
            && objc_msgSend( *(id *)(a1 + 7280),  "isEqualToSet:",  +[NSSet setWithArray:](NSSet, "setWithArray:", v26[5])))
          {
            CFIndex v10 = objc_autoreleasePoolPush();
            if (qword_100219F60) {
              [(id)qword_100219F60 WFLog:3, "%s No change in DenyListed BSSIDSet. Skipping driver update. %@", "WiFiDeviceManagerProcessBSSAndAutoJoinDenyListUpdate", *(void *)(a1 + 7280) message];
            }
            objc_autoreleasePoolPop(v10);
          }

          else
          {
            id v11 = +[NSMutableDictionary dictionary](&OBJC_CLASS___NSMutableDictionary, "dictionary");
            id v12 = (_BYTE *)(a1 + 7264);
            uint64_t v13 = (void *)v26[5];
            if (v13 && [v13 count])
            {
              [v11 setObject:[NSNumber numberWithUnsignedChar:3] forKey:@"IO80211InterfaceBssidBlacklistMode"];
              [v11 setObject:v26[5] forKey:@"IO80211InterfaceBssidBlacklistBssids"];
              uint64_t v14 = *(const void **)(a1 + 7280);
              if (v14)
              {
                CFRelease(v14);
                *(void *)(a1 + 7280) = 0LL;
              }

              *(void *)(a1 + 7280) = CFSetCreateCopy( kCFAllocatorDefault,  (CFSetRef)+[NSSet setWithArray:](&OBJC_CLASS___NSSet, "setWithArray:", v26[5]));
              if (*v12)
              {
                uint64_t v15 = objc_autoreleasePoolPush();
                if (qword_100219F60) {
                  [qword_100219F60 WFLog:@"%s: DenyListed BSSIDSet expiry timer already running" message:3];
                }
              }

              else
              {
                _BYTE *v12 = 1;
                BOOL v17 = *(dispatch_source_s **)(a1 + 7272);
                dispatch_time_t v18 = dispatch_time(0LL, 600000000000LL);
                dispatch_source_set_timer(v17, v18, 0xFFFFFFFFFFFFFFFFLL, 0LL);
                uint64_t v15 = objc_autoreleasePoolPush();
                if (qword_100219F60) {
                  [qword_100219F60 WFLog:@"message: DenyListed BSSIDSet expiry timer set to fire in %f seconds from now" message:@"WiFiDeviceManagerProcessBSSAndAutoJoinDenyListUpdate" ];
                }
              }
            }

            else
            {
              [v11 setObject:[NSNumber numberWithUnsignedChar:0] forKey:@"IO80211InterfaceBssidBlacklistMode"];
              id v16 = *(const void **)(a1 + 7280);
              if (v16)
              {
                CFRelease(v16);
                *(void *)(a1 + 7280) = 0LL;
              }

              _BYTE *v12 = 0;
              dispatch_source_set_timer( *(dispatch_source_t *)(a1 + 7272),  0xFFFFFFFFFFFFFFFFLL,  0xFFFFFFFFFFFFFFFFLL,  0LL);
              uint64_t v15 = objc_autoreleasePoolPush();
              if (qword_100219F60) {
                [qword_100219F60 WFLog:@"%s: DenyListed BSSIDSet expiry timer set to fire never" message:3];
              }
            }

            objc_autoreleasePoolPop(v15);
            BOOL v19 = objc_autoreleasePoolPush();
            if (qword_100219F60) {
              [(id)qword_100219F60 WFLog:3, "%s: %@", "WiFiDeviceManagerProcessBSSAndAutoJoinDenyListUpdate", v11 message];
            }
            objc_autoreleasePoolPop(v19);
            uint64_t v20 = *(void *)(a1 + 64);
            uint64_t v21 = (const void *)sub_100043E8C(v20);
            sub_10003EC6C(v20, v21, 372LL, 0LL, (uint64_t)v11);
          }
        }

        else
        {
          uint64_t v23 = objc_autoreleasePoolPush();
          if (qword_100219F60) {
            [qword_100219F60 WFLog:@"message:%s networks key missing" message:@"WiFiDeviceManagerProcessBSSAndAutoJoinDenyListUpdate"];
          }
          objc_autoreleasePoolPop(v23);
        }

        CFRelease(v4);
      }
    }
  }

  _Block_object_dispose(&v25, 8);
  objc_autoreleasePoolPop(v2);
}

void sub_1000CEB80( _Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, ...)
{
}

void sub_1000CEBA4(uint64_t a1)
{
  uint64_t v2 = *(void *)(a1 + 240);
  if (v2) {
    sub_1000CEC04(a1, v2);
  }
  uint64_t v3 = *(const void **)(a1 + 5456);
  if (v3)
  {
    CFRelease(v3);
    *(void *)(a1 + 5456) = 0LL;
  }

  uint64_t v4 = *(const void **)(a1 + 5576);
  if (v4)
  {
    CFRelease(v4);
    *(void *)(a1 + 5576) = 0LL;
  }

  sub_100048B6C(*(void *)(a1 + 64));
  *(_BYTE *)(a1 + 16) = 0;
}

void sub_1000CEC04(uint64_t a1, uint64_t a2)
{
  uint64_t v4 = objc_autoreleasePoolPush();
  if (qword_100219F60) {
    [qword_100219F60 WFLog:@"%s: entering" message:4];
  }
  objc_autoreleasePoolPop(v4);
  if (*(_BYTE *)(a1 + 16) && *(void *)(a1 + 240) == a2)
  {
    sub_1000D004C((const void *)a1);
    LocalCenter = CFNotificationCenterGetLocalCenter();
    CFNotificationCenterRemoveObserver( LocalCenter,  (const void *)a1,  @"com.apple.wifid.wifiroammanagerroamnotification",  0LL);
    DarwinNotifyCenter = CFNotificationCenterGetDarwinNotifyCenter();
    CFNotificationCenterRemoveObserver( DarwinNotifyCenter,  (const void *)a1,  @"com.apple.siri.connection.timeout",  0LL);
    id v8 = CFNotificationCenterGetDarwinNotifyCenter();
    CFNotificationCenterRemoveObserver( v8,  (const void *)a1,  @"com.apple.apsd.connection-failure-notification",  0LL);
    id v9 = CFNotificationCenterGetDarwinNotifyCenter();
    CFNotificationCenterRemoveObserver(v9, (const void *)a1, @"com.apple.airplay.connection.stalled", 0LL);
    CFIndex v10 = CFNotificationCenterGetDarwinNotifyCenter();
    CFNotificationCenterRemoveObserver(v10, (const void *)a1, @"com.apple.airplay.bufferedaudiounderrun", 0LL);
    id v11 = CFNotificationCenterGetDarwinNotifyCenter();
    CFNotificationCenterRemoveObserver(v11, (const void *)a1, @"com.apple.airplay.realTimeAudioUnderrun", 0LL);
    SCDynamicStoreSetDispatchQueue(*(SCDynamicStoreRef *)(a1 + 5432), 0LL);
    id v12 = *(dispatch_source_s **)(a1 + 360);
    if (v12) {
      dispatch_source_cancel(v12);
    }
    uint64_t v13 = *(dispatch_source_s **)(a1 + 312);
    if (v13) {
      dispatch_source_cancel(v13);
    }
    uint64_t v14 = *(dispatch_source_s **)(a1 + 5232);
    if (v14) {
      dispatch_source_cancel(v14);
    }
    uint64_t v15 = *(dispatch_source_s **)(a1 + 5312);
    if (v15) {
      dispatch_source_cancel(v15);
    }
    id v16 = *(dispatch_source_s **)(a1 + 5504);
    if (v16) {
      dispatch_source_cancel(v16);
    }
    BOOL v17 = *(dispatch_source_s **)(a1 + 8544);
    if (v17) {
      dispatch_source_cancel(v17);
    }
    dispatch_time_t v18 = *(dispatch_source_s **)(a1 + 8584);
    if (v18) {
      dispatch_source_cancel(v18);
    }
    BOOL v19 = *(dispatch_source_s **)(a1 + 992);
    if (v19) {
      dispatch_source_cancel(v19);
    }
    uint64_t v20 = *(dispatch_source_s **)(a1 + 1048);
    if (v20) {
      dispatch_source_cancel(v20);
    }
    uint64_t v21 = *(dispatch_source_s **)(a1 + 5520);
    if (v21) {
      dispatch_source_cancel(v21);
    }
    uint64_t v22 = *(dispatch_source_s **)(a1 + 6760);
    if (v22) {
      dispatch_source_cancel(v22);
    }
    uint64_t v23 = *(dispatch_source_s **)(a1 + 6768);
    if (v23) {
      dispatch_source_cancel(v23);
    }
    id v24 = *(dispatch_source_s **)(a1 + 7272);
    if (v24) {
      dispatch_source_cancel(v24);
    }
    uint64_t v25 = *(dispatch_source_s **)(a1 + 7296);
    if (v25) {
      dispatch_source_cancel(v25);
    }
    uint64_t v26 = *(dispatch_source_s **)(a1 + 7168);
    if (v26) {
      dispatch_source_cancel(v26);
    }
    uint64_t v27 = *(dispatch_source_s **)(a1 + 7208);
    if (v27) {
      dispatch_source_cancel(v27);
    }
    int v28 = *(dispatch_source_s **)(a1 + 8920);
    if (v28)
    {
      dispatch_source_cancel(v28);
      dispatch_release(*(dispatch_object_t *)(a1 + 8920));
      *(void *)(a1 + 8920) = 0LL;
    }

    uint64_t v29 = *(void **)(a1 + 7024);
    if (v29)
    {
      [v29 abort];

      *(void *)(a1 + 7024) = 0LL;
    }

    uint64_t v30 = *(dispatch_source_s **)(a1 + 8936);
    if (v30) {
      dispatch_source_cancel(v30);
    }
    uint64_t v31 = *(dispatch_source_s **)(a1 + 8944);
    if (v31) {
      dispatch_source_cancel(v31);
    }
    uint64_t v32 = *(dispatch_source_s **)(a1 + 3760);
    if (v32)
    {
      dispatch_source_cancel(v32);
      dispatch_release(*(dispatch_object_t *)(a1 + 3760));
      *(void *)(a1 + 3760) = 0LL;
    }

    if (sub_10004B9C0(*(void *)(a1 + 64)))
    {
      uint64_t v33 = (const void *)sub_100040CF8(*(void *)(a1 + 64));
      sub_1000D00D8(a1, v33);
    }

    if (+[WiFiAIRAgent sharedInstance](&OBJC_CLASS___WiFiAIRAgent, "sharedInstance")
      && -[WiFiAIRAgent isInterfaceRankingInProgress]( +[WiFiAIRAgent sharedInstance](&OBJC_CLASS___WiFiAIRAgent, "sharedInstance"),  "isInterfaceRankingInProgress"))
    {
      sub_10001DE98();
      -[WiFiAIRAgent terminateRequest]( +[WiFiAIRAgent sharedInstance](&OBJC_CLASS___WiFiAIRAgent, "sharedInstance"),  "terminateRequest");
    }

    sub_100048BDC(*(void *)(a1 + 64));
    sub_10001653C(*(void *)(a1 + 120), *(void *)(a1 + 240));
    if (_os_feature_enabled_impl("CoreWiFi", "UnifiedAutoJoin"))
    {
      [*(id *)(a1 + 8776) setEventHandler:0];
      [*(id *)(a1 + 8776) invalidate];

      *(void *)(a1 + 8776) = 0LL;
      uint64_t v34 = *(void *)(a1 + 8880);
      if (v34)
      {
        (*(void (**)(uint64_t, NSError *, void, void))(v34 + 16))( v34,  +[NSError errorWithDomain:code:userInfo:]( &OBJC_CLASS___NSError,  "errorWithDomain:code:userInfo:",  NSPOSIXErrorDomain,  58LL,  0LL),  0LL,  0LL);
        _Block_release(*(const void **)(a1 + 8880));
        *(void *)(a1 + 8880) = 0LL;

        *(void *)(a1 + 888_Block_object_dispose(va, 8) = 0LL;
      }

      uint64_t v35 = *(void *)(a1 + 8896);
      if (v35)
      {
        (*(void (**)(uint64_t, NSError *, void, void))(v35 + 16))( v35,  +[NSError errorWithDomain:code:userInfo:]( &OBJC_CLASS___NSError,  "errorWithDomain:code:userInfo:",  NSPOSIXErrorDomain,  58LL,  0LL),  0LL,  0LL);
        _Block_release(*(const void **)(a1 + 8896));
        *(void *)(a1 + 8896) = 0LL;

        *(void *)(a1 + 8904) = 0LL;
      }

      uint64_t v36 = *(void *)(a1 + 8792);
      if (v36)
      {
        (*(void (**)(uint64_t, NSError *))(v36 + 16))( v36,  +[NSError errorWithDomain:code:userInfo:]( &OBJC_CLASS___NSError,  "errorWithDomain:code:userInfo:",  NSPOSIXErrorDomain,  58LL,  0LL));
        _Block_release(*(const void **)(a1 + 8792));
        *(void *)(a1 + 8792) = 0LL;
        double v37 = *(const void **)(a1 + 8784);
        if (v37)
        {
          CFRelease(v37);
          *(void *)(a1 + 8784) = 0LL;
        }
      }

      uint64_t v38 = *(void *)(a1 + 8816);
      if (v38)
      {
        (*(void (**)(uint64_t, NSError *, void))(v38 + 16))( v38,  +[NSError errorWithDomain:code:userInfo:]( &OBJC_CLASS___NSError,  "errorWithDomain:code:userInfo:",  NSPOSIXErrorDomain,  58LL,  0LL),  0LL);
        _Block_release(*(const void **)(a1 + 8816));
        *(void *)(a1 + 8816) = 0LL;
      }

      uint64_t v39 = *(void *)(a1 + 8808);
      if (v39)
      {
        (*(void (**)(uint64_t, NSError *))(v39 + 16))( v39,  +[NSError errorWithDomain:code:userInfo:]( &OBJC_CLASS___NSError,  "errorWithDomain:code:userInfo:",  NSPOSIXErrorDomain,  58LL,  0LL));
        _Block_release(*(const void **)(a1 + 8808));
        *(void *)(a1 + 880_Block_object_dispose(va, 8) = 0LL;

        *(void *)(a1 + 8800) = 0LL;
      }

      *(void *)(a1 + 884_Block_object_dispose(va, 8) = 0LL;
      *(void *)(a1 + 8856) = 0LL;
      CFRelease((CFTypeRef)a1);
    }

    -[WiFiUserInteractionMonitor unregisterStateChangeCallback:]( +[WiFiUserInteractionMonitor sharedInstance](&OBJC_CLASS___WiFiUserInteractionMonitor, "sharedInstance"),  "unregisterStateChangeCallback:",  a1);
    sub_1000D0210(a1);
    *(void *)(a1 + 240) = 0LL;
    id v5 = objc_autoreleasePoolPush();
    if (qword_100219F60) {
      [qword_100219F60 WFLog:@"%s: exiting" message:4];
    }
  }

  else
  {
    id v5 = objc_autoreleasePoolPush();
    if (qword_100219F60) {
      [qword_100219F60 WFLog:@"%s: exiting, Error: not opened or unmatched queues" message:4];
    }
  }

  objc_autoreleasePoolPop(v5);
}

uint64_t sub_1000CF0F4(uint64_t a1)
{
  return sub_10004B9CC(*(void *)(a1 + 64));
}

void sub_1000CF0FC(int a1, CFArrayRef theArray, uint64_t a3)
{
  if (!a3)
  {
    uint64_t v14 = objc_autoreleasePoolPush();
    if (qword_100219F60) {
      objc_msgSend( (id)qword_100219F60,  "WFLog:message:",  4,  "__WiFiDeviceManagerDynamicStoreCallback: manager reference is NULL",  v27,  v28,  v29,  v30);
    }
LABEL_23:
    objc_autoreleasePoolPop(v14);
    return;
  }

  if (theArray && CFArrayGetCount(theArray) >= 1)
  {
    CFIndex v5 = 0LL;
    while (1)
    {
      ValueAtIndex = CFArrayGetValueAtIndex(theArray, v5);
      if (ValueAtIndex)
      {
        int v7 = ValueAtIndex;
        CFTypeID TypeID = CFStringGetTypeID();
        if (CFGetTypeID(v7) == TypeID)
        {
          if (CFEqual(v7, @"com.apple.sharing")) {
            break;
          }
        }
      }

      if (++v5 >= CFArrayGetCount(theArray)) {
        goto LABEL_9;
      }
    }

    if (*(_BYTE *)(a3 + 208)) {
      BOOL v16 = *(_BYTE *)(a3 + 3456) == 0;
    }
    else {
      BOOL v16 = 0;
    }
    BOOL v17 = SCDynamicStoreKeyCreate(kCFAllocatorDefault, @"%@", @"com.apple.sharing");
    if (v17)
    {
      dispatch_time_t v18 = v17;
      BOOL v19 = (const __CFDictionary *)SCDynamicStoreCopyValue(*(SCDynamicStoreRef *)(a3 + 5432), v17);
      if (v19)
      {
        uint64_t v20 = v19;
        CFBooleanRef Value = CFDictionaryGetValue(v19, @"AutoUnlockInProgress");
        if (Value && CFEqual(Value, kCFBooleanTrue))
        {
          if (*(_DWORD *)(a3 + 3272))
          {
            uint64_t v22 = (const void *)sub_10004CE2C(*(void *)(a3 + 64));
            sub_1000DFD78((uint64_t *)a3, v22, 1014LL);
            sub_1000D0428(a3);
          }

          uint64_t v23 = 1LL;
        }

        else
        {
          id v24 = objc_autoreleasePoolPush();
          if (qword_100219F60) {
            [qword_100219F60 WFLog:@"Auto-unlock not in progress. Resuming auto-join attempt."];
          }
          objc_autoreleasePoolPop(v24);
          uint64_t v23 = 0LL;
        }

        sub_1000E953C(a3, v23);
        CFRelease(v20);
      }

      else
      {
        uint64_t v23 = 0LL;
      }

      CFRelease(v18);
    }

    else
    {
      uint64_t v23 = 0LL;
    }

    if ((_DWORD)v23) {
      int v25 = 1;
    }
    else {
      int v25 = v16;
    }
    sub_1000CE334(a3, v25);
    uint64_t v14 = objc_autoreleasePoolPush();
    if (qword_100219F60) {
      [qword_100219F60 WFLog:@"__WiFiDeviceManagerDynamicStoreCallback" message:@"%s: awdlMacAddressInUse=%d isDeviceLockedAndSuspendable=%d shouldDisassociate=%d" args:@[v23, v16, 0]];
    }
    goto LABEL_23;
  }

void sub_1000CF5E4(uint64_t a1)
{
  CFMutableArrayRef Mutable = CFArrayCreateMutable(0LL, 0LL, &kCFTypeArrayCallBacks);
  if (Mutable)
  {
    uint64_t v3 = Mutable;
    CFStringRef v4 = SCDynamicStoreKeyCreate(kCFAllocatorDefault, @"com.apple.sharing");
    if (v4)
    {
      CFStringRef v5 = v4;
      CFArrayAppendValue(v3, v4);
      CFRelease(v5);
    }

    if (CFArrayGetCount(v3) >= 1) {
      SCDynamicStoreSetNotificationKeys(*(SCDynamicStoreRef *)(a1 + 5432), v3, 0LL);
    }
    CFRelease(v3);
  }

void sub_1000CF68C(uint64_t a1, uint64_t a2)
{
  if (a2)
  {
    sub_1000CF5E4(a2);
  }

  else
  {
    uint64_t v2 = objc_autoreleasePoolPush();
    if (qword_100219F60) {
      [(id)qword_100219F60 WFLog:4 message:"Cannot reconnect to the dynamic store - info is NULL"];
    }
    objc_autoreleasePoolPop(v2);
  }

uint64_t sub_1000CF6DC(uint64_t result)
{
  if (result) {
    return sub_100055A54(*(void *)(result + 64));
  }
  return result;
}

void sub_1000CF6EC(uint64_t a1, const void *a2, uint64_t a3)
{
  CFStringRef v5 = objc_autoreleasePoolPush();
  if (a2 && &_MRMediaRemoteGetNowPlayingApplicationPlaybackState)
  {
    id v6 = objc_autoreleasePoolPush();
    if (qword_100219F60) {
      [(id)qword_100219F60 WFLog:3, "%s: %@", "__WiFiDeviceManagerNowPlayingStateDidChange", a3 message];
    }
    objc_autoreleasePoolPop(v6);
    CFRetain(a2);
    v7[0] = _NSConcreteStackBlock;
    v7[1] = 3221225472LL;
    v7[2] = sub_10010F480;
    v7[3] = &unk_1001E5128;
    v7[4] = a2;
    MRMediaRemoteGetNowPlayingApplicationPlaybackState(qword_100219F80, v7);
  }

  objc_autoreleasePoolPop(v5);
}

uint64_t sub_1000CF7C4(uint64_t a1, char a2)
{
  *(_BYTE *)(a1 + 3404) = a2;
  uint64_t v3 = objc_autoreleasePoolPush();
  if (qword_100219F60)
  {
    if (*(_BYTE *)(a1 + 3404)) {
      CFStringRef v4 = "TRUE";
    }
    else {
      CFStringRef v4 = "FALSE";
    }
    [qword_100219F60 WFLog:@"%s: isOnMovingNetwork: %s" message:3,  "__WiFiDeviceManagerMovingNetworkNotifyFamily",  v4];
  }

  objc_autoreleasePoolPop(v3);
  uint64_t v5 = *(void *)(a1 + 64);
  id v6 = (const void *)sub_100043E8C(v5);
  if (*(_BYTE *)(a1 + 3404)) {
    int v7 = (uint64_t *)&kCFBooleanTrue;
  }
  else {
    int v7 = (uint64_t *)&kCFBooleanFalse;
  }
  return sub_10003EC6C(v5, v6, 471LL, 0LL, *v7);
}

double sub_1000CF880(uint64_t a1, char a2, int a3)
{
  uint64_t v3 = (unsigned __int8 *)(a1 + 7008);
  int v4 = *(unsigned __int8 *)(a1 + 7009);
  if (a3) {
    unsigned __int8 v5 = v4 | a2;
  }
  else {
    unsigned __int8 v5 = v4 & ~a2;
  }
  if (v5 == v4) {
    return result;
  }
  uint64_t v9 = objc_autoreleasePoolPush();
  CFIndex v10 = (void *)qword_100219F60;
  if (qword_100219F60)
  {
    id v11 = sub_10003B244(v3[1]);
    [v10 WFLog:3, "%s: current state %@(%d) new state %@(%d)", "WiFiDeviceManagerUpdateOpMode", v11, v3[1], sub_10003B244(v5), v5 message];
  }

  objc_autoreleasePoolPop(v9);
  v3[1] = v5;
  uint64_t v13 = *(void (**)(uint64_t, void, void, void))(a1 + 4640);
  if (v13) {
    v13(a1, *v3, v5, *(void *)(a1 + 4648));
  }
  if ((a2 & 4) != 0)
  {
    uint64_t v14 = (const void *)sub_100043E8C(*(void *)(a1 + 64));
    uint64_t v15 = sub_1000DEA34(a1, v14, 1);
    BOOL v16 = v15;
    if (*v3 && (v5 & 1) != 0 && v15)
    {
      if (a3) {
        uint64_t v17 = 3LL;
      }
      else {
        uint64_t v17 = 0LL;
      }
      sub_1000D36F4((void *)a1, v15, 1, v17);
      dispatch_time_t v18 = objc_autoreleasePoolPush();
      if (qword_100219F60)
      {
        BOOL v19 = "kSCNetworkServicePrimaryRankNever";
        if (!a3) {
          BOOL v19 = "kSCNetworkServicePrimaryRankDefault";
        }
        [qword_100219F60 WFLog:@"%s: setting interface rank %s : reason %s ",  "WiFiDeviceManagerUpdateOpMode",  v19,  " Concurrency"];
      }

      objc_autoreleasePoolPop(v18);
    }

    else if (!v15)
    {
LABEL_23:
      sub_1000F1468(a1);
      goto LABEL_24;
    }

    CFRelease(v16);
    goto LABEL_23;
  }

void sub_1000CFA74(unsigned __int8 *a1)
{
  if (&_MRMediaRemoteGetNowPlayingApplicationPlaybackState)
  {
    uint64_t v2 = objc_autoreleasePoolPush();
    if (qword_100219F60) {
      [qword_100219F60 WFLog:@"__WiFiDeviceManagerAddMediaPlaybackStateObserver, isCarplay %d, user forced %d" message:3, "%s, isCarplay %d, user forced %d", "__WiFiDeviceManagerAddMediaPlaybackStateObserver", a1[5488], a1[3405]];
    }
    objc_autoreleasePoolPop(v2);
    if (!a1[5488] && !a1[3405])
    {
      MRMediaRemoteRegisterForNowPlayingNotifications(qword_100219F80);
      LocalCenter = CFNotificationCenterGetLocalCenter();
      CFNotificationCenterAddObserver( LocalCenter,  a1,  (CFNotificationCallback)sub_1000CF6EC,  kMRMediaRemoteNowPlayingApplicationIsPlayingDidChangeNotification,  0LL,  CFNotificationSuspensionBehaviorDeliverImmediately);
      sub_1000CF6EC(v4, a1, (uint64_t)@"Reading Initial State");
    }
  }

void sub_1000CFB5C(uint64_t a1, uint64_t a2, CFTypeRef cf)
{
  if (a1 && *(_BYTE *)(a1 + 433))
  {
    if ((_DWORD)a2 == 1)
    {
      if (!sub_1000F5E14(a1, cf)) {
        return;
      }
      a2 = 1LL;
    }

    sub_1000F5218(a1, a2);
  }

void sub_1000CFBB0(uint64_t a1, uint64_t a2)
{
  uint64_t v3 = objc_autoreleasePoolPush();
  if (qword_100219F60) {
    [qword_100219F60 WFLog:@"%s: Fault Notification com.apple.siri.connection.timeout" message:3];
  }
  objc_autoreleasePoolPop(v3);
  if (a2)
  {
    uint64_t v4 = *(dispatch_queue_s **)(a2 + 240);
    block[0] = _NSConcreteStackBlock;
    block[1] = 3221225472LL;
    block[2] = sub_100118A30;
    block[3] = &unk_1001E2620;
    void block[4] = a2;
    dispatch_async(v4, block);
  }

  else
  {
    unsigned __int8 v5 = objc_autoreleasePoolPush();
    if (qword_100219F60) {
      [qword_100219F60 WFLog:@"__WiFiDeviceManagerHandleSiriTimedOutNotification: null manager."];
    }
    objc_autoreleasePoolPop(v5);
  }

void sub_1000CFC9C(uint64_t a1, uint64_t a2)
{
  uint64_t v3 = objc_autoreleasePoolPush();
  if (qword_100219F60) {
    [qword_100219F60 WFLog:@"Fault Notification com.apple.apsd.connection-failure-notification" message:3];
  }
  objc_autoreleasePoolPop(v3);
  if (a2)
  {
    uint64_t v4 = *(dispatch_queue_s **)(a2 + 240);
    block[0] = _NSConcreteStackBlock;
    block[1] = 3221225472LL;
    block[2] = sub_100118B74;
    block[3] = &unk_1001E2620;
    void block[4] = a2;
    dispatch_async(v4, block);
  }

  else
  {
    unsigned __int8 v5 = objc_autoreleasePoolPush();
    if (qword_100219F60) {
      [qword_100219F60 WFLog:@"__WiFiDeviceManagerHandleApsdTimedOutNotification: null manager."];
    }
    objc_autoreleasePoolPop(v5);
  }

void sub_1000CFD88(uint64_t a1, uint64_t a2)
{
  uint64_t v3 = objc_autoreleasePoolPush();
  if (qword_100219F60) {
    [qword_100219F60 WFLog:@"Fault Notification com.apple.airplay.connection.stalled" message:3];
  }
  objc_autoreleasePoolPop(v3);
  if (a2)
  {
    uint64_t v4 = *(dispatch_queue_s **)(a2 + 240);
    block[0] = _NSConcreteStackBlock;
    block[1] = 3221225472LL;
    block[2] = sub_100118CB8;
    block[3] = &unk_1001E2620;
    void block[4] = a2;
    dispatch_async(v4, block);
  }

  else
  {
    unsigned __int8 v5 = objc_autoreleasePoolPush();
    if (qword_100219F60) {
      [qword_100219F60 WFLog:@"%s: null manager." message:3];
    }
    objc_autoreleasePoolPop(v5);
  }

void sub_1000CFE74(uint64_t a1, uint64_t a2)
{
  uint64_t v3 = objc_autoreleasePoolPush();
  if (qword_100219F60) {
    [qword_100219F60 WFLog:@"%s: Fault Notification com.apple.airplay.bufferedaudiounderrun" message:3];
  }
  objc_autoreleasePoolPop(v3);
  if (a2)
  {
    uint64_t v4 = *(dispatch_queue_s **)(a2 + 240);
    block[0] = _NSConcreteStackBlock;
    block[1] = 3221225472LL;
    block[2] = sub_100118DFC;
    block[3] = &unk_1001E2620;
    void block[4] = a2;
    dispatch_async(v4, block);
  }

  else
  {
    unsigned __int8 v5 = objc_autoreleasePoolPush();
    if (qword_100219F60) {
      [qword_100219F60 WFLog:@"%s: null manager." message:3];
    }
    objc_autoreleasePoolPop(v5);
  }

void sub_1000CFF60(uint64_t a1, uint64_t a2)
{
  uint64_t v3 = objc_autoreleasePoolPush();
  if (qword_100219F60) {
    [qword_100219F60 WFLog:@"Fault Notification com.apple.airplay.realTimeAudioUnderrun" message:3];
  }
  objc_autoreleasePoolPop(v3);
  if (a2)
  {
    uint64_t v4 = *(dispatch_queue_s **)(a2 + 240);
    block[0] = _NSConcreteStackBlock;
    block[1] = 3221225472LL;
    block[2] = sub_100118F34;
    block[3] = &unk_1001E2620;
    void block[4] = a2;
    dispatch_async(v4, block);
  }

  else
  {
    unsigned __int8 v5 = objc_autoreleasePoolPush();
    if (qword_100219F60) {
      [qword_100219F60 WFLog:@"__WiFiDeviceManagerHandleAirplayRealtimeAudioUnderrunNotification: null manager."];
    }
    objc_autoreleasePoolPop(v5);
  }

void sub_1000D004C(const void *a1)
{
  if (&_MRMediaRemoteGetNowPlayingApplicationPlaybackState)
  {
    uint64_t v2 = objc_autoreleasePoolPush();
    if (qword_100219F60) {
      [qword_100219F60 WFLog:@"__WiFiDeviceManagerRemoveMediaPlaybackStateObserver"];
    }
    objc_autoreleasePoolPop(v2);
    MRMediaRemoteUnregisterForNowPlayingNotifications();
    LocalCenter = CFNotificationCenterGetLocalCenter();
    CFNotificationCenterRemoveObserver( LocalCenter,  a1,  kMRMediaRemoteNowPlayingApplicationIsPlayingDidChangeNotification,  0LL);
  }

void sub_1000D00D8(uint64_t a1, const void *a2)
{
  if (*(_DWORD *)(a1 + 5416))
  {
    if (sub_1000DF3FC(a1))
    {
      uint64_t v4 = sub_1000E6404(a1, 2);
      if (v4)
      {
        unsigned __int8 v5 = v4;
        if (sub_1000E6064(a1, a2, v4, 0LL, 0LL))
        {
          id v6 = objc_autoreleasePoolPush();
          if (qword_100219F60) {
            [qword_100219F60 WFLog:@"__WiFideviceManagerTeardownAllAwdlSession: Failed remove AWDL network"];
          }
          objc_autoreleasePoolPop(v6);
        }

        CFRelease(v5);
      }
    }

    if (sub_1000DF3D8(a1))
    {
      int v7 = sub_1000E6404(a1, 1);
      if (v7)
      {
        id v8 = v7;
        if (sub_1000E6064(a1, a2, v7, 0LL, 0LL))
        {
          uint64_t v9 = objc_autoreleasePoolPush();
          if (qword_100219F60) {
            [qword_100219F60 WFLog:@"__WiFideviceManagerTeardownAllAwdlSession: Failed remove AWDL network"];
          }
          objc_autoreleasePoolPop(v9);
        }

        CFRelease(v8);
      }
    }

    *(_DWORD *)(a1 + 5416) = 0;
  }

void sub_1000D0210(uint64_t a1)
{
  if (a1)
  {
    uint64_t v2 = *(dispatch_source_s **)(a1 + 8960);
    if (v2)
    {
      dispatch_source_cancel(v2);
      dispatch_release(*(dispatch_object_t *)(a1 + 8960));
      *(void *)(a1 + 8960) = 0LL;
      uint64_t v3 = objc_autoreleasePoolPush();
      if (qword_100219F60) {
        [qword_100219F60 WFLog:@"kernel event monitor stopped"];
      }
    }

    else
    {
      uint64_t v3 = objc_autoreleasePoolPush();
      if (qword_100219F60) {
        [qword_100219F60 WFLog:@"kernel event monitor not initialized."];
      }
    }

    objc_autoreleasePoolPop(v3);
  }

void sub_1000D02BC(uint64_t a1)
{
  if (!*(_BYTE *)(a1 + 3297))
  {
    *(_BYTE *)(a1 + 3297) = 1;
    if (*(void *)(a1 + 5400))
    {
      uint64_t v2 = objc_autoreleasePoolPush();
      uint64_t v3 = (uint64_t)[*(id *)(a1 + 5400) requestPowerResource:0 withDetails:0];
      objc_autoreleasePoolPop(v2);
      if (!(_DWORD)v3) {
        return;
      }
    }

    else
    {
      *(_DWORD *)(a1 + 192) = 0;
      if (_os_feature_enabled_impl("CoreWiFi", "UnifiedAutoJoin"))
      {
        sub_1000F5F98(a1, 0xFuLL);
      }

      else
      {
        [+[WiFiXPCManager sharedXPCManager](WiFiXPCManager, "sharedXPCManager") autoJoinStartedWithTrigger:15 interfaceName:sub_100043E8C(*(void *)(a1 + 64))];
        sub_1000D0A5C(a1, 2LL, "WiFiDeviceManagerEnable");
      }

      uint64_t v3 = 4294963365LL;
    }

    uint64_t v4 = objc_autoreleasePoolPush();
    if (qword_100219F60) {
      [qword_100219F60 WFLog:@"WiFiBatteryMgmt : Requested resource but none available. Will not autojoin. Nothing to do here. %d" message:3 v3];
    }
    objc_autoreleasePoolPop(v4);
  }

void sub_1000D03D8(uint64_t a1, uint64_t a2)
{
}

void sub_1000D03E4(uint64_t a1)
{
  if (*(_BYTE *)(a1 + 3297))
  {
    *(_BYTE *)(a1 + 3297) = 0;
    sub_1000D0428();
    if (*(void *)(a1 + 5400)) {
      sub_1000D0894(a1);
    }
  }

void sub_1000D0428(uint64_t a1)
{
  if (!*(_DWORD *)(a1 + 3272))
  {
    if ((_os_feature_enabled_impl("CoreWiFi", "UnifiedAutoJoin") & 1) == 0) {
      return;
    }
    goto LABEL_20;
  }

  uint64_t v2 = *(const void **)(a1 + 1104);
  if (v2)
  {
    CFRelease(v2);
    *(void *)(a1 + 1104) = 0LL;
  }

  sub_1000D157C(a1, 0);
  sub_10004EC48(*(void *)(a1 + 64));
  int v3 = *(_DWORD *)(a1 + 3272);
  if ((v3 - 16) <= 4)
  {
    uint64_t v4 = objc_autoreleasePoolPush();
    if (qword_100219F60) {
      [(id)qword_100219F60 WFLog:3, "%s: in %@ state, aborting", "WiFiDeviceManagerAbort", sub_1000BDC98(*(_DWORD *)(a1 + 3272)) message];
    }
    objc_autoreleasePoolPop(v4);
    sub_1000CABEC(a1, 0);
    *(_BYTE *)(a1 + 6960) = 0;
    int v3 = *(_DWORD *)(a1 + 3272);
  }

  if ((v3 - 12) >= 0xFFFFFFF6)
  {
    unsigned __int8 v5 = objc_autoreleasePoolPush();
    if (qword_100219F60) {
      [qword_100219F60 WFLog:@"Scanning in progress, next system wake should not defer AJ scan"];
    }
    objc_autoreleasePoolPop(v5);
    *(void *)(a1 + 7256) = 0LL;
  }

  sub_10004CA9C(*(void *)(a1 + 64), *(void *)(a1 + 3304));
  *(void *)(a1 + 3304) = 0LL;
  if (*(_DWORD *)(a1 + 3272) == 1) {
    dispatch_source_set_timer(*(dispatch_source_t *)(a1 + 312), 0xFFFFFFFFFFFFFFFFLL, 0xFFFFFFFFFFFFFFFFLL, 0LL);
  }
  *(_DWORD *)(a1 + 3272) = 0;
  uint64_t v6 = *(void *)(a1 + 224);
  if (!v6)
  {
LABEL_20:
    if (_os_feature_enabled_impl("CoreWiFi", "UnifiedAutoJoin"))
    {
      id v8 = *(void **)(a1 + 8776);
      NSErrorUserInfoKey v22 = NSLocalizedDescriptionKey;
      uint64_t v23 = @"WiFiDeviceManagerAbort()";
      objc_msgSend( v8,  "cancelAutoJoinWithUUID:error:reply:",  0,  +[NSError errorWithDomain:code:userInfo:]( NSError,  "errorWithDomain:code:userInfo:",  NSPOSIXErrorDomain,  53,  +[NSDictionary dictionaryWithObjects:forKeys:count:]( NSDictionary,  "dictionaryWithObjects:forKeys:count:",  &v23,  &v22,  1)),  0);
      uint64_t v9 = *(void *)(a1 + 8880);
      if (v9)
      {
        (*(void (**)(uint64_t, NSError *, void, void))(v9 + 16))( v9,  +[NSError errorWithDomain:code:userInfo:]( &OBJC_CLASS___NSError,  "errorWithDomain:code:userInfo:",  NSPOSIXErrorDomain,  89LL,  0LL),  0LL,  0LL);
        _Block_release(*(const void **)(a1 + 8880));
        *(void *)(a1 + 8880) = 0LL;

        *(void *)(a1 + 888_Block_object_dispose(va, 8) = 0LL;
      }

      uint64_t v10 = *(void *)(a1 + 8896);
      if (v10)
      {
        (*(void (**)(uint64_t, NSError *, void, void))(v10 + 16))( v10,  +[NSError errorWithDomain:code:userInfo:]( &OBJC_CLASS___NSError,  "errorWithDomain:code:userInfo:",  NSPOSIXErrorDomain,  89LL,  0LL),  0LL,  0LL);
        _Block_release(*(const void **)(a1 + 8896));
        *(void *)(a1 + 8896) = 0LL;

        *(void *)(a1 + 8904) = 0LL;
      }

      uint64_t v11 = *(void *)(a1 + 8792);
      if (v11)
      {
        (*(void (**)(uint64_t, NSError *))(v11 + 16))( v11,  +[NSError errorWithDomain:code:userInfo:]( &OBJC_CLASS___NSError,  "errorWithDomain:code:userInfo:",  NSPOSIXErrorDomain,  89LL,  0LL));
        _Block_release(*(const void **)(a1 + 8792));
        *(void *)(a1 + 8792) = 0LL;
        int v12 = *(const void **)(a1 + 8784);
        if (v12)
        {
          CFRelease(v12);
          *(void *)(a1 + 8784) = 0LL;
        }
      }

      uint64_t v13 = *(void *)(a1 + 8816);
      if (v13)
      {
        (*(void (**)(uint64_t, NSError *, void))(v13 + 16))( v13,  +[NSError errorWithDomain:code:userInfo:]( &OBJC_CLASS___NSError,  "errorWithDomain:code:userInfo:",  NSPOSIXErrorDomain,  89LL,  0LL),  0LL);
        _Block_release(*(const void **)(a1 + 8816));
        *(void *)(a1 + 8816) = 0LL;
      }

      uint64_t v14 = *(void *)(a1 + 8808);
      if (v14)
      {
        (*(void (**)(uint64_t, NSError *))(v14 + 16))( v14,  +[NSError errorWithDomain:code:userInfo:]( &OBJC_CLASS___NSError,  "errorWithDomain:code:userInfo:",  NSPOSIXErrorDomain,  89LL,  0LL));
        _Block_release(*(const void **)(a1 + 8808));
        *(void *)(a1 + 880_Block_object_dispose(va, 8) = 0LL;

        *(void *)(a1 + 8800) = 0LL;
      }
    }

    goto LABEL_32;
  }

  if (sub_1000ABA7C(v6))
  {
    if (sub_1000ABA84(*(void *)(a1 + 224)) != 2)
    {
      int v7 = *(const void **)(a1 + 224);
      if (v7)
      {
        CFRelease(v7);
        *(void *)(a1 + 224) = 0LL;
      }

      goto LABEL_20;
    }

    BOOL v16 = objc_autoreleasePoolPush();
    uint64_t v17 = (void *)qword_100219F60;
    if (qword_100219F60)
    {
      uint64_t v18 = *(void *)(a1 + 224);
      uint64_t v20 = sub_1000ABA7C(v18);
      [v17 WFLog:3, "%s: not releasing pending notification %@ (type=%d,inputType=%d)", "WiFiDeviceManagerAbort", v18, v20, sub_1000ABA84(*(void *)(a1 + 224)) message];
    }
  }

  else
  {
    BOOL v16 = objc_autoreleasePoolPush();
    if (qword_100219F60) {
      [(id)qword_100219F60 WFLog:3, "%s: not releasing ask to join notification %@", "WiFiDeviceManagerAbort", *(void *)(a1 + 224), v19, v21 message];
    }
  }

  objc_autoreleasePoolPop(v16);
LABEL_32:
  sub_10010D14C(a1, @"autoJoinAborted", 0LL, 0LL);
  uint64_t v15 = objc_autoreleasePoolPush();
  if (qword_100219F60) {
    [(id)qword_100219F60 WFLog:3 message:"Aborted current auto-join session."];
  }
  objc_autoreleasePoolPop(v15);
}

void sub_1000D0894(uint64_t a1)
{
  uint64_t v2 = objc_autoreleasePoolPush();
  if (!a1)
  {
    uint64_t v10 = objc_autoreleasePoolPush();
    if (qword_100219F60) {
      [qword_100219F60 WFLog:@"%s: null manager." message:3];
    }
    goto LABEL_13;
  }

  if (!*(void *)(a1 + 5400))
  {
    uint64_t v10 = objc_autoreleasePoolPush();
    if (qword_100219F60) {
      [qword_100219F60 WFLog:@"%s: Power modules not attached." message:3];
    }
LABEL_13:
    objc_autoreleasePoolPop(v10);
    goto LABEL_14;
  }

  uint64_t v3 = *(void *)(a1 + 64);
  uint64_t v4 = (const void *)sub_100043E8C(v3);
  unsigned __int8 v5 = sub_100040538(v3, v4);
  if (!v5)
  {
    uint64_t v8 = *(void *)(a1 + 64);
    uint64_t v9 = (const void *)sub_100040CF8(v8);
    if (sub_1000500D4(v8, v9, 0LL))
    {
      uint64_t v10 = objc_autoreleasePoolPush();
      if (qword_100219F60) {
        [qword_100219F60 WFLog:@"Power module attached - AWDL still enabled."];
      }
    }

    else
    {
      if (!*(_BYTE *)(a1 + 3297))
      {
        [*(id *)(a1 + 5400) releasePowerResources];
        goto LABEL_14;
      }

      uint64_t v10 = objc_autoreleasePoolPush();
      if (qword_100219F60) {
        [qword_100219F60 WFLog:@"%s: Power module attached - autojoin still enabled." message:3];
      }
    }

    goto LABEL_13;
  }

  uint64_t v6 = v5;
  int v7 = objc_autoreleasePoolPush();
  if (qword_100219F60) {
    [(id)qword_100219F60 WFLog:3, "%s: Power module attached - still connected to %@.", "__WiFiDeviceManagerReleasePowerResource", sub_100095BC8(v6) message];
  }
  objc_autoreleasePoolPop(v7);
  CFRelease(v6);
LABEL_14:
  objc_autoreleasePoolPop(v2);
}

void sub_1000D0A4C(uint64_t a1)
{
}

void sub_1000D0A5C(uint64_t a1, uint64_t a2, uint64_t a3)
{
  if (!*(_DWORD *)(a1 + 3272)) {
    sub_1000D157C(a1, 0LL);
  }
}

void sub_1000D0AAC(uint64_t a1, uint64_t a2, uint64_t a3)
{
  uint64_t v6 = objc_autoreleasePoolPush();
  if (qword_100219F60) {
    [qword_100219F60 WFLog:@"%s called by %s" message:3];
  }
  objc_autoreleasePoolPop(v6);
  if (a1)
  {
    *(_DWORD *)(a1 + 5624) = a2;
    if ((_DWORD)a2 == 2) {
      *(void *)(a1 + 328_Block_object_dispose(va, 8) = 0LL;
    }
    double valuePtr = NAN;
    int v7 = *(const __CFArray **)(a1 + 320);
    if (v7
      && (Count = CFArrayGetCount(v7), (CFIndex v9 = *(void *)(a1 + 328)) != 0)
      && (_DWORD)a2 != 2
      && (double v10 = *(double *)(a1 + 336), v10 != 0.0)
      && (CFIndex v11 = Count) != 0)
    {
      if (v9 >= Count)
      {
        CFIndex v9 = Count - 1;
        *(void *)(a1 + 32_Block_object_dispose(va, 8) = Count - 1;
      }

      unsigned int v12 = 1;
      if ((_DWORD)a2 == 1 && v10 >= 5.0)
      {
        if (*(void *)(a1 + 392)) {
          unsigned int v12 = 2;
        }
        else {
          *(void *)(a1 + 336) = 0x4014000000000000LL;
        }
      }

      if (v9 >= 1)
      {
        do
        {
          ValueAtIndex = (const __CFNumber *)CFArrayGetValueAtIndex(*(CFArrayRef *)(a1 + 320), v9);
          if (ValueAtIndex)
          {
            CFNumberGetValue(ValueAtIndex, kCFNumberDoubleType, &valuePtr);
          }

          uint64_t v14 = *(void *)(a1 + 328);
          CFIndex v9 = v14 - 1;
          *(void *)(a1 + 32_Block_object_dispose(va, 8) = v14 - 1;
        }

        while (v14 > 1);
      }

      if (*(_DWORD *)(a1 + 348) < v12) {
        *(_DWORD *)(a1 + 34_Block_object_dispose(va, 8) = v12;
      }
      uint64_t v15 = objc_autoreleasePoolPush();
      if (qword_100219F60) {
        [qword_100219F60 WFLog:message:3, "%s: resetType=%d, retryIndex=%ld, quickRetry=%d, lastInterval=%f, intervals=(%ld) autoHSInterval=(%f)", "__WiFiDeviceManagerResetRetryIntervals", a2, *(void *)(a1 + 328), *(unsigned int *)(a1 + 348), *(void *)(a1 + 336), v11, *(void *)(a1 + 6824)];
      }
      objc_autoreleasePoolPop(v15);
    }

    else
    {
      *(_DWORD *)(a1 + 34_Block_object_dispose(va, 8) = 0;
      *(void *)(a1 + 32_Block_object_dispose(va, 8) = 0LL;
      *(void *)(a1 + 336) = 0LL;
    }

    int v16 = *(_DWORD *)(a1 + 3272);
    if (v16 == 1)
    {
      dispatch_source_set_timer(*(dispatch_source_t *)(a1 + 312), 0xFFFFFFFFFFFFFFFFLL, 0xFFFFFFFFFFFFFFFFLL, 0LL);
      int v16 = 0;
    }

    *(_DWORD *)(a1 + 3272) = v16;
  }

void sub_1000D0CB8(uint64_t a1, int a2, uint64_t a3)
{
  uint64_t v6 = objc_autoreleasePoolPush();
  if (qword_100219F60) {
    [qword_100219F60 WFLog:@"%s called by %s" message:3, "__WiFiDeviceManagerAutoAssociate", a3];
  }
  objc_autoreleasePoolPop(v6);
  if (_os_feature_enabled_impl("CoreWiFi", "UnifiedAutoJoin"))
  {
    int v7 = objc_autoreleasePoolPush();
    if (qword_100219F60) {
      [qword_100219F60 WFLog:@"%s not allowed with Unified Auto-Join" message:@"__WiFiDeviceManagerAutoAssociate"];
    }
    objc_autoreleasePoolPop(v7);
    return;
  }

  CFArrayRemoveAllValues(*(CFMutableArrayRef *)(a1 + 1096));
  sub_10010D14C(a1, @"kWiFiAutoJoinStatusBegan", 0LL, 0LL);
  if (CFAbsoluteTimeGetCurrent() > *(double *)(a1 + 6776))
  {
    SCDynamicStoreContext context = dispatch_get_context(*(dispatch_object_t *)(a1 + 6768));
    sub_1000CA6A4((uint64_t)context);
  }

  if (!*(_BYTE *)(a1 + 3297))
  {
    uint64_t v15 = objc_autoreleasePoolPush();
    int v16 = (void *)qword_100219F60;
    if (qword_100219F60)
    {
      uint64_t v17 = "Auto association attempt canceled because auto join is disabled.";
LABEL_24:
      [v16 WFLog:3 message:v17];
    }

void sub_1000D157C(uint64_t a1, unsigned int a2)
{
  if (byte_100219FA1)
  {
    uint64_t v3 = objc_autoreleasePoolPush();
    if (qword_100219F60) {
      [qword_100219F60 WFLog:@"%s: Lockdown Mode is enabled, ignoring SetATJOneShot %ld" message:3, @"__WiFiDeviceManagerSetATJOneShot", a2];
    }
    objc_autoreleasePoolPop(v3);
  }

  else if (*(unsigned __int8 *)(a1 + 104) != a2)
  {
    unsigned __int8 v5 = objc_autoreleasePoolPush();
    if (qword_100219F60)
    {
      uint64_t v6 = "Enabling";
      if (!a2) {
        uint64_t v6 = "Disabling";
      }
      objc_msgSend((id)qword_100219F60, "WFLog:message:", 3, "%s one-shot ATJ", v6);
    }

    objc_autoreleasePoolPop(v5);
    *(_BYTE *)(a1 + 104) = a2;
    if (a2)
    {
      *(_DWORD *)(a1 + 192) = 1;
      if (_os_feature_enabled_impl("CoreWiFi", "UnifiedAutoJoin"))
      {
        sub_1000F5F98(a1, 0xFuLL);
      }

      else
      {
        [+[WiFiXPCManager sharedXPCManager](WiFiXPCManager, "sharedXPCManager") autoJoinStartedWithTrigger:15 interfaceName:sub_100043E8C(*(void *)(a1 + 64))];
        sub_1000D0A5C(a1, 2LL, (uint64_t)"__WiFiDeviceManagerSetATJOneShot");
      }
    }
  }

void sub_1000D16F4(uint64_t a1, int a2)
{
  uint64_t v4 = objc_autoreleasePoolPush();
  unsigned __int8 v5 = objc_autoreleasePoolPush();
  if (qword_100219F60)
  {
    else {
      uint64_t v6 = off_1001E54A8[a2 - 1];
    }
    [(id)qword_100219F60 WFLog:3, "%s: type=%@", "WiFiDeviceManagerReset", v6 message];
  }

  objc_autoreleasePoolPop(v5);
  uint64_t v7 = 2LL;
  switch(a2)
  {
    case 1:
      sub_1000D184C(a1);
      uint64_t v7 = 7LL;
      goto LABEL_8;
    case 3:
LABEL_8:
      [*(id *)(a1 + 6632) removeDenyListStateWithDenyListRemoveReason:v7];
      if ([*(id *)(a1 + 6632) denyListedNetworkCount]) {
        sub_1000D0428(a1);
      }
      if ([*(id *)(a1 + 6888) count]) {
        [*(id *)(a1 + 6888) removeAllObjects];
      }
      break;
    case 4:
      uint64_t v8 = *(void **)(a1 + 6632);
      uint64_t v9 = 5LL;
      goto LABEL_16;
    case 5:
      sub_1000D184C(a1);
      break;
    case 6:
      sub_1000D184C(a1);
      uint64_t v8 = *(void **)(a1 + 6632);
      uint64_t v9 = 3LL;
      goto LABEL_16;
    case 7:
      sub_1000D184C(a1);
      uint64_t v8 = *(void **)(a1 + 6632);
      uint64_t v9 = 4LL;
LABEL_16:
      [v8 removeDenyListStateWithDenyListRemoveReason:v9];
      if ([*(id *)(a1 + 6632) denyListedNetworkCount]) {
        sub_1000D0428(a1);
      }
      break;
    default:
      break;
  }

  objc_autoreleasePoolPop(v4);
}

void sub_1000D184C(uint64_t a1)
{
  uint64_t v2 = objc_autoreleasePoolPush();
  if (a1)
  {
    if (qword_100219F60) {
      [qword_100219F60 WFLog:@"%s: reseting userCancelled networks" message:3];
    }
    objc_autoreleasePoolPop(v2);
    CFSetRemoveAllValues(*(CFMutableSetRef *)(a1 + 3496));
  }

  else
  {
    if (qword_100219F60) {
      [qword_100219F60 WFLog:@"%s: manager is nil" message:4];
    }
    objc_autoreleasePoolPop(v2);
  }

uint64_t sub_1000D18E8(uint64_t result, uint64_t a2, uint64_t a3)
{
  *(void *)(result + 3880) = a2;
  *(void *)(result + 388_Block_object_dispose(va, 8) = a3;
  return result;
}

uint64_t sub_1000D18F4(uint64_t result, uint64_t a2, uint64_t a3)
{
  *(void *)(result + 404_Block_object_dispose(va, 8) = a2;
  *(void *)(result + 4056) = a3;
  return result;
}

uint64_t sub_1000D1900(uint64_t result, uint64_t a2, uint64_t a3)
{
  *(void *)(result + 4704) = a2;
  *(void *)(result + 4712) = a3;
  return result;
}

uint64_t sub_1000D190C(uint64_t result, uint64_t a2, uint64_t a3)
{
  *(void *)(result + 3864) = a2;
  *(void *)(result + 3872) = a3;
  return result;
}

uint64_t sub_1000D1918(uint64_t result, uint64_t a2, uint64_t a3)
{
  *(void *)(result + 3896) = a2;
  *(void *)(result + 3904) = a3;
  return result;
}

uint64_t sub_1000D1924(uint64_t result, uint64_t a2, uint64_t a3)
{
  *(void *)(result + 3912) = a2;
  *(void *)(result + 3920) = a3;
  return result;
}

uint64_t sub_1000D1930(uint64_t result, uint64_t a2, uint64_t a3)
{
  *(void *)(result + 392_Block_object_dispose(va, 8) = a2;
  *(void *)(result + 3936) = a3;
  return result;
}

uint64_t sub_1000D193C(uint64_t result, uint64_t a2, uint64_t a3)
{
  *(void *)(result + 3944) = a2;
  *(void *)(result + 3960) = a3;
  return result;
}

uint64_t sub_1000D1948(uint64_t result, uint64_t a2, uint64_t a3)
{
  *(void *)(result + 396_Block_object_dispose(va, 8) = a2;
  *(void *)(result + 3976) = a3;
  return result;
}

uint64_t sub_1000D1954(uint64_t result, uint64_t a2, uint64_t a3)
{
  *(void *)(result + 3984) = a2;
  *(void *)(result + 3992) = a3;
  return result;
}

uint64_t sub_1000D1960(uint64_t result, uint64_t a2, uint64_t a3)
{
  *(void *)(result + 4016) = a2;
  *(void *)(result + 4024) = a3;
  return result;
}

uint64_t sub_1000D196C(uint64_t result, uint64_t a2, uint64_t a3)
{
  *(void *)(result + 4032) = a2;
  *(void *)(result + 4040) = a3;
  return result;
}

uint64_t sub_1000D1978(uint64_t result, uint64_t a2, uint64_t a3)
{
  *(void *)(result + 4064) = a2;
  *(void *)(result + 4072) = a3;
  return result;
}

uint64_t sub_1000D1984(uint64_t result, uint64_t a2, uint64_t a3)
{
  *(void *)(result + 4080) = a2;
  *(void *)(result + 408_Block_object_dispose(va, 8) = a3;
  return result;
}

uint64_t sub_1000D1990(uint64_t result, uint64_t a2, uint64_t a3)
{
  *(void *)(result + 4096) = a2;
  *(void *)(result + 4104) = a3;
  return result;
}

uint64_t sub_1000D199C(uint64_t result, uint64_t a2, uint64_t a3)
{
  *(void *)(result + 4112) = a2;
  *(void *)(result + 4120) = a3;
  return result;
}

uint64_t sub_1000D19A8(uint64_t result, uint64_t a2, uint64_t a3)
{
  *(void *)(result + 412_Block_object_dispose(va, 8) = a2;
  *(void *)(result + 4136) = a3;
  return result;
}

uint64_t sub_1000D19B4(uint64_t result, uint64_t a2, uint64_t a3)
{
  *(void *)(result + 4144) = a2;
  *(void *)(result + 4152) = a3;
  return result;
}

uint64_t sub_1000D19C0(uint64_t result, uint64_t a2, uint64_t a3)
{
  *(void *)(result + 4160) = a2;
  *(void *)(result + 416_Block_object_dispose(va, 8) = a3;
  return result;
}

uint64_t sub_1000D19CC(uint64_t result, uint64_t a2, uint64_t a3)
{
  *(void *)(result + 4176) = a2;
  *(void *)(result + 4184) = a3;
  return result;
}

uint64_t sub_1000D19D8(uint64_t result, uint64_t a2, uint64_t a3)
{
  *(void *)(result + 4192) = a2;
  *(void *)(result + 4200) = a3;
  return result;
}

uint64_t sub_1000D19E4(uint64_t result, uint64_t a2, uint64_t a3)
{
  *(void *)(result + 4000) = a2;
  *(void *)(result + 400_Block_object_dispose(va, 8) = a3;
  return result;
}

uint64_t sub_1000D19F0(uint64_t result, uint64_t a2, uint64_t a3)
{
  *(void *)(result + 420_Block_object_dispose(va, 8) = a2;
  *(void *)(result + 4216) = a3;
  return result;
}

uint64_t sub_1000D19FC(uint64_t result, uint64_t a2, uint64_t a3)
{
  *(void *)(result + 4224) = a2;
  *(void *)(result + 4232) = a3;
  return result;
}

uint64_t sub_1000D1A08(uint64_t result, uint64_t a2, uint64_t a3)
{
  *(void *)(result + 4240) = a2;
  *(void *)(result + 424_Block_object_dispose(va, 8) = a3;
  return result;
}

uint64_t sub_1000D1A14(uint64_t result, uint64_t a2, uint64_t a3)
{
  *(void *)(result + 4256) = a2;
  *(void *)(result + 4264) = a3;
  return result;
}

uint64_t sub_1000D1A20(uint64_t result, uint64_t a2, uint64_t a3)
{
  *(void *)(result + 4784) = a2;
  *(void *)(result + 4792) = a3;
  return result;
}

uint64_t sub_1000D1A2C(uint64_t result, uint64_t a2, uint64_t a3)
{
  *(void *)(result + 4800) = a2;
  *(void *)(result + 480_Block_object_dispose(va, 8) = a3;
  return result;
}

uint64_t sub_1000D1A38(uint64_t result, uint64_t a2, uint64_t a3)
{
  *(void *)(result + 4272) = a2;
  *(void *)(result + 4280) = a3;
  return result;
}

uint64_t sub_1000D1A44(uint64_t result, uint64_t a2, uint64_t a3)
{
  *(void *)(result + 428_Block_object_dispose(va, 8) = a2;
  *(void *)(result + 4296) = a3;
  return result;
}

uint64_t sub_1000D1A50(uint64_t result, uint64_t a2, uint64_t a3)
{
  *(void *)(result + 4320) = a2;
  *(void *)(result + 432_Block_object_dispose(va, 8) = a3;
  return result;
}

uint64_t sub_1000D1A5C(uint64_t result, uint64_t a2, uint64_t a3)
{
  *(void *)(result + 4336) = a2;
  *(void *)(result + 4344) = a3;
  return result;
}

uint64_t sub_1000D1A68(uint64_t result, uint64_t a2, uint64_t a3)
{
  *(void *)(result + 4512) = a2;
  *(void *)(result + 4520) = a3;
  return result;
}

uint64_t sub_1000D1A74(uint64_t result, uint64_t a2, uint64_t a3)
{
  *(void *)(result + 4656) = a2;
  *(void *)(result + 4664) = a3;
  return result;
}

uint64_t sub_1000D1A80(uint64_t result, uint64_t a2, uint64_t a3)
{
  *(void *)(result + 4672) = a2;
  *(void *)(result + 4680) = a3;
  return result;
}

uint64_t sub_1000D1A8C(uint64_t result, uint64_t a2, uint64_t a3)
{
  *(void *)(result + 4720) = a2;
  *(void *)(result + 472_Block_object_dispose(va, 8) = a3;
  return result;
}

uint64_t sub_1000D1A98(uint64_t result, uint64_t a2, uint64_t a3)
{
  *(void *)(result + 4736) = a2;
  *(void *)(result + 4744) = a3;
  return result;
}

uint64_t sub_1000D1AA4(uint64_t result, uint64_t a2, uint64_t a3)
{
  *(void *)(result + 4864) = a2;
  *(void *)(result + 4872) = a3;
  return result;
}

uint64_t sub_1000D1AB0(uint64_t result, uint64_t a2, uint64_t a3)
{
  *(void *)(result + 4816) = a2;
  *(void *)(result + 4824) = a3;
  return result;
}

uint64_t sub_1000D1ABC(uint64_t result, uint64_t a2, uint64_t a3)
{
  *(void *)(result + 484_Block_object_dispose(va, 8) = a2;
  *(void *)(result + 4856) = a3;
  return result;
}

uint64_t sub_1000D1AC8(uint64_t result, uint64_t a2, uint64_t a3)
{
  *(void *)(result + 4880) = a2;
  *(void *)(result + 488_Block_object_dispose(va, 8) = a3;
  return result;
}

uint64_t sub_1000D1AD4(uint64_t result, uint64_t a2, uint64_t a3)
{
  *(void *)(result + 4896) = a2;
  *(void *)(result + 4904) = a3;
  return result;
}

uint64_t sub_1000D1AE0(uint64_t result, uint64_t a2, uint64_t a3)
{
  *(void *)(result + 4912) = a2;
  *(void *)(result + 4920) = a3;
  return result;
}

void sub_1000D1AEC(uint64_t a1, const void *a2)
{
  uint64_t v4 = objc_autoreleasePoolPush();
  id v5 = sub_1000A335C((uint64_t)a2);
  id v6 = sub_1000D1BDC(a1, 0LL, 0LL, 0LL, 5LL);
  [*(id *)(a1 + 6632) setNetworkDenyListInfo:v6 forScanResult:v5];
  uint64_t v7 = *(void *)(a1 + 64);
  uint64_t v8 = (const void *)sub_100043E8C(v7);
  uint64_t v9 = sub_100040538(v7, v8);
  if (v9)
  {
    int v10 = v9;
    if (CFEqual(a2, v9) && [*(id *)(a1 + 6632) enabled])
    {
      CFIndex v11 = (const void *)sub_100043E8C(*(void *)(a1 + 64));
      sub_1000CE074(a1, v11, 1002LL, "WiFiDeviceManagerTemporarilyDisableNetwork", 5764LL);
    }

    CFRelease(v10);
  }

  else
  {
  }

  objc_autoreleasePoolPop(v4);
}

id sub_1000D1BDC(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5)
{
  int v10 = objc_autoreleasePoolPush();
  if (a1)
  {
    id v11 = objc_alloc_init(&OBJC_CLASS___CWFNetworkDenyListInfo);
    [v11 setReason:a2];
    [v11 setReasonData:a3];
    [v11 setBSSID:a4];
    [v11 setState:a5];
  }

  else
  {
    uint64_t v13 = objc_autoreleasePoolPush();
    if (qword_100219F60) {
      [qword_100219F60 WFLog:@"%s: manager is NULL!" message:3];
    }
    objc_autoreleasePoolPop(v13);
    id v11 = 0LL;
  }

  objc_autoreleasePoolPop(v10);
  return v11;
}

uint64_t sub_1000D1CB8(uint64_t a1, const __CFArray *a2)
{
  v126 = (unsigned __int8 *)(a1 + 5208);
  unsigned int v141 = 0;
  int v4 = _os_feature_enabled_impl("CoreWiFi", "UnifiedAutoJoin");
  if (a1 && v4)
  {
    id v5 = objc_autoreleasePoolPush();
    if (a2)
    {
      id v6 = +[NSMutableSet set](&OBJC_CLASS___NSMutableSet, "set");
      if (CFArrayGetCount(a2) >= 1)
      {
        CFIndex v7 = 0LL;
        do
        {
          ValueAtIndex = (CFDictionaryRef *)CFArrayGetValueAtIndex(a2, v7);
          uint64_t v9 = sub_1000A063C(ValueAtIndex);
          if (v9)
          {
            int v10 = v9;
            [v6 addObject:v9];
          }

          ++v7;
        }

        while (v7 < CFArrayGetCount(a2));
      }
    }

    else
    {
      id v6 = 0LL;
    }

    [*(id *)(a1 + 8776) setKnownNetworks:v6];
    objc_autoreleasePoolPop(v5);
  }

  id v11 = (const void *)sub_100043E8C(*(void *)(a1 + 64));
  unsigned int v12 = sub_1000DEA34(a1, v11, 1);
  sub_1000D3350(a1);
  uint64_t v13 = kCFAllocatorDefault;
  CFMutableArrayRef Mutable = CFArrayCreateMutable(kCFAllocatorDefault, 0LL, &kCFTypeArrayCallBacks);
  CFMutableArrayRef v15 = CFArrayCreateMutable(kCFAllocatorDefault, 0LL, &kCFTypeArrayCallBacks);
  CFMutableSetRef v16 = CFSetCreateMutable(kCFAllocatorDefault, 0LL, &kCFTypeSetCallBacks);
  theSet = v16;
  unsigned __int8 v130 = v15;
  if (Mutable) {
    BOOL v17 = v15 == 0LL;
  }
  else {
    BOOL v17 = 1;
  }
  if (v17 || v16 == 0LL)
  {
    CFRange v119 = objc_autoreleasePoolPush();
    if (qword_100219F60) {
      [qword_100219F60 WFLog:@"%s: failed to create array" message:3];
    }
    objc_autoreleasePoolPop(v119);
    BOOL v93 = 0LL;
    int v134 = 0LL;
    int v82 = 0;
    if (v12) {
      goto LABEL_205;
    }
    goto LABEL_206;
  }

  CFMutableArrayRef v19 = CFArrayCreateMutable(kCFAllocatorDefault, 0LL, &kCFTypeArrayCallBacks);
  uint64_t v20 = CFArrayCreateMutable(kCFAllocatorDefault, 0LL, &kCFTypeArrayCallBacks);
  int v134 = CFArrayCreateMutable(kCFAllocatorDefault, 0LL, &kCFTypeArrayCallBacks);
  if (v19) {
    BOOL v21 = v20 == 0LL;
  }
  else {
    BOOL v21 = 1;
  }
  if (v21)
  {
    dispatch_time_t v120 = objc_autoreleasePoolPush();
    if (qword_100219F60) {
      [qword_100219F60 WFLog:@"%s: failed to create hs20 array" message:3];
    }
    objc_autoreleasePoolPop(v120);
    theArray = 0LL;
    goto LABEL_268;
  }

  theArray = CFArrayCreateMutable(kCFAllocatorDefault, 0LL, &kCFTypeArrayCallBacks);
  if (theArray)
  {
    NSErrorUserInfoKey v22 = sub_100095BC8(v12);
    uint64_t v23 = 1LL;
    CFTypeRef cf = v12;
    if (v22)
    {
      uint64_t v24 = *(void *)(a1 + 6640);
      if (v24)
      {
        if (CFEqual(v22, *(CFTypeRef *)(a1 + 6640)))
        {
          int v25 = objc_autoreleasePoolPush();
          if (qword_100219F60) {
            [(id)qword_100219F60 WFLog:3, "%s: '%@' removed via iCloud, shouldDisassociate = FALSE", "WiFiDeviceManagerSetNetworks", v24 message];
          }
          objc_autoreleasePoolPop(v25);
          uint64_t v23 = 0LL;
          unsigned int v12 = (void *)cf;
        }

        else
        {
          uint64_t v23 = 1LL;
        }
      }
    }

    int v132 = Mutable;
    if (v12 && !sub_1000D33E4((void *)a1, v12) && !sub_1000D3484(a1, v12))
    {
      uint64_t v26 = objc_autoreleasePoolPush();
      if (qword_100219F60) {
        [(id)qword_100219F60 WFLog:3, "%s: '%@' not previously known, shouldDisassociate = FALSE", "WiFiDeviceManagerSetNetworks", sub_100095BC8(cf) message];
      }
      objc_autoreleasePoolPop(v26);
      int v27 = objc_autoreleasePoolPush();
      uint64_t v28 = (void *)qword_100219F60;
      if (qword_100219F60)
      {
        BOOL v29 = sub_100095318((BOOL)cf);
        uint64_t v30 = "yes";
        if (v29) {
          __int128 v31 = "yes";
        }
        else {
          __int128 v31 = "no";
        }
        if (*(_DWORD *)(a1 + 5512) != 1) {
          uint64_t v30 = "no";
        }
        objc_msgSend( v28,  "WFLog:message:",  3,  "%s: Current network is HS20 ? %s, Got CarPlay in-car ? %s",  "WiFiDeviceManagerSetNetworks",  v31,  v30);
      }

      objc_autoreleasePoolPop(v27);
      unsigned int v12 = (void *)cf;
      if (!sub_100095318((BOOL)cf) || *(_DWORD *)(a1 + 5512) != 1) {
        uint64_t v23 = 0LL;
      }
    }

    uint64_t v139 = v19;
    unsigned int v140 = v20;
    CFIndex v138 = a2;
    if (a2)
    {
      CFIndex Count = CFArrayGetCount(a2);
      if (Count >= 1)
      {
        CFIndex v33 = Count;
        CFIndex v34 = 0LL;
        int v35 = 0;
        while (1)
        {
          __int128 v36 = (void *)CFArrayGetValueAtIndex(a2, v34);
          if (!v36) {
            goto LABEL_95;
          }
          __int128 v37 = v36;
          __int128 v38 = *(const void **)(a1 + 3504);
          if (v38 && CFEqual(v38, v37)) {
            int v35 = 1;
          }
          if ((_DWORD)v23)
          {
            if (!v12)
            {
              uint64_t v23 = 0LL;
              goto LABEL_81;
            }

            uint64_t v23 = CFEqual(v12, v37) ? 0LL : v23;
          }

          else if (!v12)
          {
            goto LABEL_81;
          }

          if (sub_100095318((BOOL)v12) && sub_100095318((BOOL)v37)) {
            break;
          }
LABEL_74:
          if (sub_1000972B8((uint64_t)v12))
          {
            unsigned int v44 = sub_100096804(v12);
            CFMutableArrayRef v45 = sub_100096804(v37);
            if (CFEqual(v44, v45))
            {
              uint64_t v46 = objc_autoreleasePoolPush();
              if (qword_100219F60) {
                [(id)qword_100219F60 WFLog:3, "%s: connected to the same ambiguous SSID network %@, shouldDisassociate = FALSE", "WiFiDeviceManagerSetNetworks", sub_100095BC8(v37) message];
              }
              objc_autoreleasePoolPop(v46);
              uint64_t v23 = 0LL;
            }
          }

          if (CFEqual(v12, v37)) {
            sub_1000D3518(a1, v37);
          }
LABEL_81:
          if (sub_100095B88((BOOL)v37))
          {
            if (sub_10004D660(*(void *)(a1 + 64)))
            {
              CFIndex v47 = CFStringCreateMutable(kCFAllocatorDefault, 0LL);
              if (!v47)
              {
                int v82 = 0;
                CFMutableArrayRef v19 = v139;
                CFMutableArrayRef Mutable = v132;
                goto LABEL_200;
              }

              CFIndex v48 = v47;
              uint64_t v49 = v23;
              sub_10009CF6C((uint64_t)v37, v47);
              int v50 = objc_autoreleasePoolPush();
              if (qword_100219F60) {
                [(id)qword_100219F60 WFLog:3, "%s: Adding HS20 Account: %@", "WiFiDeviceManagerSetNetworks", v48 message];
              }
              objc_autoreleasePoolPop(v50);
              CFRelease(v48);
              else {
                unsigned int v51 = v134;
              }
              goto LABEL_100;
            }

            int v53 = objc_autoreleasePoolPush();
            if (qword_100219F60) {
              [qword_100219F60 WFLog:@"%s: device does not support HS2.0. Will not program HS2.0 account" message:3];
            }
            objc_autoreleasePoolPop(v53);
          }

          else
          {
            if (!sub_10009A128((uint64_t)v37))
            {
              uint64_t v49 = v23;
              uint64_t v54 = objc_autoreleasePoolPush();
              if (qword_100219F60) {
                [(id)qword_100219F60 WFLog:3, "%s: skipping disabled network %@", "WiFiDeviceManagerSetNetworks", sub_100095BC8(v37) message];
              }
              objc_autoreleasePoolPop(v54);
              unsigned int v51 = theArray;
LABEL_100:
              CFArrayAppendValue(v51, v37);
              goto LABEL_105;
            }

            if (sub_10009EA20((uint64_t)v37))
            {
              uint64_t v49 = v23;
              uint64_t v52 = objc_autoreleasePoolPush();
              if (qword_100219F60) {
                [(id)qword_100219F60 WFLog:3, "%s: %@ is disabled until first user join", "WiFiDeviceManagerSetNetworks", sub_100095BC8(v37) message];
              }
              goto LABEL_104;
            }

            if (sub_10009EAF4((const __CFDictionary **)v37))
            {
              uint64_t v49 = v23;
              uint64_t v52 = objc_autoreleasePoolPush();
              if (qword_100219F60) {
                [(id)qword_100219F60 WFLog:3, "%s: skipping infrequently joined public network %@", "WiFiDeviceManagerSetNetworks", sub_100095BC8(v37) message];
              }
LABEL_104:
              objc_autoreleasePoolPop(v52);
LABEL_105:
              a2 = v138;
              uint64_t v23 = v49;
              goto LABEL_106;
            }

            CFArrayAppendValue(v132, v37);
            if (CFSetContainsValue(*(CFSetRef *)(a1 + 3496), v37)) {
              CFSetAddValue(theSet, v37);
            }
          }

LABEL_176:
                if (*(_DWORD *)(a1 + 5512) == 1)
                {
                  sub_100051010(*(void *)(a1 + 64));
                  CFIndex v81 = objc_autoreleasePoolPush();
                  if (qword_100219F60) {
                    [qword_100219F60 WFLog:@"Aborting scan..."];
                  }
                  objc_autoreleasePoolPop(v81);
                }

                int v82 = !v59;
                *(_DWORD *)(a1 + 2_Block_object_dispose(va, 8) = 0;
                sub_1000D0AAC(a1, 2LL, (uint64_t)"WiFiDeviceManagerSetNetworks");
                if (cf)
                {
                  CFMutableArrayRef v83 = (const __CFNumber *)sub_100096A74((uint64_t)cf);
                  if (v83) {
                    CFNumberGetValue(v83, kCFNumberIntType, &v141);
                  }
                  uint64_t v84 = objc_autoreleasePoolPush();
                  uint64_t v85 = (void *)qword_100219F60;
                  if (!qword_100219F60) {
                    goto LABEL_188;
                  }
                  __int128 v86 = (const __CFString *)sub_100095BC8(cf);
                  uint64_t v87 = v141;
                  CFNumberRef v88 = sub_100096A74((uint64_t)cf);
                  uint64_t v89 = sub_1000992D0((uint64_t)v88);
                }

                else
                {
                  unsigned int v90 = objc_autoreleasePoolPush();
                  uint64_t v84 = v90;
                  uint64_t v85 = (void *)qword_100219F60;
                  if (!qword_100219F60)
                  {
                    objc_autoreleasePoolPop(v90);
                    unsigned int v12 = (void *)cf;
                    goto LABEL_192;
                  }

                  uint64_t v89 = 0xFFFFFFFFLL;
                  __int128 v86 = @"None";
                  uint64_t v87 = v141;
                }

                [v85 WFLog:3, "%s: currentNetwork: %@, channel: %d band: %d shouldDisassociate %d", "WiFiDeviceManagerSetNetworks", v86, v87, v89, v131 message];
                CFMutableArrayRef Mutable = v61;
LABEL_188:
                objc_autoreleasePoolPop(v84);
                unsigned int v12 = (void *)cf;
                CFMutableArrayRef v19 = v139;
                if (cf && (_DWORD)v131)
                {
                  unsigned int v91 = (const void *)sub_100043E8C(*(void *)(a1 + 64));
                  sub_1000CE074(a1, v91, 1003LL, "WiFiDeviceManagerSetNetworks", 6181LL);
                }

LABEL_192:
                if (*(_DWORD *)(a1 + 5512) != 1) {
                  goto LABEL_200;
                }
                *(_BYTE *)(a1 + 1056) = 0;
                if (!v126[1800] || !v126[3] || *v126 < 0xFu || (v126[1801] & 4) == 0)
                {
                  __int128 v92 = objc_autoreleasePoolPush();
                  if (qword_100219F60) {
                    [qword_100219F60 WFLog:@"%s: 5Ghz MIS is inactive\n" message:4];
                  }
                  objc_autoreleasePoolPop(v92);
LABEL_200:
                  if (!v19) {
                    goto LABEL_202;
                  }
                  goto LABEL_201;
                }

                if (CFArrayGetCount(v138) == 1)
                {
                  uint64_t v97 = CFArrayGetValueAtIndex(v138, 0LL);
                  if (sub_10009DF44((uint64_t)v97))
                  {
                    if (sub_1000951FC((uint64_t)v97, @"CHANNEL"))
                    {
                      BOOL v98 = sub_100096BF4((uint64_t)v97, @"CHANNEL");
                      unsigned int v142 = v98;
                      if (v98 <= 0x23)
                      {
                        uint64_t v118 = objc_autoreleasePoolPush();
                        if (qword_100219F60) {
                          [qword_100219F60 WFLog:@"__WiFiDeviceManagerSwitchMISChannelForCarPlayJoin 2.4 Ghz CarPlay network\n"];
                        }
                      }

                      else
                      {
                        CFIndex v99 = (const __CFArray *)sub_1000951FC((uint64_t)v97, @"networkKnownBSSListKey");
                        if (v99)
                        {
                          v100 = v99;
                          if (CFArrayGetCount(v99) >= 1)
                          {
                            CFIndex v101 = 0LL;
                            while (1)
                            {
                              unsigned int v102 = (const __CFDictionary *)CFArrayGetValueAtIndex(v100, v101);
                              CFIndex v103 = (const __CFNumber *)CFDictionaryGetValue(v102, @"CHANNEL");
                              int v104 = CFDictionaryGetValue(v102, @"CHANNEL_FLAGS");
                              if (v103)
                              {
                                if (v104)
                                {
                                  CFNumberGetValue(v103, kCFNumberSInt32Type, &v142);
                                  if (v142 < 0xF) {
                                    break;
                                  }
                                }
                              }

                              if (CFArrayGetCount(v100) <= ++v101) {
                                goto LABEL_235;
                              }
                            }

                            uint64_t v118 = objc_autoreleasePoolPush();
                            if (qword_100219F60) {
                              [qword_100219F60 WFLog:@"__WiFiDeviceManagerSwitchMISChannelForCarPlayJoin 2.4 Ghz channel is available\n"];
                            }
                            goto LABEL_258;
                          }
                        }

LABEL_235:
                        CFMutableArrayRef v19 = v139;
                        if (!v126[1800] || !sub_1000DCBFC(a1, 1LL))
                        {
                          double v117 = objc_autoreleasePoolPush();
                          if (qword_100219F60) {
                            [qword_100219F60 WFLog:@"%s: Concurrent mode is not allowed\n" message:4];
                          }
                          goto LABEL_254;
                        }

                        if (sub_1000497C8(*(void *)(a1 + 64), (int)v98))
                        {
                          if (sub_1000496CC(*(void *)(a1 + 64), (int)v98))
                          {
                            uint64_t v118 = objc_autoreleasePoolPush();
                            if (qword_100219F60) {
                              [qword_100219F60 WFLog:@"%s: Channel (%d) is DFS channel\n" message:4];
                            }
                          }

                          else if (sub_1000E673C(a1, (uint64_t)v98))
                          {
                            uint64_t v118 = objc_autoreleasePoolPush();
                            if (qword_100219F60) {
                              [qword_100219F60 WFLog:@"Channel (%d) is coex denylisted\n" message:4];
                            }
                          }

                          else
                          {
                            if (*(_DWORD *)(a1 + 5256) == 80) {
                              int v105 = 1040;
                            }
                            else {
                              int v105 = 18;
                            }
                            int v144 = v105;
                            valuePtr[0] = (_DWORD)v98;
                            int v143 = 1;
                            CFMutableDictionaryRef v106 = CFDictionaryCreateMutable( kCFAllocatorDefault,  0LL,  &kCFTypeDictionaryKeyCallBacks,  &kCFTypeDictionaryValueCallBacks);
                            if (v106)
                            {
                              uint64_t v107 = v106;
                              CFNumberRef v108 = CFNumberCreate(kCFAllocatorDefault, kCFNumberSInt32Type, valuePtr);
                              if (v108)
                              {
                                CFNumberRef v109 = v108;
                                CFDictionarySetValue(v107, @"IO80211InterfaceSoftAPCSAChannel", v108);
                                CFRelease(v109);
                                CFNumberRef v110 = CFNumberCreate(kCFAllocatorDefault, kCFNumberSInt32Type, &v144);
                                if (v110)
                                {
                                  CFNumberRef v111 = v110;
                                  CFDictionarySetValue(v107, @"IO80211InterfaceSoftAPCSAChannelFlag", v110);
                                  CFRelease(v111);
                                  CFNumberRef v112 = CFNumberCreate(kCFAllocatorDefault, kCFNumberSInt32Type, &v143);
                                  if (v112)
                                  {
                                    CFNumberRef v113 = v112;
                                    CFDictionarySetValue(v107, @"IO80211InterfaceSoftAPCSASwitchCount", v112);
                                    CFRelease(v113);
                                    CFDictionarySetValue( v107,  @"IO80211InterfaceSoftAPCSAForceDisconnect",  kCFBooleanFalse);
                                    uint64_t v114 = *(void *)(a1 + 64);
                                    CFNumberRef v115 = (const void *)sub_100043E8C(v114);
                                    uint64_t v116 = sub_10003EC6C(v114, v115, 349LL, 0LL, (uint64_t)v107);
                                    if (!(_DWORD)v116)
                                    {
                                      unsigned __int8 *v126 = valuePtr[0];
                                      CFRelease(v107);
LABEL_250:
                                      *(_BYTE *)(a1 + 1056) = 1;
                                      double v117 = objc_autoreleasePoolPush();
                                      if (qword_100219F60) {
                                        [qword_100219F60 WFLog:@"%s: Allow 5Ghz CarPlay & Hotspot concurrent mode\n" message:3];
                                      }
LABEL_254:
                                      objc_autoreleasePoolPop(v117);
LABEL_255:
                                      unsigned int v12 = (void *)cf;
                                      uint64_t v20 = v140;
                                      goto LABEL_200;
                                    }

                                    uint64_t v123 = v116;
                                    CFIndex v124 = objc_autoreleasePoolPush();
                                    if (qword_100219F60) {
                                      [qword_100219F60 WFLog:@"__WiFiDeviceManagerSwitchMISChannel: Failed to switch MIS channel to %d, err %d" message:4, "%s: Failed to switch MIS channel to %d, err %d", "__WiFiDeviceManagerSwitchMISChannel", valuePtr[0], v123];
                                    }
                                    objc_autoreleasePoolPop(v124);
                                    CFMutableArrayRef v19 = v139;
                                  }
                                }
                              }

                              CFRelease(v107);
                              goto LABEL_255;
                            }

                            uint64_t v118 = objc_autoreleasePoolPush();
                            if (qword_100219F60) {
                              [qword_100219F60 WFLog:@"%s Failed to create dict" message:4];
                            }
                          }
                        }

                        else
                        {
                          uint64_t v118 = objc_autoreleasePoolPush();
                          if (qword_100219F60) {
                            [qword_100219F60 WFLog:@"Invalid channel (%d)\n" message:4];
                          }
                        }
                      }
                    }

                    else
                    {
                      uint64_t v118 = objc_autoreleasePoolPush();
                      if (qword_100219F60) {
                        [qword_100219F60 WFLog:@"__WiFiDeviceManagerSwitchMISChannelForCarPlayJoin: No channel inform\n"];
                      }
                    }
                  }

                  else
                  {
                    uint64_t v118 = objc_autoreleasePoolPush();
                    if (qword_100219F60) {
                      [qword_100219F60 WFLog:@"%s: Not CarPlay network\n" message:4];
                    }
                  }
                }

                else
                {
                  uint64_t v118 = objc_autoreleasePoolPush();
                  if (qword_100219F60) {
                    [qword_100219F60 WFLog:@"__WiFiDeviceManagerSwitchMISChannelForCarPlayJoin: Not CarPlay join\n"];
                  }
                }

LABEL_258:
                objc_autoreleasePoolPop(v118);
                unsigned int v12 = (void *)cf;
                CFMutableArrayRef v19 = v139;
                uint64_t v20 = v140;
                goto LABEL_200;
              }

LABEL_268:
              int v82 = 0;
              goto LABEL_200;
            }
          }

          CFNumberRef v75 = 0LL;
        }

        else
        {
          CFNumberRef v75 = 0LL;
          CFNumberRef v68 = 0LL;
        }

        CFNumberRef v73 = v128;
        goto LABEL_154;
      }

      CFMutableArrayRef v58 = v130;
      CFMutableArrayRef v19 = v139;
      uint64_t v13 = kCFAllocatorDefault;
    }

    else
    {
      v122 = objc_autoreleasePoolPush();
      if (qword_100219F60) {
        objc_msgSend((id)qword_100219F60, "WFLog:message:", 3, "%s: null networks", "WiFiDeviceManagerSetNetworks");
      }
      objc_autoreleasePoolPop(v122);
      CFMutableArrayRef v58 = v130;
    }

    CFIndex v55 = v132;
    goto LABEL_122;
  }

  v121 = objc_autoreleasePoolPush();
  if (qword_100219F60) {
    [qword_100219F60 WFLog:@"%s: failed to create disabledNetworks array" message:3];
  }
  objc_autoreleasePoolPop(v121);
  int v82 = 0;
  theArray = 0LL;
LABEL_201:
  CFRelease(v19);
LABEL_202:
  if (v20) {
    CFRelease(v20);
  }
  BOOL v93 = theArray;
  if (v12) {
LABEL_205:
  }
    CFRelease(v12);
LABEL_206:
  if (v130) {
    CFRelease(v130);
  }
  if (Mutable) {
    CFRelease(Mutable);
  }
  if (v134) {
    CFRelease(v134);
  }
  if (v93) {
    CFRelease(v93);
  }
  *(_DWORD *)(a1 + 192) = 14;
  if (_os_feature_enabled_impl("CoreWiFi", "UnifiedAutoJoin"))
  {
    if (*(_DWORD *)(a1 + 5512) == 1)
    {
      uint64_t v94 = a1;
      unint64_t v95 = 32LL;
LABEL_222:
      sub_1000F5F98(v94, v95);
      return sub_1000D4854(a1);
    }

    if (v126[3565])
    {
      uint64_t v94 = a1;
      unint64_t v95 = 33LL;
      goto LABEL_222;
    }

    if (v82)
    {
      uint64_t v94 = a1;
      unint64_t v95 = 5LL;
      goto LABEL_222;
    }
  }

  else
  {
    [+[WiFiXPCManager sharedXPCManager](WiFiXPCManager, "sharedXPCManager") autoJoinStartedWithTrigger:5 interfaceName:sub_100043E8C(*(void *)(a1 + 64))];
    sub_1000D0A5C(a1, 0LL, (uint64_t)"WiFiDeviceManagerSetNetworks");
  }

  return sub_1000D4854(a1);
}

void *sub_1000D3348(uint64_t a1, const void *a2)
{
  return sub_1000DEA34(a1, a2, 1);
}

void sub_1000D3350(uint64_t a1)
{
  if (a1)
  {
    uint64_t v2 = (const void *)sub_100043E8C(*(void *)(a1 + 64));
    uint64_t v3 = sub_1000DEA34(a1, v2, 1);
    if (v3) {
      CFRelease(v3);
    }
    int v4 = objc_autoreleasePoolPush();
  }

  else
  {
    int v4 = objc_autoreleasePoolPush();
    if (qword_100219F60) {
      [qword_100219F60 WFLog:@"%s: null manager." message:3];
    }
  }

  objc_autoreleasePoolPop(v4);
}

uint64_t sub_1000D33DC(uint64_t a1)
{
  return *(void *)(a1 + 6640);
}

BOOL sub_1000D33E4(void *a1, const void *a2)
{
  int v4 = (const __CFArray *)a1[440];
  v8.length = CFArrayGetCount(v4);
  v8.location = 0LL;
  if (CFArrayContainsValue(v4, v8, a2)) {
    return 1LL;
  }
  id v5 = (const __CFArray *)a1[454];
  v9.length = CFArrayGetCount(v5);
  v9.location = 0LL;
  if (CFArrayContainsValue(v5, v9, a2)) {
    return 1LL;
  }
  CFIndex v7 = (const __CFArray *)a1[441];
  v10.length = CFArrayGetCount(v7);
  v10.location = 0LL;
  return CFArrayContainsValue(v7, v10, a2) != 0;
}

uint64_t sub_1000D3484(uint64_t a1, const void *a2)
{
  if (!a2) {
    return 0LL;
  }
  uint64_t result = sub_100095318((BOOL)a2);
  if ((_DWORD)result)
  {
    id v5 = *(const __CFArray **)(a1 + 3616);
    v7.length = CFArrayGetCount(v5);
    v7.location = 0LL;
    if (CFArrayContainsValue(v5, v7, a2))
    {
      return 1LL;
    }

    else
    {
      id v6 = *(const __CFArray **)(a1 + 3624);
      v8.length = CFArrayGetCount(v6);
      v8.location = 0LL;
      return CFArrayContainsValue(v6, v8, a2) != 0;
    }
  }

  return result;
}

void sub_1000D3518(uint64_t a1, const void *a2)
{
  if (a1)
  {
    unsigned int v3 = *(_DWORD *)(a1 + 72);
    BOOL v4 = v3 > 0xB;
    int v5 = (1 << v3) & 0x80E;
    BOOL v6 = v4 || v5 == 0;
    if (!v6 && sub_100043E8C(*(void *)(a1 + 64)))
    {
      CFRange v8 = (const __CFString *)sub_100043E8C(*(void *)(a1 + 64));
      CFStringGetCString(v8, buffer, 16LL, 0x8000100u);
      BOOL v9 = sub_10009E640((uint64_t)a2) != 0;
      network_config_set_interface_constrained(buffer, v9);
      CFRange v10 = objc_autoreleasePoolPush();
      id v11 = (void *)qword_100219F60;
      if (qword_100219F60)
      {
        unsigned int v12 = sub_10009E6CC((uint64_t)a2);
        uint64_t v13 = sub_10003B38C(v12);
        uint64_t v14 = sub_10009E6CC((uint64_t)a2);
        [v11 WFLog:3, "%s: updated save data mode to %@(%d) for network %@", "__WiFiDeviceManagerApplyConstrainedInterfaceConfig", v13, v14, sub_100095BC8(a2) message];
      }

      objc_autoreleasePoolPop(v10);
    }
  }

void sub_1000D3650(uint64_t a1, const void *a2)
{
  BOOL v4 = *(const void **)(a1 + 3504);
  if (v4)
  {
    CFRelease(v4);
    *(void *)(a1 + 3504) = 0LL;
  }

  if (a2)
  {
    int v5 = objc_autoreleasePoolPush();
    if (qword_100219F60) {
      [(id)qword_100219F60 WFLog:3, "%s, %@", "WiFiDeviceManagerSetPreviousNetwork", a2 message];
    }
    objc_autoreleasePoolPop(v5);
    BOOL v6 = sub_1000D91B0(a1, a2, 1);
    *(void *)(a1 + 3504) = v6;
    if (!v6) {
      *(void *)(a1 + 3504) = CFRetain(a2);
    }
  }

void sub_1000D36F4(void *a1, const void *a2, char a3, uint64_t a4)
{
  if (!a1[682])
  {
    CFMutableArrayRef v19 = objc_autoreleasePoolPush();
    if (qword_100219F60) {
      [qword_100219F60 WFLog:@"%s: netif is NULL!!!", "__WiFiDeviceManagerSetInterfaceRank"];
    }
    objc_autoreleasePoolPop(v19);
    return;
  }

  uint64_t v8 = 2863311530LL;
  if (a2)
  {
    BOOL v9 = sub_1000D91B0((uint64_t)a1, a2, 1);
    CFRange v10 = v9;
    if (v9)
    {
      uint64_t v8 = sub_10009E120((uint64_t)v9);
      BOOL v11 = (v8 - 1) < 2;
      if ((a3 & 1) != 0) {
        goto LABEL_25;
      }
      goto LABEL_8;
    }
  }

  else
  {
    CFRange v10 = 0LL;
  }

  BOOL v11 = 0;
  if ((a3 & 1) != 0) {
    goto LABEL_25;
  }
LABEL_8:
  a1[696] = 0LL;
  if (v10)
  {
    if ((v8 - 1) > 1)
    {
      a4 = 0LL;
    }

    else
    {
      unsigned int v12 = (const __CFDictionary *)sub_1000951FC((uint64_t)a2, @"11U_INTERWORKING_IE");
      if (v12)
      {
        CFBooleanRef Value = CFDictionaryGetValue(v12, @"INTERWORKING_ACCESS_INTERNET");
        a1[696] = Value;
        if (Value)
        {
          uint64_t v14 = objc_autoreleasePoolPush();
          if (qword_100219F60)
          {
            if ((const CFBooleanRef)a1[696] == kCFBooleanTrue) {
              CFMutableArrayRef v15 = "SET";
            }
            else {
              CFMutableArrayRef v15 = "ZERO";
            }
            [(id)qword_100219F60 WFLog:3, "%s: internetAccess bit %s for network %@", "__WiFiDeviceManagerSetInterfaceRank", v15, sub_100095BC8(a2) message];
          }

          objc_autoreleasePoolPop(v14);
        }
      }

      if ((_DWORD)v8 == 1) {
        a4 = 3LL;
      }
      else {
        a4 = 0LL;
      }
      CFMutableSetRef v16 = (void (*)(void *, void, void, uint64_t))a1[540];
      if (v16) {
        v16(a1, 0LL, a1[541], v8);
      }
      BOOL v11 = 1;
    }

    sub_1000D3518((uint64_t)a1, v10);
    if ((_DWORD)a4) {
      goto LABEL_36;
    }
    goto LABEL_29;
  }

  a4 = 0LL;
LABEL_25:
  if ((_DWORD)a4) {
    goto LABEL_36;
  }
LABEL_29:
  if (!v11
    && _os_feature_enabled_impl("WiFiManager", "AdaptiveInterfaceRanking")
    && +[WiFiAIRAgent sharedInstance](&OBJC_CLASS___WiFiAIRAgent, "sharedInstance"))
  {
    if (-[WiFiAIRAgent isInterfaceRankingInProgress]( +[WiFiAIRAgent sharedInstance](&OBJC_CLASS___WiFiAIRAgent, "sharedInstance"),  "isInterfaceRankingInProgress"))
    {
      -[WiFiAIRAgent terminateRequest]( +[WiFiAIRAgent sharedInstance](&OBJC_CLASS___WiFiAIRAgent, "sharedInstance"),  "terminateRequest");
    }

    sub_10001DE98();
    SCNetworkInterfaceSetPrimaryRank(a1[682], 3LL);
    v20[0] = _NSConcreteStackBlock;
    v20[1] = 3221225472LL;
    v20[2] = sub_1000FDB7C;
    v20[3] = &unk_1001E4EB8;
    int v21 = 0;
    v20[4] = a1;
    v20[5] = a2;
    -[WiFiAIRAgent waitForConfirmationWithTimeout:withBssEnvironment:withMgrCallback:]( +[WiFiAIRAgent sharedInstance](&OBJC_CLASS___WiFiAIRAgent, "sharedInstance"),  "waitForConfirmationWithTimeout:withBssEnvironment:withMgrCallback:",  a2,  sub_1000FDAE4((uint64_t)a1, a2),  v20);
    if (v10) {
      goto LABEL_42;
    }
    return;
  }

void sub_1000D3A2C(uint64_t a1, const void *a2)
{
  unsigned int valuePtr = 0;
  if (!a1)
  {
    CFMutableArrayRef v19 = objc_autoreleasePoolPush();
    if (qword_100219F60) {
      [qword_100219F60 WFLog:@"%s: manager is NULL" message:4];
    }
    goto LABEL_28;
  }

  if (!*(void *)(a1 + 5456))
  {
    CFMutableArrayRef v19 = objc_autoreleasePoolPush();
    if (qword_100219F60) {
      [qword_100219F60 WFLog:@"%s: netif is NULL" message:4];
    }
    goto LABEL_28;
  }

  if (!*(void *)(a1 + 5432))
  {
    CFMutableArrayRef v19 = objc_autoreleasePoolPush();
    if (qword_100219F60) {
      [qword_100219F60 WFLog:@"%s: dynamicStoreRef is NULL" message:4];
    }
    goto LABEL_28;
  }

  unsigned int v3 = sub_1000D91B0(a1, a2, 1);
  if (!v3)
  {
    CFMutableArrayRef v19 = objc_autoreleasePoolPush();
    if (qword_100219F60) {
      [qword_100219F60 WFLog:@"%s: no matching known network" message:4];
    }
LABEL_28:
    objc_autoreleasePoolPop(v19);
    return;
  }

  BOOL v4 = v3;
  uint64_t v5 = sub_10009E120((uint64_t)v3);
  int v25 = v5;
  BOOL v6 = (const __CFString *)sub_10004CE2C(*(void *)(a1 + 64));
  if (!v6)
  {
    uint64_t v20 = objc_autoreleasePoolPush();
    if (qword_100219F60) {
      [qword_100219F60 WFLog:@"%s: interfaceName is NULL." message:4];
    }
    goto LABEL_33;
  }

  NetworkInterfaceEntity = SCDynamicStoreKeyCreateNetworkInterfaceEntity( kCFAllocatorDefault,  kSCDynamicStoreDomainState,  v6,  kSCEntNetAirPort);
  if (!NetworkInterfaceEntity)
  {
    uint64_t v20 = objc_autoreleasePoolPush();
    if (qword_100219F60) {
      [qword_100219F60 WFLog:@"%s: stateKey is NULL." message:4];
    }
LABEL_33:
    objc_autoreleasePoolPop(v20);
    CFRelease(v4);
    return;
  }

  uint64_t v8 = NetworkInterfaceEntity;
  BOOL v9 = (const __CFDictionary *)SCDynamicStoreCopyValue(*(SCDynamicStoreRef *)(a1 + 5432), NetworkInterfaceEntity);
  if (v9)
  {
    CFRange v10 = v9;
    CFBooleanRef Value = (const __CFNumber *)CFDictionaryGetValue(v9, @"WiFiNetworkType");
    if (Value)
    {
      CFNumberGetValue(Value, kCFNumberIntType, &valuePtr);
      unsigned int v12 = valuePtr;
    }

    else
    {
      unsigned int v12 = 0;
    }

    if (v12 != (_DWORD)v5)
    {
      uint64_t v13 = objc_autoreleasePoolPush();
      if (qword_100219F60) {
        [qword_100219F60 WFLog:@"%s: update the network type from %d to %d" message:3, "__WiFiDeviceManagerUpdateDynamicStoreNetworkEntry", valuePtr, v5];
      }
      objc_autoreleasePoolPop(v13);
      MutableCFStringRef Copy = CFDictionaryCreateMutableCopy(kCFAllocatorDefault, 0LL, v10);
      if (MutableCopy)
      {
        CFMutableArrayRef v15 = MutableCopy;
        CFNumberRef v16 = CFNumberCreate(kCFAllocatorDefault, kCFNumberIntType, &v25);
        if (v16)
        {
          CFNumberRef v17 = v16;
          CFDictionarySetValue(v15, @"WiFiNetworkType", v16);
          SCDynamicStoreSetValue(*(SCDynamicStoreRef *)(a1 + 5432), v8, v15);
          CFRelease(v15);
          uint64_t v18 = v17;
        }

        else
        {
          uint64_t v23 = objc_autoreleasePoolPush();
          if (qword_100219F60) {
            [qword_100219F60 WFLog:@"%s: networkTypeNum is NULL" message:4];
          }
          objc_autoreleasePoolPop(v23);
          uint64_t v18 = v15;
        }

        CFRelease(v18);
      }

      else
      {
        NSErrorUserInfoKey v22 = objc_autoreleasePoolPush();
        if (qword_100219F60) {
          [qword_100219F60 WFLog:@"%s: newConfig is NULL" message:4];
        }
        objc_autoreleasePoolPop(v22);
      }
    }

    CFRelease(v10);
  }

  else
  {
    int v21 = objc_autoreleasePoolPush();
    if (qword_100219F60) {
      [qword_100219F60 WFLog:@"%s: config is NULL." message:4];
    }
    objc_autoreleasePoolPop(v21);
  }

  CFRelease(v4);
  CFRelease(v8);
}

void sub_1000D3E0C(uint64_t a1)
{
  uint64_t v2 = objc_autoreleasePoolPush();
  unsigned int v3 = +[NSMutableArray arrayWithArray:](&OBJC_CLASS___NSMutableArray, "arrayWithArray:", *(void *)(a1 + 3520));
  -[NSMutableArray addObjectsFromArray:](v3, "addObjectsFromArray:", *(void *)(a1 + 3616));
  v8.length = (CFIndex)-[NSMutableArray count](v3, "count");
  v8.location = 0LL;
  CFArraySortValues((CFMutableArrayRef)v3, v8, (CFComparatorFunction)sub_10009C1E4, 0LL);
  if (-[NSMutableArray count](v3, "count"))
  {
    uint64_t v4 = 0LL;
    int v5 = 0;
    unsigned __int16 v6 = 1;
    do
    {
      id v7 = -[NSMutableArray objectAtIndexedSubscript:](v3, "objectAtIndexedSubscript:", v4);
      uint64_t v4 = (unsigned __int16)++v5;
    }

    while ((unint64_t)-[NSMutableArray count](v3, "count") > (unsigned __int16)v5);
  }

  objc_autoreleasePoolPop(v2);
}

uint64_t sub_1000D3EF0(uint64_t a1, const void *a2)
{
  uint64_t v2 = 0xFFFFLL;
  if (a1 && a2)
  {
    int v5 = objc_autoreleasePoolPush();
    unsigned __int16 v6 = +[NSMutableArray arrayWithArray:](&OBJC_CLASS___NSMutableArray, "arrayWithArray:", *(void *)(a1 + 3520));
    -[NSMutableArray addObjectsFromArray:](v6, "addObjectsFromArray:", *(void *)(a1 + 3616));
    if (-[NSMutableArray count](v6, "count"))
    {
      uint64_t v7 = 0LL;
      int v8 = 0;
      while (1)
      {
        id v9 = -[NSMutableArray objectAtIndexedSubscript:](v6, "objectAtIndexedSubscript:", v7);
        CFRange v10 = (const __CFString *)sub_100095BC8(v9);
        BOOL v11 = (const __CFString *)sub_100095BC8(a2);
        if (CFStringCompare(v10, v11, 0LL) == kCFCompareEqualTo) {
          break;
        }
        uint64_t v7 = (unsigned __int16)++v8;
      }

      uint64_t v2 = sub_10009F85C((uint64_t)v9);
    }

    else
    {
LABEL_7:
      uint64_t v2 = 0xFFFFLL;
    }

    objc_autoreleasePoolPop(v5);
  }

  return v2;
}

void sub_1000D3FD0(uint64_t a1)
{
  uint64_t v2 = *(void *)(a1 + 3504);
  if (!v2
    || !sub_100097700(v2)
    || sub_1000951FC(*(void *)(a1 + 3504), @"WiFiInstantHotspotJoining") != kCFBooleanTrue
    && sub_1000951FC(*(void *)(a1 + 3504), @"WiFiAutoInstantHotspotJoining") != kCFBooleanTrue)
  {
    goto LABEL_13;
  }

  unsigned int v3 = (const __CFNumber *)sub_1000951FC(*(void *)(a1 + 3504), @"lastDisconnectReasonKey");
  if (!v3) {
    goto LABEL_13;
  }
  unsigned int valuePtr = -1431655766;
  CFNumberGetValue(v3, kCFNumberIntType, &valuePtr);
  if (valuePtr >= 3)
  {
    int v55 = 0;
    BOOL v13 = valuePtr == 1019;
    goto LABEL_14;
  }

  uint64_t v4 = (const __CFDate *)sub_1000951FC(*(void *)(a1 + 3504), @"lastDisconnectTimestampKey");
  if (!v4 || (int v5 = v4, Current = CFAbsoluteTimeGetCurrent(), Current - CFDateGetAbsoluteTime(v5) >= 300.0))
  {
LABEL_13:
    int v55 = 0;
    BOOL v13 = 0;
    goto LABEL_14;
  }

  uint64_t v7 = objc_autoreleasePoolPush();
  if (qword_100219F60)
  {
    int v8 = sub_100095BC8(*(const void **)(a1 + 3504));
    uint64_t v9 = valuePtr;
    double v10 = CFAbsoluteTimeGetCurrent();
    BOOL v11 = +[NSString stringWithFormat:]( &OBJC_CLASS___NSString,  "stringWithFormat:",  @"%s",  -[NSString UTF8String]( +[NSString stringWithFormat:]( &OBJC_CLASS___NSString,  "stringWithFormat:",  @"{%@*} %@",  @"AUTOJOIN",  +[NSString stringWithFormat:]( &OBJC_CLASS___NSString,  "stringWithFormat:",  @"%s Previous Hotspot %@ disconnect reason %d time since linkDown %.1f",  "__WiFiDeviceManagerFilterNetworks",  v8,  v9,  v10 - CFDateGetAbsoluteTime(v5))),  "UTF8String"));
    if (os_log_type_enabled((os_log_t)&_os_log_default, OS_LOG_TYPE_DEFAULT))
    {
      unsigned int v12 = -[NSString UTF8String]( +[NSString stringWithFormat:]( &OBJC_CLASS___NSString,  "stringWithFormat:",  @"[WiFiPolicy] %s",  -[NSString UTF8String](v11, "UTF8String")),  "UTF8String");
      *(_DWORD *)__int128 buf = 136446210;
      CFMutableArrayRef v58 = v12;
      _os_log_impl( (void *)&_mh_execute_header,  (os_log_t)&_os_log_default,  OS_LOG_TYPE_DEFAULT,  "%{public}s",  buf,  0xCu);
    }
  }

  objc_autoreleasePoolPop(v7);
  BOOL v13 = 0;
  int v55 = 1;
LABEL_14:
  CFIndex Count = CFArrayGetCount(*(CFArrayRef *)(a1 + 3520));
  if (Count >= 1)
  {
    CFIndex v15 = Count;
    for (CFIndex i = 0LL; i != v15; ++i)
    {
      ValueAtIndex = (void *)CFArrayGetValueAtIndex(*(CFArrayRef *)(a1 + 3520), i);
      if (ValueAtIndex)
      {
        uint64_t v18 = ValueAtIndex;
        if (sub_1000FC698(a1, ValueAtIndex, 1u))
        {
          if (!*(_BYTE *)(a1 + 6848)
            || (v19 = (const void *)sub_100043E8C(*(void *)(a1 + 64)), (uint64_t v20 = sub_1000DEA34(a1, v19, 1)) == 0LL)
            || (int v21 = v20,
                NSErrorUserInfoKey v22 = sub_100096804(v20),
                uint64_t v23 = sub_100096804(v18),
                LODWORD(v22) = CFEqual(v22, v23),
                CFRelease(v21),
                !(_DWORD)v22))
          {
            if (!v13
              || (uint64_t v24 = *(const void **)(a1 + 3504)) == 0LL
              || (int v25 = sub_100096804(v24), v26 = sub_100096804(v18), !CFEqual(v25, v26)))
            {
              CFArrayAppendValue(*(CFMutableArrayRef *)(a1 + 3536), v18);
              CFArrayAppendValue(*(CFMutableArrayRef *)(a1 + 3568), v18);
            }
          }
        }

        else
        {
          int v27 = objc_autoreleasePoolPush();
          if (qword_100219F60)
          {
            uint64_t v28 = +[NSString stringWithFormat:]( &OBJC_CLASS___NSString,  "stringWithFormat:",  @"%s",  -[NSString UTF8String]( +[NSString stringWithFormat:]( &OBJC_CLASS___NSString,  "stringWithFormat:",  @"{%@*} %@",  @"AUTOJOIN",  +[NSString stringWithFormat:]( &OBJC_CLASS___NSString,  "stringWithFormat:",  @"%s: %@ not suitable",  "__WiFiDeviceManagerFilterNetworks",  sub_100095BC8(v18))),  "UTF8String"));
            if (os_log_type_enabled((os_log_t)&_os_log_default, OS_LOG_TYPE_DEFAULT))
            {
              BOOL v29 = -[NSString UTF8String]( +[NSString stringWithFormat:]( &OBJC_CLASS___NSString,  "stringWithFormat:",  @"[WiFiPolicy] %s",  -[NSString UTF8String](v28, "UTF8String")),  "UTF8String");
              *(_DWORD *)__int128 buf = 136446210;
              CFMutableArrayRef v58 = v29;
              _os_log_impl( (void *)&_mh_execute_header,  (os_log_t)&_os_log_default,  OS_LOG_TYPE_DEFAULT,  "%{public}s",  buf,  0xCu);
            }
          }

          objc_autoreleasePoolPop(v27);
        }
      }
    }
  }

  CFArrayRemoveAllValues(*(CFMutableArrayRef *)(a1 + 3544));
  CFIndex v30 = CFArrayGetCount(*(CFArrayRef *)(a1 + 3528));
  if (v30 >= 1)
  {
    CFIndex v31 = v30;
    for (CFIndex j = 0LL; j != v31; ++j)
    {
      CFIndex v33 = (void *)CFArrayGetValueAtIndex(*(CFArrayRef *)(a1 + 3528), j);
      if (v33)
      {
        CFIndex v34 = v33;
        if (sub_1000FC698(a1, v33, 1u))
        {
          CFArrayAppendValue(*(CFMutableArrayRef *)(a1 + 3544), v34);
          v59.length = CFArrayGetCount(*(CFArrayRef *)(a1 + 3568));
          v59.location = 0LL;
          if (CFArrayGetFirstIndexOfValue(*(CFArrayRef *)(a1 + 3568), v59, v34) == -1) {
            CFArrayAppendValue(*(CFMutableArrayRef *)(a1 + 3568), v34);
          }
        }

        else
        {
          int v35 = objc_autoreleasePoolPush();
          if (qword_100219F60)
          {
            __int128 v36 = +[NSString stringWithFormat:]( &OBJC_CLASS___NSString,  "stringWithFormat:",  @"%s",  -[NSString UTF8String]( +[NSString stringWithFormat:]( &OBJC_CLASS___NSString,  "stringWithFormat:",  @"{%@*} %@",  @"AUTOJOIN",  +[NSString stringWithFormat:]( &OBJC_CLASS___NSString,  "stringWithFormat:",  @"%s: %@ not suitable",  "__WiFiDeviceManagerFilterNetworks",  sub_100095BC8(v34))),  "UTF8String"));
            if (os_log_type_enabled((os_log_t)&_os_log_default, OS_LOG_TYPE_DEFAULT))
            {
              __int128 v37 = -[NSString UTF8String]( +[NSString stringWithFormat:]( &OBJC_CLASS___NSString,  "stringWithFormat:",  @"[WiFiPolicy] %s",  -[NSString UTF8String](v36, "UTF8String")),  "UTF8String");
              *(_DWORD *)__int128 buf = 136446210;
              CFMutableArrayRef v58 = v37;
              _os_log_impl( (void *)&_mh_execute_header,  (os_log_t)&_os_log_default,  OS_LOG_TYPE_DEFAULT,  "%{public}s",  buf,  0xCu);
            }
          }

          objc_autoreleasePoolPop(v35);
        }
      }
    }
  }

  if (v55)
  {
    __int128 v38 = *(const void **)(a1 + 3504);
    if (v38)
    {
      CFArrayAppendValue(*(CFMutableArrayRef *)(a1 + 3544), v38);
      v60.length = CFArrayGetCount(*(CFArrayRef *)(a1 + 3568));
      v60.location = 0LL;
    }
  }

  CFIndex v39 = CFArrayGetCount(*(CFArrayRef *)(a1 + 3568));
  if (v39)
  {
    v61.length = v39;
    v61.location = 0LL;
    CFArraySortValues(*(CFMutableArrayRef *)(a1 + 3568), v61, (CFComparatorFunction)sub_10009C290, 0LL);
  }

  CFMutableStringRef Mutable = CFStringCreateMutable(kCFAllocatorDefault, 0LL);
  if (Mutable)
  {
    CFDataRef v41 = Mutable;
    CFDataRef v42 = *(const __CFArray **)(a1 + 3568);
    if (v42)
    {
      CFIndex v43 = CFArrayGetCount(v42);
      if (v43)
      {
        uint64_t v44 = v43;
        if (v43 >= 1)
        {
          CFIndex v45 = 0LL;
          if (v43 >= 5) {
            uint64_t v46 = 5LL;
          }
          else {
            uint64_t v46 = v43;
          }
          do
          {
            CFIndex v47 = CFArrayGetValueAtIndex(v42, v45);
            if (v47)
            {
              CFIndex v48 = v47;
              if (sub_100097264(v47))
              {
                uint64_t v49 = (const __CFString *)sub_1000951FC((uint64_t)v48, @"BSSID");
                if (v49) {
                  int v50 = v49;
                }
                else {
                  int v50 = @"null-bssid!";
                }
              }

              else
              {
                unsigned int v51 = (const __CFString *)sub_100095BC8(v48);
                if (v51) {
                  int v50 = v51;
                }
                else {
                  int v50 = @"null-ssid!";
                }
              }

              CFStringAppend(v41, v50);
              CFStringAppendFormat(v41, 0LL, @" ");
            }

            ++v45;
          }

          while (v46 != v45);
          if (v44 >= 6) {
            CFStringAppendFormat(v41, 0LL, @" ...");
          }
        }
      }
    }

    uint64_t v52 = objc_autoreleasePoolPush();
    if (qword_100219F60)
    {
      int v53 = +[NSString stringWithFormat:]( &OBJC_CLASS___NSString,  "stringWithFormat:",  @"%s",  -[NSString UTF8String]( +[NSString stringWithFormat:]( &OBJC_CLASS___NSString,  "stringWithFormat:",  @"{%@*} %@",  @"AUTOJOIN",  +[NSString stringWithFormat:]( &OBJC_CLASS___NSString,  "stringWithFormat:",  @"%s: Filtered networks - %@",  "__WiFiDeviceManagerFilterNetworks",  v41)),  "UTF8String"));
      if (os_log_type_enabled((os_log_t)&_os_log_default, OS_LOG_TYPE_DEFAULT))
      {
        uint64_t v54 = -[NSString UTF8String]( +[NSString stringWithFormat:]( &OBJC_CLASS___NSString,  "stringWithFormat:",  @"[WiFiPolicy] %s",  -[NSString UTF8String](v53, "UTF8String")),  "UTF8String");
        *(_DWORD *)__int128 buf = 136446210;
        CFMutableArrayRef v58 = v54;
        _os_log_impl( (void *)&_mh_execute_header,  (os_log_t)&_os_log_default,  OS_LOG_TYPE_DEFAULT,  "%{public}s",  buf,  0xCu);
      }
    }

    objc_autoreleasePoolPop(v52);
    CFRelease(v41);
  }

uint64_t sub_1000D4854(uint64_t a1)
{
  uint64_t v2 = objc_autoreleasePoolPush();
  if (!sub_100047598(*(void *)(a1 + 64)))
  {
    uint64_t v30 = 0LL;
    goto LABEL_107;
  }

  if (*(_DWORD *)(a1 + 20) == 1)
  {
    CFMutableStringRef Mutable = CFArrayCreateMutable(kCFAllocatorDefault, 0LL, &kCFTypeArrayCallBacks);
    if (*(_DWORD *)(a1 + 176))
    {
      if (sub_1000CAC54(a1))
      {
        uint64_t v64 = v2;
        uint64_t v4 = (const void *)sub_100043E8C(*(void *)(a1 + 64));
        int v5 = sub_1000DEA34(a1, v4, 1);
        CFIndex Count = CFArrayGetCount(*(CFArrayRef *)(a1 + 3520));
        CFNumberRef v67 = v5;
        if (Count >= 1)
        {
          CFIndex v7 = Count;
          CFIndex v8 = 0LL;
          CFIndex v65 = Count;
          uint64_t v66 = a1;
          while (1)
          {
            ValueAtIndex = (CFDictionaryRef *)CFArrayGetValueAtIndex(*(CFArrayRef *)(a1 + 3520), v8);
            if (ValueAtIndex) {
              break;
            }
LABEL_26:
            if (v7 == ++v8) {
              goto LABEL_38;
            }
          }

          double v10 = ValueAtIndex;
          id v11 = sub_1000A335C((uint64_t)ValueAtIndex);
          id v12 = [*(id *)(a1 + 6632) isNetworkInDenyListedState:3 scanResult:v11];
          unsigned int v69 = [*(id *)(a1 + 6632) isNetworkInDenyListedState:1 scanResult:v11];
          unsigned int v68 = [*(id *)(a1 + 6632) isNetworkDenyListedForAutoJoinDueToTrigDisc:v11 RSSI:0 timestamp:0];
          BOOL v13 = sub_1000A063C(v10);
          if (v13)
          {
            unsigned int v70 = [*(id *)(a1 + 8776) isKnownNetworkDisallowed:v13];
          }

          else
          {
            id v14 = v12;
            CFIndex v15 = objc_autoreleasePoolPush();
            if (qword_100219F60) {
              [qword_100219F60 WFLog:@"message: %s: Unable to create CWFNetworkProfile. Skipping isKnownNetworkDisallowed check" message:@"WiFiDeviceManagerSetBackgroundScan"];
            }
            objc_autoreleasePoolPop(v15);
            unsigned int v70 = 0;
            id v12 = v14;
          }

          if (byte_100219FA1) {
            BOOL v16 = v5 == 0LL;
          }
          else {
            BOOL v16 = 1;
          }
          if (v16
            || (CFNumberRef v17 = (const __CFString *)sub_100095BC8(v5),
                uint64_t v18 = (const __CFString *)sub_100095BC8(v10),
                CFStringCompare(v17, v18, 0LL) == kCFCompareEqualTo))
          {
            unsigned int v20 = 1;
          }

          else
          {
            CFMutableArrayRef v19 = sub_1000A063C(v10);
            unsigned int v20 = [v19 isAllowedInLockdownMode];
          }

          if (!sub_1000971AC((uint64_t)v10)
            && sub_1000974EC((uint64_t)v10)
            && v20
            && !v70
            && ((v69 & 1) == 0 || v68))
          {
            CFArrayAppendValue(Mutable, v10);
LABEL_25:

            goto LABEL_26;
          }

void sub_1000D5088(uint64_t a1, const void *a2)
{
  if (a1)
  {
    if (a2)
    {
      uint64_t v4 = *(void *)(a1 + 64);
      int v5 = (const void *)sub_100043E8C(v4);
      unsigned __int16 v6 = sub_100040538(v4, v5);
      if (v6)
      {
        CFIndex v7 = v6;
        CFIndex v8 = sub_100095BC8(v6);
        if (v8)
        {
          uint64_t v9 = v8;
          if (CFEqual(a2, v8))
          {
            double v10 = *(const void **)(a1 + 6640);
            if (v10)
            {
              CFRelease(v10);
              *(void *)(a1 + 6640) = 0LL;
            }

            *(void *)(a1 + 6640) = CFRetain(v9);
          }
        }

        CFRelease(v7);
      }
    }

    else
    {
      id v11 = *(const void **)(a1 + 6640);
      if (v11) {
        CFRelease(v11);
      }
      *(void *)(a1 + 6640) = 0LL;
    }
  }

void sub_1000D5134(uint64_t a1, CFTypeRef cf)
{
  uint64_t v4 = *(const void **)(a1 + 3608);
  if (v4)
  {
    CFRelease(v4);
    *(void *)(a1 + 360_Block_object_dispose(va, 8) = 0LL;
  }

  if (cf) {
    *(void *)(a1 + 360_Block_object_dispose(va, 8) = CFRetain(cf);
  }
}

void sub_1000D5174(uint64_t a1, CFTypeRef cf)
{
  if (a1 && cf)
  {
    CFRetain(cf);
    uint64_t v4 = *(const void **)(a1 + 3696);
    if (v4) {
      CFRelease(v4);
    }
    *(void *)(a1 + 3696) = cf;
    sub_1000D3350(a1);
  }

uint64_t sub_1000D51C4(uint64_t result, uint64_t a2)
{
  if (result)
  {
    if (a2)
    {
      uint64_t v3 = *(void *)(result + 64);
      uint64_t v4 = (const void *)sub_100043E8C(v3);
      return sub_10003EC6C(v3, v4, 484LL, 0LL, a2);
    }
  }

  return result;
}

void sub_1000D5214(uint64_t a1, CFTypeRef cf, int a3)
{
  unsigned __int16 v6 = *(const void **)(a1 + 320);
  if (v6)
  {
    CFRelease(v6);
    *(void *)(a1 + 320) = 0LL;
  }

  if (cf)
  {
    *(void *)(a1 + 320) = CFRetain(cf);
    *(_DWORD *)(a1 + 5620) = a3;
    sub_1000D0AAC(a1, 1LL, (uint64_t)"WiFiDeviceManagerSetRetryIntervals");
  }

void sub_1000D5284(uint64_t a1, uint64_t a2)
{
  *(_BYTE *)(a1 + 3680) = a2;
  uint64_t v2 = *(void *)(a1 + 64);
  if (v2)
  {
    sub_100052844(v2, a2);
  }

  else
  {
    uint64_t v3 = objc_autoreleasePoolPush();
    if (qword_100219F60) {
      [qword_100219F60 WFLog:@"No Device" message:4];
    }
    objc_autoreleasePoolPop(v3);
  }

void sub_1000D52F8(uint64_t a1, CFTypeRef cf)
{
  if (!a1)
  {
    int v5 = objc_autoreleasePoolPush();
    if (qword_100219F60) {
      [qword_100219F60 WFLog:@"%s: manager ref is null" message:4];
    }
    goto LABEL_10;
  }

  if (!cf)
  {
    int v5 = objc_autoreleasePoolPush();
    if (qword_100219F60) {
      [qword_100219F60 WFLog:@"%s: wifiAmbiguousSSIDs is null" message:4];
    }
LABEL_10:
    objc_autoreleasePoolPop(v5);
    return;
  }

  CFRetain(cf);
  uint64_t v4 = *(const void **)(a1 + 3712);
  if (v4) {
    CFRelease(v4);
  }
  *(void *)(a1 + 3712) = cf;
}

void sub_1000D53B8(uint64_t a1, int a2)
{
  if (*(_DWORD *)(a1 + 6560) != a2)
  {
    *(_DWORD *)(a1 + 6560) = a2;
    if (a2)
    {
      if (_os_feature_enabled_impl("CoreWiFi", "UnifiedAutoJoin"))
      {
        sub_1000F5F98(a1, 0x11uLL);
      }

      else
      {
        [+[WiFiXPCManager sharedXPCManager](WiFiXPCManager, "sharedXPCManager") autoJoinStartedWithTrigger:17 interfaceName:sub_100043E8C(*(void *)(a1 + 64))];
        sub_1000D0A5C(a1, 2LL, (uint64_t)"WiFiDeviceManagerSetJoinRecommendationMode");
      }
    }
  }

void sub_1000D5458(uint64_t a1, int a2)
{
  if (a2 == 5) {
    sub_1000D157C(a1, 1u);
  }
  else {
    *(_DWORD *)(a1 + 160) = a2;
  }
}

void sub_1000D5470(uint64_t a1, uint64_t a2)
{
  uint64_t v4 = objc_autoreleasePoolPush();
  if (qword_100219F60) {
    objc_msgSend((id)qword_100219F60, "WFLog:message:", 2, "wake mode set to %d", a2);
  }
  objc_autoreleasePoolPop(v4);
  *(_DWORD *)(a1 + 16_Block_object_dispose(va, 8) = a2;
}

id sub_1000D54D8(uint64_t *a1, int a2, const void *a3)
{
  unsigned __int16 v6 = (const void *)a1[14];
  if (v6)
  {
    CFRelease(v6);
    a1[14] = 0LL;
  }

  if (a3) {
    a1[14] = (uint64_t)CFRetain(a3);
  }
  id result = (id)a1[836];
  if (result) {
    return [result enableTestMode:a2 != 0];
  }
  return result;
}

void sub_1000D554C(uint64_t a1, uint64_t a2, int a3)
{
  unsigned __int16 v6 = objc_autoreleasePoolPush();
  if (qword_100219F60) {
    [qword_100219F60 WFLog:@"WiFiDeviceManagerSetUserInteractionMode" message:3, "%s: %d", "WiFiDeviceManagerSetUserInteractionMode", a2];
  }
  objc_autoreleasePoolPop(v6);
  int v7 = *(_DWORD *)(a1 + 176);
  if ((_DWORD)a2) {
    BOOL v8 = v7 == 0;
  }
  else {
    BOOL v8 = 0;
  }
  char v9 = !v8;
  if (v7 != (_DWORD)a2)
  {
    if (*(void *)(a1 + 240))
    {
      if (!*(void *)(a1 + 6688))
      {
        double v10 = objc_autoreleasePoolPush();
        id v11 = -[WiFiUserNotificationManager initWithQueue:supportsWAPI:]( objc_alloc(&OBJC_CLASS___WiFiUserNotificationManager),  "initWithQueue:supportsWAPI:",  *(void *)(a1 + 240),  *(unsigned __int8 *)(a1 + 88));
        *(void *)(a1 + 668_Block_object_dispose(va, 8) = v11;
        if (v11)
        {
          -[WiFiUserNotificationManager startListening](v11, "startListening");
          [*(id *)(a1 + 6688) registerCallback:&stru_1001E4B68 withContext:a1];
          *(_DWORD *)(a1 + 6700) = 0;
          [*(id *)(a1 + 6688) enableTestMode:sub_1001344F8(*(void *)(a1 + 96)) != 0];
        }

        else
        {
          id v12 = objc_autoreleasePoolPush();
          if (qword_100219F60) {
            [qword_100219F60 WFLog:@"%s: failed to create user notification manager" message:4];
          }
          objc_autoreleasePoolPop(v12);
        }

        objc_autoreleasePoolPop(v10);
      }

      if (*(_DWORD *)(a1 + 20) == 1)
      {
        keys = @"IO80211InterfaceRadioMODE";
        BOOL v13 = (void **)&kCFBooleanFalse;
        if ((_DWORD)a2 == 1) {
          BOOL v13 = (void **)&kCFBooleanTrue;
        }
        values = *v13;
        CFDictionaryRef v14 = CFDictionaryCreate( kCFAllocatorDefault,  (const void **)&keys,  (const void **)&values,  1LL,  &kCFTypeDictionaryKeyCallBacks,  &kCFTypeDictionaryValueCallBacks);
        if (v14)
        {
          CFDictionaryRef v15 = v14;
          uint64_t v16 = *(void *)(a1 + 64);
          CFNumberRef v17 = (const void *)sub_100043E8C(v16);
          sub_10003EC6C(v16, v17, 473LL, 0LL, (uint64_t)v15);
          CFRelease(v15);
        }
      }

      else
      {
        uint64_t v18 = objc_autoreleasePoolPush();
        if (qword_100219F60) {
          [(id)qword_100219F60 WFLog:3 message:"MIMO Power Save Configuration cancelled because device is not powered."];
        }
        objc_autoreleasePoolPop(v18);
      }

      if ((_DWORD)a2 == 1) {
        *(_DWORD *)(a1 + 6700) = 0;
      }
      if (!a3) {
        *(CFAbsoluteTime *)(a1 + 216) = CFAbsoluteTimeGetCurrent();
      }
      sub_1000D6494(a1);
      int v7 = *(_DWORD *)(a1 + 176);
    }

    if (v7 != (_DWORD)a2) {
      goto LABEL_58;
    }
  }

  if (*(unsigned __int8 *)(a1 + 208) != a3)
  {
LABEL_58:
    uint64_t v19 = *(void *)(a1 + 64);
    unsigned int v20 = (const void *)sub_100043E8C(v19);
    int v21 = sub_100040538(v19, v20);
    if (v21)
    {
      NSErrorUserInfoKey v22 = v21;
      if (sub_100097700((uint64_t)v21))
      {
        if (!a3)
        {
          unsigned int v27 = *(dispatch_source_s **)(a1 + 6768);
          dispatch_time_t v28 = dispatch_time(0LL, 315360000000000000LL);
          dispatch_source_set_timer(v27, v28, 0xFFFFFFFFFFFFFFFFLL, 0LL);
          double v26 = CFAbsoluteTimeGetCurrent() + 315360000.0;
          goto LABEL_39;
        }

        double v23 = *(double *)(a1 + 6776);
        if (v23 > CFAbsoluteTimeGetCurrent() + 3600.0)
        {
          id v24 = *(dispatch_source_s **)(a1 + 6768);
          dispatch_time_t v25 = dispatch_time(0LL, 3600000000000LL);
          dispatch_source_set_timer(v24, v25, 0xFFFFFFFFFFFFFFFFLL, 0LL);
          double v26 = CFAbsoluteTimeGetCurrent() + 3600.0;
LABEL_39:
          *(double *)(a1 + 6776) = v26;
        }
      }

      CFRelease(v22);
    }
  }

  *(_BYTE *)(a1 + 20_Block_object_dispose(va, 8) = a3;
  *(_DWORD *)(a1 + 176) = a2;
  sub_1000154D0(*(void *)(a1 + 120), a2);
  if ((_DWORD)a2 == 3)
  {
    else {
      sub_1000D66BC(a1, 0);
    }
    [*(id *)(a1 + 6688) dismissJoinAlerts];
  }

  sub_100134094(*(void *)(a1 + 96), a2);
  if ((v9 & 1) == 0) {
    sub_1000D4854(a1);
  }
  uint64_t v29 = *(void **)(a1 + 7320);
  if (v29)
  {
    BOOL v30 = (*(_DWORD *)(a1 + 176) - 1) < 2;
    [v29 setDeviceLockState:a3 != 0];
    [*(id *)(a1 + 7320) setDisplayState:v30];
  }

  if (a3) {
    a3 = *(_BYTE *)(a1 + 3456) == 0;
  }
  else {
    int v31 = a3;
  }
  sub_1000CE334(a1, v31);
}

void sub_1000D5954(id a1, int a2, id a3, int a4, void *a5)
{
  uint64_t v6 = *(void *)&a4;
  uint64_t v8 = *(void *)&a2;
  char v9 = objc_autoreleasePoolPush();
  if (qword_100219F60) {
    [qword_100219F60 WFLog:@"__WiFiDeviceManagerHandleUserNotificationResponse" message:3 responseType:v6 notifyType:v8];
  }
  objc_autoreleasePoolPop(v9);
  switch((int)v8)
  {
    case 1:
      if ((_DWORD)v6 == 1)
      {
        id v11 = objc_msgSend(objc_msgSend(a3, "scannedNetwork"), "scanProperties");
        id v12 = objc_autoreleasePoolPush();
        if (qword_100219F60) {
          [qword_100219F60 WFLog:3, "%s: user accepted recommendation for %@", "__WiFiDeviceManagerHandleUserNotificationResponse", [a3 network] message];
        }
        objc_autoreleasePoolPop(v12);
        if (objc_msgSend(objc_msgSend(a3, "network"), "source") == (id)2) {
          BOOL v13 = sub_100094CE8((const __CFString *)objc_msgSend(objc_msgSend(a3, "network"), "SSID"));
        }
        else {
          BOOL v13 = 0LL;
        }
        if (!v13 && v11) {
          BOOL v13 = sub_100094AAC((uint64_t)kCFAllocatorDefault, v11);
        }
        if (v13)
        {
          if (objc_msgSend(objc_msgSend(a3, "network"), "source") == (id)1)
          {
            sub_1000A0088((uint64_t)v13, objc_msgSend(objc_msgSend(a3, "network"), "uniqueIdentifier"));
            sub_10009ED2C((uint64_t)v13, 3u);
          }

          sub_1000D03E4((uint64_t)a5);
          if (objc_msgSend(objc_msgSend(a3, "network"), "password"))
          {
            CFIndex v45 = objc_autoreleasePoolPush();
            if (qword_100219F60) {
              [(id)qword_100219F60 WFLog:3, "%s: setting password for network %@", "__WiFiDeviceManagerHandleUserNotificationResponse", sub_100095BC8(v13) message];
            }
            objc_autoreleasePoolPop(v45);
            sub_100099C50(v13, (const __CFString *)objc_msgSend(objc_msgSend(a3, "network"), "password"));
          }

          sub_10010B9B4((uint64_t *)a5, @"userJoinAssociating", v13);
          uint64_t v46 = objc_autoreleasePoolPush();
          if (qword_100219F60) {
            [qword_100219F60 WFLog:@"__WiFiDeviceManagerHandleUserNotificationResponse: found matching network in scan results, proceeding with association"];
          }
          objc_autoreleasePoolPop(v46);
          CFIndex v47 = (const void *)sub_100043E8C(*((void *)a5 + 8));
          if (sub_1000E1104((uint64_t)a5, v47, v13, 0LL, 0LL, (uint64_t)sub_100110C3C, 0LL, 1016LL))
          {
            sub_1000D02BC((uint64_t)a5);
            uint64_t v48 = sub_100043E8C(*((void *)a5 + 8));
            sub_1000EF770((uint64_t)a5, v48, 7LL, 0LL, v13, 0LL);
            sub_10010B9B4((uint64_t *)a5, @"userJoinAssociationFailed", v13);
          }

          goto LABEL_86;
        }

        int v53 = objc_autoreleasePoolPush();
        if (qword_100219F60) {
          [qword_100219F60 WFLog:3, @"%s: scan required, no scan properties for network %@", @"__WiFiDeviceManagerHandleUserNotificationResponse", [a3 network] message];
        }
        uint64_t v54 = v53;
        goto LABEL_99;
      }

      int v40 = objc_autoreleasePoolPush();
      if (qword_100219F60)
      {
        if ((_DWORD)v6) {
          char v41 = @"system";
        }
        else {
          char v41 = @"user";
        }
        [(id)qword_100219F60 WFLog:3, "%s: %@ dismissed recommendation %@ current state %@", "__WiFiDeviceManagerHandleUserNotificationResponse", v41, a3, sub_1000BDC98(*((_DWORD *)a5 + 818)) message];
      }

      objc_autoreleasePoolPop(v40);
      uint64_t v42 = objc_opt_class(&OBJC_CLASS___NSString);
      if ((objc_opt_isKindOfClass(a3, v42) & 1) != 0) {
        goto LABEL_51;
      }
      if ([a3 SSID])
      {
        a3 = [a3 SSID];
LABEL_51:
        uint64_t v19 = sub_100094CE8((const __CFString *)a3);
      }

      else
      {
        uint64_t v19 = 0LL;
      }

      if (*((_DWORD *)a5 + 818) == 14)
      {
        sub_1000D0428((uint64_t)a5);
        sub_1000D16F4((uint64_t)a5, 1);
        if (*((_DWORD *)a5 + 5) == 1)
        {
          *((_DWORD *)a5 + 4_Block_object_dispose(va, 8) = 16;
          if (_os_feature_enabled_impl("CoreWiFi", "UnifiedAutoJoin"))
          {
            sub_1000F5F98((uint64_t)a5, 0x11uLL);
          }

          else
          {
            [+[WiFiXPCManager sharedXPCManager](WiFiXPCManager, "sharedXPCManager") autoJoinStartedWithTrigger:17 interfaceName:sub_100043E8C(*((void *)a5 + 8))];
            sub_1000D0A5C((uint64_t)a5, 2LL, (uint64_t)"__WiFiDeviceManagerHandleUserNotificationResponse");
          }
        }
      }

      break;
    case 2:
      CFDictionaryRef v14 = (const void *)sub_10004CE2C(*((void *)a5 + 8));
      CFDictionaryRef v15 = sub_1000DEA34((uint64_t)a5, v14, 1);
      if (!v15) {
        goto LABEL_100;
      }
      BOOL v13 = v15;
      if ((_DWORD)v6 == 3)
      {
        CFRange v49 = objc_autoreleasePoolPush();
        if (qword_100219F60) {
          [(id)qword_100219F60 WFLog:3, "%s: user launched settings for %@", "__WiFiDeviceManagerHandleUserNotificationResponse", a3 message];
        }
        objc_autoreleasePoolPop(v49);
        sub_10010B64C(2LL, (CFDictionaryRef *)v13);
      }

      else if ((_DWORD)v6 == 2)
      {
        uint64_t v16 = objc_autoreleasePoolPush();
        if (qword_100219F60) {
          [(id)qword_100219F60 WFLog:3, "%s: user disconnected from %@", "__WiFiDeviceManagerHandleUserNotificationResponse", a3 message];
        }
        objc_autoreleasePoolPop(v16);
        sub_1000D1AEC((uint64_t)a5, v13);
      }

      else
      {
        int v50 = objc_autoreleasePoolPush();
        if (qword_100219F60) {
          [(id)qword_100219F60 WFLog:3, "%s: user dismissed join alert for %@", "__WiFiDeviceManagerHandleUserNotificationResponse", a3 message];
        }
        objc_autoreleasePoolPop(v50);
      }

LABEL_87:
      CFRelease(v13);
      break;
    case 5:
      double v26 = -[CWFScanResult initWithScanRecord:includeProperties:]( [CWFScanResult alloc],  "initWithScanRecord:includeProperties:",  [a3 objectForKeyedSubscript:@"ToScanResult"],  0);
      unsigned int v27 = -[CWFScanResult initWithScanRecord:includeProperties:]( [CWFScanResult alloc],  "initWithScanRecord:includeProperties:",  [a3 objectForKeyedSubscript:@"FromScanResult"],  0);
      dispatch_time_t v28 = objc_autoreleasePoolPush();
      if ((_DWORD)v6 == 1)
      {
        if (qword_100219F60) {
          [(id)qword_100219F60 WFLog:3, "%s: user joined colocated SSID network %@", "__WiFiDeviceManagerHandleUserNotificationResponse", v26 message];
        }
        objc_autoreleasePoolPop(v28);
        uint64_t v29 = sub_1000A3DB0(v26);
        if (v29)
        {
          BOOL v30 = v29;
          sub_1000D03E4((uint64_t)a5);
          if (sub_100098BF8((uint64_t)v30))
          {
            int v31 = (const void *)sub_10004CE2C(*((void *)a5 + 8));
            uint64_t v32 = (CFDictionaryRef *)sub_1000DEA34((uint64_t)a5, v31, 1);
            if (v32)
            {
              id v33 = v32;
              CFStringRef v34 = sub_100095408(v32);
              if (v34)
              {
                char v35 = v34;
                __int128 v36 = objc_autoreleasePoolPush();
                if (qword_100219F60) {
                  [(id)qword_100219F60 WFLog:3, "%s: setting password for network %@", "__WiFiDeviceManagerHandleUserNotificationResponse", sub_100095BC8(v30) message];
                }
                objc_autoreleasePoolPop(v36);
                sub_100099C50(v30, v35);
                CFRelease(v35);
              }

              CFRelease(v33);
            }
          }

          sub_10010B9B4((uint64_t *)a5, @"userJoinAssociating", v30);
          __int128 v37 = (const void *)sub_100043E8C(*((void *)a5 + 8));
          if (sub_1000E1104((uint64_t)a5, v37, v30, 0LL, 0LL, (uint64_t)sub_100110C3C, 0LL, 1016LL))
          {
            sub_1000D02BC((uint64_t)a5);
            uint64_t v38 = sub_100043E8C(*((void *)a5 + 8));
            sub_1000EF770((uint64_t)a5, v38, 7LL, 0LL, v30, 0LL);
            sub_10010B9B4((uint64_t *)a5, @"userJoinAssociationFailed", v30);
            sub_1000FFC68((uint64_t)a5);
          }

          uint64_t v19 = sub_100094E60((uint64_t)kCFAllocatorDefault, (uint64_t)v30);
          CFRelease(v30);
        }

        else
        {
          uint64_t v19 = 0LL;
        }

        uint64_t v52 = (NSMutableDictionary *)objc_msgSend( -[NSUserDefaults objectForKey:]( +[NSUserDefaults standardUserDefaults]( NSUserDefaults,  "standardUserDefaults"),  "objectForKey:",  @"UserDismissedColocatedSSIDTimestamps"),  "mutableCopy");
        if (!v52) {
          uint64_t v52 = objc_alloc_init(&OBJC_CLASS___NSMutableDictionary);
        }
        -[NSMutableDictionary setObject:forKeyedSubscript:]( v52,  "setObject:forKeyedSubscript:",  +[NSDate now](&OBJC_CLASS___NSDate, "now"),  +[NSString stringWithFormat:]( &OBJC_CLASS___NSString,  "stringWithFormat:",  @"%@",  -[CWFScanResult networkName](v26, "networkName")));
        -[NSUserDefaults setObject:forKey:]( +[NSUserDefaults standardUserDefaults](&OBJC_CLASS___NSUserDefaults, "standardUserDefaults"),  "setObject:forKey:",  v52,  @"UserDismissedColocatedSSIDTimestamps");
      }

      else
      {
        if (qword_100219F60)
        {
          if ((_DWORD)v6) {
            CFIndex v43 = @"system";
          }
          else {
            CFIndex v43 = @"user";
          }
          [(id)qword_100219F60 WFLog:3, "%s: %@ dismissed colocated SSID notification (scanResult=(%@), state=%@)", "__WiFiDeviceManagerHandleUserNotificationResponse", v43, v26, sub_1000BDC98(*((_DWORD *)a5 + 818)) message];
        }

        objc_autoreleasePoolPop(v28);
        uint64_t v19 = sub_1000A3DB0(v26);
        if (!(_DWORD)v6)
        {
          CFIndex v44 = (NSMutableDictionary *)objc_msgSend( -[NSUserDefaults objectForKey:]( +[NSUserDefaults standardUserDefaults]( NSUserDefaults,  "standardUserDefaults"),  "objectForKey:",  @"UserDismissedColocatedSSIDTimestamps"),  "mutableCopy");
          if (!v44) {
            CFIndex v44 = objc_alloc_init(&OBJC_CLASS___NSMutableDictionary);
          }
          -[NSMutableDictionary setObject:forKeyedSubscript:]( v44,  "setObject:forKeyedSubscript:",  +[NSDate now](&OBJC_CLASS___NSDate, "now"),  +[NSString stringWithFormat:]( &OBJC_CLASS___NSString,  "stringWithFormat:",  @"%@",  -[CWFScanResult networkName](v26, "networkName")));
          -[NSUserDefaults setObject:forKey:]( +[NSUserDefaults standardUserDefaults](&OBJC_CLASS___NSUserDefaults, "standardUserDefaults"),  "setObject:forKey:",  v44,  @"UserDismissedColocatedSSIDTimestamps");

          sub_1000FFC68((uint64_t)a5);
        }
      }

      break;
    case 6:
      if (*((_DWORD *)a5 + 818) == 17)
      {
        *((_DWORD *)a5 + 81_Block_object_dispose(va, 8) = 12;
        int v39 = sub_100110EF8(v10, v6);
        uint64_t v19 = 0LL;
        *((_DWORD *)a5 + 81_Block_object_dispose(va, 8) = sub_10010B464((uint64_t)a5, v39);
      }

      else
      {
        uint64_t v56 = objc_autoreleasePoolPush();
        if (qword_100219F60) {
          [(id)qword_100219F60 WFLog:4, "%s: Received notification in unexpected state: %@", "__WiFiDeviceManagerHandleUserNotificationResponse", sub_1000BDC98(*((_DWORD *)a5 + 818)) message];
        }
        uint64_t v54 = v56;
LABEL_99:
        objc_autoreleasePoolPop(v54);
LABEL_100:
        uint64_t v19 = 0LL;
      }

      break;
    default:
      goto LABEL_100;
  }

  int v55 = (void (*)(void *, const void *, uint64_t, uint64_t, void))*((void *)a5 + 584);
  if (v55) {
    v55(a5, v19, v8, v6, *((void *)a5 + 585));
  }
  if (v19) {
    CFRelease(v19);
  }
}

void sub_1000D6494(uint64_t a1)
{
  uint64_t v2 = (unsigned __int8 *)(a1 + 7032);
  uint64_t v3 = *(unsigned __int8 *)(a1 + 7034);
  uint64_t v4 = (const void *)sub_100043E8C(*(void *)(a1 + 64));
  int v5 = sub_1000DEA34(a1, v4, 1);
  if (v5)
  {
    uint64_t v6 = v5;
    if (sub_1000973BC((uint64_t)v5) && (_DWORD)v3 == 0)
    {
      CFAbsoluteTime Current = CFAbsoluteTimeGetCurrent();
      uint64_t v3 = 0LL;
      double v9 = *(double *)(a1 + 216);
      double v10 = Current - v9;
      id v11 = "disabled";
      if (v9 != 0.0 && v10 <= 3600.0)
      {
        uint64_t v3 = *(_BYTE *)(a1 + 3440) != 0;
        if (*(_BYTE *)(a1 + 3440)) {
          id v11 = "enabled";
        }
      }

      id v12 = objc_autoreleasePoolPush();
      BOOL v13 = (void *)qword_100219F60;
      if (qword_100219F60)
      {
        CFDictionaryRef v14 = sub_100095BC8(v6);
        CFDictionaryRef v15 = "enable";
        if (*v2) {
          uint64_t v16 = "enable";
        }
        else {
          uint64_t v16 = "disable";
        }
        if (!v2[1]) {
          CFDictionaryRef v15 = "disable";
        }
        if (*(_BYTE *)(a1 + 3440)) {
          CFNumberRef v17 = "primary";
        }
        else {
          CFNumberRef v17 = "non-primary";
        }
        [v13 WFLog:3, "%s: %@: attempting to %s WoW and %s LPAS with WoW on Captive %s (%s), last unlocked %.3f seconds ago.", "__WiFiDeviceManagerUpdateWoWOnNetworkCharacteristics", v14, v16, v15, v11, v17, *(void *)&v10 message];
      }

      objc_autoreleasePoolPop(v12);
    }

    id v18 = sub_1000A335C((uint64_t)v6);
    unsigned int v19 = [*(id *)(a1 + 6632) isNetworkInDenyListedState:3 scanResult:v18];

    if (v2[3] != (_DWORD)v3 || v2[4] != v19)
    {
      unsigned int v20 = objc_autoreleasePoolPush();
      if (qword_100219F60) {
        [qword_100219F60 WFLog:@"%s: enableWowOnCaptive prev (%d) now (%d), isWoWDenyListed prev (%d) now(%d)\n" message:3, "__WiFiDeviceManagerUpdateWoWOnNetworkCharacteristics", v2[3], v3, v2[4], v19];
      }
      objc_autoreleasePoolPop(v20);
      sub_1000DD63C(a1, *v2, v2[1], v3, v19);
      v2[3] = v3;
      v2[4] = v19;
    }

    CFRelease(v6);
  }

void sub_1000D66BC(uint64_t a1, int a2)
{
  uint64_t v4 = objc_autoreleasePoolPush();
  if (_os_feature_enabled_impl("CoreWiFi", "UnifiedAutoJoin"))
  {
    double v10 = objc_autoreleasePoolPush();
    if (qword_100219F60) {
      [qword_100219F60 WFLog:@"%s not allowed with Unified Auto-Join" message:3 v36];
    }
    goto LABEL_15;
  }

  if (a2 == 6)
  {
    int v5 = objc_autoreleasePoolPush();
    if (qword_100219F60) {
      [qword_100219F60 WFLog:@"__WiFiDeviceManagerAttemptNetworkTransition" message:3 format:@"%s trigger is kWiFiMetricsNetworkTransitionNetworkOfInterest, reset last transtion scan time + time since linkup so we attempt transtion regardles of last attempt time"];
    }
    objc_autoreleasePoolPop(v5);
    *(void *)(a1 + 340_Block_object_dispose(va, 8) = 0LL;
    *(void *)(a1 + 3392) = 0LL;
    *(_DWORD *)(a1 + 3384) = 0;
    if (*(void *)(a1 + 6592))
    {
      uint64_t v6 = (const void **)(a1 + 6592);
      goto LABEL_13;
    }
  }

  else
  {
    int v7 = *(const void **)(a1 + 6592);
    if (v7)
    {
      uint64_t v6 = (const void **)(a1 + 6592);
      if (a2 != 7)
      {
LABEL_13:
        double v10 = objc_autoreleasePoolPush();
        if (qword_100219F60) {
          [(id)qword_100219F60 WFLog:3, "%s Not attempting transition when colocatedScopeTransition network  %@ is set.. Bailing", "__WiFiDeviceManagerAttemptNetworkTransition", sub_100095BC8(*v6) message];
        }
LABEL_15:
        objc_autoreleasePoolPop(v10);
        goto LABEL_83;
      }

      sub_10010F69C((CFArrayRef *)a1, v7);
      uint64_t v8 = *(const void **)(a1 + 6592);
      *(_BYTE *)(a1 + 6600) = 1;
      double v9 = objc_autoreleasePoolPush();
      if (qword_100219F60) {
        [(id)qword_100219F60 WFLog:3, "%s: Top network for colocatedScopeTransition: %@", "__WiFiDeviceManagerAttemptNetworkTransition", sub_100095BC8(*v6) message];
      }
      objc_autoreleasePoolPop(v9);
      if (v8) {
        goto LABEL_82;
      }
      goto LABEL_83;
    }

    if ((a2 & 0xFFFFFFFE) != 6 && !sub_10010F7B4(a1))
    {
      double v10 = objc_autoreleasePoolPush();
      if (qword_100219F60) {
        [qword_100219F60 WFLog:@"__WiFiDeviceManagerAttemptNetworkTransition: not now..."];
      }
      goto LABEL_15;
    }
  }

  id v11 = sub_1000E359C(a1);
  if (v11)
  {
    +[WiFiLocationManager logLocation:addPrefixString:]( &OBJC_CLASS___WiFiLocationManager,  "logLocation:addPrefixString:",  v11,  @"__WiFiDeviceManagerAttemptNetworkTransition");
    unsigned int v12 = +[WiFiLocationManager isLocationValid:uptoSeconds:isHighAccuracy:]( &OBJC_CLASS___WiFiLocationManager,  "isLocationValid:uptoSeconds:isHighAccuracy:",  v11,  1LL,  900.0);
    BOOL v13 = objc_autoreleasePoolPush();
    if (qword_100219F60) {
      [qword_100219F60 WFLog:@"__WiFiDeviceManagerAttemptNetworkTransition isLocValid %d" message:3, "%s: isLocValid %d",  "__WiFiDeviceManagerAttemptNetworkTransition",  v12];
    }
    objc_autoreleasePoolPop(v13);
    CFDictionaryRef v14 = (CFTypeRef *)(a1 + 3360);
    CFDictionaryRef v15 = *(void **)(a1 + 3376);
    if (v15)
    {
      if (v12)
      {
        [v15 distanceFromLocation:v11];
        if (v16 > 30.0)
        {
          CFNumberRef v17 = objc_autoreleasePoolPush();
          if (qword_100219F60) {
            [qword_100219F60 WFLog:@"%s: moved significantly since the last location" message:3];
          }
LABEL_31:
          objc_autoreleasePoolPop(v17);
LABEL_32:
          id v18 = (const __CFArray *)objc_msgSend( +[WiFiAnalyticsManager sharedWiFiAnalyticsManager]( WiFiAnalyticsManager,  "sharedWiFiAnalyticsManager"),  "copyScoreSortedNetworksAvailableAtLocation:",  v11);
          unsigned int v19 = objc_autoreleasePoolPush();
          if (qword_100219F60) {
            [(id)qword_100219F60 WFLog:3, "%s: score sorted networks %@", "__WiFiDeviceManagerAttemptNetworkTransition", v18 message];
          }
          objc_autoreleasePoolPop(v19);
          unsigned int v20 = *(const void **)(a1 + 3376);
          if (v20) {
            CFRelease(v20);
          }
          *(void *)(a1 + 3376) = v11;
          CFRetain(v11);
          if (v18 && CFArrayGetCount(v18) && CFArrayGetCount(v18) >= 1)
          {
            CFIndex v21 = 0LL;
            do
            {
              ValueAtIndex = CFArrayGetValueAtIndex(v18, v21);
              if (ValueAtIndex) {
                sub_10010F69C((CFArrayRef *)a1, ValueAtIndex);
              }
              ++v21;
            }

            while (CFArrayGetCount(v18) > v21);
          }

          if (*v14)
          {
            CFRelease(*v14);
            CFTypeRef *v14 = 0LL;
          }

          if (v18)
          {
            CFTypeRef *v14 = v18;
            CFRetain(v18);
            CFRelease(v18);
          }

          goto LABEL_54;
        }

        if (*(_DWORD *)(a1 + 3384) == -1)
        {
          CFStringRef v34 = objc_autoreleasePoolPush();
          if (qword_100219F60) {
            [qword_100219F60 WFLog:@"%s: switched network/roamed since the last attempt" message:3];
          }
          objc_autoreleasePoolPop(v34);
          *(_DWORD *)(a1 + 3384) = 0;
          goto LABEL_32;
        }
      }

uint64_t sub_1000D6EA0(uint64_t a1)
{
  if (a1)
  {
    if (!*(_DWORD *)(a1 + 352)) {
      return 0LL;
    }
    uint64_t v2 = objc_autoreleasePoolPush();
    if (qword_100219F60) {
      [qword_100219F60 WFLog:@"Auto-join has been deferred for %f seconds with reasons=0x%x" message:CFAbsoluteTimeGetCurrent() - *(double *)(a1 + 368),  *(unsigned int *)(a1 + 352)];
    }
    uint64_t v3 = 1LL;
  }

  else
  {
    uint64_t v2 = objc_autoreleasePoolPush();
    if (qword_100219F60) {
      [qword_100219F60 WFLog:@"__WiFiDeviceManagerIsAutoJoinDeferred: null manager."];
    }
    uint64_t v3 = 0LL;
  }

  objc_autoreleasePoolPop(v2);
  return v3;
}

uint64_t sub_1000D6F70(uint64_t result, char a2)
{
  *(_BYTE *)(result + 24) = a2;
  return result;
}

BOOL sub_1000D6F78(uint64_t a1)
{
  return *(_BYTE *)(a1 + 24) != 0;
}

_BYTE *sub_1000D6F88(_BYTE *result, char a2, char a3, char a4)
{
  result[32] = a2;
  result[5600] = a3;
  result[35] = a4;
  return result;
}

void sub_1000D6F9C(uint64_t a1, unsigned int a2)
{
  if (byte_100219FA1)
  {
    uint64_t v3 = objc_autoreleasePoolPush();
    if (qword_100219F60) {
      [qword_100219F60 WFLog:@"Lockdown Mode is enabled, ignoring set WiFiAskToJoinPreferenceType %ld" message:3];
    }
    objc_autoreleasePoolPop(v3);
  }

  else
  {
    *(_DWORD *)(a1 + 10_Block_object_dispose(va, 8) = a2;
    sub_1001343C0(*(void *)(a1 + 96), 0);
  }

void sub_1000D7028(uint64_t a1, int a2)
{
}

uint64_t sub_1000D7030(uint64_t result, int a2)
{
  *(_DWORD *)(result + 164) = a2;
  return result;
}

void sub_1000D7038(uint64_t a1, unsigned int a2)
{
  uint64_t v4 = objc_autoreleasePoolPush();
  if (qword_100219F60) {
    [qword_100219F60 WFLog:@"WiFiDeviceManagerSetBlackListDisable" message:3, "%s: disable=%d", "WiFiDeviceManagerSetBlackListDisable", a2];
  }
  objc_autoreleasePoolPop(v4);
  int v5 = objc_autoreleasePoolPush();
  uint64_t v6 = *(void **)(a1 + 6632);
  if (a2)
  {
    [v6 removeAllDenyListedItems];
    sub_1000D184C(a1);
    uint64_t v6 = *(void **)(a1 + 6632);
    uint64_t v7 = 0LL;
  }

  else
  {
    uint64_t v7 = 1LL;
  }

  [v6 setEnabled:v7];
  objc_autoreleasePoolPop(v5);
}

id sub_1000D70DC(uint64_t a1, int a2)
{
  id result = *(id *)(a1 + 7320);
  if (result) {
    return [result setPrivacyRestrictionDisabled:a2 != 0];
  }
  return result;
}

void sub_1000D70F4(CFMutableArrayRef *a1, const __CFArray *a2, int a3)
{
  if (a2 && CFArrayGetCount(a2))
  {
    v6.length = CFArrayGetCount(a2);
    v6.location = 0LL;
    CFArrayApplyFunction(a2, v6, (CFArrayApplierFunction)sub_1000D7174, a1);
  }

  if (a3) {
    sub_1000D4854((uint64_t)a1);
  }
}

void sub_1000D7174(const void *a1, uint64_t a2)
{
  if (a1 && a2)
  {
    uint64_t v4 = *(const __CFArray **)(a2 + 3584);
    v5.length = CFArrayGetCount(v4);
    v5.location = 0LL;
    if (!CFArrayContainsValue(v4, v5, a1)) {
      CFArrayAppendValue(*(CFMutableArrayRef *)(a2 + 3584), a1);
    }
  }

id sub_1000D71E0(uint64_t a1, unsigned int a2, unsigned int a3)
{
  *(_DWORD *)(a1 + 5384) = *(_DWORD *)(a1 + 5384) & 0xFFFFFFF3 | (4 * ((a3 >> 2) & 3));
  id result = +[WiFiRoamManager sharedWiFiRoamManager](&OBJC_CLASS___WiFiRoamManager, "sharedWiFiRoamManager");
  if (result) {
    return [+[WiFiRoamManager sharedWiFiRoamManager](WiFiRoamManager, "sharedWiFiRoamManager") setBTState:*(unsigned int *)(a1 + 5384) type:a2];
  }
  return result;
}

void sub_1000D7248(uint64_t a1, CFDictionaryRef theDict)
{
  unsigned int valuePtr = 0;
  CFBooleanRef Value = (const __CFNumber *)CFDictionaryGetValue(theDict, @"MWS_BT_CONNECTION_REPORT_ACL_A2DP");
  CFNumberGetValue(Value, kCFNumberIntType, &valuePtr);
  unsigned int v28 = 0;
  CFRange v5 = (const __CFNumber *)CFDictionaryGetValue(theDict, @"MWS_BT_CONNECTION_REPORT_ESCO");
  CFNumberGetValue(v5, kCFNumberIntType, &v28);
  unsigned int v27 = 0;
  CFRange v6 = (const __CFNumber *)CFDictionaryGetValue(theDict, @"MWS_BT_CONNECTION_REPORT_HID");
  CFNumberGetValue(v6, kCFNumberIntType, &v27);
  HIDWORD(v26) = 0;
  uint64_t v7 = (const __CFNumber *)CFDictionaryGetValue(theDict, @"MWS_BT_CONNECTION_REPORT_2G_AoS_UNI");
  CFNumberGetValue(v7, kCFNumberIntType, (char *)&v26 + 4);
  LODWORD(v26) = 0;
  uint64_t v8 = (const __CFNumber *)CFDictionaryGetValue(theDict, @"MWS_BT_CONNECTION_REPORT_5G_AoS_UNI");
  CFNumberGetValue(v8, kCFNumberIntType, &v26);
  HIDWORD(v25) = 0;
  double v9 = (const __CFNumber *)CFDictionaryGetValue(theDict, @"MWS_BT_CONNECTION_REPORT_2G_AoS_BI");
  CFNumberGetValue(v9, kCFNumberIntType, (char *)&v25 + 4);
  LODWORD(v25) = 0;
  double v10 = (const __CFNumber *)CFDictionaryGetValue(theDict, @"MWS_BT_CONNECTION_REPORT_5G_AoS_BI");
  CFNumberGetValue(v10, kCFNumberIntType, &v25);
  id v11 = objc_autoreleasePoolPush();
  if (qword_100219F60) {
    objc_msgSend( (id)qword_100219F60,  "WFLog:message:",  3,  "%s: A2DP: %d eSCO: %d HID: %d 2GHz AoS Uni: %d 5GHz AoS Uni: %d 2GHz AoS Bi: %d 5GHz AoS Bi: %d ",  "WiFiDeviceManagerSetBluetoothConnectionsReport",  valuePtr,  v28,  v27,  HIDWORD(v26),  v26,  HIDWORD(v25),  v25);
  }
  objc_autoreleasePoolPop(v11);
  int v12 = *(_DWORD *)(a1 + 5384);
  BOOL v13 = (v12 & 2) != valuePtr;
  if (valuePtr) {
    BOOL v14 = (v12 & 2) != valuePtr;
  }
  else {
    BOOL v14 = 0;
  }
  if (valuePtr) {
    BOOL v15 = 0;
  }
  else {
    BOOL v15 = (v12 & 2) != 0;
  }
  unsigned int v16 = HIDWORD(v26) + v28;
  int v17 = -HIDWORD(v25);
  if (((v12 & 1) == 0) == (HIDWORD(v26) + v28 + HIDWORD(v25) != 0))
  {
    if (v16 == v17) {
      BOOL v15 = 1;
    }
    else {
      BOOL v14 = 1;
    }
    BOOL v13 = 1;
  }

  *(_DWORD *)(a1 + 5384) = v12 & 0xFFFFFFFC | (2 * (valuePtr != 0)) | (v16 != v17);
  *(_DWORD *)(a1 + 5392) = v27 != 0;
  *(_DWORD *)(a1 + 538_Block_object_dispose(va, 8) = 102;
  if (v13)
  {
    uint64_t v18 = *(void *)(a1 + 64);
    unsigned int v19 = (const void *)sub_100043E8C(v18);
    sub_10004D50C(v18, v19, 0x66u, *(_DWORD *)(a1 + 5384));
  }

  if (+[WiFiRoamManager sharedWiFiRoamManager](&OBJC_CLASS___WiFiRoamManager, "sharedWiFiRoamManager")) {
    [+[WiFiRoamManager sharedWiFiRoamManager](WiFiRoamManager, "sharedWiFiRoamManager") setBTState:*(unsigned int *)(a1 + 5384) type:102];
  }
  *(_DWORD *)(a1 + 192) = 2;
  if (v15)
  {
    if (_os_feature_enabled_impl("CoreWiFi", "UnifiedAutoJoin"))
    {
      sub_1000F5F98(a1, 0x18uLL);
    }

    else
    {
      [+[WiFiXPCManager sharedXPCManager](WiFiXPCManager, "sharedXPCManager") autoJoinStartedWithTrigger:24 interfaceName:sub_100043E8C(*(void *)(a1 + 64))];
      sub_1000D0A5C(a1, 1LL, (uint64_t)"WiFiDeviceManagerSetBluetoothConnectionsReport");
    }
  }

  unsigned int v20 = *(void **)(a1 + 7320);
  if (v20)
  {
    LOBYTE(v24) = (v26 | v25) != 0;
    [v20 setBluetoothState:*(_DWORD *)(a1 + 5384) != 0 connectedDeviceCount:v27 inA2dp:valuePtr != 0 inSco:v28 != 0 inUniAoS:v26 != 0 inBiAoS:v25 != 0 btAudioBand:v24];
  }

  if (v14)
  {
    uint64_t v21 = sub_100043E8C(*(void *)(a1 + 64));
    CFNumberRef v22 = *(void (**)(uint64_t, uint64_t, void))(a1 + 4368);
    if (v22)
    {
      v22(a1, v21, *(void *)(a1 + 4376));
      int v23 = objc_autoreleasePoolPush();
      if (qword_100219F60) {
        [(id)qword_100219F60 WFLog:3 message:"Signal WiFi to Reset 24GHz M1M4 Handshake Count to Zero"];
      }
      objc_autoreleasePoolPop(v23);
    }
  }

void sub_1000D75B0(uint64_t a1, const void *a2)
{
  if (a1)
  {
    uint64_t v4 = objc_autoreleasePoolPush();
    if (qword_100219F60) {
      [(id)qword_100219F60 WFLog:3, "%s: %@", "WiFiDeviceManagerSetCoexBlacklistedChannels", a2 message];
    }
    objc_autoreleasePoolPop(v4);
    CFRange v5 = *(const void **)(a1 + 56);
    if (v5)
    {
      CFRelease(v5);
      *(void *)(a1 + 56) = 0LL;
    }

    if (a2)
    {
      *(void *)(a1 + 56) = CFRetain(a2);
      uint64_t v6 = *(void *)(a1 + 64);
      uint64_t v7 = (const void *)sub_100040CF8(v6);
      sub_1000501D0(v6, v7, *(const __CFArray **)(a1 + 56));
      if (*(void *)(a1 + 7320))
      {
        CFNumberRef value = 0LL;
        unsigned int valuePtr = 0;
        if (CFArrayGetCount(*(CFArrayRef *)(a1 + 56)) < 1)
        {
          uint64_t v13 = 0LL;
          uint64_t v12 = 0LL;
          uint64_t v11 = 0LL;
          uint64_t v10 = 0LL;
          uint64_t v9 = 0LL;
        }

        else
        {
          CFIndex v8 = 0LL;
          uint64_t v9 = 0LL;
          uint64_t v10 = 0LL;
          uint64_t v11 = 0LL;
          uint64_t v12 = 0LL;
          uint64_t v13 = 0LL;
          do
          {
            ValueAtIndex = (const __CFDictionary *)CFArrayGetValueAtIndex(*(CFArrayRef *)(a1 + 56), v8);
            if (ValueAtIndex)
            {
              CFDictionaryGetValueIfPresent(ValueAtIndex, @"MWS_Channel_Number", (const void **)&value);
              if (value)
              {
                CFNumberGetValue((CFNumberRef)value, kCFNumberIntType, &valuePtr);
                if (valuePtr)
                {
                  if ((int)valuePtr > 13)
                  {
                    if (valuePtr > 0x33)
                    {
                      if (valuePtr > 0x63)
                      {
                        if (valuePtr > 0x94) {
                          ++v9;
                        }
                        else {
                          ++v10;
                        }
                      }

                      else
                      {
                        ++v11;
                      }
                    }

                    else
                    {
                      ++v12;
                    }
                  }

                  else
                  {
                    ++v13;
                  }
                }
              }
            }

            ++v8;
          }

          while (CFArrayGetCount(*(CFArrayRef *)(a1 + 56)) > v8);
        }

        [*(id *)(a1 + 7320) addSoftApCoexEvent:v13 deniedUnii1ChannelMap:v12 deniedUnii2aChannelMap:v11 deniedUnii2cChannelMap:v10 deniedUnii3ChannelMap:v9];
      }
    }
  }

__CFArray *sub_1000D7770(uint64_t a1, const __CFDictionary *a2)
{
  uint64_t v4 = objc_autoreleasePoolPush();
  uint64_t valuePtr = 0LL;
  double v94 = 0.0;
  unsigned int v92 = 0;
  if (!a1)
  {
    CFRange v5 = objc_autoreleasePoolPush();
    if (qword_100219F60) {
      [qword_100219F60 WFLog:@"%s: manager is NULL!" message:3];
    }
    goto LABEL_45;
  }

  CFRange v5 = objc_autoreleasePoolPush();
  if (!a2)
  {
    if (qword_100219F60) {
      [qword_100219F60 WFLog:@"request is NULL!"];
    }
    goto LABEL_45;
  }

  if (qword_100219F60) {
    [(id)qword_100219F60 WFLog:3, "%s: Processing Request:%@", "WiFiDeviceManagerProcessWoWBlacklistCommandsAndCopyResponse", a2 message];
  }
  objc_autoreleasePoolPop(v5);
  CFBooleanRef Value = (const __CFDictionary *)CFDictionaryGetValue(a2, @"AddTrigger");
  if (Value)
  {
    uint64_t v7 = Value;
    CFIndex v8 = objc_autoreleasePoolPush();
    if (qword_100219F60) {
      [qword_100219F60 WFLog:@"Processing WiFiDeviceManagerProcessWoWBlacklistCommand: AddTrigger" message:3];
    }
    objc_autoreleasePoolPop(v8);
    uint64_t v9 = (const __CFNumber *)CFDictionaryGetValue(v7, @"triggerReason");
    if (v9)
    {
      CFNumberGetValue(v9, kCFNumberSInt32Type, (char *)&valuePtr + 4);
      uint64_t v10 = CFDictionaryGetValue(v7, @"SSID_STR");
      if (v10)
      {
        uint64_t v11 = v10;
        uint64_t v87 = v4;
        uint64_t v12 = CFDictionaryGetValue(v7, @"BSSID");
        uint64_t v13 = HIDWORD(valuePtr);
        SCDynamicStoreContext context = objc_autoreleasePoolPush();
        if (CFArrayGetCount(*(CFArrayRef *)(a1 + 3520)) < 1) {
          goto LABEL_18;
        }
        CFIndex v14 = 0LL;
        int v15 = 0;
        do
        {
          ValueAtIndex = CFArrayGetValueAtIndex(*(CFArrayRef *)(a1 + 3520), v14);
          int v17 = sub_100095BC8(ValueAtIndex);
          if (CFEqual(v17, v11))
          {
            uint64_t v18 = objc_autoreleasePoolPush();
            if (qword_100219F60) {
              [qword_100219F60 WFLog:@"Processing WiFiDeviceManagerProcessWoWBlacklistCommand: AddTrigger" message:3];
            }
            objc_autoreleasePoolPop(v18);
            id v19 = sub_1000A335C((uint64_t)ValueAtIndex);
            id v20 = sub_1000D1BDC(a1, v13, 0LL, (uint64_t)v12, 3LL);
            [*(id *)(a1 + 6632) setNetworkDenyListInfo:v20 forScanResult:v19];

            int v15 = 1;
          }

          ++v14;
        }

        while (CFArrayGetCount(*(CFArrayRef *)(a1 + 3520)) > v14);
        if (!v15)
        {
LABEL_18:
          if (CFArrayGetCount(*(CFArrayRef *)(a1 + 3528)) >= 1)
          {
            CFIndex v21 = 0LL;
            do
            {
              CFNumberRef v22 = CFArrayGetValueAtIndex(*(CFArrayRef *)(a1 + 3528), v21);
              int v23 = sub_100095BC8(v22);
              if (CFEqual(v23, v11))
              {
                uint64_t v24 = objc_autoreleasePoolPush();
                if (qword_100219F60) {
                  [qword_100219F60 WFLog:@"Processing WiFiDeviceManagerProcessWoWBlacklistCommand: AddTrigger" message:3];
                }
                objc_autoreleasePoolPop(v24);
                id v25 = sub_1000A335C((uint64_t)v22);
                id v26 = sub_1000D1BDC(a1, v13, 0LL, (uint64_t)v12, 3LL);
                [*(id *)(a1 + 6632) setNetworkDenyListInfo:v26 forScanResult:v25];
              }

              ++v21;
            }

            while (CFArrayGetCount(*(CFArrayRef *)(a1 + 3528)) > v21);
          }
        }

        objc_autoreleasePoolPop(context);
        CFStringRef Copy = 0LL;
        uint64_t v4 = v87;
        goto LABEL_88;
      }

LABEL_83:
    -[NSMutableArray removeAllObjects](contexta, "removeAllObjects");
    -[NSMutableArray removeAllObjects](v45, "removeAllObjects");
    ++v47;
    uint64_t v46 = v86;
  }

  while (v47 < (unint64_t)[v86 count]);
  uint64_t v4 = v88;
  CFStringRef Copy = theArray;
  CFIndex v43 = v84;
LABEL_85:

LABEL_86:
  CFRange v37 = v43;
LABEL_87:
  objc_autoreleasePoolPop(v37);
LABEL_88:
  objc_autoreleasePoolPop(v4);
  return Copy;
}

__CFArray *sub_1000D8278(uint64_t a1)
{
  uint64_t v2 = objc_autoreleasePoolPush();
  CFMutableDictionaryRef Mutable = CFArrayCreateMutable(kCFAllocatorDefault, 0LL, &kCFTypeArrayCallBacks);
  if (!Mutable)
  {
    CFIndex v43 = objc_autoreleasePoolPush();
    if (qword_100219F60) {
      [qword_100219F60 WFLog:@"__WiFiDeviceManagerCopyWoWDenyListingHistory: denyListHistory is NULL" message:3];
    }
    goto LABEL_62;
  }

  if (!a1)
  {
    CFIndex v43 = objc_autoreleasePoolPush();
    if (qword_100219F60) {
      [qword_100219F60 WFLog:@"%s: manager is NULL!" message:3];
    }
    goto LABEL_62;
  }

  id v4 = [*(id *)(a1 + 6632) networksInDenyListedStateHistory:3];
  if (!v4)
  {
    CFIndex v43 = objc_autoreleasePoolPush();
    if (qword_100219F60) {
      [qword_100219F60 WFLog:@"%s: networkDenyListedNetworks is NULL" message:3];
    }
LABEL_62:
    objc_autoreleasePoolPop(v43);
    goto LABEL_55;
  }

  CFRange v5 = v4;
  SCDynamicStoreContext context = v2;
  if ([v4 count])
  {
    uint64_t v6 = 0LL;
    CFIndex v44 = Mutable;
    uint64_t v46 = v5;
    uint64_t v47 = a1;
    while (1)
    {
      int valuePtr = 0;
      id v7 = [v5 objectAtIndex:v6];
      CFIndex v8 = sub_1000A3DB0(v7);
      CFMutableDictionaryRef v9 = CFDictionaryCreateMutable(0LL, 0LL, &kCFTypeDictionaryKeyCallBacks, &kCFTypeDictionaryValueCallBacks);
      if (!v9)
      {
        CFRange v38 = objc_autoreleasePoolPush();
        if (qword_100219F60) {
          [qword_100219F60 WFLog:@"%s: results is NULL" message:4];
        }
        objc_autoreleasePoolPop(v38);
        goto LABEL_46;
      }

      uint64_t v10 = v9;
      uint64_t v11 = sub_100094E60((uint64_t)kCFAllocatorDefault, (uint64_t)v8);
      uint64_t v12 = sub_1000D91B0(a1, v11, 1);
      uint64_t v13 = v12;
      if (!v11 || !v12)
      {
        CFRange v39 = objc_autoreleasePoolPush();
        if (qword_100219F60) {
          [qword_100219F60 WFLog:@"mergedNetwork is NULL" message:4];
        }
        objc_autoreleasePoolPop(v39);
        if (!v13) {
          goto LABEL_44;
        }
        goto LABEL_43;
      }

      BOOL v14 = sub_10009860C((uint64_t)v12);
      BOOL v15 = sub_100095B4C((uint64_t)v13);
      unsigned int v16 = sub_100095BC8(v11);
      CFDictionaryAddValue(v10, @"SSID_STR", v16);
      LOBYTE(valuePtr) = sub_100098EA8((uint64_t)v8);
      int valuePtr = valuePtr;
      int v17 = sub_10009E120((uint64_t)v8) << 8;
      if (!v15 || !v14) {
        int v19 = 0;
      }
      else {
        int v19 = 0x10000;
      }
      valuePtr |= v17 | v19;
      CFNumberRef v20 = CFNumberCreate(kCFAllocatorDefault, kCFNumberSInt32Type, &valuePtr);
      if (v20)
      {
        CFNumberRef v21 = v20;
        CFDictionaryAddValue(v10, @"wowBlacklistedNetworkFlags", v20);
        CFRelease(v21);
      }

      CFNumberRef v22 = objc_alloc_init(&OBJC_CLASS___NSMutableArray);
      a1 = v47;
      if (!v22)
      {
        char v41 = objc_autoreleasePoolPush();
        CFRange v5 = v46;
        if (qword_100219F60) {
          [qword_100219F60 WFLog:@"%s: networkDenyListTimestamps is NULL" message:3];
        }
        objc_autoreleasePoolPop(v41);
LABEL_43:
        CFRelease(v13);
        goto LABEL_44;
      }

      int v23 = v22;
      id v24 = [*(id *)(v47 + 6632) denyListedReasonHistoryForNetwork:v7 state:3 timestamps:v22 reasonData:0];
      if (!v24) {
        goto LABEL_34;
      }
      id v25 = v24;
      id v26 = [v24 count];
      if (v26 != -[NSMutableArray count](v23, "count")) {
        goto LABEL_34;
      }
      CFMutableArrayRef v27 = CFArrayCreateMutable(kCFAllocatorDefault, 0LL, &kCFTypeArrayCallBacks);
      if (v27) {
        break;
      }
      int v40 = objc_autoreleasePoolPush();
      if (qword_100219F60) {
        [qword_100219F60 WFLog:@"%s: denyListingHistoryRecord is NULL" message:4];
      }
      objc_autoreleasePoolPop(v40);
      a1 = v47;
LABEL_35:
      CFRelease(v23);
      CFRange v5 = v46;
      if (v13) {
        goto LABEL_43;
      }
LABEL_44:
      if (v11) {
        CFRelease(v11);
      }
LABEL_46:
    }

    unsigned int v28 = v27;
    if ([v25 count])
    {
      unint64_t v29 = 0LL;
      do
      {
        CFMutableDictionaryRef v30 = CFDictionaryCreateMutable(0LL, 0LL, &kCFTypeDictionaryKeyCallBacks, &kCFTypeDictionaryValueCallBacks);
        if (v30)
        {
          int v31 = v30;
          id v32 = [v25 objectAtIndex:v29];
          unsigned int v49 = -1431655766;
          unsigned int v49 = [v32 unsignedIntegerValue];
          CFNumberRef v33 = CFNumberCreate(kCFAllocatorDefault, kCFNumberIntType, &v49);
          CFDictionaryAddValue(v31, @"wowBlacklistingReason", v33);
          if (v33) {
            CFRelease(v33);
          }
          id v34 = -[NSMutableArray objectAtIndex:](v23, "objectAtIndex:", v29);
          uint64_t v48 = -1LL;
          [v34 doubleValue];
          uint64_t v48 = v35;
          CFNumberRef v36 = CFNumberCreate(kCFAllocatorDefault, kCFNumberDoubleType, &v48);
          CFDictionaryAddValue(v31, @"wowBlacklistingTimeStamp", v36);
          if (v36) {
            CFRelease(v36);
          }
          CFArrayAppendValue(v28, v31);
          CFRelease(v31);
        }

        else
        {
          CFRange v37 = objc_autoreleasePoolPush();
          if (qword_100219F60) {
            [qword_100219F60 WFLog:@"%s: results is NULL" message:4];
          }
          objc_autoreleasePoolPop(v37);
        }

        ++v29;
      }

      while (v29 < (unint64_t)[v25 count]);
    }

    CFDictionaryAddValue(v10, @"wowBlackListingHistory", v28);
    CFRelease(v28);
    CFMutableDictionaryRef Mutable = v44;
    a1 = v47;
LABEL_34:
    CFArrayAppendValue(Mutable, v10);
    CFRelease(v10);
    goto LABEL_35;
  }

__CFArray *sub_1000D880C(uint64_t a1)
{
  uint64_t v2 = objc_autoreleasePoolPush();
  if (!a1)
  {
    CFMutableDictionaryRef v30 = objc_autoreleasePoolPush();
    if (qword_100219F60) {
      [qword_100219F60 WFLog:@"%s: manager is NULL" message:3];
    }
    goto LABEL_37;
  }

  CFMutableArrayRef Mutable = CFArrayCreateMutable(kCFAllocatorDefault, 0LL, &kCFTypeArrayCallBacks);
  if (!Mutable)
  {
    CFMutableDictionaryRef v30 = objc_autoreleasePoolPush();
    if (qword_100219F60) {
      [qword_100219F60 WFLog:@"response is NULL" message:3];
    }
LABEL_37:
    objc_autoreleasePoolPop(v30);
    id v4 = 0LL;
LABEL_41:
    uint64_t v6 = 0LL;
LABEL_45:
    CFIndex v8 = 0LL;
    goto LABEL_17;
  }

  id v4 = Mutable;
  CFMutableDictionaryRef v5 = CFDictionaryCreateMutable( kCFAllocatorDefault,  0LL,  &kCFTypeDictionaryKeyCallBacks,  &kCFTypeDictionaryValueCallBacks);
  if (!v5)
  {
    int v31 = objc_autoreleasePoolPush();
    if (qword_100219F60) {
      [qword_100219F60 WFLog:@"message: %s: perSSIDInfo is NULL" message:@"__WiFiDeviceManagerWoWBlacklistCopyThresholds"];
    }
    objc_autoreleasePoolPop(v31);
    goto LABEL_41;
  }

  uint64_t v6 = v5;
  CFMutableDictionaryRef v7 = CFDictionaryCreateMutable( kCFAllocatorDefault,  0LL,  &kCFTypeDictionaryKeyCallBacks,  &kCFTypeDictionaryValueCallBacks);
  if (!v7)
  {
    id v32 = objc_autoreleasePoolPush();
    if (qword_100219F60) {
      [qword_100219F60 WFLog:@"%s: perBSSIDInfo is NULL" message:3];
    }
    objc_autoreleasePoolPop(v32);
    goto LABEL_45;
  }

  CFIndex v8 = v7;
  theArray = v4;
  uint64_t v35 = v2;
  for (uint64_t i = 0LL; i != 10; ++i)
  {
    unsigned __int8 valuePtr = -86;
    unsigned __int8 valuePtr = objc_msgSend( objc_msgSend( objc_msgSend(*(id *)(a1 + 6632), "SSIDThresholds"),  "objectAtIndexedSubscript:",  i),  "unsignedIntegerValue");
    unsigned __int8 v37 = -86;
    unsigned __int8 v37 = objc_msgSend( objc_msgSend( objc_msgSend(*(id *)(a1 + 6632), "BSSIDThresholds"),  "objectAtIndexedSubscript:",  i),  "unsignedIntegerValue");
    uint64_t v10 = (const __CFString *)CWFStringFromDenyListAddReason(i);
    CFMutableStringRef v11 = CFStringCreateMutable(kCFAllocatorDefault, 0LL);
    if (!v11)
    {
      unsigned int v28 = objc_autoreleasePoolPush();
      if (qword_100219F60) {
        [qword_100219F60 WFLog:@"%s: keyStrRefSsid is NULL" message:3];
      }
      objc_autoreleasePoolPop(v28);
      goto LABEL_32;
    }

    uint64_t v12 = v11;
    CFMutableStringRef v13 = CFStringCreateMutable(kCFAllocatorDefault, 0LL);
    if (!v13)
    {
      unint64_t v29 = objc_autoreleasePoolPush();
      if (qword_100219F60) {
        [qword_100219F60 WFLog:@"%s: keyStrRefBssid is NULL" message:3];
      }
      objc_autoreleasePoolPop(v29);
      CFMutableArrayRef v27 = v12;
LABEL_31:
      CFRelease(v27);
LABEL_32:
      id v4 = theArray;
      uint64_t v2 = v35;
      goto LABEL_17;
    }

    BOOL v14 = v13;
    CFStringAppend(v12, @"PerSSID ");
    CFStringAppend(v12, v10);
    CFNumberRef v15 = CFNumberCreate(kCFAllocatorDefault, kCFNumberCharType, &valuePtr);
    if (!v15
      || (CFNumberRef v16 = v15,
          CFDictionaryAddValue(v6, v12, v15),
          CFRelease(v16),
          CFStringAppend(v14, @"PerBSSID "),
          CFStringAppend(v14, v10),
          (CFNumberRef v17 = CFNumberCreate(kCFAllocatorDefault, kCFNumberCharType, &v37)) == 0LL))
    {
      id v26 = objc_autoreleasePoolPush();
      if (qword_100219F60) {
        [qword_100219F60 WFLog:@"%s: numRef is NULL" message:3];
      }
      objc_autoreleasePoolPop(v26);
      CFRelease(v12);
      CFMutableArrayRef v27 = v14;
      goto LABEL_31;
    }

    CFNumberRef v18 = v17;
    CFDictionaryAddValue(v8, v14, v17);
    CFRelease(v18);
    CFRelease(v12);
    CFRelease(v14);
  }

  id v4 = theArray;
  CFArrayAppendValue(theArray, v6);
  CFArrayAppendValue(theArray, v8);
  [*(id *)(a1 + 6632) wowDenyListExpiry];
  uint64_t v36 = v19;
  CFNumberRef v20 = CFNumberCreate(kCFAllocatorDefault, kCFNumberDoubleType, &v36);
  if (v20)
  {
    CFNumberRef v21 = v20;
    CFNumberRef v22 = CFDictionaryCreateMutable( kCFAllocatorDefault,  0LL,  &kCFTypeDictionaryKeyCallBacks,  &kCFTypeDictionaryValueCallBacks);
    if (v22)
    {
      int v23 = v22;
      CFDictionarySetValue(v22, @"unBlacklistingTimeoutInSec", v21);
      CFArrayAppendValue(theArray, v23);
      CFRelease(v23);
    }

    CFRelease(v21);
    id v24 = objc_autoreleasePoolPush();
    if (qword_100219F60) {
      [(id)qword_100219F60 WFLog:3, "%s: response:%@", "__WiFiDeviceManagerWoWBlacklistCopyThresholds", theArray message];
    }
  }

  else
  {
    id v24 = objc_autoreleasePoolPush();
    if (qword_100219F60) {
      [qword_100219F60 WFLog:@"%s: numRef is NULL" message:3];
    }
  }

  objc_autoreleasePoolPop(v24);
  uint64_t v2 = v35;
LABEL_17:
  CFRelease(@"PerSSID ");
  CFRelease(@"PerBSSID ");
  if (v6) {
    CFRelease(v6);
  }
  if (v8) {
    CFRelease(v8);
  }
  objc_autoreleasePoolPop(v2);
  return v4;
}

uint64_t sub_1000D8D08(uint64_t a1)
{
  return *(void *)(a1 + 3504);
}

CFArrayRef sub_1000D8D10(uint64_t a1, const void *a2)
{
  return sub_1000D91B0(a1, a2, 1);
}

uint64_t sub_1000D8D18(uint64_t a1)
{
  return *(void *)(a1 + 3640);
}

void sub_1000D8D20(uint64_t a1, const void *a2)
{
  id v4 = *(const void **)(a1 + 3640);
  if (v4)
  {
    CFRelease(v4);
    *(void *)(a1 + 3640) = 0LL;
  }

  if (a2)
  {
    CFMutableDictionaryRef v5 = sub_1000D91B0(a1, a2, 1);
    *(void *)(a1 + 3640) = v5;
    if (!v5) {
      *(void *)(a1 + 3640) = CFRetain(a2);
    }
  }

void sub_1000D8D78(uint64_t a1, const __CFDictionary **a2)
{
  if (a2 && *(void *)(a1 + 7320))
  {
    v3[0] = _NSConcreteStackBlock;
    v3[1] = 3221225472LL;
    void v3[2] = sub_1000D9160;
    v3[3] = &unk_1001E4B88;
    void v3[4] = a1;
    sub_1000D8E24(a1, a2, (uint64_t)v3);
  }

  else
  {
    uint64_t v2 = objc_autoreleasePoolPush();
    if (qword_100219F60) {
      [qword_100219F60 WFLog:@"Error notifying UsageMonitor" message:4];
    }
    objc_autoreleasePoolPop(v2);
  }

void sub_1000D8E24(uint64_t a1, const __CFDictionary **a2, uint64_t a3)
{
  uint64_t v34 = 0LL;
  uint64_t v35 = &v34;
  uint64_t v36 = 0x2020000000LL;
  uint64_t v37 = 0LL;
  uint64_t v30 = 0LL;
  int v31 = &v30;
  uint64_t v32 = 0x2020000000LL;
  uint64_t v33 = 0LL;
  if (!a1)
  {
    uint64_t v6 = objc_autoreleasePoolPush();
    if (qword_100219F60) {
      [qword_100219F60 WFLog:@"%s: null manager" message:4];
    }
    objc_autoreleasePoolPop(v6);
  }

  if (!a2)
  {
    CFMutableDictionaryRef v7 = objc_autoreleasePoolPush();
    if (qword_100219F60) {
      [qword_100219F60 WFLog:@"%s: null network" message:4];
    }
    objc_autoreleasePoolPop(v7);
  }

  if (a3)
  {
    if (a1 && a2 && !byte_100219FA0)
    {
      CFIndex v8 = sub_100094E60((uint64_t)kCFAllocatorDefault, (uint64_t)a2);
      v35[3] = (uint64_t)v8;
      CFMutableDictionaryRef v9 = sub_1000A47DC(*(const __CFArray **)(a1 + 3696), a2);
      if (v9)
      {
        uint64_t v10 = sub_100094E60((uint64_t)kCFAllocatorDefault, (uint64_t)v9);
        v31[3] = (uint64_t)v10;
      }

      CFMutableStringRef v11 = *(const __CFDictionary **)(a1 + 3608);
      if (v11)
      {
        uint64_t v12 = sub_100095BC8(a2);
        BOOL v13 = CFDictionaryGetValue(v11, v12) != 0LL;
      }

      else
      {
        BOOL v13 = 0;
      }

      id v15 = sub_1000E359C(a1);
      *(_DWORD *)buffer = 0;
      CFNumberRef v16 = *(const __CFString **)(a1 + 7304);
      if (v16)
      {
        v38.length = CFStringGetLength(*(CFStringRef *)(a1 + 7304));
        v38.location = 0LL;
        CFStringGetBytes(v16, v38, 0x8000100u, 0, 0, buffer, 4LL, 0LL);
      }

      int v17 = sub_1000FDC1C(a1, (const void *)v35[3]);
      uint64_t v18 = *(unsigned __int8 *)(a1 + 7312);
      uint64_t v19 = *(void **)(a1 + 7328);
      if (v19)
      {
        unsigned __int8 v20 = [v19 isAtPrimaryHomeLocation];
        unsigned __int8 v21 = [*(id *)(a1 + 7328) isAtNonPrimaryHomeLocation];
      }

      else
      {
        unsigned __int8 v20 = 0;
        unsigned __int8 v21 = 0;
      }

      CFNumberRef v22 = sub_1000FA698(a1);
      CFRetain((CFTypeRef)a1);
      block[0] = _NSConcreteStackBlock;
      block[1] = 3221225472LL;
      block[2] = sub_10011192C;
      block[3] = &unk_1001E5168;
      void block[8] = &v30;
      block[9] = a1;
      void block[4] = v22;
      void block[5] = v15;
      BOOL v26 = v13;
      int v24 = *(_DWORD *)buffer;
      int v25 = v17;
      block[10] = v18;
      unsigned __int8 v27 = v20;
      unsigned __int8 v28 = v21;
      void block[6] = a3;
      void block[7] = &v34;
      dispatch_async((dispatch_queue_t)qword_100219F80, block);
    }

    else
    {
      (*(void (**)(uint64_t, void))(a3 + 16))(a3, 0LL);
    }
  }

  else
  {
    BOOL v14 = objc_autoreleasePoolPush();
    if (qword_100219F60) {
      [qword_100219F60 WFLog:@"%s: null callbackBlock" message:4];
    }
    objc_autoreleasePoolPop(v14);
  }

  _Block_object_dispose(&v30, 8);
  _Block_object_dispose(&v34, 8);
}

void sub_1000D9120( _Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, ...)
{
}

void sub_1000D9160(uint64_t a1, void *a2)
{
  if (a2)
  {
    [*(id *)(*(void *)(a1 + 32) + 7320) setForgetNetworkEvent:a2 forInterface:sub_100043E8C(*(void *)(*(void *)(a1 + 32) + 64))];
  }

CFArrayRef sub_1000D91B0(uint64_t a1, const void *a2, int a3)
{
  if (!a1)
  {
    uint64_t v10 = objc_autoreleasePoolPush();
    if (qword_100219F60) {
      [qword_100219F60 WFLog:@"%s: manager is NULL!" message:3];
    }
    goto LABEL_13;
  }

  if (!a2)
  {
    uint64_t v10 = objc_autoreleasePoolPush();
    if (qword_100219F60) {
      [qword_100219F60 WFLog:@"network is NULL!"];
    }
LABEL_13:
    objc_autoreleasePoolPop(v10);
    return 0LL;
  }

  CFMutableDictionaryRef v5 = (const __CFArray *)sub_100081958(*(void *)(a1 + 6744));
  uint64_t v6 = v5;
  if (!v5) {
    return v6;
  }
  v12.length = CFArrayGetCount(v5);
  v12.location = 0LL;
  FirstIndexOfCFBooleanRef Value = CFArrayGetFirstIndexOfValue(v6, v12, a2);
  if (FirstIndexOfValue == -1) {
    return 0LL;
  }
  ValueAtIndex = CFArrayGetValueAtIndex(v6, FirstIndexOfValue);
  if (!ValueAtIndex) {
    return 0LL;
  }
  CFMutableDictionaryRef v9 = (const __CFArray *)sub_100094E60((uint64_t)kCFAllocatorDefault, (uint64_t)ValueAtIndex);
  uint64_t v6 = v9;
  if (a3 && v9) {
    sub_100095F10((uint64_t)v9, (uint64_t)a2);
  }
  return v6;
}

CFArrayRef sub_1000D92D0(uint64_t a1, const void *a2)
{
  return sub_1000D91B0(a1, a2, 0);
}

void sub_1000D92D8(void *a1, const void *a2, CFTypeRef cf)
{
  if (!a1)
  {
    uint64_t v10 = objc_autoreleasePoolPush();
    if (qword_100219F60) {
      [qword_100219F60 WFLog:@"%s: null manager." message:@"WiFiDeviceManagerSetCellularCarrierName"];
    }
    goto LABEL_20;
  }

  if (!cf)
  {
    uint64_t v10 = objc_autoreleasePoolPush();
    if (qword_100219F60) {
      [qword_100219F60 WFLog:@"%s: null carrierName." message:@"WiFiDeviceManagerSetCellularCarrierName"];
    }
    goto LABEL_20;
  }

  if (!a2)
  {
    uint64_t v10 = objc_autoreleasePoolPush();
    if (qword_100219F60) {
      [qword_100219F60 WFLog:@"%s: null ifName." message:@"WiFiDeviceManagerSetCellularCarrierName"];
    }
LABEL_20:
    objc_autoreleasePoolPop(v10);
    return;
  }

  uint64_t v6 = (const void *)a1[773];
  if (v6)
  {
    CFRelease(v6);
    a1[773] = 0LL;
  }

  CFMutableDictionaryRef v7 = (const void *)a1[774];
  if (v7)
  {
    CFRelease(v7);
    a1[774] = 0LL;
  }

  a1[773] = CFRetain(cf);
  a1[774] = CFRetain(a2);
  CFIndex v8 = objc_autoreleasePoolPush();
  if (qword_100219F60) {
    [(id)qword_100219F60 WFLog:3, "%s: cellular (%@) carrier name updated to %@", "WiFiDeviceManagerSetCellularCarrierName", a2, cf message];
  }
  objc_autoreleasePoolPop(v8);
  CFMutableDictionaryRef v9 = (void *)a1[915];
  if (v9)
  {
    if (a1[774]) {
      [v9 setSecondaryInterfaceName:];
    }
  }

void sub_1000D9460(uint64_t a1, int a2)
{
  id v4 = objc_autoreleasePoolPush();
  if (a1)
  {
    if (qword_100219F60)
    {
      CFMutableDictionaryRef v5 = "is 5G";
      if (!a2) {
        CFMutableDictionaryRef v5 = "is Not 5G";
      }
      [qword_100219F60 WFLog:@"%s: cellular Type %s \n" message:3,  "WiFiDeviceManagerSetCellularRadioType5G",  v5];
    }

    objc_autoreleasePoolPop(v4);
    *(_BYTE *)(a1 + 6995) = a2;
  }

  else
  {
    if (qword_100219F60) {
      [qword_100219F60 WFLog:@"%s: null manager." message:@"WiFiDeviceManagerSetCellularRadioType5G"];
    }
    objc_autoreleasePoolPop(v4);
  }

void sub_1000D9528(uint64_t *a1, CFTypeRef cf)
{
  if (a1)
  {
    id v4 = (const void *)a1[25];
    if (v4)
    {
      CFRelease(v4);
      a1[25] = 0LL;
    }

    if (cf) {
      a1[25] = (uint64_t)CFRetain(cf);
    }
    sub_1000154E8(a1[15], cf);
    sub_1000CFB5C((uint64_t)a1, 1LL, cf);
    CFMutableDictionaryRef v5 = (void *)a1[915];
    if (v5) {
      [v5 setCurrentApplicationName:cf withAttributes:0];
    }
  }

  else
  {
    uint64_t v6 = objc_autoreleasePoolPush();
    if (qword_100219F60) {
      [qword_100219F60 WFLog:@"%s: null manager." message:@"WiFiDeviceManagerSetForegroundAppBundleId"];
    }
    objc_autoreleasePoolPop(v6);
  }

void sub_1000D95F8(uint64_t a1, int a2)
{
  if (!a1)
  {
    CFRange v12 = objc_autoreleasePoolPush();
    if (qword_100219F60) {
      [qword_100219F60 WFLog:@"%s: manager is NULL" message:3];
    }
    goto LABEL_12;
  }

  id v4 = (unsigned __int8 *)(a1 + 5208);
  *(_DWORD *)(a1 + 7004) = a2;
  CFMutableDictionaryRef v5 = objc_autoreleasePoolPush();
  uint64_t v6 = (void *)qword_100219F60;
  if (qword_100219F60)
  {
    if (a2 == 2) {
      CFMutableDictionaryRef v7 = "5GHz";
    }
    else {
      CFMutableDictionaryRef v7 = "2.4GHz";
    }
    uint64_t v8 = *v4;
    CFIndex Count = CFSetGetCount(*(CFSetRef *)(a1 + 5280));
    CFIndex v10 = CFSetGetCount(*(CFSetRef *)(a1 + 5288));
    CFIndex v11 = CFSetGetCount(*(CFSetRef *)(a1 + 5296));
    objc_msgSend( v6,  "WFLog:message:",  3,  "%s:NAN Concurrency SoftAP Preferred Band update to %s while misChannel=%d and Clients connected (Broadcast:%ld, Hi dden:%ld Other Hidden %ld NanLink %ld)\n",  "WiFiDeviceManagerSetSoftAPNANCocurrencyPreferredBand",  v7,  v8,  Count,  v10,  v11,  CFSetGetCount(*(CFSetRef *)(a1 + 5304)));
  }

  objc_autoreleasePoolPop(v5);
  if (a2 != 2 && *v4 >= 0xFu && v4[3])
  {
    CFRange v12 = objc_autoreleasePoolPush();
    if (qword_100219F60) {
      objc_msgSend( (id)qword_100219F60,  "WFLog:message:",  3,  "%s:Restart legacy softAP to move to %s\n",  "WiFiDeviceManagerSetSoftAPNANCocurrencyPreferredBand",  "2.4GHz");
    }
LABEL_12:
    objc_autoreleasePoolPop(v12);
  }

id sub_1000D9790(uint64_t a1, int a2, int a3)
{
  id result = *(id *)(a1 + 120);
  if (result)
  {
    sub_100014C80((uint64_t)result, a2);
    id result = *(id *)(a1 + 7320);
    if (result)
    {
      [result enableXCTestNotifications];
      return [*(id *)(a1 + 7320) enableSubmitAnalyticsNoSampling:a3 != 0];
    }
  }

  return result;
}

void sub_1000D97E0(uint64_t a1, int a2)
{
  int v3 = *(_DWORD *)(a1 + 7000);
  int v4 = a2 != 0;
  *(_DWORD *)(a1 + 7000) = v4;
  if (!a2 && v3 != v4 && *(_BYTE *)(a1 + 5211))
  {
    if (CFSetGetCount(*(CFSetRef *)(a1 + 5280)) > 0
      || CFSetGetCount(*(CFSetRef *)(a1 + 5288)) > 0
      || CFSetGetCount(*(CFSetRef *)(a1 + 5296)) > 0
      || CFSetGetCount(*(CFSetRef *)(a1 + 5304)) > 0)
    {
      uint64_t v6 = objc_autoreleasePoolPush();
      CFMutableDictionaryRef v7 = (void *)qword_100219F60;
      if (qword_100219F60)
      {
        CFIndex Count = CFSetGetCount(*(CFSetRef *)(a1 + 5280));
        CFIndex v9 = CFSetGetCount(*(CFSetRef *)(a1 + 5288));
        CFIndex v10 = CFSetGetCount(*(CFSetRef *)(a1 + 5296));
        objc_msgSend( v7,  "WFLog:message:",  3,  "%s:User SoftAP Preferred Changed to %s while Clients connected (Broadcast:%ld, Hidden:%ld Other Hidden %ld NanLink %ld)\n",  "WiFiDeviceManagerSetSoftAPUserPreferredBand",  "Default",  Count,  v9,  v10,  CFSetGetCount(*(CFSetRef *)(a1 + 5304)));
      }

      goto LABEL_16;
    }

    int v4 = *(_DWORD *)(a1 + 7000);
  }

  if (v4 == v3) {
    return;
  }
  uint64_t v6 = objc_autoreleasePoolPush();
  if (qword_100219F60)
  {
    CFIndex v11 = "Default";
    if (a2) {
      CFIndex v11 = "2.4GHz";
    }
    objc_msgSend( (id)qword_100219F60,  "WFLog:message:",  3,  "%s:User SoftAP Preferred Band %s\n",  "WiFiDeviceManagerSetSoftAPUserPreferredBand",  v11,  v12,  v13,  v14,  v15);
  }

void sub_1000D9964(uint64_t a1)
{
  if (!a1)
  {
    uint64_t v1 = objc_autoreleasePoolPush();
    if (qword_100219F60) {
      [qword_100219F60 WFLog:@"__WiFiDeviceManagerShouldRestartNANPublisher: null device manager"];
    }
    objc_autoreleasePoolPop(v1);
  }

void sub_1000D99C4(uint64_t a1, uint64_t a2)
{
  CFMutableArrayRef Mutable = CFDictionaryCreateMutable( kCFAllocatorDefault,  0LL,  &kCFTypeDictionaryKeyCallBacks,  &kCFTypeDictionaryValueCallBacks);
  if (Mutable)
  {
    CFMutableDictionaryRef v5 = Mutable;
    int v6 = *(unsigned __int16 *)(a1 + 1) >> 14;
    if (v6)
    {
      if (v6 == 1)
      {
        CFMutableDictionaryRef v7 = @"6";
      }

      else
      {
        if (v6 != 3) {
          goto LABEL_9;
        }
        CFMutableDictionaryRef v7 = @"5";
      }
    }

    else
    {
      CFMutableDictionaryRef v7 = @"2";
    }

    CFDictionarySetValue(Mutable, @"band_before", v7);
LABEL_9:
    int v8 = *(unsigned __int16 *)(a2 + 1) >> 14;
    if (v8)
    {
      if (v8 == 1)
      {
        CFIndex v9 = @"6";
      }

      else
      {
        if (v8 != 3) {
          goto LABEL_16;
        }
        CFIndex v9 = @"5";
      }
    }

    else
    {
      CFIndex v9 = @"2";
    }

    CFDictionarySetValue(v5, @"band_after", v9);
LABEL_16:
    if (*(unsigned __int8 *)(a1 + 9) >= 0xA2u)
    {
      CFNumberRef v10 = CFNumberCreate(kCFAllocatorDefault, kCFNumberSInt8Type, (const void *)(a1 + 9));
      if (v10)
      {
        CFNumberRef v11 = v10;
        CFDictionarySetValue(v5, @"rssi_before", v10);
        CFRelease(v11);
      }
    }

    if (*(unsigned __int8 *)(a2 + 9) >= 0xA2u)
    {
      CFNumberRef v12 = CFNumberCreate(kCFAllocatorDefault, kCFNumberSInt8Type, (const void *)(a2 + 9));
      if (v12)
      {
        CFNumberRef v13 = v12;
        CFDictionarySetValue(v5, @"rssi_after", v12);
        CFRelease(v13);
      }
    }

    if ((*(_DWORD *)(a1 + 32) - 1) < 0x257FFF)
    {
      CFNumberRef v14 = CFNumberCreate(kCFAllocatorDefault, kCFNumberIntType, (const void *)(a1 + 32));
      if (v14)
      {
        CFNumberRef v15 = v14;
        CFDictionarySetValue(v5, @"txrate_before", v14);
        CFRelease(v15);
      }
    }

    if ((*(_DWORD *)(a2 + 32) - 1) < 0x257FFF)
    {
      CFNumberRef v16 = CFNumberCreate(kCFAllocatorDefault, kCFNumberIntType, (const void *)(a2 + 32));
      if (v16)
      {
        CFNumberRef v17 = v16;
        CFDictionarySetValue(v5, @"txrate_after", v16);
        CFRelease(v17);
      }
    }

    int v19 = *(_DWORD *)(a1 + 36);
    uint64_t v18 = (const void *)(a1 + 36);
    if ((v19 - 1) < 0x257FFF)
    {
      CFNumberRef v20 = CFNumberCreate(kCFAllocatorDefault, kCFNumberIntType, v18);
      if (v20)
      {
        CFNumberRef v21 = v20;
        CFDictionarySetValue(v5, @"rxrate_before", v20);
        CFRelease(v21);
      }
    }

    int v23 = *(_DWORD *)(a2 + 36);
    CFNumberRef v22 = (const void *)(a2 + 36);
    if ((v23 - 1) < 0x257FFF)
    {
      CFNumberRef v24 = CFNumberCreate(kCFAllocatorDefault, kCFNumberIntType, v22);
      if (v24)
      {
        CFNumberRef v25 = v24;
        CFDictionarySetValue(v5, @"rxrate_after", v24);
        CFRelease(v25);
      }
    }

    sub_100039588((uint64_t)@"com.apple.wifi.mloSwitch", (uint64_t)v5);
    CFRelease(v5);
    return;
  }

  BOOL v26 = objc_autoreleasePoolPush();
  if (qword_100219F60) {
    [qword_100219F60 WFLog:@"metric is null" message:@"WiFiDeviceManagerSubmitMloPrefBandSwitchMetric"];
  }
  objc_autoreleasePoolPop(v26);
}

void sub_1000D9CC0(uint64_t a1, uint64_t a2)
{
  unsigned int valuePtr = 0;
  id v4 = sub_1000D9F24(a1);
  if (!v4)
  {
    CFNumberRef v20 = objc_autoreleasePoolPush();
    if (qword_100219F60) {
      [qword_100219F60 WFLog:@"%s: Not able to submit setup metric __WiFiDeviceManagerCopyCurrentCoreWiFiScanResult returned NULL" message:3];
    }
    goto LABEL_25;
  }

  CFMutableDictionaryRef Mutable = CFDictionaryCreateMutable( kCFAllocatorDefault,  0LL,  &kCFTypeDictionaryKeyCallBacks,  &kCFTypeDictionaryValueCallBacks);
  if (!Mutable)
  {
    CFNumberRef v20 = objc_autoreleasePoolPush();
    if (qword_100219F60) {
      [qword_100219F60 WFLog:@"%s: metric is null" message:@"WiFiDeviceManagerSubmitObssMitTransitionMetric"];
    }
LABEL_25:
    objc_autoreleasePoolPop(v20);
    goto LABEL_20;
  }

  int v6 = Mutable;
  unsigned int v7 = objc_msgSend(objc_msgSend(v4, "channel"), "band") - 1;
  if (v7 <= 2) {
    CFDictionarySetValue(v6, @"band", off_1001E54E0[v7]);
  }
  unint64_t v8 = *(char *)(a2 + 2);
  if (v8 <= 3) {
    CFDictionarySetValue(v6, @"channelWidth", off_1001E54F8[v8]);
  }
  unint64_t v9 = *(char *)(a2 + 3);
  if (v9 <= 3) {
    CFDictionarySetValue(v6, @"recommended_channelWidth", off_1001E54F8[v9]);
  }
  char v10 = *(_BYTE *)(a2 + 3) - *(_BYTE *)(a2 + 2);
  uint64_t v11 = v10 + 3LL;
  uint64_t v12 = *(char *)(a1 + 3858) + 3LL;
  unint64_t v13 = *(char *)(a1 + 3856);
  if (v13 <= 3) {
    CFDictionarySetValue(v6, @"previous_recommended_channelWidth", off_1001E54F8[v13]);
  }
  unsigned int v14 = *(_DWORD *)(a2 + 20);
  unsigned int v15 = *(unsigned __int8 *)(a1 + 3857);
  BOOL v16 = v14 >= v15;
  unsigned int v17 = v14 - v15;
  if (v17 != 0 && v16)
  {
    unsigned int valuePtr = v17;
    CFNumberRef v18 = CFNumberCreate(kCFAllocatorDefault, kCFNumberIntType, &valuePtr);
    if (v18)
    {
      CFNumberRef v19 = v18;
      CFDictionarySetValue(v6, @"recommendationDuration", v18);
      CFRelease(v19);
    }
  }

  *(_BYTE *)(a1 + 3856) = *(_BYTE *)(a2 + 3);
  *(_BYTE *)(a1 + 3857) = *(_DWORD *)(a2 + 20);
  *(_BYTE *)(a1 + 385_Block_object_dispose((const void *)(v15 - 112), 8) = v10;
  sub_100039588((uint64_t)@"com.apple.wifi.obssMitigation.transitionStats", (uint64_t)v6);
  CFRelease(v6);
LABEL_20:
}

id sub_1000D9F24(uint64_t a1)
{
  uint64_t v2 = (const void *)sub_10004CE2C(*(void *)(a1 + 64));
  id result = sub_1000DEA34(a1, v2, 1);
  if (result)
  {
    id v4 = result;
    id v5 = sub_1000A335C((uint64_t)result);
    CFRelease(v4);
    return v5;
  }

  return result;
}

void sub_1000D9F74(uint64_t a1, uint64_t a2)
{
  int v44 = sub_10001C4D8(*(void *)(a1 + 120));
  unsigned __int8 v43 = -127;
  char v42 = 0;
  int v41 = 0;
  id v4 = sub_1000D9F24(a1);
  if (!v4)
  {
    CFRange v38 = objc_autoreleasePoolPush();
    if (qword_100219F60) {
      [qword_100219F60 WFLog:@"%s: Not able to submit setup metric __WiFiDeviceManagerCopyCurrentCoreWiFiScanResult returned NULL" message:3];
    }
    goto LABEL_49;
  }

  CFMutableDictionaryRef Mutable = CFDictionaryCreateMutable( kCFAllocatorDefault,  0LL,  &kCFTypeDictionaryKeyCallBacks,  &kCFTypeDictionaryValueCallBacks);
  if (!Mutable)
  {
    CFRange v38 = objc_autoreleasePoolPush();
    if (qword_100219F60) {
      [qword_100219F60 WFLog:@"metric is null" message:@"WiFiDeviceManagerSubmitObssMitMetric"];
    }
LABEL_49:
    objc_autoreleasePoolPop(v38);
    goto LABEL_44;
  }

  int v6 = Mutable;
  unsigned int v7 = objc_msgSend(objc_msgSend(v4, "channel"), "band") - 1;
  if (v7 <= 2) {
    CFDictionarySetValue(v6, @"band", off_1001E54E0[v7]);
  }
  unint64_t v8 = *(char *)(a2 + 2);
  if (v8 <= 3) {
    CFDictionarySetValue(v6, @"channelWidth", off_1001E54F8[v8]);
  }
  unint64_t v9 = *(char *)(a2 + 3);
  if (v9 <= 3) {
    CFDictionarySetValue(v6, @"recommended_channelWidth", off_1001E54F8[v9]);
  }
  uint64_t v10 = (char)(*(_BYTE *)(a2 + 3) - *(_BYTE *)(a2 + 2)) + 3LL;
  unsigned int v11 = *(_DWORD *)(a2 + 12);
  if (v11)
  {
    unsigned int valuePtr = 100 * *(_DWORD *)(a2 + 8) / v11;
    CFNumberRef v12 = CFNumberCreate(kCFAllocatorDefault, kCFNumberIntType, &valuePtr);
    if (v12)
    {
      CFNumberRef v13 = v12;
      CFDictionarySetValue(v6, @"rxBadFCSOverRxFrames", v12);
      CFRelease(v13);
    }

    unsigned int v39 = (100 * *(_DWORD *)(a2 + 4)) / *(_DWORD *)(a2 + 12);
    CFNumberRef v14 = CFNumberCreate(kCFAllocatorDefault, kCFNumberIntType, &v39);
    if (v14)
    {
      CFNumberRef v15 = v14;
      CFDictionarySetValue(v6, @"rxBadPLCPOverRxFrames", v14);
      CFRelease(v15);
    }
  }

  CFNumberRef v16 = CFNumberCreate(kCFAllocatorDefault, kCFNumberIntType, (const void *)(a2 + 12));
  if (v16)
  {
    CFNumberRef v17 = v16;
    CFDictionarySetValue(v6, @"rxFrames", v16);
    CFRelease(v17);
  }

  CFNumberRef v18 = CFNumberCreate(kCFAllocatorDefault, kCFNumberIntType, (const void *)(a2 + 16));
  if (v18)
  {
    CFNumberRef v19 = v18;
    CFDictionarySetValue(v6, @"rxPER", v18);
    CFRelease(v19);
  }

  CFNumberRef v20 = CFNumberCreate(kCFAllocatorDefault, kCFNumberIntType, &v44);
  if (v20)
  {
    CFNumberRef v21 = v20;
    CFDictionarySetValue(v6, @"p95_txLatency", v20);
    CFRelease(v21);
  }

  CFNumberRef v22 = CFNumberCreate(kCFAllocatorDefault, kCFNumberSInt8Type, (const void *)(a2 + 40));
  if (v22)
  {
    CFNumberRef v23 = v22;
    CFDictionarySetValue(v6, @"rssi_core0", v22);
    CFRelease(v23);
  }

  CFNumberRef v24 = CFNumberCreate(kCFAllocatorDefault, kCFNumberSInt8Type, (const void *)(a2 + 41));
  if (v24)
  {
    CFNumberRef v25 = v24;
    CFDictionarySetValue(v6, @"rssi_core1", v24);
    CFRelease(v25);
  }

  uint64_t v26 = 0LL;
  char v27 = -127;
  do
  {
    int v28 = *(char *)(a2 + 24 + v26);
    if (v28 > v27 && v28 < 0) {
      char v27 = *(_BYTE *)(a2 + 24 + v26);
    }
    ++v26;
  }

  while (v26 != 8);
  unsigned __int8 v43 = v27;
  CFNumberRef v30 = CFNumberCreate(kCFAllocatorDefault, kCFNumberSInt8Type, &v43);
  if (v30)
  {
    CFNumberRef v31 = v30;
    CFDictionarySetValue(v6, @"strongestNonPrimaryChannelEnergy", v30);
    CFRelease(v31);
  }

  char v42 = v43 - *(_BYTE *)(a2 + 40);
  CFNumberRef v32 = CFNumberCreate(kCFAllocatorDefault, kCFNumberSInt8Type, &v42);
  if (v32)
  {
    CFNumberRef v33 = v32;
    CFDictionarySetValue(v6, @"diffStrongestNonPrimaryChannelEnergySOI", v32);
    CFRelease(v33);
  }

  uint64_t v34 = 0LL;
  int v35 = 0;
  do
  {
    ++v34;
  }

  while (v34 != 8);
  int v41 = v35;
  CFNumberRef v36 = CFNumberCreate(kCFAllocatorDefault, kCFNumberSInt32Type, &v41);
  if (v36)
  {
    CFNumberRef v37 = v36;
    CFDictionarySetValue(v6, @"channelWidthWithMaxEnergy", v36);
    CFRelease(v37);
  }

  sub_100039588((uint64_t)@"com.apple.wifi.obssMitigation.stats", (uint64_t)v6);
  CFRelease(v6);
LABEL_44:
}

uint64_t sub_1000DA400(uint64_t a1, const void *a2)
{
  id v4 = objc_autoreleasePoolPush();
  double v9 = 0.0;
  uint64_t v10 = 0LL;
  id v5 = sub_1000A335C((uint64_t)a2);
  uint64_t v6 = 1LL;
  if ([*(id *)(a1 + 6632) isNetworkInDenyListedState:1 scanResult:v5])
  {
    if ([*(id *)(a1 + 6632) isNetworkDenyListedForAutoJoinDueToTrigDisc:v5 RSSI:&v10 timestamp:&v9]
      && !sub_10001D56C(*(_DWORD **)(a1 + 120), a2, v10, v9))
    {
      unint64_t v8 = objc_autoreleasePoolPush();
      if (qword_100219F60) {
        [(id)qword_100219F60 WFLog:3, "%s: Trigger disconnected %@ is not suitable", "WiFiDeviceManagerKnownNetworkSuitableAfterTriggerDisconnect", sub_100095BC8(a2) message];
      }
      objc_autoreleasePoolPop(v8);
      uint64_t v6 = 0LL;
      if (v5) {
        goto LABEL_6;
      }
      goto LABEL_7;
    }

    uint64_t v6 = 1LL;
  }

  if (v5) {
LABEL_6:
  }

LABEL_7:
  objc_autoreleasePoolPop(v4);
  return v6;
}

uint64_t sub_1000DA504(uint64_t a1)
{
  return a1 + 1200;
}

uint64_t sub_1000DA50C(uint64_t a1)
{
  uint64_t v2 = (const void *)sub_10004CE2C(*(void *)(a1 + 64));
  int v3 = sub_1000DEA34(a1, v2, 1);
  if (v3)
  {
    id v4 = v3;
    id v5 = objc_autoreleasePoolPush();
    if (qword_100219F60) {
      [qword_100219F60 WFLog:@"Start 6E prefer off switch scan" message:4];
    }
    objc_autoreleasePoolPop(v5);
    uint64_t v6 = *(const __CFArray **)(a1 + 3520);
    v12.length = CFArrayGetCount(v6);
    v12.location = 0LL;
    FirstIndexOfCFBooleanRef Value = CFArrayGetFirstIndexOfValue(v6, v12, v4);
    if (FirstIndexOfValue == -1)
    {
      double v9 = objc_autoreleasePoolPush();
      if (qword_100219F60) {
        [qword_100219F60 WFLog:@"%s: no known network found" message:4 v11];
      }
    }

    else
    {
      ValueAtIndex = CFArrayGetValueAtIndex(*(CFArrayRef *)(a1 + 3520), FirstIndexOfValue);
      if (sub_1000951FC((uint64_t)ValueAtIndex, @"Standalone") == kCFBooleanTrue)
      {
        sub_1000F5F98(a1, 0x34uLL);
        goto LABEL_10;
      }

      double v9 = objc_autoreleasePoolPush();
      if (qword_100219F60) {
        [(id)qword_100219F60 WFLog:3, "%s: Current network is not standalone 6G %@", "WiFiDeviceManager6EPreferOff", ValueAtIndex message];
      }
    }

    objc_autoreleasePoolPop(v9);
LABEL_10:
    CFRelease(v4);
  }

  return 4294963396LL;
}

uint64_t sub_1000DA664(uint64_t a1)
{
  uint64_t v2 = (const void *)sub_10004CE2C(*(void *)(a1 + 64));
  int v3 = sub_1000DEA34(a1, v2, 1);
  if (v3)
  {
    id v4 = v3;
    int valuePtr = 0;
    id v5 = (const __CFNumber *)sub_1000951FC((uint64_t)v3, @"CHANNEL_FLAGS");
    if (v5 && (CFNumberGetValue(v5, kCFNumberIntType, &valuePtr), (valuePtr & 0x2000) != 0))
    {
      unsigned int v7 = objc_autoreleasePoolPush();
      if (qword_100219F60) {
        [qword_100219F60 WFLog:@"%s: current channel is non 6G channel" message:@"WiFiDeviceManager6EPreferOn"];
      }
      objc_autoreleasePoolPop(v7);
    }

    else
    {
      sub_1000F5F98(a1, 0x35uLL);
    }

    CFRelease(v4);
  }

  return 4294963396LL;
}

void sub_1000DA728(uint64_t a1)
{
  if (a1)
  {
    uint64_t v1 = *(void *)(a1 + 64);
    sub_100043E8C(v1);
    sub_10004E304(v1);
  }

void sub_1000DA75C(uint64_t a1, const __CFArray *a2)
{
  uint64_t v4 = *(void *)(a1 + 64);
  id v5 = (const void *)sub_100043E8C(v4);
  uint64_t v6 = sub_100040538(v4, v5);
  if (v6)
  {
    unsigned int v7 = v6;
    unint64_t v8 = (void *)sub_1000951FC((uint64_t)v6, @"SSID");
    double v9 = *(const void **)(a1 + 3768);
    if (v8 == v9) {
      goto LABEL_12;
    }
    uint64_t v10 = v8;
    if (v8) {
      BOOL v11 = v9 == 0LL;
    }
    else {
      BOOL v11 = 1;
    }
    if (!v11)
    {
      double v9 = *(const void **)(a1 + 3768);
    }

    if (v9)
    {
      CFRelease(v9);
      *(void *)(a1 + 376_Block_object_dispose((const void *)(v15 - 112), 8) = 0LL;
    }

    *(void *)(a1 + 376_Block_object_dispose((const void *)(v15 - 112), 8) = [v10 copy];
    *(_DWORD *)(a1 + 3776) = 0;
LABEL_12:
    CFRange v12 = sub_1000539A4(*(void *)(a1 + 64), 0x4E20u);
    CFNumberRef v13 = sub_1000D91B0(a1, v7, 0);
    if (!v13)
    {
LABEL_44:
      CFRelease(v7);
      if (v12) {
        CFRelease(v12);
      }
      return;
    }

    CFNumberRef v14 = v13;
    if (a2 && CFArrayGetCount(a2) >= 1)
    {
      int v15 = 0;
      int v16 = 0;
      CFIndex v17 = 0LL;
      do
      {
        CFNumberRef v18 = objc_autoreleasePoolPush();
        ValueAtIndex = CFArrayGetValueAtIndex(a2, v17);
        id v20 = sub_1000A335C((uint64_t)ValueAtIndex);
        if ([v20 SSID] == *(id *)(a1 + 3768)
          || [v20 SSID]
          && *(void *)(a1 + 3768)
          && objc_msgSend(objc_msgSend(v20, "SSID"), "isEqual:", *(void *)(a1 + 3768)))
        {
          unsigned int v21 = objc_msgSend(objc_msgSend(v20, "channel"), "band");
          v15 |= v21 != 3;
          v16 |= v21 == 3;
        }

        objc_autoreleasePoolPop(v18);
        ++v17;
      }

      while (v17 < CFArrayGetCount(a2));
      if (!v12) {
        goto LABEL_34;
      }
    }

    else
    {
      int v15 = 0;
      int v16 = 0;
      if (!v12) {
        goto LABEL_34;
      }
    }

    if (CFArrayGetCount(v12) >= 1)
    {
      int v22 = 0;
      CFIndex v23 = 0LL;
      do
      {
        CFNumberRef v24 = objc_autoreleasePoolPush();
        CFNumberRef v25 = CFArrayGetValueAtIndex(v12, v23);
        id v26 = sub_1000A335C((uint64_t)v25);
        if ([v26 SSID] == *(id *)(a1 + 3768)
          || [v26 SSID]
          && *(void *)(a1 + 3768)
          && objc_msgSend(objc_msgSend(v26, "SSID"), "isEqual:", *(void *)(a1 + 3768)))
        {
          unsigned int v27 = objc_msgSend(objc_msgSend(v26, "channel"), "band");
          v22 |= v27 != 3;
          v16 |= v27 == 3;
        }

        objc_autoreleasePoolPop(v24);
        ++v23;
      }

      while (v23 < CFArrayGetCount(v12));
      goto LABEL_35;
    }

void sub_1000DAB00(dispatch_queue_s **cf, const void *a2)
{
  if (cf)
  {
    if (cf[564])
    {
      if (cf[30])
      {
        if (a2)
        {
          CFRetain(cf);
          CFRetain(a2);
          uint64_t v4 = cf[30];
          block[0] = _NSConcreteStackBlock;
          block[1] = 3221225472LL;
          block[2] = sub_10010D0FC;
          block[3] = &unk_1001E2C30;
          void block[4] = cf;
          void block[5] = a2;
          dispatch_async(v4, block);
          return;
        }

        id v5 = objc_autoreleasePoolPush();
        if (qword_100219F60) {
          [qword_100219F60 WFLog:@"%s: null network" message:4];
        }
      }

      else
      {
        id v5 = objc_autoreleasePoolPush();
        if (qword_100219F60) {
          [qword_100219F60 WFLog:@"%s: null queue" message:4];
        }
      }
    }

    else
    {
      id v5 = objc_autoreleasePoolPush();
      if (qword_100219F60) {
        [qword_100219F60 WFLog:@"%s: null updateNetwork callback" message:4];
      }
    }
  }

  else
  {
    id v5 = objc_autoreleasePoolPush();
    if (qword_100219F60) {
      [qword_100219F60 WFLog:@"%s: null manager" message:4];
    }
  }

  objc_autoreleasePoolPop(v5);
}

void sub_1000DAC64(uint64_t a1, const __CFDictionary **a2)
{
  v2[0] = _NSConcreteStackBlock;
  v2[1] = 3221225472LL;
  v2[2] = sub_1000DACB4;
  v2[3] = &unk_1001E4B88;
  v2[4] = a1;
  sub_1000D8E24(a1, a2, (uint64_t)v2);
}

void sub_1000DACB4(uint64_t a1, void *a2)
{
  if (a2)
  {
    [*(id *)(*(void *)(a1 + 32) + 7320) updateCurrentNetworkDetails:a2];
  }

uint64_t sub_1000DACEC(uint64_t a1, const void *a2)
{
  uint64_t v4 = objc_autoreleasePoolPush();
  id v5 = objc_autoreleasePoolPush();
  if (qword_100219F60) {
    [(id)qword_100219F60 WFLog:3 message:"Updating 6G standalone property in known network plist"];
  }
  objc_autoreleasePoolPop(v5);
  uint64_t v6 = sub_1000539A4(*(void *)(a1 + 64), 0x4E20u);
  unsigned int v7 = v6;
  if (!a2)
  {
    uint64_t v10 = 0LL;
    if (!v6) {
      goto LABEL_23;
    }
    goto LABEL_22;
  }

  id v8 = sub_1000A335C((uint64_t)a2);
  unsigned int v9 = objc_msgSend(objc_msgSend(v8, "channel"), "band");
  uint64_t v10 = v9 == 3;
  if (v8)
  {
    unsigned int v11 = v9;
    CFRange v12 = sub_1000D91B0(a1, a2, 0);
    if (v12)
    {
      CFNumberRef v13 = v12;
      if (v11 == 3 && v7 && CFArrayGetCount(v7) >= 1)
      {
        CFIndex v14 = 0LL;
        do
        {
          ValueAtIndex = CFArrayGetValueAtIndex(v7, v14);
          id v16 = sub_1000A335C((uint64_t)ValueAtIndex);
          if ([v16 SSID]
            && [v8 SSID]
            && objc_msgSend(objc_msgSend(v16, "SSID"), "isEqual:", objc_msgSend(v8, "SSID"))
            && objc_msgSend(objc_msgSend(v16, "channel"), "band") != 3)
          {
            LOBYTE(v10) = 0;
          }

          ++v14;
        }

        while (v14 < CFArrayGetCount(v7));
      }

      BOOL v17 = sub_1000951FC((uint64_t)v13, @"Standalone") == kCFBooleanTrue;
      v10 &= 1u;
      if (v17 != (_DWORD)v10)
      {
        CFNumberRef v18 = objc_autoreleasePoolPush();
        if (qword_100219F60) {
          [(id)qword_100219F60 WFLog:3, "Know network %@ 6G standalone state changed from %d to %d", v13, v17, v10 message];
        }
        objc_autoreleasePoolPop(v18);
        *(_DWORD *)(a1 + 3776) = 0;
        sub_10009582C( (uint64_t)v13,  @"Standalone",  +[NSNumber numberWithBool:](&OBJC_CLASS___NSNumber, "numberWithBool:", v10));
        sub_1000DAB00((dispatch_queue_s **)a1, v13);
      }

      CFRelease(v13);
    }
  }

  if (v7) {
LABEL_22:
  }
    CFRelease(v7);
LABEL_23:
  objc_autoreleasePoolPop(v4);
  return v10;
}

BOOL sub_1000DAF1C(uint64_t a1, const void *a2)
{
  if (a1
    && a2
    && (CFIndex Count = CFArrayGetCount(*(CFArrayRef *)(a1 + 3568))) != 0
    && (v8.length = Count,
        v8.location = 0LL,
        FirstIndexOfCFBooleanRef Value = CFArrayGetFirstIndexOfValue(*(CFArrayRef *)(a1 + 3568), v8, a2),
        FirstIndexOfValue != -1)
    && (ValueAtIndex = CFArrayGetValueAtIndex(*(CFArrayRef *)(a1 + 3568), FirstIndexOfValue)) != 0LL)
  {
    return sub_1000973BC((uint64_t)ValueAtIndex);
  }

  else
  {
    return 0LL;
  }

__CFDictionary *sub_1000DAF8C(uint64_t a1, const __CFArray *a2)
{
  BOOL valuePtr = 0LL;
  CFMutableDictionaryRef Mutable = CFDictionaryCreateMutable( kCFAllocatorDefault,  0LL,  &kCFTypeDictionaryKeyCallBacks,  &kCFTypeDictionaryValueCallBacks);
  if (Mutable)
  {
    CFMutableArrayRef v5 = CFArrayCreateMutable(kCFAllocatorDefault, 0LL, &kCFTypeArrayCallBacks);
    if (v5)
    {
      uint64_t v6 = v5;
      unsigned int v7 = (unsigned __int8 *)(a1 + 5448);
      CFRange v8 = CFStringCreateMutable(kCFAllocatorDefault, 0LL);
      CFSetRemoveAllValues(*(CFMutableSetRef *)(a1 + 3592));
      CFSetRemoveAllValues(*(CFMutableSetRef *)(a1 + 3600));
      if (a2 && CFArrayGetCount(a2) >= 1)
      {
        if (v8) {
          CFStringAppend(v8, @"Preparing background scan request for ");
        }
        theArray = CFArrayCreateMutable(kCFAllocatorDefault, 0LL, &kCFTypeArrayCallBacks);
        if (theArray)
        {
          theDict = Mutable;
          CFNumberRef v66 = v6;
          CFIndex Count = CFArrayGetCount(a2);
          if (Count >= 1)
          {
            CFIndex v9 = 0LL;
            unsigned int v69 = a2;
            while (1)
            {
              ValueAtIndex = (void *)CFArrayGetValueAtIndex(a2, v9);
              unsigned int v11 = sub_100094E98((uint64_t)ValueAtIndex);
              BOOL valuePtr = sub_100097324(ValueAtIndex) != 0;
              CFNumberRef v12 = CFNumberCreate(kCFAllocatorDefault, kCFNumberCFIndexType, &valuePtr);
              if (v12)
              {
                CFNumberRef v13 = v12;
                CFDictionarySetValue(v11, @"HIDDEN_NETWORK", v12);
                CFRelease(v13);
              }

              CFIndex v14 = CFArrayGetValueAtIndex(a2, v9);
              int v15 = (const __CFString *)sub_100095BC8(v14);
              int v71 = 0;
              int v16 = sub_1000FD668(a1, ValueAtIndex, 0, &v71);
              if (*(_DWORD *)(a1 + 128) != v16)
              {
                unsigned int v70 = *(_DWORD *)(a1 + 136) + v16;
                CFNumberRef v17 = CFNumberCreate(kCFAllocatorDefault, kCFNumberSInt32Type, &v70);
                if (v17)
                {
                  CFNumberRef v18 = v17;
                  CFDictionarySetValue(v11, @"BGSCANRSSITHRES", v17);
                  CFNumberRef v19 = objc_autoreleasePoolPush();
                  if (qword_100219F60)
                  {
                    id v20 = @"NULL";
                    if (v15) {
                      id v20 = v15;
                    }
                    else {
                      unsigned int v21 = off_1001E57A8[v71 - 1];
                    }
                    [(id)qword_100219F60 WFLog:3, "%s PNO RssiThres %d for unreliable network %@ (%@)", "__CreateBGScanRequest", v70, v20, v21 message];
                  }

                  objc_autoreleasePoolPop(v19);
                  CFRelease(v18);
                  a2 = v69;
                }
              }

              int v22 = v8;
              CFIndex v23 = objc_autoreleasePoolPush();
              id v24 = sub_1000A335C((uint64_t)ValueAtIndex);
              if ([*(id *)(a1 + 6632) isNetworkDenyListedForAutoJoinDueToTrigDisc:v24 RSSI:0 timestamp:0])
              {
                unsigned int v70 = -1431655766;
                unsigned int v70 = *(_DWORD *)(a1 + 136) + sub_10001D4F8(*(void *)(a1 + 120));
                CFSetAddValue(*(CFMutableSetRef *)(a1 + 3592), ValueAtIndex);
                CFNumberRef v25 = CFNumberCreate(kCFAllocatorDefault, kCFNumberSInt32Type, &v70);
                if (v25)
                {
                  CFNumberRef v26 = v25;
                  CFDictionarySetValue(v11, @"BGSCANRSSITHRES", v25);
                  unsigned int v27 = objc_autoreleasePoolPush();
                  if (qword_100219F60)
                  {
                    int v28 = @"NULL";
                    if (v15) {
                      int v28 = v15;
                    }
                    [(id)qword_100219F60 WFLog:3, "%s LQAMgr enforced RssiThres %d for trgDisc network %@", "__CreateBGScanRequest", v70, v28 message];
                  }

                  objc_autoreleasePoolPop(v27);
                  CFRelease(v26);
                }

                a2 = v69;
              }

              objc_autoreleasePoolPop(v23);
              CFRange v8 = v22;
              if (sub_1000DAF1C(a1, ValueAtIndex)
                || sub_10009CF04((uint64_t)ValueAtIndex)
                || sub_100095318((BOOL)ValueAtIndex))
              {
                CFSetAddValue(*(CFMutableSetRef *)(a1 + 3600), ValueAtIndex);
                CFDictionarySetValue(v11, @"DISALLOW_PNO", kCFBooleanTrue);
                if (sub_1000951FC((uint64_t)ValueAtIndex, @"WiFiNetworkUserAcceptedRecommendationAt"))
                {
                  BOOL v29 = objc_autoreleasePoolPush();
                  if (qword_100219F60)
                  {
                    uint64_t v30 = @"NULL";
                    if (v15) {
                      uint64_t v30 = v15;
                    }
                    [(id)qword_100219F60 WFLog:3, "%s: user accepted recommendation to join captive %@, added to BGScan List", "__CreateBGScanRequest", v30 message];
                  }
                }

                else if (sub_10009EBF8((uint64_t)ValueAtIndex) || sub_100095318((BOOL)ValueAtIndex))
                {
                  BOOL v29 = objc_autoreleasePoolPush();
                  if (qword_100219F60)
                  {
                    CFNumberRef v31 = @"NULL";
                    if (v15) {
                      CFNumberRef v31 = v15;
                    }
                    [(id)qword_100219F60 WFLog:3, "%s Captive %@ added to BGScan List ", "__CreateBGScanRequest", v31 message];
                  }
                }

                else
                {
                  CFDictionarySetValue(v11, @"HOTSPOT", kCFBooleanTrue);
                  BOOL v29 = objc_autoreleasePoolPush();
                  if (qword_100219F60)
                  {
                    uint64_t v48 = @"NULL";
                    if (v15) {
                      uint64_t v48 = v15;
                    }
                    [(id)qword_100219F60 WFLog:3, "%s Hotspot %@ added to BGScan List ", "__CreateBGScanRequest", v48 message];
                  }
                }

                objc_autoreleasePoolPop(v29);
              }

              if (sub_1000972B8((uint64_t)ValueAtIndex))
              {
                CFDictionarySetValue(v11, @"DISALLOW_PNO", kCFBooleanTrue);
                CFNumberRef v32 = objc_autoreleasePoolPush();
                if (qword_100219F60)
                {
                  CFNumberRef v33 = @"NULL";
                  if (v15) {
                    CFNumberRef v33 = v15;
                  }
                  [(id)qword_100219F60 WFLog:3, "%s Ambiguous ssid %@ added to BGScan List ", "__CreateBGScanRequest", v33 message];
                }

                objc_autoreleasePoolPop(v32);
              }

              if (byte_100219FA1)
              {
                uint64_t v34 = sub_1000A063C((CFDictionaryRef *)ValueAtIndex);
                if (([v34 isAllowedInLockdownMode] & 1) == 0)
                {
                  CFDictionarySetValue(v11, @"DISALLOW_PNO", kCFBooleanTrue);
                  int v35 = objc_autoreleasePoolPush();
                  if (qword_100219F60)
                  {
                    CFNumberRef v36 = @"NULL";
                    if (v15) {
                      CFNumberRef v36 = v15;
                    }
                    [(id)qword_100219F60 WFLog:3, "%s ssid %@ not allowed to wake up host in lockdown mode ", "__CreateBGScanRequest", v36 message];
                  }

                  objc_autoreleasePoolPop(v35);
                }
              }

              if (v11)
              {
                CFArrayAppendValue(theArray, v11);
                CFRelease(v11);
              }

              if (v22 && v15) {
                break;
              }
              if (v15) {
                goto LABEL_66;
              }
LABEL_82:
              if (Count == ++v9) {
                goto LABEL_88;
              }
            }

            if (!CFEqual(v15, &stru_1001EB6E0)) {
              CFStringAppendFormat(v22, 0LL, @"%@ ", v15);
            }
LABEL_66:
            if (CFEqual(v15, &stru_1001EB6E0))
            {
              CFNumberRef v37 = CFArrayGetValueAtIndex(a2, v9);
              CFRange v38 = sub_1000951FC((uint64_t)v37, @"BSSID");
              if (v38)
              {
                unsigned int v39 = v38;
                int v40 = sub_1000951FC((uint64_t)ValueAtIndex, @"CHANNEL");
                if (v40)
                {
                  int v41 = v40;
                  char v42 = sub_1000951FC((uint64_t)ValueAtIndex, @"CHANNEL_FLAGS");
                  unsigned __int8 v43 = CFDictionaryCreateMutable( kCFAllocatorDefault,  0LL,  &kCFTypeDictionaryKeyCallBacks,  &kCFTypeDictionaryValueCallBacks);
                  if (v43)
                  {
                    int v44 = v43;
                    CFDictionaryAddValue(v43, @"CHANNEL", v41);
                    if (v42) {
                      CFDictionaryAddValue(v44, @"CHANNEL_FLAGS", v42);
                    }
                    v73.length = CFArrayGetCount(v66);
                    v73.location = 0LL;
                    if (!CFArrayContainsValue(v66, v73, v44)) {
                      CFArrayAppendValue(v66, v44);
                    }
                    CFRelease(v44);
                  }
                }

                a2 = v69;
                if (v22)
                {
                  else {
                    CFIndex v45 = "";
                  }
                  uint64_t v46 = sub_1000951FC((uint64_t)ValueAtIndex, @"EXIT_NETWORK");
                  uint64_t v47 = " EX";
                  if (!v46) {
                    uint64_t v47 = "";
                  }
                  CFStringAppendFormat(v22, 0LL, @"%@ ~%s%s ", v39, v45, v47);
                }
              }
            }

            goto LABEL_82;
          }

void sub_1000DB930(uint64_t a1)
{
  if (a1)
  {
    uint64_t v2 = (const void *)sub_100043E8C(*(void *)(a1 + 64));
    int v3 = sub_1000DEA34(a1, v2, 1);
    uint64_t v4 = *(void *)(a1 + 64);
    if (v3)
    {
      CFMutableArrayRef v5 = v3;
      sub_10004D99C(v4, 1);
      CFRelease(v5);
    }

    else
    {
      sub_10004D99C(*(void *)(a1 + 64), 0);
    }
  }

uint64_t sub_1000DB9C8(uint64_t a1)
{
  uint64_t v2 = objc_autoreleasePoolPush();
  if (qword_100219F60) {
    [qword_100219F60 WFLog:@"%s: Resetting MIS state." message:@"WiFiDeviceManagerResetMISState"];
  }
  objc_autoreleasePoolPop(v2);
  int v3 = (const void *)sub_100043E8C(*(void *)(a1 + 64));
  return sub_1000DBA44(a1, v3, 0LL, 0LL, 0LL);
}

uint64_t sub_1000DBA44(uint64_t a1, const void *a2, const void *a3, uint64_t a4, uint64_t a5)
{
  uint64_t v10 = malloc(0x20uLL);
  void *v10 = a1;
  v10[1] = a4;
  v10[3] = a5;
  if (a3) {
    CFTypeRef v11 = CFRetain(a3);
  }
  else {
    CFTypeRef v11 = 0LL;
  }
  void v10[2] = v11;
  uint64_t v12 = sub_100045594(*(void *)(a1 + 64), a2, (uint64_t)sub_1000E5508, (uint64_t)v10);
  if ((_DWORD)v12)
  {
    uint64_t v13 = v12;
    CFIndex v14 = objc_autoreleasePoolPush();
    if (qword_100219F60) {
      objc_msgSend((id)qword_100219F60, "WFLog:message:", 4, "Unable to stop network (%d). deviceManager=%p", v13, a1);
    }
    objc_autoreleasePoolPop(v14);
    free(v10);
  }

  return 0LL;
}

void sub_1000DBB14(uint64_t a1, uint64_t a2, unsigned int *a3)
{
  if (*(unsigned __int8 *)(a1 + 5211) == (_DWORD)a2)
  {
    uint64_t v4 = objc_autoreleasePoolPush();
    if (qword_100219F60)
    {
      CFMutableArrayRef v5 = "enabled";
      if (!(_DWORD)a2) {
        CFMutableArrayRef v5 = "disabled";
      }
      objc_msgSend((id)qword_100219F60, "WFLog:message:", 3, "MIS is already %s", v5);
    }

    objc_autoreleasePoolPop(v4);
  }

  else
  {
    CFRange v8 = objc_autoreleasePoolPush();
    if ((_DWORD)a2)
    {
      if (qword_100219F60) {
        [qword_100219F60 WFLog:@"%s: Force MIS Service enable" message:3];
      }
      objc_autoreleasePoolPop(v8);
      sub_1000DBCC0(a1, a2, 0, 0, a3);
    }

    else
    {
      if (qword_100219F60) {
        [qword_100219F60 WFLog:@"%s: Force MIS Service disable" message:3];
      }
      objc_autoreleasePoolPop(v8);
      uint64_t v14 = 0LL;
      __int128 v12 = 0u;
      __int128 v13 = 0u;
      uint64_t v10 = 1LL;
      memset(v9, 0, sizeof(v9));
      DWORD2(v9[0]) = 1;
      CFStringRef v11 = CFStringCreateWithFormat(kCFAllocatorDefault, 0LL, @"%@", @"MIS Disabled");
      sub_1000DC1AC(a1, (uint64_t)v9);
      sub_1000DBCC0(a1, 0LL, 0, 0, a3);
      sub_1000DC604(a1);
    }
  }

void sub_1000DBCC0(uint64_t a1, uint64_t a2, int a3, int a4, unsigned int *a5)
{
  if ((_DWORD)a2)
  {
    uint64_t v41 = 0LL;
    __int128 v39 = 0u;
    __int128 v40 = 0u;
    __int128 v37 = 0u;
    __int128 v38 = 0u;
    __int128 v35 = 0u;
    __int128 v36 = 0u;
    __int128 v33 = 0u;
    __int128 v34 = 0u;
    __int128 v31 = 0u;
    __int128 v32 = 0u;
    LODWORD(v31) = *a5;
    sub_1000DC1AC(a1, (uint64_t)&v31);
  }

  if (!sub_10004B9CC(*(void *)(a1 + 64)))
  {
    if (*a5 != 5)
    {
      uint64_t v41 = 0LL;
      __int128 v39 = 0u;
      __int128 v40 = 0u;
      __int128 v37 = 0u;
      __int128 v38 = 0u;
      __int128 v35 = 0u;
      __int128 v36 = 0u;
      __int128 v33 = 0u;
      __int128 v34 = 0u;
      __int128 v31 = 0u;
      __int128 v32 = 0u;
      DWORD1(v31) = 3;
      sub_1000DC1AC(a1, (uint64_t)&v31);
    }

    return;
  }

  uint64_t v10 = (unsigned __int8 *)(a1 + 5208);
  if (!(a3 | a2)
    && ((id v24 = *(const __CFSet **)(a1 + 5264)) != 0LL && CFSetGetCount(v24)
     || (CFNumberRef v25 = *(const __CFSet **)(a1 + 5272)) != 0LL && CFSetGetCount(v25)))
  {
    CFNumberRef v26 = objc_autoreleasePoolPush();
    if (qword_100219F60)
    {
      if (v10[5]) {
        unsigned int v27 = "enabled";
      }
      else {
        unsigned int v27 = "disabled";
      }
      objc_msgSend((id)qword_100219F60, "WFLog:message:", 3, "MIS Discovery %s by more clients", v27);
    }

    objc_autoreleasePoolPop(v26);
    return;
  }

  if ((_DWORD)a2
    && *(_BYTE *)(a1 + 5211)
    && !*(_BYTE *)(a1 + 5376)
    && (a4 || CFSetGetCount(*(CFSetRef *)(a1 + 5264)) >= 1 && *(_DWORD *)(a1 + 7000) == 1))
  {
    unsigned int v28 = *v10;
    CFStringRef v11 = objc_autoreleasePoolPush();
    __int128 v12 = (void *)qword_100219F60;
    if (v28 > 0xD)
    {
      if (qword_100219F60) {
        [qword_100219F60 WFLog:@"MIS Discovery %s Force 2.4Ghz" message:@"enabled"];
      }
      unsigned int v15 = 1;
      goto LABEL_14;
    }

    if (qword_100219F60)
    {
      uint64_t v14 = "MIS Already enabled in 2.4GHz";
LABEL_12:
      objc_msgSend(v12, "WFLog:message:", 3, v14, v30);
    }
  }

  else
  {
    CFStringRef v11 = objc_autoreleasePoolPush();
    __int128 v12 = (void *)qword_100219F60;
    if (qword_100219F60)
    {
      __int128 v13 = "disabled";
      if ((_DWORD)a2) {
        __int128 v13 = "enabled";
      }
      uint64_t v30 = v13;
      uint64_t v14 = "MIS Discovery %s";
      goto LABEL_12;
    }
  }

  unsigned int v15 = 0;
LABEL_14:
  objc_autoreleasePoolPop(v11);
  int v16 = objc_autoreleasePoolPush();
  if (qword_100219F60)
  {
    if (*(_BYTE *)(a1 + 6992)) {
      CFNumberRef v17 = "Support";
    }
    else {
      CFNumberRef v17 = "Not Support";
    }
    CFNumberRef v18 = "is 5G";
    if (!*(_BYTE *)(a1 + 6995)) {
      CFNumberRef v18 = "is not 5G";
    }
    int v19 = *(_DWORD *)(a1 + 7000);
    id v20 = "5GHz";
    if (v19 == 1) {
      id v20 = "2.4GHz";
    }
    if (v19) {
      unsigned int v21 = v20;
    }
    else {
      unsigned int v21 = "Default";
    }
    if (a4) {
      int v22 = "2.4GHz";
    }
    else {
      int v22 = "Default";
    }
    objc_msgSend( (id)qword_100219F60,  "WFLog:message:",  3,  "MIS WiFi %s 5GHz SoftAP, Cellular Radio %s, User Preferred %s Band, Client Req %s\n",  v17,  v18,  v21,  v22);
  }

  objc_autoreleasePoolPop(v16);
  if ((_DWORD)a2) {
    sub_1000DC9F0(a1, 0LL);
  }
  *(_BYTE *)(a1 + 5213) = a2;
  *(_BYTE *)(a1 + 5376) = a4;
  *(_BYTE *)(a1 + 537_Block_object_dispose((const void *)(v15 - 112), 8) = *a5 == 8;
  CFIndex v23 = objc_autoreleasePoolPush();
  if (qword_100219F60) {
    objc_msgSend( (id)qword_100219F60,  "WFLog:message:",  3,  "%s misRestart %d misEnabled %d enable %d manager->mis.misEnabled %d numClients %d misIsNANPHS %d bringUpMethod %d\n",  "WiFiDeviceManagerSetMISDiscoveryState",  v15,  0,  a2,  *(unsigned __int8 *)(a1 + 5211),  (*(_BYTE *)(a1 + 5210) + *(_BYTE *)(a1 + 5209)),  *(unsigned __int8 *)(a1 + 5378),  *a5);
  }
  objc_autoreleasePoolPop(v23);
  _os_feature_enabled_impl("WiFiManager", "EnableNANPHS");
  if (v15)
  {
    sub_1000D9964(a1);
    goto LABEL_58;
  }

  if ((_DWORD)a2 || !*(_BYTE *)(a1 + 5211))
  {
    if ((_DWORD)a2 && *(_BYTE *)(a1 + 5211) && *(_BYTE *)(a1 + 5252)) {
      sub_1000458E0(*(void *)(a1 + 64), 1);
    }
    goto LABEL_58;
  }

  if (*(unsigned __int8 *)(a1 + 5210) != -*(_BYTE *)(a1 + 5209))
  {
LABEL_58:
    if (*(void *)(a1 + 4128))
    {
      sub_1000DCD9C(a1, 1);
      (*(void (**)(uint64_t, void, void))(a1 + 4128))( a1,  *(void *)(a1 + 4136),  *(unsigned __int8 *)(a1 + 5213));
    }

    return;
  }

  if (a3)
  {
    if (*(_BYTE *)(a1 + 5214))
    {
      *(_BYTE *)(a1 + 5214) = 0;
      sub_1000DC9F0(a1, 0LL);
    }

    uint64_t v41 = 0LL;
    __int128 v39 = 0u;
    __int128 v40 = 0u;
    __int128 v37 = 0u;
    __int128 v38 = 0u;
    __int128 v35 = 0u;
    __int128 v36 = 0u;
    __int128 v33 = 0u;
    __int128 v34 = 0u;
    __int128 v31 = 0u;
    __int128 v32 = 0u;
    DWORD2(v31) = 1;
    LODWORD(v3_Block_object_dispose((const void *)(v15 - 112), 8) = 1;
    *((void *)&v38 + 1) = CFStringCreateWithFormat(kCFAllocatorDefault, 0LL, @"%@", @"MIS Disabled");
    sub_1000DC1AC(a1, (uint64_t)&v31);
    sub_1000DC604(a1);
    goto LABEL_58;
  }

  BOOL v29 = objc_autoreleasePoolPush();
  if (qword_100219F60) {
    [qword_100219F60 WFLog:@"%s: Starting MIS idle timer" message:3];
  }
  objc_autoreleasePoolPop(v29);
  sub_1000DC9F0(a1, 2LL);
}

double sub_1000DC1AC(uint64_t a1, uint64_t a2)
{
  double v4 = *(double *)(a2 + 16);
  if (v4 != 0.0)
  {
    *(double *)(a1 + 6296) = v4;
    sub_1000EED88(a1, 1);
  }

  if (*(_DWORD *)a2)
  {
    if (!*(_DWORD *)(a1 + 6280)) {
      *(_DWORD *)(a1 + 6280) = *(_DWORD *)a2;
    }
    sub_1000EED88(a1, 1);
  }

  int v5 = *(_DWORD *)(a2 + 4);
  if (v5) {
    *(_DWORD *)(a1 + 6284) = v5;
  }
  double v6 = *(double *)(a2 + 24);
  if (v6 != 0.0)
  {
    *(double *)(a1 + 6304) = v6;
    sub_1000EED88(a1, 1);
  }

  unsigned int v7 = (_BYTE *)(a1 + 5208);
  if (*(_DWORD *)(a2 + 4) < 2u)
  {
    int v8 = 0;
  }

  else
  {
    sub_1000EED88(a1, 0);
    int v8 = 1;
  }

  if (*(_BYTE *)(a2 + 160)) {
    *(_BYTE *)(a1 + 6440) = *(_BYTE *)(a2 + 160);
  }
  int v9 = *(_DWORD *)(a2 + 8);
  if (v9)
  {
    if (*(_DWORD *)(a1 + 6284) == 1)
    {
      *(_DWORD *)(a1 + 628_Block_object_dispose((const void *)(v15 - 112), 8) = v9;
      *(double *)(a1 + 6312) = sub_10003AE68();
      int v8 = 1;
    }

    sub_1000EED88(a1, 0);
  }

  *(_DWORD *)(a1 + 634_Block_object_dispose((const void *)(v15 - 112), 8) = 0;
  uint64_t v10 = *(void *)(a1 + 5200);
  if (v10)
  {
    unsigned __int16 valuePtr = 0;
    CFStringRef v11 = (const __CFNumber *)sub_1000951FC(v10, @"AP_MODE_AUTH_UPPER");
    __int128 v12 = v11;
    if (v11 && CFNumberGetValue(v11, kCFNumberSInt16Type, &valuePtr))
    {
      int v13 = (valuePtr >> 2) & 2 | (valuePtr >> 5) & 0x80;
    }

    else
    {
      unsigned int v15 = objc_autoreleasePoolPush();
      if (qword_100219F60) {
        [qword_100219F60 WFLog:@"Faield to get SoftAP upper AUTH (numRef is NULL %d)" message:v12 == 0];
      }
      objc_autoreleasePoolPop(v15);
      int v13 = 0;
    }

    *(_DWORD *)(a1 + 634_Block_object_dispose((const void *)(v15 - 112), 8) = v13;
  }

  else
  {
    uint64_t v14 = objc_autoreleasePoolPush();
    if (qword_100219F60) {
      [(id)qword_100219F60 WFLog:3 message:"SoftAP has no network record"];
    }
    objc_autoreleasePoolPop(v14);
  }

  if (*(_BYTE *)(a2 + 72))
  {
    *(_BYTE *)(a1 + 6352) = *(_BYTE *)(a2 + 72);
    sub_1000EED88(a1, 1);
  }

  uint64_t v16 = *(void *)(a2 + 80);
  if (v16)
  {
    CFNumberRef v17 = *(const void **)(a1 + 6360);
    if (v17)
    {
      CFRelease(v17);
      *(void *)(a1 + 6360) = 0LL;
      uint64_t v16 = *(void *)(a2 + 80);
    }

    *(void *)(a1 + 6360) = v16;
    sub_1000EED88(a1, 1);
  }

  if (*(_BYTE *)(a2 + 88))
  {
    *(_BYTE *)(a1 + 636_Block_object_dispose((const void *)(v15 - 112), 8) = *(_BYTE *)(a2 + 88);
    sub_1000EED88(a1, 1);
  }

  double v18 = *(double *)(a2 + 96);
  if (v18 != 0.0)
  {
    *(double *)(a1 + 6376) = v18;
    sub_1000EED88(a1, 1);
  }

  double v19 = *(double *)(a2 + 104);
  if (v19 != 0.0)
  {
    *(double *)(a1 + 6384) = v19;
    sub_1000EED88(a1, 1);
  }

  int v20 = *(_DWORD *)(a2 + 112);
  if (v20) {
    *(_DWORD *)(a1 + 6392) = v20;
  }
  uint64_t v21 = *(void *)(a2 + 120);
  if (v21)
  {
    int v22 = *(const void **)(a1 + 6400);
    if (v22)
    {
      CFRelease(v22);
      *(void *)(a1 + 6400) = 0LL;
      uint64_t v21 = *(void *)(a2 + 120);
    }

    *(void *)(a1 + 6400) = v21;
  }

  if (*(_BYTE *)(a2 + 128)) {
    *(_BYTE *)(a1 + 640_Block_object_dispose((const void *)(v15 - 112), 8) = *(_BYTE *)(a2 + 128);
  }
  if (*(_BYTE *)(a2 + 144)) {
    *(_BYTE *)(a1 + 6424) = *(_BYTE *)(a2 + 144);
  }
  uint64_t v23 = *(void *)(a2 + 136);
  if (v23)
  {
    id v24 = *(const void **)(a1 + 6416);
    if (v24)
    {
      CFRelease(v24);
      *(void *)(a1 + 6416) = 0LL;
      uint64_t v23 = *(void *)(a2 + 136);
    }

    *(void *)(a1 + 6416) = v23;
  }

  uint64_t v25 = *(void *)(a2 + 152);
  if (v25)
  {
    CFNumberRef v26 = *(const void **)(a1 + 6432);
    if (v26)
    {
      CFRelease(v26);
      *(void *)(a1 + 6432) = 0LL;
      uint64_t v25 = *(void *)(a2 + 152);
    }

    *(void *)(a1 + 6432) = v25;
  }

  if (*(_BYTE *)(a2 + 160)) {
    *(_BYTE *)(a1 + 6440) = *(_BYTE *)(a2 + 160);
  }
  unsigned int v27 = objc_autoreleasePoolPush();
  if (qword_100219F60) {
    objc_msgSend( (id)qword_100219F60,  "WFLog:message:",  3,  "%s: PHSessionMetric: method=%d end=%d teardown=%d, misStart=%f softAPUp=%f sessionEnd=%f, appleDeviceConnectionCou nt=%d(%x) nonAppleDeviceConnectionCount=%d deviceDisconnectCount=%d, lpmDuration=%llu, channel=%d, securityTypes 0 x%XnanPhPublisherFailureReason %d, nanPhNanStationCount %d, nanPhNanStartSessionTime %f nanPhNanSessionEndTime %f",  "WiFiDeviceManagerRecordPHMetricStats",  *(unsigned int *)(a1 + 6280),  *(unsigned int *)(a1 + 6284),  *(unsigned int *)(a1 + 6288),  *(void *)(a1 + 6296),  *(void *)(a1 + 6304),  *(void *)(a1 + 6312),  *(unsigned __int16 *)(a1 + 6320),  *(unsigned __int16 *)(a1 + 6322),  *(unsigned __int16 *)(a1 + 6324),  *(unsigned __int16 *)(a1 + 6326),  *(void *)(a1 + 6328),  *(unsigned int *)(a1 + 6336),  *(unsigned int *)(a1 + 6348),  *(unsigned __int8 *)(a1 + 6352),  *(unsigned __int8 *)(a1 + 6368),  *(void *)(a1 + 6376),  *(void *)(a1 + 6384));
  }
  objc_autoreleasePoolPop(v27);
  if (v8)
  {
    if (*v7) {
      *(_DWORD *)(a1 + 6336) = *v7;
    }
    BOOL v29 = *(const __CFDictionary **)(a1 + 6984);
    if (v29)
    {
      CFBooleanRef Value = (const __CFNumber *)CFDictionaryGetValue(v29, @"SOFTAP_LOWPOWER_STATS_LOWPOWER_STATE_DURATION");
      if (Value) {
        CFNumberGetValue(Value, kCFNumberSInt64Type, (void *)(a1 + 6328));
      }
    }

    int v31 = *(unsigned __int8 *)(a1 + 6344);
    __int128 v32 = objc_autoreleasePoolPush();
    if (v31)
    {
      if (qword_100219F60) {
        [qword_100219F60 WFLog:@"%s: PHSessionMetric: submission already pending." message:3];
      }
      objc_autoreleasePoolPop(v32);
    }

    else
    {
      __int128 v33 = (double *)(a1 + 6280);
      if (qword_100219F60) {
        [qword_100219F60 WFLog:@"%s: PHSessionMetric: submission triggered." message:3];
      }
      objc_autoreleasePoolPop(v32);
      return sub_100031E28(v33);
    }
  }

  return result;
}

void sub_1000DC604(uint64_t a1)
{
  IOPMAssertionID v2 = *(_DWORD *)(a1 + 5220);
  if (v2)
  {
    uint64_t v3 = IOPMAssertionRelease(v2);
    if ((_DWORD)v3)
    {
      uint64_t v4 = v3;
      int v5 = objc_autoreleasePoolPush();
      if (qword_100219F60) {
        [qword_100219F60 WFLog:@"Stop MIS: Unable to release MIS PM Assertion error=%d" message:4 v4];
      }
      objc_autoreleasePoolPop(v5);
    }

    *(_DWORD *)(a1 + 5220) = 0;
  }

  if (*(void *)(a1 + 4936))
  {
    double v6 = objc_autoreleasePoolPush();
    if (qword_100219F60) {
      [(id)qword_100219F60 WFLog:3 message:"Stopping MIS session"];
    }
    objc_autoreleasePoolPop(v6);
    if (_MISStopService)
    {
      int v18 = _MISStopService(*(void *)(a1 + 4936), a1 + 4944, v7, v8, v9, v10, v11, v12);
      if (!v18) {
        goto LABEL_17;
      }
    }

    else
    {
      int v18 = -1;
    }

    double v19 = objc_autoreleasePoolPush();
    if (qword_100219F60) {
      [qword_100219F60 WFLog:@"Unable to stop DHCP Service: %s\n" message:4];
    }
    objc_autoreleasePoolPop(v19);
LABEL_17:
    if (!_MISSetHostCount || _MISSetHostCount(*(void *)(a1 + 4936), 2, 0LL, v13, v14, v15, v16, v17))
    {
      unsigned int v27 = objc_autoreleasePoolPush();
      if (qword_100219F60) {
        [qword_100219F60 WFLog:@"__WiFiDeviceManagerStopMIS: Error resetting MIS host count"];
      }
      objc_autoreleasePoolPop(v27);
    }

    if (_MISDetach)
    {
      int v28 = _MISDetach(*(void *)(a1 + 4936), v20, v21, v22, v23, v24, v25, v26);
      if (!v28)
      {
LABEL_29:
        *(void *)(a1 + 4936) = 0LL;
        goto LABEL_30;
      }
    }

    else
    {
      int v28 = -1;
    }

    BOOL v29 = objc_autoreleasePoolPush();
    if (qword_100219F60) {
      [qword_100219F60 WFLog:@"Unable to detach MIS session: %s\n" message:4];
    }
    objc_autoreleasePoolPop(v29);
    goto LABEL_29;
  }

uint64_t sub_1000DC9D8(uint64_t a1)
{
  return *(unsigned __int8 *)(a1 + 5211);
}

uint64_t sub_1000DC9E4(uint64_t result, char a2)
{
  *(_BYTE *)(result + 5211) = a2;
  return result;
}

void sub_1000DC9F0(uint64_t a1, uint64_t a2)
{
  uint64_t v2 = a2;
  double v4 = 90.0;
  if ((a2 - 1) >= 2)
  {
    double v13 = 315360000.0;
    switch((int)a2)
    {
      case 0:
        goto LABEL_14;
      case 3:
        goto LABEL_2;
      case 4:
        return;
      case 5:
        double v4 = 120.0;
        goto LABEL_2;
      default:
        double v4 = 315360000.0;
        goto LABEL_2;
    }
  }

  else
  {
LABEL_2:
    int v5 = *(_DWORD *)(a1 + 5224);
    if (!v5
      || (double v6 = *(double *)(a1 + 5240),
          CFAbsoluteTime Current = CFAbsoluteTimeGetCurrent(),
          int v5 = *(_DWORD *)(a1 + 5224),
          v4 > v6 - Current)
      || (_DWORD)v2 == 3 && v5 == 4)
    {
      BOOL v8 = v5 == 5;
      BOOL v9 = (v2 & 0xFFFFFFFE) == 2;
      BOOL v10 = v9 && v8;
      if (v9 && v8) {
        uint64_t v2 = 5LL;
      }
      else {
        uint64_t v2 = v2;
      }
      uint64_t v11 = objc_autoreleasePoolPush();
      if (qword_100219F60)
      {
        uint64_t v12 = " ";
        if (v10) {
          uint64_t v12 = "Extending";
        }
        [qword_100219F60 WFLog:@"Starting MIS Timer. %s state (%d) timeout (%.1f)" message:3 v12 v2 v4];
      }

      objc_autoreleasePoolPop(v11);
      double v13 = v4;
LABEL_14:
      if ((_DWORD)v2 != 5 && *(_DWORD *)(a1 + 5224) == 5) {
        CFSetRemoveValue(*(CFMutableSetRef *)(a1 + 5264), @"wifid");
      }
      *(_DWORD *)(a1 + 5224) = v2;
      uint64_t v14 = *(dispatch_source_s **)(a1 + 5232);
      dispatch_time_t v15 = dispatch_time(0LL, (uint64_t)(v13 * 1000000000.0));
      dispatch_source_set_timer(v14, v15, 0xFFFFFFFFFFFFFFFFLL, 0LL);
      *(double *)(a1 + 5240) = v13 + CFAbsoluteTimeGetCurrent();
    }

    else
    {
      uint64_t v16 = objc_autoreleasePoolPush();
      if (qword_100219F60) {
        objc_msgSend( (id)qword_100219F60,  "WFLog:message:",  3,  "MIS Timer Already Running. current state (%d) current timeout (%.1f) requested state (%d) requested timeout (%.1f) ",  *(unsigned int *)(a1 + 5224),  *(void *)(a1 + 5240),  v2,  *(void *)&v4);
      }
      objc_autoreleasePoolPop(v16);
    }
  }

uint64_t sub_1000DCBE0(uint64_t a1)
{
  return (*(_BYTE *)(a1 + 5210) + *(_BYTE *)(a1 + 5209));
}

uint64_t sub_1000DCBFC(uint64_t a1, uint64_t a2)
{
  uint64_t v2 = (unsigned __int8 *)(a1 + 7008);
  int v3 = *(unsigned __int8 *)(a1 + 7009);
  if (*v2)
  {
    uint64_t v7 = (const void *)sub_100043E8C(*(void *)(a1 + 64));
    BOOL v8 = sub_1000DEA34(a1, v7, 1);
    if (v8)
    {
      v2[1] |= 1u;
      CFRelease(v8);
    }

    BOOL v4 = 0LL;
    switch(v2[1])
    {
      case 0u:
        goto LABEL_13;
      case 1u:
      case 8u:
        BOOL v9 = (((_DWORD)a2 - 2) & 0xFFFFFFFD) == 0;
        goto LABEL_19;
      case 2u:
        BOOL v9 = (_DWORD)a2 == 4 || (_DWORD)a2 == 1;
        goto LABEL_19;
      case 4u:
        BOOL v4 = (a2 - 1) < 2;
        goto LABEL_22;
      case 5u:
        BOOL v9 = (_DWORD)a2 == 2;
LABEL_19:
        BOOL v4 = v9;
        break;
      default:
        goto LABEL_22;
    }

    goto LABEL_22;
  }

  BOOL v4 = v3 == 0;
  if ((_DWORD)a2 != 1)
  {
    if ((_DWORD)a2 != 2 || v3 != 1) {
      goto LABEL_22;
    }
    goto LABEL_13;
  }

  if (v3 == 2) {
LABEL_13:
  }
    BOOL v4 = 1LL;
LABEL_22:
  BOOL v10 = objc_autoreleasePoolPush();
  uint64_t v11 = (void *)qword_100219F60;
  if (qword_100219F60)
  {
    uint64_t v12 = *v2;
    double v13 = sub_10003B244(v2[1]);
    uint64_t v14 = v2[1];
    dispatch_time_t v15 = sub_10003B244(a2);
    uint64_t v16 = "Not Allowed";
    if (v4) {
      uint64_t v16 = "OK";
    }
    [v11 WFLog:3, "%s: isSupported: %d current state: %@(%d) request: %@(%d) status: %s", "WiFiDeviceManagerIsOpModeAllowed", v12, v13, v14, v15, a2, v16 message];
  }

  objc_autoreleasePoolPop(v10);
  return v4;
}

void sub_1000DCD9C(uint64_t a1, int a2)
{
  if (a1)
  {
    if (CFSetGetCount(*(CFSetRef *)(a1 + 5264)) > 0
      || CFSetGetCount(*(CFSetRef *)(a1 + 5280)) > 0
      || *(unsigned __int8 *)(a1 + 5252) | a2)
    {
      sub_1000DD0A4(a1);
    }

    else
    {
      BOOL v4 = objc_autoreleasePoolPush();
      int v5 = (void *)qword_100219F60;
      if (qword_100219F60)
      {
        uint64_t v6 = *(unsigned __int8 *)(a1 + 5252);
        uint64_t v7 = *(const __CFSet **)(a1 + 5264);
        if (v7) {
          CFIndex Count = CFSetGetCount(v7);
        }
        else {
          CFIndex Count = 0LL;
        }
        BOOL v9 = *(const __CFSet **)(a1 + 5272);
        if (v9) {
          CFIndex v10 = CFSetGetCount(v9);
        }
        else {
          CFIndex v10 = 0LL;
        }
        uint64_t v11 = *(const __CFSet **)(a1 + 5280);
        if (v11) {
          CFIndex v12 = CFSetGetCount(v11);
        }
        else {
          CFIndex v12 = 0LL;
        }
        double v13 = *(const __CFSet **)(a1 + 5288);
        if (v13) {
          CFIndex v14 = CFSetGetCount(v13);
        }
        else {
          CFIndex v14 = 0LL;
        }
        dispatch_time_t v15 = *(const __CFSet **)(a1 + 5296);
        if (v15) {
          CFIndex v16 = CFSetGetCount(v15);
        }
        else {
          CFIndex v16 = 0LL;
        }
        uint64_t v17 = *(const __CFSet **)(a1 + 5304);
        if (v17) {
          uint64_t v17 = (const __CFSet *)CFSetGetCount(v17);
        }
        objc_msgSend( v5,  "WFLog:message:",  3,  "%s: current misIsHidden: %d, num broadcast clients %ld, num hidden clients %ld, num broadcast STAs %ld, num hi dden STAs %ld, num other hidden STAs %ld num Nan Link STAs %ld",  "WiFiDeviceManagerSetMISHiddenOrBroadcastState",  v6,  Count,  v10,  v12,  v14,  v16,  v17);
      }

      objc_autoreleasePoolPop(v4);
      int v18 = objc_autoreleasePoolPush();
      if (qword_100219F60) {
        [(id)qword_100219F60 WFLog:3 message:"Start Broadcast to Hidden state change timer\n"];
      }
      objc_autoreleasePoolPop(v18);
      double v19 = *(dispatch_source_s **)(a1 + 5312);
      dispatch_time_t v20 = dispatch_time(0LL, 90000000000LL);
      dispatch_source_set_timer(v19, v20, 0xFFFFFFFFFFFFFFFFLL, 0LL);
    }
  }

void sub_1000DCF84(uint64_t a1, uint64_t a2)
{
  uint64_t v4 = *(void *)(a1 + 64);
  int v5 = (const void *)sub_100043E98(v4);
  uint64_t v6 = sub_10003EC6C(v4, v5, 508LL, 0LL, a2);
  if ((_DWORD)v6)
  {
    uint64_t v7 = v6;
    BOOL v8 = objc_autoreleasePoolPush();
    if (qword_100219F60) {
      objc_msgSend( (id)qword_100219F60,  "WFLog:message:",  4,  "Unable to set MIS max STA (err = %d) deviceManager=%p\n",  v7,  a1);
    }
    objc_autoreleasePoolPop(v8);
  }

void sub_1000DD024(uint64_t a1, int a2, int a3, int a4, void *value)
{
  if (a1 && value)
  {
    if (a2)
    {
      uint64_t v6 = 5272LL;
      if (!a3) {
        uint64_t v6 = 5264LL;
      }
      CFSetAddValue(*(CFMutableSetRef *)(a1 + v6), value);
LABEL_10:
      sub_1000DCD9C(a1, 0);
      return;
    }

    uint64_t v8 = 5272LL;
    if (!a3) {
      uint64_t v8 = 5264LL;
    }
    CFSetRemoveValue(*(CFMutableSetRef *)(a1 + v8), value);
    if (a4) {
      goto LABEL_10;
    }
  }

void sub_1000DD0A4(uint64_t a1)
{
  if (a1)
  {
    uint64_t v2 = (_BYTE *)(a1 + 5211);
    if (*(_BYTE *)(a1 + 5211))
    {
      BOOL v3 = CFSetGetCount(*(CFSetRef *)(a1 + 5264)) <= 0 && CFSetGetCount(*(CFSetRef *)(a1 + 5280)) < 1;
      uint64_t v4 = objc_autoreleasePoolPush();
      int v5 = (void *)qword_100219F60;
      if (qword_100219F60)
      {
        uint64_t v17 = v2[41];
        uint64_t v6 = *(const __CFSet **)(a1 + 5264);
        if (v6) {
          CFIndex Count = CFSetGetCount(v6);
        }
        else {
          CFIndex Count = 0LL;
        }
        uint64_t v8 = *(const __CFSet **)(a1 + 5272);
        if (v8) {
          CFIndex v9 = CFSetGetCount(v8);
        }
        else {
          CFIndex v9 = 0LL;
        }
        CFIndex v10 = *(const __CFSet **)(a1 + 5280);
        if (v10) {
          CFIndex v11 = CFSetGetCount(v10);
        }
        else {
          CFIndex v11 = 0LL;
        }
        CFIndex v12 = *(const __CFSet **)(a1 + 5288);
        if (v12) {
          CFIndex v13 = CFSetGetCount(v12);
        }
        else {
          CFIndex v13 = 0LL;
        }
        CFIndex v14 = *(const __CFSet **)(a1 + 5296);
        if (v14) {
          CFIndex v15 = CFSetGetCount(v14);
        }
        else {
          CFIndex v15 = 0LL;
        }
        CFIndex v16 = *(const __CFSet **)(a1 + 5304);
        if (v16) {
          CFIndex v16 = (const __CFSet *)CFSetGetCount(v16);
        }
        objc_msgSend( v5,  "WFLog:message:",  3,  "%s: new misIsHidden: %d, current misIsHidden: %d, num broadcast clients %ld, num hidden clients %ld, num broad cast STAs %ld, num hidden STAs %ld, num other hidden STAs %ld num Nan Link STAs %ld",  "__WiFiDeviceManagerSetBroadcastHiddenMode",  v3,  v17,  Count,  v9,  v11,  v13,  v15,  v16);
      }

      objc_autoreleasePoolPop(v4);
      if (v2[41] != v3)
      {
        v2[41] = v3;
        if (*v2)
        {
          sub_1000457AC(*(void *)(a1 + 64), v3);
          sub_1000F1468(a1);
        }
      }
    }
  }

void sub_1000DD250(void *a1)
{
  if (a1)
  {
    uint64_t v2 = (unsigned __int8 *)a1 + 5213;
    BOOL v3 = objc_autoreleasePoolPush();
    uint64_t v4 = (void *)qword_100219F60;
    if (qword_100219F60)
    {
      uint64_t v23 = *v2;
      uint64_t v5 = v2[39];
      uint64_t v6 = (const __CFSet *)a1[658];
      if (v6) {
        CFIndex Count = CFSetGetCount(v6);
      }
      else {
        CFIndex Count = 0LL;
      }
      uint64_t v8 = (const __CFSet *)a1[659];
      if (v8) {
        CFIndex v9 = CFSetGetCount(v8);
      }
      else {
        CFIndex v9 = 0LL;
      }
      CFIndex v10 = (const __CFSet *)a1[660];
      if (v10) {
        CFIndex v11 = CFSetGetCount(v10);
      }
      else {
        CFIndex v11 = 0LL;
      }
      CFIndex v12 = (const __CFSet *)a1[661];
      if (v12) {
        CFIndex v13 = CFSetGetCount(v12);
      }
      else {
        CFIndex v13 = 0LL;
      }
      CFIndex v14 = (const __CFSet *)a1[662];
      if (v14) {
        CFIndex v15 = CFSetGetCount(v14);
      }
      else {
        CFIndex v15 = 0LL;
      }
      CFIndex v16 = (const __CFSet *)a1[663];
      if (v16) {
        CFIndex v16 = (const __CFSet *)CFSetGetCount(v16);
      }
      objc_msgSend( v4,  "WFLog:message:",  3,  "%s (discovery:%d): Clearing misIsHidden: %d, num broadcast clients %ld, num hidden clients %ld, num broadcast ST As %ld, num hidden STAs %ld, num other hidden STAs %ld num Nan Link STAs %ld",  "WiFiDeviceManagerClearMISHiddenOrBroadcastState",  v23,  v5,  Count,  v9,  v11,  v13,  v15,  v16);
    }

    objc_autoreleasePoolPop(v3);
    v2[39] = 0;
    if (!*v2)
    {
      uint64_t v17 = (__CFSet *)a1[658];
      if (v17) {
        CFSetRemoveAllValues(v17);
      }
      int v18 = (__CFSet *)a1[659];
      if (v18) {
        CFSetRemoveAllValues(v18);
      }
    }

    double v19 = (__CFSet *)a1[660];
    if (v19) {
      CFSetRemoveAllValues(v19);
    }
    dispatch_time_t v20 = (__CFSet *)a1[661];
    if (v20) {
      CFSetRemoveAllValues(v20);
    }
    uint64_t v21 = (__CFSet *)a1[662];
    if (v21) {
      CFSetRemoveAllValues(v21);
    }
    if (!v2[167])
    {
      uint64_t v22 = (__CFSet *)a1[663];
      if (v22) {
        CFSetRemoveAllValues(v22);
      }
    }
  }

uint64_t sub_1000DD3FC(uint64_t a1, int a2)
{
  uint64_t v4 = *(void *)(a1 + 64);
  uint64_t v5 = (const void *)sub_100043E8C(v4);
  uint64_t v6 = (uint64_t *)&kCFBooleanFalse;
  if (!a2) {
    uint64_t v6 = (uint64_t *)&kCFBooleanTrue;
  }
  sub_10003EC6C(v4, v5, 511LL, 0LL, *v6);
  return sub_1000154BC(*(void *)(a1 + 120), a2);
}

uint64_t sub_1000DD468(uint64_t a1)
{
  return *(unsigned __int8 *)(a1 + 5213);
}

uint64_t sub_1000DD474(uint64_t a1)
{
  return sub_100047598(*(void *)(a1 + 64));
}

uint64_t sub_1000DD47C(uint64_t a1)
{
  uint64_t result = sub_100047598(*(void *)(a1 + 64));
  if ((_DWORD)result) {
    return sub_10004D6F8(*(void *)(a1 + 64)) != 0;
  }
  return result;
}

uint64_t sub_1000DD4B4(uint64_t a1)
{
  return *(unsigned __int8 *)(a1 + 5449);
}

void sub_1000DD4C0(uint64_t a1, int a2, int a3, int a4)
{
  uint64_t v8 = (unsigned __int8 *)(a1 + 7032);
  CFIndex v9 = objc_autoreleasePoolPush();
  CFIndex v10 = (void *)qword_100219F60;
  if (qword_100219F60)
  {
    int v11 = sub_100047598(*(void *)(a1 + 64));
    CFIndex v12 = "YES";
    if (!v11) {
      CFIndex v12 = "NO";
    }
    CFIndex v13 = "enable";
    if (a2) {
      CFIndex v14 = "enable";
    }
    else {
      CFIndex v14 = "disable";
    }
    if (!a3) {
      CFIndex v13 = "disable";
    }
    CFIndex v15 = "enabled";
    if (!a4) {
      CFIndex v15 = "disabled";
    }
    objc_msgSend( v10,  "WFLog:message:",  3,  "WoW Capable = %s, Attempting to %s WoW and %s LPAS with WoW on Captive %s",  v12,  v14,  v13,  v15);
  }

  objc_autoreleasePoolPop(v9);
  if (!*(_BYTE *)(a1 + 3403))
  {
    if (a2)
    {
      if (*v8 != a2)
      {
        sub_1000D16F4(a1, 3);
        if (*(_DWORD *)(a1 + 20) == 1)
        {
          *(_DWORD *)(a1 + 192) = 17;
          sub_1000D0A5C(a1, 0LL, (uint64_t)"WiFiDeviceManagerSetWoWState");
        }
      }
    }
  }

  *uint64_t v8 = a2;
  v8[1] = a3;
  void v8[2] = a4;
  sub_1000DD63C(a1, a2, a3, a4, 0);
  if (!a4) {
    sub_1000D6494(a1);
  }
}

id sub_1000DD63C(uint64_t a1, int a2, int a3, int a4, int a5)
{
  id result = (id)sub_100047598(*(void *)(a1 + 64));
  if ((_DWORD)result)
  {
    *(_OWORD *)keys = *(_OWORD *)off_1001E4FA8;
    __int128 v23 = *(_OWORD *)off_1001E4FB8;
    CFBooleanRef v11 = kCFBooleanTrue;
    if (a2) {
      CFBooleanRef v12 = kCFBooleanTrue;
    }
    else {
      CFBooleanRef v12 = kCFBooleanFalse;
    }
    if (a3) {
      CFBooleanRef v13 = kCFBooleanTrue;
    }
    else {
      CFBooleanRef v13 = kCFBooleanFalse;
    }
    CFBooleanRef v18 = v12;
    CFBooleanRef v19 = v13;
    if (a4) {
      CFBooleanRef v14 = kCFBooleanTrue;
    }
    else {
      CFBooleanRef v14 = kCFBooleanFalse;
    }
    if (!a5) {
      CFBooleanRef v11 = kCFBooleanFalse;
    }
    CFBooleanRef v20 = v14;
    CFBooleanRef v21 = v11;
    id result = CFDictionaryCreate( kCFAllocatorDefault,  (const void **)keys,  (const void **)&v18,  4LL,  &kCFTypeDictionaryKeyCallBacks,  &kCFTypeDictionaryValueCallBacks);
    if (result)
    {
      CFIndex v15 = result;
      sub_100055A78(*(void *)(a1 + 64), a2, a3);
      uint64_t v16 = *(void *)(a1 + 64);
      uint64_t v17 = (const void *)sub_100043E8C(v16);
      sub_10003EC6C(v16, v17, 496LL, 0LL, (uint64_t)v15);
      CFRelease(v15);
      sub_1000DB930(a1);
      return [+[WiFiXPCManager sharedXPCManager](WiFiXPCManager, "sharedXPCManager", v18, v19) sendWoWDidChangeEventWithInterfaceName:sub_10004CE2C(*(void *)(a1 + 64))];
    }
  }

  return result;
}

uint64_t sub_1000DD7A4(uint64_t result)
{
  if (result) {
    return sub_1000452B8(*(void *)(result + 64));
  }
  return result;
}

uint64_t sub_1000DD7B4(uint64_t a1, const void *a2, char a3)
{
  uint64_t v7 = *(const void **)(a1 + 7304);
  if (v7)
  {
    CFRelease(v7);
    *(void *)(a1 + 7304) = 0LL;
  }

  if (a2) {
    CFTypeRef v8 = CFRetain(a2);
  }
  else {
    CFTypeRef v8 = 0LL;
  }
  *(void *)(a1 + 7304) = v8;
  *(_BYTE *)(a1 + 7312) = a3;
  return 1LL;
}

BOOL sub_1000DD82C(uint64_t a1, uint64_t a2)
{
  return sub_100050388(*(void *)(a1 + 64), a2) == 0;
}

uint64_t sub_1000DD84C(uint64_t a1)
{
  unsigned int v3 = 0;
  if (!sub_10005045C(*(void *)(a1 + 64), (uint64_t)&v3))
  {
    uint64_t v1 = objc_autoreleasePoolPush();
    if (qword_100219F60) {
      [qword_100219F60 WFLog:@"message:3%s WiFiMC : Retrieved band support :[%d]" message:@"WiFiDeviceManagerGetCountryBandSupport" v3];
    }
    objc_autoreleasePoolPop(v1);
  }

  return v3;
}

BOOL sub_1000DD8C4(uint64_t a1, const __CFString *a2)
{
  unsigned int v3 = sub_1000DDB78(a1);
  if (!v3)
  {
    CFIndex v15 = objc_autoreleasePoolPush();
    if (qword_100219F60) {
      [qword_100219F60 WFLog:@"%s: error creating network struct" message:3];
    }
    objc_autoreleasePoolPop(v15);
    return 0LL;
  }

  uint64_t v4 = v3;
  if (!a2 || !CFStringGetLength(a2))
  {
    CFRelease(v4);
    return 0LL;
  }

  CFStringRef v5 = sub_100095408((CFDictionaryRef *)v4);
  uint64_t v6 = objc_autoreleasePoolPush();
  if (qword_100219F60)
  {
    uint64_t v7 = "already";
    if (!v5) {
      uint64_t v7 = "not";
    }
    [qword_100219F60 WFLog:@"MIS password is %s present" message:3 v7];
  }

  objc_autoreleasePoolPop(v6);
  if (v5 && CFStringGetLength(v5))
  {
    if (CFStringCompare(a2, v5, 0LL))
    {
      BOOL v8 = sub_100099C50(v4, a2);
      if (v8)
      {
LABEL_35:
        CFRelease(v4);
LABEL_36:
        CFRelease(v5);
        return v8;
      }

      CFIndex v9 = objc_autoreleasePoolPush();
      if (qword_100219F60) {
        [qword_100219F60 WFLog:@"%s: failed setting MIS password with one already present. Try removing and attempt again...", "WiFiDeviceManagerSetMisPassword"];
      }
      objc_autoreleasePoolPop(v9);
      sub_100099D38(v4);
      sub_100099DFC(v4);
      BOOL v10 = sub_100099C50(v4, a2);
      if (v10)
      {
        BOOL v8 = v10;
        goto LABEL_35;
      }

      CFBooleanRef v11 = objc_autoreleasePoolPush();
      if (qword_100219F60) {
        [(id)qword_100219F60 WFLog:4 message:"Error saving password in keychain"];
      }
      BOOL v8 = 0LL;
    }

    else
    {
      CFBooleanRef v11 = objc_autoreleasePoolPush();
      if (qword_100219F60) {
        [qword_100219F60 WFLog:@"%s: new and current passwords are equal" message:@"WiFiDeviceManagerSetMisPassword"];
      }
      BOOL v8 = 1LL;
    }

    objc_autoreleasePoolPop(v11);
    goto LABEL_35;
  }

  BOOL v8 = sub_100099C50(v4, a2);
  if (!v8)
  {
    CFBooleanRef v12 = objc_autoreleasePoolPush();
    if (qword_100219F60) {
      [qword_100219F60 WFLog:@"%s: failed setting new MIS password. Try removing any existing item and attempt again..." message:3];
    }
    objc_autoreleasePoolPop(v12);
    sub_100099D38(v4);
    sub_100099DFC(v4);
    BOOL v13 = sub_100099C50(v4, a2);
    if (v13)
    {
      BOOL v8 = v13;
    }

    else
    {
      CFBooleanRef v14 = objc_autoreleasePoolPush();
      if (qword_100219F60) {
        [(id)qword_100219F60 WFLog:4 message:"Error saving new password in keychain"];
      }
      objc_autoreleasePoolPop(v14);
      BOOL v8 = 0LL;
    }
  }

  CFRelease(v4);
  if (v5) {
    goto LABEL_36;
  }
  return v8;
}

_WORD *sub_1000DDB78(uint64_t a1)
{
  uint64_t v2 = objc_autoreleasePoolPush();
  if (qword_100219F60) {
    [(id)qword_100219F60 WFLog:3 message:"Preparing MIS Network Configuration Parameters"];
  }
  objc_autoreleasePoolPop(v2);
  CFMutableDictionaryRef Mutable = CFDictionaryCreateMutable( kCFAllocatorDefault,  0LL,  &kCFTypeDictionaryKeyCallBacks,  &kCFTypeDictionaryValueCallBacks);
  if (!Mutable) {
    return 0LL;
  }
  uint64_t v4 = Mutable;
  int v15 = -1431655766;
  __int16 valuePtr = 1;
  CFNumberRef v5 = CFNumberCreate(kCFAllocatorDefault, kCFNumberSInt16Type, &valuePtr);
  if (!v5) {
    goto LABEL_11;
  }
  CFNumberRef v6 = v5;
  CFDictionaryAddValue(v4, @"AP_MODE_AUTH_LOWER", v5);
  CFRelease(v6);
  __int16 valuePtr = 8;
  CFNumberRef v7 = CFNumberCreate(kCFAllocatorDefault, kCFNumberSInt16Type, &valuePtr);
  if (!v7) {
    goto LABEL_11;
  }
  CFNumberRef v8 = v7;
  CFDictionaryAddValue(v4, @"AP_MODE_AUTH_UPPER", v7);
  CFRelease(v8);
  int v15 = 10;
  CFNumberRef v9 = CFNumberCreate(kCFAllocatorDefault, kCFNumberSInt32Type, &v15);
  if (!v9) {
    goto LABEL_11;
  }
  CFNumberRef v10 = v9;
  CFDictionaryAddValue(v4, @"AP_MODE_CYPHER_TYPE", v9);
  CFRelease(v10);
  int v15 = *(unsigned __int8 *)(a1 + 5208);
  CFNumberRef v11 = CFNumberCreate(kCFAllocatorDefault, kCFNumberSInt32Type, &v15);
  if (!v11
    || (CFNumberRef v12 = v11,
        CFDictionaryAddValue(v4, @"CHANNEL", v11),
        CFRelease(v12),
        CFDictionaryAddValue(v4, @"SSID_STR", @"_AppleWi-FiInternetTetheringSSID_"),
        (BOOL v13 = sub_100094AAC((uint64_t)kCFAllocatorDefault, v4)) == 0LL))
  {
LABEL_11:
    BOOL v13 = 0LL;
  }

  CFRelease(v4);
  return v13;
}

void sub_1000DDD4C(uint64_t a1, CFStringRef *a2)
{
  unsigned int v3 = (CFDictionaryRef *)sub_1000DDB78(a1);
  if (v3)
  {
    uint64_t v4 = v3;
    *a2 = 0LL;
    *a2 = sub_100095408(v3);
    CFRelease(v4);
  }

  else
  {
    CFNumberRef v5 = objc_autoreleasePoolPush();
    if (qword_100219F60) {
      [qword_100219F60 WFLog:@"error creating network struct" message:3];
    }
    objc_autoreleasePoolPop(v5);
  }

uint64_t sub_1000DDDD4(uint64_t a1)
{
  return *(unsigned int *)(a1 + 20);
}

uint64_t sub_1000DDDDC(uint64_t a1)
{
  return *(unsigned int *)(a1 + 20);
}

uint64_t sub_1000DDE04(uint64_t a1, const void *a2, uint64_t a3)
{
  if (*(_DWORD *)(a1 + 20) == (_DWORD)a3) {
    return 0LL;
  }
  uint64_t v16 = 0LL;
  __int128 v14 = 0u;
  __int128 v15 = 0u;
  uint64_t v12 = 3LL;
  memset(v11, 0, sizeof(v11));
  DWORD2(v11[0]) = 3;
  CFStringRef v13 = CFStringCreateWithFormat(kCFAllocatorDefault, 0LL, @"%@", @"Power Off");
  sub_1000DC1AC(a1, (uint64_t)v11);
  sub_1000DC604(a1);
  if (!(_DWORD)a3)
  {
    CFNumberRef v6 = *(void **)(a1 + 8928);
    if (v6) {
      [v6 resetSettlement];
    }
    if (*(_DWORD *)(a1 + 5416))
    {
      CFNumberRef v7 = *(void **)(a1 + 5424);
      if (v7) {

      }
      *(void *)(a1 + 5424) = 0LL;
      sub_1000D00D8(a1, a2);
    }

    CFNumberRef v8 = sub_1000DEA34(a1, a2, 1);
    if (v8)
    {
      CFNumberRef v9 = v8;
      CFRelease(v9);
    }
  }

  uint64_t result = sub_10004CF48(*(void *)(a1 + 64), a2, a3);
  if (!(_DWORD)result)
  {
    *(_DWORD *)(a1 + 20) = a3;
    sub_1000DDF64(a1, (uint64_t)a2);
    sub_1000DE0D0(a1, 1u, a3);
    if (*(_DWORD *)(a1 + 20) == 1) {
      sub_100054538(*(void *)(a1 + 64));
    }
    return 0LL;
  }

  return result;
}

id sub_1000DDF64(uint64_t a1, uint64_t a2)
{
  unsigned int v3 = *(void (**)(uint64_t, uint64_t, void))(a1 + 3984);
  if (v3) {
    v3(a1, a2, *(void *)(a1 + 3992));
  }
  uint64_t v4 = objc_autoreleasePoolPush();
  if (qword_100219F60) {
    [qword_100219F60 WFLog:@"Device powering %s" message:sub_10003AE44(*(_DWORD *)(a1 + 20))];
  }
  objc_autoreleasePoolPop(v4);
  sub_1000D0428(a1);
  sub_1000D16F4(a1, 1);
  if (*(_DWORD *)(a1 + 20) == 1)
  {
    sub_1000EBB80(a1);
    *(_DWORD *)(a1 + 192) = 3;
    if (_os_feature_enabled_impl("CoreWiFi", "UnifiedAutoJoin"))
    {
      sub_1000F5F98(a1, 8uLL);
    }

    else
    {
      [+[WiFiXPCManager sharedXPCManager](WiFiXPCManager, "sharedXPCManager") autoJoinStartedWithTrigger:8 interfaceName:sub_100043E8C(*(void *)(a1 + 64))];
      sub_1000D0A5C(a1, 2LL, (uint64_t)"__WiFiDeviceManagerUpdatePower");
    }

    sub_1000D4854(a1);
    uint64_t v5 = *(void *)(a1 + 64);
    CFNumberRef v6 = (const void *)sub_100043E8C(v5);
    sub_10004D50C(v5, v6, *(_DWORD *)(a1 + 5388), *(_DWORD *)(a1 + 5384));
  }

  id result = (id)_os_feature_enabled_impl("CoreWiFi", "UnifiedAutoJoin");
  if ((_DWORD)result) {
    return sub_1000F6C7C(a1);
  }
  return result;
}

void sub_1000DE0D0(uint64_t a1, unsigned int a2, uint64_t a3)
{
  CFNumberRef v6 = (_BYTE *)(a1 + 7080);
  double Current = CFAbsoluteTimeGetCurrent();
  double v8 = *(double *)(a1 + 7048);
  BOOL v9 = v8 != 0.0;
  if (v8 + 120.0 <= Current) {
    BOOL v9 = 0;
  }
  id v62 = v6;
  if (!a2 && v9)
  {
    CFNumberRef v10 = objc_autoreleasePoolPush();
    if (qword_100219F60) {
      [qword_100219F60 WFLog:@"%s: DPS event detected while already in monitoring period. Ignoring..." message:4];
    }
LABEL_7:
    objc_autoreleasePoolPop(v10);
    CFNumberRef v11 = 0LL;
LABEL_8:
    int v12 = 1;
    goto LABEL_9;
  }

  if (!a2) {
    LOBYTE(v9) = 1;
  }
  if (v9)
  {
    uint64_t v14 = *(void *)(a1 + 64);
    __int128 v15 = (const void *)sub_100043E8C(v14);
    uint64_t v16 = (const __CFArray *)sub_100040538(v14, v15);
    CFNumberRef v11 = v16;
    if (v16)
    {
      uint64_t v17 = sub_100095BC8(v16);
      CFBooleanRef v18 = sub_100096968(v11);
      CFBooleanRef v19 = sub_1000969F8(v11);
    }

    else
    {
      uint64_t v17 = 0LL;
      CFBooleanRef v18 = 0LL;
      CFBooleanRef v19 = 0LL;
    }

    switch(a2)
    {
      case 0u:
        uint64_t v46 = objc_autoreleasePoolPush();
        if (qword_100219F60) {
          [qword_100219F60 WFLog:@"%s: initiating DPS probing and monitoring period" message:3];
        }
        objc_autoreleasePoolPop(v46);
        uint64_t v47 = *(void **)(a1 + 7320);
        if (v47) {
          [v47 addFaultEvent:6 forInterface:sub_10004CE2C(*(void *)(a1 + 64))];
        }
        goto LABEL_79;
      case 1u:
        if (!*v6) {
          _BYTE *v6 = 1;
        }
        if (v6[1]) {
          goto LABEL_8;
        }
        uint64_t v55 = objc_autoreleasePoolPush();
        if (qword_100219F60) {
          [qword_100219F60 WFLog:@"%s: power state changed while monitoring DPS.. State:%d" message:3,  "__WiFiDeviceManagerEvaluateDpsStateChange",  a3];
        }
        objc_autoreleasePoolPop(v55);
        int v12 = 1;
        v6[1] = 1;
        if (v6[2]) {
          goto LABEL_9;
        }
        goto LABEL_116;
      case 2u:
        uint64_t v56 = objc_autoreleasePoolPush();
        if (qword_100219F60) {
          objc_msgSend((id)qword_100219F60, "WFLog:message:", 3, "ControlCenterToggled: state:%d", a3);
        }
        objc_autoreleasePoolPop(v56);
        if (*v6) {
          goto LABEL_8;
        }
        uint64_t v57 = objc_autoreleasePoolPush();
        if (qword_100219F60) {
          [qword_100219F60 WFLog:@"__WiFiDeviceManagerEvaluateDpsStateChange: link state changed while monitoring DPS"];
        }
        objc_autoreleasePoolPop(v57);
        int v12 = 1;
        _BYTE *v6 = 1;
        if (v6[1]) {
          goto LABEL_9;
        }
        v6[2] = 1;
LABEL_116:
        sub_10003387C(*(void *)(a1 + 64), 0LL, 2u, 0);
        goto LABEL_9;
      case 3u:
        if (v6[1])
        {
          if (!v11) {
            goto LABEL_8;
          }
        }

        else
        {
          int v12 = 1;
          if (!v11 || !*v6)
          {
LABEL_9:
            BOOL v13 = 1;
            goto LABEL_16;
          }
        }

        sub_10003387C(*(void *)(a1 + 64), 0LL, 3u, 0);
        goto LABEL_8;
      case 4u:
      case 5u:
        int v40 = objc_autoreleasePoolPush();
        if (qword_100219F60) {
          objc_msgSend((id)qword_100219F60, "WFLog:message:", 3, "Event IP/roam state changed: info:%d", a3);
        }
        objc_autoreleasePoolPop(v40);
        if (v11)
        {
          uint64_t v41 = *(const void **)(a1 + 7056);
          CFNumberRef v6 = v62;
          if (v41 && v17 && !CFEqual(v41, v17)) {
            v62[3] = 1;
          }
          char v42 = *(const void **)(a1 + 7064);
          if (v42 && v18 && !CFEqual(v42, v18)) {
            v62[4] = 1;
          }
          unsigned __int8 v43 = *(const void **)(a1 + 7072);
          if (v43 && v19 && !CFEqual(v43, v19)) {
            void v62[5] = 1;
          }
          LOBYTE(v63) = v62[3];
          *(_WORD *)((char *)&v63 + 1) = *((_WORD *)v62 + 2);
          BYTE3(v63) = *v62;
          char v44 = v62[1];
          DWORD1(v63) = -1431655766;
          *((void *)&v63 + 1) = __PAIR64__(a3, a2);
          BYTE4(v63) = v44;
          sub_100037250(&v63);
          CFIndex v45 = v62;
          goto LABEL_81;
        }

        CFNumberRef v10 = objc_autoreleasePoolPush();
        if (qword_100219F60) {
          [qword_100219F60 WFLog:@"__WiFiDeviceManagerEvaluateDpsStateChange: no connected network while in DPS monitoring period."];
        }
        goto LABEL_7;
      case 6u:
        if (*v6) {
          goto LABEL_8;
        }
        id v58 = objc_autoreleasePoolPush();
        if (qword_100219F60) {
          [qword_100219F60 WFLog:@"__WiFiDeviceManagerEvaluateDpsStateChange: link went down while monitoring DPS.. reason:%d" message:3, "%s: link went down while monitoring DPS.. reason:%d", "__WiFiDeviceManagerEvaluateDpsStateChange", a3];
        }
        objc_autoreleasePoolPop(v58);
        int v12 = 1;
        _BYTE *v6 = 1;
        LOBYTE(v64) = v6[3];
        *(_WORD *)((char *)&v64 + 1) = *((_WORD *)v6 + 2);
        BYTE3(v64) = 1;
        char v59 = v6[1];
        *(void *)((char *)&v64 + 4) = 0x6AAAAAAAALL;
        BYTE4(v64) = v59;
        HIDWORD(v64) = a3;
        sub_100037250(&v64);
        BOOL v13 = 0;
        goto LABEL_16;
      default:
LABEL_79:
        if (!v11)
        {
          CFNumberRef v10 = objc_autoreleasePoolPush();
          if (qword_100219F60) {
            [qword_100219F60 WFLog:@"%s: DPS received while not connected. Not proceeding." message:4];
          }
          goto LABEL_7;
        }

        *(double *)(a1 + 704_Block_object_dispose((const void *)(v15 - 112), 8) = Current;
        CFIndex v45 = (_BYTE *)(a1 + 7080);
        v6[110] = 0;
LABEL_81:
        *((_WORD *)v45 + 2) = 0;
        *(_DWORD *)CFIndex v45 = 0;
        uint64_t v48 = *(const void **)(a1 + 7056);
        if (v48)
        {
          CFRelease(v48);
          *(void *)(a1 + 7056) = 0LL;
        }

        unsigned int v49 = *(const void **)(a1 + 7064);
        if (v49)
        {
          CFRelease(v49);
          *(void *)(a1 + 7064) = 0LL;
        }

        CFIndex v50 = *(const void **)(a1 + 7072);
        if (v50)
        {
          CFRelease(v50);
          *(void *)(a1 + 7072) = 0LL;
        }

        if (v17) {
          *(void *)(a1 + 7056) = CFRetain(v17);
        }
        if (v18) {
          *(void *)(a1 + 7064) = CFRetain(v18);
        }
        if (v19) {
          *(void *)(a1 + 7072) = CFRetain(v19);
        }
        int v12 = 1;
        if (v6[108]) {
          goto LABEL_9;
        }
        CFAbsoluteTime v51 = CFAbsoluteTimeGetCurrent();
        v6[108] = 1;
        *(CFAbsoluteTime *)(a1 + 7040) = v51;
        uint64_t v52 = objc_autoreleasePoolPush();
        if (qword_100219F60) {
          [(id)qword_100219F60 WFLog:3 message:"DPS Probe: Starting probe on all ACs"];
        }
        objc_autoreleasePoolPop(v52);
        uint64_t v53 = 0LL;
        do
        {
          sub_100111130(v53, a1);
          uint64_t v53 = (v53 + 1);
        }

        while ((_DWORD)v53 != 4);
        if (!a1)
        {
          CFIndex v54 = objc_autoreleasePoolPush();
          if (qword_100219F60) {
            [qword_100219F60 WFLog:@"%s: null manager." message:4];
          }
          objc_autoreleasePoolPop(v54);
          goto LABEL_54;
        }

        goto LABEL_8;
    }
  }

  int v12 = 0;
  CFNumberRef v11 = 0LL;
  BOOL v13 = a2 != 6;
LABEL_16:
  CFBooleanRef v20 = *(const __CFDictionary **)(a1 + 7192);
  if (v20) {
    unsigned int Count = CFDictionaryGetCount(v20);
  }
  else {
    unsigned int Count = 0;
  }
  uint64_t v22 = (const __CFDictionary *)sub_100054D9C(*(void *)(a1 + 64));
  if (!v22)
  {
    int v27 = 0;
    uint64_t v26 = 0LL;
    int v28 = 0LL;
    goto LABEL_35;
  }

  __int128 v23 = v22;
  unsigned int v24 = CFDictionaryGetCount(v22);
  unsigned int v25 = v24;
  uint64_t v26 = 0LL;
  int v27 = 0;
  int v28 = 0LL;
  if (!v24 || Count > v24)
  {
LABEL_35:
    if (!v12) {
      goto LABEL_46;
    }
    goto LABEL_36;
  }

  if (!Count)
  {
    uint64_t v26 = 0LL;
    int v28 = 0LL;
LABEL_45:
    *(void *)(a1 + 7192) = CFDictionaryCreateCopy(kCFAllocatorDefault, v23);
    int v27 = 1;
    if (!v12) {
      goto LABEL_46;
    }
LABEL_36:
    __int128 v36 = *(const __CFDictionary **)(a1 + 7192);
    if (v36 && CFDictionaryGetCount(v36) && ((v62[110] != 0) & ~v27) == 0)
    {
      v62[110] = 1;
      __int128 v37 = objc_autoreleasePoolPush();
      if (qword_100219F60) {
        [(id)qword_100219F60 WFLog:3, "Sending AccessPointInfo update to WA: %@", *(void *)(a1 + 7192) message];
      }
      objc_autoreleasePoolPop(v37);
      sub_100037470(*(const __CFDictionary **)(a1 + 7192));
    }

    goto LABEL_46;
  }

  BOOL v29 = (const void **)malloc(8LL * v24);
  if (!v29)
  {
    CFBooleanRef v60 = objc_autoreleasePoolPush();
    if (qword_100219F60) {
      [qword_100219F60 WFLog:@"%s: keys alloc failure" message:4];
    }
    objc_autoreleasePoolPop(v60);
    if (!v13) {
      goto LABEL_51;
    }
    goto LABEL_54;
  }

  uint64_t v26 = v29;
  bzero(v29, 8LL * v25);
  uint64_t v30 = (const void **)malloc(8LL * v25);
  if (v30)
  {
    int v28 = v30;
    bzero(v30, 8LL * v25);
    CFDictionaryGetKeysAndValues(v23, v26, v28);
    unint64_t v31 = 0LL;
    uint64_t v32 = 8LL * v25;
    do
    {
      CFBooleanRef Value = (const __CFString *)CFDictionaryGetValue(v23, v26[v31 / 8]);
      __int128 v34 = (const __CFString *)CFDictionaryGetValue(*(CFDictionaryRef *)(a1 + 7192), v26[v31 / 8]);
      if (Value) {
        BOOL v35 = v34 == 0LL;
      }
      else {
        BOOL v35 = 1;
      }
      if (v35 || CFStringCompare(Value, v34, 0LL))
      {
        dispatch_time_t v38 = *(const void **)(a1 + 7192);
        if (v38)
        {
          CFRelease(v38);
          *(void *)(a1 + 7192) = 0LL;
        }

        goto LABEL_45;
      }

      v31 += 8LL;
    }

    while (v32 != v31);
    int v27 = 0;
    if (v12) {
      goto LABEL_36;
    }
LABEL_46:
    if (!v26) {
      goto LABEL_48;
    }
    goto LABEL_47;
  }

  CFBooleanRef v61 = objc_autoreleasePoolPush();
  if (qword_100219F60) {
    [qword_100219F60 WFLog:@"%s: values alloc failure" message:4];
  }
  objc_autoreleasePoolPop(v61);
  int v28 = 0LL;
LABEL_47:
  free(v26);
LABEL_48:
  if (v28) {
    free(v28);
  }
  if (!v13)
  {
LABEL_51:
    __int128 v39 = objc_autoreleasePoolPush();
    if (qword_100219F60) {
      [(id)qword_100219F60 WFLog:3 message:"DPS/DNS Symptoms: DPS Probe: cancelling DPS probe & clearing HUD because of link down"];
    }
    objc_autoreleasePoolPop(v39);
    sub_10010E744(a1);
    sub_100111058(a1);
  }

uint64_t sub_1000DE958(uint64_t a1, uint64_t a2)
{
  uint64_t v4 = (const void *)sub_100043E8C(*(void *)(a1 + 64));
  return sub_1000DDE04(a1, v4, a2);
}

__CFDictionary *sub_1000DE98C(uint64_t a1, const void *a2)
{
  unsigned int v3 = sub_1000DEA34(a1, a2, 1);
  if (!v3) {
    return 0LL;
  }
  uint64_t v4 = (uint64_t)v3;
  CFMutableDictionaryRef Mutable = CFDictionaryCreateMutable( kCFAllocatorDefault,  0LL,  &kCFTypeDictionaryKeyCallBacks,  &kCFTypeDictionaryValueCallBacks);
  if (Mutable)
  {
    CFNumberRef v6 = sub_100096710(v4);
    CFDictionarySetValue(Mutable, @"RoamKnownBSS", v6);
    CFDictionarySetValue(Mutable, @"RoamEvents", *(const void **)(a1 + 272));
  }

  return Mutable;
}

void *sub_1000DEA34(uint64_t a1, const void *a2, int a3)
{
  CFNumberRef v6 = sub_100040538(*(void *)(a1 + 64), a2);
  if (v6)
  {
    CFNumberRef v7 = v6;
    double v8 = sub_1000D91B0(a1, v6, 1);
    if (v8)
    {
      BOOL v9 = v8;
      if (sub_100095318((BOOL)v7))
      {
        CFNumberRef v10 = (const __CFString *)sub_100095BC8(v7);
        CFNumberRef v11 = sub_100095BC8(v9);
        if (v10)
        {
          int v12 = v11;
          if (v11)
          {
            if (!CFEqual(v10, v11))
            {
              BOOL v13 = objc_autoreleasePoolPush();
              if (qword_100219F60) {
                [(id)qword_100219F60 WFLog:3, "%s: updating known SSID %@ to connected SSID %@", "__WiFiDeviceManagerCopyCurrentNetwork", v12, v10 message];
              }
              objc_autoreleasePoolPop(v13);
              sub_10009582C((uint64_t)v9, @"SSID_STR", v10);
              CFDataRef ExternalRepresentation = CFStringCreateExternalRepresentation(kCFAllocatorDefault, v10, 0x8000100u, 0);
              if (ExternalRepresentation)
              {
                CFDataRef v15 = ExternalRepresentation;
                sub_10009582C((uint64_t)v9, @"SSID", ExternalRepresentation);
                CFRelease(v15);
              }
            }
          }
        }
      }
    }

    else
    {
      BOOL v9 = (void *)CFRetain(v7);
      if (!v9)
      {
        [+[WiFiXPCManager sharedXPCManager](WiFiXPCManager, "sharedXPCManager") setCachedCurrentNetworkRef:0 interfaceName:a2];
        [+[WiFiXPCManager sharedXPCManager](WiFiXPCManager, "sharedXPCManager") setCachedCurrentKnownNetworkRef:interfaceName:0, a2];
        BOOL v9 = 0LL;
LABEL_46:
        CFRelease(v7);
        return v9;
      }
    }

    unsigned int v16 = sub_1000FDC1C(a1, v9);
    sub_1000970C0((uint64_t)v9, @"DiagnosticsBssEnv", v16);
    sub_1000522AC(*(void *)(a1 + 64), v9);
    uint64_t v17 = sub_1000A47DC(*(const __CFArray **)(a1 + 3696), (const __CFDictionary **)v9);
    if (!v17)
    {
      int v27 = objc_autoreleasePoolPush();
      if (qword_100219F60) {
        [(id)qword_100219F60 WFLog:4, "WFMacRandomisation : Network <%@> not present in Private MAC Cache", sub_100095BC8(v9) message];
      }
      objc_autoreleasePoolPop(v27);
      goto LABEL_24;
    }

    uint64_t v18 = (uint64_t)v17;
    CFBooleanRef v19 = sub_1000951FC((uint64_t)v17, @"PRIVATE_MAC_ADDRESS");
    if (v19)
    {
      CFBooleanRef v20 = v19;
      CFTypeID TypeID = CFDictionaryGetTypeID();
      if (TypeID == CFGetTypeID(v20))
      {
        sub_10009582C((uint64_t)v9, @"PRIVATE_MAC_ADDRESS", v20);
        CFBooleanRef Value = (const __CFData *)CFDictionaryGetValue((CFDictionaryRef)v20, @"PRIVATE_MAC_ADDRESS_VALUE");
        if (!sub_10003B498(Value))
        {
          if (!sub_1000971AC((uint64_t)v9))
          {
            CFMutableDictionaryRef Mutable = CFDictionaryCreateMutable( 0LL,  0LL,  &kCFTypeDictionaryKeyCallBacks,  &kCFTypeDictionaryValueCallBacks);
            sub_1000F4340(v18, Mutable);
            sub_10009582C((uint64_t)v9, @"PrivateMacInfoDictionary", Mutable);
            if (Mutable) {
              CFRelease(Mutable);
            }
          }

          goto LABEL_24;
        }

        sub_10009582C((uint64_t)v9, @"PrivateMacInfoDictionary", 0LL);
        __int128 v23 = (const __CFBoolean *)sub_1000951FC(v18, @"FailureThresholdMet");
        if (v23 && (unsigned int v24 = v23, v23 == kCFBooleanTrue))
        {
          uint64_t v25 = (uint64_t)v9;
          uint64_t v26 = v24;
        }

        else
        {
          uint64_t v25 = (uint64_t)v9;
          uint64_t v26 = 0LL;
        }

        sub_10009582C(v25, @"FailureThresholdMet", v26);
      }
    }

uint64_t sub_1000DEF3C(uint64_t a1, uint64_t a2, int a3)
{
  uint64_t v5 = sub_10004D504();
  if (!(_DWORD)v5)
  {
    *(_BYTE *)(a1 + 249) = a3;
    if (a3)
    {
      sub_1000D0428(a1);
    }

    else
    {
      *(_DWORD *)(a1 + 192) = 6;
      if (_os_feature_enabled_impl("CoreWiFi", "UnifiedAutoJoin"))
      {
        sub_1000F5F98(a1, 0xCuLL);
      }

      else
      {
        [+[WiFiXPCManager sharedXPCManager](WiFiXPCManager, "sharedXPCManager") autoJoinStartedWithTrigger:12 interfaceName:sub_100043E8C(*(void *)(a1 + 64))];
        sub_1000D0A5C(a1, 2LL, (uint64_t)"WiFiDeviceManagerSetWiFiDirectMode");
      }
    }
  }

  return v5;
}

CFArrayRef sub_1000DEFF8(uint64_t a1)
{
  CFArrayRef result = (CFArrayRef)CFSetGetCount(*(CFSetRef *)(a1 + 3312));
  if (result)
  {
    CFIndex v3 = (CFIndex)result;
    __chkstk_darwin();
    uint64_t v5 = (char *)&v6 - ((v4 + 15) & 0xFFFFFFFFFFFFFFF0LL);
    memset(v5, 170, v4);
    CFSetGetValues(*(CFSetRef *)(a1 + 3312), (const void **)v5);
    return CFArrayCreate(kCFAllocatorDefault, (const void **)v5, v3, &kCFTypeArrayCallBacks);
  }

  return result;
}

__CFDictionary *sub_1000DF0C8(uint64_t a1, const __CFString *a2)
{
  int valuePtr = 0;
  size_t v4 = (const __CFString *)sub_100040CF8(*(void *)(a1 + 64));
  if (!v4)
  {
    CFBooleanRef v21 = objc_autoreleasePoolPush();
    if (qword_100219F60) {
      [qword_100219F60 WFLog:@"%s: No awdl Interface." message:3];
    }
    goto LABEL_36;
  }

  if (!a2)
  {
    CFBooleanRef v21 = objc_autoreleasePoolPush();
    if (qword_100219F60) {
      [qword_100219F60 WFLog:@"%s: null interface." message:3];
    }
LABEL_36:
    objc_autoreleasePoolPop(v21);
    return 0LL;
  }

  if (CFStringCompare(v4, a2, 0LL) == kCFCompareEqualTo)
  {
    uint64_t v6 = sub_100040C24(*(void *)(a1 + 64), a2);
    if (!v6) {
      return v6;
    }
    CFNumberRef v10 = objc_autoreleasePoolPush();
    CFBooleanRef Value = CFDictionaryGetValue(v6, @"LINK_CHANGED_IS_AVAILABLE");
    MutableCFStringRef Copy = CFDictionaryCreateMutableCopy(kCFAllocatorDefault, 0LL, v6);
    if (!MutableCopy)
    {
      uint64_t v22 = objc_autoreleasePoolPush();
      if (qword_100219F60) {
        [qword_100219F60 WFLog:@"%s: null copiedInfoRef." message:3];
      }
      objc_autoreleasePoolPop(v22);
      goto LABEL_30;
    }

    BOOL v13 = MutableCopy;
    if (Value)
    {
      uint64_t v14 = *(void **)(a1 + 5400);
      if (v14)
      {
        if (![v14 isPowerResourceAvailable:1]
          || (CFBooleanRef v15 = kCFBooleanTrue, !CFEqual(Value, kCFBooleanTrue)))
        {
          CFBooleanRef v15 = kCFBooleanFalse;
        }

        CFDictionarySetValue(v13, @"LINK_CHANGED_IS_AVAILABLE", v15);
      }
    }

    int v16 = sub_1000DF3D8(a1);
    uint64_t v17 = (const void **)&kCFBooleanFalse;
    if (!v16) {
      uint64_t v17 = (const void **)&kCFBooleanTrue;
    }
    CFDictionarySetValue(v13, @"RANGING_ALLOWED", *v17);
    if (sub_1000DF3D8(a1))
    {
      int v18 = 1;
    }

    else
    {
      if (!sub_1000DF3FC(a1))
      {
LABEL_27:
        CFNumberRef v19 = CFNumberCreate(kCFAllocatorDefault, kCFNumberSInt32Type, &valuePtr);
        CFDictionarySetValue(v13, @"RANGING_ACTIVE_SESSION", v19);
        if (v19) {
          CFRelease(v19);
        }
        CFRelease(v6);
        uint64_t v6 = v13;
LABEL_30:
        objc_autoreleasePoolPop(v10);
        return v6;
      }

      int v18 = 2;
    }

    int valuePtr = v18;
    goto LABEL_27;
  }

  CFMutableDictionaryRef Mutable = CFDictionaryCreateMutable( kCFAllocatorDefault,  0LL,  &kCFTypeDictionaryKeyCallBacks,  &kCFTypeDictionaryValueCallBacks);
  uint64_t v6 = Mutable;
  if (Mutable)
  {
    CFNumberRef v7 = (_BYTE *)(a1 + 5252);
    CFDictionarySetValue(Mutable, @"WiFiHostApStateIdentifier", kCFBooleanTrue);
    if ((v7[1757] & 4) != 0) {
      CFBooleanRef v8 = kCFBooleanTrue;
    }
    else {
      CFBooleanRef v8 = kCFBooleanFalse;
    }
    CFDictionarySetValue(v6, @"WiFiHostApStateEnable", v8);
    if (*v7) {
      CFBooleanRef v9 = kCFBooleanTrue;
    }
    else {
      CFBooleanRef v9 = kCFBooleanFalse;
    }
    CFDictionarySetValue(v6, @"WiFiHostApStateADHSMode", v9);
  }

  return v6;
}

uint64_t sub_1000DF3D8(uint64_t a1)
{
  uint64_t result = (uint64_t)sub_1000E6404(a1, 1);
  if (result)
  {
    CFRelease((CFTypeRef)result);
    return 1LL;
  }

  return result;
}

uint64_t sub_1000DF3FC(uint64_t a1)
{
  uint64_t result = (uint64_t)sub_1000E6404(a1, 2);
  if (result)
  {
    CFRelease((CFTypeRef)result);
    return 1LL;
  }

  return result;
}

void *sub_1000DF420(uint64_t a1, const void *a2)
{
  return sub_1000DEA34(a1, a2, 0);
}

id sub_1000DF428(uint64_t a1)
{
  id v2 = -[NSString copy](-[NSUUID UUIDString](+[NSUUID UUID](&OBJC_CLASS___NSUUID, "UUID"), "UUIDString"), "copy");
  *(void *)(a1 + 384_Block_object_dispose((const void *)(v15 - 112), 8) = v2;
  return [*(id *)(a1 + 8776) setColocatedScopeID:v2];
}

uint64_t sub_1000DF46C(uint64_t a1, const void *a2, int a3)
{
  uint64_t v6 = (const void *)sub_100043E8C(*(void *)(a1 + 64));
  CFNumberRef v7 = sub_100040538(*(void *)(a1 + 64), v6);
  if (v7)
  {
    CFBooleanRef v8 = v7;
    CFBooleanRef v9 = sub_100095BC8(v7);
    if (sub_100055A48(*(void *)(a1 + 64)))
    {
      uint64_t valuePtr = 0LL;
      CFNumberRef v10 = *(const __CFArray **)(a1 + 3728);
      if (v10) {
        CFIndex Count = CFArrayGetCount(v10);
      }
      else {
        CFIndex Count = 0LL;
      }
      CFBooleanRef v15 = (const __CFNumber *)sub_1000951FC((uint64_t)v8, @"CHANNEL_FLAGS");
      if (v15) {
        CFNumberGetValue(v15, kCFNumberIntType, (char *)&valuePtr + 4);
      }
      if (a3 != 1)
      {
        if ((valuePtr & 0x200000000000LL) == 0)
        {
          if (Count >= 1)
          {
            CFIndex v24 = 0LL;
            int v25 = 0;
            do
            {
              ValueAtIndex = CFArrayGetValueAtIndex(*(CFArrayRef *)(a1 + 3728), v24);
              if (ValueAtIndex)
              {
                uint64_t v27 = (uint64_t)ValueAtIndex;
                int v28 = sub_100095BC8(ValueAtIndex);
                BOOL v29 = (const __CFNumber *)sub_1000951FC(v27, @"CHANNEL_FLAGS");
                if (v29)
                {
                  CFNumberGetValue(v29, kCFNumberIntType, &valuePtr);
                  if (CFEqual(v9, a2))
                  {
                    if ((valuePtr & 0x2000) != 0)
                    {
                      if (CFEqual(v9, v28))
                      {
                        uint64_t v14 = objc_autoreleasePoolPush();
                        if (qword_100219F60) {
                          [qword_100219F60 WFLog:@"%s: same ssid is found with 6E enabled, do same ssid roaming" message:3];
                        }
                        goto LABEL_60;
                      }

                      if ((valuePtr & 0x2000) != 0 && !CFEqual(v9, v28)) {
                        int v25 = 1;
                      }
                    }
                  }

                  else if ((valuePtr & 0x2000) != 0 && CFEqual(a2, v28))
                  {
                    int v25 = 1;
                  }
                }
              }

              ++v24;
            }

            while (Count != v24);
            if (!v25) {
              goto LABEL_57;
            }
            __int128 v23 = objc_autoreleasePoolPush();
            if (qword_100219F60) {
              [qword_100219F60 WFLog:@"%s: different ssid is found with 6E enabled, do ssid transition" message:3];
            }
            goto LABEL_48;
          }

LABEL_57:
          if (CFEqual(v9, a2))
          {
            uint64_t v14 = objc_autoreleasePoolPush();
            if (qword_100219F60) {
              [qword_100219F60 WFLog:@"%s: no matching network in colocated cache with 6E enabled, do same ssid roaming" message:3];
            }
            goto LABEL_60;
          }
        }

  if (v15)
  {
    uint64_t v26 = objc_autoreleasePoolPush();
    if (qword_100219F60) {
      [qword_100219F60 WFLog:@"%s - Resetting BssBlacklist Expiry interval" message:3];
    }
    objc_autoreleasePoolPop(v26);
    [*(id *)(a1 + 6632) setDenyListedStateExpiryIntervalInSec:2 state:300.0];
  }

void sub_1000DF8C0(uint64_t a1, const void *a2, const void *a3, unsigned int a4)
{
  int v7 = sub_1000DF46C(a1, a3, a4);
  if (v7 == 1)
  {
    sub_10004EFE0(*(void *)(a1 + 64), a2, a4);
  }

  else if (v7 == 2)
  {
    sub_1000DF940(a1, a4 == 1);
  }

void sub_1000DF940(uint64_t a1, int a2)
{
  uint64_t valuePtr = 0LL;
  if (sub_100055A48(*(void *)(a1 + 64)))
  {
    size_t v4 = objc_autoreleasePoolPush();
    if (qword_100219F60)
    {
      uint64_t v5 = "2.4Gh/5Gh";
      if (!a2) {
        uint64_t v5 = "6Gh";
      }
      [qword_100219F60 WFLog:@"[NWTRANSIT]: Initiate Colocated Network Transition. Transitioning to %s Colocated Network" message:3 v5];
    }

    objc_autoreleasePoolPop(v4);
    uint64_t v6 = (const void *)sub_100043E8C(*(void *)(a1 + 64));
    int v7 = sub_100040538(*(void *)(a1 + 64), v6);
    CFBooleanRef v8 = (const __CFNumber *)sub_1000951FC((uint64_t)v7, @"CHANNEL_FLAGS");
    if (v8) {
      CFNumberGetValue(v8, kCFNumberIntType, &valuePtr);
    }
    CFBooleanRef v9 = *(const __CFArray **)(a1 + 3728);
    if (v9) {
      CFIndex Count = CFArrayGetCount(v9);
    }
    else {
      CFIndex Count = 0LL;
    }
    CFNumberRef v11 = objc_autoreleasePoolPush();
    if (qword_100219F60) {
      objc_msgSend((id)qword_100219F60, "WFLog:message:", 3, "[NWTRANSIT]: Num Colocated Networks %ld", Count);
    }
    objc_autoreleasePoolPop(v11);
    char v12 = valuePtr;
    if (!a2)
    {
      if ((valuePtr & 0x18) != 0 && Count >= 1)
      {
        CFIndex v18 = 0LL;
        while (1)
        {
          ValueAtIndex = CFArrayGetValueAtIndex(*(CFArrayRef *)(a1 + 3728), v18);
          if (ValueAtIndex)
          {
            CFBooleanRef v15 = ValueAtIndex;
            CFBooleanRef v20 = (const __CFNumber *)sub_1000951FC((uint64_t)ValueAtIndex, @"CHANNEL_FLAGS");
            if (v20)
            {
              CFNumberGetValue(v20, kCFNumberIntType, (char *)&valuePtr + 4);
              if ((valuePtr & 0x200000000000LL) != 0) {
                break;
              }
            }
          }

          if (Count == ++v18)
          {
            char v12 = valuePtr;
            goto LABEL_32;
          }
        }

        CFIndex v24 = objc_autoreleasePoolPush();
        if (qword_100219F60) {
          [(id)qword_100219F60 WFLog:3, "[NWTRANSIT]:Associated to 2.4Gh/5Gh. Top 6Gh Colocated Network for Transition = %@", v15 message];
        }
      }

      else
      {
LABEL_32:
        if ((v12 & 8) == 0 || Count < 1) {
          return;
        }
        CFIndex v21 = 0LL;
        while (1)
        {
          __int16 v22 = CFArrayGetValueAtIndex(*(CFArrayRef *)(a1 + 3728), v21);
          if (v22)
          {
            CFBooleanRef v15 = v22;
            __int128 v23 = (const __CFNumber *)sub_1000951FC((uint64_t)v22, @"CHANNEL_FLAGS");
            if (v23)
            {
              CFNumberGetValue(v23, kCFNumberIntType, (char *)&valuePtr + 4);
              if ((valuePtr & 0x1000000000LL) != 0) {
                break;
              }
            }
          }

          if (Count == ++v21) {
            return;
          }
        }

        CFIndex v24 = objc_autoreleasePoolPush();
        if (qword_100219F60) {
          [(id)qword_100219F60 WFLog:3, "[NWTRANSIT]:Associated to 2.4Gh. Top 5Gh Colocated Network for Transition = %@", v15 message];
        }
      }

      objc_autoreleasePoolPop(v24);
LABEL_45:
      sub_1000F8C18(a1, v15);
      return;
    }

    if ((valuePtr & 0x2000) != 0 && Count >= 1)
    {
      CFIndex v13 = 0LL;
      while (1)
      {
        uint64_t v14 = CFArrayGetValueAtIndex(*(CFArrayRef *)(a1 + 3728), v13);
        if (v14)
        {
          CFBooleanRef v15 = v14;
          CFIndex v16 = objc_autoreleasePoolPush();
          if (qword_100219F60) {
            [(id)qword_100219F60 WFLog:3, "[NWTRANSIT]: Associated to 6Gh. Top Colocated Network for Transition = %@", v15 message];
          }
          objc_autoreleasePoolPop(v16);
          int v17 = (const __CFNumber *)sub_1000951FC((uint64_t)v15, @"CHANNEL_FLAGS");
          if (v17)
          {
            CFNumberGetValue(v17, kCFNumberIntType, (char *)&valuePtr + 4);
            if ((valuePtr & 0x1000000000LL) != 0) {
              break;
            }
          }
        }

        if (Count == ++v13) {
          return;
        }
      }

      goto LABEL_45;
    }
  }

void sub_1000DFBFC(uint64_t a1, void *a2)
{
  if (a2)
  {
    [*(id *)(a1 + 32) setJoinEvent:0 withReason:0 lastDisconnectReason:*(unsigned int *)(a1 + 48) lastJoinFailure:0 andNetworkDetails:a2 forInterface:*(void *)(a1 + 40)];
  }

void sub_1000DFC4C(uint64_t a1)
{
  uint64_t v2 = *(void *)(a1 + 40);
  if (*(void *)(v2 + 240))
  {
    uint64_t v4 = *(void *)(a1 + 32);
    CFIndex v3 = (CFTypeRef *)(a1 + 32);
    (*(void (**)(uint64_t, void, void, void, void, void))(v2 + 3864))( v2,  *(void *)(*(void *)(v4 + 8) + 24LL),  0LL,  0LL,  0LL,  *(void *)(v2 + 3872));
    CFRelease(v3[1]);
    uint64_t v5 = *v3;
  }

  else
  {
    CFRelease((CFTypeRef)v2);
    uint64_t v6 = *(void **)(a1 + 32);
    CFIndex v3 = (CFTypeRef *)(a1 + 32);
    uint64_t v5 = v6;
  }

  int v7 = *(const void **)(v5[1] + 24LL);
  if (v7)
  {
    CFRelease(v7);
    *(void *)(*((void *)*v3 + 1) + 24LL) = 0LL;
  }

void *sub_1000DFCCC(void *result, int a2, CFTypeRef cf, int a4, int a5, int a6, int a7)
{
  CFNumberRef v11 = result;
  if (cf)
  {
    CFIndex v13 = (const void *)result[478];
    if (v13)
    {
      CFRelease(v13);
      v11[478] = 0LL;
    }

    uint64_t result = CFRetain(cf);
    v11[478] = result;
  }

  *((_DWORD *)v11 + 95_Block_object_dispose((const void *)(v15 - 112), 8) = a4;
  *((_DWORD *)v11 + 960) = a6;
  *((_DWORD *)v11 + 959) = a5;
  *((_DWORD *)v11 + 961) = a7;
  return result;
}

void sub_1000DFD3C(uint64_t a1)
{
  uint64_t v2 = (const void *)sub_100043E8C(*(void *)(a1 + 64));
  sub_1000CE074(a1, v2, 1001LL, "WiFiDeviceManagerDisassociateAll", 20797LL);
}

void sub_1000DFD78(uint64_t *a1, const void *a2, uint64_t a3)
{
  uint64_t v6 = (const __CFDictionary **)sub_1000DEA34((uint64_t)a1, a2, 1);
  int v7 = objc_autoreleasePoolPush();
  if (qword_100219F60) {
    [(id)qword_100219F60 WFLog:3, "%s: network=%@ reason=%@(%d)", "WiFiDeviceManagerCancelAssociation", v6, sub_10003B050(a3), a3 message];
  }
  objc_autoreleasePoolPop(v7);
  if (a1[915])
  {
    v8[0] = _NSConcreteStackBlock;
    v8[1] = 3221225472LL;
    void v8[2] = sub_1000DFE98;
    v8[3] = &unk_1001E4BD0;
    v8[4] = a1;
    int v9 = a3;
    sub_1000D8E24((uint64_t)a1, v6, (uint64_t)v8);
  }

  sub_10004ED80(a1[8], a2, 0LL, a3, "WiFiDeviceManagerCancelAssociation", 20827LL);
  sub_10001BBC8(a1[15], 0LL, 1LL, 0);
  if (v6) {
    CFRelease(v6);
  }
}

void sub_1000DFE98(uint64_t a1, void *a2)
{
  if (a2)
  {
    [*(id *)(*(void *)(a1 + 32) + 7320) setJoinEvent:0 withReason:0 lastDisconnectReason:*(unsigned int *)(a1 + 40) lastJoinFailure:0 andNetworkDetails:a2 forInterface:sub_100043E8C(*(void *)(*(void *)(a1 + 32) + 64))];
  }

uint64_t sub_1000DFEFC(const __CFDictionary *a1)
{
  uint64_t result = (uint64_t)CFDictionaryGetValue(a1, @"SCAN_CHANNELS");
  if (result)
  {
    uint64_t v2 = (const __CFArray *)result;
    uint64_t result = CFArrayGetCount((CFArrayRef)result);
    if (result)
    {
      uint64_t v3 = result;
      if (result < 1)
      {
        return 1LL;
      }

      else
      {
        CFIndex v4 = 0LL;
        unsigned int valuePtr = -1431655766;
        while (1)
        {
          ValueAtIndex = (const __CFDictionary *)CFArrayGetValueAtIndex(v2, v4);
          CFBooleanRef Value = (const __CFNumber *)CFDictionaryGetValue(ValueAtIndex, @"CHANNEL");
          CFNumberGetValue(Value, kCFNumberSInt32Type, &valuePtr);
          if (valuePtr <= 0x23) {
            break;
          }
          if (v3 == ++v4) {
            return 1LL;
          }
        }

        int v7 = objc_autoreleasePoolPush();
        if (qword_100219F60) {
          [qword_100219F60 WFLog:@"%s: 2GHz Scan request because channel %d is requested ", @"WiFiDeviceManagerIs5GScanRequest", valuePtr];
        }
        objc_autoreleasePoolPop(v7);
        return 0LL;
      }
    }
  }

  return result;
}

uint64_t sub_1000DFFE4(unsigned __int8 *a1, const void *a2, int a3)
{
  BOOL v5 = sub_1000E0174((uint64_t)a1, a2);
  if (sub_1000E01D4(a1))
  {
    uint64_t v6 = objc_autoreleasePoolPush();
    if (qword_100219F60) {
      [qword_100219F60 WFLog:@"%s: Will not queue NDD request - sensitive action on" message:@"WiFiDeviceManagerIsNDDAllowed" v12 v13];
    }
LABEL_16:
    objc_autoreleasePoolPop(v6);
    return 0LL;
  }

  if (sub_1000E0348((uint64_t)a1)
    && (!sub_1000DF3D8((uint64_t)a1) ? (BOOL v7 = v5) : (BOOL v7 = 0), !v7)
    || (!a1[3406] ? (char v8 = 1) : (char v8 = v5), (v8 & 1) == 0 && a3))
  {
    uint64_t v6 = objc_autoreleasePoolPush();
    if (qword_100219F60) {
      [qword_100219F60 WFLog:@"%s: Will not queue NDD request - hosting AWDL session" message:3 v12 v13];
    }
    goto LABEL_16;
  }

  char v10 = !sub_1000E0424((uint64_t)a1) || v5;
  if ((v10 & 1) == 0)
  {
    uint64_t v6 = objc_autoreleasePoolPush();
    if (qword_100219F60) {
      objc_msgSend( (id)qword_100219F60,  "WFLog:message:",  3,  "%s: Will not queue NDD request - MIS discovery state %d MIS Scan Blocked = %d",  "WiFiDeviceManagerIsNDDAllowed",  a1[5213],  a1[5320]);
    }
    goto LABEL_16;
  }

  else {
    char v11 = 1;
  }
  if ((v11 & 1) == 0)
  {
    uint64_t v6 = objc_autoreleasePoolPush();
    if (qword_100219F60) {
      [qword_100219F60 WFLog:@"%s: Will not queue NDD request - autojoin is busy" message:3 v12 v13];
    }
    goto LABEL_16;
  }

  return 1LL;
}

BOOL sub_1000E0174(uint64_t a1, const void *a2)
{
  BOOL result = 0LL;
  if (a1 && a2)
  {
    BOOL v5 = *(const __CFArray **)(a1 + 4928);
    if (v5)
    {
      v6.length = CFArrayGetCount(*(CFArrayRef *)(a1 + 4928));
      v6.location = 0LL;
      return CFArrayContainsValue(v5, v6, a2) != 0;
    }

    else
    {
      return 0LL;
    }
  }

  return result;
}

uint64_t sub_1000E01D4(unsigned __int8 *a1)
{
  if (a1[5496])
  {
    uint64_t v1 = objc_autoreleasePoolPush();
    if (qword_100219F60) {
      [qword_100219F60 WFLog:@"WiFiDeviceManager Link setup - critical phase is ON"];
    }
LABEL_17:
    objc_autoreleasePoolPop(v1);
    return 1LL;
  }

  int v3 = sub_1000D6EA0((uint64_t)a1);
  uint64_t v1 = objc_autoreleasePoolPush();
  if (v3)
  {
    if (qword_100219F60) {
      [qword_100219F60 WFLog:@"WiFiDeviceManager - in autojoin deferral period"];
    }
    goto LABEL_17;
  }

  if (qword_100219F60) {
    [qword_100219F60 WFLog:@"__WiFiDeviceManagerSideKickAsserted: manager->state.sideKickAsserted=%d" message:3, "%s: manager->state.sideKickAsserted=%d", "__WiFiDeviceManagerSideKickAsserted", a1[3260]];
  }
  objc_autoreleasePoolPop(v1);
  int v4 = a1[3260];
  uint64_t v1 = objc_autoreleasePoolPush();
  if (v4)
  {
    if (qword_100219F60) {
      [qword_100219F60 WFLog:@"WiFiDeviceManager sideKick is asserted"];
    }
    goto LABEL_17;
  }

  if (qword_100219F60) {
    [qword_100219F60 WFLog:@"__WiFiDeviceManagerVoiceRelayAsserted" message:3 "%s: manager->state.voiceRelayAsserted=%d",  "__WiFiDeviceManagerVoiceRelayAsserted",  a1[3261]];
  }
  objc_autoreleasePoolPop(v1);
  if (a1[3261])
  {
    uint64_t v1 = objc_autoreleasePoolPush();
    if (qword_100219F60) {
      [qword_100219F60 WFLog:@"WiFiDeviceManager - voice relay is asserted"];
    }
    goto LABEL_17;
  }

  return 0LL;
}

uint64_t sub_1000E0348(uint64_t a1)
{
  if (a1)
  {
    if (!*(_DWORD *)(a1 + 5416)) {
      return 0LL;
    }
    uint64_t v1 = *(void *)(a1 + 64);
    uint64_t v2 = (const void *)sub_100040CF8(v1);
    int v3 = objc_autoreleasePoolPush();
    if (qword_100219F60) {
      [qword_100219F60 WFLog:@"%s: wifid has started AWDL and it is enabled" message:3];
    }
    uint64_t v4 = 1LL;
  }

  else
  {
    int v3 = objc_autoreleasePoolPush();
    if (qword_100219F60) {
      [qword_100219F60 WFLog:@"%s: null manager." message:3];
    }
    uint64_t v4 = 0LL;
  }

  objc_autoreleasePoolPop(v3);
  return v4;
}

uint64_t sub_1000E041C(uint64_t a1)
{
  return *(unsigned __int8 *)(a1 + 3406);
}

BOOL sub_1000E0424(uint64_t a1)
{
  uint64_t v1 = (_BYTE *)(a1 + 5213);
  if (*(_BYTE *)(a1 + 5320))
  {
    if (CFAbsoluteTimeGetCurrent() >= *(double *)(a1 + 5328))
    {
      v1[107] = 0;
    }

    else if (v1[107])
    {
      return 1LL;
    }
  }

  return *v1 != 0;
}

CFIndex sub_1000E0480(CFIndex result)
{
  if (!result) {
    return result;
  }
  CFIndex v1 = result;
  BOOL result = CFArrayGetCount(*(CFArrayRef *)(result + 3520));
  if (!result) {
    return result;
  }
  if (_os_feature_enabled_impl("CoreWiFi", "UnifiedAutoJoin"))
  {
    if ((CWFIsAutoJoinRetryTrigger(*(void *)(v1 + 8832)) & 1) == 0 && *(void *)(v1 + 8824))
    {
      int v2 = *(_DWORD *)(v1 + 3272);
      return v2 != 14 && v2 != 17;
    }

    return 0LL;
  }

  uint64_t v4 = objc_autoreleasePoolPush();
  if (qword_100219F60) {
    [(id)qword_100219F60 WFLog:3, "%s: autojoin is busy %@", "__WiFiDeviceManagerIsAutoJoinBusy", sub_1000BDC98(*(_DWORD *)(v1 + 3272)) message];
  }
  objc_autoreleasePoolPop(v4);
  return 1LL;
}

uint64_t sub_1000E0560( uint64_t a1, const void *a2, const __CFDictionary *a3, const void *a4, uint64_t a5, uint64_t a6)
{
  char v11 = (_BYTE *)(a1 + 5488);
  int v47 = 0;
  BOOL v12 = sub_1000E0174(a1, a4);
  int valuePtr = 0;
  CFBooleanRef Value = (const __CFNumber *)CFDictionaryGetValue(a3, @"SCAN_TYPE");
  if (!Value || (CFNumberGetValue(Value, kCFNumberIntType, &valuePtr), valuePtr != 3))
  {
    if (sub_1000E01D4((unsigned __int8 *)a1))
    {
      uint64_t v14 = objc_autoreleasePoolPush();
      if (qword_100219F60) {
        [qword_100219F60 WFLog:@"%s: Will not queue scan request - sensitive action on" message:@"WiFiDeviceManagerScanAsync"];
      }
LABEL_6:
      CFBooleanRef v15 = v14;
LABEL_7:
      objc_autoreleasePoolPop(v15);
      return 16LL;
    }

    if ((!sub_1000E0348(a1) || (!sub_1000DF3D8(a1) ? (BOOL v17 = v12) : (BOOL v17 = 0), v17))
      && (!*(_BYTE *)(a1 + 3406) ? (char v18 = 1) : (char v18 = v12), (v18 & 1) != 0 || !sub_1000DFEFC(a3)))
    {
      char v21 = !sub_1000E0424(a1) || v12;
      if ((v21 & 1) == 0)
      {
        char v42 = objc_autoreleasePoolPush();
        if (qword_100219F60) {
          objc_msgSend( (id)qword_100219F60,  "WFLog:message:",  3,  "%s: Will not queue scan request - MIS discovery state %d MIS Scan Blocked = %d",  "WiFiDeviceManagerScanAsync",  *(unsigned __int8 *)(a1 + 5213),  *(unsigned __int8 *)(a1 + 5320));
        }
        CFBooleanRef v15 = v42;
        goto LABEL_7;
      }

      else {
        char v22 = 1;
      }
      if ((v22 & 1) == 0)
      {
        uint64_t v14 = objc_autoreleasePoolPush();
        if (qword_100219F60) {
          [qword_100219F60 WFLog:@"%s: Will not queue scan request - autojoin is busy" message:3];
        }
        goto LABEL_6;
      }
    }

    else
    {
      int v19 = v11[1505];
      CFBooleanRef v20 = objc_autoreleasePoolPush();
      if (!v19)
      {
        if (qword_100219F60) {
          objc_msgSend( (id)qword_100219F60,  "WFLog:message:",  3,  "%s: Will not queue scan request - hosting AWDL session and isLPSCSupported=%d",  "WiFiDeviceManagerScanAsync",  v11[1505]);
        }
        CFBooleanRef v15 = v20;
        goto LABEL_7;
      }

      if (qword_100219F60) {
        [qword_100219F60 WFLog:@"%s: Will try to queue scan request on LPSC only" message:3];
      }
      objc_autoreleasePoolPop(v20);
    }
  }

  __int128 v23 = malloc(0x28uLL);
  if (v23)
  {
    uint64_t v24 = (uint64_t)v23;
    void *v23 = a1;
    v23[1] = a5;
    int v25 = (const __CFString *)CFDictionaryGetValue(a3, @"ScanReqClientName");
    *(void *)(v24 + 16) = v25;
    *(void *)(v24 + 24) = a6;
    if (CFDictionaryContainsKey(a3, @"SSID_STR")) {
      BOOL v26 = 1;
    }
    else {
      BOOL v26 = CFDictionaryContainsKey(a3, @"SCAN_SSID_LIST") != 0;
    }
    *(_BYTE *)(v24 + 32) = v26;
    if (*v11)
    {
      uint64_t v27 = (const __CFNumber *)CFDictionaryGetValue(a3, @"SCAN_DWELL_TIME");
      if (v27)
      {
        int v45 = 0;
        CFNumberGetValue(v27, kCFNumberSInt32Type, &v45);
        if (v45 >= 41)
        {
          int v28 = objc_autoreleasePoolPush();
          if (qword_100219F60) {
            [qword_100219F60 WFLog:@"%s: Reducing dwell time from %d to %d" message:@"WiFiDeviceManagerScanAsync" v45:40];
          }
          objc_autoreleasePoolPop(v28);
          int v45 = 40;
          CFNumberRef v29 = CFNumberCreate(kCFAllocatorDefault, kCFNumberSInt32Type, &v45);
          if (v29)
          {
            CFNumberRef v30 = v29;
            CFDictionaryReplaceValue(a3, @"SCAN_DWELL_TIME", v29);
            CFRelease(v30);
          }
        }
      }
    }

    if (v25) {
      BOOL v31 = v12;
    }
    else {
      BOOL v31 = 0;
    }
    if (v31)
    {
      int v45 = 0;
      uint64_t v32 = (const __CFNumber *)CFDictionaryGetValue(a3, @"SCAN_LOW_PRIORITY");
      if (v32) {
        CFNumberGetValue(v32, kCFNumberSInt32Type, &v45);
      }
      if (!v45)
      {
        CFDictionarySetValue(a3, @"SCAN_LOW_LATENCY", kCFBooleanTrue);
        __int128 v33 = objc_autoreleasePoolPush();
        if (qword_100219F60) {
          [(id)qword_100219F60 WFLog:3, "%s: Setting low latency to true for interactive client %@", "WiFiDeviceManagerScanAsync", v25 message];
        }
        objc_autoreleasePoolPop(v33);
        if (CFStringCompare(v25, @"mobilewifitool", 0LL) == kCFCompareEqualTo && valuePtr == 9)
        {
          __int128 v34 = objc_autoreleasePoolPush();
          if (qword_100219F60) {
            [qword_100219F60 WFLog:@"This is normal priority, low latency mobilewifitool client with low power scan type"];
          }
          objc_autoreleasePoolPop(v34);
        }
      }
    }

    if (*(int *)(a1 + 6200) <= -75)
    {
      BOOL v35 = (const __CFNumber *)CFDictionaryGetValue(a3, @"SCAN_LOW_LATENCY");
      if (v35) {
        CFNumberGetValue(v35, kCFNumberSInt32Type, &v47);
      }
      int v45 = 0;
      __int128 v36 = (const __CFNumber *)CFDictionaryGetValue(a3, @"SCAN_LOW_PRIORITY");
      if (v36)
      {
        CFNumberGetValue(v36, kCFNumberSInt32Type, &v45);
        BOOL v37 = v45 != 0;
      }

      else
      {
        BOOL v37 = 0;
      }

      if (!v47 && !v37)
      {
        dispatch_time_t v38 = objc_autoreleasePoolPush();
        if (qword_100219F60) {
          objc_msgSend( (id)qword_100219F60,  "WFLog:message:",  3,  "currentRssi(=%d) <= threshold(=%d), lowering scan priority \n",  *(unsigned int *)(a1 + 6200),  4294967221);
        }
        objc_autoreleasePoolPop(v38);
        CFDictionarySetValue(a3, @"SCAN_LOW_PRIORITY", kCFBooleanTrue);
        CFDictionarySetValue(a3, @"SCAN_PRIO_OVERRIDE", kCFBooleanTrue);
      }
    }

    if (v25)
    {
      if (CFStringCompare(v25, @"Preferences", 0LL) == kCFCompareEqualTo) {
        CFDictionarySetValue(a3, @"SCAN_INC_BSS_LIST", kCFBooleanTrue);
      }
      if (CFStringCompare(v25, @"HPSetup", 0LL) == kCFCompareEqualTo)
      {
        __int128 v39 = objc_autoreleasePoolPush();
        if (qword_100219F60) {
          [(id)qword_100219F60 WFLog:3, "%s: prioritizing scan request from client %@", "WiFiDeviceManagerScanAsync", v25 message];
        }
        objc_autoreleasePoolPop(v39);
        sub_100051010(*(void *)(a1 + 64));
      }
    }

    int v40 = *(void (**)(uint64_t, const void *, void, uint64_t, const __CFDictionary *))(a1 + 4384);
    if (v40) {
      v40(a1, a2, *(void *)(a1 + 4392), 4LL, a3);
    }
    uint64_t v41 = 14LL;
    if (*(void *)(a1 + 7320) && v25)
    {
      if (CFEqual(v25, @"Preferences"))
      {
        uint64_t v41 = 8LL;
      }

      else if (CFEqual(v25, @"SpringBoard"))
      {
        uint64_t v41 = 10LL;
      }

      else if (CFEqual(v25, @"WiFiPickerExtens"))
      {
        uint64_t v41 = 9LL;
      }

      else if (CFEqual(v25, @"locationd"))
      {
        uint64_t v41 = 16LL;
      }

      else if (CFEqual(v25, @"pipelined"))
      {
        uint64_t v41 = 17LL;
      }

      else if (CFEqual(v25, @"homed"))
      {
        uint64_t v41 = 12LL;
      }

      else if (CFEqual(v25, @"configd"))
      {
        uint64_t v41 = 13LL;
      }

      else if (CFEqual(v25, @"milod"))
      {
        uint64_t v41 = 26LL;
      }

      else
      {
        uint64_t v41 = 14LL;
      }
    }

    uint64_t v16 = sub_1000E0CC4(a1, a2, a3, 0LL, (uint64_t)sub_1000E0D80, v24, 0LL, v41);
    if ((_DWORD)v16) {
      free((void *)v24);
    }
  }

  else
  {
    char v44 = objc_autoreleasePoolPush();
    if (qword_100219F60) {
      [qword_100219F60 WFLog:@"%s: null scanData" message:4];
    }
    objc_autoreleasePoolPop(v44);
    return 12LL;
  }

  return v16;
}

uint64_t sub_1000E0CC4( uint64_t a1, const void *a2, const void *a3, uint64_t a4, uint64_t a5, uint64_t a6, void *a7, uint64_t a8)
{
  uint64_t v11 = sub_10004DBA0(*(void *)(a1 + 64), a2, a3, a4, a5, a6, a7);
  if ((_DWORD)v11)
  {
    uint64_t v14 = objc_autoreleasePoolPush();
    if (qword_100219F60) {
      objc_msgSend((id)qword_100219F60, "WFLog:message:", 4, "Error initiating scan request: %d", v11);
    }
    objc_autoreleasePoolPop(v14);
  }

  else
  {
    BOOL v12 = *(void **)(a1 + 7320);
    if (v12) {
      [v12 setScanningState:1 client:a8 neighborBSS:0 otherBSS:0 withChannelInfoList:0 withRequest:a3 forInterface:sub_100043E8C(*(void *)(a1 + 64))];
    }
  }

  return v11;
}

void sub_1000E0D80(uint64_t a1, uint64_t a2, const __CFArray *a3, uint64_t a4, uint64_t a5, void *a6)
{
  char v10 = objc_autoreleasePoolPush();
  uint64_t v11 = (void *)os_transaction_create("com.apple.wifid.WiFiDeviceManagerClientScanCallback");
  if (a6)
  {
    uint64_t v12 = *(void *)a6;
    uint64_t v13 = (const __CFString *)*((void *)a6 + 2);
    if (v13 && CFStringCompare(v13, @"HPSetup", 0LL) == kCFCompareEqualTo)
    {
      if (a3 && CFArrayGetCount(a3))
      {
        BOOL v17 = objc_autoreleasePoolPush();
        if (qword_100219F60) {
          [(id)qword_100219F60 WFLog:3, "%s:scan result(%d) for request from %@ error (%d)", "WiFiDeviceManagerClientScanCallback", CFArrayGetCount(a3), *((void *)a6 + 2), a5 message];
        }
        objc_autoreleasePoolPop(v17);
      }

      else
      {
        char v18 = "Directed";
        if (!*((_BYTE *)a6 + 32)) {
          char v18 = "Regular";
        }
        CFNumberRef v29 = +[NSString stringWithFormat:]( &OBJC_CLASS___NSString,  "stringWithFormat:",  @"%s Scan from %@ failed_%d",  v18,  *((void *)a6 + 2),  a5);
        int v19 = *(const __CFDate **)(v12 + 152);
        CFAbsoluteTime Current = CFAbsoluteTimeGetCurrent();
        char v21 = CFDateCreate(kCFAllocatorDefault, Current);
        char v22 = v21;
        double TimeIntervalSinceDate = 0.0;
        if (v19 && v21) {
          double TimeIntervalSinceDate = CFDateGetTimeIntervalSinceDate(v21, v19);
        }
        uint64_t v24 = objc_autoreleasePoolPush();
        if (qword_100219F60) {
          [(id)qword_100219F60 WFLog:3, "%s: No scan result for request from %@ error (%d), timeSincelastCCForScan (%f) startedDateTime(%@)", "WiFiDeviceManagerClientScanCallback", *((void *)a6 + 2), a5, *(void *)&TimeIntervalSinceDate, v19 message];
        }
        objc_autoreleasePoolPop(v24);
        if (!v19 || TimeIntervalSinceDate >= 60.0)
        {
          int v25 = objc_autoreleasePoolPush();
          if (qword_100219F60) {
            [(id)qword_100219F60 WFLog:3, "Triggering corecapture for {%@}", v29 message];
          }
          objc_autoreleasePoolPop(v25);
          sub_1000C553C(v12, v29);
          BOOL v26 = *(const void **)(v12 + 152);
          if (v26)
          {
            CFRelease(v26);
            *(void *)(v12 + 152) = 0LL;
          }

          CFAbsoluteTime v27 = CFAbsoluteTimeGetCurrent();
          *(void *)(v12 + 152) = CFDateCreate(kCFAllocatorDefault, v27);
        }

        if (v22) {
          CFRelease(v22);
        }
      }
    }

    if ((_DWORD)a5 == -536870165 && *(_DWORD *)(v12 + 5512) == 1)
    {
      uint64_t v14 = objc_autoreleasePoolPush();
      if (qword_100219F60) {
        [qword_100219F60 WFLog:@"%s: converting error to EBUSY" message:3];
      }
      objc_autoreleasePoolPop(v14);
      *(_BYTE *)(v12 + 72_Block_object_dispose((const void *)(v15 - 112), 8) = 1;
      a5 = 16LL;
    }

    CFBooleanRef v15 = (void (*)(uint64_t, uint64_t, const __CFArray *, uint64_t, void))*((void *)a6 + 1);
    if (v15) {
      v15(v12, a2, a3, a5, *((void *)a6 + 3));
    }
    uint64_t v16 = *(void (**)(uint64_t, uint64_t, void, uint64_t, void))(v12 + 4384);
    if (v16) {
      v16(v12, a2, *(void *)(v12 + 4392), 5LL, 0LL);
    }
    free(a6);
    if (v11) {
LABEL_14:
    }
  }

  else
  {
    int v28 = objc_autoreleasePoolPush();
    if (qword_100219F60) {
      [qword_100219F60 WFLog:@"%s: null scanData" message:4];
    }
    objc_autoreleasePoolPop(v28);
    if (v11) {
      goto LABEL_14;
    }
  }

  objc_autoreleasePoolPop(v10);
}

uint64_t sub_1000E10D0(uint64_t a1, __CFArray *a2)
{
  uint64_t v3 = *(void *)(a1 + 64);
  uint64_t v4 = (const void *)sub_100043E8C(v3);
  return sub_100044EB0(v3, v4, a2);
}

uint64_t sub_1000E1104( uint64_t a1, const void *a2, void *a3, const void *a4, const __CFString *a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  if (!a1)
  {
    int v19 = objc_autoreleasePoolPush();
    if (qword_100219F60) {
      [(id)qword_100219F60 WFLog:4, "%s: failed to join %@, null manager", "WiFiDeviceManagerAssociateAsync", sub_100095BC8(a3) message];
    }
    objc_autoreleasePoolPop(v19);
    return 4294963396LL;
  }

  BOOL v152 = a8 != 1018;
  sub_1000E2DE8(a3);
  dword_100219FA4 = 0;
  uint64_t v153 = a8;
  CFTypeRef cf = a2;
  CFRange v148 = a5;
  CFRange v149 = a4;
  switch((int)a8)
  {
    case 1008:
      dword_100219FA4 = 0x80000;
      int v14 = 1;
      if (CFStringCompare(a5, @"Preferences", 1uLL))
      {
        if (CFStringCompare(a5, @"homed", 1uLL))
        {
          int v15 = 1;
          if (CFStringCompare(a5, @"SpringBoard", 1uLL))
          {
            int v16 = 1;
            if (CFStringCompare(a5, @"WiFiPickerExtens", 1uLL))
            {
              if (CFStringCompare(a5, @"HPSetup", 1uLL) && CFStringCompare(a5, @"Setup", 1uLL))
              {
                CFComparisonResult v17 = CFStringCompare(a5, @"sharingd", 1uLL);
                int v14 = 0;
                int v15 = 0;
                int v16 = 0;
                uint64_t v18 = 8LL;
                if (v17 == kCFCompareEqualTo) {
                  uint64_t v18 = 14LL;
                }
              }

              else
              {
                int v14 = 0;
                int v15 = 0;
                int v16 = 0;
                uint64_t v18 = 13LL;
              }
            }

            else
            {
              int v14 = 0;
              int v15 = 0;
              uint64_t v18 = 3LL;
            }
          }

          else
          {
            int v14 = 0;
            int v16 = 0;
            uint64_t v18 = 7LL;
          }
        }

        else
        {
          int v14 = 0;
          int v15 = 0;
          int v16 = 0;
          uint64_t v18 = 6LL;
        }
      }

      else
      {
        int v15 = 0;
        int v16 = 0;
        uint64_t v18 = 2LL;
      }

      goto LABEL_26;
    case 1011:
      int v14 = 0;
      int v15 = 0;
      int v16 = 0;
      dword_100219FA4 = 0x40000;
      uint64_t v18 = 5LL;
      goto LABEL_26;
    case 1013:
      int v14 = 0;
      int v15 = 0;
      int v16 = 0;
      dword_100219FA4 = 0x20000;
      uint64_t v18 = 9LL;
      goto LABEL_26;
    case 1016:
      int v14 = 0;
      int v15 = 0;
      int v16 = 0;
      dword_100219FA4 = 0x800000;
      uint64_t v18 = 4LL;
      goto LABEL_26;
    default:
      if ((_DWORD)a8 == 1018)
      {
        int v14 = 0;
        int v15 = 0;
        int v16 = 0;
        dword_100219FA4 = 0x400000;
        uint64_t v18 = 10LL;
LABEL_26:
        uint64_t v147 = v18;
      }

      else
      {
        int v14 = 0;
        int v15 = 0;
        int v16 = 0;
        uint64_t v147 = 0LL;
        dword_100219FA4 = 0x100000;
      }

      if (!a3) {
        goto LABEL_47;
      }
      char v21 = *(const __CFArray **)(a1 + 5576);
      if (!v21) {
        goto LABEL_47;
      }
      CFIndex Count = CFArrayGetCount(v21);
      if (!Count) {
        goto LABEL_47;
      }
      uint64_t v23 = Count;
      uint64_t v24 = (const __CFString *)sub_1000951FC((uint64_t)a3, @"PolicyUUID");
      if (v23 < 1) {
        goto LABEL_40;
      }
      int v25 = v24;
      CFIndex v26 = 0LL;
      int v27 = 1;
      break;
  }

  while (1)
  {
    ValueAtIndex = CFArrayGetValueAtIndex(*(CFArrayRef *)(a1 + 5576), v26);
    if (!ValueAtIndex) {
      goto LABEL_38;
    }
    uint64_t v29 = (uint64_t)ValueAtIndex;
    if (!v25) {
      break;
    }
    CFNumberRef v30 = (const __CFString *)sub_100012B90(v29);
    if (CFStringCompare(v25, v30, 0LL) == kCFCompareEqualTo && !sub_10009EFD8((uint64_t)a3))
    {
LABEL_40:
      int v27 = 1;
      goto LABEL_42;
    }

    int v27 = 0;
LABEL_38:
    if (v23 == ++v26) {
      goto LABEL_42;
    }
  }

  int v27 = 0;
LABEL_42:
  BOOL v31 = objc_autoreleasePoolPush();
  uint64_t v32 = (void *)qword_100219F60;
  if (qword_100219F60)
  {
    __int128 v33 = sub_100095BC8(a3);
    __int128 v34 = "";
    if (!v27) {
      __int128 v34 = "NOT ";
    }
    [v32 WFLog:3, "%s: network %@ is %scompliant with the active policies!", "__WiFiDeviceManagerIsNetworkPolicyCompliant", v33, v34 message];
  }

  objc_autoreleasePoolPop(v31);
  if (!v27)
  {
    if (*(void *)(a1 + 240))
    {
      CFRetain(cf);
      CFRetain((CFTypeRef)a1);
      int v45 = *(dispatch_queue_s **)(a1 + 240);
      block[0] = _NSConcreteStackBlock;
      block[1] = 3221225472LL;
      block[2] = sub_1000E3114;
      block[3] = &unk_1001E4BF0;
      void block[4] = a1;
      void block[5] = cf;
      void block[6] = a6;
      void block[7] = a7;
      dispatch_async(v45, block);
    }

    else
    {
      CFBooleanRef v60 = objc_autoreleasePoolPush();
      if (qword_100219F60) {
        [qword_100219F60 WFLog:@"%s: null queue." message:4];
      }
      objc_autoreleasePoolPop(v60);
    }

    return 4294963366LL;
  }

LABEL_47:
  BOOL v35 = objc_autoreleasePoolPush();
  id v36 = sub_1000A335C((uint64_t)a3);
  if ([*(id *)(a1 + 6632) isNetworkInDenyListedState:1 scanResult:v36])
  {
    id v37 = [*(id *)(a1 + 6632) reasonsForNetworkInDenyListedState:v36 state:1 timestamps:0 reasonData:0];
    if (v37)
    {
      dispatch_time_t v38 = v37;
      if ([v37 count])
      {
        unsigned int v39 = [[v38 objectAtIndex:0] unsignedIntegerValue];
        dword_100219FA4 |= v39;
        ++*(_WORD *)(a1 + 6016);
        uint64_t v40 = v147;
        if (v14 | v15 | v16) {
          uint64_t v40 = 11LL;
        }
        uint64_t v147 = v40;
      }
    }
  }

  objc_autoreleasePoolPop(v35);
  uint64_t v41 = sub_1000DEA34(a1, cf, 1);
  char v42 = objc_autoreleasePoolPush();
  unsigned __int8 v43 = (void *)qword_100219F60;
  if (qword_100219F60)
  {
    if (v41) {
      char v44 = sub_100095BC8(v41);
    }
    else {
      char v44 = 0LL;
    }
    uint64_t v46 = sub_100095BC8(a3);
    [v43 WFLog:3, "%s: current %@, assoc %@, reason %@(%d)", "WiFiDeviceManagerAssociateAsync", v44, v46, sub_10003B050(v153), v153 message];
  }

  objc_autoreleasePoolPop(v42);
  if (*(_DWORD *)(a1 + 3272) != 14)
  {
    char v47 = _os_feature_enabled_impl("CoreWiFi", "UnifiedAutoJoin");
    if ((_DWORD)v153 != 1018 || (v47 & 1) == 0) {
      sub_1000D0428(a1);
    }
  }

  if (!*(_BYTE *)(a1 + 3457) || !v41)
  {
    if (v41) {
      goto LABEL_72;
    }
    BOOL v55 = 0;
    BOOL v56 = v153 == 1008;
    goto LABEL_96;
  }

  uint64_t v48 = sub_100095BC8(v41);
  unsigned int v49 = sub_100095BC8(a3);
  if (CFEqual(v48, v49))
  {
    CFIndex v50 = (const __CFBoolean *)sub_1000951FC((uint64_t)a3, @"JOINING_FROM_UI");
    if ((_DWORD)v153 == 1008 || v50 == kCFBooleanTrue)
    {
      *(void *)&__int128 v159 = 0LL;
      *((void *)&v159 + 1) = &v159;
      *(void *)&__int128 v160 = 0x2020000000LL;
      *((void *)&v160 + 1) = 0xAAAAAAAAAAAAAAAALL;
      if (cf) {
        CFTypeRef v51 = CFRetain(cf);
      }
      else {
        CFTypeRef v51 = 0LL;
      }
      *((void *)&v160 + 1) = v51;
      uint64_t v174 = 0LL;
      unsigned int v175 = &v174;
      uint64_t v176 = 0x2020000000LL;
      v177 = (void *)0xAAAAAAAAAAAAAAAALL;
      v177 = (void *)CFRetain(v41);
      unsigned int v92 = objc_autoreleasePoolPush();
      if (qword_100219F60) {
        [(id)qword_100219F60 WFLog:3, "%s: user preferred cellular-outranked WiFi: %@", "WiFiDeviceManagerAssociateAsync", sub_100095BC8(a3) message];
      }
      objc_autoreleasePoolPop(v92);
      [*(id *)(a1 + 7320) addFaultEvent:20 forInterface:cf];
      sub_1000552E8(*(void *)(a1 + 64), *(void *)(*((void *)&v159 + 1) + 24LL), 1LL);
      if (*(void *)(a1 + 240))
      {
        CFRetain((CFTypeRef)a1);
        if (cf) {
          CFRetain(cf);
        }
        BOOL v93 = *(dispatch_queue_s **)(a1 + 240);
        v173[0] = _NSConcreteStackBlock;
        v173[1] = 3221225472LL;
        v173[2] = sub_1000E3170;
        v173[3] = &unk_1001E4C18;
        v173[4] = &v174;
        v173[5] = &v159;
        v173[6] = a1;
        v173[7] = a6;
        v173[8] = a7;
        dispatch_async(v93, v173);
      }

      else
      {
        double v94 = objc_autoreleasePoolPush();
        if (qword_100219F60) {
          [qword_100219F60 WFLog:@"%s: null queue." message:4];
        }
        objc_autoreleasePoolPop(v94);
      }

      uint64_t v95 = v175[3];
      if (v95 && *(void *)(*((void *)&v159 + 1) + 24LL) && *(void *)(a1 + 4096))
      {
        sub_10009582C(v95, @"WiFiNetworkIsAutoJoined", kCFBooleanFalse);
        sub_10009A194((const void *)v175[3], 1, +[NSDate date](&OBJC_CLASS___NSDate, "date"));
        if (*(void *)(a1 + 240))
        {
          CFRetain((CFTypeRef)a1);
          CFRetain((CFTypeRef)v175[3]);
          unsigned int v96 = *(const void **)(*((void *)&v159 + 1) + 24LL);
          if (v96) {
            CFRetain(v96);
          }
          uint64_t v97 = *(dispatch_queue_s **)(a1 + 240);
          v172[0] = _NSConcreteStackBlock;
          v172[1] = 3221225472LL;
          v172[2] = sub_1000E31F4;
          v172[3] = &unk_1001E4C40;
          v172[6] = a1;
          v172[4] = &v174;
          v172[5] = &v159;
          dispatch_async(v97, v172);
        }

        else
        {
          CFNumberRef v128 = objc_autoreleasePoolPush();
          if (qword_100219F60) {
            [qword_100219F60 WFLog:@"%s: null queue." message:@"WiFiDeviceManagerAssociateAsync"];
          }
          objc_autoreleasePoolPop(v128);
        }
      }

      uint64_t v129 = (const void *)v175[3];
      if (v129) {
        CFRelease(v129);
      }
      unsigned __int8 v130 = *(const void **)(*((void *)&v159 + 1) + 24LL);
      if (v130) {
        CFRelease(v130);
      }
      _Block_object_dispose(&v174, 8);
      _Block_object_dispose(&v159, 8);
      return 0LL;
    }
  }

      if (v16 == ++v17) {
        goto LABEL_13;
      }
    }
  }

  CFBooleanRef v61 = objc_autoreleasePoolPush();
  if (qword_100219F60) {
    [qword_100219F60 WFLog:@"__WiFiDeviceManagerPrepareCandidates: no scan candidate network"];
  }
  objc_autoreleasePoolPop(v61);
  return 0LL;
}

                objc_autoreleasePoolPop(v25);
LABEL_48:
                ;
              }
            }
          }

          else
          {
            __int128 v34 = objc_autoreleasePoolPush();
            if (qword_100219F60) {
              [(id)qword_100219F60 WFLog:3, "%s: provisioned HS2.0 account %@ has no credentials.", "__WiFiDeviceManagerSetHS20HomeOperatorNetwork", sub_100095BC8(v54) message];
            }
            objc_autoreleasePoolPop(v34);
          }
        }
      }

      int v16 = v53 + 1;
      int v15 = cf;
    }

    while (v53 + 1 != v52);
  }

  CFRange v6 = v49;
  uint64_t v4 = v50;
  a1 = v48;
  if (v15) {
    CFRelease(v15);
  }
LABEL_56:
  BOOL v35 = CFArrayCreateMutableCopy(kCFAllocatorDefault, 0LL, *(CFArrayRef *)(a1 + 3616));
  if (CFArrayGetCount(*(CFArrayRef *)(a1 + 3624)))
  {
    id v36 = *(const __CFArray **)(a1 + 3624);
    v58.length = CFArrayGetCount(v36);
    v58.location = 0LL;
    CFArrayAppendArray(v35, v36, v58);
  }

  if (v4 < 1)
  {
LABEL_71:
    if (!v35) {
      return;
    }
    goto LABEL_72;
  }

  id v37 = 0LL;
  while (1)
  {
    dispatch_time_t v38 = CFArrayGetValueAtIndex(theArray, v37);
    if (v38)
    {
      unsigned int v39 = v38;
    }

  objc_autoreleasePoolPop(v6);
}

LABEL_103:
      if (*(void *)(a1 + 7320))
      {
        v158[0] = _NSConcreteStackBlock;
        v158[1] = 3221225472LL;
        v158[2] = sub_1000E334C;
        v158[3] = &unk_1001E4B88;
        v158[4] = a1;
        sub_1000D8E24(a1, (const __CFDictionary **)v41, (uint64_t)v158);
      }

      char v63 = 0;
      char v62 = 1;
LABEL_106:
      if ((_DWORD)v153 == 1018)
      {
        if ((v63 & 1) == 0) {
          goto LABEL_110;
        }
      }

      else
      {
        ++*(_DWORD *)(a1 + 3472);
        id v65 = objc_autoreleasePoolPush();
        if (qword_100219F60) {
          [qword_100219F60 WFLog:@"%s: did increment user join counter (%d)", @"WiFiDeviceManagerAssociateAsync", *(unsigned int *)(a1 + 3472)];
        }
        objc_autoreleasePoolPop(v65);
        if ((v63 & 1) == 0)
        {
LABEL_110:
          sub_10004EC50(*(void *)(a1 + 64), cf, 0, 1008);
          if (!a3) {
            goto LABEL_116;
          }
          goto LABEL_114;
        }
      }

      if (!a3) {
        goto LABEL_116;
      }
LABEL_114:
      if (v41)
      {
        CFNumberRef v66 = sub_100095BC8(v41);
        CFNumberRef v67 = sub_100095BC8(a3);
        if (!CFEqual(v66, v67))
        {
          if (*(void *)(a1 + 4736))
          {
            if (*(void *)(a1 + 240))
            {
              *(void *)&__int128 v159 = 0LL;
              *((void *)&v159 + 1) = &v159;
              __int128 v160 = 0x2020000000uLL;
              uint64_t v174 = 0LL;
              unsigned int v175 = &v174;
              uint64_t v176 = 0x2020000000LL;
              v177 = (void *)0xAAAAAAAAAAAAAAAALL;
              CFAbsoluteTime Current = CFAbsoluteTimeGetCurrent();
              v177 = CFDateCreate(kCFAllocatorDefault, Current);
              CFTypeRef v90 = CFRetain(v41);
              *(void *)(*((void *)&v159 + 1) + 24LL) = v90;
              CFRetain((CFTypeRef)a1);
              unsigned int v91 = *(dispatch_queue_s **)(a1 + 240);
              v157[0] = _NSConcreteStackBlock;
              v157[1] = 3221225472LL;
              v157[2] = sub_1000E33AC;
              v157[3] = &unk_1001E4C40;
              v157[4] = &v159;
              v157[5] = &v174;
              v157[6] = a1;
              dispatch_async(v91, v157);
              _Block_object_dispose(&v174, 8);
              _Block_object_dispose(&v159, 8);
            }

            else
            {
              CFIndex v124 = objc_autoreleasePoolPush();
              if (qword_100219F60) {
                [qword_100219F60 WFLog:@"%s: null queue." message:@"WiFiDeviceManagerAssociateAsync"];
              }
              objc_autoreleasePoolPop(v124);
            }
          }
        }
      }

        CFRange v72 = *(const __CFDictionary **)(a1 + 32);
        if (v72)
        {
          if (*(_BYTE *)(a1 + 57)) {
            double v73 = 120;
          }
          else {
            double v73 = 18000;
          }
          if (*(_BYTE *)(a1 + 57)) {
            unsigned int v74 = 5;
          }
          else {
            unsigned int v74 = 60;
          }
          if ((_DWORD)a4 != 2) {
            double v73 = v74;
          }
          if (sub_100134EA0(v72) + *(double *)(a1 + 48) > (double)v73)
          {
            CFNumberRef v75 = *(const __CFDictionary **)(a1 + 32);
            if (v75)
            {
              if (CFDictionaryGetValue(v75, @"atjHistTblEntUserPromptPending") == kCFBooleanTrue)
              {
                id v76 = objc_autoreleasePoolPush();
                if (qword_100219F60) {
                  objc_msgSend((id)qword_100219F60, "WFLog:message:", 3, "ATJManager: prompt user for action=%d", a4);
                }
                objc_autoreleasePoolPop(v76);
                a2 = 1LL;
              }
            }
          }
        }

        goto LABEL_118;
      }

LABEL_116:
      char context = v62;
      unsigned int v68 = malloc(0x30uLL);
      uint64_t v69 = (uint64_t)v68;
      v68[4] = 0LL;
      void v68[5] = 0LL;
      *unsigned int v68 = a1;
      v68[1] = a6;
      v68[2] = a7;
      v68[3] = 0LL;
      *((_DWORD *)v68 + _Block_object_dispose((const void *)(v15 - 112), 8) = v153;
      *((_DWORD *)v68 + 9) = v152;
      if (v55)
      {
        v68[3] = v41;
        CFRetain(v41);
      }

      unsigned int v70 = *(void (**)(uint64_t, CFTypeRef, void *, void, void, void))(a1 + 3880);
      if (v70) {
        v70(a1, cf, a3, 0LL, 0LL, *(void *)(a1 + 3888));
      }
      int v71 = objc_autoreleasePoolPush();
      [*(id *)(a1 + 6608) asyncTrackNetworksOfInterest:1];
      objc_autoreleasePoolPop(v71);
      sub_1000D3E0C(a1);
      if (a3)
      {
        CFRange v72 = objc_autoreleasePoolPush();
        if (!v148)
        {
          if (qword_100219F60) {
            [qword_100219F60 WFLog:@"%s: client is NULL!"];
          }
          goto LABEL_137;
        }

        if (qword_100219F60) {
          [(id)qword_100219F60 WFLog:3, "%s: Association client is %@", "__WiFiDeviceManagerIsNetworkAutoJoinDelayed", v148 message];
        }
        objc_autoreleasePoolPop(v72);
        if (CFStringCompare(v148, @"Preferences", 0LL)) {
          goto LABEL_142;
        }
        if (!*(_BYTE *)(a1 + 5211)
          && !*(_DWORD *)(a1 + 5336)
          && *(unsigned __int8 *)(a1 + 5353) == -*(_BYTE *)(a1 + 5352)
          || *(_BYTE *)(a1 + 7008) && sub_1000DCBFC(a1, 1LL))
        {
          double v73 = CFAbsoluteTimeGetCurrent();
          unsigned int v74 = *(_DWORD *)(a1 + 3344);
          if (v74 <= 6 && ((1 << v74) & 0x58) != 0)
          {
            CFRange v72 = objc_autoreleasePoolPush();
            CFNumberRef v75 = (void *)qword_100219F60;
            if (qword_100219F60)
            {
              int v143 = (void *)sub_10008FDAC(*(_DWORD *)(a1 + 3344));
              id v76 = "%s: Device in motion (%@). Suppressing autojoin delayed alert.";
LABEL_136:
              objc_msgSend(v75, "WFLog:message:", 3, v76, "__WiFiDeviceManagerIsNetworkAutoJoinDelayed", v143);
            }
          }

          else
          {
            v179.length = CFArrayGetCount(*(CFArrayRef *)(a1 + 3520));
            v179.location = 0LL;
            FirstIndexOfCFBooleanRef Value = CFArrayGetFirstIndexOfValue(*(CFArrayRef *)(a1 + 3520), v179, a3);
            if (FirstIndexOfValue == -1)
            {
              v180.length = CFArrayGetCount(*(CFArrayRef *)(a1 + 3528));
              v180.location = 0LL;
              CFIndex v132 = CFArrayGetFirstIndexOfValue(*(CFArrayRef *)(a1 + 3528), v180, a3);
              if (v132 == -1) {
                goto LABEL_142;
              }
              CFIndex v126 = v132;
              BOOL v127 = (CFArrayRef *)(a1 + 3528);
            }

            else
            {
              CFIndex v126 = FirstIndexOfValue;
              BOOL v127 = (CFArrayRef *)(a1 + 3520);
            }

            int v133 = (void *)CFArrayGetValueAtIndex(*v127, v126);
            if (!v133) {
              goto LABEL_142;
            }
            int v134 = v133;
            sub_100095F10((uint64_t)v133, (uint64_t)a3);
            if (!sub_10009A128((uint64_t)v134))
            {
              dword_100219FA4 |= 0x10000u;
              goto LABEL_142;
            }

            if (sub_100097700((uint64_t)v134)
              || !sub_1000974EC((uint64_t)v134)
              || sub_1000951FC((uint64_t)v134, @"HotspotDeviceIdentifier"))
            {
              CFRange v72 = objc_autoreleasePoolPush();
              CFNumberRef v75 = (void *)qword_100219F60;
              if (!qword_100219F60) {
                goto LABEL_137;
              }
              int v143 = (void *)sub_100095BC8(v134);
              id v76 = "%s: not considering personal hotspot network %@ for delayed auto-join";
              goto LABEL_136;
            }

            if (sub_1000971F8(v134))
            {
              CFRange v72 = objc_autoreleasePoolPush();
              CFNumberRef v75 = (void *)qword_100219F60;
              if (!qword_100219F60) {
                goto LABEL_137;
              }
              int v143 = (void *)sub_100095BC8(v134);
              id v76 = "%s: not considering hidden network %@ for delayed auto-join";
              goto LABEL_136;
            }

            if (!sub_10009CF04((uint64_t)v134))
            {
              int v135 = sub_1000FC698(a1, v134, 0);
              CFNumberRef v136 = objc_autoreleasePoolPush();
              if (v135)
              {
                id v137 = sub_1000A335C((uint64_t)a3);
                if ([*(id *)(a1 + 6632) isNetworkDenyListedForAutoJoinDueToTrigDisc:v137 RSSI:0 timestamp:0])
                {
                  CFIndex v138 = objc_autoreleasePoolPush();
                  if (qword_100219F60) {
                    [qword_100219F60 WFLog:@"%s: joining weak/trigger-disconnected network at %d, not considering for slow auto-join" message:3 sub_100096BF4((uint64_t)a3, @"RSSI")];
                  }
                }

                else
                {
                  if (![*(id *)(a1 + 3648) canDeferNetwork:v134 withUsageRank:sub_10009F85C((uint64_t)v134) andMotionState:*(unsigned int *)(a1 + 3344)])
                  {
                    objc_autoreleasePoolPop(v136);

                    if (!v41)
                    {
                      dword_100219FA4 |= 0x200000u;
                      if (*(void *)(a1 + 240))
                      {
                        CFRetain((CFTypeRef)a1);
                        uint64_t v139 = *(dispatch_queue_s **)(a1 + 240);
                        v156[0] = _NSConcreteStackBlock;
                        v156[1] = 3221225472LL;
                        v156[2] = sub_1000E3488;
                        v156[3] = &unk_1001E2620;
                        v156[4] = a1;
                        dispatch_async(v139, v156);
                      }

                      else
                      {
                        unsigned int v140 = objc_autoreleasePoolPush();
                        if (qword_100219F60) {
                          [qword_100219F60 WFLog:@"%s: null queue." message:@"WiFiDeviceManagerAssociateAsync"];
                        }
                        objc_autoreleasePoolPop(v140);
                      }

                      unsigned int v141 = *(void **)(a1 + 7320);
                      if (v141) {
                        [v141 addFaultEvent:12 forInterface:sub_10004CE2C(*(void *)(a1 + 64))];
                      }
                    }

                    goto LABEL_142;
                  }

                  CFIndex v138 = objc_autoreleasePoolPush();
                  if (qword_100219F60) {
                    [(id)qword_100219F60 WFLog:3, "%s: not considering deferrable network %@ for delayed auto-join", "__WiFiDeviceManagerIsNetworkAutoJoinDelayed", sub_100095BC8(v134) message];
                  }
                }

                objc_autoreleasePoolPop(v138);
                objc_autoreleasePoolPop(v136);

LABEL_142:
                *(_DWORD *)(a1 + 3464) = 0;
                char v79 = (const __CFNumber *)sub_1000951FC((uint64_t)a3, @"TransitionDisabledFlags");
                if (v79) {
                  CFNumberGetValue(v79, kCFNumberSInt32Type, (void *)(a1 + 3464));
                }
                uint64_t v80 = sub_1000A063C((CFDictionaryRef *)a3);
                id v81 = sub_1000E359C(a1);
                if (CWFKnownNetworkAssociatedDuringAWDLRealTimeMode(v80, v81))
                {
                  int v82 = objc_autoreleasePoolPush();
                  if (qword_100219F60) {
                    [(id)qword_100219F60 WFLog:3, "%s: Applying APPLE80211_ASSOC_F_PREFER_NON_6GHZ because AWDL real time mode was recently active wh ile associated to this known network (%@)", "WiFiDeviceManagerAssociateAsync", v80 message];
                  }
                  objc_autoreleasePoolPop(v82);
                  unsigned int v83 = sub_100096BF4((uint64_t)a3, @"ASSOC_FLAGS");
                  sub_1000970C0((uint64_t)a3, @"ASSOC_FLAGS", v83 & 0xFFFEFFFF | 0x10000LL);
                }

                if (_os_feature_enabled_impl("CoreWiFi", "WiFi6EStandalone6GHz"))
                {
                  if (sub_100055A54(*(void *)(a1 + 64)))
                  {
                    unsigned int v84 = sub_100096BF4((uint64_t)a3, @"ASSOC_FLAGS");
                    if ((v84 & 0x100000) == 0)
                    {
                      uint64_t v85 = sub_1000539A4(*(void *)(a1 + 64), 0);
                      if (CWFScanResultHas6GHzOnlyBSS(a3, v85, &stru_1001E4C60))
                      {
                        id v86 = objc_autoreleasePoolPush();
                        if (qword_100219F60) {
                          [(id)qword_100219F60 WFLog:3, "%s: Applying APPLE80211_ASSOC_F_6GHZ_ONLY because network has 6GHz-only BSS (%@)", "WiFiDeviceManagerAssociateAsync", a3 message];
                        }
                        objc_autoreleasePoolPop(v86);
                        sub_1000970C0((uint64_t)a3, @"ASSOC_FLAGS", v84 & 0xFFEFFFFF | 0x100000LL);
                        uint64_t v87 = sub_1000A063C((CFDictionaryRef *)a3);
                        [v87 setWas6GHzOnlyAt:[NSDate date]];
                        CFNumberRef v88 = sub_1000A1DEC(v87, 0LL);
                        sub_10009582C((uint64_t)v88, @"Standalone", 0LL);
                        if (v88)
                        {
                          sub_100095524((uint64_t)a3, (uint64_t)v88);
                          CFRelease(v88);
                        }
                      }

                      else if ([v80 wasRecently6GHzOnlyOnAnyDevice])
                      {
                        unsigned int v102 = objc_autoreleasePoolPush();
                        if (qword_100219F60) {
                          [(id)qword_100219F60 WFLog:3, "%s: Applying APPLE80211_ASSOC_F_6GHZ_ONLY because known network was recently determined to b e 6GHz-only (%@)", "WiFiDeviceManagerAssociateAsync", a3 message];
                        }
                        objc_autoreleasePoolPop(v102);
                        sub_1000970C0((uint64_t)a3, @"ASSOC_FLAGS", v84 & 0xFFEFFFFF | 0x100000LL);
                      }

                      if (v85) {
                        CFRelease(v85);
                      }
                    }
                  }
                }

                if (sub_10004D6C8(*(void *)(a1 + 64)) && sub_100098124(a3))
                {
                  CFIndex v103 = objc_autoreleasePoolPush();
                  if (qword_100219F60) {
                    [(id)qword_100219F60 WFLog:3, "%s: Applying APPLE80211_ASSOC_F_BEACON_PROTECTION because network is capable (%@)", "WiFiDeviceManagerAssociateAsync", a3 message];
                  }
                  objc_autoreleasePoolPop(v103);
                  unsigned int v104 = sub_100096BF4((uint64_t)a3, @"ASSOC_FLAGS");
                  sub_1000970C0((uint64_t)a3, @"ASSOC_FLAGS", v104 & 0xFFFF7FFF | 0x8000LL);
                }

                if (sub_10004D6EC(*(void *)(a1 + 64)))
                {
                  unsigned int v105 = sub_1000981F0((const __CFDictionary *)a3);
                  CFMutableDictionaryRef v106 = objc_autoreleasePoolPush();
                  if (v105)
                  {
                    if (qword_100219F60) {
                      [(id)qword_100219F60 WFLog:3, "%s: Applying APPLE80211_ASSOC_F_SAE_PK because network is capable (%@)", "WiFiDeviceManagerAssociateAsync", a3 message];
                    }
                    objc_autoreleasePoolPop(v106);
                    unsigned int v107 = sub_100096BF4((uint64_t)a3, @"ASSOC_FLAGS");
                    sub_1000970C0((uint64_t)a3, @"ASSOC_FLAGS", v107 & 0xFFFBFFFF | 0x40000LL);
                    unsigned int v108 = sub_100096BF4((uint64_t)a3, @"WSEC_FLAGS");
                    unsigned int v109 = sub_100098260((const __CFDictionary *)a3);
                    CFMutableDictionaryRef v106 = objc_autoreleasePoolPush();
                    if (v109)
                    {
                      unsigned int v110 = v108 | 0x20000;
                      if (qword_100219F60) {
                        [(id)qword_100219F60 WFLog:3, "%s: Applying APPLE80211_ASSOC_F_SAE_PK_RESTRICT mode network is capable (%@)", "WiFiDeviceManagerAssociateAsync", a3 message];
                      }
                    }

                    else
                    {
                      unsigned int v110 = v108 | 0x10000;
                      if (qword_100219F60) {
                        [(id)qword_100219F60 WFLog:3, "%s: Applying APPLE80211_ASSOC_F_SAE_PK_ENABLE because network is capable (%@)", "WiFiDeviceManagerAssociateAsync", a3 message];
                      }
                    }
                  }

                  else
                  {
                    if (qword_100219F60) {
                      [(id)qword_100219F60 WFLog:3, "%s: Applying APPLE80211_ASSOC_F_SAE_PK_DISABLE mode network is incapable (%@)", "WiFiDeviceManagerAssociateAsync", a3 message];
                    }
                    unsigned int v110 = 0;
                  }

                  objc_autoreleasePoolPop(v106);
                  sub_1000970C0((uint64_t)a3, @"WSEC_FLAGS", v110);
                }

                if (sub_10004D6E0(*(void *)(a1 + 64))
                  && sub_10009819C((CFDictionaryRef *)a3))
                {
                  CFNumberRef v111 = objc_autoreleasePoolPush();
                  if (qword_100219F60) {
                    [(id)qword_100219F60 WFLog:3, "%s: Applying APPLE80211_ASSOC_F_OCV because network is capable (%@)", "WiFiDeviceManagerAssociateAsync", a3 message];
                  }
                  objc_autoreleasePoolPop(v111);
                  unsigned int v112 = sub_100096BF4((uint64_t)a3, @"ASSOC_FLAGS");
                  sub_1000970C0((uint64_t)a3, @"ASSOC_FLAGS", v112 & 0xFFFDFFFF | 0x20000LL);
                }

                char v113 = context ^ 1;
                if (!v41) {
                  char v113 = 0;
                }
                if ((v113 & 1) == 0) {
                  sub_100051010(*(void *)(a1 + 64));
                }
                *(CFAbsoluteTime *)(a1 + 344_Block_object_dispose((const void *)(v15 - 112), 8) = CFAbsoluteTimeGetCurrent();
                [+[WiFiXPCManager sharedXPCManager](WiFiXPCManager, "sharedXPCManager") willAssociateWithNetwork:a3 isAutoJoin:0 interfaceName:cf];
                if (sub_1000951FC((uint64_t)a3, @"COLOCATED_NETWORK_SCOPE_ID"))
                {
                  char v114 = 1;
                }

                else
                {
                  sub_1000DF428(a1);
                  sub_10009582C((uint64_t)a3, @"COLOCATED_NETWORK_SCOPE_ID", *(const void **)(a1 + 3848));
                  char v114 = 0;
                }

                *(_BYTE *)(v69 + 40) = v114;
                if (_os_feature_enabled_impl("WiFiManager", "ColocatedScopeTransition"))
                {
                  sub_1000E366C((uint64_t)a3);
                  CFNumberRef v115 = objc_autoreleasePoolPush();
                  uint64_t v116 = (void *)qword_100219F60;
                  if (qword_100219F60)
                  {
                    double v117 = sub_100095BC8(a3);
                    [v116 WFLog:3, "%s: Setting ColocatedScopeId for %@ - '%@'", "WiFiDeviceManagerAssociateAsync", v117, sub_1000951FC((uint64_t)a3, @"COLOCATED_NETWORK_SCOPE_ID") message];
                  }

                  objc_autoreleasePoolPop(v115);
                }

                sub_1000E36D4(a1, a3);
                uint64_t v118 = objc_autoreleasePoolPush();
                if (qword_100219F60) {
                  [(id)qword_100219F60 WFLog:3, "Join with colocated scopeID (%@), network (%@)", sub_1000951FC((uint64_t)a3, @"COLOCATED_NETWORK_SCOPE_ID"), a3 message];
                }
                objc_autoreleasePoolPop(v118);
                sub_10004A048( *(void *)(a1 + 64),  0,  +[NSString stringWithFormat:]( &OBJC_CLASS___NSString,  "stringWithFormat:",  @"%@/%p",  @"UserJoin",  v69),  (CFNumberRef)0xA);
                uint64_t v20 = sub_10004E3C4(*(void *)(a1 + 64), cf, a3, v149, (uint64_t)sub_1000E38D0, v69, v152);
                if ((_DWORD)v20)
                {
                  sub_10004A048( *(void *)(a1 + 64),  0,  +[NSString stringWithFormat:]( &OBJC_CLASS___NSString,  "stringWithFormat:",  @"%@/%p",  @"UserJoin",  v69),  0LL);
                  if ((_DWORD)v153 != 1018)
                  {
                    --*(_DWORD *)(a1 + 3472);
                    CFRange v119 = objc_autoreleasePoolPush();
                    if (qword_100219F60) {
                      [qword_100219F60 WFLog:@"%s: did decrement user join counter (%d)" message:3, "WiFiDeviceManagerAssociateAsync", *(unsigned int *)(a1 + 3472)];
                    }
                    objc_autoreleasePoolPop(v119);
                  }

                  [+[WiFiXPCManager sharedXPCManager](WiFiXPCManager, "sharedXPCManager") associationDoneWithNetwork:a3 error:v20 interfaceName:cf];
                  dispatch_time_t v120 = *(const void **)(v69 + 24);
                  if (v120)
                  {
                    CFRelease(v120);
                    *(void *)(v69 + 24) = 0LL;
                  }

                  free((void *)v69);
                }

                else
                {
                  sub_1000CF880(a1, 1, 1);
                  if (*(void *)(a1 + 7320))
                  {
                    v155[0] = _NSConcreteStackBlock;
                    v155[1] = 3221225472LL;
                    v155[2] = sub_1000E4638;
                    v155[3] = &unk_1001E4C80;
                    v155[4] = a1;
                    v155[5] = v147;
                    sub_1000D8E24(a1, (const __CFDictionary **)a3, (uint64_t)v155);
                  }
                }

                if (v41) {
                  CFRelease(v41);
                }
                return v20;
              }

              if (qword_100219F60) {
                [(id)qword_100219F60 WFLog:3, "%s: not considering non-suitable network %@ for delayed auto-join", "__WiFiDeviceManagerIsNetworkAutoJoinDelayed", sub_100095BC8(v134) message];
              }
              uint64_t v77 = v136;
LABEL_141:
              objc_autoreleasePoolPop(v77);
              goto LABEL_142;
            }

            CFRange v72 = objc_autoreleasePoolPush();
            CFNumberRef v75 = (void *)qword_100219F60;
            if (qword_100219F60)
            {
              int v143 = (void *)sub_100095BC8(v134);
              id v76 = "%s: not considering hotspot network %@ for delayed auto-join";
              goto LABEL_136;
            }
          }

LABEL_137:
          uint64_t v77 = v72;
          goto LABEL_141;
        }

        unsigned int v78 = objc_autoreleasePoolPush();
        if (qword_100219F60) {
          [qword_100219F60 WFLog:@"__WiFiDeviceManagerIsNetworkAutoJoinDelayed not considering delayed auto-join due to MIS"];
        }
      }

      else
      {
        unsigned int v78 = objc_autoreleasePoolPush();
        if (qword_100219F60) {
          [qword_100219F60 WFLog:@"network is NULL!"];
        }
      }

      uint64_t v77 = v78;
      goto LABEL_141;
    }

    sub_100109F94(a1, v71);
    char v79 = objc_autoreleasePoolPush();
    if (qword_100219F60)
    {
      uint64_t v80 = v107 ? sub_100095BC8(v107) : @"Unknown";
      id v81 = +[NSString stringWithFormat:]( &OBJC_CLASS___NSString,  "stringWithFormat:",  @"%s",  -[NSString UTF8String]( +[NSString stringWithFormat:]( &OBJC_CLASS___NSString,  "stringWithFormat:",  @"{%@*} %@",  @"AUTOJOIN, ASSOC",  +[NSString stringWithFormat:]( &OBJC_CLASS___NSString,  "stringWithFormat:",  @"Failed to associate with %@, reason %d, WFMacRandomisation : is mac address private ? : <%d>",  v80,  a4,  v102)),  "UTF8String"));
      if (os_log_type_enabled((os_log_t)&_os_log_default, OS_LOG_TYPE_DEFAULT))
      {
        int v82 = -[NSString UTF8String]( +[NSString stringWithFormat:]( &OBJC_CLASS___NSString,  "stringWithFormat:",  @"[WiFiPolicy] %s",  -[NSString UTF8String](v81, "UTF8String")),  "UTF8String");
        *(_DWORD *)double v117 = 136446210;
        uint64_t v118 = v82;
        _os_log_impl( (void *)&_mh_execute_header,  (os_log_t)&_os_log_default,  OS_LOG_TYPE_DEFAULT,  "%{public}s",  v117,  0xCu);
      }
    }

    objc_autoreleasePoolPop(v79);
    switch((_DWORD)a4)
    {
      case 0x52:
        uint64_t v52 = 0LL;
        break;
      case 0xEA010003:
        sub_10010D14C(a1, @"autoJoinEAPNeedsUserFix", 0LL, 0LL);
        if (v11)
        {
          *(void *)(a1 + 1120) = -1LL;
          if (CFDictionaryGetValue(v11, @"TLSServerCertificateChain"))
          {
            unsigned int v83 = sub_100043E8C(*(void *)(a1 + 64));
            uint64_t v52 = sub_1000EF770(a1, v83, 2LL, 2LL, v107, v11);
          }

          else
          {
            id v86 = (const __CFArray *)CFDictionaryGetValue(v11, @"RequiredProperties");
            uint64_t v87 = v86;
            if (v86)
            {
              v124.length = CFArrayGetCount(v86);
              v124.location = 0LL;
              if (!CFArrayGetFirstIndexOfValue(v87, v124, @"UserName"))
              {
                v125.length = CFArrayGetCount(v87);
                v125.location = 0LL;
                CFArrayGetFirstIndexOfValue(v87, v125, @"UserPassword");
              }
            }
          }
        }

        break;
      case 0xFFFFF0BF:
        unsigned int v84 = v106;
        if (!v100 || (uint64_t v85 = *(const __CFArray **)(a1 + 1104)) == 0LL)
        {
LABEL_160:
          if ((value & 1) != 0 || *(uint64_t *)(a1 + 1120) > 1)
          {
            *(void *)(a1 + 1120) = 0LL;
LABEL_166:
            if (v84) {
              CFRelease(v84);
            }
            goto LABEL_168;
          }

LABEL_96:
    if (a3) {
      goto LABEL_97;
    }
    goto LABEL_103;
  }

  if (!sub_10009DF44((uint64_t)v41) || !sub_1000951FC((uint64_t)a3, @"JOINING_FROM_UI"))
  {
    CFBooleanRef v61 = objc_autoreleasePoolPush();
    if (qword_100219F60) {
      [(id)qword_100219F60 WFLog:3, "Same SSID %@ and EAP network. Skip disassociation.", sub_100095BC8(v41) message];
    }
    objc_autoreleasePoolPop(v61);
    char v62 = 0;
    BOOL v55 = 0;
    char v63 = 1;
    goto LABEL_106;
  }

  if (*(void *)(a1 + 240))
  {
    *(void *)&__int128 v159 = 0LL;
    *((void *)&v159 + 1) = &v159;
    *(void *)&__int128 v160 = 0x2020000000LL;
    *((void *)&v160 + 1) = 0xAAAAAAAAAAAAAAAALL;
    if (cf) {
      CFTypeRef v54 = CFRetain(cf);
    }
    else {
      CFTypeRef v54 = 0LL;
    }
    *((void *)&v160 + 1) = v54;
    uint64_t v174 = 0LL;
    unsigned int v175 = &v174;
    uint64_t v176 = 0x2020000000LL;
    v177 = (void *)0xAAAAAAAAAAAAAAAALL;
    v177 = (void *)CFRetain(v41);
    CFRetain((CFTypeRef)a1);
    v122 = *(dispatch_queue_s **)(a1 + 240);
    v171[0] = _NSConcreteStackBlock;
    v171[1] = 3221225472LL;
    v171[2] = sub_1000E3274;
    v171[3] = &unk_1001E4C18;
    v171[4] = &v174;
    v171[5] = &v159;
    void v171[6] = a1;
    v171[7] = a6;
    v171[8] = a7;
    dispatch_async(v122, v171);
    _Block_object_dispose(&v174, 8);
    _Block_object_dispose(&v159, 8);
  }

  else
  {
    v121 = objc_autoreleasePoolPush();
    if (qword_100219F60) {
      [qword_100219F60 WFLog:@"%s: null queue." message:4];
    }
    objc_autoreleasePoolPop(v121);
  }

  sub_1000D36F4((void *)a1, 0LL, 0, 0LL);
  uint64_t v123 = objc_autoreleasePoolPush();
  if (qword_100219F60) {
    [qword_100219F60 WFLog:@"%s: joining from UI. Setting interface rank kSCNetworkServicePrimaryRankDefault" message:3];
  }
  objc_autoreleasePoolPop(v123);
  sub_1000D3A2C(a1, v41);
  return 0LL;
}

void sub_1000E2DAC( _Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20, uint64_t a21, uint64_t a22, uint64_t a23, uint64_t a24, uint64_t a25, uint64_t a26, uint64_t a27, uint64_t a28, uint64_t a29, uint64_t a30, uint64_t a31, uint64_t a32, uint64_t a33, uint64_t a34, uint64_t a35, uint64_t a36, uint64_t a37, uint64_t a38, uint64_t a39, uint64_t a40, uint64_t a41, uint64_t a42, uint64_t a43, uint64_t a44, uint64_t a45, uint64_t a46, char a47)
{
}

uint64_t sub_1000E2DE8(const void *a1)
{
  uint64_t result = sub_100095B4C((uint64_t)a1);
  if (!(_DWORD)result) {
    return result;
  }
  uint64_t result = (uint64_t)sub_1000951FC((uint64_t)a1, @"ShareableEAPConfig");
  if (!result) {
    return result;
  }
  uint64_t v3 = sub_1000951FC((uint64_t)a1, @"ShareableEAPTrustExceptions");
  if (v3)
  {
    uint64_t v4 = v3;
    BOOL v5 = sub_100095BC8(a1);
    EAPTLSSetTrustExceptionBindings(@"WirelessSSID", v5, v4);
  }

  else
  {
    uint64_t v11 = objc_autoreleasePoolPush();
    if (qword_100219F60) {
      [(id)qword_100219F60 WFLog:3, "%s: Network doesn't contain property kWiFiNetworkShareableEAPTrustExceptions, hopefully this network (%@) doesn' t need them. Attempting to ingest anyway.", "WiFiDeviceManagerFixAndIngestShareableNetworkIfNecessary", sub_100095BC8(a1) message];
    }
    objc_autoreleasePoolPop(v11);
  }

  if (!qword_1002199E8)
  {
    __int128 v20 = off_1001E5148;
    char v21 = 0LL;
    qword_1002199E8 = _sl_dlopen(&v20, 0LL);
  }

  if (!qword_1002199E8)
  {
    uint64_t v12 = objc_autoreleasePoolPush();
    if (qword_100219F60) {
      objc_msgSend( (id)qword_100219F60,  "WFLog:message:",  3,  "%s: isEAP8021XAvailable() indicated the function doesn't exist. Soft link failed. EAP8021X deps missing.",  "WiFiDeviceManagerFixAndIngestShareableNetworkIfNecessary");
    }
    objc_autoreleasePoolPop(v12);
    return 0LL;
  }

  CFRange v6 = sub_1000951FC((uint64_t)a1, @"ShareableEAPConfig");
  uint64_t v16 = 0LL;
  CFComparisonResult v17 = &v16;
  uint64_t v18 = 0x2020000000LL;
  BOOL v7 = (uint64_t (*)(const void *))off_1002199F0;
  int v19 = off_1002199F0;
  if (!off_1002199F0)
  {
    *(void *)&__int128 v20 = _NSConcreteStackBlock;
    *((void *)&v20 + 1) = 3221225472LL;
    char v21 = sub_100110B64;
    char v22 = &unk_1001E42A0;
    uint64_t v23 = &v16;
    sub_100110B64((uint64_t)&v20);
    BOOL v7 = (uint64_t (*)(const void *))v17[3];
  }

  _Block_object_dispose(&v16, 8);
  if (!v7) {
    sub_1001547C4();
  }
  char v8 = (const __CFDictionary *)v7(v6);
  if (!v8)
  {
    uint64_t v13 = objc_autoreleasePoolPush();
    int v14 = (void *)qword_100219F60;
    if (qword_100219F60)
    {
      int v15 = sub_100095BC8(a1);
      [v14 WFLog:3, "%s: soft_EAPClientConfigurationCopyAndImport() returned NULL. BAIL (SSID: %@)", "WiFiDeviceManagerFixAndIngestShareableNetworkIfNecessary", v15, v16 message];
    }

    objc_autoreleasePoolPop(v13);
    return 0LL;
  }

  Default = CFAllocatorGetDefault();
  MutableCFStringRef Copy = CFDictionaryCreateMutableCopy(Default, 0LL, v8);
  CFDictionarySetValue(MutableCopy, @"EAPClientConfiguration", v8);
  CFDictionarySetValue(MutableCopy, @"EnableUserInterface", kCFBooleanFalse);
  sub_10009582C((uint64_t)a1, @"EnterpriseProfile", MutableCopy);
  sub_10009582C((uint64_t)a1, @"ShareableEAPConfig", 0LL);
  sub_10009582C((uint64_t)a1, @"ShareableEAPTrustExceptions", 0LL);
  CFRelease(v8);
  if (MutableCopy) {
    CFRelease(MutableCopy);
  }
  return 1LL;
}

void sub_1000E30F4(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, ...)
{
}

void sub_1000E3114(uint64_t a1)
{
  int v2 = *(void **)(a1 + 32);
  if (v2[30])
  {
    (*(void (**)(void))(a1 + 48))();
    int v2 = *(void **)(a1 + 32);
  }

  CFRelease(v2);
  uint64_t v3 = *(const void **)(a1 + 40);
  if (v3) {
    CFRelease(v3);
  }
}

void sub_1000E3170(uint64_t a1)
{
  int v2 = *(void **)(a1 + 48);
  if (v2[30])
  {
    (*(void (**)(void))(a1 + 56))();
    int v2 = *(void **)(a1 + 48);
  }

  CFRelease(v2);
  uint64_t v3 = *(const void **)(*(void *)(*(void *)(a1 + 32) + 8LL) + 24LL);
  if (v3) {
    CFRelease(v3);
  }
  uint64_t v4 = *(const void **)(*(void *)(*(void *)(a1 + 40) + 8LL) + 24LL);
  if (v4) {
    CFRelease(v4);
  }
}

void sub_1000E31F4(void *a1)
{
  uint64_t v2 = a1[6];
  if (*(void *)(v2 + 240))
  {
    (*(void (**)(uint64_t, void, void, void))(v2 + 4096))( v2,  *(void *)(*(void *)(a1[5] + 8LL) + 24LL),  *(void *)(v2 + 4104),  *(void *)(*(void *)(a1[4] + 8LL) + 24LL));
    uint64_t v2 = a1[6];
  }

  CFRelease((CFTypeRef)v2);
  uint64_t v3 = *(const void **)(*(void *)(a1[4] + 8LL) + 24LL);
  if (v3) {
    CFRelease(v3);
  }
  uint64_t v4 = *(const void **)(*(void *)(a1[5] + 8LL) + 24LL);
  if (v4) {
    CFRelease(v4);
  }
}

void sub_1000E3274(uint64_t a1)
{
  uint64_t v2 = *(void **)(a1 + 48);
  if (v2[30])
  {
    uint64_t v3 = a1 + 40;
    (*(void (**)(void))(a1 + 56))();
    CFRetain(*(CFTypeRef *)(a1 + 48));
    uint64_t v4 = *(const void **)(*(void *)(*(void *)(a1 + 32) + 8LL) + 24LL);
    if (v4)
    {
      CFRelease(v4);
      *(void *)(*(void *)(*(void *)(a1 + 32) + 8LL) + 24LL) = 0LL;
    }

    BOOL v5 = *(const void **)(*(void *)(*(void *)v3 + 8LL) + 24LL);
    if (!v5) {
      return;
    }
LABEL_10:
    CFRelease(v5);
    *(void *)(*(void *)(*(void *)v3 + 8LL) + 24LL) = 0LL;
    return;
  }

  CFRelease(v2);
  CFRange v6 = *(const void **)(*(void *)(*(void *)(a1 + 32) + 8LL) + 24LL);
  if (v6)
  {
    CFRelease(v6);
    *(void *)(*(void *)(*(void *)(a1 + 32) + 8LL) + 24LL) = 0LL;
  }

  uint64_t v8 = *(void *)(a1 + 40);
  uint64_t v7 = a1 + 40;
  BOOL v5 = *(const void **)(*(void *)(v8 + 8) + 24LL);
  if (v5)
  {
    uint64_t v3 = v7;
    goto LABEL_10;
  }

void sub_1000E334C(uint64_t a1, void *a2)
{
  if (a2)
  {
    [*(id *)(*(void *)(a1 + 32) + 7320) setJoinEvent:0 withReason:0 lastDisconnectReason:1008 lastJoinFailure:0 andNetworkDetails:a2 forInterface:sub_100043E8C(*(void *)(*(void *)(a1 + 32) + 64))];
  }

void sub_1000E33AC(uint64_t a1)
{
  uint64_t v2 = *(void *)(a1 + 48);
  if (*(void *)(v2 + 240))
  {
    uint64_t v3 = a1 + 40;
    (*(void (**)(uint64_t, void, const __CFString *, void, void))(v2 + 4736))( v2,  *(void *)(*(void *)(*(void *)(a1 + 32) + 8LL) + 24LL),  @"LinkDownTimestamp",  *(void *)(*(void *)(*(void *)(a1 + 40) + 8LL) + 24LL),  *(void *)(v2 + 4744));
    CFRelease(*(CFTypeRef *)(a1 + 48));
    uint64_t v4 = *(const void **)(*(void *)(*(void *)(a1 + 32) + 8LL) + 24LL);
    if (v4)
    {
      CFRelease(v4);
      *(void *)(*(void *)(*(void *)(a1 + 32) + 8LL) + 24LL) = 0LL;
    }

    BOOL v5 = *(const void **)(*(void *)(*(void *)v3 + 8LL) + 24LL);
    if (!v5) {
      return;
    }
LABEL_10:
    CFRelease(v5);
    *(void *)(*(void *)(*(void *)v3 + 8LL) + 24LL) = 0LL;
    return;
  }

  CFRelease((CFTypeRef)v2);
  CFRange v6 = *(const void **)(*(void *)(*(void *)(a1 + 32) + 8LL) + 24LL);
  if (v6)
  {
    CFRelease(v6);
    *(void *)(*(void *)(*(void *)(a1 + 32) + 8LL) + 24LL) = 0LL;
  }

  uint64_t v8 = *(void *)(a1 + 40);
  uint64_t v7 = a1 + 40;
  BOOL v5 = *(const void **)(*(void *)(v8 + 8) + 24LL);
  if (v5)
  {
    uint64_t v3 = v7;
    goto LABEL_10;
  }

void sub_1000E3488(uint64_t a1)
{
  uint64_t v1 = *(void *)(a1 + 32);
  if (*(void *)(v1 + 240))
  {
    if (*(_BYTE *)(v1 + 6272))
    {
      uint64_t v3 = *(void *)(v1 + 4544);
      uint64_t v4 = objc_autoreleasePoolPush();
      if (v3)
      {
        if (qword_100219F60) {
          [qword_100219F60 WFLog:@"__WiFiDeviceManagerDelayedAutoJoinNotification" message:3];
        }
        objc_autoreleasePoolPop(v4);
        (*(void (**)(uint64_t, uint64_t, void, void))(v1 + 4544))(v1, 3LL, 0LL, *(void *)(v1 + 4552));
        goto LABEL_12;
      }

      if (qword_100219F60) {
        [qword_100219F60 WFLog:@"__WiFiDeviceManagerDelayedAutoJoinNotification: softErrorManagerService callback is NULL!"];
      }
      CFRange v6 = v4;
    }

    else
    {
      uint64_t v7 = objc_autoreleasePoolPush();
      if (qword_100219F60) {
        [qword_100219F60 WFLog:@"%s: user auto-join is disabled." message:@"__WiFiDeviceManagerDelayedAutoJoinNotification"];
      }
      CFRange v6 = v7;
    }

    objc_autoreleasePoolPop(v6);
LABEL_12:
    BOOL v5 = *(const void **)(a1 + 32);
    goto LABEL_13;
  }

  BOOL v5 = *(const void **)(a1 + 32);
LABEL_13:
  CFRelease(v5);
}

id sub_1000E359C(uint64_t a1)
{
  uint64_t v2 = objc_autoreleasePoolPush();
  uint64_t v3 = objc_autoreleasePoolPush();
  unsigned int v4 = [*(id *)(a1 + 5592) isAuthorized];
  objc_autoreleasePoolPop(v3);
  if (v4)
  {
    id v5 = objc_msgSend(objc_msgSend(*(id *)(a1 + 5592), "latestLocation"), "copy");
  }

  else
  {
    CFRange v6 = objc_autoreleasePoolPush();
    if (qword_100219F60) {
      [qword_100219F60 WFLog:@"%s: not authorized to use location" message:3];
    }
    objc_autoreleasePoolPop(v6);
    id v5 = 0LL;
  }

  objc_autoreleasePoolPop(v2);
  return v5;
}

NSDictionary *__cdecl sub_1000E3650(id a1, id a2)
{
  CFDictionaryRef v2 = sub_100012CEC((uint64_t)a2);
  return (NSDictionary *)(id)CFMakeCollectable(v2);
}

void sub_1000E366C(uint64_t a1)
{
  id v2 = [+[WiFiAnalyticsManager sharedWiFiAnalyticsManager]( WiFiAnalyticsManager,  "sharedWiFiAnalyticsManager") copyColocatedScopeIdForNetwork:a1];
  if (v2)
  {
    id v3 = v2;
    sub_10009582C(a1, @"COLOCATED_NETWORK_SCOPE_ID", v2);
  }

void sub_1000E36D4(uint64_t a1, const void *a2)
{
  int v4 = sub_100055A48(*(void *)(a1 + 64));
  if (a2 && v4)
  {
    id v5 = sub_1000951FC((uint64_t)a2, @"COLOCATED_NETWORK_SCOPE_ID");
    if (v5)
    {
      CFRange v6 = objc_autoreleasePoolPush();
      if (qword_100219F60) {
        [(id)qword_100219F60 WFLog:3, "[NWTRANSIT]: %s: Assign ScopeID for %@", "__WiFiDeviceManagerAssignColocatedGroupScopeID", sub_100095BC8(a2) message];
      }
      objc_autoreleasePoolPop(v6);
    }

    uint64_t v7 = *(const __CFArray **)(a1 + 3728);
    if (v7) {
      CFIndex Count = CFArrayGetCount(v7);
    }
    else {
      CFIndex Count = 0LL;
    }
    int v9 = objc_autoreleasePoolPush();
    if (qword_100219F60) {
      [qword_100219F60 WFLog:@"[NWTRANSIT]: %s: Colocated Network CFIndex Count = %ld " message:3,  "[NWTRANSIT]: %s: Colocated Network CFIndex Count = %ld ",  "__WiFiDeviceManagerAssignColocatedGroupScopeID",  Count];
    }
    objc_autoreleasePoolPop(v9);
    if (v5 || (char v10 = *(const void **)(a1 + 3744)) == 0LL)
    {
      if (!v5)
      {
        uint64_t v11 = -[NSUUID UUIDString](+[NSUUID UUID](&OBJC_CLASS___NSUUID, "UUID"), "UUIDString");
        if (!v11) {
          return;
        }
        id v5 = v11;
        sub_10009582C((uint64_t)a2, @"COLOCATED_NETWORK_SCOPE_ID", v11);
        uint64_t v12 = objc_autoreleasePoolPush();
        if (qword_100219F60) {
          [(id)qword_100219F60 WFLog:3, "[NWTRANSIT]: %s: Configured ColocatedScopeId for %@ - '%@'", "__WiFiDeviceManagerAssignColocatedGroupScopeID", sub_100095BC8(a2), v5 message];
        }
        objc_autoreleasePoolPop(v12);
        *(void *)(a1 + 3744) = -[NSString initWithString:](objc_alloc(&OBJC_CLASS___NSString), "initWithString:", v5);
      }
    }

    else
    {
      sub_10009582C((uint64_t)a2, @"COLOCATED_NETWORK_SCOPE_ID", *(const void **)(a1 + 3744));
      id v5 = v10;
    }

    if (*(_BYTE *)(a1 + 3736) == 1 && sub_1000F93A4(a1, (uint64_t)a2) && Count > 0)
    {
      for (CFIndex i = 0LL; i != Count; ++i)
      {
        ValueAtIndex = CFArrayGetValueAtIndex(*(CFArrayRef *)(a1 + 3728), i);
        if (ValueAtIndex) {
          sub_10009582C((uint64_t)ValueAtIndex, @"COLOCATED_NETWORK_SCOPE_ID", v5);
        }
      }
    }
  }

void sub_1000E38D0(uint64_t a1, const void *a2, void *a3, const void *a4, uint64_t a5, unsigned int *a6)
{
  char context = objc_autoreleasePoolPush();
  uint64_t v11 = *(void *)a6;
  if (a6[9] == 1)
  {
    --*(_DWORD *)(v11 + 3472);
    uint64_t v12 = objc_autoreleasePoolPush();
    if (qword_100219F60) {
      [qword_100219F60 WFLog:@"%s: did decrement user join counter (%d)" message:3, "__WiFiDeviceManagerClientAssociateCallback", *(unsigned int *)(v11 + 3472)];
    }
    objc_autoreleasePoolPop(v12);
  }

  sub_10004A048( *(void *)(v11 + 64),  0,  +[NSString stringWithFormat:](&OBJC_CLASS___NSString, "stringWithFormat:", @"%@/%p", @"UserJoin", a6),  0LL);
  p_superclass = &OBJC_CLASS___WiFiUserNotificationHistory.superclass;
  [+[WiFiXPCManager sharedXPCManager](WiFiXPCManager, "sharedXPCManager") associationDoneWithNetwork:a3 error:a5 interfaceName:a2];
  if (!(_DWORD)a5)
  {
    BOOL v14 = a3 != 0LL;
    if (!a3)
    {
LABEL_85:
      sub_1000CF880(v11, 1, 1);
      sub_1000FED08(v11, a3);
      goto LABEL_86;
    }

    id v15 = sub_1000A335C((uint64_t)a3);
    [*(id *)(v11 + 6632) removeNetworkDenyListInfoWithReason:1 forScanResult:v15];
    [*(id *)(v11 + 6632) removeNetworkDenyListInfoForTrigger:0 forNetwork:v15];

    sub_100109CFC(v11, a3, 0);
    uint64_t v16 = objc_autoreleasePoolPush();
    if (qword_100219F60) {
      [(id)qword_100219F60 WFLog:3, "%s: joined %@, reason type %d", "__WiFiDeviceManagerClientAssociateCallback", sub_100095BC8(a3), a6[8] message];
    }
    objc_autoreleasePoolPop(v16);
    if (+[WiFiPerfPerAssoc sharedInstance](&OBJC_CLASS___WiFiPerfPerAssoc, "sharedInstance"))
    {
      uint64_t v99 = 0LL;
      v100 = &v99;
      uint64_t v101 = 0x2020000000LL;
      unsigned int v102 = (__CFArray *)0xAAAAAAAAAAAAAAAALL;
      unsigned int v102 = sub_1000538A8(*(void *)(v11 + 64));
      CFComparisonResult v17 = +[WiFiPerfPerAssoc sharedInstance](&OBJC_CLASS___WiFiPerfPerAssoc, "sharedInstance");
      uint64_t v18 = v100[3];
      v98[0] = _NSConcreteStackBlock;
      v98[1] = 3221225472LL;
      v98[2] = sub_10010D3D0;
      v98[3] = &unk_1001E42A0;
      v98[4] = &v99;
      -[WiFiPerfPerAssoc ingestScanResults:currentSSID:andReply:]( v17,  "ingestScanResults:currentSSID:andReply:",  v18,  sub_100095BC8(a3),  v98);
      _Block_object_dispose(&v99, 8);
    }

    sub_1000FD4EC(v11, a3);
    if (_os_feature_enabled_impl("CoreWiFi", "UnifiedAutoJoin"))
    {
      int v19 = sub_100095BC8(a3);
      if (v19) {
        [*(id *)(v11 + 8848) removeObjectForKey:v19];
      }
    }

    __int128 v20 = *(const void **)(v11 + 3432);
    if (v20)
    {
      CFRelease(v20);
      *(void *)(v11 + 3432) = 0LL;
    }

    char v21 = (const void *)*((void *)a6 + 3);
    if (v21)
    {
      CFRetain(v21);
      *(_BYTE *)(v11 + 3405) = 1;
      *(void *)(v11 + 3432) = *((void *)a6 + 3);
      *(_DWORD *)(v11 + 3384) = -1;
      if (_os_feature_enabled_impl("CoreWiFi", "UnifiedAutoJoin"))
      {
        char v22 = (const void *)*((void *)a6 + 3);
        if (v22)
        {
          uint64_t v23 = sub_1000951FC((uint64_t)a3, @"addedAt");
          uint64_t v24 = sub_1000951FC((uint64_t)v22, @"addedAt");
          if (v23)
          {
            if (v24 && *(void *)(v11 + 4512))
            {
              int v25 = sub_10009D454((uint64_t)a3);
              CFIndex v26 = sub_100095BC8(a3);
              CFStringRef v27 = v25
                  ? CFStringCreateWithFormat(kCFAllocatorDefault, 0LL, @"'%@' (%@)", v26, v25)
                  : CFStringCreateWithFormat(kCFAllocatorDefault, 0LL, @"'%@'", v26, v86);
              CFStringRef v28 = v27;
              if (v27)
              {
                CFNumberRef v88 = a4;
                uint64_t v29 = sub_10009D454((uint64_t)v22);
                CFNumberRef v30 = sub_100095BC8(v22);
                if (v29) {
                  CFStringRef v31 = CFStringCreateWithFormat(kCFAllocatorDefault, 0LL, @"'%@' (%@)", v30, v29);
                }
                else {
                  CFStringRef v31 = CFStringCreateWithFormat(kCFAllocatorDefault, 0LL, @"'%@'", v30, v87);
                }
                CFStringRef v32 = v31;
                if (v31)
                {
                  CFAbsoluteTime Current = CFAbsoluteTimeGetCurrent();
                  CFDateRef v34 = CFDateCreate(kCFAllocatorDefault, Current);
                  if (v34)
                  {
                    CFDateRef v35 = v34;
                    id v36 = objc_autoreleasePoolPush();
                    if (qword_100219F60) {
                      [(id)qword_100219F60 WFLog:3, "%s: setting user-defined network priority %@ as more-preferred than previous network %@", "__WiFiDeviceManagerUpdateNetworkUserPriority", v28, v32 message];
                    }
                    objc_autoreleasePoolPop(v36);
                    sub_1000A5334((uint64_t)v22, (CFDictionaryRef *)a3, v35);
                    sub_1000DAB00((dispatch_queue_s **)v11, v22);
                    CFRelease(v35);
                  }

                  CFRelease(v28);
                }

                else
                {
                  CFStringRef v32 = v28;
                }

                CFRelease(v32);
                a4 = v88;
              }
            }
          }
        }

        id v37 = sub_100095BC8(*((const void **)a6 + 3));
        if (v37) {
          [*(id *)(v11 + 8848) removeObjectForKey:v37];
        }
      }
    }

    CFAbsoluteTime v38 = CFAbsoluteTimeGetCurrent();
    CFDateRef v39 = CFDateCreate(kCFAllocatorDefault, v38);
    if (v39) {
      sub_10009A194(a3, 1, v39);
    }
    id v40 = sub_1000E359C(v11);
    if (v40)
    {
      uint64_t v41 = v40;
      uint64_t v42 = *(void *)(v11 + 6744);
      [v40 coordinate];
      CLLocationDegrees v44 = v43;
      [v41 coordinate];
      CLLocationDegrees v46 = v45;
      [v41 horizontalAccuracy];
      sub_10007E304(v42, a3, v44, v46, v47, [v41 timestamp]);
    }

    if (v39 && *(_BYTE *)(v11 + 3406))
    {
      uint64_t v48 = a4;
      sub_10009B324(a3, v39);
    }

    else
    {
LABEL_49:
      uint64_t v48 = a4;
      if (!v39)
      {
LABEL_51:
        sub_100109C38(v11, a3);
        if (*(_BYTE *)(v11 + 3404))
        {
          unsigned int v49 = objc_autoreleasePoolPush();
          if (qword_100219F60) {
            [(id)qword_100219F60 WFLog:3, "%s: tagging network %@ as moving", "__WiFiDeviceManagerClientAssociateCallback", sub_100095BC8(a3) message];
          }
          objc_autoreleasePoolPop(v49);
          sub_10009582C((uint64_t)a3, @"WiFiNetworkAttributeIsMoving", kCFBooleanTrue);
          CFBooleanRef v50 = kCFBooleanFalse;
        }

        else
        {
          CFBooleanRef v50 = kCFBooleanFalse;
          sub_10009582C((uint64_t)a3, @"WiFiNetworkAttributeIsMoving", kCFBooleanFalse);
        }

        sub_10009582C((uint64_t)a3, @"WiFiInstantHotspotJoining", v50);
        sub_10009582C((uint64_t)a3, @"WiFiAutoInstantHotspotJoining", v50);
        sub_100100228((dispatch_queue_s **)v11, a3, *(_DWORD *)(v11 + 3464), 0);
        CFTypeRef v51 = sub_1000DEA34(v11, a2, 1);
        a4 = v48;
        if (v51)
        {
          uint64_t v52 = v51;
          p_superclass = (__objc2_class **)(&OBJC_CLASS___WiFiUserNotificationHistory + 8);
          if (*(_DWORD *)(v11 + 3464)) {
            sub_10009582C( (uint64_t)v51,  @"TransitionDisabledFlags",  +[NSNumber numberWithUnsignedInt:](&OBJC_CLASS___NSNumber, "numberWithUnsignedInt:"));
          }
          sub_1000D3650(v11, v52);
          sub_10009AB20(a3, v52);
          CFRelease(v52);
        }

        else
        {
          sub_1000D3650(v11, a3);
          p_superclass = &OBJC_CLASS___WiFiUserNotificationHistory.superclass;
        }

        unsigned int v53 = a6[8];
        if (v53 == 1011 || v53 == 1008) {
          *(_BYTE *)(v11 + 3405) = 1;
        }
        if (*(void *)(v11 + 3912))
        {
          if (*(void *)(v11 + 240))
          {
            if (a2) {
              CFRetain(a2);
            }
            CFRetain(a3);
            if (a4) {
              CFRetain(a4);
            }
            CFRetain((CFTypeRef)v11);
            CFTypeRef v54 = *(dispatch_queue_s **)(v11 + 240);
            block[0] = _NSConcreteStackBlock;
            block[1] = 3221225472LL;
            block[2] = sub_10010D40C;
            block[3] = &unk_1001E4CC8;
            void block[4] = v11;
            void block[5] = a2;
            void block[6] = a3;
            void block[7] = a4;
            int v97 = 0;
            dispatch_async(v54, block);
          }

          else
          {
            BOOL v55 = objc_autoreleasePoolPush();
            if (qword_100219F60) {
              [qword_100219F60 WFLog:@"%s: null queue." message:4];
            }
            objc_autoreleasePoolPop(v55);
          }
        }

        if (*(void *)(v11 + 3864))
        {
          if (*(void *)(v11 + 240))
          {
            uint64_t v99 = 0LL;
            v100 = &v99;
            uint64_t v101 = 0x2020000000LL;
            unsigned int v102 = 0LL;
            CFTypeRef v56 = CFRetain(a3);
            v100[3] = (uint64_t)v56;
            CFRetain((CFTypeRef)v11);
            uint64_t v57 = *(dispatch_queue_s **)(v11 + 240);
            v94[0] = _NSConcreteStackBlock;
            v94[1] = 3221225472LL;
            v94[2] = sub_10010D4B0;
            v94[3] = &unk_1001E4FD0;
            v94[4] = &v99;
            v94[5] = v11;
            int v95 = 0;
            dispatch_async(v57, v94);
            _Block_object_dispose(&v99, 8);
          }

          else
          {
            id v58 = objc_autoreleasePoolPush();
            if (qword_100219F60) {
              [qword_100219F60 WFLog:@"%s: null queue." message:4];
            }
            objc_autoreleasePoolPop(v58);
          }
        }

        *(_WORD *)(v11 + 6584) = sub_1000D3EF0(v11, a3);
        char v59 = objc_autoreleasePoolPush();
        if (qword_100219F60) {
          [(id)qword_100219F60 WFLog:3, "%s: usage rank for %@ is now : %d", "__WiFiDeviceManagerClientAssociateCallback", sub_100095BC8(a3), *(unsigned __int16 *)(v11 + 6584) message];
        }
        objc_autoreleasePoolPop(v59);
        CFBooleanRef v60 = objc_autoreleasePoolPush();
        CFBooleanRef v61 = (void *)qword_100219F60;
        if (qword_100219F60)
        {
          char v62 = sub_100095BC8(a3);
          [v61 WFLog:3, "%s: Submit metric to update scores for user switched to %@, and left %@", "__WiFiDeviceManagerClientAssociateCallback", v62, sub_100095BC8(*((const void **)a6 + 3)) message];
        }

        objc_autoreleasePoolPop(v60);
        sub_10003416C(v11, a3, *((const void **)a6 + 3));
        BOOL v14 = 1;
        goto LABEL_85;
      }
    }

    CFRelease(v39);
    goto LABEL_51;
  }

  if (*(void *)(v11 + 7320))
  {
    v103[0] = _NSConcreteStackBlock;
    v103[1] = 3221225472LL;
    v103[2] = sub_10010D36C;
    v103[3] = &unk_1001E4BD0;
    v103[4] = v11;
    int v104 = a5;
    sub_1000D8E24(v11, (const __CFDictionary **)a3, (uint64_t)v103);
  }

  BOOL v14 = a3 != 0LL;
  sub_1000CF880(v11, 1, 0);
LABEL_86:
  sub_100109E80(v11, a3);
  sub_100109F94(v11, (uint64_t)a3);
  char v63 = sub_1000A47DC(*(const __CFArray **)(v11 + 3696), (const __CFDictionary **)a3);
  if ((_DWORD)a5 == -3924) {
    goto LABEL_111;
  }
  uint64_t v64 = (uint64_t)v63;
  if (sub_1000971AC((uint64_t)a3) || !v64)
  {
    if (!v64) {
      goto LABEL_111;
    }
  }

  else
  {
    id v65 = sub_1000951FC(v64, @"PRIVATE_MAC_ADDRESS");
    if (v65)
    {
      CFNumberRef v66 = v65;
      BOOL v90 = v14;
      CFTypeID TypeID = CFDictionaryGetTypeID();
      BOOL v68 = TypeID == CFGetTypeID(v66);
      BOOL v14 = v90;
      if (v68)
      {
        CFBooleanRef Value = (const __CFData *)CFDictionaryGetValue((CFDictionaryRef)v66, @"PRIVATE_MAC_ADDRESS_VALUE");
        unsigned int v70 = sub_10003B498(Value);
        if ((_DWORD)a5)
        {
          if (v70)
          {
            uint64_t v89 = a2;
            int v71 = p_superclass;
            CFRange v72 = a4;
            unsigned int v73 = sub_100096BF4(v64, @"FailureCountCurrent");
            unsigned int v74 = sub_100096BF4(v64, @"FailureCountThresholdCurrent");
            if (*(void *)(v11 + 4736))
            {
              if (*(void *)(v11 + 240))
              {
                uint64_t v99 = 0LL;
                v100 = &v99;
                uint64_t v101 = 0x2020000000LL;
                unsigned int v102 = 0LL;
                if (v90)
                {
                  CFTypeRef v75 = CFRetain(a3);
                  v100[3] = (uint64_t)v75;
                }

                CFRetain((CFTypeRef)v11);
                id v76 = *(dispatch_queue_s **)(v11 + 240);
                v93[0] = _NSConcreteStackBlock;
                v93[1] = 3221225472LL;
                v93[2] = sub_10010D54C;
                v93[3] = &unk_1001E2D48;
                v93[4] = &v99;
                v93[5] = v11;
                dispatch_async(v76, v93);
                _Block_object_dispose(&v99, 8);
              }

              else
              {
                unsigned int v84 = objc_autoreleasePoolPush();
                if (qword_100219F60) {
                  [qword_100219F60 WFLog:@"%s: null queue." message:4];
                }
                objc_autoreleasePoolPop(v84);
              }
            }

            unsigned int v85 = v74 - v73;
            a4 = v72;
            p_superclass = v71;
            a2 = v89;
            BOOL v14 = v90;
            if (v85 == 1) {
              sub_10009582C((uint64_t)a3, @"FailureThresholdMet", kCFBooleanTrue);
            }
          }
        }
      }
    }
  }

  if ((_DWORD)a5)
  {
    uint64_t v77 = (const __CFBoolean *)sub_1000951FC(v64, @"MacAddressRandomisationTagMigratedNetwork");
    if (v77)
    {
      if (v77 == kCFBooleanTrue && *(void *)(v11 + 4704))
      {
        if (*(void *)(v11 + 240))
        {
          uint64_t v99 = 0LL;
          v100 = &v99;
          uint64_t v101 = 0x2020000000LL;
          unsigned int v102 = 0LL;
          if (v14)
          {
            CFTypeRef v78 = CFRetain(a3);
            v100[3] = (uint64_t)v78;
          }

          CFRetain((CFTypeRef)v11);
          char v79 = *(dispatch_queue_s **)(v11 + 240);
          v92[0] = _NSConcreteStackBlock;
          v92[1] = 3221225472LL;
          v92[2] = sub_10010D5D4;
          v92[3] = &unk_1001E2D48;
          v92[4] = &v99;
          v92[5] = v11;
          dispatch_async(v79, v92);
          _Block_object_dispose(&v99, 8);
        }

        else
        {
          uint64_t v80 = objc_autoreleasePoolPush();
          if (qword_100219F60) {
            [qword_100219F60 WFLog:@"%s: null queue." message:4];
          }
          objc_autoreleasePoolPop(v80);
        }
      }
    }
  }

void sub_1000E4614(_Unwind_Exception *a1)
{
}

void sub_1000E4638(uint64_t a1, void *a2)
{
  if (a2)
  {
    [*(id *)(*(void *)(a1 + 32) + 7320) setJoinEvent:1 withReason:*(void *)(a1 + 40) lastDisconnectReason:0 lastJoinFailure:0 andNetworkDetails:a2 forInterface:sub_100043E8C(*(void *)(*(void *)(a1 + 32) + 64))];
  }

uint64_t sub_1000E4698(uint64_t a1, uint64_t a2, const void *a3, uint64_t a4, uint64_t a5, uint64_t a6)
{
  uint64_t v12 = -[WiFiFindAndJoinRequest initWithNetworkName:]( objc_alloc(&OBJC_CLASS___WiFiFindAndJoinRequest),  "initWithNetworkName:",  sub_100095BC8(a3));
  if (!v12) {
    return 4294963395LL;
  }
  uint64_t v13 = v12;
  -[WiFiFindAndJoinRequest setPassword:](v12, "setPassword:", a4);
  -[WiFiFindAndJoinRequest setChannelNumber:](v13, "setChannelNumber:", sub_100096BF4((uint64_t)a3, @"CHANNEL"));
  -[WiFiFindAndJoinRequest setTimeout:](v13, "setTimeout:", 60.0);
  v16[0] = _NSConcreteStackBlock;
  v16[1] = 3221225472LL;
  v16[2] = sub_1000E47B0;
  v16[3] = &unk_1001E4CA8;
  v16[6] = a5;
  v16[7] = a1;
  v16[4] = v13;
  v16[5] = a2;
  v16[8] = a6;
  if (a1) {
    uint64_t v14 = *(void *)(a1 + 240);
  }
  else {
    uint64_t v14 = 0LL;
  }
  if (-[WiFiFindAndJoinRequest runAsynchronouslyOnQueue:onInterface:withReply:]( v13,  "runAsynchronouslyOnQueue:onInterface:withReply:",  v14,  a2,  v16))
  {
    return 0LL;
  }

  else
  {
    return 4294963396LL;
  }

void sub_1000E47B0(uint64_t a1, uint64_t a2, uint64_t a3)
{
  uint64_t v3 = a3;
  if (a3)
  {
    id v5 = objc_autoreleasePoolPush();
    if (qword_100219F60) {
      [(id)qword_100219F60 WFLog:4, "%s: error: %@", "WiFiDeviceManagerFindAndJoinRequestAsync_block_invoke", v3 message];
    }
    objc_autoreleasePoolPop(v5);
    id v6 = [(id)v3 domain];
    else {
      uint64_t v3 = 4294963353LL;
    }
  }

  if ([*(id *)(a1 + 32) joinedNetwork]) {
    uint64_t v7 = sub_1000A3DB0([*(id *)(a1 + 32) joinedNetwork]);
  }
  else {
    uint64_t v7 = 0LL;
  }
  (*(void (**)(void, void, void *, void, uint64_t, void))(a1 + 48))( *(void *)(a1 + 56),  *(void *)(a1 + 40),  v7,  0LL,  v3,  *(void *)(a1 + 64));
  if (v7) {
    CFRelease(v7);
  }
}

uint64_t sub_1000E48A8(uint64_t result)
{
  if (result) {
    return *(void *)(result + 240);
  }
  return result;
}

uint64_t sub_1000E48B4(uint64_t a1, const void *a2, const void *a3, uint64_t a4, uint64_t a5)
{
  char v10 = (uint64_t *)malloc(0x38uLL);
  if (!v10) {
    return 4294963395LL;
  }
  uint64_t v11 = v10;
  sub_1000D0428(a1);
  *(_BYTE *)(a1 + 24_Block_object_dispose((const void *)(v1 - 200), 8) = 1;
  uint64_t *v11 = a1;
  v11[1] = a4;
  void v11[5] = a5;
  void v11[3] = (uint64_t)CFRetain(a3);
  *((_DWORD *)v11 + _Block_object_dispose((const void *)(v1 - 200), 8) = 1;
  uint64_t v12 = sub_1000452C4(*(void *)(a1 + 64), a2, a3, (uint64_t)sub_1000E4988, (uint64_t)v11);
  if ((_DWORD)v12)
  {
    uint64_t v13 = (const void *)v11[3];
    if (v13) {
      CFRelease(v13);
    }
    free(v11);
    sub_10004548C(*(void *)(a1 + 64), a2, 0LL, 0LL);
  }

  return v12;
}

void sub_1000E4988(uint64_t a1, const void *a2, uint64_t a3, CFTypeRef *a4)
{
  uint64_t v7 = (uint64_t)*a4;
  uint64_t v8 = sub_100094AAC((uint64_t)kCFAllocatorDefault, a4[3]);
  if (v8)
  {
    CFNumberRef v9 = CFNumberCreate(kCFAllocatorDefault, kCFNumberSInt32Type, a4 + 4);
    if (v9)
    {
      CFNumberRef v10 = v9;
      sub_10009582C((uint64_t)v8, @"networkRole", v9);
      CFRelease(v10);
    }

    if (!(_DWORD)a3)
    {
      CFSetAddValue(*(CFMutableSetRef *)(v7 + 3312), v8);
      goto LABEL_8;
    }
  }

  else if (!(_DWORD)a3)
  {
    goto LABEL_8;
  }

  sub_1000E4A8C(v7, a2, (uint64_t)v8, 0LL, 0LL);
LABEL_8:
  uint64_t v11 = (void (*)(void, void, void, void, void, void))a4[1];
  if (v11) {
    v11(v7, a2, a3, v8, 0LL, a4[5]);
  }
  CFTypeRef v12 = a4[3];
  if (v12)
  {
    CFRelease(v12);
    a4[3] = 0LL;
  }

  if (v8) {
    CFRelease(v8);
  }
  free(a4);
}

uint64_t sub_1000E4A8C(uint64_t a1, const void *a2, uint64_t a3, uint64_t a4, uint64_t a5)
{
  CFNumberRef v10 = malloc(0x20uLL);
  *(_BYTE *)(a1 + 24_Block_object_dispose((const void *)(v1 - 200), 8) = 0;
  void *v10 = a1;
  v10[1] = a4;
  void v10[2] = a3;
  v10[3] = a5;
  uint64_t v11 = sub_10004548C(*(void *)(a1 + 64), a2, (uint64_t)sub_1000E4B98, (uint64_t)v10);
  if ((_DWORD)v11)
  {
    uint64_t v12 = v11;
    uint64_t v13 = objc_autoreleasePoolPush();
    if (qword_100219F60) {
      objc_msgSend((id)qword_100219F60, "WFLog:message:", 4, "Unable to stop network (%d). deviceManager=%p", v12, a1);
    }
    objc_autoreleasePoolPop(v13);
  }

  *(_DWORD *)(a1 + 192) = 8;
  if (_os_feature_enabled_impl("CoreWiFi", "UnifiedAutoJoin"))
  {
    sub_1000F5F98(a1, 0xBuLL);
  }

  else
  {
    [+[WiFiXPCManager sharedXPCManager](WiFiXPCManager, "sharedXPCManager") autoJoinStartedWithTrigger:11 interfaceName:a2];
    sub_1000D0A5C(a1, 2LL, "WiFiDeviceManagerStopAdHocNetwork");
  }

  return 0LL;
}

void sub_1000E4B98(uint64_t a1, uint64_t a2, uint64_t a3, void *a4)
{
  uint64_t v6 = *a4;
  id v5 = (void (*)(void, uint64_t, uint64_t, void, void))a4[1];
  if (v5) {
    v5(*a4, a2, a3, 0LL, a4[3]);
  }
  CFSetRemoveValue(*(CFMutableSetRef *)(v6 + 3312), (const void *)a4[2]);
  free(a4);
}

uint64_t sub_1000E4BDC(uint64_t a1, const void *a2, const __CFDictionary *a3, uint64_t a4, uint64_t a5)
{
  CFNumberRef v10 = malloc(0x38uLL);
  if (!v10)
  {
    uint64_t v57 = objc_autoreleasePoolPush();
    if (qword_100219F60) {
      [qword_100219F60 WFLog:@"%s: null startData" message:4];
    }
    objc_autoreleasePoolPop(v57);
    return 4294963395LL;
  }

  if (!a3)
  {
    id v58 = objc_autoreleasePoolPush();
    if (qword_100219F60) {
      [qword_100219F60 WFLog:@"%s: null request" message:4];
    }
    objc_autoreleasePoolPop(v58);
    return 4294963396LL;
  }

  uint64_t v11 = v10;
  void *v10 = a1;
  v10[1] = a4;
  v10[5] = a5;
  *((_DWORD *)v10 + _Block_object_dispose((const void *)(v1 - 200), 8) = 3;
  MutableCFStringRef Copy = CFDictionaryCreateMutableCopy(kCFAllocatorDefault, 0LL, a3);
  if (!MutableCopy)
  {
    char v59 = objc_autoreleasePoolPush();
    if (qword_100219F60) {
      [qword_100219F60 WFLog:@"%s: null hostAPDictionary" message:4];
    }
    objc_autoreleasePoolPop(v59);
    return 4294963394LL;
  }

  uint64_t v13 = MutableCopy;
  void v11[3] = CFRetain(MutableCopy);
  CFBooleanRef Value = (const __CFBoolean *)CFDictionaryGetValue(a3, @"AP_MODE_MOVETOIOS_MIGRATION");
  if (!Value || Value != kCFBooleanTrue) {
    goto LABEL_65;
  }
  CFMutableDictionaryRef Mutable = CFStringCreateMutable(kCFAllocatorDefault, 0LL);
  LODWORD(v67[0]) = 0;
  *(void *)int valuePtr = 0LL;
  BOOL v66 = 0LL;
  if (!sub_100050388(*(void *)(a1 + 64), (uint64_t)Mutable))
  {
    BOOL v16 = CFStringCompare(Mutable, @"XZ", 0LL) == kCFCompareEqualTo
       || CFStringCompare(Mutable, &stru_1001EB6E0, 0LL) == kCFCompareEqualTo
       || CFStringCompare(Mutable, @"JP", 0LL) == kCFCompareEqualTo
       || CFStringCompare(Mutable, @"TN", 0LL) == kCFCompareEqualTo
       || CFStringCompare(Mutable, @"YE", 0LL) == kCFCompareEqualTo;
    BOOL v66 = v16;
  }

  uint64_t v64 = v13;
  id v65 = a2;
  BOOL v17 = sub_10010D648(Mutable);
  uint64_t v18 = 0LL;
  do
  {
    CFComparisonResult v19 = CFStringCompare(Mutable, off_1001E4FF0[v18], 0LL);
    if (v19 == kCFCompareEqualTo) {
      break;
    }
  }

  while (v18++ != 37);
  uint64_t v21 = *(void *)(a1 + 64);
  char v22 = (const void *)sub_100040CF8(v21);
  uint64_t v61 = sub_1000500D4(v21, v22, valuePtr);
  uint64_t v23 = (const void *)sub_100043E8C(*(void *)(a1 + 64));
  uint64_t v24 = sub_1000DEA34(a1, v23, 1);
  uint64_t v25 = (uint64_t)v24;
  char v63 = a3;
  if (!v24)
  {
    int v28 = 0;
    int v29 = 0;
    uint64_t v30 = 0LL;
LABEL_31:
    uint64_t v31 = 0LL;
    goto LABEL_32;
  }

  CFIndex v26 = (const __CFNumber *)sub_1000951FC((uint64_t)v24, @"CHANNEL");
  CFStringRef v27 = (const __CFNumber *)sub_1000951FC(v25, @"CHANNEL_FLAGS");
  if (v27) {
    CFNumberGetValue(v27, kCFNumberSInt32Type, &valuePtr[1]);
  }
  if (v26) {
    CFNumberGetValue(v26, kCFNumberSInt32Type, v67);
  }
  if ((valuePtr[1] & 8) != 0)
  {
    int v29 = 0;
    uint64_t v30 = 0LL;
    int v28 = 1;
  }

  else
  {
    int v28 = 0;
    if ((valuePtr[1] & 0x10) != 0)
    {
      uint64_t v30 = 0LL;
      int v29 = 1;
    }

    else
    {
      int v29 = 0;
      uint64_t v30 = (valuePtr[1] >> 13) & 1;
    }
  }

  uint64_t v31 = (valuePtr[1] >> 11) & 1;
LABEL_32:
  else {
    char v32 = v66;
  }
  if ((v32 & 1) != 0
    || v25 && v29 && sub_1000496CC(*(void *)(a1 + 64), v67[0])
    || *(_BYTE *)(a1 + 3406))
  {
    __int128 v33 = objc_autoreleasePoolPush();
    CFDateRef v34 = (void *)qword_100219F60;
    if (qword_100219F60)
    {
      int v62 = v28;
      uint64_t v35 = sub_10004D608(*(void *)(a1 + 64));
      BOOL v36 = 0LL;
      if (v25 && v29) {
        BOOL v36 = sub_1000496CC(*(void *)(a1 + 64), v67[0]) != 0;
      }
      objc_msgSend( v34,  "WFLog:message:",  3,  "MIGRATION: %s Starting SoftAp on 2.4GHz (RegulatoryRestricted: %d, Infra6G: %d, InfraBWHigherThan80MHz:%d, isChi p160MHzCapable:%d, Infra5G_DFS:%d AWDLRealTimeMode:%d)",  "__WiFiDeviceManagerSelectPHChannel",  v66,  v30,  v31,  v35,  v36,  *(unsigned __int8 *)(a1 + 3406));
      int v28 = v62;
    }

    objc_autoreleasePoolPop(v33);
    if (v25 && v28)
    {
      CFNumberRef v37 = CFNumberCreate(kCFAllocatorDefault, kCFNumberSInt32Type, v67);
      CFAbsoluteTime v38 = objc_autoreleasePoolPush();
      if (qword_100219F60) {
        objc_msgSend( (id)qword_100219F60,  "WFLog:message:",  3,  "MIGRATION: Selecting 2.4G infra channel :%d ",  LODWORD(v67[0]));
      }
      uint64_t v13 = v64;
    }

    else
    {
      uint64_t v39 = 0LL;
      uint64_t v13 = v64;
      while (!sub_1000497C8(*(void *)(a1 + 64), dword_10021909C[v39]))
      {
        if (++v39 == 3) {
          goto LABEL_53;
        }
      }

      CFNumberRef v37 = CFNumberCreate(kCFAllocatorDefault, kCFNumberSInt32Type, &dword_10021909C[v39]);
      CFAbsoluteTime v38 = objc_autoreleasePoolPush();
      if (qword_100219F60) {
        [qword_100219F60 WFLog:message:3, @"MIGRATION: Selecting 2G  channel :%d\n", dword_10021909C[v39]];
      }
    }

    objc_autoreleasePoolPop(v38);
    if (!v37) {
      goto LABEL_53;
    }
    goto LABEL_58;
  }

  if (v29 && !(_DWORD)v61)
  {
    uint64_t v48 = objc_autoreleasePoolPush();
    uint64_t v13 = v64;
    if (qword_100219F60) {
      [qword_100219F60 WFLog:@"MIGRATION: Selecting 5G infra channel :%d " message:LODWORD(v67[0])];
    }
    unsigned int v49 = (int *)v67;
    goto LABEL_79;
  }

  uint64_t v50 = 0LL;
  if (v19) {
    char v51 = v17;
  }
  else {
    char v51 = 1;
  }
  char v52 = 1;
  uint64_t v13 = v64;
  while (1)
  {
    char v53 = v52;
    unsigned int v49 = &dword_1002190A8[v50];
    uint64_t v54 = *v49;
    if ((_DWORD)v54 != 138) {
      break;
    }
    if ((v51 & 1) == 0) {
      goto LABEL_93;
    }
LABEL_95:
    char v52 = 0;
    uint64_t v50 = 1LL;
    if ((v53 & 1) == 0) {
      goto LABEL_53;
    }
  }

  else {
    char v55 = 0;
  }
  if ((v55 & 1) != 0) {
    goto LABEL_95;
  }
LABEL_93:
  int v56 = sub_1000E673C(a1, v54);
  if (v19 && v56) {
    goto LABEL_95;
  }
  uint64_t v48 = objc_autoreleasePoolPush();
  if (qword_100219F60) {
    [qword_100219F60 WFLog:@"MIGRATION: Selecting 5G  channel :%d  AwdlActive: %d" message:3 v49 v61];
  }
LABEL_79:
  objc_autoreleasePoolPop(v48);
  CFNumberRef v37 = CFNumberCreate(kCFAllocatorDefault, kCFNumberSInt32Type, v49);
  if (v37)
  {
LABEL_58:
    CFDictionarySetValue(v13, @"CHANNEL", v37);
    if (Mutable) {
      CFRelease(Mutable);
    }
    char v40 = 1;
    CFMutableDictionaryRef Mutable = (const __CFString *)v37;
    a2 = v65;
    goto LABEL_61;
  }

void sub_1000E5394(uint64_t a1, uint64_t a2, uint64_t a3, CFTypeRef *a4)
{
  uint64_t v7 = (uint64_t)*a4;
  uint64_t v8 = sub_100094AAC((uint64_t)kCFAllocatorDefault, a4[3]);
  if (!v8)
  {
    if (!(_DWORD)a3) {
      goto LABEL_8;
    }
LABEL_7:
    uint64_t v16 = 0LL;
    memset(v15, 0, sizeof(v15));
    DWORD1(v15[0]) = 16;
    v11.n128_f64[0] = sub_1000DC1AC(v7, (uint64_t)v15);
    goto LABEL_11;
  }

  CFNumberRef v9 = CFNumberCreate(kCFAllocatorDefault, kCFNumberSInt32Type, a4 + 4);
  if (v9)
  {
    CFNumberRef v10 = v9;
    sub_10009582C((uint64_t)v8, @"networkRole", v9);
    CFRelease(v10);
  }

  if ((_DWORD)a3) {
    goto LABEL_7;
  }
  CFSetAddValue(*(CFMutableSetRef *)(v7 + 3312), v8);
LABEL_8:
  uint64_t v12 = objc_autoreleasePoolPush();
  if (qword_100219F60) {
    [qword_100219F60 WFLog:@"%s: aborting ongoing auto-join on network start" message:3];
  }
  objc_autoreleasePoolPop(v12);
  sub_1000D0428(v7);
LABEL_11:
  uint64_t v13 = (void (*)(void, void, void, void, void, void, __n128))a4[1];
  if (v13) {
    v13(v7, a2, a3, v8, 0LL, a4[5], v11);
  }
  CFTypeRef v14 = a4[3];
  if (v14)
  {
    CFRelease(v14);
    a4[3] = 0LL;
  }

  if (v8) {
    CFRelease(v8);
  }
  free(a4);
}

void sub_1000E5508(int a1, uint64_t a2, uint64_t a3, void *a4)
{
  uint64_t v6 = *a4;
  id v5 = (void (*)(void, uint64_t, uint64_t, void, void))a4[1];
  if (v5) {
    v5(*a4, a2, a3, 0LL, a4[3]);
  }
  uint64_t v7 = (const void *)a4[2];
  if (v7)
  {
    if (CFSetContainsValue(*(CFSetRef *)(v6 + 3312), v7)) {
      CFSetRemoveValue(*(CFMutableSetRef *)(v6 + 3312), (const void *)a4[2]);
    }
    uint64_t v8 = (const void *)a4[2];
    if (v8) {
      CFRelease(v8);
    }
  }

  free(a4);
}

uint64_t sub_1000E556C( uint64_t a1, const __CFString *a2, int a3, const void *a4, uint64_t a5, uint64_t a6, const void *a7)
{
  if (a3 == 1) {
    return sub_1000E48B4(a1, a2, a4, a5, a6);
  }
  if ((a3 & 0xFFFFFFFE) == 2) {
    return sub_1000E4BDC(a1, a2, (const __CFDictionary *)a4, a5, a6);
  }
  if (a3 == 4) {
    return sub_1000E55C4(a1, a2, (const __CFDictionary *)a4, a5, a6, a7);
  }
  return 4294963396LL;
}

uint64_t sub_1000E55C4( uint64_t a1, const __CFString *a2, const __CFDictionary *a3, uint64_t a4, uint64_t a5, const void *a6)
{
  if (!a1) {
    return 4294963396LL;
  }
  if (sub_1000DCBFC(a1, 2LL))
  {
    if (!sub_10004FF60(*(void *)(a1 + 64), a2))
    {
      uint64_t v12 = objc_autoreleasePoolPush();
      if (qword_100219F60) {
        [qword_100219F60 WFLog:@"%s: AWDL bringup requested while link state is down." message:@"WiFiDeviceManagerStartAwdl"];
      }
      objc_autoreleasePoolPop(v12);
    }

    if (!*(_DWORD *)(a1 + 5408))
    {
      __int128 v20 = objc_autoreleasePoolPush();
      if (qword_100219F60) {
        objc_msgSend( (id)qword_100219F60,  "WFLog:message:",  3,  "%s: unable to start AWDL, thermal index (%d) is below disabled threshold (%d).",  "WiFiDeviceManagerStartAwdl",  *(unsigned int *)(a1 + 5408),  0);
      }
      goto LABEL_33;
    }

    if (*(_BYTE *)(a1 + 3400) && CFDictionaryGetValue(a3, @"APPLE80211KEY_AWDL_INFO_ASSISTED_DISCOVERY_FOLLOW"))
    {
      uint64_t v13 = objc_autoreleasePoolPush();
      if (qword_100219F60) {
        [qword_100219F60 WFLog:@"%s: unable to start AWDL in follow mode, VoIP Call Active." message:3];
      }
      CFTypeRef v14 = v13;
      goto LABEL_34;
    }

    if (*(void *)(a1 + 5400))
    {
      BOOL v17 = objc_autoreleasePoolPush();
      if (([*(id *)(a1 + 5400) isPowerResourceAvailable:1] & 1) == 0)
      {
        CFIndex v26 = malloc(0x38uLL);
        if (v26)
        {
          CFStringRef v27 = v26;
          void *v26 = a1;
          v26[1] = a4;
          v26[5] = a5;
          __int128 v26[2] = CFRetain(a2);
          if (a3) {
            CFTypeRef v28 = CFRetain(a3);
          }
          else {
            CFTypeRef v28 = 0LL;
          }
          v27[3] = v28;
          *((_DWORD *)v27 + _Block_object_dispose((const void *)(v1 - 200), 8) = 4;
          if (a6) {
            CFTypeRef v32 = CFRetain(a6);
          }
          else {
            CFTypeRef v32 = 0LL;
          }
          void v27[6] = v32;
          __int128 v33 = objc_autoreleasePoolPush();
          if (qword_100219F60) {
            [qword_100219F60 WFLog:@"WiFiBatteryMgmt :  Power module is attached - checking for resource availability before starting AWDL."];
          }
          objc_autoreleasePoolPop(v33);
          uint64_t v16 = (uint64_t)[*(id *)(a1 + 5400) requestPowerResource:1 withDetails:v27];
          objc_autoreleasePoolPop(v17);
          if ((_DWORD)v16)
          {
            CFDateRef v34 = (const void *)v27[2];
            if (v34)
            {
              CFRelease(v34);
              v27[2] = 0LL;
            }

            uint64_t v35 = (const void *)v27[3];
            if (v35)
            {
              CFRelease(v35);
              v27[3] = 0LL;
            }

            BOOL v36 = (const void *)v27[6];
            if (v36)
            {
              CFRelease(v36);
              void v27[6] = 0LL;
            }

            free(v27);
          }
        }

        else
        {
          objc_autoreleasePoolPop(v17);
          return 4294963395LL;
        }

        return v16;
      }

      objc_autoreleasePoolPop(v17);
    }

    int v18 = sub_1000500D4(*(void *)(a1 + 64), a2, 0LL);
    int v19 = v18;
    if (a3)
    {
      if (*(_DWORD *)(a1 + 5416))
      {
        if (v18)
        {
          if (CFDictionaryGetValue(a3, @"AWDL_INFO_ASSISTED_DISCOVERY_METRIC"))
          {
            if (!sub_1000DF3D8(a1))
            {
              if (sub_1000DF3FC(a1))
              {
                CFAbsoluteTime v38 = sub_1000E6404(a1, 2);
                if (v38)
                {
                  uint64_t v39 = v38;
                  if (sub_1000E6064(a1, a2, v38, 0LL, 0LL))
                  {
                    CFRelease(v39);
                    char v40 = objc_autoreleasePoolPush();
                    if (qword_100219F60) {
                      [qword_100219F60 WFLog:@"Error trying to stop AWDL in Follow Mode."];
                    }
                  }

                  else
                  {
                    CFSetRemoveValue(*(CFMutableSetRef *)(a1 + 3312), v39);
                    char v40 = objc_autoreleasePoolPush();
                    if (qword_100219F60) {
                      [qword_100219F60 WFLog:@"%s: AWDL in Follow Mode. Exit Follow Mode" message:3];
                    }
                  }

                  objc_autoreleasePoolPop(v40);
                }
              }
            }
          }
        }
      }
    }

    if (*(_DWORD *)(a1 + 5416) && v19)
    {
      if (a3
        && CFDictionaryGetValue(a3, @"APPLE80211KEY_AWDL_INFO_ASSISTED_DISCOVERY_FOLLOW")
        && sub_1000DF3D8(a1))
      {
        __int128 v20 = objc_autoreleasePoolPush();
        if (qword_100219F60) {
          objc_msgSend( (id)qword_100219F60,  "WFLog:message:",  3,  "%s: AWDL is already started in Assisted Discovery. Follow Mode not allowed. Refcount=%d",  "WiFiDeviceManagerStartAwdl",  *(unsigned int *)(a1 + 5416),  v50);
        }
LABEL_33:
        CFTypeRef v14 = v20;
LABEL_34:
        objc_autoreleasePoolPop(v14);
        return 4294963366LL;
      }

      int v29 = objc_autoreleasePoolPush();
      if (qword_100219F60) {
        [qword_100219F60 WFLog:@"%s: AWDL is already started. Refcount=%d. Invoking client network started callback." message:3, @"WiFiDeviceManagerStartAwdl", *(unsigned int *)(a1 + 5416)];
      }
      objc_autoreleasePoolPop(v29);
      if (*(void *)(a1 + 240))
      {
        v52[0] = 0LL;
        v52[1] = v52;
        v52[2] = 0x2020000000LL;
        CFTypeRef v53 = (CFTypeRef)0xAAAAAAAAAAAAAAAALL;
        CFTypeRef v53 = CFRetain(a2);
        CFRetain((CFTypeRef)a1);
        uint64_t v30 = *(dispatch_queue_s **)(a1 + 240);
        block[0] = _NSConcreteStackBlock;
        block[1] = 3221225472LL;
        block[2] = sub_1000E652C;
        block[3] = &unk_1001E2710;
        void block[4] = v52;
        void block[5] = a1;
        void block[6] = a4;
        void block[7] = a5;
        dispatch_async(v30, block);
        _Block_object_dispose(v52, 8);
      }

      else
      {
        CFNumberRef v37 = objc_autoreleasePoolPush();
        if (qword_100219F60) {
          [qword_100219F60 WFLog:@"%s: null queue." message:4];
        }
        objc_autoreleasePoolPop(v37);
      }

      goto LABEL_92;
    }

    if (sub_1000DCBFC(a1, 2LL))
    {
      if (!sub_10004FF60(*(void *)(a1 + 64), a2))
      {
        char v22 = objc_autoreleasePoolPush();
        if (qword_100219F60) {
          [qword_100219F60 WFLog:@"%s: AWDL bringup requested while link state is down." message:4];
        }
        objc_autoreleasePoolPop(v22);
      }

      uint64_t v23 = malloc(0x38uLL);
      if (v23)
      {
        uint64_t v24 = (uint64_t)v23;
        void *v23 = a1;
        v23[1] = a4;
        v23[5] = a5;
        if (a3) {
          CFTypeRef v25 = CFRetain(a3);
        }
        else {
          CFTypeRef v25 = 0LL;
        }
        *(void *)(v24 + 24) = v25;
        *(_DWORD *)(v24 + 32) = 4;
        if (a6) {
          CFTypeRef v41 = CFRetain(a6);
        }
        else {
          CFTypeRef v41 = 0LL;
        }
        *(void *)(v24 + 4_Block_object_dispose((const void *)(v1 - 200), 8) = v41;
        uint64_t v42 = objc_autoreleasePoolPush();
        if (qword_100219F60) {
          [qword_100219F60 WFLog:@"__WiFiDeviceManagerRequestAwdlBringup: hosting AWDL session. Aborting auto-join"];
        }
        objc_autoreleasePoolPop(v42);
        sub_1000D0428(a1);
        sub_100051010(*(void *)(a1 + 64));
        uint64_t v43 = sub_1000464BC(*(void *)(a1 + 64), a2, a3, (uint64_t)sub_10010DE60, v24, a6);
        if (!(_DWORD)v43)
        {
          *(_BYTE *)(a1 + 5421) = 1;
          sub_1000CF880(a1, 2, 1);
LABEL_92:
          ++*(_DWORD *)(a1 + 5416);
          double v47 = objc_autoreleasePoolPush();
          if (qword_100219F60) {
            [qword_100219F60 WFLog:@"%s: AWDL refCount is now [%d].", @"WiFiDeviceManagerStartAwdl", *(unsigned int *)(a1 + 5416)];
          }
          objc_autoreleasePoolPop(v47);
          if (*(_DWORD *)(a1 + 5416) != 1) {
            return 0LL;
          }
          uint64_t v48 = *(void **)(a1 + 5424);
          if (v48) {

          }
          uint64_t v16 = 0LL;
          *(void *)(a1 + 5424) = sub_10003AFF4((uint64_t)"WiFiDeviceManagerStartAwdl");
          return v16;
        }

        uint64_t v16 = v43;
        uint64_t v44 = *(const void **)(v24 + 24);
        if (v44)
        {
          CFRelease(v44);
          *(void *)(v24 + 24) = 0LL;
        }

        double v45 = *(const void **)(v24 + 48);
        if (v45) {
          CFRelease(v45);
        }
        free((void *)v24);
        CLLocationDegrees v46 = objc_autoreleasePoolPush();
        if (qword_100219F60) {
          [qword_100219F60 WFLog:@"__WiFiDeviceManagerRequestAwdlBringup: error bringing up AWDL session. Re-enabling auto-join"];
        }
        objc_autoreleasePoolPop(v46);
        *(_DWORD *)(a1 + 192) = 10;
        if (_os_feature_enabled_impl("CoreWiFi", "UnifiedAutoJoin"))
        {
          sub_1000F5F98(a1, 9uLL);
        }

        else
        {
          [+[WiFiXPCManager sharedXPCManager](WiFiXPCManager, "sharedXPCManager") autoJoinStartedWithTrigger:9 interfaceName:sub_100043E8C(*(void *)(a1 + 64))];
          sub_1000D0A5C(a1, 2LL, (uint64_t)"__WiFiDeviceManagerRequestAwdlBringup");
        }
      }

      else
      {
        uint64_t v16 = 4294963395LL;
      }
    }

    else
    {
      uint64_t v31 = objc_autoreleasePoolPush();
      if (qword_100219F60) {
        [qword_100219F60 WFLog:@"__WiFiDeviceManagerRequestAwdlBringup: unable to start AWDL due to concurrency."];
      }
      objc_autoreleasePoolPop(v31);
      uint64_t v16 = 82LL;
    }

    unsigned int v49 = objc_autoreleasePoolPush();
    if (qword_100219F60) {
      [qword_100219F60 WFLog:@"%s: error bringing up AWDL (=%d)", @"WiFiDeviceManagerStartAwdl", v16];
    }
    objc_autoreleasePoolPop(v49);
  }

  else
  {
    id v15 = objc_autoreleasePoolPush();
    if (qword_100219F60) {
      [qword_100219F60 WFLog:@"%s: unable to start AWDL due to concurrency." message:3];
    }
    objc_autoreleasePoolPop(v15);
    return 82LL;
  }

  return v16;
}

void sub_1000E5DFC( _Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, ...)
{
}

uint64_t sub_1000E5E14(uint64_t a1, const void *a2, int a3, uint64_t a4, uint64_t a5)
{
  int valuePtr = 0;
  if (a3 == 2) {
    int v9 = 3;
  }
  else {
    int v9 = a3;
  }
  CFNumberRef v10 = sub_1000DEFF8(a1);
  if (!v10) {
    return 4294963394LL;
  }
  __n128 v11 = v10;
  if (CFArrayGetCount(v10) < 1) {
    goto LABEL_11;
  }
  CFIndex v12 = 0LL;
  while (1)
  {
    ValueAtIndex = CFArrayGetValueAtIndex(v11, v12);
    if (ValueAtIndex)
    {
      uint64_t v14 = (uint64_t)ValueAtIndex;
      id v15 = (const __CFNumber *)sub_1000951FC((uint64_t)ValueAtIndex, @"networkRole");
      if (v15)
      {
        CFNumberGetValue(v15, kCFNumberSInt32Type, &valuePtr);
        if (valuePtr == v9) {
          break;
        }
      }
    }

    if (CFArrayGetCount(v11) <= ++v12) {
      goto LABEL_11;
    }
  }

  int v18 = (const __CFArray *)sub_100094E60((uint64_t)kCFAllocatorDefault, v14);
  if (v18)
  {
    int v19 = v18;
    uint64_t v16 = sub_1000E5F48(a1, a2, v18, a4, a5);
    CFRelease(v11);
    __n128 v11 = v19;
  }

  else
  {
LABEL_11:
    uint64_t v16 = 4294963394LL;
  }

  CFRelease(v11);
  return v16;
}

uint64_t sub_1000E5F48(uint64_t a1, const void *a2, void *value, uint64_t a4, uint64_t a5)
{
  if (!value) {
    return 4294963396LL;
  }
  if (!CFSetContainsValue(*(CFSetRef *)(a1 + 3312), value)) {
    return 4294963396LL;
  }
  CFNumberRef v10 = CFSetGetValue(*(CFSetRef *)(a1 + 3312), value);
  __n128 v11 = (const __CFNumber *)sub_1000951FC((uint64_t)v10, @"networkRole");
  if (!v11) {
    return 4294963394LL;
  }
  int valuePtr = -1431655766;
  CFNumberGetValue(v11, kCFNumberSInt32Type, &valuePtr);
  if (valuePtr == 1)
  {
    sub_1000E4A8C(a1, a2, (uint64_t)v10, a4, a5);
    return 0LL;
  }

  if ((valuePtr & 0xFFFFFFFE) == 2)
  {
    sub_1000DBA44(a1, a2, v10, a4, a5);
    return 0LL;
  }

  if (valuePtr == 4) {
    return sub_1000E6064(a1, a2, v10, a4, a5);
  }
  else {
    return 4294963396LL;
  }
}

uint64_t sub_1000E6064(uint64_t a1, const void *a2, const void *a3, uint64_t a4, uint64_t a5)
{
  int v5 = *(_DWORD *)(a1 + 5416);
  if (!v5) {
    return 4294963396LL;
  }
  *(_DWORD *)(a1 + 5416) = v5 - 1;
  __n128 v11 = objc_autoreleasePoolPush();
  if (qword_100219F60) {
    [qword_100219F60 WFLog:@"%s: AWDL refCount is now [%d].", @"WiFiDeviceManagerStopAwdl", *(unsigned int *)(a1 + 5416)];
  }
  objc_autoreleasePoolPop(v11);
  if (*(_DWORD *)(a1 + 5416))
  {
    if (a4 && *(void *)(a1 + 240))
    {
      CFRetain((CFTypeRef)a1);
      CFIndex v12 = *(dispatch_queue_s **)(a1 + 240);
      block[0] = _NSConcreteStackBlock;
      block[1] = 3221225472LL;
      block[2] = sub_1000E6654;
      block[3] = &unk_1001E4CC8;
      void block[4] = a1;
      void block[5] = a4;
      int v23 = 0;
      void block[6] = a2;
      void block[7] = a5;
      dispatch_async(v12, block);
    }

    return 0LL;
  }

  else
  {
    uint64_t v14 = *(void **)(a1 + 5424);
    if (v14) {

    }
    *(void *)(a1 + 5424) = 0LL;
    id v15 = malloc(0x20uLL);
    if (v15)
    {
      uint64_t v16 = v15;
      *id v15 = a1;
      v15[1] = a4;
      v15[3] = a5;
      if (a3) {
        CFTypeRef v17 = CFRetain(a3);
      }
      else {
        CFTypeRef v17 = 0LL;
      }
      v16[2] = v17;
      uint64_t v13 = sub_10004659C(*(uint64_t **)(a1 + 64), a2, a3, (uint64_t)sub_10010E054, (uint64_t)v16);
      *(_DWORD *)(a1 + 192) = 11;
      int v18 = objc_autoreleasePoolPush();
      if (qword_100219F60) {
        [qword_100219F60 WFLog:@"%s: hosted AWDL session is down. Triggering auto-join" message:3];
      }
      objc_autoreleasePoolPop(v18);
      if (_os_feature_enabled_impl("CoreWiFi", "UnifiedAutoJoin"))
      {
        sub_1000F5F98(a1, 9uLL);
        if (!(_DWORD)v13) {
          return v13;
        }
      }

      else
      {
        [+[WiFiXPCManager sharedXPCManager](WiFiXPCManager, "sharedXPCManager") autoJoinStartedWithTrigger:9 interfaceName:sub_100043E8C(*(void *)(a1 + 64))];
        sub_1000D0A5C(a1, 2LL, "__WiFiDeviceManagerRequestAwdlTeardown");
        if (!(_DWORD)v13) {
          return v13;
        }
      }

      int v19 = (const void *)v16[2];
      if (v19) {
        CFRelease(v19);
      }
      free(v16);
    }

    else
    {
      uint64_t v13 = 4294963395LL;
    }

    sub_1000CF880(a1, 2, 0);
    __int128 v20 = objc_autoreleasePoolPush();
    if (qword_100219F60) {
      [qword_100219F60 WFLog:@"%s: error tearing down AWDL (=%d)", @"WiFiDeviceManagerStopAwdl", v13];
    }
    objc_autoreleasePoolPop(v20);
  }

  return v13;
}

uint64_t sub_1000E62DC(uint64_t a1, CFArrayRef theArray)
{
  uint64_t v2 = 0LL;
  if (a1 && theArray)
  {
    if (CFArrayGetCount(theArray) < 1)
    {
      return 0LL;
    }

    else
    {
      uint64_t v2 = 0LL;
      CFIndex v5 = 0LL;
      do
      {
        ValueAtIndex = (void *)CFArrayGetValueAtIndex(theArray, v5);
        if (ValueAtIndex)
        {
          uint64_t v7 = ValueAtIndex;
          uint64_t v8 = sub_100096BF4((uint64_t)ValueAtIndex, @"networkRole");
          uint64_t v9 = *(void *)(a1 + 64);
          if (v8 == (const __CFNumber *)4)
          {
            CFNumberRef v10 = (const void *)sub_100040CF8(v9);
            uint64_t v2 = sub_1000E5F48(a1, v10, v7, 0LL, 0LL);
          }

          else
          {
            __n128 v11 = (const void *)sub_100043E8C(v9);
            uint64_t v2 = sub_1000E5F48(a1, v11, v7, 0LL, 0LL);
            if (!(_DWORD)v2)
            {
              if (((unint64_t)v8 & 0xFFFFFFFFFFFFFFFELL) == 2)
              {
                *(_BYTE *)(a1 + 5211) = 0;
                sub_1000CF880(a1, 4, 0);
              }

              uint64_t v2 = 0LL;
            }
          }
        }

        ++v5;
      }

      while (v5 < CFArrayGetCount(theArray));
    }
  }

  return v2;
}

_WORD *sub_1000E6404(uint64_t a1, int a2)
{
  uint64_t v3 = sub_1000DEFF8(a1);
  if (!v3) {
    return 0LL;
  }
  int v4 = v3;
  int valuePtr = -1431655766;
  if (CFArrayGetCount(v3) < 1)
  {
LABEL_13:
    __n128 v11 = 0LL;
    goto LABEL_14;
  }

  CFIndex v5 = 0LL;
  while (1)
  {
    ValueAtIndex = CFArrayGetValueAtIndex(v4, v5);
    if (!ValueAtIndex) {
      goto LABEL_12;
    }
    uint64_t v7 = (uint64_t)ValueAtIndex;
    uint64_t v8 = (const __CFNumber *)sub_1000951FC((uint64_t)ValueAtIndex, @"networkRole");
    if (!v8) {
      goto LABEL_12;
    }
    CFNumberGetValue(v8, kCFNumberSInt32Type, &valuePtr);
    if (valuePtr != 4) {
      goto LABEL_12;
    }
    if (a2 == 2) {
      break;
    }
    if (a2 == 1)
    {
      uint64_t v9 = v7;
      CFNumberRef v10 = @"AWDL_INFO_ASSISTED_DISCOVERY_METRIC";
      goto LABEL_11;
    }

void sub_1000E652C(uint64_t a1)
{
  uint64_t v2 = *(uint64_t **)(a1 + 40);
  if (v2[30])
  {
    uint64_t v3 = sub_100040538(v2[8], *(const void **)(*(void *)(*(void *)(a1 + 32) + 8LL) + 24LL));
    int valuePtr = 4;
    if (v3)
    {
      CFNumberRef v4 = CFNumberCreate(kCFAllocatorDefault, kCFNumberSInt32Type, &valuePtr);
      if (v4)
      {
        CFNumberRef v5 = v4;
        sub_10009582C((uint64_t)v3, @"networkRole", v4);
        CFRelease(v5);
      }
    }

    uint64_t v6 = *(void (**)(void, void, uint64_t, const void *, void, void))(a1 + 48);
    if (v6)
    {
      if (v3) {
        uint64_t v7 = 0LL;
      }
      else {
        uint64_t v7 = 4294963395LL;
      }
      v6( *(void *)(a1 + 40),  *(void *)(*(void *)(*(void *)(a1 + 32) + 8LL) + 24LL),  v7,  v3,  0LL,  *(void *)(a1 + 56));
    }

    CFRelease(*(CFTypeRef *)(a1 + 40));
    uint64_t v8 = *(const void **)(*(void *)(*(void *)(a1 + 32) + 8LL) + 24LL);
    if (v8)
    {
      CFRelease(v8);
      *(void *)(*(void *)(*(void *)(a1 + 32) + 8LL) + 24LL) = 0LL;
    }

    if (v3) {
      CFRelease(v3);
    }
  }

  else
  {
    CFRelease(v2);
    uint64_t v9 = *(const void **)(*(void *)(*(void *)(a1 + 32) + 8LL) + 24LL);
    if (v9)
    {
      CFRelease(v9);
      *(void *)(*(void *)(*(void *)(a1 + 32) + 8LL) + 24LL) = 0LL;
    }
  }

void sub_1000E6654(uint64_t a1)
{
  uint64_t v2 = *(void **)(a1 + 32);
  if (v2[30])
  {
    (*(void (**)(void))(a1 + 40))();
    uint64_t v2 = *(void **)(a1 + 32);
  }

  CFRelease(v2);
}

uint64_t sub_1000E6694(uint64_t a1, int a2)
{
  *(_DWORD *)(a1 + 344) = a2;
  return 0LL;
}

uint64_t sub_1000E66A0(uint64_t a1, uint64_t a2, double a3)
{
  if (a1 && (*(void *)(a1 + 392) != a2 || *(double *)(a1 + 384) != a3))
  {
    uint64_t v6 = objc_autoreleasePoolPush();
    if (qword_100219F60) {
      [qword_100219F60 WFLog:@"scan throttle set to %ld over %f seconds" message:2 a2:a3];
    }
    objc_autoreleasePoolPop(v6);
    *(void *)(a1 + 392) = a2;
    *(double *)(a1 + 384) = a3;
  }

  return 0LL;
}

uint64_t sub_1000E673C(uint64_t a1, uint64_t a2)
{
  if (!(_DWORD)a2)
  {
    uint64_t v9 = objc_autoreleasePoolPush();
    if (qword_100219F60) {
      [qword_100219F60 WFLog:@"invalid channel %d" message:@"WiFiDeviceManagerIsChannelCoexBlacklisted"];
    }
    goto LABEL_21;
  }

  if (!a1)
  {
    uint64_t v9 = objc_autoreleasePoolPush();
    if (qword_100219F60) {
      [qword_100219F60 WFLog:@"%s: null deviceManager" message:3];
    }
    goto LABEL_21;
  }

  uint64_t v3 = *(const __CFArray **)(a1 + 56);
  if (!v3)
  {
    uint64_t v9 = objc_autoreleasePoolPush();
    if (qword_100219F60) {
      [qword_100219F60 WFLog:@"%s: null blacklistedChannels" message:3, "%s: null blacklistedChannels", "WiFiDeviceManagerIsChannelCoexBlacklisted", v10];
    }
LABEL_21:
    objc_autoreleasePoolPop(v9);
    return 0LL;
  }

  CFNumberRef value = 0LL;
  int valuePtr = 0;
  if (CFArrayGetCount(v3) < 1) {
    return 0LL;
  }
  CFIndex v5 = 0LL;
  while (1)
  {
    ValueAtIndex = (const __CFDictionary *)CFArrayGetValueAtIndex(*(CFArrayRef *)(a1 + 56), v5);
    if (ValueAtIndex)
    {
      CFDictionaryGetValueIfPresent(ValueAtIndex, @"MWS_Channel_Number", (const void **)&value);
      if (value)
      {
        CFNumberGetValue((CFNumberRef)value, kCFNumberIntType, &valuePtr);
        if (valuePtr == (_DWORD)a2) {
          break;
        }
      }
    }

    if (CFArrayGetCount(*(CFArrayRef *)(a1 + 56)) <= ++v5) {
      return 0LL;
    }
  }

  uint64_t v8 = objc_autoreleasePoolPush();
  if (qword_100219F60) {
    [qword_100219F60 WFLog:@"%s: channel %d is a deny-listed coex channel" message:3, @"WiFiDeviceManagerIsChannelCoexBlacklisted", a2];
  }
  objc_autoreleasePoolPop(v8);
  return 1LL;
}

uint64_t sub_1000E68D4(uint64_t a1, const void *a2, const void *a3, uint64_t a4, uint64_t a5)
{
  uint64_t v10 = malloc(0x18uLL);
  void *v10 = a1;
  v10[1] = a4;
  void v10[2] = a5;
  uint64_t v11 = sub_10005064C(*(void *)(a1 + 64), a2, a3, 0LL, (uint64_t)sub_1000E6958, (uint64_t)v10);
  if ((_DWORD)v11) {
    free(v10);
  }
  return v11;
}

void sub_1000E6958(int a1, uint64_t a2, CFArrayRef theArray, int a4, uint64_t a5, uint64_t *a6)
{
  uint64_t v10 = *a6;
  if (theArray && CFArrayGetCount(theArray)) {
    sub_10010D7C8(v10, theArray);
  }
  uint64_t v11 = (void (*)(uint64_t, uint64_t, CFArrayRef, uint64_t, uint64_t))a6[1];
  if (v11) {
    v11(v10, a2, theArray, a5, a6[2]);
  }
  free(a6);
}

void sub_1000E69D4(uint64_t a1, const void *a2)
{
  if (!a1)
  {
    CFIndex v12 = objc_autoreleasePoolPush();
    if (qword_100219F60) {
      [qword_100219F60 WFLog:@"%s: null manager" message:3];
    }
    goto LABEL_25;
  }

  CFIndex Count = CFArrayGetCount(*(CFArrayRef *)(a1 + 3616));
  uint64_t v5 = CFArrayGetCount(*(CFArrayRef *)(a1 + 3624)) + Count;
  if (!v5)
  {
    CFIndex v12 = objc_autoreleasePoolPush();
    if (qword_100219F60) {
      [qword_100219F60 WFLog:@"__WiFiDeviceManagerFindMergeHS20Account: No HS2.0 accounts"];
    }
LABEL_25:
    objc_autoreleasePoolPop(v12);
    return;
  }

  MutableCFStringRef Copy = CFArrayCreateMutableCopy(kCFAllocatorDefault, 0LL, *(CFArrayRef *)(a1 + 3616));
  if (CFArrayGetCount(*(CFArrayRef *)(a1 + 3624)))
  {
    uint64_t v7 = *(const __CFArray **)(a1 + 3624);
    v13.length = CFArrayGetCount(v7);
    v13.location = 0LL;
    CFArrayAppendArray(MutableCopy, v7, v13);
  }

  if (!a2 || sub_10009D344((uint64_t)a2) || v5 < 1)
  {
LABEL_17:
    if (MutableCopy) {
LABEL_18:
    }
      CFRelease(MutableCopy);
  }

  else
  {
    CFIndex v8 = 0LL;
    while (1)
    {
      ValueAtIndex = (void *)CFArrayGetValueAtIndex(MutableCopy, v8);
      if (ValueAtIndex)
      {
        uint64_t v10 = ValueAtIndex;
        if (!sub_100099E30(ValueAtIndex))
        {
          uint64_t v11 = objc_autoreleasePoolPush();
          if (qword_100219F60) {
            [(id)qword_100219F60 WFLog:3, "%s: provisioned HS2.0 account %@ has no credentials.", "__WiFiDeviceManagerFindMergeHS20Account", sub_100095BC8(v10) message];
          }
          objc_autoreleasePoolPop(v11);
          goto LABEL_17;
        }
      }

      if (v5 == ++v8) {
        goto LABEL_17;
      }
    }

    sub_10009D31C((uint64_t)a2, 1);
    sub_100095524((uint64_t)a2, (uint64_t)v10);
    if (MutableCopy) {
      goto LABEL_18;
    }
  }

uint64_t sub_1000E6BD4(uint64_t a1, uint64_t a2, uint64_t a3, const __CFArray *a4)
{
  return sub_1000506F8(*(void *)(a1 + 64), a2, a3, a4);
}

uint64_t sub_1000E6BDC(uint64_t a1, uint64_t a2, uint64_t a3)
{
  return sub_100046F6C(*(void *)(a1 + 64), a2, a3);
}

uint64_t sub_1000E6BE4(uint64_t a1, uint64_t a2, int a3, uint64_t a4)
{
  return sub_100050AAC(*(void *)(a1 + 64), a2, a3, a4);
}

uint64_t sub_1000E6BEC(uint64_t a1, const void *a2, const __CFArray *a3, uint64_t a4, uint64_t a5, double a6)
{
  CFIndex v12 = malloc(0x18uLL);
  if (CFArrayGetCount(a3) >= 1)
  {
    CFIndex v13 = 0LL;
    int v14 = 0;
    do
    {
      ValueAtIndex = (const __CFDictionary *)CFArrayGetValueAtIndex(a3, v13);
      if (ValueAtIndex)
      {
        CFBooleanRef Value = (const __CFNumber *)CFDictionaryGetValue( ValueAtIndex,  @"APPLE80211KEY_AWDL_INFO_ASSISTED_DISCOVERY_FOLLOW");
        if (Value)
        {
          char valuePtr = -86;
          CFNumberGetValue(Value, kCFNumberSInt8Type, &valuePtr);
          if (valuePtr) {
            int v14 = 1;
          }
        }
      }

      ++v13;
    }

    while (CFArrayGetCount(a3) > v13);
    if (*(_BYTE *)(a1 + 3400) && v14)
    {
      CFTypeRef v17 = objc_autoreleasePoolPush();
      if (qword_100219F60) {
        [qword_100219F60 WFLog:@"%s: unable to start Ranging in follow mode, VoIP Call Active." message:3];
      }
      objc_autoreleasePoolPop(v17);
      goto LABEL_15;
    }

    if (v14 && sub_1000DF3D8(a1))
    {
LABEL_15:
      uint64_t v18 = 4294963366LL;
LABEL_17:
      free(v12);
      return v18;
    }
  }

  void *v12 = a1;
  v12[1] = a4;
  unsigned int v12[2] = a5;
  uint64_t v18 = sub_1000509CC(*(void *)(a1 + 64), a2, a3, (uint64_t)sub_1000E6DC0, (uint64_t)v12, a6);
  if ((_DWORD)v18) {
    goto LABEL_17;
  }
  if (a3 && *(void *)(a1 + 7320))
  {
    if (CFArrayGetCount(a3))
    {
      id v20 = objc_msgSend( -[__CFArray objectAtIndex:](a3, "objectAtIndex:", 0),  "objectForKey:",  @"RANGING_NUM_MEASUREMENTS");
      uint64_t v21 = *(void **)(a1 + 7320);
      if (v20) {
        id v22 = [v20 unsignedIntegerValue];
      }
      else {
        id v22 = 0LL;
      }
      [v21 rangingStartedWithNumMeasurements:v22];
    }

    return 0LL;
  }

  return v18;
}

void sub_1000E6DC0(int a1, uint64_t a2, uint64_t a3, uint64_t a4, void *a5)
{
  uint64_t v6 = (void (*)(void, uint64_t, uint64_t, uint64_t, void))a5[1];
  if (v6) {
    v6(*a5, a2, a3, a4, a5[2]);
  }
  free(a5);
}

uint64_t sub_1000E6DF4(uint64_t a1, uint64_t a2)
{
  if (!a1)
  {
    int v14 = objc_autoreleasePoolPush();
    if (qword_100219F60) {
      [qword_100219F60 WFLog:@"%s: null manager." message:3];
    }
    id v15 = v14;
    goto LABEL_29;
  }

  if (*(_DWORD *)(a1 + 5408) == (_DWORD)a2)
  {
    uint64_t v16 = objc_autoreleasePoolPush();
    if (qword_100219F60) {
      [qword_100219F60 WFLog:@"%s: thermal index unchanged (%d)." message:@"WiFiDeviceManagerSetThermalIndex" 3];
    }
    id v15 = v16;
LABEL_29:
    objc_autoreleasePoolPop(v15);
    return 0LL;
  }

  *(_DWORD *)(a1 + 540_Block_object_dispose(va, 8) = a2;
  sub_1000E7090(a1, 1);
  if (*(_DWORD *)(a1 + 5408))
  {
    if (*(_BYTE *)(a1 + 3297))
    {
      CFNumberRef v4 = objc_autoreleasePoolPush();
      if (qword_100219F60) {
        [qword_100219F60 WFLog:@"%s: resource has become available for auto-join. Triggering auto-join..." message:3];
      }
      objc_autoreleasePoolPop(v4);
      if (_os_feature_enabled_impl("CoreWiFi", "UnifiedAutoJoin"))
      {
        sub_1000F5F98(a1, 0x16uLL);
      }

      else
      {
        [+[WiFiXPCManager sharedXPCManager](WiFiXPCManager, "sharedXPCManager") autoJoinStartedWithTrigger:22 interfaceName:sub_100043E8C(*(void *)(a1 + 64))];
        sub_1000D0A5C(a1, 2LL, (uint64_t)"WiFiDeviceManagerSetThermalIndex");
      }
    }
  }

  else
  {
    uint64_t v5 = (const void *)sub_100043E8C(*(void *)(a1 + 64));
    uint64_t v6 = sub_1000DEA34(a1, v5, 1);
    if (v6)
    {
      uint64_t v7 = v6;
      CFIndex v8 = objc_autoreleasePoolPush();
      if (qword_100219F60) {
        [qword_100219F60 WFLog:@"%s: resource no longer available for association. Disassociating..." message:3];
      }
      objc_autoreleasePoolPop(v8);
      uint64_t v9 = (const void *)sub_100043E8C(*(void *)(a1 + 64));
      sub_1000CE074(a1, v9, 1006LL, "WiFiDeviceManagerSetThermalIndex", 27426LL);
      CFRelease(v7);
    }

    if (*(_BYTE *)(a1 + 3297))
    {
      uint64_t v10 = objc_autoreleasePoolPush();
      if (qword_100219F60) {
        [qword_100219F60 WFLog:@"%s: resource no longer available for auto-join. Aborting..." message:3];
      }
      objc_autoreleasePoolPop(v10);
      sub_1000D0428(a1);
    }

    if (*(_DWORD *)(a1 + 5416))
    {
      uint64_t v11 = *(void **)(a1 + 5424);
      if (v11) {

      }
      *(void *)(a1 + 5424) = 0LL;
      CFIndex v12 = (const void *)sub_100040CF8(*(void *)(a1 + 64));
      sub_1000D00D8(a1, v12);
    }
  }

  return sub_100050C44(*(void *)(a1 + 64), a2);
}

void sub_1000E7090(uint64_t a1, int a2)
{
  if (*(void *)(a1 + 4432))
  {
    CFNumberRef v4 = (const __CFString *)sub_100040CF8(*(void *)(a1 + 64));
    uint64_t v5 = sub_1000DF0C8(a1, v4);
    if (v5)
    {
      uint64_t v6 = v5;
      MutableCFStringRef Copy = CFDictionaryCreateMutableCopy(kCFAllocatorDefault, 0LL, v5);
      CFRelease(v6);
      if (MutableCopy)
      {
        uint64_t v8 = *(void *)(a1 + 64);
        uint64_t v9 = (const __CFString *)sub_100040CF8(v8);
        int v10 = sub_10004FF60(v8, v9);
        int v11 = 0;
        if (a2) {
          BOOL v12 = 1;
        }
        else {
          BOOL v12 = *(void *)(a1 + 5400) == 0LL;
        }
        int v13 = v12;
        if (v10 && v13) {
          int v11 = *(_DWORD *)(a1 + 5408) != 0;
        }
        CFBooleanRef Value = (const __CFBoolean *)CFDictionaryGetValue(MutableCopy, @"LINK_CHANGED_IS_AVAILABLE");
        if (Value)
        {
          if (CFBooleanGetValue(Value) == v11)
          {
LABEL_23:
            CFRelease(MutableCopy);
            return;
          }
        }

        else
        {
          id v15 = objc_autoreleasePoolPush();
          if (qword_100219F60) {
            [qword_100219F60 WFLog:@"%s: availabilityRef was NULL, so sending the awdl state info to client." message:3];
          }
          objc_autoreleasePoolPop(v15);
        }

        uint64_t v16 = (const void **)&kCFBooleanTrue;
        if (!v11) {
          uint64_t v16 = (const void **)&kCFBooleanFalse;
        }
        CFDictionarySetValue(MutableCopy, @"LINK_CHANGED_IS_AVAILABLE", *v16);
        CFTypeRef v17 = *(void (**)(uint64_t, int64_t, void, const __CFDictionary *))(a1 + 4432);
        int64_t v18 = sub_100040CF8(*(void *)(a1 + 64));
        v17(a1, v18, *(void *)(a1 + 4440), MutableCopy);
        goto LABEL_23;
      }
    }
  }

uint64_t sub_1000E7210(uint64_t a1, uint64_t a2, CFDictionaryRef theDict, CFMutableDictionaryRef *a4)
{
  int valuePtr = -1431655766;
  CFBooleanRef Value = (const __CFNumber *)CFDictionaryGetValue(theDict, @"DebugModule");
  if (!Value) {
    return sub_1000511FC(*(void *)(a1 + 64), a2, theDict, a4);
  }
  CFNumberGetValue(Value, kCFNumberIntType, &valuePtr);
  switch(valuePtr)
  {
    case 3:
      if (!a1)
      {
        uint64_t v30 = objc_autoreleasePoolPush();
        unsigned int v83 = (void *)qword_100219F60;
        if (!qword_100219F60) {
          goto LABEL_62;
        }
        unsigned int v84 = "__WiFiDeviceManagerDebugAutoJoin";
        goto LABEL_178;
      }

      if (theDict)
      {
        uint64_t v9 = (const __CFNumber *)CFDictionaryGetValue(theDict, @"DebugCommand");
        if (!v9) {
          return 4294963396LL;
        }
        unsigned int v94 = -1431655766;
        CFNumberGetValue(v9, kCFNumberIntType, &v94);
        switch(v94)
        {
          case 0u:
            int v10 = objc_autoreleasePoolPush();
            if (qword_100219F60) {
              [(id)qword_100219F60 WFLog:4 message:"Dumping Auto-Join Stats"];
            }
            objc_autoreleasePoolPop(v10);
            MutableCFStringRef Copy = sub_10010E0E0((id *)a1);
            goto LABEL_41;
          case 1u:
            char v63 = objc_autoreleasePoolPush();
            if (qword_100219F60) {
              [(id)qword_100219F60 WFLog:4 message:"Reset Auto-Join Stats"];
            }
            objc_autoreleasePoolPop(v63);
            bzero((void *)(a1 + 5608), 0x238uLL);
            goto LABEL_156;
          case 4u:
            *(_BYTE *)(a1 + 34) = 0;
            uint64_t v64 = objc_autoreleasePoolPush();
            id v65 = (void *)qword_100219F60;
            if (!qword_100219F60) {
              goto LABEL_103;
            }
            BOOL v66 = "Enabled Periodic 5Ghz Scan";
            goto LABEL_102;
          case 5u:
            *(_BYTE *)(a1 + 34) = 1;
            uint64_t v64 = objc_autoreleasePoolPush();
            id v65 = (void *)qword_100219F60;
            if (!qword_100219F60) {
              goto LABEL_103;
            }
            BOOL v66 = "Disabled Periodic 5Ghz Scan";
            goto LABEL_102;
          case 6u:
            *(_BYTE *)(a1 + 5601) = 0;
            uint64_t v64 = objc_autoreleasePoolPush();
            id v65 = (void *)qword_100219F60;
            if (!qword_100219F60) {
              goto LABEL_103;
            }
            BOOL v66 = "Considering geotags for 5Ghz Scan";
            goto LABEL_102;
          case 7u:
            *(_BYTE *)(a1 + 5601) = 1;
            uint64_t v64 = objc_autoreleasePoolPush();
            id v65 = (void *)qword_100219F60;
            if (!qword_100219F60) {
              goto LABEL_103;
            }
            BOOL v66 = "Not considering geotags for 5Ghz Scan";
LABEL_102:
            [v65 WFLog:3 message:v66];
LABEL_103:
            CFNumberRef v67 = v64;
            goto LABEL_155;
          case 8u:
            unsigned int v93 = 0;
            uint64_t v68 = (const __CFNumber *)CFDictionaryGetValue(theDict, @"DebugCommandValueDict");
            if (v68 && CFNumberGetValue(v68, kCFNumberSInt32Type, &v93))
            {
              *(_DWORD *)(a1 + 132) = v93;
              id v15 = objc_autoreleasePoolPush();
              if (qword_100219F60) {
                [qword_100219F60 WFLog:@"message" message:[NSString stringWithFormat:@"%s Using Debug Value for AutoJoinUnreliableNwRssiThres = %d", "__WiFiDeviceManagerDebugAutoJoin", v93]];
              }
              goto LABEL_161;
            }

            id v15 = objc_autoreleasePoolPush();
            if (qword_100219F60) {
              [qword_100219F60 WFLog:@"%s DebugCmdAutoJoinUnreliableNwRssiThres valRef is NULL" message:4];
            }
            goto LABEL_18;
          case 9u:
            unsigned int v93 = 0;
            uint64_t v69 = (const __CFNumber *)CFDictionaryGetValue(theDict, @"DebugCommandValueDict");
            if (v69 && CFNumberGetValue(v69, kCFNumberSInt32Type, &v93))
            {
              *(_DWORD *)(a1 + 136) = v93;
              id v15 = objc_autoreleasePoolPush();
              if (qword_100219F60) {
                [qword_100219F60 WFLog:@"message" message:[NSString stringWithFormat:@"%s Using Debug Value for AutoJoinPnoRssiThres = %d", "__WiFiDeviceManagerDebugAutoJoin", v93]];
              }
              goto LABEL_161;
            }

            id v15 = objc_autoreleasePoolPush();
            if (qword_100219F60) {
              [qword_100219F60 WFLog:@"%s DebugCmdAutoJoinPnoRssiThres valRef is NULL" message:4];
            }
            goto LABEL_18;
          case 0xAu:
            unsigned int v93 = 0;
            unsigned int v70 = (const __CFNumber *)CFDictionaryGetValue(theDict, @"DebugCommandValueDict");
            if (v70 && CFNumberGetValue(v70, kCFNumberSInt32Type, &v93))
            {
              *(_DWORD *)(a1 + 140) = v93;
              id v15 = objc_autoreleasePoolPush();
              if (qword_100219F60) {
                [qword_100219F60 WFLog:@"message" message:3, "%s Using Debug Value for AutoJoinDrivingRssiThres = %d", "__WiFiDeviceManagerDebugAutoJoin", v93];
              }
              goto LABEL_161;
            }

            id v15 = objc_autoreleasePoolPush();
            if (qword_100219F60) {
              [qword_100219F60 WFLog:@"%s DebugCmdAutoJoinDrivingRssiThres valRef is NULL" message:4];
            }
            goto LABEL_18;
          case 0xBu:
            if (!CFDictionaryContainsValue(theDict, @"DebugCommandValueDict"))
            {
              *(_BYTE *)(a1 + 36) = CFDictionaryGetValue(theDict, @"DebugCommandValueDict") == kCFBooleanTrue;
              int v71 = objc_autoreleasePoolPush();
              if (qword_100219F60)
              {
                if (*(_BYTE *)(a1 + 36)) {
                  CFRange v72 = "Disabled";
                }
                else {
                  CFRange v72 = "Enabled";
                }
                [qword_100219F60 WFLog:@"message: 3 %s Using Debug Value for 24GhzAJScanDuringBTAndDriving: 2.4Ghz AJ Scans %s __WiFiDeviceManagerDebugAutoJoin %s"];
              }

              goto LABEL_154;
            }

            uint64_t v30 = objc_autoreleasePoolPush();
            if (qword_100219F60) {
              [qword_100219F60 WFLog:@"DebugCmdDisable24GhzAJScanDuringBTAndDriving no value" message:4];
            }
            goto LABEL_62;
          case 0xCu:
            unsigned int v93 = 0;
            unsigned int v73 = (const __CFNumber *)CFDictionaryGetValue(theDict, @"DebugCommandValueDict");
            if (!v73)
            {
              uint64_t v30 = objc_autoreleasePoolPush();
              if (qword_100219F60) {
                [qword_100219F60 WFLog:@"%s DebugCmdAutoJoinDrivingRssiThres valRef is NULL" message:4];
              }
              goto LABEL_62;
            }

            int v74 = CFNumberGetValue(v73, kCFNumberSInt32Type, &v93);
            CFTypeRef v75 = objc_autoreleasePoolPush();
            if (v74)
            {
              if (qword_100219F60)
              {
                id v76 = "YES";
                if (!v93) {
                  id v76 = "NO";
                }
                [qword_100219F60 WFLog:@"message" message:[NSString stringWithFormat:@"%s Using Debug Value for AutoJoinSimulateScanRSSI: Simulating:%s RSSI:%d", "__WiFiDeviceManagerDebugAutoJoin", v76, v93]];
              }

              objc_autoreleasePoolPop(v75);
              uint64_t v12 = 0LL;
              if (v93)
              {
                *(_DWORD *)(a1 + 44) = v93;
                *(_BYTE *)(a1 + 40) = 1;
              }

              else
              {
                *(_DWORD *)(a1 + 44) = 0;
                *(_BYTE *)(a1 + 40) = 0;
              }

              return v12;
            }

            if (qword_100219F60) {
              [qword_100219F60 WFLog:@"%s DebugCmdAutoJoinDrivingRssiThres valRef is NULL" message:4];
            }
            uint64_t v31 = v75;
            goto LABEL_63;
          case 0xDu:
            if (!CFDictionaryContainsValue(theDict, @"DebugCommandValueDict"))
            {
              *(_BYTE *)(a1 + 4_Block_object_dispose(va, 8) = CFDictionaryGetValue(theDict, @"DebugCommandValueDict") == kCFBooleanTrue;
              int v71 = objc_autoreleasePoolPush();
              if (qword_100219F60)
              {
                if (*(_BYTE *)(a1 + 48)) {
                  uint64_t v77 = "On";
                }
                else {
                  uint64_t v77 = "Off";
                }
                [qword_100219F60 WFLog:@"message: %s Using Debug Value for DebugCmdAutoJoinDrivingCarPlay: Carplay is %s" message:@"__WiFiDeviceManagerDebugAutoJoin" v77];
              }

              goto LABEL_154;
            }

            uint64_t v30 = objc_autoreleasePoolPush();
            if (qword_100219F60) {
              [qword_100219F60 WFLog:@"DebugCmdAutoJoinDrivingCarPlay no value"];
            }
            goto LABEL_62;
          case 0xEu:
            if (!CFDictionaryContainsValue(theDict, @"DebugCommandValueDict"))
            {
              *(_BYTE *)(a1 + 49) = CFDictionaryGetValue(theDict, @"DebugCommandValueDict") == kCFBooleanTrue;
              int v71 = objc_autoreleasePoolPush();
              if (qword_100219F60)
              {
                if (*(_BYTE *)(a1 + 49)) {
                  CFTypeRef v78 = "On";
                }
                else {
                  CFTypeRef v78 = "Off";
                }
                [qword_100219F60 WFLog:@"message" message:@"%s Using Debug Value for DebugCmdBTA2DPEnable: BTA2DP is %s" args:__WiFiDeviceManagerDebugAutoJoin, v78];
              }

              goto LABEL_154;
            }

            uint64_t v30 = objc_autoreleasePoolPush();
            if (qword_100219F60) {
              [qword_100219F60 WFLog:@"%s DebugCmdBTA2DPEnable no value" message:4 v91];
            }
            goto LABEL_62;
          case 0xFu:
            if (!CFDictionaryContainsValue(theDict, @"DebugCommandValueDict"))
            {
              *(_BYTE *)(a1 + 37) = CFDictionaryGetValue(theDict, @"DebugCommandValueDict") == kCFBooleanTrue;
              int v71 = objc_autoreleasePoolPush();
              if (qword_100219F60)
              {
                if (*(_BYTE *)(a1 + 37)) {
                  char v79 = "Enabled";
                }
                else {
                  char v79 = "Disabled";
                }
                [qword_100219F60 WFLog:@"message:3" messageFormat:@"%s Using Debug Value for DebugCmdAutoJoinBTSCODisable: AJ Scans for BTSCO %s" messageArguments:@"__WiFiDeviceManagerDebugAutoJoin" v79];
              }

              goto LABEL_154;
            }

            uint64_t v30 = objc_autoreleasePoolPush();
            if (qword_100219F60) {
              [qword_100219F60 WFLog:@"%s DebugCmdAutoJoinBTSCODisable no value" message:4];
            }
            goto LABEL_62;
          case 0x10u:
            if (CFDictionaryContainsValue(theDict, @"DebugCommandValueDict"))
            {
              uint64_t v30 = objc_autoreleasePoolPush();
              if (qword_100219F60) {
                [qword_100219F60 WFLog:@"%s DebugCmdBTSCOEnable no value" message:4];
              }
              goto LABEL_62;
            }

            *(_BYTE *)(a1 + 50) = CFDictionaryGetValue(theDict, @"DebugCommandValueDict") == kCFBooleanTrue;
            int v71 = objc_autoreleasePoolPush();
            if (qword_100219F60)
            {
              if (*(_BYTE *)(a1 + 50)) {
                uint64_t v80 = "On";
              }
              else {
                uint64_t v80 = "Off";
              }
              [qword_100219F60 WFLog:@"message: %s Using Debug Value for DebugCmdBTSCOEnable: BTSCO is %s" message:@"__WiFiDeviceManagerDebugAutoJoin" v80];
            }

LABEL_154:
            CFNumberRef v67 = v71;
LABEL_155:
            objc_autoreleasePoolPop(v67);
            goto LABEL_156;
          case 0x11u:
            unsigned int v93 = 0;
            id v81 = (const __CFNumber *)CFDictionaryGetValue(theDict, @"DebugCommandValueDict");
            if (!v81 || !CFNumberGetValue(v81, kCFNumberSInt32Type, &v93))
            {
              id v15 = objc_autoreleasePoolPush();
              if (qword_100219F60) {
                [qword_100219F60 WFLog:@"%s DebugCmdTopNetworksRankLimit valRef is NULL" message:4];
              }
              goto LABEL_18;
            }

            *(_DWORD *)(a1 + 144) = v93;
            id v15 = objc_autoreleasePoolPush();
            if (qword_100219F60) {
              [qword_100219F60 WFLog:@"message" message:3, "%s Using Debug Value for DebugCmdTopNetworksRankLimit = %d", "__WiFiDeviceManagerDebugAutoJoin", v93];
            }
LABEL_161:
            uint64_t v12 = 0LL;
            break;
          default:
            goto LABEL_60;
        }

        goto LABEL_162;
      }

      uint64_t v30 = objc_autoreleasePoolPush();
      unsigned int v85 = (void *)qword_100219F60;
      if (!qword_100219F60) {
        goto LABEL_62;
      }
      uint64_t v86 = "__WiFiDeviceManagerDebugAutoJoin";
      goto LABEL_193;
    case 5:
      if (!a1)
      {
        id v15 = objc_autoreleasePoolPush();
        if (qword_100219F60) {
          [qword_100219F60 WFLog:@"%s manager is NULL" message:4 v91];
        }
        goto LABEL_18;
      }

      if (!theDict)
      {
        id v15 = objc_autoreleasePoolPush();
        if (qword_100219F60) {
          [qword_100219F60 WFLog:@"%s request is NULL" message:4 v91];
        }
        goto LABEL_18;
      }

      int v13 = (const __CFNumber *)CFDictionaryGetValue(theDict, @"DebugCommand");
      if (v13)
      {
        unsigned int v94 = -1431655766;
        if (CFNumberGetValue(v13, kCFNumberIntType, &v94))
        {
          unsigned int v14 = v94;
          id v15 = objc_autoreleasePoolPush();
          if (v14)
          {
            if (qword_100219F60) {
              [qword_100219F60 WFLog:@"%s: Unknown debug command %d" message:4];
            }
LABEL_18:
            uint64_t v12 = 4294963396LL;
LABEL_162:
            int v62 = v15;
            goto LABEL_163;
          }

          id v38 = +[WiFiRoamManager sharedWiFiRoamManager](&OBJC_CLASS___WiFiRoamManager, "sharedWiFiRoamManager");
          if (v38)
          {
            uint64_t v39 = v38;
            id v40 = -[__CFDictionary valueForKey:](theDict, "valueForKey:", @"DebugCommandValueDict");
            if (v40)
            {
              CFTypeRef v41 = v40;
              objc_msgSend(objc_msgSend(v40, "valueForKey:", @"minLinkUpWaitSec"), "doubleValue");
              double v43 = v42;
              objc_msgSend(objc_msgSend(v41, "valueForKey:", @"minRetryWaitSec"), "doubleValue");
              double v45 = v44;
              id v46 = objc_msgSend(objc_msgSend(v41, "valueForKey:", @"maxRetriesSec"), "integerValue");
              objc_msgSend(objc_msgSend(v41, "valueForKey:", @"windowSizeSec"), "doubleValue");
              double v48 = v47;
              [v39 setParamMinRoamWaitTimeFromLinkUpInSec:v43];
              [v39 setParamMinRoamRetryWaitTime:v45];
              [v39 setParamMaxRoamRetriesInWindow:v46];
              [v39 setParamWindowSizeInSec:v48];
              unsigned int v49 = objc_autoreleasePoolPush();
              uint64_t v12 = qword_100219F60;
              if (qword_100219F60)
              {
                [v39 paramMinRoamWaitTimeFromLinkUpInSec];
                uint64_t v51 = v50;
                [v39 paramMinRoamRetryWaitTime];
                uint64_t v53 = v52;
                id v54 = [v39 paramMaxRoamRetriesInWindow];
                [v39 paramWindowSizeInSec];
                objc_msgSend( (id)v12,  "WFLog:message:",  3,  "%s: Configuring RoamManager paramMinRoamWaitTimeFromLinkUpInSec: %.1f paramMinRoamRetryWaitTime: %.1f paramMaxRoamRetriesInWindow: %d paramWindowSizeInSec: %.1f",  "__WiFiDeviceManagerDebugRoamMgr",  v51,  v53,  v54,  v55);
                uint64_t v12 = 0LL;
              }

              goto LABEL_80;
            }

            unsigned int v49 = objc_autoreleasePoolPush();
            if (qword_100219F60) {
              [qword_100219F60 WFLog:@"%s kWiFiDebugCommandValueDict is NULL" message:4];
            }
          }

          else
          {
            unsigned int v49 = objc_autoreleasePoolPush();
            if (qword_100219F60) {
              [qword_100219F60 WFLog:@"%s WiFiRoamManager is NULL" message:4];
            }
          }

          uint64_t v12 = 4294963396LL;
LABEL_80:
          objc_autoreleasePoolPop(v49);
          goto LABEL_162;
        }
      }

      return 4294963396LL;
    case 6:
      if (!a1)
      {
        int64_t v18 = objc_autoreleasePoolPush();
        if (qword_100219F60) {
          [qword_100219F60 WFLog:@"%s manager is NULL" message:4 v91];
        }
        goto LABEL_26;
      }

      if (!theDict)
      {
        int64_t v18 = objc_autoreleasePoolPush();
        if (qword_100219F60) {
          [qword_100219F60 WFLog:@"%s request is NULL" message:4 v91];
        }
        goto LABEL_26;
      }

      uint64_t v16 = (const __CFNumber *)CFDictionaryGetValue(theDict, @"DebugCommand");
      if (!v16) {
        return 4294963396LL;
      }
      unsigned int v94 = -1431655766;
      if (!CFNumberGetValue(v16, kCFNumberIntType, &v94)) {
        return 4294963396LL;
      }
      unsigned int v17 = v94;
      int64_t v18 = objc_autoreleasePoolPush();
      if (v17)
      {
        if (qword_100219F60) {
          [qword_100219F60 WFLog:@"%s: Unknown debug command %d" message:4, "%s: Unknown debug command %d",  "__WiFiDeviceManagerDebugSimulateWiFiAssistOverrideCondition",  v94];
        }
LABEL_26:
        uint64_t v12 = 4294963396LL;
        goto LABEL_90;
      }

      id v56 = -[__CFDictionary valueForKey:](theDict, "valueForKey:", @"DebugCommandValueDict");
      if (!v56)
      {
        BOOL v90 = objc_autoreleasePoolPush();
        if (qword_100219F60) {
          [qword_100219F60 WFLog:@"%s kWiFiDebugCommandValueDict is NULL" message:4];
        }
        objc_autoreleasePoolPop(v90);
        goto LABEL_26;
      }

      uint64_t v57 = v56;
      unsigned int v58 = objc_msgSend(objc_msgSend(v56, "valueForKey:", @"movingNetwork"), "intValue");
      unsigned int v59 = objc_msgSend(objc_msgSend(v57, "valueForKey:", @"edgeBssWalkout"), "intValue");
      unsigned int v60 = objc_msgSend(objc_msgSend(v57, "valueForKey:", @"badRepNetwork"), "intValue");
      *(_BYTE *)(a1 + 54) = v60 != 0;
      *(_BYTE *)(a1 + 52) = v58 != 0;
      *(_BYTE *)(a1 + 53) = v59 != 0;
      uint64_t v61 = objc_autoreleasePoolPush();
      if (qword_100219F60) {
        objc_msgSend( (id)qword_100219F60,  "WFLog:message:",  3,  "%s: Simulating wifi-assist conditions badReputationNetwork:%d  movingNetwork:%d edgeBssWalkOut: %d",  "__WiFiDeviceManagerDebugSimulateWiFiAssistOverrideCondition",  *(unsigned __int8 *)(a1 + 54),  *(unsigned __int8 *)(a1 + 52),  *(unsigned __int8 *)(a1 + 53));
      }
      objc_autoreleasePoolPop(v61);
      if (v60 || v58 || v59)
      {
        uint64_t v12 = 0LL;
        *(_BYTE *)(a1 + 55) = 1;
      }

      else
      {
        uint64_t v12 = 0LL;
        *(_BYTE *)(a1 + 55) = 0;
      }

void sub_1000E8474(uint64_t a1, CFDictionaryRef theDict, int a3)
{
  uint64_t v6 = (_BYTE *)(a1 + 5448);
  uint64_t valuePtr = 0LL;
  CFBooleanRef Value = (const __CFNumber *)CFDictionaryGetValue(theDict, @"BGSCAN_CACHE");
  if (Value)
  {
    CFNumberGetValue(Value, kCFNumberIntType, (char *)&valuePtr + 4);
    _BYTE *v6 = BYTE4(valuePtr);
  }

  uint64_t v8 = (const __CFNumber *)CFDictionaryGetValue(theDict, @"BGSCAN_CACHE_WSB_ROLLOVER");
  if (v8)
  {
    CFNumberGetValue(v8, kCFNumberIntType, &valuePtr);
    v6[2] = valuePtr;
  }

  uint64_t v9 = (const __CFArray *)CFDictionaryGetValue(theDict, @"SCAN_CHANNELS");
  if (!v9)
  {
    int v13 = 0LL;
    CFMutableDictionaryRef Mutable = 0LL;
    if (!a3) {
      goto LABEL_17;
    }
    goto LABEL_16;
  }

  int v10 = v9;
  CFMutableDictionaryRef Mutable = CFArrayCreateMutable(kCFAllocatorDefault, 0LL, &kCFTypeArrayCallBacks);
  CFMutableArrayRef v12 = CFArrayCreateMutable(kCFAllocatorDefault, 0LL, &kCFTypeArrayCallBacks);
  int v13 = v12;
  if (Mutable) {
    BOOL v14 = v12 == 0LL;
  }
  else {
    BOOL v14 = 1;
  }
  if (v14) {
    goto LABEL_17;
  }
  uint64_t v15 = *(void *)(a1 + 64);
  uint64_t v16 = (const void *)sub_100043E8C(v15);
  if (CFArrayGetCount(Mutable) >= 1)
  {
    CFIndex v18 = 0LL;
    do
    {
      ValueAtIndex = (const __CFDictionary *)CFArrayGetValueAtIndex(Mutable, v18);
      if (ValueAtIndex)
      {
        id v20 = CFDictionaryGetValue(ValueAtIndex, @"SUP_CHANNEL");
        CFArrayAppendValue(v13, v20);
      }

      ++v18;
    }

    while (CFArrayGetCount(Mutable) > v18);
  }

  CFIndex Count = CFArrayGetCount(v10);
  if (Count < 1)
  {
LABEL_11:
    unsigned int v17 = *(const void **)(a1 + 5440);
    if (v17)
    {
      CFRelease(v17);
      *(void *)(a1 + 5440) = 0LL;
    }

    *(void *)(a1 + 5440) = CFRetain(v10);
    if (!a3)
    {
LABEL_17:
      if (!Mutable) {
        goto LABEL_19;
      }
      goto LABEL_18;
    }

void sub_1000E86EC(uint64_t a1, unsigned int a2)
{
  if (a1)
  {
    uint64_t v3 = *(void *)(a1 + 64);
    CFNumberRef v4 = (const void *)sub_100043E8C(v3);
    sub_10004D80C(v3, v4, a2);
  }

  else
  {
    uint64_t v5 = objc_autoreleasePoolPush();
    if (qword_100219F60) {
      [qword_100219F60 WFLog:@"%s: null deviceManager" message:3];
    }
    objc_autoreleasePoolPop(v5);
  }

void sub_1000E8774(uint64_t a1, const __CFDictionary *a2)
{
  unsigned int valuePtr = 0;
  if (!a1)
  {
    uint64_t v57 = objc_autoreleasePoolPush();
    if (qword_100219F60) {
      [qword_100219F60 WFLog:@"%s: null deviceManager" message:3 v64 v65];
    }
    goto LABEL_85;
  }

  if (!a2)
  {
    uint64_t v57 = objc_autoreleasePoolPush();
    if (qword_100219F60) {
      [qword_100219F60 WFLog:@"%s: null mutableTestParams" message:3 v64 v65];
    }
    goto LABEL_85;
  }

  CFNumberRef v4 = (const __CFString *)sub_10004CE2C(*(void *)(a1 + 64));
  CFBooleanRef Value = (const __CFString *)CFDictionaryGetValue(a2, @"WiFiTestCommandInterfaceName");
  if (!v4)
  {
    uint64_t v57 = objc_autoreleasePoolPush();
    if (qword_100219F60) {
      [qword_100219F60 WFLog:@"Current Interface is Null!"];
    }
    goto LABEL_85;
  }

  uint64_t v6 = Value;
  if (!Value)
  {
    uint64_t v57 = objc_autoreleasePoolPush();
    if (qword_100219F60) {
      [qword_100219F60 WFLog:@"%s:test Interface is Null!"];
    }
    goto LABEL_85;
  }

  if (CFStringCompare(Value, v4, 0LL))
  {
    uint64_t v57 = objc_autoreleasePoolPush();
    if (qword_100219F60) {
      [(id)qword_100219F60 WFLog:3, "%s: ignore this device %@, test interface %@", "WiFiDeviceManagerSetTestParams", v4, v6 message];
    }
    goto LABEL_85;
  }

  uint64_t v7 = (const __CFNumber *)CFDictionaryGetValue(a2, @"WiFiTestCommandType");
  if (!v7)
  {
    uint64_t v57 = objc_autoreleasePoolPush();
    if (qword_100219F60) {
      [qword_100219F60 WFLog:@"%s: null cmdNum" message:3 v64 v65];
    }
LABEL_85:
    objc_autoreleasePoolPop(v57);
    return;
  }

  CFNumberGetValue(v7, kCFNumberIntType, &valuePtr);
  if (valuePtr >= 0xC9)
  {
    sub_10005294C(*(void *)(a1 + 64), a2);
    return;
  }

  CFDictionaryRemoveValue(a2, @"WiFiTestCommandType");
  if (valuePtr == 103)
  {
    char v68 = 0;
    uint64_t v24 = (const void *)sub_10004CE2C(*(void *)(a1 + 64));
    if (v24)
    {
      CFTypeRef v25 = sub_1000DEA34(a1, v24, 1);
      if (v25)
      {
        CFIndex v26 = v25;
        CFStringRef v27 = (const __CFNumber *)CFDictionaryGetValue(a2, @"WiFiTestCommandParamIsEdge");
        if (v27)
        {
          CFNumberGetValue(v27, kCFNumberCharType, &v68);
          char v28 = v68;
        }

        else
        {
          char v28 = 0;
        }

        sub_10001BBC8(*(void *)(a1 + 120), v26, 2LL, v28);
        return;
      }

      unsigned int v58 = objc_autoreleasePoolPush();
      unsigned int v59 = (void *)qword_100219F60;
      if (!qword_100219F60) {
        goto LABEL_97;
      }
      unsigned int v60 = "no current network";
      goto LABEL_96;
    }

    unsigned int v58 = objc_autoreleasePoolPush();
    unsigned int v59 = (void *)qword_100219F60;
    if (!qword_100219F60) {
      goto LABEL_97;
    }
    unsigned int v60 = "interface is NULL!";
LABEL_96:
    [v59 WFLog:4 message:v60];
    goto LABEL_97;
  }

  if (valuePtr != 102)
  {
    if (valuePtr != 101) {
      return;
    }
    uint64_t v8 = (const __CFBoolean *)CFDictionaryGetValue(a2, @"enabled");
    uint64_t v9 = (const __CFNumber *)CFDictionaryGetValue(a2, @"learningPeriod");
    int v10 = (const __CFNumber *)CFDictionaryGetValue(a2, @"expiryPeriod");
    int v11 = (const __CFNumber *)CFDictionaryGetValue(a2, @"envType");
    CFMutableArrayRef v12 = (const __CFNumber *)CFDictionaryGetValue(a2, @"roamTriggerRssi");
    int v13 = (const __CFNumber *)CFDictionaryGetValue(a2, @"roamDelta");
    BOOL v14 = CFDictionaryGetValue(a2, @"voipAndMotionTest");
    uint64_t v15 = (const __CFNumber *)CFDictionaryGetValue(a2, @"voipState");
    uint64_t v16 = a2;
    unsigned int v17 = v8;
    CFIndex v18 = (const __CFNumber *)CFDictionaryGetValue(v16, @"motionState");
    if (v17)
    {
      int v19 = CFBooleanGetValue(v17);
      *(_BYTE *)(a1 + 256) = v19;
      if (!v19)
      {
        id v20 = 0LL;
        CFMutableDictionaryRef v21 = 0LL;
        uint64_t v22 = 0LL;
        uint64_t v23 = 0LL;
        *(_DWORD *)(a1 + 260) = 259200;
        *(void *)(a1 + 264) = 2592000LL;
        *(void *)(a1 + 280) = 0LL;
        *(_DWORD *)(a1 + 287) = 0;
        goto LABEL_62;
      }
    }

    else if (!*(_BYTE *)(a1 + 256))
    {
      return;
    }

    if (v9) {
      CFNumberGetValue(v9, kCFNumberIntType, (void *)(a1 + 260));
    }
    if (v10) {
      CFNumberGetValue(v10, kCFNumberIntType, (void *)(a1 + 264));
    }
    if (v11) {
      CFNumberGetValue(v11, kCFNumberIntType, (void *)(a1 + 268));
    }
    if (v12) {
      CFNumberGetValue(v12, kCFNumberIntType, (void *)(a1 + 280));
    }
    if (v13) {
      CFNumberGetValue(v13, kCFNumberIntType, (void *)(a1 + 284));
    }
    if (v14)
    {
      double v43 = v17;
      CFMutableDictionaryRef v21 = 0LL;
      uint64_t v23 = 0LL;
      uint64_t v22 = 0LL;
      id v20 = 0LL;
      if (v15 && v18)
      {
        CFNumberGetValue(v15, kCFNumberCharType, (void *)(a1 + 289));
        CFNumberGetValue(v18, kCFNumberCharType, (void *)(a1 + 290));
        CFMutableDictionaryRef v21 = 0LL;
        *(_BYTE *)(a1 + 28_Block_object_dispose(va, 8) = 1;
LABEL_48:
        if (!v43)
        {
LABEL_70:
          if (v21) {
            CFRelease(v21);
          }
          return;
        }

        id v20 = 0LL;
        uint64_t v22 = 0LL;
        uint64_t v23 = 0LL;
LABEL_62:
        double v47 = (const void *)sub_10004CE2C(*(void *)(a1 + 64));
        double v48 = sub_1000DEA34(a1, v47, 1);
        if (v48)
        {
          unsigned int v49 = v48;
          uint64_t v50 = *(const __CFArray **)(a1 + 3520);
          if (v50)
          {
            v69.length = CFArrayGetCount(*(CFArrayRef *)(a1 + 3520));
            v69.location = 0LL;
            FirstIndexOfCFBooleanRef Value = CFArrayGetFirstIndexOfValue(v50, v69, v49);
            if (FirstIndexOfValue != -1)
            {
              ValueAtIndex = CFArrayGetValueAtIndex(*(CFArrayRef *)(a1 + 3520), FirstIndexOfValue);
              if (ValueAtIndex)
              {
                uint64_t v53 = ValueAtIndex;
                uint64_t v54 = *(void *)(a1 + 64);
                uint64_t v55 = sub_10004CE2C(v54);
                unsigned int v56 = sub_1000FDC1C(a1, v53);
                sub_10003E8CC(v54, v55, v53, v56, v23, v22, *(__int16 *)(a1 + 284));
              }
            }
          }

          CFRelease(v49);
        }

        if (v20) {
          CFRelease(v20);
        }
        goto LABEL_70;
      }
    }

    else if (*(_DWORD *)(a1 + 280) && *(_DWORD *)(a1 + 284))
    {
      double v43 = v17;
      CFMutableDictionaryRef Mutable = CFDictionaryCreateMutable( kCFAllocatorDefault,  0LL,  &kCFTypeDictionaryKeyCallBacks,  &kCFTypeDictionaryValueCallBacks);
      if (!Mutable)
      {
        int v62 = objc_autoreleasePoolPush();
        if (qword_100219F60) {
          [qword_100219F60 WFLog:@"%s: offsetOptDict create failed" message:4];
        }
        objc_autoreleasePoolPop(v62);
        CFMutableDictionaryRef v21 = 0LL;
        goto LABEL_48;
      }

      CFMutableDictionaryRef v21 = Mutable;
      double v45 = CFDictionaryCreateMutable( kCFAllocatorDefault,  0LL,  &kCFTypeDictionaryKeyCallBacks,  &kCFTypeDictionaryValueCallBacks);
      if (!v45)
      {
        char v63 = objc_autoreleasePoolPush();
        if (qword_100219F60) {
          [qword_100219F60 WFLog:@"%s: offsetOptions create failed" message:4];
        }
        objc_autoreleasePoolPop(v63);
        goto LABEL_48;
      }

      id v20 = v45;
      CFDictionarySetValue(v45, @"IO80211InterfaceRoamTargetRssiDelta", v13);
      CFDictionarySetValue(v21, @"IO80211InterfaceRoamMotionTrafficParams", v20);
      uint64_t v22 = 0LL;
      uint64_t v23 = 2LL;
    }

    else
    {
      uint64_t v23 = 0LL;
      CFMutableDictionaryRef v21 = 0LL;
      id v20 = 0LL;
      uint64_t v22 = 2LL;
    }

    id v46 = objc_autoreleasePoolPush();
    if (qword_100219F60) {
      [qword_100219F60 WFLog:@"__WiFiDeviceManagerSetRoamTestParams" message:3, "%s: Roam Test Parameters: enabled %d learningPeriod %d expiryPeriod %d envType %d roamTriggerRssi %d roamDelta %d", "__WiFiDeviceManagerSetRoamTestParams", *(unsigned __int8 *)(a1 + 256), *(unsigned int *)(a1 + 260), *(unsigned int *)(a1 + 264), *(unsigned int *)(a1 + 268), *(unsigned int *)(a1 + 280), *(unsigned int *)(a1 + 284)];
    }
    objc_autoreleasePoolPop(v46);
    goto LABEL_62;
  }

  unsigned int v67 = 0;
  if (!*(void *)(a1 + 3520))
  {
    unsigned int v58 = objc_autoreleasePoolPush();
    unsigned int v59 = (void *)qword_100219F60;
    if (!qword_100219F60) {
      goto LABEL_97;
    }
    unsigned int v60 = "Known broadcast list is NULL!";
    goto LABEL_96;
  }

  int v29 = (const __CFString *)CFDictionaryGetValue(a2, @"SSID_STR");
  if (!v29)
  {
    unsigned int v58 = objc_autoreleasePoolPush();
    unsigned int v59 = (void *)qword_100219F60;
    if (!qword_100219F60) {
      goto LABEL_97;
    }
    unsigned int v60 = "ssid not specified!";
    goto LABEL_96;
  }

  uint64_t v30 = v29;
  uint64_t v31 = (const __CFString *)CFDictionaryGetValue(a2, @"BSSID");
  if (!v31)
  {
    unsigned int v58 = objc_autoreleasePoolPush();
    unsigned int v59 = (void *)qword_100219F60;
    if (qword_100219F60)
    {
      unsigned int v60 = "bssid not specified!";
      goto LABEL_96;
    }

uint64_t sub_1000E9078(uint64_t a1, const __CFDictionary *a2)
{
  if (!a1) {
    return 4294963396LL;
  }
  uint64_t v3 = sub_10001EEF8(*(void *)(a1 + 120), a2);
  uint64_t v4 = sub_10001DD0C(*(void *)(a1 + 120));
  objc_msgSend(*(id *)(a1 + 7320), "setTdLogic_badRssiThreshold:goodRssiThreshold:", v4, v5);
  return v3;
}

uint64_t sub_1000E90C8(uint64_t a1, uint64_t a2)
{
  BOOL v6 = 0;
  if (a1)
  {
    if (a2)
    {
      *(_BYTE *)(a1 + 620_Block_object_dispose(va, 8) = *(_BYTE *)(a2 + 5);
      sub_10004D62C(*(void *)(a1 + 64), &v6);
      *(_BYTE *)(a2 + 6) &= v6;
    }

    return sub_100014CFC(*(void *)(a1 + 120), a2);
  }

  else
  {
    uint64_t v5 = objc_autoreleasePoolPush();
    if (qword_100219F60) {
      [qword_100219F60 WFLog:@"%s: NULL Device Manager !" message:4];
    }
    objc_autoreleasePoolPop(v5);
    return 4294963396LL;
  }

uint64_t sub_1000E9174(uint64_t a1, int a2)
{
  if (a1) {
    return sub_100014DF8(*(void *)(a1 + 120), a2);
  }
  uint64_t v3 = objc_autoreleasePoolPush();
  if (qword_100219F60) {
    [qword_100219F60 WFLog:@"%s: NULL Device Manager !" message:4];
  }
  objc_autoreleasePoolPop(v3);
  return 4294963396LL;
}

void sub_1000E91EC(uint64_t a1)
{
  uint64_t v2 = objc_autoreleasePoolPush();
  if (a1)
  {
    [*(id *)(a1 + 6632) setDefaultDenyListThresholds];
  }

  else if (qword_100219F60)
  {
    [qword_100219F60 WFLog:@"%s: NULL Device Manager!" message:3];
  }

  objc_autoreleasePoolPop(v2);
}

uint64_t sub_1000E9258(uint64_t a1, int *a2, uint64_t a3)
{
  if (a1)
  {
    uint64_t v4 = (_BYTE *)(a1 + 5209);
    int v5 = *a2;
    if (*a2 == -536870144 || v5 == -536870256)
    {
      sub_100055A84(*(void *)(a1 + 64), 1);
      if (v4[2] && v4[1] == -*v4)
      {
        unsigned int v17 = 0;
        uint64_t v8 = objc_autoreleasePoolPush();
        if (qword_100219F60) {
          [qword_100219F60 WFLog:@"Disable MIS on Wake: Client Count %d" message:3];
        }
        objc_autoreleasePoolPop(v8);
        sub_1000DBCC0(a1, 0LL, 1, 0, &v17);
      }

      if (!a3)
      {
        uint64_t v16 = objc_autoreleasePoolPush();
        if (qword_100219F60) {
          [qword_100219F60 WFLog:@"%s: null wakeReason." message:@"__WiFiDeviceManagerSystemWokenForAutoUnlock"];
        }
        objc_autoreleasePoolPop(v16);
      }

      uint64_t v9 = 1LL;
    }

    else
    {
      if (v5 != -536870272) {
        return 0LL;
      }
      sub_100055A84(*(void *)(a1 + 64), 0);
      if (*(_DWORD *)(a1 + 5416))
      {
        CFMutableArrayRef v12 = *(const __CFSet **)(a1 + 3312);
        if (v12)
        {
          if (CFSetGetCount(v12))
          {
            int v13 = objc_autoreleasePoolPush();
            if (qword_100219F60) {
              [qword_100219F60 WFLog:@"system is going to sleep. Tearing down hosted AWDL session."];
            }
            objc_autoreleasePoolPop(v13);
            BOOL v14 = *(void **)(a1 + 5424);
            if (v14) {

            }
            *(void *)(a1 + 5424) = 0LL;
            CFSetApplyFunction(*(CFSetRef *)(a1 + 3312), (CFSetApplierFunction)sub_1000E94BC, (void *)a1);
          }
        }
      }

      sub_1000E953C(a1, 0);
      sub_1000D6494(a1);
      uint64_t v9 = 0LL;
    }

    v4[2039] = v9;
    uint64_t v15 = *(void **)(a1 + 7320);
    if (v15) {
      [v15 setSystemWakeState:v9 wokenByWiFi:sub_10003B698()];
    }
    return sub_100014EE0(*(unsigned __int8 **)(a1 + 120), v9);
  }

  else
  {
    int v10 = objc_autoreleasePoolPush();
    if (qword_100219F60) {
      [qword_100219F60 WFLog:@"%s: NULL Device Manager !" message:4];
    }
    objc_autoreleasePoolPop(v10);
    return 4294963396LL;
  }

void sub_1000E94BC(uint64_t a1, uint64_t a2)
{
  if (a2)
  {
    uint64_t v3 = (const void *)sub_100040CF8(*(void *)(a2 + 64));
    sub_1000D00D8(a2, v3);
  }

  else
  {
    uint64_t v4 = objc_autoreleasePoolPush();
    if (qword_100219F60) {
      [qword_100219F60 WFLog:@"__WiFiDeviceManagerHostedAwdlSessionTearDownApplier: null manager."];
    }
    objc_autoreleasePoolPop(v4);
  }

void sub_1000E953C(uint64_t a1, int a2)
{
  int v3 = *(_DWORD *)(a1 + 352);
  unsigned int v4 = v3 & 0xFFFFFFFE | (a2 != 0);
  *(_DWORD *)(a1 + 352) = v4;
  if (v3) {
    BOOL v5 = 1;
  }
  else {
    BOOL v5 = v4 == 0;
  }
  if (v5)
  {
    if (!v4)
    {
      dispatch_source_set_timer(*(dispatch_source_t *)(a1 + 360), 0xFFFFFFFFFFFFFFFFLL, 0xFFFFFFFFFFFFFFFFLL, 0LL);
      BOOL v6 = objc_autoreleasePoolPush();
      if (qword_100219F60) {
        [(id)qword_100219F60 WFLog:3 message:"Auto-join deferral canceled."];
      }
      objc_autoreleasePoolPop(v6);
      if (v3)
      {
        *(_DWORD *)(a1 + 192) = 12;
        if (_os_feature_enabled_impl("CoreWiFi", "UnifiedAutoJoin"))
        {
          sub_1000F5F98(a1, 0xEuLL);
        }

        else
        {
          [+[WiFiXPCManager sharedXPCManager](WiFiXPCManager, "sharedXPCManager") autoJoinStartedWithTrigger:14 interfaceName:sub_100043E8C(*(void *)(a1 + 64))];
          sub_1000D0A5C(a1, 2LL, (uint64_t)"__WiFiDeviceManagerSetAutoJoinDeferral");
        }
      }
    }
  }

  else
  {
    uint64_t v7 = objc_autoreleasePoolPush();
    uint64_t v8 = v7;
    if (qword_100219F60) {
      [(id)qword_100219F60 WFLog:3 message:"Auto-join will be deferred for 2 seconds."];
    }
    objc_autoreleasePoolPop(v8);
    uint64_t v9 = *(dispatch_source_s **)(a1 + 360);
    dispatch_time_t v10 = dispatch_time(0LL, 2000000000LL);
    dispatch_source_set_timer(v9, v10, 0xFFFFFFFFFFFFFFFFLL, 0LL);
    *(CFAbsoluteTime *)(a1 + 36_Block_object_dispose(va, 8) = CFAbsoluteTimeGetCurrent();
  }

uint64_t sub_1000E96B0(uint64_t a1, uint64_t *a2)
{
  if (!a1)
  {
    BOOL v14 = objc_autoreleasePoolPush();
    if (qword_100219F60) {
      [qword_100219F60 WFLog:@"%s: null deviceManager" message:3];
    }
    goto LABEL_24;
  }

  if (!a2)
  {
    BOOL v14 = objc_autoreleasePoolPush();
    if (qword_100219F60) {
      [qword_100219F60 WFLog:@"%s: null appWiFiUsageState" message:3];
    }
LABEL_24:
    objc_autoreleasePoolPop(v14);
    return 4294963396LL;
  }

  if (*(void *)(a1 + 184) == *a2) {
    return 0LL;
  }
  unsigned int v4 = (_BYTE *)(a1 + 5488);
  *(void *)(a1 + 184) = *a2;
  uint64_t v3 = sub_100015000(*(void *)(a1 + 120), *a2);
  CFMutableDictionaryRef Mutable = CFDictionaryCreateMutable( kCFAllocatorDefault,  0LL,  &kCFTypeDictionaryKeyCallBacks,  &kCFTypeDictionaryValueCallBacks);
  if (*v4 || *(_BYTE *)(a1 + 3402) || *(_BYTE *)(a1 + 5490))
  {
    CFBooleanRef v6 = kCFBooleanTrue;
    CFBooleanRef v7 = kCFBooleanFalse;
  }

  else
  {
    CFBooleanRef v6 = kCFBooleanTrue;
    CFBooleanRef v7 = kCFBooleanFalse;
    CFBooleanRef v8 = kCFBooleanFalse;
    if (!-[WiFiUserInteractionMonitor isRealTimeAppActive]( +[WiFiUserInteractionMonitor sharedInstance](&OBJC_CLASS___WiFiUserInteractionMonitor, "sharedInstance"),  "isRealTimeAppActive")) {
      goto LABEL_10;
    }
  }

  CFBooleanRef v8 = v6;
LABEL_10:
  if (-[WiFiUserInteractionMonitor isInHomeScreen]( +[WiFiUserInteractionMonitor sharedInstance](&OBJC_CLASS___WiFiUserInteractionMonitor, "sharedInstance"),  "isInHomeScreen"))
  {
    CFBooleanRef v9 = v6;
  }

  else
  {
    CFBooleanRef v9 = v7;
  }

  CFDictionarySetValue(Mutable, @"IO80211IsInHomeScreen", v9);
  CFDictionarySetValue(Mutable, @"IO80211IsLatencySensitiveAppActive", v8);
  dispatch_time_t v10 = objc_autoreleasePoolPush();
  if (qword_100219F60) {
    [(id)qword_100219F60 WFLog:3, "App state params %@", Mutable message];
  }
  objc_autoreleasePoolPop(v10);
  uint64_t v11 = *(void *)(a1 + 64);
  CFMutableArrayRef v12 = (const void *)sub_100043E8C(v11);
  sub_10003EC6C(v11, v12, 485LL, 0LL, (uint64_t)Mutable);
  if (Mutable) {
    CFRelease(Mutable);
  }
  return v3;
}

uint64_t sub_1000E98CC(uint64_t a1, int a2)
{
  unsigned int v4 = (const void *)sub_100043E8C(*(void *)(a1 + 64));
  BOOL v5 = sub_1000DEA34(a1, v4, 1);
  if (!v5) {
    return 4294963366LL;
  }
  CFBooleanRef v6 = v5;
  if (sub_10009E120((uint64_t)v5) - 1 <= 1 && *(_BYTE *)(a1 + 5488))
  {
    uint64_t v7 = sub_100050E48(*(void *)(a1 + 64), a2 ^ 1u);
    CFBooleanRef v8 = objc_autoreleasePoolPush();
    if (qword_100219F60)
    {
      CFBooleanRef v9 = "off";
      if (a2) {
        CFBooleanRef v9 = "on";
      }
      [qword_100219F60 WFLog:@"speech session is %s in CarPlay" message:3 v9];
    }

    objc_autoreleasePoolPop(v8);
  }

  else
  {
    uint64_t v7 = 4294963366LL;
  }

  CFRelease(v6);
  return v7;
}

uint64_t sub_1000E99B8(uint64_t a1, const __CFString **a2)
{
  unsigned int v4 = objc_autoreleasePoolPush();
  if (qword_100219F60)
  {
    if (*((_BYTE *)a2 + 24)) {
      BOOL v5 = "Y";
    }
    else {
      BOOL v5 = "N";
    }
    [(id)qword_100219F60 WFLog:3, "%s: CarPlay session vehicle inform: model %@, manufacturer %@, hardware version %@, isSessionActive %s", "WiFiDeviceManagerSetCarPlaySessionState", *(_OWORD *)a2, a2[2], v5 message];
  }

  objc_autoreleasePoolPop(v4);
  if (!*((_BYTE *)a2 + 24))
  {
    uint64_t v23 = *(dispatch_source_s **)(a1 + 1048);
    dispatch_time_t v24 = -1LL;
    uint64_t v25 = -1LL;
LABEL_32:
    dispatch_source_set_timer(v23, v24, v25, 0LL);
    return 0LL;
  }

  CFBooleanRef v6 = *a2;
  *(void *)(a1 + 8720) = *a2;
  uint64_t v7 = a2[1];
  *(void *)(a1 + 872_Block_object_dispose(va, 8) = v7;
  CFBooleanRef v8 = a2[2];
  *(void *)(a1 + 8736) = v8;
  *(_BYTE *)(a1 + 940) = 1;
  double v9 = *(double *)(a1 + 704);
  double v10 = v9 - *(double *)(a1 + 696);
  if (v10 > 0.0 && v10 <= 10.0)
  {
    uint64_t v12 = (v10 * 1000.0);
    double v13 = *(double *)(a1 + 712);
    uint64_t v14 = ((v13 - v9) * 1000.0);
    v33[0] = v12;
    v33[1] = ((v13 - v9) * 1000.0);
    double v15 = (*(double *)(a1 + 720) - v13) * 1000.0;
    uint64_t v16 = v15;
    int v34 = 43690;
    uint64_t v35 = @"Unknown";
    void v33[2] = v15;
    int v17 = *(unsigned __int8 *)(a1 + 728);
    LOBYTE(v34) = *(_BYTE *)(a1 + 728);
    CFIndex v36 = @"Unknown";
    CFIndex v37 = @"Unknown";
    if (v6)
    {
      uint64_t v35 = v6;
      CFIndex v36 = v7;
      CFIndex v37 = v8;
    }

    CFIndex v18 = (const void *)sub_100043E8C(*(void *)(a1 + 64));
    int v19 = sub_1000DEA34(a1, v18, 1);
    if (v19)
    {
      id v20 = v19;
      CFMutableDictionaryRef v21 = (const __CFNumber *)sub_100096A74((uint64_t)v19);
      if (v21)
      {
        unsigned __int16 valuePtr = -21846;
        CFNumberGetValue(v21, kCFNumberSInt16Type, &valuePtr);
        unsigned int v22 = valuePtr;
        HIWORD(v34) = valuePtr;
      }

      else
      {
        unsigned int v22 = 0;
      }

      CFRelease(v20);
    }

    else
    {
      unsigned int v22 = 0;
    }

    CFIndex v26 = objc_autoreleasePoolPush();
    if (qword_100219F60)
    {
      CFStringRef v27 = "yes";
      if (!v17) {
        CFStringRef v27 = "no";
      }
      objc_msgSend( (id)qword_100219F60,  "WFLog:message:",  3,  "%s: timeBasicAssocTaken %u ms, time4WayHSTaken %u ms, timeDhcpTaken %u ms, wasScanCanceled %s, channel %u",  "__WiFiDeviceManagerSubmitCarPlayConnectMetrics",  v12,  v14,  v16,  v27,  v22);
    }

    objc_autoreleasePoolPop(v26);
    sub_1000387BC(v33);
  }

  if ((_os_feature_enabled_impl("WiFiManager", "LMTPCFor5GHzCarPlay") & 1) != 0
    || _os_feature_enabled_impl("WiFiManager", "LMTPCFor24GHzCarPlay"))
  {
    uint64_t v28 = *(void *)(a1 + 64);
    if (v28)
    {
      if (sub_10004D614(v28))
      {
        int v29 = objc_autoreleasePoolPush();
        if (qword_100219F60) {
          [qword_100219F60 WFLog:@"%s: chipset supports LPC" message:3];
        }
        objc_autoreleasePoolPop(v29);
        uint64_t v30 = *(dispatch_source_s **)(a1 + 1048);
        dispatch_time_t v24 = dispatch_time(0LL, 600000000000LL);
        uint64_t v23 = v30;
        uint64_t v25 = 600000000000LL;
        goto LABEL_32;
      }
    }
  }

  return 0LL;
}

uint64_t sub_1000E9C80(uint64_t a1, unsigned int *a2)
{
  unsigned int v4 = (const void *)sub_100043E8C(*(void *)(a1 + 64));
  BOOL v5 = sub_1000DEA34(a1, v4, 1);
  if (!v5) {
    return 0LL;
  }
  CFBooleanRef v6 = v5;
  uint64_t v7 = 0LL;
  uint64_t v8 = *a2;
  uint64_t v9 = *((void *)a2 + 1);
  if (v8 <= 2)
  {
    uint64_t v10 = a2[1];
    if (v10 <= 0x1E)
    {
      if (*(_DWORD *)(a1 + 3344) == 4) {
        double v11 = (double)v10;
      }
      else {
        double v11 = (double)v10 * 0.8;
      }
      CFAbsoluteTime Current = CFAbsoluteTimeGetCurrent();
      unsigned int v13 = Current;
      unsigned int v14 = Current / 0x3C;
      int v15 = v14 - 30 * ((143165577 * (unint64_t)v14) >> 32);
      unsigned int v16 = (Current - *(double *)(a1 + 8576));
      if (v16 >= 0x3C)
      {
        unsigned int v17 = v16 / 0x3C;
        if (v16 / 0x3C >= 0x1E) {
          unsigned int v17 = 30;
        }
        unsigned int v18 = v17 + v15;
        if (v18 >= 0x1E) {
          int v19 = 30;
        }
        else {
          int v19 = v18;
        }
        int v20 = v19 - (v18 > 0x1D);
        uint64_t v21 = v18 - v20;
        if (v15 < v20)
        {
          int v22 = *(_DWORD *)(a1 + 8716);
          unsigned int v23 = v13 / 0x708;
          signed int v24 = v14 - 30 * (v13 / 0x708);
          uint64_t v25 = (int *)(a1 - 120LL * v23 + 4LL * v14 + 8600);
          do
          {
            int v26 = *v25++;
            v22 -= v26;
            *(_DWORD *)(a1 + 8716) = v22;
            ++v24;
          }

          while (v20 > v24);
        }

        if ((int)v21 >= 1)
        {
          int v27 = *(_DWORD *)(a1 + 8716);
          uint64_t v28 = (int *)(a1 + 8596);
          do
          {
            int v29 = *v28++;
            v27 -= v29;
            *(_DWORD *)(a1 + 8716) = v27;
            --v21;
          }

          while (v21);
        }
      }

      *(_DWORD *)(a1 + 4LL * v15 + 8596) += v10;
      unsigned int v30 = *(_DWORD *)(a1 + 8716) + v10;
      *(_DWORD *)(a1 + 8716) = v30;
      double v31 = dbl_10017FBB0[(_DWORD)v8 == 1];
      if ((_DWORD)v8 == 2) {
        double v31 = 540.0;
      }
      CFTypeRef v32 = objc_autoreleasePoolPush();
      if (qword_100219F60)
      {
        __int128 v33 = "no";
        if (v11 != 0.0) {
          __int128 v33 = "yes";
        }
        [qword_100219F60 WFLog:@"%s: can relax power ? %s, current duration %u, total duration for past 30 minutes %u, current rate %.1lf" message:3 v33 v10 *(unsigned int *)(a1 + 8716) *(unsigned int *)(a1 + 8716) / 1800.0];
      }

      objc_autoreleasePoolPop(v32);
      uint64_t v7 = v11;
    }
  }

  int v34 = objc_autoreleasePoolPush();
  if (qword_100219F60) {
    [(id)qword_100219F60 WFLog:3, "%s: priority %d, adjusted duration %u, type %@, motion state %d", "__WiFiDeviceManagerAdjustDurationOfCarPlayHidSession", v8, v7, v9, *(unsigned int *)(a1 + 3344) message];
  }
  objc_autoreleasePoolPop(v34);
  if ((_DWORD)v7
    && ((v35 = CFAbsoluteTimeGetCurrent(), double v37 = v35, !*(_BYTE *)(a1 + 8592))
     || (LODWORD(v36) = *(_DWORD *)(a1 + 8568), *(double *)(a1 + 8576) - v35 + (double)v36 < (double)v7)))
  {
    uint64_t v38 = sub_100050E48(*(void *)(a1 + 64), 0);
    if (!(_DWORD)v38)
    {
      uint64_t v39 = *(dispatch_source_s **)(a1 + 8584);
      dispatch_time_t v40 = dispatch_time(0LL, 1000000000LL * v7);
      dispatch_source_set_timer(v39, v40, 0xFFFFFFFFFFFFFFFFLL, 0LL);
      CFTypeRef v41 = objc_autoreleasePoolPush();
      if (qword_100219F60) {
        [qword_100219F60 WFLog:@"%s: CarPlay HID session is active for %u seconds" message:3, @"WiFiDeviceManagerSetCarPlayHidSessionState", v7];
      }
      objc_autoreleasePoolPop(v41);
      uint64_t v38 = 0LL;
      *(_DWORD *)(a1 + 856_Block_object_dispose(va, 8) = v7;
      *(double *)(a1 + 8576) = v37;
      *(_BYTE *)(a1 + 8592) = 1;
    }
  }

  else
  {
LABEL_39:
    uint64_t v38 = 0LL;
  }

  CFRelease(v6);
  return v38;
}

uint64_t sub_1000EA014(uint64_t a1, int a2, double a3)
{
  if (a1)
  {
    int v6 = *(_DWORD *)(a1 + 3344);
    if (a2 != 4 && v6 == 4)
    {
      if (!-[WiFiUserInteractionMonitor isCellularDataUsable]( +[WiFiUserInteractionMonitor sharedInstance](&OBJC_CLASS___WiFiUserInteractionMonitor, "sharedInstance"),  "isCellularDataUsable"))
      {
        uint64_t v8 = objc_autoreleasePoolPush();
        if (qword_100219F60) {
          [qword_100219F60 WFLog:@"%s: motion state changed from driving and no alternative network interface. Triggering auto-join" message:3];
        }
        objc_autoreleasePoolPop(v8);
LABEL_20:
        sub_1000F5F98(a1, 0x38uLL);
        goto LABEL_22;
      }

      int v6 = *(_DWORD *)(a1 + 3344);
    }

    if (v6 == 4)
    {
      if ((a2 | 2) != 6) {
        goto LABEL_17;
      }
    }

    else if (v6 == 6 && (a2 | 2) != 6)
    {
LABEL_17:
      uint64_t v9 = objc_autoreleasePoolPush();
      if (qword_100219F60) {
        [qword_100219F60 WFLog:@"%s: motion state changed from driving. Resetting auto-join intervals." message:3];
      }
      objc_autoreleasePoolPop(v9);
      if (!_os_feature_enabled_impl("CoreWiFi", "UnifiedAutoJoin"))
      {
        sub_1000D0A5C(a1, 2LL, (uint64_t)"WiFiDeviceManagerSetMotionState");
        goto LABEL_22;
      }

      goto LABEL_20;
    }

void sub_1000EA220(uint64_t a1, int a2)
{
  uint64_t v2 = a1;
  uint64_t v3 = *(void *)(a1 + 120);
  if (a2)
  {
    unsigned int v4 = sub_1000EA244;
  }

  else
  {
    unsigned int v4 = 0LL;
    uint64_t v2 = 0LL;
  }

  sub_1000166F4(v3, (uint64_t)v4, v2);
}

void sub_1000EA244(uint64_t a1, uint64_t a2)
{
  if (a1)
  {
    uint64_t v4 = sub_10004CE2C(*(void *)(a1 + 64));
    if (v4)
    {
      sub_100083D94(*(void *)(a1 + 6744), a1, v4, a2);
      return;
    }

    BOOL v5 = objc_autoreleasePoolPush();
    if (qword_100219F60) {
      [qword_100219F60 WFLog:@"__WiFiDeviceManagerTdConfirmedCallback - interface is NULL!"];
    }
  }

  else
  {
    BOOL v5 = objc_autoreleasePoolPush();
    if (qword_100219F60) {
      [qword_100219F60 WFLog:@"%s - Manager is NULL!" message:4];
    }
  }

  objc_autoreleasePoolPop(v5);
}

void sub_1000EA304(uint64_t a1, int a2, int a3, int a4)
{
  int v15 = a3;
  int valuePtr = a2;
  if (sub_10004D66C(*(void *)(a1 + 64)))
  {
    *(_OWORD *)keys = *(_OWORD *)off_1001E4CE8;
    int v19 = @"IO80211InterfaceDualPowerCellularTxShort";
    memset(values, 170, sizeof(values));
    CFNumberRef v6 = CFNumberCreate(kCFAllocatorDefault, kCFNumberSInt32Type, &valuePtr);
    CFNumberRef v7 = CFNumberCreate(kCFAllocatorDefault, kCFNumberSInt32Type, &v15);
    CFNumberRef v8 = v7;
    if (v6) {
      BOOL v9 = v7 == 0LL;
    }
    else {
      BOOL v9 = 1;
    }
    if (v9)
    {
      if (!v6)
      {
LABEL_12:
        if (v8) {
          CFRelease(v8);
        }
        return;
      }
    }

    else
    {
      CFBooleanRef v10 = kCFBooleanTrue;
      if (!a4) {
        CFBooleanRef v10 = kCFBooleanFalse;
      }
      values[0] = v6;
      values[1] = v7;
      values[2] = v10;
      CFDictionaryRef v11 = CFDictionaryCreate( kCFAllocatorDefault,  (const void **)keys,  (const void **)values,  3LL,  &kCFTypeDictionaryKeyCallBacks,  &kCFTypeDictionaryValueCallBacks);
      if (v11)
      {
        CFDictionaryRef v12 = v11;
        uint64_t v13 = *(void *)(a1 + 64);
        unsigned int v14 = (const void *)sub_100043E8C(v13);
        sub_10003EC6C(v13, v14, 499LL, 0LL, (uint64_t)v12);
        CFRelease(v12);
      }

      *(_BYTE *)(a1 + 6176) = v15 == 1;
    }

    CFRelease(v6);
    goto LABEL_12;
  }

uint64_t sub_1000EA48C(uint64_t a1, int a2)
{
  uint64_t v2 = &kCFBooleanTrue;
  if (!a2) {
    uint64_t v2 = &kCFBooleanFalse;
  }
  uint64_t v3 = (uint64_t)*v2;
  uint64_t v4 = *(void *)(a1 + 64);
  BOOL v5 = (const void *)sub_100043E8C(v4);
  return sub_10003EC6C(v4, v5, 448LL, 0LL, v3);
}

void sub_1000EA4E0(uint64_t a1, double a2)
{
  if (a1)
  {
    if (*(double *)(a1 + 6736) != a2)
    {
      uint64_t v4 = objc_autoreleasePoolPush();
      if (qword_100219F60) {
        [qword_100219F60 WFLog:@"%s: timeout %f" message:@"WiFiDeviceManagerSetNANOffHeadConnectionExpiry" :3 :*(void *)&a2];
      }
      objc_autoreleasePoolPop(v4);
      *(double *)(a1 + 6736) = a2;
    }
  }

  else
  {
    BOOL v5 = objc_autoreleasePoolPush();
    if (qword_100219F60) {
      [qword_100219F60 WFLog:@"%s: manager is NULL" message:3];
    }
    objc_autoreleasePoolPop(v5);
  }

double sub_1000EA5B0(uint64_t a1)
{
  if (a1) {
    return *(double *)(a1 + 6736);
  }
  uint64_t v2 = objc_autoreleasePoolPush();
  if (qword_100219F60) {
    [qword_100219F60 WFLog:@"deviceManager is NULL!"];
  }
  objc_autoreleasePoolPop(v2);
  return 0.0;
}

void sub_1000EA61C(uint64_t a1)
{
  uint64_t v2 = (_BYTE *)(a1 + 5211);
  uint64_t v3 = *(void *)(a1 + 64);
  uint64_t v4 = (const void *)sub_100043E8C(v3);
  sub_10003EC6C(v3, v4, 481LL, 0LL, 0LL);
  if (!-[WiFiUserInteractionMonitor isRealTimeAppActive]( +[WiFiUserInteractionMonitor sharedInstance](&OBJC_CLASS___WiFiUserInteractionMonitor, "sharedInstance"),  "isRealTimeAppActive")
    && *(_BYTE *)(a1 + 3468))
  {
    sub_1000CCDC0(a1);
  }

  if (*(_DWORD *)(a1 + 5416))
  {
    BOOL v5 = (const void *)sub_100040CF8(*(void *)(a1 + 64));
    if (sub_1000DF3D8(a1))
    {
      CFNumberRef v6 = sub_1000E6404(a1, 1);
      if (v6)
      {
        CFNumberRef v7 = v6;
        CFNumberRef v8 = (const __CFDate *)sub_1000951FC((uint64_t)v6, @"lastJoined");
        CFAbsoluteTime Current = CFAbsoluteTimeGetCurrent();
        CFBooleanRef v10 = CFDateCreate(kCFAllocatorDefault, Current);
        CFDictionaryRef v11 = v10;
        if (v8 && v10)
        {
          if (CFDateGetTimeIntervalSinceDate(v10, v8) >= 20.0)
          {
            CFDictionaryRef v12 = objc_autoreleasePoolPush();
            if (qword_100219F60) {
              [qword_100219F60 WFLog:@"__WiFiDeviceManagerAssistedDiscoverySessionTimeout: remove AWDL network(Assisted Discovery) due to Timeout"];
            }
            objc_autoreleasePoolPop(v12);
            if (sub_1000E6064(a1, v5, v7, 0LL, 0LL))
            {
              uint64_t v13 = objc_autoreleasePoolPush();
              if (qword_100219F60) {
                [qword_100219F60 WFLog:@"__WiFiDeviceManagerAssistedDiscoverySessionTimeout: Failed remove AWDL network"];
              }
              objc_autoreleasePoolPop(v13);
            }
          }
        }

        else if (!v10)
        {
LABEL_18:
          CFRelease(v7);
          goto LABEL_19;
        }

        CFRelease(v11);
        goto LABEL_18;
      }
    }
  }

uint64_t sub_1000EA844(uint64_t a1, int a2)
{
  if (a1)
  {
    *(_BYTE *)(a1 + 3681) = a2 != 0;
    keys = @"IO80211InterfaceBatterySaveModeState";
    uint64_t v3 = (void **)&kCFBooleanTrue;
    if (!a2) {
      uint64_t v3 = (void **)&kCFBooleanFalse;
    }
    values = *v3;
    CFDictionaryRef v4 = CFDictionaryCreate( kCFAllocatorDefault,  (const void **)&keys,  (const void **)&values,  1LL,  &kCFTypeDictionaryKeyCallBacks,  &kCFTypeDictionaryValueCallBacks);
    if (v4)
    {
      CFDictionaryRef v5 = v4;
      uint64_t v6 = *(void *)(a1 + 64);
      CFNumberRef v7 = (const void *)sub_100043E8C(v6);
      sub_10003EC6C(v6, v7, 472LL, 0LL, (uint64_t)v5);
      CFRelease(v5);
    }

    return 0LL;
  }

  else
  {
    BOOL v9 = objc_autoreleasePoolPush();
    if (qword_100219F60) {
      [qword_100219F60 WFLog:@"%s: NULL Device Manager !" message:4];
    }
    objc_autoreleasePoolPop(v9);
    return 4294963396LL;
  }

uint64_t sub_1000EA974()
{
  return _os_feature_enabled_impl("WiFiManager", "IgnoreAVCAssertion") ^ 1;
}

uint64_t sub_1000EA99C(uint64_t a1, CFDictionaryRef theDict)
{
  if (!a1 || !theDict)
  {
    uint64_t v16 = objc_autoreleasePoolPush();
    unsigned int v17 = (void *)qword_100219F60;
    if (!qword_100219F60) {
      goto LABEL_41;
    }
    unsigned int v18 = "Error: %s: device manager or policy dict is NULL";
    goto LABEL_54;
  }

  CFBooleanRef Value = (const __CFString *)CFDictionaryGetValue(theDict, @"appPolicyUUID");
  CFDictionaryRef v5 = (const __CFBoolean *)CFDictionaryGetValue(theDict, @"appPolicyState");
  uint64_t v6 = CFBooleanGetValue(v5);
  unsigned int v7 = -[WiFiUserInteractionMonitor isCoPresenceActive]( +[WiFiUserInteractionMonitor sharedInstance](&OBJC_CLASS___WiFiUserInteractionMonitor, "sharedInstance"),  "isCoPresenceActive");
  if (Value) {
    BOOL v8 = v5 == 0LL;
  }
  else {
    BOOL v8 = 1;
  }
  if (v8)
  {
    uint64_t v16 = objc_autoreleasePoolPush();
    unsigned int v17 = (void *)qword_100219F60;
    if (!qword_100219F60) {
      goto LABEL_41;
    }
    unsigned int v18 = "Error: %s: policy dict has NULL values";
LABEL_54:
    uint64_t v21 = 4LL;
    goto LABEL_40;
  }

  unsigned int v9 = v7;
  CFBooleanRef v10 = (BOOL *)(a1 + 5489);
  if (CFStringCompare(Value, @"CB06911C-82BE-44A9-8359-F8C02AAF82DB", 0LL)) {
    goto LABEL_8;
  }
  if (*v10 == (_DWORD)v6 && *(unsigned __int8 *)(a1 + 5491) == v9)
  {
    uint64_t v16 = objc_autoreleasePoolPush();
    unsigned int v17 = (void *)qword_100219F60;
    if (qword_100219F60)
    {
      uint64_t v28 = v6;
      unsigned int v18 = "%s: Duplicate avc assertion (callState=%d), bail out";
LABEL_39:
      uint64_t v21 = 3LL;
LABEL_40:
      objc_msgSend(v17, "WFLog:message:", v21, v18, "WiFiDeviceManagerSetAppPolicy", v28);
      goto LABEL_41;
    }

    goto LABEL_41;
  }

  if (_os_feature_enabled_impl("WiFiManager", "IgnoreAVCAssertion"))
  {
    uint64_t v16 = objc_autoreleasePoolPush();
    unsigned int v17 = (void *)qword_100219F60;
    if (qword_100219F60)
    {
      uint64_t v28 = v6;
      unsigned int v18 = "%s: avc assertion (callState=%d) not for infra, bail out";
      goto LABEL_39;
    }

void sub_1000EAEB8(uint64_t a1, int a2)
{
  if (a1)
  {
    if (*(_DWORD *)(a1 + 72) == 7)
    {
      BOOL v3 = a2 != 0;
      *(_BYTE *)(a1 + 3261) = a2 != 0;
      CFDictionaryRef v4 = objc_autoreleasePoolPush();
      if (qword_100219F60) {
        objc_msgSend( (id)qword_100219F60,  "WFLog:message:",  3,  "%s: manager->state.voiceRelayAsserted set to %d",  "WiFiDeviceManagerVoiceRelay",  *(unsigned __int8 *)(a1 + 3261));
      }
      objc_autoreleasePoolPop(v4);
      BOOL valuePtr = v3;
      CFMutableDictionaryRef Mutable = CFDictionaryCreateMutable( kCFAllocatorDefault,  0LL,  &kCFTypeDictionaryKeyCallBacks,  &kCFTypeDictionaryValueCallBacks);
      if (Mutable)
      {
        uint64_t v6 = Mutable;
        CFNumberRef v7 = CFNumberCreate(kCFAllocatorDefault, kCFNumberShortType, &valuePtr);
        CFDictionarySetValue(v6, @"APPLE80211KEY_REGKEY_WIFI_VOICE_IND_STATE", v7);
        BOOL v8 = objc_autoreleasePoolPush();
        if (qword_100219F60) {
          [qword_100219F60 WFLog:@"%s: WiFiDeviceSetIoctl(APPLE80211_IOC_VOICE_IND_STATE)\n" message:3];
        }
        objc_autoreleasePoolPop(v8);
        uint64_t v9 = *(void *)(a1 + 64);
        CFBooleanRef v10 = (const void *)sub_100043E8C(v9);
        sub_10003EC6C(v9, v10, 453LL, 0LL, (uint64_t)v6);
        CFRelease(v6);
        if (v7) {
          CFRelease(v7);
        }
      }
    }
  }

  else
  {
    CFDictionaryRef v11 = objc_autoreleasePoolPush();
    if (qword_100219F60) {
      [qword_100219F60 WFLog:@"WiFiDeviceManagerRef is NULL, aborting..."];
    }
    objc_autoreleasePoolPop(v11);
  }

void sub_1000EB060(uint64_t a1, uint64_t a2)
{
  uint64_t v2 = a1 + 7352;
  if (*(_BYTE *)(a1 + 7352))
  {
    CFDictionaryRef v5 = (unsigned __int8 *)(a1 + 8558);
    if (*(_BYTE *)(a1 + 5488) || *(_BYTE *)(a1 + 3402) || *(_BYTE *)(a1 + 5490)) {
      unsigned __int8 v6 = 1;
    }
    else {
      unsigned __int8 v6 = -[WiFiUserInteractionMonitor isRealTimeAppActive]( +[WiFiUserInteractionMonitor sharedInstance](&OBJC_CLASS___WiFiUserInteractionMonitor, "sharedInstance"),  "isRealTimeAppActive");
    }
    void v5[2] = v6;
    CFNumberRef v7 = objc_autoreleasePoolPush();
    if (qword_100219F60)
    {
      BOOL v8 = "Yes";
      if (*v5) {
        uint64_t v9 = "Yes";
      }
      else {
        uint64_t v9 = "No";
      }
      if (v5[2]) {
        CFBooleanRef v10 = "Yes";
      }
      else {
        CFBooleanRef v10 = "No";
      }
      if (!v5[3]) {
        BOOL v8 = "No";
      }
      objc_msgSend( (id)qword_100219F60,  "WFLog:message:",  3,  "%s:isConnected %s, isTimeSensitiveAppRunning %s, isThereTrafficNow %s",  "__WiFiDeviceManagerEvaluate24GHzInfraNetworkState",  v9,  v10,  v8);
    }

    objc_autoreleasePoolPop(v7);
    void v5[4] = 0;
    int v11 = *v5;
    if (*v5)
    {
      if (v5[2] || (int v11 = v5[3]) != 0)
      {
        int v11 = 1;
        void v5[4] = 1;
      }
    }

    if (*(unsigned __int8 *)(v2 + 1205) != v11)
    {
      v12.n128_f64[0] = CFAbsoluteTimeGetCurrent();
      double v13 = *(double *)(a1 + 8536);
      if (v13 == 0.0 || (double v14 = v12.n128_f64[0] - v13, v12.n128_u64[0] = 4.0, v14 >= 4.0) || v14 < 0.0)
      {
        int v19 = *(void (**)(uint64_t, uint64_t, void, void, __n128))(a1 + 4336);
        if (v19)
        {
          v19(a1, a2, *(void *)(a1 + 4344), v5[4], v12);
          int v20 = objc_autoreleasePoolPush();
          if (qword_100219F60) {
            [qword_100219F60 WFLog:@"Signal WiFi critical state - %d" message:v5[4]];
          }
          objc_autoreleasePoolPop(v20);
        }

        *(CFAbsoluteTime *)(a1 + 8536) = CFAbsoluteTimeGetCurrent();
        *(_DWORD *)(a1 + 8553) = *(_DWORD *)v5;
        *(_BYTE *)(a1 + 8557) = v5[4];
        dispatch_source_set_timer(*(dispatch_source_t *)(a1 + 8544), 0xFFFFFFFFFFFFFFFFLL, 0xFFFFFFFFFFFFFFFFLL, 0LL);
        *(_BYTE *)(v2 + 1200) = 0;
      }

      else if (!*(_BYTE *)(v2 + 1200))
      {
        uint64_t v15 = objc_autoreleasePoolPush();
        double v16 = 4.0 - v14;
        if (qword_100219F60) {
          [qword_100219F60 WFLog:@"%d secs remain for signaling WiFi critical state. Waiting..." message:3];
        }
        objc_autoreleasePoolPop(v15);
        unsigned int v17 = *(dispatch_source_s **)(a1 + 8544);
        dispatch_time_t v18 = dispatch_time(0LL, (uint64_t)(v16 * 1000000000.0));
        dispatch_source_set_timer(v17, v18, 0xFFFFFFFFFFFFFFFFLL, 0LL);
        *(_BYTE *)(v2 + 1200) = 1;
      }
    }
  }

uint64_t sub_1000EB2C0(uint64_t a1, uint64_t a2, void *key)
{
  if (!a1)
  {
    uint64_t v15 = objc_autoreleasePoolPush();
    if (qword_100219F60) {
      [qword_100219F60 WFLog:@"Error: %s: device manager is NULL" message:4];
    }
    goto LABEL_29;
  }

  if (!a2)
  {
    uint64_t v15 = objc_autoreleasePoolPush();
    if (qword_100219F60) {
      [qword_100219F60 WFLog:@"Error: %s: trafficReg is NULL" message:4];
    }
    goto LABEL_29;
  }

  if (!key)
  {
    uint64_t v15 = objc_autoreleasePoolPush();
    if (qword_100219F60) {
      [qword_100219F60 WFLog:@"Error: %s: clientID is NULL" message:@"WiFiDeviceManagerAppTrafficRegistration"];
    }
    goto LABEL_29;
  }

  CFBooleanRef Value = (void *)CFDictionaryGetValue(*(CFDictionaryRef *)(a1 + 7016), key);
  if (!Value
    || (id v7 = Value,
        uint64_t v8 = objc_opt_class(&OBJC_CLASS___AWDLServiceDiscoveryManager),
        (objc_opt_isKindOfClass(v7, v8) & 1) == 0))
  {
    id v7 = objc_alloc_init(&OBJC_CLASS___AWDLServiceDiscoveryManager);
    CFDictionarySetValue(*(CFMutableDictionaryRef *)(a1 + 7016), key, v7);
  }

  unsigned __int8 v17 = 0;
  id v9 = [[AWDLTrafficRegistrationConfiguration alloc] initWithDictionary:a2 isActive:&v17];
  if (!v9)
  {
    uint64_t v15 = objc_autoreleasePoolPush();
    if (qword_100219F60) {
      [qword_100219F60 WFLog:@"Failed to send traffic registration because failed to parse dictionary" message:4 v16];
    }
LABEL_29:
    objc_autoreleasePoolPop(v15);
    CFBooleanRef v10 = 0LL;
    uint64_t v13 = 4294963396LL;
    goto LABEL_18;
  }

  CFBooleanRef v10 = v9;
  if (v17)
  {
LABEL_20:
    uint64_t v13 = 4294963365LL;
    goto LABEL_18;
  }

uint64_t sub_1000EB550( uint64_t a1, uint64_t a2, unsigned int *a3, unsigned int a4, unsigned int a5, const void *a6)
{
  return sub_1000EB574(a1, 0LL, a2, a3, a4, a5, a6, (uint64_t)sub_1000EB950);
}

uint64_t sub_1000EB574( uint64_t a1, __CFDictionary *a2, uint64_t a3, unsigned int *a4, unsigned int a5, unsigned int a6, const void *a7, uint64_t a8)
{
  if (!a1)
  {
    double v31 = objc_autoreleasePoolPush();
    if (qword_100219F60) {
      [qword_100219F60 WFLog:@"%s: manager is NULL !" message:4];
    }
    goto LABEL_49;
  }

  memset(v33, 170, sizeof(v33));
  if (!(_DWORD)a3)
  {
    CFNumberRef v16 = 0LL;
    if (a5) {
      goto LABEL_5;
    }
    goto LABEL_15;
  }

  void v33[2] = a3;
  CFNumberRef v16 = CFNumberCreate(0LL, kCFNumberCFIndexType, &v33[2]);
  if (!v16)
  {
    double v31 = objc_autoreleasePoolPush();
    if (qword_100219F60) {
      [qword_100219F60 WFLog:@"%s: numProbesRef is NULL !" message:4];
    }
LABEL_49:
    objc_autoreleasePoolPop(v31);
    return 4294963394LL;
  }

  if (a5)
  {
LABEL_5:
    CFMutableArrayRef Mutable = CFArrayCreateMutable(kCFAllocatorDefault, 0LL, &kCFTypeArrayCallBacks);
    if (!Mutable)
    {
      uint64_t v26 = objc_autoreleasePoolPush();
      if (qword_100219F60) {
        [qword_100219F60 WFLog:@"%s: probeSizeArrRef is NULL !" message:4];
      }
      CFNumberRef v25 = 0LL;
      uint64_t v28 = 0LL;
      dispatch_time_t v18 = 0LL;
      goto LABEL_53;
    }

    dispatch_time_t v18 = Mutable;
    CFTypeRef v32 = v16;
    int v19 = a2;
    uint64_t v20 = a8;
    uint64_t v21 = a5;
    do
    {
      unsigned int v22 = *a4++;
      v33[1] = v22;
      CFNumberRef v23 = CFNumberCreate(0LL, kCFNumberCFIndexType, &v33[1]);
      if (!v23)
      {
        uint64_t v26 = objc_autoreleasePoolPush();
        if (qword_100219F60) {
          [qword_100219F60 WFLog:@"__WiFiDeviceManagerTriggerActiveProbe: probeSizeRef is NULL !"];
        }
        CFNumberRef v25 = 0LL;
        uint64_t v28 = 0LL;
        uint64_t v29 = 4294963394LL;
        CFNumberRef v16 = v32;
        goto LABEL_29;
      }

      CFNumberRef v24 = v23;
      CFArrayAppendValue(v18, v23);
      CFRelease(v24);
      --v21;
    }

    while (v21);
    a8 = v20;
    a2 = v19;
    CFNumberRef v16 = v32;
    if (!a6) {
      goto LABEL_16;
    }
    goto LABEL_10;
  }

void sub_1000EB950(void *value, CFMutableArrayRef theArray, uint64_t a3, uint64_t a4)
{
  unsigned __int8 v6 = *(void (**)(uint64_t, void, void, uint64_t, CFMutableArrayRef))(a4 + 4384);
  if (v6) {
    v6(a4, 0LL, *(void *)(a4 + 4392), 6LL, theArray);
  }
}

void sub_1000EB9A4(uint64_t a1, int a2)
{
  *(_BYTE *)(a1 + 5496) = a2;
  BOOL v3 = *(dispatch_source_s **)(a1 + 5504);
  if (a2) {
    dispatch_time_t v4 = dispatch_time(0LL, 10000000000LL);
  }
  else {
    dispatch_time_t v4 = -1LL;
  }
  dispatch_source_set_timer(v3, v4, 0xFFFFFFFFFFFFFFFFLL, 0LL);
  *(_DWORD *)(a1 + 68_Block_object_dispose(va, 8) = 0;
  *(void *)(a1 + 680) = 0LL;
}

void sub_1000EBA08(uint64_t a1, int a2)
{
  *(_DWORD *)(a1 + 5512) = a2;
  *(_BYTE *)(a1 + 1056) = 0;
  if (a2 == 1)
  {
    double Current = CFAbsoluteTimeGetCurrent();
    if (Current - *(double *)(a1 + 696) > 10.0)
    {
      *(double *)(a1 + 696) = Current;
      *(_BYTE *)(a1 + 72_Block_object_dispose(va, 8) = 0;
    }
  }

void sub_1000EBA54(uint64_t a1, uint64_t a2)
{
}

uint64_t sub_1000EBA5C(uint64_t a1)
{
  if (a1)
  {
    uint64_t v2 = objc_autoreleasePoolPush();
    if (qword_100219F60) {
      [qword_100219F60 WFLog:@"%s: wifid is hosting AWDL session." message:3];
    }
    uint64_t v3 = 1LL;
  }

  else
  {
    uint64_t v2 = objc_autoreleasePoolPush();
    if (qword_100219F60) {
      [qword_100219F60 WFLog:@"%s: null manager." message:@"WiFiDeviceManagerIsHostingAwdlSession"];
    }
    uint64_t v3 = 0LL;
  }

  objc_autoreleasePoolPop(v2);
  return v3;
}

void sub_1000EBB1C(uint64_t a1, CFArrayRef theArray)
{
  dispatch_time_t v4 = *(const void **)(a1 + 5576);
  if (v4)
  {
    CFRelease(v4);
    *(void *)(a1 + 5576) = 0LL;
  }

  if (theArray) {
    *(void *)(a1 + 5576) = CFArrayCreateCopy(kCFAllocatorDefault, theArray);
  }
}

uint64_t sub_1000EBB68(uint64_t a1, uint64_t a2)
{
  if (a1 && a2) {
    return sub_100055974(*(void *)(a1 + 64), a2);
  }
  else {
    return 83LL;
  }
}

void sub_1000EBB80(uint64_t a1)
{
  uint64_t v2 = (void *)MGCopyAnswer(@"ProductType", 0LL);
  uint64_t v3 = (void *)MGCopyAnswer(@"ProductVersion", 0LL);
  dispatch_time_t v4 = v3;
  if (v2)
  {
    if (v3)
    {
      *(_OWORD *)keys = *(_OWORD *)off_1001E4D00;
      values[0] = v2;
      values[1] = v3;
      CFDictionaryRef v5 = CFDictionaryCreate( kCFAllocatorDefault,  (const void **)keys,  (const void **)values,  2LL,  &kCFTypeDictionaryKeyCallBacks,  &kCFTypeDictionaryValueCallBacks);
      if (v5)
      {
        CFDictionaryRef v6 = v5;
        uint64_t v7 = *(void *)(a1 + 64);
        uint64_t v8 = (const void *)sub_100043E8C(v7);
        sub_10003EC6C(v7, v8, 490LL, 0LL, (uint64_t)v6);
        id v9 = objc_autoreleasePoolPush();
        if (qword_100219F60) {
          [(id)qword_100219F60 WFLog:3, "%s: productType:%@ iosVersion:%@", "WiFiDeviceManagerSetDeviceInfo", v2, v4 message];
        }
        objc_autoreleasePoolPop(v9);
LABEL_7:
        CFRelease(v2);
        if (!v4) {
          goto LABEL_9;
        }
        goto LABEL_8;
      }

      int v11 = objc_autoreleasePoolPush();
      if (qword_100219F60) {
        [qword_100219F60 WFLog:@"%s; failed to create dictionary" message:3];
      }
          "WiFiDeviceManagerSetDeviceInfo");
    }

    else
    {
      int v11 = objc_autoreleasePoolPush();
      if (qword_100219F60) {
        [qword_100219F60 WFLog:@"iosVersion is NULL"];
      }
    }

    objc_autoreleasePoolPop(v11);
    CFDictionaryRef v6 = 0LL;
    goto LABEL_7;
  }

  CFBooleanRef v10 = objc_autoreleasePoolPush();
  if (qword_100219F60) {
    [qword_100219F60 WFLog:@"%s: productType is NULL" message:3];
  }
  objc_autoreleasePoolPop(v10);
  CFDictionaryRef v6 = 0LL;
  if (v4) {
LABEL_8:
  }
    CFRelease(v4);
LABEL_9:
  if (v6) {
    CFRelease(v6);
  }
}

void sub_1000EBD90(uint64_t a1, const void *a2)
{
  uint64_t v20 = 0LL;
  uint64_t v21 = &v20;
  uint64_t v22 = 0x2020000000LL;
  uint64_t v23 = 0LL;
  uint64_t v16 = 0LL;
  unsigned __int8 v17 = &v16;
  uint64_t v18 = 0x2020000000LL;
  uint64_t v19 = 0LL;
  if (!a1)
  {
    uint64_t v13 = objc_autoreleasePoolPush();
    if (qword_100219F60) {
      [qword_100219F60 WFLog:@"%s: null manager." message:4];
    }
    goto LABEL_16;
  }

  if (!*(void *)(a1 + 64))
  {
    uint64_t v13 = objc_autoreleasePoolPush();
    if (qword_100219F60) {
      objc_msgSend((id)qword_100219F60, "WFLog:message:", 4, "%s: null device.", "WiFiDeviceManagerForgetNetwork");
    }
LABEL_16:
    objc_autoreleasePoolPop(v13);
    goto LABEL_11;
  }

  dispatch_time_t v4 = sub_100095BC8(a2);
  CFTypeRef v5 = CFRetain(v4);
  v21[3] = (uint64_t)v5;
  CFDictionaryRef v6 = (const void *)sub_10004CE2C(*(void *)(a1 + 64));
  CFTypeRef v7 = CFRetain(v6);
  v17[3] = (uint64_t)v7;
  [*(id *)(a1 + 6632) removeAllDenyListEntriesWithNetworkName:v21[3]];
  dispatch_queue_global_t global_queue = dispatch_get_global_queue(0LL, 0LL);
  block[0] = _NSConcreteStackBlock;
  block[1] = 3221225472LL;
  block[2] = sub_1000EC058;
  block[3] = &unk_1001E4D18;
  void block[4] = &v16;
  void block[5] = &v20;
  dispatch_async(global_queue, block);
  if (!a2)
  {
    double v14 = objc_autoreleasePoolPush();
    if (qword_100219F60) {
      [qword_100219F60 WFLog:@"%s: null network" message:3];
    }
    goto LABEL_19;
  }

  id v9 = (const __CFBoolean *)sub_1000951FC((uint64_t)a2, @"AutoHotspotDisableWiFiAutoJoinUntilUserJoin");
  CFBooleanRef v10 = v9;
  if (!v9) {
    goto LABEL_11;
  }
  CFTypeID v11 = CFGetTypeID(v9);
  if (v11 != CFBooleanGetTypeID())
  {
    double v14 = objc_autoreleasePoolPush();
    if (qword_100219F60) {
      [qword_100219F60 WFLog:@"WiFiDeviceManagerForgetNetwork: invalid value type"];
    }
LABEL_19:
    objc_autoreleasePoolPop(v14);
    goto LABEL_11;
  }

  if (CFBooleanGetValue(v10))
  {
    __n128 v12 = objc_autoreleasePoolPush();
    if (qword_100219F60) {
      [(id)qword_100219F60 WFLog:3, "%s: Auto Hotspot Disable for %@", "WiFiDeviceManagerForgetNetwork", sub_100095BC8(a2) message];
    }
    objc_autoreleasePoolPop(v12);
    CFArrayAppendValue(*(CFMutableArrayRef *)(a1 + 6880), a2);
  }

void sub_1000EC02C( _Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, ...)
{
}

void sub_1000EC058(uint64_t a1)
{
  uint64_t v2 = *(const void **)(*(void *)(*(void *)(a1 + 32) + 8LL) + 24LL);
  if (v2)
  {
    CFRelease(v2);
    *(void *)(*(void *)(*(void *)(a1 + 32) + 8LL) + 24LL) = 0LL;
  }

  uint64_t v3 = *(const void **)(*(void *)(*(void *)(a1 + 40) + 8LL) + 24LL);
  if (v3)
  {
    CFRelease(v3);
    *(void *)(*(void *)(*(void *)(a1 + 40) + 8LL) + 24LL) = 0LL;
  }

void sub_1000EC0CC(uint64_t a1, const void *a2)
{
  uint64_t v14 = 0LL;
  uint64_t v15 = &v14;
  uint64_t v16 = 0x2020000000LL;
  uint64_t v17 = 0LL;
  uint64_t v10 = 0LL;
  CFTypeID v11 = &v10;
  uint64_t v12 = 0x2020000000LL;
  uint64_t v13 = 0LL;
  if (!a1)
  {
    uint64_t v8 = objc_autoreleasePoolPush();
    if (qword_100219F60) {
      [qword_100219F60 WFLog:@"%s: null manager." message:4];
    }
    goto LABEL_9;
  }

  if (!*(void *)(a1 + 64))
  {
    uint64_t v8 = objc_autoreleasePoolPush();
    if (qword_100219F60) {
      [qword_100219F60 WFLog:@"%s: null device." message:4];
    }
LABEL_9:
    objc_autoreleasePoolPop(v8);
    goto LABEL_4;
  }

  uint64_t v3 = sub_100095BC8(a2);
  CFTypeRef v4 = CFRetain(v3);
  v15[3] = (uint64_t)v4;
  CFTypeRef v5 = (const void *)sub_10004CE2C(*(void *)(a1 + 64));
  CFTypeRef v6 = CFRetain(v5);
  void v11[3] = (uint64_t)v6;
  dispatch_queue_global_t global_queue = dispatch_get_global_queue(0LL, 0LL);
  block[0] = _NSConcreteStackBlock;
  block[1] = 3221225472LL;
  block[2] = sub_1000EC24C;
  block[3] = &unk_1001E4D18;
  void block[4] = &v10;
  void block[5] = &v14;
  dispatch_async(global_queue, block);
LABEL_4:
  _Block_object_dispose(&v10, 8);
  _Block_object_dispose(&v14, 8);
}

void sub_1000EC228( _Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, ...)
{
}

void sub_1000EC24C(uint64_t a1)
{
  uint64_t v2 = *(const void **)(*(void *)(*(void *)(a1 + 32) + 8LL) + 24LL);
  if (v2)
  {
    CFRelease(v2);
    *(void *)(*(void *)(*(void *)(a1 + 32) + 8LL) + 24LL) = 0LL;
  }

  uint64_t v3 = *(const void **)(*(void *)(*(void *)(a1 + 40) + 8LL) + 24LL);
  if (v3)
  {
    CFRelease(v3);
    *(void *)(*(void *)(*(void *)(a1 + 40) + 8LL) + 24LL) = 0LL;
  }

void sub_1000EC2C0(uint64_t a1, void *a2)
{
  if (a1 && a2)
  {
    sub_1000EC354(a1, a2, 0);
  }

  else
  {
    uint64_t v3 = objc_autoreleasePoolPush();
    if (qword_100219F60)
    {
      CFTypeRef v4 = "manager";
      if (a1) {
        CFTypeRef v4 = "network";
      }
      [qword_100219F60 WFLog:@"%s: %s is NULL" message:3, "WiFiDeviceManagerForceBssidAssociation", v4];
    }

    objc_autoreleasePoolPop(v3);
  }

NSError *sub_1000EC354(uint64_t a1, void *a2, int a3)
{
  CFTypeRef v6 = (_BYTE *)(a1 + 5211);
  if ((!_os_feature_enabled_impl("CoreWiFi", "UnifiedAutoJoin")
     || !_os_feature_enabled_impl("WiFiManager", "ColocatedScopeTransition")
     || !v6[1389])
    && !sub_1000951FC((uint64_t)a2, @"COLOCATED_NETWORK_SCOPE_ID"))
  {
    unsigned int v7 = sub_100096BF4((uint64_t)a2, @"ASSOC_FLAGS");
    sub_1000970C0((uint64_t)a2, @"ASSOC_FLAGS", v7 & 0xFFFFFFFE | 1LL);
  }

  *(_BYTE *)(a1 + 1192) = sub_1000951FC((uint64_t)a2, @"COLOCATED_NETWORK_SCOPE_ID") != 0LL;
  if (sub_10004D6C8(*(void *)(a1 + 64)) && sub_100098124(a2))
  {
    uint64_t v8 = objc_autoreleasePoolPush();
    if (qword_100219F60) {
      [(id)qword_100219F60 WFLog:3, "%s: Applying APPLE80211_ASSOC_F_BEACON_PROTECTION because network is capable (%@)", "__WiFiDeviceManagerAssociateCandidate", a2 message];
    }
    objc_autoreleasePoolPop(v8);
    unsigned int v9 = sub_100096BF4((uint64_t)a2, @"ASSOC_FLAGS");
    sub_1000970C0((uint64_t)a2, @"ASSOC_FLAGS", v9 & 0xFFFF7FFF | 0x8000LL);
  }

  if (sub_10004D6EC(*(void *)(a1 + 64)))
  {
    unsigned int v10 = sub_1000981F0((const __CFDictionary *)a2);
    CFTypeID v11 = objc_autoreleasePoolPush();
    if (v10)
    {
      if (qword_100219F60) {
        [(id)qword_100219F60 WFLog:3, "%s: Applying APPLE80211_ASSOC_F_SAE_PK because network is capable (%@)", "__WiFiDeviceManagerAssociateCandidate", a2 message];
      }
      objc_autoreleasePoolPop(v11);
      unsigned int v12 = sub_100096BF4((uint64_t)a2, @"ASSOC_FLAGS");
      sub_1000970C0((uint64_t)a2, @"ASSOC_FLAGS", v12 & 0xFFFBFFFF | 0x40000LL);
      unsigned int v13 = sub_100096BF4((uint64_t)a2, @"WSEC_FLAGS");
      unsigned int v14 = sub_100098260((const __CFDictionary *)a2);
      CFTypeID v11 = objc_autoreleasePoolPush();
      if (v14)
      {
        unsigned int v15 = v13 | 0x20000;
        if (qword_100219F60) {
          [(id)qword_100219F60 WFLog:3, "%s: Applying APPLE80211_ASSOC_F_SAE_PK_RESTRICT mode network is capable (%@)", "__WiFiDeviceManagerAssociateCandidate", a2 message];
        }
      }

      else
      {
        unsigned int v15 = v13 | 0x10000;
        if (qword_100219F60) {
          [(id)qword_100219F60 WFLog:3, "%s: Applying APPLE80211_ASSOC_F_SAE_PK_ENABLE because network is capable (%@)", "__WiFiDeviceManagerAssociateCandidate", a2 message];
        }
      }
    }

    else
    {
      if (qword_100219F60) {
        [(id)qword_100219F60 WFLog:3, "%s: Applying APPLE80211_ASSOC_F_SAE_PK_DISABLE mode network is incapable (%@)", "__WiFiDeviceManagerAssociateCandidate", a2 message];
      }
      unsigned int v15 = 0;
    }

    objc_autoreleasePoolPop(v11);
    sub_1000970C0((uint64_t)a2, @"WSEC_FLAGS", v15);
  }

  if (sub_10004D6E0(*(void *)(a1 + 64)) && sub_10009819C((CFDictionaryRef *)a2))
  {
    uint64_t v16 = objc_autoreleasePoolPush();
    if (qword_100219F60) {
      [(id)qword_100219F60 WFLog:3, "%s: Applying APPLE80211_ASSOC_F_OCV because network is capable (%@)", "__WiFiDeviceManagerAssociateCandidate", a2 message];
    }
    objc_autoreleasePoolPop(v16);
    unsigned int v17 = sub_100096BF4((uint64_t)a2, @"ASSOC_FLAGS");
    sub_1000970C0((uint64_t)a2, @"ASSOC_FLAGS", v17 & 0xFFFDFFFF | 0x20000LL);
  }

  uint64_t v18 = sub_1000A063C((CFDictionaryRef *)a2);
  id v19 = sub_1000E359C(a1);
  if (CWFKnownNetworkAssociatedDuringAWDLRealTimeMode(v18, v19))
  {
    uint64_t v20 = objc_autoreleasePoolPush();
    if (qword_100219F60) {
      [(id)qword_100219F60 WFLog:3, "%s: Applying APPLE80211_ASSOC_F_PREFER_NON_6GHZ because AWDL real time mode was recently active while associated to this known network (%@)", "__WiFiDeviceManagerAssociateCandidate", v18 message];
    }
    objc_autoreleasePoolPop(v20);
    unsigned int v21 = sub_100096BF4((uint64_t)a2, @"ASSOC_FLAGS");
    sub_1000970C0((uint64_t)a2, @"ASSOC_FLAGS", v21 & 0xFFFEFFFF | 0x10000LL);
  }

  uint64_t v22 = objc_autoreleasePoolPush();
  if (qword_100219F60)
  {
    uint64_t v23 = +[NSString stringWithFormat:]( &OBJC_CLASS___NSString,  "stringWithFormat:",  @"%s",  -[NSString UTF8String]( +[NSString stringWithFormat:]( &OBJC_CLASS___NSString,  "stringWithFormat:",  @"{%@*} %@",  @"AUTOJOIN, ASSOC",  +[NSString stringWithFormat:]( &OBJC_CLASS___NSString,  "stringWithFormat:",  @"Attempting auto join association of %@",  sub_100095BC8(a2))),  "UTF8String"));
    if (os_log_type_enabled((os_log_t)&_os_log_default, OS_LOG_TYPE_DEFAULT))
    {
      *(_DWORD *)__int128 buf = 136446210;
      uint64_t v54 = -[NSString UTF8String]( +[NSString stringWithFormat:]( &OBJC_CLASS___NSString,  "stringWithFormat:",  @"[WiFiPolicy] %s",  -[NSString UTF8String](v23, "UTF8String")),  "UTF8String");
      _os_log_impl( (void *)&_mh_execute_header,  (os_log_t)&_os_log_default,  OS_LOG_TYPE_DEFAULT,  "%{public}s",  buf,  0xCu);
    }
  }

  objc_autoreleasePoolPop(v22);
  if (!sub_1000FC698(a1, a2, 1u))
  {
    NSErrorUserInfoKey v51 = NSLocalizedDescriptionKey;
    uint64_t v52 = @"Assoc Candidate network not suitable for auto-join";
    double v45 = +[NSError errorWithDomain:code:userInfo:]( &OBJC_CLASS___NSError,  "errorWithDomain:code:userInfo:",  NSPOSIXErrorDomain,  1LL,  +[NSDictionary dictionaryWithObjects:forKeys:count:]( &OBJC_CLASS___NSDictionary,  "dictionaryWithObjects:forKeys:count:",  &v52,  &v51,  1LL));
    if (!(_DWORD)v45) {
      return v45;
    }
    goto LABEL_68;
  }

  [+[WiFiXPCManager sharedXPCManager](WiFiXPCManager, "sharedXPCManager") willAssociateWithNetwork:a2 isAutoJoin:1 interfaceName:sub_100043E8C(*(void *)(a1 + 64))];
  CFNumberRef v24 = *(void (**)(uint64_t, uint64_t, void *, void, void, void))(a1 + 3880);
  if (v24)
  {
    uint64_t v25 = sub_100043E8C(*(void *)(a1 + 64));
    v24(a1, v25, a2, 0LL, 0LL, *(void *)(a1 + 3888));
  }

  sub_1000D3E0C(a1);
  uint64_t v26 = objc_autoreleasePoolPush();
  [*(id *)(a1 + 6608) asyncTrackNetworksOfInterest:1];
  objc_autoreleasePoolPop(v26);
  *(_DWORD *)(a1 + 3464) = 0;
  int v27 = (const __CFNumber *)sub_1000951FC((uint64_t)a2, @"TransitionDisabledFlags");
  if (v27) {
    CFNumberGetValue(v27, kCFNumberSInt32Type, (void *)(a1 + 3464));
  }
  *(CFAbsoluteTime *)(a1 + 344_Block_object_dispose((const void *)(v9 - 48), 8) = CFAbsoluteTimeGetCurrent();
  if (*(void *)(a1 + 7280))
  {
    uint64_t v28 = objc_autoreleasePoolPush();
    id v29 = +[NSMutableDictionary dictionary](&OBJC_CLASS___NSMutableDictionary, "dictionary");
    unsigned int v30 = *(void **)(a1 + 7280);
    double v31 = (char *)[v30 count];
    if ((unint64_t)(v31 - 1) <= 9)
    {
      [v29 setObject:[v30 allObjects] forKey:@"BSS_BLACKLIST_BSSIDS"];
      sub_10009582C((uint64_t)a2, @"BSS_BLACKLIST", v29);
      CFTypeRef v32 = objc_autoreleasePoolPush();
      if (qword_100219F60) {
        [(id)qword_100219F60 WFLog:3, "BssBlacklist: %@", sub_1000951FC((uint64_t)a2, @"BSS_BLACKLIST"), v49 message];
      }
      goto LABEL_54;
    }

    __int128 v33 = v31;
    if ((unint64_t)v31 < 0xB)
    {
      CFTypeRef v32 = objc_autoreleasePoolPush();
      unint64_t v36 = (void *)qword_100219F60;
      if (qword_100219F60)
      {
        double v48 = v33;
        double v35 = "Unable to add BssBlacklist key to network for join. Count:%lu";
        goto LABEL_53;
      }
    }

    else
    {
      objc_msgSend( v29,  "setObject:forKey:",  objc_msgSend(objc_msgSend(v30, "allObjects"), "subarrayWithRange:", 0, 10),  @"BSS_BLACKLIST_BSSIDS");
      sub_10009582C((uint64_t)a2, @"BSS_BLACKLIST", v29);
      CFTypeRef v32 = objc_autoreleasePoolPush();
      uint64_t v34 = qword_100219F60;
      if (qword_100219F60)
      {
        double v48 = v33;
        unsigned int v49 = sub_1000951FC((uint64_t)a2, @"BSS_BLACKLIST");
        double v35 = "BssBlacklist capped to 3. Count:%lu. %@";
        unint64_t v36 = (void *)v34;
LABEL_53:
        objc_msgSend(v36, "WFLog:message:", 4, v35, v48, v49);
      }
    }

void sub_1000ECC9C(uint64_t a1, const void *a2, uint64_t a3, uint64_t a4)
{
  if (!a1)
  {
    unsigned int v17 = objc_autoreleasePoolPush();
    if (qword_100219F60) {
      [qword_100219F60 WFLog:@"%s: null manager." message:3];
    }
    goto LABEL_25;
  }

  if (!a2)
  {
    unsigned int v17 = objc_autoreleasePoolPush();
    if (qword_100219F60) {
      [qword_100219F60 WFLog:@"%s: null network." message:3 v19];
    }
    goto LABEL_25;
  }

  if (*(void *)(a1 + 6232))
  {
    unsigned int v17 = objc_autoreleasePoolPush();
    if (qword_100219F60) {
      [(id)qword_100219F60 WFLog:3, "%s: Already associating to %@", "WiFiDeviceManagerUserForcedAssociation", sub_100095BC8(*(const void **)(a1 + 6232)) message];
    }
LABEL_25:
    objc_autoreleasePoolPop(v17);
    return;
  }

  uint64_t v8 = (const void *)sub_100043E8C(*(void *)(a1 + 64));
  unsigned int v9 = sub_1000DEA34(a1, v8, 1);
  unsigned int v10 = objc_autoreleasePoolPush();
  if (qword_100219F60) {
    [(id)qword_100219F60 WFLog:3, "%s: Currently associated to %@", "WiFiDeviceManagerUserForcedAssociation", sub_100095BC8(v9) message];
  }
  objc_autoreleasePoolPop(v10);
  CFRetain(a2);
  *(void *)(a1 + 6232) = a2;
  *(void *)(a1 + 6216) = a3;
  *(void *)(a1 + 6224) = a4;
  if (v9 && CFEqual(v9, a2))
  {
    CFTypeID v11 = objc_autoreleasePoolPush();
    if (qword_100219F60) {
      [(id)qword_100219F60 WFLog:3, "%s: Already associated to requested network: %@", "WiFiDeviceManagerUserForcedAssociation", sub_100095BC8(a2) message];
    }
    objc_autoreleasePoolPop(v11);
    sub_1000ECFA0((void *)a1, (uint64_t)a2, 0LL);
    goto LABEL_17;
  }

  unsigned int v12 = objc_autoreleasePoolPush();
  if (qword_100219F60) {
    [(id)qword_100219F60 WFLog:3, "%s: starting forced association scan for %@", "WiFiDeviceManagerUserForcedAssociation", sub_100095BC8(a2) message];
  }
  objc_autoreleasePoolPop(v12);
  unsigned int v13 = sub_1000ED0D0((const __CFArray *)a2, 0LL, *(_DWORD *)(a1 + 128), 0x6Eu, 1);
  unsigned int v14 = malloc(0x28uLL);
  if (v14)
  {
    uint64_t v15 = (uint64_t)v14;
    void *v14 = a1;
    uint64_t v16 = (const void *)sub_100043E8C(*(void *)(a1 + 64));
    sub_1000E0CC4(a1, v16, v13, 0LL, (uint64_t)sub_1000ED584, v15, 0LL, 11LL);
    if (!v13) {
      goto LABEL_16;
    }
    goto LABEL_15;
  }

  uint64_t v18 = objc_autoreleasePoolPush();
  if (qword_100219F60) {
    [qword_100219F60 WFLog:@"%s: null scanData" message:4];
  }
  objc_autoreleasePoolPop(v18);
  if (v13) {
LABEL_15:
  }
    CFRelease(v13);
LABEL_16:
  if (v9) {
LABEL_17:
  }
    CFRelease(v9);
}

void sub_1000ECFA0(void *a1, uint64_t a2, uint64_t a3)
{
  if (!a1)
  {
    unsigned int v9 = objc_autoreleasePoolPush();
    if (qword_100219F60) {
      [qword_100219F60 WFLog:@"%s: null manager." message:3];
    }
    unsigned int v10 = v9;
    goto LABEL_14;
  }

  uint64_t v6 = a1[777];
  unsigned int v7 = objc_autoreleasePoolPush();
  if (!v6)
  {
    if (qword_100219F60) {
      [qword_100219F60 WFLog:@"%s: null callback" message:3];
    }
    unsigned int v10 = v7;
LABEL_14:
    objc_autoreleasePoolPop(v10);
    return;
  }

  if (qword_100219F60) {
    [qword_100219F60 WFLog:@"__WiFiDeviceManagerDispatchUserForcedAssociationCallback result %d" message:3];
  }
  objc_autoreleasePoolPop(v7);
  ((void (*)(void *, uint64_t, uint64_t, void))a1[777])(a1, a3, a2, a1[778]);
  a1[777] = 0LL;
  a1[778] = 0LL;
  uint64_t v8 = (const void *)a1[779];
  if (v8)
  {
    CFRelease(v8);
    a1[779] = 0LL;
  }

__CFDictionary *sub_1000ED0D0(const __CFArray *a1, const __CFArray *a2, int a3, unsigned int a4, int a5)
{
  unsigned int v39 = a4;
  int v40 = a3;
  CFMutableArrayRef Mutable = CFDictionaryCreateMutable( kCFAllocatorDefault,  0LL,  &kCFTypeDictionaryKeyCallBacks,  &kCFTypeDictionaryValueCallBacks);
  if (!Mutable) {
    return Mutable;
  }
  unsigned int v10 = CFStringCreateMutable(kCFAllocatorDefault, 0LL);
  CFDictionarySetValue(Mutable, @"SCAN_MERGE", kCFBooleanTrue);
  CFDictionarySetValue(Mutable, @"MONITOR_QBSS_LOAD", kCFBooleanTrue);
  CFDictionarySetValue(Mutable, @"SCAN_INC_BSS_LIST", kCFBooleanTrue);
  int valuePtr = a5;
  CFNumberRef v11 = CFNumberCreate(kCFAllocatorDefault, kCFNumberSInt32Type, &valuePtr);
  CFDictionarySetValue(Mutable, @"SCAN_TYPE", v11);
  if (v11) {
    CFRelease(v11);
  }
  int valuePtr = 3;
  CFNumberRef v12 = CFNumberCreate(kCFAllocatorDefault, kCFNumberSInt32Type, &valuePtr);
  CFDictionarySetValue(Mutable, @"SCAN_BSS_TYPE", v12);
  if (v12) {
    CFRelease(v12);
  }
  CFNumberRef v13 = CFNumberCreate(kCFAllocatorDefault, kCFNumberIntType, &v40);
  CFDictionarySetValue(Mutable, @"SCAN_RSSI_THRESHOLD", v13);
  if (v13) {
    CFRelease(v13);
  }
  if (!a1) {
    goto LABEL_35;
  }
  uint64_t v14 = sub_10009499C();
  if (v14 != CFGetTypeID(a1))
  {
    CFTypeID TypeID = CFArrayGetTypeID();
    if (TypeID == CFGetTypeID(a1) && CFArrayGetCount(a1) >= 1)
    {
      if (v10) {
        CFStringAppend(v10, @"Performing auto-join broadcast and directed scan for ");
      }
      CFMutableArrayRef v17 = CFArrayCreateMutable(kCFAllocatorDefault, 0LL, &kCFTypeArrayCallBacks);
      if (v17)
      {
        theArray = v17;
        CFIndex Count = CFArrayGetCount(a1);
        unint64_t v19 = Count - 1;
        if (Count >= 1)
        {
          CFIndex v20 = 0LL;
          if (v19 >= 8) {
            unint64_t v19 = 8LL;
          }
          unint64_t v21 = v19 + 1;
          do
          {
            ValueAtIndex = CFArrayGetValueAtIndex(a1, v20);
            uint64_t v23 = sub_100095BC8(ValueAtIndex);
            if (v23)
            {
              CFNumberRef v24 = v23;
              uint64_t v25 = CFDictionaryCreateMutable( kCFAllocatorDefault,  0LL,  &kCFTypeDictionaryKeyCallBacks,  &kCFTypeDictionaryValueCallBacks);
              if (v25)
              {
                uint64_t v26 = v25;
                CFDictionarySetValue(v25, @"SSID_STR", v24);
                CFArrayAppendValue(theArray, v26);
                CFRelease(v26);
                if (v10) {
                  CFStringAppendFormat(v10, 0LL, @"%@ ", v24);
                }
              }
            }

            ++v20;
          }

          while (v21 != v20);
        }

        if (CFArrayGetCount(theArray))
        {
          int v27 = CFDictionaryCreateMutable( kCFAllocatorDefault,  0LL,  &kCFTypeDictionaryKeyCallBacks,  &kCFTypeDictionaryValueCallBacks);
          if (v27)
          {
            uint64_t v28 = v27;
            CFDictionarySetValue(v27, @"SSID_STR", &stru_1001EB6E0);
            CFArrayAppendValue(theArray, v28);
            CFRelease(v28);
          }

          CFDictionarySetValue(Mutable, @"SCAN_SSID_LIST", theArray);
        }

        CFRelease(theArray);
      }

      goto LABEL_37;
    }

void sub_1000ED584(uint64_t a1, uint64_t a2, const __CFArray *a3, uint64_t a4, uint64_t a5, uint64_t *a6)
{
  if (!a6)
  {
    uint64_t v14 = objc_autoreleasePoolPush();
    if (qword_100219F60) {
      [qword_100219F60 WFLog:@"%s: null scanData" message:4];
    }
    goto LABEL_14;
  }

  uint64_t v8 = (void *)*a6;
  sub_100104644(*a6, a3);
  unsigned int v9 = (const void *)v8[779];
  if (v9)
  {
    if (a3 && CFArrayGetCount(a3))
    {
      ValueAtIndex = (void *)CFArrayGetValueAtIndex(a3, 0LL);
      if (CFEqual(v9, ValueAtIndex))
      {
LABEL_6:
        CFNumberRef v11 = objc_autoreleasePoolPush();
        if (qword_100219F60) {
          [qword_100219F60 WFLog:@"%s: disabling device manager" message:3];
        }
        objc_autoreleasePoolPop(v11);
        sub_1000D03E4((uint64_t)v8);
        sub_100095524((uint64_t)ValueAtIndex, (uint64_t)v9);
        CFNumberRef v12 = objc_autoreleasePoolPush();
        if (qword_100219F60) {
          [qword_100219F60 WFLog:@"__WiFiDeviceManagerUserForcedAssociationScanCallback: found matching network in scan results, proceeding with association"];
        }
        objc_autoreleasePoolPop(v12);
        CFNumberRef v13 = (const void *)sub_100043E8C(v8[8]);
        sub_1000E1104((uint64_t)v8, v13, ValueAtIndex, 0LL, 0LL, (uint64_t)sub_10010F2A4, 0LL, 1011LL);
        goto LABEL_15;
      }

      if (sub_100096D08((const __CFDictionary *)ValueAtIndex) && (sub_100098EA8((uint64_t)v9) & 2) != 0)
      {
        CFMutableArrayRef v17 = objc_autoreleasePoolPush();
        if (qword_100219F60) {
          [qword_100219F60 WFLog:@"%s: scanned network is SAE, provided network is WPA capable" message:3];
        }
        objc_autoreleasePoolPop(v17);
        goto LABEL_6;
      }

      sub_1000ECFA0(v8, (uint64_t)v9, 1LL);
      uint64_t v14 = objc_autoreleasePoolPush();
      uint64_t v15 = (void *)qword_100219F60;
      if (qword_100219F60)
      {
        uint64_t v16 = "%s: scanned network is not equal";
        goto LABEL_13;
      }
    }

    else
    {
      sub_1000ECFA0(v8, (uint64_t)v9, 1LL);
      uint64_t v14 = objc_autoreleasePoolPush();
      uint64_t v15 = (void *)qword_100219F60;
      if (qword_100219F60)
      {
        uint64_t v16 = "%s: scan results were empty";
LABEL_13:
        objc_msgSend(v15, "WFLog:message:", 3, v16, "__WiFiDeviceManagerUserForcedAssociationScanCallback");
      }
    }

void sub_1000ED82C(uint64_t a1, const void *a2, uint64_t a3, uint64_t a4)
{
  if (!a1)
  {
    CFMutableArrayRef v17 = objc_autoreleasePoolPush();
    if (qword_100219F60) {
      [qword_100219F60 WFLog:@"%s: null manager." message:3];
    }
    goto LABEL_25;
  }

  if (!a2)
  {
    CFMutableArrayRef v17 = objc_autoreleasePoolPush();
    if (qword_100219F60) {
      [qword_100219F60 WFLog:@"%s: null network." message:3 v19];
    }
    goto LABEL_25;
  }

  if (*(void *)(a1 + 6264))
  {
    CFMutableArrayRef v17 = objc_autoreleasePoolPush();
    if (qword_100219F60) {
      [(id)qword_100219F60 WFLog:3, "%s: Already associating to %@", "WiFiDeviceManagerAddNetworkScan", sub_100095BC8(*(const void **)(a1 + 6264)) message];
    }
LABEL_25:
    objc_autoreleasePoolPop(v17);
    return;
  }

  uint64_t v8 = (const void *)sub_100043E8C(*(void *)(a1 + 64));
  unsigned int v9 = sub_1000DEA34(a1, v8, 1);
  unsigned int v10 = objc_autoreleasePoolPush();
  if (qword_100219F60) {
    [(id)qword_100219F60 WFLog:3, "%s: Currently associated to %@", "WiFiDeviceManagerAddNetworkScan", sub_100095BC8(v9) message];
  }
  objc_autoreleasePoolPop(v10);
  CFRetain(a2);
  *(void *)(a1 + 6264) = a2;
  *(void *)(a1 + 624_Block_object_dispose((const void *)(v9 - 48), 8) = a3;
  *(void *)(a1 + 6256) = a4;
  if (v9 && CFEqual(v9, a2))
  {
    CFNumberRef v11 = objc_autoreleasePoolPush();
    if (qword_100219F60) {
      [(id)qword_100219F60 WFLog:3, "%s: Already associated to requested network: %@", "WiFiDeviceManagerAddNetworkScan", sub_100095BC8(a2) message];
    }
    objc_autoreleasePoolPop(v11);
    sub_1000EDB34((void *)a1, (uint64_t)a2, 3LL, 0LL);
    goto LABEL_17;
  }

  CFNumberRef v12 = objc_autoreleasePoolPush();
  if (qword_100219F60) {
    [(id)qword_100219F60 WFLog:3, "%s: starting forced association scan for %@", "WiFiDeviceManagerAddNetworkScan", sub_100095BC8(a2) message];
  }
  objc_autoreleasePoolPop(v12);
  CFNumberRef v13 = sub_1000ED0D0(0LL, 0LL, *(_DWORD *)(a1 + 128), 0, 1);
  uint64_t v14 = malloc(0x28uLL);
  if (v14)
  {
    uint64_t v15 = (uint64_t)v14;
    void *v14 = a1;
    uint64_t v16 = (const void *)sub_100043E8C(*(void *)(a1 + 64));
    sub_1000E0CC4(a1, v16, v13, 0LL, (uint64_t)sub_1000EDC98, v15, 0LL, 11LL);
    if (!v13) {
      goto LABEL_16;
    }
    goto LABEL_15;
  }

  uint64_t v18 = objc_autoreleasePoolPush();
  if (qword_100219F60) {
    objc_msgSend((id)qword_100219F60, "WFLog:message:", 4, "%s: null scanData", "WiFiDeviceManagerAddNetworkScan");
  }
  objc_autoreleasePoolPop(v18);
  if (v13) {
LABEL_15:
  }
    CFRelease(v13);
LABEL_16:
  if (v9) {
LABEL_17:
  }
    CFRelease(v9);
}

void sub_1000EDB34(void *a1, uint64_t a2, uint64_t a3, const __CFArray *a4)
{
  if (!a1)
  {
    CFNumberRef v12 = objc_autoreleasePoolPush();
    if (qword_100219F60) {
      [qword_100219F60 WFLog:@"%s: null manager." message:3];
    }
    CFNumberRef v13 = v12;
    goto LABEL_12;
  }

  uint64_t v8 = a1[781];
  unsigned int v9 = objc_autoreleasePoolPush();
  unsigned int v10 = (void *)qword_100219F60;
  if (!v8)
  {
    if (qword_100219F60) {
      [qword_100219F60 WFLog:@"__WiFiDeviceManagerDispatchAddNetworkScanCallback: null callback"];
    }
    CFNumberRef v13 = v9;
LABEL_12:
    objc_autoreleasePoolPop(v13);
    return;
  }

  if (qword_100219F60)
  {
    if (a4) {
      CFIndex Count = CFArrayGetCount(a4);
    }
    else {
      CFIndex Count = 0LL;
    }
    [v10 WFLog:@"__WiFiDeviceManagerDispatchAddNetworkScanCallback" message:3, "%s: result %d count %ld", "__WiFiDeviceManagerDispatchAddNetworkScanCallback", a3, Count];
  }

  objc_autoreleasePoolPop(v9);
  ((void (*)(void *, uint64_t, const __CFArray *, uint64_t, void))a1[781])(a1, a3, a4, a2, a1[782]);
  a1[781] = 0LL;
  a1[782] = 0LL;
  uint64_t v14 = (const void *)a1[783];
  if (v14)
  {
    CFRelease(v14);
    a1[783] = 0LL;
  }

void sub_1000EDC98(int a1, int a2, CFArrayRef theArray, uint64_t a4, int a5, void *a6)
{
  if (a6)
  {
    unsigned int v9 = (void *)*a6;
    if (theArray
      && CFArrayGetCount(theArray)
      && (MutableCFStringRef Copy = CFArrayCreateMutableCopy(kCFAllocatorDefault, 0LL, theArray)) != 0LL)
    {
      CFNumberRef v11 = MutableCopy;
      v13.length = CFArrayGetCount(MutableCopy);
      v13.location = 0LL;
      CFArraySortValues(v11, v13, (CFComparatorFunction)sub_10009C3F0, 0LL);
      sub_1000EDB34(v9, v9[783], a5 != 0, v11);
      CFRelease(v11);
    }

    else
    {
      sub_1000EDB34(v9, v9[783], a5 != 0, 0LL);
    }
  }

  else
  {
    CFNumberRef v12 = objc_autoreleasePoolPush();
    if (qword_100219F60) {
      [qword_100219F60 WFLog:@"__WiFiDeviceManagerAddNetworkScanCallback: null scanData"];
    }
    objc_autoreleasePoolPop(v12);
  }

  free(a6);
}

uint64_t sub_1000EDDA4(uint64_t result, uint64_t a2, uint64_t a3)
{
  *(void *)(result + 4752) = a2;
  *(void *)(result + 4760) = a3;
  return result;
}

void sub_1000EDDB0(uint64_t a1)
{
  uint64_t v2 = objc_autoreleasePoolPush();
  if (!a1)
  {
    uint64_t v3 = objc_autoreleasePoolPush();
    if (qword_100219F60) {
      [qword_100219F60 WFLog:@"%s: deviceManager is NULL!" message:3];
    }
    goto LABEL_6;
  }

  if (*(_DWORD *)(a1 + 20) != 1)
  {
    uint64_t v3 = objc_autoreleasePoolPush();
    if (qword_100219F60) {
      [qword_100219F60 WFLog:@"wifi is off" message:@"WiFiDeviceManagerNoNetworksFoundNotification"];
    }
    goto LABEL_6;
  }

  if (sub_1000EBA5C(a1))
  {
    uint64_t v3 = objc_autoreleasePoolPush();
    if (qword_100219F60) {
      [qword_100219F60 WFLog:@"%s: in AWDL session, not reporting no network soft-error" message:@"WiFiDeviceManagerNoNetworksFoundNotification"];
    }
    goto LABEL_6;
  }

  CFTypeRef v4 = (const void *)sub_10004CE2C(*(void *)(a1 + 64));
  CFTypeRef v5 = sub_1000DEA34(a1, v4, 1);
  if (!v5)
  {
    uint64_t v6 = *(const __CFArray **)(a1 + 3360);
    if (v6 && CFArrayGetCount(v6))
    {
      if (sub_10004C6CC(*(void *)(a1 + 64)))
      {
        unsigned int v7 = *(void (**)(uint64_t, uint64_t, void, void))(a1 + 4544);
        if (v7)
        {
          v7(a1, 2LL, 0LL, *(void *)(a1 + 4552));
          goto LABEL_13;
        }

        uint64_t v3 = objc_autoreleasePoolPush();
        if (qword_100219F60) {
          [qword_100219F60 WFLog:@"%s: softErrorManagerService callback is NULL!" message:3];
        }
      }

      else
      {
        uint64_t v3 = objc_autoreleasePoolPush();
        if (qword_100219F60) {
          [qword_100219F60 WFLog:@"%s: EAP is not idle, not reporting no network soft-error" message:3];
        }
      }
    }

    else
    {
      uint64_t v3 = objc_autoreleasePoolPush();
      if (qword_100219F60) {
        [qword_100219F60 WFLog:@"%s: no known networks at this location, not reporting no network soft-error" message:@"WiFiDeviceManagerNoNetworksFoundNotification"];
      }
    }

void sub_1000EDFE8( uint64_t a1, const __CFString *a2, unint64_t a3, const void *a4, const void *a5, const void *a6)
{
  if (a1)
  {
    if (*(void *)(a1 + 64))
    {
      CFMutableDictionaryRef Mutable = CFDictionaryCreateMutable( kCFAllocatorDefault,  0LL,  &kCFTypeDictionaryKeyCallBacks,  &kCFTypeDictionaryValueCallBacks);
      if (Mutable)
      {
        CFRange v13 = Mutable;
        if ((unint64_t)a2 | a3)
        {
          if (a2)
          {
            CFStringRef Copy = CFStringCreateCopy(kCFAllocatorDefault, a2);
            if (Copy)
            {
              uint64_t v15 = Copy;
              CFDictionaryAddValue(v13, @"BSSID", Copy);
              uint64_t v16 = objc_autoreleasePoolPush();
              if (qword_100219F60) {
                [(id)qword_100219F60 WFLog:3, "%s: bssidStrRef:%@ bssidLen:%ld ", "WiFiDeviceManagerSetRoam", v15, CFStringGetLength(v15) message];
              }
              objc_autoreleasePoolPop(v16);
              CFDataRef v17 = 0LL;
              if (!a3) {
                goto LABEL_35;
              }
              goto LABEL_21;
            }

            CFNumberRef v29 = objc_autoreleasePoolPush();
            if (qword_100219F60) {
              [qword_100219F60 WFLog:@"%s: bssidStrRef is NULL" message:3];
            }
LABEL_60:
            objc_autoreleasePoolPop(v29);
LABEL_47:
            CFRelease(v13);
            return;
          }

          __int16 v31 = -1;
          *(_DWORD *)bytes = -1;
          CFDataRef v24 = CFDataCreate(kCFAllocatorDefault, bytes, 6LL);
          if (v24)
          {
            CFDataRef v17 = v24;
            CFDictionaryAddValue(v13, @"BSSID", v24);
            uint64_t v15 = 0LL;
            if (!a3)
            {
LABEL_35:
              if (a4) {
                CFDictionaryAddValue(v13, @"BAND_FOR_CHANNEL", a4);
              }
              if (a5) {
                CFDictionaryAddValue(v13, @"BAND_PREFERENCE", a5);
              }
              if (a6) {
                CFDictionaryAddValue(v13, @"ROAM_FLAGS", a6);
              }
              int v27 = objc_autoreleasePoolPush();
              if (qword_100219F60) {
                [(id)qword_100219F60 WFLog:3, "%s:calling DeviceSetRoam with :%@", "WiFiDeviceManagerSetRoam", v13 message];
              }
              objc_autoreleasePoolPop(v27);
              sub_10005341C(*(void *)(a1 + 64), (uint64_t)v13);
              if (v15) {
                CFRelease(v15);
              }
              if (v17) {
                CFRelease(v17);
              }
              goto LABEL_47;
            }

void sub_1000EE484(uint64_t a1, const void *a2)
{
  if (a1)
  {
    uint64_t v3 = *(void *)(a1 + 64);
    if (v3)
    {
      if (*(_BYTE *)(a1 + 38))
      {
        sub_100054E88(v3, a2);
        return;
      }

      CFTypeRef v4 = objc_autoreleasePoolPush();
      if (qword_100219F60) {
        [qword_100219F60 WFLog:@"Debug CoreCapture is disabled" message:3];
      }
    }

    else
    {
      CFTypeRef v4 = objc_autoreleasePoolPush();
      if (qword_100219F60) {
        [qword_100219F60 WFLog:@"%s: manager->device is NULL" message:3];
      }
    }
  }

  else
  {
    CFTypeRef v4 = objc_autoreleasePoolPush();
    if (qword_100219F60) {
      [qword_100219F60 WFLog:@"%s: manager is NULL" message:3];
    }
  }

  objc_autoreleasePoolPop(v4);
}

void sub_1000EE564(uint64_t a1)
{
  double Current = CFAbsoluteTimeGetCurrent();
  double v3 = *(double *)(a1 + 5536);
  if (v3 == 0.0 || Current - v3 > 1800.0)
  {
    *(double *)(a1 + 5536) = Current;
    char v4 = 1;
    double v3 = Current;
  }

  else
  {
    char v4 = *(_BYTE *)(a1 + 5544) + 1;
  }

  CFTypeRef v5 = (unsigned __int8 *)(a1 + 5544);
  *(_BYTE *)(a1 + 5544) = v4;
  double v6 = Current - v3;
  double v7 = Current - *(double *)(a1 + 5528);
  uint64_t v8 = objc_autoreleasePoolPush();
  if (qword_100219F60) {
    objc_msgSend( (id)qword_100219F60,  "WFLog:message:",  4,  "%s: timeSinceFirstDisassoc: %f minutes, link lost: %d times, timeSinceLastChipTrap: %f hour, lastChipTrapTime: %f \n",  "WiFiDeviceManagerTriggerReport",  v6 / 60.0,  *v5,  v7 / 3600.0,  *(void *)(a1 + 5528));
  }
  objc_autoreleasePoolPop(v8);
  if (*v5 >= 0xAu && v6 <= 1800.0 && (v7 >= 36000.0 || *(double *)(a1 + 5528) == 0.0))
  {
    unsigned int v9 = objc_autoreleasePoolPush();
    if (qword_100219F60) {
      [(id)qword_100219F60 WFLog:3, "%s: Trigger Watchdog at driver:%@", "WiFiDeviceManagerTriggerReport", @"AssocTimeoutWatchdog" message];
    }
    objc_autoreleasePoolPop(v9);
    sub_1000EE484(a1, @"AssocTimeoutWatchdog");
    *CFTypeRef v5 = 0;
    *(void *)(a1 + 5536) = 0LL;
    *(double *)(a1 + 552_Block_object_dispose((const void *)(v9 - 48), 8) = Current;
  }

  else
  {
    unsigned int v10 = objc_autoreleasePoolPush();
    if (qword_100219F60) {
      [(id)qword_100219F60 WFLog:3, "%s: Trigger CoreCapture at driver:%@", "WiFiDeviceManagerTriggerReport", @"AssocTimeoutCoreCapture" message];
    }
    objc_autoreleasePoolPop(v10);
    sub_1000EE484(a1, @"AssocTimeoutCoreCapture");
  }

uint64_t sub_1000EE760(uint64_t a1)
{
  if (a1) {
    return *(unsigned int *)(a1 + 6200);
  }
  uint64_t v2 = objc_autoreleasePoolPush();
  if (qword_100219F60) {
    [qword_100219F60 WFLog:@"%s: deviceManager is NULL!" message:3];
  }
  objc_autoreleasePoolPop(v2);
  return 0LL;
}

uint64_t sub_1000EE7CC(uint64_t a1)
{
  if (a1) {
    return a1 + 5608;
  }
  else {
    return 0LL;
  }
}

uint64_t sub_1000EE7E0(uint64_t a1)
{
  if (a1) {
    return a1 + 8984;
  }
  else {
    return 0LL;
  }
}

uint64_t sub_1000EE7F4(uint64_t a1, CFArrayRef theArray, __CFArray *a3)
{
  if (a1 && theArray && a3)
  {
    if (CFArrayGetCount(theArray) >= 1)
    {
      CFIndex v6 = 0LL;
      do
      {
        ValueAtIndex = CFArrayGetValueAtIndex(theArray, v6);
        uint64_t v8 = *(const __CFArray **)(a1 + 3528);
        v12.length = CFArrayGetCount(v8);
        v12.location = 0LL;
        LODWORD(v_Block_object_dispose((const void *)(v9 - 48), 8) = CFArrayContainsValue(v8, v12, ValueAtIndex);
        unsigned int v9 = *(const __CFArray **)(a1 + 3520);
        v13.length = CFArrayGetCount(v9);
        v13.location = 0LL;
        ++v6;
      }

      while (v6 < CFArrayGetCount(theArray));
    }

    if (CFArrayGetCount(a3)) {
      return 1LL;
    }
  }

  else
  {
    CFNumberRef v11 = objc_autoreleasePoolPush();
    if (qword_100219F60) {
      [qword_100219F60 WFLog:@"WiFiDeviceManagerFilterForKnownNetworksInScanResults: called with improper arguments!"];
    }
    objc_autoreleasePoolPop(v11);
  }

  return 0LL;
}

BOOL sub_1000EE928(BOOL result)
{
  if (result) {
    return *(_DWORD *)(result + 5388) == 102 && (*(_BYTE *)(result + 5384) & 1) != 0 || *(_BYTE *)(result + 50) != 0;
  }
  return result;
}

BOOL sub_1000EE95C(BOOL result)
{
  if (result) {
    return *(_DWORD *)(result + 5388) == 102 && (*(_BYTE *)(result + 5384) & 2) != 0 || *(_BYTE *)(result + 49) != 0;
  }
  return result;
}

void sub_1000EE990(uint64_t a1, unsigned int a2, uint64_t a3, uint64_t a4)
{
  if (a1)
  {
    uint64_t v8 = *(void *)(a1 + 64);
    unsigned int v9 = (const void *)sub_100043E8C(v8);
    unsigned int v10 = sub_100040538(v8, v9);
    CFNumberRef v11 = objc_autoreleasePoolPush();
    if (qword_100219F60) {
      objc_msgSend( (id)qword_100219F60,  "WFLog:message:",  3,  "%s: setting user auto join %d (trigger %d, locState %d)",  "WiFiDeviceManagerSetUserAutoJoin",  a2,  a3,  a4);
    }
    objc_autoreleasePoolPop(v11);
    if (a2 || !v10 || *(_BYTE *)(a1 + 6272))
    {
      if (*(unsigned __int8 *)(a1 + 6272) == a2)
      {
LABEL_28:
        if (v10) {
          CFRelease(v10);
        }
        return;
      }
    }

    else
    {
      CFRange v12 = objc_autoreleasePoolPush();
      if (qword_100219F60) {
        [(id)qword_100219F60 WFLog:3, "%s: new state is disabled while connected to network %@", "WiFiDeviceManagerSetUserAutoJoin", v10 message];
      }
      objc_autoreleasePoolPop(v12);
    }

    *(_BYTE *)(a1 + 6272) = a2;
    CFRange v13 = *(void **)(a1 + 7320);
    if (v13) {
      [v13 setControlCenterState:a2 != 0 withKnownLocation:(_DWORD)a4 != 3 forInterface:sub_100043E8C(*(void *)(a1 + 64))];
    }
    sub_1000DE0D0(a1, 2u, a2 != 0);
    if (a2)
    {
      sub_1000EECC8(a1);
      sub_1000D0428(a1);
      sub_1000D16F4(a1, 1);
      *(_DWORD *)(a1 + 192) = 15;
      if (_os_feature_enabled_impl("CoreWiFi", "UnifiedAutoJoin"))
      {
        sub_1000F5F98(a1, 0x28uLL);
      }

      else
      {
        [+[WiFiXPCManager sharedXPCManager](WiFiXPCManager, "sharedXPCManager") autoJoinStartedWithTrigger:40 interfaceName:sub_100043E8C(*(void *)(a1 + 64))];
        sub_1000D0A5C(a1, 2LL, (uint64_t)"WiFiDeviceManagerSetUserAutoJoin");
      }
    }

    else
    {
      uint64_t v14 = objc_autoreleasePoolPush();
      if (v10)
      {
        if (qword_100219F60) {
          [(id)qword_100219F60 WFLog:3, "%s: user auto join disabled, disconnecting from current network %@", "WiFiDeviceManagerSetUserAutoJoin", sub_100095BC8(v10) message];
        }
        objc_autoreleasePoolPop(v14);
        uint64_t v15 = (const void *)sub_100043E8C(*(void *)(a1 + 64));
        sub_1000CE074(a1, v15, 1011LL, "WiFiDeviceManagerSetUserAutoJoin", 34328LL);
      }

      else
      {
        if (qword_100219F60) {
          [qword_100219F60 WFLog:@"No current network" message:3];
        }
        objc_autoreleasePoolPop(v14);
      }

      sub_1000EECC8(a1);
      sub_1000D0428(a1);
      sub_1000D16F4(a1, 1);
      *(_DWORD *)(a1 + 192) = 15;
    }

    sub_1000D4854(a1);
    goto LABEL_28;
  }

  uint64_t v16 = objc_autoreleasePoolPush();
  if (qword_100219F60) {
    [qword_100219F60 WFLog:@"%s: null device manager" message:4];
  }
  objc_autoreleasePoolPop(v16);
}

void sub_1000EECC8(uint64_t a1)
{
  if (!a1)
  {
    double v3 = objc_autoreleasePoolPush();
    if (qword_100219F60) {
      [qword_100219F60 WFLog:@"%s: deviceManager is NULL!"];
    }
    goto LABEL_9;
  }

  uint64_t v1 = *(void (**)(uint64_t, uint64_t, void, void))(a1 + 4544);
  if (!v1)
  {
    double v3 = objc_autoreleasePoolPush();
    if (qword_100219F60) {
      [qword_100219F60 WFLog:@"__WiFiDeviceManagerUserAutoJoinPreferenceChangedNotification: softErrorManagerService callback is NULL!"];
    }
LABEL_9:
    objc_autoreleasePoolPop(v3);
    return;
  }

  if (*(_BYTE *)(a1 + 6272)) {
    uint64_t v2 = 7LL;
  }
  else {
    uint64_t v2 = 8LL;
  }
  v1(a1, v2, 0LL, *(void *)(a1 + 4552));
}

void sub_1000EED88(uint64_t a1, int a2)
{
  uint64_t v55 = objc_autoreleasePoolPush();
  valuePtr[0] = 0.0;
  *(_DWORD *)buffer = 0;
  if (a1 && *(void *)(a1 + 7320))
  {
    char v4 = (unsigned __int8 *)(a1 + 5208);
    CFTypeRef v5 = objc_autoreleasePoolPush();
    CFIndex v6 = (void *)qword_100219F60;
    if (qword_100219F60)
    {
      uint64_t v52 = v5;
      double v7 = sub_100095BC8(*(const void **)(a1 + 5200));
      uint64_t v50 = *v4;
      NSErrorUserInfoKey v51 = v7;
      uint64_t v49 = *(unsigned __int8 *)(a1 + 5209);
      uint64_t v48 = *(unsigned int *)(a1 + 5248);
      uint64_t v47 = *(unsigned __int8 *)(a1 + 5354);
      uint64_t v46 = *(unsigned __int8 *)(a1 + 5353);
      uint64_t v45 = *(unsigned __int8 *)(a1 + 5352);
      uint64_t v8 = *(const __CFSet **)(a1 + 5280);
      if (v8) {
        CFIndex Count = CFSetGetCount(v8);
      }
      else {
        CFIndex Count = 0LL;
      }
      unsigned int v9 = *(const __CFSet **)(a1 + 5288);
      if (v9) {
        CFIndex v43 = CFSetGetCount(v9);
      }
      else {
        CFIndex v43 = 0LL;
      }
      int v53 = a2;
      unsigned int v10 = *(const __CFSet **)(a1 + 5296);
      if (v10) {
        CFIndex v11 = CFSetGetCount(v10);
      }
      else {
        CFIndex v11 = 0LL;
      }
      CFRange v12 = *(const __CFSet **)(a1 + 5304);
      if (v12) {
        CFIndex v13 = CFSetGetCount(v12);
      }
      else {
        CFIndex v13 = 0LL;
      }
      uint64_t v14 = *(unsigned __int8 *)(a1 + 5211);
      uint64_t v15 = *(unsigned __int8 *)(a1 + 5213);
      uint64_t v16 = *(unsigned __int8 *)(a1 + 5252);
      uint64_t v17 = *(unsigned __int8 *)(a1 + 5320);
      uint64_t v18 = *(const __CFSet **)(a1 + 5264);
      if (v18) {
        CFIndex v19 = CFSetGetCount(v18);
      }
      else {
        CFIndex v19 = 0LL;
      }
      CFIndex v20 = *(const __CFSet **)(a1 + 5272);
      if (v20) {
        CFIndex v20 = (const __CFSet *)CFSetGetCount(v20);
      }
      objc_msgSend( v6,  "WFLog:message:",  3,  "%s: PHSession: Network=%@;Channel=%d;STACount=%d(Max=%d,USB=%d,BT=%d,WiFi=%d,Broadcast=%ld,Hidden=%ld;Other=%ld;"
        "NanLink=%ld);MISEnabled=%d;MISDiscoveryEnabled=%d;MISHidden=%d;MISScanBlocked=%d;LegacyClients=%ld;InstantClient"
        "s=%ld;Force2.4GHz=%d;ForceDisconnectInfra=%d",
        "__WiFiDeviceManagerUpdateSoftApUsageSession",
        v51,
        v50,
        v49,
        v48,
        v47,
        v46,
        v45,
        Count,
        v43,
        v11,
        v13,
        v14,
        v15,
        v16,
        v17,
        v19,
        v20,
        *(unsigned __int8 *)(a1 + 5376),
        *(unsigned __int8 *)(a1 + 5377));
      a2 = v53;
      CFTypeRef v5 = v52;
    }

    objc_autoreleasePoolPop(v5);
    unint64_t v21 = *(const __CFDictionary **)(a1 + 6984);
    if (v21)
    {
      CFBooleanRef Value = (const __CFNumber *)CFDictionaryGetValue(v21, @"SOFTAP_LOWPOWER_STATS_LOWPOWER_STATE_DURATION");
      if (Value) {
        CFNumberGetValue(Value, kCFNumberDoubleType, valuePtr);
      }
    }

    uint64_t v23 = *(const __CFString **)(a1 + 7304);
    if (v23)
    {
      v58.length = CFStringGetLength(*(CFStringRef *)(a1 + 7304));
      v58.location = 0LL;
      CFStringGetBytes(v23, v58, 0x8000100u, 0, 0, buffer, 4LL, 0LL);
    }

    double v24 = *(double *)(a1 + 6296);
    if (v24 == 0.0)
    {
      double v27 = 0.0;
    }

    else
    {
      double v25 = *(double *)(a1 + 6304);
      double v26 = v25 - v24;
      if (v25 == 0.0) {
        double v27 = 0.0;
      }
      else {
        double v27 = v26;
      }
    }

    unsigned int v28 = *(_DWORD *)(a1 + 6280) - 1;
    if (v28 > 7) {
      CFNumberRef v29 = @"Unknown";
    }
    else {
      CFNumberRef v29 = off_1001E5550[v28];
    }
    uint64_t v54 = v29;
    int v30 = *(_DWORD *)(a1 + 6284) - 1;
    else {
      uint64_t v31 = (uint64_t)*(&off_1001E5590 + v30);
    }
    unsigned int v32 = *(_DWORD *)(a1 + 6288) - 1;
    if (v32 > 6) {
      __int16 v33 = 0LL;
    }
    else {
      __int16 v33 = off_1001E5628[v32];
    }
    CFRange v34 = *(void **)(a1 + 7320);
    uint64_t v35 = *v4;
    uint64_t v36 = *(int *)buffer;
    BOOL v37 = *(_BYTE *)(a1 + 5252) != 0;
    BOOL v38 = *(_BYTE *)(a1 + 3403) != 0;
    uint64_t v39 = *(void *)(a1 + 64);
    int v40 = (const void *)sub_100040CF8(v39);
    int v41 = sub_1000500D4(v39, v40, 0LL);
    BYTE3(usedBufLen) = *(_DWORD *)(a1 + 7000) != 0;
    BYTE2(usedBufLen) = v41 != 0;
    BYTE1(usedBufLen) = v38;
    LOBYTE(usedBufLen) = v37;
    objc_msgSend( v34,  "setSoftApState:requester:status:changeReason:channelNumber:countryCode:isHidden:isInfraConnected:isAwdlUp:lowPower ModeDuration:compatibilityMode:requestToUpLatency:",  a2 != 0,  v54,  v31,  v33,  v35,  v36,  valuePtr[0],  v27,  usedBufLen);
  }

  objc_autoreleasePoolPop(v55);
}

void sub_1000EF100(uint64_t a1, int a2, unsigned __int16 *a3, __int16 a4, int a5)
{
  CFIndex v6 = (unsigned __int8 *)(a1 + 5210);
  if (!a2)
  {
    ++*(_WORD *)(a1 + 6326);
    goto LABEL_9;
  }

  if (sub_10003AEB0(a3) | a5)
  {
    ++*(_WORD *)(a1 + 6320);
    *(_WORD *)(a1 + 6322) |= a4;
    if (!a5) {
      goto LABEL_9;
    }
  }

  else
  {
    ++*(_WORD *)(a1 + 6324);
    if (!a5) {
      goto LABEL_9;
    }
  }

  unsigned int v9 = v6[1158];
  if (*v6 > v9) {
    v6[1158] = v9 + 1;
  }
LABEL_9:
  unsigned int v10 = objc_autoreleasePoolPush();
  if (qword_100219F60) {
    objc_msgSend( (id)qword_100219F60,  "WFLog:message:",  3,  "%s: PHSessionMetric: method=%d end=%d teardown=%d, misStart=%f softAPUp=%fsessionEnd=%f, appleDeviceConnectionCoun t=%d(%x) nonAppleDeviceConnectionCount=%ddeviceDisconnectCount=%d, lpmDuration=%llu, channel=%d nanPhNanStationCount=%d",  "WiFiDeviceManagerRecordPHMetricSTAAssocEvent",  *(unsigned int *)(a1 + 6280),  *(unsigned int *)(a1 + 6284),  *(unsigned int *)(a1 + 6288),  *(void *)(a1 + 6296),  *(void *)(a1 + 6304),  *(void *)(a1 + 6312),  *(unsigned __int16 *)(a1 + 6320),  *(unsigned __int16 *)(a1 + 6322),  *(unsigned __int16 *)(a1 + 6324),  *(unsigned __int16 *)(a1 + 6326),  *(void *)(a1 + 6328),  *(unsigned int *)(a1 + 6336),  v6[1158]);
  }
  objc_autoreleasePoolPop(v10);
}

uint64_t sub_1000EF234(uint64_t result, int a2)
{
  if (result)
  {
    uint64_t v3 = result;
    *(_BYTE *)(result + 3456) = a2;
    uint64_t v4 = *(void *)(result + 64);
    CFTypeRef v5 = (const void *)sub_100043E8C(v4);
    CFIndex v6 = (uint64_t *)&kCFBooleanTrue;
    if (!a2) {
      CFIndex v6 = (uint64_t *)&kCFBooleanFalse;
    }
    sub_10003EC6C(v4, v5, 483LL, 0LL, *v6);
    double v7 = *(void **)(v3 + 7320);
    if (v7) {
      [v7 setDeviceChargingState:*(_BYTE *)(v3 + 3456) != 0];
    }
    sub_10001611C(*(void *)(v3 + 120), *(_BYTE *)(v3 + 3456));
    return sub_100055A6C(*(void *)(v3 + 64), *(_BYTE *)(v3 + 3456));
  }

  return result;
}

void sub_1000EF2D0(uint64_t a1, uint64_t a2)
{
  if (a1)
  {
    uint64_t v3 = -[WiFiRecommendationStub initWithWiFiNetwork:]( objc_alloc(&OBJC_CLASS___WiFiRecommendationStub),  "initWithWiFiNetwork:",  a2);
    *(_DWORD *)(a1 + 3272) = sub_1000EF388(a1, v3, 1);
    if (v3) {
      CFRelease(v3);
    }
  }

  else
  {
    uint64_t v4 = objc_autoreleasePoolPush();
    if (qword_100219F60) {
      [qword_100219F60 WFLog:@"%s: manager is nil" message:4];
    }
    objc_autoreleasePoolPop(v4);
  }

uint64_t sub_1000EF388(uint64_t a1, void *a2, int a3)
{
  uint64_t v3 = *(unsigned int *)(a1 + 3272);
  if (!a2) {
    return v3;
  }
  double v7 = objc_autoreleasePoolPush();
  if (a3)
  {
    id v8 = 0LL;
    goto LABEL_9;
  }

  if (!*(_DWORD *)(a1 + 6560) || !*(_DWORD *)(a1 + 108))
  {
LABEL_30:
    objc_autoreleasePoolPop(v7);
    return v3;
  }

  if (*(_DWORD *)(a1 + 6700))
  {
    uint64_t v15 = objc_autoreleasePoolPush();
    if (qword_100219F60) {
      [qword_100219F60 WFLog:@"__WiFiDeviceManagerDispatchRecommendation: already displayed recommendation in this session (state %d)" message:3, "%s: already displayed recommendation in this session (state %d)", "__WiFiDeviceManagerDispatchRecommendation", *(unsigned int *)(a1 + 6700)];
    }
    goto LABEL_29;
  }

  if (!-[WiFiUserInteractionMonitor isNetworkRecommendationAllowed]( +[WiFiUserInteractionMonitor sharedInstance](&OBJC_CLASS___WiFiUserInteractionMonitor, "sharedInstance"),  "isNetworkRecommendationAllowed"))
  {
    uint64_t v15 = objc_autoreleasePoolPush();
    if (qword_100219F60) {
      [qword_100219F60 WFLog:@"%s: recommendation not allowed due to user interaction state" message:3 v16];
    }
LABEL_29:
    objc_autoreleasePoolPop(v15);
    goto LABEL_30;
  }

  id v8 = sub_1000E359C(a1);
LABEL_9:
  [*(id *)(a1 + 6688) enableTestMode:sub_1001344F8(*(void *)(a1 + 96)) != 0];
  unsigned int v9 = objc_autoreleasePoolPush();
  if (qword_100219F60) {
    [qword_100219F60 WFLog:3, @"%s: dispatching recommendation for %@", @"__WiFiDeviceManagerDispatchRecommendation", [a2 SSID] message];
  }
  objc_autoreleasePoolPop(v9);
  unsigned int v10 = [*(id *)(a1 + 6688) dispatchNotificationWithRecommendation:a2 currentLocation:v8 force:a3 != 0];
  if (v10 == 2)
  {
    CFRange v12 = objc_autoreleasePoolPush();
    if (qword_100219F60) {
      [qword_100219F60 WFLog:3, "%s: blacklisting recommendation for %@", "__WiFiDeviceManagerDispatchRecommendation", [a2 SSID] message];
    }
    objc_autoreleasePoolPop(v12);
    CFIndex v11 = sub_100094CE8((const __CFString *)[a2 SSID]);
    CFIndex v13 = *(void (**)(uint64_t, _WORD *, uint64_t, uint64_t, void))(a1 + 4672);
    if (v13) {
      v13(a1, v11, 1LL, 6LL, *(void *)(a1 + 4680));
    }
    goto LABEL_19;
  }

  if (!v10)
  {
    *(_DWORD *)(a1 + 6700) = 2;
    if (*(void *)(a1 + 4656))
    {
      CFIndex v11 = sub_100094CE8((const __CFString *)[a2 SSID]);
      (*(void (**)(uint64_t, _WORD *, uint64_t, void))(a1 + 4656))(a1, v11, 1LL, *(void *)(a1 + 4664));
      uint64_t v3 = 14LL;
LABEL_19:
      if (v11) {
        CFRelease(v11);
      }
      goto LABEL_22;
    }

    uint64_t v3 = 14LL;
  }

void sub_1000EF60C(uint64_t a1, const void *a2)
{
  if (a1)
  {
    uint64_t v3 = sub_100095BC8(a2);
    int v4 = *(_DWORD *)(a1 + 3272);
    if (v3) {
      [*(id *)(a1 + 6688) dispatchNotificationWithRandomMAC:v3];
    }
    *(_DWORD *)(a1 + 3272) = v4;
  }

  else
  {
    CFTypeRef v5 = objc_autoreleasePoolPush();
    if (qword_100219F60) {
      [qword_100219F60 WFLog:@"%s: manager is nil" message:4];
    }
    objc_autoreleasePoolPop(v5);
  }

void sub_1000EF69C(uint64_t a1, const void *a2)
{
  if (a1)
  {
    uint64_t v4 = sub_100043E8C(*(void *)(a1 + 64));
    *(_DWORD *)(a1 + 3272) = sub_1000EF770(a1, v4, 10LL, 0LL, a2, 0LL);
    CFTypeRef v5 = objc_autoreleasePoolPush();
    if (qword_100219F60) {
      [(id)qword_100219F60 WFLog:3, "%s: state %@", "WiFiDeviceManagerDispatchSimulatedAskToJoinHotspotNotification", sub_1000BDC98(*(_DWORD *)(a1 + 3272)) message];
    }
  }

  else
  {
    CFTypeRef v5 = objc_autoreleasePoolPush();
    if (qword_100219F60) {
      [qword_100219F60 WFLog:@"%s: manager is nil" message:4 v6];
    }
  }

  objc_autoreleasePoolPop(v5);
}

uint64_t sub_1000EF770(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, const void *a5, uint64_t a6)
{
  CFRange v12 = objc_autoreleasePoolPush();
  if (qword_100219F60) {
    [(id)qword_100219F60 WFLog:3, "%s: type=%@(%d)", "__WiFiDeviceManagerDispatchNotification", sub_10003B428(a3), a3 message];
  }
  objc_autoreleasePoolPop(v12);
  if (!*(void *)(a1 + 3928))
  {
LABEL_9:
    if ((_DWORD)a3 == 2)
    {
      if (!a5) {
        return *(unsigned int *)(a1 + 3272);
      }
LABEL_25:
      return *(unsigned int *)(a1 + 3272);
    }

void sub_1000EF9DC(uint64_t a1, const void *a2)
{
  if (a1)
  {
    uint64_t v4 = sub_100043E8C(*(void *)(a1 + 64));
    *(_DWORD *)(a1 + 3272) = sub_1000EF770(a1, v4, 2LL, 0LL, a2, 0LL);
    CFTypeRef v5 = objc_autoreleasePoolPush();
    if (qword_100219F60) {
      [(id)qword_100219F60 WFLog:3, "%s: state %@", "WiFiDeviceManagerDispatchSimulatedEAPTrustNotification", sub_1000BDC98(*(_DWORD *)(a1 + 3272)) message];
    }
  }

  else
  {
    CFTypeRef v5 = objc_autoreleasePoolPush();
    if (qword_100219F60) {
      [qword_100219F60 WFLog:@"%s: manager is nil" message:4 v6];
    }
  }

  objc_autoreleasePoolPop(v5);
}

__CFDictionary *sub_1000EFAB0(uint64_t a1, const __CFDictionary *a2)
{
  __int16 v33 = objc_autoreleasePoolPush();
  CFNumberRef number = 0LL;
  CFNumberRef value = 0LL;
  unint64_t valuePtr = 13LL;
  CFTypeRef cf = 0LL;
  if (!a1)
  {
    uint64_t v4 = objc_autoreleasePoolPush();
    if (qword_100219F60) {
      [qword_100219F60 WFLog:@"%s: manager is NULL!" message:3];
    }
    goto LABEL_33;
  }

  uint64_t v4 = objc_autoreleasePoolPush();
  if (!a2)
  {
    if (qword_100219F60) {
      objc_msgSend( (id)qword_100219F60,  "WFLog:message:",  3,  "%s: request is NULL!",  "WiFiDeviceManagerProcessAutoJoinBlacklistCommandsAndCopyResponse",  v31);
    }
    goto LABEL_33;
  }

  if (qword_100219F60) {
    [(id)qword_100219F60 WFLog:3, "%s: Processing Request:%@", "WiFiDeviceManagerProcessAutoJoinBlacklistCommandsAndCopyResponse", a2 message];
  }
  objc_autoreleasePoolPop(v4);
  CFDictionaryGetValueIfPresent(a2, @"command", (const void **)&value);
  if (!value)
  {
    uint64_t v4 = objc_autoreleasePoolPush();
    if (qword_100219F60) {
      [qword_100219F60 WFLog:@"%s with no command" message:3 v31];
    }
    goto LABEL_33;
  }

  CFDictionaryGetValueIfPresent(a2, @"reason", (const void **)&number);
  if (number) {
    CFNumberGetValue(number, kCFNumberLongType, &valuePtr);
  }
  CFDictionaryGetValueIfPresent(a2, @"network", &cf);
  if (cf)
  {
    CFTypeRef v5 = sub_100094AAC((uint64_t)kCFAllocatorDefault, cf);
    if (!v5)
    {
      uint64_t v4 = objc_autoreleasePoolPush();
      if (qword_100219F60) {
        [qword_100219F60 WFLog:@"%s couldn't convert record to network" message:3 v31];
      }
      goto LABEL_33;
    }

    uint64_t v6 = v5;
    if (CFArrayGetCount(*(CFArrayRef *)(a1 + 3520)) < 1)
    {
LABEL_14:
      ValueAtIndex = 0LL;
    }

    else
    {
      CFIndex v7 = 0LL;
      while (1)
      {
        ValueAtIndex = CFArrayGetValueAtIndex(*(CFArrayRef *)(a1 + 3520), v7);
        if (CFEqual(v6, ValueAtIndex)) {
          break;
        }
        if (++v7 >= CFArrayGetCount(*(CFArrayRef *)(a1 + 3520))) {
          goto LABEL_14;
        }
      }
    }

    if (CFArrayGetCount(*(CFArrayRef *)(a1 + 3528)) >= 1)
    {
      CFIndex v9 = 0LL;
      while (1)
      {
        unsigned int v10 = CFArrayGetValueAtIndex(*(CFArrayRef *)(a1 + 3528), v9);
        if (CFEqual(v6, v10)) {
          break;
        }
        if (++v9 >= CFArrayGetCount(*(CFArrayRef *)(a1 + 3528))) {
          goto LABEL_22;
        }
      }

      ValueAtIndex = v10;
    }

uint64_t sub_1000F0094(uint64_t a1, unint64_t a2, uint64_t a3)
{
  uint64_t v6 = objc_autoreleasePoolPush();
  id v7 = sub_1000A335C(a3);
  uint64_t v8 = 0LL;
  if (!a1 || !a3) {
    goto LABEL_12;
  }
  [*(id *)(a1 + 6632) setDenyListedStateExpiryIntervalInSec:1 state:60.0];
  if (a2 > 7)
  {
    CFMutableArrayRef v13 = objc_autoreleasePoolPush();
    if (qword_100219F60) {
      [qword_100219F60 WFLog:@"__WiFiDeviceManagerSetAutoJoinBlacklistedNetworkCondition - unrecognized WiFiDenyListAddReason" message:3];
    }
    objc_autoreleasePoolPop(v13);
    uint64_t v8 = 0LL;
    if (v7) {
      goto LABEL_13;
    }
    goto LABEL_14;
  }

  if (((1LL << a2) & 0x4F) != 0)
  {
    CFIndex v9 = sub_1000951FC(a3, @"BSSID");
    id v10 = sub_1000D1BDC(a1, a2, 0LL, (uint64_t)v9, 1LL);
  }

  else
  {
    if (((1LL << a2) & 0x90) == 0)
    {
      id v14 = sub_1000951FC(a3, @"BSSID");
      int v15 = 5;
      id v10 = sub_1000D1BDC(a1, 5LL, 0LL, (uint64_t)v14, 1LL);
      do
      {
        [*(id *)(a1 + 6632) setNetworkDenyListInfo:v10 forScanResult:v7];
        --v15;
      }

      while (v15);
      goto LABEL_9;
    }

    id v11 = sub_1000951FC(a3, @"BSSID");
    id v10 = sub_1000D1BDC(a1, a2, 0LL, (uint64_t)v11, 1LL);
    [*(id *)(a1 + 6632) setNetworkDenyListInfo:v10 forScanResult:v7];
    [*(id *)(a1 + 6632) setNetworkDenyListInfo:v10 forScanResult:v7];
  }

  [*(id *)(a1 + 6632) setNetworkDenyListInfo:v10 forScanResult:v7];
LABEL_9:
  if (v10) {

  }
  uint64_t v8 = 1LL;
LABEL_12:
  if (v7) {
LABEL_13:
  }

LABEL_14:
  objc_autoreleasePoolPop(v6);
  return v8;
}

uint64_t sub_1000F0268(uint64_t result, uint64_t a2, uint64_t a3)
{
  if (result)
  {
    uint64_t v3 = *(void (**)(uint64_t, uint64_t, uint64_t, void))(result + 4528);
    if (v3)
    {
      v3(result, a3, a2, *(void *)(result + 4536));
      return 1LL;
    }

    else
    {
      return 0LL;
    }
  }

  return result;
}

BOOL sub_1000F02A4(uint64_t a1)
{
  return *(_DWORD *)(a1 + 176) == 1;
}

void sub_1000F02B4(uint64_t a1)
{
  if (a1)
  {
    uint64_t v2 = *(void (**)(uint64_t, void))(a1 + 4560);
    if (v2) {
      v2(a1, *(void *)(a1 + 4568));
    }
    else {
      sub_1000D66BC(a1, 6);
    }
  }

  else
  {
    uint64_t v3 = objc_autoreleasePoolPush();
    if (qword_100219F60) {
      [qword_100219F60 WFLog:@"%s: null manager" message:4];
    }
    objc_autoreleasePoolPop(v3);
  }

void sub_1000F0370(uint64_t a1, int a2)
{
  CFIndex Count = CFArrayGetCount(*(CFArrayRef *)(a1 + 3520));
  if (Count >= 1)
  {
    CFIndex v5 = Count;
    CFIndex v6 = 0LL;
    if (a2 == 1) {
      id v7 = "Invalidating";
    }
    else {
      id v7 = "Disabling";
    }
    do
    {
      ValueAtIndex = (void *)CFArrayGetValueAtIndex(*(CFArrayRef *)(a1 + 3520), v6);
      if (ValueAtIndex)
      {
        CFIndex v9 = ValueAtIndex;
        if (sub_100096670((uint64_t)ValueAtIndex) == 1)
        {
          id v10 = objc_autoreleasePoolPush();
          if (qword_100219F60) {
            [(id)qword_100219F60 WFLog:3, "%s %s home NOI for broadcast network '%@'", "WiFiDeviceManagerDisableHomeNetwork", v7, sub_100095BC8(v9) message];
          }
          objc_autoreleasePoolPop(v10);
          sub_1000F0528(a1, v9, a2);
        }
      }

      ++v6;
    }

    while (v5 != v6);
  }

  CFIndex v11 = CFArrayGetCount(*(CFArrayRef *)(a1 + 3528));
  if (v11 >= 1)
  {
    CFIndex v12 = v11;
    CFIndex v13 = 0LL;
    if (a2 == 1) {
      id v14 = "Invalidating";
    }
    else {
      id v14 = "Disabling";
    }
    do
    {
      int v15 = (void *)CFArrayGetValueAtIndex(*(CFArrayRef *)(a1 + 3528), v13);
      if (v15)
      {
        id v16 = v15;
        if (sub_100096670((uint64_t)v15) == 1)
        {
          unsigned int v17 = objc_autoreleasePoolPush();
          if (qword_100219F60) {
            [(id)qword_100219F60 WFLog:3, "%s:%s home NOI for directed network '%@'", "WiFiDeviceManagerDisableHomeNetwork", v14, sub_100095BC8(v16) message];
          }
          objc_autoreleasePoolPop(v17);
          sub_1000F0528(a1, v16, a2);
        }
      }

      ++v13;
    }

    while (v12 != v13);
  }

void sub_1000F0528(uint64_t a1, void *a2, int a3)
{
  if (a3)
  {
    sub_10009FA58(a2, 2);
  }

  else
  {
    CFIndex v5 = objc_autoreleasePoolPush();
    id v6 = [*(id *)(a1 + 6608) copyHomeNetworkTransitionDate];
    id v7 = objc_autoreleasePoolPush();
    if (qword_100219F60) {
      [(id)qword_100219F60 WFLog:3, "%s: Disabling NOI home network '%@' until %@", "__WiFiDeviceManagerDisableHomeNetworkHelper", sub_100095BC8(a2), v6 message];
    }
    objc_autoreleasePoolPop(v7);
    sub_100099F8C((uint64_t)a2, v6);
    sub_10009A048((CFMutableDictionaryRef *)a2, 0, @"DisableHomeNetwork");

    objc_autoreleasePoolPop(v5);
  }

  uint64_t v8 = objc_autoreleasePoolPush();
  CFIndex v9 = (void *)qword_100219F60;
  if (qword_100219F60)
  {
    id v10 = sub_100095BC8(a2);
    [v9 WFLog:4, "%s: Updating NOI home-state key for '%@' to %d", "__WiFiDeviceManagerDisableHomeNetworkHelper", v10, sub_100096670((uint64_t)a2) message];
  }

  objc_autoreleasePoolPop(v8);
  sub_1000DAB00((dispatch_queue_s **)a1, a2);
}

uint64_t sub_1000F0660(const void *a1)
{
  if (!a1)
  {
    uint64_t v4 = objc_autoreleasePoolPush();
    if (qword_100219F60) {
      [qword_100219F60 WFLog:@"Can't determine shareable status, network argument is NULL" message:3];
    }
    uint64_t v2 = 0LL;
    goto LABEL_30;
  }

  if (sub_10009EFD8((uint64_t)a1))
  {
    uint64_t v4 = objc_autoreleasePoolPush();
    CFIndex v5 = (void *)qword_100219F60;
    if (qword_100219F60)
    {
      id v6 = sub_100095BC8(a1);
      uint64_t v2 = 3LL;
      [v5 WFLog:3, "%s Network with SSID: %@ is unshareable as it's carrier based.", "WiFiNetworkDetermineShareableStatusOfNetworkForNearbyDeviceSetup", v6 message];
    }

    else
    {
      uint64_t v2 = 3LL;
    }

uint64_t sub_1000F08B0(const void *a1)
{
  unsigned int valuePtr = sub_1000F0660(a1);
  Default = CFAllocatorGetDefault();
  CFNumberRef v3 = CFNumberCreate(Default, kCFNumberIntType, &valuePtr);
  if (v3)
  {
    CFNumberRef v4 = v3;
    sub_10009582C((uint64_t)a1, @"ShareableStatus", v3);
    CFRelease(v4);
  }

  return valuePtr;
}

uint64_t sub_1000F0918(const void *a1)
{
  CFNumberRef value = 0LL;
  if (!sub_100095B4C((uint64_t)a1))
  {
    id v16 = objc_autoreleasePoolPush();
    if (qword_100219F60) {
      [(id)qword_100219F60 WFLog:3, "%s not appending EAP info for nearby device setup as the supplied network argument does NOT use EAP auth (SSID: %@)", "WiFiNetworkAppendEAPInformationForNearbyDeviceSetup", sub_100095BC8(a1) message];
    }
    goto LABEL_23;
  }

  if (-[ManagedConfigWrapper isEAPShareBlockedByManagedDefault]( +[ManagedConfigWrapper sharedInstance](&OBJC_CLASS___ManagedConfigWrapper, "sharedInstance"),  "isEAPShareBlockedByManagedDefault"))
  {
    id v16 = objc_autoreleasePoolPush();
    if (qword_100219F60) {
      [(id)qword_100219F60 WFLog:3, "%s Network with SSID: %@ is unshareable as it's EAP auth and the profile to block EAP credential sharing is inst alled. Will not append EAP credentials", "WiFiNetworkAppendEAPInformationForNearbyDeviceSetup", sub_100095BC8(a1) message];
    }
    goto LABEL_23;
  }

  if (sub_10009869C((uint64_t)a1))
  {
    id v16 = objc_autoreleasePoolPush();
    if (qword_100219F60) {
      [(id)qword_100219F60 WFLog:3, "%s not appending EAP info for nearby device setup as the supplied network comes from a third party (WiFiNetworkI sAppBased() true). (SSID: %@)", "WiFiNetworkAppendEAPInformationForNearbyDeviceSetup", sub_100095BC8(a1) message];
    }
    goto LABEL_23;
  }

  uint64_t v2 = sub_100094EB4((uint64_t)a1);
  if (!v2)
  {
    id v16 = objc_autoreleasePoolPush();
    if (qword_100219F60) {
      [(id)qword_100219F60 WFLog:3, "%s Got NULL back from WiFiNetworkCopyFilteredRecord(), bailing and not appending EAP info. SSID: %@", "WiFiNetworkAppendEAPInformationForNearbyDeviceSetup", sub_100095BC8(a1) message];
    }
LABEL_23:
    objc_autoreleasePoolPop(v16);
    return 0LL;
  }

  CFNumberRef v3 = v2;
  CFAllocatorRef Default = CFAllocatorGetDefault();
  CFIndex v5 = (CFDictionaryRef *)sub_100094AAC((uint64_t)Default, v3);
  if (!v5)
  {
    unsigned int v17 = objc_autoreleasePoolPush();
    if (qword_100219F60) {
      [(id)qword_100219F60 WFLog:3, "%s Failed to create WiFiNetworkRef from the result of WiFiNetworkCopyFilteredRecord(), bailing and not appending EAP info. SSID: %@", "WiFiNetworkAppendEAPInformationForNearbyDeviceSetup", sub_100095BC8(a1) message];
    }
    objc_autoreleasePoolPop(v17);
    CFRelease(v3);
    return 0LL;
  }

  id v6 = v5;
  id v7 = sub_100094FD8(v5, 0LL);
  uint64_t v8 = v7;
  if (v7)
  {
    CFDictionaryGetValueIfPresent(v7, @"EAPClientConfiguration", (const void **)&value);
    if (value)
    {
      CFIndex v9 = (const void *)EAPClientConfigurationCopyShareable();
      if (v9)
      {
        id v10 = v9;
        sub_10009582C((uint64_t)a1, @"ShareableEAPConfig", v9);
        CFIndex v11 = sub_100095BC8(a1);
        CFIndex v12 = (const void *)EAPTLSCopyTrustExceptionBindings(@"WirelessSSID", v11);
        if (v12)
        {
          CFIndex v13 = v12;
          sub_10009582C((uint64_t)a1, @"ShareableEAPTrustExceptions", v12);
          CFRelease(v13);
        }

        else
        {
          BOOL v19 = objc_autoreleasePoolPush();
          if (qword_100219F60) {
            [(id)qword_100219F60 WFLog:3, "%s failed to copy trust exceptions for network with SSID: %@", "WiFiNetworkAppendEAPInformationForNearbyDeviceSetup", sub_100095BC8(a1) message];
          }
          objc_autoreleasePoolPop(v19);
        }

        CFRelease(v10);
        uint64_t v14 = 1LL;
        goto LABEL_12;
      }

      id v18 = objc_autoreleasePoolPush();
      if (qword_100219F60) {
        [(id)qword_100219F60 WFLog:3, "%s EAPUtilCopyShareableConfiguration() didn't return a shareable EAP config, most likely cause is unsupported EAPAcceptTypes (SSID: %@)", "WiFiNetworkAppendEAPInformationForNearbyDeviceSetup", sub_100095BC8(a1) message];
      }
    }

    else
    {
      id v18 = objc_autoreleasePoolPush();
      if (qword_100219F60) {
        [(id)qword_100219F60 WFLog:3, "%s no kEAPOLControlEAPClientConfiguration for network (SSID: %@), won't append", "WiFiNetworkAppendEAPInformationForNearbyDeviceSetup", sub_100095BC8(a1) message];
      }
    }
  }

  else
  {
    id v18 = objc_autoreleasePoolPush();
    if (qword_100219F60) {
      [(id)qword_100219F60 WFLog:3, "%s no eapProfile (or Got NULL back from WiFiNetworkCopyPreparedEAPProfile()) for network (SSID: %@), won't append", "WiFiNetworkAppendEAPInformationForNearbyDeviceSetup", sub_100095BC8(a1) message];
    }
  }

  objc_autoreleasePoolPop(v18);
  uint64_t v14 = 0LL;
LABEL_12:
  CFRelease(v3);
  CFRelease(v6);
  if (v8) {
    CFRelease(v8);
  }
  return v14;
}

uint64_t sub_1000F0CB8(uint64_t a1, const void *a2)
{
  if (a1 && a2)
  {
    uint64_t v2 = sub_1000DEA34(a1, a2, 1);
    if (sub_100095B4C((uint64_t)v2))
    {
      CFNumberRef v3 = sub_100095BC8(v2);
      EAPTLSSetTrustExceptionBindings(@"WirelessSSID", v3, &off_1002057E8);
      uint64_t v4 = 1LL;
      if (v2) {
LABEL_5:
      }
        CFRelease(v2);
    }

    else
    {
      id v7 = objc_autoreleasePoolPush();
      if (qword_100219F60) {
        [(id)qword_100219F60 WFLog:3, "%s not destroying EAP trust for current network is it's not EAP  (SSID: %@)", "WiFiDeviceManagerDestroyEAPTrustExceptionsForCurrentNetwork", sub_100095BC8(v2) message];
      }
      objc_autoreleasePoolPop(v7);
      uint64_t v4 = 0LL;
      if (v2) {
        goto LABEL_5;
      }
    }
  }

  else
  {
    id v6 = objc_autoreleasePoolPush();
    if (qword_100219F60) {
      [qword_100219F60 WFLog:@"%s requires manager and interface name args" message:3];
    }
    objc_autoreleasePoolPop(v6);
    return 0LL;
  }

  return v4;
}

void sub_1000F0DC8(uint64_t a1, uint64_t a2)
{
  if (a1)
  {
    if (a2)
    {
      *(void *)(a1 + 5400) = a2;
      uint64_t v2 = objc_autoreleasePoolPush();
      if (qword_100219F60) {
        [qword_100219F60 WFLog:@"Battery Manager set " message:3];
      }
    }

    else
    {
      uint64_t v2 = objc_autoreleasePoolPush();
      if (qword_100219F60) {
        [qword_100219F60 WFLog:@"Battery manager is NULL"];
      }
    }
  }

  else
  {
    uint64_t v2 = objc_autoreleasePoolPush();
    if (qword_100219F60) {
      [qword_100219F60 WFLog:@"%s: manager is NULL" message:3];
    }
  }

  objc_autoreleasePoolPop(v2);
}

void sub_1000F0E8C(uint64_t a1, unsigned int a2)
{
  uint64_t v4 = objc_autoreleasePoolPush();
  if (a1)
  {
    if (qword_100219F60) {
      [qword_100219F60 WFLog:@"WiFiDeviceManagerSetAvailabilityEngineIsEnabled enabled %d" message:3];
    }
    objc_autoreleasePoolPop(v4);
    *(_BYTE *)(a1 + 6696) = a2;
  }

  else
  {
    if (qword_100219F60) {
      [qword_100219F60 WFLog:@"%s: manager is NULL" message:3];
    }
    objc_autoreleasePoolPop(v4);
  }

uint64_t sub_1000F0F40(uint64_t result)
{
  if (result) {
    return sub_100053CD8(*(void *)(result + 64));
  }
  return result;
}

uint64_t sub_1000F0F50(uint64_t result)
{
  if (result) {
    return sub_100053CE4(*(void *)(result + 64));
  }
  return result;
}

uint64_t sub_1000F0F60(uint64_t result)
{
  if (result)
  {
    uint64_t v1 = result;
    uint64_t result = _os_feature_enabled_impl("WiFiManager", "WPA3PersonalHotspot");
    if ((_DWORD)result)
    {
      uint64_t result = sub_100053CF0(*(void *)(v1 + 64));
      if ((_DWORD)result) {
        return sub_10004D5F0(*(void *)(v1 + 64)) != 0;
      }
    }
  }

  return result;
}

uint64_t sub_1000F0FB4(uint64_t result)
{
  if (result) {
    return sub_10004D5F0(*(void *)(result + 64));
  }
  return result;
}

void sub_1000F0FC8(uint64_t a1, int a2)
{
  if (!a1)
  {
    uint64_t v14 = objc_autoreleasePoolPush();
    if (qword_100219F60) {
      [qword_100219F60 WFLog:@"WiFiBatteryMgmt : NULL Manager" message:3];
    }
    objc_autoreleasePoolPop(v14);
    int v15 = objc_autoreleasePoolPush();
    if (qword_100219F60) {
      [qword_100219F60 WFLog:@"WiFiBatteryMgmt : NULL Manager" message:3];
    }
    CFIndex v5 = v15;
    goto LABEL_6;
  }

  if (a2)
  {
    CFNumberRef v3 = objc_autoreleasePoolPush();
    if (qword_100219F60) {
      [qword_100219F60 WFLog:@"%s: WiFiBatteryMgmt : resource has become available for auto-join/awdl. manager->state.enable(%d)", @"WiFiDeviceManagerHandleChangedPowerBudgetValue", *(unsigned __int8 *)(a1 + 3297)];
    }
    objc_autoreleasePoolPop(v3);
    uint64_t v4 = objc_autoreleasePoolPush();
    [*(id *)(a1 + 5400) requestPowerResource:0 withDetails:0];
    CFIndex v5 = v4;
LABEL_6:
    objc_autoreleasePoolPop(v5);
    return;
  }

  id v6 = (const void *)sub_100043E8C(*(void *)(a1 + 64));
  id v7 = sub_1000DEA34(a1, v6, 1);
  if (v7)
  {
    uint64_t v8 = v7;
    CFIndex v9 = objc_autoreleasePoolPush();
    if (qword_100219F60) {
      [qword_100219F60 WFLog:@"WiFiBatteryMgmt : resource no longer available for connection. Disassociating..."];
    }
    objc_autoreleasePoolPop(v9);
    id v10 = (const void *)sub_100043E8C(*(void *)(a1 + 64));
    sub_1000CE074(a1, v10, 1006LL, "WiFiDeviceManagerHandleChangedPowerBudgetValue", 36237LL);
    CFRelease(v8);
  }

  else if (*(_BYTE *)(a1 + 3297))
  {
    CFIndex v11 = objc_autoreleasePoolPush();
    if (qword_100219F60) {
      [qword_100219F60 WFLog:@"WiFiBatteryMgmt : resource no longer available for auto-join. Aborting..."];
    }
    objc_autoreleasePoolPop(v11);
    sub_1000D0428(a1);
    sub_1000D0894(a1);
  }

  if (*(_DWORD *)(a1 + 5416))
  {
    CFIndex v12 = *(void **)(a1 + 5424);
    if (v12) {

    }
    *(void *)(a1 + 5424) = 0LL;
    CFIndex v13 = (const void *)sub_100040CF8(*(void *)(a1 + 64));
    sub_1000D00D8(a1, v13);
  }

void sub_1000F11F8(uint64_t a1, int a2, void *a3)
{
  if (!a3)
  {
    id v6 = objc_autoreleasePoolPush();
    if (qword_100219F60) {
      [qword_100219F60 WFLog:@"%s: null request." message:3];
    }
    goto LABEL_32;
  }

  id v6 = objc_autoreleasePoolPush();
  if (!a1)
  {
    if (qword_100219F60) {
      [qword_100219F60 WFLog:@"%s: null device manager." message:@"WiFiDeviceManagerHandleUnchangedPowerBudgetValue"];
    }
LABEL_32:
    objc_autoreleasePoolPop(v6);
    unsigned int v17 = objc_autoreleasePoolPush();
    if (qword_100219F60) {
      [qword_100219F60 WFLog:@"WiFiBatteryMgmt : NULL Request or Null Device Manager" message:3];
    }
    objc_autoreleasePoolPop(v17);
    return;
  }

  if (qword_100219F60) {
    [qword_100219F60 WFLog:@"WiFiBatteryMgmt : power budget resource is present and unchanged!"];
  }
  objc_autoreleasePoolPop(v6);
  if (*a3)
  {
    if (*a3 != 1LL) {
      return;
    }
    uint64_t v7 = a3[1];
    if (!v7) {
      return;
    }
    if (a2)
    {
      uint64_t v8 = sub_1000E55C4( a1,  *(const __CFString **)(v7 + 16),  *(const __CFDictionary **)(v7 + 24),  *(void *)(v7 + 8),  *(void *)(v7 + 40),  *(const void **)(v7 + 48));
      if (!(_DWORD)v8) {
        goto LABEL_20;
      }
      CFIndex v9 = *(void (**)(uint64_t, uint64_t, uint64_t, void, void, uint64_t))(v7 + 8);
      if (!v9) {
        goto LABEL_20;
      }
      uint64_t v10 = v8;
      uint64_t v11 = *(void *)(v7 + 16);
      uint64_t v12 = *(void *)(v7 + 40);
      uint64_t v13 = a1;
    }

    else
    {
      CFIndex v9 = *(void (**)(uint64_t, uint64_t, uint64_t, void, void, uint64_t))(v7 + 8);
      if (!v9)
      {
LABEL_20:
        uint64_t v14 = *(const void **)(v7 + 16);
        if (v14)
        {
          CFRelease(v14);
          *(void *)(v7 + 16) = 0LL;
        }

        int v15 = *(const void **)(v7 + 24);
        if (v15)
        {
          CFRelease(v15);
          *(void *)(v7 + 24) = 0LL;
        }

        id v16 = *(const void **)(v7 + 48);
        if (v16) {
          CFRelease(v16);
        }
        free((void *)v7);
        return;
      }

      uint64_t v11 = *(void *)(v7 + 16);
      uint64_t v12 = *(void *)(v7 + 40);
      uint64_t v13 = a1;
      uint64_t v10 = 4294963390LL;
    }

    v9(v13, v11, v10, 0LL, 0LL, v12);
    goto LABEL_20;
  }

  if (a2 && *(_BYTE *)(a1 + 3297))
  {
    *(_DWORD *)(a1 + 192) = 9;
    if (_os_feature_enabled_impl("CoreWiFi", "UnifiedAutoJoin"))
    {
      sub_1000F5F98(a1, 0x17uLL);
    }

    else
    {
      [+[WiFiXPCManager sharedXPCManager](WiFiXPCManager, "sharedXPCManager") autoJoinStartedWithTrigger:23 interfaceName:sub_100043E8C(*(void *)(a1 + 64))];
      sub_1000D0A5C(a1, 2LL, (uint64_t)"WiFiDeviceManagerAutoAssociateStart");
    }
  }

void sub_1000F1468(uint64_t a1)
{
  if (*(void *)(a1 + 4432))
  {
    CFMutableArrayRef Mutable = CFDictionaryCreateMutable( kCFAllocatorDefault,  0LL,  &kCFTypeDictionaryKeyCallBacks,  &kCFTypeDictionaryValueCallBacks);
    if (Mutable)
    {
      CFNumberRef v3 = Mutable;
      CFDictionarySetValue(Mutable, @"WiFiHostApStateIdentifier", kCFBooleanTrue);
      if ((*(_BYTE *)(a1 + 7009) & 4) != 0) {
        CFBooleanRef v4 = kCFBooleanTrue;
      }
      else {
        CFBooleanRef v4 = kCFBooleanFalse;
      }
      CFDictionarySetValue(v3, @"WiFiHostApStateEnable", v4);
      if (*(_BYTE *)(a1 + 5252)) {
        CFBooleanRef v5 = kCFBooleanTrue;
      }
      else {
        CFBooleanRef v5 = kCFBooleanFalse;
      }
      CFDictionarySetValue(v3, @"WiFiHostApStateADHSMode", v5);
      id v6 = *(void (**)(uint64_t, uint64_t, void, __CFDictionary *))(a1 + 4432);
      uint64_t v7 = sub_100043E98(*(void *)(a1 + 64));
      v6(a1, v7, *(void *)(a1 + 4440), v3);
      CFRelease(v3);
    }
  }

void sub_1000F1574(uint64_t a1, uint64_t a2)
{
  CFBooleanRef v4 = objc_autoreleasePoolPush();
  if (a1)
  {
    if (qword_100219F60) {
      [qword_100219F60 WFLog:@"WiFiDeviceManagerAutoInstantHotspotTestMode: test mode %d" message:3, "%s: test mode %d", "WiFiDeviceManagerAutoInstantHotspotTestMode", a2];
    }
    objc_autoreleasePoolPop(v4);
    if ((_DWORD)a2 == 3)
    {
      *(_BYTE *)(a1 + 6784) = 0;
    }

    else if ((_DWORD)a2 == 4)
    {
      *(_BYTE *)(a1 + 6784) = 1;
    }
  }

  else
  {
    if (qword_100219F60) {
      [qword_100219F60 WFLog:@"%s: manager is NULL" message:3];
    }
    objc_autoreleasePoolPop(v4);
  }

void sub_1000F1644(uint64_t a1, uint64_t a2)
{
  CFBooleanRef v4 = objc_autoreleasePoolPush();
  if (a1)
  {
    if (qword_100219F60) {
      [(id)qword_100219F60 WFLog:3, "%s: enabled %@(%d)", "WiFiDeviceManagerSetAutoInstantHotspotMode", sub_10003B3D8(a2), a2 message];
    }
    objc_autoreleasePoolPop(v4);
    *(_DWORD *)(a1 + 6756) = a2;
  }

  else
  {
    if (qword_100219F60) {
      [qword_100219F60 WFLog:@"%s: manager is NULL" message:3];
    }
    objc_autoreleasePoolPop(v4);
  }

void sub_1000F1704(uint64_t a1, double a2)
{
  CFBooleanRef v4 = objc_autoreleasePoolPush();
  if (a1)
  {
    if (qword_100219F60) {
      [qword_100219F60 WFLog:@"WiFiDeviceManagerSetAutoInstantHotspotTriggerInterval interval %f" message:3, *(void *)&a2];
    }
    objc_autoreleasePoolPop(v4);
    *(double *)(a1 + 6816) = a2;
    *(double *)(a1 + 6824) = a2;
  }

  else
  {
    if (qword_100219F60) {
      [qword_100219F60 WFLog:@"%s: manager is NULL" message:3];
    }
    objc_autoreleasePoolPop(v4);
  }

CFArrayRef sub_1000F17B8(uint64_t a1)
{
  if (_os_feature_enabled_impl("CoreWiFi", "UnifiedAutoJoin"))
  {
    double v25 = objc_autoreleasePoolPush();
    if (qword_100219F60) {
      [qword_100219F60 WFLog:@"%s not allowed with Unified Auto-Join" message:3];
    }
    objc_autoreleasePoolPop(v25);
    return 0LL;
  }

  uint64_t result = *(const __CFArray **)(a1 + 320);
  if (!result) {
    return result;
  }
  double valuePtr = NAN;
  int v3 = *(_DWORD *)(a1 + 348);
  if (v3)
  {
    *(_DWORD *)(a1 + 34_Block_object_dispose((const void *)(v9 - 48), 8) = v3 - 1;
    if (v3 != 1)
    {
      double valuePtr = 1.0;
      double v4 = 1.0;
      goto LABEL_9;
    }
  }

  uint64_t result = (const __CFArray *)CFArrayGetValueAtIndex(result, *(void *)(a1 + 328));
  if (!result) {
    return result;
  }
  CFNumberGetValue(result, kCFNumberDoubleType, &valuePtr);
  double v4 = valuePtr;
  if (valuePtr <= 0.0) {
    return 0LL;
  }
  *(double *)(a1 + 336) = valuePtr;
LABEL_9:
  *(_DWORD *)(a1 + 5636) = *(void *)(a1 + 328);
  if (*(_DWORD *)(a1 + 3272) == 2)
  {
    double v4 = v4 + 2.0;
    double valuePtr = v4;
  }

  unsigned int v5 = *(_DWORD *)(a1 + 344);
  if (v5)
  {
    double valuePtr = v4;
    double v6 = v4 - v4 * 0.1;
    double v7 = v4 + v4 * 0.1;
    uint32_t v8 = arc4random();
    double v9 = v6 + (double)(v8 + ((v8 / 0x7FFFFFFF) | ((v8 / 0x7FFFFFFF) << 31))) / 2147483650.0 * (v7 - v6);
    uint64_t v10 = *(dispatch_source_s **)(a1 + 312);
    dispatch_time_t v11 = dispatch_time(0LL, (uint64_t)(v9 * 1000000000.0));
    dispatch_source_set_timer(v10, v11, 0xFFFFFFFFFFFFFFFFLL, 0LL);
    uint64_t v12 = objc_autoreleasePoolPush();
    if (!qword_100219F60) {
      goto LABEL_20;
    }
    uint64_t v13 = +[NSString stringWithFormat:]( &OBJC_CLASS___NSString,  "stringWithFormat:",  @"%s",  -[NSString UTF8String]( +[NSString stringWithFormat:]( &OBJC_CLASS___NSString,  "stringWithFormat:",  @"{%@-} %@",  @"AUTOJOIN",  +[NSString stringWithFormat:]( &OBJC_CLASS___NSString,  "stringWithFormat:",  @"%s: Performing next automatic assocation in %.3f(%.3f) seconds, retry cap=%d",  "__WiFiDeviceManagerScheduleNextRetry",  *(void *)&v9,  *(void *)&valuePtr,  *(unsigned int *)(a1 + 344))),  "UTF8String"));
    if (!os_log_type_enabled((os_log_t)&_os_log_default, OS_LOG_TYPE_DEFAULT)) {
      goto LABEL_20;
    }
  }

  else
  {
    double v14 = v4 - v4 * 0.1;
    double v15 = v4 + v4 * 0.1;
    uint32_t v16 = arc4random();
    double v17 = v14 + (double)(v16 + ((v16 / 0x7FFFFFFF) | ((v16 / 0x7FFFFFFF) << 31))) / 2147483650.0 * (v15 - v14);
    id v18 = *(dispatch_source_s **)(a1 + 312);
    dispatch_time_t v19 = dispatch_time(0LL, (uint64_t)(v17 * 1000000000.0));
    dispatch_source_set_timer(v18, v19, 0xFFFFFFFFFFFFFFFFLL, 0LL);
    uint64_t v12 = objc_autoreleasePoolPush();
    if (!qword_100219F60) {
      goto LABEL_20;
    }
    uint64_t v13 = +[NSString stringWithFormat:]( &OBJC_CLASS___NSString,  "stringWithFormat:",  @"%s",  -[NSString UTF8String]( +[NSString stringWithFormat:]( &OBJC_CLASS___NSString,  "stringWithFormat:",  @"{%@-} %@",  @"AUTOJOIN",  +[NSString stringWithFormat:]( &OBJC_CLASS___NSString,  "stringWithFormat:",  @"%s: Performing next automatic assocation in %.3f(%.3f) seconds",  "__WiFiDeviceManagerScheduleNextRetry",  *(void *)&v17,  *(void *)&valuePtr)),  "UTF8String"));
    if (!os_log_type_enabled((os_log_t)&_os_log_default, OS_LOG_TYPE_DEFAULT)) {
      goto LABEL_20;
    }
  }

  CFIndex v20 = -[NSString UTF8String]( +[NSString stringWithFormat:]( &OBJC_CLASS___NSString,  "stringWithFormat:",  @"[WiFiPolicy] %s",  -[NSString UTF8String](v13, "UTF8String")),  "UTF8String");
  *(_DWORD *)__int128 buf = 136446210;
  CFNumberRef v29 = v20;
  _os_log_impl((void *)&_mh_execute_header, (os_log_t)&_os_log_default, OS_LOG_TYPE_DEFAULT, "%{public}s", buf, 0xCu);
LABEL_20:
  objc_autoreleasePoolPop(v12);
  *(_DWORD *)(a1 + 5632) = valuePtr;
  if (v3)
  {
    double v26 = objc_autoreleasePoolPush();
    if (qword_100219F60) {
      [qword_100219F60 WFLog:@"%s: in quick autojoin retry, %d more remaining." message:3, "%s: in quick autojoin retry, %d more remaining.", "__WiFiDeviceManagerScheduleNextRetry", *(unsigned int *)(a1 + 348)];
    }
    objc_autoreleasePoolPop(v26);
  }

  else
  {
    CFIndex Count = CFArrayGetCount(*(CFArrayRef *)(a1 + 320));
    uint64_t v22 = *(void *)(a1 + 328);
    uint64_t v23 = v22 + 1;
    if (v22 + 1 < Count)
    {
      ValueAtIndex = (const __CFNumber *)CFArrayGetValueAtIndex(*(CFArrayRef *)(a1 + 320), v22 + 1);
      if (ValueAtIndex)
      {
        CFNumberGetValue(ValueAtIndex, kCFNumberDoubleType, &valuePtr);
        if (valuePtr > 0.0) {
          *(void *)(a1 + 32_Block_object_dispose((const void *)(v9 - 48), 8) = v23;
        }
      }
    }
  }

  return (const __CFArray *)1;
}

CFNumberRef sub_1000F1CB4(uint64_t a1)
{
  if (CFAbsoluteTimeGetCurrent() - *(double *)(a1 + 6904) > 15.0 || (uint64_t result = sub_1000F1D7C(a1), (_DWORD)result))
  {
    if (!-[WiFiUserInteractionMonitor isAnyCallInProgress]( +[WiFiUserInteractionMonitor sharedInstance](&OBJC_CLASS___WiFiUserInteractionMonitor, "sharedInstance"),  "isAnyCallInProgress")) {
      return (const __CFNumber *)1;
    }
    int v3 = objc_autoreleasePoolPush();
    if (qword_100219F60) {
      [qword_100219F60 WFLog:@"%s: call is in progress, not scanning for auto hotspot." message:3];
    }
    objc_autoreleasePoolPop(v3);
    return 0LL;
  }

  return result;
}

CFNumberRef sub_1000F1D7C(uint64_t a1)
{
  uint64_t result = *(const __CFNumber **)(a1 + 3504);
  if (result)
  {
    uint64_t result = (const __CFNumber *)sub_100097700((uint64_t)result);
    if ((_DWORD)result)
    {
      if (sub_1000951FC(*(void *)(a1 + 3504), @"WiFiAutoInstantHotspotJoining") != kCFBooleanTrue) {
        return 0LL;
      }
      uint64_t result = (const __CFNumber *)sub_1000951FC(*(void *)(a1 + 3504), @"lastDisconnectReasonKey");
      if (result)
      {
        unsigned int valuePtr = -1431655766;
        CFNumberGetValue(result, kCFNumberIntType, &valuePtr);
        return (const __CFNumber *)(valuePtr <= 2 && CFAbsoluteTimeGetCurrent() - *(double *)(a1 + 6904) <= 600.0);
      }
    }
  }

  return result;
}

void sub_1000F1E34(uint64_t a1, int a2)
{
  int v4 = *(_DWORD *)(a1 + 3272);
  if ((_os_feature_enabled_impl("CoreWiFi", "UnifiedAutoJoin") & 1) == 0)
  {
    if (-[WiFiUserInteractionMonitor isSetupCompleted]( +[WiFiUserInteractionMonitor sharedInstance](&OBJC_CLASS___WiFiUserInteractionMonitor, "sharedInstance"),  "isSetupCompleted"))
    {
      if (*(_DWORD *)(a1 + 20) == 1
        && sub_1000F1CB4(a1)
        && (v4 - 16) >= 5
        && ([*(id *)(a1 + 3648) isTimeDeferredNetworksPresent] & 1) == 0
        && v4 != 12)
      {
        double v5 = 0.0;
        double v6 = objc_autoreleasePoolPush();
        if (qword_100219F60) {
          objc_msgSend( (id)qword_100219F60,  "WFLog:message:",  3,  "%s: autoHS mode = %d Primary Interface = %d AutoHotspotAssociated=%d wifiNetworkAutoJoinFailed=%d autoHotspo tEnableRequest=%d RemainTimingout=%f",  "__WiFiDeviceManagerScanForAutoInstantHotspot",  *(unsigned int *)(a1 + 6756),  sub_100053D08(*(void *)(a1 + 64)),  *(unsigned __int8 *)(a1 + 6848),  *(unsigned __int8 *)(a1 + 6849),  *(unsigned __int8 *)(a1 + 6752),  *(void *)&v5);
        }
        objc_autoreleasePoolPop(v6);
        if (!*(_BYTE *)(a1 + 6848)
          && *(_BYTE *)(a1 + 6849)
          && sub_1000F1CB4(a1)
          && (a2 || CFAbsoluteTimeGetCurrent() - *(double *)(a1 + 6896) > 180.0))
        {
          CFArrayRemoveAllValues(*(CFMutableArrayRef *)(a1 + 6792));
          *(_DWORD *)(a1 + 6840) = 2;
          *(void *)(a1 + 6832) = 0x300000002LL;
          *(_BYTE *)(a1 + 6920) = 0;
          double v7 = objc_autoreleasePoolPush();
          if (qword_100219F60) {
            objc_msgSend( (id)qword_100219F60,  "WFLog:message:",  3,  "%s: Scanning for Hotspot Devices: curr state %d next state %d",  "__WiFiDeviceManagerScanForAutoInstantHotspot",  *(unsigned int *)(a1 + 3272),  16);
          }
          objc_autoreleasePoolPop(v7);
          if (*(_DWORD *)(a1 + 3272) == 16) {
            sub_1000CABEC(a1, 0);
          }
          *(_DWORD *)(a1 + 6844) = 0;
          *(_DWORD *)(a1 + 3272) = 16;
          *(CFAbsoluteTime *)(a1 + 6896) = CFAbsoluteTimeGetCurrent();
          *(_OWORD *)(a1 + 644_Block_object_dispose((const void *)(v9 - 48), 8) = 0u;
          *(_OWORD *)(a1 + 6464) = 0u;
          *(_OWORD *)(a1 + 6480) = 0u;
          *(_OWORD *)(a1 + 6496) = 0u;
          *(_OWORD *)(a1 + 6512) = 0u;
          *(_OWORD *)(a1 + 652_Block_object_dispose((const void *)(v9 - 48), 8) = 0u;
          *(_OWORD *)(a1 + 6544) = 0u;
          uint32_t v8 = *(dispatch_source_s **)(a1 + 6760);
          dispatch_time_t v9 = dispatch_time(0LL, 30000000000LL);
          dispatch_source_set_timer(v8, v9, 0xFFFFFFFFFFFFFFFFLL, 0LL);
          [*(id *)(a1 + 6728) startBrowsing];
          *(CFAbsoluteTime *)(a1 + 6912) = CFAbsoluteTimeGetCurrent();
          ++*(_DWORD *)(a1 + 6164);
        }
      }
    }

    else
    {
      uint64_t v10 = objc_autoreleasePoolPush();
      if (qword_100219F60) {
        [qword_100219F60 WFLog:@"__WiFiDeviceManagerScanForAutoInstantHotspot: setup not completed yet."];
      }
      objc_autoreleasePoolPop(v10);
    }
  }

uint64_t sub_1000F2108(uint64_t a1)
{
  return *(unsigned int *)(a1 + 6924);
}

void sub_1000F2110(uint64_t a1, int a2)
{
  int valuePtr = a2;
  CFNumberRef v3 = CFNumberCreate(kCFAllocatorDefault, kCFNumberSInt32Type, &valuePtr);
  if (a1)
  {
    uint64_t v4 = *(void *)(a1 + 64);
    double v5 = (const void *)sub_100043E8C(v4);
    sub_10003EC6C(v4, v5, 537LL, 0LL, (uint64_t)v3);
  }

  if (v3) {
    CFRelease(v3);
  }
}

void sub_1000F2188(uint64_t a1, uint64_t a2)
{
  uint64_t v4 = objc_autoreleasePoolPush();
  double v5 = objc_autoreleasePoolPush();
  if (a2)
  {
    if (qword_100219F60) {
      [(id)qword_100219F60 WFLog:3, "%s: setting 3bars source: %@", "WiFiDeviceManagerSet3BarsSource", a2 message];
    }
    objc_autoreleasePoolPop(v5);
    if (!*(void *)(a1 + 6656))
    {
      double v6 = objc_alloc_init(&OBJC_CLASS___NSMutableSet);
      *(void *)(a1 + 6680) = a2;
      -[NSMutableSet addObject:](v6, "addObject:", a2);
      id v7 = objc_alloc_init(&OBJC_CLASS___WiFiWalletSource);
      *(void *)(a1 + 6672) = v7;
      if (v7) {
        -[NSMutableSet addObject:](v6, "addObject:", v7);
      }
      *(void *)(a1 + 6656) = -[WiFiAvailabilityEngine initWithProviders:sources:]( objc_alloc(&OBJC_CLASS___WiFiAvailabilityEngine),  "initWithProviders:sources:",  +[NSSet setWithObjects:]( &OBJC_CLASS___NSSet,  "setWithObjects:",  *(void *)(a1 + 6664),  0LL),  v6);
      uint32_t v8 = objc_autoreleasePoolPush();
      if (qword_100219F60) {
        [qword_100219F60 WFLog:@"%s: initialized availability engine" message:3];
      }
      objc_autoreleasePoolPop(v8);
      v9[0] = _NSConcreteStackBlock;
      v9[1] = 3221225472LL;
      v9[2] = sub_1000F2334;
      void v9[3] = &unk_1001E4D38;
      v9[4] = a1;
      [*(id *)(a1 + 6656) setAvailabilityChangedCallback:v9];
      if (v6) {
        CFRelease(v6);
      }
    }
  }

  else
  {
    if (qword_100219F60) {
      [qword_100219F60 WFLog:@"%s: 3bars source is nil" message:4];
    }
    objc_autoreleasePoolPop(v5);
  }

  objc_autoreleasePoolPop(v4);
}

void sub_1000F2334(uint64_t a1, uint64_t a2)
{
  CFNumberRef v3 = objc_autoreleasePoolPush();
  if (qword_100219F60) {
    [(id)qword_100219F60 WFLog:3, "%s: recommendations found: %@", "__WiFiDeviceManagerHandleNetworkAvailabilityChange", a2 message];
  }
  objc_autoreleasePoolPop(v3);
}

void *sub_1000F2390(void *result, uint64_t a2, double a3, double a4)
{
  if (result)
  {
    id v7 = result;
    if (result[838] != a2 || *((double *)result + 839) != a3 || *((double *)result + 840) != a4)
    {
      result[838] = a2;
      *((double *)result + 839) = a3;
      *((double *)result + 840) = a4;
      uint32_t v8 = objc_autoreleasePoolPush();
      if (qword_100219F60) {
        [qword_100219F60 WFLog:@"WiFiDeviceManagerSetJoinAlertParams" message:3 format:@"%s: mode:%ld time:%f secs, distance: %f m" arguments:a2, a4, a3];
      }
      objc_autoreleasePoolPop(v8);
      BOOL v9 = v7[838] == 255LL || *((_DWORD *)v7 + 1640) == 255;
      return [(id)v7[836] enableTestMode:v9];
    }
  }

  return result;
}

void sub_1000F2480(uint64_t a1, const __CFArray *a2)
{
  if (!a1)
  {
    uint64_t v48 = objc_autoreleasePoolPush();
    if (qword_100219F60) {
      [qword_100219F60 WFLog:@"%s: null manager." message:@"WiFiDeviceManagerGetInterfaceDataUsage"];
    }
    goto LABEL_82;
  }

  if (!a2)
  {
    uint64_t v48 = objc_autoreleasePoolPush();
    if (qword_100219F60) {
      [qword_100219F60 WFLog:@"%s: null mutableIfStatsArrayRef." message:4];
    }
    goto LABEL_82;
  }

  uint64_t v4 = (const void *)sub_10004CE2C(*(void *)(a1 + 64));
  if (!v4)
  {
    uint64_t v48 = objc_autoreleasePoolPush();
    if (qword_100219F60) {
      [qword_100219F60 WFLog:@"%s: null ifName." message:@"WiFiDeviceManagerGetInterfaceDataUsage"];
    }
LABEL_82:
    objc_autoreleasePoolPop(v48);
    return;
  }

  double v5 = v4;
  double v6 = sub_100053F34(*(void *)(a1 + 64), v4);
  id v7 = objc_autoreleasePoolPush();
  uint32_t v8 = v7;
  if (v6)
  {
    char context = v7;
    uint64_t v51 = a1;
    BOOL v9 = -[NSCalendar dateFromComponents:]( +[NSCalendar currentCalendar](&OBJC_CLASS___NSCalendar, "currentCalendar"),  "dateFromComponents:",  -[NSCalendar components:fromDate:]( +[NSCalendar currentCalendar](&OBJC_CLASS___NSCalendar, "currentCalendar"),  "components:fromDate:",  28LL,  +[NSDate date](&OBJC_CLASS___NSDate, "date")));
    if (CFArrayGetCount(a2) < 1) {
      goto LABEL_13;
    }
    CFIndex v10 = 0LL;
    while (1)
    {
      ValueAtIndex = (const __CFDictionary *)CFArrayGetValueAtIndex(a2, v10);
      if (ValueAtIndex)
      {
        uint64_t v12 = ValueAtIndex;
        CFBooleanRef Value = CFDictionaryGetValue(ValueAtIndex, @"DataUsageInterfaceName");
        double v14 = CFDictionaryGetValue(v12, @"DataUsageDate");
        if (Value)
        {
          double v15 = v14;
          if (v14)
          {
            if (CFEqual(Value, v5) && CFEqual(v15, v9)) {
              break;
            }
          }
        }
      }

      if (++v10 >= CFArrayGetCount(a2)) {
        goto LABEL_13;
      }
    }

    MutableCFStringRef Copy = CFDictionaryCreateMutableCopy(kCFAllocatorDefault, 0LL, v12);
    CFArrayRemoveValueAtIndex(a2, v10);
    if (MutableCopy)
    {
      uint32_t v16 = kCFAllocatorDefault;
    }

    else
    {
LABEL_13:
      uint32_t v16 = kCFAllocatorDefault;
      MutableCFStringRef Copy = CFDictionaryCreateMutable( kCFAllocatorDefault,  0LL,  &kCFTypeDictionaryKeyCallBacks,  &kCFTypeDictionaryValueCallBacks);
      CFDictionarySetValue(MutableCopy, @"DataUsageInterfaceName", v5);
      CFDictionarySetValue(MutableCopy, @"DataUsageDate", v9);
    }

    objc_autoreleasePoolPop(context);
    id v18 = (const __CFArray *)CFDictionaryGetValue(MutableCopy, @"DataUsageInterfacePeerList");
    if (v18) {
      CFMutableArrayRef Mutable = CFArrayCreateMutableCopy(v16, 0LL, v18);
    }
    else {
      CFMutableArrayRef Mutable = CFArrayCreateMutable(v16, 0LL, &kCFTypeArrayCallBacks);
    }
    CFMutableArrayRef v20 = Mutable;
    uint64_t v21 = (const __CFArray *)CFDictionaryGetValue(v6, @"DataUsageInterfacePeerList");
    if (v21)
    {
      CFMutableArrayRef v22 = CFArrayCreateMutableCopy(v16, 0LL, v21);
      if (!v20) {
        goto LABEL_63;
      }
    }

    else
    {
      CFMutableArrayRef v22 = 0LL;
      if (!v20)
      {
LABEL_63:
        if (MutableCopy) {
          CFArrayAppendValue(a2, MutableCopy);
        }
        uint64_t v47 = *(const void **)(v51 + 6984);
        if (v47)
        {
          CFRelease(v47);
          *(void *)(v51 + 6984) = 0LL;
        }

        *(void *)(v51 + 6984) = sub_100045B04(*(void *)(v51 + 64));
        if (v22) {
          CFRelease(v22);
        }
        if (v20) {
          CFRelease(v20);
        }
        if (MutableCopy) {
          CFRelease(MutableCopy);
        }
        CFRelease(v6);
        return;
      }
    }

    uint64_t v49 = MutableCopy;
    theArray = v22;
    if (CFArrayGetCount(v20) < 1)
    {
LABEL_59:
      CFMutableArrayRef v22 = theArray;
      if (theArray && CFArrayGetCount(theArray))
      {
        v59.length = CFArrayGetCount(theArray);
        v59.location = 0LL;
        CFArrayAppendArray(v20, theArray, v59);
      }

      MutableCFStringRef Copy = v49;
      CFDictionarySetValue(v49, @"DataUsageInterfacePeerList", v20);
      goto LABEL_63;
    }

    CFIndex v23 = 0LL;
    allocator = v16;
    while (1)
    {
      uint64_t v56 = 0LL;
      unint64_t valuePtr = 0LL;
      uint64_t v54 = 0LL;
      unint64_t v55 = 0LL;
      CFNumberRef v24 = (const __CFDictionary *)CFArrayGetValueAtIndex(v20, v23);
      if (!v24) {
        goto LABEL_49;
      }
      double v25 = CFDictionaryCreateMutableCopy(v16, 0LL, v24);
      if (!v25) {
        goto LABEL_49;
      }
      double v26 = v25;
      double v27 = CFDictionaryGetValue(v25, @"DataUsageInterfacePeerAddr");
      if (v27) {
        break;
      }
LABEL_48:
      CFRelease(v26);
LABEL_49:
      if (++v23 >= CFArrayGetCount(v20)) {
        goto LABEL_59;
      }
    }

    unsigned int v28 = v27;
    CFDictionaryGetValue(v26, @"DataUsageInterfacePeerDisplayName");
    CFNumberRef v29 = (const __CFNumber *)CFDictionaryGetValue(v26, @"DataUsageInterfacePeerLastBytes");
    if (v29) {
      CFNumberGetValue(v29, kCFNumberSInt64Type, &valuePtr);
    }
    int v30 = (const __CFNumber *)CFDictionaryGetValue(v26, @"DataUsageInterfacePeerTotalBytes");
    if (v30) {
      CFNumberGetValue(v30, kCFNumberSInt64Type, &v56);
    }
    if (v21 && CFArrayGetCount(v21) >= 1)
    {
      CFIndex v31 = 0LL;
      while (1)
      {
        unsigned int v32 = (const __CFDictionary *)CFArrayGetValueAtIndex(v21, v31);
        if (v32)
        {
          __int16 v33 = v32;
          CFRange v34 = CFDictionaryGetValue(v32, @"DataUsageInterfacePeerAddr");
          if (v34)
          {
            uint64_t v35 = v34;
            uint64_t v36 = (const __CFNumber *)CFDictionaryGetValue(v33, @"DataUsageInterfacePeerLastBytes");
            if (v36) {
              CFNumberGetValue(v36, kCFNumberSInt64Type, &v55);
            }
            BOOL v37 = (const __CFNumber *)CFDictionaryGetValue(v33, @"DataUsageInterfacePeerTotalBytes");
            if (v37) {
              CFNumberGetValue(v37, kCFNumberSInt64Type, &v54);
            }
            if (CFEqual(v28, v35)) {
              break;
            }
          }
        }

        if (++v31 >= CFArrayGetCount(v21)) {
          goto LABEL_41;
        }
      }

      if (theArray)
      {
        if (CFArrayGetCount(theArray))
        {
          v58.length = CFArrayGetCount(theArray);
          v58.location = 0LL;
          FirstIndexOfCFBooleanRef Value = CFArrayGetFirstIndexOfValue(theArray, v58, v33);
          if (FirstIndexOfValue != -1)
          {
            CFIndex v45 = FirstIndexOfValue;
            uint64_t v46 = objc_autoreleasePoolPush();
            if (qword_100219F60) {
              [qword_100219F60 WFLog:@"%s: processed peer at index %ld" message:3, "WiFiDeviceManagerGetInterfaceDataUsage", v45];
            }
            objc_autoreleasePoolPop(v46);
            CFArrayRemoveValueAtIndex(theArray, v45);
          }
        }
      }

      unint64_t v38 = v55;
      unint64_t v39 = valuePtr;
      if (v55 >= valuePtr) {
        goto LABEL_43;
      }
    }

    else
    {
LABEL_41:
      unint64_t v38 = 0LL;
      unint64_t v39 = valuePtr;
    }

    v56 += v39;
LABEL_43:
    uint32_t v16 = allocator;
    unint64_t valuePtr = v38;
    CFNumberRef v40 = CFNumberCreate(allocator, kCFNumberSInt64Type, &valuePtr);
    if (v40)
    {
      CFNumberRef v41 = v40;
      CFDictionarySetValue(v26, @"DataUsageInterfacePeerLastBytes", v40);
      CFRelease(v41);
    }

    CFNumberRef v42 = CFNumberCreate(allocator, kCFNumberSInt64Type, &v56);
    if (v42)
    {
      CFNumberRef v43 = v42;
      CFDictionarySetValue(v26, @"DataUsageInterfacePeerTotalBytes", v42);
      CFRelease(v43);
    }

    CFArraySetValueAtIndex(v20, v23, v26);
    goto LABEL_48;
  }

  if (qword_100219F60) {
    [qword_100219F60 WFLog:@"%s: null ifUsageRef. Nothing to update." message:3];
  }
  objc_autoreleasePoolPop(v8);
}

void sub_1000F2B28(uint64_t a1, unsigned int a2)
{
  uint64_t v4 = objc_autoreleasePoolPush();
  if (a1)
  {
    if (qword_100219F60) {
      [qword_100219F60 WFLog:@"Debug CoreCapture %d" message:3, "%s: Debug CoreCapture %d",  "WiFiDeviceManagerSetDebugCoreCapture",  a2];
    }
    objc_autoreleasePoolPop(v4);
    *(_BYTE *)(a1 + 3_Block_object_dispose((const void *)(v9 - 48), 8) = a2;
  }

  else
  {
    if (qword_100219F60) {
      [qword_100219F60 WFLog:@"%s: manager is NULL" message:3];
    }
    objc_autoreleasePoolPop(v4);
  }

void sub_1000F2BD8(uint64_t a1, unsigned int a2)
{
  uint64_t v4 = objc_autoreleasePoolPush();
  if (a1)
  {
    if (qword_100219F60) {
      [qword_100219F60 WFLog:@"CoreCapture On Assisted AJ Failure %d" message:3];
    }
    objc_autoreleasePoolPop(v4);
    *(_BYTE *)(a1 + 39) = a2;
  }

  else
  {
    if (qword_100219F60) {
      [qword_100219F60 WFLog:@"%s: manager is NULL" message:3];
    }
    objc_autoreleasePoolPop(v4);
  }

void sub_1000F2C88(uint64_t a1, const void *a2)
{
  if (a1)
  {
    if (a2) {
      CFDictionaryRemoveValue(*(CFMutableDictionaryRef *)(a1 + 7016), a2);
    }
  }

NSMutableArray *sub_1000F2C9C(uint64_t a1)
{
  if (!a1) {
    return 0LL;
  }
  uint64_t v1 = *(void **)(a1 + 6656);
  if (!v1)
  {
    CFMutableArrayRef v20 = objc_autoreleasePoolPush();
    if (qword_100219F60) {
      [qword_100219F60 WFLog:@"%s: availability engine is NULL" message:4];
    }
    goto LABEL_50;
  }

  id v2 = [v1 availableNetworks];
  if (!v2 || (CFNumberRef v3 = v2, ![v2 count]))
  {
    CFMutableArrayRef v20 = objc_autoreleasePoolPush();
    if (qword_100219F60) {
      [qword_100219F60 WFLog:@"%s: no available networks" message:3];
    }
LABEL_50:
    objc_autoreleasePoolPop(v20);
    return 0LL;
  }

  CFIndex v23 = objc_alloc_init(&OBJC_CLASS___NSMutableArray);
  if (!v23) {
    return 0LL;
  }
  __int128 v30 = 0u;
  __int128 v31 = 0u;
  __int128 v28 = 0u;
  __int128 v29 = 0u;
  id v4 = [v3 countByEnumeratingWithState:&v28 objects:v33 count:16];
  if (v4)
  {
    id v5 = v4;
    obCFIndex j = v3;
    uint64_t v22 = *(void *)v29;
    do
    {
      for (CFIndex i = 0LL; i != v5; CFIndex i = (char *)i + 1)
      {
        if (*(void *)v29 != v22) {
          objc_enumerationMutation(obj);
        }
        id v7 = *(void **)(*((void *)&v28 + 1) + 8LL * (void)i);
        uint32_t v8 = objc_alloc_init(&OBJC_CLASS___NSMutableDictionary);
        if ([v7 SSID]) {
          -[NSMutableDictionary setObject:forKey:](v8, "setObject:forKey:", [v7 SSID], @"ssid");
        }
        if (objc_msgSend(objc_msgSend(v7, "network"), "accessPoints")) {
          -[NSMutableDictionary setObject:forKey:]( v8,  "setObject:forKey:",  +[NSNumber numberWithUnsignedInteger:]( NSNumber,  "numberWithUnsignedInteger:",  objc_msgSend(objc_msgSend(objc_msgSend(v7, "network"), "accessPoints"), "count")),  @"apCount");
        }
        if (objc_opt_respondsToSelector([v7 network], "uniqueIdentifier")) {
          -[NSMutableDictionary setObject:forKey:]( v8,  "setObject:forKey:",  objc_msgSend((id)objc_opt_self(objc_msgSend(v7, "network")), "uniqueIdentifier"),  @"uniqueIdentifier");
        }
        id v9 = objc_msgSend(objc_msgSend(v7, "network"), "source");
        CFIndex v10 = @"unknown";
        if (v9 == (id)2) {
          CFIndex v10 = @"3bars";
        }
        if (v9 == (id)1) {
          dispatch_time_t v11 = @"wallet";
        }
        else {
          dispatch_time_t v11 = v10;
        }
        -[NSMutableDictionary setObject:forKey:](v8, "setObject:forKey:", v11, @"source");
        if (objc_msgSend(objc_msgSend(v7, "scannedNetwork"), "BSSID")) {
          -[NSMutableDictionary setObject:forKey:]( v8,  "setObject:forKey:",  objc_msgSend(objc_msgSend(v7, "scannedNetwork"), "BSSID"),  @"scannedBSSID");
        }
        if (objc_msgSend(objc_msgSend(v7, "scannedNetwork"), "essMembers")) {
          -[NSMutableDictionary setObject:forKey:]( v8,  "setObject:forKey:",  +[NSNumber numberWithUnsignedInteger:]( NSNumber,  "numberWithUnsignedInteger:",  objc_msgSend(objc_msgSend(objc_msgSend(v7, "scannedNetwork"), "essMembers"), "count")),  @"essMemberCount");
        }
        if (objc_msgSend(objc_msgSend(v7, "network"), "popularityScore")) {
          -[NSMutableDictionary setObject:forKey:]( v8,  "setObject:forKey:",  +[NSNumber numberWithUnsignedInteger:]( NSNumber,  "numberWithUnsignedInteger:",  objc_msgSend(objc_msgSend(objc_msgSend(v7, "network"), "popularityScore"), "score")),  @"popularityScore");
        }
        if (objc_msgSend(objc_msgSend(v7, "network"), "password")) {
          -[NSMutableDictionary setObject:forKey:]( v8,  "setObject:forKey:",  objc_msgSend(objc_msgSend(v7, "network"), "password"),  @"password");
        }
        if (objc_msgSend(objc_msgSend(v7, "network"), "attributes"))
        {
          uint64_t v12 = objc_alloc_init(&OBJC_CLASS___NSMutableString);
          __int128 v24 = 0u;
          __int128 v25 = 0u;
          __int128 v26 = 0u;
          __int128 v27 = 0u;
          id v13 = objc_msgSend(objc_msgSend(v7, "network"), "attributes");
          id v14 = [v13 countByEnumeratingWithState:&v24 objects:v32 count:16];
          if (v14)
          {
            id v15 = v14;
            uint64_t v16 = *(void *)v25;
            do
            {
              for (CFIndex j = 0LL; j != v15; CFIndex j = (char *)j + 1)
              {
                if (*(void *)v25 != v16) {
                  objc_enumerationMutation(v13);
                }
                unsigned int v18 = [*(id *)(*((void *)&v24 + 1) + 8 * (void)j) intValue] - 1;
                if (v18 <= 5) {
                  -[NSMutableString appendString:](v12, "appendString:", off_1001E5660[v18]);
                }
              }

              id v15 = [v13 countByEnumeratingWithState:&v24 objects:v32 count:16];
            }

            while (v15);
          }

          if (-[NSMutableString length](v12, "length")) {
            -[NSMutableDictionary setObject:forKey:]( v8,  "setObject:forKey:",  -[NSMutableString stringByTrimmingCharactersInSet:]( v12,  "stringByTrimmingCharactersInSet:",  +[NSCharacterSet whitespaceCharacterSet](&OBJC_CLASS___NSCharacterSet, "whitespaceCharacterSet")),  @"attributes");
          }
        }

        -[NSMutableArray addObject:](v23, "addObject:", v8);
      }

      id v5 = [obj countByEnumeratingWithState:&v28 objects:v33 count:16];
    }

    while (v5);
  }

  return v23;
}

uint64_t sub_1000F3144(uint64_t result, uint64_t a2, uint64_t a3)
{
  *(void *)(result + 468_Block_object_dispose((const void *)(v9 - 48), 8) = a2;
  *(void *)(result + 4696) = a3;
  return result;
}

uint64_t sub_1000F3150(uint64_t a1)
{
  return *(unsigned __int8 *)(a1 + 88);
}

void sub_1000F3158(uint64_t a1)
{
  if (!a1)
  {
    CFNumberRef v3 = objc_autoreleasePoolPush();
    if (qword_100219F60) {
      [qword_100219F60 WFLog:@"%s: null wifidevice manager" message:4];
    }
    goto LABEL_10;
  }

  uint64_t v2 = *(void *)(a1 + 6688);
  CFNumberRef v3 = objc_autoreleasePoolPush();
  if (!v2)
  {
    if (qword_100219F60) {
      [qword_100219F60 WFLog:@"%s: null user notification manager" message:@"WiFiDeviceManagerResetAvailabilityEngine"];
    }
LABEL_10:
    objc_autoreleasePoolPop(v3);
    return;
  }

  if (qword_100219F60) {
    [qword_100219F60 WFLog:@"%s: reseting user notification states" message:@"WiFiDeviceManagerResetAvailabilityEngine"];
  }
  objc_autoreleasePoolPop(v3);
  [*(id *)(a1 + 6688) reset];
}

__CFDictionary *sub_1000F3238(uint64_t a1, const __CFDictionary *a2)
{
  id v4 = objc_autoreleasePoolPush();
  CFNumberRef number = 0LL;
  CFNumberRef value = 0LL;
  uint64_t v31 = 13LL;
  CFTypeRef cf = 0LL;
  if (!a1)
  {
    __int128 v28 = objc_autoreleasePoolPush();
    if (qword_100219F60) {
      [qword_100219F60 WFLog:@"%s: manager is NULL!"];
    }
    goto LABEL_76;
  }

  if (!a2)
  {
    __int128 v28 = objc_autoreleasePoolPush();
    if (qword_100219F60) {
      [qword_100219F60 WFLog:@"%s: request is NULL!"];
    }
    goto LABEL_76;
  }

  CFDictionaryGetValueIfPresent(a2, @"command", (const void **)&value);
  if (!value)
  {
    __int128 v28 = objc_autoreleasePoolPush();
    if (qword_100219F60) {
      [qword_100219F60 WFLog:@"%s with no command" message:3];
    }
    goto LABEL_76;
  }

  if (!sub_1000511F0(*(void *)(a1 + 64)))
  {
    __int128 v28 = objc_autoreleasePoolPush();
    if (qword_100219F60) {
      [qword_100219F60 WFLog:@"BssBlacklist not supported on this platform.. Bailing!"];
    }
    goto LABEL_76;
  }

  CFDictionaryGetValueIfPresent(a2, @"network", &cf);
  if (!cf)
  {
    dispatch_time_t v11 = 0LL;
    goto LABEL_22;
  }

  id v5 = sub_100094AAC((uint64_t)kCFAllocatorDefault, cf);
  if (!v5)
  {
    __int128 v28 = objc_autoreleasePoolPush();
    if (qword_100219F60) {
      [qword_100219F60 WFLog:@"%s couldn't convert record to network" message:3];
    }
    goto LABEL_76;
  }

  double v6 = v5;
  if (CFArrayGetCount(*(CFArrayRef *)(a1 + 3520)) < 1)
  {
LABEL_11:
    ValueAtIndex = 0LL;
  }

  else
  {
    CFIndex v7 = 0LL;
    while (1)
    {
      ValueAtIndex = CFArrayGetValueAtIndex(*(CFArrayRef *)(a1 + 3520), v7);
      if (CFEqual(v6, ValueAtIndex)) {
        break;
      }
      if (++v7 >= CFArrayGetCount(*(CFArrayRef *)(a1 + 3520))) {
        goto LABEL_11;
      }
    }
  }

  if (CFArrayGetCount(*(CFArrayRef *)(a1 + 3528)) < 1)
  {
LABEL_16:
    if (!ValueAtIndex)
    {
LABEL_20:
      dispatch_time_t v11 = 0LL;
      goto LABEL_21;
    }
  }

  else
  {
    CFIndex v9 = 0LL;
    while (1)
    {
      CFIndex v10 = CFArrayGetValueAtIndex(*(CFArrayRef *)(a1 + 3528), v9);
      if (CFEqual(v6, v10)) {
        break;
      }
      if (++v9 >= CFArrayGetCount(*(CFArrayRef *)(a1 + 3528))) {
        goto LABEL_16;
      }
    }

    ValueAtIndex = v10;
    if (!v10) {
      goto LABEL_20;
    }
  }

  dispatch_time_t v11 = sub_100094E60((uint64_t)kCFAllocatorDefault, (uint64_t)ValueAtIndex);
  uint64_t v12 = sub_1000951FC((uint64_t)v6, @"BSSID");
  sub_10009582C((uint64_t)v11, @"BSSID", v12);
LABEL_21:
  CFRelease(v6);
LABEL_22:
  if (CFStringCompare((CFStringRef)value, @"kBssBlacklistSet", 0LL) == kCFCompareEqualTo)
  {
    CFDictionaryGetValueIfPresent(a2, @"reason", (const void **)&number);
    if (number) {
      CFNumberGetValue(number, kCFNumberLongType, &v31);
    }
    if (!v11)
    {
LABEL_74:
      __int128 v28 = objc_autoreleasePoolPush();
      if (qword_100219F60) {
        [qword_100219F60 WFLog:@"Couldn't find network to set blacklist condition" message:3];
      }
LABEL_76:
      objc_autoreleasePoolPop(v28);
      __int128 v25 = sub_1000F3918(a1, &off_100205828);
      goto LABEL_63;
    }

    uint64_t v17 = v31;
    unsigned int v18 = objc_autoreleasePoolPush();
    if (v17 == 13)
    {
      if (qword_100219F60) {
        [qword_100219F60 WFLog:@"%s - Couldn't determine blacklist condition to set" message:3, @"WiFiDeviceManagerProcessBssBlacklistCommandsAndCopyResponse", v29];
      }
    }

    else
    {
      id v19 = sub_1000A335C((uint64_t)v11);
      [*(id *)(a1 + 6632) setDenyListedStateExpiryIntervalInSec:1 state:60.0];
      if (v17 == 8)
      {
        CFMutableArrayRef v20 = sub_1000951FC((uint64_t)v11, @"BSSID");
        id v21 = sub_1000D1BDC(a1, 8LL, 0LL, (uint64_t)v20, 2LL);
        [*(id *)(a1 + 6632) setNetworkDenyListInfo:v21 forScanResult:v19];
        [*(id *)(a1 + 6632) setNetworkDenyListInfo:v21 forScanResult:v19];
        [*(id *)(a1 + 6632) setNetworkDenyListInfo:v21 forScanResult:v19];
        uint64_t v22 = *(void **)(a1 + 7320);
        if (v22) {
          [v22 addFaultEvent:9 forInterface:sub_100043E8C(*(void *)(a1 + 64))];
        }
        if (v21) {
      }
        }

      else
      {
        __int128 v24 = objc_autoreleasePoolPush();
        if (qword_100219F60) {
          [qword_100219F60 WFLog:@"__WiFiDeviceManagerSetBssBlacklistedNetworkCondition - unrecognized WiFiDenyListAddReason" message:3];
        }
        objc_autoreleasePoolPop(v24);
      }

      if (v19) {

      }
      objc_autoreleasePoolPop(v18);
      if (v17 == 8) {
        goto LABEL_55;
      }
      unsigned int v18 = objc_autoreleasePoolPush();
      if (qword_100219F60) {
        [qword_100219F60 WFLog:@"%s - __WiFiDeviceManagerSetBssBlacklistedNetworkCondition %lu failed" message:3 v31];
      }
    }

    objc_autoreleasePoolPop(v18);
LABEL_55:
    __int128 v25 = sub_1000F3918(a1, &off_100205828);
LABEL_62:
    CFRelease(v11);
    goto LABEL_63;
  }

  id v13 = (const __CFNumber *)CFDictionaryGetValue(a2, @"timeout");
  if (v13 && (int valuePtr = 0, CFNumberGetValue(v13, kCFNumberIntType, &valuePtr)))
  {
    id v14 = objc_autoreleasePoolPush();
    if (qword_100219F60) {
      [qword_100219F60 WFLog:@"Configuring BssBlacklist Expiry interval to %d" message:3, "%s - Configuring BssBlacklist Expiry interval to %d",  "WiFiDeviceManagerProcessBssBlacklistCommandsAndCopyResponse",  valuePtr];
    }
    objc_autoreleasePoolPop(v14);
    [*(id *)(a1 + 6632) setDenyListedStateExpiryIntervalInSec:2 state:(double)valuePtr];
    int v15 = 1;
  }

  else
  {
    int v15 = 0;
  }

  if (CFStringCompare((CFStringRef)value, @"kBssBlacklistClear", 0LL) == kCFCompareEqualTo)
  {
    if (v11)
    {
      id v23 = sub_1000A335C((uint64_t)v11);
      [*(id *)(a1 + 6632) removeNetworkDenyListInfoWithReason:1 forScanResult:v23];

      goto LABEL_57;
    }

    goto LABEL_74;
  }

  if (CFStringCompare((CFStringRef)value, @"kBssBlacklistRemove", 0LL))
  {
    if (CFStringCompare((CFStringRef)value, @"kBssBlacklistExpire", 0LL) == kCFCompareEqualTo)
    {
      [*(id *)(a1 + 6632) removeExpiredDenyListedState:2];
      if (![*(id *)(a1 + 6632) denyListedNetworkCount])
      {
        uint64_t v16 = objc_autoreleasePoolPush();
        if (qword_100219F60) {
          [qword_100219F60 WFLog:@"%s - Couldn't perform BSS unblacklist" message:3];
        }
LABEL_81:
        objc_autoreleasePoolPop(v16);
        goto LABEL_61;
      }
    }
  }

  else
  {
    [*(id *)(a1 + 6632) removeDenyListStateWithDenyListRemoveReason:5];
    if (![*(id *)(a1 + 6632) denyListedNetworkCount])
    {
      uint64_t v16 = objc_autoreleasePoolPush();
      if (qword_100219F60) {
        [qword_100219F60 WFLog:@"%s - Couldn't perform time triggered BSS unblacklist" message:3];
      }
      goto LABEL_81;
    }
  }

__CFDictionary *sub_1000F3918(uint64_t a1, void *a2)
{
  uint64_t v44 = objc_autoreleasePoolPush();
  CFMutableArrayRef Mutable = CFArrayCreateMutable(kCFAllocatorDefault, 0LL, &kCFTypeArrayCallBacks);
  CFMutableArrayRef v4 = CFArrayCreateMutable(kCFAllocatorDefault, 0LL, &kCFTypeArrayCallBacks);
  CFMutableArrayRef v5 = CFArrayCreateMutable(kCFAllocatorDefault, 0LL, &kCFTypeArrayCallBacks);
  CFMutableArrayRef v6 = CFArrayCreateMutable(kCFAllocatorDefault, 0LL, &kCFTypeArrayCallBacks);
  __int128 v57 = 0u;
  __int128 v58 = 0u;
  __int128 v59 = 0u;
  __int128 v60 = 0u;
  obCFIndex j = a2;
  id v7 = [a2 countByEnumeratingWithState:&v57 objects:v61 count:16];
  if (!v7)
  {
LABEL_51:
    unint64_t v39 = CFDictionaryCreateMutable(0LL, 0LL, &kCFTypeDictionaryKeyCallBacks, &kCFTypeDictionaryValueCallBacks);
    CFDictionarySetValue(v39, @"networks", Mutable);
    CFDictionarySetValue(v39, @"reasons", v4);
    CFDictionarySetValue(v39, @"timestamps", v6);
    CFDictionarySetValue(v39, @"reasonData", v5);
LABEL_61:
    CFNumberRef v41 = v44;
    if (v6) {
      goto LABEL_62;
    }
    goto LABEL_63;
  }

  id v8 = v7;
  uint64_t v9 = *(void *)v58;
  uint64_t v51 = v5;
  theArray = v4;
  uint64_t v49 = Mutable;
  uint64_t v50 = v6;
  uint64_t v45 = *(void *)v58;
LABEL_3:
  uint64_t v10 = 0LL;
  id v46 = v8;
  while (1)
  {
    if (*(void *)v58 != v9) {
      objc_enumerationMutation(obj);
    }
    id v54 = [*(id *)(*((void *)&v57 + 1) + 8 * v10) integerValue];
    id v11 = objc_msgSend(*(id *)(a1 + 6632), "networksInDenyListedState:");
    if (!v11) {
      goto LABEL_49;
    }
    uint64_t v12 = v11;
    if (![v11 count]) {
      goto LABEL_49;
    }
    uint64_t v48 = v10;
    if ([v12 count])
    {
      id v13 = v12;
      unint64_t v14 = 0LL;
      int v53 = v12;
      do
      {
        id v15 = [v13 objectAtIndex:v14];
        uint64_t v16 = sub_1000A3DB0(v15);
        if (v16)
        {
          uint64_t v17 = v16;
          id v18 = +[NSMutableArray array](&OBJC_CLASS___NSMutableArray, "array");
          id v19 = +[NSMutableArray array](&OBJC_CLASS___NSMutableArray, "array");
          id v20 = [*(id *)(a1 + 6632) reasonsForNetworkInDenyListedState:v15 state:v54 timestamps:v18 reasonData:v19];
          if (v20)
          {
            id v21 = v20;
            if ([v20 count])
            {
              uint64_t v22 = CFArrayCreateMutable(kCFAllocatorDefault, 0LL, &kCFTypeArrayCallBacks);
              if ([v21 count])
              {
                unint64_t v23 = 0LL;
                do
                {
                  id v24 = [v21 objectAtIndex:v23];
                  LODWORD(valuePtr) = -1431655766;
                  LODWORD(valuePtr) = [v24 unsignedIntegerValue];
                  CFNumberRef v25 = CFNumberCreate(kCFAllocatorDefault, kCFNumberIntType, &valuePtr);
                  CFArrayAppendValue(v22, v25);
                  if (v25) {
                    CFRelease(v25);
                  }
                  ++v23;
                }

                while (v23 < (unint64_t)[v21 count]);
              }

              CFArrayAppendValue(theArray, v22);
              if (v22) {
                CFRelease(v22);
              }
              __int128 v26 = sub_100094E60((uint64_t)kCFAllocatorDefault, (uint64_t)v17);
              CFMutableArrayRef Mutable = v49;
              CFArrayAppendValue(v49, v26);
              id v13 = v53;
              if (v26) {
                CFRelease(v26);
              }
            }
          }

          if (v18 && [v18 count])
          {
            __int128 v27 = CFArrayCreateMutable(kCFAllocatorDefault, 0LL, &kCFTypeArrayCallBacks);
            if ([v18 count])
            {
              unint64_t v28 = 0LL;
              do
              {
                id v29 = [v18 objectAtIndex:v28];
                uint64_t valuePtr = -1LL;
                [v29 doubleValue];
                uint64_t valuePtr = v30;
                CFNumberRef v31 = CFNumberCreate(kCFAllocatorDefault, kCFNumberDoubleType, &valuePtr);
                CFArrayAppendValue(v27, v31);
                if (v31) {
                  CFRelease(v31);
                }
                ++v28;
              }

              while (v28 < (unint64_t)[v18 count]);
            }

            CFArrayAppendValue(v50, v27);
            id v13 = v53;
            if (v27) {
              CFRelease(v27);
            }
          }

          if (v19 && [v19 count])
          {
            unsigned int v32 = CFArrayCreateMutable(kCFAllocatorDefault, 0LL, &kCFTypeArrayCallBacks);
            if ([v19 count])
            {
              unint64_t v33 = 0LL;
              do
              {
                id v34 = [v19 objectAtIndex:v33];
                LODWORD(valuePtr) = -1431655766;
                LODWORD(valuePtr) = [v34 unsignedIntegerValue];
                CFNumberRef v35 = CFNumberCreate(kCFAllocatorDefault, kCFNumberIntType, &valuePtr);
                CFArrayAppendValue(v32, v35);
                if (v35) {
                  CFRelease(v35);
                }
                ++v33;
              }

              while (v33 < (unint64_t)[v19 count]);
            }

            CFArrayAppendValue(v51, v32);
            if (v32) {
              CFRelease(v32);
            }
          }

          CFRelease(v17);
        }

        ++v14;
      }

      while (v14 < (unint64_t)[v13 count]);
    }

    if (!CFArrayGetCount(Mutable))
    {
      unint64_t v39 = 0LL;
      CFNumberRef v41 = v44;
      CFMutableArrayRef v5 = v51;
      CFMutableArrayRef v4 = theArray;
      CFMutableArrayRef v6 = v50;
      if (!v50) {
        goto LABEL_63;
      }
LABEL_62:
      CFRelease(v6);
      goto LABEL_63;
    }

    CFMutableArrayRef v4 = theArray;
    CFMutableArrayRef v6 = v50;
    CFMutableArrayRef v5 = v51;
    if (!CFArrayGetCount(theArray)) {
      break;
    }
    CFIndex Count = CFArrayGetCount(theArray);
    if (Count != CFArrayGetCount(Mutable)) {
      break;
    }
    if (!CFArrayGetCount(v50) || (CFIndex v37 = CFArrayGetCount(theArray), v37 != CFArrayGetCount(v50)))
    {
      CFNumberRef v42 = objc_autoreleasePoolPush();
      if (qword_100219F60) {
        [qword_100219F60 WFLog:@"%s Mismatched reason and timestamp array counts" message:3];
      }
      goto LABEL_60;
    }

    uint64_t v9 = v45;
    id v8 = v46;
    uint64_t v10 = v48;
    if (!CFArrayGetCount(v51) || (CFIndex v38 = CFArrayGetCount(theArray), v38 != CFArrayGetCount(v51)))
    {
      CFNumberRef v42 = objc_autoreleasePoolPush();
      if (qword_100219F60) {
        [qword_100219F60 WFLog:@"Mismatched reason and reasonData array counts" message:3];
      }
LABEL_60:
      objc_autoreleasePoolPop(v42);
      unint64_t v39 = 0LL;
      goto LABEL_61;
    }

void sub_1000F3F84(uint64_t a1, uint64_t a2)
{
}

void sub_1000F3F94(uint64_t a1)
{
}

id sub_1000F3FA0(uint64_t a1, uint64_t a2)
{
  CFNumberRef v3 = (const char *)[sub_1000951FC(a2, @"BSSID") UTF8String];
  return [*(id *)(*(void *)(*(void *)(a1 + 32) + 8) + 40) addObject:[NSData dataWithBytes:ether_aton(v3) length:6]];
}

uint64_t sub_1000F3FFC(uint64_t a1, unsigned int a2)
{
  uint64_t v3 = *(void *)(a1 + 64);
  CFMutableArrayRef v4 = (const void *)sub_100043E8C(v3);
  return sub_10004D580(v3, v4, a2);
}

void sub_1000F4030(uint64_t a1, const __CFDictionary *a2)
{
  int valuePtr = 0;
  CFMutableDictionaryRef Mutable = CFDictionaryCreateMutable( kCFAllocatorDefault,  0LL,  &kCFTypeDictionaryKeyCallBacks,  &kCFTypeDictionaryValueCallBacks);
  if (Mutable)
  {
    CFMutableArrayRef v5 = Mutable;
    CFMutableArrayRef v6 = (const __CFNumber *)CFDictionaryGetValue(a2, @"ADAPTIVE_ROAM_RSSI_TRIGGER");
    if (v6
      && (id v7 = v6,
          CFNumberGetValue(v6, kCFNumberIntType, &valuePtr),
          *(_DWORD *)(a1 + 7336) = valuePtr,
          (CFMutableArrayRef v8 = CFArrayCreateMutable(kCFAllocatorDefault, 0LL, &kCFTypeArrayCallBacks)) != 0LL))
    {
      uint64_t v9 = v8;
      uint64_t v10 = *(const void **)(a1 + 7344);
      if (v10)
      {
        CFRelease(v10);
        *(void *)(a1 + 7344) = 0LL;
      }

      id v11 = CFDictionaryGetValue(a2, @"ADAPTIVE_ROAM_CHANNELS_INFO");
      *(void *)(a1 + 7344) = v11;
      if (v11)
      {
        CFNumberRef value = v7;
        theDict = v5;
        CFRetain(v11);
        uint64_t v12 = *(const __CFArray **)(a1 + 7344);
        if (v12)
        {
          CFIndex Count = CFArrayGetCount(v12);
          if (Count >= 1)
          {
            CFIndex v14 = Count;
            CFIndex v15 = 0LL;
            key = (void *)kWAMessageKeyChannel;
            uint64_t v16 = (const void *)kWAMessageKeyChannelFlags;
            do
            {
              ValueAtIndex = CFArrayGetValueAtIndex(*(CFArrayRef *)(a1 + 7344), v15);
              if (ValueAtIndex)
              {
                id v18 = ValueAtIndex;
                CFTypeID v19 = CFGetTypeID(ValueAtIndex);
                CFTypeID TypeID = CFDictionaryGetTypeID();
                CFTypeID v21 = CFGetTypeID(v18);
                if (v21 == CFNumberGetTypeID()) {
                  uint64_t v22 = v18;
                }
                else {
                  uint64_t v22 = 0LL;
                }
                if (v19 == TypeID)
                {
                  unint64_t v23 = CFDictionaryGetValue((CFDictionaryRef)v18, key);
                  id v24 = CFDictionaryGetValue((CFDictionaryRef)v18, v16);
                  if (!v23) {
                    goto LABEL_23;
                  }
                  uint64_t v22 = v24;
                  if (!v24) {
                    goto LABEL_23;
                  }
                  CFNumberRef v25 = CFDictionaryCreateMutable( kCFAllocatorDefault,  0LL,  &kCFTypeDictionaryKeyCallBacks,  &kCFTypeDictionaryValueCallBacks);
                  if (!v25) {
                    goto LABEL_23;
                  }
                  __int128 v26 = v25;
                  CFDictionarySetValue(v25, @"IO80211Channel", v23);
                  __int128 v27 = v26;
                  unint64_t v28 = @"IO80211ChannelFlags";
                }

                else
                {
                  if (!v22) {
                    goto LABEL_23;
                  }
                  __int128 v27 = CFDictionaryCreateMutable( kCFAllocatorDefault,  0LL,  &kCFTypeDictionaryKeyCallBacks,  &kCFTypeDictionaryValueCallBacks);
                  if (!v27) {
                    goto LABEL_23;
                  }
                  __int128 v26 = v27;
                  unint64_t v28 = @"IO80211Channel";
                }

                CFDictionarySetValue(v27, v28, v22);
                CFArrayAppendValue(v9, v26);
                CFRelease(v26);
              }

void sub_1000F4340(uint64_t a1, __CFDictionary *a2)
{
  if (a1 && a2)
  {
    id v29 = kCFBooleanFalse;
    CFNumberRef value = (const __CFBoolean *)sub_1000951FC(a1, @"MacAddressRandomisationTagMigratedNetwork");
    CFMutableArrayRef v4 = sub_1000951FC(a1, @"isHs20BasedNetwork");
    CFMutableArrayRef v5 = sub_1000951FC(a1, @"DomainName");
    __int128 v26 = (const __CFBoolean *)sub_1000951FC(a1, @"isProfileBasedNetwork");
    CFBooleanRef v6 = (CFBooleanRef)sub_1000951FC(a1, @"PrivateMacDefaultToOFF");
    CFNumberRef v31 = (void *)sub_1000951FC(a1, @"isCarrierBundleBased");
    unsigned int v32 = (void *)sub_1000951FC(a1, @"DisplayedOperatorName");
    unint64_t v28 = (const __CFBoolean *)sub_1000951FC(a1, @"FeatureOffBySystemForHome");
    __int128 v27 = (const __CFBoolean *)sub_1000951FC(a1, @"FeatureOFFBySystemForFrequentlyUsedNetworks");
    id v7 = (const __CFBoolean *)sub_1000951FC(a1, @"FeatureOffBySystemForCarplay");
    [sub_1000951FC(a1, @"PrivateMacJoinDateAfterUpgrade") timeIntervalSinceNow];
    double v9 = v8;
    CFNumberRef v25 = (const __CFBoolean *)sub_1000951FC(a1, @"ExperiencedFallback");
    uint64_t v10 = sub_1000951FC(a1, @"PrivateMacControlledDevice");
    id v11 = (const __CFDictionary *)sub_1000951FC(a1, @"PRIVATE_MAC_ADDRESS");
    uint64_t v12 = v4;
    if (v11 && (id v13 = (const __CFNumber *)CFDictionaryGetValue(v11, @"PRIVATE_MAC_ADDRESS_TYPE")) != 0LL)
    {
      unsigned int v14 = sub_10003B810(v13);
      CFBooleanRef v15 = (CFBooleanRef)sub_1000951FC(a1, @"PrivateMacPrefChanged");
      CFBooleanRef v16 = value;
      if (v15)
      {
        BOOL v17 = v14 == 1 && v15 == kCFBooleanTrue;
        CFBooleanRef v18 = kCFBooleanFalse;
        if (v17) {
          CFBooleanRef v18 = kCFBooleanTrue;
        }
        id v29 = v18;
      }
    }

    else
    {
      CFBooleanRef v16 = value;
    }

    if (v10) {
      CFDictionarySetValue(a2, @"PrivateMacControlledDevice", v10);
    }
    if (v6) {
      CFDictionarySetValue(a2, @"PrivateMacDefaultToOFF", v6);
    }
    if (v5) {
      CFDictionarySetValue(a2, @"DomainName", v5);
    }
    if (v16) {
      CFDictionarySetValue(a2, @"MacAddressRandomisationTagMigratedNetwork", v16);
    }
    if (v12) {
      CFDictionarySetValue(a2, @"isHs20BasedNetwork", v12);
    }
    if (v31) {
      CFDictionarySetValue(a2, @"isCarrierBundleBased", v31);
    }
    if (v32) {
      CFDictionarySetValue(a2, @"DisplayedOperatorName", v32);
    }
    if (v7 && v7 == kCFBooleanTrue)
    {
      uint64_t v19 = 5LL;
    }

    else if (v28 && v28 == kCFBooleanTrue || v27 && v27 == kCFBooleanTrue)
    {
      uint64_t v19 = 4LL;
    }

    else
    {
      if (!v29 || v29 != kCFBooleanTrue)
      {
        if (v26)
        {
          uint64_t v19 = v26 == kCFBooleanTrue && v6 == kCFBooleanTrue && v6 != 0LL;
          if (!v16 || (v19 & 1) != 0) {
            goto LABEL_35;
          }
        }

        else if (!v16)
        {
          uint64_t v19 = 0LL;
          goto LABEL_35;
        }

        if (v25 == kCFBooleanTrue && v25 != 0LL && v9 < -86400.0 && v16 == kCFBooleanTrue) {
          uint64_t v19 = 2LL;
        }
        else {
          uint64_t v19 = 0LL;
        }
        goto LABEL_35;
      }

      uint64_t v19 = 3LL;
    }

uint64_t sub_1000F46D0()
{
  if (-[WiFiUserInteractionMonitor isCarPlay]( +[WiFiUserInteractionMonitor sharedInstance](&OBJC_CLASS___WiFiUserInteractionMonitor, "sharedInstance"),  "isCarPlay")
    || -[WiFiUserInteractionMonitor isMediaPlaying]( +[WiFiUserInteractionMonitor sharedInstance](&OBJC_CLASS___WiFiUserInteractionMonitor, "sharedInstance"),  "isMediaPlaying")
    || -[WiFiUserInteractionMonitor isAirplayActiveOverInfra]( +[WiFiUserInteractionMonitor sharedInstance](&OBJC_CLASS___WiFiUserInteractionMonitor, "sharedInstance"),  "isAirplayActiveOverInfra"))
  {
    unsigned int v0 = 1;
  }

  else
  {
    unsigned int v0 = -[WiFiUserInteractionMonitor isRealTimeAppActive]( +[WiFiUserInteractionMonitor sharedInstance](&OBJC_CLASS___WiFiUserInteractionMonitor, "sharedInstance"),  "isRealTimeAppActive");
  }

  unsigned int v1 = -[WiFiUserInteractionMonitor isInHomeScreen]( +[WiFiUserInteractionMonitor sharedInstance](&OBJC_CLASS___WiFiUserInteractionMonitor, "sharedInstance"),  "isInHomeScreen");
  unsigned int v2 = -[WiFiUserInteractionMonitor isAVConferenceActive]( +[WiFiUserInteractionMonitor sharedInstance](&OBJC_CLASS___WiFiUserInteractionMonitor, "sharedInstance"),  "isAVConferenceActive");
  if (v0) {
    unsigned int v3 = 0;
  }
  else {
    unsigned int v3 = v1;
  }
  CFMutableArrayRef v4 = objc_autoreleasePoolPush();
  if (qword_100219F60)
  {
    CFMutableArrayRef v5 = "Foreground";
    if (v3) {
      CFMutableArrayRef v5 = "Background";
    }
    CFBooleanRef v6 = "yes";
    if (v1) {
      id v7 = "no";
    }
    else {
      id v7 = "yes";
    }
    if (v2) {
      double v8 = "yes";
    }
    else {
      double v8 = "no";
    }
    if (!v0) {
      CFBooleanRef v6 = "no";
    }
    [qword_100219F60 WFLog:@"%s: app state for DPS action : %s isAnyAppInFG:%s isFTactive:%s isLatencySensitiveAppActive:%s" message:3,  "WiFiDeviceManagerGetAppState",  v5,  v7,  v8,  v6];
  }

  int v9 = v1 ^ 1;
  objc_autoreleasePoolPop(v4);
  if (v3) {
    int v10 = 0;
  }
  else {
    int v10 = 0x1000000;
  }
  int v11 = v10 | (v0 << 16);
  if (v2) {
    int v12 = 256;
  }
  else {
    int v12 = 0;
  }
  return v12 | v9 | v11;
}

void sub_1000F4820(uint64_t a1)
{
  unsigned int v2 = objc_opt_new(&OBJC_CLASS___NSMutableString);
  uint64_t v35 = a1;
  if (a1)
  {
    id v3 = +[WiFiUsageAccessPointProfile beaconsAndWPSInfo]( &OBJC_CLASS___WiFiUsageAccessPointProfile,  "beaconsAndWPSInfo");
    if ([v3 count])
    {
      -[NSMutableString appendFormat:]( v2,  "appendFormat:",  @"ApProfile and WPS info for the latest %lu BSSID this device associaed with in the past 7 days:",  [v3 count]);
      CFMutableArrayRef v4 = objc_autoreleasePoolPush();
      CFMutableArrayRef v5 = "WiFiDeviceManagerDumpToLog";
      if (qword_100219F60) {
        [qword_100219F60 WFLog:@"%s - HexDump of beacons from the latest %lu BSSID this device associated with in the past 7 days (timestamped when received by wifid):" message:3, @"WiFiDeviceManagerDumpToLog", [v3 count]];
      }
      objc_autoreleasePoolPop(v4);
      __int128 v43 = 0u;
      __int128 v44 = 0u;
      __int128 v41 = 0u;
      __int128 v42 = 0u;
      id v36 = [v3 countByEnumeratingWithState:&v41 objects:v48 count:16];
      if (v36)
      {
        uint64_t v33 = *(void *)v42;
        id v34 = v3;
        do
        {
          for (CFIndex i = 0LL; i != v36; CFIndex i = (char *)i + 1)
          {
            if (*(void *)v42 != v33) {
              objc_enumerationMutation(v3);
            }
            id v7 = *(void **)(*((void *)&v41 + 1) + 8LL * (void)i);
            id v8 = [v3 objectForKeyedSubscript:v7];
            [v7 timeIntervalSince1970];
            int v9 = v5;
            int v11 = +[NSString stringWithFormat:]( NSString,  "stringWithFormat:",  @"%s - %f: %@",  v5,  v10,  +[WiFiUsagePrivacyFilter toHEXString:length:]( WiFiUsagePrivacyFilter,  "toHEXString:length:",  objc_msgSend(objc_msgSend(v8, "beacon"), "bytes"),  objc_msgSend(objc_msgSend(v8, "beacon"), "length")));
            if (os_log_type_enabled((os_log_t)&_os_log_default, OS_LOG_TYPE_DEFAULT))
            {
              int v12 = -[NSString UTF8String]( +[NSString stringWithFormat:]( &OBJC_CLASS___NSString,  "stringWithFormat:",  @"[WiFiPolicy] %s",  -[NSString UTF8String](v11, "UTF8String")),  "UTF8String");
              *(_DWORD *)__int128 buf = 136446210;
              uint64_t v47 = v12;
              _os_log_impl( (void *)&_mh_execute_header,  (os_log_t)&_os_log_default,  OS_LOG_TYPE_DEFAULT,  "%{public}s",  buf,  0xCu);
            }

            -[v2 appendFormat:@"\n%@ '%@' %@ (%@) - " bssid:[v8 bssid] ssid:[v8 ssid] apProfile_shortID:[v8 apProfile_shortID] apProfileID:[v8 apProfileID]];
            __int128 v39 = 0u;
            __int128 v40 = 0u;
            __int128 v37 = 0u;
            __int128 v38 = 0u;
            id v13 = objc_msgSend(objc_msgSend(v8, "apProfileWPSInfo"), "allKeys");
            id v14 = [v13 countByEnumeratingWithState:&v37 objects:v45 count:16];
            if (v14)
            {
              id v15 = v14;
              uint64_t v16 = *(void *)v38;
              do
              {
                for (CFIndex j = 0LL; j != v15; CFIndex j = (char *)j + 1)
                {
                  if (*(void *)v38 != v16) {
                    objc_enumerationMutation(v13);
                  }
                  -[NSMutableString appendFormat:]( v2,  "appendFormat:",  @"%@=%@ ",  *(void *)(*((void *)&v37 + 1) + 8 * (void)j),  objc_msgSend( objc_msgSend(v8, "apProfileWPSInfo"),  "objectForKeyedSubscript:",  *(void *)(*((void *)&v37 + 1) + 8 * (void)j)));
                }

                id v15 = [v13 countByEnumeratingWithState:&v37 objects:v45 count:16];
              }

              while (v15);
            }

            CFMutableArrayRef v5 = v9;
            id v3 = v34;
          }

          id v36 = [v34 countByEnumeratingWithState:&v41 objects:v48 count:16];
        }

        while (v36);
      }

      CFBooleanRef v18 = +[NSString stringWithFormat:](&OBJC_CLASS___NSString, "stringWithFormat:", @"%s - %@", v5, v2);
      if (os_log_type_enabled((os_log_t)&_os_log_default, OS_LOG_TYPE_DEFAULT))
      {
        uint64_t v19 = -[NSString UTF8String]( +[NSString stringWithFormat:]( &OBJC_CLASS___NSString,  "stringWithFormat:",  @"[WiFiPolicy] %s",  -[NSString UTF8String](v18, "UTF8String")),  "UTF8String");
        *(_DWORD *)__int128 buf = 136446210;
        uint64_t v47 = v19;
        _os_log_impl( (void *)&_mh_execute_header,  (os_log_t)&_os_log_default,  OS_LOG_TYPE_DEFAULT,  "%{public}s",  buf,  0xCu);
      }
    }

    else
    {
      id v20 = objc_autoreleasePoolPush();
      if (qword_100219F60) {
        objc_msgSend( (id)qword_100219F60,  "WFLog:message:",  3,  "%s -  HexDump of beacon from the latest AP we associated with (beacon captures shotly after association)",  "WiFiDeviceManagerDumpToLog");
      }
      objc_autoreleasePoolPop(v20);
      if (*(_DWORD *)(v35 + 1200)) {
        goto LABEL_26;
      }
      uint64_t v22 = *(unsigned int *)(v35 + 1204);
      if ((_DWORD)v22)
      {
        int v23 = 0;
        id v24 = (unsigned __int8 *)(v35 + 1208);
        unint64_t v25 = v35 + 1208 + v22;
        do
        {
          uint64_t v26 = 0xA2E2E2E2E2E2ELL;
          qword_1002199F8 = v26;
          __int128 v27 = (char *)&qword_1002199F8 + 7;
          while (1)
          {
            int v28 = v23;
            if ((v23 & 0xF) == 0)
            {
              int v29 = snprintf(v27, (char *)&dword_100219DF8 - v27, "%04X ", v23);
              else {
                __int128 v27 = (char *)&dword_100219DF8;
              }
            }

            int v30 = snprintf(v27, (char *)&dword_100219DF8 - v27, "%02X ", *v24);
            else {
              __int128 v27 = (char *)&dword_100219DF8;
            }
            if ((++v23 & 0xF) == 0 && v27 < (char *)&unk_100219DF7)
            {
              *v27++ = 10;
            }
          }

          ++v24;
LABEL_48:
          CFNumberRef v31 = (char *)((char *)&qword_1002199F8 - v27 + 1024);
          else {
            snprintf(v27, (size_t)v31, "......");
          }
          unsigned int v32 = objc_autoreleasePoolPush();
          int v23 = v28 + 1;
          if (qword_100219F60) {
            objc_msgSend( (id)qword_100219F60,  "WFLog:message:",  3,  "%s OtaSystemInfo bytes printed:%d of %d\n%s",  "__RawBeaconHexDumpToDLOG",  (v28 + 1),  *(unsigned int *)(v35 + 1204),  &qword_1002199F8);
          }
          objc_autoreleasePoolPop(v32);
        }

        while ((unint64_t)v24 < v25);
        if (*(_DWORD *)(v35 + 1200))
        {
LABEL_26:
          CFTypeID v21 = objc_autoreleasePoolPush();
          if (qword_100219F60) {
            [qword_100219F60 WFLog:@"%s - beacon content from latest AP not available" message:@"WiFiDeviceManagerDumpToLog"];
          }
          objc_autoreleasePoolPop(v21);
        }
      }
    }
  }
}

uint64_t sub_1000F4E5C(uint64_t result, char a2)
{
  *(_BYTE *)(result + 8772) = a2;
  return result;
}

void sub_1000F4E68(uint64_t a1, uint64_t a2)
{
  if (a1)
  {
    if (a2)
    {
      CFMutableDictionaryRef Mutable = CFDictionaryCreateMutable( kCFAllocatorDefault,  0LL,  &kCFTypeDictionaryKeyCallBacks,  &kCFTypeDictionaryValueCallBacks);
      if (Mutable)
      {
        CFMutableArrayRef v5 = Mutable;
        CFNumberRef v6 = CFNumberCreate(kCFAllocatorDefault, kCFNumberShortType, (const void *)a2);
        CFNumberRef v7 = CFNumberCreate(kCFAllocatorDefault, kCFNumberShortType, (const void *)(a2 + 1));
        CFNumberRef v8 = CFNumberCreate(kCFAllocatorDefault, kCFNumberLongType, (const void *)(a2 + 4));
        CFNumberRef v9 = CFNumberCreate(kCFAllocatorDefault, kCFNumberIntType, (const void *)(a2 + 8));
        CFDictionarySetValue(v5, @"APPLE80211KEY_MWS_WIFI_CRITICAL", v6);
        CFDictionarySetValue(v5, @"APPLE80211KEY_MWS_WIFI_CRITICAL_TYPE", v7);
        CFDictionarySetValue(v5, @"APPLE80211KEY_MWS_WIFI_CRITICAL_DURATION", v8);
        CFDictionarySetValue(v5, @"APPLE80211KEY_MWS_WIFI_CRITICAL_RESERVED", v9);
        uint64_t v10 = objc_autoreleasePoolPush();
        if (qword_100219F60) {
          [qword_100219F60 WFLog:@"%s: WiFiDeviceSetProperty(APPLE80211KEY_MWS_WIFI_CRITICAL_PARAM)\n" message:3];
        }
        objc_autoreleasePoolPop(v10);
        uint64_t v11 = *(void *)(a1 + 64);
        int v12 = (const void *)sub_100043E8C(v11);
        sub_1000447A8(v11, v12, @"APPLE80211KEY_MWS_WIFI_CRITICAL_PARAM", (uint64_t)v5);
        CFRelease(v5);
        if (v6) {
          CFRelease(v6);
        }
        if (v7) {
          CFRelease(v7);
        }
        if (v8) {
          CFRelease(v8);
        }
        if (v9) {
          CFRelease(v9);
        }
      }
    }
  }

void sub_1000F5030(uint64_t a1, int a2)
{
  unint64_t v13 = 0xAAAAAAAAAAAAAAAALL;
  int v14 = -1431655766;
  if (a1)
  {
    BOOL v4 = a2 != 0;
    *(_BYTE *)(a1 + 3260) = a2 != 0;
    CFMutableArrayRef v5 = objc_autoreleasePoolPush();
    if (qword_100219F60) {
      objc_msgSend( (id)qword_100219F60,  "WFLog:message:",  3,  "%s: manager->state.sideKickAsserted set to %d",  "WiFiDeviceManagerSideKick",  *(unsigned __int8 *)(a1 + 3260));
    }
    objc_autoreleasePoolPop(v5);
    sub_100053C44(*(void *)(a1 + 64), a2);
    if (a2) {
      int v6 = 1450;
    }
    else {
      int v6 = 0;
    }
    HIDWORD(v13) = v6;
    LOWORD(v14) = 0;
    LOBYTE(v13) = v4;
    BYTE1(v13) = 2;
    sub_1000F4E68(a1, (uint64_t)&v13);
    double Current = CFAbsoluteTimeGetCurrent();
    if (a2)
    {
      *(double *)(a1 + 1064) = Current;
    }

    else
    {
      *(double *)(a1 + 1072) = Current;
      double v9 = Current - *(double *)(a1 + 1064);
      if (v9 <= 0.0)
      {
        int v12 = objc_autoreleasePoolPush();
        if (qword_100219F60) {
          objc_msgSend( (id)qword_100219F60,  "WFLog:message:",  4,  "%s: why WiFi Sidekick critical session exit time %f ms is earlier than entry time %f ms?",  "WiFiDeviceManagerSubmitSidekickMetrics",  *(void *)(a1 + 1072),  *(void *)(a1 + 1064));
        }
        objc_autoreleasePoolPop(v12);
      }

      else
      {
        uint64_t v10 = (v9 * 1000.0);
        unsigned int v15 = (v9 * 1000.0);
        uint64_t v11 = objc_autoreleasePoolPush();
        if (qword_100219F60) {
          objc_msgSend( (id)qword_100219F60,  "WFLog:message:",  3,  "%s: WiFi Sidekick critical duration is %u ms",  "WiFiDeviceManagerSubmitSidekickMetrics",  v10);
        }
        objc_autoreleasePoolPop(v11);
        sub_100039000(&v15);
      }
    }
  }

  else
  {
    CFNumberRef v8 = objc_autoreleasePoolPush();
    if (qword_100219F60) {
      [qword_100219F60 WFLog:@"WiFiDeviceManagerRef is NULL, aborting..."];
    }
    objc_autoreleasePoolPop(v8);
  }

uint64_t sub_1000F5204(uint64_t result, uint64_t a2)
{
  *(void *)(result + 6744) = a2;
  return result;
}

uint64_t sub_1000F520C(uint64_t result, uint64_t a2, uint64_t a3)
{
  *(void *)(result + 476_Block_object_dispose((const void *)(v9 - 48), 8) = a2;
  *(void *)(result + 4776) = a3;
  return result;
}

void sub_1000F5218(uint64_t a1, uint64_t a2)
{
  uint64_t v4 = *(void *)(a1 + 424);
  CFMutableArrayRef v5 = objc_autoreleasePoolPush();
  if (v4)
  {
    if (qword_100219F60) {
      [(id)qword_100219F60 WFLog:3, "%s(): CATS Update %@: Enter deviceManager:%p  source:%d enable:%d appPolicy:%d bitmap:0x%llx\n", "WifiDeviceManagerCatsUpdateEvent", sub_1000F5D98(a1), a1, a2, *(unsigned __int8 *)(a1 + 433), *(unsigned __int8 *)(a1 + 435), *(void *)(a1 + 440) message];
    }
    objc_autoreleasePoolPop(v5);
    if (*(_BYTE *)(a1 + 433))
    {
      uint64_t v6 = *(void *)(a1 + 424);
      uint64_t v7 = *(unsigned __int8 *)(a1 + 435);
      uint64_t v8 = *(void *)(a1 + 440);
      int v9 = *(unsigned __int8 *)(a1 + 434);
      uint64_t v57 = v8;
      int v58 = v9;
      if ((_DWORD)a2 == 8)
      {
        uint64_t v10 = 0LL;
        uint64_t v11 = 0LL;
        int v12 = (_BYTE *)0xAAAAAAAAAAAAAAAALL;
        unsigned __int8 v13 = -86;
        char v54 = -86;
      }

      else
      {
        if (*(_BYTE *)(a1 + 5488)
          || *(_BYTE *)(a1 + 3402)
          || *(_BYTE *)(a1 + 5490)
          || -[WiFiUserInteractionMonitor isRealTimeAppActive]( +[WiFiUserInteractionMonitor sharedInstance](&OBJC_CLASS___WiFiUserInteractionMonitor, "sharedInstance"),  "isRealTimeAppActive"))
        {
          uint64_t v14 = sub_100111848((_BYTE *)a1);
          uint64_t v10 = v14;
          if (v9) {
            char v15 = 0;
          }
          else {
            char v15 = -86;
          }
          unint64_t v16 = 0xAAAAAAAAAAAAAAAALL;
          if (v9) {
            unint64_t v16 = v14;
          }
          unint64_t v55 = v16;
          unsigned int v17 = 1;
        }

        else
        {
          uint64_t v10 = 0LL;
          unsigned int v17 = 0;
          unint64_t v55 = 0xAAAAAAAAAAAAAAAALL;
          char v15 = -86;
        }

        CFBooleanRef v18 = objc_autoreleasePoolPush();
        uint64_t v19 = (void *)qword_100219F60;
        if (qword_100219F60)
        {
          uint64_t v20 = *(void *)(a1 + 64);
          if (v20) {
            uint64_t v20 = sub_10004CE2C(v20);
          }
          [v19 WFLog:3, "%s: CATSUpdate %@: fgApp:%@ b=0x%llx rc=%d\n", "WiFiDeviceManagerCatsSetLowLatencyApp", v20, *(void *)(a1 + 448), v10, v17 message];
        }

        objc_autoreleasePoolPop(v18);
        if ((v17 & 1) != 0)
        {
          uint64_t v11 = 2LL;
          char v54 = -86;
          uint64_t v8 = v57;
          unsigned __int8 v13 = v15;
        }

        else
        {
          unsigned int v21 = -[WiFiUserInteractionMonitor isInHomeScreen]( +[WiFiUserInteractionMonitor sharedInstance]( &OBJC_CLASS___WiFiUserInteractionMonitor,  "sharedInstance"),  "isInHomeScreen");
          unsigned int v22 = v21;
          uint64_t v23 = *(unsigned __int8 *)(a1 + 456);
          if (*(_BYTE *)(a1 + 456)) {
            uint64_t v24 = v21 ^ 1;
          }
          else {
            uint64_t v24 = 0LL;
          }
          if (v58) {
            char v25 = 1;
          }
          else {
            char v25 = v15;
          }
          char v52 = v25;
          if (v58) {
            char v26 = v21;
          }
          else {
            char v26 = -86;
          }
          char v54 = v26;
          __int128 v27 = objc_autoreleasePoolPush();
          int v28 = (void *)qword_100219F60;
          if (qword_100219F60)
          {
            uint64_t v29 = *(void *)(a1 + 64);
            if (v29) {
              uint64_t v29 = sub_10004CE2C(v29);
            }
            [v28 WFLog:3, "%s: CATSUpdate %@: fgApp:%@ hs=%d t=%d wl=%d rc=%d\n", "WiFiDeviceManagerCatsSetForegroundApp", v29, *(void *)(a1 + 448), v22, 1, v23, v24 message];
          }

          objc_autoreleasePoolPop(v27);
          uint64_t v10 = 0LL;
          if ((v24 & 1) != 0)
          {
            uint64_t v11 = 1LL;
            unsigned __int8 v13 = v52;
          }

          else
          {
            uint64_t v11 = 0LL;
            if (v58) {
              unsigned __int8 v13 = 2;
            }
            else {
              unsigned __int8 v13 = v15;
            }
            char v54 = -86;
          }

          uint64_t v8 = v57;
        }

        int v12 = (_BYTE *)v55;
      }

      BOOL v30 = (_DWORD)v7 == (_DWORD)v11 && v8 == v10;
      uint64_t v31 = !v30;
      uint64_t v56 = v31;
      if (v30)
      {
LABEL_81:
        if (v58)
        {
          if (a2 >= 9u)
          {
            __int128 v44 = objc_autoreleasePoolPush();
            if (qword_100219F60) {
              [qword_100219F60 WFLog:@"%s: CATS Stats invalid AppPolicy(%d) or Notify source (%d)\n" message:4];
            }
            goto LABEL_100;
          }

          ++*(_DWORD *)(a1 + 652);
          if ((v56 & 1) != 0)
          {
            ++*(_DWORD *)(a1 + 544);
            ++*(_DWORD *)(a1 + 544 + 4LL * v11 + 4);
            ++*(_DWORD *)(a1 + 564);
            uint64_t v45 = (_DWORD *)(a1 + 564 + 4LL * a2 + 4);
          }

          else
          {
            uint64_t v45 = (_DWORD *)(a1 + 656);
          }

          ++*v45;
          if ((_DWORD)v11 == 1)
          {
            if (v13 == 1)
            {
              ++*(_DWORD *)(a1 + 652);
              ++*(_DWORD *)(a1 + 608);
              if (v54) {
                ++*(_DWORD *)(a1 + 616);
              }
              ++*(_DWORD *)(a1 + 612);
              goto LABEL_101;
            }

            __int128 v44 = objc_autoreleasePoolPush();
            id v46 = (void *)qword_100219F60;
            if (!qword_100219F60) {
              goto LABEL_100;
            }
            uint64_t v47 = "WifiDeviceManagerCatsFgAppActivityStats";
            uint64_t v48 = v13;
            goto LABEL_99;
          }

          if ((_DWORD)v11 == 2)
          {
            if (!v13)
            {
              ++*(_DWORD *)(a1 + 620);
              if ((*v12 & 2) != 0)
              {
                ++*(_DWORD *)(a1 + 628);
              }

              else if ((*v12 & 4) != 0)
              {
                ++*(_DWORD *)(a1 + 632);
              }

              else if ((v12[1] & 1) != 0)
              {
                ++*(_DWORD *)(a1 + 640);
              }

              else if ((v12[4] & 1) != 0)
              {
                ++*(_DWORD *)(a1 + 644);
              }

              else if ((*v12 & 0x10) != 0 || (v12[2] & 1) != 0)
              {
                ++*(_DWORD *)(a1 + 636);
              }

              else
              {
                ++*(_DWORD *)(a1 + 624);
              }

              goto LABEL_101;
            }

            __int128 v44 = objc_autoreleasePoolPush();
            id v46 = (void *)qword_100219F60;
            if (!qword_100219F60) {
              goto LABEL_100;
            }
            uint64_t v47 = "WifiDeviceManagerCatsLowLatencyEventStats";
            uint64_t v48 = v13;
LABEL_99:
            objc_msgSend(v46, "WFLog:message:", 4, "%s: CATS Stats Invalid Report type (%d)  \n", v47, v48, v51);
LABEL_100:
            objc_autoreleasePoolPop(v44);
          }
        }

LABEL_101:
        uint64_t v49 = objc_autoreleasePoolPush();
        if (qword_100219F60) {
          [(id)qword_100219F60 WFLog:3, "%s: CATSUpdate %@: Exit deviceManager=%p Source:%d stateChange:%d (P:%d-->%d B:0x%llx-->0x%llx)\n", "WifiDeviceManagerCatsUpdateEvent", sub_1000F5D98(a1), a1, a2, v56, v7, v11, v57, v10 message];
        }
        objc_autoreleasePoolPop(v49);
        return;
      }

      if (v6)
      {
        if (*(unsigned __int8 *)(a1 + 464) < 4u)
        {
          unsigned __int8 v53 = v13;
          char valuePtr = v11;
          uint64_t v59 = v10;
          CFMutableDictionaryRef Mutable = CFDictionaryCreateMutable( 0LL,  0LL,  &kCFTypeDictionaryKeyCallBacks,  &kCFTypeDictionaryValueCallBacks);
          if (Mutable)
          {
            id v34 = Mutable;
            CFNumberRef v35 = CFNumberCreate(kCFAllocatorDefault, kCFNumberCharType, &valuePtr);
            if (v35)
            {
              CFNumberRef v36 = v35;
              CFNumberRef v37 = CFNumberCreate(kCFAllocatorDefault, kCFNumberLongLongType, &v59);
              if (v37)
              {
                CFNumberRef v38 = v37;
                CFDictionarySetValue(v34, @"CATS_APP_PRIORITY", v36);
                CFDictionarySetValue(v34, @"CATS_APP_BITMAP", v38);
                CFRelease(v36);
                CFRelease(v38);
                unsigned int v39 = *(unsigned __int8 *)(a1 + 464);
                if (*(_BYTE *)(a1 + 464))
                {
                  unint64_t v40 = 0LL;
                  __int128 v41 = (void (**)(uint64_t, uint64_t, __CFDictionary *, void))(a1 + 488);
                  do
                  {
                    if (*v41)
                    {
                      (*v41)(v6, a1, v34, *(v41 - 2));
                      unsigned int v39 = *(unsigned __int8 *)(a1 + 464);
                    }

                    ++v40;
                    v41 += 3;
                  }

                  while (v40 < v39);
                }

                CFRelease(v34);
                unsigned __int8 v13 = v53;
                goto LABEL_80;
              }

              CFRelease(v34);
              CFRelease(v36);
              __int128 v43 = objc_autoreleasePoolPush();
              if (qword_100219F60) {
                [qword_100219F60 WFLog:@"%s:CATSUpdate deviceManager:0x%p CATSUpdate not allocate app bitmap CATS dictionary entry" message:4];
              }
            }

            else
            {
              CFRelease(v34);
              __int128 v43 = objc_autoreleasePoolPush();
              if (qword_100219F60) {
                [qword_100219F60 WFLog:@"%s:CATSUpdate deviceManager:0x%p CATSUpdate not allocate app policy CATS dictionary entry" message:4];
              }
            }

            objc_autoreleasePoolPop(v43);
          }

          else
          {
            __int128 v42 = objc_autoreleasePoolPush();
            if (qword_100219F60) {
              [qword_100219F60 WFLog:@"%s:CATSUpdate deviceManager:0x%p CATSUpdate not allocate CATS dictionary" message:4];
            }
            objc_autoreleasePoolPop(v42);
          }

          unsigned __int8 v13 = v53;
          unsigned int v32 = objc_autoreleasePoolPush();
          if (qword_100219F60) {
            [qword_100219F60 WFLog:@"%s:CATSUpdate deviceManager:%p CATS Update not allocate CATS dictionary" message:4];
          }
        }

        else
        {
          unsigned int v32 = objc_autoreleasePoolPush();
          if (qword_100219F60) {
            objc_msgSend( (id)qword_100219F60,  "WFLog:message:",  4,  "%s: CATS Update Clients: Num Clients(%d) > Max Clients(%d)",  "WifiDeviceManagerCatsUpdateClients",  *(unsigned __int8 *)(a1 + 464),  3);
          }
        }
      }

      else
      {
        unsigned int v32 = objc_autoreleasePoolPush();
        if (qword_100219F60) {
          [qword_100219F60 WFLog:@"%s: CATS Update Clients: Invalid arguments" message:4 v50 v51];
        }
      }

      objc_autoreleasePoolPop(v32);
LABEL_80:
      *(_BYTE *)(a1 + 435) = v11;
      *(void *)(a1 + 440) = v10;
      goto LABEL_81;
    }
  }

  else
  {
    if (qword_100219F60) {
      [(id)qword_100219F60 WFLog:3, "%s: CATS %@: Update Invalid deviceManager args device=%p deviceManager:%p WifiManager:%p Enab:%d\n", "WifiDeviceManagerCatsUpdateEvent", sub_1000F5D98(a1), *(void *)(a1 + 64), a1, *(void *)(a1 + 424), *(unsigned __int8 *)(a1 + 433) message];
    }
    objc_autoreleasePoolPop(v5);
  }

            CFRelease(Mutable);
            goto LABEL_102;
          }
        }

        else
        {
          uint64_t v50 = sub_1001036C0(a1, (const __CFArray *)v34, v32, 0, 7LL);
          CFArrayAppendValue(*(CFMutableArrayRef *)(a1 + 1160), v34);
          uint64_t v51 = cf;
          if (!cf) {
            goto LABEL_91;
          }
        }

        CFRelease(v51);
        goto LABEL_91;
      }

      unsigned __int8 v53 = objc_autoreleasePoolPush();
      if (qword_100219F60) {
        [qword_100219F60 WFLog:@"Autojoin reset hidden index %ld, hiddenCount %d as all directed networks scanned for matching security" message:3];
      }
      objc_autoreleasePoolPop(v53);
      *(void *)(a1 + 1136) = 0LL;
LABEL_100:
      char v54 = 12LL;
      unint64_t v55 = 1;
      if (!Mutable) {
        goto LABEL_102;
      }
      goto LABEL_101;
    }

    if (v21)
    {
      if (sub_100095B4C((uint64_t)v21))
      {
        __int128 v27 = @"EAP";
LABEL_66:
        [v26 WFLog:3, "Autojoin looking for %@ hidden network, so skipping - %@", v27, Mutable message];
        goto LABEL_67;
      }

      if (sub_100096E90((uint64_t)v21))
      {
        __int128 v27 = @"WPA";
        goto LABEL_66;
      }

      if (sub_1000957F4((BOOL)v21))
      {
        __int128 v27 = @"WEP";
        goto LABEL_66;
      }

      if (sub_100096D08((const __CFDictionary *)v21))
      {
        __int128 v27 = @"SAE";
        goto LABEL_66;
      }
    }

    __int128 v27 = @"OPEN";
    goto LABEL_66;
  }

  for (CFIndex j = *(void *)(a1 + 1112); j < CFArrayGetCount(*(CFArrayRef *)(a1 + 1104)); ++j)
  {
    unsigned int v17 = (void *)CFArrayGetValueAtIndex(*(CFArrayRef *)(a1 + 1104), *(void *)(a1 + 1112));
    if (!sub_100097264(v17))
    {
      if (CFStringGetLength(Mutable))
      {
        BOOL v30 = objc_autoreleasePoolPush();
        if (qword_100219F60) {
          [(id)qword_100219F60 WFLog:3, "Autojoin is processing network %ld of %ld candidates, skipped candidate - %@", *(void *)(a1 + 1112) + 1, v15, Mutable message];
        }
        objc_autoreleasePoolPop(v30);
      }

      goto LABEL_100;
    }

    if (Mutable) {
      sub_100106504(a1, v17, Mutable);
    }
    ++*(void *)(a1 + 1112);
  }

  CFBooleanRef v18 = *(void *)(a1 + 1112);
  CFIndex Length = CFStringGetLength(Mutable);
  if (v18 < v15)
  {
    if (Length)
    {
      uint64_t v20 = objc_autoreleasePoolPush();
      if (qword_100219F60) {
        [(id)qword_100219F60 WFLog:3, "Autojoin is processing network %ld of %ld candidates, skipped candidates - %@", *(void *)(a1 + 1112) + 1, v15, Mutable message];
      }
      objc_autoreleasePoolPop(v20);
    }

    goto LABEL_34;
  }

  if (Length)
  {
    int v28 = objc_autoreleasePoolPush();
    if (qword_100219F60) {
      [(id)qword_100219F60 WFLog:3, "Autojoin completed processing %ld candidates, skipped candidates - %@", *(void *)(a1 + 1112) + 1, Mutable message];
    }
    objc_autoreleasePoolPop(v28);
  }

  if (Mutable) {
    CFRelease(Mutable);
  }
  return sub_10010824C(a1);
}

void sub_1000F5A40(uint64_t a1, uint64_t a2)
{
  uint64_t v4 = objc_autoreleasePoolPush();
  if (qword_100219F60) {
    [(id)qword_100219F60 WFLog:3, "%s: CATSInit %@: Enter device:%p deviceManager:%p manager:%p", "WifiDeviceManagerCatsInit", sub_1000F5D98(a1), *(void *)(a1 + 64), a1, a2 message];
  }
  objc_autoreleasePoolPop(v4);
  if (a1 && a2)
  {
    *(void *)(a1 + 424) = a2;
    *(_BYTE *)(a1 + 435) = 0;
    *(_BYTE *)(a1 + 464) = 0;
    *(_WORD *)(a1 + 433) = 0;
    *(void *)(a1 + 440) = 0LL;
    *(void *)(a1 + 44_Block_object_dispose((const void *)(v9 - 48), 8) = 0LL;
    CFMutableArrayRef v5 = (const __CFString *)sub_100043E8C(*(void *)(a1 + 64));
    uint64_t v6 = (const __CFString *)sub_10004CE2C(*(void *)(a1 + 64));
    BOOL v7 = 0;
    if (v5 && v6) {
      BOOL v7 = CFStringCompare(v5, v6, 0LL) == kCFCompareEqualTo;
    }
    uint64_t v8 = objc_autoreleasePoolPush();
    int v9 = (void *)qword_100219F60;
    if (qword_100219F60)
    {
      uint64_t v10 = *(void *)(a1 + 64);
      if (v10) {
        uint64_t v10 = sub_10004CE2C(v10);
      }
      [v9 WFLog:3, "%s: CATS %@: Trace deviceManager:%p rc=%d\n", "WifiDeviceManagerCatsIsMainInterface", v10, a1, v7 message];
    }

    objc_autoreleasePoolPop(v8);
    *(_BYTE *)(a1 + 432) = v7;
    if (v7)
    {
      sub_1000F5E14(a1, 0LL);
      if ((sub_100112B30(a1 + 424, 0, (uint64_t)sub_100112C94) & 0x80000000) != 0)
      {
        uint64_t v11 = objc_autoreleasePoolPush();
        if (qword_100219F60) {
          [qword_100219F60 WFLog:@"%s: CATS Error registering P2P callback\n" message:3];
        }
        objc_autoreleasePoolPop(v11);
      }

      if ((sub_100112B30(a1 + 424, 1, (uint64_t)sub_1001130B0) & 0x80000000) != 0)
      {
        int v12 = objc_autoreleasePoolPush();
        if (qword_100219F60) {
          [qword_100219F60 WFLog:@"%s: CATS Error registering UCM callback\n" message:3];
        }
        objc_autoreleasePoolPop(v12);
      }

      if ((sub_100112B30(a1 + 424, 2, (uint64_t)sub_1001131B0) & 0x80000000) != 0)
      {
        unsigned __int8 v13 = objc_autoreleasePoolPush();
        if (qword_100219F60) {
          [qword_100219F60 WFLog:@"%s: CATS Error registering Scan Manager callback\n" message:3];
        }
        objc_autoreleasePoolPop(v13);
      }

      if (_os_feature_enabled_impl("WiFiManager", "CATS"))
      {
        uint64_t v14 = objc_autoreleasePoolPush();
        if (qword_100219F60) {
          [(id)qword_100219F60 WFLog:3, "%s: CATS %@: Enable Trace deviceManager:%p\n", "WifiDeviceManagerEnableCats", sub_1000F5D98(a1), a1 message];
        }
        objc_autoreleasePoolPop(v14);
        if (!*(_BYTE *)(a1 + 433) && *(_BYTE *)(a1 + 432))
        {
          *(_BYTE *)(a1 + 433) = 1;
          sub_1000F5218(a1, 7LL);
        }
      }
    }

    char v15 = objc_autoreleasePoolPush();
    unint64_t v16 = (void *)qword_100219F60;
    if (qword_100219F60)
    {
      uint64_t v17 = *(void *)(a1 + 64);
      if (v17)
      {
        uint64_t v18 = sub_10004CE2C(v17);
        uint64_t v19 = *(void *)(a1 + 64);
      }

      else
      {
        uint64_t v19 = 0LL;
        uint64_t v18 = 0LL;
      }

      [v16 WFLog:3, "%s: CATSInit %@: Exit: device:%p deviceManager:%p manager:%p m:%d en:%d\n", "WifiDeviceManagerCatsInit", v18, v19, a1, a2, *(unsigned __int8 *)(a1 + 432), _os_feature_enabled_impl("WiFiManager", "CATS") message];
    }
  }

  else
  {
    char v15 = objc_autoreleasePoolPush();
    if (qword_100219F60) {
      [qword_100219F60 WFLog:@"%s: CATSInit Invalid deviceManager or manager handle" message:4 v20 v21 v22 v23 v24 v25];
    }
  }

  objc_autoreleasePoolPop(v15);
}

uint64_t sub_1000F5D98(uint64_t a1)
{
  if (a1)
  {
    uint64_t v1 = *(void *)(a1 + 64);
    if (v1) {
      return sub_10004CE2C(v1);
    }
  }

  else
  {
    id v3 = objc_autoreleasePoolPush();
    if (qword_100219F60) {
      [qword_100219F60 WFLog:@"%s: CATSUpdate Invalid arguments" message:4];
    }
    objc_autoreleasePoolPop(v3);
  }

  return 0LL;
}

BOOL sub_1000F5E14(uint64_t a1, CFTypeRef cf)
{
  int v4 = cf != 0LL;
  int v5 = *(unsigned __int8 *)(a1 + 456);
  uint64_t v6 = *(const void **)(a1 + 448);
  if (v6)
  {
    CFRelease(v6);
    *(void *)(a1 + 44_Block_object_dispose((const void *)(v9 - 48), 8) = 0LL;
  }

  if (cf)
  {
    CFTypeRef v7 = CFRetain(cf);
  }

  else
  {
    CFTypeRef v7 = 0LL;
    int v4 = 0;
  }

  *(void *)(a1 + 44_Block_object_dispose((const void *)(v9 - 48), 8) = v7;
  *(_BYTE *)(a1 + 456) = v4;
  uint64_t v8 = objc_autoreleasePoolPush();
  if (qword_100219F60) {
    [(id)qword_100219F60 WFLog:3, "%s: CATS %@:  deviceManager:%p FgApp:%@ stateChange:%d whitelisted=%d\n", "WifiDeviceManagerCatsWhitelistedApp", sub_1000F5D98(a1), a1, *(void *)(a1 + 448), v5 != v4, cf != 0 message];
  }
  objc_autoreleasePoolPop(v8);
  return v5 != v4;
}

void sub_1000F5F00(uint64_t a1)
{
  if (a1 && *(_BYTE *)(a1 + 432))
  {
    uint64_t v1 = objc_autoreleasePoolPush();
    if (qword_100219F60) {
      [qword_100219F60 WFLog:@"message: CATS Trace: DeInit Enter\n"];
    }
  }

  else
  {
    uint64_t v1 = objc_autoreleasePoolPush();
    if (qword_100219F60) {
      [qword_100219F60 WFLog:@"%s: CATSDeInit Invalid deviceManager info" message:4];
    }
  }

  objc_autoreleasePoolPop(v1);
}

void sub_1000F5F98(uint64_t a1, unint64_t a2)
{
  uint64_t v55 = 0LL;
  uint64_t v56 = &v55;
  uint64_t v57 = 0x3052000000LL;
  int v58 = sub_1000F3F84;
  uint64_t v59 = sub_1000F3F94;
  uint64_t v60 = 0LL;
  char context = objc_autoreleasePoolPush();
  int v4 = objc_autoreleasePoolPush();
  if (qword_100219F60) {
    [qword_100219F60 WFLog:@"AUTO-JOIN: Triggered (trigger=%d)" message:3, "%s: AUTO-JOIN: Triggered (trigger=%d)", "WiFiDeviceManagerStartAutoJoinAndReply", a2];
  }
  objc_autoreleasePoolPop(v4);
  if ((_os_feature_enabled_impl("CoreWiFi", "UnifiedAutoJoin") & 1) == 0)
  {
    uint64_t v49 = objc_autoreleasePoolPush();
    if (qword_100219F60) {
      [qword_100219F60 WFLog:@"UAJM feature is disabled" message:@"WiFiDeviceManagerStartAutoJoinAndReply"];
    }
    goto LABEL_98;
  }

  if (!a1)
  {
    uint64_t v49 = objc_autoreleasePoolPush();
    if (qword_100219F60) {
      [qword_100219F60 WFLog:@"WiFiDeviceManagerStartAutoJoinAndReply: manager is null"];
    }
    goto LABEL_98;
  }

  if (!*(void *)(a1 + 8776))
  {
    uint64_t v49 = objc_autoreleasePoolPush();
    if (qword_100219F60) {
      [qword_100219F60 WFLog:@"%s: UAJM is null" message:4];
    }
    goto LABEL_98;
  }

  sub_100043E8C(*(void *)(a1 + 64));
  if (*(_DWORD *)(a1 + 20) != 1)
  {
    uint64_t v49 = objc_autoreleasePoolPush();
    if (qword_100219F60) {
      [qword_100219F60 WFLog:@"WiFi is OFF"];
    }
LABEL_98:
    objc_autoreleasePoolPop(v49);
    CFMutableDictionaryRef Mutable = 0LL;
    goto LABEL_77;
  }

  CFMutableDictionaryRef Mutable = CFArrayCreateMutable(kCFAllocatorDefault, 0LL, &kCFTypeArrayCallBacks);
  if (!Mutable) {
    goto LABEL_77;
  }
  uint64_t v6 = *(void *)(a1 + 64);
  CFTypeRef v7 = (const void *)sub_100043E8C(v6);
  uint64_t v8 = sub_100044EB0(v6, v7, Mutable);
  if ((_DWORD)v8)
  {
    uint64_t v50 = objc_autoreleasePoolPush();
    if (qword_100219F60) {
      [qword_100219F60 WFLog:@"%s: FAILED to get supported channels (err=%d)" message:4, "%s: FAILED to get supported channels (err=%d)", "WiFiDeviceManagerStartAutoJoinAndReply", v8];
    }
    goto LABEL_103;
  }

  if (!CFArrayGetCount(Mutable))
  {
    uint64_t v50 = objc_autoreleasePoolPush();
    if (qword_100219F60) {
      [qword_100219F60 WFLog:@"%s: Supported channels list is empty" message:@"WiFiDeviceManagerStartAutoJoinAndReply"];
    }
LABEL_103:
    objc_autoreleasePoolPop(v50);
    goto LABEL_77;
  }

  id v9 = +[NSMutableArray array](&OBJC_CLASS___NSMutableArray, "array");
  for (CFIndex i = 0LL; i < CFArrayGetCount(Mutable); ++i)
  {
    ValueAtIndex = (const __CFDictionary *)CFArrayGetValueAtIndex(Mutable, i);
    if (ValueAtIndex)
    {
      id v12 = objc_alloc_init(&OBJC_CLASS___CWFChannel);
      [v12 setChannel:[((id)CFDictionaryGetValue(ValueAtIndex, @"SUP_CHANNEL")) unsignedIntegerValue]];
      [v12 setFlags:[[(id)CFDictionaryGetValue(ValueAtIndex, @"SUP_CHANNEL_FLAGS") unsignedIntegerValue]];
      [v9 addObject:v12];
    }
  }

  if ([v9 count]) {
    objc_msgSend( *(id *)(a1 + 8776),  "setSupportedChannels:",  +[NSMutableSet setWithArray:](NSMutableSet, "setWithArray:", v9));
  }
  id v13 = sub_1000E359C(a1);
  uint64_t v14 = *(void **)(a1 + 8776);
  if (v13)
  {
    [v14 setLocation:v13];
  }

  else
  {
    [v14 setLocation:0];
  }

  sub_1000FEEF8(a1);
  id v15 = objc_alloc_init(&OBJC_CLASS___CWFAutoJoinParameters);
  [v15 setMode:1];
  [v15 setTrigger:a2];
  if (*(_DWORD *)(a1 + 5512) != 1 && !*(_BYTE *)(a1 + 5496))
  {
    if (*(_BYTE *)(a1 + 8773) && *(void *)(a1 + 8752))
    {
      id v23 = objc_alloc_init(&OBJC_CLASS___CWFChannel);
      [v23 setChannel:[*(id *)(a1 + 8752) unsignedIntegerValue]];
      [v23 setFlags:[*(id *)(a1 + 8760) unsignedIntValue]];
      id v63 = v23;
      uint64_t v24 = +[NSArray arrayWithObjects:count:](&OBJC_CLASS___NSArray, "arrayWithObjects:count:", &v63, 1LL);
    }

    else
    {
      if (a2 != 55)
      {
LABEL_34:
        uint64_t v22 = 0LL;
        goto LABEL_37;
      }

      id v25 = objc_alloc_init(&OBJC_CLASS___CWFChannel);
      [v25 setChannel:*(unsigned int *)(a1 + 3832)];
      [v25 setFlags:*(unsigned int *)(a1 + 3836)];
      id v62 = v25;
      uint64_t v24 = +[NSArray arrayWithObjects:count:](&OBJC_CLASS___NSArray, "arrayWithObjects:count:", &v62, 1LL);
    }

    uint64_t v22 = v24;
    goto LABEL_37;
  }

  id v16 = objc_msgSend(objc_msgSend(*(id *)(a1 + 8776), "knownNetworks"), "anyObject");
  uint64_t v17 = sub_1000A1DEC(v16, 0LL);
  uint64_t v18 = v17;
  if (!v17) {
    goto LABEL_34;
  }
  uint64_t v19 = (void *)sub_1000951FC((uint64_t)v17, @"CHANNEL");
  if (v19)
  {
    id v20 = objc_alloc_init(&OBJC_CLASS___CWFChannel);
    [v20 setChannel:[v19 unsignedIntegerValue]];
    unsigned int v21 = sub_1000992D0((uint64_t)v18) - 1;
    if (v21 < 3) {
      [v20 setFlags:dword_10017FB94[v21]];
    }
    id v64 = v20;
    uint64_t v22 = +[NSArray arrayWithObjects:count:](&OBJC_CLASS___NSArray, "arrayWithObjects:count:", &v64, 1LL);
  }

  else
  {
    uint64_t v22 = 0LL;
  }

  CFRelease(v18);
LABEL_37:
  [v15 setPreferredChannels:v22];
  if (a2 == 7
    || a2 == 2 && ((uint64_t v26 = *(void *)(a1 + 3504)) == 0 || !sub_10009DF44(v26) || !*(_BYTE *)(a1 + 984)))
  {
    __int128 v27 = (CFDictionaryRef *)sub_1000D91B0(a1, *(const void **)(a1 + 3504), 0);
    int v28 = v27;
    if (v27)
    {
      uint64_t v29 = sub_1000A063C(v27);
      if (v29)
      {
        if (sub_100097700((uint64_t)v28)
          && (sub_1000951FC((uint64_t)v28, @"WiFiInstantHotspotJoining") == kCFBooleanTrue
           || sub_1000951FC((uint64_t)v28, @"WiFiAutoInstantHotspotJoining") == kCFBooleanTrue))
        {
          BOOL v30 = (const __CFNumber *)sub_1000951FC((uint64_t)v28, @"lastDisconnectReasonKey");
          if (v30)
          {
            uint64_t v31 = (const __CFDate *)sub_1000951FC((uint64_t)v28, @"lastDisconnectTimestampKey");
            if (v31)
            {
              unsigned int valuePtr = -1431655766;
              CFNumberGetValue(v30, kCFNumberIntType, &valuePtr);
              if (valuePtr <= 2)
              {
                double Current = CFAbsoluteTimeGetCurrent();
                if (Current - CFDateGetAbsoluteTime(v31) < 300.0)
                {
                  uint64_t v33 = objc_autoreleasePoolPush();
                  id v34 = v33;
                  if (qword_100219F60)
                  {
                    char v52 = v33;
                    CFNumberRef v35 = sub_100095BC8(v28);
                    uint64_t v36 = valuePtr;
                    double v37 = CFAbsoluteTimeGetCurrent();
                    CFNumberRef v38 = +[NSString stringWithFormat:]( &OBJC_CLASS___NSString,  "stringWithFormat:",  @"%s",  -[NSString UTF8String]( +[NSString stringWithFormat:]( &OBJC_CLASS___NSString,  "stringWithFormat:",  @"{%@*} %@",  @"AUTOJOIN",  +[NSString stringWithFormat:]( &OBJC_CLASS___NSString,  "stringWithFormat:",  @"%s Previous Hotspot %@ disconnect reason %d time since linkDown %.1f",  "__WiFiDeviceManagerUnifiedAutoJoinForceDirectedScanForAutoHotspotLinkDownRecovery",  v35,  v36,  v37 - CFDateGetAbsoluteTime(v31))),  "UTF8String"));
                    BOOL v39 = os_log_type_enabled((os_log_t)&_os_log_default, OS_LOG_TYPE_DEFAULT);
                    id v34 = v52;
                    if (v39)
                    {
                      unint64_t v40 = -[NSString UTF8String]( +[NSString stringWithFormat:]( &OBJC_CLASS___NSString,  "stringWithFormat:",  @"[WiFiPolicy] %s",  -[NSString UTF8String](v38, "UTF8String")),  "UTF8String");
                      *(_DWORD *)__int128 buf = 136446210;
                      BOOL v66 = v40;
                      _os_log_impl( (void *)&_mh_execute_header,  (os_log_t)&_os_log_default,  OS_LOG_TYPE_DEFAULT,  "%{public}s",  buf,  0xCu);
                      id v34 = v52;
                    }
                  }

                  objc_autoreleasePoolPop(v34);
                  [v29 setHiddenState:1];
                }
              }
            }
          }
        }

        [v15 setTargetNetworkProfile:v29];
      }

      CFRelease(v28);
    }
  }

  if (*(_BYTE *)(a1 + 3406))
  {
    uint64_t v41 = 4LL;
    goto LABEL_59;
  }

  if (a2 > 0x37 || ((1LL << a2) & 0xC0000100000084LL) == 0)
  {
    if (*(_DWORD *)(a1 + 176) != 3
      && (a2 > 0x3A || ((1LL << a2) & 0x630048F1C000200LL) == 0)
      && !CWFIsAutoJoinRetryTrigger(a2))
    {
LABEL_60:
      if (a2 == 39) {
        *(_BYTE *)(a1 + 6600) = 1;
      }
      goto LABEL_64;
    }

    uint64_t v41 = 2LL;
LABEL_59:
    [v15 setMode:v41];
    goto LABEL_60;
  }

void sub_1000F6AF8( _Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, ...)
{
}

void sub_1000F6B50(void *a1, void *a2, uint64_t a3)
{
  uint64_t v6 = objc_autoreleasePoolPush();
  if ([a2 mode])
  {
    uint64_t v7 = sub_10003AFF4((uint64_t)"WiFiDeviceManagerStartAutoJoinWithParams");
    CFRetain(a1);
    uint64_t v8 = (void *)a1[1097];
    v9[0] = _NSConcreteStackBlock;
    v9[1] = 3221225472LL;
    v9[2] = sub_1000F6C1C;
    void v9[3] = &unk_1001E4D88;
    void v9[5] = a3;
    v9[6] = a1;
    v9[4] = v7;
    [v8 performAutoJoinWithParameters:a2 reply:v9];
  }

  else
  {
    sub_1000F5F98((uint64_t)a1, (unint64_t)[a2 trigger]);
  }

  objc_autoreleasePoolPop(v6);
}

void sub_1000F6C1C(uint64_t a1, uint64_t a2)
{
  int v4 = objc_autoreleasePoolPush();
  uint64_t v5 = *(void *)(a1 + 40);
  if (v5) {
    (*(void (**)(uint64_t, uint64_t))(v5 + 16))(v5, a2);
  }
  CFRelease(*(CFTypeRef *)(a1 + 48));

  objc_autoreleasePoolPop(v4);
}

id sub_1000F6C74(uint64_t a1, uint64_t a2)
{
  *(void *)(a1 + 8840) = a2;
  return sub_1000F6C7C(a1);
}

id sub_1000F6C7C(uint64_t a1)
{
  uint64_t v2 = *(void *)(a1 + 8840);
  if (v2 != 5)
  {
    id v3 = (const void *)sub_100043E8C(*(void *)(a1 + 64));
    int v4 = sub_1000DEA34(a1, v3, 1);
    if (v4)
    {
      uint64_t v5 = v4;
      if (sub_100097700((uint64_t)v4))
      {
        uint64_t v2 = 4LL;
      }

      else if (sub_10009CF04((uint64_t)v5))
      {
        uint64_t v2 = 4LL;
      }

      else
      {
        uint64_t v2 = 3LL;
      }

      CFRelease(v5);
    }
  }

  return [*(id *)(a1 + 8776) setRetrySchedule:v2];
}

void sub_1000F6D00(const __CFDictionary *a1, const __CFDictionary *a2)
{
  if (a1 && a2)
  {
    if (sub_100097FF4((uint64_t)a2)
      && sub_100098058((uint64_t)a2)
      && !CFDictionaryGetValue(a1, @"RSN_IE"))
    {
      sub_10009582C((uint64_t)a2, @"RSN_IE", 0LL);
      int v4 = objc_autoreleasePoolPush();
      if (qword_100219F60) {
        [qword_100219F60 WFLog:@"message:3" messageFormat:@"%s WPA1 only network but WPA2 property is existing in network profile. Removing WPA2 property for association" message: @"WiFiDeviceManagerAdjustSecurityTypeForKnownNetwork"];
      }
      objc_autoreleasePoolPop(v4);
    }

    if (sub_1000957F4((BOOL)a2)
      && sub_100095B4C((uint64_t)a2)
      && !CFDictionaryGetValue(a1, @"RSN_IE")
      && !CFDictionaryGetValue(a1, @"WPA_IE"))
    {
      sub_10009582C((uint64_t)a2, @"RSN_IE", 0LL);
      sub_10009582C((uint64_t)a2, @"WPA_IE", 0LL);
      uint64_t v5 = objc_autoreleasePoolPush();
      if (qword_100219F60) {
        [qword_100219F60 WFLog:@"message: %s Dynamic WEP but WPA property is existing in network profile. Removing WPA property for association "];
      }
      objc_autoreleasePoolPop(v5);
    }

    if (sub_1000957F4((BOOL)a2)
      && sub_100097FF4((uint64_t)a2)
      && !CFDictionaryGetValue(a1, @"WPA_IE"))
    {
      sub_10009582C((uint64_t)a2, @"WPA_IE", 0LL);
      uint64_t v6 = objc_autoreleasePoolPush();
      if (qword_100219F60) {
        [qword_100219F60 WFLog:@"message: %s WEP only but WPA property is existing in network profile. Removing WPA property for association " message:@"WiFiDeviceManagerAdjustSecurityTypeForKnownNetwork"];
      }
      objc_autoreleasePoolPop(v6);
    }

    if (sub_100095B4C((uint64_t)a2)
      && CFDictionaryGetValue(a1, @"WPA_IE")
      && !CFDictionaryGetValue(a1, @"RSN_IE"))
    {
      sub_10009582C((uint64_t)a2, @"RSN_IE", 0LL);
      uint64_t v7 = objc_autoreleasePoolPush();
      if (qword_100219F60) {
        [qword_100219F60 WFLog:@"message: %s WPA1 only enterprise network but WPA2 property is existing in network profile. Removing WPA2 property for association "];
      }
      objc_autoreleasePoolPop(v7);
    }

    if (sub_100097FF4((uint64_t)a2)
      && sub_100098058((uint64_t)a2)
      && sub_100096D08(a2)
      && !CFDictionaryGetValue(a1, @"WPA_IE"))
    {
      sub_10009582C((uint64_t)a2, @"WPA_IE", 0LL);
      uint64_t v8 = objc_autoreleasePoolPush();
      if (qword_100219F60) {
        [qword_100219F60 WFLog:@"message:3" messageFormat:@"%s WPA3 transition network but WPA1 property is existing in network profile. Removing WPA1 property for association " messageArguments:@"WiFiDeviceManagerAdjustSecurityTypeForKnownNetwork"];
      }
      objc_autoreleasePoolPop(v8);
    }
  }

id sub_1000F6FF0(uint64_t a1)
{
  return objc_msgSend(objc_msgSend(*(id *)(a1 + 8776), "metric"), "copy");
}

id sub_1000F7008(uint64_t a1)
{
  return objc_msgSend(objc_msgSend(*(id *)(a1 + 8776), "statistics"), "copy");
}

id sub_1000F7020(uint64_t a1)
{
  return [*(id *)(a1 + 8776) resetStatistics];
}

void sub_1000F7028(uint64_t a1, int a2)
{
}

void sub_1000F7030(uint64_t a1, int a2)
{
}

void sub_1000F7038(uint64_t a1, int a2)
{
  int v4 = objc_autoreleasePoolPush();
  if (qword_100219F60)
  {
    uint64_t v5 = "allowing";
    if (!a2) {
      uint64_t v5 = "disallowing";
    }
    [qword_100219F60 WFLog:@"WiFiDeviceManagerAllowPowerSaveMode power save"];
  }

  objc_autoreleasePoolPop(v4);
  sub_100053B30(*(void *)(a1 + 64), a2);
}

uint64_t sub_1000F70C4(uint64_t a1)
{
  if (a1) {
    return 0LL;
  }
  uint64_t v2 = objc_autoreleasePoolPush();
  if (qword_100219F60) {
    [qword_100219F60 WFLog:@"%s: NULL Device Manager !" message:4];
  }
  objc_autoreleasePoolPop(v2);
  return 4294963396LL;
}

void sub_1000F7130(uint64_t a1, int a2)
{
  if (a1)
  {
    *(_BYTE *)(a1 + 3457) = a2;
    int v4 = objc_autoreleasePoolPush();
    if (qword_100219F60)
    {
      uint64_t v5 = "TRUE";
      if (!a2) {
        uint64_t v5 = "FALSE";
      }
      [qword_100219F60 WFLog:@"%s: isOutrankedByCellular=%s" message:3,  "%s: isOutrankedByCellular=%s",  "WiFiDeviceManagerSetSymptomsCellOutrankRecommendation",  v5];
    }

    objc_autoreleasePoolPop(v4);
    uint64_t v6 = *(void **)(a1 + 7320);
    uint64_t v7 = sub_100043E8C(*(void *)(a1 + 64));
    [v6 setCellularOutrankingState:a2 != 0 forInterface:v7];
  }

  else
  {
    uint64_t v8 = objc_autoreleasePoolPush();
    if (qword_100219F60) {
      [qword_100219F60 WFLog:@"%s: null manager" message:4];
    }
    objc_autoreleasePoolPop(v8);
  }

void sub_1000F7228(uint64_t a1, uint64_t a2)
{
  int v4 = objc_autoreleasePoolPush();
  if (a1)
  {
    if (qword_100219F60) {
      [(id)qword_100219F60 WFLog:3, "%s: networkQualityDict=%@", "WiFiDeviceManagerNotifyNetworkQualityResults", a2 message];
    }
    objc_autoreleasePoolPop(v4);
    uint64_t v5 = *(void **)(a1 + 7320);
    uint64_t v6 = sub_100043E8C(*(void *)(a1 + 64));
    [v5 notifyNetworkQualityResults:a2 forInterface:v6];
  }

  else
  {
    if (qword_100219F60) {
      [qword_100219F60 WFLog:@"%s: null manager" message:4];
    }
    objc_autoreleasePoolPop(v4);
  }

void sub_1000F72E8(uint64_t a1, const __CFDictionary *a2)
{
  if (!a1)
  {
    uint64_t v33 = objc_autoreleasePoolPush();
    if (qword_100219F60) {
      [qword_100219F60 WFLog:@"WiFiDeviceManagerProcessBSPCommand manager is NULL"];
    }
    objc_autoreleasePoolPop(v33);
    return;
  }

  int v4 = objc_autoreleasePoolPush();
  if (!a2)
  {
    if (qword_100219F60) {
      [qword_100219F60 WFLog:@"dict is NULL" message:4];
    }
    objc_autoreleasePoolPop(v4);
    return;
  }

  if (qword_100219F60) {
    [(id)qword_100219F60 WFLog:3, "%s:%d BSPCommand Dictionary %@", "WiFiDeviceManagerProcessBSPCommand", 45608, a2 message];
  }
  objc_autoreleasePoolPop(v4);
  uint64_t valuePtr = 0LL;
  CFBooleanRef Value = (const __CFNumber *)CFDictionaryGetValue(a2, @"BSP_CommandType");
  if (!Value) {
    return;
  }
  CFNumberGetValue(Value, kCFNumberLongLongType, &valuePtr);
  if (valuePtr != 2)
  {
    if (valuePtr == 4)
    {
      uint64_t v6 = CFDictionaryGetValue(a2, @"BSP_CommandParams");
      uint64_t v7 = *(void *)(a1 + 64);
      uint64_t v8 = (const void *)sub_100043E8C(v7);
      sub_1000447A8(v7, v8, @"BSP_CommandParams", (uint64_t)v6);
    }

    return;
  }

  CFMutableStringRef Mutable = CFStringCreateMutable(kCFAllocatorDefault, 0LL);
  if (!Mutable)
  {
    id v34 = objc_autoreleasePoolPush();
    if (qword_100219F60) {
      [qword_100219F60 WFLog:@"%s cannot create countryCodeRef" message:4];
    }
    objc_autoreleasePoolPop(v34);
    return;
  }

  CFMutableStringRef v10 = Mutable;
  if (sub_100050388(*(void *)(a1 + 64), (uint64_t)Mutable))
  {
    CFNumberRef v35 = objc_autoreleasePoolPush();
    if (qword_100219F60) {
      [qword_100219F60 WFLog:@"%s cannot get countryCode" message:4];
    }
    goto LABEL_63;
  }

  CFMutableDictionaryRef v11 = CFDictionaryCreateMutable(0LL, 0LL, &kCFTypeDictionaryKeyCallBacks, &kCFTypeDictionaryValueCallBacks);
  if (!v11)
  {
    CFNumberRef v35 = objc_autoreleasePoolPush();
    if (qword_100219F60) {
      [qword_100219F60 WFLog:@"cannot allocate dictRef" message:4];
    }
LABEL_63:
    objc_autoreleasePoolPop(v35);
    unsigned int v32 = v10;
    goto LABEL_48;
  }

  id v12 = v11;
  uint64_t v40 = 3LL;
  CFNumberRef v13 = CFNumberCreate(kCFAllocatorDefault, kCFNumberLongLongType, &v40);
  if (!v13)
  {
    uint64_t v36 = objc_autoreleasePoolPush();
    if (qword_100219F60) {
      [qword_100219F60 WFLog:@"cannot allocate eventTypeRef" message:4];
    }
    goto LABEL_68;
  }

  CFDictionarySetValue(v12, @"BSP_EventType", v13);
  CFMutableDictionaryRef v14 = CFDictionaryCreateMutable(0LL, 0LL, &kCFTypeDictionaryKeyCallBacks, &kCFTypeDictionaryValueCallBacks);
  if (!v14)
  {
    uint64_t v36 = objc_autoreleasePoolPush();
    if (qword_100219F60) {
      [qword_100219F60 WFLog:@"%s:cannot allocate eventParamsRef" message:4];
    }
LABEL_68:
    id v15 = 0LL;
    goto LABEL_71;
  }

  id v15 = v14;
  int v39 = 0;
  uint64_t v38 = 1LL;
  CFMutableArrayRef v16 = CFArrayCreateMutable(kCFAllocatorDefault, 0LL, &kCFTypeArrayCallBacks);
  if (v16)
  {
    uint64_t v17 = v16;
    uint64_t v18 = *(void *)(a1 + 64);
    uint64_t v19 = (const void *)sub_100043E8C(v18);
    uint64_t v20 = sub_1000450F8(v18, v19, v17);
    if ((_DWORD)v20)
    {
      uint64_t v21 = v20;
      uint64_t v22 = objc_autoreleasePoolPush();
      if (qword_100219F60) {
        [qword_100219F60 WFLog:@"%s: Device return error %d for supported channels" message:4];
      }
      goto LABEL_18;
    }

    if (CFArrayGetCount(v17) < 1)
    {
      uint64_t v25 = 1LL;
LABEL_37:
      uint64_t v29 = objc_autoreleasePoolPush();
      if (qword_100219F60) {
        [(id)qword_100219F60 WFLog:3, "%s:%d countryCode=%@, regulatoryInfo = 0x%llx", "__WiFiDeviceManagerSendBSPRegulatoryInfo", 45587, v10, v25 message];
      }
      objc_autoreleasePoolPop(v29);
      CFNumberRef v30 = CFNumberCreate(kCFAllocatorDefault, kCFNumberLongLongType, &v38);
      if (v30)
      {
        CFNumberRef v23 = v30;
        CFDictionarySetValue(v15, @"BSP_RegulatoryInfo", v30);
        CFDictionarySetValue(v12, @"BSP_EventParams", v15);
        uint64_t v31 = sub_10004CE2C(*(void *)(a1 + 64));
        sub_1000C4E14(v31, v31, a1, v12);
        goto LABEL_41;
      }

      uint64_t v22 = objc_autoreleasePoolPush();
      if (qword_100219F60) {
        [qword_100219F60 WFLog:@"cannot allocate regulatoryInfoRef" message:4];
      }
LABEL_18:
      objc_autoreleasePoolPop(v22);
      CFNumberRef v23 = 0LL;
LABEL_41:
      CFRelease(v17);
      goto LABEL_42;
    }

    CFIndex v24 = 0LL;
    uint64_t v25 = 1LL;
    while (1)
    {
      ValueAtIndex = (const __CFDictionary *)CFArrayGetValueAtIndex(v17, v24);
      if (ValueAtIndex)
      {
        __int128 v27 = (const __CFNumber *)CFDictionaryGetValue(ValueAtIndex, @"SUP_CHANNEL");
        if (v27)
        {
          if (CFNumberGetValue(v27, kCFNumberSInt32Type, &v39))
          {
            if ((v39 - 50) >= 0xFFFFFFF2)
            {
              v25 |= 2uLL;
            }

            else
            {
              BOOL v28 = (v39 - 166) >= 0xFFFFFFE8 || v39 == 138;
              v25 |= 0x10uLL;
            }

            uint64_t v38 = v25;
          }
        }
      }

uint64_t sub_1000F7890(uint64_t a1)
{
  uint64_t v2 = objc_autoreleasePoolPush();
  if (qword_100219F60) {
    [qword_100219F60 WFLog:@"Sending link status %d" message:3];
  }
  objc_autoreleasePoolPop(v2);
  return *(unsigned __int8 *)(a1 + 3441);
}

NSMutableDictionary *sub_1000F78F0(uint64_t a1)
{
  uint64_t v2 = objc_autoreleasePoolPush();
  id v3 = objc_alloc_init(&OBJC_CLASS___NSMutableDictionary);
  if (*(void *)(a1 + 8928))
  {
    int v4 = objc_alloc_init(&OBJC_CLASS___NSMutableDictionary);
    if ([*(id *)(a1 + 8928) status]) {
      uint64_t v5 = @"Settled";
    }
    else {
      uint64_t v5 = @"Unsettled";
    }
    -[NSMutableDictionary setObject:forKey:](v4, "setObject:forKey:", v5, @"description");
    -[NSMutableDictionary setObject:forKey:]( v4,  "setObject:forKey:",  +[NSNumber numberWithInteger:]( NSNumber,  "numberWithInteger:",  [*(id *)(a1 + 8928) status]),  @"status");
    -[NSMutableDictionary setObject:forKey:]( v4,  "setObject:forKey:",  +[NSNumber numberWithUnsignedInteger:]( NSNumber,  "numberWithUnsignedInteger:",  [*(id *)(a1 + 8928) confidence]),  @"confidence");
    if ([*(id *)(a1 + 8928) settledDate]) {
      -[NSMutableDictionary setObject:forKey:]( v4,  "setObject:forKey:",  [*(id *)(a1 + 8928) settledDate],  @"date");
    }
    -[NSMutableDictionary setObject:forKey:](v3, "setObject:forKey:", v4, @"settlement");
  }

  uint64_t v6 = objc_alloc_init(&OBJC_CLASS___NSMutableDictionary);
  -[NSMutableDictionary setObject:forKey:]( v6,  "setObject:forKey:",  +[NSNumber numberWithUnsignedInt:](&OBJC_CLASS___NSNumber, "numberWithUnsignedInt:", *(unsigned int *)(a1 + 3344)),  @"state");
  -[NSMutableDictionary setObject:forKey:]( v6,  "setObject:forKey:",  +[NSDate dateWithTimeIntervalSinceReferenceDate:]( &OBJC_CLASS___NSDate,  "dateWithTimeIntervalSinceReferenceDate:",  *(double *)(a1 + 3352)),  @"startTime");
  -[NSMutableDictionary setObject:forKey:]( v6,  "setObject:forKey:",  sub_10008FDAC(*(_DWORD *)(a1 + 3344)),  @"description");
  -[NSMutableDictionary setObject:forKey:]( v6,  "setObject:forKey:",  +[NSNumber numberWithBool:]( &OBJC_CLASS___NSNumber,  "numberWithBool:",  -[WiFiUserInteractionMonitor isCarModeActive]( +[WiFiUserInteractionMonitor sharedInstance](&OBJC_CLASS___WiFiUserInteractionMonitor, "sharedInstance"),  "isCarModeActive")),  @"carMode");
  -[NSMutableDictionary setObject:forKey:](v3, "setObject:forKey:", v6, @"motion");

  id v7 = sub_1000E359C(a1);
  if (v7)
  {
    uint64_t v8 = v7;
    id v9 = objc_alloc_init(&OBJC_CLASS___NSMutableDictionary);
    uint64_t v13 = 0LL;
    CFMutableStringRef v10 = +[NSKeyedArchiver archivedDataWithRootObject:requiringSecureCoding:error:]( &OBJC_CLASS___NSKeyedArchiver,  "archivedDataWithRootObject:requiringSecureCoding:error:",  v8,  1LL,  &v13);
    if (v13)
    {
      CFMutableDictionaryRef v11 = objc_autoreleasePoolPush();
      if (qword_100219F60) {
        [qword_100219F60 WFLog:@"%s: failed to encode location" message:4];
      }
      objc_autoreleasePoolPop(v11);
    }

    else
    {
      -[NSMutableDictionary setObject:forKey:](v9, "setObject:forKey:", v10, @"location");
    }

    -[NSMutableDictionary setObject:forKey:](v3, "setObject:forKey:", v9, @"location");
  }

  objc_autoreleasePoolPop(v2);
  return v3;
}

uint64_t sub_1000F7B98(uint64_t a1)
{
  uint64_t v2 = (unsigned __int8 *)(a1 + 5488);
  if ((sub_1000E01D4((unsigned __int8 *)a1) & 1) == 0
    && *v2 != 1
    && v2[1] != 1
    && v2[2] != 1
    && v2[3] != 1
    && (!sub_1000E0348(a1) || !sub_1000DF3D8(a1))
    && *(_BYTE *)(a1 + 3406) != 1
    && !sub_1000E0424(a1)
    && !sub_1000E0480(a1))
  {
    return 1LL;
  }

  id v3 = objc_autoreleasePoolPush();
  if (qword_100219F60) {
    objc_msgSend( (id)qword_100219F60,  "WFLog:message:",  3,  "Rejecting sensing: isSensing:%d carplay:%d faceTime:%d airplayOverInfra:%d coPresence:%d isCharging:%d userMode:%d\n",  sub_1000E01D4((unsigned __int8 *)a1),  *v2,  v2[1],  v2[2],  v2[3],  *(unsigned __int8 *)(a1 + 3456),  *(unsigned int *)(a1 + 176));
  }
  objc_autoreleasePoolPop(v3);
  int v4 = objc_autoreleasePoolPush();
  uint64_t v5 = (void *)qword_100219F60;
  if (qword_100219F60)
  {
    unsigned int v6 = sub_1000E0348(a1);
    unsigned int v7 = sub_1000DF3D8(a1);
    uint64_t v8 = *(unsigned __int8 *)(a1 + 3406);
    BOOL v9 = sub_1000E0424(a1);
    objc_msgSend( v5,  "WFLog:message:",  3,  "Rejecting sensing: AWDLEnabled:%d AssistedDiscHostedNetwork:%d RealTimeMode:%d MISScanBlocked:%d AutoJoinBusy:%d\n",  v6,  v7,  v8,  v9,  sub_1000E0480(a1));
  }

  objc_autoreleasePoolPop(v4);
  return 0LL;
}

uint64_t sub_1000F7D3C(uint64_t a1, uint64_t a2, const __CFData *a3)
{
  uint64_t result = 4294963396LL;
  if (a1 && a2 && a3)
  {
    else {
      return 4294963389LL;
    }
  }

  return result;
}

uint64_t sub_1000F7DA4( uint64_t a1, const void *a2, void *a3, void (*a4)(uint64_t, const void *, void, uint64_t, uint64_t), uint64_t a5)
{
  uint64_t v54 = 0LL;
  uint64_t v55 = &v54;
  uint64_t v56 = 0x2020000000LL;
  unint64_t v57 = 0xAAAAAAAAAAAAAAAALL;
  uint64_t v50 = 0LL;
  uint64_t v51 = &v50;
  uint64_t v52 = 0x2020000000LL;
  unint64_t v53 = 0xAAAAAAAAAAAAAAAALL;
  if ((MGGetBoolAnswer(@"InternalBuild") & 1) == 0
    || !_os_feature_enabled_impl("WiFiManager", "Sensing")
    || !sub_100055514(*(void *)(a1 + 64)))
  {
    char v9 = 0;
    uint64_t v10 = 4294963389LL;
    goto LABEL_37;
  }

  char v9 = 0;
  uint64_t v10 = 4294963396LL;
  if (a2 && a3)
  {
    uint64_t v11 = sub_1000558E8(*(void *)(a1 + 64));
    uint64_t v12 = sub_1000558F4(*(void *)(a1 + 64));
    uint64_t v13 = objc_autoreleasePoolPush();
    if (qword_100219F60) {
      [(id)qword_100219F60 WFLog:3, "%s: ifName: %@ numReportsRem: %d, expectedTotalReports: %d, sensingParams: %@", "WiFiDeviceManagerSensingEnableAsync", a2, v11, v12, a3 message];
    }
    objc_autoreleasePoolPop(v13);
    if (v11 | v12)
    {
      char v9 = 0;
      uint64_t v10 = 37LL;
      goto LABEL_37;
    }

    id v14 = [a3 objectForKeyedSubscript:@"SENSING_PARAMS_SCHEDULE_ONCE_AFTER"];
    int v15 = [v14 intValue];
    id v16 = [a3 objectForKeyedSubscript:@"SENSING_PARAMS_SCHEDULE_DAILY_AT"];
    id v17 = [v16 intValue];
    id v18 = [a3 objectForKeyedSubscript:@"SENSING_PARAMS_NUMBER_OF_REPORTS"];
    signed int v19 = [v18 intValue];
    v55[3] = v19;
    signed int v20 = [v18 intValue];
    char v9 = 0;
    v51[3] = v20;
    if (v14)
    {
      uint64_t v10 = 0LL;
      if (v15 == -2) {
        goto LABEL_22;
      }
      if (!v55[3]) {
        goto LABEL_21;
      }
      uint64_t v21 = malloc(0x20uLL);
      *(void *)uint64_t v21 = a1;
      *((void *)v21 + 1) = a4;
      *((void *)v21 + 2) = CFRetain(a3);
      *((void *)v21 + 3) = a5;
      uint64_t v22 = *(dispatch_source_s **)(a1 + 8936);
      if (v22)
      {
        dispatch_source_cancel(v22);
        dispatch_release(*(dispatch_object_t *)(a1 + 8936));
        *(void *)(a1 + 8936) = 0LL;
      }

      if (v15 >= 1)
      {
        *(void *)(a1 + 8936) = dispatch_source_create( (dispatch_source_type_t)&_dispatch_source_type_timer,  0LL,  0LL,  *(dispatch_queue_t *)(a1 + 240));
        CFRetain(a2);
        CFRetain(a3);
        CFNumberRef v23 = *(dispatch_source_s **)(a1 + 8936);
        handler[0] = _NSConcreteStackBlock;
        handler[1] = 3221225472LL;
        handler[2] = sub_1000F849C;
        handler[3] = &unk_1001E4DB0;
        handler[4] = &v54;
        handler[5] = a1;
        handler[6] = a2;
        handler[7] = a3;
        handler[8] = v21;
        dispatch_source_set_event_handler(v23, handler);
        CFIndex v24 = *(dispatch_source_s **)(a1 + 8936);
        dispatch_time_t v25 = dispatch_time(0LL, 1000000000LL * v15);
        dispatch_source_set_timer(v24, v25, 0xFFFFFFFFFFFFFFFFLL, 0LL);
        dispatch_activate(*(dispatch_object_t *)(a1 + 8936));
        uint64_t v10 = 0LL;
        goto LABEL_16;
      }

      if (v15)
      {
LABEL_21:
        char v9 = 0;
        uint64_t v10 = 0LL;
LABEL_22:
        if (!v16) {
          goto LABEL_37;
        }
        goto LABEL_23;
      }

      sub_1000558CC(*(void *)(a1 + 64));
      uint64_t v42 = v55[3];
      v55[3] = v42 - 1;
      sub_1000558DC(*(void *)(a1 + 64), v42 - 1);
      int v43 = objc_alloc_init(&OBJC_CLASS___NSDateFormatter);
      -[NSDateFormatter setDateFormat:](v43, "setDateFormat:", @"yyyy/MM/dd hh:mm:ss:SSS");
      -[NSDateFormatter setTimeZone:]( v43,  "setTimeZone:",  +[NSTimeZone localTimeZone](&OBJC_CLASS___NSTimeZone, "localTimeZone"));
      if (sub_1000F7B98(a1))
      {
        uint64_t v10 = sub_100055520(*(void *)(a1 + 64), a2, a3, (uint64_t)sub_1000F8668, (uint64_t)v21);
        char context = objc_autoreleasePoolPush();
        if (qword_100219F60)
        {
          __int128 v44 = "failed to start";
          if (!(_DWORD)v10) {
            __int128 v44 = "started";
          }
          [(id)qword_100219F60 WFLog:3, "%s: One-time sensing data read %s (err: %d) (reads rem: %ld) [%@]", "WiFiDeviceManagerSensingEnableAsync", v44, v10, v55[3], -[NSDateFormatter stringFromDate:](v43, "stringFromDate:", +[NSDate date](NSDate, "date")) message];
        }

        objc_autoreleasePoolPop(context);
      }

      else
      {
        uint64_t v45 = objc_autoreleasePoolPush();
        if (qword_100219F60) {
          [qword_100219F60 WFLog:@"%s: rejecting sensing due to on-going high priority event\n" message:@"WiFiDeviceManagerSensingEnableAsync"];
        }
        objc_autoreleasePoolPop(v45);
        uint64_t v10 = 16LL;
      }

      if (!(_DWORD)v10)
      {
LABEL_16:
        char v9 = 1;
        if (!v16) {
          goto LABEL_37;
        }
        goto LABEL_23;
      }

      sub_1000558DC(*(void *)(a1 + 64), 0);
      CFRelease(*((CFTypeRef *)v21 + 2));
      free(v21);
      char v9 = 0;
      if (!v16) {
        goto LABEL_37;
      }
    }

    else
    {
      uint64_t v10 = 0LL;
      if (!v16) {
        goto LABEL_37;
      }
    }

void sub_1000F8458(_Unwind_Exception *a1)
{
}

void sub_1000F849C(uint64_t a1)
{
  uint64_t v2 = *(void *)(a1 + 40);
  --*(void *)(*(void *)(*(void *)(a1 + 32) + 8LL) + 24LL);
  sub_1000558DC(*(void *)(v2 + 64), *(_DWORD *)(*(void *)(*(void *)(a1 + 32) + 8LL) + 24LL));
  id v3 = objc_alloc_init(&OBJC_CLASS___NSDateFormatter);
  -[NSDateFormatter setDateFormat:](v3, "setDateFormat:", @"yyyy/MM/dd hh:mm:ss:SSS");
  -[NSDateFormatter setTimeZone:]( v3,  "setTimeZone:",  +[NSTimeZone localTimeZone](&OBJC_CLASS___NSTimeZone, "localTimeZone"));
  if (!sub_1000F7B98(*(void *)(a1 + 40)))
  {
    unsigned int v7 = objc_autoreleasePoolPush();
    if (qword_100219F60) {
      [qword_100219F60 WFLog:@"%s: rejecting sensing due to on-going high priority event\n" message:@"WiFiDeviceManagerSensingEnableAsync_block_invoke"];
    }
    objc_autoreleasePoolPop(v7);

    goto LABEL_12;
  }

  uint64_t v4 = sub_100055520( *(void *)(*(void *)(a1 + 40) + 64LL),  *(const void **)(a1 + 48),  *(void **)(a1 + 56),  (uint64_t)sub_1000F8668,  *(void *)(a1 + 64));
  uint64_t v5 = objc_autoreleasePoolPush();
  if (qword_100219F60)
  {
    if ((_DWORD)v4) {
      unsigned int v6 = "failed to start";
    }
    else {
      unsigned int v6 = "started";
    }
    [(id)qword_100219F60 WFLog:3, "%s: One-time delayed sensing data read %s (err: %d) (reads rem: %ld) [%@]", "WiFiDeviceManagerSensingEnableAsync_block_invoke", v6, v4, *(void *)(*(void *)(*(void *)(a1 + 32) + 8) + 24), -[NSDateFormatter stringFromDate:](v3, "stringFromDate:", +[NSDate date](NSDate, "date")) message];
  }

  objc_autoreleasePoolPop(v5);

  if ((_DWORD)v4)
  {
LABEL_12:
    sub_1000558DC(*(void *)(*(void *)(a1 + 40) + 64LL), 0);
    CFRelease(*(CFTypeRef *)(*(void *)(a1 + 64) + 16LL));
    free(*(void **)(a1 + 64));
  }

  CFRelease(*(CFTypeRef *)(a1 + 48));
  CFRelease(*(CFTypeRef *)(a1 + 56));
}

void sub_1000F8668(uint64_t a1, const void *a2, uint64_t a3, uint64_t *a4)
{
  uint64_t v8 = (void *)a4[2];
  int v9 = sub_1000558E8(a1);
  if (!v9) {
    goto LABEL_11;
  }
  uint64_t v10 = *a4;
  sub_1000558DC(a1, v9 - 1);
  uint64_t v11 = objc_alloc_init(&OBJC_CLASS___NSDateFormatter);
  -[NSDateFormatter setDateFormat:](v11, "setDateFormat:", @"yyyy/MM/dd hh:mm:ss:SSS");
  -[NSDateFormatter setTimeZone:]( v11,  "setTimeZone:",  +[NSTimeZone localTimeZone](&OBJC_CLASS___NSTimeZone, "localTimeZone"));
  if (!sub_1000F7B98(v10))
  {
    id v14 = objc_autoreleasePoolPush();
    if (qword_100219F60) {
      [qword_100219F60 WFLog:@"%s: rejecting sensing due to on-going high priority event\n" message:3];
    }
    objc_autoreleasePoolPop(v14);

    goto LABEL_11;
  }

  uint64_t v12 = sub_100055520(a1, a2, v8, (uint64_t)sub_1000F8668, (uint64_t)a4);
  uint64_t v13 = objc_autoreleasePoolPush();
  if (qword_100219F60) {
    [qword_100219F60 WFLog:@"message:%s sensing enable event retVal[%d]\n" message:@"__WiFiDeviceManagerClientSensingCallback" retVal:v12];
  }
  objc_autoreleasePoolPop(v13);

  if ((_DWORD)v12) {
LABEL_11:
  }
    sub_100117D1C(a1, a2, a3, v8, a4);
}

void sub_1000F87F0(uint64_t a1)
{
  unsigned int v2 = objc_msgSend( objc_msgSend(*(id *)(a1 + 32), "objectForKeyedSubscript:", @"SENSING_PARAMS_COMMENT"),  "isEqualToString:",  @"automatic collection scheduled");
  uint64_t v3 = *(void *)(a1 + 48);
  if (!v2 || *(_BYTE *)(v3 + 3456))
  {
    sub_1000558CC(*(void *)(v3 + 64));
    uint64_t v4 = *(void *)(a1 + 48);
    --*(void *)(*(void *)(*(void *)(a1 + 40) + 8LL) + 24LL);
    sub_1000558DC(*(void *)(v4 + 64), *(_DWORD *)(*(void *)(*(void *)(a1 + 40) + 8LL) + 24LL));
    uint64_t v5 = objc_alloc_init(&OBJC_CLASS___NSDateFormatter);
    -[NSDateFormatter setDateFormat:](v5, "setDateFormat:", @"yyyy/MM/dd hh:mm:ss:SSS");
    -[NSDateFormatter setTimeZone:]( v5,  "setTimeZone:",  +[NSTimeZone localTimeZone](&OBJC_CLASS___NSTimeZone, "localTimeZone"));
    if (sub_1000F7B98(*(void *)(a1 + 48)))
    {
      uint64_t v6 = sub_100055520( *(void *)(*(void *)(a1 + 48) + 64LL),  *(const void **)(a1 + 56),  *(void **)(a1 + 64),  (uint64_t)sub_1000F89EC,  *(void *)(a1 + 48));
      unsigned int v7 = objc_autoreleasePoolPush();
      if (qword_100219F60)
      {
        if ((_DWORD)v6) {
          uint64_t v8 = "failed to start";
        }
        else {
          uint64_t v8 = "started";
        }
        [(id)qword_100219F60 WFLog:3, "%s: Daily sensing data read %s (err: %d) (reads rem: %ld) [%@]", "WiFiDeviceManagerSensingEnableAsync_block_invoke_2", v8, v6, *(void *)(*(void *)(*(void *)(a1 + 40) + 8) + 24), -[NSDateFormatter stringFromDate:](v5, "stringFromDate:", +[NSDate date](NSDate, "date")) message];
      }

      objc_autoreleasePoolPop(v7);

      if (!(_DWORD)v6) {
        goto LABEL_15;
      }
    }

    else
    {
      int v9 = objc_autoreleasePoolPush();
      if (qword_100219F60) {
        [qword_100219F60 WFLog:@"%s: rejecting sensing due to on-going high priority event\n" message:3];
      }
      objc_autoreleasePoolPop(v9);
    }

    sub_1000558DC(*(void *)(*(void *)(a1 + 48) + 64LL), 0);
LABEL_15:
    CFRelease(*(CFTypeRef *)(a1 + 56));
    CFRelease(*(CFTypeRef *)(a1 + 64));
  }

void sub_1000F89EC(uint64_t a1, const void *a2, uint64_t a3, uint64_t a4)
{
  uint64_t v8 = -[NSUserDefaults dictionaryForKey:]( +[NSUserDefaults standardUserDefaults](&OBJC_CLASS___NSUserDefaults, "standardUserDefaults"),  "dictionaryForKey:",  @"WIFI_SENSING");
  int v9 = sub_1000558E8(a1);
  if (!v9) {
    goto LABEL_11;
  }
  sub_1000558DC(a1, v9 - 1);
  uint64_t v10 = objc_alloc_init(&OBJC_CLASS___NSDateFormatter);
  -[NSDateFormatter setDateFormat:](v10, "setDateFormat:", @"yyyy/MM/dd hh:mm:ss:SSS");
  -[NSDateFormatter setTimeZone:]( v10,  "setTimeZone:",  +[NSTimeZone localTimeZone](&OBJC_CLASS___NSTimeZone, "localTimeZone"));
  if (!sub_1000F7B98(a4))
  {
    uint64_t v13 = objc_autoreleasePoolPush();
    if (qword_100219F60) {
      [qword_100219F60 WFLog:@"%s: rejecting sensing due to on-going high priority event\n" message:3];
    }
    objc_autoreleasePoolPop(v13);

    goto LABEL_11;
  }

  uint64_t v11 = sub_100055520(a1, a2, v8, (uint64_t)sub_1000F89EC, a4);
  uint64_t v12 = objc_autoreleasePoolPush();
  if (qword_100219F60) {
    objc_msgSend( (id)qword_100219F60,  "WFLog:message:",  3,  "%s sensing enable event retVal[%d]\n",  "__WiFiDeviceManagerSensingDailyCallback",  v11);
  }
  objc_autoreleasePoolPop(v12);

  if ((_DWORD)v11) {
LABEL_11:
  }
    sub_100117D1C(a1, a2, a3, v8, 0LL);
}

uint64_t sub_1000F8B8C(uint64_t a1, const void *a2)
{
  if (!_os_feature_enabled_impl("WiFiManager", "Sensing")
    || !sub_100055514(*(void *)(a1 + 64)))
  {
    return 4294963389LL;
  }

  uint64_t v4 = *(dispatch_source_s **)(a1 + 8936);
  if (v4)
  {
    dispatch_source_cancel(v4);
    dispatch_release(*(dispatch_object_t *)(a1 + 8936));
    *(void *)(a1 + 8936) = 0LL;
  }

  uint64_t v5 = *(dispatch_source_s **)(a1 + 8944);
  if (v5)
  {
    dispatch_source_cancel(v5);
    dispatch_release(*(dispatch_object_t *)(a1 + 8944));
    *(void *)(a1 + 8944) = 0LL;
  }

  return sub_10005571C(*(void *)(a1 + 64), a2);
}

void sub_1000F8C18(uint64_t a1, const void *a2)
{
  uint64_t v4 = objc_autoreleasePoolPush();
  uint64_t v5 = (const void *)sub_100043E8C(*(void *)(a1 + 64));
  uint64_t v6 = sub_100040538(*(void *)(a1 + 64), v5);
  unsigned int v7 = objc_autoreleasePoolPush();
  uint64_t v8 = (void *)qword_100219F60;
  if (qword_100219F60)
  {
    int v9 = sub_100095BC8(a2);
    [v8 WFLog:3, "[NWTRANSIT]: %s: topNetwork: %@, current: %@", "__WiFiDeviceManagerTransitionToColocatedNetwork", v9, sub_100095BC8(v6) message];
  }

  objc_autoreleasePoolPop(v7);
  if (v6)
  {
    if (sub_100095BC8(v6))
    {
      if (CFEqual(v6, a2))
      {
        uint64_t v10 = objc_autoreleasePoolPush();
        if (qword_100219F60) {
          [qword_100219F60 WFLog:@"[NWTRANSIT]: %s: no need for transition..." message:3];
        }
        objc_autoreleasePoolPop(v10);
      }

      else
      {
        uint64_t v11 = malloc(0x30uLL);
        v11[4] = 0LL;
        void v11[5] = 0LL;
        void *v11 = a1;
        v11[1] = sub_1001107A8;
        v11[2] = 0LL;
        void v11[3] = 0LL;
        *((_DWORD *)v11 + _Block_object_dispose((const void *)(v1 - 152), 8) = 1013;
        sub_1000E36D4(a1, v6);
        *(_BYTE *)(a1 + 3752) = 1;
        uint64_t v12 = (void *)sub_1000951FC((uint64_t)v6, @"COLOCATED_NETWORK_SCOPE_ID");
        CFNumberRef v23 = sub_1000951FC((uint64_t)a2, @"COLOCATED_NETWORK_SCOPE_ID");
        uint64_t v13 = objc_autoreleasePoolPush();
        if (qword_100219F60) {
          [(id)qword_100219F60 WFLog:3, "[NWTRANSIT]: %s: SCOPE ID for %@ = %@ ", "__WiFiDeviceManagerMatchColocatedScopeID", sub_100095BC8(v6), v12 message];
        }
        objc_autoreleasePoolPop(v13);
        id v14 = objc_autoreleasePoolPush();
        if (qword_100219F60) {
          [(id)qword_100219F60 WFLog:3, "[NWTRANSIT]: %s: SCOPE ID for %@ = %@ ", "__WiFiDeviceManagerMatchColocatedScopeID", sub_100095BC8(a2), v23 message];
        }
        objc_autoreleasePoolPop(v14);
        if (v12 && v23 && [v12 isEqualToString:v23])
        {
          int v15 = objc_autoreleasePoolPush();
          if (qword_100219F60) {
            objc_msgSend((id)qword_100219F60, "WFLog:message:", 3, "[NWTRANSIT]: SCOPE ID Matches, Debounce the Link");
          }
          objc_autoreleasePoolPop(v15);
          id v16 = objc_autoreleasePoolPush();
          if (qword_100219F60) {
            [qword_100219F60 WFLog:@"[NWTRANSIT] %s: Link down will be debounced" message:3];
          }
          objc_autoreleasePoolPop(v16);
        }

        else
        {
LABEL_23:
          id v17 = objc_autoreleasePoolPush();
          id v18 = (void *)qword_100219F60;
          if (qword_100219F60)
          {
            signed int v19 = sub_100095BC8(v6);
            [v18 WFLog:3, "[NWTRANSIT]: %s: Disconnect from '%@', attempting network transition to '%@'", "__WiFiDeviceManagerTransitionToColocatedNetwork", v19, sub_100095BC8(v6) message];
          }

          objc_autoreleasePoolPop(v17);
          signed int v20 = (const void *)sub_100043E8C(*(void *)(a1 + 64));
          sub_1000CE074(a1, v20, 1013LL, "__WiFiDeviceManagerTransitionToColocatedNetwork", 47191LL);
        }

        uint64_t v21 = sub_10004E3C4(*(void *)(a1 + 64), v5, a2, 0LL, (uint64_t)sub_1001187C0, (uint64_t)v11, 1013);
        if ((_DWORD)v21)
        {
          [+[WiFiXPCManager sharedXPCManager](WiFiXPCManager, "sharedXPCManager") associationDoneWithNetwork:a2 error:v21 interfaceName:v5];
          *(_BYTE *)(a1 + 3752) = 0;
          uint64_t v22 = (const void *)v11[3];
          if (v22) {
            CFRelease(v22);
          }
          free(v11);
        }
      }
    }

    CFRelease(v6);
  }

  objc_autoreleasePoolPop(v4);
}

void sub_1000F8F9C(uint64_t a1, const __CFDictionary *a2)
{
  int v30 = 0;
  if (!a1 || !a2) {
    goto LABEL_38;
  }
  uint64_t v4 = (const void *)sub_100043E8C(*(void *)(a1 + 64));
  CFBooleanRef Value = (const __CFArray *)CFDictionaryGetValue(a2, @"COLOCATED_NETWORK_GROUP");
  *(void *)(a1 + 372_Block_object_dispose((const void *)(v1 - 152), 8) = Value;
  if (Value) {
    CFIndex Count = CFArrayGetCount(Value);
  }
  else {
    CFIndex Count = 0LL;
  }
  unsigned int v7 = objc_autoreleasePoolPush();
  if (qword_100219F60) {
    [qword_100219F60 WFLog:@"[NWTRANSIT]: %s: Colocated Network CFIndex Count = %ld " message:3,  @"WiFiDeviceManagerSetColocatedNetworks",  Count];
  }
  objc_autoreleasePoolPop(v7);
  if (Count > 1) {
    goto LABEL_17;
  }
  int valuePtr = 2;
  CFNumberRef v8 = CFNumberCreate(kCFAllocatorDefault, kCFNumberSInt32Type, &valuePtr);
  int v9 = sub_1000ED0D0(0LL, 0LL, *(_DWORD *)(a1 + 128), 0x6Eu, 11);
  CFDictionarySetValue(v9, @"SCAN_FLAGS", v8);
  if (v9)
  {
    uint64_t v10 = malloc(0x28uLL);
    if (v10)
    {
      uint64_t v11 = v10;
      void *v10 = a1;
      v10[1] = 0LL;
      v10[3] = 0LL;
      if (CFDictionaryContainsKey(v9, @"SSID_STR")) {
        BOOL v12 = 1;
      }
      else {
        BOOL v12 = CFDictionaryContainsKey(v9, @"SCAN_SSID_LIST") != 0;
      }
      v11[32] = v12;
      uint64_t v13 = (const void *)sub_100043E8C(*(void *)(a1 + 64));
      uint64_t v14 = sub_1000E0CC4(a1, v13, v9, 0LL, (uint64_t)sub_10010442C, (uint64_t)v11, 0LL, 23LL);
      if ((_DWORD)v14)
      {
        uint64_t v28 = v14;
        double v29 = objc_autoreleasePoolPush();
        if (qword_100219F60) {
          [qword_100219F60 WFLog:@"Error initiating scan request: %d" message:4 v28];
        }
        objc_autoreleasePoolPop(v29);
        free(v11);
      }
    }

    else
    {
      __int128 v27 = objc_autoreleasePoolPush();
      if (qword_100219F60) {
        [qword_100219F60 WFLog:@"%s: null scanData" message:4];
      }
      objc_autoreleasePoolPop(v27);
    }

    CFRelease(v9);
    if (v8) {
LABEL_16:
    }
      CFRelease(v8);
  }

  else
  {
    uint64_t v26 = objc_autoreleasePoolPush();
    if (qword_100219F60) {
      [qword_100219F60 WFLog:@"__WiFiDeviceManagerColocatedNetworkScan: failed to create scan request"];
    }
    objc_autoreleasePoolPop(v26);
    if (v8) {
      goto LABEL_16;
    }
  }

CFArrayRef sub_1000F93A4(uint64_t a1, uint64_t a2)
{
  uint64_t result = *(const __CFArray **)(a1 + 3728);
  if (result)
  {
    CFIndex Count = CFArrayGetCount(result);
    if (Count < 1)
    {
      return 0LL;
    }

    else
    {
      CFIndex v6 = Count;
      CFIndex v7 = 0LL;
      while (1)
      {
        ValueAtIndex = CFArrayGetValueAtIndex(*(CFArrayRef *)(a1 + 3728), v7);
        if (ValueAtIndex)
        {
        }

        if (v6 == ++v7) {
          return 0LL;
        }
      }

      return (const __CFArray *)1;
    }
  }

  return result;
}

void sub_1000F9420(uint64_t a1, const __CFDictionary *a2)
{
  uint64_t v28 = 0LL;
  uint64_t valuePtr = 0LL;
  uint64_t v27 = 0LL;
  if (sub_100055A48(*(void *)(a1 + 64)))
  {
    uint64_t v4 = (const void *)sub_100043E8C(*(void *)(a1 + 64));
    uint64_t v5 = sub_100040538(*(void *)(a1 + 64), v4);
    CFIndex v6 = (const __CFNumber *)sub_1000951FC((uint64_t)v5, @"CHANNEL_FLAGS");
    if (v6) {
      CFNumberGetValue(v6, kCFNumberIntType, &valuePtr);
    }
    CFBooleanRef Value = (const __CFNumber *)CFDictionaryGetValue(a2, @"6E_NETWORK_TRANSITION");
    if (Value)
    {
      CFNumberGetValue(Value, kCFNumberIntType, (char *)&v28 + 4);
      CFNumberRef v8 = (const __CFNumber *)CFDictionaryGetValue(a2, @"LEGACY_NETWORK_TRANSITION");
      if (v8)
      {
        CFNumberGetValue(v8, kCFNumberIntType, &v28);
        int v9 = (const __CFNumber *)CFDictionaryGetValue(a2, @"CHANNEL");
        if (v9) {
          CFNumberGetValue(v9, kCFNumberIntType, (char *)&v27 + 4);
        }
        uint64_t v10 = objc_autoreleasePoolPush();
        if (qword_100219F60)
        {
          if ((_DWORD)v28) {
            uint64_t v11 = "2.4Gh/5Gh";
          }
          else {
            uint64_t v11 = "6Gh";
          }
          [qword_100219F60 WFLog:message:3, @"[NWTRANSIT]: Initiate Colocated Network Transition. Transitioning to %s Colocated Network", v11];
        }

        objc_autoreleasePoolPop(v10);
        BOOL v12 = *(const __CFArray **)(a1 + 3728);
        if (v12) {
          CFIndex Count = CFArrayGetCount(v12);
        }
        else {
          CFIndex Count = 0LL;
        }
        uint64_t v14 = objc_autoreleasePoolPush();
        if (qword_100219F60) {
          [qword_100219F60 WFLog:@"[NWTRANSIT]: Num Colocated Networks %ld" message:Count];
        }
        objc_autoreleasePoolPop(v14);
        if ((_DWORD)v28)
        {
          if ((valuePtr & 0x2000) != 0 && Count >= 1)
          {
            for (CFIndex i = 0LL; Count != i; ++i)
            {
              ValueAtIndex = CFArrayGetValueAtIndex(*(CFArrayRef *)(a1 + 3728), i);
              if (ValueAtIndex)
              {
                id v17 = ValueAtIndex;
                id v18 = (const __CFNumber *)sub_1000951FC((uint64_t)ValueAtIndex, @"CHANNEL_FLAGS");
                signed int v19 = (const __CFNumber *)sub_1000951FC((uint64_t)v17, @"CHANNEL");
                CFNumberGetValue(v19, kCFNumberIntType, &v27);
                CFNumberGetValue(v18, kCFNumberIntType, (char *)&valuePtr + 4);
                if (!HIDWORD(v27) && (valuePtr & 0x1000000000LL) != 0)
                {
                  uint64_t v26 = objc_autoreleasePoolPush();
                  if (qword_100219F60) {
                    [(id)qword_100219F60 WFLog:3, "[NWTRANSIT]: Associated to 6Gh. No Target channel. Top Colocated Network for Transition = %@", v17 message];
                  }
                  goto LABEL_54;
                }

                if (HIDWORD(v27) == (_DWORD)v27)
                {
                  uint64_t v26 = objc_autoreleasePoolPush();
                  if (qword_100219F60) {
                    [(id)qword_100219F60 WFLog:3, "[NWTRANSIT]: Associated to 6Gh. Colocated network available in Peer Channel. NetworCFIndex k = %@", v17 message];
                  }
                  goto LABEL_54;
                }

                if (v18 && (valuePtr & 0x800000000LL) != 0)
                {
                  uint64_t v26 = objc_autoreleasePoolPush();
                  if (qword_100219F60) {
                    [(id)qword_100219F60 WFLog:3, "[NWTRANSIT]: Associated to 6Gh. Top Colocated Network for Transition = %@", v17 message];
                  }
                  goto LABEL_54;
                }
              }
            }
          }
        }

        else if ((valuePtr & 0x18) != 0 && Count >= 1)
        {
          for (CFIndex j = 0LL; j != Count; ++j)
          {
            uint64_t v21 = CFArrayGetValueAtIndex(*(CFArrayRef *)(a1 + 3728), j);
            if (v21)
            {
              id v17 = v21;
              uint64_t v22 = (const __CFNumber *)sub_1000951FC((uint64_t)v21, @"CHANNEL_FLAGS");
              if (v22)
              {
                CFNumberGetValue(v22, kCFNumberIntType, (char *)&valuePtr + 4);
                if ((valuePtr & 0x200000000000LL) != 0)
                {
                  uint64_t v26 = objc_autoreleasePoolPush();
                  if (qword_100219F60) {
                    [(id)qword_100219F60 WFLog:3, "[NWTRANSIT]:Associated to 2.4Gh/5Gh. Top 6Gh Colocated Network for Transition = %@", v17 message];
                  }
                  goto LABEL_54;
                }
              }
            }
          }

          if ((valuePtr & 8) == 0) {
            return;
          }
          CFIndex v23 = 0LL;
          while (1)
          {
            CFIndex v24 = CFArrayGetValueAtIndex(*(CFArrayRef *)(a1 + 3728), v23);
            if (v24)
            {
              id v17 = v24;
              dispatch_time_t v25 = (const __CFNumber *)sub_1000951FC((uint64_t)v24, @"CHANNEL_FLAGS");
              if (v25)
              {
                CFNumberGetValue(v25, kCFNumberIntType, (char *)&valuePtr + 4);
                if ((valuePtr & 0x1000000000LL) != 0) {
                  break;
                }
              }
            }

            if (Count == ++v23) {
              return;
            }
          }

          uint64_t v26 = objc_autoreleasePoolPush();
          if (qword_100219F60) {
            [(id)qword_100219F60 WFLog:3, "[NWTRANSIT]:Associated to 2.4Gh. Top 5Gh Colocated Network for Transition = %@", v17 message];
          }
LABEL_54:
          objc_autoreleasePoolPop(v26);
          sub_1000F8C18(a1, v17);
        }
      }
    }
  }

uint64_t sub_1000F97B8(uint64_t result)
{
  if (result) {
    return sub_100055A48(*(void *)(result + 64));
  }
  return result;
}

uint64_t sub_1000F97C8(uint64_t result, char a2)
{
  *(_BYTE *)(result + 6996) = a2;
  return result;
}

void sub_1000F97D4(uint64_t a1, uint64_t a2, int a3)
{
  if (!a1)
  {
    CFIndex v6 = objc_autoreleasePoolPush();
    CFIndex v7 = (void *)qword_100219F60;
    if (!qword_100219F60) {
      goto LABEL_7;
    }
    uint64_t v10 = "WiFiDeviceManagerEvaluateStandaloneNetworkForUserPrompts";
    CFNumberRef v8 = "%s: null device manager";
    goto LABEL_13;
  }

  if (!-[WiFiUserInteractionMonitor isSetupCompleted]( +[WiFiUserInteractionMonitor sharedInstance](&OBJC_CLASS___WiFiUserInteractionMonitor, "sharedInstance"),  "isSetupCompleted"))
  {
    CFIndex v6 = objc_autoreleasePoolPush();
    CFIndex v7 = (void *)qword_100219F60;
    if (!qword_100219F60) {
      goto LABEL_7;
    }
    CFNumberRef v8 = "suppressing standalone 6G notifications as setup is not complete";
LABEL_13:
    uint64_t v9 = 4LL;
    goto LABEL_6;
  }

  sub_1000F98D4(a1, a2);
  if (a3)
  {
    CFIndex v6 = objc_autoreleasePoolPush();
    CFIndex v7 = (void *)qword_100219F60;
    if (!qword_100219F60)
    {
LABEL_7:
      objc_autoreleasePoolPop(v6);
      return;
    }

    uint64_t v10 = "WiFiDeviceManagerEvaluateStandaloneNetworkForUserPrompts";
    uint64_t v11 = a2;
    CFNumberRef v8 = "%s: no colocated candidate found for %@";
    uint64_t v9 = 3LL;
LABEL_6:
    objc_msgSend(v7, "WFLog:message:", v9, v8, v10, v11);
    goto LABEL_7;
  }

uint64_t sub_1000F98D4(uint64_t a1, uint64_t a2)
{
  uint64_t v4 = objc_autoreleasePoolPush();
  if (a2)
  {
    uint64_t v5 = objc_autoreleasePoolPush();
    if (a1)
    {
      if (qword_100219F60) {
        [qword_100219F60 WFLog:@"Beacon cache was empty"];
      }
    }

    else if (qword_100219F60)
    {
      [qword_100219F60 WFLog:@"%s: WiFiDeviceManagerRef is NULL" message:3];
    }
  }

  else
  {
    uint64_t v5 = objc_autoreleasePoolPush();
    if (qword_100219F60) {
      [qword_100219F60 WFLog:@"%s: WiFiNetworkRef returned NULL" message:3];
    }
  }

  objc_autoreleasePoolPop(v5);
  objc_autoreleasePoolPop(v4);
  return 0LL;
}

void sub_1000F99A8(uint64_t *a1, const void *a2, const void *a3)
{
  CFIndex v6 = objc_autoreleasePoolPush();
  if (!a1)
  {
    id v17 = objc_autoreleasePoolPush();
    if (qword_100219F60) {
      [qword_100219F60 WFLog:@"%s: null device manager" message:4];
    }
    goto LABEL_29;
  }

  if (!-[WiFiUserInteractionMonitor isSetupCompleted]( +[WiFiUserInteractionMonitor sharedInstance](&OBJC_CLASS___WiFiUserInteractionMonitor, "sharedInstance"),  "isSetupCompleted"))
  {
    id v17 = objc_autoreleasePoolPush();
    id v18 = (void *)qword_100219F60;
    if (qword_100219F60)
    {
      signed int v19 = "suppressing limited compatibility modal as setup is not complete";
LABEL_28:
      objc_msgSend(v18, "WFLog:message:", 4, v19, v21);
    }

void sub_1000F9D2C(uint64_t *a1, const __CFString *a2)
{
  if (!a1)
  {
    CFIndex v23 = objc_autoreleasePoolPush();
    if (qword_100219F60) {
      [qword_100219F60 WFLog:@"%s: null manager." message:3];
    }
    goto LABEL_28;
  }

  uint64_t v4 = (const void *)sub_100043E8C(a1[8]);
  uint64_t v5 = sub_1000DEA34((uint64_t)a1, v4, 1);
  if (!v5)
  {
    CFIndex v23 = objc_autoreleasePoolPush();
    if (qword_100219F60) {
      [qword_100219F60 WFLog:@"%s: device is not connected to a network" message:4];
    }
LABEL_28:
    objc_autoreleasePoolPop(v23);
    id v18 = 0LL;
    goto LABEL_23;
  }

  CFIndex v6 = v5;
  CFIndex v7 = sub_1000539A4(a1[8], 0);
  CFNumberRef v8 = v7;
  if (v7)
  {
    __int128 v26 = 0u;
    __int128 v27 = 0u;
    __int128 v24 = 0u;
    __int128 v25 = 0u;
    id v9 = -[__CFArray countByEnumeratingWithState:objects:count:]( v7,  "countByEnumeratingWithState:objects:count:",  &v24,  v28,  16LL);
    if (v9)
    {
      id v10 = v9;
      uint64_t v11 = *(void *)v25;
      while (2)
      {
        for (CFIndex i = 0LL; i != v10; CFIndex i = (char *)i + 1)
        {
          if (*(void *)v25 != v11) {
            objc_enumerationMutation(v8);
          }
          uint64_t v13 = *(const void **)(*((void *)&v24 + 1) + 8LL * (void)i);
          uint64_t v14 = (const __CFString *)sub_100095BC8(v13);
          if (CFStringCompare(v14, a2, 0LL) == kCFCompareEqualTo)
          {
            signed int v19 = sub_100095BC8(v6);
            if (v19) {
              sub_10009582C((uint64_t)v13, @"LimitedCompatibilityNetworkName", v19);
            }
            id v20 = sub_1000A335C((uint64_t)v13);
            id v18 = -[NSArray initWithObjects:](objc_alloc(&OBJC_CLASS___NSArray), "initWithObjects:", v20, 0LL);
            id v21 = sub_1000D9F24((uint64_t)a1);
            if (v21)
            {
              uint64_t v22 = -[WiFiColocatedNetworkManager initWithNetwork:colocatedNetworks:]( objc_alloc(&OBJC_CLASS___WiFiColocatedNetworkManager),  "initWithNetwork:colocatedNetworks:",  v21,  v18);
              sub_1000F99A8(a1, v6, v22);
            }

            goto LABEL_21;
          }
        }

        id v10 = -[__CFArray countByEnumeratingWithState:objects:count:]( v8,  "countByEnumeratingWithState:objects:count:",  &v24,  v28,  16LL);
        if (v10) {
          continue;
        }
        break;
      }
    }

    uint64_t v15 = objc_autoreleasePoolPush();
    if (qword_100219F60) {
      [(id)qword_100219F60 WFLog:3, "%s: scanning for %@", "WiFiDeviceManagerDispatchSimulatedColocatedJoinNotification", a2 message];
    }
    objc_autoreleasePoolPop(v15);
  }

  id v16 = sub_1000ED0D0(0LL, 0LL, 0, 0x6Eu, 1);
  CFDictionarySetValue(v16, @"SSID_STR", a2);
  id v17 = (const void *)sub_100043E8C(a1[8]);
  sub_1000E0CC4((uint64_t)a1, v17, v16, 0LL, (uint64_t)sub_1000FA030, (uint64_t)a1, 0LL, 22LL);
  id v18 = 0LL;
LABEL_21:
  CFRelease(v6);
  if (v8) {
    CFRelease(v8);
  }
LABEL_23:
}

void sub_1000FA030(int a1, int a2, CFArrayRef theArray, uint64_t a4, uint64_t a5, uint64_t *a6)
{
  if (!a6)
  {
    id v20 = objc_autoreleasePoolPush();
    if (qword_100219F60) {
      [qword_100219F60 WFLog:@"__WiFiDeviceManagerSimulatedColocatedJoinNotificationScanCallback: manager is null"];
    }
    goto LABEL_17;
  }

  if (!theArray || !CFArrayGetCount(theArray))
  {
    id v20 = objc_autoreleasePoolPush();
    if (qword_100219F60) {
      [qword_100219F60 WFLog:@"scan results were empty"];
    }
LABEL_17:
    objc_autoreleasePoolPop(v20);
    uint64_t v11 = 0LL;
    id v16 = 0LL;
    id v9 = 0LL;
LABEL_21:
    uint64_t v15 = 0LL;
    goto LABEL_10;
  }

  CFNumberRef v8 = (const void *)sub_100043E8C(a6[8]);
  id v9 = sub_1000DEA34((uint64_t)a6, v8, 1);
  ValueAtIndex = CFArrayGetValueAtIndex(theArray, 0LL);
  uint64_t v11 = -[NSArray initWithObjects:]( objc_alloc(&OBJC_CLASS___NSArray),  "initWithObjects:",  ValueAtIndex,  CFArrayGetValueAtIndex(theArray, 1LL),  0LL);
  uint64_t v12 = CFArrayGetValueAtIndex(theArray, 0LL);
  uint64_t v13 = CFArrayGetValueAtIndex(theArray, 1LL);
  id v14 = sub_1000D9F24((uint64_t)a6);
  if (!v14)
  {
    id v21 = objc_autoreleasePoolPush();
    if (qword_100219F60) {
      [qword_100219F60 WFLog:@"%s: __WiFiDeviceManagerCopyCurrentCoreWiFiScanResult() returned NULL" message:3];
    }
    objc_autoreleasePoolPop(v21);
    id v16 = 0LL;
    goto LABEL_21;
  }

  uint64_t v15 = v14;
  id v16 = -[WiFiColocatedNetworkManager initWithNetwork:colocatedNetworks:]( objc_alloc(&OBJC_CLASS___WiFiColocatedNetworkManager),  "initWithNetwork:colocatedNetworks:",  v14,  v11);
  id v17 = objc_autoreleasePoolPush();
  if (qword_100219F60) {
    [(id)qword_100219F60 WFLog:3, "%s: simulating colocated join notification for %@", "__WiFiDeviceManagerSimulatedColocatedJoinNotificationScanCallback", -[WiFiColocatedNetworkManager colocatedNetworks](v16, "colocatedNetworks") message];
  }
  objc_autoreleasePoolPop(v17);
  id v18 = sub_100095BC8(v9);
  if (v18)
  {
    signed int v19 = v18;
    sub_10009582C((uint64_t)v12, @"LimitedCompatibilityNetworkName", v18);
    sub_10009582C((uint64_t)v13, @"LimitedCompatibilityNetworkName", v19);
  }

  sub_1000F99A8(a6, v9, v16);
LABEL_10:

  if (v9) {
    CFRelease(v9);
  }
}

void sub_1000FA2C0(uint64_t a1, const void *a2)
{
  uint64_t v4 = objc_autoreleasePoolPush();
  if (!a1)
  {
    id v9 = objc_autoreleasePoolPush();
    if (qword_100219F60) {
      [qword_100219F60 WFLog:@"%s: null device manager" message:4];
    }
    goto LABEL_14;
  }

  uint64_t v5 = sub_100095BC8(a2);
  if (!v5)
  {
    id v9 = objc_autoreleasePoolPush();
    if (qword_100219F60) {
      [qword_100219F60 WFLog:@"%s: network name is null" message:@"WiFiDeviceManagerDispatchAppJoinNotification"];
    }
    goto LABEL_14;
  }

  CFIndex v6 = v5;
  if (!sub_1000951FC((uint64_t)a2, @"OriginatingApp"))
  {
    id v9 = objc_autoreleasePoolPush();
    if (qword_100219F60) {
      [qword_100219F60 WFLog:@"%s: app name is null" message:@"WiFiDeviceManagerDispatchAppJoinNotification"];
    }
LABEL_14:
    objc_autoreleasePoolPop(v9);
    goto LABEL_7;
  }

  CFRetain(a2);
  *(void *)(a1 + 6240) = a2;
  int v7 = sub_1000A4754((uint64_t)a2);
  CFNumberRef v8 = objc_autoreleasePoolPush();
  if (qword_100219F60) {
    [(id)qword_100219F60 WFLog:3, "%s: dispatching user forced association notify alert for network='%@'", "WiFiDeviceManagerDispatchAppJoinNotification", a2 message];
  }
  objc_autoreleasePoolPop(v8);
  [*(id *)(a1 + 6688) dispatchAccessoryJoinAlertForNetwork:v6 unsecured:v7 != 0];
LABEL_7:
  objc_autoreleasePoolPop(v4);
}

void sub_1000FA43C(uint64_t a1)
{
  if (-[WiFiUserInteractionMonitor isSetupCompleted]( +[WiFiUserInteractionMonitor sharedInstance](&OBJC_CLASS___WiFiUserInteractionMonitor, "sharedInstance"),  "isSetupCompleted"))
  {
    uint64_t v11 = objc_autoreleasePoolPush();
    if (qword_100219F60) {
      [qword_100219F60 WFLog:@"%s: User has already set up device" message:3];
    }
    goto LABEL_22;
  }

  id v2 = sub_1000D9F24(a1);
  if (!v2)
  {
    uint64_t v11 = objc_autoreleasePoolPush();
    if (qword_100219F60) {
      [qword_100219F60 WFLog:@"%s: Not able to submit setup metric __WiFiDeviceManagerCopyCurrentCoreWiFiScanResult returned NULL" message:3];
    }
LABEL_22:
    objc_autoreleasePoolPop(v11);
    id v14 = 0LL;
    uint64_t v3 = 0LL;
    goto LABEL_17;
  }

  uint64_t v3 = v2;
  id v14 = sub_1000FA698(a1);
  if (v14)
  {
    CFMutableDictionaryRef Mutable = CFDictionaryCreateMutable( kCFAllocatorDefault,  0LL,  &kCFTypeDictionaryKeyCallBacks,  &kCFTypeDictionaryValueCallBacks);
    if (Mutable)
    {
      uint64_t v5 = Mutable;
      unsigned int v6 = objc_msgSend(objc_msgSend(v3, "channel"), "band");
      if (v6 == 3)
      {
        CFDictionarySetValue(v5, @"infraBand", @"6");
        else {
          CFBooleanRef v9 = kCFBooleanFalse;
        }
        CFDictionarySetValue(v5, @"isSplitSSID", v9);
        int v7 = @"suppressedBanner";
        id v10 = v5;
        CFNumberRef v8 = (const __CFString *)kCFBooleanTrue;
      }

      else
      {
        if (v6 == 2)
        {
          int v7 = @"infraBand";
          CFNumberRef v8 = @"5";
        }

        else
        {
          if (v6 != 1)
          {
LABEL_16:
            sub_100039588((uint64_t)@"com.apple.wifi.setup", (uint64_t)v5);
            CFRelease(v5);
            goto LABEL_17;
          }

          int v7 = @"infraBand";
          CFNumberRef v8 = @"2";
        }

        id v10 = v5;
      }

      CFDictionarySetValue(v10, v7, v8);
      goto LABEL_16;
    }

    uint64_t v13 = objc_autoreleasePoolPush();
    if (qword_100219F60) {
      [qword_100219F60 WFLog:@"metric is null" message:@"WiFiDeviceManagerSubmitSetupMetric"];
    }
    objc_autoreleasePoolPop(v13);
  }

  else
  {
    uint64_t v12 = objc_autoreleasePoolPush();
    if (qword_100219F60) {
      [qword_100219F60 WFLog:@"%s: Not able to submit setup metric __WiFiDeviceManagerCopyCurrentCoreWiFiNetworkProfile returned NULL" message:3];
    }
    objc_autoreleasePoolPop(v12);
    id v14 = 0LL;
  }

CFDictionaryRef *sub_1000FA698(uint64_t a1)
{
  id v2 = (const void *)sub_10004CE2C(*(void *)(a1 + 64));
  uint64_t result = (CFDictionaryRef *)sub_1000DEA34(a1, v2, 1);
  if (result)
  {
    uint64_t v4 = result;
    uint64_t v5 = sub_1000A063C(result);
    CFRelease(v4);
    return (CFDictionaryRef *)v5;
  }

  return result;
}

void sub_1000FA6E8(void *a1, uint64_t a2)
{
  uint64_t v4 = objc_autoreleasePoolPush();
  uint64_t v5 = (void *)a1[494];
  unsigned int v6 = sub_1000ABA8C(a2);
  int v7 = sub_1000A3DB0([v5 retrieveNextCandidate]);
  CFNumberRef v8 = objc_autoreleasePoolPush();
  if (!v7)
  {
    if (qword_100219F60)
    {
      uint64_t v22 = "Could not create WiFiNetworkRef from scan result";
      CFIndex v23 = (void *)qword_100219F60;
LABEL_28:
      objc_msgSend(v23, "WFLog:message:", 4, v22, v25);
    }

void *sub_1000FAAA8(uint64_t a1, uint64_t a2)
{
  uint64_t v4 = objc_autoreleasePoolPush();
  if (!a1)
  {
    uint64_t v13 = objc_autoreleasePoolPush();
    if (qword_100219F60) {
      [qword_100219F60 WFLog:@"%s: manager is null" message:4];
    }
    goto LABEL_17;
  }

  id v5 = objc_msgSend(objc_msgSend(*(id *)(a1 + 8776), "knownNetworks"), "allObjects");
  if (!v5)
  {
    uint64_t v13 = objc_autoreleasePoolPush();
    if (qword_100219F60) {
      [qword_100219F60 WFLog:@"%s: known network profiles is nil" message:3];
    }
LABEL_17:
    objc_autoreleasePoolPop(v13);
    goto LABEL_11;
  }

  unsigned int v6 = v5;
  __int128 v16 = 0u;
  __int128 v17 = 0u;
  __int128 v14 = 0u;
  __int128 v15 = 0u;
  id v7 = [v5 countByEnumeratingWithState:&v14 objects:v18 count:16];
  if (!v7)
  {
LABEL_11:
    uint64_t v11 = 0LL;
    goto LABEL_12;
  }

  id v8 = v7;
  uint64_t v9 = *(void *)v15;
LABEL_5:
  uint64_t v10 = 0LL;
  while (1)
  {
    if (*(void *)v15 != v9) {
      objc_enumerationMutation(v6);
    }
    uint64_t v11 = *(void **)(*((void *)&v14 + 1) + 8 * v10);
    if (v8 == (id)++v10)
    {
      id v8 = [v6 countByEnumeratingWithState:&v14 objects:v18 count:16];
      if (v8) {
        goto LABEL_5;
      }
      goto LABEL_11;
    }
  }

uint64_t sub_1000FAC44(uint64_t a1)
{
  uint64_t v2 = *(void *)(a1 + 32);
  uint64_t v3 = (const void *)sub_100043E8C(*(void *)(v2 + 64));
  return sub_1000E1104(v2, v3, *(void **)(a1 + 40), 0LL, 0LL, (uint64_t)sub_1000FAC90, 0LL, 1026LL);
}

void sub_1000FAC90(uint64_t a1, uint64_t a2, void *a3, uint64_t a4, uint64_t a5)
{
  uint64_t v9 = *(void **)(a1 + 3952);
  uint64_t v10 = objc_autoreleasePoolPush();
  if (qword_100219F60) {
    [(id)qword_100219F60 WFLog:3, "%s: error %d reqInfo %@", "__WiFiDeviceManagerColocatedJoinAssociationCallback", a5, a4 message];
  }
  objc_autoreleasePoolPop(v10);
  uint64_t v11 = *(void **)(a1 + 8968);
  uint64_t v12 = objc_autoreleasePoolPush();
  if (v11)
  {
    if (qword_100219F60) {
      [qword_100219F60 WFLog:@"__WiFiDeviceManagerColocatedJoinAssociationCallback: enabling device manager"];
    }
    objc_autoreleasePoolPop(v12);
    sub_1000D02BC(a1);
    if ((_DWORD)a5)
    {
      if (sub_100098BF8((uint64_t)v11))
      {
        uint64_t v13 = objc_autoreleasePoolPush();
        if (qword_100219F60) {
          [(id)qword_100219F60 WFLog:3, "%s: removing password for %@ due to failed association", "__WiFiDeviceManagerColocatedJoinAssociationCallback", v11 message];
        }
        objc_autoreleasePoolPop(v13);
        sub_100099D38(v11);
      }

      goto LABEL_12;
    }

    __int128 v14 = (const __CFString *)sub_100095BC8(a3);
    __int128 v15 = (const __CFString *)sub_100095BC8(v11);
    if (CFStringCompare(v14, v15, 0LL))
    {
LABEL_12:
      __int128 v16 = objc_autoreleasePoolPush();
      if (qword_100219F60) {
        [(id)qword_100219F60 WFLog:3, "%s: launching settings to complete join for %@", "__WiFiDeviceManagerColocatedJoinAssociationCallback", v11 message];
      }
      objc_autoreleasePoolPop(v16);
      sub_10010B64C(0LL, (CFDictionaryRef *)v11);
      return;
    }

    sub_100072038(*(void *)(a1 + 6744), a3, 18LL);
    if ([v9 numberOfCandidates])
    {
      __int128 v17 = sub_1000A3DB0([v9 retrieveNextCandidate]);
      if (v17)
      {
        id v18 = v17;
        if (!sub_100098BF8((uint64_t)v17))
        {
LABEL_20:
          CFRetain(v18);
          *(void *)(a1 + 896_Block_object_dispose((const void *)(v1 - 152), 8) = v18;
          id v21 = *(dispatch_queue_s **)(a1 + 240);
          block[0] = _NSConcreteStackBlock;
          block[1] = 3221225472LL;
          block[2] = sub_1001189A4;
          block[3] = &unk_1001E2C30;
          void block[4] = v18;
          void block[5] = a1;
          dispatch_async(v21, block);
          return;
        }

        signed int v19 = sub_100095408(*(CFDictionaryRef **)(a1 + 8976));
        if (v19)
        {
          id v20 = v19;
          sub_100099C50(v18, v19);
          CFRelease(v20);
          goto LABEL_20;
        }

        __int128 v24 = objc_autoreleasePoolPush();
        if (qword_100219F60) {
          [(id)qword_100219F60 WFLog:4, "%s: failed to get password for %@", "__WiFiDeviceManagerColocatedJoinAssociationCallback", *(void *)(a1 + 8976) message];
        }
        objc_autoreleasePoolPop(v24);
      }

      else
      {
        CFIndex v23 = objc_autoreleasePoolPush();
        if (qword_100219F60) {
          [(id)qword_100219F60 WFLog:4 message:"Could not create WiFiNetworkRef from scan result"];
        }
        objc_autoreleasePoolPop(v23);
      }
    }

    else
    {
      uint64_t v22 = *(const void **)(a1 + 8968);
      if (v22)
      {
        CFRelease(v22);
        *(void *)(a1 + 896_Block_object_dispose((const void *)(v1 - 152), 8) = 0LL;
      }
    }
  }

  else
  {
    if (qword_100219F60) {
      [qword_100219F60 WFLog:@"%s: join candidate is null" message:4];
    }
    objc_autoreleasePoolPop(v12);
  }

uint64_t sub_1000FAF60()
{
  return 0LL;
}

void sub_1000FAF7C(uint64_t a1)
{
  if (a1)
  {
    uint64_t v2 = objc_autoreleasePoolPush();
    id v3 = [*(id *)(a1 + 6632) networksInDenyListedState:3];
    if (v3)
    {
      uint64_t v4 = (_BYTE *)(a1 + 9017);
      *(_BYTE *)(a1 + 9017) = [v3 count] != 0;
      id v5 = objc_autoreleasePoolPush();
      if (qword_100219F60)
      {
        if (*v4) {
          unsigned int v6 = "YES";
        }
        else {
          unsigned int v6 = "NO";
        }
        objc_msgSend( (id)qword_100219F60,  "WFLog:message:",  3,  "%s: WoW Denylist non-empty: %s",  "WiFiDeviceManagerProcessWoWDenylistUpdate",  v6);
      }
    }

    else
    {
      id v5 = objc_autoreleasePoolPush();
      if (qword_100219F60) {
        [qword_100219F60 WFLog:@"%s: Failed to get WoW Denylisted networks" message:3 v7];
      }
    }

    objc_autoreleasePoolPop(v5);
    objc_autoreleasePoolPop(v2);
  }

uint64_t sub_1000FB06C(uint64_t result)
{
  if (result) {
    return *(unsigned __int8 *)(result + 3440);
  }
  return result;
}

uint64_t sub_1000FB078(uint64_t *a1, const void *a2, CFTypeRef cf1, const void *a4)
{
  if (CFEqual(cf1, @"IO80211InterfaceBGScanParams"))
  {
    id v8 = (CFTypeRef *)(a1 + 683);
    uint64_t v9 = (const void *)a1[683];
    if (v9)
    {
LABEL_3:
      CFRelease(v9);
      *id v8 = 0LL;
    }
  }

  else
  {
    if (!CFEqual(cf1, @"IO80211InterfaceBGDynamicProfileParams")) {
      return sub_1000447A8(a1[8], a2, cf1, (uint64_t)a4);
    }
    id v8 = (CFTypeRef *)(a1 + 684);
    uint64_t v9 = (const void *)a1[684];
    if (v9) {
      goto LABEL_3;
    }
  }

  *id v8 = CFRetain(a4);
  return sub_1000447A8(a1[8], a2, cf1, (uint64_t)a4);
}

uint64_t sub_1000FB120(uint64_t *a1, const void *a2, void *a3)
{
  unsigned int v6 = objc_autoreleasePoolPush();
  if (!a1)
  {
    uint64_t v28 = objc_autoreleasePoolPush();
    if (qword_100219F60) {
      [qword_100219F60 WFLog:@"%s: null manager." message:@"WiFiDeviceManagerSetBackgroundScanConfiguration"];
    }
    goto LABEL_48;
  }

  if (!a2)
  {
    uint64_t v28 = objc_autoreleasePoolPush();
    if (qword_100219F60) {
      [qword_100219F60 WFLog:@"%s: null interfaceName." message:@"WiFiDeviceManagerSetBackgroundScanConfiguration"];
    }
    goto LABEL_48;
  }

  if (!a3)
  {
    uint64_t v28 = objc_autoreleasePoolPush();
    if (qword_100219F60) {
      [qword_100219F60 WFLog:@"%s: null config." message:@"WiFiDeviceManagerSetBackgroundScanConfiguration"];
    }
LABEL_48:
    objc_autoreleasePoolPop(v28);
    uint64_t v26 = 4294963396LL;
    goto LABEL_41;
  }

  id v7 = +[NSMutableDictionary dictionary](&OBJC_CLASS___NSMutableDictionary, "dictionary");
  double v32 = a2;
  unsigned int v33 = v6;
  int v30 = a3;
  double v31 = (CFMutableArrayRef *)a1;
  if ([a3 modifyMap])
  {
    double v29 = v7;
    id v8 = +[NSMutableArray array](&OBJC_CLASS___NSMutableArray, "array");
    __int128 v40 = 0u;
    __int128 v41 = 0u;
    __int128 v42 = 0u;
    __int128 v43 = 0u;
    obCFIndex j = [a3 channels];
    id v9 = [obj countByEnumeratingWithState:&v40 objects:v51 count:16];
    if (v9)
    {
      id v10 = v9;
      uint64_t v11 = *(void *)v41;
      do
      {
        for (CFIndex i = 0LL; i != v10; CFIndex i = (char *)i + 1)
        {
          if (*(void *)v41 != v11) {
            objc_enumerationMutation(obj);
          }
          uint64_t v13 = *(void **)(*((void *)&v40 + 1) + 8LL * (void)i);
          v49[0] = @"CHANNEL";
          __int128 v14 = +[NSNumber numberWithUnsignedInteger:]( NSNumber,  "numberWithUnsignedInteger:",  [v13 channel]);
          v49[1] = @"CHANNEL_FLAGS";
          v50[0] = v14;
          v50[1] = +[NSNumber numberWithUnsignedInt:]( NSNumber,  "numberWithUnsignedInt:",  [v13 flags]);
          [v8 addObject:+[NSDictionary dictionaryWithObjects:forKeys:count:]( NSDictionary,  "dictionaryWithObjects:forKeys:count:",  v50,  v49,  2)];
        }

        id v10 = [obj countByEnumeratingWithState:&v40 objects:v51 count:16];
      }

      while (v10);
    }

    id v7 = v29;
    [v29 setObject:v8 forKeyedSubscript:@"SCAN_CHANNELS"];
    a2 = v32;
    unsigned int v6 = v33;
  }

  if (([a3 modifyMap] & 4) != 0) {
    [v7 setObject:[NSNumber numberWithBool:[a3 cacheEnabled]] forKeyedSubscript:@"BGSCAN_CACHE"];
  }
  if (([a3 modifyMap] & 8) != 0) {
    objc_msgSend( v7,  "setObject:forKeyedSubscript:",  +[NSNumber numberWithBool:](NSNumber, "numberWithBool:", objc_msgSend(a3, "cacheRollover")),  @"BGSCAN_CACHE_WSB_ROLLOVER");
  }
  if ([v7 count])
  {
    sub_1000E8474((uint64_t)a1, (CFDictionaryRef)v7, 0);
    if (([a3 modifyMap] & 2) == 0)
    {
LABEL_35:
      sub_1000D4854((uint64_t)a1);
      goto LABEL_36;
    }

id sub_1000FB764(uint64_t a1)
{
  uint64_t v2 = objc_autoreleasePoolPush();
  if (a1)
  {
    id v3 = objc_alloc_init(&OBJC_CLASS___CWFBackgroundScanConfiguration);
    uint64_t v4 = *(void **)(a1 + 5472);
    if (v4) {
      objc_msgSend( v3,  "setScanFrequency:",  objc_msgSend( objc_msgSend(v4, "objectForKeyedSubscript:", @"IO80211InterfaceBGScanDynamicProfileScanFreq"),  "unsignedIntegerValue"));
    }
    id v5 = *(void **)(a1 + 5464);
    if (v5) {
      objc_msgSend( v3,  "setLostNetworkScanCount:",  objc_msgSend( objc_msgSend(v5, "objectForKeyedSubscript:", @"IO80211InterfaceBGScanLostNetTO"),  "unsignedIntegerValue"));
    }
    char context = v2;
    [v3 setCacheEnabled:*(_BYTE *)(a1 + 5449) != 0];
    [v3 setCacheRollover:*(_BYTE *)(a1 + 5450) != 0];
    unsigned int v6 = *(void **)(a1 + 5440);
    double v32 = v3;
    if (v6)
    {
      uint64_t v30 = a1;
      id v7 = +[NSMutableArray array](&OBJC_CLASS___NSMutableArray, "array");
      __int128 v33 = 0u;
      __int128 v34 = 0u;
      __int128 v35 = 0u;
      __int128 v36 = 0u;
      id v8 = [v6 countByEnumeratingWithState:&v33 objects:v37 count:16];
      if (v8)
      {
        id v9 = v8;
        uint64_t v10 = *(void *)v34;
        do
        {
          for (CFIndex i = 0LL; i != v9; CFIndex i = (char *)i + 1)
          {
            if (*(void *)v34 != v10) {
              objc_enumerationMutation(v6);
            }
            uint64_t v12 = *(void **)(*((void *)&v33 + 1) + 8LL * (void)i);
            id v13 = objc_alloc_init(&OBJC_CLASS___CWFChannel);
            objc_msgSend( v13,  "setChannel:",  objc_msgSend(objc_msgSend(v12, "objectForKeyedSubscript:", @"CHANNEL"), "unsignedIntegerValue"));
            id v14 = [v12 objectForKeyedSubscript:@"CHANNEL_FLAGS"];
            if (v14)
            {
              uint64_t v15 = (uint64_t)[v14 unsignedIntValue];
            }

            else if ((unint64_t)[v13 channel] <= 0xE)
            {
              uint64_t v15 = 10LL;
            }

            else
            {
              uint64_t v15 = 18LL;
            }

            [v13 setFlags:v15];
            [v7 addObject:v13];
          }

          id v9 = [v6 countByEnumeratingWithState:&v33 objects:v37 count:16];
        }

        while (v9);
      }

      [v3 setChannels:v7];
      a1 = v30;
    }

    id v16 = *(const __CFArray **)(a1 + 3584);
    if (v16)
    {
      id v17 = +[NSMutableArray array](&OBJC_CLASS___NSMutableArray, "array");
      if (CFArrayGetCount(v16) >= 1)
      {
        CFIndex v18 = 0LL;
        do
        {
          ValueAtIndex = CFArrayGetValueAtIndex(v16, v18);
          id v20 = objc_autoreleasePoolPush();
          if (ValueAtIndex && (CFDictionaryRef v21 = sub_100012CEC((uint64_t)ValueAtIndex)) != 0LL)
          {
            uint64_t v22 = v21;
            id v23 = objc_alloc_init(&OBJC_CLASS___CWFBackgroundScanNetwork);
            CFBooleanRef Value = CFDictionaryGetValue(v22, @"BSSID");
            [v23 setBSSID:CWFCorrectEthernetAddressString(Value)];
            id v25 = objc_alloc_init(&OBJC_CLASS___CWFChannel);
            [v25 setChannel:((unsigned int)CFDictionaryGetValue(v22, @"CHANNEL"))];
            uint64_t v26 = (void *)CFDictionaryGetValue(v22, @"CHANNEL_FLAGS");
            if (v26)
            {
              uint64_t v27 = (uint64_t)[v26 unsignedIntValue];
            }

            else if ((unint64_t)[v25 channel] <= 0xE)
            {
              uint64_t v27 = 10LL;
            }

            else
            {
              uint64_t v27 = 18LL;
            }

            [v25 setFlags:v27];
            [v23 setChannel:v25];
            [v23 setEntry:[-[__CFDictionary objectForKeyedSubscript:](v22, "objectForKeyedSubscript:", @"ENTRY_NETWORK") boolValue]];
            [v23 setExit:[-[__CFDictionary objectForKeyedSubscript:](v22, "objectForKeyedSubscript:", @"EXIT_NETWORK") BOOLValue]];
            objc_autoreleasePoolPop(v20);
            CFRelease(v22);
            if (v23)
            {
              [v17 addObject:v23];
            }
          }

          else
          {
            objc_autoreleasePoolPop(v20);
          }

          ++v18;
        }

        while (v18 < CFArrayGetCount(v16));
      }

      id v3 = v32;
      [v32 setNetworks:v17];
    }

    [v3 setModifyMap:0];
    uint64_t v2 = context;
  }

  else
  {
    double v29 = objc_autoreleasePoolPush();
    if (qword_100219F60) {
      [qword_100219F60 WFLog:@"%s: null manager." message:3];
    }
    objc_autoreleasePoolPop(v29);
    id v3 = 0LL;
  }

  objc_autoreleasePoolPop(v2);
  return v3;
}

NSMutableArray *sub_1000FBBB0(uint64_t a1)
{
  id v2 = [*(id *)(a1 + 6632) networksInDenyListedState:1];
  if ([v2 count]) {
    id v3 = +[NSMutableArray arrayWithCapacity:]( NSMutableArray,  "arrayWithCapacity:",  [v2 count]);
  }
  else {
    id v3 = 0LL;
  }
  char context = objc_autoreleasePoolPush();
  __int128 v10 = 0u;
  __int128 v11 = 0u;
  __int128 v12 = 0u;
  __int128 v13 = 0u;
  id v4 = [v2 countByEnumeratingWithState:&v10 objects:v14 count:16];
  if (v4)
  {
    id v5 = v4;
    uint64_t v6 = *(void *)v11;
    do
    {
      id v7 = 0LL;
      do
      {
        if (*(void *)v11 != v6) {
          objc_enumerationMutation(v2);
        }
        -[NSMutableArray addObject:]( v3,  "addObject:",  +[NSDictionary dictionaryWithObjectsAndKeys:]( NSDictionary,  "dictionaryWithObjectsAndKeys:",  [*(id *)(*((void *)&v10 + 1) + 8 * (void)v7) copy],  @"network",   objc_msgSend( objc_msgSend( *(id *)(a1 + 6632),  "reasonsForNetworkInDenyListedState:state:timestamps:reasonData:",  *(void *)(*((void *)&v10 + 1) + 8 * (void)v7),  1,  0,  0),  "copy"),  @"reasons",  0));
        id v7 = (char *)v7 + 1;
      }

      while (v5 != v7);
      id v5 = [v2 countByEnumeratingWithState:&v10 objects:v14 count:16];
    }

    while (v5);
  }

  objc_autoreleasePoolPop(context);
  return v3;
}

BOOL sub_1000FBD60(uint64_t a1, unint64_t a2, uint64_t a3)
{
  return sub_1000F0094(a1, a2, a3) != 0;
}

uint64_t sub_1000FBD7C(uint64_t a1, uint64_t a2, uint64_t a3)
{
  id v5 = sub_1000A335C(a3);
  [*(id *)(a1 + 6632) removeNetworkDenyListInfoWithReason:a2 forScanResult:v5];

  return 1LL;
}

void sub_1000FBDC8(uint64_t a1)
{
  id v2 = objc_autoreleasePoolPush();
  if (qword_100219F60) {
    [qword_100219F60 WFLog:@"Enter: %s %d\n" message:3];
  }
  objc_autoreleasePoolPop(v2);
  id v9 = objc_autoreleasePoolPush();
  uint64_t v10 = *(void *)(a1 + 240);
  if (v10) {
    sub_1000CEC04(a1, v10);
  }
  __int128 v11 = *(const void **)(a1 + 3504);
  if (v11)
  {
    CFRelease(v11);
    *(void *)(a1 + 3504) = 0LL;
  }

  __int128 v12 = *(const void **)(a1 + 3640);
  if (v12)
  {
    CFRelease(v12);
    *(void *)(a1 + 3640) = 0LL;
  }

  __int128 v13 = *(const void **)(a1 + 64);
  if (v13)
  {
    CFRelease(v13);
    *(void *)(a1 + 64) = 0LL;
  }

  id v14 = *(const void **)(a1 + 96);
  if (v14)
  {
    CFRelease(v14);
    *(void *)(a1 + 96) = 0LL;
  }

  uint64_t v15 = *(dispatch_object_s **)(a1 + 312);
  if (v15)
  {
    dispatch_release(v15);
    *(void *)(a1 + 312) = 0LL;
  }

  id v16 = *(dispatch_object_s **)(a1 + 360);
  if (v16)
  {
    dispatch_release(v16);
    *(void *)(a1 + 360) = 0LL;
  }

  id v17 = *(const void **)(a1 + 3496);
  if (v17)
  {
    CFRelease(v17);
    *(void *)(a1 + 3496) = 0LL;
  }

  CFIndex v18 = *(const void **)(a1 + 3528);
  if (v18)
  {
    CFRelease(v18);
    *(void *)(a1 + 352_Block_object_dispose((const void *)(v1 - 152), 8) = 0LL;
  }

  signed int v19 = *(const void **)(a1 + 3520);
  if (v19)
  {
    CFRelease(v19);
    *(void *)(a1 + 3520) = 0LL;
  }

  id v20 = *(const void **)(a1 + 3544);
  if (v20)
  {
    CFRelease(v20);
    *(void *)(a1 + 3544) = 0LL;
  }

  CFDictionaryRef v21 = *(const void **)(a1 + 3536);
  if (v21)
  {
    CFRelease(v21);
    *(void *)(a1 + 3536) = 0LL;
  }

  uint64_t v22 = *(const void **)(a1 + 3568);
  if (v22)
  {
    CFRelease(v22);
    *(void *)(a1 + 356_Block_object_dispose((const void *)(v1 - 152), 8) = 0LL;
  }

  id v23 = *(const void **)(a1 + 3576);
  if (v23)
  {
    CFRelease(v23);
    *(void *)(a1 + 3576) = 0LL;
  }

  __int128 v24 = *(const void **)(a1 + 3584);
  if (v24)
  {
    CFRelease(v24);
    *(void *)(a1 + 3584) = 0LL;
  }

  id v25 = *(const void **)(a1 + 3560);
  if (v25)
  {
    CFRelease(v25);
    *(void *)(a1 + 3560) = 0LL;
  }

  uint64_t v26 = *(const void **)(a1 + 3552);
  if (v26)
  {
    CFRelease(v26);
    *(void *)(a1 + 3552) = 0LL;
  }

  uint64_t v27 = *(const void **)(a1 + 3648);
  if (v27)
  {
    CFRelease(v27);
    *(void *)(a1 + 364_Block_object_dispose((const void *)(v1 - 152), 8) = 0LL;
  }

  uint64_t v28 = *(const void **)(a1 + 3592);
  if (v28)
  {
    CFRelease(v28);
    *(void *)(a1 + 3592) = 0LL;
  }

  double v29 = *(const void **)(a1 + 3600);
  if (v29)
  {
    CFRelease(v29);
    *(void *)(a1 + 3600) = 0LL;
  }

  uint64_t v30 = *(const void **)(a1 + 3320);
  if (v30)
  {
    CFRelease(v30);
    *(void *)(a1 + 3320) = 0LL;
  }

  double v31 = *(const void **)(a1 + 3328);
  if (v31)
  {
    CFRelease(v31);
    *(void *)(a1 + 332_Block_object_dispose((const void *)(v1 - 152), 8) = 0LL;
  }

  double v32 = *(const void **)(a1 + 3616);
  if (v32)
  {
    CFRelease(v32);
    *(void *)(a1 + 3616) = 0LL;
  }

  __int128 v33 = *(const void **)(a1 + 3624);
  if (v33)
  {
    CFRelease(v33);
    *(void *)(a1 + 3624) = 0LL;
  }

  __int128 v34 = *(const void **)(a1 + 3632);
  if (v34)
  {
    CFRelease(v34);
    *(void *)(a1 + 3632) = 0LL;
  }

  __int128 v35 = *(const void **)(a1 + 3280);
  if (v35)
  {
    CFRelease(v35);
    *(void *)(a1 + 3280) = 0LL;
  }

  __int128 v36 = *(const void **)(a1 + 3312);
  if (v36)
  {
    CFRelease(v36);
    *(void *)(a1 + 3312) = 0LL;
  }

  __int128 v37 = *(const void **)(a1 + 1096);
  if (v37)
  {
    CFRelease(v37);
    *(void *)(a1 + 1096) = 0LL;
  }

  __int128 v38 = *(const void **)(a1 + 1160);
  if (v38)
  {
    CFRelease(v38);
    *(void *)(a1 + 1160) = 0LL;
  }

  __int128 v39 = *(const void **)(a1 + 376);
  if (v39)
  {
    CFRelease(v39);
    *(void *)(a1 + 376) = 0LL;
  }

  __int128 v40 = *(const void **)(a1 + 272);
  if (v40)
  {
    CFRelease(v40);
    *(void *)(a1 + 272) = 0LL;
  }

  __int128 v41 = *(const void **)(a1 + 5432);
  if (v41)
  {
    CFRelease(v41);
    *(void *)(a1 + 5432) = 0LL;
  }

  __int128 v42 = *(const void **)(a1 + 120);
  if (v42)
  {
    CFRelease(v42);
    *(void *)(a1 + 120) = 0LL;
  }

  __int128 v43 = *(const void **)(a1 + 4928);
  if (v43)
  {
    CFRelease(v43);
    *(void *)(a1 + 492_Block_object_dispose((const void *)(v1 - 152), 8) = 0LL;
  }

  __int128 v44 = *(const void **)(a1 + 968);
  if (v44)
  {
    CFRelease(v44);
    *(void *)(a1 + 96_Block_object_dispose((const void *)(v1 - 152), 8) = 0LL;
  }

  uint64_t v45 = *(const void **)(a1 + 56);
  if (v45)
  {
    CFRelease(v45);
    *(void *)(a1 + 56) = 0LL;
  }

  id v46 = *(dispatch_object_s **)(a1 + 5504);
  if (v46)
  {
    dispatch_release(v46);
    *(void *)(a1 + 5504) = 0LL;
  }

  uint64_t v47 = *(dispatch_object_s **)(a1 + 8544);
  if (v47)
  {
    dispatch_release(v47);
    *(void *)(a1 + 8544) = 0LL;
  }

  uint64_t v48 = *(dispatch_object_s **)(a1 + 8584);
  if (v48)
  {
    dispatch_release(v48);
    *(void *)(a1 + 8584) = 0LL;
  }

  uint64_t v49 = *(dispatch_object_s **)(a1 + 992);
  if (v49)
  {
    dispatch_release(v49);
    *(void *)(a1 + 992) = 0LL;
  }

  uint64_t v50 = *(dispatch_object_s **)(a1 + 1048);
  if (v50)
  {
    dispatch_release(v50);
    *(void *)(a1 + 104_Block_object_dispose((const void *)(v1 - 152), 8) = 0LL;
  }

  uint64_t v51 = *(dispatch_object_s **)(a1 + 5520);
  if (v51)
  {
    dispatch_release(v51);
    *(void *)(a1 + 5520) = 0LL;
  }

  uint64_t v52 = *(void *)(a1 + 4936);
  if (v52)
  {
    if (_MISDetach) {
      _MISDetach(v52, v10, v3, v4, v5, v6, v7, v8);
    }
    *(void *)(a1 + 4936) = 0LL;
  }

  IOPMAssertionID v53 = *(_DWORD *)(a1 + 5220);
  if (v53)
  {
    IOPMAssertionRelease(v53);
    *(_DWORD *)(a1 + 5220) = 0;
  }

  uint64_t v54 = *(dispatch_object_s **)(a1 + 5232);
  if (v54)
  {
    dispatch_release(v54);
    *(void *)(a1 + 5232) = 0LL;
  }

  uint64_t v55 = *(dispatch_object_s **)(a1 + 5312);
  if (v55)
  {
    dispatch_release(v55);
    *(void *)(a1 + 5312) = 0LL;
  }

  uint64_t v56 = *(const void **)(a1 + 5360);
  if (v56)
  {
    CFRelease(v56);
    *(void *)(a1 + 5360) = 0LL;
  }

  unint64_t v57 = *(const void **)(a1 + 5368);
  if (v57)
  {
    CFRelease(v57);
    *(void *)(a1 + 536_Block_object_dispose((const void *)(v1 - 152), 8) = 0LL;
  }

  int v58 = *(const void **)(a1 + 5440);
  if (v58)
  {
    CFRelease(v58);
    *(void *)(a1 + 5440) = 0LL;
  }

  uint64_t v59 = *(const void **)(a1 + 5464);
  if (v59)
  {
    CFRelease(v59);
    *(void *)(a1 + 5464) = 0LL;
  }

  uint64_t v60 = *(const void **)(a1 + 5472);
  if (v60)
  {
    CFRelease(v60);
    *(void *)(a1 + 5472) = 0LL;
  }

  [*(id *)(a1 + 5400) resetDevice];
  *(void *)(a1 + 5400) = 0LL;
  uint64_t v61 = *(const void **)(a1 + 5480);
  if (v61)
  {
    CFRelease(v61);
    *(void *)(a1 + 5480) = 0LL;
  }

  id v62 = *(const void **)(a1 + 3360);
  if (v62)
  {
    CFRelease(v62);
    *(void *)(a1 + 3360) = 0LL;
  }

  id v63 = *(const void **)(a1 + 3368);
  if (v63)
  {
    CFRelease(v63);
    *(void *)(a1 + 336_Block_object_dispose((const void *)(v1 - 152), 8) = 0LL;
  }

  id v64 = *(const void **)(a1 + 3376);
  if (v64)
  {
    CFRelease(v64);
    *(void *)(a1 + 3376) = 0LL;
  }

  uint64_t v65 = *(const void **)(a1 + 3432);
  if (v65)
  {
    CFRelease(v65);
    *(void *)(a1 + 3432) = 0LL;
  }

  BOOL v66 = *(const void **)(a1 + 6152);
  if (v66)
  {
    CFRelease(v66);
    *(void *)(a1 + 6152) = 0LL;
  }

  unsigned int v67 = *(const void **)(a1 + 6048);
  if (v67)
  {
    CFRelease(v67);
    *(void *)(a1 + 604_Block_object_dispose((const void *)(v1 - 152), 8) = 0LL;
  }

  char v68 = *(const void **)(a1 + 6056);
  if (v68)
  {
    CFRelease(v68);
    *(void *)(a1 + 6056) = 0LL;
  }

  CFRange v69 = *(const void **)(a1 + 5264);
  if (v69)
  {
    CFRelease(v69);
    *(void *)(a1 + 5264) = 0LL;
  }

  unsigned int v70 = *(const void **)(a1 + 5272);
  if (v70)
  {
    CFRelease(v70);
    *(void *)(a1 + 5272) = 0LL;
  }

  int v71 = *(const void **)(a1 + 5280);
  if (v71)
  {
    CFRelease(v71);
    *(void *)(a1 + 5280) = 0LL;
  }

  CFRange v72 = *(const void **)(a1 + 5288);
  if (v72)
  {
    CFRelease(v72);
    *(void *)(a1 + 528_Block_object_dispose((const void *)(v1 - 152), 8) = 0LL;
  }

  unsigned int v73 = *(const void **)(a1 + 5296);
  if (v73)
  {
    CFRelease(v73);
    *(void *)(a1 + 5296) = 0LL;
  }

  int v74 = *(const void **)(a1 + 5304);
  if (v74)
  {
    CFRelease(v74);
    *(void *)(a1 + 5304) = 0LL;
  }

  CFTypeRef v75 = *(const void **)(a1 + 3672);
  if (v75)
  {
    CFRelease(v75);
    *(void *)(a1 + 3672) = 0LL;
  }

  id v76 = *(const void **)(a1 + 6544);
  if (v76)
  {
    CFRelease(v76);
    *(void *)(a1 + 6544) = 0LL;
  }

  uint64_t v77 = *(const void **)(a1 + 6496);
  if (v77)
  {
    CFRelease(v77);
    *(void *)(a1 + 6496) = 0LL;
  }

  CFTypeRef v78 = *(const void **)(a1 + 6512);
  if (v78)
  {
    CFRelease(v78);
    *(void *)(a1 + 6512) = 0LL;
  }

  char v79 = *(const void **)(a1 + 6528);
  if (v79)
  {
    CFRelease(v79);
    *(void *)(a1 + 652_Block_object_dispose((const void *)(v1 - 152), 8) = 0LL;
  }

  uint64_t v80 = *(const void **)(a1 + 6360);
  if (v80)
  {
    CFRelease(v80);
    *(void *)(a1 + 6360) = 0LL;
  }

  id v81 = *(const void **)(a1 + 6400);
  if (v81)
  {
    CFRelease(v81);
    *(void *)(a1 + 6400) = 0LL;
  }

  unint64_t v82 = *(const void **)(a1 + 6416);
  if (v82)
  {
    CFRelease(v82);
    *(void *)(a1 + 6416) = 0LL;
  }

  unsigned int v83 = *(const void **)(a1 + 6432);
  if (v83)
  {
    CFRelease(v83);
    *(void *)(a1 + 6432) = 0LL;
  }

  IOPMAssertionID v84 = *(_DWORD *)(a1 + 6564);
  if (v84)
  {
    IOPMAssertionRelease(v84);
    *(_DWORD *)(a1 + 6564) = 0;
    *(void *)(a1 + 656_Block_object_dispose((const void *)(v1 - 152), 8) = 0LL;
  }

  unsigned int v85 = *(dispatch_object_s **)(a1 + 6760);
  if (v85)
  {
    dispatch_release(v85);
    *(void *)(a1 + 6760) = 0LL;
  }

  uint64_t v86 = *(dispatch_object_s **)(a1 + 6768);
  if (v86)
  {
    dispatch_release(v86);
    *(void *)(a1 + 676_Block_object_dispose((const void *)(v1 - 152), 8) = 0LL;
  }

  uint64_t v87 = *(const void **)(a1 + 6792);
  if (v87)
  {
    CFRelease(v87);
    *(void *)(a1 + 6792) = 0LL;
  }

  uint64_t v88 = *(const void **)(a1 + 6864);
  if (v88)
  {
    CFRelease(v88);
    *(void *)(a1 + 6864) = 0LL;
  }

  uint64_t v89 = *(const void **)(a1 + 6872);
  if (v89)
  {
    CFRelease(v89);
    *(void *)(a1 + 6872) = 0LL;
  }

  BOOL v90 = *(const void **)(a1 + 6880);
  if (v90)
  {
    CFRelease(v90);
    *(void *)(a1 + 6880) = 0LL;
  }

  *(void *)(a1 + 688_Block_object_dispose((const void *)(v1 - 152), 8) = 0LL;
  uint64_t v91 = *(const void **)(a1 + 6640);
  if (v91)
  {
    CFRelease(v91);
    *(void *)(a1 + 6640) = 0LL;
  }

  unsigned int v92 = *(const void **)(a1 + 6984);
  if (v92)
  {
    CFRelease(v92);
    *(void *)(a1 + 6984) = 0LL;
  }

  *(void *)(a1 + 6624) = 0LL;
  unsigned int v93 = *(const void **)(a1 + 7016);
  if (v93)
  {
    CFRelease(v93);
    *(void *)(a1 + 7016) = 0LL;
  }

  unsigned int v94 = *(const void **)(a1 + 6656);
  if (v94)
  {
    CFRelease(v94);
    *(void *)(a1 + 6656) = 0LL;
  }

  int v95 = *(const void **)(a1 + 6664);
  if (v95)
  {
    CFRelease(v95);
    *(void *)(a1 + 6664) = 0LL;
  }

  unsigned int v96 = *(const void **)(a1 + 6672);
  if (v96)
  {
    CFRelease(v96);
    *(void *)(a1 + 6672) = 0LL;
  }

  *(void *)(a1 + 6680) = 0LL;

  *(void *)(a1 + 668_Block_object_dispose((const void *)(v1 - 152), 8) = 0LL;
  *(void *)(a1 + 672_Block_object_dispose((const void *)(v1 - 152), 8) = 0LL;
  int v97 = *(dispatch_object_s **)(a1 + 7272);
  if (v97)
  {
    dispatch_release(v97);
    *(void *)(a1 + 7272) = 0LL;
    *(_BYTE *)(a1 + 7264) = 0;
  }

  uint64_t v98 = *(dispatch_object_s **)(a1 + 7296);
  if (v98)
  {
    dispatch_release(v98);
    *(void *)(a1 + 7296) = 0LL;
    *(_BYTE *)(a1 + 728_Block_object_dispose((const void *)(v1 - 152), 8) = 0;
  }

  uint64_t v99 = *(dispatch_object_s **)(a1 + 7168);
  if (v99)
  {
    dispatch_release(v99);
    *(void *)(a1 + 716_Block_object_dispose((const void *)(v1 - 152), 8) = 0LL;
  }

  v100 = *(dispatch_object_s **)(a1 + 7208);
  if (v100)
  {
    dispatch_release(v100);
    *(void *)(a1 + 720_Block_object_dispose((const void *)(v1 - 152), 8) = 0LL;
  }

  uint64_t v101 = *(const void **)(a1 + 3696);
  if (v101)
  {
    CFRelease(v101);
    *(void *)(a1 + 3696) = 0LL;
  }

  unsigned int v102 = *(const void **)(a1 + 3688);
  if (v102)
  {
    CFRelease(v102);
    *(void *)(a1 + 368_Block_object_dispose((const void *)(v1 - 152), 8) = 0LL;
  }

  CFIndex v103 = *(const void **)(a1 + 3704);
  if (v103)
  {
    CFRelease(v103);
    *(void *)(a1 + 3704) = 0LL;
  }

  int v104 = *(const void **)(a1 + 7344);
  if (v104)
  {
    CFRelease(v104);
    *(void *)(a1 + 7344) = 0LL;
  }

  unsigned int v105 = *(const void **)(a1 + 8928);
  if (v105)
  {
    CFRelease(v105);
    *(void *)(a1 + 892_Block_object_dispose((const void *)(v1 - 152), 8) = 0LL;
  }

  CFMutableDictionaryRef v106 = *(const void **)(a1 + 3768);
  if (v106)
  {
    CFRelease(v106);
    *(void *)(a1 + 376_Block_object_dispose((const void *)(v1 - 152), 8) = 0LL;
  }

  unsigned int v107 = *(const void **)(a1 + 3728);
  if (v107)
  {
    CFRelease(v107);
    *(void *)(a1 + 372_Block_object_dispose((const void *)(v1 - 152), 8) = 0LL;
  }

  unsigned int v108 = *(const void **)(a1 + 3744);
  if (v108)
  {
    CFRelease(v108);
    *(void *)(a1 + 3744) = 0LL;
  }

  *(_BYTE *)(a1 + 3736) = 0;
  *(_BYTE *)(a1 + 3752) = 0;
  unsigned int v109 = *(const void **)(a1 + 3824);
  if (v109)
  {
    CFRelease(v109);
    *(void *)(a1 + 3824) = 0LL;
  }

  *(void *)(a1 + 384_Block_object_dispose((const void *)(v1 - 152), 8) = 0LL;
  *(_OWORD *)(a1 + 3780) = 0u;
  *(_OWORD *)(a1 + 3796) = 0u;
  *(void *)(a1 + 3809) = 0LL;
  unsigned int v110 = *(dispatch_object_s **)(a1 + 8936);
  if (v110)
  {
    dispatch_release(v110);
    *(void *)(a1 + 8936) = 0LL;
  }

  CFNumberRef v111 = *(dispatch_object_s **)(a1 + 8944);
  if (v111)
  {
    dispatch_release(v111);
    *(void *)(a1 + 8944) = 0LL;
  }

  qword_1002199D8 = 0LL;
  objc_autoreleasePoolPop(v9);
}

uint64_t sub_1000FC52C(uint64_t a1)
{
  double Current = CFAbsoluteTimeGetCurrent();
  MutableCFStringRef Copy = CFArrayCreateMutableCopy(kCFAllocatorDefault, 0LL, *(CFArrayRef *)(a1 + 376));
  CFArrayRemoveAllValues(*(CFMutableArrayRef *)(a1 + 376));
  if (MutableCopy)
  {
    if (CFArrayGetCount(MutableCopy) >= 1)
    {
      CFIndex v4 = 0LL;
      do
      {
        double valuePtr = 0.0;
        ValueAtIndex = (const __CFNumber *)CFArrayGetValueAtIndex(MutableCopy, v4);
        if (ValueAtIndex)
        {
          uint64_t v6 = ValueAtIndex;
          CFNumberGetValue(ValueAtIndex, kCFNumberDoubleType, &valuePtr);
        }

        ++v4;
      }

      while (v4 < CFArrayGetCount(MutableCopy));
    }

    CFRelease(MutableCopy);
  }

  if (CFArrayGetCount(*(CFArrayRef *)(a1 + 376)) < *(void *)(a1 + 392)) {
    return 0LL;
  }
  uint64_t v8 = objc_autoreleasePoolPush();
  if (qword_100219F60) {
    [qword_100219F60 WFLog:@"__WiFiDeviceManagerIsScanThrottleLimitExceeded: scan throttle exceeded: there have been %ld attempts in the past %f seconds" message:3];
  }
  objc_autoreleasePoolPop(v8);
  return 1LL;
}

uint64_t sub_1000FC698(uint64_t a1, void *a2, unsigned int a3)
{
  uint64_t v6 = objc_autoreleasePoolPush();
  if (!a2)
  {
    uint64_t v7 = objc_autoreleasePoolPush();
    if (qword_100219F60) {
      [qword_100219F60 WFLog:@"%s: null network,  isFilteringAJCandidates %d" message:3, "%s: null network,  isFilteringAJCandidates %d",  "__WiFiDeviceManagerKnownNetworkSuitabilityCheck",  a3,  v38];
    }
    goto LABEL_24;
  }

  if (CFSetContainsValue(*(CFSetRef *)(a1 + 3496), a2))
  {
    uint64_t v7 = objc_autoreleasePoolPush();
    uint64_t v8 = (void *)qword_100219F60;
    if (qword_100219F60)
    {
      __int128 v37 = sub_100095BC8(a2);
      uint64_t v38 = a3;
      id v9 = "%s: user canceled network %@, isFilteringAJCandidates %d";
LABEL_23:
      objc_msgSend(v8, "WFLog:message:", 3, v9, "__WiFiDeviceManagerKnownNetworkSuitabilityCheck", v37, v38);
      goto LABEL_24;
    }

    goto LABEL_24;
  }

  if (sub_10009EA20((uint64_t)a2))
  {
    uint64_t v7 = objc_autoreleasePoolPush();
    uint64_t v8 = (void *)qword_100219F60;
    if (qword_100219F60)
    {
      __int128 v37 = sub_100095BC8(a2);
      uint64_t v38 = a3;
      id v9 = "%s: disabled until first user join network %@ isFilteringAJCandidates %d";
      goto LABEL_23;
    }

CFNumberRef sub_1000FD054(uint64_t a1, const void *a2)
{
  if (!a1)
  {
    id v9 = objc_autoreleasePoolPush();
    if (qword_100219F60) {
      [qword_100219F60 WFLog:@"%s: null manager" message:3];
    }
    goto LABEL_20;
  }

  if (!*(void *)(a1 + 3672))
  {
    id v9 = objc_autoreleasePoolPush();
    if (qword_100219F60) {
      [qword_100219F60 WFLog:@"%s: null networksMissingPassword" message:3, "%s: null networksMissingPassword", "__WiFiDeviceManagerIsNetworkInMissingPasswordList"];
    }
    goto LABEL_20;
  }

  CFIndex v4 = sub_100095BC8(a2);
  if (!v4)
  {
    id v9 = objc_autoreleasePoolPush();
    if (qword_100219F60) {
      [qword_100219F60 WFLog:@"%s: null ssid" message:3];
    }
LABEL_20:
    uint64_t v8 = v9;
LABEL_11:
    objc_autoreleasePoolPop(v8);
    return 0LL;
  }

  uint64_t v5 = v4;
  double valuePtr = 0.0;
  uint64_t result = (const __CFNumber *)CFDictionaryGetValue(*(CFDictionaryRef *)(a1 + 3672), v4);
  if (result)
  {
    CFNumberGetValue(result, kCFNumberDoubleType, &valuePtr);
    if (CFAbsoluteTimeGetCurrent() - valuePtr > 86400.0
      || sub_10009DF44((uint64_t)a2) && *(_DWORD *)(a1 + 5512) == 1)
    {
      sub_1000FD4EC(a1, a2);
      uint64_t v7 = objc_autoreleasePoolPush();
      if (qword_100219F60) {
        [(id)qword_100219F60 WFLog:3, "%s: unblacklisting network %@", "__WiFiDeviceManagerIsNetworkInMissingPasswordList", v5 message];
      }
      uint64_t v8 = v7;
      goto LABEL_11;
    }

    return (const __CFNumber *)1;
  }

  return result;
}

uint64_t sub_1000FD1E4(uint64_t a1, void *a2)
{
  CFIndex v4 = objc_autoreleasePoolPush();
  if (!a1)
  {
    __int128 v11 = objc_autoreleasePoolPush();
    if (qword_100219F60) {
      [qword_100219F60 WFLog:@"%s: null manager." message:3 v15 v16 v17];
    }
    goto LABEL_14;
  }

  if (*(_DWORD *)(a1 + 168) != 2)
  {
LABEL_15:
    uint64_t v10 = 0LL;
    goto LABEL_16;
  }

  id v5 = sub_1000A335C((uint64_t)a2);
  if (([*(id *)(a1 + 6632) isNetworkInDenyListedState:1 scanResult:v5] & 1) == 0)
  {

LABEL_12:
    __int128 v11 = objc_autoreleasePoolPush();
    if (qword_100219F60) {
      [qword_100219F60 WFLog:@"__WiFiDeviceManagerHasNetworkRssiImproved: invalid scannedRssi" message:3 v15 v16 v17];
    }
    goto LABEL_14;
  }

  id v6 = [*(id *)(a1 + 6632) RSSIWhenNetworkWasDenyListed:v5];
  uint64_t v7 = sub_100096BF4((uint64_t)a2, @"RSSI");

  if (!(_DWORD)v7) {
    goto LABEL_12;
  }
  if (!(_DWORD)v6)
  {
    __int128 v11 = objc_autoreleasePoolPush();
    if (qword_100219F60) {
      [qword_100219F60 WFLog:@"__WiFiDeviceManagerHasNetworkRssiImproved: invalid denyListedRssi" message:3 v15 v16 v17];
    }
    goto LABEL_14;
  }

  int v18 = 0;
  uint64_t v8 = sub_1000FD668(a1, a2, 1, &v18);
  if ((int)v8 > (int)v7)
  {
    uint64_t v13 = v8;
    __int128 v11 = objc_autoreleasePoolPush();
    if (qword_100219F60)
    {
      else {
        unsigned int v14 = off_1001E57A8[v18 - 1];
      }
      [(id)qword_100219F60 WFLog:3, "%s: scannedRssi %d below threshold %d (%@)", "__WiFiDeviceManagerHasNetworkRssiImproved", v7, v13, v14 message];
    }

uint64_t sub_1000FD410(uint64_t a1, const void *a2)
{
  if (a1)
  {
    if (*(_DWORD *)(a1 + 168) != 2) {
      return 0LL;
    }
    uint64_t v3 = sub_100096BF4((uint64_t)a2, @"RSSI");
    CFIndex v4 = objc_autoreleasePoolPush();
    if (qword_100219F60) {
      [(id)qword_100219F60 WFLog:3, "RSSI-based unblacklisting: including %@ (rssi=%d) for scan.", sub_100095BC8(a2), v3 message];
    }
    uint64_t v5 = 1LL;
  }

  else
  {
    CFIndex v4 = objc_autoreleasePoolPush();
    if (qword_100219F60) {
      [qword_100219F60 WFLog:@"__WiFiDeviceManagerIsRssiBasedUnblacklistingAllowed: null manager."];
    }
    uint64_t v5 = 0LL;
  }

  objc_autoreleasePoolPop(v4);
  return v5;
}

void sub_1000FD4EC(uint64_t a1, const void *a2)
{
  if (!a1)
  {
    uint64_t v5 = objc_autoreleasePoolPush();
    if (qword_100219F60) {
      [qword_100219F60 WFLog:@"__WiFiDeviceManagerManageMissingPasswordList: null manager"];
    }
    goto LABEL_14;
  }

  if (!a2)
  {
    uint64_t v5 = objc_autoreleasePoolPush();
    if (qword_100219F60) {
      [qword_100219F60 WFLog:@"%s: null network" message:3];
    }
    goto LABEL_14;
  }

  if (!*(void *)(a1 + 3672))
  {
    uint64_t v5 = objc_autoreleasePoolPush();
    if (qword_100219F60) {
      [qword_100219F60 WFLog:@"%s: null networksMissingPassword" message:3];
    }
LABEL_14:
    id v6 = v5;
LABEL_18:
    objc_autoreleasePoolPop(v6);
    return;
  }

  uint64_t v3 = sub_100095BC8(a2);
  CFIndex v4 = objc_autoreleasePoolPush();
  if (!v3)
  {
    if (qword_100219F60) {
      [qword_100219F60 WFLog:@"%s: null ssid" message:3];
    }
    id v6 = v4;
    goto LABEL_18;
  }

  if (qword_100219F60) {
    [(id)qword_100219F60 WFLog:3, "%s: Remove %@, added at %@", "__WiFiDeviceManagerManageMissingPasswordList", v3, CFDictionaryGetValue(*(CFDictionaryRef *)(a1 + 3672), v3) message];
  }
  objc_autoreleasePoolPop(v4);
  CFDictionaryRemoveValue(*(CFMutableDictionaryRef *)(a1 + 3672), v3);
}

uint64_t sub_1000FD668(uint64_t a1, void *a2, int a3, int *a4)
{
  uint64_t v8 = *(unsigned int *)(a1 + 128);
  id v9 = sub_1000D91B0(a1, a2, 1);
  if (v9)
  {
    uint64_t v10 = v9;
    int v11 = sub_1000D3EF0(a1, v9);
    if (sub_10009F9B8((uint64_t)v10) != 1
      && sub_100096670((uint64_t)v10) != 1
      && *(_DWORD *)(a1 + 144) < v11)
    {
      int v12 = *(_DWORD *)(a1 + 3344);
      if (v12 == 6)
      {
        uint64_t v13 = (unsigned int *)(a1 + 140);
        int v14 = 2;
        goto LABEL_12;
      }

      if (v12 == 4)
      {
        uint64_t v13 = (unsigned int *)(a1 + 140);
        int v14 = 1;
        goto LABEL_12;
      }

      if (sub_10009F434((CFDictionaryRef *)a2)
        || objc_msgSend( +[WiFiAnalyticsManager sharedWiFiAnalyticsManager]( WiFiAnalyticsManager,  "sharedWiFiAnalyticsManager"),  "isMovingNetwork:",  a2))
      {
        uint64_t v13 = (unsigned int *)(a1 + 132);
        int v14 = 3;
        goto LABEL_12;
      }

      if (sub_10009F3D4((CFDictionaryRef *)a2)
        || objc_msgSend( +[WiFiAnalyticsManager sharedWiFiAnalyticsManager]( WiFiAnalyticsManager,  "sharedWiFiAnalyticsManager"),  "isOmnipresentNetwork:",  a2))
      {
        uint64_t v13 = (unsigned int *)(a1 + 132);
        int v14 = 4;
LABEL_12:
        uint64_t v8 = *v13;
        if (!a4) {
          goto LABEL_19;
        }
        goto LABEL_18;
      }
    }

    int v14 = 0;
    if (!a4)
    {
LABEL_19:
      if (*(void *)(a1 + 6152))
      {
        *(_DWORD *)bytes = v14;
        unsigned int v20 = sub_100096BF4((uint64_t)a2, @"RSSI");
        int v21 = v11;
        CFDataRef v15 = CFDataCreate(kCFAllocatorDefault, bytes, 12LL);
        if (v15)
        {
          CFDataRef v16 = v15;
          CFArrayAppendValue(*(CFMutableArrayRef *)(a1 + 6152), v15);
          CFRelease(v16);
LABEL_24:
          CFRelease(v10);
          return v8;
        }

        int v18 = objc_autoreleasePoolPush();
        if (qword_100219F60) {
          [qword_100219F60 WFLog:@"%s: null dataRef" message:4];
        }
      }

      else
      {
        int v18 = objc_autoreleasePoolPush();
        if (qword_100219F60) {
          [qword_100219F60 WFLog:@"%s: null excludedDueToAJThresholdThisSession" message:4];
        }
      }

      objc_autoreleasePoolPop(v18);
      goto LABEL_24;
    }

void sub_1000FD888(uint64_t a1)
{
  if (!a1)
  {
    uint64_t v1 = objc_autoreleasePoolPush();
    if (qword_100219F60) {
      [qword_100219F60 WFLog:@"%s: NULL manager" message:4];
    }
    objc_autoreleasePoolPop(v1);
  }

void sub_1000FD8E8(uint64_t a1, uint64_t a2)
{
  unsigned __int8 v9 = 0;
  unsigned int v8 = 0;
  uint64_t v3 = *(void *)(a1 + 32);
  if (v3)
  {
    CFIndex v4 = *(void (**)(uint64_t, unsigned int *, unsigned __int8 *, void))(v3 + 4528);
    if (v4)
    {
      v4(v3, &v8, &v9, *(void *)(v3 + 4536));
      uint64_t v5 = objc_autoreleasePoolPush();
      if (qword_100219F60) {
        objc_msgSend( (id)qword_100219F60,  "WFLog:message:",  3,  "%s BatteryInfo. batterylevel:%u. externalPowerSupply:%u",  "__WiFiDeviceManagerCreateNetworkDenyList_block_invoke",  v8,  v9);
      }
      objc_autoreleasePoolPop(v5);
      uint64_t v6 = 1LL;
      if (!a2) {
        return;
      }
LABEL_10:
      (*(void (**)(uint64_t, uint64_t, BOOL, void))(a2 + 16))(a2, v6, v9 != 0, v8);
      return;
    }
  }

  uint64_t v7 = objc_autoreleasePoolPush();
  if (qword_100219F60) {
    [qword_100219F60 WFLog:@"%s Callbacks not available " message:4];
  }
  objc_autoreleasePoolPop(v7);
  uint64_t v6 = 0LL;
  if (a2) {
    goto LABEL_10;
  }
}

uint64_t sub_1000FD9E8(uint64_t result, uint64_t a2)
{
  if (a2) {
    return (*(uint64_t (**)(uint64_t, uint64_t, BOOL))(a2 + 16))( a2,  1LL,  *(_DWORD *)(*(void *)(result + 32) + 176LL) == 1);
  }
  return result;
}

void sub_1000FDA10(uint64_t a1, uint64_t a2)
{
  if (a2) {
    (*(void (**)(uint64_t, uint64_t))(a2 + 16))(a2, 1LL);
  }
}

void sub_1000FDA5C(uint64_t a1)
{
  uint64_t v2 = *(void *)(a1 + 40);
  if (*(void *)(v2 + 240))
  {
    uint64_t v4 = *(void *)(a1 + 32);
    uint64_t v3 = (CFTypeRef *)(a1 + 32);
    (*(void (**)(uint64_t, void, const __CFString *, const CFBooleanRef, void))(v2 + 4736))( v2,  *(void *)(*(void *)(v4 + 8) + 24LL),  @"FailureCountCurrent",  kCFBooleanTrue,  *(void *)(v2 + 4744));
    CFRelease(v3[1]);
    uint64_t v5 = *v3;
  }

  else
  {
    CFRelease((CFTypeRef)v2);
    uint64_t v6 = *(void **)(a1 + 32);
    uint64_t v3 = (CFTypeRef *)(a1 + 32);
    uint64_t v5 = v6;
  }

  uint64_t v7 = *(const void **)(v5[1] + 24LL);
  if (v7)
  {
    CFRelease(v7);
    *(void *)(*((void *)*v3 + 1) + 24LL) = 0LL;
  }

uint64_t sub_1000FDAE4(uint64_t a1, const void *a2)
{
  uint64_t result = 0LL;
  if (a1)
  {
    if (a2)
    {
      uint64_t v5 = *(const __CFArray **)(a1 + 3520);
      if (!v5) {
        return sub_1000FDC1C(a1, a2);
      }
      v8.length = CFArrayGetCount(*(CFArrayRef *)(a1 + 3520));
      v8.location = 0LL;
      FirstIndexOfCFBooleanRef Value = CFArrayGetFirstIndexOfValue(v5, v8, a2);
      if (FirstIndexOfValue == -1) {
        return sub_1000FDC1C(a1, a2);
      }
      ValueAtIndex = CFArrayGetValueAtIndex(*(CFArrayRef *)(a1 + 3520), FirstIndexOfValue);
      if (!ValueAtIndex) {
        return sub_1000FDC1C(a1, a2);
      }
      uint64_t result = sub_1000FDC1C(a1, ValueAtIndex);
      if (!(_DWORD)result) {
        return sub_1000FDC1C(a1, a2);
      }
    }
  }

  return result;
}

void sub_1000FDB7C(uint64_t a1)
{
  uint64_t v2 = objc_autoreleasePoolPush();
  if (qword_100219F60) {
    [(id)qword_100219F60 WFLog:3, "%s: setting interface rank %s for network %@", "__WiFiDeviceManagerSetInterfaceRank_block_invoke", "kSCNetworkServicePrimaryRankDefault", sub_100095BC8(*(const void **)(a1 + 40)) message];
  }
  objc_autoreleasePoolPop(v2);
}

uint64_t sub_1000FDC1C(uint64_t a1, const void *a2)
{
  CFAbsoluteTime Current = CFAbsoluteTimeGetCurrent();
  CFDateRef v5 = CFDateCreate(kCFAllocatorDefault, Current);
  uint64_t v6 = 0LL;
  uint64_t v7 = 1LL;
  if (!a1 || !a2) {
    goto LABEL_153;
  }
  CFRange v8 = (const __CFString *)sub_100095BC8(a2);
  if (*(_BYTE *)(a1 + 3780))
  {
    unsigned __int8 v9 = v8;
    uint64_t v10 = CFStringCreateWithBytes( kCFAllocatorDefault,  (const UInt8 *)(a1 + 3781),  *(unsigned __int8 *)(a1 + 3813),  0x8000100u,  0);
    int v11 = v10;
    if (v10) {
      BOOL v12 = v9 == 0LL;
    }
    else {
      BOOL v12 = 1;
    }
    if (v12)
    {
      uint64_t v13 = 0LL;
      if (!v10) {
        goto LABEL_18;
      }
    }

    else if (CFStringCompare(v9, v10, 0LL))
    {
      int v14 = objc_autoreleasePoolPush();
      if (qword_100219F60) {
        [(id)qword_100219F60 WFLog:3, "WiFiRoam : using bssList. Network from scan results : [%@] and network ssid : [%@]", v11, v9 message];
      }
      objc_autoreleasePoolPop(v14);
      uint64_t v13 = 0LL;
    }

    else
    {
      uint64_t v13 = 1LL;
    }

    CFRelease(v11);
  }

  else
  {
    uint64_t v13 = 0LL;
  }

LABEL_148:
      IOPMAssertionID v53 = objc_autoreleasePoolPush();
      uint64_t v54 = (void *)qword_100219F60;
      if (qword_100219F60)
      {
        uint64_t v55 = sub_10003B2EC(v7);
        uint64_t v56 = sub_100095BC8(v40);
        unsigned int v57 = sub_100055BEC(*(void *)(a1 + 64));
        [v54 WFLog:3, "%s: WiFiRoam : AP environment is %@ for %@(%@). Last applied environment is %@. Early exit ? : [%hhu]. augment ed from scan results ? : [%hhu]", "__WiFiDeviceManagerEvaluateAPEnvironment", v55, v56, v66, sub_10003B2EC(v57), v36, v62 message];
      }

LABEL_153:
          if (!v5) {
            goto LABEL_155;
          }
          goto LABEL_154;
        }

        if ((_DWORD)v34 == 1)
        {
          unsigned int v36 = 0;
          uint64_t v7 = 2LL;
        }

        else
        {
          unsigned int v36 = 0;
          if ((_DWORD)v21 == 1 && v39 == 1) {
            uint64_t v7 = 3LL;
          }
          else {
            uint64_t v7 = 1LL;
          }
        }

        goto LABEL_138;
      }
    }

    else
    {
      id v46 = objc_autoreleasePoolPush();
      if (qword_100219F60) {
        [(id)qword_100219F60 WFLog:3, "%s: Network : %@ is not in known network list", "__WiFiDeviceManagerEvaluateAPEnvironment", sub_100095BC8(v65) message];
      }
      objc_autoreleasePoolPop(v46);
      double v41 = 0.0;
    }

    uint64_t v47 = objc_autoreleasePoolPush();
    if (qword_100219F60) {
      [(id)qword_100219F60 WFLog:3, "%s: failed to get last association date for %@.", "__WiFiDeviceManagerEvaluateAPEnvironment", sub_100095BC8(v65) message];
    }
    objc_autoreleasePoolPop(v47);
    goto LABEL_108;
  }

  uint64_t v59 = objc_autoreleasePoolPush();
  if (qword_100219F60) {
    [qword_100219F60 WFLog:@"%s: no known BSS for this network. Learning environment." message:3];
  }
  objc_autoreleasePoolPop(v59);
  uint64_t v7 = 1LL;
  if (!v5) {
    goto LABEL_155;
  }
LABEL_154:
  CFRelease(v5);
LABEL_155:
  if (v6) {
    CFRelease(v6);
  }
  return v7;
}

void sub_1000FE580(void *a1)
{
  uint64_t v2 = a1[6];
  if (*(void *)(v2 + 240))
  {
    uint64_t v3 = a1 + 5;
    (*(void (**)(uint64_t, void, void, void))(v2 + 4032))( v2,  *(void *)(*(void *)(a1[4] + 8LL) + 24LL),  *(void *)(v2 + 4040),  *(void *)(*(void *)(a1[5] + 8LL) + 24LL));
    uint64_t v4 = (void *)a1[6];
    CFDateRef v5 = (void (*)(void *, void, void, uint64_t, void))v4[548];
    if (v5)
    {
      v5(v4, a1[7], v4[549], 1LL, 0LL);
      uint64_t v4 = (void *)a1[6];
    }

    CFRelease(v4);
    uint64_t v6 = *(const void **)(*(void *)(a1[4] + 8LL) + 24LL);
    if (v6)
    {
      CFRelease(v6);
      *(void *)(*(void *)(a1[4] + 8LL) + 24LL) = 0LL;
    }

    uint64_t v7 = *(const void **)(*(void *)(*v3 + 8LL) + 24LL);
    if (!v7) {
      return;
    }
LABEL_12:
    CFRelease(v7);
    *(void *)(*(void *)(*v3 + 8LL) + 24LL) = 0LL;
    return;
  }

  CFRelease((CFTypeRef)v2);
  CFRange v8 = *(const void **)(*(void *)(a1[4] + 8LL) + 24LL);
  if (v8)
  {
    CFRelease(v8);
    *(void *)(*(void *)(a1[4] + 8LL) + 24LL) = 0LL;
  }

  uint64_t v10 = a1[5];
  unsigned __int8 v9 = a1 + 5;
  uint64_t v7 = *(const void **)(*(void *)(v10 + 8) + 24LL);
  if (v7)
  {
    uint64_t v3 = v9;
    goto LABEL_12;
  }

void sub_1000FE674(uint64_t a1, uint64_t a2, int a3, int a4)
{
  if (!*(_BYTE *)(a1 + 940)) {
    return;
  }
  unsigned __int16 v8 = (unsigned __int16)sub_10009A3DC(a2);
  int v9 = sub_10009A3FC(a2);
  __int128 v45 = 0u;
  __int128 v46 = 0u;
  __int128 v47 = 0u;
  __int128 v48 = 0u;
  __int128 v49 = 0u;
  __int128 v50 = 0u;
  __int128 v51 = 0u;
  __int128 v52 = 0u;
  __int128 v53 = 0u;
  __int128 v54 = 0u;
  __int128 v55 = 0u;
  LODWORD(v45) = (CFAbsoluteTimeGetCurrent() - *(double *)(a1 + 736));
  LODWORD(v52) = a4;
  uint64_t v10 = sub_10003B050(a3);
  int v11 = @"unknown";
  if (v10) {
    int v11 = v10;
  }
  *((void *)&v51 + 1) = v11;
  if ((v8 & 0x100) != 0)
  {
    BOOL v12 = @"11ax";
  }

  else if ((v8 & 0x80) != 0)
  {
    BOOL v12 = @"11ac";
  }

  else if ((v8 & 0x10) != 0)
  {
    BOOL v12 = @"11n";
  }

  else
  {
    BOOL v12 = @"legacy";
  }

  *((void *)&v52 + 1) = v12;
  uint64_t v13 = (_OWORD *)(a1 + 1016);
  WORD5(v50) = v9;
  *(void *)uint64_t v44 = @"Unknown";
  *(void *)&v44[8] = @"Unknown";
  *(void *)&v44[16] = @"Unknown";
  if (*(void *)(a1 + 8720))
  {
    *(void *)uint64_t v44 = *(void *)(a1 + 8720);
    *(_OWORD *)&v44[8] = *(_OWORD *)(a1 + 8728);
  }

  *(void *)((char *)&v45 + 4) = *(void *)(a1 + 744);
  int v14 = (int)*(double *)(a1 + 760);
  HIDWORD(v45) = *(_DWORD *)(a1 + 752);
  LODWORD(v46) = v14;
  DWORD1(v46) = *(_DWORD *)(a1 + 756);
  *((void *)&v46 + 1) = *(void *)(a1 + 768);
  int v15 = *(_DWORD *)(a1 + 776);
  LODWORD(v47) = (int)*(double *)(a1 + 784);
  DWORD1(v47) = v15;
  *((void *)&v47 + 1) = *(void *)(a1 + 792);
  int v16 = *(_DWORD *)(a1 + 800);
  LODWORD(v4_Block_object_dispose((const void *)(v1 - 152), 8) = (int)*(double *)(a1 + 808);
  DWORD1(v4_Block_object_dispose((const void *)(v1 - 152), 8) = v16;
  *((void *)&v48 + 1) = *(void *)(a1 + 816);
  int v17 = *(_DWORD *)(a1 + 824);
  LODWORD(v49) = (int)*(double *)(a1 + 832);
  DWORD1(v49) = v17;
  *((void *)&v49 + 1) = *(void *)(a1 + 840);
  int v18 = *(_DWORD *)(a1 + 848);
  LODWORD(v50) = (int)*(double *)(a1 + 856);
  DWORD1(v50) = v18;
  if (*(_DWORD *)(a1 + 884)) {
    int v19 = 1;
  }
  else {
    int v19 = 5;
  }
  HIDWORD(v50) = *(_DWORD *)(a1 + 864);
  LODWORD(v51) = v19;
  uint64_t v20 = (const __CFNumber *)sub_100096A74(a2);
  if (v20)
  {
    __int16 valuePtr = -21846;
    CFNumberGetValue(v20, kCFNumberSInt16Type, &valuePtr);
    __int16 v21 = valuePtr;
  }

  else
  {
    __int16 v21 = 0;
  }

  WORD4(v50) = v21;
  *(void *)(a1 + 1040) = 0LL;
  if (*(_BYTE *)(a1 + 1000))
  {
    if (*(double *)(a1 + 832) <= 60.0)
    {
      int v22 = *(_DWORD *)(a1 + 752);
      if (v22)
      {
        double v23 = 1.0 / (double)v22;
        double v24 = v23
            * (double)(8
                     * (unint64_t)((double)(800
        double v25 = v24 / (double)(1000 * v45);
        if ((v8 & 0x100) != 0)
        {
          if (v9 == 80 && v22 > 600500) {
            goto LABEL_44;
          }
          if (v9 == 20)
          {
            int v28 = 143400;
          }

          else
          {
            if (v9 != 40) {
              goto LABEL_45;
            }
            int v28 = 286800;
          }

          goto LABEL_43;
        }

        if ((v8 & 0x80) != 0)
        {
          if (v9 == 80 && v22 > 433300) {
            goto LABEL_44;
          }
          if (v9 != 20)
          {
            if (v9 != 40) {
              goto LABEL_45;
            }
            int v28 = 200000;
            goto LABEL_43;
          }

          unsigned __int16 v29 = 21164;
        }

        else
        {
          if ((v8 & 0x10) == 0)
          {
            int v26 = 0;
            uint64_t v27 = "N";
LABEL_47:
            unsigned int v39 = objc_autoreleasePoolPush();
            if (qword_100219F60)
            {
              uint64_t v40 = "Y";
              if (!v26) {
                uint64_t v40 = "N";
              }
              [(id)qword_100219F60 WFLog:3, "%s: LPC - valid %s, rssi %.1lf, txRateMax %d, totalTxFrames %llu, bitAirTime %.4lf (us), totalAirTime %. 2lf (ms), txDutyCycle %.3lf (%%), phyMode %@, isMimo %s, duration %d (s), power reduction %.2lf (uAh), t xoffset %d:%d:%d:%d (%%)", "__WiFiDeviceManagerSubmitCarPlayLinkQualityMetrics", v27, *(void *)(a1 + 832), *(unsigned int *)(a1 + 752), *(void *)(a1 + 944), v23 * 1000.0, *(void *)&v24, v25 * 100.0, *((void *)&v52 + 1), v40, v45, *(void *)(a1 + 1040), *(unsigned int *)(a1 + 1016), *(unsigned int *)(a1 + 1020), *(unsigned int *)(a1 + 1024), *(unsigned int *)(a1 + 1028) message];
            }

            objc_autoreleasePoolPop(v39);
            goto LABEL_52;
          }

          if (v9 == 40 && v22 > 150000) {
            goto LABEL_44;
          }
          if (v9 != 20) {
            goto LABEL_45;
          }
          unsigned __int16 v29 = 6664;
        }

        int v28 = v29 | 0x10000;
LABEL_43:
        if (v22 > v28)
        {
LABEL_44:
          int v26 = 1;
          double v30 = 40.0;
LABEL_46:
          v31.i64[0] = (int)*(void *)(a1 + 1024);
          v31.i64[1] = (int)HIDWORD(*v13);
          float64x2_t v32 = vcvtq_f64_s64(v31);
          v31.i64[0] = (int)*v13;
          v31.i64[1] = (int)HIDWORD(*(void *)v13);
          float64x2_t v33 = (float64x2_t)vdupq_n_s64(0x4059000000000000uLL);
          float64x2_t v34 = vdivq_f64(vcvtq_f64_s64(v31), v33);
          float64x2_t v35 = vdivq_f64(v32, v33);
          float64x2_t v36 = vmulq_n_f64((float64x2_t)xmmword_10017FBC0, v30);
          float64x2_t v37 = vmulq_f64(v35, vmulq_n_f64((float64x2_t)xmmword_10017FBD0, v30));
          float64x2_t v38 = vmulq_f64(v34, v36);
          v37.f64[0] = v25 * (v38.f64[0] + 0.0 + v38.f64[1] + v37.f64[0] + v37.f64[1]) * 1000.0;
          *(float64_t *)(a1 + 1040) = v37.f64[0];
          LOBYTE(v53) = 1;
          *((void *)&v53 + 1) = *(void *)(a1 + 1008);
          __int128 v54 = *(_OWORD *)(a1 + 1016);
          *((void *)&v55 + 1) = *(void *)&v37.f64[0];
          uint64_t v27 = "Y";
          goto LABEL_47;
        }

void sub_1000FEC90(uint64_t a1, void *a2)
{
  if (a2)
  {
    BOOL v3 = sub_100053B20(*(void *)(*(void *)(a1 + 32) + 64LL)) != 1;
    [*(id *)(*(void *)(a1 + 32) + 7320) setLinkEvent:1 isInvoluntary:v3 linkChangeReason:0 linkChangeSubreason:0 withNetworkDetails:a2 forInterface:sub_100043E8C(*(void *)(*(void *)(a1 + 32) + 64))];
  }

void sub_1000FED08(uint64_t a1, const void *a2)
{
  if (*(_BYTE *)(a1 + 7008))
  {
    if (a2)
    {
      if (sub_10009EFD8((uint64_t)a2)
        || sub_10009860C((uint64_t)a2)
        || sub_100095B4C((uint64_t)a2)
        || sub_1000973BC((uint64_t)a2)
        || sub_1000971F8(a2))
      {
        return;
      }

      int v7 = sub_1000992D0((uint64_t)a2);
      if (v7) {
        __int16 v4 = 1 << v7;
      }
      else {
        __int16 v4 = 0;
      }
      uint64_t v6 = *(void *)(a1 + 64);
      CFDateRef v5 = sub_100095BC8(a2);
    }

    else
    {
      __int16 v4 = 0;
      CFDateRef v5 = 0LL;
      uint64_t v6 = *(void *)(a1 + 64);
    }

    sub_100045C2C(v6, 0, v4, v5);
  }

void sub_1000FEDD0(uint64_t a1, void *a2)
{
  if (a2)
  {
    [*(id *)(*(void *)(a1 + 32) + 7320) setLinkEvent:0 isInvoluntary:*(_BYTE *)(a1 + 52) != 0 linkChangeReason:*(void *)(a1 + 40) linkChangeSubreason:*(int *)(a1 + 48) withNetworkDetails:a2 forInterface:sub_100043E8C(*(void *)(*(void *)(a1 + 32) + 64))];
  }

void sub_1000FEE48(uint64_t a1)
{
  if (*(void *)(a1 + 120))
  {
    if (*(void *)(a1 + 5552))
    {
      uint64_t v2 = objc_autoreleasePoolPush();
      if (qword_100219F60) {
        [(id)qword_100219F60 WFLog:3 message:"Ignore Pending Active Probe !"];
      }
      objc_autoreleasePoolPop(v2);
      sub_10001BA7C(*(void *)(a1 + 120), *(CFTypeRef *)(a1 + 5552));
      BOOL v3 = *(const void **)(a1 + 5552);
      if (v3)
      {
        CFRelease(v3);
        *(void *)(a1 + 5552) = 0LL;
      }
    }
  }

  else
  {
    __int16 v4 = objc_autoreleasePoolPush();
    if (qword_100219F60) {
      [(id)qword_100219F60 WFLog:4 message:"Null LQA manager\n"];
    }
    objc_autoreleasePoolPop(v4);
  }

void sub_1000FEEF8(uint64_t a1)
{
  uint64_t v2 = objc_autoreleasePoolPush();
  if ((_os_feature_enabled_impl("CoreWiFi", "UnifiedAutoJoin") & 1) == 0)
  {
    BOOL v12 = objc_autoreleasePoolPush();
    if (qword_100219F60) {
      [qword_100219F60 WFLog:@"__WiFiDeviceManagerUnifiedAutoJoinUpdateAssociatedNetwork: UAJM feature is disabled"];
    }
    goto LABEL_17;
  }

  if (!a1)
  {
    BOOL v12 = objc_autoreleasePoolPush();
    if (qword_100219F60) {
      [qword_100219F60 WFLog:@"%s: manager is null" message:4];
    }
LABEL_17:
    uint64_t v13 = v12;
LABEL_21:
    objc_autoreleasePoolPop(v13);
    goto LABEL_12;
  }

  uint64_t v3 = *(void *)(a1 + 8776);
  __int16 v4 = objc_autoreleasePoolPush();
  if (!v3)
  {
    if (qword_100219F60) {
      [qword_100219F60 WFLog:@"%s: UAJM is null" message:4];
    }
    uint64_t v13 = v4;
    goto LABEL_21;
  }

  uint64_t v5 = *(void *)(a1 + 64);
  if (v5)
  {
    uint64_t v6 = (const void *)sub_100043E8C(v5);
    int v7 = (CFDictionaryRef *)sub_1000DEA34(a1, v6, 1);
    unsigned __int16 v8 = v7;
    if (v7)
    {
      id v9 = sub_1000A335C((uint64_t)v7);
      if (v9)
      {
        uint64_t v10 = sub_1000A063C(v8);
        if (v10)
        {
          id v11 = [v9 scanResultWithMatchingKnownNetworkProfile:v10];

          id v9 = v11;
        }

        goto LABEL_9;
      }
    }

    else
    {
      id v9 = 0LL;
    }

    uint64_t v10 = 0LL;
  }

  else
  {
    id v9 = 0LL;
    uint64_t v10 = 0LL;
    unsigned __int16 v8 = 0LL;
  }

void sub_1000FF0B4(int a1, uint64_t a2, CFDictionaryRef theDict, uint64_t a4, uint64_t a5)
{
  if (!theDict || !a5) {
    return;
  }
  CFBooleanRef Value = (const __CFBoolean *)CFDictionaryGetValue(theDict, @"LINK_CHANGED_IS_AVAILABLE");
  if (!Value)
  {
    int v14 = *(void (**)(uint64_t, uint64_t, void, CFDictionaryRef))(a5 + 4432);
    if (!v14) {
      return;
    }
    goto LABEL_21;
  }

  id v9 = Value;
  int v10 = CFBooleanGetValue(Value);
  id v11 = objc_autoreleasePoolPush();
  if (qword_100219F60)
  {
    BOOL v12 = "TRUE";
    if (v10) {
      uint64_t v13 = "TRUE";
    }
    else {
      uint64_t v13 = "FALSE";
    }
    if (!*(_BYTE *)(a5 + 5421)) {
      BOOL v12 = "FALSE";
    }
    [qword_100219F60 WFLog:@"%s: AWDL availability changed to %s, pendingRequest %s" message:3,  "__WiFiDeviceManagerAwdlAvailableCallback",  v13,  v12];
  }

  objc_autoreleasePoolPop(v11);
  int v14 = *(void (**)(uint64_t, uint64_t, void, CFDictionaryRef))(a5 + 4432);
  if (v14)
  {
    if (*(void *)(a5 + 5400))
    {
      int v15 = objc_autoreleasePoolPush();
      MutableCFStringRef Copy = CFDictionaryCreateMutableCopy(kCFAllocatorDefault, 0LL, theDict);
      if (MutableCopy)
      {
        int v17 = MutableCopy;
        if (![*(id *)(a5 + 5400) isPowerResourceAvailable:1]
          || (CFBooleanRef v18 = kCFBooleanTrue, !CFEqual(v9, kCFBooleanTrue)))
        {
          CFBooleanRef v18 = kCFBooleanFalse;
        }

        CFDictionarySetValue(v17, @"LINK_CHANGED_IS_AVAILABLE", v18);
        objc_autoreleasePoolPop(v15);
        (*(void (**)(uint64_t, uint64_t, void, __CFDictionary *))(a5 + 4432))( a5,  a2,  *(void *)(a5 + 4440),  v17);
        CFRelease(v17);
        return;
      }

      objc_autoreleasePoolPop(v15);
      int v14 = *(void (**)(uint64_t, uint64_t, void, CFDictionaryRef))(a5 + 4432);
    }

void sub_1000FF280(int a1, const void *a2, CFDictionaryRef theDict, uint64_t a4, uint64_t a5)
{
  if (theDict && a5)
  {
    unsigned __int16 v8 = (BOOL *)(a5 + 5420);
    CFBooleanRef Value = CFDictionaryGetValue(theDict, @"LINK_CHANGED_IS_LINKDOWN");
    if (Value)
    {
      int v10 = CFEqual(Value, kCFBooleanTrue);
      int v11 = *(_DWORD *)(a5 + 5416);
      if (v10)
      {
        if (v11)
        {
          BOOL v12 = objc_autoreleasePoolPush();
          if (qword_100219F60) {
            [qword_100219F60 WFLog:@"%s: AWDL link-down received when refCount is %d" message:3, "%s: AWDL link-down received when refCount is %d", "__WiFiDeviceManagerAwdlLinkEventCallback", *(unsigned int *)(a5 + 5416)];
          }
          objc_autoreleasePoolPop(v12);
          if (!*(_BYTE *)(a5 + 5421)
            && (objc_msgSend( +[WiFiP2PAWDLState currentState](WiFiP2PAWDLState, "currentState"),  "isEnabled") & 1) == 0)
          {
            uint64_t v13 = objc_autoreleasePoolPush();
            if (qword_100219F60) {
              [qword_100219F60 WFLog:@"%s: AWDL link-down tearing down all active AWDL sessions" message:3];
            }
            objc_autoreleasePoolPop(v13);
            sub_1000D00D8(a5, a2);
          }
        }
      }

      else if (v11)
      {
        kdebug_trace(731381788LL, 0LL, 0LL, 0LL, 0LL);
        int v14 = objc_autoreleasePoolPush();
        if (qword_100219F60) {
          [qword_100219F60 WFLog:@"%s: AWDL link up, refcount %d" message:4, "%s: AWDL link up, refcount %d",  "__WiFiDeviceManagerAwdlLinkEventCallback",  *(unsigned int *)(a5 + 5416)];
        }
        objc_autoreleasePoolPop(v14);
      }

      int v15 = *(void **)(a5 + 7320);
      if (v15) {
        [v15 setAwdlState:v10 == 0 inMode:0];
      }
    }

    else
    {
      int v10 = 1;
    }

    v16.n128_f64[0] = sub_1000CF880(a5, 2, v10 == 0);
    int v17 = *(void (**)(uint64_t, const void *, void, CFDictionaryRef, double))(a5 + 4432);
    if (v17) {
      v17(a5, a2, *(void *)(a5 + 4440), theDict, v16.n128_f64[0]);
    }
    CFBooleanRef v18 = *(void (**)(uint64_t, const void *, void, uint64_t, CFDictionaryRef, __n128))(a5 + 4384);
    if (v18) {
      v18(a5, a2, *(void *)(a5 + 4392), 3LL, theDict, v16);
    }
    if (v10 && *v8)
    {
      int v19 = objc_autoreleasePoolPush();
      if (qword_100219F60) {
        [qword_100219F60 WFLog:@"__WiFiDeviceManagerAwdlLinkEventCallback: hosted AWDL session is down. Triggering auto-join"];
      }
      objc_autoreleasePoolPop(v19);
      if (_os_feature_enabled_impl("CoreWiFi", "UnifiedAutoJoin"))
      {
        sub_1000F5F98(a5, 9uLL);
      }

      else
      {
        [+[WiFiXPCManager sharedXPCManager](WiFiXPCManager, "sharedXPCManager") autoJoinStartedWithTrigger:9 interfaceName:sub_100043E8C(*(void *)(a5 + 64))];
        sub_1000D0A5C(a5, 0LL, (uint64_t)"__WiFiDeviceManagerAwdlLinkEventCallback");
      }
    }

    *unsigned __int16 v8 = v10 == 0;
  }

void sub_1000FF530(uint64_t a1, uint64_t a2, uint64_t a3)
{
  if (a3)
  {
    if (*(unsigned __int8 *)(a3 + 3406) != (_DWORD)a2)
    {
      uint64_t v5 = objc_autoreleasePoolPush();
      if (qword_100219F60) {
        [qword_100219F60 WFLog:@"__WiFiDeviceManagerAwdlRealTimeModeEventCallback AwdlRealTime: Before %d, Now %d" message:3, *(unsigned __int8 *)(a3 + 3406), a2];
      }
      objc_autoreleasePoolPop(v5);
      *(_BYTE *)(a3 + 3406) = a2;
      -[WiFiUsageMonitor updateRealTimeCoex:type:reasons:]( +[WiFiUsageMonitor sharedInstance](WiFiUsageMonitor, "sharedInstance"),  "updateRealTimeCoex:type:reasons:",  (_DWORD)a2 != 0,  0,  objc_msgSend(  objc_msgSend( objc_alloc_init(WiFiP2PAWDLStateMonitor),  "copyActiveServiceUniqueIdentifiers"),  "sortedArrayUsingSelector:",  "localizedCaseInsensitiveCompare:"));
      if (+[WiFiRoamManager sharedWiFiRoamManager](&OBJC_CLASS___WiFiRoamManager, "sharedWiFiRoamManager")) {
        [+[WiFiRoamManager sharedWiFiRoamManager](WiFiRoamManager, "sharedWiFiRoamManager") setAwdlRealTimeModeActive:*(_BYTE *)(a3 + 3406) != 0];
      }
      if (sub_100055A48(*(void *)(a3 + 64)) && !sub_1000EBA5C(a3))
      {
        if (!(_DWORD)a2 && CFAbsoluteTimeGetCurrent() - *(double *)(a3 + 3720) > 60.0)
        {
          sub_1000DF940(a3, 0);
          *(CFAbsoluteTime *)(a3 + 3720) = CFAbsoluteTimeGetCurrent();
        }
      }

      else if (!(_DWORD)a2)
      {
        if (_os_feature_enabled_impl("CoreWiFi", "UnifiedAutoJoin"))
        {
          sub_1000F5F98(a3, 0x39uLL);
        }

        else if (*(_BYTE *)(a3 + 3403))
        {
          sub_1000D66BC(a3, 3);
        }

        else
        {
          sub_1000D0A5C(a3, 2LL, (uint64_t)"__WiFiDeviceManagerAwdlRealTimeModeEventCallback");
        }
      }

      sub_1000CF880(a3, 2, a2);
      int v7 = (const __CFString *)sub_100040CF8(*(void *)(a3 + 64));
      unsigned __int16 v8 = sub_1000DF0C8(a3, v7);
      if (v8)
      {
        id v9 = v8;
        MutableCFStringRef Copy = CFDictionaryCreateMutableCopy(kCFAllocatorDefault, 0LL, v8);
        CFRelease(v9);
        if (MutableCopy)
        {
          int v11 = (const void **)&kCFBooleanTrue;
          if (!(_DWORD)a2) {
            int v11 = (const void **)&kCFBooleanFalse;
          }
          CFDictionarySetValue(MutableCopy, @"AWDL_REAL_TIME_MODE", *v11);
          BOOL v12 = *(void (**)(uint64_t, int64_t, void, __CFDictionary *))(a3 + 4432);
          if (v12)
          {
            int64_t v13 = sub_100040CF8(*(void *)(a3 + 64));
            v12(a3, v13, *(void *)(a3 + 4440), MutableCopy);
          }

          CFRelease(MutableCopy);
        }
      }

      if ((_DWORD)a2)
      {
        CFAbsoluteTime Current = CFAbsoluteTimeGetCurrent();
        CFDateRef v15 = CFDateCreate(kCFAllocatorDefault, Current);
        if (v15)
        {
          CFDateRef v16 = v15;
          int v17 = (const void *)sub_100043E8C(*(void *)(a3 + 64));
          CFBooleanRef v18 = sub_1000DEA34(a3, v17, 1);
          if (v18)
          {
            int v19 = v18;
            sub_10009B324(v18, v16);
            sub_1000DAB00((dispatch_queue_s **)a3, v19);
            CFRelease(v19);
          }

          CFRelease(v16);
        }

        sub_1000FFC68(a3);
      }
    }
  }

  else
  {
    uint64_t v6 = objc_autoreleasePoolPush();
    if (qword_100219F60) {
      [qword_100219F60 WFLog:@"%s: NULL Device Manager !" message:3];
    }
    objc_autoreleasePoolPop(v6);
  }

void sub_1000FF860(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5)
{
  if (a3 && a5)
  {
    if (*(_DWORD *)(a5 + 5416))
    {
      kdebug_trace(731381792LL, 0LL, 0LL, 0LL, 0LL);
      unsigned __int16 v8 = objc_autoreleasePoolPush();
      if (qword_100219F60) {
        [qword_100219F60 WFLog:@"%s: peer list changed" message:4];
      }
      objc_autoreleasePoolPop(v8);
    }

    id v9 = *(void (**)(uint64_t, uint64_t, void, uint64_t))(a5 + 4432);
    if (v9) {
      v9(a5, a2, *(void *)(a5 + 4440), a3);
    }
  }

void sub_1000FF928(uint64_t a1, uint64_t a2, uint64_t a3)
{
  uint64_t v5 = objc_autoreleasePoolPush();
  if (a3)
  {
    uint64_t v6 = (unsigned __int8 *)(a3 + 5208);
    if (qword_100219F60) {
      [qword_100219F60 WFLog:@"__WiFiDeviceManagerSoftAPChannelChangedEventCallback Channel %d  %d" message:3,  "%s: Channel %d  %d",  "__WiFiDeviceManagerSoftAPChannelChangedEventCallback",  a2,  *v6];
    }
    objc_autoreleasePoolPop(v5);
    if (*(_BYTE *)(a3 + 5211))
    {
      unsigned int v7 = *v6;
      if (v7 != (_DWORD)a2 && (a2 >= 0xF && v7 > 0xE || a2 <= 0xD && v7 <= 0xD))
      {
        unsigned __int8 *v6 = a2;
        CFSetAddValue(*(CFMutableSetRef *)(a3 + 5264), @"wifid");
        sub_1000DCD9C(a3, 0);
        sub_1000457AC(*(void *)(a3 + 64), 0);
        sub_1000DC9F0(a3, 5LL);
        unsigned __int16 v8 = sub_1000DEFF8(a3);
        if (v8)
        {
          id v9 = v8;
          int valuePtr = -1431655766;
          int Count = CFArrayGetCount(v8);
          if (Count >= 1)
          {
            CFIndex v11 = 0LL;
            uint64_t v12 = Count;
            do
            {
              ValueAtIndex = CFArrayGetValueAtIndex(v9, v11);
              if (ValueAtIndex)
              {
                int v14 = ValueAtIndex;
                CFDateRef v15 = (const __CFNumber *)sub_1000951FC((uint64_t)ValueAtIndex, @"networkRole");
                if (v15)
                {
                  CFNumberGetValue(v15, kCFNumberSInt32Type, &valuePtr);
                  if (valuePtr == 3)
                  {
                    int v18 = *v6;
                    CFNumberRef v16 = CFNumberCreate(kCFAllocatorDefault, kCFNumberSInt32Type, &v18);
                    if (!v16) {
                      break;
                    }
                    CFNumberRef v17 = v16;
                    CFSetRemoveValue(*(CFMutableSetRef *)(a3 + 3312), v14);
                    sub_10009582C((uint64_t)v14, @"CHANNEL", v17);
                    CFSetAddValue(*(CFMutableSetRef *)(a3 + 3312), v14);
                    CFRelease(v17);
                  }
                }
              }

              ++v11;
            }

            while (v12 != v11);
          }

          CFRelease(v9);
        }
      }
    }
  }

  else
  {
    if (qword_100219F60) {
      [qword_100219F60 WFLog:@"%s: deviceManagerRef is Null!"];
    }
    objc_autoreleasePoolPop(v5);
  }

void sub_1000FFB58(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  if (!a3)
  {
    int v10 = objc_autoreleasePoolPush();
    if (qword_100219F60) {
      [qword_100219F60 WFLog:@"%s: deviceManagerRef is Null!"];
    }
    id v9 = v10;
    goto LABEL_9;
  }

  uint64_t v7 = *(void *)(a3 + 4752);
  unsigned __int16 v8 = objc_autoreleasePoolPush();
  if (!v7)
  {
    if (qword_100219F60) {
      [qword_100219F60 WFLog:@"%s: p2pThreadCoex callback is NULL!" message:3];
    }
    id v9 = v8;
LABEL_9:
    objc_autoreleasePoolPop(v9);
    return;
  }

  if (qword_100219F60) {
    [(id)qword_100219F60 WFLog:3, "%s: p2pThreadCoexEventDict:%@ ", "__WiFiDeviceManagerP2pThreadCoexEventCallback", a4 message];
  }
  objc_autoreleasePoolPop(v8);
  (*(void (**)(uint64_t, uint64_t, void, uint64_t))(a3 + 4752))(a3, a2, *(void *)(a3 + 4760), a4);
}

void sub_1000FFC68(uint64_t a1)
{
  uint64_t v2 = objc_autoreleasePoolPush();
  if (!a1)
  {
    float64x2_t v33 = objc_autoreleasePoolPush();
    if (qword_100219F60) {
      [qword_100219F60 WFLog:@"%s: WiFiDeviceManagerRef is NULL" message:3];
    }
    float64x2_t v34 = v33;
    goto LABEL_59;
  }

  uint64_t v3 = sub_1000539A4(*(void *)(a1 + 64), 0);
  __int16 v4 = objc_autoreleasePoolPush();
  if (!v3)
  {
    if (qword_100219F60) {
      [qword_100219F60 WFLog:@"%s: CFArrayCreateMutable() returned NULL" message:3];
    }
    float64x2_t v34 = v4;
LABEL_59:
    objc_autoreleasePoolPop(v34);
LABEL_60:
    CFIndex v11 = 0LL;
    uint64_t v6 = 0LL;
    goto LABEL_52;
  }

  if (CFArrayGetCount(v3) < 1)
  {
    objc_autoreleasePoolPop(v4);
LABEL_27:
    int v22 = objc_autoreleasePoolPush();
    if (qword_100219F60) {
      [qword_100219F60 WFLog:@"%s: __WiFiDeviceManagerCreateCoreWiFiScanResultsFromNetworks() returned NULL" message:3];
    }
    objc_autoreleasePoolPop(v22);
    uint64_t v6 = 0LL;
    goto LABEL_30;
  }

  CFIndex v5 = 0LL;
  uint64_t v6 = 0LL;
  do
  {
    ValueAtIndex = CFArrayGetValueAtIndex(v3, v5);
    if (ValueAtIndex)
    {
      id v8 = sub_1000A335C((uint64_t)ValueAtIndex);
      if (v8)
      {
        id v9 = v8;
        if (!v6) {
          uint64_t v6 = objc_alloc_init(&OBJC_CLASS___NSMutableArray);
        }
        -[NSMutableArray addObject:](v6, "addObject:", v9);
      }
    }

    ++v5;
  }

  while (CFArrayGetCount(v3) > v5);
  objc_autoreleasePoolPop(v4);
  if (!v6) {
    goto LABEL_27;
  }
  id v10 = sub_1000D9F24(a1);
  if (v10)
  {
    CFIndex v11 = v10;
    unsigned int v39 = v6;
    uint64_t v12 = (void *)CWFColocatedNetworksMatchingScanResult( v10,  v6,  objc_msgSend(objc_msgSend(*(id *)(a1 + 8776), "knownNetworks"), "allObjects"));
    int64_t v13 = &ACAccountStoreDidChangeNotification_ptr;
    id v14 = -[NSUserDefaults objectForKey:]( +[NSUserDefaults standardUserDefaults](&OBJC_CLASS___NSUserDefaults, "standardUserDefaults"),  "objectForKey:",  @"UserDismissedColocatedSSIDTimestamps");
    __int128 v44 = 0u;
    __int128 v45 = 0u;
    __int128 v46 = 0u;
    __int128 v47 = 0u;
    CFDateRef v15 = v12;
    id v16 = [v12 countByEnumeratingWithState:&v44 objects:v49 count:16];
    if (v16)
    {
      id v17 = v16;
      float64x2_t v37 = v11;
      uint64_t v36 = a1;
      uint64_t v18 = *(void *)v45;
LABEL_16:
      uint64_t v19 = 0LL;
      while (1)
      {
        if (*(void *)v45 != v18) {
          objc_enumerationMutation(v15);
        }
        uint64_t v20 = *(void **)(*((void *)&v44 + 1) + 8 * v19);
        if (!objc_msgSend( objc_msgSend(v14, "allKeys"),  "containsObject:",  +[NSString stringWithFormat:]( NSString,  "stringWithFormat:",  @"%@",  objc_msgSend(v20, "networkName")))) {
          break;
        }
        __int16 v21 = objc_autoreleasePoolPush();
        if (qword_100219F60) {
          [(id)qword_100219F60 WFLog:3, "%s: Colocated SSID candidate already dismissed by user (%@)", "__WiFiDeviceManagerCheckForColocatedSSIDs", v20 message];
        }
        objc_autoreleasePoolPop(v21);
        if (v17 == (id)++v19)
        {
          id v17 = [v15 countByEnumeratingWithState:&v44 objects:v49 count:16];
          if (v17) {
            goto LABEL_16;
          }
          uint64_t v20 = 0LL;
          break;
        }
      }

      a1 = v36;
      CFIndex v11 = v37;
      int64_t v13 = &ACAccountStoreDidChangeNotification_ptr;
    }

    else
    {
      uint64_t v20 = 0LL;
    }

    uint64_t v6 = v39;
    if (os_variant_has_internal_content("com.apple.WiFiManager"))
    {
      id v23 = objc_msgSend( objc_msgSend((id)v13[412], "standardUserDefaults"),  "objectForKey:",  @"ColocatedSSIDNotificationForceMatchSSID");
      if (v23)
      {
        id v24 = v23;
        __int128 v42 = 0u;
        __int128 v43 = 0u;
        __int128 v40 = 0u;
        __int128 v41 = 0u;
        id v25 = -[NSMutableArray countByEnumeratingWithState:objects:count:]( v39,  "countByEnumeratingWithState:objects:count:",  &v40,  v48,  16LL);
        if (v25)
        {
          id v26 = v25;
          float64x2_t v38 = v11;
          uint64_t v27 = a1;
          uint64_t v28 = *(void *)v41;
          while (2)
          {
            for (CFIndex i = 0LL; i != v26; CFIndex i = (char *)i + 1)
            {
              if (*(void *)v41 != v28) {
                objc_enumerationMutation(v39);
              }
              double v30 = *(void **)(*((void *)&v40 + 1) + 8LL * (void)i);
              if (objc_msgSend(objc_msgSend(v30, "networkName"), "isEqualToString:", v24))
              {
                int64x2_t v31 = objc_autoreleasePoolPush();
                if (qword_100219F60) {
                  [(id)qword_100219F60 WFLog:3, "%s: [internal] Force matched SSID candidate %@", "__WiFiDeviceManagerCheckForColocatedSSIDs", v20 message];
                }
                objc_autoreleasePoolPop(v31);
                uint64_t v20 = v30;
                goto LABEL_46;
              }
            }

            id v26 = -[NSMutableArray countByEnumeratingWithState:objects:count:]( v39,  "countByEnumeratingWithState:objects:count:",  &v40,  v48,  16LL);
            if (v26) {
              continue;
            }
            break;
          }

void sub_1001001B0(uint64_t a1, void *a2)
{
  if (a2)
  {
    BOOL v3 = sub_100053B20(*(void *)(*(void *)(a1 + 32) + 64LL)) != 1;
    [*(id *)(*(void *)(a1 + 32) + 7320) setLinkEvent:1 isInvoluntary:v3 linkChangeReason:0 linkChangeSubreason:0 withNetworkDetails:a2 forInterface:sub_100043E8C(*(void *)(*(void *)(a1 + 32) + 64))];
  }

void sub_100100228(dispatch_queue_s **a1, const void *a2, int a3, int a4)
{
  if (a1 && a2 && a3)
  {
    sub_10009582C( (uint64_t)a2,  @"TransitionDisabledFlags",  +[NSNumber numberWithUnsignedInt:](&OBJC_CLASS___NSNumber, "numberWithUnsignedInt:"));
    if (a4) {
      sub_1000DAB00(a1, a2);
    }
  }

void sub_1001002A4(uint64_t a1, const void *a2, const __CFDictionary *a3)
{
  if (!a1)
  {
    __int128 v50 = objc_autoreleasePoolPush();
    if (qword_100219F60) {
      [qword_100219F60 WFLog:@"%s, WiFiDeviceManagerRef is NULL" message:4];
    }
    goto LABEL_71;
  }

  if (!a3)
  {
    __int128 v50 = objc_autoreleasePoolPush();
    if (qword_100219F60) {
      [qword_100219F60 WFLog:@"%s, roamStatusdict is NULL" message:4];
    }
LABEL_71:
    objc_autoreleasePoolPop(v50);
    return;
  }

  uint64_t v6 = malloc(0xB8uLL);
  if (v6)
  {
    uint64_t v7 = (uint64_t)v6;
    v6[22] = 0LL;
    *((_OWORD *)v6 + 9) = 0u;
    *((_OWORD *)v6 + 10) = 0u;
    *((_OWORD *)v6 + 7) = 0u;
    *((_OWORD *)v6 + _Block_object_dispose((const void *)(v1 - 152), 8) = 0u;
    *((_OWORD *)v6 + 5) = 0u;
    *((_OWORD *)v6 + 6) = 0u;
    *((_OWORD *)v6 + 3) = 0u;
    *((_OWORD *)v6 + 4) = 0u;
    *((_OWORD *)v6 + 1) = 0u;
    *((_OWORD *)v6 + 2) = 0u;
    *(_OWORD *)uint64_t v6 = 0u;
    *((_DWORD *)v6 + 4) = sub_100098EA8((uint64_t)a2);
    CFBooleanRef Value = (const __CFNumber *)CFDictionaryGetValue(a3, @"ROAMEDEVENT_STATUS");
    if (Value) {
      CFNumberGetValue(Value, kCFNumberSInt32Type, (void *)(v7 + 24));
    }
    id v9 = (const __CFNumber *)CFDictionaryGetValue(a3, @"ROAMEDEVENT_REASON");
    if (v9) {
      CFNumberGetValue(v9, kCFNumberSInt32Type, (void *)(v7 + 28));
    }
    id v10 = (const __CFNumber *)CFDictionaryGetValue(a3, @"ROAMEDEVENT_FLAGS");
    if (v10) {
      CFNumberGetValue(v10, kCFNumberSInt32Type, (void *)(v7 + 20));
    }
    CFIndex v11 = (const __CFNumber *)CFDictionaryGetValue(a3, @"ROAMEDEVENT_PROFILE_TYPE");
    if (v11) {
      CFNumberGetValue(v11, kCFNumberSInt32Type, (void *)(v7 + 32));
    }
    uint64_t v12 = (const __CFNumber *)CFDictionaryGetValue(a3, @"ROAMEDEVENT_ORIGIN_RSSI");
    if (v12) {
      CFNumberGetValue(v12, kCFNumberSInt32Type, (void *)(v7 + 36));
    }
    int64_t v13 = (const __CFNumber *)CFDictionaryGetValue(a3, @"ROAMEDEVENT_TARGET_RSSI");
    if (v13) {
      CFNumberGetValue(v13, kCFNumberSInt32Type, (void *)(v7 + 40));
    }
    id v14 = (const __CFNumber *)CFDictionaryGetValue(a3, @"ROAMEDEVENT_ORIGIN_CHANNEL");
    if (v14) {
      CFNumberGetValue(v14, kCFNumberSInt32Type, (void *)(v7 + 44));
    }
    CFDateRef v15 = (const __CFNumber *)CFDictionaryGetValue(a3, @"ROAMEDEVENT_TARGET_CHANNEL");
    if (v15) {
      CFNumberGetValue(v15, kCFNumberSInt32Type, (void *)(v7 + 48));
    }
    id v16 = (const __CFNumber *)CFDictionaryGetValue(a3, @"ROAMEDEVENT_ORIGIN_CHANNEL_FLAGS");
    if (v16) {
      CFNumberGetValue(v16, kCFNumberSInt32Type, (void *)(v7 + 52));
    }
    id v17 = (const __CFNumber *)CFDictionaryGetValue(a3, @"ROAMEDEVENT_TARGET_CHANNEL_FLAGS");
    if (v17) {
      CFNumberGetValue(v17, kCFNumberSInt32Type, (void *)(v7 + 56));
    }
    uint64_t v18 = (const __CFData *)CFDictionaryGetValue(a3, @"ROAMEDEVENT_ORIGIN_OUI");
    if (v18)
    {
      v52.location = 0LL;
      v52.length = 3LL;
      CFDataGetBytes(v18, v52, (UInt8 *)(v7 + 60));
    }

    uint64_t v19 = (const __CFData *)CFDictionaryGetValue(a3, @"ROAMEDEVENT_TARGET_OUI");
    if (v19)
    {
      v53.location = 0LL;
      v53.length = 3LL;
      CFDataGetBytes(v19, v53, (UInt8 *)(v7 + 63));
    }

    uint64_t v20 = (const __CFNumber *)CFDictionaryGetValue(a3, @"ROAMEDEVENT_TIME_STARTED");
    if (v20) {
      CFNumberGetValue(v20, kCFNumberSInt64Type, (void *)v7);
    }
    __int16 v21 = (const __CFNumber *)CFDictionaryGetValue(a3, @"ROAMEDEVENT_TIME_ENDED");
    if (v21) {
      CFNumberGetValue(v21, kCFNumberSInt64Type, (void *)(v7 + 8));
    }
    int v22 = (const __CFNumber *)CFDictionaryGetValue(a3, @"ROAMEDEVENT_ORIGIN_AUTHTYPE");
    if (v22) {
      CFNumberGetValue(v22, kCFNumberSInt32Type, (void *)(v7 + 144));
    }
    id v23 = (const __CFNumber *)CFDictionaryGetValue(a3, @"ROAMEDEVENT_TARGET_AUTHTYPE");
    if (v23) {
      CFNumberGetValue(v23, kCFNumberSInt32Type, (void *)(v7 + 148));
    }
    id v24 = (const __CFNumber *)CFDictionaryGetValue(a3, @"ROAMEDEVENT_ORIGIN_AKMS");
    if (v24) {
      CFNumberGetValue(v24, kCFNumberSInt32Type, (void *)(v7 + 152));
    }
    id v25 = (const __CFNumber *)CFDictionaryGetValue(a3, @"ROAMEDEVENT_TARGET_AKMS");
    if (v25) {
      CFNumberGetValue(v25, kCFNumberSInt32Type, (void *)(v7 + 156));
    }
    id v26 = (const __CFNumber *)CFDictionaryGetValue(a3, @"ROAMEDEVENT_ORIGIN_PHYMODE");
    if (v26) {
      CFNumberGetValue(v26, kCFNumberSInt32Type, (void *)(v7 + 160));
    }
    uint64_t v27 = (const __CFNumber *)CFDictionaryGetValue(a3, @"ROAMEDEVENT_TARGET_PHYMODE");
    if (v27) {
      CFNumberGetValue(v27, kCFNumberSInt32Type, (void *)(v7 + 164));
    }
    uint64_t v28 = (const __CFNumber *)CFDictionaryGetValue(a3, @"ROAMEDEVENT_CHANNELS_SCANNED_COUNT");
    if (v28) {
      CFNumberGetValue(v28, kCFNumberSInt16Type, (void *)(v7 + 180));
    }
    unsigned __int16 v29 = (const __CFData *)CFDictionaryGetValue(a3, @"ROAMEDEVENT_ORIGIN_ADDR");
    if (v29)
    {
      v54.location = 0LL;
      v54.length = 6LL;
      CFDataGetBytes(v29, v54, (UInt8 *)(v7 + 168));
    }

    double v30 = (const __CFData *)CFDictionaryGetValue(a3, @"ROAMEDEVENT_TARGET_ADDR");
    if (v30)
    {
      v55.location = 0LL;
      v55.length = 6LL;
      CFDataGetBytes(v30, v55, (UInt8 *)(v7 + 174));
    }

    int64x2_t v31 = objc_autoreleasePoolPush();
    id v32 = -[__CFDictionary objectForKey:](a3, "objectForKey:", @"ROAM_CACHE");
    objc_autoreleasePoolPop(v31);
    int v33 = sub_100053CFC(*(void *)(a1 + 64));
    id v34 = +[WiFiRoamManager sharedWiFiRoamManager](&OBJC_CLASS___WiFiRoamManager, "sharedWiFiRoamManager");
    if (v34)
    {
      float64x2_t v35 = v34;
      sub_10001E670( *(void *)(a1 + 120),  (_DWORD *)(v7 + 68),  (_DWORD *)(v7 + 72),  (_DWORD *)(v7 + 76),  (_DWORD *)(v7 + 80),  (unint64_t *)(v7 + 88),  (unint64_t *)(v7 + 128),  (unint64_t *)(v7 + 136));
      uint64_t v36 = *(const __CFArray **)(a1 + 3520);
      if (v36)
      {
        v56.length = CFArrayGetCount(*(CFArrayRef *)(a1 + 3520));
        v56.location = 0LL;
        FirstIndexOfCFBooleanRef Value = CFArrayGetFirstIndexOfValue(v36, v56, a2);
        if (FirstIndexOfValue != -1)
        {
          ValueAtIndex = CFArrayGetValueAtIndex(*(CFArrayRef *)(a1 + 3520), FirstIndexOfValue);
          if (v33 && [v35 isRoamLateDueToDelta]) {
            sub_10009B560( (uint64_t)ValueAtIndex,  a2,  (int)[v35 minRssiDeltaInRoamCache],  (int)[v35 maxRssiDeltaInRoamCache]);
          }
          int v39 = *(unsigned __int16 *)(v7 + 20);
          unsigned int v40 = sub_100096670((uint64_t)ValueAtIndex);
          *(_DWORD *)(v7 + 20) = v39 | (v40 << 24) | (sub_10009F9B8((uint64_t)ValueAtIndex) << 16);
          *(_DWORD *)(v7 + 32) = sub_1000FDC1C(a1, ValueAtIndex);
        }
      }

      if (v33) {
        *(_DWORD *)(v7 + 100) = *(_DWORD *)(v7 + 8) - *(_DWORD *)v7;
      }
      unint64_t v41 = sub_10009A1FC(a2);
      if (v41)
      {
        __int128 v42 = (const __CFDate *)v41;
        double Current = CFAbsoluteTimeGetCurrent();
        *(void *)(v7 + 104) = (unint64_t)(Current - CFDateGetAbsoluteTime(v42));
      }

      unsigned int v44 = [v35 lastHostTriggeredRoamReason];
      int v45 = *(_DWORD *)(a1 + 3344);
      *(_DWORD *)(v7 + 112) = v44;
      *(_DWORD *)(v7 + 116) = v45;
      *(_BYTE *)(v7 + 120) = *(_BYTE *)(a1 + 3400) != 0;
      *(_BYTE *)(v7 + 121) = [v35 isRoamLateDueToDelta];
      [v35 setLastHostTriggeredRoamReason:0];
      uint64_t v46 = *(void *)(a1 + 64);
      __int128 v47 = sub_100095BC8(a2);
      sub_1000302C0(v46, v7, (uint64_t)v47, v32);
      if (v33)
      {
        [v35 didSubmitMetrics];
      }

      else
      {
        uint64_t v48 = *(void *)(a1 + 64);
        __int128 v49 = sub_100095BC8(a2);
        sub_1000302C0(v48, v7, (uint64_t)v49, v32);
      }

      sub_10001E644(*(void *)(a1 + 120));
    }

    else
    {
      __int128 v51 = objc_autoreleasePoolPush();
      if (qword_100219F60) {
        [qword_100219F60 WFLog:@"%s, roamManager is NULL" message:4];
      }
      objc_autoreleasePoolPop(v51);
    }

    free((void *)v7);
  }

void sub_100100900(uint64_t a1, int a2)
{
  if (a1)
  {
    if (*(void *)(a1 + 4112))
    {
      CFMutableDictionaryRef Mutable = CFDictionaryCreateMutable( kCFAllocatorDefault,  0LL,  &kCFTypeDictionaryKeyCallBacks,  &kCFTypeDictionaryValueCallBacks);
      if (Mutable)
      {
        CFIndex v5 = Mutable;
        if (a2)
        {
          __int16 valuePtr = 0;
          CFNumberRef v6 = CFNumberCreate(kCFAllocatorDefault, kCFNumberSInt16Type, &valuePtr);
          if (v6)
          {
            CFNumberRef v7 = v6;
            CFDictionaryAddValue(v5, @"HostApDisableHotspotAdvertiseReason", v6);
            CFRelease(v7);
          }

          id v8 = objc_autoreleasePoolPush();
          if (qword_100219F60) {
            [qword_100219F60 WFLog:@"%s: HostAP Max Client Connected: Disable Hotspot Advertising\n" message:3];
          }
        }

        else
        {
          id v8 = objc_autoreleasePoolPush();
          if (qword_100219F60) {
            [qword_100219F60 WFLog:@"%s: HostAP Max Client Allowed: Enable Hotspot Advertising\n" message:3];
          }
        }

        objc_autoreleasePoolPop(v8);
        if (*(_BYTE *)(a1 + 5211)) {
          CFBooleanRef v9 = kCFBooleanTrue;
        }
        else {
          CFBooleanRef v9 = kCFBooleanFalse;
        }
        CFDictionaryAddValue(v5, @"HostApEnabled", v9);
        if (a2) {
          CFBooleanRef v10 = kCFBooleanTrue;
        }
        else {
          CFBooleanRef v10 = kCFBooleanFalse;
        }
        CFDictionaryAddValue(v5, @"HostApDisableHotspotAdvertise", v10);
        (*(void (**)(uint64_t, void, __CFDictionary *))(a1 + 4112))(a1, *(void *)(a1 + 4120), v5);
        CFRelease(v5);
      }
    }
  }

uint64_t sub_100100A88(uint64_t a1)
{
  uint64_t v2 = objc_autoreleasePoolPush();
  BOOL v3 = *(const void **)(a1 + 1104);
  if (v3)
  {
    CFRelease(v3);
    *(void *)(a1 + 1104) = 0LL;
  }

  __int16 v4 = *(const void **)(a1 + 3368);
  if (v4)
  {
    CFRelease(v4);
    *(void *)(a1 + 336_Block_object_dispose((const void *)(v1 - 152), 8) = 0LL;
  }

  CFIndex v5 = *(const void **)(a1 + 3360);
  if (v5)
  {
    CFRelease(v5);
    *(void *)(a1 + 3360) = 0LL;
  }

  CFNumberRef v6 = *(const void **)(a1 + 3376);
  if (v6)
  {
    CFRelease(v6);
    *(void *)(a1 + 3376) = 0LL;
  }

  *(_BYTE *)(a1 + 3296) = 0;
  *(_DWORD *)(a1 + 112_Block_object_dispose((const void *)(v1 - 152), 8) = 0;
  CFNumberRef v7 = *(__CFArray **)(a1 + 3280);
  if (v7) {
    CFArrayRemoveAllValues(v7);
  }
  *(_DWORD *)(a1 + 5612) = 0;
  if (!*(void *)(a1 + 3504)
    || (id v8 = *(const __CFArray **)(a1 + 3568),
        v46.length = CFArrayGetCount(v8),
        v46.location = 0LL,
        CFArrayGetFirstIndexOfValue(v8, v46, *(const void **)(a1 + 3504)) == -1)
    || (ValueAtIndex = *(void **)(a1 + 3504)) == 0LL)
  {
    if (!CFArrayGetCount(*(CFArrayRef *)(a1 + 3568)))
    {
      ValueAtIndex = 0LL;
      goto LABEL_46;
    }

    ValueAtIndex = (void *)CFArrayGetValueAtIndex(*(CFArrayRef *)(a1 + 3568), 0LL);
    if (!ValueAtIndex) {
      goto LABEL_46;
    }
  }

  if (!sub_1000FC698(a1, ValueAtIndex, 0))
  {
LABEL_46:
    id v32 = objc_autoreleasePoolPush();
    if (qword_100219F60) {
      [qword_100219F60 WFLog:@"multi-stage auto-join: No previous network (%p)" message:3 ValueAtIndex];
    }
    int v33 = v32;
    goto LABEL_55;
  }

  if (sub_10009DF44((uint64_t)ValueAtIndex) && !*(_DWORD *)(a1 + 688))
  {
    *(_BYTE *)(a1 + 672) = 1;
    *(void *)(a1 + 664) = 0LL;
    *(_DWORD *)(a1 + 68_Block_object_dispose((const void *)(v1 - 152), 8) = 1;
  }

  CFBooleanRef v10 = (const __CFNumber *)sub_1000951FC((uint64_t)ValueAtIndex, @"CHANNEL");
  if (!v10)
  {
    id v34 = objc_autoreleasePoolPush();
    float64x2_t v35 = (void *)qword_100219F60;
    if (!qword_100219F60)
    {
LABEL_54:
      int v33 = v34;
LABEL_55:
      objc_autoreleasePoolPop(v33);
      uint64_t v37 = 4294963396LL;
      goto LABEL_56;
    }

    uint64_t v36 = "multi-stage auto-join: No channel info";
LABEL_53:
    [v35 WFLog:3 message:v36];
    goto LABEL_54;
  }

  CFIndex v11 = v10;
  if (!sub_10009DF44((uint64_t)ValueAtIndex) {
    || (*(_BYTE *)(a1 + 672) = 0,
  }
        int v12 = sub_100096BF4((uint64_t)ValueAtIndex, @"CHANNEL"),
        LODWORD(valuePtr) = v12,
        *(_DWORD *)(a1 + 66_Block_object_dispose((const void *)(v1 - 152), 8) = v12,
        v12 > 14)
    || (int64_t v13 = (const __CFArray *)sub_1000951FC((uint64_t)ValueAtIndex, @"networkKnownBSSListKey")) == 0LL
    || (id v14 = v13, CFArrayGetCount(v13) < 2)
    || CFArrayGetCount(v14) < 1)
  {
LABEL_31:
    uint64_t v20 = (void *)sub_1000951FC((uint64_t)ValueAtIndex, @"CHANNEL_FLAGS");
    if (v20)
    {
      __int16 v21 = v20;
      uint64_t v18 = v11;
      goto LABEL_33;
    }

    id v34 = objc_autoreleasePoolPush();
    float64x2_t v35 = (void *)qword_100219F60;
    if (!qword_100219F60) {
      goto LABEL_54;
    }
    uint64_t v36 = "multi-stage auto-join: No channel flags info";
    goto LABEL_53;
  }

  CFIndex v15 = 0LL;
  while (1)
  {
    id v16 = (const __CFDictionary *)CFArrayGetValueAtIndex(v14, v15);
    CFBooleanRef Value = (const __CFNumber *)CFDictionaryGetValue(v16, @"CHANNEL");
    if (Value)
    {
      uint64_t v18 = Value;
      CFNumberGetValue(Value, kCFNumberSInt32Type, &valuePtr);
      if ((int)valuePtr >= 36)
      {
        uint64_t v19 = (void *)CFDictionaryGetValue(v16, @"CHANNEL_FLAGS");
        if (v19) {
          break;
        }
      }
    }

    if (CFArrayGetCount(v14) <= ++v15) {
      goto LABEL_31;
    }
  }

  __int16 v21 = v19;
  *(_DWORD *)(a1 + 66_Block_object_dispose((const void *)(v1 - 152), 8) = valuePtr;
  *(_BYTE *)(a1 + 672) = 1;
  unint64_t v41 = objc_autoreleasePoolPush();
  if (qword_100219F60) {
    [qword_100219F60 WFLog:@"__WiFiDeviceManagerScanPreviousNetworkChannel: Re-directed to connect to chanenl %d" message:3, "%s: Re-directed to connect to chanenl %d", "__WiFiDeviceManagerScanPreviousNetworkChannel", valuePtr];
  }
  objc_autoreleasePoolPop(v41);
LABEL_33:
  sub_100103660(a1);
  __int128 valuePtr = *(_OWORD *)off_1001E4F98;
  values[0] = v18;
  values[1] = v21;
  CFDictionaryRef v22 = CFDictionaryCreate( kCFAllocatorDefault,  (const void **)&valuePtr,  (const void **)values,  2LL,  &kCFTypeDictionaryKeyCallBacks,  &kCFTypeDictionaryValueCallBacks);
  if (!v22)
  {
LABEL_69:
    uint64_t v37 = 4294963394LL;
    goto LABEL_56;
  }

  CFDictionaryRef v23 = v22;
  CFMutableDictionaryRef Mutable = CFArrayCreateMutable(kCFAllocatorDefault, 0LL, &kCFTypeArrayCallBacks);
  if (!Mutable)
  {
    CFRelease(v23);
    goto LABEL_69;
  }

  id v25 = Mutable;
  CFArrayAppendValue(Mutable, v23);
  sub_1000FD888(a1);
  id v26 = objc_autoreleasePoolPush();
  if (qword_100219F60)
  {
    uint64_t v27 = +[NSString stringWithFormat:]( &OBJC_CLASS___NSString,  "stringWithFormat:",  @"%s",  -[NSString UTF8String]( +[NSString stringWithFormat:]( &OBJC_CLASS___NSString,  "stringWithFormat:",  @"{%@*} %@",  @"AUTOJOIN, SCAN",  +[NSString stringWithFormat:]( &OBJC_CLASS___NSString,  "stringWithFormat:",  @"multi-stage auto-join: Scanning(%s) for previous network %@ on channel %@",  "Active",  sub_100095BC8(ValueAtIndex),  v18)),  "UTF8String"));
    if (os_log_type_enabled((os_log_t)&_os_log_default, OS_LOG_TYPE_DEFAULT))
    {
      *(_DWORD *)__int128 buf = 136446210;
      __int128 v43 = -[NSString UTF8String]( +[NSString stringWithFormat:]( &OBJC_CLASS___NSString,  "stringWithFormat:",  @"[WiFiPolicy] %s",  -[NSString UTF8String](v27, "UTF8String")),  "UTF8String");
      _os_log_impl( (void *)&_mh_execute_header,  (os_log_t)&_os_log_default,  OS_LOG_TYPE_DEFAULT,  "%{public}s",  buf,  0xCu);
    }
  }

  objc_autoreleasePoolPop(v26);
  if (*(_DWORD *)(a1 + 5512) == 1 || *(_BYTE *)(a1 + 5496))
  {
    uint64_t v28 = objc_autoreleasePoolPush();
    if (qword_100219F60) {
      [qword_100219F60 WFLog:@"__WiFiDeviceManagerScanPreviousNetworkChannel CarPlay scan dewll time (%d), channel (%d), dual band (%d)", 40, *(unsigned int *)(a1 + 668), *(unsigned __int8 *)(a1 + 672)];
    }
    objc_autoreleasePoolPop(v28);
    unsigned int v29 = 40;
  }

  else
  {
    unsigned int v29 = 110;
  }

  uint64_t v30 = sub_1001036C0(a1, *(const __CFArray **)(a1 + 3544), v25, v29, 25LL);
  if (!(_DWORD)v30)
  {
    CFArrayAppendValue(*(CFMutableArrayRef *)(a1 + 3280), v23);
    CFRelease(v23);
    CFRelease(v25);
    uint64_t v31 = 6LL;
    *(_DWORD *)(a1 + 3276) = 6;
    goto LABEL_62;
  }

  uint64_t v37 = v30;
  CFRelease(v23);
  CFRelease(v25);
LABEL_56:
  float64x2_t v38 = objc_autoreleasePoolPush();
  if (qword_100219F60) {
    [qword_100219F60 WFLog:@"multi-stage auto-join: Error scanning for previous network, err=%d" message:4 v37];
  }
  objc_autoreleasePoolPop(v38);
  if (*(_DWORD *)(a1 + 5512) == 1 || *(_BYTE *)(a1 + 5496))
  {
    *(_DWORD *)(a1 + 3276) = 6;
    uint64_t v39 = sub_100103C48((_DWORD *)a1);
  }

  else
  {
    uint64_t v39 = (uint64_t)sub_100103D04(a1);
  }

  uint64_t v31 = v39;
LABEL_62:
  objc_autoreleasePoolPop(v2);
  return v31;
}

CFArrayRef sub_1001010A4(uint64_t a1)
{
  if (*(_DWORD *)(a1 + 3272) != 2)
  {
    uint64_t v2 = *(const void **)(a1 + 1104);
    if (v2)
    {
      CFRelease(v2);
      *(void *)(a1 + 1104) = 0LL;
    }

    *(_DWORD *)(a1 + 112_Block_object_dispose((const void *)(v1 - 152), 8) = 0;
  }

  BOOL v3 = *(const void **)(a1 + 1160);
  if (v3)
  {
    CFRelease(v3);
    *(void *)(a1 + 1160) = 0LL;
  }

  *(void *)(a1 + 1136) = 0LL;
  CFIndex Count = CFArrayGetCount(*(CFArrayRef *)(a1 + 3544));
  objc_autoreleasePoolPop(objc_autoreleasePoolPush());
  if (*(_DWORD *)(a1 + 176) != 3) {
    CFAbsoluteTimeGetCurrent();
  }
  if (*(_BYTE *)(a1 + 32) && *(_BYTE *)(a1 + 33))
  {
    if (*(_BYTE *)(a1 + 35))
    {
      int v5 = 9;
    }

    else
    {
      if (*(_DWORD *)(a1 + 3272) == 2)
      {
        if (!*(_BYTE *)(a1 + 5600)
          || (CFIndex v37 = CFArrayGetCount(*(CFArrayRef *)(a1 + 1104)),
              CFIndex v38 = CFArrayGetCount(*(CFArrayRef *)(a1 + 3560)) + v37,
              v38 + CFArrayGetCount(*(CFArrayRef *)(a1 + 3552))))
        {
          *(_DWORD *)(a1 + 5612) = 4;
        }

        char v6 = 0;
        ++*(_WORD *)(a1 + 6108);
        goto LABEL_15;
      }

      int v5 = 8;
    }
  }

  else
  {
    int v5 = 7;
  }

  *(_DWORD *)(a1 + 5612) = v5;
  char v6 = 1;
LABEL_15:
  if (Count) {
    unsigned int v7 = 110;
  }
  else {
    unsigned int v7 = 0;
  }
  *(_BYTE *)(a1 + 3296) = 0;
  int valuePtr = -1431655766;
  CFMutableDictionaryRef Mutable = CFArrayCreateMutable(kCFAllocatorDefault, 0LL, &kCFTypeArrayCallBacks);
  CFMutableArrayRef v9 = CFArrayCreateMutable(kCFAllocatorDefault, 0LL, &kCFTypeArrayCallBacks);
  CFBooleanRef v10 = v9;
  if (Mutable) {
    BOOL v11 = v9 == 0LL;
  }
  else {
    BOOL v11 = 1;
  }
  if (v11) {
    goto LABEL_27;
  }
  uint64_t v12 = *(void *)(a1 + 64);
  int64_t v13 = (const void *)sub_100043E8C(v12);
  uint64_t v14 = sub_100044EB0(v12, v13, v10);
  if ((_DWORD)v14)
  {
    uint64_t v15 = v14;
    id v16 = objc_autoreleasePoolPush();
    if (qword_100219F60) {
      [qword_100219F60 WFLog:@"AJScan: Device return error %d for supported channels. Scanning ALL channels\n" message:3];
    }
    objc_autoreleasePoolPop(v16);
    goto LABEL_27;
  }

  *(_DWORD *)(a1 + 6160) = 0;
  if ((v6 & 1) != 0)
  {
LABEL_27:
    int v17 = 0;
    uint64_t v18 = "ALL";
    goto LABEL_28;
  }

  if (CFArrayGetCount(v10) < 1)
  {
    int v17 = 1;
    uint64_t v18 = "5Ghz";
  }

  else
  {
    unsigned int v39 = v7;
    CFIndex v29 = 0LL;
    uint64_t v18 = "5Ghz";
    do
    {
      ValueAtIndex = (const __CFDictionary *)CFArrayGetValueAtIndex(v10, v29);
      if (ValueAtIndex)
      {
        uint64_t v31 = ValueAtIndex;
        CFBooleanRef Value = (void *)CFDictionaryGetValue(ValueAtIndex, @"SUP_CHANNEL");
        int v33 = (const __CFNumber *)CFDictionaryGetValue(v31, @"SUP_CHANNEL_FLAGS");
        if (Value)
        {
          id v34 = v33;
          if (v33)
          {
            if (CFNumberGetValue(v33, kCFNumberSInt32Type, &valuePtr))
            {
              if ((valuePtr & 0x10) != 0)
              {
                *(_OWORD *)__int128 buf = *(_OWORD *)off_1001E4F98;
                values[0] = Value;
                values[1] = v34;
                CFDictionaryRef v35 = CFDictionaryCreate( kCFAllocatorDefault,  (const void **)buf,  (const void **)values,  2LL,  &kCFTypeDictionaryKeyCallBacks,  &kCFTypeDictionaryValueCallBacks);
                if (v35)
                {
                  CFDictionaryRef v36 = v35;
                  CFArrayAppendValue(Mutable, v35);
                  CFRelease(v36);
                }
              }
            }
          }
        }
      }

      ++v29;
    }

    while (v29 < CFArrayGetCount(v10));
    int v17 = 1;
    unsigned int v7 = v39;
  }

uint64_t sub_100101580(uint64_t a1, void *a2, const __CFDictionary *a3, uint64_t a4)
{
  char context = objc_autoreleasePoolPush();
  id v8 = objc_autoreleasePoolPush();
  if (qword_100219F60)
  {
    CFMutableArrayRef v9 = +[NSString stringWithFormat:]( &OBJC_CLASS___NSString,  "stringWithFormat:",  @"%s",  -[NSString UTF8String]( +[NSString stringWithFormat:]( &OBJC_CLASS___NSString,  "stringWithFormat:",  @"{%@*} %@",  @"AUTOJOIN",  +[NSString stringWithFormat:]( &OBJC_CLASS___NSString,  "stringWithFormat:",  @"%s: current state: %@",  "__WiFiDeviceManagerProcessAssociationResult",  sub_1000BDC98(*(_DWORD *)(a1 + 3272)))),  "UTF8String"));
    if (os_log_type_enabled((os_log_t)&_os_log_default, OS_LOG_TYPE_DEFAULT))
    {
      LODWORD(buf) = 136446210;
      *(void *)((char *)&buf + 4) = -[NSString UTF8String]( +[NSString stringWithFormat:]( &OBJC_CLASS___NSString,  "stringWithFormat:",  @"[WiFiPolicy] %s",  -[NSString UTF8String](v9, "UTF8String")),  "UTF8String");
      _os_log_impl( (void *)&_mh_execute_header,  (os_log_t)&_os_log_default,  OS_LOG_TYPE_DEFAULT,  "%{public}s",  (uint8_t *)&buf,  0xCu);
    }
  }

  objc_autoreleasePoolPop(v8);
  double v111 = 0.0;
  if (a3) {
    MutableCFStringRef Copy = CFDictionaryCreateMutableCopy(kCFAllocatorDefault, 0LL, a3);
  }
  else {
    MutableCFStringRef Copy = CFDictionaryCreateMutable( kCFAllocatorDefault,  0LL,  &kCFTypeDictionaryKeyCallBacks,  &kCFTypeDictionaryValueCallBacks);
  }
  BOOL v11 = MutableCopy;
  if (MutableCopy)
  {
    uint64_t v12 = sub_1000BDC98(*(_DWORD *)(a1 + 3272));
    CFDictionaryAddValue(v11, @"reason", v12);
  }

  if (!(_DWORD)a4)
  {
    *(_DWORD *)double v117 = 0;
    *(void *)&__int128 theDict = 0LL;
    __int128 buf = 0uLL;
    int64_t v13 = (const __CFString *)sub_10004CE2C(*(void *)(a1 + 64));
    CFStringGetCString(v13, (char *)&buf, 16LL, 0);
    if (!(void)theDict)
    {
LABEL_19:
      uint64_t v18 = objc_autoreleasePoolPush();
      if (qword_100219F60) {
        [(id)qword_100219F60 WFLog:3, "%s: %@ not an EAP  network, not checking AT notification code", "__WiFiDeviceManagerProcessAssociationResult", sub_100095BC8(a2) message];
      }
      objc_autoreleasePoolPop(v18);
      uint64_t v19 = sub_1000D91B0(a1, a2, 1);
      CFIndex v20 = v19;
      if (v19)
      {
        CFIndex v21 = sub_1000951FC((uint64_t)v19, @"ALLOW_WPA2_PSK");
        if (v21) {
          sub_10009582C((uint64_t)a2, @"ALLOW_WPA2_PSK", v21);
        }
        CFDictionaryRef v22 = sub_1000951FC((uint64_t)v20, @"ALLOW_OWE_TSN");
        if (v22) {
          sub_10009582C((uint64_t)a2, @"ALLOW_OWE_TSN", v22);
        }
        sub_10009AB20(v20, a2);
        CFDictionaryRef v23 = (const void *)sub_10009A1FC(v20);
        if (v23) {
          sub_10009582C((uint64_t)a2, @"prevJoined", v23);
        }
        if (_os_feature_enabled_impl("CoreWiFi", "UnifiedAutoJoin"))
        {
          id v24 = sub_1000E359C(a1);
          uint64_t v25 = v24;
          if (v24)
          {
            uint64_t v26 = *(void *)(a1 + 6744);
            [v24 coordinate];
            CLLocationDegrees v28 = v27;
            [v25 coordinate];
            CLLocationDegrees v30 = v29;
            [v25 horizontalAccuracy];
            sub_10007E304(v26, a2, v28, v30, v31, [v25 timestamp]);
          }

          if (*(_BYTE *)(a1 + 3406))
          {
            CFAbsoluteTime Current = CFAbsoluteTimeGetCurrent();
            CFDateRef v33 = CFDateCreate(kCFAllocatorDefault, Current);
            if (v33)
            {
              sub_10009B324(a2, v33);
              CFRelease(v33);
            }
          }
        }

        CFRelease(v20);
      }

      CFAbsoluteTime v34 = CFAbsoluteTimeGetCurrent();
      CFDateRef v35 = CFDateCreate(kCFAllocatorDefault, v34);
      if (v35)
      {
        sub_10009A194(a2, 0, v35);
        CFDictionaryRef v36 = objc_autoreleasePoolPush();
        if (qword_100219F60) {
          [(id)qword_100219F60 WFLog:3, "%s: setting auto association date for %@ to %@", "__WiFiDeviceManagerProcessAssociationResult", sub_100095BC8(a2), v35 message];
        }
        objc_autoreleasePoolPop(v36);
        CFRelease(v35);
      }

      sub_100109C38(a1, a2);
      if (a2)
      {
        id v37 = sub_1000A335C((uint64_t)a2);
        [*(id *)(a1 + 6632) isNetworkDenyListedForAutoJoinDueToTrigDisc:v37 RSSI:0 timestamp:&v111];
        sub_10001552C(*(void *)(a1 + 120), v111);

        sub_100109CFC(a1, a2, 0);
        id v38 = sub_1000A335C((uint64_t)a2);
        [*(id *)(a1 + 6632) removeNetworkDenyListInfoWithReason:1 forScanResult:v38];
        [*(id *)(a1 + 6632) removeNetworkDenyListInfoForTrigger:0 forNetwork:v38];
      }

      else
      {
        unsigned int v39 = objc_autoreleasePoolPush();
        if (qword_100219F60) {
          [qword_100219F60 WFLog:@"__WiFiDeviceManagerProcessAssociationResult: Failed to set blacklist last trigger disconnect"];
        }
        objc_autoreleasePoolPop(v39);
        sub_100109CFC(a1, 0LL, 0);
        unsigned int v40 = objc_autoreleasePoolPush();
        if (qword_100219F60) {
          [qword_100219F60 WFLog:@"%s: Failed to clear blacklist trigger" message:3];
        }
        objc_autoreleasePoolPop(v40);
      }

      if (*(_BYTE *)(a1 + 3404))
      {
        unint64_t v41 = objc_autoreleasePoolPush();
        if (qword_100219F60) {
          [(id)qword_100219F60 WFLog:3, "%s: tagging network %@ as moving", "__WiFiDeviceManagerProcessAssociationResult", sub_100095BC8(a2) message];
        }
        objc_autoreleasePoolPop(v41);
        sub_10009582C((uint64_t)a2, @"WiFiNetworkAttributeIsMoving", kCFBooleanTrue);
        CFBooleanRef v42 = kCFBooleanFalse;
      }

      else
      {
        CFBooleanRef v42 = kCFBooleanFalse;
        sub_10009582C((uint64_t)a2, @"WiFiNetworkAttributeIsMoving", kCFBooleanFalse);
      }

      sub_10009582C((uint64_t)a2, @"WiFiInstantHotspotJoining", v42);
      sub_10009582C((uint64_t)a2, @"WiFiAutoInstantHotspotJoining", v42);
      if (*(_DWORD *)(a1 + 3464)) {
        BOOL v43 = a2 == 0LL;
      }
      else {
        BOOL v43 = 1;
      }
      if (!v43) {
        sub_10009582C( (uint64_t)a2,  @"TransitionDisabledFlags",  +[NSNumber numberWithUnsignedInt:](&OBJC_CLASS___NSNumber, "numberWithUnsignedInt:"));
      }
      sub_1000D3650(a1, a2);
      if (*(void *)(a1 + 3864))
      {
        if (*(void *)(a1 + 240))
        {
          *(void *)&__int128 buf = 0LL;
          *((void *)&buf + 1) = &buf;
          uint64_t v120 = 0x2020000000LL;
          v121 = 0LL;
          *(void *)&__int128 theDict = 0LL;
          *((void *)&theDict + 1) = &theDict;
          uint64_t v113 = 0x2020000000LL;
          char v114 = 0LL;
          if (a2)
          {
            CFTypeRef v44 = CFRetain(a2);
            *(void *)(*((void *)&buf + 1) + 24LL) = v44;
          }

          if (v11)
          {
            CFTypeRef v45 = CFRetain(v11);
            *(void *)(*((void *)&theDict + 1) + 24LL) = v45;
          }

          CFRetain((CFTypeRef)a1);
          CFRange v46 = *(dispatch_queue_s **)(a1 + 240);
          block[0] = _NSConcreteStackBlock;
          block[1] = 3221225472LL;
          block[2] = sub_100109D88;
          block[3] = &unk_1001E4F00;
          void block[4] = &buf;
          void block[5] = &theDict;
          void block[6] = a1;
          int v110 = 0;
          dispatch_async(v46, block);
          _Block_object_dispose(&theDict, 8);
          _Block_object_dispose(&buf, 8);
        }

        else
        {
          __int128 v47 = objc_autoreleasePoolPush();
          if (qword_100219F60) {
            [qword_100219F60 WFLog:@"%s: null queue." message:4];
          }
          objc_autoreleasePoolPop(v47);
        }
      }

      sub_1000D0AAC(a1, 2LL, (uint64_t)"__WiFiDeviceManagerProcessAssociationResult");
      CFArrayRemoveAllValues(*(CFMutableArrayRef *)(a1 + 3552));
      CFArrayRemoveAllValues(*(CFMutableArrayRef *)(a1 + 3560));
      [*(id *)(a1 + 3648) clearScanResultsForAutoJoinSessionReset];
      sub_10010D14C(a1, @"autoJoinSuccess", a2, 0LL);
      if (_os_feature_enabled_impl("CoreWiFi", "UnifiedAutoJoin"))
      {
        uint64_t v48 = sub_100095BC8(a2);
        if (v48) {
          [*(id *)(a1 + 8848) removeObjectForKey:v48];
        }
      }

      sub_100109E80(a1, a2);
      sub_100109F94(a1, (uint64_t)a2);
      if (v11) {
        CFRelease(v11);
      }
      *(_WORD *)(a1 + 6584) = sub_1000D3EF0(a1, a2);
      sub_1000CF880(a1, 1, 1);
      sub_1000FED08(a1, a2);
      __int128 v49 = objc_autoreleasePoolPush();
      if (qword_100219F60)
      {
        __int128 v50 = +[NSString stringWithFormat:]( &OBJC_CLASS___NSString,  "stringWithFormat:",  @"%s",  -[NSString UTF8String]( +[NSString stringWithFormat:]( &OBJC_CLASS___NSString,  "stringWithFormat:",  @"{%@*} %@",  @"AUTOJOIN, ASSOC",  +[NSString stringWithFormat:]( &OBJC_CLASS___NSString,  "stringWithFormat:",  @"Auto join association succeeded, network: %@",  sub_100095BC8(a2))),  "UTF8String"));
        if (os_log_type_enabled((os_log_t)&_os_log_default, OS_LOG_TYPE_DEFAULT))
        {
          __int128 v51 = -[NSString UTF8String]( +[NSString stringWithFormat:]( &OBJC_CLASS___NSString,  "stringWithFormat:",  @"[WiFiPolicy] %s",  -[NSString UTF8String](v50, "UTF8String")),  "UTF8String");
          LODWORD(buf) = 136446210;
          *(void *)((char *)&buf + 4) = v51;
          _os_log_impl( (void *)&_mh_execute_header,  (os_log_t)&_os_log_default,  OS_LOG_TYPE_DEFAULT,  "%{public}s",  (uint8_t *)&buf,  0xCu);
        }
      }

      objc_autoreleasePoolPop(v49);
      uint64_t v52 = 0LL;
      goto LABEL_77;
    }

    uint64_t v14 = (const __CFDictionary *)CFDictionaryGetValue((CFDictionaryRef)theDict, @"AdditionalProperties");
    if (!v14
      || (uint64_t v15 = (const __CFDictionary *)CFDictionaryGetValue(v14, @"EAPAKASIMNotificationActionInfo"),
          (id v16 = v15) == 0LL)
      || !CFDictionaryGetValue(v15, @"Code")
      || (int v17 = (const __CFNumber *)CFDictionaryGetValue(v16, @"Code"), sub_10003AC9C(v17) == -1))
    {
LABEL_17:
      if ((void)theDict) {
        CFRelease((CFTypeRef)theDict);
      }
      goto LABEL_19;
    }

    if ((void)theDict) {
      CFRelease((CFTypeRef)theDict);
    }
    CFRange v54 = objc_autoreleasePoolPush();
    if (qword_100219F60) {
      [(id)qword_100219F60 WFLog:3, "%s: EAP AT notification code found associating to %@, reporting error", "__WiFiDeviceManagerProcessAssociationResult", sub_100095BC8(a2) message];
    }
    objc_autoreleasePoolPop(v54);
    a4 = 4294963355LL;
  }

  uint64_t v52 = *(unsigned int *)(a1 + 3272);
  if (a2)
  {
    BOOL v100 = sub_100095B4C((uint64_t)a2);
    CFRange v55 = sub_1000D91B0(a1, a2, 1);
    CFMutableDictionaryRef v106 = v55;
    CFRange v56 = kCFBooleanFalse;
    if (v55) {
      unsigned int v57 = (const __CFDictionary **)v55;
    }
    else {
      unsigned int v57 = (const __CFDictionary **)a2;
    }
  }

  else
  {
    BOOL v100 = 0;
    CFMutableDictionaryRef v106 = 0LL;
    unsigned int v57 = 0LL;
    CFRange v56 = kCFBooleanFalse;
  }

  unsigned int v107 = v57;
  int v58 = sub_1000A47DC(*(const __CFArray **)(a1 + 3696), v57);
  CFTypeRef cf = v58;
  if (v58)
  {
    uint64_t v59 = (const __CFDictionary *)sub_1000951FC((uint64_t)v58, @"PRIVATE_MAC_ADDRESS");
    if (v59 && (CFTypeID TypeID = CFDictionaryGetTypeID(), TypeID == CFGetTypeID(v59)))
    {
      uint64_t v61 = (const __CFData *)CFDictionaryGetValue(v59, @"PRIVATE_MAC_ADDRESS_VALUE");
      unsigned int v102 = sub_10003B498(v61);
    }

    else
    {
      unsigned int v102 = 0LL;
    }

    CFRange v56 = (const __CFBoolean *)sub_1000951FC((uint64_t)cf, @"MacAddressRandomisationTagMigratedNetwork");
  }

  else
  {
    unsigned int v102 = 0LL;
    uint64_t v59 = 0LL;
  }

  sub_1000A4754((uint64_t)v107);
  if (!*(_BYTE *)(a1 + 3680)) {
    goto LABEL_124;
  }
  if (!v56 || v56 != kCFBooleanTrue)
  {
    uint64_t v68 = (uint64_t)cf;
    if (cf && (_DWORD)v102)
    {
      uint64_t v68 = (uint64_t)cf;
      if (!sub_1000971AC((uint64_t)v107) && *(void *)(a1 + 4736))
      {
        if (*(void *)(a1 + 240))
        {
          *(void *)&__int128 theDict = 0LL;
          *((void *)&theDict + 1) = &theDict;
          uint64_t v113 = 0x2020000000LL;
          char v114 = 0LL;
          CFTypeRef v69 = CFRetain(cf);
          *(void *)(*((void *)&theDict + 1) + 24LL) = v69;
          CFRetain((CFTypeRef)a1);
          unsigned int v70 = *(dispatch_queue_s **)(a1 + 240);
          *(void *)&__int128 buf = _NSConcreteStackBlock;
          *((void *)&buf + 1) = 3221225472LL;
          uint64_t v120 = (uint64_t)sub_10010A9F0;
          v121 = &unk_1001E2D48;
          p___int128 theDict = &theDict;
          uint64_t v123 = a1;
          dispatch_async(v70, &buf);
          _Block_object_dispose(&theDict, 8);
        }

        else
        {
          unsigned int v93 = objc_autoreleasePoolPush();
          if (qword_100219F60) {
            [qword_100219F60 WFLog:@"%s: null queue." message:@"__WiFiDeviceManagerProcessAssociationFailure"];
          }
          objc_autoreleasePoolPop(v93);
          uint64_t v68 = (uint64_t)cf;
        }
      }
    }

    else if (!cf)
    {
      goto LABEL_124;
    }

    *(void *)((char *)&theDict + 4) = 0xAAAAAAAAAAAAAAAALL;
    LODWORD(theDict) = 5;
    sub_100037928(v68, (uint64_t)&theDict);
    sub_100037694((unsigned int *)&theDict);
    goto LABEL_124;
  }

  if (!v59)
  {
LABEL_124:
    uint64_t v101 = 0LL;
    char value = 1;
    goto LABEL_125;
  }

  CFTypeID v62 = CFDictionaryGetTypeID();
  uint64_t v101 = 0LL;
  char value = 1;
  if (v62 == CFGetTypeID(v59) && (_DWORD)v102)
  {
    id v63 = CFDictionaryCreateMutableCopy(kCFAllocatorDefault, 0LL, v59);
    CFNumberRef valuea = sub_10003B870(1);
    CFDictionarySetValue(v63, @"PRIVATE_MAC_ADDRESS_TYPE", valuea);
    CFDictionarySetValue(v63, @"PRIVATE_MAC_ADDRESS_VALUE", *(const void **)(a1 + 3704));
    sub_10009582C((uint64_t)v107, @"PRIVATE_MAC_ADDRESS", v63);
    id v64 = objc_autoreleasePoolPush();
    if (qword_100219F60) {
      [(id)qword_100219F60 WFLog:3, "%s: WFMacRandomisation : Network <%@> falling back to physical Mac due to Assoc failure", "__WiFiDeviceManagerProcessAssociationFailure", sub_100095BC8(v107) message];
    }
    objc_autoreleasePoolPop(v64);
    if (valuea) {
      CFRelease(valuea);
    }
    uint64_t v65 = *(void (**)(uint64_t, const __CFDictionary **, void))(a1 + 4704);
    if (v65) {
      v65(a1, v107, *(void *)(a1 + 4712));
    }
    if (cf)
    {
      *(void *)((char *)&buf + 4) = 0xAAAAAAAAAAAAAAAALL;
      LODWORD(buf) = 2;
      sub_100037928((uint64_t)cf, (uint64_t)&buf);
      sub_100037694((unsigned int *)&buf);
    }

    if (v63) {
      CFRelease(v63);
    }
    BOOL v66 = objc_autoreleasePoolPush();
    if (qword_100219F60) {
      [(id)qword_100219F60 WFLog:3, "WFMacRandomisation : Changing mac address of <%@> from Private to HW to Retry. Current count is <%ld>", sub_100095BC8(v107), *(void *)(a1 + 1120) message];
    }
    objc_autoreleasePoolPop(v66);
    unsigned int v67 = *(void **)(a1 + 7320);
    if (v67) {
      [v67 addFaultEvent:11 forInterface:sub_100043E8C(*(void *)(a1 + 64))];
    }
    char value = 0;
    uint64_t v101 = 1LL;
  }

LABEL_199:
      uint64_t v76 = 5LL;
LABEL_136:
      uint64_t v77 = sub_1000951FC((uint64_t)v107, @"BSSID");
      id v78 = sub_1000D1BDC(a1, v76, (int)a4, (uint64_t)v77, 5LL);
      [*(id *)(a1 + 6632) setNetworkDenyListInfo:v78 forScanResult:v75];

      objc_autoreleasePoolPop(v74);
      uint64_t v71 = (uint64_t)v107;
    }

void sub_100102A4C( _Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20, uint64_t a21, uint64_t a22, uint64_t a23, uint64_t a24, uint64_t a25, uint64_t a26, uint64_t a27, uint64_t a28, uint64_t a29, uint64_t a30, char a31)
{
}

uint64_t sub_100102A84(uint64_t a1)
{
  uint64_t v2 = *(unsigned int *)(a1 + 3272);
  uint64_t v3 = *(void *)(a1 + 224);
  __int16 v4 = objc_autoreleasePoolPush();
  if (qword_100219F60) {
    [(id)qword_100219F60 WFLog:3, "%s: notification %@ currentState %@", "__WiFiDeviceManagerProcessUserResponse", *(void *)(a1 + 224), sub_1000BDC98(v2) message];
  }
  objc_autoreleasePoolPop(v4);
  *(_DWORD *)(a1 + 3272) = 12;
  int v5 = *(const void **)(a1 + 224);
  *(void *)(a1 + 224) = 0LL;
  switch(sub_1000ABA7C((uint64_t)v5))
  {
    case 0u:
      uint64_t v6 = (uint64_t)sub_10010B300(a1, (uint64_t)v5);
      goto LABEL_28;
    case 1u:
    case 3u:
      uint64_t v6 = sub_10010AADC(a1, (uint64_t)v5);
      goto LABEL_28;
    case 2u:
      uint64_t v6 = sub_10010AD94(a1, (uint64_t)v5);
      goto LABEL_28;
    case 5u:
      uint64_t v2 = *(unsigned int *)(a1 + 3272);
      unsigned int v7 = sub_1000ABA8C((uint64_t)v5);
      id v8 = (void *)sub_100091DAC((uint64_t)v5);
      CFMutableArrayRef v9 = objc_autoreleasePoolPush();
      CFBooleanRef v10 = (void *)qword_100219F60;
      if (v8)
      {
        if (qword_100219F60)
        {
          BOOL v11 = sub_100095BC8(v8);
          [v10 WFLog:3, "%s: network %@ ResponseType=%@", "__WiFiDeviceManagerProcessJoinRecommendationNotification", v11, sub_1000ABE6C(v7) message];
        }

        objc_autoreleasePoolPop(v9);
        switch(v7)
        {
          case 1u:
            CFAbsoluteTime Current = CFAbsoluteTimeGetCurrent();
            CFDateRef v13 = CFDateCreate(kCFAllocatorDefault, Current);
            sub_10009582C((uint64_t)v8, @"WiFiNetworkUserAcceptedRecommendationAt", v13);
            if (v13) {
              CFRelease(v13);
            }
            uint64_t v14 = sub_1000EC354(a1, v8, 1);
            if ((_DWORD)v14) {
              goto LABEL_39;
            }
            break;
          case 2u:
            sub_100109CFC(a1, v8, 1);
            goto LABEL_27;
          case 3u:
            goto LABEL_27;
          case 5u:
            CFAbsoluteTime v20 = CFAbsoluteTimeGetCurrent();
            CFDateRef v21 = CFDateCreate(kCFAllocatorDefault, v20);
            CFDictionaryRef v22 = sub_10003AEF8((uint64_t)v21, 5LL, 0LL, 0LL);
            CFDictionaryRef v23 = objc_autoreleasePoolPush();
            if (qword_100219F60) {
              [(id)qword_100219F60 WFLog:3, "%s: user muted network, disabling network until %@", "__WiFiDeviceManagerProcessJoinRecommendationNotification", v22 message];
            }
            objc_autoreleasePoolPop(v23);
            sub_10009A048((CFMutableDictionaryRef *)v8, 0, @"JoinRecommendation");
            sub_100099F8C((uint64_t)v8, v22);
            sub_1000DAB00((dispatch_queue_s **)a1, v8);
            if (v21) {
              CFRelease(v21);
            }
            if (v22) {
              CFRelease(v22);
            }
            break;
          default:
            goto LABEL_29;
        }

        goto LABEL_29;
      }

      if (qword_100219F60) {
        [qword_100219F60 WFLog:@"%s: network is null" message:4];
      }
      double v27 = v9;
      goto LABEL_55;
    case 0xAu:
      int v15 = sub_1000ABA8C((uint64_t)v5);
      uint64_t v6 = sub_10010B464(a1, v15);
      goto LABEL_28;
    case 0xCu:
      uint64_t v2 = *(unsigned int *)(a1 + 3272);
      int v16 = sub_1000ABA8C((uint64_t)v5);
      uint64_t v17 = sub_100091DAC((uint64_t)v5);
      if (v17)
      {
        if (v16 != 3)
        {
          if (v16 != 2)
          {
            if (v16 != 1) {
              goto LABEL_29;
            }
            id v8 = (void *)v17;
            uint64_t v18 = (const void *)sub_100043E8C(*(void *)(a1 + 64));
            sub_1000CE074( a1,  v18,  1019LL,  "__WiFiDeviceManagerProcessAutoHotspotJoinRecommendationNotification",  37002LL);
            if (sub_100098EA8((uint64_t)v8))
            {
              sub_10010B64C(0LL, (CFDictionaryRef *)v8);
              goto LABEL_29;
            }

            uint64_t v14 = sub_1000EC354(a1, v8, 0);
            if ((_DWORD)v14)
            {
LABEL_39:
              uint64_t v6 = sub_100101580(a1, v8, 0LL, (uint64_t)v14);
              goto LABEL_28;
            }

            sub_10010D14C(a1, @"autoJoinAssociating", v8, 0LL);
            if (*(void *)(a1 + 4576))
            {
              if (*(void *)(a1 + 240))
              {
                uint64_t v30 = 0LL;
                double v31 = &v30;
                uint64_t v32 = 0x2020000000LL;
                uint64_t v33 = 0LL;
                id v24 = sub_100094E60((uint64_t)kCFAllocatorDefault, (uint64_t)v8);
                v31[3] = (uint64_t)v24;
                if (v24)
                {
                  CFRetain((CFTypeRef)a1);
                  uint64_t v25 = *(dispatch_queue_s **)(a1 + 240);
                  block[0] = _NSConcreteStackBlock;
                  block[1] = 3221225472LL;
                  block[2] = sub_10010BCC8;
                  block[3] = &unk_1001E2D48;
                  void block[4] = &v30;
                  void block[5] = a1;
                  dispatch_async(v25, block);
                }

                _Block_object_dispose(&v30, 8);
              }

              else
              {
                uint64_t v26 = objc_autoreleasePoolPush();
                if (qword_100219F60) {
                  [qword_100219F60 WFLog:@"%s: null queue." message:4];
                }
                objc_autoreleasePoolPop(v26);
              }
            }

            uint64_t v2 = 12LL;
            goto LABEL_29;
          }

          *(_BYTE *)(a1 + 6939) = 0;
        }

void sub_100102F84( _Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, ...)
{
}

uint64_t sub_100102F9C(uint64_t a1)
{
  unsigned int v2 = *(_DWORD *)(a1 + 3272);
  CFIndex Count = CFArrayGetCount(*(CFArrayRef *)(a1 + 6792));
  CFIndex v4 = CFArrayGetCount(*(CFArrayRef *)(a1 + 6864));
  CFIndex v5 = CFArrayGetCount(*(CFArrayRef *)(a1 + 6872));
  CFIndex v6 = CFArrayGetCount(*(CFArrayRef *)(a1 + 6880));
  uint64_t v41 = Count;
  if (!Count)
  {
    sub_1000CABEC(a1, 0);
    ValueAtIndex = 0LL;
    goto LABEL_53;
  }

  uint64_t v7 = v6;
  id v8 = objc_autoreleasePoolPush();
  if (qword_100219F60) {
    [(id)qword_100219F60 WFLog:3, "%s: hotspot interface found device %@", "__WiFiDeviceManagerProcessScannedInstantHotspotDevices", *(void *)(a1 + 6792) message];
  }
  objc_autoreleasePoolPop(v8);
  if (v41 < 1)
  {
    ValueAtIndex = 0LL;
    goto LABEL_52;
  }

  unsigned int v40 = v2;
  CFIndex v9 = 0LL;
  while (1)
  {
    ValueAtIndex = CFArrayGetValueAtIndex(*(CFArrayRef *)(a1 + 6792), v9);
    if (v4 < 1)
    {
LABEL_10:
      int v42 = 1;
    }

    else
    {
      CFIndex v11 = 0LL;
      while (!objc_msgSend( *(id *)(a1 + 6728),  "isEqualHotspotDevices:compareTo:",  CFArrayGetValueAtIndex(*(CFArrayRef *)(a1 + 6864), v11),  ValueAtIndex))
      {
        if (v4 == ++v11) {
          goto LABEL_10;
        }
      }

      uint64_t v12 = objc_autoreleasePoolPush();
      if (qword_100219F60) {
        [qword_100219F60 WFLog:@"Hotspot blacklisted: User cancelled \n"];
      }
      objc_autoreleasePoolPop(v12);
      int v42 = 0;
    }

    if (v5 < 1)
    {
LABEL_18:
      int v14 = 1;
      if (!v7) {
        goto LABEL_29;
      }
    }

    else
    {
      CFIndex v13 = 0LL;
      while (!objc_msgSend( *(id *)(a1 + 6728),  "isEqualHotspotDevices:compareTo:",  CFArrayGetValueAtIndex(*(CFArrayRef *)(a1 + 6872), v13),  ValueAtIndex))
      {
        if (v5 == ++v13) {
          goto LABEL_18;
        }
      }

      int v15 = objc_autoreleasePoolPush();
      if (qword_100219F60) {
        [qword_100219F60 WFLog:@"Hotspot blacklisted: Peer declined \n"];
      }
      objc_autoreleasePoolPop(v15);
      int v14 = 0;
      if (!v7)
      {
LABEL_29:
        int v22 = 1;
        goto LABEL_35;
      }
    }

    id v16 = [*(id *)(a1 + 6728) getHotspotDeviceName:ValueAtIndex];
    if (v7 < 1) {
      goto LABEL_29;
    }
    uint64_t v17 = v16;
    CFIndex v18 = 0LL;
    while (1)
    {
      uint64_t v19 = CFArrayGetValueAtIndex(*(CFArrayRef *)(a1 + 6880), v18);
      if (v19)
      {
        CFAbsoluteTime v20 = v19;
        CFDateRef v21 = sub_100095BC8(v19);
        if (CFEqual(v17, v21)) {
          break;
        }
      }

      if (v7 == ++v18) {
        goto LABEL_28;
      }
    }

    CFDictionaryRef v23 = (const __CFDate *)sub_1000951FC((uint64_t)v20, @"lastDisconnectTimestampKey");
    if (v23 && (id v24 = v23, !sub_100097B1C((uint64_t)v20)))
    {
      double Current = CFAbsoluteTimeGetCurrent();
      double v28 = Current - CFDateGetAbsoluteTime(v24);
      double v29 = objc_autoreleasePoolPush();
      if (v28 >= 3600.0)
      {
        if (qword_100219F60) {
          [qword_100219F60 WFLog:@"%s: Remove Hotspot from Denylist\n" message:3];
        }
        objc_autoreleasePoolPop(v29);
        CFArrayRemoveValueAtIndex(*(CFMutableArrayRef *)(a1 + 6880), v18);
LABEL_28:
        int v22 = 1;
        goto LABEL_35;
      }

      if (qword_100219F60) {
        [(id)qword_100219F60 WFLog:3, "%s: Hotspot denylisted due to Deauth on %@\n", "__WiFiDeviceManagerProcessScannedInstantHotspotDevices", v24 message];
      }
      objc_autoreleasePoolPop(v29);
      int v22 = 0;
    }

    else
    {
      uint64_t v25 = objc_autoreleasePoolPush();
      if (qword_100219F60) {
        [(id)qword_100219F60 WFLog:3, "%s: Hotspot %@ denylisted until user Join\n", "__WiFiDeviceManagerProcessScannedInstantHotspotDevices", sub_100095BC8(v20) message];
      }
      objc_autoreleasePoolPop(v25);
      int v22 = 0;
    }

uint64_t sub_1001034F4(uint64_t a1, uint64_t a2)
{
  uint64_t v10 = 0LL;
  CFIndex v11 = &v10;
  uint64_t v12 = 0x3052000000LL;
  CFIndex v13 = sub_1000F3F84;
  int v14 = sub_1000F3F94;
  uint64_t v15 = a2;
  v9[0] = 0LL;
  v9[1] = v9;
  v9[2] = 0x3052000000LL;
  void v9[3] = sub_1000F3F84;
  v9[4] = sub_1000F3F94;
  void v9[5] = 0LL;
  v8[0] = 0LL;
  v8[1] = v8;
  void v8[2] = 0x3052000000LL;
  v8[3] = sub_1000F3F84;
  v8[4] = sub_1000F3F94;
  void v8[5] = 0LL;
  if (!*(_BYTE *)(a1 + 6960))
  {
    *(_DWORD *)(a1 + 3272) = 19;
    *(_BYTE *)(a1 + 6960) = 1;
    sub_10010B9B4((uint64_t *)a1, @"userJoinStarted", 0LL);
    id v3 = (id)v11[5];
    dispatch_queue_global_t global_queue = dispatch_get_global_queue(0LL, 0LL);
    v7[0] = _NSConcreteStackBlock;
    v7[1] = 3221225472LL;
    v7[2] = sub_10010BD9C;
    v7[3] = &unk_1001E4F78;
    v7[4] = v8;
    void v7[5] = &v10;
    void v7[6] = v9;
    v7[7] = a1;
    dispatch_async(global_queue, v7);
  }

  uint64_t v5 = *(unsigned int *)(a1 + 3272);
  _Block_object_dispose(v8, 8);
  _Block_object_dispose(v9, 8);
  _Block_object_dispose(&v10, 8);
  return v5;
}

void sub_100103630( _Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, ...)
{
  uint64_t v11 = va_arg(va1, void);
  uint64_t v13 = va_arg(va1, void);
  uint64_t v14 = va_arg(va1, void);
  uint64_t v15 = va_arg(va1, void);
  uint64_t v16 = va_arg(va1, void);
  uint64_t v17 = va_arg(va1, void);
  _Block_object_dispose(va, 8);
  _Block_object_dispose(va1, 8);
  _Block_object_dispose((const void *)(v9 - 64), 8);
  _Unwind_Resume(a1);
}

void sub_100103660(uint64_t a1)
{
  if (!a1)
  {
    uint64_t v1 = objc_autoreleasePoolPush();
    if (qword_100219F60) {
      [qword_100219F60 WFLog:@"%s: NULL manager" message:4];
    }
    objc_autoreleasePoolPop(v1);
  }

uint64_t sub_1001036C0(uint64_t a1, const __CFArray *a2, CFArrayRef theArray, unsigned int a4, uint64_t a5)
{
  if (!theArray || !*(_BYTE *)(a1 + 3406) || CFArrayGetCount(theArray) == 1)
  {
    uint64_t v10 = sub_1000ED0D0(a2, theArray, 0, a4, 1);
    if (!v10) {
      return 4294963396LL;
    }
    uint64_t v11 = v10;
    id v12 = sub_1000E359C(a1);
    uint64_t v13 = objc_autoreleasePoolPush();
    if (v12)
    {
      id v14 = [v12 timestamp];
      if (!v14)
      {
        CFTypeRef v44 = objc_autoreleasePoolPush();
        if (qword_100219F60) {
          [qword_100219F60 WFLog:@"%s: location timestamp is nil" message:3];
        }
        objc_autoreleasePoolPop(v44);
        objc_autoreleasePoolPop(v13);
LABEL_41:
        CFRelease(v12);
LABEL_42:
        *(_DWORD *)(a1 + 192) = 18;
        uint64_t v37 = (uint64_t *)malloc(0x28uLL);
        if (v37)
        {
          uint64_t v38 = v37;
          [+[WiFiXPCManager sharedXPCManager](WiFiXPCManager, "sharedXPCManager") autoJoinUpdatedWithState:2 interfaceName:sub_100043E8C(*(void *)(a1 + 64))];
          uint64_t *v38 = a1;
          v38[1] = 0LL;
          v38[3] = 0LL;
          if (CFDictionaryContainsKey(v11, @"SSID_STR")) {
            BOOL v39 = 1;
          }
          else {
            BOOL v39 = CFDictionaryContainsKey(v11, @"SCAN_SSID_LIST") != 0;
          }
          *((_BYTE *)v38 + 32) = v39;
          unsigned int v40 = (const void *)sub_100043E8C(*(void *)(a1 + 64));
          uint64_t v24 = sub_1000E0CC4(a1, v40, v11, 0LL, (uint64_t)sub_10010442C, (uint64_t)v38, (void *)(a1 + 3304), a5);
          if ((_DWORD)v24)
          {
            BOOL v43 = objc_autoreleasePoolPush();
            if (qword_100219F60) {
              [qword_100219F60 WFLog:@"Error initiating scan request: %d" message:4 v24];
            }
            objc_autoreleasePoolPop(v43);
            free(v38);
          }
        }

        else
        {
          int v42 = objc_autoreleasePoolPush();
          if (qword_100219F60) {
            [qword_100219F60 WFLog:@"%s: null scanData" message:4];
          }
          objc_autoreleasePoolPop(v42);
          uint64_t v24 = 4294963396LL;
        }

        CFRelease(v11);
        return v24;
      }

      [v14 timeIntervalSinceNow];
      *(void *)(a1 + 6096) = v15;
      objc_autoreleasePoolPop(v13);
      [v12 horizontalAccuracy];
      *(void *)(a1 + 6072) = v16;
      [v12 coordinate];
      *(void *)(a1 + 6080) = v17;
      [v12 coordinate];
      *(void *)(a1 + 608_Block_object_dispose(va, 8) = v18;
      if (*(double *)(a1 + 6080) != 0.0)
      {
        ++*(_WORD *)(a1 + 6104);
        goto LABEL_13;
      }
    }

    else
    {
      if (qword_100219F60) {
        [(id)qword_100219F60 WFLog:4 message:"Location is Nil"];
      }
      objc_autoreleasePoolPop(v13);
      *(_OWORD *)(a1 + 6072) = 0u;
      *(_OWORD *)(a1 + 608_Block_object_dispose(va, 8) = 0u;
    }

    ++*(_WORD *)(a1 + 6106);
LABEL_13:
    CFMutableDictionaryRef Mutable = CFStringCreateMutable(kCFAllocatorDefault, 0LL);
    if (Mutable)
    {
      CFAbsoluteTime v20 = Mutable;
      uint64_t v21 = *(int *)(a1 + 5612);
      else {
        int v22 = off_1001E5690[v21];
      }
      if (*(_BYTE *)(a1 + 33) && *(_BYTE *)(a1 + 32)) {
        uint64_t v25 = @"Scan-{";
      }
      else {
        uint64_t v25 = @"_Scan-{";
      }
      CFStringAppend(Mutable, v25);
      CFStringAppend(v20, v22);
      uint64_t v26 = *(int *)(a1 + 5620);
      if (v26 <= 3)
      {
        double v27 = off_1001E56F8[v26];
        CFStringAppend(v20, @" ");
        CFStringAppend(v20, v27);
      }

      uint64_t v28 = *(int *)(a1 + 5624);
      if (v28 > 2)
      {
        CFStringAppendFormat(v20, 0LL, @" %dsecs", *(unsigned int *)(a1 + 5632));
      }

      else
      {
        double v29 = off_1001E5718[v28];
        CFStringAppend(v20, @" ");
        CFStringAppend(v20, v29);
      }

      uint64_t v30 = *(int *)(a1 + 192);
      if (v30 <= 0xE)
      {
        double v31 = off_1001E5730[v30];
        CFStringAppend(v20, @" ");
        CFStringAppend(v20, v31);
      }

      CFStringAppend(v20, @"}  Expecting-[");
      CFStringAppendFormat( v20,  0LL,  @"%dNW, %dHid, %dHS20, %dHS",  *(unsigned int *)(a1 + 6128),  *(unsigned int *)(a1 + 6124),  *(unsigned int *)(a1 + 6116),  *(unsigned int *)(a1 + 6120));
      CFStringAppend(v20, @"] @ ");
      uint64_t v32 = sub_10008FDAC(*(_DWORD *)(a1 + 3344));
      CFStringAppendFormat( v20,  0LL,  @"{%@, %.3f, %.3f, %.1fm, %.1fsecs}]",  v32,  *(void *)(a1 + 6080),  *(void *)(a1 + 6088),  *(void *)(a1 + 6072),  *(void *)(a1 + 6096));
      id v33 = objc_autoreleasePoolPush();
      if (qword_100219F60) {
        [(id)qword_100219F60 WFLog:3, "AJScan: %@", v20 message];
      }
      objc_autoreleasePoolPop(v33);
      CFRelease(v20);
    }

    uint64_t v34 = *(unsigned int *)(a1 + 5612);
    if (v34 <= 0xC)
    {
      *(_DWORD *)(a1 + 5616) = v34;
      ++*(_WORD *)(a1 + 5608 + 2 * v34 + 252);
      ++*(_DWORD *)(a1 + 5608 + 4 * v34 + 304);
    }

    uint64_t v35 = *(unsigned int *)(a1 + 5624);
    uint64_t v36 = *(unsigned int *)(a1 + 5628);
    *(_DWORD *)(a1 + 5612) = 13;
    *(void *)(a1 + 5624) = 0x1200000003LL;
    if (!v12) {
      goto LABEL_42;
    }
    goto LABEL_41;
  }

  CFDictionaryRef v23 = objc_autoreleasePoolPush();
  if (qword_100219F60) {
    [(id)qword_100219F60 WFLog:3 message:"Multi channel scan attempt not permitted because AWDL real time mode is active"];
  }
  objc_autoreleasePoolPop(v23);
  return 4294963366LL;
}

uint64_t sub_100103C48(_DWORD *a1)
{
  int v1 = a1[819];
  if (v1 == 10) {
    return sub_100104818((uint64_t)a1);
  }
  if (v1 == 6)
  {
    unsigned int v2 = a1[166] + 1;
    a1[166] = v2;
    if (a1[172] == 1 && v2 <= 2) {
      return sub_100100A88();
    }
    a1[166] = 0;
    a1[172] = 2;
    return sub_100104818((uint64_t)a1);
  }

  CFIndex v4 = objc_autoreleasePoolPush();
  if (qword_100219F60) {
    [qword_100219F60 WFLog:@"Something went wrong. Should not come here."];
  }
  objc_autoreleasePoolPop(v4);
  return 1LL;
}

CFArrayRef sub_100103D04(uint64_t a1)
{
  unsigned int v2 = *(const void **)(a1 + 1104);
  if (v2)
  {
    CFRelease(v2);
    *(void *)(a1 + 1104) = 0LL;
  }

  *(_DWORD *)(a1 + 112_Block_object_dispose(va, 8) = 0;
  id v3 = objc_autoreleasePoolPush();
  if (qword_100219F60)
  {
    CFIndex v4 = sub_1000BDC98(*(_DWORD *)(a1 + 3276));
    uint64_t v5 = +[NSString stringWithFormat:]( &OBJC_CLASS___NSString,  "stringWithFormat:",  @"%s",  -[NSString UTF8String]( +[NSString stringWithFormat:]( &OBJC_CLASS___NSString,  "stringWithFormat:",  @"{%@*} %@",  @"AUTOJOIN",  +[NSString stringWithFormat:]( &OBJC_CLASS___NSString,  "stringWithFormat:",  @"%s: last state: %@, current state: %@, topNetwork %@",  "__WiFiDeviceManagerScanMRUNetworkChannels",  v4,  sub_1000BDC98(*(_DWORD *)(a1 + 3272)),  *(void *)(a1 + 3368))),  "UTF8String"));
    if (os_log_type_enabled((os_log_t)&_os_log_default, OS_LOG_TYPE_DEFAULT))
    {
      *(_DWORD *)__int128 buf = 136446210;
      CFRange v46 = -[NSString UTF8String]( +[NSString stringWithFormat:]( &OBJC_CLASS___NSString,  "stringWithFormat:",  @"[WiFiPolicy] %s",  -[NSString UTF8String](v5, "UTF8String")),  "UTF8String");
      _os_log_impl( (void *)&_mh_execute_header,  (os_log_t)&_os_log_default,  OS_LOG_TYPE_DEFAULT,  "%{public}s",  buf,  0xCu);
    }
  }

  objc_autoreleasePoolPop(v3);
  CFIndex v6 = *(const __CFArray **)(a1 + 3568);
  if (!v6)
  {
    uint64_t v36 = objc_autoreleasePoolPush();
    uint64_t v37 = (void *)qword_100219F60;
    if (!qword_100219F60) {
      goto LABEL_70;
    }
    uint64_t v41 = "__WiFiDeviceManagerScanMRUNetworkChannels";
    uint64_t v38 = "%s: NULL known filtered networks";
LABEL_63:
    uint64_t v39 = 3LL;
LABEL_69:
    objc_msgSend(v37, "WFLog:message:", v39, v38, v41);
    goto LABEL_70;
  }

  CFIndex Count = CFArrayGetCount(v6);
  if (!Count)
  {
    uint64_t v36 = objc_autoreleasePoolPush();
    uint64_t v37 = (void *)qword_100219F60;
    if (!qword_100219F60) {
      goto LABEL_70;
    }
    uint64_t v41 = "__WiFiDeviceManagerScanMRUNetworkChannels";
    uint64_t v38 = "%s: No known filtered networks";
    goto LABEL_63;
  }

  uint64_t v8 = Count;
  CFMutableArrayRef Mutable = CFArrayCreateMutable(kCFAllocatorDefault, 0LL, &kCFTypeArrayCallBacks);
  if (!Mutable)
  {
    unsigned int v40 = objc_autoreleasePoolPush();
    if (qword_100219F60) {
      [qword_100219F60 WFLog:@"%s: null mruNetworkChanList" message:3];
    }
    objc_autoreleasePoolPop(v40);
    uint64_t v31 = 4294963394LL;
    goto LABEL_67;
  }

  uint64_t v10 = Mutable;
  *(_DWORD *)(a1 + 5612) = 1;
  CFMutableStringRef v44 = CFStringCreateMutable(kCFAllocatorDefault, 0LL);
  if (v8 >= 1)
  {
    CFIndex v11 = 0LL;
    uint64_t v12 = 8LL;
    while (1)
    {
      if (CFArrayGetCount(v10) > 3) {
        goto LABEL_39;
      }
      if (*(_DWORD *)(a1 + 3276) == 7)
      {
        *(_DWORD *)(a1 + 5612) = 12;
        ValueAtIndex = *(const void **)(a1 + 3368);
        uint64_t v12 = 9LL;
        if (!ValueAtIndex) {
          goto LABEL_39;
        }
      }

      else
      {
        ValueAtIndex = CFArrayGetValueAtIndex(*(CFArrayRef *)(a1 + 3568), v11);
        if (!ValueAtIndex) {
          goto LABEL_36;
        }
      }

      id v14 = sub_10009BF08((uint64_t)ValueAtIndex);
      if (v14)
      {
        uint64_t v15 = v14;
        CFIndex v16 = CFDictionaryGetCount(v14);
        if (v16)
        {
          uint64_t v17 = v16;
          unsigned int v43 = v12;
          v42[1] = v42;
          __chkstk_darwin();
          uint64_t v19 = (char *)v42 - ((v18 + 15) & 0xFFFFFFFFFFFFFFF0LL);
          memset(v19, 170, v18);
          CFDictionaryGetKeysAndValues(v15, 0LL, (const void **)v19);
          if (v17 >= 1)
          {
            uint64_t v20 = 0LL;
            uint64_t v21 = v19 - 8;
            do
            {
              if (CFArrayGetCount(v10) > 3) {
                break;
              }
              int v22 = *(const __CFDictionary **)&v21[8 * v17];
              if (v22)
              {
                CFBooleanRef Value = CFDictionaryGetValue(v22, @"CHANNEL");
                uint64_t v24 = CFDictionaryGetValue(*(CFDictionaryRef *)&v21[8 * v17], @"CHANNEL_FLAGS");
                if (Value && v24 != 0LL)
                {
                  sub_100103660(a1);
                  if (sub_100105068(*(const __CFArray **)(a1 + 3280), Value) != 1)
                  {
                    CFArrayAppendValue(v10, *(const void **)&v21[8 * v17]);
                    CFArrayAppendValue(*(CFMutableArrayRef *)(a1 + 3280), *(const void **)&v21[8 * v17]);
                    if (v44)
                    {
                      if (!v20)
                      {
                        uint64_t v26 = sub_100095BC8(ValueAtIndex);
                        CFStringAppendFormat(v44, 0LL, @" %@ on channels: ", v26);
                      }

                      CFStringAppendFormat(v44, 0LL, @"%@ ", Value);
                    }

                    ++v20;
                  }
                }
              }

              --v17;
            }

            while ((unint64_t)(v17 + 1) > 1);
          }

          CFRelease(v15);
          if (*(_DWORD *)(a1 + 3276) == 7)
          {
            uint64_t v35 = objc_autoreleasePoolPush();
            uint64_t v12 = v43;
            if (qword_100219F60) {
              [(id)qword_100219F60 WFLog:3, "Top Networks MRU channels: %@", v44 message];
            }
            objc_autoreleasePoolPop(v35);
            goto LABEL_39;
          }

          uint64_t v12 = v43;
        }

        else
        {
          CFRelease(v15);
        }
      }

void sub_10010442C(uint64_t a1, uint64_t a2, const __CFArray *a3, uint64_t a4, uint64_t a5, uint64_t *a6)
{
  uint64_t v9 = *a6;
  uint64_t v10 = sub_10004CA94(*(void *)(*a6 + 64));
  free(a6);
  CFIndex v11 = objc_autoreleasePoolPush();
  if (qword_100219F60) {
    [(id)qword_100219F60 WFLog:3, "Auto join scan completed (%d) with current state: %@", a5, sub_1000BDC98(*(_DWORD *)(v9 + 3272)) message];
  }
  objc_autoreleasePoolPop(v11);
  if (v10 == *(void *)(v9 + 3304))
  {
    sub_100104644(v9, a3);
    *(void *)(v9 + 108_Block_object_dispose(va, 8) = a3;
    *(_DWORD *)(v9 + 1080) = a5;
    unsigned int v12 = *(_DWORD *)(v9 + 3272);
    if (v12 <= 0xB)
    {
      if (((1 << v12) & 0xFDC) != 0)
      {
        if (a3 && CFArrayGetCount(a3))
        {
          if (CFArrayGetCount(a3) >= 1)
          {
            CFIndex v13 = 0LL;
            do
            {
              ValueAtIndex = CFArrayGetValueAtIndex(a3, v13);
              uint64_t v15 = *(const __CFArray **)(v9 + 3528);
              v22.length = CFArrayGetCount(v15);
              v22.location = 0LL;
              LODWORD(v15) = CFArrayContainsValue(v15, v22, ValueAtIndex);
              CFIndex v16 = *(const __CFArray **)(v9 + 3520);
              v23.length = CFArrayGetCount(v16);
              v23.location = 0LL;
              if (v15 | CFArrayContainsValue(v16, v23, ValueAtIndex))
              {
                uint64_t v17 = sub_100095BC8(ValueAtIndex);
                if (v17)
                {
                  size_t v18 = v17;
                  uint64_t v19 = (const __CFString *)sub_10004CE2C(*(void *)(v9 + 64));
                  sub_100031A9C(v9, v19, v18);
                }
              }

              ++v13;
            }

            while (v13 < CFArrayGetCount(a3));
          }

          uint64_t v20 = *(__CFArray **)(v9 + 1096);
          v24.length = CFArrayGetCount(a3);
          v24.location = 0LL;
          CFArrayAppendArray(v20, a3, v24);
        }

        goto LABEL_19;
      }

      if (v12 == 5) {
LABEL_19:
      }
        sub_1000CACC4(v9);
    }

    *(void *)(v9 + 108_Block_object_dispose(va, 8) = 0LL;
    return;
  }

  uint64_t v21 = objc_autoreleasePoolPush();
  if (qword_100219F60) {
    [qword_100219F60 WFLog:@"Ignorning old request.  CurrentCommand=%lld PendingCommand=%lld" message:3 v10 *(void *)(v9 + 3304)];
  }
  objc_autoreleasePoolPop(v21);
}

void sub_100104644(uint64_t a1, CFArrayRef theArray)
{
  if (!theArray) {
    return;
  }
  if (!a1)
  {
    CFIndex v11 = objc_autoreleasePoolPush();
    if (qword_100219F60) {
      [qword_100219F60 WFLog:@"__WiFiDeviceManagerTrackScanResultsForAWDMetrics: null ajMetrics."];
    }
    goto LABEL_25;
  }

  if (!*(void *)(a1 + 6048))
  {
    CFIndex v11 = objc_autoreleasePoolPush();
    if (qword_100219F60) {
      [qword_100219F60 WFLog:@"%s: null scannedSSIDsThisSession." message:4];
    }
    goto LABEL_25;
  }

  if (!*(void *)(a1 + 6056))
  {
    CFIndex v11 = objc_autoreleasePoolPush();
    if (qword_100219F60) {
      [qword_100219F60 WFLog:@"%s: null knownSSIDsScannedThisSession." message:4];
    }
LABEL_25:
    objc_autoreleasePoolPop(v11);
    return;
  }

  if (CFArrayGetCount(theArray) >= 1)
  {
    CFIndex v4 = 0LL;
    do
    {
      ValueAtIndex = CFArrayGetValueAtIndex(theArray, v4);
      CFIndex v6 = sub_100095BC8(ValueAtIndex);
      if (v6) {
        CFSetAddValue(*(CFMutableSetRef *)(a1 + 6048), v6);
      }
      ++v4;
    }

    while (v4 < CFArrayGetCount(theArray));
  }

  CFMutableArrayRef Mutable = CFArrayCreateMutable(kCFAllocatorDefault, 0LL, &kCFTypeArrayCallBacks);
  if (sub_1000EE7F4(a1, theArray, Mutable) && CFArrayGetCount(Mutable) >= 1)
  {
    CFIndex v8 = 0LL;
    do
    {
      uint64_t v9 = CFArrayGetValueAtIndex(Mutable, v8);
      uint64_t v10 = sub_100095BC8(v9);
      if (v10) {
        CFSetAddValue(*(CFMutableSetRef *)(a1 + 6056), v10);
      }
      ++v8;
    }

    while (v8 < CFArrayGetCount(Mutable));
  }

  if (Mutable) {
    CFRelease(Mutable);
  }
}

uint64_t sub_100104818(uint64_t a1)
{
  unsigned int v2 = *(const void **)(a1 + 1104);
  if (v2)
  {
    CFRelease(v2);
    *(void *)(a1 + 1104) = 0LL;
  }

  CFMutableArrayRef Mutable = CFArrayCreateMutable(kCFAllocatorDefault, 0LL, &kCFTypeArrayCallBacks);
  if (!Mutable)
  {
    uint64_t v10 = objc_autoreleasePoolPush();
    if (qword_100219F60) {
      [qword_100219F60 WFLog:@"__WiFiDeviceManagerScanCarPlayRemainingChannels: Couldn't allocate channelList"];
    }
    objc_autoreleasePoolPop(v10);
    uint64_t v11 = 4294963394LL;
    goto LABEL_82;
  }

  CFMutableArrayRef v4 = Mutable;
  *(_DWORD *)(a1 + 3276) = 10;
  int v5 = *(_DWORD *)(a1 + 688);
  if (v5 == 4)
  {
    if (*(_BYTE *)(a1 + 672)) {
      goto LABEL_18;
    }
LABEL_15:
    *(_DWORD *)(a1 + 68_Block_object_dispose(va, 8) = 0;
LABEL_33:
    CFRelease(v4);
    goto LABEL_85;
  }

  if (v5 == 3) {
    goto LABEL_15;
  }
  if (v5 != 2)
  {
    LODWORD(v12) = 0;
    goto LABEL_23;
  }

  int v6 = *(_DWORD *)(a1 + 668);
  if (v6 < 36)
  {
    if (!v6)
    {
      LODWORD(v12) = 0;
      goto LABEL_21;
    }

uint64_t sub_100105068(const __CFArray *a1, const void *a2)
{
  CFIndex Count = CFArrayGetCount(a1);
  if (Count < 1) {
    return 0LL;
  }
  CFIndex v5 = Count;
  CFIndex v6 = 0LL;
  while (1)
  {
    ValueAtIndex = (const __CFDictionary *)CFArrayGetValueAtIndex(a1, v6);
    CFBooleanRef Value = CFDictionaryGetValue(ValueAtIndex, @"CHANNEL");
    if (CFEqual(a2, Value)) {
      break;
    }
    if (v5 == ++v6) {
      return 0LL;
    }
  }

  return 1LL;
}

CFArrayRef sub_1001050F0(uint64_t a1)
{
  unsigned int v2 = *(const void **)(a1 + 1104);
  if (v2)
  {
    CFRelease(v2);
    *(void *)(a1 + 1104) = 0LL;
  }

  *(_DWORD *)(a1 + 112_Block_object_dispose(va, 8) = 0;
  id v3 = objc_autoreleasePoolPush();
  if (qword_100219F60)
  {
    CFMutableArrayRef v4 = sub_1000BDC98(*(_DWORD *)(a1 + 3276));
    CFIndex v5 = +[NSString stringWithFormat:]( &OBJC_CLASS___NSString,  "stringWithFormat:",  @"%s",  -[NSString UTF8String]( +[NSString stringWithFormat:]( &OBJC_CLASS___NSString,  "stringWithFormat:",  @"{%@*} %@",  @"AUTOJOIN",  +[NSString stringWithFormat:]( &OBJC_CLASS___NSString,  "stringWithFormat:",  @"%s: last state: %@, current state: %@, topNetwork %@",  "__WiFiDeviceManagerScanRemainingChannels",  v4,  sub_1000BDC98(*(_DWORD *)(a1 + 3272)),  *(void *)(a1 + 3368))),  "UTF8String"));
    if (os_log_type_enabled((os_log_t)&_os_log_default, OS_LOG_TYPE_DEFAULT))
    {
      *(_DWORD *)__int128 buf = 136446210;
      *(void *)&uint8_t buf[4] = -[NSString UTF8String]( +[NSString stringWithFormat:]( &OBJC_CLASS___NSString,  "stringWithFormat:",  @"[WiFiPolicy] %s",  -[NSString UTF8String](v5, "UTF8String")),  "UTF8String");
      _os_log_impl( (void *)&_mh_execute_header,  (os_log_t)&_os_log_default,  OS_LOG_TYPE_DEFAULT,  "%{public}s",  buf,  0xCu);
    }
  }

  objc_autoreleasePoolPop(v3);
  int v6 = 10;
  if (*(_DWORD *)(a1 + 3276) == 9)
  {
    if (*(void *)(a1 + 3368)) {
      int v6 = 11;
    }
    else {
      int v6 = 10;
    }
  }

  unsigned int v36 = v6;
  *(_DWORD *)(a1 + 3276) = v6;
  CFMutableArrayRef Mutable = CFArrayCreateMutable(kCFAllocatorDefault, 0LL, &kCFTypeArrayCallBacks);
  CFMutableArrayRef v8 = CFArrayCreateMutable(kCFAllocatorDefault, 0LL, &kCFTypeArrayCallBacks);
  int v9 = v8;
  if (Mutable) {
    BOOL v10 = v8 == 0LL;
  }
  else {
    BOOL v10 = 1;
  }
  if (v10)
  {
    uint64_t v34 = objc_autoreleasePoolPush();
    if (qword_100219F60) {
      [qword_100219F60 WFLog:@"%s: Failed to create remaining or supp ch list array" message:3];
    }
    objc_autoreleasePoolPop(v34);
    uint64_t v13 = 4294963394LL;
LABEL_44:
    char v30 = 1;
    if (!v9) {
      goto LABEL_46;
    }
    goto LABEL_45;
  }

  uint64_t v11 = *(void *)(a1 + 64);
  uint64_t v12 = (const void *)sub_100043E8C(v11);
  uint64_t v13 = sub_100044EB0(v11, v12, v9);
  if ((_DWORD)v13)
  {
    uint64_t v35 = objc_autoreleasePoolPush();
    if (qword_100219F60) {
      [qword_100219F60 WFLog:@"Device failed to return supported channels."];
    }
  }

  else
  {
    if (CFArrayGetCount(v9))
    {
      id v14 = CFStringCreateMutable(kCFAllocatorDefault, 0LL);
      *(_DWORD *)(a1 + 6160) = 0;
      CFMutableArrayRef v15 = objc_autoreleasePoolPush();
      if (qword_100219F60)
      {
        CFIndex v16 = +[NSString stringWithFormat:]( &OBJC_CLASS___NSString,  "stringWithFormat:",  @"%s",  -[NSString UTF8String]( +[NSString stringWithFormat:]( &OBJC_CLASS___NSString,  "stringWithFormat:",  @"{%@*} %@",  @"AUTOJOIN, SCAN",  +[NSString stringWithFormat:]( &OBJC_CLASS___NSString,  "stringWithFormat:",  @"multi-stage auto-join: Attempting to scan remaining channels%s",  ".")),  "UTF8String"));
        if (os_log_type_enabled((os_log_t)&_os_log_default, OS_LOG_TYPE_DEFAULT))
        {
          uint64_t v17 = -[NSString UTF8String]( +[NSString stringWithFormat:]( &OBJC_CLASS___NSString,  "stringWithFormat:",  @"[WiFiPolicy] %s",  -[NSString UTF8String](v16, "UTF8String")),  "UTF8String");
          *(_DWORD *)__int128 buf = 136446210;
          *(void *)&uint8_t buf[4] = v17;
          _os_log_impl( (void *)&_mh_execute_header,  (os_log_t)&_os_log_default,  OS_LOG_TYPE_DEFAULT,  "%{public}s",  buf,  0xCu);
        }
      }

      objc_autoreleasePoolPop(v15);
      if (CFArrayGetCount(v9) >= 1)
      {
        for (CFIndex i = 0LL; i < CFArrayGetCount(v9); ++i)
        {
          ValueAtIndex = (const __CFDictionary *)CFArrayGetValueAtIndex(v9, i);
          if (ValueAtIndex)
          {
            uint64_t v20 = ValueAtIndex;
            CFBooleanRef Value = (void *)CFDictionaryGetValue(ValueAtIndex, @"SUP_CHANNEL");
            CFRange v22 = (void *)CFDictionaryGetValue(v20, @"SUP_CHANNEL_FLAGS");
            if (Value)
            {
              int v23 = v22;
              if (v22)
              {
                if (sub_100105068(*(const __CFArray **)(a1 + 3280), Value) != 1)
                {
                  *(_OWORD *)__int128 buf = *(_OWORD *)off_1001E4F98;
                  values[0] = Value;
                  values[1] = v23;
                  CFDictionaryRef v24 = CFDictionaryCreate( kCFAllocatorDefault,  (const void **)buf,  (const void **)values,  2LL,  &kCFTypeDictionaryKeyCallBacks,  &kCFTypeDictionaryValueCallBacks);
                  if (v24)
                  {
                    CFDictionaryRef v25 = v24;
                    CFArrayAppendValue(Mutable, v24);
                    CFArrayAppendValue(*(CFMutableArrayRef *)(a1 + 3280), v25);
                    CFRelease(v25);
                    if (v14) {
                      CFStringAppendFormat(v14, 0LL, @"%@ ", Value);
                    }
                  }
                }

                continue;
              }

              uint64_t v26 = objc_autoreleasePoolPush();
              if (qword_100219F60) {
                [qword_100219F60 WFLog:@"Null channel flag" message:3];
              }
            }

            else
            {
              uint64_t v26 = objc_autoreleasePoolPush();
              if (qword_100219F60) {
                [qword_100219F60 WFLog:@"%s: Null channel number" message:3];
              }
            }

            objc_autoreleasePoolPop(v26);
          }
        }
      }

      sub_1000FD888(a1);
      if (v14)
      {
        CFMutableStringRef v27 = objc_autoreleasePoolPush();
        if (qword_100219F60)
        {
          uint64_t v28 = +[NSString stringWithFormat:]( &OBJC_CLASS___NSString,  "stringWithFormat:",  @"%s",  -[NSString UTF8String]( +[NSString stringWithFormat:]( &OBJC_CLASS___NSString,  "stringWithFormat:",  @"{%@*} %@",  @"AUTOJOIN, SCAN",  +[NSString stringWithFormat:]( &OBJC_CLASS___NSString,  "stringWithFormat:",  @"Scanning(%s) remaining channels: %@",  "Active",  v14)),  "UTF8String"));
          if (os_log_type_enabled((os_log_t)&_os_log_default, OS_LOG_TYPE_DEFAULT))
          {
            CFDictionaryRef v29 = -[NSString UTF8String]( +[NSString stringWithFormat:]( &OBJC_CLASS___NSString,  "stringWithFormat:",  @"[WiFiPolicy] %s",  -[NSString UTF8String](v28, "UTF8String")),  "UTF8String");
            *(_DWORD *)__int128 buf = 136446210;
            *(void *)&uint8_t buf[4] = v29;
            _os_log_impl( (void *)&_mh_execute_header,  (os_log_t)&_os_log_default,  OS_LOG_TYPE_DEFAULT,  "%{public}s",  buf,  0xCu);
          }
        }

        objc_autoreleasePoolPop(v27);
      }

      if (CFArrayGetCount(Mutable))
      {
        *(_DWORD *)(a1 + 5612) = 2;
        uint64_t v13 = sub_1001036C0(a1, *(const __CFArray **)(a1 + 3544), Mutable, 0, 3LL);
        if (!v14) {
          goto LABEL_44;
        }
      }

      else
      {
        uint64_t v13 = 4294963394LL;
        if (!v14) {
          goto LABEL_44;
        }
      }

      CFRelease(v14);
      goto LABEL_44;
    }

    uint64_t v35 = objc_autoreleasePoolPush();
    if (qword_100219F60) {
      [qword_100219F60 WFLog:@"%s: Empty supported channels." message:@"__WiFiDeviceManagerScanRemainingChannels"];
    }
  }

  objc_autoreleasePoolPop(v35);
  char v30 = 0;
LABEL_45:
  CFRelease(v9);
LABEL_46:
  if (Mutable) {
    CFRelease(Mutable);
  }
  if ((_DWORD)v13)
  {
    int v31 = objc_autoreleasePoolPush();
    if (qword_100219F60) {
      [qword_100219F60 WFLog:@"multi-stage auto-join: Error scanning remaining channels, err=%d" message:4 v13];
    }
    objc_autoreleasePoolPop(v31);
    return sub_100105840(a1, v13);
  }

  else
  {
    uint64_t result = (const __CFArray *)v36;
    if ((v30 & 1) == 0)
    {
      CFMutableStringRef v33 = objc_autoreleasePoolPush();
      if (qword_100219F60) {
        [qword_100219F60 WFLog:@"%s: Fallback to all channel scans" message:3];
      }
      objc_autoreleasePoolPop(v33);
      return sub_1001010A4(a1);
    }
  }

  return result;
}

CFArrayRef sub_100105840(uint64_t a1, int a2)
{
  CFMutableArrayRef v4 = objc_autoreleasePoolPush();
  if (qword_100219F60)
  {
    CFIndex v5 = +[NSString stringWithFormat:]( &OBJC_CLASS___NSString,  "stringWithFormat:",  @"%s",  -[NSString UTF8String]( +[NSString stringWithFormat:]( &OBJC_CLASS___NSString,  "stringWithFormat:",  @"{%@*} %@",  @"AUTOJOIN",  +[NSString stringWithFormat:]( &OBJC_CLASS___NSString,  "stringWithFormat:",  @"%s: current state: %@",  "__WiFiDeviceManagerDetermineNextAction",  sub_1000BDC98(*(_DWORD *)(a1 + 3272)))),  "UTF8String"));
    if (os_log_type_enabled((os_log_t)&_os_log_default, OS_LOG_TYPE_DEFAULT))
    {
      *(_DWORD *)__int128 buf = 136446210;
      uint64_t v71 = -[NSString UTF8String]( +[NSString stringWithFormat:]( &OBJC_CLASS___NSString,  "stringWithFormat:",  @"[WiFiPolicy] %s",  -[NSString UTF8String](v5, "UTF8String")),  "UTF8String");
      _os_log_impl( (void *)&_mh_execute_header,  (os_log_t)&_os_log_default,  OS_LOG_TYPE_DEFAULT,  "%{public}s",  buf,  0xCu);
    }
  }

  objc_autoreleasePoolPop(v4);
  if (a2)
  {
    if (a2 == 82)
    {
      sub_1000D0428(a1);
      return 0LL;
    }

    return sub_1000F17B8(a1);
  }

  int v6 = *(const __CFArray **)(a1 + 1096);
  if (v6 && *(_BYTE *)(a1 + 6848) && *(_BYTE *)(a1 + 6939) && *(void *)(a1 + 6928))
  {
    CFIndex Count = CFArrayGetCount(*(CFArrayRef *)(a1 + 1096));
    CFIndex v8 = Count;
    if (Count < 1)
    {
      if (Count)
      {
        id v14 = objc_autoreleasePoolPush();
        if (qword_100219F60) {
          [qword_100219F60 WFLog:@"%s: null network." message:@"__WiFiDeviceManagerProcessAutoHotspotJoinRecommendedFromScanResults"];
        }
        objc_autoreleasePoolPop(v14);
      }
    }

    else
    {
      CFIndex v9 = 0LL;
      while (1)
      {
        ValueAtIndex = CFArrayGetValueAtIndex(v6, v9);
        if (ValueAtIndex)
        {
          uint64_t v11 = ValueAtIndex;
          uint64_t v12 = sub_100095BC8(ValueAtIndex);
          uint64_t v13 = sub_100095BC8(*(const void **)(a1 + 6928));
          if (CFEqual(v12, v13)) {
            break;
          }
        }

        if (v8 == ++v9) {
          goto LABEL_21;
        }
      }

      if (v8 != v9)
      {
        uint64_t v15 = sub_100043E8C(*(void *)(a1 + 64));
        *(_DWORD *)(a1 + 3272) = sub_1000EF770(a1, v15, 12LL, 0LL, v11, 0LL);
      }
    }
  }

void sub_100106158(uint64_t a1)
{
  if (*(void *)(a1 + 376))
  {
    if (*(void *)(a1 + 392))
    {
      if (*(double *)(a1 + 384) != 0.0)
      {
        CFAbsoluteTime valuePtr = CFAbsoluteTimeGetCurrent();
        CFNumberRef v2 = CFNumberCreate(kCFAllocatorDefault, kCFNumberDoubleType, &valuePtr);
        if (v2)
        {
          CFNumberRef v3 = v2;
          CFArrayAppendValue(*(CFMutableArrayRef *)(a1 + 376), v2);
          CFRelease(v3);
          CFMutableArrayRef v4 = objc_autoreleasePoolPush();
          if (qword_100219F60) {
            [qword_100219F60 WFLog:@"%s: there have been %ld auto-join attempts in the last %f seconds" message:3 CFArrayGetCount(*(CFArrayRef *)(a1 + 376)),  *(void *)(a1 + 384)];
          }
          objc_autoreleasePoolPop(v4);
        }
      }
    }
  }

void sub_10010622C(uint64_t a1, const __CFArray *a2)
{
  if (!a2)
  {
    uint64_t v13 = objc_autoreleasePoolPush();
    id v14 = (void *)qword_100219F60;
    if (qword_100219F60)
    {
      uint64_t v15 = "ScanResults is Null!";
LABEL_20:
      [v14 WFLog:4 message:v15];
    }

void sub_100106504(uint64_t a1, const void *a2, __CFString *a3)
{
  if (a1 && a2)
  {
    if (sub_100097264(a2)) {
      CFIndex v5 = sub_1000951FC((uint64_t)a2, @"BSSID");
    }
    else {
      CFIndex v5 = sub_100095BC8(a2);
    }
    CFStringAppendFormat(a3, 0LL, @"%@", v5);
    if (sub_1000957F4((BOOL)a2)) {
      CFStringAppend(a3, @"(WEP)");
    }
    CFStringAppendFormat(a3, 0LL, @", ");
  }

void sub_100106604(uint64_t a1, void *a2)
{
  if (!sub_1000FC698(a1, a2, 0))
  {
    CFMutableArrayRef v4 = objc_autoreleasePoolPush();
    id v5 = sub_1000A335C((uint64_t)a2);
    id v6 = [*(id *)(a1 + 6632) reasonsForNetworkInDenyListedState:v5 state:1 timestamps:0 reasonData:0];
    if (v6)
    {
      unsigned int v7 = v6;
      if ([v6 count])
      {
        unint64_t v8 = 0LL;
        int v9 = 0;
        do
        {
          id v10 = [v7 objectAtIndex:v8];
          if (v10)
          {
            unsigned __int16 v11 = (unsigned __int16)[v10 unsignedIntegerValue];
            if (v11 <= 0xCu && ((1 << v11) & v9) == 0)
            {
              v9 |= (unsigned __int16)(1 << v11);
              ++*(_WORD *)(a1 + 2LL * v11 + 5964);
            }
          }

          ++v8;
        }

        while (v8 < (unint64_t)[v7 count]);
      }

      if ([*(id *)(a1 + 6632) isNetworkDenyListedForAutoJoinDueToTrigDisc:v5 RSSI:0 timestamp:0])
      {
        int v13 = sub_100096BF4((uint64_t)a2, @"RSSI");
        if (v13 > -96)
        {
          if (v13 > -91)
          {
            if (v13 > -86)
            {
              if (v13 > -81)
              {
                if (v13 > -76)
                {
                  int v15 = *(_DWORD *)(a1 + 6132);
                  if (v13 > -71) {
                    int v14 = v15 | 0x40;
                  }
                  else {
                    int v14 = v15 | 0x20;
                  }
                }

                else
                {
                  int v14 = *(_DWORD *)(a1 + 6132) | 0x10;
                }
              }

              else
              {
                int v14 = *(_DWORD *)(a1 + 6132) | 8;
              }
            }

            else
            {
              int v14 = *(_DWORD *)(a1 + 6132) | 4;
            }
          }

          else
          {
            int v14 = *(_DWORD *)(a1 + 6132) | 2;
          }
        }

        else
        {
          int v14 = *(_DWORD *)(a1 + 6132) | 1;
        }

        *(_DWORD *)(a1 + 6132) = v14;
      }
    }

    else
    {
      CFIndex v16 = objc_autoreleasePoolPush();
      if (qword_100219F60) {
        [qword_100219F60 WFLog:@"%s !__WiFiDeviceManagerIsNetworkSuitableForAutojoin but couldn't get problematicNetwork" message:3];
      }
      objc_autoreleasePoolPop(v16);
    }

    objc_autoreleasePoolPop(v4);
  }

void sub_1001067FC(uint64_t a1, const void *a2, __CFString *a3)
{
  if (a1 && a2)
  {
    if (sub_100097264(a2)) {
      id v6 = @"*";
    }
    else {
      id v6 = (const __CFString *)sub_100095BC8(a2);
    }
    CFStringAppend(a3, v6);
    CFStringAppendFormat(a3, 0LL, @"-");
    unsigned int v7 = sub_1000951FC((uint64_t)a2, @"BSSID");
    CFStringAppendFormat(a3, 0LL, @"%@", v7);
    CFStringAppendFormat(a3, 0LL, @"-");
    unint64_t v8 = sub_100096A74((uint64_t)a2);
    CFStringAppendFormat(a3, 0LL, @"( C:%@, "), v8;
    int v9 = sub_100096BF4((uint64_t)a2, @"RSSI");
    CFStringAppendFormat(a3, 0LL, @"R:%ld, ", v9);
    id v10 = sub_100096BF4((uint64_t)a2, @"AGE");
    CFStringAppendFormat(a3, 0LL, @"A:%ld,", v10);
    if (sub_100095318((BOOL)a2))
    {
      BOOL v11 = sub_1000998D0((uint64_t)a2);
      CFStringAppend(a3, @",");
      if (v11) {
        uint64_t v12 = @" HS2.0-h";
      }
      else {
        uint64_t v12 = @" HS2.0-r";
      }
      CFStringAppend(a3, v12);
    }

    if (sub_100108C9C(a1, a2))
    {
      CFStringAppend(a3, @",");
      CFStringAppend(a3, @" HS");
    }

    if (sub_1000DAF1C(a1, a2))
    {
      CFStringAppend(a3, @",");
      CFStringAppend(a3, @" Cap");
    }

    if (sub_10009DF44((uint64_t)a2))
    {
      CFStringAppend(a3, @",");
      CFStringAppend(a3, @" Car");
    }

    if (sub_1000971AC((uint64_t)a2))
    {
      CFStringAppend(a3, @",");
      CFStringAppend(a3, @" Ad");
    }

    if (sub_100095B4C((uint64_t)a2))
    {
      CFStringAppend(a3, @",");
      CFStringAppend(a3, @" EAP");
    }

    if (sub_1000957F4((BOOL)a2))
    {
      CFStringAppend(a3, @",");
      CFStringAppend(a3, @" WEP");
    }

    if (sub_100096E90((uint64_t)a2))
    {
      CFStringAppend(a3, @",");
      CFStringAppend(a3, @" WPA");
    }

    if (sub_100096D08((const __CFDictionary *)a2))
    {
      CFStringAppend(a3, @",");
      CFStringAppend(a3, @" SAE");
    }

    CFStringAppendFormat(a3, 0LL, @""));
  }

void sub_100106AF8(uint64_t a1)
{
  if (!a1)
  {
    id v28 = objc_autoreleasePoolPush();
    if (qword_100219F60) {
      [qword_100219F60 WFLog:@"%s: manager object is NULL" message:3];
    }
    goto LABEL_86;
  }

  if (!*(void *)(a1 + 1104))
  {
    id v28 = objc_autoreleasePoolPush();
    if (qword_100219F60) {
      [qword_100219F60 WFLog:@"__WiFiDeviceManagerPrepareDeferredNetworkList: scan candidates is NULL"];
    }
    goto LABEL_86;
  }

  if (!*(void *)(a1 + 3560))
  {
    id v28 = objc_autoreleasePoolPush();
    if (qword_100219F60) {
      [qword_100219F60 WFLog:@"%s: deferred network list is NULL" message:3];
    }
    goto LABEL_86;
  }

  CFMutableStringRef Mutable = CFStringCreateMutable(kCFAllocatorDefault, 0LL);
  if (!Mutable)
  {
    id v28 = objc_autoreleasePoolPush();
    if (qword_100219F60) {
      [qword_100219F60 WFLog:@"message is NULL" message:3];
    }
LABEL_86:
    objc_autoreleasePoolPop(v28);
    return;
  }

  CFNumberRef v3 = Mutable;
  if (!CFArrayGetCount(*(CFArrayRef *)(a1 + 1104))) {
    goto LABEL_77;
  }
  CFIndex Count = CFArrayGetCount(*(CFArrayRef *)(a1 + 3616));
  if (CFArrayGetCount(*(CFArrayRef *)(a1 + 1104)) < 1) {
    goto LABEL_77;
  }
  CFIndex v4 = 0LL;
  uint64_t v30 = 0LL;
  id v5 = 0LL;
  int v6 = 1;
  do
  {
    ValueAtIndex = CFArrayGetValueAtIndex(*(CFArrayRef *)(a1 + 1104), v4);
    if (!ValueAtIndex) {
      goto LABEL_59;
    }
    unint64_t v8 = ValueAtIndex;
    if (sub_10009DF44((uint64_t)ValueAtIndex))
    {
      if (*(_DWORD *)(a1 + 5512) == 1) {
        goto LABEL_59;
      }
    }

    int v9 = *(const void **)(a1 + 3504);
    if (v9)
    {
      if (CFEqual(v9, v8)
        && !sub_100053B28(*(void *)(a1 + 64))
        && !-[WiFiUserInteractionMonitor isCellularDataUsable]( +[WiFiUserInteractionMonitor sharedInstance](&OBJC_CLASS___WiFiUserInteractionMonitor, "sharedInstance"),  "isCellularDataUsable"))
      {
        goto LABEL_59;
      }
    }

    if (sub_1000A4754((uint64_t)v8)
      && (sub_10009CEA8((uint64_t)v8)
       || sub_1000951FC((uint64_t)v8, @"WiFiNetworkAttributeIsPublic") == kCFBooleanTrue))
    {
      char v10 = 0;
      char v11 = 1;
    }

    else
    {
      char v11 = 0;
      char v10 = 1;
    }

    uint64_t v12 = *(const void **)(a1 + 3504);
    if (v12
      && (!CFEqual(v12, v8) || sub_1000DA400(a1, v8))
      && (int v13 = *(const void **)(a1 + 3504)) != 0LL
      && CFEqual(v13, v8))
    {
      unsigned int v14 = 0;
    }

    else
    {
      unsigned int v14 = [*(id *)(a1 + 3648) canDeferNetwork:v8 withUsageRank:sub_1000D3EF0(a1, v8) andMotionState:*(unsigned int *)(a1 + 3344)];
      v30 += v14;
      if (v14) {
        goto LABEL_30;
      }
    }

    if (Count < 1)
    {
LABEL_30:
      if (v14) {
        goto LABEL_31;
      }
      goto LABEL_33;
    }

    if (sub_100095318((BOOL)v8))
    {
      CFArrayAppendValue(*(CFMutableArrayRef *)(a1 + 3552), v8);
      char v15 = 0;
      ++v30;
      goto LABEL_32;
    }

void sub_100107114(uint64_t a1, const __CFArray *a2)
{
  if (!a1)
  {
    id v27 = objc_autoreleasePoolPush();
    if (qword_100219F60) {
      [qword_100219F60 WFLog:@"%s: manager is Null!"];
    }
    goto LABEL_51;
  }

  if (!a2)
  {
    id v27 = objc_autoreleasePoolPush();
    if (qword_100219F60) {
      [qword_100219F60 WFLog:@"__WiFiDeviceManagerFilterCandidatesWithRssiThreshold: no scan candidate network"];
    }
LABEL_51:
    objc_autoreleasePoolPop(v27);
    return;
  }

  CFMutableStringRef Mutable = CFStringCreateMutable(kCFAllocatorDefault, 0LL);
  if (CFArrayGetCount(a2) < 1)
  {
    char v6 = 0;
    int v7 = -1431655766;
    if (!Mutable) {
      return;
    }
LABEL_33:
    if (!CFStringGetLength(Mutable))
    {
LABEL_45:
      CFRelease(Mutable);
      return;
    }

    int v23 = objc_autoreleasePoolPush();
    if (v6)
    {
      if (!qword_100219F60) {
        goto LABEL_44;
      }
      CFIndex v24 = (v7 - 1) > 3 ? 0LL : off_1001E57A8[v7 - 1];
      id v25 = +[NSString stringWithFormat:]( &OBJC_CLASS___NSString,  "stringWithFormat:",  @"%s",  -[NSString UTF8String]( +[NSString stringWithFormat:]( &OBJC_CLASS___NSString,  "stringWithFormat:",  @"{%@*} %@",  @"AUTOJOIN",  +[NSString stringWithFormat:]( &OBJC_CLASS___NSString,  "stringWithFormat:",  @"Filtering scan results in %@ due to AJ RSSI threshold: %@",  v24,  Mutable)),  "UTF8String"));
      if (!os_log_type_enabled((os_log_t)&_os_log_default, OS_LOG_TYPE_DEFAULT)) {
        goto LABEL_44;
      }
    }

    else
    {
      if (!qword_100219F60) {
        goto LABEL_44;
      }
      id v25 = +[NSString stringWithFormat:]( &OBJC_CLASS___NSString,  "stringWithFormat:",  @"%s",  -[NSString UTF8String]( +[NSString stringWithFormat:]( &OBJC_CLASS___NSString,  "stringWithFormat:",  @"{%@*} %@",  @"AUTOJOIN",  +[NSString stringWithFormat:]( &OBJC_CLASS___NSString,  "stringWithFormat:",  @"Filtering scan results due to AJ RSSI threshold: %@",  Mutable)),  "UTF8String"));
      if (!os_log_type_enabled((os_log_t)&_os_log_default, OS_LOG_TYPE_DEFAULT)) {
        goto LABEL_44;
      }
    }

    id v26 = -[NSString UTF8String]( +[NSString stringWithFormat:]( &OBJC_CLASS___NSString,  "stringWithFormat:",  @"[WiFiPolicy] %s",  -[NSString UTF8String](v25, "UTF8String")),  "UTF8String");
    *(_DWORD *)__int128 buf = 136446210;
    CFRange v31 = v26;
    _os_log_impl((void *)&_mh_execute_header, (os_log_t)&_os_log_default, OS_LOG_TYPE_DEFAULT, "%{public}s", buf, 0xCu);
LABEL_44:
    objc_autoreleasePoolPop(v23);
    goto LABEL_45;
  }

  CFIndex v5 = 0LL;
  char v6 = 0;
  int v7 = -1431655766;
  unint64_t v8 = Mutable;
  do
  {
    ValueAtIndex = (void *)CFArrayGetValueAtIndex(a2, v5);
    if (ValueAtIndex)
    {
      char v10 = ValueAtIndex;
      *(_DWORD *)__int128 buf = -1431655766;
      char v11 = sub_100096BF4((uint64_t)ValueAtIndex, @"RSSI");
      int v12 = sub_1000FD668(a1, v10, 1, (int *)buf);
      if ((*(_DWORD *)buf - 1) < 2)
      {
        int v7 = *(_DWORD *)buf;
        char v6 = 1;
      }

      if (*(_BYTE *)(a1 + 40) && *(_DWORD *)(a1 + 44))
      {
        int v13 = objc_autoreleasePoolPush();
        if (qword_100219F60) {
          objc_msgSend( (id)qword_100219F60,  "WFLog:message:",  4,  "%s: Using Simulated RSSI Value(%d) instead of actual RSSI value(%d)",  "__WiFiDeviceManagerFilterCandidatesWithRssiThreshold",  *(unsigned int *)(a1 + 44),  v11);
        }
        objc_autoreleasePoolPop(v13);
        LODWORD(v11) = *(_DWORD *)(a1 + 44);
        CFMutableStringRef Mutable = v8;
      }

      if ((int)v11 < v12)
      {
        if (Mutable)
        {
          int v14 = *(_DWORD *)buf;
          unsigned int v15 = *(_DWORD *)buf - 5;
          BOOL v16 = sub_100097264(v10);
          if (v15 >= 0xFFFFFFFE)
          {
            if (v16) {
              __int16 v18 = sub_1000951FC((uint64_t)v10, @"BSSID");
            }
            else {
              __int16 v18 = sub_100095BC8(v10);
            }
            uint64_t v20 = v18;
            BOOL v21 = sub_100096BF4((uint64_t)v10, @"RSSI");
            CFIndex v22 = @"MovingNw";
            if (v14 != 3) {
              CFIndex v22 = 0LL;
            }
            if (v14 == 4) {
              CFIndex v22 = @"OmnipresentNw";
            }
            CFMutableStringRef Mutable = v8;
            CFStringAppendFormat(v8, 0LL, @"%@(%ld {%@}), ", v20, v21, v22);
          }

          else
          {
            if (v16) {
              int v17 = sub_1000951FC((uint64_t)v10, @"BSSID");
            }
            else {
              int v17 = sub_100095BC8(v10);
            }
            uint64_t v19 = v17;
            CFMutableStringRef Mutable = v8;
            id v28 = sub_100096BF4((uint64_t)v10, @"RSSI");
            CFStringAppendFormat(v8, 0LL, @"%@(%ld), ", v19, v28, v29);
          }
        }

        CFArrayRemoveValueAtIndex(a2, v5--);
      }
    }

    ++v5;
  }

  while (v5 < CFArrayGetCount(a2));
  if (Mutable) {
    goto LABEL_33;
  }
}

void sub_100107620(const __CFArray *a1, int a2, CFTypeRef *a3)
{
  CFAllocatorRef v34 = kCFAllocatorDefault;
  CFMutableStringRef Mutable = CFStringCreateMutable(kCFAllocatorDefault, 0LL);
  if (!a1 || (int Count = CFArrayGetCount(a1), Count < 1))
  {
    char v10 = 0LL;
    uint64_t v9 = 0LL;
    goto LABEL_26;
  }

  id v33 = a3;
  CFIndex v8 = 0LL;
  uint64_t v9 = 0LL;
  char v10 = 0LL;
  CFIndex v11 = Count - 1;
  uint64_t v12 = Count;
  do
  {
    ValueAtIndex = CFArrayGetValueAtIndex(a1, v8);
    if (ValueAtIndex)
    {
      int v14 = ValueAtIndex;
      if (Mutable)
      {
        if (a2 && sub_100097264(ValueAtIndex)) {
          ++v9;
        }
        unsigned int v15 = (const __CFString *)sub_100095BC8(v14);
        if (v8 >= v11) {
          CFStringAppend(Mutable, v15);
        }
        else {
          CFStringAppendFormat(Mutable, 0LL, @"%@, ", v15);
        }
      }

      BOOL v16 = sub_100097264(v14);
      if (a2)
      {
        if (v16)
        {
          int v17 = (void *)sub_1000951FC((uint64_t)v14, @"CHANNEL");
          if (v17)
          {
            __int16 v18 = v17;
            uint64_t v19 = (void *)sub_1000951FC((uint64_t)v14, @"CHANNEL_FLAGS");
            if (v19)
            {
              uint64_t v20 = v19;
              if (v10
                || (char v10 = CFDictionaryCreateMutable( v34,  0LL,  &kCFTypeDictionaryKeyCallBacks,  &kCFTypeDictionaryValueCallBacks)) != 0LL)
              {
                *(_OWORD *)keys = *(_OWORD *)off_1001E4F98;
                values[0] = v18;
                values[1] = v20;
                CFDictionaryRef v21 = CFDictionaryCreate( v34,  (const void **)keys,  (const void **)values,  2LL,  &kCFTypeDictionaryKeyCallBacks,  &kCFTypeDictionaryValueCallBacks);
                if (v21)
                {
                  CFDictionaryRef v22 = v21;
                  CFDictionarySetValue(v10, v18, v21);
                  CFRelease(v22);
                }
              }
            }
          }
        }
      }
    }

    ++v8;
  }

  while (v12 != v8);
  if (v10)
  {
    a3 = v33;
    if (!CFDictionaryGetCount(v10))
    {
      CFRelease(v10);
      char v10 = 0LL;
      if (!Mutable) {
        goto LABEL_30;
      }
      goto LABEL_27;
    }

CFIndex sub_1001079F0(uint64_t a1)
{
  CFNumberRef v2 = objc_autoreleasePoolPush();
  if (qword_100219F60)
  {
    CFNumberRef v3 = +[NSString stringWithFormat:]( &OBJC_CLASS___NSString,  "stringWithFormat:",  @"%s",  -[NSString UTF8String]( +[NSString stringWithFormat:]( &OBJC_CLASS___NSString,  "stringWithFormat:",  @"{%@*} %@",  @"AUTOJOIN",  +[NSString stringWithFormat:]( &OBJC_CLASS___NSString,  "stringWithFormat:",  @"%s: current state: %@ ",  "__WiFiDeviceManagerPrepareCandidates",  sub_1000BDC98(*(_DWORD *)(a1 + 3272)))),  "UTF8String"));
    if (os_log_type_enabled((os_log_t)&_os_log_default, OS_LOG_TYPE_DEFAULT))
    {
      *(_DWORD *)__int128 buf = 136446210;
      id v64 = -[NSString UTF8String]( +[NSString stringWithFormat:]( &OBJC_CLASS___NSString,  "stringWithFormat:",  @"[WiFiPolicy] %s",  -[NSString UTF8String](v3, "UTF8String")),  "UTF8String");
      _os_log_impl( (void *)&_mh_execute_header,  (os_log_t)&_os_log_default,  OS_LOG_TYPE_DEFAULT,  "%{public}s",  buf,  0xCu);
    }
  }

  objc_autoreleasePoolPop(v2);
  CFIndex v4 = *(const __CFArray **)(a1 + 1104);
  if (v4)
  {
    CFIndex result = CFArrayGetCount(v4);
    if (!result) {
      return result;
    }
    CFIndex v6 = result;
    v65.location = 0LL;
    v65.length = result;
    CFArraySortValues(*(CFMutableArrayRef *)(a1 + 1104), v65, (CFComparatorFunction)sub_100108D18, (void *)a1);
    if (*(_DWORD *)(a1 + 3272) == 11) {
      goto LABEL_10;
    }
    int v7 = *(const void **)(a1 + 3504);
    if (!v7) {
      goto LABEL_10;
    }
    if (sub_100108C9C(a1, v7)) {
      goto LABEL_10;
    }
    if (sub_100095318(*(void *)(a1 + 3504))) {
      goto LABEL_10;
    }
    v66.location = 0LL;
    v66.length = v6;
    FirstIndexOfCFBooleanRef Value = CFArrayGetFirstIndexOfValue(*(CFArrayRef *)(a1 + 1104), v66, *(const void **)(a1 + 3504));
    if (FirstIndexOfValue == -1) {
      goto LABEL_10;
    }
    CFIndex v46 = FirstIndexOfValue;
    ValueAtIndex = CFArrayGetValueAtIndex(*(CFArrayRef *)(a1 + 1104), FirstIndexOfValue);
    if (sub_100097700(*(void *)(a1 + 3504)))
    {
      CFBooleanRef v48 = (CFBooleanRef)sub_1000951FC(*(void *)(a1 + 3504), @"WiFiInstantHotspotJoining");
      if (v48 == kCFBooleanTrue)
      {
        sub_10009582C((uint64_t)ValueAtIndex, @"WiFiInstantHotspotJoining", v48);
        int v49 = 1;
      }

      else
      {
        int v49 = 0;
      }

      if (sub_1000951FC(*(void *)(a1 + 3504), @"WiFiAutoInstantHotspotJoining") == kCFBooleanTrue)
      {
        sub_10009582C((uint64_t)ValueAtIndex, @"WiFiAutoInstantHotspotJoining", kCFBooleanTrue);
        char v50 = 1;
        goto LABEL_65;
      }
    }

    else
    {
      int v49 = 0;
    }

    char v50 = 0;
LABEL_65:
    CFRetain(ValueAtIndex);
    CFArrayRemoveValueAtIndex(*(CFMutableArrayRef *)(a1 + 1104), v46);
    CFArrayInsertValueAtIndex(*(CFMutableArrayRef *)(a1 + 1104), 0LL, ValueAtIndex);
    if (ValueAtIndex) {
      CFRelease(ValueAtIndex);
    }
    char v51 = v50 ^ 1;
    if (v49) {
      char v51 = 0;
    }
    if ((v51 & 1) == 0)
    {
      uint64_t v52 = (const __CFDate *)sub_1000951FC(*(void *)(a1 + 3504), @"lastDisconnectTimestampKey");
      if (v52)
      {
        CFRange v53 = v52;
        double Current = CFAbsoluteTimeGetCurrent();
        if (Current - CFDateGetAbsoluteTime(v53) > 300.0)
        {
          CFRange v55 = objc_autoreleasePoolPush();
          if (qword_100219F60)
          {
            uint64_t v56 = sub_100095BC8(*(const void **)(a1 + 3504));
            unsigned int v57 = v49 ? "Instant" : "Auto instant";
            double v58 = CFAbsoluteTimeGetCurrent();
            uint64_t v59 = +[NSString stringWithFormat:]( &OBJC_CLASS___NSString,  "stringWithFormat:",  @"%s",  -[NSString UTF8String]( +[NSString stringWithFormat:]( &OBJC_CLASS___NSString,  "stringWithFormat:",  @"{%@*} %@",  @"AUTOJOIN",  +[NSString stringWithFormat:]( &OBJC_CLASS___NSString,  "stringWithFormat:",  @"%s Ignore Previous Hotspot %@ type(%s) disconnect time since linkDown %f",  "__WiFiDeviceManagerPrepareCandidates",  v56,  v57,  v58 - CFDateGetAbsoluteTime(v53))),  "UTF8String"));
            if (os_log_type_enabled((os_log_t)&_os_log_default, OS_LOG_TYPE_DEFAULT))
            {
              uint64_t v60 = -[NSString UTF8String]( +[NSString stringWithFormat:]( &OBJC_CLASS___NSString,  "stringWithFormat:",  @"[WiFiPolicy] %s",  -[NSString UTF8String](v59, "UTF8String")),  "UTF8String");
              *(_DWORD *)__int128 buf = 136446210;
              id v64 = v60;
              _os_log_impl( (void *)&_mh_execute_header,  (os_log_t)&_os_log_default,  OS_LOG_TYPE_DEFAULT,  "%{public}s",  buf,  0xCu);
            }
          }

          objc_autoreleasePoolPop(v55);
          CFArrayRemoveValueAtIndex(*(CFMutableArrayRef *)(a1 + 1104), 0LL);
        }
      }
    }

uint64_t sub_10010824C(uint64_t a1)
{
  uint64_t v1 = a1;
  CFNumberRef v2 = (_BYTE *)(a1 + 6848);
  int v3 = sub_1000DCBFC(a1, 1LL);
  if (v3)
  {
    CFIndex v4 = *(const __CFArray **)(v1 + 1104);
    if (v4)
    {
      int v37 = v3;
      CFIndex Count = CFArrayGetCount(v4);
      if (Count && (v6 = Count, CFIndex v7 = *(void *)(v1 + 1112), v7 < Count))
      {
        uint64_t v38 = v1;
        while (1)
        {
          ValueAtIndex = (void *)CFArrayGetValueAtIndex(*(CFArrayRef *)(v1 + 1104), v7);
          uint64_t v9 = objc_autoreleasePoolPush();
          if (!ValueAtIndex) {
            break;
          }
          if (qword_100219F60)
          {
            char v10 = +[NSString stringWithFormat:]( &OBJC_CLASS___NSString,  "stringWithFormat:",  @"%s",  -[NSString UTF8String]( +[NSString stringWithFormat:]( &OBJC_CLASS___NSString,  "stringWithFormat:",  @"{%@*} %@",  @"AUTOJOIN",  +[NSString stringWithFormat:]( &OBJC_CLASS___NSString,  "stringWithFormat:",  @"Autojoin is processing network %ld of %ld candidates",  *(void *)(v1 + 1112) + 1LL,  v6)),  "UTF8String"));
            if (os_log_type_enabled((os_log_t)&_os_log_default, OS_LOG_TYPE_DEFAULT))
            {
              uint64_t v1 = v38;
              CFIndex v11 = -[NSString UTF8String]( +[NSString stringWithFormat:]( &OBJC_CLASS___NSString,  "stringWithFormat:",  @"[WiFiPolicy] %s",  -[NSString UTF8String](v10, "UTF8String")),  "UTF8String");
              *(_DWORD *)__int128 buf = 136446210;
              unsigned int v40 = v11;
              _os_log_impl( (void *)&_mh_execute_header,  (os_log_t)&_os_log_default,  OS_LOG_TYPE_DEFAULT,  "%{public}s",  buf,  0xCu);
            }
          }

          objc_autoreleasePoolPop(v9);
          if ((!*(_BYTE *)(v1 + 24) || !sub_1000452B8(*(void *)(v1 + 64)) || *(_DWORD *)(v1 + 28))
            && sub_100097264(ValueAtIndex))
          {
            int v34 = objc_autoreleasePoolPush();
            if (qword_100219F60) {
              [(id)qword_100219F60 WFLog:3 message:"Autojoin candidate contains hidden ssid"];
            }
            objc_autoreleasePoolPop(v34);
            id v35 = sub_1000951FC((uint64_t)ValueAtIndex, @"CHANNEL");
            return sub_100109094(v1, v35);
          }

          ++*(void *)(v1 + 1112);
          CFIndex v12 = objc_autoreleasePoolPush();
          if (qword_100219F60) {
            [qword_100219F60 WFLog:@"%s: manager->joinRecommendationMode = %d" message:3, "__WiFiDeviceManagerProcessCandidates", *(unsigned int *)(v1 + 6560)];
          }
          objc_autoreleasePoolPop(v12);
          int v13 = *(_DWORD *)(v1 + 3272);
          if (v13 == 21)
          {
            uint64_t v19 = objc_autoreleasePoolPush();
            if (qword_100219F60) {
              [(id)qword_100219F60 WFLog:3, "%s: not the right time to ask for approval to join for %@. Retrying next candidate.", "__WiFiDeviceManagerProcessCandidates", sub_100095BC8(ValueAtIndex) message];
            }
            objc_autoreleasePoolPop(v19);
          }

          else
          {
            if (v13 == 14)
            {
              unsigned int v36 = objc_autoreleasePoolPush();
              if (qword_100219F60) {
                [(id)qword_100219F60 WFLog:3, "%s: requesting approval to join. Waiting for user input for %@.", "__WiFiDeviceManagerProcessCandidates", sub_100095BC8(ValueAtIndex) message];
              }
              objc_autoreleasePoolPop(v36);
              return 14LL;
            }

            if (!*v2) {
              goto LABEL_37;
            }
            int v14 = (const void *)sub_100043E8C(*(void *)(v1 + 64));
            unsigned int v15 = sub_1000DEA34(v1, v14, 1);
            if (!v15
              || (CFIndex v16 = v15,
                  CFIndex v17 = sub_100095BC8(v15),
                  __int16 v18 = sub_100095BC8(ValueAtIndex),
                  LODWORD(v17) = CFEqual(v17, v18),
                  CFRelease(v16),
                  !(_DWORD)v17))
            {
              CFIndex v24 = objc_autoreleasePoolPush();
              if (qword_100219F60) {
                [(id)qword_100219F60 WFLog:3, "%s: Disconnect from Hotspot. Attempting network transition to %@!!", "__WiFiDeviceManagerProcessCandidates", sub_100095BC8(ValueAtIndex) message];
              }
              objc_autoreleasePoolPop(v24);
              BOOL v25 = (const void *)sub_100043E8C(*(void *)(v1 + 64));
              sub_1000CE074(v1, v25, 1019LL, "__WiFiDeviceManagerProcessCandidates", 15494LL);
LABEL_37:
              if (_os_feature_enabled_impl("CoreWiFi", "UnifiedAutoJoin"))
              {
                BOOL v26 = (const void *)sub_100043E8C(*(void *)(v1 + 64));
                size_t v27 = sub_1000DEA34(v1, v26, 1);
                if (v27)
                {
                  unsigned int v28 = v27;
                  uint64_t v29 = objc_autoreleasePoolPush();
                  BOOL v30 = (void *)qword_100219F60;
                  if (qword_100219F60)
                  {
                    CFRange v31 = sub_100095BC8(v28);
                    [v30 WFLog:3, "%s: Disconnect from '%@', attempting network transition to '%@'", "__WiFiDeviceManagerProcessCandidates", v31, sub_100095BC8(ValueAtIndex) message];
                  }

                  objc_autoreleasePoolPop(v29);
                  BOOL v32 = (const void *)sub_100043E8C(*(void *)(v1 + 64));
                  sub_1000CE074(v1, v32, 1013LL, "__WiFiDeviceManagerProcessCandidates", 15511LL);
                  CFRelease(v28);
                }
              }

              id v33 = sub_1000EC354(v1, ValueAtIndex, 0);
              if ((_DWORD)v33) {
                return sub_100101580(v1, ValueAtIndex, 0LL, v33);
              }
              sub_10010D14C(v1, @"autoJoinAssociating", ValueAtIndex, 0LL);
              return 12LL;
            }
          }

          CFIndex v7 = *(void *)(v1 + 1112);
          if (v7 >= v6) {
            goto LABEL_26;
          }
        }

        if (qword_100219F60) {
          [qword_100219F60 WFLog:@"%s: null network" message:3];
        }
        objc_autoreleasePoolPop(v9);
        ValueAtIndex = 0LL;
      }

      else
      {
        ValueAtIndex = 0LL;
LABEL_26:
        uint64_t v20 = objc_autoreleasePoolPush();
        if (qword_100219F60) {
          [qword_100219F60 WFLog:@"Done processing AJ candidates, %ld" message:3];
        }
        objc_autoreleasePoolPop(v20);
      }

      uint64_t v22 = 0LL;
      int v3 = v37;
    }

    else
    {
      ValueAtIndex = 0LL;
      uint64_t v22 = 0LL;
    }
  }

  else
  {
    BOOL v21 = objc_autoreleasePoolPush();
    if (qword_100219F60) {
      [(id)qword_100219F60 WFLog:3, "Autojoin cancelled due to concurrent state %@(%d)", sub_10003B244(v2[161]), v2[161] message];
    }
    objc_autoreleasePoolPop(v21);
    ValueAtIndex = 0LL;
    uint64_t v22 = 4294963393LL;
  }

  if (_os_feature_enabled_impl("CoreWiFi", "UnifiedAutoJoin"))
  {
    sub_100109874( v1,  (uint64_t)ValueAtIndex,  (int)v22,  CWFManagerErrorDomain,  (uint64_t)@"Failed to process join candidate");
    return 0LL;
  }

  else if (*(_BYTE *)(v1 + 24) && sub_1000452B8(*(void *)(v1 + 64)) && !*(_DWORD *)(v1 + 28))
  {
    return sub_100109988((_DWORD *)v1, v22);
  }

  else if (v3)
  {
    return sub_1001088A8(v1);
  }

  else
  {
    return sub_100105840(v1, v22);
  }

uint64_t sub_1001088A8(uint64_t a1)
{
  CFNumberRef v2 = *(const void **)(a1 + 1104);
  if (v2)
  {
    CFRelease(v2);
    *(void *)(a1 + 1104) = 0LL;
  }

  if (!CFArrayGetCount(*(CFArrayRef *)(a1 + 3320)))
  {
    __int16 v18 = objc_autoreleasePoolPush();
    if (qword_100219F60) {
      [qword_100219F60 WFLog:@"__WiFiDeviceManagerProcessDeferredNetworks: No GAS queries."];
    }
    goto LABEL_26;
  }

  int v3 = *(const __CFArray **)(a1 + 3552);
  if (!v3)
  {
    __int16 v18 = objc_autoreleasePoolPush();
    if (qword_100219F60) {
      [qword_100219F60 WFLog:@"__WiFiDeviceManagerProcessDeferredNetworks: No scan results"];
    }
    goto LABEL_26;
  }

  if (!CFArrayGetCount(v3))
  {
    __int16 v18 = objc_autoreleasePoolPush();
    if (qword_100219F60) {
      objc_msgSend((id)qword_100219F60, "WFLog:message:", 3, "No HS2.0 networks to query", v24);
    }
LABEL_26:
    objc_autoreleasePoolPop(v18);
    goto LABEL_27;
  }

  int valuePtr = 0;
  CFMutableDictionaryRef Mutable = CFDictionaryCreateMutable( kCFAllocatorDefault,  0LL,  &kCFTypeDictionaryKeyCallBacks,  &kCFTypeDictionaryValueCallBacks);
  if (!Mutable)
  {
LABEL_27:
    CFIndex Count = CFArrayGetCount(*(CFArrayRef *)(a1 + 3560));
    if (Count)
    {
      CFIndex v20 = Count;
      BOOL v21 = *(__CFArray **)(a1 + 1104);
      if (!v21)
      {
        BOOL v21 = CFArrayCreateMutable(kCFAllocatorDefault, 0LL, &kCFTypeArrayCallBacks);
        *(void *)(a1 + 1104) = v21;
      }

      v26.location = 0LL;
      v26.length = v20;
      CFArrayAppendArray(v21, *(CFArrayRef *)(a1 + 3560), v26);
      uint64_t v22 = objc_autoreleasePoolPush();
      if (qword_100219F60) {
        [qword_100219F60 WFLog:@"__WiFiDeviceManagerProcessDeferredNetworks: Appending deffered networks to candidates list"];
      }
      objc_autoreleasePoolPop(v22);
    }

    CFArrayRemoveAllValues(*(CFMutableArrayRef *)(a1 + 3552));
    CFArrayRemoveAllValues(*(CFMutableArrayRef *)(a1 + 3560));
    [*(id *)(a1 + 3648) clearScanResultsForAutoJoinSessionReset];
    sub_100107114(a1, *(const __CFArray **)(a1 + 1104));
    uint64_t v16 = 0LL;
    return sub_100105840(a1, v16);
  }

  CFIndex v5 = Mutable;
  CFNumberRef v6 = CFNumberCreate(kCFAllocatorDefault, kCFNumberSInt32Type, &valuePtr);
  CFDictionaryAddValue(v5, @"GAS_PROTOCOL", v6);
  CFDictionaryAddValue(v5, @"GAS_QUERY", *(const void **)(a1 + 3320));
  CFDictionaryAddValue(v5, @"GAS_NETWORKS", *(const void **)(a1 + 3552));
  CFIndex v7 = CFArrayGetCount(*(CFArrayRef *)(a1 + 3552));
  CFIndex v8 = CFStringCreateMutable(kCFAllocatorDefault, 0LL);
  if (v7 >= 1)
  {
    for (CFIndex i = 0LL; i != v7; ++i)
    {
      ValueAtIndex = CFArrayGetValueAtIndex(*(CFArrayRef *)(a1 + 3552), i);
      CFIndex v11 = (const __CFString *)sub_1000951FC((uint64_t)ValueAtIndex, @"BSSID");
      if (v11)
      {
        if (i >= v7 - 1) {
          CFStringAppend(v8, v11);
        }
        else {
          CFStringAppendFormat(v8, 0LL, @"%@, ", v11);
        }
      }
    }
  }

  CFIndex v12 = malloc(0x18uLL);
  if (v12)
  {
    int v13 = v12;
    void *v12 = a1;
    v12[1] = sub_100109B20;
    unsigned int v12[2] = a1;
    uint64_t v14 = *(void *)(a1 + 64);
    unsigned int v15 = (const void *)sub_100043E8C(v14);
    uint64_t v16 = sub_100050654(v14, v15, v5, 0LL, (uint64_t)sub_1000E6958, (uint64_t)v13, (void *)(a1 + 3304));
    if ((_DWORD)v16) {
      free(v13);
    }
  }

  else
  {
    uint64_t v16 = 4294963395LL;
  }

  CFRelease(v5);
  if (v6) {
    CFRelease(v6);
  }
  CFIndex v17 = objc_autoreleasePoolPush();
  if ((_DWORD)v16)
  {
    if (qword_100219F60) {
      objc_msgSend((id)qword_100219F60, "WFLog:message:", 4, "Unable to send GAS query. Error %d", v16);
    }
    objc_autoreleasePoolPop(v17);
    if (v8) {
      CFRelease(v8);
    }
    return sub_100105840(a1, v16);
  }

  if (qword_100219F60) {
    [(id)qword_100219F60 WFLog:3, "%s: Sending GAS request to %@", "__WiFiDeviceManagerProcessDeferredNetworks", v8 message];
  }
  objc_autoreleasePoolPop(v17);
  if (v8) {
    CFRelease(v8);
  }
  return 13LL;
}

BOOL sub_100108C9C(uint64_t a1, const void *a2)
{
  if (a1
    && a2
    && !sub_100095318((BOOL)a2)
    && (CFIndex Count = CFArrayGetCount(*(CFArrayRef *)(a1 + 3568))) != 0
    && (v8.length = Count,
        v8.location = 0LL,
        FirstIndexOfCFBooleanRef Value = CFArrayGetFirstIndexOfValue(*(CFArrayRef *)(a1 + 3568), v8, a2),
        FirstIndexOfValue != -1)
    && (ValueAtIndex = CFArrayGetValueAtIndex(*(CFArrayRef *)(a1 + 3568), FirstIndexOfValue)) != 0LL)
  {
    return sub_100099810((uint64_t)ValueAtIndex);
  }

  else
  {
    return 0LL;
  }

uint64_t sub_100108D18(uint64_t a1, uint64_t a2, uint64_t a3)
{
  if (!a3) {
    goto LABEL_50;
  }
  if (a1 | a2) {
    uint64_t v6 = -1LL;
  }
  else {
    uint64_t v6 = 0LL;
  }
  if (a2) {
    uint64_t result = 1LL;
  }
  else {
    uint64_t result = v6;
  }
  if (!a1 || !a2) {
    return result;
  }
  CFIndex Count = CFArrayGetCount(*(CFArrayRef *)(a3 + 3568));
  if (!Count)
  {
LABEL_50:
    uint64_t v19 = (const void *)a2;
    ValueAtIndex = (const void *)a1;
    return sub_100099638((uint64_t)ValueAtIndex, (uint64_t)v19);
  }

  CFIndex v9 = Count;
  if (*(_DWORD *)(a3 + 3272) != 11) {
    goto LABEL_26;
  }
  char v10 = *(const __CFArray **)(a3 + 3360);
  if (!v10 || !CFArrayGetCount(v10)) {
    goto LABEL_26;
  }
  uint64_t v11 = sub_10009EEF4(*(const __CFArray **)(a3 + 3360), a1);
  uint64_t v12 = sub_10009EEF4(*(const __CFArray **)(a3 + 3360), a2);
  int v13 = objc_autoreleasePoolPush();
  uint64_t v14 = (void *)qword_100219F60;
  if (qword_100219F60)
  {
    unsigned int v15 = sub_100095BC8((const void *)a1);
    [v14 WFLog:3, "%s: ranking: %@(%ld), %@(%ld)", "__WiFiDeviceManagerNetworkCompareAutoJoinPriority", v15, v11, sub_100095BC8((const void *)a2), v12 message];
  }

  objc_autoreleasePoolPop(v13);
  if (v11 != -1 && v12 != -1)
  {
    if (v11 > v12) {
      return 1LL;
    }
    else {
      return -1LL;
    }
  }

  uint64_t result = v11 == -1 ? 1LL : -1LL;
  if (v11 == -1 && v12 == -1)
  {
LABEL_26:
    v34.location = 0LL;
    v34.length = v9;
    FirstIndexOfCFBooleanRef Value = CFArrayGetFirstIndexOfValue(*(CFArrayRef *)(a3 + 3568), v34, (const void *)a1);
    ValueAtIndex = (const void *)a1;
    if (FirstIndexOfValue != -1) {
      ValueAtIndex = CFArrayGetValueAtIndex(*(CFArrayRef *)(a3 + 3568), FirstIndexOfValue);
    }
    v35.location = 0LL;
    v35.length = v9;
    CFIndex v18 = CFArrayGetFirstIndexOfValue(*(CFArrayRef *)(a3 + 3568), v35, (const void *)a2);
    uint64_t v19 = (const void *)a2;
    if (v18 != -1) {
      uint64_t v19 = CFArrayGetValueAtIndex(*(CFArrayRef *)(a3 + 3568), v18);
    }
    if (*(_BYTE *)(a3 + 6616))
    {
      uint64_t result = sub_10009C5D4((uint64_t)ValueAtIndex, (uint64_t)v19, 0LL);
      if (result) {
        return result;
      }
      CFIndex v20 = (const __CFDate *)sub_1000951FC((uint64_t)ValueAtIndex, @"lastUpdated");
      BOOL v21 = (const __CFDate *)sub_1000951FC((uint64_t)v19, @"lastUpdated");
      uint64_t v22 = sub_100096BF4(a1, @"RSSI");
      BOOL v23 = sub_100096BF4(a2, @"RSSI");
      if (v20)
      {
        if (v21)
        {
          if ((uint64_t)v22 >= -65)
          {
            uint64_t v24 = v23;
            if ((uint64_t)v23 >= -65)
            {
              CFComparisonResult v25 = CFDateCompare(v20, v21, 0LL);
              CFRange v26 = objc_autoreleasePoolPush();
              size_t v27 = (void *)qword_100219F60;
              if (v25 == kCFCompareGreaterThan)
              {
                if (qword_100219F60)
                {
                  unsigned int v28 = sub_100095BC8(ValueAtIndex);
                  [v27 WFLog:4, "Preferred %@(%ld, %@) over %@ (%ld, %@)", v28, v22, v20, sub_100095BC8(v19), v24, v21 message];
                }

                objc_autoreleasePoolPop(v26);
                return -1LL;
              }

              if (qword_100219F60)
              {
                id v33 = sub_100095BC8(v19);
                [v27 WFLog:4, "Preferred %@(%ld, %@) over %@ (%ld, %@)", v33, v24, v21, sub_100095BC8(ValueAtIndex), v22, v20 message];
              }

              objc_autoreleasePoolPop(v26);
              return 1LL;
            }
          }
        }
      }
    }

    if (*(void *)(a3 + 6928))
    {
      uint64_t v29 = sub_100095BC8((const void *)a1);
      BOOL v30 = sub_100095BC8(*(const void **)(a3 + 6928));
      if (CFEqual(v29, v30)) {
        return -1LL;
      }
      CFRange v31 = sub_100095BC8((const void *)a2);
      BOOL v32 = sub_100095BC8(*(const void **)(a3 + 6928));
      if (CFEqual(v31, v32)) {
        return 1LL;
      }
    }

    return sub_100099638((uint64_t)ValueAtIndex, (uint64_t)v19);
  }

  return result;
}

uint64_t sub_100109094(uint64_t a1, const void *a2)
{
  CFIndex Count = CFArrayGetCount(*(CFArrayRef *)(a1 + 3544));
  CFMutableStringRef Mutable = CFStringCreateMutable(kCFAllocatorDefault, 0LL);
  uint64_t v6 = *(const __CFArray **)(a1 + 1104);
  if (!v6) {
    goto LABEL_116;
  }
  CFIndex v7 = CFArrayGetCount(v6);
  if (!v7 || (CFIndex v8 = *(void *)(a1 + 1112), v8 >= v7))
  {
    unsigned int v57 = objc_autoreleasePoolPush();
    if (qword_100219F60) {
      [qword_100219F60 WFLog:@"__WiFiDeviceManagerScanForHiddenNetworks: error: scan index invalid, %ld" message:3];
    }
    objc_autoreleasePoolPop(v57);
LABEL_116:
    uint64_t v50 = 4294963394LL;
    if (!Mutable) {
      return sub_100105840(a1, v50);
    }
    goto LABEL_95;
  }

  if (!*(void *)(a1 + 1144)) {
    goto LABEL_100;
  }
  ValueAtIndex = CFArrayGetValueAtIndex(*(CFArrayRef *)(a1 + 1104), v8);
  if (!sub_100097264(ValueAtIndex)) {
    goto LABEL_100;
  }
  if (*(void *)(a1 + 1136) >= (int)Count)
  {
    uint64_t v11 = objc_autoreleasePoolPush();
    if (qword_100219F60) {
      [qword_100219F60 WFLog:@"Autojoin reset hidden index %ld, hiddenCount %d" message:3];
    }
    objc_autoreleasePoolPop(v11);
    *(void *)(a1 + 1136) = 0LL;
    uint64_t v10 = *(void *)(a1 + 1112) + 1LL;
    *(void *)(a1 + 1112) = v10;
  }

  else
  {
    uint64_t v10 = *(void *)(a1 + 1112);
  }

  if (v10 < 1) {
    goto LABEL_18;
  }
  uint64_t v12 = (void *)CFArrayGetValueAtIndex(*(CFArrayRef *)(a1 + 1104), v10 - 1);
  if (!v12)
  {
    int v13 = objc_autoreleasePoolPush();
    if (qword_100219F60) {
      [qword_100219F60 WFLog:@"Previous Scan Candidate is Null!, index %ld" message:4];
    }
    objc_autoreleasePoolPop(v13);
LABEL_18:
    uint64_t v12 = 0LL;
  }

  CFIndex v14 = CFArrayGetCount(*(CFArrayRef *)(a1 + 1104));
  if (!v12 || *(void *)(a1 + 1136) || (CFIndex v15 = v14, !sub_1000971F8(v12)))
  {
LABEL_34:
    if (CFStringGetLength(Mutable))
    {
      v62.length = CFStringGetLength(Mutable);
      v62.location = 0LL;
      CFStringDelete(Mutable, v62);
    }

    BOOL v21 = (const __CFDictionary **)CFArrayGetValueAtIndex(*(CFArrayRef *)(a1 + 1104), *(void *)(a1 + 1112));
    CFIndex v22 = *(void *)(a1 + 1136);
    if (v22 < (int)Count)
    {
      do
      {
        BOOL v23 = (const __CFDictionary **)CFArrayGetValueAtIndex(*(CFArrayRef *)(a1 + 3544), v22);
        uint64_t v24 = *(const __CFArray **)(a1 + 1160);
        v63.length = CFArrayGetCount(v24);
        v63.location = 0LL;
        if (CFArrayGetFirstIndexOfValue(v24, v63, v23) == -1)
        {
          if (Mutable) {
            sub_100106504(a1, v23, Mutable);
          }
        }

        ++v22;
      }

      while ((int)Count != v22);
      CFIndex v22 = (int)Count;
    }

void sub_100109874(uint64_t a1, uint64_t a2, uint64_t a3, CFErrorDomain a4, uint64_t a5)
{
  uint64_t v10 = objc_autoreleasePoolPush();
  if (!a3) {
    a3 = 57LL;
  }
  if (!a4) {
    a4 = kCFErrorDomainPOSIX;
  }
  if (a5)
  {
    NSErrorUserInfoKey v14 = NSLocalizedDescriptionKey;
    uint64_t v15 = a5;
    uint64_t v11 = +[NSDictionary dictionaryWithObjects:forKeys:count:]( &OBJC_CLASS___NSDictionary,  "dictionaryWithObjects:forKeys:count:",  &v15,  &v14,  1LL);
    CFErrorDomain v12 = a4;
    uint64_t v13 = a3;
  }

  else
  {
    CFErrorDomain v12 = a4;
    uint64_t v13 = a3;
    uint64_t v11 = 0LL;
  }

  sub_1001099E8( a1,  a2,  (uint64_t)+[NSError errorWithDomain:code:userInfo:]( &OBJC_CLASS___NSError,  "errorWithDomain:code:userInfo:",  v12,  v13,  v11));
  objc_autoreleasePoolPop(v10);
}

uint64_t sub_100109988(_DWORD *a1, uint64_t a2)
{
  if (a1[1378] == 1 || *((_BYTE *)a1 + 5496)) {
    return sub_100103C48(a1);
  }
  unsigned int v3 = a1[819];
  if (v3 <= 0xB)
  {
    if (((1 << v3) & 0xC0) != 0) {
      return sub_100103D04();
    }
    if (((1 << v3) & 0x300) != 0) {
      return sub_1001050F0();
    }
    if (((1 << v3) & 0xC00) != 0) {
      return sub_1001088A8((uint64_t)a1);
    }
  }

  return sub_100105840(a1, a2);
}

void sub_1001099E8(uint64_t a1, uint64_t a2, uint64_t a3)
{
  uint64_t v6 = objc_autoreleasePoolPush();
  if (a1)
  {
    uint64_t v7 = *(void *)(a1 + 8792);
    if (v7)
    {
      uint64_t v8 = *(void *)(a1 + 8784);
      if (v8)
      {
        if (a2)
        {
          if (!sub_1000995FC(a2, v8)) {
            goto LABEL_10;
          }
          uint64_t v7 = *(void *)(a1 + 8792);
        }

        (*(void (**)(uint64_t, uint64_t))(v7 + 16))(v7, a3);
        _Block_release(*(const void **)(a1 + 8792));
        *(void *)(a1 + 8792) = 0LL;
        CFRelease(*(CFTypeRef *)(a1 + 8784));
        *(void *)(a1 + 8784) = 0LL;
        uint64_t v9 = *(void *)(a1 + 8872);
        uint64_t v10 = v9 + 1;
        BOOL v11 = v9 == -1;
        *(void *)(a1 + 8872) = v10;
        if (*(void *)(a1 + 8864) >= 6uLL && !v11)
        {
          sub_10004A048( *(void *)(a1 + 64),  0,  +[NSString stringWithFormat:]( NSString,  "stringWithFormat:",  @"%@/%@",  @"AutoJoin",  [*(id *)(a1 + 8856) UUIDString]),  0);
          sub_10004A048( *(void *)(a1 + 64),  9,  +[NSString stringWithFormat:]( NSString,  "stringWithFormat:",  @"%@/%@",  @"AutoJoin",  [*(id *)(a1 + 8856) UUIDString]),  0);
        }
      }
    }
  }

void sub_100109B20(uint64_t a1, uint64_t a2, const __CFArray *a3, uint64_t a4)
{
  uint64_t v7 = objc_autoreleasePoolPush();
  if (qword_100219F60) {
    [(id)qword_100219F60 WFLog:3, "Auto join GAS query completed (%d) with current state: %@", a4, sub_1000BDC98(*(_DWORD *)(a1 + 3272)) message];
  }
  objc_autoreleasePoolPop(v7);
  uint64_t v8 = sub_10004CA94(*(void *)(a1 + 64));
  if (v8 == *(void *)(a1 + 3304))
  {
    uint64_t v9 = *(const void **)(a1 + 3328);
    if (v9)
    {
      CFRelease(v9);
      *(void *)(a1 + 332_Block_object_dispose(va, 8) = 0LL;
    }

    if (a3) {
      MutableCFStringRef Copy = CFArrayCreateMutableCopy(kCFAllocatorDefault, 0LL, a3);
    }
    else {
      MutableCFStringRef Copy = 0LL;
    }
    *(void *)(a1 + 332_Block_object_dispose(va, 8) = MutableCopy;
    *(_DWORD *)(a1 + 3336) = a4;
    sub_1000CACC4(a1);
  }

  else
  {
    uint64_t v11 = v8;
    CFErrorDomain v12 = objc_autoreleasePoolPush();
    if (qword_100219F60) {
      [qword_100219F60 WFLog:@"Ignorning old request.  CurrentCommand=%lld PendingCommand=%lld" message:3 v11:*(void *)(a1 + 3304)];
    }
    objc_autoreleasePoolPop(v12);
  }

void sub_100109C38(uint64_t a1, const void *a2)
{
  CFIndex v4 = objc_autoreleasePoolPush();
  if (a1 && a2)
  {
    CFIndex v5 = *(const __CFArray **)(a1 + 3520);
    if (v5)
    {
      v10.length = CFArrayGetCount(*(CFArrayRef *)(a1 + 3520));
      v10.location = 0LL;
      FirstIndexOfCFBooleanRef Value = CFArrayGetFirstIndexOfValue(v5, v10, a2);
      if (FirstIndexOfValue != -1)
      {
        ValueAtIndex = CFArrayGetValueAtIndex(*(CFArrayRef *)(a1 + 3520), FirstIndexOfValue);
        if (ValueAtIndex) {
          goto LABEL_9;
        }
      }
    }

    uint64_t v8 = *(const __CFArray **)(a1 + 3528);
    if (v8)
    {
      v11.length = CFArrayGetCount(*(CFArrayRef *)(a1 + 3528));
      v11.location = 0LL;
      CFIndex v9 = CFArrayGetFirstIndexOfValue(v8, v11, a2);
      if (v9 != -1)
      {
        ValueAtIndex = CFArrayGetValueAtIndex(*(CFArrayRef *)(a1 + 3528), v9);
        if (ValueAtIndex) {
LABEL_9:
        }
          [*(id *)(a1 + 6608) setNetworkOfInterest:ValueAtIndex];
      }
    }
  }

  objc_autoreleasePoolPop(v4);
}

void sub_100109CFC(uint64_t a1, const void *a2, int a3)
{
  if (a1)
  {
    uint64_t v6 = objc_autoreleasePoolPush();
    unsigned int v7 = [*(id *)(a1 + 6632) enabled];
    objc_autoreleasePoolPop(v6);
    if (v7)
    {
      uint64_t v8 = *(__CFSet **)(a1 + 3496);
      if (a3) {
        CFSetAddValue(v8, a2);
      }
      else {
        CFSetRemoveValue(v8, a2);
      }
    }
  }

void sub_100109D88(uint64_t a1)
{
  CFNumberRef v2 = *(uint64_t **)(a1 + 48);
  if (v2[30])
  {
    unsigned int v3 = (void (*)(uint64_t *, uint64_t, void, void, void, void))v2[483];
    uint64_t v4 = sub_100043E8C(v2[8]);
    uint64_t v5 = a1 + 40;
    v3( v2,  v4,  *(void *)(*(void *)(*(void *)(a1 + 32) + 8LL) + 24LL),  *(void *)(*(void *)(*(void *)(a1 + 40) + 8LL) + 24LL),  *(unsigned int *)(a1 + 56),  *(void *)(*(void *)(a1 + 48) + 3872LL));
    CFRelease(*(CFTypeRef *)(a1 + 48));
    uint64_t v6 = *(const void **)(*(void *)(*(void *)(a1 + 32) + 8LL) + 24LL);
    if (v6)
    {
      CFRelease(v6);
      *(void *)(*(void *)(*(void *)(a1 + 32) + 8LL) + 24LL) = 0LL;
    }

    unsigned int v7 = *(const void **)(*(void *)(*(void *)v5 + 8LL) + 24LL);
    if (!v7) {
      return;
    }
LABEL_10:
    CFRelease(v7);
    *(void *)(*(void *)(*(void *)v5 + 8LL) + 24LL) = 0LL;
    return;
  }

  CFRelease(*(CFTypeRef *)(a1 + 48));
  uint64_t v8 = *(const void **)(*(void *)(*(void *)(a1 + 32) + 8LL) + 24LL);
  if (v8)
  {
    CFRelease(v8);
    *(void *)(*(void *)(*(void *)(a1 + 32) + 8LL) + 24LL) = 0LL;
  }

  uint64_t v10 = *(void *)(a1 + 40);
  uint64_t v9 = a1 + 40;
  unsigned int v7 = *(const void **)(*(void *)(v10 + 8) + 24LL);
  if (v7)
  {
    uint64_t v5 = v9;
    goto LABEL_10;
  }

void sub_100109E80(uint64_t a1, const void *a2)
{
  uint64_t v4 = objc_autoreleasePoolPush();
  if (!a1)
  {
    uint64_t v5 = objc_autoreleasePoolPush();
    if (qword_100219F60) {
      [qword_100219F60 WFLog:@"__WiFiDeviceManagerAsyncQueryLOITypeForLatestLocation: manager is null"];
    }
    goto LABEL_11;
  }

  if (!+[WiFiLOIManager sharedWiFiLOIManager](&OBJC_CLASS___WiFiLOIManager, "sharedWiFiLOIManager"))
  {
    uint64_t v5 = objc_autoreleasePoolPush();
    if (qword_100219F60) {
      [qword_100219F60 WFLog:@"%s: sharedWiFiLOIManager is nil" message:4];
    }
LABEL_11:
    objc_autoreleasePoolPop(v5);
    goto LABEL_6;
  }

  if (a2) {
    CFRetain(a2);
  }
  v6[0] = _NSConcreteStackBlock;
  v6[1] = 3221225472LL;
  v6[2] = sub_10010A21C;
  void v6[3] = &unk_1001E4F50;
  v6[5] = a1;
  v6[6] = a2;
  v6[4] = 0LL;
  [+[WiFiLOIManager sharedWiFiLOIManager](WiFiLOIManager, "sharedWiFiLOIManager") asyncQueryLOITypeAtLatestLocationWithCompletion:v6];
LABEL_6:
  objc_autoreleasePoolPop(v4);
}

void sub_100109F94(uint64_t a1, uint64_t a2)
{
  uint64_t v4 = objc_autoreleasePoolPush();
  if (sub_1000511F0(*(void *)(a1 + 64)))
  {
    uint64_t v5 = (void *)sub_1000951FC(a2, @"JOIN_STATUS_SUBSTATE_INFO");
    if (!v5)
    {
      uint64_t v24 = objc_autoreleasePoolPush();
      if (qword_100219F60) {
        [qword_100219F60 WFLog:@"%s substatesArray for join status is nil" message:@"__WiFiDeviceManagerProcessJoinStatusSubState"];
      }
      objc_autoreleasePoolPop(v24);
      if (a2) {
        goto LABEL_29;
      }
      goto LABEL_30;
    }

    uint64_t v6 = v5;
    if ([v5 count])
    {
      unint64_t v7 = 0LL;
      uint64_t v25 = a2;
      CFRange v26 = v4;
      do
      {
        id v8 = [v6 objectAtIndex:v7];
        if (v8)
        {
          uint64_t v9 = v8;
          id v10 = [v8 objectForKey:@"JOIN_STATUS_SUBSTATE_FLAGS"];
          if (v10)
          {
            if ([v10 intValue])
            {
              id v11 = [v9 objectForKey:@"BSSID"];
              if (v11)
              {
                CFErrorDomain v12 = v11;
                uint64_t v13 = [v11 bytes];
                if (*(_DWORD *)v13 || v13[2] != 0)
                {
                  uint64_t v15 = ether_ntoa((const ether_addr *)[v12 bytes]);
                  uint64_t v16 = v15
                      ? +[NSString stringWithUTF8String:](&OBJC_CLASS___NSString, "stringWithUTF8String:", v15)
                      : 0LL;
                  CFIndex v17 = sub_10010A36C(v9, (uint64_t)v16);
                  if (v17)
                  {
                    CFIndex v18 = v17;
                    if (-[NSMutableArray count](v17, "count"))
                    {
                      uint64_t v19 = sub_100094E60((uint64_t)kCFAllocatorDefault, a2);
                      sub_10009582C((uint64_t)v19, @"BSSID", v16);
                      id v20 = sub_1000A335C((uint64_t)v19);
                      if (-[NSMutableArray count](v18, "count"))
                      {
                        unint64_t v21 = 0LL;
                        do
                        {
                          id v22 = sub_1000D1BDC( a1,  8LL,  (uint64_t)-[NSMutableArray objectAtIndex:](v18, "objectAtIndex:", v21),  (uint64_t)v16,  2LL);
                          [*(id *)(a1 + 6632) setNetworkDenyListInfo:v22 forScanResult:v20];

                          ++v21;
                        }

                        while (v21 < (unint64_t)-[NSMutableArray count](v18, "count"));
                      }

                      BOOL v23 = *(void **)(a1 + 7320);
                      if (v23) {
                        [v23 addFaultEvent:9 forInterface:sub_100043E8C(*(void *)(a1 + 64))];
                      }
                      uint64_t v4 = v26;
                      if (v19) {
                        CFRelease(v19);
                      }

                      a2 = v25;
                    }
                  }
                }
              }
            }
          }
        }

        ++v7;
      }

      while (v7 < (unint64_t)[v6 count]);
    }
  }

  if (a2) {
LABEL_29:
  }
    sub_10009582C(a2, @"JOIN_STATUS_SUBSTATE_INFO", 0LL);
LABEL_30:
  objc_autoreleasePoolPop(v4);
}

void sub_10010A21C(void *a1, int a2)
{
  uint64_t v3 = a1[5];
  uint64_t v4 = *(dispatch_queue_s **)(v3 + 240);
  if (v4)
  {
    v7[0] = _NSConcreteStackBlock;
    v7[1] = 3221225472LL;
    v7[2] = sub_10010A2A0;
    v7[3] = &unk_1001E4F28;
    uint64_t v5 = a1[6];
    int v8 = a2;
    void v7[5] = v5;
    void v7[6] = v3;
    v7[4] = a1[4];
    dispatch_sync(v4, v7);
  }

  else
  {
    uint64_t v6 = (const void *)a1[6];
    if (v6) {
      CFRelease(v6);
    }
  }

uint64_t sub_10010A2A0(uint64_t a1)
{
  CFNumberRef v2 = objc_autoreleasePoolPush();
  uint64_t v3 = (void *)qword_100219F60;
  if (qword_100219F60)
  {
    uint64_t v4 = sub_100095BC8(*(const void **)(a1 + 40));
    [v3 WFLog:3, "%s: LOI Type for '%@' = %@(%d)", "__WiFiDeviceManagerAsyncQueryLOITypeForLatestLocation_block_invoke_2", v4, sub_10003B3B0(*(_DWORD *)(a1 + 56)), *(unsigned int *)(a1 + 56) message];
  }

  objc_autoreleasePoolPop(v2);
  uint64_t v5 = *(const void **)(a1 + 40);
  *(_DWORD *)(*(void *)(a1 + 48) + 6648LL) = *(_DWORD *)(a1 + 56);
  if (v5)
  {
    unsigned int v6 = *(_DWORD *)(a1 + 56);
    if (v6)
    {
      sub_10009FEB4(v5, v6);
      uint64_t v5 = *(const void **)(a1 + 40);
    }

    CFRelease(v5);
  }

  uint64_t result = *(void *)(a1 + 32);
  if (result) {
    return (*(uint64_t (**)(void))(result + 16))();
  }
  return result;
}

NSMutableArray *sub_10010A36C(void *a1, uint64_t a2)
{
  uint64_t v4 = objc_autoreleasePoolPush();
  if (!a1)
  {
    id v22 = objc_autoreleasePoolPush();
    if (qword_100219F60) {
      [qword_100219F60 WFLog:@"dict is nil" message:4];
    }
    goto LABEL_51;
  }

  if (!a2)
  {
    id v22 = objc_autoreleasePoolPush();
    if (qword_100219F60) {
      [qword_100219F60 WFLog:@"%s bssid is nil" message:4];
    }
LABEL_51:
    objc_autoreleasePoolPop(v22);
    CFErrorDomain v12 = 0LL;
    goto LABEL_46;
  }

  id v5 = [a1 objectForKey:@"AUTHEVENT_STATUS"];
  id v6 = [a1 objectForKey:@"AUTHEVENT_REASON"];
  id v7 = [a1 objectForKey:@"ASSOCEVENT_STATUS"];
  id v8 = [a1 objectForKey:@"ASSOCEVENT_REASON"];
  id v23 = [a1 objectForKey:@"SETSSID_STATUS"];
  id v24 = [a1 objectForKey:@"SETSSID_REASON"];
  id v9 = [a1 objectForKey:@"SUPPLICANTEVENT_STATUS"];
  id v10 = [a1 objectForKey:@"SUPPLICANTEVENT_REASON"];
  id v11 = [a1 objectForKey:@"REASSOCEVENT_STATUS"];
  id v25 = [a1 objectForKey:@"REASSOCEVENT_REASON"];
  CFErrorDomain v12 = 0LL;
  if (v5 && v6)
  {
    if (sub_10010A958((int)[v5 intValue], (int)objc_msgSend(v6, "intValue")))
    {
      uint64_t v13 = objc_autoreleasePoolPush();
      if (qword_100219F60) {
        [(id)qword_100219F60 WFLog:4, "%s Auth Status/Reason for %@ BssBlacklist Eligible - Status:%d ieeeStatus:%d", "__CopyReasonsFromSubStatesForBssBlacklist", a2, (unint64_t)objc_msgSend(v5, "intValue") & 0x1FF, (unint64_t)objc_msgSend(v6, "intValue") & 0x1FF message];
      }
      objc_autoreleasePoolPop(v13);
      CFErrorDomain v12 = objc_alloc_init(&OBJC_CLASS___NSMutableArray);
      -[NSMutableArray addObject:]( v12,  "addObject:",  +[NSNumber numberWithInt:](NSNumber, "numberWithInt:", [v6 intValue]));
    }

    else
    {
      CFErrorDomain v12 = 0LL;
    }
  }

  if (v7 && v8 && sub_10010A958((int)[v7 intValue], (int)objc_msgSend(v8, "intValue")))
  {
    NSErrorUserInfoKey v14 = objc_autoreleasePoolPush();
    if (qword_100219F60) {
      [(id)qword_100219F60 WFLog:4, "%s Assoc Status/Reason for %@ BssBlacklist Eligible - Status:%d ieeeStatus:%d", "__CopyReasonsFromSubStatesForBssBlacklist", a2, (unint64_t)objc_msgSend(v7, "intValue") & 0x1FF, (unint64_t)objc_msgSend(v8, "intValue") & 0x1FF message];
    }
    objc_autoreleasePoolPop(v14);
    if (!v12) {
      CFErrorDomain v12 = objc_alloc_init(&OBJC_CLASS___NSMutableArray);
    }
    -[NSMutableArray addObject:]( v12,  "addObject:",  +[NSNumber numberWithInt:](NSNumber, "numberWithInt:", [v8 intValue]));
  }

  if (v11 && v25 && sub_10010A958((int)[v11 intValue], (int)objc_msgSend(v25, "intValue")))
  {
    uint64_t v15 = objc_autoreleasePoolPush();
    if (qword_100219F60) {
      [(id)qword_100219F60 WFLog:4, "%s Reassoc Status/Reason for %@ BssBlacklist Eligible - Status:%d ieeeStatus:%d", "__CopyReasonsFromSubStatesForBssBlacklist", a2, (unint64_t)objc_msgSend(v11, "intValue") & 0x1FF, (unint64_t)objc_msgSend(v25, "intValue") & 0x1FF message];
    }
    objc_autoreleasePoolPop(v15);
    uint64_t v16 = v24;
    if (!v12) {
      CFErrorDomain v12 = objc_alloc_init(&OBJC_CLASS___NSMutableArray);
    }
    -[NSMutableArray addObject:]( v12,  "addObject:",  +[NSNumber numberWithInt:](NSNumber, "numberWithInt:", [v25 intValue]));
    if (!v23) {
      goto LABEL_35;
    }
    goto LABEL_28;
  }

  uint64_t v16 = v24;
  if (v23)
  {
LABEL_28:
    if (v16 && sub_10010A958((int)[v23 intValue], (int)objc_msgSend(v16, "intValue")))
    {
      CFIndex v17 = objc_autoreleasePoolPush();
      if (qword_100219F60) {
        [(id)qword_100219F60 WFLog:4, "%s SetSsid Status/Reason for %@ BssBlacklist Eligible - Status:%d ieeeStatus:%d", "__CopyReasonsFromSubStatesForBssBlacklist", a2, (unint64_t)objc_msgSend(v23, "intValue") & 0x1FF, (unint64_t)objc_msgSend(v16, "intValue") & 0x1FF message];
      }
      objc_autoreleasePoolPop(v17);
      if (!v12) {
        CFErrorDomain v12 = objc_alloc_init(&OBJC_CLASS___NSMutableArray);
      }
      -[NSMutableArray addObject:]( v12,  "addObject:",  +[NSNumber numberWithInt:](NSNumber, "numberWithInt:", [v16 intValue]));
    }
  }

uint64_t sub_10010A958(int a1, int a2)
{
  uint64_t result = 1LL;
  if (((a2 + 528347119) > 0x14 || ((1 << (a2 - 17)) & 0x172001) == 0)
    && ((a2 + 528347054) > 0x11 || ((1 << (a2 - 82)) & 0x20C03) == 0))
  {
    return 0LL;
  }

  return result;
}

void sub_10010A9F0(uint64_t a1)
{
  uint64_t v2 = *(void *)(a1 + 40);
  if (*(void *)(v2 + 240))
  {
    uint64_t v4 = *(void *)(a1 + 32);
    uint64_t v3 = (CFTypeRef *)(a1 + 32);
    (*(void (**)(uint64_t, void, const __CFString *, const CFBooleanRef, void))(v2 + 4736))( v2,  *(void *)(*(void *)(v4 + 8) + 24LL),  @"FailureCountCurrent",  kCFBooleanTrue,  *(void *)(v2 + 4744));
    CFRelease(v3[1]);
    id v5 = *v3;
  }

  else
  {
    CFRelease((CFTypeRef)v2);
    id v6 = *(void **)(a1 + 32);
    uint64_t v3 = (CFTypeRef *)(a1 + 32);
    id v5 = v6;
  }

  id v7 = *(const void **)(v5[1] + 24LL);
  if (v7)
  {
    CFRelease(v7);
    *(void *)(*((void *)*v3 + 1) + 24LL) = 0LL;
  }

void sub_10010AA78(uint64_t a1, void *a2)
{
  if (a2)
  {
    [*(id *)(*(void *)(a1 + 32) + 7320) setJoinEvent:0 withReason:1 lastDisconnectReason:0 lastJoinFailure:*(int *)(a1 + 40) andNetworkDetails:a2 forInterface:sub_100043E8C(*(void *)(*(void *)(a1 + 32) + 64))];
  }

uint64_t sub_10010AADC(uint64_t a1, uint64_t a2)
{
  uint64_t v4 = objc_autoreleasePoolPush();
  uint64_t v5 = *(unsigned int *)(a1 + 3272);
  uint64_t v6 = sub_1000ABA8C(a2);
  uint64_t v7 = sub_100091DAC(a2);
  if (v7)
  {
    id v8 = (void *)v7;
    id v9 = objc_autoreleasePoolPush();
    if (qword_100219F60) {
      [(id)qword_100219F60 WFLog:3, "%s: responseType=%d ssid=%@", "__WiFiDeviceManagerProcessPasswordNotification", v6, sub_100095BC8(v8) message];
    }
    objc_autoreleasePoolPop(v9);
    switch((int)v6)
    {
      case 1:
        id v10 = sub_1000ABD30(a2, kCFUserNotificationTextFieldValuesKey);
        if (!v10) {
          break;
        }
        id v11 = v10;
        CFTypeID TypeID = CFArrayGetTypeID();
        if (TypeID == CFGetTypeID(v11))
        {
          if (CFArrayGetCount(v11) <= 1)
          {
            if (CFArrayGetCount(v11) < 1) {
              goto LABEL_24;
            }
            NSErrorUserInfoKey v14 = v11;
            CFIndex v15 = 0LL;
          }

          else
          {
            ValueAtIndex = CFArrayGetValueAtIndex(v11, 0LL);
            sub_10009582C((uint64_t)v8, @"UserName", ValueAtIndex);
            NSErrorUserInfoKey v14 = v11;
            CFIndex v15 = 1LL;
          }

          id v24 = (const __CFString *)CFArrayGetValueAtIndex(v14, v15);
          id v23 = v8;
        }

        else
        {
          CFTypeID v22 = CFStringGetTypeID();
          if (v22 != CFGetTypeID(v11)) {
            goto LABEL_24;
          }
          id v23 = v8;
          id v24 = (const __CFString *)v11;
        }

        sub_100099C50(v23, v24);
LABEL_24:
        id v25 = sub_1000EC354(a1, v8, 1);
        if ((_DWORD)v25)
        {
          uint64_t v19 = sub_100101580(a1, v8, 0LL, (uint64_t)v25);
          goto LABEL_13;
        }

        break;
      case 2:
        sub_100109CFC(a1, v8, 1);
        id v16 = sub_1000A335C((uint64_t)v8);
        CFIndex v17 = sub_1000951FC((uint64_t)v8, @"BSSID");
        id v18 = sub_1000D1BDC(a1, 0LL, 0LL, (uint64_t)v17, 3LL);
        [*(id *)(a1 + 6632) setNetworkDenyListInfo:v18 forScanResult:v16];

        goto LABEL_10;
      case 3:
LABEL_10:
        uint64_t v19 = sub_10010824C(a1);
LABEL_13:
        uint64_t v5 = v19;
        break;
      case 4:
        id v20 = objc_autoreleasePoolPush();
        if (qword_100219F60) {
          [qword_100219F60 WFLog:@"__WiFiDeviceManagerProcessPasswordNotification: opening settings to collect credentials"];
        }
        objc_autoreleasePoolPop(v20);
        sub_10010B64C(0LL, (CFDictionaryRef *)v8);
        uint64_t v5 = 14LL;
        break;
      default:
        break;
    }
  }

  objc_autoreleasePoolPop(v4);
  return v5;
}

uint64_t sub_10010AD94(uint64_t a1, uint64_t a2)
{
  uint64_t v4 = objc_autoreleasePoolPush();
  uint64_t v5 = *(unsigned int *)(a1 + 3272);
  unsigned int v6 = sub_1000ABA8C(a2);
  uint64_t v7 = (const void *)sub_100091DAC(a2);
  id v8 = objc_autoreleasePoolPush();
  if (v7)
  {
    if (qword_100219F60) {
      [(id)qword_100219F60 WFLog:3, "%s: ResponseType=%@", "__WiFiDeviceManagerProcessEAPTrustNotification", sub_1000ABE6C(v6) message];
    }
    objc_autoreleasePoolPop(v8);
    switch(v6)
    {
      case 1u:
      case 4u:
        id v9 = (const __CFDictionary *)sub_10004CE2C(a2);
        if (v9)
        {
          CFBooleanRef Value = CFDictionaryGetValue(v9, @"TLSServerCertificateChain");
          if (Value)
          {
            id v11 = Value;
            CFErrorDomain v12 = sub_100012CEC((uint64_t)v7);
            MutableCFStringRef Copy = CFDictionaryCreateMutableCopy(kCFAllocatorDefault, 0LL, v12);
            if (v12) {
              CFRelease(v12);
            }
            NSErrorUserInfoKey v14 = (const __CFDictionary *)CFDictionaryGetValue(MutableCopy, @"EnterpriseProfile");
            if (v14)
            {
              CFIndex v15 = CFDictionaryCreateMutableCopy(kCFAllocatorDefault, 0LL, v14);
              if (v15)
              {
                id v16 = v15;
                CFIndex v17 = (const __CFDictionary *)CFDictionaryGetValue(v15, @"EAPClientConfiguration");
                if (v17)
                {
                  id v18 = CFDictionaryCreateMutableCopy(kCFAllocatorDefault, 0LL, v17);
                  if (v18)
                  {
                    uint64_t v19 = v18;
                    CFDictionarySetValue(v18, @"TLSSaveTrustExceptions", kCFBooleanTrue);
                    CFDictionarySetValue(v19, @"TLSUserTrustProceedCertificateChain", v11);
                    CFDictionarySetValue(v16, @"EAPClientConfiguration", v19);
                    CFRelease(v19);
                    CFDictionarySetValue(MutableCopy, @"EnterpriseProfile", v16);
                    CFRelease(v16);
                    id v20 = (CFDictionaryRef *)sub_100094AAC((uint64_t)kCFAllocatorDefault, MutableCopy);
                    if (v20)
                    {
                      unint64_t v21 = v20;
                      if (v6 == 4)
                      {
                        sub_10010B64C(1LL, v20);
                        CFRelease(v21);
                        id v16 = 0LL;
                        uint64_t v5 = 14LL;
                        if (!MutableCopy) {
                          goto LABEL_31;
                        }
LABEL_30:
                        CFRelease(MutableCopy);
                        goto LABEL_31;
                      }

                      id v25 = objc_autoreleasePoolPush();
                      if (qword_100219F60) {
                        [(id)qword_100219F60 WFLog:3, "%s: proceeding with joining %@", "__WiFiDeviceManagerProcessEAPTrustNotification", v21 message];
                      }
                      objc_autoreleasePoolPop(v25);
                      *(void *)(a1 + 1120) = 0LL;
                      CFRange v26 = sub_1000EC354(a1, v21, 1);
                      if (!(_DWORD)v26)
                      {
                        sub_10010D14C(a1, @"autoJoinAssociating", v21, 0LL);
                        id v16 = 0LL;
                        uint64_t v5 = 12LL;
                        if (!MutableCopy) {
                          goto LABEL_31;
                        }
                        goto LABEL_30;
                      }

                      uint64_t v5 = sub_100101580(a1, v21, 0LL, (uint64_t)v26);
                    }

                    else
                    {
                      BOOL v32 = objc_autoreleasePoolPush();
                      if (qword_100219F60) {
                        [qword_100219F60 WFLog:@"__WiFiDeviceManagerProcessEAPTrustNotification: failed to create network"];
                      }
                      objc_autoreleasePoolPop(v32);
                    }

                    id v16 = 0LL;
                    if (MutableCopy) {
                      goto LABEL_30;
                    }
LABEL_31:
                    if (v16) {
                      CFRelease(v16);
                    }
                    goto LABEL_33;
                  }

                  CFIndex v31 = objc_autoreleasePoolPush();
                  if (qword_100219F60) {
                    [qword_100219F60 WFLog:@"%s: failed to make mutable copy of eap client config" message:4];
                  }
                }

                else
                {
                  CFIndex v31 = objc_autoreleasePoolPush();
                  if (qword_100219F60) {
                    [(id)qword_100219F60 WFLog:4, "%s: eap client config is null for network %@", "__WiFiDeviceManagerProcessEAPTrustNotification", sub_100095BC8(v7) message];
                  }
                }

                objc_autoreleasePoolPop(v31);
LABEL_53:
                if (MutableCopy) {
                  goto LABEL_30;
                }
                goto LABEL_31;
              }

              BOOL v30 = objc_autoreleasePoolPush();
              if (qword_100219F60) {
                [qword_100219F60 WFLog:@"%s: failed to make mutable copy of eap profile" message:4];
              }
            }

            else
            {
              BOOL v30 = objc_autoreleasePoolPush();
              if (qword_100219F60) {
                [(id)qword_100219F60 WFLog:4, "%s: eap profile is null for network %@", "__WiFiDeviceManagerProcessEAPTrustNotification", sub_100095BC8(v7) message];
              }
            }

            objc_autoreleasePoolPop(v30);
            id v16 = 0LL;
            goto LABEL_53;
          }

          uint64_t v29 = objc_autoreleasePoolPush();
          if (qword_100219F60) {
            [(id)qword_100219F60 WFLog:4, "%s: certificateChain is null for network %@", "__WiFiDeviceManagerProcessEAPTrustNotification", sub_100095BC8(v7) message];
          }
        }

        else
        {
          uint64_t v29 = objc_autoreleasePoolPush();
          if (qword_100219F60) {
            [(id)qword_100219F60 WFLog:4, "%s: notification for %@ is missing additional information", "__WiFiDeviceManagerProcessEAPTrustNotification", sub_100095BC8(v7) message];
          }
        }

        unsigned int v28 = v29;
        goto LABEL_42;
      case 2u:
        sub_100109CFC(a1, v7, 1);
        id v22 = sub_1000A335C((uint64_t)v7);
        id v23 = sub_1000951FC((uint64_t)v7, @"BSSID");
        id v24 = sub_1000D1BDC(a1, 0LL, 0LL, (uint64_t)v23, 3LL);
        [*(id *)(a1 + 6632) setNetworkDenyListInfo:v24 forScanResult:v22];

        goto LABEL_18;
      case 3u:
LABEL_18:
        uint64_t v5 = sub_10010824C(a1);
        goto LABEL_33;
      default:
        goto LABEL_33;
    }
  }

  if (qword_100219F60) {
    [qword_100219F60 WFLog:@"%s: network is null" message:4];
  }
  unsigned int v28 = v8;
LABEL_42:
  objc_autoreleasePoolPop(v28);
LABEL_33:
  objc_autoreleasePoolPop(v4);
  return v5;
}

CFArrayRef sub_10010B300(uint64_t a1, uint64_t a2)
{
  int v4 = *(_DWORD *)(a1 + 3272);
  int v5 = sub_1000ABA8C(a2);
  if (v5 == 4)
  {
    sub_10010B64C(0LL, 0LL);
  }

  else if (v5 == 1)
  {
    unsigned int v6 = (const void *)sub_100091DAC(a2);
    if (*(void *)(a1 + 3864))
    {
      if (*(void *)(a1 + 240))
      {
        uint64_t v12 = 0LL;
        uint64_t v13 = &v12;
        uint64_t v14 = 0x2020000000LL;
        uint64_t v15 = 0LL;
        if (v6)
        {
          CFTypeRef v7 = CFRetain(v6);
          void v13[3] = (uint64_t)v7;
        }

        CFRetain((CFTypeRef)a1);
        id v8 = *(dispatch_queue_s **)(a1 + 240);
        block[0] = _NSConcreteStackBlock;
        block[1] = 3221225472LL;
        block[2] = sub_10010B918;
        block[3] = &unk_1001E2D48;
        void block[4] = &v12;
        void block[5] = a1;
        dispatch_async(v8, block);
        _Block_object_dispose(&v12, 8);
      }

      else
      {
        id v10 = objc_autoreleasePoolPush();
        if (qword_100219F60) {
          [qword_100219F60 WFLog:@"__WiFiDeviceManagerProcessAskToJoinNotification: null queue."];
        }
        objc_autoreleasePoolPop(v10);
      }
    }

    return 0LL;
  }

  if (v4) {
    return sub_1000F17B8(a1);
  }
  return 0LL;
}

void sub_10010B44C( _Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, ...)
{
}

uint64_t sub_10010B464(uint64_t a1, int a2)
{
  uint64_t v4 = *(unsigned int *)(a1 + 3272);
  id v5 = [*(id *)(a1 + 6728) getHotspotDeviceName:*(void *)(a1 + 6856)];
  switch(a2)
  {
    case 3:
      CFTypeRef v7 = objc_autoreleasePoolPush();
      if (qword_100219F60) {
        [qword_100219F60 WFLog:@"%s: User response System timeout" message:3];
      }
      objc_autoreleasePoolPop(v7);
      sub_1000CABEC(a1, 0);
      uint64_t v4 = *(unsigned int *)(a1 + 6844);
      sub_10010B9B4((uint64_t *)a1, @"userJoinAborted", 0LL);
      id v8 = (const __CFString *)NSPOSIXErrorDomain;
      id v9 = @"System canceled hotspot notification";
LABEL_15:
      sub_10010BB38(a1, (uint64_t)v5, 89LL, v8, (uint64_t)v9);
      return v4;
    case 2:
      if (*(void *)(a1 + 6856))
      {
        id v10 = objc_autoreleasePoolPush();
        if (qword_100219F60) {
          [(id)qword_100219F60 WFLog:3, "%s: Adding %@:[%@] to User Suppressed List until next link state change", "__WiFiDeviceManagerProcessAskToJoinHotspotNotification", v5, *(void *)(a1 + 6856) message];
        }
        objc_autoreleasePoolPop(v10);
        CFArrayAppendValue(*(CFMutableArrayRef *)(a1 + 6864), *(const void **)(a1 + 6856));
      }

      *(void *)(a1 + 6856) = 0LL;
      *(void *)(a1 + 6824) = 0LL;
      sub_1000CABEC(a1, 0);
      uint64_t v4 = *(unsigned int *)(a1 + 6844);
      *(_DWORD *)(a1 + 644_Block_object_dispose(va, 8) = -3909;
      sub_1000325B0((unsigned int *)(a1 + 6448));
      sub_10010B9B4((uint64_t *)a1, @"userJoinAborted", 0LL);
      id v8 = (const __CFString *)NSPOSIXErrorDomain;
      id v9 = @"User canceled hotspot notification";
      goto LABEL_15;
    case 1:
      return sub_1001034F4(a1, *(void *)(a1 + 6856));
  }

  return v4;
}

void sub_10010B64C(uint64_t a1, CFDictionaryRef *a2)
{
  if (a1 > 2 || !*off_1001E57C8[(int)a1])
  {
    id v11 = objc_autoreleasePoolPush();
    if (qword_100219F60) {
      [qword_100219F60 WFLog:@"__WiFiDeviceManagerOpenSettings: failed to create urlPathString for type %d" message:4];
    }
    goto LABEL_17;
  }

  uint64_t v4 = CFStringCreateWithFormat(kCFAllocatorDefault, 0LL, @"prefs:root=WIFI&path=%@", *off_1001E57C8[(int)a1]);
  if (!v4)
  {
    id v11 = objc_autoreleasePoolPush();
    if (qword_100219F60) {
      [qword_100219F60 WFLog:@"__WiFiDeviceManagerOpenSettings: failed to create urlString for type %d" message:4];
    }
LABEL_17:
    objc_autoreleasePoolPop(v11);
    return;
  }

  id v5 = v4;
  CFURLRef v6 = CFURLCreateWithString(kCFAllocatorDefault, v4, 0LL);
  CFTypeRef v7 = objc_autoreleasePoolPush();
  if (!v6)
  {
    if (qword_100219F60) {
      [qword_100219F60 WFLog:@"__WiFiDeviceManagerOpenSettings: failed to create url for type %d" message:4 "%s: failed to create url for type %d" "__WiFiDeviceManagerOpenSettings" a1];
    }
    objc_autoreleasePoolPop(v7);
    id v10 = (__CFString *)v5;
    goto LABEL_14;
  }

  if (qword_100219F60) {
    [(id)qword_100219F60 WFLog:3, "%s: launching settings with url %@", "__WiFiDeviceManagerOpenSettings", v6 message];
  }
  objc_autoreleasePoolPop(v7);
  if (!a2)
  {
    uint64_t v12 = objc_autoreleasePoolPush();
    if (qword_100219F60) {
      [qword_100219F60 WFLog:@"skip persisting network to disk"];
    }
    objc_autoreleasePoolPop(v12);
    id v8 = 0LL;
    goto LABEL_11;
  }

  id v8 = (__CFString *)CFStringCreateWithFormat( kCFAllocatorDefault,  0LL,  @"%@/%@",  @"/var/mobile/Library/Caches/com.apple.wifi/",  @"LastEnterpriseNetwork.plist");
  id v9 = objc_autoreleasePoolPush();
  if (qword_100219F60) {
    [(id)qword_100219F60 WFLog:3, "%s: archiving network to path %@", "__WiFiDeviceManagerOpenSettings", v8 message];
  }
  objc_autoreleasePoolPop(v9);
  if (sub_10009F564(a2, v8))
  {
LABEL_11:
    [+[LSApplicationWorkspace defaultWorkspace](LSApplicationWorkspace, "defaultWorkspace") openSensitiveURL:v6 withOptions:0];
    goto LABEL_12;
  }

  uint64_t v13 = objc_autoreleasePoolPush();
  if (qword_100219F60) {
    [(id)qword_100219F60 WFLog:4, "%s: failed to archive network to path %@", "__WiFiDeviceManagerOpenSettings", v8 message];
  }
  objc_autoreleasePoolPop(v13);
LABEL_12:
  CFRelease(v5);
  CFRelease(v6);
  if (v8)
  {
    id v10 = v8;
LABEL_14:
    CFRelease(v10);
  }

void sub_10010B918(uint64_t a1)
{
  uint64_t v2 = *(uint64_t **)(a1 + 40);
  if (v2[30])
  {
    uint64_t v3 = (void (*)(uint64_t *, uint64_t, void, void, void, void))v2[483];
    uint64_t v4 = sub_100043E8C(v2[8]);
    uint64_t v6 = *(void *)(a1 + 32);
    id v5 = (CFTypeRef *)(a1 + 32);
    v3(v2, v4, *(void *)(*(void *)(v6 + 8) + 24LL), 0LL, 0LL, *((void *)v5[1] + 484));
    CFRelease(v5[1]);
    CFTypeRef v7 = *v5;
  }

  else
  {
    CFRelease(*(CFTypeRef *)(a1 + 40));
    id v8 = *(void **)(a1 + 32);
    id v5 = (CFTypeRef *)(a1 + 32);
    CFTypeRef v7 = v8;
  }

  id v9 = *(const void **)(v7[1] + 24LL);
  if (v9)
  {
    CFRelease(v9);
    *(void *)(*((void *)*v5 + 1) + 24LL) = 0LL;
  }

void sub_10010B9B4(uint64_t *a1, const void *a2, const void *a3)
{
  if (!a1)
  {
    id v10 = objc_autoreleasePoolPush();
    if (qword_100219F60) {
      [qword_100219F60 WFLog:@"%s: null manager." message:3];
    }
    goto LABEL_15;
  }

  if (!a2)
  {
    id v10 = objc_autoreleasePoolPush();
    if (qword_100219F60) {
      [qword_100219F60 WFLog:@"__WiFiDeviceManagerPostUserJoinNotification: null status."];
    }
    goto LABEL_15;
  }

  if (!a1[510]) {
    return;
  }
  CFMutableStringRef Mutable = CFDictionaryCreateMutable( kCFAllocatorDefault,  0LL,  &kCFTypeDictionaryKeyCallBacks,  &kCFTypeDictionaryValueCallBacks);
  if (!Mutable)
  {
    id v10 = objc_autoreleasePoolPush();
    if (qword_100219F60) {
      [qword_100219F60 WFLog:@"%s: null detailedState." message:3];
    }
LABEL_15:
    objc_autoreleasePoolPop(v10);
    return;
  }

  CFTypeRef v7 = Mutable;
  CFDictionarySetValue(Mutable, @"userJoinStatus", a2);
  if (a3) {
    CFDictionarySetValue(v7, @"userJoinNetwork", a3);
  }
  id v8 = (void (*)(uint64_t *, uint64_t, uint64_t, __CFDictionary *))a1[510];
  uint64_t v9 = sub_100043E8C(a1[8]);
  v8(a1, v9, a1[511], v7);
  CFRelease(v7);
}

void sub_10010BB38(uint64_t a1, uint64_t a2, uint64_t a3, CFErrorDomain a4, uint64_t a5)
{
  id v10 = objc_autoreleasePoolPush();
  if (!a4) {
    a4 = kCFErrorDomainPOSIX;
  }
  if (a5)
  {
    NSErrorUserInfoKey v14 = NSLocalizedDescriptionKey;
    uint64_t v15 = a5;
    id v11 = +[NSDictionary dictionaryWithObjects:forKeys:count:]( &OBJC_CLASS___NSDictionary,  "dictionaryWithObjects:forKeys:count:",  &v15,  &v14,  1LL);
    CFErrorDomain v12 = a4;
    uint64_t v13 = a3;
  }

  else
  {
    CFErrorDomain v12 = a4;
    uint64_t v13 = a3;
    id v11 = 0LL;
  }

  +[NSError errorWithDomain:code:userInfo:](&OBJC_CLASS___NSError, "errorWithDomain:code:userInfo:", v12, v13, v11);
  sub_10010BC40(a1, a2);
  objc_autoreleasePoolPop(v10);
}

void sub_10010BC40(uint64_t a1, uint64_t a2)
{
  uint64_t v4 = objc_autoreleasePoolPush();
  if (a1)
  {
    if (a2)
    {
      if (*(void *)(a1 + 8808))
      {
        uint64_t v5 = *(void *)(a1 + 8800);
        if (v5)
        {
          if ([*(id *)(a1 + 6728) isEqualHotspotDevicesName:v5 compareTo:a2])
          {
            (*(void (**)(void))(*(void *)(a1 + 8808) + 16LL))();
            _Block_release(*(const void **)(a1 + 8808));
            *(void *)(a1 + 880_Block_object_dispose(va, 8) = 0LL;
            CFRelease(*(CFTypeRef *)(a1 + 8800));
            *(void *)(a1 + 8800) = 0LL;
          }
        }
      }
    }
  }

  objc_autoreleasePoolPop(v4);
}

void sub_10010BCC8(uint64_t a1)
{
  uint64_t v2 = *(void **)(a1 + 40);
  if (v2[30])
  {
    uint64_t v3 = objc_autoreleasePoolPush();
    if (qword_100219F60) {
      [(id)qword_100219F60 WFLog:4, "%s: Adding network '%@' to known network list", "__WiFiDeviceManagerProcessAutoHotspotJoinRecommendationNotification_block_invoke", sub_100095BC8(*(const void **)(*(void *)(*(void *)(a1 + 32) + 8) + 24)) message];
    }
    objc_autoreleasePoolPop(v3);
    uint64_t v5 = *(void *)(a1 + 32);
    uint64_t v4 = *(void *)(a1 + 40);
    uint64_t v6 = (CFTypeRef *)(a1 + 32);
    (*(void (**)(uint64_t, void, void))(v4 + 4576))( v4,  *(void *)(*(void *)(v5 + 8) + 24LL),  *(void *)(v4 + 4584));
    CFRelease(v6[1]);
    CFTypeRef v7 = *v6;
  }

  else
  {
    CFRelease(v2);
    id v8 = *(void **)(a1 + 32);
    uint64_t v6 = (CFTypeRef *)(a1 + 32);
    CFTypeRef v7 = v8;
  }

  uint64_t v9 = *(const void **)(v7[1] + 24LL);
  if (v9)
  {
    CFRelease(v9);
    *(void *)(*((void *)*v6 + 1) + 24LL) = 0LL;
  }

void sub_10010BD9C(void *a1)
{
  *(void *)(*(void *)(a1[4] + 8) + 4kdebug_trace(731381764, 0, 0, 0, 0) = [*(id *)(a1[7] + 6728) newHotspot:*(void *)(*(void *)(a1[5] + 8) + 40) error:*(void *)(a1[6] + 8) + 40];
  uint64_t v2 = (void *)a1[7];
  v2[868] = *(void *)(*(void *)(a1[6] + 8LL) + 40LL);
  v2[869] = *(void *)(*(void *)(a1[4] + 8LL) + 40LL);
  uint64_t v3 = (dispatch_queue_s *)v2[30];
  block[0] = _NSConcreteStackBlock;
  block[1] = 3221225472LL;
  block[2] = sub_10010BE54;
  block[3] = &unk_1001E2620;
  void block[4] = v2;
  dispatch_sync(v3, block);
}

CFAbsoluteTime sub_10010BE54(uint64_t a1)
{
  uint64_t v2 = *(void *)(a1 + 32);
  *(_BYTE *)(v2 + 6960) = 0;
  if (*(_DWORD *)(v2 + 3272) == 19)
  {
    sub_1000CACC4(v2);
  }

  else
  {
    uint64_t v4 = objc_autoreleasePoolPush();
    if (qword_100219F60) {
      [qword_100219F60 WFLog:@"__WiFiDeviceManagerEnableRemoteHotspotDevice_block_invoke_2 Received Enabled Hotspot Devices in state %d" message:3 "%s: Received Enabled Hotspot Devices in state %d" 3 *(unsigned int *)(*(void *)(a1 + 32) + 3272)];
    }
    objc_autoreleasePoolPop(v4);
    return sub_1000CABEC(*(void *)(a1 + 32), 0);
  }

  return result;
}

void sub_10010BEEC(uint64_t a1, const __CFString *a2, unsigned int a3)
{
  *(_DWORD *)(a1 + 6924) = a3;
  uint64_t v6 = *(const void **)(a1 + 6808);
  if (v6)
  {
    CFRelease(v6);
    *(void *)(a1 + 680_Block_object_dispose(va, 8) = 0LL;
  }

  CFTypeRef v7 = objc_autoreleasePoolPush();
  if (qword_100219F60) {
    objc_msgSend( (id)qword_100219F60,  "WFLog:message:",  3,  "Dispatch Notification: Auto Hotspot Failure %d",  *(unsigned int *)(a1 + 6924));
  }
  objc_autoreleasePoolPop(v7);
  if (!*(_BYTE *)(a1 + 6920) && *(_DWORD *)(a1 + 6756) == 1)
  {
    id v8 = sub_100094CE8(a2);
    if (v8)
    {
      uint64_t v9 = v8;
      uint64_t v10 = sub_100043E8C(*(void *)(a1 + 64));
      sub_1000EF770(a1, v10, 11LL, 0LL, v9, 0LL);
      CFRelease(v9);
      sub_10010B9B4((uint64_t *)a1, @"userJoinAssociationFailed", 0LL);
    }
  }

uint64_t sub_10010C020(uint64_t a1, const __CFArray *a2, int a3)
{
  int valuePtr = 0;
  if (a1)
  {
    if (a3)
    {
      uint64_t v5 = sub_1000ED0D0(a2, 0LL, *(_DWORD *)(a1 + 128), 0x6Eu, 1);
      CFDictionaryRef v6 = 0LL;
      CFNumberRef v7 = 0LL;
      CFMutableArrayRef Mutable = 0LL;
      if (!v5)
      {
LABEL_24:
        uint64_t v19 = objc_autoreleasePoolPush();
        if (qword_100219F60) {
          [qword_100219F60 WFLog:@"__WiFiDeviceManagerAutoInstantHotspotJoin: failed to create scan request"];
        }
        objc_autoreleasePoolPop(v19);
        uint64_t v10 = 0LL;
        if (!v7) {
          goto LABEL_19;
        }
        goto LABEL_18;
      }
    }

    else
    {
      int valuePtr = 130;
      CFNumberRef v11 = CFNumberCreate(kCFAllocatorDefault, kCFNumberIntType, &valuePtr);
      if (!v11) {
        return 0LL;
      }
      CFNumberRef v7 = v11;
      CFMutableArrayRef Mutable = CFArrayCreateMutable(kCFAllocatorDefault, 0LL, &kCFTypeArrayCallBacks);
      if (!Mutable)
      {
        CFDictionaryRef v6 = 0LL;
        uint64_t v10 = 0LL;
LABEL_18:
        CFRelease(v7);
LABEL_19:
        if (v6) {
          CFRelease(v6);
        }
        if (Mutable) {
          CFRelease(Mutable);
        }
        return v10;
      }

      CFErrorDomain v12 = (void *)sub_1000951FC((uint64_t)a2, @"CHANNEL");
      *(_OWORD *)keys = *(_OWORD *)off_1001E4F98;
      values[0] = v12;
      values[1] = v7;
      CFDictionaryRef v6 = CFDictionaryCreate( kCFAllocatorDefault,  (const void **)keys,  (const void **)values,  2LL,  &kCFTypeDictionaryKeyCallBacks,  &kCFTypeDictionaryValueCallBacks);
      CFArrayAppendValue(Mutable, v6);
      uint64_t v13 = sub_1000ED0D0(a2, Mutable, *(_DWORD *)(a1 + 128), 0x6Eu, 1);
      if (!v13) {
        goto LABEL_24;
      }
      uint64_t v5 = v13;
      CFDictionarySetValue(v13, @"SCAN_LOW_LATENCY", kCFBooleanTrue);
    }

    NSErrorUserInfoKey v14 = malloc(0x28uLL);
    if (v14)
    {
      uint64_t v15 = v14;
      void *v14 = a1;
      v14[1] = 0LL;
      v14[3] = 0LL;
      if (CFDictionaryContainsKey(v5, @"SSID_STR")) {
        BOOL v16 = 1;
      }
      else {
        BOOL v16 = CFDictionaryContainsKey(v5, @"SCAN_SSID_LIST") != 0;
      }
      v15[32] = v16;
      CFIndex v17 = (const void *)sub_100043E8C(*(void *)(a1 + 64));
      uint64_t v10 = sub_1000E0CC4(a1, v17, v5, 0LL, (uint64_t)sub_10010C37C, (uint64_t)v15, 0LL, 18LL);
      if ((_DWORD)v10)
      {
        unint64_t v21 = objc_autoreleasePoolPush();
        if (qword_100219F60) {
          objc_msgSend((id)qword_100219F60, "WFLog:message:", 4, "Error initiating scan request: %d", v10);
        }
        objc_autoreleasePoolPop(v21);
        free(v15);
      }
    }

    else
    {
      id v20 = objc_autoreleasePoolPush();
      if (qword_100219F60) {
        [qword_100219F60 WFLog:@"%s: null scanData" message:4];
      }
      objc_autoreleasePoolPop(v20);
      uint64_t v10 = 0LL;
    }

    CFRelease(v5);
    if (!v7) {
      goto LABEL_19;
    }
    goto LABEL_18;
  }

  uint64_t v9 = objc_autoreleasePoolPush();
  if (qword_100219F60) {
    [qword_100219F60 WFLog:@"%s: manager NULL" message:3];
  }
  objc_autoreleasePoolPop(v9);
  return 4294963396LL;
}

void sub_10010C37C(int a1, int a2, const __CFArray *a3, int a4, int a5, uint64_t *a6)
{
  uint64_t v6 = *a6;
  if (!*(void *)(*a6 + 6808))
  {
    uint64_t v33 = objc_autoreleasePoolPush();
    if (qword_100219F60) {
      [qword_100219F60 WFLog:@"__WiFiDeviceManagerAutoInstantHotspotScanCallback: No Network"];
    }
    objc_autoreleasePoolPop(v33);
    return;
  }

  free(a6);
  uint64_t v9 = (const __CFString *)sub_1000951FC(*(void *)(v6 + 6808), @"SSID_STR");
  uint64_t v10 = v9;
  if (v9) {
    CFRetain(v9);
  }
  if (a3 && CFArrayGetCount(a3))
  {
    CFNumberRef v11 = objc_autoreleasePoolPush();
    if (qword_100219F60) {
      [(id)qword_100219F60 WFLog:3, "%s: Looking for autoInstantHotspot.hotspotAssocNetwork %@", "__WiFiDeviceManagerAutoInstantHotspotScanCallback", *(void *)(v6 + 6808) message];
    }
    objc_autoreleasePoolPop(v11);
    CFErrorDomain v12 = objc_autoreleasePoolPush();
    if (qword_100219F60) {
      [qword_100219F60 WFLog:@"__WiFiDeviceManagerAutoInstantHotspotScanCallback found %ld networks" message:3];
    }
    objc_autoreleasePoolPop(v12);
    if (CFArrayGetCount(a3) < 1)
    {
LABEL_15:
      *(_DWORD *)(v6 + 3272) = *(_DWORD *)(v6 + 6844);
      sub_10010BEEC(v6, v10, 3u);
      *(_DWORD *)(v6 + 644_Block_object_dispose(va, 8) = -3906;
      sub_1000325B0((unsigned int *)(v6 + 6448));
      BOOL v16 = objc_autoreleasePoolPush();
      if (qword_100219F60) {
        [qword_100219F60 WFLog:@"%s: did not find the top network" message:3];
      }
      objc_autoreleasePoolPop(v16);
      if (!v10) {
        return;
      }
    }

    else
    {
      CFIndex v13 = 0LL;
      while (1)
      {
        ValueAtIndex = CFArrayGetValueAtIndex(a3, v13);
        if (ValueAtIndex)
        {
          uint64_t v15 = ValueAtIndex;
        }

        if (CFArrayGetCount(a3) <= ++v13) {
          goto LABEL_15;
        }
      }

      CFRange v26 = objc_autoreleasePoolPush();
      if (qword_100219F60) {
        [(id)qword_100219F60 WFLog:3, "%s: found the top network to match scanned network %@", "__WiFiDeviceManagerAutoInstantHotspotScanCallback", sub_100095BC8(v15) message];
      }
      objc_autoreleasePoolPop(v26);
      sub_100095524((uint64_t)v15, *(void *)(v6 + 6808));
      if ((_os_feature_enabled_impl("CoreWiFi", "UnifiedAutoJoin") & 1) == 0) {
        sub_1000D03E4(v6);
      }
      size_t v27 = *(const void **)(v6 + 6808);
      if (v27) {
        CFRelease(v27);
      }
      *(void *)(v6 + 680_Block_object_dispose(va, 8) = 0LL;
      unsigned int v28 = sub_100094E60((uint64_t)kCFAllocatorDefault, (uint64_t)v15);
      *(void *)(v6 + 680_Block_object_dispose(va, 8) = v28;
      sub_10009582C((uint64_t)v28, @"WiFiAutoInstantHotspotJoining", kCFBooleanTrue);
      sub_10009582C(*(void *)(v6 + 6808), @"WiFiInstantHotspotJoining", kCFBooleanFalse);
      uint64_t v29 = (const void *)sub_100043E8C(*(void *)(v6 + 64));
      uint64_t v30 = sub_1000E1104(v6, v29, *(void **)(v6 + 6808), 0LL, 0LL, (uint64_t)sub_10010C9C0, 0LL, 1018LL);
      if ((_DWORD)v30)
      {
        uint64_t v31 = v30;
        BOOL v32 = objc_autoreleasePoolPush();
        if (qword_100219F60) {
          [qword_100219F60 WFLog:@"%s: Error returned by Associate Async %d" message:3, "%s: Error returned by Associate Async %d",  "__WiFiDeviceManagerAutoInstantHotspotAssociate",  v31];
        }
        objc_autoreleasePoolPop(v32);
        *(void *)(v6 + 6824) = 0LL;
        *(_DWORD *)(v6 + 3272) = *(_DWORD *)(v6 + 6844);
        sub_1000D02BC(v6);
        *(_DWORD *)(v6 + 3272) = *(_DWORD *)(v6 + 6844);
        sub_10010BEEC(v6, v10, 4u);
        unint64_t v21 = (unsigned int *)(v6 + 6448);
        *(_DWORD *)(v6 + 644_Block_object_dispose(va, 8) = v31;
        goto LABEL_26;
      }

      sub_10010B9B4((uint64_t *)v6, @"userJoinAssociating", *(const void **)(v6 + 6808));
      if (!v10) {
        return;
      }
    }

void sub_10010C844(uint64_t a1)
{
  uint64_t v2 = *(void **)(a1 + 32);
  if (v2[30])
  {
    CFRetain(v2);
    block[0] = _NSConcreteStackBlock;
    block[1] = 3221225472LL;
    block[2] = sub_10010C90C;
    block[3] = &unk_1001E4AE8;
    char v5 = *(_BYTE *)(a1 + 48);
    dispatch_async(*(dispatch_queue_t *)(*(void *)(a1 + 32) + 240LL), block);
  }

  else
  {
    uint64_t v3 = objc_autoreleasePoolPush();
    if (qword_100219F60) {
      [qword_100219F60 WFLog:@"%s: null queue." message:4];
    }
    objc_autoreleasePoolPop(v3);
  }

void sub_10010C90C(uint64_t a1)
{
  uint64_t v2 = *(void **)(a1 + 32);
  if (v2[30])
  {
    uint64_t v3 = sub_10010C020(v2, v2[851], *(unsigned __int8 *)(a1 + 48));
    if ((_DWORD)v3)
    {
      uint64_t v4 = v3;
      char v5 = objc_autoreleasePoolPush();
      if (qword_100219F60) {
        [qword_100219F60 WFLog:@"__WiFiDeviceManagerAutoInstantHotspotScanCallback_block_invoke_2: error initiating scan = %d" message:3];
      }
      objc_autoreleasePoolPop(v5);
      uint64_t v6 = *(void *)(a1 + 32);
      CFNumberRef v7 = *(const __CFString **)(a1 + 40);
      *(_DWORD *)(v6 + 3272) = *(_DWORD *)(v6 + 6844);
      sub_10010BEEC(v6, v7, 3u);
      id v8 = (unsigned int *)(*(void *)(a1 + 32) + 6448LL);
      *id v8 = v4;
      sub_1000325B0(v8);
    }

    uint64_t v2 = *(void **)(a1 + 32);
  }

  CFRelease(v2);
}

void sub_10010C9C0(uint64_t a1, uint64_t a2, const void *a3, uint64_t a4, uint64_t a5)
{
  if (!a1)
  {
    NSErrorUserInfoKey v14 = objc_autoreleasePoolPush();
    if (qword_100219F60) {
      [qword_100219F60 WFLog:@"%s: manager is NULL" message:3];
    }
    objc_autoreleasePoolPop(v14);
    return;
  }

  if (!a3)
  {
    unsigned int v28 = objc_autoreleasePoolPush();
    if (qword_100219F60) {
      [qword_100219F60 WFLog:@"__WiFiDeviceManagerAutoInstantHotspotAssociationCallback: No Network"];
    }
    objc_autoreleasePoolPop(v28);
    uint64_t v9 = 0LL;
LABEL_38:
    *(void *)(a1 + 6824) = 0LL;
    *(_DWORD *)(a1 + 3272) = *(_DWORD *)(a1 + 6844);
    sub_1000D02BC(a1);
    if (!v9) {
      return;
    }
    goto LABEL_39;
  }

  id v8 = (const __CFString *)sub_1000951FC(*(void *)(a1 + 6808), @"SSID_STR");
  uint64_t v9 = v8;
  if (v8) {
    CFRetain(v8);
  }
  if (!(_DWORD)a5)
  {
    uint64_t v15 = objc_autoreleasePoolPush();
    if (qword_100219F60) {
      [(id)qword_100219F60 WFLog:3, "%s: Hotspot Association to %@ Success.", "__WiFiDeviceManagerAutoInstantHotspotAssociationCallback", sub_100095BC8(a3) message];
    }
    objc_autoreleasePoolPop(v15);
    *(_BYTE *)(a1 + 684_Block_object_dispose(va, 8) = 1;
    *(_BYTE *)(a1 + 6939) = 1;
    CFAbsoluteTime Current = CFAbsoluteTimeGetCurrent();
    CFDateRef v17 = CFDateCreate(kCFAllocatorDefault, Current);
    if (v17)
    {
      CFDateRef v18 = v17;
      sub_10009A194(a3, 0, v17);
      uint64_t v19 = objc_autoreleasePoolPush();
      if (qword_100219F60) {
        [(id)qword_100219F60 WFLog:3, "%s: setting auto association date for %@ to %@", "__WiFiDeviceManagerAutoInstantHotspotAssociationCallback", sub_100095BC8(a3), v18 message];
      }
      objc_autoreleasePoolPop(v19);
      CFRelease(v18);
    }

    sub_1000D3650(a1, a3);
    sub_10009582C(*(void *)(a1 + 3504), @"WiFiAutoInstantHotspotJoining", kCFBooleanTrue);
    sub_10010B9B4((uint64_t *)a1, @"userJoinSuccess", a3);
    id v20 = *(const void **)(a1 + 6808);
    if (v20)
    {
      CFRelease(v20);
      *(void *)(a1 + 680_Block_object_dispose(va, 8) = 0LL;
    }

    *(_BYTE *)(a1 + 5496) = 1;
    unint64_t v21 = *(dispatch_source_s **)(a1 + 5504);
    dispatch_time_t v22 = dispatch_time(0LL, 10000000000LL);
    dispatch_source_set_timer(v21, v22, 0xFFFFFFFFFFFFFFFFLL, 0LL);
    *(_DWORD *)(a1 + 68_Block_object_dispose(va, 8) = 0;
    *(void *)(a1 + 680) = 0LL;
    *(_BYTE *)(a1 + 6457) = 1;
    if (*(void *)(a1 + 4576))
    {
      if (*(void *)(a1 + 240))
      {
        uint64_t v30 = 0LL;
        uint64_t v31 = &v30;
        uint64_t v32 = 0x2020000000LL;
        uint64_t v33 = 0LL;
        id v23 = sub_100094E60((uint64_t)kCFAllocatorDefault, (uint64_t)a3);
        v31[3] = (uint64_t)v23;
        if (v23)
        {
          CFRetain((CFTypeRef)a1);
          dispatch_time_t v24 = *(dispatch_queue_s **)(a1 + 240);
          block[0] = _NSConcreteStackBlock;
          block[1] = 3221225472LL;
          block[2] = sub_10010D028;
          block[3] = &unk_1001E2D48;
          void block[4] = &v30;
          void block[5] = a1;
          dispatch_async(v24, block);
        }

        _Block_object_dispose(&v30, 8);
      }

      else
      {
        size_t v27 = objc_autoreleasePoolPush();
        if (qword_100219F60) {
          [qword_100219F60 WFLog:@"%s: null queue." message:4];
        }
        objc_autoreleasePoolPop(v27);
      }
    }

    goto LABEL_38;
  }

  double v10 = CFAbsoluteTimeGetCurrent();
  double v11 = *(double *)(a1 + 6968);
  CFErrorDomain v12 = objc_autoreleasePoolPush();
  if (v10 <= v11 || v10 - v11 >= 20.0)
  {
    if (qword_100219F60) {
      [(id)qword_100219F60 WFLog:3, "%s: Hotspot Association to %@ Failed. %d", "__WiFiDeviceManagerAutoInstantHotspotAssociationCallback", sub_100095BC8(a3), a5 message];
    }
    objc_autoreleasePoolPop(v12);
    sub_10010BEEC(a1, v9, 4u);
    *(_DWORD *)(a1 + 644_Block_object_dispose(va, 8) = a5;
    sub_1000325B0((unsigned int *)(a1 + 6448));
    goto LABEL_38;
  }

  if (qword_100219F60) {
    [qword_100219F60 WFLog:@"%s: retry Assoc after 1 second" message:3];
  }
  objc_autoreleasePoolPop(v12);
  dispatch_time_t v25 = dispatch_time(0LL, 1000000000LL);
  dispatch_queue_global_t global_queue = dispatch_get_global_queue(0LL, 0LL);
  v34[0] = _NSConcreteStackBlock;
  v34[1] = 3221225472LL;
  v34[2] = sub_10010CEA8;
  v34[3] = &unk_1001E2C30;
  v34[4] = a1;
  v34[5] = v9;
  dispatch_after(v25, global_queue, v34);
  if (v9) {
LABEL_39:
  }
    CFRelease(v9);
}

void sub_10010CE90( _Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, ...)
{
}

void sub_10010CEA8(uint64_t a1)
{
  uint64_t v2 = *(void **)(a1 + 32);
  if (v2[30])
  {
    CFRetain(v2);
    block[0] = _NSConcreteStackBlock;
    block[1] = 3221225472LL;
    block[2] = sub_10010CF68;
    block[3] = &unk_1001E2C30;
    dispatch_async(*(dispatch_queue_t *)(*(void *)(a1 + 32) + 240LL), block);
  }

  else
  {
    uint64_t v3 = objc_autoreleasePoolPush();
    if (qword_100219F60) {
      [qword_100219F60 WFLog:@"%s: null queue." message:4];
    }
    objc_autoreleasePoolPop(v3);
  }

void sub_10010CF68(uint64_t a1)
{
  uint64_t v2 = *(void *)(a1 + 32);
  if (*(void *)(v2 + 240))
  {
    uint64_t v3 = sub_10010C020(v2, *(void *)(v2 + 6808), *(unsigned __int8 *)(v2 + 6920));
    if ((_DWORD)v3)
    {
      uint64_t v4 = v3;
      char v5 = objc_autoreleasePoolPush();
      if (qword_100219F60) {
        [qword_100219F60 WFLog:@"__WiFiDeviceManagerAutoInstantHotspotAssociationCallback_block_invoke_2: SInt32 error = %d" message:3];
      }
      objc_autoreleasePoolPop(v5);
      uint64_t v6 = *(void *)(a1 + 32);
      CFNumberRef v7 = *(const __CFString **)(a1 + 40);
      *(_DWORD *)(v6 + 3272) = *(_DWORD *)(v6 + 6844);
      sub_10010BEEC(v6, v7, 4u);
      id v8 = (unsigned int *)(*(void *)(a1 + 32) + 6448LL);
      *id v8 = v4;
      sub_1000325B0(v8);
      sub_1000D02BC(*(void *)(a1 + 32));
    }

    uint64_t v2 = *(void *)(a1 + 32);
  }

  CFRelease((CFTypeRef)v2);
}

void sub_10010D028(uint64_t a1)
{
  uint64_t v2 = *(void **)(a1 + 40);
  if (v2[30])
  {
    uint64_t v3 = objc_autoreleasePoolPush();
    if (qword_100219F60) {
      [(id)qword_100219F60 WFLog:4, "%s: Adding network '%@' to known network list", "__WiFiDeviceManagerAutoInstantHotspotAssociationCallback_block_invoke_3", sub_100095BC8(*(const void **)(*(void *)(*(void *)(a1 + 32) + 8) + 24)) message];
    }
    objc_autoreleasePoolPop(v3);
    uint64_t v5 = *(void *)(a1 + 32);
    uint64_t v4 = *(void *)(a1 + 40);
    uint64_t v6 = (CFTypeRef *)(a1 + 32);
    (*(void (**)(uint64_t, void, void))(v4 + 4576))( v4,  *(void *)(*(void *)(v5 + 8) + 24LL),  *(void *)(v4 + 4584));
    CFRelease(v6[1]);
    CFNumberRef v7 = *v6;
  }

  else
  {
    CFRelease(v2);
    id v8 = *(void **)(a1 + 32);
    uint64_t v6 = (CFTypeRef *)(a1 + 32);
    CFNumberRef v7 = v8;
  }

  uint64_t v9 = *(const void **)(v7[1] + 24LL);
  if (v9)
  {
    CFRelease(v9);
    *(void *)(*((void *)*v6 + 1) + 24LL) = 0LL;
  }

void sub_10010D0FC(uint64_t a1)
{
  uint64_t v2 = *(void *)(a1 + 32);
  if (*(void *)(v2 + 240))
  {
    uint64_t v4 = *(void *)(a1 + 40);
    uint64_t v3 = (CFTypeRef *)(a1 + 40);
    (*(void (**)(uint64_t, uint64_t, void))(v2 + 4512))(v2, v4, *(void *)(v2 + 4520));
    CFRelease(*(v3 - 1));
  }

  else
  {
    CFRelease((CFTypeRef)v2);
    uint64_t v3 = (CFTypeRef *)(a1 + 40);
  }

  CFRelease(*v3);
}

void sub_10010D14C(uint64_t a1, CFTypeRef cf1, const void *a3, uint64_t a4)
{
  if (!a1)
  {
    CFIndex v13 = objc_autoreleasePoolPush();
    if (qword_100219F60) {
      [qword_100219F60 WFLog:@"__WiFiDeviceManagerPostAutoJoinNotificationWithMetric: null manager."];
    }
    goto LABEL_21;
  }

  if (!cf1)
  {
    CFIndex v13 = objc_autoreleasePoolPush();
    if (qword_100219F60) {
      [qword_100219F60 WFLog:@"__WiFiDeviceManagerPostAutoJoinNotificationWithMetric: null status."];
    }
    goto LABEL_21;
  }

  if (!*(void *)(a1 + 4064)) {
    return;
  }
  if (CFEqual(cf1, @"autoJoinNetworkNotFound"))
  {
    id v8 = objc_autoreleasePoolPush();
    if (qword_100219F60) {
      objc_msgSend( (id)qword_100219F60,  "WFLog:message:",  3,  "%s: auto-join failed with no network found. Unsuitable network count:%d",  "__WiFiDeviceManagerPostAutoJoinNotificationWithMetric",  *(unsigned int *)(a1 + 1128));
    }
    objc_autoreleasePoolPop(v8);
    if (!*(_DWORD *)(a1 + 1128))
    {
      *(_BYTE *)(a1 + 6849) = 1;
    }
  }

  CFMutableArrayRef Mutable = CFDictionaryCreateMutable( kCFAllocatorDefault,  0LL,  &kCFTypeDictionaryKeyCallBacks,  &kCFTypeDictionaryValueCallBacks);
  if (!Mutable)
  {
    CFIndex v13 = objc_autoreleasePoolPush();
    if (qword_100219F60) {
      [qword_100219F60 WFLog:@"%s: null notificationDict." message:3];
    }
LABEL_21:
    objc_autoreleasePoolPop(v13);
    return;
  }

  double v10 = Mutable;
  CFDictionarySetValue(Mutable, @"autoJoinStatus", cf1);
  if (a3) {
    CFDictionarySetValue(v10, @"autoJoinNetwork", a3);
  }
  double v11 = *(void (**)(uint64_t, uint64_t, void, __CFDictionary *, uint64_t))(a1 + 4064);
  uint64_t v12 = sub_100043E8C(*(void *)(a1 + 64));
  v11(a1, v12, *(void *)(a1 + 4072), v10, a4);
  CFRelease(v10);
}

void sub_10010D36C(uint64_t a1, void *a2)
{
  if (a2)
  {
    [*(id *)(*(void *)(a1 + 32) + 7320) setJoinEvent:0 withReason:0 lastDisconnectReason:0 lastJoinFailure:*(int *)(a1 + 40) andNetworkDetails:a2 forInterface:sub_100043E8C(*(void *)(*(void *)(a1 + 32) + 64))];
  }

void sub_10010D3D0(uint64_t a1)
{
  uint64_t v2 = *(const void **)(*(void *)(*(void *)(a1 + 32) + 8LL) + 24LL);
  if (v2)
  {
    CFRelease(v2);
    *(void *)(*(void *)(*(void *)(a1 + 32) + 8LL) + 24LL) = 0LL;
  }

void sub_10010D40C(uint64_t a1)
{
  uint64_t v2 = *(void *)(a1 + 32);
  if (*(void *)(v2 + 240))
  {
    (*(void (**)(uint64_t, void, void, void, void, void))(v2 + 3912))( v2,  *(void *)(a1 + 40),  *(void *)(a1 + 48),  *(void *)(a1 + 56),  *(unsigned int *)(a1 + 64),  *(void *)(v2 + 3920));
    CFRelease(*(CFTypeRef *)(a1 + 32));
    uint64_t v3 = *(const void **)(a1 + 40);
    if (v3) {
      CFRelease(v3);
    }
    uint64_t v4 = *(const void **)(a1 + 48);
    if (v4) {
      CFRelease(v4);
    }
    uint64_t v5 = *(const void **)(a1 + 56);
    if (v5) {
      CFRelease(v5);
    }
  }

  else
  {
    CFRelease((CFTypeRef)v2);
    uint64_t v6 = *(const void **)(a1 + 40);
    if (v6) {
      CFRetain(v6);
    }
    CFNumberRef v7 = *(const void **)(a1 + 48);
    if (v7) {
      CFRetain(v7);
    }
    id v8 = *(const void **)(a1 + 56);
    if (v8) {
      CFRetain(v8);
    }
  }

void sub_10010D4B0(uint64_t a1)
{
  uint64_t v2 = *(uint64_t **)(a1 + 40);
  if (v2[30])
  {
    uint64_t v3 = (void (*)(uint64_t *, uint64_t, void, void, void, void))v2[483];
    uint64_t v4 = sub_100043E8C(v2[8]);
    uint64_t v6 = *(void *)(a1 + 32);
    uint64_t v5 = (uint64_t *)(a1 + 32);
    v3(v2, v4, *(void *)(*(void *)(v6 + 8) + 24LL), 0LL, *((unsigned int *)v5 + 4), *(void *)(v5[1] + 3872));
    CFRelease((CFTypeRef)v5[1]);
    uint64_t v7 = *v5;
  }

  else
  {
    CFRelease(*(CFTypeRef *)(a1 + 40));
    uint64_t v8 = *(void *)(a1 + 32);
    uint64_t v5 = (uint64_t *)(a1 + 32);
    uint64_t v7 = v8;
  }

  uint64_t v9 = *(const void **)(*(void *)(v7 + 8) + 24LL);
  if (v9)
  {
    CFRelease(v9);
    *(void *)(*(void *)(*v5 + 8) + 24LL) = 0LL;
  }

void sub_10010D54C(uint64_t a1)
{
  uint64_t v2 = *(void *)(a1 + 40);
  if (*(void *)(v2 + 240))
  {
    uint64_t v4 = *(void *)(a1 + 32);
    uint64_t v3 = (CFTypeRef *)(a1 + 32);
    (*(void (**)(uint64_t, void, const __CFString *, const CFBooleanRef, void))(v2 + 4736))( v2,  *(void *)(*(void *)(v4 + 8) + 24LL),  @"FailureCountCurrent",  kCFBooleanTrue,  *(void *)(v2 + 4744));
    CFRelease(v3[1]);
    uint64_t v5 = *v3;
  }

  else
  {
    CFRelease((CFTypeRef)v2);
    uint64_t v6 = *(void **)(a1 + 32);
    uint64_t v3 = (CFTypeRef *)(a1 + 32);
    uint64_t v5 = v6;
  }

  uint64_t v7 = *(const void **)(v5[1] + 24LL);
  if (v7)
  {
    CFRelease(v7);
    *(void *)(*((void *)*v3 + 1) + 24LL) = 0LL;
  }

void sub_10010D5D4(uint64_t a1)
{
  uint64_t v2 = *(void *)(a1 + 40);
  if (*(void *)(v2 + 240))
  {
    uint64_t v4 = *(void *)(a1 + 32);
    uint64_t v3 = (CFTypeRef *)(a1 + 32);
    (*(void (**)(uint64_t, void, void))(v2 + 4704))( v2,  *(void *)(*(void *)(v4 + 8) + 24LL),  *(void *)(v2 + 4712));
    CFRelease(v3[1]);
    uint64_t v5 = *v3;
  }

  else
  {
    CFRelease((CFTypeRef)v2);
    uint64_t v6 = *(void **)(a1 + 32);
    uint64_t v3 = (CFTypeRef *)(a1 + 32);
    uint64_t v5 = v6;
  }

  uint64_t v7 = *(const void **)(v5[1] + 24LL);
  if (v7)
  {
    CFRelease(v7);
    *(void *)(*((void *)*v3 + 1) + 24LL) = 0LL;
  }

BOOL sub_10010D648(const __CFString *a1)
{
  if (a1)
  {
    return CFStringCompare(a1, @"RU", 0LL) == kCFCompareEqualTo
        || CFStringCompare(a1, @"KG", 0LL) == kCFCompareEqualTo
        || CFStringCompare(a1, @"AM", 0LL) == kCFCompareEqualTo
        || CFStringCompare(a1, @"KZ", 0LL) == kCFCompareEqualTo;
  }

  else
  {
    uint64_t v3 = objc_autoreleasePoolPush();
    if (qword_100219F60) {
      [qword_100219F60 WFLog:@"%s: countryCode is null\n" message:4];
    }
    objc_autoreleasePoolPop(v3);
    return 0LL;
  }

void sub_10010D71C(uint64_t a1)
{
  uint64_t v2 = objc_autoreleasePoolPush();
  if (qword_100219F60) {
    [qword_100219F60 WFLog:@"%s: MIS stopped Callback" message:3];
  }
  objc_autoreleasePoolPop(v2);
  if (*(_BYTE *)(a1 + 5215))
  {
    CFSetAddValue(*(CFMutableSetRef *)(a1 + 5264), @"wifid");
    sub_1000DCD9C(a1, 0);
    sub_1000457AC(*(void *)(a1 + 64), 0);
    sub_1000DC9F0(a1, 5LL);
  }

void sub_10010D7C8(uint64_t a1, CFArrayRef theArray)
{
  CFIndex Count = CFArrayGetCount(theArray);
  if (!Count)
  {
    unsigned int v44 = objc_autoreleasePoolPush();
    if (qword_100219F60) {
      [qword_100219F60 WFLog:@"%s: No GAS responses received" message:4];
    }
    goto LABEL_81;
  }

  uint64_t v4 = Count;
  CFIndex v5 = CFArrayGetCount(*(CFArrayRef *)(a1 + 3616));
  uint64_t v6 = CFArrayGetCount(*(CFArrayRef *)(a1 + 3624)) + v5;
  if (!v6)
  {
    unsigned int v44 = objc_autoreleasePoolPush();
    if (qword_100219F60) {
      [qword_100219F60 WFLog:@"__WiFiDeviceManagerFindMatchingHS20Account: No HS2.0 accounts"];
    }
LABEL_81:
    objc_autoreleasePoolPop(v44);
    return;
  }

  CFIndex v55 = CFArrayGetCount(theArray);
  if (!v55)
  {
    CFIndex v45 = objc_autoreleasePoolPush();
    if (qword_100219F60) {
      [qword_100219F60 WFLog:@"%s: No GAS responses received" message:4];
    }
    goto LABEL_86;
  }

  CFIndex v7 = CFArrayGetCount(*(CFArrayRef *)(a1 + 3616));
  uint64_t v52 = CFArrayGetCount(*(CFArrayRef *)(a1 + 3624)) + v7;
  uint64_t v8 = objc_autoreleasePoolPush();
  uint64_t v9 = (void *)qword_100219F60;
  if (qword_100219F60)
  {
    CFIndex v10 = CFArrayGetCount(*(CFArrayRef *)(a1 + 3616));
    [v9 WFLog:@"%s: hs20Accounts: enabled %ld, disabled %ld" message:3, @"__WiFiDeviceManagerSetHS20HomeOperatorNetwork", v10, CFArrayGetCount(*(CFArrayRef *)(a1 + 3624))];
  }

  objc_autoreleasePoolPop(v8);
  if (!v52)
  {
    CFIndex v45 = objc_autoreleasePoolPush();
    if (qword_100219F60) {
      [qword_100219F60 WFLog:@"__WiFiDeviceManagerSetHS20HomeOperatorNetwork: No HS2.0 accounts"];
    }
LABEL_86:
    objc_autoreleasePoolPop(v45);
    goto LABEL_56;
  }

  MutableCFStringRef Copy = CFArrayCreateMutableCopy(kCFAllocatorDefault, 0LL, *(CFArrayRef *)(a1 + 3616));
  if (CFArrayGetCount(*(CFArrayRef *)(a1 + 3624)))
  {
    uint64_t v12 = *(const __CFArray **)(a1 + 3624);
    v57.length = CFArrayGetCount(v12);
    v57.location = 0LL;
    CFArrayAppendArray(MutableCopy, v12, v57);
  }

  CFTypeRef cf = MutableCopy;
  if (v55 >= 1)
  {
    for (CFIndex i = 0LL; i != v55; ++i)
    {
      ValueAtIndex = CFArrayGetValueAtIndex(theArray, i);
      if (ValueAtIndex) {
        sub_10009D374((uint64_t)ValueAtIndex, 0);
      }
    }
  }

  uint64_t v48 = a1;
  uint64_t v49 = v6;
  uint64_t v50 = v4;
  uint64_t v15 = MutableCopy;
  if (v52 >= 1)
  {
    CFIndex v16 = 0LL;
    do
    {
      CFIndex v53 = v16;
      uint64_t v54 = (void *)CFArrayGetValueAtIndex(v15, v16);
      if (v54)
      {
        CFDateRef v17 = (const __CFString *)sub_1000951FC((uint64_t)v54, @"DomainName");
        if (v17)
        {
          CFDateRef v18 = v17;
          uint64_t v19 = objc_autoreleasePoolPush();
          if (qword_100219F60) {
            [(id)qword_100219F60 WFLog:3, "%s: Home Domain name %@", "__WiFiDeviceManagerSetHS20HomeOperatorNetwork", v18 message];
          }
          objc_autoreleasePoolPop(v19);
          if (sub_100099E30(v54))
          {
            if (v55 >= 1)
            {
              for (CFIndex j = 0LL; j != v55; ++j)
              {
                unint64_t v21 = CFArrayGetValueAtIndex(theArray, j);
                if (v21)
                {
                  dispatch_time_t v22 = v21;
                  id v23 = (const __CFDictionary *)sub_10009D448((uint64_t)v21);
                  if (v23)
                  {
                    CFBooleanRef Value = (const __CFArray *)CFDictionaryGetValue(v23, @"ANQP_DOMAIN_NAME_LIST");
                    dispatch_time_t v25 = objc_autoreleasePoolPush();
                    if (Value)
                    {
                      if (qword_100219F60) {
                        [(id)qword_100219F60 WFLog:3, "%s: Checking ANQP domain list against home domain %@", "__WiFiDeviceManagerSetHS20HomeOperatorNetwork", v18 message];
                      }
                      objc_autoreleasePoolPop(v25);
                      CFIndex v26 = CFArrayGetCount(Value);
                      if (v26 >= 1)
                      {
                        CFIndex v27 = v26;
                        CFIndex v28 = 0LL;
                        while (1)
                        {
                          uint64_t v29 = (const __CFString *)CFArrayGetValueAtIndex(Value, v28);
                          uint64_t v30 = objc_autoreleasePoolPush();
                          if (qword_100219F60) {
                            [(id)qword_100219F60 WFLog:3, "%s: Comparing home domain %@ against ANQP domain result %@", "__WiFiDeviceManagerSetHS20HomeOperatorNetwork", v18, v29 message];
                          }
                          objc_autoreleasePoolPop(v30);
                          if (v29)
                          {
                            if (CFStringCompare(v18, v29, 0LL) == kCFCompareEqualTo)
                            {
                              sub_10009D374((uint64_t)v22, 1);
                              sub_10009D31C((uint64_t)v22, 1);
                              sub_100095524((uint64_t)v22, (uint64_t)v54);
                              dispatch_time_t v25 = objc_autoreleasePoolPush();
                              uint64_t v32 = (void *)qword_100219F60;
                              if (qword_100219F60)
                              {
                                uint64_t v33 = sub_1000951FC((uint64_t)v54, @"DomainName");
                                [v32 WFLog:3, "%s: found response from home operator %@, marking %@ provisioned", "__WiFiDeviceManagerSetHS20HomeOperatorNetwork", v33, sub_100095BC8(v22) message];
                              }

                              goto LABEL_47;
                            }

                            uint64_t v31 = objc_autoreleasePoolPush();
                            if (qword_100219F60) {
                              [(id)qword_100219F60 WFLog:3, "%s: home domain %@ and ANQP domain result %@ were determined to be different", "__WiFiDeviceManagerSetHS20HomeOperatorNetwork", v18, v29 message];
                            }
                            objc_autoreleasePoolPop(v31);
                          }

                          if (v27 == ++v28) {
                            goto LABEL_48;
                          }
                        }
                      }

                      continue;
                    }

                    if (qword_100219F60) {
                      [qword_100219F60 WFLog:@"%s: ANQP domain list was NULL" message:3 v46 v47];
                    }
                  }

                  else
                  {
                    dispatch_time_t v25 = objc_autoreleasePoolPush();
                    if (qword_100219F60) {
                      [qword_100219F60 WFLog:@"%s: result from WiFiNetworkGetGasResponse() was NULL" message:3 v46 v47];
                    }
                  }
                }

                else
                {
                  dispatch_time_t v25 = objc_autoreleasePoolPush();
                  if (qword_100219F60) {
                    [qword_100219F60 WFLog:@"%s: network ref from responses was NULL." message:3 v46 v47];
                  }
                }

void sub_10010DE60(uint64_t a1, const void *a2, uint64_t a3, const __CFDictionary **a4)
{
  uint64_t v7 = (uint64_t)*a4;
  *((_BYTE *)*a4 + 5421) = 0;
  if ((_DWORD)a3)
  {
    sub_1000E6064(v7, a2, 0LL, 0LL, 0LL);
    uint64_t v8 = 0LL;
  }

  else
  {
    uint64_t v8 = sub_100040538(a1, a2);
    if (v8)
    {
      CFNumberRef v9 = CFNumberCreate(kCFAllocatorDefault, kCFNumberSInt32Type, a4 + 4);
      if (v9)
      {
        CFIndex v10 = v9;
        int valuePtr = -1431655766;
        sub_10009582C((uint64_t)v8, @"networkRole", v9);
        CFNumberGetValue(v10, kCFNumberSInt32Type, &valuePtr);
        if (valuePtr == 4)
        {
          double v11 = a4[3];
          if (v11)
          {
            CFBooleanRef Value = CFDictionaryGetValue(a4[3], @"APPLE80211KEY_AWDL_INFO_ASSISTED_DISCOVERY_FOLLOW");
            if (Value) {
              sub_10009582C((uint64_t)v8, @"APPLE80211KEY_AWDL_INFO_ASSISTED_DISCOVERY_FOLLOW", Value);
            }
            CFIndex v13 = CFDictionaryGetValue(v11, @"AWDL_INFO_ASSISTED_DISCOVERY_METRIC");
            if (v13)
            {
              sub_10009582C((uint64_t)v8, @"AWDL_INFO_ASSISTED_DISCOVERY_METRIC", v13);
              NSErrorUserInfoKey v14 = (const __CFString *)a4[6];
              if (v14)
              {
                if (CFStringCompare(v14, @"mobilewifitool", 0LL))
                {
                  CFAbsoluteTime Current = CFAbsoluteTimeGetCurrent();
                  CFDateRef v16 = CFDateCreate(kCFAllocatorDefault, Current);
                  sub_10009582C((uint64_t)v8, @"lastJoined", v16);
                  if (v16) {
                    CFRelease(v16);
                  }
                }
              }
            }
          }
        }

        CFRelease(v10);
      }

      CFSetAddValue(*(CFMutableSetRef *)(v7 + 3312), v8);
    }
  }

  CFDateRef v17 = a4[1];
  if (v17) {
    ((void (*)(uint64_t, const void *, uint64_t, const void *, void, const __CFDictionary *))v17)( v7,  a2,  a3,  v8,  0LL,  a4[5]);
  }
  CFDateRef v18 = a4[3];
  if (v18)
  {
    CFRelease(v18);
    a4[3] = 0LL;
  }

  uint64_t v19 = a4[6];
  if (v19)
  {
    CFRelease(v19);
    a4[6] = 0LL;
  }

  if (v8) {
    CFRelease(v8);
  }
  free(a4);
}

void sub_10010E054(int a1, uint64_t a2, uint64_t a3, uint64_t *a4)
{
  uint64_t v6 = *a4;
  CFIndex v5 = (void (*)(uint64_t, uint64_t, uint64_t, void, uint64_t))a4[1];
  if (v5) {
    v5(*a4, a2, a3, 0LL, a4[3]);
  }
  uint64_t v7 = (const void *)a4[2];
  if (v7 && CFSetContainsValue(*(CFSetRef *)(v6 + 3312), v7)) {
    CFSetRemoveValue(*(CFMutableSetRef *)(v6 + 3312), (const void *)a4[2]);
  }
  if (*(void *)(v6 + 5400))
  {
    uint64_t v8 = objc_autoreleasePoolPush();
    sub_1000D0894(v6);
    objc_autoreleasePoolPop(v8);
  }

  CFNumberRef v9 = (const void *)a4[2];
  if (v9) {
    CFRelease(v9);
  }
  free(a4);
}

__CFDictionary *sub_10010E0E0(id *a1)
{
  if (_os_feature_enabled_impl("CoreWiFi", "UnifiedAutoJoin"))
  {
    id v2 = objc_msgSend(objc_msgSend(a1[1097], "statistics"), "copy");
    id v3 = objc_msgSend(objc_msgSend(v2, "debugInfo"), "copy");

    return (__CFDictionary *)v3;
  }

  else
  {
    if (!a1) {
      return 0LL;
    }
    v44[0] = @"PrevChannelScan";
    v44[1] = @"MRUChannelScan";
    v44[2] = @"RemChannelScan";
    v44[3] = @"Broadcast24GScan";
    v44[4] = @"Broadcast5GScan";
    v44[5] = @"BroadcastGeoBasedAllBandScan";
    v44[6] = @"BroadcastPeriodicAllBandScan";
    v44[7] = @"BroadcastLegacyAllBandScan";
    v44[8] = @"BroadcastLocnInvalidAllBandScan";
    v44[9] = @"BroadcastFake5GScan";
    v44[10] = @"HiddenNetworkScan";
    v44[11] = @"LocnPrevChannelScan";
    v44[12] = @"LocnMRUChannelScan";
    v43[0] = @"DeviceEnable";
    v43[1] = @"ATJOneShot";
    v43[2] = @"BTStateChange";
    v43[3] = @"PowerStateChange";
    v43[4] = @"LinkStateChange";
    void v43[5] = @"WiFiDirectDisabled";
    v43[6] = @"ClientAssociateCallback";
    v43[7] = @"AdhocNetworkStopped";
    v43[8] = @"BatteryPowerResource";
    v43[9] = @"AWDLBringup";
    v43[10] = @"AWDLBringdown";
    v43[11] = @"AJDeferralTimer";
    v43[12] = @"MISEvent";
    v43[13] = @"SetNetworkCall";
    v42[0] = @"ResetTypeNone";
    v42[1] = @"ResetTypeModerate";
    void v42[2] = @"ResetTypeFull";
    CFMutableArrayRef Mutable = CFDictionaryCreateMutable( kCFAllocatorDefault,  0LL,  &kCFTypeDictionaryKeyCallBacks,  &kCFTypeDictionaryValueCallBacks);
    uint64_t v6 = 0LL;
    uint64_t v7 = (char *)(a1 + 739);
    do
    {
      CFNumberRef v8 = CFNumberCreate(kCFAllocatorDefault, kCFNumberIntType, v7);
      if (v8)
      {
        CFNumberRef v9 = v8;
        CFDictionarySetValue(Mutable, (const void *)v44[v6], v8);
        CFRelease(v9);
      }

      ++v6;
      v7 += 4;
    }

    while (v6 != 13);
    uint64_t v10 = 0LL;
    double v11 = (char *)a1 + 5668;
    do
    {
      CFNumberRef v12 = CFNumberCreate(kCFAllocatorDefault, kCFNumberIntType, v11);
      if (v12)
      {
        CFNumberRef v13 = v12;
        CFDictionarySetValue(Mutable, (const void *)v43[v10], v12);
        CFRelease(v13);
      }

      ++v10;
      v11 += 4;
    }

    while (v10 != 14);
    uint64_t v14 = 0LL;
    uint64_t v15 = (char *)a1 + 5644;
    do
    {
      CFNumberRef v16 = CFNumberCreate(kCFAllocatorDefault, kCFNumberIntType, v15);
      if (v16)
      {
        CFNumberRef v17 = v16;
        CFDictionarySetValue(Mutable, (const void *)v42[v14], v16);
        CFRelease(v17);
      }

      ++v14;
      v15 += 4;
    }

    while (v14 != 3);
    CFNumberRef v18 = CFNumberCreate(kCFAllocatorDefault, kCFNumberIntType, a1 + 758);
    if (v18)
    {
      CFNumberRef v19 = v18;
      CFDictionarySetValue(Mutable, @"NetworkTransitionScan", v18);
      CFRelease(v19);
    }

    CFNumberRef v20 = CFNumberCreate(kCFAllocatorDefault, kCFNumberIntType, a1 + 729);
    if (v20)
    {
      CFNumberRef v21 = v20;
      CFDictionarySetValue(Mutable, @"AJNum5GhzOnlyNetworks", v20);
      CFRelease(v21);
    }

    CFNumberRef v22 = CFNumberCreate(kCFAllocatorDefault, kCFNumberIntType, (char *)a1 + 5836);
    if (v22)
    {
      CFNumberRef v23 = v22;
      CFDictionarySetValue(Mutable, @"AJNumDualBandNetworks", v22);
      CFRelease(v23);
    }

    CFNumberRef v24 = CFNumberCreate(kCFAllocatorDefault, kCFNumberIntType, a1 + 730);
    if (v24)
    {
      CFNumberRef v25 = v24;
      CFDictionarySetValue(Mutable, @"AJNum24GhzOnlyNetworks", v24);
      CFRelease(v25);
    }

    CFNumberRef v26 = CFNumberCreate(kCFAllocatorDefault, kCFNumberIntType, a1 + 728);
    if (v26)
    {
      CFNumberRef v27 = v26;
      CFDictionarySetValue(Mutable, @"AJ5GhzTriggerForBusy24GhzBand", v26);
      CFRelease(v27);
    }

    CFNumberRef v28 = CFNumberCreate(kCFAllocatorDefault, kCFNumberIntType, a1 + 727);
    if (v28)
    {
      CFNumberRef v29 = v28;
      CFDictionarySetValue(Mutable, @"AJ5GhzTriggerForHS20Networks", v28);
      CFRelease(v29);
    }

    CFNumberRef v30 = CFNumberCreate(kCFAllocatorDefault, kCFNumberIntType, (char *)a1 + 5820);
    if (v30)
    {
      CFNumberRef v31 = v30;
      CFDictionarySetValue(Mutable, @"AJ5GhzTriggerForLegacyHSNetworks", v30);
      CFRelease(v31);
    }

    CFNumberRef v32 = CFNumberCreate(kCFAllocatorDefault, kCFNumberIntType, (char *)a1 + 5828);
    if (v32)
    {
      CFNumberRef v33 = v32;
      CFDictionarySetValue(Mutable, @"AJ5GhzTriggerForNetworks", v32);
      CFRelease(v33);
    }

    CFNumberRef v34 = CFNumberCreate(kCFAllocatorDefault, kCFNumberIntType, (char *)a1 + 5812);
    if (v34)
    {
      CFNumberRef v35 = v34;
      CFDictionarySetValue(Mutable, @"AJ5GhzTriggerForHiddenNetworks", v34);
      CFRelease(v35);
    }

    CFNumberRef v36 = CFNumberCreate(kCFAllocatorDefault, kCFNumberIntType, (char *)a1 + 6164);
    if (v36)
    {
      CFNumberRef v37 = v36;
      CFDictionarySetValue(Mutable, @"AutoHotspotBTScanCount", v36);
      CFRelease(v37);
    }

    CFNumberRef v38 = CFNumberCreate(kCFAllocatorDefault, kCFNumberIntType, a1 + 771);
    if (v38)
    {
      CFNumberRef v39 = v38;
      CFDictionarySetValue(Mutable, @"AutoHotspotBTScanDuration", v38);
      CFRelease(v39);
    }

    CFNumberRef v40 = CFNumberCreate(kCFAllocatorDefault, kCFNumberIntType, a1 + 856);
    if (v40)
    {
      CFNumberRef v41 = v40;
      CFDictionarySetValue(Mutable, @"isADHSConnected", v40);
      CFRelease(v41);
    }

    return Mutable;
  }

void sub_10010E744(uint64_t a1)
{
  if (a1)
  {
    *(void *)(a1 + 7176) = 0LL;
    id v2 = (_BYTE *)(a1 + 7189);
    if (*(_BYTE *)(a1 + 7189))
    {
      id v3 = objc_autoreleasePoolPush();
      if (qword_100219F60) {
        [(id)qword_100219F60 WFLog:3 message:"DPS/DNS Symptoms HUD: clearing display and stopping displayTimer"];
      }
      objc_autoreleasePoolPop(v3);
      _BYTE *v2 = 0;
      dispatch_source_set_timer(*(dispatch_source_t *)(a1 + 7168), 0xFFFFFFFFFFFFFFFFLL, 0xFFFFFFFFFFFFFFFFLL, 0LL);
      if (MGGetBoolAnswer(@"InternalBuild"))
      {
        uint64_t v4 = *(void (**)(uint64_t, uint64_t, void, void))(a1 + 4544);
        if (v4) {
          v4(a1, 18LL, 0LL, *(void *)(a1 + 4552));
        }
      }
    }

    if (*(_DWORD *)(a1 + 7184)) {
      sub_10001D984(*(void *)(a1 + 120));
    }
  }

  else
  {
    CFIndex v5 = objc_autoreleasePoolPush();
    if (qword_100219F60) {
      [qword_100219F60 WFLog:@"%s: null manager." message:4];
    }
    objc_autoreleasePoolPop(v5);
  }

void sub_10010E868(uint64_t a1)
{
  if (a1)
  {
    id v2 = (_BYTE *)(a1 + 7240);
    *(void *)(a1 + 7224) = 0LL;
    *(void *)(a1 + 7216) = 0LL;
    if (*(_BYTE *)(a1 + 7240))
    {
      id v3 = objc_autoreleasePoolPush();
      if (qword_100219F60) {
        [(id)qword_100219F60 WFLog:3 message:"SlowWiFi HUD: clearing display and stopping displayTimer"];
      }
      objc_autoreleasePoolPop(v3);
      _BYTE *v2 = 0;
      dispatch_source_set_timer(*(dispatch_source_t *)(a1 + 7208), 0xFFFFFFFFFFFFFFFFLL, 0xFFFFFFFFFFFFFFFFLL, 0LL);
      if (MGGetBoolAnswer(@"InternalBuild"))
      {
        uint64_t v4 = *(void (**)(uint64_t, uint64_t, void, void))(a1 + 4544);
        if (v4) {
          v4(a1, 17LL, 0LL, *(void *)(a1 + 4552));
        }
      }
    }
  }

  else
  {
    CFIndex v5 = objc_autoreleasePoolPush();
    if (qword_100219F60) {
      [qword_100219F60 WFLog:@"%s: null manager." message:4];
    }
    objc_autoreleasePoolPop(v5);
  }

id sub_10010E980(uint64_t a1, const void *a2, int a3)
{
  uint64_t v6 = sub_1000951FC((uint64_t)a2, @"BSSID");
  uint64_t v7 = sub_100095BC8(a2);
  int v8 = sub_100054520(*(void *)(a1 + 64));
  BOOL v9 = sub_100095B4C((uint64_t)a2);
  unsigned int v10 = sub_1000FDC1C(a1, a2);
  unsigned int v11 = sub_100096670((uint64_t)a2);
  int v12 = sub_10009FDC8((uint64_t)a2);
  unsigned int v13 = v12;
  if (v8 && !v9 && v10 != 1 && (v11 == 1 || v12 == 2))
  {
    [+[WiFiAnalyticsManager sharedWiFiAnalyticsManager]( WiFiAnalyticsManager,  "sharedWiFiAnalyticsManager") getAdaptiveRoamParams:v6 ssid:v7];
    char v26 = 1;
  }

  else
  {
    int v35 = v12;
    uint64_t v14 = objc_autoreleasePoolPush();
    uint64_t v15 = (void *)qword_100219F60;
    if (qword_100219F60)
    {
      BOOL v16 = v9;
      BOOL v33 = v8 != 0;
      CFNumberRef v17 = sub_10003B2EC(v10);
      int v34 = v8;
      BOOL v18 = v9;
      unsigned int v19 = v10;
      CFNumberRef v20 = v7;
      CFNumberRef v21 = v17;
      CFNumberRef v32 = sub_10003B334(v11);
      CFNumberRef v31 = v20;
      unsigned int v10 = v19;
      BOOL v9 = v18;
      int v8 = v34;
      [v15 WFLog:3, "%s: not enabling adaptive roaming on %@ (forceApply:%u deviceSupport:%u EAP:%u env:%@ networkOfInterestType:%@ LOIType:%@)", "__WiFiDeviceManagerGetAdaptiveRoamParams", v31, a3 != 0, v33, v16, v21, v32, sub_10003B3B0(v35) message];
    }

    objc_autoreleasePoolPop(v14);
    if (a3)
    {
      unsigned int v22 = v11;
      CFNumberRef v23 = objc_alloc_init(&OBJC_CLASS___NSMutableDictionary);
      -[NSMutableDictionary setObject:forKey:]( v23,  "setObject:forKey:",  +[NSNumber numberWithInt:](&OBJC_CLASS___NSNumber, "numberWithInt:", 0LL),  @"IO80211InterfaceAdaptiveRoamRSSITrigger");
      uint64_t v24 = *(void *)(a1 + 64);
      CFNumberRef v25 = (const void *)sub_100043E8C(v24);
      sub_10003EC6C(v24, v25, 532LL, 0LL, (uint64_t)v23);

      unsigned int v11 = v22;
    }

    char v26 = 0;
    unsigned int v13 = v35;
  }

  uint64_t v27 = v11;
  CFNumberRef v28 = *(void **)(a1 + 7320);
  uint64_t v29 = sub_100043E8C(*(void *)(a1 + 64));
  v36[0] = v26;
  v36[1] = a3 != 0;
  v36[2] = v8 != 0;
  v36[3] = v9;
  int v37 = -1431655766;
  uint64_t v38 = v10;
  uint64_t v39 = v27;
  uint64_t v40 = v13;
  return [v28 setRoamingARCriteria:v36 forInterface:v29];
}

double sub_10010EBFC(uint64_t a1, const void *a2, const void *a3, const void *a4, uint64_t a5, uint64_t a6)
{
  uint64_t v11 = sub_10004CA94(*(void *)(a6 + 64));
  [+[WiFiXPCManager sharedXPCManager](WiFiXPCManager, "sharedXPCManager") associationDoneWithNetwork:a3 error:a5 interfaceName:a2];
  int v12 = objc_autoreleasePoolPush();
  if (qword_100219F60)
  {
    unsigned int v13 = sub_1000BDC98(*(_DWORD *)(a6 + 3272));
    uint64_t v14 = +[NSString stringWithFormat:]( &OBJC_CLASS___NSString,  "stringWithFormat:",  @"%s",  -[NSString UTF8String]( +[NSString stringWithFormat:]( &OBJC_CLASS___NSString,  "stringWithFormat:",  @"{%@*} %@",  @"AUTOJOIN, ASSOC",  +[NSString stringWithFormat:]( &OBJC_CLASS___NSString,  "stringWithFormat:",  @"Auto join association completed (%d) with current state: %@, network: %@",  a5,  v13,  sub_100095BC8(a3))),  "UTF8String"));
    if (os_log_type_enabled((os_log_t)&_os_log_default, OS_LOG_TYPE_DEFAULT))
    {
      *(_DWORD *)__int128 buf = 136446210;
      uint64_t v39 = -[NSString UTF8String]( +[NSString stringWithFormat:]( &OBJC_CLASS___NSString,  "stringWithFormat:",  @"[WiFiPolicy] %s",  -[NSString UTF8String](v14, "UTF8String")),  "UTF8String");
      _os_log_impl( (void *)&_mh_execute_header,  (os_log_t)&_os_log_default,  OS_LOG_TYPE_DEFAULT,  "%{public}s",  buf,  0xCu);
    }
  }

  objc_autoreleasePoolPop(v12);
  if (!(_DWORD)a5)
  {
    sub_1000FD4EC(a6, a3);
    if (a3)
    {
      if (sub_100096E90((uint64_t)a3) || sub_100096D08((const __CFDictionary *)a3))
      {
        *(CFAbsoluteTime *)(a6 + 712) = CFAbsoluteTimeGetCurrent();
        CFAbsoluteTime Current = CFAbsoluteTimeGetCurrent();
        *(CFAbsoluteTime *)(a6 + 960) = Current;
        CFAbsoluteTime v17 = (Current - *(double *)(a6 + 952)) * 1000.0;
        uint64_t v18 = v17;
        *(_DWORD *)__int128 buf = v17;
        unsigned int v19 = (const void *)sub_100043E8C(*(void *)(a6 + 64));
        CFNumberRef v20 = sub_1000DEA34(a6, v19, 1);
        LODWORD(v39) = 0;
        if (v20)
        {
          CFNumberRef v21 = v20;
          unsigned int v22 = (const __CFNumber *)sub_100096A74((uint64_t)v20);
          LODWORD(v23) = sub_1000992D0((uint64_t)v21);
          if (v22)
          {
            unsigned __int16 valuePtr = -21846;
            CFNumberGetValue(v22, kCFNumberSInt16Type, &valuePtr);
            LODWORD(v22) = valuePtr;
            LOWORD(v39) = valuePtr;
          }

          if ((_DWORD)v23) {
            WORD1(v39) = v23;
          }
          CFRelease(v21);
          uint64_t v23 = (unsigned __int16)v23;
        }

        else
        {
          uint64_t v23 = 0LL;
          LODWORD(v22) = 0;
        }

        CFNumberRef v31 = objc_autoreleasePoolPush();
        if (qword_100219F60) {
          objc_msgSend( (id)qword_100219F60,  "WFLog:message:",  3,  "%s: time4WayHSTaken %u ms, channel %u, band %u",  "__WiFiDeviceManagerSubmitInfraConnectionMetrics",  v18,  v22,  v23);
        }
        objc_autoreleasePoolPop(v31);
        sub_1000389BC((unsigned int *)buf);
      }

      if (sub_10009DF44((uint64_t)a3)
        && (sub_10009E054((uint64_t)a3) && (_os_feature_enabled_impl("WiFiManager", "LMTPCFor24GHzCarPlay") & 1) != 0
         || !sub_10009E054((uint64_t)a3) && _os_feature_enabled_impl("WiFiManager", "LMTPCFor5GHzCarPlay")))
      {
        CFNumberRef v32 = (const void *)sub_100043E8C(a1);
        sub_10003EC6C(a1, v32, 513LL, 0LL, (uint64_t)kCFBooleanTrue);
        BOOL v33 = objc_autoreleasePoolPush();
        if (qword_100219F60) {
          [qword_100219F60 WFLog:@"%s: Enabled LMTPC for CarPlay" message:3];
        }
        objc_autoreleasePoolPop(v33);
      }
    }
  }

  if (*(void *)(a6 + 3912))
  {
    if (*(void *)(a6 + 240))
    {
      if (a2) {
        CFRetain(a2);
      }
      if (a3) {
        CFRetain(a3);
      }
      if (a4) {
        CFRetain(a4);
      }
      CFRetain((CFTypeRef)a6);
      uint64_t v15 = *(dispatch_queue_s **)(a6 + 240);
      block[0] = _NSConcreteStackBlock;
      block[1] = 3221225472LL;
      block[2] = sub_10010F230;
      block[3] = &unk_1001E4CC8;
      void block[4] = a6;
      void block[5] = a2;
      void block[6] = a3;
      void block[7] = a4;
      int v36 = a5;
      dispatch_async(v15, block);
    }

    else
    {
      uint64_t v24 = objc_autoreleasePoolPush();
      if (qword_100219F60) {
        [qword_100219F60 WFLog:@"%s: null queue." message:4];
      }
      objc_autoreleasePoolPop(v24);
    }
  }

  if (v11 == *(void *)(a6 + 3304))
  {
    if ((_DWORD)a5)
    {
      if (*(_BYTE *)(a6 + 1192) == 1) {
        sub_1000F5F98(a6, 0x3BuLL);
      }
    }

    else
    {
      *(void *)(a6 + 1176) = sub_1000DEA34(a6, a2, 1);
    }

    CFTypeRef v28 = *(CFTypeRef *)(a6 + 1176);
    if (a3 && !v28)
    {
      CFTypeRef v28 = CFRetain(a3);
      *(void *)(a6 + 1176) = v28;
    }

    *(void *)(a6 + 1184) = a4;
    *(_DWORD *)(a6 + 116_Block_object_dispose(va, 8) = a5;
    int v29 = *(_DWORD *)(a6 + 3272);
    if (v29 == 15 || v29 == 12)
    {
      sub_1000CACC4(a6);
      CFTypeRef v28 = *(CFTypeRef *)(a6 + 1176);
    }

    CFNumberRef v30 = (_OWORD *)(a6 + 1168);
    if (v28) {
      CFRelease(v28);
    }
    double result = 0.0;
    _OWORD *v30 = 0u;
    v30[1] = 0u;
  }

  else
  {
    CFNumberRef v25 = objc_autoreleasePoolPush();
    if (qword_100219F60) {
      [qword_100219F60 WFLog:@"Ignoring old request.  CurrentCommand=%lld PendingCommand=%lld" message:3 v11 *(void *)(a6 + 3304)];
    }
    objc_autoreleasePoolPop(v25);
    if (a3)
    {
      char v26 = *(const __CFArray **)(a6 + 3520);
      if (v26)
      {
        v40.length = CFArrayGetCount(*(CFArrayRef *)(a6 + 3520));
        v40.location = 0LL;
      }
    }
  }

  return result;
}

void sub_10010F1D0(uint64_t a1, void *a2)
{
  if (a2)
  {
    [*(id *)(*(void *)(a1 + 32) + 7320) setJoinEvent:1 withReason:*(void *)(a1 + 40) lastDisconnectReason:0 lastJoinFailure:0 andNetworkDetails:a2 forInterface:sub_100043E8C(*(void *)(*(void *)(a1 + 32) + 64))];
  }

void sub_10010F230(uint64_t a1)
{
  uint64_t v2 = *(void *)(a1 + 32);
  if (*(void *)(v2 + 240))
  {
    (*(void (**)(uint64_t, void, void, void, void, void))(v2 + 3912))( v2,  *(void *)(a1 + 40),  *(void *)(a1 + 48),  *(void *)(a1 + 56),  *(unsigned int *)(a1 + 64),  *(void *)(v2 + 3920));
    uint64_t v2 = *(void *)(a1 + 32);
  }

  CFRelease((CFTypeRef)v2);
  id v3 = *(const void **)(a1 + 40);
  if (v3) {
    CFRelease(v3);
  }
  uint64_t v4 = *(const void **)(a1 + 48);
  if (v4) {
    CFRelease(v4);
  }
  CFIndex v5 = *(const void **)(a1 + 56);
  if (v5) {
    CFRelease(v5);
  }
}

void sub_10010F2A4(uint64_t a1, uint64_t a2, const void *a3, uint64_t a4, uint64_t a5)
{
  BOOL v9 = objc_autoreleasePoolPush();
  if (qword_100219F60) {
    [(id)qword_100219F60 WFLog:3, "%s: error %d reqInfo %@", "__WiFiDeviceManagerUserForcedAssociationCallback", a5, a4 message];
  }
  objc_autoreleasePoolPop(v9);
  unsigned int v10 = objc_autoreleasePoolPush();
  if (a1)
  {
    if (qword_100219F60) {
      [qword_100219F60 WFLog:@"%s: enabling device manager" message:3];
    }
    objc_autoreleasePoolPop(v10);
    sub_1000D02BC(a1);
    if (a3 && *(void *)(a1 + 6232))
    {
      if (!(_DWORD)a5)
      {
        uint64_t v11 = (const __CFString *)sub_100095BC8(a3);
        int v12 = (const __CFString *)sub_100095BC8(*(const void **)(a1 + 6232));
        if (CFStringCompare(v11, v12, 0LL) == kCFCompareEqualTo)
        {
          uint64_t v18 = objc_autoreleasePoolPush();
          if (qword_100219F60) {
            [qword_100219F60 WFLog:@"%s: finished forced association successfully" message:3];
          }
          objc_autoreleasePoolPop(v18);
          uint64_t v14 = (void *)a1;
          uint64_t v15 = (uint64_t)a3;
          uint64_t v17 = 0LL;
          goto LABEL_17;
        }
      }

      unsigned int v13 = objc_autoreleasePoolPush();
      if (qword_100219F60) {
        [qword_100219F60 WFLog:@"%s: failed forced association" message:3];
      }
      objc_autoreleasePoolPop(v13);
      uint64_t v14 = (void *)a1;
      uint64_t v15 = (uint64_t)a3;
    }

    else
    {
      BOOL v16 = objc_autoreleasePoolPush();
      if (qword_100219F60) {
        [qword_100219F60 WFLog:@"%s: network is NULL" message:3];
      }
      objc_autoreleasePoolPop(v16);
      uint64_t v14 = (void *)a1;
      uint64_t v15 = 0LL;
    }

    uint64_t v17 = 2LL;
LABEL_17:
    sub_1000ECFA0(v14, v15, v17);
    return;
  }

  if (qword_100219F60) {
    [qword_100219F60 WFLog:@"%s: manager is NULL" message:3];
  }
  objc_autoreleasePoolPop(v10);
}

void sub_10010F480(uint64_t a1, uint64_t a2)
{
  int v2 = a2;
  uint64_t v4 = (const void *)MRMediaRemoteCopyPlaybackStateDescription(a2);
  CFIndex v5 = objc_autoreleasePoolPush();
  if (qword_100219F60) {
    [(id)qword_100219F60 WFLog:3, "%s: state is %@", "__WiFiDeviceManagerNowPlayingStateDidChange_block_invoke", v4 message];
  }
  objc_autoreleasePoolPop(v5);
  if (v4) {
    CFRelease(v4);
  }
  uint64_t v6 = *(void *)(a1 + 32);
  uint64_t v7 = *(dispatch_queue_s **)(v6 + 240);
  if (v7)
  {
    block[0] = _NSConcreteStackBlock;
    block[1] = 3221225472LL;
    block[2] = sub_10010F5A4;
    block[3] = &unk_1001E43F8;
    void block[4] = v6;
    int v10 = v2;
    dispatch_async(v7, block);
  }

  else
  {
    int v8 = objc_autoreleasePoolPush();
    if (qword_100219F60) {
      [qword_100219F60 WFLog:@"%s: null queue." message:4];
    }
    objc_autoreleasePoolPop(v8);
    CFRelease(*(CFTypeRef *)(a1 + 32));
  }

void sub_10010F5A4(uint64_t a1)
{
  uint64_t v2 = *(void *)(a1 + 32);
  if (!*(void *)(v2 + 240)) {
    goto LABEL_12;
  }
  if (*(_DWORD *)(a1 + 40) == 1)
  {
    *(_BYTE *)(v2 + 3402) = 1;
    -[WiFiUserInteractionMonitor updateIsMediaPlaying:]( +[WiFiUserInteractionMonitor sharedInstance](&OBJC_CLASS___WiFiUserInteractionMonitor, "sharedInstance"),  "updateIsMediaPlaying:",  1LL);
  }

  else
  {
    *(_BYTE *)(v2 + 3402) = 0;
    -[WiFiUserInteractionMonitor updateIsMediaPlaying:]( +[WiFiUserInteractionMonitor sharedInstance](&OBJC_CLASS___WiFiUserInteractionMonitor, "sharedInstance"),  "updateIsMediaPlaying:",  0LL);
    uint64_t v3 = *(void *)(a1 + 32);
    if (*(_BYTE *)(v3 + 6616))
    {
LABEL_7:
      if (*(_BYTE *)(v3 + 433))
      {
        sub_1000F5218(v3, 3LL);
        uint64_t v3 = *(void *)(a1 + 32);
      }

      goto LABEL_9;
    }

    int v4 = _os_feature_enabled_impl("CoreWiFi", "UnifiedAutoJoin");
    uint64_t v5 = *(void *)(a1 + 32);
    if (v4) {
      sub_1000F5F98(v5, 0x1BuLL);
    }
    else {
      sub_1000D66BC(v5, 2);
    }
  }

  uint64_t v3 = *(void *)(a1 + 32);
  if (v3) {
    goto LABEL_7;
  }
LABEL_9:
  if (*(void *)(v3 + 7320))
  {
    [*(id *)(v3 + 7320) setMediaState:*(_BYTE *)(v3 + 3402) != 0];
    uint64_t v3 = *(void *)(a1 + 32);
  }

  sub_1000EB060(v3, 0LL);
  uint64_t v2 = *(void *)(a1 + 32);
LABEL_12:
  CFRelease((CFTypeRef)v2);
}

void sub_10010F69C(CFArrayRef *a1, const void *a2)
{
  if (CFArrayGetCount(a1[440]) >= 1)
  {
    CFIndex v4 = 0LL;
    do
    {
      ValueAtIndex = CFArrayGetValueAtIndex(a1[440], v4);
      if (CFEqual(a2, ValueAtIndex)) {
        goto LABEL_14;
      }
    }

    while (CFArrayGetCount(a1[440]) > ++v4);
  }

  if (CFArrayGetCount(a1[441]) >= 1)
  {
    CFIndex v6 = 0LL;
    do
    {
      ValueAtIndex = CFArrayGetValueAtIndex(a1[441], v6);
      if (CFEqual(a2, ValueAtIndex)) {
        goto LABEL_14;
      }
    }

    while (CFArrayGetCount(a1[441]) > ++v6);
  }

  if (CFArrayGetCount(a1[454]) >= 1)
  {
    CFIndex v7 = 0LL;
    while (1)
    {
      ValueAtIndex = CFArrayGetValueAtIndex(a1[454], v7);
      if (CFEqual(a2, ValueAtIndex)) {
        break;
      }
      if (CFArrayGetCount(a1[454]) <= ++v7) {
        return;
      }
    }

uint64_t sub_10010F7B4(uint64_t a1)
{
  uint64_t v2 = objc_autoreleasePoolPush();
  if (!a1)
  {
    uint64_t v11 = objc_autoreleasePoolPush();
    if (qword_100219F60) {
      [qword_100219F60 WFLog:@"%s: manager ref is null" message:3];
    }
    goto LABEL_72;
  }

  if (*(_BYTE *)(a1 + 6848) && *(void *)(a1 + 6928))
  {
    uint64_t v3 = objc_autoreleasePoolPush();
    if (qword_100219F60) {
      [qword_100219F60 WFLog:@"%s: Transition OK. Auto Hotspot Network recommendation" message:3];
    }
LABEL_29:
    objc_autoreleasePoolPop(v3);
    uint64_t v9 = 1LL;
    goto LABEL_30;
  }

  if (!*(void *)(a1 + 3520))
  {
    uint64_t v11 = objc_autoreleasePoolPush();
    if (qword_100219F60) {
      [qword_100219F60 WFLog:@"%s: no known networks" message:3];
    }
    goto LABEL_72;
  }

  if (*(_DWORD *)(a1 + 20) != 1)
  {
    uint64_t v11 = objc_autoreleasePoolPush();
    if (qword_100219F60) {
      [qword_100219F60 WFLog:@"%s: wifi is off" message:3];
    }
    goto LABEL_72;
  }

  if (!*(_BYTE *)(a1 + 3403))
  {
    uint64_t v11 = objc_autoreleasePoolPush();
    if (qword_100219F60) {
      [qword_100219F60 WFLog:@"%s: not associated" message:3];
    }
    goto LABEL_72;
  }

  if (*(_BYTE *)(a1 + 3404))
  {
    uint64_t v11 = objc_autoreleasePoolPush();
    if (qword_100219F60) {
      [qword_100219F60 WFLog:@"%s: on a moving network" message:3];
    }
    goto LABEL_72;
  }

  if (sub_1000E0348(a1) && sub_1000DF3FC(a1))
  {
    uint64_t v11 = objc_autoreleasePoolPush();
    if (qword_100219F60) {
      [qword_100219F60 WFLog:@"%s: Active Ranging Session" message:3];
    }
    goto LABEL_72;
  }

  if (*(_BYTE *)(a1 + 6616)) {
    goto LABEL_13;
  }
  if (*(_BYTE *)(a1 + 6600))
  {
    uint64_t v3 = objc_autoreleasePoolPush();
    if (qword_100219F60) {
      [qword_100219F60 WFLog:@"%s: Transition ok when its within colocated scope" message:3];
    }
    goto LABEL_29;
  }

  unsigned int v13 = (const void *)sub_10004CE2C(*(void *)(a1 + 64));
  uint64_t v14 = sub_1000DEA34(a1, v13, 1);
  uint64_t v15 = v14;
  if (v14)
  {
    CFRelease(v15);
  }

  else if (*(_BYTE *)(a1 + 3405))
  {
LABEL_39:
    BOOL v16 = objc_autoreleasePoolPush();
    if (qword_100219F60) {
      [qword_100219F60 WFLog:@"%s: network switched by user" message:3];
    }
    objc_autoreleasePoolPop(v16);
    if (v15) {
      CFRelease(v15);
    }
    goto LABEL_43;
  }

  if (*(_DWORD *)(a1 + 176) != 3)
  {
    uint64_t v11 = objc_autoreleasePoolPush();
    if (qword_100219F60) {
      [qword_100219F60 WFLog:@"__WiFiDeviceManagerIsStateSuitableForNetworkTransition: display is on"];
    }
    goto LABEL_72;
  }

void sub_10010FD10(uint64_t a1, const void *a2)
{
  CFIndex v4 = objc_autoreleasePoolPush();
  if (a1)
  {
    uint64_t v5 = *(void *)(a1 + 64);
    double v6 = (const void *)sub_100043E8C(v5);
    double v7 = sub_100040538(v5, v6);
    double v8 = objc_autoreleasePoolPush();
    uint64_t v9 = (void *)qword_100219F60;
    if (qword_100219F60)
    {
      double v10 = sub_100095BC8(a2);
      [v9 WFLog:3, "%s: topNetwork: %@, current: %@", "__WiFiDeviceManagerTransitionToNetwork", v10, sub_100095BC8(v7) message];
    }

    objc_autoreleasePoolPop(v8);
    if (v7)
    {
      if (!sub_100095BC8(v7))
      {
LABEL_67:
        CFRelease(v7);
        goto LABEL_68;
      }

      if (CFEqual(v7, a2))
      {
        uint64_t v11 = objc_autoreleasePoolPush();
        if (qword_100219F60) {
          [qword_100219F60 WFLog:@"__WiFiDeviceManagerTransitionToNetwork: no need for transition..."];
        }
        objc_autoreleasePoolPop(v11);
        *(_DWORD *)(a1 + 3384) = 6;
        goto LABEL_67;
      }

      unsigned int v13 = sub_10009BF08((uint64_t)a2);
      uint64_t v14 = v13;
      if (v13) {
        CFIndex Count = CFDictionaryGetCount(v13);
      }
      else {
        CFIndex Count = 0LL;
      }
      BOOL v16 = objc_autoreleasePoolPush();
      if (qword_100219F60) {
        [qword_100219F60 WFLog:@"__WiFiDeviceManagerTransitionToNetwork channel count %d" message:Count];
      }
      objc_autoreleasePoolPop(v16);
      if ((_DWORD)Count)
      {
        uint64_t v52 = (NSMutableArray *)&v50;
        __chkstk_darwin();
        uint64_t v18 = (const void **)((char *)&v50 - v17);
        memset((char *)&v50 - v17, 170, v19);
        CFDictionaryGetKeysAndValues(v14, 0LL, v18);
        CFMutableArrayRef Mutable = CFArrayCreateMutable(kCFAllocatorDefault, 0LL, &kCFTypeArrayCallBacks);
        if (Mutable)
        {
          char v51 = v14;
          CFNumberRef v21 = -[NSMutableArray initWithCapacity:](objc_alloc(&OBJC_CLASS___NSMutableArray), "initWithCapacity:", 2LL);
          uint64_t v22 = (Count - 1);
          if ((int)Count >= 1)
          {
            do
            {
              if (CFArrayGetCount(Mutable) > 1) {
                break;
              }
              uint64_t v23 = (const __CFDictionary *)v18[v22];
              if (v23)
              {
                CFBooleanRef Value = CFDictionaryGetValue(v23, @"CHANNEL");
                if (Value)
                {
                  CFNumberRef v25 = Value;
                  if ((-[NSMutableArray containsObject:](v21, "containsObject:", Value) & 1) == 0)
                  {
                    -[NSMutableArray addObject:](v21, "addObject:", v25);
                    CFArrayAppendValue(Mutable, v18[v22]);
                  }
                }
              }
            }

            while (v22-- >= 1);
          }

          uint64_t v14 = v51;
        }

        else
        {
          CFNumberRef v21 = 0LL;
        }
      }

      else
      {
        uint64_t v27 = sub_100096A74((uint64_t)a2);
        CFTypeRef v28 = sub_1000951FC((uint64_t)a2, @"CHANNEL_FLAGS");
        if (!v27)
        {
          CFMutableArrayRef Mutable = 0LL;
          CFNumberRef v21 = 0LL;
          goto LABEL_40;
        }

        int v29 = v28;
        CFMutableArrayRef Mutable = CFArrayCreateMutable(kCFAllocatorDefault, 0LL, &kCFTypeArrayCallBacks);
        CFNumberRef v30 = CFDictionaryCreateMutable( kCFAllocatorDefault,  0LL,  &kCFTypeDictionaryKeyCallBacks,  &kCFTypeDictionaryValueCallBacks);
        CFNumberRef v21 = 0LL;
        if (v30 && Mutable)
        {
          CFNumberRef v31 = v30;
          CFDictionaryAddValue(v30, @"CHANNEL", v27);
          if (v29) {
            CFDictionaryAddValue(v31, @"CHANNEL_FLAGS", v29);
          }
          CFNumberRef v21 = -[NSMutableArray initWithCapacity:](objc_alloc(&OBJC_CLASS___NSMutableArray), "initWithCapacity:", 1LL);
          -[NSMutableArray addObject:](v21, "addObject:", v27);
          CFArrayAppendValue(Mutable, v31);
          CFRelease(v31);
LABEL_37:
          char v32 = 0;
          if (CFArrayGetCount(Mutable)) {
            goto LABEL_42;
          }
          goto LABEL_41;
        }
      }

      if (Mutable) {
        goto LABEL_37;
      }
LABEL_40:
      char v32 = 1;
LABEL_41:
      if (!sub_10009860C((uint64_t)a2))
      {
        uint64_t v52 = v21;
        char v41 = v32;
        uint64_t v46 = objc_autoreleasePoolPush();
        if (qword_100219F60) {
          [qword_100219F60 WFLog:@"__WiFiDeviceManagerTransitionToNetwork: no mru channels found"];
        }
        goto LABEL_81;
      }

void sub_1001103EC(int a1, int a2, const __CFArray *a3, int a4, uint64_t a5, uint64_t *a6)
{
  uint64_t v8 = *a6;
  free(a6);
  if (!v8)
  {
    uint64_t v15 = objc_autoreleasePoolPush();
    BOOL v16 = (void *)qword_100219F60;
    if (!qword_100219F60) {
      goto LABEL_16;
    }
    uint64_t v17 = "%s: null manager";
    goto LABEL_15;
  }

  if ((_DWORD)a5)
  {
    uint64_t v15 = objc_autoreleasePoolPush();
    if (qword_100219F60) {
      [qword_100219F60 WFLog:@"Error in scan: %d" message:4];
    }
    goto LABEL_16;
  }

  if (!a3 || !CFArrayGetCount(a3))
  {
    uint64_t v15 = objc_autoreleasePoolPush();
    BOOL v16 = (void *)qword_100219F60;
    if (!qword_100219F60) {
      goto LABEL_16;
    }
    uint64_t v17 = "%s: no scan result";
    goto LABEL_15;
  }

  uint64_t v9 = objc_autoreleasePoolPush();
  if (qword_100219F60) {
    [qword_100219F60 WFLog:@"__WiFiDeviceManagerNetworkTransitionScanCallback found %ld networks" message:3];
  }
  objc_autoreleasePoolPop(v9);
  sub_100104644(v8, a3);
  if (CFArrayGetCount(a3) < 1)
  {
LABEL_13:
    uint64_t v15 = objc_autoreleasePoolPush();
    BOOL v16 = (void *)qword_100219F60;
    if (!qword_100219F60)
    {
LABEL_16:
      objc_autoreleasePoolPop(v15);
      return;
    }

    uint64_t v17 = "%s: did not find the top network";
LABEL_15:
    [v16 WFLog:3 message:v17 __WiFiDeviceManagerNetworkTransitionScanCallback];
    goto LABEL_16;
  }

  CFIndex v10 = 0LL;
  uint64_t v11 = (_BYTE *)(v8 + 6600);
  while (1)
  {
    ValueAtIndex = (void *)CFArrayGetValueAtIndex(a3, v10);
    if (ValueAtIndex)
    {
      unsigned int v13 = ValueAtIndex;
      uint64_t v14 = *(const void **)(v8 + 3368);
      if (v14)
      {
        if (CFEqual(v14, v13)) {
          break;
        }
      }
    }

    if (CFArrayGetCount(a3) <= ++v10) {
      goto LABEL_13;
    }
  }

  uint64_t v18 = objc_autoreleasePoolPush();
  if (qword_100219F60) {
    [(id)qword_100219F60 WFLog:3, "%s: found the top network to match scanned network %@", "__WiFiDeviceManagerNetworkTransitionScanCallback", sub_100095BC8(v13) message];
  }
  objc_autoreleasePoolPop(v18);
  if (!sub_10010F7B4(v8))
  {
    uint64_t v15 = objc_autoreleasePoolPush();
    BOOL v16 = (void *)qword_100219F60;
    if (!qword_100219F60) {
      goto LABEL_16;
    }
    uint64_t v17 = "%s: not now...";
    goto LABEL_15;
  }

  if (!*(_BYTE *)(v8 + 6616) && (uint64_t v23 = *(const void **)(v8 + 3432)) != 0LL && CFEqual(v13, v23))
  {
    uint64_t v24 = objc_autoreleasePoolPush();
    if (qword_100219F60) {
      [(id)qword_100219F60 WFLog:3, "%s: target network %@ is the same as the one user left, not transitioning.", "__WiFiDeviceManagerNetworkTransitionScanCallback", sub_100095BC8(v13) message];
    }
    objc_autoreleasePoolPop(v24);
    if (*v11)
    {
      _BYTE *v11 = 0;
      uint64_t v15 = objc_autoreleasePoolPush();
      BOOL v16 = (void *)qword_100219F60;
      if (!qword_100219F60) {
        goto LABEL_16;
      }
      uint64_t v17 = "%s:Clearing colocatedScopeTransition state";
      goto LABEL_15;
    }
  }

  else
  {
    ++*(_DWORD *)(v8 + 3384);
    *(CFAbsoluteTime *)(v8 + 3392) = CFAbsoluteTimeGetCurrent();
    sub_1000D03E4(v8);
    size_t v19 = (const void *)sub_100043E8C(*(void *)(v8 + 64));
    if (sub_1000E1104(v8, v19, v13, 0LL, 0LL, (uint64_t)sub_1001107A8, 0LL, 1013LL))
    {
      CFNumberRef v20 = objc_autoreleasePoolPush();
      if (qword_100219F60) {
        [qword_100219F60 WFLog:@"%s: Error returned by Associate Async %d" message:3];
      }
      objc_autoreleasePoolPop(v20);
      if (*v11)
      {
        _BYTE *v11 = 0;
        CFNumberRef v21 = objc_autoreleasePoolPush();
        if (qword_100219F60) {
          [qword_100219F60 WFLog:@"Clearing colocatedScopeTransition state"];
        }
        objc_autoreleasePoolPop(v21);
      }

      sub_1000D02BC(v8);
      uint64_t v22 = sub_100043E8C(*(void *)(v8 + 64));
      sub_1000EF770(v8, v22, 7LL, 0LL, v13, 0LL);
    }
  }

void sub_1001107A8(uint64_t a1, uint64_t a2, const void *a3, uint64_t a4, uint64_t a5)
{
  uint64_t v8 = objc_autoreleasePoolPush();
  if (a1)
  {
    if (qword_100219F60) {
      [(id)qword_100219F60 WFLog:3, "%s: network %@, error %d", "__WiFiDeviceManagerNetworkTransitionAssociationCallback", sub_100095BC8(a3), a5 message];
    }
    objc_autoreleasePoolPop(v8);
    *(_BYTE *)(a1 + 6600) = 0;
    uint64_t v9 = *(const void **)(a1 + 6592);
    if (v9)
    {
      CFRelease(v9);
      *(void *)(a1 + 6592) = 0LL;
    }

    sub_1000D02BC(a1);
  }

  else
  {
    if (qword_100219F60) {
      [qword_100219F60 WFLog:@"%s: manager is NULL" message:3];
    }
    objc_autoreleasePoolPop(v8);
  }

id sub_100110894(uint64_t a1, uint64_t a2, uint64_t a3)
{
  if (a1)
  {
    id v4 = [+[WiFiAnalyticsManager sharedWiFiAnalyticsManager]( WiFiAnalyticsManager,  "sharedWiFiAnalyticsManager") copyColocatedScopeIdForNetwork:a2];
    id v5 = [WiFiAnalyticsManager sharedWiFiAnalyticsManager].copyColocatedScopeIdForNetwork:a3];
    double v6 = v5;
    if (v4) {
      BOOL v7 = v5 == 0LL;
    }
    else {
      BOOL v7 = 1;
    }
    if (v7)
    {
      id v9 = 0LL;
      id v8 = 0LL;
      if (!v4)
      {
        if (!v5) {
          return v8;
        }
        goto LABEL_11;
      }
    }

    else
    {
      id v9 = [v4 isEqualToString:v5];
    }

    id v8 = v9;
    if (v6) {
LABEL_11:
    }
  }

  else
  {
    uint64_t v11 = objc_autoreleasePoolPush();
    if (qword_100219F60) {
      [qword_100219F60 WFLog:@"%s: network1 is NULL!" message:3];
    }
    objc_autoreleasePoolPop(v11);
    return 0LL;
  }

  return v8;
}

void sub_10011097C(const void *a1, uint64_t a2)
{
  uint64_t v4 = sub_1000ABA7C((uint64_t)a1);
  uint64_t v5 = sub_1000ABA84((uint64_t)a1);
  unsigned int v6 = sub_1000ABA8C((uint64_t)a1);
  BOOL v7 = objc_autoreleasePoolPush();
  id v8 = (void *)qword_100219F60;
  if (qword_100219F60)
  {
    id v9 = sub_1000BDC98(*(_DWORD *)(a2 + 3272));
    [v8 WFLog:3, "%s: state=%@ type=%d responseType=%@ inputType=%d", "__WiFiDeviceManagerNotificationCallback", v9, v4, sub_1000ABE6C(v6), v5 message];
  }

  objc_autoreleasePoolPop(v7);
  if ((_DWORD)v5 == 2
    || (!(_DWORD)v4 ? (v10 = v6 == 4) : (v10 = 0), v10 ? (char v11 = 0) : (char v11 = 1), (_DWORD)v4 == 13 || (v11 & 1) == 0))
  {
    if ((int)v4 > 1)
    {
      if ((_DWORD)v4 == 13)
      {
        sub_1000FA6E8((void *)a2, (uint64_t)a1);
      }

      else if ((_DWORD)v4 == 2)
      {
        sub_10010AD94(a2, (uint64_t)a1);
      }
    }

    else if ((_DWORD)v4)
    {
      if ((_DWORD)v4 == 1) {
        sub_10010AADC(a2, (uint64_t)a1);
      }
    }

    else
    {
      sub_10010B300(a2, (uint64_t)a1);
    }
  }

  if (*(const void **)(a2 + 224) == a1)
  {
    int v12 = *(_DWORD *)(a2 + 3272);
    if (v12 == 17 || v12 == 14)
    {
      sub_1000CACC4(a2);
    }

    else if (a1)
    {
      CFRelease(a1);
      *(void *)(a2 + 224) = 0LL;
    }
  }

  else
  {
    unsigned int v13 = objc_autoreleasePoolPush();
    if (qword_100219F60) {
      [qword_100219F60 WFLog:@"notification in callback is not pending" message:3];
    }
    objc_autoreleasePoolPop(v13);
  }

void *sub_100110B64(uint64_t a1)
{
  uint64_t v4 = 0LL;
  if (!qword_1002199E8)
  {
    __int128 v5 = off_1001E5148;
    uint64_t v6 = 0LL;
    qword_1002199E8 = _sl_dlopen(&v5, &v4);
  }

  uint64_t v2 = (void *)qword_1002199E8;
  if (!qword_1002199E8) {
    sub_100154828(&v4);
  }
  if (v4) {
    free(v4);
  }
  double result = dlsym(v2, "EAPClientConfigurationCopyAndImport");
  *(void *)(*(void *)(*(void *)(a1 + 32) + 8LL) + 24LL) = result;
  off_1002199F0 = *(_UNKNOWN **)(*(void *)(*(void *)(a1 + 32) + 8LL) + 24LL);
  return result;
}

void sub_100110C3C(uint64_t *a1, uint64_t a2, const void *a3, uint64_t a4, uint64_t a5)
{
  id v9 = objc_autoreleasePoolPush();
  if (qword_100219F60) {
    [(id)qword_100219F60 WFLog:3, "%s: error %d reqInfo %@", "__WiFiDeviceManagerUserNotificationAssociationCallback", a5, a4 message];
  }
  objc_autoreleasePoolPop(v9);
  BOOL v10 = objc_autoreleasePoolPush();
  if (a1)
  {
    if (qword_100219F60) {
      [qword_100219F60 WFLog:@"%s: enabling device manager" message:3];
    }
    objc_autoreleasePoolPop(v10);
    sub_1000D02BC((uint64_t)a1);
    if (!a3)
    {
      uint64_t v15 = objc_autoreleasePoolPush();
      if (qword_100219F60) {
        [qword_100219F60 WFLog:@"%s: network is NULL" message:3];
      }
      goto LABEL_21;
    }

    char v11 = objc_autoreleasePoolPush();
    if ((_DWORD)a5)
    {
      if (qword_100219F60) {
        [qword_100219F60 WFLog:@"%s: failed user notification association" message:3];
      }
      objc_autoreleasePoolPop(v11);
      uint64_t v12 = sub_100043E8C(a1[8]);
      sub_1000EF770((uint64_t)a1, v12, 7LL, 0LL, a3, 0LL);
      sub_10010B9B4(a1, @"userJoinAssociationFailed", a3);
      return;
    }

    if (qword_100219F60) {
      [qword_100219F60 WFLog:@"__WiFiDeviceManagerUserNotificationAssociationCallback: finished user notification association successfully"];
    }
    objc_autoreleasePoolPop(v11);
    sub_10010B9B4(a1, @"userJoinSuccess", a3);
    if (a1[572])
    {
      if (a1[30])
      {
        uint64_t v17 = 0LL;
        uint64_t v18 = &v17;
        uint64_t v19 = 0x2020000000LL;
        uint64_t v20 = 0LL;
        unsigned int v13 = sub_100094E60((uint64_t)kCFAllocatorDefault, (uint64_t)a3);
        v18[3] = (uint64_t)v13;
        if (v13)
        {
          CFRetain(a1);
          uint64_t v14 = (dispatch_queue_s *)a1[30];
          block[0] = _NSConcreteStackBlock;
          block[1] = 3221225472LL;
          block[2] = sub_100110F84;
          block[3] = &unk_1001E2D48;
          void block[4] = &v17;
          void block[5] = a1;
          dispatch_async(v14, block);
        }

        _Block_object_dispose(&v17, 8);
        return;
      }

      uint64_t v15 = objc_autoreleasePoolPush();
      if (qword_100219F60) {
        [qword_100219F60 WFLog:@"%s: null queue." message:4];
      }
LABEL_21:
      objc_autoreleasePoolPop(v15);
    }
  }

  else
  {
    if (qword_100219F60) {
      [qword_100219F60 WFLog:@"%s: manager is NULL" message:3];
    }
    objc_autoreleasePoolPop(v10);
  }

void sub_100110EE0( _Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, ...)
{
}

uint64_t sub_100110EF8(uint64_t a1, uint64_t a2)
{
  if ((_DWORD)a2 == 5) {
    return 3LL;
  }
  uint64_t v2 = a2;
  if ((_DWORD)a2 != 1)
  {
    if ((_DWORD)a2)
    {
      uint64_t v3 = objc_autoreleasePoolPush();
      if (qword_100219F60) {
        [qword_100219F60 WFLog:@"%s: Unexpected response type: %u" message:4];
      }
      objc_autoreleasePoolPop(v3);
      return 0LL;
    }

    else
    {
      return 2LL;
    }
  }

  return v2;
}

void sub_100110F84(uint64_t a1)
{
  uint64_t v2 = *(void **)(a1 + 40);
  if (v2[30])
  {
    uint64_t v3 = objc_autoreleasePoolPush();
    if (qword_100219F60) {
      [(id)qword_100219F60 WFLog:4, "%s: Adding network '%@' to known network list", "__WiFiDeviceManagerUserNotificationAssociationCallback_block_invoke", sub_100095BC8(*(const void **)(*(void *)(*(void *)(a1 + 32) + 8) + 24)) message];
    }
    objc_autoreleasePoolPop(v3);
    uint64_t v5 = *(void *)(a1 + 32);
    uint64_t v4 = *(void *)(a1 + 40);
    uint64_t v6 = (CFTypeRef *)(a1 + 32);
    (*(void (**)(uint64_t, void, void))(v4 + 4576))( v4,  *(void *)(*(void *)(v5 + 8) + 24LL),  *(void *)(v4 + 4584));
    CFRelease(v6[1]);
    BOOL v7 = *v6;
  }

  else
  {
    CFRelease(v2);
    id v8 = *(void **)(a1 + 32);
    uint64_t v6 = (CFTypeRef *)(a1 + 32);
    BOOL v7 = v8;
  }

  id v9 = *(const void **)(v7[1] + 24LL);
  if (v9)
  {
    CFRelease(v9);
    *(void *)(*((void *)*v6 + 1) + 24LL) = 0LL;
  }

void sub_100111058(uint64_t a1)
{
  uint64_t v2 = objc_autoreleasePoolPush();
  if (a1)
  {
    if (qword_100219F60) {
      [(id)qword_100219F60 WFLog:3 message:"DPS Probe: Cancelling probe on all ACs"];
    }
    objc_autoreleasePoolPop(v2);
    uint64_t v3 = 0LL;
    uint64_t v4 = a1 + 7136;
    do
    {
      uint64_t v5 = *(const void **)(v4 + v3);
      if (v5)
      {
        sub_10001BA7C(*(void *)(a1 + 120), v5);
        uint64_t v6 = *(const void **)(v4 + v3);
        if (v6)
        {
          CFRelease(v6);
          *(void *)(v4 + v3) = 0LL;
        }
      }

      v3 += 8LL;
    }

    while (v3 != 32);
    *(_BYTE *)(a1 + 718_Block_object_dispose(va, 8) = 0;
  }

  else
  {
    if (qword_100219F60) {
      [qword_100219F60 WFLog:@"%s: manager is NULL !" message:4];
    }
    objc_autoreleasePoolPop(v2);
  }

void sub_100111130(uint64_t a1, uint64_t a2)
{
  uint64_t v26 = 0LL;
  if (!a2)
  {
    uint64_t v20 = objc_autoreleasePoolPush();
    if (qword_100219F60) {
      [qword_100219F60 WFLog:@"%s: manager is NULL !" message:4];
    }
    objc_autoreleasePoolPop(v20);
    return;
  }

  unint64_t v27 = 0xAAAAAAAAAAAAAAAALL;
  uint64_t valuePtr = 1LL;
  CFNumberRef v4 = CFNumberCreate(0LL, kCFNumberCFIndexType, &valuePtr);
  if (!v4)
  {
    CFNumberRef v21 = objc_autoreleasePoolPush();
    if (qword_100219F60) {
      [qword_100219F60 WFLog:@"%s: numProbesRef is NULL !" message:4];
    }
    objc_autoreleasePoolPop(v21);
    return;
  }

  CFNumberRef v5 = v4;
  CFMutableArrayRef Mutable = CFArrayCreateMutable(kCFAllocatorDefault, 0LL, &kCFTypeArrayCallBacks);
  if (!Mutable)
  {
    uint64_t v22 = objc_autoreleasePoolPush();
    if (qword_100219F60) {
      [qword_100219F60 WFLog:@"%s: probeSizeArrRef is NULL !" message:4];
    }
    objc_autoreleasePoolPop(v22);
    uint64_t v23 = v5;
    goto LABEL_41;
  }

  BOOL v7 = Mutable;
  uint64_t v28 = 1300LL;
  CFNumberRef v8 = CFNumberCreate(0LL, kCFNumberCFIndexType, &v28);
  if (!v8)
  {
    uint64_t v24 = objc_autoreleasePoolPush();
    if (qword_100219F60) {
      [qword_100219F60 WFLog:@"%s: probeSizeRef is NULL !" message:4];
    }
    goto LABEL_32;
  }

  CFNumberRef v9 = v8;
  CFArrayAppendValue(v7, v8);
  CFRelease(v9);
  unint64_t v27 = 1LL;
  CFNumberRef v10 = CFNumberCreate(0LL, kCFNumberCFIndexType, &v27);
  if (!v10)
  {
    uint64_t v24 = objc_autoreleasePoolPush();
    if (qword_100219F60) {
      [qword_100219F60 WFLog:@"%s: probeTimeoutSecsRef is NULL !" message:4];
    }
LABEL_32:
    objc_autoreleasePoolPop(v24);
    CFRelease(v5);
    uint64_t v23 = v7;
LABEL_41:
    CFRelease(v23);
    return;
  }

  CFNumberRef v11 = v10;
  uint64_t v12 = CFDictionaryCreateMutable(0LL, 0LL, &kCFTypeDictionaryKeyCallBacks, &kCFTypeDictionaryValueCallBacks);
  unsigned int v13 = v12;
  if (v12)
  {
    CFDictionarySetValue(v12, @"kWiFiLqaMgrNumProbes", v5);
    CFDictionarySetValue(v13, @"kWiFiLqaMgrProbeSize", v7);
    CFDictionarySetValue(v13, @"kWiFiLqaMgrProbeTimeoutSecs", v11);
    switch((int)a1)
    {
      case 0:
        uint64_t v26 = 0LL;
        uint64_t v14 = sub_100111578;
        break;
      case 1:
        uint64_t v26 = 200LL;
        uint64_t v14 = sub_10011158C;
        break;
      case 2:
        uint64_t v26 = 700LL;
        uint64_t v14 = sub_1001115A0;
        break;
      case 3:
        uint64_t v26 = 800LL;
        uint64_t v14 = sub_1001115B4;
        break;
      default:
        goto LABEL_36;
    }

    CFNumberRef v15 = CFNumberCreate(0LL, kCFNumberCFIndexType, &v26);
    if (v15) {
      CFDictionarySetValue(v13, @"kWiFiLqaMgrProbeTrafficClass", v15);
    }
    BOOL v16 = CFDictionaryCreateMutable(0LL, 0LL, &kCFTypeDictionaryKeyCallBacks, &kCFTypeDictionaryValueCallBacks);
    uint64_t v17 = a2 + 8LL * a1;
    *(void *)(v17 + 7136) = v16;
    if (sub_1000157E8(*(void *)(a2 + 120), v13, v16, (uint64_t)v14, a2))
    {
      uint64_t v18 = (CFTypeRef *)(v17 + 7136);
      uint64_t v19 = objc_autoreleasePoolPush();
      if (qword_100219F60) {
        [qword_100219F60 WFLog:@"__WiFiDeviceManagerTriggerDpsACProbe failed to enqueue DPS probe for ac:%d" message:4 "%s: failed to enqueue DPS probe for ac:%d" "__WiFiDeviceManagerTriggerDpsACProbe" a1 v26];
      }
      objc_autoreleasePoolPop(v19);
      if (*v18)
      {
        CFRelease(*v18);
        CFTypeRef *v18 = 0LL;
      }
    }
  }

  else
  {
    CFNumberRef v25 = objc_autoreleasePoolPush();
    if (qword_100219F60) {
      [qword_100219F60 WFLog:@"%s: probeOptions is NULL !" message:4];
    }
    objc_autoreleasePoolPop(v25);
LABEL_36:
    CFNumberRef v15 = 0LL;
  }

  CFRelease(v5);
  CFRelease(v11);
  if (v13) {
    CFRelease(v13);
  }
  CFRelease(v7);
  if (v15)
  {
    uint64_t v23 = v15;
    goto LABEL_41;
  }

void sub_100111578(int a1, CFArrayRef theArray, uint64_t a3, uint64_t a4)
{
}

void sub_10011158C(int a1, CFArrayRef theArray, uint64_t a3, uint64_t a4)
{
}

void sub_1001115A0(int a1, CFArrayRef theArray, uint64_t a3, uint64_t a4)
{
}

void sub_1001115B4(int a1, CFArrayRef theArray, uint64_t a3, uint64_t a4)
{
}

void sub_1001115C8(CFArrayRef theArray, uint64_t a2, uint64_t a3, uint64_t a4)
{
  unint64_t v25 = 0xAAAAAAAAAAAAAAAALL;
  int64_t valuePtr = 0xAAAAAAAAAAAAAAAALL;
  if (a2)
  {
    BOOL v7 = objc_autoreleasePoolPush();
    if (qword_100219F60) {
      [qword_100219F60 WFLog:@"%s: diagnostic probe failed with error %ld" message:4, "__WiFiDeviceManagerUpdateProbeResults", a2];
    }
LABEL_14:
    objc_autoreleasePoolPop(v7);
    goto LABEL_15;
  }

  if (!theArray || !CFArrayGetCount(theArray))
  {
    BOOL v7 = objc_autoreleasePoolPush();
    if (qword_100219F60) {
      [qword_100219F60 WFLog:@"%s: empty DPS probe results." message:4];
    }
    goto LABEL_14;
  }

  ValueAtIndex = (const __CFDictionary *)CFArrayGetValueAtIndex(theArray, 0LL);
  unint64_t v25 = 0LL;
  int64_t valuePtr = 0LL;
  CFBooleanRef Value = (const __CFNumber *)CFDictionaryGetValue(ValueAtIndex, @"kWiFiLqaMgrNumProbesSent");
  if (Value) {
    CFNumberGetValue(Value, kCFNumberCFIndexType, &valuePtr);
  }
  CFNumberRef v11 = (const __CFNumber *)CFDictionaryGetValue(ValueAtIndex, @"kWiFiLqaMgrNumProbesFail");
  if (v11) {
    CFNumberGetValue(v11, kCFNumberCFIndexType, &v25);
  }
  if (valuePtr)
  {
    BOOL v12 = (uint64_t)(100 * v25) / valuePtr == 0;
    goto LABEL_16;
  }

uint64_t sub_100111848(_BYTE *a1)
{
  if (a1)
  {
    if (a1[3400]) {
      uint64_t v1 = (8LL * (a1[5488] != 0)) | 4;
    }
    else {
      uint64_t v1 = 8LL * (a1[5488] != 0);
    }
    uint64_t v2 = v1 | (a1[5489] != 0);
    if (a1[3402]) {
      v2 |= 0x10uLL;
    }
    if (a1[3401]) {
      v2 |= 2uLL;
    }
    if (a1[5490]) {
      v2 |= 0x20uLL;
    }
    if (a1[5491]) {
      return v2 | 0x40;
    }
    else {
      return v2;
    }
  }

  else
  {
    CFNumberRef v4 = objc_autoreleasePoolPush();
    if (qword_100219F60) {
      [qword_100219F60 WFLog:@"%s: CATS Invalid arguments\n" message:4];
    }
    objc_autoreleasePoolPop(v4);
    return 0LL;
  }

void sub_10011192C(uint64_t a1)
{
  int v95 = -1431655766;
  unint64_t v94 = 0xAAAAAAAAAAAAAAAALL;
  pthread_mutex_lock(&stru_100218F48);
  if (*(void *)(*(void *)(a1 + 72) + 240LL))
  {
    IOPMAssertionID v84 = sub_100096968(*(const __CFArray **)(*(void *)(*(void *)(a1 + 56) + 8LL) + 24LL));
    uint64_t v79 = a1;
    id v2 = [WiFiAnalyticsManager sharedWiFiAnalyticsManager].copyGeoTagsForNetworkAtLocation:*(void *)(*(void *)(*(void *)(a1 + 56) + 8) + 24) location:*(void *)(a1 + 40);
    __int128 v90 = 0u;
    __int128 v91 = 0u;
    __int128 v92 = 0u;
    __int128 v93 = 0u;
    obCFIndex j = v2;
    id v3 = [v2 countByEnumeratingWithState:&v90 objects:v97 count:16];
    if (v3)
    {
      id v4 = v3;
      uint64_t v82 = *(void *)v91;
      uint64_t v5 = WADeviceAnalyticsGeoTagInfo[0];
      uint64_t v7 = WADeviceAnalyticsGeoTagInfo[4];
      uint64_t v6 = WADeviceAnalyticsGeoTagInfo[5];
      uint64_t v8 = WADeviceAnalyticsGeoTagInfo[3];
      double v9 = 0.0;
      double v10 = 1.79769313e308;
      double v11 = 0.0;
LABEL_4:
      uint64_t v12 = 0LL;
      while (1)
      {
        if (*(void *)v91 != v82) {
          objc_enumerationMutation(obj);
        }
        unsigned int v13 = *(void **)(*((void *)&v90 + 1) + 8 * v12);
        id v14 = [v13 objectForKey:v5];
        id v15 = [v13 objectForKey:v6];
        id v16 = [v13 objectForKey:v8];
        id v17 = [v13 objectForKey:v7];
        if (!v84) {
          break;
        }
        double v18 = v17;
        if (objc_msgSend(v14, "isEqualToString:"))
        {
          [v15 doubleValue];
          if (v19 < v10)
          {
            [v15 doubleValue];
            double v10 = v20;
            [v16 doubleValue];
            double v11 = v21;
            [v18 doubleValue];
            double v9 = v22;
          }
        }

        if (v4 == (id)++v12)
        {
          id v4 = [obj countByEnumeratingWithState:&v90 objects:v97 count:16];
          if (v4) {
            goto LABEL_4;
          }
          goto LABEL_15;
        }
      }
    }

    double v9 = 0.0;
    double v11 = 0.0;
LABEL_15:

    uint64_t v23 = v79;
    id v24 = [WiFiAnalyticsManager sharedWiFiAnalyticsManager].copyNetworksAvailableAtLocation:*(void *)(v79 + 40)];
    id v25 = [WiFiAnalyticsManager sharedWiFiAnalyticsManager] copyPreferenceScoreDictionaryForNetwork:*(void *)(*(void *)(*(void *)(v79 + 56) + 8) + 24)];
    id v83 = [v24 count];
    id obja = objc_msgSend( objc_msgSend(v25, "objectForKey:", WADeviceAnalyticsNetworkPreferenceScoreInfo[2]),  "unsignedIntegerValue");
    id v78 = objc_msgSend( objc_msgSend(v25, "objectForKey:", WADeviceAnalyticsNetworkPreferenceScoreInfo[3]),  "unsignedIntegerValue");
    id v26 = objc_msgSend( objc_msgSend(v25, "objectForKey:", WADeviceAnalyticsNetworkPreferenceScoreInfo[7]),  "integerValue");
    unsigned int v77 = objc_msgSend( objc_msgSend(v25, "objectForKey:", WADeviceAnalyticsNetworkPreferenceScoreInfo[0]),  "BOOLValue");
    unsigned int v76 = objc_msgSend( objc_msgSend(v25, "objectForKey:", WADeviceAnalyticsNetworkPreferenceScoreInfo[1]),  "BOOLValue");

    unint64_t v27 = (void *)sub_1000951FC(*(void *)(*(void *)(*(void *)(v79 + 56) + 8LL) + 24LL), @"AP_MODE");
    uint64_t v28 = (void *)sub_100096A74(*(void *)(*(void *)(*(void *)(v79 + 56) + 8LL) + 24LL));
    int v29 = (void *)sub_1000951FC(*(void *)(*(void *)(*(void *)(v79 + 56) + 8LL) + 24LL), @"CHANNEL_FLAGS");
    CFNumberRef v30 = (void *)sub_1000951FC(*(void *)(*(void *)(*(void *)(v79 + 56) + 8LL) + 24LL), @"RSSI");
    id v31 = [v27 integerValue];
    char v32 = sub_10009A3DC(*(void *)(*(void *)(*(void *)(v79 + 56) + 8LL) + 24LL));
    id v33 = [v28 integerValue];
    id v34 = [v29 integerValue];
    uint64_t v35 = sub_10009A3FC(*(void *)(*(void *)(*(void *)(v79 + 56) + 8LL) + 24LL));
    id v36 = [v30 integerValue];
    LOBYTE(v75) = sub_10009C030(*(const void **)(*(void *)(*(void *)(v79 + 56) + 8LL) + 24LL), v84) != 0;
    id v37 = +[WiFiUsageBssDetails bssWithIdentifier:apProfile:apMode:phyMode:channel:channelFlags:channelWidth:rssi:latitude:longitude:isEdgeBss:]( &OBJC_CLASS___WiFiUsageBssDetails,  "bssWithIdentifier:apProfile:apMode:phyMode:channel:channelFlags:channelWidth:rssi:latitude:longitude:isEdgeBss:",  v84,  0LL,  v31,  v32,  v33,  v34,  v11,  v9,  v35,  v36,  v75);
    objc_msgSend( v37,  "setHasAppleIE:",  sub_1000951FC(*(void *)(*(void *)(*(void *)(v79 + 56) + 8) + 24), @"APPLE_IE") != 0);
    objc_msgSend( v37,  "setHasDomainName:",  sub_1000951FC(*(void *)(*(void *)(*(void *)(v79 + 56) + 8) + 24), @"DomainName") != 0);
    objc_msgSend( v37,  "setHasNaiRealms:",  sub_1000951FC(*(void *)(*(void *)(*(void *)(v79 + 56) + 8) + 24), @"NaiRealmName") != 0);
    objc_msgSend( v37,  "setHasRoamingOis:",  sub_1000951FC(*(void *)(*(void *)(*(void *)(v79 + 56) + 8) + 24), @"RoamingConsortiumOIs") != 0);
    uint64_t v38 = (void *)sub_1000951FC( *(void *)(*(void *)(*(void *)(v79 + 56) + 8LL) + 24LL),  @"11U_INTERWORKING_IE");
    if (v38)
    {
      uint64_t v39 = v38;
      [v37 setHasInterworkingIE:1];
      id v40 = [v39 objectForKey:@"INTERWORKING_ACCESS_NETWORK_TYPE"];
      id v41 = [v39 objectForKey:@"INTERWORKING_ACCESS_VENTURE_GRP"];
      id v42 = [v39 objectForKey:@"INTERWORKING_ACCESS_VENTURE_TYPE"];
      if (v40) {
        objc_msgSend(v37, "setNetworkAccessCode:", objc_msgSend(v40, "integerValue"));
      }
      if (v41) {
        [v37 setVenueGroup:[v41 integerValue]];
      }
      uint64_t v23 = v79;
      if (v42) {
        [v37 setVenueCode:[v42 integerValue]];
      }
    }

    if (sub_1000951FC(*(void *)(*(void *)(*(void *)(v23 + 56) + 8LL) + 24LL), @"WPS_PROB_RESP_IE")
      || sub_1000951FC(*(void *)(*(void *)(*(void *)(v23 + 56) + 8LL) + 24LL), @"WPS_BEACON_IE"))
    {
      [v37 setHasWpsIE:1];
      [v37 setModelName:sub_1000A4008(*(const __CFDictionary **)(*(void *)(*(void *)(v23 + 56) + 8) + 24))];
      [v37 setModelNumber:sub_1000A4060(*(const __CFDictionary **)(*(void *)(*(void *)(v23 + 56) + 8) + 24))];
      [v37 setManufacturerName:sub_1000A3FB0(*(const __CFDictionary **)(*(void *)(*(void *)(v23 + 56) + 8) + 24))];
      [v37 setDeviceVersion:sub_1000A40B8(*(void *)(*(void *)(*(void *)(v23 + 56) + 8) + 24))];
    }

    id v43 = [[WiFiUsageNetworkDetails alloc] initWithNetworkName:sub_100095BC8(*(const void **)(*(void *)(*(void *)(v23 + 56) + 8) + 24))];
    [v43 setConnectedBss:v37];
    [v43 setColocatedNetworkCount:v83];
    [v43 setSwitchedAwayCount:obja];
    [v43 setSwitchedToCount:v78];
    [v43 setNetworkScore:v26];
    [v43 setIsKnown:sub_10009A16C(*(void *)(*(void *)(*(void *)(v23 + 56) + 8) + 24))];
    [v43 setIsOpen:sub_100098EA8(*(void *)(*(void *)(*(void *)(v23 + 56) + 8) + 24)) == 0];
    [v43 setCaptiveStatus:sub_100097480(*(void *)(*(void *)(*(void *)(v23 + 56) + 8) + 24))];
    objc_msgSend( v43,  "setIsPublic:",  sub_1000951FC(*(void *)(*(void *)(*(void *)(v23 + 56) + 8) + 24), @"WiFiNetworkAttributeIsPublic") == kCFBooleanTrue);
    [v43 setIsHome:sub_100096670(*(void *)(*(void *)(*(void *)(v23 + 56) + 8) + 24)) == 1];
    [v43 setIsWork:sub_10009F9B8(*(void *)(*(void *)(*(void *)(v23 + 56) + 8) + 24)) == 1];
    [v43 setIsInternal:sub_1000A0010(*(const void **)(*(void *)(*(void *)(v23 + 56) + 8) + 24))];
    [v43 setIsManaged:sub_10009860C(*(void *)(*(void *)(*(void *)(v23 + 56) + 8) + 24))];
    [v43 setIsCarrierBased:sub_10009EE28(*(void *)(*(void *)(*(void *)(v23 + 56) + 8) + 24)) == 2];
    [v43 setIsCarPlay:sub_10009DF44(*(void *)(*(void *)(*(void *)(v23 + 56) + 8) + 24)) != 0];
    BOOL v44 = sub_10009EE28(*(void *)(*(void *)(*(void *)(v23 + 56) + 8LL) + 24LL)) == 1
       || sub_10009EE28(*(void *)(*(void *)(*(void *)(v23 + 56) + 8LL) + 24LL)) == 6;
    [v43 setIsAppBased:v44];
    [v43 setIsWalletBased:sub_10009EE28(*(void *)(*(void *)(*(void *)(v23 + 56) + 8) + 24)) == 3];
    [v43 setIsPersonalHotspot:sub_100097700(*(void *)(*(void *)(*(void *)(v23 + 56) + 8) + 24)) != 0];
    objc_msgSend( v43,  "setIsInstantHotspot:",  sub_1000951FC(*(void *)(*(void *)(*(void *)(v23 + 56) + 8) + 24), @"WiFiInstantHotspotJoining") == kCFBooleanTrue);
    objc_msgSend( v43,  "setIsAutoHotspot:",  sub_1000951FC( *(void *)(*(void *)(*(void *)(v23 + 56) + 8) + 24),  @"WiFiAutoInstantHotspotJoining") == kCFBooleanTrue);
    [v43 setIsMoving:v77];
    [v43 setIsWidelyDeployed:v76];
    [v43 setIsAutoJoined:sub_1000951FC(*(void *)(*(void *)(*(void *)(v23 + 56) + 8) + 24), @"WiFiNetworkIsAutoJoined") == kCFBooleanTrue];
    [v43 setIsAdhoc:sub_1000971AC(*(void *)(*(void *)(*(void *)(v23 + 56) + 8) + 24)) != 0];
    [v43 setIsHidden:sub_1000971F8(*(const void **)(*(void *)(*(void *)(v23 + 56) + 8) + 24)) != 0];
    [v43 setIsPasspoint:sub_100095318(*(void *)(*(void *)(*(void *)(v23 + 56) + 8) + 24))];
    [v43 setIsMetered:sub_10009E5AC(*(void *)(*(void *)(*(void *)(v23 + 56) + 8) + 24))];
    [v43 setHasWapi:sub_100098380(*(void *)(*(void *)(*(void *)(v23 + 56) + 8) + 24))];
    BOOL v48 = sub_100097F2C(*(void *)(*(void *)(*(void *)(v23 + 56) + 8LL) + 24LL))
       && !sub_1000951FC(*(void *)(*(void *)(*(void *)(v23 + 56) + 8LL) + 24LL), @"RSN_IE")
       || sub_1000957F4(*(void *)(*(void *)(*(void *)(v23 + 56) + 8LL) + 24LL));
    [v43 setHasWeakSecurity:v48];
    [v43 setHasWpa3:sub_100096D08(*(const __CFDictionary **)(*(void *)(*(void *)(v23 + 56) + 8) + 24)) != 0];
    [v43 setHasWep:sub_1000957F4(*(void *)(*(void *)(*(void *)(v23 + 56) + 8) + 24))];
    [v43 setHasEnterpriseSecurity:sub_100095B4C(*(void *)(*(void *)(*(void *)(v23 + 56) + 8) + 24))];
    [v43 setHasNoMap:sub_1000972F0(*(const void **)(*(void *)(*(void *)(v23 + 56) + 8) + 24))];
    [v43 setHasAmbiguousSsid:sub_1000972B8(*(void *)(*(void *)(*(void *)(v23 + 56) + 8) + 24))];
    [v43 setHasCustomNetworkSettings:*(unsigned __int8 *)(v23 + 96)];
    [v43 setRequiresUsername:sub_100098D64(*(void *)(*(void *)(*(void *)(v23 + 56) + 8) + 24))];
    [v43 setRequiresPassword:sub_100098BF8(*(void *)(*(void *)(*(void *)(v23 + 56) + 8) + 24))];
    [v43 setRequiresIdentity:sub_100098CC0(*(void *)(*(void *)(*(void *)(v23 + 56) + 8) + 24)) != 0];
    [v43 setRequiresOtp:sub_100098E6C(*(const void **)(*(void *)(*(void *)(v23 + 56) + 8) + 24)) != 0];
    [v43 setCanExposeImsi:sub_10009F0DC(*(const void **)(*(void *)(*(void *)(v23 + 56) + 8) + 24)) != 0];
    [v43 setUsageRank:sub_10009F85C(*(void *)(*(void *)(*(void *)(v23 + 56) + 8) + 24))];
    uint64_t v49 = (void *)sub_1000951FC( *(void *)(*(void *)(*(void *)(v23 + 56) + 8LL) + 24LL),  @"WiFiManagerKnownNetworksEventType");
    if (v49)
    {
      uint64_t v50 = v49;
      [v43 setAddedFromUI:([v49 integerValue] == 1)];
      [v43 setAddedFromApp:[v50 integerValue] == 8];
      objc_msgSend(v43, "setAddedViaSync:", objc_msgSend(v50, "integerValue") == (id)3);
      [v43 setAddedViaATJ:([v50 integerValue] == 6)];
      [v43 setAddedViaRecommendation:[v50 integerValue] == 14];
      objc_msgSend(v43, "setAddedViaSharing:", objc_msgSend(v50, "integerValue") == (id)11);
    }

    char v51 = (void *)sub_1000951FC( *(void *)(*(void *)(*(void *)(v23 + 56) + 8LL) + 24LL),  @"lastTputMeasurementResults");
    __int128 v86 = 0u;
    __int128 v87 = 0u;
    __int128 v88 = 0u;
    __int128 v89 = 0u;
    id v52 = [v51 countByEnumeratingWithState:&v86 objects:v96 count:16];
    if (v52)
    {
      id v53 = v52;
      uint64_t v54 = *(void *)v87;
      do
      {
        for (CFIndex i = 0LL; i != v53; CFIndex i = (char *)i + 1)
        {
          if (*(void *)v87 != v54) {
            objc_enumerationMutation(v51);
          }
          [*(id *)(*((void *)&v86 + 1) + 8 * (void)i) doubleValue];
          objc_msgSend(v43, "addDownloadSpeed:");
        }

        id v53 = [v51 countByEnumeratingWithState:&v86 objects:v96 count:16];
      }

      while (v53);
    }

    BOOL v56 = !sub_10009A128(*(void *)(*(void *)(*(void *)(v23 + 56) + 8LL) + 24LL))
       && sub_10009F05C(*(void *)(*(void *)(*(void *)(v23 + 56) + 8LL) + 24LL)) == 0LL;
    [v43 setAutoJoinDisabled:v56];
    [v43 setAutoLoginDisabled:sub_10009EBF8(*(void *)(*(void *)(*(void *)(v23 + 56) + 8) + 24))];
    [v43 setLowDataModeEnabled:sub_10009E640(*(void *)(*(void *)(*(void *)(v23 + 56) + 8) + 24)) != 0];
    BOOL v57 = !sub_10009A128(*(void *)(*(void *)(*(void *)(v23 + 56) + 8LL) + 24LL))
       && sub_10009F05C(*(void *)(*(void *)(*(void *)(v23 + 56) + 8LL) + 24LL)) != 0LL;
    [v43 setControlCenterDisabled:v57];
    [v43 setPrivateRelayEnabled:sub_1000A1C1C(*(void *)(*(void *)(*(void *)(v23 + 56) + 8) + 24))];
    [v43 setPrivateRelayBlockedReason:sub_1000A1CC4(*(void *)(*(void *)(*(void *)(v23 + 56) + 8) + 24))];
    int v85 = 0;
    CFRange v58 = (void *)sub_1000951FC(*(void *)(*(void *)(*(void *)(v23 + 56) + 8LL) + 24LL), @"80211D_IE");
    if (v58)
    {
      id v59 = [v58 objectForKey:@"IE_KEY_80211D_COUNTRY_CODE"];
      if (v59)
      {
        [v59 getBytes:&v85 maxLength:4 usedLength:0 encoding:4 options:0 range:0 remainingRange:[v59 length]];
        [v43 setAdvertisedCountryCode:v85];
      }
    }

    if (*(_DWORD *)(v23 + 88)) {
      [v43 setAppliedCountryCode:];
    }
    [v43 setBssEnvironment:sub_10003B2EC(*(_DWORD *)(v23 + 92))];
    [v43 setLocaleSource:*(void *)(v23 + 80)];
    [v43 setLastJoinDate:sub_10009A1FC(*(const void **)(*(void *)(*(void *)(v23 + 56) + 8) + 24))];
    uint64_t v60 = *(void *)(*(void *)(*(void *)(v23 + 64) + 8LL) + 24LL);
    if (v60)
    {
      sub_100037928(v60, (uint64_t)&v94);
      uint64_t v61 = HIDWORD(v94) > 2 ? @"UnknownAddr" : off_1001E57E0[SHIDWORD(v94)];
      [v43 setPrivateMacType:v61];
      [v43 setPrivateMacFeatureToggled:v95 == 1];
      [v43 setPrivateMacUnderClassification:BYTE1(v95) == 1];
      [v43 setPrivateMacDisabledByProfile:BYTE2(v95) == 1];
      CFRange v62 = *(const void **)(*(void *)(*(void *)(v23 + 64) + 8LL) + 24LL);
      if (v62)
      {
        CFRelease(v62);
        *(void *)(*(void *)(*(void *)(v23 + 64) + 8LL) + 24LL) = 0LL;
      }
    }

    [v43 setIsAtPrimaryHMHome:*(unsigned __int8 *)(v23 + 97)];
    [v43 setIsAtNonPrimaryHMHome:*(unsigned __int8 *)(v23 + 98)];
    id v63 = [+[WiFiAnalyticsManager sharedWiFiAnalyticsManager]( WiFiAnalyticsManager,  "sharedWiFiAnalyticsManager") copyColocatedScopeIdForNetwork:*(void *)(*(void *)(*(void *)(v23 + 56) + 8) + 24)];
    if (v63)
    {
      CFRange v64 = v63;
      id v65 = [+[WiFiAnalyticsManager sharedWiFiAnalyticsManager]( WiFiAnalyticsManager,  "sharedWiFiAnalyticsManager") copyAllStoredNetworkSsidsWithColocatedScopeId:v63];
      if (v65)
      {
        CFRange v66 = v65;
        if ((unint64_t)[v65 count] >= 2
          && [v66 containsObject:sub_100095BC8(*(const void **)(*(void *)(*(void *)(v23 + 56) + 8) + 24))])
        {
          __int128 v67 = (char *)[v66 count] - 1;
        }

        else
        {
          __int128 v67 = 0LL;
        }
      }

      else
      {
        __int128 v67 = 0LL;
      }
    }

    else
    {
      __int128 v67 = 0LL;
    }

    [v43 setColocatedScopeCount:v67];
    __int128 v68 = (void *)sub_1000951FC( *(void *)(*(void *)(*(void *)(v23 + 56) + 8LL) + 24LL),  CWFCoreWiFiSpecificAttributesKey);
    if (v68)
    {
      __int128 v69 = v68;
      uint64_t v70 = CWFNetworkProfilePropertyDisable6EModeKey;
      if ([v68 objectForKeyedSubscript:CWFNetworkProfilePropertyDisable6EModeKey])
      {
        id v71 = objc_msgSend(objc_msgSend(v69, "objectForKeyedSubscript:", v70), "integerValue");
        if (v71 == (id)2)
        {
          CFRange v72 = @"off";
          goto LABEL_84;
        }

        if (v71 == (id)1)
        {
          CFRange v72 = @"auto";
          goto LABEL_84;
        }

        if (!v71)
        {
          CFRange v72 = @"none";
LABEL_84:
          CFComparisonResult v73 = v43;
          goto LABEL_85;
        }
      }
    }

    CFComparisonResult v73 = v43;
    CFRange v72 = 0LL;
LABEL_85:
    [v73 setDisable6eMode:v72];
    objc_msgSend(v43, "setIsStandalone6E:", objc_msgSend(*(id *)(v23 + 32), "isStandalone6G"));

    int v74 = *(const void **)(*(void *)(*(void *)(v23 + 56) + 8LL) + 24LL);
    if (v74)
    {
      CFRelease(v74);
      *(void *)(*(void *)(*(void *)(v23 + 56) + 8LL) + 24LL) = 0LL;
    }

    (*(void (**)(void))(*(void *)(v23 + 48) + 16LL))();
    pthread_mutex_unlock(&stru_100218F48);
    CFRelease(*(CFTypeRef *)(v23 + 72));
    return;
  }

  CFIndex v45 = objc_autoreleasePoolPush();
  if (qword_100219F60) {
    [qword_100219F60 WFLog:@"%s: null queue." message:4];
  }
  objc_autoreleasePoolPop(v45);

  uint64_t v46 = *(const void **)(*(void *)(*(void *)(a1 + 56) + 8LL) + 24LL);
  if (v46)
  {
    CFRelease(v46);
    *(void *)(*(void *)(*(void *)(a1 + 56) + 8LL) + 24LL) = 0LL;
  }

  uint64_t v47 = *(const void **)(*(void *)(*(void *)(a1 + 64) + 8LL) + 24LL);
  if (v47)
  {
    CFRelease(v47);
    *(void *)(*(void *)(*(void *)(a1 + 64) + 8LL) + 24LL) = 0LL;
  }

  pthread_mutex_unlock(&stru_100218F48);
  CFRelease(*(CFTypeRef *)(a1 + 72));
}

void sub_100112A90(uint64_t a1, void *a2)
{
  if (a2)
  {
    BOOL v3 = sub_100053B20(*(void *)(*(void *)(a1 + 32) + 64LL)) != 1;
    [*(id *)(*(void *)(a1 + 32) + 7320) setJoinEvent:1 withReason:0 lastDisconnectReason:0 lastJoinFailure:0 andNetworkDetails:a2 forInterface:sub_100043E8C(*(void *)(*(void *)(a1 + 32) + 64))];
    [*(id *)(*(void *)(a1 + 32) + 7320) setLinkEvent:1 isInvoluntary:v3 linkChangeReason:0 linkChangeSubreason:0 withNetworkDetails:a2 forInterface:*(void *)(a1 + 40)];
  }

uint64_t sub_100112B30(uint64_t a1, int a2, uint64_t a3)
{
  if (!a1 || !a3)
  {
    uint64_t v5 = objc_autoreleasePoolPush();
    if (qword_100219F60) {
      objc_msgSend( (id)qword_100219F60,  "WFLog:message:",  4,  "%s: CATS Register Client: Invalid arguments",  "WifiDeviceManagerCatsRegisterClient",  v14);
    }
    goto LABEL_8;
  }

  unint64_t v4 = *(unsigned __int8 *)(a1 + 40);
  if (v4 >= 3)
  {
    uint64_t v5 = objc_autoreleasePoolPush();
    if (qword_100219F60) {
      [qword_100219F60 WFLog:@"%s: CATS Register Client  Max %d clients registered " message:3];
    }
LABEL_8:
    uint64_t v6 = 0xFFFFFFFFLL;
    goto LABEL_20;
  }

  if (*(_BYTE *)(a1 + 40))
  {
    uint64_t v7 = 0LL;
    uint64_t v8 = (int *)(a1 + 56);
    while (1)
    {
      int v9 = *v8;
      v8 += 6;
      if (v9 == a2) {
        break;
      }
      if (v4 == ++v7)
      {
        int v10 = *(unsigned __int8 *)(a1 + 40);
        goto LABEL_16;
      }
    }

    int v10 = *(unsigned __int8 *)(a1 + 40);
    if ((v7 & 0x80000000) == 0) {
      goto LABEL_17;
    }
  }

  else
  {
    int v10 = 0;
  }

void sub_100112C94(uint64_t a1, uint64_t a2, const __CFDictionary *a3)
{
  if (!a1 || !a2 || !a3)
  {
    uint64_t v14 = objc_autoreleasePoolPush();
    if (qword_100219F60) {
      [qword_100219F60 WFLog:@"%s: CATSUpdate P2P Invalid arguments" message:4];
    }
    goto LABEL_23;
  }

  id v5 = +[WiFiP2PSPITransactionRequestor shared](&OBJC_CLASS___WiFiP2PSPITransactionRequestor, "shared");
  if (!v5)
  {
    uint64_t v14 = objc_autoreleasePoolPush();
    if (qword_100219F60) {
      [qword_100219F60 WFLog:@"Fails to create WiFiP2PSPITransactionRequestor"];
    }
    goto LABEL_23;
  }

  uint64_t v6 = v5;
  unsigned __int8 valuePtr = 0;
  CFBooleanRef Value = (const __CFNumber *)CFDictionaryGetValue(a3, @"CATS_APP_PRIORITY");
  if (!Value)
  {
    uint64_t v14 = objc_autoreleasePoolPush();
    if (qword_100219F60) {
      [qword_100219F60 WFLog:@"%s: CATSUpdate APPLE80211KEY_CATS_APP_PRIORITY key not found" message:4];
    }
LABEL_23:
    objc_autoreleasePoolPop(v14);
    return;
  }

  CFNumberGetValue(Value, kCFNumberCharType, &valuePtr);
  uint64_t v8 = objc_autoreleasePoolPush();
  if (qword_100219F60) {
    [qword_100219F60 WFLog:@"%s: CATSUpdate appPolicy (%d -> %d)", @"WiFiDeviceManagerCatsP2PUpdate", *(unsigned __int8 *)(a2 + 435), valuePtr];
  }
  objc_autoreleasePoolPop(v8);
  uint64_t v24 = 0LL;
  int v9 = (const __CFNumber *)CFDictionaryGetValue(a3, @"CATS_APP_BITMAP");
  if (v9)
  {
    CFNumberGetValue(v9, kCFNumberLongLongType, &v24);
    int v10 = objc_autoreleasePoolPush();
    if (qword_100219F60) {
      [qword_100219F60 WFLog:@"%s: CATSUpdate appBitMap (0x%llx -> 0x%llx)" message:3, @"WiFiDeviceManagerCatsP2PUpdate", *(void *)(a2 + 440), v24];
    }
    objc_autoreleasePoolPop(v10);
    unint64_t v11 = (v24 ^ *(_DWORD *)(a2 + 440)) & 0x40;
    uint64_t v12 = objc_autoreleasePoolPush();
    if (qword_100219F60) {
      [qword_100219F60 WFLog:@"%s: CATSUpdate coPresenceBitChanged = %d" message:3, "%s: CATSUpdate coPresenceBitChanged = %d", "WiFiDeviceManagerCatsP2PUpdate", v11 >> 6];
    }
    objc_autoreleasePoolPop(v12);
    if (*(unsigned __int8 *)(a2 + 435) != valuePtr || v11)
    {
      uint64_t v13 = 2LL;
      switch(*(_BYTE *)(a2 + 435))
      {
        case 0:
          uint64_t v13 = 3LL;
          goto LABEL_31;
        case 1:
          goto LABEL_31;
        case 2:
          if ((*(_BYTE *)(a2 + 440) & 0x40) != 0) {
            uint64_t v13 = 12LL;
          }
          else {
            uint64_t v13 = 1LL;
          }
          goto LABEL_31;
        case 3:
          uint64_t v13 = 12LL;
LABEL_31:
          [v6 endTransaction:v13];
          switch(valuePtr)
          {
            case 0u:
              v20[0] = _NSConcreteStackBlock;
              v20[1] = 3221225472LL;
              v20[2] = sub_1001133FC;
              v20[3] = &unk_1001E5188;
              v20[4] = a2;
              id v16 = v20;
              id v17 = v6;
              uint64_t v18 = 3LL;
              goto LABEL_39;
            case 1u:
              v21[0] = _NSConcreteStackBlock;
              v21[1] = 3221225472LL;
              v21[2] = sub_1001133EC;
              v21[3] = &unk_1001E5188;
              UInt8 v21[4] = a2;
              id v16 = v21;
              id v17 = v6;
              uint64_t v18 = 2LL;
              goto LABEL_39;
            case 2u:
              if ((v24 & 0x40) != 0)
              {
                v23[0] = _NSConcreteStackBlock;
                v23[1] = 3221225472LL;
                v23[2] = sub_100113308;
                v23[3] = &unk_1001E5188;
                v23[4] = a2;
                id v16 = v23;
LABEL_38:
                id v17 = v6;
                uint64_t v18 = 12LL;
              }

              else
              {
                v22[0] = _NSConcreteStackBlock;
                v22[1] = 3221225472LL;
                v22[2] = sub_1001133DC;
                v22[3] = &unk_1001E5188;
                v22[4] = a2;
                id v16 = v22;
                id v17 = v6;
                uint64_t v18 = 1LL;
              }

void sub_1001130B0(uint64_t a1, uint64_t a2, uint64_t a3)
{
  uint64_t v6 = objc_autoreleasePoolPush();
  if (a1 && a2 && a3)
  {
    if (qword_100219F60) {
      [qword_100219F60 WFLog:@"%s: CATSUpdate UCM\n" message:3];
    }
    objc_autoreleasePoolPop(v6);
    uint64_t v7 = *(void (**)(uint64_t, uint64_t, uint64_t))(a2 + 4768);
    if (v7)
    {
      v7(a1, a2, a3);
      return;
    }

    uint64_t v6 = objc_autoreleasePoolPush();
    if (qword_100219F60) {
      [qword_100219F60 WFLog:@"%s: catsUcmUpdate callback is NULL!"];
    }
  }

  else if (qword_100219F60)
  {
    [qword_100219F60 WFLog:@"%s: CATSUpdate UCM Invalid arguments" message:4];
  }

  objc_autoreleasePoolPop(v6);
}

void sub_1001131B0(uint64_t a1, uint64_t a2, const __CFDictionary *a3)
{
  uint64_t v6 = objc_autoreleasePoolPush();
  if (a1 && a2 && a3)
  {
    if (qword_100219F60) {
      [qword_100219F60 WFLog:@"%s: CATSUpdate Scan Manager\n" message:3];
    }
    objc_autoreleasePoolPop(v6);
    unsigned __int8 valuePtr = 0;
    CFBooleanRef Value = (const __CFNumber *)CFDictionaryGetValue(a3, @"CATS_APP_PRIORITY");
    if (Value)
    {
      CFNumberGetValue(Value, kCFNumberCharType, &valuePtr);
      *(_BYTE *)(a2 + 416) = valuePtr;
      uint64_t v8 = objc_autoreleasePoolPush();
      if (qword_100219F60) {
        [qword_100219F60 WFLog:@"%s: CATSUpdate appPolicy=%d" message:3, "WiFiDeviceManagerCatsScanUpdate", valuePtr];
      }
      objc_autoreleasePoolPop(v8);
    }

    else
    {
      int v9 = objc_autoreleasePoolPush();
      if (qword_100219F60) {
        [qword_100219F60 WFLog:@"%s: CATSUpdate APPLE80211KEY_CATS_APP_PRIORITY key not found" message:4];
      }
      objc_autoreleasePoolPop(v9);
    }
  }

  else
  {
    if (qword_100219F60) {
      [qword_100219F60 WFLog:@"WiFiDeviceManagerCatsScanUpdate: CATSUpdate Scan Manager Invalid arguments"];
    }
    objc_autoreleasePoolPop(v6);
  }

void sub_100113308(uint64_t a1, uint64_t a2)
{
}

void sub_100113318(uint64_t a1, uint64_t a2)
{
  if (a2)
  {
    if (!a1) {
      return;
    }
    unint64_t v4 = objc_autoreleasePoolPush();
    if (qword_100219F60) {
      [qword_100219F60 WFLog:@"__CatsP2PUpdateCallback" message:@"%s: CATSUpdate P2P Error: %ld device:%p deviceManager:%p manager:%p\n" 4 a1 *(void *)(a2 + 64) a2 *(void *)(a2 + 424)];
    }
  }

  else
  {
    unint64_t v4 = objc_autoreleasePoolPush();
    if (qword_100219F60) {
      [qword_100219F60 WFLog:@"%s: CATS P2P callback Invalid argument\n" message:4];
    }
  }

  objc_autoreleasePoolPop(v4);
}

void sub_1001133DC(uint64_t a1, uint64_t a2)
{
}

void sub_1001133EC(uint64_t a1, uint64_t a2)
{
}

void sub_1001133FC(uint64_t a1, uint64_t a2)
{
}

void sub_10011340C(uint64_t a1, uint64_t a2)
{
}

void sub_10011341C(uint64_t a1, uint64_t a2)
{
  unint64_t v4 = objc_autoreleasePoolPush();
  uint64_t v5 = *(void **)(a1 + 48);
  if (v5[30])
  {
    CFRetain(v5);
    block[0] = _NSConcreteStackBlock;
    block[2] = sub_1001135C4;
    block[3] = &unk_1001E51B0;
    uint64_t v6 = *(void *)(a1 + 48);
    uint64_t v7 = *(void *)(a1 + 56);
    uint64_t v8 = *(dispatch_queue_s **)(v6 + 240);
    block[1] = 3221225472LL;
    void block[4] = a2;
    void block[5] = v7;
    void block[6] = v6;
    dispatch_async(v8, block);
    sub_10004A048( *(void *)(*(void *)(a1 + 48) + 64),  0,  +[NSString stringWithFormat:]( NSString,  "stringWithFormat:",  @"%@/%@",  @"AutoJoin",  [*(id *)(*(void *)(*(void *)(a1 + 40) + 8) + 40) UUIDString]),  0);
    sub_10004A048( *(void *)(*(void *)(a1 + 48) + 64),  9,  +[NSString stringWithFormat:]( NSString,  "stringWithFormat:",  @"%@/%@",  @"AutoJoin",  [*(id *)(*(void *)(*(void *)(a1 + 40) + 8) + 40) UUIDString]),  0);
    if (*(void *)(a1 + 56) == 39LL) {
      *(_BYTE *)(*(void *)(a1 + 48) + 660kdebug_trace(731381764LL, 0LL, 0LL, 0LL, 0LL) = 0;
    }
  }

  else
  {
    int v9 = objc_autoreleasePoolPush();
    if (qword_100219F60) {
      [qword_100219F60 WFLog:@"%s: null queue." message:@"WiFiDeviceManagerStartAutoJoinAndReply_block_invoke"];
    }
    objc_autoreleasePoolPop(v9);
  }

  objc_autoreleasePoolPop(v4);
  CFRelease(*(CFTypeRef *)(a1 + 48));
}

void sub_1001135C4(void *a1)
{
  id v2 = objc_autoreleasePoolPush();
  BOOL v3 = (void *)a1[4];
  if ((a1[5] & 0xFFFFFFFFFFFFFFFELL) == 0x36 && v3)
  {
    if ([v3 code] == (id)37)
    {
      unint64_t v4 = objc_autoreleasePoolPush();
      if (qword_100219F60) {
        [qword_100219F60 WFLog:@"SSID transition arbitrator is running, ignore duplicated steering request"];
      }
      objc_autoreleasePoolPop(v4);
    }

    else
    {
      int valuePtr = 4;
      CFNumberRef v6 = CFNumberCreate(0LL, kCFNumberIntType, &valuePtr);
      CFNumberRef v7 = CFNumberCreate(0LL, kCFNumberIntType, (const void *)(a1[6] + 3844LL));
      sub_1000EDFE8(a1[6], @"FF:FF:FF:FF:FF:FF", 0LL, 0LL, v6, v7);
      if (v6) {
        CFRelease(v6);
      }
      if (v7) {
        CFRelease(v7);
      }
    }
  }

  else
  {
    sub_100105840(a1[6], [v3 code]);
  }

  [*(id *)(a1[6] + 3648) setScanResultsWithAutoJoinSessionCompletion:*(void *)(a1[6] + 1096) complete:1];
  uint64_t v5 = (CFMutableArrayRef *)a1[6];
  if (v5[137])
  {
    CFArrayRemoveAllValues(v5[137]);
    uint64_t v5 = (CFMutableArrayRef *)a1[6];
  }

  CFRelease(v5);
  objc_autoreleasePoolPop(v2);
}

void sub_100113714(uint64_t a1, unint64_t a2, uint64_t a3)
{
  uint64_t v5 = *(void *)(a1 + 32);
  CFNumberRef v6 = objc_autoreleasePoolPush();
  if (a3)
  {
    if (!v5)
    {
      NSErrorUserInfoKey v46 = NSLocalizedDescriptionKey;
      uint64_t v47 = @"No device manager configured";
      id v25 = +[NSError errorWithDomain:code:userInfo:]( &OBJC_CLASS___NSError,  "errorWithDomain:code:userInfo:",  NSPOSIXErrorDomain,  6LL,  +[NSDictionary dictionaryWithObjects:forKeys:count:]( &OBJC_CLASS___NSDictionary,  "dictionaryWithObjects:forKeys:count:",  &v47,  &v46,  1LL));
      goto LABEL_77;
    }

    if (*(void *)(v5 + 8776))
    {
      if (*(_BYTE *)(v5 + 3297))
      {
        if (*(_BYTE *)(v5 + 6272) || *(_BYTE *)(v5 + 5496))
        {
          if (*(_DWORD *)(v5 + 20) == 1)
          {
            if (*(_BYTE *)(v5 + 248))
            {
              NSErrorDomain v38 = NSPOSIXErrorDomain;
              NSErrorUserInfoKey v46 = NSLocalizedDescriptionKey;
              uint64_t v39 = @"WiFi adhoc is enabled";
            }

            else
            {
              if (!*(_BYTE *)(v5 + 249))
              {
                BOOL v7 = *(_BYTE *)(v5 + 5211)
                  || *(_DWORD *)(v5 + 5336)
                char v8 = *(_BYTE *)(v5 + 7008);
                if (v8) {
                  char v8 = sub_1000DCBFC(v5, 1LL) != 0;
                }
                if (!v7 || (v8 & 1) != 0)
                {
                  uint64_t v9 = *(void *)(v5 + 64);
                  int v10 = (const void *)sub_100043E8C(v9);
                  unint64_t v11 = sub_100040538(v9, v10);
                  if ((*(_DWORD *)(v5 + 5388) == 102 && (*(_BYTE *)(v5 + 5384) & 1) != 0 || *(_BYTE *)(v5 + 50))
                    && *(_DWORD *)(v5 + 5512) == 1
                    && !*(_BYTE *)(v5 + 37)
                    && (a2 > 0x37 || ((1LL << a2) & 0xD0000000000000LL) == 0))
                  {
                    NSErrorDomain v21 = NSPOSIXErrorDomain;
                    NSErrorUserInfoKey v46 = NSLocalizedDescriptionKey;
                    double v22 = @"BT SCO is enabled";
                  }

                  else if (*(_BYTE *)(v5 + 3406) && (a2 > 0x37 || ((1LL << a2) & 0xD0012000000184LL) == 0))
                  {
                    NSErrorDomain v21 = NSPOSIXErrorDomain;
                    NSErrorUserInfoKey v46 = NSLocalizedDescriptionKey;
                    double v22 = @"AWDL real time mode is active";
                  }

                  else
                  {
                    if (!sub_1000DF3D8(v5))
                    {
                      if (sub_1000D6EA0(v5))
                      {
                        NSErrorDomain v40 = NSPOSIXErrorDomain;
                        NSErrorUserInfoKey v46 = NSLocalizedDescriptionKey;
                        uint64_t v47 = @"Auto-join deferral is active";
LABEL_118:
                        id v26 = +[NSDictionary dictionaryWithObjects:forKeys:count:]( &OBJC_CLASS___NSDictionary,  "dictionaryWithObjects:forKeys:count:",  &v47,  &v46,  1LL);
                        NSErrorDomain v27 = v40;
                        uint64_t v28 = 16LL;
                        goto LABEL_81;
                      }

                      if (!v11 || sub_100097700((uint64_t)v11))
                      {
LABEL_69:
                        if (*(_DWORD *)(v5 + 5408))
                        {
                          uint64_t v23 = *(void **)(v5 + 5400);
                          if (v23 && ([v23 isPowerResourceAvailable:0] & 1) == 0)
                          {
                            NSErrorDomain v41 = NSPOSIXErrorDomain;
                            NSErrorUserInfoKey v46 = NSLocalizedDescriptionKey;
                            id v42 = @"Insufficient battery resource";
                          }

                          else if (sub_1000FC52C(v5))
                          {
                            NSErrorDomain v41 = NSPOSIXErrorDomain;
                            NSErrorUserInfoKey v46 = NSLocalizedDescriptionKey;
                            id v42 = @"Scan throttle limit exceeded";
                          }

                          else
                          {
                            if (*(_BYTE *)(v5 + 8952))
                            {
                              uint64_t v24 = *(unsigned int *)(v5 + 3472);
                              if ((int)v24 < 1)
                              {
                                id v25 = 0LL;
                                uint64_t v5 = 1LL;
                                if (!v11)
                                {
LABEL_77:
                                  (*(void (**)(uint64_t, uint64_t, NSError *))(a3 + 16))(a3, v5, v25);
                                  goto LABEL_78;
                                }

void sub_100114450(uint64_t a1, void *a2, uint64_t a3, void *a4, uint64_t a5)
{
  char v8 = *(uint64_t **)(a1 + 32);
  uint64_t v9 = objc_autoreleasePoolPush();
  if (a5)
  {
    if (v8)
    {
      if (v8[1097])
      {
        if (a2)
        {
          int v10 = sub_1000A1DEC(a2, 0LL);
          if (v10)
          {
            unint64_t v11 = v10;
            if (sub_1000FC698((uint64_t)v8, v10, 1u))
            {
              if (!a4) {
                goto LABEL_11;
              }
              uint64_t v12 = sub_1000A1DEC([a4 matchingKnownNetworkProfile], 0);
              if (v12)
              {
                a4 = v12;
                if (sub_10000B784())
                {
                  uint64_t v13 = v8[843];
                  uint64_t v14 = (const void *)sub_100043E8C(v8[8]);
                  if (sub_1000831A4(v13, v14, a4, v11))
                  {
LABEL_11:
                    BOOL v15 = sub_100117634((uint64_t)v8, v11);
                    CFRelease(v11);
                    double v16 = 0LL;
                    double v17 = 0LL;
                    uint64_t v18 = 1LL;
                    if (!a4)
                    {
LABEL_13:
                      (*(void (**)(uint64_t, uint64_t, BOOL, NSError *))(a5 + 16))(a5, v18, v15, v17);
                      goto LABEL_14;
                    }

uint64_t sub_10011483C(uint64_t a1, void *a2, void *a3)
{
  uint64_t v5 = *(void *)(a1 + 32);
  CFNumberRef v6 = objc_autoreleasePoolPush();
  if (!v5 || !*(void *)(v5 + 8776))
  {
    uint64_t v7 = 0LL;
    goto LABEL_13;
  }

  uint64_t v7 = 0LL;
  if (a2 && a3)
  {
    char v8 = sub_1000A1DEC(a2, 0LL);
    uint64_t v9 = sub_1000A1DEC(a3, 0LL);
    int v10 = v9;
    if (v8 && v9)
    {
      if (*(_BYTE *)(v5 + 6616)) {
        uint64_t v11 = sub_10009C5D4((uint64_t)v9, (uint64_t)v8, 0LL);
      }
      else {
        uint64_t v11 = 0LL;
      }
    }

    else
    {
      uint64_t v11 = 0LL;
      uint64_t v7 = 0LL;
      if (!v8)
      {
LABEL_11:
        if (v10) {
          CFRelease(v10);
        }
        goto LABEL_13;
      }
    }

    CFRelease(v8);
    uint64_t v7 = v11;
    goto LABEL_11;
  }

void sub_10011491C(uint64_t a1, void *a2, void (**a3)(void, void, void, void))
{
  uint64_t v5 = *(void *)(a1 + 32);
  CFNumberRef v6 = objc_autoreleasePoolPush();
  uint64_t v7 = v6;
  if (!a3) {
    goto LABEL_62;
  }
  if (!v5)
  {
    NSErrorDomain v36 = NSPOSIXErrorDomain;
    v59[0] = NSLocalizedDescriptionKey;
    id v37 = @"No device manager configured";
LABEL_68:
    v62[0] = v37;
    NSErrorDomain v38 = +[NSDictionary dictionaryWithObjects:forKeys:count:]( &OBJC_CLASS___NSDictionary,  "dictionaryWithObjects:forKeys:count:",  v62,  v59,  1LL);
    NSErrorDomain v39 = v36;
    uint64_t v40 = 6LL;
LABEL_70:
    NSErrorDomain v41 = +[NSError errorWithDomain:code:userInfo:]( &OBJC_CLASS___NSError,  "errorWithDomain:code:userInfo:",  v39,  v40,  v38);
    NSErrorUserInfoKey v31 = 0LL;
    goto LABEL_74;
  }

  if (!*(void *)(v5 + 8776))
  {
    NSErrorDomain v36 = NSPOSIXErrorDomain;
    v59[0] = NSLocalizedDescriptionKey;
    id v37 = @"No auto-join manager configured";
    goto LABEL_68;
  }

  if (!a2)
  {
    v59[0] = NSLocalizedDescriptionKey;
    v62[0] = @"No scan parameters specified";
    NSErrorDomain v38 = +[NSDictionary dictionaryWithObjects:forKeys:count:]( &OBJC_CLASS___NSDictionary,  "dictionaryWithObjects:forKeys:count:",  v62,  v59,  1LL);
    NSErrorDomain v39 = NSPOSIXErrorDomain;
    uint64_t v40 = 22LL;
    goto LABEL_70;
  }

  uint64_t v43 = v6;
  uint64_t v8 = *(void *)(v5 + 8880);
  if (v8)
  {
    (*(void (**)(uint64_t, NSError *, void, void))(v8 + 16))( v8,  +[NSError errorWithDomain:code:userInfo:]( &OBJC_CLASS___NSError,  "errorWithDomain:code:userInfo:",  NSPOSIXErrorDomain,  89LL,  0LL),  0LL,  0LL);
    _Block_release(*(const void **)(v5 + 8880));
    *(void *)(v5 + 8880) = 0LL;
  }

  if (_os_feature_enabled_impl("CoreWiFi", "WiFi6EMaxCompatibility"))
  {
    int v9 = sub_10006DCC8(*(void *)(v5 + 6744));
    int v10 = objc_autoreleasePoolPush();
    if (qword_100219F60) {
      [qword_100219F60 WFLog:@"%s: prefer 6E enabled %d" message:3, "%s: prefer 6E enabled %d",  "__WiFiDeviceManagerUnifiedAutoJoinScanForNetworks",  v9 == 0];
    }
    objc_autoreleasePoolPop(v10);
    [*(id *)(v5 + 8776) setMaxCompatibilityEnabled:v9 == 0];
  }

  *(void *)(v5 + 8880) = _Block_copy(a3);

  *(void *)(v5 + 888_Block_object_dispose(va, 8) = [a2 copy];
  id v44 = +[NSMutableDictionary dictionary](&OBJC_CLASS___NSMutableDictionary, "dictionary");
  if (*(_BYTE *)(v5 + 7008)
    && *(_BYTE *)(v5 + 5211)
    && *(unsigned __int8 *)(v5 + 5208) >= 0xFu
    && (*(_BYTE *)(v5 + 7009) & 4) != 0)
  {
    uint64_t v35 = objc_autoreleasePoolPush();
    if (qword_100219F60) {
      [(id)qword_100219F60 WFLog:4 message:"AJScan: Disallowing 6Ghz channels due to Active 5GHz MIS session"];
    }
    objc_autoreleasePoolPop(v35);
    char v11 = 0;
  }

  else
  {
    char v11 = 1;
  }

  uint64_t v42 = v5;
  __int128 v53 = 0u;
  __int128 v54 = 0u;
  __int128 v51 = 0u;
  __int128 v52 = 0u;
  double v45 = a2;
  obCFIndex j = [a2 channels];
  id v12 = [obj countByEnumeratingWithState:&v51 objects:v62 count:16];
  if (v12)
  {
    id v13 = v12;
    id v14 = 0LL;
    uint64_t v15 = *(void *)v52;
    do
    {
      for (CFIndex i = 0LL; i != v13; CFIndex i = (char *)i + 1)
      {
        if (*(void *)v52 != v15) {
          objc_enumerationMutation(obj);
        }
        double v17 = *(void **)(*((void *)&v51 + 1) + 8LL * (void)i);
        if ((v11 & 1) != 0
          || ([*(id *)(*((void *)&v51 + 1) + 8 * (void)i) is6GHz] & 1) == 0)
        {
          if (!v14) {
            id v14 = +[NSMutableArray array](&OBJC_CLASS___NSMutableArray, "array");
          }
          v60[0] = @"CHANNEL";
          uint64_t v18 = +[NSNumber numberWithUnsignedInteger:]( NSNumber,  "numberWithUnsignedInteger:",  [v17 channel]);
          v60[1] = @"CHANNEL_FLAGS";
          v61[0] = v18;
          v61[1] = +[NSNumber numberWithUnsignedInt:]( NSNumber,  "numberWithUnsignedInt:",  [v17 flags]);
          [v14 addObject:+[NSDictionary dictionaryWithObjects:forKeys:count:]( NSDictionary,  "dictionaryWithObjects:forKeys:count:",  v61,  v60,  2)];
        }
      }

      id v13 = [obj countByEnumeratingWithState:&v51 objects:v62 count:16];
    }

    while (v13);
  }

  else
  {
    id v14 = 0LL;
  }

  if ([v14 count])
  {
    [v44 setObject:v14 forKeyedSubscript:@"SCAN_CHANNELS"];
    __int128 v49 = 0u;
    __int128 v50 = 0u;
    __int128 v47 = 0u;
    __int128 v48 = 0u;
    id v19 = [v45 SSIDList];
    id v20 = [v19 countByEnumeratingWithState:&v47 objects:v59 count:16];
    if (v20)
    {
      id v21 = v20;
      id v22 = 0LL;
      uint64_t v23 = *(void *)v48;
      do
      {
        for (CFIndex j = 0LL; j != v21; CFIndex j = (char *)j + 1)
        {
          if (*(void *)v48 != v23) {
            objc_enumerationMutation(v19);
          }
          uint64_t v25 = *(void *)(*((void *)&v47 + 1) + 8LL * (void)j);
          if (!v22) {
            id v22 = +[NSMutableArray array](&OBJC_CLASS___NSMutableArray, "array");
          }
          BOOL v57 = @"SSID_STR";
          uint64_t v58 = v25;
          [v22 addObject:[NSDictionary dictionaryWithObjects:forKeys:count:&v58, &v57, 1]];
        }

        id v21 = [v19 countByEnumeratingWithState:&v47 objects:v59 count:16];
      }

      while (v21);
    }

    else
    {
      id v22 = 0LL;
    }

    if ([v22 count])
    {
      CFIndex v55 = @"SSID_STR";
      BOOL v56 = &stru_1001EB6E0;
      [v22 addObject:+[NSDictionary dictionaryWithObjects:forKeys:count:]( NSDictionary,  "dictionaryWithObjects:forKeys:count:",  &v56,  &v55,  1)];
    }

    [v44 setObject:v22 forKeyedSubscript:@"SCAN_SSID_LIST"];
    objc_msgSend(v44, "setObject:forKeyedSubscript:", objc_msgSend(v45, "SSID"), @"SSID_STR");
    objc_msgSend(v44, "setObject:forKeyedSubscript:", objc_msgSend(v45, "BSSID"), @"BSSID");
    uint64_t v7 = v43;
    if ([v45 shortSSID]) {
      id v26 = +[NSNumber numberWithUnsignedInteger:]( NSNumber,  "numberWithUnsignedInteger:",  [v45 shortSSID]);
    }
    else {
      id v26 = 0LL;
    }
    [v44 setObject:v26 forKeyedSubscript:@"SCAN_SHORT_SSID"];
    objc_msgSend( v44,  "setObject:forKeyedSubscript:",  +[NSNumber numberWithUnsignedInt:]( NSNumber,  "numberWithUnsignedInt:",  objc_msgSend(v45, "scanType")),  @"SCAN_TYPE");
    [v44 setObject:[NSNumber numberWithUnsignedInt:[v45 BSSType]] forKeyedSubscript:@"SCAN_BSS_TYPE"];
    objc_msgSend( v44,  "setObject:forKeyedSubscript:",  +[NSNumber numberWithUnsignedInt:](NSNumber, "numberWithUnsignedInt:", objc_msgSend(v45, "PHYMode")),  @"SCAN_PHY_MODE");
    objc_msgSend( v44,  "setObject:forKeyedSubscript:",  +[NSNumber numberWithUnsignedInteger:]( NSNumber,  "numberWithUnsignedInteger:",  objc_msgSend(v45, "restTime")),  @"SCAN_REST_TIME");
    objc_msgSend( v44,  "setObject:forKeyedSubscript:",  +[NSNumber numberWithUnsignedInteger:]( NSNumber,  "numberWithUnsignedInteger:",  objc_msgSend(v45, "dwellTime")),  @"SCAN_DWELL_TIME");
    objc_msgSend( v44,  "setObject:forKeyedSubscript:",  +[NSNumber numberWithBool:](NSNumber, "numberWithBool:", objc_msgSend(v45, "mergeScanResults")),  @"SCAN_MERGE");
    if ([v45 numberOfScans]) {
      NSErrorDomain v27 = +[NSNumber numberWithUnsignedInteger:]( NSNumber,  "numberWithUnsignedInteger:",  [v45 numberOfScans]);
    }
    else {
      NSErrorDomain v27 = (NSNumber *)&off_100204C50;
    }
    [v44 setObject:v27 forKeyedSubscript:@"SCAN_NUM_SCANS"];
    if ([v45 acceptableCacheAge] == (id)-1)
    {
      [v44 setObject:&__kCFBooleanTrue forKeyedSubscript:@"CacheOnly"];
      uint64_t v28 = (NSNumber *)&off_100204C68;
    }

    else
    {
      uint64_t v28 = +[NSNumber numberWithDouble:]( NSNumber,  "numberWithDouble:",  (double)(unint64_t)[v45 acceptableCacheAge] / 1000.0);
    }

    [v44 setObject:v28 forKeyedSubscript:@"SCAN_MAXAGE"];
    objc_msgSend( v44,  "setObject:forKeyedSubscript:",  +[NSNumber numberWithUnsignedInt:]( NSNumber,  "numberWithUnsignedInt:",  objc_msgSend(v45, "scanFlags")),  @"SCAN_FLAGS");
    if ([v45 scanType] != 3 && objc_msgSend(v45, "acceptableCacheAge") != (id)-1)
    {
      uint64_t v29 = *(void *)(v42 + 8864);
      if ((unint64_t)objc_msgSend(objc_msgSend(v45, "channels"), "count") + v29 >= 7)
      {
        sub_10004A048( *(void *)(v42 + 64),  0,  +[NSString stringWithFormat:]( NSString,  "stringWithFormat:",  @"%@/%@",  @"AutoJoin",  [*(id *)(v42 + 8856) UUIDString]),  0);
        sub_10004A048( *(void *)(v42 + 64),  9,  +[NSString stringWithFormat:]( NSString,  "stringWithFormat:",  @"%@/%@",  @"AutoJoin",  [*(id *)(v42 + 8856) UUIDString]),  0);
      }
    }

    CFNumberRef v30 = malloc(0x28uLL);
    NSErrorUserInfoKey v31 = v30;
    if (v30)
    {
      void *v30 = v42;
      v30[1] = 0LL;
      v30[3] = 0LL;
      if ([v22 count]) {
        uint64_t v32 = 21LL;
      }
      else {
        uint64_t v32 = 20LL;
      }
      id v33 = (const void *)sub_100043E8C(*(void *)(v42 + 64));
      int v34 = sub_1000E0CC4(v42, v33, v44, 10LL, (uint64_t)sub_10011772C, (uint64_t)v31, 0LL, v32);
      if (!v34) {
        goto LABEL_62;
      }
      NSErrorDomain v41 = +[NSError errorWithDomain:code:userInfo:]( &OBJC_CLASS___NSError,  "errorWithDomain:code:userInfo:",  CWFManagerErrorDomain,  v34,  0LL);
    }

    else
    {
      NSErrorDomain v41 = +[NSError errorWithDomain:code:userInfo:]( &OBJC_CLASS___NSError,  "errorWithDomain:code:userInfo:",  NSPOSIXErrorDomain,  12LL,  0LL);
    }
  }

  else
  {
    NSErrorDomain v41 = +[NSError errorWithDomain:code:userInfo:]( &OBJC_CLASS___NSError,  "errorWithDomain:code:userInfo:",  NSPOSIXErrorDomain,  1LL,  0LL);
    NSErrorUserInfoKey v31 = 0LL;
    uint64_t v7 = v43;
  }

void sub_1001152D0(uint64_t a1, void *a2, void (**a3)(void, void, void, void))
{
  uint64_t v5 = *(void *)(a1 + 32);
  CFNumberRef v6 = objc_autoreleasePoolPush();
  if (!a3) {
    goto LABEL_22;
  }
  if (!v5)
  {
    NSErrorDomain v24 = NSPOSIXErrorDomain;
    *(void *)&__int128 v33 = NSLocalizedDescriptionKey;
    uint64_t v25 = @"No device manager configured";
LABEL_25:
    v32[0] = v25;
    id v26 = +[NSDictionary dictionaryWithObjects:forKeys:count:]( &OBJC_CLASS___NSDictionary,  "dictionaryWithObjects:forKeys:count:",  v32,  &v33,  1LL);
    NSErrorDomain v27 = v24;
    uint64_t v28 = 6LL;
    goto LABEL_28;
  }

  if (!*(void *)(v5 + 8776))
  {
    NSErrorDomain v24 = NSPOSIXErrorDomain;
    *(void *)&__int128 v33 = NSLocalizedDescriptionKey;
    uint64_t v25 = @"No auto-join manager configured";
    goto LABEL_25;
  }

  if (a2)
  {
    uint64_t v7 = *(void *)(v5 + 8896);
    if (v7)
    {
      (*(void (**)(uint64_t, NSError *, void, void))(v7 + 16))( v7,  +[NSError errorWithDomain:code:userInfo:]( &OBJC_CLASS___NSError,  "errorWithDomain:code:userInfo:",  NSPOSIXErrorDomain,  89LL,  0LL),  0LL,  0LL);
      _Block_release(*(const void **)(v5 + 8896));
      *(void *)(v5 + 8896) = 0LL;
    }

    *(void *)(v5 + 8896) = _Block_copy(a3);

    *(void *)(v5 + 8904) = [a2 copy];
    id v8 = +[NSMutableDictionary dictionary](&OBJC_CLASS___NSMutableDictionary, "dictionary");
    [v8 setObject:&off_100204C80 forKeyedSubscript:@"GAS_PROTOCOL"];
    objc_msgSend(v8, "setObject:forKeyedSubscript:", objc_msgSend(a2, "ANQPElementIDList"), @"GAS_QUERY");
    id v9 = +[NSMutableArray array](&OBJC_CLASS___NSMutableArray, "array");
    __int128 v33 = 0u;
    __int128 v34 = 0u;
    __int128 v35 = 0u;
    __int128 v36 = 0u;
    id v10 = [a2 scanResults];
    id v11 = [v10 countByEnumeratingWithState:&v33 objects:v32 count:16];
    if (v11)
    {
      id v12 = v11;
      uint64_t v13 = *(void *)v34;
      do
      {
        for (CFIndex i = 0LL; i != v12; CFIndex i = (char *)i + 1)
        {
          if (*(void *)v34 != v13) {
            objc_enumerationMutation(v10);
          }
          id v15 = [*(id *)(*((void *)&v33 + 1) + 8 * (void)i) scanRecord];
          if (v15) {
            [v9 addObject:v15];
          }
        }

        id v12 = [v10 countByEnumeratingWithState:&v33 objects:v32 count:16];
      }

      while (v12);
    }

    double v16 = sub_10003A530((const __CFArray *)v9);
    if (v16)
    {
      double v17 = v16;
      [v8 setObject:v16 forKeyedSubscript:@"GAS_NETWORKS"];
      if ([a2 acceptableCacheAge] == (id)-1)
      {
        [v8 setObject:&__kCFBooleanTrue forKeyedSubscript:@"CacheOnly"];
        uint64_t v18 = (NSNumber *)&off_100204C68;
      }

      else
      {
        uint64_t v18 = +[NSNumber numberWithDouble:]( NSNumber,  "numberWithDouble:",  (double)(unint64_t)[a2 acceptableCacheAge] / 1000.0);
      }

      [v8 setObject:v18 forKeyedSubscript:@"SCAN_MAXAGE"];
      CFRelease(v17);
      id v19 = malloc(0x18uLL);
      id v20 = v19;
      if (v19)
      {
        v19[1] = 0LL;
        v19[2] = 0LL;
        void *v19 = v5;
        uint64_t v21 = *(void *)(v5 + 64);
        id v22 = (const void *)sub_100043E8C(v21);
        int v23 = sub_10005064C(v21, v22, v8, 10LL, (uint64_t)sub_100117A40, (uint64_t)v20);
        if (!v23) {
          goto LABEL_22;
        }
        NSErrorDomain v30 = (NSErrorDomain)CWFManagerErrorDomain;
        uint64_t v31 = v23;
      }

      else
      {
        NSErrorDomain v30 = NSPOSIXErrorDomain;
        uint64_t v31 = 12LL;
      }

      uint64_t v29 = +[NSError errorWithDomain:code:userInfo:]( &OBJC_CLASS___NSError,  "errorWithDomain:code:userInfo:",  v30,  v31,  0LL);
      goto LABEL_32;
    }

    NSErrorDomain v27 = NSPOSIXErrorDomain;
    uint64_t v28 = 12LL;
    id v26 = 0LL;
  }

  else
  {
    *(void *)&__int128 v33 = NSLocalizedDescriptionKey;
    v32[0] = @"No ANQP parameters specified";
    id v26 = +[NSDictionary dictionaryWithObjects:forKeys:count:]( &OBJC_CLASS___NSDictionary,  "dictionaryWithObjects:forKeys:count:",  v32,  &v33,  1LL);
    NSErrorDomain v27 = NSPOSIXErrorDomain;
    uint64_t v28 = 22LL;
  }

void sub_100115728(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  uint64_t v7 = *(void *)(a1 + 32);
  id v8 = objc_autoreleasePoolPush();
  if (a4)
  {
    if (v7)
    {
      if (*(void *)(v7 + 8776))
      {
        if (!a2)
        {
          NSErrorUserInfoKey v24 = NSLocalizedDescriptionKey;
          uint64_t v25 = @"No join candidate specified";
          id v15 = +[NSError errorWithDomain:code:userInfo:]( &OBJC_CLASS___NSError,  "errorWithDomain:code:userInfo:",  NSPOSIXErrorDomain,  22LL,  +[NSDictionary dictionaryWithObjects:forKeys:count:]( &OBJC_CLASS___NSDictionary,  "dictionaryWithObjects:forKeys:count:",  &v25,  &v24,  1LL));
LABEL_27:
          BOOL v16 = 0LL;
          goto LABEL_19;
        }

        if ([(id)a2 matchingKnownNetworkProfile])
        {
          id v9 = sub_100117C28((_WORD *)a2);
          if (sub_1000FC698(v7, v9, 0))
          {
            int v10 = sub_1000FD668(v7, v9, 0, 0LL);
            if ((uint64_t)[(id)a2 RSSI] < v10)
            {
              NSErrorDomain v22 = NSPOSIXErrorDomain;
              NSErrorUserInfoKey v24 = NSLocalizedDescriptionKey;
              int v23 = @"Below minimum RSSI threshold";
            }

            else
            {
              unsigned int v11 = objc_msgSend(objc_msgSend((id)a2, "matchingKnownNetworkProfile"), "isPasspoint");
              if (v11 == [(id)a2 isPasspoint])
              {
                if (a3 == 39)
                {
                  uint64_t v12 = *(void *)(v7 + 64);
                  uint64_t v13 = (const void *)sub_100043E8C(v12);
                  id v14 = sub_100040538(v12, v13);
                  if (!v14 || !sub_100110894(v7, (uint64_t)v14, (uint64_t)v9))
                  {
                    NSErrorUserInfoKey v24 = NSLocalizedDescriptionKey;
                    uint64_t v25 = @"Colocated scope ID does not match current network";
                    id v15 = +[NSError errorWithDomain:code:userInfo:]( &OBJC_CLASS___NSError,  "errorWithDomain:code:userInfo:",  NSPOSIXErrorDomain,  1LL,  +[NSDictionary dictionaryWithObjects:forKeys:count:]( &OBJC_CLASS___NSDictionary,  "dictionaryWithObjects:forKeys:count:",  &v25,  &v24,  1LL));
                    BOOL v16 = 0LL;
                    a2 = 0LL;
                    goto LABEL_15;
                  }
                }

                else
                {
                  id v14 = 0LL;
                }

                BOOL v16 = sub_100117634(v7, v9);
                id v15 = 0LL;
                a2 = 1LL;
LABEL_15:
                if (v14) {
                  CFRelease(v14);
                }
                if (!v9) {
                  goto LABEL_19;
                }
LABEL_18:
                CFRelease(v9);
LABEL_19:
                (*(void (**)(uint64_t, uint64_t, BOOL, NSError *))(a4 + 16))(a4, a2, v16, v15);
                goto LABEL_20;
              }

              NSErrorDomain v22 = NSPOSIXErrorDomain;
              NSErrorUserInfoKey v24 = NSLocalizedDescriptionKey;
              int v23 = @"Join candidate does not match known network passpoint state";
            }
          }

          else
          {
            NSErrorDomain v22 = NSPOSIXErrorDomain;
            NSErrorUserInfoKey v24 = NSLocalizedDescriptionKey;
            int v23 = @"Join candidate not suitable for auto-join";
          }

          uint64_t v25 = v23;
          id v15 = +[NSError errorWithDomain:code:userInfo:]( &OBJC_CLASS___NSError,  "errorWithDomain:code:userInfo:",  v22,  1LL,  +[NSDictionary dictionaryWithObjects:forKeys:count:]( &OBJC_CLASS___NSDictionary,  "dictionaryWithObjects:forKeys:count:",  &v25,  &v24,  1LL));
          a2 = 0LL;
          BOOL v16 = 0LL;
          if (!v9) {
            goto LABEL_19;
          }
          goto LABEL_18;
        }

        NSErrorUserInfoKey v24 = NSLocalizedDescriptionKey;
        uint64_t v25 = @"No matching known network specified";
        id v19 = +[NSDictionary dictionaryWithObjects:forKeys:count:]( &OBJC_CLASS___NSDictionary,  "dictionaryWithObjects:forKeys:count:",  &v25,  &v24,  1LL);
        NSErrorDomain v20 = NSPOSIXErrorDomain;
        uint64_t v21 = 22LL;
LABEL_26:
        id v15 = +[NSError errorWithDomain:code:userInfo:]( &OBJC_CLASS___NSError,  "errorWithDomain:code:userInfo:",  v20,  v21,  v19);
        a2 = 0LL;
        goto LABEL_27;
      }

      NSErrorDomain v17 = NSPOSIXErrorDomain;
      NSErrorUserInfoKey v24 = NSLocalizedDescriptionKey;
      uint64_t v18 = @"No auto-join manager configured";
    }

    else
    {
      NSErrorDomain v17 = NSPOSIXErrorDomain;
      NSErrorUserInfoKey v24 = NSLocalizedDescriptionKey;
      uint64_t v18 = @"No device manager configured";
    }

    uint64_t v25 = v18;
    id v19 = +[NSDictionary dictionaryWithObjects:forKeys:count:]( &OBJC_CLASS___NSDictionary,  "dictionaryWithObjects:forKeys:count:",  &v25,  &v24,  1LL);
    NSErrorDomain v20 = v17;
    uint64_t v21 = 6LL;
    goto LABEL_26;
  }

uint64_t sub_100115B4C(uint64_t a1, _WORD *a2, _WORD *a3)
{
  uint64_t v5 = *(void *)(a1 + 32);
  CFNumberRef v6 = objc_autoreleasePoolPush();
  if (!v5 || !*(void *)(v5 + 8776))
  {
    uint64_t v7 = 0LL;
    goto LABEL_13;
  }

  uint64_t v7 = 0LL;
  if (a2 && a3)
  {
    id v8 = sub_100117C28(a2);
    id v9 = sub_100117C28(a3);
    int v10 = v9;
    if (v8 && v9)
    {
      if (*(_BYTE *)(v5 + 6616)) {
        uint64_t v11 = sub_10009C5D4((uint64_t)v9, (uint64_t)v8, 0LL);
      }
      else {
        uint64_t v11 = 0LL;
      }
    }

    else
    {
      uint64_t v11 = 0LL;
      uint64_t v7 = 0LL;
      if (!v8)
      {
LABEL_11:
        if (v10) {
          CFRelease(v10);
        }
        goto LABEL_13;
      }
    }

    CFRelease(v8);
    uint64_t v7 = v11;
    goto LABEL_11;
  }

void sub_100115C24(uint64_t a1, void *a2, void (**a3)(void, void))
{
  uint64_t v5 = *(void *)(a1 + 32);
  CFNumberRef v6 = objc_autoreleasePoolPush();
  if (!a3) {
    goto LABEL_32;
  }
  if (!v5)
  {
    NSErrorDomain v24 = NSPOSIXErrorDomain;
    NSErrorUserInfoKey v32 = NSLocalizedDescriptionKey;
    uint64_t v25 = @"No device manager configured";
LABEL_41:
    __int128 v33 = v25;
    id v26 = +[NSDictionary dictionaryWithObjects:forKeys:count:]( &OBJC_CLASS___NSDictionary,  "dictionaryWithObjects:forKeys:count:",  &v33,  &v32,  1LL);
    NSErrorDomain v27 = v24;
    uint64_t v28 = 6LL;
    goto LABEL_46;
  }

  if (!*(void *)(v5 + 8776))
  {
    NSErrorDomain v24 = NSPOSIXErrorDomain;
    NSErrorUserInfoKey v32 = NSLocalizedDescriptionKey;
    uint64_t v25 = @"No auto-join manager configured";
    goto LABEL_41;
  }

  if (a2)
  {
    if ([a2 scanResult])
    {
      uint64_t v7 = (const __CFDictionary *)sub_100117C28([a2 scanResult]);
      if (v7)
      {
        id v8 = v7;
        sub_1000F6D00((const __CFDictionary *)objc_msgSend(objc_msgSend(a2, "scanResult"), "scanRecord"), v7);
        uint64_t v9 = *(void *)(v5 + 8792);
        if (v9)
        {
          (*(void (**)(uint64_t, NSError *))(v9 + 16))( v9,  +[NSError errorWithDomain:code:userInfo:]( &OBJC_CLASS___NSError,  "errorWithDomain:code:userInfo:",  NSPOSIXErrorDomain,  89LL,  0LL));
          _Block_release(*(const void **)(v5 + 8792));
          int v10 = *(const void **)(v5 + 8784);
          if (v10) {
            CFRelease(v10);
          }
        }

        *(void *)(v5 + 8792) = _Block_copy(a3);
        *(void *)(v5 + 8784) = CFRetain(v8);
        CFMutableArrayRef Mutable = *(__CFArray **)(v5 + 1104);
        if (!Mutable)
        {
          CFMutableArrayRef Mutable = CFArrayCreateMutable(kCFAllocatorDefault, 0LL, &kCFTypeArrayCallBacks);
          *(void *)(v5 + 1104) = Mutable;
        }

        if (*(void *)(v5 + 8872))
        {
          sub_10004A048( *(void *)(v5 + 64),  0,  +[NSString stringWithFormat:]( NSString,  "stringWithFormat:",  @"%@/%@",  @"AutoJoin",  [*(id *)(v5 + 8856) UUIDString]),  0);
          sub_10004A048( *(void *)(v5 + 64),  9,  +[NSString stringWithFormat:]( NSString,  "stringWithFormat:",  @"%@/%@",  @"AutoJoin",  [*(id *)(v5 + 8856) UUIDString]),  0);
          CFMutableArrayRef Mutable = *(__CFArray **)(v5 + 1104);
        }

        CFArrayRemoveAllValues(Mutable);
        if ([a2 bandPreference]) {
          sub_10009582C( (uint64_t)v8,  @"BAND_PREFERENCE",  +[NSNumber numberWithInteger:]( NSNumber,  "numberWithInteger:",  [a2 bandPreference]));
        }
        if ([a2 colocatedScopeID]) {
          sub_10009582C((uint64_t)v8, @"COLOCATED_NETWORK_SCOPE_ID", [a2 colocatedScopeID]);
        }
        if ([a2 has6GHzOnlyBSS])
        {
          unsigned int v12 = sub_100096BF4((uint64_t)v8, @"ASSOC_FLAGS");
          sub_1000970C0((uint64_t)v8, @"ASSOC_FLAGS", v12 | 0x100000LL);
        }

        uint64_t v13 = (const void *)sub_100043E8C(*(void *)(v5 + 64));
        id v14 = sub_1000DEA34(v5, v13, 1);
        if (v14)
        {
          id v15 = v14;
          BOOL v16 = (void *)sub_1000951FC((uint64_t)v14, @"SSID");
          NSErrorDomain v17 = sub_1000951FC((uint64_t)v8, @"SSID");
          if (v16 && v17 && [v16 isEqual:v17])
          {
            CFNumberRef v18 = CFNumberCreate(0LL, kCFNumberIntType, (const void *)(v5 + 3844));
            if ([a2 bandPreference])
            {
              if ([a2 bandPreference]) {
                id v19 = +[NSNumber numberWithInteger:]( NSNumber,  "numberWithInteger:",  [a2 bandPreference]);
              }
              else {
                id v19 = 0LL;
              }
              uint64_t v22 = v5;
              unint64_t v23 = 0LL;
              uint64_t v21 = 0LL;
            }

            else
            {
              NSErrorDomain v20 = +[NSNumber numberWithUnsignedInteger:]( NSNumber,  "numberWithUnsignedInteger:",  objc_msgSend(objc_msgSend(objc_msgSend(a2, "scanResult"), "channel"), "channel"));
              uint64_t v21 = +[NSNumber numberWithUnsignedInt:]( NSNumber,  "numberWithUnsignedInt:",  objc_msgSend(objc_msgSend(objc_msgSend(a2, "scanResult"), "channel"), "band"));
              uint64_t v22 = v5;
              unint64_t v23 = (unint64_t)v20;
              id v19 = 0LL;
            }

            sub_1000EDFE8(v22, @"FF:FF:FF:FF:FF:FF", v23, v21, v19, v18);
            if (v18) {
              CFRelease(v18);
            }
            CFRelease(v15);
            *(_DWORD *)(v5 + 3272) = 0;
            a3[2](a3, 0LL);
            goto LABEL_31;
          }

          CFRelease(v15);
        }

        CFArrayAppendValue(*(CFMutableArrayRef *)(v5 + 1104), v8);
        *(void *)(v5 + 1120) = 0LL;
        *(void *)(v5 + 1112) = 0LL;
        *(_DWORD *)(v5 + 3272) = sub_10010824C(v5);
LABEL_31:
        CFRelease(v8);
        goto LABEL_32;
      }

      NSErrorDomain v27 = NSPOSIXErrorDomain;
      uint64_t v28 = 22LL;
      id v26 = 0LL;
      goto LABEL_46;
    }

    NSErrorDomain v29 = NSPOSIXErrorDomain;
    NSErrorUserInfoKey v32 = NSLocalizedDescriptionKey;
    NSErrorDomain v30 = @"No network specified";
  }

  else
  {
    NSErrorDomain v29 = NSPOSIXErrorDomain;
    NSErrorUserInfoKey v32 = NSLocalizedDescriptionKey;
    NSErrorDomain v30 = @"No assoc parameters specified";
  }

  __int128 v33 = v30;
  id v26 = +[NSDictionary dictionaryWithObjects:forKeys:count:]( &OBJC_CLASS___NSDictionary,  "dictionaryWithObjects:forKeys:count:",  &v33,  &v32,  1LL);
  NSErrorDomain v27 = v29;
  uint64_t v28 = 22LL;
LABEL_46:
  uint64_t v31 = +[NSError errorWithDomain:code:userInfo:]( &OBJC_CLASS___NSError,  "errorWithDomain:code:userInfo:",  v27,  v28,  v26);
  if (v31) {
    ((void (**)(void, NSError *))a3)[2](a3, v31);
  }
LABEL_32:
  objc_autoreleasePoolPop(v6);
}

void sub_1001161A4(uint64_t a1, uint64_t a2, uint64_t a3)
{
  uint64_t v4 = *(void *)(a1 + 32);
  uint64_t v5 = objc_autoreleasePoolPush();
  if (!a3) {
    goto LABEL_26;
  }
  if (!v4)
  {
    NSErrorDomain v14 = NSPOSIXErrorDomain;
    NSErrorUserInfoKey v25 = NSLocalizedDescriptionKey;
    id v15 = @"No device manager configured";
LABEL_29:
    id v26 = v15;
    unsigned int v12 = +[NSError errorWithDomain:code:userInfo:]( &OBJC_CLASS___NSError,  "errorWithDomain:code:userInfo:",  v14,  6LL,  +[NSDictionary dictionaryWithObjects:forKeys:count:]( &OBJC_CLASS___NSDictionary,  "dictionaryWithObjects:forKeys:count:",  &v26,  &v25,  1LL));
    uint64_t v7 = 0LL;
    goto LABEL_22;
  }

  if (!*(void *)(v4 + 8776))
  {
    NSErrorDomain v14 = NSPOSIXErrorDomain;
    NSErrorUserInfoKey v25 = NSLocalizedDescriptionKey;
    id v15 = @"No auto-join manager configured";
    goto LABEL_29;
  }

  uint64_t v6 = *(unsigned int *)(v4 + 6756);
  else {
    uint64_t v7 = 0LL;
  }
  if (!-[WiFiUserInteractionMonitor isSetupCompleted]( +[WiFiUserInteractionMonitor sharedInstance](&OBJC_CLASS___WiFiUserInteractionMonitor, "sharedInstance"),  "isSetupCompleted"))
  {
    NSErrorUserInfoKey v25 = NSLocalizedDescriptionKey;
    id v26 = @"Device setup not completed";
    BOOL v16 = +[NSDictionary dictionaryWithObjects:forKeys:count:]( &OBJC_CLASS___NSDictionary,  "dictionaryWithObjects:forKeys:count:",  &v26,  &v25,  1LL);
    NSErrorDomain v17 = NSPOSIXErrorDomain;
    uint64_t v18 = 6LL;
LABEL_45:
    unsigned int v12 = +[NSError errorWithDomain:code:userInfo:]( &OBJC_CLASS___NSError,  "errorWithDomain:code:userInfo:",  v17,  v18,  v16);
    goto LABEL_22;
  }

  if (!*(_DWORD *)(v4 + 6756))
  {
    NSErrorUserInfoKey v25 = NSLocalizedDescriptionKey;
    id v26 = @"autoHotspotMode==Never";
    BOOL v16 = +[NSDictionary dictionaryWithObjects:forKeys:count:]( &OBJC_CLASS___NSDictionary,  "dictionaryWithObjects:forKeys:count:",  &v26,  &v25,  1LL);
    NSErrorDomain v17 = NSPOSIXErrorDomain;
    uint64_t v18 = 1LL;
    goto LABEL_45;
  }

  if (sub_100053D08(*(void *)(v4 + 64)))
  {
    NSErrorDomain v19 = NSPOSIXErrorDomain;
    NSErrorUserInfoKey v25 = NSLocalizedDescriptionKey;
    NSErrorDomain v20 = @"IPv4/IPv6 network path already available on another interface";
LABEL_39:
    id v26 = v20;
    BOOL v16 = +[NSDictionary dictionaryWithObjects:forKeys:count:]( &OBJC_CLASS___NSDictionary,  "dictionaryWithObjects:forKeys:count:",  &v26,  &v25,  1LL);
    NSErrorDomain v17 = v19;
    uint64_t v18 = 37LL;
    goto LABEL_45;
  }

  if (*(_BYTE *)(v4 + 6976))
  {
    NSErrorDomain v21 = NSPOSIXErrorDomain;
    uint64_t v22 = +[NSString stringWithFormat:]( &OBJC_CLASS___NSString,  "stringWithFormat:",  @"AutoHotspot disabled via flags (0x%X)",  *(unsigned __int8 *)(v4 + 6976),  NSLocalizedDescriptionKey);
LABEL_43:
    id v26 = (const __CFString *)v22;
    goto LABEL_44;
  }

  if (!sub_1000F1D7C(v4)
    && (_os_feature_enabled_impl("CoreWiFi", "UnifiedAutoJoin") & 1) == 0
    && CFAbsoluteTimeGetCurrent() - *(double *)(v4 + 6904) <= 15.0)
  {
    NSErrorDomain v21 = NSPOSIXErrorDomain;
    uint64_t v22 = +[NSString stringWithFormat:]( &OBJC_CLASS___NSString,  "stringWithFormat:",  @"AutoHotspot triggered within %d seconds of previous link down",  15LL,  NSLocalizedDescriptionKey);
    goto LABEL_43;
  }

  if (-[WiFiUserInteractionMonitor isAnyCallInProgress]( +[WiFiUserInteractionMonitor sharedInstance](&OBJC_CLASS___WiFiUserInteractionMonitor, "sharedInstance"),  "isAnyCallInProgress"))
  {
    NSErrorDomain v21 = NSPOSIXErrorDomain;
    NSErrorUserInfoKey v25 = NSLocalizedDescriptionKey;
    unint64_t v23 = @"Call in progress";
LABEL_37:
    id v26 = v23;
LABEL_44:
    BOOL v16 = +[NSDictionary dictionaryWithObjects:forKeys:count:]( &OBJC_CLASS___NSDictionary,  "dictionaryWithObjects:forKeys:count:",  &v26,  &v25,  1LL);
    NSErrorDomain v17 = v21;
    uint64_t v18 = 35LL;
    goto LABEL_45;
  }

  int v8 = *(_DWORD *)(v4 + 3272);
  if (v8 == 12)
  {
    NSErrorDomain v21 = NSPOSIXErrorDomain;
    NSErrorUserInfoKey v25 = NSLocalizedDescriptionKey;
    unint64_t v23 = @"Association in progress";
    goto LABEL_37;
  }

  if ((v8 - 17) <= 3)
  {
    NSErrorDomain v21 = NSPOSIXErrorDomain;
    NSErrorUserInfoKey v25 = NSLocalizedDescriptionKey;
    unint64_t v23 = @"AutoHotspot connection in progress";
    goto LABEL_37;
  }

  if (*(_BYTE *)(v4 + 6848))
  {
    NSErrorDomain v19 = NSPOSIXErrorDomain;
    NSErrorUserInfoKey v25 = NSLocalizedDescriptionKey;
    NSErrorDomain v20 = @"Already associated to hotspot";
    goto LABEL_39;
  }

  uint64_t v9 = *(void *)(v4 + 64);
  int v10 = (const void *)sub_100043E8C(v9);
  uint64_t v11 = sub_100040538(v9, v10);
  if (v11)
  {
    NSErrorDomain v24 = v11;
    id v26 = +[NSString stringWithFormat:]( &OBJC_CLASS___NSString,  "stringWithFormat:",  @"Already associated to %@",  sub_100095BC8(v11),  NSLocalizedDescriptionKey);
    unsigned int v12 = +[NSError errorWithDomain:code:userInfo:]( &OBJC_CLASS___NSError,  "errorWithDomain:code:userInfo:",  NSPOSIXErrorDomain,  37LL,  +[NSDictionary dictionaryWithObjects:forKeys:count:]( &OBJC_CLASS___NSDictionary,  "dictionaryWithObjects:forKeys:count:",  &v26,  &v25,  1LL));
    CFRelease(v24);
    goto LABEL_22;
  }

  if ((_os_feature_enabled_impl("CoreWiFi", "UnifiedAutoJoin") & 1) == 0
    && CFAbsoluteTimeGetCurrent() - *(double *)(v4 + 6896) <= 180.0)
  {
    NSErrorDomain v21 = NSPOSIXErrorDomain;
    uint64_t v22 = +[NSString stringWithFormat:]( &OBJC_CLASS___NSString,  "stringWithFormat:",  @"AutoHotspot triggered within %d seconds of previous browse attempt",  180LL,  NSLocalizedDescriptionKey);
    goto LABEL_43;
  }

  unsigned int v12 = 0LL;
LABEL_22:
  if (v12) {
    uint64_t v13 = 0LL;
  }
  else {
    uint64_t v13 = v7;
  }
  (*(void (**)(uint64_t, uint64_t, NSError *))(a3 + 16))(a3, v13, v12);
LABEL_26:
  objc_autoreleasePoolPop(v5);
}

void sub_100116724(uint64_t a1, uint64_t a2, uint64_t a3)
{
  uint64_t v5 = *(void *)(a1 + 32);
  uint64_t v6 = objc_autoreleasePoolPush();
  if (a3)
  {
    if (v5)
    {
      if (*(void *)(v5 + 8776))
      {
        if (!a2)
        {
          NSErrorUserInfoKey v40 = NSLocalizedDescriptionKey;
          NSErrorDomain v41 = @"No hotspot specified";
          __int128 v33 = +[NSDictionary dictionaryWithObjects:forKeys:count:]( &OBJC_CLASS___NSDictionary,  "dictionaryWithObjects:forKeys:count:",  &v41,  &v40,  1LL);
          NSErrorDomain v34 = NSPOSIXErrorDomain;
          uint64_t v35 = 22LL;
          goto LABEL_45;
        }

        CFIndex Count = CFArrayGetCount(*(CFArrayRef *)(v5 + 6864));
        CFIndex v8 = CFArrayGetCount(*(CFArrayRef *)(v5 + 6872));
        CFIndex v9 = CFArrayGetCount(*(CFArrayRef *)(v5 + 6880));
        id v10 = [*(id *)(v5 + 6888) count];
        if (Count >= 1)
        {
          if (objc_msgSend( *(id *)(v5 + 6728),  "isEqualHotspotDevices:compareTo:",  CFArrayGetValueAtIndex(*(CFArrayRef *)(v5 + 6864), 0),  a2)) {
            goto LABEL_7;
          }
          CFIndex v13 = 1LL;
          do
          {
            if (Count == v13) {
              goto LABEL_12;
            }
          }

          while (![*(id *)(v5 + 6728) isEqualHotspotDevices:CFArrayGetValueAtIndex(*(CFArrayRef *)(v5 + 6864), v13++) compareTo:a2]);
          if (Count > v13 - 1)
          {
LABEL_7:
            NSErrorDomain v11 = NSPOSIXErrorDomain;
            NSErrorUserInfoKey v40 = NSLocalizedDescriptionKey;
            unsigned int v12 = @"Hotspot suppressed/canceled by user";
            goto LABEL_43;
          }
        }

void sub_100116D08(uint64_t a1, uint64_t a2, unint64_t a3, char a4, void *a5)
{
  uint64_t v9 = *(void *)(a1 + 32);
  id v10 = objc_autoreleasePoolPush();
  if (!a5) {
    goto LABEL_15;
  }
  if (!v9)
  {
    NSErrorDomain v17 = NSPOSIXErrorDomain;
    NSErrorUserInfoKey v19 = NSLocalizedDescriptionKey;
    double v18 = @"No device manager configured";
LABEL_19:
    CFIndex v20 = v18;
    CFIndex v13 = +[NSError errorWithDomain:code:userInfo:]( &OBJC_CLASS___NSError,  "errorWithDomain:code:userInfo:",  v17,  6LL,  +[NSDictionary dictionaryWithObjects:forKeys:count:]( &OBJC_CLASS___NSDictionary,  "dictionaryWithObjects:forKeys:count:",  &v20,  &v19,  1LL));
    if (!v13) {
      goto LABEL_15;
    }
    NSErrorDomain v11 = (void (*)(void *, NSError *, void))a5[2];
    unsigned int v12 = a5;
LABEL_10:
    v11(v12, v13, 0LL);
    goto LABEL_15;
  }

  if (!*(void *)(v9 + 8776))
  {
    NSErrorDomain v17 = NSPOSIXErrorDomain;
    NSErrorUserInfoKey v19 = NSLocalizedDescriptionKey;
    double v18 = @"No auto-join manager configured";
    goto LABEL_19;
  }

  if (!*(void *)(v9 + 6728))
  {
    NSErrorDomain v17 = NSPOSIXErrorDomain;
    NSErrorUserInfoKey v19 = NSLocalizedDescriptionKey;
    double v18 = @"No hotspot interface manager configured";
    goto LABEL_19;
  }

  if (CFAbsoluteTimeGetCurrent() - *(double *)(v9 + 6800) <= (double)a3 && [*(id *)(v9 + 6792) count])
  {
    ((void (*)(void *, void, id))a5[2])( a5,  0,  [*(id *)(v9 + 6792) copy]);
    goto LABEL_15;
  }

  if ((a4 & 1) != 0)
  {
    NSErrorDomain v11 = (void (*)(void *, NSError *, void))a5[2];
    unsigned int v12 = a5;
    CFIndex v13 = 0LL;
    goto LABEL_10;
  }

  uint64_t v14 = *(void *)(v9 + 8816);
  if (v14)
  {
    (*(void (**)(uint64_t, NSError *, void))(v14 + 16))( v14,  +[NSError errorWithDomain:code:userInfo:]( &OBJC_CLASS___NSError,  "errorWithDomain:code:userInfo:",  NSPOSIXErrorDomain,  89LL,  0LL),  0LL);
    _Block_release(*(const void **)(v9 + 8816));
  }

  *(void *)(v9 + 8816) = _Block_copy(a5);
  CFArrayRemoveAllValues(*(CFMutableArrayRef *)(v9 + 6792));
  uint64_t v15 = *(dispatch_source_s **)(v9 + 6760);
  dispatch_time_t v16 = dispatch_time(0LL, 1000000000 * a2);
  dispatch_source_set_timer(v15, v16, 0xFFFFFFFFFFFFFFFFLL, 0LL);
  *(_DWORD *)(v9 + 3272) = 16;
  [*(id *)(v9 + 6728) startBrowsing];
  *(CFAbsoluteTime *)(v9 + 6912) = CFAbsoluteTimeGetCurrent();
  ++*(_DWORD *)(v9 + 6164);
LABEL_15:
  objc_autoreleasePoolPop(v10);
}

void sub_100116F78(uint64_t a1, void *a2, void (**a3)(void, void))
{
  uint64_t v5 = *(void *)(a1 + 32);
  uint64_t v6 = objc_autoreleasePoolPush();
  if (!a3) {
    goto LABEL_9;
  }
  if (!v5)
  {
    NSErrorDomain v8 = NSPOSIXErrorDomain;
    NSErrorUserInfoKey v16 = NSLocalizedDescriptionKey;
    uint64_t v9 = @"No device manager configured";
LABEL_12:
    NSErrorDomain v17 = v9;
    id v10 = +[NSDictionary dictionaryWithObjects:forKeys:count:]( &OBJC_CLASS___NSDictionary,  "dictionaryWithObjects:forKeys:count:",  &v17,  &v16,  1LL);
    NSErrorDomain v11 = v8;
    uint64_t v12 = 6LL;
    goto LABEL_16;
  }

  if (!*(void *)(v5 + 8776))
  {
    NSErrorDomain v8 = NSPOSIXErrorDomain;
    NSErrorUserInfoKey v16 = NSLocalizedDescriptionKey;
    uint64_t v9 = @"No auto-join manager configured";
    goto LABEL_12;
  }

  if (sub_100053D08(*(void *)(v5 + 64)))
  {
    NSErrorDomain v13 = NSPOSIXErrorDomain;
    NSErrorUserInfoKey v16 = NSLocalizedDescriptionKey;
    uint64_t v14 = @"IPv4/IPv6 network path already available on another interface";
  }

  else
  {
    if (a2)
    {
      uint64_t v7 = *(const void **)(v5 + 8808);
      if (v7)
      {
        _Block_release(v7);
      }

      *(void *)(v5 + 880_Block_object_dispose(va, 8) = _Block_copy(a3);
      *(void *)(v5 + 8800) = a2;
      CFArrayRemoveAllValues(*(CFMutableArrayRef *)(v5 + 6792));
      CFArrayAppendValue(*(CFMutableArrayRef *)(v5 + 6792), a2);
      *(_DWORD *)(v5 + 6840) = 2;
      *(void *)(v5 + 6832) = 0x300000002LL;
      *(_BYTE *)(v5 + 6920) = 0;
      *(_DWORD *)(v5 + 3272) = sub_100102F9C(v5);
      goto LABEL_9;
    }

    NSErrorDomain v13 = NSPOSIXErrorDomain;
    NSErrorUserInfoKey v16 = NSLocalizedDescriptionKey;
    uint64_t v14 = @"No hotspot specified";
  }

  NSErrorDomain v17 = v14;
  id v10 = +[NSDictionary dictionaryWithObjects:forKeys:count:]( &OBJC_CLASS___NSDictionary,  "dictionaryWithObjects:forKeys:count:",  &v17,  &v16,  1LL);
  NSErrorDomain v11 = v13;
  uint64_t v12 = 22LL;
LABEL_16:
  uint64_t v15 = +[NSError errorWithDomain:code:userInfo:]( &OBJC_CLASS___NSError,  "errorWithDomain:code:userInfo:",  v11,  v12,  v10);
  if (v15) {
    ((void (**)(void, NSError *))a3)[2](a3, v15);
  }
LABEL_9:
  objc_autoreleasePoolPop(v6);
}

void sub_10011719C(uint64_t a1, void *a2, void *a3, uint64_t a4)
{
  uint64_t v7 = *(void *)(a1 + 32);
  NSErrorDomain v8 = objc_autoreleasePoolPush();
  if (v7)
  {
    uint64_t v9 = *(void **)(v7 + 8776);
    if (v9)
    {
      if (a4 != 1 || *(void *)(v7 + 8824))
      {
        if (a4)
        {
          [+[WiFiXPCManager sharedXPCManager](WiFiXPCManager, "sharedXPCManager") autoJoinUpdatedWithState:a4 interfaceName:sub_100043E8C(*(void *)(v7 + 64))];
        }

        else
        {
          id v12 = [v9 metric];
          objc_msgSend( +[WiFiXPCManager sharedXPCManager](WiFiXPCManager, "sharedXPCManager"),  "autoJoinEndedWithResult:interfaceName:",  objc_msgSend(v12, "result"),  sub_100043E8C(*(void *)(v7 + 64)));
          if ([v12 result])
          {
            NSErrorDomain v13 = sub_100117C28([v12 network]);
            sub_10010D14C(v7, @"autoJoinSuccess", v13, (uint64_t)v12);
            if (v13) {
              CFRelease(v13);
            }
          }

          else
          {
            if ([v12 error])
            {
              uint64_t v14 = off_1001E37C0;
            }

            else if ([v12 wasAlreadyAssociated])
            {
              uint64_t v14 = off_1001E3798;
            }

            else
            {
              uint64_t v14 = off_1001E37B0;
            }

            sub_10010D14C(v7, *v14, 0LL, (uint64_t)v12);
          }

          else {
            double v15 = 14.0;
          }
          id v16 = [v12 network];
          if (v16)
          {
            NSErrorDomain v17 = v16;
            if (objc_msgSend(objc_msgSend(v16, "matchingKnownNetworkProfile"), "addReason") == (id)8
              && !objc_msgSend(objc_msgSend(v17, "matchingKnownNetworkProfile"), "lastJoinedBySystemAt")
              && v15 > (double)((unint64_t)[v12 duration] / 0x3E8))
            {
              double v18 = sub_1000A3DB0(v17);
              NSErrorUserInfoKey v19 = objc_autoreleasePoolPush();
              if (qword_100219F60) {
                [(id)qword_100219F60 WFLog:3, "%s Updating 6G standalone property after iCloud sync on %@", "__WiFiDeviceManagerUnifiedAutoJoinCheckForStandalone6G", v18 message];
              }
              objc_autoreleasePoolPop(v19);
              sub_1000DACEC(v7, v18);
              if (v18) {
                CFRelease(v18);
              }
            }
          }

          sub_1000FFC68(v7);
          if (*(_DWORD *)(v7 + 3272) == 16) {
            sub_1000CABEC(v7, 0);
          }
        }
      }

      else
      {
        id v10 = *(void **)(v7 + 8856);
        if (v10)
        {
          sub_10004A048( *(void *)(v7 + 64),  0,  +[NSString stringWithFormat:]( NSString,  "stringWithFormat:",  @"%@/%@",  @"AutoJoin",  [v10 UUIDString]),  0);
          sub_10004A048( *(void *)(v7 + 64),  9,  +[NSString stringWithFormat:]( NSString,  "stringWithFormat:",  @"%@/%@",  @"AutoJoin",  [*(id *)(v7 + 8856) UUIDString]),  0);
          NSErrorDomain v11 = *(void **)(v7 + 8856);
        }

        else
        {
          NSErrorDomain v11 = 0LL;
        }

        *(void *)(v7 + 8872) = 0LL;
        *(void *)(v7 + 8864) = 0LL;

        *(void *)(v7 + 8856) = [a2 copy];
        objc_msgSend( +[WiFiXPCManager sharedXPCManager](WiFiXPCManager, "sharedXPCManager"),  "autoJoinStartedWithTrigger:interfaceName:",  objc_msgSend(a3, "trigger"),  sub_100043E8C(*(void *)(v7 + 64)));
        sub_10010D14C(v7, @"kWiFiAutoJoinStatusBegan", 0LL, 0LL);
      }

      *(void *)(v7 + 8824) = a4;
      *(void *)(v7 + 8832) = [a3 trigger];
    }
  }

  objc_autoreleasePoolPop(v8);
}

void sub_100117528(uint64_t a1, void *a2, uint64_t a3)
{
  uint64_t v5 = *(void **)(a1 + 32);
  uint64_t v6 = objc_autoreleasePoolPush();
  uint64_t v7 = 0LL;
  if (a2 && a3 && v5)
  {
    if (!v5[1097] || !v5[564] || (NSErrorDomain v8 = sub_1000A1DEC(a2, 0LL)) == 0LL)
    {
      uint64_t v7 = 0LL;
      goto LABEL_14;
    }

    uint64_t v9 = v8;
    id v10 = (CFDictionaryRef *)sub_1000D91B0((uint64_t)v5, v8, 0);
    if (!v10)
    {
      uint64_t v7 = 0LL;
LABEL_13:
      CFRelease(v9);
      goto LABEL_14;
    }

    NSErrorDomain v11 = v10;
    uint64_t v7 = sub_1000A063C(v10);
    if (v7 && (id v12 = (void *)(*(uint64_t (**)(uint64_t, void *))(a3 + 16))(a3, v7)) != 0LL)
    {
      NSErrorDomain v13 = sub_1000A1DEC(v12, 0LL);
      if (v13) {
        ((void (*)(void *, _WORD *, void))v5[564])(v5, v13, v5[565]);
      }
    }

    else
    {
      NSErrorDomain v13 = 0LL;
    }

    CFRelease(v9);
    CFRelease(v11);
    uint64_t v9 = v13;
    if (v13) {
      goto LABEL_13;
    }
  }

BOOL sub_100117634(uint64_t a1, const void *a2)
{
  if (!a1) {
    return 0LL;
  }
  BOOL v3 = 0LL;
  if (a2 && *(void *)(a1 + 8776))
  {
    CFMutableArrayRef Mutable = *(__CFArray **)(a1 + 1104);
    if (!Mutable)
    {
      CFMutableArrayRef Mutable = CFArrayCreateMutable(kCFAllocatorDefault, 0LL, &kCFTypeArrayCallBacks);
      *(void *)(a1 + 1104) = Mutable;
    }

    CFArrayRemoveAllValues(Mutable);
    CFArrayRemoveAllValues(*(CFMutableArrayRef *)(a1 + 3552));
    CFArrayRemoveAllValues(*(CFMutableArrayRef *)(a1 + 3560));
    [*(id *)(a1 + 3648) clearScanResultsForAutoJoinSessionReset];
    CFArrayAppendValue(*(CFMutableArrayRef *)(a1 + 1104), a2);
    sub_100106AF8(a1);
    BOOL v3 = CFArrayGetCount(*(CFArrayRef *)(a1 + 3560)) > 0
      || CFArrayGetCount(*(CFArrayRef *)(a1 + 3552)) > 0
      || !CFArrayGetCount(*(CFArrayRef *)(a1 + 1104));
    CFArrayRemoveAllValues(*(CFMutableArrayRef *)(a1 + 3552));
    CFArrayRemoveAllValues(*(CFMutableArrayRef *)(a1 + 3560));
    [*(id *)(a1 + 3648) clearScanResultsForAutoJoinSessionReset];
    CFArrayRemoveAllValues(*(CFMutableArrayRef *)(a1 + 1104));
  }

  return v3;
}

void sub_10011772C( uint64_t a1, uint64_t a2, const __CFArray *a3, const __CFDictionary *a4, int a5, uint64_t *a6)
{
  id v10 = objc_autoreleasePoolPush();
  if (a6)
  {
    uint64_t v11 = *a6;
    id v12 = objc_autoreleasePoolPush();
    if (v11)
    {
      if (*(void *)(v11 + 8880))
      {
        NSErrorDomain v13 = *(void **)(v11 + 8888);
        if (v13)
        {
          if (a4)
          {
            CFBooleanRef Value = (const __CFBoolean *)CFDictionaryGetValue(a4, @"CompletedUsingCache");
            NSErrorDomain v13 = *(void **)(v11 + 8888);
          }

          else
          {
            CFBooleanRef Value = kCFBooleanFalse;
          }

          unsigned int v15 = [v13 scanType];
          if (a5 || (id v17 = +[NSMutableArray array](&OBJC_CLASS___NSMutableArray, "array"), !a3))
          {
            uint64_t v16 = 0LL;
          }

          else
          {
            double v18 = v17;
            NSErrorDomain v29 = Value;
            NSErrorUserInfoKey v19 = v12;
            if (CFArrayGetCount(a3) >= 1)
            {
              CFIndex v20 = 0LL;
              do
              {
                id v21 = objc_autoreleasePoolPush();
                ValueAtIndex = CFArrayGetValueAtIndex(a3, v20);
                if (ValueAtIndex)
                {
                  id v23 = sub_1000A335C((uint64_t)ValueAtIndex);
                  if (v23) {
                    [v18 addObject:v23];
                  }
                }

                objc_autoreleasePoolPop(v21);
                ++v20;
              }

              while (CFArrayGetCount(a3) > v20);
            }

            uint64_t v16 = CWFFilteredScanResults(v18, *(void *)(v11 + 8888));
            NSErrorDomain v24 = *(__CFArray **)(v11 + 1096);
            v30.length = CFArrayGetCount(a3);
            v30.location = 0LL;
            CFArrayAppendArray(v24, a3, v30);
            id v12 = v19;
            CFBooleanRef Value = v29;
          }

          if (v15 == 3 || Value != kCFBooleanFalse)
          {
            NSErrorUserInfoKey v25 = *(char **)(v11 + 8864);
          }

          else
          {
            NSErrorUserInfoKey v25 = (char *)objc_msgSend(objc_msgSend(*(id *)(v11 + 8888), "channels"), "count") + *(void *)(v11 + 8864);
            *(void *)(v11 + 8864) = v25;
            if (!*(_BYTE *)(v11 + 9012)) {
              *(_BYTE *)(v11 + 9012) = 1;
            }
          }

          if ((unint64_t)v25 >= 6 && *(void *)(v11 + 8872))
          {
            sub_10004A048( *(void *)(v11 + 64),  0,  +[NSString stringWithFormat:]( NSString,  "stringWithFormat:",  @"%@/%@",  @"AutoJoin",  [*(id *)(v11 + 8856) UUIDString]),  0);
            sub_10004A048( *(void *)(v11 + 64),  9,  +[NSString stringWithFormat:]( NSString,  "stringWithFormat:",  @"%@/%@",  @"AutoJoin",  [*(id *)(v11 + 8856) UUIDString]),  0);
          }

          uint64_t v26 = *(void *)(v11 + 8880);
          if (a5) {
            NSErrorDomain v27 = +[NSError errorWithDomain:code:userInfo:]( &OBJC_CLASS___NSError,  "errorWithDomain:code:userInfo:",  CWFManagerErrorDomain,  a5,  0LL);
          }
          else {
            NSErrorDomain v27 = 0LL;
          }
          id v28 = 0LL;
          if (v15 != 3 && Value != kCFBooleanTrue) {
            id v28 = [*(id *)(v11 + 8888) channels];
          }
          (*(void (**)(uint64_t, NSError *, uint64_t, id))(v26 + 16))(v26, v27, v16, v28);
          _Block_release(*(const void **)(v11 + 8880));
          *(void *)(v11 + 8880) = 0LL;

          *(void *)(v11 + 888_Block_object_dispose(va, 8) = 0LL;
        }
      }
    }

    objc_autoreleasePoolPop(v12);
    free(a6);
  }

  objc_autoreleasePoolPop(v10);
}

void sub_100117A40( uint64_t a1, uint64_t a2, const __CFArray *a3, const __CFDictionary *a4, int a5, uint64_t *a6)
{
  id v10 = objc_autoreleasePoolPush();
  if (a6)
  {
    if (a3 && CFArrayGetCount(a3)) {
      sub_10010D7C8(*a6, a3);
    }
    uint64_t v11 = *a6;
    id v12 = objc_autoreleasePoolPush();
    if (!v11 || !*(void *)(v11 + 8896) || !*(void *)(v11 + 8904)) {
      goto LABEL_26;
    }
    if (a4)
    {
      CFBooleanRef Value = (const __CFBoolean *)CFDictionaryGetValue(a4, @"CompletedUsingCache");
      if (a5)
      {
LABEL_10:
        uint64_t v14 = *(void *)(v11 + 8896);
        unsigned int v15 = +[NSError errorWithDomain:code:userInfo:]( &OBJC_CLASS___NSError,  "errorWithDomain:code:userInfo:",  CWFManagerErrorDomain,  a5,  0LL);
        uint64_t v16 = 0LL;
LABEL_22:
        if (Value == kCFBooleanTrue) {
          id v23 = 0LL;
        }
        else {
          id v23 = [*(id *)(v11 + 8904) scanResults];
        }
        (*(void (**)(uint64_t, NSError *, uint64_t, id))(v14 + 16))(v14, v15, v16, v23);
        _Block_release(*(const void **)(v11 + 8896));
        *(void *)(v11 + 8896) = 0LL;

        *(void *)(v11 + 8904) = 0LL;
LABEL_26:
        objc_autoreleasePoolPop(v12);
        free(a6);
        goto LABEL_27;
      }
    }

    else
    {
      CFBooleanRef Value = kCFBooleanFalse;
      if (a5) {
        goto LABEL_10;
      }
    }

    id v17 = +[NSMutableArray array](&OBJC_CLASS___NSMutableArray, "array");
    if (a3)
    {
      double v18 = v17;
      if (CFArrayGetCount(a3) >= 1)
      {
        CFIndex v19 = 0LL;
        do
        {
          CFIndex v20 = objc_autoreleasePoolPush();
          ValueAtIndex = CFArrayGetValueAtIndex(a3, v19);
          if (ValueAtIndex)
          {
            id v22 = sub_1000A335C((uint64_t)ValueAtIndex);
            if (v22) {
              [v18 addObject:v22];
            }
          }

          objc_autoreleasePoolPop(v20);
          ++v19;
        }

        while (CFArrayGetCount(a3) > v19);
      }

      uint64_t v16 = CWFFilteredANQPResults(v18, *(void *)(v11 + 8904));
    }

    else
    {
      uint64_t v16 = 0LL;
    }

    unsigned int v15 = 0LL;
    uint64_t v14 = *(void *)(v11 + 8896);
    goto LABEL_22;
  }

_WORD *sub_100117C28(_WORD *a1)
{
  id v2 = objc_autoreleasePoolPush();
  if (a1)
  {
    id v3 = [a1 matchingKnownNetworkProfile];
    if (!v3) {
      goto LABEL_9;
    }
    uint64_t v4 = v3;
    a1 = [a1 scanRecord];
    if (!a1) {
      goto LABEL_8;
    }
    uint64_t v5 = (const __CFDictionary *)sub_1000A1DEC(v4, [v4 properties]);
    if (!v5)
    {
LABEL_9:
      a1 = 0LL;
      goto LABEL_8;
    }

    CFDictionaryRef v6 = v5;
    CFDictionaryRef v7 = sub_100012CEC((uint64_t)v5);
    if (v7)
    {
      CFDictionaryRef v8 = v7;
      id v9 = +[NSMutableDictionary dictionary](&OBJC_CLASS___NSMutableDictionary, "dictionary");
      [v9 addEntriesFromDictionary:v8];
      [v9 addEntriesFromDictionary:a1];
      a1 = sub_100094AAC((uint64_t)kCFAllocatorDefault, v9);
      sub_100095524((uint64_t)a1, (uint64_t)v6);
      CFRelease(v6);
      CFDictionaryRef v6 = v8;
    }

    else
    {
      a1 = 0LL;
    }

    CFRelease(v6);
  }

uint64_t sub_100117D1C(uint64_t a1, const void *a2, uint64_t a3, void *a4, void *a5)
{
  uint64_t v9 = a1;
  id v10 = (void *)sub_100055900(a1);
  if (a5)
  {
    uint64_t v11 = (void (*)(void, const void *, void *, uint64_t, void))a5[1];
    if (v11) {
      v11(*a5, a2, v10, a3, a5[3]);
    }
  }

  if (CFArrayGetCount((CFArrayRef)v10))
  {
    unsigned int v12 = objc_msgSend( objc_msgSend(a4, "objectForKeyedSubscript:", @"SENSING_PARAMS_SUBMIT_METRIC"),  "BOOLValue");
    if (_os_feature_enabled_impl("WiFiManager", "Sensing"))
    {
      int v13 = MGGetBoolAnswer(@"InternalBuild");
      unsigned int v14 = v10 ? v12 : 0;
      if (v13 && v14)
      {
        NSErrorDomain v39 = a4;
        unsigned int v15 = objc_autoreleasePoolPush();
        if (qword_100219F60) {
          [qword_100219F60 WFLog:@"Sensing %s: submitMetric: %d" message:3];
        }
        objc_autoreleasePoolPop(v15);
        NSErrorDomain v34 = +[NSUserDefaults standardUserDefaults](&OBJC_CLASS___NSUserDefaults, "standardUserDefaults");
        uint64_t v16 = -[NSUserDefaults dictionaryForKey:](v34, "dictionaryForKey:", @"WIFI_SENSING");
        id v17 = v16;
        if (v16)
        {
          [v16 objectForKeyedSubscript:@"SENSING_RESULTS_DATA_TIMESTAMP"] doubleValue];
          uint64_t v19 = v18;
          CFIndex v20 = objc_autoreleasePoolPush();
          if (qword_100219F60) {
            [qword_100219F60 WFLog:@"Sensing lastSensingSubmitTimestamp %lf" message:3];
          }
          objc_autoreleasePoolPop(v20);
        }

        uint64_t v52 = 0LL;
        __int128 v53 = &v52;
        uint64_t v54 = 0x3052000000LL;
        CFIndex v55 = sub_1000F3F84;
        BOOL v56 = sub_1000F3F94;
        BOOL v57 = (NSMutableDictionary *)0xAAAAAAAAAAAAAAAALL;
        unsigned int v35 = a3;
        __int128 v36 = a5;
        uint64_t v37 = v9;
        NSErrorDomain v38 = a2;
        BOOL v57 = objc_alloc_init(&OBJC_CLASS___NSMutableDictionary);
        __int128 v48 = 0u;
        __int128 v49 = 0u;
        __int128 v50 = 0u;
        __int128 v51 = 0u;
        id v21 = [v10 countByEnumeratingWithState:&v48 objects:v59 count:16];
        if (v21)
        {
          uint64_t v40 = *(void *)v49;
          do
          {
            id v22 = 0LL;
            id v41 = v21;
            do
            {
              if (*(void *)v49 != v40) {
                objc_enumerationMutation(v10);
              }
              id v23 = *(void **)(*((void *)&v48 + 1) + 8LL * (void)v22);
              __int128 v44 = 0u;
              __int128 v45 = 0u;
              __int128 v46 = 0u;
              __int128 v47 = 0u;
              id v24 = [&off_100205858 countByEnumeratingWithState:&v44 objects:v58 count:16];
              if (v24)
              {
                uint64_t v25 = *(void *)v45;
                do
                {
                  for (CFIndex i = 0LL; i != v24; CFIndex i = (char *)i + 1)
                  {
                    if (*(void *)v45 != v25) {
                      objc_enumerationMutation(&off_100205858);
                    }
                    uint64_t v27 = *(void *)(*((void *)&v44 + 1) + 8LL * (void)i);
                    id v28 = objc_msgSend( objc_msgSend(v23, "objectForKeyedSubscript:", v27),  "componentsSeparatedByString:",  @":");
                    if ([v28 count] == (id)6) {
                      [v23 setObject:[v28 objectAtIndexedSubscript:5] forKeyedSubscript:v27];
                    }
                    else {
                      [v23 setObject:@"NA" forKeyedSubscript:v27];
                    }
                  }

                  id v24 = [&off_100205858 countByEnumeratingWithState:&v44 objects:v58 count:16];
                }

                while (v24);
              }

              id v22 = (char *)v22 + 1;
            }

            while (v22 != v41);
            id v21 = [v10 countByEnumeratingWithState:&v48 objects:v59 count:16];
          }

          while (v21);
        }

        [(id)v53[5] setObject:v10 forKey:@"SENSING_RESULTS_DATA"];
        if ([v39 objectForKeyedSubscript:@"SENSING_PARAMS_ACTIVITY_LABELS"]) {
          objc_msgSend( (id)v53[5],  "setObject:forKey:",  objc_msgSend(v39, "objectForKeyedSubscript:", @"SENSING_PARAMS_ACTIVITY_LABELS"),  @"SENSING_PARAMS_ACTIVITY_LABELS");
        }
        if ([v39 objectForKeyedSubscript:@"SENSING_PARAMS_PLACE_LABELS"]) {
          objc_msgSend( (id)v53[5],  "setObject:forKey:",  objc_msgSend(v39, "objectForKeyedSubscript:", @"SENSING_PARAMS_PLACE_LABELS"),  @"SENSING_PARAMS_PLACE_LABELS");
        }
        if ([v39 objectForKeyedSubscript:@"SENSING_PARAMS_ACTIVITY_VALUE"]) {
          objc_msgSend( (id)v53[5],  "setObject:forKey:",  objc_msgSend(v39, "objectForKeyedSubscript:", @"SENSING_PARAMS_ACTIVITY_VALUE"),  @"SENSING_PARAMS_ACTIVITY_VALUE");
        }
        if ([v39 objectForKeyedSubscript:@"SENSING_PARAMS_COMMENT"]) {
          objc_msgSend( (id)v53[5],  "setObject:forKey:",  objc_msgSend(v39, "objectForKeyedSubscript:", @"SENSING_PARAMS_COMMENT"),  @"SENSING_PARAMS_COMMENT");
        }
        id v43 = 0LL;
        v42[0] = _NSConcreteStackBlock;
        v42[1] = 3221225472LL;
        void v42[2] = sub_1001183A4;
        void v42[3] = &unk_1001E53C0;
        v42[4] = &v52;
        uint64_t v9 = v37;
        a2 = v38;
        a5 = v36;
        a3 = v35;
        if (+[OSALog createForSubmission:metadata:options:error:writing:]( &OBJC_CLASS___OSALog,  "createForSubmission:metadata:options:error:writing:",  @"235",  0LL,  0LL,  &v43,  v42))
        {
          NSErrorDomain v29 = +[NSMutableDictionary dictionaryWithDictionary:]( &OBJC_CLASS___NSMutableDictionary,  "dictionaryWithDictionary:",  v17);
          -[NSMutableDictionary setObject:forKeyedSubscript:]( v29,  "setObject:forKeyedSubscript:",  +[NSNumber numberWithDouble:](&OBJC_CLASS___NSNumber, "numberWithDouble:", CFAbsoluteTimeGetCurrent()),  @"SENSING_RESULTS_DATA_TIMESTAMP");
          -[NSUserDefaults setObject:forKey:](v34, "setObject:forKey:", v29, @"WIFI_SENSING");
          CFRange v30 = objc_autoreleasePoolPush();
          if (qword_100219F60) {
            [(id)qword_100219F60 WFLog:3, "Sensing submit - updating the last submitted timestamp %@", v29 message];
          }
        }

        else
        {
          CFRange v30 = objc_autoreleasePoolPush();
          if (qword_100219F60) {
            [(id)qword_100219F60 WFLog:4, "WiFiSensing Failed to write 235 report: %@", objc_msgSend(v43, "localizedDescription") message];
          }
        }

        objc_autoreleasePoolPop(v30);
        uint64_t v31 = (const void *)v53[5];
        if (v31)
        {
          CFRelease(v31);
          v53[5] = 0LL;
        }

        _Block_object_dispose(&v52, 8);
      }
    }
  }

  if (a5)
  {
    NSErrorUserInfoKey v32 = (void (*)(void, const void *, void *, uint64_t, void))a5[1];
    if (v32) {
      v32(*a5, a2, v10, a3, a5[3]);
    }
    CFRelease((CFTypeRef)a5[2]);
    free(a5);
  }

  sub_1000558DC(v9, 0);
  sub_1000558CC(v9);
  return sub_10005571C(v9, a2);
}

void sub_100118364( _Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20, uint64_t a21, uint64_t a22, uint64_t a23, uint64_t a24, uint64_t a25, uint64_t a26, uint64_t a27, uint64_t a28, uint64_t a29, uint64_t a30, uint64_t a31, uint64_t a32, uint64_t a33, uint64_t a34, uint64_t a35, uint64_t a36, uint64_t a37, uint64_t a38, uint64_t a39, uint64_t a40, uint64_t a41, uint64_t a42, char a43)
{
}

void sub_1001183A4(uint64_t a1, void *a2)
{
  uint64_t v3 = 0LL;
  [a2 writeData:[NSJSONSerialization dataWithJSONObject:options:error:]( NSJSONSerialization,  "dataWithJSONObject:options:error:",  *(void *)(*(void *)(*(void *)(a1 + 32) + 8) + 40),  0,  &v3)];
  id v2 = objc_autoreleasePoolPush();
  if (qword_100219F60) {
    [(id)qword_100219F60 WFLog:3 message:"Sensing Finished submitting Record\n"];
  }
  objc_autoreleasePoolPop(v2);
}

uint64_t sub_10011842C(uint64_t a1)
{
  return close(*(_DWORD *)(a1 + 32));
}

void sub_100118434(uint64_t a1)
{
  ssize_t v2 = read(*(_DWORD *)(a1 + 40), __b, 0x400uLL);
  if (v2 >= 1)
  {
    ssize_t v3 = v2;
    ssize_t v4 = 0LL;
    uint64_t v5 = __b;
    while (1)
    {
      uint64_t v6 = *(unsigned int *)&__b[v4];
      if (v6 <= 0x2F)
      {
        id v10 = objc_autoreleasePoolPush();
        if (qword_100219F60) {
          [qword_100219F60 WFLog:@"__WiFiDeviceManagerSetupKernelEventMonitor_block_invoke_2: not enough bytes read for event data"];
        }
        goto LABEL_17;
      }

      memset(__str, 170, sizeof(__str));
      snprintf(__str, 0x10uLL, "%s%u", v5 + 32, *((_DWORD *)v5 + 7));
      CFDictionaryRef v7 = +[NSString stringWithCString:encoding:](&OBJC_CLASS___NSString, "stringWithCString:encoding:", __str, 4LL);
      if (!v7)
      {
        id v10 = objc_autoreleasePoolPush();
        if (qword_100219F60) {
          [qword_100219F60 WFLog:@"%s: null ifName" message:4];
        }
        goto LABEL_17;
      }

      if (*((_DWORD *)v5 + 5) == 1)
      {
        CFDictionaryRef v8 = v7;
        uint64_t v9 = (const void *)sub_10004CE2C(*(void *)(*(void *)(a1 + 32) + 64LL));
        if (CFEqual(v9, v8)) {
          sub_10011861C(*(void *)(a1 + 32));
        }
      }

      v4 += *(unsigned int *)&__b[v4];
      uint64_t v5 = &__b[v4];
      if (v4 >= v3) {
        return;
      }
    }

    id v10 = objc_autoreleasePoolPush();
    if (qword_100219F60) {
      [qword_100219F60 WFLog:@"%s: not enough bytes read" message:4];
    }
LABEL_17:
    objc_autoreleasePoolPop(v10);
  }

void sub_10011861C(uint64_t a1)
{
  __int128 v9 = 0u;
  __int128 v10 = 0u;
  if (a1)
  {
    ssize_t v2 = (_BYTE *)(a1 + 8952);
    if (!*(_BYTE *)(a1 + 8952))
    {
      uint64_t v3 = sub_10004CE2C(*(void *)(a1 + 64));
      if (v3)
      {
        ssize_t v4 = (void *)v3;
        int v5 = socket(30, 2, 0);
        if ((v5 & 0x80000000) == 0)
        {
          int v6 = v5;
          [v4 getCString:&v9 maxLength:16 encoding:4];
          if (!ioctl(v6, 0xC0206911uLL, &v9) && (v10 & 1) != 0)
          {
            _BYTE *v2 = 1;
            sub_1000D0210(a1);
            CFDictionaryRef v7 = objc_autoreleasePoolPush();
            if (qword_100219F60) {
              [qword_100219F60 WFLog:@"__WiFiDeviceManagerUpdateInterfaceFlags: interface went up, starting auto-join"];
            }
            objc_autoreleasePoolPop(v7);
            sub_1000F5F98(a1, 0x26uLL);
          }

          close(v6);
        }
      }

      else
      {
        CFDictionaryRef v8 = objc_autoreleasePoolPush();
        if (qword_100219F60) {
          [qword_100219F60 WFLog:@"%s: null ifName" message:4];
        }
        objc_autoreleasePoolPop(v8);
      }
    }
  }

void sub_1001187C0(uint64_t a1, uint64_t a2, const void *a3, uint64_t a4, uint64_t a5, uint64_t *a6)
{
  uint64_t v6 = *a6;
  if (*a6)
  {
    *(_BYTE *)(v6 + 3752) = 0;
    __int128 v9 = objc_autoreleasePoolPush();
    if (qword_100219F60) {
      [(id)qword_100219F60 WFLog:3, "[NWTRANSIT]: %s: network %@, error %d", "__WiFiDeviceManagerColocatedNetworkTransitionAssociationCallback", sub_100095BC8(a3), a5 message];
    }
    objc_autoreleasePoolPop(v9);
    int v10 = sub_100055A48(*(void *)(v6 + 64));
    if ((_DWORD)a5 && v10)
    {
      ++dword_100219DF8;
      uint64_t v11 = objc_autoreleasePoolPush();
      if (qword_100219F60) {
        [qword_100219F60 WFLog:@"[NWTRANSIT]: Transition Attempt Failed. Retry after %d time" message:30];
      }
      objc_autoreleasePoolPop(v11);
      if (dword_100219DF8 <= 3)
      {
        CFRetain((CFTypeRef)v6);
        unsigned int v12 = *(dispatch_queue_s **)(v6 + 240);
        block[0] = _NSConcreteStackBlock;
        block[1] = 3221225472LL;
        block[2] = sub_10011894C;
        block[3] = &unk_1001E2620;
        void block[4] = v6;
        dispatch_async(v12, block);
      }
    }

    else
    {
      dword_100219DF8 = 0;
    }
  }

  else
  {
    int v13 = objc_autoreleasePoolPush();
    if (qword_100219F60) {
      [qword_100219F60 WFLog:@"%s: manager is NULL" message:3];
    }
    objc_autoreleasePoolPop(v13);
  }

void sub_10011894C(uint64_t a1)
{
  ssize_t v2 = *(void **)(a1 + 32);
  if (v2[30])
  {
    uint64_t v3 = (dispatch_source_s *)v2[470];
    dispatch_time_t v4 = dispatch_time(0LL, 30000000000LL);
    dispatch_source_set_timer(v3, v4, 0xFFFFFFFFFFFFFFFFLL, 0LL);
    ssize_t v2 = *(void **)(a1 + 32);
  }

  CFRelease(v2);
}

uint64_t sub_1001189A4(uint64_t a1)
{
  ssize_t v2 = objc_autoreleasePoolPush();
  if (qword_100219F60) {
    [(id)qword_100219F60 WFLog:3, "Dispatching join for =%@", *(void *)(a1 + 32) message];
  }
  objc_autoreleasePoolPop(v2);
  uint64_t v3 = *(void *)(a1 + 40);
  dispatch_time_t v4 = (const void *)sub_100043E8C(*(void *)(v3 + 64));
  return sub_1000E1104(v3, v4, *(void **)(a1 + 32), 0LL, 0LL, (uint64_t)sub_1000FAC90, 0LL, 14LL);
}

void sub_100118A30(uint64_t a1)
{
  ssize_t v2 = (__CFString *)sub_10004CE2C(*(void *)(*(void *)(a1 + 32) + 64LL));
  [*(id *)(*(void *)(a1 + 32) + 7320) addFaultEvent:25 forInterface:sub_10004CE2C(*(void *)(*(void *)(a1 + 32) + 64))];
  if (!v2 || !-[__CFString length](v2, "length"))
  {
    uint64_t v3 = objc_autoreleasePoolPush();
    if (qword_100219F60) {
      [(id)qword_100219F60 WFLog:3, "%s: Invalid interfaceName %@ reason %lu", "__WiFiDeviceManagerHandleSiriTimedOutNotification_block_invoke", v2, 25 message];
    }
    objc_autoreleasePoolPop(v3);
    ssize_t v2 = @"UnknownInterface";
  }

  v5[0] = kWAMessageKeyFaultDate;
  v6[0] = +[NSDate date](&OBJC_CLASS___NSDate, "date");
  v5[1] = kWAMessageKeyFaultName;
  uint64_t v4 = WiFiUsageFaultReasonStringMap(25LL);
  void v5[2] = kWAMessageKeyFaultInterface;
  v6[1] = v4;
  v6[2] = v2;
  sub_100039678( +[NSDictionary dictionaryWithObjects:forKeys:count:]( &OBJC_CLASS___NSDictionary,  "dictionaryWithObjects:forKeys:count:",  v6,  v5,  3LL));
}

void sub_100118B74(uint64_t a1)
{
  ssize_t v2 = (__CFString *)sub_10004CE2C(*(void *)(*(void *)(a1 + 32) + 64LL));
  [*(id *)(*(void *)(a1 + 32) + 7320) addFaultEvent:26 forInterface:sub_10004CE2C(*(void *)(*(void *)(a1 + 32) + 64))];
  if (!v2 || !-[__CFString length](v2, "length"))
  {
    uint64_t v3 = objc_autoreleasePoolPush();
    if (qword_100219F60) {
      [(id)qword_100219F60 WFLog:3, "%s: Invalid interfaceName %@ reason %lu", "__WiFiDeviceManagerHandleApsdTimedOutNotification_block_invoke", v2, 26 message];
    }
    objc_autoreleasePoolPop(v3);
    ssize_t v2 = @"UnknownInterface";
  }

  v5[0] = kWAMessageKeyFaultDate;
  v6[0] = +[NSDate date](&OBJC_CLASS___NSDate, "date");
  v5[1] = kWAMessageKeyFaultName;
  uint64_t v4 = WiFiUsageFaultReasonStringMap(26LL);
  void v5[2] = kWAMessageKeyFaultInterface;
  v6[1] = v4;
  v6[2] = v2;
  sub_100039678( +[NSDictionary dictionaryWithObjects:forKeys:count:]( &OBJC_CLASS___NSDictionary,  "dictionaryWithObjects:forKeys:count:",  v6,  v5,  3LL));
}

void sub_100118CB8(uint64_t a1)
{
  ssize_t v2 = (__CFString *)sub_10004CE2C(*(void *)(*(void *)(a1 + 32) + 64LL));
  [*(id *)(*(void *)(a1 + 32) + 7320) addFaultEvent:30 forInterface:sub_10004CE2C(*(void *)(*(void *)(a1 + 32) + 64))];
  if (!v2 || !-[__CFString length](v2, "length"))
  {
    uint64_t v3 = objc_autoreleasePoolPush();
    if (qword_100219F60) {
      [(id)qword_100219F60 WFLog:3, "%s: Invalid interfaceName %@ reason %lu", "__WiFiDeviceManagerHandleAirplayConnectionStallNotification_block_invoke", v2, 30 message];
    }
    objc_autoreleasePoolPop(v3);
    ssize_t v2 = @"UnknownInterface";
  }

  v5[0] = kWAMessageKeyFaultDate;
  v6[0] = +[NSDate date](&OBJC_CLASS___NSDate, "date");
  v5[1] = kWAMessageKeyFaultName;
  uint64_t v4 = WiFiUsageFaultReasonStringMap(30LL);
  void v5[2] = kWAMessageKeyFaultInterface;
  v6[1] = v4;
  v6[2] = v2;
  sub_100039678( +[NSDictionary dictionaryWithObjects:forKeys:count:]( &OBJC_CLASS___NSDictionary,  "dictionaryWithObjects:forKeys:count:",  v6,  v5,  3LL));
}

void sub_100118DFC(uint64_t a1)
{
  ssize_t v2 = (__CFString *)sub_10004CE2C(*(void *)(*(void *)(a1 + 32) + 64LL));
  [*(id *)(*(void *)(a1 + 32) + 7320) addFaultEvent:31 forInterface:v2];
  if (!v2 || !-[__CFString length](v2, "length"))
  {
    uint64_t v3 = objc_autoreleasePoolPush();
    if (qword_100219F60) {
      [(id)qword_100219F60 WFLog:3, "%s: Invalid interfaceName %@ reason %lu", "__WiFiDeviceManagerHandleAirplayBufferedAudioUnderrunNotification_block_invoke", v2, 31 message];
    }
    objc_autoreleasePoolPop(v3);
    ssize_t v2 = @"UnknownInterface";
  }

  v5[0] = kWAMessageKeyFaultDate;
  v6[0] = +[NSDate date](&OBJC_CLASS___NSDate, "date");
  v5[1] = kWAMessageKeyFaultName;
  uint64_t v4 = WiFiUsageFaultReasonStringMap(31LL);
  void v5[2] = kWAMessageKeyFaultInterface;
  v6[1] = v4;
  v6[2] = v2;
  sub_100039678( +[NSDictionary dictionaryWithObjects:forKeys:count:]( &OBJC_CLASS___NSDictionary,  "dictionaryWithObjects:forKeys:count:",  v6,  v5,  3LL));
}

void sub_100118F34(uint64_t a1)
{
  ssize_t v2 = (__CFString *)sub_10004CE2C(*(void *)(*(void *)(a1 + 32) + 64LL));
  [*(id *)(*(void *)(a1 + 32) + 7320) addFaultEvent:32 forInterface:v2];
  if (!v2 || !-[__CFString length](v2, "length"))
  {
    uint64_t v3 = objc_autoreleasePoolPush();
    if (qword_100219F60) {
      [(id)qword_100219F60 WFLog:3, "%s: Invalid interfaceName %@ reason %lu", "__WiFiDeviceManagerHandleAirplayRealtimeAudioUnderrunNotification_block_invoke", v2, 32 message];
    }
    objc_autoreleasePoolPop(v3);
    ssize_t v2 = @"UnknownInterface";
  }

  v5[0] = kWAMessageKeyFaultDate;
  v6[0] = +[NSDate date](&OBJC_CLASS___NSDate, "date");
  v5[1] = kWAMessageKeyFaultName;
  uint64_t v4 = WiFiUsageFaultReasonStringMap(32LL);
  void v5[2] = kWAMessageKeyFaultInterface;
  v6[1] = v4;
  v6[2] = v2;
  sub_100039678( +[NSDictionary dictionaryWithObjects:forKeys:count:]( &OBJC_CLASS___NSDictionary,  "dictionaryWithObjects:forKeys:count:",  v6,  v5,  3LL));
}

uint64_t sub_10011A27C()
{
  uint64_t result = qword_100219E00;
  if (!qword_100219E00)
  {
    pthread_once(&stru_100219110, (void (*)(void))sub_10011A2B8);
    return qword_100219E00;
  }

  return result;
}

uint64_t sub_10011A2B8()
{
  uint64_t result = _CFRuntimeRegisterClass(&unk_1001E5820);
  qword_100219E00 = result;
  return result;
}

char *sub_10011A2DC(uint64_t a1, uint64_t a2)
{
  if (!&_EAPOLControlKeyCreate) {
    return 0LL;
  }
  if (!qword_100219E00) {
    pthread_once(&stru_100219110, (void (*)(void))sub_10011A2B8);
  }
  uint64_t Instance = (char *)_CFRuntimeCreateInstance(a1);
  int v5 = Instance;
  if (Instance)
  {
    *((_OWORD *)Instance + 5) = 0u;
    *((_OWORD *)Instance + 6) = 0u;
    *((_OWORD *)Instance + 3) = 0u;
    *((_OWORD *)Instance + 4) = 0u;
    *((_OWORD *)Instance + 1) = 0u;
    *((_OWORD *)Instance + 2) = 0u;
    *((void *)Instance + 2) = a2;
    uint64_t v6 = (const __CFString *)sub_10004CE2C(a2);
    CFStringGetCString(v6, v5 + 24, 16LL, 0);
  }

  return v5;
}

uint64_t sub_10011A384(uint64_t result, uint64_t a2, uint64_t a3)
{
  if (result)
  {
    *(void *)(result + 56) = a2;
    *(void *)(result + 64) = a3;
  }

  return result;
}

void sub_10011A390(uint64_t a1, dispatch_queue_s *a2)
{
  if (a1 && a2)
  {
    *(void *)(a1 + 4_Block_object_dispose(va, 8) = a2;
    uint64_t v3 = *(const __SCDynamicStore **)(a1 + 40);
    if (!v3)
    {
      __int128 v22 = 0u;
      memset(v23, 0, sizeof(v23));
      __int128 v20 = 0u;
      __int128 v21 = 0u;
      __int128 v18 = 0u;
      __int128 v19 = 0u;
      __int128 v16 = 0u;
      __int128 v17 = 0u;
      __int128 v14 = 0u;
      __int128 v15 = 0u;
      __int128 v12 = 0u;
      __int128 v13 = 0u;
      __int128 v10 = 0u;
      __int128 v11 = 0u;
      *(_OWORD *)__str = 0u;
      context.version = 0LL;
      memset(&context.retain, 0, 24);
      context.info = (void *)a1;
      snprintf(__str, 0xFFuLL, "WiFiDeviceEAP:%p", *(const void **)(a1 + 16));
      int v5 = CFStringCreateWithCString(kCFAllocatorDefault, __str, 0);
      if (!v5) {
        return;
      }
      uint64_t v6 = v5;
      *(void *)(a1 + 40) = SCDynamicStoreCreate( kCFAllocatorDefault,  v5,  (SCDynamicStoreCallBack)sub_10011A530,  &context);
      CFRelease(v6);
      if (!*(void *)(a1 + 40)) {
        return;
      }
      sub_10011A5BC(a1);
      if (!SCDynamicStoreSetDisconnectCallBack(*(void *)(a1 + 40), sub_10011A634))
      {
        CFDictionaryRef v7 = objc_autoreleasePoolPush();
        if (qword_100219F60) {
          [(id)qword_100219F60 WFLog:4 message:"Error subscribing to the dynamic store disconnect event."];
        }
        objc_autoreleasePoolPop(v7);
      }

      uint64_t v3 = *(const __SCDynamicStore **)(a1 + 40);
      a2 = *(dispatch_queue_s **)(a1 + 48);
    }

    if (!SCDynamicStoreSetDispatchQueue(v3, a2))
    {
      uint64_t v4 = objc_autoreleasePoolPush();
      if (qword_100219F60) {
        [(id)qword_100219F60 WFLog:4 message:"Error setting dynamic store queue."];
      }
      objc_autoreleasePoolPop(v4);
    }
  }

void sub_10011A530(int a1, CFArrayRef theArray, uint64_t a3)
{
  if (*(_DWORD *)(a3 + 96))
  {
    CFIndex Count = CFArrayGetCount(theArray);
    if (Count >= 1)
    {
      CFIndex v6 = Count;
      for (CFIndex i = 0LL; i != v6; ++i)
      {
        if (CFArrayGetValueAtIndex(theArray, i))
        {
          CFDictionaryRef v8 = (const __CFString *)EAPOLControlKeyCopyInterface();
          if (v8)
          {
            __int128 v9 = v8;
            sub_10011B48C(a3, v8);
            CFRelease(v9);
          }
        }
      }
    }
  }

void sub_10011A5BC(uint64_t a1)
{
  values = (void *)EAPOLControlKeyCreate(a1 + 24);
  ssize_t v2 = CFArrayCreate(0LL, (const void **)&values, 1LL, &kCFTypeArrayCallBacks);
  if (values)
  {
    CFRelease(values);
    values = 0LL;
  }

  SCDynamicStoreSetNotificationKeys(*(SCDynamicStoreRef *)(a1 + 40), v2, 0LL);
  if (v2) {
    CFRelease(v2);
  }
}

void sub_10011A634(uint64_t a1, uint64_t a2)
{
  if (a2)
  {
    sub_10011A5BC(a2);
  }

  else
  {
    ssize_t v2 = objc_autoreleasePoolPush();
    if (qword_100219F60) {
      [(id)qword_100219F60 WFLog:4 message:"Cannot reconnect to the dynamic store - info is NULL"];
    }
    objc_autoreleasePoolPop(v2);
  }

uint64_t sub_10011A684(uint64_t result)
{
  if (result)
  {
    uint64_t v1 = result;
    if (*(void *)(result + 48))
    {
      uint64_t result = SCDynamicStoreSetDispatchQueue(*(SCDynamicStoreRef *)(result + 40), 0LL);
      *(void *)(v1 + 4_Block_object_dispose(va, 8) = 0LL;
    }
  }

  return result;
}

uint64_t sub_10011A6BC(uint64_t a1, void *cf1, const void *a3)
{
  uint64_t v3 = 4294963396LL;
  if (a1 && cf1)
  {
    CFDictionaryRef v7 = *(const void **)(a1 + 72);
    if (v7 && CFEqual(cf1, v7) && *(_DWORD *)(a1 + 96) == 5) {
      return sub_10011A990(a1, cf1, a3);
    }
    __int128 v9 = sub_10011AEF4(a1, (CFDictionaryRef *)cf1, a3);
    if (v9)
    {
      __int128 v10 = v9;
      sub_10011B0D4(a1, v9);
      sub_10011B118(a1, cf1);
      __int128 v11 = *(const void **)(a1 + 88);
      if (v11) {
        CFRelease(v11);
      }
      *(void *)(a1 + 96) = 0LL;
      __int128 v12 = (_DWORD *)(a1 + 96);
      *(void *)(a1 + 8_Block_object_dispose(va, 8) = 0LL;
      *(void *)(a1 + 104) = 0LL;
      dispatch_semaphore_t v13 = dispatch_semaphore_create(0LL);
      uint64_t v22 = 0LL;
      id v23 = &v22;
      uint64_t v24 = 0x2020000000LL;
      int v25 = 0;
      dispatch_queue_global_t global_queue = dispatch_get_global_queue(0LL, 0LL);
      block[0] = _NSConcreteStackBlock;
      block[1] = 3221225472LL;
      block[2] = sub_10011B1EC;
      block[3] = &unk_1001E5800;
      void block[5] = &v22;
      void block[6] = a1 + 24;
      void block[4] = v13;
      dispatch_async(global_queue, block);
      dispatch_time_t v15 = dispatch_time(0LL, 3000000000LL);
      if (dispatch_semaphore_wait(v13, v15))
      {
        __int128 v16 = objc_autoreleasePoolPush();
        if (qword_100219F60) {
          [(id)qword_100219F60 WFLog:4 message:"Gave up waiting for EAPOLControlCopyStateAndStatus. Bailing"];
        }
        objc_autoreleasePoolPop(v16);
LABEL_14:
        _DWORD *v12 = 0;
        uint64_t v3 = 4294963394LL;
LABEL_27:
        dispatch_release(v13);
        CFRelease(v10);
        _Block_object_dispose(&v22, 8);
        return v3;
      }

      int v17 = *((_DWORD *)v23 + 6);
      *(_DWORD *)(a1 + 104) = v17;
      if (v17 == 3)
      {
        _DWORD *v12 = 1;
        __int128 v20 = objc_autoreleasePoolPush();
        if (qword_100219F60) {
          [(id)qword_100219F60 WFLog:3 message:"WiFiDeviceEAPAssociate: EAPOLControl already stopping"];
        }
        objc_autoreleasePoolPop(v20);
      }

      else
      {
        if (v17)
        {
          _DWORD *v12 = 1;
          uint64_t v18 = EAPOLControlStop(a1 + 24);
          __int128 v19 = objc_autoreleasePoolPush();
          if (qword_100219F60) {
            [qword_100219F60 WFLog:@"WiFiDeviceEAPAssociate: EAPOLControlStop result=%d" message:3 v18];
          }
        }

        else
        {
          *(_DWORD *)(a1 + 96) = 2;
          uint64_t v18 = EAPOLControlStart(a1 + 24, *(void *)(a1 + 80));
          __int128 v19 = objc_autoreleasePoolPush();
          if (qword_100219F60) {
            [qword_100219F60 WFLog:@"WiFiDeviceEAPAssociate: EAPOLControlStart result=%d" message:3 v18];
          }
        }

        objc_autoreleasePoolPop(v19);
        if ((_DWORD)v18) {
          goto LABEL_14;
        }
      }

      uint64_t v3 = 0LL;
      goto LABEL_27;
    }
  }

  return v3;
}

void sub_10011A978( _Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, ...)
{
}

uint64_t sub_10011A990(uint64_t a1, void *cf1, const void *a3)
{
  uint64_t v3 = 4294963396LL;
  if (a1 && cf1)
  {
    CFDictionaryRef v7 = *(const void **)(a1 + 72);
    if (!v7 || !CFEqual(cf1, v7)) {
      return sub_10011A6BC(a1, cf1);
    }
    CFDictionaryRef v8 = sub_10011AEF4(a1, (CFDictionaryRef *)cf1, a3);
    if (v8)
    {
      __int128 v9 = v8;
      sub_10011B0D4(a1, v8);
      CFTypeRef cf = 0LL;
      __int128 v10 = (unsigned int *)(a1 + 104);
      EAPOLControlCopyStateAndStatus(a1 + 24, a1 + 104, &cf);
      if (cf)
      {
        CFRelease(cf);
        CFTypeRef cf = 0LL;
      }

      __int128 v11 = objc_autoreleasePoolPush();
      if (qword_100219F60) {
        [qword_100219F60 WFLog:@"%s: EAPOLControlCopyStateAndStatus() returned state %d" message:3,  "%s: EAPOLControlCopyStateAndStatus() returned state %d",  "WiFiDeviceEAPUpdate",  *v10];
      }
      objc_autoreleasePoolPop(v11);
      unsigned int v12 = *v10;
      if (*v10 == 3) {
        goto LABEL_67;
      }
      if (v12 != 2)
      {
        if (v12)
        {
          *(_DWORD *)(a1 + 96) = 1;
          uint64_t v3 = EAPOLControlStop(a1 + 24);
          dispatch_semaphore_t v13 = objc_autoreleasePoolPush();
          if (qword_100219F60) {
            [qword_100219F60 WFLog:@"WiFiDeviceEAPUpdate: EAPOLControlStop result=%d" message:3 v3];
          }
        }

        else
        {
          *(_DWORD *)(a1 + 96) = 2;
          uint64_t v3 = EAPOLControlStart(a1 + 24, *(void *)(a1 + 80));
          dispatch_semaphore_t v13 = objc_autoreleasePoolPush();
          if (qword_100219F60) {
            [qword_100219F60 WFLog:@"WiFiDeviceEAPUpdate: EAPOLControlStart result=%d" message:3 v3];
          }
        }

        objc_autoreleasePoolPop(v13);
        if (!(_DWORD)v3) {
          goto LABEL_70;
        }
        goto LABEL_66;
      }

      dispatch_time_t v15 = objc_autoreleasePoolPush();
      if (qword_100219F60) {
        [qword_100219F60 WFLog:@"%s: Starting..." message:3];
      }
      objc_autoreleasePoolPop(v15);
      if (*(void *)(a1 + 88) && (__int128 v16 = *(const __CFDictionary **)(a1 + 80)) != 0LL)
      {
        CFBooleanRef Value = (const __CFDictionary *)CFDictionaryGetValue(v16, @"EAPClientConfiguration");
        uint64_t v18 = Value;
        if (Value && CFDictionaryGetCount(Value))
        {
          CFIndex Count = CFArrayGetCount(*(CFArrayRef *)(a1 + 88));
          __int128 v20 = objc_autoreleasePoolPush();
          CFIndex v40 = Count;
          if (Count)
          {
            if (qword_100219F60) {
              [qword_100219F60 WFLog:@"%s: required array count was %ld" message:3, "%s: required array count was %ld",  "__WiFiDeviceEAPCopyUserInput",  Count];
            }
            objc_autoreleasePoolPop(v20);
            CFMutableDictionaryRef Mutable = CFDictionaryCreateMutable( kCFAllocatorDefault,  0LL,  &kCFTypeDictionaryKeyCallBacks,  &kCFTypeDictionaryValueCallBacks);
            if (Mutable)
            {
              uint64_t v22 = Mutable;
              if (Count >= 1)
              {
                CFIndex v23 = 0LL;
                NSErrorDomain v39 = v18;
                do
                {
                  ValueAtIndex = CFArrayGetValueAtIndex(*(CFArrayRef *)(a1 + 88), v23);
                  int v25 = objc_autoreleasePoolPush();
                  if (qword_100219F60) {
                    [(id)qword_100219F60 WFLog:3, "%s: key value at index %ld is %@", "__WiFiDeviceEAPCopyUserInput", v23, ValueAtIndex message];
                  }
                  objc_autoreleasePoolPop(v25);
                  if (ValueAtIndex)
                  {
                    uint64_t v26 = CFDictionaryGetValue(v18, ValueAtIndex);
                    if (v26)
                    {
                      uint64_t v27 = v26;
                      id v28 = objc_autoreleasePoolPush();
                      if (qword_100219F60) {
                        [(id)qword_100219F60 WFLog:3, "%s: setting key-value pair in userInput for %@", "__WiFiDeviceEAPCopyUserInput", ValueAtIndex message];
                      }
                      objc_autoreleasePoolPop(v28);
                      CFDictionarySetValue(v22, ValueAtIndex, v27);
                      uint64_t v18 = v39;
                    }
                  }

                  ++v23;
                }

                while (v40 != v23);
              }

              if (CFDictionaryGetCount(v22))
              {
LABEL_58:
                __int128 v33 = objc_autoreleasePoolPush();
                if (qword_100219F60)
                {
                  NSErrorDomain v34 = "non-NULL";
                  if (!v22) {
                    NSErrorDomain v34 = "NULL";
                  }
                  [qword_100219F60 WFLog:@"%s: __WiFiDeviceEAPCopyUserInput() returned a %s userInput" message:3,  "%s: __WiFiDeviceEAPCopyUserInput() returned a %s userInput",  "WiFiDeviceEAPUpdate",  v34];
                }

                objc_autoreleasePoolPop(v33);
                if (v22)
                {
                  *(_DWORD *)(a1 + 96) = 4;
                  uint64_t v3 = EAPOLControlProvideUserInput(a1 + 24, v22);
                  unsigned int v35 = objc_autoreleasePoolPush();
                  if (qword_100219F60) {
                    [qword_100219F60 WFLog:@"WiFiDeviceEAPUpdate: EAPOLControlProvideUserInput result=%d" message:3 v3];
                  }
                  objc_autoreleasePoolPop(v35);
                  CFRelease(v22);
                  if (!(_DWORD)v3) {
                    goto LABEL_70;
                  }
LABEL_66:
                  *(_DWORD *)(a1 + 96) = 0;
                  uint64_t v3 = 4294963394LL;
LABEL_70:
                  CFRelease(v9);
                  return v3;
                }

CFDictionaryRef sub_10011AEF4(uint64_t a1, CFDictionaryRef *a2, const void *a3)
{
  CFIndex v6 = sub_100094FD8(a2, a3);
  CFDictionaryRef v7 = v6;
  if (!a3)
  {
    if (v6)
    {
      CFBooleanRef Value = (const __CFDictionary *)CFDictionaryGetValue(v6, @"EAPClientConfiguration");
      if (Value)
      {
        __int128 v9 = CFDictionaryGetValue(Value, @"UserPassword");
        __int128 v10 = (CFDictionaryRef *)CFRetain(a2);
        if (v10)
        {
          __int128 v11 = v10;
          if (sub_100095318((BOOL)v10))
          {
            BOOL v12 = v9 != 0LL;
            while (sub_100098BF8((uint64_t)v11) && !v12)
            {
              dispatch_semaphore_t v13 = objc_autoreleasePoolPush();
              if (qword_100219F60) {
                [(id)qword_100219F60 WFLog:4, "%s: did not manage to find password for HS2.0 account %@. Looking for next matching account...", "__WiFiDeviceCopyPreparedEAPProfile", sub_100095BC8(v11) message];
              }
              objc_autoreleasePoolPop(v13);
              uint64_t v14 = *(void *)(a1 + 16);
              uint64_t v15 = sub_10004CE2C(v14);
              __int128 v16 = (CFDictionaryRef *)sub_10004CA54(v14, v15, (uint64_t)v11);
              CFRelease(v11);
              if (!v16)
              {
                __int128 v19 = objc_autoreleasePoolPush();
                if (qword_100219F60) {
                  [(id)qword_100219F60 WFLog:4, "%s: did not manage to find password for HS2.0 network %@. No more matching HS2.0 account", "__WiFiDeviceCopyPreparedEAPProfile", sub_100095BC8(a2) message];
                }
                objc_autoreleasePoolPop(v19);
                return v7;
              }

              if (v7) {
                CFRelease(v7);
              }
              __int128 v11 = v16;
              int v17 = sub_100094FD8(v16, 0LL);
              CFDictionaryRef v7 = v17;
              BOOL v12 = v17
                 && (uint64_t v18 = (const __CFDictionary *)CFDictionaryGetValue(v17, @"EAPClientConfiguration")) != 0LL
                 && CFDictionaryGetValue(v18, @"UserPassword") != 0LL;
              if (!sub_100095318((BOOL)v11)) {
                break;
              }
            }
          }

          CFRelease(v11);
        }
      }
    }
  }

  return v7;
}

void sub_10011B0D4(uint64_t a1, CFTypeRef cf)
{
  uint64_t v4 = *(const void **)(a1 + 80);
  if (v4) {
    CFRelease(v4);
  }
  *(void *)(a1 + 80) = cf;
  if (cf) {
    CFRetain(cf);
  }
}

void sub_10011B118(uint64_t a1, CFTypeRef cf)
{
  uint64_t v4 = *(const void **)(a1 + 72);
  if (v4) {
    CFRelease(v4);
  }
  *(void *)(a1 + 72) = cf;
  if (cf) {
    CFRetain(cf);
  }
}

void sub_10011B15C(uint64_t a1, CFTypeRef cf)
{
  uint64_t v4 = *(const void **)(a1 + 88);
  if (v4) {
    CFRelease(v4);
  }
  *(void *)(a1 + 8_Block_object_dispose(va, 8) = cf;
  if (cf)
  {
    CFRetain(cf);
    int v5 = objc_autoreleasePoolPush();
    if (qword_100219F60) {
      [(id)qword_100219F60 WFLog:3, "%s: eapRef required set to:\n%@", "__WiFiDeviceEAPSetRequired", *(void *)(a1 + 88) message];
    }
    objc_autoreleasePoolPop(v5);
  }

uint64_t sub_10011B1EC(uint64_t a1)
{
  CFTypeRef cf = 0LL;
  EAPOLControlCopyStateAndStatus(*(void *)(a1 + 48), *(void *)(*(void *)(a1 + 40) + 8LL) + 24LL, &cf);
  if (cf)
  {
    CFRelease(cf);
    CFTypeRef cf = 0LL;
  }

  return dispatch_semaphore_signal(*(dispatch_semaphore_t *)(a1 + 32));
}

uint64_t sub_10011B244(uint64_t a1)
{
  return *(unsigned int *)(a1 + 104);
}

void sub_10011B24C(uint64_t a1, const void *a2, int a3)
{
  if (a1)
  {
    sub_10011B2A8(a1, a2, a3);
    if (!*(_DWORD *)(a1 + 96))
    {
      uint64_t v4 = *(const void **)(a1 + 72);
      if (v4) {
        CFRelease(v4);
      }
      *(void *)(a1 + 72) = 0LL;
      int v5 = *(const void **)(a1 + 80);
      if (v5) {
        CFRelease(v5);
      }
      *(void *)(a1 + 80) = 0LL;
      CFIndex v6 = *(const void **)(a1 + 88);
      if (v6) {
        CFRelease(v6);
      }
      *(void *)(a1 + 8_Block_object_dispose(va, 8) = 0LL;
    }
  }

void sub_10011B2A8(uint64_t a1, CFTypeRef cf1, int a3)
{
  CFTypeRef cf = 0LL;
  if (a1)
  {
    uint64_t v4 = *(const void **)(a1 + 72);
    if (v4)
    {
      if (!cf1 || CFEqual(cf1, v4))
      {
        if (a3)
        {
          uint64_t v6 = *(void *)(a1 + 16);
          CFDictionaryRef v7 = (const void *)sub_100043E8C(v6);
          sub_10004ED80(v6, v7, 0LL, 1012, "__WiFiDeviceEAPCancel", 984LL);
        }

        unsigned int v8 = *(_DWORD *)(a1 + 96);
        if (v8)
        {
          if (v8 <= 4 && (__int128 v9 = *(void (**)(uint64_t, uint64_t, void, void))(a1 + 56)) != 0LL)
          {
            *(_DWORD *)(a1 + 96) = 0;
            v9(a1, 4294963391LL, 0LL, *(void *)(a1 + 64));
            if (*(_DWORD *)(a1 + 96)) {
              return;
            }
          }

          else
          {
            *(_DWORD *)(a1 + 96) = 0;
          }
        }

        uint64_t v10 = a1 + 24;
        __int128 v11 = (_DWORD *)(a1 + 104);
        EAPOLControlCopyStateAndStatus(v10, v11, &cf);
        if (cf)
        {
          CFRelease(cf);
          CFTypeRef cf = 0LL;
        }

        if ((*v11 - 1) <= 1)
        {
          EAPOLControlStop(v10);
          BOOL v12 = objc_autoreleasePoolPush();
          if (qword_100219F60) {
            [(id)qword_100219F60 WFLog:3 message:"WiFiDeviceEAPCancel: EAPOLControlStop"];
          }
          objc_autoreleasePoolPop(v12);
        }
      }
    }
  }

void sub_10011B3D4(uint64_t a1)
{
  if (a1)
  {
    ssize_t v2 = objc_autoreleasePoolPush();
    if (qword_100219F60) {
      [(id)qword_100219F60 WFLog:3 message:"Aborting EAP"];
    }
    objc_autoreleasePoolPop(v2);
    uint64_t v3 = *(const void **)(a1 + 72);
    if (v3) {
      sub_10011B24C(a1, v3, 1);
    }
  }

void sub_10011B440(void *a1)
{
  ssize_t v2 = (const void *)a1[9];
  if (v2)
  {
    CFRelease(v2);
    a1[9] = 0LL;
  }

  uint64_t v3 = (const void *)a1[10];
  if (v3)
  {
    CFRelease(v3);
    a1[10] = 0LL;
  }

  uint64_t v4 = (const void *)a1[5];
  if (v4)
  {
    CFRelease(v4);
    a1[5] = 0LL;
  }

void sub_10011B48C(uint64_t a1, const __CFString *a2)
{
  unsigned int v64 = 0;
  CFDictionaryRef theDict = 0LL;
  *(void *)buffer = 0LL;
  uint64_t v66 = 0LL;
  if (!*(void *)(a1 + 72)) {
    goto LABEL_98;
  }
  CFStringGetCString(a2, buffer, 16LL, 0);
  if (theDict)
  {
    CFBooleanRef Value = (const __CFDictionary *)CFDictionaryGetValue(theDict, @"AdditionalProperties");
    if (Value)
    {
      int v5 = (const __CFDictionary *)CFDictionaryGetValue(Value, @"EAPAKASIMNotificationActionInfo");
      if (v5)
      {
        uint64_t v6 = (const __CFNumber *)CFDictionaryGetValue(v5, @"Code");
        CFDictionaryRef v7 = sub_10003AC9C(v6);
        sub_10009582C( *(void *)(a1 + 72),  @"JOIN_EXTENDED_STATUS",  +[NSNumber numberWithInt:](&OBJC_CLASS___NSNumber, "numberWithInt:", v7));
      }
    }
  }

  unsigned int v8 = objc_autoreleasePoolPush();
  if (qword_100219F60) {
    [qword_100219F60 WFLog:@"EAP: eapState=%d" message:3];
  }
  objc_autoreleasePoolPop(v8);
  if (!v64)
  {
    uint64_t v16 = *(void *)(a1 + 80);
    if (!v16) {
      goto LABEL_98;
    }
    if (*(_DWORD *)(a1 + 96) == 1)
    {
      *(_DWORD *)(a1 + 10_Block_object_dispose(va, 8) = 0;
      *(void *)(a1 + 100) = 0LL;
      *(_DWORD *)(a1 + 96) = 2;
      uint64_t v17 = EAPOLControlStart(a1 + 24, v16);
      uint64_t v18 = objc_autoreleasePoolPush();
      if (qword_100219F60) {
        [qword_100219F60 WFLog:message:3, @"WiFiDeviceEAPAssociate: EAPOLControlStart from Idle result=%d", v17];
      }
      objc_autoreleasePoolPop(v18);
      if ((_DWORD)v17) {
        int v19 = -369033216;
      }
      else {
        int v19 = 0;
      }
      uint64_t v20 = v19 | v17;
      if (!(_DWORD)v20) {
        goto LABEL_98;
      }
    }

    else
    {
      __int128 v21 = objc_autoreleasePoolPush();
      if (qword_100219F60) {
        [(id)qword_100219F60 WFLog:3 message:"WiFiDeviceEAP: EAPOLControl state went Idle while joining"];
      }
      objc_autoreleasePoolPop(v21);
      uint64_t v20 = 4294963391LL;
    }

    uint64_t v22 = a1;
    int v23 = 0;
LABEL_32:
    sub_10011C08C(v22, 0LL, v20, v23);
    goto LABEL_98;
  }

  if (v64 != 2) {
    goto LABEL_98;
  }
  __int128 v9 = theDict;
  int v10 = *(_DWORD *)(a1 + 96);
  if (v10 == 4)
  {
    if (!theDict)
    {
      *(_DWORD *)(a1 + 104) = 2;
      return;
    }

    uint64_t v24 = (const __CFNumber *)CFDictionaryGetValue(theDict, @"ClientStatus");
    if (!v24) {
      goto LABEL_98;
    }
    int v25 = sub_10003AC9C(v24);
    uint64_t v26 = (const __CFNumber *)CFDictionaryGetValue(v9, @"SupplicantState");
    unsigned int v27 = sub_10003AC9C(v26);
    id v28 = objc_autoreleasePoolPush();
    if (qword_100219F60)
    {
      if (v27 > 8) {
        NSErrorDomain v29 = "<unknown>";
      }
      else {
        NSErrorDomain v29 = off_1001E5880[v27];
      }
      objc_msgSend((id)qword_100219F60, "WFLog:message:", 3, "EAP: Status=%u SupplicationStatus=%s", v25, v29);
    }

    objc_autoreleasePoolPop(v28);
    if ((_DWORD)v25 == 20) {
      goto LABEL_97;
    }
    if ((_DWORD)v25 != 3)
    {
      if (!(_DWORD)v25)
      {
        if (v27 - 7 < 2)
        {
          goto LABEL_97;
        }

        if (v27 != 4) {
          goto LABEL_97;
        }
        *(_DWORD *)(a1 + 96) = 0;
        __int128 v46 = *(void (**)(uint64_t, void, void, void))(a1 + 56);
        if (v46) {
          v46(a1, 0LL, 0LL, *(void *)(a1 + 64));
        }
        if (*(void *)(a1 + 72))
        {
          uint64_t v47 = *(void *)(a1 + 16);
          __int128 v48 = objc_autoreleasePoolPush();
          if (v47)
          {
            if (qword_100219F60) {
              [qword_100219F60 WFLog:@"%s: Checking if EAP network requires WoW Eapol filter to be set" message:3];
            }
            objc_autoreleasePoolPop(v48);
            __int128 v49 = objc_autoreleasePoolPush();
            __int128 v50 = +[ManagedConfigWrapper sharedInstance](&OBJC_CLASS___ManagedConfigWrapper, "sharedInstance");
            if (v50
              && -[ManagedConfigWrapper isWiFiNetworkMDMNetwork:](v50, "isWiFiNetworkMDMNetwork:", *(void *)(a1 + 72)))
            {
              __int128 v51 = objc_autoreleasePoolPush();
              if (qword_100219F60) {
                [qword_100219F60 WFLog:@"%s: EAP network was added by MDM" message:3];
              }
              objc_autoreleasePoolPop(v51);
            }

            else
            {
              objc_autoreleasePoolPop(v49);
              uint64_t v52 = (const __CFNumber *)sub_1000951FC(*(void *)(a1 + 72), @"WiFiManagerKnownNetworksEventType");
              if (!v52) {
                goto LABEL_97;
              }
              unsigned int valuePtr = 0;
              CFNumberGetValue(v52, kCFNumberIntType, &valuePtr);
              if (valuePtr != 17) {
                goto LABEL_97;
              }
              __int128 v49 = objc_autoreleasePoolPush();
              if (qword_100219F60) {
                [qword_100219F60 WFLog:@"%s: EAP network was added via .mobileconfig profile" message:3];
              }
            }

            objc_autoreleasePoolPop(v49);
            unsigned int valuePtr = 1;
            CFNumberRef v53 = CFNumberCreate(kCFAllocatorDefault, kCFNumberSInt32Type, &valuePtr);
            if (v53)
            {
              uint64_t v54 = (uint64_t)v53;
              uint64_t v55 = *(void *)(a1 + 16);
              BOOL v56 = (const void *)sub_100043E8C(v55);
              sub_10003EC6C(v55, v56, 497LL, 0LL, v54);
              BOOL v57 = objc_autoreleasePoolPush();
              if (qword_100219F60) {
                [qword_100219F60 WFLog:@"%s: Enabling Eapol filter for WoW" message:3];
              }
              objc_autoreleasePoolPop(v57);
              uint64_t v58 = (const void *)v54;
LABEL_96:
              CFRelease(v58);
            }

void sub_10011BDF0(uint64_t a1, uint64_t a2, const void *a3, uint64_t a4, uint64_t a5, uint64_t a6)
{
  __int128 v9 = objc_autoreleasePoolPush();
  if (a3)
  {
    if (qword_100219F60)
    {
      int v10 = sub_100095BC8(a3);
      uint64_t v11 = "failed";
      if (!(_DWORD)a5) {
        uint64_t v11 = "succeeded";
      }
      BOOL v12 = +[NSString stringWithFormat:]( &OBJC_CLASS___NSString,  "stringWithFormat:",  @"%s",  -[NSString UTF8String]( +[NSString stringWithFormat:]( &OBJC_CLASS___NSString,  "stringWithFormat:",  @"{%@-} %@",  @"EAP",  +[NSString stringWithFormat:]( &OBJC_CLASS___NSString,  "stringWithFormat:",  @"EAP: Inner Association of %@ %s (%d)",  v10,  v11,  a5)),  "UTF8String"));
      if (os_log_type_enabled((os_log_t)&_os_log_default, OS_LOG_TYPE_ERROR))
      {
LABEL_11:
        *(_DWORD *)__int128 buf = 136446210;
        uint64_t v16 = -[NSString UTF8String]( +[NSString stringWithFormat:]( &OBJC_CLASS___NSString,  "stringWithFormat:",  @"[WiFiPolicy] %s",  -[NSString UTF8String](v12, "UTF8String")),  "UTF8String");
        _os_log_impl( (void *)&_mh_execute_header,  (os_log_t)&_os_log_default,  OS_LOG_TYPE_ERROR,  "%{public}s",  buf,  0xCu);
      }
    }
  }

  else if (qword_100219F60)
  {
    dispatch_semaphore_t v13 = "failed";
    if (!(_DWORD)a5) {
      dispatch_semaphore_t v13 = "succeeded";
    }
    BOOL v12 = +[NSString stringWithFormat:]( &OBJC_CLASS___NSString,  "stringWithFormat:",  @"%s",  -[NSString UTF8String]( +[NSString stringWithFormat:]( &OBJC_CLASS___NSString,  "stringWithFormat:",  @"{%@-} %@",  @"EAP",  +[NSString stringWithFormat:]( &OBJC_CLASS___NSString,  "stringWithFormat:",  @"EAP: Inner Association %s (%d)",  v13,  a5)),  "UTF8String"));
    if (os_log_type_enabled((os_log_t)&_os_log_default, OS_LOG_TYPE_ERROR)) {
      goto LABEL_11;
    }
  }

  objc_autoreleasePoolPop(v9);
  if (*(_DWORD *)(a6 + 96) == 3)
  {
    if ((_DWORD)a5)
    {
      sub_10011C08C(a6, 0LL, a5, 0);
    }

    else
    {
      *(_DWORD *)(a6 + 96) = 4;
      uint64_t v14 = sub_10004CE2C(*(void *)(a6 + 16));
      sub_10011B48C(a6, v14);
    }
  }

void sub_10011C08C(uint64_t a1, uint64_t a2, uint64_t a3, int a4)
{
  *(_DWORD *)(a1 + 96) = 0;
  switch((_DWORD)a3)
  {
    case 0:
      goto LABEL_5;
    case 0xEA010014:
      return;
    case 0xEA010003:
      *(_DWORD *)(a1 + 96) = 5;
LABEL_5:
      CFDictionaryRef v7 = *(void (**)(uint64_t, uint64_t, uint64_t, void))(a1 + 56);
      if (v7) {
        v7(a1, a3, a2, *(void *)(a1 + 64));
      }
      return;
  }

  sub_10011B2A8(a1, 0LL, a4);
  unsigned int v8 = *(void (**)(uint64_t, uint64_t, uint64_t, void))(a1 + 56);
  if (v8) {
    v8(a1, a3, a2, *(void *)(a1 + 64));
  }
  if (!*(_DWORD *)(a1 + 96))
  {
    __int128 v9 = *(const void **)(a1 + 72);
    if (v9) {
      CFRelease(v9);
    }
    *(void *)(a1 + 72) = 0LL;
    int v10 = *(const void **)(a1 + 80);
    if (v10) {
      CFRelease(v10);
    }
    *(void *)(a1 + 80) = 0LL;
    uint64_t v11 = *(const void **)(a1 + 88);
    if (v11) {
      CFRelease(v11);
    }
    *(void *)(a1 + 8_Block_object_dispose(va, 8) = 0LL;
  }

void sub_10011C504(_Unwind_Exception *a1)
{
}

void sub_10011C5A8(_Unwind_Exception *a1)
{
}

void sub_10011C620(_Unwind_Exception *a1)
{
}

void sub_10011C6C4(_Unwind_Exception *a1)
{
}

void sub_10011C714(_Unwind_Exception *a1)
{
}

void sub_10011C780(_Unwind_Exception *a1)
{
}

void sub_10011C7E4(_Unwind_Exception *a1)
{
}

void sub_10011C84C(_Unwind_Exception *a1)
{
}

void sub_10011D458( _Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, ...)
{
}

void sub_10011D470(uint64_t a1, uint64_t a2)
{
}

void sub_10011D480(uint64_t a1)
{
}

void sub_10011D48C(void *a1)
{
  ssize_t v2 = objc_autoreleasePoolPush();
  if (a1[4])
  {
    id v3 = +[NSMutableDictionary dictionary](&OBJC_CLASS___NSMutableDictionary, "dictionary");
    __int128 v9 = 0u;
    __int128 v10 = 0u;
    __int128 v11 = 0u;
    __int128 v12 = 0u;
    id v4 = [*(id *)(a1[5] + 48) allKeys];
    id v5 = [v4 countByEnumeratingWithState:&v9 objects:v13 count:16];
    if (v5)
    {
      id v6 = v5;
      uint64_t v7 = *(void *)v10;
      do
      {
        unsigned int v8 = 0LL;
        do
        {
          if (*(void *)v10 != v7) {
            objc_enumerationMutation(v4);
          }
          objc_msgSend( v3,  "setObject:forKeyedSubscript:",  objc_msgSend( objc_msgSend( *(id *)(a1[5] + 48),  "objectForKeyedSubscript:",  *(void *)(*((void *)&v9 + 1) + 8 * (void)v8)),  "objectForKeyedSubscript:",  a1[4]),  *(void *)(*((void *)&v9 + 1) + 8 * (void)v8));
          unsigned int v8 = (char *)v8 + 1;
        }

        while (v6 != v8);
        id v6 = [v4 countByEnumeratingWithState:&v9 objects:v13 count:16];
      }

      while (v6);
    }

    if ([v3 count]) {
      *(void *)(*(void *)(a1[6] + 8) + 4kdebug_trace(731381764, 0, 0, 0, 0) = [v3 copy];
    }
  }

  objc_autoreleasePoolPop(v2);
}

void sub_10011D650(void *a1)
{
  ssize_t v2 = objc_autoreleasePoolPush();
  if (a1[4] && a1[5])
  {
    id v3 = objc_msgSend(*(id *)(a1[6] + 48), "objectForKeyedSubscript:");
    if (!v3)
    {
      id v3 = +[NSMutableDictionary dictionary](&OBJC_CLASS___NSMutableDictionary, "dictionary");
      [*(id *)(a1[6] + 48) setObject:v3 forKeyedSubscript:a1[5]];
    }

    [v3 setObject:a1[7] forKeyedSubscript:a1[4]];
  }

  objc_autoreleasePoolPop(v2);
}

void sub_10011DB94(uint64_t a1, uint64_t a2, uint64_t a3, int a4, uint64_t a5)
{
  if (!a4)
  {
    if (a5)
    {
      CFDictionaryRef v7 = sub_100012CEC(a5);
      if (v7)
      {
        CFDictionaryRef v8 = v7;
        objc_msgSend( *(id *)(a1 + 32),  "__setPeerAssistedDiscoveryNetwork:interfaceName:UUID:",  v7,  *(void *)(a1 + 40),  objc_msgSend(*(id *)(a1 + 48), "UUID"));
        CFRelease(v8);
      }
    }
  }

  if ([*(id *)(a1 + 56) response])
  {
    __int128 v9 = (void (**)(id, NSError *, void))[*(id *)(a1 + 56) response];
    if (a4) {
      __int128 v10 = +[NSError errorWithDomain:code:userInfo:]( &OBJC_CLASS___NSError,  "errorWithDomain:code:userInfo:",  CWFManagerErrorDomain,  a4,  0LL);
    }
    else {
      __int128 v10 = 0LL;
    }
    v9[2](v9, v10, 0LL);
  }
}

void sub_10011DC60( uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, void (**a6)(void, void, void, void, void, void))
{
  __int128 v12 = objc_autoreleasePoolPush();
  if (a6)
  {
    a6[2](a6, a1, a2, a3, a4, a5);
    _Block_release(a6);
  }

  objc_autoreleasePoolPop(v12);
}

void sub_10011DEC4(uint64_t a1, uint64_t a2, uint64_t a3, int a4)
{
  if (!a4) {
    objc_msgSend( *(id *)(a1 + 32),  "__setPeerAssistedDiscoveryNetwork:interfaceName:UUID:",  0,  *(void *)(a1 + 40),  objc_msgSend(*(id *)(a1 + 48), "UUID"));
  }
  if ([*(id *)(a1 + 56) response])
  {
    id v6 = (void (**)(id, NSError *, void))[*(id *)(a1 + 56) response];
    if (a4) {
      CFDictionaryRef v7 = +[NSError errorWithDomain:code:userInfo:]( &OBJC_CLASS___NSError,  "errorWithDomain:code:userInfo:",  CWFManagerErrorDomain,  a4,  0LL);
    }
    else {
      CFDictionaryRef v7 = 0LL;
    }
    v6[2](v6, v7, 0LL);
  }
}

void sub_10011DF6C( uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, void (**a5)(void, void, void, void, void))
{
  __int128 v10 = objc_autoreleasePoolPush();
  if (a5)
  {
    a5[2](a5, a1, a2, a3, a4);
    _Block_release(a5);
  }

  objc_autoreleasePoolPop(v10);
}

void sub_10011E3EC(uint64_t a1, uint64_t a2, unsigned int a3, void *a4)
{
  id v6 = objc_autoreleasePoolPush();
  if ([a4 response])
  {
    CFDictionaryRef v7 = (void (**)(id, NSError *, void))[a4 response];
    if (a3) {
      CFDictionaryRef v8 = +[NSError errorWithDomain:code:userInfo:]( &OBJC_CLASS___NSError,  "errorWithDomain:code:userInfo:",  CWFManagerErrorDomain,  a3,  0LL);
    }
    else {
      CFDictionaryRef v8 = 0LL;
    }
    v7[2](v7, v8, 0LL);
  }

  objc_autoreleasePoolPop(v6);
}

void sub_1001202EC(uint64_t a1, const void *a2, void *a3, uint64_t a4, int a5, void *a6)
{
  __int128 v12 = objc_autoreleasePoolPush();
  id v13 = [a6 info];
  id v14 = [v13 objectForKeyedSubscript:CWFXPCAssocParamsKey];
  uint64_t v15 = CWFGetOSLog(v14);
  if (v15) {
    uint64_t v16 = (os_log_s *)CWFGetOSLog(v15);
  }
  else {
    uint64_t v16 = (os_log_s *)&_os_log_default;
  }
  if (os_log_type_enabled(v16, OS_LOG_TYPE_DEFAULT))
  {
    int v47 = 67109120;
    LODWORD(v4_Block_object_dispose(va, 8) = a5;
    _os_log_send_and_compose_impl( 1LL,  0LL,  0LL,  0LL,  &_mh_execute_header,  v16,  0LL,  "[corewifi] __WiFiDeviceManagerAssociationCallback to CoreWiFi with error:%d\n",  &v47);
  }

  if (a5)
  {
    uint64_t v17 = +[NSError errorWithDomain:code:userInfo:]( &OBJC_CLASS___NSError,  "errorWithDomain:code:userInfo:",  CWFManagerErrorDomain,  a5,  a4);
    goto LABEL_47;
  }

  if ([v14 rememberUponSuccessfulAssociation])
  {
    id v18 = [sub_1000951FC((uint64_t)a3, @"WiFiManagerKnownNetworksEventType") intValue];
    sub_10009A194(a3, 1, +[NSDate date](&OBJC_CLASS___NSDate, "date"));
    int v19 = sub_1000D8D10(a1, a3);
    uint64_t v20 = CWFGetOSLog(v19);
    if (v20) {
      __int128 v21 = (os_log_s *)CWFGetOSLog(v20);
    }
    else {
      __int128 v21 = (os_log_s *)&_os_log_default;
    }
    if (os_log_type_enabled(v21, OS_LOG_TYPE_INFO))
    {
      uint64_t v22 = sub_100095BC8(v19);
      int v47 = 136315394;
      __int128 v48 = "__WiFiDeviceManagerAssociationCallback";
      __int16 v49 = 2112;
      __int128 v50 = v22;
      _os_log_send_and_compose_impl( 1LL,  0LL,  0LL,  0LL,  &_mh_execute_header,  v21,  1LL,  "[corewifi] %s: WiFiDeviceManagerCopyMatchingMergedNetwork() returned known network %@",  &v47,  22);
    }

    if (v19)
    {
      if (sub_10009E120((uint64_t)a3) == 2) {
        sub_100077498( (uint64_t)[WiFiXPCManager sharedXPCManager] getWiFiManager,  a3,  1u);
      }
      if (sub_1000951FC((uint64_t)a3, @"WiFiNetworkNANServiceID")) {
        sub_100077498( (uint64_t)[+[WiFiXPCManager sharedXPCManager](WiFiXPCManager, "sharedXPCManager") getWiFiManager],  a3,  1u);
      }
      sub_1000DACEC(a1, a3);
    }

    else
    {
      int v23 = sub_1000D3348(a1, a2);
      if (v23)
      {
        uint64_t v24 = v23;
        sub_10009AB20(a3, v23);
        CFRelease(v24);
      }

      if (_os_feature_enabled_impl("CoreWiFi", "UnifiedAutoJoin"))
      {
        id v25 = sub_1000E359C(a1);
        if (v25)
        {
          uint64_t v26 = v25;
          int v27 = [WiFiXPCManager sharedXPCManager].getWiFiManager;
          [v26 coordinate];
          CLLocationDegrees v29 = v28;
          [v26 coordinate];
          CLLocationDegrees v31 = v30;
          [v26 horizontalAccuracy];
          sub_10007E304(v27, a3, v29, v31, v32, [v26 timestamp]);
        }

        if (sub_1000E041C(a1))
        {
          CFAbsoluteTime Current = CFAbsoluteTimeGetCurrent();
          CFDateRef v34 = CFDateCreate(kCFAllocatorDefault, Current);
          if (v34)
          {
            CFDateRef v35 = v34;
            sub_10009B324(a3, v34);
            CFRelease(v35);
          }
        }
      }

      if (objc_msgSend(objc_msgSend(v14, "knownNetworkProfile"), "isPublicAirPlayNetwork")) {
        sub_1000A5834( (uint64_t)a3,  (int)objc_msgSend(objc_msgSend(v14, "knownNetworkProfile"), "isPublicAirPlayNetwork"));
      }
      sub_100072038( +[WiFiXPCManager sharedXPCManager](WiFiXPCManager, "sharedXPCManager"),  a3,  v18);
      BOOL v36 = sub_10006DC84((uint64_t)objc_msgSend( +[WiFiXPCManager sharedXPCManager]( WiFiXPCManager,  "sharedXPCManager"),  "getWiFiManager"))
         && (sub_1000DACEC(a1, a3) & 1) != 0;
      sub_1000F97D4(a1, (uint64_t)a3, v36);
      sub_1000FA43C(a1);
      int v19 = CFRetain(a3);
      uint64_t v37 = CWFGetOSLog(v19);
      if (v37) {
        uint64_t v38 = (os_log_s *)CWFGetOSLog(v37);
      }
      else {
        uint64_t v38 = (os_log_s *)&_os_log_default;
      }
      if (os_log_type_enabled(v38, OS_LOG_TYPE_INFO))
      {
        NSErrorDomain v39 = sub_100095BC8(v19);
        int v47 = 136315394;
        __int128 v48 = "__WiFiDeviceManagerAssociationCallback";
        __int16 v49 = 2112;
        __int128 v50 = v39;
        LODWORD(v46) = 22;
        _os_log_send_and_compose_impl( 1LL,  0LL,  0LL,  0LL,  &_mh_execute_header,  v38,  1LL,  "[corewifi] %s: knownNetwork now points to %@",  &v47,  v46);
      }
    }

    if (sub_100098BF8((uint64_t)v19) || (BOOL v40 = sub_1000984F0((BOOL)v19)))
    {
      CFMutableArrayRef v41 = (const __CFString *)objc_msgSend(objc_msgSend(v14, "EAPCredentials"), "password");
      if (v41 || (CFMutableArrayRef v41 = (const __CFString *)[v14 password]) != 0) {
        sub_100099C50(v19, v41);
      }
      if (!v19) {
        goto LABEL_46;
      }
    }

    else
    {
      uint64_t v43 = CWFGetOSLog(v40);
      if (v43) {
        __int128 v44 = (os_log_s *)CWFGetOSLog(v43);
      }
      else {
        __int128 v44 = (os_log_s *)&_os_log_default;
      }
      if (os_log_type_enabled(v44, OS_LOG_TYPE_INFO))
      {
        __int128 v45 = sub_100095BC8(v19);
        int v47 = 136315650;
        __int128 v48 = "__WiFiDeviceManagerAssociationCallback";
        __int16 v49 = 2112;
        __int128 v50 = v45;
        __int16 v51 = 2112;
        uint64_t v52 = v19;
        LODWORD(v46) = 32;
        _os_log_send_and_compose_impl( 1LL,  0LL,  0LL,  0LL,  &_mh_execute_header,  v44,  1LL,  "[corewifi] %s: deleting password for known network %@ as that network does not use a password. Network spec: %@",  &v47,  v46);
      }

      sub_100099D38(v19);
      if (!v19) {
        goto LABEL_46;
      }
    }

    CFRelease(v19);
  }

void sub_1001211A4(uint64_t a1, uint64_t a2, const __CFArray *a3, int a4, void *a5)
{
  __int128 v9 = objc_autoreleasePoolPush();
  if (a4)
  {
    if ([a5 response])
    {
      __int128 v10 = (void (**)(id, NSError *, void))[a5 response];
      v10[2]( v10,  +[NSError errorWithDomain:code:userInfo:]( &OBJC_CLASS___NSError,  "errorWithDomain:code:userInfo:",  CWFManagerErrorDomain,  a4,  0LL),  0LL);
    }
  }

  else
  {
    id v11 = [a5 info];
    id v12 = [v11 objectForKeyedSubscript:CWFXPCScanParamsKey];
    if (_os_feature_enabled_impl("CoreWiFi", "WiFi6EMaxCompatibility"))
    {
      __int128 v23 = 0u;
      __int128 v24 = 0u;
      __int128 v21 = 0u;
      __int128 v22 = 0u;
      id v13 = objc_msgSend(v12, "channels", 0);
      id v14 = [v13 countByEnumeratingWithState:&v21 objects:v25 count:16];
      if (v14)
      {
        id v15 = v14;
        uint64_t v16 = *(void *)v22;
        while (2)
        {
          for (CFIndex i = 0LL; i != v15; CFIndex i = (char *)i + 1)
          {
            if (*(void *)v22 != v16) {
              objc_enumerationMutation(v13);
            }
            if ([*(id *)(*((void *)&v21 + 1) + 8 * (void)i) band] == 2)
            {
              goto LABEL_16;
            }
          }

          id v15 = [v13 countByEnumeratingWithState:&v21 objects:v25 count:16];
          if (v15) {
            continue;
          }
          break;
        }
      }

      [v12 mergeScanResults];
    }

void sub_1001216F4(uint64_t a1, uint64_t a2, const __CFArray *a3, int a4, void *a5)
{
  CFDictionaryRef v8 = objc_autoreleasePoolPush();
  if (a4)
  {
    if ([a5 response])
    {
      __int128 v9 = (void (**)(id, NSError *, void))[a5 response];
      v9[2]( v9,  +[NSError errorWithDomain:code:userInfo:]( &OBJC_CLASS___NSError,  "errorWithDomain:code:userInfo:",  CWFManagerErrorDomain,  a4,  0LL),  0LL);
    }
  }

  else
  {
    id v10 = +[NSMutableArray array](&OBJC_CLASS___NSMutableArray, "array");
    if (a3 && CFArrayGetCount(a3) >= 1)
    {
      CFIndex v11 = 0LL;
      do
      {
        ValueAtIndex = CFArrayGetValueAtIndex(a3, v11);
        if (ValueAtIndex)
        {
          id v13 = sub_1000A335C((uint64_t)ValueAtIndex);
          if (v13) {
            [v10 addObject:v13];
          }
        }

        ++v11;
      }

      while (CFArrayGetCount(a3) > v11);
    }

    id v14 = [a5 info];
    uint64_t v15 = CWFFilteredANQPResults(v10, [v14 objectForKeyedSubscript:CWFXPCANQPParamsKey]);
    id v16 = +[NSMutableDictionary dictionary](&OBJC_CLASS___NSMutableDictionary, "dictionary");
    [v16 setObject:v15 forKeyedSubscript:CWFXPCResultKey];
    if ([a5 response])
    {
      uint64_t v17 = (void (**)(id, void, id))[a5 response];
      v17[2](v17, 0LL, v16);
    }
  }

  objc_autoreleasePoolPop(v8);
}

void sub_100121B7C(uint64_t a1, uint64_t a2, const __CFArray *a3, int a4, void *a5)
{
  CFDictionaryRef v8 = objc_autoreleasePoolPush();
  if (a4)
  {
    if ([a5 response])
    {
      __int128 v9 = (void (**)(id, NSError *, void))[a5 response];
      v9[2]( v9,  +[NSError errorWithDomain:code:userInfo:]( &OBJC_CLASS___NSError,  "errorWithDomain:code:userInfo:",  CWFManagerErrorDomain,  a4,  0LL),  0LL);
    }
  }

  else
  {
    if (a3)
    {
      id v10 = +[NSMutableArray array](&OBJC_CLASS___NSMutableArray, "array");
      if (CFArrayGetCount(a3) >= 1)
      {
        id v25 = v8;
        uint64_t v26 = a5;
        CFIndex v11 = 0LL;
        int v27 = a3;
        double v28 = v10;
        do
        {
          ValueAtIndex = (void *)CFArrayGetValueAtIndex(a3, v11);
          if (ValueAtIndex)
          {
            id v13 = ValueAtIndex;
            CFIndex v30 = v11;
            id v14 = objc_alloc_init(&OBJC_CLASS___CWFRangingResult);
            [v14 setMACAddress:[v13 objectForKeyedSubscript:@"STATION_MAC"]];
            [v14 setIdentifier:[v13 objectForKeyedSubscript:@"RANGING_TOKEN_ID"]];
            objc_msgSend(objc_msgSend(v13, "objectForKeyedSubscript:", @"RANGING_DISTANCE"), "doubleValue");
            [v14 setDistance:];
            objc_msgSend(objc_msgSend(v13, "objectForKeyedSubscript:", @"RANGING_SD"), "doubleValue");
            [v14 setStandardDeviation:];
            objc_msgSend( v14,  "setStatus:",  objc_msgSend(objc_msgSend(v13, "objectForKeyedSubscript:", @"RANGING_STATUS"), "intValue"));
            CLLocationDegrees v29 = v14;
            [v14 setNumberOfValidMeasurements:[[v13 objectForKeyedSubscript:@"RANGING_VALID_COUNT"] unsignedIntegerValue]];
            id v15 = +[NSMutableArray array](&OBJC_CLASS___NSMutableArray, "array");
            id v16 = [v13 objectForKeyedSubscript:@"RANGING_RESULTS"];
            __int128 v31 = 0u;
            __int128 v32 = 0u;
            __int128 v33 = 0u;
            __int128 v34 = 0u;
            id v17 = [v16 countByEnumeratingWithState:&v31 objects:v35 count:16];
            if (v17)
            {
              id v18 = v17;
              uint64_t v19 = *(void *)v32;
              do
              {
                uint64_t v20 = 0LL;
                do
                {
                  if (*(void *)v32 != v19) {
                    objc_enumerationMutation(v16);
                  }
                  __int128 v21 = *(void **)(*((void *)&v31 + 1) + 8LL * (void)v20);
                  id v22 = objc_alloc_init(&OBJC_CLASS___CWFRangingMeasurement);
                  objc_msgSend( v22,  "setRoundTripTime:",  objc_msgSend(objc_msgSend(v21, "objectForKeyedSubscript:", @"RANGING_RTT"), "integerValue"));
                  objc_msgSend( v22,  "setRSSI:",  objc_msgSend(objc_msgSend(v21, "objectForKeyedSubscript:", @"RANGING_RSSI"), "integerValue"));
                  objc_msgSend( v22,  "setChannel:",  objc_msgSend( objc_msgSend(v21, "objectForKeyedSubscript:", @"RANGING_CHANNEL"),  "unsignedIntegerValue"));
                  objc_msgSend( v22,  "setSNR:",  objc_msgSend(objc_msgSend(v21, "objectForKeyedSubscript:", @"RANGING_SNR"), "integerValue"));
                  objc_msgSend( v22,  "setCoreID:",  objc_msgSend( objc_msgSend(v21, "objectForKeyedSubscript:", @"RANGING_CORE_ID"),  "unsignedIntegerValue"));
                  [v15 addObject:v22];
                  uint64_t v20 = (char *)v20 + 1;
                }

                while (v18 != v20);
                id v18 = [v16 countByEnumeratingWithState:&v31 objects:v35 count:16];
              }

              while (v18);
            }

            [v29 setMeasurements:CGSizeMake(v15, v25, v26)];
            id v10 = v28;
            [v28 addObject:v29];
            a3 = v27;
            CFIndex v11 = v30;
          }

          ++v11;
        }

        while (CFArrayGetCount(a3) > v11);
        CFDictionaryRef v8 = v25;
        a5 = v26;
      }
    }

    else
    {
      id v10 = 0LL;
    }

    id v23 = +[NSMutableDictionary dictionary](&OBJC_CLASS___NSMutableDictionary, "dictionary", v25, v26);
    [v23 setObject:v10 forKeyedSubscript:CWFXPCResultKey];
    if ([a5 response])
    {
      __int128 v24 = (void (**)(id, void, id))[a5 response];
      v24[2](v24, 0LL, v23);
    }
  }

  objc_autoreleasePoolPop(v8);
}